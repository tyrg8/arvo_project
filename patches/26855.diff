commit 20988977ab5425cec88c7ffe0e1e648e1373698c
Merge: 076e7e3a9 39899582d
Author: John Cupitt <jcupitt@gmail.com>
Date:   Tue Nov 3 23:45:17 2020 +0000

    Merge branch '8.10'

diff --git a/ChangeLog b/ChangeLog
index d1e24f6e1..196be7e67 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,544 +1,545 @@
 14/8/20 started 8.11
 - add vips_jpegload_source() and vips_svgload_source() to public C API
 - integrate doxygen in build system to generate C++ API docs
 - improve C++ API doc comments
 - add VipsInterpolate and guint64 support to C++ API 
 - add VImage::new_from_memory_steal [Zeranoe]
 - vipsthumbnail supports stdin / stdout thumbnailing
 - have a lock just for pdfium [DarthSim]
 - better GraphicsMagick image write [bfriesen]
 - get pdfium load building again [Projkt-James]
 - add _source load support for pdfium
 
 18/10/20 started 8.10.3
 - relax heic is_a rules [hisham]
 - fix vips7 webp load [barryspearce]
 - fix out of bounds exif read in heifload
 - fix out of bounds read in tiffload
+- fix tiffsave region shrink mode [imgifty]
 
 6/9/20 started 8.10.2
 - update magicksave/load profile handling [kelilevi]
 - better demand hint rules [kaas3000]
 - fix tiff thumbnail from buffer and source [vansante]
 - in jpegsave, don't set JFIF resolution if we set EXIF resolution
 - bump minimum libheif version to 1.3 [lovell]
 - dzsave in iiif mode could set info.json dimensions off by one [Linden6]
 - pdfload allows dpi and scale to both be set [le0daniel]
 - allow gaussblur sigma zero, meaning no blur
 - better heif signature detection [lovell]
 - fix vips_fractsurf() typo [kleisauke]
 - better heif EOF detection [lovell]
 - fix gir build with g-o-i 1.66+ [László]
 - improve seek behaviour on pipes
 - add "speed" param to heifsave [lovell]
 - fix regression in C path for dilate / erode [kleisauke]
 - fix build with libheif save but no load [estepnv]
 
 9/8/20 started 8.10.1
 - fix markdown -> xml conversion in doc generation
 - remove typedef redefinitions to please old gccs
 - fix regression in tiff pyramid thumbnailing [tand826]
 - stop 0-length buffer being passed to imagemagick [lovell]
 - convert no-profile CMYK to RGB on save [augustocdias]
 - ensure SVG loader skips input with chars outside x09-x7F range [lovell]
 - better mask sizing in gaussmat [johntrunc]
 - fix tiffsave "squash" handling [barryspearce]
 - fix jpegload autorotate [chregu]
 - only start the background render thread on first use
 
 24/1/20 started 8.10.0
 - more conformat IIIF output from dzsave [regisrob]
 - add @id to dzsave to set IIIF id property [regisrob]
 - add max and min to region shrink [rgluskin]
 - allow \ as an escape character in vips_break_token() [akemrir]
 - tiffsave has a "depth" param to set max pyr depth
 - libtiff LOGLUV images load and save as libvips XYZ 
 - add gifload_source, csvload_source, csvsave_target, matrixload_source,
   matrixsave_source, pdfload_source, heifload_source, heifsave_target,
   ppmload_source, ppmsave_target
 - revise vipsthumbnail flags
 - add VIPS_LEAK env var
 - add vips_pipe_read_limit_set(), --vips-pipe-read-limit,
   VIPS_PIPE_READ_LIMIT
 - revise gifload to fix BACKGROUND and PREVIOUS dispose [alon-ne]
 - add subsample_mode, deprecate no_subsample in jpegsave [Elad-Laufer]
 - add vips_isdirf()
 - add PAGENUMBER support to tiff write [jclavoie-jive]
 - add "all" mode to smartcrop 
 - flood fill could stop half-way for some very complex shapes
 - better handling of unaligned reads in multipage tiffs [petoor]
 - mark old --delete option to vipsthumbnail as deprecated [UweOhse]
 - png save with a bad ICC profile just gives a warning
 - add "premultipled" option to vips_affine(), clarified vips_resize() 
   behaviour with alpha channels
 - improve bioformats support with read and write of tiff subifd pyramids
 - thumbnail exploits subifd pyramids
 - handle all EXIF orientation cases, deprecate 
   vips_autorot_get_angle() [Elad-Laufer]
 - load PNGs with libspng, if possible
 - deprecate heifload autorotate -- it's now always on
 - revised resize improves accuracy [kleisauke]
 - add --vips-config flag to show configuration info
 - add "bitdepth" param to tiff save, deprecate "squash" [MathemanFlo]
 - tiff load and save now supports 2 and 4 bit data [MathemanFlo]
 - pngsave @bitdepth parameter lets you write 1, 2 and 4 bit PNGs
 - ppmsave also uses "bitdepth" now, for consistency
 - reduce operation cache max to 100
 - rework the final bits of vips7 for vips8 [kleisauke]
 - --disable-deprecated now works [kleisauke]
 - vipsheader allows "stdin" as a filename
 - gifload allows gifs with images outside the canvas
 - wasm compatibility patches [kleisauke]
 - webpsave has a @profile param
 
 24/4/20 started 8.9.3
 - better iiif tile naming [IllyaMoskvin]
 
 31/1/19 started 8.9.2
 - fix a deadlock with --vips-leak [DarthSim]
 - better gifload behaviour for DISPOSAL_UNSPECIFIED [DarthSim]
 - ban ppm max_value < 0 
 - add fuzz corpus to dist
 - detect read errors correctly in source_sniff
 - fix regression in autorot [malomalo]
 - thumbnail on HEIC images could select the thumbnail incorrectly under some
   size modes [ZorinArsenij]
 
 20/6/19 started 8.9.1
 - don't use the new source loaders for new_from_file or new_from_buffer, it
   will break the loader priority system
 - fix thumbnail autorot [janko]
 - fix a warning with magicksave with no delay array [chregu]
 - fix a race in tiled tiff load [kleisauke]
 - better imagemagick init [LebronCurry]
 - lock for metadata changes [jcupitt]
 
 20/6/19 started 8.9.0
 - add vips_image_get/set_array_int()
 - disable webp alpha output if all frame fill the canvas and are solid
 - support arrays of delays for animated images [deftomat]
 - add "unlimited" flag to svgload
 - disable webp alpha output if all frames fill the canvas and are solid
 - add "compression" option to heifsave [lovell]
 - support webp and zstd compression in tiff
 - loaders use "minimise" to close input files earlier
 - integrate support for oss-fuzz [omira-sch]
 - add vips_switch() / vips_case() ... fast many-way ifthenelse
 - better const handling for arithmetic operators fixes comparisons against out
   of range values
 - sharpen restores input colourspace
 - handle alpha in heifload / heifsave [meyermarcel]
 - add @interpretation and @format to rawload
 - nifti load/save uses double for all floating point metadata
 - add vips_error_buffer_copy()
 - add VipsSource and VipsTarget: a universal IO class for loaders and savers
 - jpeg, png, tiff (though not tiffsave), rad, svg, ppm and webp use the 
   new IO class
 - rewritten ppm load/save is faster and uses less memory
 - add @no_strip option to dzsave [kalozka1]
 - add iiif layout to dzsave
 - fix use of resolution-unit metadata on tiff save [kayarre]
 - support TIFF CIELAB images with alpha [angelmixu]
 - support TIFF with premultiplied alpha in any band 
 - block metadata changes on shared images [pvdz]
 - RGB and sRGB are synonmous
 
 17/9/19 started 8.8.4
 - improve compatibility with older imagemagick versions
 - remove realpath, since it can fail on systems with grsec
 
 31/8/19 started 8.8.3
 - revert sharpen restoring the input colourspace
 - xres/yres tiffsave params were in pixels/cm [f--f]
 
 9/7/19 started 8.8.2
 - better early shutdown in readers
 - don't attempt to save large XMP to jpeg [tnextday]
 - always fetch HEIC metadata from the main image [zhoux2016]
 - fix loop in malformed ppm [Kyle-Kyle]
 - better support for PNGs with long comment names
 - fix build with GM
 - add locks for pdfium load
 - fix build with MSVC 
 - fix a problem with shinkv tail processing [angelmixu]
 - fix a read one byte beyond buffer bug in jpegload
 - make GIF parsing less strict
 - better feof() handling in GIF load
 - clip coding and interpretation on vips image read
 - check image bounds for GIF load
 - prevent over-pre-shrink in thumbnail [kleisauke]
 - fix sharpen with sigma 0.5 [2h4dl]
 - sharpen restores input colourspace
 - verify bands/format for coded images
 - improve data_length handling for jpeg metadata
 
 24/5/19 started 8.8.1
 - improve realpath() use on older libc
 - better magickload error messages
 - more consistent behaviour for page-height metadata
 - fix for composite with many small images and some combinations of blend modes
 - fix memleak in tiff pyr save to memory [scossu]
 - istiff attempts to read the first directory rather than just testing the
   magic number [przemyslawpluta]
 - much faster ismagick() [jcupitt]
 - better behaviour for vips_region_fetch() if request lies partly ouside image
 - remove 256 band limit in arithmetic.c [erdmann]
 - disable Orc if building with CET [lovell]
 - fix vipsthumbnail with pyr tiff [kleisauke]
 - text autofit could occasionally terminate early [levmorozov]
 - fewer warnings on tiffload [chregu]
 - vips_resize() breaks aspect ratio and limits shrink to prevent <1px 
   dimensions [lovell]
 
 21/9/18 started 8.8.0
 - much faster smartcrop [lovell]
 - add low/high to smartcrop [jcupitt]
 - add XMP support to png read/write [jcupitt]
 - deprecate thumbnail auto_rotate, add no_rotate [jcupitt]
 - implement thumbnail shrink-on-load for openslide images [jcupitt]
 - add animated webp support [jcupitt]
 - revise vips_cast() to improve behaviour with uint images [erdmann]
 - add bandand()/or()/eor() to cplusplus binding [clcaalu]
 - implement shrink-on-load for tiff pyramids [jcupitt]
 - added vips_image_set_blob_copy() [jcupitt]
 - don't stop composite on first non-transparent image [felixbuenemann, GDmac]
 - add vips_rect_overlapsrect()
 - composite is much faster at positioning subimages
 - stop tiff pyr layers if width or height drop to 1 [gvincke]
 - dzsave has a new skip_blanks option
 - add vips_CMYK2XYZ() and vips_XYZ2CMYK(), plus associated routes 
 - include cmyk and srgb fallback profiles
 - add vips_profile_load() and use it everywhere
 - fix race in temp filename creation [lhecker]
 - add @reduction_effort param to webpsave [lovell]
 - add @option_string param to thumbnail_buffer [kleisauke]
 - add XMP, IPCT, ICC, EXIF etc. support to magickload/magicksave
 - much lower memuse for gifload
 - tilecache speedups
 - add vips_heifload(), vips_heifsave()
 - add heif thumbnail support to vips_thumbnail()
 - free threadpool earlier, reducing mem growth for some long-running 
   processes [jtorresfabra]
 - add vips_region_fetch() / _width() / _height() for language bindings
 - vips_text() supports justification
 - move vips_image_set_kill() and iskilled() to the public API
 - dzsave to szi sets suffix correctly [martinweihrauch]
 - dzsave szi writes "scan-properties.xml"
 - add vips_image_(get|set)_image()
 - add openslideload option to attach all associated images as metadata
 - dzsave to szi will write all associated images
 - remove old c++ and python interfaces
 - vipsthumbnail can thumbnail animated and multipage images
 - deprecate webpload @shrink, use @scale instead
 
 31/3/19 started 8.7.5
 - better buffer sizing in tiff reader [omira-sch]
 
 4/1/19 started 8.7.4
 - magickload with magick6 API did not chain exceptions correctly causing a
   memory leak under some conditions [kleisauke]
 - zero memory on allocate to prevent write of uninitialized memory under some 
   error conditions [Balint Varga-Perke]
 
 21/11/18 started 8.7.3
 - fix infinite loop for autofit with non-scaleable font 
 - mapim was not offsetting by window offset [erdmann]
 - better rounding for scale [kleisauke]
 - fix a memleak in magick6load [kleisauke]
 
 21/11/18 started 8.7.2
 - more info output for temp files to help diagnose problems
 - vips_text() could set the wrong DPI
 - vips_text() leaked in autofit mode
 
 23/9/18 started 8.7.1
 - update function list in docs [janko-m] 
 - test for g_str_to_ascii() [jcupitt]
 - fix temp file open on Windows and fallback on linux [lovell]
 
 23/12/17 started 8.7.0
 - add magicksave, save image with libMagick [dlemstra]
 - remove jpeg thumbnail from EXIF if "jpeg-thumbnail-data" has been removed by
   user
 - hough_line scales width to 0 - 180, not 0 - 360
 - hough_line is 4x faster
 - hough_circle is 2x faster
 - add vips_sobel() and vips_canny() edge detectors
 - add vips_rotate() ... a convenience method for vips_similarity()
 - svgload was missing is_a [lovell]
 - better header sniffing for small files
 - drop incompatible ICC profiles before save
 - better hasalpha rules
 - create funcs always make MULTIBAND (ie. no alpha)
 - use O_TMPFILE, if available [Alexander--]
 - set "interlaced=1" for interlaced JPG and PNG images
 - add PDFium PDF loader
 - jpegload adds a jpeg-chroma-subsample field with eg. 4:4:4 for no
   chrominance subsampling. 
 - tiffload, pdfload, magickload set VIPS_META_N_PAGES "n-pages" metadata item
 - add fontfile option to vips_text() [fangqiao]
 - add vips_transpose3d() -- swap major dimensions in a volumetric image
 - remove vips7 stuff from default API ... you must now #include it explicitly
 - added vips_argument_get_id() to fix derived classes on win32 [angelmixu]
 - fix compile with MSVC 2017 [angelmixu]
 - pdfload has a option for background 
 - vips7 C++ interface defaults off
 - make members, getters and operators "const" in cpp API
 - composite has params for x/y position of sub-images [medakk]
 - add Mitchell kernel
 - pyramid builders have a choice of 2x2 shrinkers [harukizaemon]
 - add `palette` option to pngsave [felixbuenemann]
 - add basic nifti load/save support
 - support writing string-valued fields via libexif
 - paste in the test suite from pyvips
 - get EXIF tag names from tag plus ifd [@Nan619]
 - escape ASCII control characters in XML
 - magickload now sniffs some file types itself
 - update radiance load from upstream
 - add region_shrink to tiffsave
 - mapim could fail for float index images with coordinates out of int range
 - scale openexr alpha to 0 - 255
 - close input earlier, when we can [kleisauke]
 - add vips_object_get_args() for language bindings [kleisauke]
 
 12/3/18 started 8.6.4
 - better fitting of fonts with overhanging edges [Adrià]
 - revise C++ example [fangqiao]
 - strict round down on jpeg shrink on load [davidwood]
 - configure test for g++ 7.2 and composite.cpp
 - don't Ping in magickload, too unreliable
 - ensure WebP can add metadata when compiled with libwebpmux [lovell]
 - improve accuracy of vector path convolution [felixbuenemann]
 
 12/2/18 started 8.6.3
 - use pkg-config to find libjpeg, if we can
 - better clean of output image in vips_image_write() fixes a crash 
   writing twice to memory
 - better rounding behaviour in convolution means we hit the vector path more
   often
 - fix a crash if a delayed load failed [gsharpsh00ter]
 - icc_import attaches the fallback profile if it used it
 
 5/1/18 started 8.6.2
 - vips_sink_screen() keeps a ref to the input image ... stops a rare race
 - fix a minor accidental ABI break in 8.6.0 -> 8.6.1 [remicollet]
 - fix read of plane-separate TIFFs with large strips [remicollet]
 - fix a C++ warning in composite.cpp [lovell]
 - remove number of images limit in composite
 - composite allows 1 mode ... reused for all joins
 - fix race in vips_sink() for seq read 
 
 10/12/17 started 8.6.1
 - fix mmap window new/free cycling 
 - fix some compiler warnings
 - remove the 64-image limit on bandary operations
 - better version date [bmwiedemann]
 - bump wrapper script version [bgilbert]
 - fix a memleak on error during jpeg buffer write [lovell]
 - fix misspelling of IPTC as IPCT [lovell]
 - seq could be set on small images opened in random-access mode [aferrero2707]
 - fix small memleak in dzsave [lovell]
 - small speedup for rgb->g [lovell]
 
 15/4/17 started 8.6.0
 - supports fits images with leading non-image HDUs, thanks benepo
 - add vips_image_new_from_image() and vips_image_new_from_image1() ... make a
   constant image
 - add new_from_image() to Python as well
 - slight change to cpp new_from_image() to match py/C behaviour
 - vips_conv(), vips_compass(), vips_convsep() default to FLOAT precision
 - add FORCE resize mode to break aspect ratio
 - add vips_thumbnail_image()
 - better prefix guessing on Windows, thanks tumagonx
 - savers support a "page_height" option for multipage save
 - rename 'disc' as 'memory' and default off
 - add vips_find_trim(), search for non-background areas 
 - remove lcms1 support, it had bitrotted
 - `join` tagged as seq
 - support tiffsave_buffer for pyramids, thanks bubba
 - thumbnail and vipsthumbnail have an option for rendering intent, thanks 
   kleisauke 
 - set file create time on Windows, thanks dlong500
 - remove python tests ... moved to pyvips test suite
 - vips7 and vips8 python bindings default to off ... use the new pyvips
   binding instead
 - better svgload: larger output, handle missing width/height, thanks lovell
 - add vips_gravity() ... embed, but with direction rather than position
 - vips_text() can autofit text to a box, thanks gargsms
 - add vips_composite() / vips_composite2(): merge a set of images with 
   a set of blend modes
 - better gobject-introspection annotations, thanks astavale 
 - vips_image_write() severs all links between images, when it can ... thanks
   Warren and Nakilon
 - vector path for convolution is more accurate and can handle larger masks
 - linear and cubic kernels for reduce are higher quality
 - added vips_value_set_blob_free()
 - "--size Nx" to vipsthumbnail was broken, thanks jrochkind 
 - fix build with gcc 7
 - add vips_fill_nearest() ... fill pixels with nearest colour
 - add VIPS_COMBINE_MIN, a new combining mode for vips_compass()
 - vips_hist_find_indexed() now has a @combine parameter
 - vips_affine() and vips_similarity() have a "background" parameter
 - fix nasty jaggies on the edges of affine output, thanks chregu
 - add gif-delay, gif-comment and gif-loop metadata
 - add dispose handling to gifload
 - dzsave outputs extra right and bottom overlap-only tiles, for closer spec
   adherence
 - deprecate the "centre" option for vips_resize(): it's now always on
 - setting the EXIF data block automatically sets other image tags
 - add "extend" option to affine; resize uses it to stop black edges
 
 29/8/17 started 8.5.9
 - make --fail stop jpeg read on any libjpeg warning, thanks @mceachen
 - don't build enumtypes so often, removing perl as a compile dependency
 - fix a crash with heavy use of draw operations from language bindings, 
   thanks @Nakilon 
 
 2/8/17 started 8.5.8
 - fix transparency detection in merge, thanks Haida
 - define env var VIPS_WARNING to hide warning messages
 - shut down dzsave output earlier to help mark-sweep bindings
 - fix webp thumbnail upscale, thanks Kleis
 
 9/6/17 started 8.5.7
 - better smartcrop
 - transform cmyk->rgb automatically on write if there's an embedded profile
   and the saver does not support cmyk
 - fix DPI mixup in svgload ... we were writing images about 20% too large,
   thanks Fosk
 
 19/5/17 started 8.5.6
 - tiff read with start page > 0 could break edge tiles or strips
 - raise b64 limit to allow for huge profiles (thanks jaume)
 - fix error return in blob save (thanks jaume)
 - tag vipsprofile as py2 (thanks ioquatix)
 - don't cache thumbnail (thanks tomasc)
 
 23/4/17 started 8.5.5
 - doc polishing
 - more improvements for truncated PNG files, thanks juyunsang 
 - improve corrupted jpg handling, thanks juyunsang
 - fix small test suite issues on os x
 
 23/4/17 started 8.5.4
 - don't depend on image width when setting n_lines, thanks kleisauke
 
 7/4/17 started 8.5.3
 - more link fixing in docs 
 - revise cache sizing again to help out of order errors under heavy load, thanks
   kleisauke
 
 25/3/17 started 8.5.2
 - better behaviour for truncated PNG files, thanks Yury
 - missing proto for vips_tiffsave_buffer(), thanks greut
 - move some docs from the wiki and blog into core libvips docs
 - add support for markdown in docs
 
 25/3/17 started 8.5.1
 - init more classes earlier, thanks David
 
 13/10/16 started 8.5.0
 - rewritten buffer system is safer and frees memory earlier
 - added tiff save to buffer
 - added dzsave save to buffer (zip only)
 - revise header get/set functions
 - better vipsheader behaviour with complex field types
 - added vips_image_hasalpha()
 - added vips_thumbnail() / vips_thumbnail_buffer()
 - webpload/webpsave read and write icc, xmp, exif metadata
 - better >4gb detect for zip dzsave output [Felix Bünemann]
 - all loaders have a @fail option, meaning fail on first warning, though it
   only does anything for jpg and csv
 - add vips_image_get_fields() to help bindings
 - add tiff multi-page read/write
 - add VIPS_META_PAGE_HEIGHT metadata
 - IM6/IM7 magickload supports page/n/page-height, all_frames deprecated
 - gifload supports n/page-height
 - added #defines for VIPS_SONAME, VIPS_LIBRARY_CURRENT, VIPS_LIBRARY_REVISION,
   VIPS_LIBRARY_AGE
 - better support for bscale / bzero in fits images
 - deprecate vips_warn() / vips_info(); use g_warning() / g_info() instead
 - vipsthumbnail supports much fancier geometry strings, thanks tomasc
 - vips_thumbnail() has new @size option
 - fix --vips-cache-max etc. 
 - add compute reordering, plus some new API to support it:
   vips_reorder_margin_hint() and vips_reorder_prepare_many(), thanks
   aferrero2707
 - kick load operations from cache on read error, thanks gaillard 
 - fix return from C++ assignment operator overloads (+=, -= etc) 
 - add @max_slope to vips_hist_local() to implement CLAHE, thanks hunter-87
 - vips_gaussnoise() pixels are reproducible on recalc, thanks MvGulik
 - max/min sort values by y and x coordinate
 - tiff read uses libtiff scanline API if rows-per-strip is large
 - vips_region_shrink() knows about alpha, helps dzsave and tiffsave
 - use expat, not libxml, for XML load ... removes a required dependency, since
   we get expat as part of glib
 - new sequential mode infrastructure is faster and more flexible
 - add vips_smartcrop(), based on sharp's smartcropper
 - vipsthumbnail has a --smartcrop option
 - added vips_rot90() etc. convenience functions
 - fix vips_resize() bug when hscale and vscale were very different
 
 8/12/16 started 8.4.5
 - allow libgsf-1.14.26 to help centos, thanks tdiprima
 
 11/11/16 started 8.4.4
 - fix crash in vips.exe arg parsing on Windows, thanks Yury
 
 18/10/16 started 8.4.3
 - fix error detection in gif_close, thanks aaron42net
 - fix tiny threading memleak
 - improve compatibility with very old glib, see #548
 
 27/9/16 started 8.4.2
 - small doc improvements
 - fix error message for metadata fetch type mismatch
 - resolve a race condition in thread shutdown, thanks Lovell
 
 1/5/16 started 8.4
 - many more wepsave options [Felix Bünemann]
 - added quant_table option to wepsave [Felix Bünemann]
 - added @n option to pdfload, thanks andris
 - dzsave won't write empty tiles in google mode, thanks bverem, perog,
   felixbuenemann
 - allow nested [] in CLI args
 - restore BandFmt on unpremultiply in vipsthumbnail
 - better python detection and build [Felix Bünemann]
 - max-alpha defaults to 65535 for RGB16/GREY16
 - added radsave_buffer [Henri Chain]
 - support tiff orientation tag
 - autorotate option for tiff load
 - tiffsave converts for jpg if jpg compression is turned on
 - tiffsave supports --strip
 - conversions to GREY16 could lock
 - free pixel buffers on image close as well as thread exit ... stops main 
   thread buffers clogging up the system
 - dzsave can write compressed zips [Felix Bünemann]
 - vips_image_write() only refs the input when it has to ... makes it easier to
   combine many images in bounded memory
 - VImage::write() implementation was missing
 - VImage::write() return value changed from void to VImage to help chaining
 - added C++ arithmetic assignment overloads, += etc. 
 - VImage::ifthenelse() with double args was missing =0 on options
 - better accuracy for reducev with smarter multiplication
 - better quality for vips_resize() with linear/cubic kernels 
 - pyvips8 can create new metadata
 - better upsizing with vips_resize()
 - add imagemagick v7 support, thanks sachinwalia2k8 
 - added vips_worley(), vips_perlin() noise generators
 - added vips_convf(), vips_convi(), vips_convasep(), vips_conva() ... 
   im_conv*() functions rewritten as classes
 - vips_convsep() calls vips_convasep() for the approximate case
 - new fixed-point vector path for convi is up to about 2x faster
 - gif loader can make 1, 2, 3, or 4 bands depending on file contents
 - support --strip for pngsave
 - add svgz support [Felix Bünemann]
 - rename boostrap.sh -> autogen.sh to help snapcraft
 - support unicode filenames on Windows 
 - added VIPS_ROUND as well as VIPS_RINT
 - resize/reduce*/shrink*/affine now round output size to nearest rather than 
   rounding down, thanks ioquatix
 - better support for tile overlaps in google maps mode in dzsave
 - dzsave puts vips-properties.xml in the main dir for gm and zoomify layouts
 - resize and reduce have @centre option for centre convention downsampling
 - vipsthumbnail uses centre convention to better match imagemagick
diff --git a/libvips/foreign/vips2tiff.c b/libvips/foreign/vips2tiff.c
index a4331b771..1ea738953 100644
--- a/libvips/foreign/vips2tiff.c
+++ b/libvips/foreign/vips2tiff.c
@@ -1588,71 +1588,72 @@ static int
 layer_strip_shrink( Layer *layer )
 {
 	Layer *below = layer->below;
 	VipsRegion *from = layer->strip;
 	VipsRegion *to = below->strip;
 
 	VipsRect target;
 	VipsRect source;
 
 	/* Our pixels might cross a strip boundary in the layer below, so we
 	 * have to write repeatedly until we run out of pixels.
 	 */
 	for(;;) {
 		/* The pixels the layer below needs.
 		 */
 		target.left = 0;
 		target.top = below->write_y;
 		target.width = below->image->Xsize;
 		target.height = to->valid.height;
 		vips_rect_intersectrect( &target, &to->valid, &target );
 
 		/* Those pixels need this area of this layer. 
 		 */
 		source.left = target.left * 2;
 		source.top = target.top * 2;
 		source.width = target.width * 2;
 		source.height = target.height * 2;
 
 		/* Of which we have these available.
 		 */
 		vips_rect_intersectrect( &source, &from->valid, &source );
 
 		/* So these are the pixels in the layer below we can provide.
 		 */
 		target.left = source.left / 2;
 		target.top = source.top / 2;
 		target.width = source.width / 2;
 		target.height = source.height / 2;
 
 		/* None? All done.
 		 */
 		if( vips_rect_isempty( &target ) )
 			break;
 
-		(void) vips_region_shrink( from, to, &target );
+		(void) vips_region_shrink_method( from, to, &target,
+			layer->wtiff->region_shrink );
 
 		below->write_y += target.height;
 
 		/* If we've filled the strip below, let it know.
 		 * We can either fill the region, if it's somewhere half-way
 		 * down the image, or, if it's at the bottom, get to the last
 		 * real line of pixels.
 		 */
 		if( below->write_y == VIPS_RECT_BOTTOM( &to->valid ) ||
 			below->write_y == below->height ) {
 			if( layer_strip_arrived( below ) )
 				return( -1 );
 		}
 	}
 
 	return( 0 );
 }
 
 /* A new strip has arrived! The strip has at least enough pixels in to 
  * write a line of tiles or a set of scanlines.  
  *
  * - write a line of tiles / set of scanlines
  * - shrink what we can to the layer below
  * - move our strip down by the tile height
  * - copy the overlap with the previous strip
  */
diff --git a/test/test-suite/test_foreign.py b/test/test-suite/test_foreign.py
index 0e51bdbd7..e4f847bae 100644
--- a/test/test-suite/test_foreign.py
+++ b/test/test-suite/test_foreign.py
@@ -23,1066 +23,1063 @@ from helpers import \
 class TestForeign:
     tempdir = None
 
     @classmethod
     def setup_class(cls):
         cls.tempdir = tempfile.mkdtemp()
 
         cls.colour = pyvips.Image.jpegload(JPEG_FILE)
         cls.mono = cls.colour.extract_band(1).copy()
         # we remove the ICC profile: the RGB one will no longer be appropriate
         cls.mono.remove("icc-profile-data")
         cls.rad = cls.colour.float2rad().copy()
         cls.rad.remove("icc-profile-data")
         cls.cmyk = cls.colour.bandjoin(cls.mono)
         cls.cmyk = cls.cmyk.copy(interpretation=pyvips.Interpretation.CMYK)
         cls.cmyk.remove("icc-profile-data")
 
         im = pyvips.Image.new_from_file(GIF_FILE)
         cls.onebit = im > 128
 
     @classmethod
     def teardown_class(cls):
         shutil.rmtree(cls.tempdir, ignore_errors=True)
         cls.colour = None
         cls.mono = None
         cls.rad = None
         cls.cmyk = None
         cls.onebit = None
 
     # we have test files for formats which have a clear standard
     def file_loader(self, loader, test_file, validate):
         im = pyvips.Operation.call(loader, test_file)
         validate(im)
         im = pyvips.Image.new_from_file(test_file)
         validate(im)
 
     def buffer_loader(self, loader, test_file, validate):
         with open(test_file, 'rb') as f:
             buf = f.read()
 
         im = pyvips.Operation.call(loader, buf)
         validate(im)
         im = pyvips.Image.new_from_buffer(buf, "")
         validate(im)
 
     def save_load(self, format, im):
         x = pyvips.Image.new_temp_file(format)
         im.write(x)
 
         assert im.width == x.width
         assert im.height == x.height
         assert im.bands == x.bands
         max_diff = (im - x).abs().max()
         assert max_diff == 0
 
     def save_load_file(self, format, options, im, thresh):
         # yuk!
         # but we can't set format parameters for pyvips.Image.new_temp_file()
         filename = temp_filename(self.tempdir, format)
 
         im.write_to_file(filename + options)
         x = pyvips.Image.new_from_file(filename)
 
         assert im.width == x.width
         assert im.height == x.height
         assert im.bands == x.bands
         max_diff = (im - x).abs().max()
         assert max_diff <= thresh
         x = None
 
     def save_load_buffer(self, saver, loader, im, max_diff=0, **kwargs):
         buf = pyvips.Operation.call(saver, im, **kwargs)
         x = pyvips.Operation.call(loader, buf)
 
         assert im.width == x.width
         assert im.height == x.height
         assert im.bands == x.bands
         assert (im - x).abs().max() <= max_diff
 
     def save_buffer_tempfile(self, saver, suf, im, max_diff=0):
         filename = temp_filename(self.tempdir, suf)
 
         buf = pyvips.Operation.call(saver, im)
         f = open(filename, 'wb')
         f.write(buf)
         f.close()
 
         x = pyvips.Image.new_from_file(filename)
 
         assert im.width == x.width
         assert im.height == x.height
         assert im.bands == x.bands
         assert (im - x).abs().max() <= max_diff
 
     def test_vips(self):
         self.save_load_file(".v", "", self.colour, 0)
 
         # check we can save and restore metadata
         filename = temp_filename(self.tempdir, ".v")
         self.colour.write_to_file(filename)
         x = pyvips.Image.new_from_file(filename)
         before_exif = self.colour.get("exif-data")
         after_exif = x.get("exif-data")
 
         assert len(before_exif) == len(after_exif)
         for i in range(len(before_exif)):
             assert before_exif[i] == after_exif[i]
 
         x = None
 
     @skip_if_no("jpegload")
     def test_jpeg(self):
         def jpeg_valid(im):
             a = im(10, 10)
             # different versions of libjpeg decode have slightly different 
             # rounding
             assert_almost_equal_objects(a, [141, 127, 90], threshold=3)
             profile = im.get("icc-profile-data")
             assert len(profile) == 564
             assert im.width == 290
             assert im.height == 442
             assert im.bands == 3
 
         self.file_loader("jpegload", JPEG_FILE, jpeg_valid)
         self.save_load("%s.jpg", self.mono)
         self.save_load("%s.jpg", self.colour)
 
         self.buffer_loader("jpegload_buffer", JPEG_FILE, jpeg_valid)
         self.save_load_buffer("jpegsave_buffer", "jpegload_buffer",
                               self.colour, 80)
 
         # see if we have exif parsing: our test image has this field
         x = pyvips.Image.new_from_file(JPEG_FILE)
         if x.get_typeof("exif-ifd0-Orientation") != 0:
             # we need a copy of the image to set the new metadata on
             # otherwise we get caching problems
 
             # can set, save and load new orientation
             x = pyvips.Image.new_from_file(JPEG_FILE)
             x = x.copy()
 
             x.set("orientation", 2)
 
             filename = temp_filename(self.tempdir, '.jpg')
             x.write_to_file(filename)
 
             x = pyvips.Image.new_from_file(filename)
             y = x.get("orientation")
             assert y == 2
 
             # can remove orientation, save, load again, orientation
             # has reset
             x = x.copy()
             x.remove("orientation")
 
             filename = temp_filename(self.tempdir, '.jpg')
             x.write_to_file(filename)
 
             x = pyvips.Image.new_from_file(filename)
             y = x.get("orientation")
             assert y == 1
 
             # autorotate load works
             x = pyvips.Image.new_from_file(JPEG_FILE)
             x = x.copy()
 
             x.set("orientation", 6)
 
             filename = temp_filename(self.tempdir, '.jpg')
             x.write_to_file(filename)
 
             x1 = pyvips.Image.new_from_file(filename)
             x2 = pyvips.Image.new_from_file(filename, autorotate=True)
             assert x1.width == x2.height
             assert x1.height == x2.width
 
             # sets incorrect orientation, save, load again, orientation
             # has reset to 1
             x = x.copy()
             x.set("orientation", 256)
 
             filename = temp_filename(self.tempdir, '.jpg')
             x.write_to_file(filename)
 
             x = pyvips.Image.new_from_file(filename)
             y = x.get("orientation")
             assert y == 1
 
             # can set, save and reload ASCII string fields
             x = pyvips.Image.new_from_file(JPEG_FILE)
             x = x.copy()
 
             x.set_type(pyvips.GValue.gstr_type, 
                        "exif-ifd0-ImageDescription", "hello world")
 
             filename = temp_filename(self.tempdir, '.jpg')
             x.write_to_file(filename)
 
             x = pyvips.Image.new_from_file(filename)
             y = x.get("exif-ifd0-ImageDescription")
             # can't use == since the string will have an extra " (xx, yy, zz)" 
             # format area at the end
             assert y.startswith("hello world")
 
             # can set, save and reload UTF16 string fields ... pyvips is 
             # utf8, but it will be coded as utf16 and back for the XP* fields
             x = pyvips.Image.new_from_file(JPEG_FILE)
             x = x.copy()
 
             x.set_type(pyvips.GValue.gstr_type, "exif-ifd0-XPComment", u"йцук")
 
             filename = temp_filename(self.tempdir, '.jpg')
             x.write_to_file(filename)
 
             x = pyvips.Image.new_from_file(filename)
             y = x.get("exif-ifd0-XPComment")
             # can't use == since the string will have an extra " (xx, yy, zz)" 
             # format area at the end
             assert y.startswith(u"йцук")
 
             # can set/save/load UserComment, a tag which has the
             # encoding in the first 8 bytes ... though libexif only supports
             # ASCII for this
             x = pyvips.Image.new_from_file(JPEG_FILE)
             x = x.copy()
 
             x.set_type(pyvips.GValue.gstr_type, 
                        "exif-ifd2-UserComment", "hello world")
 
             filename = temp_filename(self.tempdir, '.jpg')
             x.write_to_file(filename)
 
             x = pyvips.Image.new_from_file(filename)
             y = x.get("exif-ifd2-UserComment")
             # can't use == since the string will have an extra " (xx, yy, zz)" 
             # format area at the end
             assert y.startswith("hello world")
 
     @skip_if_no("jpegload")
     def test_jpegsave(self):
         im = pyvips.Image.new_from_file(JPEG_FILE)
 
         q10 = im.jpegsave_buffer(Q=10)
         q10_subsample_auto = im.jpegsave_buffer(Q=10, subsample_mode="auto")
         q10_subsample_on = im.jpegsave_buffer(Q=10, subsample_mode="on")
         q10_subsample_off = im.jpegsave_buffer(Q=10, subsample_mode="off")
         
         q90 = im.jpegsave_buffer(Q=90)
         q90_subsample_auto = im.jpegsave_buffer(Q=90, subsample_mode="auto")
         q90_subsample_on = im.jpegsave_buffer(Q=90, subsample_mode="on")
         q90_subsample_off = im.jpegsave_buffer(Q=90, subsample_mode="off")
 
         # higher Q should mean a bigger buffer
         assert len(q90) > len(q10)
         
         assert len(q10_subsample_auto) == len(q10) 
         assert len(q10_subsample_on) == len(q10_subsample_auto)
         assert len(q10_subsample_off) > len(q10)    
         
         assert len(q90_subsample_auto) == len(q90) 
         assert len(q90_subsample_on) < len(q90) 
         assert len(q90_subsample_off) == len(q90_subsample_auto)
 
     @skip_if_no("jpegload")
     def test_truncated(self):
         # This should open (there's enough there for the header)
         im = pyvips.Image.new_from_file(TRUNCATED_FILE)
         # but this should fail with a warning, and knock TRUNCATED_FILE out of
         # the cache
         x = im.avg()
 
         # now we should open again, but it won't come from cache, it'll reload
         im = pyvips.Image.new_from_file(TRUNCATED_FILE)
         # and this should fail with a warning once more
         x = im.avg()
 
     @skip_if_no("pngload")
     def test_png(self):
         def png_valid(im):
             a = im(10, 10)
             assert_almost_equal_objects(a, [38671.0, 33914.0, 26762.0])
             assert im.width == 290
             assert im.height == 442
             assert im.bands == 3
 
         self.file_loader("pngload", PNG_FILE, png_valid)
         self.buffer_loader("pngload_buffer", PNG_FILE, png_valid)
         self.save_load_buffer("pngsave_buffer", "pngload_buffer", self.colour)
         self.save_load("%s.png", self.mono)
         self.save_load("%s.png", self.colour)
         self.save_load_file(".png", "[interlace]", self.colour, 0)
         self.save_load_file(".png", "[interlace]", self.mono, 0)
 
         # size of a regular mono PNG 
         len_mono = len(self.mono.write_to_buffer(".png"))
 
         # 4-bit should be smaller
         len_mono4 = len(self.mono.write_to_buffer(".png", bitdepth=4))
         assert( len_mono4 < len_mono )
 
         len_mono2 = len(self.mono.write_to_buffer(".png", bitdepth=2))
         assert( len_mono2 < len_mono4 )
 
         len_mono1 = len(self.mono.write_to_buffer(".png", bitdepth=1))
         assert( len_mono1 < len_mono2 )
 
         # we can't test palette save since we can't be sure libimagequant is
         # available and there's no easy test for its presence
 
     @skip_if_no("tiffload")
     def test_tiff(self):
         def tiff_valid(im):
             a = im(10, 10)
             assert_almost_equal_objects(a, [38671.0, 33914.0, 26762.0])
             assert im.width == 290
             assert im.height == 442
             assert im.bands == 3
 
         self.file_loader("tiffload", TIF_FILE, tiff_valid)
         self.buffer_loader("tiffload_buffer", TIF_FILE, tiff_valid)
 
         def tiff1_valid(im):
             a = im(127, 0)
             assert_almost_equal_objects(a, [0.0])
             a = im(128, 0)
             assert_almost_equal_objects(a, [255.0])
             assert im.width == 256
             assert im.height == 4
             assert im.bands == 1
 
         self.file_loader("tiffload", TIF1_FILE, tiff1_valid)
 
         def tiff2_valid(im):
             a = im(127, 0)
             assert_almost_equal_objects(a, [85.0])
             a = im(128, 0)
             assert_almost_equal_objects(a, [170.0])
             assert im.width == 256
             assert im.height == 4
             assert im.bands == 1
 
         self.file_loader("tiffload", TIF2_FILE, tiff2_valid)
 
         def tiff4_valid(im):
             a = im(127, 0)
             assert_almost_equal_objects(a, [119.0])
             a = im(128, 0)
             assert_almost_equal_objects(a, [136.0])
             assert im.width == 256
             assert im.height == 4
             assert im.bands == 1
 
         self.file_loader("tiffload", TIF4_FILE, tiff4_valid)
 
-        if pyvips.at_least_libvips(8, 5):
-            self.save_load_buffer("tiffsave_buffer",
-                                  "tiffload_buffer",
-                                  self.colour)
+        self.save_load_buffer("tiffsave_buffer", "tiffload_buffer", self.colour)
         self.save_load("%s.tif", self.mono)
         self.save_load("%s.tif", self.colour)
         self.save_load("%s.tif", self.cmyk)
 
         self.save_load("%s.tif", self.onebit)
         self.save_load_file(".tif", "[bitdepth=1]", self.onebit, 0)
         self.save_load_file(".tif", "[miniswhite]", self.onebit, 0)
         self.save_load_file(".tif", "[bitdepth=1,miniswhite]", self.onebit, 0)
 
         self.save_load_file(".tif",
                             "[profile={0}]".format(SRGB_FILE),
                             self.colour, 0)
         self.save_load_file(".tif", "[tile]", self.colour, 0)
         self.save_load_file(".tif", "[tile,pyramid]", self.colour, 0)
         self.save_load_file(".tif", "[tile,pyramid,subifd]", self.colour, 0)
         self.save_load_file(".tif",
                             "[tile,pyramid,compression=jpeg]", self.colour, 80)
         self.save_load_file(".tif",
                             "[tile,pyramid,subifd,compression=jpeg]", 
                             self.colour, 80)
         self.save_load_file(".tif", "[bigtiff]", self.colour, 0)
         self.save_load_file(".tif", "[compression=jpeg]", self.colour, 80)
         self.save_load_file(".tif",
                             "[tile,tile-width=256]", self.colour, 10)
 
         im = pyvips.Image.new_from_file(TIF2_FILE)
         self.save_load_file(".tif", "[bitdepth=2]", im, 0)
         im = pyvips.Image.new_from_file(TIF4_FILE)
         self.save_load_file(".tif", "[bitdepth=4]", im, 0)
 
         filename = temp_filename(self.tempdir, '.tif')
         x = pyvips.Image.new_from_file(TIF_FILE)
         x = x.copy()
         x.set("orientation", 2)
         x.write_to_file(filename)
         x = pyvips.Image.new_from_file(filename)
         y = x.get("orientation")
         assert y == 2
 
         filename = temp_filename(self.tempdir, '.tif')
         x = pyvips.Image.new_from_file(TIF_FILE)
         x = x.copy()
         x.set("orientation", 2)
         x.write_to_file(filename)
         x = pyvips.Image.new_from_file(filename)
         y = x.get("orientation")
         assert y == 2
         x = x.copy()
         x.remove("orientation")
 
         filename = temp_filename(self.tempdir, '.tif')
         x.write_to_file(filename)
         x = pyvips.Image.new_from_file(filename)
         y = x.get("orientation")
         assert y == 1
 
         filename = temp_filename(self.tempdir, '.tif')
         x = pyvips.Image.new_from_file(TIF_FILE)
         x = x.copy()
         x.set("orientation", 6)
         x.write_to_file(filename)
         x1 = pyvips.Image.new_from_file(filename)
         x2 = pyvips.Image.new_from_file(filename, autorotate=True)
         assert x1.width == x2.height
         assert x1.height == x2.width
 
         filename = temp_filename(self.tempdir, '.tif')
         x = pyvips.Image.new_from_file(TIF_FILE)
         x = x.copy()
         x.write_to_file(filename, xres=100, yres=200, resunit="cm")
         x1 = pyvips.Image.new_from_file(filename)
         assert x1.get("resolution-unit") == "cm"
         assert x1.xres == 100
         assert x1.yres == 200
 
         filename = temp_filename(self.tempdir, '.tif')
         x = pyvips.Image.new_from_file(TIF_FILE)
         x = x.copy()
         x.write_to_file(filename, xres=100, yres=200, resunit="inch")
         x1 = pyvips.Image.new_from_file(filename)
         assert x1.get("resolution-unit") == "in"
         assert x1.xres == 100
         assert x1.yres == 200
 
         # OME support in 8.5
         x = pyvips.Image.new_from_file(OME_FILE)
         assert x.width == 439
         assert x.height == 167
         page_height = x.height
 
         x = pyvips.Image.new_from_file(OME_FILE, n=-1)
         assert x.width == 439
         assert x.height == page_height * 15
 
         x = pyvips.Image.new_from_file(OME_FILE, page=1, n=-1)
         assert x.width == 439
         assert x.height == page_height * 14
 
         x = pyvips.Image.new_from_file(OME_FILE, page=1, n=2)
         assert x.width == 439
         assert x.height == page_height * 2
 
         x = pyvips.Image.new_from_file(OME_FILE, n=-1)
         assert x(0, 166)[0] == 96
         assert x(0, 167)[0] == 0
         assert x(0, 168)[0] == 1
 
         filename = temp_filename(self.tempdir, '.tif')
         x.write_to_file(filename)
 
         x = pyvips.Image.new_from_file(filename, n=-1)
         assert x.width == 439
         assert x.height == page_height * 15
         assert x(0, 166)[0] == 96
         assert x(0, 167)[0] == 0
         assert x(0, 168)[0] == 1
 
         # pyr save to buffer added in 8.6
         x = pyvips.Image.new_from_file(TIF_FILE)
         buf = x.tiffsave_buffer(tile=True, pyramid=True)
         filename = temp_filename(self.tempdir, '.tif')
         x.tiffsave(filename, tile=True, pyramid=True)
         with open(filename, 'rb') as f:
             buf2 = f.read()
         assert len(buf) == len(buf2)
 
         a = pyvips.Image.new_from_buffer(buf, "", page=2)
         b = pyvips.Image.new_from_buffer(buf2, "", page=2)
         assert a.width == b.width
         assert a.height == b.height
         assert a.avg() == b.avg()
 
-        x = pyvips.Image.new_from_file(TIF_FILE)
-        buf = x.tiffsave_buffer(tile=True, pyramid=True, region_shrink="mean")
-        buf = x.tiffsave_buffer(tile=True, pyramid=True, region_shrink="mode")
-        buf = x.tiffsave_buffer(tile=True, pyramid=True, region_shrink="median")
-        buf = x.tiffsave_buffer(tile=True, pyramid=True, region_shrink="max")
-        buf = x.tiffsave_buffer(tile=True, pyramid=True, region_shrink="min")
-        buf = x.tiffsave_buffer(tile=True, pyramid=True,
-                                region_shrink="nearest")
+        # just 0/255 in each band, shrink with mode and all pixels should be 0
+        # or 255 in layer 1
+        x = pyvips.Image.new_from_file(TIF_FILE) > 128
+        for shrink in ["mode", "median", "max", "min"]:
+            buf = x.tiffsave_buffer(pyramid=True, region_shrink=shrink)
+            y = pyvips.Image.new_from_buffer(buf, "", page=1)
+            z = y.hist_find(band=0)
+            assert z(0, 0)[0] + z(255, 0)[0] == y.width * y.height
 
     @skip_if_no("magickload")
     def test_magickload(self):
         def bmp_valid(im):
             a = im(100, 100)
 
             assert_almost_equal_objects(a, [227, 216, 201])
             assert im.width == 1419
             assert im.height == 1001
 
         self.file_loader("magickload", BMP_FILE, bmp_valid)
         self.buffer_loader("magickload_buffer", BMP_FILE, bmp_valid)
 
         # we should have rgb or rgba for svg files ... different versions of
         # IM handle this differently. GM even gives 1 band.
         im = pyvips.Image.magickload(SVG_FILE)
         assert im.bands == 3 or im.bands == 4 or im.bands == 1
 
         # density should change size of generated svg
         im = pyvips.Image.magickload(SVG_FILE, density='100')
         width = im.width
         height = im.height
         im = pyvips.Image.magickload(SVG_FILE, density='200')
         # This seems to fail on travis, no idea why, some problem in their IM
         # perhaps
         # assert im.width == width * 2
         # assert im.height == height * 2
 
         im = pyvips.Image.magickload(GIF_ANIM_FILE)
         width = im.width
         height = im.height
         im = pyvips.Image.magickload(GIF_ANIM_FILE, n=-1)
         assert im.width == width
         assert im.height == height * 5
 
         # page/n let you pick a range of pages
         # 'n' param added in 8.5
         if pyvips.at_least_libvips(8, 5):
             im = pyvips.Image.magickload(GIF_ANIM_FILE)
             width = im.width
             height = im.height
             im = pyvips.Image.magickload(GIF_ANIM_FILE, page=1, n=2)
             assert im.width == width
             assert im.height == height * 2
             page_height = im.get("page-height")
             assert page_height == height
 
         # should work for dicom
         im = pyvips.Image.magickload(DICOM_FILE)
         assert im.width == 128
         assert im.height == 128
         # some IMs are 3 bands, some are 1, can't really test
         # assert im.bands == 1
 
         # libvips has its own sniffer for ICO, test that
         with open(ICO_FILE, 'rb') as f:
             buf = f.read()
 
         im = pyvips.Image.new_from_buffer(buf, "")
         assert im.width == 16
         assert im.height == 16
 
         # load should see metadata like eg. icc profiles 
         im = pyvips.Image.magickload(JPEG_FILE)
         assert len(im.get("icc-profile-data")) == 564
 
     # added in 8.7
     @skip_if_no("magicksave")
     def test_magicksave(self):
         # save to a file and load again ... we can't use save_load_file since
         # we want to make sure we use magickload/save 
         # don't use BMP - GraphicsMagick always adds an alpha
         # don't use TIF - IM7 will save as 16-bit
         filename = temp_filename(self.tempdir, ".jpg")
 
         self.colour.magicksave(filename)
         x = pyvips.Image.magickload(filename)
 
         assert self.colour.width == x.width
         assert self.colour.height == x.height
         assert self.colour.bands == x.bands
         max_diff = (self.colour - x).abs().max()
         assert max_diff < 60
         assert len(x.get("icc-profile-data")) == 564
 
         self.save_load_buffer("magicksave_buffer", "magickload_buffer",
                               self.colour, 60, format="JPG")
 
         # try an animation
         if have("gifload"):
             x1 = pyvips.Image.new_from_file(GIF_ANIM_FILE, n=-1)
             w1 = x1.magicksave_buffer(format="GIF")
             x2 = pyvips.Image.new_from_buffer(w1, "", n=-1)
             assert x1.get("delay") == x2.get("delay")
             assert x1.get("page-height") == x2.get("page-height")
             # magicks vary in how they handle this ... just pray we are close
             assert abs(x1.get("gif-loop") - x2.get("gif-loop")) < 5
 
     @skip_if_no("webpload")
     def test_webp(self):
         def webp_valid(im):
             a = im(10, 10)
             # different webp versions use different rounding systems leading
             # to small variations
             assert_almost_equal_objects(a, [71, 166, 236], threshold=2)
             assert im.width == 550
             assert im.height == 368
             assert im.bands == 3
 
         self.file_loader("webpload", WEBP_FILE, webp_valid)
         self.buffer_loader("webpload_buffer", WEBP_FILE, webp_valid)
         self.save_load_buffer("webpsave_buffer", "webpload_buffer",
                               self.colour, 60)
         self.save_load("%s.webp", self.colour)
 
         # test lossless mode
         im = pyvips.Image.new_from_file(WEBP_FILE)
         buf = im.webpsave_buffer(lossless=True)
         im2 = pyvips.Image.new_from_buffer(buf, "")
         assert abs(im.avg() - im2.avg()) < 1
 
         # higher Q should mean a bigger buffer
         b1 = im.webpsave_buffer(Q=10)
         b2 = im.webpsave_buffer(Q=90)
         assert len(b2) > len(b1)
 
         # try saving an image with an ICC profile and reading it back ... if we
         # can do it, our webp supports metadata load/save
         buf = self.colour.webpsave_buffer()
         im = pyvips.Image.new_from_buffer(buf, "")
         if im.get_typeof("icc-profile-data") != 0:
             # verify that the profile comes back unharmed
             p1 = self.colour.get("icc-profile-data")
             p2 = im.get("icc-profile-data")
             assert p1 == p2
 
             # add tests for exif, xmp, ipct
             # the exif test will need us to be able to walk the header,
             # we can't just check exif-data
 
             # we can test that exif changes change the output of webpsave
             # first make sure we have exif support
             z = pyvips.Image.new_from_file(JPEG_FILE)
             if z.get_typeof("exif-ifd0-Orientation") != 0:
                 x = self.colour.copy()
                 x.set("orientation", 6)
                 buf = x.webpsave_buffer()
                 y = pyvips.Image.new_from_buffer(buf, "")
                 assert y.get("orientation") == 6
 
         # try converting an animated gif to webp ... can't do back to gif
         # again without IM support
         if have("gifload"):
             x1 = pyvips.Image.new_from_file(GIF_ANIM_FILE, n=-1)
             w1 = x1.webpsave_buffer(Q=10)
 
             x2 = pyvips.Image.new_from_buffer(w1, "", n=-1)
             assert x1.width == x2.width
             assert x1.height == x2.height
             assert x1.get("delay") == x2.get("delay")
             assert x1.get("page-height") == x2.get("page-height")
             assert x1.get("gif-loop") == x2.get("gif-loop")
 
         # WebP image that happens to contain the string "<svg"
         if have("svgload"):
             x = pyvips.Image.new_from_file(WEBP_LOOKS_LIKE_SVG_FILE)
             assert x.get("vips-loader") == "webpload"
 
     @skip_if_no("analyzeload")
     def test_analyzeload(self):
         def analyze_valid(im):
             a = im(10, 10)
             assert pytest.approx(a[0]) == 3335
             assert im.width == 128
             assert im.height == 8064
             assert im.bands == 1
 
         self.file_loader("analyzeload", ANALYZE_FILE, analyze_valid)
 
     @skip_if_no("matload")
     def test_matload(self):
         def matlab_valid(im):
             a = im(10, 10)
             assert_almost_equal_objects(a, [38671.0, 33914.0, 26762.0])
             assert im.width == 290
             assert im.height == 442
             assert im.bands == 3
 
         self.file_loader("matload", MATLAB_FILE, matlab_valid)
 
     @skip_if_no("openexrload")
     def test_openexrload(self):
         def exr_valid(im):
             a = im(10, 10)
             assert_almost_equal_objects(a, [0.124512, 0.159668, 0.040375, 
                                             255.0],
                                         threshold=0.00001)
             assert im.width == 610
             assert im.height == 406
             assert im.bands == 4
 
         self.file_loader("openexrload", EXR_FILE, exr_valid)
 
     @skip_if_no("fitsload")
     def test_fitsload(self):
         def fits_valid(im):
             a = im(10, 10)
             assert_almost_equal_objects(a, [-0.165013, -0.148553, 1.09122,
                                             -0.942242], threshold=0.00001)
             assert im.width == 200
             assert im.height == 200
             assert im.bands == 4
 
         self.file_loader("fitsload", FITS_FILE, fits_valid)
         self.save_load("%s.fits", self.mono)
 
     @skip_if_no("niftiload")
     def test_niftiload(self):
         def nifti_valid(im):
             a = im(30, 26)
             assert_almost_equal_objects(a, [131])
             assert im.width == 91
             assert im.height == 9919
             assert im.bands == 1
 
         self.file_loader("niftiload", NIFTI_FILE, nifti_valid)
         self.save_load("%s.nii.gz", self.mono)
 
     @skip_if_no("openslideload")
     def test_openslideload(self):
         def openslide_valid(im):
             a = im(10, 10)
             assert_almost_equal_objects(a, [244, 250, 243, 255])
             assert im.width == 2220
             assert im.height == 2967
             assert im.bands == 4
 
         self.file_loader("openslideload", OPENSLIDE_FILE, openslide_valid)
 
     @skip_if_no("pdfload")
     def test_pdfload(self):
         def pdf_valid(im):
             a = im(10, 10)
             assert_almost_equal_objects(a, [35, 31, 32, 255])
             assert im.width == 1134
             assert im.height == 680
             assert im.bands == 4
 
         self.file_loader("pdfload", PDF_FILE, pdf_valid)
         self.buffer_loader("pdfload_buffer", PDF_FILE, pdf_valid)
 
         im = pyvips.Image.new_from_file(PDF_FILE)
         x = pyvips.Image.new_from_file(PDF_FILE, scale=2)
         assert abs(im.width * 2 - x.width) < 2
         assert abs(im.height * 2 - x.height) < 2
 
         im = pyvips.Image.new_from_file(PDF_FILE)
         x = pyvips.Image.new_from_file(PDF_FILE, dpi=144)
         assert abs(im.width * 2 - x.width) < 2
         assert abs(im.height * 2 - x.height) < 2
 
     @skip_if_no("gifload")
     def test_gifload(self):
         def gif_valid(im):
             a = im(10, 10)
             assert_almost_equal_objects(a, [33])
             assert im.width == 159
             assert im.height == 203
             assert im.bands == 1
 
         self.file_loader("gifload", GIF_FILE, gif_valid)
         self.buffer_loader("gifload_buffer", GIF_FILE, gif_valid)
 
         # 'n' param added in 8.5
         if pyvips.at_least_libvips(8, 5):
             x1 = pyvips.Image.new_from_file(GIF_ANIM_FILE)
             x2 = pyvips.Image.new_from_file(GIF_ANIM_FILE, n=2)
             assert x2.height == 2 * x1.height
             page_height = x2.get("page-height")
             assert page_height == x1.height
 
             x2 = pyvips.Image.new_from_file(GIF_ANIM_FILE, n=-1)
             assert x2.height == 5 * x1.height
             # our test gif has delay 0 for the first frame set in error
             assert x2.get("delay") == [0, 50, 50, 50, 50]
 
             x2 = pyvips.Image.new_from_file(GIF_ANIM_FILE, page=1, n=-1)
             assert x2.height == 4 * x1.height
 
             animation = pyvips.Image.new_from_file(GIF_ANIM_FILE, n=-1)
             filename = temp_filename(self.tempdir, '.png')
             animation.write_to_file(filename)
             # Uncomment to see output file
             # animation.write_to_file('cogs.png')
 
             assert filecmp.cmp(GIF_ANIM_EXPECTED_PNG_FILE, filename, shallow=False)
 
     @skip_if_no("gifload")
     def test_gifload_animation_dispose_background(self):
         animation = pyvips.Image.new_from_file(GIF_ANIM_DISPOSE_BACKGROUND_FILE, n=-1)
 
         filename = temp_filename(self.tempdir, '.png')
         animation.write_to_file(filename)
 
         # Uncomment to see output file
         # animation.write_to_file('dispose-background.png')
 
         assert filecmp.cmp(GIF_ANIM_DISPOSE_BACKGROUND_EXPECTED_PNG_FILE, filename, shallow=False)
 
     @skip_if_no("gifload")
     def test_gifload_animation_dispose_previous(self):
         animation = pyvips.Image.new_from_file(GIF_ANIM_DISPOSE_PREVIOUS_FILE, n=-1)
 
         filename = temp_filename(self.tempdir, '.png')
         animation.write_to_file(filename)
 
         # Uncomment to see output file
         # animation.write_to_file('dispose-previous.png')
 
         assert filecmp.cmp(GIF_ANIM_DISPOSE_PREVIOUS_EXPECTED_PNG_FILE, filename, shallow=False)
 
     @skip_if_no("svgload")
     def test_svgload(self):
         def svg_valid(im):
             a = im(10, 10)
             assert_almost_equal_objects(a, [0, 0, 0, 0])
             assert im.width == 736
             assert im.height == 552
             assert im.bands == 4
 
         self.file_loader("svgload", SVG_FILE, svg_valid)
         self.buffer_loader("svgload_buffer", SVG_FILE, svg_valid)
 
         self.file_loader("svgload", SVGZ_FILE, svg_valid)
         self.buffer_loader("svgload_buffer", SVGZ_FILE, svg_valid)
 
         self.file_loader("svgload", SVG_GZ_FILE, svg_valid)
 
         im = pyvips.Image.new_from_file(SVG_FILE)
         x = pyvips.Image.new_from_file(SVG_FILE, scale=2)
         assert abs(im.width * 2 - x.width) < 2
         assert abs(im.height * 2 - x.height) < 2
 
         im = pyvips.Image.new_from_file(SVG_FILE)
         x = pyvips.Image.new_from_file(SVG_FILE, dpi=144)
         assert abs(im.width * 2 - x.width) < 2
         assert abs(im.height * 2 - x.height) < 2
 
     def test_csv(self):
         self.save_load("%s.csv", self.mono)
 
     def test_matrix(self):
         self.save_load("%s.mat", self.mono)
 
     @skip_if_no("ppmload")
     def test_ppm(self):
         self.save_load("%s.ppm", self.mono)
         self.save_load("%s.ppm", self.colour)
 
     @skip_if_no("radload")
     def test_rad(self):
         self.save_load("%s.hdr", self.colour)
         self.save_buffer_tempfile("radsave_buffer", ".hdr",
                                   self.rad, max_diff=0)
 
     @skip_if_no("dzsave")
     def test_dzsave(self):
         # dzsave is hard to test, there are so many options
         # test each option separately and hope they all function together
         # correctly
 
         # default deepzoom layout ... we must use png here, since we want to
         # test the overlap for equality
         filename = temp_filename(self.tempdir, '')
         self.colour.dzsave(filename, suffix=".png")
 
         # test horizontal overlap ... expect 256 step, overlap 1
         x = pyvips.Image.new_from_file(filename + "_files/9/0_0.png")
         assert x.width == 255
         y = pyvips.Image.new_from_file(filename + "_files/9/1_0.png")
         assert y.width == 37
 
         # the right two columns of x should equal the left two columns of y
         left = x.crop(x.width - 2, 0, 2, x.height)
         right = y.crop(0, 0, 2, y.height)
         assert (left - right).abs().max() == 0
 
         # test vertical overlap
         assert x.height == 255
         y = pyvips.Image.new_from_file(filename + "_files/9/0_1.png")
         assert y.height == 189
 
         # the bottom two rows of x should equal the top two rows of y
         top = x.crop(0, x.height - 2, x.width, 2)
         bottom = y.crop(0, 0, y.width, 2)
         assert (top - bottom).abs().max() == 0
 
         # there should be a bottom layer
         x = pyvips.Image.new_from_file(filename + "_files/0/0_0.png")
         assert x.width == 1
         assert x.height == 1
 
         # 9 should be the final layer
         assert not os.path.isdir(filename + "_files/10")
 
         # default google layout
         filename = temp_filename(self.tempdir, '')
         self.colour.dzsave(filename, layout="google")
 
         # test bottom-right tile ... default is 256x256 tiles, overlap 0
         x = pyvips.Image.new_from_file(filename + "/1/1/1.jpg")
         assert x.width == 256
         assert x.height == 256
         assert not os.path.exists(filename + "/1/1/2.jpg")
         assert not os.path.exists(filename + "/2")
         x = pyvips.Image.new_from_file(filename + "/blank.png")
         assert x.width == 256
         assert x.height == 256
 
         # google layout with overlap ... verify that we clip correctly
 
         # overlap 1, 510x510 pixels, 256 pixel tiles, should be exactly 2x2
         # tiles, though in fact the bottom and right edges will be white
         filename = temp_filename(self.tempdir, '')
         self.colour \
             .replicate(2, 2) \
             .crop(0, 0, 510, 510) \
             .dzsave(filename, layout="google", overlap=1, depth="one")
 
         x = pyvips.Image.new_from_file(filename + "/0/1/1.jpg")
         assert x.width == 256
         assert x.height == 256
         assert not os.path.exists(filename + "/0/2/2.jpg")
 
         # with 511x511, it'll fit exactly into 2x2 -- we we actually generate
         # 3x3, since we output the overlaps
         filename = temp_filename(self.tempdir, '')
         self.colour \
             .replicate(2, 2) \
             .crop(0, 0, 511, 511) \
             .dzsave(filename, layout="google", overlap=1, depth="one")
 
         x = pyvips.Image.new_from_file(filename + "/0/2/2.jpg")
         assert x.width == 256
         assert x.height == 256
         assert not os.path.exists(filename + "/0/3/3.jpg")
 
         # default zoomify layout
         filename = temp_filename(self.tempdir, '')
         self.colour.dzsave(filename, layout="zoomify")
 
         # 256x256 tiles, no overlap
         assert os.path.exists(filename + "/ImageProperties.xml")
         x = pyvips.Image.new_from_file(filename + "/TileGroup0/1-0-0.jpg")
         assert x.width == 256
         assert x.height == 256
 
         # test zip output
         filename = temp_filename(self.tempdir, '.zip')
         self.colour.dzsave(filename)
         assert os.path.exists(filename)
         assert not os.path.exists(filename + "_files")
         assert not os.path.exists(filename + ".dzi")
 
         # test compressed zip output
         filename2 = temp_filename(self.tempdir, '.zip')
         self.colour.dzsave(filename2, compression=-1)
         assert os.path.exists(filename2)
         assert os.path.getsize(filename2) < os.path.getsize(filename)
 
         # test suffix
         filename = temp_filename(self.tempdir, '')
         self.colour.dzsave(filename, suffix=".png")
 
         x = pyvips.Image.new_from_file(filename + "_files/9/0_0.png")
         assert x.width == 255
 
         # test overlap
         filename = temp_filename(self.tempdir, '')
         self.colour.dzsave(filename, overlap=200)
 
         y = pyvips.Image.new_from_file(filename + "_files/9/1_1.jpeg")
         assert y.width == 236
 
         # test tile-size
         filename = temp_filename(self.tempdir, '')
         self.colour.dzsave(filename, tile_size=512)
 
         y = pyvips.Image.new_from_file(filename + "_files/9/0_0.jpeg")
         assert y.width == 290
         assert y.height == 442
 
         # test save to memory buffer
         filename = temp_filename(self.tempdir, '.zip')
         base = os.path.basename(filename)
         root, ext = os.path.splitext(base)
 
         self.colour.dzsave(filename)
         with open(filename, 'rb') as f:
             buf1 = f.read()
         buf2 = self.colour.dzsave_buffer(basename=root)
         assert len(buf1) == len(buf2)
 
         # we can't test the bytes are exactly equal -- the timestamps will
         # be different
 
         # added in 8.7
         buf = self.colour.dzsave_buffer(region_shrink="mean")
         buf = self.colour.dzsave_buffer(region_shrink="mode")
         buf = self.colour.dzsave_buffer(region_shrink="median")
 
     @skip_if_no("heifload")
     def test_heifload(self):
         def heif_valid(im):
             a = im(10, 10)
             # different versions of HEIC decode have slightly different 
             # rounding
             assert_almost_equal_objects(a, [197.0, 181.0, 158.0], threshold=2)
             assert im.width == 3024
             assert im.height == 4032
             assert im.bands == 3
 
         self.file_loader("heifload", HEIC_FILE, heif_valid)
         self.buffer_loader("heifload_buffer", HEIC_FILE, heif_valid)
 
     @skip_if_no("heifsave")
     def test_heifsave(self):
         self.save_load_buffer("heifsave_buffer", "heifload_buffer",
                               self.colour, 80)
         self.save_load("%s.heic", self.colour)
 
         # test lossless mode
         im = pyvips.Image.new_from_file(HEIC_FILE)
         buf = im.heifsave_buffer(lossless=True)
         im2 = pyvips.Image.new_from_buffer(buf, "")
         # not in fact quite lossless
         assert abs(im.avg() - im2.avg()) < 3
 
         # higher Q should mean a bigger buffer
         b1 = im.heifsave_buffer(Q=10)
         b2 = im.heifsave_buffer(Q=90)
         assert len(b2) > len(b1)
 
         # try saving an image with an ICC profile and reading it back 
         # not all libheif have profile support, so put it in an if
         buf = self.colour.heifsave_buffer()
         im = pyvips.Image.new_from_buffer(buf, "")
         p1 = self.colour.get("icc-profile-data")
         if im.get_typeof("icc-profile-data") != 0:
             p2 = im.get("icc-profile-data")
             assert p1 == p2
 
         # add tests for exif, xmp, ipct
         # the exif test will need us to be able to walk the header,
         # we can't just check exif-data
 
         # libheif 1.1 (on ubuntu 18.04, current LTS) does not support exif
         # write, so this test is commented out
 
         # test that exif changes change the output of heifsave
         # first make sure we have exif support
         #z = pyvips.Image.new_from_file(JPEG_FILE)
         #if z.get_typeof("exif-ifd0-Orientation") != 0:
         #    x = self.colour.copy()
         #    x.set("exif-ifd0-Make", "banana")
         #    buf = x.heifsave_buffer()
         #    y = pyvips.Image.new_from_buffer(buf, "")
         #    assert y.get("exif-ifd0-Make").split(" ")[0] == "banana"
