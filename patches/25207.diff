commit 0dd74a9a6f1cce26763443f9247b131bb8eb7254
Author: htuch <htuch@users.noreply.github.com>
Date:   Mon Dec 14 19:09:58 2020 -0500

    config: v2 non-pubsub transport API fatal-by-default. (#14389)
    
    This is a followup to #14223, covering remaining uses of the
    transport_api_version field.
    
    Risk level: High (this will break anyone who is still using v2 and has
    not enabled CLI or runtime override)
    Testing: Various tests updated, some exemplar tests added to
    server_test.
    Release Notes: Same as #13950.
    
    Signed-off-by: Harvey Tuch <htuch@google.com>

diff --git a/source/common/config/BUILD b/source/common/config/BUILD
index a92b3e0179..067f1d9ada 100644
--- a/source/common/config/BUILD
+++ b/source/common/config/BUILD
@@ -375,32 +375,33 @@ envoy_cc_library(
 envoy_cc_library(
     name = "utility_lib",
     srcs = ["utility.cc"],
     hdrs = ["utility.h"],
     deps = [
         ":api_type_oracle_lib",
         ":version_converter_lib",
         "//include/envoy/config:grpc_mux_interface",
         "//include/envoy/config:subscription_interface",
         "//include/envoy/local_info:local_info_interface",
         "//include/envoy/registry",
         "//include/envoy/server:filter_config_interface",
         "//include/envoy/upstream:cluster_manager_interface",
         "//source/common/common:assert_lib",
         "//source/common/common:backoff_lib",
         "//source/common/common:hash_lib",
         "//source/common/common:hex_lib",
         "//source/common/grpc:common_lib",
         "//source/common/protobuf",
         "//source/common/protobuf:utility_lib",
+        "//source/common/runtime:runtime_features_lib",
         "//source/common/singleton:const_singleton",
         "//source/common/stats:histogram_lib",
         "//source/common/stats:stats_lib",
         "//source/common/stats:stats_matcher_lib",
         "//source/common/stats:tag_producer_lib",
         "@com_github_cncf_udpa//udpa/type/v1:pkg_cc_proto",
         "@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto",
         "@envoy_api//envoy/config/cluster/v3:pkg_cc_proto",
         "@envoy_api//envoy/config/core/v3:pkg_cc_proto",
         "@envoy_api//envoy/config/endpoint/v3:pkg_cc_proto",
     ],
 )
diff --git a/source/common/config/subscription_factory_impl.cc b/source/common/config/subscription_factory_impl.cc
index bb07b4d72d..ba40d3ec99 100644
--- a/source/common/config/subscription_factory_impl.cc
+++ b/source/common/config/subscription_factory_impl.cc
@@ -19,98 +19,80 @@ namespace Config {
 SubscriptionFactoryImpl::SubscriptionFactoryImpl(
     const LocalInfo::LocalInfo& local_info, Event::Dispatcher& dispatcher,
     Upstream::ClusterManager& cm, ProtobufMessage::ValidationVisitor& validation_visitor,
-    Api::Api& api, Runtime::Loader& runtime)
+    Api::Api& api)
     : local_info_(local_info), dispatcher_(dispatcher), cm_(cm),
-      validation_visitor_(validation_visitor), api_(api), runtime_(runtime) {}
+      validation_visitor_(validation_visitor), api_(api) {}
 
 SubscriptionPtr SubscriptionFactoryImpl::subscriptionFromConfigSource(
     const envoy::config::core::v3::ConfigSource& config, absl::string_view type_url,
     Stats::Scope& scope, SubscriptionCallbacks& callbacks,
     OpaqueResourceDecoder& resource_decoder) {
   Config::Utility::checkLocalInfo(type_url, local_info_);
   std::unique_ptr<Subscription> result;
   SubscriptionStats stats = Utility::generateStats(scope);
 
   switch (config.config_source_specifier_case()) {
   case envoy::config::core::v3::ConfigSource::ConfigSourceSpecifierCase::kPath: {
     Utility::checkFilesystemSubscriptionBackingPath(config.path(), api_);
     return std::make_unique<Config::FilesystemSubscriptionImpl>(
         dispatcher_, config.path(), callbacks, resource_decoder, stats, validation_visitor_, api_);
   }
   case envoy::config::core::v3::ConfigSource::ConfigSourceSpecifierCase::kApiConfigSource: {
     const envoy::config::core::v3::ApiConfigSource& api_config_source = config.api_config_source();
     Utility::checkApiConfigSourceSubscriptionBackingCluster(cm_.primaryClusters(),
                                                             api_config_source);
-    const auto transport_api_version = api_config_source.transport_api_version();
-    if (transport_api_version == envoy::config::core::v3::ApiVersion::AUTO ||
-        transport_api_version == envoy::config::core::v3::ApiVersion::V2) {
-      runtime_.countDeprecatedFeatureUse();
-      const std::string& warning = fmt::format(
-          "V2 (and AUTO) xDS transport protocol versions are deprecated in {}. "
-          "The v2 xDS major version is deprecated and disabled by default. Support for v2 will be "
-          "removed from Envoy at the start of Q1 2021. You may make use of v2 in Q4 2020 by "
-          "following the advice in https://www.envoyproxy.io/docs/envoy/latest/faq/api/transition.",
-          config.DebugString());
-      ENVOY_LOG(warn, warning);
-      auto& runtime_snapshot = runtime_.snapshot();
-      if (!runtime_snapshot.runtimeFeatureEnabled(
-              "envoy.reloadable_features.enable_deprecated_v2_api")) {
-        throw DeprecatedMajorVersionException(warning);
-      }
-    }
-
+    const auto transport_api_version = Utility::getAndCheckTransportVersion(api_config_source);
     switch (api_config_source.api_type()) {
     case envoy::config::core::v3::ApiConfigSource::hidden_envoy_deprecated_UNSUPPORTED_REST_LEGACY:
       throw EnvoyException(
           "REST_LEGACY no longer a supported ApiConfigSource. "
           "Please specify an explicit supported api_type in the following config:\n" +
           config.DebugString());
     case envoy::config::core::v3::ApiConfigSource::REST:
       return std::make_unique<HttpSubscriptionImpl>(
           local_info_, cm_, api_config_source.cluster_names()[0], dispatcher_,
           api_.randomGenerator(), Utility::apiConfigSourceRefreshDelay(api_config_source),
           Utility::apiConfigSourceRequestTimeout(api_config_source),
-          restMethod(type_url, api_config_source.transport_api_version()), type_url,
-          api_config_source.transport_api_version(), callbacks, resource_decoder, stats,
-          Utility::configSourceInitialFetchTimeout(config), validation_visitor_);
+          restMethod(type_url, transport_api_version), type_url, transport_api_version, callbacks,
+          resource_decoder, stats, Utility::configSourceInitialFetchTimeout(config),
+          validation_visitor_);
     case envoy::config::core::v3::ApiConfigSource::GRPC:
       return std::make_unique<GrpcSubscriptionImpl>(
           std::make_shared<Config::GrpcMuxImpl>(
               local_info_,
               Utility::factoryForGrpcApiConfigSource(cm_.grpcAsyncClientManager(),
                                                      api_config_source, scope, true)
                   ->create(),
-              dispatcher_, sotwGrpcMethod(type_url, api_config_source.transport_api_version()),
-              api_config_source.transport_api_version(), api_.randomGenerator(), scope,
-              Utility::parseRateLimitSettings(api_config_source),
+              dispatcher_, sotwGrpcMethod(type_url, transport_api_version), transport_api_version,
+              api_.randomGenerator(), scope, Utility::parseRateLimitSettings(api_config_source),
               api_config_source.set_node_on_first_message_only()),
           callbacks, resource_decoder, stats, type_url, dispatcher_,
           Utility::configSourceInitialFetchTimeout(config),
           /*is_aggregated*/ false);
     case envoy::config::core::v3::ApiConfigSource::DELTA_GRPC: {
       return std::make_unique<GrpcSubscriptionImpl>(
           std::make_shared<Config::NewGrpcMuxImpl>(
               Config::Utility::factoryForGrpcApiConfigSource(cm_.grpcAsyncClientManager(),
                                                              api_config_source, scope, true)
                   ->create(),
-              dispatcher_, deltaGrpcMethod(type_url, api_config_source.transport_api_version()),
-              api_config_source.transport_api_version(), api_.randomGenerator(), scope,
-              Utility::parseRateLimitSettings(api_config_source), local_info_),
+              dispatcher_, deltaGrpcMethod(type_url, transport_api_version), transport_api_version,
+              api_.randomGenerator(), scope, Utility::parseRateLimitSettings(api_config_source),
+              local_info_),
           callbacks, resource_decoder, stats, type_url, dispatcher_,
           Utility::configSourceInitialFetchTimeout(config), false);
     }
     default:
       NOT_REACHED_GCOVR_EXCL_LINE;
     }
   }
   case envoy::config::core::v3::ConfigSource::ConfigSourceSpecifierCase::kAds: {
     return std::make_unique<GrpcSubscriptionImpl>(
         cm_.adsMux(), callbacks, resource_decoder, stats, type_url, dispatcher_,
         Utility::configSourceInitialFetchTimeout(config), true);
   }
   default:
     throw EnvoyException(
         "Missing config source specifier in envoy::config::core::v3::ConfigSource");
   }
   NOT_REACHED_GCOVR_EXCL_LINE;
 }
diff --git a/source/common/config/subscription_factory_impl.h b/source/common/config/subscription_factory_impl.h
index cc076be46d..5c0555533a 100644
--- a/source/common/config/subscription_factory_impl.h
+++ b/source/common/config/subscription_factory_impl.h
@@ -17,17 +17,16 @@ class SubscriptionFactoryImpl : public SubscriptionFactory, Logger::Loggable<Log
 public:
   SubscriptionFactoryImpl(const LocalInfo::LocalInfo& local_info, Event::Dispatcher& dispatcher,
                           Upstream::ClusterManager& cm,
-                          ProtobufMessage::ValidationVisitor& validation_visitor, Api::Api& api,
-                          Runtime::Loader& runtime);
+                          ProtobufMessage::ValidationVisitor& validation_visitor, Api::Api& api);
 
   // Config::SubscriptionFactory
   SubscriptionPtr subscriptionFromConfigSource(const envoy::config::core::v3::ConfigSource& config,
                                                absl::string_view type_url, Stats::Scope& scope,
                                                SubscriptionCallbacks& callbacks,
                                                OpaqueResourceDecoder& resource_decoder) override;
   SubscriptionPtr
   collectionSubscriptionFromUrl(const xds::core::v3::ResourceLocator& collection_locator,
                                 const envoy::config::core::v3::ConfigSource& config,
                                 absl::string_view type_url, Stats::Scope& scope,
                                 SubscriptionCallbacks& callbacks,
                                 OpaqueResourceDecoder& resource_decoder) override;
@@ -35,11 +34,10 @@ public:
 private:
   const LocalInfo::LocalInfo& local_info_;
   Event::Dispatcher& dispatcher_;
   Upstream::ClusterManager& cm_;
   ProtobufMessage::ValidationVisitor& validation_visitor_;
   Api::Api& api_;
-  Runtime::Loader& runtime_;
 };
 
 } // namespace Config
 } // namespace Envoy
diff --git a/source/common/config/utility.h b/source/common/config/utility.h
index b0c2bb1b73..828dd82ba3 100644
--- a/source/common/config/utility.h
+++ b/source/common/config/utility.h
@@ -1,31 +1,32 @@
 #pragma once
 
 #include "envoy/api/api.h"
 #include "envoy/common/random_generator.h"
 #include "envoy/config/bootstrap/v3/bootstrap.pb.h"
 #include "envoy/config/cluster/v3/cluster.pb.h"
 #include "envoy/config/core/v3/address.pb.h"
 #include "envoy/config/core/v3/config_source.pb.h"
 #include "envoy/config/endpoint/v3/endpoint.pb.h"
 #include "envoy/config/grpc_mux.h"
 #include "envoy/config/subscription.h"
 #include "envoy/local_info/local_info.h"
 #include "envoy/registry/registry.h"
 #include "envoy/server/filter_config.h"
 #include "envoy/stats/histogram.h"
 #include "envoy/stats/scope.h"
 #include "envoy/stats/stats_matcher.h"
 #include "envoy/stats/tag_producer.h"
 #include "envoy/upstream/cluster_manager.h"
 
 #include "common/common/assert.h"
 #include "common/common/backoff_strategy.h"
 #include "common/common/hash.h"
 #include "common/common/hex.h"
 #include "common/common/utility.h"
 #include "common/grpc/common.h"
 #include "common/protobuf/protobuf.h"
 #include "common/protobuf/utility.h"
+#include "common/runtime/runtime_features.h"
 #include "common/singleton/const_singleton.h"
 
 #include "udpa/type/v1/typed_struct.pb.h"
@@ -66,406 +67,434 @@ class Utility {
 public:
   /**
    * Legacy APIs uses JSON and do not have an explicit version.
    * @param input the input to hash.
    * @return std::pair<std::string, uint64_t> the string is the hash converted into
    *         a hex string, pre-pended by a user friendly prefix. The uint64_t is the
    *         raw hash.
    */
   static std::pair<std::string, uint64_t> computeHashedVersion(const std::string& input) {
     uint64_t hash = HashUtil::xxHash64(input);
     return std::make_pair("hash_" + Hex::uint64ToHex(hash), hash);
   }
 
   /**
    * Extract refresh_delay as a std::chrono::milliseconds from
    * envoy::config::core::v3::ApiConfigSource.
    */
   static std::chrono::milliseconds
   apiConfigSourceRefreshDelay(const envoy::config::core::v3::ApiConfigSource& api_config_source);
 
   /**
    * Extract request_timeout as a std::chrono::milliseconds from
    * envoy::config::core::v3::ApiConfigSource. If request_timeout isn't set in the config source, a
    * default value of 1s will be returned.
    */
   static std::chrono::milliseconds
   apiConfigSourceRequestTimeout(const envoy::config::core::v3::ApiConfigSource& api_config_source);
 
   /**
    * Extract initial_fetch_timeout as a std::chrono::milliseconds from
    * envoy::config::core::v3::ApiConfigSource. If request_timeout isn't set in the config source, a
    * default value of 0s will be returned.
    */
   static std::chrono::milliseconds
   configSourceInitialFetchTimeout(const envoy::config::core::v3::ConfigSource& config_source);
 
   /**
    * Populate an envoy::config::core::v3::ApiConfigSource.
    * @param cluster supplies the cluster name for the ApiConfigSource.
    * @param refresh_delay_ms supplies the refresh delay for the ApiConfigSource in ms.
    * @param api_type supplies the type of subscription to use for the ApiConfigSource.
    * @param api_config_source a reference to the envoy::config::core::v3::ApiConfigSource object to
    * populate.
    */
   static void translateApiConfigSource(const std::string& cluster, uint32_t refresh_delay_ms,
                                        const std::string& api_type,
                                        envoy::config::core::v3::ApiConfigSource& api_config_source);
 
   /**
    * Check cluster info for API config sanity. Throws on error.
    * @param error_prefix supplies the prefix to use in error messages.
    * @param cluster_name supplies the cluster name to check.
    * @param cm supplies the cluster manager.
    * @param allow_added_via_api indicates whether a cluster is allowed to be added via api
    *                            rather than be a static resource from the bootstrap config.
    * @return the main thread cluster if it exists.
    */
   static Upstream::ClusterConstOptRef checkCluster(absl::string_view error_prefix,
                                                    absl::string_view cluster_name,
                                                    Upstream::ClusterManager& cm,
                                                    bool allow_added_via_api = false);
 
   /**
    * Check cluster/local info for API config sanity. Throws on error.
    * @param error_prefix supplies the prefix to use in error messages.
    * @param cluster_name supplies the cluster name to check.
    * @param cm supplies the cluster manager.
    * @param local_info supplies the local info.
    * @return the main thread cluster if it exists.
    */
   static Upstream::ClusterConstOptRef
   checkClusterAndLocalInfo(absl::string_view error_prefix, absl::string_view cluster_name,
                            Upstream::ClusterManager& cm, const LocalInfo::LocalInfo& local_info);
 
   /**
    * Check local info for API config sanity. Throws on error.
    * @param error_prefix supplies the prefix to use in error messages.
    * @param local_info supplies the local info.
    */
   static void checkLocalInfo(absl::string_view error_prefix,
                              const LocalInfo::LocalInfo& local_info);
 
   /**
    * Check the existence of a path for a filesystem subscription. Throws on error.
    * @param path the path to validate.
    * @param api reference to the Api object
    */
   static void checkFilesystemSubscriptionBackingPath(const std::string& path, Api::Api& api);
 
   /**
    * Check the grpc_services and cluster_names for API config sanity. Throws on error.
    * @param api_config_source the config source to validate.
    * @throws EnvoyException when an API config has the wrong number of gRPC
    * services or cluster names, depending on expectations set by its API type.
    */
   static void
   checkApiConfigSourceNames(const envoy::config::core::v3::ApiConfigSource& api_config_source);
 
   /**
    * Check the validity of a cluster backing an api config source. Throws on error.
    * @param primary_clusters the API config source eligible clusters.
    * @param cluster_name the cluster name to validate.
    * @param config_source the config source typed name.
    * @throws EnvoyException when an API config doesn't have a statically defined non-EDS cluster.
    */
   static void validateClusterName(const Upstream::ClusterManager::ClusterSet& primary_clusters,
                                   const std::string& cluster_name,
                                   const std::string& config_source);
 
   /**
    * Potentially calls Utility::validateClusterName, if a cluster name can be found.
    * @param primary_clusters the API config source eligible clusters.
    * @param api_config_source the config source to validate.
    * @throws EnvoyException when an API config doesn't have a statically defined non-EDS cluster.
    */
   static void checkApiConfigSourceSubscriptionBackingCluster(
       const Upstream::ClusterManager::ClusterSet& primary_clusters,
       const envoy::config::core::v3::ApiConfigSource& api_config_source);
 
+  /**
+   * Access transport_api_version field in ApiConfigSource, while validating version
+   * compatibility.
+   * @param api_config_source the config source to extract transport API version from.
+   * @return envoy::config::core::v3::ApiVersion transport API version
+   * @throws DeprecatedMajorVersionException when the transport version is disabled.
+   */
+  template <class Proto>
+  static envoy::config::core::v3::ApiVersion
+  getAndCheckTransportVersion(const Proto& api_config_source) {
+    const auto transport_api_version = api_config_source.transport_api_version();
+    if (transport_api_version == envoy::config::core::v3::ApiVersion::AUTO ||
+        transport_api_version == envoy::config::core::v3::ApiVersion::V2) {
+      Runtime::LoaderSingleton::getExisting()->countDeprecatedFeatureUse();
+      const std::string& warning = fmt::format(
+          "V2 (and AUTO) xDS transport protocol versions are deprecated in {}. "
+          "The v2 xDS major version is deprecated and disabled by default. Support for v2 will be "
+          "removed from Envoy at the start of Q1 2021. You may make use of v2 in Q4 2020 by "
+          "following the advice in https://www.envoyproxy.io/docs/envoy/latest/faq/api/transition.",
+          api_config_source.DebugString());
+      ENVOY_LOG_MISC(warn, warning);
+      if (!Runtime::runtimeFeatureEnabled("envoy.reloadable_features.enable_deprecated_v2_api")) {
+        throw DeprecatedMajorVersionException(warning);
+      }
+    }
+    return transport_api_version;
+  }
+
   /**
    * Parses RateLimit configuration from envoy::config::core::v3::ApiConfigSource to
    * RateLimitSettings.
    * @param api_config_source ApiConfigSource.
    * @return RateLimitSettings.
    */
   static RateLimitSettings
   parseRateLimitSettings(const envoy::config::core::v3::ApiConfigSource& api_config_source);
 
   /**
    * Generate a ControlPlaneStats object from stats scope.
    * @param scope for stats.
    * @return ControlPlaneStats for scope.
    */
   static ControlPlaneStats generateControlPlaneStats(Stats::Scope& scope) {
     const std::string control_plane_prefix = "control_plane.";
     return {ALL_CONTROL_PLANE_STATS(POOL_COUNTER_PREFIX(scope, control_plane_prefix),
                                     POOL_GAUGE_PREFIX(scope, control_plane_prefix),
                                     POOL_TEXT_READOUT_PREFIX(scope, control_plane_prefix))};
   }
 
   /**
    * Generate a SubscriptionStats object from stats scope.
    * @param scope for stats.
    * @return SubscriptionStats for scope.
    */
   static SubscriptionStats generateStats(Stats::Scope& scope) {
     return {
         ALL_SUBSCRIPTION_STATS(POOL_COUNTER(scope), POOL_GAUGE(scope), POOL_TEXT_READOUT(scope))};
   }
 
   /**
    * Get a Factory from the registry with a particular name (and templated type) with error checking
    * to ensure the name and factory are valid.
    * @param name string identifier for the particular implementation.
    * @return factory the factory requested or nullptr if it does not exist.
    */
   template <class Factory> static Factory& getAndCheckFactoryByName(const std::string& name) {
     if (name.empty()) {
       ExceptionUtil::throwEnvoyException("Provided name for static registration lookup was empty.");
     }
 
     Factory* factory = Registry::FactoryRegistry<Factory>::getFactory(name);
 
     if (factory == nullptr) {
       ExceptionUtil::throwEnvoyException(
           fmt::format("Didn't find a registered implementation for name: '{}'", name));
     }
 
     return *factory;
   }
 
   /**
    * Get a Factory from the registry with a particular name or return nullptr.
    * @param name string identifier for the particular implementation.
    */
   template <class Factory> static Factory* getFactoryByName(const std::string& name) {
     if (name.empty()) {
       return nullptr;
     }
 
     return Registry::FactoryRegistry<Factory>::getFactory(name);
   }
 
   /**
    * Get a Factory from the registry or return nullptr.
    * @param message proto that contains fields 'name' and 'typed_config'.
    */
   template <class Factory, class ProtoMessage>
   static Factory* getFactory(const ProtoMessage& message) {
     Factory* factory = Utility::getFactoryByType<Factory>(message.typed_config());
     if (factory != nullptr) {
       return factory;
     }
 
     return Utility::getFactoryByName<Factory>(message.name());
   }
 
   /**
    * Get a Factory from the registry with error checking to ensure the name and the factory are
    * valid.
    * @param message proto that contains fields 'name' and 'typed_config'.
    */
   template <class Factory, class ProtoMessage>
   static Factory& getAndCheckFactory(const ProtoMessage& message) {
     Factory* factory = Utility::getFactoryByType<Factory>(message.typed_config());
     if (factory != nullptr) {
       return *factory;
     }
 
     return Utility::getAndCheckFactoryByName<Factory>(message.name());
   }
 
   /**
    * Get type URL from a typed config.
    * @param typed_config for the extension config.
    */
   static std::string getFactoryType(const ProtobufWkt::Any& typed_config) {
     static const std::string& typed_struct_type =
         udpa::type::v1::TypedStruct::default_instance().GetDescriptor()->full_name();
     // Unpack methods will only use the fully qualified type name after the last '/'.
     // https://github.com/protocolbuffers/protobuf/blob/3.6.x/src/google/protobuf/any.proto#L87
     auto type = std::string(TypeUtil::typeUrlToDescriptorFullName(typed_config.type_url()));
     if (type == typed_struct_type) {
       udpa::type::v1::TypedStruct typed_struct;
       MessageUtil::unpackTo(typed_config, typed_struct);
       // Not handling nested structs or typed structs in typed structs
       return std::string(TypeUtil::typeUrlToDescriptorFullName(typed_struct.type_url()));
     }
     return type;
   }
 
   /**
    * Get a Factory from the registry by type URL.
    * @param typed_config for the extension config.
    */
   template <class Factory> static Factory* getFactoryByType(const ProtobufWkt::Any& typed_config) {
     if (typed_config.type_url().empty()) {
       return nullptr;
     }
     return Registry::FactoryRegistry<Factory>::getFactoryByType(getFactoryType(typed_config));
   }
 
   /**
    * Translate a nested config into a proto message provided by the implementation factory.
    * @param enclosing_message proto that contains a field 'config'. Note: the enclosing proto is
    * provided because for statically registered implementations, a custom config is generally
    * optional, which means the conversion must be done conditionally.
    * @param validation_visitor message validation visitor instance.
    * @param factory implementation factory with the method 'createEmptyConfigProto' to produce a
    * proto to be filled with the translated configuration.
    */
   template <class ProtoMessage, class Factory>
   static ProtobufTypes::MessagePtr
   translateToFactoryConfig(const ProtoMessage& enclosing_message,
                            ProtobufMessage::ValidationVisitor& validation_visitor,
                            Factory& factory) {
     ProtobufTypes::MessagePtr config = factory.createEmptyConfigProto();
 
     // Fail in an obvious way if a plugin does not return a proto.
     RELEASE_ASSERT(config != nullptr, "");
 
     // Check that the config type is not google.protobuf.Empty
     RELEASE_ASSERT(config->GetDescriptor()->full_name() != "google.protobuf.Empty", "");
 
     translateOpaqueConfig(enclosing_message.typed_config(),
                           enclosing_message.hidden_envoy_deprecated_config(), validation_visitor,
                           *config);
     return config;
   }
 
   /**
    * Translate the typed any field into a proto message provided by the implementation factory.
    * @param typed_config typed configuration.
    * @param validation_visitor message validation visitor instance.
    * @param factory implementation factory with the method 'createEmptyConfigProto' to produce a
    * proto to be filled with the translated configuration.
    */
   template <class Factory>
   static ProtobufTypes::MessagePtr
   translateAnyToFactoryConfig(const ProtobufWkt::Any& typed_config,
                               ProtobufMessage::ValidationVisitor& validation_visitor,
                               Factory& factory) {
     ProtobufTypes::MessagePtr config = factory.createEmptyConfigProto();
 
     // Fail in an obvious way if a plugin does not return a proto.
     RELEASE_ASSERT(config != nullptr, "");
 
     // Check that the config type is not google.protobuf.Empty
     RELEASE_ASSERT(config->GetDescriptor()->full_name() != "google.protobuf.Empty", "");
 
     translateOpaqueConfig(typed_config, ProtobufWkt::Struct(), validation_visitor, *config);
     return config;
   }
 
   /**
    * Truncates the message to a length less than default GRPC trailers size limit (by default 8KiB).
    */
   static std::string truncateGrpcStatusMessage(absl::string_view error_message);
 
   /**
    * Create TagProducer instance. Check all tag names for conflicts to avoid
    * unexpected tag name overwriting.
    * @param bootstrap bootstrap proto.
    * @throws EnvoyException when the conflict of tag names is found.
    */
   static Stats::TagProducerPtr
   createTagProducer(const envoy::config::bootstrap::v3::Bootstrap& bootstrap);
 
   /**
    * Create StatsMatcher instance.
    */
   static Stats::StatsMatcherPtr
   createStatsMatcher(const envoy::config::bootstrap::v3::Bootstrap& bootstrap);
 
   /**
    * Create HistogramSettings instance.
    */
   static Stats::HistogramSettingsConstPtr
   createHistogramSettings(const envoy::config::bootstrap::v3::Bootstrap& bootstrap);
 
   /**
    * Obtain gRPC async client factory from a envoy::config::core::v3::ApiConfigSource.
    * @param async_client_manager gRPC async client manager.
    * @param api_config_source envoy::config::core::v3::ApiConfigSource. Must have config type GRPC.
    * @param skip_cluster_check whether to skip cluster validation.
    * @return Grpc::AsyncClientFactoryPtr gRPC async client factory.
    */
   static Grpc::AsyncClientFactoryPtr
   factoryForGrpcApiConfigSource(Grpc::AsyncClientManager& async_client_manager,
                                 const envoy::config::core::v3::ApiConfigSource& api_config_source,
                                 Stats::Scope& scope, bool skip_cluster_check);
 
   /**
    * Translate a set of cluster's hosts into a load assignment configuration.
    * @param hosts cluster's list of hosts.
    * @return envoy::config::endpoint::v3::ClusterLoadAssignment a load assignment configuration.
    */
   static envoy::config::endpoint::v3::ClusterLoadAssignment
   translateClusterHosts(const Protobuf::RepeatedPtrField<envoy::config::core::v3::Address>& hosts);
 
   /**
    * Translate opaque config from google.protobuf.Any or google.protobuf.Struct to defined proto
    * message.
    * @param typed_config opaque config packed in google.protobuf.Any
    * @param config the deprecated google.protobuf.Struct config, empty struct if doesn't exist.
    * @param validation_visitor message validation visitor instance.
    * @param out_proto the proto message instantiated by extensions
    */
   static void translateOpaqueConfig(const ProtobufWkt::Any& typed_config,
                                     const ProtobufWkt::Struct& config,
                                     ProtobufMessage::ValidationVisitor& validation_visitor,
                                     Protobuf::Message& out_proto);
 
   /**
    * Verify that any filter designed to be terminal is configured to be terminal, and vice versa.
    * @param name the name of the filter.
    * @param filter_type the type of filter.
    * @param filter_chain_type the type of filter chain.
    * @param is_terminal_filter true if the filter is designed to be terminal.
    * @param last_filter_in_current_config true if the filter is last in the configuration.
    * @throws EnvoyException if there is a mismatch between design and configuration.
    */
   static void validateTerminalFilters(const std::string& name, const std::string& filter_type,
                                       const char* filter_chain_type, bool is_terminal_filter,
                                       bool last_filter_in_current_config) {
     if (is_terminal_filter && !last_filter_in_current_config) {
       ExceptionUtil::throwEnvoyException(
           fmt::format("Error: terminal filter named {} of type {} must be the "
                       "last filter in a {} filter chain.",
                       name, filter_type, filter_chain_type));
     } else if (!is_terminal_filter && last_filter_in_current_config) {
       ExceptionUtil::throwEnvoyException(fmt::format(
           "Error: non-terminal filter named {} of type {} is the last filter in a {} filter chain.",
           name, filter_type, filter_chain_type));
     }
   }
 
   /**
    * Prepares the DNS failure refresh backoff strategy given the cluster configuration.
    * @param config the config that contains dns refresh information.
    * @param dns_refresh_rate_ms the default DNS refresh rate.
    * @param random the random generator.
    * @return BackOffStrategyPtr for scheduling refreshes.
    */
   template <typename T>
   static BackOffStrategyPtr prepareDnsRefreshStrategy(const T& config, uint64_t dns_refresh_rate_ms,
                                                       Random::RandomGenerator& random) {
     if (config.has_dns_failure_refresh_rate()) {
       uint64_t base_interval_ms =
           PROTOBUF_GET_MS_REQUIRED(config.dns_failure_refresh_rate(), base_interval);
       uint64_t max_interval_ms = PROTOBUF_GET_MS_OR_DEFAULT(config.dns_failure_refresh_rate(),
                                                             max_interval, base_interval_ms * 10);
       if (max_interval_ms < base_interval_ms) {
         ExceptionUtil::throwEnvoyException(
             "dns_failure_refresh_rate must have max_interval greater than "
             "or equal to the base_interval");
       }
       return std::make_unique<JitteredExponentialBackOffStrategy>(base_interval_ms, max_interval_ms,
                                                                   random);
     }
     return std::make_unique<FixedBackOffStrategy>(dns_refresh_rate_ms);
   }
 };
 
 } // namespace Config
 } // namespace Envoy
diff --git a/source/common/upstream/cluster_manager_impl.cc b/source/common/upstream/cluster_manager_impl.cc
index af026fe66b..b1950599c0 100644
--- a/source/common/upstream/cluster_manager_impl.cc
+++ b/source/common/upstream/cluster_manager_impl.cc
@@ -246,168 +246,168 @@ void ClusterManagerInitHelper::setPrimaryClustersInitializedCb(
 ClusterManagerImpl::ClusterManagerImpl(
     const envoy::config::bootstrap::v3::Bootstrap& bootstrap, ClusterManagerFactory& factory,
     Stats::Store& stats, ThreadLocal::Instance& tls, Runtime::Loader& runtime,
     const LocalInfo::LocalInfo& local_info, AccessLog::AccessLogManager& log_manager,
     Event::Dispatcher& main_thread_dispatcher, Server::Admin& admin,
     ProtobufMessage::ValidationContext& validation_context, Api::Api& api,
     Http::Context& http_context, Grpc::Context& grpc_context, Router::Context& router_context)
     : factory_(factory), runtime_(runtime), stats_(stats), tls_(tls),
       random_(api.randomGenerator()),
       bind_config_(bootstrap.cluster_manager().upstream_bind_config()), local_info_(local_info),
       cm_stats_(generateStats(stats)),
       init_helper_(*this, [this](ClusterManagerCluster& cluster) { onClusterInit(cluster); }),
       config_tracker_entry_(
           admin.getConfigTracker().add("clusters", [this] { return dumpClusterConfigs(); })),
       time_source_(main_thread_dispatcher.timeSource()), dispatcher_(main_thread_dispatcher),
       http_context_(http_context), router_context_(router_context),
       cluster_stat_names_(stats.symbolTable()),
       cluster_load_report_stat_names_(stats.symbolTable()),
       cluster_circuit_breakers_stat_names_(stats.symbolTable()),
       cluster_request_response_size_stat_names_(stats.symbolTable()),
       cluster_timeout_budget_stat_names_(stats.symbolTable()),
       subscription_factory_(local_info, main_thread_dispatcher, *this,
-                            validation_context.dynamicValidationVisitor(), api, runtime_) {
+                            validation_context.dynamicValidationVisitor(), api) {
   async_client_manager_ = std::make_unique<Grpc::AsyncClientManagerImpl>(
       *this, tls, time_source_, api, grpc_context.statNames());
   const auto& cm_config = bootstrap.cluster_manager();
   if (cm_config.has_outlier_detection()) {
     const std::string event_log_file_path = cm_config.outlier_detection().event_log_path();
     if (!event_log_file_path.empty()) {
       outlier_event_logger_ = std::make_shared<Outlier::EventLoggerImpl>(
           log_manager, event_log_file_path, time_source_);
     }
   }
 
   // We need to know whether we're zone aware early on, so make sure we do this lookup
   // before we load any clusters.
   if (!cm_config.local_cluster_name().empty()) {
     local_cluster_name_ = cm_config.local_cluster_name();
   }
 
   const auto& dyn_resources = bootstrap.dynamic_resources();
 
   // Cluster loading happens in two phases: first all the primary clusters are loaded, and then all
   // the secondary clusters are loaded. As it currently stands all non-EDS clusters and EDS which
   // load endpoint definition from file are primary and
   // (REST,GRPC,DELTA_GRPC) EDS clusters are secondary. This two phase
   // loading is done because in v2 configuration each EDS cluster individually sets up a
   // subscription. When this subscription is an API source the cluster will depend on a non-EDS
   // cluster, so the non-EDS clusters must be loaded first.
   auto is_primary_cluster = [](const envoy::config::cluster::v3::Cluster& cluster) -> bool {
     return cluster.type() != envoy::config::cluster::v3::Cluster::EDS ||
            (cluster.type() == envoy::config::cluster::v3::Cluster::EDS &&
             cluster.eds_cluster_config().eds_config().config_source_specifier_case() ==
                 envoy::config::core::v3::ConfigSource::ConfigSourceSpecifierCase::kPath);
   };
   // Build book-keeping for which clusters are primary. This is useful when we
   // invoke loadCluster() below and it needs the complete set of primaries.
   for (const auto& cluster : bootstrap.static_resources().clusters()) {
     if (is_primary_cluster(cluster)) {
       primary_clusters_.insert(cluster.name());
     }
   }
   // Load all the primary clusters.
   for (const auto& cluster : bootstrap.static_resources().clusters()) {
     if (is_primary_cluster(cluster)) {
       loadCluster(cluster, "", false, active_clusters_);
     }
   }
 
   // Now setup ADS if needed, this might rely on a primary cluster.
   // This is the only point where distinction between delta ADS and state-of-the-world ADS is made.
   // After here, we just have a GrpcMux interface held in ads_mux_, which hides
   // whether the backing implementation is delta or SotW.
   if (dyn_resources.has_ads_config()) {
     if (dyn_resources.ads_config().api_type() ==
         envoy::config::core::v3::ApiConfigSource::DELTA_GRPC) {
       ads_mux_ = std::make_shared<Config::NewGrpcMuxImpl>(
           Config::Utility::factoryForGrpcApiConfigSource(*async_client_manager_,
                                                          dyn_resources.ads_config(), stats, false)
               ->create(),
           main_thread_dispatcher,
           *Protobuf::DescriptorPool::generated_pool()->FindMethodByName(
-              dyn_resources.ads_config().transport_api_version() ==
+              Config::Utility::getAndCheckTransportVersion(dyn_resources.ads_config()) ==
                       envoy::config::core::v3::ApiVersion::V3
                   // TODO(htuch): consolidate with type_to_endpoint.cc, once we sort out the future
                   // direction of that module re: https://github.com/envoyproxy/envoy/issues/10650.
                   ? "envoy.service.discovery.v3.AggregatedDiscoveryService.DeltaAggregatedResources"
                   : "envoy.service.discovery.v2.AggregatedDiscoveryService."
                     "DeltaAggregatedResources"),
-          dyn_resources.ads_config().transport_api_version(), random_, stats_,
+          Config::Utility::getAndCheckTransportVersion(dyn_resources.ads_config()), random_, stats_,
           Envoy::Config::Utility::parseRateLimitSettings(dyn_resources.ads_config()), local_info);
     } else {
       ads_mux_ = std::make_shared<Config::GrpcMuxImpl>(
           local_info,
           Config::Utility::factoryForGrpcApiConfigSource(*async_client_manager_,
                                                          dyn_resources.ads_config(), stats, false)
               ->create(),
           main_thread_dispatcher,
           *Protobuf::DescriptorPool::generated_pool()->FindMethodByName(
-              dyn_resources.ads_config().transport_api_version() ==
+              Config::Utility::getAndCheckTransportVersion(dyn_resources.ads_config()) ==
                       envoy::config::core::v3::ApiVersion::V3
                   // TODO(htuch): consolidate with type_to_endpoint.cc, once we sort out the future
                   // direction of that module re: https://github.com/envoyproxy/envoy/issues/10650.
                   ? "envoy.service.discovery.v3.AggregatedDiscoveryService."
                     "StreamAggregatedResources"
                   : "envoy.service.discovery.v2.AggregatedDiscoveryService."
                     "StreamAggregatedResources"),
-          dyn_resources.ads_config().transport_api_version(), random_, stats_,
+          Config::Utility::getAndCheckTransportVersion(dyn_resources.ads_config()), random_, stats_,
           Envoy::Config::Utility::parseRateLimitSettings(dyn_resources.ads_config()),
           bootstrap.dynamic_resources().ads_config().set_node_on_first_message_only());
     }
   } else {
     ads_mux_ = std::make_unique<Config::NullGrpcMuxImpl>();
   }
 
   // After ADS is initialized, load EDS static clusters as EDS config may potentially need ADS.
   for (const auto& cluster : bootstrap.static_resources().clusters()) {
     // Now load all the secondary clusters.
     if (cluster.type() == envoy::config::cluster::v3::Cluster::EDS &&
         cluster.eds_cluster_config().eds_config().config_source_specifier_case() !=
             envoy::config::core::v3::ConfigSource::ConfigSourceSpecifierCase::kPath) {
       loadCluster(cluster, "", false, active_clusters_);
     }
   }
 
   cm_stats_.cluster_added_.add(bootstrap.static_resources().clusters().size());
   updateClusterCounts();
 
   absl::optional<ThreadLocalClusterManagerImpl::LocalClusterParams> local_cluster_params;
   if (local_cluster_name_) {
     auto local_cluster = active_clusters_.find(local_cluster_name_.value());
     if (local_cluster == active_clusters_.end()) {
       throw EnvoyException(
           fmt::format("local cluster '{}' must be defined", local_cluster_name_.value()));
     }
     local_cluster_params.emplace();
     local_cluster_params->info_ = local_cluster->second->cluster().info();
     local_cluster_params->load_balancer_factory_ = local_cluster->second->loadBalancerFactory();
     local_cluster->second->setAddedOrUpdated();
   }
 
   // Once the initial set of static bootstrap clusters are created (including the local cluster),
   // we can instantiate the thread local cluster manager.
   tls_.set([this, local_cluster_params](Event::Dispatcher& dispatcher) {
     return std::make_shared<ThreadLocalClusterManagerImpl>(*this, dispatcher, local_cluster_params);
   });
 
   // We can now potentially create the CDS API once the backing cluster exists.
   if (dyn_resources.has_cds_config()) {
     cds_api_ = factory_.createCds(dyn_resources.cds_config(), *this);
     init_helper_.setCds(cds_api_.get());
   } else {
     init_helper_.setCds(nullptr);
   }
 
   // Proceed to add all static bootstrap clusters to the init manager. This will immediately
   // initialize any primary clusters. Post-init processing further initializes any thread
   // aware load balancer and sets up the per-worker host set updates.
   for (auto& cluster : active_clusters_) {
     init_helper_.addCluster(*cluster.second);
   }
 
   // Potentially move to secondary initialization on the static bootstrap clusters if all primary
   // clusters have already initialized. (E.g., if all static).
   init_helper_.onStaticLoadComplete();
 
   ads_mux_->start();
 }
@@ -415,17 +415,17 @@ ClusterManagerImpl::ClusterManagerImpl(
 void ClusterManagerImpl::initializeSecondaryClusters(
     const envoy::config::bootstrap::v3::Bootstrap& bootstrap) {
   init_helper_.startInitializingSecondaryClusters();
 
   const auto& cm_config = bootstrap.cluster_manager();
   if (cm_config.has_load_stats_config()) {
     const auto& load_stats_config = cm_config.load_stats_config();
 
     load_stats_reporter_ = std::make_unique<LoadStatsReporter>(
         local_info_, *this, stats_,
         Config::Utility::factoryForGrpcApiConfigSource(*async_client_manager_, load_stats_config,
                                                        stats_, false)
             ->create(),
-        load_stats_config.transport_api_version(), dispatcher_);
+        Config::Utility::getAndCheckTransportVersion(load_stats_config), dispatcher_);
   }
 }
 
diff --git a/source/extensions/access_loggers/common/BUILD b/source/extensions/access_loggers/common/BUILD
index 9a55e9e2ca..c77fe9dca5 100644
--- a/source/extensions/access_loggers/common/BUILD
+++ b/source/extensions/access_loggers/common/BUILD
@@ -25,17 +25,18 @@ envoy_cc_library(
 envoy_cc_library(
     name = "grpc_access_logger",
     hdrs = ["grpc_access_logger.h"],
     deps = [
         "//include/envoy/event:dispatcher_interface",
         "//include/envoy/grpc:async_client_manager_interface",
         "//include/envoy/local_info:local_info_interface",
         "//include/envoy/singleton:instance_interface",
         "//include/envoy/stats:stats_interface",
         "//include/envoy/thread_local:thread_local_interface",
         "//source/common/common:assert_lib",
+        "//source/common/config:utility_lib",
         "//source/common/grpc:typed_async_client_lib",
         "//source/common/protobuf:utility_lib",
         "@com_google_absl//absl/types:optional",
         "@envoy_api//envoy/config/core/v3:pkg_cc_proto",
     ],
 )
diff --git a/source/extensions/access_loggers/common/grpc_access_logger.h b/source/extensions/access_loggers/common/grpc_access_logger.h
index 90e7b0d8a8..911326ee54 100644
--- a/source/extensions/access_loggers/common/grpc_access_logger.h
+++ b/source/extensions/access_loggers/common/grpc_access_logger.h
@@ -1,18 +1,19 @@
 #pragma once
 
 #include <memory>
 
 #include "envoy/config/core/v3/config_source.pb.h"
 #include "envoy/event/dispatcher.h"
 #include "envoy/grpc/async_client_manager.h"
 #include "envoy/local_info/local_info.h"
 #include "envoy/singleton/instance.h"
 #include "envoy/stats/scope.h"
 #include "envoy/thread_local/thread_local.h"
 
 #include "common/common/assert.h"
+#include "common/config/utility.h"
 #include "common/grpc/typed_async_client.h"
 #include "common/protobuf/utility.h"
 
 #include "absl/container/flat_hash_map.h"
 #include "absl/types/optional.h"
@@ -175,33 +176,33 @@ class GrpcAccessLoggerCache : public Singleton::Instance,
                               public Detail::GrpcAccessLoggerCache<GrpcAccessLogger, ConfigProto> {
 public:
   using Interface = Detail::GrpcAccessLoggerCache<GrpcAccessLogger, ConfigProto>;
 
   GrpcAccessLoggerCache(Grpc::AsyncClientManager& async_client_manager, Stats::Scope& scope,
                         ThreadLocal::SlotAllocator& tls, const LocalInfo::LocalInfo& local_info)
       : async_client_manager_(async_client_manager), scope_(scope), tls_slot_(tls.allocateSlot()),
         local_info_(local_info) {
     tls_slot_->set([](Event::Dispatcher& dispatcher) {
       return std::make_shared<ThreadLocalCache>(dispatcher);
     });
   }
 
   typename GrpcAccessLogger::SharedPtr getOrCreateLogger(const ConfigProto& config,
                                                          GrpcAccessLoggerType logger_type,
                                                          Stats::Scope& scope) override {
     // TODO(euroelessar): Consider cleaning up loggers.
     auto& cache = tls_slot_->getTyped<ThreadLocalCache>();
     const auto cache_key = std::make_pair(MessageUtil::hash(config), logger_type);
     const auto it = cache.access_loggers_.find(cache_key);
     if (it != cache.access_loggers_.end()) {
       return it->second;
     }
     const Grpc::AsyncClientFactoryPtr factory =
         async_client_manager_.factoryForGrpcService(config.grpc_service(), scope_, false);
     const auto logger = std::make_shared<GrpcAccessLogger>(
         factory->create(), config.log_name(),
         std::chrono::milliseconds(PROTOBUF_GET_MS_OR_DEFAULT(config, buffer_flush_interval, 1000)),
         PROTOBUF_GET_WRAPPED_OR_DEFAULT(config, buffer_size_bytes, 16384), cache.dispatcher_,
-        local_info_, scope, config.transport_api_version());
+        local_info_, scope, Config::Utility::getAndCheckTransportVersion(config));
     cache.access_loggers_.emplace(cache_key, logger);
     return logger;
   }
diff --git a/source/extensions/filters/http/ext_authz/BUILD b/source/extensions/filters/http/ext_authz/BUILD
index c758367978..9a902c5177 100644
--- a/source/extensions/filters/http/ext_authz/BUILD
+++ b/source/extensions/filters/http/ext_authz/BUILD
@@ -39,18 +39,19 @@ envoy_cc_library(
 envoy_cc_extension(
     name = "config",
     srcs = ["config.cc"],
     hdrs = ["config.h"],
     security_posture = "robust_to_untrusted_downstream",
     deps = [
         ":ext_authz",
         "//include/envoy/registry",
         "//include/envoy/stats:stats_macros",
+        "//source/common/config:utility_lib",
         "//source/common/grpc:google_async_client_cache",
         "//source/common/protobuf:utility_lib",
         "//source/extensions/filters/common/ext_authz:ext_authz_http_lib",
         "//source/extensions/filters/http:well_known_names",
         "//source/extensions/filters/http/common:factory_base_lib",
         "@envoy_api//envoy/config/core/v3:pkg_cc_proto",
         "@envoy_api//envoy/extensions/filters/http/ext_authz/v3:pkg_cc_proto",
     ],
 )
diff --git a/source/extensions/filters/http/ext_authz/config.cc b/source/extensions/filters/http/ext_authz/config.cc
index 22162671e7..5446cb7a55 100644
--- a/source/extensions/filters/http/ext_authz/config.cc
+++ b/source/extensions/filters/http/ext_authz/config.cc
@@ -1,16 +1,17 @@
 #include "extensions/filters/http/ext_authz/config.h"
 
 #include <chrono>
 #include <string>
 
 #include "envoy/config/core/v3/grpc_service.pb.h"
 #include "envoy/extensions/filters/http/ext_authz/v3/ext_authz.pb.h"
 #include "envoy/extensions/filters/http/ext_authz/v3/ext_authz.pb.validate.h"
 #include "envoy/registry/registry.h"
 
+#include "common/config/utility.h"
 #include "common/grpc/google_async_client_cache.h"
 #include "common/protobuf/utility.h"
 
 #include "extensions/filters/common/ext_authz/ext_authz_grpc_impl.h"
 #include "extensions/filters/common/ext_authz/ext_authz_http_impl.h"
 #include "extensions/filters/http/ext_authz/ext_authz.h"
@@ -23,74 +24,74 @@ namespace ExtAuthz {
 Http::FilterFactoryCb ExtAuthzFilterConfig::createFilterFactoryFromProtoTyped(
     const envoy::extensions::filters::http::ext_authz::v3::ExtAuthz& proto_config,
     const std::string& stats_prefix, Server::Configuration::FactoryContext& context) {
   const auto filter_config = std::make_shared<FilterConfig>(
       proto_config, context.scope(), context.runtime(), context.httpContext(), stats_prefix);
   Http::FilterFactoryCb callback;
 
   if (proto_config.has_http_service()) {
     // Raw HTTP client.
     const uint32_t timeout_ms = PROTOBUF_GET_MS_OR_DEFAULT(proto_config.http_service().server_uri(),
                                                            timeout, DefaultTimeout);
     const auto client_config =
         std::make_shared<Extensions::Filters::Common::ExtAuthz::ClientConfig>(
             proto_config, timeout_ms, proto_config.http_service().path_prefix());
     callback = [filter_config, client_config,
                 &context](Http::FilterChainFactoryCallbacks& callbacks) {
       auto client = std::make_unique<Extensions::Filters::Common::ExtAuthz::RawHttpClientImpl>(
           context.clusterManager(), client_config);
       callbacks.addStreamDecoderFilter(Http::StreamDecoderFilterSharedPtr{
           std::make_shared<Filter>(filter_config, std::move(client))});
     };
   } else if (proto_config.grpc_service().has_google_grpc()) {
     // Google gRPC client.
 
     // The use_alpha field was there select the v2alpha api version, which is
     // long deprecated and should not be used anymore.
     if (proto_config.hidden_envoy_deprecated_use_alpha()) {
       throw EnvoyException("The use_alpha field is deprecated and is no longer supported.");
     }
 
     const uint32_t timeout_ms =
         PROTOBUF_GET_MS_OR_DEFAULT(proto_config.grpc_service(), timeout, DefaultTimeout);
     Grpc::AsyncClientCacheSingletonSharedPtr async_client_cache_singleton =
         Grpc::getAsyncClientCacheSingleton(context.getServerFactoryContext());
     Grpc::AsyncClientCacheSharedPtr async_client_cache =
         async_client_cache_singleton->getOrCreateAsyncClientCache(
             context.clusterManager().grpcAsyncClientManager(), context.scope(),
             context.threadLocal(), proto_config.grpc_service());
     callback = [async_client_cache, filter_config, timeout_ms, proto_config,
-                transport_api_version = proto_config.transport_api_version()](
+                transport_api_version = Config::Utility::getAndCheckTransportVersion(proto_config)](
                    Http::FilterChainFactoryCallbacks& callbacks) {
       auto client = std::make_unique<Filters::Common::ExtAuthz::GrpcClientImpl>(
           async_client_cache->getAsyncClient(), std::chrono::milliseconds(timeout_ms),
           transport_api_version);
       callbacks.addStreamDecoderFilter(Http::StreamDecoderFilterSharedPtr{
           std::make_shared<Filter>(filter_config, std::move(client))});
     };
   } else {
     // Envoy gRPC client.
 
     // The use_alpha field was there select the v2alpha api version, which is
     // long deprecated and should not be used anymore.
     if (proto_config.hidden_envoy_deprecated_use_alpha()) {
       throw EnvoyException("The use_alpha field is deprecated and is no longer supported.");
     }
 
     const uint32_t timeout_ms =
         PROTOBUF_GET_MS_OR_DEFAULT(proto_config.grpc_service(), timeout, DefaultTimeout);
     callback = [grpc_service = proto_config.grpc_service(), &context, filter_config, timeout_ms,
-                transport_api_version = proto_config.transport_api_version()](
+                transport_api_version = Config::Utility::getAndCheckTransportVersion(proto_config)](
                    Http::FilterChainFactoryCallbacks& callbacks) {
       const auto async_client_factory =
           context.clusterManager().grpcAsyncClientManager().factoryForGrpcService(
               grpc_service, context.scope(), true);
       auto client = std::make_unique<Filters::Common::ExtAuthz::GrpcClientImpl>(
           async_client_factory->create(), std::chrono::milliseconds(timeout_ms),
           transport_api_version);
       callbacks.addStreamDecoderFilter(Http::StreamDecoderFilterSharedPtr{
           std::make_shared<Filter>(filter_config, std::move(client))});
     };
   }
 
   return callback;
 }
diff --git a/source/extensions/filters/http/ratelimit/BUILD b/source/extensions/filters/http/ratelimit/BUILD
index 0b95847111..a4090ee21d 100644
--- a/source/extensions/filters/http/ratelimit/BUILD
+++ b/source/extensions/filters/http/ratelimit/BUILD
@@ -44,16 +44,17 @@ envoy_cc_library(
 envoy_cc_extension(
     name = "config",
     srcs = ["config.cc"],
     hdrs = ["config.h"],
     security_posture = "robust_to_untrusted_downstream",
     deps = [
         ":ratelimit_lib",
         "//include/envoy/registry",
+        "//source/common/config:utility_lib",
         "//source/common/protobuf:utility_lib",
         "//source/extensions/filters/common/ratelimit:ratelimit_client_interface",
         "//source/extensions/filters/common/ratelimit:ratelimit_lib",
         "//source/extensions/filters/http:well_known_names",
         "//source/extensions/filters/http/common:factory_base_lib",
         "@envoy_api//envoy/extensions/filters/http/ratelimit/v3:pkg_cc_proto",
     ],
 )
diff --git a/source/extensions/filters/http/ratelimit/config.cc b/source/extensions/filters/http/ratelimit/config.cc
index 9ff4038e99..912604d37a 100644
--- a/source/extensions/filters/http/ratelimit/config.cc
+++ b/source/extensions/filters/http/ratelimit/config.cc
@@ -1,13 +1,14 @@
 #include "extensions/filters/http/ratelimit/config.h"
 
 #include <chrono>
 #include <string>
 
 #include "envoy/extensions/filters/http/ratelimit/v3/rate_limit.pb.h"
 #include "envoy/extensions/filters/http/ratelimit/v3/rate_limit.pb.validate.h"
 #include "envoy/registry/registry.h"
 
+#include "common/config/utility.h"
 #include "common/protobuf/utility.h"
 
 #include "extensions/filters/common/ratelimit/ratelimit_impl.h"
 #include "extensions/filters/http/ratelimit/ratelimit.h"
@@ -20,19 +21,20 @@ namespace RateLimitFilter {
 Http::FilterFactoryCb RateLimitFilterConfig::createFilterFactoryFromProtoTyped(
     const envoy::extensions::filters::http::ratelimit::v3::RateLimit& proto_config,
     const std::string&, Server::Configuration::FactoryContext& context) {
   ASSERT(!proto_config.domain().empty());
   FilterConfigSharedPtr filter_config(new FilterConfig(proto_config, context.localInfo(),
                                                        context.scope(), context.runtime(),
                                                        context.httpContext()));
   const std::chrono::milliseconds timeout =
       std::chrono::milliseconds(PROTOBUF_GET_MS_OR_DEFAULT(proto_config, timeout, 20));
 
   return [proto_config, &context, timeout,
           filter_config](Http::FilterChainFactoryCallbacks& callbacks) -> void {
     callbacks.addStreamFilter(std::make_shared<Filter>(
-        filter_config, Filters::Common::RateLimit::rateLimitClient(
-                           context, proto_config.rate_limit_service().grpc_service(), timeout,
-                           proto_config.rate_limit_service().transport_api_version())));
+        filter_config,
+        Filters::Common::RateLimit::rateLimitClient(
+            context, proto_config.rate_limit_service().grpc_service(), timeout,
+            Config::Utility::getAndCheckTransportVersion(proto_config.rate_limit_service()))));
   };
 }
 
diff --git a/source/extensions/filters/network/ext_authz/BUILD b/source/extensions/filters/network/ext_authz/BUILD
index 3ef4a4738a..4d43cbd30e 100644
--- a/source/extensions/filters/network/ext_authz/BUILD
+++ b/source/extensions/filters/network/ext_authz/BUILD
@@ -36,15 +36,16 @@ envoy_cc_library(
 envoy_cc_extension(
     name = "config",
     srcs = ["config.cc"],
     hdrs = ["config.h"],
     security_posture = "robust_to_untrusted_downstream",
     deps = [
         "//include/envoy/registry",
+        "//source/common/config:utility_lib",
         "//source/common/protobuf:utility_lib",
         "//source/extensions/filters/network:well_known_names",
         "//source/extensions/filters/network/common:factory_base_lib",
         "//source/extensions/filters/network/ext_authz",
         "@envoy_api//envoy/config/core/v3:pkg_cc_proto",
         "@envoy_api//envoy/extensions/filters/network/ext_authz/v3:pkg_cc_proto",
     ],
 )
diff --git a/source/extensions/filters/network/ext_authz/config.cc b/source/extensions/filters/network/ext_authz/config.cc
index a8a4188b39..65e852f6a1 100644
--- a/source/extensions/filters/network/ext_authz/config.cc
+++ b/source/extensions/filters/network/ext_authz/config.cc
@@ -1,16 +1,17 @@
 #include "extensions/filters/network/ext_authz/config.h"
 
 #include <chrono>
 #include <string>
 
 #include "envoy/config/core/v3/grpc_service.pb.h"
 #include "envoy/extensions/filters/network/ext_authz/v3/ext_authz.pb.h"
 #include "envoy/extensions/filters/network/ext_authz/v3/ext_authz.pb.validate.h"
 #include "envoy/network/connection.h"
 #include "envoy/registry/registry.h"
 
+#include "common/config/utility.h"
 #include "common/protobuf/utility.h"
 
 #include "extensions/filters/common/ext_authz/ext_authz.h"
 #include "extensions/filters/common/ext_authz/ext_authz_grpc_impl.h"
 #include "extensions/filters/network/ext_authz/ext_authz.h"
@@ -23,24 +24,24 @@ namespace ExtAuthz {
 Network::FilterFactoryCb ExtAuthzConfigFactory::createFilterFactoryFromProtoTyped(
     const envoy::extensions::filters::network::ext_authz::v3::ExtAuthz& proto_config,
     Server::Configuration::FactoryContext& context) {
   ConfigSharedPtr ext_authz_config = std::make_shared<Config>(proto_config, context.scope());
   const uint32_t timeout_ms = PROTOBUF_GET_MS_OR_DEFAULT(proto_config.grpc_service(), timeout, 200);
 
   return [grpc_service = proto_config.grpc_service(), &context, ext_authz_config,
-          transport_api_version = proto_config.transport_api_version(),
+          transport_api_version = Envoy::Config::Utility::getAndCheckTransportVersion(proto_config),
           timeout_ms](Network::FilterManager& filter_manager) -> void {
     auto async_client_factory =
         context.clusterManager().grpcAsyncClientManager().factoryForGrpcService(
             grpc_service, context.scope(), true);
 
     auto client = std::make_unique<Filters::Common::ExtAuthz::GrpcClientImpl>(
         async_client_factory->create(), std::chrono::milliseconds(timeout_ms),
         transport_api_version);
     filter_manager.addReadFilter(Network::ReadFilterSharedPtr{
         std::make_shared<Filter>(ext_authz_config, std::move(client))});
   };
 }
 
 /**
  * Static registration for the external authorization filter. @see RegisterFactory.
  */
diff --git a/source/extensions/filters/network/ratelimit/BUILD b/source/extensions/filters/network/ratelimit/BUILD
index f653adf348..035bfad5b6 100644
--- a/source/extensions/filters/network/ratelimit/BUILD
+++ b/source/extensions/filters/network/ratelimit/BUILD
@@ -37,16 +37,17 @@ envoy_cc_library(
 envoy_cc_extension(
     name = "config",
     srcs = ["config.cc"],
     hdrs = ["config.h"],
     security_posture = "robust_to_untrusted_downstream",
     deps = [
         "//include/envoy/registry",
+        "//source/common/config:utility_lib",
         "//source/common/protobuf:utility_lib",
         "//source/extensions/filters/common/ratelimit:ratelimit_client_interface",
         "//source/extensions/filters/common/ratelimit:ratelimit_lib",
         "//source/extensions/filters/network:well_known_names",
         "//source/extensions/filters/network/common:factory_base_lib",
         "//source/extensions/filters/network/ratelimit:ratelimit_lib",
         "@envoy_api//envoy/extensions/filters/network/ratelimit/v3:pkg_cc_proto",
     ],
 )
diff --git a/source/extensions/filters/network/ratelimit/config.cc b/source/extensions/filters/network/ratelimit/config.cc
index 82037f5b42..b60bd47e54 100644
--- a/source/extensions/filters/network/ratelimit/config.cc
+++ b/source/extensions/filters/network/ratelimit/config.cc
@@ -1,13 +1,14 @@
 #include "extensions/filters/network/ratelimit/config.h"
 
 #include <chrono>
 #include <string>
 
 #include "envoy/extensions/filters/network/ratelimit/v3/rate_limit.pb.h"
 #include "envoy/extensions/filters/network/ratelimit/v3/rate_limit.pb.validate.h"
 #include "envoy/registry/registry.h"
 
+#include "common/config/utility.h"
 #include "common/protobuf/utility.h"
 
 #include "extensions/filters/common/ratelimit/ratelimit_impl.h"
 #include "extensions/filters/network/ratelimit/ratelimit.h"
@@ -20,26 +21,25 @@ namespace RateLimitFilter {
 Network::FilterFactoryCb RateLimitConfigFactory::createFilterFactoryFromProtoTyped(
     const envoy::extensions::filters::network::ratelimit::v3::RateLimit& proto_config,
     Server::Configuration::FactoryContext& context) {
 
   ASSERT(!proto_config.stat_prefix().empty());
   ASSERT(!proto_config.domain().empty());
   ASSERT(proto_config.descriptors_size() > 0);
 
   ConfigSharedPtr filter_config(new Config(proto_config, context.scope(), context.runtime()));
   const std::chrono::milliseconds timeout =
       std::chrono::milliseconds(PROTOBUF_GET_MS_OR_DEFAULT(proto_config, timeout, 20));
 
   return [proto_config, &context, timeout,
           filter_config](Network::FilterManager& filter_manager) -> void {
     filter_manager.addReadFilter(std::make_shared<Filter>(
-        filter_config,
-
-        Filters::Common::RateLimit::rateLimitClient(
-            context, proto_config.rate_limit_service().grpc_service(), timeout,
-            proto_config.rate_limit_service().transport_api_version())));
+        filter_config, Filters::Common::RateLimit::rateLimitClient(
+                           context, proto_config.rate_limit_service().grpc_service(), timeout,
+                           Envoy::Config::Utility::getAndCheckTransportVersion(
+                               proto_config.rate_limit_service()))));
   };
 }
 
 /**
  * Static registration for the rate limit filter. @see RegisterFactory.
  */
diff --git a/source/extensions/filters/network/thrift_proxy/filters/ratelimit/BUILD b/source/extensions/filters/network/thrift_proxy/filters/ratelimit/BUILD
index 7252afc340..02425a8b06 100644
--- a/source/extensions/filters/network/thrift_proxy/filters/ratelimit/BUILD
+++ b/source/extensions/filters/network/thrift_proxy/filters/ratelimit/BUILD
@@ -30,17 +30,18 @@ envoy_cc_library(
 envoy_cc_extension(
     name = "config",
     srcs = ["config.cc"],
     hdrs = ["config.h"],
     security_posture = "requires_trusted_downstream_and_upstream",
     status = "alpha",
     deps = [
         ":ratelimit_lib",
         "//include/envoy/registry",
+        "//source/common/config:utility_lib",
         "//source/common/protobuf:utility_lib",
         "//source/extensions/filters/common/ratelimit:ratelimit_client_interface",
         "//source/extensions/filters/common/ratelimit:ratelimit_lib",
         "//source/extensions/filters/network/thrift_proxy/filters:factory_base_lib",
         "//source/extensions/filters/network/thrift_proxy/filters:well_known_names",
         "@envoy_api//envoy/extensions/filters/network/thrift_proxy/filters/ratelimit/v3:pkg_cc_proto",
     ],
 )
diff --git a/source/extensions/filters/network/thrift_proxy/filters/ratelimit/config.cc b/source/extensions/filters/network/thrift_proxy/filters/ratelimit/config.cc
index 9813ec583c..9383c2782c 100644
--- a/source/extensions/filters/network/thrift_proxy/filters/ratelimit/config.cc
+++ b/source/extensions/filters/network/thrift_proxy/filters/ratelimit/config.cc
@@ -1,13 +1,14 @@
 #include "extensions/filters/network/thrift_proxy/filters/ratelimit/config.h"
 
 #include <chrono>
 #include <string>
 
 #include "envoy/extensions/filters/network/thrift_proxy/filters/ratelimit/v3/rate_limit.pb.h"
 #include "envoy/extensions/filters/network/thrift_proxy/filters/ratelimit/v3/rate_limit.pb.validate.h"
 #include "envoy/registry/registry.h"
 
+#include "common/config/utility.h"
 #include "common/protobuf/utility.h"
 
 #include "extensions/filters/common/ratelimit/ratelimit_impl.h"
 #include "extensions/filters/network/thrift_proxy/filters/ratelimit/ratelimit.h"
@@ -23,22 +24,23 @@ ThriftProxy::ThriftFilters::FilterFactoryCb
 RateLimitFilterConfig::createFilterFactoryFromProtoTyped(
     const envoy::extensions::filters::network::thrift_proxy::filters::ratelimit::v3::RateLimit&
         proto_config,
     const std::string&, Server::Configuration::FactoryContext& context) {
   ASSERT(!proto_config.domain().empty());
   ConfigSharedPtr config(new Config(proto_config, context.localInfo(), context.scope(),
                                     context.runtime(), context.clusterManager()));
   const std::chrono::milliseconds timeout =
       std::chrono::milliseconds(PROTOBUF_GET_MS_OR_DEFAULT(proto_config, timeout, 20));
 
   return [proto_config, &context, timeout,
           config](ThriftProxy::ThriftFilters::FilterChainFactoryCallbacks& callbacks) -> void {
     callbacks.addDecoderFilter(std::make_shared<Filter>(
         config, Filters::Common::RateLimit::rateLimitClient(
                     context, proto_config.rate_limit_service().grpc_service(), timeout,
-                    proto_config.rate_limit_service().transport_api_version())));
+                    Envoy::Config::Utility::getAndCheckTransportVersion(
+                        proto_config.rate_limit_service()))));
   };
 }
 
 /**
  * Static registration for the rate limit filter. @see RegisterFactory.
  */
diff --git a/source/extensions/stat_sinks/metrics_service/BUILD b/source/extensions/stat_sinks/metrics_service/BUILD
index df78d152ba..cf7a8ce39c 100644
--- a/source/extensions/stat_sinks/metrics_service/BUILD
+++ b/source/extensions/stat_sinks/metrics_service/BUILD
@@ -42,15 +42,16 @@ envoy_cc_library(
 envoy_cc_extension(
     name = "config",
     srcs = ["config.cc"],
     hdrs = ["config.h"],
     security_posture = "data_plane_agnostic",
     deps = [
         "//include/envoy/registry",
         "//source/common/common:assert_lib",
+        "//source/common/config:utility_lib",
         "//source/extensions/stat_sinks:well_known_names",
         "//source/extensions/stat_sinks/metrics_service:metrics_proto_descriptors_lib",
         "//source/extensions/stat_sinks/metrics_service:metrics_service_grpc_lib",
         "//source/server:configuration_lib",
         "@envoy_api//envoy/config/metrics/v3:pkg_cc_proto",
     ],
 )
diff --git a/source/extensions/stat_sinks/metrics_service/config.cc b/source/extensions/stat_sinks/metrics_service/config.cc
index 8b44af894b..a1e9be3782 100644
--- a/source/extensions/stat_sinks/metrics_service/config.cc
+++ b/source/extensions/stat_sinks/metrics_service/config.cc
@@ -1,13 +1,14 @@
 #include "extensions/stat_sinks/metrics_service/config.h"
 
 #include "envoy/config/metrics/v3/metrics_service.pb.h"
 #include "envoy/config/metrics/v3/metrics_service.pb.validate.h"
 #include "envoy/registry/registry.h"
 
 #include "common/common/assert.h"
+#include "common/config/utility.h"
 #include "common/grpc/async_client_impl.h"
 #include "common/network/resolver_impl.h"
 
 #include "extensions/stat_sinks/metrics_service/grpc_metrics_proto_descriptors.h"
 #include "extensions/stat_sinks/metrics_service/grpc_metrics_service_impl.h"
 #include "extensions/stat_sinks/well_known_names.h"
@@ -21,23 +22,23 @@ Stats::SinkPtr
 MetricsServiceSinkFactory::createStatsSink(const Protobuf::Message& config,
                                            Server::Configuration::ServerFactoryContext& server) {
   validateProtoDescriptors();
 
   const auto& sink_config =
       MessageUtil::downcastAndValidate<const envoy::config::metrics::v3::MetricsServiceConfig&>(
           config, server.messageValidationContext().staticValidationVisitor());
   const auto& grpc_service = sink_config.grpc_service();
-  const auto& transport_api_version = sink_config.transport_api_version();
+  const auto& transport_api_version = Config::Utility::getAndCheckTransportVersion(sink_config);
   ENVOY_LOG(debug, "Metrics Service gRPC service configuration: {}", grpc_service.DebugString());
 
   std::shared_ptr<GrpcMetricsStreamer<envoy::service::metrics::v3::StreamMetricsMessage,
                                       envoy::service::metrics::v3::StreamMetricsResponse>>
       grpc_metrics_streamer = std::make_shared<GrpcMetricsStreamerImpl>(
           server.clusterManager().grpcAsyncClientManager().factoryForGrpcService(
               grpc_service, server.scope(), false),
           server.localInfo(), transport_api_version);
 
   return std::make_unique<MetricsServiceSink<envoy::service::metrics::v3::StreamMetricsMessage,
                                              envoy::service::metrics::v3::StreamMetricsResponse>>(
       grpc_metrics_streamer,
       PROTOBUF_GET_WRAPPED_OR_DEFAULT(sink_config, report_counters_as_deltas, false));
 }
diff --git a/source/server/server.cc b/source/server/server.cc
index c3bfd89621..ef9e211c2e 100644
--- a/source/server/server.cc
+++ b/source/server/server.cc
@@ -582,28 +582,28 @@ void InstanceImpl::onClusterManagerPrimaryInitializationComplete() {
 void InstanceImpl::onRuntimeReady() {
   // Begin initializing secondary clusters after RTDS configuration has been applied.
   clusterManager().initializeSecondaryClusters(bootstrap_);
 
   if (bootstrap_.has_hds_config()) {
     const auto& hds_config = bootstrap_.hds_config();
     async_client_manager_ = std::make_unique<Grpc::AsyncClientManagerImpl>(
         *config_.clusterManager(), thread_local_, time_source_, *api_, grpc_context_.statNames());
     hds_delegate_ = std::make_unique<Upstream::HdsDelegate>(
         stats_store_,
         Config::Utility::factoryForGrpcApiConfigSource(*async_client_manager_, hds_config,
                                                        stats_store_, false)
             ->create(),
-        hds_config.transport_api_version(), *dispatcher_, Runtime::LoaderSingleton::get(),
-        stats_store_, *ssl_context_manager_, info_factory_, access_log_manager_,
-        *config_.clusterManager(), *local_info_, *admin_, *singleton_manager_, thread_local_,
-        messageValidationContext().dynamicValidationVisitor(), *api_);
+        Config::Utility::getAndCheckTransportVersion(hds_config), *dispatcher_,
+        Runtime::LoaderSingleton::get(), stats_store_, *ssl_context_manager_, info_factory_,
+        access_log_manager_, *config_.clusterManager(), *local_info_, *admin_, *singleton_manager_,
+        thread_local_, messageValidationContext().dynamicValidationVisitor(), *api_);
   }
 
   // If there is no global limit to the number of active connections, warn on startup.
   // TODO (tonya11en): Move this functionality into the overload manager.
   if (!runtime().snapshot().get(Network::TcpListenerImpl::GlobalMaxCxRuntimeKey)) {
     ENVOY_LOG(warn,
               "there is no configured limit to the number of allowed active connections. Set a "
               "limit via the runtime key {}",
               Network::TcpListenerImpl::GlobalMaxCxRuntimeKey);
   }
 }
diff --git a/test/common/config/BUILD b/test/common/config/BUILD
index 72e18e2372..80a2bfa5b6 100644
--- a/test/common/config/BUILD
+++ b/test/common/config/BUILD
@@ -288,22 +288,22 @@ envoy_cc_test(
 envoy_cc_test(
     name = "subscription_factory_impl_test",
     srcs = ["subscription_factory_impl_test.cc"],
     deps = [
         "//source/common/config:subscription_factory_lib",
         "//source/common/config:xds_resource_lib",
         "//test/mocks/config:config_mocks",
         "//test/mocks/event:event_mocks",
         "//test/mocks/filesystem:filesystem_mocks",
         "//test/mocks/local_info:local_info_mocks",
         "//test/mocks/protobuf:protobuf_mocks",
-        "//test/mocks/runtime:runtime_mocks",
         "//test/mocks/stats:stats_mocks",
         "//test/mocks/upstream:cluster_manager_mocks",
         "//test/test_common:environment_lib",
         "//test/test_common:logging_lib",
+        "//test/test_common:test_runtime_lib",
         "//test/test_common:utility_lib",
         "@envoy_api//envoy/config/cluster/v3:pkg_cc_proto",
         "@envoy_api//envoy/config/core/v3:pkg_cc_proto",
         "@envoy_api//envoy/config/endpoint/v3:pkg_cc_proto",
     ],
 )
diff --git a/test/common/config/subscription_factory_impl_test.cc b/test/common/config/subscription_factory_impl_test.cc
index 0a92ab6444..efa98bfafb 100644
--- a/test/common/config/subscription_factory_impl_test.cc
+++ b/test/common/config/subscription_factory_impl_test.cc
@@ -1,27 +1,27 @@
 #include <memory>
 
 #include "envoy/common/exception.h"
 #include "envoy/config/cluster/v3/cluster.pb.h"
 #include "envoy/config/core/v3/config_source.pb.h"
 #include "envoy/config/core/v3/config_source.pb.validate.h"
 #include "envoy/config/core/v3/grpc_service.pb.h"
 #include "envoy/config/endpoint/v3/endpoint.pb.h"
 #include "envoy/stats/scope.h"
 
 #include "common/config/subscription_factory_impl.h"
 #include "common/config/xds_resource.h"
 
 #include "test/mocks/config/mocks.h"
 #include "test/mocks/event/mocks.h"
 #include "test/mocks/filesystem/mocks.h"
 #include "test/mocks/local_info/mocks.h"
 #include "test/mocks/protobuf/mocks.h"
-#include "test/mocks/runtime/mocks.h"
 #include "test/mocks/stats/mocks.h"
 #include "test/mocks/upstream/cluster_manager.h"
 #include "test/test_common/environment.h"
 #include "test/test_common/logging.h"
+#include "test/test_common/test_runtime.h"
 #include "test/test_common/utility.h"
 
 #include "gmock/gmock.h"
 #include "gtest/gtest.h"
@@ -39,34 +39,33 @@ class SubscriptionFactoryTest : public testing::Test {
 public:
   SubscriptionFactoryTest()
       : http_request_(&cm_.thread_local_cluster_.async_client_),
         api_(Api::createApiForTest(stats_store_, random_)),
-        subscription_factory_(local_info_, dispatcher_, cm_, validation_visitor_, *api_, runtime_) {
-  }
+        subscription_factory_(local_info_, dispatcher_, cm_, validation_visitor_, *api_) {}
 
   SubscriptionPtr
   subscriptionFromConfigSource(const envoy::config::core::v3::ConfigSource& config) {
     return subscription_factory_.subscriptionFromConfigSource(
         config, Config::TypeUrl::get().ClusterLoadAssignment, stats_store_, callbacks_,
         resource_decoder_);
   }
 
   SubscriptionPtr collectionSubscriptionFromUrl(const std::string& xds_url) {
     const auto resource_locator = XdsResourceIdentifier::decodeUrl(xds_url);
     return subscription_factory_.collectionSubscriptionFromUrl(
         resource_locator, {}, Config::TypeUrl::get().ClusterLoadAssignment, stats_store_,
         callbacks_, resource_decoder_);
   }
 
   Upstream::MockClusterManager cm_;
   Event::MockDispatcher dispatcher_;
   Random::MockRandomGenerator random_;
   MockSubscriptionCallbacks callbacks_;
   MockOpaqueResourceDecoder resource_decoder_;
   Http::MockAsyncClientRequest http_request_;
   Stats::MockIsolatedStatsStore stats_store_;
   NiceMock<LocalInfo::MockLocalInfo> local_info_;
   NiceMock<ProtobufMessage::MockValidationVisitor> validation_visitor_;
   Api::ApiPtr api_;
   NiceMock<Runtime::MockLoader> runtime_;
   SubscriptionFactoryImpl subscription_factory_;
 };
@@ -332,49 +331,43 @@ TEST_F(SubscriptionFactoryTest, GrpcSubscription) {
 // Use of the V2 transport fails by default.
 TEST_F(SubscriptionFactoryTest, LogWarningOnDeprecatedV2Transport) {
   envoy::config::core::v3::ConfigSource config;
 
   config.mutable_api_config_source()->set_api_type(envoy::config::core::v3::ApiConfigSource::GRPC);
   config.mutable_api_config_source()->set_transport_api_version(
       envoy::config::core::v3::ApiVersion::V2);
   config.mutable_api_config_source()->add_grpc_services()->mutable_envoy_grpc()->set_cluster_name(
       "static_cluster");
-  NiceMock<Runtime::MockSnapshot> snapshot;
-  EXPECT_CALL(runtime_, snapshot()).WillRepeatedly(ReturnRef(snapshot));
-  EXPECT_CALL(snapshot, runtimeFeatureEnabled(_)).WillOnce(Return(false));
-  EXPECT_CALL(runtime_, countDeprecatedFeatureUse());
 
+  TestScopedRuntime scoped_runtime;
   Upstream::ClusterManager::ClusterSet primary_clusters;
   primary_clusters.insert("static_cluster");
   EXPECT_CALL(cm_, primaryClusters()).WillOnce(ReturnRef(primary_clusters));
 
   EXPECT_THROW_WITH_REGEX(subscription_factory_.subscriptionFromConfigSource(
                               config, Config::TypeUrl::get().ClusterLoadAssignment, stats_store_,
                               callbacks_, resource_decoder_),
                           EnvoyException,
                           "V2 .and AUTO. xDS transport protocol versions are deprecated in");
 }
 
 // Use of AUTO transport fails by default. This will encourage folks to upgrade to explicit V3.
 TEST_F(SubscriptionFactoryTest, LogWarningOnDeprecatedAutoTransport) {
   envoy::config::core::v3::ConfigSource config;
 
   config.mutable_api_config_source()->set_api_type(envoy::config::core::v3::ApiConfigSource::GRPC);
   config.mutable_api_config_source()->set_transport_api_version(
       envoy::config::core::v3::ApiVersion::AUTO);
   config.mutable_api_config_source()->add_grpc_services()->mutable_envoy_grpc()->set_cluster_name(
       "static_cluster");
-  NiceMock<Runtime::MockSnapshot> snapshot;
-  EXPECT_CALL(runtime_, snapshot()).WillRepeatedly(ReturnRef(snapshot));
-  EXPECT_CALL(snapshot, runtimeFeatureEnabled(_)).WillOnce(Return(false));
-  EXPECT_CALL(runtime_, countDeprecatedFeatureUse());
 
+  TestScopedRuntime scoped_runtime;
   Upstream::ClusterManager::ClusterSet primary_clusters;
   primary_clusters.insert("static_cluster");
   EXPECT_CALL(cm_, primaryClusters()).WillOnce(ReturnRef(primary_clusters));
 
   EXPECT_THROW_WITH_REGEX(subscription_factory_.subscriptionFromConfigSource(
                               config, Config::TypeUrl::get().ClusterLoadAssignment, stats_store_,
                               callbacks_, resource_decoder_),
                           EnvoyException,
                           "V2 .and AUTO. xDS transport protocol versions are deprecated in");
 }
diff --git a/test/config/utility.cc b/test/config/utility.cc
index 115201d530..680cd9c536 100644
--- a/test/config/utility.cc
+++ b/test/config/utility.cc
@@ -342,17 +342,23 @@ static_resources:
 
 // TODO(#6327) cleaner approach to testing with static config.
 std::string ConfigHelper::adsBootstrap(const std::string& api_type,
-                                       envoy::config::core::v3::ApiVersion api_version) {
+                                       envoy::config::core::v3::ApiVersion resource_api_version,
+                                       envoy::config::core::v3::ApiVersion transport_api_version) {
+  // We use this to allow tests to default to having a single API version but override and make
+  // the transport/resource API version distinction when needed.
+  if (transport_api_version == envoy::config::core::v3::ApiVersion::AUTO) {
+    transport_api_version = resource_api_version;
+  }
   return fmt::format(R"EOF(
 dynamic_resources:
   lds_config:
     resource_api_version: {1}
     ads: {{}}
   cds_config:
     resource_api_version: {1}
     ads: {{}}
   ads_config:
-    transport_api_version: {1}
+    transport_api_version: {2}
     api_type: {0}
 static_resources:
   clusters:
@@ -358,32 +364,34 @@ static_resources:
   clusters:
     name: dummy_cluster
     connect_timeout:
       seconds: 5
     type: STATIC
     load_assignment:
       cluster_name: dummy_cluster
       endpoints:
       - lb_endpoints:
         - endpoint:
             address:
               socket_address:
                 address: 127.0.0.1
                 port_value: 0
     lb_policy: ROUND_ROBIN
     typed_extension_protocol_options:
       envoy.extensions.upstreams.http.v3.HttpProtocolOptions:
         "@type": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions
         explicit_http_config:
           http2_protocol_options: {{}}
 admin:
-  access_log_path: {2}
+  access_log_path: {3}
   address:
     socket_address:
       address: 127.0.0.1
       port_value: 0
 )EOF",
-                     api_type, api_version == envoy::config::core::v3::ApiVersion::V2 ? "V2" : "V3",
+                     api_type,
+                     resource_api_version == envoy::config::core::v3::ApiVersion::V2 ? "V2" : "V3",
+                     transport_api_version == envoy::config::core::v3::ApiVersion::V2 ? "V2" : "V3",
                      Platform::null_device_path);
 }
 
 // TODO(samflattery): bundle this up with buildCluster
diff --git a/test/config/utility.h b/test/config/utility.h
index ade1ce1b2d..0649e1f6d8 100644
--- a/test/config/utility.h
+++ b/test/config/utility.h
@@ -32,255 +32,257 @@ class ConfigHelper {
 public:
   using HttpConnectionManager =
       envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager;
   struct ServerSslOptions {
     ServerSslOptions& setRsaCert(bool rsa_cert) {
       rsa_cert_ = rsa_cert;
       return *this;
     }
 
     ServerSslOptions& setRsaCertOcspStaple(bool rsa_cert_ocsp_staple) {
       rsa_cert_ocsp_staple_ = rsa_cert_ocsp_staple;
       return *this;
     }
 
     ServerSslOptions& setEcdsaCert(bool ecdsa_cert) {
       ecdsa_cert_ = ecdsa_cert;
       return *this;
     }
 
     ServerSslOptions& setEcdsaCertOcspStaple(bool ecdsa_cert_ocsp_staple) {
       ecdsa_cert_ocsp_staple_ = ecdsa_cert_ocsp_staple;
       return *this;
     }
 
     ServerSslOptions& setOcspStapleRequired(bool ocsp_staple_required) {
       ocsp_staple_required_ = ocsp_staple_required;
       return *this;
     }
 
     ServerSslOptions& setTlsV13(bool tlsv1_3) {
       tlsv1_3_ = tlsv1_3;
       return *this;
     }
 
     ServerSslOptions& setExpectClientEcdsaCert(bool expect_client_ecdsa_cert) {
       expect_client_ecdsa_cert_ = expect_client_ecdsa_cert;
       return *this;
     }
 
     bool rsa_cert_{true};
     bool rsa_cert_ocsp_staple_{true};
     bool ecdsa_cert_{false};
     bool ecdsa_cert_ocsp_staple_{false};
     bool ocsp_staple_required_{false};
     bool tlsv1_3_{false};
     bool expect_client_ecdsa_cert_{false};
   };
 
   // Set up basic config, using the specified IpVersion for all connections: listeners, upstream,
   // and admin connections.
   //
   // By default, this runs with an L7 proxy config, but config can be set to TCP_PROXY_CONFIG
   // to test L4 proxying.
   ConfigHelper(const Network::Address::IpVersion version, Api::Api& api,
                const std::string& config = httpProxyConfig());
 
   static void
   initializeTls(const ServerSslOptions& options,
                 envoy::extensions::transport_sockets::tls::v3::CommonTlsContext& common_context);
 
   using ConfigModifierFunction = std::function<void(envoy::config::bootstrap::v3::Bootstrap&)>;
   using HttpModifierFunction = std::function<void(HttpConnectionManager&)>;
 
   // A basic configuration (admin port, cluster_0, one listener) with no network filters.
   static std::string baseConfig();
 
   // A basic configuration (admin port, cluster_0, one udp listener) with no network filters.
   static std::string baseUdpListenerConfig();
 
   // A string for a tls inspector listener filter which can be used with addListenerFilter()
   static std::string tlsInspectorFilter();
 
   // A basic configuration for L4 proxying.
   static std::string tcpProxyConfig();
   // A basic configuration for L7 proxying.
   static std::string httpProxyConfig();
   // A basic configuration for L7 proxying with QUIC transport.
   static std::string quicHttpProxyConfig();
   // A string for a basic buffer filter, which can be used with addFilter()
   static std::string defaultBufferFilter();
   // A string for a small buffer filter, which can be used with addFilter()
   static std::string smallBufferFilter();
   // A string for a health check filter which can be used with addFilter()
   static std::string defaultHealthCheckFilter();
   // A string for a squash filter which can be used with addFilter()
   static std::string defaultSquashFilter();
   // A string for startTls transport socket config.
   static std::string startTlsConfig();
 
   // Configuration for L7 proxying, with clusters cluster_1 and cluster_2 meant to be added via CDS.
   // api_type should be REST, GRPC, or DELTA_GRPC.
   static std::string discoveredClustersBootstrap(const std::string& api_type);
   static std::string adsBootstrap(const std::string& api_type,
-                                  envoy::config::core::v3::ApiVersion api_version);
+                                  envoy::config::core::v3::ApiVersion resource_api_version,
+                                  envoy::config::core::v3::ApiVersion transport_api_version =
+                                      envoy::config::core::v3::ApiVersion::AUTO);
   // Builds a standard Cluster config fragment, with a single endpoint (at address:port).
   static envoy::config::cluster::v3::Cluster buildStaticCluster(const std::string& name, int port,
                                                                 const std::string& address);
 
   // ADS configurations
   static envoy::config::cluster::v3::Cluster buildCluster(
       const std::string& name, const std::string& lb_policy = "ROUND_ROBIN",
       envoy::config::core::v3::ApiVersion api_version = envoy::config::core::v3::ApiVersion::V3);
 
   static envoy::config::cluster::v3::Cluster buildTlsCluster(
       const std::string& name, const std::string& lb_policy = "ROUND_ROBIN",
       envoy::config::core::v3::ApiVersion api_version = envoy::config::core::v3::ApiVersion::V3);
 
   static envoy::config::endpoint::v3::ClusterLoadAssignment buildClusterLoadAssignment(
       const std::string& name, const std::string& ip_version, uint32_t port,
       envoy::config::core::v3::ApiVersion api_version = envoy::config::core::v3::ApiVersion::V3);
 
   static envoy::config::listener::v3::Listener buildBaseListener(
       const std::string& name, const std::string& address, const std::string& filter_chains = "",
       envoy::config::core::v3::ApiVersion api_version = envoy::config::core::v3::ApiVersion::V3);
 
   static envoy::config::listener::v3::Listener buildListener(
       const std::string& name, const std::string& route_config, const std::string& address,
       const std::string& stat_prefix,
       envoy::config::core::v3::ApiVersion api_version = envoy::config::core::v3::ApiVersion::V3);
 
   static envoy::config::route::v3::RouteConfiguration buildRouteConfig(
       const std::string& name, const std::string& cluster,
       envoy::config::core::v3::ApiVersion api_version = envoy::config::core::v3::ApiVersion::V3);
 
   // Builds a standard Endpoint suitable for population by finalize().
   static envoy::config::endpoint::v3::Endpoint buildEndpoint(const std::string& address);
 
   // Run the final config modifiers, and then set the upstream ports based on upstream connections.
   // This is the last operation run on |bootstrap_| before it is handed to Envoy.
   // Ports are assigned by looping through clusters, hosts, and addresses in the
   // order they are stored in |bootstrap_|
   void finalize(const std::vector<uint32_t>& ports);
 
   // Set source_address in the bootstrap bind config.
   void setSourceAddress(const std::string& address_string);
 
   // Overwrite the first host and route for the primary listener.
   void setDefaultHostAndRoute(const std::string& host, const std::string& route);
 
   // Sets byte limits on upstream and downstream connections.
   void setBufferLimits(uint32_t upstream_buffer_limit, uint32_t downstream_buffer_limit);
 
   // Set the idle timeout on downstream connections through the HttpConnectionManager.
   void setDownstreamHttpIdleTimeout(std::chrono::milliseconds idle_timeout);
 
   // Set the max connection duration for downstream connections through the HttpConnectionManager.
   void setDownstreamMaxConnectionDuration(std::chrono::milliseconds max_connection_duration);
 
   // Set the max stream duration for downstream connections through the HttpConnectionManager.
   void setDownstreamMaxStreamDuration(std::chrono::milliseconds max_stream_duration);
 
   // Set the connect timeout on upstream connections.
   void setConnectTimeout(std::chrono::milliseconds timeout);
 
   envoy::config::route::v3::VirtualHost createVirtualHost(const char* host, const char* route = "/",
                                                           const char* cluster = "cluster_0");
 
   void addVirtualHost(const envoy::config::route::v3::VirtualHost& vhost);
 
   // Add an HTTP filter prior to existing filters.
   void addFilter(const std::string& filter_yaml);
 
   // Add a network filter prior to existing filters.
   void addNetworkFilter(const std::string& filter_yaml);
 
   // Add a listener filter prior to existing filters.
   void addListenerFilter(const std::string& filter_yaml);
 
   // Sets the client codec to the specified type.
   void setClientCodec(envoy::extensions::filters::network::http_connection_manager::v3::
                           HttpConnectionManager::CodecType type);
 
   // Add the default SSL configuration.
   void addSslConfig(const ServerSslOptions& options);
   void addSslConfig() { addSslConfig({}); }
 
   // Set the HTTP access log for the first HCM (if present) to a given file. The default is
   // the platform's null device.
   bool setAccessLog(const std::string& filename, absl::string_view format = "");
 
   // Set the listener access log for the first listener to a given file.
   bool setListenerAccessLog(const std::string& filename, absl::string_view format = "");
 
   // Renames the first listener to the name specified.
   void renameListener(const std::string& name);
 
   // Allows callers to do their own modification to |bootstrap_| which will be
   // applied just before ports are modified in finalize().
   void addConfigModifier(ConfigModifierFunction function);
 
   // Allows callers to easily modify the HttpConnectionManager configuration.
   // Modifiers will be applied just before ports are modified in finalize
   void addConfigModifier(HttpModifierFunction function);
 
   // Allows callers to easily modify the filter named 'name' from the first filter chain from the
   // first listener. Modifiers will be applied just before ports are modified in finalize
   template <class FilterType>
   void addFilterConfigModifier(const std::string& name,
                                std::function<void(Protobuf::Message& filter)> function) {
     addConfigModifier([name, function, this](envoy::config::bootstrap::v3::Bootstrap&) -> void {
       FilterType filter_config;
       loadFilter<FilterType>(name, filter_config);
       function(filter_config);
       storeFilter<FilterType>(name, filter_config);
     });
   }
 
   // Apply any outstanding config modifiers, stick all the listeners in a discovery response message
   // and write it to the lds file.
   void setLds(absl::string_view version_info);
 
   // Set limits on pending downstream outbound frames.
   void setDownstreamOutboundFramesLimits(uint32_t max_all_frames, uint32_t max_control_frames);
 
   // Set limits on pending upstream outbound frames.
   void setUpstreamOutboundFramesLimits(uint32_t max_all_frames, uint32_t max_control_frames);
 
   // Return the bootstrap configuration for hand-off to Envoy.
   const envoy::config::bootstrap::v3::Bootstrap& bootstrap() { return bootstrap_; }
 
   // Allow a finalized configuration to be edited for generating xDS responses
   void applyConfigModifiers();
 
   // Configure Envoy to do TLS to upstream.
   void configureUpstreamTls();
 
   // Skip validation that ensures that all upstream ports are referenced by the
   // configuration generated in ConfigHelper::finalize.
   void skipPortUsageValidation() { skip_port_usage_validation_ = true; }
 
   // Add this key value pair to the static runtime.
   void addRuntimeOverride(const std::string& key, const std::string& value);
 
   // Enable deprecated v2 API resources via the runtime.
   void enableDeprecatedV2Api();
 
   // Add filter_metadata to a cluster with the given name
   void addClusterFilterMetadata(absl::string_view metadata_yaml,
                                 absl::string_view cluster_name = "cluster_0");
 
   // Given an HCM with the default config, set the matcher to be a connect matcher and enable
   // CONNECT requests.
   static void setConnectConfig(HttpConnectionManager& hcm, bool terminate_connect);
 
   void setLocalReply(
       const envoy::extensions::filters::network::http_connection_manager::v3::LocalReplyConfig&
           config);
 
   // Set new codecs to use for upstream and downstream codecs.
   void setNewCodecs();
 
   using HttpProtocolOptions = envoy::extensions::upstreams::http::v3::HttpProtocolOptions;
   static void setProtocolOptions(envoy::config::cluster::v3::Cluster& cluster,
                                  HttpProtocolOptions& protocol_options);
   static void setHttp2(envoy::config::cluster::v3::Cluster& cluster);
diff --git a/test/extensions/access_loggers/grpc/grpc_access_log_impl_test.cc b/test/extensions/access_loggers/grpc/grpc_access_log_impl_test.cc
index ed4a980036..e1637db9bf 100644
--- a/test/extensions/access_loggers/grpc/grpc_access_log_impl_test.cc
+++ b/test/extensions/access_loggers/grpc/grpc_access_log_impl_test.cc
@@ -378,41 +378,42 @@ public:
 TEST_F(GrpcAccessLoggerCacheImplTest, Deduplication) {
   Stats::IsolatedStoreImpl scope;
   InSequence s;
 
   envoy::extensions::access_loggers::grpc::v3::CommonGrpcAccessLogConfig config;
   config.set_log_name("log-1");
   config.mutable_grpc_service()->mutable_envoy_grpc()->set_cluster_name("cluster-1");
+  config.set_transport_api_version(envoy::config::core::v3::ApiVersion::V3);
 
   expectClientCreation();
   GrpcAccessLoggerSharedPtr logger1 =
       logger_cache_.getOrCreateLogger(config, Common::GrpcAccessLoggerType::HTTP, scope);
   EXPECT_EQ(logger1,
             logger_cache_.getOrCreateLogger(config, Common::GrpcAccessLoggerType::HTTP, scope));
 
   // Do not deduplicate different types of logger
   expectClientCreation();
   EXPECT_NE(logger1,
             logger_cache_.getOrCreateLogger(config, Common::GrpcAccessLoggerType::TCP, scope));
 
   // Changing log name leads to another logger.
   config.set_log_name("log-2");
   expectClientCreation();
   EXPECT_NE(logger1,
             logger_cache_.getOrCreateLogger(config, Common::GrpcAccessLoggerType::HTTP, scope));
 
   config.set_log_name("log-1");
   EXPECT_EQ(logger1,
             logger_cache_.getOrCreateLogger(config, Common::GrpcAccessLoggerType::HTTP, scope));
 
   // Changing cluster name leads to another logger.
   config.mutable_grpc_service()->mutable_envoy_grpc()->set_cluster_name("cluster-2");
   expectClientCreation();
   EXPECT_NE(logger1,
             logger_cache_.getOrCreateLogger(config, Common::GrpcAccessLoggerType::HTTP, scope));
 }
 
 } // namespace
 } // namespace GrpcCommon
 } // namespace AccessLoggers
 } // namespace Extensions
 } // namespace Envoy
diff --git a/test/extensions/access_loggers/grpc/http_config_test.cc b/test/extensions/access_loggers/grpc/http_config_test.cc
index 37ba522024..1b91b69159 100644
--- a/test/extensions/access_loggers/grpc/http_config_test.cc
+++ b/test/extensions/access_loggers/grpc/http_config_test.cc
@@ -25,29 +25,30 @@ class HttpGrpcAccessLogConfigTest : public testing::Test {
 public:
   void SetUp() override {
     factory_ =
         Registry::FactoryRegistry<Server::Configuration::AccessLogInstanceFactory>::getFactory(
             AccessLogNames::get().HttpGrpc);
     ASSERT_NE(nullptr, factory_);
 
     message_ = factory_->createEmptyConfigProto();
     ASSERT_NE(nullptr, message_);
 
     EXPECT_CALL(context_.cluster_manager_.async_client_manager_, factoryForGrpcService(_, _, _))
         .WillOnce(Invoke([](const envoy::config::core::v3::GrpcService&, Stats::Scope&, bool) {
           return std::make_unique<NiceMock<Grpc::MockAsyncClientFactory>>();
         }));
 
     auto* common_config = http_grpc_access_log_.mutable_common_config();
     common_config->set_log_name("foo");
     common_config->mutable_grpc_service()->mutable_envoy_grpc()->set_cluster_name("bar");
+    common_config->set_transport_api_version(envoy::config::core::v3::ApiVersion::V3);
     TestUtility::jsonConvert(http_grpc_access_log_, *message_);
   }
 
   AccessLog::FilterPtr filter_;
   NiceMock<Server::Configuration::MockFactoryContext> context_;
   envoy::extensions::access_loggers::grpc::v3::HttpGrpcAccessLogConfig http_grpc_access_log_;
   ProtobufTypes::MessagePtr message_;
   Server::Configuration::AccessLogInstanceFactory* factory_{};
 };
 
 // Normal OK configuration.
diff --git a/test/extensions/access_loggers/grpc/http_grpc_access_log_integration_test.cc b/test/extensions/access_loggers/grpc/http_grpc_access_log_integration_test.cc
index 9b702dc355..590a3d280e 100644
--- a/test/extensions/access_loggers/grpc/http_grpc_access_log_integration_test.cc
+++ b/test/extensions/access_loggers/grpc/http_grpc_access_log_integration_test.cc
@@ -23,101 +23,104 @@ class AccessLogIntegrationTest : public Grpc::VersionedGrpcClientIntegrationPara
                                  public HttpIntegrationTest {
 public:
   AccessLogIntegrationTest() : HttpIntegrationTest(Http::CodecClient::Type::HTTP1, ipVersion()) {}
 
   void createUpstreams() override {
     HttpIntegrationTest::createUpstreams();
     addFakeUpstream(FakeHttpConnection::Type::HTTP2);
   }
 
   void initialize() override {
+    if (apiVersion() != envoy::config::core::v3::ApiVersion::V3) {
+      config_helper_.enableDeprecatedV2Api();
+    }
     config_helper_.addConfigModifier([](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {
       auto* accesslog_cluster = bootstrap.mutable_static_resources()->add_clusters();
       accesslog_cluster->MergeFrom(bootstrap.static_resources().clusters()[0]);
       accesslog_cluster->set_name("accesslog");
       ConfigHelper::setHttp2(*accesslog_cluster);
     });
 
     config_helper_.addConfigModifier(
         [this](
             envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&
                 hcm) {
           auto* access_log = hcm.add_access_log();
           access_log->set_name("grpc_accesslog");
 
           envoy::extensions::access_loggers::grpc::v3::HttpGrpcAccessLogConfig config;
           auto* common_config = config.mutable_common_config();
           common_config->set_log_name("foo");
           common_config->set_transport_api_version(apiVersion());
           setGrpcService(*common_config->mutable_grpc_service(), "accesslog",
                          fake_upstreams_.back()->localAddress());
           access_log->mutable_typed_config()->PackFrom(config);
         });
 
     HttpIntegrationTest::initialize();
   }
 
   static ProtobufTypes::MessagePtr scrubHiddenEnvoyDeprecated(const Protobuf::Message& message) {
     ProtobufTypes::MessagePtr mutable_clone;
     mutable_clone.reset(message.New());
     mutable_clone->MergeFrom(message);
     Config::VersionUtil::scrubHiddenEnvoyDeprecated(*mutable_clone);
     return mutable_clone;
   }
 
   ABSL_MUST_USE_RESULT
   AssertionResult waitForAccessLogConnection() {
     return fake_upstreams_[1]->waitForHttpConnection(*dispatcher_, fake_access_log_connection_);
   }
 
   ABSL_MUST_USE_RESULT
   AssertionResult waitForAccessLogStream() {
     return fake_access_log_connection_->waitForNewStream(*dispatcher_, access_log_request_);
   }
 
   ABSL_MUST_USE_RESULT
   AssertionResult waitForAccessLogRequest(const std::string& expected_request_msg_yaml) {
     envoy::service::accesslog::v3::StreamAccessLogsMessage request_msg;
     VERIFY_ASSERTION(access_log_request_->waitForGrpcMessage(*dispatcher_, request_msg));
     EXPECT_EQ("POST", access_log_request_->headers().getMethodValue());
     EXPECT_EQ(TestUtility::getVersionedMethodPath("envoy.service.accesslog.{}.AccessLogService",
                                                   "StreamAccessLogs", apiVersion()),
               access_log_request_->headers().getPathValue());
     EXPECT_EQ("application/grpc", access_log_request_->headers().getContentTypeValue());
 
     envoy::service::accesslog::v3::StreamAccessLogsMessage expected_request_msg;
     TestUtility::loadFromYaml(expected_request_msg_yaml, expected_request_msg);
 
     // Clear fields which are not deterministic.
     auto* log_entry = request_msg.mutable_http_logs()->mutable_log_entry(0);
     log_entry->mutable_common_properties()->clear_downstream_remote_address();
     log_entry->mutable_common_properties()->clear_downstream_direct_remote_address();
     log_entry->mutable_common_properties()->clear_downstream_local_address();
     log_entry->mutable_common_properties()->clear_start_time();
     log_entry->mutable_common_properties()->clear_time_to_last_rx_byte();
     log_entry->mutable_common_properties()->clear_time_to_first_downstream_tx_byte();
     log_entry->mutable_common_properties()->clear_time_to_last_downstream_tx_byte();
     log_entry->mutable_request()->clear_request_id();
     if (request_msg.has_identifier()) {
       auto* node = request_msg.mutable_identifier()->mutable_node();
       node->clear_extensions();
       node->clear_user_agent_build_version();
     }
     Config::VersionUtil::scrubHiddenEnvoyDeprecated(request_msg);
     Config::VersionUtil::scrubHiddenEnvoyDeprecated(expected_request_msg);
     EXPECT_TRUE(TestUtility::protoEqual(request_msg, expected_request_msg,
                                         /*ignore_repeated_field_ordering=*/false));
     return AssertionSuccess();
   }
 
   void cleanup() {
     if (fake_access_log_connection_ != nullptr) {
       AssertionResult result = fake_access_log_connection_->close();
       RELEASE_ASSERT(result, result.message());
       result = fake_access_log_connection_->waitForDisconnect();
       RELEASE_ASSERT(result, result.message());
     }
   }
 
   FakeHttpConnectionPtr fake_access_log_connection_;
   FakeStreamPtr access_log_request_;
 };
diff --git a/test/extensions/access_loggers/grpc/tcp_grpc_access_log_integration_test.cc b/test/extensions/access_loggers/grpc/tcp_grpc_access_log_integration_test.cc
index 22a3d800a8..e8516e0f6d 100644
--- a/test/extensions/access_loggers/grpc/tcp_grpc_access_log_integration_test.cc
+++ b/test/extensions/access_loggers/grpc/tcp_grpc_access_log_integration_test.cc
@@ -28,96 +28,99 @@ class TcpGrpcAccessLogIntegrationTest : public Grpc::VersionedGrpcClientIntegrat
                                         public BaseIntegrationTest {
 public:
   TcpGrpcAccessLogIntegrationTest()
       : BaseIntegrationTest(ipVersion(), ConfigHelper::tcpProxyConfig()) {
     enableHalfClose(true);
   }
 
   void createUpstreams() override {
     BaseIntegrationTest::createUpstreams();
     addFakeUpstream(FakeHttpConnection::Type::HTTP2);
   }
 
   void initialize() override {
+    if (apiVersion() != envoy::config::core::v3::ApiVersion::V3) {
+      config_helper_.enableDeprecatedV2Api();
+    }
     config_helper_.renameListener("tcp_proxy");
     config_helper_.addConfigModifier([](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {
       auto* accesslog_cluster = bootstrap.mutable_static_resources()->add_clusters();
       accesslog_cluster->MergeFrom(bootstrap.static_resources().clusters()[0]);
       accesslog_cluster->set_name("accesslog");
       ConfigHelper::setHttp2(*accesslog_cluster);
     });
 
     config_helper_.addConfigModifier([this](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {
       auto* listener = bootstrap.mutable_static_resources()->mutable_listeners(0);
       auto* access_log = listener->add_access_log();
       access_log->set_name("grpc_accesslog");
       envoy::extensions::access_loggers::grpc::v3::TcpGrpcAccessLogConfig access_log_config;
       auto* common_config = access_log_config.mutable_common_config();
       common_config->set_log_name("foo");
       common_config->set_transport_api_version(apiVersion());
       setGrpcService(*common_config->mutable_grpc_service(), "accesslog",
                      fake_upstreams_.back()->localAddress());
       access_log->mutable_typed_config()->PackFrom(access_log_config);
     });
     BaseIntegrationTest::initialize();
   }
 
   ABSL_MUST_USE_RESULT
   AssertionResult waitForAccessLogConnection() {
     return fake_upstreams_[1]->waitForHttpConnection(*dispatcher_, fake_access_log_connection_);
   }
 
   ABSL_MUST_USE_RESULT
   AssertionResult waitForAccessLogStream() {
     return fake_access_log_connection_->waitForNewStream(*dispatcher_, access_log_request_);
   }
 
   ABSL_MUST_USE_RESULT
   AssertionResult waitForAccessLogRequest(const std::string& expected_request_msg_yaml) {
     envoy::service::accesslog::v3::StreamAccessLogsMessage request_msg;
     VERIFY_ASSERTION(access_log_request_->waitForGrpcMessage(*dispatcher_, request_msg));
     EXPECT_EQ("POST", access_log_request_->headers().getMethodValue());
     EXPECT_EQ(TestUtility::getVersionedMethodPath("envoy.service.accesslog.{}.AccessLogService",
                                                   "StreamAccessLogs", apiVersion()),
               access_log_request_->headers().getPathValue());
     EXPECT_EQ("application/grpc", access_log_request_->headers().getContentTypeValue());
 
     envoy::service::accesslog::v3::StreamAccessLogsMessage expected_request_msg;
     TestUtility::loadFromYaml(expected_request_msg_yaml, expected_request_msg);
 
     // Clear fields which are not deterministic.
     auto* log_entry = request_msg.mutable_tcp_logs()->mutable_log_entry(0);
     clearPort(*log_entry->mutable_common_properties()->mutable_downstream_remote_address());
     clearPort(*log_entry->mutable_common_properties()->mutable_downstream_direct_remote_address());
     clearPort(*log_entry->mutable_common_properties()->mutable_downstream_local_address());
     clearPort(*log_entry->mutable_common_properties()->mutable_upstream_remote_address());
     clearPort(*log_entry->mutable_common_properties()->mutable_upstream_local_address());
     log_entry->mutable_common_properties()->clear_start_time();
     log_entry->mutable_common_properties()->clear_time_to_last_rx_byte();
     log_entry->mutable_common_properties()->clear_time_to_first_downstream_tx_byte();
     log_entry->mutable_common_properties()->clear_time_to_last_downstream_tx_byte();
     if (request_msg.has_identifier()) {
       auto* node = request_msg.mutable_identifier()->mutable_node();
       node->clear_extensions();
       node->clear_user_agent_build_version();
     }
     Config::VersionUtil::scrubHiddenEnvoyDeprecated(request_msg);
     Config::VersionUtil::scrubHiddenEnvoyDeprecated(expected_request_msg);
     EXPECT_TRUE(TestUtility::protoEqual(request_msg, expected_request_msg,
                                         /*ignore_repeated_field_ordering=*/false));
 
     return AssertionSuccess();
   }
 
   void cleanup() {
     if (fake_access_log_connection_ != nullptr) {
       AssertionResult result = fake_access_log_connection_->close();
       RELEASE_ASSERT(result, result.message());
       result = fake_access_log_connection_->waitForDisconnect();
       RELEASE_ASSERT(result, result.message());
       fake_access_log_connection_ = nullptr;
     }
   }
 
   FakeHttpConnectionPtr fake_access_log_connection_;
   FakeStreamPtr access_log_request_;
 };
diff --git a/test/extensions/filters/http/ext_authz/config_test.cc b/test/extensions/filters/http/ext_authz/config_test.cc
index 86c2679390..0d48e3b481 100644
--- a/test/extensions/filters/http/ext_authz/config_test.cc
+++ b/test/extensions/filters/http/ext_authz/config_test.cc
@@ -22,40 +22,44 @@ namespace ExtAuthz {
 namespace {
 
 void expectCorrectProtoGrpc(envoy::config::core::v3::ApiVersion api_version) {
+  std::unique_ptr<TestDeprecatedV2Api> _deprecated_v2_api;
+  if (api_version != envoy::config::core::v3::ApiVersion::V3) {
+    _deprecated_v2_api = std::make_unique<TestDeprecatedV2Api>();
+  }
   std::string yaml = R"EOF(
   transport_api_version: V3
   grpc_service:
     google_grpc:
       target_uri: ext_authz_server
       stat_prefix: google
   failure_mode_allow: false
   transport_api_version: {}
   )EOF";
 
   ExtAuthzFilterConfig factory;
   ProtobufTypes::MessagePtr proto_config = factory.createEmptyConfigProto();
   TestUtility::loadFromYaml(
       fmt::format(yaml, TestUtility::getVersionStringFromApiVersion(api_version)), *proto_config);
 
   testing::StrictMock<Server::Configuration::MockFactoryContext> context;
   testing::StrictMock<Server::Configuration::MockServerFactoryContext> server_context;
   EXPECT_CALL(context, getServerFactoryContext())
       .Times(1)
       .WillOnce(testing::ReturnRef(server_context));
   EXPECT_CALL(server_context, singletonManager());
   EXPECT_CALL(context, threadLocal());
   EXPECT_CALL(context, messageValidationVisitor());
   EXPECT_CALL(context, clusterManager());
   EXPECT_CALL(context, runtime());
   EXPECT_CALL(context, scope()).Times(2);
   EXPECT_CALL(context.cluster_manager_.async_client_manager_, factoryForGrpcService(_, _, _))
       .WillOnce(Invoke([](const envoy::config::core::v3::GrpcService&, Stats::Scope&, bool) {
         return std::make_unique<NiceMock<Grpc::MockAsyncClientFactory>>();
       }));
   Http::FilterFactoryCb cb = factory.createFilterFactoryFromProto(*proto_config, "stats", context);
   Http::MockFilterChainFactoryCallbacks filter_callback;
   EXPECT_CALL(filter_callback, addStreamDecoderFilter(_));
   cb(filter_callback);
 }
 
 } // namespace
diff --git a/test/extensions/filters/http/ext_authz/ext_authz_integration_test.cc b/test/extensions/filters/http/ext_authz/ext_authz_integration_test.cc
index 953c431d73..c3ec137d83 100644
--- a/test/extensions/filters/http/ext_authz/ext_authz_integration_test.cc
+++ b/test/extensions/filters/http/ext_authz/ext_authz_integration_test.cc
@@ -27,282 +27,285 @@ class ExtAuthzGrpcIntegrationTest : public Grpc::VersionedGrpcClientIntegrationP
                                     public HttpIntegrationTest {
 public:
   ExtAuthzGrpcIntegrationTest()
       : HttpIntegrationTest(Http::CodecClient::Type::HTTP1, ipVersion()) {}
 
   void createUpstreams() override {
     HttpIntegrationTest::createUpstreams();
     addFakeUpstream(FakeHttpConnection::Type::HTTP2);
   }
 
   void initializeConfig(bool disable_with_metadata = false) {
+    if (apiVersion() != envoy::config::core::v3::ApiVersion::V3) {
+      config_helper_.enableDeprecatedV2Api();
+    }
     config_helper_.addConfigModifier([this, disable_with_metadata](
                                          envoy::config::bootstrap::v3::Bootstrap& bootstrap) {
       auto* ext_authz_cluster = bootstrap.mutable_static_resources()->add_clusters();
       ext_authz_cluster->MergeFrom(bootstrap.static_resources().clusters()[0]);
       ext_authz_cluster->set_name("ext_authz");
       ConfigHelper::setHttp2(*ext_authz_cluster);
 
       TestUtility::loadFromYaml(base_filter_config_, proto_config_);
       setGrpcService(*proto_config_.mutable_grpc_service(), "ext_authz",
                      fake_upstreams_.back()->localAddress());
 
       proto_config_.mutable_filter_enabled()->set_runtime_key("envoy.ext_authz.enable");
       proto_config_.mutable_filter_enabled()->mutable_default_value()->set_numerator(100);
       if (disable_with_metadata) {
         // Disable the ext_authz filter with metadata matcher that never matches.
         auto* metadata = proto_config_.mutable_filter_enabled_metadata();
         metadata->set_filter("xyz.abc");
         metadata->add_path()->set_key("k1");
         metadata->mutable_value()->mutable_string_match()->set_exact("never_matched");
       }
       proto_config_.mutable_deny_at_disable()->set_runtime_key("envoy.ext_authz.deny_at_disable");
       proto_config_.mutable_deny_at_disable()->mutable_default_value()->set_value(false);
       proto_config_.set_transport_api_version(apiVersion());
 
       envoy::config::listener::v3::Filter ext_authz_filter;
       ext_authz_filter.set_name(Extensions::HttpFilters::HttpFilterNames::get().ExtAuthorization);
       ext_authz_filter.mutable_typed_config()->PackFrom(proto_config_);
       config_helper_.addFilter(MessageUtil::getJsonStringFromMessage(ext_authz_filter));
     });
   }
 
   void setDenyAtDisableRuntimeConfig(bool deny_at_disable, bool disable_with_metadata) {
     if (!disable_with_metadata) {
       config_helper_.addRuntimeOverride("envoy.ext_authz.enable", "numerator: 0");
     }
     if (deny_at_disable) {
       config_helper_.addRuntimeOverride("envoy.ext_authz.deny_at_disable", "true");
     } else {
       config_helper_.addRuntimeOverride("envoy.ext_authz.deny_at_disable", "false");
     }
   }
 
   void initiateClientConnection(uint64_t request_body_length,
                                 const Headers& headers_to_add = Headers{},
                                 const Headers& headers_to_append = Headers{},
                                 const Headers& headers_to_remove = Headers{}) {
     auto conn = makeClientConnection(lookupPort("http"));
     codec_client_ = makeHttpConnection(std::move(conn));
     Http::TestRequestHeaderMapImpl headers{
         {":method", "POST"}, {":path", "/test"}, {":scheme", "http"}, {":authority", "host"}};
 
     // Initialize headers to append. If the authorization server returns any matching keys with one
     // of value in headers_to_add, the header entry from authorization server replaces the one in
     // headers_to_add.
     for (const auto& header_to_add : headers_to_add) {
       headers.addCopy(header_to_add.first, header_to_add.second);
     }
 
     // Initialize headers to append. If the authorization server returns any matching keys with one
     // of value in headers_to_append, it will be appended.
     for (const auto& headers_to_append : headers_to_append) {
       headers.addCopy(headers_to_append.first, headers_to_append.second);
     }
 
     // Initialize headers to be removed. If the authorization server returns any of
     // these as a header to remove, it will be removed.
     for (const auto& header_to_remove : headers_to_remove) {
       headers.addCopy(header_to_remove.first, header_to_remove.second);
     }
 
     TestUtility::feedBufferWithRandomCharacters(request_body_, request_body_length);
     response_ = codec_client_->makeRequestWithBody(headers, request_body_.toString());
   }
 
   void waitForExtAuthzRequest(const std::string& expected_check_request_yaml) {
     AssertionResult result =
         fake_upstreams_.back()->waitForHttpConnection(*dispatcher_, fake_ext_authz_connection_);
     RELEASE_ASSERT(result, result.message());
     result = fake_ext_authz_connection_->waitForNewStream(*dispatcher_, ext_authz_request_);
     RELEASE_ASSERT(result, result.message());
 
     // Check for the validity of the received CheckRequest.
     envoy::service::auth::v3::CheckRequest check_request;
     result = ext_authz_request_->waitForGrpcMessage(*dispatcher_, check_request);
     RELEASE_ASSERT(result, result.message());
 
     EXPECT_EQ("POST", ext_authz_request_->headers().getMethodValue());
     EXPECT_EQ(TestUtility::getVersionedMethodPath("envoy.service.auth.{}.Authorization", "Check",
                                                   apiVersion()),
               ext_authz_request_->headers().getPathValue());
     EXPECT_EQ("application/grpc", ext_authz_request_->headers().getContentTypeValue());
 
     envoy::service::auth::v3::CheckRequest expected_check_request;
     TestUtility::loadFromYaml(expected_check_request_yaml, expected_check_request);
 
     auto* attributes = check_request.mutable_attributes();
     auto* http_request = attributes->mutable_request()->mutable_http();
 
     EXPECT_TRUE(attributes->request().has_time());
 
     // Clear fields which are not relevant.
     attributes->clear_source();
     attributes->clear_destination();
     attributes->clear_metadata_context();
     attributes->mutable_request()->clear_time();
     http_request->clear_id();
     http_request->clear_headers();
     http_request->clear_scheme();
 
     EXPECT_EQ(check_request.DebugString(), expected_check_request.DebugString());
 
     result = ext_authz_request_->waitForEndStream(*dispatcher_);
     RELEASE_ASSERT(result, result.message());
   }
 
   void waitForSuccessfulUpstreamResponse(
       const std::string& expected_response_code, const Headers& headers_to_add = Headers{},
       const Headers& headers_to_append = Headers{}, const Headers& headers_to_remove = Headers{},
       const Http::TestRequestHeaderMapImpl& new_headers_from_upstream =
           Http::TestRequestHeaderMapImpl{},
       const Http::TestRequestHeaderMapImpl& headers_to_append_multiple =
           Http::TestRequestHeaderMapImpl{}) {
     AssertionResult result =
         fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_);
     RELEASE_ASSERT(result, result.message());
     result = fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_);
     RELEASE_ASSERT(result, result.message());
     result = upstream_request_->waitForEndStream(*dispatcher_);
     RELEASE_ASSERT(result, result.message());
 
     upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{":status", "200"}}, false);
     upstream_request_->encodeData(response_size_, true);
 
     for (const auto& header_to_add : headers_to_add) {
       EXPECT_THAT(upstream_request_->headers(),
                   Http::HeaderValueOf(header_to_add.first, header_to_add.second));
       // For headers_to_add (with append = false), the original request headers have no "-replaced"
       // suffix, but the ones from the authorization server have it.
       EXPECT_TRUE(absl::EndsWith(header_to_add.second, "-replaced"));
     }
 
     for (const auto& header_to_append : headers_to_append) {
       // The current behavior of appending is using the "appendCopy", which ALWAYS combines entries
       // with the same key into one key, and the values are separated by "," (regardless it is an
       // inline-header or not). In addition to that, it only applies to the existing headers (the
       // header is existed in the original request headers).
       EXPECT_THAT(
           upstream_request_->headers(),
           Http::HeaderValueOf(
               header_to_append.first,
               // In this test, the keys and values of the original request headers have the same
               // string value. Hence for "header2" key, the value is "header2,header2-appended".
               absl::StrCat(header_to_append.first, ",", header_to_append.second)));
       const auto value = upstream_request_->headers()
                              .get(Http::LowerCaseString(header_to_append.first))[0]
                              ->value()
                              .getStringView();
       EXPECT_TRUE(absl::EndsWith(value, "-appended"));
       const auto values = StringUtil::splitToken(value, ",");
       EXPECT_EQ(2, values.size());
     }
 
     if (!new_headers_from_upstream.empty()) {
       // new_headers_from_upstream has append = true. The current implementation ignores to set
       // multiple headers that are not present in the original request headers. In order to add
       // headers with the same key multiple times, setting response headers with append = false and
       // append = true is required.
       EXPECT_THAT(new_headers_from_upstream,
                   Not(Http::IsSubsetOfHeaders(upstream_request_->headers())));
     }
 
     if (!headers_to_append_multiple.empty()) {
       // headers_to_append_multiple has append = false for the first entry of multiple entries, and
       // append = true for the rest entries.
       EXPECT_THAT(upstream_request_->headers(),
                   Http::HeaderValueOf("multiple", "multiple-first,multiple-second"));
     }
 
     for (const auto& header_to_remove : headers_to_remove) {
       // The headers that were originally present in the request have now been removed.
       EXPECT_TRUE(
           upstream_request_->headers().get(Http::LowerCaseString{header_to_remove.first}).empty());
     }
 
     response_->waitForEndStream();
 
     EXPECT_TRUE(upstream_request_->complete());
     EXPECT_EQ(request_body_.length(), upstream_request_->bodyLength());
 
     EXPECT_TRUE(response_->complete());
     EXPECT_EQ(expected_response_code, response_->headers().getStatusValue());
     EXPECT_EQ(response_size_, response_->body().size());
   }
 
   void sendExtAuthzResponse(const Headers& headers_to_add, const Headers& headers_to_append,
                             const Headers& headers_to_remove,
                             const Http::TestRequestHeaderMapImpl& new_headers_from_upstream,
                             const Http::TestRequestHeaderMapImpl& headers_to_append_multiple) {
     ext_authz_request_->startGrpcStream();
     envoy::service::auth::v3::CheckResponse check_response;
     check_response.mutable_status()->set_code(Grpc::Status::WellKnownGrpcStatus::Ok);
 
     for (const auto& header_to_add : headers_to_add) {
       auto* entry = check_response.mutable_ok_response()->mutable_headers()->Add();
       entry->mutable_append()->set_value(false);
       entry->mutable_header()->set_key(header_to_add.first);
       entry->mutable_header()->set_value(header_to_add.second);
     }
 
     for (const auto& header_to_append : headers_to_append) {
       auto* entry = check_response.mutable_ok_response()->mutable_headers()->Add();
       entry->mutable_append()->set_value(true);
       entry->mutable_header()->set_key(header_to_append.first);
       entry->mutable_header()->set_value(header_to_append.second);
     }
 
     for (const auto& header_to_remove : headers_to_remove) {
       auto* entry = check_response.mutable_ok_response()->mutable_headers_to_remove();
       entry->Add(std::string(header_to_remove.first));
     }
 
     // Entries in this headers are not present in the original request headers.
     new_headers_from_upstream.iterate(
         [&check_response](const Http::HeaderEntry& h) -> Http::HeaderMap::Iterate {
           auto* entry = check_response.mutable_ok_response()->mutable_headers()->Add();
           // Try to append to a non-existent field.
           entry->mutable_append()->set_value(true);
           entry->mutable_header()->set_key(std::string(h.key().getStringView()));
           entry->mutable_header()->set_value(std::string(h.value().getStringView()));
           return Http::HeaderMap::Iterate::Continue;
         });
 
     // Entries in this headers are not present in the original request headers. But we set append =
     // true and append = false.
     headers_to_append_multiple.iterate(
         [&check_response](const Http::HeaderEntry& h) -> Http::HeaderMap::Iterate {
           auto* entry = check_response.mutable_ok_response()->mutable_headers()->Add();
           const auto key = std::string(h.key().getStringView());
           const auto value = std::string(h.value().getStringView());
 
           // This scenario makes sure we have set the headers to be appended later.
           entry->mutable_append()->set_value(!absl::EndsWith(value, "-first"));
           entry->mutable_header()->set_key(key);
           entry->mutable_header()->set_value(value);
           return Http::HeaderMap::Iterate::Continue;
         });
 
     ext_authz_request_->sendGrpcMessage(check_response);
     ext_authz_request_->finishGrpcStream(Grpc::Status::Ok);
   }
 
   const std::string expectedRequestBody() {
     const std::string request_body_string = request_body_.toString();
     const uint64_t request_body_length = request_body_.length();
     return request_body_length > max_request_bytes_
                ? request_body_string.substr(0, max_request_bytes_)
                : request_body_string;
   }
 
   void cleanup() {
     if (fake_ext_authz_connection_ != nullptr) {
       AssertionResult result = fake_ext_authz_connection_->close();
       RELEASE_ASSERT(result, result.message());
     }
     cleanupUpstreamAndDownstream();
   }
 
   const std::string expectedCheckRequest(Http::CodecClient::Type downstream_protocol) {
     const std::string expected_downstream_protocol =
         downstream_protocol == Http::CodecClient::Type::HTTP1 ? "HTTP/1.1" : "HTTP/2";
     constexpr absl::string_view expected_format = R"EOF(
diff --git a/test/extensions/filters/http/ratelimit/ratelimit_integration_test.cc b/test/extensions/filters/http/ratelimit/ratelimit_integration_test.cc
index 80928a3da0..b021373881 100644
--- a/test/extensions/filters/http/ratelimit/ratelimit_integration_test.cc
+++ b/test/extensions/filters/http/ratelimit/ratelimit_integration_test.cc
@@ -26,182 +26,184 @@ class RatelimitIntegrationTest : public Grpc::VersionedGrpcClientIntegrationPara
                                  public HttpIntegrationTest {
 public:
   RatelimitIntegrationTest() : HttpIntegrationTest(Http::CodecClient::Type::HTTP1, ipVersion()) {}
 
   void SetUp() override {
     XDS_DEPRECATED_FEATURE_TEST_SKIP;
     initialize();
   }
 
   void createUpstreams() override {
     HttpIntegrationTest::createUpstreams();
     addFakeUpstream(FakeHttpConnection::Type::HTTP2);
   }
 
   void initialize() override {
-
+    if (apiVersion() != envoy::config::core::v3::ApiVersion::V3) {
+      config_helper_.enableDeprecatedV2Api();
+    }
     config_helper_.addConfigModifier([this](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {
       auto* ratelimit_cluster = bootstrap.mutable_static_resources()->add_clusters();
       ratelimit_cluster->MergeFrom(bootstrap.static_resources().clusters()[0]);
       ratelimit_cluster->set_name("ratelimit");
       ConfigHelper::setHttp2(*ratelimit_cluster);
 
       // enhance rate limit filter config based on the configuration of test.
       TestUtility::loadFromYaml(base_filter_config_, proto_config_);
       proto_config_.set_failure_mode_deny(failure_mode_deny_);
       proto_config_.set_enable_x_ratelimit_headers(enable_x_ratelimit_headers_);
       proto_config_.set_disable_x_envoy_ratelimited_header(disable_x_envoy_ratelimited_header_);
       setGrpcService(*proto_config_.mutable_rate_limit_service()->mutable_grpc_service(),
                      "ratelimit", fake_upstreams_.back()->localAddress());
       proto_config_.mutable_rate_limit_service()->set_transport_api_version(apiVersion());
 
       envoy::config::listener::v3::Filter ratelimit_filter;
       ratelimit_filter.set_name("envoy.filters.http.ratelimit");
       ratelimit_filter.mutable_typed_config()->PackFrom(proto_config_);
       config_helper_.addFilter(MessageUtil::getJsonStringFromMessage(ratelimit_filter));
     });
     config_helper_.addConfigModifier(
         [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&
                hcm) {
           auto* rate_limit = hcm.mutable_route_config()
                                  ->mutable_virtual_hosts(0)
                                  ->mutable_routes(0)
                                  ->mutable_route()
                                  ->add_rate_limits();
           rate_limit->add_actions()->mutable_destination_cluster();
         });
     HttpIntegrationTest::initialize();
   }
 
   void initiateClientConnection() {
     auto conn = makeClientConnection(lookupPort("http"));
     codec_client_ = makeHttpConnection(std::move(conn));
     Http::TestRequestHeaderMapImpl headers{
         {":method", "POST"},    {":path", "/test/long/url"}, {":scheme", "http"},
         {":authority", "host"}, {"x-lyft-user-id", "123"},   {"x-forwarded-for", "10.0.0.1"}};
     response_ = codec_client_->makeRequestWithBody(headers, request_size_);
   }
 
   void waitForRatelimitRequest() {
     AssertionResult result =
         fake_upstreams_[1]->waitForHttpConnection(*dispatcher_, fake_ratelimit_connection_);
     RELEASE_ASSERT(result, result.message());
     result = fake_ratelimit_connection_->waitForNewStream(*dispatcher_, ratelimit_request_);
     RELEASE_ASSERT(result, result.message());
     envoy::service::ratelimit::v3::RateLimitRequest request_msg;
     result = ratelimit_request_->waitForGrpcMessage(*dispatcher_, request_msg);
     RELEASE_ASSERT(result, result.message());
     result = ratelimit_request_->waitForEndStream(*dispatcher_);
     RELEASE_ASSERT(result, result.message());
     EXPECT_EQ("POST", ratelimit_request_->headers().getMethodValue());
     EXPECT_EQ(TestUtility::getVersionedMethodPath("envoy.service.ratelimit.{}.RateLimitService",
                                                   "ShouldRateLimit", apiVersion()),
               ratelimit_request_->headers().getPathValue());
     EXPECT_EQ("application/grpc", ratelimit_request_->headers().getContentTypeValue());
 
     envoy::service::ratelimit::v3::RateLimitRequest expected_request_msg;
     expected_request_msg.set_domain("some_domain");
     auto* entry = expected_request_msg.add_descriptors()->add_entries();
     entry->set_key("destination_cluster");
     entry->set_value("cluster_0");
     EXPECT_EQ(expected_request_msg.DebugString(), request_msg.DebugString());
   }
 
   void waitForSuccessfulUpstreamResponse() {
     AssertionResult result =
         fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_);
     RELEASE_ASSERT(result, result.message());
     result = fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_);
     RELEASE_ASSERT(result, result.message());
     result = upstream_request_->waitForEndStream(*dispatcher_);
     RELEASE_ASSERT(result, result.message());
 
     upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{":status", "200"}}, false);
     upstream_request_->encodeData(response_size_, true);
     response_->waitForEndStream();
 
     EXPECT_TRUE(upstream_request_->complete());
     EXPECT_EQ(request_size_, upstream_request_->bodyLength());
 
     EXPECT_TRUE(response_->complete());
     EXPECT_EQ("200", response_->headers().getStatusValue());
     EXPECT_EQ(response_size_, response_->body().size());
   }
 
   void waitForFailedUpstreamResponse(uint32_t response_code) {
     response_->waitForEndStream();
     EXPECT_TRUE(response_->complete());
     EXPECT_EQ(std::to_string(response_code), response_->headers().getStatusValue());
   }
 
   void sendRateLimitResponse(
       envoy::service::ratelimit::v3::RateLimitResponse::Code code,
       const Extensions::Filters::Common::RateLimit::DescriptorStatusList& descriptor_statuses,
       const Http::ResponseHeaderMap& response_headers_to_add,
       const Http::RequestHeaderMap& request_headers_to_add) {
     ratelimit_request_->startGrpcStream();
     envoy::service::ratelimit::v3::RateLimitResponse response_msg;
     response_msg.set_overall_code(code);
     *response_msg.mutable_statuses() = {descriptor_statuses.begin(), descriptor_statuses.end()};
 
     response_headers_to_add.iterate(
         [&response_msg](const Http::HeaderEntry& h) -> Http::HeaderMap::Iterate {
           auto header = response_msg.mutable_response_headers_to_add()->Add();
           header->set_key(std::string(h.key().getStringView()));
           header->set_value(std::string(h.value().getStringView()));
           return Http::HeaderMap::Iterate::Continue;
         });
     request_headers_to_add.iterate(
         [&response_msg](const Http::HeaderEntry& h) -> Http::HeaderMap::Iterate {
           auto header = response_msg.mutable_request_headers_to_add()->Add();
           header->set_key(std::string(h.key().getStringView()));
           header->set_value(std::string(h.value().getStringView()));
           return Http::HeaderMap::Iterate::Continue;
         });
     ratelimit_request_->sendGrpcMessage(response_msg);
     ratelimit_request_->finishGrpcStream(Grpc::Status::Ok);
   }
 
   void cleanup() {
     if (fake_ratelimit_connection_ != nullptr) {
       if (clientType() != Grpc::ClientType::GoogleGrpc) {
         // TODO(htuch) we should document the underlying cause of this difference and/or fix it.
         AssertionResult result = fake_ratelimit_connection_->close();
         RELEASE_ASSERT(result, result.message());
       }
       AssertionResult result = fake_ratelimit_connection_->waitForDisconnect();
       RELEASE_ASSERT(result, result.message());
     }
     cleanupUpstreamAndDownstream();
   }
 
   void basicFlow() {
     initiateClientConnection();
     waitForRatelimitRequest();
     sendRateLimitResponse(envoy::service::ratelimit::v3::RateLimitResponse::OK, {},
                           Http::TestResponseHeaderMapImpl{}, Http::TestRequestHeaderMapImpl{});
     waitForSuccessfulUpstreamResponse();
     cleanup();
 
     EXPECT_EQ(1, test_server_->counter("cluster.cluster_0.ratelimit.ok")->value());
     EXPECT_EQ(nullptr, test_server_->counter("cluster.cluster_0.ratelimit.over_limit"));
     EXPECT_EQ(nullptr, test_server_->counter("cluster.cluster_0.ratelimit.error"));
   }
 
   FakeHttpConnectionPtr fake_ratelimit_connection_;
   FakeStreamPtr ratelimit_request_;
   IntegrationStreamDecoderPtr response_;
 
   const uint64_t request_size_ = 1024;
   const uint64_t response_size_ = 512;
   bool failure_mode_deny_ = false;
   envoy::extensions::filters::http::ratelimit::v3::RateLimit::XRateLimitHeadersRFCVersion
       enable_x_ratelimit_headers_ = envoy::extensions::filters::http::ratelimit::v3::RateLimit::OFF;
   bool disable_x_envoy_ratelimited_header_ = false;
   envoy::extensions::filters::http::ratelimit::v3::RateLimit proto_config_{};
   const std::string base_filter_config_ = R"EOF(
     domain: some_domain
     timeout: 0.5s
   )EOF";
 };
 
 // Test that verifies failure mode cases.
diff --git a/test/extensions/filters/network/common/fuzz/BUILD b/test/extensions/filters/network/common/fuzz/BUILD
index 9d90563c9c..41b2869c3d 100644
--- a/test/extensions/filters/network/common/fuzz/BUILD
+++ b/test/extensions/filters/network/common/fuzz/BUILD
@@ -59,14 +59,15 @@ envoy_cc_test_library(
 envoy_cc_fuzz_test(
     name = "network_readfilter_fuzz_test",
     srcs = ["network_readfilter_fuzz_test.cc"],
     corpus = "network_readfilter_corpus",
     dictionaries = ["network_readfilter_fuzz_test.dict"],
     # All Envoy network filters must be linked to the test in order for the fuzzer to pick
     # these up via the NamedNetworkFilterConfigFactory.
     deps = [
         ":uber_readfilter_lib",
         "//source/common/config:utility_lib",
         "//test/config:utility_lib",
+        "//test/test_common:test_runtime_lib",
     ] + envoy_all_network_filters(),
 )
 
diff --git a/test/extensions/filters/network/common/fuzz/network_readfilter_fuzz_test.cc b/test/extensions/filters/network/common/fuzz/network_readfilter_fuzz_test.cc
index cacff3aa89..2582fe207c 100644
--- a/test/extensions/filters/network/common/fuzz/network_readfilter_fuzz_test.cc
+++ b/test/extensions/filters/network/common/fuzz/network_readfilter_fuzz_test.cc
@@ -1,61 +1,63 @@
 #include "common/config/utility.h"
 #include "common/protobuf/utility.h"
 
 #include "extensions/filters/network/well_known_names.h"
 
 #include "test/config/utility.h"
 #include "test/extensions/filters/network/common/fuzz/network_readfilter_fuzz.pb.validate.h"
 #include "test/extensions/filters/network/common/fuzz/uber_readfilter.h"
 #include "test/fuzz/fuzz_runner.h"
+#include "test/test_common/test_runtime.h"
 
 namespace Envoy {
 namespace Extensions {
 namespace NetworkFilters {
 DEFINE_PROTO_FUZZER(const test::extensions::filters::network::FilterFuzzTestCase& input) {
+  TestDeprecatedV2Api _deprecated_v2_api;
   ABSL_ATTRIBUTE_UNUSED static PostProcessorRegistration reg = {
       [](test::extensions::filters::network::FilterFuzzTestCase* input, unsigned int seed) {
         // This post-processor mutation is applied only when libprotobuf-mutator
         // calls mutate on an input, and *not* during fuzz target execution.
         // Replaying a corpus through the fuzzer will not be affected by the
         // post-processor mutation.
 
         // TODO(jianwendong): After extending to cover all the filters, we can use
         // `Registry::FactoryRegistry<
         // Server::Configuration::NamedNetworkFilterConfigFactory>::registeredNames()`
         // to get all the filter names instead of calling `UberFilterFuzzer::filter_names()`.
         static const auto filter_names = UberFilterFuzzer::filterNames();
         static const auto factories = Registry::FactoryRegistry<
             Server::Configuration::NamedNetworkFilterConfigFactory>::factories();
         // Choose a valid filter name.
         if (std::find(filter_names.begin(), filter_names.end(), input->config().name()) ==
             std::end(filter_names)) {
           absl::string_view filter_name = filter_names[seed % filter_names.size()];
           input->mutable_config()->set_name(std::string(filter_name));
         }
         // Set the corresponding type_url for Any.
         auto& factory = factories.at(input->config().name());
         input->mutable_config()->mutable_typed_config()->set_type_url(
             absl::StrCat("type.googleapis.com/",
                          factory->createEmptyConfigProto()->GetDescriptor()->full_name()));
       }};
 
   try {
     TestUtility::validate(input);
     // Check the filter's name in case some filters are not supported yet.
     static const auto filter_names = UberFilterFuzzer::filterNames();
     // TODO(jianwendong): remove this if block after covering all the filters.
     if (std::find(filter_names.begin(), filter_names.end(), input.config().name()) ==
         std::end(filter_names)) {
       ENVOY_LOG_MISC(debug, "Test case with unsupported filter type: {}", input.config().name());
       return;
     }
     static UberFilterFuzzer fuzzer;
     fuzzer.fuzz(input.config(), input.actions());
   } catch (const ProtoValidationException& e) {
     ENVOY_LOG_MISC(debug, "ProtoValidationException: {}", e.what());
   }
 }
 
 } // namespace NetworkFilters
 } // namespace Extensions
-} // namespace Envoy
\ No newline at end of file
+} // namespace Envoy
diff --git a/test/extensions/filters/network/ext_authz/BUILD b/test/extensions/filters/network/ext_authz/BUILD
index d3a01660f4..d04bd170c3 100644
--- a/test/extensions/filters/network/ext_authz/BUILD
+++ b/test/extensions/filters/network/ext_authz/BUILD
@@ -37,11 +37,12 @@ envoy_extension_cc_test(
 envoy_extension_cc_test(
     name = "config_test",
     srcs = ["config_test.cc"],
     extension_name = "envoy.filters.network.ext_authz",
     deps = [
         "//source/extensions/filters/network/ext_authz:config",
         "//test/mocks/server:factory_context_mocks",
+        "//test/test_common:test_runtime_lib",
         "@envoy_api//envoy/config/core/v3:pkg_cc_proto",
         "@envoy_api//envoy/extensions/filters/network/ext_authz/v3:pkg_cc_proto",
     ],
 )
diff --git a/test/extensions/filters/network/ext_authz/config_test.cc b/test/extensions/filters/network/ext_authz/config_test.cc
index a96e02ee91..9cdb483aa7 100644
--- a/test/extensions/filters/network/ext_authz/config_test.cc
+++ b/test/extensions/filters/network/ext_authz/config_test.cc
@@ -1,12 +1,13 @@
 #include "envoy/config/core/v3/grpc_service.pb.h"
 #include "envoy/extensions/filters/network/ext_authz/v3/ext_authz.pb.h"
 #include "envoy/extensions/filters/network/ext_authz/v3/ext_authz.pb.validate.h"
 #include "envoy/stats/scope.h"
 
 #include "extensions/filters/network/ext_authz/config.h"
 
 #include "test/mocks/server/factory_context.h"
+#include "test/test_common/test_runtime.h"
 #include "test/test_common/utility.h"
 
 #include "gmock/gmock.h"
 #include "gtest/gtest.h"
@@ -21,31 +22,34 @@ namespace ExtAuthz {
 
 namespace {
 void expectCorrectProto(envoy::config::core::v3::ApiVersion api_version) {
+  std::unique_ptr<TestDeprecatedV2Api> _deprecated_v2_api;
+  if (api_version != envoy::config::core::v3::ApiVersion::V3) {
+    _deprecated_v2_api = std::make_unique<TestDeprecatedV2Api>();
+  }
   std::string yaml = R"EOF(
-  transport_api_version: V3
   grpc_service:
     google_grpc:
       target_uri: ext_authz_server
       stat_prefix: google
   failure_mode_allow: false
   stat_prefix: name
   transport_api_version: {}
 )EOF";
 
   ExtAuthzConfigFactory factory;
   ProtobufTypes::MessagePtr proto_config = factory.createEmptyConfigProto();
   TestUtility::loadFromYaml(
       fmt::format(yaml, TestUtility::getVersionStringFromApiVersion(api_version)), *proto_config);
 
   NiceMock<Server::Configuration::MockFactoryContext> context;
 
   EXPECT_CALL(context.cluster_manager_.async_client_manager_, factoryForGrpcService(_, _, _))
       .WillOnce(Invoke([](const envoy::config::core::v3::GrpcService&, Stats::Scope&, bool) {
         return std::make_unique<NiceMock<Grpc::MockAsyncClientFactory>>();
       }));
   Network::FilterFactoryCb cb = factory.createFilterFactoryFromProto(*proto_config, context);
   Network::MockConnection connection;
   EXPECT_CALL(connection, addReadFilter(_));
   cb(connection);
 }
 } // namespace
diff --git a/test/extensions/stats_sinks/metrics_service/metrics_service_integration_test.cc b/test/extensions/stats_sinks/metrics_service/metrics_service_integration_test.cc
index 81b89d4ff9..0bf4f9cada 100644
--- a/test/extensions/stats_sinks/metrics_service/metrics_service_integration_test.cc
+++ b/test/extensions/stats_sinks/metrics_service/metrics_service_integration_test.cc
@@ -22,126 +22,129 @@ class MetricsServiceIntegrationTest : public Grpc::VersionedGrpcClientIntegratio
                                       public HttpIntegrationTest {
 public:
   MetricsServiceIntegrationTest()
       : HttpIntegrationTest(Http::CodecClient::Type::HTTP1, ipVersion()) {}
 
   void createUpstreams() override {
     HttpIntegrationTest::createUpstreams();
     addFakeUpstream(FakeHttpConnection::Type::HTTP2);
   }
 
   void initialize() override {
+    if (apiVersion() != envoy::config::core::v3::ApiVersion::V3) {
+      config_helper_.enableDeprecatedV2Api();
+    }
     config_helper_.addConfigModifier([this](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {
       // metrics_service cluster for Envoy gRPC.
       auto* metrics_service_cluster = bootstrap.mutable_static_resources()->add_clusters();
       metrics_service_cluster->MergeFrom(bootstrap.static_resources().clusters()[0]);
       metrics_service_cluster->set_name("metrics_service");
       ConfigHelper::setHttp2(*metrics_service_cluster);
       // metrics_service gRPC service definition.
       auto* metrics_sink = bootstrap.add_stats_sinks();
       metrics_sink->set_name("envoy.stat_sinks.metrics_service");
       envoy::config::metrics::v3::MetricsServiceConfig config;
       setGrpcService(*config.mutable_grpc_service(), "metrics_service",
                      fake_upstreams_.back()->localAddress());
       config.set_transport_api_version(apiVersion());
       metrics_sink->mutable_typed_config()->PackFrom(config);
       // Shrink reporting period down to 1s to make test not take forever.
       bootstrap.mutable_stats_flush_interval()->CopyFrom(
           Protobuf::util::TimeUtil::MillisecondsToDuration(100));
     });
 
     HttpIntegrationTest::initialize();
   }
 
   ABSL_MUST_USE_RESULT
   AssertionResult waitForMetricsServiceConnection() {
     return fake_upstreams_[1]->waitForHttpConnection(*dispatcher_,
                                                      fake_metrics_service_connection_);
   }
 
   ABSL_MUST_USE_RESULT
   AssertionResult waitForMetricsStream() {
     return fake_metrics_service_connection_->waitForNewStream(*dispatcher_,
                                                               metrics_service_request_);
   }
 
   ABSL_MUST_USE_RESULT
   AssertionResult waitForMetricsRequest() {
     bool known_summary_exists = false;
     bool known_histogram_exists = false;
     bool known_counter_exists = false;
     bool known_gauge_exists = false;
 
     // Sometimes stats do not come in the first flush cycle, this loop ensures that we wait till
     // required stats are flushed.
     // TODO(ramaraochavali): Figure out a more robust way to find out all required stats have been
     // flushed.
     while (!(known_counter_exists && known_gauge_exists && known_summary_exists &&
              known_histogram_exists)) {
       envoy::service::metrics::v3::StreamMetricsMessage request_msg;
       VERIFY_ASSERTION(metrics_service_request_->waitForGrpcMessage(*dispatcher_, request_msg));
       EXPECT_EQ("POST", metrics_service_request_->headers().getMethodValue());
       EXPECT_EQ(TestUtility::getVersionedMethodPath("envoy.service.metrics.{}.MetricsService",
                                                     "StreamMetrics", apiVersion()),
                 metrics_service_request_->headers().getPathValue());
       EXPECT_EQ("application/grpc", metrics_service_request_->headers().getContentTypeValue());
       EXPECT_TRUE(request_msg.envoy_metrics_size() > 0);
       const Protobuf::RepeatedPtrField<::io::prometheus::client::MetricFamily>& envoy_metrics =
           request_msg.envoy_metrics();
 
       int64_t previous_time_stamp = 0;
       for (const ::io::prometheus::client::MetricFamily& metrics_family : envoy_metrics) {
         if (metrics_family.name() == "cluster.cluster_0.membership_change" &&
             metrics_family.type() == ::io::prometheus::client::MetricType::COUNTER) {
           known_counter_exists = true;
           EXPECT_EQ(1, metrics_family.metric(0).counter().value());
         }
         if (metrics_family.name() == "cluster.cluster_0.membership_total" &&
             metrics_family.type() == ::io::prometheus::client::MetricType::GAUGE) {
           known_gauge_exists = true;
           EXPECT_EQ(1, metrics_family.metric(0).gauge().value());
         }
         if (metrics_family.name() == "cluster.cluster_0.upstream_rq_time" &&
             metrics_family.type() == ::io::prometheus::client::MetricType::SUMMARY) {
           known_summary_exists = true;
           Stats::HistogramStatisticsImpl empty_statistics;
           EXPECT_EQ(metrics_family.metric(0).summary().quantile_size(),
                     empty_statistics.supportedQuantiles().size());
         }
         if (metrics_family.name() == "cluster.cluster_0.upstream_rq_time" &&
             metrics_family.type() == ::io::prometheus::client::MetricType::HISTOGRAM) {
           known_histogram_exists = true;
           EXPECT_EQ(metrics_family.metric(0).histogram().bucket_size(),
                     Stats::HistogramSettingsImpl::defaultBuckets().size());
         }
         ASSERT(metrics_family.metric(0).has_timestamp_ms());
         // Validate that all metrics have the same timestamp.
         if (previous_time_stamp > 0) {
           EXPECT_EQ(previous_time_stamp, metrics_family.metric(0).timestamp_ms());
         }
         previous_time_stamp = metrics_family.metric(0).timestamp_ms();
         if (known_counter_exists && known_gauge_exists && known_summary_exists &&
             known_histogram_exists) {
           break;
         }
       }
     }
     EXPECT_TRUE(known_counter_exists);
     EXPECT_TRUE(known_gauge_exists);
     EXPECT_TRUE(known_summary_exists);
     EXPECT_TRUE(known_histogram_exists);
 
     return AssertionSuccess();
   }
 
   void cleanup() {
     if (fake_metrics_service_connection_ != nullptr) {
       AssertionResult result = fake_metrics_service_connection_->close();
       RELEASE_ASSERT(result, result.message());
       result = fake_metrics_service_connection_->waitForDisconnect();
       RELEASE_ASSERT(result, result.message());
     }
   }
 
   FakeHttpConnectionPtr fake_metrics_service_connection_;
   FakeStreamPtr metrics_service_request_;
 };
diff --git a/test/integration/ads_integration.cc b/test/integration/ads_integration.cc
index c8f1c3b7b5..cf0fbeb710 100644
--- a/test/integration/ads_integration.cc
+++ b/test/integration/ads_integration.cc
@@ -20,16 +20,17 @@ using testing::AssertionResult;
 
 namespace Envoy {
 
-AdsIntegrationTest::AdsIntegrationTest(const envoy::config::core::v3::ApiVersion api_version)
-    : HttpIntegrationTest(
-          Http::CodecClient::Type::HTTP2, ipVersion(),
-          ConfigHelper::adsBootstrap(
-              sotwOrDelta() == Grpc::SotwOrDelta::Sotw ? "GRPC" : "DELTA_GRPC", api_version)) {
+AdsIntegrationTest::AdsIntegrationTest(envoy::config::core::v3::ApiVersion resource_api_version,
+                                       envoy::config::core::v3::ApiVersion transport_api_version)
+    : HttpIntegrationTest(Http::CodecClient::Type::HTTP2, ipVersion(),
+                          ConfigHelper::adsBootstrap(
+                              sotwOrDelta() == Grpc::SotwOrDelta::Sotw ? "GRPC" : "DELTA_GRPC",
+                              resource_api_version, transport_api_version)) {
   use_lds_ = false;
   create_xds_upstream_ = true;
   tls_xds_upstream_ = true;
   sotw_or_delta_ = sotwOrDelta();
-  api_version_ = api_version;
+  api_version_ = resource_api_version;
   setUpstreamProtocol(FakeHttpConnection::Type::HTTP2);
 }
 
diff --git a/test/integration/ads_integration.h b/test/integration/ads_integration.h
index 804b3b3f31..18468f975d 100644
--- a/test/integration/ads_integration.h
+++ b/test/integration/ads_integration.h
@@ -17,49 +17,51 @@ namespace Envoy {
 
 class AdsIntegrationTest : public Grpc::DeltaSotwIntegrationParamTest, public HttpIntegrationTest {
 public:
-  AdsIntegrationTest(const envoy::config::core::v3::ApiVersion api_version);
+  AdsIntegrationTest(envoy::config::core::v3::ApiVersion resource_api_version,
+                     envoy::config::core::v3::ApiVersion transport_api_version =
+                         envoy::config::core::v3::ApiVersion::AUTO);
   AdsIntegrationTest() : AdsIntegrationTest(envoy::config::core::v3::ApiVersion::V3) {}
 
   void TearDown() override;
 
   envoy::config::cluster::v3::Cluster buildCluster(const std::string& name,
                                                    const std::string& lb_policy = "ROUND_ROBIN");
 
   envoy::config::cluster::v3::Cluster buildTlsCluster(const std::string& name);
 
   envoy::config::cluster::v3::Cluster buildRedisCluster(const std::string& name);
 
   envoy::config::endpoint::v3::ClusterLoadAssignment
   buildClusterLoadAssignment(const std::string& name);
 
   envoy::config::endpoint::v3::ClusterLoadAssignment
   buildTlsClusterLoadAssignment(const std::string& name);
 
   envoy::config::listener::v3::Listener buildListener(const std::string& name,
                                                       const std::string& route_config,
                                                       const std::string& stat_prefix = "ads_test");
 
   envoy::config::listener::v3::Listener buildRedisListener(const std::string& name,
                                                            const std::string& cluster);
 
   envoy::config::route::v3::RouteConfiguration buildRouteConfig(const std::string& name,
                                                                 const std::string& cluster);
 
   void makeSingleRequest();
 
   void initialize() override;
   void initializeAds(const bool rate_limiting);
 
   void testBasicFlow();
 
   envoy::admin::v3::ClustersConfigDump getClustersConfigDump();
   envoy::admin::v3::ListenersConfigDump getListenersConfigDump();
   envoy::admin::v3::RoutesConfigDump getRoutesConfigDump();
 
   // If API version is v2, fatal-by-default is disabled unless fatal_by_default_v2_override_ is set.
   envoy::config::core::v3::ApiVersion api_version_;
   // Set to force fatal-by-default v2 even if API version is v2.
   bool fatal_by_default_v2_override_{false};
 };
 
 } // namespace Envoy
diff --git a/test/integration/ads_integration_test.cc b/test/integration/ads_integration_test.cc
index 90e2b56230..1f49cd2842 100644
--- a/test/integration/ads_integration_test.cc
+++ b/test/integration/ads_integration_test.cc
@@ -1385,38 +1385,24 @@ INSTANTIATE_TEST_SUITE_P(IpVersionsClientTypeDelta, AdsClusterV2Test,
 // Basic CDS/EDS update that warms and makes active a single cluster (v2 API).
 TEST_P(AdsClusterV2Test, DEPRECATED_FEATURE_TEST(BasicClusterInitialWarming)) {
   initialize();
   const auto cds_type_url = Config::getTypeUrl<envoy::config::cluster::v3::Cluster>(
       envoy::config::core::v3::ApiVersion::V2);
   const auto eds_type_url = Config::getTypeUrl<envoy::config::endpoint::v3::ClusterLoadAssignment>(
       envoy::config::core::v3::ApiVersion::V2);
 
   EXPECT_TRUE(compareDiscoveryRequest(cds_type_url, "", {}, {}, {}, true));
   sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(
       cds_type_url, {buildCluster("cluster_0")}, {buildCluster("cluster_0")}, {}, "1", true);
   test_server_->waitForGaugeEq("cluster_manager.warming_clusters", 1);
   EXPECT_TRUE(compareDiscoveryRequest(eds_type_url, "", {"cluster_0"}, {"cluster_0"}, {}));
   sendDiscoveryResponse<envoy::config::endpoint::v3::ClusterLoadAssignment>(
       eds_type_url, {buildClusterLoadAssignment("cluster_0")},
       {buildClusterLoadAssignment("cluster_0")}, {}, "1", true);
 
   test_server_->waitForGaugeEq("cluster_manager.warming_clusters", 0);
   test_server_->waitForGaugeGe("cluster_manager.active_clusters", 2);
 }
 
-// If we attempt to use v2 APIs by default, the configuration should be rejected.
-TEST_P(AdsClusterV2Test, DEPRECATED_FEATURE_TEST(RejectV2ConfigByDefault)) {
-  fatal_by_default_v2_override_ = true;
-  initialize();
-  const auto cds_type_url = Config::getTypeUrl<envoy::config::cluster::v3::Cluster>(
-      envoy::config::core::v3::ApiVersion::V2);
-
-  EXPECT_TRUE(compareDiscoveryRequest(cds_type_url, "", {}, {}, {}, true));
-  sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(
-      cds_type_url, {buildCluster("cluster_0")}, {buildCluster("cluster_0")}, {}, "1", true);
-  test_server_->waitForCounterGe("cluster_manager.cds.update_rejected", 1);
-  EXPECT_EQ(1, test_server_->gauge("runtime.deprecated_feature_seen_since_process_start")->value());
-}
-
 // Verify CDS is paused during cluster warming.
 TEST_P(AdsClusterV2Test, DEPRECATED_FEATURE_TEST(CdsPausedDuringWarming)) {
   initialize();
@@ -1553,18 +1539,44 @@ TEST_P(AdsClusterV2Test, DEPRECATED_FEATURE_TEST(XdsBatching)) {
 // Regression test for https://github.com/envoyproxy/envoy/issues/13681.
 TEST_P(AdsClusterV2Test, DEPRECATED_FEATURE_TEST(TypeUrlAnnotationRegression)) {
   initialize();
   const auto cds_type_url = Config::getTypeUrl<envoy::config::cluster::v3::Cluster>(
       envoy::config::core::v3::ApiVersion::V2);
 
   EXPECT_TRUE(compareDiscoveryRequest(cds_type_url, "", {}, {}, {}, true));
   auto cluster = buildCluster("cluster_0");
   auto* bias = cluster.mutable_least_request_lb_config()->mutable_active_request_bias();
   bias->set_default_value(1.1);
   bias->set_runtime_key("foo");
   sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(cds_type_url, {cluster}, {cluster}, {},
                                                              "1", true);
 
   test_server_->waitForCounterGe("cluster_manager.cds.update_rejected", 1);
 }
 
+// Validate v2 resource are rejected by default.
+class AdsV2ResourceRejectTest : public AdsIntegrationTest {
+public:
+  // We need to use a v3 transport as we're not going to set the v2 allow overrides.
+  AdsV2ResourceRejectTest()
+      : AdsIntegrationTest(envoy::config::core::v3::ApiVersion::V2,
+                           envoy::config::core::v3::ApiVersion::V3) {}
+};
+
+INSTANTIATE_TEST_SUITE_P(IpVersionsClientTypeDelta, AdsV2ResourceRejectTest,
+                         DELTA_SOTW_GRPC_CLIENT_INTEGRATION_PARAMS);
+
+// If we attempt to use v2 APIs by default, the configuration should be rejected.
+TEST_P(AdsV2ResourceRejectTest, DEPRECATED_FEATURE_TEST(RejectV2ConfigByDefault)) {
+  fatal_by_default_v2_override_ = true;
+  initialize();
+  const auto cds_type_url = Config::getTypeUrl<envoy::config::cluster::v3::Cluster>(
+      envoy::config::core::v3::ApiVersion::V2);
+
+  EXPECT_TRUE(compareDiscoveryRequest(cds_type_url, "", {}, {}, {}, true));
+  sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(
+      cds_type_url, {buildCluster("cluster_0")}, {buildCluster("cluster_0")}, {}, "1", true);
+  test_server_->waitForCounterGe("cluster_manager.cds.update_rejected", 1);
+  EXPECT_EQ(1, test_server_->gauge("runtime.deprecated_feature_seen_since_process_start")->value());
+}
+
 } // namespace Envoy
diff --git a/test/integration/hds_integration_test.cc b/test/integration/hds_integration_test.cc
index 378538f2fc..c473226d73 100644
--- a/test/integration/hds_integration_test.cc
+++ b/test/integration/hds_integration_test.cc
@@ -31,128 +31,131 @@ class HdsIntegrationTest : public Grpc::VersionedGrpcClientIntegrationParamTest,
                            public HttpIntegrationTest {
 public:
   HdsIntegrationTest() : HttpIntegrationTest(Http::CodecClient::Type::HTTP1, ipVersion()) {}
 
   void createUpstreams() override {
     addFakeUpstream(FakeHttpConnection::Type::HTTP2);
     hds_upstream_ = fake_upstreams_.back().get();
     HttpIntegrationTest::createUpstreams();
   }
   void initialize() override {
+    if (apiVersion() != envoy::config::core::v3::ApiVersion::V3) {
+      config_helper_.enableDeprecatedV2Api();
+    }
     setUpstreamCount(upstream_endpoints_);
     config_helper_.addConfigModifier([this](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {
       // Setup hds and corresponding gRPC cluster.
       auto* hds_config = bootstrap.mutable_hds_config();
       hds_config->set_api_type(envoy::config::core::v3::ApiConfigSource::GRPC);
       hds_config->set_transport_api_version(envoy::config::core::v3::ApiVersion::V3);
       hds_config->add_grpc_services()->mutable_envoy_grpc()->set_cluster_name("hds_cluster");
       hds_config->set_transport_api_version(apiVersion());
       auto* hds_cluster = bootstrap.mutable_static_resources()->add_clusters();
       hds_cluster->MergeFrom(bootstrap.static_resources().clusters()[0]);
       hds_cluster->mutable_circuit_breakers()->Clear();
       hds_cluster->set_name("hds_cluster");
       ConfigHelper::setHttp2(*hds_cluster);
       auto* cluster_0 = bootstrap.mutable_static_resources()->mutable_clusters(0);
       cluster_0->clear_load_assignment();
     });
 
     HttpIntegrationTest::initialize();
 
     // Endpoint connections
     if (tls_hosts_) {
       host_upstream_ =
           createFakeUpstream(HttpIntegrationTest::createUpstreamTlsContext(), http_conn_type_);
       host2_upstream_ =
           createFakeUpstream(HttpIntegrationTest::createUpstreamTlsContext(), http_conn_type_);
     } else {
       host_upstream_ = createFakeUpstream(http_conn_type_);
       host2_upstream_ = createFakeUpstream(http_conn_type_);
     }
   }
 
   // Sets up a connection between Envoy and the management server.
   void waitForHdsStream() {
     AssertionResult result =
         hds_upstream_->waitForHttpConnection(*dispatcher_, hds_fake_connection_);
     RELEASE_ASSERT(result, result.message());
     result = hds_fake_connection_->waitForNewStream(*dispatcher_, hds_stream_);
     RELEASE_ASSERT(result, result.message());
   }
 
   // Envoy sends health check messages to the endpoints
   void healthcheckEndpoints(std::string cluster2 = "") {
     ASSERT_TRUE(host_upstream_->waitForHttpConnection(*dispatcher_, host_fake_connection_));
     ASSERT_TRUE(host_fake_connection_->waitForNewStream(*dispatcher_, host_stream_));
     ASSERT_TRUE(host_stream_->waitForEndStream(*dispatcher_));
 
     EXPECT_EQ(host_stream_->headers().getPathValue(), "/healthcheck");
     EXPECT_EQ(host_stream_->headers().getMethodValue(), "GET");
     EXPECT_EQ(host_stream_->headers().getHostValue(), "anna");
 
     if (!cluster2.empty()) {
       ASSERT_TRUE(host2_upstream_->waitForHttpConnection(*dispatcher_, host2_fake_connection_));
       ASSERT_TRUE(host2_fake_connection_->waitForNewStream(*dispatcher_, host2_stream_));
       ASSERT_TRUE(host2_stream_->waitForEndStream(*dispatcher_));
 
       EXPECT_EQ(host2_stream_->headers().getPathValue(), "/healthcheck");
       EXPECT_EQ(host2_stream_->headers().getMethodValue(), "GET");
       EXPECT_EQ(host2_stream_->headers().getHostValue(), cluster2);
     }
   }
 
   // Clean up the connection between Envoy and the management server
   void cleanupHdsConnection() {
     if (hds_fake_connection_ != nullptr) {
       AssertionResult result = hds_fake_connection_->close();
       RELEASE_ASSERT(result, result.message());
       result = hds_fake_connection_->waitForDisconnect();
       RELEASE_ASSERT(result, result.message());
     }
   }
 
   // Clean up connections between Envoy and endpoints
   void cleanupHostConnections() {
     if (host_fake_connection_ != nullptr) {
       AssertionResult result = host_fake_connection_->close();
       RELEASE_ASSERT(result, result.message());
       result = host_fake_connection_->waitForDisconnect();
       RELEASE_ASSERT(result, result.message());
     }
     if (host2_fake_connection_ != nullptr) {
       AssertionResult result = host2_fake_connection_->close();
       RELEASE_ASSERT(result, result.message());
       result = host2_fake_connection_->waitForDisconnect();
       RELEASE_ASSERT(result, result.message());
     }
   }
 
   // Creates a basic HealthCheckSpecifier message containing one endpoint and
   // one HTTP health_check
   envoy::service::health::v3::HealthCheckSpecifier
   makeHttpHealthCheckSpecifier(envoy::type::v3::CodecClientType codec_type, bool use_tls) {
     envoy::service::health::v3::HealthCheckSpecifier server_health_check_specifier_;
     server_health_check_specifier_.mutable_interval()->set_nanos(100000000); // 0.1 seconds
 
     auto* cluster_health_check = server_health_check_specifier_.add_cluster_health_checks();
 
     cluster_health_check->set_cluster_name("anna");
     Network::Utility::addressToProtobufAddress(
         *host_upstream_->localAddress(),
         *cluster_health_check->add_locality_endpoints()->add_endpoints()->mutable_address());
     cluster_health_check->mutable_locality_endpoints(0)->mutable_locality()->set_region(
         "middle_earth");
     cluster_health_check->mutable_locality_endpoints(0)->mutable_locality()->set_zone("shire");
     cluster_health_check->mutable_locality_endpoints(0)->mutable_locality()->set_sub_zone(
         "hobbiton");
     auto* health_check = cluster_health_check->add_health_checks();
     health_check->mutable_timeout()->set_seconds(MaxTimeout);
     health_check->mutable_interval()->set_seconds(MaxTimeout);
     health_check->mutable_unhealthy_threshold()->set_value(2);
     health_check->mutable_healthy_threshold()->set_value(2);
     health_check->mutable_grpc_health_check();
     auto* http_health_check = health_check->mutable_http_health_check();
     http_health_check->set_path("/healthcheck");
     http_health_check->set_codec_client_type(codec_type);
     if (use_tls) {
       // Map our transport socket matches with our matcher.
       const std::string criteria_yaml = absl::StrFormat(
           R"EOF(
diff --git a/test/integration/load_stats_integration_test.cc b/test/integration/load_stats_integration_test.cc
index f7b007fa9a..d476823971 100644
--- a/test/integration/load_stats_integration_test.cc
+++ b/test/integration/load_stats_integration_test.cc
@@ -21,367 +21,370 @@ class LoadStatsIntegrationTest : public Grpc::VersionedGrpcClientIntegrationPara
                                  public HttpIntegrationTest {
 public:
   LoadStatsIntegrationTest() : HttpIntegrationTest(Http::CodecClient::Type::HTTP1, ipVersion()) {
     // We rely on some fairly specific load balancing picks in this test, so
     // determinize the schedule.
     setDeterministic();
   }
 
   void addEndpoint(envoy::config::endpoint::v3::LocalityLbEndpoints& locality_lb_endpoints,
                    uint32_t index, uint32_t& num_endpoints) {
     setUpstreamAddress(index + 1, *locality_lb_endpoints.add_lb_endpoints());
     ++num_endpoints;
   }
 
   // Used as args to updateClusterLocalityAssignment().
   struct LocalityAssignment {
     LocalityAssignment() : LocalityAssignment({}, 0) {}
     LocalityAssignment(const std::vector<uint32_t>& endpoints) : LocalityAssignment(endpoints, 0) {}
     LocalityAssignment(const std::vector<uint32_t>& endpoints, uint32_t weight)
         : endpoints_(endpoints), weight_(weight) {}
 
     // service_upstream_ indices for endpoints in the cluster.
     const std::vector<uint32_t> endpoints_;
     // If non-zero, locality level weighting.
     const uint32_t weight_{};
   };
 
   // We need to supply the endpoints via EDS to provide locality information for
   // load reporting. Use a filesystem delivery to simplify test mechanics.
   void updateClusterLoadAssignment(const LocalityAssignment& winter_upstreams,
                                    const LocalityAssignment& dragon_upstreams,
                                    const LocalityAssignment& p1_winter_upstreams,
                                    const LocalityAssignment& p1_dragon_upstreams) {
     uint32_t num_endpoints = 0;
     envoy::config::endpoint::v3::ClusterLoadAssignment cluster_load_assignment;
     // EDS service_name is set in cluster_0
     cluster_load_assignment.set_cluster_name("service_name_0");
 
     auto* winter = cluster_load_assignment.add_endpoints();
     winter->mutable_locality()->set_region("some_region");
     winter->mutable_locality()->set_zone("zone_name");
     winter->mutable_locality()->set_sub_zone("winter");
     if (winter_upstreams.weight_ > 0) {
       winter->mutable_load_balancing_weight()->set_value(winter_upstreams.weight_);
     }
     for (uint32_t index : winter_upstreams.endpoints_) {
       addEndpoint(*winter, index, num_endpoints);
     }
 
     auto* dragon = cluster_load_assignment.add_endpoints();
     dragon->mutable_locality()->set_region("some_region");
     dragon->mutable_locality()->set_zone("zone_name");
     dragon->mutable_locality()->set_sub_zone("dragon");
     if (dragon_upstreams.weight_ > 0) {
       dragon->mutable_load_balancing_weight()->set_value(dragon_upstreams.weight_);
     }
     for (uint32_t index : dragon_upstreams.endpoints_) {
       addEndpoint(*dragon, index, num_endpoints);
     }
 
     auto* winter_p1 = cluster_load_assignment.add_endpoints();
     winter_p1->set_priority(1);
     winter_p1->mutable_locality()->set_region("some_region");
     winter_p1->mutable_locality()->set_zone("zone_name");
     winter_p1->mutable_locality()->set_sub_zone("winter");
     for (uint32_t index : p1_winter_upstreams.endpoints_) {
       addEndpoint(*winter_p1, index, num_endpoints);
     }
 
     auto* dragon_p1 = cluster_load_assignment.add_endpoints();
     dragon_p1->set_priority(1);
     dragon_p1->mutable_locality()->set_region("some_region");
     dragon_p1->mutable_locality()->set_zone("zone_name");
     dragon_p1->mutable_locality()->set_sub_zone("dragon");
     for (uint32_t index : p1_dragon_upstreams.endpoints_) {
       addEndpoint(*dragon_p1, index, num_endpoints);
     }
     eds_helper_.setEdsAndWait({cluster_load_assignment}, *test_server_);
   }
 
   void createUpstreams() override {
     addFakeUpstream(FakeHttpConnection::Type::HTTP2);
     load_report_upstream_ = fake_upstreams_.back().get();
     HttpIntegrationTest::createUpstreams();
   }
 
   void initialize() override {
+    if (apiVersion() != envoy::config::core::v3::ApiVersion::V3) {
+      config_helper_.enableDeprecatedV2Api();
+    }
     setUpstreamCount(upstream_endpoints_);
     config_helper_.addConfigModifier([this](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {
       // Setup load reporting and corresponding gRPC cluster.
       auto* loadstats_config = bootstrap.mutable_cluster_manager()->mutable_load_stats_config();
       loadstats_config->set_api_type(envoy::config::core::v3::ApiConfigSource::GRPC);
       loadstats_config->add_grpc_services()->mutable_envoy_grpc()->set_cluster_name("load_report");
       loadstats_config->set_transport_api_version(apiVersion());
       auto* load_report_cluster = bootstrap.mutable_static_resources()->add_clusters();
       load_report_cluster->MergeFrom(bootstrap.static_resources().clusters()[0]);
       load_report_cluster->mutable_circuit_breakers()->Clear();
       load_report_cluster->set_name("load_report");
       ConfigHelper::setHttp2(*load_report_cluster);
       // Put ourselves in a locality that will be used in
       // updateClusterLoadAssignment()
       auto* locality = bootstrap.mutable_node()->mutable_locality();
       locality->set_region("some_region");
       locality->set_zone("zone_name");
       locality->set_sub_zone(sub_zone_);
       // Switch predefined cluster_0 to EDS filesystem sourcing.
       auto* cluster_0 = bootstrap.mutable_static_resources()->mutable_clusters(0);
       cluster_0->set_type(envoy::config::cluster::v3::Cluster::EDS);
       auto* eds_cluster_config = cluster_0->mutable_eds_cluster_config();
       eds_cluster_config->mutable_eds_config()->set_resource_api_version(
           envoy::config::core::v3::ApiVersion::V3);
       eds_cluster_config->mutable_eds_config()->set_path(eds_helper_.eds_path());
       eds_cluster_config->set_service_name("service_name_0");
       if (locality_weighted_lb_) {
         cluster_0->mutable_common_lb_config()->mutable_locality_weighted_lb_config();
       }
     });
     HttpIntegrationTest::initialize();
     load_report_upstream_ = fake_upstreams_[0].get();
     for (uint32_t i = 0; i < upstream_endpoints_; ++i) {
       service_upstream_[i] = fake_upstreams_[i + 1].get();
     }
     updateClusterLoadAssignment({}, {}, {}, {});
   }
 
   void initiateClientConnection() {
     auto conn = makeClientConnection(lookupPort("http"));
     codec_client_ = makeHttpConnection(std::move(conn));
     Http::TestRequestHeaderMapImpl headers{
         {":method", "POST"},    {":path", "/test/long/url"}, {":scheme", "http"},
         {":authority", "host"}, {"x-lyft-user-id", "123"},   {"x-forwarded-for", "10.0.0.1"}};
     response_ = codec_client_->makeRequestWithBody(headers, request_size_);
   }
 
   void waitForLoadStatsStream() {
     AssertionResult result =
         load_report_upstream_->waitForHttpConnection(*dispatcher_, fake_loadstats_connection_);
     RELEASE_ASSERT(result, result.message());
     result = fake_loadstats_connection_->waitForNewStream(*dispatcher_, loadstats_stream_);
     RELEASE_ASSERT(result, result.message());
   }
 
   void mergeLoadStats(envoy::service::load_stats::v3::LoadStatsRequest& loadstats_request,
                       envoy::service::load_stats::v3::LoadStatsRequest& local_loadstats_request) {
     // Strip out "load_report" cluster, so that it doesn't interfere with the test.
     for (auto it = local_loadstats_request.mutable_cluster_stats()->begin();
          it != local_loadstats_request.mutable_cluster_stats()->end(); ++it) {
       if (it->cluster_name() == "load_report") {
         local_loadstats_request.mutable_cluster_stats()->erase(it);
         break;
       }
     }
 
     ASSERT_LE(loadstats_request.cluster_stats_size(), 1) << loadstats_request.DebugString();
     ASSERT_LE(local_loadstats_request.cluster_stats_size(), 1)
         << local_loadstats_request.DebugString();
 
     if (local_loadstats_request.cluster_stats_size() == 0) {
       return;
     } else if (loadstats_request.cluster_stats_size() == 0) {
       loadstats_request.CopyFrom(local_loadstats_request);
       ASSERT_TRUE(loadstats_request.has_node());
       ASSERT_FALSE(loadstats_request.node().id().empty());
       ASSERT_FALSE(loadstats_request.node().cluster().empty());
       return;
     }
 
     const auto& local_cluster_stats = local_loadstats_request.cluster_stats(0);
     auto* cluster_stats = loadstats_request.mutable_cluster_stats(0);
 
     cluster_stats->set_total_dropped_requests(cluster_stats->total_dropped_requests() +
                                               local_cluster_stats.total_dropped_requests());
 
     for (int i = 0; i < local_cluster_stats.upstream_locality_stats_size(); ++i) {
       const auto& local_upstream_locality_stats = local_cluster_stats.upstream_locality_stats(i);
       bool copied = false;
       for (int j = 0; j < cluster_stats->upstream_locality_stats_size(); ++j) {
         auto* upstream_locality_stats = cluster_stats->mutable_upstream_locality_stats(j);
         if (TestUtility::protoEqual(upstream_locality_stats->locality(),
                                     local_upstream_locality_stats.locality()) &&
             upstream_locality_stats->priority() == local_upstream_locality_stats.priority()) {
           copied = true;
           upstream_locality_stats->set_total_successful_requests(
               upstream_locality_stats->total_successful_requests() +
               local_upstream_locality_stats.total_successful_requests());
           upstream_locality_stats->set_total_error_requests(
               upstream_locality_stats->total_error_requests() +
               local_upstream_locality_stats.total_error_requests());
           upstream_locality_stats->set_total_issued_requests(
               upstream_locality_stats->total_issued_requests() +
               local_upstream_locality_stats.total_issued_requests());
           // Unlike most stats, current requests in progress replaces old requests in progress.
           break;
         }
       }
       if (!copied) {
         auto* upstream_locality_stats = cluster_stats->add_upstream_locality_stats();
         upstream_locality_stats->CopyFrom(local_upstream_locality_stats);
       }
     }
 
     // Unfortunately because we don't issue an update when total_requests_in_progress goes from
     // non-zero to zero, we have to go through and zero it out for any locality stats we didn't see.
     for (int i = 0; i < cluster_stats->upstream_locality_stats_size(); ++i) {
       auto upstream_locality_stats = cluster_stats->mutable_upstream_locality_stats(i);
       bool found = false;
       for (int j = 0; j < local_cluster_stats.upstream_locality_stats_size(); ++j) {
         auto& local_upstream_locality_stats = local_cluster_stats.upstream_locality_stats(j);
         if (TestUtility::protoEqual(upstream_locality_stats->locality(),
                                     local_upstream_locality_stats.locality()) &&
             upstream_locality_stats->priority() == local_upstream_locality_stats.priority()) {
           found = true;
           break;
         }
       }
       if (!found) {
         upstream_locality_stats->set_total_requests_in_progress(0);
       }
     }
   }
 
   ABSL_MUST_USE_RESULT AssertionResult
   waitForLoadStatsRequest(const std::vector<envoy::config::endpoint::v3::UpstreamLocalityStats>&
                               expected_locality_stats,
                           uint64_t dropped = 0) {
     Event::TestTimeSystem::RealTimeBound bound(TestUtility::DefaultTimeout);
     Protobuf::RepeatedPtrField<envoy::config::endpoint::v3::ClusterStats> expected_cluster_stats;
     if (!expected_locality_stats.empty() || dropped != 0) {
       auto* cluster_stats = expected_cluster_stats.Add();
       cluster_stats->set_cluster_name("cluster_0");
       // Verify the eds service_name is passed back.
       cluster_stats->set_cluster_service_name("service_name_0");
       if (dropped > 0) {
         cluster_stats->set_total_dropped_requests(dropped);
       }
       std::copy(
           expected_locality_stats.begin(), expected_locality_stats.end(),
           Protobuf::RepeatedPtrFieldBackInserter(cluster_stats->mutable_upstream_locality_stats()));
     }
 
     envoy::service::load_stats::v3::LoadStatsRequest loadstats_request;
     // Because multiple load stats may be sent while load in being sent (on slow machines), loop and
     // merge until all the expected load has been reported.
     do {
       envoy::service::load_stats::v3::LoadStatsRequest local_loadstats_request;
       AssertionResult result =
           loadstats_stream_->waitForGrpcMessage(*dispatcher_, local_loadstats_request);
       RELEASE_ASSERT(result, result.message());
       // Check that "envoy.lrs.supports_send_all_clusters" client feature is set.
       if (local_loadstats_request.has_node()) {
         EXPECT_THAT(local_loadstats_request.node().client_features(),
                     ::testing::ElementsAre("envoy.lrs.supports_send_all_clusters"));
       }
       // Sanity check and clear the measured load report interval.
       for (auto& cluster_stats : *local_loadstats_request.mutable_cluster_stats()) {
         const uint32_t actual_load_report_interval_ms =
             Protobuf::util::TimeUtil::DurationToMilliseconds(cluster_stats.load_report_interval());
         // Turns out libevent timers aren't that accurate; without this adjustment we see things
         // like "expected 500, actual 497". Tweak as needed if races are observed.
         EXPECT_GE(actual_load_report_interval_ms, load_report_interval_ms_ - 100);
         // Allow for some skew in test environment.
         EXPECT_LT(actual_load_report_interval_ms, load_report_interval_ms_ + 1000);
         cluster_stats.mutable_load_report_interval()->Clear();
       }
       mergeLoadStats(loadstats_request, local_loadstats_request);
 
       EXPECT_EQ("POST", loadstats_stream_->headers().getMethodValue());
       EXPECT_EQ(
           TestUtility::getVersionedMethodPath("envoy.service.load_stats.{}.LoadReportingService",
                                               "StreamLoadStats", apiVersion()),
           loadstats_stream_->headers().getPathValue());
       EXPECT_EQ("application/grpc", loadstats_stream_->headers().getContentTypeValue());
       if (!bound.withinBound()) {
         return TestUtility::assertRepeatedPtrFieldEqual(expected_cluster_stats,
                                                         loadstats_request.cluster_stats(), true);
       }
     } while (!TestUtility::assertRepeatedPtrFieldEqual(expected_cluster_stats,
                                                        loadstats_request.cluster_stats(), true));
     return testing::AssertionSuccess();
   }
 
   void waitForUpstreamResponse(uint32_t endpoint_index, uint32_t response_code = 200) {
     AssertionResult result = service_upstream_[endpoint_index]->waitForHttpConnection(
         *dispatcher_, fake_upstream_connection_);
     RELEASE_ASSERT(result, result.message());
     result = fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_);
     RELEASE_ASSERT(result, result.message());
     result = upstream_request_->waitForEndStream(*dispatcher_);
     RELEASE_ASSERT(result, result.message());
 
     upstream_request_->encodeHeaders(
         Http::TestResponseHeaderMapImpl{{":status", std::to_string(response_code)}}, false);
     upstream_request_->encodeData(response_size_, true);
     response_->waitForEndStream();
 
     ASSERT_TRUE(upstream_request_->complete());
     EXPECT_EQ(request_size_, upstream_request_->bodyLength());
 
     ASSERT_TRUE(response_->complete());
     EXPECT_EQ(std::to_string(response_code), response_->headers().getStatusValue());
     EXPECT_EQ(response_size_, response_->body().size());
   }
 
   void requestLoadStatsResponse(const std::vector<std::string>& clusters,
                                 bool send_all_clusters = false) {
     envoy::service::load_stats::v3::LoadStatsResponse loadstats_response;
     loadstats_response.mutable_load_reporting_interval()->MergeFrom(
         Protobuf::util::TimeUtil::MillisecondsToDuration(load_report_interval_ms_));
     for (const auto& cluster : clusters) {
       loadstats_response.add_clusters(cluster);
     }
     if (send_all_clusters) {
       loadstats_response.set_send_all_clusters(true);
     }
     loadstats_stream_->sendGrpcMessage(loadstats_response);
     // Wait until the request has been received by Envoy.
     test_server_->waitForCounterGe("load_reporter.requests", ++load_requests_);
   }
 
   envoy::config::endpoint::v3::UpstreamLocalityStats localityStats(const std::string& sub_zone,
                                                                    uint64_t success, uint64_t error,
                                                                    uint64_t active, uint64_t issued,
                                                                    uint32_t priority = 0) {
     envoy::config::endpoint::v3::UpstreamLocalityStats locality_stats;
     auto* locality = locality_stats.mutable_locality();
     locality->set_region("some_region");
     locality->set_zone("zone_name");
     locality->set_sub_zone(sub_zone);
     locality_stats.set_total_successful_requests(success);
     locality_stats.set_total_error_requests(error);
     locality_stats.set_total_requests_in_progress(active);
     locality_stats.set_total_issued_requests(issued);
     locality_stats.set_priority(priority);
     return locality_stats;
   }
 
   void cleanupLoadStatsConnection() {
     if (fake_loadstats_connection_ != nullptr) {
       AssertionResult result = fake_loadstats_connection_->close();
       RELEASE_ASSERT(result, result.message());
       result = fake_loadstats_connection_->waitForDisconnect();
       RELEASE_ASSERT(result, result.message());
     }
   }
 
   void sendAndReceiveUpstream(uint32_t endpoint_index, uint32_t response_code = 200) {
     initiateClientConnection();
     waitForUpstreamResponse(endpoint_index, response_code);
     cleanupUpstreamAndDownstream();
   }
 
   static constexpr uint32_t upstream_endpoints_ = 5;
 
   IntegrationStreamDecoderPtr response_;
   std::string sub_zone_{"winter"};
   FakeHttpConnectionPtr fake_loadstats_connection_;
   FakeStreamPtr loadstats_stream_;
   FakeUpstream* load_report_upstream_{};
   FakeUpstream* service_upstream_[upstream_endpoints_]{};
   uint32_t load_requests_{};
   EdsHelper eds_helper_;
   bool locality_weighted_lb_{};
 
   const uint64_t request_size_ = 1024;
   const uint64_t response_size_ = 512;
   const uint32_t load_report_interval_ms_ = 500;
 };
diff --git a/test/server/server_test.cc b/test/server/server_test.cc
index 5669a56652..162126c25b 100644
--- a/test/server/server_test.cc
+++ b/test/server/server_test.cc
@@ -688,12 +688,30 @@ TEST_P(ServerInstanceImplTest, BootstrapNode) {
 // Validate that bootstrap with v2 dynamic transport is rejected when --bootstrap-version is not
 // set.
 TEST_P(ServerInstanceImplTest,
        DEPRECATED_FEATURE_TEST(FailToLoadV2TransportWithoutExplicitVersion)) {
   EXPECT_THROW_WITH_REGEX(initialize("test/server/test_data/server/dynamic_v2.yaml"),
                           DeprecatedMajorVersionException,
                           "V2 .and AUTO. xDS transport protocol versions are deprecated in.*");
 }
 
+// Validate that bootstrap with v2 ADS transport is rejected when --bootstrap-version is not
+// set.
+TEST_P(ServerInstanceImplTest,
+       DEPRECATED_FEATURE_TEST(FailToLoadV2AdsTransportWithoutExplicitVersion)) {
+  EXPECT_THROW_WITH_REGEX(initialize("test/server/test_data/server/ads_v2.yaml"),
+                          DeprecatedMajorVersionException,
+                          "V2 .and AUTO. xDS transport protocol versions are deprecated in.*");
+}
+
+// Validate that bootstrap with v2 HDS transport is rejected when --bootstrap-version is not
+// set.
+TEST_P(ServerInstanceImplTest,
+       DEPRECATED_FEATURE_TEST(FailToLoadV2HdsTransportWithoutExplicitVersion)) {
+  EXPECT_THROW_WITH_REGEX(initialize("test/server/test_data/server/hds_v2.yaml"),
+                          DeprecatedMajorVersionException,
+                          "V2 .and AUTO. xDS transport protocol versions are deprecated in.*");
+}
+
 // Validate that bootstrap v2 is rejected when --bootstrap-version is not set.
 TEST_P(ServerInstanceImplTest,
        DEPRECATED_FEATURE_TEST(FailToLoadV2BootstrapWithoutExplicitVersion)) {
@@ -828,9 +846,21 @@ TEST_P(ServerInstanceImplTest, DEPRECATED_FEATURE_TEST(FailToLoadV2ConfigWhenV3S
 // Validate that bootstrap with v2 dynamic transport loads when --bootstrap-version is set.
 TEST_P(ServerInstanceImplTest, DEPRECATED_FEATURE_TEST(LoadsV2TransportWithoutExplicitVersion)) {
   options_.bootstrap_version_ = 2;
   initialize("test/server/test_data/server/dynamic_v2.yaml");
 }
 
+// Validate that bootstrap with v2 ADS transport loads when --bootstrap-version is set.
+TEST_P(ServerInstanceImplTest, DEPRECATED_FEATURE_TEST(LoadsV2AdsTransportWithoutExplicitVersion)) {
+  options_.bootstrap_version_ = 2;
+  initialize("test/server/test_data/server/ads_v2.yaml");
+}
+
+// Validate that bootstrap with v2 HDS transport loads when --bootstrap-version is set.
+TEST_P(ServerInstanceImplTest, DEPRECATED_FEATURE_TEST(LoadsV2HdsTransportWithoutExplicitVersion)) {
+  options_.bootstrap_version_ = 2;
+  initialize("test/server/test_data/server/hds_v2.yaml");
+}
+
 // Validate that bootstrap pb_text loads.
 TEST_P(ServerInstanceImplTest, LoadsBootstrapFromPbText) {
   EXPECT_LOG_NOT_CONTAINS("trace", "Configuration does not parse cleanly as v3",
diff --git a/test/server/test_data/server/ads_v2.yaml b/test/server/test_data/server/ads_v2.yaml
new file mode 100644
index 0000000000..03e5693b75
--- /dev/null
+++ b/test/server/test_data/server/ads_v2.yaml
@@ -0,0 +1,14 @@
+node:
+  id: bootstrap_id
+  cluster: bootstrap_cluster
+static_resources:
+  clusters:
+  - name: dummy_cluster
+    connect_timeout: 1s
+dynamic_resources:
+  ads_config:
+    api_type: GRPC
+    transport_api_version: V2
+    grpc_services:
+      envoy_grpc:
+        cluster_name: "dummy_cluster"
diff --git a/test/server/test_data/server/hds_v2.yaml b/test/server/test_data/server/hds_v2.yaml
new file mode 100644
index 0000000000..fb87f8239e
--- /dev/null
+++ b/test/server/test_data/server/hds_v2.yaml
@@ -0,0 +1,13 @@
+node:
+  id: bootstrap_id
+  cluster: bootstrap_cluster
+static_resources:
+  clusters:
+  - name: dummy_cluster
+    connect_timeout: 1s
+hds_config:
+  api_type: GRPC
+  transport_api_version: V2
+  grpc_services:
+    envoy_grpc:
+      cluster_name: "dummy_cluster"
diff --git a/tools/code_format/check_format.py b/tools/code_format/check_format.py
index 7e666ed061..c7b68dba7c 100755
--- a/tools/code_format/check_format.py
+++ b/tools/code_format/check_format.py
@@ -109,11 +109,16 @@ GRPC_INIT_ALLOWLIST = ("./source/common/grpc/google_grpc_context.cc")
 # These files should not throw exceptions. Add HTTP/1 when exceptions removed.
 EXCEPTION_DENYLIST = ("./source/common/http/http2/codec_impl.h",
                       "./source/common/http/http2/codec_impl.cc")
 
+# Header files that can throw exceptions. These should be limited; the only
+# valid situation identified so far is template functions used for config
+# processing.
+EXCEPTION_ALLOWLIST = ("./source/common/config/utility.h")
+
 # We want all URL references to exist in repository_locations.bzl files and have
 # metadata that conforms to the schema in ./api/bazel/external_deps.bzl. Below
 # we have some exceptions for either infrastructure files or places we fall
 # short today (Rust).
 #
 # Please DO NOT extend this allow list without consulting
 # @envoyproxy/dependency-shepherds.
@@ -240,828 +245,828 @@ UNOWNED_EXTENSIONS = {
 class FormatChecker:
 
   def __init__(self, args):
     self.operation_type = args.operation_type
     self.target_path = args.target_path
     self.api_prefix = args.api_prefix
     self.api_shadow_root = args.api_shadow_prefix
     self.envoy_build_rule_check = not args.skip_envoy_build_rule_check
     self.namespace_check = args.namespace_check
     self.namespace_check_excluded_paths = args.namespace_check_excluded_paths + [
         "./tools/api_boost/testdata/",
         "./tools/clang_tools/",
     ]
     self.build_fixer_check_excluded_paths = args.build_fixer_check_excluded_paths + [
         "./bazel/external/",
         "./bazel/toolchains/",
         "./bazel/BUILD",
         "./tools/clang_tools",
     ]
     self.include_dir_order = args.include_dir_order
 
   # Map a line transformation function across each line of a file,
   # writing the result lines as requested.
   # If there is a clang format nesting or mismatch error, return the first occurrence
   def evaluateLines(self, path, line_xform, write=True):
     error_message = None
     format_flag = True
     output_lines = []
     for line_number, line in enumerate(self.readLines(path)):
       if line.find("// clang-format off") != -1:
         if not format_flag and error_message is None:
           error_message = "%s:%d: %s" % (path, line_number + 1, "clang-format nested off")
         format_flag = False
       if line.find("// clang-format on") != -1:
         if format_flag and error_message is None:
           error_message = "%s:%d: %s" % (path, line_number + 1, "clang-format nested on")
         format_flag = True
       if format_flag:
         output_lines.append(line_xform(line, line_number))
       else:
         output_lines.append(line)
     # We used to use fileinput in the older Python 2.7 script, but this doesn't do
     # inplace mode and UTF-8 in Python 3, so doing it the manual way.
     if write:
       pathlib.Path(path).write_text('\n'.join(output_lines), encoding='utf-8')
     if not format_flag and error_message is None:
       error_message = "%s:%d: %s" % (path, line_number + 1, "clang-format remains off")
     return error_message
 
   # Obtain all the lines in a given file.
   def readLines(self, path):
     return self.readFile(path).split('\n')
 
   # Read a UTF-8 encoded file as a str.
   def readFile(self, path):
     return pathlib.Path(path).read_text(encoding='utf-8')
 
   # lookPath searches for the given executable in all directories in PATH
   # environment variable. If it cannot be found, empty string is returned.
   def lookPath(self, executable):
     return shutil.which(executable) or ''
 
   # pathExists checks whether the given path exists. This function assumes that
   # the path is absolute and evaluates environment variables.
   def pathExists(self, executable):
     return os.path.exists(os.path.expandvars(executable))
 
   # executableByOthers checks whether the given path has execute permission for
   # others.
   def executableByOthers(self, executable):
     st = os.stat(os.path.expandvars(executable))
     return bool(st.st_mode & stat.S_IXOTH)
 
   # Check whether all needed external tools (clang-format, buildifier, buildozer) are
   # available.
   def checkTools(self):
     error_messages = []
 
     clang_format_abs_path = self.lookPath(CLANG_FORMAT_PATH)
     if clang_format_abs_path:
       if not self.executableByOthers(clang_format_abs_path):
         error_messages.append("command {} exists, but cannot be executed by other "
                               "users".format(CLANG_FORMAT_PATH))
     else:
       error_messages.append(
           "Command {} not found. If you have clang-format in version 10.x.x "
           "installed, but the binary name is different or it's not available in "
           "PATH, please use CLANG_FORMAT environment variable to specify the path. "
           "Examples:\n"
           "    export CLANG_FORMAT=clang-format-10.0.0\n"
           "    export CLANG_FORMAT=/opt/bin/clang-format-10\n"
           "    export CLANG_FORMAT=/usr/local/opt/llvm@10/bin/clang-format".format(
               CLANG_FORMAT_PATH))
 
     def checkBazelTool(name, path, var):
       bazel_tool_abs_path = self.lookPath(path)
       if bazel_tool_abs_path:
         if not self.executableByOthers(bazel_tool_abs_path):
           error_messages.append("command {} exists, but cannot be executed by other "
                                 "users".format(path))
       elif self.pathExists(path):
         if not self.executableByOthers(path):
           error_messages.append("command {} exists, but cannot be executed by other "
                                 "users".format(path))
       else:
 
         error_messages.append("Command {} not found. If you have {} installed, but the binary "
                               "name is different or it's not available in $GOPATH/bin, please use "
                               "{} environment variable to specify the path. Example:\n"
                               "    export {}=`which {}`\n"
                               "If you don't have {} installed, you can install it by:\n"
                               "    go get -u github.com/bazelbuild/buildtools/{}".format(
                                   path, name, var, var, name, name, name))
 
     checkBazelTool('buildifier', BUILDIFIER_PATH, 'BUILDIFIER_BIN')
     checkBazelTool('buildozer', BUILDOZER_PATH, 'BUILDOZER_BIN')
 
     return error_messages
 
   def checkNamespace(self, file_path):
     for excluded_path in self.namespace_check_excluded_paths:
       if file_path.startswith(excluded_path):
         return []
 
     nolint = "NOLINT(namespace-%s)" % self.namespace_check.lower()
     text = self.readFile(file_path)
     if not re.search("^\s*namespace\s+%s\s*{" % self.namespace_check, text, re.MULTILINE) and \
       not nolint in text:
       return [
           "Unable to find %s namespace or %s for file: %s" %
           (self.namespace_check, nolint, file_path)
       ]
     return []
 
   def packageNameForProto(self, file_path):
     package_name = None
     error_message = []
     result = PROTO_PACKAGE_REGEX.search(self.readFile(file_path))
     if result is not None and len(result.groups()) == 1:
       package_name = result.group(1)
     if package_name is None:
       error_message = ["Unable to find package name for proto file: %s" % file_path]
 
     return [package_name, error_message]
 
   # To avoid breaking the Lyft import, we just check for path inclusion here.
   def allowlistedForProtobufDeps(self, file_path):
     return (file_path.endswith(PROTO_SUFFIX) or file_path.endswith(REPOSITORIES_BZL) or \
             any(path_segment in file_path for path_segment in GOOGLE_PROTOBUF_ALLOWLIST))
 
   # Real-world time sources should not be instantiated in the source, except for a few
   # specific cases. They should be passed down from where they are instantied to where
   # they need to be used, e.g. through the ServerInstance, Dispatcher, or ClusterManager.
   def allowlistedForRealTime(self, file_path):
     if file_path.endswith(".md"):
       return True
     return file_path in REAL_TIME_ALLOWLIST
 
   def allowlistedForRegisterFactory(self, file_path):
     if not file_path.startswith("./test/"):
       return True
 
     return any(file_path.startswith(prefix) for prefix in REGISTER_FACTORY_TEST_ALLOWLIST)
 
   def allowlistedForSerializeAsString(self, file_path):
     return file_path in SERIALIZE_AS_STRING_ALLOWLIST or file_path.endswith(DOCS_SUFFIX)
 
   def allowlistedForJsonStringToMessage(self, file_path):
     return file_path in JSON_STRING_TO_MESSAGE_ALLOWLIST
 
   def allowlistedForHistogramSiSuffix(self, name):
     return name in HISTOGRAM_WITH_SI_SUFFIX_ALLOWLIST
 
   def allowlistedForStdRegex(self, file_path):
     return file_path.startswith("./test") or file_path in STD_REGEX_ALLOWLIST or file_path.endswith(
         DOCS_SUFFIX)
 
   def allowlistedForGrpcInit(self, file_path):
     return file_path in GRPC_INIT_ALLOWLIST
 
   def allowlistedForUnpackTo(self, file_path):
     return file_path.startswith("./test") or file_path in [
         "./source/common/protobuf/utility.cc", "./source/common/protobuf/utility.h"
     ]
 
   def denylistedForExceptions(self, file_path):
     # Returns true when it is a non test header file or the file_path is in DENYLIST or
-    # it is under toos/testdata subdirectory.
+    # it is under tools/testdata subdirectory.
     if file_path.endswith(DOCS_SUFFIX):
       return False
 
-    return (file_path.endswith('.h') and not file_path.startswith("./test/")) or file_path in EXCEPTION_DENYLIST \
+    return (file_path.endswith('.h') and not file_path.startswith("./test/") and not file_path in EXCEPTION_ALLOWLIST) or file_path in EXCEPTION_DENYLIST \
         or self.isInSubdir(file_path, 'tools/testdata')
 
   def allowlistedForBuildUrls(self, file_path):
     return file_path in BUILD_URLS_ALLOWLIST
 
   def isApiFile(self, file_path):
     return file_path.startswith(self.api_prefix) or file_path.startswith(self.api_shadow_root)
 
   def isBuildFile(self, file_path):
     basename = os.path.basename(file_path)
     if basename in {"BUILD", "BUILD.bazel"} or basename.endswith(".BUILD"):
       return True
     return False
 
   def isExternalBuildFile(self, file_path):
     return self.isBuildFile(file_path) and (file_path.startswith("./bazel/external/") or
                                             file_path.startswith("./tools/clang_tools"))
 
   def isStarlarkFile(self, file_path):
     return file_path.endswith(".bzl")
 
   def isWorkspaceFile(self, file_path):
     return os.path.basename(file_path) == "WORKSPACE"
 
   def isBuildFixerExcludedFile(self, file_path):
     for excluded_path in self.build_fixer_check_excluded_paths:
       if file_path.startswith(excluded_path):
         return True
     return False
 
   def hasInvalidAngleBracketDirectory(self, line):
     if not line.startswith(INCLUDE_ANGLE):
       return False
     path = line[INCLUDE_ANGLE_LEN:]
     slash = path.find("/")
     if slash == -1:
       return False
     subdir = path[0:slash]
     return subdir in SUBDIR_SET
 
   def checkCurrentReleaseNotes(self, file_path, error_messages):
     first_word_of_prior_line = ''
     next_word_to_check = ''  # first word after :
     prior_line = ''
 
     def endsWithPeriod(prior_line):
       if not prior_line:
         return True  # Don't punctuation-check empty lines.
       if prior_line.endswith('.'):
         return True  # Actually ends with .
       if prior_line.endswith('`') and REF_WITH_PUNCTUATION_REGEX.match(prior_line):
         return True  # The text in the :ref ends with a .
       return False
 
     for line_number, line in enumerate(self.readLines(file_path)):
 
       def reportError(message):
         error_messages.append("%s:%d: %s" % (file_path, line_number + 1, message))
 
       if VERSION_HISTORY_SECTION_NAME.match(line):
         if line == "Deprecated":
           # The deprecations section is last, and does not have enforced formatting.
           break
 
         # Reset all parsing at the start of a section.
         first_word_of_prior_line = ''
         next_word_to_check = ''  # first word after :
         prior_line = ''
 
       invalid_reflink_match = INVALID_REFLINK.match(line)
       if invalid_reflink_match:
         reportError("Found text \" ref:\". This should probably be \" :ref:\"\n%s" % line)
 
       # make sure flags are surrounded by ``s
       flag_match = RELOADABLE_FLAG_REGEX.match(line)
       if flag_match:
         if not flag_match.groups()[0].startswith(' `'):
           reportError("Flag `%s` should be enclosed in a single set of back ticks" %
                       flag_match.groups()[1])
 
       if line.startswith("* "):
         if not endsWithPeriod(prior_line):
           reportError("The following release note does not end with a '.'\n %s" % prior_line)
 
         match = VERSION_HISTORY_NEW_LINE_REGEX.match(line)
         if not match:
           reportError("Version history line malformed. "
                       "Does not match VERSION_HISTORY_NEW_LINE_REGEX in check_format.py\n %s" %
                       line)
         else:
           first_word = match.groups()[0]
           next_word = match.groups()[1]
           # Do basic alphabetization checks of the first word on the line and the
           # first word after the :
           if first_word_of_prior_line and first_word_of_prior_line > first_word:
             reportError(
                 "Version history not in alphabetical order (%s vs %s): please check placement of line\n %s. "
                 % (first_word_of_prior_line, first_word, line))
           if first_word_of_prior_line == first_word and next_word_to_check and next_word_to_check > next_word:
             reportError(
                 "Version history not in alphabetical order (%s vs %s): please check placement of line\n %s. "
                 % (next_word_to_check, next_word, line))
           first_word_of_prior_line = first_word
           next_word_to_check = next_word
 
           prior_line = line
       elif not line:
         # If we hit the end of this release note block block, check the prior line.
         if not endsWithPeriod(prior_line):
           reportError("The following release note does not end with a '.'\n %s" % prior_line)
       elif prior_line:
         prior_line += line
 
   def checkFileContents(self, file_path, checker):
     error_messages = []
 
     if file_path.endswith("version_history/current.rst"):
       # Version file checking has enough special cased logic to merit its own checks.
       # This only validates entries for the current release as very old release
       # notes have a different format.
       self.checkCurrentReleaseNotes(file_path, error_messages)
 
     def checkFormatErrors(line, line_number):
 
       def reportError(message):
         error_messages.append("%s:%d: %s" % (file_path, line_number + 1, message))
 
       checker(line, file_path, reportError)
 
     evaluate_failure = self.evaluateLines(file_path, checkFormatErrors, False)
     if evaluate_failure is not None:
       error_messages.append(evaluate_failure)
 
     return error_messages
 
   def fixSourceLine(self, line, line_number):
     # Strip double space after '.'  This may prove overenthusiastic and need to
     # be restricted to comments and metadata files but works for now.
     line = re.sub(DOT_MULTI_SPACE_REGEX, ". ", line)
 
     if self.hasInvalidAngleBracketDirectory(line):
       line = line.replace("<", '"').replace(">", '"')
 
     # Fix incorrect protobuf namespace references.
     for invalid_construct, valid_construct in PROTOBUF_TYPE_ERRORS.items():
       line = line.replace(invalid_construct, valid_construct)
 
     # Use recommended cpp stdlib
     for invalid_construct, valid_construct in LIBCXX_REPLACEMENTS.items():
       line = line.replace(invalid_construct, valid_construct)
 
     # Fix code conventions violations.
     for invalid_construct, valid_construct in CODE_CONVENTION_REPLACEMENTS.items():
       line = line.replace(invalid_construct, valid_construct)
 
     return line
 
   # We want to look for a call to condvar.waitFor, but there's no strong pattern
   # to the variable name of the condvar. If we just look for ".waitFor" we'll also
   # pick up time_system_.waitFor(...), and we don't want to return true for that
   # pattern. But in that case there is a strong pattern of using time_system in
   # various spellings as the variable name.
   def hasCondVarWaitFor(self, line):
     wait_for = line.find(".waitFor(")
     if wait_for == -1:
       return False
     preceding = line[0:wait_for]
     if preceding.endswith("time_system") or preceding.endswith("timeSystem()") or \
       preceding.endswith("time_system_"):
       return False
     return True
 
   # Determines whether the filename is either in the specified subdirectory, or
   # at the top level. We consider files in the top level for the benefit of
   # the check_format testcases in tools/testdata/check_format.
   def isInSubdir(self, filename, *subdirs):
     # Skip this check for check_format's unit-tests.
     if filename.count("/") <= 1:
       return True
     for subdir in subdirs:
       if filename.startswith('./' + subdir + '/'):
         return True
     return False
 
   # Determines if given token exists in line without leading or trailing token characters
   # e.g. will return True for a line containing foo() but not foo_bar() or baz_foo
   def tokenInLine(self, token, line):
     index = 0
     while True:
       index = line.find(token, index)
       # the following check has been changed from index < 1 to index < 0 because
       # this function incorrectly returns false when the token in question is the
       # first one in a line. The following line returns false when the token is present:
       # (no leading whitespace) violating_symbol foo;
       if index < 0:
         break
       if index == 0 or not (line[index - 1].isalnum() or line[index - 1] == '_'):
         if index + len(token) >= len(line) or not (line[index + len(token)].isalnum() or
                                                    line[index + len(token)] == '_'):
           return True
       index = index + 1
     return False
 
   def checkSourceLine(self, line, file_path, reportError):
     # Check fixable errors. These may have been fixed already.
     if line.find(".  ") != -1:
       reportError("over-enthusiastic spaces")
     if self.isInSubdir(file_path, 'source', 'include') and X_ENVOY_USED_DIRECTLY_REGEX.match(line):
       reportError(
           "Please do not use the raw literal x-envoy in source code.  See Envoy::Http::PrefixValue."
       )
     if self.hasInvalidAngleBracketDirectory(line):
       reportError("envoy includes should not have angle brackets")
     for invalid_construct, valid_construct in PROTOBUF_TYPE_ERRORS.items():
       if invalid_construct in line:
         reportError("incorrect protobuf type reference %s; "
                     "should be %s" % (invalid_construct, valid_construct))
     for invalid_construct, valid_construct in LIBCXX_REPLACEMENTS.items():
       if invalid_construct in line:
         reportError("term %s should be replaced with standard library term %s" %
                     (invalid_construct, valid_construct))
     for invalid_construct, valid_construct in CODE_CONVENTION_REPLACEMENTS.items():
       if invalid_construct in line:
         reportError("term %s should be replaced with preferred term %s" %
                     (invalid_construct, valid_construct))
     # Do not include the virtual_includes headers.
     if re.search("#include.*/_virtual_includes/", line):
       reportError("Don't include the virtual includes headers.")
 
     # Some errors cannot be fixed automatically, and actionable, consistent,
     # navigable messages should be emitted to make it easy to find and fix
     # the errors by hand.
     if not self.allowlistedForProtobufDeps(file_path):
       if '"google/protobuf' in line or "google::protobuf" in line:
         reportError("unexpected direct dependency on google.protobuf, use "
                     "the definitions in common/protobuf/protobuf.h instead.")
     if line.startswith("#include <mutex>") or line.startswith("#include <condition_variable"):
       # We don't check here for std::mutex because that may legitimately show up in
       # comments, for example this one.
       reportError("Don't use <mutex> or <condition_variable*>, switch to "
                   "Thread::MutexBasicLockable in source/common/common/thread.h")
     if line.startswith("#include <shared_mutex>"):
       # We don't check here for std::shared_timed_mutex because that may
       # legitimately show up in comments, for example this one.
       reportError("Don't use <shared_mutex>, use absl::Mutex for reader/writer locks.")
     if not self.allowlistedForRealTime(file_path) and not "NO_CHECK_FORMAT(real_time)" in line:
       if "RealTimeSource" in line or \
         ("RealTimeSystem" in line and not "TestRealTimeSystem" in line) or \
         "std::chrono::system_clock::now" in line or "std::chrono::steady_clock::now" in line or \
         "std::this_thread::sleep_for" in line or self.hasCondVarWaitFor(line):
         reportError("Don't reference real-world time sources from production code; use injection")
     duration_arg = DURATION_VALUE_REGEX.search(line)
     if duration_arg and duration_arg.group(1) != "0" and duration_arg.group(1) != "0.0":
       # Matching duration(int-const or float-const) other than zero
       reportError(
           "Don't use ambiguous duration(value), use an explicit duration type, e.g. Event::TimeSystem::Milliseconds(value)"
       )
     if not self.allowlistedForRegisterFactory(file_path):
       if "Registry::RegisterFactory<" in line or "REGISTER_FACTORY" in line:
         reportError("Don't use Registry::RegisterFactory or REGISTER_FACTORY in tests, "
                     "use Registry::InjectFactory instead.")
     if not self.allowlistedForUnpackTo(file_path):
       if "UnpackTo" in line:
         reportError("Don't use UnpackTo() directly, use MessageUtil::unpackTo() instead")
     # Check that we use the absl::Time library
     if self.tokenInLine("std::get_time", line):
       if "test/" in file_path:
         reportError("Don't use std::get_time; use TestUtility::parseTime in tests")
       else:
         reportError("Don't use std::get_time; use the injectable time system")
     if self.tokenInLine("std::put_time", line):
       reportError("Don't use std::put_time; use absl::Time equivalent instead")
     if self.tokenInLine("gmtime", line):
       reportError("Don't use gmtime; use absl::Time equivalent instead")
     if self.tokenInLine("mktime", line):
       reportError("Don't use mktime; use absl::Time equivalent instead")
     if self.tokenInLine("localtime", line):
       reportError("Don't use localtime; use absl::Time equivalent instead")
     if self.tokenInLine("strftime", line):
       reportError("Don't use strftime; use absl::FormatTime instead")
     if self.tokenInLine("strptime", line):
       reportError("Don't use strptime; use absl::FormatTime instead")
     if self.tokenInLine("strerror", line):
       reportError("Don't use strerror; use Envoy::errorDetails instead")
     # Prefer using abseil hash maps/sets over std::unordered_map/set for performance optimizations and
     # non-deterministic iteration order that exposes faulty assertions.
     # See: https://abseil.io/docs/cpp/guides/container#hash-tables
     if "std::unordered_map" in line:
       reportError("Don't use std::unordered_map; use absl::flat_hash_map instead or "
                   "absl::node_hash_map if pointer stability of keys/values is required")
     if "std::unordered_set" in line:
       reportError("Don't use std::unordered_set; use absl::flat_hash_set instead or "
                   "absl::node_hash_set if pointer stability of keys/values is required")
     if "std::atomic_" in line:
       # The std::atomic_* free functions are functionally equivalent to calling
       # operations on std::atomic<T> objects, so prefer to use that instead.
       reportError("Don't use free std::atomic_* functions, use std::atomic<T> members instead.")
     # Block usage of certain std types/functions as iOS 11 and macOS 10.13
     # do not support these at runtime.
     # See: https://github.com/envoyproxy/envoy/issues/12341
     if self.tokenInLine("std::any", line):
       reportError("Don't use std::any; use absl::any instead")
     if self.tokenInLine("std::get_if", line):
       reportError("Don't use std::get_if; use absl::get_if instead")
     if self.tokenInLine("std::holds_alternative", line):
       reportError("Don't use std::holds_alternative; use absl::holds_alternative instead")
     if self.tokenInLine("std::make_optional", line):
       reportError("Don't use std::make_optional; use absl::make_optional instead")
     if self.tokenInLine("std::monostate", line):
       reportError("Don't use std::monostate; use absl::monostate instead")
     if self.tokenInLine("std::optional", line):
       reportError("Don't use std::optional; use absl::optional instead")
     if self.tokenInLine("std::string_view", line):
       reportError("Don't use std::string_view; use absl::string_view instead")
     if self.tokenInLine("std::variant", line):
       reportError("Don't use std::variant; use absl::variant instead")
     if self.tokenInLine("std::visit", line):
       reportError("Don't use std::visit; use absl::visit instead")
     if "__attribute__((packed))" in line and file_path != "./include/envoy/common/platform.h":
       # __attribute__((packed)) is not supported by MSVC, we have a PACKED_STRUCT macro that
       # can be used instead
       reportError("Don't use __attribute__((packed)), use the PACKED_STRUCT macro defined "
                   "in include/envoy/common/platform.h instead")
     if DESIGNATED_INITIALIZER_REGEX.search(line):
       # Designated initializers are not part of the C++14 standard and are not supported
       # by MSVC
       reportError("Don't use designated initializers in struct initialization, "
                   "they are not part of C++14")
     if " ?: " in line:
       # The ?: operator is non-standard, it is a GCC extension
       reportError("Don't use the '?:' operator, it is a non-standard GCC extension")
     if line.startswith("using testing::Test;"):
       reportError("Don't use 'using testing::Test;, elaborate the type instead")
     if line.startswith("using testing::TestWithParams;"):
       reportError("Don't use 'using testing::Test;, elaborate the type instead")
     if TEST_NAME_STARTING_LOWER_CASE_REGEX.search(line):
       # Matches variants of TEST(), TEST_P(), TEST_F() etc. where the test name begins
       # with a lowercase letter.
       reportError("Test names should be CamelCase, starting with a capital letter")
     if not self.allowlistedForSerializeAsString(file_path) and "SerializeAsString" in line:
       # The MessageLite::SerializeAsString doesn't generate deterministic serialization,
       # use MessageUtil::hash instead.
       reportError(
           "Don't use MessageLite::SerializeAsString for generating deterministic serialization, use MessageUtil::hash instead."
       )
     if not self.allowlistedForJsonStringToMessage(file_path) and "JsonStringToMessage" in line:
       # Centralize all usage of JSON parsing so it is easier to make changes in JSON parsing
       # behavior.
       reportError("Don't use Protobuf::util::JsonStringToMessage, use TestUtility::loadFromJson.")
 
     if self.isInSubdir(file_path, 'source') and file_path.endswith('.cc') and \
       ('.counterFromString(' in line or '.gaugeFromString(' in line or \
         '.histogramFromString(' in line or '.textReadoutFromString(' in line or \
         '->counterFromString(' in line or '->gaugeFromString(' in line or \
         '->histogramFromString(' in line or '->textReadoutFromString(' in line):
       reportError("Don't lookup stats by name at runtime; use StatName saved during construction")
 
     if MANGLED_PROTOBUF_NAME_REGEX.search(line):
       reportError("Don't use mangled Protobuf names for enum constants")
 
     hist_m = HISTOGRAM_SI_SUFFIX_REGEX.search(line)
     if hist_m and not self.allowlistedForHistogramSiSuffix(hist_m.group(0)):
       reportError(
           "Don't suffix histogram names with the unit symbol, "
           "it's already part of the histogram object and unit-supporting sinks can use this information natively, "
           "other sinks can add the suffix automatically on flush should they prefer to do so.")
 
     if not self.allowlistedForStdRegex(file_path) and "std::regex" in line:
       reportError("Don't use std::regex in code that handles untrusted input. Use RegexMatcher")
 
     if not self.allowlistedForGrpcInit(file_path):
       grpc_init_or_shutdown = line.find("grpc_init()")
       grpc_shutdown = line.find("grpc_shutdown()")
       if grpc_init_or_shutdown == -1 or (grpc_shutdown != -1 and
                                          grpc_shutdown < grpc_init_or_shutdown):
         grpc_init_or_shutdown = grpc_shutdown
       if grpc_init_or_shutdown != -1:
         comment = line.find("// ")
         if comment == -1 or comment > grpc_init_or_shutdown:
           reportError("Don't call grpc_init() or grpc_shutdown() directly, instantiate " +
                       "Grpc::GoogleGrpcContext. See #8282")
 
     if self.denylistedForExceptions(file_path):
       # Skpping cases where 'throw' is a substring of a symbol like in "foothrowBar".
       if "throw" in line.split():
         comment_match = COMMENT_REGEX.search(line)
         if comment_match is None or comment_match.start(0) > line.find("throw"):
           reportError("Don't introduce throws into exception-free files, use error " +
                       "statuses instead.")
 
     if "lua_pushlightuserdata" in line:
       reportError(
           "Don't use lua_pushlightuserdata, since it can cause unprotected error in call to" +
           "Lua API (bad light userdata pointer) on ARM64 architecture. See " +
           "https://github.com/LuaJIT/LuaJIT/issues/450#issuecomment-433659873 for details.")
 
     if file_path.endswith(PROTO_SUFFIX):
       exclude_path = ['v1', 'v2', 'generated_api_shadow']
       result = PROTO_VALIDATION_STRING.search(line)
       if result is not None:
         if not any(x in file_path for x in exclude_path):
           reportError("min_bytes is DEPRECATED, Use min_len.")
 
   def checkBuildLine(self, line, file_path, reportError):
     if "@bazel_tools" in line and not (self.isStarlarkFile(file_path) or
                                        file_path.startswith("./bazel/") or
                                        "python/runfiles" in line):
       reportError("unexpected @bazel_tools reference, please indirect via a definition in //bazel")
     if not self.allowlistedForProtobufDeps(file_path) and '"protobuf"' in line:
       reportError("unexpected direct external dependency on protobuf, use "
                   "//source/common/protobuf instead.")
     if (self.envoy_build_rule_check and not self.isStarlarkFile(file_path) and
         not self.isWorkspaceFile(file_path) and not self.isExternalBuildFile(file_path) and
         "@envoy//" in line):
       reportError("Superfluous '@envoy//' prefix")
     if not self.allowlistedForBuildUrls(file_path) and (" urls = " in line or " url = " in line):
       reportError("Only repository_locations.bzl may contains URL references")
 
   def fixBuildLine(self, file_path, line, line_number):
     if (self.envoy_build_rule_check and not self.isStarlarkFile(file_path) and
         not self.isWorkspaceFile(file_path) and not self.isExternalBuildFile(file_path)):
       line = line.replace("@envoy//", "//")
     return line
 
   def fixBuildPath(self, file_path):
     self.evaluateLines(file_path, functools.partial(self.fixBuildLine, file_path))
 
     error_messages = []
 
     # TODO(htuch): Add API specific BUILD fixer script.
     if not self.isBuildFixerExcludedFile(file_path) and not self.isApiFile(
         file_path) and not self.isStarlarkFile(file_path) and not self.isWorkspaceFile(file_path):
       if os.system("%s %s %s" % (ENVOY_BUILD_FIXER_PATH, file_path, file_path)) != 0:
         error_messages += ["envoy_build_fixer rewrite failed for file: %s" % file_path]
 
     if os.system("%s -lint=fix -mode=fix %s" % (BUILDIFIER_PATH, file_path)) != 0:
       error_messages += ["buildifier rewrite failed for file: %s" % file_path]
     return error_messages
 
   def checkBuildPath(self, file_path):
     error_messages = []
 
     if not self.isBuildFixerExcludedFile(file_path) and not self.isApiFile(
         file_path) and not self.isStarlarkFile(file_path) and not self.isWorkspaceFile(file_path):
       command = "%s %s | diff %s -" % (ENVOY_BUILD_FIXER_PATH, file_path, file_path)
       error_messages += self.executeCommand(command, "envoy_build_fixer check failed", file_path)
 
     if self.isBuildFile(file_path) and (file_path.startswith(self.api_prefix + "envoy") or
                                         file_path.startswith(self.api_shadow_root + "envoy")):
       found = False
       for line in self.readLines(file_path):
         if "api_proto_package(" in line:
           found = True
           break
       if not found:
         error_messages += ["API build file does not provide api_proto_package()"]
 
     command = "%s -mode=diff %s" % (BUILDIFIER_PATH, file_path)
     error_messages += self.executeCommand(command, "buildifier check failed", file_path)
     error_messages += self.checkFileContents(file_path, self.checkBuildLine)
     return error_messages
 
   def fixSourcePath(self, file_path):
     self.evaluateLines(file_path, self.fixSourceLine)
 
     error_messages = []
 
     if not file_path.endswith(DOCS_SUFFIX):
       if not file_path.endswith(PROTO_SUFFIX):
         error_messages += self.fixHeaderOrder(file_path)
       error_messages += self.clangFormat(file_path)
     if file_path.endswith(PROTO_SUFFIX) and self.isApiFile(file_path):
       package_name, error_message = self.packageNameForProto(file_path)
       if package_name is None:
         error_messages += error_message
     return error_messages
 
   def checkSourcePath(self, file_path):
     error_messages = self.checkFileContents(file_path, self.checkSourceLine)
 
     if not file_path.endswith(DOCS_SUFFIX):
       if not file_path.endswith(PROTO_SUFFIX):
         error_messages += self.checkNamespace(file_path)
         command = ("%s --include_dir_order %s --path %s | diff %s -" %
                    (HEADER_ORDER_PATH, self.include_dir_order, file_path, file_path))
         error_messages += self.executeCommand(command, "header_order.py check failed", file_path)
       command = ("%s %s | diff %s -" % (CLANG_FORMAT_PATH, file_path, file_path))
       error_messages += self.executeCommand(command, "clang-format check failed", file_path)
 
     if file_path.endswith(PROTO_SUFFIX) and self.isApiFile(file_path):
       package_name, error_message = self.packageNameForProto(file_path)
       if package_name is None:
         error_messages += error_message
     return error_messages
 
   # Example target outputs are:
   #   - "26,27c26"
   #   - "12,13d13"
   #   - "7a8,9"
   def executeCommand(self,
                      command,
                      error_message,
                      file_path,
                      regex=re.compile(r"^(\d+)[a|c|d]?\d*(?:,\d+[a|c|d]?\d*)?$")):
     try:
       output = subprocess.check_output(command, shell=True, stderr=subprocess.STDOUT).strip()
       if output:
         return output.decode('utf-8').split("\n")
       return []
     except subprocess.CalledProcessError as e:
       if (e.returncode != 0 and e.returncode != 1):
         return ["ERROR: something went wrong while executing: %s" % e.cmd]
       # In case we can't find any line numbers, record an error message first.
       error_messages = ["%s for file: %s" % (error_message, file_path)]
       for line in e.output.decode('utf-8').splitlines():
         for num in regex.findall(line):
           error_messages.append("  %s:%s" % (file_path, num))
       return error_messages
 
   def fixHeaderOrder(self, file_path):
     command = "%s --rewrite --include_dir_order %s --path %s" % (HEADER_ORDER_PATH,
                                                                  self.include_dir_order, file_path)
     if os.system(command) != 0:
       return ["header_order.py rewrite error: %s" % (file_path)]
     return []
 
   def clangFormat(self, file_path):
     command = "%s -i %s" % (CLANG_FORMAT_PATH, file_path)
     if os.system(command) != 0:
       return ["clang-format rewrite error: %s" % (file_path)]
     return []
 
   def checkFormat(self, file_path):
     if file_path.startswith(EXCLUDED_PREFIXES):
       return []
 
     if not file_path.endswith(SUFFIXES):
       return []
 
     error_messages = []
     # Apply fixes first, if asked, and then run checks. If we wind up attempting to fix
     # an issue, but there's still an error, that's a problem.
     try_to_fix = self.operation_type == "fix"
     if self.isBuildFile(file_path) or self.isStarlarkFile(file_path) or self.isWorkspaceFile(
         file_path):
       if try_to_fix:
         error_messages += self.fixBuildPath(file_path)
       error_messages += self.checkBuildPath(file_path)
     else:
       if try_to_fix:
         error_messages += self.fixSourcePath(file_path)
       error_messages += self.checkSourcePath(file_path)
 
     if error_messages:
       return ["From %s" % file_path] + error_messages
     return error_messages
 
   def checkFormatReturnTraceOnError(self, file_path):
     """Run checkFormat and return the traceback of any exception."""
     try:
       return self.checkFormat(file_path)
     except:
       return traceback.format_exc().split("\n")
 
   def checkOwners(self, dir_name, owned_directories, error_messages):
     """Checks to make sure a given directory is present either in CODEOWNERS or OWNED_EXTENSIONS
     Args:
       dir_name: the directory being checked.
       owned_directories: directories currently listed in CODEOWNERS.
       error_messages: where to put an error message for new unowned directories.
     """
     found = False
     for owned in owned_directories:
       if owned.startswith(dir_name) or dir_name.startswith(owned):
         found = True
     if not found and dir_name not in UNOWNED_EXTENSIONS:
       error_messages.append("New directory %s appears to not have owners in CODEOWNERS" % dir_name)
 
   def checkApiShadowStarlarkFiles(self, file_path, error_messages):
     command = "diff -u "
     command += file_path + " "
     api_shadow_starlark_path = self.api_shadow_root + re.sub(r"\./api/", '', file_path)
     command += api_shadow_starlark_path
 
     error_message = self.executeCommand(command, "invalid .bzl in generated_api_shadow", file_path)
     if self.operation_type == "check":
       error_messages += error_message
     elif self.operation_type == "fix" and len(error_message) != 0:
       shutil.copy(file_path, api_shadow_starlark_path)
 
     return error_messages
 
   def checkFormatVisitor(self, arg, dir_name, names):
     """Run checkFormat in parallel for the given files.
     Args:
       arg: a tuple (pool, result_list, owned_directories, error_messages)
         pool and result_list are for starting tasks asynchronously.
         owned_directories tracks directories listed in the CODEOWNERS file.
         error_messages is a list of string format errors.
       dir_name: the parent directory of the given files.
       names: a list of file names.
     """
 
     # Unpack the multiprocessing.Pool process pool and list of results. Since
     # python lists are passed as references, this is used to collect the list of
     # async results (futures) from running checkFormat and passing them back to
     # the caller.
     pool, result_list, owned_directories, error_messages = arg
 
     # Sanity check CODEOWNERS.  This doesn't need to be done in a multi-threaded
     # manner as it is a small and limited list.
     source_prefix = './source/'
     full_prefix = './source/extensions/'
     # Check to see if this directory is a subdir under /source/extensions
     # Also ignore top level directories under /source/extensions since we don't
     # need owners for source/extensions/access_loggers etc, just the subdirectories.
     if dir_name.startswith(full_prefix) and '/' in dir_name[len(full_prefix):]:
       self.checkOwners(dir_name[len(source_prefix):], owned_directories, error_messages)
 
     for file_name in names:
       if dir_name.startswith("./api") and self.isStarlarkFile(file_name):
         result = pool.apply_async(self.checkApiShadowStarlarkFiles,
                                   args=(dir_name + "/" + file_name, error_messages))
         result_list.append(result)
       result = pool.apply_async(self.checkFormatReturnTraceOnError,
                                 args=(dir_name + "/" + file_name,))
       result_list.append(result)
 
   # checkErrorMessages iterates over the list with error messages and prints
   # errors and returns a bool based on whether there were any errors.
   def checkErrorMessages(self, error_messages):
     if error_messages:
       for e in error_messages:
         print("ERROR: %s" % e)
       return True
     return False
