commit ed997f5f125491099914ab9febff432238de4018
Author: James Almer <jamrial@gmail.com>
Date:   Wed Apr 12 19:18:25 2023 +0000

    picture: revert recent ITU-T T.35 metadata commits

diff --git a/include/dav1d/headers.h b/include/dav1d/headers.h
index a591b2d..e2f7aa0 100644
--- a/include/dav1d/headers.h
+++ b/include/dav1d/headers.h
@@ -196,9 +196,8 @@ typedef struct Dav1dMasteringDisplay {
 typedef struct Dav1dITUTT35 {
     uint8_t  country_code;
     uint8_t  country_code_extension_byte;
     size_t   payload_size;
     uint8_t *payload;
-    struct Dav1dRef *ref; ///< allocation origin
 } Dav1dITUTT35;
 
 typedef struct Dav1dSequenceHeader {
diff --git a/include/dav1d/picture.h b/include/dav1d/picture.h
index 2c80012..2eb0b62 100644
--- a/include/dav1d/picture.h
+++ b/include/dav1d/picture.h
@@ -49,48 +49,48 @@ typedef struct Dav1dPictureParameters {
 typedef struct Dav1dPicture {
     Dav1dSequenceHeader *seq_hdr;
     Dav1dFrameHeader *frame_hdr;
 
     /**
      * Pointers to planar image data (Y is [0], U is [1], V is [2]). The data
      * should be bytes (for 8 bpc) or words (for 10 bpc). In case of words
      * containing 10 bpc image data, the pixels should be located in the LSB
      * bits, so that values range between [0, 1023]; the upper bits should be
      * zero'ed out.
      */
     void *data[3];
 
     /**
      * Number of bytes between 2 lines in data[] for luma [0] or chroma [1].
      */
     ptrdiff_t stride[2];
 
     Dav1dPictureParameters p;
     Dav1dDataProps m;
 
     /**
      * High Dynamic Range Content Light Level metadata applying to this picture,
      * as defined in section 5.8.3 and 6.7.3
      */
     Dav1dContentLightLevel *content_light;
     /**
      * High Dynamic Range Mastering Display Color Volume metadata applying to
      * this picture, as defined in section 5.8.4 and 6.7.4
      */
     Dav1dMasteringDisplay *mastering_display;
     /**
-     * Array of ITU-T T.35 metadata as defined in section 5.8.2 and 6.7.2
+     * ITU-T T.35 metadata as defined in section 5.8.2 and 6.7.2
      */
     Dav1dITUTT35 *itut_t35;
-    /**
-     * Number of ITU-T T35 metadata entries in the array
-     */
-    int n_itut_t35;
 
     uintptr_t reserved[4]; ///< reserved for future use
 
     struct Dav1dRef *frame_hdr_ref; ///< Dav1dFrameHeader allocation origin
     struct Dav1dRef *seq_hdr_ref; ///< Dav1dSequenceHeader allocation origin
+    struct Dav1dRef *content_light_ref; ///< Dav1dContentLightLevel allocation origin
+    struct Dav1dRef *mastering_display_ref; ///< Dav1dMasteringDisplay allocation origin
+    struct Dav1dRef *itut_t35_ref; ///< Dav1dITUTT35 allocation origin
+    uintptr_t reserved_ref[4]; ///< reserved for future use
     struct Dav1dRef *ref; ///< Frame data allocation origin
 
     void *allocator_data; ///< pointer managed by the allocator
 } Dav1dPicture;
diff --git a/meson.build b/meson.build
index 71a61e4..bab3188 100644
--- a/meson.build
+++ b/meson.build
@@ -30,7 +30,7 @@ project('dav1d', ['c'],
                       'b_ndebug=if-release'],
     meson_version: '>= 0.49.0')
 
-dav1d_soname_version       = '7.0.0'
+dav1d_soname_version       = '6.8.0'
 dav1d_api_version_array    = dav1d_soname_version.split('.')
 dav1d_api_version_major    = dav1d_api_version_array[0]
 dav1d_api_version_minor    = dav1d_api_version_array[1]
diff --git a/src/internal.h b/src/internal.h
index 6937e9b..b5fd1e1 100644
--- a/src/internal.h
+++ b/src/internal.h
@@ -92,116 +92,116 @@ enum TaskType {
 struct Dav1dContext {
     Dav1dFrameContext *fc;
     unsigned n_fc;
 
     Dav1dTaskContext *tc;
     unsigned n_tc;
 
     // cache of OBUs that make up a single frame before we submit them
     // to a frame worker to be decoded
     struct Dav1dTileGroup *tile;
     int n_tile_data_alloc;
     int n_tile_data;
     int n_tiles;
     Dav1dMemPool *seq_hdr_pool;
     Dav1dRef *seq_hdr_ref;
     Dav1dSequenceHeader *seq_hdr;
     Dav1dMemPool *frame_hdr_pool;
     Dav1dRef *frame_hdr_ref;
     Dav1dFrameHeader *frame_hdr;
 
     Dav1dRef *content_light_ref;
     Dav1dContentLightLevel *content_light;
     Dav1dRef *mastering_display_ref;
     Dav1dMasteringDisplay *mastering_display;
+    Dav1dRef *itut_t35_ref;
     Dav1dITUTT35 *itut_t35;
-    int n_itut_t35;
 
     // decoded output picture queue
     Dav1dData in;
     Dav1dThreadPicture out, cache;
     // dummy is a pointer to prevent compiler errors about atomic_load()
     // not taking const arguments
     atomic_int flush_mem, *flush;
     struct {
         Dav1dThreadPicture *out_delayed;
         unsigned next;
     } frame_thread;
 
     // task threading (refer to tc[] for per_thread thingies)
     struct TaskThreadData {
         pthread_mutex_t lock;
         pthread_cond_t cond;
         atomic_uint first;
         unsigned cur;
         // This is used for delayed reset of the task cur pointer when
         // such operation is needed but the thread doesn't enter a critical
         // section (typically when executing the next sbrow task locklessly).
         // See src/thread_task.c:reset_task_cur().
         atomic_uint reset_task_cur;
         atomic_int cond_signaled;
         struct {
             int exec;
             pthread_cond_t cond;
             const Dav1dPicture *in;
             Dav1dPicture *out;
             enum TaskType type;
             atomic_int progress[2]; /* [0]=started, [1]=completed */
             union {
                 struct {
                     ALIGN(int8_t grain_lut_8bpc[3][GRAIN_HEIGHT + 1][GRAIN_WIDTH], 16);
                     ALIGN(uint8_t scaling_8bpc[3][256], 64);
                 };
                 struct {
                     ALIGN(int16_t grain_lut_16bpc[3][GRAIN_HEIGHT + 1][GRAIN_WIDTH], 16);
                     ALIGN(uint8_t scaling_16bpc[3][4096], 64);
                 };
             };
         } delayed_fg;
         int inited;
     } task_thread;
 
     // reference/entropy state
     Dav1dMemPool *segmap_pool;
     Dav1dMemPool *refmvs_pool;
     struct {
         Dav1dThreadPicture p;
         Dav1dRef *segmap;
         Dav1dRef *refmvs;
         unsigned refpoc[7];
     } refs[8];
     Dav1dMemPool *cdf_pool;
     CdfThreadContext cdf[8];
 
     Dav1dDSPContext dsp[3 /* 8, 10, 12 bits/component */];
     Dav1dRefmvsDSPContext refmvs_dsp;
 
     // tree to keep track of which edges are available
     struct {
         EdgeNode *root[2 /* BL_128X128 vs. BL_64X64 */];
         EdgeBranch branch_sb128[1 + 4 + 16 + 64];
         EdgeBranch branch_sb64[1 + 4 + 16];
         EdgeTip tip_sb128[256];
         EdgeTip tip_sb64[64];
     } intra_edge;
 
     Dav1dPicAllocator allocator;
     int apply_grain;
     int operating_point;
     unsigned operating_point_idc;
     int all_layers;
     int max_spatial_id;
     unsigned frame_size_limit;
     int strict_std_compliance;
     int output_invisible_frames;
     enum Dav1dInloopFilterType inloop_filters;
     enum Dav1dDecodeFrameType decode_frame_type;
     int drain;
     enum PictureFlags frame_flags;
     enum Dav1dEventFlags event_flags;
     Dav1dDataProps cached_error_props;
     int cached_error;
 
     Dav1dLogger logger;
 
     Dav1dMemPool *picture_pool;
 };
diff --git a/src/lib.c b/src/lib.c
index 3ec62f9..eca22eb 100644
--- a/src/lib.c
+++ b/src/lib.c
@@ -571,75 +571,74 @@ error:
 void dav1d_flush(Dav1dContext *const c) {
     dav1d_data_unref_internal(&c->in);
     if (c->out.p.frame_hdr)
         dav1d_thread_picture_unref(&c->out);
     if (c->cache.p.frame_hdr)
         dav1d_thread_picture_unref(&c->cache);
 
     c->drain = 0;
     c->cached_error = 0;
 
     for (int i = 0; i < 8; i++) {
         if (c->refs[i].p.p.frame_hdr)
             dav1d_thread_picture_unref(&c->refs[i].p);
         dav1d_ref_dec(&c->refs[i].segmap);
         dav1d_ref_dec(&c->refs[i].refmvs);
         dav1d_cdf_thread_unref(&c->cdf[i]);
     }
     c->frame_hdr = NULL;
     c->seq_hdr = NULL;
     dav1d_ref_dec(&c->seq_hdr_ref);
 
     c->mastering_display = NULL;
     c->content_light = NULL;
+    c->itut_t35 = NULL;
     dav1d_ref_dec(&c->mastering_display_ref);
     dav1d_ref_dec(&c->content_light_ref);
-    for (int n = 0; n < c->n_itut_t35; n++)
-        dav1d_ref_dec(&c->itut_t35[n].ref);
-    c->n_itut_t35 = 0;
+    dav1d_ref_dec(&c->itut_t35_ref);
 
     dav1d_data_props_unref_internal(&c->cached_error_props);
 
     if (c->n_fc == 1 && c->n_tc == 1) return;
     atomic_store(c->flush, 1);
 
     // stop running tasks in worker threads
     if (c->n_tc > 1) {
         pthread_mutex_lock(&c->task_thread.lock);
         for (unsigned i = 0; i < c->n_tc; i++) {
             Dav1dTaskContext *const tc = &c->tc[i];
             while (!tc->task_thread.flushed) {
                 pthread_cond_wait(&tc->task_thread.td.cond, &c->task_thread.lock);
             }
         }
         for (unsigned i = 0; i < c->n_fc; i++) {
             c->fc[i].task_thread.task_head = NULL;
             c->fc[i].task_thread.task_tail = NULL;
             c->fc[i].task_thread.task_cur_prev = NULL;
             c->fc[i].task_thread.pending_tasks.head = NULL;
             c->fc[i].task_thread.pending_tasks.tail = NULL;
             atomic_init(&c->fc[i].task_thread.pending_tasks.merge, 0);
         }
         atomic_init(&c->task_thread.first, 0);
         c->task_thread.cur = c->n_fc;
         atomic_store(&c->task_thread.reset_task_cur, UINT_MAX);
         atomic_store(&c->task_thread.cond_signaled, 0);
         pthread_mutex_unlock(&c->task_thread.lock);
     }
 
     // wait for threads to complete flushing
     if (c->n_fc > 1) {
         for (unsigned n = 0, next = c->frame_thread.next; n < c->n_fc; n++, next++) {
             if (next == c->n_fc) next = 0;
             Dav1dFrameContext *const f = &c->fc[next];
             dav1d_decode_frame_exit(f, -1);
             f->n_tile_data = 0;
             f->task_thread.retval = 0;
             Dav1dThreadPicture *out_delayed = &c->frame_thread.out_delayed[next];
             if (out_delayed->p.frame_hdr) {
                 dav1d_thread_picture_unref(out_delayed);
             }
         }
         c->frame_thread.next = 0;
     }
     atomic_store(c->flush, 0);
 }
@@ -652,97 +651,95 @@ COLD void dav1d_close(Dav1dContext **const c_out) {
 static COLD void close_internal(Dav1dContext **const c_out, int flush) {
     Dav1dContext *const c = *c_out;
     if (!c) return;
 
     if (flush) dav1d_flush(c);
 
     if (c->tc) {
         struct TaskThreadData *ttd = &c->task_thread;
         if (ttd->inited) {
             pthread_mutex_lock(&ttd->lock);
             for (unsigned n = 0; n < c->n_tc && c->tc[n].task_thread.td.inited; n++)
                 c->tc[n].task_thread.die = 1;
             pthread_cond_broadcast(&ttd->cond);
             pthread_mutex_unlock(&ttd->lock);
             for (unsigned n = 0; n < c->n_tc; n++) {
                 Dav1dTaskContext *const pf = &c->tc[n];
                 if (!pf->task_thread.td.inited) break;
                 pthread_join(pf->task_thread.td.thread, NULL);
                 pthread_cond_destroy(&pf->task_thread.td.cond);
                 pthread_mutex_destroy(&pf->task_thread.td.lock);
             }
             pthread_cond_destroy(&ttd->delayed_fg.cond);
             pthread_cond_destroy(&ttd->cond);
             pthread_mutex_destroy(&ttd->lock);
         }
         dav1d_free_aligned(c->tc);
     }
 
     for (unsigned n = 0; c->fc && n < c->n_fc; n++) {
         Dav1dFrameContext *const f = &c->fc[n];
 
         // clean-up threading stuff
         if (c->n_fc > 1) {
             freep(&f->tile_thread.lowest_pixel_mem);
             freep(&f->frame_thread.b);
             dav1d_freep_aligned(&f->frame_thread.pal_idx);
             dav1d_freep_aligned(&f->frame_thread.cf);
             freep(&f->frame_thread.tile_start_off);
             dav1d_freep_aligned(&f->frame_thread.pal);
             freep(&f->frame_thread.cbi);
         }
         if (c->n_tc > 1) {
             pthread_mutex_destroy(&f->task_thread.pending_tasks.lock);
             pthread_cond_destroy(&f->task_thread.cond);
             pthread_mutex_destroy(&f->task_thread.lock);
         }
         freep(&f->frame_thread.frame_progress);
         freep(&f->task_thread.tasks);
         freep(&f->task_thread.tile_tasks[0]);
         dav1d_free_aligned(f->ts);
         dav1d_free_aligned(f->ipred_edge[0]);
         free(f->a);
         free(f->tile);
         free(f->lf.mask);
         free(f->lf.lr_mask);
         free(f->lf.level);
         free(f->lf.tx_lpf_right_edge[0]);
         free(f->lf.start_of_tile_row);
         dav1d_refmvs_clear(&f->rf);
         dav1d_free_aligned(f->lf.cdef_line_buf);
         dav1d_free_aligned(f->lf.lr_line_buf);
     }
     dav1d_free_aligned(c->fc);
     if (c->n_fc > 1 && c->frame_thread.out_delayed) {
         for (unsigned n = 0; n < c->n_fc; n++)
             if (c->frame_thread.out_delayed[n].p.frame_hdr)
                 dav1d_thread_picture_unref(&c->frame_thread.out_delayed[n]);
         free(c->frame_thread.out_delayed);
     }
     for (int n = 0; n < c->n_tile_data; n++)
         dav1d_data_unref_internal(&c->tile[n].data);
     free(c->tile);
     for (int n = 0; n < 8; n++) {
         dav1d_cdf_thread_unref(&c->cdf[n]);
         if (c->refs[n].p.p.frame_hdr)
             dav1d_thread_picture_unref(&c->refs[n].p);
         dav1d_ref_dec(&c->refs[n].refmvs);
         dav1d_ref_dec(&c->refs[n].segmap);
     }
     dav1d_ref_dec(&c->seq_hdr_ref);
     dav1d_ref_dec(&c->frame_hdr_ref);
 
     dav1d_ref_dec(&c->mastering_display_ref);
     dav1d_ref_dec(&c->content_light_ref);
-    for (int n = 0; n < c->n_itut_t35; n++)
-        dav1d_ref_dec(&c->itut_t35[n].ref);
-    free(c->itut_t35);
+    dav1d_ref_dec(&c->itut_t35_ref);
 
     dav1d_mem_pool_end(c->seq_hdr_pool);
     dav1d_mem_pool_end(c->frame_hdr_pool);
     dav1d_mem_pool_end(c->segmap_pool);
     dav1d_mem_pool_end(c->refmvs_pool);
     dav1d_mem_pool_end(c->cdf_pool);
     dav1d_mem_pool_end(c->picture_pool);
 
     dav1d_freep_aligned(c_out);
 }
diff --git a/src/obu.c b/src/obu.c
index c5b3946..e08129a 100644
--- a/src/obu.c
+++ b/src/obu.c
@@ -1178,494 +1178,499 @@ static int check_for_overrun(Dav1dContext *const c, GetBits *const gb,
 int dav1d_parse_obus(Dav1dContext *const c, Dav1dData *const in, const int global) {
     GetBits gb;
     int res;
 
     dav1d_init_get_bits(&gb, in->data, in->sz);
 
     // obu header
     dav1d_get_bit(&gb); // obu_forbidden_bit
     const enum Dav1dObuType type = dav1d_get_bits(&gb, 4);
     const int has_extension = dav1d_get_bit(&gb);
     const int has_length_field = dav1d_get_bit(&gb);
     dav1d_get_bit(&gb); // reserved
 
     int temporal_id = 0, spatial_id = 0;
     if (has_extension) {
         temporal_id = dav1d_get_bits(&gb, 3);
         spatial_id = dav1d_get_bits(&gb, 2);
         dav1d_get_bits(&gb, 3); // reserved
     }
 
     // obu length field
     const unsigned len = has_length_field ?
         dav1d_get_uleb128(&gb) : (unsigned) in->sz - 1 - has_extension;
     if (gb.error) goto error;
 
     const unsigned init_bit_pos = dav1d_get_bits_pos(&gb);
     const unsigned init_byte_pos = init_bit_pos >> 3;
 
     // We must have read a whole number of bytes at this point (1 byte
     // for the header and whole bytes at a time when reading the
     // leb128 length field).
     assert((init_bit_pos & 7) == 0);
 
     // We also know that we haven't tried to read more than in->sz
     // bytes yet (otherwise the error flag would have been set by the
     // code in getbits.c)
     assert(in->sz >= init_byte_pos);
 
     // Make sure that there are enough bits left in the buffer for the
     // rest of the OBU.
     if (len > in->sz - init_byte_pos) goto error;
 
     // skip obu not belonging to the selected temporal/spatial layer
     if (type != DAV1D_OBU_SEQ_HDR && type != DAV1D_OBU_TD &&
         has_extension && c->operating_point_idc != 0)
     {
         const int in_temporal_layer = (c->operating_point_idc >> temporal_id) & 1;
         const int in_spatial_layer = (c->operating_point_idc >> (spatial_id + 8)) & 1;
         if (!in_temporal_layer || !in_spatial_layer)
             return len + init_byte_pos;
     }
 
     switch (type) {
     case DAV1D_OBU_SEQ_HDR: {
         Dav1dRef *ref = dav1d_ref_create_using_pool(c->seq_hdr_pool,
                                                     sizeof(Dav1dSequenceHeader));
         if (!ref) return DAV1D_ERR(ENOMEM);
         Dav1dSequenceHeader *seq_hdr = ref->data;
         if ((res = parse_seq_hdr(c, &gb, seq_hdr)) < 0) {
             dav1d_ref_dec(&ref);
             goto error;
         }
         if (check_for_overrun(c, &gb, init_bit_pos, len)) {
             dav1d_ref_dec(&ref);
             goto error;
         }
         // If we have read a sequence header which is different from
         // the old one, this is a new video sequence and can't use any
         // previous state. Free that state.
 
         if (!c->seq_hdr) {
             c->frame_hdr = NULL;
             c->frame_flags |= PICTURE_FLAG_NEW_SEQUENCE;
         // see 7.5, operating_parameter_info is allowed to change in
         // sequence headers of a single sequence
         } else if (memcmp(seq_hdr, c->seq_hdr, offsetof(Dav1dSequenceHeader, operating_parameter_info))) {
             c->frame_hdr = NULL;
             c->mastering_display = NULL;
             c->content_light = NULL;
             dav1d_ref_dec(&c->mastering_display_ref);
             dav1d_ref_dec(&c->content_light_ref);
             for (int i = 0; i < 8; i++) {
                 if (c->refs[i].p.p.frame_hdr)
                     dav1d_thread_picture_unref(&c->refs[i].p);
                 dav1d_ref_dec(&c->refs[i].segmap);
                 dav1d_ref_dec(&c->refs[i].refmvs);
                 dav1d_cdf_thread_unref(&c->cdf[i]);
             }
             c->frame_flags |= PICTURE_FLAG_NEW_SEQUENCE;
         // If operating_parameter_info changed, signal it
         } else if (memcmp(seq_hdr->operating_parameter_info, c->seq_hdr->operating_parameter_info,
                           sizeof(seq_hdr->operating_parameter_info)))
         {
             c->frame_flags |= PICTURE_FLAG_NEW_OP_PARAMS_INFO;
         }
         dav1d_ref_dec(&c->seq_hdr_ref);
         c->seq_hdr_ref = ref;
         c->seq_hdr = seq_hdr;
         break;
     }
     case DAV1D_OBU_REDUNDANT_FRAME_HDR:
         if (c->frame_hdr) break;
         // fall-through
     case DAV1D_OBU_FRAME:
     case DAV1D_OBU_FRAME_HDR:
         if (global) break;
         if (!c->seq_hdr) goto error;
         if (!c->frame_hdr_ref) {
             c->frame_hdr_ref = dav1d_ref_create_using_pool(c->frame_hdr_pool,
                                                            sizeof(Dav1dFrameHeader));
             if (!c->frame_hdr_ref) return DAV1D_ERR(ENOMEM);
         }
 #ifndef NDEBUG
         // ensure that the reference is writable
         assert(dav1d_ref_is_writable(c->frame_hdr_ref));
 #endif
         c->frame_hdr = c->frame_hdr_ref->data;
         memset(c->frame_hdr, 0, sizeof(*c->frame_hdr));
         c->frame_hdr->temporal_id = temporal_id;
         c->frame_hdr->spatial_id = spatial_id;
         if ((res = parse_frame_hdr(c, &gb)) < 0) {
             c->frame_hdr = NULL;
             goto error;
         }
         for (int n = 0; n < c->n_tile_data; n++)
             dav1d_data_unref_internal(&c->tile[n].data);
         c->n_tile_data = 0;
         c->n_tiles = 0;
         if (type != DAV1D_OBU_FRAME) {
             // This is actually a frame header OBU so read the
             // trailing bit and check for overrun.
             dav1d_get_bit(&gb);
             if (check_for_overrun(c, &gb, init_bit_pos, len)) {
                 c->frame_hdr = NULL;
                 goto error;
             }
         }
 
         if (c->frame_size_limit && (int64_t)c->frame_hdr->width[1] *
             c->frame_hdr->height > c->frame_size_limit)
         {
             dav1d_log(c, "Frame size %dx%d exceeds limit %u\n", c->frame_hdr->width[1],
                       c->frame_hdr->height, c->frame_size_limit);
             c->frame_hdr = NULL;
             return DAV1D_ERR(ERANGE);
         }
 
         if (type != DAV1D_OBU_FRAME)
             break;
         // OBU_FRAMEs shouldn't be signaled with show_existing_frame
         if (c->frame_hdr->show_existing_frame) {
             c->frame_hdr = NULL;
             goto error;
         }
 
         // This is the frame header at the start of a frame OBU.
         // There's no trailing bit at the end to skip, but we do need
         // to align to the next byte.
         dav1d_bytealign_get_bits(&gb);
         // fall-through
     case DAV1D_OBU_TILE_GRP: {
         if (global) break;
         if (!c->frame_hdr) goto error;
         if (c->n_tile_data_alloc < c->n_tile_data + 1) {
             if ((c->n_tile_data + 1) > INT_MAX / (int)sizeof(*c->tile)) goto error;
             struct Dav1dTileGroup *tile = realloc(c->tile, (c->n_tile_data + 1) * sizeof(*c->tile));
             if (!tile) goto error;
             c->tile = tile;
             memset(c->tile + c->n_tile_data, 0, sizeof(*c->tile));
             c->n_tile_data_alloc = c->n_tile_data + 1;
         }
         parse_tile_hdr(c, &gb);
         // Align to the next byte boundary and check for overrun.
         dav1d_bytealign_get_bits(&gb);
         if (check_for_overrun(c, &gb, init_bit_pos, len))
             goto error;
         // The current bit position is a multiple of 8 (because we
         // just aligned it) and less than 8*pkt_bytelen because
         // otherwise the overrun check would have fired.
         const unsigned pkt_bytelen = init_byte_pos + len;
         const unsigned bit_pos = dav1d_get_bits_pos(&gb);
         assert((bit_pos & 7) == 0);
         assert(pkt_bytelen >= (bit_pos >> 3));
         dav1d_data_ref(&c->tile[c->n_tile_data].data, in);
         c->tile[c->n_tile_data].data.data += bit_pos >> 3;
         c->tile[c->n_tile_data].data.sz = pkt_bytelen - (bit_pos >> 3);
         // ensure tile groups are in order and sane, see 6.10.1
         if (c->tile[c->n_tile_data].start > c->tile[c->n_tile_data].end ||
             c->tile[c->n_tile_data].start != c->n_tiles)
         {
             for (int i = 0; i <= c->n_tile_data; i++)
                 dav1d_data_unref_internal(&c->tile[i].data);
             c->n_tile_data = 0;
             c->n_tiles = 0;
             goto error;
         }
         c->n_tiles += 1 + c->tile[c->n_tile_data].end -
                           c->tile[c->n_tile_data].start;
         c->n_tile_data++;
         break;
     }
     case DAV1D_OBU_METADATA: {
 #define DEBUG_OBU_METADATA 0
 #if DEBUG_OBU_METADATA
         const uint8_t *const init_ptr = gb.ptr;
 #endif
         // obu metadta type field
         const enum ObuMetaType meta_type = dav1d_get_uleb128(&gb);
         const int meta_type_len = (dav1d_get_bits_pos(&gb) - init_bit_pos) >> 3;
         if (gb.error) goto error;
 
         switch (meta_type) {
         case OBU_META_HDR_CLL: {
             Dav1dRef *ref = dav1d_ref_create(sizeof(Dav1dContentLightLevel));
             if (!ref) return DAV1D_ERR(ENOMEM);
             Dav1dContentLightLevel *const content_light = ref->data;
 
             content_light->max_content_light_level = dav1d_get_bits(&gb, 16);
 #if DEBUG_OBU_METADATA
             printf("CLLOBU: max-content-light-level: %d [off=%td]\n",
                    content_light->max_content_light_level,
                    (gb.ptr - init_ptr) * 8 - gb.bits_left);
 #endif
             content_light->max_frame_average_light_level = dav1d_get_bits(&gb, 16);
 #if DEBUG_OBU_METADATA
             printf("CLLOBU: max-frame-average-light-level: %d [off=%td]\n",
                    content_light->max_frame_average_light_level,
                    (gb.ptr - init_ptr) * 8 - gb.bits_left);
 #endif
 
             // Skip the trailing bit, align to the next byte boundary and check for overrun.
             dav1d_get_bit(&gb);
             dav1d_bytealign_get_bits(&gb);
             if (check_for_overrun(c, &gb, init_bit_pos, len)) {
                 dav1d_ref_dec(&ref);
                 goto error;
             }
 
             dav1d_ref_dec(&c->content_light_ref);
             c->content_light = content_light;
             c->content_light_ref = ref;
             break;
         }
         case OBU_META_HDR_MDCV: {
             Dav1dRef *ref = dav1d_ref_create(sizeof(Dav1dMasteringDisplay));
             if (!ref) return DAV1D_ERR(ENOMEM);
             Dav1dMasteringDisplay *const mastering_display = ref->data;
 
             for (int i = 0; i < 3; i++) {
                 mastering_display->primaries[i][0] = dav1d_get_bits(&gb, 16);
                 mastering_display->primaries[i][1] = dav1d_get_bits(&gb, 16);
 #if DEBUG_OBU_METADATA
                 printf("MDCVOBU: primaries[%d]: (%d, %d) [off=%td]\n", i,
                        mastering_display->primaries[i][0],
                        mastering_display->primaries[i][1],
                        (gb.ptr - init_ptr) * 8 - gb.bits_left);
 #endif
             }
             mastering_display->white_point[0] = dav1d_get_bits(&gb, 16);
 #if DEBUG_OBU_METADATA
             printf("MDCVOBU: white-point-x: %d [off=%td]\n",
                    mastering_display->white_point[0],
                    (gb.ptr - init_ptr) * 8 - gb.bits_left);
 #endif
             mastering_display->white_point[1] = dav1d_get_bits(&gb, 16);
 #if DEBUG_OBU_METADATA
             printf("MDCVOBU: white-point-y: %d [off=%td]\n",
                    mastering_display->white_point[1],
                    (gb.ptr - init_ptr) * 8 - gb.bits_left);
 #endif
             mastering_display->max_luminance = dav1d_get_bits(&gb, 32);
 #if DEBUG_OBU_METADATA
             printf("MDCVOBU: max-luminance: %d [off=%td]\n",
                    mastering_display->max_luminance,
                    (gb.ptr - init_ptr) * 8 - gb.bits_left);
 #endif
             mastering_display->min_luminance = dav1d_get_bits(&gb, 32);
 #if DEBUG_OBU_METADATA
             printf("MDCVOBU: min-luminance: %d [off=%td]\n",
                    mastering_display->min_luminance,
                    (gb.ptr - init_ptr) * 8 - gb.bits_left);
 #endif
             // Skip the trailing bit, align to the next byte boundary and check for overrun.
             dav1d_get_bit(&gb);
             dav1d_bytealign_get_bits(&gb);
             if (check_for_overrun(c, &gb, init_bit_pos, len)) {
                 dav1d_ref_dec(&ref);
                 goto error;
             }
 
             dav1d_ref_dec(&c->mastering_display_ref);
             c->mastering_display = mastering_display;
             c->mastering_display_ref = ref;
             break;
         }
         case OBU_META_ITUT_T35: {
             int payload_size = len;
             // Don't take into account all the trailing bits for payload_size
             while (payload_size > 0 && !in->data[init_byte_pos + payload_size - 1])
                 payload_size--; // trailing_zero_bit x 8
             payload_size--; // trailing_one_bit + trailing_zero_bit x 7
 
             // Don't take into account meta_type bytes
             payload_size -= meta_type_len;
 
             int country_code_extension_byte = 0;
             const int country_code = dav1d_get_bits(&gb, 8);
             payload_size--;
             if (country_code == 0xFF) {
                 country_code_extension_byte = dav1d_get_bits(&gb, 8);
                 payload_size--;
             }
 
             if (payload_size <= 0) {
                 dav1d_log(c, "Malformed ITU-T T.35 metadata message format\n");
                 break;
             }
 
-            if ((c->n_itut_t35 + 1) > INT_MAX / (int)sizeof(*c->itut_t35)) goto error;
-            struct Dav1dITUTT35 *itut_t35 = realloc(c->itut_t35, (c->n_itut_t35 + 1) * sizeof(*c->itut_t35));
-            if (!itut_t35) goto error;
-            c->itut_t35 = itut_t35;
-            memset(c->itut_t35 + c->n_itut_t35, 0, sizeof(*c->itut_t35));
-
-            Dav1dITUTT35 *const itut_t35_metadata = &c->itut_t35[c->n_itut_t35];
-            itut_t35_metadata->ref = dav1d_ref_create(payload_size * sizeof(uint8_t));
-            if (!itut_t35_metadata->ref) return DAV1D_ERR(ENOMEM);
+            Dav1dRef *ref = dav1d_ref_create(sizeof(Dav1dITUTT35) + payload_size * sizeof(uint8_t));
+            if (!ref) return DAV1D_ERR(ENOMEM);
+            Dav1dITUTT35 *const itut_t35_metadata = ref->data;
 
-            itut_t35_metadata->payload = itut_t35_metadata->ref->data;
+            // We need our public headers to be C++ compatible, so payload can't be
+            // a flexible array member
+            itut_t35_metadata->payload = (uint8_t *) &itut_t35_metadata[1];
             itut_t35_metadata->country_code = country_code;
             itut_t35_metadata->country_code_extension_byte = country_code_extension_byte;
             for (int i = 0; i < payload_size; i++)
                 itut_t35_metadata->payload[i] = dav1d_get_bits(&gb, 8);
             itut_t35_metadata->payload_size = payload_size;
 
-            c->n_itut_t35++;
+            dav1d_ref_dec(&c->itut_t35_ref);
+            c->itut_t35 = itut_t35_metadata;
+            c->itut_t35_ref = ref;
             break;
         }
         case OBU_META_SCALABILITY:
         case OBU_META_TIMECODE:
             // ignore metadata OBUs we don't care about
             break;
         default:
             // print a warning but don't fail for unknown types
             dav1d_log(c, "Unknown Metadata OBU type %d\n", meta_type);
             break;
         }
 
         break;
     }
     case DAV1D_OBU_TD:
         c->frame_flags |= PICTURE_FLAG_NEW_TEMPORAL_UNIT;
         break;
     case DAV1D_OBU_PADDING:
         // ignore OBUs we don't care about
         break;
     default:
         // print a warning but don't fail for unknown types
         dav1d_log(c, "Unknown OBU type %d of size %u\n", type, len);
         break;
     }
 
     if (c->seq_hdr && c->frame_hdr) {
         if (c->frame_hdr->show_existing_frame) {
             if (!c->refs[c->frame_hdr->existing_frame_idx].p.p.frame_hdr) goto error;
             switch (c->refs[c->frame_hdr->existing_frame_idx].p.p.frame_hdr->frame_type) {
             case DAV1D_FRAME_TYPE_INTER:
             case DAV1D_FRAME_TYPE_SWITCH:
                 if (c->decode_frame_type > DAV1D_DECODEFRAMETYPE_REFERENCE)
                     goto skip;
                 break;
             case DAV1D_FRAME_TYPE_INTRA:
                 if (c->decode_frame_type > DAV1D_DECODEFRAMETYPE_INTRA)
                     goto skip;
                 // fall-through
             default:
                 break;
             }
             if (!c->refs[c->frame_hdr->existing_frame_idx].p.p.data[0]) goto error;
             if (c->strict_std_compliance &&
                 !c->refs[c->frame_hdr->existing_frame_idx].p.showable)
             {
                 goto error;
             }
             if (c->n_fc == 1) {
                 dav1d_thread_picture_ref(&c->out,
                                          &c->refs[c->frame_hdr->existing_frame_idx].p);
-                dav1d_picture_move_props(&c->out.p,
+                dav1d_picture_copy_props(&c->out.p,
                                          c->content_light, c->content_light_ref,
                                          c->mastering_display, c->mastering_display_ref,
-                                         &c->itut_t35, &c->n_itut_t35,
+                                         c->itut_t35, c->itut_t35_ref,
                                          &in->m);
+                // Must be removed from the context after being attached to the frame
+                dav1d_ref_dec(&c->itut_t35_ref);
+                c->itut_t35 = NULL;
                 c->event_flags |= dav1d_picture_get_event_flags(&c->refs[c->frame_hdr->existing_frame_idx].p);
             } else {
                 pthread_mutex_lock(&c->task_thread.lock);
                 // need to append this to the frame output queue
                 const unsigned next = c->frame_thread.next++;
                 if (c->frame_thread.next == c->n_fc)
                     c->frame_thread.next = 0;
 
                 Dav1dFrameContext *const f = &c->fc[next];
                 while (f->n_tile_data > 0)
                     pthread_cond_wait(&f->task_thread.cond,
                                       &f->task_thread.ttd->lock);
                 Dav1dThreadPicture *const out_delayed =
                     &c->frame_thread.out_delayed[next];
                 if (out_delayed->p.data[0] || atomic_load(&f->task_thread.error)) {
                     unsigned first = atomic_load(&c->task_thread.first);
                     if (first + 1U < c->n_fc)
                         atomic_fetch_add(&c->task_thread.first, 1U);
                     else
                         atomic_store(&c->task_thread.first, 0);
                     atomic_compare_exchange_strong(&c->task_thread.reset_task_cur,
                                                    &first, UINT_MAX);
                     if (c->task_thread.cur && c->task_thread.cur < c->n_fc)
                         c->task_thread.cur--;
                 }
                 const int error = f->task_thread.retval;
                 if (error) {
                     c->cached_error = error;
                     f->task_thread.retval = 0;
                     dav1d_data_props_copy(&c->cached_error_props, &out_delayed->p.m);
                     dav1d_thread_picture_unref(out_delayed);
                 } else if (out_delayed->p.data[0]) {
                     const unsigned progress = atomic_load_explicit(&out_delayed->progress[1],
                                                                    memory_order_relaxed);
                     if ((out_delayed->visible || c->output_invisible_frames) &&
                         progress != FRAME_ERROR)
                     {
                         dav1d_thread_picture_ref(&c->out, out_delayed);
                         c->event_flags |= dav1d_picture_get_event_flags(out_delayed);
                     }
                     dav1d_thread_picture_unref(out_delayed);
                 }
                 dav1d_thread_picture_ref(out_delayed,
                                          &c->refs[c->frame_hdr->existing_frame_idx].p);
                 out_delayed->visible = 1;
-                dav1d_picture_move_props(&out_delayed->p,
+                dav1d_picture_copy_props(&out_delayed->p,
                                          c->content_light, c->content_light_ref,
                                          c->mastering_display, c->mastering_display_ref,
-                                         &c->itut_t35, &c->n_itut_t35,
+                                         c->itut_t35, c->itut_t35_ref,
                                          &in->m);
+                // Must be removed from the context after being attached to the frame
+                dav1d_ref_dec(&c->itut_t35_ref);
+                c->itut_t35 = NULL;
+
                 pthread_mutex_unlock(&c->task_thread.lock);
             }
             if (c->refs[c->frame_hdr->existing_frame_idx].p.p.frame_hdr->frame_type == DAV1D_FRAME_TYPE_KEY) {
                 const int r = c->frame_hdr->existing_frame_idx;
                 c->refs[r].p.showable = 0;
                 for (int i = 0; i < 8; i++) {
                     if (i == r) continue;
 
                     if (c->refs[i].p.p.frame_hdr)
                         dav1d_thread_picture_unref(&c->refs[i].p);
                     dav1d_thread_picture_ref(&c->refs[i].p, &c->refs[r].p);
 
                     dav1d_cdf_thread_unref(&c->cdf[i]);
                     dav1d_cdf_thread_ref(&c->cdf[i], &c->cdf[r]);
 
                     dav1d_ref_dec(&c->refs[i].segmap);
                     c->refs[i].segmap = c->refs[r].segmap;
                     if (c->refs[r].segmap)
                         dav1d_ref_inc(c->refs[r].segmap);
                     dav1d_ref_dec(&c->refs[i].refmvs);
                 }
             }
             c->frame_hdr = NULL;
         } else if (c->n_tiles == c->frame_hdr->tiling.cols * c->frame_hdr->tiling.rows) {
             switch (c->frame_hdr->frame_type) {
             case DAV1D_FRAME_TYPE_INTER:
             case DAV1D_FRAME_TYPE_SWITCH:
                 if (c->decode_frame_type > DAV1D_DECODEFRAMETYPE_REFERENCE ||
                     (c->decode_frame_type == DAV1D_DECODEFRAMETYPE_REFERENCE &&
                      !c->frame_hdr->refresh_frame_flags))
                     goto skip;
                 break;
             case DAV1D_FRAME_TYPE_INTRA:
                 if (c->decode_frame_type > DAV1D_DECODEFRAMETYPE_INTRA ||
                     (c->decode_frame_type == DAV1D_DECODEFRAMETYPE_REFERENCE &&
                      !c->frame_hdr->refresh_frame_flags))
                     goto skip;
                 // fall-through
             default:
                 break;
             }
             if (!c->n_tile_data)
                 goto error;
             if ((res = dav1d_submit_frame(c)) < 0)
                 return res;
             assert(!c->n_tile_data);
             c->frame_hdr = NULL;
             c->n_tiles = 0;
         }
     }
 
     return len + init_byte_pos;
diff --git a/src/picture.c b/src/picture.c
index 7b100bd..3e55d3f 100644
--- a/src/picture.c
+++ b/src/picture.c
@@ -88,9 +88,6 @@ void dav1d_default_picture_release(Dav1dPicture *const p, void *const cookie) {
 
 struct pic_ctx_context {
     struct Dav1dRef *plane_ref[3]; /* MUST BE FIRST */
-    struct Dav1dRef *content_light_ref;
-    struct Dav1dRef *mastering_display_ref;
-    struct Dav1dRef *itut_t35_ref;
     enum Dav1dPixelLayout layout;
     void *extra_ptr; /* MUST BE AT THE END */
 };
@@ -100,20 +97,12 @@ struct plane_ctx_context {
     Dav1dPicture pic;
 };
 
-struct itut_t35_ctx_context {
-    Dav1dITUTT35 *itut_t35;
-    int n_itut_t35;
-};
-
 static void free_buffer(const uint8_t *const data, void *const user_data) {
     struct pic_ctx_context *pic_ctx = user_data;
     const int planes = pic_ctx->layout != DAV1D_PIXEL_LAYOUT_I400 ? 3 : 1;
 
     for (int i = 0; i < planes; i++)
         dav1d_ref_dec(&pic_ctx->plane_ref[i]);
-    dav1d_ref_dec(&pic_ctx->content_light_ref);
-    dav1d_ref_dec(&pic_ctx->mastering_display_ref);
-    dav1d_ref_dec(&pic_ctx->itut_t35_ref);
     free(pic_ctx);
 }
 
@@ -125,209 +114,151 @@ static void free_plane_buffer(const uint8_t *const data, void *const user_data)
     free(plane_ctx);
 }
 
-static void free_itut_t35(const uint8_t *const data, void *const user_data) {
-    struct itut_t35_ctx_context *itut_t35_ctx = user_data;
-
-    for (int i = 0; i < itut_t35_ctx->n_itut_t35; i++)
-        dav1d_ref_dec(&itut_t35_ctx->itut_t35[i].ref);
-    free(itut_t35_ctx->itut_t35);
-    free(itut_t35_ctx);
-}
-
 static int picture_alloc_with_edges(Dav1dContext *const c,
                                     Dav1dPicture *const p,
                                     const int w, const int h,
                                     Dav1dSequenceHeader *const seq_hdr, Dav1dRef *const seq_hdr_ref,
                                     Dav1dFrameHeader *const frame_hdr, Dav1dRef *const frame_hdr_ref,
+                                    Dav1dContentLightLevel *const content_light, Dav1dRef *const content_light_ref,
+                                    Dav1dMasteringDisplay *const mastering_display, Dav1dRef *const mastering_display_ref,
+                                    Dav1dITUTT35 *const itut_t35, Dav1dRef *const itut_t35_ref,
                                     const int bpc,
                                     const Dav1dDataProps *const props,
                                     Dav1dPicAllocator *const p_allocator,
                                     const size_t extra, void **const extra_ptr)
 {
     if (p->data[0]) {
         dav1d_log(c, "Picture already allocated!\n");
         return -1;
     }
     assert(bpc > 0 && bpc <= 16);
 
     struct pic_ctx_context *pic_ctx = malloc(extra + sizeof(struct pic_ctx_context));
     if (pic_ctx == NULL)
         return DAV1D_ERR(ENOMEM);
     memset(pic_ctx, 0, sizeof(struct pic_ctx_context));
 
     p->p.w = w;
     p->p.h = h;
     p->seq_hdr = seq_hdr;
     p->frame_hdr = frame_hdr;
     p->p.layout = seq_hdr->layout;
     p->p.bpc = bpc;
     dav1d_data_props_set_defaults(&p->m);
     const int res = p_allocator->alloc_picture_callback(p, p_allocator->cookie);
     if (res < 0) {
         free(pic_ctx);
         return res;
     }
 
     pic_ctx->layout = p->p.layout;
 
     if (!(p->ref = dav1d_ref_wrap(p->data[0], free_buffer, pic_ctx))) {
         p_allocator->release_picture_callback(p, p_allocator->cookie);
         free(pic_ctx);
         dav1d_log(c, "Failed to wrap picture: %s\n", strerror(errno));
         return DAV1D_ERR(ENOMEM);
     }
 
     struct plane_ctx_context *plane_ctx = malloc(sizeof(struct plane_ctx_context));
     if (plane_ctx == NULL){
         dav1d_ref_dec(&p->ref);
         p_allocator->release_picture_callback(p, p_allocator->cookie);
         return DAV1D_ERR(ENOMEM);
     }
 
     plane_ctx->allocator = *p_allocator;
     plane_ctx->pic = *p;
 
     pic_ctx->plane_ref[0] = dav1d_ref_wrap(p->data[0], free_plane_buffer, plane_ctx);
     if (!pic_ctx->plane_ref[0]) {
         dav1d_ref_dec(&p->ref);
         p_allocator->release_picture_callback(p, p_allocator->cookie);
         free(plane_ctx);
         dav1d_log(c, "Failed to wrap picture plane: %s\n", strerror(errno));
         return DAV1D_ERR(ENOMEM);
     }
 
     const int planes = p->p.layout != DAV1D_PIXEL_LAYOUT_I400 ? 3 : 1;
     for (int i = 1; i < planes; i++) {
         pic_ctx->plane_ref[i] = pic_ctx->plane_ref[0];
         dav1d_ref_inc(pic_ctx->plane_ref[i]);
     }
 
     p->seq_hdr_ref = seq_hdr_ref;
     if (seq_hdr_ref) dav1d_ref_inc(seq_hdr_ref);
 
     p->frame_hdr_ref = frame_hdr_ref;
     if (frame_hdr_ref) dav1d_ref_inc(frame_hdr_ref);
 
+    dav1d_picture_copy_props(p, content_light, content_light_ref,
+                             mastering_display, mastering_display_ref,
+                             itut_t35, itut_t35_ref, props);
+
     if (extra && extra_ptr)
         *extra_ptr = &pic_ctx->extra_ptr;
 
     return 0;
 }
 
-static int picture_copy_props(Dav1dPicture *const p,
+void dav1d_picture_copy_props(Dav1dPicture *const p,
                               Dav1dContentLightLevel *const content_light, Dav1dRef *const content_light_ref,
                               Dav1dMasteringDisplay *const mastering_display, Dav1dRef *const mastering_display_ref,
-                              Dav1dITUTT35 **const p_itut_t35, int *const pn_itut_t35,
-                              const Dav1dDataProps *const props, int copy)
+                              Dav1dITUTT35 *const itut_t35, Dav1dRef *const itut_t35_ref,
+                              const Dav1dDataProps *const props)
 {
-    struct pic_ctx_context *const pic_ctx = p->ref->user_data;
-    Dav1dITUTT35 *const itut_t35 = *p_itut_t35;
-    int res = 0, n_itut_t35 = *pn_itut_t35;
     dav1d_data_props_copy(&p->m, props);
 
-    dav1d_ref_dec(&pic_ctx->content_light_ref);
-    pic_ctx->content_light_ref = content_light_ref;
+    dav1d_ref_dec(&p->content_light_ref);
+    p->content_light_ref = content_light_ref;
     p->content_light = content_light;
     if (content_light_ref) dav1d_ref_inc(content_light_ref);
 
-    dav1d_ref_dec(&pic_ctx->mastering_display_ref);
-    pic_ctx->mastering_display_ref = mastering_display_ref;
+    dav1d_ref_dec(&p->mastering_display_ref);
+    p->mastering_display_ref = mastering_display_ref;
     p->mastering_display = mastering_display;
     if (mastering_display_ref) dav1d_ref_inc(mastering_display_ref);
 
-    if (n_itut_t35) {
-        struct itut_t35_ctx_context *itut_t35_ctx = malloc(sizeof(struct itut_t35_ctx_context));
-        if (itut_t35_ctx == NULL) {
-            res = DAV1D_ERR(ENOMEM);
-            goto end;
-        }
-
-        if (copy) {
-            assert(n_itut_t35 < INT_MAX / (int)sizeof(*itut_t35));
-            itut_t35_ctx->itut_t35 = malloc(n_itut_t35 * sizeof(*itut_t35));
-            if (itut_t35_ctx->itut_t35 == NULL) {
-                free(itut_t35_ctx);
-                res = DAV1D_ERR(ENOMEM);
-                goto end;
-            }
-        } else
-            itut_t35_ctx->itut_t35 = itut_t35;
-
-        dav1d_ref_dec(&pic_ctx->itut_t35_ref);
-        pic_ctx->itut_t35_ref = dav1d_ref_wrap((uint8_t *)itut_t35_ctx->itut_t35,
-                                               free_itut_t35, itut_t35_ctx);
-        if (pic_ctx->itut_t35_ref == NULL) {
-            if (copy)
-                freep(&itut_t35_ctx->itut_t35);
-            freep(&itut_t35_ctx);
-            res = DAV1D_ERR(ENOMEM);
-            goto end;
-        }
-        p->itut_t35 = itut_t35_ctx->itut_t35;
-        if (copy) {
-            memcpy(p->itut_t35, itut_t35, n_itut_t35 * sizeof(*itut_t35));
-            for (int i = 0; i < n_itut_t35; i++)
-                dav1d_ref_inc(p->itut_t35[i].ref);
-        }
-        itut_t35_ctx->n_itut_t35 = n_itut_t35;
-    }
-    p->n_itut_t35 = n_itut_t35;
-
-end:
-    if (!copy) {
-        // Must be removed from the source after being attached to the picture
-        if (res < 0)
-            free(itut_t35);
-        *p_itut_t35 = NULL;
-        *pn_itut_t35 = 0;
-    }
-
-    return res;
-}
-
-int dav1d_picture_move_props(Dav1dPicture *const p,
-                             Dav1dContentLightLevel *const content_light, Dav1dRef *const content_light_ref,
-                             Dav1dMasteringDisplay *const mastering_display, Dav1dRef *const mastering_display_ref,
-                             Dav1dITUTT35 **const itut_t35, int *const n_itut_t35,
-                             const Dav1dDataProps *const props)
-{
-    return picture_copy_props(p, content_light, content_light_ref,
-                              mastering_display, mastering_display_ref,
-                              itut_t35, n_itut_t35, props, 0);
+    dav1d_ref_dec(&p->itut_t35_ref);
+    p->itut_t35_ref = itut_t35_ref;
+    p->itut_t35 = itut_t35;
+    if (itut_t35_ref) dav1d_ref_inc(itut_t35_ref);
 }
 
 int dav1d_thread_picture_alloc(Dav1dContext *const c, Dav1dFrameContext *const f,
                                const int bpc)
 {
     Dav1dThreadPicture *const p = &f->sr_cur;
     const int have_frame_mt = c->n_fc > 1;
 
-    int res =
+    const int res =
         picture_alloc_with_edges(c, &p->p, f->frame_hdr->width[1], f->frame_hdr->height,
                                  f->seq_hdr, f->seq_hdr_ref,
                                  f->frame_hdr, f->frame_hdr_ref,
+                                 c->content_light, c->content_light_ref,
+                                 c->mastering_display, c->mastering_display_ref,
+                                 c->itut_t35, c->itut_t35_ref,
                                  bpc, &f->tile[0].data.m, &c->allocator,
                                  have_frame_mt ? sizeof(atomic_int) * 2 : 0,
                                  (void **) &p->progress);
     if (res) return res;
 
-    res = dav1d_picture_move_props(&p->p, c->content_light, c->content_light_ref,
-                                   c->mastering_display, c->mastering_display_ref,
-                                   &c->itut_t35, &c->n_itut_t35, &f->tile[0].data.m);
-    if (res) return res;
+    // Must be removed from the context after being attached to the frame
+    dav1d_ref_dec(&c->itut_t35_ref);
+    c->itut_t35 = NULL;
 
     // Don't clear these flags from c->frame_flags if the frame is not visible.
     // This way they will be added to the next visible frame too.
     const int flags_mask = (f->frame_hdr->show_frame || c->output_invisible_frames)
                            ? 0 : (PICTURE_FLAG_NEW_SEQUENCE | PICTURE_FLAG_NEW_OP_PARAMS_INFO);
     p->flags = c->frame_flags;
     c->frame_flags &= flags_mask;
 
     p->visible = f->frame_hdr->show_frame;
     p->showable = f->frame_hdr->showable_frame;
     if (have_frame_mt) {
         atomic_init(&p->progress[0], 0);
         atomic_init(&p->progress[1], 0);
     }
     return res;
 }
@@ -335,33 +266,34 @@ int dav1d_thread_picture_alloc(Dav1dContext *const c, Dav1dFrameContext *const f
 int dav1d_picture_alloc_copy(Dav1dContext *const c, Dav1dPicture *const dst, const int w,
                              const Dav1dPicture *const src)
 {
     struct pic_ctx_context *const pic_ctx = src->ref->user_data;
     struct plane_ctx_context *const plane_ctx = pic_ctx->plane_ref[0]->user_data;
     const int res = picture_alloc_with_edges(c, dst, w, src->p.h,
                                              src->seq_hdr, src->seq_hdr_ref,
                                              src->frame_hdr, src->frame_hdr_ref,
+                                             src->content_light, src->content_light_ref,
+                                             src->mastering_display, src->mastering_display_ref,
+                                             src->itut_t35, src->itut_t35_ref,
                                              src->p.bpc, &src->m, &plane_ctx->allocator,
                                              0, NULL);
-    if (res) return res;
-
-    return picture_copy_props(dst, src->content_light, pic_ctx->content_light_ref,
-                              src->mastering_display, pic_ctx->mastering_display_ref,
-                              (Dav1dITUTT35 **)&src->itut_t35,
-                              (int *)&src->n_itut_t35, &src->m, 1);
+    return res;
 }
 
 void dav1d_picture_ref(Dav1dPicture *const dst, const Dav1dPicture *const src) {
     validate_input(dst != NULL);
     validate_input(dst->data[0] == NULL);
     validate_input(src != NULL);
 
     if (src->ref) {
         validate_input(src->data[0] != NULL);
         dav1d_ref_inc(src->ref);
     }
     if (src->frame_hdr_ref) dav1d_ref_inc(src->frame_hdr_ref);
     if (src->seq_hdr_ref) dav1d_ref_inc(src->seq_hdr_ref);
     if (src->m.user_data.ref) dav1d_ref_inc(src->m.user_data.ref);
+    if (src->content_light_ref) dav1d_ref_inc(src->content_light_ref);
+    if (src->mastering_display_ref) dav1d_ref_inc(src->mastering_display_ref);
+    if (src->itut_t35_ref) dav1d_ref_inc(src->itut_t35_ref);
     *dst = *src;
 }
 
@@ -401,13 +333,16 @@ void dav1d_thread_picture_move_ref(Dav1dThreadPicture *const dst,
 void dav1d_picture_unref_internal(Dav1dPicture *const p) {
     validate_input(p != NULL);
 
     if (p->ref) {
         validate_input(p->data[0] != NULL);
         dav1d_ref_dec(&p->ref);
     }
     dav1d_ref_dec(&p->seq_hdr_ref);
     dav1d_ref_dec(&p->frame_hdr_ref);
     dav1d_ref_dec(&p->m.user_data.ref);
+    dav1d_ref_dec(&p->content_light_ref);
+    dav1d_ref_dec(&p->mastering_display_ref);
+    dav1d_ref_dec(&p->itut_t35_ref);
     memset(p, 0, sizeof(*p));
     dav1d_data_props_set_defaults(&p->m);
 }
diff --git a/src/picture.h b/src/picture.h
index 9c55209..0c3a0ec 100644
--- a/src/picture.h
+++ b/src/picture.h
@@ -101,12 +101,12 @@ int dav1d_default_picture_alloc(Dav1dPicture *p, void *cookie);
 void dav1d_default_picture_release(Dav1dPicture *p, void *cookie);
 void dav1d_picture_unref_internal(Dav1dPicture *p);
 
-int dav1d_picture_move_props(Dav1dPicture *p,
-                             Dav1dContentLightLevel *content_light, Dav1dRef *content_light_ref,
-                             Dav1dMasteringDisplay *mastering_display, Dav1dRef *mastering_display_ref,
-                             Dav1dITUTT35 **itut_t35, int *n_itut_t35,
-                             const Dav1dDataProps *props);
+void dav1d_picture_copy_props(Dav1dPicture *p,
+                              Dav1dContentLightLevel *content_light, Dav1dRef *content_light_ref,
+                              Dav1dMasteringDisplay *mastering_display, Dav1dRef *mastering_display_ref,
+                              Dav1dITUTT35 *itut_t35, Dav1dRef *itut_t35_ref,
+                              const Dav1dDataProps *props);
 
 /**
  * Get event flags from picture flags.
  */
