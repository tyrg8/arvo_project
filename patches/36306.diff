commit 38fd577ded3498b3c610d5a9e046482fa6c65481
Merge: 35a0258f4 d45e78b71
Author: JacobBarthelmeh <jacob@wolfssl.com>
Date:   Tue Jul 20 18:57:48 2021 +0700

    Merge pull request #4218 from SparkiDev/sp_ecc_add_dbl
    
    SP: ecc proj add point, dbl point fix

diff --git a/wolfcrypt/src/sp_arm32.c b/wolfcrypt/src/sp_arm32.c
index d0a850577..99d4935c7 100644
--- a/wolfcrypt/src/sp_arm32.c
+++ b/wolfcrypt/src/sp_arm32.c
@@ -37490,215 +37490,223 @@ int sp_ecc_check_key_256(const mp_int* pX, const mp_int* pY,
     return err;
 }
 #endif
 #ifdef WOLFSSL_PUBLIC_ECC_ADD_DBL
 /* Add two projective EC points together.
  * (pX, pY, pZ) + (qX, qY, qZ) = (rX, rY, rZ)
  *
  * pX   First EC point's X ordinate.
  * pY   First EC point's Y ordinate.
  * pZ   First EC point's Z ordinate.
  * qX   Second EC point's X ordinate.
  * qY   Second EC point's Y ordinate.
  * qZ   Second EC point's Z ordinate.
  * rX   Resultant EC point's X ordinate.
  * rY   Resultant EC point's Y ordinate.
  * rZ   Resultant EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_proj_add_point_256(mp_int* pX, mp_int* pY, mp_int* pZ,
                               mp_int* qX, mp_int* qY, mp_int* qZ,
                               mp_int* rX, mp_int* rY, mp_int* rZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_256* p = NULL;
 #else
     sp_digit tmp[2 * 8 * 5];
     sp_point_256 p[2];
 #endif
     sp_point_256* q = NULL;
-    int err;
+    int err = MP_OKAY;
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_256*)XMALLOC(sizeof(sp_point_256) * 2, NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 8 * 5, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL) {
             err = MEMORY_E;
         }
     }
 #endif
 
     if (err == MP_OKAY) {
         q = p + 1;
 
         sp_256_from_mp(p->x, 8, pX);
         sp_256_from_mp(p->y, 8, pY);
         sp_256_from_mp(p->z, 8, pZ);
         sp_256_from_mp(q->x, 8, qX);
         sp_256_from_mp(q->y, 8, qY);
         sp_256_from_mp(q->z, 8, qZ);
+        p->infinity = sp_256_iszero_8(p->x) &
+                      sp_256_iszero_8(p->y);
+        q->infinity = sp_256_iszero_8(q->x) &
+                      sp_256_iszero_8(q->y);
 
             sp_256_proj_point_add_8(p, p, q, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->x, rX);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->y, rY);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->z, rZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 
 /* Double a projective EC point.
  * (pX, pY, pZ) + (pX, pY, pZ) = (rX, rY, rZ)
  *
  * pX   EC point's X ordinate.
  * pY   EC point's Y ordinate.
  * pZ   EC point's Z ordinate.
  * rX   Resultant EC point's X ordinate.
  * rY   Resultant EC point's Y ordinate.
  * rZ   Resultant EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_proj_dbl_point_256(mp_int* pX, mp_int* pY, mp_int* pZ,
                               mp_int* rX, mp_int* rY, mp_int* rZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_256* p = NULL;
 #else
     sp_digit tmp[2 * 8 * 2];
     sp_point_256 p[1];
 #endif
     int err = MP_OKAY;
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_256*)XMALLOC(sizeof(sp_point_256), NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 8 * 2, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL)
             err = MEMORY_E;
     }
 #endif
 
     if (err == MP_OKAY) {
         sp_256_from_mp(p->x, 8, pX);
         sp_256_from_mp(p->y, 8, pY);
         sp_256_from_mp(p->z, 8, pZ);
+        p->infinity = sp_256_iszero_8(p->x) &
+                      sp_256_iszero_8(p->y);
 
             sp_256_proj_point_dbl_8(p, p, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->x, rX);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->y, rY);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->z, rZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 
 /* Map a projective EC point to affine in place.
  * pZ will be one.
  *
  * pX   EC point's X ordinate.
  * pY   EC point's Y ordinate.
  * pZ   EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_map_256(mp_int* pX, mp_int* pY, mp_int* pZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_256* p = NULL;
 #else
     sp_digit tmp[2 * 8 * 4];
     sp_point_256 p[1];
 #endif
     int err = MP_OKAY;
 
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_256*)XMALLOC(sizeof(sp_point_256), NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 8 * 4, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL)
             err = MEMORY_E;
     }
 #endif
     if (err == MP_OKAY) {
         sp_256_from_mp(p->x, 8, pX);
         sp_256_from_mp(p->y, 8, pY);
         sp_256_from_mp(p->z, 8, pZ);
+        p->infinity = sp_256_iszero_8(p->x) &
+                      sp_256_iszero_8(p->y);
 
             sp_256_map_8(p, p, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->x, pX);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->y, pY);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->z, pZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 #endif /* WOLFSSL_PUBLIC_ECC_ADD_DBL */
 #ifdef HAVE_COMP_KEY
 /* Find the square root of a number mod the prime of the curve.
  *
  * y  The number to operate on and the result.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
@@ -46767,215 +46775,223 @@ int sp_ecc_check_key_384(const mp_int* pX, const mp_int* pY,
     return err;
 }
 #endif
 #ifdef WOLFSSL_PUBLIC_ECC_ADD_DBL
 /* Add two projective EC points together.
  * (pX, pY, pZ) + (qX, qY, qZ) = (rX, rY, rZ)
  *
  * pX   First EC point's X ordinate.
  * pY   First EC point's Y ordinate.
  * pZ   First EC point's Z ordinate.
  * qX   Second EC point's X ordinate.
  * qY   Second EC point's Y ordinate.
  * qZ   Second EC point's Z ordinate.
  * rX   Resultant EC point's X ordinate.
  * rY   Resultant EC point's Y ordinate.
  * rZ   Resultant EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_proj_add_point_384(mp_int* pX, mp_int* pY, mp_int* pZ,
                               mp_int* qX, mp_int* qY, mp_int* qZ,
                               mp_int* rX, mp_int* rY, mp_int* rZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_384* p = NULL;
 #else
     sp_digit tmp[2 * 12 * 5];
     sp_point_384 p[2];
 #endif
     sp_point_384* q = NULL;
-    int err;
+    int err = MP_OKAY;
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_384*)XMALLOC(sizeof(sp_point_384) * 2, NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 12 * 5, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL) {
             err = MEMORY_E;
         }
     }
 #endif
 
     if (err == MP_OKAY) {
         q = p + 1;
 
         sp_384_from_mp(p->x, 12, pX);
         sp_384_from_mp(p->y, 12, pY);
         sp_384_from_mp(p->z, 12, pZ);
         sp_384_from_mp(q->x, 12, qX);
         sp_384_from_mp(q->y, 12, qY);
         sp_384_from_mp(q->z, 12, qZ);
+        p->infinity = sp_384_iszero_12(p->x) &
+                      sp_384_iszero_12(p->y);
+        q->infinity = sp_384_iszero_12(q->x) &
+                      sp_384_iszero_12(q->y);
 
             sp_384_proj_point_add_12(p, p, q, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->x, rX);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->y, rY);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->z, rZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 
 /* Double a projective EC point.
  * (pX, pY, pZ) + (pX, pY, pZ) = (rX, rY, rZ)
  *
  * pX   EC point's X ordinate.
  * pY   EC point's Y ordinate.
  * pZ   EC point's Z ordinate.
  * rX   Resultant EC point's X ordinate.
  * rY   Resultant EC point's Y ordinate.
  * rZ   Resultant EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_proj_dbl_point_384(mp_int* pX, mp_int* pY, mp_int* pZ,
                               mp_int* rX, mp_int* rY, mp_int* rZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_384* p = NULL;
 #else
     sp_digit tmp[2 * 12 * 2];
     sp_point_384 p[1];
 #endif
     int err = MP_OKAY;
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_384*)XMALLOC(sizeof(sp_point_384), NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 12 * 2, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL)
             err = MEMORY_E;
     }
 #endif
 
     if (err == MP_OKAY) {
         sp_384_from_mp(p->x, 12, pX);
         sp_384_from_mp(p->y, 12, pY);
         sp_384_from_mp(p->z, 12, pZ);
+        p->infinity = sp_384_iszero_12(p->x) &
+                      sp_384_iszero_12(p->y);
 
             sp_384_proj_point_dbl_12(p, p, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->x, rX);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->y, rY);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->z, rZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 
 /* Map a projective EC point to affine in place.
  * pZ will be one.
  *
  * pX   EC point's X ordinate.
  * pY   EC point's Y ordinate.
  * pZ   EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_map_384(mp_int* pX, mp_int* pY, mp_int* pZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_384* p = NULL;
 #else
     sp_digit tmp[2 * 12 * 6];
     sp_point_384 p[1];
 #endif
     int err = MP_OKAY;
 
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_384*)XMALLOC(sizeof(sp_point_384), NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 12 * 6, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL)
             err = MEMORY_E;
     }
 #endif
     if (err == MP_OKAY) {
         sp_384_from_mp(p->x, 12, pX);
         sp_384_from_mp(p->y, 12, pY);
         sp_384_from_mp(p->z, 12, pZ);
+        p->infinity = sp_384_iszero_12(p->x) &
+                      sp_384_iszero_12(p->y);
 
             sp_384_map_12(p, p, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->x, pX);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->y, pY);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->z, pZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 #endif /* WOLFSSL_PUBLIC_ECC_ADD_DBL */
 #ifdef HAVE_COMP_KEY
 /* Find the square root of a number mod the prime of the curve.
  *
  * y  The number to operate on and the result.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
diff --git a/wolfcrypt/src/sp_arm64.c b/wolfcrypt/src/sp_arm64.c
index 88b0fc90c..478c39ed6 100644
--- a/wolfcrypt/src/sp_arm64.c
+++ b/wolfcrypt/src/sp_arm64.c
@@ -39045,215 +39045,223 @@ int sp_ecc_check_key_256(const mp_int* pX, const mp_int* pY,
     return err;
 }
 #endif
 #ifdef WOLFSSL_PUBLIC_ECC_ADD_DBL
 /* Add two projective EC points together.
  * (pX, pY, pZ) + (qX, qY, qZ) = (rX, rY, rZ)
  *
  * pX   First EC point's X ordinate.
  * pY   First EC point's Y ordinate.
  * pZ   First EC point's Z ordinate.
  * qX   Second EC point's X ordinate.
  * qY   Second EC point's Y ordinate.
  * qZ   Second EC point's Z ordinate.
  * rX   Resultant EC point's X ordinate.
  * rY   Resultant EC point's Y ordinate.
  * rZ   Resultant EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_proj_add_point_256(mp_int* pX, mp_int* pY, mp_int* pZ,
                               mp_int* qX, mp_int* qY, mp_int* qZ,
                               mp_int* rX, mp_int* rY, mp_int* rZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_256* p = NULL;
 #else
     sp_digit tmp[2 * 4 * 5];
     sp_point_256 p[2];
 #endif
     sp_point_256* q = NULL;
-    int err;
+    int err = MP_OKAY;
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_256*)XMALLOC(sizeof(sp_point_256) * 2, NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 4 * 5, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL) {
             err = MEMORY_E;
         }
     }
 #endif
 
     if (err == MP_OKAY) {
         q = p + 1;
 
         sp_256_from_mp(p->x, 4, pX);
         sp_256_from_mp(p->y, 4, pY);
         sp_256_from_mp(p->z, 4, pZ);
         sp_256_from_mp(q->x, 4, qX);
         sp_256_from_mp(q->y, 4, qY);
         sp_256_from_mp(q->z, 4, qZ);
+        p->infinity = sp_256_iszero_4(p->x) &
+                      sp_256_iszero_4(p->y);
+        q->infinity = sp_256_iszero_4(q->x) &
+                      sp_256_iszero_4(q->y);
 
             sp_256_proj_point_add_4(p, p, q, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->x, rX);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->y, rY);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->z, rZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 
 /* Double a projective EC point.
  * (pX, pY, pZ) + (pX, pY, pZ) = (rX, rY, rZ)
  *
  * pX   EC point's X ordinate.
  * pY   EC point's Y ordinate.
  * pZ   EC point's Z ordinate.
  * rX   Resultant EC point's X ordinate.
  * rY   Resultant EC point's Y ordinate.
  * rZ   Resultant EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_proj_dbl_point_256(mp_int* pX, mp_int* pY, mp_int* pZ,
                               mp_int* rX, mp_int* rY, mp_int* rZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_256* p = NULL;
 #else
     sp_digit tmp[2 * 4 * 2];
     sp_point_256 p[1];
 #endif
     int err = MP_OKAY;
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_256*)XMALLOC(sizeof(sp_point_256), NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 4 * 2, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL)
             err = MEMORY_E;
     }
 #endif
 
     if (err == MP_OKAY) {
         sp_256_from_mp(p->x, 4, pX);
         sp_256_from_mp(p->y, 4, pY);
         sp_256_from_mp(p->z, 4, pZ);
+        p->infinity = sp_256_iszero_4(p->x) &
+                      sp_256_iszero_4(p->y);
 
             sp_256_proj_point_dbl_4(p, p, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->x, rX);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->y, rY);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->z, rZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 
 /* Map a projective EC point to affine in place.
  * pZ will be one.
  *
  * pX   EC point's X ordinate.
  * pY   EC point's Y ordinate.
  * pZ   EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_map_256(mp_int* pX, mp_int* pY, mp_int* pZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_256* p = NULL;
 #else
     sp_digit tmp[2 * 4 * 4];
     sp_point_256 p[1];
 #endif
     int err = MP_OKAY;
 
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_256*)XMALLOC(sizeof(sp_point_256), NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 4 * 4, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL)
             err = MEMORY_E;
     }
 #endif
     if (err == MP_OKAY) {
         sp_256_from_mp(p->x, 4, pX);
         sp_256_from_mp(p->y, 4, pY);
         sp_256_from_mp(p->z, 4, pZ);
+        p->infinity = sp_256_iszero_4(p->x) &
+                      sp_256_iszero_4(p->y);
 
             sp_256_map_4(p, p, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->x, pX);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->y, pY);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->z, pZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 #endif /* WOLFSSL_PUBLIC_ECC_ADD_DBL */
 #ifdef HAVE_COMP_KEY
 /* Find the square root of a number mod the prime of the curve.
  *
  * y  The number to operate on and the result.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
@@ -64681,215 +64689,223 @@ int sp_ecc_check_key_384(const mp_int* pX, const mp_int* pY,
     return err;
 }
 #endif
 #ifdef WOLFSSL_PUBLIC_ECC_ADD_DBL
 /* Add two projective EC points together.
  * (pX, pY, pZ) + (qX, qY, qZ) = (rX, rY, rZ)
  *
  * pX   First EC point's X ordinate.
  * pY   First EC point's Y ordinate.
  * pZ   First EC point's Z ordinate.
  * qX   Second EC point's X ordinate.
  * qY   Second EC point's Y ordinate.
  * qZ   Second EC point's Z ordinate.
  * rX   Resultant EC point's X ordinate.
  * rY   Resultant EC point's Y ordinate.
  * rZ   Resultant EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_proj_add_point_384(mp_int* pX, mp_int* pY, mp_int* pZ,
                               mp_int* qX, mp_int* qY, mp_int* qZ,
                               mp_int* rX, mp_int* rY, mp_int* rZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_384* p = NULL;
 #else
     sp_digit tmp[2 * 6 * 5];
     sp_point_384 p[2];
 #endif
     sp_point_384* q = NULL;
-    int err;
+    int err = MP_OKAY;
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_384*)XMALLOC(sizeof(sp_point_384) * 2, NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 6 * 5, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL) {
             err = MEMORY_E;
         }
     }
 #endif
 
     if (err == MP_OKAY) {
         q = p + 1;
 
         sp_384_from_mp(p->x, 6, pX);
         sp_384_from_mp(p->y, 6, pY);
         sp_384_from_mp(p->z, 6, pZ);
         sp_384_from_mp(q->x, 6, qX);
         sp_384_from_mp(q->y, 6, qY);
         sp_384_from_mp(q->z, 6, qZ);
+        p->infinity = sp_384_iszero_6(p->x) &
+                      sp_384_iszero_6(p->y);
+        q->infinity = sp_384_iszero_6(q->x) &
+                      sp_384_iszero_6(q->y);
 
             sp_384_proj_point_add_6(p, p, q, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->x, rX);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->y, rY);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->z, rZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 
 /* Double a projective EC point.
  * (pX, pY, pZ) + (pX, pY, pZ) = (rX, rY, rZ)
  *
  * pX   EC point's X ordinate.
  * pY   EC point's Y ordinate.
  * pZ   EC point's Z ordinate.
  * rX   Resultant EC point's X ordinate.
  * rY   Resultant EC point's Y ordinate.
  * rZ   Resultant EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_proj_dbl_point_384(mp_int* pX, mp_int* pY, mp_int* pZ,
                               mp_int* rX, mp_int* rY, mp_int* rZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_384* p = NULL;
 #else
     sp_digit tmp[2 * 6 * 2];
     sp_point_384 p[1];
 #endif
     int err = MP_OKAY;
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_384*)XMALLOC(sizeof(sp_point_384), NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 6 * 2, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL)
             err = MEMORY_E;
     }
 #endif
 
     if (err == MP_OKAY) {
         sp_384_from_mp(p->x, 6, pX);
         sp_384_from_mp(p->y, 6, pY);
         sp_384_from_mp(p->z, 6, pZ);
+        p->infinity = sp_384_iszero_6(p->x) &
+                      sp_384_iszero_6(p->y);
 
             sp_384_proj_point_dbl_6(p, p, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->x, rX);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->y, rY);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->z, rZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 
 /* Map a projective EC point to affine in place.
  * pZ will be one.
  *
  * pX   EC point's X ordinate.
  * pY   EC point's Y ordinate.
  * pZ   EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_map_384(mp_int* pX, mp_int* pY, mp_int* pZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_384* p = NULL;
 #else
     sp_digit tmp[2 * 6 * 6];
     sp_point_384 p[1];
 #endif
     int err = MP_OKAY;
 
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_384*)XMALLOC(sizeof(sp_point_384), NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 6 * 6, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL)
             err = MEMORY_E;
     }
 #endif
     if (err == MP_OKAY) {
         sp_384_from_mp(p->x, 6, pX);
         sp_384_from_mp(p->y, 6, pY);
         sp_384_from_mp(p->z, 6, pZ);
+        p->infinity = sp_384_iszero_6(p->x) &
+                      sp_384_iszero_6(p->y);
 
             sp_384_map_6(p, p, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->x, pX);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->y, pY);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->z, pZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 #endif /* WOLFSSL_PUBLIC_ECC_ADD_DBL */
 #ifdef HAVE_COMP_KEY
 /* Find the square root of a number mod the prime of the curve.
  *
  * y  The number to operate on and the result.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
diff --git a/wolfcrypt/src/sp_armthumb.c b/wolfcrypt/src/sp_armthumb.c
index 42909b897..0cd63fff2 100644
--- a/wolfcrypt/src/sp_armthumb.c
+++ b/wolfcrypt/src/sp_armthumb.c
@@ -41915,215 +41915,223 @@ int sp_ecc_check_key_256(const mp_int* pX, const mp_int* pY,
     return err;
 }
 #endif
 #ifdef WOLFSSL_PUBLIC_ECC_ADD_DBL
 /* Add two projective EC points together.
  * (pX, pY, pZ) + (qX, qY, qZ) = (rX, rY, rZ)
  *
  * pX   First EC point's X ordinate.
  * pY   First EC point's Y ordinate.
  * pZ   First EC point's Z ordinate.
  * qX   Second EC point's X ordinate.
  * qY   Second EC point's Y ordinate.
  * qZ   Second EC point's Z ordinate.
  * rX   Resultant EC point's X ordinate.
  * rY   Resultant EC point's Y ordinate.
  * rZ   Resultant EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_proj_add_point_256(mp_int* pX, mp_int* pY, mp_int* pZ,
                               mp_int* qX, mp_int* qY, mp_int* qZ,
                               mp_int* rX, mp_int* rY, mp_int* rZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_256* p = NULL;
 #else
     sp_digit tmp[2 * 8 * 5];
     sp_point_256 p[2];
 #endif
     sp_point_256* q = NULL;
-    int err;
+    int err = MP_OKAY;
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_256*)XMALLOC(sizeof(sp_point_256) * 2, NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 8 * 5, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL) {
             err = MEMORY_E;
         }
     }
 #endif
 
     if (err == MP_OKAY) {
         q = p + 1;
 
         sp_256_from_mp(p->x, 8, pX);
         sp_256_from_mp(p->y, 8, pY);
         sp_256_from_mp(p->z, 8, pZ);
         sp_256_from_mp(q->x, 8, qX);
         sp_256_from_mp(q->y, 8, qY);
         sp_256_from_mp(q->z, 8, qZ);
+        p->infinity = sp_256_iszero_8(p->x) &
+                      sp_256_iszero_8(p->y);
+        q->infinity = sp_256_iszero_8(q->x) &
+                      sp_256_iszero_8(q->y);
 
             sp_256_proj_point_add_8(p, p, q, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->x, rX);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->y, rY);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->z, rZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 
 /* Double a projective EC point.
  * (pX, pY, pZ) + (pX, pY, pZ) = (rX, rY, rZ)
  *
  * pX   EC point's X ordinate.
  * pY   EC point's Y ordinate.
  * pZ   EC point's Z ordinate.
  * rX   Resultant EC point's X ordinate.
  * rY   Resultant EC point's Y ordinate.
  * rZ   Resultant EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_proj_dbl_point_256(mp_int* pX, mp_int* pY, mp_int* pZ,
                               mp_int* rX, mp_int* rY, mp_int* rZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_256* p = NULL;
 #else
     sp_digit tmp[2 * 8 * 2];
     sp_point_256 p[1];
 #endif
     int err = MP_OKAY;
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_256*)XMALLOC(sizeof(sp_point_256), NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 8 * 2, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL)
             err = MEMORY_E;
     }
 #endif
 
     if (err == MP_OKAY) {
         sp_256_from_mp(p->x, 8, pX);
         sp_256_from_mp(p->y, 8, pY);
         sp_256_from_mp(p->z, 8, pZ);
+        p->infinity = sp_256_iszero_8(p->x) &
+                      sp_256_iszero_8(p->y);
 
             sp_256_proj_point_dbl_8(p, p, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->x, rX);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->y, rY);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->z, rZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 
 /* Map a projective EC point to affine in place.
  * pZ will be one.
  *
  * pX   EC point's X ordinate.
  * pY   EC point's Y ordinate.
  * pZ   EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_map_256(mp_int* pX, mp_int* pY, mp_int* pZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_256* p = NULL;
 #else
     sp_digit tmp[2 * 8 * 4];
     sp_point_256 p[1];
 #endif
     int err = MP_OKAY;
 
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_256*)XMALLOC(sizeof(sp_point_256), NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 8 * 4, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL)
             err = MEMORY_E;
     }
 #endif
     if (err == MP_OKAY) {
         sp_256_from_mp(p->x, 8, pX);
         sp_256_from_mp(p->y, 8, pY);
         sp_256_from_mp(p->z, 8, pZ);
+        p->infinity = sp_256_iszero_8(p->x) &
+                      sp_256_iszero_8(p->y);
 
             sp_256_map_8(p, p, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->x, pX);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->y, pY);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->z, pZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 #endif /* WOLFSSL_PUBLIC_ECC_ADD_DBL */
 #ifdef HAVE_COMP_KEY
 /* Find the square root of a number mod the prime of the curve.
  *
  * y  The number to operate on and the result.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
@@ -52313,215 +52321,223 @@ int sp_ecc_check_key_384(const mp_int* pX, const mp_int* pY,
     return err;
 }
 #endif
 #ifdef WOLFSSL_PUBLIC_ECC_ADD_DBL
 /* Add two projective EC points together.
  * (pX, pY, pZ) + (qX, qY, qZ) = (rX, rY, rZ)
  *
  * pX   First EC point's X ordinate.
  * pY   First EC point's Y ordinate.
  * pZ   First EC point's Z ordinate.
  * qX   Second EC point's X ordinate.
  * qY   Second EC point's Y ordinate.
  * qZ   Second EC point's Z ordinate.
  * rX   Resultant EC point's X ordinate.
  * rY   Resultant EC point's Y ordinate.
  * rZ   Resultant EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_proj_add_point_384(mp_int* pX, mp_int* pY, mp_int* pZ,
                               mp_int* qX, mp_int* qY, mp_int* qZ,
                               mp_int* rX, mp_int* rY, mp_int* rZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_384* p = NULL;
 #else
     sp_digit tmp[2 * 12 * 5];
     sp_point_384 p[2];
 #endif
     sp_point_384* q = NULL;
-    int err;
+    int err = MP_OKAY;
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_384*)XMALLOC(sizeof(sp_point_384) * 2, NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 12 * 5, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL) {
             err = MEMORY_E;
         }
     }
 #endif
 
     if (err == MP_OKAY) {
         q = p + 1;
 
         sp_384_from_mp(p->x, 12, pX);
         sp_384_from_mp(p->y, 12, pY);
         sp_384_from_mp(p->z, 12, pZ);
         sp_384_from_mp(q->x, 12, qX);
         sp_384_from_mp(q->y, 12, qY);
         sp_384_from_mp(q->z, 12, qZ);
+        p->infinity = sp_384_iszero_12(p->x) &
+                      sp_384_iszero_12(p->y);
+        q->infinity = sp_384_iszero_12(q->x) &
+                      sp_384_iszero_12(q->y);
 
             sp_384_proj_point_add_12(p, p, q, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->x, rX);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->y, rY);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->z, rZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 
 /* Double a projective EC point.
  * (pX, pY, pZ) + (pX, pY, pZ) = (rX, rY, rZ)
  *
  * pX   EC point's X ordinate.
  * pY   EC point's Y ordinate.
  * pZ   EC point's Z ordinate.
  * rX   Resultant EC point's X ordinate.
  * rY   Resultant EC point's Y ordinate.
  * rZ   Resultant EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_proj_dbl_point_384(mp_int* pX, mp_int* pY, mp_int* pZ,
                               mp_int* rX, mp_int* rY, mp_int* rZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_384* p = NULL;
 #else
     sp_digit tmp[2 * 12 * 2];
     sp_point_384 p[1];
 #endif
     int err = MP_OKAY;
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_384*)XMALLOC(sizeof(sp_point_384), NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 12 * 2, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL)
             err = MEMORY_E;
     }
 #endif
 
     if (err == MP_OKAY) {
         sp_384_from_mp(p->x, 12, pX);
         sp_384_from_mp(p->y, 12, pY);
         sp_384_from_mp(p->z, 12, pZ);
+        p->infinity = sp_384_iszero_12(p->x) &
+                      sp_384_iszero_12(p->y);
 
             sp_384_proj_point_dbl_12(p, p, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->x, rX);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->y, rY);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->z, rZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 
 /* Map a projective EC point to affine in place.
  * pZ will be one.
  *
  * pX   EC point's X ordinate.
  * pY   EC point's Y ordinate.
  * pZ   EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_map_384(mp_int* pX, mp_int* pY, mp_int* pZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_384* p = NULL;
 #else
     sp_digit tmp[2 * 12 * 6];
     sp_point_384 p[1];
 #endif
     int err = MP_OKAY;
 
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_384*)XMALLOC(sizeof(sp_point_384), NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 12 * 6, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL)
             err = MEMORY_E;
     }
 #endif
     if (err == MP_OKAY) {
         sp_384_from_mp(p->x, 12, pX);
         sp_384_from_mp(p->y, 12, pY);
         sp_384_from_mp(p->z, 12, pZ);
+        p->infinity = sp_384_iszero_12(p->x) &
+                      sp_384_iszero_12(p->y);
 
             sp_384_map_12(p, p, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->x, pX);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->y, pY);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->z, pZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 #endif /* WOLFSSL_PUBLIC_ECC_ADD_DBL */
 #ifdef HAVE_COMP_KEY
 /* Find the square root of a number mod the prime of the curve.
  *
  * y  The number to operate on and the result.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
diff --git a/wolfcrypt/src/sp_c32.c b/wolfcrypt/src/sp_c32.c
index 087d6e16a..390a6b767 100644
--- a/wolfcrypt/src/sp_c32.c
+++ b/wolfcrypt/src/sp_c32.c
@@ -19089,215 +19089,223 @@ int sp_ecc_check_key_256(const mp_int* pX, const mp_int* pY,
     return err;
 }
 #endif
 #ifdef WOLFSSL_PUBLIC_ECC_ADD_DBL
 /* Add two projective EC points together.
  * (pX, pY, pZ) + (qX, qY, qZ) = (rX, rY, rZ)
  *
  * pX   First EC point's X ordinate.
  * pY   First EC point's Y ordinate.
  * pZ   First EC point's Z ordinate.
  * qX   Second EC point's X ordinate.
  * qY   Second EC point's Y ordinate.
  * qZ   Second EC point's Z ordinate.
  * rX   Resultant EC point's X ordinate.
  * rY   Resultant EC point's Y ordinate.
  * rZ   Resultant EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_proj_add_point_256(mp_int* pX, mp_int* pY, mp_int* pZ,
                               mp_int* qX, mp_int* qY, mp_int* qZ,
                               mp_int* rX, mp_int* rY, mp_int* rZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_256* p = NULL;
 #else
     sp_digit tmp[2 * 10 * 5];
     sp_point_256 p[2];
 #endif
     sp_point_256* q = NULL;
     int err = MP_OKAY;
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_256*)XMALLOC(sizeof(sp_point_256) * 2, NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 10 * 5, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL) {
             err = MEMORY_E;
         }
     }
 #endif
 
     if (err == MP_OKAY) {
         q = p + 1;
 
         sp_256_from_mp(p->x, 10, pX);
         sp_256_from_mp(p->y, 10, pY);
         sp_256_from_mp(p->z, 10, pZ);
         sp_256_from_mp(q->x, 10, qX);
         sp_256_from_mp(q->y, 10, qY);
         sp_256_from_mp(q->z, 10, qZ);
+        p->infinity = sp_256_iszero_10(p->x) &
+                      sp_256_iszero_10(p->y);
+        q->infinity = sp_256_iszero_10(q->x) &
+                      sp_256_iszero_10(q->y);
 
             sp_256_proj_point_add_10(p, p, q, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->x, rX);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->y, rY);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->z, rZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 
 /* Double a projective EC point.
  * (pX, pY, pZ) + (pX, pY, pZ) = (rX, rY, rZ)
  *
  * pX   EC point's X ordinate.
  * pY   EC point's Y ordinate.
  * pZ   EC point's Z ordinate.
  * rX   Resultant EC point's X ordinate.
  * rY   Resultant EC point's Y ordinate.
  * rZ   Resultant EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_proj_dbl_point_256(mp_int* pX, mp_int* pY, mp_int* pZ,
                               mp_int* rX, mp_int* rY, mp_int* rZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_256* p = NULL;
 #else
     sp_digit tmp[2 * 10 * 2];
     sp_point_256 p[1];
 #endif
     int err = MP_OKAY;
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_256*)XMALLOC(sizeof(sp_point_256), NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 10 * 2, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL)
             err = MEMORY_E;
     }
 #endif
 
     if (err == MP_OKAY) {
         sp_256_from_mp(p->x, 10, pX);
         sp_256_from_mp(p->y, 10, pY);
         sp_256_from_mp(p->z, 10, pZ);
+        p->infinity = sp_256_iszero_10(p->x) &
+                      sp_256_iszero_10(p->y);
 
             sp_256_proj_point_dbl_10(p, p, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->x, rX);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->y, rY);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->z, rZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 
 /* Map a projective EC point to affine in place.
  * pZ will be one.
  *
  * pX   EC point's X ordinate.
  * pY   EC point's Y ordinate.
  * pZ   EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_map_256(mp_int* pX, mp_int* pY, mp_int* pZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_256* p = NULL;
 #else
     sp_digit tmp[2 * 10 * 4];
     sp_point_256 p[1];
 #endif
     int err = MP_OKAY;
 
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_256*)XMALLOC(sizeof(sp_point_256), NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 10 * 4, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL)
             err = MEMORY_E;
     }
 #endif
     if (err == MP_OKAY) {
         sp_256_from_mp(p->x, 10, pX);
         sp_256_from_mp(p->y, 10, pY);
         sp_256_from_mp(p->z, 10, pZ);
+        p->infinity = sp_256_iszero_10(p->x) &
+                      sp_256_iszero_10(p->y);
 
             sp_256_map_10(p, p, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->x, pX);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->y, pY);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->z, pZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 #endif /* WOLFSSL_PUBLIC_ECC_ADD_DBL */
 #ifdef HAVE_COMP_KEY
 /* Find the square root of a number mod the prime of the curve.
  *
  * y  The number to operate on and the result.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
@@ -26818,215 +26826,223 @@ int sp_ecc_check_key_384(const mp_int* pX, const mp_int* pY,
     return err;
 }
 #endif
 #ifdef WOLFSSL_PUBLIC_ECC_ADD_DBL
 /* Add two projective EC points together.
  * (pX, pY, pZ) + (qX, qY, qZ) = (rX, rY, rZ)
  *
  * pX   First EC point's X ordinate.
  * pY   First EC point's Y ordinate.
  * pZ   First EC point's Z ordinate.
  * qX   Second EC point's X ordinate.
  * qY   Second EC point's Y ordinate.
  * qZ   Second EC point's Z ordinate.
  * rX   Resultant EC point's X ordinate.
  * rY   Resultant EC point's Y ordinate.
  * rZ   Resultant EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_proj_add_point_384(mp_int* pX, mp_int* pY, mp_int* pZ,
                               mp_int* qX, mp_int* qY, mp_int* qZ,
                               mp_int* rX, mp_int* rY, mp_int* rZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_384* p = NULL;
 #else
     sp_digit tmp[2 * 15 * 5];
     sp_point_384 p[2];
 #endif
     sp_point_384* q = NULL;
     int err = MP_OKAY;
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_384*)XMALLOC(sizeof(sp_point_384) * 2, NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 15 * 5, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL) {
             err = MEMORY_E;
         }
     }
 #endif
 
     if (err == MP_OKAY) {
         q = p + 1;
 
         sp_384_from_mp(p->x, 15, pX);
         sp_384_from_mp(p->y, 15, pY);
         sp_384_from_mp(p->z, 15, pZ);
         sp_384_from_mp(q->x, 15, qX);
         sp_384_from_mp(q->y, 15, qY);
         sp_384_from_mp(q->z, 15, qZ);
+        p->infinity = sp_384_iszero_15(p->x) &
+                      sp_384_iszero_15(p->y);
+        q->infinity = sp_384_iszero_15(q->x) &
+                      sp_384_iszero_15(q->y);
 
             sp_384_proj_point_add_15(p, p, q, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->x, rX);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->y, rY);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->z, rZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 
 /* Double a projective EC point.
  * (pX, pY, pZ) + (pX, pY, pZ) = (rX, rY, rZ)
  *
  * pX   EC point's X ordinate.
  * pY   EC point's Y ordinate.
  * pZ   EC point's Z ordinate.
  * rX   Resultant EC point's X ordinate.
  * rY   Resultant EC point's Y ordinate.
  * rZ   Resultant EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_proj_dbl_point_384(mp_int* pX, mp_int* pY, mp_int* pZ,
                               mp_int* rX, mp_int* rY, mp_int* rZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_384* p = NULL;
 #else
     sp_digit tmp[2 * 15 * 2];
     sp_point_384 p[1];
 #endif
     int err = MP_OKAY;
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_384*)XMALLOC(sizeof(sp_point_384), NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 15 * 2, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL)
             err = MEMORY_E;
     }
 #endif
 
     if (err == MP_OKAY) {
         sp_384_from_mp(p->x, 15, pX);
         sp_384_from_mp(p->y, 15, pY);
         sp_384_from_mp(p->z, 15, pZ);
+        p->infinity = sp_384_iszero_15(p->x) &
+                      sp_384_iszero_15(p->y);
 
             sp_384_proj_point_dbl_15(p, p, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->x, rX);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->y, rY);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->z, rZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 
 /* Map a projective EC point to affine in place.
  * pZ will be one.
  *
  * pX   EC point's X ordinate.
  * pY   EC point's Y ordinate.
  * pZ   EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_map_384(mp_int* pX, mp_int* pY, mp_int* pZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_384* p = NULL;
 #else
     sp_digit tmp[2 * 15 * 6];
     sp_point_384 p[1];
 #endif
     int err = MP_OKAY;
 
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_384*)XMALLOC(sizeof(sp_point_384), NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 15 * 6, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL)
             err = MEMORY_E;
     }
 #endif
     if (err == MP_OKAY) {
         sp_384_from_mp(p->x, 15, pX);
         sp_384_from_mp(p->y, 15, pY);
         sp_384_from_mp(p->z, 15, pZ);
+        p->infinity = sp_384_iszero_15(p->x) &
+                      sp_384_iszero_15(p->y);
 
             sp_384_map_15(p, p, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->x, pX);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->y, pY);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->z, pZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 #endif /* WOLFSSL_PUBLIC_ECC_ADD_DBL */
 #ifdef HAVE_COMP_KEY
 /* Find the square root of a number mod the prime of the curve.
  *
  * y  The number to operate on and the result.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
diff --git a/wolfcrypt/src/sp_c64.c b/wolfcrypt/src/sp_c64.c
index 6172e8023..5983b9816 100644
--- a/wolfcrypt/src/sp_c64.c
+++ b/wolfcrypt/src/sp_c64.c
@@ -18872,215 +18872,223 @@ int sp_ecc_check_key_256(const mp_int* pX, const mp_int* pY,
     return err;
 }
 #endif
 #ifdef WOLFSSL_PUBLIC_ECC_ADD_DBL
 /* Add two projective EC points together.
  * (pX, pY, pZ) + (qX, qY, qZ) = (rX, rY, rZ)
  *
  * pX   First EC point's X ordinate.
  * pY   First EC point's Y ordinate.
  * pZ   First EC point's Z ordinate.
  * qX   Second EC point's X ordinate.
  * qY   Second EC point's Y ordinate.
  * qZ   Second EC point's Z ordinate.
  * rX   Resultant EC point's X ordinate.
  * rY   Resultant EC point's Y ordinate.
  * rZ   Resultant EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_proj_add_point_256(mp_int* pX, mp_int* pY, mp_int* pZ,
                               mp_int* qX, mp_int* qY, mp_int* qZ,
                               mp_int* rX, mp_int* rY, mp_int* rZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_256* p = NULL;
 #else
     sp_digit tmp[2 * 5 * 5];
     sp_point_256 p[2];
 #endif
     sp_point_256* q = NULL;
     int err = MP_OKAY;
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_256*)XMALLOC(sizeof(sp_point_256) * 2, NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 5 * 5, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL) {
             err = MEMORY_E;
         }
     }
 #endif
 
     if (err == MP_OKAY) {
         q = p + 1;
 
         sp_256_from_mp(p->x, 5, pX);
         sp_256_from_mp(p->y, 5, pY);
         sp_256_from_mp(p->z, 5, pZ);
         sp_256_from_mp(q->x, 5, qX);
         sp_256_from_mp(q->y, 5, qY);
         sp_256_from_mp(q->z, 5, qZ);
+        p->infinity = sp_256_iszero_5(p->x) &
+                      sp_256_iszero_5(p->y);
+        q->infinity = sp_256_iszero_5(q->x) &
+                      sp_256_iszero_5(q->y);
 
             sp_256_proj_point_add_5(p, p, q, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->x, rX);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->y, rY);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->z, rZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 
 /* Double a projective EC point.
  * (pX, pY, pZ) + (pX, pY, pZ) = (rX, rY, rZ)
  *
  * pX   EC point's X ordinate.
  * pY   EC point's Y ordinate.
  * pZ   EC point's Z ordinate.
  * rX   Resultant EC point's X ordinate.
  * rY   Resultant EC point's Y ordinate.
  * rZ   Resultant EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_proj_dbl_point_256(mp_int* pX, mp_int* pY, mp_int* pZ,
                               mp_int* rX, mp_int* rY, mp_int* rZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_256* p = NULL;
 #else
     sp_digit tmp[2 * 5 * 2];
     sp_point_256 p[1];
 #endif
     int err = MP_OKAY;
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_256*)XMALLOC(sizeof(sp_point_256), NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 5 * 2, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL)
             err = MEMORY_E;
     }
 #endif
 
     if (err == MP_OKAY) {
         sp_256_from_mp(p->x, 5, pX);
         sp_256_from_mp(p->y, 5, pY);
         sp_256_from_mp(p->z, 5, pZ);
+        p->infinity = sp_256_iszero_5(p->x) &
+                      sp_256_iszero_5(p->y);
 
             sp_256_proj_point_dbl_5(p, p, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->x, rX);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->y, rY);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->z, rZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 
 /* Map a projective EC point to affine in place.
  * pZ will be one.
  *
  * pX   EC point's X ordinate.
  * pY   EC point's Y ordinate.
  * pZ   EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_map_256(mp_int* pX, mp_int* pY, mp_int* pZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_256* p = NULL;
 #else
     sp_digit tmp[2 * 5 * 4];
     sp_point_256 p[1];
 #endif
     int err = MP_OKAY;
 
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_256*)XMALLOC(sizeof(sp_point_256), NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 5 * 4, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL)
             err = MEMORY_E;
     }
 #endif
     if (err == MP_OKAY) {
         sp_256_from_mp(p->x, 5, pX);
         sp_256_from_mp(p->y, 5, pY);
         sp_256_from_mp(p->z, 5, pZ);
+        p->infinity = sp_256_iszero_5(p->x) &
+                      sp_256_iszero_5(p->y);
 
             sp_256_map_5(p, p, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->x, pX);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->y, pY);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->z, pZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 #endif /* WOLFSSL_PUBLIC_ECC_ADD_DBL */
 #ifdef HAVE_COMP_KEY
 /* Find the square root of a number mod the prime of the curve.
  *
  * y  The number to operate on and the result.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
@@ -26072,215 +26080,223 @@ int sp_ecc_check_key_384(const mp_int* pX, const mp_int* pY,
     return err;
 }
 #endif
 #ifdef WOLFSSL_PUBLIC_ECC_ADD_DBL
 /* Add two projective EC points together.
  * (pX, pY, pZ) + (qX, qY, qZ) = (rX, rY, rZ)
  *
  * pX   First EC point's X ordinate.
  * pY   First EC point's Y ordinate.
  * pZ   First EC point's Z ordinate.
  * qX   Second EC point's X ordinate.
  * qY   Second EC point's Y ordinate.
  * qZ   Second EC point's Z ordinate.
  * rX   Resultant EC point's X ordinate.
  * rY   Resultant EC point's Y ordinate.
  * rZ   Resultant EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_proj_add_point_384(mp_int* pX, mp_int* pY, mp_int* pZ,
                               mp_int* qX, mp_int* qY, mp_int* qZ,
                               mp_int* rX, mp_int* rY, mp_int* rZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_384* p = NULL;
 #else
     sp_digit tmp[2 * 7 * 5];
     sp_point_384 p[2];
 #endif
     sp_point_384* q = NULL;
     int err = MP_OKAY;
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_384*)XMALLOC(sizeof(sp_point_384) * 2, NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 7 * 5, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL) {
             err = MEMORY_E;
         }
     }
 #endif
 
     if (err == MP_OKAY) {
         q = p + 1;
 
         sp_384_from_mp(p->x, 7, pX);
         sp_384_from_mp(p->y, 7, pY);
         sp_384_from_mp(p->z, 7, pZ);
         sp_384_from_mp(q->x, 7, qX);
         sp_384_from_mp(q->y, 7, qY);
         sp_384_from_mp(q->z, 7, qZ);
+        p->infinity = sp_384_iszero_7(p->x) &
+                      sp_384_iszero_7(p->y);
+        q->infinity = sp_384_iszero_7(q->x) &
+                      sp_384_iszero_7(q->y);
 
             sp_384_proj_point_add_7(p, p, q, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->x, rX);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->y, rY);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->z, rZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 
 /* Double a projective EC point.
  * (pX, pY, pZ) + (pX, pY, pZ) = (rX, rY, rZ)
  *
  * pX   EC point's X ordinate.
  * pY   EC point's Y ordinate.
  * pZ   EC point's Z ordinate.
  * rX   Resultant EC point's X ordinate.
  * rY   Resultant EC point's Y ordinate.
  * rZ   Resultant EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_proj_dbl_point_384(mp_int* pX, mp_int* pY, mp_int* pZ,
                               mp_int* rX, mp_int* rY, mp_int* rZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_384* p = NULL;
 #else
     sp_digit tmp[2 * 7 * 2];
     sp_point_384 p[1];
 #endif
     int err = MP_OKAY;
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_384*)XMALLOC(sizeof(sp_point_384), NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 7 * 2, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL)
             err = MEMORY_E;
     }
 #endif
 
     if (err == MP_OKAY) {
         sp_384_from_mp(p->x, 7, pX);
         sp_384_from_mp(p->y, 7, pY);
         sp_384_from_mp(p->z, 7, pZ);
+        p->infinity = sp_384_iszero_7(p->x) &
+                      sp_384_iszero_7(p->y);
 
             sp_384_proj_point_dbl_7(p, p, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->x, rX);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->y, rY);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->z, rZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 
 /* Map a projective EC point to affine in place.
  * pZ will be one.
  *
  * pX   EC point's X ordinate.
  * pY   EC point's Y ordinate.
  * pZ   EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_map_384(mp_int* pX, mp_int* pY, mp_int* pZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_384* p = NULL;
 #else
     sp_digit tmp[2 * 7 * 6];
     sp_point_384 p[1];
 #endif
     int err = MP_OKAY;
 
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_384*)XMALLOC(sizeof(sp_point_384), NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 7 * 6, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL)
             err = MEMORY_E;
     }
 #endif
     if (err == MP_OKAY) {
         sp_384_from_mp(p->x, 7, pX);
         sp_384_from_mp(p->y, 7, pY);
         sp_384_from_mp(p->z, 7, pZ);
+        p->infinity = sp_384_iszero_7(p->x) &
+                      sp_384_iszero_7(p->y);
 
             sp_384_map_7(p, p, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->x, pX);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->y, pY);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->z, pZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 #endif /* WOLFSSL_PUBLIC_ECC_ADD_DBL */
 #ifdef HAVE_COMP_KEY
 /* Find the square root of a number mod the prime of the curve.
  *
  * y  The number to operate on and the result.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
diff --git a/wolfcrypt/src/sp_cortexm.c b/wolfcrypt/src/sp_cortexm.c
index 7abd4dc61..d3607ab33 100644
--- a/wolfcrypt/src/sp_cortexm.c
+++ b/wolfcrypt/src/sp_cortexm.c
@@ -22834,215 +22834,223 @@ int sp_ecc_check_key_256(const mp_int* pX, const mp_int* pY,
     return err;
 }
 #endif
 #ifdef WOLFSSL_PUBLIC_ECC_ADD_DBL
 /* Add two projective EC points together.
  * (pX, pY, pZ) + (qX, qY, qZ) = (rX, rY, rZ)
  *
  * pX   First EC point's X ordinate.
  * pY   First EC point's Y ordinate.
  * pZ   First EC point's Z ordinate.
  * qX   Second EC point's X ordinate.
  * qY   Second EC point's Y ordinate.
  * qZ   Second EC point's Z ordinate.
  * rX   Resultant EC point's X ordinate.
  * rY   Resultant EC point's Y ordinate.
  * rZ   Resultant EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_proj_add_point_256(mp_int* pX, mp_int* pY, mp_int* pZ,
                               mp_int* qX, mp_int* qY, mp_int* qZ,
                               mp_int* rX, mp_int* rY, mp_int* rZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_256* p = NULL;
 #else
     sp_digit tmp[2 * 8 * 5];
     sp_point_256 p[2];
 #endif
     sp_point_256* q = NULL;
     int err = MP_OKAY;
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_256*)XMALLOC(sizeof(sp_point_256) * 2, NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 8 * 5, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL) {
             err = MEMORY_E;
         }
     }
 #endif
 
     if (err == MP_OKAY) {
         q = p + 1;
 
         sp_256_from_mp(p->x, 8, pX);
         sp_256_from_mp(p->y, 8, pY);
         sp_256_from_mp(p->z, 8, pZ);
         sp_256_from_mp(q->x, 8, qX);
         sp_256_from_mp(q->y, 8, qY);
         sp_256_from_mp(q->z, 8, qZ);
+        p->infinity = sp_256_iszero_8(p->x) &
+                      sp_256_iszero_8(p->y);
+        q->infinity = sp_256_iszero_8(q->x) &
+                      sp_256_iszero_8(q->y);
 
             sp_256_proj_point_add_8(p, p, q, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->x, rX);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->y, rY);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->z, rZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 
 /* Double a projective EC point.
  * (pX, pY, pZ) + (pX, pY, pZ) = (rX, rY, rZ)
  *
  * pX   EC point's X ordinate.
  * pY   EC point's Y ordinate.
  * pZ   EC point's Z ordinate.
  * rX   Resultant EC point's X ordinate.
  * rY   Resultant EC point's Y ordinate.
  * rZ   Resultant EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_proj_dbl_point_256(mp_int* pX, mp_int* pY, mp_int* pZ,
                               mp_int* rX, mp_int* rY, mp_int* rZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_256* p = NULL;
 #else
     sp_digit tmp[2 * 8 * 2];
     sp_point_256 p[1];
 #endif
     int err = MP_OKAY;
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_256*)XMALLOC(sizeof(sp_point_256), NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 8 * 2, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL)
             err = MEMORY_E;
     }
 #endif
 
     if (err == MP_OKAY) {
         sp_256_from_mp(p->x, 8, pX);
         sp_256_from_mp(p->y, 8, pY);
         sp_256_from_mp(p->z, 8, pZ);
+        p->infinity = sp_256_iszero_8(p->x) &
+                      sp_256_iszero_8(p->y);
 
             sp_256_proj_point_dbl_8(p, p, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->x, rX);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->y, rY);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->z, rZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 
 /* Map a projective EC point to affine in place.
  * pZ will be one.
  *
  * pX   EC point's X ordinate.
  * pY   EC point's Y ordinate.
  * pZ   EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_map_256(mp_int* pX, mp_int* pY, mp_int* pZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_256* p = NULL;
 #else
     sp_digit tmp[2 * 8 * 4];
     sp_point_256 p[1];
 #endif
     int err = MP_OKAY;
 
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_256*)XMALLOC(sizeof(sp_point_256), NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 8 * 4, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL)
             err = MEMORY_E;
     }
 #endif
     if (err == MP_OKAY) {
         sp_256_from_mp(p->x, 8, pX);
         sp_256_from_mp(p->y, 8, pY);
         sp_256_from_mp(p->z, 8, pZ);
+        p->infinity = sp_256_iszero_8(p->x) &
+                      sp_256_iszero_8(p->y);
 
             sp_256_map_8(p, p, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->x, pX);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->y, pY);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->z, pZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 #endif /* WOLFSSL_PUBLIC_ECC_ADD_DBL */
 #ifdef HAVE_COMP_KEY
 /* Find the square root of a number mod the prime of the curve.
  *
  * y  The number to operate on and the result.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
@@ -30057,215 +30065,223 @@ int sp_ecc_check_key_384(const mp_int* pX, const mp_int* pY,
     return err;
 }
 #endif
 #ifdef WOLFSSL_PUBLIC_ECC_ADD_DBL
 /* Add two projective EC points together.
  * (pX, pY, pZ) + (qX, qY, qZ) = (rX, rY, rZ)
  *
  * pX   First EC point's X ordinate.
  * pY   First EC point's Y ordinate.
  * pZ   First EC point's Z ordinate.
  * qX   Second EC point's X ordinate.
  * qY   Second EC point's Y ordinate.
  * qZ   Second EC point's Z ordinate.
  * rX   Resultant EC point's X ordinate.
  * rY   Resultant EC point's Y ordinate.
  * rZ   Resultant EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_proj_add_point_384(mp_int* pX, mp_int* pY, mp_int* pZ,
                               mp_int* qX, mp_int* qY, mp_int* qZ,
                               mp_int* rX, mp_int* rY, mp_int* rZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_384* p = NULL;
 #else
     sp_digit tmp[2 * 12 * 5];
     sp_point_384 p[2];
 #endif
     sp_point_384* q = NULL;
     int err = MP_OKAY;
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_384*)XMALLOC(sizeof(sp_point_384) * 2, NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 12 * 5, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL) {
             err = MEMORY_E;
         }
     }
 #endif
 
     if (err == MP_OKAY) {
         q = p + 1;
 
         sp_384_from_mp(p->x, 12, pX);
         sp_384_from_mp(p->y, 12, pY);
         sp_384_from_mp(p->z, 12, pZ);
         sp_384_from_mp(q->x, 12, qX);
         sp_384_from_mp(q->y, 12, qY);
         sp_384_from_mp(q->z, 12, qZ);
+        p->infinity = sp_384_iszero_12(p->x) &
+                      sp_384_iszero_12(p->y);
+        q->infinity = sp_384_iszero_12(q->x) &
+                      sp_384_iszero_12(q->y);
 
             sp_384_proj_point_add_12(p, p, q, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->x, rX);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->y, rY);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->z, rZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 
 /* Double a projective EC point.
  * (pX, pY, pZ) + (pX, pY, pZ) = (rX, rY, rZ)
  *
  * pX   EC point's X ordinate.
  * pY   EC point's Y ordinate.
  * pZ   EC point's Z ordinate.
  * rX   Resultant EC point's X ordinate.
  * rY   Resultant EC point's Y ordinate.
  * rZ   Resultant EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_proj_dbl_point_384(mp_int* pX, mp_int* pY, mp_int* pZ,
                               mp_int* rX, mp_int* rY, mp_int* rZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_384* p = NULL;
 #else
     sp_digit tmp[2 * 12 * 2];
     sp_point_384 p[1];
 #endif
     int err = MP_OKAY;
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_384*)XMALLOC(sizeof(sp_point_384), NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 12 * 2, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL)
             err = MEMORY_E;
     }
 #endif
 
     if (err == MP_OKAY) {
         sp_384_from_mp(p->x, 12, pX);
         sp_384_from_mp(p->y, 12, pY);
         sp_384_from_mp(p->z, 12, pZ);
+        p->infinity = sp_384_iszero_12(p->x) &
+                      sp_384_iszero_12(p->y);
 
             sp_384_proj_point_dbl_12(p, p, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->x, rX);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->y, rY);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->z, rZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 
 /* Map a projective EC point to affine in place.
  * pZ will be one.
  *
  * pX   EC point's X ordinate.
  * pY   EC point's Y ordinate.
  * pZ   EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_map_384(mp_int* pX, mp_int* pY, mp_int* pZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_384* p = NULL;
 #else
     sp_digit tmp[2 * 12 * 6];
     sp_point_384 p[1];
 #endif
     int err = MP_OKAY;
 
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_384*)XMALLOC(sizeof(sp_point_384), NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 12 * 6, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL)
             err = MEMORY_E;
     }
 #endif
     if (err == MP_OKAY) {
         sp_384_from_mp(p->x, 12, pX);
         sp_384_from_mp(p->y, 12, pY);
         sp_384_from_mp(p->z, 12, pZ);
+        p->infinity = sp_384_iszero_12(p->x) &
+                      sp_384_iszero_12(p->y);
 
             sp_384_map_12(p, p, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->x, pX);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->y, pY);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->z, pZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 #endif /* WOLFSSL_PUBLIC_ECC_ADD_DBL */
 #ifdef HAVE_COMP_KEY
 /* Find the square root of a number mod the prime of the curve.
  *
  * y  The number to operate on and the result.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
diff --git a/wolfcrypt/src/sp_x86_64.c b/wolfcrypt/src/sp_x86_64.c
index 19436d0f6..c4e26e1b8 100644
--- a/wolfcrypt/src/sp_x86_64.c
+++ b/wolfcrypt/src/sp_x86_64.c
@@ -24564,239 +24564,247 @@ int sp_ecc_check_key_256(const mp_int* pX, const mp_int* pY,
     return err;
 }
 #endif
 #ifdef WOLFSSL_PUBLIC_ECC_ADD_DBL
 /* Add two projective EC points together.
  * (pX, pY, pZ) + (qX, qY, qZ) = (rX, rY, rZ)
  *
  * pX   First EC point's X ordinate.
  * pY   First EC point's Y ordinate.
  * pZ   First EC point's Z ordinate.
  * qX   Second EC point's X ordinate.
  * qY   Second EC point's Y ordinate.
  * qZ   Second EC point's Z ordinate.
  * rX   Resultant EC point's X ordinate.
  * rY   Resultant EC point's Y ordinate.
  * rZ   Resultant EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_proj_add_point_256(mp_int* pX, mp_int* pY, mp_int* pZ,
                               mp_int* qX, mp_int* qY, mp_int* qZ,
                               mp_int* rX, mp_int* rY, mp_int* rZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_256* p = NULL;
 #else
     sp_digit tmp[2 * 4 * 5];
     sp_point_256 p[2];
 #endif
     sp_point_256* q = NULL;
-    int err;
+    int err = MP_OKAY;
 #ifdef HAVE_INTEL_AVX2
     word32 cpuid_flags = cpuid_get_flags();
 #endif
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_256*)XMALLOC(sizeof(sp_point_256) * 2, NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 4 * 5, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL) {
             err = MEMORY_E;
         }
     }
 #endif
 
     if (err == MP_OKAY) {
         q = p + 1;
 
         sp_256_from_mp(p->x, 4, pX);
         sp_256_from_mp(p->y, 4, pY);
         sp_256_from_mp(p->z, 4, pZ);
         sp_256_from_mp(q->x, 4, qX);
         sp_256_from_mp(q->y, 4, qY);
         sp_256_from_mp(q->z, 4, qZ);
+        p->infinity = sp_256_iszero_4(p->x) &
+                      sp_256_iszero_4(p->y);
+        q->infinity = sp_256_iszero_4(q->x) &
+                      sp_256_iszero_4(q->y);
 
 #ifdef HAVE_INTEL_AVX2
         if (IS_INTEL_BMI2(cpuid_flags) && IS_INTEL_ADX(cpuid_flags))
             sp_256_proj_point_add_avx2_4(p, p, q, tmp);
         else
 #endif
             sp_256_proj_point_add_4(p, p, q, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->x, rX);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->y, rY);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->z, rZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 
 /* Double a projective EC point.
  * (pX, pY, pZ) + (pX, pY, pZ) = (rX, rY, rZ)
  *
  * pX   EC point's X ordinate.
  * pY   EC point's Y ordinate.
  * pZ   EC point's Z ordinate.
  * rX   Resultant EC point's X ordinate.
  * rY   Resultant EC point's Y ordinate.
  * rZ   Resultant EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_proj_dbl_point_256(mp_int* pX, mp_int* pY, mp_int* pZ,
                               mp_int* rX, mp_int* rY, mp_int* rZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_256* p = NULL;
 #else
     sp_digit tmp[2 * 4 * 2];
     sp_point_256 p[1];
 #endif
     int err = MP_OKAY;
 #ifdef HAVE_INTEL_AVX2
     word32 cpuid_flags = cpuid_get_flags();
 #endif
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_256*)XMALLOC(sizeof(sp_point_256), NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 4 * 2, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL)
             err = MEMORY_E;
     }
 #endif
 
     if (err == MP_OKAY) {
         sp_256_from_mp(p->x, 4, pX);
         sp_256_from_mp(p->y, 4, pY);
         sp_256_from_mp(p->z, 4, pZ);
+        p->infinity = sp_256_iszero_4(p->x) &
+                      sp_256_iszero_4(p->y);
 
 #ifdef HAVE_INTEL_AVX2
         if (IS_INTEL_BMI2(cpuid_flags) && IS_INTEL_ADX(cpuid_flags))
             sp_256_proj_point_dbl_avx2_4(p, p, tmp);
         else
 #endif
             sp_256_proj_point_dbl_4(p, p, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->x, rX);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->y, rY);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->z, rZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 
 /* Map a projective EC point to affine in place.
  * pZ will be one.
  *
  * pX   EC point's X ordinate.
  * pY   EC point's Y ordinate.
  * pZ   EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_map_256(mp_int* pX, mp_int* pY, mp_int* pZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_256* p = NULL;
 #else
     sp_digit tmp[2 * 4 * 4];
     sp_point_256 p[1];
 #endif
     int err = MP_OKAY;
 
 #ifdef HAVE_INTEL_AVX2
     word32 cpuid_flags = cpuid_get_flags();
 #endif
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_256*)XMALLOC(sizeof(sp_point_256), NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 4 * 4, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL)
             err = MEMORY_E;
     }
 #endif
     if (err == MP_OKAY) {
         sp_256_from_mp(p->x, 4, pX);
         sp_256_from_mp(p->y, 4, pY);
         sp_256_from_mp(p->z, 4, pZ);
+        p->infinity = sp_256_iszero_4(p->x) &
+                      sp_256_iszero_4(p->y);
 
 #ifdef HAVE_INTEL_AVX2
         if (IS_INTEL_BMI2(cpuid_flags) && IS_INTEL_ADX(cpuid_flags))
             sp_256_map_avx2_4(point, point, tmp);
         else
 #endif
             sp_256_map_4(p, p, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->x, pX);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->y, pY);
     }
     if (err == MP_OKAY) {
         err = sp_256_to_mp(p->z, pZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 #endif /* WOLFSSL_PUBLIC_ECC_ADD_DBL */
 #ifdef HAVE_COMP_KEY
 /* Find the square root of a number mod the prime of the curve.
  *
  * y  The number to operate on and the result.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
@@ -49138,239 +49146,247 @@ int sp_ecc_check_key_384(const mp_int* pX, const mp_int* pY,
     return err;
 }
 #endif
 #ifdef WOLFSSL_PUBLIC_ECC_ADD_DBL
 /* Add two projective EC points together.
  * (pX, pY, pZ) + (qX, qY, qZ) = (rX, rY, rZ)
  *
  * pX   First EC point's X ordinate.
  * pY   First EC point's Y ordinate.
  * pZ   First EC point's Z ordinate.
  * qX   Second EC point's X ordinate.
  * qY   Second EC point's Y ordinate.
  * qZ   Second EC point's Z ordinate.
  * rX   Resultant EC point's X ordinate.
  * rY   Resultant EC point's Y ordinate.
  * rZ   Resultant EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_proj_add_point_384(mp_int* pX, mp_int* pY, mp_int* pZ,
                               mp_int* qX, mp_int* qY, mp_int* qZ,
                               mp_int* rX, mp_int* rY, mp_int* rZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_384* p = NULL;
 #else
     sp_digit tmp[2 * 6 * 5];
     sp_point_384 p[2];
 #endif
     sp_point_384* q = NULL;
-    int err;
+    int err = MP_OKAY;
 #ifdef HAVE_INTEL_AVX2
     word32 cpuid_flags = cpuid_get_flags();
 #endif
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_384*)XMALLOC(sizeof(sp_point_384) * 2, NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 6 * 5, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL) {
             err = MEMORY_E;
         }
     }
 #endif
 
     if (err == MP_OKAY) {
         q = p + 1;
 
         sp_384_from_mp(p->x, 6, pX);
         sp_384_from_mp(p->y, 6, pY);
         sp_384_from_mp(p->z, 6, pZ);
         sp_384_from_mp(q->x, 6, qX);
         sp_384_from_mp(q->y, 6, qY);
         sp_384_from_mp(q->z, 6, qZ);
+        p->infinity = sp_384_iszero_6(p->x) &
+                      sp_384_iszero_6(p->y);
+        q->infinity = sp_384_iszero_6(q->x) &
+                      sp_384_iszero_6(q->y);
 
 #ifdef HAVE_INTEL_AVX2
         if (IS_INTEL_BMI2(cpuid_flags) && IS_INTEL_ADX(cpuid_flags))
             sp_384_proj_point_add_avx2_6(p, p, q, tmp);
         else
 #endif
             sp_384_proj_point_add_6(p, p, q, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->x, rX);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->y, rY);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->z, rZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 
 /* Double a projective EC point.
  * (pX, pY, pZ) + (pX, pY, pZ) = (rX, rY, rZ)
  *
  * pX   EC point's X ordinate.
  * pY   EC point's Y ordinate.
  * pZ   EC point's Z ordinate.
  * rX   Resultant EC point's X ordinate.
  * rY   Resultant EC point's Y ordinate.
  * rZ   Resultant EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_proj_dbl_point_384(mp_int* pX, mp_int* pY, mp_int* pZ,
                               mp_int* rX, mp_int* rY, mp_int* rZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_384* p = NULL;
 #else
     sp_digit tmp[2 * 6 * 2];
     sp_point_384 p[1];
 #endif
     int err = MP_OKAY;
 #ifdef HAVE_INTEL_AVX2
     word32 cpuid_flags = cpuid_get_flags();
 #endif
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_384*)XMALLOC(sizeof(sp_point_384), NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 6 * 2, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL)
             err = MEMORY_E;
     }
 #endif
 
     if (err == MP_OKAY) {
         sp_384_from_mp(p->x, 6, pX);
         sp_384_from_mp(p->y, 6, pY);
         sp_384_from_mp(p->z, 6, pZ);
+        p->infinity = sp_384_iszero_6(p->x) &
+                      sp_384_iszero_6(p->y);
 
 #ifdef HAVE_INTEL_AVX2
         if (IS_INTEL_BMI2(cpuid_flags) && IS_INTEL_ADX(cpuid_flags))
             sp_384_proj_point_dbl_avx2_6(p, p, tmp);
         else
 #endif
             sp_384_proj_point_dbl_6(p, p, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->x, rX);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->y, rY);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->z, rZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 
 /* Map a projective EC point to affine in place.
  * pZ will be one.
  *
  * pX   EC point's X ordinate.
  * pY   EC point's Y ordinate.
  * pZ   EC point's Z ordinate.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
 int sp_ecc_map_384(mp_int* pX, mp_int* pY, mp_int* pZ)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* tmp = NULL;
     sp_point_384* p = NULL;
 #else
     sp_digit tmp[2 * 6 * 6];
     sp_point_384 p[1];
 #endif
     int err = MP_OKAY;
 
 #ifdef HAVE_INTEL_AVX2
     word32 cpuid_flags = cpuid_get_flags();
 #endif
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         p = (sp_point_384*)XMALLOC(sizeof(sp_point_384), NULL,
                                          DYNAMIC_TYPE_ECC);
         if (p == NULL)
             err = MEMORY_E;
     }
     if (err == MP_OKAY) {
         tmp = (sp_digit*)XMALLOC(sizeof(sp_digit) * 2 * 6 * 6, NULL,
                                  DYNAMIC_TYPE_ECC);
         if (tmp == NULL)
             err = MEMORY_E;
     }
 #endif
     if (err == MP_OKAY) {
         sp_384_from_mp(p->x, 6, pX);
         sp_384_from_mp(p->y, 6, pY);
         sp_384_from_mp(p->z, 6, pZ);
+        p->infinity = sp_384_iszero_6(p->x) &
+                      sp_384_iszero_6(p->y);
 
 #ifdef HAVE_INTEL_AVX2
         if (IS_INTEL_BMI2(cpuid_flags) && IS_INTEL_ADX(cpuid_flags))
             sp_384_map_avx2_6(point, point, tmp);
         else
 #endif
             sp_384_map_6(p, p, tmp);
     }
 
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->x, pX);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->y, pY);
     }
     if (err == MP_OKAY) {
         err = sp_384_to_mp(p->z, pZ);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (tmp != NULL)
         XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
     if (p != NULL)
         XFREE(p, NULL, DYNAMIC_TYPE_ECC);
 #endif
 
     return err;
 }
 #endif /* WOLFSSL_PUBLIC_ECC_ADD_DBL */
 #ifdef HAVE_COMP_KEY
 /* Find the square root of a number mod the prime of the curve.
  *
  * y  The number to operate on and the result.
  * returns MEMORY_E if dynamic memory allocation fails and MP_OKAY otherwise.
  */
