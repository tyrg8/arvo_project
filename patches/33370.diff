commit 6d9c0a4ad586bee773dc079ed52a72a73cd2342d
Author: Cristy <mikayla-grace@urban-warrior.org>
Date:   Sat Jan 2 16:58:54 2021 -0500

    use LONG_MIN define rather than SSIZE_MAX

diff --git a/MagickCore/blob.c b/MagickCore/blob.c
index fa19f5e5d..2a2dc025a 100644
--- a/MagickCore/blob.c
+++ b/MagickCore/blob.c
@@ -306,116 +306,116 @@ MagickExport void AttachCustomStream(BlobInfo *blob_info,
   CustomStreamInfo *custom_stream)
 {
   assert(blob_info != (BlobInfo *) NULL);
   assert(custom_stream != (CustomStreamInfo *) NULL);
   assert(custom_stream->signature == MagickCoreSignature);
   if (blob_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"...");
   blob_info->type=CustomStream;
   blob_info->custom_stream=custom_stream;
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 +   B l o b T o F i l e                                                       %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  BlobToFile() writes a blob to a file.  It returns MagickFalse if an error
 %  occurs otherwise MagickTrue.
 %
 %  The format of the BlobToFile method is:
 %
 %       MagickBooleanType BlobToFile(char *filename,const void *blob,
 %         const size_t length,ExceptionInfo *exception)
 %
 %  A description of each parameter follows:
 %
 %    o filename: Write the blob to this file.
 %
 %    o blob: the address of a blob.
 %
 %    o length: This length in bytes of the blob.
 %
 %    o exception: return any errors or warnings in this structure.
 %
 */
 MagickExport MagickBooleanType BlobToFile(char *filename,const void *blob,
   const size_t length,ExceptionInfo *exception)
 {
   int
     file;
 
   size_t
     i;
 
   ssize_t
     count;
 
   assert(filename != (const char *) NULL);
   (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",filename);
   assert(blob != (const void *) NULL);
   if (*filename == '\0')
     file=AcquireUniqueFileResource(filename);
   else
     file=open_utf8(filename,O_RDWR | O_CREAT | O_EXCL | O_BINARY,S_MODE);
   if (file == -1)
     {
       ThrowFileException(exception,BlobError,"UnableToWriteBlob",filename);
       return(MagickFalse);
     }
   for (i=0; i < length; i+=count)
   {
     count=write(file,(const char *) blob+i,MagickMin(length-i,(size_t)
-      SSIZE_MAX));
+      LONG_MAX));
     if (count <= 0)
       {
         count=0;
         if (errno != EINTR)
           break;
       }
   }
   file=close(file);
   if ((file == -1) || (i < length))
     {
       ThrowFileException(exception,BlobError,"UnableToWriteBlob",filename);
       return(MagickFalse);
     }
   return(MagickTrue);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   B l o b T o I m a g e                                                     %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  BlobToImage() implements direct to memory image formats.  It returns the
 %  blob as an image.
 %
 %  The format of the BlobToImage method is:
 %
 %      Image *BlobToImage(const ImageInfo *image_info,const void *blob,
 %        const size_t length,ExceptionInfo *exception)
 %
 %  A description of each parameter follows:
 %
 %    o image_info: the image info.
 %
 %    o blob: the address of a character stream in one of the image formats
 %      understood by ImageMagick.
 %
 %    o length: This size_t integer reflects the length in bytes of the blob.
 %
 %    o exception: return any errors or warnings in this structure.
 %
 */
@@ -1313,267 +1313,267 @@ MagickExport int ErrorBlob(const Image *image)
   assert(image != (Image *) NULL);
   assert(image->signature == MagickCoreSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"...");
   assert(image->blob != (BlobInfo *) NULL);
   assert(image->blob->type != UndefinedStream);
   blob_info=image->blob;
   switch (blob_info->type)
   {
     case UndefinedStream:
     case StandardStream:
       break;
     case FileStream:
     case PipeStream:
     {
       blob_info->error=ferror(blob_info->file_info.file);
       break;
     }
     case ZipStream:
     {
 #if defined(MAGICKCORE_ZLIB_DELEGATE)
       (void) gzerror(blob_info->file_info.gzfile,&blob_info->error);
 #endif
       break;
     }
     case BZipStream:
     {
 #if defined(MAGICKCORE_BZLIB_DELEGATE)
       (void) BZ2_bzerror(blob_info->file_info.bzfile,&blob_info->error);
 #endif
       break;
     }
     case FifoStream:
     {
       blob_info->error=0;
       break;
     }
     case BlobStream:
       break;
     case CustomStream:
       break;
   }
   return(blob_info->error);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   F i l e T o B l o b                                                       %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  FileToBlob() returns the contents of a file as a buffer terminated with
 %  the '\0' character.  The length of the buffer (not including the extra
 %  terminating '\0' character) is returned via the 'length' parameter.  Free
 %  the buffer with RelinquishMagickMemory().
 %
 %  The format of the FileToBlob method is:
 %
 %      void *FileToBlob(const char *filename,const size_t extent,
 %        size_t *length,ExceptionInfo *exception)
 %
 %  A description of each parameter follows:
 %
 %    o blob:  FileToBlob() returns the contents of a file as a blob.  If
 %      an error occurs NULL is returned.
 %
 %    o filename: the filename.
 %
 %    o extent:  The maximum length of the blob.
 %
 %    o length: On return, this reflects the actual length of the blob.
 %
 %    o exception: return any errors or warnings in this structure.
 %
 */
 MagickExport void *FileToBlob(const char *filename,const size_t extent,
   size_t *length,ExceptionInfo *exception)
 {
   int
     file;
 
   MagickBooleanType
     status;
 
   MagickOffsetType
     offset;
 
   size_t
     i;
 
   ssize_t
     count;
 
   struct stat
     attributes;
 
   unsigned char
     *blob;
 
   void
     *map;
 
   assert(filename != (const char *) NULL);
   (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",filename);
   assert(exception != (ExceptionInfo *) NULL);
   *length=0;
   status=IsRightsAuthorized(PathPolicyDomain,ReadPolicyRights,filename);
   if (status == MagickFalse)
     {
       errno=EPERM;
       (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,
         "NotAuthorized","`%s'",filename);
       return(NULL);
     }
   file=fileno(stdin);
   if (LocaleCompare(filename,"-") != 0)
     {
       status=GetPathAttributes(filename,&attributes);
       if ((status == MagickFalse) || (S_ISDIR(attributes.st_mode) != 0))
         {
           ThrowFileException(exception,BlobError,"UnableToReadBlob",filename);
           return(NULL);
         }
       file=open_utf8(filename,O_RDONLY | O_BINARY,0);
     }
   if (file == -1)
     {
       ThrowFileException(exception,BlobError,"UnableToOpenFile",filename);
       return(NULL);
     }
   offset=(MagickOffsetType) lseek(file,0,SEEK_END);
   count=0;
   if ((file == fileno(stdin)) || (offset < 0) ||
       (offset != (MagickOffsetType) ((ssize_t) offset)))
     {
       size_t
         quantum;
 
       struct stat
         file_stats;
 
       /*
         Stream is not seekable.
       */
       offset=(MagickOffsetType) lseek(file,0,SEEK_SET);
       quantum=(size_t) MagickMaxBufferExtent;
       if ((fstat(file,&file_stats) == 0) && (file_stats.st_size > 0))
         quantum=(size_t) MagickMin(file_stats.st_size,MagickMaxBufferExtent);
       blob=(unsigned char *) AcquireQuantumMemory(quantum,sizeof(*blob));
       for (i=0; blob != (unsigned char *) NULL; i+=count)
       {
         count=read(file,blob+i,quantum);
         if (count <= 0)
           {
             count=0;
             if (errno != EINTR)
               break;
           }
         if (~((size_t) i) < (quantum+1))
           {
             blob=(unsigned char *) RelinquishMagickMemory(blob);
             break;
           }
         blob=(unsigned char *) ResizeQuantumMemory(blob,i+quantum+1,
           sizeof(*blob));
         if ((size_t) (i+count) >= extent)
           break;
       }
       if (LocaleCompare(filename,"-") != 0)
         file=close(file);
       if (blob == (unsigned char *) NULL)
         {
           (void) ThrowMagickException(exception,GetMagickModule(),
             ResourceLimitError,"MemoryAllocationFailed","`%s'",filename);
           return(NULL);
         }
       if (file == -1)
         {
           blob=(unsigned char *) RelinquishMagickMemory(blob);
           ThrowFileException(exception,BlobError,"UnableToReadBlob",filename);
           return(NULL);
         }
       *length=(size_t) MagickMin(i+count,extent);
       blob[*length]='\0';
       return(blob);
     }
   *length=(size_t) MagickMin(offset,(MagickOffsetType)
-    MagickMin(extent,(size_t) SSIZE_MAX));
+    MagickMin(extent,(size_t) LONG_MAX));
   blob=(unsigned char *) NULL;
   if (~(*length) >= (MagickPathExtent-1))
     blob=(unsigned char *) AcquireQuantumMemory(*length+MagickPathExtent,
       sizeof(*blob));
   if (blob == (unsigned char *) NULL)
     {
       file=close(file);
       (void) ThrowMagickException(exception,GetMagickModule(),
         ResourceLimitError,"MemoryAllocationFailed","`%s'",filename);
       return(NULL);
     }
   map=MapBlob(file,ReadMode,0,*length);
   if (map != (unsigned char *) NULL)
     {
       (void) memcpy(blob,map,*length);
       (void) UnmapBlob(map,*length);
     }
   else
     {
       (void) lseek(file,0,SEEK_SET);
       for (i=0; i < *length; i+=count)
       {
         count=read(file,blob+i,(size_t) MagickMin(*length-i,(size_t)
-          SSIZE_MAX));
+          LONG_MAX));
         if (count <= 0)
           {
             count=0;
             if (errno != EINTR)
               break;
           }
       }
       if (i < *length)
         {
           file=close(file)-1;
           blob=(unsigned char *) RelinquishMagickMemory(blob);
           ThrowFileException(exception,BlobError,"UnableToReadBlob",filename);
           return(NULL);
         }
     }
   blob[*length]='\0';
   if (LocaleCompare(filename,"-") != 0)
     file=close(file);
   if (file == -1)
     {
       blob=(unsigned char *) RelinquishMagickMemory(blob);
       ThrowFileException(exception,BlobError,"UnableToReadBlob",filename);
     }
   return(blob);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   F i l e T o I m a g e                                                     %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  FileToImage() write the contents of a file to an image.
 %
 %  The format of the FileToImage method is:
 %
 %      MagickBooleanType FileToImage(Image *,const char *filename)
 %
 %  A description of each parameter follows:
 %
 %    o image: the image.
 %
 %    o filename: the filename.
 %
 */
@@ -3593,133 +3593,133 @@ static size_t PingStream(const Image *magick_unused(image),
 MagickExport Image *PingBlob(const ImageInfo *image_info,const void *blob,
   const size_t length,ExceptionInfo *exception)
 {
   const MagickInfo
     *magick_info;
 
   Image
     *image;
 
   ImageInfo
     *clone_info,
     *ping_info;
 
   MagickBooleanType
     status;
 
   assert(image_info != (ImageInfo *) NULL);
   assert(image_info->signature == MagickCoreSignature);
   if (image_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",
       image_info->filename);
   assert(exception != (ExceptionInfo *) NULL);
   if ((blob == (const void *) NULL) || (length == 0))
     {
       (void) ThrowMagickException(exception,GetMagickModule(),BlobError,
         "ZeroLengthBlobNotPermitted","`%s'",image_info->filename);
       return((Image *) NULL);
     }
   ping_info=CloneImageInfo(image_info);
   ping_info->blob=(void *) blob;
   ping_info->length=length;
   ping_info->ping=MagickTrue;
   if (*ping_info->magick == '\0')
     (void) SetImageInfo(ping_info,0,exception);
   magick_info=GetMagickInfo(ping_info->magick,exception);
   if (magick_info == (const MagickInfo *) NULL)
     {
       (void) ThrowMagickException(exception,GetMagickModule(),
         MissingDelegateError,"NoDecodeDelegateForThisImageFormat","`%s'",
         ping_info->magick);
       ping_info=DestroyImageInfo(ping_info);
       return((Image *) NULL);
     }
   if (GetMagickBlobSupport(magick_info) != MagickFalse)
     {
       char
         filename[MagickPathExtent];
 
       /*
         Native blob support for this image format.
       */
       (void) CopyMagickString(filename,ping_info->filename,MagickPathExtent);
       (void) FormatLocaleString(ping_info->filename,MagickPathExtent,"%s:%s",
         ping_info->magick,filename);
       image=ReadStream(ping_info,&PingStream,exception);
       if (image != (Image *) NULL)
         (void) DetachBlob(image->blob);
       ping_info=DestroyImageInfo(ping_info);
       return(image);
     }
   /*
     Write blob to a temporary file on disk.
   */
   ping_info->blob=(void *) NULL;
   ping_info->length=0;
   *ping_info->filename='\0';
   status=BlobToFile(ping_info->filename,blob,length,exception);
   if (status == MagickFalse)
     {
       (void) RelinquishUniqueFileResource(ping_info->filename);
       ping_info=DestroyImageInfo(ping_info);
       return((Image *) NULL);
     }
   clone_info=CloneImageInfo(ping_info);
   (void) FormatLocaleString(clone_info->filename,MagickPathExtent,"%s:%s",
     ping_info->magick,ping_info->filename);
   image=ReadStream(clone_info,&PingStream,exception);
   if (image != (Image *) NULL)
     {
       Image
         *images;
 
       /*
         Restore original filenames and image format.
       */
       for (images=GetFirstImageInList(image); images != (Image *) NULL; )
       {
         (void) CopyMagickString(images->filename,image_info->filename,
           MagickPathExtent);
         (void) CopyMagickString(images->magick_filename,image_info->filename,
           MagickPathExtent);
         (void) CopyMagickString(images->magick,magick_info->name,
           MagickPathExtent);
         images=GetNextImageInList(images);
       }
     }
   clone_info=DestroyImageInfo(clone_info);
   (void) RelinquishUniqueFileResource(ping_info->filename);
   ping_info=DestroyImageInfo(ping_info);
   return(image);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 +  R e a d B l o b                                                            %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  ReadBlob() reads data from the blob or image file and returns it.  It
 %  returns the number of bytes read. If length is zero, ReadBlob() returns
-%  zero and has no other results. If length is greater than SSIZE_MAX, the
+%  zero and has no other results. If length is greater than LONG_MAX, the
 %  result is unspecified.
 %
 %  The format of the ReadBlob method is:
 %
 %      ssize_t ReadBlob(Image *image,const size_t length,void *data)
 %
 %  A description of each parameter follows:
 %
 %    o image: the image.
 %
 %    o length:  Specifies an integer representing the number of bytes to read
 %      from the file.
 %
 %    o data:  Specifies an area to place the information requested from the
 %      file.
 %
 */
@@ -4697,77 +4697,77 @@ MagickExport signed int ReadBlobSignedLong(Image *image)
   quantum.unsigned_value=ReadBlobLong(image);
   return(quantum.signed_value);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 +  R e a d B l o b S i g n e d S h o r t                                      %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  ReadBlobSignedShort() reads a signed short value as a 16-bit quantity in the
 %  byte-order specified by the endian member of the image structure.
 %
 %  The format of the ReadBlobSignedShort method is:
 %
 %      signed short ReadBlobSignedShort(Image *image)
 %
 %  A description of each parameter follows.
 %
 %    o image: the image.
 %
 */
 MagickExport signed short ReadBlobSignedShort(Image *image)
 {
   union
   {
     unsigned short
       unsigned_value;
 
     signed short
       signed_value;
   } quantum;
 
   quantum.unsigned_value=ReadBlobShort(image);
   return(quantum.signed_value);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 +  R e a d B l o b S t r e a m                                                %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  ReadBlobStream() reads data from the blob or image file and returns it.  It
 %  returns a pointer to the data buffer you supply or to the image memory
 %  buffer if its supported (zero-copy). If length is zero, ReadBlobStream()
 %  returns a count of zero and has no other results. If length is greater than
-%  SSIZE_MAX, the result is unspecified.
+%  LONG_MAX, the result is unspecified.
 %
 %  The format of the ReadBlobStream method is:
 %
 %      const void *ReadBlobStream(Image *image,const size_t length,
 %        void *magick_restrict data,ssize_t *count)
 %
 %  A description of each parameter follows:
 %
 %    o image: the image.
 %
 %    o length:  Specifies an integer representing the number of bytes to read
 %      from the file.
 %
 %    o count: returns the number of bytes read.
 %
 %    o data:  Specifies an area to place the information requested from the
 %      file.
 %
 */
@@ -4887,165 +4887,165 @@ MagickExport BlobInfo *ReferenceBlob(BlobInfo *blob)
 {
   assert(blob != (BlobInfo *) NULL);
   assert(blob->signature == MagickCoreSignature);
   if (blob->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"...");
   LockSemaphoreInfo(blob->semaphore);
   blob->reference_count++;
   UnlockSemaphoreInfo(blob->semaphore);
   return(blob);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 +  S e e k B l o b                                                            %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  SeekBlob() sets the offset in bytes from the beginning of a blob or file
 %  and returns the resulting offset.
 %
 %  The format of the SeekBlob method is:
 %
 %      MagickOffsetType SeekBlob(Image *image,const MagickOffsetType offset,
 %        const int whence)
 %
 %  A description of each parameter follows:
 %
 %    o image: the image.
 %
 %    o offset:  Specifies an integer representing the offset in bytes.
 %
 %    o whence:  Specifies an integer representing how the offset is
 %      treated relative to the beginning of the blob as follows:
 %
 %        SEEK_SET  Set position equal to offset bytes.
 %        SEEK_CUR  Set position to current location plus offset.
 %        SEEK_END  Set position to EOF plus offset.
 %
 */
 MagickExport MagickOffsetType SeekBlob(Image *image,
   const MagickOffsetType offset,const int whence)
 {
   BlobInfo
     *magick_restrict blob_info;
 
   assert(image != (Image *) NULL);
   assert(image->signature == MagickCoreSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
   assert(image->blob != (BlobInfo *) NULL);
   assert(image->blob->type != UndefinedStream);
   blob_info=image->blob;
   switch (blob_info->type)
   {
     case UndefinedStream:
       break;
     case StandardStream:
     case PipeStream:
       return(-1);
     case FileStream:
     {
       if ((offset < 0) && (whence == SEEK_SET))
         return(-1);
       if (fseek(blob_info->file_info.file,offset,whence) < 0)
         return(-1);
       blob_info->offset=TellBlob(image);
       break;
     }
     case ZipStream:
     {
 #if defined(MAGICKCORE_ZLIB_DELEGATE)
       if (gzseek(blob_info->file_info.gzfile,offset,whence) < 0)
         return(-1);
 #endif
       blob_info->offset=TellBlob(image);
       break;
     }
     case BZipStream:
       return(-1);
     case FifoStream:
       return(-1);
     case BlobStream:
     {
       switch (whence)
       {
         case SEEK_SET:
         default:
         {
           if (offset < 0)
             return(-1);
           blob_info->offset=offset;
           break;
         }
         case SEEK_CUR:
         {
-          if (((offset > 0) && (blob_info->offset > (SSIZE_MAX-offset))) ||
-              ((offset < 0) && (blob_info->offset < (-SSIZE_MAX-offset))))
+          if (((offset > 0) && (blob_info->offset > (LONG_MAX-offset))) ||
+              ((offset < 0) && (blob_info->offset < (LONG_MIN-offset))))
             {
               errno=EOVERFLOW;
               return(-1);
             }
           if ((blob_info->offset+offset) < 0)
             return(-1);
           blob_info->offset+=offset;
           break;
         }
         case SEEK_END:
         {
           if (((MagickOffsetType) blob_info->length+offset) < 0)
             return(-1);
           blob_info->offset=blob_info->length+offset;
           break;
         }
       }
       if (blob_info->offset < (MagickOffsetType) ((off_t) blob_info->length))
         {
           blob_info->eof=MagickFalse;
           break;
         }
       if (blob_info->offset >= (MagickOffsetType) ((off_t) blob_info->extent))
         return(-1);
       break;
     }
     case CustomStream:
     {
       if (blob_info->custom_stream->seeker == (CustomStreamSeeker) NULL)
         return(-1);
       blob_info->offset=blob_info->custom_stream->seeker(offset,whence,
         blob_info->custom_stream->data);
       break;
     }
   }
   return(blob_info->offset);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 +   S e t B l o b E x e m p t                                                 %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  SetBlobExempt() sets the blob exempt status.
 %
 %  The format of the SetBlobExempt method is:
 %
 %      MagickBooleanType SetBlobExempt(const Image *image,
 %        const MagickBooleanType exempt)
 %
 %  A description of each parameter follows:
 %
 %    o image: the image.
 %
 %    o exempt: Set to true if this blob is exempt from being closed.
 %
 */
diff --git a/MagickCore/cache.c b/MagickCore/cache.c
index 6076f19ca..8a58f0c0d 100644
--- a/MagickCore/cache.c
+++ b/MagickCore/cache.c
@@ -163,98 +163,98 @@ static time_t
   cache_epoch = 0;
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 +   A c q u i r e P i x e l C a c h e                                         %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  AcquirePixelCache() acquires a pixel cache.
 %
 %  The format of the AcquirePixelCache() method is:
 %
 %      Cache AcquirePixelCache(const size_t number_threads)
 %
 %  A description of each parameter follows:
 %
 %    o number_threads: the number of nexus threads.
 %
 */
 MagickPrivate Cache AcquirePixelCache(const size_t number_threads)
 {
   CacheInfo
     *magick_restrict cache_info;
 
   char
     *value;
 
   cache_info=(CacheInfo *) AcquireAlignedMemory(1,sizeof(*cache_info));
   if (cache_info == (CacheInfo *) NULL)
     ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
   (void) memset(cache_info,0,sizeof(*cache_info));
   cache_info->type=UndefinedCache;
   cache_info->mode=IOMode;
   cache_info->disk_mode=IOMode;
   cache_info->colorspace=sRGBColorspace;
   cache_info->file=(-1);
   cache_info->id=GetMagickThreadId();
   cache_info->number_threads=number_threads;
   if (GetOpenMPMaximumThreads() > cache_info->number_threads)
     cache_info->number_threads=GetOpenMPMaximumThreads();
   if (GetMagickResourceLimit(ThreadResource) > cache_info->number_threads)
     cache_info->number_threads=(size_t) GetMagickResourceLimit(ThreadResource);
   if (cache_info->number_threads == 0)
     cache_info->number_threads=1;
   cache_info->nexus_info=AcquirePixelCacheNexus(cache_info->number_threads);
   if (cache_info->nexus_info == (NexusInfo **) NULL)
     ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
   value=GetEnvironmentValue("MAGICK_SYNCHRONIZE");
   if (value != (const char *) NULL)
     {
       cache_info->synchronize=IsStringTrue(value);
       value=DestroyString(value);
     }
   value=GetPolicyValue("cache:synchronize");
   if (value != (const char *) NULL)
     {
       cache_info->synchronize=IsStringTrue(value);
       value=DestroyString(value);
     }
   cache_info->width_limit=MagickMin(GetMagickResourceLimit(WidthResource),
-    (MagickSizeType) SSIZE_MAX);
+    (MagickSizeType) LONG_MAX);
   cache_info->height_limit=MagickMin(GetMagickResourceLimit(HeightResource),
-    (MagickSizeType) SSIZE_MAX);
+    (MagickSizeType) LONG_MAX);
   cache_info->semaphore=AcquireSemaphoreInfo();
   cache_info->reference_count=1;
   cache_info->file_semaphore=AcquireSemaphoreInfo();
   cache_info->debug=IsEventLogging();
   cache_info->signature=MagickCoreSignature;
   return((Cache ) cache_info);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   A c q u i r e P i x e l C a c h e N e x u s                               %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  AcquirePixelCacheNexus() allocates the NexusInfo structure.
 %
 %  The format of the AcquirePixelCacheNexus method is:
 %
 %      NexusInfo **AcquirePixelCacheNexus(const size_t number_threads)
 %
 %  A description of each parameter follows:
 %
 %    o number_threads: the number of nexus threads.
 %
 */
@@ -3548,33 +3548,33 @@ static MagickBooleanType OpenPixelCacheOnDisk(CacheInfo *cache_info,
 static inline MagickOffsetType WritePixelCacheRegion(
   const CacheInfo *magick_restrict cache_info,const MagickOffsetType offset,
   const MagickSizeType length,const unsigned char *magick_restrict buffer)
 {
   MagickOffsetType
     i;
 
   ssize_t
     count;
 
 #if !defined(MAGICKCORE_HAVE_PWRITE)
   if (lseek(cache_info->file,offset,SEEK_SET) < 0)
     return((MagickOffsetType) -1);
 #endif
   count=0;
   for (i=0; i < (MagickOffsetType) length; i+=count)
   {
 #if !defined(MAGICKCORE_HAVE_PWRITE)
     count=write(cache_info->file,buffer+i,(size_t) MagickMin(length-i,(size_t)
-      SSIZE_MAX));
+      LONG_MAX));
 #else
     count=pwrite(cache_info->file,buffer+i,(size_t) MagickMin(length-i,(size_t)
-      SSIZE_MAX),offset+i);
+      LONG_MAX),offset+i);
 #endif
     if (count <= 0)
       {
         count=0;
         if (errno != EINTR)
           break;
       }
   }
   return(i);
 }
@@ -4371,33 +4371,33 @@ MagickExport Quantum *QueueAuthenticPixels(Image *image,const ssize_t x,
 static inline MagickOffsetType ReadPixelCacheRegion(
   const CacheInfo *magick_restrict cache_info,const MagickOffsetType offset,
   const MagickSizeType length,unsigned char *magick_restrict buffer)
 {
   MagickOffsetType
     i;
 
   ssize_t
     count;
 
 #if !defined(MAGICKCORE_HAVE_PREAD)
   if (lseek(cache_info->file,offset,SEEK_SET) < 0)
     return((MagickOffsetType) -1);
 #endif
   count=0;
   for (i=0; i < (MagickOffsetType) length; i+=count)
   {
 #if !defined(MAGICKCORE_HAVE_PREAD)
     count=read(cache_info->file,buffer+i,(size_t) MagickMin(length-i,(size_t)
-      SSIZE_MAX));
+      LONG_MAX));
 #else
     count=pread(cache_info->file,buffer+i,(size_t) MagickMin(length-i,(size_t)
-      SSIZE_MAX),offset+i);
+      LONG_MAX),offset+i);
 #endif
     if (count <= 0)
       {
         count=0;
         if (errno != EINTR)
           break;
       }
   }
   return(i);
 }
@@ -5018,9 +5018,9 @@ static inline void PrefetchPixelCacheNexusPixels(const NexusInfo *nexus_info,
 static inline MagickBooleanType ValidatePixelOffset(const ssize_t x,
   const ssize_t a)
 {
-  if ((x >= 0) && (a > ((ssize_t) SSIZE_MAX-x)))
+  if ((x >= 0) && (a > (ssize_t) (LONG_MAX-x)))
     return(MagickFalse);
-  if (a < -((ssize_t) SSIZE_MAX-x))
+  if (a < (ssize_t) (LONG_MIN-x))
     return(MagickFalse);
   return(MagickTrue);
 }
diff --git a/MagickCore/distribute-cache.c b/MagickCore/distribute-cache.c
index 8bf197c6f..028d54f31 100644
--- a/MagickCore/distribute-cache.c
+++ b/MagickCore/distribute-cache.c
@@ -147,28 +147,28 @@
 static inline MagickOffsetType dpc_read(int file,const MagickSizeType length,
   unsigned char *magick_restrict message)
 {
   MagickOffsetType
     i;
 
   ssize_t
     count;
 
 #if !MAGICKCORE_HAVE_DISTRIBUTE_CACHE
   magick_unreferenced(file);
   magick_unreferenced(message);
 #endif
 
   count=0;
   for (i=0; i < (MagickOffsetType) length; i+=count)
   {
     count=recv(file,CHAR_TYPE_CAST message+i,(LENGTH_TYPE) MagickMin(length-i,
-      (MagickSizeType) SSIZE_MAX),0);
+      (MagickSizeType) LONG_MAX),0);
     if (count <= 0)
       {
         count=0;
         if (errno != EINTR)
           break;
       }
   }
   return(i);
 }
@@ -424,33 +424,33 @@ MagickPrivate DistributeCacheInfo *DestroyDistributeCacheInfo(
 static inline MagickOffsetType dpc_send(int file,const MagickSizeType length,
   const unsigned char *magick_restrict message)
 {
   MagickOffsetType
     count;
 
   MagickOffsetType
     i;
 
 #if !MAGICKCORE_HAVE_DISTRIBUTE_CACHE
   magick_unreferenced(file);
   magick_unreferenced(message);
 #endif
 
   /*
     Ensure a complete message is sent.
   */
   count=0;
   for (i=0; i < (MagickOffsetType) length; i+=count)
   {
     count=(MagickOffsetType) send(file,CHAR_TYPE_CAST message+i,(LENGTH_TYPE)
-      MagickMin(length-i,(MagickSizeType) SSIZE_MAX),MSG_NOSIGNAL);
+      MagickMin(length-i,(MagickSizeType) LONG_MAX),MSG_NOSIGNAL);
     if (count <= 0)
       {
         count=0;
         if (errno != EINTR)
           break;
       }
   }
   return(i);
 }
 
 #if !MAGICKCORE_HAVE_DISTRIBUTE_CACHE
@@ -1143,217 +1143,217 @@ MagickPrivate MagickBooleanType OpenDistributePixelCache(
   /*
     Open distributed pixel cache.
   */
   assert(server_info != (DistributeCacheInfo *) NULL);
   assert(server_info->signature == MagickCoreSignature);
   assert(image != (Image *) NULL);
   assert(image->signature == MagickCoreSignature);
   p=message;
   *p++='o';  /* open */
   /*
     Serialize image attributes (see ValidatePixelCacheMorphology()).
   */
   (void) memcpy(p,&server_info->session_key,sizeof(server_info->session_key));
   p+=sizeof(server_info->session_key);
   (void) memcpy(p,&image->storage_class,sizeof(image->storage_class));
   p+=sizeof(image->storage_class);
   (void) memcpy(p,&image->colorspace,sizeof(image->colorspace));
   p+=sizeof(image->colorspace);
   (void) memcpy(p,&image->alpha_trait,sizeof(image->alpha_trait));
   p+=sizeof(image->alpha_trait);
   (void) memcpy(p,&image->channels,sizeof(image->channels));
   p+=sizeof(image->channels);
   (void) memcpy(p,&image->columns,sizeof(image->columns));
   p+=sizeof(image->columns);
   (void) memcpy(p,&image->rows,sizeof(image->rows));
   p+=sizeof(image->rows);
   (void) memcpy(p,&image->number_channels,sizeof(image->number_channels));
   p+=sizeof(image->number_channels);
   (void) memcpy(p,image->channel_map,MaxPixelChannels*
     sizeof(*image->channel_map));
   p+=MaxPixelChannels*sizeof(*image->channel_map);
   (void) memcpy(p,&image->metacontent_extent,sizeof(image->metacontent_extent));
   p+=sizeof(image->metacontent_extent);
   count=dpc_send(server_info->file,p-message,message);
   if (count != (MagickOffsetType) (p-message))
     return(MagickFalse);
   status=MagickFalse;
   count=dpc_read(server_info->file,sizeof(status),(unsigned char *) &status);
   if (count != (MagickOffsetType) sizeof(status))
     return(MagickFalse);
   return(status);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 +   R e a d D i s t r i b u t e P i x e l C a c h e M e t a c o n t e n t     %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  ReadDistributePixelCacheMetacontents() reads metacontent from the specified
 %  region of the distributed pixel cache.
 %
 %  The format of the ReadDistributePixelCacheMetacontents method is:
 %
 %      MagickOffsetType ReadDistributePixelCacheMetacontents(
 %        DistributeCacheInfo *server_info,const RectangleInfo *region,
 %        const MagickSizeType length,unsigned char *metacontent)
 %
 %  A description of each parameter follows:
 %
 %    o server_info: the distributed cache info.
 %
 %    o image: the image.
 %
 %    o region: read the metacontent from this region of the image.
 %
 %    o length: the length in bytes of the metacontent.
 %
 %    o metacontent: read these metacontent from the pixel cache.
 %
 */
 MagickPrivate MagickOffsetType ReadDistributePixelCacheMetacontent(
   DistributeCacheInfo *server_info,const RectangleInfo *region,
   const MagickSizeType length,unsigned char *metacontent)
 {
   MagickOffsetType
     count;
 
   unsigned char
     *p;
 
   unsigned char
     message[MagickPathExtent];
 
   /*
     Read distributed pixel cache metacontent.
   */
   assert(server_info != (DistributeCacheInfo *) NULL);
   assert(server_info->signature == MagickCoreSignature);
   assert(region != (RectangleInfo *) NULL);
   assert(metacontent != (unsigned char *) NULL);
-  if (length > (MagickSizeType) SSIZE_MAX)
+  if (length > (MagickSizeType) LONG_MAX)
     return(-1);
   p=message;
   *p++='R';
   (void) memcpy(p,&server_info->session_key,sizeof(server_info->session_key));
   p+=sizeof(server_info->session_key);
   (void) memcpy(p,&region->width,sizeof(region->width));
   p+=sizeof(region->width);
   (void) memcpy(p,&region->height,sizeof(region->height));
   p+=sizeof(region->height);
   (void) memcpy(p,&region->x,sizeof(region->x));
   p+=sizeof(region->x);
   (void) memcpy(p,&region->y,sizeof(region->y));
   p+=sizeof(region->y);
   (void) memcpy(p,&length,sizeof(length));
   p+=sizeof(length);
   count=dpc_send(server_info->file,p-message,message);
   if (count != (MagickOffsetType) (p-message))
     return(-1);
   return(dpc_read(server_info->file,length,metacontent));
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 +   R e a d D i s t r i b u t e P i x e l C a c h e P i x e l s               %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  ReadDistributePixelCachePixels() reads pixels from the specified region of
 %  the distributed pixel cache.
 %
 %  The format of the ReadDistributePixelCachePixels method is:
 %
 %      MagickOffsetType ReadDistributePixelCachePixels(
 %        DistributeCacheInfo *server_info,const RectangleInfo *region,
 %        const MagickSizeType length,unsigned char *magick_restrict pixels)
 %
 %  A description of each parameter follows:
 %
 %    o server_info: the distributed cache info.
 %
 %    o image: the image.
 %
 %    o region: read the pixels from this region of the image.
 %
 %    o length: the length in bytes of the pixels.
 %
 %    o pixels: read these pixels from the pixel cache.
 %
 */
 MagickPrivate MagickOffsetType ReadDistributePixelCachePixels(
   DistributeCacheInfo *server_info,const RectangleInfo *region,
   const MagickSizeType length,unsigned char *magick_restrict pixels)
 {
   MagickOffsetType
     count;
 
   unsigned char
     *p;
 
   unsigned char
     message[MagickPathExtent];
 
   /*
     Read distributed pixel cache pixels.
   */
   assert(server_info != (DistributeCacheInfo *) NULL);
   assert(server_info->signature == MagickCoreSignature);
   assert(region != (RectangleInfo *) NULL);
   assert(pixels != (unsigned char *) NULL);
-  if (length > (MagickSizeType) SSIZE_MAX)
+  if (length > (MagickSizeType) LONG_MAX)
     return(-1);
   p=message;
   *p++='r';
   (void) memcpy(p,&server_info->session_key,sizeof(server_info->session_key));
   p+=sizeof(server_info->session_key);
   (void) memcpy(p,&region->width,sizeof(region->width));
   p+=sizeof(region->width);
   (void) memcpy(p,&region->height,sizeof(region->height));
   p+=sizeof(region->height);
   (void) memcpy(p,&region->x,sizeof(region->x));
   p+=sizeof(region->x);
   (void) memcpy(p,&region->y,sizeof(region->y));
   p+=sizeof(region->y);
   (void) memcpy(p,&length,sizeof(length));
   p+=sizeof(length);
   count=dpc_send(server_info->file,p-message,message);
   if (count != (MagickOffsetType) (p-message))
     return(-1);
   return(dpc_read(server_info->file,length,pixels));
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 +   R e l i n q u i s h D i s t r i b u t e P i x e l C a c h e               %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  RelinquishDistributePixelCache() frees resources acquired with
 %  OpenDistributePixelCache().
 %
 %  The format of the RelinquishDistributePixelCache method is:
 %
 %      MagickBooleanType RelinquishDistributePixelCache(
 %        DistributeCacheInfo *server_info)
 %
 %  A description of each parameter follows:
 %
 %    o server_info: the distributed cache info.
 %
 */
@@ -1379,168 +1379,168 @@ MagickPrivate MagickBooleanType RelinquishDistributePixelCache(
   /*
     Delete distributed pixel cache.
   */
   assert(server_info != (DistributeCacheInfo *) NULL);
   assert(server_info->signature == MagickCoreSignature);
   p=message;
   *p++='d';
   (void) memcpy(p,&server_info->session_key,sizeof(server_info->session_key));
   p+=sizeof(server_info->session_key);
   count=dpc_send(server_info->file,p-message,message);
   if (count != (MagickOffsetType) (p-message))
     return(MagickFalse);
   count=dpc_read(server_info->file,sizeof(status),(unsigned char *) &status);
   if (count != (MagickOffsetType) sizeof(status))
     return(MagickFalse);
   return(status);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 +   W r i t e D i s t r i b u t e P i x e l C a c h e M e t a c o n t e n t   %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  WriteDistributePixelCacheMetacontents() writes image metacontent to the
 %  specified region of the distributed pixel cache.
 %
 %  The format of the WriteDistributePixelCacheMetacontents method is:
 %
 %      MagickOffsetType WriteDistributePixelCacheMetacontents(
 %        DistributeCacheInfo *server_info,const RectangleInfo *region,
 %        const MagickSizeType length,const unsigned char *metacontent)
 %
 %  A description of each parameter follows:
 %
 %    o server_info: the distributed cache info.
 %
 %    o image: the image.
 %
 %    o region: write the metacontent to this region of the image.
 %
 %    o length: the length in bytes of the metacontent.
 %
 %    o metacontent: write these metacontent to the pixel cache.
 %
 */
 MagickPrivate MagickOffsetType WriteDistributePixelCacheMetacontent(
   DistributeCacheInfo *server_info,const RectangleInfo *region,
   const MagickSizeType length,const unsigned char *metacontent)
 {
   MagickOffsetType
     count;
 
   unsigned char
     *p;
 
   unsigned char
     message[MagickPathExtent];
 
   /*
     Write distributed pixel cache metacontent.
   */
   assert(server_info != (DistributeCacheInfo *) NULL);
   assert(server_info->signature == MagickCoreSignature);
   assert(region != (RectangleInfo *) NULL);
   assert(metacontent != (unsigned char *) NULL);
-  if (length > (MagickSizeType) SSIZE_MAX)
+  if (length > (MagickSizeType) LONG_MAX)
     return(-1);
   p=message;
   *p++='W';
   (void) memcpy(p,&server_info->session_key,sizeof(server_info->session_key));
   p+=sizeof(server_info->session_key);
   (void) memcpy(p,&region->width,sizeof(region->width));
   p+=sizeof(region->width);
   (void) memcpy(p,&region->height,sizeof(region->height));
   p+=sizeof(region->height);
   (void) memcpy(p,&region->x,sizeof(region->x));
   p+=sizeof(region->x);
   (void) memcpy(p,&region->y,sizeof(region->y));
   p+=sizeof(region->y);
   (void) memcpy(p,&length,sizeof(length));
   p+=sizeof(length);
   count=dpc_send(server_info->file,p-message,message);
   if (count != (MagickOffsetType) (p-message))
     return(-1);
   return(dpc_send(server_info->file,length,metacontent));
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 +   W r i t e D i s t r i b u t e P i x e l C a c h e P i x e l s             %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  WriteDistributePixelCachePixels() writes image pixels to the specified
 %  region of the distributed pixel cache.
 %
 %  The format of the WriteDistributePixelCachePixels method is:
 %
 %      MagickBooleanType WriteDistributePixelCachePixels(
 %        DistributeCacheInfo *server_info,const RectangleInfo *region,
 %        const MagickSizeType length,
 %        const unsigned char *magick_restrict pixels)
 %
 %  A description of each parameter follows:
 %
 %    o server_info: the distributed cache info.
 %
 %    o image: the image.
 %
 %    o region: write the pixels to this region of the image.
 %
 %    o length: the length in bytes of the pixels.
 %
 %    o pixels: write these pixels to the pixel cache.
 %
 */
 MagickPrivate MagickOffsetType WriteDistributePixelCachePixels(
   DistributeCacheInfo *server_info,const RectangleInfo *region,
   const MagickSizeType length,const unsigned char *magick_restrict pixels)
 {
   MagickOffsetType
     count;
 
   unsigned char
     *p;
 
   unsigned char
     message[MagickPathExtent];
 
   /*
     Write distributed pixel cache pixels.
   */
   assert(server_info != (DistributeCacheInfo *) NULL);
   assert(server_info->signature == MagickCoreSignature);
   assert(region != (RectangleInfo *) NULL);
   assert(pixels != (const unsigned char *) NULL);
-  if (length > (MagickSizeType) SSIZE_MAX)
+  if (length > (MagickSizeType) LONG_MAX)
     return(-1);
   p=message;
   *p++='w';
   (void) memcpy(p,&server_info->session_key,sizeof(server_info->session_key));
   p+=sizeof(server_info->session_key);
   (void) memcpy(p,&region->width,sizeof(region->width));
   p+=sizeof(region->width);
   (void) memcpy(p,&region->height,sizeof(region->height));
   p+=sizeof(region->height);
   (void) memcpy(p,&region->x,sizeof(region->x));
   p+=sizeof(region->x);
   (void) memcpy(p,&region->y,sizeof(region->y));
   p+=sizeof(region->y);
   (void) memcpy(p,&length,sizeof(length));
   p+=sizeof(length);
   count=dpc_send(server_info->file,p-message,message);
   if (count != (MagickOffsetType) (p-message))
     return(-1);
   return(dpc_send(server_info->file,length,pixels));
 }
diff --git a/MagickCore/draw.c b/MagickCore/draw.c
index 1729b8efe..11b7bf3a7 100644
--- a/MagickCore/draw.c
+++ b/MagickCore/draw.c
@@ -2306,17 +2306,17 @@ static MagickBooleanType CheckPrimitiveExtent(MVGInfo *mvg_info,
 static inline double GetDrawValue(const char *magick_restrict string,
   char **magick_restrict sentinal)
 {
   char
     **magick_restrict q;
 
   double
     value;
 
   q=sentinal;
   value=InterpretLocaleValue(string,q);
-  if ((IsNaN(value) != 0) || (value < -((double) SSIZE_MAX-512.0)) ||
-      (value > ((double) SSIZE_MAX-512.0)))
+  if ((IsNaN(value) != 0) || (value < -((double) LONG_MAX-512.0)) ||
+      (value > ((double) LONG_MAX-512.0)))
     return(0.0);
   sentinal=q;
   return(value);
 }
@@ -6237,135 +6237,135 @@ static MagickBooleanType TraceArcPath(MVGInfo *mvg_info,const PointInfo start,
 static MagickBooleanType TraceBezier(MVGInfo *mvg_info,
   const size_t number_coordinates)
 {
   double
     alpha,
     *coefficients,
     weight;
 
   PointInfo
     end,
     point,
     *points;
 
   PrimitiveInfo
     *primitive_info;
 
   PrimitiveInfo
     *p;
 
   ssize_t
     i,
     j;
 
   size_t
     control_points,
     quantum;
 
   /*
     Allocate coefficients.
   */
   primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;
   quantum=number_coordinates;
   for (i=0; i < (ssize_t) number_coordinates; i++)
   {
     for (j=i+1; j < (ssize_t) number_coordinates; j++)
     {
       alpha=fabs(primitive_info[j].point.x-primitive_info[i].point.x);
-      if (alpha > (double) SSIZE_MAX)
+      if (alpha > (double) LONG_MAX)
         {
           (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),
             ResourceLimitError,"MemoryAllocationFailed","`%s'","");
           return(MagickFalse);
         }
       if (alpha > (double) quantum)
         quantum=(size_t) alpha;
       alpha=fabs(primitive_info[j].point.y-primitive_info[i].point.y);
-      if (alpha > (double) SSIZE_MAX)
+      if (alpha > (double) LONG_MAX)
         {
           (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),
             ResourceLimitError,"MemoryAllocationFailed","`%s'","");
           return(MagickFalse);
         }
       if (alpha > (double) quantum)
         quantum=(size_t) alpha;
     }
   }
   primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;
   quantum=MagickMin(quantum/number_coordinates,BezierQuantum);
   coefficients=(double *) AcquireQuantumMemory(number_coordinates,
     sizeof(*coefficients));
   points=(PointInfo *) AcquireQuantumMemory(quantum,number_coordinates*
     sizeof(*points));
   if ((coefficients == (double *) NULL) || (points == (PointInfo *) NULL))
     {
       if (points != (PointInfo *) NULL)
         points=(PointInfo *) RelinquishMagickMemory(points);
       if (coefficients != (double *) NULL)
         coefficients=(double *) RelinquishMagickMemory(coefficients);
       (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),
         ResourceLimitError,"MemoryAllocationFailed","`%s'","");
       return(MagickFalse);
     }
   control_points=quantum*number_coordinates;
   if (CheckPrimitiveExtent(mvg_info,control_points+1) == MagickFalse)
     {
       points=(PointInfo *) RelinquishMagickMemory(points);
       coefficients=(double *) RelinquishMagickMemory(coefficients);
       return(MagickFalse);
     }
   primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;
   /*
     Compute bezier points.
   */
   end=primitive_info[number_coordinates-1].point;
   for (i=0; i < (ssize_t) number_coordinates; i++)
     coefficients[i]=Permutate((ssize_t) number_coordinates-1,i);
   weight=0.0;
   for (i=0; i < (ssize_t) control_points; i++)
   {
     p=primitive_info;
     point.x=0.0;
     point.y=0.0;
     alpha=pow((double) (1.0-weight),(double) number_coordinates-1.0);
     for (j=0; j < (ssize_t) number_coordinates; j++)
     {
       point.x+=alpha*coefficients[j]*p->point.x;
       point.y+=alpha*coefficients[j]*p->point.y;
       alpha*=weight/(1.0-weight);
       p++;
     }
     points[i]=point;
     weight+=1.0/control_points;
   }
   /*
     Bezier curves are just short segmented polys.
   */
   p=primitive_info;
   for (i=0; i < (ssize_t) control_points; i++)
   {
     if (TracePoint(p,points[i]) == MagickFalse)
       {
         points=(PointInfo *) RelinquishMagickMemory(points);
         coefficients=(double *) RelinquishMagickMemory(coefficients);
         return(MagickFalse);
       }
     p+=p->coordinates;
   }
   if (TracePoint(p,end) == MagickFalse)
     {
       points=(PointInfo *) RelinquishMagickMemory(points);
       coefficients=(double *) RelinquishMagickMemory(coefficients);
       return(MagickFalse);
     }
   p+=p->coordinates;
   primitive_info->coordinates=(size_t) (p-primitive_info);
   primitive_info->closed_subpath=MagickFalse;
   for (i=0; i < (ssize_t) primitive_info->coordinates; i++)
   {
     p->primitive=primitive_info->primitive;
     p--;
   }
   points=(PointInfo *) RelinquishMagickMemory(points);
   coefficients=(double *) RelinquishMagickMemory(coefficients);
   return(MagickTrue);
 }
diff --git a/MagickCore/image-private.h b/MagickCore/image-private.h
index bb2ce7921..b17823b1b 100644
--- a/MagickCore/image-private.h
+++ b/MagickCore/image-private.h
@@ -53,11 +53,11 @@ extern "C" {
 static inline ssize_t CastDoubleToLong(const double value)
 {
   if (IsNaN(value) != 0)
     return(0);
-  if (value > (double) SSIZE_MAX)
-    return((ssize_t) SSIZE_MAX);
-  if (value < (double) -SSIZE_MAX)
-    return((ssize_t) -SSIZE_MAX);
+  if (value > (double) LONG_MAX)
+    return((ssize_t) LONG_MAX);
+  if (value < (double) LONG_MIN)
+    return((ssize_t) LONG_MIN);
   return((ssize_t) value);
 }
 
diff --git a/MagickCore/matrix.c b/MagickCore/matrix.c
index be92f9883..c06d8bd0f 100644
--- a/MagickCore/matrix.c
+++ b/MagickCore/matrix.c
@@ -132,40 +132,40 @@ static void MatrixSignalHandler(int status)
 static inline MagickOffsetType WriteMatrixElements(
   const MatrixInfo *magick_restrict matrix_info,const MagickOffsetType offset,
   const MagickSizeType length,const unsigned char *magick_restrict buffer)
 {
   MagickOffsetType
     i;
 
   ssize_t
     count;
 
 #if !defined(MAGICKCORE_HAVE_PWRITE)
   LockSemaphoreInfo(matrix_info->semaphore);
   if (lseek(matrix_info->file,offset,SEEK_SET) < 0)
     {
       UnlockSemaphoreInfo(matrix_info->semaphore);
       return((MagickOffsetType) -1);
     }
 #endif
   count=0;
   for (i=0; i < (MagickOffsetType) length; i+=count)
   {
 #if !defined(MAGICKCORE_HAVE_PWRITE)
     count=write(matrix_info->file,buffer+i,(size_t) MagickMin(length-i,
-      (MagickSizeType) SSIZE_MAX));
+      (MagickSizeType) LONG_MAX));
 #else
     count=pwrite(matrix_info->file,buffer+i,(size_t) MagickMin(length-i,
-      (MagickSizeType) SSIZE_MAX),(off_t) (offset+i));
+      (MagickSizeType) LONG_MAX),(off_t) (offset+i));
 #endif
     if (count <= 0)
       {
         count=0;
         if (errno != EINTR)
           break;
       }
   }
 #if !defined(MAGICKCORE_HAVE_PWRITE)
   UnlockSemaphoreInfo(matrix_info->semaphore);
 #endif
   return(i);
 }
@@ -664,40 +664,40 @@ static inline ssize_t EdgeY(const ssize_t y,const size_t rows)
 static inline MagickOffsetType ReadMatrixElements(
   const MatrixInfo *magick_restrict matrix_info,const MagickOffsetType offset,
   const MagickSizeType length,unsigned char *magick_restrict buffer)
 {
   MagickOffsetType
     i;
 
   ssize_t
     count;
 
 #if !defined(MAGICKCORE_HAVE_PREAD)
   LockSemaphoreInfo(matrix_info->semaphore);
   if (lseek(matrix_info->file,offset,SEEK_SET) < 0)
     {
       UnlockSemaphoreInfo(matrix_info->semaphore);
       return((MagickOffsetType) -1);
     }
 #endif
   count=0;
   for (i=0; i < (MagickOffsetType) length; i+=count)
   {
 #if !defined(MAGICKCORE_HAVE_PREAD)
     count=read(matrix_info->file,buffer+i,(size_t) MagickMin(length-i,
-      (MagickSizeType) SSIZE_MAX));
+      (MagickSizeType) LONG_MAX));
 #else
     count=pread(matrix_info->file,buffer+i,(size_t) MagickMin(length-i,
-      (MagickSizeType) SSIZE_MAX),(off_t) (offset+i));
+      (MagickSizeType) LONG_MAX),(off_t) (offset+i));
 #endif
     if (count <= 0)
       {
         count=0;
         if (errno != EINTR)
           break;
       }
   }
 #if !defined(MAGICKCORE_HAVE_PREAD)
   UnlockSemaphoreInfo(matrix_info->semaphore);
 #endif
   return(i);
 }
diff --git a/MagickCore/memory.c b/MagickCore/memory.c
index 121fa6436..ac846c688 100644
--- a/MagickCore/memory.c
+++ b/MagickCore/memory.c
@@ -987,76 +987,76 @@ MagickExport void GetMagickMemoryMethods(
   AcquireMemoryHandler *acquire_memory_handler,
   ResizeMemoryHandler *resize_memory_handler,
   DestroyMemoryHandler *destroy_memory_handler)
 {
   assert(acquire_memory_handler != (AcquireMemoryHandler *) NULL);
   assert(resize_memory_handler != (ResizeMemoryHandler *) NULL);
   assert(destroy_memory_handler != (DestroyMemoryHandler *) NULL);
   *acquire_memory_handler=memory_methods.acquire_memory_handler;
   *resize_memory_handler=memory_methods.resize_memory_handler;
   *destroy_memory_handler=memory_methods.destroy_memory_handler;
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 +   G e t M a x M e m o r y R e q u e s t                                     %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  GetMaxMemoryRequest() returns the max_memory_request value.
 %
 %  The format of the GetMaxMemoryRequest method is:
 %
 %      size_t GetMaxMemoryRequest(void)
 %
 */
 MagickExport size_t GetMaxMemoryRequest(void)
 {
 #define MinMemoryRequest "16MiB"
 
   if (max_memory_request == 0)
     {
       char
         *value;
 
       max_memory_request=(size_t) MagickULLConstant(~0);
       value=GetPolicyValue("system:max-memory-request");
       if (value != (char *) NULL)
         {
           /*
             The security policy sets a max memory request limit.
           */
           max_memory_request=MagickMax(StringToSizeType(value,100.0),
             StringToSizeType(MinMemoryRequest,100.0));
           value=DestroyString(value);
         }
     }
-  return(MagickMin(max_memory_request,SSIZE_MAX));
+  return(MagickMin(max_memory_request,LONG_MAX));
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   G e t V i r t u a l M e m o r y B l o b                                   %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  GetVirtualMemoryBlob() returns the virtual memory blob associated with the
 %  specified MemoryInfo structure.
 %
 %  The format of the GetVirtualMemoryBlob method is:
 %
 %      void *GetVirtualMemoryBlob(const MemoryInfo *memory_info)
 %
 %  A description of each parameter follows:
 %
 %    o memory_info: The MemoryInfo structure.
 */
diff --git a/MagickCore/nt-base.h b/MagickCore/nt-base.h
index adb3fc883..57b366b22 100644
--- a/MagickCore/nt-base.h
+++ b/MagickCore/nt-base.h
@@ -24,288 +24,281 @@
 #if defined(__cplusplus) || defined(c_plusplus)
 extern "C" {
 #endif
 
 #if defined(MAGICKCORE_WINDOWS_SUPPORT)
 
 #define WIN32_LEAN_AND_MEAN
 #define VC_EXTRALEAN
 #define _CRT_SECURE_NO_DEPRECATE  1
 #include <windows.h>
 #include <wchar.h>
 #include <winuser.h>
 #include <wingdi.h>
 #include <io.h>
 #include <process.h>
 #include <errno.h>
 #include <malloc.h>
 #include <sys/utime.h>
 #if defined(_DEBUG) && !defined(__MINGW32__)
 #include <crtdbg.h>
 #endif
 
 #define PROT_READ  0x01
 #define PROT_WRITE  0x02
 #define MAP_SHARED  0x01
 #define MAP_PRIVATE  0x02
 #define MAP_ANONYMOUS  0x20
 #define F_OK 0
 #define R_OK 4
 #define W_OK 2
 #define RW_OK 6
 #define _SC_PAGE_SIZE 1
 #define _SC_PHYS_PAGES 2
 #define _SC_OPEN_MAX 3
-#if !defined(SSIZE_MAX)
-# ifdef _WIN64
-#   define SSIZE_MAX LLONG_MAX
-# else
-#   define SSIZE_MAX LONG_MAX
-# endif
-#endif
 
 /*
   _MSC_VER values:
     1100 MSVC 5.0
     1200 MSVC 6.0
     1300 MSVC 7.0 Visual C++ .NET 2002
     1310 Visual c++ .NET 2003
     1400 Visual C++ 2005
     1500 Visual C++ 2008
     1600 Visual C++ 2010
     1700 Visual C++ 2012
     1800 Visual C++ 2013
     1900 Visual C++ 2015
 */
 
 #if !defined(chsize)
 # if defined(__BORLANDC__)
 #   define chsize(file,length)  chsize(file,length)
 # else
 #   define chsize(file,length)  _chsize(file,length)
 # endif
 #endif
 
 #if !defined(access)
 #if defined(_VISUALC_) && (_MSC_VER >= 1400)
 #  define access(path,mode)  _access_s(path,mode)
 #endif
 #endif
 #if !defined(chdir)
 #  define chdir  _chdir
 #endif
 #if !defined(close)
 #  define close  _close
 #endif
 #if !defined(closedir)
 #  define closedir(directory)  NTCloseDirectory(directory)
 #endif
 #define MAGICKCORE_HAVE_ERF
 #if defined(_VISUALC_) && (_MSC_VER < 1700)
 #  define erf(x)  NTErf(x)
 #endif
 #if !defined(fdopen)
 #  define fdopen  _fdopen
 #endif
 #if !defined(fileno)
 #  define fileno  _fileno
 #endif
 #if !defined(freelocale)
 #  define freelocale  _free_locale
 #endif
 #if !defined(fseek) && !defined(__MINGW32__)
 #if defined(MAGICKCORE_WINDOWS_SUPPORT) && \
   !(defined(_MSC_VER) && (_MSC_VER < 1400)) && \
   !(defined(__MSVCRT_VERSION__) && (__MSVCRT_VERSION__ < 0x800))
 #  define fseek  _fseeki64
 #endif
 #endif
 #if !defined(fstat) && !defined(__BORLANDC__)
 #if defined(MAGICKCORE_WINDOWS_SUPPORT) && \
   !(defined(_MSC_VER) && (_MSC_VER < 1400)) && \
   !(defined(__MSVCRT_VERSION__) && (__MSVCRT_VERSION__ < 0x800))
 #  define fstat  _fstati64
 #else
 #  define fstat  _fstat
 #endif
 #endif
 #if !defined(fsync)
 #  define fsync  _commit
 #endif
 #if !defined(ftell) && !defined(__MINGW32__)
 #if defined(MAGICKCORE_WINDOWS_SUPPORT) && \
   !(defined(_MSC_VER) && (_MSC_VER < 1400)) && \
   !(defined(__MSVCRT_VERSION__) && (__MSVCRT_VERSION__ < 0x800))
 #  define ftell  _ftelli64
 #endif
 #endif
 #if !defined(ftruncate)
 #  define ftruncate(file,length)  NTTruncateFile(file,length)
 #endif
 #if !defined(getcwd)
 #  define getcwd  _getcwd
 #endif
 #if !defined(getpid)
 #  define getpid  _getpid
 #endif
 #if !defined(hypot)
 #  define hypot  _hypot
 #endif
 #if !defined(isatty)
 #  define isatty  _isatty
 #endif
 #if !defined(locale_t)
 #define locale_t _locale_t
 #endif
 #if defined(MAGICKCORE_WINDOWS_SUPPORT) && \
   !(defined(_MSC_VER) && (_MSC_VER < 1400)) && \
   !(defined(__MSVCRT_VERSION__) && (__MSVCRT_VERSION__ < 0x800))
 #if !defined(lseek)
 #  define lseek  _lseeki64
 #endif
 #else
 #if !defined(lseek)
 #  define lseek  _lseek
 #endif
 #endif
 #if !defined(MAGICKCORE_LTDL_DELEGATE)
 #if !defined(lt_dlclose)
 #  define lt_dlclose(handle)  NTCloseLibrary(handle)
 #endif
 #if !defined(lt_dlerror)
 #  define lt_dlerror()  NTGetLibraryError()
 #endif
 #if !defined(lt_dlexit)
 #  define lt_dlexit()  NTExitLibrary()
 #endif
 #if !defined(lt_dlinit)
 #  define lt_dlinit()  NTInitializeLibrary()
 #endif
 #if !defined(lt_dlopen)
 #  define lt_dlopen(filename)  NTOpenLibrary(filename)
 #endif
 #if !defined(lt_dlsetsearchpath)
 #  define lt_dlsetsearchpath(path)  NTSetSearchPath(path)
 #endif
 #if !defined(lt_dlsym)
 #  define lt_dlsym(handle,name)  NTGetLibrarySymbol(handle,name)
 #endif
 #endif
 #if !defined(mkdir)
 #  define mkdir  _mkdir
 #endif
 #if !defined(mmap)
 #  define mmap(address,length,protection,access,file,offset) \
   NTMapMemory(address,length,protection,access,file,offset)
 #endif
 #if !defined(munmap)
 #  define munmap(address,length)  NTUnmapMemory(address,length)
 #endif
 #if !defined(opendir)
 #  define opendir(directory)  NTOpenDirectory(directory)
 #endif
 #if !defined(open)
 #  define open  _open
 #endif
 #if !defined(pclose)
 #  define pclose  _pclose
 #endif
 #if !defined(popen)
 #  define popen  _popen
 #endif
 #if !defined(fprintf_l)
 #define fprintf_l  _fprintf_s_l
 #endif
 #if !defined(read)
 #  define read(fd,buffer,count)  _read(fd,buffer,(unsigned int) count)
 #endif
 #if !defined(readdir)
 #  define readdir(directory)  NTReadDirectory(directory)
 #endif
 #if !defined(setmode)
 #  define setmode  _setmode
 #endif
 #if !defined(spawnvp)
 #  define spawnvp  _spawnvp
 #endif
 #if !defined(strtod_l)
 #define strtod_l  _strtod_l
 #endif
 #if !defined(stat) && !defined(__BORLANDC__)
 #if defined(MAGICKCORE_WINDOWS_SUPPORT) && \
   !(defined(_MSC_VER) && (_MSC_VER < 1400)) && \
   !(defined(__MSVCRT_VERSION__) && (__MSVCRT_VERSION__ < 0x800))
 #  define stat  _stati64
 #else
 #  define stat  _stat
 #endif
 #endif
 #if !defined(strcasecmp)
 #  define strcasecmp  _stricmp
 #endif
 #if !defined(strncasecmp)
 #  define strncasecmp  _strnicmp
 #endif
 #if !defined(sysconf)
 #  define sysconf(name)  NTSystemConfiguration(name)
 #endif
 #if defined(MAGICKCORE_WINDOWS_SUPPORT) && \
   !(defined(_MSC_VER) && (_MSC_VER < 1400)) && \
   !(defined(__MSVCRT_VERSION__) && (__MSVCRT_VERSION__ < 0x800))
 #  define tell  _telli64
 #else
 #  define tell  _tell
 #endif
 #if !defined(tempnam)
 #  define tempnam  _tempnam_s
 #endif
 #if !defined(tolower_l)
 #define tolower_l  _tolower_l
 #endif
 #if !defined(toupper_l)
 #define toupper_l  _toupper_l
 #endif
 #if !defined(umask)
 #  define umask  _umask
 #endif
 #if !defined(unlink)
 #  define unlink  _unlink
 #endif
 #if !defined(utime)
 #  define utime(filename,time)  _utime(filename,(struct _utimbuf*) time)
 #endif
 #if !defined(vfprintf_l)
 #define vfprintf_l  _vfprintf_l
 #endif
 #if !defined(vsnprintf)
 #if !defined(_MSC_VER) || (defined(_MSC_VER) && _MSC_VER < 1500)
 #define vsnprintf _vsnprintf
 #endif
 #endif
 #if !defined(vsnprintf_l)
 #define vsnprintf_l  _vsnprintf_l
 #endif
 #if !defined(write)
 #  define write(fd,buffer,count)  _write(fd,buffer,(unsigned int) count)
 #endif
 #if !defined(wstat) && !defined(__BORLANDC__)
 #if defined(MAGICKCORE_WINDOWS_SUPPORT) && \
   !(defined(_MSC_VER) && (_MSC_VER < 1400)) && \
   !(defined(__MSVCRT_VERSION__) && (__MSVCRT_VERSION__ < 0x800))
 #  define wstat  _wstati64
 #else
 #  define wstat  _wstat
 #endif
 #endif
 
 #if defined(__BORLANDC__)
 #undef _O_RANDOM
 #define _O_RANDOM 0
 #undef _O_SEQUENTIAL
 #define _O_SEQUENTIAL 0
 #undef _O_SHORT_LIVED
 #define _O_SHORT_LIVED 0
 #undef _O_TEMPORARY
 #define _O_TEMPORARY 0
 #endif
 
 #undef gettimeofday
diff --git a/MagickCore/pixel.c b/MagickCore/pixel.c
index 1b110a58b..fa4b2b988 100644
--- a/MagickCore/pixel.c
+++ b/MagickCore/pixel.c
@@ -4456,10 +4456,10 @@ static inline void CatromWeights(const double x,double (*weights)[4])
 
 static inline double ConstrainPixelOffset(double x)
 {
-  if (x < (double) -(SSIZE_MAX-512))
-    return((double) -(SSIZE_MAX-512));
-  if (x > (double) (SSIZE_MAX-512))
-    return((double) (SSIZE_MAX-512));
+  if (x < (double) -(LONG_MAX-512))
+    return((double) -(LONG_MAX-512));
+  if (x > (double) (LONG_MAX-512))
+    return((double) (LONG_MAX-512));
   return(x);
 }
 
diff --git a/MagickCore/resource.c b/MagickCore/resource.c
index c1dff2cbe..55c39c710 100644
--- a/MagickCore/resource.c
+++ b/MagickCore/resource.c
@@ -115,26 +115,26 @@ static RandomInfo
 static ResourceInfo
   resource_info =
   {
     MagickULLConstant(0),              /* initial width */
     MagickULLConstant(0),              /* initial height */
     MagickULLConstant(0),              /* initial list length */
     MagickULLConstant(0),              /* initial area */
     MagickULLConstant(0),              /* initial memory */
     MagickULLConstant(0),              /* initial map */
     MagickULLConstant(0),              /* initial disk */
     MagickULLConstant(0),              /* initial file */
     MagickULLConstant(0),              /* initial thread */
     MagickULLConstant(0),              /* initial throttle */
     MagickULLConstant(0),              /* initial time */
-    SSIZE_MAX/sizeof(Quantum)/MaxPixelChannels/2, /* width limit */
-    SSIZE_MAX/sizeof(Quantum)/MaxPixelChannels/2, /* height limit */
+    LONG_MAX/sizeof(Quantum)/MaxPixelChannels/2, /* width limit */
+    LONG_MAX/sizeof(Quantum)/MaxPixelChannels/2, /* height limit */
     MagickResourceInfinity,            /* list length limit */
     MagickULLConstant(3072)*1024*1024, /* area limit */
     MagickULLConstant(1536)*1024*1024, /* memory limit */
     MagickULLConstant(3072)*1024*1024, /* map limit */
     MagickResourceInfinity,            /* disk limit */
     MagickULLConstant(768),            /* file limit */
     MagickULLConstant(1),              /* thread limit */
     MagickULLConstant(0),              /* throttle limit */
     MagickResourceInfinity             /* time limit */
   };
@@ -1316,209 +1316,209 @@ MagickPrivate void ResourceComponentTerminus(void)
   for (i=0; i < (ssize_t) NumberOfResourceTypes; i++)
     if (resource_semaphore[i] == (SemaphoreInfo *) NULL)
       resource_semaphore[i]=AcquireSemaphoreInfo();
   LockSemaphoreInfo(resource_semaphore[FileResource]);
   if (temporary_resources != (SplayTreeInfo *) NULL)
     temporary_resources=DestroySplayTree(temporary_resources);
   if (random_info != (RandomInfo *) NULL)
     random_info=DestroyRandomInfo(random_info);
   UnlockSemaphoreInfo(resource_semaphore[FileResource]);
   for (i=0; i < (ssize_t) NumberOfResourceTypes; i++)
     RelinquishSemaphoreInfo(&resource_semaphore[i]);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   S e t M a g i c k R e s o u r c e L i m i t                               %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  SetMagickResourceLimit() sets the limit for a particular resource.
 %
 %  The format of the SetMagickResourceLimit() method is:
 %
 %      MagickBooleanType SetMagickResourceLimit(const ResourceType type,
 %        const MagickSizeType limit)
 %
 %  A description of each parameter follows:
 %
 %    o type: the type of resource.
 %
 %    o limit: the maximum limit for the resource.
 %
 */
 MagickExport MagickBooleanType SetMagickResourceLimit(const ResourceType type,
   const MagickSizeType limit)
 {
   char
     *value;
 
   MagickBooleanType
     status;
 
   status=MagickTrue;
   value=(char *) NULL;
   switch (type)
   {
     case DiskResource:
     case FileResource:
     case MapResource:
     case MemoryResource:
     case TimeResource:
     {
       if (resource_semaphore[type] == (SemaphoreInfo *) NULL)
         ActivateSemaphoreInfo(&resource_semaphore[type]);
       LockSemaphoreInfo(resource_semaphore[type]);
       break;
     }
     default: ;
   }
   switch (type)
   {
     case AreaResource:
     {
       value=GetPolicyValue("resource:area");
       if (value == (char *) NULL)
         resource_info.area_limit=limit;
       else
         resource_info.area_limit=MagickMin(limit,StringToMagickSizeType(value,
           100.0));
       break;
     }
     case DiskResource:
     {
       value=GetPolicyValue("resource:disk");
       if (value == (char *) NULL)
         resource_info.disk_limit=limit;
       else
         resource_info.disk_limit=MagickMin(limit,StringToMagickSizeType(value,
           100.0));
       break;
     }
     case FileResource:
     {
       value=GetPolicyValue("resource:file");
       if (value == (char *) NULL)
         resource_info.file_limit=limit;
       else
         resource_info.file_limit=MagickMin(limit,StringToMagickSizeType(value,
           100.0));
       break;
     }
     case HeightResource:
     {
       value=GetPolicyValue("resource:height");
       if (value == (char *) NULL)
         resource_info.height_limit=limit;
       else
         resource_info.height_limit=MagickMin(limit,StringToMagickSizeType(
           value,100.0));
       resource_info.height_limit=MagickMin(resource_info.height_limit,
-        (MagickSizeType) SSIZE_MAX);
+        (MagickSizeType) LONG_MAX);
       break;
     }
     case ListLengthResource:
     {
       value=GetPolicyValue("resource:list-length");
       if (value == (char *) NULL)
         resource_info.list_length_limit=limit;
       else
         resource_info.list_length_limit=MagickMin(limit,
           StringToMagickSizeType(value,100.0));
       break;
     }
     case MapResource:
     {
       value=GetPolicyValue("resource:map");
       if (value == (char *) NULL)
         resource_info.map_limit=limit;
       else
         resource_info.map_limit=MagickMin(limit,StringToMagickSizeType(
           value,100.0));
       break;
     }
     case MemoryResource:
     {
       value=GetPolicyValue("resource:memory");
       if (value == (char *) NULL)
         resource_info.memory_limit=limit;
       else
         resource_info.memory_limit=MagickMin(limit,StringToMagickSizeType(
           value,100.0));
       break;
     }
     case ThreadResource:
     {
       value=GetPolicyValue("resource:thread");
       if (value == (char *) NULL)
         resource_info.thread_limit=limit;
       else
         resource_info.thread_limit=MagickMin(limit,StringToMagickSizeType(
           value,100.0));
       if (resource_info.thread_limit > GetOpenMPMaximumThreads())
         resource_info.thread_limit=GetOpenMPMaximumThreads();
       else
         if (resource_info.thread_limit == 0)
           resource_info.thread_limit=1;
       break;
     }
     case ThrottleResource:
     {
       value=GetPolicyValue("resource:throttle");
       if (value == (char *) NULL)
         resource_info.throttle_limit=limit;
       else
         resource_info.throttle_limit=MagickMax(limit,StringToMagickSizeType(
           value,100.0));
       break;
     }
     case TimeResource:
     {
       value=GetPolicyValue("resource:time");
       if (value == (char *) NULL)
         resource_info.time_limit=limit;
       else
         resource_info.time_limit=MagickMin(limit,StringToMagickSizeType(value,
           100.0));
       ResetPixelCacheEpoch();
       break;
     }
     case WidthResource:
     {
       value=GetPolicyValue("resource:width");
       if (value == (char *) NULL)
         resource_info.width_limit=limit;
       else
         resource_info.width_limit=MagickMin(limit,StringToMagickSizeType(value,
           100.0));
       resource_info.width_limit=MagickMin(resource_info.width_limit,
-        (MagickSizeType) SSIZE_MAX);
+        (MagickSizeType) LONG_MAX);
       break;
     }
     default:
     {
       status=MagickFalse;
       break;
     }
   }
   switch (type)
   {
     case DiskResource:
     case FileResource:
     case MapResource:
     case MemoryResource:
     case TimeResource:
     {
       UnlockSemaphoreInfo(resource_semaphore[type]);
       break;
     }
     default: ;
   }
   if (value != (char *) NULL)
     value=DestroyString(value);
   return(status);
 }
diff --git a/MagickCore/string.c b/MagickCore/string.c
index e411caa3d..9572e336b 100644
--- a/MagickCore/string.c
+++ b/MagickCore/string.c
@@ -524,142 +524,142 @@ MagickExport void ConcatenateStringInfo(StringInfo *string_info,
   assert(string_info != (StringInfo *) NULL);
   assert(string_info->signature == MagickCoreSignature);
   assert(source != (const StringInfo *) NULL);
   length=string_info->length;
   if (~length < source->length)
     ThrowFatalException(ResourceLimitFatalError,"UnableToConcatenateString");
   SetStringInfoLength(string_info,length+source->length);
   (void) memcpy(string_info->datum+length,source->datum,source->length);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   C o n f i g u r e F i l e T o S t r i n g I n f o                         %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  ConfigureFileToStringInfo() returns the contents of a configure file as a
 %  string.
 %
 %  The format of the ConfigureFileToStringInfo method is:
 %
 %      StringInfo *ConfigureFileToStringInfo(const char *filename)
 %        ExceptionInfo *exception)
 %
 %  A description of each parameter follows:
 %
 %    o filename: the filename.
 %
 */
 MagickExport StringInfo *ConfigureFileToStringInfo(const char *filename)
 {
   char
     *string;
 
   int
     file;
 
   MagickOffsetType
     offset;
 
   size_t
     length;
 
   StringInfo
     *string_info;
 
   void
     *map;
 
   assert(filename != (const char *) NULL);
   file=open_utf8(filename,O_RDONLY | O_BINARY,0);
   if (file == -1)
     return((StringInfo *) NULL);
   offset=(MagickOffsetType) lseek(file,0,SEEK_END);
   if ((offset < 0) || (offset != (MagickOffsetType) ((ssize_t) offset)))
     {
       file=close(file)-1;
       return((StringInfo *) NULL);
     }
   length=(size_t) offset;
   string=(char *) NULL;
   if (~length >= (MagickPathExtent-1))
     string=(char *) AcquireQuantumMemory(length+MagickPathExtent,
       sizeof(*string));
   if (string == (char *) NULL)
     {
       file=close(file)-1;
       return((StringInfo *) NULL);
     }
   map=MapBlob(file,ReadMode,0,length);
   if (map != (void *) NULL)
     {
       (void) memcpy(string,map,length);
       (void) UnmapBlob(map,length);
     }
   else
     {
       size_t
         i;
 
       ssize_t
         count;
 
       (void) lseek(file,0,SEEK_SET);
       for (i=0; i < length; i+=count)
       {
         count=read(file,string+i,(size_t) MagickMin(length-i,(size_t)
-          SSIZE_MAX));
+          LONG_MAX));
         if (count <= 0)
           {
             count=0;
             if (errno != EINTR)
               break;
           }
       }
       if (i < length)
         {
           file=close(file)-1;
           string=DestroyString(string);
           return((StringInfo *) NULL);
         }
     }
   string[length]='\0';
   file=close(file)-1;
   string_info=AcquireStringInfoContainer();
   string_info->path=ConstantString(filename);
   string_info->length=length;
   string_info->datum=(unsigned char *) string;
   return(string_info);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   C o n s t a n t S t r i n g                                               %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  ConstantString() allocates exactly the needed memory for a string and
 %  copies the source string to that memory location.  A NULL string pointer
 %  will allocate an empty string containing just the NUL character.
 %
 %  When finished the string should be freed using DestoryString()
 %
 %  The format of the ConstantString method is:
 %
 %      char *ConstantString(const char *source)
 %
 %  A description of each parameter follows:
 %
 %    o source: A character string.
 %
 */
diff --git a/MagickCore/transform.c b/MagickCore/transform.c
index 3fce4d2b0..88990eb2a 100644
--- a/MagickCore/transform.c
+++ b/MagickCore/transform.c
@@ -769,10 +769,10 @@ MagickExport Image *CropImage(const Image *image,const RectangleInfo *geometry,
 
 static inline double ConstrainPixelOffset(double x)
 {
-  if (x < (double) -(SSIZE_MAX-512))
-    return((double) -(SSIZE_MAX-512));
-  if (x > (double) (SSIZE_MAX-512))
-    return((double) (SSIZE_MAX-512));
+  if (x < (double) -(LONG_MAX-512))
+    return((double) -(LONG_MAX-512));
+  if (x > (double) (LONG_MAX-512))
+    return((double) (LONG_MAX-512));
   return(x);
 }
 
diff --git a/MagickCore/xml-tree.c b/MagickCore/xml-tree.c
index d14c97bb8..d9eb1f9bd 100644
--- a/MagickCore/xml-tree.c
+++ b/MagickCore/xml-tree.c
@@ -559,185 +559,185 @@ MagickExport XMLTreeInfo *DestroyXMLTree(XMLTreeInfo *xml_info)
 {
   assert(xml_info != (XMLTreeInfo *) NULL);
   assert((xml_info->signature == MagickCoreSignature) ||
          (((XMLTreeRoot *) xml_info)->signature == MagickCoreSignature));
   if (xml_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"...");
   DestroyXMLTreeChild(xml_info);
   DestroyXMLTreeOrdered(xml_info);
   DestroyXMLTreeRoot(xml_info);
   xml_info->attributes=DestroyXMLTreeAttributes(xml_info->attributes);
   xml_info->content=DestroyString(xml_info->content);
   xml_info->tag=DestroyString(xml_info->tag);
   xml_info=(XMLTreeInfo *) RelinquishMagickMemory(xml_info);
   return((XMLTreeInfo *) NULL);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   F i l e T o X M L                                                         %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  FileToXML() returns the contents of a file as a XML string.
 %
 %  The format of the FileToXML method is:
 %
 %      char *FileToXML(const char *filename,const size_t extent)
 %
 %  A description of each parameter follows:
 %
 %    o filename: the filename.
 %
 %    o extent: Maximum length of the string.
 %
 */
 MagickPrivate char *FileToXML(const char *filename,const size_t extent)
 {
   char
     *xml;
 
   int
     file;
 
   MagickOffsetType
     offset;
 
   size_t
     i;
 
   size_t
     length;
 
   ssize_t
     count;
 
   void
     *map;
 
   assert(filename != (const char *) NULL);
   length=0;
   file=fileno(stdin);
   if (LocaleCompare(filename,"-") != 0)
     file=open_utf8(filename,O_RDONLY | O_BINARY,0);
   if (file == -1)
     return((char *) NULL);
   offset=(MagickOffsetType) lseek(file,0,SEEK_END);
   count=0;
   if ((file == fileno(stdin)) || (offset < 0) ||
       (offset != (MagickOffsetType) ((ssize_t) offset)))
     {
       size_t
         quantum;
 
       struct stat
         file_stats;
 
       /*
         Stream is not seekable.
       */
       offset=(MagickOffsetType) lseek(file,0,SEEK_SET);
       quantum=(size_t) MagickMaxBufferExtent;
       if ((fstat(file,&file_stats) == 0) && (file_stats.st_size > 0))
         quantum=(size_t) MagickMin(file_stats.st_size,MagickMaxBufferExtent);
       xml=(char *) AcquireQuantumMemory(quantum,sizeof(*xml));
       for (i=0; xml != (char *) NULL; i+=count)
       {
         count=read(file,xml+i,quantum);
         if (count <= 0)
           {
             count=0;
             if (errno != EINTR)
               break;
           }
         if (~((size_t) i) < (quantum+1))
           {
             xml=(char *) RelinquishMagickMemory(xml);
             break;
           }
         xml=(char *) ResizeQuantumMemory(xml,i+quantum+1,sizeof(*xml));
         if ((size_t) (i+count) >= extent)
           break;
       }
       if (LocaleCompare(filename,"-") != 0)
         file=close(file);
       if (xml == (char *) NULL)
         return((char *) NULL);
       if (file == -1)
         {
           xml=(char *) RelinquishMagickMemory(xml);
           return((char *) NULL);
         }
       length=(size_t) MagickMin(i+count,extent);
       xml[length]='\0';
       return(xml);
     }
   length=(size_t) MagickMin(offset,(MagickOffsetType) extent);
   xml=(char *) NULL;
   if (~length >= (MagickPathExtent-1))
     xml=(char *) AcquireQuantumMemory(length+MagickPathExtent,sizeof(*xml));
   if (xml == (char *) NULL)
     {
       file=close(file);
       return((char *) NULL);
     }
   map=MapBlob(file,ReadMode,0,length);
   if (map != (char *) NULL)
     {
       (void) memcpy(xml,map,length);
       (void) UnmapBlob(map,length);
     }
   else
     {
       (void) lseek(file,0,SEEK_SET);
       for (i=0; i < length; i+=count)
       {
-        count=read(file,xml+i,(size_t) MagickMin(length-i,(size_t) SSIZE_MAX));
+        count=read(file,xml+i,(size_t) MagickMin(length-i,(size_t) LONG_MAX));
         if (count <= 0)
           {
             count=0;
             if (errno != EINTR)
               break;
           }
       }
       if (i < length)
         {
           file=close(file)-1;
           xml=(char *) RelinquishMagickMemory(xml);
           return((char *) NULL);
         }
     }
   xml[length]='\0';
   if (LocaleCompare(filename,"-") != 0)
     file=close(file);
   if (file == -1)
     xml=(char *) RelinquishMagickMemory(xml);
   return(xml);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   G e t N e x t X M L T r e e T a g                                         %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  GetNextXMLTreeTag() returns the next tag or NULL if not found.
 %
 %  The format of the GetNextXMLTreeTag method is:
 %
 %      XMLTreeInfo *GetNextXMLTreeTag(XMLTreeInfo *xml_info)
 %
 %  A description of each parameter follows:
 %
 %    o xml_info: the xml info.
 %
 */
diff --git a/coders/ashlar.c b/coders/ashlar.c
index 9e6b1e116..02710fc98 100644
--- a/coders/ashlar.c
+++ b/coders/ashlar.c
@@ -257,104 +257,104 @@ static ssize_t FindMinimumTileLocation(NodeInfo *first,const ssize_t x,
 static TileInfo AssignBestTileLocation(AshlarInfo *ashlar_info,
   size_t width,size_t height)
 {
   NodeInfo
     *node,
     **previous,
     *tail;
 
   ssize_t
     min_excess;
 
   TileInfo
     tile;
 
   /*
     Align along left edge.
   */
   tile.previous=(NodeInfo **) NULL;
   width=(width+ashlar_info->align-1);
   width-=width % ashlar_info->align;
   if ((width > ashlar_info->width) || (height > ashlar_info->height))
     {
       /*
         Tile can't fit, bail.
       */
       tile.x=0;
       tile.y=0;
       return(tile);
     }
-  tile.x=(ssize_t) SSIZE_MAX;
-  tile.y=(ssize_t) SSIZE_MAX;
-  min_excess=(ssize_t) SSIZE_MAX;
+  tile.x=(ssize_t) LONG_MAX;
+  tile.y=(ssize_t) LONG_MAX;
+  min_excess=(ssize_t) LONG_MAX;
   node=ashlar_info->current;
   previous=(&ashlar_info->current);
   while ((width+node->x) <= ashlar_info->width)
   {
     ssize_t
       excess,
       y;
 
     y=FindMinimumTileLocation(node,node->x,width,&excess);
     if (ashlar_info->best_fit == MagickFalse)
       {
         if (y < tile.y)
           {
             tile.y=y;
             tile.previous=previous;
           }
       }
     else
       {
         if ((height+y)  <= ashlar_info->height)
           if ((y < tile.y) || ((y == tile.y) && (excess < min_excess)))
             {
               tile.y=y;
               tile.previous=previous;
               min_excess=excess;
             }
       }
     previous=(&node->next);
     node=node->next;
   }
   tile.x=(tile.previous == (NodeInfo **) NULL) ? 0 : (*tile.previous)->x;
   if (ashlar_info->best_fit != MagickFalse)
     {
       /*
         Align along both left and right edges.
       */
       tail=ashlar_info->current;
       node=ashlar_info->current;
       previous=(&ashlar_info->current);
       while (tail->x < (ssize_t) width)
         tail=tail->next;
       while (tail != (NodeInfo *) NULL)
       {
         ssize_t
           excess,
           x,
           y;
 
         x=tail->x-width;
         while (node->next->x <= x)
         {
           previous=(&node->next);
           node=node->next;
         }
         y=FindMinimumTileLocation(node,x,width,&excess);
         if ((height+y) <= ashlar_info->height)
           {
             if (y <= tile.y)
               if ((y < tile.y) || (excess < min_excess) ||
                   ((excess == min_excess) && (x < tile.x)))
                 {
                   tile.x=x;
                   tile.y=y;
                   min_excess=excess;
                   tile.previous=previous;
                }
          }
        tail=tail->next;
     }
   }
   return(tile);
 }
@@ -445,46 +445,46 @@ static int RestoreTileOrder(const void *p_tile,const void *q_tile)
 static MagickBooleanType PackAshlarTiles(AshlarInfo *ashlar_info,
   CanvasInfo *tiles,const size_t number_tiles)
 {
   MagickBooleanType
     status;
 
   ssize_t
     i;
 
   /*
     Pack tiles so they fit the canvas with minimum excess.
   */
   for (i=0; i < (ssize_t) number_tiles; i++)
     tiles[i].order=(i);
   qsort((void *) tiles,number_tiles,sizeof(*tiles),CompareTileHeight);
   for (i=0; i < (ssize_t) number_tiles; i++)
   {
     tiles[i].x=0;
     tiles[i].y=0;
     if ((tiles[i].width != 0) && (tiles[i].height != 0))
       {
         TileInfo
           tile_info;
 
         tile_info=AssignTileLocation(ashlar_info,tiles[i].width,
           tiles[i].height);
         tiles[i].x=(ssize_t) tile_info.x;
         tiles[i].y=(ssize_t) tile_info.y;
         if (tile_info.previous == (NodeInfo **) NULL)
           {
-            tiles[i].x=(ssize_t) SSIZE_MAX;
-            tiles[i].y=(ssize_t) SSIZE_MAX;
+            tiles[i].x=(ssize_t) LONG_MAX;
+            tiles[i].y=(ssize_t) LONG_MAX;
           }
       }
   }
   qsort((void *) tiles,number_tiles,sizeof(*tiles),RestoreTileOrder);
   status=MagickTrue;
   for (i=0; i < (ssize_t) number_tiles; i++)
   {
-    tiles[i].order=(ssize_t) ((tiles[i].x != (ssize_t) SSIZE_MAX) ||
-      (tiles[i].y != (ssize_t) SSIZE_MAX) ? 1 : 0);
+    tiles[i].order=(ssize_t) ((tiles[i].x != (ssize_t) LONG_MAX) ||
+      (tiles[i].y != (ssize_t) LONG_MAX) ? 1 : 0);
     if (tiles[i].order == 0)
       status=MagickFalse;
   }
   return(status);  /* return true if room is found for all tiles */
 }
@@ -492,192 +492,192 @@ static MagickBooleanType PackAshlarTiles(AshlarInfo *ashlar_info,
 static MagickBooleanType WriteASHLARImage(const ImageInfo *image_info,
   Image *image,ExceptionInfo *exception)
 {
   AshlarInfo
     ashlar_info;
 
   CanvasInfo
     *tiles;
 
   const char
     *value;
 
   Image
     *ashlar_image,
     *next;
 
   ImageInfo
     *write_info;
 
   MagickBooleanType
     status;
 
   NodeInfo
     *nodes;
 
   RectangleInfo
     extent,
     geometry;
 
   ssize_t
     i,
     n;
 
   /*
     Convert image sequence laid out in continuous irregular courses.
   */
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickCoreSignature);
   assert(image != (Image *) NULL);
   assert(image->signature == MagickCoreSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
   if (image_info->extract != (char *) NULL)
     (void) ParseAbsoluteGeometry(image_info->extract,&geometry);
   else
     {
       /*
         Determine a sane canvas size and border width.
       */
       (void) ParseAbsoluteGeometry("0x0+0+0",&geometry);
       for (next=image; next != (Image *) NULL; next=GetNextImageInList(next))
       {
         geometry.width+=next->columns;
         geometry.height+=next->rows;
       }
       geometry.width=(size_t) geometry.width/7;
       geometry.height=(size_t) geometry.height/7;
       geometry.x=(ssize_t) pow((double) geometry.width,0.25);
       geometry.y=(ssize_t) pow((double) geometry.height,0.25);
     }
   /*
     Initialize image tiles.
   */
   ashlar_image=AcquireImage(image_info,exception);
   status=SetImageExtent(ashlar_image,geometry.width,geometry.height,exception);
   if (status == MagickFalse)
     {
       ashlar_image=DestroyImageList(ashlar_image);
       return(MagickFalse);
     }
   (void) SetImageBackgroundColor(ashlar_image,exception);
   tiles=(CanvasInfo *) AcquireQuantumMemory(GetImageListLength(image),
     sizeof(*tiles));
   ashlar_info.number_nodes=2*geometry.width;
   nodes=(NodeInfo *) AcquireQuantumMemory(ashlar_info.number_nodes,
     sizeof(*nodes));
   if ((tiles == (CanvasInfo *) NULL) || (nodes == (NodeInfo *) NULL))
     {
       if (tiles != (CanvasInfo *) NULL)
         tiles=(CanvasInfo *) RelinquishMagickMemory(tiles);
       if (nodes != (NodeInfo *) NULL)
         nodes=(NodeInfo *) RelinquishMagickMemory(tiles);
       ashlar_image=DestroyImageList(ashlar_image);
       ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
     }
   /*
     Interate until we find a tile size that fits the canvas.
   */
   value=GetImageOption(image_info,"ashlar:best-fit");
   for (i=20; i > 0; i--)
   {
     ssize_t
       j;
 
     n=0;
     for (next=image; next != (Image *) NULL; next=GetNextImageInList(next))
     {
       tiles[n].id=n;
       tiles[n].width=(size_t) (0.05*i*next->columns+2*geometry.x);
       tiles[n].height=(size_t) (0.05*i*next->rows+2*geometry.y);
       n++;
     }
     for (j=0; j < (ssize_t) ashlar_info.number_nodes-1; j++)
       nodes[j].next=nodes+j+1;
     nodes[j].next=(NodeInfo *) NULL;
     ashlar_info.best_fit=IsStringTrue(value) != MagickFalse ? MagickTrue :
       MagickFalse;
     ashlar_info.free=nodes;
     ashlar_info.current=(&ashlar_info.head);
     ashlar_info.width=geometry.width;
     ashlar_info.height=geometry.height;
     ashlar_info.align=(ssize_t) ((ashlar_info.width+ashlar_info.number_nodes-1)/
       ashlar_info.number_nodes);
     ashlar_info.head.x=0;
     ashlar_info.head.y=0;
     ashlar_info.head.next=(&ashlar_info.sentinal);
     ashlar_info.sentinal.x=(ssize_t) geometry.width;
-    ashlar_info.sentinal.y=(ssize_t) SSIZE_MAX;
+    ashlar_info.sentinal.y=(ssize_t) LONG_MAX;
     ashlar_info.sentinal.next=(NodeInfo *) NULL;
     status=PackAshlarTiles(&ashlar_info,tiles,(size_t) n);
     if (status != MagickFalse)
       break;
   }
   /*
     Determine layout of images tiles on the canvas.
   */
   value=GetImageOption(image_info,"label");
   extent.width=0;
   extent.height=0;
   for (i=0; i < n; i++)
   {
     Image
       *tile_image;
 
-    if ((tiles[i].x == (ssize_t) SSIZE_MAX) ||
-        (tiles[i].y == (ssize_t) SSIZE_MAX))
+    if ((tiles[i].x == (ssize_t) LONG_MAX) ||
+        (tiles[i].y == (ssize_t) LONG_MAX))
       continue;
     tile_image=ResizeImage(GetImageFromList(image,tiles[i].id),(size_t)
       (tiles[i].width-2*geometry.x),(size_t) (tiles[i].height-2*geometry.y),
       image->filter,exception);
     if (tile_image == (Image *) NULL)
       continue;
     (void) CompositeImage(ashlar_image,tile_image,image->compose,MagickTrue,
       tiles[i].x+geometry.x,tiles[i].y+geometry.y,exception);
     if (value != (const char *) NULL)
       {
         char
           *label,
           offset[MagickPathExtent];
 
         DrawInfo
           *draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);
 
         label=InterpretImageProperties((ImageInfo *) image_info,tile_image,
           value,exception);
         if (label != (const char *) NULL)
           {
             (void) CloneString(&draw_info->text,label);
             draw_info->pointsize=1.8*geometry.y;
             (void) FormatLocaleString(offset,MagickPathExtent,"%+g%+g",(double)
               tiles[i].x+geometry.x,(double) tiles[i].height+tiles[i].y+
               geometry.y/2.0);
             (void) CloneString(&draw_info->geometry,offset);
             (void) AnnotateImage(ashlar_image,draw_info,exception);
           }
       }
     if ((tiles[i].width+tiles[i].x) > extent.width)
       extent.width=(size_t) (tiles[i].width+tiles[i].x);
     if ((tiles[i].height+tiles[i].y) > extent.height)
       extent.height=(size_t) (tiles[i].height+tiles[i].y);
     tile_image=DestroyImage(tile_image);
   }
   (void) SetImageExtent(ashlar_image,extent.width,extent.height,exception);
   nodes=(NodeInfo *) RelinquishMagickMemory(nodes);
   tiles=(CanvasInfo *) RelinquishMagickMemory(tiles);
   /*
     Write ASHLAR canvas.
   */
   (void) CopyMagickString(ashlar_image->filename,image_info->filename,
     MagickPathExtent);
   write_info=CloneImageInfo(image_info);
   *write_info->magick='\0';
   (void) SetImageInfo(write_info,1,exception);
   if ((*write_info->magick == '\0') ||
       (LocaleCompare(write_info->magick,"ASHLAR") == 0))
     (void) FormatLocaleString(ashlar_image->filename,MagickPathExtent,
       "miff:%s",write_info->filename);
   status=WriteImage(write_info,ashlar_image,exception);
   ashlar_image=DestroyImage(ashlar_image);
   write_info=DestroyImageInfo(write_info);
   return(MagickTrue);
 }
diff --git a/coders/heic.c b/coders/heic.c
index 13316dd15..7910247ca 100644
--- a/coders/heic.c
+++ b/coders/heic.c
@@ -373,228 +373,228 @@ static MagickBooleanType ReadHEICImageByID(const ImageInfo *image_info,
 static Image *ReadHEICImage(const ImageInfo *image_info,
   ExceptionInfo *exception)
 {
   const StringInfo
     *profile;
 
   heif_item_id
     *image_ids,
     primary_image_id;
 
   Image
     *image;
 
   MagickBooleanType
     status;
 
   size_t
     count,
     length;
 
   struct heif_context
     *heif_context;
 
   struct heif_error
     error;
 
   struct heif_image_handle
     *image_handle;
 
   void
     *file_data;
 
   /*
     Open image file.
   */
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickCoreSignature);
   if (image_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",
       image_info->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickCoreSignature);
   image=AcquireImage(image_info,exception);
   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
   if (status == MagickFalse)
     return(DestroyImageList(image));
-  if (GetBlobSize(image) > (MagickSizeType) SSIZE_MAX)
+  if (GetBlobSize(image) > (MagickSizeType) LONG_MAX)
     ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
   length=(size_t) GetBlobSize(image);
   file_data=AcquireMagickMemory(length);
   if (file_data == (void *) NULL)
     ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
   if (ReadBlob(image,length,file_data) != (ssize_t) length)
     {
       file_data=RelinquishMagickMemory(file_data);
       ThrowReaderException(CorruptImageError,"InsufficientImageDataInFile");
     }
   /*
     Decode HEIF image.
   */
   heif_context=heif_context_alloc();
   error=heif_context_read_from_memory_without_copy(heif_context,file_data,
     length,NULL);
   if (IsHeifSuccess(image,&error,exception) == MagickFalse)
     {
       heif_context_free(heif_context);
       file_data=RelinquishMagickMemory(file_data);
       return(DestroyImageList(image));
     }
   error=heif_context_get_primary_image_ID(heif_context,&primary_image_id);
   if (IsHeifSuccess(image,&error,exception) == MagickFalse)
     {
       heif_context_free(heif_context);
       file_data=RelinquishMagickMemory(file_data);
       return(DestroyImageList(image));
     }
   error=heif_context_get_image_handle(heif_context,primary_image_id,
     &image_handle);
   if (IsHeifSuccess(image,&error,exception) == MagickFalse)
     {
       heif_context_free(heif_context);
       file_data=RelinquishMagickMemory(file_data);
       return(DestroyImageList(image));
     }
   status=ReadHEICImageByID(image_info,image,image_handle,exception);
   image_ids=(heif_item_id *) NULL;
   count=(size_t) heif_context_get_number_of_top_level_images(heif_context);
   if ((status != MagickFalse) && (count > 1))
     {
       size_t
         i;
 
       image_ids=(heif_item_id *) AcquireQuantumMemory((size_t) count,
         sizeof(*image_ids));
       if (image_ids == (heif_item_id *) NULL)
         {
           heif_image_handle_release(image_handle);
           heif_context_free(heif_context);
           file_data=RelinquishMagickMemory(file_data);
           return(DestroyImageList(image));
         }
       (void) heif_context_get_list_of_top_level_image_IDs(heif_context,
         image_ids,(int) count);
       for (i=0; i < count; i++)
       {
         if (image_ids[i] == primary_image_id)
           continue;
         /*
           Allocate next image structure.
         */
         AcquireNextImage(image_info,image,exception);
         if (GetNextImageInList(image) == (Image *) NULL)
           {
             status=MagickFalse;
             break;
           }
         image=SyncNextImageInList(image);
         error=heif_context_get_image_handle(heif_context,primary_image_id,
           &image_handle);
         if (IsHeifSuccess(image,&error,exception) == MagickFalse)
           {
             status=MagickFalse;
             break;
           }
         status=ReadHEICImageByID(image_info,image,image_handle,exception);
         if (status == MagickFalse)
           break;
         if (image_info->number_scenes != 0)
           if (image->scene >= (image_info->scene+image_info->number_scenes-1))
             break;
       }
     }
   heif_image_handle_release(image_handle);
   error=heif_context_get_image_handle(heif_context,primary_image_id,
     &image_handle);
   if (IsHeifSuccess(image,&error,exception) == MagickFalse)
     {
       heif_context_free(heif_context);
       file_data=RelinquishMagickMemory(file_data);
       return(DestroyImageList(image));
     }
   if (heif_image_handle_has_depth_image(image_handle) != 0)
     {
       heif_item_id
         depth_id;
 
       int
         number_images;
 
       /*
         Read depth image.
       */
       number_images=heif_image_handle_get_list_of_depth_image_IDs(image_handle,
         &depth_id,1);
       if (number_images > 0)
         {
           struct heif_image_handle
             *depth_handle;
 
           error=heif_image_handle_get_depth_image_handle(image_handle,depth_id,
             &depth_handle);
           if (IsHeifSuccess(image,&error,exception) != MagickFalse)
             {
               AcquireNextImage(image_info,image,exception);
               if (GetNextImageInList(image) == (Image *) NULL)
                 status=MagickFalse;
               image=SyncNextImageInList(image);
               status=ReadHEICImageByID(image_info,image,depth_handle,
                 exception);
               heif_image_handle_release(depth_handle);
             }
        }
     }
   heif_image_handle_release(image_handle);
   if (image_ids != (heif_item_id *) NULL)
     (void) RelinquishMagickMemory(image_ids);
   heif_context_free(heif_context);
   file_data=RelinquishMagickMemory(file_data);
   if (status == MagickFalse)
     return(DestroyImageList(image));
   image=GetFirstImageInList(image);
   profile=GetImageProfile(image,"icc");
   if (profile != (const StringInfo *) NULL)
     {
       Image
         *next;
 
       /*
         Change image colorspace if it contains a color profile.
       */
       for (next=image; next != (Image *) NULL; next=GetNextImageInList(next))
         if (HEICSkipImage(image_info,next) != MagickFalse)
           {
             if (image_info->ping == MagickFalse)
               (void) TransformImageColorspace(next,sRGBColorspace,exception);
             else
               next->colorspace=sRGBColorspace;
           }
     }
   return(image);
 }
 #endif
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   I s H E I C                                                               %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  IsHEIC() returns MagickTrue if the image format type, identified by the
 %  magick string, is Heic.
 %
 %  The format of the IsHEIC method is:
 %
 %      MagickBooleanType IsHEIC(const unsigned char *magick,const size_t length)
 %
 %  A description of each parameter follows:
 %
 %    o magick: compare image format pattern against these bytes.
 %
 %    o length: Specifies the length of the magick string.
 %
 */
diff --git a/coders/tiff.c b/coders/tiff.c
index 2ca7cd9b9..92d30724a 100644
--- a/coders/tiff.c
+++ b/coders/tiff.c
@@ -238,41 +238,41 @@ static MagickBooleanType
 static MagickOffsetType TIFFSeekCustomStream(const MagickOffsetType offset,
   const int whence,void *user_data)
 {
   PhotoshopProfile
     *profile;
 
   profile=(PhotoshopProfile *) user_data;
   switch (whence)
   {
     case SEEK_SET:
     default:
     {
       if (offset < 0)
         return(-1);
       profile->offset=offset;
       break;
     }
     case SEEK_CUR:
     {
-      if (((offset > 0) && (profile->offset > (SSIZE_MAX-offset))) ||
-          ((offset < 0) && (profile->offset < (-SSIZE_MAX-offset))))
+      if (((offset > 0) && (profile->offset > (LONG_MAX-offset))) ||
+          ((offset < 0) && (profile->offset < (LONG_MIN-offset))))
         {
           errno=EOVERFLOW;
           return(-1);
         }
       if ((profile->offset+offset) < 0)
         return(-1);
       profile->offset+=offset;
       break;
     }
     case SEEK_END:
     {
       if (((MagickOffsetType) profile->length+offset) < 0)
         return(-1);
       profile->offset=profile->length+offset;
       break;
     }
   }
 
   return(profile->offset);
 }
