commit c4de49edc4652e2f17c8747a6dd9b36ff362017a
Author: Michael Niedermayer <michael@niedermayer.cc>
Date:   Mon Sep 30 23:42:41 2019 +0200

    avformat/electronicarts: If no packet has been read at the end do not treat it as if theres a packet
    
    Fixes: Assertion failure
    Fixes: 17770/clusterfuzz-testcase-minimized-ffmpeg_DEMUXER_fuzzer-5700606668308480
    
    Found-by: continuous fuzzing process https://github.com/google/oss-fuzz/tree/master/projects/ffmpeg
    Reviewed-by: Peter Ross <pross@xvid.org>
    Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>

diff --git a/libavformat/electronicarts.c b/libavformat/electronicarts.c
index 6dbc3e350a..c894663c29 100644
--- a/libavformat/electronicarts.c
+++ b/libavformat/electronicarts.c
@@ -572,171 +572,175 @@ static int ea_read_header(AVFormatContext *s)
 static int ea_read_packet(AVFormatContext *s, AVPacket *pkt)
 {
     EaDemuxContext *ea = s->priv_data;
     AVIOContext *pb    = s->pb;
     int partial_packet = 0;
+    int hit_end = 0;
     unsigned int chunk_type, chunk_size;
     int ret = 0, packet_read = 0, key = 0;
     int av_uninit(num_samples);
 
-    while (!packet_read || partial_packet) {
+    while ((!packet_read && !hit_end) || partial_packet) {
         chunk_type = avio_rl32(pb);
         chunk_size = ea->big_endian ? avio_rb32(pb) : avio_rl32(pb);
         if (chunk_size < 8)
             return AVERROR_INVALIDDATA;
         chunk_size -= 8;
 
         switch (chunk_type) {
         /* audio data */
         case ISNh_TAG:
             /* header chunk also contains data; skip over the header portion */
             if (chunk_size < 32)
                 return AVERROR_INVALIDDATA;
             avio_skip(pb, 32);
             chunk_size -= 32;
         case ISNd_TAG:
         case SCDl_TAG:
         case SNDC_TAG:
         case SDEN_TAG:
             if (!ea->audio_codec) {
                 avio_skip(pb, chunk_size);
                 break;
             } else if (ea->audio_codec == AV_CODEC_ID_PCM_S16LE_PLANAR ||
                        ea->audio_codec == AV_CODEC_ID_MP3) {
                 num_samples = avio_rl32(pb);
                 avio_skip(pb, 8);
                 chunk_size -= 12;
             } else if (ea->audio_codec == AV_CODEC_ID_ADPCM_PSX) {
                 avio_skip(pb, 8);
                 chunk_size -= 8;
             }
 
             if (partial_packet) {
                 avpriv_request_sample(s, "video header followed by audio packet");
                 av_packet_unref(pkt);
                 partial_packet = 0;
             }
 
             if (!chunk_size)
                 continue;
 
             ret = av_get_packet(pb, pkt, chunk_size);
             if (ret < 0)
                 return ret;
             pkt->stream_index = ea->audio_stream_index;
 
             switch (ea->audio_codec) {
             case AV_CODEC_ID_ADPCM_EA:
             case AV_CODEC_ID_ADPCM_EA_R1:
             case AV_CODEC_ID_ADPCM_EA_R2:
             case AV_CODEC_ID_ADPCM_IMA_EA_EACS:
             case AV_CODEC_ID_ADPCM_EA_R3:
                 if (pkt->size < 4) {
                     av_log(s, AV_LOG_ERROR, "Packet is too short\n");
                     av_packet_unref(pkt);
                     return AVERROR_INVALIDDATA;
                 }
                 if (ea->audio_codec == AV_CODEC_ID_ADPCM_EA_R3)
                     pkt->duration = AV_RB32(pkt->data);
                 else
                     pkt->duration = AV_RL32(pkt->data);
                 break;
             case AV_CODEC_ID_ADPCM_IMA_EA_SEAD:
                 pkt->duration = ret * 2 / ea->num_channels;
                 break;
             case AV_CODEC_ID_PCM_S16LE_PLANAR:
             case AV_CODEC_ID_MP3:
                 pkt->duration = num_samples;
                 break;
             case AV_CODEC_ID_ADPCM_PSX:
                 pkt->duration = chunk_size / (16 * ea->num_channels) * 28;
                 break;
             default:
                 pkt->duration = chunk_size / (ea->bytes * ea->num_channels);
             }
 
             packet_read = 1;
             break;
 
         /* ending tag */
         case 0:
         case ISNe_TAG:
         case SCEl_TAG:
         case SEND_TAG:
         case SEEN_TAG:
             while (!avio_feof(pb)) {
                 int tag = avio_rl32(pb);
 
                 if (tag == ISNh_TAG ||
                     tag == SCHl_TAG ||
                     tag == SEAD_TAG ||
                     tag == SHEN_TAG) {
                     avio_skip(pb, -4);
                     break;
                 }
             }
             if (avio_feof(pb))
                 ret = AVERROR_EOF;
-            packet_read = 1;
+            hit_end = 1;
             break;
 
         case MVIh_TAG:
         case kVGT_TAG:
         case pQGT_TAG:
         case TGQs_TAG:
         case MADk_TAG:
             key = AV_PKT_FLAG_KEY;
         case MVIf_TAG:
         case fVGT_TAG:
         case MADm_TAG:
         case MADe_TAG:
             avio_seek(pb, -8, SEEK_CUR);    // include chunk preamble
             chunk_size += 8;
             goto get_video_packet;
 
         case mTCD_TAG:
             if (chunk_size < 8)
                 return AVERROR_INVALIDDATA;
 
             avio_skip(pb, 8);               // skip ea DCT header
             chunk_size -= 8;
             goto get_video_packet;
 
         case MV0K_TAG:
         case AV0K_TAG:
         case MPCh_TAG:
         case pIQT_TAG:
             key = AV_PKT_FLAG_KEY;
         case MV0F_TAG:
         case AV0F_TAG:
 get_video_packet:
             if (!chunk_size)
                 continue;
 
             if (partial_packet) {
                 ret = av_append_packet(pb, pkt, chunk_size);
             } else
                 ret = av_get_packet(pb, pkt, chunk_size);
             if (ret < 0) {
                 packet_read = 1;
                 break;
             }
             partial_packet = chunk_type == MVIh_TAG;
             if (chunk_type == AV0K_TAG || chunk_type == AV0F_TAG)
                 pkt->stream_index = ea->alpha.stream_index;
             else
                 pkt->stream_index = ea->video.stream_index;
             pkt->flags       |= key;
             packet_read       = 1;
             break;
 
         default:
             avio_skip(pb, chunk_size);
             break;
         }
     }
 
     if (ret < 0 && partial_packet)
         av_packet_unref(pkt);
+    if (ret >= 0 && hit_end && !packet_read)
+        return AVERROR(EAGAIN);
+
     return ret;
 }
 
