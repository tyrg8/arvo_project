commit 8821114a1dda1859210e666e4a371efdbd021863
Author: danielaparker <danielaparker@yahoo.com>
Date:   Thu Apr 29 05:33:12 2021 -0400

    unicode_traits to_codepoint

diff --git a/fuzzers/fuzz_json_encoder.cpp b/fuzzers/fuzz_json_encoder.cpp
index 57fb3c09d..9776bc56b 100644
--- a/fuzzers/fuzz_json_encoder.cpp
+++ b/fuzzers/fuzz_json_encoder.cpp
@@ -6,21 +6,13 @@ using namespace jsoncons;
 extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, std::size_t size)
 {
     std::string s(reinterpret_cast<const char*>(data), size);
     std::istringstream is(s);
 
-    try
-    {
-        std::string s2;
-        json_string_encoder visitor(s2);
-        json_reader reader(is, visitor);
-        std::error_code ec;
-        reader.read(ec);
-        std::cout << ec.message() << "\n";
-    }
-    catch (const std::excption& e)
-    {
-        std::cout << e.what() << "\n";
-    }
+    std::string s2;
+    json_string_encoder visitor(s2);
+    json_reader reader(is, visitor);
+    std::error_code ec;
+    reader.read(ec);
 
     return 0;
 }
diff --git a/include/jsoncons/json_encoder.hpp b/include/jsoncons/json_encoder.hpp
index 5b3530314..fc179d98e 100644
--- a/include/jsoncons/json_encoder.hpp
+++ b/include/jsoncons/json_encoder.hpp
@@ -28,1544 +28,1535 @@ namespace jsoncons {
 namespace detail {
 
     inline
     bool is_control_character(uint32_t c)
     {
         return c <= 0x1F || c == 0x7f;
     }
 
     inline
     bool is_non_ascii_codepoint(uint32_t cp)
     {
         return cp >= 0x80;
     }
 
     template <class CharT, class Sink>
     std::size_t escape_string(const CharT* s, std::size_t length,
                          bool escape_all_non_ascii, bool escape_solidus,
                          Sink& sink)
     {
         std::size_t count = 0;
         const CharT* begin = s;
         const CharT* end = s + length;
         for (const CharT* it = begin; it != end; ++it)
         {
             CharT c = *it;
             switch (c)
             {
                 case '\\':
                     sink.push_back('\\');
                     sink.push_back('\\');
                     count += 2;
                     break;
                 case '"':
                     sink.push_back('\\');
                     sink.push_back('\"');
                     count += 2;
                     break;
                 case '\b':
                     sink.push_back('\\');
                     sink.push_back('b');
                     count += 2;
                     break;
                 case '\f':
                     sink.push_back('\\');
                     sink.push_back('f');
                     count += 2;
                     break;
                 case '\n':
                     sink.push_back('\\');
                     sink.push_back('n');
                     count += 2;
                     break;
                 case '\r':
                     sink.push_back('\\');
                     sink.push_back('r');
                     count += 2;
                     break;
                 case '\t':
                     sink.push_back('\\');
                     sink.push_back('t');
                     count += 2;
                     break;
                 default:
                     if (escape_solidus && c == '/')
                     {
                         sink.push_back('\\');
                         sink.push_back('/');
                         count += 2;
                     }
                     else if (is_control_character(c) || escape_all_non_ascii)
                     {
                         // convert to codepoint
-                        unicode_traits::sequence_generator<const CharT*> g(it, end, unicode_traits::conv_flags::strict);
-                        if (g.done() || g.status() != unicode_traits::conv_errc())
+                        uint32_t cp;
+                        auto r = unicode_traits::to_codepoint(it, end, cp, unicode_traits::conv_flags::strict);
+                        if (r.ec != unicode_traits::conv_errc())
                         {
                             JSONCONS_THROW(ser_error(json_errc::illegal_codepoint));
                         }
-                        uint32_t cp = g.get().codepoint();
-                        it += (g.get().length() - 1);
-
-                        //uint32_t cp;
-                        //auto r = unicode_traits::to_codepoint(it, end, cp, unicode_traits::conv_flags::strict);
-                        //if (r.ec != unicode_traits::conv_errc())
-                        //{
-                        //    JSONCONS_THROW(ser_error(json_errc::illegal_codepoint));
-                        //}
-                        //it = r.ptr;
-
+                        it = r.ptr - 1;
                         if (is_non_ascii_codepoint(cp) || is_control_character(c))
                         {
                             if (cp > 0xFFFF)
                             {
                                 cp -= 0x10000;
                                 uint32_t first = (cp >> 10) + 0xD800;
                                 uint32_t second = ((cp & 0x03FF) + 0xDC00);
 
                                 sink.push_back('\\');
                                 sink.push_back('u');
                                 sink.push_back(jsoncons::detail::to_hex_character(first >> 12 & 0x000F));
                                 sink.push_back(jsoncons::detail::to_hex_character(first >> 8 & 0x000F));
                                 sink.push_back(jsoncons::detail::to_hex_character(first >> 4 & 0x000F));
                                 sink.push_back(jsoncons::detail::to_hex_character(first & 0x000F));
                                 sink.push_back('\\');
                                 sink.push_back('u');
                                 sink.push_back(jsoncons::detail::to_hex_character(second >> 12 & 0x000F));
                                 sink.push_back(jsoncons::detail::to_hex_character(second >> 8 & 0x000F));
                                 sink.push_back(jsoncons::detail::to_hex_character(second >> 4 & 0x000F));
                                 sink.push_back(jsoncons::detail::to_hex_character(second & 0x000F));
                                 count += 12;
                             }
                             else
                             {
                                 sink.push_back('\\');
                                 sink.push_back('u');
                                 sink.push_back(jsoncons::detail::to_hex_character(cp >> 12 & 0x000F));
                                 sink.push_back(jsoncons::detail::to_hex_character(cp >> 8 & 0x000F));
                                 sink.push_back(jsoncons::detail::to_hex_character(cp >> 4 & 0x000F));
                                 sink.push_back(jsoncons::detail::to_hex_character(cp & 0x000F));
                                 count += 6;
                             }
                         }
                         else
                         {
                             sink.push_back(c);
                             ++count;
                         }
                     }
                     else
                     {
                         sink.push_back(c);
                         ++count;
                     }
                     break;
             }
         }
         return count;
     }
 
     inline
     byte_string_chars_format resolve_byte_string_chars_format(byte_string_chars_format format1,
                                                               byte_string_chars_format format2,
                                                               byte_string_chars_format default_format = byte_string_chars_format::base64url)
     {
         byte_string_chars_format sink;
         switch (format1)
         {
             case byte_string_chars_format::base16:
             case byte_string_chars_format::base64:
             case byte_string_chars_format::base64url:
                 sink = format1;
                 break;
             default:
                 switch (format2)
                 {
                     case byte_string_chars_format::base64url:
                     case byte_string_chars_format::base64:
                     case byte_string_chars_format::base16:
                         sink = format2;
                         break;
                     default: // base64url
                     {
                         sink = default_format;
                         break;
                     }
                 }
                 break;
         }
         return sink;
     }
 
 } // namespace detail
 
     template<class CharT,class Sink=jsoncons::stream_sink<CharT>,class Allocator=std::allocator<char>>
     class basic_json_encoder final : public basic_json_visitor<CharT>
     {
         static const std::array<CharT, 4>& null_k()
         {
             static constexpr std::array<CharT,4> k{'n','u','l','l'};
             return k;
         }
         static const std::array<CharT, 4>& true_k()
         {
             static constexpr std::array<CharT,4> k{'t','r','u','e'};
             return k;
         }
         static const std::array<CharT, 5>& false_k()
         {
             static constexpr std::array<CharT,5> k{'f','a','l','s','e'};
             return k;
         }
     public:
         using allocator_type = Allocator;
         using char_type = CharT;
         using typename basic_json_visitor<CharT>::string_view_type;
         using sink_type = Sink;
         using string_type = typename basic_json_encode_options<CharT>::string_type;
 
     private:
         enum class container_type {object, array};
 
         class encoding_context
         {
             container_type type_;
             std::size_t count_;
             line_split_kind line_splits_;
             bool indent_before_;
             bool new_line_after_;
             std::size_t begin_pos_;
             std::size_t data_pos_;
         public:
             encoding_context(container_type type, line_split_kind split_lines, bool indent_once,
                              std::size_t begin_pos, std::size_t data_pos) noexcept
                : type_(type), count_(0), line_splits_(split_lines), indent_before_(indent_once), new_line_after_(false),
                  begin_pos_(begin_pos), data_pos_(data_pos)
             {
             }
 
             encoding_context(const encoding_context&) = default;
             encoding_context& operator=(const encoding_context&) = default;
 
             void set_position(std::size_t pos)
             {
                 data_pos_ = pos;
             }
 
             std::size_t begin_pos() const
             {
                 return begin_pos_;
             }
 
             std::size_t data_pos() const
             {
                 return data_pos_;
             }
 
             std::size_t count() const
             {
                 return count_;
             }
 
             void increment_count()
             {
                 ++count_;
             }
 
             bool new_line_after() const
             {
                 return new_line_after_;
             }
 
             void new_line_after(bool value) 
             {
                 new_line_after_ = value;
             }
 
             bool is_object() const
             {
                 return type_ == container_type::object;
             }
 
             bool is_array() const
             {
                 return type_ == container_type::array;
             }
 
             bool is_same_line() const
             {
                 return line_splits_ == line_split_kind::same_line;
             }
 
             bool is_new_line() const
             {
                 return line_splits_ == line_split_kind::new_line;
             }
 
             bool is_multi_line() const
             {
                 return line_splits_ == line_split_kind::multi_line;
             }
 
             bool is_indent_once() const
             {
                 return count_ == 0 ? indent_before_ : false;
             }
 
         };
         typedef typename std::allocator_traits<allocator_type>:: template rebind_alloc<encoding_context> encoding_context_allocator_type;
 
         Sink sink_;
         basic_json_encode_options<CharT> options_;
         jsoncons::detail::write_double fp_;
 
         std::vector<encoding_context,encoding_context_allocator_type> stack_;
         int indent_amount_;
         std::size_t column_;
         std::basic_string<CharT> colon_str_;
         std::basic_string<CharT> comma_str_;
         std::basic_string<CharT> open_object_brace_str_;
         std::basic_string<CharT> close_object_brace_str_;
         std::basic_string<CharT> open_array_bracket_str_;
         std::basic_string<CharT> close_array_bracket_str_;
         int nesting_depth_;
 
         // Noncopyable and nonmoveable
         basic_json_encoder(const basic_json_encoder&) = delete;
         basic_json_encoder& operator=(const basic_json_encoder&) = delete;
     public:
         basic_json_encoder(Sink&& sink, 
                            const Allocator& alloc = Allocator())
             : basic_json_encoder(std::forward<Sink>(sink), basic_json_encode_options<CharT>(), alloc)
         {
         }
 
         basic_json_encoder(Sink&& sink, 
                            const basic_json_encode_options<CharT>& options, 
                            const Allocator& alloc = Allocator())
            : sink_(std::forward<Sink>(sink)), 
              options_(options),
              fp_(options.float_format(), options.precision()),
              stack_(alloc),
              indent_amount_(0), 
              column_(0),
              nesting_depth_(0)
         {
             switch (options.spaces_around_colon())
             {
                 case spaces_option::space_after:
                     colon_str_ = std::basic_string<CharT>({':',' '});
                     break;
                 case spaces_option::space_before:
                     colon_str_ = std::basic_string<CharT>({' ',':'});
                     break;
                 case spaces_option::space_before_and_after:
                     colon_str_ = std::basic_string<CharT>({' ',':',' '});
                     break;
                 default:
                     colon_str_.push_back(':');
                     break;
             }
             switch (options.spaces_around_comma())
             {
                 case spaces_option::space_after:
                     comma_str_ = std::basic_string<CharT>({',',' '});
                     break;
                 case spaces_option::space_before:
                     comma_str_ = std::basic_string<CharT>({' ',','});
                     break;
                 case spaces_option::space_before_and_after:
                     comma_str_ = std::basic_string<CharT>({' ',',',' '});
                     break;
                 default:
                     comma_str_.push_back(',');
                     break;
             }
             if (options.pad_inside_object_braces())
             {
                 open_object_brace_str_ = std::basic_string<CharT>({'{', ' '});
                 close_object_brace_str_ = std::basic_string<CharT>({' ', '}'});
             }
             else
             {
                 open_object_brace_str_.push_back('{');
                 close_object_brace_str_.push_back('}');
             }
             if (options.pad_inside_array_brackets())
             {
                 open_array_bracket_str_ = std::basic_string<CharT>({'[', ' '});
                 close_array_bracket_str_ = std::basic_string<CharT>({' ', ']'});
             }
             else
             {
                 open_array_bracket_str_.push_back('[');
                 close_array_bracket_str_.push_back(']');
             }
         }
 
         ~basic_json_encoder() noexcept
         {
             JSONCONS_TRY
             {
                 sink_.flush();
             }
             JSONCONS_CATCH(...)
             {
             }
         }
 
     private:
         // Implementing methods
         void visit_flush() override
         {
             sink_.flush();
         }
 
         bool visit_begin_object(semantic_tag, const ser_context&, std::error_code& ec) override
         {
             if (JSONCONS_UNLIKELY(++nesting_depth_ > options_.max_nesting_depth()))
             {
                 ec = json_errc::max_nesting_depth_exceeded;
                 return false;
             } 
             if (!stack_.empty() && stack_.back().is_array() && stack_.back().count() > 0)
             {
                 sink_.append(comma_str_.data(),comma_str_.length());
                 column_ += comma_str_.length();
             }
 
             if (!stack_.empty()) // object or array
             {
                 if (stack_.back().is_object())
                 {
                     switch (options_.object_object_line_splits())
                     {
                         case line_split_kind::same_line:
                             if (column_ >= options_.line_length_limit())
                             {
                                 break_line();
                             }
                             break;
                         case line_split_kind::new_line:
                             if (column_ >= options_.line_length_limit())
                             {
                                 break_line();
                             }
                             break;
                         default: // multi_line
                             break;
                     }
                     stack_.emplace_back(container_type::object,options_.object_object_line_splits(), false,
                                         column_, column_+open_object_brace_str_.length());
                 }
                 else // array
                 {
                     switch (options_.array_object_line_splits())
                     {
                         case line_split_kind::same_line:
                             if (column_ >= options_.line_length_limit())
                             {
                                 //stack_.back().new_line_after(true);
                                 new_line();
                             }
                             break;
                         case line_split_kind::new_line:
                             stack_.back().new_line_after(true);
                             new_line();
                             break;
                         default: // multi_line
                             stack_.back().new_line_after(true);
                             new_line();
                             break;
                     }
                     stack_.emplace_back(container_type::object,options_.array_object_line_splits(), false,
                                         column_, column_+open_object_brace_str_.length());
                 }
             }
             else 
             {
                 stack_.emplace_back(container_type::object, line_split_kind::multi_line, false,
                                     column_, column_+open_object_brace_str_.length());
             }
             indent();
             
             sink_.append(open_object_brace_str_.data(), open_object_brace_str_.length());
             column_ += open_object_brace_str_.length();
             return true;
         }
 
         bool visit_end_object(const ser_context&, std::error_code&) override
         {
             JSONCONS_ASSERT(!stack_.empty());
             --nesting_depth_;
 
             unindent();
             if (stack_.back().new_line_after())
             {
                 new_line();
             }
             stack_.pop_back();
             sink_.append(close_object_brace_str_.data(), close_object_brace_str_.length());
             column_ += close_object_brace_str_.length();
 
             end_value();
             return true;
         }
 
         bool visit_begin_array(semantic_tag, const ser_context&, std::error_code& ec) override
         {
             if (JSONCONS_UNLIKELY(++nesting_depth_ > options_.max_nesting_depth()))
             {
                 ec = json_errc::max_nesting_depth_exceeded;
                 return false;
             } 
             if (!stack_.empty() && stack_.back().is_array() && stack_.back().count() > 0)
             {
                 sink_.append(comma_str_.data(),comma_str_.length());
                 column_ += comma_str_.length();
             }
             if (!stack_.empty())
             {
                 if (stack_.back().is_object())
                 {
                     switch (options_.object_array_line_splits())
                     {
                         case line_split_kind::same_line:
                             stack_.emplace_back(container_type::array,options_.object_array_line_splits(),false,
                                                 column_, column_ + open_array_bracket_str_.length());
                             break;
                         case line_split_kind::new_line:
                         {
                             stack_.emplace_back(container_type::array,options_.object_array_line_splits(),true,
                                                 column_, column_+open_array_bracket_str_.length());
                             break;
                         }
                         default: // multi_line
                             stack_.emplace_back(container_type::array,options_.object_array_line_splits(),true,
                                                 column_, column_+open_array_bracket_str_.length());
                             break;
                     }
                 }
                 else // array
                 {
                     switch (options_.array_array_line_splits())
                     {
                         case line_split_kind::same_line:
                             if (stack_.back().is_multi_line())
                             {
                                 stack_.back().new_line_after(true);
                                 new_line();
                             }
                             stack_.emplace_back(container_type::array,options_.array_array_line_splits(), false,
                                                 column_, column_+open_array_bracket_str_.length());
                             break;
                         case line_split_kind::new_line:
                             stack_.back().new_line_after(true);
                             new_line();
                             stack_.emplace_back(container_type::array,options_.array_array_line_splits(), false,
                                                 column_, column_+open_array_bracket_str_.length());
                             break;
                         default: // multi_line
                             stack_.back().new_line_after(true);
                             new_line();
                             stack_.emplace_back(container_type::array,options_.array_array_line_splits(), false,
                                                 column_, column_+open_array_bracket_str_.length());
                             //new_line();
                             break;
                     }
                 }
             }
             else 
             {
                 stack_.emplace_back(container_type::array, line_split_kind::multi_line, false,
                                     column_, column_+open_array_bracket_str_.length());
             }
             indent();
             sink_.append(open_array_bracket_str_.data(), open_array_bracket_str_.length());
             column_ += open_array_bracket_str_.length();
             return true;
         }
 
         bool visit_end_array(const ser_context&, std::error_code&) override
         {
             JSONCONS_ASSERT(!stack_.empty());
             --nesting_depth_;
 
             unindent();
             if (stack_.back().new_line_after())
             {
                 new_line();
             }
             stack_.pop_back();
             sink_.append(close_array_bracket_str_.data(), close_array_bracket_str_.length());
             column_ += close_array_bracket_str_.length();
             end_value();
             return true;
         }
 
         bool visit_key(const string_view_type& name, const ser_context&, std::error_code&) override
         {
             JSONCONS_ASSERT(!stack_.empty());
             if (stack_.back().count() > 0)
             {
                 sink_.append(comma_str_.data(),comma_str_.length());
                 column_ += comma_str_.length();
             }
 
             if (stack_.back().is_multi_line())
             {
                 stack_.back().new_line_after(true);
                 new_line();
             }
             else if (stack_.back().count() > 0 && column_ >= options_.line_length_limit())
             {
                 //stack_.back().new_line_after(true);
                 new_line(stack_.back().data_pos());
             }
 
             if (stack_.back().count() == 0)
             {
                 stack_.back().set_position(column_);
             }
             sink_.push_back('\"');
             std::size_t length = jsoncons::detail::escape_string(name.data(), name.length(),options_.escape_all_non_ascii(),options_.escape_solidus(),sink_);
             sink_.push_back('\"');
             sink_.append(colon_str_.data(),colon_str_.length());
             column_ += (length+2+colon_str_.length());
             return true;
         }
 
         bool visit_null(semantic_tag, const ser_context&, std::error_code&) override
         {
             if (!stack_.empty()) 
             {
                 if (stack_.back().is_array())
                 {
                     begin_scalar_value();
                 }
                 if (!stack_.back().is_multi_line() && column_ >= options_.line_length_limit())
                 {
                     break_line();
                 }
             }
 
             sink_.append(null_k().data(), null_k().size());
             column_ += null_k().size();
 
             end_value();
             return true;
         }
 
         bool visit_string(const string_view_type& sv, semantic_tag tag, const ser_context&, std::error_code&) override
         {
             if (!stack_.empty()) 
             {
                 if (stack_.back().is_array())
                 {
                     begin_scalar_value();
                 }
                 if (!stack_.back().is_multi_line() && column_ >= options_.line_length_limit())
                 {
                     break_line();
                 }
             }
 
             switch (tag)
             {
                 case semantic_tag::bigint:
                     write_bigint_value(sv);
                     break;
                 default:
                 {
                     sink_.push_back('\"');
                     std::size_t length = jsoncons::detail::escape_string(sv.data(), sv.length(),options_.escape_all_non_ascii(),options_.escape_solidus(),sink_);
                     sink_.push_back('\"');
                     column_ += (length+2);
                     break;
                 }
             }
 
             end_value();
             return true;
         }
 
         bool visit_byte_string(const byte_string_view& b, 
                                   semantic_tag tag,
                                   const ser_context&,
                                   std::error_code&) override
         {
             if (!stack_.empty()) 
             {
                 if (stack_.back().is_array())
                 {
                     begin_scalar_value();
                 }
                 if (!stack_.back().is_multi_line() && column_ >= options_.line_length_limit())
                 {
                     break_line();
                 }
             }
 
             byte_string_chars_format encoding_hint;
             switch (tag)
             {
                 case semantic_tag::base16:
                     encoding_hint = byte_string_chars_format::base16;
                     break;
                 case semantic_tag::base64:
                     encoding_hint = byte_string_chars_format::base64;
                     break;
                 case semantic_tag::base64url:
                     encoding_hint = byte_string_chars_format::base64url;
                     break;
                 default:
                     encoding_hint = byte_string_chars_format::none;
                     break;
             }
 
             byte_string_chars_format format = jsoncons::detail::resolve_byte_string_chars_format(options_.byte_string_format(), 
                                                                                                  encoding_hint, 
                                                                                                  byte_string_chars_format::base64url);
             switch (format)
             {
                 case byte_string_chars_format::base16:
                 {
                     sink_.push_back('\"');
                     std::size_t length = encode_base16(b.begin(),b.end(),sink_);
                     sink_.push_back('\"');
                     column_ += (length + 2);
                     break;
                 }
                 case byte_string_chars_format::base64:
                 {
                     sink_.push_back('\"');
                     std::size_t length = encode_base64(b.begin(), b.end(), sink_);
                     sink_.push_back('\"');
                     column_ += (length + 2);
                     break;
                 }
                 case byte_string_chars_format::base64url:
                 {
                     sink_.push_back('\"');
                     std::size_t length = encode_base64url(b.begin(),b.end(),sink_);
                     sink_.push_back('\"');
                     column_ += (length + 2);
                     break;
                 }
                 default:
                 {
                     JSONCONS_UNREACHABLE();
                 }
             }
 
             end_value();
             return true;
         }
 
         bool visit_double(double value, 
                              semantic_tag,
                              const ser_context& context,
                              std::error_code& ec) override
         {
             if (!stack_.empty()) 
             {
                 if (stack_.back().is_array())
                 {
                     begin_scalar_value();
                 }
                 if (!stack_.back().is_multi_line() && column_ >= options_.line_length_limit())
                 {
                     break_line();
                 }
             }
 
             if (!std::isfinite(value))
             {
                 if ((std::isnan)(value))
                 {
                     if (options_.enable_nan_to_num())
                     {
                         sink_.append(options_.nan_to_num().data(), options_.nan_to_num().length());
                         column_ += options_.nan_to_num().length();
                     }
                     else if (options_.enable_nan_to_str())
                     {
                         visit_string(options_.nan_to_str(), semantic_tag::none, context, ec);
                     }
                     else
                     {
                         sink_.append(null_k().data(), null_k().size());
                         column_ += null_k().size();
                     }
                 }
                 else if (value == std::numeric_limits<double>::infinity())
                 {
                     if (options_.enable_inf_to_num())
                     {
                         sink_.append(options_.inf_to_num().data(), options_.inf_to_num().length());
                         column_ += options_.inf_to_num().length();
                     }
                     else if (options_.enable_inf_to_str())
                     {
                         visit_string(options_.inf_to_str(), semantic_tag::none, context, ec);
                     }
                     else
                     {
                         sink_.append(null_k().data(), null_k().size());
                         column_ += null_k().size();
                     }
                 }
                 else
                 {
                     if (options_.enable_neginf_to_num())
                     {
                         sink_.append(options_.neginf_to_num().data(), options_.neginf_to_num().length());
                         column_ += options_.neginf_to_num().length();
                     }
                     else if (options_.enable_neginf_to_str())
                     {
                         visit_string(options_.neginf_to_str(), semantic_tag::none, context, ec);
                     }
                     else
                     {
                         sink_.append(null_k().data(), null_k().size());
                         column_ += null_k().size();
                     }
                 }
             }
             else
             {
                 std::size_t length = fp_(value, sink_);
                 column_ += length;
             }
 
             end_value();
             return true;
         }
 
         bool visit_int64(int64_t value, 
                             semantic_tag,
                             const ser_context&,
                             std::error_code&) override
         {
             if (!stack_.empty()) 
             {
                 if (stack_.back().is_array())
                 {
                     begin_scalar_value();
                 }
                 if (!stack_.back().is_multi_line() && column_ >= options_.line_length_limit())
                 {
                     break_line();
                 }
             }
             std::size_t length = jsoncons::detail::from_integer(value, sink_);
             column_ += length;
             end_value();
             return true;
         }
 
         bool visit_uint64(uint64_t value, 
                              semantic_tag, 
                              const ser_context&,
                              std::error_code&) override
         {
             if (!stack_.empty()) 
             {
                 if (stack_.back().is_array())
                 {
                     begin_scalar_value();
                 }
                 if (!stack_.back().is_multi_line() && column_ >= options_.line_length_limit())
                 {
                     break_line();
                 }
             }
             std::size_t length = jsoncons::detail::from_integer(value, sink_);
             column_ += length;
             end_value();
             return true;
         }
 
         bool visit_bool(bool value, semantic_tag, const ser_context&, std::error_code&) override
         {
             if (!stack_.empty()) 
             {
                 if (stack_.back().is_array())
                 {
                     begin_scalar_value();
                 }
                 if (!stack_.back().is_multi_line() && column_ >= options_.line_length_limit())
                 {
                     break_line();
                 }
             }
 
             if (value)
             {
                 sink_.append(true_k().data(), true_k().size());
                 column_ += true_k().size();
             }
             else
             {
                 sink_.append(false_k().data(), false_k().size());
                 column_ += false_k().size();
             }
 
             end_value();
             return true;
         }
 
         void begin_scalar_value()
         {
             if (!stack_.empty())
             {
                 if (stack_.back().count() > 0)
                 {
                     sink_.append(comma_str_.data(),comma_str_.length());
                     column_ += comma_str_.length();
                 }
                 if (stack_.back().is_multi_line() || stack_.back().is_indent_once())
                 {
                     stack_.back().new_line_after(true);
                     new_line();
                 }
             }
         }
 
         void write_bigint_value(const string_view_type& sv)
         {
             switch (options_.bigint_format())
             {
                 case bigint_chars_format::number:
                 {
                     sink_.append(sv.data(),sv.size());
                     column_ += sv.size();
                     break;
                 }
                 case bigint_chars_format::base64:
                 {
                     bigint n = bigint::from_string(sv.data(), sv.length());
                     bool is_neg = n < 0;
                     if (is_neg)
                     {
                         n = - n -1;
                     }
                     int signum;
                     std::vector<uint8_t> v;
                     n.write_bytes_be(signum, v);
 
                     sink_.push_back('\"');
                     if (is_neg)
                     {
                         sink_.push_back('~');
                         ++column_;
                     }
                     std::size_t length = encode_base64(v.begin(), v.end(), sink_);
                     sink_.push_back('\"');
                     column_ += (length+2);
                     break;
                 }
                 case bigint_chars_format::base64url:
                 {
                     bigint n = bigint::from_string(sv.data(), sv.length());
                     bool is_neg = n < 0;
                     if (is_neg)
                     {
                         n = - n -1;
                     }
                     int signum;
                     std::vector<uint8_t> v;
                     n.write_bytes_be(signum, v);
 
                     sink_.push_back('\"');
                     if (is_neg)
                     {
                         sink_.push_back('~');
                         ++column_;
                     }
                     std::size_t length = encode_base64url(v.begin(), v.end(), sink_);
                     sink_.push_back('\"');
                     column_ += (length+2);
                     break;
                 }
                 default:
                 {
                     sink_.push_back('\"');
                     sink_.append(sv.data(),sv.size());
                     sink_.push_back('\"');
                     column_ += (sv.size() + 2);
                     break;
                 }
             }
         }
 
         void end_value()
         {
             if (!stack_.empty())
             {
                 stack_.back().increment_count();
             }
         }
 
         void indent()
         {
             indent_amount_ += static_cast<int>(options_.indent_size());
         }
 
         void unindent()
         {
             indent_amount_ -= static_cast<int>(options_.indent_size());
         }
 
         void new_line()
         {
             sink_.append(options_.new_line_chars().data(),options_.new_line_chars().length());
             for (int i = 0; i < indent_amount_; ++i)
             {
                 sink_.push_back(' ');
             }
             column_ = indent_amount_;
         }
 
         void new_line(std::size_t len)
         {
             sink_.append(options_.new_line_chars().data(),options_.new_line_chars().length());
             for (std::size_t i = 0; i < len; ++i)
             {
                 sink_.push_back(' ');
             }
             column_ = len;
         }
 
         void break_line()
         {
             stack_.back().new_line_after(true);
             new_line();
         }
     };
 
     template<class CharT,class Sink=jsoncons::stream_sink<CharT>,class Allocator=std::allocator<char>>
     class basic_compact_json_encoder final : public basic_json_visitor<CharT>
     {
         static const std::array<CharT, 4>& null_k()
         {
             static constexpr std::array<CharT,4> k{'n','u','l','l'};
             return k;
         }
         static const std::array<CharT, 4>& true_k()
         {
             static constexpr std::array<CharT,4> k{'t','r','u','e'};
             return k;
         }
         static const std::array<CharT, 5>& false_k()
         {
             static constexpr std::array<CharT,5> k{'f','a','l','s','e'};
             return k;
         }
     public:
         using allocator_type = Allocator;
         using char_type = CharT;
         using typename basic_json_visitor<CharT>::string_view_type;
         using sink_type = Sink;
         using string_type = typename basic_json_encode_options<CharT>::string_type;
 
     private:
         enum class container_type {object, array};
 
         class encoding_context
         {
             container_type type_;
             std::size_t count_;
         public:
             encoding_context(container_type type) noexcept
                : type_(type), count_(0)
             {
             }
 
             std::size_t count() const
             {
                 return count_;
             }
 
             void increment_count()
             {
                 ++count_;
             }
 
             bool is_array() const
             {
                 return type_ == container_type::array;
             }
         };
         typedef typename std::allocator_traits<allocator_type>:: template rebind_alloc<encoding_context> encoding_context_allocator_type;
 
         Sink sink_;
         basic_json_encode_options<CharT> options_;
         jsoncons::detail::write_double fp_;
         std::vector<encoding_context,encoding_context_allocator_type> stack_;
         int nesting_depth_;
 
         // Noncopyable
         basic_compact_json_encoder(const basic_compact_json_encoder&) = delete;
         basic_compact_json_encoder& operator=(const basic_compact_json_encoder&) = delete;
     public:
         basic_compact_json_encoder(Sink&& sink, 
                                       const Allocator& alloc = Allocator())
             : basic_compact_json_encoder(std::forward<Sink>(sink), basic_json_encode_options<CharT>(), alloc)
         {
         }
 
         basic_compact_json_encoder(Sink&& sink, 
                                       const basic_json_encode_options<CharT>& options, 
                                       const Allocator& alloc = Allocator())
            : sink_(std::forward<Sink>(sink)),
              options_(options),
              fp_(options.float_format(), options.precision()),
              stack_(alloc),
              nesting_depth_(0)          
         {
         }
 
         basic_compact_json_encoder(basic_compact_json_encoder&&) = default;
         basic_compact_json_encoder& operator=(basic_compact_json_encoder&&) = default;
 
         ~basic_compact_json_encoder() noexcept
         {
             JSONCONS_TRY
             {
                 sink_.flush();
             }
             JSONCONS_CATCH(...)
             {
             }
         }
 
 
     private:
         // Implementing methods
         void visit_flush() override
         {
             sink_.flush();
         }
 
         bool visit_begin_object(semantic_tag, const ser_context&, std::error_code& ec) override
         {
             if (JSONCONS_UNLIKELY(++nesting_depth_ > options_.max_nesting_depth()))
             {
                 ec = json_errc::max_nesting_depth_exceeded;
                 return false;
             } 
             if (!stack_.empty() && stack_.back().is_array() && stack_.back().count() > 0)
             {
                 sink_.push_back(',');
             }
 
             stack_.emplace_back(container_type::object);
             sink_.push_back('{');
             return true;
         }
 
         bool visit_end_object(const ser_context&, std::error_code&) override
         {
             JSONCONS_ASSERT(!stack_.empty());
             --nesting_depth_;
 
             stack_.pop_back();
             sink_.push_back('}');
 
             if (!stack_.empty())
             {
                 stack_.back().increment_count();
             }
             return true;
         }
 
 
         bool visit_begin_array(semantic_tag, const ser_context&, std::error_code& ec) override
         {
             if (JSONCONS_UNLIKELY(++nesting_depth_ > options_.max_nesting_depth()))
             {
                 ec = json_errc::max_nesting_depth_exceeded;
                 return false;
             } 
             if (!stack_.empty() && stack_.back().is_array() && stack_.back().count() > 0)
             {
                 sink_.push_back(',');
             }
             stack_.emplace_back(container_type::array);
             sink_.push_back('[');
             return true;
         }
 
         bool visit_end_array(const ser_context&, std::error_code&) override
         {
             JSONCONS_ASSERT(!stack_.empty());
             --nesting_depth_;
 
             stack_.pop_back();
             sink_.push_back(']');
             if (!stack_.empty())
             {
                 stack_.back().increment_count();
             }
             return true;
         }
 
         bool visit_key(const string_view_type& name, const ser_context&, std::error_code&) override
         {
             if (!stack_.empty() && stack_.back().count() > 0)
             {
                 sink_.push_back(',');
             }
 
             sink_.push_back('\"');
             jsoncons::detail::escape_string(name.data(), name.length(),options_.escape_all_non_ascii(),options_.escape_solidus(),sink_);
             sink_.push_back('\"');
             sink_.push_back(':');
             return true;
         }
 
         bool visit_null(semantic_tag, const ser_context&, std::error_code&) override
         {
             if (!stack_.empty() && stack_.back().is_array() && stack_.back().count() > 0)
             {
                 sink_.push_back(',');
             }
 
             sink_.append(null_k().data(), null_k().size());
 
             if (!stack_.empty())
             {
                 stack_.back().increment_count();
             }
             return true;
         }
 
         void write_bigint_value(const string_view_type& sv)
         {
             switch (options_.bigint_format())
             {
                 case bigint_chars_format::number:
                 {
                     sink_.append(sv.data(),sv.size());
                     break;
                 }
                 case bigint_chars_format::base64:
                 {
                     bigint n = bigint::from_string(sv.data(), sv.length());
                     bool is_neg = n < 0;
                     if (is_neg)
                     {
                         n = - n -1;
                     }
                     int signum;
                     std::vector<uint8_t> v;
                     n.write_bytes_be(signum, v);
 
                     sink_.push_back('\"');
                     if (is_neg)
                     {
                         sink_.push_back('~');
                     }
                     encode_base64(v.begin(), v.end(), sink_);
                     sink_.push_back('\"');
                     break;
                 }
                 case bigint_chars_format::base64url:
                 {
                     bigint n = bigint::from_string(sv.data(), sv.length());
                     bool is_neg = n < 0;
                     if (is_neg)
                     {
                         n = - n -1;
                     }
                     int signum;
                     std::vector<uint8_t> v;
                     n.write_bytes_be(signum, v);
 
                     sink_.push_back('\"');
                     if (is_neg)
                     {
                         sink_.push_back('~');
                     }
                     encode_base64url(v.begin(), v.end(), sink_);
                     sink_.push_back('\"');
                     break;
                 }
                 default:
                 {
                     sink_.push_back('\"');
                     sink_.append(sv.data(),sv.size());
                     sink_.push_back('\"');
                     break;
                 }
             }
         }
 
         bool visit_string(const string_view_type& sv, semantic_tag tag, const ser_context&, std::error_code&) override
         {
             if (!stack_.empty() && stack_.back().is_array() && stack_.back().count() > 0)
             {
                 sink_.push_back(',');
             }
 
             switch (tag)
             {
                 case semantic_tag::bigint:
                     write_bigint_value(sv);
                     break;
                 default:
                 {
                     sink_.push_back('\"');
                     jsoncons::detail::escape_string(sv.data(), sv.length(),options_.escape_all_non_ascii(),options_.escape_solidus(),sink_);
                     sink_.push_back('\"');
                     break;
                 }
             }
 
             if (!stack_.empty())
             {
                 stack_.back().increment_count();
             }
             return true;
         }
 
         bool visit_byte_string(const byte_string_view& b, 
                                   semantic_tag tag,
                                   const ser_context&,
                                   std::error_code&) override
         {
             if (!stack_.empty() && stack_.back().is_array() && stack_.back().count() > 0)
             {
                 sink_.push_back(',');
             }
 
             byte_string_chars_format encoding_hint;
             switch (tag)
             {
                 case semantic_tag::base16:
                     encoding_hint = byte_string_chars_format::base16;
                     break;
                 case semantic_tag::base64:
                     encoding_hint = byte_string_chars_format::base64;
                     break;
                 case semantic_tag::base64url:
                     encoding_hint = byte_string_chars_format::base64url;
                     break;
                 default:
                     encoding_hint = byte_string_chars_format::none;
                     break;
             }
 
             byte_string_chars_format format = jsoncons::detail::resolve_byte_string_chars_format(options_.byte_string_format(), 
                                                                                        encoding_hint, 
                                                                                        byte_string_chars_format::base64url);
             switch (format)
             {
                 case byte_string_chars_format::base16:
                 {
                     sink_.push_back('\"');
                     encode_base16(b.begin(),b.end(),sink_);
                     sink_.push_back('\"');
                     break;
                 }
                 case byte_string_chars_format::base64:
                 {
                     sink_.push_back('\"');
                     encode_base64(b.begin(), b.end(), sink_);
                     sink_.push_back('\"');
                     break;
                 }
                 case byte_string_chars_format::base64url:
                 {
                     sink_.push_back('\"');
                     encode_base64url(b.begin(),b.end(),sink_);
                     sink_.push_back('\"');
                     break;
                 }
                 default:
                 {
                     JSONCONS_UNREACHABLE();
                 }
             }
 
             if (!stack_.empty())
             {
                 stack_.back().increment_count();
             }
             return true;
         }
 
         bool visit_double(double value, 
                              semantic_tag,
                              const ser_context& context,
                              std::error_code& ec) override
         {
             if (!stack_.empty() && stack_.back().is_array() && stack_.back().count() > 0)
             {
                 sink_.push_back(',');
             }
 
             if (JSONCONS_UNLIKELY(!std::isfinite(value)))
             {
                 if ((std::isnan)(value))
                 {
                     if (options_.enable_nan_to_num())
                     {
                         sink_.append(options_.nan_to_num().data(), options_.nan_to_num().length());
                     }
                     else if (options_.enable_nan_to_str())
                     {
                         visit_string(options_.nan_to_str(), semantic_tag::none, context, ec);
                     }
                     else
                     {
                         sink_.append(null_k().data(), null_k().size());
                     }
                 }
                 else if (value == std::numeric_limits<double>::infinity())
                 {
                     if (options_.enable_inf_to_num())
                     {
                         sink_.append(options_.inf_to_num().data(), options_.inf_to_num().length());
                     }
                     else if (options_.enable_inf_to_str())
                     {
                         visit_string(options_.inf_to_str(), semantic_tag::none, context, ec);
                     }
                     else
                     {
                         sink_.append(null_k().data(), null_k().size());
                     }
                 }
                 else 
                 {
                     if (options_.enable_neginf_to_num())
                     {
                         sink_.append(options_.neginf_to_num().data(), options_.neginf_to_num().length());
                     }
                     else if (options_.enable_neginf_to_str())
                     {
                         visit_string(options_.neginf_to_str(), semantic_tag::none, context, ec);
                     }
                     else
                     {
                         sink_.append(null_k().data(), null_k().size());
                     }
                 }
             }
             else
             {
                 fp_(value, sink_);
             }
 
             if (!stack_.empty())
             {
                 stack_.back().increment_count();
             }
             return true;
         }
 
         bool visit_int64(int64_t value, 
                             semantic_tag,
                             const ser_context&,
                             std::error_code&) override
         {
             if (!stack_.empty() && stack_.back().is_array() && stack_.back().count() > 0)
             {
                 sink_.push_back(',');
             }
             jsoncons::detail::from_integer(value, sink_);
             if (!stack_.empty())
             {
                 stack_.back().increment_count();
             }
             return true;
         }
 
         bool visit_uint64(uint64_t value, 
                              semantic_tag, 
                              const ser_context&,
                              std::error_code&) override
         {
             if (!stack_.empty() && stack_.back().is_array() && stack_.back().count() > 0)
             {
                 sink_.push_back(',');
             }
             jsoncons::detail::from_integer(value, sink_);
             if (!stack_.empty())
             {
                 stack_.back().increment_count();
             }
             return true;
         }
 
         bool visit_bool(bool value, semantic_tag, const ser_context&, std::error_code&) override
         {
             if (!stack_.empty() && stack_.back().is_array() && stack_.back().count() > 0)
             {
                 sink_.push_back(',');
             }
 
             if (value)
             {
                 sink_.append(true_k().data(), true_k().size());
             }
             else
             {
                 sink_.append(false_k().data(), false_k().size());
             }
 
             if (!stack_.empty())
             {
                 stack_.back().increment_count();
             }
             return true;
         }
     };
 
     using json_stream_encoder = basic_json_encoder<char,jsoncons::stream_sink<char>>;
     using wjson_stream_encoder = basic_json_encoder<wchar_t,jsoncons::stream_sink<wchar_t>>;
     using compact_json_stream_encoder = basic_compact_json_encoder<char,jsoncons::stream_sink<char>>;
     using compact_wjson_stream_encoder = basic_compact_json_encoder<wchar_t,jsoncons::stream_sink<wchar_t>>;
 
     using json_string_encoder = basic_json_encoder<char,jsoncons::string_sink<std::string>>;
     using wjson_string_encoder = basic_json_encoder<wchar_t,jsoncons::string_sink<std::wstring>>;
     using compact_json_string_encoder = basic_compact_json_encoder<char,jsoncons::string_sink<std::string>>;
     using compact_wjson_string_encoder = basic_compact_json_encoder<wchar_t,jsoncons::string_sink<std::wstring>>;
 
     #if !defined(JSONCONS_NO_DEPRECATED)
     template<class CharT,class Sink=jsoncons::stream_sink<CharT>>
     using basic_json_serializer = basic_json_encoder<CharT,Sink>; 
 
     template<class CharT,class Sink=jsoncons::stream_sink<CharT>>
     using basic_json_compressed_serializer = basic_compact_json_encoder<CharT,Sink>; 
 
     template<class CharT,class Sink=jsoncons::stream_sink<CharT>>
     using basic_json_compressed_encoder = basic_compact_json_encoder<CharT,Sink>; 
 
     JSONCONS_DEPRECATED_MSG("Instead, use compact_json_stream_encoder") typedef basic_compact_json_encoder<char,jsoncons::stream_sink<char>> json_compressed_stream_encoder;
     JSONCONS_DEPRECATED_MSG("Instead, use compact_wjson_stream_encoder")typedef basic_compact_json_encoder<wchar_t,jsoncons::stream_sink<wchar_t>> wjson_compressed_stream_encoder;
     JSONCONS_DEPRECATED_MSG("Instead, use compact_json_string_encoder") typedef basic_compact_json_encoder<char,jsoncons::string_sink<char>> json_compressed_string_encoder;
     JSONCONS_DEPRECATED_MSG("Instead, use compact_wjson_string_encoder")typedef basic_compact_json_encoder<wchar_t,jsoncons::string_sink<wchar_t>> wjson_compressed_string_encoder;
 
     JSONCONS_DEPRECATED_MSG("Instead, use json_stream_encoder") typedef json_stream_encoder json_encoder;
     JSONCONS_DEPRECATED_MSG("Instead, use wjson_stream_encoder") typedef wjson_stream_encoder wjson_encoder;
     JSONCONS_DEPRECATED_MSG("Instead, use compact_json_stream_encoder") typedef compact_json_stream_encoder compact_json_encoder;
     JSONCONS_DEPRECATED_MSG("Instead, use compact_wjson_stream_encoder") typedef compact_wjson_stream_encoder wcompact_json_encoder;
 
     JSONCONS_DEPRECATED_MSG("Instead, use json_stream_encoder") typedef basic_json_encoder<char,jsoncons::stream_sink<char>> json_serializer;
     JSONCONS_DEPRECATED_MSG("Instead, use wjson_stream_encoder") typedef basic_json_encoder<wchar_t,jsoncons::stream_sink<wchar_t>> wjson_serializer;
 
     JSONCONS_DEPRECATED_MSG("Instead, use compact_json_stream_encoder")  typedef basic_compact_json_encoder<char,jsoncons::stream_sink<char>> json_compressed_serializer;
     JSONCONS_DEPRECATED_MSG("Instead, use compact_wjson_stream_encoder") typedef basic_compact_json_encoder<wchar_t,jsoncons::stream_sink<wchar_t>> wjson_compressed_serializer;
 
     JSONCONS_DEPRECATED_MSG("Instead, use json_string_encoder")  typedef basic_json_encoder<char,jsoncons::string_sink<std::string>> json_string_serializer;
     JSONCONS_DEPRECATED_MSG("Instead, use wjson_string_encoder") typedef basic_json_encoder<wchar_t,jsoncons::string_sink<std::wstring>> wjson_string_serializer;
 
     JSONCONS_DEPRECATED_MSG("Instead, use compact_json_string_encoder")  typedef basic_compact_json_encoder<char,jsoncons::string_sink<std::string>> json_compressed_string_serializer;
     JSONCONS_DEPRECATED_MSG("Instead, use wcompact_json_string_encoder") typedef basic_compact_json_encoder<wchar_t,jsoncons::string_sink<std::wstring>> wjson_compressed_string_serializer;
     #endif
 
 } // namespace jsoncons
 
 #endif
diff --git a/include/jsoncons/unicode_traits.hpp b/include/jsoncons/unicode_traits.hpp
index 1ea541339..481a91e55 100644
--- a/include/jsoncons/unicode_traits.hpp
+++ b/include/jsoncons/unicode_traits.hpp
@@ -304,1505 +304,1291 @@ namespace std {
 namespace jsoncons { namespace unicode_traits {
 
     // encoding_errc
 
     enum class encoding_errc
     {
         success = 0,
         expected_u8_found_u16 = 1,
         expected_u8_found_u32,
         expected_u16_found_fffe,
         expected_u32_found_fffe
     };
 
     class Encoding_errc_impl_
        : public std::error_category
     {
     public:
         virtual const char* name() const noexcept
         {
             return "unicode_traits encoding error";
         }
         virtual std::string message(int ev) const
         {
             switch (static_cast<encoding_errc>(ev))
             {
             case encoding_errc::expected_u8_found_u16:
                 return "Expected UTF-8, found UTF-16";
             case encoding_errc::expected_u8_found_u32:
                 return "Expected UTF-8, found UTF-32";
             case encoding_errc::expected_u16_found_fffe:
                 return "Expected UTF-16, found non character";
             case encoding_errc::expected_u32_found_fffe:
                 return "Expected UTF-32, found non character";
             default:
                 return "";
                 break;
             }
         }
     };
 
     inline
     const std::error_category& encoding_error_category()
     {
         static Encoding_errc_impl_ instance;
         return instance;
     }
 
     inline 
     std::error_code make_error_code(encoding_errc result)
     {
         return std::error_code(static_cast<int>(result),encoding_error_category());
     }
 
     // utf8
 
     template <class CharT>
     typename std::enable_if<is_char8<CharT>::value, conv_errc>::type
     is_legal_utf8(const CharT* first, std::size_t length) 
     {
         uint8_t a;
         const CharT* srcptr = first+length;
         switch (length) {
         default:
             return conv_errc::over_long_utf8_sequence;
         case 4:
             if (((a = (*--srcptr))& 0xC0) != 0x80)
                 return conv_errc::expected_continuation_byte;
             JSONCONS_FALLTHROUGH;
         case 3:
             if (((a = (*--srcptr))& 0xC0) != 0x80)
                 return conv_errc::expected_continuation_byte;
             JSONCONS_FALLTHROUGH;
         case 2:
             if (((a = (*--srcptr))& 0xC0) != 0x80)
                 return conv_errc::expected_continuation_byte;
 
             switch (static_cast<uint8_t>(*first)) 
             {
                 // no fall-through in this inner switch
                 case 0xE0: if (a < 0xA0) return conv_errc::source_illegal; break;
                 case 0xED: if (a > 0x9F) return conv_errc::source_illegal; break;
                 case 0xF0: if (a < 0x90) return conv_errc::source_illegal; break;
                 case 0xF4: if (a > 0x8F) return conv_errc::source_illegal; break;
                 default:   if (a < 0x80) return conv_errc::source_illegal;
             }
 
             JSONCONS_FALLTHROUGH;
         case 1:
             if (static_cast<uint8_t>(*first) >= 0x80 && static_cast<uint8_t>(*first) < 0xC2)
                 return conv_errc::source_illegal;
             break;
         }
         if (static_cast<uint8_t>(*first) > 0xF4) 
             return conv_errc::source_illegal;
 
         return conv_errc();
     }
 
     template <class...> using void_t = void;
 
     template <class, class, class = void>
     struct is_output_iterator : std::false_type {};
 
     template <class I, class E>
     struct is_output_iterator<I, E, void_t<
         typename std::iterator_traits<I>::iterator_category,
         decltype(*std::declval<I>() = std::declval<E>())>> : std::true_type {};
 
     // is_same_size fixes issue with vs2013
 
     // primary template
     template<class T1, class T2, class Enable = void>
     struct is_same_size : std::false_type 
     {
     };
      
     // specialization for non void types
     template<class T1, class T2>
     struct is_same_size<T1, T2, typename std::enable_if<!std::is_void<T1>::value && !std::is_void<T2>::value>::type>
     {
         static constexpr bool value = (sizeof(T1) == sizeof(T2));
     }; 
 
     // convert
 
     template <class CharT>
     struct convert_result
     {
         const CharT* ptr;
         conv_errc ec;
     };
 
     // to_codepoint
 
     template <class CharT,class CodepointT>
     typename std::enable_if<is_char8<CharT>::value && is_char32<CodepointT>::value,
                             convert_result<CharT>>::type 
     to_codepoint(const CharT* first, const CharT* last, 
                  CodepointT& ch, 
                  conv_flags flags = conv_flags::strict) 
     {
         ch = 0;
         if (first >= last)
         {
             return convert_result<CharT>{first, conv_errc::source_exhausted};
         }
         conv_errc  result = conv_errc();
 
         unsigned short extra_bytes_to_read = trailing_bytes_for_utf8[static_cast<uint8_t>(*first)];
         if (extra_bytes_to_read >= last - first) 
         {
             result = conv_errc::source_exhausted; 
             return convert_result<CharT>{first, result};
         }
         // Do this check whether lenient or strict 
         if ((result=is_legal_utf8(first, extra_bytes_to_read+1)) != conv_errc()) 
         {
             return convert_result<CharT>{first, result};
         }
         // The cases all fall through. See "Note A" below.
         switch (extra_bytes_to_read) 
         {
             case 5: 
                 ch += static_cast<uint8_t>(*first++); 
                 ch <<= 6;
                 JSONCONS_FALLTHROUGH;
             case 4: 
                 ch += static_cast<uint8_t>(*first++); 
                 ch <<= 6;
                 JSONCONS_FALLTHROUGH;
             case 3: 
                 ch += static_cast<uint8_t>(*first++); 
                 ch <<= 6;
                 JSONCONS_FALLTHROUGH;
             case 2: 
                 ch += static_cast<uint8_t>(*first++); 
                 ch <<= 6;
                 JSONCONS_FALLTHROUGH;
             case 1: 
                 ch += static_cast<uint8_t>(*first++); 
                 ch <<= 6;
                 JSONCONS_FALLTHROUGH;
             case 0: 
                 ch += static_cast<uint8_t>(*first++);
                 break;
         }
         ch -= offsets_from_utf8[extra_bytes_to_read];
 
         if (ch <= max_legal_utf32) {
             /*
              * UTF-16 surrogate values are illegal in UTF-32, and anything
              * over Plane 17 (> 0x10FFFF) is illegal.
              */
             if (is_surrogate(ch) ) 
             {
                 if (flags == conv_flags::strict) 
                 {
                     first -= (extra_bytes_to_read+1); // return to the illegal value itself
                     result = conv_errc::source_illegal;
                     return convert_result<CharT>{first, result};
                 } 
                 else
                 {
                     ch = replacement_char;
                 }
             }
         } 
         else // i.e., ch > max_legal_utf32
         { 
             result = conv_errc::source_illegal;
             ch = replacement_char;
         }
 
         return convert_result<CharT>{first,result} ;
     }
 
     template <class CharT,class CodepointT>
     typename std::enable_if<is_char16<CharT>::value && is_char32<CodepointT>::value,
                             convert_result<CharT>>::type 
     to_codepoint(const CharT* first, const CharT* last, 
                  CodepointT& ch, 
                  conv_flags flags = conv_flags::strict) 
     {
         ch = 0;
         if (first >= last)
         {
             return convert_result<CharT>{first, conv_errc::source_exhausted};
         }
         conv_errc  result = conv_errc();
 
         ch = *first++;
         // If we have a surrogate pair, convert to UTF32 first. 
         if (is_high_surrogate(ch)) 
         {
             // If the 16 bits following the high surrogate are in the first buffer... 
             if (first < last) 
             {
                 uint32_t ch2 = *first;
                 // If ptr's a low surrogate, convert to UTF32. 
                 if (ch2 >= sur_low_start && ch2 <= sur_low_end ) 
                 {
                     ch = ((ch - sur_high_start) << half_shift)
                         + (ch2 - sur_low_start) + half_base;
                     ++first;
                 } 
                 else if (flags == conv_flags::strict) // ptr's an unpaired high surrogate 
                 { 
                     --first; /* return to the illegal value itself */
                     result = conv_errc::source_illegal;
                     return convert_result<CharT>{first, result};
                 }
             } 
             else 
             { /* We don't have the 16 bits following the high surrogate. */
                 --first; /* return to the high surrogate */
                 result = conv_errc::source_exhausted;
                 return convert_result<CharT>{first, result};
             }
         } else if (flags == conv_flags::strict) {
             /* UTF-16 surrogate values are illegal in UTF-32 */
             if (is_low_surrogate(ch) ) 
             {
                 --first; /* return to the illegal value itself */
                 result = conv_errc::source_illegal;
                 return convert_result<CharT>{first, result};
             }
         }
         
         return convert_result<CharT>{first,result} ;
     }
 
     template <class CharT,class CodepointT>
     typename std::enable_if<is_char32<CharT>::value && is_char32<CodepointT>::value,
                             convert_result<CharT>>::type 
     to_codepoint(const CharT* first, const CharT* last, 
                  CodepointT& ch, 
                  conv_flags flags = conv_flags::strict) 
     {
         ch = 0;
         if (first >= last)
         {
             return convert_result<CharT>{first, conv_errc::source_exhausted};
         }
         conv_errc  result = conv_errc();
 
         ch = *first++;
         if (flags == conv_flags::strict ) 
         {
             /* UTF-16 surrogate values are illegal in UTF-32 */
             if (is_surrogate(ch)) 
             {
                 --first; /* return to the illegal value itself */
                 result = conv_errc::illegal_surrogate_value;
                 return convert_result<CharT>{first,result} ;
             }
         }
         if (!(ch <= max_legal_utf32))
         {
             ch = replacement_char;
             result = conv_errc::source_illegal;
         }
 
         return convert_result<CharT>{first,result} ;
     }
 
     // convert
 
     template <class CharT,class Container>
     typename std::enable_if<is_char8<CharT>::value
                             && jsoncons::detail::is_back_insertable<Container>::value
                             && is_char8<typename Container::value_type>::value,
                             convert_result<CharT>>::type 
     convert(const CharT* data, std::size_t length, Container& target, conv_flags flags=conv_flags::strict) 
     {
         (void)flags;
 
         conv_errc  result = conv_errc();
         const CharT* last = data + length;
         while (data != last) 
         {
             std::size_t len = trailing_bytes_for_utf8[static_cast<uint8_t>(*data)] + 1;
             if (len > (std::size_t)(last - data))
             {
                 return convert_result<CharT>{data, conv_errc::source_exhausted};
             }
             if ((result=is_legal_utf8(data, len)) != conv_errc())
             {
                 return convert_result<CharT>{data,result};
             }
 
             switch (len) {
                 case 4: target.push_back(static_cast<uint8_t>(*data++));
                     JSONCONS_FALLTHROUGH;
                 case 3: target.push_back(static_cast<uint8_t>(*data++));
                     JSONCONS_FALLTHROUGH;
                 case 2: target.push_back(static_cast<uint8_t>(*data++));
                     JSONCONS_FALLTHROUGH;
                 case 1: target.push_back(static_cast<uint8_t>(*data++));
             }
         }
         return convert_result<CharT>{data,result} ;
     }
 
     template <class CharT,class Container>
     typename std::enable_if<is_char8<CharT>::value
                             && jsoncons::detail::is_back_insertable<Container>::value
                             && is_char16<typename Container::value_type>::value,
                             convert_result<CharT>>::type 
     convert(const CharT* data, std::size_t length, 
             Container& target, 
             conv_flags flags = conv_flags::strict) 
     {
         conv_errc  result = conv_errc();
 
         const CharT* last = data + length;
         while (data != last) 
         {
             unsigned short extra_bytes_to_read = trailing_bytes_for_utf8[static_cast<uint8_t>(*data)];
             if (extra_bytes_to_read >= last - data) 
             {
                 result = conv_errc::source_exhausted; 
                 break;
             }
             /* Do this check whether lenient or strict */
             if ((result=is_legal_utf8(data, extra_bytes_to_read+1)) != conv_errc())
             {
                 break;
             }
             /*
              * The cases all fall through. See "Note A" below.
              */
             uint32_t ch = 0;
             switch (extra_bytes_to_read) {
                 case 5: ch += static_cast<uint8_t>(*data++); ch <<= 6; /* remember, illegal UTF-8 */
                     JSONCONS_FALLTHROUGH;
                 case 4: ch += static_cast<uint8_t>(*data++); ch <<= 6; /* remember, illegal UTF-8 */
                     JSONCONS_FALLTHROUGH;
                 case 3: ch += static_cast<uint8_t>(*data++); ch <<= 6;
                     JSONCONS_FALLTHROUGH;
                 case 2: ch += static_cast<uint8_t>(*data++); ch <<= 6;
                     JSONCONS_FALLTHROUGH;
                 case 1: ch += static_cast<uint8_t>(*data++); ch <<= 6;
                     JSONCONS_FALLTHROUGH;
                 case 0: ch += static_cast<uint8_t>(*data++);
                     break;
             }
             ch -= offsets_from_utf8[extra_bytes_to_read];
 
             if (ch <= max_bmp) { /* Target is a character <= 0xFFFF */
                 /* UTF-16 surrogate values are illegal in UTF-32 */
                 if (is_surrogate(ch) ) 
                 {
                     if (flags == conv_flags::strict) {
                         data -= (extra_bytes_to_read+1); /* return to the illegal value itself */
                         result = conv_errc::source_illegal;
                         break;
                     } else {
                         target.push_back(replacement_char);
                     }
                 } else {
                     target.push_back((uint16_t)ch); /* normal case */
                 }
             } else if (ch > max_utf16) {
                 if (flags == conv_flags::strict) {
                     result = conv_errc::source_illegal;
                     data -= (extra_bytes_to_read+1); /* return to the start */
                     break; /* Bail out; shouldn't continue */
                 } else {
                     target.push_back(replacement_char);
                 }
             } else {
                 /* target is a character in range 0xFFFF - 0x10FFFF. */
                 ch -= half_base;
                 target.push_back((uint16_t)((ch >> half_shift) + sur_high_start));
                 target.push_back((uint16_t)((ch & half_mask) + sur_low_start));
             }
         }
         return convert_result<CharT>{data,result} ;
     }
 
     template <class CharT,class Container>
     typename std::enable_if<is_char8<CharT>::value                            
                             && jsoncons::detail::is_back_insertable<Container>::value
                             && is_char32<typename Container::value_type>::value,
                             convert_result<CharT>>::type 
     convert(const CharT* data, std::size_t length, 
             Container& target, 
             conv_flags flags = conv_flags::strict) 
     {
         conv_errc  result = conv_errc();
 
         const CharT* last = data + length;
         while (data < last) 
         {
             uint32_t ch = 0;
             unsigned short extra_bytes_to_read = trailing_bytes_for_utf8[static_cast<uint8_t>(*data)];
             if (extra_bytes_to_read >= last - data) 
             {
                 result = conv_errc::source_exhausted; 
                 break;
             }
             /* Do this check whether lenient or strict */
             if ((result=is_legal_utf8(data, extra_bytes_to_read+1)) != conv_errc()) 
             {
                 break;
             }
             /*
              * The cases all fall through. See "Note A" below.
              */
             switch (extra_bytes_to_read) 
             {
                 case 5: 
                     ch += static_cast<uint8_t>(*data++); 
                     ch <<= 6;
                     JSONCONS_FALLTHROUGH;
                 case 4: 
                     ch += static_cast<uint8_t>(*data++); 
                     ch <<= 6;
                     JSONCONS_FALLTHROUGH;
                 case 3: 
                     ch += static_cast<uint8_t>(*data++); 
                     ch <<= 6;
                     JSONCONS_FALLTHROUGH;
                 case 2: 
                     ch += static_cast<uint8_t>(*data++); 
                     ch <<= 6;
                     JSONCONS_FALLTHROUGH;
                 case 1: 
                     ch += static_cast<uint8_t>(*data++); 
                     ch <<= 6;
                     JSONCONS_FALLTHROUGH;
                 case 0: 
                     ch += static_cast<uint8_t>(*data++);
                     break;
             }
             ch -= offsets_from_utf8[extra_bytes_to_read];
 
             if (ch <= max_legal_utf32) {
                 /*
                  * UTF-16 surrogate values are illegal in UTF-32, and anything
                  * over Plane 17 (> 0x10FFFF) is illegal.
                  */
                 if (is_surrogate(ch) ) 
                 {
                     if (flags == conv_flags::strict) {
                         data -= (extra_bytes_to_read+1); /* return to the illegal value itself */
                         result = conv_errc::source_illegal;
                         break;
                     } else {
                         target.push_back(replacement_char);
                     }
                 } else {
                     target.push_back(ch);
                 }
             } else { /* i.e., ch > max_legal_utf32 */
                 result = conv_errc::source_illegal;
                 target.push_back(replacement_char);
             }
         }
         return convert_result<CharT>{data,result} ;
     }
 
     // utf16
 
     template <class CharT,class Container>
     typename std::enable_if<is_char16<CharT>::value                            
                             && jsoncons::detail::is_back_insertable<Container>::value
                             && is_char8<typename Container::value_type>::value,
                             convert_result<CharT>>::type 
     convert(const CharT* data, std::size_t length, 
                      Container& target, 
                      conv_flags flags = conv_flags::strict) {
         conv_errc  result = conv_errc();
 
         const CharT* last = data + length;
         while (data < last) {
             unsigned short bytes_to_write = 0;
             const uint32_t byteMask = 0xBF;
             const uint32_t byteMark = 0x80; 
             uint32_t ch = *data++;
             /* If we have a surrogate pair, convert to uint32_t data. */
             if (is_high_surrogate(ch)) 
             {
                 /* If the 16 bits following the high surrogate are in the data buffer... */
                 if (data < last) {
                     uint32_t ch2 = *data;
                     /* If ptr's a low surrogate, convert to uint32_t. */
                     if (ch2 >= sur_low_start && ch2 <= sur_low_end) {
                         ch = ((ch - sur_high_start) << half_shift)
                             + (ch2 - sur_low_start) + half_base;
                         ++data;
                     } else if (flags == conv_flags::strict) { /* ptr's an unpaired high surrogate */
                         --data; /* return to the illegal value itself */
                         result = conv_errc::unpaired_high_surrogate;
                         break;
                     }
                 } else { /* We don't have the 16 bits following the high surrogate. */
                     --data; /* return to the high surrogate */
                     result = conv_errc::source_exhausted;
                     break;
                 }
             } else if (flags == conv_flags::strict) {
                 /* UTF-16 surrogate values are illegal in UTF-32 */
                 if (is_low_surrogate(ch)) 
                 {
                     --data; /* return to the illegal value itself */
                     result = conv_errc::source_illegal;
                     break;
                 }
             }
             /* Figure out how many bytes the result will require */
             if (ch < (uint32_t)0x80) {      
                 bytes_to_write = 1;
             } else if (ch < (uint32_t)0x800) {     
                 bytes_to_write = 2;
             } else if (ch < (uint32_t)0x10000) {   
                 bytes_to_write = 3;
             } else if (ch < (uint32_t)0x110000) {  
                 bytes_to_write = 4;
             } else {                            
                 bytes_to_write = 3;
                 ch = replacement_char;
             }
             
             uint8_t byte1 = 0;
             uint8_t byte2 = 0;
             uint8_t byte3 = 0;
             uint8_t byte4 = 0;
 
             switch (bytes_to_write) { // note: everything falls through
                 case 4: byte4 = (uint8_t)((ch | byteMark) & byteMask); ch >>= 6;
                     JSONCONS_FALLTHROUGH;
                 case 3: byte3 = (uint8_t)((ch | byteMark) & byteMask); ch >>= 6;
                     JSONCONS_FALLTHROUGH;
                 case 2: byte2 = (uint8_t)((ch | byteMark) & byteMask); ch >>= 6;
                     JSONCONS_FALLTHROUGH;
                 case 1: byte1 = (uint8_t)(ch | first_byte_mark[bytes_to_write]);
                     break;
             }
             switch (bytes_to_write) 
             {
             case 4: 
                 target.push_back(byte1);
                 target.push_back(byte2);
                 target.push_back(byte3);
                 target.push_back(byte4);
                 break;
             case 3: 
                 target.push_back(byte1);
                 target.push_back(byte2);
                 target.push_back(byte3);
                 break;
             case 2: 
                 target.push_back(byte1);
                 target.push_back(byte2);
                 break;
             case 1: 
                 target.push_back(byte1);
                 break;
             }
         }
         return convert_result<CharT>{data,result} ;
     }
 
     template <class CharT,class Container>
     typename std::enable_if<is_char16<CharT>::value                            
                             && jsoncons::detail::is_back_insertable<Container>::value
                             && is_char16<typename Container::value_type>::value,
                             convert_result<CharT>>::type 
     convert(const CharT* data, std::size_t length, 
             Container& target, 
             conv_flags flags = conv_flags::strict) 
     {
         conv_errc  result = conv_errc();
 
         const CharT* last = data + length;
         while (data != last) 
         {
             uint32_t ch = *data++;
             /* If we have a surrogate pair, convert to uint32_t data. */
             if (is_high_surrogate(ch)) 
             {
                 /* If the 16 bits following the high surrogate are in the data buffer... */
                 if (data < last) {
                     uint32_t ch2 = *data;
                     /* If ptr's a low surrogate, */
                     if (ch2 >= sur_low_start && ch2 <= sur_low_end) {
                         target.push_back((uint16_t)ch);
                         target.push_back((uint16_t)ch2);
                         ++data;
                     } else if (flags == conv_flags::strict) { /* ptr's an unpaired high surrogate */
                         --data; /* return to the illegal value itself */
                         result = conv_errc::unpaired_high_surrogate;
                         break;
                     }
                 } else { /* We don't have the 16 bits following the high surrogate. */
                     --data; /* return to the high surrogate */
                     result = conv_errc::source_exhausted;
                     break;
                 }
             } else if (is_low_surrogate(ch)) 
             {
                 // illegal leading low surrogate
                 if (flags == conv_flags::strict) {
                     --data; /* return to the illegal value itself */
                     result = conv_errc::source_illegal;
                     break;
                 }
                 else
                 {
                     target.push_back((uint16_t)ch);
                 }
             }
             else
             {
                 target.push_back((uint16_t)ch);
             }
         }
         return convert_result<CharT>{data,result} ;
     }
 
     template <class CharT,class Container>
     typename std::enable_if<is_char16<CharT>::value                            
                             && jsoncons::detail::is_back_insertable<Container>::value
                             && is_char32<typename Container::value_type>::value,
                             convert_result<CharT>>::type 
     convert(const CharT* data, std::size_t length, 
             Container& target, 
             conv_flags flags = conv_flags::strict) 
     {
         conv_errc  result = conv_errc();
 
         const CharT* last = data + length;
         while (data != last) 
         {
             uint32_t ch = *data++;
             /* If we have a surrogate pair, convert to UTF32 data. */
             if (is_high_surrogate(ch)) 
             {
                 /* If the 16 bits following the high surrogate are in the data buffer... */
                 if (data < last) {
                     uint32_t ch2 = *data;
                     /* If ptr's a low surrogate, convert to UTF32. */
                     if (ch2 >= sur_low_start && ch2 <= sur_low_end ) 
                     {
                         ch = ((ch - sur_high_start) << half_shift)
                             + (ch2 - sur_low_start) + half_base;
                         ++data;
                     } else if (flags == conv_flags::strict) { /* ptr's an unpaired high surrogate */
                         --data; /* return to the illegal value itself */
                         result = conv_errc::source_illegal;
                         break;
                     }
                 } else { /* We don't have the 16 bits following the high surrogate. */
                     --data; /* return to the high surrogate */
                     result = conv_errc::source_exhausted;
                     break;
                 }
             } else if (flags == conv_flags::strict) {
                 /* UTF-16 surrogate values are illegal in UTF-32 */
                 if (is_low_surrogate(ch) ) 
                 {
                     --data; /* return to the illegal value itself */
                     result = conv_errc::source_illegal;
                     break;
                 }
             }
             target.push_back(ch);
         }
         return convert_result<CharT>{data,result} ;
     }
 
     // utf32
 
     template <class CharT,class Container>
     typename std::enable_if<is_char32<CharT>::value                            
                             && jsoncons::detail::is_back_insertable<Container>::value
                             && is_char8<typename Container::value_type>::value,
                             convert_result<CharT>>::type 
     convert(const CharT* data, std::size_t length, 
             Container& target, 
             conv_flags flags = conv_flags::strict) 
     {
         conv_errc  result = conv_errc();
         const CharT* last = data + length;
         while (data < last) 
         {
             unsigned short bytes_to_write = 0;
             const uint32_t byteMask = 0xBF;
             const uint32_t byteMark = 0x80; 
             uint32_t ch = *data++;
             if (flags == conv_flags::strict ) 
             {
                 /* UTF-16 surrogate values are illegal in UTF-32 */
                 if (is_surrogate(ch)) 
                 {
                     --data; /* return to the illegal value itself */
                     result = conv_errc::illegal_surrogate_value;
                     break;
                 }
             }
             /*
              * Figure out how many bytes the result will require. Turn any
              * illegally large UTF32 things (> Plane 17) into replacement chars.
              */
             if (ch < (uint32_t)0x80) {      bytes_to_write = 1;
             } else if (ch < (uint32_t)0x800) {     bytes_to_write = 2;
             } else if (ch < (uint32_t)0x10000) {   bytes_to_write = 3;
             } else if (ch <= max_legal_utf32) {  bytes_to_write = 4;
             } else {                            
                 bytes_to_write = 3;
                 ch = replacement_char;
                 result = conv_errc::source_illegal;
             }
 
             uint8_t byte1 = 0;
             uint8_t byte2 = 0;
             uint8_t byte3 = 0;
             uint8_t byte4 = 0;
 
             switch (bytes_to_write) {
             case 4:
                 byte4 = (uint8_t)((ch | byteMark) & byteMask); ch >>= 6;
                 JSONCONS_FALLTHROUGH;
             case 3:
                 byte3 = (uint8_t)((ch | byteMark) & byteMask); ch >>= 6;
                 JSONCONS_FALLTHROUGH;
             case 2:
                 byte2 = (uint8_t)((ch | byteMark) & byteMask); ch >>= 6;
                 JSONCONS_FALLTHROUGH;
             case 1:
                 byte1 = (uint8_t) (ch | first_byte_mark[bytes_to_write]);
                 break;
             }
 
             switch (bytes_to_write) 
             {
             case 4: 
                 target.push_back(byte1);
                 target.push_back(byte2);
                 target.push_back(byte3);
                 target.push_back(byte4);
                 break;
             case 3: 
                 target.push_back(byte1);
                 target.push_back(byte2);
                 target.push_back(byte3);
                 break;
             case 2: 
                 target.push_back(byte1);
                 target.push_back(byte2);
                 break;
             case 1: 
                 target.push_back(byte1);
                 break;
             }
         }
         return convert_result<CharT>{data,result} ;
     }
 
     template <class CharT,class Container>
     typename std::enable_if<is_char32<CharT>::value                            
                             && jsoncons::detail::is_back_insertable<Container>::value
                             && is_char16<typename Container::value_type>::value,
                             convert_result<CharT>>::type 
     convert(const CharT* data, std::size_t length, 
             Container& target, 
             conv_flags flags = conv_flags::strict) 
     {
         conv_errc  result = conv_errc();
 
         const CharT* last = data + length;
         while (data != last) 
         {
             uint32_t ch = *data++;
             if (ch <= max_bmp) { /* Target is a character <= 0xFFFF */
                 /* UTF-16 surrogate values are illegal in UTF-32; 0xffff or 0xfffe are both reserved values */
                 if (is_surrogate(ch) ) 
                 {
                     if (flags == conv_flags::strict) {
                         --data; /* return to the illegal value itself */
                         result = conv_errc::source_illegal;
                         break;
                     } else {
                         target.push_back(replacement_char);
                     }
                 } else {
                     target.push_back((uint16_t)ch); /* normal case */
                 }
             } else if (ch > max_legal_utf32) {
                 if (flags == conv_flags::strict) {
                     result = conv_errc::source_illegal;
                 } else {
                     target.push_back(replacement_char);
                 }
             } else {
                 /* target is a character in range 0xFFFF - 0x10FFFF. */
                 ch -= half_base;
                 target.push_back((uint16_t)((ch >> half_shift) + sur_high_start));
                 target.push_back((uint16_t)((ch & half_mask) + sur_low_start));
             }
         }
         return convert_result<CharT>{data,result} ;
     }
 
     template <class CharT,class Container>
     typename std::enable_if<is_char32<CharT>::value                            
                             && jsoncons::detail::is_back_insertable<Container>::value
                             && is_char32<typename Container::value_type>::value,
                             convert_result<CharT>>::type 
     convert(const CharT* data, std::size_t length, 
             Container& target, 
             conv_flags flags = conv_flags::strict) 
     {
         conv_errc  result = conv_errc();
 
         const CharT* last = data + length;
         while (data != last) 
         {
             uint32_t ch = *data++;
             if (flags == conv_flags::strict ) 
             {
                 /* UTF-16 surrogate values are illegal in UTF-32 */
                 if (is_surrogate(ch)) 
                 {
                     --data; /* return to the illegal value itself */
                     result = conv_errc::illegal_surrogate_value;
                     break;
                 }
             }
             if (ch <= max_legal_utf32)
             {
                 target.push_back(ch);
             }
             else
             {
                 target.push_back(replacement_char);
                 result = conv_errc::source_illegal;
             }
         }
         return convert_result<CharT>{data,result} ;
     }
 
     // validate
 
     template <class CharT>
     typename std::enable_if<is_char8<CharT>::value,
                             convert_result<CharT>>::type 
     validate(const CharT* data, std::size_t length) noexcept
     {
         conv_errc  result = conv_errc();
         const CharT* last = data + length;
         while (data != last) 
         {
             std::size_t len = static_cast<std::size_t>(trailing_bytes_for_utf8[static_cast<uint8_t>(*data)]) + 1;
             if (len > (std::size_t)(last - data))
             {
                 return convert_result<CharT>{data, conv_errc::source_exhausted};
             }
             if ((result=is_legal_utf8(data, len)) != conv_errc())
             {
                 return convert_result<CharT>{data,result} ;
             }
             data += len;
         }
         return convert_result<CharT>{data,result} ;
     }
 
     // utf16
 
     template <class CharT>
     typename std::enable_if<is_char16<CharT>::value,
                             convert_result<CharT>>::type 
     validate(const CharT* data, std::size_t length)  noexcept
     {
         conv_errc  result = conv_errc();
 
         const CharT* last = data + length;
         while (data != last) 
         {
             uint32_t ch = *data++;
             /* If we have a surrogate pair, validate to uint32_t data. */
             if (is_high_surrogate(ch)) 
             {
                 /* If the 16 bits following the high surrogate are in the data buffer... */
                 if (data < last) {
                     uint32_t ch2 = *data;
                     /* If ptr's a low surrogate, */
                     if (ch2 >= sur_low_start && ch2 <= sur_low_end) {
                         ++data;
                     } else {
                         --data; /* return to the illegal value itself */
                         result = conv_errc::unpaired_high_surrogate;
                         break;
                     }
                 } else { /* We don't have the 16 bits following the high surrogate. */
                     --data; /* return to the high surrogate */
                     result = conv_errc::source_exhausted;
                     break;
                 }
             } else if (is_low_surrogate(ch)) 
             {
                 /* UTF-16 surrogate values are illegal in UTF-32 */
                 --data; /* return to the illegal value itself */
                 result = conv_errc::source_illegal;
                 break;
             }
         }
         return convert_result<CharT>{data,result} ;
     }
 
     // utf32
 
     template <class CharT>
     typename std::enable_if<is_char32<CharT>::value,
                             convert_result<CharT>>::type 
     validate(const CharT* data, std::size_t length) noexcept
     {
         conv_errc  result = conv_errc();
 
         const CharT* last = data + length;
         while (data != last) 
         {
             uint32_t ch = *data++;
             /* UTF-16 surrogate values are illegal in UTF-32 */
             if (is_surrogate(ch)) 
             {
                 --data; /* return to the illegal value itself */
                 result = conv_errc::illegal_surrogate_value;
                 break;
             }
             if (!(ch <= max_legal_utf32))
             {
                 result = conv_errc::source_illegal;
             }
         }
         return convert_result<CharT>{data, result} ;
     }
 
     // count_codepoints
 
     enum class encoding {u8,u16le,u16be,u32le,u32be,undetected};
 
     template <class Iterator>
     struct determine_encoding_result
     {
         Iterator it;
         encoding ec;
     };
 
     template <class Iterator>
     typename std::enable_if<std::is_integral<typename std::iterator_traits<Iterator>::value_type>::value && sizeof(typename std::iterator_traits<Iterator>::value_type) == sizeof(uint8_t),
                             determine_encoding_result<Iterator>>::type 
     detect_encoding(Iterator first, Iterator last) noexcept
     {
         Iterator it1 = first;
         if (std::distance(first,last) < 4)
         {
             if (std::distance(first,last) == 3)
             {
                 Iterator it2 = ++first;
                 Iterator it3 = ++first;
                 if (static_cast<uint8_t>(*it1) == 0xEF && static_cast<uint8_t>(*it2) == 0xBB && static_cast<uint8_t>(*it3) == 0xBF)
                 {
                     return determine_encoding_result<Iterator>{last,encoding::u8};
                 }
             }
             return determine_encoding_result<Iterator>{it1,encoding::undetected};
         }
         else
         {
             Iterator it2 = ++first;
             Iterator it3 = ++first;
             Iterator it4 = ++first;
 
             uint32_t bom = static_cast<uint8_t>(*it1) | (static_cast<uint8_t>(*it2) << 8) | (static_cast<uint8_t>(*it3) << 16) | (static_cast<uint8_t>(*it4) << 24);
             if (bom == 0xFFFE0000)                  
             { 
                 return determine_encoding_result<Iterator>{it4++,encoding::u32be};
             }
             else if (bom == 0x0000FEFF) 
             {
                 return determine_encoding_result<Iterator>{first,encoding::u32le};
             }
             else if ((bom & 0xFFFF) == 0xFFFE)     
             {
                 return determine_encoding_result<Iterator>{it3,encoding::u16be};
             }
             else if ((bom & 0xFFFF) == 0xFEFF)      
             {
                 return determine_encoding_result<Iterator>{it3,encoding::u16le};
             }
             else if ((bom & 0xFFFFFF) == 0xBFBBEF)  
             {
                 return determine_encoding_result<Iterator>{it4,encoding::u8};
             }
             else
             {
                 uint32_t pattern = (static_cast<uint8_t>(*it1) ? 1 : 0) | (static_cast<uint8_t>(*it2) ? 2 : 0) | (static_cast<uint8_t>(*it3) ? 4 : 0) | (static_cast<uint8_t>(*it4) ? 8 : 0);
                 switch (pattern) {
                 case 0x08: 
                     return determine_encoding_result<Iterator>{it1,encoding::u32be};
                 case 0x0A: 
                     return determine_encoding_result<Iterator>{it1,encoding::u16be};
                 case 0x01: 
                     return determine_encoding_result<Iterator>{it1,encoding::u32le};
                 case 0x05: 
                     return determine_encoding_result<Iterator>{it1,encoding::u16le};
                 case 0x0F: 
                     return determine_encoding_result<Iterator>{it1,encoding::u8};
                 default:
                     return determine_encoding_result<Iterator>{it1,encoding::undetected};
                 }
             }
         }
     }
 
     template <class CharT>
     typename std::enable_if<is_char8<CharT>::value, std::size_t>::type 
     count_codepoints(const CharT* data, std::size_t length, 
                      conv_flags flags = conv_flags::strict) 
     {
         conv_errc  result = conv_errc();
 
         const CharT* ptr = data;
         const CharT* last = data + length;
         while (ptr < last) 
         {
             uint32_t ch = 0;
             unsigned short extra_bytes_to_read = trailing_bytes_for_utf8[static_cast<uint8_t>(*ptr)];
             if (extra_bytes_to_read >= last - ptr) 
             {
                 result = conv_errc::source_exhausted; 
                 break;
             }
             /* Do this check whether lenient or strict */
             if ((result=is_legal_utf8(ptr, extra_bytes_to_read+1)) != conv_errc()) 
             {
                 break;
             }
             /*
              * The cases all fall through. See "Note A" below.
              */
             switch (extra_bytes_to_read) 
             {
                 case 5: 
                     ch += static_cast<uint8_t>(*ptr++); 
                     ch <<= 6;
                     JSONCONS_FALLTHROUGH;
                 case 4: 
                     ch += static_cast<uint8_t>(*ptr++); 
                     ch <<= 6;
                     JSONCONS_FALLTHROUGH;
                 case 3: 
                     ch += static_cast<uint8_t>(*ptr++); 
                     ch <<= 6;
                     JSONCONS_FALLTHROUGH;
                 case 2: 
                     ch += static_cast<uint8_t>(*ptr++); 
                     ch <<= 6;
                     JSONCONS_FALLTHROUGH;
                 case 1: 
                     ch += static_cast<uint8_t>(*ptr++); 
                     ch <<= 6;
                     JSONCONS_FALLTHROUGH;
                 case 0: 
                     ch += static_cast<uint8_t>(*ptr++);
                     break;
             }
             ch -= offsets_from_utf8[extra_bytes_to_read];
 
             if (ch <= max_legal_utf32) {
                 /*
                  * UTF-16 surrogate values are illegal in UTF-32, and anything
                  * over Plane 17 (> 0x10FFFF) is illegal.
                  */
                 if (is_surrogate(ch)) 
                 {
                     if (flags == conv_flags::strict) {
                         ptr -= (extra_bytes_to_read+1); /* return to the illegal value itself */
                         result = conv_errc::source_illegal;
                         break;
                     } else {
                     }
                 } else {
                 }
             } else { /* i.e., ch > max_legal_utf32 */
                 result = conv_errc::source_illegal;
             }
         }
         return ptr - data;
     }
 
     template <class CharT>
     typename std::enable_if<is_char16<CharT>::value, std::size_t>::type 
     count_codepoints(const CharT* data, std::size_t length, 
                      conv_flags flags = conv_flags::strict) 
     {
         conv_errc  result = conv_errc();
 
         const CharT* ptr = data;
         const CharT* last = ptr + length;
         while (ptr != last) 
         {
             uint32_t ch = *ptr++;
             /* If we have a surrogate pair, convert to UTF32 ptr. */
             if (is_high_surrogate(ch)) 
             {
                 /* If the 16 bits following the high surrogate are in the ptr buffer... */
                 if (ptr < last) {
                     uint32_t ch2 = *ptr;
                     /* If ptr's a low surrogate, convert to UTF32. */
                     if (ch2 >= sur_low_start && ch2 <= sur_low_end ) 
                     {
                         ch = ((ch - sur_high_start) << half_shift)
                             + (ch2 - sur_low_start) + half_base;
                         ++ptr;
                     } else if (flags == conv_flags::strict) { /* ptr's an unpaired high surrogate */
                         --ptr; /* return to the illegal value itself */
                         result = conv_errc::source_illegal;
                         break;
                     }
                 } else { /* We don't have the 16 bits following the high surrogate. */
                     --ptr; /* return to the high surrogate */
                     result = conv_errc::source_exhausted;
                     break;
                 }
             } else if (flags == conv_flags::strict) {
                 /* UTF-16 surrogate values are illegal in UTF-32 */
                 if (is_low_surrogate(ch) ) 
                 {
                     --ptr; /* return to the illegal value itself */
                     result = conv_errc::source_illegal;
                     break;
                 }
             }
         }
         return ptr - data;
     }
 
     template <class CharT>
     typename std::enable_if<is_char32<CharT>::value, std::size_t>::type 
     count_codepoints(const CharT* data, std::size_t length, 
                      conv_flags flags = conv_flags::strict) 
     {
         conv_errc ec = conv_errc();
 
         const CharT* ptr = data;
         const CharT* last = data + length;
         while (ptr != last) 
         {
             uint32_t ch = *ptr++;
             if (flags == conv_flags::strict ) 
             {
                 // UTF-16 surrogate values are illegal in UTF-32 
                 if (is_surrogate(ch)) 
                 {
                     ec = conv_errc::illegal_surrogate_value;
                     break;
                 }
             }
             if (!(ch <= max_legal_utf32))
             {
                 ec = conv_errc::source_illegal;
             }
         }
         return ec == conv_errc() ? ptr - data : 0;
     }
 
     template <class Iterator>
     struct skip_bom_result
     {
         Iterator it;
         encoding_errc ec;
     };
 
     template <class Iterator>
     typename std::enable_if<std::is_integral<typename std::iterator_traits<Iterator>::value_type>::value && sizeof(typename std::iterator_traits<Iterator>::value_type) == sizeof(uint8_t),
                                    skip_bom_result<Iterator>>::type 
     skip_bom(Iterator first, Iterator last) noexcept
     {
         auto result = unicode_traits::detect_encoding(first,last);
         switch (result.ec)
         {
         case unicode_traits::encoding::u8:
             return skip_bom_result<Iterator>{result.it,encoding_errc()};
             break;
         case unicode_traits::encoding::u16le:
         case unicode_traits::encoding::u16be:
             return skip_bom_result<Iterator>{result.it,encoding_errc::expected_u8_found_u16};
             break;
         case unicode_traits::encoding::u32le:
         case unicode_traits::encoding::u32be:
             return skip_bom_result<Iterator>{result.it,encoding_errc::expected_u8_found_u32};
             break;
         default:
             return skip_bom_result<Iterator>{result.it,encoding_errc()};
             break;
         }
     }
 
     template <class Iterator>
     typename std::enable_if<std::is_integral<typename std::iterator_traits<Iterator>::value_type>::value && sizeof(typename std::iterator_traits<Iterator>::value_type) == sizeof(uint16_t),
                                    skip_bom_result<Iterator>>::type 
     skip_bom(Iterator first, Iterator last) noexcept
     {
         if (first == last)
         {
             return skip_bom_result<Iterator>{first,encoding_errc()};
         }
         uint16_t bom = static_cast<uint16_t>(*first);
         if (bom == 0xFEFF)                  
         {
             return skip_bom_result<Iterator>{++first,encoding_errc()};
         }
         else if (bom == 0xFFFE) 
         {
             return skip_bom_result<Iterator>{last,encoding_errc::expected_u16_found_fffe};
         }
         else
         {
             return skip_bom_result<Iterator>{first,encoding_errc()};
         }
     }
 
     template <class Iterator>
     typename std::enable_if<std::is_integral<typename std::iterator_traits<Iterator>::value_type>::value && sizeof(typename std::iterator_traits<Iterator>::value_type) == sizeof(uint32_t),
                             skip_bom_result<Iterator>>::type 
     skip_bom(Iterator first, Iterator last) noexcept
     {
         if (first == last)
         {
             return skip_bom_result<Iterator>{first,encoding_errc()};
         }
         uint32_t bom = static_cast<uint32_t>(*first);
         if (bom == 0xFEFF0000)                  
         {
             return skip_bom_result<Iterator>{++first,encoding_errc()};
         }
         else if (bom == 0xFFFE0000) 
         {
             return skip_bom_result<Iterator>{last,encoding_errc::expected_u32_found_fffe};
         }
         else
         {
             return skip_bom_result<Iterator>{first,encoding_errc()};
         }
     }
-// sequence 
-
-    template <class Iterator>
-    class sequence
-    {
-        Iterator first_;
-        std::size_t length_;
-    public:
-        sequence(Iterator first, std::size_t length)
-            : first_(first), length_(length)
-        {
-        }
-
-        Iterator begin() const
-        {
-            return first_;
-        }
-
-        std::size_t length() const
-        {
-            return length_;
-        }
-
-        template <class CharT = typename std::iterator_traits<Iterator>::value_type>
-        typename std::enable_if<sizeof(CharT) == sizeof(uint8_t),uint32_t>::type 
-        codepoint() const noexcept
-        {
-            uint32_t ch = 0;
-            Iterator it = first_;
-            switch (length_) 
-            {
-            default:
-                return replacement_char;
-                break;
-            case 4:
-                ch += static_cast<uint8_t>(*it++); ch <<= 6;
-                JSONCONS_FALLTHROUGH;
-            case 3:
-                ch += static_cast<uint8_t>(*it++); ch <<= 6;
-                JSONCONS_FALLTHROUGH;
-            case 2:
-                ch += static_cast<uint8_t>(*it++); ch <<= 6;
-                JSONCONS_FALLTHROUGH;
-            case 1:
-                ch += static_cast<uint8_t>(*it++);
-                ch -= offsets_from_utf8[length_ - 1];
-                break;
-            }
-            if (ch <= max_legal_utf32) 
-            {
-                if (is_surrogate(ch)) 
-                {
-                    ch = replacement_char;
-                }
-            }
-            else // ch > max_legal_utf32
-            {
-                ch = replacement_char;
-            }
-            return ch;
-        }
-
-        template <class CharT = typename std::iterator_traits<Iterator>::value_type>
-        typename std::enable_if<sizeof(CharT) == sizeof(uint16_t),uint32_t>::type 
-        codepoint() const noexcept
-        {
-            if (length_ == 0)
-            {
-                return replacement_char;
-            }
-            if (length_ == 2)
-            {
-                uint32_t ch = *first_;
-                uint32_t ch2 = *(first_+ 1);
-                ch = ((ch - sur_high_start) << half_shift)
-                     + (ch2 - sur_low_start) + half_base;
-                return ch;
-            }
-            else 
-            {
-                return *first_;
-            }
-        }
-
-        template <class CharT = typename std::iterator_traits<Iterator>::value_type>
-        typename std::enable_if<sizeof(CharT) == sizeof(uint32_t),uint32_t>::type 
-        codepoint() const noexcept
-        {
-            if (length_ == 0)
-            {
-                return replacement_char;
-            }
-            return *(first_);
-        }
-    };
-
-    // sequence_generator
-
-    template <class Iterator>
-    class sequence_generator
-    {
-        Iterator begin_;
-        Iterator last_;
-        conv_flags flags_;
-        std::size_t length_;
-        conv_errc err_cd_;
-    public:
-        using sequence_type = sequence<Iterator>;
-
-        sequence_generator(Iterator first, Iterator last, 
-                           conv_flags flags = conv_flags::strict) noexcept
-            : begin_(first), last_(last), flags_(flags), 
-              length_(0), err_cd_(conv_errc())
-        {
-            next();
-        }
-
-        bool done() const noexcept
-        {
-            return err_cd_ != conv_errc() || begin_ == last_;
-        }
-
-        conv_errc status() const noexcept
-        {
-            return err_cd_;
-        }
-
-        sequence_type get() const noexcept
-        {
-            return sequence<Iterator>(begin_,length_);
-        }
-
-        template <class CharT = typename std::iterator_traits<Iterator>::value_type>
-        typename std::enable_if<sizeof(CharT) == sizeof(uint8_t)>::type 
-        next() noexcept
-        {
-            begin_ += length_;
-            if (begin_ != last_)
-            {
-                std::size_t length = trailing_bytes_for_utf8[static_cast<uint8_t>(*begin_)] + 1;
-                if (length > (std::size_t)(last_ - begin_))
-                {
-                    err_cd_ = conv_errc::source_exhausted;
-                }
-                else if ((err_cd_ = is_legal_utf8(begin_, length)) != conv_errc())
-                {
-                }
-                else
-                {
-                    length_ = length;
-                }
-            }
-        }
-
-        template <class CharT = typename std::iterator_traits<Iterator>::value_type>
-        typename std::enable_if<sizeof(CharT) == sizeof(uint16_t)>::type 
-        next() noexcept
-        {
-            begin_ += length_;
-            if (begin_ != last_)
-            {
-                Iterator it = begin_;
-
-                uint32_t ch = *it++;
-                /* If we have a surrogate pair, validate to uint32_t it. */
-                if (is_high_surrogate(ch)) 
-                {
-                    /* If the 16 bits following the high surrogate are in the it buffer... */
-                    if (it < last_) {
-                        uint32_t ch2 = *it;
-                        /* If it's a low surrogate, */
-                        if (ch2 >= sur_low_start && ch2 <= sur_low_end) 
-                        {
-                            ++it;
-                            length_ = 2;
-                        } 
-                        else 
-                        {
-                            err_cd_ = conv_errc::unpaired_high_surrogate;
-                        }
-                    } 
-                    else 
-                    { 
-                        // We don't have the 16 bits following the high surrogate.
-                        err_cd_ = conv_errc::source_exhausted;
-                    }
-                } 
-                else if (is_low_surrogate(ch)) 
-                {
-                    /* leading low surrogate */
-                    err_cd_ = conv_errc::source_illegal;
-                }
-                else
-                {
-                    length_ = 1;
-                }
-            }
-        }
-
-        template <class CharT = typename std::iterator_traits<Iterator>::value_type>
-        typename std::enable_if<sizeof(CharT) == sizeof(uint32_t)>::type 
-        next() noexcept
-        {
-            begin_ += length_;
-            length_ = 1;
-        }
-    };
-
-    template <class Iterator>
-    sequence_generator<Iterator> make_sequence_generator(Iterator first, Iterator last,
-        conv_flags flags = conv_flags::strict)
-    {
-        return sequence_generator<Iterator>(first, last, flags);
-    }
 
 } // unicode_traits
 } // jsoncons
diff --git a/tests/fuzz_regression/src/fuzz_regression_tests.cpp b/tests/fuzz_regression/src/fuzz_regression_tests.cpp
index eb441a1df..248b05d63 100644
--- a/tests/fuzz_regression/src/fuzz_regression_tests.cpp
+++ b/tests/fuzz_regression/src/fuzz_regression_tests.cpp
@@ -17,602 +17,590 @@ using namespace jsoncons;
 
 TEST_CASE("oss-fuzz issues")
 {
-#if 0
     // Fuzz target: fuzz_parse
     // Issue: Stack-overflow
     // Diagnosis: During basic_json destruction, an internal compiler stack error occurred in std::vector 
     //            destructor after reaching a certain nesting depth,
     //            approximately 270 with visual studio on windows.
     // Resolution: 
     // - Implement destructors for json_array and json_object that flatten std::vector elements
     // - max_nesting_depth option for all parsers and encoders (default 1024)
     SECTION("issue 21589")
     {
         std::string pathname = "fuzz_regression/input/clusterfuzz-testcase-minimized-fuzz_parse-5763671533027328";
         json_options options;
         options.max_nesting_depth(std::numeric_limits<int>::max());
 
         std::ifstream is(pathname, std::ios_base::in | std::ios_base::binary);
         REQUIRE_THROWS_WITH(json::parse(is, options), Catch::Matchers::Contains(json_error_category_impl().message((int)json_errc::expected_comma_or_right_bracket).c_str()));
     }
 
     // Fuzz target: fuzz_cbo
     // Issue: Abrt in __cxxabiv1::failed_throw
     // Diagnosis: Huge length field in binary data formats
     // Resolution: Read from source in chunks, to avoid bad_alloc, and fail with unexpected_eof
     SECTION("issue 21619")
     {
         std::string pathname = "fuzz_regression/input/clusterfuzz-testcase-minimized-fuzz_cbor-5171679883165696";
 
         std::ifstream is(pathname, std::ios_base::in | std::ios_base::binary);
         CHECK(is); //-V521
 
         cbor::cbor_options options;
         options.max_nesting_depth(std::numeric_limits<int>::max());
 
         default_json_visitor visitor;
 
         cbor::cbor_stream_reader reader(is,visitor,options);
 
         std::error_code ec;
         REQUIRE_NOTHROW(reader.read(ec));
         CHECK((ec.value() == (int)cbor::cbor_errc::unexpected_eof ||  // x64 arch //-V521
                ec.value() == (int)cbor::cbor_errc::number_too_large)); // x86 arch  
     }
 
     // Fuzz target: fuzz_cbor
     // Issue: Timeout in fuzz_cbor
     SECTION("issue 21631")
     {
         std::string pathname = "fuzz_regression/input/clusterfuzz-testcase-minimized-fuzz_cbor-5639265590706176";
 
         std::ifstream is(pathname, std::ios_base::in | std::ios_base::binary);
         CHECK(is); //-V521
 
         default_json_visitor visitor;
 
         cbor::cbor_options options;
         options.max_nesting_depth(std::numeric_limits<int>::max());
 
         cbor::cbor_stream_reader reader(is,visitor,options);
 
         std::error_code ec;
         REQUIRE_NOTHROW(reader.read(ec));
         CHECK((ec == cbor::cbor_errc::unknown_type || // x64 arch //-V521
                ec == cbor::cbor_errc::number_too_large)); // x86 arch
     }
 
     // Fuzz target: fuzz_csv
     // Issue: Integer-overflow
     SECTION("issue 21663")
     {
         std::string pathname = "fuzz_regression/input/clusterfuzz-testcase-minimized-fuzz_csv-5762751990595584";
 
         std::ifstream is(pathname, std::ios_base::in | std::ios_base::binary);
         CHECK(is); //-V521
 
         json_decoder<json> visitor;
 
         csv::csv_options options;
         options.assume_header(true);
         options.mapping(csv::mapping_kind::n_rows);
         csv::csv_reader reader(is,visitor,options);
 
         std::error_code ec;
         REQUIRE_NOTHROW(reader.read(ec));
         CHECK_FALSE(ec); //-V521
 
         //std::cout << visitor.get_result() << "" << std::endl;
     }
 
     SECTION("issue 21663b")
     {
         std::string s = "-6.6E6";
         auto result = jsoncons::detail::to_integer<int64_t>(s.data(),s.size());
         CHECK_FALSE(result); //-V521
     }
 
     // Fuzz target: fuzz_ubjson
     // Issue: Out-of-memory
     // Diagnosis:  Issue with huge length for a strongly typed array of no-op, null, false, or true,
     // e.g. [[][$][T][#][I][9223372036854775807]
     // Resolution: limit number of items to max_items set in options
     SECTION("issue 21667")
     {
         std::string pathname = "fuzz_regression/input/clusterfuzz-testcase-minimized-fuzz_ubjson-5738905124208640";
 
         std::ifstream is(pathname, std::ios_base::in | std::ios_base::binary);
         CHECK(is); //-V521
 
         default_json_visitor visitor;
 
         ubjson::ubjson_stream_reader reader(is,visitor);
         std::error_code ec;
         REQUIRE_NOTHROW(reader.read(ec));
         CHECK((ec == ubjson::ubjson_errc::max_items_exceeded || // x64 arch //-V521
                ec == ubjson::ubjson_errc::number_too_large)); // x86 arch
     }
 
     // Fuzz target: fuzz_ubjson
     // Issue: Timeout 
     SECTION("issue 21697")
     {
         std::string pathname = "fuzz_regression/input/clusterfuzz-testcase-minimized-fuzz_ubjson-5737197673381888";
 
         std::ifstream is(pathname, std::ios_base::in | std::ios_base::binary);
         CHECK(is); //-V521
 
         json_decoder<json> visitor;
 
         ubjson::ubjson_stream_reader reader(is,visitor);
         std::error_code ec;
         REQUIRE_NOTHROW(reader.read(ec));
         CHECK(ec == ubjson::ubjson_errc::key_expected); //-V521
     }
 
     // Fuzz target: fuzz_cbor
     // Issue: Stack overflow
     SECTION("issue 21709")
     {
         std::string pathname = "fuzz_regression/input/clusterfuzz-testcase-minimized-fuzz_cbor-5740910806827008.fuzz";
 
         std::ifstream is(pathname, std::ios_base::in | std::ios_base::binary);
         cbor::cbor_options options;
         options.max_nesting_depth(10000);
         REQUIRE_THROWS_WITH(cbor::decode_cbor<json>(is,options), Catch::Matchers::Contains(cbor::cbor_error_category_impl().message((int)cbor::cbor_errc::max_nesting_depth_exceeded).c_str()));
     }
 
     // Fuzz target: fuzz_cbor
     // Issue: Stack overflow
     SECTION("issue 21710")
     {
         std::string pathname = "fuzz_regression/input/clusterfuzz-testcase-fuzz_cbor-5141282369568768";
 
         std::ifstream is(pathname, std::ios_base::in | std::ios_base::binary);
         CHECK(is); //-V521
 
         cbor::cbor_options options;
         options.max_nesting_depth(10000);
 
         REQUIRE_THROWS_WITH(cbor::decode_cbor<json>(is,options), Catch::Matchers::Contains(cbor::cbor_error_category_impl().message((int)cbor::cbor_errc::max_nesting_depth_exceeded).c_str()));
     }
 
     SECTION("issue 21710b")
     {
         std::string pathname = "fuzz_regression/input/clusterfuzz-testcase-fuzz_cbor-5141282369568768";
 
         std::ifstream is(pathname, std::ios_base::in | std::ios_base::binary);
         CHECK(is); //-V521
 
         cbor::cbor_options options;
         options.max_nesting_depth(std::numeric_limits<int>::max());
 
         default_json_visitor visitor;
         cbor::cbor_stream_reader reader(is,visitor,options);
 
         std::error_code ec;
         REQUIRE_NOTHROW(reader.read(ec));
         CHECK(ec.value() == (int)cbor::cbor_errc::unknown_type); //-V521
     }
 
     // Fuzz target: fuzz_msgpack
     // Issue: Out of memory
     SECTION("issue 21801")
     {
         std::string pathname = "fuzz_regression/input/clusterfuzz-testcase-minimized-fuzz_msgpack-5651190114418688";
 
         std::ifstream is(pathname, std::ios_base::in | std::ios_base::binary);
         CHECK(is); //-V521
 
         json_decoder<json> visitor;
 
         msgpack::msgpack_options options;
 
         msgpack::msgpack_stream_reader reader(is,visitor);
         std::error_code ec;
         REQUIRE_NOTHROW(reader.read(ec));
         CHECK(ec == msgpack::msgpack_errc::unexpected_eof); //-V521
     }
 
     // Fuzz target: fuzz_cbor
     // Issue: Stack overflow
     SECTION("issue 21805")
     {
         std::string pathname = "fuzz_regression/input/clusterfuzz-testcase-fuzz_cbor-5687592176844800";
 
         std::ifstream is(pathname, std::ios_base::in | std::ios_base::binary);
         CHECK(is); //-V521
 
         default_json_visitor visitor;
 
         cbor::cbor_options options;
 
         cbor::cbor_stream_reader reader(is,visitor,options);
 
         std::error_code ec;
         //reader.read(ec);
         //std::cout << ec.message() << "" << std::endl;
         REQUIRE_NOTHROW(reader.read(ec));
         CHECK((ec == cbor::cbor_errc::max_nesting_depth_exceeded));  //-V521
     }
 
     // Fuzz target: fuzz_msgpack
     // Issue: Timeout
     SECTION("issue 21813")
     {
         std::string pathname = "fuzz_regression/input/clusterfuzz-testcase-fuzz_msgpack-5727715157344256";
 
         std::ifstream is(pathname, std::ios_base::in | std::ios_base::binary);
         CHECK(is); //-V521
 
         default_json_visitor visitor;
 
         msgpack::msgpack_options options;
         options.max_nesting_depth(std::numeric_limits<int>::max());
 
         msgpack::msgpack_stream_reader reader(is,visitor,options);
         std::error_code ec;
         REQUIRE_NOTHROW(reader.read(ec));
         CHECK(ec == msgpack::msgpack_errc::unexpected_eof); //-V521
     }
 
     // Fuzz target: fuzz_ubjson
     // Issue: Timeout
     SECTION("issue 21865")
     {
         std::string pathname = "fuzz_regression/input/clusterfuzz-testcase-fuzz_bson-5637264110780416";
 
         std::ifstream is(pathname, std::ios_base::in | std::ios_base::binary);
         CHECK(is); //-V521
 
         default_json_visitor visitor;
 
         bson::bson_options options;
         options.max_nesting_depth(std::numeric_limits<int>::max());
 
         bson::bson_stream_reader reader(is,visitor,options);
         std::error_code ec;
         REQUIRE_NOTHROW(reader.read(ec));
         CHECK(ec == bson::bson_errc::unknown_type); //-V521
     }
 
     // Fuzz target: fuzz_cbor_encoder
     // Issue: failed_throw
     // Resolution: change assert to illegal_chunked_string error code
     SECTION("issue 21902")
     {
         std::string pathname = "fuzz_regression/input/clusterfuzz-testcase-fuzz_cbor_encoder-5665976638242816";
 
         std::ifstream is(pathname, std::ios_base::in | std::ios_base::binary);
         CHECK(is); //-V521
 
         try
         {
             std::vector<uint8_t> buf;
             cbor::cbor_bytes_encoder encoder(buf);
             cbor::cbor_stream_reader reader(is, encoder);
 
             std::error_code ec;
             REQUIRE_NOTHROW(reader.read(ec));
             CHECK(ec == cbor::cbor_errc::illegal_chunked_string); //-V521
         }
         catch (const std::exception& e)
         {
             std::cout << e.what() << "" << std::endl;
         }
     }
 
     // Fuzz target: fuzz_csv_encoder
     // Issue: Failed throw
     // Resolution: check if csv_parser is still in start state when no more input
     SECTION("issue 21912")
     {
         std::string pathname = "fuzz_regression/input/clusterfuzz-testcase-minimized-fuzz_csv_encoder-5202115606872064.fuzz";
 
         std::ifstream is(pathname, std::ios_base::in | std::ios_base::binary);
         CHECK(is); //-V521
 
         std::string s2;
         csv::csv_string_encoder visitor(s2);
 
         csv::csv_reader reader(is, visitor);
         std::error_code ec;
 
         REQUIRE_NOTHROW(reader.read(ec));
         CHECK((ec == csv::csv_errc::source_error)); //-V521
 
         //std::cout << visitor.get_result() << "" << std::endl;
     }
 
     // Fuzz target: fuzz_cbor
     // Issue: failed_throw
     SECTION("issue 21948")
     {
         std::string pathname = "fuzz_regression/input/clusterfuzz-testcase-minimized-fuzz_cbor-5743359164678144";
 
         std::ifstream is(pathname, std::ios_base::in | std::ios_base::binary);
         CHECK(is); //-V521
 
         json_decoder<json> visitor;
         cbor::cbor_options options;
 
         cbor::cbor_stream_reader reader(is,visitor,options);
 
         std::error_code ec;
         REQUIRE_NOTHROW(reader.read(ec));
         CHECK((ec == cbor::cbor_errc::unknown_type));  //-V521
     }
 
     // Fuzz target: fuzz_csv_encoder
     // Issue: Failed throw
     // Resolution: Fixed check for floating point values
     SECTION("issue 21990")
     {
         std::string pathname = "fuzz_regression/input/clusterfuzz-testcase-minimized-fuzz_csv_encoder-5682837304115200.fuzz";
 
         std::ifstream is(pathname, std::ios_base::in | std::ios_base::binary);
         CHECK(is); //-V521
 
         std::string s2;
         csv::csv_string_encoder visitor(s2);
 
         csv::csv_reader reader(is, visitor);
         std::error_code ec;
 
         REQUIRE_NOTHROW(reader.read(ec));
     }
 
     // Fuzz target: fuzz_cbor_encoder
     // Issue: failed_throw
     // Resolution: Replaced assert that array containing decimal fraction
     //             has size 2 with error code invalid_decimal_fraction
     SECTION("issue  22000")
     {
         std::string pathname = "fuzz_regression/input/clusterfuzz-testcase-fuzz_cbor_encoder-5685492533428224";
 
         std::ifstream is(pathname, std::ios_base::in | std::ios_base::binary);
         CHECK(is); //-V521
 
         std::vector<uint8_t> buf;
         cbor::cbor_bytes_encoder encoder(buf);
         cbor::cbor_stream_reader reader(is, encoder);
 
         std::error_code ec;
         REQUIRE_NOTHROW(reader.read(ec));
         CHECK(ec == cbor::cbor_errc::invalid_decimal_fraction); //-V521
     }
 
     // Fuzz target: fuzz_cbor_encoder
     // Issue: failed_throw
     // Resolution: prettify_string with decimal fractions failed with exponents >= 1000
 
     SECTION("issue 22018")
     {
         std::string pathname = "fuzz_regression/input/clusterfuzz-testcase-fuzz_cbor_encoder-5673305546948608";
 
         std::ifstream is(pathname, std::ios_base::in | std::ios_base::binary);
         CHECK(is); //-V521
 
         std::vector<uint8_t> buf;
         cbor::cbor_bytes_encoder encoder(buf);
         cbor::cbor_stream_reader reader(is, encoder);
 
         std::error_code ec;
         REQUIRE_NOTHROW(reader.read(ec));
         CHECK((ec == cbor::cbor_errc::illegal_chunked_string || ec == cbor::cbor_errc::invalid_decimal_fraction)); //-V521
     }
     // Fuzz target: fuzz_cbor_encoder
     // Issue: Stack-overflow
     // Resolution: 
 
     SECTION("issue 22023")
     {
         std::string pathname = "fuzz_regression/input/clusterfuzz-testcase-fuzz_cbor_encoder-5681910597812224";
 
         std::ifstream is(pathname, std::ios_base::in | std::ios_base::binary);
         CHECK(is); //-V521
 
         std::vector<uint8_t> buf;
         cbor::cbor_bytes_encoder encoder(buf);
 
         cbor::cbor_stream_reader reader(is, encoder);
 
         std::error_code ec;
         REQUIRE_NOTHROW(reader.read(ec));
         CHECK(ec == cbor::cbor_errc::unexpected_eof); //-V521
     }
 
     // Fuzz target: fuzz_msgpack_encoder
     // Issue: Timeout
     SECTION("issue 22024")
     {
         std::string pathname = "fuzz_regression/input/clusterfuzz-testcase-fuzz_msgpack_encoder-5677646685143040";
 
         std::ifstream is(pathname, std::ios_base::in | std::ios_base::binary);
         CHECK(is); //-V521
 
         std::vector<uint8_t> buf;
         msgpack::msgpack_bytes_encoder visitor(buf);
 
         msgpack::msgpack_stream_reader reader(is,visitor);
         std::error_code ec;
 
         REQUIRE_NOTHROW(reader.read(ec));
         CHECK((ec == msgpack::msgpack_errc::unexpected_eof || //-V521
                ec == msgpack::msgpack_errc::unknown_type));
     }
 
     // Fuzz target: jsoncons:fuzz_json_cursor
     // Issue: failed_throw
     SECTION("issue 22091")
     {
         std::string pathname = "fuzz_regression/input/clusterfuzz-testcase-minimized-fuzz_json_cursor-5686693027119104";
 
         std::ifstream is(pathname, std::ios_base::in | std::ios_base::binary);
         CHECK(is); //-V521
 
         std::error_code ec;
         json_cursor reader(is, ec);
         while (reader.done() == 0 && !ec)
         {
             const auto& event = reader.current();
             std::string s2 = event.get<std::string>(ec); 
             if (!ec)
             {
                 reader.next(ec);
             }
         }
         CHECK(ec == conv_errc::not_string); //-V521
     }
 
     // Fuzz target: fuzz_cbor_encoder
     // Issue: TIMEOUT
     // Resolution: 
 /*
     SECTION("issue 22379")
     {
         std::string pathname = "fuzz_regression/input/clusterfuzz-testcase-minimized-fuzz_cbor_encoder-6266427819687936";
 
         std::ifstream is(pathname, std::ios_base::in | std::ios_base::binary);
         CHECK(is);
 
         std::vector<uint8_t> buf;
         cbor::cbor_bytes_encoder encoder(buf);
 
         cbor::cbor_stream_reader reader(is, encoder);
 
         std::error_code ec;
         try
         {
             reader.read(ec);
         }
         catch (const std::exception& e)
         {
             std::cout << e.what() << "\n";
         }
         //REQUIRE_NOTHROW(reader.read(ec));
         //CHECK(ec == cbor::cbor_errc::unexpected_eof);
     }
 */
     // Fuzz target: fuzz_ubjson
     // Issue: Direct-leak in std::__1::__libcpp_allocate
     SECTION("issue 24216")
     {
         std::string pathname = "fuzz_regression/input/clusterfuzz-testcase-minimized-fuzz_ubjson-5667315455361024";
 
         std::ifstream is(pathname, std::ios_base::in | std::ios_base::binary);
         CHECK(is); //-V521
 
         try {
            json j2 = ubjson::decode_ubjson<json>(is);
         }
         catch(const jsoncons::ser_error&) 
         {
             //std::cout << e.what() << "\n\n";
         }
     }
 
     // Fuzz target: fuzz_msgpack_parser_max
     // Issue:  Integer-overflow
     SECTION("issue 24574")
     {
         std::string pathname = "fuzz_regression/input/clusterfuzz-testcase-minimized-fuzz_msgpack_parser_max-6248108141576192";
 
         std::ifstream is(pathname, std::ios_base::in | std::ios_base::binary);
         CHECK(is); //-V521
 
         default_json_visitor visitor;
         msgpack::msgpack_options options;
         options.max_nesting_depth(std::numeric_limits<int>::max());
 
         msgpack::msgpack_stream_reader reader(is, visitor, options);
         std::error_code ec;
         reader.read(ec);
     }
 
     // Fuzz target: fuzz_ubjson_encoder
     // Issue: Timeout
     SECTION("issue 23840")
     {
         std::string pathname = "fuzz_regression/input/clusterfuzz-testcase-minimized-fuzz_ubjson_encoder-5711604342849536";
 
         std::ifstream is(pathname, std::ios_base::in | std::ios_base::binary);
         CHECK(is); //-V521
 
         std::vector<uint8_t> output;
         ubjson::ubjson_bytes_encoder encoder(output);
         ubjson::ubjson_stream_reader reader(is, encoder);
 
         std::error_code ec;
         reader.read(ec);
         CHECK(ec == ubjson::ubjson_errc::unknown_type); //-V521
     }
 
     // Fuzz target: fuzz_ubjson
     // Issue: failed_throw
     SECTION("issue 25891")
     {
         std::string pathname = "fuzz_regression/input/clusterfuzz-testcase-minimized-fuzz_ubjson-5751108612653056";
 
         std::ifstream is(pathname, std::ios_base::in | std::ios_base::binary);
         CHECK(is); //-V521
 
         try {
            json j2 = ubjson::decode_ubjson<json>(is);
         }
         catch(const jsoncons::ser_error&) {}
     }
 
     // Fuzz target: fuzz_json_encoder
     // Issue: Out-of-memory
     SECTION("issue 27342")
     {
         std::string pathname = "fuzz_regression/input/clusterfuzz-testcase-minimized-fuzz_json_encoder-5769370349076480";
 
         std::ifstream is(pathname, std::ios_base::in | std::ios_base::binary);
         CHECK(is); //-V521
 
         std::string s2;
         json_string_encoder visitor(s2);
 
         json_reader reader(is, visitor);
         try
         {
             std::error_code ec;
             reader.read(ec);
         }
         catch (const std::exception& e)
         {
             std::cout << e.what() << std::endl;
         }
     }
-#endif
+
     // Fuzz target: fuzz_json_encoder
     // Issue: Container-overflow READ 1
     SECTION("issue 33781")
     {
         std::string pathname = "fuzz_regression/input/clusterfuzz-testcase-minimized-fuzz_json_encoder-5639543840702464";
 
         std::ifstream is(pathname, std::ios_base::in | std::ios_base::binary);
         CHECK(is); //-V521
 
         std::string s2;
         json_string_encoder visitor(s2);
 
         json_reader reader(is, visitor);
-        try
-        {
-            std::error_code ec;
-            reader.read(ec);
-            if (ec)
-            {
-                std::cout << ec.message() << "\n";
-            }
-        }
-        catch (const std::exception& e)
-        {
-            std::cout << e.what() << std::endl;
-        }
+        std::error_code ec;
+        reader.read(ec);
     }
 }
 
