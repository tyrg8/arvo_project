commit ea14d495b1995ff09642edfb1b0b45a3d289b0af
Merge: f305433 8dc9766
Author: Xin Li <delphij@google.com>
Date:   Wed Sep 4 13:33:44 2019 -0700

    DO NOT MERGE - Merge Android 10 into master
    
    Bug: 139893257
    Change-Id: I4cd7a2af463ad33b1bdc7260434d5e1c04695ef8

diff --git a/Android.bp b/Android.bp
index 16cd9b5..3c424e4 100644
--- a/Android.bp
+++ b/Android.bp
@@ -1,514 +1,514 @@
 cc_library_static {
     name: "libavcdec",
     vendor_available: true,
     host_supported:true,
     shared_libs: ["liblog", "libcutils",],
 
     cflags: [
         "-fPIC",
         "-O3",
         "-Wall",
         "-Werror",
         "-Wno-unused-variable",
         "-Wno-null-pointer-arithmetic",
     ],
 
     export_include_dirs: [
         "decoder",
         "common",
     ],
 
     srcs: [
         "common/ih264_buf_mgr.c",
         "common/ih264_disp_mgr.c",
         "common/ih264_inter_pred_filters.c",
         "common/ih264_luma_intra_pred_filters.c",
         "common/ih264_chroma_intra_pred_filters.c",
         "common/ih264_padding.c",
         "common/ih264_mem_fns.c",
         "common/ih264_deblk_edge_filters.c",
         "common/ih264_iquant_itrans_recon.c",
         "common/ih264_ihadamard_scaling.c",
         "common/ih264_weighted_pred.c",
         "common/ithread.c",
         "decoder/ih264d_cabac.c",
         "decoder/ih264d_parse_mb_header.c",
         "decoder/ih264d_parse_cabac.c",
         "decoder/ih264d_process_intra_mb.c",
         "decoder/ih264d_inter_pred.c",
         "decoder/ih264d_parse_bslice.c",
         "decoder/ih264d_parse_pslice.c",
         "decoder/ih264d_parse_islice.c",
         "decoder/ih264d_cabac_init_tables.c",
         "decoder/ih264d_bitstrm.c",
         "decoder/ih264d_compute_bs.c",
         "decoder/ih264d_deblocking.c",
         "decoder/ih264d_parse_headers.c",
         "decoder/ih264d_mb_utils.c",
         "decoder/ih264d_mvpred.c",
         "decoder/ih264d_utils.c",
         "decoder/ih264d_process_bslice.c",
         "decoder/ih264d_process_pslice.c",
         "decoder/ih264d_parse_slice.c",
         "decoder/ih264d_quant_scaling.c",
         "decoder/ih264d_parse_cavlc.c",
         "decoder/ih264d_dpb_mgr.c",
         "decoder/ih264d_nal.c",
         "decoder/ih264d_sei.c",
         "decoder/ih264d_tables.c",
         "decoder/ih264d_vui.c",
         "decoder/ih264d_format_conv.c",
         "decoder/ih264d_thread_parse_decode.c",
         "decoder/ih264d_api.c",
         "decoder/ih264d_thread_compute_bs.c",
         "decoder/ih264d_function_selector_generic.c",
     ],
 
     arch: {
         arm: {
             local_include_dirs: [
                 "decoder/arm",
                 "common/arm",
             ],
 
             srcs: [
                 "decoder/arm/ih264d_function_selector.c",
                 "common/arm/ih264_arm_memory_barrier.s",
             ],
 
             cflags: [
                 "-DARM",
 
                 // These will be overriden by armv7_a_neon
                 "-DDISABLE_NEON",
                 "-DDEFAULT_ARCH=D_ARCH_ARM_NONEON",
             ],
 
             neon: {
                 srcs: [
                     "decoder/arm/ih264d_function_selector_a9q.c",
                     "common/arm/ih264_intra_pred_chroma_a9q.s",
                     "common/arm/ih264_intra_pred_luma_16x16_a9q.s",
                     "common/arm/ih264_intra_pred_luma_4x4_a9q.s",
                     "common/arm/ih264_intra_pred_luma_8x8_a9q.s",
                     "common/arm/ih264_inter_pred_chroma_a9q.s",
                     "common/arm/ih264_inter_pred_filters_luma_horz_a9q.s",
                     "common/arm/ih264_inter_pred_filters_luma_vert_a9q.s",
                     "common/arm/ih264_inter_pred_luma_copy_a9q.s",
                     "common/arm/ih264_inter_pred_luma_horz_qpel_a9q.s",
                     "common/arm/ih264_inter_pred_luma_vert_qpel_a9q.s",
                     "common/arm/ih264_inter_pred_luma_horz_hpel_vert_hpel_a9q.s",
                     "common/arm/ih264_inter_pred_luma_horz_qpel_vert_qpel_a9q.s",
                     "common/arm/ih264_inter_pred_luma_horz_qpel_vert_hpel_a9q.s",
                     "common/arm/ih264_inter_pred_luma_horz_hpel_vert_qpel_a9q.s",
                     "common/arm/ih264_default_weighted_pred_a9q.s",
                     "common/arm/ih264_weighted_pred_a9q.s",
                     "common/arm/ih264_weighted_bi_pred_a9q.s",
                     "common/arm/ih264_deblk_chroma_a9.s",
                     "common/arm/ih264_deblk_luma_a9.s",
                     "common/arm/ih264_padding_neon.s",
                     "common/arm/ih264_iquant_itrans_recon_a9.s",
                     "common/arm/ih264_iquant_itrans_recon_dc_a9.s",
                     "common/arm/ih264_ihadamard_scaling_a9.s",
                 ],
                 cflags: [
                     "-UDISABLE_NEON",
                     "-UDEFAULT_ARCH",
                     "-DDEFAULT_ARCH=D_ARCH_ARM_A9Q",
                 ],
             },
         },
 
         arm64: {
             cflags: [
                 "-DARMV8",
                 "-DARM",
                 "-DDEFAULT_ARCH=D_ARCH_ARMV8_GENERIC",
             ],
             local_include_dirs: [
                 "decoder/arm",
                 "common/armv8",
             ],
 
             srcs: [
                 "decoder/arm/ih264d_function_selector.c",
                 "decoder/arm/ih264d_function_selector_av8.c",
                 "common/armv8/ih264_intra_pred_chroma_av8.s",
                 "common/armv8/ih264_intra_pred_luma_16x16_av8.s",
                 "common/armv8/ih264_intra_pred_luma_4x4_av8.s",
                 "common/armv8/ih264_inter_pred_chroma_av8.s",
                 "common/armv8/ih264_inter_pred_filters_luma_horz_av8.s",
                 "common/armv8/ih264_inter_pred_filters_luma_vert_av8.s",
                 "common/armv8/ih264_inter_pred_luma_copy_av8.s",
                 "common/armv8/ih264_inter_pred_luma_horz_qpel_av8.s",
                 "common/armv8/ih264_inter_pred_luma_vert_qpel_av8.s",
                 "common/armv8/ih264_inter_pred_luma_horz_hpel_vert_hpel_av8.s",
                 "common/armv8/ih264_inter_pred_luma_horz_qpel_vert_qpel_av8.s",
                 "common/armv8/ih264_inter_pred_luma_horz_qpel_vert_hpel_av8.s",
                 "common/armv8/ih264_inter_pred_luma_horz_hpel_vert_qpel_av8.s",
                 "common/armv8/ih264_default_weighted_pred_av8.s",
                 "common/armv8/ih264_weighted_pred_av8.s",
                 "common/armv8/ih264_weighted_bi_pred_av8.s",
                 "common/armv8/ih264_deblk_chroma_av8.s",
                 "common/armv8/ih264_deblk_luma_av8.s",
                 "common/armv8/ih264_padding_neon_av8.s",
                 "common/armv8/ih264_iquant_itrans_recon_av8.s",
                 "common/armv8/ih264_iquant_itrans_recon_dc_av8.s",
                 "common/armv8/ih264_ihadamard_scaling_av8.s",
                 "common/armv8/ih264_intra_pred_luma_8x8_av8.s",
             ],
         },
 
         mips: {
             local_include_dirs: ["common/mips"],
 
             srcs: ["decoder/mips/ih264d_function_selector.c"],
         },
 
         mips64: {
             local_include_dirs: ["common/mips"],
 
             srcs: ["decoder/mips/ih264d_function_selector.c"],
         },
 
         x86: {
             cflags: [
                 "-DX86",
                 "-msse4.2",
                 "-DDEFAULT_ARCH=D_ARCH_X86_SSE42",
             ],
 
             local_include_dirs: [
                 "decoder/x86",
                 "common/x86",
             ],
 
             srcs: [
                 "decoder/x86/ih264d_function_selector.c",
                 "decoder/x86/ih264d_function_selector_sse42.c",
                 "decoder/x86/ih264d_function_selector_ssse3.c",
                 "common/x86/ih264_inter_pred_filters_ssse3.c",
                 "common/x86/ih264_deblk_luma_ssse3.c",
                 "common/x86/ih264_deblk_chroma_ssse3.c",
                 "common/x86/ih264_padding_ssse3.c",
                 "common/x86/ih264_mem_fns_ssse3.c",
                 "common/x86/ih264_iquant_itrans_recon_dc_ssse3.c",
                 "common/x86/ih264_iquant_itrans_recon_ssse3.c",
                 "common/x86/ih264_luma_intra_pred_filters_ssse3.c",
                 "common/x86/ih264_chroma_intra_pred_filters_ssse3.c",
                 "common/x86/ih264_iquant_itrans_recon_sse42.c",
                 "common/x86/ih264_weighted_pred_sse42.c",
                 "common/x86/ih264_ihadamard_scaling_sse42.c",
             ],
         },
 
         x86_64: {
             cflags: [
                 "-DX86",
                 "-msse4.2",
                 "-DDEFAULT_ARCH=D_ARCH_X86_SSE42",
             ],
 
             local_include_dirs: [
                 "decoder/x86",
                 "common/x86",
             ],
 
             srcs: [
                 "decoder/x86/ih264d_function_selector.c",
                 "decoder/x86/ih264d_function_selector_sse42.c",
                 "decoder/x86/ih264d_function_selector_ssse3.c",
                 "common/x86/ih264_inter_pred_filters_ssse3.c",
                 "common/x86/ih264_deblk_luma_ssse3.c",
                 "common/x86/ih264_deblk_chroma_ssse3.c",
                 "common/x86/ih264_padding_ssse3.c",
                 "common/x86/ih264_mem_fns_ssse3.c",
                 "common/x86/ih264_iquant_itrans_recon_dc_ssse3.c",
                 "common/x86/ih264_iquant_itrans_recon_ssse3.c",
                 "common/x86/ih264_luma_intra_pred_filters_ssse3.c",
                 "common/x86/ih264_chroma_intra_pred_filters_ssse3.c",
                 "common/x86/ih264_iquant_itrans_recon_sse42.c",
                 "common/x86/ih264_weighted_pred_sse42.c",
                 "common/x86/ih264_ihadamard_scaling_sse42.c",
             ],
         },
     },
 
     sanitize: {
-    	cfi: true,
-        diag: {
-            cfi: true,
-        },
-        blacklist: "cfi_blacklist.txt",
+        integer_overflow: true,
+        misc_undefined: ["bounds"],
+        // Enable CFI if this becomes a shared library.
+        // cfi: true,
+        blacklist: "libavc_blacklist.txt",
     },
 }
 
 cc_library_static {
     name: "libavcenc",
     vendor_available: true,
     shared_libs: ["liblog", "libcutils",],
 
     cflags: [
         "-DNDEBUG",
         "-UHP_PL",
         "-DN_MB_ENABLE",
         "-fPIC",
 
         "-O3",
         "-Wall",
         "-Werror",
         "-Wno-error=constant-conversion",
     ],
 
     export_include_dirs: [
         "encoder",
         "common",
     ],
 
     srcs: [ //Rate Control
         "common/ih264_resi_trans_quant.c",
         "common/ih264_iquant_itrans_recon.c",
         "common/ih264_ihadamard_scaling.c",
         "common/ih264_inter_pred_filters.c",
         "common/ih264_luma_intra_pred_filters.c",
         "common/ih264_chroma_intra_pred_filters.c",
         "common/ih264_padding.c",
         "common/ih264_mem_fns.c",
         "common/ih264_deblk_edge_filters.c",
         "common/ih264_deblk_tables.c",
         "common/ih264_cavlc_tables.c",
         "common/ih264_cabac_tables.c",
         "common/ih264_common_tables.c",
         "common/ih264_trans_data.c",
         "common/ih264_buf_mgr.c",
         "common/ih264_dpb_mgr.c",
         "common/ih264_list.c",
         "common/ithread.c",
         "encoder/ih264e_globals.c",
         "encoder/ih264e_intra_modes_eval.c",
         "encoder/ih264e_half_pel.c",
         "encoder/ih264e_mc.c",
         "encoder/ih264e_me.c",
         "encoder/ih264e_rc_mem_interface.c",
         "encoder/ih264e_time_stamp.c",
         "encoder/ih264e_modify_frm_rate.c",
         "encoder/ih264e_rate_control.c",
         "encoder/ih264e_core_coding.c",
         "encoder/ih264e_deblk.c",
         "encoder/ih264e_api.c",
         "encoder/ih264e_process.c",
         "encoder/ih264e_encode.c",
         "encoder/ih264e_utils.c",
         "encoder/ih264e_version.c",
         "encoder/ih264e_bitstream.c",
         "encoder/ih264e_cavlc.c",
         "encoder/ih264e_cabac_init.c",
         "encoder/ih264e_cabac.c",
         "encoder/ih264e_cabac_encode.c",
         "encoder/ih264e_encode_header.c",
         "encoder/ih264e_function_selector_generic.c",
         "encoder/ih264e_fmt_conv.c",
         "encoder/irc_rate_control_api.c",
         "encoder/irc_bit_allocation.c",
         "encoder/irc_cbr_buffer_control.c",
         "encoder/irc_est_sad.c",
         "encoder/irc_fixed_point_error_bits.c",
         "encoder/irc_frame_info_collector.c",
         "encoder/irc_mb_model_based.c",
         "encoder/irc_picture_type.c",
         "encoder/irc_rd_model.c",
         "encoder/irc_vbr_storage_vbv.c",
         "encoder/irc_vbr_str_prms.c",
         "encoder/ime.c",
         "encoder/ime_distortion_metrics.c",
     ],
 
     arch: {
         arm: {
             local_include_dirs: [
                 "encoder/arm",
                 "common/arm",
             ],
 
             srcs: [
                 "encoder/arm/ih264e_function_selector.c",
                 "common/arm/ih264_arm_memory_barrier.s",
             ],
 
             cflags: [
                 "-DARM",
 
                 // This will be overriden by armv7_a_neon
                 "-DDISABLE_NEON",
             ],
 
             neon: {
                 srcs: [
                     "encoder/arm/ih264e_function_selector_a9q.c",
                     "common/arm/ih264_resi_trans_quant_a9.s",
                     "common/arm/ih264_iquant_itrans_recon_a9.s",
                     "common/arm/ih264_iquant_itrans_recon_dc_a9.s",
                     "common/arm/ih264_ihadamard_scaling_a9.s",
                     "common/arm/ih264_deblk_chroma_a9.s",
                     "common/arm/ih264_deblk_luma_a9.s",
                     "common/arm/ih264_intra_pred_chroma_a9q.s",
                     "common/arm/ih264_intra_pred_luma_16x16_a9q.s",
                     "common/arm/ih264_intra_pred_luma_4x4_a9q.s",
                     "common/arm/ih264_intra_pred_luma_8x8_a9q.s",
                     "common/arm/ih264_inter_pred_chroma_a9q.s",
                     "common/arm/ih264_inter_pred_filters_luma_horz_a9q.s",
                     "common/arm/ih264_inter_pred_filters_luma_vert_a9q.s",
                     "common/arm/ih264_inter_pred_luma_bilinear_a9q.s",
                     "common/arm/ih264_inter_pred_luma_copy_a9q.s",
                     "common/arm/ih264_padding_neon.s",
                     "common/arm/ih264_mem_fns_neon.s",
                     "encoder/arm/ih264e_evaluate_intra16x16_modes_a9q.s",
                     "encoder/arm/ih264e_evaluate_intra4x4_modes_a9q.s",
                     "encoder/arm/ih264e_evaluate_intra_chroma_modes_a9q.s",
                     "encoder/arm/ih264e_half_pel.s",
                     "encoder/arm/ih264e_fmt_conv.s",
                     "encoder/arm/ime_distortion_metrics_a9q.s",
                 ],
 
                 cflags: [
                     "-UDISABLE_NEON",
                 ],
             },
         },
 
         arm64: {
             cflags: [
                 "-DARMV8",
                 "-DARM",
             ],
 
             local_include_dirs: [
                 "encoder/arm",
                 "encoder/armv8",
                 "common/armv8",
             ],
 
             srcs: [
                 "encoder/arm/ih264e_function_selector.c",
                 "encoder/arm/ih264e_function_selector_av8.c",
                 "common/armv8/ih264_resi_trans_quant_av8.s",
                 "common/armv8/ih264_iquant_itrans_recon_av8.s",
                 "common/armv8/ih264_iquant_itrans_recon_dc_av8.s",
                 "common/armv8/ih264_ihadamard_scaling_av8.s",
                 "common/armv8/ih264_intra_pred_chroma_av8.s",
                 "common/armv8/ih264_intra_pred_luma_16x16_av8.s",
                 "common/armv8/ih264_intra_pred_luma_4x4_av8.s",
                 "common/armv8/ih264_intra_pred_luma_8x8_av8.s",
                 "common/armv8/ih264_inter_pred_luma_copy_av8.s",
                 "common/armv8/ih264_inter_pred_chroma_av8.s",
                 "common/armv8/ih264_inter_pred_filters_luma_horz_av8.s",
                 "common/armv8/ih264_inter_pred_filters_luma_vert_av8.s",
                 "common/armv8/ih264_padding_neon_av8.s",
                 "common/armv8/ih264_mem_fns_neon_av8.s",
                 "common/armv8/ih264_deblk_luma_av8.s",
                 "common/armv8/ih264_deblk_chroma_av8.s",
                 "encoder/armv8/ih264e_evaluate_intra16x16_modes_av8.s",
                 "encoder/armv8/ih264e_evaluate_intra_chroma_modes_av8.s",
                 "encoder/armv8/ih264e_half_pel_av8.s",
                 "encoder/armv8/ime_distortion_metrics_av8.s",
             ],
         },
 
         mips: {
             local_include_dirs: [
                 "common/mips",
                 "encoder/mips",
             ],
 
             srcs: ["encoder/mips/ih264e_function_selector.c"],
         },
 
         mips64: {
             local_include_dirs: [
                 "common/mips",
                 "encoder/mips",
             ],
 
             srcs: ["encoder/mips/ih264e_function_selector.c"],
         },
 
         x86: {
             cflags: [
                 "-DX86",
                 "-msse4.2",
             ],
 
             local_include_dirs: [
                 "encoder/x86",
                 "common/x86",
             ],
 
             srcs: [
                 "encoder/x86/ih264e_function_selector.c",
                 "encoder/x86/ih264e_function_selector_sse42.c",
                 "encoder/x86/ih264e_function_selector_ssse3.c",
                 "common/x86/ih264_iquant_itrans_recon_ssse3.c",
                 "common/x86/ih264_iquant_itrans_recon_dc_ssse3.c",
                 "common/x86/ih264_ihadamard_scaling_ssse3.c",
                 "common/x86/ih264_inter_pred_filters_ssse3.c",
                 "common/x86/ih264_mem_fns_ssse3.c",
                 "common/x86/ih264_padding_ssse3.c",
                 "common/x86/ih264_luma_intra_pred_filters_ssse3.c",
                 "common/x86/ih264_chroma_intra_pred_filters_ssse3.c",
                 "common/x86/ih264_deblk_chroma_ssse3.c",
                 "common/x86/ih264_deblk_luma_ssse3.c",
                 "common/x86/ih264_iquant_itrans_recon_sse42.c",
                 "common/x86/ih264_ihadamard_scaling_sse42.c",
                 "common/x86/ih264_resi_trans_quant_sse42.c",
                 "common/x86/ih264_weighted_pred_sse42.c",
                 "encoder/x86/ih264e_half_pel_ssse3.c",
                 "encoder/x86/ih264e_intra_modes_eval_ssse3.c",
                 "encoder/x86/ime_distortion_metrics_sse42.c",
             ],
         },
 
         x86_64: {
             cflags: [
                 "-DX86",
                 "-msse4.2",
             ],
 
             local_include_dirs: [
                 "encoder/x86",
                 "common/x86",
             ],
 
             srcs: [
                 "encoder/x86/ih264e_function_selector.c",
                 "encoder/x86/ih264e_function_selector_sse42.c",
                 "encoder/x86/ih264e_function_selector_ssse3.c",
                 "common/x86/ih264_iquant_itrans_recon_ssse3.c",
                 "common/x86/ih264_iquant_itrans_recon_dc_ssse3.c",
                 "common/x86/ih264_ihadamard_scaling_ssse3.c",
                 "common/x86/ih264_inter_pred_filters_ssse3.c",
                 "common/x86/ih264_mem_fns_ssse3.c",
                 "common/x86/ih264_padding_ssse3.c",
                 "common/x86/ih264_luma_intra_pred_filters_ssse3.c",
                 "common/x86/ih264_chroma_intra_pred_filters_ssse3.c",
                 "common/x86/ih264_deblk_chroma_ssse3.c",
                 "common/x86/ih264_deblk_luma_ssse3.c",
                 "common/x86/ih264_iquant_itrans_recon_sse42.c",
                 "common/x86/ih264_ihadamard_scaling_sse42.c",
                 "common/x86/ih264_resi_trans_quant_sse42.c",
                 "common/x86/ih264_weighted_pred_sse42.c",
                 "encoder/x86/ih264e_half_pel_ssse3.c",
                 "encoder/x86/ih264e_intra_modes_eval_ssse3.c",
                 "encoder/x86/ime_distortion_metrics_sse42.c",
             ],
         },
     },
 
     sanitize: {
-    	cfi: true,
-        diag: {
-            cfi: true,
-        },
-        blacklist: "cfi_blacklist.txt",
+        integer_overflow: true,
+        misc_undefined: ["bounds"],
+        // Enable CFI if this becomes a shared library.
+        // cfi: true,
+        blacklist: "libavc_blacklist.txt",
     },
 }
 
diff --git a/cfi_blacklist.txt b/cfi_blacklist.txt
deleted file mode 100644
index 1571e0e..0000000
--- a/cfi_blacklist.txt
+++ /dev/null
@@ -1 +0,0 @@
-src:*external/libavc/*
diff --git a/common/arm/ih264_platform_macros.h b/common/arm/ih264_platform_macros.h
index 438e240..a4d7f3a 100644
--- a/common/arm/ih264_platform_macros.h
+++ b/common/arm/ih264_platform_macros.h
@@ -1,41 +1,43 @@
 /******************************************************************************
  *
  * Copyright (C) 2015 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  *****************************************************************************
  * Originally developed and contributed by Ittiam Systems Pvt. Ltd, Bangalore
 */
 /**
 *******************************************************************************
 * @file
 *  ih264_platform_macros.h
 *
 * @brief
 *  Platform specific Macro definitions used in the codec
 *
 * @author
 *  Ittiam
 *
 * @remarks
 *  None
 *
 *******************************************************************************
 */
 #ifndef _IH264_PLATFORM_MACROS_H_
 #define _IH264_PLATFORM_MACROS_H_
 
+#include <stdint.h>
+
 #ifndef  ARMV8
 
 static __inline WORD32 CLIP_U8(WORD32 x)
@@ -62,6 +64,18 @@ static __inline WORD32 CLIP_S10(WORD32 x)
     return x;
 }
 
+static __inline WORD32 CLIP_U11(WORD32 x)
+{
+    asm("usat %0, #11, %1" : "=r"(x) : "r"(x));
+    return x;
+}
+
+static __inline WORD32 CLIP_S11(WORD32 x)
+{
+    asm("ssat %0, #11, %1" : "=r"(x) : "r"(x));
+    return x;
+}
+
 static __inline WORD32 CLIP_U12(WORD32 x)
 {
     asm("usat %0, #12, %1" : "=r"(x) : "r"(x));
@@ -89,51 +103,64 @@ static __inline WORD32 CLIP_S16(WORD32 x)
 static __inline UWORD32 ITT_BIG_ENDIAN(UWORD32 x)
 {
     asm("rev %0, %1" : "=r"(x) : "r"(x));
     return x;
 }
 #define NOP(nop_cnt)    {UWORD32 nop_i; for (nop_i = 0; nop_i < nop_cnt; nop_i++) asm("nop");}
 
 #else
 
-#define CLIP_U8(x) CLIP3(0, 255, (x))
-#define CLIP_S8(x) CLIP3(-128, 127, (x))
+#define CLIP_U8(x) CLIP3(0, UINT8_MAX, (x))
+#define CLIP_S8(x) CLIP3(INT8_MIN, INT8_MAX, (x))
 
 #define CLIP_U10(x) CLIP3(0, 1023, (x))
 #define CLIP_S10(x) CLIP3(-512, 511, (x))
 
+#define CLIP_U11(x) CLIP3(0, 2047, (x))
+#define CLIP_S11(x) CLIP3(-1024, 1023, (x))
+
 #define CLIP_U12(x) CLIP3(0, 4095, (x))
 #define CLIP_S12(x) CLIP3(-2048, 2047, (x))
 
-#define CLIP_U16(x) CLIP3(0, 65535, (x))
-#define CLIP_S16(x) CLIP3(-32768, 32767, (x))
+#define CLIP_U16(x) CLIP3(0, UINT16_MAX, (x))
+#define CLIP_S16(x) CLIP3(INT16_MIN, INT16_MAX, (x))
 
 #define ITT_BIG_ENDIAN(x)       __asm__("rev %0, %1" : "=r"(x) : "r"(x));
 
 #define NOP(nop_cnt)                                \
 {                                                   \
     UWORD32 nop_i;                                  \
     for (nop_i = 0; nop_i < nop_cnt; nop_i++)       \
         __asm__ __volatile__("mov x0, x0");         \
 }
 
 #endif
 
+/*saturating instructions are not available for WORD64 in ARMv7, hence we cannot
+ * use inline assembly like other clips*/
+#define CLIP_U32(x) CLIP3(0, UINT32_MAX, (x))
+#define CLIP_S32(x) CLIP3(INT32_MIN, INT32_MAX, (x))
+
 #define DATA_SYNC() __sync_synchronize()
 
 #define SHL(x,y) (((y) < 32) ? ((x) << (y)) : 0)
 #define SHR(x,y) (((y) < 32) ? ((x) >> (y)) : 0)
 
 #define SHR_NEG(val,shift)  ((shift>0)?(val>>shift):(val<<(-shift)))
 #define SHL_NEG(val,shift)  ((shift<0)?(val>>(-shift)):(val<<shift))
 
 #define INLINE inline
 
+/* In normal cases, 0 will not be passed as an argument to CLZ and CTZ.
+As CLZ and CTZ outputs are used as a shift value in few places, these return
+31 for u4_word == 0 case, just to handle error cases gracefully without any
+undefined behaviour */
+
 static INLINE UWORD32 CLZ(UWORD32 u4_word)
 {
     if(u4_word)
         return (__builtin_clz(u4_word));
     else
-        return 32;
+        return 31;
 }
 static INLINE UWORD32 CTZ(UWORD32 u4_word)
 {
diff --git a/common/armv8/ih264_platform_macros.h b/common/armv8/ih264_platform_macros.h
index 438e240..a4d7f3a 100644
--- a/common/armv8/ih264_platform_macros.h
+++ b/common/armv8/ih264_platform_macros.h
@@ -1,41 +1,43 @@
 /******************************************************************************
  *
  * Copyright (C) 2015 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  *****************************************************************************
  * Originally developed and contributed by Ittiam Systems Pvt. Ltd, Bangalore
 */
 /**
 *******************************************************************************
 * @file
 *  ih264_platform_macros.h
 *
 * @brief
 *  Platform specific Macro definitions used in the codec
 *
 * @author
 *  Ittiam
 *
 * @remarks
 *  None
 *
 *******************************************************************************
 */
 #ifndef _IH264_PLATFORM_MACROS_H_
 #define _IH264_PLATFORM_MACROS_H_
 
+#include <stdint.h>
+
 #ifndef  ARMV8
 
 static __inline WORD32 CLIP_U8(WORD32 x)
@@ -62,6 +64,18 @@ static __inline WORD32 CLIP_S10(WORD32 x)
     return x;
 }
 
+static __inline WORD32 CLIP_U11(WORD32 x)
+{
+    asm("usat %0, #11, %1" : "=r"(x) : "r"(x));
+    return x;
+}
+
+static __inline WORD32 CLIP_S11(WORD32 x)
+{
+    asm("ssat %0, #11, %1" : "=r"(x) : "r"(x));
+    return x;
+}
+
 static __inline WORD32 CLIP_U12(WORD32 x)
 {
     asm("usat %0, #12, %1" : "=r"(x) : "r"(x));
@@ -89,51 +103,64 @@ static __inline WORD32 CLIP_S16(WORD32 x)
 static __inline UWORD32 ITT_BIG_ENDIAN(UWORD32 x)
 {
     asm("rev %0, %1" : "=r"(x) : "r"(x));
     return x;
 }
 #define NOP(nop_cnt)    {UWORD32 nop_i; for (nop_i = 0; nop_i < nop_cnt; nop_i++) asm("nop");}
 
 #else
 
-#define CLIP_U8(x) CLIP3(0, 255, (x))
-#define CLIP_S8(x) CLIP3(-128, 127, (x))
+#define CLIP_U8(x) CLIP3(0, UINT8_MAX, (x))
+#define CLIP_S8(x) CLIP3(INT8_MIN, INT8_MAX, (x))
 
 #define CLIP_U10(x) CLIP3(0, 1023, (x))
 #define CLIP_S10(x) CLIP3(-512, 511, (x))
 
+#define CLIP_U11(x) CLIP3(0, 2047, (x))
+#define CLIP_S11(x) CLIP3(-1024, 1023, (x))
+
 #define CLIP_U12(x) CLIP3(0, 4095, (x))
 #define CLIP_S12(x) CLIP3(-2048, 2047, (x))
 
-#define CLIP_U16(x) CLIP3(0, 65535, (x))
-#define CLIP_S16(x) CLIP3(-32768, 32767, (x))
+#define CLIP_U16(x) CLIP3(0, UINT16_MAX, (x))
+#define CLIP_S16(x) CLIP3(INT16_MIN, INT16_MAX, (x))
 
 #define ITT_BIG_ENDIAN(x)       __asm__("rev %0, %1" : "=r"(x) : "r"(x));
 
 #define NOP(nop_cnt)                                \
 {                                                   \
     UWORD32 nop_i;                                  \
     for (nop_i = 0; nop_i < nop_cnt; nop_i++)       \
         __asm__ __volatile__("mov x0, x0");         \
 }
 
 #endif
 
+/*saturating instructions are not available for WORD64 in ARMv7, hence we cannot
+ * use inline assembly like other clips*/
+#define CLIP_U32(x) CLIP3(0, UINT32_MAX, (x))
+#define CLIP_S32(x) CLIP3(INT32_MIN, INT32_MAX, (x))
+
 #define DATA_SYNC() __sync_synchronize()
 
 #define SHL(x,y) (((y) < 32) ? ((x) << (y)) : 0)
 #define SHR(x,y) (((y) < 32) ? ((x) >> (y)) : 0)
 
 #define SHR_NEG(val,shift)  ((shift>0)?(val>>shift):(val<<(-shift)))
 #define SHL_NEG(val,shift)  ((shift<0)?(val>>(-shift)):(val<<shift))
 
 #define INLINE inline
 
+/* In normal cases, 0 will not be passed as an argument to CLZ and CTZ.
+As CLZ and CTZ outputs are used as a shift value in few places, these return
+31 for u4_word == 0 case, just to handle error cases gracefully without any
+undefined behaviour */
+
 static INLINE UWORD32 CLZ(UWORD32 u4_word)
 {
     if(u4_word)
         return (__builtin_clz(u4_word));
     else
-        return 32;
+        return 31;
 }
 static INLINE UWORD32 CTZ(UWORD32 u4_word)
 {
diff --git a/common/ih264_typedefs.h b/common/ih264_typedefs.h
index 8e4685a..29138c6 100644
--- a/common/ih264_typedefs.h
+++ b/common/ih264_typedefs.h
@@ -1,60 +1,60 @@
 /******************************************************************************
  *
  * Copyright (C) 2015 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  *****************************************************************************
  * Originally developed and contributed by Ittiam Systems Pvt. Ltd, Bangalore
 */
 /**
 *******************************************************************************
 * @file
 *  ih264_typedefs.h
 *
 * @brief
 *  Type definitions used in the code
 *
 * @author
 *  Ittiam
 *
 * @remarks
 *  None
 *
 *******************************************************************************
 */
 
 #ifndef _IH264_TYPEDEFS_H_
 #define _IH264_TYPEDEFS_H_
 
-
+#include <stdint.h>
 /*****************************************************************************/
 /* Unsigned data types                                                       */
 /*****************************************************************************/
-typedef unsigned char   UWORD8;
-typedef unsigned short  UWORD16;
-typedef unsigned int    UWORD32;
-typedef unsigned long long   UWORD64;
+typedef uint8_t   UWORD8;
+typedef uint16_t  UWORD16;
+typedef uint32_t  UWORD32;
+typedef uint64_t  UWORD64;
 
 
 /*****************************************************************************/
 /* Signed data types                                                         */
 /*****************************************************************************/
-typedef signed char     WORD8;
-typedef short           WORD16;
-typedef int             WORD32;
-
+typedef int8_t     WORD8;
+typedef int16_t    WORD16;
+typedef int32_t    WORD32;
+typedef int64_t    WORD64;
 
 /*****************************************************************************/
 /* Miscellaneous data types                                                  */
 /*****************************************************************************/
diff --git a/common/mips/ih264_platform_macros.h b/common/mips/ih264_platform_macros.h
index d098372..fa0ba61 100644
--- a/common/mips/ih264_platform_macros.h
+++ b/common/mips/ih264_platform_macros.h
@@ -1,80 +1,93 @@
 /******************************************************************************
  *
  * Copyright (C) 2015 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  *****************************************************************************
  * Originally developed and contributed by Ittiam Systems Pvt. Ltd, Bangalore
 */
 /**
 *******************************************************************************
 * @file
 *  ih264_platform_macros.h
 *
 * @brief
 *  Platform specific Macro definitions used in the codec
 *
 * @author
 *  Ittiam
 *
 * @remarks
 *  None
 *
 *******************************************************************************
 */
 
 
 #ifndef _IH264_PLATFORM_MACROS_H_
 #define _IH264_PLATFORM_MACROS_H_
 
-#define CLIP_U8(x) CLIP3(0, 255, (x))
-#define CLIP_S8(x) CLIP3(-128, 127, (x))
+#include <stdint.h>
+
+#define CLIP_U8(x) CLIP3(0, UINT8_MAX, (x))
+#define CLIP_S8(x) CLIP3(INT8_MIN, INT8_MAX, (x))
 
 #define CLIP_U10(x) CLIP3(0, 1023, (x))
 #define CLIP_S10(x) CLIP3(-512, 511, (x))
 
+#define CLIP_U11(x) CLIP3(0, 2047, (x))
+#define CLIP_S11(x) CLIP3(-1024, 1023, (x))
+
 #define CLIP_U12(x) CLIP3(0, 4095, (x))
 #define CLIP_S12(x) CLIP3(-2048, 2047, (x))
 
-#define CLIP_U16(x) CLIP3(0, 65535, (x))
-#define CLIP_S16(x) CLIP3(-32768, 32767, (x))
+#define CLIP_U16(x) CLIP3(0, UINT16_MAX, (x))
+#define CLIP_S16(x) CLIP3(INT16_MIN, INT16_MAX, (x))
+
+#define CLIP_U32(x) CLIP3(0, UINT32_MAX, (x))
+#define CLIP_S32(x) CLIP3(INT32_MIN, INT32_MAX, (x))
 
 #define MEM_ALIGN16 __attribute__ ((aligned (16)))
 
 #define SHL(x,y) (((y) < 32) ? ((x) << (y)) : 0)
 #define SHR(x,y) (((y) < 32) ? ((x) >> (y)) : 0)
 
 #define SHR_NEG(val,shift)  ((shift>0)?(val>>shift):(val<<(-shift)))
 #define SHL_NEG(val,shift)  ((shift<0)?(val>>(-shift)):(val<<shift))
 
 
 #define ITT_BIG_ENDIAN(x)       ((x << 24))                |   \
                             ((x & 0x0000ff00) << 8)    |   \
                             ((x & 0x00ff0000) >> 8)    |   \
                             ((UWORD32)x >> 24);
 
 
 #define NOP(nop_cnt)    {UWORD32 nop_i; for (nop_i = 0; nop_i < nop_cnt; nop_i++);}
 
 #define PLD(a)
 
+/* In normal cases, 0 will not be passed as an argument to CLZ and CTZ.
+As CLZ and CTZ outputs are used as a shift value in few places, these return
+31 for u4_word == 0 case, just to handle error cases gracefully without any
+undefined behaviour */
+
 static __inline UWORD32 CLZ(UWORD32 u4_word)
 {
     if(u4_word)
     return(__builtin_clz(u4_word));
     else
-        return 32;
+        return 31;
 }
 
 static __inline UWORD32 CTZ(UWORD32 u4_word)
diff --git a/common/x86/ih264_ihadamard_scaling_sse42.c b/common/x86/ih264_ihadamard_scaling_sse42.c
index d68d105..4065e35 100644
--- a/common/x86/ih264_ihadamard_scaling_sse42.c
+++ b/common/x86/ih264_ihadamard_scaling_sse42.c
@@ -54,149 +54,149 @@
 /*
  ********************************************************************************
  *
  * @brief This function performs a 4x4 inverse hadamard transform on the 4x4 DC coefficients
  * of a 16x16 intra prediction macroblock, and then performs scaling.
  * prediction buffer
  *
  * @par Description:
  *  The DC coefficients pass through a 2-stage inverse hadamard transform.
  *  This inverse transformed content is scaled to based on Qp value.
  *
  * @param[in] pi2_src
  *  input 4x4 block of DC coefficients
  *
  * @param[out] pi2_out
  *  output 4x4 block
  *
  * @param[in] pu2_iscal_mat
  *  pointer to scaling list
  *
  * @param[in] pu2_weigh_mat
  *  pointer to weight matrix
  *
  * @param[in] u4_qp_div_6
  *  Floor (qp/6)
  *
  * @param[in] pi4_tmp
  * temporary buffer of size 1*16
  *
  * @returns none
  *
  * @remarks none
  *
  *******************************************************************************
  */
 void ih264_ihadamard_scaling_4x4_sse42(WORD16* pi2_src,
                                        WORD16* pi2_out,
                                        const UWORD16 *pu2_iscal_mat,
                                        const UWORD16 *pu2_weigh_mat,
                                        UWORD32 u4_qp_div_6,
                                        WORD32* pi4_tmp)
 {
     __m128i src_r0_r1, src_r2_r3;
     __m128i src_r0, src_r1, src_r2, src_r3;
     __m128i temp0, temp1, temp2, temp3;
-    __m128i add_rshift = _mm_set1_epi32((1 << (5 - u4_qp_div_6)));
+    __m128i add_rshift = _mm_set1_epi32((u4_qp_div_6 < 6) ? (1 << (5 - u4_qp_div_6)) : 0);
     __m128i mult_val = _mm_set1_epi32(pu2_iscal_mat[0] * pu2_weigh_mat[0]);
     UNUSED (pi4_tmp);
 
     src_r0_r1 = _mm_loadu_si128((__m128i *) (pi2_src)); //a00 a01 a02 a03 a10 a11 a12 a13 -- the source matrix 0th,1st row
     src_r2_r3 = _mm_loadu_si128((__m128i *) (pi2_src + 8)); //a20 a21 a22 a23 a30 a31 a32 a33 -- the source matrix 2nd,3rd row
     //sign_reg = _mm_cmpgt_epi16(zero_8x16b, src_r0_r1);
     src_r0 = _mm_cvtepi16_epi32(src_r0_r1);
     src_r0_r1 = _mm_srli_si128(src_r0_r1, 8);
     src_r1 = _mm_cvtepi16_epi32(src_r0_r1);
 
     src_r2 = _mm_cvtepi16_epi32(src_r2_r3);
     src_r2_r3 = _mm_srli_si128(src_r2_r3, 8);
     src_r3 = _mm_cvtepi16_epi32(src_r2_r3);
 
     /* Perform Inverse transform */
     /*-------------------------------------------------------------*/
     /* IDCT [ Horizontal transformation ]                          */
     /*-------------------------------------------------------------*/
     // Matrix transpose
     /*
      *  a0 a1 a2 a3
      *  b0 b1 b2 b3
      *  c0 c1 c2 c3
      *  d0 d1 d2 d3
      */
     temp0 = _mm_unpacklo_epi32(src_r0, src_r1);                  //a0 b0 a1 b1
     temp2 = _mm_unpacklo_epi32(src_r2, src_r3);                  //c0 d0 c1 d1
     temp1 = _mm_unpackhi_epi32(src_r0, src_r1);                  //a2 b2 a3 b3
     temp3 = _mm_unpackhi_epi32(src_r2, src_r3);                  //c2 d2 c3 d3
     src_r0 = _mm_unpacklo_epi64(temp0, temp2);                    //a0 b0 c0 d0
     src_r1 = _mm_unpackhi_epi64(temp0, temp2);                    //a1 b1 c1 d1
     src_r2 = _mm_unpacklo_epi64(temp1, temp3);                    //a2 b2 c2 d2
     src_r3 = _mm_unpackhi_epi64(temp1, temp3);                    //a3 b3 c3 d3
 
     temp0 = _mm_add_epi32(src_r0, src_r3);
     temp1 = _mm_add_epi32(src_r1, src_r2);
     temp2 = _mm_sub_epi32(src_r1, src_r2);
     temp3 = _mm_sub_epi32(src_r0, src_r3);
 
     src_r0 = _mm_add_epi32(temp0, temp1);
     src_r1 = _mm_add_epi32(temp2, temp3);
     src_r2 = _mm_sub_epi32(temp0, temp1);
     src_r3 = _mm_sub_epi32(temp3, temp2);
 
     /*-------------------------------------------------------------*/
     /* IDCT [ Vertical transformation ]                          */
     /*-------------------------------------------------------------*/
     // Matrix transpose
     /*
      *  a0 b0 c0 d0
      *  a1 b1 c1 d1
      *  a2 b2 c2 d2
      *  a3 b3 c3 d3
      */
     temp0 = _mm_unpacklo_epi32(src_r0, src_r1);                  //a0 a1 b0 b1
     temp2 = _mm_unpacklo_epi32(src_r2, src_r3);                  //a2 a3 b2 b3
     temp1 = _mm_unpackhi_epi32(src_r0, src_r1);                  //c0 c1 d0 d1
     temp3 = _mm_unpackhi_epi32(src_r2, src_r3);                  //c2 c3 d2 d3
     src_r0 = _mm_unpacklo_epi64(temp0, temp2);                   //a0 a1 a2 a3
     src_r1 = _mm_unpackhi_epi64(temp0, temp2);                   //b0 b1 b2 b3
     src_r2 = _mm_unpacklo_epi64(temp1, temp3);                   //c0 c1 c2 c3
     src_r3 = _mm_unpackhi_epi64(temp1, temp3);                   //d0 d1 d2 d3
 
     temp0 = _mm_add_epi32(src_r0, src_r3);
     temp1 = _mm_add_epi32(src_r1, src_r2);
     temp2 = _mm_sub_epi32(src_r1, src_r2);
     temp3 = _mm_sub_epi32(src_r0, src_r3);
 
     src_r0 = _mm_add_epi32(temp0, temp1);
     src_r1 = _mm_add_epi32(temp2, temp3);
     src_r2 = _mm_sub_epi32(temp0, temp1);
     src_r3 = _mm_sub_epi32(temp3, temp2);
 
     src_r0 = _mm_mullo_epi32(src_r0, mult_val);
     src_r1 = _mm_mullo_epi32(src_r1, mult_val);
     src_r2 = _mm_mullo_epi32(src_r2, mult_val);
     src_r3 = _mm_mullo_epi32(src_r3, mult_val);
 
     //Scaling
     if(u4_qp_div_6 >= 6)
     {
         src_r0 = _mm_slli_epi32(src_r0, u4_qp_div_6 - 6);
         src_r1 = _mm_slli_epi32(src_r1, u4_qp_div_6 - 6);
         src_r2 = _mm_slli_epi32(src_r2, u4_qp_div_6 - 6);
         src_r3 = _mm_slli_epi32(src_r3, u4_qp_div_6 - 6);
     }
     else
     {
         temp0 = _mm_add_epi32(src_r0, add_rshift);
         temp1 = _mm_add_epi32(src_r1, add_rshift);
         temp2 = _mm_add_epi32(src_r2, add_rshift);
         temp3 = _mm_add_epi32(src_r3, add_rshift);
         src_r0 = _mm_srai_epi32(temp0, 6 - u4_qp_div_6);
         src_r1 = _mm_srai_epi32(temp1, 6 - u4_qp_div_6);
         src_r2 = _mm_srai_epi32(temp2, 6 - u4_qp_div_6);
         src_r3 = _mm_srai_epi32(temp3, 6 - u4_qp_div_6);
     }
     src_r0_r1 = _mm_packs_epi32(src_r0, src_r1);
     src_r2_r3 = _mm_packs_epi32(src_r2, src_r3);
 
     _mm_storeu_si128((__m128i *) (&pi2_out[0]), src_r0_r1);
     _mm_storeu_si128((__m128i *) (&pi2_out[8]), src_r2_r3);
 }
diff --git a/common/x86/ih264_ihadamard_scaling_ssse3.c b/common/x86/ih264_ihadamard_scaling_ssse3.c
index 1b940ea..b4d483f 100644
--- a/common/x86/ih264_ihadamard_scaling_ssse3.c
+++ b/common/x86/ih264_ihadamard_scaling_ssse3.c
@@ -53,157 +53,157 @@
 /*
  ********************************************************************************
  *
  * @brief This function performs a 4x4 inverse hadamard transform on the 4x4 DC coefficients
  * of a 16x16 intra prediction macroblock, and then performs scaling.
  * prediction buffer
  *
  * @par Description:
  *  The DC coefficients pass through a 2-stage inverse hadamard transform.
  *  This inverse transformed content is scaled to based on Qp value.
  *
  * @param[in] pi2_src
  *  input 4x4 block of DC coefficients
  *
  * @param[out] pi2_out
  *  output 4x4 block
  *
  * @param[in] pu2_iscal_mat
  *  pointer to scaling list
  *
  * @param[in] pu2_weigh_mat
  *  pointer to weight matrix
  *
  * @param[in] u4_qp_div_6
  *  Floor (qp/6)
  *
  * @param[in] pi4_tmp
  * temporary buffer of size 1*16
  *
  * @returns none
  *
  * @remarks none
  *
  *******************************************************************************
  */
 void ih264_ihadamard_scaling_4x4_ssse3(WORD16* pi2_src,
                                        WORD16* pi2_out,
                                        const UWORD16 *pu2_iscal_mat,
                                        const UWORD16 *pu2_weigh_mat,
                                        UWORD32 u4_qp_div_6,
                                        WORD32* pi4_tmp)
 {
     int val = 0xFFFF;
     __m128i src_r0_r1, src_r2_r3, sign_reg, zero_8x16b = _mm_setzero_si128();
     __m128i src_r0, src_r1, src_r2, src_r3;
     __m128i temp0, temp1, temp2, temp3;
-    __m128i add_rshift = _mm_set1_epi32((1 << (5 - u4_qp_div_6)));
+    __m128i add_rshift = _mm_set1_epi32((u4_qp_div_6 < 6) ? (1 << (5 - u4_qp_div_6)) : 0);
     __m128i mult_val = _mm_set1_epi32(pu2_iscal_mat[0] * pu2_weigh_mat[0]);
 
     __m128i mask = _mm_set1_epi32(val);
     UNUSED (pi4_tmp);
 
     mult_val = _mm_and_si128(mult_val, mask);
 
     src_r0_r1 = _mm_loadu_si128((__m128i *) (pi2_src)); //a00 a01 a02 a03 a10 a11 a12 a13 -- the source matrix 0th,1st row
     src_r2_r3 = _mm_loadu_si128((__m128i *) (pi2_src + 8)); //a20 a21 a22 a23 a30 a31 a32 a33 -- the source matrix 2nd,3rd row
     sign_reg = _mm_cmpgt_epi16(zero_8x16b, src_r0_r1);
     src_r0 = _mm_unpacklo_epi16(src_r0_r1, sign_reg);
     src_r1 = _mm_unpackhi_epi16(src_r0_r1, sign_reg);
     sign_reg = _mm_cmpgt_epi16(zero_8x16b, src_r2_r3);
     src_r2 = _mm_unpacklo_epi16(src_r2_r3, sign_reg);
     src_r3 = _mm_unpackhi_epi16(src_r2_r3, sign_reg);
 
     /* Perform Inverse transform */
     /*-------------------------------------------------------------*/
     /* IDCT [ Horizontal transformation ]                          */
     /*-------------------------------------------------------------*/
     // Matrix transpose
     /*
      *  a0 a1 a2 a3
      *  b0 b1 b2 b3
      *  c0 c1 c2 c3
      *  d0 d1 d2 d3
      */
     temp0 = _mm_unpacklo_epi32(src_r0, src_r1);                  //a0 b0 a1 b1
     temp2 = _mm_unpacklo_epi32(src_r2, src_r3);                  //c0 d0 c1 d1
     temp1 = _mm_unpackhi_epi32(src_r0, src_r1);                  //a2 b2 a3 b3
     temp3 = _mm_unpackhi_epi32(src_r2, src_r3);                  //c2 d2 c3 d3
     src_r0 = _mm_unpacklo_epi64(temp0, temp2);                    //a0 b0 c0 d0
     src_r1 = _mm_unpackhi_epi64(temp0, temp2);                    //a1 b1 c1 d1
     src_r2 = _mm_unpacklo_epi64(temp1, temp3);                    //a2 b2 c2 d2
     src_r3 = _mm_unpackhi_epi64(temp1, temp3);                    //a3 b3 c3 d3
 
     temp0 = _mm_add_epi32(src_r0, src_r3);
     temp1 = _mm_add_epi32(src_r1, src_r2);
     temp2 = _mm_sub_epi32(src_r1, src_r2);
     temp3 = _mm_sub_epi32(src_r0, src_r3);
 
     src_r0 = _mm_add_epi32(temp0, temp1);
     src_r1 = _mm_add_epi32(temp2, temp3);
     src_r2 = _mm_sub_epi32(temp0, temp1);
     src_r3 = _mm_sub_epi32(temp3, temp2);
 
     /*-------------------------------------------------------------*/
     /* IDCT [ Vertical transformation ]                          */
     /*-------------------------------------------------------------*/
     // Matrix transpose
     /*
      *  a0 b0 c0 d0
      *  a1 b1 c1 d1
      *  a2 b2 c2 d2
      *  a3 b3 c3 d3
      */
     temp0 = _mm_unpacklo_epi32(src_r0, src_r1);                  //a0 a1 b0 b1
     temp2 = _mm_unpacklo_epi32(src_r2, src_r3);                  //a2 a3 b2 b3
     temp1 = _mm_unpackhi_epi32(src_r0, src_r1);                  //c0 c1 d0 d1
     temp3 = _mm_unpackhi_epi32(src_r2, src_r3);                  //c2 c3 d2 d3
     src_r0 = _mm_unpacklo_epi64(temp0, temp2);                   //a0 a1 a2 a3
     src_r1 = _mm_unpackhi_epi64(temp0, temp2);                   //b0 b1 b2 b3
     src_r2 = _mm_unpacklo_epi64(temp1, temp3);                   //c0 c1 c2 c3
     src_r3 = _mm_unpackhi_epi64(temp1, temp3);                   //d0 d1 d2 d3
 
     temp0 = _mm_add_epi32(src_r0, src_r3);
     temp1 = _mm_add_epi32(src_r1, src_r2);
     temp2 = _mm_sub_epi32(src_r1, src_r2);
     temp3 = _mm_sub_epi32(src_r0, src_r3);
 
     src_r0 = _mm_add_epi32(temp0, temp1);
     src_r1 = _mm_add_epi32(temp2, temp3);
     src_r2 = _mm_sub_epi32(temp0, temp1);
     src_r3 = _mm_sub_epi32(temp3, temp2);
 
     src_r0 = _mm_and_si128(src_r0, mask);
     src_r1 = _mm_and_si128(src_r1, mask);
     src_r2 = _mm_and_si128(src_r2, mask);
     src_r3 = _mm_and_si128(src_r3, mask);
 
     src_r0 = _mm_madd_epi16(src_r0, mult_val);
     src_r1 = _mm_madd_epi16(src_r1, mult_val);
     src_r2 = _mm_madd_epi16(src_r2, mult_val);
     src_r3 = _mm_madd_epi16(src_r3, mult_val);
 
     //Scaling
     if(u4_qp_div_6 >= 6)
     {
         src_r0 = _mm_slli_epi32(src_r0, u4_qp_div_6 - 6);
         src_r1 = _mm_slli_epi32(src_r1, u4_qp_div_6 - 6);
         src_r2 = _mm_slli_epi32(src_r2, u4_qp_div_6 - 6);
         src_r3 = _mm_slli_epi32(src_r3, u4_qp_div_6 - 6);
     }
     else
     {
         temp0 = _mm_add_epi32(src_r0, add_rshift);
         temp1 = _mm_add_epi32(src_r1, add_rshift);
         temp2 = _mm_add_epi32(src_r2, add_rshift);
         temp3 = _mm_add_epi32(src_r3, add_rshift);
         src_r0 = _mm_srai_epi32(temp0, 6 - u4_qp_div_6);
         src_r1 = _mm_srai_epi32(temp1, 6 - u4_qp_div_6);
         src_r2 = _mm_srai_epi32(temp2, 6 - u4_qp_div_6);
         src_r3 = _mm_srai_epi32(temp3, 6 - u4_qp_div_6);
     }
     src_r0_r1 = _mm_packs_epi32(src_r0, src_r1);
     src_r2_r3 = _mm_packs_epi32(src_r2, src_r3);
 
     _mm_storeu_si128((__m128i *) (&pi2_out[0]), src_r0_r1);
     _mm_storeu_si128((__m128i *) (&pi2_out[8]), src_r2_r3);
 }
diff --git a/common/x86/ih264_iquant_itrans_recon_sse42.c b/common/x86/ih264_iquant_itrans_recon_sse42.c
index f27111f..a7b9e82 100644
--- a/common/x86/ih264_iquant_itrans_recon_sse42.c
+++ b/common/x86/ih264_iquant_itrans_recon_sse42.c
@@ -53,520 +53,520 @@
 /*
  ********************************************************************************
  *
  * @brief This function reconstructs a 4x4 sub block from quantized resiude and
  * prediction buffer
  *
  * @par Description:
  *  The quantized residue is first inverse quantized, then inverse transformed.
  *  This inverse transformed content is added to the prediction buffer to recon-
  *  struct the end output
  *
  * @param[in] pi2_src
  *  quantized 4x4 block
  *
  * @param[in] pu1_pred
  *  prediction 4x4 block
  *
  * @param[out] pu1_out
  *  reconstructed 4x4 block
  *
  * @param[in] src_strd
  *  quantization buffer stride
  *
  * @param[in] pred_strd,
  *  Prediction buffer stride
  *
  * @param[in] out_strd
  *  recon buffer Stride
  *
  * @param[in] pu2_scaling_list
  *  pointer to scaling list
  *
  * @param[in] pu2_norm_adjust
  *  pointer to inverse scale matrix
  *
  * @param[in] u4_qp_div_6
  *  Floor (qp/6)
  *
  * @param[in] pi4_tmp
  * temporary buffer of size 1*16
  *
  * @returns none
  *
  * @remarks none
  *
  *******************************************************************************
  */
 void ih264_iquant_itrans_recon_4x4_sse42(WORD16 *pi2_src,
                                    UWORD8 *pu1_pred,
                                    UWORD8 *pu1_out,
                                    WORD32 pred_strd,
                                    WORD32 out_strd,
                                    const UWORD16 *pu2_iscal_mat,
                                    const UWORD16 *pu2_weigh_mat,
                                    UWORD32 u4_qp_div_6,
                                    WORD16 *pi2_tmp,
                                    WORD32 iq_start_idx,
                                    WORD16 *pi2_dc_ld_addr)
  {
     UWORD32 *pu4_out = (UWORD32 *) pu1_out;
     __m128i src_r0_r1, src_r2_r3;
     __m128i src_r0, src_r1, src_r2, src_r3;
     __m128i scalemat_r0_r1, scalemat_r2_r3;
     __m128i pred_r0, pred_r1, pred_r2, pred_r3;
     __m128i sign_reg, dequant_r0_r1, dequant_r2_r3;
     __m128i zero_8x16b = _mm_setzero_si128();          // all bits reset to zero
     __m128i temp0, temp1, temp2, temp3, temp4, temp5, temp6, temp7;
     __m128i resq_r0, resq_r1, resq_r2, resq_r3;
-    __m128i add_rshift = _mm_set1_epi32((1 << (3 - u4_qp_div_6)));
+    __m128i add_rshift = _mm_set1_epi32((u4_qp_div_6 < 4) ? (1 << (3 - u4_qp_div_6)) : 0);
     __m128i value_32 = _mm_set1_epi32(32);
     UNUSED (pi2_tmp);
 
     /*************************************************************/
     /* Dequantization of coefficients. Will be replaced by SIMD  */
     /* operations on platform                                    */
     /*************************************************************/
     src_r0_r1 = _mm_loadu_si128((__m128i *) (pi2_src)); //a00 a01 a02 a03 a10 a11 a12 a13 -- the source matrix 0th,1st row
     src_r2_r3 = _mm_loadu_si128((__m128i *) (pi2_src + 8)); //a20 a21 a22 a23 a30 a31 a32 a33 -- the source matrix 2nd,3rd row
     scalemat_r0_r1 = _mm_loadu_si128((__m128i *) (pu2_iscal_mat)); //b00 b01 b02 b03 b10 b11 b12 b13 -- the scaling matrix 0th,1st row
     scalemat_r2_r3 = _mm_loadu_si128((__m128i *) (pu2_iscal_mat + 8)); //b20 b21 b22 b23 b30 b31 b32 b33 -- the scaling matrix 2nd,3rd row
     dequant_r0_r1 = _mm_loadu_si128((__m128i *) (pu2_weigh_mat)); //q00 q01 q02 q03 q10 q11 q12 q13 -- all 16 bits
     dequant_r2_r3 = _mm_loadu_si128((__m128i *) (pu2_weigh_mat + 8)); //q20 q21 q22 q23 q30 q31 q32 q33 -- all 16 bits
 
     temp0 = _mm_mullo_epi16(scalemat_r0_r1, dequant_r0_r1); //b00*q00 b01*q01 b02*q02 b03*q03 b10*q10 b11*q11 b12*q12 b13*q13 -- 16 bit result
     temp1 = _mm_mullo_epi16(scalemat_r2_r3, dequant_r2_r3); //b00*q00 b01*q01 b02*q02 b03*q03 b10*q10 b11*q11 b12*q12 b13*q13 -- 16 bit result
 
     temp4 = _mm_unpacklo_epi16(temp0, zero_8x16b); // b00*q00 0 b01*q01 0 b02*q02 0 b03*q03 0 -- 16 bit long
     temp5 = _mm_unpackhi_epi16(temp0, zero_8x16b); // b10*q10 0 b11*q11 0 b12*q12 0 b13*q13 0 -- 16 bit long
     temp6 = _mm_unpacklo_epi16(temp1, zero_8x16b); // b00*q00 0 b01*q01 0 b02*q02 0 b03*q03 0 -- 16 bit long
     temp7 = _mm_unpackhi_epi16(temp1, zero_8x16b); // b10*q10 0 b11*q11 0 b12*q12 0 b13*q13 0 -- 16 bit long
 
     src_r0 = _mm_unpacklo_epi16(src_r0_r1, zero_8x16b); // a00 0 a01 0 a02 0 a03 0 -- 16 bit long
     src_r1 = _mm_unpackhi_epi16(src_r0_r1, zero_8x16b); // a10 0 a11 0 a12 0 a13 0 -- 16 bit long
     src_r2 = _mm_unpacklo_epi16(src_r2_r3, zero_8x16b); // a20 0 a21 0 a22 0 a23 0 -- 16 bit long
     src_r3 = _mm_unpackhi_epi16(src_r2_r3, zero_8x16b); // a30 0 a31 0 a32 0 a33 0 -- 16 bit long
 
     temp4 = _mm_madd_epi16(src_r0, temp4); //a00*b00*q00 a10*b10*q10 a20*b20*q20 a30*b30 q30 -- 32 bits long
     temp5 = _mm_madd_epi16(src_r1, temp5);
     temp6 = _mm_madd_epi16(src_r2, temp6);
     temp7 = _mm_madd_epi16(src_r3, temp7);
 
     if (u4_qp_div_6 >= 4) {
         resq_r0 = _mm_slli_epi32(temp4, u4_qp_div_6 - 4);
         resq_r1 = _mm_slli_epi32(temp5, u4_qp_div_6 - 4);
         resq_r2 = _mm_slli_epi32(temp6, u4_qp_div_6 - 4);
         resq_r3 = _mm_slli_epi32(temp7, u4_qp_div_6 - 4);
     } else {
         temp4 = _mm_add_epi32(temp4, add_rshift);
         temp5 = _mm_add_epi32(temp5, add_rshift);
         temp6 = _mm_add_epi32(temp6, add_rshift);
         temp7 = _mm_add_epi32(temp7, add_rshift);
         resq_r0 = _mm_srai_epi32(temp4, 4 - u4_qp_div_6);
         resq_r1 = _mm_srai_epi32(temp5, 4 - u4_qp_div_6);
         resq_r2 = _mm_srai_epi32(temp6, 4 - u4_qp_div_6);
         resq_r3 = _mm_srai_epi32(temp7, 4 - u4_qp_div_6);
     }
 
     if (iq_start_idx == 1)
         resq_r0 = _mm_insert_epi32(resq_r0,(WORD32)pi2_dc_ld_addr[0],0);
     /* Perform Inverse transform */
     /*-------------------------------------------------------------*/
     /* IDCT [ Horizontal transformation ]                          */
     /*-------------------------------------------------------------*/
     // Matrix transpose
     /*
      *  a0 a1 a2 a3
      *  b0 b1 b2 b3
      *  c0 c1 c2 c3
      *  d0 d1 d2 d3
      */
     temp1 = _mm_unpacklo_epi32(resq_r0, resq_r1);                  //a0 b0 a1 b1
     temp3 = _mm_unpacklo_epi32(resq_r2, resq_r3);                  //c0 d0 c1 d1
     temp2 = _mm_unpackhi_epi32(resq_r0, resq_r1);                  //a2 b2 a3 b3
     temp4 = _mm_unpackhi_epi32(resq_r2, resq_r3);                  //c2 d2 c3 d3
     resq_r0 = _mm_unpacklo_epi64(temp1, temp3);                    //a0 b0 c0 d0
     resq_r1 = _mm_unpackhi_epi64(temp1, temp3);                    //a1 b1 c1 d1
     resq_r2 = _mm_unpacklo_epi64(temp2, temp4);                    //a2 b2 c2 d2
     resq_r3 = _mm_unpackhi_epi64(temp2, temp4);                    //a3 b3 c3 d3
     //Transform starts -- horizontal transform
     /*------------------------------------------------------------------*/
     /* z0 = w0 + w2                                             */
     temp0 = _mm_add_epi32(resq_r0, resq_r2);
     /* z1 = w0 - w2                                             */
     temp1 = _mm_sub_epi32(resq_r0, resq_r2);
     /* z2 = (w1 >> 1) - w3                                      */
     temp2 = _mm_srai_epi32(resq_r1, 1);                         //(w1>>1)
     temp2 = _mm_sub_epi32(temp2, resq_r3);                      //(w1>>1) - w3
     /* z3 = w1 + (w3 >> 1)                                      */
     temp3 = _mm_srai_epi32(resq_r3, 1);                         //(w3>>1) + w1
     temp3 = _mm_add_epi32(temp3, resq_r1);
     /*----------------------------------------------------------*/
     /* x0 = z0 + z3                                             */
     resq_r0 = _mm_add_epi32(temp0, temp3);
     /* x1 = z1 + z2                                             */
     resq_r1 = _mm_add_epi32(temp1, temp2);
     /* x2 = z1 - z2                                             */
     resq_r2 = _mm_sub_epi32(temp1, temp2);
     /* x3 = z0 - z3                                             */
     resq_r3 = _mm_sub_epi32(temp0, temp3);
     // Matrix transpose
     /*
      *  a0 b0 c0 d0
      *  a1 b1 c1 d1
      *  a2 b2 c2 d2
      *  a3 b3 c3 d3
      */
     temp1 = _mm_unpacklo_epi32(resq_r0, resq_r1);                  //a0 a1 b0 b1
     temp3 = _mm_unpacklo_epi32(resq_r2, resq_r3);                  //a2 a3 b2 b3
     temp2 = _mm_unpackhi_epi32(resq_r0, resq_r1);                  //c0 c1 d0 d1
     temp4 = _mm_unpackhi_epi32(resq_r2, resq_r3);                  //c2 c3 d2 d3
     resq_r0 = _mm_unpacklo_epi64(temp1, temp3);                    //a0 a1 a2 a3
     resq_r1 = _mm_unpackhi_epi64(temp1, temp3);                    //b0 b1 b2 b3
     resq_r2 = _mm_unpacklo_epi64(temp2, temp4);                    //c0 c1 c2 c3
     resq_r3 = _mm_unpackhi_epi64(temp2, temp4);                    //d0 d1 d2 d3
     //Transform ends -- horizontal transform
 
     //Load pred buffer
     pred_r0 = _mm_loadl_epi64((__m128i *) (&pu1_pred[0])); //p00 p01 p02 p03 0 0 0 0 0 0 0 0 -- all 8 bits
     pred_r1 = _mm_loadl_epi64((__m128i *) (&pu1_pred[pred_strd])); //p10 p11 p12 p13 0 0 0 0 0 0 0 0 -- all 8 bits
     pred_r2 = _mm_loadl_epi64((__m128i *) (&pu1_pred[2 * pred_strd])); //p20 p21 p22 p23 0 0 0 0 0 0 0 0 -- all 8 bits
     pred_r3 = _mm_loadl_epi64((__m128i *) (&pu1_pred[3 * pred_strd])); //p30 p31 p32 p33 0 0 0 0 0 0 0 0 -- all 8 bits
 
     pred_r0 = _mm_cvtepu8_epi32(pred_r0); //p00 p01 p02 p03 -- all 32 bits
     pred_r1 = _mm_cvtepu8_epi32(pred_r1); //p10 p11 p12 p13 -- all 32 bits
     pred_r2 = _mm_cvtepu8_epi32(pred_r2); //p20 p21 p22 p23 -- all 32 bits
     pred_r3 = _mm_cvtepu8_epi32(pred_r3); //p30 p31 p32 p33 -- all 32 bits
 
     /*--------------------------------------------------------------*/
     /* IDCT [ Vertical transformation] and Xij = (xij + 32)>>6      */
     /*                                                              */
     /* Add the prediction and store it back to same buffer          */
     /*--------------------------------------------------------------*/
     /* z0j = y0j + y2j                                                        */
     temp0 = _mm_add_epi32(resq_r0, resq_r2);
     /* z1j = y0j - y2j                                                        */
     temp1 = _mm_sub_epi32(resq_r0, resq_r2);
     /* z2j = (y1j>>1) - y3j                                                        */
     temp2 = _mm_srai_epi32(resq_r1, 1);                             //(y1j>>1)
     temp2 = _mm_sub_epi32(temp2, resq_r3);
     /* z3j = y1j + (y3j>>1)                                                        */
     temp3 = _mm_srai_epi32(resq_r3, 1);                             //(y3j>>1)
     temp3 = _mm_add_epi32(temp3, resq_r1);
 
     /* x0j = z0j + z3j                                                        */
     temp4 = _mm_add_epi32(temp0, temp3);
     temp4 = _mm_add_epi32(temp4, value_32);
     temp4 = _mm_srai_epi32(temp4, 6);
     temp4 = _mm_add_epi32(temp4, pred_r0);
     /* x1j = z1j + z2j                                                        */
     temp5 = _mm_add_epi32(temp1, temp2);
     temp5 = _mm_add_epi32(temp5, value_32);
     temp5 = _mm_srai_epi32(temp5, 6);
     temp5 = _mm_add_epi32(temp5, pred_r1);
     /* x2j = z1j - z2j                                                        */
     temp6 = _mm_sub_epi32(temp1, temp2);
     temp6 = _mm_add_epi32(temp6, value_32);
     temp6 = _mm_srai_epi32(temp6, 6);
     temp6 = _mm_add_epi32(temp6, pred_r2);
     /* x3j = z0j - z3j                                                        */
     temp7 = _mm_sub_epi32(temp0, temp3);
     temp7 = _mm_add_epi32(temp7, value_32);
     temp7 = _mm_srai_epi32(temp7, 6);
     temp7 = _mm_add_epi32(temp7, pred_r3);
 
     // 32-bit to 16-bit conversion
     temp0 = _mm_packs_epi32(temp4, temp5);
     temp1 = _mm_packs_epi32(temp6, temp7);
     /*------------------------------------------------------------------*/
     //Clipping the results to 8 bits
     sign_reg = _mm_cmpgt_epi16(temp0, zero_8x16b);      // sign check
     temp0 = _mm_and_si128(temp0, sign_reg);
     sign_reg = _mm_cmpgt_epi16(temp1, zero_8x16b);
     temp1 = _mm_and_si128(temp1, sign_reg);
 
     resq_r0 = _mm_packus_epi16(temp0, temp1);
     resq_r1 = _mm_srli_si128(resq_r0, 4);
     resq_r2 = _mm_srli_si128(resq_r1, 4);
     resq_r3 = _mm_srli_si128(resq_r2, 4);
 
     *pu4_out = _mm_cvtsi128_si32(resq_r0);
     pu1_out += out_strd;
     pu4_out = (UWORD32 *) (pu1_out);
     *(pu4_out) = _mm_cvtsi128_si32(resq_r1);
     pu1_out += out_strd;
     pu4_out = (UWORD32 *) (pu1_out);
     *(pu4_out) = _mm_cvtsi128_si32(resq_r2);
     pu1_out += out_strd;
     pu4_out = (UWORD32 *) (pu1_out);
     *(pu4_out) = _mm_cvtsi128_si32(resq_r3);
 }
 
 /*
  ********************************************************************************
  *
  * @brief This function reconstructs a 4x4 sub block from quantized chroma resiude and
  * prediction buffer
  *
  * @par Description:
  *  The quantized residue is first inverse quantized, then inverse transformed.
  *  This inverse transformed content is added to the prediction buffer to recon-
  *  struct the end output
  *
  * @param[in] pi2_src
  *  quantized 4x4 block
  *
  * @param[in] pu1_pred
  *  prediction 4x4 block
  *
  * @param[out] pu1_out
  *  reconstructed 4x4 block
  *
  * @param[in] src_strd
  *  quantization buffer stride
  *
  * @param[in] pred_strd,
  *  Prediction buffer stride
  *
  * @param[in] out_strd
  *  recon buffer Stride
  *
  * @param[in] pu2_scaling_list
  *  pointer to scaling list
  *
  * @param[in] pu2_norm_adjust
  *  pointer to inverse scale matrix
  *
  * @param[in] u4_qp_div_6
  *  Floor (qp/6)
  *
  * @param[in] pi4_tmp
  * temporary buffer of size 1*16
  *
  * @returns none
  *
  * @remarks none
  *
  *******************************************************************************
  */
 void ih264_iquant_itrans_recon_chroma_4x4_sse42(WORD16 *pi2_src,
                                    UWORD8 *pu1_pred,
                                    UWORD8 *pu1_out,
                                    WORD32 pred_strd,
                                    WORD32 out_strd,
                                    const UWORD16 *pu2_iscal_mat,
                                    const UWORD16 *pu2_weigh_mat,
                                    UWORD32 u4_qp_div_6,
                                    WORD16 *pi2_tmp,
                                    WORD16 *pi2_dc_ld_addr)
  {
     __m128i src_r0_r1, src_r2_r3;
     __m128i src_r0, src_r1, src_r2, src_r3;
     __m128i scalemat_r0_r1, scalemat_r2_r3;
     __m128i pred_r0, pred_r1, pred_r2, pred_r3;
     __m128i sign_reg, dequant_r0_r1, dequant_r2_r3;
     __m128i zero_8x16b = _mm_setzero_si128();          // all bits reset to zero
     __m128i temp0, temp1, temp2, temp3, temp4, temp5, temp6, temp7;
     __m128i resq_r0, resq_r1, resq_r2, resq_r3;
-    __m128i add_rshift = _mm_set1_epi32((1 << (3 - u4_qp_div_6)));
+    __m128i add_rshift = _mm_set1_epi32((u4_qp_div_6 < 4) ? (1 << (3 - u4_qp_div_6)) : 0);
     __m128i value_32 = _mm_set1_epi32(32);
     __m128i chroma_mask = _mm_set1_epi16 (0xFF);
     __m128i out_r0, out_r1, out_r2, out_r3;
     UNUSED (pi2_tmp);
 
     /*************************************************************/
     /* Dequantization of coefficients. Will be replaced by SIMD  */
     /* operations on platform                                    */
     /*************************************************************/
     src_r0_r1 = _mm_loadu_si128((__m128i *) (pi2_src)); //a00 a01 a02 a03 a10 a11 a12 a13 -- the source matrix 0th,1st row
     src_r2_r3 = _mm_loadu_si128((__m128i *) (pi2_src + 8)); //a20 a21 a22 a23 a30 a31 a32 a33 -- the source matrix 2nd,3rd row
     scalemat_r0_r1 = _mm_loadu_si128((__m128i *) (pu2_iscal_mat)); //b00 b01 b02 b03 b10 b11 b12 b13 -- the scaling matrix 0th,1st row
     scalemat_r2_r3 = _mm_loadu_si128((__m128i *) (pu2_iscal_mat + 8)); //b20 b21 b22 b23 b30 b31 b32 b33 -- the scaling matrix 2nd,3rd row
     dequant_r0_r1 = _mm_loadu_si128((__m128i *) (pu2_weigh_mat)); //q00 q01 q02 q03 q10 q11 q12 q13 -- all 16 bits
     dequant_r2_r3 = _mm_loadu_si128((__m128i *) (pu2_weigh_mat + 8)); //q20 q21 q22 q23 q30 q31 q32 q33 -- all 16 bits
 
     temp0 = _mm_mullo_epi16(scalemat_r0_r1, dequant_r0_r1); //b00*q00 b01*q01 b02*q02 b03*q03 b10*q10 b11*q11 b12*q12 b13*q13 -- 16 bit result
     temp1 = _mm_mullo_epi16(scalemat_r2_r3, dequant_r2_r3); //b00*q00 b01*q01 b02*q02 b03*q03 b10*q10 b11*q11 b12*q12 b13*q13 -- 16 bit result
 
     temp4 = _mm_unpacklo_epi16(temp0, zero_8x16b); // b00*q00 0 b01*q01 0 b02*q02 0 b03*q03 0 -- 16 bit long
     temp5 = _mm_unpackhi_epi16(temp0, zero_8x16b); // b10*q10 0 b11*q11 0 b12*q12 0 b13*q13 0 -- 16 bit long
     temp6 = _mm_unpacklo_epi16(temp1, zero_8x16b); // b00*q00 0 b01*q01 0 b02*q02 0 b03*q03 0 -- 16 bit long
     temp7 = _mm_unpackhi_epi16(temp1, zero_8x16b); // b10*q10 0 b11*q11 0 b12*q12 0 b13*q13 0 -- 16 bit long
 
     src_r0 = _mm_unpacklo_epi16(src_r0_r1, zero_8x16b); // a00 0 a01 0 a02 0 a03 0 -- 16 bit long
     src_r1 = _mm_unpackhi_epi16(src_r0_r1, zero_8x16b); // a10 0 a11 0 a12 0 a13 0 -- 16 bit long
     src_r2 = _mm_unpacklo_epi16(src_r2_r3, zero_8x16b); // a20 0 a21 0 a22 0 a23 0 -- 16 bit long
     src_r3 = _mm_unpackhi_epi16(src_r2_r3, zero_8x16b); // a30 0 a31 0 a32 0 a33 0 -- 16 bit long
 
     temp4 = _mm_madd_epi16(src_r0, temp4); //a00*b00*q00 a10*b10*q10 a20*b20*q20 a30*b30 q30 -- 32 bits long
     temp5 = _mm_madd_epi16(src_r1, temp5);
     temp6 = _mm_madd_epi16(src_r2, temp6);
     temp7 = _mm_madd_epi16(src_r3, temp7);
 
     if (u4_qp_div_6 >= 4) {
         resq_r0 = _mm_slli_epi32(temp4, u4_qp_div_6 - 4);
         resq_r1 = _mm_slli_epi32(temp5, u4_qp_div_6 - 4);
         resq_r2 = _mm_slli_epi32(temp6, u4_qp_div_6 - 4);
         resq_r3 = _mm_slli_epi32(temp7, u4_qp_div_6 - 4);
     } else {
         temp4 = _mm_add_epi32(temp4, add_rshift);
         temp5 = _mm_add_epi32(temp5, add_rshift);
         temp6 = _mm_add_epi32(temp6, add_rshift);
         temp7 = _mm_add_epi32(temp7, add_rshift);
         resq_r0 = _mm_srai_epi32(temp4, 4 - u4_qp_div_6);
         resq_r1 = _mm_srai_epi32(temp5, 4 - u4_qp_div_6);
         resq_r2 = _mm_srai_epi32(temp6, 4 - u4_qp_div_6);
         resq_r3 = _mm_srai_epi32(temp7, 4 - u4_qp_div_6);
     }
 
     resq_r0 = _mm_insert_epi32(resq_r0,(WORD32)pi2_dc_ld_addr[0],0);
     /* Perform Inverse transform */
     /*-------------------------------------------------------------*/
     /* IDCT [ Horizontal transformation ]                          */
     /*-------------------------------------------------------------*/
     // Matrix transpose
     /*
      *  a0 a1 a2 a3
      *  b0 b1 b2 b3
      *  c0 c1 c2 c3
      *  d0 d1 d2 d3
      */
     temp1 = _mm_unpacklo_epi32(resq_r0, resq_r1);                  //a0 b0 a1 b1
     temp3 = _mm_unpacklo_epi32(resq_r2, resq_r3);                  //c0 d0 c1 d1
     temp2 = _mm_unpackhi_epi32(resq_r0, resq_r1);                  //a2 b2 a3 b3
     temp4 = _mm_unpackhi_epi32(resq_r2, resq_r3);                  //c2 d2 c3 d3
     resq_r0 = _mm_unpacklo_epi64(temp1, temp3);                    //a0 b0 c0 d0
     resq_r1 = _mm_unpackhi_epi64(temp1, temp3);                    //a1 b1 c1 d1
     resq_r2 = _mm_unpacklo_epi64(temp2, temp4);                    //a2 b2 c2 d2
     resq_r3 = _mm_unpackhi_epi64(temp2, temp4);                    //a3 b3 c3 d3
     //Transform starts -- horizontal transform
     /*------------------------------------------------------------------*/
     /* z0 = w0 + w2                                             */
     temp0 = _mm_add_epi32(resq_r0, resq_r2);
     /* z1 = w0 - w2                                             */
     temp1 = _mm_sub_epi32(resq_r0, resq_r2);
     /* z2 = (w1 >> 1) - w3                                      */
     temp2 = _mm_srai_epi32(resq_r1, 1);                         //(w1>>1)
     temp2 = _mm_sub_epi32(temp2, resq_r3);                      //(w1>>1) - w3
     /* z3 = w1 + (w3 >> 1)                                      */
     temp3 = _mm_srai_epi32(resq_r3, 1);                         //(w3>>1) + w1
     temp3 = _mm_add_epi32(temp3, resq_r1);
     /*----------------------------------------------------------*/
     /* x0 = z0 + z3                                             */
     resq_r0 = _mm_add_epi32(temp0, temp3);
     /* x1 = z1 + z2                                             */
     resq_r1 = _mm_add_epi32(temp1, temp2);
     /* x2 = z1 - z2                                             */
     resq_r2 = _mm_sub_epi32(temp1, temp2);
     /* x3 = z0 - z3                                             */
     resq_r3 = _mm_sub_epi32(temp0, temp3);
     // Matrix transpose
     /*
      *  a0 b0 c0 d0
      *  a1 b1 c1 d1
      *  a2 b2 c2 d2
      *  a3 b3 c3 d3
      */
     temp1 = _mm_unpacklo_epi32(resq_r0, resq_r1);                  //a0 a1 b0 b1
     temp3 = _mm_unpacklo_epi32(resq_r2, resq_r3);                  //a2 a3 b2 b3
     temp2 = _mm_unpackhi_epi32(resq_r0, resq_r1);                  //c0 c1 d0 d1
     temp4 = _mm_unpackhi_epi32(resq_r2, resq_r3);                  //c2 c3 d2 d3
     resq_r0 = _mm_unpacklo_epi64(temp1, temp3);                    //a0 a1 a2 a3
     resq_r1 = _mm_unpackhi_epi64(temp1, temp3);                    //b0 b1 b2 b3
     resq_r2 = _mm_unpacklo_epi64(temp2, temp4);                    //c0 c1 c2 c3
     resq_r3 = _mm_unpackhi_epi64(temp2, temp4);                    //d0 d1 d2 d3
     //Transform ends -- horizontal transform
 
     //Load pred buffer
     pred_r0 = _mm_loadl_epi64((__m128i *) (&pu1_pred[0])); //p00 p01 p02 p03 0 0 0 0 0 0 0 0 -- all 8 bits
     pred_r1 = _mm_loadl_epi64((__m128i *) (&pu1_pred[pred_strd])); //p10 p11 p12 p13 0 0 0 0 0 0 0 0 -- all 8 bits
     pred_r2 = _mm_loadl_epi64((__m128i *) (&pu1_pred[2 * pred_strd])); //p20 p21 p22 p23 0 0 0 0 0 0 0 0 -- all 8 bits
     pred_r3 = _mm_loadl_epi64((__m128i *) (&pu1_pred[3 * pred_strd])); //p30 p31 p32 p33 0 0 0 0 0 0 0 0 -- all 8 bits
 
     pred_r0 = _mm_and_si128(pred_r0, chroma_mask);
     pred_r1 = _mm_and_si128(pred_r1, chroma_mask);
     pred_r2 = _mm_and_si128(pred_r2, chroma_mask);
     pred_r3 = _mm_and_si128(pred_r3, chroma_mask);
 
     pred_r0 = _mm_cvtepu16_epi32(pred_r0); //p00 p01 p02 p03 -- all 32 bits
     pred_r1 = _mm_cvtepu16_epi32(pred_r1); //p10 p11 p12 p13 -- all 32 bits
     pred_r2 = _mm_cvtepu16_epi32(pred_r2); //p20 p21 p22 p23 -- all 32 bits
     pred_r3 = _mm_cvtepu16_epi32(pred_r3); //p30 p31 p32 p33 -- all 32 bits
 
     /*--------------------------------------------------------------*/
     /* IDCT [ Vertical transformation] and Xij = (xij + 32)>>6      */
     /*                                                              */
     /* Add the prediction and store it back to same buffer          */
     /*--------------------------------------------------------------*/
     /* z0j = y0j + y2j                                                        */
     temp0 = _mm_add_epi32(resq_r0, resq_r2);
     /* z1j = y0j - y2j                                                        */
     temp1 = _mm_sub_epi32(resq_r0, resq_r2);
     /* z2j = (y1j>>1) - y3j                                                        */
     temp2 = _mm_srai_epi32(resq_r1, 1);                             //(y1j>>1)
     temp2 = _mm_sub_epi32(temp2, resq_r3);
     /* z3j = y1j + (y3j>>1)                                                        */
     temp3 = _mm_srai_epi32(resq_r3, 1);                             //(y3j>>1)
     temp3 = _mm_add_epi32(temp3, resq_r1);
 
     /* x0j = z0j + z3j                                                        */
     temp4 = _mm_add_epi32(temp0, temp3);
     temp4 = _mm_add_epi32(temp4, value_32);
     temp4 = _mm_srai_epi32(temp4, 6);
     temp4 = _mm_add_epi32(temp4, pred_r0);
     /* x1j = z1j + z2j                                                        */
     temp5 = _mm_add_epi32(temp1, temp2);
     temp5 = _mm_add_epi32(temp5, value_32);
     temp5 = _mm_srai_epi32(temp5, 6);
     temp5 = _mm_add_epi32(temp5, pred_r1);
     /* x2j = z1j - z2j                                                        */
     temp6 = _mm_sub_epi32(temp1, temp2);
     temp6 = _mm_add_epi32(temp6, value_32);
     temp6 = _mm_srai_epi32(temp6, 6);
     temp6 = _mm_add_epi32(temp6, pred_r2);
     /* x3j = z0j - z3j                                                        */
     temp7 = _mm_sub_epi32(temp0, temp3);
     temp7 = _mm_add_epi32(temp7, value_32);
     temp7 = _mm_srai_epi32(temp7, 6);
     temp7 = _mm_add_epi32(temp7, pred_r3);
 
     // 32-bit to 16-bit conversion
     temp0 = _mm_packs_epi32(temp4, temp5);
     temp1 = _mm_packs_epi32(temp6, temp7);
     /*------------------------------------------------------------------*/
     //Clipping the results to 8 bits
     sign_reg = _mm_cmpgt_epi16(temp0, zero_8x16b);      // sign check
     temp0 = _mm_and_si128(temp0, sign_reg);
     sign_reg = _mm_cmpgt_epi16(temp1, zero_8x16b);
     temp1 = _mm_and_si128(temp1, sign_reg);
 
     resq_r0 = _mm_packus_epi16(temp0, temp1);
     resq_r1 = _mm_srli_si128(resq_r0, 4);
     resq_r2 = _mm_srli_si128(resq_r1, 4);
     resq_r3 = _mm_srli_si128(resq_r2, 4);
 
     resq_r0 = _mm_cvtepu8_epi16(resq_r0); //p00 p01 p02 p03 -- all 16 bits
     resq_r1 = _mm_cvtepu8_epi16(resq_r1); //p10 p11 p12 p13 -- all 16 bits
     resq_r2 = _mm_cvtepu8_epi16(resq_r2); //p20 p21 p22 p23 -- all 16 bits
     resq_r3 = _mm_cvtepu8_epi16(resq_r3); //p30 p31 p32 p33 -- all 16 bits
 
     chroma_mask = _mm_set1_epi16 (0xFF00);
     out_r0 = _mm_loadl_epi64((__m128i *) (&pu1_out[0]));
     out_r1 = _mm_loadl_epi64((__m128i *) (&pu1_out[out_strd]));
     out_r2 = _mm_loadl_epi64((__m128i *) (&pu1_out[2 * out_strd]));
     out_r3 = _mm_loadl_epi64((__m128i *) (&pu1_out[3 * out_strd]));
 
     out_r0 = _mm_and_si128(out_r0, chroma_mask);
     out_r1 = _mm_and_si128(out_r1, chroma_mask);
     out_r2 = _mm_and_si128(out_r2, chroma_mask);
     out_r3 = _mm_and_si128(out_r3, chroma_mask);
 
     out_r0 = _mm_add_epi8(out_r0, resq_r0);
     out_r1 = _mm_add_epi8(out_r1, resq_r1);
     out_r2 = _mm_add_epi8(out_r2, resq_r2);
     out_r3 = _mm_add_epi8(out_r3, resq_r3);
 
     _mm_storel_epi64((__m128i *)(&pu1_out[0]), out_r0);
     _mm_storel_epi64((__m128i *)(&pu1_out[out_strd]), out_r1);
     _mm_storel_epi64((__m128i *)(&pu1_out[2 * out_strd]), out_r2);
     _mm_storel_epi64((__m128i *)(&pu1_out[3 * out_strd]), out_r3);
 }
diff --git a/common/x86/ih264_iquant_itrans_recon_ssse3.c b/common/x86/ih264_iquant_itrans_recon_ssse3.c
index 30f7e59..506be49 100644
--- a/common/x86/ih264_iquant_itrans_recon_ssse3.c
+++ b/common/x86/ih264_iquant_itrans_recon_ssse3.c
@@ -53,315 +53,315 @@
 /*
  ********************************************************************************
  *
  * @brief This function reconstructs a 4x4 sub block from quantized resiude and
  * prediction buffer
  *
  * @par Description:
  *  The quantized residue is first inverse quantized, then inverse transformed.
  *  This inverse transformed content is added to the prediction buffer to recon-
  *  struct the end output
  *
  * @param[in] pi2_src
  *  quantized 4x4 block
  *
  * @param[in] pu1_pred
  *  prediction 4x4 block
  *
  * @param[out] pu1_out
  *  reconstructed 4x4 block
  *
  * @param[in] src_strd
  *  quantization buffer stride
  *
  * @param[in] pred_strd,
  *  Prediction buffer stride
  *
  * @param[in] out_strd
  *  recon buffer Stride
  *
  * @param[in] pu2_scaling_list
  *  pointer to scaling list
  *
  * @param[in] pu2_norm_adjust
  *  pointer to inverse scale matrix
  *
  * @param[in] u4_qp_div_6
  *  Floor (qp/6)
  *
  * @param[in] pi4_tmp
  * temporary buffer of size 1*16
  *
  * @returns none
  *
  * @remarks none
  *
  *******************************************************************************
  */
 void ih264_iquant_itrans_recon_4x4_ssse3(WORD16 *pi2_src,
                                          UWORD8 *pu1_pred,
                                          UWORD8 *pu1_out,
                                          WORD32 pred_strd,
                                          WORD32 out_strd,
                                          const UWORD16 *pu2_iscal_mat,
                                          const UWORD16 *pu2_weigh_mat,
                                          UWORD32 u4_qp_div_6,
                                          WORD16 *pi2_tmp,
                                          WORD32 iq_start_idx,
                                          WORD16 *pi2_dc_ld_addr)
 {
     UWORD32 *pu4_out = (UWORD32 *) pu1_out;
     __m128i src_r0_r1, src_r2_r3;
     __m128i src_r0, src_r1, src_r2, src_r3;
     __m128i scalemat_r0_r1, scalemat_r2_r3, predload_r;
     __m128i pred_r0, pred_r1, pred_r2, pred_r3;
     __m128i sign_reg, dequant_r0_r1, dequant_r2_r3;
     __m128i zero_8x16b = _mm_setzero_si128();          // all bits reset to zero
     __m128i temp0, temp1, temp2, temp3, temp4, temp5, temp6, temp7;
     __m128i resq_r0, resq_r1, resq_r2, resq_r3;
-    __m128i add_rshift = _mm_set1_epi32((1 << (3 - u4_qp_div_6)));
+    __m128i add_rshift = _mm_set1_epi32((u4_qp_div_6 < 4) ? (1 << (3 - u4_qp_div_6)) : 0);
     __m128i value_32 = _mm_set1_epi32(32);
     UNUSED (pi2_tmp);
     UNUSED (pi2_dc_ld_addr);
 
     /*************************************************************/
     /* Dequantization of coefficients. Will be replaced by SIMD  */
     /* operations on platform                                    */
     /*************************************************************/
     src_r0_r1 = _mm_loadu_si128((__m128i *) (pi2_src)); //a00 a01 a02 a03 a10 a11 a12 a13 -- the source matrix 0th,1st row
     src_r2_r3 = _mm_loadu_si128((__m128i *) (pi2_src + 8)); //a20 a21 a22 a23 a30 a31 a32 a33 -- the source matrix 2nd,3rd row
     scalemat_r0_r1 = _mm_loadu_si128((__m128i *) (pu2_iscal_mat)); //b00 b01 b02 b03 b10 b11 b12 b13 -- the scaling matrix 0th,1st row
     scalemat_r2_r3 = _mm_loadu_si128((__m128i *) (pu2_iscal_mat + 8)); //b20 b21 b22 b23 b30 b31 b32 b33 -- the scaling matrix 2nd,3rd row
     dequant_r0_r1 = _mm_loadu_si128((__m128i *) (pu2_weigh_mat)); //q00 q01 q02 q03 q10 q11 q12 q13 -- all 16 bits
     dequant_r2_r3 = _mm_loadu_si128((__m128i *) (pu2_weigh_mat + 8)); //q20 q21 q22 q23 q30 q31 q32 q33 -- all 16 bits
 
     temp0 = _mm_mullo_epi16(scalemat_r0_r1, dequant_r0_r1); //b00*q00 b01*q01 b02*q02 b03*q03 b10*q10 b11*q11 b12*q12 b13*q13 -- 16 bit result
     temp1 = _mm_mullo_epi16(scalemat_r2_r3, dequant_r2_r3); //b00*q00 b01*q01 b02*q02 b03*q03 b10*q10 b11*q11 b12*q12 b13*q13 -- 16 bit result
 
     temp4 = _mm_unpacklo_epi16(temp0, zero_8x16b); // b00*q00 0 b01*q01 0 b02*q02 0 b03*q03 0 -- 16 bit long
     temp5 = _mm_unpackhi_epi16(temp0, zero_8x16b); // b10*q10 0 b11*q11 0 b12*q12 0 b13*q13 0 -- 16 bit long
     temp6 = _mm_unpacklo_epi16(temp1, zero_8x16b); // b00*q00 0 b01*q01 0 b02*q02 0 b03*q03 0 -- 16 bit long
     temp7 = _mm_unpackhi_epi16(temp1, zero_8x16b); // b10*q10 0 b11*q11 0 b12*q12 0 b13*q13 0 -- 16 bit long
 
     src_r0 = _mm_unpacklo_epi16(src_r0_r1, zero_8x16b); // a00 0 a01 0 a02 0 a03 0 -- 16 bit long
     src_r1 = _mm_unpackhi_epi16(src_r0_r1, zero_8x16b); // a10 0 a11 0 a12 0 a13 0 -- 16 bit long
     src_r2 = _mm_unpacklo_epi16(src_r2_r3, zero_8x16b); // a20 0 a21 0 a22 0 a23 0 -- 16 bit long
     src_r3 = _mm_unpackhi_epi16(src_r2_r3, zero_8x16b); // a30 0 a31 0 a32 0 a33 0 -- 16 bit long
 
     temp4 = _mm_madd_epi16(src_r0, temp4); //a00*b00*q00 a10*b10*q10 a20*b20*q20 a30*b30 q30 -- 32 bits long
     temp5 = _mm_madd_epi16(src_r1, temp5);
     temp6 = _mm_madd_epi16(src_r2, temp6);
     temp7 = _mm_madd_epi16(src_r3, temp7);
 
     if (u4_qp_div_6 >= 4) {
         resq_r0 = _mm_slli_epi32(temp4, u4_qp_div_6 - 4);
         resq_r1 = _mm_slli_epi32(temp5, u4_qp_div_6 - 4);
         resq_r2 = _mm_slli_epi32(temp6, u4_qp_div_6 - 4);
         resq_r3 = _mm_slli_epi32(temp7, u4_qp_div_6 - 4);
     } else {
         temp4 = _mm_add_epi32(temp4, add_rshift);
         temp5 = _mm_add_epi32(temp5, add_rshift);
         temp6 = _mm_add_epi32(temp6, add_rshift);
         temp7 = _mm_add_epi32(temp7, add_rshift);
         resq_r0 = _mm_srai_epi32(temp4, 4 - u4_qp_div_6);
         resq_r1 = _mm_srai_epi32(temp5, 4 - u4_qp_div_6);
         resq_r2 = _mm_srai_epi32(temp6, 4 - u4_qp_div_6);
         resq_r3 = _mm_srai_epi32(temp7, 4 - u4_qp_div_6);
     }
 
     if (iq_start_idx == 1)
     {
         resq_r0 = _mm_insert_epi16(resq_r0,(WORD32)pi2_src[0],0);
         if (pi2_src[0] >= 0)
             resq_r0 = _mm_insert_epi16(resq_r0,0,1);
         else
             resq_r0 = _mm_insert_epi16(resq_r0,-1,1);
     }
     /* Perform Inverse transform */
     /*-------------------------------------------------------------*/
     /* IDCT [ Horizontal transformation ]                          */
     /*-------------------------------------------------------------*/
     // Matrix transpose
     /*
      *  a0 a1 a2 a3
      *  b0 b1 b2 b3
      *  c0 c1 c2 c3
      *  d0 d1 d2 d3
      */
     temp1 = _mm_unpacklo_epi32(resq_r0, resq_r1);                  //a0 b0 a1 b1
     temp3 = _mm_unpacklo_epi32(resq_r2, resq_r3);                  //c0 d0 c1 d1
     temp2 = _mm_unpackhi_epi32(resq_r0, resq_r1);                  //a2 b2 a3 b3
     temp4 = _mm_unpackhi_epi32(resq_r2, resq_r3);                  //c2 d2 c3 d3
     resq_r0 = _mm_unpacklo_epi64(temp1, temp3);                    //a0 b0 c0 d0
     resq_r1 = _mm_unpackhi_epi64(temp1, temp3);                    //a1 b1 c1 d1
     resq_r2 = _mm_unpacklo_epi64(temp2, temp4);                    //a2 b2 c2 d2
     resq_r3 = _mm_unpackhi_epi64(temp2, temp4);                    //a3 b3 c3 d3
     //Transform starts -- horizontal transform
     /*------------------------------------------------------------------*/
     /* z0 = w0 + w2                                             */
     temp0 = _mm_add_epi32(resq_r0, resq_r2);
     /* z1 = w0 - w2                                             */
     temp1 = _mm_sub_epi32(resq_r0, resq_r2);
     /* z2 = (w1 >> 1) - w3                                      */
     temp2 = _mm_srai_epi32(resq_r1, 1);                         //(w1>>1)
     temp2 = _mm_sub_epi32(temp2, resq_r3);                      //(w1>>1) - w3
     /* z3 = w1 + (w3 >> 1)                                      */
     temp3 = _mm_srai_epi32(resq_r3, 1);                         //(w3>>1) + w1
     temp3 = _mm_add_epi32(temp3, resq_r1);
     /*----------------------------------------------------------*/
     /* x0 = z0 + z3                                             */
     resq_r0 = _mm_add_epi32(temp0, temp3);
     /* x1 = z1 + z2                                             */
     resq_r1 = _mm_add_epi32(temp1, temp2);
     /* x2 = z1 - z2                                             */
     resq_r2 = _mm_sub_epi32(temp1, temp2);
     /* x3 = z0 - z3                                             */
     resq_r3 = _mm_sub_epi32(temp0, temp3);
     // Matrix transpose
     /*
      *  a0 b0 c0 d0
      *  a1 b1 c1 d1
      *  a2 b2 c2 d2
      *  a3 b3 c3 d3
      */
     temp1 = _mm_unpacklo_epi32(resq_r0, resq_r1);                  //a0 a1 b0 b1
     temp3 = _mm_unpacklo_epi32(resq_r2, resq_r3);                  //a2 a3 b2 b3
     temp2 = _mm_unpackhi_epi32(resq_r0, resq_r1);                  //c0 c1 d0 d1
     temp4 = _mm_unpackhi_epi32(resq_r2, resq_r3);                  //c2 c3 d2 d3
     resq_r0 = _mm_unpacklo_epi64(temp1, temp3);                    //a0 a1 a2 a3
     resq_r1 = _mm_unpackhi_epi64(temp1, temp3);                    //b0 b1 b2 b3
     resq_r2 = _mm_unpacklo_epi64(temp2, temp4);                    //c0 c1 c2 c3
     resq_r3 = _mm_unpackhi_epi64(temp2, temp4);                    //d0 d1 d2 d3
     //Transform ends -- horizontal transform
 
     zero_8x16b = _mm_setzero_si128();                  // all bits reset to zero
     //Load pred buffer
     predload_r = _mm_loadl_epi64((__m128i *) (&pu1_pred[0])); //p00 p01 p02 p03 0 0 0 0 0 0 0 0 -- all 8 bits
     pred_r0 = _mm_unpacklo_epi8(predload_r, zero_8x16b); //p00 p01 p02 p03 0 0 0 0 -- all 16 bits
 
     predload_r = _mm_loadl_epi64((__m128i *) (&pu1_pred[pred_strd])); //p10 p11 p12 p13 0 0 0 0 0 0 0 0 -- all 8 bits
     pred_r1 = _mm_unpacklo_epi8(predload_r, zero_8x16b); //p10 p11 p12 p13 0 0 0 0 -- all 16 bits
 
     predload_r = _mm_loadl_epi64((__m128i *) (&pu1_pred[2 * pred_strd])); //p20 p21 p22 p23 0 0 0 0 0 0 0 0 -- all 8 bits
     pred_r2 = _mm_unpacklo_epi8(predload_r, zero_8x16b); //p20 p21 p22 p23 0 0 0 0 -- all 16 bits
 
     predload_r = _mm_loadl_epi64((__m128i *) (&pu1_pred[3 * pred_strd])); //p30 p31 p32 p33 0 0 0 0 0 0 0 0 -- all 8 bits
     pred_r3 = _mm_unpacklo_epi8(predload_r, zero_8x16b); //p30 p31 p32 p33 0 0 0 0 -- all 16 bits
     pred_r0 = _mm_unpacklo_epi16(pred_r0, zero_8x16b); //p00 p01 p02 p03 -- 32 bits sign extended
     pred_r1 = _mm_unpacklo_epi16(pred_r1, zero_8x16b); //p10 p11 p12 p13 -- 32 bits sign extended
     pred_r2 = _mm_unpacklo_epi16(pred_r2, zero_8x16b); //p20 p21 p22 p23 -- 32 bits sign extended
     pred_r3 = _mm_unpacklo_epi16(pred_r3, zero_8x16b); //p30 p31 p32 p33 -- 32 bits sign extended
 
     /*--------------------------------------------------------------*/
     /* IDCT [ Vertical transformation] and Xij = (xij + 32)>>6      */
     /*                                                              */
     /* Add the prediction and store it back to same buffer          */
     /*--------------------------------------------------------------*/
     /* z0j = y0j + y2j                                                        */
     temp0 = _mm_add_epi32(resq_r0, resq_r2);
     /* z1j = y0j - y2j                                                        */
     temp1 = _mm_sub_epi32(resq_r0, resq_r2);
     /* z2j = (y1j>>1) - y3j                                                        */
     temp2 = _mm_srai_epi32(resq_r1, 1);                             //(y1j>>1)
     temp2 = _mm_sub_epi32(temp2, resq_r3);
     /* z3j = y1j + (y3j>>1)                                                        */
     temp3 = _mm_srai_epi32(resq_r3, 1);                             //(y3j>>1)
     temp3 = _mm_add_epi32(temp3, resq_r1);
 
     /* x0j = z0j + z3j                                                        */
     temp4 = _mm_add_epi32(temp0, temp3);
     temp4 = _mm_add_epi32(temp4, value_32);
     temp4 = _mm_srai_epi32(temp4, 6);
     temp4 = _mm_add_epi32(temp4, pred_r0);
     /* x1j = z1j + z2j                                                        */
     temp5 = _mm_add_epi32(temp1, temp2);
     temp5 = _mm_add_epi32(temp5, value_32);
     temp5 = _mm_srai_epi32(temp5, 6);
     temp5 = _mm_add_epi32(temp5, pred_r1);
     /* x2j = z1j - z2j                                                        */
     temp6 = _mm_sub_epi32(temp1, temp2);
     temp6 = _mm_add_epi32(temp6, value_32);
     temp6 = _mm_srai_epi32(temp6, 6);
     temp6 = _mm_add_epi32(temp6, pred_r2);
     /* x3j = z0j - z3j                                                        */
     temp7 = _mm_sub_epi32(temp0, temp3);
     temp7 = _mm_add_epi32(temp7, value_32);
     temp7 = _mm_srai_epi32(temp7, 6);
     temp7 = _mm_add_epi32(temp7, pred_r3);
 
     // 32-bit to 16-bit conversion
     temp0 = _mm_packs_epi32(temp4, temp5);
     temp1 = _mm_packs_epi32(temp6, temp7);
     /*------------------------------------------------------------------*/
     //Clipping the results to 8 bits
     sign_reg = _mm_cmpgt_epi16(temp0, zero_8x16b);      // sign check
     temp0 = _mm_and_si128(temp0, sign_reg);
     sign_reg = _mm_cmpgt_epi16(temp1, zero_8x16b);
     temp1 = _mm_and_si128(temp1, sign_reg);
 
     resq_r0 = _mm_packus_epi16(temp0, temp1);
     resq_r1 = _mm_srli_si128(resq_r0, 4);
     resq_r2 = _mm_srli_si128(resq_r1, 4);
     resq_r3 = _mm_srli_si128(resq_r2, 4);
 
     *pu4_out = _mm_cvtsi128_si32(resq_r0);
     pu1_out += out_strd;
     pu4_out = (UWORD32 *) (pu1_out);
     *(pu4_out) = _mm_cvtsi128_si32(resq_r1);
     pu1_out += out_strd;
     pu4_out = (UWORD32 *) (pu1_out);
     *(pu4_out) = _mm_cvtsi128_si32(resq_r2);
     pu1_out += out_strd;
     pu4_out = (UWORD32 *) (pu1_out);
     *(pu4_out) = _mm_cvtsi128_si32(resq_r3);
 }
 /**
  *******************************************************************************
  *
  * @brief
  *  This function performs inverse quant and Inverse transform type Ci4 for 8x8 block
  *
  * @par Description:
  *  Performs inverse transform Ci8 and adds the residue to get the
  *  reconstructed block
  *
  * @param[in] pi2_src
  *  Input 8x8coefficients
  *
  * @param[in] pu1_pred
  *  Prediction 8x8 block
  *
  * @param[out] pu1_recon
  *  Output 8x8 block
  *
  * @param[in] q_div
  *  QP/6
  *
  * @param[in] q_rem
  *  QP%6
  *
  * @param[in] q_lev
  *  Quantizer level
  *
  * @param[in] u4_src_stride
  *  Input stride
  *
  * @param[in] u4_pred_stride,
  *  Prediction stride
  *
  * @param[in] u4_out_stride
  *  Output Stride
  *
  * @param[in] pi4_tmp
  *  temporary buffer of size 1*64
  *  the tmp for each block
  *
  * @param[in] pu4_iquant_mat
  *  Pointer to the inverse quantization matrix
  *
  * @returns  Void
  *
  * @remarks
  *  None
  *
  *******************************************************************************
  */
@@ -369,672 +369,672 @@ void ih264_iquant_itrans_recon_4x4_ssse3(WORD16 *pi2_src,
 void ih264_iquant_itrans_recon_8x8_ssse3(WORD16 *pi2_src,
                                          UWORD8 *pu1_pred,
                                          UWORD8 *pu1_out,
                                          WORD32 pred_strd,
                                          WORD32 out_strd,
                                          const UWORD16 *pu2_iscale_mat,
                                          const UWORD16 *pu2_weigh_mat,
                                          UWORD32 qp_div,
                                          WORD16 *pi2_tmp,
                                          WORD32 iq_start_idx,
                                          WORD16 *pi2_dc_ld_addr)
 {
     __m128i src_r0;
     __m128i scalemat_r0;
     __m128i zero_8x16b = _mm_setzero_si128(); // all bits reset to zero
     // __m128i one_8x16b = _mm_set1_epi8(255); // all bits set to 1
     // __m128i one_zero_mask = _mm_unpacklo_epi16(one_8x16b, zero_8x16b); // 1 0 1 0 1 0 1 0 --- 16 bits size
     __m128i value_32 = _mm_set1_epi32(32);
-    __m128i add_rshift = _mm_set1_epi32((1 << (5 - qp_div)));
+    __m128i add_rshift = _mm_set1_epi32((qp_div < 6) ? (1 << (5 - qp_div)) : 0);
     __m128i dequant_r0;
     __m128i predload_r;
     __m128i pred_r0_1, pred_r1_1, pred_r2_1, pred_r3_1, pred_r4_1, pred_r5_1,
             pred_r6_1, pred_r7_1;
     __m128i sign_reg;
     __m128i src_r0_1, src_r0_2;
     __m128i scalemat_r0_1, scalemat_r0_2;
     __m128i temp1, temp2, temp3, temp4, temp5, temp6, temp7, temp8;
     __m128i temp10, temp11, temp12, temp13, temp14, temp15, temp16, temp17,
             temp18, temp19, temp20;
     // To store dequantization results
     __m128i resq_r0_1, resq_r0_2, resq_r1_1, resq_r1_2, resq_r2_1, resq_r2_2,
             resq_r3_1, resq_r3_2, resq_r4_1, resq_r4_2, resq_r5_1, resq_r5_2,
             resq_r6_1, resq_r6_2, resq_r7_1, resq_r7_2;
     UNUSED (pi2_tmp);
     UNUSED (iq_start_idx);
     UNUSED (pi2_dc_ld_addr);
 
     /*************************************************************/
     /* Dequantization of coefficients. Will be replaced by SIMD  */
     /* operations on platform. Note : DC coeff is not scaled     */
     /*************************************************************/
 
     // Row 0 processing
     src_r0 = _mm_loadu_si128((__m128i *) (pi2_src)); //a00 a01 a02 a03 a04 a05 a06 a07 -- the source matrix 0th row
     scalemat_r0 = _mm_loadu_si128((__m128i *) (pu2_iscale_mat)); //b00 b01 b02 b03 b04 b05 b06 b07 -- the scaling matrix 0th row
     dequant_r0 = _mm_loadu_si128((__m128i *) (&pu2_weigh_mat[0])); //q0 q1 q2 q3 q4 q5 q6 q7 -- all 16 bits
     src_r0_1 = _mm_unpacklo_epi16(src_r0, zero_8x16b); //a00 0 a01 0 a02 0 a03 0 -- 16 bit long
     src_r0_2 = _mm_unpackhi_epi16(src_r0, zero_8x16b); // a04 0 a05 0 a06 0 a07 0 -- 16 bit long
     temp10 = _mm_mullo_epi16(scalemat_r0, dequant_r0); //b00*q0 b01*q1 b02*q2 b03*q3 b04*q4 b05*q5 b06*q6 b07*q7 -- 16 bit result
     scalemat_r0_1 = _mm_unpacklo_epi16(temp10, zero_8x16b); // b00*q0 0 b01*q1 0 b02*q2 0 b03*q3 0 -- 16 bit long
     scalemat_r0_2 = _mm_unpackhi_epi16(temp10, zero_8x16b); // b04*q4 0 b05*q5 0 b06*q6 0 b07*q7 0 -- 16 bit long
 
     temp5 = _mm_madd_epi16(src_r0_1, scalemat_r0_1); // a00*b00*q0 a01*b01*q1 a02*b02*q2 a03*b03*q3 -- 32 bits long
     temp7 = _mm_madd_epi16(src_r0_2, scalemat_r0_2); // a04*b04*q4 a05*b05*q5 a06*b06*q6 a07*b07*q7 -- 32 bits long
 
     if (qp_div >= 6) {
         resq_r0_1 = _mm_slli_epi32(temp5, qp_div - 6);
         resq_r0_2 = _mm_slli_epi32(temp7, qp_div - 6);
     } else {
         temp5 = _mm_add_epi32(temp5, add_rshift);
         temp7 = _mm_add_epi32(temp7, add_rshift);
         resq_r0_1 = _mm_srai_epi32(temp5, 6 - qp_div);
         resq_r0_2 = _mm_srai_epi32(temp7, 6 - qp_div);
     }
     resq_r0_1 = _mm_packs_epi32(resq_r0_1, resq_r0_2); //a00*b00*q0 a01*b01*q1 a02*b02*q2 a03*b03*q3 a04*b04*q4 a05*b05*q5 a06*b06*q6 a07*b07*q7 -- 16 bit long
     // Row 1 processing
     src_r0 = _mm_loadu_si128((__m128i *) (pi2_src + 8)); //a00 a01 a02 a03 a04 a05 a06 a07 a08 -- the source matrix 1st row
     scalemat_r0 = _mm_loadu_si128((__m128i *) (pu2_iscale_mat + 8)); //b00 b01 b02 b03 b04 b05 b06 b07 b08 -- the scaling matrix 1st row
     dequant_r0 = _mm_loadu_si128((__m128i *) (&pu2_weigh_mat[8])); //q0 q1 q2 q3 q4 q5 q6 q7 -- all 16 bits
     src_r0_1 = _mm_unpacklo_epi16(src_r0, zero_8x16b); //a00 0 a01 0 a02 0 a03 0 -- 16 bit long
     src_r0_2 = _mm_unpackhi_epi16(src_r0, zero_8x16b); // a04 0 a05 0 a06 0 a07 0 -- 16 bit long
     temp10 = _mm_mullo_epi16(scalemat_r0, dequant_r0); //b00*q0 b01*q1 b02*q2 b03*q3 b04*q4 b05*q5 b06*q6 b07*q7 -- 16 bit result
     scalemat_r0_1 = _mm_unpacklo_epi16(temp10, zero_8x16b); // b00*q0 0 b01*q1 0 b02*q2 0 b03*q3 0 -- 16 bit long
     scalemat_r0_2 = _mm_unpackhi_epi16(temp10, zero_8x16b); // b04*q4 0 b05*q5 0 b06*q6 0 b07*q7 0 -- 16 bit long
     temp5 = _mm_madd_epi16(src_r0_1, scalemat_r0_1); // a00*b00*q0 a01*b01*q1 a02*b02*q2 a03*b03*q3 -- 32 bits long
     temp7 = _mm_madd_epi16(src_r0_2, scalemat_r0_2); // a04*b04*q4 a05*b05*q5 a06*b06*q6 a07*b07*q7 -- 32 bits long
     if (qp_div >= 6) {
         resq_r1_1 = _mm_slli_epi32(temp5, qp_div - 6);
         resq_r1_2 = _mm_slli_epi32(temp7, qp_div - 6);
     } else {
         temp5 = _mm_add_epi32(temp5, add_rshift);
         temp7 = _mm_add_epi32(temp7, add_rshift);
         resq_r1_1 = _mm_srai_epi32(temp5, 6 - qp_div);
         resq_r1_2 = _mm_srai_epi32(temp7, 6 - qp_div);
     }
     resq_r1_1 = _mm_packs_epi32(resq_r1_1, resq_r1_2); //a00*b00*q0 a01*b01*q1 a02*b02*q2 a03*b03*q3 a04*b04*q4 a05*b05*q5 a06*b06*q6 a07*b07*q7 -- 16 bit long
     // Row 2 processing
     src_r0 = _mm_loadu_si128((__m128i *) (pi2_src + 16)); //a00 a01 a02 a03 a04 a05 a06 a07 a08 -- the source matrix 2nd row
     scalemat_r0 = _mm_loadu_si128((__m128i *) (pu2_iscale_mat + 16)); //b00 b01 b02 b03 b04 b05 b06 b07 b08 -- the scaling matrix 2nd row
     dequant_r0 = _mm_loadu_si128((__m128i *) (&pu2_weigh_mat[16])); //q0 q1 q2 q3 q4 q5 q6 q7 -- all 16 bits
     src_r0_1 = _mm_unpacklo_epi16(src_r0, zero_8x16b); //a00 0 a01 0 a02 0 a03 0 -- 16 bit long
     src_r0_2 = _mm_unpackhi_epi16(src_r0, zero_8x16b); // a04 0 a05 0 a06 0 a07 0 -- 16 bit long
     temp10 = _mm_mullo_epi16(scalemat_r0, dequant_r0); //b00*q0 b01*q1 b02*q2 b03*q3 b04*q4 b05*q5 b06*q6 b07*q7 -- 16 bit result
     scalemat_r0_1 = _mm_unpacklo_epi16(temp10, zero_8x16b); // b00*q0 0 b01*q1 0 b02*q2 0 b03*q3 0 -- 16 bit long
     scalemat_r0_2 = _mm_unpackhi_epi16(temp10, zero_8x16b); // b04*q4 0 b05*q5 0 b06*q6 0 b07*q7 0 -- 16 bit long
     temp5 = _mm_madd_epi16(src_r0_1, scalemat_r0_1); // a00*b00*q0 a01*b01*q1 a02*b02*q2 a03*b03*q3 -- 32 bits long
     temp7 = _mm_madd_epi16(src_r0_2, scalemat_r0_2); // a04*b04*q4 a05*b05*q5 a06*b06*q6 a07*b07*q7 -- 32 bits long
     if (qp_div >= 6) {
         resq_r2_1 = _mm_slli_epi32(temp5, qp_div - 6);
         resq_r2_2 = _mm_slli_epi32(temp7, qp_div - 6);
     } else {
         temp5 = _mm_add_epi32(temp5, add_rshift);
         temp7 = _mm_add_epi32(temp7, add_rshift);
         resq_r2_1 = _mm_srai_epi32(temp5, 6 - qp_div);
         resq_r2_2 = _mm_srai_epi32(temp7, 6 - qp_div);
     }
     resq_r2_1 = _mm_packs_epi32(resq_r2_1, resq_r2_2); //a00*b00*q0 a01*b01*q1 a02*b02*q2 a03*b03*q3 a04*b04*q4 a05*b05*q5 a06*b06*q6 a07*b07*q7 -- 16 bit long
     // Row 3 processing
     src_r0 = _mm_loadu_si128((__m128i *) (pi2_src + 24)); //a00 a01 a02 a03 a04 a05 a06 a07 a08 -- the source matrix 3rd row
     scalemat_r0 = _mm_loadu_si128((__m128i *) (pu2_iscale_mat + 24)); //b00 b01 b02 b03 b04 b05 b06 b07 b08 -- the scaling matrix 3rd row
     dequant_r0 = _mm_loadu_si128((__m128i *) (&pu2_weigh_mat[24])); //q0 q1 q2 q3 q4 q5 q6 q7 -- all 16 bits
     src_r0_1 = _mm_unpacklo_epi16(src_r0, zero_8x16b); //a00 0 a01 0 a02 0 a03 0 -- 16 bit long
     src_r0_2 = _mm_unpackhi_epi16(src_r0, zero_8x16b); // a04 0 a05 0 a06 0 a07 0 -- 16 bit long
     temp10 = _mm_mullo_epi16(scalemat_r0, dequant_r0); //b00*q0 b01*q1 b02*q2 b03*q3 b04*q4 b05*q5 b06*q6 b07*q7 -- 16 bit result
     scalemat_r0_1 = _mm_unpacklo_epi16(temp10, zero_8x16b); // b00*q0 0 b01*q1 0 b02*q2 0 b03*q3 0 -- 16 bit long
     scalemat_r0_2 = _mm_unpackhi_epi16(temp10, zero_8x16b); // b04*q4 0 b05*q5 0 b06*q6 0 b07*q7 0 -- 16 bit long
     temp5 = _mm_madd_epi16(src_r0_1, scalemat_r0_1); // a00*b00*q0 a01*b01*q1 a02*b02*q2 a03*b03*q3 - 32 bits long
     temp7 = _mm_madd_epi16(src_r0_2, scalemat_r0_2); // a04*b04*q4 a05*b05*q5 a06*b06*q6 a07*b07*q7 -- 32 bits long
     if (qp_div >= 6) {
         resq_r3_1 = _mm_slli_epi32(temp5, qp_div - 6);
         resq_r3_2 = _mm_slli_epi32(temp7, qp_div - 6);
     } else {
         temp5 = _mm_add_epi32(temp5, add_rshift);
         temp7 = _mm_add_epi32(temp7, add_rshift);
         resq_r3_1 = _mm_srai_epi32(temp5, 6 - qp_div);
         resq_r3_2 = _mm_srai_epi32(temp7, 6 - qp_div);
     }
     resq_r3_1 = _mm_packs_epi32(resq_r3_1, resq_r3_2); //a00*b00*q0 a01*b01*q1 a02*b02*q2 a03*b03*q3 a04*b04*q4 a05*b05*q5 a06*b06*q6 a07*b07*q7 -- 16 bit long
     // Row 4 processing
     src_r0 = _mm_loadu_si128((__m128i *) (pi2_src + 32)); //a00 a01 a02 a03 a04 a05 a06 a07 a08 -- the source matrix 4th row
     scalemat_r0 = _mm_loadu_si128((__m128i *) (pu2_iscale_mat + 32)); //b00 b01 b02 b03 b04 b05 b06 b07 b08 -- the scaling matrix 4th row
     dequant_r0 = _mm_loadu_si128((__m128i *) (&pu2_weigh_mat[32])); //q0 q1 q2 q3 q4 q5 q6 q7 -- all 16 bits
     src_r0_1 = _mm_unpacklo_epi16(src_r0, zero_8x16b); //a00 0 a01 0 a02 0 a03 0 -- 16 bit long
     src_r0_2 = _mm_unpackhi_epi16(src_r0, zero_8x16b); // a04 0 a05 0 a06 0 a07 0 -- 16 bit long
     temp10 = _mm_mullo_epi16(scalemat_r0, dequant_r0); //b00*q0 b01*q1 b02*q2 b03*q3 b04*q4 b05*q5 b06*q6 b07*q7 -- 16 bit result
     scalemat_r0_1 = _mm_unpacklo_epi16(temp10, zero_8x16b); // b00*q0 0 b01*q1 0 b02*q2 0 b03*q3 0 -- 16 bit long
     scalemat_r0_2 = _mm_unpackhi_epi16(temp10, zero_8x16b); // b04*q4 0 b05*q5 0 b06*q6 0 b07*q7 0 -- 16 bit long
     temp5 = _mm_madd_epi16(src_r0_1, scalemat_r0_1); // a00*b00*q0 a01*b01*q1 a02*b02*q2 a03*b03*q3 -- 32 bits long
     temp7 = _mm_madd_epi16(src_r0_2, scalemat_r0_2); // a04*b04*q4 a05*b05*q5 a06*b06*q6 a07*b07*q7 -- 32 bits long
     if (qp_div >= 6) {
         resq_r4_1 = _mm_slli_epi32(temp5, qp_div - 6);
         resq_r4_2 = _mm_slli_epi32(temp7, qp_div - 6);
 
     } else {
         temp5 = _mm_add_epi32(temp5, add_rshift);
         temp7 = _mm_add_epi32(temp7, add_rshift);
         resq_r4_1 = _mm_srai_epi32(temp5, 6 - qp_div);
         resq_r4_2 = _mm_srai_epi32(temp7, 6 - qp_div);
     }
     resq_r4_1 = _mm_packs_epi32(resq_r4_1, resq_r4_2); //a00*b00*q0 a01*b01*q1 a02*b02*q2 a03*b03*q3 a04*b04*q4 a05*b05*q5 a06*b06*q6 a07*b07*q7 -- 16 bit long
     // Row 5 processing
     src_r0 = _mm_loadu_si128((__m128i *) (pi2_src + 40)); //a00 a01 a02 a03 a04 a05 a06 a07 a08 -- the source matrix 5th row
     scalemat_r0 = _mm_loadu_si128((__m128i *) (pu2_iscale_mat + 40)); //b00 b01 b02 b03 b04 b05 b06 b07 b08 -- the scaling matrix 5th row
     dequant_r0 = _mm_loadu_si128((__m128i *) (&pu2_weigh_mat[40])); //q0 q1 q2 q3 q4 q5 q6 q7 -- all 16 bits
     src_r0_1 = _mm_unpacklo_epi16(src_r0, zero_8x16b); //a00 0 a01 0 a02 0 a03 0 -- 16 bit long
     src_r0_2 = _mm_unpackhi_epi16(src_r0, zero_8x16b); // a04 0 a05 0 a06 0 a07 0 -- 16 bit long
     temp10 = _mm_mullo_epi16(scalemat_r0, dequant_r0); //b00*q0 b01*q1 b02*q2 b03*q3 b04*q4 b05*q5 b06*q6 b07*q7 -- 16 bit result
     scalemat_r0_1 = _mm_unpacklo_epi16(temp10, zero_8x16b); // b00*q0 0 b01*q1 0 b02*q2 0 b03*q3 0 -- 16 bit long
     scalemat_r0_2 = _mm_unpackhi_epi16(temp10, zero_8x16b); // b04*q4 0 b05*q5 0 b06*q6 0 b07*q7 0 -- 16 bit long
     temp5 = _mm_madd_epi16(src_r0_1, scalemat_r0_1); // a00*b00*q0 a01*b01*q1 a02*b02*q2 a03*b03*q3 -- 32 bits long
     temp7 = _mm_madd_epi16(src_r0_2, scalemat_r0_2); // a04*b04*q4 a05*b05*q5 a06*b06*q6 a07*b07*q7 -- 32 bits long
     if (qp_div >= 6) {
         resq_r5_1 = _mm_slli_epi32(temp5, qp_div - 6);
         resq_r5_2 = _mm_slli_epi32(temp7, qp_div - 6);
         //resq_r5_1 = _mm_and_si128(resq_r5_1,one_zero_mask);
         //resq_r5_2 = _mm_and_si128(resq_r5_2,one_zero_mask);
     } else {
         temp5 = _mm_add_epi32(temp5, add_rshift);
         temp7 = _mm_add_epi32(temp7, add_rshift);
         resq_r5_1 = _mm_srai_epi32(temp5, 6 - qp_div);
         resq_r5_2 = _mm_srai_epi32(temp7, 6 - qp_div);
     }
     resq_r5_1 = _mm_packs_epi32(resq_r5_1, resq_r5_2); //a00*b00*q0 a01*b01*q1 a02*b02*q2 a03*b03*q3 a04*b04*q4 a05*b05*q5 a06*b06*q6 a07*b07*q7 -- 16 bit long
     // Row 6 processing
     src_r0 = _mm_loadu_si128((__m128i *) (pi2_src + 48)); //a00 a01 a02 a03 a04 a05 a06 a07 a08 -- the source matrix 6th row
     scalemat_r0 = _mm_loadu_si128((__m128i *) (pu2_iscale_mat + 48)); //b00 b01 b02 b03 b04 b05 b06 b07 b08 -- the scaling matrix 6th row
     dequant_r0 = _mm_loadu_si128((__m128i *) (&pu2_weigh_mat[48])); //q0 q1 q2 q3 q4 q5 q6 q7 -- all 16 bits
     src_r0_1 = _mm_unpacklo_epi16(src_r0, zero_8x16b); //a00 0 a01 0 a02 0 a03 0 -- 16 bit long
     src_r0_2 = _mm_unpackhi_epi16(src_r0, zero_8x16b); // a04 0 a05 0 a06 0 a07 0 -- 16 bit long
     temp10 = _mm_mullo_epi16(scalemat_r0, dequant_r0); //b00*q0 b01*q1 b02*q2 b03*q3 b04*q4 b05*q5 b06*q6 b07*q7 -- 16 bit result
     scalemat_r0_1 = _mm_unpacklo_epi16(temp10, zero_8x16b); // b00*q0 0 b01*q1 0 b02*q2 0 b03*q3 0 -- 16 bit long
     scalemat_r0_2 = _mm_unpackhi_epi16(temp10, zero_8x16b); // b04*q4 0 b05*q5 0 b06*q6 0 b07*q7 0 -- 16 bit long
     temp5 = _mm_madd_epi16(src_r0_1, scalemat_r0_1); // a00*b00*q0 a01*b01*q1 a02*b02*q2 a03*b03*q3 -- 32 bits long
     temp7 = _mm_madd_epi16(src_r0_2, scalemat_r0_2); // a04*b04*q4 a05*b05*q5 a06*b06*q6 a07*b07*q7 -- 32 bits long
     if (qp_div >= 6) {
         resq_r6_1 = _mm_slli_epi32(temp5, qp_div - 6);
         resq_r6_2 = _mm_slli_epi32(temp7, qp_div - 6);
         //resq_r6_1 = _mm_and_si128(resq_r6_1,one_zero_mask);
         //resq_r6_2 = _mm_and_si128(resq_r6_2,one_zero_mask);
     } else {
         temp5 = _mm_add_epi32(temp5, add_rshift);
         temp7 = _mm_add_epi32(temp7, add_rshift);
         resq_r6_1 = _mm_srai_epi32(temp5, 6 - qp_div);
         resq_r6_2 = _mm_srai_epi32(temp7, 6 - qp_div);
         //resq_r6_1 = _mm_and_si128(resq_r6_1,one_zero_mask);
         //resq_r6_2 = _mm_and_si128(resq_r6_2,one_zero_mask);
     }
     resq_r6_1 = _mm_packs_epi32(resq_r6_1, resq_r6_2); //a00*b00*q0 a01*b01*q1 a02*b02*q2 a03*b03*q3 a04*b04*q4 a05*b05*q5 a06*b06*q6 a07*b07*q7 -- 16 bit long
     // Row 7 processing
     src_r0 = _mm_loadu_si128((__m128i *) (pi2_src + 56)); //a00 a01 a02 a03 a04 a05 a06 a07 a08 -- the source matrix 7th row
     scalemat_r0 = _mm_loadu_si128((__m128i *) (pu2_iscale_mat + 56)); //b00 b01 b02 b03 b04 b05 b06 b07 b08 -- the scaling matrix 7th row
     dequant_r0 = _mm_loadu_si128((__m128i *) (&pu2_weigh_mat[56])); //q0 q1 q2 q3 q4 q5 q6 q7 -- all 16 bits
     src_r0_1 = _mm_unpacklo_epi16(src_r0, zero_8x16b); //a00 0 a01 0 a02 0 a03 0 -- 16 bit long
     src_r0_2 = _mm_unpackhi_epi16(src_r0, zero_8x16b); // a04 0 a05 0 a06 0 a07 0 -- 16 bit long
     temp10 = _mm_mullo_epi16(scalemat_r0, dequant_r0); //b00*q0 b01*q1 b02*q2 b03*q3 b04*q4 b05*q5 b06*q6 b07*q7 -- 16 bit result
     scalemat_r0_1 = _mm_unpacklo_epi16(temp10, zero_8x16b); // b00*q0 0 b01*q1 0 b02*q2 0 b03*q3 0 -- 16 bit long
     scalemat_r0_2 = _mm_unpackhi_epi16(temp10, zero_8x16b); // b04*q4 0 b05*q5 0 b06*q6 0 b07*q7 0 -- 16 bit long
     temp5 = _mm_madd_epi16(src_r0_1, scalemat_r0_1); // a00*b00*q0 a01*b01*q1 a02*b02*q2 a03*b03*q3 -- 32 bits long
     temp7 = _mm_madd_epi16(src_r0_2, scalemat_r0_2); // a04*b04*q4 a05*b05*q5 a06*b06*q6 a07*b07*q7 -- 32 bits long
     if (qp_div >= 6) {
         resq_r7_1 = _mm_slli_epi32(temp5, qp_div - 6);
         resq_r7_2 = _mm_slli_epi32(temp7, qp_div - 6);
     } else {
         temp5 = _mm_add_epi32(temp5, add_rshift);
         temp7 = _mm_add_epi32(temp7, add_rshift);
         resq_r7_1 = _mm_srai_epi32(temp5, 6 - qp_div);
         resq_r7_2 = _mm_srai_epi32(temp7, 6 - qp_div);
     }
     resq_r7_1 = _mm_packs_epi32(resq_r7_1, resq_r7_2); //a00*b00*q0 a01*b01*q1 a02*b02*q2 a03*b03*q3 a04*b04*q4 a05*b05*q5 a06*b06*q6 a07*b07*q7 -- 16 bit long
     /* Perform Inverse transform */
     /*--------------------------------------------------------------------*/
     /* IDCT [ Horizontal transformation ]                                 */
     /*--------------------------------------------------------------------*/
     // Matrix transpose
     /*
      *  a0 a1 a2 a3 a4 a5 a6 a7
      *  b0 b1 b2 b3 b4 b5 b6 b7
      *  c0 c1 c2 c3 c4 c5 c6 c7
      *  d0 d1 d2 d3 d4 d5 d6 d7
      */
     temp1 = _mm_unpacklo_epi16(resq_r0_1, resq_r1_1); //a0 b0 a1 b1 a2 b2 a3 b3
     temp3 = _mm_unpacklo_epi16(resq_r2_1, resq_r3_1); //c0 d0 c1 d1 c2 d2 c3 d3
     temp2 = _mm_unpackhi_epi16(resq_r0_1, resq_r1_1); //a4 b4 a5 b5 a6 b6 a7 b7
     temp4 = _mm_unpackhi_epi16(resq_r2_1, resq_r3_1); //c4 d4 c5 d5 c6 d6 c7 d7
     resq_r0_1 = _mm_unpacklo_epi32(temp1, temp3); //a0 b0 c0 d0 a1 b1 c1 d1
     resq_r1_1 = _mm_unpackhi_epi32(temp1, temp3); //a2 b2 c2 d2 a3 b3 c3 d3
     resq_r2_1 = _mm_unpacklo_epi32(temp2, temp4); //a4 b4 c4 d4 a5 b5 c5 d5
     resq_r3_1 = _mm_unpackhi_epi32(temp2, temp4); //a6 b6 c6 d6 a7 b7 c7 d7
     /*
      * e0 e1 e2 e3 e4 e5 e6 e7
      * f0 f1 f2 f3 f4 f5 f6 f7
      * g0 g1 g2 g3 g4 g5 g6 g7
      * h0 h1 h2 h3 h4 h5 h6 h7
      */
     temp1 = _mm_unpacklo_epi16(resq_r4_1, resq_r5_1); //e0 f0 e1 f1 e2 f2 e2 f3
     temp3 = _mm_unpacklo_epi16(resq_r6_1, resq_r7_1); //g0 h0 g1 h1 g2 h2 g3 h3
     temp2 = _mm_unpackhi_epi16(resq_r4_1, resq_r5_1); //e4 f4 e5 f5 e6 f6 e7 f7
     temp4 = _mm_unpackhi_epi16(resq_r6_1, resq_r7_1); //g4 h4 g5 h5 g6 h6 g7 h7
     resq_r4_1 = _mm_unpacklo_epi32(temp1, temp3); //e0 f0 g0 h0 e1 f1 g1 h1
     resq_r5_1 = _mm_unpackhi_epi32(temp1, temp3); //e2 f2 g2 h2 e3 f3 g3 h3
     resq_r6_1 = _mm_unpacklo_epi32(temp2, temp4); //e4 f4 g4 h4 e5 f5 g5 h5
     resq_r7_1 = _mm_unpackhi_epi32(temp2, temp4); //e6 f6 g6 h6 e7 f7 g7 h7
     /*
      * a0 b0 c0 d0 a1 b1 c1 d1
      * a2 b2 c2 d2 a3 b3 c3 d3
      * a4 b4 c4 d4 a5 b5 c5 d5
      * a6 b6 c6 d6 a7 b7 c7 d7
      * e0 f0 g0 h0 e1 f1 g1 h1
      * e2 f2 g2 h2 e3 f3 g3 h3
      * e4 f4 g4 h4 e5 f5 g5 h5
      * e6 f6 g6 h6 e7 f7 g7 h7
      */
     resq_r0_2 = _mm_unpacklo_epi64(resq_r0_1, resq_r4_1); //a0 b0 c0 d0 e0 f0 g0 h0
     resq_r1_2 = _mm_unpackhi_epi64(resq_r0_1, resq_r4_1); //a1 b1 c1 d1 e1 f1 g1 h1
     resq_r2_2 = _mm_unpacklo_epi64(resq_r1_1, resq_r5_1); //a2 b2 c2 d2 e2 f2 g2 h2
     resq_r3_2 = _mm_unpackhi_epi64(resq_r1_1, resq_r5_1); //a3 b3 c3 d3 e3 f3 g3 h3
     resq_r4_2 = _mm_unpacklo_epi64(resq_r2_1, resq_r6_1); //a4 b4 c4 d4 e4 f4 g4 h4
     resq_r5_2 = _mm_unpackhi_epi64(resq_r2_1, resq_r6_1); //a5 b5 c5 d5 e5 f5 g5 h5
     resq_r6_2 = _mm_unpacklo_epi64(resq_r3_1, resq_r7_1); //a6 b6 c6 d6 e6 f6 g6 h6
     resq_r7_2 = _mm_unpackhi_epi64(resq_r3_1, resq_r7_1); //a7 b7 c7 d7 e7 f7 g7 h7
 
     sign_reg = _mm_cmpgt_epi16(zero_8x16b, resq_r1_2);
     resq_r1_1 = _mm_unpacklo_epi16(resq_r1_2, sign_reg); //a1 b1 c1 d1 -- 32 bit
     resq_r1_2 = _mm_unpackhi_epi16(resq_r1_2, sign_reg); //e1 f1 g1 h1 -- 32 bit
     sign_reg = _mm_cmpgt_epi16(zero_8x16b, resq_r3_2);
     resq_r3_1 = _mm_unpacklo_epi16(resq_r3_2, sign_reg); //a3 b3 c3 d3 -- 32 bit
     resq_r3_2 = _mm_unpackhi_epi16(resq_r3_2, sign_reg); //e3 f3 g3 h3 -- 32 bit
     sign_reg = _mm_cmpgt_epi16(zero_8x16b, resq_r5_2);
     resq_r5_1 = _mm_unpacklo_epi16(resq_r5_2, sign_reg); //a5 b5 c5 d5 -- 32 bit
     resq_r5_2 = _mm_unpackhi_epi16(resq_r5_2, sign_reg); //e5 f5 g5 h5 -- 32 bit
     sign_reg = _mm_cmpgt_epi16(zero_8x16b, resq_r7_2);
     resq_r7_1 = _mm_unpacklo_epi16(resq_r7_2, sign_reg); //a7 b7 c7 d7 -- 32 bit
     resq_r7_2 = _mm_unpackhi_epi16(resq_r7_2, sign_reg); //e7 f7 g7 h7 -- 32 bit
     //Transform starts -- horizontal transform
     /*------------------------------------------------------------------*/
     /* y0 = w0 + w4                                                     */
     temp1 = _mm_add_epi16(resq_r0_2, resq_r4_2);
     /* y2 = w0 - w4                                                      */
     temp3 = _mm_sub_epi16(resq_r0_2, resq_r4_2);
     /* y1 = -w3 + w5 - w7 - (w7 >> 1)                                   */
     temp2 = _mm_sub_epi32(resq_r5_1, resq_r3_1); //-w3+w5
     temp10 = _mm_sub_epi32(resq_r5_2, resq_r3_2);
     temp4 = _mm_sub_epi32(temp2, resq_r7_1); //-w3+w5-w7
     temp12 = _mm_sub_epi32(temp10, resq_r7_2);
     temp5 = _mm_srai_epi32(resq_r7_1, 1); //w7>>1
     temp13 = _mm_srai_epi32(resq_r7_2, 1);
     temp2 = _mm_sub_epi32(temp4, temp5); //-w3+w5-w7 -(w7>>1)
     temp10 = _mm_sub_epi32(temp12, temp13);
     temp2 = _mm_packs_epi32(temp2, temp10);
     /* y3 = w1 + w7 - w3 - (w3 >> 1)                                    */
     temp4 = _mm_add_epi32(resq_r1_1, resq_r7_1); //w1+w7
     temp12 = _mm_add_epi32(resq_r1_2, resq_r7_2);
     temp4 = _mm_sub_epi32(temp4, resq_r3_1); //w1+w7-w3
     temp12 = _mm_sub_epi32(temp12, resq_r3_2);
     temp5 = _mm_srai_epi32(resq_r3_1, 1); //w3>>1
     temp13 = _mm_srai_epi32(resq_r3_2, 1);
     temp4 = _mm_sub_epi32(temp4, temp5); //w1+w7-w3-(w3>>1)
     temp12 = _mm_sub_epi32(temp12, temp13);
     temp4 = _mm_packs_epi32(temp4, temp12);
     /* y4 = (w2 >> 1) - w6                                              */
     temp5 = _mm_srai_epi16(resq_r2_2, 1); //w2>>1
     temp5 = _mm_sub_epi16(temp5, resq_r6_2); //(w2>>1)-w6
     /* y5 = -w1 + w7 + w5 + (w5 >> 1)                                   */
     temp6 = _mm_sub_epi32(resq_r7_1, resq_r1_1); //w7-w1
     temp14 = _mm_sub_epi32(resq_r7_2, resq_r1_2);
     temp6 = _mm_add_epi32(temp6, resq_r5_1); //w7-w1+w5
     temp14 = _mm_add_epi32(temp14, resq_r5_2);
     temp7 = _mm_srai_epi32(resq_r5_1, 1); //w5>>1
     temp15 = _mm_srai_epi32(resq_r5_2, 1);
     temp6 = _mm_add_epi32(temp6, temp7); //w7-w1_w5+(w5>>1)
     temp14 = _mm_add_epi32(temp14, temp15);
     temp6 = _mm_packs_epi32(temp6, temp14);
     /* y6 = w2 + (w6 >> 1)                                              */
     temp7 = _mm_srai_epi16(resq_r6_2, 1); //w6>>1
     temp7 = _mm_add_epi16(temp7, resq_r2_2); //(w6>>1)+w2
     /* y7 = w3 + w5 + w1 + (w1 >> 1)                                    */
     temp8 = _mm_add_epi32(resq_r3_1, resq_r5_1); //w3+w5
     temp16 = _mm_add_epi32(resq_r3_2, resq_r5_2);
     temp8 = _mm_add_epi32(temp8, resq_r1_1); //w3+w5+w1
     temp16 = _mm_add_epi32(temp16, resq_r1_2);
     temp17 = _mm_srai_epi32(resq_r1_1, 1); //w1>>1
     temp18 = _mm_srai_epi32(resq_r1_2, 1);
     temp8 = _mm_add_epi32(temp8, temp17); //w3+w5+w1+(w1>>1)
     temp16 = _mm_add_epi32(temp16, temp18);
     temp8 = _mm_packs_epi32(temp8, temp16);
     /*------------------------------------------------------------------*/
     /*------------------------------------------------------------------*/
     /* z0 = y0 + y6                                                        */
     resq_r0_1 = _mm_add_epi16(temp1, temp7);
     /* z1 = y1 + (y7 >> 2)                                                */
     resq_r1_1 = _mm_srai_epi16(temp8, 2);
     resq_r1_1 = _mm_add_epi16(resq_r1_1, temp2);
     /* z2 = y2 + y4                                                        */
     resq_r2_1 = _mm_add_epi16(temp3, temp5);
     /* z3 = y3 + (y5 >> 2)                                                */
     resq_r3_1 = _mm_srai_epi16(temp6, 2);
     resq_r3_1 = _mm_add_epi16(resq_r3_1, temp4);
     /* z4 = y2 - y4                                                        */
     resq_r4_1 = _mm_sub_epi16(temp3, temp5);
     /* z5 = (y3 >> 2) - y5                                                 */
     resq_r5_1 = _mm_srai_epi16(temp4, 2);
     resq_r5_1 = _mm_sub_epi16(resq_r5_1, temp6);
     /* z6 = y0 - y6                                                     */
     resq_r6_1 = _mm_sub_epi16(temp1, temp7);
     /* z7 = y7 - (y1 >> 2)                                                 */
     resq_r7_1 = _mm_srai_epi16(temp2, 2);
     resq_r7_1 = _mm_sub_epi16(temp8, resq_r7_1);
     /*------------------------------------------------------------------*/
     /*------------------------------------------------------------------*/
     /* x0 = z0 + z7                                                        */
     temp1 = _mm_add_epi16(resq_r0_1, resq_r7_1);
     /* x1 = z2 + z5                                                        */
     temp2 = _mm_add_epi16(resq_r2_1, resq_r5_1);
     /* x2 = z4 + z3                                                        */
     temp3 = _mm_add_epi16(resq_r4_1, resq_r3_1);
     /* x3 = z6 + z1                                                        */
     temp4 = _mm_add_epi16(resq_r6_1, resq_r1_1);
     /* x4 = z6 - z1                                                        */
     temp5 = _mm_sub_epi16(resq_r6_1, resq_r1_1);
     /* x5 = z4 - z3                                                        */
     temp6 = _mm_sub_epi16(resq_r4_1, resq_r3_1);
     /* x6 = z2 - z5                                                        */
     temp7 = _mm_sub_epi16(resq_r2_1, resq_r5_1);
     /* x7 = z0 - z7                                                        */
     temp8 = _mm_sub_epi16(resq_r0_1, resq_r7_1);
     /*------------------------------------------------------------------*/
     // Matrix transpose
     /*
      *  a0 b0 c0 d0 e0 f0 g0 h0
      *  a1 b1 c1 d1 e1 f1 g1 h1
      *  a2 b2 c2 d2 e2 f2 g2 h2
      *  a3 b3 c3 d3 e3 f3 g3 h3
      */
     temp17 = _mm_unpacklo_epi16(temp1, temp2); //a0 a1 b0 b1 c0 c1 d0 d1
     temp19 = _mm_unpacklo_epi16(temp3, temp4); //a2 a3 b2 b3 c2 c3 d2 d3
     temp18 = _mm_unpackhi_epi16(temp1, temp2); //e0 e1 f0 f1 g0 g1 h0 h1
     temp20 = _mm_unpackhi_epi16(temp3, temp4); //e2 e3 f2 f3 g2 g3 h2 h3
 
     resq_r0_1 = _mm_unpacklo_epi32(temp17, temp19); //a0 a1 a2 a3 b0 b1 b2 b3
     resq_r1_1 = _mm_unpackhi_epi32(temp17, temp19); //c0 c1 c2 c3 d0 d1 d2 d3
     resq_r2_1 = _mm_unpacklo_epi32(temp18, temp20); //e0 e1 e2 e3 f0 f1 f2 f3
     resq_r3_1 = _mm_unpackhi_epi32(temp18, temp20); //g0 g2 g2 g3 h0 h1 h2 h3
     /*
      *  a4 b4 c4 d4 e4 f4 g4 h4
      *  a5 b5 c5 d5 e5 f5 g5 h5
      *  a6 b6 c6 d6 e6 f6 g6 h6
      *  a7 b7 c7 d7 e7 f7 g7 h7
      */
     temp17 = _mm_unpacklo_epi16(temp5, temp6); //a4 a5 b4 b5 c4 c5 d4 d5
     temp19 = _mm_unpacklo_epi16(temp7, temp8); //a6 a7 b6 b7 c6 c7 d6 d7
     temp18 = _mm_unpackhi_epi16(temp5, temp6); //e4 e5 f4 f5 g4 g5 h4 h5
     temp20 = _mm_unpackhi_epi16(temp7, temp8); //e6 e7 f6 f7 g6 g7 h6 h7
 
     resq_r4_1 = _mm_unpacklo_epi32(temp17, temp19); //a4 a5 a6 a7 b4 b5 b6 b7
     resq_r5_1 = _mm_unpackhi_epi32(temp17, temp19); //c4 c5 c6 c7 d4 d5 d6 d7
     resq_r6_1 = _mm_unpacklo_epi32(temp18, temp20); //e4 e5 e6 e7 f4 f5 f6 f7
     resq_r7_1 = _mm_unpackhi_epi32(temp18, temp20); //g4 g5 g6 g7 h4 h5 h6 h7
     /*  a0 a1 a2 a3 b0 b1 b2 b3
      *  c0 c1 c2 c3 d0 d1 d2 d3
      *  e0 e1 e2 e3 f0 f1 f2 f3
      *  g0 g2 g2 g3 h0 h1 h2 h3
      *  a4 a5 a6 a7 b4 b5 b6 b7
      *  c4 c5 c6 c7 d4 d5 d6 d7
      *  e4 e5 e6 e7 f4 f5 f6 f7
      *  g4 g5 g6 g7 h4 h5 h6 h7
      */
     resq_r0_2 = _mm_unpacklo_epi64(resq_r0_1, resq_r4_1); //a0 a1 a2 a3 a4 a5 a6 a7
     resq_r1_2 = _mm_unpackhi_epi64(resq_r0_1, resq_r4_1); //b0 b1 b2 b3 b4 b5 b6 b7
     resq_r2_2 = _mm_unpacklo_epi64(resq_r1_1, resq_r5_1); //c0 c1 c2 c3 c4 c5 c6 c7
     resq_r3_2 = _mm_unpackhi_epi64(resq_r1_1, resq_r5_1); //d0 d1 d2 d3 d4 d5 d6 d7
     resq_r4_2 = _mm_unpacklo_epi64(resq_r2_1, resq_r6_1); //e0 e1 e2 e3 e4 e5 e6 e7
     resq_r5_2 = _mm_unpackhi_epi64(resq_r2_1, resq_r6_1); //f0 f1 f2 f3 f4 f5 f6 f7
     resq_r6_2 = _mm_unpacklo_epi64(resq_r3_1, resq_r7_1); //g0 g1 g2 g3 g4 g5 g6 g7
     resq_r7_2 = _mm_unpackhi_epi64(resq_r3_1, resq_r7_1); //h0 h1 h2 h3 h4 h5 h6 h7
 
     sign_reg = _mm_cmpgt_epi16(zero_8x16b, resq_r1_2);
     resq_r1_1 = _mm_unpacklo_epi16(resq_r1_2, sign_reg); //a1 b1 c1 d1 -- 32 bit
     resq_r1_2 = _mm_unpackhi_epi16(resq_r1_2, sign_reg); //e1 f1 g1 h1 -- 32 bit
     sign_reg = _mm_cmpgt_epi16(zero_8x16b, resq_r3_2);
     resq_r3_1 = _mm_unpacklo_epi16(resq_r3_2, sign_reg); //a3 b3 c3 d3 -- 32 bit
     resq_r3_2 = _mm_unpackhi_epi16(resq_r3_2, sign_reg); //e3 f3 g3 h3 -- 32 bit
     sign_reg = _mm_cmpgt_epi16(zero_8x16b, resq_r5_2);
     resq_r5_1 = _mm_unpacklo_epi16(resq_r5_2, sign_reg); //a5 b5 c5 d5 -- 32 bit
     resq_r5_2 = _mm_unpackhi_epi16(resq_r5_2, sign_reg); //e5 f5 g5 h5 -- 32 bit
     sign_reg = _mm_cmpgt_epi16(zero_8x16b, resq_r7_2);
     resq_r7_1 = _mm_unpacklo_epi16(resq_r7_2, sign_reg); //a7 b7 c7 d7 -- 32 bit
     resq_r7_2 = _mm_unpackhi_epi16(resq_r7_2, sign_reg); //e7 f7 g7 h7 -- 32 bit
 
     zero_8x16b = _mm_setzero_si128(); // all bits reset to zero
     //Load pred buffer row 0
     predload_r = _mm_loadl_epi64((__m128i *) (&pu1_pred[0])); //p0 p1 p2 p3 p4 p5 p6 p7 0 0 0 0 0 0 0 0 -- all 8 bits
     pred_r0_1 = _mm_unpacklo_epi8(predload_r, zero_8x16b); //p0 p1 p2 p3 p4 p5 p6 p7 -- all 16 bits
     //Load pred buffer row 1
     predload_r = _mm_loadl_epi64((__m128i *) (&pu1_pred[pred_strd])); //p0 p1 p2 p3 p4 p5 p6 p7 0 0 0 0 0 0 0 0 -- all 8 bits
     pred_r1_1 = _mm_unpacklo_epi8(predload_r, zero_8x16b); //p0 p1 p2 p3 p4 p5 p6 p7 -- all 16 bits
     //Load pred buffer row 2
     predload_r = _mm_loadl_epi64((__m128i *) (&pu1_pred[2 * pred_strd])); //p0 p1 p2 p3 p4 p5 p6 p7 0 0 0 0 0 0 0 0 -- all 8 bits
     pred_r2_1 = _mm_unpacklo_epi8(predload_r, zero_8x16b); //p0 p1 p2 p3 p4 p5 p6 p7 -- all 16 bits
     //Load pred buffer row 3
     predload_r = _mm_loadl_epi64((__m128i *) (&pu1_pred[3 * pred_strd])); //p0 p1 p2 p3 p4 p5 p6 p7 0 0 0 0 0 0 0 0 -- all 8 bits
     pred_r3_1 = _mm_unpacklo_epi8(predload_r, zero_8x16b); //p0 p1 p2 p3 p4 p5 p6 p7 -- all 16 bits
     //Load pred buffer row 4
     predload_r = _mm_loadl_epi64((__m128i *) (&pu1_pred[4 * pred_strd])); //p0 p1 p2 p3 p4 p5 p6 p7 0 0 0 0 0 0 0 0 -- all 8 bits
     pred_r4_1 = _mm_unpacklo_epi8(predload_r, zero_8x16b); //p0 p1 p2 p3 p4 p5 p6 p7 -- all 16 bits
     //Load pred buffer row 5
     predload_r = _mm_loadl_epi64((__m128i *) (&pu1_pred[5 * pred_strd])); //p0 p1 p2 p3 p4 p5 p6 p7 0 0 0 0 0 0 0 0 -- all 8 bit
     pred_r5_1 = _mm_unpacklo_epi8(predload_r, zero_8x16b); //p0 p1 p2 p3 p4 p5 p6 p7 -- all 16 bits
     //Load pred buffer row 6
     predload_r = _mm_loadl_epi64((__m128i *) (&pu1_pred[6 * pred_strd])); //p0 p1 p2 p3 p4 p5 p6 p7 0 0 0 0 0 0 0 0 -- all 8 bits
     pred_r6_1 = _mm_unpacklo_epi8(predload_r, zero_8x16b); //p0 p1 p2 p3 p4 p5 p6 p7 -- all 16 bits
     //Load pred buffer row 7
     predload_r = _mm_loadl_epi64((__m128i *) (&pu1_pred[7 * pred_strd])); //p0 p1 p2 p3 p4 p5 p6 p7 0 0 0 0 0 0 0 0 -- all 8 bits
     pred_r7_1 = _mm_unpacklo_epi8(predload_r, zero_8x16b); //p0 p1 p2 p3 p4 p5 p6 p7 -- all 16 bits
 
     /*--------------------------------------------------------------------*/
     /* IDCT [ Vertical transformation] and Xij = (xij + 32)>>6            */
     /*                                                                    */
     /* Add the prediction and store it back to reconstructed frame buffer */
     /* [Prediction buffer itself in this case]                            */
     /*--------------------------------------------------------------------*/
 
     /* y0j = w0j + w4j                                                     */
     temp1 = _mm_add_epi16(resq_r0_2, resq_r4_2);
     /* y2j = w0j - w4j                                                      */
     temp3 = _mm_sub_epi16(resq_r0_2, resq_r4_2);
     /* y1j = -w3j + w5j - w7j - (w7j >> 1)                                   */
     temp2 = _mm_sub_epi32(resq_r5_1, resq_r3_1); //-w3+w5
     temp10 = _mm_sub_epi32(resq_r5_2, resq_r3_2);
     temp4 = _mm_sub_epi32(temp2, resq_r7_1); //-w3+w5-w7
     temp12 = _mm_sub_epi32(temp10, resq_r7_2);
     temp5 = _mm_srai_epi32(resq_r7_1, 1); //w7>>1
     temp13 = _mm_srai_epi32(resq_r7_2, 1);
     temp2 = _mm_sub_epi32(temp4, temp5); //-w3+w5-w7 -(w7>>1)
     temp10 = _mm_sub_epi32(temp12, temp13);
     temp2 = _mm_packs_epi32(temp2, temp10);
     /* y3j = w1j + w7j - w3j - (w3j >> 1)                                    */
     temp4 = _mm_add_epi32(resq_r1_1, resq_r7_1); //w1+w7
     temp12 = _mm_add_epi32(resq_r1_2, resq_r7_2);
     temp4 = _mm_sub_epi32(temp4, resq_r3_1); //w1+w7-w3
     temp12 = _mm_sub_epi32(temp12, resq_r3_2);
     temp5 = _mm_srai_epi32(resq_r3_1, 1); //w3>>1
     temp13 = _mm_srai_epi32(resq_r3_2, 1);
     temp4 = _mm_sub_epi32(temp4, temp5); //w1+w7-w3-(w3>>1)
     temp12 = _mm_sub_epi32(temp12, temp13);
     temp4 = _mm_packs_epi32(temp4, temp12);
     /* y4j = (w2j >> 1) - w6j                                              */
     temp5 = _mm_srai_epi16(resq_r2_2, 1); //w2>>1
     temp5 = _mm_sub_epi16(temp5, resq_r6_2); //(w2>>1)-w6
     /* y5j = -w1j + w7j + w5j + (w5j >> 1)                                   */
     temp6 = _mm_sub_epi32(resq_r7_1, resq_r1_1); //w7-w1
     temp14 = _mm_sub_epi32(resq_r7_2, resq_r1_2);
     temp6 = _mm_add_epi32(temp6, resq_r5_1); //w7-w1+w5
     temp14 = _mm_add_epi32(temp14, resq_r5_2);
     temp7 = _mm_srai_epi32(resq_r5_1, 1); //w5>>1
     temp15 = _mm_srai_epi32(resq_r5_2, 1);
     temp6 = _mm_add_epi32(temp6, temp7); //w7-w1_w5+(w5>>1)
     temp14 = _mm_add_epi32(temp14, temp15);
     temp6 = _mm_packs_epi32(temp6, temp14);
     /* y6j = w2j + (w6j >> 1)                                              */
     temp7 = _mm_srai_epi16(resq_r6_2, 1); //w6>>1
     temp7 = _mm_add_epi16(temp7, resq_r2_2); //(w6>>1)+w2
     /* y7j = w3j + w5j + w1j + (w1j >> 1)                                    */
     temp8 = _mm_add_epi32(resq_r3_1, resq_r5_1); //w3+w5
     temp16 = _mm_add_epi32(resq_r3_2, resq_r5_2);
     temp8 = _mm_add_epi32(temp8, resq_r1_1); //w3+w5+w1
     temp16 = _mm_add_epi32(temp16, resq_r1_2);
     temp17 = _mm_srai_epi32(resq_r1_1, 1); //w1>>1
     temp18 = _mm_srai_epi32(resq_r1_2, 1);
     temp8 = _mm_add_epi32(temp8, temp17); //w3+w5+w1+(w1>>1)
     temp16 = _mm_add_epi32(temp16, temp18);
     temp8 = _mm_packs_epi32(temp8, temp16);
     /*------------------------------------------------------------------*/
     /*------------------------------------------------------------------*/
     /* z0j = y0j + y6j                                                        */
     resq_r0_1 = _mm_add_epi16(temp1, temp7);
     /* z1j = y1j + (y7j >> 2)                                                */
     resq_r1_1 = _mm_srai_epi16(temp8, 2);
     resq_r1_1 = _mm_add_epi16(resq_r1_1, temp2);
     /* z2j = y2j + y4j                                                        */
     resq_r2_1 = _mm_add_epi16(temp3, temp5);
     /* z3j = y3j + (y5j >> 2)                                                */
     resq_r3_1 = _mm_srai_epi16(temp6, 2);
     resq_r3_1 = _mm_add_epi16(resq_r3_1, temp4);
     /* z4j = y2j - y4j                                                        */
     resq_r4_1 = _mm_sub_epi16(temp3, temp5);
     /* z5j = (y3j >> 2) - y5j                                                 */
     resq_r5_1 = _mm_srai_epi16(temp4, 2);
     resq_r5_1 = _mm_sub_epi16(resq_r5_1, temp6);
     /* z6j = y0j - y6j                                                     */
     resq_r6_1 = _mm_sub_epi16(temp1, temp7);
     /* z7j = y7j - (y1j >> 2)                                                 */
     resq_r7_1 = _mm_srai_epi16(temp2, 2);
     resq_r7_1 = _mm_sub_epi16(temp8, resq_r7_1);
     /*------------------------------------------------------------------*/
 
     /*------------------------------------------------------------------*/
     /* x0j = z0j + z7j                                                        */
     temp1 = _mm_add_epi16(resq_r0_1, resq_r7_1);
     sign_reg = _mm_cmpgt_epi16(zero_8x16b, temp1);
     temp10 = _mm_unpacklo_epi16(temp1, sign_reg);
     temp11 = _mm_unpackhi_epi16(temp1, sign_reg);
     temp10 = _mm_add_epi32(temp10, value_32);
     temp11 = _mm_add_epi32(temp11, value_32);
     temp10 = _mm_srai_epi32(temp10, 6);
     temp11 = _mm_srai_epi32(temp11, 6);
     temp10 = _mm_packs_epi32(temp10, temp11);
     temp1 = _mm_add_epi16(temp10, pred_r0_1);
     /* x1j = z2j + z5j                                                        */
     temp2 = _mm_add_epi16(resq_r2_1, resq_r5_1);
     sign_reg = _mm_cmpgt_epi16(zero_8x16b, temp2);
     temp10 = _mm_unpacklo_epi16(temp2, sign_reg);
     temp11 = _mm_unpackhi_epi16(temp2, sign_reg);
     temp10 = _mm_add_epi32(temp10, value_32);
     temp11 = _mm_add_epi32(temp11, value_32);
     temp10 = _mm_srai_epi32(temp10, 6);
     temp11 = _mm_srai_epi32(temp11, 6);
     temp10 = _mm_packs_epi32(temp10, temp11);
     temp2 = _mm_add_epi16(temp10, pred_r1_1);
     /* x2j = z4j + z3j                                                        */
     temp3 = _mm_add_epi16(resq_r4_1, resq_r3_1);
     sign_reg = _mm_cmpgt_epi16(zero_8x16b, temp3);
     temp10 = _mm_unpacklo_epi16(temp3, sign_reg);
     temp11 = _mm_unpackhi_epi16(temp3, sign_reg);
     temp10 = _mm_add_epi32(temp10, value_32);
     temp11 = _mm_add_epi32(temp11, value_32);
     temp10 = _mm_srai_epi32(temp10, 6);
     temp11 = _mm_srai_epi32(temp11, 6);
     temp10 = _mm_packs_epi32(temp10, temp11);
     temp3 = _mm_add_epi16(temp10, pred_r2_1);
     /* x3j = z6j + z1j                                                        */
     temp4 = _mm_add_epi16(resq_r6_1, resq_r1_1);
     sign_reg = _mm_cmpgt_epi16(zero_8x16b, temp4);
     temp10 = _mm_unpacklo_epi16(temp4, sign_reg);
     temp11 = _mm_unpackhi_epi16(temp4, sign_reg);
     temp10 = _mm_add_epi32(temp10, value_32);
     temp11 = _mm_add_epi32(temp11, value_32);
     temp10 = _mm_srai_epi32(temp10, 6);
     temp11 = _mm_srai_epi32(temp11, 6);
     temp10 = _mm_packs_epi32(temp10, temp11);
     temp4 = _mm_add_epi16(temp10, pred_r3_1);
     /* x4j = z6j - z1j                                                        */
     temp5 = _mm_sub_epi16(resq_r6_1, resq_r1_1);
     sign_reg = _mm_cmpgt_epi16(zero_8x16b, temp5);
     temp10 = _mm_unpacklo_epi16(temp5, sign_reg);
     temp11 = _mm_unpackhi_epi16(temp5, sign_reg);
     temp10 = _mm_add_epi32(temp10, value_32);
     temp11 = _mm_add_epi32(temp11, value_32);
     temp10 = _mm_srai_epi32(temp10, 6);
     temp11 = _mm_srai_epi32(temp11, 6);
     temp10 = _mm_packs_epi32(temp10, temp11);
     temp5 = _mm_add_epi16(temp10, pred_r4_1);
     /* x5j = z4j - z3j                                                        */
     temp6 = _mm_sub_epi16(resq_r4_1, resq_r3_1);
     sign_reg = _mm_cmpgt_epi16(zero_8x16b, temp6);
     temp10 = _mm_unpacklo_epi16(temp6, sign_reg);
     temp11 = _mm_unpackhi_epi16(temp6, sign_reg);
     temp10 = _mm_add_epi32(temp10, value_32);
     temp11 = _mm_add_epi32(temp11, value_32);
     temp10 = _mm_srai_epi32(temp10, 6);
     temp11 = _mm_srai_epi32(temp11, 6);
     temp10 = _mm_packs_epi32(temp10, temp11);
     temp6 = _mm_add_epi16(temp10, pred_r5_1);
     /* x6j = z2j - z5j                                                        */
     temp7 = _mm_sub_epi16(resq_r2_1, resq_r5_1);
     sign_reg = _mm_cmpgt_epi16(zero_8x16b, temp7);
     temp10 = _mm_unpacklo_epi16(temp7, sign_reg);
     temp11 = _mm_unpackhi_epi16(temp7, sign_reg);
     temp10 = _mm_add_epi32(temp10, value_32);
     temp11 = _mm_add_epi32(temp11, value_32);
     temp10 = _mm_srai_epi32(temp10, 6);
     temp11 = _mm_srai_epi32(temp11, 6);
     temp10 = _mm_packs_epi32(temp10, temp11);
     temp7 = _mm_add_epi16(temp10, pred_r6_1);
     /* x7j = z0j - z7j                                                        */
     temp8 = _mm_sub_epi16(resq_r0_1, resq_r7_1);
     sign_reg = _mm_cmpgt_epi16(zero_8x16b, temp8);
     temp10 = _mm_unpacklo_epi16(temp8, sign_reg);
     temp11 = _mm_unpackhi_epi16(temp8, sign_reg);
     temp10 = _mm_add_epi32(temp10, value_32);
     temp11 = _mm_add_epi32(temp11, value_32);
     temp10 = _mm_srai_epi32(temp10, 6);
     temp11 = _mm_srai_epi32(temp11, 6);
     temp10 = _mm_packs_epi32(temp10, temp11);
     temp8 = _mm_add_epi16(temp10, pred_r7_1);
     /*------------------------------------------------------------------*/
     //Clipping the results to 8 bits
     sign_reg = _mm_cmpgt_epi16(temp1, zero_8x16b); // sign check
     temp1 = _mm_and_si128(temp1, sign_reg);
     sign_reg = _mm_cmpgt_epi16(temp2, zero_8x16b); // sign check
     temp2 = _mm_and_si128(temp2, sign_reg);
     sign_reg = _mm_cmpgt_epi16(temp3, zero_8x16b); // sign check
     temp3 = _mm_and_si128(temp3, sign_reg);
     sign_reg = _mm_cmpgt_epi16(temp4, zero_8x16b); // sign check
     temp4 = _mm_and_si128(temp4, sign_reg);
     sign_reg = _mm_cmpgt_epi16(temp5, zero_8x16b); // sign check
     temp5 = _mm_and_si128(temp5, sign_reg);
     sign_reg = _mm_cmpgt_epi16(temp6, zero_8x16b); // sign check
     temp6 = _mm_and_si128(temp6, sign_reg);
     sign_reg = _mm_cmpgt_epi16(temp7, zero_8x16b); // sign check
     temp7 = _mm_and_si128(temp7, sign_reg);
     sign_reg = _mm_cmpgt_epi16(temp8, zero_8x16b); // sign check
     temp8 = _mm_and_si128(temp8, sign_reg);
 
     resq_r0_2 = _mm_packus_epi16(temp1, zero_8x16b);
     resq_r1_2 = _mm_packus_epi16(temp2, zero_8x16b);
     resq_r2_2 = _mm_packus_epi16(temp3, zero_8x16b);
     resq_r3_2 = _mm_packus_epi16(temp4, zero_8x16b);
     resq_r4_2 = _mm_packus_epi16(temp5, zero_8x16b);
     resq_r5_2 = _mm_packus_epi16(temp6, zero_8x16b);
     resq_r6_2 = _mm_packus_epi16(temp7, zero_8x16b);
     resq_r7_2 = _mm_packus_epi16(temp8, zero_8x16b);
 
     _mm_storel_epi64((__m128i *) (&pu1_out[0]), resq_r0_2);
     _mm_storel_epi64((__m128i *) (&pu1_out[out_strd]), resq_r1_2);
     _mm_storel_epi64((__m128i *) (&pu1_out[2 * out_strd]), resq_r2_2);
     _mm_storel_epi64((__m128i *) (&pu1_out[3 * out_strd]), resq_r3_2);
     _mm_storel_epi64((__m128i *) (&pu1_out[4 * out_strd]), resq_r4_2);
     _mm_storel_epi64((__m128i *) (&pu1_out[5 * out_strd]), resq_r5_2);
     _mm_storel_epi64((__m128i *) (&pu1_out[6 * out_strd]), resq_r6_2);
     _mm_storel_epi64((__m128i *) (&pu1_out[7 * out_strd]), resq_r7_2);
 }
 
diff --git a/common/x86/ih264_platform_macros.h b/common/x86/ih264_platform_macros.h
index 340c5d8..54af325 100644
--- a/common/x86/ih264_platform_macros.h
+++ b/common/x86/ih264_platform_macros.h
@@ -1,79 +1,90 @@
 /******************************************************************************
  *
  * Copyright (C) 2015 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  *****************************************************************************
  * Originally developed and contributed by Ittiam Systems Pvt. Ltd, Bangalore
 */
 /**
 *******************************************************************************
 * @file
 *  ih264_platform_macros.h
 *
 * @brief
 *  Platform specific Macro definitions used in the codec
 *
 * @author
 *  Ittiam
 *
 * @remarks
 *  None
 *
 *******************************************************************************
 */
 
 
 #ifndef _IH264_PLATFORM_MACROS_H_
 #define _IH264_PLATFORM_MACROS_H_
 
+#include <stdint.h>
 #include <immintrin.h>
 
-
-#define CLIP_U8(x) CLIP3(0, 255, (x))
-#define CLIP_S8(x) CLIP3(-128, 127, (x))
+#define CLIP_U8(x) CLIP3(0, UINT8_MAX, (x))
+#define CLIP_S8(x) CLIP3(INT8_MIN, INT8_MAX, (x))
 
 #define CLIP_U10(x) CLIP3(0, 1023, (x))
 #define CLIP_S10(x) CLIP3(-512, 511, (x))
 
+#define CLIP_U11(x) CLIP3(0, 2047, (x))
+#define CLIP_S11(x) CLIP3(-1024, 1023, (x))
+
 #define CLIP_U12(x) CLIP3(0, 4095, (x))
 #define CLIP_S12(x) CLIP3(-2048, 2047, (x))
 
-#define CLIP_U16(x) CLIP3(0, 65535, (x))
-#define CLIP_S16(x) CLIP3(-32768, 32767, (x))
+#define CLIP_U16(x) CLIP3(0, UINT16_MAX, (x))
+#define CLIP_S16(x) CLIP3(INT16_MIN, INT16_MAX, (x))
+
+#define CLIP_U32(x) CLIP3(0, UINT32_MAX, (x))
+#define CLIP_S32(x) CLIP3(INT32_MIN, INT32_MAX, (x))
 
 #define MEM_ALIGN16 __attribute__ ((aligned (16)))
 
 #define SHL(x,y) (((y) < 32) ? ((x) << (y)) : 0)
 #define SHR(x,y) (((y) < 32) ? ((x) >> (y)) : 0)
 
 #define SHR_NEG(val,shift)  ((shift>0)?(val>>shift):(val<<(-shift)))
 #define SHL_NEG(val,shift)  ((shift<0)?(val>>(-shift)):(val<<shift))
 
 
 #define ITT_BIG_ENDIAN(x)   __builtin_bswap32(x);
 
 #define NOP(nop_cnt) {UWORD32 nop_i; for (nop_i = 0; nop_i < nop_cnt; nop_i++) asm("nop");}
 
 #define PLD(a)
 
+/* In normal cases, 0 will not be passed as an argument to CLZ and CTZ.
+As CLZ and CTZ outputs are used as a shift value in few places, these return
+31 for u4_word == 0 case, just to handle error cases gracefully without any
+undefined behaviour */
+
 static __inline UWORD32 CLZ(UWORD32 u4_word)
 {
     if(u4_word)
     return(__builtin_clz(u4_word));
     else
-        return 32;
+        return 31;
 }
 
 static __inline UWORD32 CTZ(UWORD32 u4_word)
diff --git a/decoder/ih264d.h b/decoder/ih264d.h
index 7c76296..83f8a1f 100644
--- a/decoder/ih264d.h
+++ b/decoder/ih264d.h
@@ -40,31 +40,32 @@
 #ifndef _IH264D_H_
 #define _IH264D_H_
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 #include "iv.h"
 #include "ivd.h"
 
 
 /*****************************************************************************/
 /* Constant Macros                                                           */
 /*****************************************************************************/
+#define IVD_ERROR_MASK 0xFF
 
 /*****************************************************************************/
 /* Function Macros                                                           */
 /*****************************************************************************/
 #define IS_IVD_CONCEALMENT_APPLIED(x)       (x & (1 << IVD_APPLIEDCONCEALMENT))
 #define IS_IVD_INSUFFICIENTDATA_ERROR(x)    (x & (1 << IVD_INSUFFICIENTDATA))
 #define IS_IVD_CORRUPTEDDATA_ERROR(x)       (x & (1 << IVD_CORRUPTEDDATA))
 #define IS_IVD_CORRUPTEDHEADER_ERROR(x)     (x & (1 << IVD_CORRUPTEDHEADER))
 #define IS_IVD_UNSUPPORTEDINPUT_ERROR(x)    (x & (1 << IVD_UNSUPPORTEDINPUT))
 #define IS_IVD_UNSUPPORTEDPARAM_ERROR(x)    (x & (1 << IVD_UNSUPPORTEDPARAM))
 #define IS_IVD_FATAL_ERROR(x)               (x & (1 << IVD_FATALERROR))
 #define IS_IVD_INVALID_BITSTREAM_ERROR(x)   (x & (1 << IVD_INVALID_BITSTREAM))
 #define IS_IVD_INCOMPLETE_BITSTREAM_ERROR(x) (x & (1 << IVD_INCOMPLETE_BITSTREAM))
 
 
 /*****************************************************************************/
 /* API Function Prototype                                                    */
 /*****************************************************************************/
diff --git a/decoder/ih264d_api.c b/decoder/ih264d_api.c
index 057b5db..eef6e3a 100644
--- a/decoder/ih264d_api.c
+++ b/decoder/ih264d_api.c
@@ -898,248 +898,245 @@ WORD32 ih264d_set_processor(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)
 /**************************************************************************
  * \if Function name : ih264d_init_decoder \endif
  *
  *
  * \brief
  *    Initializes the decoder
  *
  * \param apiVersion               : Version of the api being used.
  * \param errorHandlingMechanism   : Mechanism to be used for errror handling.
  * \param postFilteringType: Type of post filtering operation to be used.
  * \param uc_outputFormat: Format of the decoded picture [default 4:2:0].
  * \param uc_dispBufs: Number of Display Buffers.
  * \param p_NALBufAPI: Pointer to NAL Buffer API.
  * \param p_DispBufAPI: Pointer to Display Buffer API.
  * \param ih264d_dec_mem_manager  :Pointer to the function that will be called by decoder
  *                        for memory allocation and freeing.
  *
  * \return
  *    0 on Success and -1 on error
  *
  **************************************************************************
  */
 void ih264d_init_decoder(void * ps_dec_params)
 {
     dec_struct_t * ps_dec = (dec_struct_t *)ps_dec_params;
     dec_slice_params_t *ps_cur_slice;
     pocstruct_t *ps_prev_poc, *ps_cur_poc;
     WORD32 size;
 
     size = sizeof(pred_info_t) * 2 * 32;
     memset(ps_dec->ps_pred, 0 , size);
 
     size = sizeof(disp_mgr_t);
     memset(ps_dec->pv_disp_buf_mgr, 0 , size);
 
     size = sizeof(buf_mgr_t) + ithread_get_mutex_lock_size();
     memset(ps_dec->pv_pic_buf_mgr, 0, size);
 
     size = sizeof(dec_err_status_t);
     memset(ps_dec->ps_dec_err_status, 0, size);
 
     size = sizeof(sei);
     memset(ps_dec->ps_sei, 0, size);
 
     size = sizeof(dpb_commands_t);
     memset(ps_dec->ps_dpb_cmds, 0, size);
 
     size = sizeof(dec_bit_stream_t);
     memset(ps_dec->ps_bitstrm, 0, size);
 
     size = sizeof(dec_slice_params_t);
     memset(ps_dec->ps_cur_slice, 0, size);
 
     size = MAX(sizeof(dec_seq_params_t), sizeof(dec_pic_params_t));
     memset(ps_dec->pv_scratch_sps_pps, 0, size);
 
     size = sizeof(ctxt_inc_mb_info_t);
     memset(ps_dec->ps_left_mb_ctxt_info, 0, size);
 
     size = (sizeof(neighbouradd_t) << 2);
     memset(ps_dec->ps_left_mvpred_addr, 0 ,size);
 
     size = sizeof(buf_mgr_t) + ithread_get_mutex_lock_size();
     memset(ps_dec->pv_mv_buf_mgr, 0, size);
 
     /* Free any dynamic buffers that are allocated */
     ih264d_free_dynamic_bufs(ps_dec);
 
     ps_cur_slice = ps_dec->ps_cur_slice;
     ps_dec->init_done = 0;
 
     ps_dec->u4_num_cores = 1;
 
     ps_dec->u2_pic_ht = ps_dec->u2_pic_wd = 0;
 
     ps_dec->u1_separate_parse = DEFAULT_SEPARATE_PARSE;
     ps_dec->u4_app_disable_deblk_frm = 0;
     ps_dec->i4_degrade_type = 0;
     ps_dec->i4_degrade_pics = 0;
 
-    ps_dec->i4_app_skip_mode = IVD_SKIP_NONE;
-    ps_dec->i4_dec_skip_mode = IVD_SKIP_NONE;
-
     memset(ps_dec->ps_pps, 0,
            ((sizeof(dec_pic_params_t)) * MAX_NUM_PIC_PARAMS));
     memset(ps_dec->ps_sps, 0,
            ((sizeof(dec_seq_params_t)) * MAX_NUM_SEQ_PARAMS));
 
     /* Initialization of function pointers ih264d_deblock_picture function*/
 
     ps_dec->p_DeblockPicture[0] = ih264d_deblock_picture_non_mbaff;
     ps_dec->p_DeblockPicture[1] = ih264d_deblock_picture_mbaff;
 
     ps_dec->s_cab_dec_env.pv_codec_handle = ps_dec;
 
     ps_dec->u4_num_fld_in_frm = 0;
 
     ps_dec->ps_dpb_mgr->pv_codec_handle = ps_dec;
 
     /* Initialize the sei validity u4_flag with zero indiacting sei is not valid*/
     ps_dec->ps_sei->u1_is_valid = 0;
 
     /* decParams Initializations */
     ps_dec->ps_cur_pps = NULL;
     ps_dec->ps_cur_sps = NULL;
     ps_dec->u1_init_dec_flag = 0;
     ps_dec->u1_first_slice_in_stream = 1;
     ps_dec->u1_last_pic_not_decoded = 0;
     ps_dec->u4_app_disp_width = 0;
     ps_dec->i4_header_decoded = 0;
     ps_dec->u4_total_frames_decoded = 0;
 
     ps_dec->i4_error_code = 0;
-    ps_dec->i4_content_type = -1;
+    ps_dec->i4_content_type = IV_CONTENTTYPE_NA;
     ps_dec->ps_cur_slice->u1_mbaff_frame_flag = 0;
 
     ps_dec->ps_dec_err_status->u1_err_flag = ACCEPT_ALL_PICS; //REJECT_PB_PICS;
     ps_dec->ps_dec_err_status->u1_cur_pic_type = PIC_TYPE_UNKNOWN;
     ps_dec->ps_dec_err_status->u4_frm_sei_sync = SYNC_FRM_DEFAULT;
     ps_dec->ps_dec_err_status->u4_cur_frm = INIT_FRAME;
     ps_dec->ps_dec_err_status->u1_pic_aud_i = PIC_TYPE_UNKNOWN;
 
     ps_dec->u1_pr_sl_type = 0xFF;
     ps_dec->u2_mbx = 0xffff;
     ps_dec->u2_mby = 0;
     ps_dec->u2_total_mbs_coded = 0;
 
     /* POC initializations */
     ps_prev_poc = &ps_dec->s_prev_pic_poc;
     ps_cur_poc = &ps_dec->s_cur_pic_poc;
     ps_prev_poc->i4_pic_order_cnt_lsb = ps_cur_poc->i4_pic_order_cnt_lsb = 0;
     ps_prev_poc->i4_pic_order_cnt_msb = ps_cur_poc->i4_pic_order_cnt_msb = 0;
     ps_prev_poc->i4_delta_pic_order_cnt_bottom =
                     ps_cur_poc->i4_delta_pic_order_cnt_bottom = 0;
     ps_prev_poc->i4_delta_pic_order_cnt[0] =
                     ps_cur_poc->i4_delta_pic_order_cnt[0] = 0;
     ps_prev_poc->i4_delta_pic_order_cnt[1] =
                     ps_cur_poc->i4_delta_pic_order_cnt[1] = 0;
     ps_prev_poc->u1_mmco_equalto5 = ps_cur_poc->u1_mmco_equalto5 = 0;
     ps_prev_poc->i4_top_field_order_count = ps_cur_poc->i4_top_field_order_count =
                     0;
     ps_prev_poc->i4_bottom_field_order_count =
                     ps_cur_poc->i4_bottom_field_order_count = 0;
     ps_prev_poc->u1_bot_field = ps_cur_poc->u1_bot_field = 0;
     ps_prev_poc->u1_mmco_equalto5 = ps_cur_poc->u1_mmco_equalto5 = 0;
     ps_prev_poc->i4_prev_frame_num_ofst = ps_cur_poc->i4_prev_frame_num_ofst = 0;
     ps_cur_slice->u1_mmco_equalto5 = 0;
     ps_cur_slice->u2_frame_num = 0;
 
     ps_dec->i4_max_poc = 0;
     ps_dec->i4_prev_max_display_seq = 0;
     ps_dec->u1_recon_mb_grp = 4;
 
     /* Field PIC initializations */
     ps_dec->u1_second_field = 0;
     ps_dec->s_prev_seq_params.u1_eoseq_pending = 0;
 
     /* Set the cropping parameters as zero */
     ps_dec->u2_crop_offset_y = 0;
     ps_dec->u2_crop_offset_uv = 0;
 
     /* The Initial Frame Rate Info is not Present */
     ps_dec->i4_vui_frame_rate = -1;
-    ps_dec->i4_pic_type = -1;
-    ps_dec->i4_frametype = -1;
-    ps_dec->i4_content_type = -1;
+    ps_dec->i4_pic_type = NA_SLICE;
+    ps_dec->i4_frametype = IV_NA_FRAME;
+    ps_dec->i4_content_type = IV_CONTENTTYPE_NA;
 
     ps_dec->u1_res_changed = 0;
 
 
     ps_dec->u1_frame_decoded_flag = 0;
 
     /* Set the default frame seek mask mode */
     ps_dec->u4_skip_frm_mask = SKIP_NONE;
 
     /********************************************************/
     /* Initialize CAVLC residual decoding function pointers */
     /********************************************************/
     ps_dec->pf_cavlc_4x4res_block[0] = ih264d_cavlc_4x4res_block_totalcoeff_1;
     ps_dec->pf_cavlc_4x4res_block[1] =
                     ih264d_cavlc_4x4res_block_totalcoeff_2to10;
     ps_dec->pf_cavlc_4x4res_block[2] =
                     ih264d_cavlc_4x4res_block_totalcoeff_11to16;
 
     ps_dec->pf_cavlc_parse4x4coeff[0] = ih264d_cavlc_parse4x4coeff_n0to7;
     ps_dec->pf_cavlc_parse4x4coeff[1] = ih264d_cavlc_parse4x4coeff_n8;
 
     ps_dec->pf_cavlc_parse_8x8block[0] =
                     ih264d_cavlc_parse_8x8block_none_available;
     ps_dec->pf_cavlc_parse_8x8block[1] =
                     ih264d_cavlc_parse_8x8block_left_available;
     ps_dec->pf_cavlc_parse_8x8block[2] =
                     ih264d_cavlc_parse_8x8block_top_available;
     ps_dec->pf_cavlc_parse_8x8block[3] =
                     ih264d_cavlc_parse_8x8block_both_available;
 
     /***************************************************************************/
     /* Initialize Bs calculation function pointers for P and B, 16x16/non16x16 */
     /***************************************************************************/
     ps_dec->pf_fill_bs1[0][0] = ih264d_fill_bs1_16x16mb_pslice;
     ps_dec->pf_fill_bs1[0][1] = ih264d_fill_bs1_non16x16mb_pslice;
 
     ps_dec->pf_fill_bs1[1][0] = ih264d_fill_bs1_16x16mb_bslice;
     ps_dec->pf_fill_bs1[1][1] = ih264d_fill_bs1_non16x16mb_bslice;
 
     ps_dec->pf_fill_bs_xtra_left_edge[0] =
                     ih264d_fill_bs_xtra_left_edge_cur_frm;
     ps_dec->pf_fill_bs_xtra_left_edge[1] =
                     ih264d_fill_bs_xtra_left_edge_cur_fld;
 
     /* Initialize Reference Pic Buffers */
     ih264d_init_ref_bufs(ps_dec->ps_dpb_mgr);
 
     ps_dec->u2_prv_frame_num = 0;
     ps_dec->u1_top_bottom_decoded = 0;
     ps_dec->u1_dangling_field = 0;
 
     ps_dec->s_cab_dec_env.cabac_table = gau4_ih264d_cabac_table;
 
     ps_dec->pu1_left_mv_ctxt_inc = ps_dec->u1_left_mv_ctxt_inc_arr[0];
     ps_dec->pi1_left_ref_idx_ctxt_inc =
                     &ps_dec->i1_left_ref_idx_ctx_inc_arr[0][0];
     ps_dec->pu1_left_yuv_dc_csbp = &ps_dec->u1_yuv_dc_csbp_topmb;
 
     /* ! */
     /* Initializing flush frame u4_flag */
     ps_dec->u1_flushfrm = 0;
 
     {
         ps_dec->s_cab_dec_env.pv_codec_handle = (void*)ps_dec;
         ps_dec->ps_bitstrm->pv_codec_handle = (void*)ps_dec;
         ps_dec->ps_cur_slice->pv_codec_handle = (void*)ps_dec;
         ps_dec->ps_dpb_mgr->pv_codec_handle = (void*)ps_dec;
     }
 
     memset(ps_dec->disp_bufs, 0, (MAX_DISP_BUFS_NEW) * sizeof(disp_buf_t));
     memset(ps_dec->u4_disp_buf_mapping, 0,
            (MAX_DISP_BUFS_NEW) * sizeof(UWORD32));
     memset(ps_dec->u4_disp_buf_to_be_freed, 0,
            (MAX_DISP_BUFS_NEW) * sizeof(UWORD32));
     memset(ps_dec->ps_cur_slice, 0, sizeof(dec_slice_params_t));
 
     ih264d_init_arch(ps_dec);
     ih264d_init_function_ptr(ps_dec);
     ps_dec->e_frm_out_mode = IVD_DISPLAY_FRAME_OUT;
     ps_dec->init_done = 1;
 
 }
@@ -1187,455 +1184,483 @@ WORD32 ih264d_free_static_bufs(iv_obj_t *dec_hdl)
     if(dec_hdl)
     {
         pf_aligned_free(pv_mem_ctxt, dec_hdl);
     }
     return IV_SUCCESS;
 }
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : ih264d_create                                              */
 /*                                                                           */
 /*  Description   : creates decoder                                          */
 /*                                                                           */
 /*  Inputs        :iv_obj_t decoder handle                                   */
 /*                :pv_api_ip pointer to input structure                      */
 /*                :pv_api_op pointer to output structure                     */
 /*  Outputs       :                                                          */
 /*  Returns       : void                                                     */
 /*                                                                           */
 /*  Issues        : none                                                     */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         22 10 2008    100356         Draft                                */
 /*                                                                           */
 /*****************************************************************************/
 WORD32 ih264d_allocate_static_bufs(iv_obj_t **dec_hdl, void *pv_api_ip, void *pv_api_op)
 {
     ih264d_create_ip_t *ps_create_ip;
     ih264d_create_op_t *ps_create_op;
     void *pv_buf;
     UWORD8 *pu1_buf;
     dec_struct_t *ps_dec;
     void *(*pf_aligned_alloc)(void *pv_mem_ctxt, WORD32 alignment, WORD32 size);
     void (*pf_aligned_free)(void *pv_mem_ctxt, void *pv_buf);
     void *pv_mem_ctxt;
     WORD32 size;
 
     ps_create_ip = (ih264d_create_ip_t *)pv_api_ip;
     ps_create_op = (ih264d_create_op_t *)pv_api_op;
 
     ps_create_op->s_ivd_create_op_t.u4_error_code = 0;
 
     pf_aligned_alloc = ps_create_ip->s_ivd_create_ip_t.pf_aligned_alloc;
     pf_aligned_free = ps_create_ip->s_ivd_create_ip_t.pf_aligned_free;
     pv_mem_ctxt  = ps_create_ip->s_ivd_create_ip_t.pv_mem_ctxt;
 
     /* Initialize return handle to NULL */
     ps_create_op->s_ivd_create_op_t.pv_handle = NULL;
     pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, sizeof(iv_obj_t));
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, sizeof(iv_obj_t));
     *dec_hdl = (iv_obj_t *)pv_buf;
     ps_create_op->s_ivd_create_op_t.pv_handle = *dec_hdl;
 
     (*dec_hdl)->pv_codec_handle = NULL;
     pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, sizeof(dec_struct_t));
     RETURN_IF((NULL == pv_buf), IV_FAIL);
     (*dec_hdl)->pv_codec_handle = (dec_struct_t *)pv_buf;
     ps_dec = (dec_struct_t *)pv_buf;
 
     memset(ps_dec, 0, sizeof(dec_struct_t));
 
 #ifndef LOGO_EN
     ps_dec->u4_share_disp_buf = ps_create_ip->s_ivd_create_ip_t.u4_share_disp_buf;
 #else
     ps_dec->u4_share_disp_buf = 0;
 #endif
 
     ps_dec->u1_chroma_format =
                     (UWORD8)(ps_create_ip->s_ivd_create_ip_t.e_output_format);
 
     if((ps_dec->u1_chroma_format != IV_YUV_420P)
                     && (ps_dec->u1_chroma_format
                                     != IV_YUV_420SP_UV)
                     && (ps_dec->u1_chroma_format
                                     != IV_YUV_420SP_VU))
     {
         ps_dec->u4_share_disp_buf = 0;
     }
 
     ps_dec->pf_aligned_alloc = pf_aligned_alloc;
     ps_dec->pf_aligned_free = pf_aligned_free;
     ps_dec->pv_mem_ctxt = pv_mem_ctxt;
 
 
     size = ((sizeof(dec_seq_params_t)) * MAX_NUM_SEQ_PARAMS);
     pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->ps_sps = pv_buf;
 
     size = (sizeof(dec_pic_params_t)) * MAX_NUM_PIC_PARAMS;
     pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->ps_pps = pv_buf;
 
     size = ithread_get_handle_size();
     pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->pv_dec_thread_handle = pv_buf;
 
     size = ithread_get_handle_size();
     pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->pv_bs_deblk_thread_handle = pv_buf;
 
     size = sizeof(dpb_manager_t);
     pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->ps_dpb_mgr = pv_buf;
 
     size = sizeof(pred_info_t) * 2 * 32;
     pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->ps_pred = pv_buf;
 
     size = sizeof(disp_mgr_t);
     pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->pv_disp_buf_mgr = pv_buf;
 
     size = sizeof(buf_mgr_t) + ithread_get_mutex_lock_size();
     pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->pv_pic_buf_mgr = pv_buf;
 
     size = sizeof(struct pic_buffer_t) * (H264_MAX_REF_PICS * 2);
     pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->ps_pic_buf_base = pv_buf;
 
     size = sizeof(dec_err_status_t);
     pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->ps_dec_err_status = (dec_err_status_t *)pv_buf;
 
     size = sizeof(sei);
     pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->ps_sei = (sei *)pv_buf;
 
     size = sizeof(dpb_commands_t);
     pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->ps_dpb_cmds = (dpb_commands_t *)pv_buf;
 
     size = sizeof(dec_bit_stream_t);
     pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->ps_bitstrm = (dec_bit_stream_t *)pv_buf;
 
     size = sizeof(dec_slice_params_t);
     pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->ps_cur_slice = (dec_slice_params_t *)pv_buf;
 
     size = MAX(sizeof(dec_seq_params_t), sizeof(dec_pic_params_t));
     pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->pv_scratch_sps_pps = pv_buf;
 
 
     ps_dec->u4_static_bits_buf_size = 256000;
     pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, ps_dec->u4_static_bits_buf_size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, ps_dec->u4_static_bits_buf_size);
     ps_dec->pu1_bits_buf_static = pv_buf;
 
 
     size = ((TOTAL_LIST_ENTRIES + PAD_MAP_IDX_POC)
                         * sizeof(void *));
     pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
     ps_dec->ppv_map_ref_idx_to_poc_base = pv_buf;
     memset(ps_dec->ppv_map_ref_idx_to_poc_base, 0, size);
 
     ps_dec->ppv_map_ref_idx_to_poc = ps_dec->ppv_map_ref_idx_to_poc_base + OFFSET_MAP_IDX_POC;
 
 
     size = (sizeof(bin_ctxt_model_t) * NUM_CABAC_CTXTS);
     pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->p_cabac_ctxt_table_t = pv_buf;
 
 
 
     size = sizeof(ctxt_inc_mb_info_t);
     pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->ps_left_mb_ctxt_info = pv_buf;
 
 
 
     size = MAX_REF_BUF_SIZE * 2;
     pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->pu1_ref_buff_base = pv_buf;
     ps_dec->pu1_ref_buff = ps_dec->pu1_ref_buff_base + MAX_REF_BUF_SIZE;
 
 
     size = ((sizeof(WORD16)) * PRED_BUFFER_WIDTH
                         * PRED_BUFFER_HEIGHT * 2);
     pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->pi2_pred1 = pv_buf;
 
 
     size = sizeof(UWORD8) * (MB_LUM_SIZE);
     pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->pu1_temp_mc_buffer = pv_buf;
 
 
 
 
     size = 8 * MAX_REF_BUFS * sizeof(struct pic_buffer_t);
     pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
 
     ps_dec->pu1_init_dpb_base = pv_buf;
     pu1_buf = pv_buf;
     ps_dec->ps_dpb_mgr->ps_init_dpb[0][0] = (struct pic_buffer_t *)pu1_buf;
 
     pu1_buf += size / 2;
     ps_dec->ps_dpb_mgr->ps_init_dpb[1][0] = (struct pic_buffer_t *)pu1_buf;
 
     size = (sizeof(UWORD32) * 2 * 3
                         * ((MAX_FRAMES << 1) * (MAX_FRAMES << 1)) * 2);
     pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->pu4_mbaff_wt_mat = pv_buf;
 
     size = sizeof(UWORD32) * 2 * 3
                         * ((MAX_FRAMES << 1) * (MAX_FRAMES << 1));
     pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->pu4_wts_ofsts_mat = pv_buf;
 
 
     size = (sizeof(neighbouradd_t) << 2);
     pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->ps_left_mvpred_addr = pv_buf;
 
 
     size = sizeof(buf_mgr_t) + ithread_get_mutex_lock_size();
     pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->pv_mv_buf_mgr = pv_buf;
 
 
     size =  sizeof(col_mv_buf_t) * (H264_MAX_REF_PICS * 2);
     pv_buf = pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
     ps_dec->ps_col_mv_base = pv_buf;
     memset(ps_dec->ps_col_mv_base, 0, size);
 
     {
         UWORD8 i;
         struct pic_buffer_t *ps_init_dpb;
         ps_init_dpb = ps_dec->ps_dpb_mgr->ps_init_dpb[0][0];
         for(i = 0; i < 2 * MAX_REF_BUFS; i++)
         {
             ps_init_dpb->pu1_buf1 = NULL;
             ps_init_dpb->u1_long_term_frm_idx = MAX_REF_BUFS + 1;
             ps_dec->ps_dpb_mgr->ps_init_dpb[0][i] = ps_init_dpb;
             ps_dec->ps_dpb_mgr->ps_mod_dpb[0][i] = ps_init_dpb;
             ps_init_dpb++;
         }
 
         ps_init_dpb = ps_dec->ps_dpb_mgr->ps_init_dpb[1][0];
         for(i = 0; i < 2 * MAX_REF_BUFS; i++)
         {
             ps_init_dpb->pu1_buf1 = NULL;
             ps_init_dpb->u1_long_term_frm_idx = MAX_REF_BUFS + 1;
             ps_dec->ps_dpb_mgr->ps_init_dpb[1][i] = ps_init_dpb;
             ps_dec->ps_dpb_mgr->ps_mod_dpb[1][i] = ps_init_dpb;
             ps_init_dpb++;
         }
     }
     ih264d_init_decoder(ps_dec);
 
     return IV_SUCCESS;
 }
 
 
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : ih264d_create                                              */
 /*                                                                           */
 /*  Description   : creates decoder                                          */
 /*                                                                           */
 /*  Inputs        :iv_obj_t decoder handle                                   */
 /*                :pv_api_ip pointer to input structure                      */
 /*                :pv_api_op pointer to output structure                     */
 /*  Outputs       :                                                          */
 /*  Returns       : void                                                     */
 /*                                                                           */
 /*  Issues        : none                                                     */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         22 10 2008    100356         Draft                                */
 /*                                                                           */
 /*****************************************************************************/
 WORD32 ih264d_create(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)
 {
     ih264d_create_ip_t *ps_create_ip;
     ih264d_create_op_t *ps_create_op;
 
     WORD32 ret;
 
     ps_create_ip = (ih264d_create_ip_t *)pv_api_ip;
     ps_create_op = (ih264d_create_op_t *)pv_api_op;
 
     ps_create_op->s_ivd_create_op_t.u4_error_code = 0;
     dec_hdl = NULL;
     ret = ih264d_allocate_static_bufs(&dec_hdl, pv_api_ip, pv_api_op);
 
     /* If allocation of some buffer fails, then free buffers allocated till then */
     if(IV_FAIL == ret)
     {
         if(dec_hdl)
         {
             if(dec_hdl->pv_codec_handle)
             {
                 ih264d_free_static_bufs(dec_hdl);
             }
             else
             {
                 void (*pf_aligned_free)(void *pv_mem_ctxt, void *pv_buf);
                 void *pv_mem_ctxt;
 
                 pf_aligned_free = ps_create_ip->s_ivd_create_ip_t.pf_aligned_free;
                 pv_mem_ctxt  = ps_create_ip->s_ivd_create_ip_t.pv_mem_ctxt;
                 pf_aligned_free(pv_mem_ctxt, dec_hdl);
             }
         }
         ps_create_op->s_ivd_create_op_t.u4_error_code = IVD_MEM_ALLOC_FAILED;
-        ps_create_op->s_ivd_create_op_t.u4_error_code = 1 << IVD_FATALERROR;
+        ps_create_op->s_ivd_create_op_t.u4_error_code |= 1 << IVD_FATALERROR;
 
         return IV_FAIL;
     }
 
     return IV_SUCCESS;
 }
 
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name :  ih264d_map_error                                        */
 /*                                                                           */
 /*  Description   :  Maps error codes to IVD error groups                    */
 /*                                                                           */
 /*  Inputs        :                                                          */
 /*  Globals       : <Does it use any global variables?>                      */
 /*  Outputs       :                                                          */
 /*  Returns       : void                                                     */
 /*                                                                           */
 /*  Issues        : none                                                     */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         22 10 2008    100356         Draft                                */
 /*                                                                           */
 /*****************************************************************************/
 UWORD32 ih264d_map_error(UWORD32 i4_err_status)
 {
     UWORD32 temp = 0;
 
     switch(i4_err_status)
     {
         case ERROR_MEM_ALLOC_ISRAM_T:
         case ERROR_MEM_ALLOC_SDRAM_T:
         case ERROR_BUF_MGR:
         case ERROR_MB_GROUP_ASSGN_T:
         case ERROR_FRAME_LIMIT_OVER:
         case ERROR_ACTUAL_RESOLUTION_GREATER_THAN_INIT:
         case ERROR_PROFILE_NOT_SUPPORTED:
         case ERROR_INIT_NOT_DONE:
         case IVD_MEM_ALLOC_FAILED:
+        case ERROR_FEATURE_UNAVAIL:
+        case IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED:
             temp = 1 << IVD_FATALERROR;
             H264_DEC_DEBUG_PRINT("\nFatal Error\n");
             break;
 
         case ERROR_DBP_MANAGER_T:
         case ERROR_GAPS_IN_FRM_NUM:
         case ERROR_UNKNOWN_NAL:
         case ERROR_INV_MB_SLC_GRP_T:
         case ERROR_MULTIPLE_SLC_GRP_T:
         case ERROR_UNKNOWN_LEVEL:
         case ERROR_UNAVAIL_PICBUF_T:
         case ERROR_UNAVAIL_MVBUF_T:
         case ERROR_UNAVAIL_DISPBUF_T:
         case ERROR_NUM_REF:
         case ERROR_REFIDX_ORDER_T:
         case ERROR_PIC0_NOT_FOUND_T:
         case ERROR_MB_TYPE:
         case ERROR_SUB_MB_TYPE:
         case ERROR_CBP:
         case ERROR_REF_IDX:
         case ERROR_NUM_MV:
         case ERROR_CHROMA_PRED_MODE:
         case ERROR_INTRAPRED:
         case ERROR_NEXT_MB_ADDRESS_T:
         case ERROR_MB_ADDRESS_T:
         case ERROR_PIC1_NOT_FOUND_T:
         case ERROR_CAVLC_NUM_COEFF_T:
         case ERROR_CAVLC_SCAN_POS_T:
         case ERROR_PRED_WEIGHT_TABLE_T:
         case ERROR_CORRUPTED_SLICE:
             temp = 1 << IVD_CORRUPTEDDATA;
             break;
 
         case ERROR_NOT_SUPP_RESOLUTION:
-        case ERROR_FEATURE_UNAVAIL:
         case ERROR_ACTUAL_LEVEL_GREATER_THAN_INIT:
             temp = 1 << IVD_UNSUPPORTEDINPUT;
             break;
 
         case ERROR_INVALID_PIC_PARAM:
         case ERROR_INVALID_SEQ_PARAM:
         case ERROR_EGC_EXCEED_32_1_T:
         case ERROR_EGC_EXCEED_32_2_T:
         case ERROR_INV_RANGE_TEV_T:
         case ERROR_INV_SLC_TYPE_T:
         case ERROR_INV_POC_TYPE_T:
         case ERROR_INV_RANGE_QP_T:
         case ERROR_INV_SPS_PPS_T:
         case ERROR_INV_SLICE_HDR_T:
             temp = 1 << IVD_CORRUPTEDHEADER;
             break;
 
         case ERROR_EOB_FLUSHBITS_T:
         case ERROR_EOB_GETBITS_T:
         case ERROR_EOB_GETBIT_T:
         case ERROR_EOB_BYPASS_T:
         case ERROR_EOB_DECISION_T:
         case ERROR_EOB_TERMINATE_T:
         case ERROR_EOB_READCOEFF4X4CAB_T:
             temp = 1 << IVD_INSUFFICIENTDATA;
             break;
         case ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED:
         case ERROR_DISP_WIDTH_RESET_TO_PIC_WIDTH:
             temp = 1 << IVD_UNSUPPORTEDPARAM | 1 << IVD_FATALERROR;
             break;
 
         case ERROR_DANGLING_FIELD_IN_PIC:
             temp = 1 << IVD_APPLIEDCONCEALMENT;
             break;
 
     }
 
     return temp;
 
 }
@@ -1767,828 +1792,741 @@ WORD32 check_app_out_buf_size(dec_struct_t *ps_dec)
 WORD32 ih264d_video_decode(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)
 {
     /* ! */
 
     dec_struct_t * ps_dec = (dec_struct_t *)(dec_hdl->pv_codec_handle);
 
     WORD32 i4_err_status = 0;
     UWORD8 *pu1_buf = NULL;
     WORD32 buflen;
     UWORD32 u4_max_ofst, u4_length_of_start_code = 0;
 
     UWORD32 bytes_consumed = 0;
     UWORD32 cur_slice_is_nonref = 0;
     UWORD32 u4_next_is_aud;
     UWORD32 u4_first_start_code_found = 0;
     WORD32 ret = 0,api_ret_value = IV_SUCCESS;
     WORD32 header_data_left = 0,frame_data_left = 0;
     UWORD8 *pu1_bitstrm_buf;
     ivd_video_decode_ip_t *ps_dec_ip;
     ivd_video_decode_op_t *ps_dec_op;
 
     ithread_set_name((void*)"Parse_thread");
 
     ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;
     ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;
 
     {
         UWORD32 u4_size;
         u4_size = ps_dec_op->u4_size;
         memset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t));
         ps_dec_op->u4_size = u4_size;
     }
 
     ps_dec->pv_dec_out = ps_dec_op;
     if(ps_dec->init_done != 1)
     {
         return IV_FAIL;
     }
 
     /*Data memory barries instruction,so that bitstream write by the application is complete*/
     DATA_SYNC();
 
     if(0 == ps_dec->u1_flushfrm)
     {
         if(ps_dec_ip->pv_stream_buffer == NULL)
         {
             ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
             ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;
             return IV_FAIL;
         }
         if(ps_dec_ip->u4_num_Bytes <= 0)
         {
             ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
             ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;
             return IV_FAIL;
 
         }
     }
     ps_dec->u1_pic_decode_done = 0;
 
     ps_dec_op->u4_num_bytes_consumed = 0;
 
     ps_dec->ps_out_buffer = NULL;
 
     if(ps_dec_ip->u4_size
                     >= offsetof(ivd_video_decode_ip_t, s_out_buffer))
         ps_dec->ps_out_buffer = &ps_dec_ip->s_out_buffer;
 
     ps_dec->u4_fmt_conv_cur_row = 0;
 
     ps_dec->u4_output_present = 0;
     ps_dec->s_disp_op.u4_error_code = 1;
     ps_dec->u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS;
     if(0 == ps_dec->u4_share_disp_buf
                     && ps_dec->i4_decode_header == 0)
     {
         UWORD32 i;
         if((ps_dec->ps_out_buffer->u4_num_bufs == 0) ||
            (ps_dec->ps_out_buffer->u4_num_bufs > IVD_VIDDEC_MAX_IO_BUFFERS))
         {
             ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
             ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;
             return IV_FAIL;
         }
 
         for(i = 0; i < ps_dec->ps_out_buffer->u4_num_bufs; i++)
         {
             if(ps_dec->ps_out_buffer->pu1_bufs[i] == NULL)
             {
                 ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                 ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;
                 return IV_FAIL;
             }
 
             if(ps_dec->ps_out_buffer->u4_min_out_buf_size[i] == 0)
             {
                 ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                 ps_dec_op->u4_error_code |=
                                 IVD_DISP_FRM_ZERO_OP_BUF_SIZE;
                 return IV_FAIL;
             }
         }
     }
 
     if(ps_dec->u4_total_frames_decoded >= NUM_FRAMES_LIMIT)
     {
         ps_dec_op->u4_error_code = ERROR_FRAME_LIMIT_OVER;
         return IV_FAIL;
     }
 
     /* ! */
     ps_dec->u4_ts = ps_dec_ip->u4_ts;
 
     ps_dec_op->u4_error_code = 0;
-    ps_dec_op->e_pic_type = -1;
+    ps_dec_op->e_pic_type = IV_NA_FRAME;
     ps_dec_op->u4_output_present = 0;
     ps_dec_op->u4_frame_decoded_flag = 0;
 
-    ps_dec->i4_frametype = -1;
-    ps_dec->i4_content_type = -1;
+    ps_dec->i4_frametype = IV_NA_FRAME;
+    ps_dec->i4_content_type = IV_CONTENTTYPE_NA;
 
     ps_dec->u4_slice_start_code_found = 0;
 
     /* In case the deocder is not in flush mode(in shared mode),
      then decoder has to pick up a buffer to write current frame.
      Check if a frame is available in such cases */
 
     if(ps_dec->u1_init_dec_flag == 1 && ps_dec->u4_share_disp_buf == 1
                     && ps_dec->u1_flushfrm == 0)
     {
         UWORD32 i;
 
         WORD32 disp_avail = 0, free_id;
 
         /* Check if at least one buffer is available with the codec */
         /* If not then return to application with error */
         for(i = 0; i < ps_dec->u1_pic_bufs; i++)
         {
             if(0 == ps_dec->u4_disp_buf_mapping[i]
                             || 1 == ps_dec->u4_disp_buf_to_be_freed[i])
             {
                 disp_avail = 1;
                 break;
             }
 
         }
 
         if(0 == disp_avail)
         {
             /* If something is queued for display wait for that buffer to be returned */
 
             ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;
             ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
             return (IV_FAIL);
         }
 
         while(1)
         {
             pic_buffer_t *ps_pic_buf;
             ps_pic_buf = (pic_buffer_t *)ih264_buf_mgr_get_next_free(
                             (buf_mgr_t *)ps_dec->pv_pic_buf_mgr, &free_id);
 
             if(ps_pic_buf == NULL)
             {
                 UWORD32 i, display_queued = 0;
 
                 /* check if any buffer was given for display which is not returned yet */
                 for(i = 0; i < (MAX_DISP_BUFS_NEW); i++)
                 {
                     if(0 != ps_dec->u4_disp_buf_mapping[i])
                     {
                         display_queued = 1;
                         break;
                     }
                 }
                 /* If some buffer is queued for display, then codec has to singal an error and wait
                  for that buffer to be returned.
                  If nothing is queued for display then codec has ownership of all display buffers
                  and it can reuse any of the existing buffers and continue decoding */
 
                 if(1 == display_queued)
                 {
                     /* If something is queued for display wait for that buffer to be returned */
                     ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;
                     ps_dec_op->u4_error_code |= (1
                                     << IVD_UNSUPPORTEDPARAM);
                     return (IV_FAIL);
                 }
             }
             else
             {
                 /* If the buffer is with display, then mark it as in use and then look for a buffer again */
                 if(1 == ps_dec->u4_disp_buf_mapping[free_id])
                 {
                     ih264_buf_mgr_set_status(
                                     (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                                     free_id,
                                     BUF_MGR_IO);
                 }
                 else
                 {
                     /**
                      *  Found a free buffer for present call. Release it now.
                      *  Will be again obtained later.
                      */
                     ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                                           free_id,
                                           BUF_MGR_IO);
                     break;
                 }
             }
         }
 
     }
 
     if(ps_dec->u1_flushfrm)
     {
         if(ps_dec->u1_init_dec_flag == 0)
         {
             /*Come out of flush mode and return*/
             ps_dec->u1_flushfrm = 0;
             return (IV_FAIL);
         }
 
 
 
         ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,
                                       &(ps_dec->s_disp_op));
         if(0 == ps_dec->s_disp_op.u4_error_code)
         {
             /* check output buffer size given by the application */
             if(check_app_out_buf_size(ps_dec) != IV_SUCCESS)
             {
                 ps_dec_op->u4_error_code= IVD_DISP_FRM_ZERO_OP_BUF_SIZE;
                 return (IV_FAIL);
             }
 
             ps_dec->u4_fmt_conv_cur_row = 0;
             ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht;
             ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),
                                   ps_dec->u4_fmt_conv_cur_row,
                                   ps_dec->u4_fmt_conv_num_rows);
             ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;
             ps_dec->u4_output_present = 1;
 
         }
         ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));
 
         ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;
         ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;
 
         ps_dec_op->u4_new_seq = 0;
 
         ps_dec_op->u4_output_present = ps_dec->u4_output_present;
         ps_dec_op->u4_progressive_frame_flag =
                         ps_dec->s_disp_op.u4_progressive_frame_flag;
         ps_dec_op->e_output_format =
                         ps_dec->s_disp_op.e_output_format;
         ps_dec_op->s_disp_frm_buf = ps_dec->s_disp_op.s_disp_frm_buf;
         ps_dec_op->e4_fld_type = ps_dec->s_disp_op.e4_fld_type;
         ps_dec_op->u4_ts = ps_dec->s_disp_op.u4_ts;
         ps_dec_op->u4_disp_buf_id = ps_dec->s_disp_op.u4_disp_buf_id;
 
         /*In the case of flush ,since no frame is decoded set pic type as invalid*/
         ps_dec_op->u4_is_ref_flag = -1;
         ps_dec_op->e_pic_type = IV_NA_FRAME;
         ps_dec_op->u4_frame_decoded_flag = 0;
 
         if(0 == ps_dec->s_disp_op.u4_error_code)
         {
             return (IV_SUCCESS);
         }
         else
             return (IV_FAIL);
 
     }
     if(ps_dec->u1_res_changed == 1)
     {
         /*if resolution has changed and all buffers have been flushed, reset decoder*/
         ih264d_init_decoder(ps_dec);
     }
 
-    ps_dec->u4_prev_nal_skipped = 0;
-
     ps_dec->u2_cur_mb_addr = 0;
     ps_dec->u2_total_mbs_coded = 0;
     ps_dec->u2_cur_slice_num = 0;
     ps_dec->cur_dec_mb_num = 0;
     ps_dec->cur_recon_mb_num = 0;
     ps_dec->u4_first_slice_in_pic = 1;
     ps_dec->u1_slice_header_done = 0;
     ps_dec->u1_dangling_field = 0;
 
     ps_dec->u4_dec_thread_created = 0;
     ps_dec->u4_bs_deblk_thread_created = 0;
     ps_dec->u4_cur_bs_mb_num = 0;
     ps_dec->u4_start_recon_deblk  = 0;
     ps_dec->u4_sps_cnt_in_process = 0;
 
     DEBUG_THREADS_PRINTF(" Starting process call\n");
 
 
     ps_dec->u4_pic_buf_got = 0;
 
     do
     {
         WORD32 buf_size;
 
         pu1_buf = (UWORD8*)ps_dec_ip->pv_stream_buffer
                         + ps_dec_op->u4_num_bytes_consumed;
 
         u4_max_ofst = ps_dec_ip->u4_num_Bytes
                         - ps_dec_op->u4_num_bytes_consumed;
 
         /* If dynamic bitstream buffer is not allocated and
          * header decode is done, then allocate dynamic bitstream buffer
          */
         if((NULL == ps_dec->pu1_bits_buf_dynamic) &&
            (ps_dec->i4_header_decoded & 1))
         {
             WORD32 size;
 
             void *pv_buf;
             void *pv_mem_ctxt = ps_dec->pv_mem_ctxt;
             size = MAX(256000, ps_dec->u2_pic_wd * ps_dec->u2_pic_ht * 3 / 2);
             pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128,
                                               size + EXTRA_BS_OFFSET);
             RETURN_IF((NULL == pv_buf), IV_FAIL);
+            memset(pv_buf, 0, size + EXTRA_BS_OFFSET);
             ps_dec->pu1_bits_buf_dynamic = pv_buf;
             ps_dec->u4_dynamic_bits_buf_size = size;
         }
 
         if(ps_dec->pu1_bits_buf_dynamic)
         {
             pu1_bitstrm_buf = ps_dec->pu1_bits_buf_dynamic;
             buf_size = ps_dec->u4_dynamic_bits_buf_size;
         }
         else
         {
             pu1_bitstrm_buf = ps_dec->pu1_bits_buf_static;
             buf_size = ps_dec->u4_static_bits_buf_size;
         }
 
         u4_next_is_aud = 0;
 
         buflen = ih264d_find_start_code(pu1_buf, 0, u4_max_ofst,
                                                &u4_length_of_start_code,
                                                &u4_next_is_aud);
 
         if(buflen == -1)
             buflen = 0;
         /* Ignore bytes beyond the allocated size of intermediate buffer */
         /* Since 8 bytes are read ahead, ensure 8 bytes are free at the
         end of the buffer, which will be memset to 0 after emulation prevention */
         buflen = MIN(buflen, buf_size - 8);
 
         bytes_consumed = buflen + u4_length_of_start_code;
         ps_dec_op->u4_num_bytes_consumed += bytes_consumed;
 
-        {
-            UWORD8 u1_firstbyte, u1_nal_ref_idc;
-
-            if(ps_dec->i4_app_skip_mode == IVD_SKIP_B)
-            {
-                u1_firstbyte = *(pu1_buf + u4_length_of_start_code);
-                u1_nal_ref_idc = (UWORD8)(NAL_REF_IDC(u1_firstbyte));
-                if(u1_nal_ref_idc == 0)
-                {
-                    /*skip non reference frames*/
-                    cur_slice_is_nonref = 1;
-                    continue;
-                }
-                else
-                {
-                    if(1 == cur_slice_is_nonref)
-                    {
-                        /*We have encountered a referenced frame,return to app*/
-                        ps_dec_op->u4_num_bytes_consumed -=
-                                        bytes_consumed;
-                        ps_dec_op->e_pic_type = IV_B_FRAME;
-                        ps_dec_op->u4_error_code =
-                                        IVD_DEC_FRM_SKIPPED;
-                        ps_dec_op->u4_error_code |= (1
-                                        << IVD_UNSUPPORTEDPARAM);
-                        ps_dec_op->u4_frame_decoded_flag = 0;
-                        ps_dec_op->u4_size =
-                                        sizeof(ivd_video_decode_op_t);
-                        /*signal the decode thread*/
-                        ih264d_signal_decode_thread(ps_dec);
-                        /* close deblock thread if it is not closed yet*/
-                        if(ps_dec->u4_num_cores == 3)
-                        {
-                            ih264d_signal_bs_deblk_thread(ps_dec);
-                        }
-
-                        return (IV_FAIL);
-                    }
-                }
-
-            }
-
-        }
-
-
         if(buflen)
         {
             memcpy(pu1_bitstrm_buf, pu1_buf + u4_length_of_start_code,
                    buflen);
             /* Decoder may read extra 8 bytes near end of the frame */
             if((buflen + 8) < buf_size)
             {
                 memset(pu1_bitstrm_buf + buflen, 0, 8);
             }
             u4_first_start_code_found = 1;
 
         }
         else
         {
             /*start code not found*/
 
             if(u4_first_start_code_found == 0)
             {
                 /*no start codes found in current process call*/
 
                 ps_dec->i4_error_code = ERROR_START_CODE_NOT_FOUND;
                 ps_dec_op->u4_error_code |= 1 << IVD_INSUFFICIENTDATA;
 
                 if(ps_dec->u4_pic_buf_got == 0)
                 {
 
                     ih264d_fill_output_struct_from_context(ps_dec,
                                                            ps_dec_op);
 
                     ps_dec_op->u4_error_code = ps_dec->i4_error_code;
                     ps_dec_op->u4_frame_decoded_flag = 0;
 
                     return (IV_FAIL);
                 }
                 else
                 {
                     ps_dec->u1_pic_decode_done = 1;
                     continue;
                 }
             }
             else
             {
                 /* a start code has already been found earlier in the same process call*/
                 frame_data_left = 0;
                 header_data_left = 0;
                 continue;
             }
 
         }
 
-        ps_dec->u4_return_to_app = 0;
         ret = ih264d_parse_nal_unit(dec_hdl, ps_dec_op,
                               pu1_bitstrm_buf, buflen);
         if(ret != OK)
         {
             UWORD32 error =  ih264d_map_error(ret);
             ps_dec_op->u4_error_code = error | ret;
             api_ret_value = IV_FAIL;
 
             if((ret == IVD_RES_CHANGED)
                             || (ret == IVD_MEM_ALLOC_FAILED)
                             || (ret == ERROR_UNAVAIL_PICBUF_T)
                             || (ret == ERROR_UNAVAIL_MVBUF_T)
                             || (ret == ERROR_INV_SPS_PPS_T)
+                            || (ret == ERROR_FEATURE_UNAVAIL)
+                            || (ret == IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED)
                             || (ret == IVD_DISP_FRM_ZERO_OP_BUF_SIZE))
             {
                 ps_dec->u4_slice_start_code_found = 0;
                 break;
             }
 
             if((ret == ERROR_INCOMPLETE_FRAME) || (ret == ERROR_DANGLING_FIELD_IN_PIC))
             {
                 ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;
                 api_ret_value = IV_FAIL;
                 break;
             }
 
             if(ret == ERROR_IN_LAST_SLICE_OF_PIC)
             {
                 api_ret_value = IV_FAIL;
                 break;
             }
 
         }
 
-        if(ps_dec->u4_return_to_app)
-        {
-            /*We have encountered a referenced frame,return to app*/
-            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;
-            ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;
-            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
-            ps_dec_op->u4_frame_decoded_flag = 0;
-            ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);
-            /*signal the decode thread*/
-            ih264d_signal_decode_thread(ps_dec);
-            /* close deblock thread if it is not closed yet*/
-            if(ps_dec->u4_num_cores == 3)
-            {
-                ih264d_signal_bs_deblk_thread(ps_dec);
-            }
-            return (IV_FAIL);
-
-        }
-
-
-
         header_data_left = ((ps_dec->i4_decode_header == 1)
                         && (ps_dec->i4_header_decoded != 3)
                         && (ps_dec_op->u4_num_bytes_consumed
                                         < ps_dec_ip->u4_num_Bytes));
         frame_data_left = (((ps_dec->i4_decode_header == 0)
                         && ((ps_dec->u1_pic_decode_done == 0)
                                         || (u4_next_is_aud == 1)))
                         && (ps_dec_op->u4_num_bytes_consumed
                                         < ps_dec_ip->u4_num_Bytes));
     }
     while(( header_data_left == 1)||(frame_data_left == 1));
 
     if((ps_dec->u4_pic_buf_got == 1)
             && (ret != IVD_MEM_ALLOC_FAILED)
             && ps_dec->u2_total_mbs_coded < ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
     {
         // last slice - missing/corruption
         WORD32 num_mb_skipped;
         WORD32 prev_slice_err;
         pocstruct_t temp_poc;
         WORD32 ret1;
         WORD32 ht_in_mbs;
         ht_in_mbs = ps_dec->u2_pic_ht >> (4 + ps_dec->ps_cur_slice->u1_field_pic_flag);
         num_mb_skipped = (ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
                             - ps_dec->u2_total_mbs_coded;
 
         if(ps_dec->u4_first_slice_in_pic && (ps_dec->u4_pic_buf_got == 0))
             prev_slice_err = 1;
         else
             prev_slice_err = 2;
 
         if(ps_dec->u4_first_slice_in_pic && (ps_dec->u2_total_mbs_coded == 0))
             prev_slice_err = 1;
 
         ret1 = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, ps_dec->u1_nal_unit_type == IDR_SLICE_NAL, ps_dec->ps_cur_slice->u2_frame_num,
                                    &temp_poc, prev_slice_err);
 
         if((ret1 == ERROR_UNAVAIL_PICBUF_T) || (ret1 == ERROR_UNAVAIL_MVBUF_T) ||
                        (ret1 == ERROR_INV_SPS_PPS_T))
         {
             ret = ret1;
         }
     }
 
     if((ret == IVD_RES_CHANGED)
                     || (ret == IVD_MEM_ALLOC_FAILED)
                     || (ret == ERROR_UNAVAIL_PICBUF_T)
                     || (ret == ERROR_UNAVAIL_MVBUF_T)
                     || (ret == ERROR_INV_SPS_PPS_T))
     {
 
         /* signal the decode thread */
         ih264d_signal_decode_thread(ps_dec);
         /* close deblock thread if it is not closed yet */
         if(ps_dec->u4_num_cores == 3)
         {
             ih264d_signal_bs_deblk_thread(ps_dec);
         }
         /* dont consume bitstream for change in resolution case */
         if(ret == IVD_RES_CHANGED)
         {
             ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;
         }
         return IV_FAIL;
     }
 
 
     if(ps_dec->u1_separate_parse)
     {
         /* If Format conversion is not complete,
          complete it here */
         if(ps_dec->u4_num_cores == 2)
         {
 
             /*do deblocking of all mbs*/
             if((ps_dec->u4_nmb_deblk == 0) &&(ps_dec->u4_start_recon_deblk == 1) && (ps_dec->ps_cur_sps->u1_mb_aff_flag == 0))
             {
                 UWORD32 u4_num_mbs,u4_max_addr;
                 tfr_ctxt_t s_tfr_ctxt;
                 tfr_ctxt_t *ps_tfr_cxt = &s_tfr_ctxt;
                 pad_mgr_t *ps_pad_mgr = &ps_dec->s_pad_mgr;
 
                 /*BS is done for all mbs while parsing*/
                 u4_max_addr = (ps_dec->u2_frm_wd_in_mbs * ps_dec->u2_frm_ht_in_mbs) - 1;
                 ps_dec->u4_cur_bs_mb_num = u4_max_addr + 1;
 
 
                 ih264d_init_deblk_tfr_ctxt(ps_dec, ps_pad_mgr, ps_tfr_cxt,
                                            ps_dec->u2_frm_wd_in_mbs, 0);
 
 
                 u4_num_mbs = u4_max_addr
                                 - ps_dec->u4_cur_deblk_mb_num + 1;
 
                 DEBUG_PERF_PRINTF("mbs left for deblocking= %d \n",u4_num_mbs);
 
                 if(u4_num_mbs != 0)
                     ih264d_check_mb_map_deblk(ps_dec, u4_num_mbs,
                                                    ps_tfr_cxt,1);
 
                 ps_dec->u4_start_recon_deblk  = 0;
 
             }
 
         }
 
         /*signal the decode thread*/
         ih264d_signal_decode_thread(ps_dec);
         /* close deblock thread if it is not closed yet*/
         if(ps_dec->u4_num_cores == 3)
         {
             ih264d_signal_bs_deblk_thread(ps_dec);
         }
     }
 
 
     DATA_SYNC();
 
 
     if((ps_dec_op->u4_error_code & 0xff)
                     != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED)
     {
         ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;
         ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;
     }
 
 //Report if header (sps and pps) has not been decoded yet
-    if(ps_dec->i4_header_decoded != 3)
-    {
-        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);
-
-    }
-
     if(ps_dec->i4_decode_header == 1 && ps_dec->i4_header_decoded != 3)
     {
         ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);
-
-    }
-    if(ps_dec->u4_prev_nal_skipped)
-    {
-        /*We have encountered a referenced frame,return to app*/
-        ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;
-        ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
-        ps_dec_op->u4_frame_decoded_flag = 0;
-        ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);
-        /* close deblock thread if it is not closed yet*/
-        if(ps_dec->u4_num_cores == 3)
-        {
-            ih264d_signal_bs_deblk_thread(ps_dec);
-        }
-        return (IV_FAIL);
-
+        api_ret_value = IV_FAIL;
     }
 
     if((ps_dec->u4_pic_buf_got == 1)
                     && (ERROR_DANGLING_FIELD_IN_PIC != i4_err_status))
     {
         /*
          * For field pictures, set the bottom and top picture decoded u4_flag correctly.
          */
 
         if(ps_dec->ps_cur_slice->u1_field_pic_flag)
         {
             if(1 == ps_dec->ps_cur_slice->u1_bottom_field_flag)
             {
                 ps_dec->u1_top_bottom_decoded |= BOT_FIELD_ONLY;
             }
             else
             {
                 ps_dec->u1_top_bottom_decoded |= TOP_FIELD_ONLY;
             }
         }
         else
         {
                 ps_dec->u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY;
         }
 
         /* if new frame in not found (if we are still getting slices from previous frame)
          * ih264d_deblock_display is not called. Such frames will not be added to reference /display
          */
         if ((ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC) == 0)
         {
             /* Calling Function to deblock Picture and Display */
             ret = ih264d_deblock_display(ps_dec);
         }
 
 
         /*set to complete ,as we dont support partial frame decode*/
         if(ps_dec->i4_header_decoded == 3)
         {
             ps_dec->u2_total_mbs_coded = ps_dec->ps_cur_sps->u2_max_mb_addr + 1;
         }
 
         /*Update the i4_frametype at the end of picture*/
         if(ps_dec->ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)
         {
             ps_dec->i4_frametype = IV_IDR_FRAME;
         }
         else if(ps_dec->i4_pic_type == B_SLICE)
         {
             ps_dec->i4_frametype = IV_B_FRAME;
         }
         else if(ps_dec->i4_pic_type == P_SLICE)
         {
             ps_dec->i4_frametype = IV_P_FRAME;
         }
         else if(ps_dec->i4_pic_type == I_SLICE)
         {
             ps_dec->i4_frametype = IV_I_FRAME;
         }
         else
         {
             H264_DEC_DEBUG_PRINT("Shouldn't come here\n");
         }
 
         //Update the content type
         ps_dec->i4_content_type = ps_dec->ps_cur_slice->u1_field_pic_flag;
 
         ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded + 2;
         ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded
                         - ps_dec->ps_cur_slice->u1_field_pic_flag;
 
     }
 
     /* close deblock thread if it is not closed yet*/
     if(ps_dec->u4_num_cores == 3)
     {
         ih264d_signal_bs_deblk_thread(ps_dec);
     }
 
 
     {
         /* In case the decoder is configured to run in low delay mode,
          * then get display buffer and then format convert.
          * Note in this mode, format conversion does not run paralelly in a thread and adds to the codec cycles
          */
 
         if((IVD_DECODE_FRAME_OUT == ps_dec->e_frm_out_mode)
                         && ps_dec->u1_init_dec_flag)
         {
 
             ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,
                                           &(ps_dec->s_disp_op));
             if(0 == ps_dec->s_disp_op.u4_error_code)
             {
                 ps_dec->u4_fmt_conv_cur_row = 0;
                 ps_dec->u4_output_present = 1;
             }
         }
 
         ih264d_fill_output_struct_from_context(ps_dec, ps_dec_op);
 
         /* If Format conversion is not complete,
          complete it here */
         if(ps_dec->u4_output_present &&
           (ps_dec->u4_fmt_conv_cur_row < ps_dec->s_disp_frame_info.u4_y_ht))
         {
             ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht
                             - ps_dec->u4_fmt_conv_cur_row;
             ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),
                                   ps_dec->u4_fmt_conv_cur_row,
                                   ps_dec->u4_fmt_conv_num_rows);
             ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;
         }
 
         ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));
     }
 
     if(ps_dec->i4_decode_header == 1 && (ps_dec->i4_header_decoded & 1) == 1)
     {
         ps_dec_op->u4_progressive_frame_flag = 1;
         if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))
         {
             if((0 == ps_dec->ps_sps->u1_frame_mbs_only_flag)
                             && (0 == ps_dec->ps_sps->u1_mb_aff_flag))
                 ps_dec_op->u4_progressive_frame_flag = 0;
 
         }
     }
 
     if((TOP_FIELD_ONLY | BOT_FIELD_ONLY) == ps_dec->u1_top_bottom_decoded)
     {
         ps_dec->u1_top_bottom_decoded = 0;
     }
     /*--------------------------------------------------------------------*/
     /* Do End of Pic processing.                                          */
     /* Should be called only if frame was decoded in previous process call*/
     /*--------------------------------------------------------------------*/
     if(ps_dec->u4_pic_buf_got == 1)
     {
         if(1 == ps_dec->u1_last_pic_not_decoded)
         {
             ret = ih264d_end_of_pic_dispbuf_mgr(ps_dec);
 
             if(ret != OK)
                 return ret;
 
             ret = ih264d_end_of_pic(ps_dec);
             if(ret != OK)
                 return ret;
         }
         else
         {
             ret = ih264d_end_of_pic(ps_dec);
             if(ret != OK)
                 return ret;
         }
 
     }
 
 
     /*Data memory barrier instruction,so that yuv write by the library is complete*/
     DATA_SYNC();
 
     H264_DEC_DEBUG_PRINT("The num bytes consumed: %d\n",
                          ps_dec_op->u4_num_bytes_consumed);
     return api_ret_value;
 }
@@ -3104,132 +3042,110 @@ WORD32 ih264d_get_buf_info(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : ih264d_set_params                                        */
 /*                                                                           */
 /*  Description   :                                                          */
 /*                                                                           */
 /*  Inputs        :iv_obj_t decoder handle                                   */
 /*                :pv_api_ip pointer to input structure                      */
 /*                :pv_api_op pointer to output structure                     */
 /*  Outputs       :                                                          */
 /*  Returns       : void                                                     */
 /*                                                                           */
 /*  Issues        : none                                                     */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         22 10 2008    100356         Draft                                */
 /*                                                                           */
 /*****************************************************************************/
 WORD32 ih264d_set_params(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)
 {
 
     dec_struct_t * ps_dec;
     WORD32 ret = IV_SUCCESS;
 
     ivd_ctl_set_config_ip_t *ps_ctl_ip =
                     (ivd_ctl_set_config_ip_t *)pv_api_ip;
     ivd_ctl_set_config_op_t *ps_ctl_op =
                     (ivd_ctl_set_config_op_t *)pv_api_op;
 
     ps_dec = (dec_struct_t *)(dec_hdl->pv_codec_handle);
 
     ps_dec->u4_skip_frm_mask = 0;
 
     ps_ctl_op->u4_error_code = 0;
 
-    ps_dec->i4_app_skip_mode = ps_ctl_ip->e_frm_skip_mode;
-
-    /*Is it really supported test it when you so the corner testing using test app*/
-
     if(ps_ctl_ip->e_frm_skip_mode != IVD_SKIP_NONE)
     {
-
-        if(ps_ctl_ip->e_frm_skip_mode == IVD_SKIP_P)
-            ps_dec->u4_skip_frm_mask |= 1 << P_SLC_BIT;
-        else if(ps_ctl_ip->e_frm_skip_mode == IVD_SKIP_B)
-            ps_dec->u4_skip_frm_mask |= 1 << B_SLC_BIT;
-        else if(ps_ctl_ip->e_frm_skip_mode == IVD_SKIP_PB)
-        {
-            ps_dec->u4_skip_frm_mask |= 1 << B_SLC_BIT;
-            ps_dec->u4_skip_frm_mask |= 1 << P_SLC_BIT;
-        }
-        else if(ps_ctl_ip->e_frm_skip_mode == IVD_SKIP_I)
-            ps_dec->u4_skip_frm_mask |= 1 << I_SLC_BIT;
-        else
-        {
-            //dynamic parameter not supported
-            //Put an appropriate error code to return the error..
-            //when you do the error code tests and after that remove this comment
-            ps_ctl_op->u4_error_code = (1 << IVD_UNSUPPORTEDPARAM);
-            ret = IV_FAIL;
-        }
+        ps_ctl_op->u4_error_code = (1 << IVD_UNSUPPORTEDPARAM);
+        ret = IV_FAIL;
     }
 
     if(ps_ctl_ip->u4_disp_wd >= ps_dec->u2_pic_wd)
     {
         ps_dec->u4_app_disp_width = ps_ctl_ip->u4_disp_wd;
     }
     else if(0 == ps_dec->i4_header_decoded)
     {
         ps_dec->u4_app_disp_width = ps_ctl_ip->u4_disp_wd;
     }
     else if(ps_ctl_ip->u4_disp_wd == 0)
     {
         ps_dec->u4_app_disp_width = 0;
     }
     else
     {
         /*
          * Set the display width to zero. This will ensure that the wrong value we had stored (0xFFFFFFFF)
          * does not propogate.
          */
         ps_dec->u4_app_disp_width = 0;
         ps_ctl_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
         ps_ctl_op->u4_error_code |= ERROR_DISP_WIDTH_INVALID;
         ret = IV_FAIL;
     }
 
     if(ps_ctl_ip->e_vid_dec_mode == IVD_DECODE_FRAME)
         ps_dec->i4_decode_header = 0;
     else if(ps_ctl_ip->e_vid_dec_mode == IVD_DECODE_HEADER)
         ps_dec->i4_decode_header = 1;
     else
     {
         ps_ctl_op->u4_error_code = (1 << IVD_UNSUPPORTEDPARAM);
         ps_dec->i4_decode_header = 1;
         ret = IV_FAIL;
     }
     ps_dec->e_frm_out_mode = IVD_DISPLAY_FRAME_OUT;
 
     if((ps_ctl_ip->e_frm_out_mode != IVD_DECODE_FRAME_OUT) &&
        (ps_ctl_ip->e_frm_out_mode != IVD_DISPLAY_FRAME_OUT))
     {
         ps_ctl_op->u4_error_code = (1 << IVD_UNSUPPORTEDPARAM);
         ret = IV_FAIL;
     }
     ps_dec->e_frm_out_mode = ps_ctl_ip->e_frm_out_mode;
     return ret;
 
 }
 
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : ih264d_set_default_params                                */
 /*                                                                           */
 /*  Description   :                                                          */
 /*                                                                           */
 /*  Inputs        :iv_obj_t decoder handle                                   */
 /*                :pv_api_ip pointer to input structure                      */
 /*                :pv_api_op pointer to output structure                     */
 /*  Outputs       :                                                          */
 /*  Returns       : void                                                     */
 /*                                                                           */
 /*  Issues        : none                                                     */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         08 08 2011   100421          Copied from set_params               */
 /*                                                                           */
 /*****************************************************************************/
@@ -3434,90 +3350,90 @@ WORD32 ih264d_ctl(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)
     return ret;
 }
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name :   ih264d_rel_display_frame                               */
 /*                                                                           */
 /*  Description   :                                                          */
 /*                                                                           */
 /*  Inputs        :iv_obj_t decoder handle                                   */
 /*                :pv_api_ip pointer to input structure                      */
 /*                :pv_api_op pointer to output structure                     */
 /*  Outputs       :                                                          */
 /*  Returns       : void                                                     */
 /*                                                                           */
 /*  Issues        : none                                                     */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         22 10 2008    100356         Draft                                */
 /*                                                                           */
 /*****************************************************************************/
 WORD32 ih264d_rel_display_frame(iv_obj_t *dec_hdl,
                                 void *pv_api_ip,
                                 void *pv_api_op)
 {
 
     ivd_rel_display_frame_ip_t *ps_rel_ip;
     ivd_rel_display_frame_op_t *ps_rel_op;
     UWORD32 buf_released = 0;
 
-    UWORD32 u4_ts = -1;
+    UWORD32 u4_ts = 0;
     dec_struct_t *ps_dec = dec_hdl->pv_codec_handle;
 
     ps_rel_ip = (ivd_rel_display_frame_ip_t *)pv_api_ip;
     ps_rel_op = (ivd_rel_display_frame_op_t *)pv_api_op;
     ps_rel_op->u4_error_code = 0;
     u4_ts = ps_rel_ip->u4_disp_buf_id;
 
     if(0 == ps_dec->u4_share_disp_buf)
     {
         ps_dec->u4_disp_buf_mapping[u4_ts] = 0;
         ps_dec->u4_disp_buf_to_be_freed[u4_ts] = 0;
         return IV_SUCCESS;
     }
 
     if(ps_dec->pv_pic_buf_mgr != NULL)
     {
         if(1 == ps_dec->u4_disp_buf_mapping[u4_ts])
         {
             ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                                   ps_rel_ip->u4_disp_buf_id,
                                   BUF_MGR_IO);
             ps_dec->u4_disp_buf_mapping[u4_ts] = 0;
             buf_released = 1;
         }
     }
 
     if((1 == ps_dec->u4_share_disp_buf) && (0 == buf_released))
         ps_dec->u4_disp_buf_to_be_freed[u4_ts] = 1;
 
     return IV_SUCCESS;
 }
 
 /**
  *******************************************************************************
  *
  * @brief
  *  Sets degrade params
  *
  * @par Description:
  *  Sets degrade params.
  *  Refer to ih264d_ctl_degrade_ip_t definition for details
  *
  * @param[in] ps_codec_obj
  *  Pointer to codec object at API level
  *
  * @param[in] pv_api_ip
  *  Pointer to input argument structure
  *
  * @param[out] pv_api_op
  *  Pointer to output argument structure
  *
  * @returns  Status
  *
  * @remarks
  *
  *
  *******************************************************************************
  */
diff --git a/decoder/ih264d_defs.h b/decoder/ih264d_defs.h
index 260e358..94d0d61 100644
--- a/decoder/ih264d_defs.h
+++ b/decoder/ih264d_defs.h
@@ -1,616 +1,622 @@
 /******************************************************************************
  *
  * Copyright (C) 2015 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  *****************************************************************************
  * Originally developed and contributed by Ittiam Systems Pvt. Ltd, Bangalore
 */
 #ifndef _IH264D_DEFS_H_
 #define _IH264D_DEFS_H_
 
 /**
  ************************************************************************
  * \file ih264d_defs.h
  *
  * \brief
  *    Type definitions used in the code
  *
  * \date
  *    19/11/2002
  *
  * \author  Sriram Sethuraman
  *
  ************************************************************************
  */
+#include <stdint.h>
+
 #define H264_MAX_FRAME_WIDTH                4080
 #define H264_MAX_FRAME_HEIGHT               4080
 #define H264_MAX_FRAME_SIZE                 (4096 * 2048)
 
 #define H264_MIN_FRAME_WIDTH                16
 #define H264_MIN_FRAME_HEIGHT               16
 
 #define FMT_CONV_NUM_ROWS       16
 
 /** Bit manipulation macros */
 #define CHECKBIT(a,i) ((a) &  (1 << i))
 #define CLEARBIT(a,i) ((a) &= ~(1 << i))
 
+/** Macro to check if a number lies in the valid integer range */
+#define IS_OUT_OF_RANGE_S32(a) (((a) < INT32_MIN) || ((a) > INT32_MAX))
+
 /** Macro to convert a integer to a boolean value */
 #define BOOLEAN(x) (!!(x))
 
 /** Arithmetic operations */
 #define MOD(x,y) ((x)%(y))
 #define DIV(x,y) ((x)/(y))
 #define MUL(x,y) ((x)*(y))
 #define SIGN_POW2_DIV(x, y) (((x) < 0) ? (-((-(x)) >> (y))) : ((x) >> (y)))
 
 #define MB_ENABLE_FILTERING           0x00
 #define MB_DISABLE_FILTERING          0x01
 #define MB_DISABLE_TOP_EDGE           0x02
 #define MB_DISABLE_LEFT_EDGE          0x04
 
 /** Maximum number of reference pics */
 #define MAX_REF_BUFS    32
 #define MAX_DISP_BUFS_NEW 64
 #define MAX_FRAMES              16
 
 #define INVALID_FRAME_NUM       0x0fffffff
 #define GAP_FRAME_NUM           0x1fffffff
 
 /** macros for reference picture lists, refIdx to POC mapping */
 // 1 extra entry into reference picture lists for refIdx = -1.
 // this entry is always 0. this saves conditional checks in
 // FillBs modules.
 #define POC_LIST_L0_TO_L1_DIFF  (( 2*MAX_FRAMES) + 1)
 #define POC_LIST_L0_TO_L1_DIFF_1  ((MAX_FRAMES) + 1)
 
 #define FRM_LIST_L0             0                                               //0
 #define FRM_LIST_L1             1 * POC_LIST_L0_TO_L1_DIFF//FRM_LIST_L0 + POC_LIST_L0_TO_L1_DIFF        //0+33                  //(1 * POC_LIST_L0_TO_L1_DIFF)
 #define TOP_LIST_FLD_L0         2 * POC_LIST_L0_TO_L1_DIFF//FRM_LIST_L1 + POC_LIST_L0_TO_L1_DIFF        //0+33+33                   //(2 * POC_LIST_L0_TO_L1_DIFF)
 #define TOP_LIST_FLD_L1         3 * POC_LIST_L0_TO_L1_DIFF//TOP_LIST_FLD_L0 + POC_LIST_L0_TO_L1_DIFF_1  //0+33+33+17                //(3 * POC_LIST_L0_TO_L1_DIFF)
 #define BOT_LIST_FLD_L0         4 * POC_LIST_L0_TO_L1_DIFF//TOP_LIST_FLD_L1 + POC_LIST_L0_TO_L1_DIFF_1  //0+33+33+17+17
 #define BOT_LIST_FLD_L1         5 * POC_LIST_L0_TO_L1_DIFF//BOT_LIST_FLD_L0 + POC_LIST_L0_TO_L1_DIFF_1  //0+33+33+17+17+17
 #define TOTAL_LIST_ENTRIES      6 * POC_LIST_L0_TO_L1_DIFF//BOT_LIST_FLD_L1 + POC_LIST_L0_TO_L1_DIFF_1  //0+33+33+17+17+17+17
 #define PAD_MV_BANK_ROW             64
 #define OFFSET_MV_BANK_ROW          ((PAD_MV_BANK_ROW)>>1)
 #define PAD_PUC_CURNNZ              32
 #define OFFSET_PUC_CURNNZ           (PAD_PUC_CURNNZ)
 #define PAD_MAP_IDX_POC             (1)
 #define OFFSET_MAP_IDX_POC          (1)
 
 #define OFFSET_MAP_IDX_POC          (1)
 
 #define NAL_REF_IDC(nal_first_byte)       ((nal_first_byte >> 5) & 0x3)
 #define NAL_FORBIDDEN_BIT(nal_first_byte) (nal_first_byte>>7)
 #define NAL_UNIT_TYPE(nal_first_byte)     (nal_first_byte & 0x1F)
 
 #define INT_PIC_TYPE_I        (0x00)
 
 #define YIELD_CNT_THRESHOLD  8
 
 
 #define OK        0
 #define END       1
 #define NOT_OK    -1
 
 /* For 420SP */
 #define YUV420SP_FACTOR 2
 
 /*To prevent buffer overflow access; in case the size of nal unit is
  *  greater than the allocated buffer size*/
 #define EXTRA_BS_OFFSET 16*16*2
 
 /**
  ***************************************************************************
  * Enum to hold various mem records being request
  ****************************************************************************
  */
 enum
 {
     /**
      * Codec Object at API level
      */
     MEM_REC_IV_OBJ,
 
     /**
      * Codec context
      */
     MEM_REC_CODEC,
 
     /**
      * Bitstream buffer which holds emulation prevention removed bytes
      */
     MEM_REC_BITSBUF,
 
     /**
      * Buffer to hold  coeff data
      */
     MEM_REC_COEFF_DATA,
 
     /**
      * Motion vector bank
      */
     MEM_REC_MVBANK,
 
     /**
      * Holds mem records passed to the codec.
      */
     MEM_REC_BACKUP,
 
     /**
      * Holds SPS
      */
     MEM_REC_SPS,
 
     /**
      * Holds PPS
      */
     MEM_REC_PPS,
 
     /**
      * Holds Slice Headers
      */
     MEM_REC_SLICE_HDR,
 
     /**
      * Holds thread handles
      */
     MEM_REC_THREAD_HANDLE,
 
     /**
      * Contains i4_status map indicating parse i4_status per MB basis
      */
     MEM_REC_PARSE_MAP,
 
     /**
      * Contains i4_status map indicating processing i4_status per MB basis
      */
     MEM_REC_PROC_MAP,
 
     /**
      * Contains slice number info for each MB
      */
 
     MEM_REC_SLICE_NUM_MAP,
 
     /**
      * Holds dpb manager context
      */
     MEM_REC_DPB_MGR,
 
     /**
      * Holds neighbors' info
      */
     MEM_REC_NEIGHBOR_INFO,
 
     /**
      * Holds neighbors' info
      */
     MEM_REC_PRED_INFO,
 
 
     /**
      * Holds inter pred inforamation on packed format info
      */
     MEM_REC_PRED_INFO_PKD,
     /**
      * Holds neighbors' info
      */
     MEM_REC_MB_INFO,
 
     /**
      * Holds deblock Mb info structure frame level)
      */
     MEM_REC_DEBLK_MB_INFO,
 
     /**
      * Holds  reference picture buffers in non-shared mode
      */
     MEM_REC_REF_PIC,
 
     /**
      * Holds  some misc intermediate_buffers
      */
     MEM_REC_EXTRA_MEM,
 
     /**
      * Holds  some misc intermediate_buffers
      */
     MEM_REC_INTERNAL_SCRATCH,
 
     /**
      * Holds  some misc intermediate_buffers
      */
     MEM_REC_INTERNAL_PERSIST,
 
     /* holds structures related to picture buffer manager*/
     MEM_REC_PIC_BUF_MGR,
 
     /*holds structure related to MV buffer manager*/
     MEM_REC_MV_BUF_MGR,
 
     /**
      * Place holder to compute number of memory records.
      */
     MEM_REC_CNT
 /* Do not add anything below */
 };
 
 #ifdef DEBLOCK_THREAD
 #define H264_MUTEX_LOCK(lock) ithread_mutex_lock(lock)
 #define H264_MUTEX_UNLOCK(lock) ithread_mutex_unlock(lock)
 #else //DEBLOCK_THREAD
 #define H264_MUTEX_LOCK(lock)
 #define H264_MUTEX_UNLOCK(lock)
 
 #define DEBUG_THREADS_PRINTF(...)
 #define DEBUG_PERF_PRINTF(...)
 
 /** Profile Types*/
 #define BASE_PROFILE_IDC    66
 #define MAIN_PROFILE_IDC    77
 #define EXTENDED_PROFILE_IDC    88
 #define HIGH_PROFILE_IDC   100
 
 
 #define MB_SIZE             16
 #define BLK8x8SIZE           8
 #define BLK_SIZE             4
 #define NUM_BLKS_PER_MB     24
 #define NUM_LUM_BLKS_PER_MB 16
 #define LUM_BLK              0
 #define CHROM_BLK            1
 #define NUM_PELS_IN_MB      64
 
 /* Level Types */
 #define H264_LEVEL_1_0     10
 #define H264_LEVEL_1_1     11
 #define H264_LEVEL_1_2     12
 #define H264_LEVEL_1_3     13
 #define H264_LEVEL_2_0     20
 #define H264_LEVEL_2_1     21
 #define H264_LEVEL_2_2     22
 #define H264_LEVEL_3_0     30
 #define H264_LEVEL_3_1     31
 #define H264_LEVEL_3_2     32
 #define H264_LEVEL_4_0     40
 #define H264_LEVEL_4_1     41
 #define H264_LEVEL_4_2     42
 #define H264_LEVEL_5_0     50
 #define H264_LEVEL_5_1     51
 
 #define MAX_MBS_LEVEL_51 36864
 #define MAX_MBS_LEVEL_50 22080
 #define MAX_MBS_LEVEL_42 8704
 #define MAX_MBS_LEVEL_41 8192
 #define MAX_MBS_LEVEL_40 8192
 #define MAX_MBS_LEVEL_32 5120
 #define MAX_MBS_LEVEL_31 3600
 #define MAX_MBS_LEVEL_30 1620
 #define MAX_MBS_LEVEL_22 1620
 #define MAX_MBS_LEVEL_21 792
 #define MAX_MBS_LEVEL_20 396
 #define MAX_MBS_LEVEL_13 396
 #define MAX_MBS_LEVEL_12 396
 #define MAX_MBS_LEVEL_11 396
 #define MAX_MBS_LEVEL_10 99
 
 /** NAL Types */
 #define SLICE_NAL                       1
 #define SLICE_DATA_PARTITION_A_NAL      2
 #define SLICE_DATA_PARTITION_B_NAL      3
 #define SLICE_DATA_PARTITION_C_NAL      4
 #define IDR_SLICE_NAL                   5
 #define SEI_NAL                         6
 #define SEQ_PARAM_NAL                   7
 #define PIC_PARAM_NAL                   8
 #define ACCESS_UNIT_DELIMITER_RBSP      9
 #define END_OF_SEQ_RBSP                 10
 #define END_OF_STREAM_RBSP              11
 #define FILLER_DATA_NAL                 12
 
 /** Entropy coding modes */
 #define CAVLC  0
 #define CABAC  1
 
 /** Picture Types */
 #define I_PIC       0
 #define IP_PIC      1
 #define IPB_PIC     2
 #define SI_PIC      3
 #define SIP_PIC     4
 #define ISI_PIC     5
 #define ISI_PSP_PIC 6
 #define ALL_PIC     7
 
 /* Frame or field picture type */
 #define FRM_PIC         0x00
 #define TOP_FLD         0x01
 #define BOT_FLD         0x02
 #define COMP_FLD_PAIR   0x03 /* TOP_FLD | BOT_FLD */
 #define AFRM_PIC        0x04
 #define TOP_REF         0x08
 #define BOT_REF         0x10
 #define PIC_MASK        0x03
 #define NON_EXISTING    0xff
 
 /* field picture type for display */
 #define DISP_TOP_FLD    0x00
 #define DISP_BOT_FLD    0x01
 
 /** Slice Types */
+#define NA_SLICE -1
 #define P_SLICE  0
 #define B_SLICE  1
 #define I_SLICE  2
 #define SP_SLICE 3
 #define SI_SLICE 4
 
 /* Definition for picture skip */
 #define SKIP_NONE  (0x0)
 #define I_SLC_BIT  (0x1)
 #define P_SLC_BIT  (0x2)
 #define B_SLC_BIT  (0x4)
 
 /** Macros used for Deblocking */
 #define D_INTER_MB        0
 #define D_INTRA_MB        1
 #define D_PRED_NON_16x16  2
 #define D_B_SLICE         4
 #define D_B_SUBMB         6 //D_B_SLICE | D_PRED_NON_16x16 | D_INTER_MB
 #define D_FLD_MB          0x80
 
 /** Macros for Cabac checks */
 /** MbType */
 /** |x|x|I_PCM|SKIP|
  |S|Inter/Intra|P/B|NON-BD16x16/BD16x16,I16x16/I4x4| */
 #define CAB_INTRA         0x00 /* 0000 00xx */
 #define CAB_INTER         0x04 /* 0000 01xx */
 #define CAB_I4x4          0x00 /* 0000 00x0 */
 #define CAB_I16x16        0x01 /* 0000 00x1 */
 #define CAB_BD16x16       0x04 /* 0000 0100 */
 #define CAB_NON_BD16x16   0x05 /* 0000 0101 */
 #define CAB_P             0x07 /* 0000 0111 */
 #define CAB_SI4x4         0x08 /* 0000 10x0 */
 #define CAB_SI16x16       0x09 /* 0000 10x1 */
 #define CAB_SKIP_MASK     0x10 /* 0001 0000 */
 #define CAB_SKIP          0x10 /* 0001 0000 */
 #define CAB_P_SKIP        0x16 /* 0001 x11x */
 #define CAB_B_SKIP        0x14 /* 0001 x100 */
 #define CAB_BD16x16_MASK  0x07 /* 0000 0111 */
 #define CAB_INTRA_MASK    0x04 /* 0000 0100 */
 #define CAB_I_PCM         0x20 /* 001x xxxx */
 
 /**< Binarization types for CABAC */
 /* |x|x|x|x|MSB_FIRST_FLC|FLC|TUNARY|UNARY| */
 #define UNARY           1
 #define TUNARY          2
 #define FLC             4
 #define MSB_FIRST_FLC   12
 
 /** Macroblock Types */
 #define I_4x4_MB    0
 #define I_16x16_MB  1
 #define P_MB        2
 #define B_MB        3
 #define SI_MB       4
 #define SP_MB       5
 #define I_PCM_MB    6
 
 #define SI4x4_MB 0xFF
 
 /** Intra luma 16x16 and chroma 8x8 prediction modes */
 #define NUM_INTRA_PRED_MODES  4
 #define VERT    0
 #define HORIZ   1
 #define DC      2
 #define PLANE   3
 #define NOT_VALID -1
 #define DC_DC_DC_DC   0x02020202 /*packed 4 bytes used in Decode Intra Mb*/
 
 /** Intra luma 4x4 prediction modes */
 #define NUM_INTRA4x4_PRED_MODES 9
 
 /** VERT, HORIZ, DC are applicable to 4x4 as well */
 /** D - Down; U - Up; L - Left; R - Right */
 #define DIAG_DL   3
 #define DIAG_DR   4
 #define VERT_R    5
 #define HORIZ_D   6
 #define VERT_L    7
 #define HORIZ_U   8
 
 /** P_MB prediction modes */
 #define NUM_INTER_MB_PRED_MODES 5
 #define PRED_16x16  0
 #define PRED_16x8   1
 #define PRED_8x16   2
 #define PRED_8x8    3
 #define PRED_8x8R0  4
 #define MAGIC_16x16 5
 #define MB_SKIP     255
 
 /* P_MB submb modes */
 #define P_L0_8x8    0
 #define P_L0_8x4    1
 #define P_L0_4x8    2
 #define P_L0_4x4    3
 
 /* B_MB submb modes */
 #define B_DIRECT_8x8    0
 #define B_L0_8x8        1
 #define B_L1_8x8        2
 #define B_BI_8x8        3
 #define B_L0_8x4        4
 #define B_L0_4x8        5
 #define B_L1_8x4        6
 #define B_L1_4x8        7
 #define B_BI_8x4        8
 #define B_BI_4x8        9
 #define B_L0_4x4        10
 #define B_L1_4x4        11
 #define B_BI_4x4        12
 
 /** B_MB prediction modes */
 #define B_8x8    22
 #define PRED_INVALID  -1
 #define B_DIRECT  0
 #define PRED_L0   1
 #define PRED_L1   2
 #define BI_PRED   3
 #define B_DIRECT_BI_PRED  23
 #define B_DIRECT_PRED_L0  24
 #define B_DIRECT_PRED_L1  25
 #define B_DIRECT_SPATIAL  26
 
 #define B_DIRECT8x8_BI_PRED  13
 #define B_DIRECT8x8_PRED_L0  14
 #define B_DIRECT8x8_PRED_L1  15
 
 #define ONE_TO_ONE  0
 #define FRM_TO_FLD  1
 #define FLD_TO_FRM  2
 
 /** Inter Sub MB Pred modes */
 #define NUM_INTER_SUBMB_PRED_MODES 4
 #define SUBMB_8x8    0
 #define SUBMB_8x4    1
 #define SUBMB_4x8    2
 #define SUBMB_4x4    3
 
 /** Coded Block Pattern - Chroma */
 #define CBPC_ALLZERO    0
 #define CBPC_ACZERO     1
 #define CBPC_NONZERO    2
 
 /** Index for accessing the left MB in the MV predictor array */
 #define LEFT  0
 /** Index for accessing the top MB in the MV predictor array */
 #define TOP   1
 /** Index for accessing the top right MB in the MV predictor array */
 #define TOP_R 2
 /** Index for accessing the top Left MB in the MV predictor array */
 #define TOP_L 3
 
 /** Maximum number of Sequence Parameter sets */
 #define MAX_NUM_SEQ_PARAMS 32
 
 /** Maximum number of Picture Parameter sets */
 #define MAX_NUM_PIC_PARAMS 256
 
 #define MASK_ERR_SEQ_SET_ID   (0xFFFFFFE0)
 #define MASK_ERR_PIC_SET_ID   (0xFFFFFF00)
 
 #define MAX_PIC_ORDER_CNT_TYPE    2
 
 #define MAX_BITS_IN_FRAME_NUM     16
 #define MAX_BITS_IN_POC_LSB       16
 
 #define H264_MAX_REF_PICS         16
 #define H264_MAX_REF_IDX          32
 #define MAX_WEIGHT_BIPRED_IDC     2
 #define MAX_CABAC_INIT_IDC        2
 
 #define H264_DEFAULT_NUM_CORES 1
 #define DEFAULT_SEPARATE_PARSE (H264_DEFAULT_NUM_CORES == 2)? 1 :0
 
 /** Maximum number of Slice groups */
 #define MAX_NUM_SLICE_GROUPS 8
 #define MAX_NUM_REF_FRAMES_OFFSET 255
 
 /** Deblocking modes for a slice */
 #define SLICE_BOUNDARY_DBLK_DISABLED  2
 #define DBLK_DISABLED                 1
 #define DBLK_ENABLED                  0
 #define MIN_DBLK_FIL_OFF              -12
 #define MAX_DBLK_FIL_OFF              12
 
 /** Width of the predictor buffers used for MC */
 #define MB_SIZE             16
 #define BLK8x8SIZE          8
 #define BLK_SIZE             4
 #define NUM_BLKS_PER_MB     24
 #define NUM_LUM_BLKS_PER_MB 16
 
 #define SUB_BLK_WIDTH                 4
 #define SUB_SUB_BLK_SIZE              4 /* 2x2 pixel i4_size */
 #define SUB_BLK_SIZE                  ((SUB_BLK_WIDTH) * (SUB_BLK_WIDTH))
 #define MB_LUM_SIZE                   256
 #define MB_CHROM_SIZE                 64
 
 /**< Width to pad the luminance frame buff    */
 /**< Height to pad the luminance frame buff   */
 /**< Width to pad the chrominance frame buff  */
 /**< Height to pad the chrominance frame buff */
 
 #define PAD_LEN_Y_H                   32
 #define PAD_LEN_Y_V                   20
 #define PAD_LEN_UV_H                  16
 #define PAD_LEN_UV_V                  8
 
 #define PAD_MV_BANK_ROW             64
 
 /**< Maimum u4_ofst by which the Mvs could point outside the frame buffers
  horizontally in the left and vertically in the top direction */
 #define MAX_OFFSET_OUTSIDE_X_FRM      -20
 #define MAX_OFFSET_OUTSIDE_Y_FRM      -20
 #define MAX_OFFSET_OUTSIDE_UV_FRM     -8
 
 /** UVLC parsing macros */
 #define   UEV     1
 #define   SEV     2
 #define   TEV     3
 
 /** Defines for Boolean values */
 #ifndef TRUE
 #define TRUE    1
 #define FALSE   0
 #endif
 
 #define UNUSED_FOR_REF 0
 #define IS_SHORT_TERM  1
 #define IS_LONG_TERM   2
 
 /** Defines for which field gets displayed first */
 #define MAX_FRAMES              16
 #define INVALID_FRAME_NUM       0x0fffffff
 #define DO_NOT_DISP             254
 #define DISP_FLD_FIRST_UNDEF  0
 #define DISP_TOP_FLD_FIRST   1
 #define DISP_BOT_FLD_FIRST   2
 
 /** Misc error resilience requirements*/
 #define MASK_LOG2_WEIGHT_DENOM      0xFFFFFFF8
 #define MASK_PRED_WEIGHT_OFFSET     0xFFFFFF00
 #define MAX_REDUNDANT_PIC_CNT       127
 
 
 
 #endif //DEBLOCK_THREAD
 
 #define NUM_COEFFS_IN_4x4BLK 16
-
+#define CABAC_BITS_TO_READ 23
 
 #define MEMSET_16BYTES(pu4_start,value)                         \
 {                                                               \
     memset(pu4_start,value,16);                                 \
 }
 
 #define MEMCPY_16BYTES(dst,src)                                 \
 {                                                               \
     memcpy(dst,src,16);                                         \
 }
 
 
 #endif /*_IH264D_DEFS_H_*/
diff --git a/decoder/ih264d_dpb_mgr.c b/decoder/ih264d_dpb_mgr.c
index 74ecdb5..af414a5 100644
--- a/decoder/ih264d_dpb_mgr.c
+++ b/decoder/ih264d_dpb_mgr.c
@@ -693,150 +693,159 @@ WORD32 ih264d_update_default_index_list(dpb_manager_t *ps_dpb_mgr)
 /*!
  **************************************************************************
  * \if Function name : ref_idx_reordering \endif
  *
  * \brief
  *     Parse the bitstream and reorder indices for the current slice
  *
  * \return
  *    0 - if no_error; -1 - error
  *
  * \note
  *    Called only if ref_idx_reordering_flag_l0 is decoded as 1
  *    Remove error checking for unmatching picNum or LTIndex later (if not needed)
  * \para
  *    This section implements 7.3.3.1 and 8.2.6.4
  *    Uses the default index list as the starting point and
  *    remaps the picNums sent to the next higher index in the
  *    modified list. The unmodified ones are copied from the
  *    default to modified list retaining their order in the default list.
  *
  **************************************************************************
  */
 WORD32 ih264d_ref_idx_reordering(dec_struct_t *ps_dec, UWORD8 uc_lx)
 {
     dpb_manager_t *ps_dpb_mgr = ps_dec->ps_dpb_mgr;
     UWORD16 u4_cur_pic_num = ps_dec->ps_cur_slice->u2_frame_num;
     /*< Maximum Picture Number Minus 1 */
     UWORD16 ui_max_frame_num =
                     ps_dec->ps_cur_sps->u2_u4_max_pic_num_minus1 + 1;
 
     WORD32 i, count = 0;
     UWORD32 ui_remapIdc, ui_nextUev;
     WORD16 u2_pred_frame_num = u4_cur_pic_num;
     WORD32 i_temp;
     UWORD16 u2_def_mod_flag = 0; /* Flag to keep track of which indices have been remapped */
     UWORD8 modCount = 0;
     UWORD32 *pu4_bitstrm_buf = ps_dec->ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_dec->ps_bitstrm->u4_ofst;
     dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice;
     UWORD8 u1_field_pic_flag = ps_cur_slice->u1_field_pic_flag;
 
     if(u1_field_pic_flag)
     {
         u4_cur_pic_num = u4_cur_pic_num * 2 + 1;
         ui_max_frame_num = ui_max_frame_num * 2;
     }
 
     u2_pred_frame_num = u4_cur_pic_num;
 
     ui_remapIdc = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
     while((ui_remapIdc != 3)
                     && (count < ps_cur_slice->u1_num_ref_idx_lx_active[uc_lx]))
     {
         ui_nextUev = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         if(ui_remapIdc != 2)
         {
+            if(ui_nextUev > ui_max_frame_num)
+                return ERROR_DBP_MANAGER_T;
+
             ui_nextUev = ui_nextUev + 1;
+
             if(ui_remapIdc == 0)
             {
                 // diffPicNum is -ve
-                i_temp = u2_pred_frame_num - ui_nextUev;
+                i_temp = (WORD32)u2_pred_frame_num - (WORD32)ui_nextUev;
                 if(i_temp < 0)
                     i_temp += ui_max_frame_num;
             }
             else
             {
                 // diffPicNum is +ve
-                i_temp = u2_pred_frame_num + ui_nextUev;
+                i_temp = (WORD32)u2_pred_frame_num + (WORD32)ui_nextUev;
                 if(i_temp >= ui_max_frame_num)
                     i_temp -= ui_max_frame_num;
             }
             /* Find the dpb with the matching picNum (picNum==frameNum for framePic) */
 
             if(i_temp > u4_cur_pic_num)
                 i_temp = i_temp - ui_max_frame_num;
 
             for(i = 0; i < (ps_cur_slice->u1_initial_list_size[uc_lx]); i++)
             {
                 if(ps_dpb_mgr->ps_init_dpb[uc_lx][i]->i4_pic_num == i_temp)
                     break;
             }
             if(i == (ps_cur_slice->u1_initial_list_size[uc_lx]))
             {
                 UWORD32 i4_error_code;
                 i4_error_code = ERROR_DBP_MANAGER_T;
                 return i4_error_code;
             }
 
             u2_def_mod_flag |= (1 << i);
             ps_dpb_mgr->ps_mod_dpb[uc_lx][modCount++] =
                             ps_dpb_mgr->ps_init_dpb[uc_lx][i];
             u2_pred_frame_num = i_temp; //update predictor to be the picNum just obtained
         }
         else //2
         {
-            UWORD8 u1_lt_idx = (UWORD8)ui_nextUev;
+            UWORD8 u1_lt_idx;
+
+            if(ui_nextUev > (MAX_REF_BUFS + 1))
+                return ERROR_DBP_MANAGER_T;
+
+            u1_lt_idx = (UWORD8)ui_nextUev;
 
             for(i = 0; i < (ps_cur_slice->u1_initial_list_size[uc_lx]); i++)
             {
                 if(!ps_dpb_mgr->ps_init_dpb[uc_lx][i]->u1_is_short)
                 {
                     if(ps_dpb_mgr->ps_init_dpb[uc_lx][i]->u1_long_term_pic_num
                                     == u1_lt_idx)
                         break;
                 }
             }
             if(i == (ps_cur_slice->u1_initial_list_size[uc_lx]))
             {
                 UWORD32 i4_error_code;
                 i4_error_code = ERROR_DBP_MANAGER_T;
                 return i4_error_code;
             }
 
             u2_def_mod_flag |= (1 << i);
             ps_dpb_mgr->ps_mod_dpb[uc_lx][modCount++] =
                             ps_dpb_mgr->ps_init_dpb[uc_lx][i];
         }
 
         ui_remapIdc = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         /* Get the remapping_idc - 0/1/2/3 */
         count++;
     }
 
     //Handle the ref indices that were not remapped
     for(i = 0; i < (ps_cur_slice->u1_num_ref_idx_lx_active[uc_lx]); i++)
     {
         if(!(u2_def_mod_flag & (1 << i)))
             ps_dpb_mgr->ps_mod_dpb[uc_lx][modCount++] =
                             ps_dpb_mgr->ps_init_dpb[uc_lx][i];
     }
     return OK;
 }
 /*!
  **************************************************************************
  * \if Function name : ih264d_read_mmco_commands \endif
  *
  * \brief
  *    Parses MMCO commands and stores them in a structure for later use.
  *
  * \return
  *    0 - No error; -1 - Error
  *
  * \note
  *    This function stores MMCO commands in structure only for the first time.
  *    In case of MMCO commands being issued for same Picture Number, they are
  *    just parsed and not stored them in the structure.
  *
  **************************************************************************
  */
@@ -964,392 +973,392 @@ WORD32 ih264d_read_mmco_commands(struct _DecStruct * ps_dec)
 /*!
  **************************************************************************
  * \if Function name : ih264d_do_mmco_buffer \endif
  *
  * \brief
  *    Perform decoded picture buffer memory management control operations
  *
  * \return
  *    0 - No error; -1 - Error
  *
  * \note
  *    Bitstream is also parsed here to get the MMCOs
  *
  **************************************************************************
  */
 WORD32 ih264d_do_mmco_buffer(dpb_commands_t *ps_dpb_cmds,
                           dpb_manager_t *ps_dpb_mgr,
                           UWORD8 u1_numRef_frames_for_seq, /*!< num_ref_frames from active SeqParSet*/
                           UWORD32 u4_cur_pic_num,
                           UWORD32 u2_u4_max_pic_num_minus1,
                           UWORD8 u1_nal_unit_type,
                           struct pic_buffer_t *ps_pic_buf,
                           UWORD8 u1_buf_id,
                           UWORD8 u1_fld_pic_flag,
                           UWORD8 u1_curr_pic_in_err)
 {
     WORD32 i;
     UWORD8 u1_buf_mode, u1_marked_lt;
     struct dpb_info_t *ps_next_dpb;
     UWORD8 u1_num_gaps;
     UWORD8 u1_del_node = 1;
     UWORD8 u1_insert_st_pic = 1;
     WORD32 ret;
     UNUSED(u1_nal_unit_type);
     UNUSED(u2_u4_max_pic_num_minus1);
     u1_buf_mode = ps_dpb_cmds->u1_buf_mode; //0 - sliding window; 1 - Adaptive
     u1_marked_lt = 0;
     u1_num_gaps = ps_dpb_mgr->u1_num_gaps;
 
     if(!u1_buf_mode)
     {
         //Sliding window - implements 8.2.5.3
         if((ps_dpb_mgr->u1_num_st_ref_bufs
                         + ps_dpb_mgr->u1_num_lt_ref_bufs + u1_num_gaps)
                         == u1_numRef_frames_for_seq)
         {
             UWORD8 u1_new_node_flag = 1;
             if((0 == ps_dpb_mgr->u1_num_st_ref_bufs) && (0 == u1_num_gaps))
             {
                 UWORD32 i4_error_code;
                 i4_error_code = ERROR_DBP_MANAGER_T;
                 return i4_error_code;
             }
 
             // Chase the links to reach the last but one picNum, if available
             ps_next_dpb = ps_dpb_mgr->ps_dpb_st_head;
 
             if(ps_dpb_mgr->u1_num_st_ref_bufs > 1)
             {
                 if(ps_next_dpb->i4_frame_num == (WORD32)u4_cur_pic_num)
                 {
                     /* Incase of  filed pictures top_field has been allocated   */
                     /* picture buffer and complementary bottom field pair comes */
                     /* then the sliding window mechanism should not allocate a  */
                     /* new node                                                 */
                     u1_new_node_flag = 0;
                 }
 
                 for(i = 1; i < (ps_dpb_mgr->u1_num_st_ref_bufs - 1); i++)
                 {
                     if(ps_next_dpb == NULL)
                     {
                         UWORD32 i4_error_code;
                         i4_error_code = ERROR_DBP_MANAGER_T;
                         return i4_error_code;
                     }
                     if(ps_next_dpb->i4_frame_num == (WORD32)u4_cur_pic_num)
                     {
                         /* Incase of  field pictures top_field has been allocated   */
                         /* picture buffer and complementary bottom field pair comes */
                         /* then the sliding window mechanism should not allocate a  */
                         /* new node                                                 */
                         u1_new_node_flag = 0;
                     }
                     ps_next_dpb = ps_next_dpb->ps_prev_short;
                 }
 
                 if(ps_next_dpb->ps_prev_short->ps_prev_short != NULL)
                 {
                     UWORD32 i4_error_code;
                     i4_error_code = ERROR_DBP_MANAGER_T;
                     return i4_error_code;
                 }
 
                 if(u1_new_node_flag)
                 {
                     if(u1_num_gaps)
                     {
                         ret = ih264d_delete_gap_frm_sliding(ps_dpb_mgr,
                                                             ps_next_dpb->ps_prev_short->i4_frame_num,
                                                             &u1_del_node);
                         if(ret != OK)
                             return ret;
                     }
 
                     if(u1_del_node)
                     {
                         ps_dpb_mgr->u1_num_st_ref_bufs--;
                         ps_next_dpb->ps_prev_short->u1_used_as_ref =
                                         UNUSED_FOR_REF;
                         ps_next_dpb->ps_prev_short->s_top_field.u1_reference_info =
                                         UNUSED_FOR_REF;
                         ps_next_dpb->ps_prev_short->s_bot_field.u1_reference_info =
                                         UNUSED_FOR_REF;
                         ih264d_free_ref_pic_mv_bufs(ps_dpb_mgr->pv_codec_handle,
                                                     ps_next_dpb->ps_prev_short->u1_buf_id);
                         ps_next_dpb->ps_prev_short->ps_pic_buf = NULL;
                         ps_next_dpb->ps_prev_short = NULL;
                     }
                 }
             }
             else
             {
                 if(ps_dpb_mgr->u1_num_st_ref_bufs)
                 {
                     ret = ih264d_delete_gap_frm_sliding(ps_dpb_mgr,
                                                        ps_next_dpb->i4_frame_num,
                                                        &u1_del_node);
                     if(ret != OK)
                         return ret;
                     if((ps_next_dpb->i4_frame_num != (WORD32)u4_cur_pic_num)
                                     && u1_del_node)
                     {
                         ps_dpb_mgr->u1_num_st_ref_bufs--;
                         ps_next_dpb->u1_used_as_ref = FALSE;
                         ps_next_dpb->s_top_field.u1_reference_info =
                                         UNUSED_FOR_REF;
                         ps_next_dpb->s_bot_field.u1_reference_info =
                                         UNUSED_FOR_REF;
                         ih264d_free_ref_pic_mv_bufs(ps_dpb_mgr->pv_codec_handle,
                                                     ps_next_dpb->u1_buf_id);
                         ps_next_dpb->ps_pic_buf = NULL;
                         ps_next_dpb->ps_prev_short = NULL;
                         ps_dpb_mgr->ps_dpb_st_head = NULL;
                         ps_next_dpb = NULL;
                     }
                     else if(ps_next_dpb->i4_frame_num == (WORD32)u4_cur_pic_num)
                     {
                         if(u1_curr_pic_in_err)
                         {
                             u1_insert_st_pic = 0;
                         }
                         else if(ps_dpb_mgr->u1_num_st_ref_bufs > 0)
                         {
                             ps_dpb_mgr->u1_num_st_ref_bufs--;
                             ps_next_dpb->u1_used_as_ref = FALSE;
                             ps_next_dpb->s_top_field.u1_reference_info =
                                             UNUSED_FOR_REF;
                             ps_next_dpb->s_bot_field.u1_reference_info =
                                             UNUSED_FOR_REF;
                             ih264d_free_ref_pic_mv_bufs(ps_dpb_mgr->pv_codec_handle,
                                                         ps_next_dpb->u1_buf_id);
                             ps_next_dpb->ps_pic_buf = NULL;
                             ps_next_dpb = NULL;
                         }
                     }
                 }
                 else
                 {
                     ret = ih264d_delete_gap_frm_sliding(ps_dpb_mgr,
                                                         INVALID_FRAME_NUM,
                                                         &u1_del_node);
                     if(ret != OK)
                         return ret;
                     if(u1_del_node)
                     {
                         UWORD32 i4_error_code;
                         i4_error_code = ERROR_DBP_MANAGER_T;
                         return i4_error_code;
                     }
                 }
             }
         }
     }
     else
     {
         //Adaptive memory control - implements 8.2.5.4
         UWORD32 u4_mmco;
         UWORD32 u4_diff_pic_num;
         WORD32 i4_pic_num;
         UWORD32 u4_lt_idx;
         WORD32 j;
         struct MMCParams *ps_mmc_params;
 
         for(j = 0; j < ps_dpb_cmds->u1_num_of_commands; j++)
         {
             ps_mmc_params = &ps_dpb_cmds->as_mmc_params[j];
             u4_mmco = ps_mmc_params->u4_mmco; //Get MMCO
 
             switch(u4_mmco)
             {
                 case MARK_ST_PICNUM_AS_NONREF:
                 {
 
                     {
                         UWORD32 i4_cur_pic_num = u4_cur_pic_num;
                         u4_diff_pic_num = ps_mmc_params->u4_diff_pic_num; //Get absDiffPicnumMinus1
                         if(u1_fld_pic_flag)
                             i4_cur_pic_num = i4_cur_pic_num * 2 + 1;
-                        i4_pic_num = i4_cur_pic_num - (u4_diff_pic_num + 1);
+                        i4_pic_num = ((WORD32)i4_cur_pic_num - ((WORD32)u4_diff_pic_num + 1));
                     }
 
                     if(ps_dpb_mgr->u1_num_st_ref_bufs > 0)
                     {
                         ret = ih264d_delete_st_node_or_make_lt(ps_dpb_mgr,
                                                                i4_pic_num,
                                                                MAX_REF_BUFS + 1,
                                                                u1_fld_pic_flag);
                         if(ret != OK)
                             return ret;
                     }
                     else
                     {
                         UWORD8 u1_dummy;
                         ret = ih264d_delete_gap_frm_mmco(ps_dpb_mgr, i4_pic_num, &u1_dummy);
                         if(ret != OK)
                             return ret;
                     }
                     break;
                 }
                 case MARK_LT_INDEX_AS_NONREF:
                 {
                     WORD32 i4_status;
                     u4_lt_idx = ps_mmc_params->u4_lt_idx; //Get long term index
                     ret = ih264d_delete_lt_node(ps_dpb_mgr,
                                                 u4_lt_idx,
                                                 u1_fld_pic_flag,
                                                 0, &i4_status);
                     if(ret != OK)
                         return ret;
                     if(i4_status)
                     {
                         UWORD32 i4_error_code;
                         i4_error_code = ERROR_DBP_MANAGER_T;
                         return i4_error_code;
                     }
                     break;
                 }
 
                 case MARK_ST_PICNUM_AS_LT_INDEX:
                 {
                     {
                         UWORD32 i4_cur_pic_num = u4_cur_pic_num;
                         u4_diff_pic_num = ps_mmc_params->u4_diff_pic_num; //Get absDiffPicnumMinus1
                         if(u1_fld_pic_flag)
                             i4_cur_pic_num = i4_cur_pic_num * 2 + 1;
 
-                        i4_pic_num = i4_cur_pic_num - (u4_diff_pic_num + 1);
+                        i4_pic_num = (WORD32)i4_cur_pic_num - ((WORD32)u4_diff_pic_num + 1);
                     }
 
                     u4_lt_idx = ps_mmc_params->u4_lt_idx; //Get long term index
                     if(ps_dpb_mgr->u1_num_st_ref_bufs > 0)
                     {
                         ret = ih264d_delete_st_node_or_make_lt(ps_dpb_mgr,
                                                                i4_pic_num, u4_lt_idx,
                                                                u1_fld_pic_flag);
                         if(ret != OK)
                             return ret;
                     }
                     break;
                 }
                 case SET_MAX_LT_INDEX:
                 {
                     UWORD8 uc_numLT = ps_dpb_mgr->u1_num_lt_ref_bufs;
                     u4_lt_idx = ps_mmc_params->u4_max_lt_idx_plus1; //Get Max_long_term_index_plus1
                     if(u4_lt_idx < ps_dpb_mgr->u1_max_lt_pic_idx_plus1
                                     && uc_numLT > 0)
                     {
                         struct dpb_info_t *ps_nxtDPB;
                         //Set all LT buffers with index >= u4_lt_idx to nonreference
                         ps_nxtDPB = ps_dpb_mgr->ps_dpb_ht_head;
                         ps_next_dpb = ps_nxtDPB->ps_prev_long;
                         if(ps_nxtDPB->u1_lt_idx >= u4_lt_idx)
                         {
                             i = 0;
                             ps_dpb_mgr->ps_dpb_ht_head = NULL;
                         }
                         else
                         {
                             for(i = 1; i < uc_numLT; i++)
                             {
                                 if(ps_next_dpb->u1_lt_idx >= u4_lt_idx)
                                     break;
                                 ps_nxtDPB = ps_next_dpb;
                                 ps_next_dpb = ps_next_dpb->ps_prev_long;
                             }
                             ps_nxtDPB->ps_prev_long = NULL; //Terminate the link of the closest LTIndex that is <=Max
                         }
                         ps_dpb_mgr->u1_num_lt_ref_bufs = i;
                         if(i == 0)
                             ps_next_dpb = ps_nxtDPB;
 
                         for(; i < uc_numLT; i++)
                         {
                             ps_nxtDPB = ps_next_dpb;
                             ps_nxtDPB->u1_lt_idx = MAX_REF_BUFS + 1;
                             ps_nxtDPB->u1_used_as_ref = UNUSED_FOR_REF;
                             ps_nxtDPB->s_top_field.u1_reference_info =
                                             UNUSED_FOR_REF;
                             ps_nxtDPB->s_bot_field.u1_reference_info =
                                             UNUSED_FOR_REF;
 
                             ps_nxtDPB->ps_pic_buf = NULL;
                             //Release buffer
                             ih264d_free_ref_pic_mv_bufs(ps_dpb_mgr->pv_codec_handle,
                                                         ps_nxtDPB->u1_buf_id);
                             ps_next_dpb = ps_nxtDPB->ps_prev_long;
                             ps_nxtDPB->ps_prev_long = NULL;
                         }
                     }
                     ps_dpb_mgr->u1_max_lt_pic_idx_plus1 = u4_lt_idx;
 
                     break;
                 }
                 case SET_LT_INDEX:
                 {
                     u4_lt_idx = ps_mmc_params->u4_lt_idx; //Get long term index
                     ret = ih264d_insert_st_node(ps_dpb_mgr, ps_pic_buf, u1_buf_id,
                                           u4_cur_pic_num);
                     if(ret != OK)
                         return ret;
 
                     if(ps_dpb_mgr->u1_num_st_ref_bufs > 0)
 
                     {
                         ret = ih264d_delete_st_node_or_make_lt(ps_dpb_mgr,
                                                                u4_cur_pic_num,
                                                                u4_lt_idx,
                                                                u1_fld_pic_flag);
                         if(ret != OK)
                             return ret;
                     }
                     else
                     {
                         return ERROR_DBP_MANAGER_T;
                     }
 
                     u1_marked_lt = 1;
                     break;
                 }
 
                 default:
                     break;
             }
             if(u4_mmco == RESET_REF_PICTURES || u4_mmco == RESET_ALL_PICTURES)
             {
                 ih264d_reset_ref_bufs(ps_dpb_mgr);
                 u4_cur_pic_num = 0;
             }
         }
     }
     if(!u1_marked_lt && u1_insert_st_pic)
     {
         ret = ih264d_insert_st_node(ps_dpb_mgr, ps_pic_buf, u1_buf_id,
                               u4_cur_pic_num);
         if(ret != OK)
             return ret;
     }
     return OK;
 }
 
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : ih264d_release_pics_in_dpb                                         */
 /*                                                                           */
 /*  Description   : This function deletes all pictures from DPB              */
 /*                                                                           */
 /*  Inputs        : h_pic_buf_api: pointer to picture buffer API               */
 /*                  u1_disp_bufs: number pictures ready for display           */
 /*                                                                           */
 /*  Globals       : None                                                     */
 /*  Outputs       : None                                                     */
 /*  Returns       : None                                                     */
 /*                                                                           */
 /*  Issues        : None                                                     */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         22 06 2005   NS              Draft                                */
 /*                                                                           */
 /*****************************************************************************/
diff --git a/decoder/ih264d_error_handler.h b/decoder/ih264d_error_handler.h
index 586fe8a..a3764c6 100644
--- a/decoder/ih264d_error_handler.h
+++ b/decoder/ih264d_error_handler.h
@@ -43,77 +43,78 @@
 typedef enum
 {
 
     ERROR_MEM_ALLOC_ISRAM_T = 0x50,
     ERROR_MEM_ALLOC_SDRAM_T = 0x51,
     ERROR_BUF_MGR = 0x52,
     ERROR_DBP_MANAGER_T = 0x53,
     ERROR_GAPS_IN_FRM_NUM = 0x54,
     ERROR_UNKNOWN_NAL = 0x55,
     ERROR_INV_MB_SLC_GRP_T = 0x56,
     ERROR_MULTIPLE_SLC_GRP_T = 0x57,
     ERROR_UNKNOWN_LEVEL = 0x58,
     ERROR_FEATURE_UNAVAIL = 0x59,
     ERROR_NOT_SUPP_RESOLUTION = 0x5A,
     ERROR_INVALID_PIC_PARAM = 0x5B,
     ERROR_INVALID_SEQ_PARAM = 0x5C,
     ERROR_EGC_EXCEED_32_1_T = 0x5D,
     ERROR_EGC_EXCEED_32_2_T = 0x5E,
     ERROR_INV_RANGE_TEV_T = 0x5F,
     ERROR_INV_SLC_TYPE_T = 0x60,
     ERROR_UNAVAIL_PICBUF_T = 0x61,
     ERROR_UNAVAIL_MVBUF_T = 0x62,
     ERROR_UNAVAIL_DISPBUF_T = 0x63,
     ERROR_INV_POC_TYPE_T = 0x64,
     ERROR_PIC1_NOT_FOUND_T = 0x65,
     ERROR_PIC0_NOT_FOUND_T = 0x66,
     ERROR_NUM_REF = 0x67,
     ERROR_REFIDX_ORDER_T = 0x68,
     ERROR_EOB_FLUSHBITS_T = 0x69,
     ERROR_EOB_GETBITS_T = 0x6A,
     ERROR_EOB_GETBIT_T = 0x6B,
     ERROR_EOB_BYPASS_T = 0x6C,
     ERROR_EOB_DECISION_T = 0x6D,
     ERROR_EOB_TERMINATE_T = 0x6E,
     ERROR_EOB_READCOEFF4X4CAB_T = 0x6F,
     ERROR_INV_RANGE_QP_T = 0x70,
     ERROR_END_OF_FRAME_EXPECTED_T = 0x71,
     ERROR_MB_TYPE = 0x72,
     ERROR_SUB_MB_TYPE = 0x73,
     ERROR_CBP = 0x74,
     ERROR_REF_IDX = 0x75,
     ERROR_NUM_MV = 0x76,
     ERROR_CHROMA_PRED_MODE = 0x77,
     ERROR_INTRAPRED = 0x78,
     ERROR_NEXT_MB_ADDRESS_T = 0x79,
     ERROR_MB_ADDRESS_T = 0x7A,
     ERROR_MB_GROUP_ASSGN_T = 0x7B,
     ERROR_CAVLC_NUM_COEFF_T = 0x7C,
     ERROR_CAVLC_SCAN_POS_T = 0x7D,
     ERROR_CABAC_RENORM_T = 0x7E,
     ERROR_CABAC_SIG_COEFF1_T = 0x7F,
     ERROR_CABAC_SIG_COEFF2_T = 0x80,
     ERROR_CABAC_ENCODE_COEFF_T = 0x81,
     ERROR_INV_SPS_PPS_T = 0x82,
     ERROR_INV_SLICE_HDR_T = 0x83,
     ERROR_PRED_WEIGHT_TABLE_T = 0x84,
     IH264D_VERS_BUF_INSUFFICIENT = 0x85,
     ERROR_ACTUAL_LEVEL_GREATER_THAN_INIT = 0x86,
     ERROR_CORRUPTED_SLICE = 0x87,
     ERROR_FRAME_LIMIT_OVER = 0x88,
     ERROR_ACTUAL_RESOLUTION_GREATER_THAN_INIT = 0x89,
     ERROR_PROFILE_NOT_SUPPORTED = 0x8A,
     ERROR_DISP_WIDTH_RESET_TO_PIC_WIDTH = 0x8B,
     ERROR_DISP_WIDTH_INVALID = 0x8C,
     ERROR_DANGLING_FIELD_IN_PIC = 0x8D,
     ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED = 0x8E,
     ERROR_INIT_NOT_DONE = 0x8F,
     ERROR_LEVEL_UNSUPPORTED = 0x90,
     ERROR_START_CODE_NOT_FOUND = 0x91,
     ERROR_PIC_NUM_IS_REPEATED = 0x92,
     ERROR_IN_LAST_SLICE_OF_PIC = 0x93,
     ERROR_NEW_FRAME_EXPECTED = 0x94,
     ERROR_INCOMPLETE_FRAME = 0x95,
-    ERROR_VUI_PARAMS_NOT_FOUND = 0x96
+    ERROR_VUI_PARAMS_NOT_FOUND = 0x96,
+    ERROR_INV_POC = 0x97
 
 } h264_decoder_error_code_t;
 
diff --git a/decoder/ih264d_parse_bslice.c b/decoder/ih264d_parse_bslice.c
index f087f8d..0af4214 100644
--- a/decoder/ih264d_parse_bslice.c
+++ b/decoder/ih264d_parse_bslice.c
@@ -1171,178 +1171,177 @@ WORD32 ih264d_mv_pred_ref_tfr_nby2_bmb(dec_struct_t * ps_dec,
         /*if num _cores is set to 3 ,compute bs will be done in another thread*/
         if(ps_dec->u4_num_cores < 3)
         {
             if(ps_dec->u4_app_disable_deblk_frm == 0)
                 ps_dec->pf_compute_bs(ps_dec, ps_cur_mb_info,
                                      (UWORD16)(i >> u1_mbaff));
         }
     }
     return OK;
 }
 /*!
  **************************************************************************
  * \if Function name : ih264d_get_implicit_weights \endif
  *
  * \brief
  *    Calculates Implicit Weights.
  *
  * \return
  *    None
  *
  **************************************************************************
  */
 void ih264d_get_implicit_weights(dec_struct_t *ps_dec)
 {
     UWORD32 *pu4_iwt_ofst;
     UWORD8 i, j;
     struct pic_buffer_t *ps_pic_buff0, *ps_pic_buff1;
     WORD16 i2_dist_scale_factor;
     WORD16 i16_tb, i16_td, i16_tx;
     WORD32 i4_tb, i4_td;
     WORD32 i4_poc0, i4_poc1;
     UWORD32 ui_temp0, ui_temp1;
     UWORD8 uc_num_ref_idx_l0_active, uc_num_ref_idx_l1_active;
 
     pu4_iwt_ofst = ps_dec->pu4_wts_ofsts_mat;
     uc_num_ref_idx_l0_active =
                     ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0];
     uc_num_ref_idx_l1_active =
                     ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[1];
 
     for(i = 0; i < uc_num_ref_idx_l0_active; i++)
     {
         ps_pic_buff0 = ps_dec->ps_ref_pic_buf_lx[0][i];
         i4_poc0 = ps_pic_buff0->i4_avg_poc;
         for(j = 0; j < uc_num_ref_idx_l1_active; j++)
         {
             ps_pic_buff1 = ps_dec->ps_ref_pic_buf_lx[1][j];
             i4_poc1 = ps_pic_buff1->i4_avg_poc;
 
             if(i4_poc1 != i4_poc0)
             {
                 i4_tb = ps_dec->ps_cur_pic->i4_poc - i4_poc0;
-                i16_tb = CLIP3(-128, 127, i4_tb);
+                i16_tb = CLIP_S8(i4_tb);
                 i4_td = i4_poc1 - i4_poc0;
-                i16_td = CLIP3(-128, 127, i4_td);
+                i16_td = CLIP_S8(i4_td);
                 i16_tx = (16384 + ABS(SIGN_POW2_DIV(i16_td, 1))) / i16_td;
-                i2_dist_scale_factor = CLIP3(-1024, 1023,
+                i2_dist_scale_factor = CLIP_S11(
                                             (((i16_tb * i16_tx) + 32) >> 6));
 
                 if(/*((u4_poc1 - u4_poc0) == 0) ||*/
                 (!(ps_pic_buff1->u1_is_short && ps_pic_buff0->u1_is_short))
                                 || ((i2_dist_scale_factor >> 2) < -64)
                                 || ((i2_dist_scale_factor >> 2) > 128))
                 {
                     /* same for forward and backward, wt=32 and Offset = 0 */
                     ui_temp0 = 0x00000020;
                     ui_temp1 = 0x00000020;
                 }
                 else
                 {
                     ui_temp0 = 64 - (i2_dist_scale_factor >> 2);
                     ui_temp1 = (i2_dist_scale_factor >> 2);
                 }
             }
             else
             {
                 ui_temp0 = 0x00000020;
                 ui_temp1 = 0x00000020;
             }
             pu4_iwt_ofst[0] = pu4_iwt_ofst[2] = pu4_iwt_ofst[4] = ui_temp0;
             pu4_iwt_ofst[1] = pu4_iwt_ofst[3] = pu4_iwt_ofst[5] = ui_temp1;
             pu4_iwt_ofst += 6;
         }
     }
     if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
     {
         UWORD8 k;
         WORD32 i4_cur_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;
         UWORD32* pu4_wt_mat = ps_dec->pu4_mbaff_wt_mat;
         /* Form the Implicit Weighted prediction matrix for field MBs also */
         for(k = 0; k < 2; k++)
         {
             for(i = 0; i < (uc_num_ref_idx_l0_active << 1); i++)
             {
                 UWORD16 u2_l0_idx;
 
                 /*u2_l0_idx = (i >= uc_num_ref_idx_l0_active)
                  ?(MAX_REF_BUFS + i - uc_num_ref_idx_l0_active) : (i) ;*/
 
                 u2_l0_idx = i >> 1;
                 if((i & 0x01) != k)
                 {
                     u2_l0_idx += MAX_REF_BUFS;
                 }
                 ps_pic_buff0 = ps_dec->ps_ref_pic_buf_lx[0][u2_l0_idx];
                 i4_poc0 = ps_pic_buff0->i4_poc;
                 for(j = 0; j < (uc_num_ref_idx_l1_active << 1); j++)
                 {
                     UWORD16 u2_l1_idx;
                     /*u2_l1_idx = (j >= uc_num_ref_idx_l1_active)
                      ? (MAX_REF_BUFS + j - uc_num_ref_idx_l1_active ) : (j) ;*/
 
                     u2_l1_idx = j >> 1;
                     if((j & 0x01) != k)
                     {
                         u2_l1_idx += MAX_REF_BUFS;
                     }
                     ps_pic_buff1 = ps_dec->ps_ref_pic_buf_lx[1][u2_l1_idx];
                     i4_poc1 = ps_pic_buff1->i4_poc;
                     if(i4_poc1 != i4_poc0)
                     {
                         i4_tb = i4_cur_poc - i4_poc0;
-                        i16_tb = CLIP3(-128, 127, i4_tb);
+                        i16_tb = CLIP_S8(i4_tb);
                         i4_td = i4_poc1 - i4_poc0;
-                        i16_td = CLIP3(-128, 127, i4_td);
+                        i16_td = CLIP_S8(i4_td);
                         i16_tx = (16384 + ABS(SIGN_POW2_DIV(i16_td, 1)))
                                         / i16_td;
-                        i2_dist_scale_factor = CLIP3(
-                                        -1024, 1023,
-                                        (((i16_tb * i16_tx) + 32) >> 6));
+                        i2_dist_scale_factor = CLIP_S11(
+                                                    (((i16_tb * i16_tx) + 32) >> 6));
 
                         if(/*((u4_poc1 - u4_poc0) == 0) ||*/
                         (!(ps_pic_buff1->u1_is_short && ps_pic_buff0->u1_is_short))
                                         || ((i2_dist_scale_factor >> 2) < -64)
                                         || ((i2_dist_scale_factor >> 2) > 128))
                         {
                             /* same for forward and backward, wt=32 and Offset = 0 */
                             ui_temp0 = 0x00000020;
                             ui_temp1 = 0x00000020;
                         }
                         else
                         {
                             ui_temp0 = 64 - (i2_dist_scale_factor >> 2);
                             ui_temp1 = (i2_dist_scale_factor >> 2);
                         }
                     }
                     else
                     {
                         ui_temp0 = 0x00000020;
                         ui_temp1 = 0x00000020;
                     }
                     /* Store in the weight matrix */
                     *pu4_wt_mat++ = ui_temp0;
                     *pu4_wt_mat++ = ui_temp1;
                     *pu4_wt_mat++ = ui_temp0;
                     *pu4_wt_mat++ = ui_temp1;
                     *pu4_wt_mat++ = ui_temp0;
                     *pu4_wt_mat++ = ui_temp1;
 
                 }
             }
             i4_cur_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;
         }
     }
 }
 
 /*!
  **************************************************************************
  * \if Function name : ih264d_decode_bslice \endif
  *
  * \brief
  *    Decodes a B Slice
  *
  *
  * \return
  *    0 on Success and Error code otherwise
  **************************************************************************
  */
diff --git a/decoder/ih264d_parse_cabac.c b/decoder/ih264d_parse_cabac.c
index 9d58f33..c4a3bd5 100644
--- a/decoder/ih264d_parse_cabac.c
+++ b/decoder/ih264d_parse_cabac.c
@@ -64,517 +64,517 @@
 UWORD8 ih264d_read_coeff4x4_cabac(dec_bit_stream_t *ps_bitstrm,
                                   UWORD32 u4_ctxcat,
                                   bin_ctxt_model_t *ps_ctxt_sig_coeff,
                                   dec_struct_t *ps_dec, /*!< pointer to access global variables*/
                                   bin_ctxt_model_t *ps_ctxt_coded)
 {
 
     decoding_envirnoment_t *ps_cab_env = &ps_dec->s_cab_dec_env;
     UWORD32 u4_coded_flag;
     UWORD32 u4_offset, *pu4_buffer;
     UWORD32 u4_code_int_range, u4_code_int_val_ofst;
     tu_sblk4x4_coeff_data_t *ps_tu_4x4;
     WORD16 *pi2_coeff_data;
     WORD32 num_sig_coeffs = 0;
 
     /*loading from strcuctures*/
 
     ps_tu_4x4 = (tu_sblk4x4_coeff_data_t *)ps_dec->pv_parse_tu_coeff_data;
     ps_tu_4x4->u2_sig_coeff_map = 0;
     pi2_coeff_data = &ps_tu_4x4->ai2_level[0];
 
     u4_offset = ps_bitstrm->u4_ofst;
     pu4_buffer = ps_bitstrm->pu4_buffer;
 
     u4_code_int_range = ps_cab_env->u4_code_int_range;
     u4_code_int_val_ofst = ps_cab_env->u4_code_int_val_ofst;
 
     {
 
         /*inilined DecodeDecision_onebin begins*/
 
         {
 
             UWORD32 u4_qnt_int_range, u4_int_range_lps;
             UWORD32 u4_symbol, u1_mps_state;
 
             UWORD32 table_lookup;
             const UWORD32 *pu4_table = (const UWORD32 *)ps_cab_env->cabac_table;
             UWORD32 u4_clz;
 
             u1_mps_state = (ps_ctxt_coded->u1_mps_state);
             u4_clz = CLZ(u4_code_int_range);
             u4_qnt_int_range = u4_code_int_range << u4_clz;
             u4_qnt_int_range = (u4_qnt_int_range >> 29) & 0x3;
             table_lookup =
                             pu4_table[(u1_mps_state << 2) + u4_qnt_int_range];
             u4_int_range_lps = table_lookup & 0xff;
             u4_int_range_lps = u4_int_range_lps << (23 - u4_clz);
             u4_code_int_range = u4_code_int_range - u4_int_range_lps;
             u4_symbol = ((u1_mps_state >> 6) & 0x1);
             u1_mps_state = (table_lookup >> 8) & 0x7F;
 
             CHECK_IF_LPS(u4_code_int_range, u4_code_int_val_ofst, u4_symbol,
                          u4_int_range_lps, u1_mps_state, table_lookup)
 
             if(u4_code_int_range < ONE_RIGHT_SHIFTED_BY_8)
             {
 
                 RENORM_RANGE_OFFSET(u4_code_int_range, u4_code_int_val_ofst,
                                     u4_offset, pu4_buffer)
             }
 
             ps_ctxt_coded->u1_mps_state = u1_mps_state;
             u4_coded_flag = u4_symbol;
 
             /*inilined DecodeDecision_onebin ends*/
 
         }
 
     }
 
     if(u4_coded_flag)
     {
 
         {
             bin_ctxt_model_t *p_binCtxt_last, *p_binCtxt_last_org;
             UWORD32 uc_last_coeff_idx;
             UWORD32 uc_bin;
             UWORD32 i;
             WORD32 first_coeff_offset = 0;
 
             if((u4_ctxcat == CHROMA_AC_CTXCAT) || (u4_ctxcat == LUMA_AC_CTXCAT))
             {
                 first_coeff_offset = 1;
             }
 
             i = 0;
             if(u4_ctxcat == CHROMA_DC_CTXCAT)
             {
                 uc_last_coeff_idx = 3;
             }
             else
             {
                 UWORD32 u4_start;
                 u4_start = (u4_ctxcat & 1) + (u4_ctxcat >> 2);
                 uc_last_coeff_idx = 15 - u4_start;
             }
             p_binCtxt_last_org = ps_ctxt_sig_coeff
                             + LAST_COEFF_CTXT_MINUS_SIG_COEFF_CTXT;
 
             do
             {
 
                 /*inilined DecodeDecision_onebin begins*/
                 {
 
                     UWORD32 u4_qnt_int_range, u4_int_range_lps;
                     UWORD32 u4_symbol, u1_mps_state;
                     UWORD32 table_lookup;
                     const UWORD32 *pu4_table =
                                     (const UWORD32 *)ps_cab_env->cabac_table;
                     UWORD32 u4_clz;
 
                     u1_mps_state = (ps_ctxt_sig_coeff->u1_mps_state);
 
                     u4_clz = CLZ(u4_code_int_range);
 
                     u4_qnt_int_range = u4_code_int_range << u4_clz;
                     u4_qnt_int_range = (u4_qnt_int_range >> 29) & 0x3;
 
                     table_lookup = pu4_table[(u1_mps_state << 2)
                                     + u4_qnt_int_range];
 
                     u4_int_range_lps = table_lookup & 0xff;
 
                     u4_int_range_lps = u4_int_range_lps << (23 - u4_clz);
                     u4_code_int_range = u4_code_int_range - u4_int_range_lps;
                     u4_symbol = ((u1_mps_state >> 6) & 0x1);
                     u1_mps_state = (table_lookup >> 8) & 0x7F;
 
                     CHECK_IF_LPS(u4_code_int_range, u4_code_int_val_ofst,
                                  u4_symbol, u4_int_range_lps, u1_mps_state,
                                  table_lookup)
 
                     if(u4_code_int_range < ONE_RIGHT_SHIFTED_BY_14)
                     {
 
                         UWORD32 read_bits, u4_clz;
                         u4_clz = CLZ(u4_code_int_range);
                         NEXTBITS(read_bits, (u4_offset + 23), pu4_buffer,
                                  u4_clz)
                         FLUSHBITS(u4_offset, (u4_clz))
                         u4_code_int_range = u4_code_int_range << u4_clz;
                         u4_code_int_val_ofst = (u4_code_int_val_ofst << u4_clz)
                                         | read_bits;
                     }
 
                     INC_BIN_COUNT(
                                     ps_cab_env)
 
                     ps_ctxt_sig_coeff->u1_mps_state = u1_mps_state;
                     uc_bin = u4_symbol;
 
                 }
                 /*incrementing pointer to point to the context of the next bin*/
                 ps_ctxt_sig_coeff++;
 
                 /*inilined DecodeDecision_onebin ends*/
 
                 if(uc_bin)
                 {
                     num_sig_coeffs++;
                     SET_BIT(ps_tu_4x4->u2_sig_coeff_map, (i + first_coeff_offset));
 
                     p_binCtxt_last = p_binCtxt_last_org + i;
 
                     /*inilined DecodeDecision_onebin begins*/
 
                     {
 
                         UWORD32 u4_qnt_int_range, u4_int_range_lps;
                         UWORD32 u4_symbol, u1_mps_state;
                         UWORD32 table_lookup;
                         const UWORD32 *pu4_table =
                                         (const UWORD32 *)ps_cab_env->cabac_table;
                         UWORD32 u4_clz;
 
                         u1_mps_state = (p_binCtxt_last->u1_mps_state);
 
                         u4_clz = CLZ(u4_code_int_range);
                         u4_qnt_int_range = u4_code_int_range << u4_clz;
                         u4_qnt_int_range = (u4_qnt_int_range >> 29)
                                         & 0x3;
 
                         table_lookup = pu4_table[(u1_mps_state << 2)
                                         + u4_qnt_int_range];
                         u4_int_range_lps = table_lookup & 0xff;
 
                         u4_int_range_lps = u4_int_range_lps
                                         << (23 - u4_clz);
 
                         u4_code_int_range = u4_code_int_range
                                         - u4_int_range_lps;
                         u4_symbol = ((u1_mps_state >> 6) & 0x1);
                         u1_mps_state = (table_lookup >> 8) & 0x7F;
 
                         CHECK_IF_LPS(u4_code_int_range, u4_code_int_val_ofst,
                                      u4_symbol, u4_int_range_lps,
                                      u1_mps_state, table_lookup)
 
                         INC_BIN_COUNT(ps_cab_env)
 
                         p_binCtxt_last->u1_mps_state = u1_mps_state;
                         uc_bin = u4_symbol;
 
                     }
 
                     /*inilined DecodeDecision_onebin ends*/
                     if(uc_bin == 1)
                         goto label_read_levels;
 
                 }
 
                 i = i + 1;
 
             }
             while(i < uc_last_coeff_idx);
 
             num_sig_coeffs++;
             SET_BIT(ps_tu_4x4->u2_sig_coeff_map, (i + first_coeff_offset));
 
             label_read_levels: ;
 
         }
 
         /// VALUE of No of Coeff in BLOCK = i + 1 for second case else i;
 
         /* Decode coeff_abs_level_minus1 and coeff_sign_flag */
         {
 
             WORD32 i2_abs_lvl;
             UWORD32 u1_abs_level_equal1 = 1, u1_abs_level_gt1 = 0;
 
             UWORD32 u4_ctx_inc;
             UWORD32 ui_prefix;
         bin_ctxt_model_t *p_ctxt_abs_level;
 
 
         p_ctxt_abs_level = ps_dec->p_coeff_abs_level_minus1_t[u4_ctxcat];
         u4_ctx_inc = ((0x51));
 
         /*****************************************************/
         /* Main Loop runs for no. of Significant coefficient */
         /*****************************************************/
 
 
         do
             {
 
                 {
                     INC_SYM_COUNT(&(ps_dec.s_cab_dec_env));
 
                     /*****************************************************/
                     /* inilining a modified ih264d_decode_bins_unary     */
                     /*****************************************************/
 
                     {
                         UWORD32 u4_value;
                         UWORD32 u4_symbol;
                         bin_ctxt_model_t *ps_bin_ctxt;
                         UWORD32 u4_ctx_Inc;
 
                         u4_value = 0;
 
                         u4_ctx_Inc = u4_ctx_inc & 0xf;
                         ps_bin_ctxt = p_ctxt_abs_level + u4_ctx_Inc;
 
                         do
                         {
 
                             {
 
                                 UWORD32 u4_qnt_int_range,
                                                 u4_int_range_lps;
                                 UWORD32 u1_mps_state;
                                 UWORD32 table_lookup;
                                 const UWORD32 *pu4_table =
                                                 (const UWORD32 *)ps_cab_env->cabac_table;
                                 UWORD32 u4_clz;
 
                                 u1_mps_state = (ps_bin_ctxt->u1_mps_state);
                                 u4_clz = CLZ(u4_code_int_range);
                                 u4_qnt_int_range = u4_code_int_range
                                                 << u4_clz;
                                 u4_qnt_int_range = (u4_qnt_int_range
                                                 >> 29) & 0x3;
                                 table_lookup = pu4_table[(u1_mps_state << 2)
                                                 + u4_qnt_int_range];
                                 u4_int_range_lps = table_lookup & 0xff;
 
                                 u4_int_range_lps = u4_int_range_lps
                                                 << (23 - u4_clz);
                                 u4_code_int_range = u4_code_int_range
                                                 - u4_int_range_lps;
                                 u4_symbol = ((u1_mps_state >> 6) & 0x1);
                                 u1_mps_state = (table_lookup >> 8) & 0x7F;
 
                                 CHECK_IF_LPS(u4_code_int_range,
                                              u4_code_int_val_ofst, u4_symbol,
                                              u4_int_range_lps, u1_mps_state,
                                              table_lookup)
 
                                 if(u4_code_int_range < ONE_RIGHT_SHIFTED_BY_9)
                                 {
 
                                     RENORM_RANGE_OFFSET(u4_code_int_range,
                                                         u4_code_int_val_ofst,
                                                         u4_offset, pu4_buffer)
                                 }
 
                                 INC_BIN_COUNT(ps_cab_env);
 
                                 ps_bin_ctxt->u1_mps_state = u1_mps_state;
                             }
 
                             INC_BIN_COUNT(ps_cab_env);INC_DECISION_BINS(ps_cab_env);
 
                             u4_value++;
                             ps_bin_ctxt = p_ctxt_abs_level + (u4_ctx_inc >> 4);
 
                         }
                         while(u4_symbol && (u4_value < UCOFF_LEVEL));
 
                         ui_prefix = u4_value - 1 + u4_symbol;
 
                     }
 
                     if(ui_prefix == UCOFF_LEVEL)
                     {
                         UWORD32 ui16_sufS = 0;
                         UWORD32 u1_max_bins;
                         UWORD32 u4_value;
 
                         i2_abs_lvl = UCOFF_LEVEL;
                         /*inlining ih264d_decode_bypass_bins_unary begins*/
 
                         {
                             UWORD32 uc_bin;
                             UWORD32 bits_to_flush;
-                            UWORD32 max_bits = 32;
+
 
                             bits_to_flush = 0;
                             /*renormalize to ensure there 23 bits more in the u4_code_int_val_ofst*/
                             {
                                 UWORD32 u4_clz, read_bits;
 
                                 u4_clz = CLZ(u4_code_int_range);
                                 FLUSHBITS(u4_offset, u4_clz)
-                                NEXTBITS(read_bits, u4_offset, pu4_buffer, 23)
+                                NEXTBITS(read_bits, u4_offset, pu4_buffer, CABAC_BITS_TO_READ)
                                 u4_code_int_range = u4_code_int_range << u4_clz;
                                 u4_code_int_val_ofst = (u4_code_int_val_ofst
                                                 << u4_clz) | read_bits;
 
                             }
 
                             do
                             {
                                 bits_to_flush++;
 
                                 u4_code_int_range = u4_code_int_range >> 1;
 
                                 if(u4_code_int_val_ofst >= u4_code_int_range)
                                 {
                                     /* S=1 */
                                     uc_bin = 1;
                                     u4_code_int_val_ofst -= u4_code_int_range;
                                 }
                                 else
                                 {
                                     /* S=0 */
                                     uc_bin = 0;
                                 }
 
                                 INC_BIN_COUNT(
                                                 ps_cab_env);INC_BYPASS_BINS(ps_cab_env);
 
                             }
-                            while(uc_bin && (bits_to_flush < max_bits));
+                            while(uc_bin && (bits_to_flush < CABAC_BITS_TO_READ));
 
                             u4_value = (bits_to_flush - 1);
 
                         }
                         /*inlining ih264d_decode_bypass_bins_unary ends*/
 
                         ui16_sufS = (1 << u4_value);
                         u1_max_bins = u4_value;
 
                         if(u4_value > 0)
                         {
 
                             /*inline bypassbins_flc begins*/
 
                             if(u4_value > 10)
                             {
                                 UWORD32 u4_clz, read_bits;
 
                                 u4_clz = CLZ(u4_code_int_range);
                                 FLUSHBITS(u4_offset, u4_clz)
-                                NEXTBITS(read_bits, u4_offset, pu4_buffer, 23)
+                                NEXTBITS(read_bits, u4_offset, pu4_buffer, CABAC_BITS_TO_READ)
                                 u4_code_int_range = u4_code_int_range << u4_clz;
                                 u4_code_int_val_ofst = (u4_code_int_val_ofst
                                                 << u4_clz) | read_bits;
                             }
 
                             {
                                 UWORD32 ui_bins;
                                 UWORD32 uc_bin;
                                 UWORD32 bits_to_flush;
 
                                 ui_bins = 0;
                                 bits_to_flush = 0;
 
                                 do
                                 {
                                     bits_to_flush++;
 
                                     u4_code_int_range = u4_code_int_range >> 1;
 
                                     if(u4_code_int_val_ofst
                                                     >= u4_code_int_range)
                                     {
                                         /* S=1 */
                                         uc_bin = 1;
                                         u4_code_int_val_ofst -=
                                                         u4_code_int_range;
                                     }
                                     else
                                     {
                                         /* S=0 */
                                         uc_bin = 0;
                                     }
 
                                     INC_BIN_COUNT(
                                                     ps_cab_env);INC_BYPASS_BINS(ps_cab_env);
 
                                     ui_bins = ((ui_bins << 1) | uc_bin);
 
                                 }
                                 while(bits_to_flush < u1_max_bins);
 
                                 u4_value = ui_bins;
                             }
 
                             /*inline bypassbins_flc ends*/
 
                         }
 
                         //Value of K
                         ui16_sufS += u4_value;
                         i2_abs_lvl += ui16_sufS;
 
                     }
                     else
                         i2_abs_lvl = 1 + ui_prefix;
 
                     if(i2_abs_lvl > 1)
                     {
                         u1_abs_level_gt1++;
                     }
                     if(!u1_abs_level_gt1)
                     {
                         u1_abs_level_equal1++;
                         u4_ctx_inc = (5 << 4) + MIN(u1_abs_level_equal1, 4);
                     }
                     else
                         u4_ctx_inc = (5 + MIN(u1_abs_level_gt1, 4)) << 4;
 
                     /*u4_ctx_inc = g_table_temp[u1_abs_level_gt1][u1_abs_level_equal1];*/
 
                     /* encode coeff_sign_flag[i] */
 
                     {
                         u4_code_int_range = u4_code_int_range >> 1;
 
                         if(u4_code_int_val_ofst >= (u4_code_int_range))
                         {
                             /* S=1 */
                             u4_code_int_val_ofst -= u4_code_int_range;
                             i2_abs_lvl = (-i2_abs_lvl);
                         }
 
                     }
                     num_sig_coeffs--;
                     *pi2_coeff_data++ = i2_abs_lvl;
                 }
             }
             while(num_sig_coeffs > 0);
         }
     }
 
     if(u4_coded_flag)
     {
         WORD32 offset;
         offset = (UWORD8 *)pi2_coeff_data - (UWORD8 *)ps_tu_4x4;
         offset = ALIGN4(offset);
         ps_dec->pv_parse_tu_coeff_data = (void *)((UWORD8 *)ps_dec->pv_parse_tu_coeff_data + offset);
     }
 
 
     /*updating structures*/
     ps_cab_env->u4_code_int_val_ofst = u4_code_int_val_ofst;
     ps_cab_env->u4_code_int_range = u4_code_int_range;
     ps_bitstrm->u4_ofst = u4_offset;
     return (u4_coded_flag);
 }
 /*!
  ********************************************************************************
  *   \if Function name : ih264d_read_coeff8x8_cabac \endif
  *
  *   \brief  This function encodes residual_block_cabac as defined in 7.3.5.3.2.
  when transform_8x8_flag  = 1
  *
  *   \return
  *       Returns the index of last significant coeff.
  *
  ********************************************************************************
  */
@@ -582,484 +582,484 @@ UWORD8 ih264d_read_coeff4x4_cabac(dec_bit_stream_t *ps_bitstrm,
 void ih264d_read_coeff8x8_cabac(dec_bit_stream_t *ps_bitstrm,
                                 dec_struct_t *ps_dec, /*!< pointer to access global variables*/
                                 dec_mb_info_t *ps_cur_mb_info)
 {
     decoding_envirnoment_t *ps_cab_env = &ps_dec->s_cab_dec_env;
     UWORD32 u4_offset, *pu4_buffer;
     UWORD32 u4_code_int_range, u4_code_int_val_ofst;
 
     /* High profile related declarations */
     UWORD8 u1_field_coding_flag = ps_cur_mb_info->ps_curmb->u1_mb_fld;
     const UWORD8 *pu1_lastcoeff_context_inc =
                     (UWORD8 *)gau1_ih264d_lastcoeff_context_inc;
     const UWORD8 *pu1_sigcoeff_context_inc;
     bin_ctxt_model_t *ps_ctxt_sig_coeff;
     WORD32 num_sig_coeffs = 0;
     tu_blk8x8_coeff_data_t *ps_tu_8x8;
     WORD16 *pi2_coeff_data;
 
     /*loading from strcuctures*/
 
     ps_tu_8x8 = (tu_blk8x8_coeff_data_t *)ps_dec->pv_parse_tu_coeff_data;
     ps_tu_8x8->au4_sig_coeff_map[0] = 0;
     ps_tu_8x8->au4_sig_coeff_map[1] = 0;
     pi2_coeff_data = &ps_tu_8x8->ai2_level[0];
 
 
     if(!u1_field_coding_flag)
     {
         pu1_sigcoeff_context_inc =
                         (UWORD8 *)gau1_ih264d_sigcoeff_context_inc_frame;
 
         /*******************************************************************/
         /* last coefficient context is derived from significant coeff u4_flag */
         /* only significant coefficient matrix need to be initialized      */
         /*******************************************************************/
         ps_ctxt_sig_coeff = ps_dec->s_high_profile.ps_sigcoeff_8x8_frame;
     }
     else
     {
         pu1_sigcoeff_context_inc =
                         (UWORD8 *)gau1_ih264d_sigcoeff_context_inc_field;
 
         /*******************************************************************/
         /* last coefficient context is derived from significant coeff u4_flag */
         /* only significant coefficient matrix need to be initialized      */
         /*******************************************************************/
         ps_ctxt_sig_coeff = ps_dec->s_high_profile.ps_sigcoeff_8x8_field;
     }
 
     /*loading from strcuctures*/
 
     u4_offset = ps_bitstrm->u4_ofst;
     pu4_buffer = ps_bitstrm->pu4_buffer;
 
     u4_code_int_range = ps_cab_env->u4_code_int_range;
     u4_code_int_val_ofst = ps_cab_env->u4_code_int_val_ofst;
 
     {
         {
             bin_ctxt_model_t *p_binCtxt_last, *p_binCtxt_last_org,
                             *p_ctxt_sig_coeff_org;
             UWORD32 uc_last_coeff_idx;
             UWORD32 uc_bin;
             UWORD32 i;
 
             i = 0;
 
             uc_last_coeff_idx = 63;
 
             p_binCtxt_last_org = ps_ctxt_sig_coeff
                             + LAST_COEFF_CTXT_MINUS_SIG_COEFF_CTXT_8X8;
 
             p_ctxt_sig_coeff_org = ps_ctxt_sig_coeff;
 
             do
             {
                 /*inilined DecodeDecision_onebin begins*/
                 {
                     UWORD32 u4_qnt_int_range, u4_int_range_lps;
                     UWORD32 u4_symbol, u1_mps_state;
                     UWORD32 table_lookup;
                     const UWORD32 *pu4_table =
                                     (const UWORD32 *)ps_cab_env->cabac_table;
                     UWORD32 u4_clz;
 
                     u1_mps_state = (ps_ctxt_sig_coeff->u1_mps_state);
 
                     u4_clz = CLZ(u4_code_int_range);
 
                     u4_qnt_int_range = u4_code_int_range << u4_clz;
                     u4_qnt_int_range = (u4_qnt_int_range >> 29) & 0x3;
 
                     table_lookup = pu4_table[(u1_mps_state << 2)
                                     + u4_qnt_int_range];
 
                     u4_int_range_lps = table_lookup & 0xff;
 
                     u4_int_range_lps = u4_int_range_lps << (23 - u4_clz);
                     u4_code_int_range = u4_code_int_range - u4_int_range_lps;
                     u4_symbol = ((u1_mps_state >> 6) & 0x1);
                     u1_mps_state = (table_lookup >> 8) & 0x7F;
 
                     CHECK_IF_LPS(u4_code_int_range, u4_code_int_val_ofst,
                                  u4_symbol, u4_int_range_lps, u1_mps_state,
                                  table_lookup)
 
                     if(u4_code_int_range < ONE_RIGHT_SHIFTED_BY_14)
                     {
                         UWORD32 read_bits, u4_clz;
                         u4_clz = CLZ(u4_code_int_range);
                         NEXTBITS(read_bits, (u4_offset + 23), pu4_buffer,
                                  u4_clz)
                         FLUSHBITS(u4_offset, (u4_clz))
                         u4_code_int_range = u4_code_int_range << u4_clz;
                         u4_code_int_val_ofst = (u4_code_int_val_ofst << u4_clz)
                                         | read_bits;
                     }
 
                     ps_ctxt_sig_coeff->u1_mps_state = u1_mps_state;
                     uc_bin = u4_symbol;
                 }
                 /*incrementing pointer to point to the context of the next bin*/
                 ps_ctxt_sig_coeff = p_ctxt_sig_coeff_org
                                 + pu1_sigcoeff_context_inc[i + 1];
 
                 /*inilined DecodeDecision_onebin ends*/
                 if(uc_bin)
                 {
                     num_sig_coeffs++;
                     SET_BIT(ps_tu_8x8->au4_sig_coeff_map[i>31], (i > 31 ? i - 32:i));
 
                     p_binCtxt_last = p_binCtxt_last_org
                                     + pu1_lastcoeff_context_inc[i];
 
                     /*inilined DecodeDecision_onebin begins*/
 
                     {
                         UWORD32 u4_qnt_int_range, u4_int_range_lps;
                         UWORD32 u4_symbol, u1_mps_state;
                         UWORD32 table_lookup;
                         const UWORD32 *pu4_table =
                                         (const UWORD32 *)ps_cab_env->cabac_table;
                         UWORD32 u4_clz;
 
                         u1_mps_state = (p_binCtxt_last->u1_mps_state);
 
                         u4_clz = CLZ(u4_code_int_range);
                         u4_qnt_int_range = u4_code_int_range << u4_clz;
                         u4_qnt_int_range = (u4_qnt_int_range >> 29)
                                         & 0x3;
 
                         table_lookup = pu4_table[(u1_mps_state << 2)
                                         + u4_qnt_int_range];
                         u4_int_range_lps = table_lookup & 0xff;
 
                         u4_int_range_lps = u4_int_range_lps
                                         << (23 - u4_clz);
 
                         u4_code_int_range = u4_code_int_range
                                         - u4_int_range_lps;
                         u4_symbol = ((u1_mps_state >> 6) & 0x1);
                         u1_mps_state = (table_lookup >> 8) & 0x7F;
 
                         CHECK_IF_LPS(u4_code_int_range, u4_code_int_val_ofst,
                                      u4_symbol, u4_int_range_lps,
                                      u1_mps_state, table_lookup)
 
                         p_binCtxt_last->u1_mps_state = u1_mps_state;
                         uc_bin = u4_symbol;
                     }
 
                     /*inilined DecodeDecision_onebin ends*/
                     if(uc_bin == 1)
                         goto label_read_levels;
 
                 }
 
                 i = i + 1;
 
             }
             while(i < uc_last_coeff_idx);
 
             num_sig_coeffs++;
             SET_BIT(ps_tu_8x8->au4_sig_coeff_map[i>31], (i > 31 ? i - 32:i));
 
             label_read_levels: ;
         }
 
         /// VALUE of No of Coeff in BLOCK = i + 1 for second case else i;
 
         /* Decode coeff_abs_level_minus1 and coeff_sign_flag */
         {
             WORD32 i2_abs_lvl;
             UWORD32 u1_abs_level_equal1 = 1, u1_abs_level_gt1 = 0;
 
             UWORD32 u4_ctx_inc;
             UWORD32 ui_prefix;
             bin_ctxt_model_t *p_ctxt_abs_level;
 
             p_ctxt_abs_level =
                             ps_dec->p_coeff_abs_level_minus1_t[LUMA_8X8_CTXCAT];
             u4_ctx_inc = ((0x51));
 
             /*****************************************************/
             /* Main Loop runs for no. of Significant coefficient */
             /*****************************************************/
             do
             {
                 {
 
                     /*****************************************************/
                     /* inilining a modified ih264d_decode_bins_unary     */
                     /*****************************************************/
 
                     {
                         UWORD32 u4_value;
                         UWORD32 u4_symbol;
                         bin_ctxt_model_t *ps_bin_ctxt;
                         UWORD32 u4_ctx_Inc;
                         u4_value = 0;
 
                         u4_ctx_Inc = u4_ctx_inc & 0xf;
                         ps_bin_ctxt = p_ctxt_abs_level + u4_ctx_Inc;
 
                         do
                         {
                             {
                                 UWORD32 u4_qnt_int_range,
                                                 u4_int_range_lps;
                                 UWORD32 u1_mps_state;
                                 UWORD32 table_lookup;
                                 const UWORD32 *pu4_table =
                                                 (const UWORD32 *)ps_cab_env->cabac_table;
                                 UWORD32 u4_clz;
 
                                 u1_mps_state = (ps_bin_ctxt->u1_mps_state);
                                 u4_clz = CLZ(u4_code_int_range);
                                 u4_qnt_int_range = u4_code_int_range
                                                 << u4_clz;
                                 u4_qnt_int_range = (u4_qnt_int_range
                                                 >> 29) & 0x3;
                                 table_lookup = pu4_table[(u1_mps_state << 2)
                                                 + u4_qnt_int_range];
                                 u4_int_range_lps = table_lookup & 0xff;
 
                                 u4_int_range_lps = u4_int_range_lps
                                                 << (23 - u4_clz);
                                 u4_code_int_range = u4_code_int_range
                                                 - u4_int_range_lps;
                                 u4_symbol = ((u1_mps_state >> 6) & 0x1);
                                 u1_mps_state = (table_lookup >> 8) & 0x7F;
 
                                 CHECK_IF_LPS(u4_code_int_range,
                                              u4_code_int_val_ofst, u4_symbol,
                                              u4_int_range_lps, u1_mps_state,
                                              table_lookup)
 
                                 if(u4_code_int_range < ONE_RIGHT_SHIFTED_BY_9)
                                 {
 
                                     RENORM_RANGE_OFFSET(u4_code_int_range,
                                                         u4_code_int_val_ofst,
                                                         u4_offset, pu4_buffer)
                                 }
 
                                 ps_bin_ctxt->u1_mps_state = u1_mps_state;
                             }
 
                             u4_value++;
                             ps_bin_ctxt = p_ctxt_abs_level + (u4_ctx_inc >> 4);
 
                         }
                         while(u4_symbol && (u4_value < UCOFF_LEVEL));
 
                         ui_prefix = u4_value - 1 + u4_symbol;
                     }
 
                     if(ui_prefix == UCOFF_LEVEL)
                     {
                         UWORD32 ui16_sufS = 0;
                         UWORD32 u1_max_bins;
                         UWORD32 u4_value;
 
                         i2_abs_lvl = UCOFF_LEVEL;
                         /*inlining ih264d_decode_bypass_bins_unary begins*/
 
                         {
                             UWORD32 uc_bin;
                             UWORD32 bits_to_flush;
-                            UWORD32 max_bits = 32;
+
 
                             bits_to_flush = 0;
                             /*renormalize to ensure there 23 bits more in the u4_code_int_val_ofst*/
                             {
                                 UWORD32 u4_clz, read_bits;
 
                                 u4_clz = CLZ(u4_code_int_range);
                                 FLUSHBITS(u4_offset, u4_clz)
-                                NEXTBITS(read_bits, u4_offset, pu4_buffer, 23)
+                                NEXTBITS(read_bits, u4_offset, pu4_buffer, CABAC_BITS_TO_READ)
                                 u4_code_int_range = u4_code_int_range << u4_clz;
                                 u4_code_int_val_ofst = (u4_code_int_val_ofst
                                                 << u4_clz) | read_bits;
                             }
 
                             do
                             {
                                 bits_to_flush++;
 
                                 u4_code_int_range = u4_code_int_range >> 1;
 
                                 if(u4_code_int_val_ofst >= u4_code_int_range)
                                 {
                                     /* S=1 */
                                     uc_bin = 1;
                                     u4_code_int_val_ofst -= u4_code_int_range;
                                 }
                                 else
                                 {
                                     /* S=0 */
                                     uc_bin = 0;
                                 }
 
                             }
-                            while(uc_bin && (bits_to_flush < max_bits));
+                            while(uc_bin && (bits_to_flush < CABAC_BITS_TO_READ));
 
                             u4_value = (bits_to_flush - 1);
                         }
                         /*inlining ih264d_decode_bypass_bins_unary ends*/
 
                         ui16_sufS = (1 << u4_value);
                         u1_max_bins = u4_value;
 
                         if(u4_value > 0)
                         {
                             /*inline bypassbins_flc begins*/
 
                             if(u4_value > 10)
                             {
                                 UWORD32 u4_clz, read_bits;
 
                                 u4_clz = CLZ(u4_code_int_range);
                                 FLUSHBITS(u4_offset, u4_clz)
-                                NEXTBITS(read_bits, u4_offset, pu4_buffer, 23)
+                                NEXTBITS(read_bits, u4_offset, pu4_buffer, CABAC_BITS_TO_READ)
                                 u4_code_int_range = u4_code_int_range << u4_clz;
                                 u4_code_int_val_ofst = (u4_code_int_val_ofst
                                                 << u4_clz) | read_bits;
                             }
 
                             {
                                 UWORD32 ui_bins;
                                 UWORD32 uc_bin;
                                 UWORD32 bits_to_flush;
 
                                 ui_bins = 0;
                                 bits_to_flush = 0;
 
                                 do
                                 {
                                     bits_to_flush++;
 
                                     u4_code_int_range = u4_code_int_range >> 1;
 
                                     if(u4_code_int_val_ofst
                                                     >= u4_code_int_range)
                                     {
                                         /* S=1 */
                                         uc_bin = 1;
                                         u4_code_int_val_ofst -=
                                                         u4_code_int_range;
                                     }
                                     else
                                     {
                                         /* S=0 */
                                         uc_bin = 0;
                                     }
 
                                     ui_bins = ((ui_bins << 1) | uc_bin);
 
                                 }
                                 while(bits_to_flush < u1_max_bins);
 
                                 u4_value = ui_bins;
                             }
                             /*inline bypassbins_flc ends*/
                         }
 
                         //Value of K
                         ui16_sufS += u4_value;
-                        i2_abs_lvl += ui16_sufS;
+                        i2_abs_lvl += (WORD32)ui16_sufS;
                     }
                     else
                     {
                         i2_abs_lvl = 1 + ui_prefix;
                     }
 
                     if(i2_abs_lvl > 1)
                     {
                         u1_abs_level_gt1++;
                     }
                     if(!u1_abs_level_gt1)
                     {
                         u1_abs_level_equal1++;
                         u4_ctx_inc = (5 << 4) + MIN(u1_abs_level_equal1, 4);
                     }
                     else
                     {
                         u4_ctx_inc = (5 + MIN(u1_abs_level_gt1, 4)) << 4;
                     }
 
                     /*u4_ctx_inc = g_table_temp[u1_abs_level_gt1][u1_abs_level_equal1];*/
 
                     /* encode coeff_sign_flag[i] */
 
                     {
                         u4_code_int_range = u4_code_int_range >> 1;
 
                         if(u4_code_int_val_ofst >= (u4_code_int_range))
                         {
                             /* S=1 */
                             u4_code_int_val_ofst -= u4_code_int_range;
                             i2_abs_lvl = (-i2_abs_lvl);
                         }
                     }
 
                     *pi2_coeff_data++ = i2_abs_lvl;
                     num_sig_coeffs--;
                 }
             }
             while(num_sig_coeffs > 0);
         }
     }
 
     {
         WORD32 offset;
         offset = (UWORD8 *)pi2_coeff_data - (UWORD8 *)ps_tu_8x8;
         offset = ALIGN4(offset);
         ps_dec->pv_parse_tu_coeff_data = (void *)((UWORD8 *)ps_dec->pv_parse_tu_coeff_data + offset);
     }
 
     /*updating structures*/
     ps_cab_env->u4_code_int_val_ofst = u4_code_int_val_ofst;
     ps_cab_env->u4_code_int_range = u4_code_int_range;
     ps_bitstrm->u4_ofst = u4_offset;
 }
 
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : ih264d_cabac_parse_8x8block                                     */
 /*                                                                           */
 /*  Description   : This function does the residual parsing of 4 subblocks   */
 /*                  in a 8x8 block.                                          */
 /*                                                                           */
 /*  Inputs        : pi2_coeff_block : pointer to residual block where        */
 /*                  decoded and inverse scan coefficients are updated        */
 /*                                                                           */
 /*                  u4_sub_block_strd : indicates the number of sublocks    */
 /*                  in a row. It is 4 for luma and 2 for chroma.             */
 /*                                                                           */
 /*                  u4_ctx_cat : inidicates context category for residual    */
 /*                  decoding.                                                */
 /*                                                                           */
 /*                  ps_dec : pointer to Decstruct (decoder context)          */
 /*                                                                           */
 /*                  pu1_top_nnz : top nnz pointer                            */
 /*                                                                           */
 /*                  pu1_left_nnz : left nnz pointer                          */
 /*                                                                           */
 /*  Globals       : No                                                       */
 /*  Processing    : Parsing for four subblocks in unrolled, top and left nnz */
 /*                  are updated on the fly. csbp is set in accordance to     */
 /*                  decoded numcoeff for the subblock index in raster order  */
 /*                                                                           */
 /*  Outputs       : The updated residue buffer, nnzs and csbp current block  */
 /*                                                                           */
 /*  Returns       : Returns the coded sub block pattern csbp for the block   */
 /*                                                                           */
 /*  Issues        : <List any issues or problems with this function>         */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         09 10 2008   Jay          Draft                                   */
 /*                                                                           */
 /*****************************************************************************/
diff --git a/decoder/ih264d_parse_cavlc.c b/decoder/ih264d_parse_cavlc.c
index b6a0125..d538a4e 100644
--- a/decoder/ih264d_parse_cavlc.c
+++ b/decoder/ih264d_parse_cavlc.c
@@ -436,281 +436,287 @@ WORD32 ih264d_cavlc_4x4res_block_totalcoeff_1(UWORD32 u4_isdc,
 WORD32 ih264d_cavlc_4x4res_block_totalcoeff_2to10(UWORD32 u4_isdc,
                                                UWORD32 u4_total_coeff_trail_one, /*!<TotalCoefficients<<16+trailingones*/
                                                dec_bit_stream_t *ps_bitstrm)
 {
     UWORD32 u4_total_zeroes;
     WORD32 i;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
     UWORD32 u4_bitstream_offset = ps_bitstrm->u4_ofst;
     UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF;
     UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16;
     // To avoid error check at 4x4 level, allocating for 3 extra levels(16+3)
     // since u4_trailing_ones can at the max be 3. This will be required when
     // u4_total_coeff is less than u4_trailing_ones
     WORD16 ai2_level_arr[19];
     WORD16 *i2_level_arr = &ai2_level_arr[3];
 
     tu_sblk4x4_coeff_data_t *ps_tu_4x4;
     WORD16 *pi2_coeff_data;
     dec_struct_t *ps_dec = (dec_struct_t *)ps_bitstrm->pv_codec_handle;
 
     ps_tu_4x4 = (tu_sblk4x4_coeff_data_t *)ps_dec->pv_parse_tu_coeff_data;
     ps_tu_4x4->u2_sig_coeff_map = 0;
     pi2_coeff_data = &ps_tu_4x4->ai2_level[0];
 
     i = u4_total_coeff - 1;
 
     if(u4_trailing_ones)
     {
         /*********************************************************************/
         /* Decode Trailing Ones                                              */
         /* read the sign of T1's and put them in level array                 */
         /*********************************************************************/
         UWORD32 u4_signs, u4_cnt = u4_trailing_ones;
         WORD16 (*ppi2_trlone_lkup)[3] =
                         (WORD16 (*)[3])gai2_ih264d_trailing_one_level;
         WORD16 *pi2_trlone_lkup;
 
         GETBITS(u4_signs, u4_bitstream_offset, pu4_bitstrm_buf, u4_cnt);
 
         pi2_trlone_lkup = ppi2_trlone_lkup[(1 << u4_cnt) - 2 + u4_signs];
 
-        while(u4_cnt--)
+        while(u4_cnt)
+        {
             i2_level_arr[i--] = *pi2_trlone_lkup++;
+            u4_cnt--;
+        }
     }
 
     /****************************************************************/
     /* Decoding Levels Begins                                       */
     /****************************************************************/
     if(i >= 0)
     {
         /****************************************************************/
         /* First level is decoded outside the loop as it has lot of     */
         /* special cases.                                               */
         /****************************************************************/
         UWORD32 u4_lev_suffix, u4_suffix_len, u4_lev_suffix_size;
         WORD32 u2_lev_code, u2_abs_value;
         UWORD32 u4_lev_prefix;
 
         /***************************************************************/
         /* u4_suffix_len = 0,  Find leading zeros in next 32 bits      */
         /***************************************************************/
         FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,
                               pu4_bitstrm_buf);
 
         /*********************************************************/
         /* Special decoding case when trailing ones are 3        */
         /*********************************************************/
         u2_lev_code = MIN(15, u4_lev_prefix);
 
         u2_lev_code += (3 == u4_trailing_ones) ? 0 : 2;
 
         if(14 == u4_lev_prefix)
             u4_lev_suffix_size = 4;
         else if(15 <= u4_lev_prefix)
         {
             u2_lev_code += 15;
             u4_lev_suffix_size = u4_lev_prefix - 3;
         }
         else
             u4_lev_suffix_size = 0;
 
         //HP_LEVEL_PREFIX
         if(16 <= u4_lev_prefix)
         {
             u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);
         }
         if(u4_lev_suffix_size)
         {
             GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,
                     u4_lev_suffix_size);
             u2_lev_code += u4_lev_suffix;
         }
 
         u2_abs_value = (u2_lev_code + 2) >> 1;
         /*********************************************************/
         /* If Level code is odd, level is negative else positive */
         /*********************************************************/
         i2_level_arr[i--] = (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;
 
         u4_suffix_len = (u2_abs_value > 3) ? 2 : 1;
 
         /*********************************************************/
         /* Now loop over the remaining levels                    */
         /*********************************************************/
         while(i >= 0)
         {
 
             /***************************************************************/
             /* Find leading zeros in next 32 bits                          */
             /***************************************************************/
             FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,
                                   pu4_bitstrm_buf);
 
             u4_lev_suffix_size =
                             (15 <= u4_lev_prefix) ?
                                             (u4_lev_prefix - 3) : u4_suffix_len;
 
             /*********************************************************/
             /* Compute level code using prefix and suffix            */
             /*********************************************************/
             GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,
                     u4_lev_suffix_size);
             u2_lev_code = (MIN(15,u4_lev_prefix) << u4_suffix_len)
                             + u4_lev_suffix;
 
             //HP_LEVEL_PREFIX
             if(16 <= u4_lev_prefix)
             {
                 u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);
             }
             u2_abs_value = (u2_lev_code + 2) >> 1;
 
             /*********************************************************/
             /* If Level code is odd, level is negative else positive */
             /*********************************************************/
             i2_level_arr[i--] =
                             (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;
 
             /*********************************************************/
             /* Increment suffix length if required                   */
             /*********************************************************/
             u4_suffix_len +=
                             (u4_suffix_len < 6) ?
                                             (u2_abs_value
                                                             > (3
                                                                             << (u4_suffix_len
                                                                                             - 1))) :
                                             0;
         }
 
         /****************************************************************/
         /* Decoding Levels Ends                                         */
         /****************************************************************/
     }
 
     /****************************************************************/
     /* Decoding total zeros as in section 9.2.3, table 9.7          */
     /****************************************************************/
     {
         UWORD32 u4_index;
         const UWORD8 (*ppu1_total_zero_lkup)[64] =
                         (const UWORD8 (*)[64])gau1_ih264d_table_total_zero_2to10;
 
         NEXTBITS(u4_index, u4_bitstream_offset, pu4_bitstrm_buf, 6);
         u4_total_zeroes = ppu1_total_zero_lkup[u4_total_coeff - 2][u4_index];
 
         FLUSHBITS(u4_bitstream_offset, (u4_total_zeroes >> 4));
         u4_total_zeroes &= 0xf;
     }
 
     /**************************************************************/
     /* Decode the runs and form the coefficient buffer            */
     /**************************************************************/
     {
         const UWORD8 *pu1_table_runbefore;
         UWORD32 u4_run;
         WORD32 k;
-        UWORD32 u4_scan_pos = u4_total_coeff + u4_total_zeroes - 1 + u4_isdc;
+        WORD32 u4_scan_pos = u4_total_coeff + u4_total_zeroes - 1 + u4_isdc;
         WORD32 u4_zeroes_left = u4_total_zeroes;
         k = u4_total_coeff - 1;
 
         /**************************************************************/
         /* Decoding Runs Begin for zeros left > 6                     */
         /**************************************************************/
         while((u4_zeroes_left > 6) && k)
         {
             UWORD32 u4_code;
 
             NEXTBITS(u4_code, u4_bitstream_offset, pu4_bitstrm_buf, 3);
 
             if(u4_code != 0)
             {
                 FLUSHBITS(u4_bitstream_offset, 3);
                 u4_run = (7 - u4_code);
             }
             else
             {
 
                 FIND_ONE_IN_STREAM_LEN(u4_code, u4_bitstream_offset,
                                        pu4_bitstrm_buf, 11);
                 u4_run = (4 + u4_code);
             }
 
             SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);
             *pi2_coeff_data++ = i2_level_arr[k--];
-            u4_zeroes_left -= u4_run;
-            u4_scan_pos -= (u4_run + 1);
+            u4_zeroes_left -= (WORD32)u4_run;
+            u4_scan_pos -= (WORD32)(u4_run + 1);
         }
 
+        if (u4_zeroes_left < 0 || u4_scan_pos < 0)
+            return -1;
+
         /**************************************************************/
         /* Decoding Runs for 0 < zeros left <=6                       */
         /**************************************************************/
         pu1_table_runbefore = (UWORD8 *)gau1_ih264d_table_run_before;
         while((u4_zeroes_left > 0) && k)
         {
             UWORD32 u4_code;
             NEXTBITS(u4_code, u4_bitstream_offset, pu4_bitstrm_buf, 3);
 
             u4_code = pu1_table_runbefore[u4_code + (u4_zeroes_left << 3)];
             u4_run = u4_code >> 2;
 
             FLUSHBITS(u4_bitstream_offset, (u4_code & 0x03));
 
             SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);
             *pi2_coeff_data++ = i2_level_arr[k--];
-            u4_zeroes_left -= u4_run;
-            u4_scan_pos -= (u4_run + 1);
+            u4_zeroes_left -= (WORD32)u4_run;
+            u4_scan_pos -= (WORD32)(u4_run + 1);
         }
+        if (u4_zeroes_left < 0 || u4_scan_pos < 0)
+            return -1;
         /**************************************************************/
         /* Decoding Runs End                                          */
         /**************************************************************/
 
         /**************************************************************/
         /* Copy the remaining coefficients                            */
         /**************************************************************/
-        if(u4_zeroes_left < 0)
-            return -1;
         while(k >= 0)
         {
 
             SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);
             *pi2_coeff_data++ = i2_level_arr[k--];
             u4_scan_pos--;
         }
     }
 
     {
         WORD32 offset;
         offset = (UWORD8 *)pi2_coeff_data - (UWORD8 *)ps_tu_4x4;
         offset = ALIGN4(offset);
         ps_dec->pv_parse_tu_coeff_data = (void *)((UWORD8 *)ps_dec->pv_parse_tu_coeff_data + offset);
     }
 
     ps_bitstrm->u4_ofst = u4_bitstream_offset;
     return 0;
 }
 
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : ih264d_cavlc_4x4res_block_totalcoeff_11to16                     */
 /*                                                                           */
 /*  Description   : This function does cavlc decoding of 4x4 block residual  */
 /*                  coefficient when total coeffs are greater than ten.      */
 /*                  Parsing is done as defined in section 9.2.2 and 9.2.3 of */
 /*                  the H264 standard.                                       */
 /*                                                                           */
 /*  Inputs        : <What inputs does the function take?>                    */
 /*  Globals       : <Does it use any global variables?>                      */
 /*  Processing    : <Describe how the function operates - include algorithm  */
 /*                  description>                                             */
 /*  Outputs       : <What does the function produce?>                        */
 /*  Returns       : <What does the function return?>                         */
 /*                                                                           */
 /*  Issues        : <List any issues or problems with this function>         */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         25 09 2008   Jay          Draft                                   */
 /*                                                                           */
 /*****************************************************************************/
@@ -718,501 +724,508 @@ WORD32 ih264d_cavlc_4x4res_block_totalcoeff_2to10(UWORD32 u4_isdc,
 WORD32 ih264d_cavlc_4x4res_block_totalcoeff_11to16(UWORD32 u4_isdc,
                                                 UWORD32 u4_total_coeff_trail_one, /*!<TotalCoefficients<<16+trailingones*/
                                                 dec_bit_stream_t *ps_bitstrm )
 {
     UWORD32 u4_total_zeroes;
     WORD32 i;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
     UWORD32 u4_bitstream_offset = ps_bitstrm->u4_ofst;
     UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF;
     UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16;
     // To avoid error check at 4x4 level, allocating for 3 extra levels(16+3)
     // since u4_trailing_ones can at the max be 3. This will be required when
     // u4_total_coeff is less than u4_trailing_ones
     WORD16 ai2_level_arr[19];//
     WORD16 *i2_level_arr = &ai2_level_arr[3];
 
     tu_sblk4x4_coeff_data_t *ps_tu_4x4;
     WORD16 *pi2_coeff_data;
     dec_struct_t *ps_dec = (dec_struct_t *)ps_bitstrm->pv_codec_handle;
 
     ps_tu_4x4 = (tu_sblk4x4_coeff_data_t *)ps_dec->pv_parse_tu_coeff_data;
     ps_tu_4x4->u2_sig_coeff_map = 0;
     pi2_coeff_data = &ps_tu_4x4->ai2_level[0];
 
     i = u4_total_coeff - 1;
     if(u4_trailing_ones)
     {
         /*********************************************************************/
         /* Decode Trailing Ones                                              */
         /* read the sign of T1's and put them in level array                 */
         /*********************************************************************/
         UWORD32 u4_signs, u4_cnt = u4_trailing_ones;
         WORD16 (*ppi2_trlone_lkup)[3] =
                         (WORD16 (*)[3])gai2_ih264d_trailing_one_level;
         WORD16 *pi2_trlone_lkup;
 
         GETBITS(u4_signs, u4_bitstream_offset, pu4_bitstrm_buf, u4_cnt);
 
         pi2_trlone_lkup = ppi2_trlone_lkup[(1 << u4_cnt) - 2 + u4_signs];
 
-        while(u4_cnt--)
+        while(u4_cnt)
+        {
             i2_level_arr[i--] = *pi2_trlone_lkup++;
+            u4_cnt--;
+        }
     }
 
     /****************************************************************/
     /* Decoding Levels Begins                                       */
     /****************************************************************/
     if(i >= 0)
     {
         /****************************************************************/
         /* First level is decoded outside the loop as it has lot of     */
         /* special cases.                                               */
         /****************************************************************/
         UWORD32 u4_lev_suffix, u4_suffix_len, u4_lev_suffix_size;
         UWORD16 u2_lev_code, u2_abs_value;
         UWORD32 u4_lev_prefix;
 
         if(u4_trailing_ones < 3)
         {
             /*********************************************************/
             /* u4_suffix_len = 1                                     */
             /*********************************************************/
             /***************************************************************/
             /* Find leading zeros in next 32 bits                          */
             /***************************************************************/
             FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,
                                   pu4_bitstrm_buf);
 
             u4_lev_suffix_size =
                             (15 <= u4_lev_prefix) ? (u4_lev_prefix - 3) : 1;
 
             GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,
                     u4_lev_suffix_size);
             u2_lev_code = 2 + (MIN(u4_lev_prefix,15) << 1) + u4_lev_suffix;
 
             //HP_LEVEL_PREFIX
             if(16 <= u4_lev_prefix)
             {
                 u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);
             }
         }
         else
         {
             /*********************************************************/
             /*u4_suffix_len = 0                                      */
             /*********************************************************/
             /***************************************************************/
             /* Find leading zeros in next 32 bits                          */
             /***************************************************************/
             FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,
                                   pu4_bitstrm_buf);
 
             /*********************************************************/
             /* Special decoding case when trailing ones are 3        */
             /*********************************************************/
             u2_lev_code = MIN(15, u4_lev_prefix);
 
             u2_lev_code += (3 == u4_trailing_ones) ? 0 : (2);
 
             if(14 == u4_lev_prefix)
                 u4_lev_suffix_size = 4;
             else if(15 <= u4_lev_prefix)
             {
                 u2_lev_code += 15;
                 u4_lev_suffix_size = (u4_lev_prefix - 3);
             }
             else
                 u4_lev_suffix_size = 0;
 
             //HP_LEVEL_PREFIX
             if(16 <= u4_lev_prefix)
             {
                 u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);
             }
             if(u4_lev_suffix_size)
             {
                 GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,
                         u4_lev_suffix_size);
                 u2_lev_code += u4_lev_suffix;
             }
         }
 
         u2_abs_value = (u2_lev_code + 2) >> 1;
         /*********************************************************/
         /* If Level code is odd, level is negative else positive */
         /*********************************************************/
         i2_level_arr[i--] = (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;
 
         u4_suffix_len = (u2_abs_value > 3) ? 2 : 1;
 
         /*********************************************************/
         /* Now loop over the remaining levels                    */
         /*********************************************************/
         while(i >= 0)
         {
 
             /***************************************************************/
             /* Find leading zeros in next 32 bits                          */
             /***************************************************************/
             FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,
                                   pu4_bitstrm_buf);
 
             u4_lev_suffix_size =
                             (15 <= u4_lev_prefix) ?
                                             (u4_lev_prefix - 3) : u4_suffix_len;
 
             /*********************************************************/
             /* Compute level code using prefix and suffix            */
             /*********************************************************/
             GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,
                     u4_lev_suffix_size);
             u2_lev_code = (MIN(15,u4_lev_prefix) << u4_suffix_len)
                             + u4_lev_suffix;
 
             //HP_LEVEL_PREFIX
             if(16 <= u4_lev_prefix)
             {
                 u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);
             }
             u2_abs_value = (u2_lev_code + 2) >> 1;
 
             /*********************************************************/
             /* If Level code is odd, level is negative else positive */
             /*********************************************************/
             i2_level_arr[i--] =
                             (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;
 
             /*********************************************************/
             /* Increment suffix length if required                   */
             /*********************************************************/
             u4_suffix_len +=
                             (u4_suffix_len < 6) ?
                                             (u2_abs_value
                                                             > (3
                                                                             << (u4_suffix_len
                                                                                             - 1))) :
                                             0;
         }
 
         /****************************************************************/
         /* Decoding Levels Ends                                         */
         /****************************************************************/
     }
 
     if(u4_total_coeff < (16 - u4_isdc))
     {
         UWORD32 u4_index;
         const UWORD8 (*ppu1_total_zero_lkup)[16] =
                         (const UWORD8 (*)[16])gau1_ih264d_table_total_zero_11to15;
 
         NEXTBITS(u4_index, u4_bitstream_offset, pu4_bitstrm_buf, 4);
         u4_total_zeroes = ppu1_total_zero_lkup[u4_total_coeff - 11][u4_index];
 
         FLUSHBITS(u4_bitstream_offset, (u4_total_zeroes >> 4));
         u4_total_zeroes &= 0xf;
     }
     else
         u4_total_zeroes = 0;
 
     /**************************************************************/
     /* Decode the runs and form the coefficient buffer            */
     /**************************************************************/
     {
         const UWORD8 *pu1_table_runbefore;
         UWORD32 u4_run;
         WORD32 k;
-        UWORD32 u4_scan_pos = u4_total_coeff + u4_total_zeroes - 1 + u4_isdc;
+        WORD32 u4_scan_pos = u4_total_coeff + u4_total_zeroes - 1 + u4_isdc;
         WORD32 u4_zeroes_left = u4_total_zeroes;
         k = u4_total_coeff - 1;
 
         /**************************************************************/
         /* Decoding Runs for 0 < zeros left <=6                       */
         /**************************************************************/
         pu1_table_runbefore = (UWORD8 *)gau1_ih264d_table_run_before;
         while((u4_zeroes_left > 0) && k)
         {
             UWORD32 u4_code;
             NEXTBITS(u4_code, u4_bitstream_offset, pu4_bitstrm_buf, 3);
 
             u4_code = pu1_table_runbefore[u4_code + (u4_zeroes_left << 3)];
             u4_run = u4_code >> 2;
 
             FLUSHBITS(u4_bitstream_offset, (u4_code & 0x03));
             SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);
             *pi2_coeff_data++ = i2_level_arr[k--];
-            u4_zeroes_left -= u4_run;
-            u4_scan_pos -= (u4_run + 1);
+            u4_zeroes_left -= (WORD32)u4_run;
+            u4_scan_pos -= (WORD32)(u4_run + 1);
         }
+        if (u4_zeroes_left < 0 || u4_scan_pos < 0)
+          return -1;
+
         /**************************************************************/
         /* Decoding Runs End                                          */
         /**************************************************************/
 
         /**************************************************************/
         /* Copy the remaining coefficients                            */
         /**************************************************************/
-        if(u4_zeroes_left < 0)
-            return -1;
         while(k >= 0)
         {
             SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);
             *pi2_coeff_data++ = i2_level_arr[k--];
             u4_scan_pos--;
         }
     }
 
     {
         WORD32 offset;
         offset = (UWORD8 *)pi2_coeff_data - (UWORD8 *)ps_tu_4x4;
         offset = ALIGN4(offset);
         ps_dec->pv_parse_tu_coeff_data = (void *)((UWORD8 *)ps_dec->pv_parse_tu_coeff_data + offset);
     }
 
     ps_bitstrm->u4_ofst = u4_bitstream_offset;
     return 0;
 }
 
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : ih264d_rest_of_residual_cav_chroma_dc_block              */
 /*                                                                           */
 /*  Description   : This function does the Cavlc parsing of the bitstream    */
 /*                  for chroma dc coefficients                               */
 /*  Inputs        : <What inputs does the function take?>                    */
 /*  Globals       : <Does it use any global variables?>                      */
 /*  Processing    : <Describe how the function operates - include algorithm  */
 /*                  description>                                             */
 /*  Outputs       : <What does the function produce?>                        */
 /*  Returns       : <What does the function return?>                         */
 /*                                                                           */
 /*  Issues        : <List any issues or problems with this function>         */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         15 09 2008   Jay          Draft                                   */
 /*                                                                           */
 /*****************************************************************************/
 void ih264d_rest_of_residual_cav_chroma_dc_block(UWORD32 u4_total_coeff_trail_one,
                                                  dec_bit_stream_t *ps_bitstrm)
 {
     UWORD32 u4_total_zeroes;
     WORD16 i;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
     UWORD32 u4_bitstream_offset = ps_bitstrm->u4_ofst;
     UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF;
     UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16;
     // To avoid error check at 4x4 level, allocating for 3 extra levels(4+3)
     // since u4_trailing_ones can at the max be 3. This will be required when
     // u4_total_coeff is less than u4_trailing_ones
     WORD16 ai2_level_arr[7];//
     WORD16 *i2_level_arr = &ai2_level_arr[3];
 
     tu_sblk4x4_coeff_data_t *ps_tu_4x4;
     WORD16 *pi2_coeff_data;
     dec_struct_t *ps_dec = (dec_struct_t *)ps_bitstrm->pv_codec_handle;
 
     ps_tu_4x4 = (tu_sblk4x4_coeff_data_t *)ps_dec->pv_parse_tu_coeff_data;
     ps_tu_4x4->u2_sig_coeff_map = 0;
     pi2_coeff_data = &ps_tu_4x4->ai2_level[0];
 
     i = u4_total_coeff - 1;
     if(u4_trailing_ones)
     {
         /*********************************************************************/
         /* Decode Trailing Ones                                              */
         /* read the sign of T1's and put them in level array                 */
         /*********************************************************************/
         UWORD32 u4_signs, u4_cnt = u4_trailing_ones;
         WORD16 (*ppi2_trlone_lkup)[3] =
                         (WORD16 (*)[3])gai2_ih264d_trailing_one_level;
         WORD16 *pi2_trlone_lkup;
 
         GETBITS(u4_signs, u4_bitstream_offset, pu4_bitstrm_buf, u4_cnt);
 
         pi2_trlone_lkup = ppi2_trlone_lkup[(1 << u4_cnt) - 2 + u4_signs];
 
-        while(u4_cnt--)
+        while(u4_cnt)
+        {
             i2_level_arr[i--] = *pi2_trlone_lkup++;
+            u4_cnt--;
+        }
     }
 
     /****************************************************************/
     /* Decoding Levels Begins                                       */
     /****************************************************************/
     if(i >= 0)
     {
         /****************************************************************/
         /* First level is decoded outside the loop as it has lot of     */
         /* special cases.                                               */
         /****************************************************************/
         UWORD32 u4_lev_suffix, u4_suffix_len, u4_lev_suffix_size;
         UWORD16 u2_lev_code, u2_abs_value;
         UWORD32 u4_lev_prefix;
 
         /***************************************************************/
         /* u4_suffix_len = 0,  Find leading zeros in next 32 bits      */
         /***************************************************************/
         FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,
                               pu4_bitstrm_buf);
 
         /*********************************************************/
         /* Special decoding case when trailing ones are 3        */
         /*********************************************************/
         u2_lev_code = MIN(15, u4_lev_prefix);
 
         u2_lev_code += (3 == u4_trailing_ones) ? 0 : (2);
 
         if(14 == u4_lev_prefix)
             u4_lev_suffix_size = 4;
         else if(15 <= u4_lev_prefix)
         {
             u2_lev_code += 15;
             u4_lev_suffix_size = u4_lev_prefix - 3;
         }
         else
             u4_lev_suffix_size = 0;
 
         //HP_LEVEL_PREFIX
         if(16 <= u4_lev_prefix)
         {
             u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);
         }
         if(u4_lev_suffix_size)
         {
             GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,
                     u4_lev_suffix_size);
             u2_lev_code += u4_lev_suffix;
         }
 
         u2_abs_value = (u2_lev_code + 2) >> 1;
         /*********************************************************/
         /* If Level code is odd, level is negative else positive */
         /*********************************************************/
         i2_level_arr[i--] = (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;
 
         u4_suffix_len = (u2_abs_value > 3) ? 2 : 1;
 
         /*********************************************************/
         /* Now loop over the remaining levels                    */
         /*********************************************************/
         while(i >= 0)
         {
 
             /***************************************************************/
             /* Find leading zeros in next 32 bits                          */
             /***************************************************************/
             FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,
                                   pu4_bitstrm_buf);
 
             u4_lev_suffix_size =
                             (15 <= u4_lev_prefix) ?
                                             (u4_lev_prefix - 3) : u4_suffix_len;
 
             /*********************************************************/
             /* Compute level code using prefix and suffix            */
             /*********************************************************/
             GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,
                     u4_lev_suffix_size);
             u2_lev_code = (MIN(u4_lev_prefix,15) << u4_suffix_len)
                             + u4_lev_suffix;
 
             //HP_LEVEL_PREFIX
             if(16 <= u4_lev_prefix)
             {
                 u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);
             }
             u2_abs_value = (u2_lev_code + 2) >> 1;
 
             /*********************************************************/
             /* If Level code is odd, level is negative else positive */
             /*********************************************************/
             i2_level_arr[i--] =
                             (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;
 
             /*********************************************************/
             /* Increment suffix length if required                   */
             /*********************************************************/
             u4_suffix_len += (u2_abs_value > (3 << (u4_suffix_len - 1)));
         }
 
         /****************************************************************/
         /* Decoding Levels Ends                                         */
         /****************************************************************/
     }
 
     if(u4_total_coeff < 4)
     {
         UWORD32 u4_max_ldz = (4 - u4_total_coeff);
         FIND_ONE_IN_STREAM_LEN(u4_total_zeroes, u4_bitstream_offset,
                                pu4_bitstrm_buf, u4_max_ldz);
     }
     else
         u4_total_zeroes = 0;
 
     /**************************************************************/
     /* Decode the runs and form the coefficient buffer            */
     /**************************************************************/
     {
         const UWORD8 *pu1_table_runbefore;
         UWORD32 u4_run;
-        UWORD32 u4_scan_pos = (u4_total_coeff + u4_total_zeroes - 1);
+        WORD32 u4_scan_pos = (u4_total_coeff + u4_total_zeroes - 1);
         UWORD32 u4_zeroes_left = u4_total_zeroes;
         i = u4_total_coeff - 1;
 
         /**************************************************************/
         /* Decoding Runs for 0 < zeros left <=6                       */
         /**************************************************************/
         pu1_table_runbefore = (UWORD8 *)gau1_ih264d_table_run_before;
         while(u4_zeroes_left && i)
         {
             UWORD32 u4_code;
             NEXTBITS(u4_code, u4_bitstream_offset, pu4_bitstrm_buf, 3);
 
             u4_code = pu1_table_runbefore[u4_code + (u4_zeroes_left << 3)];
             u4_run = u4_code >> 2;
 
             FLUSHBITS(u4_bitstream_offset, (u4_code & 0x03));
             SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);
             *pi2_coeff_data++ = i2_level_arr[i--];
-            u4_zeroes_left -= u4_run;
-            u4_scan_pos -= (u4_run + 1);
+            u4_zeroes_left -= (WORD32)u4_run;
+            u4_scan_pos -= (WORD32)(u4_run + 1);
         }
         /**************************************************************/
         /* Decoding Runs End                                          */
         /**************************************************************/
 
         /**************************************************************/
         /* Copy the remaining coefficients                            */
         /**************************************************************/
         while(i >= 0)
         {
             SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);
             *pi2_coeff_data++ = i2_level_arr[i--];
             u4_scan_pos--;
         }
     }
 
     {
         WORD32 offset;
         offset = (UWORD8 *)pi2_coeff_data - (UWORD8 *)ps_tu_4x4;
         offset = ALIGN4(offset);
         ps_dec->pv_parse_tu_coeff_data = (void *)((UWORD8 *)ps_dec->pv_parse_tu_coeff_data + offset);
     }
 
     ps_bitstrm->u4_ofst = u4_bitstream_offset;
 }
 
 /*!
  **************************************************************************
  * \if Function name : CavlcParsingInvScanInvQuant \endif
  *
  * \brief
  *    This function do cavlc parsing of coefficient tokens for any block
  *    type except chromDc and depending
  *    on whenther any coefficients to be parsed calls module
  *    RestOfResidualBlockCavlc.
  *
  * \return
  *    Returns total number of non-zero coefficients.
  *
  **************************************************************************
  */
@@ -1320,158 +1333,158 @@ WORD32 ih264d_cavlc_parse4x4coeff_n8(WORD16 *pi2_coeff_block,
 void ih264d_cavlc_parse_chroma_dc(dec_mb_info_t *ps_cur_mb_info,
                                   WORD16 *pi2_coeff_block,
                                   dec_bit_stream_t *ps_bitstrm,
                                   UWORD32 u4_scale_u,
                                   UWORD32 u4_scale_v,
                                   WORD32 i4_mb_inter_inc)
 {
     UWORD32 u4_total_coeff, u4_trailing_ones, u4_total_coeff_tone, u4_code;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
     UWORD32 u4_bitstream_offset = ps_bitstrm->u4_ofst;
     const UWORD8 *pu1_cav_chromdc = (const UWORD8*)gau1_ih264d_cav_chromdc_vld;
     UNUSED(i4_mb_inter_inc);
     /******************************************************************/
     /*  Chroma DC Block for U component                               */
     /******************************************************************/
     NEXTBITS(u4_code, u4_bitstream_offset, pu4_bitstrm_buf, 8);
 
     u4_code = pu1_cav_chromdc[u4_code];
 
     FLUSHBITS(u4_bitstream_offset, ((u4_code & 0x7) + 1));
     ps_bitstrm->u4_ofst = u4_bitstream_offset;
 
     u4_total_coeff = (u4_code >> 5);
 
     if(u4_total_coeff)
     {
         WORD32 i_z0, i_z1, i_z2, i_z3;
         tu_sblk4x4_coeff_data_t *ps_tu_4x4;
         dec_struct_t *ps_dec = (dec_struct_t *)ps_bitstrm->pv_codec_handle;
         WORD16 ai2_dc_coef[4];
         UWORD8 pu1_inv_scan[4] =
                         { 0, 1, 2, 3 };
         WORD16 *pi2_coeff_data =
                                     (WORD16 *)ps_dec->pv_parse_tu_coeff_data;
 
         ps_tu_4x4 = (tu_sblk4x4_coeff_data_t *)ps_dec->pv_parse_tu_coeff_data;
 
         u4_trailing_ones = ((u4_code >> 3) & 0x3);
         u4_total_coeff_tone = (u4_total_coeff << 16) | u4_trailing_ones;
         ih264d_rest_of_residual_cav_chroma_dc_block(u4_total_coeff_tone,
                                                     ps_bitstrm);
 
         ai2_dc_coef[0] = 0;
         ai2_dc_coef[1] = 0;
         ai2_dc_coef[2] = 0;
         ai2_dc_coef[3] = 0;
 
         ih264d_unpack_coeff4x4_dc_4x4blk(ps_tu_4x4,
                                          ai2_dc_coef,
                                          pu1_inv_scan);
         /*-------------------------------------------------------------------*/
         /* Inverse 2x2 transform and scaling  of chroma DC                   */
         /*-------------------------------------------------------------------*/
         i_z0 = (ai2_dc_coef[0] + ai2_dc_coef[2]);
         i_z1 = (ai2_dc_coef[0] - ai2_dc_coef[2]);
         i_z2 = (ai2_dc_coef[1] - ai2_dc_coef[3]);
         i_z3 = (ai2_dc_coef[1] + ai2_dc_coef[3]);
 
         /*-----------------------------------------------------------*/
         /* Scaling and storing the values back                       */
         /*-----------------------------------------------------------*/
-        *pi2_coeff_data++ = ((i_z0 + i_z3) * u4_scale_u) >> 5;
-        *pi2_coeff_data++ = ((i_z0 - i_z3) * u4_scale_u) >> 5;
-        *pi2_coeff_data++ = ((i_z1 + i_z2) * u4_scale_u) >> 5;
-        *pi2_coeff_data++ = ((i_z1 - i_z2) * u4_scale_u) >> 5;
+        *pi2_coeff_data++ = (WORD16)(((i_z0 + i_z3) * (WORD32)u4_scale_u) >> 5);
+        *pi2_coeff_data++ = (WORD16)(((i_z0 - i_z3) * (WORD32)u4_scale_u) >> 5);
+        *pi2_coeff_data++ = (WORD16)(((i_z1 + i_z2) * (WORD32)u4_scale_u) >> 5);
+        *pi2_coeff_data++ = (WORD16)(((i_z1 - i_z2) * (WORD32)u4_scale_u) >> 5);
 
         ps_dec->pv_parse_tu_coeff_data = (void *)pi2_coeff_data;
 
         SET_BIT(ps_cur_mb_info->u1_yuv_dc_block_flag,1);
     }
 
     /******************************************************************/
     /*  Chroma DC Block for V component                               */
     /******************************************************************/
     pi2_coeff_block += 64;
     u4_bitstream_offset = ps_bitstrm->u4_ofst;
 
     NEXTBITS(u4_code, u4_bitstream_offset, pu4_bitstrm_buf, 8);
 
     u4_code = pu1_cav_chromdc[u4_code];
 
     FLUSHBITS(u4_bitstream_offset, ((u4_code & 0x7) + 1));
     ps_bitstrm->u4_ofst = u4_bitstream_offset;
 
     u4_total_coeff = (u4_code >> 5);
 
     if(u4_total_coeff)
     {
         WORD32 i_z0, i_z1, i_z2, i_z3;
         tu_sblk4x4_coeff_data_t *ps_tu_4x4;
         dec_struct_t *ps_dec = (dec_struct_t *)ps_bitstrm->pv_codec_handle;
         WORD16 ai2_dc_coef[4];
         UWORD8 pu1_inv_scan[4] =
                         { 0, 1, 2, 3 };
         WORD16 *pi2_coeff_data =
                                     (WORD16 *)ps_dec->pv_parse_tu_coeff_data;
 
         ps_tu_4x4 = (tu_sblk4x4_coeff_data_t *)ps_dec->pv_parse_tu_coeff_data;
 
         u4_trailing_ones = ((u4_code >> 3) & 0x3);
         u4_total_coeff_tone = (u4_total_coeff << 16) | u4_trailing_ones;
         ih264d_rest_of_residual_cav_chroma_dc_block(u4_total_coeff_tone,
                                                     ps_bitstrm);
 
         ai2_dc_coef[0] = 0;
         ai2_dc_coef[1] = 0;
         ai2_dc_coef[2] = 0;
         ai2_dc_coef[3] = 0;
 
         ih264d_unpack_coeff4x4_dc_4x4blk(ps_tu_4x4,
                                          ai2_dc_coef,
                                          pu1_inv_scan);
 
         /*-------------------------------------------------------------------*/
         /* Inverse 2x2 transform and scaling  of chroma DC                   */
         /*-------------------------------------------------------------------*/
         i_z0 = (ai2_dc_coef[0] + ai2_dc_coef[2]);
         i_z1 = (ai2_dc_coef[0] - ai2_dc_coef[2]);
         i_z2 = (ai2_dc_coef[1] - ai2_dc_coef[3]);
         i_z3 = (ai2_dc_coef[1] + ai2_dc_coef[3]);
 
         /*-----------------------------------------------------------*/
         /* Scaling and storing the values back                       */
         /*-----------------------------------------------------------*/
-        *pi2_coeff_data++ = ((i_z0 + i_z3) * u4_scale_v) >> 5;
-        *pi2_coeff_data++ = ((i_z0 - i_z3) * u4_scale_v) >> 5;
-        *pi2_coeff_data++ = ((i_z1 + i_z2) * u4_scale_v) >> 5;
-        *pi2_coeff_data++ = ((i_z1 - i_z2) * u4_scale_v) >> 5;
+        *pi2_coeff_data++ = (WORD16)(((i_z0 + i_z3) * (WORD32)u4_scale_v) >> 5);
+        *pi2_coeff_data++ = (WORD16)(((i_z0 - i_z3) * (WORD32)u4_scale_v) >> 5);
+        *pi2_coeff_data++ = (WORD16)(((i_z1 + i_z2) * (WORD32)u4_scale_v) >> 5);
+        *pi2_coeff_data++ = (WORD16)(((i_z1 - i_z2) * (WORD32)u4_scale_v) >> 5);
 
         ps_dec->pv_parse_tu_coeff_data = (void *)pi2_coeff_data;
 
         SET_BIT(ps_cur_mb_info->u1_yuv_dc_block_flag,2);
     }
 }
 
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : ih264d_parse_pmb_ref_index_cavlc_range1                         */
 /*                                                                           */
 /*  Description   : This function does the Cavlc  TEV range =1 parsing of    */
 /*                  reference index  for a P MB. Range is 1 when             */
 /*                  num_ref_idx_active_minus1 is 0                           */
 /*                                                                           */
 /*  Inputs        : <What inputs does the function take?>                    */
 /*  Globals       : <Does it use any global variables?>                      */
 /*  Processing    : <Describe how the function operates - include algorithm  */
 /*                  description>                                             */
 /*  Outputs       : <What does the function produce?>                        */
 /*  Returns       : <What does the function return?>                         */
 /*                                                                           */
 /*  Issues        : <List any issues or problems with this function>         */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         19 09 2008   Jay          Draft                                   */
 /*                                                                           */
 /*****************************************************************************/
diff --git a/decoder/ih264d_parse_headers.c b/decoder/ih264d_parse_headers.c
index d9f50f4..03b423c 100644
--- a/decoder/ih264d_parse_headers.c
+++ b/decoder/ih264d_parse_headers.c
@@ -181,216 +181,222 @@ void ih264d_parse_end_of_stream(dec_struct_t * ps_dec)
 /*!
  **************************************************************************
  * \if Function name : ih264d_parse_pps \endif
  *
  * \brief
  *    Decodes Picture Parameter set
  *
  * \return
  *    0 on Success and Error code otherwise
  **************************************************************************
  */
 WORD32 ih264d_parse_pps(dec_struct_t * ps_dec, dec_bit_stream_t * ps_bitstrm)
 {
     UWORD8 uc_temp;
     dec_seq_params_t * ps_sps = NULL;
     dec_pic_params_t * ps_pps = NULL;
     UWORD32 *pu4_bitstrm_buf = ps_dec->ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_dec->ps_bitstrm->u4_ofst;
 
     /* Variables used for error resilience checks */
     UWORD32 u4_temp;
     WORD32 i_temp;
 
     /* For High profile related syntax elements */
     UWORD8 u1_more_data_flag;
     WORD32 i4_i;
 
+    if(!(ps_dec->i4_header_decoded & 1))
+        return ERROR_INV_SPS_PPS_T;
+
     /*--------------------------------------------------------------------*/
     /* Decode pic_parameter_set_id and find corresponding pic params      */
     /*--------------------------------------------------------------------*/
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u4_temp & MASK_ERR_PIC_SET_ID)
         return ERROR_INV_SPS_PPS_T;
     ps_pps = ps_dec->pv_scratch_sps_pps;
     *ps_pps = ps_dec->ps_pps[u4_temp];
     ps_pps->u1_pic_parameter_set_id = (WORD8)u4_temp;
     COPYTHECONTEXT("PPS: pic_parameter_set_id",ps_pps->u1_pic_parameter_set_id);
 
     /************************************************/
     /* initilization of High profile syntax element */
     /************************************************/
     ps_pps->i4_transform_8x8_mode_flag = 0;
     ps_pps->i4_pic_scaling_matrix_present_flag = 0;
 
     /*--------------------------------------------------------------------*/
     /* Decode seq_parameter_set_id and map it to a seq_parameter_set      */
     /*--------------------------------------------------------------------*/
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u4_temp & MASK_ERR_SEQ_SET_ID)
         return ERROR_INV_SPS_PPS_T;
     COPYTHECONTEXT("PPS: seq_parameter_set_id",u4_temp);
     ps_sps = &ps_dec->ps_sps[u4_temp];
+
+    if(FALSE == ps_sps->u1_is_valid)
+        return ERROR_INV_SPS_PPS_T;
     ps_pps->ps_sps = ps_sps;
 
     /*--------------------------------------------------------------------*/
     /* Decode entropy_coding_mode                                         */
     /*--------------------------------------------------------------------*/
     ps_pps->u1_entropy_coding_mode = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("PPS: entropy_coding_mode_flag",ps_pps->u1_entropy_coding_mode);
 
     ps_pps->u1_pic_order_present_flag = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("PPS: pic_order_present_flag",ps_pps->u1_pic_order_present_flag);
 
     /*--------------------------------------------------------------------*/
     /* Decode num_slice_groups_minus1                                     */
     /*--------------------------------------------------------------------*/
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf) + 1;
     if(u4_temp != 1)
     {
         UWORD32 i4_error_code;
         i4_error_code = ERROR_FEATURE_UNAVAIL;
         return i4_error_code;
     }
     ps_pps->u1_num_slice_groups = u4_temp;
     COPYTHECONTEXT("PPS: num_slice_groups_minus1",ps_pps->u1_num_slice_groups -1);
 
     /*--------------------------------------------------------------------*/
     /* Other parameter set values                                         */
     /*--------------------------------------------------------------------*/
     u4_temp = 1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u4_temp > H264_MAX_REF_IDX)
         return ERROR_REF_IDX;
     ps_pps->u1_num_ref_idx_lx_active[0] = u4_temp;
     COPYTHECONTEXT("PPS: num_ref_idx_l0_active_minus1",
                     ps_pps->u1_num_ref_idx_lx_active[0] - 1);
 
     u4_temp = 1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u4_temp > H264_MAX_REF_IDX)
         return ERROR_REF_IDX;
     ps_pps->u1_num_ref_idx_lx_active[1] = u4_temp;
     COPYTHECONTEXT("PPS: num_ref_idx_l1_active_minus1",
                     ps_pps->u1_num_ref_idx_lx_active[1] - 1);
 
     ps_pps->u1_wted_pred_flag = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("PPS: weighted prediction u4_flag",ps_pps->u1_wted_pred_flag);
     uc_temp = ih264d_get_bits_h264(ps_bitstrm, 2);
     COPYTHECONTEXT("PPS: weighted_bipred_idc",uc_temp);
     ps_pps->u1_wted_bipred_idc = uc_temp;
 
     if(ps_pps->u1_wted_bipred_idc > MAX_WEIGHT_BIPRED_IDC)
         return ERROR_INV_SPS_PPS_T;
 
     i_temp = 26 + ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
     if((i_temp < 0) || (i_temp > 51))
         return ERROR_INV_RANGE_QP_T;
 
     ps_pps->u1_pic_init_qp = i_temp;
     COPYTHECONTEXT("PPS: pic_init_qp_minus26",ps_pps->u1_pic_init_qp - 26);
 
     i_temp = 26 + ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
     if((i_temp < 0) || (i_temp > 51))
         return ERROR_INV_RANGE_QP_T;
 
     ps_pps->u1_pic_init_qs = i_temp;
     COPYTHECONTEXT("PPS: pic_init_qs_minus26",ps_pps->u1_pic_init_qs - 26);
 
     i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if((i_temp < -12) || (i_temp > 12))
         return ERROR_INV_RANGE_QP_T;
     ps_pps->i1_chroma_qp_index_offset = i_temp;
     COPYTHECONTEXT("PPS: chroma_qp_index_offset",ps_pps->i1_chroma_qp_index_offset);
 
     /***************************************************************************/
     /* initialize second_chroma_qp_index_offset to i1_chroma_qp_index_offset if */
     /* second_chroma_qp_index_offset is not present in bit-ps_bitstrm              */
     /***************************************************************************/
     ps_pps->i1_second_chroma_qp_index_offset =
                     ps_pps->i1_chroma_qp_index_offset;
 
     ps_pps->u1_deblocking_filter_parameters_present_flag = ih264d_get_bit_h264(
                     ps_bitstrm);
     COPYTHECONTEXT("PPS: deblocking_filter_control_present_flag",
                     ps_pps->u1_deblocking_filter_parameters_present_flag);
     ps_pps->u1_constrained_intra_pred_flag = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("PPS: constrained_intra_pred_flag",
                     ps_pps->u1_constrained_intra_pred_flag);
     ps_pps->u1_redundant_pic_cnt_present_flag = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("PPS: redundant_pic_cnt_present_flag",
                     ps_pps->u1_redundant_pic_cnt_present_flag);
 
     /* High profile related syntax elements */
     u1_more_data_flag = MORE_RBSP_DATA(ps_bitstrm);
     if(u1_more_data_flag && (ps_pps->ps_sps->u1_profile_idc == HIGH_PROFILE_IDC))
     {
         /* read transform_8x8_mode_flag  */
         ps_pps->i4_transform_8x8_mode_flag = (WORD32)ih264d_get_bit_h264(
                         ps_bitstrm);
 
         /* read pic_scaling_matrix_present_flag */
         ps_pps->i4_pic_scaling_matrix_present_flag =
                         (WORD32)ih264d_get_bit_h264(ps_bitstrm);
 
         if(ps_pps->i4_pic_scaling_matrix_present_flag)
         {
             /* read the scaling matrices */
             for(i4_i = 0; i4_i < (6 + (ps_pps->i4_transform_8x8_mode_flag << 1)); i4_i++)
             {
                 ps_pps->u1_pic_scaling_list_present_flag[i4_i] =
                                 ih264d_get_bit_h264(ps_bitstrm);
 
                 if(ps_pps->u1_pic_scaling_list_present_flag[i4_i])
                 {
                     if(i4_i < 6)
                     {
                         ih264d_scaling_list(
                                         ps_pps->i2_pic_scalinglist4x4[i4_i],
                                         16,
                                         &ps_pps->u1_pic_use_default_scaling_matrix_flag[i4_i],
                                         ps_bitstrm);
                     }
                     else
                     {
                         ih264d_scaling_list(
                                         ps_pps->i2_pic_scalinglist8x8[i4_i - 6],
                                         64,
                                         &ps_pps->u1_pic_use_default_scaling_matrix_flag[i4_i],
                                         ps_bitstrm);
                     }
                 }
             }
         }
 
         /* read second_chroma_qp_index_offset syntax element */
         i_temp = ih264d_sev(
                         pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
         if((i_temp < -12) || (i_temp > 12))
             return ERROR_INV_RANGE_QP_T;
 
         ps_pps->i1_second_chroma_qp_index_offset = i_temp;
     }
 
     /* In case bitstream read has exceeded the filled size, then
        return an error */
     if(ps_bitstrm->u4_ofst > ps_bitstrm->u4_max_ofst + 8)
     {
         return ERROR_INV_SPS_PPS_T;
     }
     ps_pps->u1_is_valid = TRUE;
     ps_dec->ps_pps[ps_pps->u1_pic_parameter_set_id] = *ps_pps;
     return OK;
 }
 
 /*!
  **************************************************************************
  * \if Function name : ih264d_parse_sps \endif
  *
  * \brief
  *    Decodes Sequence parameter set from the bitstream
  *
  * \return
  *    0 on Success and Error code otherwise
  **************************************************************************
  */
@@ -479,566 +485,573 @@ UWORD32 ih264d_correct_level_idc(UWORD32 u4_level_idc, UWORD32 u4_total_mbs)
 }
 WORD32 ih264d_parse_sps(dec_struct_t *ps_dec, dec_bit_stream_t *ps_bitstrm)
 {
     UWORD8 i;
     dec_seq_params_t *ps_seq = NULL;
     UWORD8 u1_profile_idc, u1_level_idc, u1_seq_parameter_set_id, u1_mb_aff_flag = 0;
     UWORD16 i2_max_frm_num;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
     UWORD8 u1_frm, uc_constraint_set0_flag, uc_constraint_set1_flag;
     WORD32 i4_cropped_ht, i4_cropped_wd;
     UWORD32 u4_temp;
-    WORD32 pic_height_in_map_units_minus1 = 0;
+    UWORD32 u4_pic_height_in_map_units, u4_pic_width_in_mbs;
     UWORD32 u2_pic_wd = 0;
     UWORD32 u2_pic_ht = 0;
     UWORD32 u2_frm_wd_y = 0;
     UWORD32 u2_frm_ht_y = 0;
     UWORD32 u2_frm_wd_uv = 0;
     UWORD32 u2_frm_ht_uv = 0;
     UWORD32 u2_crop_offset_y = 0;
     UWORD32 u2_crop_offset_uv = 0;
     WORD32 ret;
-    UWORD32 u4_num_reorder_frames;
+    WORD32 num_reorder_frames;
     /* High profile related syntax element */
     WORD32 i4_i;
     /* G050 */
     UWORD8 u1_frame_cropping_flag, u1_frame_cropping_rect_left_ofst,
                     u1_frame_cropping_rect_right_ofst,
                     u1_frame_cropping_rect_top_ofst,
                     u1_frame_cropping_rect_bottom_ofst;
     /* G050 */
     /*--------------------------------------------------------------------*/
     /* Decode seq_parameter_set_id and profile and level values           */
     /*--------------------------------------------------------------------*/
     SWITCHONTRACE;
     u1_profile_idc = ih264d_get_bits_h264(ps_bitstrm, 8);
     COPYTHECONTEXT("SPS: profile_idc",u1_profile_idc);
 
     /* G050 */
     uc_constraint_set0_flag = ih264d_get_bit_h264(ps_bitstrm);
     uc_constraint_set1_flag = ih264d_get_bit_h264(ps_bitstrm);
     ih264d_get_bit_h264(ps_bitstrm);
 
     /*****************************************************/
     /* Read 5 bits for uc_constraint_set3_flag (1 bit)   */
     /* and reserved_zero_4bits (4 bits) - Sushant        */
     /*****************************************************/
     ih264d_get_bits_h264(ps_bitstrm, 5);
     /* G050 */
 
     /* Check whether particular profile is suported or not */
     /* Check whether particular profile is suported or not */
     if((u1_profile_idc != MAIN_PROFILE_IDC) &&
 
     (u1_profile_idc != BASE_PROFILE_IDC) &&
 
     (u1_profile_idc != HIGH_PROFILE_IDC)
 
     )
     {
 
         /* Apart from Baseline, main and high profile,
          * only extended profile is supported provided
          * uc_constraint_set0_flag or uc_constraint_set1_flag are set to 1
          */
         if((u1_profile_idc != EXTENDED_PROFILE_IDC) ||
            ((uc_constraint_set1_flag != 1) && (uc_constraint_set0_flag != 1)))
         {
             return (ERROR_FEATURE_UNAVAIL);
         }
     }
 
     u1_level_idc = ih264d_get_bits_h264(ps_bitstrm, 8);
 
 
 
     COPYTHECONTEXT("SPS: u4_level_idc",u1_level_idc);
 
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u4_temp & MASK_ERR_SEQ_SET_ID)
         return ERROR_INV_SPS_PPS_T;
     u1_seq_parameter_set_id = u4_temp;
     COPYTHECONTEXT("SPS: seq_parameter_set_id",
                     u1_seq_parameter_set_id);
 
     /*--------------------------------------------------------------------*/
     /* Find an seq param entry in seqparam array of decStruct             */
     /*--------------------------------------------------------------------*/
 
     ps_seq = ps_dec->pv_scratch_sps_pps;
     memset(ps_seq, 0, sizeof(dec_seq_params_t));
 
     if(ps_dec->i4_header_decoded & 1)
     {
         *ps_seq = *ps_dec->ps_cur_sps;
     }
 
 
     if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_profile_idc != u1_profile_idc))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
 
     if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_level_idc != u1_level_idc))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
 
     ps_seq->u1_profile_idc = u1_profile_idc;
     ps_seq->u1_level_idc = u1_level_idc;
     ps_seq->u1_seq_parameter_set_id = u1_seq_parameter_set_id;
 
     /*******************************************************************/
     /* Initializations for high profile - Sushant                      */
     /*******************************************************************/
     ps_seq->i4_chroma_format_idc = 1;
     ps_seq->i4_bit_depth_luma_minus8 = 0;
     ps_seq->i4_bit_depth_chroma_minus8 = 0;
     ps_seq->i4_qpprime_y_zero_transform_bypass_flag = 0;
     ps_seq->i4_seq_scaling_matrix_present_flag = 0;
     if(u1_profile_idc == HIGH_PROFILE_IDC)
     {
 
         /* reading chroma_format_idc   */
         ps_seq->i4_chroma_format_idc = ih264d_uev(pu4_bitstrm_ofst,
                                                   pu4_bitstrm_buf);
 
         /* Monochrome is not supported */
         if(ps_seq->i4_chroma_format_idc != 1)
         {
-            return ERROR_INV_SPS_PPS_T;
+            return ERROR_FEATURE_UNAVAIL;
         }
 
         /* reading bit_depth_luma_minus8   */
         ps_seq->i4_bit_depth_luma_minus8 = ih264d_uev(pu4_bitstrm_ofst,
                                                       pu4_bitstrm_buf);
 
         if(ps_seq->i4_bit_depth_luma_minus8 != 0)
         {
-            return ERROR_INV_SPS_PPS_T;
+            return ERROR_FEATURE_UNAVAIL;
         }
 
         /* reading bit_depth_chroma_minus8   */
         ps_seq->i4_bit_depth_chroma_minus8 = ih264d_uev(pu4_bitstrm_ofst,
                                                         pu4_bitstrm_buf);
 
         if(ps_seq->i4_bit_depth_chroma_minus8 != 0)
         {
-            return ERROR_INV_SPS_PPS_T;
+            return ERROR_FEATURE_UNAVAIL;
         }
 
         /* reading qpprime_y_zero_transform_bypass_flag   */
         ps_seq->i4_qpprime_y_zero_transform_bypass_flag =
                         (WORD32)ih264d_get_bit_h264(ps_bitstrm);
 
         if(ps_seq->i4_qpprime_y_zero_transform_bypass_flag != 0)
         {
             return ERROR_INV_SPS_PPS_T;
         }
 
         /* reading seq_scaling_matrix_present_flag   */
         ps_seq->i4_seq_scaling_matrix_present_flag =
                         (WORD32)ih264d_get_bit_h264(ps_bitstrm);
 
         if(ps_seq->i4_seq_scaling_matrix_present_flag)
         {
             for(i4_i = 0; i4_i < 8; i4_i++)
             {
                 ps_seq->u1_seq_scaling_list_present_flag[i4_i] =
                                 ih264d_get_bit_h264(ps_bitstrm);
 
                 /* initialize u1_use_default_scaling_matrix_flag[i4_i] to zero */
                 /* before calling scaling list                             */
                 ps_seq->u1_use_default_scaling_matrix_flag[i4_i] = 0;
 
                 if(ps_seq->u1_seq_scaling_list_present_flag[i4_i])
                 {
                     if(i4_i < 6)
                     {
                         ih264d_scaling_list(
                                         ps_seq->i2_scalinglist4x4[i4_i],
                                         16,
                                         &ps_seq->u1_use_default_scaling_matrix_flag[i4_i],
                                         ps_bitstrm);
                     }
                     else
                     {
                         ih264d_scaling_list(
                                         ps_seq->i2_scalinglist8x8[i4_i - 6],
                                         64,
                                         &ps_seq->u1_use_default_scaling_matrix_flag[i4_i],
                                         ps_bitstrm);
                     }
                 }
             }
         }
     }
     /*--------------------------------------------------------------------*/
     /* Decode MaxFrameNum                                                 */
     /*--------------------------------------------------------------------*/
     u4_temp = 4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u4_temp > MAX_BITS_IN_FRAME_NUM)
     {
         return ERROR_INV_SPS_PPS_T;
     }
     ps_seq->u1_bits_in_frm_num = u4_temp;
     COPYTHECONTEXT("SPS: log2_max_frame_num_minus4",
                     (ps_seq->u1_bits_in_frm_num - 4));
 
     i2_max_frm_num = (1 << (ps_seq->u1_bits_in_frm_num));
     ps_seq->u2_u4_max_pic_num_minus1 = i2_max_frm_num - 1;
     /*--------------------------------------------------------------------*/
     /* Decode picture order count and related values                      */
     /*--------------------------------------------------------------------*/
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
     if(u4_temp > MAX_PIC_ORDER_CNT_TYPE)
     {
         return ERROR_INV_POC_TYPE_T;
     }
     ps_seq->u1_pic_order_cnt_type = u4_temp;
     COPYTHECONTEXT("SPS: pic_order_cnt_type",ps_seq->u1_pic_order_cnt_type);
 
     ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = 1;
     if(ps_seq->u1_pic_order_cnt_type == 0)
     {
         u4_temp = 4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         if(u4_temp > MAX_BITS_IN_POC_LSB)
         {
             return ERROR_INV_SPS_PPS_T;
         }
         ps_seq->u1_log2_max_pic_order_cnt_lsb_minus = u4_temp;
         ps_seq->i4_max_pic_order_cntLsb = (1 << u4_temp);
         COPYTHECONTEXT("SPS: log2_max_pic_order_cnt_lsb_minus4",(u4_temp - 4));
     }
     else if(ps_seq->u1_pic_order_cnt_type == 1)
     {
         ps_seq->u1_delta_pic_order_always_zero_flag = ih264d_get_bit_h264(
                         ps_bitstrm);
         COPYTHECONTEXT("SPS: delta_pic_order_always_zero_flag",
                         ps_seq->u1_delta_pic_order_always_zero_flag);
 
         ps_seq->i4_ofst_for_non_ref_pic = ih264d_sev(pu4_bitstrm_ofst,
                                                      pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: offset_for_non_ref_pic",
                         ps_seq->i4_ofst_for_non_ref_pic);
 
         ps_seq->i4_ofst_for_top_to_bottom_field = ih264d_sev(
                         pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: offset_for_top_to_bottom_field",
                         ps_seq->i4_ofst_for_top_to_bottom_field);
 
         u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         if(u4_temp > 255)
             return ERROR_INV_SPS_PPS_T;
         ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = u4_temp;
         COPYTHECONTEXT("SPS: num_ref_frames_in_pic_order_cnt_cycle",
                         ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle);
 
         for(i = 0; i < ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle; i++)
         {
             ps_seq->i4_ofst_for_ref_frame[i] = ih264d_sev(
                             pu4_bitstrm_ofst, pu4_bitstrm_buf);
             COPYTHECONTEXT("SPS: offset_for_ref_frame",
                             ps_seq->i4_ofst_for_ref_frame[i]);
         }
     }
 
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
     if((u4_temp > H264_MAX_REF_PICS))
     {
         return ERROR_NUM_REF;
     }
 
     /* Compare with older num_ref_frames is header is already once */
     if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_num_ref_frames != u4_temp))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
 
     ps_seq->u1_num_ref_frames = u4_temp;
     COPYTHECONTEXT("SPS: num_ref_frames",ps_seq->u1_num_ref_frames);
 
     ps_seq->u1_gaps_in_frame_num_value_allowed_flag = ih264d_get_bit_h264(
                     ps_bitstrm);
     COPYTHECONTEXT("SPS: gaps_in_frame_num_value_allowed_flag",
                     ps_seq->u1_gaps_in_frame_num_value_allowed_flag);
 
     /*--------------------------------------------------------------------*/
     /* Decode FrameWidth and FrameHeight and related values               */
     /*--------------------------------------------------------------------*/
-    ps_seq->u2_frm_wd_in_mbs = 1
+    u4_pic_width_in_mbs = 1
                     + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     COPYTHECONTEXT("SPS: pic_width_in_mbs_minus1",
-                    ps_seq->u2_frm_wd_in_mbs - 1);
-    u2_pic_wd = (ps_seq->u2_frm_wd_in_mbs << 4);
+                   u4_pic_width_in_mbs - 1);
 
-    pic_height_in_map_units_minus1 = ih264d_uev(pu4_bitstrm_ofst,
+    u4_pic_height_in_map_units = 1 + ih264d_uev(pu4_bitstrm_ofst,
                                                 pu4_bitstrm_buf);
-    ps_seq->u2_frm_ht_in_mbs = 1 + pic_height_in_map_units_minus1;
 
-    u2_pic_ht = (ps_seq->u2_frm_ht_in_mbs << 4);
+    /* Check  for unsupported resolutions*/
+    if((u4_pic_width_in_mbs > (H264_MAX_FRAME_WIDTH >> 4)) ||
+        (u4_pic_height_in_map_units > (H264_MAX_FRAME_HEIGHT >> 4)))
+    {
+        return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
+    }
+    ps_seq->u2_frm_wd_in_mbs = u4_pic_width_in_mbs;
+    ps_seq->u2_frm_ht_in_mbs = u4_pic_height_in_map_units;
 
+    u2_pic_wd = (u4_pic_width_in_mbs << 4);
+    u2_pic_ht = (u4_pic_height_in_map_units << 4);
     /*--------------------------------------------------------------------*/
     /* Get the value of MaxMbAddress and Number of bits needed for it     */
     /*--------------------------------------------------------------------*/
     ps_seq->u2_max_mb_addr = (ps_seq->u2_frm_wd_in_mbs
                     * ps_seq->u2_frm_ht_in_mbs) - 1;
 
     ps_seq->u2_total_num_of_mbs = ps_seq->u2_max_mb_addr + 1;
 
     ps_seq->u1_level_idc = ih264d_correct_level_idc(
                     u1_level_idc, ps_seq->u2_total_num_of_mbs);
 
     u1_frm = ih264d_get_bit_h264(ps_bitstrm);
     if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_frame_mbs_only_flag != u1_frm))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
 
     ps_seq->u1_frame_mbs_only_flag = u1_frm;
 
     COPYTHECONTEXT("SPS: frame_mbs_only_flag", u1_frm);
 
     if(!u1_frm)
         u1_mb_aff_flag = ih264d_get_bit_h264(ps_bitstrm);
 
     if((ps_dec->i4_header_decoded & 1)
                     && (ps_seq->u1_mb_aff_flag != u1_mb_aff_flag))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
 
     if(!u1_frm)
     {
         u2_pic_ht <<= 1;
         ps_seq->u1_mb_aff_flag = u1_mb_aff_flag;
         COPYTHECONTEXT("SPS: mb_adaptive_frame_field_flag",
                         ps_seq->u1_mb_aff_flag);
 
     }
     else
         ps_seq->u1_mb_aff_flag = 0;
 
     ps_seq->u1_direct_8x8_inference_flag = ih264d_get_bit_h264(ps_bitstrm);
 
     COPYTHECONTEXT("SPS: direct_8x8_inference_flag",
                     ps_seq->u1_direct_8x8_inference_flag);
 
     /* G050 */
     u1_frame_cropping_flag = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("SPS: frame_cropping_flag",u1_frame_cropping_flag);
 
     if(u1_frame_cropping_flag)
     {
         u1_frame_cropping_rect_left_ofst = ih264d_uev(pu4_bitstrm_ofst,
                                                       pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: frame_cropping_rect_left_offset",
                         u1_frame_cropping_rect_left_ofst);
         u1_frame_cropping_rect_right_ofst = ih264d_uev(pu4_bitstrm_ofst,
                                                        pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: frame_cropping_rect_right_offset",
                         u1_frame_cropping_rect_right_ofst);
         u1_frame_cropping_rect_top_ofst = ih264d_uev(pu4_bitstrm_ofst,
                                                      pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: frame_cropping_rect_top_offset",
                         u1_frame_cropping_rect_top_ofst);
         u1_frame_cropping_rect_bottom_ofst = ih264d_uev(pu4_bitstrm_ofst,
                                                         pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: frame_cropping_rect_bottom_offset",
                         u1_frame_cropping_rect_bottom_ofst);
     }
     /* G050 */
 
     ps_seq->u1_vui_parameters_present_flag = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("SPS: vui_parameters_present_flag",
                     ps_seq->u1_vui_parameters_present_flag);
 
     u2_frm_wd_y = u2_pic_wd + (UWORD8)(PAD_LEN_Y_H << 1);
     if(1 == ps_dec->u4_share_disp_buf)
     {
         if(ps_dec->u4_app_disp_width > u2_frm_wd_y)
             u2_frm_wd_y = ps_dec->u4_app_disp_width;
     }
 
     u2_frm_ht_y = u2_pic_ht + (UWORD8)(PAD_LEN_Y_V << 2);
     u2_frm_wd_uv = u2_pic_wd + (UWORD8)(PAD_LEN_UV_H << 2);
     u2_frm_wd_uv = MAX(u2_frm_wd_uv, u2_frm_wd_y);
 
     u2_frm_ht_uv = (u2_pic_ht >> 1) + (UWORD8)(PAD_LEN_UV_V << 2);
     u2_frm_ht_uv = MAX(u2_frm_ht_uv, (u2_frm_ht_y >> 1));
 
 
     /* Calculate display picture width, height and start u4_ofst from YUV420 */
     /* pictute buffers as per cropping information parsed above             */
     {
         UWORD16 u2_rgt_ofst = 0;
         UWORD16 u2_lft_ofst = 0;
         UWORD16 u2_top_ofst = 0;
         UWORD16 u2_btm_ofst = 0;
         UWORD8 u1_frm_mbs_flag;
         UWORD8 u1_vert_mult_factor;
 
         if(u1_frame_cropping_flag)
         {
             /* Calculate right and left u4_ofst for cropped picture           */
             u2_rgt_ofst = u1_frame_cropping_rect_right_ofst << 1;
             u2_lft_ofst = u1_frame_cropping_rect_left_ofst << 1;
 
             /* Know frame MBs only u4_flag                                      */
             u1_frm_mbs_flag = (1 == ps_seq->u1_frame_mbs_only_flag);
 
             /* Simplify the vertical u4_ofst calculation from field/frame     */
             u1_vert_mult_factor = (2 - u1_frm_mbs_flag);
 
             /* Calculate bottom and top u4_ofst for cropped  picture          */
             u2_btm_ofst = (u1_frame_cropping_rect_bottom_ofst
                             << u1_vert_mult_factor);
             u2_top_ofst = (u1_frame_cropping_rect_top_ofst
                             << u1_vert_mult_factor);
         }
 
         /* Calculate u4_ofst from start of YUV 420 picture buffer to start of*/
         /* cropped picture buffer                                           */
         u2_crop_offset_y = (u2_frm_wd_y * u2_top_ofst) + (u2_lft_ofst);
         u2_crop_offset_uv = (u2_frm_wd_uv * (u2_top_ofst >> 1))
                         + (u2_lft_ofst >> 1) * YUV420SP_FACTOR;
         /* Calculate the display picture width and height based on crop      */
         /* information                                                       */
-        i4_cropped_ht = u2_pic_ht - (u2_btm_ofst + u2_top_ofst);
-        i4_cropped_wd = u2_pic_wd - (u2_rgt_ofst + u2_lft_ofst);
+        i4_cropped_ht = (WORD32)u2_pic_ht - (WORD32)(u2_btm_ofst + u2_top_ofst);
+        i4_cropped_wd = (WORD32)u2_pic_wd - (WORD32)(u2_rgt_ofst + u2_lft_ofst);
 
         if((i4_cropped_ht < MB_SIZE) || (i4_cropped_wd < MB_SIZE))
         {
             return ERROR_INV_SPS_PPS_T;
         }
 
         if((ps_dec->i4_header_decoded & 1) && (ps_dec->u2_pic_wd != u2_pic_wd))
         {
             ps_dec->u1_res_changed = 1;
             return IVD_RES_CHANGED;
         }
 
         if((ps_dec->i4_header_decoded & 1) && (ps_dec->u2_disp_width != i4_cropped_wd))
         {
             ps_dec->u1_res_changed = 1;
             return IVD_RES_CHANGED;
         }
 
         if((ps_dec->i4_header_decoded & 1) && (ps_dec->u2_pic_ht != u2_pic_ht))
         {
             ps_dec->u1_res_changed = 1;
             return IVD_RES_CHANGED;
         }
 
         if((ps_dec->i4_header_decoded & 1) && (ps_dec->u2_disp_height != i4_cropped_ht))
         {
             ps_dec->u1_res_changed = 1;
             return IVD_RES_CHANGED;
         }
 
-        /* Check for unsupported resolutions */
+        /* Check again for unsupported resolutions with updated values*/
         if((u2_pic_wd > H264_MAX_FRAME_WIDTH) || (u2_pic_ht > H264_MAX_FRAME_HEIGHT)
                 || (u2_pic_wd < H264_MIN_FRAME_WIDTH) || (u2_pic_ht < H264_MIN_FRAME_HEIGHT)
                 || (u2_pic_wd * (UWORD32)u2_pic_ht > H264_MAX_FRAME_SIZE))
         {
             return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
         }
 
         /* If MBAff is enabled, decoder support is limited to streams with
          * width less than half of H264_MAX_FRAME_WIDTH.
          * In case of MBAff decoder processes two rows at a time
          */
         if((u2_pic_wd << ps_seq->u1_mb_aff_flag) > H264_MAX_FRAME_WIDTH)
         {
             return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
         }
 
     }
 
-    /* Backup u4_num_reorder_frames if header is already decoded */
+    /* Backup num_reorder_frames if header is already decoded */
     if((ps_dec->i4_header_decoded & 1) &&
                     (1 == ps_seq->u1_vui_parameters_present_flag) &&
                     (1 == ps_seq->s_vui.u1_bitstream_restriction_flag))
     {
-        u4_num_reorder_frames =  ps_seq->s_vui.u4_num_reorder_frames;
+        num_reorder_frames =  (WORD32)ps_seq->s_vui.u4_num_reorder_frames;
     }
     else
     {
-        u4_num_reorder_frames = -1;
+        num_reorder_frames = -1;
     }
     if(1 == ps_seq->u1_vui_parameters_present_flag)
     {
         ret = ih264d_parse_vui_parametres(&ps_seq->s_vui, ps_bitstrm);
         if(ret != OK)
             return ret;
     }
 
-    /* Compare older u4_num_reorder_frames with the new one if header is already decoded */
+    /* Compare older num_reorder_frames with the new one if header is already decoded */
     if((ps_dec->i4_header_decoded & 1) &&
-                    (-1 != (WORD32)u4_num_reorder_frames) &&
+                    (-1 != num_reorder_frames) &&
                     (1 == ps_seq->u1_vui_parameters_present_flag) &&
                     (1 == ps_seq->s_vui.u1_bitstream_restriction_flag) &&
-                    (ps_seq->s_vui.u4_num_reorder_frames != u4_num_reorder_frames))
+                    ((WORD32)ps_seq->s_vui.u4_num_reorder_frames != num_reorder_frames))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
 
     /* In case bitstream read has exceeded the filled size, then
      return an error */
     if (ps_bitstrm->u4_ofst > ps_bitstrm->u4_max_ofst)
     {
         return ERROR_INV_SPS_PPS_T;
     }
 
     /*--------------------------------------------------------------------*/
     /* All initializations to ps_dec are beyond this point                */
     /*--------------------------------------------------------------------*/
     ps_dec->u2_disp_height = i4_cropped_ht;
     ps_dec->u2_disp_width = i4_cropped_wd;
 
     ps_dec->u2_pic_wd = u2_pic_wd;
     ps_dec->u2_pic_ht = u2_pic_ht;
 
     /* Determining the Width and Height of Frame from that of Picture */
     ps_dec->u2_frm_wd_y = u2_frm_wd_y;
     ps_dec->u2_frm_ht_y = u2_frm_ht_y;
 
     ps_dec->u2_frm_wd_uv = u2_frm_wd_uv;
     ps_dec->u2_frm_ht_uv = u2_frm_ht_uv;
     ps_dec->s_pad_mgr.u1_pad_len_y_v = (UWORD8)(PAD_LEN_Y_V << (1 - u1_frm));
     ps_dec->s_pad_mgr.u1_pad_len_cr_v = (UWORD8)(PAD_LEN_UV_V << (1 - u1_frm));
 
     ps_dec->u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs;
     ps_dec->u2_frm_ht_in_mbs = ps_seq->u2_frm_ht_in_mbs;
 
     ps_dec->u2_crop_offset_y = u2_crop_offset_y;
     ps_dec->u2_crop_offset_uv = u2_crop_offset_uv;
 
     ps_seq->u1_is_valid = TRUE;
     ps_dec->ps_sps[u1_seq_parameter_set_id] = *ps_seq;
     ps_dec->ps_cur_sps = &ps_dec->ps_sps[u1_seq_parameter_set_id];
 
     return OK;
 }
 
 /*!
  **************************************************************************
  * \if Function name : ih264d_parse_end_of_sequence \endif
  *
  * \brief
  *    Decodes End of Sequence.
  *
  * \param ps_bitstrm   : Pointer to bit ps_bitstrm containing the NAL unit
  *
  * \return
  *    0 on Success and error code otherwise
  **************************************************************************
  */
diff --git a/decoder/ih264d_parse_slice.c b/decoder/ih264d_parse_slice.c
index b477c10..8d50f9a 100644
--- a/decoder/ih264d_parse_slice.c
+++ b/decoder/ih264d_parse_slice.c
@@ -162,594 +162,597 @@ void ih264d_form_pred_weight_matrix(dec_struct_t *ps_dec)
 WORD32 ih264d_start_of_pic(dec_struct_t *ps_dec,
                          WORD32 i4_poc,
                          pocstruct_t *ps_temp_poc,
                          UWORD16 u2_frame_num,
                          dec_pic_params_t *ps_pps)
 {
     pocstruct_t *ps_prev_poc = &ps_dec->s_cur_pic_poc;
     pocstruct_t *ps_cur_poc = ps_temp_poc;
 
     pic_buffer_t *pic_buf;
 
     ivd_video_decode_op_t * ps_dec_output =
                     (ivd_video_decode_op_t *)ps_dec->pv_dec_out;
     dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice;
     dec_seq_params_t *ps_seq = ps_pps->ps_sps;
     UWORD8 u1_bottom_field_flag = ps_cur_slice->u1_bottom_field_flag;
     UWORD8 u1_field_pic_flag = ps_cur_slice->u1_field_pic_flag;
     /* high profile related declarations */
     high_profile_tools_t s_high_profile;
     WORD32 ret;
 
     H264_MUTEX_LOCK(&ps_dec->process_disp_mutex);
 
     /* check output buffer size given by the application */
     if(check_app_out_buf_size(ps_dec) != IV_SUCCESS)
         return IVD_DISP_FRM_ZERO_OP_BUF_SIZE;
 
     ps_prev_poc->i4_pic_order_cnt_lsb = ps_cur_poc->i4_pic_order_cnt_lsb;
     ps_prev_poc->i4_pic_order_cnt_msb = ps_cur_poc->i4_pic_order_cnt_msb;
     ps_prev_poc->i4_delta_pic_order_cnt_bottom =
                     ps_cur_poc->i4_delta_pic_order_cnt_bottom;
     ps_prev_poc->i4_delta_pic_order_cnt[0] =
                     ps_cur_poc->i4_delta_pic_order_cnt[0];
     ps_prev_poc->i4_delta_pic_order_cnt[1] =
                     ps_cur_poc->i4_delta_pic_order_cnt[1];
     ps_prev_poc->u1_bot_field = ps_dec->ps_cur_slice->u1_bottom_field_flag;
     ps_prev_poc->i4_prev_frame_num_ofst = ps_cur_poc->i4_prev_frame_num_ofst;
     ps_prev_poc->u2_frame_num = u2_frame_num;
     ps_dec->i1_prev_mb_qp_delta = 0;
     ps_dec->i1_next_ctxt_idx = 0;
 
 
     ps_dec->u4_nmb_deblk = 0;
     if(ps_dec->u4_num_cores == 1)
        ps_dec->u4_nmb_deblk = 1;
 
 
 
     if(ps_seq->u1_mb_aff_flag == 1)
     {
         ps_dec->u4_nmb_deblk = 0;
         if(ps_dec->u4_num_cores > 2)
             ps_dec->u4_num_cores = 2;
     }
 
         ps_dec->u4_use_intrapred_line_copy = 0;
 
 
 
     if (ps_seq->u1_mb_aff_flag == 0)
     {
         ps_dec->u4_use_intrapred_line_copy = 1;
     }
 
     ps_dec->u4_app_disable_deblk_frm = 0;
     /* If degrade is enabled, set the degrade flags appropriately */
     if(ps_dec->i4_degrade_type && ps_dec->i4_degrade_pics)
     {
         WORD32 degrade_pic;
         ps_dec->i4_degrade_pic_cnt++;
         degrade_pic = 0;
 
         /* If degrade is to be done in all frames, then do not check further */
         switch(ps_dec->i4_degrade_pics)
         {
             case 4:
             {
                 degrade_pic = 1;
                 break;
             }
             case 3:
             {
                 if(ps_cur_slice->u1_slice_type != I_SLICE)
                     degrade_pic = 1;
 
                 break;
             }
             case 2:
             {
 
                 /* If pic count hits non-degrade interval or it is an islice, then do not degrade */
                 if((ps_cur_slice->u1_slice_type != I_SLICE)
                                 && (ps_dec->i4_degrade_pic_cnt
                                                 != ps_dec->i4_nondegrade_interval))
                     degrade_pic = 1;
 
                 break;
             }
             case 1:
             {
                 /* Check if the current picture is non-ref */
                 if(0 == ps_cur_slice->u1_nal_ref_idc)
                 {
                     degrade_pic = 1;
                 }
                 break;
             }
 
         }
         if(degrade_pic)
         {
             if(ps_dec->i4_degrade_type & 0x2)
                 ps_dec->u4_app_disable_deblk_frm = 1;
 
             /* MC degrading is done only for non-ref pictures */
             if(0 == ps_cur_slice->u1_nal_ref_idc)
             {
                 if(ps_dec->i4_degrade_type & 0x4)
                     ps_dec->i4_mv_frac_mask = 0;
 
                 if(ps_dec->i4_degrade_type & 0x8)
                     ps_dec->i4_mv_frac_mask = 0;
             }
         }
         else
             ps_dec->i4_degrade_pic_cnt = 0;
     }
 
     {
         dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;
         if((ps_cur_slice->u1_slice_type == I_SLICE)
                         || (ps_cur_slice->u1_slice_type == SI_SLICE))
             ps_err->u1_cur_pic_type = PIC_TYPE_I;
         else
             ps_err->u1_cur_pic_type = PIC_TYPE_UNKNOWN;
 
         if(ps_err->u1_pic_aud_i == PIC_TYPE_I)
         {
             ps_err->u1_cur_pic_type = PIC_TYPE_I;
             ps_err->u1_pic_aud_i = PIC_TYPE_UNKNOWN;
         }
 
         if(ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)
         {
             if(ps_err->u1_err_flag)
                 ih264d_reset_ref_bufs(ps_dec->ps_dpb_mgr);
             ps_err->u1_err_flag = ACCEPT_ALL_PICS;
         }
     }
 
     if(ps_dec->u1_init_dec_flag && ps_dec->s_prev_seq_params.u1_eoseq_pending)
     {
         /* Reset the decoder picture buffers */
         WORD32 j;
         for(j = 0; j < MAX_DISP_BUFS_NEW; j++)
         {
 
             ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                                   j,
                                   BUF_MGR_REF);
             ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,
                                   ps_dec->au1_pic_buf_id_mv_buf_id_map[j],
                                   BUF_MGR_REF);
             ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                                   j,
                                   BUF_MGR_IO);
         }
 
         /* reset the decoder structure parameters related to buffer handling */
         ps_dec->u1_second_field = 0;
         ps_dec->i4_cur_display_seq = 0;
 
         /********************************************************************/
         /* indicate in the decoder output i4_status that some frames are being */
         /* dropped, so that it resets timestamp and wait for a new sequence */
         /********************************************************************/
 
         ps_dec->s_prev_seq_params.u1_eoseq_pending = 0;
     }
     ret = ih264d_init_pic(ps_dec, u2_frame_num, i4_poc, ps_pps);
     if(ret != OK)
         return ret;
 
     ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_pic_tu_coeff_data;
     ps_dec->pv_proc_tu_coeff_data  = ps_dec->pv_pic_tu_coeff_data;
     ps_dec->ps_nmb_info = ps_dec->ps_frm_mb_info;
     if(ps_dec->u1_separate_parse)
     {
         UWORD16 pic_wd;
         UWORD16 pic_ht;
         UWORD32 num_mbs;
 
         pic_wd = ps_dec->u2_pic_wd;
         pic_ht = ps_dec->u2_pic_ht;
         num_mbs = (pic_wd * pic_ht) >> 8;
 
         if(ps_dec->pu1_dec_mb_map)
         {
             memset((void *)ps_dec->pu1_dec_mb_map, 0, num_mbs);
         }
 
         if(ps_dec->pu1_recon_mb_map)
         {
 
             memset((void *)ps_dec->pu1_recon_mb_map, 0, num_mbs);
         }
 
         if(ps_dec->pu2_slice_num_map)
         {
             memset((void *)ps_dec->pu2_slice_num_map, 0,
                    (num_mbs * sizeof(UWORD16)));
         }
 
     }
 
     ps_dec->ps_parse_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);
     ps_dec->ps_decode_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);
     ps_dec->ps_computebs_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);
     ps_dec->u2_cur_slice_num = 0;
 
     /* Initialize all the HP toolsets to zero */
     ps_dec->s_high_profile.u1_scaling_present = 0;
     ps_dec->s_high_profile.u1_transform8x8_present = 0;
 
     /* Get Next Free Picture */
     if(1 == ps_dec->u4_share_disp_buf)
     {
         UWORD32 i;
         /* Free any buffer that is in the queue to be freed */
         for(i = 0; i < MAX_DISP_BUFS_NEW; i++)
         {
             if(0 == ps_dec->u4_disp_buf_to_be_freed[i])
                 continue;
             ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr, i,
             BUF_MGR_IO);
             ps_dec->u4_disp_buf_to_be_freed[i] = 0;
             ps_dec->u4_disp_buf_mapping[i] = 0;
 
         }
     }
     if(!(u1_field_pic_flag && 0 != ps_dec->u1_top_bottom_decoded)) //ps_dec->u1_second_field))
     {
         pic_buffer_t *ps_cur_pic;
         WORD32 cur_pic_buf_id, cur_mv_buf_id;
         col_mv_buf_t *ps_col_mv;
         while(1)
         {
             ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free(
                             (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                             &cur_pic_buf_id);
             if(ps_cur_pic == NULL)
             {
                 ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T;
                 return ERROR_UNAVAIL_PICBUF_T;
             }
             if(0 == ps_dec->u4_disp_buf_mapping[cur_pic_buf_id])
             {
                 break;
             }
 
         }
         ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,
                                                                &cur_mv_buf_id);
         if(ps_col_mv == NULL)
         {
             ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T;
             return ERROR_UNAVAIL_MVBUF_T;
         }
 
         ps_dec->ps_cur_pic = ps_cur_pic;
         ps_dec->u1_pic_buf_id = cur_pic_buf_id;
         ps_cur_pic->u4_ts = ps_dec->u4_ts;
 
 
         ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id;
         ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id;
 
         ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag;
         ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv;
         ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0;
 
         {
             /*make first entry of list0 and list1 point to cur pic,
              *so that if first slice is in error, ref pic struct will have valid entries*/
             ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_init_dpb[0];
             ps_dec->ps_ref_pic_buf_lx[1] = ps_dec->ps_dpb_mgr->ps_init_dpb[1];
             *(ps_dec->ps_dpb_mgr->ps_init_dpb[0][0]) = *ps_cur_pic;
             /* Initialize for field reference as well */
             *(ps_dec->ps_dpb_mgr->ps_init_dpb[0][MAX_REF_BUFS]) = *ps_cur_pic;
 
             *(ps_dec->ps_dpb_mgr->ps_mod_dpb[0][0]) = *ps_cur_pic;
             /* Initialize for field reference as well */
             *(ps_dec->ps_dpb_mgr->ps_mod_dpb[0][MAX_REF_BUFS]) = *ps_cur_pic;
             *(ps_dec->ps_dpb_mgr->ps_init_dpb[1][0]) = *ps_cur_pic;
             /* Initialize for field reference as well */
             *(ps_dec->ps_dpb_mgr->ps_init_dpb[1][MAX_REF_BUFS]) = *ps_cur_pic;
             *(ps_dec->ps_dpb_mgr->ps_mod_dpb[1][0]) = *ps_cur_pic;
             /* Initialize for field reference as well */
             *(ps_dec->ps_dpb_mgr->ps_mod_dpb[1][MAX_REF_BUFS]) = *ps_cur_pic;
         }
 
         if(!ps_dec->ps_cur_pic)
         {
             WORD32 j;
             H264_DEC_DEBUG_PRINT("------- Display Buffers Reset --------\n");
             for(j = 0; j < MAX_DISP_BUFS_NEW; j++)
             {
 
                 ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                                       j,
                                       BUF_MGR_REF);
                 ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,
                                       ps_dec->au1_pic_buf_id_mv_buf_id_map[j],
                                       BUF_MGR_REF);
                 ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                                       j,
                                       BUF_MGR_IO);
             }
 
             ps_dec->i4_cur_display_seq = 0;
             ps_dec->i4_prev_max_display_seq = 0;
             ps_dec->i4_max_poc = 0;
 
             ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free(
                             (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                             &cur_pic_buf_id);
             if(ps_cur_pic == NULL)
             {
                 ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T;
                 return ERROR_UNAVAIL_PICBUF_T;
             }
 
             ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,
                                                                    &cur_mv_buf_id);
             if(ps_col_mv == NULL)
             {
                 ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T;
                 return ERROR_UNAVAIL_MVBUF_T;
             }
 
             ps_dec->ps_cur_pic = ps_cur_pic;
             ps_dec->u1_pic_buf_id = cur_pic_buf_id;
             ps_cur_pic->u4_ts = ps_dec->u4_ts;
             ps_dec->apv_buf_id_pic_buf_map[cur_pic_buf_id] = (void *)ps_cur_pic;
 
             ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id;
             ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id;
 
             ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag;
             ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv;
             ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0;
 
         }
 
         ps_dec->ps_cur_pic->u1_picturetype = u1_field_pic_flag;
         ps_dec->ps_cur_pic->u4_pack_slc_typ = SKIP_NONE;
         H264_DEC_DEBUG_PRINT("got a buffer\n");
     }
     else
     {
         H264_DEC_DEBUG_PRINT("did not get a buffer\n");
     }
 
     ps_dec->u4_pic_buf_got = 1;
 
     ps_dec->ps_cur_pic->i4_poc = i4_poc;
     ps_dec->ps_cur_pic->i4_frame_num = u2_frame_num;
     ps_dec->ps_cur_pic->i4_pic_num = u2_frame_num;
     ps_dec->ps_cur_pic->i4_top_field_order_cnt = ps_pps->i4_top_field_order_cnt;
     ps_dec->ps_cur_pic->i4_bottom_field_order_cnt =
                     ps_pps->i4_bottom_field_order_cnt;
     ps_dec->ps_cur_pic->i4_avg_poc = ps_pps->i4_avg_poc;
     ps_dec->ps_cur_pic->u4_time_stamp = ps_dec->u4_pts;
 
     ps_dec->s_cur_pic = *(ps_dec->ps_cur_pic);
     if(u1_field_pic_flag && u1_bottom_field_flag)
     {
         WORD32 i4_temp_poc;
         WORD32 i4_top_field_order_poc, i4_bot_field_order_poc;
         /* Point to odd lines, since it's bottom field */
         ps_dec->s_cur_pic.pu1_buf1 += ps_dec->s_cur_pic.u2_frm_wd_y;
         ps_dec->s_cur_pic.pu1_buf2 += ps_dec->s_cur_pic.u2_frm_wd_uv;
         ps_dec->s_cur_pic.pu1_buf3 += ps_dec->s_cur_pic.u2_frm_wd_uv;
         ps_dec->s_cur_pic.ps_mv +=
                         ((ps_dec->u2_pic_ht * ps_dec->u2_pic_wd) >> 5);
         ps_dec->s_cur_pic.pu1_col_zero_flag += ((ps_dec->u2_pic_ht
                         * ps_dec->u2_pic_wd) >> 5);
         ps_dec->ps_cur_pic->u1_picturetype |= BOT_FLD;
         i4_top_field_order_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;
         i4_bot_field_order_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;
         i4_temp_poc = MIN(i4_top_field_order_poc,
                                  i4_bot_field_order_poc);
         ps_dec->ps_cur_pic->i4_avg_poc = i4_temp_poc;
     }
 
     ps_cur_slice->u1_mbaff_frame_flag = ps_seq->u1_mb_aff_flag
                     && (!u1_field_pic_flag);
 
     ps_dec->ps_cur_pic->u1_picturetype |= (ps_cur_slice->u1_mbaff_frame_flag
                     << 2);
 
     ps_dec->ps_cur_mb_row = ps_dec->ps_nbr_mb_row; //[0];
     //Increment by 2 ,so that left mb (mbaff decrements by 2)  will always be valid
     ps_dec->ps_cur_mb_row += 2;
     ps_dec->ps_top_mb_row = ps_dec->ps_nbr_mb_row;
     ps_dec->ps_top_mb_row += ((ps_dec->u2_frm_wd_in_mbs + 2) << (1 - ps_dec->ps_cur_sps->u1_frame_mbs_only_flag));
     //Increment by 2 ,so that left mb (mbaff decrements by 2)  will always be valid
     ps_dec->ps_top_mb_row += 2;
 
     /* CHANGED CODE */
     ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv;
     ps_dec->ps_mv_top = ps_dec->ps_mv_top_p[0];
     /* CHANGED CODE */
     ps_dec->u1_mv_top_p = 0;
     ps_dec->u1_mb_idx = 0;
     /* CHANGED CODE */
     ps_dec->ps_mv_left = ps_dec->s_cur_pic.ps_mv;
     ps_dec->u2_total_mbs_coded = 0;
     ps_dec->i4_submb_ofst = -(SUB_BLK_SIZE);
     ps_dec->u4_pred_info_idx = 0;
     ps_dec->u4_pred_info_pkd_idx = 0;
     ps_dec->u4_dma_buf_idx = 0;
     ps_dec->ps_mv = ps_dec->s_cur_pic.ps_mv;
     ps_dec->ps_mv_bank_cur = ps_dec->s_cur_pic.ps_mv;
     ps_dec->pu1_col_zero_flag = ps_dec->s_cur_pic.pu1_col_zero_flag;
     ps_dec->ps_part = ps_dec->ps_parse_part_params;
     ps_dec->i2_prev_slice_mbx = -1;
     ps_dec->i2_prev_slice_mby = 0;
     ps_dec->u2_mv_2mb[0] = 0;
     ps_dec->u2_mv_2mb[1] = 0;
     ps_dec->u1_last_pic_not_decoded = 0;
 
     ps_dec->u2_cur_slice_num_dec_thread = 0;
     ps_dec->u2_cur_slice_num_bs = 0;
     ps_dec->u4_intra_pred_line_ofst = 0;
     ps_dec->pu1_cur_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line;
     ps_dec->pu1_cur_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line;
     ps_dec->pu1_cur_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line;
 
     ps_dec->pu1_cur_y_intra_pred_line_base = ps_dec->pu1_y_intra_pred_line;
     ps_dec->pu1_cur_u_intra_pred_line_base = ps_dec->pu1_u_intra_pred_line;
     ps_dec->pu1_cur_v_intra_pred_line_base = ps_dec->pu1_v_intra_pred_line;
 
 
 
 
 
     ps_dec->pu1_prev_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line
                     + (ps_dec->u2_frm_wd_in_mbs * MB_SIZE);
 
     ps_dec->pu1_prev_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line
                     + ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE * YUV420SP_FACTOR;
     ps_dec->pu1_prev_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line
                     + ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE;
 
     ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic;
     /* Initialize The Function Pointer Depending Upon the Entropy and MbAff Flag */
     {
         if(ps_cur_slice->u1_mbaff_frame_flag)
         {
             ps_dec->pf_compute_bs = ih264d_compute_bs_mbaff;
             ps_dec->pf_mvpred = ih264d_mvpred_mbaff;
         }
         else
         {
             ps_dec->pf_compute_bs = ih264d_compute_bs_non_mbaff;
             ps_dec->u1_cur_mb_fld_dec_flag = ps_cur_slice->u1_field_pic_flag;
         }
     }
     /* Set up the Parameter for DMA transfer */
     {
         UWORD8 u1_field_pic_flag = ps_dec->ps_cur_slice->u1_field_pic_flag;
 
         UWORD8 u1_mbaff = ps_cur_slice->u1_mbaff_frame_flag;
 
         UWORD8 uc_lastmbs = (((ps_dec->u2_pic_wd) >> 4)
                         % (ps_dec->u1_recon_mb_grp >> u1_mbaff));
         UWORD16 ui16_lastmbs_widthY =
                         (uc_lastmbs ? (uc_lastmbs << 4) : ((ps_dec->u1_recon_mb_grp
                                         >> u1_mbaff) << 4));
         UWORD16 ui16_lastmbs_widthUV =
                         uc_lastmbs ? (uc_lastmbs << 3) : ((ps_dec->u1_recon_mb_grp
                                         >> u1_mbaff) << 3);
 
         ps_dec->s_tran_addrecon.pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1;
         ps_dec->s_tran_addrecon.pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2;
         ps_dec->s_tran_addrecon.pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3;
 
         ps_dec->s_tran_addrecon.u2_frm_wd_y = ps_dec->u2_frm_wd_y
                         << u1_field_pic_flag;
         ps_dec->s_tran_addrecon.u2_frm_wd_uv = ps_dec->u2_frm_wd_uv
                         << u1_field_pic_flag;
 
         if(u1_field_pic_flag)
         {
             ui16_lastmbs_widthY += ps_dec->u2_frm_wd_y;
             ui16_lastmbs_widthUV += ps_dec->u2_frm_wd_uv;
         }
 
         /* Normal Increment of Pointer */
         ps_dec->s_tran_addrecon.u4_inc_y[0] = ((ps_dec->u1_recon_mb_grp << 4)
                         >> u1_mbaff);
         ps_dec->s_tran_addrecon.u4_inc_uv[0] = ((ps_dec->u1_recon_mb_grp << 4)
                         >> u1_mbaff);
 
         /* End of Row Increment */
         ps_dec->s_tran_addrecon.u4_inc_y[1] = (ui16_lastmbs_widthY
                         + (PAD_LEN_Y_H << 1)
                         + ps_dec->s_tran_addrecon.u2_frm_wd_y
                                         * ((15 << u1_mbaff) + u1_mbaff));
         ps_dec->s_tran_addrecon.u4_inc_uv[1] = (ui16_lastmbs_widthUV
                         + (PAD_LEN_UV_H << 2)
                         + ps_dec->s_tran_addrecon.u2_frm_wd_uv
                                         * ((15 << u1_mbaff) + u1_mbaff));
 
         /* Assign picture numbers to each frame/field  */
         /* only once per picture.                      */
         ih264d_assign_pic_num(ps_dec);
         ps_dec->s_tran_addrecon.u2_mv_top_left_inc = (ps_dec->u1_recon_mb_grp
                         << 2) - 1 - (u1_mbaff << 2);
         ps_dec->s_tran_addrecon.u2_mv_left_inc = ((ps_dec->u1_recon_mb_grp
                         >> u1_mbaff) - 1) << (4 + u1_mbaff);
     }
     /**********************************************************************/
     /* High profile related initialization at pictrue level               */
     /**********************************************************************/
     if(ps_seq->u1_profile_idc == HIGH_PROFILE_IDC)
     {
         if((ps_seq->i4_seq_scaling_matrix_present_flag)
                         || (ps_pps->i4_pic_scaling_matrix_present_flag))
         {
-            ih264d_form_scaling_matrix_picture(ps_seq, ps_pps, ps_dec);
+            ret = ih264d_form_scaling_matrix_picture(ps_seq, ps_pps, ps_dec);
             ps_dec->s_high_profile.u1_scaling_present = 1;
         }
         else
         {
-            ih264d_form_default_scaling_matrix(ps_dec);
+            ret = ih264d_form_default_scaling_matrix(ps_dec);
         }
 
         if(ps_pps->i4_transform_8x8_mode_flag)
         {
             ps_dec->s_high_profile.u1_transform8x8_present = 1;
         }
     }
     else
     {
-        ih264d_form_default_scaling_matrix(ps_dec);
+        ret = ih264d_form_default_scaling_matrix(ps_dec);
     }
-
+    
+    if(ret != OK)
+        return ret;
+ 
     /* required while reading the transform_size_8x8 u4_flag */
     ps_dec->s_high_profile.u1_direct_8x8_inference_flag =
                     ps_seq->u1_direct_8x8_inference_flag;
     ps_dec->s_high_profile.s_cavlc_ctxt = ps_dec->s_cavlc_ctxt;
 
     ps_dec->i1_recon_in_thread3_flag = 1;
     ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_addrecon;
     if(ps_dec->u1_separate_parse)
     {
         memcpy(&ps_dec->s_tran_addrecon_parse, &ps_dec->s_tran_addrecon,
                sizeof(tfr_ctxt_t));
         if(ps_dec->u4_num_cores >= 3 && ps_dec->i1_recon_in_thread3_flag)
         {
             memcpy(&ps_dec->s_tran_iprecon, &ps_dec->s_tran_addrecon,
                    sizeof(tfr_ctxt_t));
             ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_iprecon;
         }
     }
 
 
     ih264d_init_deblk_tfr_ctxt(ps_dec,&(ps_dec->s_pad_mgr), &(ps_dec->s_tran_addrecon),
                                ps_dec->u2_frm_wd_in_mbs, 0);
 
     ps_dec->ps_cur_deblk_mb = ps_dec->ps_deblk_pic;
     ps_dec->u4_cur_deblk_mb_num = 0;
 
     ps_dec->u4_deblk_mb_x = 0;
     ps_dec->u4_deblk_mb_y = 0;
     ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;
 
     ps_dec->u4_first_slice_in_pic = 0;
     H264_MUTEX_UNLOCK(&ps_dec->process_disp_mutex);
     return OK;
 }
 
 /*!
  **************************************************************************
  * \if Function name :  ih264d_deblock_display \endif
  *
  * \brief            :  The function callls the deblocking routine and manages
  :  the Recon buffers and displays .
  * \return           :  Nothing
  *
  **************************************************************************
  */
@@ -1057,906 +1060,854 @@ WORD32 ih264d_fix_error_in_dpb(dec_struct_t *ps_dec)
 WORD32 ih264d_parse_decode_slice(UWORD8 u1_is_idr_slice,
                                  UWORD8 u1_nal_ref_idc,
                                  dec_struct_t *ps_dec /* Decoder parameters */
                                  )
 {
     dec_bit_stream_t * ps_bitstrm = ps_dec->ps_bitstrm;
     dec_pic_params_t *ps_pps;
     dec_seq_params_t *ps_seq;
     dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice;
-    pocstruct_t s_tmp_poc;
+    pocstruct_t s_tmp_poc = {0};
     WORD32 i_delta_poc[2];
     WORD32 i4_poc = 0;
     UWORD16 u2_first_mb_in_slice, u2_frame_num;
     UWORD8 u1_field_pic_flag, u1_redundant_pic_cnt = 0, u1_slice_type;
     UWORD32 u4_idr_pic_id = 0;
     UWORD8 u1_bottom_field_flag, u1_pic_order_cnt_type;
 
     UWORD8 u1_nal_unit_type;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
     WORD8 i1_is_end_of_poc;
 
     WORD32 ret, end_of_frame;
     WORD32 prev_slice_err, num_mb_skipped;
     UWORD8 u1_mbaff;
     pocstruct_t *ps_cur_poc;
 
     UWORD32 u4_temp;
     WORD32 i_temp;
     UWORD32 u4_call_end_of_pic = 0;
 
     /* read FirstMbInSlice  and slice type*/
     ps_dec->ps_dpb_cmds->u1_dpb_commands_read_slc = 0;
     u2_first_mb_in_slice = ih264d_uev(pu4_bitstrm_ofst,
                                      pu4_bitstrm_buf);
     if(u2_first_mb_in_slice
                     > (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs))
     {
 
         return ERROR_CORRUPTED_SLICE;
     }
 
     /*we currently don not support ASO*/
     if(((u2_first_mb_in_slice << ps_cur_slice->u1_mbaff_frame_flag)
                     <= ps_dec->u2_cur_mb_addr) && (ps_dec->u4_first_slice_in_pic == 0))
     {
         return ERROR_CORRUPTED_SLICE;
     }
 
     COPYTHECONTEXT("SH: first_mb_in_slice",u2_first_mb_in_slice);
 
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
     if(u4_temp > 9)
         return ERROR_INV_SLC_TYPE_T;
 
     u1_slice_type = u4_temp;
     COPYTHECONTEXT("SH: slice_type",(u1_slice_type));
     /* Find Out the Slice Type is 5 to 9 or not then Set the Flag   */
     /* u1_sl_typ_5_9 = 1 .Which tells that all the slices in the Pic*/
     /* will be of same type of current                            */
     if(u1_slice_type > 4)
     {
         u1_slice_type -= 5;
     }
 
-    {
-        UWORD32 skip;
-
-        if((ps_dec->i4_app_skip_mode == IVD_SKIP_PB)
-                        || (ps_dec->i4_dec_skip_mode == IVD_SKIP_PB))
-        {
-            UWORD32 u4_bit_stream_offset = 0;
-
-            if(ps_dec->u1_nal_unit_type == IDR_SLICE_NAL)
-            {
-                skip = 0;
-
-                ps_dec->i4_dec_skip_mode = IVD_SKIP_NONE;
-            }
-            else if((I_SLICE == u1_slice_type)
-                            && (1 >= ps_dec->ps_cur_sps->u1_num_ref_frames))
-            {
-                skip = 0;
-
-                ps_dec->i4_dec_skip_mode = IVD_SKIP_NONE;
-            }
-            else
-            {
-                skip = 1;
-            }
-
-            /* If one frame worth of data is already skipped, do not skip the next one */
-            if((0 == u2_first_mb_in_slice) && (1 == ps_dec->u4_prev_nal_skipped))
-            {
-                skip = 0;
-            }
-
-            if(skip)
-            {
-                ps_dec->u4_prev_nal_skipped = 1;
-                ps_dec->i4_dec_skip_mode = IVD_SKIP_PB;
-                return 0;
-            }
-            else
-            {
-                /* If the previous NAL was skipped, then
-                 do not process that buffer in this call.
-                 Return to app and process it in the next call.
-                 This is necessary to handle cases where I/IDR is not complete in
-                 the current buffer and application intends to fill the remaining part of the bitstream
-                 later. This ensures we process only frame worth of data in every call */
-                if(1 == ps_dec->u4_prev_nal_skipped)
-                {
-                    ps_dec->u4_return_to_app = 1;
-                    return 0;
-                }
-            }
-        }
-
-    }
-
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u4_temp & MASK_ERR_PIC_SET_ID)
         return ERROR_INV_SLICE_HDR_T;
     /* discard slice if pic param is invalid */
     COPYTHECONTEXT("SH: pic_parameter_set_id", u4_temp);
     ps_pps = &ps_dec->ps_pps[u4_temp];
     if(FALSE == ps_pps->u1_is_valid)
     {
         return ERROR_INV_SLICE_HDR_T;
     }
     ps_seq = ps_pps->ps_sps;
     if(!ps_seq)
         return ERROR_INV_SLICE_HDR_T;
     if(FALSE == ps_seq->u1_is_valid)
         return ERROR_INV_SLICE_HDR_T;
 
     /* Get the frame num */
     u2_frame_num = ih264d_get_bits_h264(ps_bitstrm,
                                          ps_seq->u1_bits_in_frm_num);
 //    H264_DEC_DEBUG_PRINT("FRAME %d First MB in slice: %d\n", u2_frame_num, u2_first_mb_in_slice);
 
     COPYTHECONTEXT("SH: frame_num", u2_frame_num);
 //    H264_DEC_DEBUG_PRINT("Second field: %d frame num: %d prv_frame_num: %d \n", ps_dec->u1_second_field, u2_frame_num, ps_dec->u2_prv_frame_num);
     if(!ps_dec->u1_first_slice_in_stream && ps_dec->u4_first_slice_in_pic)
     {
         pocstruct_t *ps_prev_poc = &ps_dec->s_prev_pic_poc;
         pocstruct_t *ps_cur_poc = &ps_dec->s_cur_pic_poc;
 
         ps_dec->u2_mbx = 0xffff;
         ps_dec->u2_mby = 0;
 
         if((0 == u1_is_idr_slice) && ps_cur_slice->u1_nal_ref_idc)
             ps_dec->u2_prev_ref_frame_num = ps_cur_slice->u2_frame_num;
 
         if(u1_is_idr_slice || ps_cur_slice->u1_mmco_equalto5)
             ps_dec->u2_prev_ref_frame_num = 0;
 
         if(ps_dec->ps_cur_sps->u1_gaps_in_frame_num_value_allowed_flag)
         {
             ih264d_decode_gaps_in_frame_num(ps_dec, u2_frame_num);
         }
 
         ps_prev_poc->i4_prev_frame_num_ofst = ps_cur_poc->i4_prev_frame_num_ofst;
         ps_prev_poc->u2_frame_num = ps_cur_poc->u2_frame_num;
         ps_prev_poc->u1_mmco_equalto5 = ps_cur_slice->u1_mmco_equalto5;
         if(ps_cur_slice->u1_nal_ref_idc)
         {
             ps_prev_poc->i4_pic_order_cnt_lsb = ps_cur_poc->i4_pic_order_cnt_lsb;
             ps_prev_poc->i4_pic_order_cnt_msb = ps_cur_poc->i4_pic_order_cnt_msb;
             ps_prev_poc->i4_delta_pic_order_cnt_bottom =
                             ps_cur_poc->i4_delta_pic_order_cnt_bottom;
             ps_prev_poc->i4_delta_pic_order_cnt[0] =
                             ps_cur_poc->i4_delta_pic_order_cnt[0];
             ps_prev_poc->i4_delta_pic_order_cnt[1] =
                             ps_cur_poc->i4_delta_pic_order_cnt[1];
             ps_prev_poc->u1_bot_field = ps_cur_poc->u1_bot_field;
         }
 
         ps_dec->u2_total_mbs_coded = 0;
     }
     /* Get the field related flags  */
     if(!ps_seq->u1_frame_mbs_only_flag)
     {
 
         u1_field_pic_flag = ih264d_get_bit_h264(ps_bitstrm);
         COPYTHECONTEXT("SH: field_pic_flag", u1_field_pic_flag);
         u1_bottom_field_flag = 0;
 
         if(u1_field_pic_flag)
         {
             ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan_fld;
             u1_bottom_field_flag = ih264d_get_bit_h264(ps_bitstrm);
             COPYTHECONTEXT("SH: bottom_field_flag", u1_bottom_field_flag);
 
         }
         else
         {
             ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan;
         }
     }
     else
     {
         u1_field_pic_flag = 0;
         u1_bottom_field_flag = 0;
 
         ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan;
     }
 
     u1_nal_unit_type = SLICE_NAL;
     if(u1_is_idr_slice)
     {
         u1_nal_unit_type = IDR_SLICE_NAL;
         u4_idr_pic_id = ih264d_uev(pu4_bitstrm_ofst,
                                    pu4_bitstrm_buf);
         if(u4_idr_pic_id > 65535)
             return ERROR_INV_SLICE_HDR_T;
         COPYTHECONTEXT("SH:  ", u4_idr_pic_id);
     }
 
     /* read delta pic order count information*/
     i_delta_poc[0] = i_delta_poc[1] = 0;
     s_tmp_poc.i4_pic_order_cnt_lsb = 0;
     s_tmp_poc.i4_delta_pic_order_cnt_bottom = 0;
     u1_pic_order_cnt_type = ps_seq->u1_pic_order_cnt_type;
     if(u1_pic_order_cnt_type == 0)
     {
         i_temp = ih264d_get_bits_h264(
                         ps_bitstrm,
                         ps_seq->u1_log2_max_pic_order_cnt_lsb_minus);
         if(i_temp < 0 || i_temp >= ps_seq->i4_max_pic_order_cntLsb)
             return ERROR_INV_SLICE_HDR_T;
         s_tmp_poc.i4_pic_order_cnt_lsb = i_temp;
         COPYTHECONTEXT("SH: pic_order_cnt_lsb", s_tmp_poc.i4_pic_order_cnt_lsb);
 
         if((ps_pps->u1_pic_order_present_flag == 1) && (!u1_field_pic_flag))
         {
             s_tmp_poc.i4_delta_pic_order_cnt_bottom = ih264d_sev(
                             pu4_bitstrm_ofst, pu4_bitstrm_buf);
             //if(s_tmp_poc.i4_delta_pic_order_cnt_bottom > ps_seq->i4_max_pic_order_cntLsb)
             COPYTHECONTEXT("SH: delta_pic_order_cnt_bottom",
                             s_tmp_poc.i4_delta_pic_order_cnt_bottom);
         }
     }
 
     s_tmp_poc.i4_delta_pic_order_cnt[0] = 0;
     s_tmp_poc.i4_delta_pic_order_cnt[1] = 0;
     if(u1_pic_order_cnt_type == 1
                     && (!ps_seq->u1_delta_pic_order_always_zero_flag))
     {
         s_tmp_poc.i4_delta_pic_order_cnt[0] = ih264d_sev(pu4_bitstrm_ofst,
                                                          pu4_bitstrm_buf);
         COPYTHECONTEXT("SH: delta_pic_order_cnt[0]",
                         s_tmp_poc.i4_delta_pic_order_cnt[0]);
 
         if(ps_pps->u1_pic_order_present_flag && !u1_field_pic_flag)
         {
             s_tmp_poc.i4_delta_pic_order_cnt[1] = ih264d_sev(
                             pu4_bitstrm_ofst, pu4_bitstrm_buf);
             COPYTHECONTEXT("SH: delta_pic_order_cnt[1]",
                             s_tmp_poc.i4_delta_pic_order_cnt[1]);
         }
     }
 
     if(ps_pps->u1_redundant_pic_cnt_present_flag)
     {
         u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         if(u4_temp > MAX_REDUNDANT_PIC_CNT)
             return ERROR_INV_SLICE_HDR_T;
         u1_redundant_pic_cnt = u4_temp;
         COPYTHECONTEXT("SH: redundant_pic_cnt", u1_redundant_pic_cnt);
     }
 
     /*--------------------------------------------------------------------*/
     /* Check if the slice is part of new picture                          */
     /*--------------------------------------------------------------------*/
     /* First slice of a picture is always considered as part of new picture */
     i1_is_end_of_poc = 1;
     ps_dec->ps_dec_err_status->u1_err_flag &= MASK_REJECT_CUR_PIC;
 
     if(ps_dec->u4_first_slice_in_pic == 0)
     {
         i1_is_end_of_poc = ih264d_is_end_of_pic(u2_frame_num, u1_nal_ref_idc,
                                             &s_tmp_poc, &ps_dec->s_cur_pic_poc,
                                             ps_cur_slice, u1_pic_order_cnt_type,
                                             u1_nal_unit_type, u4_idr_pic_id,
                                             u1_field_pic_flag,
                                             u1_bottom_field_flag);
         if(i1_is_end_of_poc)
         {
             ps_dec->u1_first_slice_in_stream = 0;
             return ERROR_INCOMPLETE_FRAME;
         }
 
     }
 
     /*--------------------------------------------------------------------*/
     /* Check for error in slice and parse the missing/corrupted MB's      */
     /* as skip-MB's in an inserted P-slice                                */
     /*--------------------------------------------------------------------*/
     u1_mbaff = ps_seq->u1_mb_aff_flag && (!u1_field_pic_flag);
     prev_slice_err = 0;
 
     if(i1_is_end_of_poc || ps_dec->u1_first_slice_in_stream)
     {
         if(u2_frame_num != ps_dec->u2_prv_frame_num
                && ps_dec->u1_top_bottom_decoded != 0
                    && ps_dec->u1_top_bottom_decoded
                        != (TOP_FIELD_ONLY | BOT_FIELD_ONLY))
         {
             ps_dec->u1_dangling_field = 1;
             if(ps_dec->u4_first_slice_in_pic)
             {
                 // first slice - dangling field
                 prev_slice_err = 1;
             }
             else
             {
                 // last slice - dangling field
                 prev_slice_err = 2;
             }
 
             if(ps_dec->u1_top_bottom_decoded ==TOP_FIELD_ONLY)
                 ps_cur_slice->u1_bottom_field_flag = 1;
             else
                 ps_cur_slice->u1_bottom_field_flag = 0;
 
             num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
                     - ps_dec->u2_total_mbs_coded;
             ps_cur_poc = &ps_dec->s_cur_pic_poc;
 
             u1_is_idr_slice = ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL;
         }
         else if(ps_dec->u4_first_slice_in_pic)
         {
             if(u2_first_mb_in_slice > 0)
             {
                 // first slice - missing/header corruption
                 prev_slice_err = 1;
                 num_mb_skipped = u2_first_mb_in_slice << u1_mbaff;
                 ps_cur_poc = &s_tmp_poc;
 
                 // initializing slice parameters
                 ps_cur_slice->u4_idr_pic_id = u4_idr_pic_id;
                 ps_cur_slice->u1_field_pic_flag = u1_field_pic_flag;
                 ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;
                 ps_cur_slice->i4_pic_order_cnt_lsb =
                         s_tmp_poc.i4_pic_order_cnt_lsb;
                 ps_cur_slice->u1_nal_unit_type = u1_nal_unit_type;
                 ps_cur_slice->u1_redundant_pic_cnt = u1_redundant_pic_cnt;
                 ps_cur_slice->u1_nal_ref_idc = u1_nal_ref_idc;
                 ps_cur_slice->u1_pic_order_cnt_type = u1_pic_order_cnt_type;
                 ps_cur_slice->u1_mbaff_frame_flag = ps_seq->u1_mb_aff_flag
                         && (!u1_field_pic_flag);
             }
         }
         else
         {
             /* since i1_is_end_of_poc is set ,means new frame num is encountered. so conceal the current frame
              * completely */
             prev_slice_err = 2;
             num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs
                             * ps_dec->u2_frm_wd_in_mbs)
                             - ps_dec->u2_total_mbs_coded;
             ps_cur_poc = &s_tmp_poc;
         }
     }
     else
     {
         if((u2_first_mb_in_slice << u1_mbaff) > ps_dec->u2_total_mbs_coded)
         {
             // previous slice - missing/corruption
             prev_slice_err = 2;
             num_mb_skipped = (u2_first_mb_in_slice << u1_mbaff)
                     - ps_dec->u2_total_mbs_coded;
             ps_cur_poc = &s_tmp_poc;
         }
         else if((u2_first_mb_in_slice << u1_mbaff) < ps_dec->u2_total_mbs_coded)
         {
             return ERROR_CORRUPTED_SLICE;
         }
     }
 
     if(prev_slice_err)
     {
         ret = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, u1_is_idr_slice, u2_frame_num, ps_cur_poc, prev_slice_err);
 
         if(ps_dec->u1_dangling_field == 1)
         {
             ps_dec->u1_second_field = 1 - ps_dec->u1_second_field;
             ps_dec->u1_first_slice_in_stream = 0;
             ps_dec->u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY;
             return ERROR_DANGLING_FIELD_IN_PIC;
         }
 
         if(prev_slice_err == 2)
         {
             ps_dec->u1_first_slice_in_stream = 0;
             return ERROR_INCOMPLETE_FRAME;
         }
 
         if(ps_dec->u2_total_mbs_coded
                 >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
         {
             /* return if all MBs in frame are parsed*/
             ps_dec->u1_first_slice_in_stream = 0;
             return ERROR_IN_LAST_SLICE_OF_PIC;
         }
 
         if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)
         {
             ih264d_err_pic_dispbuf_mgr(ps_dec);
             return ERROR_NEW_FRAME_EXPECTED;
         }
 
         if(ret != OK)
             return ret;
 
         i1_is_end_of_poc = 0;
     }
 
     if (ps_dec->u4_first_slice_in_pic == 0)
     {
         ps_dec->ps_parse_cur_slice++;
         ps_dec->u2_cur_slice_num++;
     }
 
     // in the case of single core increment ps_decode_cur_slice
     if((ps_dec->u1_separate_parse == 0) && (ps_dec->u4_first_slice_in_pic == 0))
     {
         ps_dec->ps_decode_cur_slice++;
     }
     ps_dec->u1_slice_header_done = 0;
 
 
     if(u1_field_pic_flag)
     {
         ps_dec->u2_prv_frame_num = u2_frame_num;
     }
 
     if(ps_cur_slice->u1_mmco_equalto5)
     {
         WORD32 i4_temp_poc;
         WORD32 i4_top_field_order_poc, i4_bot_field_order_poc;
 
         if(!ps_cur_slice->u1_field_pic_flag) // or a complementary field pair
         {
             i4_top_field_order_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;
             i4_bot_field_order_poc =
                             ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;
             i4_temp_poc = MIN(i4_top_field_order_poc,
                                      i4_bot_field_order_poc);
         }
         else if(!ps_cur_slice->u1_bottom_field_flag)
             i4_temp_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;
         else
             i4_temp_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;
 
         ps_dec->ps_cur_pic->i4_top_field_order_cnt = i4_temp_poc
                         - ps_dec->ps_cur_pic->i4_top_field_order_cnt;
         ps_dec->ps_cur_pic->i4_bottom_field_order_cnt = i4_temp_poc
                         - ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;
         ps_dec->ps_cur_pic->i4_poc = i4_temp_poc;
         ps_dec->ps_cur_pic->i4_avg_poc = i4_temp_poc;
     }
     if(ps_dec->u4_first_slice_in_pic)
     {
         ret = ih264d_decode_pic_order_cnt(u1_is_idr_slice, u2_frame_num,
                                           &ps_dec->s_prev_pic_poc,
                                           &s_tmp_poc, ps_cur_slice, ps_pps,
                                           u1_nal_ref_idc,
                                           u1_bottom_field_flag,
                                           u1_field_pic_flag, &i4_poc);
         if(ret != OK)
             return ret;
         /* Display seq no calculations */
         if(i4_poc >= ps_dec->i4_max_poc)
             ps_dec->i4_max_poc = i4_poc;
         /* IDR Picture or POC wrap around */
         if(i4_poc == 0)
         {
-            ps_dec->i4_prev_max_display_seq = ps_dec->i4_prev_max_display_seq
-                            + ps_dec->i4_max_poc
-                            + ps_dec->u1_max_dec_frame_buffering + 1;
+            UWORD64 u8_temp;
+            u8_temp = (UWORD64)ps_dec->i4_prev_max_display_seq
+                      + ps_dec->i4_max_poc
+                      + ps_dec->u1_max_dec_frame_buffering + 1;
+            /*If i4_prev_max_display_seq overflows integer range, reset it */
+            ps_dec->i4_prev_max_display_seq = (u8_temp > 0x7fffffff)?
+                                              0 : u8_temp;
             ps_dec->i4_max_poc = 0;
         }
     }
 
     /*--------------------------------------------------------------------*/
     /* Copy the values read from the bitstream to the slice header and then*/
     /* If the slice is first slice in picture, then do Start of Picture   */
     /* processing.                                                        */
     /*--------------------------------------------------------------------*/
     ps_cur_slice->i4_delta_pic_order_cnt[0] = i_delta_poc[0];
     ps_cur_slice->i4_delta_pic_order_cnt[1] = i_delta_poc[1];
     ps_cur_slice->u4_idr_pic_id = u4_idr_pic_id;
     ps_cur_slice->u2_first_mb_in_slice = u2_first_mb_in_slice;
     ps_cur_slice->u1_field_pic_flag = u1_field_pic_flag;
     ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;
     ps_cur_slice->u1_slice_type = u1_slice_type;
     ps_cur_slice->i4_pic_order_cnt_lsb = s_tmp_poc.i4_pic_order_cnt_lsb;
 
     ps_cur_slice->u1_nal_unit_type = u1_nal_unit_type;
     ps_cur_slice->u1_redundant_pic_cnt = u1_redundant_pic_cnt;
     ps_cur_slice->u1_nal_ref_idc = u1_nal_ref_idc;
     ps_cur_slice->u1_pic_order_cnt_type = u1_pic_order_cnt_type;
 
     if(ps_seq->u1_frame_mbs_only_flag)
         ps_cur_slice->u1_direct_8x8_inference_flag =
                         ps_seq->u1_direct_8x8_inference_flag;
     else
         ps_cur_slice->u1_direct_8x8_inference_flag = 1;
 
     if(u1_slice_type == B_SLICE)
     {
         ps_cur_slice->u1_direct_spatial_mv_pred_flag = ih264d_get_bit_h264(
                         ps_bitstrm);
         COPYTHECONTEXT("SH: direct_spatial_mv_pred_flag",
                         ps_cur_slice->u1_direct_spatial_mv_pred_flag);
 
         if(ps_cur_slice->u1_direct_spatial_mv_pred_flag)
             ps_cur_slice->pf_decodeDirect = ih264d_decode_spatial_direct;
         else
             ps_cur_slice->pf_decodeDirect = ih264d_decode_temporal_direct;
         if(!((ps_pps->ps_sps->u1_mb_aff_flag) && (!u1_field_pic_flag)))
             ps_dec->pf_mvpred = ih264d_mvpred_nonmbaffB;
     }
     else
     {
         if(!((ps_pps->ps_sps->u1_mb_aff_flag) && (!u1_field_pic_flag)))
             ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;
     }
 
     if(ps_dec->u4_first_slice_in_pic)
     {
         if(u2_first_mb_in_slice == 0)
         {
             ret = ih264d_start_of_pic(ps_dec, i4_poc, &s_tmp_poc, u2_frame_num, ps_pps);
             if(ret != OK)
                 return ret;
         }
 
         ps_dec->u4_output_present = 0;
 
         {
             ih264d_get_next_display_field(ps_dec,
                                           ps_dec->ps_out_buffer,
                                           &(ps_dec->s_disp_op));
             /* If error code is non-zero then there is no buffer available for display,
              hence avoid format conversion */
 
             if(0 != ps_dec->s_disp_op.u4_error_code)
             {
                 ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;
             }
             else
                 ps_dec->u4_output_present = 1;
         }
         if(ps_dec->u1_separate_parse == 1)
         {
             if(ps_dec->u4_dec_thread_created == 0)
             {
                 ithread_create(ps_dec->pv_dec_thread_handle, NULL,
                                (void *)ih264d_decode_picture_thread,
                                (void *)ps_dec);
 
                 ps_dec->u4_dec_thread_created = 1;
             }
 
             if((ps_dec->u4_num_cores == 3) &&
                             ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)
                             && (ps_dec->u4_bs_deblk_thread_created == 0))
             {
                 ps_dec->u4_start_recon_deblk = 0;
                 ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,
                                (void *)ih264d_recon_deblk_thread,
                                (void *)ps_dec);
                 ps_dec->u4_bs_deblk_thread_created = 1;
             }
         }
 
     }
 
     /* INITIALIZATION of fn ptrs for MC and formMbPartInfo functions */
     {
         UWORD8 uc_nofield_nombaff;
 
 
 
         uc_nofield_nombaff = ((ps_dec->ps_cur_slice->u1_field_pic_flag == 0)
                         && (ps_dec->ps_cur_slice->u1_mbaff_frame_flag == 0)
                         && (u1_slice_type != B_SLICE)
                         && (ps_dec->ps_cur_pps->u1_wted_pred_flag == 0));
 
         /* Initialise MC and formMbPartInfo fn ptrs one time based on profile_idc */
 
         if(uc_nofield_nombaff)
         {
             ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;
             ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;
         }
         else
         {
             ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_mp;
             ps_dec->p_motion_compensate = ih264d_motion_compensate_mp;
         }
 
 
     }
 
     /*
      * Decide whether to decode the current picture or not
      */
     {
         dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;
         if(ps_err->u4_frm_sei_sync == u2_frame_num)
         {
             ps_err->u1_err_flag = ACCEPT_ALL_PICS;
             ps_err->u4_frm_sei_sync = SYNC_FRM_DEFAULT;
         }
         ps_err->u4_cur_frm = u2_frame_num;
     }
 
     /* Decision for decoding if the picture is to be skipped */
     {
         WORD32 i4_skip_b_pic, i4_skip_p_pic;
 
         i4_skip_b_pic = (ps_dec->u4_skip_frm_mask & B_SLC_BIT)
                         && (B_SLICE == u1_slice_type) && (0 == u1_nal_ref_idc);
 
         i4_skip_p_pic = (ps_dec->u4_skip_frm_mask & P_SLC_BIT)
                         && (P_SLICE == u1_slice_type) && (0 == u1_nal_ref_idc);
 
         /**************************************************************/
         /* Skip the B picture if skip mask is set for B picture and   */
         /* Current B picture is a non reference B picture or there is */
         /* no user for reference B picture                            */
         /**************************************************************/
         if(i4_skip_b_pic)
         {
             ps_dec->ps_cur_pic->u4_pack_slc_typ |= B_SLC_BIT;
             /* Don't decode the picture in SKIP-B mode if that picture is B */
             /* and also it is not to be used as a reference picture         */
             ps_dec->u1_last_pic_not_decoded = 1;
 
             return OK;
         }
         /**************************************************************/
         /* Skip the P picture if skip mask is set for P picture and   */
         /* Current P picture is a non reference P picture or there is */
         /* no user for reference P picture                            */
         /**************************************************************/
         if(i4_skip_p_pic)
         {
             ps_dec->ps_cur_pic->u4_pack_slc_typ |= P_SLC_BIT;
             /* Don't decode the picture in SKIP-P mode if that picture is P */
             /* and also it is not to be used as a reference picture         */
             ps_dec->u1_last_pic_not_decoded = 1;
 
             return OK;
         }
     }
 
     {
         UWORD16 u2_mb_x, u2_mb_y;
 
         ps_dec->i4_submb_ofst = ((u2_first_mb_in_slice
                         << ps_cur_slice->u1_mbaff_frame_flag) * SUB_BLK_SIZE)
                         - SUB_BLK_SIZE;
         if(u2_first_mb_in_slice)
         {
             UWORD8 u1_mb_aff;
             UWORD8 u1_field_pic;
             UWORD16 u2_frm_wd_in_mbs;
             u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs;
             u1_mb_aff = ps_cur_slice->u1_mbaff_frame_flag;
             u1_field_pic = ps_cur_slice->u1_field_pic_flag;
 
             {
                 UWORD32 x_offset;
                 UWORD32 y_offset;
                 UWORD32 u4_frame_stride;
                 tfr_ctxt_t *ps_trns_addr; // = &ps_dec->s_tran_addrecon_parse;
 
                 if(ps_dec->u1_separate_parse)
                 {
                     ps_trns_addr = &ps_dec->s_tran_addrecon_parse;
                 }
                 else
                 {
                     ps_trns_addr = &ps_dec->s_tran_addrecon;
                 }
                 u2_mb_x = MOD(u2_first_mb_in_slice, u2_frm_wd_in_mbs);
                 u2_mb_y = DIV(u2_first_mb_in_slice, u2_frm_wd_in_mbs);
 
                 u2_mb_y <<= u1_mb_aff;
 
                 if((u2_mb_x > u2_frm_wd_in_mbs - 1)
                                 || (u2_mb_y > ps_dec->u2_frm_ht_in_mbs - 1))
                 {
                     return ERROR_CORRUPTED_SLICE;
                 }
 
                 u4_frame_stride = ps_dec->u2_frm_wd_y << u1_field_pic;
                 x_offset = u2_mb_x << 4;
                 y_offset = (u2_mb_y * u4_frame_stride) << 4;
 
                 ps_trns_addr->pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1 + x_offset
                                 + y_offset;
 
                 u4_frame_stride = ps_dec->u2_frm_wd_uv << u1_field_pic;
                 x_offset >>= 1;
                 y_offset = (u2_mb_y * u4_frame_stride) << 3;
 
                 x_offset *= YUV420SP_FACTOR;
 
                 ps_trns_addr->pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2 + x_offset
                                 + y_offset;
                 ps_trns_addr->pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3 + x_offset
                                 + y_offset;
 
                 ps_trns_addr->pu1_mb_y = ps_trns_addr->pu1_dest_y;
                 ps_trns_addr->pu1_mb_u = ps_trns_addr->pu1_dest_u;
                 ps_trns_addr->pu1_mb_v = ps_trns_addr->pu1_dest_v;
 
 
                 // assign the deblock structure pointers to start of slice
                 if(ps_dec->u1_separate_parse == 1)
                 {
                     ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic
                                     + (u2_first_mb_in_slice << u1_mb_aff);
                 }
                 else
                 {
                         ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic
                                         + (u2_first_mb_in_slice << u1_mb_aff);
                 }
 
                 ps_dec->u2_cur_mb_addr = (u2_first_mb_in_slice << u1_mb_aff);
 
                 ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv
                                 + ((u2_first_mb_in_slice << u1_mb_aff) << 4);
             }
         }
         else
         {
             tfr_ctxt_t *ps_trns_addr;
 
             if(ps_dec->u1_separate_parse)
             {
                 ps_trns_addr = &ps_dec->s_tran_addrecon_parse;
             }
             else
             {
                 ps_trns_addr = &ps_dec->s_tran_addrecon;
             }
 
             u2_mb_x = 0xffff;
             u2_mb_y = 0;
             // assign the deblock structure pointers to start of slice
             ps_dec->u2_cur_mb_addr = 0;
             ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic;
             ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv;
             ps_trns_addr->pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1;
             ps_trns_addr->pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2;
             ps_trns_addr->pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3;
 
             ps_trns_addr->pu1_mb_y = ps_trns_addr->pu1_dest_y;
             ps_trns_addr->pu1_mb_u = ps_trns_addr->pu1_dest_u;
             ps_trns_addr->pu1_mb_v = ps_trns_addr->pu1_dest_v;
 
         }
 
         ps_dec->ps_part = ps_dec->ps_parse_part_params;
 
         ps_dec->u2_mbx =
                         (MOD(u2_first_mb_in_slice - 1, ps_seq->u2_frm_wd_in_mbs));
         ps_dec->u2_mby =
                         (DIV(u2_first_mb_in_slice - 1, ps_seq->u2_frm_wd_in_mbs));
         ps_dec->u2_mby <<= ps_cur_slice->u1_mbaff_frame_flag;
         ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;
         ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;
     }
 
     /* RBSP stop bit is used for CABAC decoding*/
     ps_bitstrm->u4_max_ofst += ps_dec->ps_cur_pps->u1_entropy_coding_mode;
 
     ps_dec->u1_B = (u1_slice_type == B_SLICE);
     ps_dec->u4_next_mb_skip = 0;
 
     ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice =
                     ps_dec->ps_cur_slice->u2_first_mb_in_slice;
     ps_dec->ps_parse_cur_slice->slice_type =
                     ps_dec->ps_cur_slice->u1_slice_type;
 
 
     ps_dec->u4_start_recon_deblk = 1;
     {
         WORD32 num_entries;
         WORD32 size;
         UWORD8 *pu1_buf;
 
         num_entries = MAX_FRAMES;
         if((1 >= ps_dec->ps_cur_sps->u1_num_ref_frames) &&
             (0 == ps_dec->i4_display_delay))
         {
             num_entries = 1;
         }
         num_entries = ((2 * num_entries) + 1);
         num_entries *= 2;
 
 
         size = num_entries * sizeof(void *);
         size += PAD_MAP_IDX_POC * sizeof(void *);
 
         pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;
         pu1_buf += size * ps_dec->u2_cur_slice_num;
         ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = ( void *)pu1_buf;
     }
 
     if(ps_dec->u1_separate_parse)
     {
         ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;
     }
     else
     {
         ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;
     }
 
     ret = ih264d_fix_error_in_dpb(ps_dec);
     if(ret < 0)
         return ERROR_DBP_MANAGER_T;
 
     if(u1_slice_type == I_SLICE)
     {
         ps_dec->ps_cur_pic->u4_pack_slc_typ |= I_SLC_BIT;
 
         ret = ih264d_parse_islice(ps_dec, u2_first_mb_in_slice);
         ps_dec->u1_pr_sl_type = u1_slice_type;
         if(ps_dec->i4_pic_type != B_SLICE && ps_dec->i4_pic_type != P_SLICE)
             ps_dec->i4_pic_type = I_SLICE;
 
     }
     else if(u1_slice_type == P_SLICE)
     {
         ps_dec->ps_cur_pic->u4_pack_slc_typ |= P_SLC_BIT;
         ret = ih264d_parse_pslice(ps_dec, u2_first_mb_in_slice);
         ps_dec->u1_pr_sl_type = u1_slice_type;
         if(ps_dec->i4_pic_type != B_SLICE)
             ps_dec->i4_pic_type = P_SLICE;
     }
     else if(u1_slice_type == B_SLICE)
     {
         ps_dec->ps_cur_pic->u4_pack_slc_typ |= B_SLC_BIT;
         ret = ih264d_parse_bslice(ps_dec, u2_first_mb_in_slice);
         ps_dec->u1_pr_sl_type = u1_slice_type;
         ps_dec->i4_pic_type = B_SLICE;
     }
     else
         return ERROR_INV_SLC_TYPE_T;
 
     if(ps_dec->u1_slice_header_done)
     {
         /* set to zero to indicate a valid slice has been decoded */
         ps_dec->u1_first_slice_in_stream = 0;
     }
 
     if(ret != OK)
         return ret;
 
     if(u1_nal_ref_idc != 0)
     {
         if(!ps_dec->ps_dpb_cmds->u1_dpb_commands_read)
         {
             memcpy((void *)ps_dec->ps_dpb_cmds, (void *)(&(ps_dec->s_dpb_cmds_scratch)),
                    sizeof(dpb_commands_t));
         }
     }
 
     /* storing last Mb X and MbY of the slice */
     ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;
     ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;
 
     /* End of Picture detection */
 
     if(ps_dec->u2_total_mbs_coded >= (ps_seq->u2_max_mb_addr + 1))
     {
         ps_dec->u1_pic_decode_done = 1;
 
     }
 
     {
         dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;
         if((ps_err->u1_err_flag & REJECT_PB_PICS)
                         && (ps_err->u1_cur_pic_type == PIC_TYPE_I))
         {
             ps_err->u1_err_flag = ACCEPT_ALL_PICS;
         }
     }
 
     PRINT_BIN_BIT_RATIO(ps_dec)
 
     return ret;
 }
 
diff --git a/decoder/ih264d_process_bslice.c b/decoder/ih264d_process_bslice.c
index 42fad03..3ff15df 100644
--- a/decoder/ih264d_process_bslice.c
+++ b/decoder/ih264d_process_bslice.c
@@ -570,356 +570,356 @@ WORD32 ih264d_decode_spatial_direct(dec_struct_t * ps_dec,
 /*!
  **************************************************************************
  * \if Function name : ih264d_decode_temporal_direct \endif
  *
  * \brief
  *    Decodes temporal direct mode.
  *
  * \return
  *    None.
  *
  **************************************************************************
  */
 WORD32 ih264d_decode_temporal_direct(dec_struct_t * ps_dec,
                                      UWORD8 u1_wd_x,
                                      dec_mb_info_t * ps_cur_mb_info,
                                      UWORD8 u1_mb_num)
 {
     struct pic_buffer_t *ps_pic_buff0, *ps_pic_buff1, *ps_col_pic;
     mv_pred_t *ps_mv, s_temp_mv_pred;
     UWORD8 u1_sub_mb_num;
     UWORD8 u1_mbaff = ps_dec->ps_cur_slice->u1_mbaff_frame_flag;
     WORD16 i2_mv_x0, i2_mv_y0, i2_mv_x1, i2_mv_y1;
     UWORD8 u1_mb_partw, u1_mb_parth;
     UWORD8 i, partition_size, sub_partition;
     UWORD32 *pui32_weight_ofsts = NULL;
     directmv_t s_mvdirect;
     const UWORD8 *pu1_mb_parth = (const UWORD8 *)gau1_ih264d_mb_parth;
     const UWORD8 *pu1_mb_partw = (const UWORD8 *)gau1_ih264d_mb_partw;
     WORD8 c_refFrm0, c_refFrm1;
     UWORD8 u1_ref_idx0, u1_is_cur_mb_fld;
-    UWORD32 pic0_poc, pic1_poc, cur_poc;
+    WORD32 pic0_poc, pic1_poc, cur_poc;
     WORD32 ret = 0;
 
     u1_is_cur_mb_fld = ps_cur_mb_info->u1_mb_field_decodingflag;
     ps_pic_buff1 = ps_dec->ps_ref_pic_buf_lx[1][0];
 
     /**********************************************************************/
     /* Call the function which gets the number of partitions and          */
     /* partition info of colocated Mb                                     */
     /**********************************************************************/
     ps_dec->pf_parse_mvdirect(ps_dec, ps_dec->ps_col_pic, &s_mvdirect, u1_wd_x,
                            ps_dec->i4_submb_ofst, ps_cur_mb_info);
     ps_col_pic = ps_dec->ps_col_pic;
 
     for(i = 0; i < s_mvdirect.i1_num_partitions; i++)
     {
         UWORD8 u1_colz;
         partition_size = s_mvdirect.i1_partitionsize[i];
         u1_sub_mb_num = s_mvdirect.i1_submb_num[i];
         ps_mv = ps_col_pic->ps_mv + s_mvdirect.i4_mv_indices[i];
 
         /* This should be removed to catch unitialized memory read */
         u1_ref_idx0 = 0;
 
         sub_partition = partition_size >> 2;
         partition_size &= 0x3;
         u1_mb_partw = pu1_mb_partw[partition_size];
         u1_mb_parth = pu1_mb_parth[partition_size];
         if(sub_partition != 0)
         {
             u1_mb_partw >>= 1;
             u1_mb_parth >>= 1;
         }
         c_refFrm0 = ps_mv->i1_ref_frame[0];
         c_refFrm1 = ps_mv->i1_ref_frame[1];
 
         if((c_refFrm0 == -1) && (c_refFrm1 == -1))
         {
             u1_ref_idx0 = 0;
             ps_pic_buff0 = ps_dec->ps_ref_pic_buf_lx[0][0];
             if(u1_mbaff && u1_is_cur_mb_fld)
             {
                 if(ps_cur_mb_info->u1_topmb)
                 {
                     pic0_poc = ps_pic_buff0->i4_top_field_order_cnt;
                     pic1_poc = ps_pic_buff1->i4_top_field_order_cnt;
                     cur_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;
                 }
                 else
                 {
                     pic1_poc = ps_pic_buff1->i4_bottom_field_order_cnt;
                     cur_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;
                     ps_pic_buff1 = ps_dec->ps_ref_pic_buf_lx[1][MAX_REF_BUFS];
                     pic0_poc = ps_pic_buff0->i4_bottom_field_order_cnt;
                     ps_pic_buff0 = ps_dec->ps_ref_pic_buf_lx[0][MAX_REF_BUFS];
                 }
             }
             else
             {
                 pic0_poc = ps_pic_buff0->i4_avg_poc;
                 pic1_poc = ps_pic_buff1->i4_avg_poc;
                 cur_poc = ps_dec->ps_cur_pic->i4_poc;
             }
         }
         else
         {
             UWORD8 uc_i, u1_num_frw_ref_pics;
             UWORD8 buf_id, u1_pic_type;
             buf_id = ps_mv->u1_col_ref_pic_idx;
             u1_pic_type = ps_mv->u1_pic_type;
             if(ps_dec->ps_cur_slice->u1_field_pic_flag)
             {
                 if(s_mvdirect.u1_vert_mv_scale == FRM_TO_FLD)
                 {
                     u1_pic_type = TOP_FLD;
                     if(ps_dec->ps_cur_slice->u1_bottom_field_flag)
                         u1_pic_type = BOT_FLD;
                 }
             }
             u1_num_frw_ref_pics =
                             ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0];
 
             for(uc_i = 0; uc_i < u1_num_frw_ref_pics; uc_i++)
             {
                 if(ps_dec->ps_cur_slice->u1_field_pic_flag)
                 {
                     if(ps_dec->ps_ref_pic_buf_lx[0][uc_i]->u1_mv_buf_id == buf_id)
                     {
                         if(ps_dec->ps_ref_pic_buf_lx[0][uc_i]->u1_pic_type
                                         == u1_pic_type)
                         {
                             u1_ref_idx0 = uc_i;
                             break;
                         }
                     }
                 }
                 else
                 {
                     if(ps_dec->ps_ref_pic_buf_lx[0][uc_i]->u1_mv_buf_id == buf_id)
                     {
                         u1_ref_idx0 = uc_i;
                         break;
                     }
                 }
             }
 
             ps_pic_buff0 = ps_dec->ps_ref_pic_buf_lx[0][u1_ref_idx0];
             ps_pic_buff1 = ps_dec->ps_ref_pic_buf_lx[1][0];
 
             if(u1_mbaff && u1_is_cur_mb_fld)
             {
                 pic0_poc = ps_pic_buff0->i4_top_field_order_cnt;
                 u1_ref_idx0 <<= 1;
                 if(s_mvdirect.u1_vert_mv_scale == ONE_TO_ONE)
                 {
                     if(u1_pic_type == BOT_FLD)
                     {
                         pic0_poc = ps_pic_buff0->i4_bottom_field_order_cnt;
                         ps_pic_buff0 = ps_dec->ps_ref_pic_buf_lx[0][(u1_ref_idx0
                                         >> 1) + MAX_REF_BUFS];
                         if(ps_cur_mb_info->u1_topmb)
                             u1_ref_idx0++;
                     }
                     else
                     {
                         if(1 - ps_cur_mb_info->u1_topmb)
                             u1_ref_idx0++;
                     }
                 }
                 if(s_mvdirect.u1_vert_mv_scale == FRM_TO_FLD)
                 {
                     if(1 - ps_cur_mb_info->u1_topmb)
                     {
                         pic0_poc = ps_pic_buff0->i4_bottom_field_order_cnt;
                         ps_pic_buff0 = ps_dec->ps_ref_pic_buf_lx[0][(u1_ref_idx0
                                         >> 1) + MAX_REF_BUFS];
                     }
                 }
                 if(ps_cur_mb_info->u1_topmb)
                 {
                     pic1_poc = ps_pic_buff1->i4_top_field_order_cnt;
                     cur_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;
                 }
                 else
                 {
                     pic1_poc = ps_pic_buff1->i4_bottom_field_order_cnt;
                     cur_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;
                     ps_pic_buff1 = ps_dec->ps_ref_pic_buf_lx[1][MAX_REF_BUFS];
                 }
             }
             else
             {
                 pic0_poc = ps_pic_buff0->i4_avg_poc;
                 pic1_poc = ps_pic_buff1->i4_avg_poc;
                 cur_poc = ps_dec->ps_cur_pic->i4_poc;
             }
         }
         {
             WORD16 i16_td;
-
+            WORD32 diff;
             if(c_refFrm0 >= 0)
             {
                 i2_mv_x0 = ps_mv->i2_mv[0];
                 i2_mv_y0 = ps_mv->i2_mv[1];
             }
             else if(c_refFrm1 >= 0)
             {
                 i2_mv_x0 = ps_mv->i2_mv[2];
                 i2_mv_y0 = ps_mv->i2_mv[3];
             }
             else
             {
                 i2_mv_x0 = 0;
                 i2_mv_y0 = 0;
             }
             /* If FRM_TO_FLD or FLD_TO_FRM scale the "y" component of the colocated Mv*/
             if(s_mvdirect.u1_vert_mv_scale == FRM_TO_FLD)
             {
                 i2_mv_y0 /= 2;
             }
             else if(s_mvdirect.u1_vert_mv_scale == FLD_TO_FRM)
             {
                 i2_mv_y0 *= 2;
             }
 
-            i16_td = pic1_poc - pic0_poc;
+            diff = pic1_poc - pic0_poc;
+            i16_td = CLIP_S8(diff);
             if((ps_pic_buff0->u1_is_short == 0) || (i16_td == 0))
             {
                 i2_mv_x1 = 0;
                 i2_mv_y1 = 0;
             }
             else
             {
                 WORD16 i16_tb, i16_tx, i2_dist_scale_factor, i16_temp;
 
-                i16_td = CLIP3(-128, 127, i16_td);
-                i16_tb = cur_poc - pic0_poc;
-                i16_tb = CLIP3(-128, 127, i16_tb);
+                diff = cur_poc - pic0_poc;
+                i16_tb = CLIP_S8(diff);
 
                 i16_tx = (16384 + ABS(SIGN_POW2_DIV(i16_td, 1))) / i16_td;
-                i2_dist_scale_factor = CLIP3(-1024, 1023,
+                i2_dist_scale_factor = CLIP_S11(
                                             (((i16_tb * i16_tx) + 32) >> 6));
                 i16_temp = (i2_mv_x0 * i2_dist_scale_factor + 128) >> 8;
                 i2_mv_x1 = i16_temp - i2_mv_x0;
                 i2_mv_x0 = i16_temp;
 
                 i16_temp = (i2_mv_y0 * i2_dist_scale_factor + 128) >> 8;
                 i2_mv_y1 = i16_temp - i2_mv_y0;
                 i2_mv_y0 = i16_temp;
             }
             {
                 mv_pred_t *ps_mv;
 
                 /*u1_sub_mb_x = u1_sub_mb_num & 0x03;
                  uc_sub_mb_y = u1_sub_mb_num >> 2;*/
                 if(ps_dec->ps_cur_pps->u1_wted_bipred_idc)
                 {
                     UWORD8 u1_idx =
                                     u1_ref_idx0
                                                     * ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[1];
                     UWORD8 u1_scale_ref = u1_mbaff && u1_is_cur_mb_fld;
                     if(u1_scale_ref)
                         u1_idx >>= 1;
                     pui32_weight_ofsts = (UWORD32*)&ps_dec->pu4_wt_ofsts[2
                                     * X3(u1_idx)];
                     if(u1_scale_ref
                                     && (ps_dec->ps_cur_pps->u1_wted_bipred_idc
                                                     == 2))
                     {
                         WORD16 i2_ref_idx;
                         i2_ref_idx = u1_ref_idx0;
                         i2_ref_idx *=
                                         (ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[1]
                                                         << 1);
                         if(!ps_cur_mb_info->u1_topmb)
                             i2_ref_idx +=
                                             (ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0]
                                                             << 1)
                                                             * (ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[1]
                                                                             << 1);
                         pui32_weight_ofsts =
                                         (UWORD32*)&ps_dec->pu4_mbaff_wt_mat[2
                                                         * X3(i2_ref_idx)];
                     }
                 }
                 {
                     pred_info_pkd_t *ps_pred_pkd;
                    WORD16 i2_mv[2];
                    WORD8 i1_ref_idx= 0;
 
                    i2_mv[0] = i2_mv_x0;
                    i2_mv[1] = i2_mv_y0;
 
                    ps_pred_pkd = ps_dec->ps_pred_pkd + ps_dec->u4_pred_info_pkd_idx;
                 ih264d_fill_pred_info(i2_mv,u1_mb_partw,u1_mb_parth,u1_sub_mb_num,PRED_L0 | PRED_L1,
                                 ps_pred_pkd,ps_pic_buff0->u1_pic_buf_id,i1_ref_idx,pui32_weight_ofsts,
                                 ps_pic_buff0->u1_pic_type);
                 ps_dec->u4_pred_info_pkd_idx++;
                 ps_cur_mb_info->u1_num_pred_parts++;
 
 
                 }
                 {
                    pred_info_pkd_t *ps_pred_pkd;
                    WORD16 i2_mv[2];
                    WORD8 i1_ref_idx= 0;
 
                    i2_mv[0] = i2_mv_x1;
                    i2_mv[1] = i2_mv_y1;
 
                    ps_pred_pkd = ps_dec->ps_pred_pkd + ps_dec->u4_pred_info_pkd_idx;
                 ih264d_fill_pred_info(i2_mv,u1_mb_partw,u1_mb_parth,u1_sub_mb_num,PRED_L0 | PRED_L1,
                                 ps_pred_pkd,ps_pic_buff1->u1_pic_buf_id,i1_ref_idx,pui32_weight_ofsts,
                                 ps_pic_buff1->u1_pic_type);
                 ps_dec->u4_pred_info_pkd_idx++;
                 ps_cur_mb_info->u1_num_pred_parts++;
 
 
                 }
 
                 /* Replication optimisation */
                 s_temp_mv_pred.i2_mv[0] = i2_mv_x0;
                 s_temp_mv_pred.i2_mv[1] = i2_mv_y0;
                 s_temp_mv_pred.i2_mv[2] = i2_mv_x1;
                 s_temp_mv_pred.i2_mv[3] = i2_mv_y1;
                 s_temp_mv_pred.i1_ref_frame[0] = u1_ref_idx0;
                 s_temp_mv_pred.i1_ref_frame[1] = 0;
                 s_temp_mv_pred.u1_col_ref_pic_idx = ps_pic_buff0->u1_mv_buf_id;
                 s_temp_mv_pred.u1_pic_type = ps_pic_buff0->u1_pic_type;
                 ps_mv = ps_dec->ps_mv_cur + (u1_mb_num << 4) + u1_sub_mb_num;
 
                 {
                     WORD16 i2_mv_x = 0, i2_mv_y = 0;
                     UWORD8 u1_packed_mb_sub_mb_mode =
                                     sub_partition ? (s_mvdirect.i1_partitionsize[i]) : ((s_mvdirect.i1_partitionsize[i])
                                                                     << 2);
 
                     if(c_refFrm0 >= 0)
                     {
                         i2_mv_x = i2_mv_x0;
                         i2_mv_y = i2_mv_y0;
                     }
                     else
                     {
                         i2_mv_x = i2_mv_x1;
                         i2_mv_y = i2_mv_y1;
                     }
 
                     u1_colz =
                                     (ps_cur_mb_info->u1_mb_field_decodingflag << 1)
                                                     | ((u1_ref_idx0 == 0)
                                                                     && (ABS(i2_mv_x)
                                                                                     <= 1)
                                                                     && (ABS(i2_mv_y)
                                                                                     <= 1));
                     u1_colz |= (u1_packed_mb_sub_mb_mode << 4);
                 }
                 ih264d_rep_mv_colz(ps_dec, &s_temp_mv_pred, ps_mv, u1_sub_mb_num,
                                    u1_colz, u1_mb_parth, u1_mb_partw);
             }
         }
     }
     /* return value set to UWORD8 to make it homogeneous  */
     /* with decodespatialdirect                           */
     return OK;
 }
diff --git a/decoder/ih264d_process_intra_mb.c b/decoder/ih264d_process_intra_mb.c
index 211d796..2d4d006 100644
--- a/decoder/ih264d_process_intra_mb.c
+++ b/decoder/ih264d_process_intra_mb.c
@@ -700,1323 +700,1323 @@ UWORD32 ih264d_unpack_luma_coeff8x8_mb(dec_struct_t * ps_dec,
     return u4_luma_dc_only_cbp;
 }
 /*!
  **************************************************************************
  * \if Function name : ih264d_process_intra_mb \endif
  *
  * \brief
  *    This function decodes an I MB. Intraprediction is carried out followed
  *    by InvTramsform. Both IntraPrediction and Reconstrucion are carried out
  *    row buffer itself.
  *
  *
  * \return
  *    0 on Success and Error code otherwise
  **************************************************************************
  */
 WORD32 ih264d_process_intra_mb(dec_struct_t * ps_dec,
                                dec_mb_info_t * ps_cur_mb_info,
                                UWORD8 u1_mb_num)
 {
     UWORD8 u1_mb_type = ps_cur_mb_info->u1_mb_type;
     UWORD8 uc_temp = ps_cur_mb_info->u1_mb_ngbr_availablity;
     UWORD8 u1_top_available = BOOLEAN(uc_temp & TOP_MB_AVAILABLE_MASK);
     UWORD8 u1_left_available = BOOLEAN(uc_temp & LEFT_MB_AVAILABLE_MASK);
     UWORD8 u1_use_top_right_mb = BOOLEAN(uc_temp & TOP_RIGHT_MB_AVAILABLE_MASK);
     UWORD8 u1_use_top_left_mb = BOOLEAN(uc_temp & TOP_LEFT_MB_AVAILABLE_MASK);
     UWORD8 uc_useTopMB = u1_top_available;
     UWORD16 u2_use_left_mb = u1_left_available;
     UWORD16 u2_use_left_mb_pack;
     UWORD8 *pu1_luma_pred_buffer;
     /* CHANGED CODE */
     UWORD8 *pu1_luma_rec_buffer;
     UWORD8 *puc_top;
 
     mb_neigbour_params_t *ps_left_mb;
     mb_neigbour_params_t *ps_top_mb;
     mb_neigbour_params_t *ps_top_right_mb;
     mb_neigbour_params_t *ps_curmb;
 
     UWORD16 u2_mbx = ps_cur_mb_info->u2_mbx;
     UWORD32 ui_pred_width, ui_rec_width;
     WORD16 *pi2_y_coeff;
     UWORD8 u1_mbaff, u1_topmb, u1_mb_field_decoding_flag;
     UWORD32 u4_num_pmbair;
     UWORD16 ui2_luma_csbp = ps_cur_mb_info->u2_luma_csbp;
     UWORD8 *pu1_yleft, *pu1_ytop_left;
     /* Chroma variables*/
     UWORD8 *pu1_top_u;
     UWORD8 *pu1_uleft;
     UWORD8 *pu1_u_top_left;
     /* CHANGED CODE */
     UWORD8 *pu1_mb_cb_rei1_buffer, *pu1_mb_cr_rei1_buffer;
     UWORD32 u4_recwidth_cr;
     /* CHANGED CODE */
     tfr_ctxt_t *ps_frame_buf = ps_dec->ps_frame_buf_ip_recon;
     UWORD32 u4_luma_dc_only_csbp = 0;
     UWORD32 u4_luma_dc_only_cbp = 0;
 
     UWORD8 *pu1_prev_intra4x4_pred_mode_data = (UWORD8 *)ps_dec->pv_proc_tu_coeff_data;                 //Pointer to keep track of intra4x4_pred_mode data in pv_proc_tu_coeff_data buffer
     u1_mbaff = ps_dec->ps_cur_slice->u1_mbaff_frame_flag;
     u1_topmb = ps_cur_mb_info->u1_topmb;
     u4_num_pmbair = (u1_mb_num >> u1_mbaff);
 
 
     /*--------------------------------------------------------------------*/
     /* Find the current MB's mb params                                    */
     /*--------------------------------------------------------------------*/
     u1_mb_field_decoding_flag = ps_cur_mb_info->u1_mb_field_decodingflag;
 
     ps_curmb = ps_cur_mb_info->ps_curmb;
     ps_top_mb = ps_cur_mb_info->ps_top_mb;
     ps_left_mb = ps_cur_mb_info->ps_left_mb;
     ps_top_right_mb = ps_cur_mb_info->ps_top_right_mb;
 
     /*--------------------------------------------------------------------*/
     /* Check whether neighbouring MB is Inter MB and                      */
     /* constrained intra pred is 1.                                       */
     /*--------------------------------------------------------------------*/
     u2_use_left_mb_pack = (u2_use_left_mb << 8) + u2_use_left_mb;
 
     if(ps_dec->ps_cur_pps->u1_constrained_intra_pred_flag)
     {
         UWORD8 u1_left = (UWORD8)u2_use_left_mb;
 
         uc_useTopMB = uc_useTopMB
                         && ((ps_top_mb->u1_mb_type != P_MB)
                                         && (ps_top_mb->u1_mb_type != B_MB));
         u2_use_left_mb = u2_use_left_mb
                         && ((ps_left_mb->u1_mb_type != P_MB)
                                         && (ps_left_mb->u1_mb_type != B_MB));
 
         u2_use_left_mb_pack = (u2_use_left_mb << 8) + u2_use_left_mb;
         if(u1_mbaff)
         {
             if(u1_mb_field_decoding_flag ^ ps_left_mb->u1_mb_fld)
             {
                 u1_left = u1_left
                                 && (((ps_left_mb + 1)->u1_mb_type != P_MB)
                                                 && ((ps_left_mb + 1)->u1_mb_type
                                                                 != B_MB));
                 u2_use_left_mb = u2_use_left_mb && u1_left;
                 if(u1_mb_field_decoding_flag)
                     u2_use_left_mb_pack = (u1_left << 8)
                                     + (u2_use_left_mb_pack & 0xff);
                 else
                     u2_use_left_mb_pack = (u2_use_left_mb << 8)
                                     + (u2_use_left_mb);
             }
         }
         u1_use_top_right_mb =
                         u1_use_top_right_mb
                                         && ((ps_top_right_mb->u1_mb_type != P_MB)
                                                         && (ps_top_right_mb->u1_mb_type
                                                                         != B_MB));
 
         u1_use_top_left_mb =
                         u1_use_top_left_mb
                                         && ((ps_cur_mb_info->u1_topleft_mbtype != P_MB)
                                                         && (ps_cur_mb_info->u1_topleft_mbtype
                                                                         != B_MB));
     }
 
     /*********************Common pointer calculations *************************/
     /* CHANGED CODE */
     pu1_luma_pred_buffer = ps_dec->pu1_y;
     pu1_luma_rec_buffer = ps_frame_buf->pu1_dest_y + (u4_num_pmbair << 4);
     pu1_mb_cb_rei1_buffer = ps_frame_buf->pu1_dest_u
                     + (u4_num_pmbair << 3) * YUV420SP_FACTOR;
     pu1_mb_cr_rei1_buffer = ps_frame_buf->pu1_dest_v + (u4_num_pmbair << 3);
     ui_pred_width = MB_SIZE;
     ui_rec_width = ps_dec->u2_frm_wd_y << u1_mb_field_decoding_flag;
     u4_recwidth_cr = ps_dec->u2_frm_wd_uv << u1_mb_field_decoding_flag;
     /************* Current and top luma pointer *****************/
 
     if(u1_mbaff)
     {
         if(u1_topmb == 0)
         {
             pu1_luma_rec_buffer += (
                             u1_mb_field_decoding_flag ?
                                             (ui_rec_width >> 1) :
                                             (ui_rec_width << 4));
             pu1_mb_cb_rei1_buffer += (
                             u1_mb_field_decoding_flag ?
                                             (u4_recwidth_cr >> 1) :
                                             (u4_recwidth_cr << 3));
             pu1_mb_cr_rei1_buffer += (
                             u1_mb_field_decoding_flag ?
                                             (u4_recwidth_cr >> 1) :
                                             (u4_recwidth_cr << 3));
         }
     }
 
     /* CHANGED CODE */
     if(ps_dec->u4_use_intrapred_line_copy == 1)
     {
         puc_top = ps_dec->pu1_prev_y_intra_pred_line + (ps_cur_mb_info->u2_mbx << 4);
         pu1_top_u = ps_dec->pu1_prev_u_intra_pred_line
                         + (ps_cur_mb_info->u2_mbx << 3) * YUV420SP_FACTOR;
     }
     else
     {
         puc_top = pu1_luma_rec_buffer - ui_rec_width;
         pu1_top_u = pu1_mb_cb_rei1_buffer - u4_recwidth_cr;
     }
     /* CHANGED CODE */
 
     /************* Left pointer *****************/
     pu1_yleft = pu1_luma_rec_buffer - 1;
     pu1_uleft = pu1_mb_cb_rei1_buffer - 1 * YUV420SP_FACTOR;
 
     /**************Top Left pointer calculation**********/
     pu1_ytop_left = puc_top - 1;
     pu1_u_top_left = pu1_top_u - 1 * YUV420SP_FACTOR;
 
     /* CHANGED CODE */
     PROFILE_DISABLE_INTRA_PRED()
     {
         pu1_prev_intra4x4_pred_mode_data = (UWORD8 *)ps_dec->pv_proc_tu_coeff_data;
         if(u1_mb_type == I_4x4_MB && ps_cur_mb_info->u1_tran_form8x8 == 0)
         {
             ps_dec->pv_proc_tu_coeff_data = (void *)((UWORD8 *)ps_dec->pv_proc_tu_coeff_data + 32);
 
         }
         else if (u1_mb_type == I_4x4_MB && ps_cur_mb_info->u1_tran_form8x8 == 1)
         {
             ps_dec->pv_proc_tu_coeff_data = (void *)((UWORD8 *)ps_dec->pv_proc_tu_coeff_data + 8);
         }
     }
     if(!ps_cur_mb_info->u1_tran_form8x8)
     {
         u4_luma_dc_only_csbp = ih264d_unpack_luma_coeff4x4_mb(ps_dec,
                                        ps_cur_mb_info,
                                        1);
     }
     else
     {
         if(!ps_dec->ps_cur_pps->u1_entropy_coding_mode)
         {
             u4_luma_dc_only_cbp = ih264d_unpack_luma_coeff4x4_mb(ps_dec,
                                            ps_cur_mb_info,
                                            1);
         }
         else
         {
             u4_luma_dc_only_cbp = ih264d_unpack_luma_coeff8x8_mb(ps_dec,
                                            ps_cur_mb_info);
         }
     }
 
     pi2_y_coeff = ps_dec->pi2_coeff_data;
 
     if(u1_mb_type != I_4x4_MB)
     {
         UWORD8 u1_intrapred_mode = MB_TYPE_TO_INTRA_16x16_MODE(u1_mb_type);
         /*--------------------------------------------------------------------*/
         /* 16x16 IntraPrediction                                              */
         /*--------------------------------------------------------------------*/
         {
             UWORD8 u1_packed_modes = (u1_top_available << 1)
                             + u1_left_available;
             UWORD8 u1_err_code =
                             (u1_intrapred_mode & 1) ?
                                             u1_intrapred_mode :
                                             (u1_intrapred_mode ^ 2);
 
             if((u1_err_code & u1_packed_modes) ^ u1_err_code)
             {
                 u1_intrapred_mode = 0;
                 ps_dec->i4_error_code = ERROR_INTRAPRED;
             }
         }
         {
             /* Align the size to multiple of 8, so that SIMD functions
                can read 64 bits at a time. Only 33 bytes are actaully used */
             UWORD8 au1_ngbr_pels[40];
             /* Get neighbour pixels */
             /* left pels */
             if(u2_use_left_mb)
             {
                 WORD32 i;
                 for(i = 0; i < 16; i++)
                     au1_ngbr_pels[16 - 1 - i] = pu1_yleft[i * ui_rec_width];
             }
             else
             {
                 memset(au1_ngbr_pels, 0, 16);
             }
 
             /* top left pels */
             au1_ngbr_pels[16] = *pu1_ytop_left;
 
             /* top pels */
             if(uc_useTopMB)
             {
                 memcpy(au1_ngbr_pels + 16 + 1, puc_top, 16);
             }
             else
             {
                 memset(au1_ngbr_pels + 16 + 1, 0, 16);
             }
             PROFILE_DISABLE_INTRA_PRED()
             ps_dec->apf_intra_pred_luma_16x16[u1_intrapred_mode](
                             au1_ngbr_pels, pu1_luma_rec_buffer, 1, ui_rec_width,
                             ((uc_useTopMB << 2) | u2_use_left_mb));
         }
         {
             UWORD32 i;
             WORD16 ai2_tmp[16];
             for(i = 0; i < 16; i++)
             {
                 WORD16 *pi2_level = pi2_y_coeff + (i << 4);
                 UWORD8 *pu1_pred_sblk = pu1_luma_rec_buffer
                                 + ((i & 0x3) * BLK_SIZE)
                                 + (i >> 2) * (ui_rec_width << 2);
                 PROFILE_DISABLE_IQ_IT_RECON()
                 {
                     if(CHECKBIT(ps_cur_mb_info->u2_luma_csbp, i))
                     {
                         ps_dec->pf_iquant_itrans_recon_luma_4x4(
                                         pi2_level,
                                         pu1_pred_sblk,
                                         pu1_pred_sblk,
                                         ui_rec_width,
                                         ui_rec_width,
                                         gau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qp_rem6],
                                         (UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[0],
                                         ps_cur_mb_info->u1_qp_div6, ai2_tmp, 1,
                                         pi2_level);
                     }
                     else if((CHECKBIT(u4_luma_dc_only_csbp, i)) && pi2_level[0] != 0)
                     {
                         ps_dec->pf_iquant_itrans_recon_luma_4x4_dc(
                                         pi2_level,
                                         pu1_pred_sblk,
                                         pu1_pred_sblk,
                                         ui_rec_width,
                                         ui_rec_width,
                                         gau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qp_rem6],
                                         (UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[0],
                                         ps_cur_mb_info->u1_qp_div6, ai2_tmp, 1,
                                         pi2_level);
                     }
                 }
             }
         }
     }
     else if(!ps_cur_mb_info->u1_tran_form8x8)
     {
         UWORD8 u1_is_left_sub_block, u1_is_top_sub_block = uc_useTopMB;
         UWORD8 u1_sub_blk_x, u1_sub_blk_y, u1_sub_mb_num;
         WORD8 i1_top_pred_mode;
         WORD8 i1_left_pred_mode;
         UWORD8 *pu1_top, *pu1_left, *pu1_top_left, *pu1_top_right;
         WORD8 *pi1_cur_pred_mode, *pi1_left_pred_mode, *pc_topPredMode;
         UWORD16 ui2_left_pred_buf_width = 0xffff;
         WORD8 i1_intra_pred;
         UWORD8 *pu1_prev_intra4x4_pred_mode_flag = pu1_prev_intra4x4_pred_mode_data;
         UWORD8 *pu1_rem_intra4x4_pred_mode = pu1_prev_intra4x4_pred_mode_data + 16;
         WORD16 *pi2_y_coeff1;
         UWORD8 u1_cur_sub_block;
         UWORD16 ui2_top_rt_mask;
 
         /*--------------------------------------------------------------------*/
         /* 4x4 IntraPrediction                                                */
         /*--------------------------------------------------------------------*/
         /* Calculation of Top Right subblock mask                             */
         /*                                                                    */
         /* (a) Set it to default mask                                         */
         /*     [It has 0 for sublocks which will never have top-right sub block] */
         /*                                                                    */
         /* (b) If top MB is not available                                     */
         /*      Clear the bits of the first row sub blocks                    */
         /*                                                                    */
         /* (c) Set/Clear bit for top-right sublock of MB                      */
         /*      [5 sub-block in decoding order] based on TOP RIGHT MB availablity */
         /*--------------------------------------------------------------------*/
 
         pu1_top = puc_top;
 
         ui2_top_rt_mask = (u1_use_top_right_mb << 3) | (0x5750);
         if(uc_useTopMB)
             ui2_top_rt_mask |= 0x7;
 
         /*Top Related initialisations*/
 
 
         pi1_cur_pred_mode = ps_cur_mb_info->ps_curmb->pi1_intrapredmodes;
         pc_topPredMode = ps_cur_mb_info->ps_top_mb->pi1_intrapredmodes;
         /*--------------------------------------
          if(u1_mbaff)
          {
 
          pi1_cur_pred_mode += (u2_mbx << 2);
          pc_topPredMode = pi1_cur_pred_mode + ps_cur_mb_info->i1_offset;
          pi1_cur_pred_mode += (u1_topmb) ? 0: 4;
          }*/
 
         if(u1_top_available)
         {
             if(ps_top_mb->u1_mb_type == I_4x4_MB)
                 *(WORD32*)pi1_cur_pred_mode = *(WORD32*)pc_topPredMode;
             else
                 *(WORD32*)pi1_cur_pred_mode =
                                 (uc_useTopMB) ? DC_DC_DC_DC : NOT_VALID;
         }
         else
             *(WORD32*)pi1_cur_pred_mode = NOT_VALID;
         /* CHANGED CODE */
 
         /* CHANGED CODE */
 
         /*Left Related initialisations*/
         pi1_left_pred_mode = ps_dec->pi1_left_pred_mode;
         if(!u1_mbaff)
         {
 
             if(u1_left_available)
             {
 
                 if(ps_left_mb->u1_mb_type != I_4x4_MB)
                     *(WORD32*)pi1_left_pred_mode =
                                     (u2_use_left_mb_pack) ?
                                     DC_DC_DC_DC :
                                                             NOT_VALID;
 
             }
             else
             {
 
                 *(WORD32*)pi1_left_pred_mode = NOT_VALID;
             }
 
         }
         else
         {
             UWORD8 u1_curMbfld = ps_cur_mb_info->u1_mb_field_decodingflag;
             UWORD8 u1_leftMbfld = ps_left_mb->u1_mb_fld;
 
             if(u1_curMbfld ^ u1_leftMbfld)
             {
 
                 if(u1_topmb
                                 | ((u1_topmb == 0)
                                                 && ((ps_curmb - 1)->u1_mb_type
                                                                 != I_4x4_MB)))
                 {
                     if(u1_left_available)
                     {
                         if(ps_left_mb->u1_mb_type != I_4x4_MB)
                         {
                             if(CHECKBIT(u2_use_left_mb_pack,0) == 0)
                                 *(WORD32*)pi1_left_pred_mode = NOT_VALID;
                             else
                                 *(WORD32*)pi1_left_pred_mode = DC_DC_DC_DC;
                         }
                     }
                     else
                         *(WORD32*)pi1_left_pred_mode = NOT_VALID;
 
                     if(u1_curMbfld)
                     {
                         if(u1_left_available)
                         {
                             if((ps_left_mb + 1)->u1_mb_type != I_4x4_MB)
                             {
                                 if(u2_use_left_mb_pack >> 8)
                                     *(WORD32*)(pi1_left_pred_mode + 4) =
                                                     DC_DC_DC_DC;
                                 else
                                     *(WORD32*)(pi1_left_pred_mode + 4) =
                                                     NOT_VALID;
                             }
                         }
                         else
                             *(WORD32*)(pi1_left_pred_mode + 4) = NOT_VALID;
                         pi1_left_pred_mode[1] = pi1_left_pred_mode[2];
                         pi1_left_pred_mode[2] = pi1_left_pred_mode[4];
                         pi1_left_pred_mode[3] = pi1_left_pred_mode[6];
                         *(WORD32*)(pi1_left_pred_mode + 4) =
                                         *(WORD32*)pi1_left_pred_mode;
                     }
                     else
                     {
 
                         pi1_left_pred_mode[7] = pi1_left_pred_mode[3];
                         pi1_left_pred_mode[6] = pi1_left_pred_mode[3];
                         pi1_left_pred_mode[5] = pi1_left_pred_mode[2];
                         pi1_left_pred_mode[4] = pi1_left_pred_mode[2];
                         pi1_left_pred_mode[3] = pi1_left_pred_mode[1];
                         pi1_left_pred_mode[2] = pi1_left_pred_mode[1];
                         pi1_left_pred_mode[1] = pi1_left_pred_mode[0];
                     }
                 }
                 pi1_left_pred_mode += (u1_topmb) ? 0 : 4;
             }
             else
             {
 
                 pi1_left_pred_mode += (u1_topmb) ? 0 : 4;
                 if(u1_left_available)
                 {
 
                     if(ps_left_mb->u1_mb_type != I_4x4_MB)
                         *(WORD32*)pi1_left_pred_mode =
                                         (u2_use_left_mb_pack) ?
                                         DC_DC_DC_DC :
                                                                 NOT_VALID;
                 }
                 else
                     *(WORD32*)pi1_left_pred_mode = NOT_VALID;
             }
         }
         /* One time pointer initialisations*/
         pi2_y_coeff1 = pi2_y_coeff;
         pu1_top_left = pu1_ytop_left;
 
         /* Scan the sub-blocks in Raster Scan Order */
         for(u1_sub_mb_num = 0; u1_sub_mb_num < 16; u1_sub_mb_num++)
         {
             /* Align the size to multiple of 8, so that SIMD functions
                can read 64 bits at a time. Only 13 bytes are actaully used */
             UWORD8 au1_ngbr_pels[16];
 
             u1_sub_blk_x = u1_sub_mb_num & 0x3;
             u1_sub_blk_y = u1_sub_mb_num >> 2;
             i1_top_pred_mode = pi1_cur_pred_mode[u1_sub_blk_x];
             i1_left_pred_mode = pi1_left_pred_mode[u1_sub_blk_y];
             u1_use_top_right_mb = (!!CHECKBIT(ui2_top_rt_mask, u1_sub_mb_num));
 
             /*********** left subblock availability**********/
             if(u1_sub_blk_x)
                 u1_is_left_sub_block = 1;
             else
                 u1_is_left_sub_block =
                                 (u1_sub_blk_y < 2) ?
                                                 (CHECKBIT(u2_use_left_mb_pack,
                                                           0)) :
                                                 (u2_use_left_mb_pack >> 8);
 
             /* CHANGED CODE */
             if(u1_sub_blk_y)
                 u1_is_top_sub_block = 1;
 
             /* CHANGED CODE */
             /***************** Top *********************/
             if(ps_dec->u4_use_intrapred_line_copy == 1)
             {
 
                 if(u1_sub_blk_y)
                     pu1_top = pu1_luma_rec_buffer - ui_rec_width;
                 else
                     pu1_top = puc_top + (u1_sub_blk_x << 2);
             }
             else
             {
                 pu1_top = pu1_luma_rec_buffer - ui_rec_width;
             }
             /***************** Top Right *********************/
             pu1_top_right = pu1_top + 4;
             /***************** Top Left *********************/
             pu1_top_left = pu1_top - 1;
             /***************** Left *********************/
             pu1_left = pu1_luma_rec_buffer - 1;
             /* CHANGED CODE */
 
             /*---------------------------------------------------------------*/
             /* Calculation of Intra prediction mode                          */
             /*---------------------------------------------------------------*/
             i1_intra_pred = ((i1_left_pred_mode < 0) | (i1_top_pred_mode < 0)) ?
                             DC : MIN(i1_left_pred_mode, i1_top_pred_mode);
             {
                 UWORD8 u1_packed_modes = (u1_is_top_sub_block << 1)
                                 + u1_is_left_sub_block;
                 UWORD8 *pu1_intra_err_codes =
                                 (UWORD8 *)gau1_ih264d_intra_pred_err_code;
                 UWORD8 uc_b2b0 = ((u1_sub_mb_num & 4) >> 1) | (u1_sub_mb_num & 1);
                 UWORD8 uc_b3b1 = ((u1_sub_mb_num & 8) >> 2)
                                 | ((u1_sub_mb_num & 2) >> 1);
 
                 u1_cur_sub_block = (uc_b3b1 << 2) + uc_b2b0;
                 PROFILE_DISABLE_INTRA_PRED()
                 if(!pu1_prev_intra4x4_pred_mode_flag[u1_cur_sub_block])
                 {
                     i1_intra_pred =
                                     pu1_rem_intra4x4_pred_mode[u1_cur_sub_block]
                                                     + (pu1_rem_intra4x4_pred_mode[u1_cur_sub_block]
                                                                     >= i1_intra_pred);
                 }
                 i1_intra_pred = CLIP3(0, 8, i1_intra_pred);
                 {
                     UWORD8 u1_err_code = pu1_intra_err_codes[i1_intra_pred];
 
                     if((u1_err_code & u1_packed_modes) ^ u1_err_code)
                      {
                         i1_intra_pred = 0;
                         ps_dec->i4_error_code = ERROR_INTRAPRED;
                      }
 
                 }
             }
             {
                 /* Get neighbour pixels */
                 /* left pels */
                 if(u1_is_left_sub_block)
                 {
                     WORD32 i;
                     for(i = 0; i < 4; i++)
                         au1_ngbr_pels[4 - 1 - i] = pu1_left[i * ui_rec_width];
                 }
                 else
                 {
                     memset(au1_ngbr_pels, 0, 4);
                 }
 
                 /* top left pels */
                 au1_ngbr_pels[4] = *pu1_top_left;
 
                 /* top pels */
                 if(u1_is_top_sub_block)
                 {
                     memcpy(au1_ngbr_pels + 4 + 1, pu1_top, 4);
                 }
                 else
                 {
                     memset(au1_ngbr_pels + 4 + 1, 0, 4);
                 }
 
                 /* top right pels */
                 if(u1_use_top_right_mb)
                 {
                     memcpy(au1_ngbr_pels + 4 * 2 + 1, pu1_top_right, 4);
                 }
                 else if(u1_is_top_sub_block)
                 {
                     memset(au1_ngbr_pels + 4 * 2 + 1, au1_ngbr_pels[4 * 2], 4);
                 }
             }
             PROFILE_DISABLE_INTRA_PRED()
             ps_dec->apf_intra_pred_luma_4x4[i1_intra_pred](
                             au1_ngbr_pels, pu1_luma_rec_buffer, 1,
                             ui_rec_width,
                             ((u1_is_top_sub_block << 2) | u1_is_left_sub_block));
 
             /* CHANGED CODE */
             if(CHECKBIT(ui2_luma_csbp, u1_sub_mb_num))
             {
                 WORD16 ai2_tmp[16];
                 PROFILE_DISABLE_IQ_IT_RECON()
                 {
                     if(CHECKBIT(u4_luma_dc_only_csbp, u1_sub_mb_num))
                     {
                         ps_dec->pf_iquant_itrans_recon_luma_4x4_dc(
                                         pi2_y_coeff1,
                                         pu1_luma_rec_buffer,
                                         pu1_luma_rec_buffer,
                                         ui_rec_width,
                                         ui_rec_width,
                                         gau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qp_rem6],
                                         (UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[0],
                                         ps_cur_mb_info->u1_qp_div6, ai2_tmp, 0,
                                         NULL);
                     }
                     else
                     {
                         ps_dec->pf_iquant_itrans_recon_luma_4x4(
                                         pi2_y_coeff1,
                                         pu1_luma_rec_buffer,
                                         pu1_luma_rec_buffer,
                                         ui_rec_width,
                                         ui_rec_width,
                                         gau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qp_rem6],
                                         (UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[0],
                                         ps_cur_mb_info->u1_qp_div6, ai2_tmp, 0,
                                         NULL);
                     }
                 }
 
             }
 
             /*---------------------------------------------------------------*/
             /* Update sub block number                                       */
             /*---------------------------------------------------------------*/
             pi2_y_coeff1 += 16;
             pu1_luma_rec_buffer +=
                             (u1_sub_blk_x == 3) ? (ui_rec_width << 2) - 12 : 4;
             pu1_luma_pred_buffer +=
                             (u1_sub_blk_x == 3) ? (ui_pred_width << 2) - 12 : 4;
             /* CHANGED CODE */
             pi1_cur_pred_mode[u1_sub_blk_x] = i1_intra_pred;
             pi1_left_pred_mode[u1_sub_blk_y] = i1_intra_pred;
         }
     }
     else if((u1_mb_type == I_4x4_MB) && (ps_cur_mb_info->u1_tran_form8x8 == 1))
     {
         UWORD8 u1_is_left_sub_block, u1_is_top_sub_block = uc_useTopMB;
         UWORD8 u1_sub_blk_x, u1_sub_blk_y, u1_sub_mb_num;
         WORD8 i1_top_pred_mode;
         WORD8 i1_left_pred_mode;
         UWORD8 *pu1_top, *pu1_left, *pu1_top_left;
         WORD8 *pi1_cur_pred_mode, *pi1_left_pred_mode, *pc_topPredMode;
         UWORD16 ui2_left_pred_buf_width = 0xffff;
         WORD8 i1_intra_pred;
         UWORD8 *pu1_prev_intra4x4_pred_mode_flag = pu1_prev_intra4x4_pred_mode_data;
         UWORD8 *pu1_rem_intra4x4_pred_mode = pu1_prev_intra4x4_pred_mode_data + 4;
         WORD16 *pi2_y_coeff1;
         UWORD16 ui2_top_rt_mask;
         UWORD32 u4_4x4_left_offset = 0;
 
         /*--------------------------------------------------------------------*/
         /* 8x8 IntraPrediction                                                */
         /*--------------------------------------------------------------------*/
         /* Calculation of Top Right subblock mask                             */
         /*                                                                    */
         /* (a) Set it to default mask                                         */
         /*  [It has 0 for sublocks which will never have top-right sub block] */
         /*                                                                    */
         /* (b) If top MB is not available                                     */
         /*      Clear the bits of the first row sub blocks                    */
         /*                                                                    */
         /* (c) Set/Clear bit for top-right sublock of MB                      */
         /*  [5 sub-block in decoding order] based on TOP RIGHT MB availablity */
         /*                                                                    */
         /* ui2_top_rt_mask: marks availibility of top right(neighbour)         */
         /* in the 8x8 Block ordering                                          */
         /*                                                                    */
         /*      tr0   tr1                                                     */
         /*   0    1   tr3                                                     */
         /*   2    3                                                           */
         /*                                                                    */
         /*  Top rights for 0 is in top MB                                     */
         /*  top right of 1 will be in top right MB                            */
         /*  top right of 3 in right MB and hence not available                */
         /*  This corresponds to ui2_top_rt_mask  having default value 0x4      */
         /*--------------------------------------------------------------------*/
 
         ui2_top_rt_mask = (u1_use_top_right_mb << 1) | (0x4);
 
         if(uc_useTopMB)
         {
             ui2_top_rt_mask |= 0x1;
         }
 
         /* Top Related initialisations */
         pi1_cur_pred_mode = ps_cur_mb_info->ps_curmb->pi1_intrapredmodes;
         pc_topPredMode = ps_cur_mb_info->ps_top_mb->pi1_intrapredmodes;
         /*
          if(u1_mbaff)
          {
          pi1_cur_pred_mode += (u2_mbx << 2);
          pc_topPredMode = pi1_cur_pred_mode + ps_cur_mb_info->i1_offset;
          pi1_cur_pred_mode += (u1_topmb) ? 0: 4;
          }
          */
         if(u1_top_available)
         {
             if(ps_top_mb->u1_mb_type == I_4x4_MB)
             {
                 *(WORD32*)pi1_cur_pred_mode = *(WORD32*)pc_topPredMode;
             }
             else
             {
                 *(WORD32*)pi1_cur_pred_mode =
                                 (uc_useTopMB) ? DC_DC_DC_DC : NOT_VALID;
             }
         }
         else
         {
             *(WORD32*)pi1_cur_pred_mode = NOT_VALID;
         }
 
         pu1_top = puc_top - 8;
 
         /*Left Related initialisations*/
         pi1_left_pred_mode = ps_dec->pi1_left_pred_mode;
 
         if(!u1_mbaff)
         {
             if(u1_left_available)
             {
                 if(ps_left_mb->u1_mb_type != I_4x4_MB)
                 {
                     *(WORD32*)pi1_left_pred_mode =
                                     (u2_use_left_mb_pack) ?
                                     DC_DC_DC_DC :
                                                             NOT_VALID;
                 }
             }
             else
             {
                 *(WORD32*)pi1_left_pred_mode = NOT_VALID;
             }
         }
         else
         {
             UWORD8 u1_curMbfld = ps_cur_mb_info->u1_mb_field_decodingflag;
 
             UWORD8 u1_leftMbfld = ps_left_mb->u1_mb_fld;
 
             if((!u1_curMbfld) && (u1_leftMbfld))
             {
                 u4_4x4_left_offset = 1;
             }
 
             if(u1_curMbfld ^ u1_leftMbfld)
             {
 
                 if(u1_topmb
                                 | ((u1_topmb == 0)
                                                 && ((ps_curmb - 1)->u1_mb_type
                                                                 != I_4x4_MB)))
 
                 {
                     if(u1_left_available)
                     {
                         if(ps_left_mb->u1_mb_type != I_4x4_MB)
                         {
                             if(CHECKBIT(u2_use_left_mb_pack,0) == 0)
                             {
                                 *(WORD32*)pi1_left_pred_mode = NOT_VALID;
                             }
                             else
                             {
                                 *(WORD32*)pi1_left_pred_mode = DC_DC_DC_DC;
                             }
                         }
                     }
                     else
                     {
                         *(WORD32*)pi1_left_pred_mode = NOT_VALID;
                     }
 
                     if(u1_curMbfld)
                     {
                         if(u1_left_available)
                         {
                             if((ps_left_mb + 1)->u1_mb_type != I_4x4_MB)
                             {
                                 if(u2_use_left_mb_pack >> 8)
                                 {
                                     *(WORD32*)(pi1_left_pred_mode + 4) =
                                                     DC_DC_DC_DC;
                                 }
                                 else
                                 {
                                     *(WORD32*)(pi1_left_pred_mode + 4) =
                                                     NOT_VALID;
                                 }
                             }
                         }
                         else
                         {
                             *(WORD32*)(pi1_left_pred_mode + 4) = NOT_VALID;
                         }
 
                         pi1_left_pred_mode[1] = pi1_left_pred_mode[2];
                         pi1_left_pred_mode[2] = pi1_left_pred_mode[4];
                         pi1_left_pred_mode[3] = pi1_left_pred_mode[6];
                         *(WORD32*)(pi1_left_pred_mode + 4) =
                                         *(WORD32*)pi1_left_pred_mode;
                     }
                     else
                     {
                         pi1_left_pred_mode[7] = pi1_left_pred_mode[3];
                         pi1_left_pred_mode[6] = pi1_left_pred_mode[3];
                         pi1_left_pred_mode[5] = pi1_left_pred_mode[2];
                         pi1_left_pred_mode[4] = pi1_left_pred_mode[2];
                         pi1_left_pred_mode[3] = pi1_left_pred_mode[1];
                         pi1_left_pred_mode[2] = pi1_left_pred_mode[1];
                         pi1_left_pred_mode[1] = pi1_left_pred_mode[0];
                     }
                 }
                 pi1_left_pred_mode += (u1_topmb) ? 0 : 4;
             }
             else
             {
                 pi1_left_pred_mode += (u1_topmb) ? 0 : 4;
 
                 if(u1_left_available)
                 {
                     if(ps_left_mb->u1_mb_type != I_4x4_MB)
                     {
                         *(WORD32*)pi1_left_pred_mode =
                                         (u2_use_left_mb_pack) ?
                                         DC_DC_DC_DC :
                                                                 NOT_VALID;
                     }
                 }
                 else
                 {
                     *(WORD32*)pi1_left_pred_mode = NOT_VALID;
                 }
             }
         }
 
         /* One time pointer initialisations*/
         pi2_y_coeff1 = pi2_y_coeff;
 
         if(u1_use_top_left_mb)
         {
             pu1_top_left = pu1_ytop_left;
         }
         else
         {
             pu1_top_left = NULL;
         }
 
         /* Scan the sub-blocks in Raster Scan Order */
         for(u1_sub_mb_num = 0; u1_sub_mb_num < 4; u1_sub_mb_num++)
         {
             u1_sub_blk_x = (u1_sub_mb_num & 0x1);
             u1_sub_blk_y = (u1_sub_mb_num >> 1);
             i1_top_pred_mode = pi1_cur_pred_mode[u1_sub_blk_x << 1];
             i1_left_pred_mode = pi1_left_pred_mode[u1_sub_blk_y << 1];
 
             if(2 == u1_sub_mb_num)
             {
                 i1_left_pred_mode = pi1_left_pred_mode[(u1_sub_blk_y << 1)
                                 + u4_4x4_left_offset];
             }
 
             u1_use_top_right_mb = (!!CHECKBIT(ui2_top_rt_mask, u1_sub_mb_num));
 
             /*********** left subblock availability**********/
             if(u1_sub_blk_x)
             {
                 u1_is_left_sub_block = 1;
             }
             else
             {
                 u1_is_left_sub_block =
                                 (u1_sub_blk_y < 1) ?
                                                 (CHECKBIT(u2_use_left_mb_pack,
                                                           0)) :
                                                 (u2_use_left_mb_pack >> 8);
             }
 
             /***************** Top *********************/
             if(u1_sub_blk_y)
             {
                 u1_is_top_sub_block = 1;
                 // sushant
                 pu1_top = /*pu1_luma_pred_buffer*/pu1_luma_rec_buffer - ui_rec_width;
             }
             else
             {
                 pu1_top += 8;
             }
 
             /***************** Left *********************/
             if((u1_sub_blk_x) | (u4_num_pmbair != 0))
             {
                 // sushant
                 pu1_left = /*pu1_luma_pred_buffer*/pu1_luma_rec_buffer - 1;
                 ui2_left_pred_buf_width = ui_rec_width;
             }
             else
             {
                 pu1_left = pu1_yleft;
                 pu1_yleft += (ui_rec_width << 3);
                 ui2_left_pred_buf_width = ui_rec_width;
             }
 
             /***************** Top Left *********************/
             if(u1_sub_mb_num)
             {
                 pu1_top_left = (u1_sub_blk_x) ?
                                 pu1_top - 1 : pu1_left - ui_rec_width;
 
                 if((u1_sub_blk_x && (!u1_is_top_sub_block))
                                 || ((!u1_sub_blk_x) && (!u1_is_left_sub_block)))
                 {
                     pu1_top_left = NULL;
                 }
             }
 
             /*---------------------------------------------------------------*/
             /* Calculation of Intra prediction mode                          */
             /*---------------------------------------------------------------*/
             i1_intra_pred = ((i1_left_pred_mode < 0) | (i1_top_pred_mode < 0)) ?
                             DC : MIN(i1_left_pred_mode, i1_top_pred_mode);
             {
                 UWORD8 u1_packed_modes = (u1_is_top_sub_block << 1)
                                 + u1_is_left_sub_block;
                 UWORD8 *pu1_intra_err_codes =
                                 (UWORD8 *)gau1_ih264d_intra_pred_err_code;
 
                 /********************************************************************/
                 /* Same intra4x4_pred_mode array is filled with intra4x4_pred_mode  */
                 /* for a MB with 8x8 intrapredicition                               */
                 /********************************************************************/
                 PROFILE_DISABLE_INTRA_PRED()
                 if(!pu1_prev_intra4x4_pred_mode_flag[u1_sub_mb_num])
                 {
                     i1_intra_pred = pu1_rem_intra4x4_pred_mode[u1_sub_mb_num]
                                     + (pu1_rem_intra4x4_pred_mode[u1_sub_mb_num]
                                                     >= i1_intra_pred);
                 }
                 i1_intra_pred = CLIP3(0, 8, i1_intra_pred);
                 {
                     UWORD8 u1_err_code = pu1_intra_err_codes[i1_intra_pred];
 
                     if((u1_err_code & u1_packed_modes) ^ u1_err_code)
                     {
                         i1_intra_pred = 0;
                         ps_dec->i4_error_code = ERROR_INTRAPRED;
                     }
                 }
             }
 
             {
                 /* Align the size to multiple of 8, so that SIMD functions
                 can read 64 bits at a time. Only 25 bytes are actaully used */
-                UWORD8 au1_ngbr_pels[32];
+                UWORD8 au1_ngbr_pels[32] = {0};
                 WORD32 ngbr_avail;
                 ngbr_avail = u1_is_left_sub_block << 0;
                 ngbr_avail |= u1_is_top_sub_block << 2;
 
                 if(pu1_top_left)
                     ngbr_avail |= 1 << 1;
 
                 ngbr_avail |= u1_use_top_right_mb << 3;
                 PROFILE_DISABLE_INTRA_PRED()
                 {
                     ps_dec->pf_intra_pred_ref_filtering(pu1_left, pu1_top_left,
                                                         pu1_top, au1_ngbr_pels,
                                                         ui2_left_pred_buf_width,
                                                         ngbr_avail);
 
                     ps_dec->apf_intra_pred_luma_8x8[i1_intra_pred](
                                     au1_ngbr_pels, pu1_luma_rec_buffer, 1,
                                     ui_rec_width,
                                     ((u1_is_top_sub_block << 2) | u1_is_left_sub_block));
                 }
             }
 
             /* Inverse Transform and Reconstruction */
             if(CHECKBIT(ps_cur_mb_info->u1_cbp, u1_sub_mb_num))
             {
                 WORD16 *pi2_scale_matrix_ptr;
                 WORD16 ai2_tmp[64];
 
                 pi2_scale_matrix_ptr =
                                 ps_dec->s_high_profile.i2_scalinglist8x8[0];
                 PROFILE_DISABLE_IQ_IT_RECON()
                 {
                     if(CHECKBIT(u4_luma_dc_only_cbp, u1_sub_mb_num))
                     {
                         ps_dec->pf_iquant_itrans_recon_luma_8x8_dc(
                                         pi2_y_coeff1,
                                         pu1_luma_rec_buffer,
                                         pu1_luma_rec_buffer,
                                         ui_rec_width,
                                         ui_rec_width,
                                         gau1_ih264d_dequant8x8_cavlc[ps_cur_mb_info->u1_qp_rem6],
                                         (UWORD16 *)pi2_scale_matrix_ptr,
                                         ps_cur_mb_info->u1_qp_div6, ai2_tmp, 0,
                                         NULL);
                     }
                     else
                     {
                         ps_dec->pf_iquant_itrans_recon_luma_8x8(
                                         pi2_y_coeff1,
                                         pu1_luma_rec_buffer,
                                         pu1_luma_rec_buffer,
                                         ui_rec_width,
                                         ui_rec_width,
                                         gau1_ih264d_dequant8x8_cavlc[ps_cur_mb_info->u1_qp_rem6],
                                         (UWORD16 *)pi2_scale_matrix_ptr,
                                         ps_cur_mb_info->u1_qp_div6, ai2_tmp, 0,
                                         NULL);
                     }
                 }
 
             }
 
             /*---------------------------------------------------------------*/
             /* Update sub block number                                       */
             /*---------------------------------------------------------------*/
             pi2_y_coeff1 += 64;
 
             pu1_luma_rec_buffer +=
                             (u1_sub_blk_x == 1) ?
                                             (ui_rec_width << 3) - (8 * 1) : 8;
 
             /*---------------------------------------------------------------*/
             /* Pred mode filled in terms of 4x4 block so replicated in 2     */
             /* locations.                                                    */
             /*---------------------------------------------------------------*/
             pi1_cur_pred_mode[u1_sub_blk_x << 1] = i1_intra_pred;
             pi1_cur_pred_mode[(u1_sub_blk_x << 1) + 1] = i1_intra_pred;
             pi1_left_pred_mode[u1_sub_blk_y << 1] = i1_intra_pred;
             pi1_left_pred_mode[(u1_sub_blk_y << 1) + 1] = i1_intra_pred;
         }
     }
     /* Decode Chroma Block */
     ih264d_unpack_chroma_coeff4x4_mb(ps_dec,
                                      ps_cur_mb_info);
     /*--------------------------------------------------------------------*/
     /* Chroma Blocks decoding                                             */
     /*--------------------------------------------------------------------*/
     {
         UWORD8 u1_intra_chrom_pred_mode;
         UWORD8 u1_chroma_cbp = (UWORD8)(ps_cur_mb_info->u1_cbp >> 4);
 
         /*--------------------------------------------------------------------*/
         /* Perform Chroma intra prediction                                    */
         /*--------------------------------------------------------------------*/
 
         u1_intra_chrom_pred_mode = CHROMA_TO_LUMA_INTRA_MODE(
                         ps_cur_mb_info->u1_chroma_pred_mode);
 
         {
             UWORD8 u1_packed_modes = (u1_top_available << 1)
                             + u1_left_available;
             UWORD8 u1_err_code =
                             (u1_intra_chrom_pred_mode & 1) ?
                                             u1_intra_chrom_pred_mode :
                                             (u1_intra_chrom_pred_mode ^ 2);
             if((u1_err_code & u1_packed_modes) ^ u1_err_code)
             {
                 u1_intra_chrom_pred_mode = 0;
                 ps_dec->i4_error_code = ERROR_INTRAPRED;
             }
         }
 
         /* CHANGED CODE */
         if(u1_chroma_cbp != CBPC_ALLZERO)
         {
             UWORD16 u2_chroma_csbp =
                             (u1_chroma_cbp == CBPC_ACZERO) ?
                                             0 : ps_cur_mb_info->u2_chroma_csbp;
             UWORD32 u4_scale_u;
             UWORD32 u4_scale_v;
 
             {
                 UWORD16 au2_ngbr_pels[33];
                 UWORD8 *pu1_ngbr_pels = (UWORD8 *)au2_ngbr_pels;
                 UWORD16 *pu2_left_uv;
                 UWORD16 *pu2_topleft_uv;
                 WORD32 use_left1 = (u2_use_left_mb_pack & 0x0ff);
                 WORD32 use_left2 = (u2_use_left_mb_pack & 0xff00) >> 8;
 
                 pu2_left_uv = (UWORD16 *)pu1_uleft;
                 pu2_topleft_uv = (UWORD16 *)pu1_u_top_left;
                 /* Get neighbour pixels */
                 /* left pels */
                 if(u2_use_left_mb_pack)
                 {
                     WORD32 i;
                     if(use_left1)
                     {
                         for(i = 0; i < 4; i++)
                             au2_ngbr_pels[8 - 1 - i] = pu2_left_uv[i
                                             * u4_recwidth_cr / YUV420SP_FACTOR];
                     }
                     else
                     {
                         memset(au2_ngbr_pels + 4, 0, 4 * sizeof(UWORD16));
                     }
 
                     if(use_left2)
                     {
                         for(i = 4; i < 8; i++)
                             au2_ngbr_pels[8 - 1 - i] = pu2_left_uv[i
                                             * u4_recwidth_cr / YUV420SP_FACTOR];
                     }
                     else
                     {
                         memset(au2_ngbr_pels, 0, 4 * sizeof(UWORD16));
                     }
                 }
                 else
                 {
                     memset(au2_ngbr_pels, 0, 8 * sizeof(UWORD16));
                 }
 
                 /* top left pels */
                 au2_ngbr_pels[8] = *pu2_topleft_uv;
 
                 /* top pels */
                 if(uc_useTopMB)
                 {
                     memcpy(au2_ngbr_pels + 8 + 1, pu1_top_u,
                            8 * sizeof(UWORD16));
                 }
                 else
                 {
                     memset(au2_ngbr_pels + 8 + 1, 0, 8 * sizeof(UWORD16));
                 }
 
                 PROFILE_DISABLE_INTRA_PRED()
                 ps_dec->apf_intra_pred_chroma[u1_intra_chrom_pred_mode](
                                 pu1_ngbr_pels,
                                 pu1_mb_cb_rei1_buffer,
                                 1,
                                 u4_recwidth_cr,
                                 ((uc_useTopMB << 2) | (use_left2 << 4)
                                                 | use_left1));
             }
             u4_scale_u = ps_cur_mb_info->u1_qpc_div6;
             u4_scale_v = ps_cur_mb_info->u1_qpcr_div6;
             pi2_y_coeff = ps_dec->pi2_coeff_data;
 
             {
                 UWORD32 i;
                 WORD16 ai2_tmp[16];
                 for(i = 0; i < 4; i++)
                 {
                     WORD16 *pi2_level = pi2_y_coeff + (i << 4);
                     UWORD8 *pu1_pred_sblk = pu1_mb_cb_rei1_buffer
                                     + ((i & 0x1) * BLK_SIZE * YUV420SP_FACTOR)
                                     + (i >> 1) * (u4_recwidth_cr << 2);
                     PROFILE_DISABLE_IQ_IT_RECON()
                     {
                         if(CHECKBIT(u2_chroma_csbp, i))
                         {
                             ps_dec->pf_iquant_itrans_recon_chroma_4x4(
                                             pi2_level,
                                             pu1_pred_sblk,
                                             pu1_pred_sblk,
                                             u4_recwidth_cr,
                                             u4_recwidth_cr,
                                             gau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qpc_rem6],
                                             (UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[1],
                                             u4_scale_u, ai2_tmp, pi2_level);
                         }
                         else if(pi2_level[0] != 0)
                         {
                             ps_dec->pf_iquant_itrans_recon_chroma_4x4_dc(
                                             pi2_level,
                                             pu1_pred_sblk,
                                             pu1_pred_sblk,
                                             u4_recwidth_cr,
                                             u4_recwidth_cr,
                                             gau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qpc_rem6],
                                             (UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[1],
                                             u4_scale_u, ai2_tmp, pi2_level);
                         }
                     }
 
                 }
             }
 
             pi2_y_coeff += MB_CHROM_SIZE;
             u2_chroma_csbp = u2_chroma_csbp >> 4;
             {
                 UWORD32 i;
                 WORD16 ai2_tmp[16];
                 for(i = 0; i < 4; i++)
                 {
                     WORD16 *pi2_level = pi2_y_coeff + (i << 4);
                     UWORD8 *pu1_pred_sblk = pu1_mb_cb_rei1_buffer + 1
                                     + ((i & 0x1) * BLK_SIZE * YUV420SP_FACTOR)
                                     + (i >> 1) * (u4_recwidth_cr << 2);
                     PROFILE_DISABLE_IQ_IT_RECON()
                     {
                         if(CHECKBIT(u2_chroma_csbp, i))
                         {
                             ps_dec->pf_iquant_itrans_recon_chroma_4x4(
                                             pi2_level,
                                             pu1_pred_sblk,
                                             pu1_pred_sblk,
                                             u4_recwidth_cr,
                                             u4_recwidth_cr,
                                             gau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qpcr_rem6],
                                             (UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[2],
                                             u4_scale_v, ai2_tmp, pi2_level);
                         }
                         else if(pi2_level[0] != 0)
                         {
                             ps_dec->pf_iquant_itrans_recon_chroma_4x4_dc(
                                             pi2_level,
                                             pu1_pred_sblk,
                                             pu1_pred_sblk,
                                             u4_recwidth_cr,
                                             u4_recwidth_cr,
                                             gau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qpcr_rem6],
                                             (UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[2],
                                             u4_scale_v, ai2_tmp, pi2_level);
                         }
                     }
                 }
             }
 
         }
         else
         {
             /* If no inverse transform is needed, pass recon buffer pointer */
             /* to Intraprediction module instead of pred buffer pointer     */
             {
                 UWORD16 au2_ngbr_pels[33];
                 UWORD8 *pu1_ngbr_pels = (UWORD8 *)au2_ngbr_pels;
                 UWORD16 *pu2_left_uv;
                 UWORD16 *pu2_topleft_uv;
                 WORD32 use_left1 = (u2_use_left_mb_pack & 0x0ff);
                 WORD32 use_left2 = (u2_use_left_mb_pack & 0xff00) >> 8;
 
                 pu2_topleft_uv = (UWORD16 *)pu1_u_top_left;
                 pu2_left_uv = (UWORD16 *)pu1_uleft;
 
                 /* Get neighbour pixels */
                 /* left pels */
                 if(u2_use_left_mb_pack)
                 {
                     WORD32 i;
                     if(use_left1)
                     {
                         for(i = 0; i < 4; i++)
                             au2_ngbr_pels[8 - 1 - i] = pu2_left_uv[i
                                             * u4_recwidth_cr / YUV420SP_FACTOR];
                     }
                     else
                     {
                         memset(au2_ngbr_pels + 4, 0, 4 * sizeof(UWORD16));
                     }
 
                     if(use_left2)
                     {
                         for(i = 4; i < 8; i++)
                             au2_ngbr_pels[8 - 1 - i] = pu2_left_uv[i
                                             * u4_recwidth_cr / YUV420SP_FACTOR];
                     }
                     else
                     {
                         memset(au2_ngbr_pels, 0, 4 * sizeof(UWORD16));
                     }
 
                 }
                 else
                 {
                     memset(au2_ngbr_pels, 0, 8 * sizeof(UWORD16));
                 }
 
                 /* top left pels */
                 au2_ngbr_pels[8] = *pu2_topleft_uv;
 
                 /* top pels */
                 if(uc_useTopMB)
                 {
                     memcpy(au2_ngbr_pels + 8 + 1, pu1_top_u,
                            8 * sizeof(UWORD16));
                 }
                 else
                 {
                     memset(au2_ngbr_pels + 8 + 1, 0, 8 * sizeof(UWORD16));
                 }
 
                 PROFILE_DISABLE_INTRA_PRED()
                 ps_dec->apf_intra_pred_chroma[u1_intra_chrom_pred_mode](
                                 pu1_ngbr_pels,
                                 pu1_mb_cb_rei1_buffer,
                                 1,
                                 u4_recwidth_cr,
                                 ((uc_useTopMB << 2) | (use_left2 << 4)
                                                 | use_left1));
             }
 
         }
 
     }
     return OK;
 }
diff --git a/decoder/ih264d_quant_scaling.c b/decoder/ih264d_quant_scaling.c
index fa9aeb5..1d48907 100644
--- a/decoder/ih264d_quant_scaling.c
+++ b/decoder/ih264d_quant_scaling.c
@@ -74,201 +74,209 @@ void ih264d_scaling_list(WORD16 *pi2_scaling_list,
     }
 }
 
-void ih264d_form_default_scaling_matrix(dec_struct_t *ps_dec)
+WORD32 ih264d_form_default_scaling_matrix(dec_struct_t *ps_dec)
 {
 
     /*************************************************************************/
     /* perform the inverse scanning for the frame and field scaling matrices */
     /*************************************************************************/
     {
         UWORD8 *pu1_inv_scan;
         WORD32 i4_i, i4_j;
 
         pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan;
 
         /* for all 4x4 matrices */
         for(i4_i = 0; i4_i < 6; i4_i++)
         {
             for(i4_j = 0; i4_j < 16; i4_j++)
             {
                 ps_dec->s_high_profile.i2_scalinglist4x4[i4_i][pu1_inv_scan[i4_j]] =
                                 16;
 
             }
         }
 
         /* for all 8x8 matrices */
         for(i4_i = 0; i4_i < 2; i4_i++)
         {
             for(i4_j = 0; i4_j < 64; i4_j++)
             {
                 ps_dec->s_high_profile.i2_scalinglist8x8[i4_i][gau1_ih264d_inv_scan_prog8x8_cabac[i4_j]] =
                                 16;
 
             }
         }
     }
+    return OK;
 }
 
-void ih264d_form_scaling_matrix_picture(dec_seq_params_t *ps_seq,
-                                        dec_pic_params_t *ps_pic,
-                                        dec_struct_t *ps_dec)
+WORD32 ih264d_form_scaling_matrix_picture(dec_seq_params_t *ps_seq,
+                                          dec_pic_params_t *ps_pic,
+                                          dec_struct_t *ps_dec)
 {
     /* default scaling matrices */
     WORD32 i4_i;
 
     /* check the SPS first */
     if(ps_seq->i4_seq_scaling_matrix_present_flag)
     {
         for(i4_i = 0; i4_i < 8; i4_i++)
         {
             if(i4_i < 6)
             {
                 /* fall-back rule A */
                 if(!ps_seq->u1_seq_scaling_list_present_flag[i4_i])
                 {
                     if((i4_i == 0) || (i4_i == 3))
                     {
                         ps_dec->s_high_profile.pi2_scale_mat[i4_i] =
                                         (i4_i == 0) ? (WORD16 *)(gai2_ih264d_default_intra4x4) : (WORD16 *)(gai2_ih264d_default_inter4x4);
                     }
                     else
                     {
                         ps_dec->s_high_profile.pi2_scale_mat[i4_i] =
                                         ps_dec->s_high_profile.pi2_scale_mat[i4_i
                                                         - 1];
                     }
                 }
                 else
                 {
                     if(ps_seq->u1_use_default_scaling_matrix_flag[i4_i])
                     {
                         ps_dec->s_high_profile.pi2_scale_mat[i4_i] =
                                         (i4_i < 3) ? (WORD16 *)(gai2_ih264d_default_intra4x4) : (WORD16 *)(gai2_ih264d_default_inter4x4);
                     }
                     else
                     {
                         ps_dec->s_high_profile.pi2_scale_mat[i4_i] =
                                         ps_seq->i2_scalinglist4x4[i4_i];
                     }
                 }
 
             }
             else
             {
                 /* fall-back rule A */
                 if((!ps_seq->u1_seq_scaling_list_present_flag[i4_i])
                                 || (ps_seq->u1_use_default_scaling_matrix_flag[i4_i]))
                 {
                     ps_dec->s_high_profile.pi2_scale_mat[i4_i] =
                                     (i4_i == 6) ? ((WORD16*)gai2_ih264d_default_intra8x8) : ((WORD16*)gai2_ih264d_default_inter8x8);
                 }
                 else
                 {
                     ps_dec->s_high_profile.pi2_scale_mat[i4_i] =
                                     ps_seq->i2_scalinglist8x8[i4_i - 6];
                 }
             }
         }
     }
 
     /* checking for the PPS */
 
     if(ps_pic->i4_pic_scaling_matrix_present_flag)
     {
         for(i4_i = 0; i4_i < 8; i4_i++)
         {
             if(i4_i < 6)
             {
                 /* fall back rule B */
                 if(!ps_pic->u1_pic_scaling_list_present_flag[i4_i])
                 {
                     if((i4_i == 0) || (i4_i == 3))
                     {
                         if(!ps_seq->i4_seq_scaling_matrix_present_flag)
                         {
                             ps_dec->s_high_profile.pi2_scale_mat[i4_i] =
                                             (i4_i == 0) ? (WORD16 *)(gai2_ih264d_default_intra4x4) : (WORD16 *)(gai2_ih264d_default_inter4x4);
                         }
                     }
                     else
                     {
                         ps_dec->s_high_profile.pi2_scale_mat[i4_i] =
                                         ps_dec->s_high_profile.pi2_scale_mat[i4_i
                                                         - 1];
                     }
                 }
                 else
                 {
                     if(ps_pic->u1_pic_use_default_scaling_matrix_flag[i4_i])
                     {
                         ps_dec->s_high_profile.pi2_scale_mat[i4_i] =
                                         (i4_i < 3) ? (WORD16 *)(gai2_ih264d_default_intra4x4) : (WORD16 *)(gai2_ih264d_default_inter4x4);
                     }
                     else
                     {
                         ps_dec->s_high_profile.pi2_scale_mat[i4_i] =
                                         ps_pic->i2_pic_scalinglist4x4[i4_i];
                     }
                 }
             }
             else
             {
                 if(!ps_pic->u1_pic_scaling_list_present_flag[i4_i])
                 {
-                    if(!ps_seq->u1_seq_scaling_list_present_flag[i4_i])
+                    if(!ps_seq->i4_seq_scaling_matrix_present_flag)
                     {
                         ps_dec->s_high_profile.pi2_scale_mat[i4_i] =
                                         (i4_i == 6) ? ((WORD16*)gai2_ih264d_default_intra8x8) : ((WORD16*)gai2_ih264d_default_inter8x8);
                     }
                 }
                 else
                 {
                     if(ps_pic->u1_pic_use_default_scaling_matrix_flag[i4_i])
                     {
                         ps_dec->s_high_profile.pi2_scale_mat[i4_i] =
                                         (i4_i == 6) ? (WORD16 *)(gai2_ih264d_default_intra8x8) : (WORD16 *)(gai2_ih264d_default_inter8x8);
                     }
                     else
                     {
                         ps_dec->s_high_profile.pi2_scale_mat[i4_i] =
                                         ps_pic->i2_pic_scalinglist8x8[i4_i - 6];
                     }
                 }
             }
         }
     }
 
     /*************************************************************************/
     /* perform the inverse scanning for the frame and field scaling matrices */
     /*************************************************************************/
     {
         UWORD8 *pu1_inv_scan_4x4;
         WORD32 i4_i, i4_j;
 
         pu1_inv_scan_4x4 = (UWORD8 *)gau1_ih264d_inv_scan;
 
         /* for all 4x4 matrices */
         for(i4_i = 0; i4_i < 6; i4_i++)
         {
+            if(ps_dec->s_high_profile.pi2_scale_mat[i4_i] == NULL)
+                return ERROR_CORRUPTED_SLICE;
+
             for(i4_j = 0; i4_j < 16; i4_j++)
             {
                 ps_dec->s_high_profile.i2_scalinglist4x4[i4_i][pu1_inv_scan_4x4[i4_j]] =
                                 ps_dec->s_high_profile.pi2_scale_mat[i4_i][i4_j];
 
             }
         }
 
         /* for all 8x8 matrices */
         for(i4_i = 0; i4_i < 2; i4_i++)
         {
+            if(ps_dec->s_high_profile.pi2_scale_mat[i4_i + 6] == NULL)
+                return ERROR_CORRUPTED_SLICE;
+
             for(i4_j = 0; i4_j < 64; i4_j++)
             {
                 ps_dec->s_high_profile.i2_scalinglist8x8[i4_i][gau1_ih264d_inv_scan_prog8x8_cabac[i4_j]] =
                                 ps_dec->s_high_profile.pi2_scale_mat[i4_i + 6][i4_j];
 
             }
         }
     }
+    return OK;
 }
 
diff --git a/decoder/ih264d_quant_scaling.h b/decoder/ih264d_quant_scaling.h
index d9bd377..c714c34 100644
--- a/decoder/ih264d_quant_scaling.h
+++ b/decoder/ih264d_quant_scaling.h
@@ -25,13 +25,13 @@ void ih264d_scaling_list(WORD16 *pi2_scaling_list,
                   dec_bit_stream_t *ps_bitstrm);
 
 
-void ih264d_form_scaling_matrix_picture(dec_seq_params_t *ps_seq,
-                                 dec_pic_params_t *ps_pic,
-                                 dec_struct_t *ps_dec);
+WORD32 ih264d_form_scaling_matrix_picture(dec_seq_params_t *ps_seq,
+                                          dec_pic_params_t *ps_pic,
+                                          dec_struct_t *ps_dec);
 
-void ih264d_form_default_scaling_matrix(dec_struct_t *ps_dec);
+WORD32 ih264d_form_default_scaling_matrix(dec_struct_t *ps_dec);
 
 
 
 
 #endif
diff --git a/decoder/ih264d_sei.c b/decoder/ih264d_sei.c
index 098a1f3..39be782 100644
--- a/decoder/ih264d_sei.c
+++ b/decoder/ih264d_sei.c
@@ -126,101 +126,105 @@ WORD32 ih264d_parse_buffering_period(buf_period_t *ps_buf_prd,
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : ih264d_parse_pic_timing                                         */
 /*                                                                           */
 /*  Description   : This function parses SEI message pic_timing              */
 /*  Inputs        : ps_bitstrm    Bitstream                                */
 /*                  ps_dec          Poniter decoder context                  */
 /*                  ui4_payload_size pay load i4_size                           */
 /*  Globals       : None                                                     */
 /*  Processing    : Parses SEI payload picture timing                        */
 /*  Outputs       : None                                                     */
 /*  Returns       : None                                                     */
 /*                                                                           */
 /*  Issues        : Not implemented fully                                    */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         06 05 2002   NS              Draft                                */
 /*                                                                           */
 /*****************************************************************************/
 WORD32 ih264d_parse_pic_timing(dec_bit_stream_t *ps_bitstrm,
                                dec_struct_t *ps_dec,
                                UWORD32 ui4_payload_size)
 {
     sei *ps_sei;
     vui_t *ps_vu4;
     UWORD8 u1_cpb_dpb_present;
     UWORD8 u1_pic_struct_present_flag;
     UWORD32 u4_start_offset, u4_bits_consumed;
     UWORD8 u1_cpb_removal_delay_length, u1_dpb_output_delay_length;
 
     ps_sei = (sei *)ps_dec->ps_sei;
     ps_vu4 = &ps_dec->ps_cur_sps->s_vui;
 
     u1_cpb_dpb_present = ps_vu4->u1_vcl_hrd_params_present
                     + ps_vu4->u1_nal_hrd_params_present;
 
     if(ps_vu4->u1_vcl_hrd_params_present)
     {
         u1_cpb_removal_delay_length =
                         ps_vu4->s_vcl_hrd.u1_cpb_removal_delay_length;
         u1_dpb_output_delay_length =
                         ps_vu4->s_vcl_hrd.u1_dpb_output_delay_length;
     }
     else if(ps_vu4->u1_nal_hrd_params_present)
     {
         u1_cpb_removal_delay_length =
                         ps_vu4->s_nal_hrd.u1_cpb_removal_delay_length;
         u1_dpb_output_delay_length =
                         ps_vu4->s_nal_hrd.u1_dpb_output_delay_length;
     }
     else
     {
         u1_cpb_removal_delay_length = 24;
         u1_dpb_output_delay_length = 24;
 
     }
 
     u4_start_offset = ps_bitstrm->u4_ofst;
     if(u1_cpb_dpb_present)
     {
         ih264d_get_bits_h264(ps_bitstrm, u1_cpb_removal_delay_length);
         ih264d_get_bits_h264(ps_bitstrm, u1_dpb_output_delay_length);
     }
 
     u1_pic_struct_present_flag = ps_vu4->u1_pic_struct_present_flag;
     if(u1_pic_struct_present_flag)
     {
         ps_sei->u1_pic_struct = ih264d_get_bits_h264(ps_bitstrm, 4);
         ps_dec->u1_pic_struct_copy = ps_sei->u1_pic_struct;
         ps_sei->u1_is_valid = 1;
     }
     u4_bits_consumed = ps_bitstrm->u4_ofst - u4_start_offset;
+
+    if((ui4_payload_size << 3) < u4_bits_consumed)
+        return ERROR_CORRUPTED_SLICE;
+
     ih264d_flush_bits_h264(ps_bitstrm,
                            (ui4_payload_size << 3) - u4_bits_consumed);
 
     return (0);
 }
 
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : ih264d_parse_recovery_point                                     */
 /*                                                                           */
 /*  Description   : This function parses SEI message recovery point          */
 /*  Inputs        : ps_bitstrm    Bitstream                                */
 /*                  ps_dec          Poniter decoder context                  */
 /*                  ui4_payload_size pay load i4_size                           */
 /*  Globals       : None                                                     */
 /*  Processing    : Parses SEI payload picture timing                        */
 /*  Outputs       : None                                                     */
 /*  Returns       : None                                                     */
 /*                                                                           */
 /*  Issues        : Not implemented fully                                    */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         06 05 2002   NS              Draft                                */
 /*                                                                           */
 /*****************************************************************************/
@@ -270,56 +274,58 @@ WORD32 ih264d_parse_recovery_point(dec_bit_stream_t *ps_bitstrm,
 WORD32 ih264d_parse_sei_payload(dec_bit_stream_t *ps_bitstrm,
                                 UWORD32 ui4_payload_type,
                                 UWORD32 ui4_payload_size,
                                 dec_struct_t *ps_dec)
 {
     sei *ps_sei;
     WORD32 i4_status = 0;
     ps_sei = (sei *)ps_dec->ps_sei;
+
+    if(ui4_payload_size == 0)
+        return -1;
+
     switch(ui4_payload_type)
     {
         case SEI_BUF_PERIOD:
 
             i4_status = ih264d_parse_buffering_period(&ps_sei->s_buf_period,
                                                       ps_bitstrm, ps_dec);
-            /*if(i4_status != OK)
-                return i4_status;*/
             break;
         case SEI_PIC_TIMING:
             if(NULL == ps_dec->ps_cur_sps)
-                ih264d_flush_bits_h264(ps_bitstrm, (ui4_payload_size << 3));
+                i4_status = ih264d_flush_bits_h264(ps_bitstrm, (ui4_payload_size << 3));
             else
-                ih264d_parse_pic_timing(ps_bitstrm, ps_dec,
+                i4_status = ih264d_parse_pic_timing(ps_bitstrm, ps_dec,
                                         ui4_payload_size);
             break;
         case SEI_RECOVERY_PT:
-            ih264d_parse_recovery_point(ps_bitstrm, ps_dec,
+            i4_status = ih264d_parse_recovery_point(ps_bitstrm, ps_dec,
                                         ui4_payload_size);
             break;
         default:
-            ih264d_flush_bits_h264(ps_bitstrm, (ui4_payload_size << 3));
+            i4_status = ih264d_flush_bits_h264(ps_bitstrm, (ui4_payload_size << 3));
             break;
     }
     return (i4_status);
 }
 
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : ih264d_parse_sei_message                                        */
 /*                                                                           */
 /*  Description   : This function is parses and decode SEI. Currently it's   */
 /*                  not implemented fully.                                   */
 /*  Inputs        : ps_dec    Decoder parameters                       */
 /*                  ps_bitstrm    Bitstream                                */
 /*  Globals       : None                                                     */
 /*  Processing    : Parses SEI NAL units and stores the info                 */
 /*  Outputs       : None                                                     */
 /*  Returns       : None                                                     */
 /*                                                                           */
 /*  Issues        : Not implemented fully                                    */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         06 05 2002   NS              Draft                                */
 /*                                                                           */
 /*****************************************************************************/
@@ -327,61 +333,55 @@ WORD32 ih264d_parse_sei_payload(dec_bit_stream_t *ps_bitstrm,
 WORD32 ih264d_parse_sei_message(dec_struct_t *ps_dec,
                                 dec_bit_stream_t *ps_bitstrm)
 {
     UWORD32 ui4_payload_type, ui4_payload_size;
     UWORD32 u4_bits;
     WORD32 i4_status = 0;
 
     do
     {
         ui4_payload_type = 0;
 
         u4_bits = ih264d_get_bits_h264(ps_bitstrm, 8);
         while(0xff == u4_bits && !EXCEED_OFFSET(ps_bitstrm))
         {
             u4_bits = ih264d_get_bits_h264(ps_bitstrm, 8);
             ui4_payload_type += 255;
         }
         ui4_payload_type += u4_bits;
 
         ui4_payload_size = 0;
         u4_bits = ih264d_get_bits_h264(ps_bitstrm, 8);
         while(0xff == u4_bits && !EXCEED_OFFSET(ps_bitstrm))
         {
             u4_bits = ih264d_get_bits_h264(ps_bitstrm, 8);
             ui4_payload_size += 255;
         }
         ui4_payload_size += u4_bits;
 
         i4_status = ih264d_parse_sei_payload(ps_bitstrm, ui4_payload_type,
                                              ui4_payload_size, ps_dec);
-        if(i4_status == -1)
-        {
-            i4_status = 0;
-            break;
-        }
-
         if(i4_status != OK)
             return i4_status;
 
         if(ih264d_check_byte_aligned(ps_bitstrm) == 0)
         {
             u4_bits = ih264d_get_bit_h264(ps_bitstrm);
             if(0 == u4_bits)
             {
                 H264_DEC_DEBUG_PRINT("\nError in parsing SEI message");
             }
             while(0 == ih264d_check_byte_aligned(ps_bitstrm)
                             && !EXCEED_OFFSET(ps_bitstrm))
             {
                 u4_bits = ih264d_get_bit_h264(ps_bitstrm);
                 if(u4_bits)
                 {
                     H264_DEC_DEBUG_PRINT("\nError in parsing SEI message");
                 }
             }
         }
     }
     while(ps_bitstrm->u4_ofst < ps_bitstrm->u4_max_ofst);
     return (i4_status);
 }
 
diff --git a/decoder/ih264d_structs.h b/decoder/ih264d_structs.h
index 706fe9d..97e9797 100644
--- a/decoder/ih264d_structs.h
+++ b/decoder/ih264d_structs.h
@@ -706,763 +706,759 @@ typedef struct
 /** Aggregating structure that is globally available */
 typedef struct _DecStruct
 {
 
     /* Add below all other static memory allocations and pointers to items
      that are dynamically allocated once per session */
     dec_bit_stream_t *ps_bitstrm;
     dec_seq_params_t *ps_cur_sps;
     dec_pic_params_t *ps_cur_pps;
     dec_slice_params_t *ps_cur_slice;
 
     dec_pic_params_t *ps_pps;
     dec_seq_params_t *ps_sps;
     const UWORD16 *pu2_quant_scale_y;
     const UWORD16 *pu2_quant_scale_u;
     const UWORD16 *pu2_quant_scale_v;
     UWORD16 u2_mbx;
     UWORD16 u2_mby;
 
     UWORD16 u2_frm_wd_y; /** Width for luma buff */
     UWORD16 u2_frm_ht_y; /** Height for luma buff */
     UWORD16 u2_frm_wd_uv; /** Width for chroma buff */
     UWORD16 u2_frm_ht_uv; /** Height for chroma buff */
     UWORD16 u2_frm_wd_in_mbs; /** Frame width expressed in MB units */
     UWORD16 u2_frm_ht_in_mbs; /** Frame height expressed in MB units */
     WORD32 i4_submb_ofst; /** Offset in subMbs from the top left edge */
     /* Pointer to colocated Zero frame Image, will be used in B_DIRECT mode */
     /* colZeroFlag | // 0th bit
      field_flag  | // 1st bit
      XX          | // 2:3 bit don't cares
      subMbMode   | // 4:5 bit
      MbMode      | // 6:7 bit */
 
     UWORD8 *pu1_col_zero_flag;
 
     UWORD16 u2_pic_wd; /** Width of the picture being decoded */
     UWORD16 u2_pic_ht; /** Height of the picture being decoded */
 
     UWORD8 u1_first_slice_in_stream;
     UWORD8 u1_mb_ngbr_availablity;
     UWORD8 u1_ref_idxl0_active_minus1;
     UWORD8 u1_qp;
     UWORD8 u1_qp_y_div6;
     UWORD8 u1_qp_u_div6;
     UWORD8 u1_qp_y_rem6;
     UWORD8 u1_qp_u_rem6;
 
     /*********************************/
     /* configurable mb-group numbers */
     /* very critical to the decoder  */
     /*********************************/
     /************************************************************/
     /* MB_GROUP should be a multiple of 2                       */
     /************************************************************/
     UWORD8 u1_recon_mb_grp;
     UWORD8 u1_recon_mb_grp_pair;
     /* Variables to handle Cabac */
     decoding_envirnoment_t s_cab_dec_env; /* < Structure for decoding_envirnoment_t */
     /* These things need to be updated at each MbLevel */
     WORD8 i1_next_ctxt_idx; /* < next Ctxt Index */
     UWORD8 u1_currB_type;
     WORD8 i1_prev_mb_qp_delta; /* Prev MbQpDelta */
     UWORD8 u1_nal_unit_type;
 
     ctxt_inc_mb_info_t *p_ctxt_inc_mb_map; /* Pointer to ctxt_inc_mb_info_t map */
     ctxt_inc_mb_info_t *p_left_ctxt_mb_info; /* Pointer to left ctxt_inc_mb_info_t */
     ctxt_inc_mb_info_t *p_top_ctxt_mb_info; /* Pointer to top ctxt_inc_mb_info_t */
     ctxt_inc_mb_info_t *ps_curr_ctxt_mb_info; /* Pointer to current ctxt_inc_mb_info_t */
     ctxt_inc_mb_info_t *ps_def_ctxt_mb_info; /* Pointer to default ctxt_inc_mb_info_t */
 
     /* mv contexts for mv decoding using cabac */
     //UWORD8   u1_top_mv_ctxt_inc[4][4];
     /* Dimensions for u1_left_mv_ctxt_inc_arr is [2][4][4] for Mbaff case */
     UWORD8 u1_left_mv_ctxt_inc_arr[2][4][4];
     UWORD8 (*pu1_left_mv_ctxt_inc)[4];
 
     UWORD8 u1_sub_mb_num;
     UWORD8 u1_B; /** if B slice u1_B = 1 else 0 */
     WORD16 i2_only_backwarddma_info_idx;
     mv_pred_t *ps_mv; /** Pointer to the MV bank array */
     mv_pred_t *ps_mv_bank_cur; /** Pointer to the MV bank array */
     mv_pred_t s_default_mv_pred; /** Structure containing the default values
      for MV predictor */
 
     pred_info_t *ps_pred; /** Stores info to cfg MC */
     pred_info_t *ps_pred_start;
 
     UWORD32 u4_pred_info_idx;
     pred_info_pkd_t *ps_pred_pkd;
     pred_info_pkd_t *ps_pred_pkd_start;
     UWORD32 u4_pred_info_pkd_idx;
     UWORD8 *pu1_ref_buff; /** Destination buffer for DMAs */
     UWORD32 u4_dma_buf_idx;
 
     UWORD8 *pu1_y;
     UWORD8 *pu1_u;
     UWORD8 *pu1_v;
 
     WORD16 *pi2_y_coeff;
     UWORD8 *pu1_inv_scan;
 
     /**
      * Pointer frame level TU subblock coeff data
      */
     void *pv_pic_tu_coeff_data;
 
     /**
      * Pointer to TU subblock coeff data and number of subblocks and scan idx
      * Incremented each time a coded subblock is processed
      *
      */
     void *pv_parse_tu_coeff_data;
     void *pv_prev_mb_parse_tu_coeff_data;
 
     void *pv_proc_tu_coeff_data;
 
     WORD16 *pi2_coeff_data;
 
     cavlc_cntxt_t s_cavlc_ctxt;
 
     UWORD32 u4_n_leftY[2];
     UWORD32 u4_n_left_cr[2];
     UWORD32 u4_n_left_temp_y;
 
     UWORD8 pu1_left_nnz_y[4];
     UWORD8 pu1_left_nnz_uv[4];
     UWORD32 u4_n_left_temp_uv;
     /***************************************************************************/
     /*          Base pointer to all the cabac contexts                         */
     /***************************************************************************/
     bin_ctxt_model_t *p_cabac_ctxt_table_t;
 
     /***************************************************************************/
     /* cabac context pointers for every SE mapped into in p_cabac_ctxt_table_t */
     /***************************************************************************/
     bin_ctxt_model_t *p_mb_type_t;
     bin_ctxt_model_t *p_mb_skip_flag_t;
     bin_ctxt_model_t *p_sub_mb_type_t;
     bin_ctxt_model_t *p_mvd_x_t;
     bin_ctxt_model_t *p_mvd_y_t;
     bin_ctxt_model_t *p_ref_idx_t;
     bin_ctxt_model_t *p_mb_qp_delta_t;
     bin_ctxt_model_t *p_intra_chroma_pred_mode_t;
     bin_ctxt_model_t *p_prev_intra4x4_pred_mode_flag_t;
     bin_ctxt_model_t *p_rem_intra4x4_pred_mode_t;
     bin_ctxt_model_t *p_mb_field_dec_flag_t;
     bin_ctxt_model_t *p_cbp_luma_t;
     bin_ctxt_model_t *p_cbp_chroma_t;
     bin_ctxt_model_t *p_cbf_t[NUM_CTX_CAT];
     bin_ctxt_model_t *p_significant_coeff_flag_t[NUM_CTX_CAT];
     bin_ctxt_model_t *p_coeff_abs_level_minus1_t[NUM_CTX_CAT];
 
     UWORD32 u4_num_pmbair; /** MB pair number */
     mv_pred_t *ps_mv_left; /** Pointer to left motion vector bank */
     mv_pred_t *ps_mv_top_left; /** Pointer to top left motion vector bank */
     mv_pred_t *ps_mv_top_right; /** Pointer to top right motion vector bank */
 
     UWORD8 *pu1_left_yuv_dc_csbp;
 
 
     deblkmb_neighbour_t deblk_left_mb[2];
     deblkmb_neighbour_t *ps_deblk_top_mb;
     neighbouradd_t (*ps_left_mvpred_addr)[2]; /* Left MvPred Address Ping Pong*/
 
     /***************************************************************************/
     /*       Ref_idx contexts  are stored in the following way                 */
     /*  Array Idx 0,1 for reference indices in Forward direction               */
     /*  Array Idx 2,3 for reference indices in backward direction              */
     /***************************************************************************/
 
     /* Dimensions for u1_left_ref_ctxt_inc_arr is [2][4] for Mbaff:Top and Bot */
     WORD8 i1_left_ref_idx_ctx_inc_arr[2][4];
     WORD8 *pi1_left_ref_idx_ctxt_inc;
 
     /*************************************************************************/
     /*               Arrangnment of DC CSBP                                  */
     /*        bits:  b7  b6  b5  b4  b3  b2  b1  b0                          */
     /*        CSBP:   x   x   x   x   x  Vdc Udc Ydc                         */
     /*************************************************************************/
     /*************************************************************************/
     /*  Points either to u1_yuv_dc_csbp_topmb or  u1_yuv_dc_csbp_bot_mb     */
     /*************************************************************************/
     UWORD8 u1_yuv_dc_csbp_topmb;
     UWORD8 u1_yuv_dc_csbp_bot_mb;
 
     /* DMA SETUP */
     tfr_ctxt_t s_tran_addrecon_parse;
     tfr_ctxt_t s_tran_addrecon;
     tfr_ctxt_t s_tran_iprecon;
     tfr_ctxt_t *ps_frame_buf_ip_recon;
     WORD8 i1_recon_in_thread3_flag;
 
     /* slice Header Simplification */
     UWORD8 u1_pr_sl_type;
     WORD32 i4_frametype;
     UWORD32 u4_app_disp_width;
     WORD32 i4_error_code;
     UWORD32 u4_bitoffset;
 
     /* Variables added to handle field pics */
 
     UWORD8 u1_second_field;
     WORD32 i4_pic_type;
     WORD32 i4_content_type;
     WORD32 i4_decode_header;
     WORD32 i4_header_decoded;
     UWORD32 u4_total_frames_decoded;
 
     ctxt_inc_mb_info_t *ps_left_mb_ctxt_info; /* structure containing the left MB's
      context info, incase of Mbaff */
     pocstruct_t s_prev_pic_poc;
     pocstruct_t s_cur_pic_poc;
     WORD32 i4_cur_display_seq;
     WORD32 i4_prev_max_display_seq;
     WORD32 i4_max_poc;
     deblk_mb_t *ps_cur_deblk_mb;
 
     /* Pointers to local scratch buffers */
     deblk_mb_t *ps_deblk_pic;
 
     /* Pointers to Picture Buffers (Given by BufAPI Lib) */
     struct pic_buffer_t *ps_cur_pic; /** Pointer to Current picture buffer */
 
     /* Scratch Picture Buffers (Given by BufAPI Lib) */
     struct pic_buffer_t s_cur_pic;
 
     /* Current Slice related information */
     volatile UWORD16 u2_cur_slice_num;
     volatile UWORD16 u2_cur_slice_num_dec_thread;
 
     /* Variables needed for Buffer API handling */
     UWORD8 u1_nal_buf_id;
     UWORD8 u1_pic_buf_id;
     UWORD8 u1_pic_bufs;
 
     WORD16 *pi2_pred1; //[441];  /** Temp predictor buffer for MC */
     /* Pointer to refernce Pic buffers list, 0:fwd, 1:bwd */
     pic_buffer_t **ps_ref_pic_buf_lx[2];
     /* refIdx to POC mapping */
     void **ppv_map_ref_idx_to_poc;
     void **ppv_map_ref_idx_to_poc_base;
     UWORD32 *pu4_wts_ofsts_mat;
     UWORD32 *pu4_wt_ofsts;
     UWORD32 *pu4_mbaff_wt_mat;
     /* Function pointers to read Params common to CAVLC and CABAC */
     WORD32 (*pf_parse_inter_mb)(struct _DecStruct * ps_dec,
                                 dec_mb_info_t * ps_cur_mb_info,
                                 UWORD8 u1_mb_num,
                                 UWORD8 u1_num_mbsNby2);
     WORD32 (*pf_mvpred_ref_tfr_nby2mb)(struct _DecStruct * ps_dec,
                                      UWORD8 u1_num_mbs,
                                      UWORD8 u1_num_mbsNby2);
 
     WORD32 (*pf_parse_inter_slice)(struct _DecStruct * ps_dec,
                                    dec_slice_params_t * ps_slice,
                                    UWORD16 u2_first_mb_in_slice);
 
     UWORD32 (*pf_get_mb_info)(struct _DecStruct * ps_dec,
                               const UWORD16 u2_cur_mb_address,
                               dec_mb_info_t * ps_cur_mb_info,
                               UWORD32 u4_mbskip_run);
 
     /* Variables for Decode Buffer Management */
     dpb_manager_t *ps_dpb_mgr;
     dpb_commands_t *ps_dpb_cmds;
     dpb_commands_t s_dpb_cmds_scratch;
 
     /* Variables Required for N MB design */
     dec_mb_info_t *ps_nmb_info;
 
     UWORD8 *pu1_y_intra_pred_line;
     UWORD8 *pu1_u_intra_pred_line;
     UWORD8 *pu1_v_intra_pred_line;
 
     UWORD8 *pu1_cur_y_intra_pred_line;
     UWORD8 *pu1_cur_u_intra_pred_line;
     UWORD8 *pu1_cur_v_intra_pred_line;
 
     UWORD8 *pu1_cur_y_intra_pred_line_base;
     UWORD8 *pu1_cur_u_intra_pred_line_base;
     UWORD8 *pu1_cur_v_intra_pred_line_base;
 
     UWORD8 *pu1_prev_y_intra_pred_line;
     UWORD8 *pu1_prev_u_intra_pred_line;
     UWORD8 *pu1_prev_v_intra_pred_line;
 
     UWORD32 u4_intra_pred_line_ofst;
 
     UWORD8 u1_res_changed;
 
     mv_pred_t *ps_mv_cur; /** pointer to current motion vector bank */
     mv_pred_t *ps_mv_top; /** pointer to top motion vector bank */
     mv_pred_t *ps_mv_top_right2;/** Pointer to top right motion vector bank */
     mv_pred_t *ps_mv_p[2]; /** Scratch ping motion vector bank */
     mv_pred_t *ps_mv_top_p[MV_SCRATCH_BUFS]; /** Scratch top pong motion vector bank */
     UWORD8 u1_mv_top_p;
 
     deblk_mb_t *ps_deblk_mbn;
 
     UWORD8 *pu1_temp_mc_buffer;
 
     struct _sei *ps_sei;
     UWORD8 u1_pic_struct_copy;
     /* Variables required for cropping */
     UWORD16 u2_disp_width;
     UWORD16 u2_disp_height;
     UWORD16 u2_crop_offset_y;
     UWORD16 u2_crop_offset_uv;
 
     /* Variable required to get presentation time stamp through application */
     UWORD32 u4_pts;
 
     /* Variables used for gaps in frame number */
     UWORD16 u2_prev_ref_frame_num;
 
     UWORD8 u1_mb_idx;
     struct pic_buffer_t *ps_col_pic;
     void (*pf_parse_mvdirect)(struct _DecStruct*,
                            struct pic_buffer_t*,
                            directmv_t*,
                            UWORD8,
                            WORD32,
                            dec_mb_info_t *);
     void *pv_dec_out;
     void *pv_dec_in;
     void *pv_scratch_sps_pps; /*used temeporarily store sps/ spps while parsing*/
 
     /* state pointers to mb and partition information */
     parse_pmbarams_t *ps_parse_mb_data;
     parse_part_params_t *ps_parse_part_params;
 
     /* scratch pointers to mb and partition information */
     parse_part_params_t *ps_part;
 
     UWORD8 u1_max_dec_frame_buffering;
     pad_mgr_t s_pad_mgr;
     UWORD8 (*pf_mvpred)(struct _DecStruct *ps_dec,
                         struct _DecMbInfo *ps_cur_mb_info,
                         mv_pred_t *ps_mv_pred,
                         mv_pred_t *ps_mv_nmb,
                         mv_pred_t *ps_mv_ntop,
                         UWORD8 u1_sub_mb_num,
                         UWORD8 uc_mb_part_width,
                         UWORD8 uc_lxstart,
                         UWORD8 uc_lxend,
                         UWORD8 u1_mb_mc_mode);
     void (*pf_compute_bs)(struct _DecStruct * ps_dec,
                          struct _DecMbInfo * ps_cur_mb_info,
                          const UWORD16 u2_mbxn_mb);
     UWORD8 u1_init_dec_flag;
     prev_seq_params_t s_prev_seq_params;
     UWORD8 u1_cur_mb_fld_dec_flag; /* current Mb fld or Frm */
 
     UWORD8 u1_topleft_mb_fld;
     UWORD8 u1_topleft_mbtype;
     UWORD8 u1_topleft_mb_fld_bot;
     UWORD8 u1_topleft_mbtype_bot;
     WORD16 i2_prev_slice_mbx;
     WORD16 i2_prev_slice_mby;
     UWORD16 u2_top_left_mask;
     UWORD16 u2_top_right_mask;
     dec_err_status_t * ps_dec_err_status;
     /* Ensure pi1_left_pred_mode is aligned to 4 byte boundary,
     by declaring this after a pointer or an integer */
     WORD8 pi1_left_pred_mode[8];
 
     UWORD8 u1_mb_idx_mv;
     UWORD16 u2_mv_2mb[2];
     UWORD32 u4_skip_frm_mask;
 
     /* variable for finding the no.of mbs decoded in the current picture */
     UWORD16 u2_total_mbs_coded;
     /* member added for supporting fragmented annex - B */
 //  frg_annex_read_t s_frag_annex_read;
     /* added for vui_t, sei support*/
     WORD32 i4_vui_frame_rate;
     /* To Store the value of ref_idx_active for previous slice */
     /* useful in error handling                                */
     UWORD8 u1_num_ref_idx_lx_active_prev;
     /* Flag added to come out of process call in annex-b if&if frame is decoded */
     /* presence of access unit delimters and pps and sps                        */
     UWORD8 u1_frame_decoded_flag;
 
     /* To keep track of whether the last picture was decoded or not */
     /* in case of skip mode set by the application                  */
     UWORD8 u1_last_pic_not_decoded;
 
     WORD32 e_dec_status;
     UWORD32 u4_num_fld_in_frm;
 
     /* Function pointer for 4x4 residual cavlc parsing based on total coeff */
     WORD32 (*pf_cavlc_4x4res_block[3])(UWORD32 u4_isdc,
                                     UWORD32 u4_total_coeff_trail_one, /**TotalCoefficients<<16+trailingones*/
                                     dec_bit_stream_t *ps_bitstrm);
 
     /* Function pointer array for interpolate functions in called from motion compensattion module */
     void (*p_mc_interpolate_x_y[16][3])(UWORD8*,
                                         UWORD8*,
                                         UWORD8*,
                                         UWORD8,
                                         UWORD16,
                                         UWORD16,
                                         UWORD8);
 
     /**************************************************************************/
     /* Function pointer for 4x4 totalcoeff, trlone and residual cavlc parsing */
     /* based on u4_n (neigbourinng nnz average)                               */
     /* These point to two functions depending on (u4_n > 7) and (u4_n <= 7)   */
     /**************************************************************************/
     WORD32 (*pf_cavlc_parse4x4coeff[2])(WORD16 *pi2_coeff_block,
                                         UWORD32 u4_isdc, /* is it a DC block */
                                         WORD32 u4_n,
                                         struct _DecStruct *ps_dec, /** Decoder Parameters */
                                         UWORD32 *pu4_total_coeff);
 
     /**************************************************************************/
     /* Function pointer for luma 8x8block cavlc parsing based on top and left */
     /* neigbour availability.                                                 */
     /**************************************************************************/
     WORD32 (*pf_cavlc_parse_8x8block[4])(WORD16 *pi2_coeff_block,
                                          UWORD32 u4_sub_block_strd,
                                          UWORD32 u4_isdc,
                                          struct _DecStruct *ps_dec,
                                          UWORD8 *pu1_top_nnz,
                                          UWORD8 *pu1_left_nnz,
                                          UWORD8 u1_tran_form8x8,
                                          UWORD8 u1_mb_field_decodingflag,
                                          UWORD32 *pu4_csbp);
 
     /**************************************************************************/
     /* Ping pong top and current rows of mb neigbour_params                   */
     /**************************************************************************/
     mb_neigbour_params_t *ps_nbr_mb_row;
     mb_neigbour_params_t *ps_cur_mb_row;
     mb_neigbour_params_t *ps_top_mb_row;
 
     /**************************************************************************/
     /* Function pointer for 16x16 and non16x16 Bs1 calculations depending on   */
     /* P and B slice.                                                          */
     /***************************************************************************/
     void (*pf_fill_bs1[2][2])(mv_pred_t *ps_cur_mv_pred,
                               mv_pred_t *ps_top_mv_pred,
                               void **ppv_map_ref_idx_to_poc,
                               UWORD32 *pu4_bs_table, /* pointer to the BsTable array */
                               mv_pred_t *ps_leftmost_mv_pred,
                               neighbouradd_t *ps_left_addr,
                               void **u4_pic_addrress,
                               WORD32 i4_ver_mvlimit);
 
     void (*pf_fill_bs_xtra_left_edge[2])(UWORD32 *pu4_bs, /* Base pointer of BS table */
                                          WORD32 u4_left_mb_t_csbp, /* left mbpair's top csbp   */
                                          WORD32 u4_left_mb_b_csbp, /* left mbpair's bottom csbp*/
                                          WORD32 u4_cur_mb_csbp, /* csbp of current mb */
                                          UWORD32 u4_cur_mb_bot /* is top or bottom mb */
 
                                          );
     /* Function pointer array for BP and MP functions for MC*/
     void (*p_motion_compensate)(struct _DecStruct * ps_dec,
                                dec_mb_info_t *ps_cur_mb_info);
 
 
     void (*p_mc_dec_thread)(struct _DecStruct * ps_dec, dec_mb_info_t *ps_cur_mb_info);
 
     /* Function pointer array for BP and MP functions for formMbPartInfo*/
 
     WORD32 (*p_form_mb_part_info)(pred_info_pkd_t *ps_pred_pkd,
                                 struct _DecStruct * ps_dec,
                                      UWORD16 u2_mb_x,
                                      UWORD16 u2_mb_y,
                                      WORD32 mb_index,
                                      dec_mb_info_t *ps_cur_mb_info);
 
     WORD32 (*p_form_mb_part_info_thread)(pred_info_pkd_t *ps_pred_pkd,
                                 struct _DecStruct * ps_dec,
                                      UWORD16 u2_mb_x,
                                      UWORD16 u2_mb_y,
                                      WORD32 mb_index,
                                      dec_mb_info_t *ps_cur_mb_info);
 
 
     /* Required for cabac mbaff bottom mb */
     UWORD32 u4_next_mb_skip;
 
     void (*p_DeblockPicture[2])(struct _DecStruct *);
 
     /* ! */
     UWORD32 u4_ts;
     UWORD8 u1_flushfrm;
 
     /* Output format sent by the application */
     UWORD8 u1_chroma_format;
     UWORD8 u1_pic_decode_done;
     UWORD8 u1_slice_header_done;
     WORD32 init_done;
 
     /******************************************/
     /* For the high profile related variables */
     /******************************************/
     high_profile_tools_t s_high_profile;
     /* CBCR */
     UWORD8 u1_qp_v_div6;
     UWORD8 u1_qp_v_rem6;
     /*
      * TO help solve the dangling field case.
      * Check for the previous frame number and the current frame number.
      */
     UWORD16 u2_prv_frame_num;
     UWORD8 u1_top_bottom_decoded;
     UWORD8 u1_dangling_field;
 
     IVD_DISPLAY_FRAME_OUT_MODE_T                e_frm_out_mode;
 
     UWORD8 *pu1_bits_buf_static;
     UWORD8 *pu1_bits_buf_dynamic;
 
     UWORD32 u4_static_bits_buf_size;
     UWORD32 u4_dynamic_bits_buf_size;
 
     UWORD32 u4_num_disp_bufs_requested;
     WORD32 i4_display_delay;
     UWORD32 u4_slice_start_code_found;
 
     UWORD32 u4_nmb_deblk;
     UWORD32 u4_use_intrapred_line_copy;
     UWORD32 u4_num_mbs_prev_nmb;
     UWORD32 u4_num_mbs_cur_nmb;
     UWORD32 u4_app_deblk_disable_level;
     UWORD32 u4_app_disable_deblk_frm;
-    WORD32 i4_app_skip_mode;
     WORD32 i4_mv_frac_mask;
 
     disp_buf_t disp_bufs[MAX_DISP_BUFS_NEW];
     UWORD32 u4_disp_buf_mapping[MAX_DISP_BUFS_NEW];
     UWORD32 u4_disp_buf_to_be_freed[MAX_DISP_BUFS_NEW];
     UWORD32 u4_share_disp_buf;
     UWORD32 u4_num_disp_bufs;
-    UWORD32 u4_prev_nal_skipped;
-    UWORD32 u4_return_to_app;
-    WORD32 i4_dec_skip_mode;
 
     UWORD32 u4_bs_deblk_thread_created;
     volatile UWORD32 u4_start_recon_deblk;
     void *pv_bs_deblk_thread_handle;
 
     UWORD32 u4_cur_bs_mb_num;
     UWORD32 u4_bs_cur_slice_num_mbs;
     UWORD32 u4_cur_deblk_mb_num;
     UWORD32 u4_sps_cnt_in_process;
     volatile UWORD16 u2_cur_slice_num_bs;
 
     UWORD32 u4_deblk_mb_x;
     UWORD32 u4_deblk_mb_y;
 
 
 
     iv_yuv_buf_t s_disp_frame_info;
     UWORD32 u4_fmt_conv_num_rows;
     UWORD32 u4_fmt_conv_cur_row;
     ivd_out_bufdesc_t *ps_out_buffer;
     ivd_get_display_frame_op_t s_disp_op;
     UWORD32 u4_output_present;
 
     volatile UWORD16 cur_dec_mb_num;
     volatile UWORD16 cur_recon_mb_num;
     volatile UWORD16 u2_cur_mb_addr;
     WORD16 i2_dec_thread_mb_y;
     WORD16 i2_recon_thread_mb_y;
 
     UWORD8 u1_separate_parse;
     UWORD32 u4_dec_thread_created;
     void *pv_dec_thread_handle;
     volatile UWORD8 *pu1_dec_mb_map;
     volatile UWORD8 *pu1_recon_mb_map;
     volatile UWORD16 *pu2_slice_num_map;
     dec_slice_struct_t *ps_dec_slice_buf;
     void *pv_map_ref_idx_to_poc_buf;
     dec_mb_info_t *ps_frm_mb_info;
     volatile dec_slice_struct_t * volatile ps_parse_cur_slice;
     volatile dec_slice_struct_t * volatile ps_decode_cur_slice;
     volatile dec_slice_struct_t * volatile ps_computebs_cur_slice;
     UWORD32 u4_cur_slice_decode_done;
     UWORD32 u4_extra_mem_used;
 
     /* 2 first slice not parsed , 1 :first slice parsed , 0 :first valid slice header parsed*/
     UWORD32 u4_first_slice_in_pic;
     UWORD32 u4_num_cores;
     IVD_ARCH_T e_processor_arch;
     IVD_SOC_T e_processor_soc;
 
     /**
      * Pictures that are are degraded
      * 0 : No degrade
      * 1 : Only on non-reference frames
      * 2 : Use interval specified by u4_nondegrade_interval
      * 3 : All non-key frames
      * 4 : All frames
      */
     WORD32 i4_degrade_pics;
 
     /**
      * Interval for pictures which are completely decoded without any degradation
      */
     WORD32 i4_nondegrade_interval;
 
     /**
      * bit position (lsb is zero): Type of degradation
      * 1 : Disable deblocking
      * 2 : Faster inter prediction filters
      * 3 : Fastest inter prediction filters
      */
     WORD32 i4_degrade_type;
 
     /** Degrade pic count, Used to maintain the interval between non-degraded pics
      *
      */
     WORD32 i4_degrade_pic_cnt;
 
     UWORD32 u4_pic_buf_got;
 
     /**
      * Col flag and mv pred buffer manager
      */
     void *pv_mv_buf_mgr;
 
     /**
      * Picture buffer manager
      */
     void *pv_pic_buf_mgr;
 
     /**
      * Display buffer manager
      */
     void *pv_disp_buf_mgr;
 
     void *apv_buf_id_pic_buf_map[MAX_DISP_BUFS_NEW];
 
     UWORD8 au1_pic_buf_id_mv_buf_id_map[MAX_DISP_BUFS_NEW];
 
     UWORD8 au1_pic_buf_ref_flag[MAX_DISP_BUFS_NEW];
 
     struct pic_buffer_t *ps_pic_buf_base;
 
     UWORD8 *pu1_ref_buff_base;
     col_mv_buf_t *ps_col_mv_base;
     void *(*pf_aligned_alloc)(void *pv_mem_ctxt, WORD32 alignment, WORD32 size);
     void (*pf_aligned_free)(void *pv_mem_ctxt, void *pv_buf);
     void *pv_mem_ctxt;
 
     UWORD8 *pu1_pic_buf_base;
     UWORD8 *pu1_mv_bank_buf_base;
     UWORD8 *pu1_init_dpb_base;
 
     ih264_default_weighted_pred_ft *pf_default_weighted_pred_luma;
 
     ih264_default_weighted_pred_ft *pf_default_weighted_pred_chroma;
 
     ih264_weighted_pred_ft *pf_weighted_pred_luma;
 
     ih264_weighted_pred_ft *pf_weighted_pred_chroma;
 
     ih264_weighted_bi_pred_ft *pf_weighted_bi_pred_luma;
 
     ih264_weighted_bi_pred_ft *pf_weighted_bi_pred_chroma;
 
     ih264_pad *pf_pad_top;
     ih264_pad *pf_pad_bottom;
     ih264_pad *pf_pad_left_luma;
     ih264_pad *pf_pad_left_chroma;
     ih264_pad *pf_pad_right_luma;
     ih264_pad *pf_pad_right_chroma;
 
     ih264_inter_pred_chroma_ft *pf_inter_pred_chroma;
 
     ih264_inter_pred_luma_ft *apf_inter_pred_luma[16];
 
     ih264_intra_pred_luma_ft *apf_intra_pred_luma_16x16[4];
 
     ih264_intra_pred_luma_ft *apf_intra_pred_luma_8x8[9];
 
     ih264_intra_pred_luma_ft *apf_intra_pred_luma_4x4[9];
 
     ih264_intra_pred_ref_filtering_ft *pf_intra_pred_ref_filtering;
 
     ih264_intra_pred_chroma_ft *apf_intra_pred_chroma[4];
 
     ih264_iquant_itrans_recon_ft *pf_iquant_itrans_recon_luma_4x4;
 
     ih264_iquant_itrans_recon_ft *pf_iquant_itrans_recon_luma_4x4_dc;
 
     ih264_iquant_itrans_recon_ft *pf_iquant_itrans_recon_luma_8x8;
 
     ih264_iquant_itrans_recon_ft *pf_iquant_itrans_recon_luma_8x8_dc;
 
     ih264_iquant_itrans_recon_chroma_ft *pf_iquant_itrans_recon_chroma_4x4;
 
     ih264_iquant_itrans_recon_chroma_ft *pf_iquant_itrans_recon_chroma_4x4_dc;
 
     ih264_ihadamard_scaling_ft *pf_ihadamard_scaling_4x4;
 
     /**
      * deblock vertical luma edge with blocking strength 4
      */
     ih264_deblk_edge_bs4_ft *pf_deblk_luma_vert_bs4;
 
     /**
      * deblock vertical luma edge with blocking strength less than 4
      */
     ih264_deblk_edge_bslt4_ft *pf_deblk_luma_vert_bslt4;
 
     /**
      * deblock vertical luma edge with blocking strength 4 for mbaff
      */
     ih264_deblk_edge_bs4_ft *pf_deblk_luma_vert_bs4_mbaff;
 
     /**
      * deblock vertical luma edge with blocking strength less than 4 for mbaff
      */
     ih264_deblk_edge_bslt4_ft *pf_deblk_luma_vert_bslt4_mbaff;
 
     /**
      * deblock vertical chroma edge with blocking strength 4
      */
     ih264_deblk_chroma_edge_bs4_ft *pf_deblk_chroma_vert_bs4;
 
     /**
      * deblock vertical chroma edge with blocking strength less than 4
      */
     ih264_deblk_chroma_edge_bslt4_ft *pf_deblk_chroma_vert_bslt4;
 
     /**
      * deblock vertical chroma edge with blocking strength 4 for mbaff
      */
     ih264_deblk_chroma_edge_bs4_ft *pf_deblk_chroma_vert_bs4_mbaff;
 
     /**
      * deblock vertical chroma edge with blocking strength less than 4 for mbaff
      */
     ih264_deblk_chroma_edge_bslt4_ft *pf_deblk_chroma_vert_bslt4_mbaff;
 
     /**
      * deblock horizontal luma edge with blocking strength 4
      */
     ih264_deblk_edge_bs4_ft *pf_deblk_luma_horz_bs4;
 
     /**
      * deblock horizontal luma edge with blocking strength less than 4
      */
     ih264_deblk_edge_bslt4_ft *pf_deblk_luma_horz_bslt4;
 
     /**
      * deblock horizontal chroma edge with blocking strength 4
      */
     ih264_deblk_chroma_edge_bs4_ft *pf_deblk_chroma_horz_bs4;
 
     /**
      * deblock horizontal chroma edge with blocking strength less than 4
      */
     ih264_deblk_chroma_edge_bslt4_ft *pf_deblk_chroma_horz_bslt4;
 
 
 } dec_struct_t;
 
 #endif /* _H264_DEC_STRUCTS_H */
diff --git a/decoder/ih264d_utils.c b/decoder/ih264d_utils.c
index edfb8f1..0381763 100644
--- a/decoder/ih264d_utils.c
+++ b/decoder/ih264d_utils.c
@@ -140,310 +140,340 @@ UWORD8 ih264d_is_end_of_pic(UWORD16 u2_frame_num,
 /*!
  **************************************************************************
  * \if Function name : ih264d_decode_pic_order_cnt \endif
  *
  * \brief
  *    Calculates picture order count of picture.
  *
  * \return
  *    Returns the pic order count of the picture to which current
  *    Slice belongs.
  *
  **************************************************************************
  */
 WORD32 ih264d_decode_pic_order_cnt(UWORD8 u1_is_idr_slice,
                                    UWORD32 u2_frame_num,
                                    pocstruct_t *ps_prev_poc,
                                    pocstruct_t *ps_cur_poc,
                                    dec_slice_params_t *ps_cur_slice, /*!< Pointer to current slice Params*/
                                    dec_pic_params_t * ps_pps,
                                    UWORD8 u1_nal_ref_idc,
                                    UWORD8 u1_bottom_field_flag,
                                    UWORD8 u1_field_pic_flag,
                                    WORD32 *pi4_poc)
 {
     WORD16 i1_pic_msb;
     WORD32 i4_top_field_order_cnt = 0, i4_bottom_field_order_cnt = 0;
     dec_seq_params_t *ps_seq = ps_pps->ps_sps;
     WORD32 i4_prev_frame_num_ofst;
 
     switch(ps_seq->u1_pic_order_cnt_type)
     {
         case 0:
             /* POC TYPE 0 */
             if(u1_is_idr_slice)
             {
                 ps_prev_poc->i4_pic_order_cnt_msb = 0;
                 ps_prev_poc->i4_pic_order_cnt_lsb = 0;
             }
             if(ps_prev_poc->u1_mmco_equalto5)
             {
                 if(ps_prev_poc->u1_bot_field != 1)
                 {
                     ps_prev_poc->i4_pic_order_cnt_msb = 0;
                     ps_prev_poc->i4_pic_order_cnt_lsb =
                                     ps_prev_poc->i4_top_field_order_count;
                 }
                 else
                 {
                     ps_prev_poc->i4_pic_order_cnt_msb = 0;
                     ps_prev_poc->i4_pic_order_cnt_lsb = 0;
                 }
             }
 
             if((ps_cur_poc->i4_pic_order_cnt_lsb
                             < ps_prev_poc->i4_pic_order_cnt_lsb)
                             && ((ps_prev_poc->i4_pic_order_cnt_lsb
                                             - ps_cur_poc->i4_pic_order_cnt_lsb)
                                             >= (ps_seq->i4_max_pic_order_cntLsb
                                                             >> 1)))
             {
                 i1_pic_msb = ps_prev_poc->i4_pic_order_cnt_msb
                                 + ps_seq->i4_max_pic_order_cntLsb;
             }
             else if((ps_cur_poc->i4_pic_order_cnt_lsb
                             > ps_prev_poc->i4_pic_order_cnt_lsb)
                             && ((ps_cur_poc->i4_pic_order_cnt_lsb
                                             - ps_prev_poc->i4_pic_order_cnt_lsb)
                                             >= (ps_seq->i4_max_pic_order_cntLsb
                                                             >> 1)))
             {
                 i1_pic_msb = ps_prev_poc->i4_pic_order_cnt_msb
                                 - ps_seq->i4_max_pic_order_cntLsb;
             }
             else
             {
                 i1_pic_msb = ps_prev_poc->i4_pic_order_cnt_msb;
             }
 
             if(!u1_field_pic_flag || !u1_bottom_field_flag)
                 i4_top_field_order_cnt = i1_pic_msb
                                 + ps_cur_poc->i4_pic_order_cnt_lsb;
 
             if(!u1_field_pic_flag)
             {
                 i4_bottom_field_order_cnt = i4_top_field_order_cnt
                                 + ps_cur_poc->i4_delta_pic_order_cnt_bottom;
             }
             else if(u1_bottom_field_flag)
             {
                 i4_bottom_field_order_cnt = i1_pic_msb
                                 + ps_cur_poc->i4_pic_order_cnt_lsb;
             }
             ps_cur_poc->i4_pic_order_cnt_msb = i1_pic_msb;
             break;
 
         case 1:
         {
             /* POC TYPE 1 */
             UWORD8 i;
             WORD32 prev_frame_num;
             WORD32 frame_num_ofst;
             WORD32 abs_frm_num;
             WORD32 poc_cycle_cnt, frame_num_in_poc_cycle;
-            WORD32 expected_delta_poc_cycle;
+            WORD64 i8_expected_delta_poc_cycle;
             WORD32 expected_poc;
+            WORD64 i8_result;
 
             prev_frame_num = (WORD32)ps_cur_slice->u2_frame_num;
             if(!u1_is_idr_slice)
             {
                 if(ps_cur_slice->u1_mmco_equalto5)
                 {
                     prev_frame_num = 0;
                     i4_prev_frame_num_ofst = 0;
                 }
                 else
                 {
                     i4_prev_frame_num_ofst = ps_prev_poc->i4_prev_frame_num_ofst;
                 }
             }
             else
                 i4_prev_frame_num_ofst = 0;
 
             /* 1. Derivation for FrameNumOffset */
             if(u1_is_idr_slice)
             {
                 frame_num_ofst = 0;
                 ps_cur_poc->i4_delta_pic_order_cnt[0] = 0;
                 ps_cur_poc->i4_delta_pic_order_cnt[1] = 0;
             }
             else if(prev_frame_num > ((WORD32)u2_frame_num))
             {
                 frame_num_ofst = i4_prev_frame_num_ofst
-                                + ps_seq->u2_u4_max_pic_num_minus1 + 1;
+                                + (WORD32)ps_seq->u2_u4_max_pic_num_minus1 + 1;
             }
             else
                 frame_num_ofst = i4_prev_frame_num_ofst;
 
             /* 2. Derivation for absFrameNum */
             if(0 != ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle)
-                abs_frm_num = frame_num_ofst + u2_frame_num;
+                abs_frm_num = frame_num_ofst + (WORD32)u2_frame_num;
             else
                 abs_frm_num = 0;
             if((u1_nal_ref_idc == 0) && (abs_frm_num > 0))
                 abs_frm_num = abs_frm_num - 1;
 
             /* 4. expectedDeltaPerPicOrderCntCycle is derived as */
-            expected_delta_poc_cycle = 0;
+            i8_expected_delta_poc_cycle = 0;
             for(i = 0; i < ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle;
                             i++)
             {
-                expected_delta_poc_cycle +=
+                i8_expected_delta_poc_cycle +=
                                 ps_seq->i4_ofst_for_ref_frame[i];
             }
 
             /* 3. When absFrameNum > 0, picOrderCntCycleCnt and
              frame_num_in_poc_cycle are derived as : */
             /* 5. expectedPicOrderCnt is derived as : */
             if(abs_frm_num > 0)
             {
                 poc_cycle_cnt =
                                 DIV((abs_frm_num - 1),
                                     ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle);
                 frame_num_in_poc_cycle =
                                 MOD((abs_frm_num - 1),
                                     ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle);
 
-                expected_poc = poc_cycle_cnt
-                                * expected_delta_poc_cycle;
+                i8_result = poc_cycle_cnt
+                                * i8_expected_delta_poc_cycle;
+
                 for(i = 0; i <= frame_num_in_poc_cycle; i++)
                 {
-                    expected_poc = expected_poc
+                    i8_result = i8_result
                                     + ps_seq->i4_ofst_for_ref_frame[i];
                 }
+
+                if(IS_OUT_OF_RANGE_S32(i8_result))
+                    return ERROR_INV_POC;
+
+                expected_poc = (WORD32)i8_result;
+
             }
             else
                 expected_poc = 0;
 
             if(u1_nal_ref_idc == 0)
             {
-                expected_poc = expected_poc
+                i8_result = expected_poc
                                 + ps_seq->i4_ofst_for_non_ref_pic;
+
+                if(IS_OUT_OF_RANGE_S32(i8_result))
+                    return ERROR_INV_POC;
+
+                expected_poc = (WORD32)i8_result;
             }
 
             /* 6. TopFieldOrderCnt or BottomFieldOrderCnt are derived as */
             if(!u1_field_pic_flag)
             {
-                i4_top_field_order_cnt = expected_poc
+                i8_result = expected_poc
                                 + ps_cur_poc->i4_delta_pic_order_cnt[0];
-                i4_bottom_field_order_cnt = i4_top_field_order_cnt
+
+                if(IS_OUT_OF_RANGE_S32(i8_result))
+                    return ERROR_INV_POC;
+                i4_top_field_order_cnt = (WORD32)i8_result;
+
+                i8_result = i4_top_field_order_cnt
                                 + ps_seq->i4_ofst_for_top_to_bottom_field
                                 + ps_cur_poc->i4_delta_pic_order_cnt[1];
+
+                if(IS_OUT_OF_RANGE_S32(i8_result))
+                    return ERROR_INV_POC;
+                i4_bottom_field_order_cnt = (WORD32)i8_result;
             }
             else if(!u1_bottom_field_flag)
             {
-                i4_top_field_order_cnt = expected_poc
+                i8_result = expected_poc
                                 + ps_cur_poc->i4_delta_pic_order_cnt[0];
+
+                if(IS_OUT_OF_RANGE_S32(i8_result))
+                    return ERROR_INV_POC;
+                i4_top_field_order_cnt = (WORD32)i8_result;
             }
             else
             {
-                i4_bottom_field_order_cnt = expected_poc
+                i8_result = expected_poc
                                 + ps_seq->i4_ofst_for_top_to_bottom_field
                                 + ps_cur_poc->i4_delta_pic_order_cnt[0];
+
+                if(IS_OUT_OF_RANGE_S32(i8_result))
+                    return ERROR_INV_POC;
+                i4_bottom_field_order_cnt = (WORD32)i8_result;
             }
             /* Copy the current POC info into Previous POC structure */
             ps_cur_poc->i4_prev_frame_num_ofst = frame_num_ofst;
         }
 
             break;
         case 2:
         {
             /* POC TYPE 2 */
             WORD32 prev_frame_num;
             WORD32 frame_num_ofst;
             WORD32 tmp_poc;
 
             prev_frame_num = (WORD32)ps_cur_slice->u2_frame_num;
             if(!u1_is_idr_slice)
             {
                 if(ps_cur_slice->u1_mmco_equalto5)
                 {
                     prev_frame_num = 0;
                     i4_prev_frame_num_ofst = 0;
                 }
                 else
                     i4_prev_frame_num_ofst = ps_prev_poc->i4_prev_frame_num_ofst;
             }
             else
                 i4_prev_frame_num_ofst = 0;
 
             /* 1. Derivation for FrameNumOffset */
             if(u1_is_idr_slice)
             {
                 frame_num_ofst = 0;
                 ps_cur_poc->i4_delta_pic_order_cnt[0] = 0;
                 ps_cur_poc->i4_delta_pic_order_cnt[1] = 0;
             }
             else if(prev_frame_num > ((WORD32)u2_frame_num))
             {
                 frame_num_ofst = i4_prev_frame_num_ofst
-                                + ps_seq->u2_u4_max_pic_num_minus1 + 1;
+                                + (WORD32)ps_seq->u2_u4_max_pic_num_minus1 + 1;
             }
             else
                 frame_num_ofst = i4_prev_frame_num_ofst;
 
             /* 2. Derivation for tempPicOrderCnt */
             if(u1_is_idr_slice)
                 tmp_poc = 0;
             else if(u1_nal_ref_idc == 0)
-                tmp_poc = ((frame_num_ofst + u2_frame_num) << 1)
+                tmp_poc = ((frame_num_ofst + (WORD32)u2_frame_num) << 1)
                                 - 1;
             else
-                tmp_poc = ((frame_num_ofst + u2_frame_num) << 1);
+                tmp_poc = ((frame_num_ofst + (WORD32)u2_frame_num) << 1);
 
             /* 6. TopFieldOrderCnt or BottomFieldOrderCnt are derived as */
             if(!u1_field_pic_flag)
             {
                 i4_top_field_order_cnt = tmp_poc;
                 i4_bottom_field_order_cnt = tmp_poc;
             }
             else if(!u1_bottom_field_flag)
                 i4_top_field_order_cnt = tmp_poc;
             else
                 i4_bottom_field_order_cnt = tmp_poc;
 
             /* Copy the current POC info into Previous POC structure */
             ps_prev_poc->i4_prev_frame_num_ofst = frame_num_ofst;
             ps_cur_poc->i4_prev_frame_num_ofst = frame_num_ofst;
         }
             break;
         default:
             return ERROR_INV_POC_TYPE_T;
             break;
     }
 
     if(!u1_field_pic_flag) // or a complementary field pair
     {
         *pi4_poc = MIN(i4_top_field_order_cnt, i4_bottom_field_order_cnt);
         ps_pps->i4_top_field_order_cnt = i4_top_field_order_cnt;
         ps_pps->i4_bottom_field_order_cnt = i4_bottom_field_order_cnt;
     }
     else if(!u1_bottom_field_flag)
     {
         *pi4_poc = i4_top_field_order_cnt;
         ps_pps->i4_top_field_order_cnt = i4_top_field_order_cnt;
     }
     else
     {
         *pi4_poc = i4_bottom_field_order_cnt;
         ps_pps->i4_bottom_field_order_cnt = i4_bottom_field_order_cnt;
     }
 
     ps_pps->i4_avg_poc = *pi4_poc;
 
     return OK;
 }
 
 /*!
  **************************************************************************
  * \if Function name : ih264d_end_of_pic_processing \endif
  *
  * \brief
  *    Performs the end of picture processing.
  *
  * It performs deblocking on the current picture and sets the i4_status of
  * current picture as decoded.
  *
  * \return
  *    0 on Success and Error code otherwise.
  **************************************************************************
  */
@@ -673,219 +703,219 @@ WORD32 ih264d_init_dec_mb_grp(dec_struct_t *ps_dec)
 /*!
  **************************************************************************
  * \if Function name : ih264d_init_pic \endif
  *
  * \brief
  *    Initializes the picture.
  *
  * \return
  *    0 on Success and Error code otherwise
  *
  * \note
  *    This function is called when first slice of the
  *    NON -IDR picture is encountered.
  **************************************************************************
  */
 WORD32 ih264d_init_pic(dec_struct_t *ps_dec,
                        UWORD16 u2_frame_num,
                        WORD32 i4_poc,
                        dec_pic_params_t *ps_pps)
 {
     dec_seq_params_t *ps_seq = ps_pps->ps_sps;
     prev_seq_params_t * ps_prev_seq_params = &ps_dec->s_prev_seq_params;
     WORD32 i4_pic_bufs;
     WORD32 ret;
 
     ps_dec->ps_cur_slice->u2_frame_num = u2_frame_num;
     ps_dec->ps_cur_slice->i4_poc = i4_poc;
     ps_dec->ps_cur_pps = ps_pps;
     ps_dec->ps_cur_pps->pv_codec_handle = ps_dec;
 
     ps_dec->ps_cur_sps = ps_seq;
     ps_dec->ps_dpb_mgr->i4_max_frm_num = ps_seq->u2_u4_max_pic_num_minus1
                     + 1;
 
     ps_dec->ps_dpb_mgr->u2_pic_ht = ps_dec->u2_pic_ht;
     ps_dec->ps_dpb_mgr->u2_pic_wd = ps_dec->u2_pic_wd;
-    ps_dec->i4_pic_type = -1;
-    ps_dec->i4_frametype = -1;
-    ps_dec->i4_content_type = -1;
+    ps_dec->i4_pic_type = NA_SLICE;
+    ps_dec->i4_frametype = IV_NA_FRAME;
+    ps_dec->i4_content_type = IV_CONTENTTYPE_NA;
 
     /*--------------------------------------------------------------------*/
     /* Get the value of MaxMbAddress and frmheight in Mbs                 */
     /*--------------------------------------------------------------------*/
     ps_seq->u2_max_mb_addr =
                     (ps_seq->u2_frm_wd_in_mbs
                                     * (ps_dec->u2_pic_ht
                                                     >> (4
                                                                     + ps_dec->ps_cur_slice->u1_field_pic_flag)))
                                     - 1;
     ps_dec->u2_frm_ht_in_mbs = (ps_dec->u2_pic_ht
                     >> (4 + ps_dec->ps_cur_slice->u1_field_pic_flag));
 
     /***************************************************************************/
     /* If change in Level or the required PicBuffers i4_size is more than the  */
     /* current one FREE the current PicBuffers and allocate affresh            */
     /***************************************************************************/
     if(!ps_dec->u1_init_dec_flag)
     {
         ps_dec->u1_max_dec_frame_buffering = ih264d_get_dpb_size(ps_seq);
 
         ps_dec->i4_display_delay = ps_dec->u1_max_dec_frame_buffering;
         if((1 == ps_seq->u1_vui_parameters_present_flag) &&
            (1 == ps_seq->s_vui.u1_bitstream_restriction_flag))
         {
             if(ps_seq->u1_frame_mbs_only_flag == 1)
                 ps_dec->i4_display_delay = ps_seq->s_vui.u4_num_reorder_frames + 1;
             else
                 ps_dec->i4_display_delay = ps_seq->s_vui.u4_num_reorder_frames * 2 + 2;
         }
 
         if(IVD_DECODE_FRAME_OUT == ps_dec->e_frm_out_mode)
             ps_dec->i4_display_delay = 0;
 
         if(ps_dec->u4_share_disp_buf == 0)
         {
             if(ps_seq->u1_frame_mbs_only_flag == 1)
                 ps_dec->u1_pic_bufs = ps_dec->i4_display_delay + ps_seq->u1_num_ref_frames + 1;
             else
                 ps_dec->u1_pic_bufs = ps_dec->i4_display_delay + ps_seq->u1_num_ref_frames * 2 + 2;
         }
         else
         {
             ps_dec->u1_pic_bufs = (WORD32)ps_dec->u4_num_disp_bufs;
         }
 
         /* Ensure at least two buffers are allocated */
         ps_dec->u1_pic_bufs = MAX(ps_dec->u1_pic_bufs, 2);
 
         if(ps_dec->u4_share_disp_buf == 0)
             ps_dec->u1_pic_bufs = MIN(ps_dec->u1_pic_bufs,
                                       (H264_MAX_REF_PICS * 2));
 
         ps_dec->u1_max_dec_frame_buffering = MIN(
                         ps_dec->u1_max_dec_frame_buffering,
                         ps_dec->u1_pic_bufs);
 
         /* Temporary hack to run Tractor Cav/Cab/MbAff Profiler streams  also for CAFI1_SVA_C.264 in conformance*/
         if(ps_dec->u1_init_dec_flag)
         {
             ih264d_release_pics_in_dpb((void *)ps_dec,
                                        ps_dec->u1_pic_bufs);
             ih264d_release_display_bufs(ps_dec);
             ih264d_reset_ref_bufs(ps_dec->ps_dpb_mgr);
         }
 
         /*********************************************************************/
         /* Configuring decoder parameters based on level and then            */
         /* fresh pointer initialisation in decoder scratch and state buffers */
         /*********************************************************************/
         if(!ps_dec->u1_init_dec_flag ||
                 ((ps_seq->u1_level_idc < H264_LEVEL_3_0) ^ (ps_prev_seq_params->u1_level_idc < H264_LEVEL_3_0)))
         {
             ret = ih264d_init_dec_mb_grp(ps_dec);
             if(ret != OK)
                 return ret;
         }
 
         ret = ih264d_allocate_dynamic_bufs(ps_dec);
         if(ret != OK)
         {
             /* Free any dynamic buffers that are allocated */
             ih264d_free_dynamic_bufs(ps_dec);
             ps_dec->i4_error_code = IVD_MEM_ALLOC_FAILED;
             return IVD_MEM_ALLOC_FAILED;
         }
 
         ret = ih264d_create_pic_buffers(ps_dec->u1_pic_bufs,
                                         ps_dec);
         if(ret != OK)
             return ret;
 
 
 
         ret = ih264d_create_mv_bank(ps_dec, ps_dec->u2_pic_wd,
                                     ps_dec->u2_pic_ht);
         if(ret != OK)
             return ret;
 
         /* In shared mode, set all of them as used by display */
         if(ps_dec->u4_share_disp_buf == 1)
         {
             WORD32 i;
 
             for(i = 0; i < ps_dec->u1_pic_bufs; i++)
             {
                 ih264_buf_mgr_set_status((buf_mgr_t *)ps_dec->pv_pic_buf_mgr, i,
                                          BUF_MGR_IO);
             }
         }
 
         ps_dec->u1_init_dec_flag = 1;
         ps_prev_seq_params->u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs;
         ps_prev_seq_params->u1_level_idc = ps_seq->u1_level_idc;
         ps_prev_seq_params->u1_profile_idc = ps_seq->u1_profile_idc;
         ps_prev_seq_params->u2_frm_ht_in_mbs = ps_seq->u2_frm_ht_in_mbs;
         ps_prev_seq_params->u1_frame_mbs_only_flag =
                         ps_seq->u1_frame_mbs_only_flag;
         ps_prev_seq_params->u1_direct_8x8_inference_flag =
                         ps_seq->u1_direct_8x8_inference_flag;
 
         ps_dec->i4_cur_display_seq = 0;
         ps_dec->i4_prev_max_display_seq = 0;
         ps_dec->i4_max_poc = 0;
 
         {
             /* 0th entry of CtxtIncMbMap will be always be containing default values
              for CABAC context representing MB not available */
             ctxt_inc_mb_info_t *p_DefCtxt = ps_dec->p_ctxt_inc_mb_map - 1;
             UWORD8 *pu1_temp;
             WORD8 i;
             p_DefCtxt->u1_mb_type = CAB_SKIP;
 
             p_DefCtxt->u1_cbp = 0x0f;
             p_DefCtxt->u1_intra_chroma_pred_mode = 0;
 
             p_DefCtxt->u1_yuv_dc_csbp = 0x7;
 
             p_DefCtxt->u1_transform8x8_ctxt = 0;
 
             pu1_temp = (UWORD8*)p_DefCtxt->i1_ref_idx;
             for(i = 0; i < 4; i++, pu1_temp++)
                 (*pu1_temp) = 0;
             pu1_temp = (UWORD8*)p_DefCtxt->u1_mv;
             for(i = 0; i < 16; i++, pu1_temp++)
                 (*pu1_temp) = 0;
             ps_dec->ps_def_ctxt_mb_info = p_DefCtxt;
         }
 
     }
     /* reset DBP commands read u4_flag */
     ps_dec->ps_dpb_cmds->u1_dpb_commands_read = 0;
 
     return OK;
 }
 
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : ih264d_get_next_display_field                                   */
 /*                                                                           */
 /*  Description   : Application calls this module to get the next field      */
 /*                  to be displayed                                          */
 /*                                                                           */
 /*  Inputs        : 1.   IBUFAPI_Handle Hnadle to the Display buffer         */
 /*                  2.   IH264DEC_DispUnit    Pointer to the display struct  */
 /*                                                                           */
 /*  Globals       :                                                          */
 /*                                                                           */
 /*                                                                           */
 /*  Processing    : None                                                     */
 /*  Outputs       : None                                                     */
 /*  Returns       : None                                                     */
 /*  Issues        : None                                                     */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         27 05 2005   Ittiam          Draft                                */
 /*                                                                           */
 /*****************************************************************************/
@@ -893,222 +923,222 @@ WORD32 ih264d_init_pic(dec_struct_t *ps_dec,
 WORD32 ih264d_get_next_display_field(dec_struct_t * ps_dec,
                                   ivd_out_bufdesc_t *ps_out_buffer,
                                   ivd_get_display_frame_op_t *pv_disp_op)
 {
     pic_buffer_t *pic_buf;
 
     UWORD8 i1_cur_fld;
     WORD32 u4_api_ret = -1;
     WORD32 i4_disp_buf_id;
     iv_yuv_buf_t *ps_op_frm;
 
 
 
     ps_op_frm = &(ps_dec->s_disp_frame_info);
     H264_MUTEX_LOCK(&ps_dec->process_disp_mutex);
     pic_buf = (pic_buffer_t *)ih264_disp_mgr_get(
                     (disp_mgr_t *)ps_dec->pv_disp_buf_mgr, &i4_disp_buf_id);
     ps_dec->u4_num_fld_in_frm = 0;
     u4_api_ret = -1;
-    pv_disp_op->u4_ts = -1;
+    pv_disp_op->u4_ts = 0;
     pv_disp_op->e_output_format = ps_dec->u1_chroma_format;
 
     pv_disp_op->s_disp_frm_buf.pv_y_buf = ps_out_buffer->pu1_bufs[0];
     pv_disp_op->s_disp_frm_buf.pv_u_buf = ps_out_buffer->pu1_bufs[1];
     pv_disp_op->s_disp_frm_buf.pv_v_buf = ps_out_buffer->pu1_bufs[2];
     if(pic_buf != NULL)
     {
         pv_disp_op->e4_fld_type = 0;
         pv_disp_op->u4_disp_buf_id = i4_disp_buf_id;
 
         ps_op_frm->u4_y_ht = pic_buf->u2_disp_height << 1;
         ps_op_frm->u4_u_ht = ps_op_frm->u4_v_ht = ps_op_frm->u4_y_ht >> 1;
         ps_op_frm->u4_y_wd = pic_buf->u2_disp_width;
 
         ps_op_frm->u4_u_wd = ps_op_frm->u4_v_wd = ps_op_frm->u4_y_wd >> 1;
 
         ps_op_frm->u4_y_strd = pic_buf->u2_frm_wd_y;
         ps_op_frm->u4_u_strd = ps_op_frm->u4_v_strd = pic_buf->u2_frm_wd_uv;
 
         /* ! */
         pv_disp_op->u4_ts = pic_buf->u4_ts;
 
         /* set the start of the Y, U and V buffer pointer for display    */
         ps_op_frm->pv_y_buf = pic_buf->pu1_buf1 + pic_buf->u2_crop_offset_y;
         ps_op_frm->pv_u_buf = pic_buf->pu1_buf2 + pic_buf->u2_crop_offset_uv;
         ps_op_frm->pv_v_buf = pic_buf->pu1_buf3 + pic_buf->u2_crop_offset_uv;
         ps_dec->u4_num_fld_in_frm++;
         ps_dec->u4_num_fld_in_frm++;
         u4_api_ret = 0;
 
         if(pic_buf->u1_picturetype == 0)
             pv_disp_op->u4_progressive_frame_flag = 1;
         else
             pv_disp_op->u4_progressive_frame_flag = 0;
 
     } H264_MUTEX_UNLOCK(&ps_dec->process_disp_mutex);
     pv_disp_op->u4_error_code = u4_api_ret;
     pv_disp_op->e_pic_type = 0xFFFFFFFF; //Junk;
 
     if(u4_api_ret)
     {
         pv_disp_op->u4_error_code = 1; //put a proper error code here
     }
     else
     {
 
         //Release the buffer if being sent for display
         UWORD32 temp;
         UWORD32 dest_inc_Y = 0, dest_inc_UV = 0;
 
         pv_disp_op->s_disp_frm_buf.u4_y_wd = temp = MIN(ps_op_frm->u4_y_wd,
                                                         ps_op_frm->u4_y_strd);
         pv_disp_op->s_disp_frm_buf.u4_u_wd = pv_disp_op->s_disp_frm_buf.u4_y_wd
                         >> 1;
         pv_disp_op->s_disp_frm_buf.u4_v_wd = pv_disp_op->s_disp_frm_buf.u4_y_wd
                         >> 1;
 
         pv_disp_op->s_disp_frm_buf.u4_y_ht = ps_op_frm->u4_y_ht;
         pv_disp_op->s_disp_frm_buf.u4_u_ht = pv_disp_op->s_disp_frm_buf.u4_y_ht
                         >> 1;
         pv_disp_op->s_disp_frm_buf.u4_v_ht = pv_disp_op->s_disp_frm_buf.u4_y_ht
                         >> 1;
         if(0 == ps_dec->u4_share_disp_buf)
         {
             pv_disp_op->s_disp_frm_buf.u4_y_strd =
                             pv_disp_op->s_disp_frm_buf.u4_y_wd;
             pv_disp_op->s_disp_frm_buf.u4_u_strd =
                             pv_disp_op->s_disp_frm_buf.u4_y_wd >> 1;
             pv_disp_op->s_disp_frm_buf.u4_v_strd =
                             pv_disp_op->s_disp_frm_buf.u4_y_wd >> 1;
 
         }
         else
         {
             pv_disp_op->s_disp_frm_buf.u4_y_strd = ps_op_frm->u4_y_strd;
         }
 
         if(ps_dec->u4_app_disp_width)
         {
             pv_disp_op->s_disp_frm_buf.u4_y_strd = MAX(
                             ps_dec->u4_app_disp_width,
                             pv_disp_op->s_disp_frm_buf.u4_y_strd);
         }
 
         pv_disp_op->u4_error_code = 0;
         if(pv_disp_op->e_output_format == IV_YUV_420P)
         {
             UWORD32 i;
             pv_disp_op->s_disp_frm_buf.u4_u_strd =
                             pv_disp_op->s_disp_frm_buf.u4_y_strd >> 1;
             pv_disp_op->s_disp_frm_buf.u4_v_strd =
                             pv_disp_op->s_disp_frm_buf.u4_y_strd >> 1;
 
             pv_disp_op->s_disp_frm_buf.u4_u_wd = ps_op_frm->u4_y_wd >> 1;
             pv_disp_op->s_disp_frm_buf.u4_v_wd = ps_op_frm->u4_y_wd >> 1;
 
             if(1 == ps_dec->u4_share_disp_buf)
             {
                 pv_disp_op->s_disp_frm_buf.pv_y_buf = ps_op_frm->pv_y_buf;
 
                 for(i = 0; i < MAX_DISP_BUFS_NEW; i++)
                 {
                     UWORD8 *buf = ps_dec->disp_bufs[i].buf[0];
                     buf += ps_dec->disp_bufs[i].u4_ofst[0];
                     if(((UWORD8 *)pv_disp_op->s_disp_frm_buf.pv_y_buf
                                     - pic_buf->u2_crop_offset_y) == buf)
                     {
                         buf = ps_dec->disp_bufs[i].buf[1];
                         buf += ps_dec->disp_bufs[i].u4_ofst[1];
                         pv_disp_op->s_disp_frm_buf.pv_u_buf = buf
                                         + (pic_buf->u2_crop_offset_uv
                                            / YUV420SP_FACTOR);
 
                         buf = ps_dec->disp_bufs[i].buf[2];
                         buf += ps_dec->disp_bufs[i].u4_ofst[2];
                         pv_disp_op->s_disp_frm_buf.pv_v_buf = buf
                                         + (pic_buf->u2_crop_offset_uv
                                            / YUV420SP_FACTOR);
 
                     }
                 }
             }
 
         }
         else if((pv_disp_op->e_output_format == IV_YUV_420SP_UV)
                         || (pv_disp_op->e_output_format == IV_YUV_420SP_VU))
         {
             pv_disp_op->s_disp_frm_buf.u4_u_strd =
                             pv_disp_op->s_disp_frm_buf.u4_y_strd;
             pv_disp_op->s_disp_frm_buf.u4_v_strd = 0;
 
             if(1 == ps_dec->u4_share_disp_buf)
             {
                 UWORD32 i;
 
                 pv_disp_op->s_disp_frm_buf.pv_y_buf = ps_op_frm->pv_y_buf;
 
                 for(i = 0; i < MAX_DISP_BUFS_NEW; i++)
                 {
                     UWORD8 *buf = ps_dec->disp_bufs[i].buf[0];
                     buf += ps_dec->disp_bufs[i].u4_ofst[0];
                     if((UWORD8 *)pv_disp_op->s_disp_frm_buf.pv_y_buf
                                     - pic_buf->u2_crop_offset_y == buf)
                     {
                         buf = ps_dec->disp_bufs[i].buf[1];
                         buf += ps_dec->disp_bufs[i].u4_ofst[1];
                         pv_disp_op->s_disp_frm_buf.pv_u_buf = buf
                                         + pic_buf->u2_crop_offset_uv;
                         ;
 
                         buf = ps_dec->disp_bufs[i].buf[2];
                         buf += ps_dec->disp_bufs[i].u4_ofst[2];
                         pv_disp_op->s_disp_frm_buf.pv_v_buf = buf
                                         + pic_buf->u2_crop_offset_uv;
                         ;
                     }
                 }
             }
             pv_disp_op->s_disp_frm_buf.u4_u_wd =
                             pv_disp_op->s_disp_frm_buf.u4_y_wd;
             pv_disp_op->s_disp_frm_buf.u4_v_wd = 0;
 
         }
         else if((pv_disp_op->e_output_format == IV_RGB_565)
                         || (pv_disp_op->e_output_format == IV_YUV_422ILE))
         {
 
             pv_disp_op->s_disp_frm_buf.u4_u_strd = 0;
             pv_disp_op->s_disp_frm_buf.u4_v_strd = 0;
             pv_disp_op->s_disp_frm_buf.u4_u_wd = 0;
             pv_disp_op->s_disp_frm_buf.u4_v_wd = 0;
             pv_disp_op->s_disp_frm_buf.u4_u_ht = 0;
             pv_disp_op->s_disp_frm_buf.u4_v_ht = 0;
 
         }
 
 
     }
 
     return u4_api_ret;
 }
 
 
 /*****************************************************************************/
 /*  Function Name : ih264d_release_display_field                                         */
 /*                                                                           */
 /*  Description   : This function releases the display field that was returned   */
 /*                  here.                                                    */
 /*  Inputs        : ps_dec - Decoder parameters                              */
 /*  Globals       : None                                                     */
 /*  Processing    : Refer bumping process in the standard                    */
 /*  Outputs       : Assigns display sequence number.                         */
 /*  Returns       : None                                                     */
 /*                                                                           */
 /*  Issues        : None                                                     */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         27 04 2005   NS              Draft                                */
 /*                                                                           */
 /*****************************************************************************/
@@ -1239,106 +1269,109 @@ WORD32 ih264d_assign_display_seq(dec_struct_t *ps_dec)
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : ih264d_release_display_bufs                                       */
 /*                                                                           */
 /*  Description   : This function implments bumping process when mmco = 5.   */
 /*                  Each outgoing frame from DPB is assigned a display       */
 /*                  sequence number which increases monotonically. System    */
 /*                  looks for this number to display a frame.                */
 /*  Inputs        : ps_dec - Decoder parameters                              */
 /*  Globals       : None                                                     */
 /*  Processing    : Refer bumping process in the standard for mmco = 5       */
 /*  Outputs       : Assigns display sequence number.                         */
 /*  Returns       : None                                                     */
 /*                                                                           */
 /*  Issues        : None                                                     */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         27 04 2005   NS              Draft                                */
 /*                                                                           */
 /*****************************************************************************/
 void ih264d_release_display_bufs(dec_struct_t *ps_dec)
 {
     WORD32 i, j;
     WORD32 i4_min_poc;
     WORD32 i4_min_poc_buf_id;
     WORD32 i4_min_index;
+    UWORD64 u8_temp;
     dpb_manager_t *ps_dpb_mgr = ps_dec->ps_dpb_mgr;
     WORD32 (*i4_poc_buf_id_map)[3] = ps_dpb_mgr->ai4_poc_buf_id_map;
 
     i4_min_poc = 0x7fffffff;
     i4_min_poc_buf_id = -1;
     i4_min_index = -1;
 
     ih264d_delete_nonref_nondisplay_pics(ps_dpb_mgr);
 
     for(j = 0; j < ps_dpb_mgr->i1_poc_buf_id_entries; j++)
     {
         i4_min_poc = 0x7fffffff;
         for(i = 0; i < MAX_FRAMES; i++)
         {
             if(i4_poc_buf_id_map[i][0] != -1)
             {
                 if(i4_poc_buf_id_map[i][1] < i4_min_poc)
                 {
                     i4_min_poc = i4_poc_buf_id_map[i][1];
                     i4_min_poc_buf_id = i4_poc_buf_id_map[i][0];
                     i4_min_index = i;
                 }
             }
         }
 
         if(DO_NOT_DISP != i4_min_poc_buf_id)
         {
             ps_dec->i4_cur_display_seq++;
             ih264_disp_mgr_add(
                             (disp_mgr_t *)ps_dec->pv_disp_buf_mgr,
                             i4_min_poc_buf_id, ps_dec->i4_cur_display_seq,
                             ps_dec->apv_buf_id_pic_buf_map[i4_min_poc_buf_id]);
             i4_poc_buf_id_map[i4_min_index][0] = -1;
             i4_poc_buf_id_map[i4_min_index][1] = 0x7fffffff;
             ps_dpb_mgr->ai4_poc_buf_id_map[i4_min_index][2] = 0;
         }
         else
         {
             i4_poc_buf_id_map[i4_min_index][0] = -1;
             i4_poc_buf_id_map[i4_min_index][1] = 0x7fffffff;
             ps_dpb_mgr->ai4_poc_buf_id_map[i4_min_index][2] = 0;
         }
     }
     ps_dpb_mgr->i1_poc_buf_id_entries = 0;
-    ps_dec->i4_prev_max_display_seq = ps_dec->i4_prev_max_display_seq
-                    + ps_dec->i4_max_poc + ps_dec->u1_max_dec_frame_buffering
-                    + 1;
+    u8_temp = (UWORD64)ps_dec->i4_prev_max_display_seq + ps_dec->i4_max_poc
+              + ps_dec->u1_max_dec_frame_buffering + 1;
+    /*If i4_prev_max_display_seq overflows integer range, reset it */
+    ps_dec->i4_prev_max_display_seq = (u8_temp > 0x7fffffff)?
+                                      0 : u8_temp;
     ps_dec->i4_max_poc = 0;
 }
 
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : ih264d_assign_pic_num                                           */
 /*                                                                           */
 /*  Description   : This function assigns pic num to each reference frame    */
 /*                  depending on the cur_frame_num as speified in section    */
 /*                  8.2.4.1                                                  */
 /*                                                                           */
 /*  Inputs        : ps_dec                                                   */
 /*                                                                           */
 /*  Globals       : NO globals used                                          */
 /*                                                                           */
 /*  Processing    : for all ST pictures                                      */
 /*                    if( FrameNum > cur_frame_num)                          */
 /*                    PicNum = FrameNum - MaxFrameNum                        */
 /*                    else                                                   */
 /*                    PicNum = FrameNum                                      */
 /*                                                                           */
 /*  Returns       : void                                                     */
 /*                                                                           */
 /*  Issues        : NO                                                       */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         13 07 2002   Jay             Draft                                */
 /*                                                                           */
 /*****************************************************************************/
@@ -1464,180 +1497,182 @@ WORD32 ih264d_update_qp(dec_struct_t * ps_dec, const WORD8 i1_qp)
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : ih264d_decode_gaps_in_frame_num                                 */
 /*                                                                           */
 /*  Description   : This function decodes gaps in frame number               */
 /*                                                                           */
 /*  Inputs        : ps_dec          Decoder parameters                       */
 /*                  u2_frame_num   current frame number                     */
 /*                                                                           */
 /*  Globals       : None                                                     */
 /*  Processing    : This functionality needs to be implemented               */
 /*  Outputs       : None                                                     */
 /*  Returns       : None                                                     */
 /*                                                                           */
 /*  Issues        : Not implemented                                          */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         06 05 2002   NS              Draft                                */
 /*                                                                           */
 /*****************************************************************************/
 WORD32 ih264d_decode_gaps_in_frame_num(dec_struct_t *ps_dec,
                                        UWORD16 u2_frame_num)
 {
     UWORD32 u4_next_frm_num, u4_start_frm_num;
     UWORD32 u4_max_frm_num;
     pocstruct_t s_tmp_poc;
     WORD32 i4_poc;
     dec_slice_params_t *ps_cur_slice;
 
     dec_pic_params_t *ps_pic_params;
     WORD8 i1_gap_idx;
     WORD32 *i4_gaps_start_frm_num;
     dpb_manager_t *ps_dpb_mgr;
     WORD32 i4_frame_gaps;
     WORD8 *pi1_gaps_per_seq;
     WORD32 ret;
 
     ps_cur_slice = ps_dec->ps_cur_slice;
     if(ps_cur_slice->u1_field_pic_flag)
     {
         if(ps_dec->u2_prev_ref_frame_num == u2_frame_num)
             return 0;
     }
 
     u4_next_frm_num = ps_dec->u2_prev_ref_frame_num + 1;
     u4_max_frm_num = ps_dec->ps_cur_sps->u2_u4_max_pic_num_minus1 + 1;
 
     // check
     if(u4_next_frm_num >= u4_max_frm_num)
     {
         u4_next_frm_num -= u4_max_frm_num;
     }
 
     if(u4_next_frm_num == u2_frame_num)
     {
         return (0);
     }
 
     // check
     if((ps_dec->u1_nal_unit_type == IDR_SLICE_NAL)
                     && (u4_next_frm_num >= u2_frame_num))
     {
         return (0);
     }
     u4_start_frm_num = u4_next_frm_num;
 
     s_tmp_poc.i4_pic_order_cnt_lsb = 0;
     s_tmp_poc.i4_delta_pic_order_cnt_bottom = 0;
     s_tmp_poc.i4_pic_order_cnt_lsb = 0;
     s_tmp_poc.i4_delta_pic_order_cnt_bottom = 0;
     s_tmp_poc.i4_delta_pic_order_cnt[0] = 0;
     s_tmp_poc.i4_delta_pic_order_cnt[1] = 0;
 
     ps_cur_slice = ps_dec->ps_cur_slice;
     ps_pic_params = ps_dec->ps_cur_pps;
 
     i4_frame_gaps = 0;
     ps_dpb_mgr = ps_dec->ps_dpb_mgr;
 
     /* Find a empty slot to store gap seqn info */
     i4_gaps_start_frm_num = ps_dpb_mgr->ai4_gaps_start_frm_num;
     for(i1_gap_idx = 0; i1_gap_idx < MAX_FRAMES; i1_gap_idx++)
     {
         if(INVALID_FRAME_NUM == i4_gaps_start_frm_num[i1_gap_idx])
             break;
     }
     if(MAX_FRAMES == i1_gap_idx)
     {
         UWORD32 i4_error_code;
         i4_error_code = ERROR_DBP_MANAGER_T;
 //          i4_error_code |= 1<<IVD_CORRUPTEDDATA;
         return i4_error_code;
     }
 
     i4_poc = 0;
     i4_gaps_start_frm_num[i1_gap_idx] = u4_start_frm_num;
     ps_dpb_mgr->ai4_gaps_end_frm_num[i1_gap_idx] = u2_frame_num - 1;
     pi1_gaps_per_seq = ps_dpb_mgr->ai1_gaps_per_seq;
     pi1_gaps_per_seq[i1_gap_idx] = 0;
     while(u4_next_frm_num != u2_frame_num)
     {
         ih264d_delete_nonref_nondisplay_pics(ps_dpb_mgr);
         if(ps_pic_params->ps_sps->u1_pic_order_cnt_type)
         {
             /* allocate a picture buffer and insert it as ST node */
             ret = ih264d_decode_pic_order_cnt(0, u4_next_frm_num,
                                               &ps_dec->s_prev_pic_poc,
                                               &s_tmp_poc, ps_cur_slice,
                                               ps_pic_params, 1, 0, 0,
                                               &i4_poc);
             if(ret != OK)
                 return ret;
 
             /* Display seq no calculations */
             if(i4_poc >= ps_dec->i4_max_poc)
                 ps_dec->i4_max_poc = i4_poc;
             /* IDR Picture or POC wrap around */
             if(i4_poc == 0)
             {
-                ps_dec->i4_prev_max_display_seq =
-                                ps_dec->i4_prev_max_display_seq
-                                                + ps_dec->i4_max_poc
-                                                + ps_dec->u1_max_dec_frame_buffering
-                                                + 1;
+                UWORD64 u8_temp;
+                u8_temp = (UWORD64)ps_dec->i4_prev_max_display_seq
+                          + ps_dec->i4_max_poc
+                          + ps_dec->u1_max_dec_frame_buffering + 1;
+                /*If i4_prev_max_display_seq overflows integer range, reset it */
+                ps_dec->i4_prev_max_display_seq = (u8_temp > 0x7fffffff)?
+                                                  0 : u8_temp;
                 ps_dec->i4_max_poc = 0;
             }
 
             ps_cur_slice->u1_mmco_equalto5 = 0;
             ps_cur_slice->u2_frame_num = u4_next_frm_num;
         }
 
         // check
         if(ps_dpb_mgr->i1_poc_buf_id_entries
                         >= ps_dec->u1_max_dec_frame_buffering)
         {
             ret = ih264d_assign_display_seq(ps_dec);
             if(ret != OK)
                 return ret;
         }
 
         ret = ih264d_insert_pic_in_display_list(
                         ps_dec->ps_dpb_mgr, (WORD8) DO_NOT_DISP,
                         (WORD32)(ps_dec->i4_prev_max_display_seq + i4_poc),
                         u4_next_frm_num);
         if(ret != OK)
             return ret;
 
         pi1_gaps_per_seq[i1_gap_idx]++;
         ret = ih264d_do_mmco_for_gaps(ps_dpb_mgr,
                                 ps_dec->ps_cur_sps->u1_num_ref_frames);
         if(ret != OK)
             return ret;
 
         ih264d_delete_nonref_nondisplay_pics(ps_dpb_mgr);
 
         u4_next_frm_num++;
         if(u4_next_frm_num >= u4_max_frm_num)
         {
             u4_next_frm_num -= u4_max_frm_num;
         }
 
         i4_frame_gaps++;
     }
 
     return OK;
 }
 
 /*!
  **************************************************************************
  * \if Function name : ih264d_create_pic_buffers \endif
  *
  * \brief
  *    This function creates Picture Buffers.
  *
  * \return
  *    0 on Success and -1 on error
  **************************************************************************
  */
@@ -1784,369 +1819,382 @@ WORD32 ih264d_create_pic_buffers(UWORD8 u1_num_of_buf,
 /*!
  **************************************************************************
  * \if Function name : ih264d_allocate_dynamic_bufs \endif
  *
  * \brief
  *    This function allocates memory required by Decoder.
  *
  * \param ps_dec: Pointer to dec_struct_t.
  *
  * \return
  *    Returns i4_status as returned by MemManager.
  *
  **************************************************************************
  */
 WORD16 ih264d_allocate_dynamic_bufs(dec_struct_t * ps_dec)
 {
     struct MemReq s_MemReq;
     struct MemBlock *p_MemBlock;
 
     pred_info_t *ps_pred_frame;
     dec_mb_info_t *ps_frm_mb_info;
     dec_slice_struct_t *ps_dec_slice_buf;
     UWORD8 *pu1_dec_mb_map, *pu1_recon_mb_map;
     UWORD16 *pu2_slice_num_map;
 
     WORD16 *pi16_res_coeff;
     WORD16 i16_status = 0;
     UWORD8 uc_frmOrFld = (1 - ps_dec->ps_cur_sps->u1_frame_mbs_only_flag);
     UWORD16 u4_luma_wd = ps_dec->u2_frm_wd_y;
     UWORD16 u4_chroma_wd = ps_dec->u2_frm_wd_uv;
     WORD8 c_i = 0;
     dec_seq_params_t *ps_sps = ps_dec->ps_cur_sps;
     UWORD32 u4_total_mbs = ps_sps->u2_total_num_of_mbs << uc_frmOrFld;
     UWORD32 u4_wd_mbs = ps_dec->u2_frm_wd_in_mbs;
     UWORD32 u4_ht_mbs = ps_dec->u2_frm_ht_in_mbs;
     UWORD32 u4_blk_wd;
     UWORD32 ui_size = 0;
     UWORD32 u4_int_scratch_size = 0, u4_ref_pred_size = 0;
     UWORD8 *pu1_buf;
     WORD32 num_entries;
     WORD32 size;
     void *pv_buf;
     UWORD32 u4_num_bufs;
     UWORD32 u4_luma_size, u4_chroma_size;
     void *pv_mem_ctxt = ps_dec->pv_mem_ctxt;
 
     size = u4_total_mbs;
     pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->pu1_dec_mb_map = pv_buf;
 
     size = u4_total_mbs;
     pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->pu1_recon_mb_map = pv_buf;
 
     size = u4_total_mbs * sizeof(UWORD16);
     pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->pu2_slice_num_map = pv_buf;
 
     /************************************************************/
     /* Post allocation Initialisations                          */
     /************************************************************/
     ps_dec->ps_parse_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);
     ps_dec->ps_decode_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);
     ps_dec->ps_computebs_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);
 
     ps_dec->ps_pred_start = ps_dec->ps_pred;
 
     size = sizeof(parse_pmbarams_t) * (ps_dec->u1_recon_mb_grp);
     pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
     memset(pv_buf, 0, size);
     ps_dec->ps_parse_mb_data = pv_buf;
 
     size = sizeof(parse_part_params_t)
                         * ((ps_dec->u1_recon_mb_grp) << 4);
     pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->ps_parse_part_params = pv_buf;
 
     size = ((u4_wd_mbs * sizeof(deblkmb_neighbour_t)) << uc_frmOrFld);
     pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->ps_deblk_top_mb = pv_buf;
 
     size = ((sizeof(ctxt_inc_mb_info_t))
                         * (((u4_wd_mbs + 1) << uc_frmOrFld) + 1));
     pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->p_ctxt_inc_mb_map = pv_buf;
 
     /* 0th entry of CtxtIncMbMap will be always be containing default values
      for CABAC context representing MB not available */
     ps_dec->p_ctxt_inc_mb_map += 1;
 
     size = (sizeof(mv_pred_t) * ps_dec->u1_recon_mb_grp
                         * 16);
     pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->ps_mv_p[0] = pv_buf;
 
     size = (sizeof(mv_pred_t) * ps_dec->u1_recon_mb_grp
                         * 16);
     pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->ps_mv_p[1] = pv_buf;
 
     {
         UWORD8 i;
         for(i = 0; i < MV_SCRATCH_BUFS; i++)
         {
             size = (sizeof(mv_pred_t)
                             * ps_dec->u1_recon_mb_grp * 4);
             pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);
             RETURN_IF((NULL == pv_buf), IV_FAIL);
+            memset(pv_buf, 0, size);
             ps_dec->ps_mv_top_p[i] = pv_buf;
         }
     }
 
     size = sizeof(UWORD8) * ((u4_wd_mbs + 2) * MB_SIZE) * 2;
     pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
     ps_dec->pu1_y_intra_pred_line = pv_buf;
     memset(ps_dec->pu1_y_intra_pred_line, 0, size);
     ps_dec->pu1_y_intra_pred_line += MB_SIZE;
 
     size = sizeof(UWORD8) * ((u4_wd_mbs + 2) * MB_SIZE) * 2;
     pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
     ps_dec->pu1_u_intra_pred_line = pv_buf;
     memset(ps_dec->pu1_u_intra_pred_line, 0, size);
     ps_dec->pu1_u_intra_pred_line += MB_SIZE;
 
     size = sizeof(UWORD8) * ((u4_wd_mbs + 2) * MB_SIZE) * 2;
     pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
     ps_dec->pu1_v_intra_pred_line = pv_buf;
     memset(ps_dec->pu1_v_intra_pred_line, 0, size);
     ps_dec->pu1_v_intra_pred_line += MB_SIZE;
 
     if(ps_dec->u1_separate_parse)
     {
         /* Needs one extra row of info, to hold top row data */
         size = sizeof(mb_neigbour_params_t)
                         * 2 * ((u4_wd_mbs + 2) * (u4_ht_mbs + 1));
     }
     else
     {
         size = sizeof(mb_neigbour_params_t)
                         * 2 * ((u4_wd_mbs + 2) << uc_frmOrFld);
     }
     pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
 
     ps_dec->ps_nbr_mb_row = pv_buf;
     memset(ps_dec->ps_nbr_mb_row, 0, size);
 
     /* Allocate deblock MB info */
     size = (u4_total_mbs + u4_wd_mbs) * sizeof(deblk_mb_t);
 
     pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
     ps_dec->ps_deblk_pic = pv_buf;
 
     memset(ps_dec->ps_deblk_pic, 0, size);
 
     /* Allocate frame level mb info */
     size = sizeof(dec_mb_info_t) * u4_total_mbs;
     pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
     ps_dec->ps_frm_mb_info = pv_buf;
     memset(ps_dec->ps_frm_mb_info, 0, size);
 
     /* Allocate memory for slice headers dec_slice_struct_t */
     num_entries = MAX_FRAMES;
     if((1 >= ps_dec->ps_cur_sps->u1_num_ref_frames) &&
         (0 == ps_dec->i4_display_delay))
     {
         num_entries = 1;
     }
     num_entries = ((2 * num_entries) + 1);
     num_entries *= 2;
 
     size = num_entries * sizeof(void *);
     size += PAD_MAP_IDX_POC * sizeof(void *);
     size *= u4_total_mbs;
     size += sizeof(dec_slice_struct_t) * u4_total_mbs;
     pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
 
     ps_dec->ps_dec_slice_buf = pv_buf;
     memset(ps_dec->ps_dec_slice_buf, 0, size);
     pu1_buf = (UWORD8 *)ps_dec->ps_dec_slice_buf;
     pu1_buf += sizeof(dec_slice_struct_t) * u4_total_mbs;
     ps_dec->pv_map_ref_idx_to_poc_buf = (void *)pu1_buf;
 
     /* Allocate memory for packed pred info */
     num_entries = u4_total_mbs;
     num_entries *= 16 * 2;
 
     size = sizeof(pred_info_pkd_t) * num_entries;
     pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->ps_pred_pkd = pv_buf;
 
     /* Allocate memory for coeff data */
     size = MB_LUM_SIZE * sizeof(WORD16);
     /*For I16x16 MBs, 16 4x4 AC coeffs and 1 4x4 DC coeff TU blocks will be sent
     For all MBs along with 8 4x4 AC coeffs 2 2x2 DC coeff TU blocks will be sent
     So use 17 4x4 TU blocks for luma and 9 4x4 TU blocks for chroma */
     size += u4_total_mbs * (MAX(17 * sizeof(tu_sblk4x4_coeff_data_t),4 * sizeof(tu_blk8x8_coeff_data_t))
                                             + 9 * sizeof(tu_sblk4x4_coeff_data_t));
     //32 bytes for each mb to store u1_prev_intra4x4_pred_mode and u1_rem_intra4x4_pred_mode data
     size += u4_total_mbs * 32;
     pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
 
     ps_dec->pi2_coeff_data = pv_buf;
 
     ps_dec->pv_pic_tu_coeff_data = (void *)(ps_dec->pi2_coeff_data + MB_LUM_SIZE);
 
     /* Allocate MV bank buffer */
     {
         UWORD32 col_flag_buffer_size, mvpred_buffer_size;
 
         col_flag_buffer_size = ((ps_dec->u2_pic_wd * ps_dec->u2_pic_ht) >> 4);
         mvpred_buffer_size = sizeof(mv_pred_t)
                         * ((ps_dec->u2_pic_wd * (ps_dec->u2_pic_ht + PAD_MV_BANK_ROW)) >> 4);
 
         u4_num_bufs = ps_dec->ps_cur_sps->u1_num_ref_frames + 1;
 
         u4_num_bufs = MIN(u4_num_bufs, ps_dec->u1_pic_bufs);
         u4_num_bufs = MAX(u4_num_bufs, 2);
         size = ALIGN64(mvpred_buffer_size) + ALIGN64(col_flag_buffer_size);
         size *= u4_num_bufs;
         pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);
         RETURN_IF((NULL == pv_buf), IV_FAIL);
+        memset(pv_buf, 0, size);
         ps_dec->pu1_mv_bank_buf_base = pv_buf;
     }
 
     /* Allocate Pic buffer */
     u4_luma_size = ps_dec->u2_frm_wd_y * ps_dec->u2_frm_ht_y;
     u4_chroma_size = ps_dec->u2_frm_wd_uv * ps_dec->u2_frm_ht_uv;
 
     {
         if(ps_dec->u4_share_disp_buf == 1)
         {
             /* In case of buffers getting shared between application and library
              there is no need of reference memtabs. Instead of setting the i4_size
              to zero, it is reduced to a small i4_size to ensure that changes
              in the code are minimal */
             if((ps_dec->u1_chroma_format == IV_YUV_420SP_UV)
                             || (ps_dec->u1_chroma_format == IV_YUV_420SP_VU)
                             || (ps_dec->u1_chroma_format == IV_YUV_420P))
             {
                 u4_luma_size = 64;
             }
 
             if(ps_dec->u1_chroma_format == IV_YUV_420SP_UV)
             {
                 u4_chroma_size = 64;
             }
 
         }
     }
 
     size = ALIGN64(u4_luma_size) + ALIGN64(u4_chroma_size);
     size *= ps_dec->u1_pic_bufs;
     pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);
     RETURN_IF((NULL == pv_buf), IV_FAIL);
+    memset(pv_buf, 0, size);
     ps_dec->pu1_pic_buf_base = pv_buf;
 
     /* Post allocation Increment Actions */
 
     /***************************************************************************/
     /*Initialize cabac context pointers for every SE that has fixed contextIdx */
     /***************************************************************************/
     {
         bin_ctxt_model_t * const p_cabac_ctxt_table_t =
                         ps_dec->p_cabac_ctxt_table_t;
         bin_ctxt_model_t * * p_coeff_abs_level_minus1_t =
                         ps_dec->p_coeff_abs_level_minus1_t;
         bin_ctxt_model_t * * p_cbf_t = ps_dec->p_cbf_t;
 
         ps_dec->p_mb_field_dec_flag_t = p_cabac_ctxt_table_t
                         + MB_FIELD_DECODING_FLAG;
         ps_dec->p_prev_intra4x4_pred_mode_flag_t = p_cabac_ctxt_table_t
                         + PREV_INTRA4X4_PRED_MODE_FLAG;
         ps_dec->p_rem_intra4x4_pred_mode_t = p_cabac_ctxt_table_t
                         + REM_INTRA4X4_PRED_MODE;
         ps_dec->p_intra_chroma_pred_mode_t = p_cabac_ctxt_table_t
                         + INTRA_CHROMA_PRED_MODE;
         ps_dec->p_mb_qp_delta_t = p_cabac_ctxt_table_t + MB_QP_DELTA;
         ps_dec->p_ref_idx_t = p_cabac_ctxt_table_t + REF_IDX;
         ps_dec->p_mvd_x_t = p_cabac_ctxt_table_t + MVD_X;
         ps_dec->p_mvd_y_t = p_cabac_ctxt_table_t + MVD_Y;
         p_cbf_t[0] = p_cabac_ctxt_table_t + CBF + 0;
         p_cbf_t[1] = p_cabac_ctxt_table_t + CBF + 4;
         p_cbf_t[2] = p_cabac_ctxt_table_t + CBF + 8;
         p_cbf_t[3] = p_cabac_ctxt_table_t + CBF + 12;
         p_cbf_t[4] = p_cabac_ctxt_table_t + CBF + 16;
         ps_dec->p_cbp_luma_t = p_cabac_ctxt_table_t + CBP_LUMA;
         ps_dec->p_cbp_chroma_t = p_cabac_ctxt_table_t + CBP_CHROMA;
 
         p_coeff_abs_level_minus1_t[LUMA_DC_CTXCAT] = p_cabac_ctxt_table_t
                         + COEFF_ABS_LEVEL_MINUS1 + COEFF_ABS_LEVEL_CAT_0_OFFSET;
 
         p_coeff_abs_level_minus1_t[LUMA_AC_CTXCAT] = p_cabac_ctxt_table_t
                         + COEFF_ABS_LEVEL_MINUS1 + COEFF_ABS_LEVEL_CAT_1_OFFSET;
 
         p_coeff_abs_level_minus1_t[LUMA_4X4_CTXCAT] = p_cabac_ctxt_table_t
                         + COEFF_ABS_LEVEL_MINUS1 + COEFF_ABS_LEVEL_CAT_2_OFFSET;
 
         p_coeff_abs_level_minus1_t[CHROMA_DC_CTXCAT] = p_cabac_ctxt_table_t
                         + COEFF_ABS_LEVEL_MINUS1 + COEFF_ABS_LEVEL_CAT_3_OFFSET;
 
         p_coeff_abs_level_minus1_t[CHROMA_AC_CTXCAT] = p_cabac_ctxt_table_t
                         + COEFF_ABS_LEVEL_MINUS1 + COEFF_ABS_LEVEL_CAT_4_OFFSET;
 
         p_coeff_abs_level_minus1_t[LUMA_8X8_CTXCAT] = p_cabac_ctxt_table_t
                         + COEFF_ABS_LEVEL_MINUS1_8X8
                         + COEFF_ABS_LEVEL_CAT_5_OFFSET;
 
         /********************************************************/
         /* context for the high profile related syntax elements */
         /* This is maintained seperately in s_high_profile     */
         /********************************************************/
         {
 
             ps_dec->s_high_profile.ps_transform8x8_flag = p_cabac_ctxt_table_t
                             + TRANSFORM_SIZE_8X8_FLAG;
 
             ps_dec->s_high_profile.ps_sigcoeff_8x8_frame = p_cabac_ctxt_table_t
                             + SIGNIFICANT_COEFF_FLAG_8X8_FRAME;
 
             ps_dec->s_high_profile.ps_last_sigcoeff_8x8_frame =
                             p_cabac_ctxt_table_t
                                             + LAST_SIGNIFICANT_COEFF_FLAG_8X8_FRAME;
 
             ps_dec->s_high_profile.ps_coeff_abs_levelminus1 =
                             p_cabac_ctxt_table_t + COEFF_ABS_LEVEL_MINUS1_8X8;
 
             ps_dec->s_high_profile.ps_sigcoeff_8x8_field = p_cabac_ctxt_table_t
                             + SIGNIFICANT_COEFF_FLAG_8X8_FIELD;
 
             ps_dec->s_high_profile.ps_last_sigcoeff_8x8_field =
                             p_cabac_ctxt_table_t
                                             + LAST_SIGNIFICANT_COEFF_FLAG_8X8_FIELD;
         }
     }
     return (i16_status);
 }
 
 /*!
  **************************************************************************
  * \if Function name : ih264d_free_dynamic_bufs \endif
  *
  * \brief
  *    This function frees dynamic memory allocated by Decoder.
  *
  * \param ps_dec: Pointer to dec_struct_t.
  *
  * \return
  *    Returns i4_status as returned by MemManager.
  *
  **************************************************************************
  */
diff --git a/decoder/ih264d_vui.c b/decoder/ih264d_vui.c
index 15bc37d..15f1c00 100644
--- a/decoder/ih264d_vui.c
+++ b/decoder/ih264d_vui.c
@@ -125,119 +125,124 @@ WORD32 ih264d_parse_hrd_parametres(hrd_t *ps_hrd,
 WORD32 ih264d_parse_vui_parametres(vui_t *ps_vu4,
                                    dec_bit_stream_t *ps_bitstrm)
 {
     UWORD8 u4_bits;
     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
     WORD32 ret;
 
     u4_bits = ih264d_get_bits_h264(ps_bitstrm, 1);
     if(u4_bits)
     {
         u4_bits = ih264d_get_bits_h264(ps_bitstrm, 8);
         ps_vu4->u1_aspect_ratio_idc = (UWORD8)u4_bits;
         if(VUI_EXTENDED_SAR == u4_bits)
         {
             ps_vu4->u2_sar_width = ih264d_get_bits_h264(ps_bitstrm, 16);
             ps_vu4->u2_sar_height = ih264d_get_bits_h264(ps_bitstrm, 16);
         }
     }
 
     u4_bits = ih264d_get_bits_h264(ps_bitstrm, 1);
     if(u4_bits)
     {
         ps_vu4->u1_overscan_appropriate_flag = ih264d_get_bits_h264(
                         ps_bitstrm, 1);
     }
     u4_bits = ih264d_get_bits_h264(ps_bitstrm, 1);
     /* Initialize to unspecified (5 for video_format and
        2 for colour_primaries, tfr_chars, matrix_coeffs  */
     ps_vu4->u1_video_format = 5;
     ps_vu4->u1_video_full_range_flag = 0;
     ps_vu4->u1_colour_primaries = 2;
     ps_vu4->u1_tfr_chars = 2;
     ps_vu4->u1_matrix_coeffs = 2;
 
     if(u4_bits)
     {
         ps_vu4->u1_video_format = ih264d_get_bits_h264(ps_bitstrm, 3);
         ps_vu4->u1_video_full_range_flag = ih264d_get_bits_h264(ps_bitstrm,
                                                                 1);
         u4_bits = ih264d_get_bits_h264(ps_bitstrm, 1);
         if(u4_bits)
         {
             ps_vu4->u1_colour_primaries = ih264d_get_bits_h264(ps_bitstrm,
                                                                8);
             ps_vu4->u1_tfr_chars = ih264d_get_bits_h264(ps_bitstrm, 8);
             ps_vu4->u1_matrix_coeffs = ih264d_get_bits_h264(ps_bitstrm, 8);
         }
     }
 
     u4_bits = ih264d_get_bits_h264(ps_bitstrm, 1);
     if(u4_bits)
     {
         ps_vu4->u1_cr_top_field = ih264d_uev(pu4_bitstrm_ofst,
                                              pu4_bitstrm_buf);
         ps_vu4->u1_cr_bottom_field = ih264d_uev(pu4_bitstrm_ofst,
                                                 pu4_bitstrm_buf);
     }
 
     u4_bits = ih264d_get_bits_h264(ps_bitstrm, 1);
     if(u4_bits)
     {
         ps_vu4->u4_num_units_in_tick = ih264d_get_bits_h264(ps_bitstrm, 32);
         ps_vu4->u4_time_scale = ih264d_get_bits_h264(ps_bitstrm, 32);
         ps_vu4->u1_fixed_frame_rate_flag = ih264d_get_bits_h264(ps_bitstrm,
                                                                 1);
     }
 
     u4_bits = ih264d_get_bits_h264(ps_bitstrm, 1);
     ps_vu4->u1_nal_hrd_params_present = u4_bits;
     if(u4_bits)
     {
         ret = ih264d_parse_hrd_parametres(&ps_vu4->s_nal_hrd, ps_bitstrm);
         if(ret != OK)
             return ret;
     }
     u4_bits = ih264d_get_bits_h264(ps_bitstrm, 1);
     ps_vu4->u1_vcl_hrd_params_present = u4_bits;
     if(u4_bits)
     {
         ret = ih264d_parse_hrd_parametres(&ps_vu4->s_vcl_hrd, ps_bitstrm);
         if(ret != OK)
             return ret;
     }
 
     if(ps_vu4->u1_nal_hrd_params_present || u4_bits)
     {
         ps_vu4->u1_low_delay_hrd_flag = ih264d_get_bits_h264(ps_bitstrm, 1);
     }
     ps_vu4->u1_pic_struct_present_flag = ih264d_get_bits_h264(ps_bitstrm, 1);
 
     ps_vu4->u1_bitstream_restriction_flag = ih264d_get_bits_h264(ps_bitstrm, 1);
 
     if(ps_vu4->u1_bitstream_restriction_flag)
     {
         ps_vu4->u1_mv_over_pic_boundaries_flag = ih264d_get_bits_h264(
                         ps_bitstrm, 1);
         ps_vu4->u4_max_bytes_per_pic_denom = ih264d_uev(pu4_bitstrm_ofst,
                                                         pu4_bitstrm_buf);
         ps_vu4->u4_max_bits_per_mb_denom = ih264d_uev(pu4_bitstrm_ofst,
                                                       pu4_bitstrm_buf);
         ps_vu4->u4_log2_max_mv_length_horz = ih264d_uev(pu4_bitstrm_ofst,
                                                         pu4_bitstrm_buf);
         ps_vu4->u4_log2_max_mv_length_vert = ih264d_uev(pu4_bitstrm_ofst,
                                                         pu4_bitstrm_buf);
         ps_vu4->u4_num_reorder_frames = ih264d_uev(pu4_bitstrm_ofst,
                                                    pu4_bitstrm_buf);
         ps_vu4->u4_max_dec_frame_buffering = ih264d_uev(pu4_bitstrm_ofst,
                                                         pu4_bitstrm_buf);
+        if((ps_vu4->u4_max_dec_frame_buffering > (H264_MAX_REF_PICS * 2)) ||
+           (ps_vu4->u4_num_reorder_frames > ps_vu4->u4_max_dec_frame_buffering))
+        {
+            return ERROR_INV_SPS_PPS_T;
+        }
     }
     else
     {
         /* Setting this to a large value if not present */
         ps_vu4->u4_num_reorder_frames = 64;
         ps_vu4->u4_max_dec_frame_buffering = 64;
     }
 
     return OK;
 }
diff --git a/encoder/ih264e_defs.h b/encoder/ih264e_defs.h
index 4537bc2..33fafd1 100644
--- a/encoder/ih264e_defs.h
+++ b/encoder/ih264e_defs.h
@@ -1,294 +1,299 @@
 /******************************************************************************
  *
  * Copyright (C) 2015 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  *****************************************************************************
  * Originally developed and contributed by Ittiam Systems Pvt. Ltd, Bangalore
 */
 /**
 *******************************************************************************
 * @file
 *  ih264e_defs.h
 *
 * @brief
 *  Definitions used in the encoder
 *
 * @author
 *  ittiam
 *
 * @remarks
 *  None
 *
 *******************************************************************************
 */
 
 #ifndef IH264E_DEFS_H_
 #define IH264E_DEFS_H_
 
 
 #define PARSE_COEFF_DATA_BLOCK_4x4(pv_mb_coeff_data, ps_mb_coeff_data, u4_nnz, u4_sig_coeff_map, pi2_res_block)   \
 {                                                                          \
     ps_mb_coeff_data = pv_mb_coeff_data;                                   \
     u4_nnz = ps_mb_coeff_data->i4_sig_map_nnz & 0xff;                      \
     if (u4_nnz)                                                            \
     {                                                                      \
         u4_sig_coeff_map = ps_mb_coeff_data->i4_sig_map_nnz >> 16;         \
         pi2_res_block = ps_mb_coeff_data->ai2_residue;                     \
         pv_mb_coeff_data = ps_mb_coeff_data->ai2_residue + ALIGN2(u4_nnz); \
     }                                                                      \
     else                                                                   \
     {                                                                      \
       pv_mb_coeff_data = ps_mb_coeff_data->ai2_residue;                    \
     }                                                                      \
 }
 
 /*****************************************************************************/
 /* Width and height restrictions                                             */
 /*****************************************************************************/
 /**
  * Minimum width supported by codec
  */
 #define MIN_WD   16
 
 /**
  * Maximum width supported by codec
  */
 
 /* changed by haining@ to support Nexus 6P screen size, was previously 1920 */
 #define MAX_WD   2560
 
 /**
  * Minimum height supported by codec
  */
 #define MIN_HT   16
 
 /**
  * Maximum height supported by codec
  */
 
 /* changed by haining@ to support Nexus 6P screen size, was previously 1920 */
 #define MAX_HT   2560
 
 /*****************************************************************************/
 /* Padding sizes                                                             */
 /*****************************************************************************/
 /**
  * Padding used for top of the frame
  */
 #define PAD_TOP     32
 
 /**
  * Padding used for bottom of the frame
  */
 #define PAD_BOT     32
 
 /**
  * Padding used at left of the frame
  */
 #define PAD_LEFT    32
 
 /**
  * Padding used at right of the frame
  */
 #define PAD_RIGHT   32
 /**
  * Padding for width
  */
 #define PAD_WD      (PAD_LEFT + PAD_RIGHT)
 /**
  * Padding for height
  */
 #define PAD_HT      (PAD_TOP  + PAD_BOT)
 
 /*
  * buffer width and height for half pel buffers
  */
 #define HP_BUFF_WD  24
 #define HP_BUFF_HT  18
 
 /*****************************************************************************/
 /* Number of frame restrictions                                              */
 /*****************************************************************************/
 /**
  *  Maximum number of reference pictures
  */
 #define MAX_REF_PIC_CNT  2
 
 /**
  *  Minimum number of reference pictures
  */
 #define MIN_REF_PIC_CNT  1
 
 /**
  *  Maximum number of B pictures between two I/P pictures
  */
-#define MAX_NUM_BFRAMES     10
+#define MAX_NUM_BFRAMES     8
+
+/**
+ *  Maximum number of pictures in input queue
+ */
+#define MAX_NUM_INP_FRAMES  ((MAX_NUM_BFRAMES) + 2)
 
 /**
  *  Maximum number of reference buffers in DPB manager
  */
 #define MAX_REF_CNT  32
 
 /*****************************************************************************/
 /* Minimum size of inter prediction unit supported by encoder                */
 /*****************************************************************************/
 #define ENC_MIN_PU_SIZE     16
 
 /*****************************************************************************/
 /* Num cores releated defs                                                   */
 /*****************************************************************************/
 /**
  *  Maximum number of cores
  */
 #define MAX_NUM_CORES       8
 
 /**
  *  Maximum number of threads for pixel processing
  */
 #define MAX_PROCESS_THREADS MAX_NUM_CORES
 
 /**
  * Maximum process context sets
  * Used to stagger encoding of MAX_CTXT_SETS in parallel
  */
 #define MAX_CTXT_SETS   1
 /**
  * Maximum number of contexts
  * Kept as twice the number of threads, to make it easier to initialize the contexts
  * from master thread
  */
 #define MAX_PROCESS_CTXT    MAX_NUM_CORES * MAX_CTXT_SETS
 
 /*****************************************************************************/
 /* Profile and level restrictions                                            */
 /*****************************************************************************/
 /**
  * Max level supported by the codec
  */
 #define MAX_LEVEL  IH264_LEVEL_51
 
 /**
  * Min level supported by the codec
  */
 #define MIN_LEVEL  IH264_LEVEL_10
 
 /**
  * Maximum number of slice headers that are held in memory simultaneously
  * For single core implementation only 1 slice header is enough.
  * But for multi-core parsing thread needs to ensure that slice headers are
  * stored till the last CB in a slice is decoded.
  * Parsing thread has to wait till last CB of a slice is consumed before reusing
  * overwriting the slice header
  * MAX_SLICE_HDR_CNT is assumed to be a power of 2
  */
 
 #define LOG2_MAX_SLICE_HDR_CNT 8
 #define MAX_SLICE_HDR_CNT (1 << LOG2_MAX_SLICE_HDR_CNT)
 
 /* Generic declarations */
 #define DEFAULT_MAX_LEVEL               40
 #define DEFAULT_RECON_ENABLE            0
 #define DEFAULT_RC                      IVE_RC_STORAGE
 #define DEFAULT_MAX_FRAMERATE           120000
-#define DEFAULT_MAX_BITRATE             50000000
+#define DEFAULT_MAX_BITRATE             240000000
 #define DEFAULT_MAX_NUM_BFRAMES         0
 #define DEFAULT_MAX_SRCH_RANGE_X        256
 #define DEFAULT_MAX_SRCH_RANGE_Y        256
 #define DEFAULT_SLICE_PARAM             256
 #define DEFAULT_SRC_FRAME_RATE          30000
 #define DEFAULT_TGT_FRAME_RATE          30000
 #define DEFAULT_BITRATE                 6000000
 #define DEFAULT_QP_MIN                  10
 #define DEFAULT_QP_MAX                  51
 #define DEFAULT_I_QP                    25
 #define DEFAULT_P_QP                    28
 #define DEFAULT_B_QP                    28
 #define DEFAULT_AIR_MODE                IVE_AIR_MODE_NONE
 #define DEFAULT_AIR_REFRESH_PERIOD      30
 #define DEFAULT_VBV_DELAY               1000
-#define DEFAULT_VBV_SIZE                16800000 /* level 3.1 */
+#define DEFAULT_VBV_SIZE                240000000 /* level 6.0 */
 #define DEFAULT_NUM_CORES               1
 #define DEFAULT_ME_SPEED_PRESET         100
 #define DEFAULT_HPEL                    1
 #define DEFAULT_QPEL                    1
 #define DEFAULT_I4                      1
 #define DEFAULT_I8                      0
 #define DEFAULT_I16                     1
 #define DEFAULT_ENABLE_FAST_SAD         0
 #define DEFAULT_ENABLE_SATQD            1
 #define DEFAULT_MIN_SAD_ENABLE          0
 #define DEFAULT_MIN_SAD_DISABLE         -1
 #define DEFAULT_SRCH_RNG_X              64
 #define DEFAULT_SRCH_RNG_Y              48
 #define DEFAULT_I_INTERVAL              30
 #define DEFAULT_IDR_INTERVAL            1000
 #define DEFAULT_B_FRAMES                0
 #define DEFAULT_DISABLE_DEBLK_LEVEL     0
 #define DEFAULT_PROFILE                 IV_PROFILE_BASE
 #define DEFAULT_MIN_INTRA_FRAME_RATE    1
 #define DEFAULT_MAX_INTRA_FRAME_RATE    2147483647
 #define DEFAULT_MIN_BUFFER_DELAY        30
 #define DEFAULT_MAX_BUFFER_DELAY        20000
 #define DEFAULT_STRIDE                  0
 #define DEFAULT_ENC_SPEED_PRESET        IVE_USER_DEFINED
 #define DEFAULT_PRE_ENC_ME              0
 #define DEFAULT_PRE_ENC_IPE             0
 #define DEFAULT_ENTROPY_CODING_MODE     0
 
 /** Maximum number of entries in input buffer list */
 #define MAX_INP_BUF_LIST_ENTRIES         32
 
 /** Maximum number of entries in output buffer list */
 #define MAX_OUT_BUF_LIST_ENTRIES         32
 
 /** Maximum number of entries in recon buffer list used within the encoder */
 #define MAX_REC_LIST_ENTRIES             16
 
 /** Number of buffers created to hold half-pel planes for every reference buffer */
 #define HPEL_PLANES_CNT                 1
 
 /** Number of buffers Needed for SUBPEL and BIPRED computation */
 #define SUBPEL_BUFF_CNT                 4
 
 /**
  *****************************************************************************
  * Macro to compute total size required to hold on set of scaling matrices
  *****************************************************************************
  */
 #define SCALING_MAT_SIZE(m_scaling_mat_size)                                 \
 {                                                                            \
     m_scaling_mat_size = 6 * TRANS_SIZE_4 * TRANS_SIZE_4;                    \
     m_scaling_mat_size += 6 * TRANS_SIZE_8 * TRANS_SIZE_8;                   \
     m_scaling_mat_size += 6 * TRANS_SIZE_16 * TRANS_SIZE_16;                 \
     m_scaling_mat_size += 2 * TRANS_SIZE_32 * TRANS_SIZE_32;                 \
 }
 
 /**
  ******************************************************************************
  *  @brief Macros to get raster scan position of a block[8x8] / sub block[4x4]
  ******************************************************************************
  */
 #define GET_BLK_RASTER_POS_X(x)     ((x & 0x01))
 #define GET_BLK_RASTER_POS_Y(y)     ((y >> 1))
 #define GET_SUB_BLK_RASTER_POS_X(x) ((x & 0x01))
 #define GET_SUB_BLK_RASTER_POS_Y(y) ((y >> 1))
 
 #define NUM_RC_MEMTABS 17
 
 /**
  ***************************************************************************
  * Enum to hold various mem records being request
  ****************************************************************************
  */
diff --git a/encoder/ih264e_structs.h b/encoder/ih264e_structs.h
index 125db84..c2e3b89 100644
--- a/encoder/ih264e_structs.h
+++ b/encoder/ih264e_structs.h
@@ -2142,677 +2142,677 @@ typedef struct
 /**
  * Codec context
  */
 struct _codec_t
 {
     /**
      * Id of current pic (input order)
      */
     WORD32 i4_poc;
 
     /**
      * Number of encode frame API calls made
      * This variable must only be used for context selection [Read only]
      */
     WORD32 i4_encode_api_call_cnt;
 
     /**
      * Number of pictures encoded
      */
     WORD32 i4_pic_cnt;
 
     /**
      * Number of threads created
      */
     WORD32 i4_proc_thread_cnt;
 
     /**
      * Mutex used to keep the control calls thread-safe
      */
     void *pv_ctl_mutex;
 
     /**
      * Current active config parameters
      */
     cfg_params_t s_cfg;
 
     /**
      * Array containing the config parameter sets
      */
     cfg_params_t as_cfg[MAX_ACTIVE_CONFIG_PARAMS];
 
     /**
      * Color format used by encoder internally
      */
     IV_COLOR_FORMAT_T e_codec_color_format;
 
     /**
      * recon stride
      * (strides for luma and chroma are the same)
      */
     WORD32 i4_rec_strd;
 
     /**
      * Flag to enable/disable deblocking of a frame
      */
     WORD32 i4_disable_deblk_pic;
 
     /**
      * Number of continuous frames where deblocking was disabled
      */
     WORD32 i4_disable_deblk_pic_cnt;
 
     /**
      * frame type
      */
     PIC_TYPE_T pic_type;
 
     /**
      * frame qp
      */
     UWORD32 u4_frame_qp;
 
     /**
      * frame num
      */
     WORD32 i4_frame_num;
 
     /**
      *  slice_type
      */
     WORD32  i4_slice_type;
 
     /*
      * Force current frame to specific type
      */
     IV_PICTURE_CODING_TYPE_T force_curr_frame_type;
 
     /**
      *  IDR pic
      */
     UWORD32 u4_is_idr;
 
     /**
      *  idr_pic_id
      */
     WORD32 i4_idr_pic_id;
 
     /**
      * Flush mode
      */
     WORD32 i4_flush_mode;
 
     /**
      * Encode header mode
      */
     WORD32 i4_header_mode;
 
     /**
      * Flag to indicate if header has already
      * been generated when i4_api_call_cnt 0
      */
     UWORD32 u4_header_generated;
 
     /**
      * Encode generate header
      */
     WORD32 i4_gen_header;
 
     /**
      * To signal successful completion of init
      */
     WORD32 i4_init_done;
 
     /**
      * To signal that at least one picture was decoded
      */
     WORD32 i4_first_pic_done;
 
     /**
      * Reset flag - Codec is reset if this flag is set
      */
     WORD32 i4_reset_flag;
 
     /**
      * Current error code
      */
     WORD32 i4_error_code;
 
     /**
      * threshold residue
      */
     WORD32 u4_thres_resi;
 
     /**
      * disable intra inter gating
      */
     UWORD32 u4_inter_gate;
 
     /**
      * Holds mem records passed during init.
      * This will be used to return the mem records during retrieve call
      */
     iv_mem_rec_t *ps_mem_rec_backup;
 
     /**
      * Flag to determine if the entropy thread is active
      */
     volatile UWORD32 au4_entropy_thread_active[MAX_CTXT_SETS];
 
     /**
      * Mutex used to keep the entropy calls thread-safe
      */
     void *pv_entropy_mutex;
 
     /**
      * Job queue buffer base
      */
     void *pv_proc_jobq_buf, *pv_entropy_jobq_buf;
 
     /**
      * Job Queue mem tab size
      */
     WORD32 i4_proc_jobq_buf_size, i4_entropy_jobq_buf_size;
 
     /**
      * Memory for MV Bank buffer manager
      */
     void *pv_mv_buf_mgr_base;
 
     /**
      * MV Bank buffer manager
      */
     void *pv_mv_buf_mgr;
 
     /**
      * Pointer to MV Buf structure array
      */
     void *ps_mv_buf;
 
     /**
      * Base address for Motion Vector bank buffer
      */
     void *pv_mv_bank_buf_base;
 
     /**
      * MV Bank size allocated
      */
     WORD32 i4_total_mv_bank_size;
 
     /**
      * Memory for Picture buffer manager for reference pictures
      */
     void *pv_ref_buf_mgr_base;
 
     /**
      * Picture buffer manager for reference pictures
      */
     void *pv_ref_buf_mgr;
 
     /**
      * Number of reference buffers added to the buffer manager
      */
     WORD32 i4_ref_buf_cnt;
 
     /**
      * Pointer to Pic Buf structure array
      */
     void *ps_pic_buf;
 
     /**
      * Base address for Picture buffer
      */
     void *pv_pic_buf_base;
 
     /**
      * Total pic buffer size allocated
      */
     WORD32 i4_total_pic_buf_size;
 
     /**
      * Memory for Buffer manager for output buffers
      */
      void *pv_out_buf_mgr_base;
 
     /**
      * Buffer manager for output buffers
      */
      void *pv_out_buf_mgr;
 
     /**
      * Current output buffer's buffer ID
      */
     WORD32 i4_out_buf_id;
 
     /**
      * Number of output buffers added to the buffer manager
      */
     WORD32 i4_out_buf_cnt;
 
     /**
      * Memory for Picture buffer manager for input buffers
      */
      void *pv_inp_buf_mgr_base;
 
     /**
      * Picture buffer manager for input buffers
      */
      void *pv_inp_buf_mgr;
 
     /**
      * Current input buffer's buffer ID
      */
     WORD32 i4_inp_buf_id;
 
     /**
      * Number of input buffers added to the buffer manager
      */
     WORD32 i4_inp_buf_cnt;
 
     /**
      * Current input buffer
      */
     pic_buf_t *ps_inp_buf;
 
     /**
      * Pointer to dpb manager structure
      */
     void *pv_dpb_mgr;
 
     /**
      * Pointer to base of Sequence parameter set structure array
      */
     sps_t *ps_sps_base;
 
     /**
      * Pointer to base of Picture parameter set structure array
      */
     pps_t *ps_pps_base;
 
     /**
      *  seq_parameter_set_id
      */
     WORD32 i4_sps_id;
 
     /**
      *  pic_parameter_set_id
      */
     WORD32 i4_pps_id;
 
     /**
      * Pointer to base of slice header structure array
      */
     slice_header_t *ps_slice_hdr_base;
 
     /**
      * packed residue coeff data size for 1 row of mbs
      */
     UWORD32 u4_size_coeff_data;
 
     /**
      * packed header data size for 1 row of mbs
      */
     UWORD32 u4_size_header_data;
 
     /**
      * Processing context - One for each processing thread
      * Create two sets, each set used for alternate frames
      */
     process_ctxt_t as_process[MAX_PROCESS_CTXT];
 
     /**
      * Thread handle for each of the processing threads
      */
     void *apv_proc_thread_handle[MAX_PROCESS_THREADS];
 
     /**
      * Thread created flag for each of the processing threads
      */
     WORD32 ai4_process_thread_created[MAX_PROCESS_THREADS];
 
     /**
      * Void pointer to process job context
      */
     void *pv_proc_jobq, *pv_entropy_jobq;
 
     /**
      * Number of MBs processed together for better instruction cache handling
      */
     WORD32 i4_proc_nmb;
 
     /**
      * Previous POC lsb
      */
     WORD32 i4_prev_poc_lsb;
 
     /**
      * Previous POC msb
      */
     WORD32 i4_prev_poc_msb;
 
     /**
      * Max POC lsb that has arrived till now
      */
     WORD32 i4_max_prev_poc_lsb;
 
     /**
      * Context for format conversion
      */
     fmt_conv_t s_fmt_conv;
 
     /**
      * Absolute pic order count
      */
     WORD32 i4_abs_pic_order_cnt;
 
     /**
      *  Pic order count of lsb
      */
     WORD32 i4_pic_order_cnt_lsb;
 
     /**
      * Array giving current picture being processed in each context set
      */
     WORD32 ai4_pic_cnt[MAX_CTXT_SETS];
 
     /*
      * Min sad to search for
      */
     UWORD32 u4_min_sad;
 
     /**
      * Reference picture set
      */
     ref_set_t as_ref_set[MAX_DPB_SIZE + MAX_CTXT_SETS];
 
 
     /*
      * Air pic cnt
      * Contains the number of pictures that have been encoded with air
      * This value is moudulo air refresh period
      */
     WORD32 i4_air_pic_cnt;
 
     /*
      * Intra refresh map
      * Stores the frames at which intra refresh should occur for a MB
      */
     UWORD16 *pu2_intr_rfrsh_map;
 
     /*
      * Indicates if the current frame is used as a reference frame
      */
     UWORD32 u4_is_curr_frm_ref;
 
     /*
      * Indicates if there can be non reference frames in the stream
      */
     WORD32 i4_non_ref_frames_in_stream;
 
     /*
      * Memory for color space conversion for luma plane
      */
     UWORD8 *pu1_y_csc_buf_base;
 
     /*
      * Memory for color space conversion foe chroma plane
      */
     UWORD8 *pu1_uv_csc_buf_base;
 
     /**
      * Function pointers for intra pred leaf level functions luma
      */
     pf_intra_pred apf_intra_pred_16_l[MAX_I16x16];
     pf_intra_pred apf_intra_pred_8_l[MAX_I8x8];
     pf_intra_pred apf_intra_pred_4_l[MAX_I4x4];
 
     /**
      * Function pointers for intra pred leaf level functions chroma
      */
     pf_intra_pred apf_intra_pred_c[MAX_CH_I8x8];
 
     /**
      * luma core coding function pointer
      */
     UWORD8 (*luma_energy_compaction[4])(process_ctxt_t *ps_proc);
 
     /**
      * chroma core coding function pointer
      */
     UWORD8 (*chroma_energy_compaction[2])(process_ctxt_t *ps_proc);
 
     /**
      * forward transform for intra blk of mb type 16x16
      */
     ih264_luma_16x16_resi_trans_dctrans_quant_ft *pf_resi_trans_dctrans_quant_16x16;
 
     /**
      * inverse transform for intra blk of mb type 16x16
      */
     ih264_luma_16x16_idctrans_iquant_itrans_recon_ft *pf_idctrans_iquant_itrans_recon_16x16;
 
     /**
      * forward transform for 4x4 blk luma
      */
     ih264_resi_trans_quant_ft *pf_resi_trans_quant_4x4;
 
     /**
      * forward transform for 4x4 blk luma
      */
     ih264_resi_trans_quant_ft *pf_resi_trans_quant_chroma_4x4;
 
     /*
      * hadamard transform and quant for a 4x4 block
      */
     ih264_hadamard_quant_ft *pf_hadamard_quant_4x4;
 
     /*
      *  hadamard transform and quant for a 4x4 block
      */
     ih264_hadamard_quant_ft *pf_hadamard_quant_2x2_uv;
 
     /**
      * inverse transform for 4x4 blk
      */
     ih264_iquant_itrans_recon_ft *pf_iquant_itrans_recon_4x4;
 
     /**
      * inverse transform for chroma 4x4 blk
      */
     ih264_iquant_itrans_recon_chroma_ft *pf_iquant_itrans_recon_chroma_4x4;
 
     /**
      * inverse transform for 4x4 blk with only single dc coeff
      */
     ih264_iquant_itrans_recon_ft *pf_iquant_itrans_recon_4x4_dc;
 
     /**
      * inverse transform for chroma 4x4 blk with only single dc coeff
      */
     ih264_iquant_itrans_recon_chroma_ft *pf_iquant_itrans_recon_chroma_4x4_dc;
 
     /*
      * Inverse hadamard transform and iquant for a 4x4 block
      */
     ih264_ihadamard_scaling_ft *pf_ihadamard_scaling_4x4;
 
     /*
      * Inverse hadamard transform and iquant for a 4x4 block
      */
     ih264_ihadamard_scaling_ft *pf_ihadamard_scaling_2x2_uv;
 
     /*
      * Function for interleave copy*
      */
     ih264_interleave_copy_ft *pf_interleave_copy;
 
     /**
      * forward transform for 8x8 blk
      */
     ih264_resi_trans_quant_ft *pf_resi_trans_quant_8x8;
 
     /**
      * inverse transform for 8x8 blk
      */
     /**
      * inverse transform for 4x4 blk
      */
     ih264_iquant_itrans_recon_ft *pf_iquant_itrans_recon_8x8;
 
     /**
      * forward transform for chroma MB
      */
     ih264_chroma_8x8_resi_trans_dctrans_quant_ft *pf_resi_trans_dctrans_quant_8x8_chroma;
 
     /**
      * inverse transform for chroma MB
      */
     ih264_idctrans_iquant_itrans_recon_ft *pf_idctrans_iquant_itrans_recon_8x8_chroma;
 
     /**
      * deblock vertical luma edge with blocking strength 4
      */
     ih264_deblk_edge_bs4_ft *pf_deblk_luma_vert_bs4;
 
     /**
      * deblock vertical chroma edge with blocking strength 4
      */
     ih264_deblk_chroma_edge_bs4_ft *pf_deblk_chroma_vert_bs4;
 
     /**
      * deblock vertical luma edge with blocking strength less than 4
      */
     ih264_deblk_edge_bslt4_ft *pf_deblk_luma_vert_bslt4;
 
     /**
      * deblock vertical chroma edge with blocking strength less than 4
      */
     ih264_deblk_chroma_edge_bslt4_ft *pf_deblk_chroma_vert_bslt4;
 
     /**
      * deblock horizontal luma edge with blocking strength 4
      */
     ih264_deblk_edge_bs4_ft *pf_deblk_luma_horz_bs4;
 
     /**
      * deblock horizontal chroma edge with blocking strength 4
      */
     ih264_deblk_chroma_edge_bs4_ft *pf_deblk_chroma_horz_bs4;
 
     /**
      * deblock horizontal luma edge with blocking strength less than 4
      */
     ih264_deblk_edge_bslt4_ft *pf_deblk_luma_horz_bslt4;
 
     /**
      * deblock horizontal chroma edge with blocking strength less than 4
      */
     ih264_deblk_chroma_edge_bslt4_ft *pf_deblk_chroma_horz_bslt4;
 
 
     /**
      * functions for padding
      */
     pf_pad pf_pad_top;
     pf_pad pf_pad_bottom;
     pf_pad pf_pad_left_luma;
     pf_pad pf_pad_left_chroma;
     pf_pad pf_pad_right_luma;
     pf_pad pf_pad_right_chroma;
 
     /**
      * Inter pred leaf level functions
      */
     ih264_inter_pred_luma_ft    *pf_inter_pred_luma_copy;
     ih264_inter_pred_luma_ft    *pf_inter_pred_luma_horz;
     ih264_inter_pred_luma_ft    *pf_inter_pred_luma_vert;
     pf_inter_pred_luma_bilinear  pf_inter_pred_luma_bilinear;
     ih264_inter_pred_chroma_ft  *pf_inter_pred_chroma;
 
     /**
      * fn ptrs for compute sad routines
      */
     ime_compute_sad_ft *apf_compute_sad_16x16[2];
     ime_compute_sad_ft *pf_compute_sad_16x8;
 
 
     /**
      * Function pointer for computing ME
      * 1 for PSLICE and 1 for BSLICE
      */
     ih264e_compute_me_ft *apf_compute_me[2];
 
     /**
      * Function pointers for computing SKIP parameters
      */
     ih264e_skip_params_ft *apf_find_skip_params_me[2];
 
     /**
      * fn ptrs for memory handling operations
      */
     pf_memcpy pf_mem_cpy;
     pf_memset pf_mem_set;
     pf_memcpy_mul8 pf_mem_cpy_mul8;
     pf_memset_mul8 pf_mem_set_mul8;
 
     /**
      * intra mode eval -encoder level function
      */
     pf_evaluate_intra_modes pf_ih264e_evaluate_intra16x16_modes;
     pf_evaluate_intra_modes pf_ih264e_evaluate_intra_chroma_modes;
     pf_evaluate_intra_4x4_modes pf_ih264e_evaluate_intra_4x4_modes;
 
     /* Half pel generation function - encoder level
      *
      */
     pf_sixtapfilter_horz pf_ih264e_sixtapfilter_horz;
     pf_sixtap_filter_2dvh_vert pf_ih264e_sixtap_filter_2dvh_vert;
 
     /**
      * color space conversion form YUV 420P to YUV 420Sp
      */
     pf_fmt_conv_420p_to_420sp pf_ih264e_conv_420p_to_420sp;
 
 
     /**
      * color space conversion form YUV 420P to YUV 420Sp
      */
     pf_fmt_conv_422ile_to_420sp pf_ih264e_fmt_conv_422i_to_420sp;
 
     /**
      * write mb layer for a given slice I, P, B
      */
     IH264E_ERROR_T (*pf_write_mb_syntax_layer[2][3]) ( entropy_ctxt_t *ps_ent_ctxt );
 
     /**
      * Output buffer
      */
     out_buf_t as_out_buf[MAX_CTXT_SETS];
 
     /**
      * recon buffer
      */
     rec_buf_t as_rec_buf[MAX_CTXT_SETS];
 
     /**
      * rate control context
      */
     rate_control_ctxt_t s_rate_control;
 
     /**
      * input buffer queue
      */
-    inp_buf_t as_inp_list[MAX_NUM_BFRAMES];
+    inp_buf_t as_inp_list[MAX_NUM_INP_FRAMES];
 
     /**
      * Flag to indicate if any IDR requests are pending
      */
     WORD32 i4_pending_idr_flag;
 
     /*
     *Flag to indicate if we have recived the last input frame
     */
     WORD32 i4_last_inp_buff_received;
 
 };
 
 #endif /* IH264E_STRUCTS_H_ */
diff --git a/encoder/ih264e_utils.c b/encoder/ih264e_utils.c
index 455aa9e..c813f57 100644
--- a/encoder/ih264e_utils.c
+++ b/encoder/ih264e_utils.c
@@ -119,346 +119,356 @@
 /**
  *******************************************************************************
  *
  * @brief
  *  Queues the current buffer, gets back a another buffer for encoding with corrent
  *  picture type
  *
  * @par Description:
  *      This function performs 3 distinct but related functions.
  *      1) Maintains an input queue [Note the the term queue donot imply a
  *         first-in first-out logic here] that queues input and dequeues them so
  *         that input frames can be encoded at any predetermined encoding order
  *      2) Uses RC library to decide which frame must be encoded in current pass
  *         and which picture type it must be encoded to.
  *      3) Uses RC library to decide the QP at which current frame has to be
  *         encoded
  *      4) Determines if the current picture must be encoded or not based on
  *         PRE-ENC skip
  *
  *     Input queue is used for storing input buffers till they are used for
  *     encoding. This queue is maintained at ps_codec->as_inp_list. Whenever a
  *     valid input comes, it is added to the end of queue. This same input is
  *     added to RC queue using the identifier as ps_codec->i4_pic_cnt. Hence any
  *     pic from RC can be located in the input queue easily.
  *
  *     The dequeue operation does not start till we have ps_codec->s_cfg.u4_max_num_bframes
  *     frames in the queue. THis is done in order to ensure that once output starts
  *     we will have a constant stream of output with no gaps.
  *
  *     THe output frame order is governed by RC library. When ever we dequeue a
  *     buffer from RC library, it ensures that we will get them in encoding order
  *     With the output of RC library, we can use the picture id to dequeue the
  *     corresponding buffer from input queue and encode it.
  *
  *     Condition at the end of stream.
  *     -------------------------------
  *      At the last valid buffer from the app, we will get ps_ive_ip->u4_is_last
  *      to be set. This will the given to lib when appropriate input buffer is
  *      given to encoding.
  *
  *      Since we have to output is not in sync with input, we will have frames to
  *      encode even after we recive the last vaild input buffer. Hence we have to
  *      make sure that we donot queue any new buffers once we get the flag [It may
  *      mess up GOP ?]. This is acheived by setting ps_codec->i4_last_inp_buff_received
  *      to act as a permenent marker for last frame recived [This may not be needed,
  *      because in our current app, all buffers after the last are marked as last.
  *      But can we rely on that?] . Hence after this flgag is set no new buffers are
  *      queued.
  *
  * @param[in] ps_codec
  *   Pointer to codec descriptor
  *
  * @param[in] ps_ive_ip
  *   Current input buffer to the encoder
  *
  * @param[out] ps_inp
  *   Buffer to be encoded in the current pass
  *
  * @returns
  *   Flag indicating if we have a pre-enc skip or not
  *
  * @remarks
  * TODO (bpic)
  *  The check for null ans is last is redudent.
  *  Need to see if we can remove it
  *
  *******************************************************************************
  */
 WORD32 ih264e_input_queue_update(codec_t *ps_codec,
                                  ive_video_encode_ip_t *ps_ive_ip,
                                  inp_buf_t *ps_enc_buff)
 {
 
     inp_buf_t *ps_inp_buf;
     picture_type_e e_pictype;
     WORD32 i4_skip;
     UWORD32 ctxt_sel, u4_pic_id, u4_pic_disp_id;
-    UWORD8 u1_frame_qp;
+    UWORD8 u1_frame_qp, i;
     UWORD32 max_frame_bits = 0x7FFFFFFF;
 
     /*  Mark that the last input frame has been received */
     if (ps_ive_ip->u4_is_last == 1)
     {
         ps_codec->i4_last_inp_buff_received = 1;
     }
 
     if (ps_ive_ip->s_inp_buf.apv_bufs[0] == NULL
                     && !ps_codec->i4_last_inp_buff_received)
     {
         ps_enc_buff->s_raw_buf.apv_bufs[0] = NULL;
         ps_enc_buff->u4_is_last = ps_ive_ip->u4_is_last;
         return 0;
     }
 
     /***************************************************************************
      * Check for pre enc skip
      *   When src and target frame rates donot match, we skip some frames to
      *   maintain the relation ship between them
      **************************************************************************/
     {
         WORD32 skip_src;
 
         skip_src = ih264e_update_rc_framerates(
                         ps_codec->s_rate_control.pps_rate_control_api,
                         ps_codec->s_rate_control.pps_pd_frm_rate,
                         ps_codec->s_rate_control.pps_time_stamp,
                         ps_codec->s_rate_control.pps_frame_time);
 
         if (skip_src)
         {
             ps_enc_buff->u4_is_last = ps_ive_ip->u4_is_last;
             return 1;
         }
     }
 
     /***************************************************************************
      *Queue the input to the queue
      **************************************************************************/
     ps_inp_buf = &(ps_codec->as_inp_list[ps_codec->i4_pic_cnt
-                                         % MAX_NUM_BFRAMES]);
+                                         % MAX_NUM_INP_FRAMES]);
 
     /* copy input info. to internal structure */
     ps_inp_buf->s_raw_buf = ps_ive_ip->s_inp_buf;
     ps_inp_buf->u4_timestamp_low = ps_ive_ip->u4_timestamp_low;
     ps_inp_buf->u4_timestamp_high = ps_ive_ip->u4_timestamp_high;
     ps_inp_buf->u4_is_last = ps_ive_ip->u4_is_last;
     ps_inp_buf->pv_mb_info = ps_ive_ip->pv_mb_info;
     ps_inp_buf->u4_mb_info_type = ps_ive_ip->u4_mb_info_type;
     ps_inp_buf->pv_pic_info = ps_ive_ip->pv_pic_info;
     ps_inp_buf->u4_pic_info_type = ps_ive_ip->u4_pic_info_type;
 
     /***************************************************************************
      * Now we should add the picture to RC stack here
      **************************************************************************/
     /*
      * If an I frame has been requested, ask  RC to force it
      * For IDR requests, we have to ask RC to force I and set IDR by our selves
      * since RC Donot know about IDR. For forcing an IDR at dequeue stage we
      * should record that an IDR has been requested some where. Hence we will
      * store it in the u4_idr_inp_list at a position same as that of input frame
      */
     {
         WORD32 i4_force_idr, i4_force_i;
 
         i4_force_idr = (ps_codec->force_curr_frame_type == IV_IDR_FRAME);
         i4_force_idr |= !(ps_codec->i4_pic_cnt % ps_codec->s_cfg.u4_idr_frm_interval);
 
         i4_force_i = (ps_codec->force_curr_frame_type == IV_I_FRAME);
 
         ps_codec->i4_pending_idr_flag |= i4_force_idr;
 
         if ((ps_codec->i4_pic_cnt > 0) && (i4_force_idr || i4_force_i))
         {
             irc_force_I_frame(ps_codec->s_rate_control.pps_rate_control_api);
         }
         ps_codec->force_curr_frame_type = IV_NA_FRAME;
     }
 
     irc_add_picture_to_stack(ps_codec->s_rate_control.pps_rate_control_api,
                              ps_codec->i4_pic_cnt);
 
 
     /* Delay */
     if (ps_codec->i4_encode_api_call_cnt
                     < (WORD32)(ps_codec->s_cfg.u4_num_bframes))
     {
         ps_enc_buff->s_raw_buf.apv_bufs[0] = NULL;
         ps_enc_buff->u4_is_last = 0;
         return 0;
     }
 
     /***************************************************************************
      * Get a new pic to encode
      **************************************************************************/
     /* Query the picture_type */
     e_pictype = ih264e_rc_get_picture_details(
                     ps_codec->s_rate_control.pps_rate_control_api, (WORD32 *)(&u4_pic_id),
                     (WORD32 *)(&u4_pic_disp_id));
 
     switch (e_pictype)
     {
         case I_PIC:
             ps_codec->pic_type = PIC_I;
             break;
         case P_PIC:
             ps_codec->pic_type = PIC_P;
             break;
         case B_PIC:
             ps_codec->pic_type = PIC_B;
             break;
         default:
             ps_codec->pic_type = PIC_NA;
             ps_enc_buff->s_raw_buf.apv_bufs[0] = NULL;
             return 0;
     }
 
     /* Set IDR if it has been requested */
     if (ps_codec->pic_type == PIC_I)
     {
         ps_codec->pic_type = ps_codec->i4_pending_idr_flag ?
                                     PIC_IDR : ps_codec->pic_type;
         ps_codec->i4_pending_idr_flag = 0;
     }
 
     /* Get current frame Qp */
     u1_frame_qp = (UWORD8)irc_get_frame_level_qp(
                     ps_codec->s_rate_control.pps_rate_control_api, e_pictype,
                     max_frame_bits);
     ps_codec->u4_frame_qp = gau1_mpeg2_to_h264_qmap[u1_frame_qp];
 
     /*
      * copy the pic id to poc because the display order is assumed to be same
      * as input order
      */
     ps_codec->i4_poc = u4_pic_id;
 
     /***************************************************************************
      * Now retrieve the correct picture from the queue
      **************************************************************************/
 
     /* Mark the skip flag   */
     i4_skip = 0;
     ctxt_sel = ps_codec->i4_encode_api_call_cnt % MAX_CTXT_SETS;
     ps_codec->s_rate_control.pre_encode_skip[ctxt_sel] = i4_skip;
 
     /* Get a buffer to encode */
-    ps_inp_buf = &(ps_codec->as_inp_list[u4_pic_id % MAX_NUM_BFRAMES]);
+    ps_inp_buf = &(ps_codec->as_inp_list[u4_pic_id % MAX_NUM_INP_FRAMES]);
 
     /* copy dequeued input to output */
     ps_enc_buff->s_raw_buf = ps_inp_buf->s_raw_buf;
     ps_enc_buff->u4_timestamp_low = ps_inp_buf->u4_timestamp_low;
     ps_enc_buff->u4_timestamp_high = ps_inp_buf->u4_timestamp_high;
     ps_enc_buff->u4_is_last = ps_inp_buf->u4_is_last;
     ps_enc_buff->pv_mb_info = ps_inp_buf->pv_mb_info;
     ps_enc_buff->u4_mb_info_type = ps_inp_buf->u4_mb_info_type;
     ps_enc_buff->pv_pic_info = ps_inp_buf->pv_pic_info;
     ps_enc_buff->u4_pic_info_type = ps_inp_buf->u4_pic_info_type;
 
     /* Special case for encoding trailing B frames
      *
      * In encoding streams with B frames it may happen that we have a B frame
      * at the end without a P/I frame after it. Hence when we are dequeing from
      * the RC, it will return the P frame [next in display order but before in
      * encoding order] first. Since the dequeue happens for an invalid frame we
      * will get a frame with null buff and set u4_is_last. Hence lib with return
      * last frame flag at this point and will stop encoding.
      *
      * Since for the last B frame, we does not have the forward ref frame
      * it makes sense to force it into P.
      *
      * To solve this, in case the current frame is P and if the last frame flag
      * is set, we need to see if there is and pending B frames. If there are any,
      * we should just encode that picture as the current P frame and set
      * that B frame as the last frame. Hence the encoder will terminate naturally
      * once that B-frame is encoded after all the in between frames.
      *
      * Since we cannot touch RC stack directly, the option of actually swapping
      * frames in RC is ruled out. We have to modify the as_inp_list to simulate
      * such a behavior by RC. We can do that by
      *  1) Search through as_inp_list to locate the largest u4_timestamp_low less
      *     than current u4_timestamp_low. This will give us the last B frame before
      *     the current P frame. Note that this will handle pre encode skip too since
      *     queue happens after pre enc skip.
      *  2) Swap the position in as_inp_list. Hence now the last B frame is
      *     encoded as P frame. And the new last B frame will have u4_is_last
      *     set so that encoder will end naturally once we reached that B frame
      *     or any subsequent frame. Also the current GOP will have 1 less B frame
      *     Since we are swapping, the poc will also be in-order.
      *  3) In case we have an IPP stream, the result of our search will be an
      *     I/P frame which is already encoded. Thus swap and encode will result
      *     in encoding of duplicate frames. Hence to avoid this we will only
      *     have this work around in case of u4_num_bframes > 0.
      *
      *     In case we have forced an I/IDR frame In between this P frame and
      *     the last B frame -> This cannot happen as the current P frame is
      *     supposed to have u4_is_last set. Thus forcing an I/ IDR after this
      *     is illogical.
      *
      *     In cae if we have forced an I such that the frame just before last frame
      *     in is I/P -> This case will never arise. Since we have a closed GOP now,
      *     once we force an I, the gop gets reset, hence there will be a B between
      *     I/P and I/P.
      */
     if (ps_enc_buff->u4_is_last && (ps_codec->pic_type == PIC_P)
-                    && ps_codec->s_cfg.u4_num_bframes && (ps_codec->i4_poc > 1))
+                    && ps_codec->s_cfg.u4_num_bframes)
     {
-        UWORD32 u4_cntr, u4_lst_bframe;
-        inp_buf_t *ps_swap_buff, *ps_inp_list, *ps_cur_pic;
-
-        u4_cntr = (u4_pic_id + 1) % MAX_NUM_BFRAMES;
-        u4_lst_bframe = u4_pic_id ? ((u4_pic_id - 1) % MAX_NUM_BFRAMES) : (MAX_NUM_BFRAMES - 1);
+        WORD32 cntr;
+        WORD32 lst_bframe = -1;
+        UWORD32 u4_timestamp_low = 0;
+        UWORD32 u4_timestamp_high = 0;
+        inp_buf_t *ps_swap_buff, *ps_inp_list;
 
         ps_inp_list = &ps_codec->as_inp_list[0];
-        ps_cur_pic = &ps_inp_list[u4_pic_id % MAX_NUM_BFRAMES];
 
-        /* Now search the pic in most recent past to current frame */
-        for(; u4_cntr != (u4_pic_id % MAX_NUM_BFRAMES);
-                        u4_cntr = ((u4_cntr + 1) % MAX_NUM_BFRAMES))
+        /* Now search the inp list for highest timestamp */
+        for(cntr = 0; cntr < MAX_NUM_INP_FRAMES; cntr++)
         {
-            if ( (ps_inp_list[u4_cntr].u4_timestamp_low  <= ps_cur_pic->u4_timestamp_low) &&
-                 (ps_inp_list[u4_cntr].u4_timestamp_high <= ps_cur_pic->u4_timestamp_high) &&
-                 (ps_inp_list[u4_cntr].u4_timestamp_low  >= ps_inp_list[u4_lst_bframe].u4_timestamp_low) &&
-                 (ps_inp_list[u4_cntr].u4_timestamp_high >= ps_inp_list[u4_lst_bframe].u4_timestamp_high))
+            if(ps_inp_list[cntr].s_raw_buf.apv_bufs[0] != NULL)
             {
-                u4_lst_bframe = u4_cntr;
+                if ((ps_inp_list[cntr].u4_timestamp_high  > u4_timestamp_high) ||
+                    (ps_inp_list[cntr].u4_timestamp_high  == u4_timestamp_high &&
+                     ps_inp_list[cntr].u4_timestamp_low  > u4_timestamp_low))
+                {
+                    u4_timestamp_low = ps_inp_list[cntr].u4_timestamp_low;
+                    u4_timestamp_high = ps_inp_list[cntr].u4_timestamp_high;
+                    lst_bframe = cntr;
+                }
             }
         }
 
-        ps_swap_buff = &(ps_codec->as_inp_list[u4_lst_bframe]);
-
-        /* copy the last B buffer to output */
-        *ps_enc_buff = *ps_swap_buff;
+        if(lst_bframe != -1)
+        {
+            ps_swap_buff = &(ps_codec->as_inp_list[lst_bframe]);
 
-        /* Store the current buf into the queue in place of last B buf */
-        *ps_swap_buff = *ps_inp_buf;
+            /* copy the last B buffer to output */
+            *ps_enc_buff = *ps_swap_buff;
 
+            /* Store the current buf into the queue in place of last B buf */
+            *ps_swap_buff = *ps_inp_buf;
+        }
     }
 
     if (ps_enc_buff->u4_is_last)
     {
         ps_codec->pic_type = PIC_NA;
     }
 
+    /* The buffer in the queue is set to NULL to specify that encoding is done for that frame */
+    for(i = 0; i < 3; i++)
+    {
+        ps_inp_buf->s_raw_buf.apv_bufs[i] = NULL;
+    }
+
     /* Return the buffer status */
     return (0);
 }
 
 /**
 *******************************************************************************
 *
 * @brief
 *  Used to get minimum level index for a given picture size
 *
 * @par Description:
 *  Gets the minimum level index and then gets corresponding level.
 *  Also used to ignore invalid levels like 2.3, 3.3 etc
 *
 * @param[in] level
 *  Level of the stream
 *
 * @returns  Level index for a given level
 *
 * @remarks
 *
 *******************************************************************************
 */
diff --git a/encoder/x86/ih264e_intra_modes_eval_ssse3.c b/encoder/x86/ih264e_intra_modes_eval_ssse3.c
index c11d7f2..ea8a6c8 100644
--- a/encoder/x86/ih264e_intra_modes_eval_ssse3.c
+++ b/encoder/x86/ih264e_intra_modes_eval_ssse3.c
@@ -427,396 +427,396 @@ void ih264e_evaluate_intra16x16_modes_ssse3(UWORD8 *pu1_src,
 /**
 ******************************************************************************
 *
 * @brief :Evaluate best intra 4x4 mode and do the prediction.
 *
 * @par Description
 *  This function evaluates intra 4x4 modes, computes corresponding sad
 *  and returns the buffer predicted with best mode.
 *
 * @param[in] pu1_src
 *  UWORD8 pointer to the source
 *
 ** @param[in] pu1_ngbr_pels
 *  UWORD8 pointer to neighbouring pels
 *
 * @param[out] pu1_dst
 *  UWORD8 pointer to the destination
 *
 * @param[in] src_strd
 *  integer source stride
 *
 * @param[in] dst_strd
 *  integer destination stride
 *
 * @param[in] u4_n_avblty
 * availability of neighbouring pixels
 *
 * @param[in] u4_intra_mode
 * Pointer to the variable in which best mode is returned
 *
 * @param[in] pu4_sadmin
 * Pointer to the variable in which minimum cost is returned
 *
 * @param[in] u4_valid_intra_modes
 * Says what all modes are valid
 *
 * * @param[in] u4_lambda
 * Lamda value for computing cost from SAD
 *
 * @param[in] u4_predictd_mode
 * Predicted mode for cost computation
 *
 * @return      none
 *
 ******************************************************************************
 */
 void ih264e_evaluate_intra_4x4_modes_ssse3(UWORD8 *pu1_src,
                                            UWORD8 *pu1_ngbr_pels,
                                            UWORD8 *pu1_dst,
                                            UWORD32 src_strd,
                                            UWORD32 dst_strd,
                                            WORD32 u4_n_avblty,
                                            UWORD32 *u4_intra_mode,
                                            WORD32 *pu4_sadmin,
                                            UWORD32 u4_valid_intra_modes,
                                            UWORD32 u4_lambda,
                                            UWORD32 u4_predictd_mode)
 {
     WORD32 left, top;
     WORD32 sad[MAX_I4x4] = { INT_MAX, INT_MAX, INT_MAX, INT_MAX, INT_MAX,
                              INT_MAX, INT_MAX, INT_MAX, INT_MAX };
     WORD32 cost[MAX_I4x4] = { INT_MAX, INT_MAX, INT_MAX, INT_MAX, INT_MAX,
                               INT_MAX, INT_MAX, INT_MAX, INT_MAX };
 
     WORD32 min_cost;
     UWORD32 lambda4 = u4_lambda << 2;
     WORD32 dst_strd2, dst_strd3;
 
     __m128i left_top_16x8b, src_16x8b, pred0_16x8b, sad_8x16b;
     __m128i pred1_16x8b, pred2_16x8b, pred3_16x8b, pred4_16x8b;
     __m128i pred5_16x8b, pred6_16x8b, pred7_16x8b, pred8_16x8b;
     __m128i shuffle_16x8b, zero_vector, mask_low_32b;
 
     left = (u4_n_avblty & LEFT_MB_AVAILABLE_MASK);
     top  =  (u4_n_avblty & TOP_MB_AVAILABLE_MASK) >> 2;
 
     dst_strd2 = dst_strd << 1;
     dst_strd3 = dst_strd + dst_strd2;
 
     // loading the 4x4 source block and neighbouring pixels
     {
         __m128i row1_16x8b, row2_16x8b;
 
         row1_16x8b = _mm_loadl_epi64((__m128i *)pu1_src);
         row2_16x8b = _mm_loadl_epi64((__m128i *)(pu1_src + src_strd));
         left_top_16x8b = _mm_loadu_si128((__m128i *)pu1_ngbr_pels);
 
         pu1_src += src_strd << 1;
         src_16x8b = _mm_unpacklo_epi32(row1_16x8b, row2_16x8b);
 
         row1_16x8b = _mm_loadl_epi64((__m128i *)pu1_src);
         row2_16x8b = _mm_loadl_epi64((__m128i *)(pu1_src + src_strd));
         zero_vector = _mm_setzero_si128();
 
         row1_16x8b = _mm_unpacklo_epi32(row1_16x8b, row2_16x8b);
         src_16x8b = _mm_unpacklo_epi64(src_16x8b, row1_16x8b);
     }
 
     /* Computing SADs*/
     if(u4_valid_intra_modes & 1)/* VERT mode valid ????*/
     {
         pred0_16x8b = _mm_srli_si128(left_top_16x8b, 5);
         pred0_16x8b = _mm_shuffle_epi32(pred0_16x8b, 0);
         sad_8x16b = _mm_sad_epu8(src_16x8b, pred0_16x8b);
 
         sad[VERT_I4x4] = _mm_extract_epi16(sad_8x16b, 0) + _mm_extract_epi16(sad_8x16b, 4);
         cost[VERT_I4x4] = sad[VERT_I4x4] + ((u4_predictd_mode == VERT_I4x4) ? u4_lambda: lambda4);
     }
 
     if(u4_valid_intra_modes & 2)/* HORZ mode valid ????*/
     {
         shuffle_16x8b = _mm_setr_epi8(3, 3, 3, 3, 2, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0);
         pred1_16x8b = _mm_shuffle_epi8(left_top_16x8b, shuffle_16x8b);
 
         sad_8x16b = _mm_sad_epu8(src_16x8b, pred1_16x8b);
 
         sad[HORZ_I4x4] = _mm_extract_epi16(sad_8x16b, 0) + _mm_extract_epi16(sad_8x16b, 4);
         cost[HORZ_I4x4] = sad[HORZ_I4x4] + ((u4_predictd_mode == HORZ_I4x4) ? u4_lambda: lambda4);
     }
 
     if(u4_valid_intra_modes & 4)/* DC mode valid ????*/
     {
         if(top + left)
         {
             WORD32 shft = 1, dcval = 0;
 
             __m128i val_16x8b, temp_16x8b, temp_8x16b;
 
             val_16x8b = _mm_setzero_si128();
 
             if(top)
             {
                 temp_16x8b = _mm_srli_si128(left_top_16x8b, 5);
                 val_16x8b = _mm_alignr_epi8(temp_16x8b, val_16x8b, 4);
                 shft ++;
                 dcval += 2;
             }
             if(left)
             {
                 val_16x8b = _mm_alignr_epi8(left_top_16x8b, val_16x8b, 4);
                 shft++;
                 dcval += 2;
             }
 
             temp_8x16b = _mm_sad_epu8(val_16x8b, zero_vector);
             dcval += _mm_extract_epi16(temp_8x16b, 4);
             dcval = dcval >> shft;
             pred2_16x8b = _mm_set1_epi8(dcval);
         }
         else
-            pred2_16x8b = _mm_set1_epi8(128);
+            pred2_16x8b = _mm_set1_epi8(-128);
 
         sad_8x16b = _mm_sad_epu8(src_16x8b, pred2_16x8b);
 
         sad[DC_I4x4] = _mm_extract_epi16(sad_8x16b, 0) + _mm_extract_epi16(sad_8x16b, 4);
         cost[DC_I4x4] = sad[DC_I4x4] + ((u4_predictd_mode == DC_I4x4) ? u4_lambda: lambda4);
     }
 
     if(u4_valid_intra_modes > 7)/* if modes other than VERT, HORZ and DC are  valid ????*/
     {
         __m128i w11_16x8b, w121_16x8b;
         __m128i temp1_16x8b, temp2_16x8b;
 
         /* Performing FILT121 and FILT11 operation for all neighbour values*/
         {
             __m128i temp1_8x16b, temp2_8x16b, temp3_8x16b;
             __m128i const_2_8x16b;
 
             const_2_8x16b = _mm_set1_epi16(2);
 
             temp1_8x16b = _mm_unpacklo_epi8(left_top_16x8b, zero_vector);   //l3 l2 l1 l0 tl t0 t1 t2
             temp2_8x16b = _mm_slli_si128(temp1_8x16b, 2);                   // 0 l3 l2 l1 l0 tl t0 t1
             temp2_8x16b = _mm_shufflelo_epi16(temp2_8x16b, 0xe5);           //l3 l3 l2 l1 l0 tl t0 t1
 
             temp1_8x16b = _mm_add_epi16(temp1_8x16b, temp2_8x16b);          //l3+l3  l3+l2       l2+l1...       t1+t2
             temp2_8x16b = _mm_slli_si128(temp1_8x16b, 2);                   //l3+l3  l3+l3       l3+l2...       t0+t1
             temp2_8x16b = _mm_shufflelo_epi16(temp2_8x16b, 0xe5);
             temp1_8x16b = _mm_add_epi16(temp1_8x16b, temp2_8x16b);          //4*l3   l3+2*l3+l2  l3+2*l2+l1...  t0+2*t1+t2
 
             temp1_8x16b = _mm_add_epi16(const_2_8x16b, temp1_8x16b);        //4*l3+2 3*l3+l2+2   l3+2*l2+l1+2.. t0+2*t1+t2+2
             temp1_8x16b = _mm_srli_epi16(temp1_8x16b, 2);
 
             temp1_16x8b = _mm_srli_si128(left_top_16x8b, 1);
             w11_16x8b = _mm_avg_epu8(left_top_16x8b, temp1_16x8b);
 
             temp2_16x8b = _mm_srli_si128(left_top_16x8b, 6);
             temp2_8x16b = _mm_unpacklo_epi8(temp2_16x8b, zero_vector);      //t1 t2 t3 t4 t5 t6 t7 0
             temp3_8x16b = _mm_srli_si128(temp2_8x16b, 2);                   //t2 t3 t4 t5 t6 t7 0  0
             temp3_8x16b = _mm_shufflehi_epi16(temp3_8x16b, 0xd4);           //t2 t3 t4 t5 t6 t7 t7 0
 
             temp2_8x16b = _mm_add_epi16(temp2_8x16b, temp3_8x16b);          //t1+t2      t2+t3...     t6+t7      t7+t7 0
             temp3_8x16b = _mm_srli_si128(temp2_8x16b, 2);                   //t2+t3      t3+t4...     t7+t7      0     0
             temp2_8x16b = _mm_add_epi16(temp2_8x16b, temp3_8x16b);          //t1+2*t2+t3 t2+2*t3+t4.. t6+2*t7+t7 t7+t7 0
 
             temp2_8x16b = _mm_add_epi16(const_2_8x16b, temp2_8x16b);        //t1+2*t2+t3+2 t2+2*t3+t4+2 t3+2*t4+t5+2... t6+2*t7+t7+2 t7+t7+2  2
             temp2_8x16b = _mm_srli_epi16(temp2_8x16b, 2);
 
             w121_16x8b = _mm_packus_epi16(temp1_8x16b, temp2_8x16b);
         }
 
         if(u4_valid_intra_modes & 8)/* DIAG_DL */
         {
             shuffle_16x8b = _mm_setr_epi8( 7,  8,  9,  10,
                                            8,  9,  10, 11,
                                            9,  10, 11, 12,
                                           10,  11, 12, 13);
             pred3_16x8b = _mm_shuffle_epi8(w121_16x8b, shuffle_16x8b);
             sad_8x16b = _mm_sad_epu8(src_16x8b, pred3_16x8b);
 
             sad[DIAG_DL_I4x4] = _mm_extract_epi16(sad_8x16b, 0) + _mm_extract_epi16(sad_8x16b, 4);
             cost[DIAG_DL_I4x4] = sad[DIAG_DL_I4x4] + ((u4_predictd_mode == DIAG_DL_I4x4) ? u4_lambda: lambda4);
         }
 
         if(u4_valid_intra_modes & 16)/* DIAG_DR */
         {
             shuffle_16x8b = _mm_setr_epi8(5, 6, 7, 8,
                                           4, 5, 6, 7,
                                           3, 4, 5, 6,
                                           2, 3, 4, 5);
             pred4_16x8b = _mm_shuffle_epi8(w121_16x8b, shuffle_16x8b);
             sad_8x16b = _mm_sad_epu8(src_16x8b, pred4_16x8b);
 
             sad[DIAG_DR_I4x4] = _mm_extract_epi16(sad_8x16b, 0) + _mm_extract_epi16(sad_8x16b, 4);
             cost[DIAG_DR_I4x4] = sad[DIAG_DR_I4x4] + ((u4_predictd_mode == DIAG_DR_I4x4) ? u4_lambda: lambda4);
         }
 
         if(u4_valid_intra_modes & 32)/* VERT_R mode valid ????*/
         {
             temp1_16x8b = _mm_srli_si128(w121_16x8b, 1);
             temp1_16x8b = _mm_unpacklo_epi64(temp1_16x8b, w11_16x8b);
             shuffle_16x8b = _mm_setr_epi8(12, 13, 14, 15,
                                            4,  5,  6,  7,
                                            3, 12, 13, 14,
                                            2,  4,  5,  6);
             pred5_16x8b = _mm_shuffle_epi8(temp1_16x8b, shuffle_16x8b);
             sad_8x16b = _mm_sad_epu8(src_16x8b, pred5_16x8b);
 
             sad[VERT_R_I4x4] = _mm_extract_epi16(sad_8x16b, 0) + _mm_extract_epi16(sad_8x16b, 4);
             cost[VERT_R_I4x4] = sad[VERT_R_I4x4] + ((u4_predictd_mode == VERT_R_I4x4) ? u4_lambda: lambda4);
         }
 
         if(u4_valid_intra_modes & 64)/* HORZ_D mode valid ????*/
         {
             temp1_16x8b = _mm_unpacklo_epi64(w121_16x8b, w11_16x8b);
             shuffle_16x8b = _mm_setr_epi8(11, 5,  6, 7,
                                           10, 4, 11, 5,
                                            9, 3, 10, 4,
                                            8, 2,  9, 3);
             pred6_16x8b = _mm_shuffle_epi8(temp1_16x8b, shuffle_16x8b);
             sad_8x16b = _mm_sad_epu8(src_16x8b, pred6_16x8b);
 
             sad[HORZ_D_I4x4] = _mm_extract_epi16(sad_8x16b, 0) + _mm_extract_epi16(sad_8x16b, 4);
             cost[HORZ_D_I4x4] = sad[HORZ_D_I4x4] + ((u4_predictd_mode == HORZ_D_I4x4) ? u4_lambda: lambda4);
         }
 
         if(u4_valid_intra_modes & 128)/* VERT_L mode valid ????*/
         {
             temp1_16x8b = _mm_srli_si128(w121_16x8b, 5);
             temp2_16x8b = _mm_srli_si128(w11_16x8b, 5);
             temp1_16x8b = _mm_unpacklo_epi64(temp1_16x8b, temp2_16x8b);
             shuffle_16x8b = _mm_setr_epi8(8,  9, 10, 11,
                                           2,  3,  4,  5,
                                           9, 10, 11, 12,
                                           3,  4,  5,  6);
             pred7_16x8b = _mm_shuffle_epi8(temp1_16x8b, shuffle_16x8b);
             sad_8x16b = _mm_sad_epu8(src_16x8b, pred7_16x8b);
 
             sad[VERT_L_I4x4] = _mm_extract_epi16(sad_8x16b, 0) + _mm_extract_epi16(sad_8x16b, 4);
             cost[VERT_L_I4x4] = sad[VERT_L_I4x4] + ((u4_predictd_mode == VERT_L_I4x4) ? u4_lambda: lambda4);
         }
 
         if(u4_valid_intra_modes & 256)/* HORZ_U mode valid ????*/
         {
             temp1_16x8b = _mm_unpacklo_epi64(w121_16x8b, w11_16x8b);
             shuffle_16x8b = _mm_setr_epi8(10, 3, 9, 2,
                                            9, 2, 8, 1,
                                            8, 1, 0, 0,
                                            0, 0, 0, 0);
             pred8_16x8b = _mm_shuffle_epi8(temp1_16x8b, shuffle_16x8b);
             sad_8x16b = _mm_sad_epu8(src_16x8b, pred8_16x8b);
 
             sad[HORZ_U_I4x4] = _mm_extract_epi16(sad_8x16b, 0) + _mm_extract_epi16(sad_8x16b, 4);
             cost[HORZ_U_I4x4] = sad[HORZ_U_I4x4] + ((u4_predictd_mode == HORZ_U_I4x4) ? u4_lambda: lambda4);
         }
 
         min_cost = MIN3(MIN3(cost[0], cost[1], cost[2]),
                         MIN3(cost[3], cost[4], cost[5]),
                         MIN3(cost[6], cost[7], cost[8]));
     }
     else
     {  /*Only first three modes valid*/
         min_cost = MIN3(cost[0], cost[1], cost[2]);
     }
 
     *pu4_sadmin = min_cost;
 
     if(min_cost == cost[0])
     {
         *u4_intra_mode = VERT_I4x4;
     }
     else if(min_cost == cost[1])
     {
         *u4_intra_mode = HORZ_I4x4;
         pred0_16x8b = pred1_16x8b;
     }
     else if(min_cost == cost[2])
     {
         *u4_intra_mode = DC_I4x4;
         pred0_16x8b = pred2_16x8b;
     }
     else if(min_cost == cost[3])
     {
         *u4_intra_mode = DIAG_DL_I4x4;
         pred0_16x8b = pred3_16x8b;
     }
     else if(min_cost == cost[4])
     {
         *u4_intra_mode = DIAG_DR_I4x4;
         pred0_16x8b = pred4_16x8b;
     }
     else if(min_cost == cost[5])
     {
         *u4_intra_mode = VERT_R_I4x4;
         pred0_16x8b = pred5_16x8b;
     }
     else if(min_cost == cost[6])
     {
         *u4_intra_mode = HORZ_D_I4x4;
         pred0_16x8b = pred6_16x8b;
     }
     else if(min_cost == cost[7])
     {
         *u4_intra_mode = VERT_L_I4x4;
         pred0_16x8b = pred7_16x8b;
     }
     else if(min_cost == cost[8])
     {
         *u4_intra_mode = HORZ_U_I4x4;
         pred0_16x8b = pred8_16x8b;
     }
 
     mask_low_32b = _mm_set1_epi8(0xff);
     mask_low_32b = _mm_srli_si128(mask_low_32b, 12);
 
     _mm_maskmoveu_si128(pred0_16x8b, mask_low_32b, (char*)pu1_dst);
     pred0_16x8b = _mm_srli_si128(pred0_16x8b, 4);
     _mm_maskmoveu_si128(pred0_16x8b, mask_low_32b, (char*)(pu1_dst + dst_strd));
     pred0_16x8b = _mm_srli_si128(pred0_16x8b, 4);
     _mm_maskmoveu_si128(pred0_16x8b, mask_low_32b, (char*)(pu1_dst + dst_strd2));
     pred0_16x8b = _mm_srli_si128(pred0_16x8b, 4);
     _mm_maskmoveu_si128(pred0_16x8b, mask_low_32b, (char*)(pu1_dst + dst_strd3));
 
 }
 
 /**
 ******************************************************************************
 *
 * @brief
 *  Evaluate best intra chroma mode (among VERT, HORZ and DC) and do the prediction.
 *
 * @par Description
 *  This function evaluates first three intra chroma modes and compute corresponding sad
 *  and return the buffer predicted with best mode.
 *
 * @param[in] pu1_src
 *  UWORD8 pointer to the source
 *
 ** @param[in] pu1_ngbr_pels
 *  UWORD8 pointer to neighbouring pels
 *
 * @param[out] pu1_dst
 *  UWORD8 pointer to the destination
 *
 * @param[in] src_strd
 *  integer source stride
 *
 * @param[in] dst_strd
 *  integer destination stride
 *
 * @param[in] u4_n_avblty
 *  availability of neighbouring pixels
 *
 * @param[in] u4_intra_mode
 *  pointer to the variable in which best mode is returned
 *
 * @param[in] pu4_sadmin
 *  pointer to the variable in which minimum sad is returned
 *
 * @param[in] u4_valid_intra_modes
 *  says what all modes are valid
 *
 * @return
 *  none
 *
 ******************************************************************************
 */
@@ -824,438 +824,438 @@ void ih264e_evaluate_intra_4x4_modes_ssse3(UWORD8 *pu1_src,
 void ih264e_evaluate_intra_chroma_modes_ssse3(UWORD8 *pu1_src,
                                               UWORD8 *pu1_ngbr_pels,
                                               UWORD8 *pu1_dst,
                                               UWORD32 src_strd,
                                               UWORD32 dst_strd,
                                               WORD32 u4_n_avblty,
                                               UWORD32 *u4_intra_mode,
                                               WORD32 *pu4_sadmin,
                                               UWORD32 u4_valid_intra_modes)
 {
     WORD32 left, top;
     WORD32 sad_vert = INT_MAX, sad_horz = INT_MAX, sad_dc = INT_MAX, min_sad;
 
     __m128i src1_16x8b, src2_16x8b, src3_16x8b, src4_16x8b;
     __m128i src5_16x8b, src6_16x8b, src7_16x8b, src8_16x8b;
 
     __m128i top_16x8b, left_16x8b;
     __m128i pred1_16x8b, pred2_16x8b;
     __m128i tmp1_8x16b, tmp2_8x16b, sad_8x16b;
 
     left = (u4_n_avblty & LEFT_MB_AVAILABLE_MASK);
     top = (u4_n_avblty & TOP_MB_AVAILABLE_MASK) >> 2;
 
     //Loading source
     {
         src1_16x8b = _mm_loadu_si128((__m128i *)pu1_src);
         pu1_src += src_strd;
         src2_16x8b = _mm_loadu_si128((__m128i *)pu1_src);
         pu1_src += src_strd;
         src3_16x8b = _mm_loadu_si128((__m128i *)pu1_src);
         pu1_src += src_strd;
         src4_16x8b = _mm_loadu_si128((__m128i *)pu1_src);
         pu1_src += src_strd;
         src5_16x8b = _mm_loadu_si128((__m128i *)pu1_src);
         pu1_src += src_strd;
         src6_16x8b = _mm_loadu_si128((__m128i *)pu1_src);
         pu1_src += src_strd;
         src7_16x8b = _mm_loadu_si128((__m128i *)pu1_src);
         pu1_src += src_strd;
         src8_16x8b = _mm_loadu_si128((__m128i *)pu1_src);
     }
 
     if(left)
     {
         left_16x8b = _mm_loadu_si128((__m128i *)pu1_ngbr_pels);
 
         if(u4_valid_intra_modes & 02) //If HORZ mode is valid
         {
             __m128i left_tmp_16x8b, left_sh_16x8b;
             __m128i const_14_15_16x8b;
 
             const_14_15_16x8b = _mm_set1_epi16(0x0f0e);
             left_sh_16x8b = _mm_slli_si128(left_16x8b, 2);
 
             pred1_16x8b = _mm_shuffle_epi8(left_16x8b, const_14_15_16x8b);    //row 1
             pred2_16x8b = _mm_shuffle_epi8(left_sh_16x8b, const_14_15_16x8b); //row 2
             tmp1_8x16b = _mm_sad_epu8(src1_16x8b, pred1_16x8b);
             tmp2_8x16b = _mm_sad_epu8(src2_16x8b, pred2_16x8b);
 
             left_tmp_16x8b = _mm_slli_si128(left_16x8b, 4);
             left_sh_16x8b = _mm_slli_si128(left_sh_16x8b, 4);
             sad_8x16b = _mm_add_epi16(tmp1_8x16b, tmp2_8x16b);
 
             pred1_16x8b = _mm_shuffle_epi8(left_tmp_16x8b, const_14_15_16x8b); //row 3
             pred2_16x8b = _mm_shuffle_epi8(left_sh_16x8b, const_14_15_16x8b);  //row 4
             tmp1_8x16b = _mm_sad_epu8(src3_16x8b, pred1_16x8b);
             tmp2_8x16b = _mm_sad_epu8(src4_16x8b, pred2_16x8b);
 
             left_tmp_16x8b = _mm_slli_si128(left_tmp_16x8b, 4);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp1_8x16b);
             left_sh_16x8b = _mm_slli_si128(left_sh_16x8b, 4);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp2_8x16b);
 
             pred1_16x8b = _mm_shuffle_epi8(left_tmp_16x8b, const_14_15_16x8b); //row 5
             pred2_16x8b = _mm_shuffle_epi8(left_sh_16x8b, const_14_15_16x8b);  //row 6
             tmp1_8x16b = _mm_sad_epu8(src5_16x8b, pred1_16x8b);
             tmp2_8x16b = _mm_sad_epu8(src6_16x8b, pred2_16x8b);
 
             left_tmp_16x8b = _mm_slli_si128(left_tmp_16x8b, 4);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp1_8x16b);
             left_sh_16x8b = _mm_slli_si128(left_sh_16x8b, 4);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp2_8x16b);
 
             pred1_16x8b = _mm_shuffle_epi8(left_tmp_16x8b, const_14_15_16x8b); //row 7
             pred2_16x8b = _mm_shuffle_epi8(left_sh_16x8b, const_14_15_16x8b);  //row 8
             tmp1_8x16b = _mm_sad_epu8(src7_16x8b, pred1_16x8b);
             tmp2_8x16b = _mm_sad_epu8(src8_16x8b, pred2_16x8b);
 
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp1_8x16b);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp2_8x16b);
 
             sad_horz = _mm_extract_epi16(sad_8x16b, 0) + _mm_extract_epi16(sad_8x16b, 4);
         }
     }
 
     if(top)
     {
         UWORD8 *pu1_top;
 
         pu1_top = pu1_ngbr_pels + 2 * BLK8x8SIZE + 2;
         top_16x8b = _mm_loadu_si128((__m128i *)pu1_top);
 
         if(u4_valid_intra_modes & 04) //If VERT mode is valid
         {
             tmp1_8x16b = _mm_sad_epu8(src1_16x8b, top_16x8b);
             tmp2_8x16b = _mm_sad_epu8(src2_16x8b, top_16x8b);
             sad_8x16b = _mm_add_epi16(tmp1_8x16b, tmp2_8x16b);
 
             tmp1_8x16b = _mm_sad_epu8(src3_16x8b, top_16x8b);
             tmp2_8x16b = _mm_sad_epu8(src4_16x8b, top_16x8b);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp1_8x16b);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp2_8x16b);
 
             tmp1_8x16b = _mm_sad_epu8(src5_16x8b, top_16x8b);
             tmp2_8x16b = _mm_sad_epu8(src6_16x8b, top_16x8b);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp1_8x16b);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp2_8x16b);
 
             tmp1_8x16b = _mm_sad_epu8(src7_16x8b, top_16x8b);
             tmp2_8x16b = _mm_sad_epu8(src8_16x8b, top_16x8b);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp1_8x16b);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp2_8x16b);
 
             sad_vert = _mm_extract_epi16(sad_8x16b, 0) + _mm_extract_epi16(sad_8x16b, 4);
         }
     }
 
     if(u4_valid_intra_modes & 01) //If DC mode is valid
     {
         if(left && top)
         {
             WORD32 left_up_u, left_down_u, left_up_v, left_down_v;
             WORD32 top_left_u, top_right_u, top_left_v, top_right_v;
             WORD32 dc_1u, dc_1v, dc_2u, dc_2v;
 
             __m128i val_sh_16x8b;
             __m128i intrlv_mask_8x16b, zero_vector;
 
             intrlv_mask_8x16b = _mm_set1_epi16(0x00ff);
             zero_vector = _mm_setzero_si128();
 
             val_sh_16x8b = _mm_srli_si128(left_16x8b, 1);
 
             tmp1_8x16b = _mm_and_si128(intrlv_mask_8x16b, left_16x8b);
             tmp2_8x16b = _mm_and_si128(intrlv_mask_8x16b, val_sh_16x8b);
             tmp1_8x16b = _mm_sad_epu8(zero_vector, tmp1_8x16b);
             tmp2_8x16b = _mm_sad_epu8(zero_vector, tmp2_8x16b);
 
             left_up_u = _mm_extract_epi16(tmp1_8x16b, 4);
             left_up_v = _mm_extract_epi16(tmp2_8x16b, 4);
             left_down_u = _mm_extract_epi16(tmp1_8x16b, 0);
             left_down_v = _mm_extract_epi16(tmp2_8x16b, 0);
 
             val_sh_16x8b = _mm_srli_si128(top_16x8b, 1);
 
             tmp1_8x16b = _mm_and_si128(intrlv_mask_8x16b, top_16x8b);
             tmp2_8x16b = _mm_and_si128(intrlv_mask_8x16b, val_sh_16x8b);
             tmp1_8x16b = _mm_sad_epu8(zero_vector, tmp1_8x16b);
             tmp2_8x16b = _mm_sad_epu8(zero_vector, tmp2_8x16b);
 
             top_left_u = _mm_extract_epi16(tmp1_8x16b, 0);
             top_left_v = _mm_extract_epi16(tmp2_8x16b, 0);
             top_right_u = _mm_extract_epi16(tmp1_8x16b, 4);
             top_right_v = _mm_extract_epi16(tmp2_8x16b, 4);
 
             // First four rows
             dc_1u = (left_up_u + top_left_u + 4) >> 3;
             dc_1v = (left_up_v + top_left_v + 4) >> 3;
             dc_2u = (top_right_u + 2) >> 2;
             dc_2v = (top_right_v + 2) >> 2;
 
             pred1_16x8b = _mm_setr_epi8(dc_1u, dc_1v, dc_1u, dc_1v, dc_1u, dc_1v, dc_1u, dc_1v,
                                         dc_2u, dc_2v, dc_2u, dc_2v, dc_2u, dc_2v, dc_2u, dc_2v);
 
             tmp1_8x16b = _mm_sad_epu8(src1_16x8b, pred1_16x8b);
             tmp2_8x16b = _mm_sad_epu8(src2_16x8b, pred1_16x8b);
             sad_8x16b = _mm_add_epi16(tmp1_8x16b, tmp2_8x16b);
 
             tmp1_8x16b = _mm_sad_epu8(src3_16x8b, pred1_16x8b);
             tmp2_8x16b = _mm_sad_epu8(src4_16x8b, pred1_16x8b);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp1_8x16b);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp2_8x16b);
 
             // Second four rows
             dc_1u = (left_down_u + 2) >> 2;
             dc_1v = (left_down_v + 2) >> 2;
             dc_2u = (left_down_u + top_right_u + 4) >> 3;
             dc_2v = (left_down_v + top_right_v + 4) >> 3;
 
             pred2_16x8b = _mm_setr_epi8(dc_1u, dc_1v, dc_1u, dc_1v, dc_1u, dc_1v, dc_1u, dc_1v,
                                         dc_2u, dc_2v, dc_2u, dc_2v, dc_2u, dc_2v, dc_2u, dc_2v);
 
             tmp1_8x16b = _mm_sad_epu8(src5_16x8b, pred2_16x8b);
             tmp2_8x16b = _mm_sad_epu8(src6_16x8b, pred2_16x8b);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp1_8x16b);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp2_8x16b);
 
             tmp1_8x16b = _mm_sad_epu8(src7_16x8b, pred2_16x8b);
             tmp2_8x16b = _mm_sad_epu8(src8_16x8b, pred2_16x8b);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp1_8x16b);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp2_8x16b);
 
             sad_dc = _mm_extract_epi16(sad_8x16b, 0) + _mm_extract_epi16(sad_8x16b, 4);
         }
         else if(left)
         {
             WORD32 left_up_u, left_down_u, left_up_v, left_down_v;
             WORD32 dc_u, dc_v;
 
             __m128i left_sh_16x8b;
             __m128i intrlv_mask_8x16b, zero_vector;
 
             intrlv_mask_8x16b = _mm_set1_epi16(0x00ff);
             zero_vector = _mm_setzero_si128();
 
             left_sh_16x8b = _mm_srli_si128(left_16x8b, 1);
 
             tmp1_8x16b = _mm_and_si128(intrlv_mask_8x16b, left_16x8b);
             tmp2_8x16b = _mm_and_si128(intrlv_mask_8x16b, left_sh_16x8b);
             tmp1_8x16b = _mm_sad_epu8(zero_vector, tmp1_8x16b);
             tmp2_8x16b = _mm_sad_epu8(zero_vector, tmp2_8x16b);
 
             left_up_u = _mm_extract_epi16(tmp1_8x16b, 4);
             left_up_v = _mm_extract_epi16(tmp2_8x16b, 4);
             left_down_u = _mm_extract_epi16(tmp1_8x16b, 0);
             left_down_v = _mm_extract_epi16(tmp2_8x16b, 0);
 
             // First four rows
             dc_u = (left_up_u + 2) >> 2;
             dc_v = (left_up_v + 2) >> 2;
 
             pred1_16x8b = _mm_set1_epi16(dc_u | (dc_v << 8));
 
             tmp1_8x16b = _mm_sad_epu8(src1_16x8b, pred1_16x8b);
             tmp2_8x16b = _mm_sad_epu8(src2_16x8b, pred1_16x8b);
             sad_8x16b = _mm_add_epi16(tmp1_8x16b, tmp2_8x16b);
 
             tmp1_8x16b = _mm_sad_epu8(src3_16x8b, pred1_16x8b);
             tmp2_8x16b = _mm_sad_epu8(src4_16x8b, pred1_16x8b);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp1_8x16b);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp2_8x16b);
 
             // Second four rows
             dc_u = (left_down_u + 2) >> 2;
             dc_v = (left_down_v + 2) >> 2;
 
             pred2_16x8b = _mm_set1_epi16(dc_u | (dc_v << 8));
 
             tmp1_8x16b = _mm_sad_epu8(src5_16x8b, pred2_16x8b);
             tmp2_8x16b = _mm_sad_epu8(src6_16x8b, pred2_16x8b);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp1_8x16b);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp2_8x16b);
 
             tmp1_8x16b = _mm_sad_epu8(src7_16x8b, pred2_16x8b);
             tmp2_8x16b = _mm_sad_epu8(src8_16x8b, pred2_16x8b);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp1_8x16b);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp2_8x16b);
 
             sad_dc = _mm_extract_epi16(sad_8x16b, 0) + _mm_extract_epi16(sad_8x16b, 4);
         }
         else if(top)
         {
             WORD32 top_left_u, top_right_u, top_left_v, top_right_v;
             WORD32 dc_1u, dc_1v, dc_2u, dc_2v;
 
             __m128i top_sh_16x8b;
             __m128i intrlv_mask_8x16b, zero_vector;
 
             intrlv_mask_8x16b = _mm_set1_epi16(0x00ff);
             zero_vector = _mm_setzero_si128();
 
             top_sh_16x8b = _mm_srli_si128(top_16x8b, 1);
 
             tmp1_8x16b = _mm_and_si128(intrlv_mask_8x16b, top_16x8b);
             tmp2_8x16b = _mm_and_si128(intrlv_mask_8x16b, top_sh_16x8b);
             tmp1_8x16b = _mm_sad_epu8(zero_vector, tmp1_8x16b);
             tmp2_8x16b = _mm_sad_epu8(zero_vector, tmp2_8x16b);
 
             top_left_u = _mm_extract_epi16(tmp1_8x16b, 0);
             top_left_v = _mm_extract_epi16(tmp2_8x16b, 0);
             top_right_u = _mm_extract_epi16(tmp1_8x16b, 4);
             top_right_v = _mm_extract_epi16(tmp2_8x16b, 4);
 
             dc_1u = (top_left_u + 2) >> 2;
             dc_1v = (top_left_v + 2) >> 2;
             dc_2u = (top_right_u + 2) >> 2;
             dc_2v = (top_right_v + 2) >> 2;
 
             pred1_16x8b = _mm_setr_epi8(dc_1u, dc_1v, dc_1u, dc_1v, dc_1u, dc_1v, dc_1u, dc_1v,
                                        dc_2u, dc_2v, dc_2u, dc_2v, dc_2u, dc_2v, dc_2u, dc_2v);
 
             tmp1_8x16b = _mm_sad_epu8(src1_16x8b, pred1_16x8b);
             tmp2_8x16b = _mm_sad_epu8(src2_16x8b, pred1_16x8b);
             sad_8x16b = _mm_add_epi16(tmp1_8x16b, tmp2_8x16b);
 
             tmp1_8x16b = _mm_sad_epu8(src3_16x8b, pred1_16x8b);
             tmp2_8x16b = _mm_sad_epu8(src4_16x8b, pred1_16x8b);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp1_8x16b);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp2_8x16b);
 
             tmp1_8x16b = _mm_sad_epu8(src5_16x8b, pred1_16x8b);
             tmp2_8x16b = _mm_sad_epu8(src6_16x8b, pred1_16x8b);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp1_8x16b);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp2_8x16b);
 
             tmp1_8x16b = _mm_sad_epu8(src7_16x8b, pred1_16x8b);
             tmp2_8x16b = _mm_sad_epu8(src8_16x8b, pred1_16x8b);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp1_8x16b);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp2_8x16b);
 
             sad_dc = _mm_extract_epi16(sad_8x16b, 0) + _mm_extract_epi16(sad_8x16b, 4);
         }
         else
         {
-            pred1_16x8b = _mm_set1_epi8(128);
+            pred1_16x8b = _mm_set1_epi8(-128);
 
             tmp1_8x16b = _mm_sad_epu8(src1_16x8b, pred1_16x8b);
             tmp2_8x16b = _mm_sad_epu8(src2_16x8b, pred1_16x8b);
             sad_8x16b = _mm_add_epi16(tmp1_8x16b, tmp2_8x16b);
 
             tmp1_8x16b = _mm_sad_epu8(src3_16x8b, pred1_16x8b);
             tmp2_8x16b = _mm_sad_epu8(src4_16x8b, pred1_16x8b);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp1_8x16b);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp2_8x16b);
 
             tmp1_8x16b = _mm_sad_epu8(src5_16x8b, pred1_16x8b);
             tmp2_8x16b = _mm_sad_epu8(src6_16x8b, pred1_16x8b);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp1_8x16b);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp2_8x16b);
 
             tmp1_8x16b = _mm_sad_epu8(src7_16x8b, pred1_16x8b);
             tmp2_8x16b = _mm_sad_epu8(src8_16x8b, pred1_16x8b);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp1_8x16b);
             sad_8x16b = _mm_add_epi16(sad_8x16b, tmp2_8x16b);
 
             sad_dc = _mm_extract_epi16(sad_8x16b, 0) + _mm_extract_epi16(sad_8x16b, 4);
         }
     }
 
     min_sad = MIN3(sad_horz, sad_vert, sad_dc);
 
     /* Finding minimum SAD and doing corresponding prediction*/
     if(min_sad < *pu4_sadmin)
     {
         *pu4_sadmin = min_sad;
 
         if(min_sad == sad_dc)
         {
             *u4_intra_mode = DC_CH_I8x8;
 
             if(!left)
                 pred2_16x8b = pred1_16x8b;
 
             _mm_storeu_si128((__m128i *)pu1_dst, pred1_16x8b);
             pu1_dst += dst_strd;
             _mm_storeu_si128((__m128i *)pu1_dst, pred1_16x8b);
             pu1_dst += dst_strd;
             _mm_storeu_si128((__m128i *)pu1_dst, pred1_16x8b);
             pu1_dst += dst_strd;
             _mm_storeu_si128((__m128i *)pu1_dst, pred1_16x8b);
             pu1_dst += dst_strd;
 
             _mm_storeu_si128((__m128i *)pu1_dst, pred2_16x8b);
             pu1_dst += dst_strd;
             _mm_storeu_si128((__m128i *)pu1_dst, pred2_16x8b);
             pu1_dst += dst_strd;
             _mm_storeu_si128((__m128i *)pu1_dst, pred2_16x8b);
             pu1_dst += dst_strd;
             _mm_storeu_si128((__m128i *)pu1_dst, pred2_16x8b);
         }
         else if(min_sad == sad_horz)
         {
             __m128i left_sh_16x8b, const_14_15_16x8b;
 
             *u4_intra_mode = HORZ_CH_I8x8;
 
             const_14_15_16x8b = _mm_set1_epi16(0x0f0e);
 
             left_sh_16x8b = _mm_slli_si128(left_16x8b, 2);
             pred1_16x8b = _mm_shuffle_epi8(left_16x8b, const_14_15_16x8b);    //row 1
             pred2_16x8b = _mm_shuffle_epi8(left_sh_16x8b, const_14_15_16x8b); //row 2
 
             _mm_storeu_si128((__m128i *)pu1_dst, pred1_16x8b);
             pu1_dst += dst_strd;
             _mm_storeu_si128((__m128i *)pu1_dst, pred2_16x8b);
 
             left_16x8b = _mm_slli_si128(left_16x8b, 4);
             left_sh_16x8b = _mm_slli_si128(left_sh_16x8b, 4);
             pred1_16x8b = _mm_shuffle_epi8(left_16x8b, const_14_15_16x8b);    //row 3
             pred2_16x8b = _mm_shuffle_epi8(left_sh_16x8b, const_14_15_16x8b); //row 4
 
             pu1_dst += dst_strd;
             _mm_storeu_si128((__m128i *)pu1_dst, pred1_16x8b);
             pu1_dst += dst_strd;
             _mm_storeu_si128((__m128i *)pu1_dst, pred2_16x8b);
 
             left_16x8b = _mm_slli_si128(left_16x8b, 4);
             left_sh_16x8b = _mm_slli_si128(left_sh_16x8b, 4);
             pred1_16x8b = _mm_shuffle_epi8(left_16x8b, const_14_15_16x8b);    //row 5
             pred2_16x8b = _mm_shuffle_epi8(left_sh_16x8b, const_14_15_16x8b); //row 6
 
             pu1_dst += dst_strd;
             _mm_storeu_si128((__m128i *)pu1_dst, pred1_16x8b);
             pu1_dst += dst_strd;
             _mm_storeu_si128((__m128i *)pu1_dst, pred2_16x8b);
 
             left_16x8b = _mm_slli_si128(left_16x8b, 4);
             left_sh_16x8b = _mm_slli_si128(left_sh_16x8b, 4);
             pred1_16x8b = _mm_shuffle_epi8(left_16x8b, const_14_15_16x8b);    //row 7
             pred2_16x8b = _mm_shuffle_epi8(left_sh_16x8b, const_14_15_16x8b); //row 8
 
             pu1_dst += dst_strd;
             _mm_storeu_si128((__m128i *)pu1_dst, pred1_16x8b);
             pu1_dst += dst_strd;
             _mm_storeu_si128((__m128i *)pu1_dst, pred2_16x8b);
         }
         else
         {
             *u4_intra_mode = VERT_CH_I8x8;
 
             _mm_storeu_si128((__m128i *)pu1_dst, top_16x8b);
             pu1_dst += dst_strd;
             _mm_storeu_si128((__m128i *)pu1_dst, top_16x8b);
             pu1_dst += dst_strd;
             _mm_storeu_si128((__m128i *)pu1_dst, top_16x8b);
             pu1_dst += dst_strd;
             _mm_storeu_si128((__m128i *)pu1_dst, top_16x8b);
             pu1_dst += dst_strd;
             _mm_storeu_si128((__m128i *)pu1_dst, top_16x8b);
             pu1_dst += dst_strd;
             _mm_storeu_si128((__m128i *)pu1_dst, top_16x8b);
             pu1_dst += dst_strd;
             _mm_storeu_si128((__m128i *)pu1_dst, top_16x8b);
             pu1_dst += dst_strd;
             _mm_storeu_si128((__m128i *)pu1_dst, top_16x8b);
         }
     }
 }
diff --git a/libavc_blacklist.txt b/libavc_blacklist.txt
new file mode 100644
index 0000000..5bb3630
--- /dev/null
+++ b/libavc_blacklist.txt
@@ -0,0 +1,34 @@
+[cfi]
+src:*external/libavc/*
+
+[integer]
+# decoder/ih264d_dpb_mgr.c:1174: 2 - 3 cannot be represented in type 'unsigned int'
+fun:ih264d_do_mmco_buffer
+# decoder/ih264d_parse_bslice.c:1388:21: 1 + 4294967295 cannot be represented in type 'unsigned int'
+# decoder/ih264d_parse_bslice.c:1391:22: 1 + 4294967295 cannot be represented in type 'unsigned int'
+fun:ih264d_decode_bslice
+# decoder/ih264d_utils.c:389: 0 - 1 cannot be represented in type 'unsigned int'
+fun:ih264d_decode_pic_order_cnt
+# decoder/ih264d_vui.c:76: 1 + 4294967295 cannot be represented in type 'unsigned int'
+fun:ih264d_parse_hrd_parametres
+# decoder/ih264d_dpb_mgr.c:751: 4294967295 + 1 cannot be represented in type 'unsigned int'
+# decoder/ih264d_dpb_mgr.c:755: 1 - 16 cannot be represented in type 'unsigned int'
+# decoder/ih264d_dpb_mgr.c:762: 4294967295 + 1 cannot be represented in type 'unsigned int'
+fun:ih264d_ref_idx_reordering
+# decoder/ih264d_process_bslice.c:785: 5 - 4294967242 cannot be represented in type 'unsigned int'
+# decoder/ih264d_process_bslice.c:796: 3 - 4294967242 cannot be represented in type 'unsigned int'
+fun:ih264d_decode_temporal_direct
+# encoder/ime.c:153: 0 - 1 cannot be represented in type 'UWORD32'
+fun:ime_diamond_search_16x16
+# encoder/irc_rate_control_api.c:1251: 1000 * 1065353216 cannot be represented in type 'unsigned int'
+fun:irc_change_frame_rate
+# encoder/irc_rate_control_api.c:310: 6000000 * 1000 cannot be represented in type 'unsigned int'
+fun:irc_initialise_rate_control
+
+# Numerous overflows in multiple functions, CAVLC is a compression technique.
+src:*/decoder/ih264d_parse_cavlc.c
+src:*/encoder/ih264e_cavlc.c
+
+# Performance related
+fun:ih264e_pack_c_mb
+fun:ime_compute_satqd_16x16_lumainter_a9q
diff --git a/test/encoder/app.h b/test/encoder/app.h
index 0e9a3df..8a2fb0a 100644
--- a/test/encoder/app.h
+++ b/test/encoder/app.h
@@ -1,183 +1,183 @@
 /******************************************************************************
  *
  * Copyright (C) 2015 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  *****************************************************************************
  * Originally developed and contributed by Ittiam Systems Pvt. Ltd, Bangalore
 */
 /*****************************************************************************/
 /*                                                                           */
 /*  File Name         : app.h                                                */
 /*                                                                           */
 /*  Description       : This file contains all the necessary structure and   */
 /*                      enumeration definitions needed for the Application   */
 /*                                                                           */
 /*  List of Functions :                                                      */
 /*                                                                           */
 /*  Issues / Problems : None                                                 */
 /*                                                                           */
 /*  Revision History  :                                                      */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         26 08 2010   Ittiam          Draft                                */
 /*                                                                           */
 /*****************************************************************************/
 
 #ifndef _APP_H_
 #define _APP_H_
 
 #include "iv2.h"
 #include "ive2.h"
 #ifdef WINDOWS_TIMER
 #include <windows.h>
 #else
 #include <sys/time.h>
 #endif
 /*****************************************************************************/
 /* Function Macros                                                           */
 /*****************************************************************************/
 #define MAX(a, b) ((a) > (b))? (a) : (b)
 #define MIN(a, b) ((a) < (b))? (a) : (b)
 
 #define ALIGN16(x) ((((x) + 15) >> 4) << 4)
 
 /*****************************************************************************/
 /* Constant Macros                                                           */
 /*****************************************************************************/
 
 #define DEFAULT_NUM_INPUT_BUFS   32
 #define DEFAULT_MAX_INPUT_BUFS   32
 
 #define DEFAULT_NUM_OUTPUT_BUFS  32
 #define DEFAULT_MAX_OUTPUT_BUFS  32
 
 #define DEFAULT_NUM_RECON_BUFS   32
 #define DEFAULT_MAX_RECON_BUFS   DEFAULT_NUM_RECON_BUFS
 
 
 #define LEN_STATUS_BUFFER        (10  * 1024)
 #define MAX_VBV_BUFF_SIZE        (120 * 16384)
 #define MAX_NUM_IO_BUFS           3
 
 #define DEFAULT_MAX_REF_FRM         2
 #define DEFAULT_MAX_REORDER_FRM     0
 #define DEFAULT_QP_MIN              4
 #define DEFAULT_QP_MAX              51
-#define DEFAULT_MAX_BITRATE         50000000
+#define DEFAULT_MAX_BITRATE         240000000
 #define DEFAULT_NUM_BFRAMES         0
 #define DEFAULT_MAX_SRCH_RANGE_X    256
 #define DEFAULT_MAX_SRCH_RANGE_Y    256
 #define DEFAULT_MAX_FRAMERATE       120000
 #define DEFAULT_NUM_CORES           1
 #define DEFAULT_NUM_CORES_PRE_ENC   0
 #define DEFAULT_FPS                 30
 #define DEFAULT_ENC_SPEED           100
 
 #define DEFAULT_MEM_REC_CNT         0
 #define DEFAULT_RECON_ENABLE        0
 #define DEFAULT_CHKSUM_ENABLE       0
 #define DEFAULT_START_FRM           0
 #define DEFAULT_NUM_FRMS            0xFFFFFFFF
 #define DEFAULT_INP_COLOR_FMT       IV_YUV_420SP_UV
 #define DEFAULT_RECON_COLOR_FMT     IV_YUV_420P
 #define DEFAULT_LOOPBACK            0
 #define DEFAULT_SRC_FRAME_RATE      30
 #define DEFAULT_TGT_FRAME_RATE      30
 #define DEFAULT_MAX_WD              1920
 #define DEFAULT_MAX_HT              1920
 #define DEFAULT_MAX_LEVEL           40
 #define DEFAULT_STRIDE              0
 #define DEFAULT_WD                  0
 #define DEFAULT_HT                  0
 #define DEFAULT_PSNR_ENABLE         0
 #define DEFAULT_ME_SPEED            100
 #define DEFAULT_ENABLE_FAST_SAD     0
 #define DEFAULT_ENABLE_ALT_REF      0
 #define DEFAULT_RC                  1
 #define DEFAULT_BITRATE             6000000
 #define DEFAULT_I_QP                25
 #define DEFAULT_I_QP_MAX            DEFAULT_QP_MAX
 #define DEFAULT_I_QP_MIN            0
 #define DEFAULT_P_QP                28
 #define DEFAULT_P_QP_MAX            DEFAULT_QP_MAX
 #define DEFAULT_P_QP_MIN            0
 #define DEFAULT_B_QP                28
 #define DEFAULT_B_QP_MAX            DEFAULT_QP_MAX
 #define DEFAULT_B_QP_MIN            0
 #define DEFAULT_AIR                 0
 #define DEFAULT_AIR_REFRESH_PERIOD  30
 #define DEFAULT_SRCH_RNG_X          64
 #define DEFAULT_SRCH_RNG_Y          48
 #define DEFAULT_I_INTERVAL          30
 #define DEFAULT_IDR_INTERVAL        1000
 #define DEFAULT_CONSTRAINED_INTRAPRED  0
 #define DEFAULT_B_FRAMES            0
 #define DEFAULT_DISABLE_DEBLK_LEVEL 0
 #define DEFAULT_HPEL                1
 #define DEFAULT_QPEL                1
 #define DEFAULT_I4                  1
 #define DEFAULT_EPROFILE            IV_PROFILE_BASE
 #define DEFAULT_SLICE_MODE          0
 #define DEFAULT_SLICE_PARAM         256
 #define DEFAULT_ENTROPY_CODING_MODE 0
 
 #define STRLENGTH               500
 
 
 /*****************************************************************************/
 /*  profile Macros                                                           */
 /*****************************************************************************/
 #ifdef PROFILE_ENABLE
     #ifdef WINDOWS_TIMER
         typedef  LARGE_INTEGER TIMER;
     #else
         //#ifdef X86_MINGW
         typedef struct timeval TIMER;
         //#endif
     #endif
 #endif
 
 #ifdef PROFILE_ENABLE
     #ifdef WINDOWS_TIMER
         #define GETTIME(timer) QueryPerformanceCounter(timer);
     #else
     //#ifdef X86_MINGW
         #define GETTIME(timer) gettimeofday(timer,NULL);
     //#endif
     #endif
 
     #ifdef WINDOWS_TIMER
         #define ELAPSEDTIME(s_start_timer,s_end_timer, s_elapsed_time, frequency) \
                   { \
                    TIMER s_temp_time;   \
                    s_temp_time.LowPart = s_end_timer.LowPart - s_start_timer.LowPart ; \
                    s_elapsed_time = (UWORD32) ( ((DOUBLE)s_temp_time.LowPart / (DOUBLE)frequency.LowPart )  * 1000000); \
                 }
     #else
     //#ifdef X86_MINGW
         #define ELAPSEDTIME(s_start_timer,s_end_timer, s_elapsed_time, frequency) \
                    s_elapsed_time = ((s_end_timer.tv_sec - s_start_timer.tv_sec) * 1000000) + (s_end_timer.tv_usec - s_start_timer.tv_usec);
     //#endif
     #endif
 
 #else
     #define GETTIME(timer)
     #define ELAPSEDTIME(s_start_timer,s_end_timer, s_elapsed_time, frequency)
 #endif
 
 
 /*****************************************************************************/
 /*  Structure definitions                                                    */
 /*****************************************************************************/
