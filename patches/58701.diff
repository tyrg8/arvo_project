commit 7aed6abd527e88243a450c7809cde6003de1cb6f
Author: Sean McBride <sean@rogue-research.com>
Date:   Tue Feb 20 12:19:50 2024 -0500

    Replaced last sprintf with snprintf (#4007)
    
    * Replaced last sprintf with snprintf
    
    To have the size of the buffer, it was required to change a function signature, and change all users of it.
    
    In most cases, determining the buffer size wasn't  trivial and so SIZE_MAX is passed. But at least this improves the infrastructure. Someone can later figure out the correct sizes.

diff --git a/src/H5Oainfo.c b/src/H5Oainfo.c
index 10502123cd..8b82e39e2a 100644
--- a/src/H5Oainfo.c
+++ b/src/H5Oainfo.c
@@ -31,7 +31,8 @@
 /* PRIVATE PROTOTYPES */
 static void  *H5O__ainfo_decode(H5F_t *f, H5O_t *open_oh, unsigned mesg_flags, unsigned *ioflags,
                                 size_t p_size, const uint8_t *p);
-static herr_t H5O__ainfo_encode(H5F_t *f, bool disable_shared, uint8_t *p, const void *_mesg);
+static herr_t H5O__ainfo_encode(H5F_t *f, bool disable_shared, size_t H5_ATTR_UNUSED p_size, uint8_t *p,
+                                const void *_mesg);
 static void  *H5O__ainfo_copy(const void *_mesg, void *_dest);
 static size_t H5O__ainfo_size(const H5F_t *f, bool disable_shared, const void *_mesg);
 static herr_t H5O__ainfo_free(void *_mesg);
@@ -175,53 +176,54 @@ done:
  *-------------------------------------------------------------------------
  */
 static herr_t
-H5O__ainfo_encode(H5F_t *f, bool H5_ATTR_UNUSED disable_shared, uint8_t *p, const void *_mesg)
+H5O__ainfo_encode(H5F_t *f, bool H5_ATTR_UNUSED disable_shared, size_t H5_ATTR_UNUSED p_size, uint8_t *p,
+                  const void *_mesg)
 {
     const H5O_ainfo_t *ainfo = (const H5O_ainfo_t *)_mesg;
     unsigned char      flags; /* Flags for encoding attribute info */
 
     FUNC_ENTER_PACKAGE_NOERR
 
     /* check args */
     assert(f);
     assert(p);
     assert(ainfo);
 
     /* Message version */
     *p++ = H5O_AINFO_VERSION;
 
     /* The flags for the attribute indices */
     flags = (unsigned char)(ainfo->track_corder ? H5O_AINFO_TRACK_CORDER : 0);
     flags = (unsigned char)(flags | (ainfo->index_corder ? H5O_AINFO_INDEX_CORDER : 0));
     *p++  = flags;
 
     /* Max. creation order value for the object */
     if (ainfo->track_corder)
         UINT16ENCODE(p, ainfo->max_crt_idx);
 
     /* Address of fractal heap to store "dense" attributes */
     H5F_addr_encode(f, &p, ainfo->fheap_addr);
 
     /* Address of v2 B-tree to index names of attributes */
     H5F_addr_encode(f, &p, ainfo->name_bt2_addr);
 
     /* Address of v2 B-tree to index creation order of attributes, if they are indexed */
     if (ainfo->index_corder)
         H5F_addr_encode(f, &p, ainfo->corder_bt2_addr);
     else
         assert(!H5_addr_defined(ainfo->corder_bt2_addr));
 
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5O__ainfo_encode() */
 
 /*-------------------------------------------------------------------------
  * Function:    H5O__ainfo_copy
  *
  * Purpose:     Copies a message from _MESG to _DEST, allocating _DEST if
  *              necessary.
  *
  * Return:      Success:        Ptr to _DEST
  *              Failure:        NULL
  *
  *-------------------------------------------------------------------------
  */
diff --git a/src/H5Oattr.c b/src/H5Oattr.c
index e86ec39432..6852ebc979 100644
--- a/src/H5Oattr.c
+++ b/src/H5Oattr.c
@@ -323,86 +323,86 @@ static herr_t
 H5O__attr_encode(H5F_t *f, uint8_t *p, const void *mesg)
 {
     const H5A_t *attr = (const H5A_t *)mesg;
     size_t       name_len;        /* Attribute name length */
     htri_t       is_type_shared;  /* Flag to indicate that a shared datatype is used for this attribute */
     htri_t       is_space_shared; /* Flag to indicate that a shared dataspace is used for this attribute */
     unsigned     flags     = 0;   /* Attribute flags */
     herr_t       ret_value = SUCCEED; /* Return value */
 
     FUNC_ENTER_PACKAGE
 
     /* check args */
     assert(f);
     assert(p);
     assert(attr);
 
     /* Check whether datatype and dataspace are shared */
     if ((is_type_shared = H5O_msg_is_shared(H5O_DTYPE_ID, attr->shared->dt)) < 0)
         HGOTO_ERROR(H5E_OHDR, H5E_BADMESG, FAIL, "can't determine if datatype is shared");
 
     if ((is_space_shared = H5O_msg_is_shared(H5O_SDSPACE_ID, attr->shared->ds)) < 0)
         HGOTO_ERROR(H5E_OHDR, H5E_BADMESG, FAIL, "can't determine if dataspace is shared");
 
     /* Encode Version */
     *p++ = attr->shared->version;
 
     /* Set attribute flags if version >1 */
     if (attr->shared->version >= H5O_ATTR_VERSION_2) {
         flags = (is_type_shared ? H5O_ATTR_FLAG_TYPE_SHARED : 0);
         flags |= (is_space_shared ? H5O_ATTR_FLAG_SPACE_SHARED : 0);
         *p++ = (uint8_t)flags; /* Set flags for attribute */
     }                          /* end if */
     else
         *p++ = 0; /* Reserved, for version <2 */
 
     /*
      * Encode the lengths of the various parts of the attribute message. The
      * encoded lengths are exact but we pad each part except the data to be a
      * multiple of eight bytes (in the first version).
      */
     name_len = strlen(attr->shared->name) + 1;
     UINT16ENCODE(p, name_len);
     UINT16ENCODE(p, attr->shared->dt_size);
     UINT16ENCODE(p, attr->shared->ds_size);
 
     /* The character encoding for the attribute's name, in later versions */
     if (attr->shared->version >= H5O_ATTR_VERSION_3)
         *p++ = (uint8_t)attr->shared->encoding;
 
     /* Write the name including null terminator */
     H5MM_memcpy(p, attr->shared->name, name_len);
     if (attr->shared->version < H5O_ATTR_VERSION_2) {
         /* Pad to the correct number of bytes */
         memset(p + name_len, 0, H5O_ALIGN_OLD(name_len) - name_len);
         p += H5O_ALIGN_OLD(name_len);
     } /* end if */
     else
         p += name_len;
 
     /* encode the attribute datatype */
-    if ((H5O_MSG_DTYPE->encode)(f, false, p, attr->shared->dt) < 0)
+    if ((H5O_MSG_DTYPE->encode)(f, false, SIZE_MAX, p, attr->shared->dt) < 0)
         HGOTO_ERROR(H5E_ATTR, H5E_CANTENCODE, FAIL, "can't encode attribute datatype");
 
     if (attr->shared->version < H5O_ATTR_VERSION_2) {
         memset(p + attr->shared->dt_size, 0, H5O_ALIGN_OLD(attr->shared->dt_size) - attr->shared->dt_size);
         p += H5O_ALIGN_OLD(attr->shared->dt_size);
     } /* end if */
     else
         p += attr->shared->dt_size;
 
     /* encode the attribute dataspace */
-    if ((H5O_MSG_SDSPACE->encode)(f, false, p, &(attr->shared->ds->extent)) < 0)
+    if ((H5O_MSG_SDSPACE->encode)(f, false, SIZE_MAX, p, &(attr->shared->ds->extent)) < 0)
         HGOTO_ERROR(H5E_ATTR, H5E_CANTENCODE, FAIL, "can't encode attribute dataspace");
 
     if (attr->shared->version < H5O_ATTR_VERSION_2) {
         memset(p + attr->shared->ds_size, 0, H5O_ALIGN_OLD(attr->shared->ds_size) - attr->shared->ds_size);
         p += H5O_ALIGN_OLD(attr->shared->ds_size);
     } /* end if */
     else
         p += attr->shared->ds_size;
 
     /* Store attribute data.  If there's no data, store 0 as fill value. */
     if (attr->shared->data)
         H5MM_memcpy(p, attr->shared->data, attr->shared->data_size);
     else
         memset(p, 0, attr->shared->data_size);
diff --git a/src/H5Obogus.c b/src/H5Obogus.c
index c9c2196b0f..4948d61c96 100644
--- a/src/H5Obogus.c
+++ b/src/H5Obogus.c
@@ -35,7 +35,8 @@
 /* PRIVATE PROTOTYPES */
 static void  *H5O__bogus_decode(H5F_t *f, H5O_t *open_oh, unsigned mesg_flags, unsigned *ioflags,
                                 size_t p_size, const uint8_t *p);
-static herr_t H5O__bogus_encode(H5F_t *f, bool disable_shared, uint8_t *p, const void *_mesg);
+static herr_t H5O__bogus_encode(H5F_t *f, bool disable_shared, size_t H5_ATTR_UNUSED p_size, uint8_t *p,
+                                const void *_mesg);
 static size_t H5O__bogus_size(const H5F_t *f, bool disable_shared, const void *_mesg);
 static herr_t H5O__bogus_debug(H5F_t *f, const void *_mesg, FILE *stream, int indent, int fwidth);
 
@@ -142,33 +143,33 @@ done:
  *-------------------------------------------------------------------------
  */
 static herr_t
-H5O__bogus_encode(H5F_t H5_ATTR_UNUSED *f, bool H5_ATTR_UNUSED disable_shared, uint8_t *p,
-                  const void H5_ATTR_UNUSED *mesg)
+H5O__bogus_encode(H5F_t H5_ATTR_UNUSED *f, bool H5_ATTR_UNUSED disable_shared, size_t H5_ATTR_UNUSED p_size,
+                  uint8_t *p, const void H5_ATTR_UNUSED *mesg)
 {
     FUNC_ENTER_PACKAGE_NOERR
 
     /* check args */
     assert(f);
     assert(p);
     assert(mesg);
 
     /* encode */
     UINT32ENCODE(p, H5O_BOGUS_VALUE);
 
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5O__bogus_encode() */
 
 /*-------------------------------------------------------------------------
  * Function:    H5O__bogus_size
  *
  * Purpose:     Returns the size of the raw message in bytes not
  *              counting the message typ or size fields, but only the data
  *              fields.  This function doesn't take into account
  *              alignment.
  *
  * Return:      Success:        Message data size in bytes w/o alignment.
  *
  *              Failure:        Negative
  *
  *-------------------------------------------------------------------------
  */
diff --git a/src/H5Obtreek.c b/src/H5Obtreek.c
index 7f56b43245..42e1ce0c32 100644
--- a/src/H5Obtreek.c
+++ b/src/H5Obtreek.c
@@ -24,7 +24,8 @@
 
 static void  *H5O__btreek_decode(H5F_t *f, H5O_t *open_oh, unsigned mesg_flags, unsigned *ioflags,
                                  size_t p_size, const uint8_t *p);
-static herr_t H5O__btreek_encode(H5F_t *f, bool disable_shared, uint8_t *p, const void *_mesg);
+static herr_t H5O__btreek_encode(H5F_t *f, bool disable_shared, size_t H5_ATTR_UNUSED p_size, uint8_t *p,
+                                 const void *_mesg);
 static void  *H5O__btreek_copy(const void *_mesg, void *_dest);
 static size_t H5O__btreek_size(const H5F_t *f, bool disable_shared, const void *_mesg);
 static herr_t H5O__btreek_debug(H5F_t *f, const void *_mesg, FILE *stream, int indent, int fwidth);
@@ -120,34 +121,35 @@ done:
  *-------------------------------------------------------------------------
  */
 static herr_t
-H5O__btreek_encode(H5F_t H5_ATTR_UNUSED *f, bool H5_ATTR_UNUSED disable_shared, uint8_t *p, const void *_mesg)
+H5O__btreek_encode(H5F_t H5_ATTR_UNUSED *f, bool H5_ATTR_UNUSED disable_shared, size_t H5_ATTR_UNUSED p_size,
+                   uint8_t *p, const void *_mesg)
 {
     const H5O_btreek_t *mesg = (const H5O_btreek_t *)_mesg;
 
     FUNC_ENTER_PACKAGE_NOERR
 
     /* Sanity check */
     assert(f);
     assert(p);
     assert(mesg);
 
     /* Store version and non-default v1 B-tree 'K' values */
     *p++ = H5O_BTREEK_VERSION;
     UINT16ENCODE(p, mesg->btree_k[H5B_CHUNK_ID]);
     UINT16ENCODE(p, mesg->btree_k[H5B_SNODE_ID]);
     UINT16ENCODE(p, mesg->sym_leaf_k);
 
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5O__btreek_encode() */
 
 /*-------------------------------------------------------------------------
  * Function:	H5O__btreek_copy
  *
  * Purpose:	Copies a message from _MESG to _DEST, allocating _DEST if
  *		necessary.
  *
  * Return:	Success:	Ptr to _DEST
  *		Failure:	NULL
  *
  *-------------------------------------------------------------------------
  */
diff --git a/src/H5Ocache_image.c b/src/H5Ocache_image.c
index 7c71178cc1..d91b46341c 100644
--- a/src/H5Ocache_image.c
+++ b/src/H5Ocache_image.c
@@ -36,7 +36,8 @@
 /* Callbacks for message class */
 static void *H5O__mdci_decode(H5F_t *f, H5O_t *open_oh, unsigned mesg_flags, unsigned *ioflags, size_t p_size,
                               const uint8_t *p);
-static herr_t H5O__mdci_encode(H5F_t *f, bool disable_shared, uint8_t *p, const void *_mesg);
+static herr_t H5O__mdci_encode(H5F_t *f, bool disable_shared, size_t H5_ATTR_UNUSED p_size, uint8_t *p,
+                               const void *_mesg);
 static void  *H5O__mdci_copy(const void *_mesg, void *_dest);
 static size_t H5O__mdci_size(const H5F_t *f, bool disable_shared, const void *_mesg);
 static herr_t H5O__mdci_free(void *mesg);
@@ -135,33 +136,34 @@ done:
  *-------------------------------------------------------------------------
  */
 static herr_t
-H5O__mdci_encode(H5F_t *f, bool H5_ATTR_UNUSED disable_shared, uint8_t *p, const void *_mesg)
+H5O__mdci_encode(H5F_t *f, bool H5_ATTR_UNUSED disable_shared, size_t H5_ATTR_UNUSED p_size, uint8_t *p,
+                 const void *_mesg)
 {
     const H5O_mdci_t *mesg = (const H5O_mdci_t *)_mesg;
 
     FUNC_ENTER_PACKAGE_NOERR
 
     /* Sanity check */
     assert(f);
     assert(p);
     assert(mesg);
 
     /* encode */
     *p++ = H5O_MDCI_VERSION_0;
     H5F_addr_encode(f, &p, mesg->addr);
     H5F_ENCODE_LENGTH(f, p, mesg->size);
 
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5O__mdci_encode() */
 
 /*-------------------------------------------------------------------------
  * Function:    H5O__mdci_copy
  *
  * Purpose:     Copies a message from _MESG to _DEST, allocating _DEST if
  *              necessary.
  *
  * Return:      Success:        Ptr to _DEST
  *              Failure:        NULL
  *
  *-------------------------------------------------------------------------
  */
diff --git a/src/H5Ocont.c b/src/H5Ocont.c
index ff082181d4..6894eca211 100644
--- a/src/H5Ocont.c
+++ b/src/H5Ocont.c
@@ -33,7 +33,8 @@
 /* PRIVATE PROTOTYPES */
 static void *H5O__cont_decode(H5F_t *f, H5O_t *open_oh, unsigned mesg_flags, unsigned *ioflags, size_t p_size,
                               const uint8_t *p);
-static herr_t H5O__cont_encode(H5F_t *f, bool disable_shared, uint8_t *p, const void *_mesg);
+static herr_t H5O__cont_encode(H5F_t *f, bool disable_shared, size_t H5_ATTR_UNUSED p_size, uint8_t *p,
+                               const void *_mesg);
 static size_t H5O__cont_size(const H5F_t *f, bool disable_shared, const void *_mesg);
 static herr_t H5O__cont_free(void *mesg);
 static herr_t H5O__cont_delete(H5F_t *f, H5O_t *open_oh, void *_mesg);
@@ -122,36 +123,37 @@ done:
  *-------------------------------------------------------------------------
  */
 static herr_t
-H5O__cont_encode(H5F_t *f, bool H5_ATTR_UNUSED disable_shared, uint8_t *p, const void *_mesg)
+H5O__cont_encode(H5F_t *f, bool H5_ATTR_UNUSED disable_shared, size_t H5_ATTR_UNUSED p_size, uint8_t *p,
+                 const void *_mesg)
 {
     const H5O_cont_t *cont = (const H5O_cont_t *)_mesg;
 
     FUNC_ENTER_PACKAGE_NOERR
 
     /* check args */
     assert(f);
     assert(p);
     assert(cont);
     assert(H5_addr_defined(cont->addr));
     assert(cont->size > 0);
 
     /* encode */
     H5F_addr_encode(f, &p, cont->addr);
     H5F_ENCODE_LENGTH(f, p, cont->size);
 
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5O__cont_encode() */
 
 /*-------------------------------------------------------------------------
  * Function:    H5O__cont_size
  *
  * Purpose:     Returns the size of the raw message in bytes not counting
  *              the message type or size fields, but only the data fields.
  *              This function doesn't take into account alignment.
  *
  * Return:      Success:        Message data size in bytes without alignment.
  *
  *              Failure:        zero
  *
  *-------------------------------------------------------------------------
  */
diff --git a/src/H5Odrvinfo.c b/src/H5Odrvinfo.c
index 4ff9873886..baec777d0f 100644
--- a/src/H5Odrvinfo.c
+++ b/src/H5Odrvinfo.c
@@ -23,7 +23,8 @@
 
 static void  *H5O__drvinfo_decode(H5F_t *f, H5O_t *open_oh, unsigned mesg_flags, unsigned *ioflags,
                                   size_t p_size, const uint8_t *p);
-static herr_t H5O__drvinfo_encode(H5F_t *f, bool disable_shared, uint8_t *p, const void *_mesg);
+static herr_t H5O__drvinfo_encode(H5F_t *f, bool disable_shared, size_t H5_ATTR_UNUSED p_size, uint8_t *p,
+                                  const void *_mesg);
 static void  *H5O__drvinfo_copy(const void *_mesg, void *_dest);
 static size_t H5O__drvinfo_size(const H5F_t *f, bool disable_shared, const void *_mesg);
 static herr_t H5O__drvinfo_reset(void *_mesg);
@@ -135,37 +136,37 @@ done:
  *-------------------------------------------------------------------------
  */
 static herr_t
-H5O__drvinfo_encode(H5F_t H5_ATTR_UNUSED *f, bool H5_ATTR_UNUSED disable_shared, uint8_t *p,
-                    const void *_mesg)
+H5O__drvinfo_encode(H5F_t H5_ATTR_UNUSED *f, bool H5_ATTR_UNUSED disable_shared, size_t H5_ATTR_UNUSED p_size,
+                    uint8_t *p, const void *_mesg)
 {
     const H5O_drvinfo_t *mesg = (const H5O_drvinfo_t *)_mesg;
 
     FUNC_ENTER_PACKAGE_NOERR
 
     /* Sanity check */
     assert(f);
     assert(p);
     assert(mesg);
 
     /* Store version, driver name, buffer length, & encoded buffer */
     *p++ = H5O_DRVINFO_VERSION;
     H5MM_memcpy(p, mesg->name, 8);
     p += 8;
     assert(mesg->len <= 65535);
     UINT16ENCODE(p, mesg->len);
     H5MM_memcpy(p, mesg->buf, mesg->len);
 
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5O__drvinfo_encode() */
 
 /*-------------------------------------------------------------------------
  * Function:	H5O__drvinfo_copy
  *
  * Purpose:	Copies a message from _MESG to _DEST, allocating _DEST if
  *		necessary.
  *
  * Return:	Success:	Ptr to _DEST
  *		Failure:	NULL
  *
  *-------------------------------------------------------------------------
  */
diff --git a/src/H5Oefl.c b/src/H5Oefl.c
index c06ecf6869..ebd92a733b 100644
--- a/src/H5Oefl.c
+++ b/src/H5Oefl.c
@@ -22,7 +22,8 @@
 /* PRIVATE PROTOTYPES */
 static void  *H5O__efl_decode(H5F_t *f, H5O_t *open_oh, unsigned mesg_flags, unsigned *ioflags, size_t p_size,
                               const uint8_t *p);
-static herr_t H5O__efl_encode(H5F_t *f, bool disable_shared, uint8_t *p, const void *_mesg);
+static herr_t H5O__efl_encode(H5F_t *f, bool disable_shared, size_t H5_ATTR_UNUSED p_size, uint8_t *p,
+                              const void *_mesg);
 static void  *H5O__efl_copy(const void *_mesg, void *_dest);
 static size_t H5O__efl_size(const H5F_t *f, bool disable_shared, const void *_mesg);
 static herr_t H5O__efl_reset(void *_mesg);
@@ -197,60 +198,61 @@ done:
  *-------------------------------------------------------------------------
  */
 static herr_t
-H5O__efl_encode(H5F_t *f, bool H5_ATTR_UNUSED disable_shared, uint8_t *p, const void *_mesg)
+H5O__efl_encode(H5F_t *f, bool H5_ATTR_UNUSED disable_shared, size_t H5_ATTR_UNUSED p_size, uint8_t *p,
+                const void *_mesg)
 {
     const H5O_efl_t *mesg = (const H5O_efl_t *)_mesg;
     size_t           u; /* Local index variable */
 
     FUNC_ENTER_PACKAGE_NOERR
 
     /* check args */
     assert(f);
     assert(mesg);
     assert(p);
 
     /* Version */
     *p++ = H5O_EFL_VERSION;
 
     /* Reserved */
     *p++ = 0;
     *p++ = 0;
     *p++ = 0;
 
     /* Number of slots */
     assert(mesg->nalloc > 0);
     UINT16ENCODE(p, mesg->nused); /*yes, twice*/
     assert(mesg->nused > 0 && mesg->nused <= mesg->nalloc);
     UINT16ENCODE(p, mesg->nused);
 
     /* Heap address */
     assert(H5_addr_defined(mesg->heap_addr));
     H5F_addr_encode(f, &p, mesg->heap_addr);
 
     /* Encode file list */
     for (u = 0; u < mesg->nused; u++) {
         /*
          * The name should have been added to the heap when the dataset was
          * created.
          */
         assert(mesg->slot[u].name_offset);
         H5F_ENCODE_LENGTH(f, p, mesg->slot[u].name_offset);
         H5F_ENCODE_LENGTH(f, p, (hsize_t)mesg->slot[u].offset);
         H5F_ENCODE_LENGTH(f, p, mesg->slot[u].size);
     } /* end for */
 
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5O__efl_encode() */
 
 /*-------------------------------------------------------------------------
  * Function:	H5O__efl_copy
  *
  * Purpose:	Copies a message from _MESG to _DEST, allocating _DEST if
  *		necessary.
  *
  * Return:	Success:	Ptr to _DEST
  *
  *		Failure:	NULL
  *
  *-------------------------------------------------------------------------
  */
diff --git a/src/H5Ofsinfo.c b/src/H5Ofsinfo.c
index 70f34fe7ad..f9cb8feb11 100644
--- a/src/H5Ofsinfo.c
+++ b/src/H5Ofsinfo.c
@@ -30,7 +30,8 @@
 /* PRIVATE PROTOTYPES */
 static void  *H5O__fsinfo_decode(H5F_t *f, H5O_t *open_oh, unsigned mesg_flags, unsigned *ioflags,
                                  size_t p_size, const uint8_t *p);
-static herr_t H5O__fsinfo_encode(H5F_t *f, bool disable_shared, uint8_t *p, const void *_mesg);
+static herr_t H5O__fsinfo_encode(H5F_t *f, bool disable_shared, size_t H5_ATTR_UNUSED p_size, uint8_t *p,
+                                 const void *_mesg);
 static void  *H5O__fsinfo_copy(const void *_mesg, void *_dest);
 static size_t H5O__fsinfo_size(const H5F_t *f, bool disable_shared, const void *_mesg);
 static herr_t H5O__fsinfo_free(void *mesg);
@@ -222,44 +223,45 @@ done:
  *-------------------------------------------------------------------------
  */
 static herr_t
-H5O__fsinfo_encode(H5F_t *f, bool H5_ATTR_UNUSED disable_shared, uint8_t *p, const void *_mesg)
+H5O__fsinfo_encode(H5F_t *f, bool H5_ATTR_UNUSED disable_shared, size_t H5_ATTR_UNUSED p_size, uint8_t *p,
+                   const void *_mesg)
 {
     const H5O_fsinfo_t *fsinfo = (const H5O_fsinfo_t *)_mesg;
     H5F_mem_page_t      ptype; /* Memory type for iteration */
 
     FUNC_ENTER_PACKAGE_NOERR
 
     /* check args */
     assert(f);
     assert(p);
     assert(fsinfo);
 
     *p++ = (uint8_t)fsinfo->version;            /* message version */
     *p++ = (uint8_t)fsinfo->strategy;           /* File space strategy */
     *p++ = (unsigned char)fsinfo->persist;      /* Free-space persist or not */
     H5F_ENCODE_LENGTH(f, p, fsinfo->threshold); /* Free-space section size threshold */
 
     H5F_ENCODE_LENGTH(f, p, fsinfo->page_size);          /* File space page size */
     UINT16ENCODE(p, fsinfo->pgend_meta_thres);           /* Page end metadata threshold */
     H5F_addr_encode(f, &p, fsinfo->eoa_pre_fsm_fsalloc); /* EOA before free-space header and section info */
 
     /* Store addresses of free-space managers, if persisting */
     if (fsinfo->persist)
         /* Addresses of free-space managers */
         for (ptype = H5F_MEM_PAGE_SUPER; ptype < H5F_MEM_PAGE_NTYPES; ptype++)
             H5F_addr_encode(f, &p, fsinfo->fs_addr[ptype - 1]);
 
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5O__fsinfo_encode() */
 
 /*-------------------------------------------------------------------------
  * Function:    H5O__fsinfo_copy
  *
  * Purpose:     Copies a message from _MESG to _DEST, allocating _DEST if
  *              necessary.
  *
  * Return:      Success:        Ptr to _DEST
  *              Failure:        NULL
  *
  *-------------------------------------------------------------------------
  */
diff --git a/src/H5Oginfo.c b/src/H5Oginfo.c
index 72d15afd64..645c5ff81a 100644
--- a/src/H5Oginfo.c
+++ b/src/H5Oginfo.c
@@ -29,7 +29,8 @@
 /* PRIVATE PROTOTYPES */
 static void  *H5O__ginfo_decode(H5F_t *f, H5O_t *open_oh, unsigned mesg_flags, unsigned *ioflags,
                                 size_t p_size, const uint8_t *p);
-static herr_t H5O__ginfo_encode(H5F_t *f, bool disable_shared, uint8_t *p, const void *_mesg);
+static herr_t H5O__ginfo_encode(H5F_t *f, bool disable_shared, size_t H5_ATTR_UNUSED p_size, uint8_t *p,
+                                const void *_mesg);
 static void  *H5O__ginfo_copy(const void *_mesg, void *_dest);
 static size_t H5O__ginfo_size(const H5F_t *f, bool disable_shared, const void *_mesg);
 static herr_t H5O__ginfo_free(void *_mesg);
@@ -158,49 +159,50 @@ done:
  *-------------------------------------------------------------------------
  */
 static herr_t
-H5O__ginfo_encode(H5F_t H5_ATTR_UNUSED *f, bool H5_ATTR_UNUSED disable_shared, uint8_t *p, const void *_mesg)
+H5O__ginfo_encode(H5F_t H5_ATTR_UNUSED *f, bool H5_ATTR_UNUSED disable_shared, size_t H5_ATTR_UNUSED p_size,
+                  uint8_t *p, const void *_mesg)
 {
     const H5O_ginfo_t *ginfo = (const H5O_ginfo_t *)_mesg;
     unsigned char      flags = 0; /* Flags for encoding group info */
 
     FUNC_ENTER_PACKAGE_NOERR
 
     /* check args */
     assert(p);
     assert(ginfo);
 
     /* Message version */
     *p++ = H5O_GINFO_VERSION;
 
     /* The flags for the group info */
     flags = (unsigned char)(ginfo->store_link_phase_change ? H5O_GINFO_STORE_PHASE_CHANGE : 0);
     flags = (unsigned char)(flags | (ginfo->store_est_entry_info ? H5O_GINFO_STORE_EST_ENTRY_INFO : 0));
     *p++  = flags;
 
     /* Store the max. # of links to store compactly & the min. # of links to store densely */
     if (ginfo->store_link_phase_change) {
         UINT16ENCODE(p, ginfo->max_compact);
         UINT16ENCODE(p, ginfo->min_dense);
     } /* end if */
 
     /* Estimated # of entries & name lengths */
     if (ginfo->store_est_entry_info) {
         UINT16ENCODE(p, ginfo->est_num_entries);
         UINT16ENCODE(p, ginfo->est_name_len);
     } /* end if */
 
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5O__ginfo_encode() */
 
 /*-------------------------------------------------------------------------
  * Function:    H5O__ginfo_copy
  *
  * Purpose:     Copies a message from _MESG to _DEST, allocating _DEST if
  *              necessary.
  *
  * Return:      Success:        Ptr to _DEST
  *
  *              Failure:        NULL
  *
  *-------------------------------------------------------------------------
  */
diff --git a/src/H5Olayout.c b/src/H5Olayout.c
index 1f2b6862b6..75456d6e85 100644
--- a/src/H5Olayout.c
+++ b/src/H5Olayout.c
@@ -31,7 +31,8 @@
 /* PRIVATE PROTOTYPES */
 static void  *H5O__layout_decode(H5F_t *f, H5O_t *open_oh, unsigned mesg_flags, unsigned *ioflags,
                                  size_t p_size, const uint8_t *p);
-static herr_t H5O__layout_encode(H5F_t *f, bool disable_shared, uint8_t *p, const void *_mesg);
+static herr_t H5O__layout_encode(H5F_t *f, bool disable_shared, size_t H5_ATTR_UNUSED p_size, uint8_t *p,
+                                 const void *_mesg);
 static void  *H5O__layout_copy(const void *_mesg, void *_dest);
 static size_t H5O__layout_size(const H5F_t *f, bool disable_shared, const void *_mesg);
 static herr_t H5O__layout_reset(void *_mesg);
@@ -794,140 +795,141 @@ done:
  *-------------------------------------------------------------------------
  */
 static herr_t
-H5O__layout_encode(H5F_t *f, bool H5_ATTR_UNUSED disable_shared, uint8_t *p, const void *_mesg)
+H5O__layout_encode(H5F_t *f, bool H5_ATTR_UNUSED disable_shared, size_t H5_ATTR_UNUSED p_size, uint8_t *p,
+                   const void *_mesg)
 {
     const H5O_layout_t *mesg = (const H5O_layout_t *)_mesg;
     unsigned            u;
     herr_t              ret_value = SUCCEED; /* Return value */
 
     FUNC_ENTER_PACKAGE
 
     /* check args */
     assert(f);
     assert(mesg);
     assert(p);
 
     /* Message version */
     *p++ = (uint8_t)((mesg->version < H5O_LAYOUT_VERSION_3) ? H5O_LAYOUT_VERSION_3 : mesg->version);
 
     /* Layout class */
     *p++ = (uint8_t)mesg->type;
 
     /* Write out layout class specific information */
     switch (mesg->type) {
         case H5D_COMPACT:
             /* Size of raw data */
             UINT16ENCODE(p, mesg->storage.u.compact.size);
 
             /* Raw data */
             if (mesg->storage.u.compact.size > 0) {
                 if (mesg->storage.u.compact.buf)
                     H5MM_memcpy(p, mesg->storage.u.compact.buf, mesg->storage.u.compact.size);
                 else
                     memset(p, 0, mesg->storage.u.compact.size);
                 p += mesg->storage.u.compact.size;
             } /* end if */
             break;
 
         case H5D_CONTIGUOUS:
             /* Contiguous storage address */
             H5F_addr_encode(f, &p, mesg->storage.u.contig.addr);
 
             /* Contiguous storage size */
             H5F_ENCODE_LENGTH(f, p, mesg->storage.u.contig.size);
             break;
 
         case H5D_CHUNKED:
             if (mesg->version < H5O_LAYOUT_VERSION_4) {
                 /* Number of dimensions */
                 assert(mesg->u.chunk.ndims > 0 && mesg->u.chunk.ndims <= H5O_LAYOUT_NDIMS);
                 *p++ = (uint8_t)mesg->u.chunk.ndims;
 
                 /* B-tree address */
                 H5F_addr_encode(f, &p, mesg->storage.u.chunk.idx_addr);
 
                 /* Dimension sizes */
                 for (u = 0; u < mesg->u.chunk.ndims; u++)
                     UINT32ENCODE(p, mesg->u.chunk.dim[u]);
             } /* end if */
             else {
                 /* Chunk feature flags */
                 *p++ = mesg->u.chunk.flags;
 
                 /* Number of dimensions */
                 assert(mesg->u.chunk.ndims > 0 && mesg->u.chunk.ndims <= H5O_LAYOUT_NDIMS);
                 *p++ = (uint8_t)mesg->u.chunk.ndims;
 
                 /* Encoded # of bytes for each chunk dimension */
                 assert(mesg->u.chunk.enc_bytes_per_dim > 0 && mesg->u.chunk.enc_bytes_per_dim <= 8);
                 *p++ = (uint8_t)mesg->u.chunk.enc_bytes_per_dim;
 
                 /* Dimension sizes */
                 for (u = 0; u < mesg->u.chunk.ndims; u++)
                     UINT64ENCODE_VAR(p, mesg->u.chunk.dim[u], mesg->u.chunk.enc_bytes_per_dim);
 
                 /* Chunk index type */
                 *p++ = (uint8_t)mesg->u.chunk.idx_type;
 
                 switch (mesg->u.chunk.idx_type) {
                     case H5D_CHUNK_IDX_BTREE:
                         HGOTO_ERROR(H5E_OHDR, H5E_BADVALUE, FAIL,
                                     "v1 B-tree index type should never be in a v4 layout message");
                         break;
 
                     case H5D_CHUNK_IDX_NONE: /* Implicit */
                         break;
 
                     case H5D_CHUNK_IDX_SINGLE: /* Single Chunk */
                         /* Filter information */
                         if (mesg->u.chunk.flags & H5O_LAYOUT_CHUNK_SINGLE_INDEX_WITH_FILTER) {
                             H5F_ENCODE_LENGTH(f, p, mesg->storage.u.chunk.u.single.nbytes);
                             UINT32ENCODE(p, mesg->storage.u.chunk.u.single.filter_mask);
                         } /* end if */
                         break;
 
                     case H5D_CHUNK_IDX_FARRAY:
                         /* Fixed array creation parameters */
                         *p++ = mesg->u.chunk.u.farray.cparam.max_dblk_page_nelmts_bits;
                         break;
 
                     case H5D_CHUNK_IDX_EARRAY:
                         /* Extensible array creation parameters */
                         *p++ = mesg->u.chunk.u.earray.cparam.max_nelmts_bits;
                         *p++ = mesg->u.chunk.u.earray.cparam.idx_blk_elmts;
                         *p++ = mesg->u.chunk.u.earray.cparam.sup_blk_min_data_ptrs;
                         *p++ = mesg->u.chunk.u.earray.cparam.data_blk_min_elmts;
                         *p++ = mesg->u.chunk.u.earray.cparam.max_dblk_page_nelmts_bits;
                         break;
 
                     case H5D_CHUNK_IDX_BT2: /* v2 B-tree index */
                         UINT32ENCODE(p, mesg->u.chunk.u.btree2.cparam.node_size);
                         *p++ = mesg->u.chunk.u.btree2.cparam.split_percent;
                         *p++ = mesg->u.chunk.u.btree2.cparam.merge_percent;
                         break;
 
                     case H5D_CHUNK_IDX_NTYPES:
                     default:
                         HGOTO_ERROR(H5E_OHDR, H5E_CANTENCODE, FAIL, "Invalid chunk index type");
                 } /* end switch */
 
                 /*
                  * Implicit index: Address of the chunks
                  * Single chunk index: address of the single chunk
                  * Other indexes: chunk index address
                  */
                 H5F_addr_encode(f, &p, mesg->storage.u.chunk.idx_addr);
             } /* end else */
             break;
 
         case H5D_VIRTUAL:
             /* Encode heap ID for VDS info */
             H5F_addr_encode(f, &p, mesg->storage.u.virt.serial_list_hobjid.addr);
             UINT32ENCODE(p, mesg->storage.u.virt.serial_list_hobjid.idx);
             break;
 
         case H5D_LAYOUT_ERROR:
         case H5D_NLAYOUTS:
         default:
             HGOTO_ERROR(H5E_OHDR, H5E_CANTENCODE, FAIL, "Invalid layout class");
     } /* end switch */
diff --git a/src/H5Olinfo.c b/src/H5Olinfo.c
index 9d26483b17..830e4e3113 100644
--- a/src/H5Olinfo.c
+++ b/src/H5Olinfo.c
@@ -33,7 +33,8 @@
 /* PRIVATE PROTOTYPES */
 static void  *H5O__linfo_decode(H5F_t *f, H5O_t *open_oh, unsigned mesg_flags, unsigned *ioflags,
                                 size_t p_size, const uint8_t *p);
-static herr_t H5O__linfo_encode(H5F_t *f, bool disable_shared, uint8_t *p, const void *_mesg);
+static herr_t H5O__linfo_encode(H5F_t *f, bool disable_shared, size_t H5_ATTR_UNUSED p_size, uint8_t *p,
+                                const void *_mesg);
 static void  *H5O__linfo_copy(const void *_mesg, void *_dest);
 static size_t H5O__linfo_size(const H5F_t *f, bool disable_shared, const void *_mesg);
 static herr_t H5O__linfo_free(void *_mesg);
@@ -183,53 +184,54 @@ done:
  *-------------------------------------------------------------------------
  */
 static herr_t
-H5O__linfo_encode(H5F_t *f, bool H5_ATTR_UNUSED disable_shared, uint8_t *p, const void *_mesg)
+H5O__linfo_encode(H5F_t *f, bool H5_ATTR_UNUSED disable_shared, size_t H5_ATTR_UNUSED p_size, uint8_t *p,
+                  const void *_mesg)
 {
     const H5O_linfo_t *linfo = (const H5O_linfo_t *)_mesg;
     unsigned char      index_flags; /* Flags for encoding link index info */
 
     FUNC_ENTER_PACKAGE_NOERR
 
     /* check args */
     assert(f);
     assert(p);
     assert(linfo);
 
     /* Message version */
     *p++ = H5O_LINFO_VERSION;
 
     /* The flags for the link indices */
     index_flags = (uint8_t)(linfo->track_corder ? H5O_LINFO_TRACK_CORDER : 0);
     index_flags = (uint8_t)(index_flags | (linfo->index_corder ? H5O_LINFO_INDEX_CORDER : 0));
     *p++        = index_flags;
 
     /* Max. link creation order value for the group, if tracked */
     if (linfo->track_corder)
         INT64ENCODE(p, linfo->max_corder);
 
     /* Address of fractal heap to store "dense" links */
     H5F_addr_encode(f, &p, linfo->fheap_addr);
 
     /* Address of v2 B-tree to index names of links */
     H5F_addr_encode(f, &p, linfo->name_bt2_addr);
 
     /* Address of v2 B-tree to index creation order of links, if they are indexed */
     if (linfo->index_corder)
         H5F_addr_encode(f, &p, linfo->corder_bt2_addr);
     else
         assert(!H5_addr_defined(linfo->corder_bt2_addr));
 
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5O__linfo_encode() */
 
 /*-------------------------------------------------------------------------
  * Function:    H5O__linfo_copy
  *
  * Purpose:     Copies a message from _MESG to _DEST, allocating _DEST if
  *              necessary.
  *
  * Return:      Success:        Ptr to _DEST
  *              Failure:        NULL
  *
  *-------------------------------------------------------------------------
  */
diff --git a/src/H5Olink.c b/src/H5Olink.c
index 9d4d6853b0..6657a500c1 100644
--- a/src/H5Olink.c
+++ b/src/H5Olink.c
@@ -35,7 +35,8 @@
 /* PRIVATE PROTOTYPES */
 static void *H5O__link_decode(H5F_t *f, H5O_t *open_oh, unsigned mesg_flags, unsigned *ioflags, size_t p_size,
                               const uint8_t *p);
-static herr_t H5O__link_encode(H5F_t *f, bool disable_shared, uint8_t *p, const void *_mesg);
+static herr_t H5O__link_encode(H5F_t *f, bool disable_shared, size_t H5_ATTR_UNUSED p_size, uint8_t *p,
+                               const void *_mesg);
 static void  *H5O__link_copy(const void *_mesg, void *_dest);
 static size_t H5O__link_size(const H5F_t *f, bool disable_shared, const void *_mesg);
 static herr_t H5O__link_reset(void *_mesg);
@@ -289,123 +290,124 @@ done:
  *-------------------------------------------------------------------------
  */
 static herr_t
-H5O__link_encode(H5F_t *f, bool H5_ATTR_UNUSED disable_shared, uint8_t *p, const void *_mesg)
+H5O__link_encode(H5F_t *f, bool H5_ATTR_UNUSED disable_shared, size_t H5_ATTR_UNUSED p_size, uint8_t *p,
+                 const void *_mesg)
 {
     const H5O_link_t *lnk = (const H5O_link_t *)_mesg;
     uint64_t          len;        /* Length of a string in the message */
     unsigned char     link_flags; /* Flags for encoding link info */
 
     FUNC_ENTER_PACKAGE_NOERR
 
     /* check args */
     assert(f);
     assert(p);
     assert(lnk);
 
     /* Get length of link's name */
     len = (uint64_t)strlen(lnk->name);
     assert(len > 0);
 
     /* encode */
     *p++ = H5O_LINK_VERSION;
 
     /* The encoding flags for the link */
     if (len > 4294967295)
         link_flags = H5O_LINK_NAME_8;
     else if (len > 65535)
         link_flags = H5O_LINK_NAME_4;
     else if (len > 255)
         link_flags = H5O_LINK_NAME_2;
     else
         link_flags = H5O_LINK_NAME_1;
     link_flags = (unsigned char)(link_flags | (lnk->corder_valid ? H5O_LINK_STORE_CORDER : 0));
     link_flags = (unsigned char)(link_flags | ((lnk->type != H5L_TYPE_HARD) ? H5O_LINK_STORE_LINK_TYPE : 0));
     link_flags = (unsigned char)(link_flags | ((lnk->cset != H5T_CSET_ASCII) ? H5O_LINK_STORE_NAME_CSET : 0));
     *p++       = link_flags;
 
     /* Store the type of a non-default link */
     if (link_flags & H5O_LINK_STORE_LINK_TYPE)
         *p++ = (uint8_t)lnk->type;
 
     /* Store the link creation order in the file, if its valid */
     if (lnk->corder_valid)
         INT64ENCODE(p, lnk->corder);
 
     /* Store a non-default link name character set */
     if (link_flags & H5O_LINK_STORE_NAME_CSET)
         *p++ = (uint8_t)lnk->cset;
 
     /* Store the link name's length */
     switch (link_flags & H5O_LINK_NAME_SIZE) {
         case 0: /* 1 byte size */
             *p++ = (uint8_t)len;
             break;
 
         case 1: /* 2 byte size */
             UINT16ENCODE(p, len);
             break;
 
         case 2: /* 4 byte size */
             UINT32ENCODE(p, len);
             break;
 
         case 3: /* 8 byte size */
             UINT64ENCODE(p, len);
             break;
 
         default:
             assert(0 && "bad size for name");
     } /* end switch */
 
     /* Store the link's name */
     H5MM_memcpy(p, lnk->name, (size_t)len);
     p += len;
 
     /* Store the appropriate information for each type of link */
     switch (lnk->type) {
         case H5L_TYPE_HARD:
             /* Store the address of the object the link points to */
             H5F_addr_encode(f, &p, lnk->u.hard.addr);
             break;
 
         case H5L_TYPE_SOFT:
             /* Store the link value */
             len = (uint16_t)strlen(lnk->u.soft.name);
             assert(len > 0);
             UINT16ENCODE(p, len);
             H5MM_memcpy(p, lnk->u.soft.name, (size_t)len);
             p += len;
             break;
 
         /* User-defined links */
         case H5L_TYPE_EXTERNAL:
         case H5L_TYPE_ERROR:
         case H5L_TYPE_MAX:
         default:
             assert(lnk->type >= H5L_TYPE_UD_MIN && lnk->type <= H5L_TYPE_MAX);
 
             /* Store the user-supplied data, however long it is */
             len = (uint16_t)lnk->u.ud.size;
             UINT16ENCODE(p, len);
             if (len > 0) {
                 H5MM_memcpy(p, lnk->u.ud.udata, (size_t)len);
                 p += len;
             }
             break;
     } /* end switch */
 
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5O__link_encode() */
 
 /*-------------------------------------------------------------------------
  * Function:    H5O__link_copy
  *
  * Purpose:     Copies a message from _MESG to _DEST, allocating _DEST if
  *              necessary.
  *
  * Return:      Success:        Ptr to _DEST
  *
  *              Failure:        NULL
  *
  *-------------------------------------------------------------------------
  */
diff --git a/src/H5Omessage.c b/src/H5Omessage.c
index f6cafdc89a..bc4381b2dd 100644
--- a/src/H5Omessage.c
+++ b/src/H5Omessage.c
@@ -1586,18 +1586,18 @@ herr_t
 H5O_msg_encode(H5F_t *f, unsigned type_id, bool disable_shared, unsigned char *buf, const void *mesg)
 {
     const H5O_msg_class_t *type;                /* Actual H5O class type for the ID */
     herr_t                 ret_value = SUCCEED; /* Return value */
 
     FUNC_ENTER_NOAPI(FAIL)
 
     /* check args */
     assert(f);
     assert(type_id < NELMTS(H5O_msg_class_g));
     type = H5O_msg_class_g[type_id]; /* map the type ID to the actual type object */
     assert(type);
 
     /* Encode */
-    if ((type->encode)(f, disable_shared, buf, mesg) < 0)
+    if ((type->encode)(f, disable_shared, SIZE_MAX, buf, mesg) < 0)
         HGOTO_ERROR(H5E_OHDR, H5E_CANTENCODE, FAIL, "unable to encode message");
 
 done:
@@ -1900,81 +1900,81 @@ herr_t
 H5O_msg_flush(H5F_t *f, H5O_t *oh, H5O_mesg_t *mesg)
 {
     uint8_t *p;                   /* Temporary pointer to encode with */
     unsigned msg_id;              /* ID for message */
     herr_t   ret_value = SUCCEED; /* Return value */
 
     FUNC_ENTER_NOAPI(FAIL)
 
     /* check args */
     assert(f);
     assert(oh);
 
     /* Point into message's chunk's image */
     p = mesg->raw - H5O_SIZEOF_MSGHDR_OH(oh);
 
     /* Retrieve actual message ID, for unknown messages */
     if (mesg->type == H5O_MSG_UNKNOWN)
         msg_id = *(H5O_unknown_t *)(mesg->native);
     else
         msg_id = (uint8_t)mesg->type->id;
 
     /* Encode the message prefix */
     if (oh->version == H5O_VERSION_1)
         UINT16ENCODE(p, msg_id);
     else
         *p++ = (uint8_t)msg_id;
     assert(mesg->raw_size < H5O_MESG_MAX_SIZE);
     UINT16ENCODE(p, mesg->raw_size);
     *p++ = mesg->flags;
 
     /* Only encode reserved bytes for version 1 of format */
     if (oh->version == H5O_VERSION_1) {
         *p++ = 0; /*reserved*/
         *p++ = 0; /*reserved*/
         *p++ = 0; /*reserved*/
     }             /* end for */
     /* Only encode creation index for version 2+ of format */
     else {
         /* Only encode creation index if they are being tracked */
         if (oh->flags & H5O_HDR_ATTR_CRT_ORDER_TRACKED)
             UINT16ENCODE(p, mesg->crt_idx);
     } /* end else */
     assert(p == mesg->raw);
 
 #ifndef NDEBUG
     /* Make certain that null messages aren't in chunks w/gaps */
     if (H5O_NULL_ID == msg_id)
         assert(oh->chunk[mesg->chunkno].gap == 0);
     else
         /* Non-null messages should always have a native pointer */
         assert(mesg->native);
 #endif /* NDEBUG */
 
     /* Encode the message itself, if it's not an "unknown" message */
     if (mesg->native && mesg->type != H5O_MSG_UNKNOWN) {
         /*
          * Encode the message.  If the message is shared then we
          * encode a Shared Object message instead of the object
          * which is being shared.
          */
         assert(mesg->raw >= oh->chunk[mesg->chunkno].image);
         assert(mesg->raw_size == H5O_ALIGN_OH(oh, mesg->raw_size));
         assert(mesg->raw + mesg->raw_size <=
                oh->chunk[mesg->chunkno].image + (oh->chunk[mesg->chunkno].size - H5O_SIZEOF_CHKSUM_OH(oh)));
 #ifndef NDEBUG
         /* Sanity check that the message won't overwrite past it's allocated space */
         {
             size_t msg_size;
 
             msg_size = mesg->type->raw_size(f, false, mesg->native);
             msg_size = H5O_ALIGN_OH(oh, msg_size);
             assert(msg_size <= mesg->raw_size);
         }
 #endif /* NDEBUG */
         assert(mesg->type->encode);
-        if ((mesg->type->encode)(f, false, mesg->raw, mesg->native) < 0)
+        if ((mesg->type->encode)(f, false, mesg->raw_size, mesg->raw, mesg->native) < 0)
             HGOTO_ERROR(H5E_OHDR, H5E_CANTENCODE, FAIL, "unable to encode object header message");
     } /* end if */
 
     /* Mark the message as clean now */
     mesg->dirty = false;
diff --git a/src/H5Omtime.c b/src/H5Omtime.c
index 9cf9400f90..864af930b4 100644
--- a/src/H5Omtime.c
+++ b/src/H5Omtime.c
@@ -24,12 +24,13 @@
 
 static void  *H5O__mtime_new_decode(H5F_t *f, H5O_t *open_oh, unsigned mesg_flags, unsigned *ioflags,
                                     size_t p_size, const uint8_t *p);
-static herr_t H5O__mtime_new_encode(H5F_t *f, bool disable_shared, uint8_t *p, const void *_mesg);
+static herr_t H5O__mtime_new_encode(H5F_t *f, bool disable_shared, size_t H5_ATTR_UNUSED p_size, uint8_t *p,
+                                    const void *_mesg);
 static size_t H5O__mtime_new_size(const H5F_t *f, bool disable_shared, const void *_mesg);
 
 static void  *H5O__mtime_decode(H5F_t *f, H5O_t *open_oh, unsigned mesg_flags, unsigned *ioflags,
                                 size_t p_size, const uint8_t *p);
-static herr_t H5O__mtime_encode(H5F_t *f, bool disable_shared, uint8_t *p, const void *_mesg);
+static herr_t H5O__mtime_encode(H5F_t *f, bool disable_shared, size_t p_size, uint8_t *p, const void *_mesg);
 static void  *H5O__mtime_copy(const void *_mesg, void *_dest);
 static size_t H5O__mtime_size(const H5F_t *f, bool disable_shared, const void *_mesg);
 static herr_t H5O__mtime_free(void *_mesg);
@@ -221,71 +222,72 @@ done:
  *-------------------------------------------------------------------------
  */
 static herr_t
-H5O__mtime_new_encode(H5F_t H5_ATTR_UNUSED *f, bool H5_ATTR_UNUSED disable_shared, uint8_t *p,
-                      const void *_mesg)
+H5O__mtime_new_encode(H5F_t H5_ATTR_UNUSED *f, bool H5_ATTR_UNUSED disable_shared,
+                      size_t H5_ATTR_UNUSED p_size, uint8_t *p, const void *_mesg)
 {
     const time_t *mesg = (const time_t *)_mesg;
 
     FUNC_ENTER_PACKAGE_NOERR
 
     /* check args */
     assert(f);
     assert(p);
     assert(mesg);
 
     /* Version */
     *p++ = H5O_MTIME_VERSION;
 
     /* Reserved bytes */
     *p++ = 0;
     *p++ = 0;
     *p++ = 0;
 
     /* Encode time */
     UINT32ENCODE(p, *mesg);
 
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5O__mtime_new_encode() */
 
 /*-------------------------------------------------------------------------
  * Function:	H5O__mtime_encode
  *
  * Purpose:	Encodes a modification time message.
  *
  * Return:	Non-negative on success/Negative on failure
  *
  *-------------------------------------------------------------------------
  */
 static herr_t
-H5O__mtime_encode(H5F_t H5_ATTR_UNUSED *f, bool H5_ATTR_UNUSED disable_shared, uint8_t *p, const void *_mesg)
+H5O__mtime_encode(H5F_t H5_ATTR_UNUSED *f, bool H5_ATTR_UNUSED disable_shared, size_t p_size, uint8_t *p,
+                  const void *_mesg)
 {
     const time_t *mesg = (const time_t *)_mesg;
     struct tm    *tm;
 
     FUNC_ENTER_PACKAGE_NOERR
 
     /* check args */
     assert(f);
     assert(p);
     assert(mesg);
 
     /* encode */
     tm = HDgmtime(mesg);
-    sprintf((char *)p, "%04d%02d%02d%02d%02d%02d", 1900 + tm->tm_year, 1 + tm->tm_mon, tm->tm_mday,
-            tm->tm_hour, tm->tm_min, tm->tm_sec);
+    snprintf((char *)p, p_size, "%04d%02d%02d%02d%02d%02d", 1900 + tm->tm_year, 1 + tm->tm_mon, tm->tm_mday,
+             tm->tm_hour, tm->tm_min, tm->tm_sec);
 
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5O__mtime_encode() */
 
 /*-------------------------------------------------------------------------
  * Function:	H5O__mtime_copy
  *
  * Purpose:	Copies a message from _MESG to _DEST, allocating _DEST if
  *		necessary.
  *
  * Return:	Success:	Ptr to _DEST
  *
  *		Failure:	NULL
  *
  *-------------------------------------------------------------------------
  */
diff --git a/src/H5Oname.c b/src/H5Oname.c
index d60013717b..fc85c0bb9e 100644
--- a/src/H5Oname.c
+++ b/src/H5Oname.c
@@ -29,7 +29,8 @@
 /* PRIVATE PROTOTYPES */
 static void *H5O__name_decode(H5F_t *f, H5O_t *open_oh, unsigned mesg_flags, unsigned *ioflags, size_t p_size,
                               const uint8_t *p);
-static herr_t H5O__name_encode(H5F_t *f, bool disable_shared, uint8_t *p, const void *_mesg);
+static herr_t H5O__name_encode(H5F_t *f, bool disable_shared, size_t H5_ATTR_UNUSED p_size, uint8_t *p,
+                               const void *_mesg);
 static void  *H5O__name_copy(const void *_mesg, void *_dest);
 static size_t H5O__name_size(const H5F_t *f, bool disable_shared, const void *_mesg);
 static herr_t H5O__name_reset(void *_mesg);
@@ -110,32 +111,33 @@ done:
  *-------------------------------------------------------------------------
  */
 static herr_t
-H5O__name_encode(H5F_t H5_ATTR_UNUSED *f, bool H5_ATTR_UNUSED disable_shared, uint8_t *p, const void *_mesg)
+H5O__name_encode(H5F_t H5_ATTR_UNUSED *f, bool H5_ATTR_UNUSED disable_shared, size_t H5_ATTR_UNUSED p_size,
+                 uint8_t *p, const void *_mesg)
 {
     const H5O_name_t *mesg = (const H5O_name_t *)_mesg;
 
     FUNC_ENTER_PACKAGE_NOERR
 
     /* check args */
     assert(f);
     assert(p);
     assert(mesg && mesg->s);
 
     /* encode */
     strcpy((char *)p, mesg->s);
 
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5O__name_encode() */
 
 /*-------------------------------------------------------------------------
  * Function:    H5O__name_copy
  *
  * Purpose:     Copies a message from _MESG to _DEST, allocating _DEST if
  *              necessary.
  *
  * Return:      Success:        Ptr to _DEST
  *
  *              Failure:        NULL
  *
  *-------------------------------------------------------------------------
  */
diff --git a/src/H5Opkg.h b/src/H5Opkg.h
index feca86f7d0..4c719bf340 100644
--- a/src/H5Opkg.h
+++ b/src/H5Opkg.h
@@ -207,26 +207,26 @@
 /* The "message class" type */
 struct H5O_msg_class_t {
     unsigned    id;          /*message type ID on disk   */
     const char *name;        /*for debugging             */
     size_t      native_size; /*size of native message    */
     unsigned    share_flags; /* Message sharing settings */
     void *(*decode)(H5F_t *, H5O_t *, unsigned, unsigned *, size_t, const uint8_t *);
-    herr_t (*encode)(H5F_t *, bool, uint8_t *, const void *);
+    herr_t (*encode)(H5F_t *, bool, size_t, uint8_t *, const void *);
     void *(*copy)(const void *, void *);                   /*copy native value         */
     size_t (*raw_size)(const H5F_t *, bool, const void *); /*sizeof encoded message	*/
     herr_t (*reset)(void *);                               /*free nested data structs  */
     herr_t (*free)(void *);                                /*free main data struct  */
     herr_t (*del)(H5F_t *, H5O_t *, void *);  /* Delete space in file referenced by this message */
     herr_t (*link)(H5F_t *, H5O_t *, void *); /* Increment any links in file reference by this message */
     herr_t (*set_share)(void *, const H5O_shared_t *); /* Set shared information */
     htri_t (*can_share)(const void *);                 /* Is message allowed to be shared? */
     herr_t (*pre_copy_file)(H5F_t *, const void *, bool *, const H5O_copy_t *,
                             void *); /*"pre copy" action when copying native value to file */
     void *(*copy_file)(H5F_t *, void *, H5F_t *, bool *, unsigned *, H5O_copy_t *,
                        void *); /*copy native value to file */
     herr_t (*post_copy_file)(const H5O_loc_t *, const void *, H5O_loc_t *, void *, unsigned *,
                              H5O_copy_t *); /*"post copy" action when copying native value to file */
     herr_t (*get_crt_index)(const void *, H5O_msg_crt_idx_t *); /* Get message's creation index */
     herr_t (*set_crt_index)(void *, H5O_msg_crt_idx_t);         /* Set message's creation index */
     herr_t (*debug)(H5F_t *, const void *, FILE *, int, int);
 };
diff --git a/src/H5Orefcount.c b/src/H5Orefcount.c
index 426d2be475..a93f4295a8 100644
--- a/src/H5Orefcount.c
+++ b/src/H5Orefcount.c
@@ -29,7 +29,8 @@
 /* PRIVATE PROTOTYPES */
 static void  *H5O__refcount_decode(H5F_t *f, H5O_t *open_oh, unsigned mesg_flags, unsigned *ioflags,
                                    size_t p_size, const uint8_t *p);
-static herr_t H5O__refcount_encode(H5F_t *f, bool disable_shared, uint8_t *p, const void *_mesg);
+static herr_t H5O__refcount_encode(H5F_t *f, bool disable_shared, size_t H5_ATTR_UNUSED p_size, uint8_t *p,
+                                   const void *_mesg);
 static void  *H5O__refcount_copy(const void *_mesg, void *_dest);
 static size_t H5O__refcount_size(const H5F_t *f, bool disable_shared, const void *_mesg);
 static herr_t H5O__refcount_free(void *_mesg);
@@ -126,35 +127,35 @@ done:
  *-------------------------------------------------------------------------
  */
 static herr_t
-H5O__refcount_encode(H5F_t H5_ATTR_UNUSED *f, bool H5_ATTR_UNUSED disable_shared, uint8_t *p,
-                     const void *_mesg)
+H5O__refcount_encode(H5F_t H5_ATTR_UNUSED *f, bool H5_ATTR_UNUSED disable_shared,
+                     size_t H5_ATTR_UNUSED p_size, uint8_t *p, const void *_mesg)
 {
     const H5O_refcount_t *refcount = (const H5O_refcount_t *)_mesg;
 
     FUNC_ENTER_PACKAGE_NOERR
 
     /* check args */
     assert(f);
     assert(p);
     assert(refcount);
 
     /* Message version */
     *p++ = H5O_REFCOUNT_VERSION;
 
     /* Object's ref. count */
     UINT32ENCODE(p, *refcount);
 
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5O__refcount_encode() */
 
 /*-------------------------------------------------------------------------
  * Function:    H5O__refcount_copy
  *
  * Purpose:     Copies a message from _MESG to _DEST, allocating _DEST if
  *              necessary.
  *
  * Return:      Success:        Ptr to _DEST
  *              Failure:        NULL
  *
  *-------------------------------------------------------------------------
  */
diff --git a/src/H5Oshared.h b/src/H5Oshared.h
index 97539baae1..2813badd33 100644
--- a/src/H5Oshared.h
+++ b/src/H5Oshared.h
@@ -91,35 +91,35 @@ done:
  *-------------------------------------------------------------------------
  */
 static inline herr_t
-H5O_SHARED_ENCODE(H5F_t *f, bool disable_shared, uint8_t *p, const void *_mesg)
+H5O_SHARED_ENCODE(H5F_t *f, bool disable_shared, size_t H5_ATTR_UNUSED p_size, uint8_t *p, const void *_mesg)
 {
     const H5O_shared_t *sh_mesg =
         (const H5O_shared_t *)_mesg; /* Pointer to shared message portion of actual message */
     herr_t ret_value = SUCCEED;      /* Return value */
 
     FUNC_ENTER_NOAPI_NOINIT
 
 #ifndef H5O_SHARED_TYPE
 #error "Need to define H5O_SHARED_TYPE macro!"
 #endif /* H5O_SHARED_TYPE */
 #ifndef H5O_SHARED_ENCODE
 #error "Need to define H5O_SHARED_ENCODE macro!"
 #endif /* H5O_SHARED_ENCODE */
 #ifndef H5O_SHARED_ENCODE_REAL
 #error "Need to define H5O_SHARED_ENCODE_REAL macro!"
 #endif /* H5O_SHARED_ENCODE_REAL */
 
     /* Sanity check */
     assert(sh_mesg->type == H5O_SHARE_TYPE_UNSHARED || sh_mesg->msg_type_id == H5O_SHARED_TYPE->id);
 
     /* Check for message stored elsewhere */
     if (H5O_IS_STORED_SHARED(sh_mesg->type) && !disable_shared) {
         /* Encode shared message into buffer */
         if (H5O__shared_encode(f, p, sh_mesg) < 0)
             HGOTO_ERROR(H5E_OHDR, H5E_CANTENCODE, FAIL, "unable to encode shared message");
     } /* end if */
     else {
         /* Encode native message directly */
         if (H5O_SHARED_ENCODE_REAL(f, p, _mesg) < 0)
             HGOTO_ERROR(H5E_OHDR, H5E_CANTENCODE, FAIL, "unable to encode native message");
     } /* end else */
diff --git a/src/H5Oshmesg.c b/src/H5Oshmesg.c
index 50d6652f42..98f18292c9 100644
--- a/src/H5Oshmesg.c
+++ b/src/H5Oshmesg.c
@@ -24,7 +24,8 @@
 
 static void  *H5O__shmesg_decode(H5F_t *f, H5O_t *open_oh, unsigned mesg_flags, unsigned *ioflags,
                                  size_t p_size, const uint8_t *p);
-static herr_t H5O__shmesg_encode(H5F_t *f, bool disable_shared, uint8_t *p, const void *_mesg);
+static herr_t H5O__shmesg_encode(H5F_t *f, bool disable_shared, size_t H5_ATTR_UNUSED p_size, uint8_t *p,
+                                 const void *_mesg);
 static void  *H5O__shmesg_copy(const void *_mesg, void *_dest);
 static size_t H5O__shmesg_size(const H5F_t *f, bool disable_shared, const void *_mesg);
 static herr_t H5O__shmesg_debug(H5F_t *f, const void *_mesg, FILE *stream, int indent, int fwidth);
@@ -113,33 +114,34 @@ done:
  *-------------------------------------------------------------------------
  */
 static herr_t
-H5O__shmesg_encode(H5F_t *f, bool H5_ATTR_UNUSED disable_shared, uint8_t *p, const void *_mesg)
+H5O__shmesg_encode(H5F_t *f, bool H5_ATTR_UNUSED disable_shared, size_t H5_ATTR_UNUSED p_size, uint8_t *p,
+                   const void *_mesg)
 {
     const H5O_shmesg_table_t *mesg = (const H5O_shmesg_table_t *)_mesg;
 
     FUNC_ENTER_PACKAGE_NOERR
 
     /* Sanity check */
     assert(f);
     assert(p);
     assert(mesg);
 
     /* Store version, table address, and number of indexes */
     *p++ = (uint8_t)mesg->version;
     H5F_addr_encode(f, &p, mesg->addr);
     *p++ = (uint8_t)mesg->nindexes;
 
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5O__shmesg_encode() */
 
 /*-------------------------------------------------------------------------
  * Function:	H5O__shmesg_copy
  *
  * Purpose:	Copies a message from _MESG to _DEST, allocating _DEST if
  *		necessary.
  *
  * Return:	Success:	Ptr to _DEST
  *		Failure:	NULL
  *
  *-------------------------------------------------------------------------
  */
diff --git a/src/H5Ostab.c b/src/H5Ostab.c
index a9c3dd118c..5000ca84d7 100644
--- a/src/H5Ostab.c
+++ b/src/H5Ostab.c
@@ -32,7 +32,8 @@
 /* PRIVATE PROTOTYPES */
 static void *H5O__stab_decode(H5F_t *f, H5O_t *open_oh, unsigned mesg_flags, unsigned *ioflags, size_t p_size,
                               const uint8_t *p);
-static herr_t H5O__stab_encode(H5F_t *f, bool disable_shared, uint8_t *p, const void *_mesg);
+static herr_t H5O__stab_encode(H5F_t *f, bool disable_shared, size_t H5_ATTR_UNUSED p_size, uint8_t *p,
+                               const void *_mesg);
 static void  *H5O__stab_copy(const void *_mesg, void *_dest);
 static size_t H5O__stab_size(const H5F_t *f, bool disable_shared, const void *_mesg);
 static herr_t H5O__stab_free(void *_mesg);
@@ -123,33 +124,34 @@ done:
  *-------------------------------------------------------------------------
  */
 static herr_t
-H5O__stab_encode(H5F_t *f, bool H5_ATTR_UNUSED disable_shared, uint8_t *p, const void *_mesg)
+H5O__stab_encode(H5F_t *f, bool H5_ATTR_UNUSED disable_shared, size_t H5_ATTR_UNUSED p_size, uint8_t *p,
+                 const void *_mesg)
 {
     const H5O_stab_t *stab = (const H5O_stab_t *)_mesg;
 
     FUNC_ENTER_PACKAGE_NOERR
 
     /* check args */
     assert(f);
     assert(p);
     assert(stab);
 
     /* encode */
     H5F_addr_encode(f, &p, stab->btree_addr);
     H5F_addr_encode(f, &p, stab->heap_addr);
 
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5O__stab_encode() */
 
 /*-------------------------------------------------------------------------
  * Function:    H5O__stab_copy
  *
  * Purpose:     Copies a message from _MESG to _DEST, allocating _DEST if
  *              necessary.
  *
  * Return:      Success:        Ptr to _DEST
  *
  *              Failure:        NULL
  *
  *-------------------------------------------------------------------------
  */
