commit 6e4931c4ad6c1f06cd1e46ecbf98e04cbb8b4ba7
Author: Fabrice Bellard <fabrice@bellard.org>
Date:   Wed Dec 27 17:10:47 2023 +0100

    top-level-await support - follow the spec in the implementation of the module linking and evaluation to avoid errors with cycling module dependencies

diff --git a/quickjs-libc.c b/quickjs-libc.c
index e180dd0..f916314 100644
--- a/quickjs-libc.c
+++ b/quickjs-libc.c
@@ -3271,45 +3271,49 @@ static JSClassDef js_worker_class = {
 static void *worker_func(void *opaque)
 {
     WorkerFuncArgs *args = opaque;
     JSRuntime *rt;
     JSThreadState *ts;
     JSContext *ctx;
+    JSValue promise;
     
     rt = JS_NewRuntime();
     if (rt == NULL) {
         fprintf(stderr, "JS_NewRuntime failure");
         exit(1);
     }        
     js_std_init_handlers(rt);
 
     JS_SetModuleLoaderFunc(rt, NULL, js_module_loader, NULL);
 
     /* set the pipe to communicate with the parent */
     ts = JS_GetRuntimeOpaque(rt);
     ts->recv_pipe = args->recv_pipe;
     ts->send_pipe = args->send_pipe;
     
     /* function pointer to avoid linking the whole JS_NewContext() if
        not needed */
     ctx = js_worker_new_context_func(rt);
     if (ctx == NULL) {
         fprintf(stderr, "JS_NewContext failure");
     }
 
     JS_SetCanBlock(rt, TRUE);
 
     js_std_add_helpers(ctx, -1, NULL);
 
-    if (!JS_RunModule(ctx, args->basename, args->filename))
+    promise = JS_LoadModule(ctx, args->basename, args->filename);
+    if (JS_IsException(promise))
         js_std_dump_error(ctx);
+    /* XXX: check */
+    JS_FreeValue(ctx, promise);
     free(args->filename);
     free(args->basename);
     free(args);
 
     js_std_loop(ctx);
 
     JS_FreeContext(ctx);
     js_std_free_handlers(rt);
     JS_FreeRuntime(rt);
     return NULL;
 }
diff --git a/quickjs.c b/quickjs.c
index 93d3949..7cbfe70 100644
--- a/quickjs.c
+++ b/quickjs.c
@@ -236,69 +236,71 @@ typedef struct {
 struct JSRuntime {
     JSMallocFunctions mf;
     JSMallocState malloc_state;
     const char *rt_info;
 
     int atom_hash_size; /* power of two */
     int atom_count;
     int atom_size;
     int atom_count_resize; /* resize hash table at this count */
     uint32_t *atom_hash;
     JSAtomStruct **atom_array;
     int atom_free_index; /* 0 = none */
 
     int class_count;    /* size of class_array */
     JSClass *class_array;
 
     struct list_head context_list; /* list of JSContext.link */
     /* list of JSGCObjectHeader.link. List of allocated GC objects (used
        by the garbage collector) */
     struct list_head gc_obj_list;
     /* list of JSGCObjectHeader.link. Used during JS_FreeValueRT() */
     struct list_head gc_zero_ref_count_list; 
     struct list_head tmp_obj_list; /* used during GC */
     JSGCPhaseEnum gc_phase : 8;
     size_t malloc_gc_threshold;
 #ifdef DUMP_LEAKS
     struct list_head string_list; /* list of JSString.link */
 #endif
     /* stack limitation */
     uintptr_t stack_size; /* in bytes, 0 if no limit */
     uintptr_t stack_top;
     uintptr_t stack_limit; /* lower stack limit */
     
     JSValue current_exception;
     /* true if inside an out of memory error, to avoid recursing */
     BOOL in_out_of_memory : 8;
 
     struct JSStackFrame *current_stack_frame;
 
     JSInterruptHandler *interrupt_handler;
     void *interrupt_opaque;
 
     JSHostPromiseRejectionTracker *host_promise_rejection_tracker;
     void *host_promise_rejection_tracker_opaque;
     
     struct list_head job_list; /* list of JSJobEntry.link */
 
     JSModuleNormalizeFunc *module_normalize_func;
     JSModuleLoaderFunc *module_loader_func;
     void *module_loader_opaque;
-
+    /* timestamp for internal use in module evaluation */
+    int64_t module_async_evaluation_next_timestamp;
+    
     BOOL can_block : 8; /* TRUE if Atomics.wait can block */
     /* used to allocate, free and clone SharedArrayBuffers */
     JSSharedArrayBufferFunctions sab_funcs;
     
     /* Shape hash table */
     int shape_hash_bits;
     int shape_hash_size;
     int shape_hash_count; /* number of hashed shapes */
     JSShape **shape_hash;
     bf_context_t bf_ctx;
     JSNumericOperations bigint_ops;
 #ifdef CONFIG_BIGNUM
     JSNumericOperations bigfloat_ops;
     JSNumericOperations bigdecimal_ops;
     uint32_t operator_count;
 #endif
     void *user_opaque;
 };
@@ -765,38 +767,60 @@ typedef struct JSImportEntry {
     int req_module_idx; /* in req_module_entries */
 } JSImportEntry;
 
+typedef enum {
+    JS_MODULE_STATUS_UNLINKED,
+    JS_MODULE_STATUS_LINKING,
+    JS_MODULE_STATUS_LINKED,
+    JS_MODULE_STATUS_EVALUATING,
+    JS_MODULE_STATUS_EVALUATING_ASYNC,
+    JS_MODULE_STATUS_EVALUATED,
+} JSModuleStatus;
+
 struct JSModuleDef {
     JSRefCountHeader header; /* must come first, 32-bit */
     JSAtom module_name;
     struct list_head link;
 
     JSReqModuleEntry *req_module_entries;
     int req_module_entries_count;
     int req_module_entries_size;
 
     JSExportEntry *export_entries;
     int export_entries_count;
     int export_entries_size;
 
     JSStarExportEntry *star_export_entries;
     int star_export_entries_count;
     int star_export_entries_size;
 
     JSImportEntry *import_entries;
     int import_entries_count;
     int import_entries_size;
 
     JSValue module_ns;
     JSValue func_obj; /* only used for JS modules */
     JSModuleInitFunc *init_func; /* only used for C modules */
+    BOOL has_tla : 8; /* true if func_obj contains await */
     BOOL resolved : 8;
     BOOL func_created : 8;
-    BOOL instantiated : 8;
-    BOOL evaluated : 8;
-    BOOL eval_mark : 8; /* temporary use during js_evaluate_module() */
+    JSModuleStatus status : 8;
+    /* temp use during js_module_link() & js_module_evaluate() */
+    int dfs_index, dfs_ancestor_index;
+    JSModuleDef *stack_prev;
+    /* temp use during js_module_evaluate() */
+    JSModuleDef **async_parent_modules;
+    int async_parent_modules_count;
+    int async_parent_modules_size;
+    int pending_async_dependencies;
+    BOOL async_evaluation;
+    int64_t async_evaluation_timestamp;
+    JSModuleDef *cycle_root;
+    JSValue promise; /* corresponds to spec field: capability */
+    JSValue resolving_funcs[2]; /* corresponds to spec field: capability */
+    
     /* true if evaluation yielded an exception. It is saved in
        eval_exception */
     BOOL eval_has_exception : 8; 
     JSValue eval_exception;
     JSValue meta_obj; /* for import.meta */
 };
@@ -1198,6 +1222,8 @@ static __exception int perform_promise_then(JSContext *ctx,
                                             JSValueConst *cap_resolving_funcs);
 static JSValue js_promise_resolve(JSContext *ctx, JSValueConst this_val,
                                   int argc, JSValueConst *argv, int magic);
+static JSValue js_promise_then(JSContext *ctx, JSValueConst this_val,
+                               int argc, JSValueConst *argv);
 static int js_string_compare(JSContext *ctx,
                              const JSString *p1, const JSString *p2);
 static JSValue JS_ToNumber(JSContext *ctx, JSValueConst val);
@@ -2192,19 +2218,17 @@ JSValue JS_GetClassProto(JSContext *ctx, JSClassID class_id)
 typedef enum JSFreeModuleEnum {
     JS_FREE_MODULE_ALL,
     JS_FREE_MODULE_NOT_RESOLVED,
-    JS_FREE_MODULE_NOT_EVALUATED,
 } JSFreeModuleEnum;
 
 /* XXX: would be more efficient with separate module lists */
 static void js_free_modules(JSContext *ctx, JSFreeModuleEnum flag)
 {
     struct list_head *el, *el1;
     list_for_each_safe(el, el1, &ctx->loaded_modules) {
         JSModuleDef *m = list_entry(el, JSModuleDef, link);
         if (flag == JS_FREE_MODULE_ALL ||
-            (flag == JS_FREE_MODULE_NOT_RESOLVED && !m->resolved) ||
-            (flag == JS_FREE_MODULE_NOT_EVALUATED && !m->evaluated)) {
+            (flag == JS_FREE_MODULE_NOT_RESOLVED && !m->resolved)) {
             js_free_module_def(ctx, m);
         }
     }
 }
@@ -19610,112 +19634,113 @@ typedef enum JSParseExportEnum {
 typedef struct JSFunctionDef {
     JSContext *ctx;
     struct JSFunctionDef *parent;
     int parent_cpool_idx; /* index in the constant pool of the parent
                              or -1 if none */
     int parent_scope_level; /* scope level in parent at point of definition */
     struct list_head child_list; /* list of JSFunctionDef.link */
     struct list_head link;
 
     BOOL is_eval; /* TRUE if eval code */
     int eval_type; /* only valid if is_eval = TRUE */
     BOOL is_global_var; /* TRUE if variables are not defined locally:
                            eval global, eval module or non strict eval */
     BOOL is_func_expr; /* TRUE if function expression */
     BOOL has_home_object; /* TRUE if the home object is available */
     BOOL has_prototype; /* true if a prototype field is necessary */
     BOOL has_simple_parameter_list;
     BOOL has_parameter_expressions; /* if true, an argument scope is created */
     BOOL has_use_strict; /* to reject directive in special cases */
     BOOL has_eval_call; /* true if the function contains a call to eval() */
     BOOL has_arguments_binding; /* true if the 'arguments' binding is
                                    available in the function */
     BOOL has_this_binding; /* true if the 'this' and new.target binding are
                               available in the function */
     BOOL new_target_allowed; /* true if the 'new.target' does not
                                 throw a syntax error */
     BOOL super_call_allowed; /* true if super() is allowed */
     BOOL super_allowed; /* true if super. or super[] is allowed */
     BOOL arguments_allowed; /* true if the 'arguments' identifier is allowed */
     BOOL is_derived_class_constructor;
     BOOL in_function_body;
     BOOL backtrace_barrier;
     JSFunctionKindEnum func_kind : 8;
     JSParseFunctionEnum func_type : 8;
     uint8_t js_mode; /* bitmap of JS_MODE_x */
     JSAtom func_name; /* JS_ATOM_NULL if no name */
 
     JSVarDef *vars;
     int var_size; /* allocated size for vars[] */
     int var_count;
     JSVarDef *args;
     int arg_size; /* allocated size for args[] */
     int arg_count; /* number of arguments */
     int defined_arg_count;
     int var_object_idx; /* -1 if none */
     int arg_var_object_idx; /* -1 if none (var object for the argument scope) */
     int arguments_var_idx; /* -1 if none */
     int arguments_arg_idx; /* argument variable definition in argument scope, 
                               -1 if none */
     int func_var_idx; /* variable containing the current function (-1
                          if none, only used if is_func_expr is true) */
     int eval_ret_idx; /* variable containing the return value of the eval, -1 if none */
     int this_var_idx; /* variable containg the 'this' value, -1 if none */
     int new_target_var_idx; /* variable containg the 'new.target' value, -1 if none */
     int this_active_func_var_idx; /* variable containg the 'this.active_func' value, -1 if none */
     int home_object_var_idx;
     BOOL need_home_object;
     
     int scope_level;    /* index into fd->scopes if the current lexical scope */
     int scope_first;    /* index into vd->vars of first lexically scoped variable */
     int scope_size;     /* allocated size of fd->scopes array */
     int scope_count;    /* number of entries used in the fd->scopes array */
     JSVarScope *scopes;
     JSVarScope def_scope_array[4];
     int body_scope; /* scope of the body of the function or eval */
 
     int global_var_count;
     int global_var_size;
     JSGlobalVar *global_vars;
 
     DynBuf byte_code;
     int last_opcode_pos; /* -1 if no last opcode */
     int last_opcode_line_num;
     BOOL use_short_opcodes; /* true if short opcodes are used in byte_code */
     
     LabelSlot *label_slots;
     int label_size; /* allocated size for label_slots[] */
     int label_count;
     BlockEnv *top_break; /* break/continue label stack */
 
     /* constant pool (strings, functions, numbers) */
     JSValue *cpool;
     int cpool_count;
     int cpool_size;
 
     /* list of variables in the closure */
     int closure_var_count;
     int closure_var_size;
     JSClosureVar *closure_var;
 
     JumpSlot *jump_slots;
     int jump_size;
     int jump_count;
 
     LineNumberSlot *line_number_slots;
     int line_number_size;
     int line_number_count;
     int line_number_last;
     int line_number_last_pc;
 
     /* pc2line table */
     JSAtom filename;
     int line_num;
     DynBuf pc2line;
 
     char *source;  /* raw source, utf-8 encoded */
     int source_len;
 
     JSModuleDef *module; /* != NULL when parsing a module */
+    BOOL has_await; /* TRUE if await is used (used in module eval) */
 } JSFunctionDef;
 
 typedef struct JSToken {
@@ -24691,149 +24716,150 @@ static __exception int js_parse_delete(JSParseState *s)
 /* allowed parse_flags: PF_ARROW_FUNC, PF_POW_ALLOWED, PF_POW_FORBIDDEN */
 static __exception int js_parse_unary(JSParseState *s, int parse_flags)
 {
     int op;
 
     switch(s->token.val) {
     case '+':
     case '-':
     case '!':
     case '~':
     case TOK_VOID:
         op = s->token.val;
         if (next_token(s))
             return -1;
         if (js_parse_unary(s, PF_POW_FORBIDDEN))
             return -1;
         switch(op) {
         case '-':
             emit_op(s, OP_neg);
             break;
         case '+':
             emit_op(s, OP_plus);
             break;
         case '!':
             emit_op(s, OP_lnot);
             break;
         case '~':
             emit_op(s, OP_not);
             break;
         case TOK_VOID:
             emit_op(s, OP_drop);
             emit_op(s, OP_undefined);
             break;
         default:
             abort();
         }
         parse_flags = 0;
         break;
     case TOK_DEC:
     case TOK_INC:
         {
             int opcode, op, scope, label;
             JSAtom name;
             op = s->token.val;
             if (next_token(s))
                 return -1;
             if (js_parse_unary(s, 0))
                 return -1;
             if (get_lvalue(s, &opcode, &scope, &name, &label, NULL, TRUE, op))
                 return -1;
             emit_op(s, OP_dec + op - TOK_DEC);
             put_lvalue(s, opcode, scope, name, label, PUT_LVALUE_KEEP_TOP,
                        FALSE);
         }
         break;
     case TOK_TYPEOF:
         {
             JSFunctionDef *fd;
             if (next_token(s))
                 return -1;
             if (js_parse_unary(s, PF_POW_FORBIDDEN))
                 return -1;
             /* reference access should not return an exception, so we
                patch the get_var */
             fd = s->cur_func;
             if (get_prev_opcode(fd) == OP_scope_get_var) {
                 fd->byte_code.buf[fd->last_opcode_pos] = OP_scope_get_var_undef;
             }
             emit_op(s, OP_typeof);
             parse_flags = 0;
         }
         break;
     case TOK_DELETE:
         if (js_parse_delete(s))
             return -1;
         parse_flags = 0;
         break;
     case TOK_AWAIT:
         if (!(s->cur_func->func_kind & JS_FUNC_ASYNC))
             return js_parse_error(s, "unexpected 'await' keyword");
         if (!s->cur_func->in_function_body)
             return js_parse_error(s, "await in default expression");
         if (next_token(s))
             return -1;
         if (js_parse_unary(s, PF_POW_FORBIDDEN))
             return -1;
+        s->cur_func->has_await = TRUE;
         emit_op(s, OP_await);
         parse_flags = 0;
         break;
     default:
         if (js_parse_postfix_expr(s, (parse_flags & PF_ARROW_FUNC) |
                                   PF_POSTFIX_CALL))
             return -1;
         if (!s->got_lf &&
             (s->token.val == TOK_DEC || s->token.val == TOK_INC)) {
             int opcode, op, scope, label;
             JSAtom name;
             op = s->token.val;
             if (get_lvalue(s, &opcode, &scope, &name, &label, NULL, TRUE, op))
                 return -1;
             emit_op(s, OP_post_dec + op - TOK_DEC);
             put_lvalue(s, opcode, scope, name, label, PUT_LVALUE_KEEP_SECOND,
                        FALSE);
             if (next_token(s))
                 return -1;        
         }
         break;
     }
     if (parse_flags & (PF_POW_ALLOWED | PF_POW_FORBIDDEN)) {
 #ifdef CONFIG_BIGNUM
         if (s->token.val == TOK_POW || s->token.val == TOK_MATH_POW) {
             /* Extended exponentiation syntax rules: we extend the ES7
                grammar in order to have more intuitive semantics:
                -2**2 evaluates to -4. */
             if (!(s->cur_func->js_mode & JS_MODE_MATH)) {
                 if (parse_flags & PF_POW_FORBIDDEN) {
                     JS_ThrowSyntaxError(s->ctx, "unparenthesized unary expression can't appear on the left-hand side of '**'");
                     return -1;
                 }
             }
             if (next_token(s))
                 return -1;
             if (js_parse_unary(s, PF_POW_ALLOWED))
                 return -1;
             emit_op(s, OP_pow);
         }
 #else
         if (s->token.val == TOK_POW) {
             /* Strict ES7 exponentiation syntax rules: To solve
                conficting semantics between different implementations
                regarding the precedence of prefix operators and the
                postifx exponential, ES7 specifies that -2**2 is a
                syntax error. */
             if (parse_flags & PF_POW_FORBIDDEN) {
                 JS_ThrowSyntaxError(s->ctx, "unparenthesized unary expression can't appear on the left-hand side of '**'");
                 return -1;
             }
             if (next_token(s))
                 return -1;
             if (js_parse_unary(s, PF_POW_ALLOWED))
                 return -1;
             emit_op(s, OP_pow);
         }
 #endif
     }
     return 0;
 }
 
 /* allowed parse_flags: PF_ARROW_FUNC, PF_IN_ACCEPTED */
@@ -25948,735 +25974,736 @@ static void set_eval_ret_undefined(JSParseState *s)
 static __exception int js_parse_statement_or_decl(JSParseState *s,
                                                   int decl_mask)
 {
     JSContext *ctx = s->ctx;
     JSAtom label_name;
     int tok;
 
     /* specific label handling */
     /* XXX: support multiple labels on loop statements */
     label_name = JS_ATOM_NULL;
     if (is_label(s)) {
         BlockEnv *be;
 
         label_name = JS_DupAtom(ctx, s->token.u.ident.atom);
 
         for (be = s->cur_func->top_break; be; be = be->prev) {
             if (be->label_name == label_name) {
                 js_parse_error(s, "duplicate label name");
                 goto fail;
             }
         }
 
         if (next_token(s))
             goto fail;
         if (js_parse_expect(s, ':'))
             goto fail;
         if (s->token.val != TOK_FOR
         &&  s->token.val != TOK_DO
         &&  s->token.val != TOK_WHILE) {
             /* labelled regular statement */
             int label_break, mask;
             BlockEnv break_entry;
 
             label_break = new_label(s);
             push_break_entry(s->cur_func, &break_entry,
                              label_name, label_break, -1, 0);
             if (!(s->cur_func->js_mode & JS_MODE_STRICT) &&
                 (decl_mask & DECL_MASK_FUNC_WITH_LABEL)) {
                 mask = DECL_MASK_FUNC | DECL_MASK_FUNC_WITH_LABEL;
             } else {
                 mask = 0;
             }
             if (js_parse_statement_or_decl(s, mask))
                 goto fail;
             emit_label(s, label_break);
             pop_break_entry(s->cur_func);
             goto done;
         }
     }
 
     switch(tok = s->token.val) {
     case '{':
         if (js_parse_block(s))
             goto fail;
         break;
     case TOK_RETURN:
         if (s->cur_func->is_eval) {
             js_parse_error(s, "return not in a function");
             goto fail;
         }
         if (next_token(s))
             goto fail;
         if (s->token.val != ';' && s->token.val != '}' && !s->got_lf) {
             if (js_parse_expr(s))
                 goto fail;
             emit_return(s, TRUE);
         } else {
             emit_return(s, FALSE);
         }
         if (js_parse_expect_semi(s))
             goto fail;
         break;
     case TOK_THROW:
         if (next_token(s))
             goto fail;
         if (s->got_lf) {
             js_parse_error(s, "line terminator not allowed after throw");
             goto fail;
         }
         if (js_parse_expr(s))
             goto fail;
         emit_op(s, OP_throw);
         if (js_parse_expect_semi(s))
             goto fail;
         break;
     case TOK_LET:
     case TOK_CONST:
     haslet:
         if (!(decl_mask & DECL_MASK_OTHER)) {
             js_parse_error(s, "lexical declarations can't appear in single-statement context");
             goto fail;
         }
         /* fall thru */
     case TOK_VAR:
         if (next_token(s))
             goto fail;
         if (js_parse_var(s, TRUE, tok, FALSE))
             goto fail;
         if (js_parse_expect_semi(s))
             goto fail;
         break;
     case TOK_IF:
         {
             int label1, label2, mask;
             if (next_token(s))
                 goto fail;
             /* create a new scope for `let f;if(1) function f(){}` */
             push_scope(s);
             set_eval_ret_undefined(s);
             if (js_parse_expr_paren(s))
                 goto fail;
             label1 = emit_goto(s, OP_if_false, -1);
             if (s->cur_func->js_mode & JS_MODE_STRICT)
                 mask = 0;
             else
                 mask = DECL_MASK_FUNC; /* Annex B.3.4 */
 
             if (js_parse_statement_or_decl(s, mask))
                 goto fail;
 
             if (s->token.val == TOK_ELSE) {
                 label2 = emit_goto(s, OP_goto, -1);
                 if (next_token(s))
                     goto fail;
 
                 emit_label(s, label1);
                 if (js_parse_statement_or_decl(s, mask))
                     goto fail;
 
                 label1 = label2;
             }
             emit_label(s, label1);
             pop_scope(s);
         }
         break;
     case TOK_WHILE:
         {
             int label_cont, label_break;
             BlockEnv break_entry;
 
             label_cont = new_label(s);
             label_break = new_label(s);
 
             push_break_entry(s->cur_func, &break_entry,
                              label_name, label_break, label_cont, 0);
 
             if (next_token(s))
                 goto fail;
 
             set_eval_ret_undefined(s);
 
             emit_label(s, label_cont);
             if (js_parse_expr_paren(s))
                 goto fail;
             emit_goto(s, OP_if_false, label_break);
 
             if (js_parse_statement(s))
                 goto fail;
             emit_goto(s, OP_goto, label_cont);
 
             emit_label(s, label_break);
 
             pop_break_entry(s->cur_func);
         }
         break;
     case TOK_DO:
         {
             int label_cont, label_break, label1;
             BlockEnv break_entry;
 
             label_cont = new_label(s);
             label_break = new_label(s);
             label1 = new_label(s);
 
             push_break_entry(s->cur_func, &break_entry,
                              label_name, label_break, label_cont, 0);
 
             if (next_token(s))
                 goto fail;
 
             emit_label(s, label1);
 
             set_eval_ret_undefined(s);
 
             if (js_parse_statement(s))
                 goto fail;
 
             emit_label(s, label_cont);
             if (js_parse_expect(s, TOK_WHILE))
                 goto fail;
             if (js_parse_expr_paren(s))
                 goto fail;
             /* Insert semicolon if missing */
             if (s->token.val == ';') {
                 if (next_token(s))
                     goto fail;
             }
             emit_goto(s, OP_if_true, label1);
 
             emit_label(s, label_break);
 
             pop_break_entry(s->cur_func);
         }
         break;
     case TOK_FOR:
         {
             int label_cont, label_break, label_body, label_test;
             int pos_cont, pos_body, block_scope_level;
             BlockEnv break_entry;
             int tok, bits;
             BOOL is_async;
 
             if (next_token(s))
                 goto fail;
 
             set_eval_ret_undefined(s);
             bits = 0;
             is_async = FALSE;
             if (s->token.val == '(') {
                 js_parse_skip_parens_token(s, &bits, FALSE);
             } else if (s->token.val == TOK_AWAIT) {
                 if (!(s->cur_func->func_kind & JS_FUNC_ASYNC)) {
                     js_parse_error(s, "for await is only valid in asynchronous functions");
                     goto fail;
                 }
                 is_async = TRUE;
                 if (next_token(s))
                     goto fail;
+                s->cur_func->has_await = TRUE;
             }
             if (js_parse_expect(s, '('))
                 goto fail;
 
             if (!(bits & SKIP_HAS_SEMI)) {
                 /* parse for/in or for/of */
                 if (js_parse_for_in_of(s, label_name, is_async))
                     goto fail;
                 break;
             }
             block_scope_level = s->cur_func->scope_level;
 
             /* create scope for the lexical variables declared in the initial,
                test and increment expressions */
             push_scope(s);
             /* initial expression */
             tok = s->token.val;
             if (tok != ';') {
                 switch (is_let(s, DECL_MASK_OTHER)) {
                 case TRUE:
                     tok = TOK_LET;
                     break;
                 case FALSE:
                     break;
                 default:
                     goto fail;
                 }
                 if (tok == TOK_VAR || tok == TOK_LET || tok == TOK_CONST) {
                     if (next_token(s))
                         goto fail;
                     if (js_parse_var(s, FALSE, tok, FALSE))
                         goto fail;
                 } else {
                     if (js_parse_expr2(s, FALSE))
                         goto fail;
                     emit_op(s, OP_drop);
                 }
 
                 /* close the closures before the first iteration */
                 close_scopes(s, s->cur_func->scope_level, block_scope_level);
             }
             if (js_parse_expect(s, ';'))
                 goto fail;
 
             label_test = new_label(s);
             label_cont = new_label(s);
             label_body = new_label(s);
             label_break = new_label(s);
 
             push_break_entry(s->cur_func, &break_entry,
                              label_name, label_break, label_cont, 0);
 
             /* test expression */
             if (s->token.val == ';') {
                 /* no test expression */
                 label_test = label_body;
             } else {
                 emit_label(s, label_test);
                 if (js_parse_expr(s))
                     goto fail;
                 emit_goto(s, OP_if_false, label_break);
             }
             if (js_parse_expect(s, ';'))
                 goto fail;
 
             if (s->token.val == ')') {
                 /* no end expression */
                 break_entry.label_cont = label_cont = label_test;
                 pos_cont = 0; /* avoid warning */
             } else {
                 /* skip the end expression */
                 emit_goto(s, OP_goto, label_body);
 
                 pos_cont = s->cur_func->byte_code.size;
                 emit_label(s, label_cont);
                 if (js_parse_expr(s))
                     goto fail;
                 emit_op(s, OP_drop);
                 if (label_test != label_body)
                     emit_goto(s, OP_goto, label_test);
             }
             if (js_parse_expect(s, ')'))
                 goto fail;
 
             pos_body = s->cur_func->byte_code.size;
             emit_label(s, label_body);
             if (js_parse_statement(s))
                 goto fail;
 
             /* close the closures before the next iteration */
             /* XXX: check continue case */
             close_scopes(s, s->cur_func->scope_level, block_scope_level);
 
             if (OPTIMIZE && label_test != label_body && label_cont != label_test) {
                 /* move the increment code here */
                 DynBuf *bc = &s->cur_func->byte_code;
                 int chunk_size = pos_body - pos_cont;
                 int offset = bc->size - pos_cont;
                 int i;
                 dbuf_realloc(bc, bc->size + chunk_size);
                 dbuf_put(bc, bc->buf + pos_cont, chunk_size);
                 memset(bc->buf + pos_cont, OP_nop, chunk_size);
                 /* increment part ends with a goto */
                 s->cur_func->last_opcode_pos = bc->size - 5;
                 /* relocate labels */
                 for (i = label_cont; i < s->cur_func->label_count; i++) {
                     LabelSlot *ls = &s->cur_func->label_slots[i];
                     if (ls->pos >= pos_cont && ls->pos < pos_body)
                         ls->pos += offset;
                 }
             } else {
                 emit_goto(s, OP_goto, label_cont);
             }
 
             emit_label(s, label_break);
 
             pop_break_entry(s->cur_func);
             pop_scope(s);
         }
         break;
     case TOK_BREAK:
     case TOK_CONTINUE:
         {
             int is_cont = s->token.val - TOK_BREAK;
             int label;
 
             if (next_token(s))
                 goto fail;
             if (!s->got_lf && s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved)
                 label = s->token.u.ident.atom;
             else
                 label = JS_ATOM_NULL;
             if (emit_break(s, label, is_cont))
                 goto fail;
             if (label != JS_ATOM_NULL) {
                 if (next_token(s))
                     goto fail;
             }
             if (js_parse_expect_semi(s))
                 goto fail;
         }
         break;
     case TOK_SWITCH:
         {
             int label_case, label_break, label1;
             int default_label_pos;
             BlockEnv break_entry;
 
             if (next_token(s))
                 goto fail;
 
             set_eval_ret_undefined(s);
             if (js_parse_expr_paren(s))
                 goto fail;
 
             push_scope(s);
             label_break = new_label(s);
             push_break_entry(s->cur_func, &break_entry,
                              label_name, label_break, -1, 1);
 
             if (js_parse_expect(s, '{'))
                 goto fail;
 
             default_label_pos = -1;
             label_case = -1;
             while (s->token.val != '}') {
                 if (s->token.val == TOK_CASE) {
                     label1 = -1;
                     if (label_case >= 0) {
                         /* skip the case if needed */
                         label1 = emit_goto(s, OP_goto, -1);
                     }
                     emit_label(s, label_case);
                     label_case = -1;
                     for (;;) {
                         /* parse a sequence of case clauses */
                         if (next_token(s))
                             goto fail;
                         emit_op(s, OP_dup);
                         if (js_parse_expr(s))
                             goto fail;
                         if (js_parse_expect(s, ':'))
                             goto fail;
                         emit_op(s, OP_strict_eq);
                         if (s->token.val == TOK_CASE) {
                             label1 = emit_goto(s, OP_if_true, label1);
                         } else {
                             label_case = emit_goto(s, OP_if_false, -1);
                             emit_label(s, label1);
                             break;
                         }
                     }
                 } else if (s->token.val == TOK_DEFAULT) {
                     if (next_token(s))
                         goto fail;
                     if (js_parse_expect(s, ':'))
                         goto fail;
                     if (default_label_pos >= 0) {
                         js_parse_error(s, "duplicate default");
                         goto fail;
                     }
                     if (label_case < 0) {
                         /* falling thru direct from switch expression */
                         label_case = emit_goto(s, OP_goto, -1);
                     }
                     /* Emit a dummy label opcode. Label will be patched after
                        the end of the switch body. Do not use emit_label(s, 0)
                        because it would clobber label 0 address, preventing
                        proper optimizer operation.
                      */
                     emit_op(s, OP_label);
                     emit_u32(s, 0);
                     default_label_pos = s->cur_func->byte_code.size - 4;
                 } else {
                     if (label_case < 0) {
                         /* falling thru direct from switch expression */
                         js_parse_error(s, "invalid switch statement");
                         goto fail;
                     }
                     if (js_parse_statement_or_decl(s, DECL_MASK_ALL))
                         goto fail;
                 }
             }
             if (js_parse_expect(s, '}'))
                 goto fail;
             if (default_label_pos >= 0) {
                 /* Ugly patch for the the `default` label, shameful and risky */
                 put_u32(s->cur_func->byte_code.buf + default_label_pos,
                         label_case);
                 s->cur_func->label_slots[label_case].pos = default_label_pos + 4;
             } else {
                 emit_label(s, label_case);
             }
             emit_label(s, label_break);
             emit_op(s, OP_drop); /* drop the switch expression */
 
             pop_break_entry(s->cur_func);
             pop_scope(s);
         }
         break;
     case TOK_TRY:
         {
             int label_catch, label_catch2, label_finally, label_end;
             JSAtom name;
             BlockEnv block_env;
 
             set_eval_ret_undefined(s);
             if (next_token(s))
                 goto fail;
             label_catch = new_label(s);
             label_catch2 = new_label(s);
             label_finally = new_label(s);
             label_end = new_label(s);
 
             emit_goto(s, OP_catch, label_catch);
 
             push_break_entry(s->cur_func, &block_env,
                              JS_ATOM_NULL, -1, -1, 1);
             block_env.label_finally = label_finally;
 
             if (js_parse_block(s))
                 goto fail;
 
             pop_break_entry(s->cur_func);
 
             if (js_is_live_code(s)) {
                 /* drop the catch offset */
                 emit_op(s, OP_drop);
                 /* must push dummy value to keep same stack size */
                 emit_op(s, OP_undefined);
                 emit_goto(s, OP_gosub, label_finally);
                 emit_op(s, OP_drop);
 
                 emit_goto(s, OP_goto, label_end);
             }
 
             if (s->token.val == TOK_CATCH) {
                 if (next_token(s))
                     goto fail;
 
                 push_scope(s);  /* catch variable */
                 emit_label(s, label_catch);
 
                 if (s->token.val == '{') {
                     /* support optional-catch-binding feature */
                     emit_op(s, OP_drop);    /* pop the exception object */
                 } else {
                     if (js_parse_expect(s, '('))
                         goto fail;
                     if (!(s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved)) {
                         if (s->token.val == '[' || s->token.val == '{') {
                             /* XXX: TOK_LET is not completely correct */
                             if (js_parse_destructuring_element(s, TOK_LET, 0, TRUE, -1, TRUE) < 0)
                                 goto fail;
                         } else {
                             js_parse_error(s, "identifier expected");
                             goto fail;
                         }
                     } else {
                         name = JS_DupAtom(ctx, s->token.u.ident.atom);
                         if (next_token(s)
                         ||  js_define_var(s, name, TOK_CATCH) < 0) {
                             JS_FreeAtom(ctx, name);
                             goto fail;
                         }
                         /* store the exception value in the catch variable */
                         emit_op(s, OP_scope_put_var);
                         emit_u32(s, name);
                         emit_u16(s, s->cur_func->scope_level);
                     }
                     if (js_parse_expect(s, ')'))
                         goto fail;
                 }
                 /* XXX: should keep the address to nop it out if there is no finally block */
                 emit_goto(s, OP_catch, label_catch2);
 
                 push_scope(s);  /* catch block */
                 push_break_entry(s->cur_func, &block_env, JS_ATOM_NULL,
                                  -1, -1, 1);
                 block_env.label_finally = label_finally;
 
                 if (js_parse_block(s))
                     goto fail;
 
                 pop_break_entry(s->cur_func);
                 pop_scope(s);  /* catch block */
                 pop_scope(s);  /* catch variable */
 
                 if (js_is_live_code(s)) {
                     /* drop the catch2 offset */
                     emit_op(s, OP_drop);
                     /* XXX: should keep the address to nop it out if there is no finally block */
                     /* must push dummy value to keep same stack size */
                     emit_op(s, OP_undefined);
                     emit_goto(s, OP_gosub, label_finally);
                     emit_op(s, OP_drop);
                     emit_goto(s, OP_goto, label_end);
                 }
                 /* catch exceptions thrown in the catch block to execute the
                  * finally clause and rethrow the exception */
                 emit_label(s, label_catch2);
                 /* catch value is at TOS, no need to push undefined */
                 emit_goto(s, OP_gosub, label_finally);
                 emit_op(s, OP_throw);
 
             } else if (s->token.val == TOK_FINALLY) {
                 /* finally without catch : execute the finally clause
                  * and rethrow the exception */
                 emit_label(s, label_catch);
                 /* catch value is at TOS, no need to push undefined */
                 emit_goto(s, OP_gosub, label_finally);
                 emit_op(s, OP_throw);
             } else {
                 js_parse_error(s, "expecting catch or finally");
                 goto fail;
             }
             emit_label(s, label_finally);
             if (s->token.val == TOK_FINALLY) {
                 int saved_eval_ret_idx = 0; /* avoid warning */
                 
                 if (next_token(s))
                     goto fail;
                 /* on the stack: ret_value gosub_ret_value */
                 push_break_entry(s->cur_func, &block_env, JS_ATOM_NULL,
                                  -1, -1, 2);
 
                 if (s->cur_func->eval_ret_idx >= 0) {
                     /* 'finally' updates eval_ret only if not a normal
                        termination */
                     saved_eval_ret_idx =
                         add_var(s->ctx, s->cur_func, JS_ATOM__ret_);
                     if (saved_eval_ret_idx < 0)
                         goto fail;
                     emit_op(s, OP_get_loc);
                     emit_u16(s, s->cur_func->eval_ret_idx);
                     emit_op(s, OP_put_loc);
                     emit_u16(s, saved_eval_ret_idx);
                     set_eval_ret_undefined(s);
                 }
                 
                 if (js_parse_block(s))
                     goto fail;
 
                 if (s->cur_func->eval_ret_idx >= 0) {
                     emit_op(s, OP_get_loc);
                     emit_u16(s, saved_eval_ret_idx);
                     emit_op(s, OP_put_loc);
                     emit_u16(s, s->cur_func->eval_ret_idx);
                 }
                 pop_break_entry(s->cur_func);
             }
             emit_op(s, OP_ret);
             emit_label(s, label_end);
         }
         break;
     case ';':
         /* empty statement */
         if (next_token(s))
             goto fail;
         break;
     case TOK_WITH:
         if (s->cur_func->js_mode & JS_MODE_STRICT) {
             js_parse_error(s, "invalid keyword: with");
             goto fail;
         } else {
             int with_idx;
 
             if (next_token(s))
                 goto fail;
 
             if (js_parse_expr_paren(s))
                 goto fail;
 
             push_scope(s);
             with_idx = define_var(s, s->cur_func, JS_ATOM__with_,
                                   JS_VAR_DEF_WITH);
             if (with_idx < 0)
                 goto fail;
             emit_op(s, OP_to_object);
             emit_op(s, OP_put_loc);
             emit_u16(s, with_idx);
 
             set_eval_ret_undefined(s);
             if (js_parse_statement(s))
                 goto fail;
 
             /* Popping scope drops lexical context for the with object variable */
             pop_scope(s);
         }
         break;
     case TOK_FUNCTION:
         /* ES6 Annex B.3.2 and B.3.3 semantics */
         if (!(decl_mask & DECL_MASK_FUNC))
             goto func_decl_error;
         if (!(decl_mask & DECL_MASK_OTHER) && peek_token(s, FALSE) == '*')
             goto func_decl_error;
         goto parse_func_var;
     case TOK_IDENT:
         if (s->token.u.ident.is_reserved) {
             js_parse_error_reserved_identifier(s);
             goto fail;
         }
         /* Determine if `let` introduces a Declaration or an ExpressionStatement */
         switch (is_let(s, decl_mask)) {
         case TRUE:
             tok = TOK_LET;
             goto haslet;
         case FALSE:
             break;
         default:
             goto fail;
         }
         if (token_is_pseudo_keyword(s, JS_ATOM_async) &&
             peek_token(s, TRUE) == TOK_FUNCTION) {
             if (!(decl_mask & DECL_MASK_OTHER)) {
             func_decl_error:
                 js_parse_error(s, "function declarations can't appear in single-statement context");
                 goto fail;
             }
         parse_func_var:
             if (js_parse_function_decl(s, JS_PARSE_FUNC_VAR,
                                        JS_FUNC_NORMAL, JS_ATOM_NULL,
                                        s->token.ptr, s->token.line_num))
                 goto fail;
             break;
         }
         goto hasexpr;
 
     case TOK_CLASS:
         if (!(decl_mask & DECL_MASK_OTHER)) {
             js_parse_error(s, "class declarations can't appear in single-statement context");
             goto fail;
         }
         if (js_parse_class(s, FALSE, JS_PARSE_EXPORT_NONE))
             return -1;
         break;
 
     case TOK_DEBUGGER:
         /* currently no debugger, so just skip the keyword */
         if (next_token(s))
             goto fail;
         if (js_parse_expect_semi(s))
             goto fail;
         break;
         
     case TOK_ENUM:
     case TOK_EXPORT:
     case TOK_EXTENDS:
         js_unsupported_keyword(s, s->token.u.ident.atom);
         goto fail;
 
     default:
     hasexpr:
         if (js_parse_expr(s))
             goto fail;
         if (s->cur_func->eval_ret_idx >= 0) {
             /* store the expression value so that it can be returned
                by eval() */
             emit_op(s, OP_put_loc);
             emit_u16(s, s->cur_func->eval_ret_idx);
         } else {
             emit_op(s, OP_drop); /* drop the result */
         }
         if (js_parse_expect_semi(s))
             goto fail;
         break;
     }
@@ -26691,18 +26718,21 @@ fail:
 /* 'name' is freed */
 static JSModuleDef *js_new_module_def(JSContext *ctx, JSAtom name)
 {
     JSModuleDef *m;
     m = js_mallocz(ctx, sizeof(*m));
     if (!m) {
         JS_FreeAtom(ctx, name);
         return NULL;
     }
     m->header.ref_count = 1;
     m->module_name = name;
     m->module_ns = JS_UNDEFINED;
     m->func_obj = JS_UNDEFINED;
     m->eval_exception = JS_UNDEFINED;
     m->meta_obj = JS_UNDEFINED;
+    m->promise = JS_UNDEFINED;
+    m->resolving_funcs[0] = JS_UNDEFINED;
+    m->resolving_funcs[1] = JS_UNDEFINED;
     list_add_tail(&m->link, &ctx->loaded_modules);
     return m;
 }
@@ -26710,55 +26740,62 @@ static JSModuleDef *js_new_module_def(JSContext *ctx, JSAtom name)
 static void js_mark_module_def(JSRuntime *rt, JSModuleDef *m,
                                JS_MarkFunc *mark_func)
 {
     int i;
 
     for(i = 0; i < m->export_entries_count; i++) {
         JSExportEntry *me = &m->export_entries[i];
         if (me->export_type == JS_EXPORT_TYPE_LOCAL &&
             me->u.local.var_ref) {
             mark_func(rt, &me->u.local.var_ref->header);
         }
     }
 
     JS_MarkValue(rt, m->module_ns, mark_func);
     JS_MarkValue(rt, m->func_obj, mark_func);
     JS_MarkValue(rt, m->eval_exception, mark_func);
     JS_MarkValue(rt, m->meta_obj, mark_func);
+    JS_MarkValue(rt, m->promise, mark_func);
+    JS_MarkValue(rt, m->resolving_funcs[0], mark_func);
+    JS_MarkValue(rt, m->resolving_funcs[1], mark_func);
 }
 
 static void js_free_module_def(JSContext *ctx, JSModuleDef *m)
 {
     int i;
 
     JS_FreeAtom(ctx, m->module_name);
 
     for(i = 0; i < m->req_module_entries_count; i++) {
         JSReqModuleEntry *rme = &m->req_module_entries[i];
         JS_FreeAtom(ctx, rme->module_name);
     }
     js_free(ctx, m->req_module_entries);
 
     for(i = 0; i < m->export_entries_count; i++) {
         JSExportEntry *me = &m->export_entries[i];
         if (me->export_type == JS_EXPORT_TYPE_LOCAL)
             free_var_ref(ctx->rt, me->u.local.var_ref);
         JS_FreeAtom(ctx, me->export_name);
         JS_FreeAtom(ctx, me->local_name);
     }
     js_free(ctx, m->export_entries);
 
     js_free(ctx, m->star_export_entries);
 
     for(i = 0; i < m->import_entries_count; i++) {
         JSImportEntry *mi = &m->import_entries[i];
         JS_FreeAtom(ctx, mi->import_name);
     }
     js_free(ctx, m->import_entries);
+    js_free(ctx, m->async_parent_modules);
 
     JS_FreeValue(ctx, m->module_ns);
     JS_FreeValue(ctx, m->func_obj);
     JS_FreeValue(ctx, m->eval_exception);
     JS_FreeValue(ctx, m->meta_obj);
+    JS_FreeValue(ctx, m->promise);
+    JS_FreeValue(ctx, m->resolving_funcs[0]);
+    JS_FreeValue(ctx, m->resolving_funcs[1]);
     list_del(&m->link);
     js_free(ctx, m);
 }
@@ -27614,164 +27651,236 @@ static int js_create_module_function(JSContext *ctx, JSModuleDef *m)
     
 /* Prepare a module to be executed by resolving all the imported
    variables. */
-static int js_link_module(JSContext *ctx, JSModuleDef *m)
+static int js_inner_module_linking(JSContext *ctx, JSModuleDef *m,
+                                   JSModuleDef **pstack_top, int index)
 {
     int i;
     JSImportEntry *mi;
     JSModuleDef *m1;
     JSVarRef **var_refs, *var_ref;
     JSObject *p;
     BOOL is_c_module;
     JSValue ret_val;
     
-    if (m->instantiated)
-        return 0;
-    m->instantiated = TRUE;
-
+    if (js_check_stack_overflow(ctx->rt, 0)) {
+        JS_ThrowStackOverflow(ctx);
+        return -1;
+    }
+    
 #ifdef DUMP_MODULE_RESOLVE
     {
         char buf1[ATOM_GET_STR_BUF_SIZE];
-        printf("start instantiating module '%s':\n", JS_AtomGetStr(ctx, buf1, sizeof(buf1), m->module_name));
+        printf("js_inner_module_linking '%s':\n", JS_AtomGetStr(ctx, buf1, sizeof(buf1), m->module_name));
     }
 #endif
 
+    if (m->status == JS_MODULE_STATUS_LINKING ||
+        m->status == JS_MODULE_STATUS_LINKED ||
+        m->status == JS_MODULE_STATUS_EVALUATING_ASYNC ||
+        m->status == JS_MODULE_STATUS_EVALUATED)
+        return index;
+
+    assert(m->status == JS_MODULE_STATUS_UNLINKED);
+    m->status = JS_MODULE_STATUS_LINKING;
+    m->dfs_index = index;
+    m->dfs_ancestor_index = index;
+    index++;
+    /* push 'm' on stack */
+    m->stack_prev = *pstack_top;
+    *pstack_top = m;
+
     for(i = 0; i < m->req_module_entries_count; i++) {
         JSReqModuleEntry *rme = &m->req_module_entries[i];
-        if (js_link_module(ctx, rme->module) < 0)
+        m1 = rme->module;
+        index = js_inner_module_linking(ctx, m1, pstack_top, index);
+        if (index < 0)
             goto fail;
+        assert(m1->status == JS_MODULE_STATUS_LINKING ||
+               m1->status == JS_MODULE_STATUS_LINKED ||
+               m1->status == JS_MODULE_STATUS_EVALUATING_ASYNC ||
+               m1->status == JS_MODULE_STATUS_EVALUATED);
+        if (m1->status == JS_MODULE_STATUS_LINKING) {
+            m->dfs_ancestor_index = min_int(m->dfs_ancestor_index,
+                                            m1->dfs_ancestor_index);
+        }
     }
 
 #ifdef DUMP_MODULE_RESOLVE
     {
         char buf1[ATOM_GET_STR_BUF_SIZE];
         printf("instantiating module '%s':\n", JS_AtomGetStr(ctx, buf1, sizeof(buf1), m->module_name));
     }
 #endif
     /* check the indirect exports */
     for(i = 0; i < m->export_entries_count; i++) {
         JSExportEntry *me = &m->export_entries[i];
         if (me->export_type == JS_EXPORT_TYPE_INDIRECT &&
             me->local_name != JS_ATOM__star_) {
             JSResolveResultEnum ret;
             JSExportEntry *res_me;
             JSModuleDef *res_m, *m1;
             m1 = m->req_module_entries[me->u.req_module_idx].module;
             ret = js_resolve_export(ctx, &res_m, &res_me, m1, me->local_name);
             if (ret != JS_RESOLVE_RES_FOUND) {
                 js_resolve_export_throw_error(ctx, ret, m, me->export_name);
                 goto fail;
             }
         }
     }
 
 #ifdef DUMP_MODULE_RESOLVE
     {
         printf("exported bindings:\n");
         for(i = 0; i < m->export_entries_count; i++) {
             JSExportEntry *me = &m->export_entries[i];
             printf(" name="); print_atom(ctx, me->export_name);
             printf(" local="); print_atom(ctx, me->local_name);
             printf(" type=%d idx=%d\n", me->export_type, me->u.local.var_idx);
         }
     }
 #endif
 
     is_c_module = (m->init_func != NULL);
 
     if (!is_c_module) {
         p = JS_VALUE_GET_OBJ(m->func_obj);
         var_refs = p->u.func.var_refs;
 
         for(i = 0; i < m->import_entries_count; i++) {
             mi = &m->import_entries[i];
 #ifdef DUMP_MODULE_RESOLVE
             printf("import var_idx=%d name=", mi->var_idx);
             print_atom(ctx, mi->import_name);
             printf(": ");
 #endif
             m1 = m->req_module_entries[mi->req_module_idx].module;
             if (mi->import_name == JS_ATOM__star_) {
                 JSValue val;
                 /* name space import */
                 val = js_get_module_ns(ctx, m1);
                 if (JS_IsException(val))
                     goto fail;
                 set_value(ctx, &var_refs[mi->var_idx]->value, val);
 #ifdef DUMP_MODULE_RESOLVE
                 printf("namespace\n");
 #endif
             } else {
                 JSResolveResultEnum ret;
                 JSExportEntry *res_me;
                 JSModuleDef *res_m;
                 JSObject *p1;
 
                 ret = js_resolve_export(ctx, &res_m,
                                         &res_me, m1, mi->import_name);
                 if (ret != JS_RESOLVE_RES_FOUND) {
                     js_resolve_export_throw_error(ctx, ret, m1, mi->import_name);
                     goto fail;
                 }
                 if (res_me->local_name == JS_ATOM__star_) {
                     JSValue val;
                     JSModuleDef *m2;
                     /* name space import from */
                     m2 = res_m->req_module_entries[res_me->u.req_module_idx].module;
                     val = js_get_module_ns(ctx, m2);
                     if (JS_IsException(val))
                         goto fail;
                     var_ref = js_create_module_var(ctx, TRUE);
                     if (!var_ref) {
                         JS_FreeValue(ctx, val);
                         goto fail;
                     }
                     set_value(ctx, &var_ref->value, val);
                     var_refs[mi->var_idx] = var_ref;
 #ifdef DUMP_MODULE_RESOLVE
                     printf("namespace from\n");
 #endif
                 } else {
                     var_ref = res_me->u.local.var_ref;
                     if (!var_ref) {
                         p1 = JS_VALUE_GET_OBJ(res_m->func_obj);
                         var_ref = p1->u.func.var_refs[res_me->u.local.var_idx];
                     }
                     var_ref->header.ref_count++;
                     var_refs[mi->var_idx] = var_ref;
 #ifdef DUMP_MODULE_RESOLVE
                     printf("local export (var_ref=%p)\n", var_ref);
 #endif
                 }
             }
         }
 
         /* keep the exported variables in the module export entries (they
            are used when the eval function is deleted and cannot be
            initialized before in case imports are exported) */
         for(i = 0; i < m->export_entries_count; i++) {
             JSExportEntry *me = &m->export_entries[i];
             if (me->export_type == JS_EXPORT_TYPE_LOCAL) {
                 var_ref = var_refs[me->u.local.var_idx];
                 var_ref->header.ref_count++;
                 me->u.local.var_ref = var_ref;
             }
         }
 
         /* initialize the global variables */
         ret_val = JS_Call(ctx, m->func_obj, JS_TRUE, 0, NULL);
         if (JS_IsException(ret_val))
             goto fail;
         JS_FreeValue(ctx, ret_val);
     }
 
+    assert(m->dfs_ancestor_index <= m->dfs_index);
+    if (m->dfs_index == m->dfs_ancestor_index) {
+        for(;;) {
+            /* pop m1 from stack */
+            m1 = *pstack_top;
+            *pstack_top = m1->stack_prev;
+            m1->status = JS_MODULE_STATUS_LINKED;
+            if (m1 == m)
+                break;
+        }
+    }
+
 #ifdef DUMP_MODULE_RESOLVE
-    printf("done instantiate\n");
+    printf("js_inner_module_linking done\n");
 #endif
-    return 0;
+    return index;
  fail:
     return -1;
 }
 
+/* Prepare a module to be executed by resolving all the imported
+   variables. */
+static int js_link_module(JSContext *ctx, JSModuleDef *m)
+{
+    JSModuleDef *stack_top, *m1;
+
+#ifdef DUMP_MODULE_RESOLVE
+    {
+        char buf1[ATOM_GET_STR_BUF_SIZE];
+        printf("js_link_module '%s':\n", JS_AtomGetStr(ctx, buf1, sizeof(buf1), m->module_name));
+    }
+#endif
+    assert(m->status == JS_MODULE_STATUS_UNLINKED ||
+           m->status == JS_MODULE_STATUS_LINKED ||
+           m->status == JS_MODULE_STATUS_EVALUATING_ASYNC ||
+           m->status == JS_MODULE_STATUS_EVALUATED);
+    stack_top = NULL;
+    if (js_inner_module_linking(ctx, m, &stack_top, 0) < 0) {
+        while (stack_top != NULL) {
+            m1 = stack_top;
+            assert(m1->status == JS_MODULE_STATUS_LINKING);
+            m1->status = JS_MODULE_STATUS_UNLINKED;
+            stack_top = m1->stack_prev;
+        }
+        return -1;
+    }
+    assert(stack_top == NULL);
+    assert(m->status == JS_MODULE_STATUS_LINKED ||
+           m->status == JS_MODULE_STATUS_EVALUATING_ASYNC ||
+           m->status == JS_MODULE_STATUS_EVALUATED);
+    return 0;
+}
+
 /* return JS_ATOM_NULL if the name cannot be found. Only works with
    not striped bytecode functions. */
 JSAtom JS_GetScriptOrModuleName(JSContext *ctx, int n_stack_levels)
@@ -27823,94 +27932,162 @@ JSValue JS_GetImportMeta(JSContext *ctx, JSModuleDef *m)
 static JSValue js_import_meta(JSContext *ctx)
 {
     JSAtom filename;
     JSModuleDef *m;
     
     filename = JS_GetScriptOrModuleName(ctx, 0);
     if (filename == JS_ATOM_NULL)
         goto fail;
 
     /* XXX: inefficient, need to add a module or script pointer in
        JSFunctionBytecode */
     m = js_find_loaded_module(ctx, filename);
     JS_FreeAtom(ctx, filename);
     if (!m) {
     fail:
         JS_ThrowTypeError(ctx, "import.meta not supported in this context");
         return JS_EXCEPTION;
     }
     return JS_GetImportMeta(ctx, m);
 }
 
-/* used by os.Worker() and import() */
-JSModuleDef *JS_RunModule(JSContext *ctx, const char *basename,
-                          const char *filename)
+static JSValue JS_NewModuleValue(JSContext *ctx, JSModuleDef *m)
+{
+    return JS_DupValue(ctx, JS_MKPTR(JS_TAG_MODULE, m));
+}
+
+static JSValue js_load_module_rejected(JSContext *ctx, JSValueConst this_val,
+                                       int argc, JSValueConst *argv, int magic, JSValue *func_data)
 {
+    JSValueConst *resolving_funcs = (JSValueConst *)func_data;
+    JSValueConst error;
+    JSValue ret;
+    
+    /* XXX: check if the test is necessary */
+    if (argc >= 1)
+        error = argv[0];
+    else
+        error = JS_UNDEFINED;
+    ret = JS_Call(ctx, resolving_funcs[1], JS_UNDEFINED,
+                  1, &error);
+    JS_FreeValue(ctx, ret);
+    return JS_UNDEFINED;
+}
+
+static JSValue js_load_module_fulfilled(JSContext *ctx, JSValueConst this_val,
+                                        int argc, JSValueConst *argv, int magic, JSValue *func_data)
+{
+    JSValueConst *resolving_funcs = (JSValueConst *)func_data;
+    JSModuleDef *m = JS_VALUE_GET_PTR(func_data[2]);
+    JSValue ret, ns;
+    
+    /* return the module namespace */
+    ns = js_get_module_ns(ctx, m);
+    if (JS_IsException(ns)) {
+        JSValue err = JS_GetException(ctx);
+        js_load_module_rejected(ctx, JS_UNDEFINED, 1, (JSValueConst *)&err, 0, func_data);
+        return JS_UNDEFINED;
+    }
+    ret = JS_Call(ctx, resolving_funcs[0], JS_UNDEFINED,
+                   1, (JSValueConst *)&ns);
+    JS_FreeValue(ctx, ret);
+    JS_FreeValue(ctx, ns);
+    return JS_UNDEFINED;
+}
+
+static void JS_LoadModuleInternal(JSContext *ctx, const char *basename,
+                                  const char *filename,
+                                  JSValueConst *resolving_funcs)
+{
+    JSValue evaluate_promise;
     JSModuleDef *m;
-    JSValue ret, func_obj;
+    JSValue ret, err, func_obj, evaluate_resolving_funcs[2];
+    JSValueConst func_data[3];
     
     m = js_host_resolve_imported_module(ctx, basename, filename);
     if (!m)
-        return NULL;
+        goto fail;
     
     if (js_resolve_module(ctx, m) < 0) {
         js_free_modules(ctx, JS_FREE_MODULE_NOT_RESOLVED);
-        return NULL;
+        goto fail;
     }
 
     /* Evaluate the module code */
-    func_obj = JS_DupValue(ctx, JS_MKPTR(JS_TAG_MODULE, m));
-    ret = JS_EvalFunction(ctx, func_obj);
-    if (JS_IsException(ret))
-        return NULL;
+    func_obj = JS_NewModuleValue(ctx, m);
+    evaluate_promise = JS_EvalFunction(ctx, func_obj);
+    if (JS_IsException(evaluate_promise)) {
+    fail:
+        err = JS_GetException(ctx);
+        ret = JS_Call(ctx, resolving_funcs[1], JS_UNDEFINED,
+                      1, (JSValueConst *)&err);
+        JS_FreeValue(ctx, ret); /* XXX: what to do if exception ? */
+        JS_FreeValue(ctx, err);
+        return;
+    }
+
+    func_obj = JS_NewModuleValue(ctx, m);
+    func_data[0] = resolving_funcs[0];
+    func_data[1] = resolving_funcs[1];
+    func_data[2] = func_obj;
+    evaluate_resolving_funcs[0] = JS_NewCFunctionData(ctx, js_load_module_fulfilled, 0, 0, 3, func_data);
+    evaluate_resolving_funcs[1] = JS_NewCFunctionData(ctx, js_load_module_rejected, 0, 0, 3, func_data);
+    JS_FreeValue(ctx, func_obj);
+    ret = js_promise_then(ctx, evaluate_promise, 2, (JSValueConst *)evaluate_resolving_funcs);
     JS_FreeValue(ctx, ret);
-    return m;
+    JS_FreeValue(ctx, evaluate_resolving_funcs[0]);
+    JS_FreeValue(ctx, evaluate_resolving_funcs[1]);
+    JS_FreeValue(ctx, evaluate_promise);
+}
+
+/* Return a promise or an exception in case of memory error. Used by
+   os.Worker() */
+JSValue JS_LoadModule(JSContext *ctx, const char *basename,
+                      const char *filename)
+{
+    JSValue promise, resolving_funcs[2];
+    
+    promise = JS_NewPromiseCapability(ctx, resolving_funcs);
+    if (JS_IsException(promise))
+        return JS_EXCEPTION;
+    JS_LoadModuleInternal(ctx, basename, filename,
+                          (JSValueConst *)resolving_funcs);
+    JS_FreeValue(ctx, resolving_funcs[0]);
+    JS_FreeValue(ctx, resolving_funcs[1]);
+    return promise;
 }
 
 static JSValue js_dynamic_import_job(JSContext *ctx,
                                      int argc, JSValueConst *argv)
 {
     JSValueConst *resolving_funcs = argv;
     JSValueConst basename_val = argv[2];
     JSValueConst specifier = argv[3];
-    JSModuleDef *m;
     const char *basename = NULL, *filename;
-    JSValue ret, err, ns;
+    JSValue ret, err;
 
     if (!JS_IsString(basename_val)) {
         JS_ThrowTypeError(ctx, "no function filename for import()");
         goto exception;
     }
     basename = JS_ToCString(ctx, basename_val);
     if (!basename)
         goto exception;
 
     filename = JS_ToCString(ctx, specifier);
     if (!filename)
         goto exception;
                      
-    m = JS_RunModule(ctx, basename, filename);
+    JS_LoadModuleInternal(ctx, basename, filename,
+                          resolving_funcs);
     JS_FreeCString(ctx, filename);
-    if (!m)
-        goto exception;
-
-    /* return the module namespace */
-    ns = js_get_module_ns(ctx, m);
-    if (JS_IsException(ns))
-        goto exception;
-
-    ret = JS_Call(ctx, resolving_funcs[0], JS_UNDEFINED,
-                   1, (JSValueConst *)&ns);
-    JS_FreeValue(ctx, ret); /* XXX: what to do if exception ? */
-    JS_FreeValue(ctx, ns);
     JS_FreeCString(ctx, basename);
     return JS_UNDEFINED;
  exception:
-
     err = JS_GetException(ctx);
     ret = JS_Call(ctx, resolving_funcs[1], JS_UNDEFINED,
                    1, (JSValueConst *)&err);
     JS_FreeValue(ctx, ret); /* XXX: what to do if exception ? */
     JS_FreeValue(ctx, err);
     JS_FreeCString(ctx, basename);
     return JS_UNDEFINED;
 }
@@ -27918,91 +28095,430 @@ static JSValue js_dynamic_import_job(JSContext *ctx,
 static JSValue js_dynamic_import(JSContext *ctx, JSValueConst specifier)
 {
     JSAtom basename;
     JSValue promise, resolving_funcs[2], basename_val;
     JSValueConst args[4];
 
     basename = JS_GetScriptOrModuleName(ctx, 0);
     if (basename == JS_ATOM_NULL)
         basename_val = JS_NULL;
     else
         basename_val = JS_AtomToValue(ctx, basename);
     JS_FreeAtom(ctx, basename);
     if (JS_IsException(basename_val))
         return basename_val;
     
     promise = JS_NewPromiseCapability(ctx, resolving_funcs);
     if (JS_IsException(promise)) {
         JS_FreeValue(ctx, basename_val);
         return promise;
     }
 
     args[0] = resolving_funcs[0];
     args[1] = resolving_funcs[1];
     args[2] = basename_val;
     args[3] = specifier;
     
+    /* cannot run JS_LoadModuleInternal synchronously because it would
+       cause an unexpected recursion in js_evaluate_module() */
     JS_EnqueueJob(ctx, js_dynamic_import_job, 4, args);
 
     JS_FreeValue(ctx, basename_val);
     JS_FreeValue(ctx, resolving_funcs[0]);
     JS_FreeValue(ctx, resolving_funcs[1]);
     return promise;
 }
 
-/* Run the <eval> function of the module and of all its requested
-   modules. */
-static JSValue js_evaluate_module(JSContext *ctx, JSModuleDef *m)
+static void js_set_module_evaluated(JSContext *ctx, JSModuleDef *m)
+{
+    m->status = JS_MODULE_STATUS_EVALUATED;
+    if (!JS_IsUndefined(m->promise)) {
+        JSValue value, ret_val;
+        assert(m->cycle_root == m);
+        value = JS_UNDEFINED;
+        ret_val = JS_Call(ctx, m->resolving_funcs[0], JS_UNDEFINED,
+                          1, (JSValueConst *)&value);
+        JS_FreeValue(ctx, ret_val);
+    }
+}
+
+typedef struct {
+    JSModuleDef **tab;
+    int count;
+    int size;
+} ExecModuleList;
+
+/* XXX: slow. Could use a linked list instead of ExecModuleList */
+static BOOL find_in_exec_module_list(ExecModuleList *exec_list, JSModuleDef *m)
+{
+    int i;
+    for(i = 0; i < exec_list->count; i++) {
+        if (exec_list->tab[i] == m)
+            return TRUE;
+    }
+    return FALSE;
+}
+
+static int gather_available_ancestors(JSContext *ctx, JSModuleDef *module,
+                                      ExecModuleList *exec_list)
+{
+    int i;
+
+    if (js_check_stack_overflow(ctx->rt, 0)) {
+        JS_ThrowStackOverflow(ctx);
+        return -1;
+    }
+    for(i = 0; i < module->async_parent_modules_count; i++) {
+        JSModuleDef *m = module->async_parent_modules[i];
+        if (!find_in_exec_module_list(exec_list, m) &&
+            !m->cycle_root->eval_has_exception) {
+            assert(m->status == JS_MODULE_STATUS_EVALUATING_ASYNC);
+            assert(!m->eval_has_exception);
+            assert(m->async_evaluation);
+            assert(m->pending_async_dependencies > 0);
+            m->pending_async_dependencies--;
+            if (m->pending_async_dependencies == 0) {
+                if (js_resize_array(ctx, (void **)&exec_list->tab, sizeof(exec_list->tab[0]), &exec_list->size, exec_list->count + 1)) {
+                    return -1;
+                }
+                exec_list->tab[exec_list->count++] = m;
+                if (!m->has_tla) {
+                    if (gather_available_ancestors(ctx, m, exec_list))
+                        return -1;
+                }
+            }
+        }
+    }
+    return 0;
+}
+
+static int exec_module_list_cmp(const void *p1, const void *p2, void *opaque)
+{
+    JSModuleDef *m1 = *(JSModuleDef **)p1;
+    JSModuleDef *m2 = *(JSModuleDef **)p2;
+    return (m1->async_evaluation_timestamp > m2->async_evaluation_timestamp) -
+        (m1->async_evaluation_timestamp < m2->async_evaluation_timestamp);
+}
+
+static int js_execute_async_module(JSContext *ctx, JSModuleDef *m);
+static int js_execute_sync_module(JSContext *ctx, JSModuleDef *m,
+                                  JSValue *pvalue);
+
+static JSValue js_async_module_execution_rejected(JSContext *ctx, JSValueConst this_val,
+                                                  int argc, JSValueConst *argv, int magic, JSValue *func_data)
+{
+    JSModuleDef *module = JS_VALUE_GET_PTR(func_data[0]);
+    JSValueConst error = argv[0];
+    int i;
+    
+    if (js_check_stack_overflow(ctx->rt, 0))
+        return JS_ThrowStackOverflow(ctx);
+
+    if (module->status == JS_MODULE_STATUS_EVALUATED) {
+        assert(module->eval_has_exception);
+        return JS_UNDEFINED;
+    }
+
+    assert(module->status == JS_MODULE_STATUS_EVALUATING_ASYNC);
+    assert(!module->eval_has_exception);
+    assert(module->async_evaluation);
+
+    module->eval_has_exception = TRUE;
+    module->eval_exception = JS_DupValue(ctx, error);
+    module->status = JS_MODULE_STATUS_EVALUATED;
+
+    for(i = 0; i < module->async_parent_modules_count; i++) {
+        JSModuleDef *m = module->async_parent_modules[i];
+        JSValue m_obj = JS_NewModuleValue(ctx, m);
+        js_async_module_execution_rejected(ctx, JS_UNDEFINED, 1, &error, 0,
+                                           &m_obj);
+        JS_FreeValue(ctx, m_obj);
+    }
+
+    if (!JS_IsUndefined(module->promise)) {
+        JSValue ret_val;
+        assert(module->cycle_root == module);
+        ret_val = JS_Call(ctx, module->resolving_funcs[1], JS_UNDEFINED,
+                          1, &error);
+        JS_FreeValue(ctx, ret_val);
+    }
+    return JS_UNDEFINED;
+}
+
+static JSValue js_async_module_execution_fulfilled(JSContext *ctx, JSValueConst this_val,
+                                                   int argc, JSValueConst *argv, int magic, JSValue *func_data)
+{
+    JSModuleDef *module = JS_VALUE_GET_PTR(func_data[0]);
+    ExecModuleList exec_list_s, *exec_list = &exec_list_s;
+    int i;
+    
+    if (module->status == JS_MODULE_STATUS_EVALUATED) {
+        assert(module->eval_has_exception);
+        return JS_UNDEFINED;
+    }
+    assert(module->status == JS_MODULE_STATUS_EVALUATING_ASYNC);
+    assert(!module->eval_has_exception);
+    assert(module->async_evaluation);
+    module->async_evaluation = FALSE;
+    js_set_module_evaluated(ctx, module);
+
+    exec_list->tab = NULL;
+    exec_list->count = 0;
+    exec_list->size = 0;
+
+    if (gather_available_ancestors(ctx, module, exec_list) < 0) {
+        js_free(ctx, exec_list->tab);
+        return JS_EXCEPTION;
+    }
+
+    /* sort by increasing async_evaluation timestamp */
+    rqsort(exec_list->tab, exec_list->count, sizeof(exec_list->tab[0]),
+           exec_module_list_cmp, NULL);
+    
+    for(i = 0; i < exec_list->count; i++) {
+        JSModuleDef *m = exec_list->tab[i];
+        if (m->status == JS_MODULE_STATUS_EVALUATED) {
+            assert(m->eval_has_exception);
+        } else if (m->has_tla) {
+            js_execute_async_module(ctx, m);
+        } else {
+            JSValue error;
+            if (js_execute_sync_module(ctx, m, &error) < 0) {
+                JSValue m_obj = JS_NewModuleValue(ctx, m);
+                js_async_module_execution_rejected(ctx, JS_UNDEFINED,
+                                                   1, (JSValueConst *)&error, 0,
+                                                   &m_obj);
+                JS_FreeValue(ctx, m_obj);
+                JS_FreeValue(ctx, error);
+            } else {
+                js_set_module_evaluated(ctx, m);
+            }
+        }
+    }
+    js_free(ctx, exec_list->tab);
+    return JS_UNDEFINED;
+}
+
+static int js_execute_async_module(JSContext *ctx, JSModuleDef *m)
+{
+    JSValue promise, m_obj;
+    JSValue resolve_funcs[2], ret_val;
+    promise = js_async_function_call(ctx, m->func_obj, JS_UNDEFINED, 0, NULL, 0);
+    if (JS_IsException(promise))
+        return -1;
+    m_obj = JS_NewModuleValue(ctx, m);
+    resolve_funcs[0] = JS_NewCFunctionData(ctx, js_async_module_execution_fulfilled, 0, 0, 1, (JSValueConst *)&m_obj);
+    resolve_funcs[1] = JS_NewCFunctionData(ctx, js_async_module_execution_rejected, 0, 0, 1, (JSValueConst *)&m_obj);
+    ret_val = js_promise_then(ctx, promise, 2, (JSValueConst *)resolve_funcs);
+    JS_FreeValue(ctx, ret_val);
+    JS_FreeValue(ctx, m_obj);
+    JS_FreeValue(ctx, resolve_funcs[0]);
+    JS_FreeValue(ctx, resolve_funcs[1]);
+    JS_FreeValue(ctx, promise);
+    return 0;
+}
+
+/* return < 0 in case of exception. *pvalue contains the exception. */
+static int js_execute_sync_module(JSContext *ctx, JSModuleDef *m,
+                                  JSValue *pvalue)
+{
+    if (m->init_func) {
+        /* C module init : no asynchronous execution */
+        if (m->init_func(ctx, m) < 0)
+            goto fail;
+    } else {
+        JSValue promise;
+        JSPromiseStateEnum state;
+
+        promise = js_async_function_call(ctx, m->func_obj, JS_UNDEFINED, 0, NULL, 0);
+        if (JS_IsException(promise))
+            goto fail;
+        state = JS_PromiseState(ctx, promise);
+        if (state == JS_PROMISE_FULFILLED) {
+            JS_FreeValue(ctx, promise);
+        } else if (state == JS_PROMISE_REJECTED) {
+            *pvalue = JS_PromiseResult(ctx, promise);
+            JS_FreeValue(ctx, promise);
+            return -1;
+        } else {
+            JS_FreeValue(ctx, promise);
+            JS_ThrowTypeError(ctx, "promise is pending");
+        fail:
+            *pvalue = JS_GetException(ctx);
+            return -1;
+        }
+    }
+    *pvalue = JS_UNDEFINED;
+    return 0;
+}
+
+/* spec: InnerModuleEvaluation. Return (index, JS_UNDEFINED) or (-1,
+   exception) */
+static int js_inner_module_evaluation(JSContext *ctx, JSModuleDef *m,
+                                      int index, JSModuleDef **pstack_top,
+                                      JSValue *pvalue)
 {
     JSModuleDef *m1;
     int i;
-    JSValue ret_val;
 
-    if (m->eval_mark)
-        return JS_UNDEFINED; /* avoid cycles */
+    if (js_check_stack_overflow(ctx->rt, 0)) {
+        JS_ThrowStackOverflow(ctx);
+        *pvalue = JS_GetException(ctx);
+        return -1;
+    }
+    
+#ifdef DUMP_MODULE_RESOLVE
+    {
+        char buf1[ATOM_GET_STR_BUF_SIZE];
+        printf("js_inner_module_evaluation '%s':\n", JS_AtomGetStr(ctx, buf1, sizeof(buf1), m->module_name));
+    }
+#endif
 
-    if (m->evaluated) {
-        /* if the module was already evaluated, rethrow the exception
-           it raised */
+    if (m->status == JS_MODULE_STATUS_EVALUATING_ASYNC ||
+        m->status == JS_MODULE_STATUS_EVALUATED) {
         if (m->eval_has_exception) {
-            return JS_Throw(ctx, JS_DupValue(ctx, m->eval_exception));
+            *pvalue = JS_DupValue(ctx, m->eval_exception);
+            return -1;
         } else {
-            return JS_UNDEFINED;
+            *pvalue = JS_UNDEFINED;
+            return index;
         }
     }
+    if (m->status == JS_MODULE_STATUS_EVALUATING) {
+        *pvalue = JS_UNDEFINED;
+        return index;
+    }
+    assert(m->status == JS_MODULE_STATUS_LINKED);
 
-    m->eval_mark = TRUE;
-
+    m->status = JS_MODULE_STATUS_EVALUATING;
+    m->dfs_index = index;
+    m->dfs_ancestor_index = index;
+    m->pending_async_dependencies = 0;
+    index++;
+    /* push 'm' on stack */
+    m->stack_prev = *pstack_top;
+    *pstack_top = m;
+    
     for(i = 0; i < m->req_module_entries_count; i++) {
         JSReqModuleEntry *rme = &m->req_module_entries[i];
         m1 = rme->module;
-        if (!m1->eval_mark) {
-            ret_val = js_evaluate_module(ctx, m1);
-            if (JS_IsException(ret_val)) {
-                m->eval_mark = FALSE;
-                return ret_val;
+        index = js_inner_module_evaluation(ctx, m1, index, pstack_top, pvalue);
+        if (index < 0) 
+            return -1;
+        assert(m1->status == JS_MODULE_STATUS_EVALUATING ||
+               m1->status == JS_MODULE_STATUS_EVALUATING_ASYNC ||
+               m1->status == JS_MODULE_STATUS_EVALUATED);
+        if (m1->status == JS_MODULE_STATUS_EVALUATING) {
+            m->dfs_ancestor_index = min_int(m->dfs_ancestor_index,
+                                            m1->dfs_ancestor_index);
+        } else {
+            m1 = m1->cycle_root;
+            assert(m1->status == JS_MODULE_STATUS_EVALUATING_ASYNC ||
+                   m1->status == JS_MODULE_STATUS_EVALUATED);
+            if (m1->eval_has_exception) {
+                *pvalue = JS_DupValue(ctx, m1->eval_exception);
+                return -1;
             }
-            JS_FreeValue(ctx, ret_val);
+        }
+        if (m1->async_evaluation) {
+            m->pending_async_dependencies++;
+            if (js_resize_array(ctx, (void **)&m1->async_parent_modules, sizeof(m1->async_parent_modules[0]), &m1->async_parent_modules_size, m1->async_parent_modules_count + 1)) {
+                *pvalue = JS_GetException(ctx);
+                return -1;
+            }
+            m1->async_parent_modules[m1->async_parent_modules_count++] = m;
         }
     }
 
-    if (m->init_func) {
-        /* C module init */
-        if (m->init_func(ctx, m) < 0)
-            ret_val = JS_EXCEPTION;
-        else
-            ret_val = JS_UNDEFINED;
+    if (m->pending_async_dependencies > 0) {
+        assert(!m->async_evaluation);
+        m->async_evaluation = TRUE;
+        m->async_evaluation_timestamp =
+            ctx->rt->module_async_evaluation_next_timestamp++;
+    } else if (m->has_tla) {
+        assert(!m->async_evaluation);
+        m->async_evaluation = TRUE;
+        m->async_evaluation_timestamp =
+            ctx->rt->module_async_evaluation_next_timestamp++;
+        js_execute_async_module(ctx, m);
     } else {
-        ret_val = JS_CallFree(ctx, m->func_obj, JS_UNDEFINED, 0, NULL);
-        m->func_obj = JS_UNDEFINED;
+        if (js_execute_sync_module(ctx, m, pvalue) < 0)
+            return -1;
     }
-    if (JS_IsException(ret_val)) {
-        /* save the thrown exception value */
-        m->eval_has_exception = TRUE;
-        m->eval_exception = JS_DupValue(ctx, ctx->rt->current_exception);
+
+    assert(m->dfs_ancestor_index <= m->dfs_index);
+    if (m->dfs_index == m->dfs_ancestor_index) {
+        for(;;) {
+            /* pop m1 from stack */
+            m1 = *pstack_top;
+            *pstack_top = m1->stack_prev;
+            if (!m1->async_evaluation) {
+                m1->status = JS_MODULE_STATUS_EVALUATED;
+            } else {
+                m1->status = JS_MODULE_STATUS_EVALUATING_ASYNC;
+            }
+            /* spec bug: cycle_root must be assigned before the test */
+            m1->cycle_root = m;
+            if (m1 == m)
+                break;
+        }
     }
-    m->eval_mark = FALSE;
-    m->evaluated = TRUE;
-    return ret_val;
+    *pvalue = JS_UNDEFINED;
+    return index;
+}
+
+/* Run the <eval> function of the module and of all its requested
+   modules. Return a promise or an exception. */
+static JSValue js_evaluate_module(JSContext *ctx, JSModuleDef *m)
+{
+    JSModuleDef *m1, *stack_top;
+    JSValue ret_val, result;
+
+    assert(m->status == JS_MODULE_STATUS_LINKED ||
+           m->status == JS_MODULE_STATUS_EVALUATING_ASYNC ||
+           m->status == JS_MODULE_STATUS_EVALUATED);
+    if (m->status == JS_MODULE_STATUS_EVALUATING_ASYNC ||
+        m->status == JS_MODULE_STATUS_EVALUATED) {
+        m = m->cycle_root;
+    }
+    /* a promise may be created only on the cycle_root of a cycle */
+    if (!JS_IsUndefined(m->promise))
+        return JS_DupValue(ctx, m->promise);
+    m->promise = JS_NewPromiseCapability(ctx, m->resolving_funcs);
+    if (JS_IsException(m->promise))
+        return JS_EXCEPTION;
+
+    stack_top = NULL;
+    if (js_inner_module_evaluation(ctx, m, 0, &stack_top, &result) < 0) {
+        while (stack_top != NULL) {
+            m1 = stack_top;
+            assert(m1->status == JS_MODULE_STATUS_EVALUATING);
+            m1->status = JS_MODULE_STATUS_EVALUATED;
+            m1->eval_has_exception = TRUE;
+            m1->eval_exception = JS_DupValue(ctx, result);
+            m1->cycle_root = m; /* spec bug: should be present */
+            stack_top = m1->stack_prev;
+        }
+        JS_FreeValue(ctx, result);
+        assert(m->status == JS_MODULE_STATUS_EVALUATED);
+        assert(m->eval_has_exception);
+        ret_val = JS_Call(ctx, m->resolving_funcs[1], JS_UNDEFINED,
+                          1, (JSValueConst *)&m->eval_exception);
+        JS_FreeValue(ctx, ret_val);
+    } else {
+        assert(m->status == JS_MODULE_STATUS_EVALUATING_ASYNC ||
+               m->status == JS_MODULE_STATUS_EVALUATED);
+        assert(!m->eval_has_exception);
+        if (!m->async_evaluation) {
+            JSValue value;
+            assert(m->status == JS_MODULE_STATUS_EVALUATED);
+            value = JS_UNDEFINED;
+            ret_val = JS_Call(ctx, m->resolving_funcs[0], JS_UNDEFINED,
+                              1, (JSValueConst *)&value);
+            JS_FreeValue(ctx, ret_val);
+        }
+        assert(stack_top == NULL);
+    }
+    return JS_DupValue(ctx, m->promise);
 }
 
 static __exception JSAtom js_parse_from_clause(JSParseState *s)
@@ -33186,39 +33702,39 @@ static __exception int js_parse_function_decl(JSParseState *s,
 static __exception int js_parse_program(JSParseState *s)
 {
     JSFunctionDef *fd = s->cur_func;
     int idx;
 
     if (next_token(s))
         return -1;
 
     if (js_parse_directives(s))
         return -1;
 
     fd->is_global_var = (fd->eval_type == JS_EVAL_TYPE_GLOBAL) ||
         (fd->eval_type == JS_EVAL_TYPE_MODULE) ||
         !(fd->js_mode & JS_MODE_STRICT);
 
     if (!s->is_module) {
         /* hidden variable for the return value */
         fd->eval_ret_idx = idx = add_var(s->ctx, fd, JS_ATOM__ret_);
         if (idx < 0)
             return -1;
     }
 
     while (s->token.val != TOK_EOF) {
         if (js_parse_source_element(s))
             return -1;
     }
 
     if (!s->is_module) {
         /* return the value of the hidden variable eval_ret_idx  */
         emit_op(s, OP_get_loc);
         emit_u16(s, fd->eval_ret_idx);
 
         emit_op(s, OP_return);
     } else {
-        emit_op(s, OP_return_undef);
+        emit_return(s, FALSE);
     }
 
     return 0;
 }
@@ -33240,32 +33756,31 @@ static void js_parse_init(JSContext *ctx, JSParseState *s,
 static JSValue JS_EvalFunctionInternal(JSContext *ctx, JSValue fun_obj,
                                        JSValueConst this_obj,
                                        JSVarRef **var_refs, JSStackFrame *sf)
 {
     JSValue ret_val;
     uint32_t tag;
 
     tag = JS_VALUE_GET_TAG(fun_obj);
     if (tag == JS_TAG_FUNCTION_BYTECODE) {
         fun_obj = js_closure(ctx, fun_obj, var_refs, sf);
         ret_val = JS_CallFree(ctx, fun_obj, this_obj, 0, NULL);
     } else if (tag == JS_TAG_MODULE) {
         JSModuleDef *m;
         m = JS_VALUE_GET_PTR(fun_obj);
         /* the module refcount should be >= 2 */
         JS_FreeValue(ctx, fun_obj);
         if (js_create_module_function(ctx, m) < 0)
             goto fail;
         if (js_link_module(ctx, m) < 0)
             goto fail;
         ret_val = js_evaluate_module(ctx, m);
         if (JS_IsException(ret_val)) {
         fail:
-            js_free_modules(ctx, JS_FREE_MODULE_NOT_EVALUATED);
             return JS_EXCEPTION;
         }
     } else {
         JS_FreeValue(ctx, fun_obj);
         ret_val = JS_ThrowTypeError(ctx, "bytecode function expected");
     }
     return ret_val;
 }
@@ -33303,112 +33818,119 @@ static void skip_shebang(JSParseState *s)
 /* 'input' must be zero terminated i.e. input[input_len] = '\0'. */
 static JSValue __JS_EvalInternal(JSContext *ctx, JSValueConst this_obj,
                                  const char *input, size_t input_len,
                                  const char *filename, int flags, int scope_idx)
 {
     JSParseState s1, *s = &s1;
     int err, js_mode, eval_type;
     JSValue fun_obj, ret_val;
     JSStackFrame *sf;
     JSVarRef **var_refs;
     JSFunctionBytecode *b;
     JSFunctionDef *fd;
     JSModuleDef *m;
 
     js_parse_init(ctx, s, input, input_len, filename);
     skip_shebang(s);
 
     eval_type = flags & JS_EVAL_TYPE_MASK;
     m = NULL;
     if (eval_type == JS_EVAL_TYPE_DIRECT) {
         JSObject *p;
         sf = ctx->rt->current_stack_frame;
         assert(sf != NULL);
         assert(JS_VALUE_GET_TAG(sf->cur_func) == JS_TAG_OBJECT);
         p = JS_VALUE_GET_OBJ(sf->cur_func);
         assert(js_class_has_bytecode(p->class_id));
         b = p->u.func.function_bytecode;
         var_refs = p->u.func.var_refs;
         js_mode = b->js_mode;
     } else {
         sf = NULL;
         b = NULL;
         var_refs = NULL;
         js_mode = 0;
         if (flags & JS_EVAL_FLAG_STRICT)
             js_mode |= JS_MODE_STRICT;
         if (flags & JS_EVAL_FLAG_STRIP)
             js_mode |= JS_MODE_STRIP;
         if (eval_type == JS_EVAL_TYPE_MODULE) {
             JSAtom module_name = JS_NewAtom(ctx, filename);
             if (module_name == JS_ATOM_NULL)
                 return JS_EXCEPTION;
             m = js_new_module_def(ctx, module_name);
             if (!m)
                 return JS_EXCEPTION;
             js_mode |= JS_MODE_STRICT;
         }
     }
     fd = js_new_function_def(ctx, NULL, TRUE, FALSE, filename, 1);
     if (!fd)
         goto fail1;
     s->cur_func = fd;
     fd->eval_type = eval_type;
     fd->has_this_binding = (eval_type != JS_EVAL_TYPE_DIRECT);
     fd->backtrace_barrier = ((flags & JS_EVAL_FLAG_BACKTRACE_BARRIER) != 0);
     if (eval_type == JS_EVAL_TYPE_DIRECT) {
         fd->new_target_allowed = b->new_target_allowed;
         fd->super_call_allowed = b->super_call_allowed;
         fd->super_allowed = b->super_allowed;
         fd->arguments_allowed = b->arguments_allowed;
     } else {
         fd->new_target_allowed = FALSE;
         fd->super_call_allowed = FALSE;
         fd->super_allowed = FALSE;
         fd->arguments_allowed = TRUE;
     }
     fd->js_mode = js_mode;
     fd->func_name = JS_DupAtom(ctx, JS_ATOM__eval_);
     if (b) {
         if (add_closure_variables(ctx, fd, b, scope_idx))
             goto fail;
     }
     fd->module = m;
+    if (m != NULL) {
+        fd->in_function_body = TRUE;
+        fd->func_kind = JS_FUNC_ASYNC;
+    }
     s->is_module = (m != NULL);
     s->allow_html_comments = !s->is_module;
 
     push_scope(s); /* body scope */
     fd->body_scope = fd->scope_level;
     
     err = js_parse_program(s);
     if (err) {
     fail:
         free_token(s, &s->token);
         js_free_function_def(ctx, fd);
         goto fail1;
     }
 
+    if (m != NULL)
+        m->has_tla = fd->has_await;
+
     /* create the function object and all the enclosed functions */
     fun_obj = js_create_function(ctx, fd);
     if (JS_IsException(fun_obj))
         goto fail1;
     /* Could add a flag to avoid resolution if necessary */
     if (m) {
         m->func_obj = fun_obj;
         if (js_resolve_module(ctx, m) < 0)
             goto fail1;
-        fun_obj = JS_DupValue(ctx, JS_MKPTR(JS_TAG_MODULE, m));
+        fun_obj = JS_NewModuleValue(ctx, m);
     }
     if (flags & JS_EVAL_FLAG_COMPILE_ONLY) {
         ret_val = fun_obj;
     } else {
         ret_val = JS_EvalFunctionInternal(ctx, fun_obj, this_obj, var_refs, sf);
     }
     return ret_val;
  fail1:
     /* XXX: should free all the unresolved dependencies */
     if (m)
         js_free_module_def(ctx, m);
     return JS_EXCEPTION;
 }
 
 /* the indirection is needed to make 'eval' optional */
@@ -34105,47 +34627,49 @@ static int JS_WriteFunctionTag(BCWriterState *s, JSValueConst obj)
 static int JS_WriteModule(BCWriterState *s, JSValueConst obj)
 {
     JSModuleDef *m = JS_VALUE_GET_PTR(obj);
     int i;
     
     bc_put_u8(s, BC_TAG_MODULE);
     bc_put_atom(s, m->module_name);
     
     bc_put_leb128(s, m->req_module_entries_count);
     for(i = 0; i < m->req_module_entries_count; i++) {
         JSReqModuleEntry *rme = &m->req_module_entries[i];
         bc_put_atom(s, rme->module_name);
     }
     
     bc_put_leb128(s, m->export_entries_count);
     for(i = 0; i < m->export_entries_count; i++) {
         JSExportEntry *me = &m->export_entries[i];
         bc_put_u8(s, me->export_type);
         if (me->export_type == JS_EXPORT_TYPE_LOCAL) {
             bc_put_leb128(s, me->u.local.var_idx);
         } else {
             bc_put_leb128(s, me->u.req_module_idx);
             bc_put_atom(s, me->local_name);
         }
         bc_put_atom(s, me->export_name);
     }
     
     bc_put_leb128(s, m->star_export_entries_count);
     for(i = 0; i < m->star_export_entries_count; i++) {
         JSStarExportEntry *se = &m->star_export_entries[i];
         bc_put_leb128(s, se->req_module_idx);
     }
     
     bc_put_leb128(s, m->import_entries_count);
     for(i = 0; i < m->import_entries_count; i++) {
         JSImportEntry *mi = &m->import_entries[i];
         bc_put_leb128(s, mi->var_idx);
         bc_put_atom(s, mi->import_name);
         bc_put_leb128(s, mi->req_module_idx);
     }
+
+    bc_put_u8(s, m->has_tla);
     
     if (JS_WriteObjectRec(s, m->func_obj))
         goto fail;
     return 0;
  fail:
     return -1;
 }
@@ -35139,100 +35663,104 @@ static JSValue JS_ReadFunctionTag(BCReaderState *s)
 static JSValue JS_ReadModule(BCReaderState *s)
 {
     JSContext *ctx = s->ctx;
     JSValue obj;
     JSModuleDef *m = NULL;
     JSAtom module_name;
     int i;
     uint8_t v8;
     
     if (bc_get_atom(s, &module_name))
         goto fail;
 #ifdef DUMP_READ_OBJECT
     bc_read_trace(s, "name: "); print_atom(s->ctx, module_name); printf("\n");
 #endif
     m = js_new_module_def(ctx, module_name);
     if (!m)
         goto fail;
-    obj = JS_DupValue(ctx, JS_MKPTR(JS_TAG_MODULE, m));
+    obj = JS_NewModuleValue(ctx, m);
     if (bc_get_leb128_int(s, &m->req_module_entries_count))
         goto fail;
     if (m->req_module_entries_count != 0) {
         m->req_module_entries_size = m->req_module_entries_count;
         m->req_module_entries = js_mallocz(ctx, sizeof(m->req_module_entries[0]) * m->req_module_entries_size);
         if (!m->req_module_entries)
             goto fail;
         for(i = 0; i < m->req_module_entries_count; i++) {
             JSReqModuleEntry *rme = &m->req_module_entries[i];
             if (bc_get_atom(s, &rme->module_name))
                 goto fail;
         }
     }
 
     if (bc_get_leb128_int(s, &m->export_entries_count))
         goto fail;
     if (m->export_entries_count != 0) {
         m->export_entries_size = m->export_entries_count;
         m->export_entries = js_mallocz(ctx, sizeof(m->export_entries[0]) * m->export_entries_size);
         if (!m->export_entries)
             goto fail;
         for(i = 0; i < m->export_entries_count; i++) {
             JSExportEntry *me = &m->export_entries[i];
             if (bc_get_u8(s, &v8))
                 goto fail;
             me->export_type = v8;
             if (me->export_type == JS_EXPORT_TYPE_LOCAL) {
                 if (bc_get_leb128_int(s, &me->u.local.var_idx))
                     goto fail;
             } else {
                 if (bc_get_leb128_int(s, &me->u.req_module_idx))
                     goto fail;
                 if (bc_get_atom(s, &me->local_name))
                     goto fail;
             }
             if (bc_get_atom(s, &me->export_name))
                 goto fail;
         }
     }
 
     if (bc_get_leb128_int(s, &m->star_export_entries_count))
         goto fail;
     if (m->star_export_entries_count != 0) {
         m->star_export_entries_size = m->star_export_entries_count;
         m->star_export_entries = js_mallocz(ctx, sizeof(m->star_export_entries[0]) * m->star_export_entries_size);
         if (!m->star_export_entries)
             goto fail;
         for(i = 0; i < m->star_export_entries_count; i++) {
             JSStarExportEntry *se = &m->star_export_entries[i];
             if (bc_get_leb128_int(s, &se->req_module_idx))
                 goto fail;
         }
     }
 
     if (bc_get_leb128_int(s, &m->import_entries_count))
         goto fail;
     if (m->import_entries_count != 0) {
         m->import_entries_size = m->import_entries_count;
         m->import_entries = js_mallocz(ctx, sizeof(m->import_entries[0]) * m->import_entries_size);
         if (!m->import_entries)
             goto fail;
         for(i = 0; i < m->import_entries_count; i++) {
             JSImportEntry *mi = &m->import_entries[i];
             if (bc_get_leb128_int(s, &mi->var_idx))
                 goto fail;
             if (bc_get_atom(s, &mi->import_name))
                 goto fail;
             if (bc_get_leb128_int(s, &mi->req_module_idx))
                 goto fail;
         }
     }
 
+    if (bc_get_u8(s, &v8))
+        goto fail;
+    m->has_tla = (v8 != 0);
+
     m->func_obj = JS_ReadObjectRec(s);
     if (JS_IsException(m->func_obj))
         goto fail;
     return obj;
  fail:
     if (m) {
         js_free_module_def(ctx, m);
     }
     return JS_EXCEPTION;
 }
@@ -46148,12 +46676,6 @@ static const JSCFunctionListEntry js_generator_proto_funcs[] = {
 
 /* Promise */
 
-typedef enum JSPromiseStateEnum {
-    JS_PROMISE_PENDING,
-    JS_PROMISE_FULFILLED,
-    JS_PROMISE_REJECTED,
-} JSPromiseStateEnum;
-
 typedef struct JSPromiseData {
     JSPromiseStateEnum promise_state;
     /* 0=fulfill, 1=reject, list of JSPromiseReactionData.link */
@@ -46178,6 +46700,22 @@ typedef struct JSPromiseReactionData {
     JSValue handler;
 } JSPromiseReactionData;
 
+JSPromiseStateEnum JS_PromiseState(JSContext *ctx, JSValue promise)
+{
+    JSPromiseData *s = JS_GetOpaque(promise, JS_CLASS_PROMISE);
+    if (!s)
+        return -1;
+    return s->promise_state;
+}
+
+JSValue JS_PromiseResult(JSContext *ctx, JSValue promise)
+{
+    JSPromiseData *s = JS_GetOpaque(promise, JS_CLASS_PROMISE);
+    if (!s)
+        return JS_UNDEFINED;
+    return JS_DupValue(ctx, s->promise_result);
+}
+
 static int js_create_resolving_functions(JSContext *ctx, JSValue *args,
                                          JSValueConst promise);
 
diff --git a/quickjs.h b/quickjs.h
index ce3dc90..41c3882 100644
--- a/quickjs.h
+++ b/quickjs.h
@@ -831,7 +831,15 @@ typedef struct {
 void JS_SetSharedArrayBufferFunctions(JSRuntime *rt,
                                       const JSSharedArrayBufferFunctions *sf);
 
+typedef enum JSPromiseStateEnum {
+    JS_PROMISE_PENDING,
+    JS_PROMISE_FULFILLED,
+    JS_PROMISE_REJECTED,
+} JSPromiseStateEnum;
+
 JSValue JS_NewPromiseCapability(JSContext *ctx, JSValue *resolving_funcs);
+JSPromiseStateEnum JS_PromiseState(JSContext *ctx, JSValue promise);
+JSValue JS_PromiseResult(JSContext *ctx, JSValue promise);
 
 /* is_handled = TRUE means that the rejection is handled */
 typedef void JSHostPromiseRejectionTracker(JSContext *ctx, JSValueConst promise,
@@ -902,8 +910,8 @@ int JS_ResolveModule(JSContext *ctx, JSValueConst obj);
 /* only exported for os.Worker() */
 JSAtom JS_GetScriptOrModuleName(JSContext *ctx, int n_stack_levels);
 /* only exported for os.Worker() */
-JSModuleDef *JS_RunModule(JSContext *ctx, const char *basename,
-                          const char *filename);
+JSValue JS_LoadModule(JSContext *ctx, const char *basename,
+                      const char *filename);
 
 /* C function definition */
 typedef enum JSCFunctionEnum {  /* XXX: should rename for namespace isolation */
diff --git a/run-test262.c b/run-test262.c
index 2092cac..e0cf771 100644
--- a/run-test262.c
+++ b/run-test262.c
@@ -1170,174 +1170,193 @@ int longest_match(const char *str, const char *find, int pos, int *ppos, int lin
 static int eval_buf(JSContext *ctx, const char *buf, size_t buf_len,
                     const char *filename, int is_test, int is_negative,
                     const char *error_type, FILE *outfile, int eval_flags,
                     int is_async)
 {
     JSValue res_val, exception_val;
     int ret, error_line, pos, pos_line;
-    BOOL is_error, has_error_line;
+    BOOL is_error, has_error_line, ret_promise;
     const char *error_name;
     
     pos = skip_comments(buf, 1, &pos_line);
     error_line = pos_line;
     has_error_line = FALSE;
     exception_val = JS_UNDEFINED;
     error_name = NULL;
 
+    /* a module evaluation returns a promise */
+    ret_promise = ((eval_flags & JS_EVAL_TYPE_MODULE) != 0);
     async_done = 0; /* counter of "Test262:AsyncTestComplete" messages */
-
+    
     res_val = JS_Eval(ctx, buf, buf_len, filename, eval_flags);
 
-    if (is_async && !JS_IsException(res_val)) {
-        JS_FreeValue(ctx, res_val);
+    if ((is_async || ret_promise) && !JS_IsException(res_val)) {
+        JSValue promise = JS_UNDEFINED;
+        if (ret_promise) {
+            promise = res_val;
+        } else {
+            JS_FreeValue(ctx, res_val);
+        }
         for(;;) {
             JSContext *ctx1;
             ret = JS_ExecutePendingJob(JS_GetRuntime(ctx), &ctx1);
             if (ret < 0) {
                 res_val = JS_EXCEPTION;
                 break;
             } else if (ret == 0) {
-                /* test if the test called $DONE() once */
-                if (async_done != 1) {
-                    res_val = JS_ThrowTypeError(ctx, "$DONE() not called");
+                if (is_async) {
+                    /* test if the test called $DONE() once */
+                    if (async_done != 1) {
+                        res_val = JS_ThrowTypeError(ctx, "$DONE() not called");
+                    } else {
+                        res_val = JS_UNDEFINED;
+                    }
                 } else {
-                    res_val = JS_UNDEFINED;
+                    /* check that the returned promise is fulfilled */
+                    JSPromiseStateEnum state = JS_PromiseState(ctx, promise);
+                    if (state == JS_PROMISE_FULFILLED)
+                        res_val = JS_UNDEFINED;
+                    else if (state == JS_PROMISE_REJECTED)
+                        res_val = JS_Throw(ctx, JS_PromiseResult(ctx, promise));
+                    else
+                        res_val = JS_ThrowTypeError(ctx, "promise is pending");
                 }
                 break;
             }
         }
+        JS_FreeValue(ctx, promise);
     }
 
     if (JS_IsException(res_val)) {
         exception_val = JS_GetException(ctx);
         is_error = JS_IsError(ctx, exception_val);
         /* XXX: should get the filename and line number */
         if (outfile) {
             if (!is_error)
                 fprintf(outfile, "%sThrow: ", (eval_flags & JS_EVAL_FLAG_STRICT) ?
                         "strict mode: " : "");
             js_print(ctx, JS_NULL, 1, &exception_val);
         }
         if (is_error) {
             JSValue name, stack;
             const char *stack_str;
         
             name = JS_GetPropertyStr(ctx, exception_val, "name");
             error_name = JS_ToCString(ctx, name);
             stack = JS_GetPropertyStr(ctx, exception_val, "stack");
             if (!JS_IsUndefined(stack)) {
                 stack_str = JS_ToCString(ctx, stack);
                 if (stack_str) {
                     const char *p;
                     int len;
                     
                     if (outfile)
                         fprintf(outfile, "%s", stack_str);
                     
                     len = strlen(filename);
                     p = strstr(stack_str, filename);
                     if (p != NULL && p[len] == ':') {
                         error_line = atoi(p + len + 1);
                         has_error_line = TRUE;
                     }
                     JS_FreeCString(ctx, stack_str);
                 }
             }
             JS_FreeValue(ctx, stack);
             JS_FreeValue(ctx, name);
         }
         if (is_negative) {
             ret = 0;
             if (error_type) {
                 char *error_class;
                 const char *msg;
             
                 msg = JS_ToCString(ctx, exception_val);
                 error_class = strdup_len(msg, strcspn(msg, ":"));
                 if (!str_equal(error_class, error_type))
                     ret = -1;
                 free(error_class);
                 JS_FreeCString(ctx, msg);
             }
         } else {
             ret = -1;
         }
     } else {
         if (is_negative)
             ret = -1;
         else
             ret = 0;
     }
 
     if (verbose && is_test) {
         JSValue msg_val = JS_UNDEFINED;
         const char *msg = NULL;
         int s_line;
         char *s = find_error(filename, &s_line, eval_flags & JS_EVAL_FLAG_STRICT);
         const char *strict_mode = (eval_flags & JS_EVAL_FLAG_STRICT) ? "strict mode: " : "";
 
         if (!JS_IsUndefined(exception_val)) {
             msg_val = JS_ToString(ctx, exception_val);
             msg = JS_ToCString(ctx, msg_val);
         }
         if (is_negative) {  // expect error
             if (ret == 0) {
                 if (msg && s &&
                     (str_equal(s, "expected error") ||
                      strstart(s, "unexpected error type:", NULL) ||
                      str_equal(s, msg))) {     // did not have error yet
                     if (!has_error_line) {
                         longest_match(buf, msg, pos, &pos, pos_line, &error_line);
                     }
                     printf("%s:%d: %sOK, now has error %s\n",
                            filename, error_line, strict_mode, msg);
                     fixed_errors++;
                 }
             } else {
                 if (!s) {   // not yet reported
                     if (msg) {
                         fprintf(error_out, "%s:%d: %sunexpected error type: %s\n",
                                 filename, error_line, strict_mode, msg);
                     } else {
                         fprintf(error_out, "%s:%d: %sexpected error\n",
                                 filename, error_line, strict_mode);
                     }
                     new_errors++;
                 }
             }
         } else {            // should not have error
             if (msg) {
                 if (!s || !str_equal(s, msg)) {
                     if (!has_error_line) {
                         char *p = skip_prefix(msg, "Test262 Error: ");
                         if (strstr(p, "Test case returned non-true value!")) {
                             longest_match(buf, "runTestCase", pos, &pos, pos_line, &error_line);
                         } else {
                             longest_match(buf, p, pos, &pos, pos_line, &error_line);
                         }
                     }
                     fprintf(error_out, "%s:%d: %s%s%s\n", filename, error_line, strict_mode,
                             error_file ? "unexpected error: " : "", msg);
 
                     if (s && (!str_equal(s, msg) || error_line != s_line)) {
                         printf("%s:%d: %sprevious error: %s\n", filename, s_line, strict_mode, s);
                         changed_errors++;
                     } else {
                         new_errors++;
                     }
                 }
             } else {
                 if (s) {
                     printf("%s:%d: %sOK, fixed error: %s\n", filename, s_line, strict_mode, s);
                     fixed_errors++;
                 }
             }
         }
         JS_FreeValue(ctx, msg_val);
         JS_FreeCString(ctx, msg);
         free(s);
     }
     JS_FreeCString(ctx, error_name);
     JS_FreeValue(ctx, exception_val);
     JS_FreeValue(ctx, res_val);
     return ret;
 }
diff --git a/test262.conf b/test262.conf
index c4349f1..1fec965 100644
--- a/test262.conf
+++ b/test262.conf
@@ -195,7 +195,7 @@ symbols-as-weakmap-keys=skip
 tail-call-optimization=skip
 template
 Temporal=skip
-top-level-await=skip
+top-level-await
 TypedArray
 TypedArray.prototype.at
 u180e
