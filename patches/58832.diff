commit ba1084daac619e9f342c9b27fa40650fb6ea0c09
Author: Jakub Pawlowski <jpawlowski@google.com>
Date:   Thu May 11 17:38:34 2023 +0200

    Bluetooth: fix crash in epan/dissectors/packet-btl2cap.c:2929:26
    
    This issue was introduced in commit b4d581c77110be4136e95e7c695cc1e827b4f7c5
    Keys added to wmem_tree must have exactly same length.
    
    Fixes #19061

diff --git a/epan/dissectors/packet-btl2cap.c b/epan/dissectors/packet-btl2cap.c
index b61013c7a5..4e1947554b 100644
--- a/epan/dissectors/packet-btl2cap.c
+++ b/epan/dissectors/packet-btl2cap.c
@@ -818,174 +818,178 @@ static int
 dissect_le_credit_based_connrequest(tvbuff_t *tvb, int offset, packet_info *pinfo,
     proto_tree *tree, proto_tree *command_tree, guint16 cid, guint8 cmd_ident,
     bthci_acl_data_t *acl_data, btl2cap_data_t *l2cap_data)
 {
 
     proto_item  *psm_item;
     guint32      psm;
     guint32      scid;
 
 
     proto_tree_add_item_ret_uint(command_tree, hf_btl2cap_le_psm, tvb, offset, 2, ENC_LITTLE_ENDIAN, &psm);
     if (psm < 0x80) {
         psm_item = proto_tree_add_item(command_tree, hf_btl2cap_psm, tvb, offset, 2, ENC_LITTLE_ENDIAN);
         proto_item_set_generated(psm_item);
     }
     offset += 2;
 
     proto_tree_add_item_ret_uint(command_tree, hf_btl2cap_scid, tvb, offset, 2, ENC_LITTLE_ENDIAN, &scid);
     offset += 2;
 
     proto_tree_add_item(command_tree, hf_btl2cap_option_mtu, tvb, offset, 2, ENC_LITTLE_ENDIAN);
     offset += 2;
 
     proto_tree_add_item(command_tree, hf_btl2cap_option_mps, tvb, offset, 2, ENC_LITTLE_ENDIAN);
     offset += 2;
 
     proto_tree_add_item(command_tree, hf_btl2cap_initial_credits, tvb, offset, 2, ENC_LITTLE_ENDIAN);
     offset += 2;
 
     if (!pinfo->fd->visited) {
-        wmem_tree_key_t    key[7];
+        wmem_tree_key_t    key[8];
         guint32            k_interface_id;
         guint32            k_adapter_id;
         guint32            k_chandle;
         guint32            k_cid;
         guint32            k_cmd_ident;
         guint32            k_frame_number;
         guint32            interface_id;
         guint32            adapter_id;
         guint32            chandle;
         psm_data_t        *psm_data;
         guint32            key_cid;
+        guint32            cid_index;
 
         if (pinfo->rec->presence_flags & WTAP_HAS_INTERFACE_ID)
             interface_id = pinfo->rec->rec_header.packet_header.interface_id;
         else
             interface_id = HCI_INTERFACE_DEFAULT;
         adapter_id = (acl_data) ? acl_data->adapter_id : HCI_ADAPTER_DEFAULT;
         chandle = (acl_data) ? acl_data->chandle : 0;
 
         k_interface_id = interface_id;
         k_adapter_id = adapter_id;
         k_chandle = chandle;
         k_cid = cid;
         k_cmd_ident = cmd_ident;
         k_frame_number = pinfo->num;
+        cid_index = 0;
 
         psm_data = wmem_new0(wmem_file_scope(), psm_data_t);
 
         if (pinfo->p2p_dir == P2P_DIR_RECV) {
             key_cid = scid | 0x80000000;
             psm_data->local_cid = BTL2CAP_UNKNOWN_CID;
             psm_data->remote_cid = key_cid;
         }
         else {
             key_cid = scid;
             psm_data->local_cid = key_cid;
             psm_data->remote_cid = BTL2CAP_UNKNOWN_CID;
         }
 
         psm_data->psm = psm;
         psm_data->local_service = (pinfo->p2p_dir == P2P_DIR_RECV) ? TRUE : FALSE;
         psm_data->in.mode = L2CAP_LE_CREDIT_BASED_FLOW_CONTROL_MODE;
         psm_data->in.start_fragments = wmem_tree_new(wmem_file_scope());
         psm_data->out.mode = L2CAP_LE_CREDIT_BASED_FLOW_CONTROL_MODE;
         psm_data->out.start_fragments = wmem_tree_new(wmem_file_scope());
         psm_data->interface_id = k_interface_id;
         psm_data->adapter_id = k_adapter_id;
         psm_data->chandle = k_chandle;
         psm_data->connect_in_frame = pinfo->num;
         psm_data->disconnect_in_frame = bluetooth_max_disconnect_in_frame;
 
         key[0].length = 1;
         key[0].key = &k_interface_id;
         key[1].length = 1;
         key[1].key = &k_adapter_id;
         key[2].length = 1;
         key[2].key = &k_chandle;
         key[3].length = 1;
         key[3].key = &k_cid;
         key[4].length = 1;
         key[4].key = &k_cmd_ident;
         key[5].length = 1;
         key[5].key = &k_frame_number;
-        key[6].length = 0;
-        key[6].key = NULL;
+        key[6].length = 1;
+        key[6].key = &cid_index;
+        key[7].length = 0;
+        key[7].key = NULL;
 
         wmem_tree_insert32_array(cmd_ident_to_psm_table, key, psm_data);
 
         k_cid = key_cid;
 
         key[4].length = 1;
         key[4].key = &k_frame_number;
         key[5].length = 0;
         key[5].key = NULL;
 
         wmem_tree_insert32_array(cid_to_psm_table, key, psm_data);
     }
 
     if (l2cap_data) {
         proto_item        *sub_item;
         guint32            bt_uuid = 0;
         guint32            disconnect_in_frame = 0;
         psm_data_t        *psm_data;
         wmem_tree_key_t    key[6];
         guint32            k_interface_id;
         guint32            k_adapter_id;
         guint32            k_chandle;
         guint32            k_cid;
         guint32            k_frame_number;
         guint32            interface_id;
         guint32            adapter_id;
         guint32            chandle;
 
         if (pinfo->rec->presence_flags & WTAP_HAS_INTERFACE_ID)
             interface_id = pinfo->rec->rec_header.packet_header.interface_id;
         else
             interface_id = HCI_INTERFACE_DEFAULT;
         adapter_id = (acl_data) ? acl_data->adapter_id : HCI_ADAPTER_DEFAULT;
         chandle = (acl_data) ? acl_data->chandle : 0;
 
         k_interface_id = interface_id;
         k_adapter_id = adapter_id;
         k_chandle = chandle;
         k_cid = scid;
         k_frame_number = pinfo->num;
 
         key[0].length = 1;
         key[0].key = &k_interface_id;
         key[1].length = 1;
         key[1].key = &k_adapter_id;
         key[2].length = 1;
         key[2].key = &k_chandle;
         key[3].length = 1;
         key[3].key = &k_cid;
         key[4].length = 1;
         key[4].key = &k_frame_number;
         key[5].length = 0;
         key[5].key = NULL;
 
         psm_data = (psm_data_t *)wmem_tree_lookup32_array_le(cid_to_psm_table, key);
         if (psm_data &&
             psm_data->interface_id == interface_id &&
             psm_data->adapter_id == adapter_id &&
             psm_data->chandle == chandle &&
             psm_data->local_cid == k_cid)
         {
             bt_uuid = get_service_uuid(pinfo, l2cap_data, psm_data->psm, psm_data->local_service);
             disconnect_in_frame = psm_data->disconnect_in_frame;
         }
 
         if (bt_uuid) {
             sub_item = proto_tree_add_uint(tree, hf_btl2cap_service, tvb, 0, 0, bt_uuid);
             proto_item_set_generated(sub_item);
         }
 
         if (disconnect_in_frame < bluetooth_max_disconnect_in_frame) {
             sub_item = proto_tree_add_uint(tree, hf_btl2cap_disconnect_in_frame, tvb, 0, 0, disconnect_in_frame);
             proto_item_set_generated(sub_item);
         }
     }
 
     return offset;
 }
@@ -994,103 +998,107 @@ static int
 dissect_le_credit_based_connresponse(tvbuff_t *tvb, int offset, packet_info *pinfo,
     proto_tree *tree, guint16 cid, guint8 cmd_ident, bthci_acl_data_t *acl_data)
 {
     guint32            dcid;
 
     proto_tree_add_item_ret_uint(tree, hf_btl2cap_dcid, tvb, offset, 2, ENC_LITTLE_ENDIAN, &dcid);
     offset += 2;
 
     proto_tree_add_item(tree, hf_btl2cap_option_mtu, tvb, offset, 2, ENC_LITTLE_ENDIAN);
     offset += 2;
 
     proto_tree_add_item(tree, hf_btl2cap_option_mps, tvb, offset, 2, ENC_LITTLE_ENDIAN);
     offset += 2;
 
     proto_tree_add_item(tree, hf_btl2cap_initial_credits, tvb, offset, 2, ENC_LITTLE_ENDIAN);
     offset += 2;
 
     proto_tree_add_item(tree, hf_btl2cap_le_result, tvb, offset, 2, ENC_LITTLE_ENDIAN);
     offset += 2;
 
 
     if (pinfo->fd->visited == 0) {
         psm_data_t        *psm_data;
-        wmem_tree_key_t    key[7];
+        wmem_tree_key_t    key[8];
         guint32            k_interface_id;
         guint32            k_adapter_id;
         guint32            k_chandle;
         guint32            k_cid;
         guint32            k_cmd_ident;
         guint32            k_frame_number;
         guint32            interface_id;
         guint32            adapter_id;
         guint32            chandle;
         guint32            key_cid;
+        guint32            cid_index;
 
         if (pinfo->rec->presence_flags & WTAP_HAS_INTERFACE_ID)
             interface_id = pinfo->rec->rec_header.packet_header.interface_id;
         else
             interface_id = HCI_INTERFACE_DEFAULT;
         adapter_id = (acl_data) ? acl_data->adapter_id : HCI_ADAPTER_DEFAULT;
         chandle = (acl_data) ? acl_data->chandle : 0;
 
         k_interface_id = interface_id;
         k_adapter_id = adapter_id;
         k_chandle = chandle;
         k_cid = cid;
         k_cmd_ident = cmd_ident;
         k_frame_number = pinfo->num;
+        cid_index = 0;
 
         key[0].length = 1;
         key[0].key = &k_interface_id;
         key[1].length = 1;
         key[1].key = &k_adapter_id;
         key[2].length = 1;
         key[2].key = &k_chandle;
         key[3].length = 1;
         key[3].key = &k_cid;
         key[4].length = 1;
         key[4].key = &k_cmd_ident;
         key[5].length = 1;
         key[5].key = &k_frame_number;
-        key[6].length = 0;
-        key[6].key = NULL;
+        key[6].length = 1;
+        key[6].key = &cid_index;
+        key[7].length = 0;
+        key[7].key = NULL;
 
         psm_data = (psm_data_t *)wmem_tree_lookup32_array_le(cmd_ident_to_psm_table, key);
         if (psm_data &&
             psm_data->interface_id == interface_id &&
             psm_data->adapter_id == adapter_id &&
             psm_data->chandle == chandle &&
             psm_data->disconnect_in_frame > pinfo->num)
         {
             key_cid = dcid | ((pinfo->p2p_dir != P2P_DIR_RECV) ? 0x00000000 : 0x80000000);
 
             k_interface_id = interface_id;
             k_adapter_id = adapter_id;
             k_chandle = chandle;
             k_cid = key_cid;
             k_frame_number = pinfo->num;
 
             key[0].length = 1;
             key[0].key = &k_interface_id;
             key[1].length = 1;
             key[1].key = &k_adapter_id;
             key[2].length = 1;
             key[2].key = &k_chandle;
             key[3].length = 1;
             key[3].key = &k_cid;
             key[4].length = 1;
             key[4].key = &k_frame_number;
             key[5].length = 0;
             key[5].key = NULL;
 
             if (pinfo->p2p_dir == P2P_DIR_RECV)
                 psm_data->remote_cid = key_cid;
             else
                 psm_data->local_cid = key_cid;
 
             wmem_tree_insert32_array(cid_to_psm_table, key, psm_data);
         }
     }
 
     return offset;
 }
