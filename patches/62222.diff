commit 2b883b93be5feef26469fb07ca126b7c13b2fd21
Author: Ivan Nardi <12729895+IvanNardi@users.noreply.github.com>
Date:   Sun Sep 10 11:09:59 2023 +0200

    Fix some errors found by fuzzers (#2078)
    
    Fix compilation on Windows.
    "dirent.h" file has been taken from https://github.com/tronkko/dirent/
    
    Fix Python bindings
    
    Fix some warnings with x86_64-w64-mingw32-gcc:
    ```
    protocols/dns.c: In function ‘ndpi_search_dns’:
    protocols/dns.c:775:41: error: cast from pointer to integer of different size [-Werror=pointer-to-int-cast]
      775 |       unsigned long first_element_len = (unsigned long)dot - (unsigned long)_hostname;
          |                                         ^
    protocols/dns.c:775:62: error: cast from pointer to integer of different size [-Werror=pointer-to-int-cast]
      775 |       unsigned long first_element_len = (unsigned long)dot - (unsigned long)_hostname;
          |
    ```
    ```
    In file included from ndpi_bitmap64.c:31:
    third_party/include/binaryfusefilter.h: In function ‘binary_fuse8_hash’:
    third_party/include/binaryfusefilter.h:160:32: error: left shift count >= width of type [-Werror=shift-count-overflow]
      160 |     uint64_t hh = hash & ((1UL << 36) - 1);
    ```
    ```
    In function ‘ndpi_match_custom_category’,
        inlined from ‘ndpi_fill_protocol_category.part.0’ at ndpi_main.c:7056:16:
    ndpi_main.c:3419:3: error: ‘strncpy’ specified bound depends on the length of the source argument [-Werror=stringop-overflow=]
     3419 |   strncpy(buf, name, name_len);
    ```

diff --git a/Makefile.am b/Makefile.am
index 9745ec7a..8efab1d0 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -11,16 +11,16 @@ pkgconfig_DATA = libndpi.pc
 EXTRA_DIST = README.md README.fuzzer.md CHANGELOG.md CONTRIBUTING.md \
 	autogen.sh wireshark windows utils packages \
 	influxdb/Makefile.in influxdb/metric_anomaly.c influxdb/README.txt \
 	rrdtool/Makefile.in rrdtool/README.txt rrdtool/rrd_anomaly.c rrdtool/rrd_similarity.c \
 	doc/requirements.txt doc/conf.py doc/flow_risks.rst doc/protocols.rst doc/guide/nDPI_QuickStartGuide.pages \
 		doc/guide/nDPI_QuickStartGuide.pdf doc/img/logo.png doc/index.rst \
 		doc/Makefile doc/what_is_ndpi.rst \
 	python/DEV_GUIDE.md python/dev_requirements.txt python/ndpi_example.py python/ndpi/__init__.py \
 		python/ndpi/ndpi_build.py python/ndpi/ndpi.py python/README.md \
 		python/requirements.txt python/setup.py python/tests.py \
 	lists/107_gambling.list \
 	lists/107_gambling_custom.list \
-	lists/README.md
+	lists/README.md \
 	sonar-project.properties .github .ci-ignore
 
 doc:
diff --git a/src/include/ndpi_typedefs.h b/src/include/ndpi_typedefs.h
index 47e2b989..d440a9e7 100644
--- a/src/include/ndpi_typedefs.h
+++ b/src/include/ndpi_typedefs.h
@@ -620,13 +620,26 @@ struct ndpi_gre_basehdr {
 /**
  * Optional information about flow management (per packet)
  */
 struct ndpi_flow_input_info {
   unsigned char in_pkt_dir;
   unsigned char seen_flow_beginning;
 };
 
+/* Save memory limiting the key to 56 bit */
+//#define SAVE_BINARY_BITMAP_MEMORY
+
+PACK_ON
+struct ndpi_binary_bitmap_entry {
+#ifdef SAVE_BINARY_BITMAP_MEMORY
+  u_int64_t value:56, category:8;
+#else
+  u_int64_t value;
+  u_int8_t category;
+#endif
+} PACK_OFF;
+
 /* ******************* ********************* ****************** */
 /* ************************************************************ */
 
 //CFFI.NDPI_PACKED_STRUCTURES
 #endif // NDPI_CFFI_PREPROCESSING_EXCLUDE_PACKED
@@ -1180,19 +1193,6 @@ typedef void ndpi_bitmap;
 typedef void ndpi_bitmap64;
 typedef void ndpi_bitmap_iterator;
 typedef void ndpi_filter;
-
-/* Save memory limiting the key to 56 bit */
-//#define SAVE_BINARY_BITMAP_MEMORY
-
-PACK_ON
-struct ndpi_binary_bitmap_entry {
-#ifdef SAVE_BINARY_BITMAP_MEMORY
-  u_int64_t value:56, category:8;
-#else
-  u_int64_t value;
-  u_int8_t category;
-#endif
-} PACK_OFF;
     
 typedef struct {
   u_int32_t num_allocated_entries, num_used_entries;
diff --git a/src/lib/ndpi_bitmap64.c b/src/lib/ndpi_bitmap64.c
index 1c8368b2..f254c148 100644
--- a/src/lib/ndpi_bitmap64.c
+++ b/src/lib/ndpi_bitmap64.c
@@ -74,47 +74,50 @@ static int ndpi_bitmap64_entry_compare(const void *_a, const void *_b) {
 /* Sort and compact memory before searching */
 bool ndpi_bitmap64_compress(ndpi_bitmap64 *_b) {
   ndpi_bitmap64_t *b = (ndpi_bitmap64_t*)_b;
   u_int32_t i;
 
+  if(!b)
+    return(false);
+
   if(b->num_used_entries > 0) {
     if(b->num_used_entries > 1)
       qsort(b->entries, b->num_used_entries,
 	    sizeof(u_int64_t),
 	    ndpi_bitmap64_entry_compare);
 
     /* Now remove duplicates */
     u_int64_t old_value = b->entries[0], new_len = 1;
 
     for(i=1; i<b->num_used_entries; i++) {
       if(b->entries[i] != old_value) {
 	if(new_len != i)
 	  memcpy(&b->entries[new_len], &b->entries[i], sizeof(u_int64_t));
 
 	old_value = b->entries[i];
 	new_len++;
       } else {
 #ifdef PRINT_DUPLICATED_HASHS
 	printf("Skipping duplicate hash %lluu [id: %u/%u]\n",
 	       b->entries[i].value, i, b->num_used_entries);
 #endif
       }
     }
 
     b->num_used_entries = b->num_allocated_entries = new_len;
   }
 
   if(binary_fuse16_allocate(b->num_used_entries, &b->bitmap)) {
     if(binary_fuse16_populate(b->entries, b->num_used_entries, &b->bitmap)) {
       ndpi_free(b->entries), b->num_used_entries = b->num_allocated_entries = 0;
       b->entries = NULL;
     } else
       return(false);
   } else
     return(false);
 
   b->is_compressed = true;
 
   return(true);
 }
 
 /* ********************************************************** */
@@ -122,32 +125,35 @@ bool ndpi_bitmap64_compress(ndpi_bitmap64 *_b) {
 bool ndpi_bitmap64_set(ndpi_bitmap64 *_b, u_int64_t value) {
   ndpi_bitmap64_t *b = (ndpi_bitmap64_t*)_b;
 
+  if(!b)
+    return(false);
+
   if(b->is_compressed) {
     /*
       We need to discard the filter and start over as this
       datastructure is immutable
     */
 
     binary_fuse16_free(&b->bitmap);
     /* No need to call b->is_compressed = false; as it will be set below */
   }
 
   if(b->num_used_entries >= b->num_allocated_entries) {
     u_int64_t *rc;
     u_int32_t new_len = b->num_allocated_entries + NDPI_BITMAP64_REALLOC_SIZE;
 
     rc = (u_int64_t*)ndpi_realloc(b->entries,
 				  sizeof(u_int64_t)*b->num_allocated_entries,
 				  sizeof(u_int64_t)*new_len);
     if(rc == NULL) return(false);
 
     b->entries = rc, b->num_allocated_entries = new_len;
   }
 
   b->entries[b->num_used_entries] = value;
   b->num_used_entries++, b->is_compressed = false;
 
   return(true);
 }
 
 /* ********************************************************** */
@@ -155,9 +161,12 @@ bool ndpi_bitmap64_set(ndpi_bitmap64 *_b, u_int64_t value) {
 bool ndpi_bitmap64_isset(ndpi_bitmap64 *_b, u_int64_t value) {
   ndpi_bitmap64_t *b = (ndpi_bitmap64_t*)_b;
 
+  if(!b)
+    return(false);
+
   if(!b->is_compressed) ndpi_bitmap64_compress(b);
 
   return(binary_fuse16_contain(value, &b->bitmap));
 }
 
 /* ********************************************************** */
@@ -165,12 +174,15 @@ bool ndpi_bitmap64_isset(ndpi_bitmap64 *_b, u_int64_t value) {
 void ndpi_bitmap64_free(ndpi_bitmap64 *_b) {
   ndpi_bitmap64_t *b = (ndpi_bitmap64_t*)_b;
 
+  if(!b)
+    return;
+
   if(b->entries)        ndpi_free(b->entries);
 
   if(b->is_compressed)
     binary_fuse16_free(&b->bitmap);
 
   ndpi_free(b);
 }
 
 /* ********************************************************** */
@@ -178,5 +190,8 @@ void ndpi_bitmap64_free(ndpi_bitmap64 *_b) {
 u_int32_t ndpi_bitmap64_size(ndpi_bitmap64 *_b) {
   ndpi_bitmap64_t *b = (ndpi_bitmap64_t*)_b;
 
+  if(!b)
+    return(0);
+
   return(sizeof(ndpi_bitmap64) + binary_fuse16_size_in_bytes(&b->bitmap));
 }
diff --git a/src/lib/ndpi_domain_classify.c b/src/lib/ndpi_domain_classify.c
index fa866f32..f1a31906 100644
--- a/src/lib/ndpi_domain_classify.c
+++ b/src/lib/ndpi_domain_classify.c
@@ -47,14 +47,17 @@ ndpi_domain_classify* ndpi_domain_classify_alloc() {
 void ndpi_domain_classify_free(ndpi_domain_classify *s) {
   u_int32_t i;
 
+  if(!s)
+    return;
+
   for(i=0; i<MAX_NUM_NDPI_DOMAIN_CLASSIFICATIONS; i++) {
     if(s->classes[i].domains != NULL) {
       ndpi_bitmap64_free(s->classes[i].domains);
     } else
       break;
   }
 
   ndpi_free(s);
 }
 
 /* ********************************************************** */
@@ -77,28 +80,30 @@ u_int32_t ndpi_domain_classify_size(ndpi_domain_classify *s) {
 bool ndpi_domain_classify_add(ndpi_domain_classify *s,
 			      u_int8_t class_id,
 			      char *domain) {
   u_int32_t i;
   char *dot = strrchr(domain, '.');
 
   if(!dot) return(false);
   if((!strcmp(dot, ".arpa")) || (!strcmp(dot, ".local")))
     return(false);
 
   for(i=0; i<MAX_NUM_NDPI_DOMAIN_CLASSIFICATIONS; i++) {
     if(s->classes[i].class_id == class_id) {
       break;      
     } else if(s->classes[i].class_id == 0) {
       s->classes[i].class_id = class_id;
       s->classes[i].domains  = ndpi_bitmap64_alloc();
+      if(!s->classes[i].domains)
+        s->classes[i].class_id = 0;
       break;
     }
   }
 
   if(i == MAX_NUM_NDPI_DOMAIN_CLASSIFICATIONS)
     return(false);
 
   return(ndpi_bitmap64_set(s->classes[i].domains,
 			   ndpi_quick_hash64(domain, strlen(domain))));
 }
 
 /* ********************************************************** */
@@ -106,54 +111,56 @@ bool ndpi_domain_classify_add(ndpi_domain_classify *s,
 u_int32_t ndpi_domain_classify_add_domains(ndpi_domain_classify *s,
 					   u_int8_t class_id,
 					   char *file_path) {
   u_int32_t i, num_added = 0;
   char buf[256];
   FILE *fd;
   char *line;
 
   for(i=0; i<MAX_NUM_NDPI_DOMAIN_CLASSIFICATIONS; i++) {
     if(s->classes[i].class_id == class_id) {
       break;      
     } else if(s->classes[i].class_id == 0) {
       s->classes[i].class_id = class_id;
       s->classes[i].domains  = ndpi_bitmap64_alloc();
+      if(!s->classes[i].domains)
+        s->classes[i].class_id = 0;
       break;
     }
   }
 
   if(i == MAX_NUM_NDPI_DOMAIN_CLASSIFICATIONS)
     return(false);
 
   /* *************************************** */
 
   fd = fopen(file_path, "r");
   if(fd == NULL)
     return(false);
 
   while((line = fgets(buf, sizeof(buf), fd)) != NULL) {
     u_int len;
     u_int64_t hash;
     
     if((line[0] == '#') ||  (line[0] == '\0'))
       continue;
     else {
       len = strlen(line) - 1;
 
       if(len == 0)
 	continue;
       else
 	line[len] = '\0';
     }
 
     hash = ndpi_quick_hash64(line, strlen(line));
 
     if(ndpi_bitmap64_set(s->classes[i].domains, hash))			 
       num_added++;
   }
 
   fclose(fd);
 
   return(num_added);
 }
 
 /* ********************************************************** */
diff --git a/src/lib/ndpi_main.c b/src/lib/ndpi_main.c
index ae3c4c20..c2a5b2f2 100644
--- a/src/lib/ndpi_main.c
+++ b/src/lib/ndpi_main.c
@@ -2669,10 +2669,11 @@ void ndpi_debug_printf(unsigned int proto, struct ndpi_detection_module_struct *
 
 void set_ndpi_debug_function(struct ndpi_detection_module_struct *ndpi_str, ndpi_debug_function_ptr ndpi_debug_printf) {
 #ifdef NDPI_ENABLE_DEBUG_MESSAGES
-  ndpi_str->ndpi_debug_printf = ndpi_debug_printf;
+  if(ndpi_str)
+    ndpi_str->ndpi_debug_printf = ndpi_debug_printf;
 #endif
 }
 
 /* ****************************************** */
 
 /* Keep it in order and in sync with ndpi_protocol_category_t in ndpi_typedefs.h */
@@ -2799,293 +2800,301 @@ _Static_assert(sizeof(categories) / sizeof(char *) == NDPI_PROTOCOL_NUM_CATEGORI
 struct ndpi_detection_module_struct *ndpi_init_detection_module(ndpi_init_prefs prefs) {
   struct ndpi_detection_module_struct *ndpi_str = ndpi_malloc(sizeof(struct ndpi_detection_module_struct));
   int i;
 
   if(ndpi_str == NULL) {
     /* Logging this error is a bit tricky. At this point, we can't use NDPI_LOG*
        functions yet, we don't have a custom log function and, as a library,
        we shouldn't use stdout/stderr. Since this error is quite unlikely,
        simply avoid any logs at all */
     return(NULL);
   }
 
   memset(ndpi_str, 0, sizeof(struct ndpi_detection_module_struct));
 
 #ifdef NDPI_ENABLE_DEBUG_MESSAGES
   set_ndpi_debug_function(ndpi_str, (ndpi_debug_function_ptr) ndpi_debug_printf);
   NDPI_BITMASK_RESET(ndpi_str->debug_bitmask);
 #endif /* NDPI_ENABLE_DEBUG_MESSAGES */
 
   if(prefs & ndpi_enable_ja3_plus)
     ndpi_str->enable_ja3_plus = 1;
 
   if(!(prefs & ndpi_dont_init_libgcrypt)) {
     if(!gcry_control (GCRYCTL_INITIALIZATION_FINISHED_P)) {
       const char *gcrypt_ver = gcry_check_version(NULL);
       if(!gcrypt_ver) {
         NDPI_LOG_ERR(ndpi_str, "Error initializing libgcrypt\n");
         ndpi_free(ndpi_str);
         return NULL;
       }
       NDPI_LOG_DBG(ndpi_str, "Libgcrypt %s\n", gcrypt_ver);
       /* Tell Libgcrypt that initialization has completed. */
       gcry_control (GCRYCTL_INITIALIZATION_FINISHED, 0);
     }
   } else {
     NDPI_LOG_DBG(ndpi_str, "Libgcrypt initialization skipped\n");
   }
 
   if((ndpi_str->protocols_ptree = ndpi_patricia_new(32 /* IPv4 */)) != NULL) {
     ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, host_protocol_list);
 
     if(!(prefs & ndpi_dont_load_cachefly_list))
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_cachefly_protocol_list);
 
     if(!(prefs & ndpi_dont_load_tor_list))
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_tor_protocol_list);
 
     if(!(prefs & ndpi_dont_load_azure_list))
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_microsoft_azure_protocol_list);
 
     if(!(prefs & ndpi_dont_load_whatsapp_list))
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_whatsapp_protocol_list);
 
     if(!(prefs & ndpi_dont_load_amazon_aws_list))
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_amazon_aws_protocol_list);
 
     if(!(prefs & ndpi_dont_load_ethereum_list))
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_mining_protocol_list);
 
     if(!(prefs & ndpi_dont_load_zoom_list))
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_zoom_protocol_list);
 
     if(!(prefs & ndpi_dont_load_cloudflare_list))
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_cloudflare_protocol_list);
 
     if(!(prefs & ndpi_dont_load_microsoft_list)) {
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_microsoft_365_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_ms_one_drive_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_ms_outlook_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_skype_teams_protocol_list);
     }
 
     if(!(prefs & ndpi_dont_load_google_list))
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_google_protocol_list);
 
     if(!(prefs & ndpi_dont_load_google_cloud_list))
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_google_cloud_protocol_list);
 
     if(!(prefs & ndpi_dont_load_protonvpn_list))
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_protonvpn_protocol_list);
 
     if(!(prefs & ndpi_dont_load_mullvad_list))
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_mullvad_protocol_list);
 
     if(!(prefs & ndpi_dont_load_asn_lists)) {
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_telegram_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_apple_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_twitter_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_netflix_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_webex_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_teamviewer_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_facebook_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_tencent_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_opendns_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_dropbox_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_starcraft_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_ubuntuone_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_twitch_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_hotspot_shield_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_github_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_steam_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_bloomberg_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_citrix_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_edgecast_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_goto_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_riotgames_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_threema_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_alibaba_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_avast_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_discord_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_line_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_vk_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_yandex_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_yandex_cloud_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_disneyplus_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_hulu_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_epicgames_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_nvidia_protocol_list);
       ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, ndpi_protocol_roblox_protocol_list);
     }
 
     if(prefs & ndpi_track_flow_payload)
       ndpi_str->max_payload_track_len = 1024; /* track up to X payload bytes */
   }
 
   ndpi_str->ip_risk_mask_ptree = ndpi_patricia_new(32 /* IPv4 */);
 
   if(!(prefs & ndpi_dont_init_risk_ptree)) {
     if((ndpi_str->ip_risk_ptree = ndpi_patricia_new(32 /* IPv4 */)) != NULL) {
       if(!(prefs & ndpi_dont_load_icloud_private_relay_list))
         ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->ip_risk_ptree, ndpi_anonymous_subscriber_icloud_private_relay_protocol_list);
       if(!(prefs & ndpi_dont_load_protonvpn_exit_nodes_list))
         ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->ip_risk_ptree, ndpi_anonymous_subscriber_protonvpn_protocol_list);
       if(!(prefs & ndpi_dont_load_crawlers_list))
         ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->ip_risk_ptree, ndpi_http_crawler_bot_protocol_list);
     }
   }
 
   ndpi_str->max_packets_to_process = NDPI_DEFAULT_MAX_NUM_PKTS_PER_FLOW_TO_DISSECT;
 
   NDPI_BITMASK_SET_ALL(ndpi_str->detection_bitmask);
   ndpi_str->user_data = NULL;
 
   ndpi_str->tcp_max_retransmission_window_size = NDPI_DEFAULT_MAX_TCP_RETRANSMISSION_WINDOW_SIZE;
   ndpi_str->tls_certificate_expire_in_x_days = 30; /* NDPI_TLS_CERTIFICATE_ABOUT_TO_EXPIRE flow risk */
 
   ndpi_str->ndpi_num_supported_protocols = NDPI_MAX_SUPPORTED_PROTOCOLS;
   ndpi_str->ndpi_num_custom_protocols = 0;
 
   ndpi_str->host_automa.ac_automa = ac_automata_init(ac_domain_match_handler);
   if(!ndpi_str->host_automa.ac_automa) {
     ndpi_exit_detection_module(ndpi_str);
     return(NULL);
   }
 
   ndpi_str->host_risk_mask_automa.ac_automa = ac_automata_init(ac_domain_match_handler);
   if(!ndpi_str->host_risk_mask_automa.ac_automa) {
     ndpi_exit_detection_module(ndpi_str);
     return(NULL);
   }
 
   ndpi_str->common_alpns_automa.ac_automa = ac_automata_init(ac_domain_match_handler);
   if(!ndpi_str->common_alpns_automa.ac_automa) {
     ndpi_exit_detection_module(ndpi_str);
     return(NULL);
   }
 
   load_common_alpns(ndpi_str);
 
   ndpi_str->tls_cert_subject_automa.ac_automa = ac_automata_init(NULL);
   if(!ndpi_str->tls_cert_subject_automa.ac_automa) {
     ndpi_exit_detection_module(ndpi_str);
     return(NULL);
   }
 
   ndpi_str->malicious_ja3_hashmap = NULL; /* Initialized on demand */
   ndpi_str->malicious_sha1_hashmap = NULL; /* Initialized on demand */
   ndpi_str->risky_domain_automa.ac_automa = NULL; /* Initialized on demand */
   ndpi_str->trusted_issuer_dn = NULL;
 
 #ifdef USE_LEGACY_AHO_CORASICK
   ndpi_str->custom_categories.hostnames.ac_automa = ac_automata_init(ac_domain_match_handler);
   if(!ndpi_str->custom_categories.hostnames.ac_automa) {
     ndpi_exit_detection_module(ndpi_str);
     return(NULL);
   }
 
   ndpi_str->custom_categories.hostnames_shadow.ac_automa = ac_automata_init(ac_domain_match_handler);
   if(!ndpi_str->custom_categories.hostnames_shadow.ac_automa) {
     ndpi_exit_detection_module(ndpi_str);
     return(NULL);
   }
 
   if(ndpi_str->custom_categories.hostnames.ac_automa)
     ac_automata_feature(ndpi_str->custom_categories.hostnames.ac_automa, AC_FEATURE_LC);
 
   if(ndpi_str->custom_categories.hostnames_shadow.ac_automa)
     ac_automata_feature(ndpi_str->custom_categories.hostnames_shadow.ac_automa, AC_FEATURE_LC);
 
   if(ndpi_str->custom_categories.hostnames.ac_automa)
     ac_automata_name(ndpi_str->custom_categories.hostnames.ac_automa, "ccat", 0);
 
   if(ndpi_str->custom_categories.hostnames_shadow.ac_automa)
     ac_automata_name(ndpi_str->custom_categories.hostnames_shadow.ac_automa, "ccat_sh", 0);
 #else
   ndpi_str->custom_categories.sc_hostnames        = ndpi_domain_classify_alloc();
+  if(!ndpi_str->custom_categories.sc_hostnames) {
+    ndpi_exit_detection_module(ndpi_str);
+    return(NULL);
+  }
   ndpi_str->custom_categories.sc_hostnames_shadow = ndpi_domain_classify_alloc();
+  if(!ndpi_str->custom_categories.sc_hostnames_shadow) {
+    ndpi_exit_detection_module(ndpi_str);
+    return(NULL);
+  }
 #endif
 
   ndpi_str->custom_categories.ipAddresses = ndpi_patricia_new(32 /* IPv4 */);
   ndpi_str->custom_categories.ipAddresses_shadow = ndpi_patricia_new(32 /* IPv4 */);
 
   if(ndpi_str->host_automa.ac_automa)
     ac_automata_feature(ndpi_str->host_automa.ac_automa,AC_FEATURE_LC);
 
   if(ndpi_str->tls_cert_subject_automa.ac_automa)
     ac_automata_feature(ndpi_str->tls_cert_subject_automa.ac_automa,AC_FEATURE_LC);
 
   if(ndpi_str->host_risk_mask_automa.ac_automa)
     ac_automata_feature(ndpi_str->host_risk_mask_automa.ac_automa,AC_FEATURE_LC);
 
   if(ndpi_str->common_alpns_automa.ac_automa)
     ac_automata_feature(ndpi_str->common_alpns_automa.ac_automa,AC_FEATURE_LC);
 
   /* ahocorasick debug */
   /* Needed ac_automata_enable_debug(1) for show debug */
   if(ndpi_str->host_automa.ac_automa)
     ac_automata_name(ndpi_str->host_automa.ac_automa,"host",AC_FEATURE_DEBUG);
 
   if(ndpi_str->tls_cert_subject_automa.ac_automa)
     ac_automata_name(ndpi_str->tls_cert_subject_automa.ac_automa,"tls_cert",AC_FEATURE_DEBUG);
 
   if(ndpi_str->host_risk_mask_automa.ac_automa)
     ac_automata_name(ndpi_str->host_risk_mask_automa.ac_automa,"content",AC_FEATURE_DEBUG);
 
   if(ndpi_str->common_alpns_automa.ac_automa)
     ac_automata_name(ndpi_str->common_alpns_automa.ac_automa,"content",AC_FEATURE_DEBUG);
 
   if((ndpi_str->custom_categories.ipAddresses == NULL) || (ndpi_str->custom_categories.ipAddresses_shadow == NULL)) {
     NDPI_LOG_ERR(ndpi_str, "[NDPI] Error allocating Patricia trees\n");
     ndpi_exit_detection_module(ndpi_str);
     return(NULL);
   }
 
   ndpi_str->ookla_cache_num_entries = 1024;
   ndpi_str->bittorrent_cache_num_entries = 32768;
   ndpi_str->zoom_cache_num_entries = 512;
   ndpi_str->stun_cache_num_entries = 1024;
   ndpi_str->tls_cert_cache_num_entries = 1024;
   ndpi_str->mining_cache_num_entries = 1024;
   ndpi_str->msteams_cache_num_entries = 1024;
   ndpi_str->stun_zoom_cache_num_entries = 1024;
 
   ndpi_str->ookla_cache_ttl = 120; /* sec */
   ndpi_str->bittorrent_cache_ttl = 0;
   ndpi_str->zoom_cache_ttl = 0;
   ndpi_str->stun_cache_ttl = 0;
   ndpi_str->tls_cert_cache_ttl = 0;
   ndpi_str->mining_cache_ttl = 0;
   ndpi_str->msteams_cache_ttl = 60; /* sec */
   ndpi_str->stun_zoom_cache_ttl = 60; /* sec */
 
   ndpi_str->opportunistic_tls_smtp_enabled = 1;
   ndpi_str->opportunistic_tls_imap_enabled = 1;
   ndpi_str->opportunistic_tls_pop_enabled = 1;
   ndpi_str->opportunistic_tls_ftp_enabled = 1;
   ndpi_str->opportunistic_tls_stun_enabled = 1;
 
   ndpi_str->monitoring_stun_pkts_to_process = 4;
   ndpi_str->monitoring_stun_flags = 0;
 
   ndpi_str->aggressiveness_ookla = NDPI_AGGRESSIVENESS_OOKLA_TLS;
 
   if(prefs & ndpi_enable_tcp_ack_payload_heuristic)
     ndpi_str->tcp_ack_paylod_heuristic = 1;
 
   if(!(prefs & ndpi_disable_fully_encrypted_heuristic))
     ndpi_str->fully_encrypted_based_on_first_pkt_heuristic = 1;
 
   for(i = 0; i < NUM_CUSTOM_CATEGORIES; i++)
     ndpi_snprintf(ndpi_str->custom_category_labels[i], CUSTOM_CATEGORY_LABEL_LEN, "User custom category %u",
 	     (unsigned int) (i + 1));
 
   return(ndpi_str);
 }
 
 /* *********************************************** */
 
 /*
   This function adds some exceptions for popular domain names
   in order to avoid "false" positives and avoid polluting
   results
 */
@@ -3395,28 +3404,28 @@ int ndpi_match_string_value(void *automa, char *string_to_match,
 int ndpi_match_custom_category(struct ndpi_detection_module_struct *ndpi_str,
 			       char *name, u_int name_len,
                                ndpi_protocol_category_t *category) {
 #ifdef USE_LEGACY_AHO_CORASICK
   u_int32_t id;
   int rc = ndpi_match_string_common(ndpi_str->custom_categories.hostnames.ac_automa,
 				    name, name_len, &id, category, NULL);
   if(rc < 0) return rc;
   return(id != NDPI_PROTOCOL_UNKNOWN ? 0 : -1);
 #else
   char buf[128];
   u_int8_t class_id;
   u_int max_len = sizeof(buf)-1;
     
   if(name_len > max_len) name_len = max_len;
-  strncpy(buf, name, name_len);
+  memcpy(buf, name, name_len);
   buf[name_len] = '\0';
   
   if(ndpi_domain_classify_contains(ndpi_str->custom_categories.sc_hostnames,
 				   &class_id, buf)) {
     *category = (ndpi_protocol_category_t)class_id;
     return(0);
   } else    
     return(-1); /* Not found */
 #endif
 }
 
 /* *********************************************** */
@@ -6876,22 +6885,25 @@ int ndpi_load_ip_category(struct ndpi_detection_module_struct *ndpi_str,
 int ndpi_load_hostname_category(struct ndpi_detection_module_struct *ndpi_str,
 				const char *name_to_add,
 				ndpi_protocol_category_t category) {
 #ifdef USE_LEGACY_AHO_CORASICK
   if(ndpi_str->custom_categories.hostnames_shadow.ac_automa == NULL)
     return(-1);
 
   if(name_to_add == NULL)
     return(-1);
 
   return ndpi_string_to_automa(ndpi_str,
 			       (AC_AUTOMATA_t *)ndpi_str->custom_categories.hostnames_shadow.ac_automa,
 			       name_to_add,category,category, 0, 0, 1); /* at_end */
 #else
+  if(ndpi_str->custom_categories.sc_hostnames_shadow == NULL)
+    return(-1);
+
   return(ndpi_domain_classify_add(ndpi_str->custom_categories.sc_hostnames_shadow,
 				  (u_int16_t)category, (char*)name_to_add) ? 0 : -1);
 #endif
 }
 
 /* ********************************************************************************* */
 
 /* Loads an IP or name category */
diff --git a/src/lib/protocols/dns.c b/src/lib/protocols/dns.c
index 1a318aa0..b518ba0f 100644
--- a/src/lib/protocols/dns.c
+++ b/src/lib/protocols/dns.c
@@ -658,229 +658,229 @@ static int search_dns_again(struct ndpi_detection_module_struct *ndpi_struct, st
 static void ndpi_search_dns(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow) {
   struct ndpi_packet_struct *packet = &ndpi_struct->packet;
   int payload_offset;
   u_int8_t is_query, is_mdns;
   u_int16_t s_port = 0, d_port = 0;
 
   NDPI_LOG_DBG(ndpi_struct, "search DNS\n");
 
   if(packet->udp != NULL) {
     s_port = ntohs(packet->udp->source);
     d_port = ntohs(packet->udp->dest);
     payload_offset = 0;
 
     /* For MDNS/LLMNR: If the packet is not a response, dest addr needs to be multicast. */
     if ((d_port == MDNS_PORT && isMDNSMulticastAddress(packet) == 0) ||
         (d_port == LLMNR_PORT && isLLMNRMulticastAddress(packet) == 0))
     {
       if (packet->payload_packet_len > 5 &&
           ntohs(get_u_int16_t(packet->payload, 2)) != 0 &&
           ntohs(get_u_int16_t(packet->payload, 4)) != 0)
       {
         NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
         return;
       }
     }
   } else if(packet->tcp != NULL) /* pkt size > 512 bytes */ {
     s_port = ntohs(packet->tcp->source);
     d_port = ntohs(packet->tcp->dest);
     payload_offset = 2;
   }
 
   is_mdns = ((s_port == MDNS_PORT) || (d_port == MDNS_PORT)) ? 1 : 0;
   
   if(((s_port == DNS_PORT) || (d_port == DNS_PORT)
       || is_mdns
       || (d_port == LLMNR_PORT))
      && (packet->payload_packet_len > sizeof(struct ndpi_dns_packet_header)+payload_offset)) {
     struct ndpi_dns_packet_header dns_header;
     char *dot;
     u_int len, off;
     int invalid = search_valid_dns(ndpi_struct, flow, &dns_header, payload_offset, &is_query, is_mdns);
     ndpi_protocol ret;
     u_int num_queries, idx;
     char _hostname[256];
 
     ret.master_protocol = NDPI_PROTOCOL_UNKNOWN;
     ret.app_protocol    = (d_port == LLMNR_PORT) ? NDPI_PROTOCOL_LLMNR : ((d_port == MDNS_PORT) ? NDPI_PROTOCOL_MDNS : NDPI_PROTOCOL_DNS);
 
     if(invalid) {
       NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
       return;
     }
 
     /* extract host name server */
     off = sizeof(struct ndpi_dns_packet_header) + payload_offset;
 
     /* Before continuing let's dissect the following queries to see if they are valid */
     for(idx=off, num_queries=0; (num_queries < dns_header.num_queries) && (idx < packet->payload_packet_len);) {
       u_int32_t i, tot_len = 0;
 
       for(i=idx; i<packet->payload_packet_len;) {
 	u_int8_t is_ptr = 0, name_len = packet->payload[i]; /* Lenght of the individual name blocks aaa.bbb.com */
 
 	if(name_len == 0) {
 	  tot_len++; /* \0 */
 	  /* End of query */
 	  break;
 	} else if((name_len & 0xC0) == 0xC0)
 	  is_ptr = 1, name_len = 0; /* Pointer */
 
 #ifdef DNS_DEBUG
 	if((!is_ptr) && (name_len > 0)) {
 	  printf("[DNS] [name_len: %u][", name_len);
 
 	  {
 	    int idx;
 
 	    for(idx=0; idx<name_len; idx++)
 	      printf("%c", packet->payload[i+1+idx]);
 
 	    printf("]\n");
 	  }
 	}
 #endif
 
 	i += name_len+1, tot_len += name_len+1;
 	if(is_ptr) break;
       } /* for */
 
 #ifdef DNS_DEBUG
       printf("[DNS] [tot_len: %u]\n\n", tot_len+4 /* type + class */);
 #endif
 
       if(((i+4 /* Skip query type and class */) > packet->payload_packet_len)
 	 || ((packet->payload[i+1] == 0x0) && (packet->payload[i+2] == 0x0)) /* Query type cannot be 0 */
 	 || (tot_len > 253)
 	 ) {
 	/* Invalid */
 #ifdef DNS_DEBUG
 	printf("[DNS] Invalid query len [%u >= %u]\n", i+4, packet->payload_packet_len);
 #endif
 	ndpi_set_risk(ndpi_struct, flow, NDPI_MALFORMED_PACKET, "Invalid DNS Query Lenght");
 	break;
       } else {
 	idx = i+5, num_queries++;
       }
     } /* for */
 
     u_int8_t hostname_is_valid = ndpi_grab_dns_name(packet, &off, _hostname, sizeof(_hostname), &len, is_mdns);
 
     ndpi_hostname_sni_set(flow, (const u_int8_t *)_hostname, len);
 
     if (hostname_is_valid == 0)
       ndpi_set_risk(ndpi_struct, flow, NDPI_INVALID_CHARACTERS, NULL);
 
     dot = strchr(_hostname, '.');
     if(dot) {
-      unsigned long first_element_len = (unsigned long)dot - (unsigned long)_hostname;
+      uintptr_t first_element_len = dot - _hostname;
 
       if(first_element_len > 32) {
 	/*
 	  The lenght of the first element in the query is very long
 	  and this might be an issue or indicate an exfiltration
 	*/
 
 	/* printf("**** %lu [%s][%s]\n", first_element_len, dot, _hostname); */
 	ndpi_set_risk(ndpi_struct, flow, NDPI_DNS_SUSPICIOUS_TRAFFIC, NULL);
       }
     }
     
     if(len > 0) {
       ndpi_protocol_match_result ret_match;
 
       ret.app_protocol = ndpi_match_host_subprotocol(ndpi_struct, flow,
 						     flow->host_server_name,
 						     strlen(flow->host_server_name),
 						     &ret_match,
 						     NDPI_PROTOCOL_DNS);
 
       /* Category is always NDPI_PROTOCOL_CATEGORY_NETWORK, regardless of the subprotocol */
       flow->category = NDPI_PROTOCOL_CATEGORY_NETWORK;
 
       if(ret.app_protocol == NDPI_PROTOCOL_UNKNOWN)
 	ret.master_protocol = checkDNSSubprotocol(s_port, d_port);
       else
 	ret.master_protocol = NDPI_PROTOCOL_DNS;
 
       ndpi_check_dga_name(ndpi_struct, flow, flow->host_server_name, 1, 0);
     }
 
     /* Report if this is a DNS query or reply */
     flow->protos.dns.is_query = is_query;
 
     if(is_query) {
       /* In this case we say that the protocol has been detected just to let apps carry on with their activities */
       ndpi_set_detected_protocol(ndpi_struct, flow, ret.app_protocol, ret.master_protocol, NDPI_CONFIDENCE_DPI);
 
       /* We have never triggered extra-dissection for LLMNR. Keep the old behaviour */
       if(ret.master_protocol != NDPI_PROTOCOL_LLMNR) {
         /* Don't use just 1 as in TCP DNS more packets could be returned (e.g. ACK). */
         flow->max_extra_packets_to_check = 5;
         flow->extra_packets_func = search_dns_again;
       }
       return; /* The response will set the verdict */
     }
 
     flow->protos.dns.num_queries = (u_int8_t)dns_header.num_queries,
       flow->protos.dns.num_answers = (u_int8_t) (dns_header.num_answers + dns_header.authority_rrs + dns_header.additional_rrs);
 
 #ifdef DNS_DEBUG
     NDPI_LOG_DBG2(ndpi_struct, "[num_queries=%d][num_answers=%d][reply_code=%u][rsp_type=%u][host_server_name=%s]\n",
 		  flow->protos.dns.num_queries, flow->protos.dns.num_answers,
 		  flow->protos.dns.reply_code, flow->protos.dns.rsp_type, flow->host_server_name
 		  );
 #endif
 
     if(flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {
       /**
 	 Do not set the protocol with DNS if ndpi_match_host_subprotocol() has
 	 matched a subprotocol
       **/
       NDPI_LOG_INFO(ndpi_struct, "found DNS\n");
       ndpi_set_detected_protocol(ndpi_struct, flow, ret.app_protocol, ret.master_protocol, NDPI_CONFIDENCE_DPI);
     } else {
       if((flow->detected_protocol_stack[0] == NDPI_PROTOCOL_DNS)
 	 || (flow->detected_protocol_stack[1] == NDPI_PROTOCOL_DNS))
 	;
       else
 	NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
     }
   }
 
   if(flow->packet_counter > 3)
     NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
 
   if((flow->detected_protocol_stack[0] == NDPI_PROTOCOL_DNS)
      || (flow->detected_protocol_stack[1] == NDPI_PROTOCOL_DNS)) {
     /* TODO: add support to RFC6891 to avoid some false positives */
     if((packet->udp != NULL)
        && (packet->payload_packet_len > PKT_LEN_ALERT)
        && (packet->payload_packet_len > flow->protos.dns.edns0_udp_payload_size)
        ) {
       char str[48];
 
       snprintf(str, sizeof(str), "%u Bytes DNS Packet", packet->payload_packet_len);
       ndpi_set_risk(ndpi_struct, flow, NDPI_DNS_LARGE_PACKET, str);
     }
 
     if(packet->iph != NULL) {
       /* IPv4 */
       u_int8_t flags = ((u_int8_t*)packet->iph)[6];
 
       /* 0: fragmented; 1: not fragmented */
       if((flags & 0x20)
 	 || (ndpi_iph_is_valid_and_not_fragmented(packet->iph, packet->l3_packet_len) == 0)) {
 	ndpi_set_risk(ndpi_struct, flow, NDPI_DNS_FRAGMENTED, NULL);
       }
     } else if(packet->iphv6 != NULL) {
       /* IPv6 */
       const struct ndpi_ip6_hdrctl *ip6_hdr = &packet->iphv6->ip6_hdr;
 
       if(ip6_hdr->ip6_un1_nxt == 0x2C /* Next Header: Fragment Header for IPv6 (44) */) {
 	ndpi_set_risk(ndpi_struct, flow, NDPI_DNS_FRAGMENTED, NULL);
       }
     }
   }
 }
 
 /* *********************************************** */
diff --git a/src/lib/third_party/include/binaryfusefilter.h b/src/lib/third_party/include/binaryfusefilter.h
index 991e28c6..6e2498ba 100644
--- a/src/lib/third_party/include/binaryfusefilter.h
+++ b/src/lib/third_party/include/binaryfusefilter.h
@@ -155,12 +155,12 @@ static inline binary_hashes_t binary_fuse8_hash_batch(uint64_t hash,
 static inline uint32_t binary_fuse8_hash(int index, uint64_t hash,
                                         const binary_fuse8_t *filter) {
     uint64_t h = binary_fuse_mulhi(hash, filter->SegmentCountLength);
     h += index * filter->SegmentLength;
     // keep the lower 36 bits
-    uint64_t hh = hash & ((1UL << 36) - 1);
+    uint64_t hh = hash & ((1ULL << 36) - 1);
     // index 0: right shift by 36; index 1: right shift by 18; index 2: no shift
     h ^= (size_t)((hh >> (36 - 18 * index)) & filter->SegmentLengthMask);
     return h;
 }
 
 // Report if the key is in the set, with false positive rate.
@@ -465,22 +465,22 @@ static inline binary_hashes_t binary_fuse16_hash_batch(uint64_t hash,
                                         const binary_fuse16_t *filter) {
   uint64_t hi = binary_fuse_mulhi(hash, filter->SegmentCountLength);
   binary_hashes_t ans;
   ans.h0 = (uint32_t)hi;
   ans.h1 = ans.h0 + filter->SegmentLength;
   ans.h2 = ans.h1 + filter->SegmentLength;
   ans.h1 ^= (uint32_t)(hash >> 18) & filter->SegmentLengthMask;
   ans.h2 ^= (uint32_t)(hash)&filter->SegmentLengthMask;
   return ans;
 }
 static inline uint32_t binary_fuse16_hash(int index, uint64_t hash,
                                         const binary_fuse16_t *filter) {
     uint64_t h = binary_fuse_mulhi(hash, filter->SegmentCountLength);
     h += index * filter->SegmentLength;
     // keep the lower 36 bits
-    uint64_t hh = hash & ((1UL << 36) - 1);
+    uint64_t hh = hash & ((1ULL << 36) - 1);
     // index 0: right shift by 36; index 1: right shift by 18; index 2: no shift
     h ^= (size_t)((hh >> (36 - 18 * index)) & filter->SegmentLengthMask);
     return h;
 }
 
 // Report if the key is in the set, with false positive rate.
@@ -498,32 +498,32 @@ static inline bool binary_fuse16_contain(uint64_t key,
 // allocate enough capacity for a set containing up to 'size' elements
 // caller is responsible to call binary_fuse16_free(filter)
 // size should be at least 2.
 static inline bool binary_fuse16_allocate(uint32_t size,
                                          binary_fuse16_t *filter) {
   uint32_t arity = 3;
   filter->SegmentLength = size == 0 ? 4 : binary_fuse_calculate_segment_length(arity, size);
   if (filter->SegmentLength > 262144) {
     filter->SegmentLength = 262144;
   }
   filter->SegmentLengthMask = filter->SegmentLength - 1;
   double sizeFactor = size <= 1 ? 0 : binary_fuse_calculate_size_factor(arity, size);
   uint32_t capacity = (uint32_t)(round((double)size * sizeFactor));
   uint32_t initSegmentCount =
       (capacity + filter->SegmentLength - 1) / filter->SegmentLength -
       (arity - 1);
   filter->ArrayLength = (initSegmentCount + arity - 1) * filter->SegmentLength;
   filter->SegmentCount =
       (filter->ArrayLength + filter->SegmentLength - 1) / filter->SegmentLength;
   if (filter->SegmentCount <= arity - 1) {
     filter->SegmentCount = 1;
   } else {
     filter->SegmentCount = filter->SegmentCount - (arity - 1);
   }
   filter->ArrayLength =
       (filter->SegmentCount + arity - 1) * filter->SegmentLength;
   filter->SegmentCountLength = filter->SegmentCount * filter->SegmentLength;
-  filter->Fingerprints = (uint16_t*)ndpi_malloc(filter->ArrayLength * sizeof(uint16_t));
+  filter->Fingerprints = (uint16_t*)ndpi_calloc(filter->ArrayLength, sizeof(uint16_t));
   return filter->Fingerprints != NULL;
 }
 
 // report memory usage
diff --git a/tests/cfgs/default/pcap/bets.pcapng b/tests/cfgs/default/pcap/bets.pcapng
index 090cf6f2..0246e757 100644
Binary files a/tests/cfgs/default/pcap/bets.pcapng and b/tests/cfgs/default/pcap/bets.pcapng differ
diff --git a/tests/cfgs/default/pcap/opera-vpn.pcapng b/tests/cfgs/default/pcap/opera-vpn.pcapng
index b6bcfa24..cb05c254 100644
Binary files a/tests/cfgs/default/pcap/opera-vpn.pcapng and b/tests/cfgs/default/pcap/opera-vpn.pcapng differ
diff --git a/tests/cfgs/default/result/dns2tcp_tunnel.pcap.out b/tests/cfgs/default/result/dns2tcp_tunnel.pcap.out
new file mode 100644
index 00000000..20b1d520
--- /dev/null
+++ b/tests/cfgs/default/result/dns2tcp_tunnel.pcap.out
@@ -0,0 +1,30 @@
+Guessed flow protos:	0
+
+DPI Packets (TCP):	6	(6.00 pkts/flow)
+Confidence DPI              : 1 (flows)
+Num dissector calls: 1 (1.00 diss/flow)
+LRU cache ookla:      0/0/0 (insert/search/found)
+LRU cache bittorrent: 0/0/0 (insert/search/found)
+LRU cache zoom:       0/0/0 (insert/search/found)
+LRU cache stun:       0/0/0 (insert/search/found)
+LRU cache tls_cert:   0/2/0 (insert/search/found)
+LRU cache mining:     0/0/0 (insert/search/found)
+LRU cache msteams:    0/0/0 (insert/search/found)
+LRU cache stun_zoom:  0/0/0 (insert/search/found)
+Automa host:          0/0 (search/found)
+Automa domain:        0/0 (search/found)
+Automa tls cert:      0/0 (search/found)
+Automa risk mask:     0/0 (search/found)
+Automa common alpns:  2/2 (search/found)
+Patricia risk mask:   2/0 (search/found)
+Patricia risk:        0/0 (search/found)
+Patricia protocols:   2/0 (search/found)
+
+TLS	50	8960	1
+
+JA3 Host Stats: 
+		 IP Address                  	 # JA3C     
+	1	 192.168.20.211           	 1      
+
+
+	1	TCP 192.168.20.211:44404 <-> 1.1.1.1:443 [proto: 91/TLS][IP: 0/Unknown][Encrypted][Confidence: DPI][DPI packets: 6][cat: Web/5][22 pkts/2595 bytes <-> 28 pkts/6365 bytes][Goodput ratio: 52/74][8.11 sec][(Advertised) ALPNs: h2;http/1.1][TLS Supported Versions: TLSv1.3;TLSv1.2][bytes ratio: -0.421 (Download)][IAT c2s/s2c min/avg/max/stddev: 0/0 289/346 3093/3078 792/900][Pkt Len c2s/s2c min/avg/max/stddev: 56/62 118/227 317/1644 68/386][Risk: ** Missing SNI TLS Extn **** ALPN/SNI Mismatch **][Risk Score: 100][TLSv1.3][JA3C: 547df21d727c7b3a5dcb59aa0fd97c2c][JA3S: eb1d94daa7e0344597e756a1fb6e7054][Firefox][Cipher: TLS_AES_128_GCM_SHA256][Plen Bins: 26,0,11,26,0,3,14,0,7,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,3]
diff --git a/windows/nDPI.vcxproj b/windows/nDPI.vcxproj
index 3f2299c0..5dca751c 100644
--- a/windows/nDPI.vcxproj
+++ b/windows/nDPI.vcxproj
@@ -1,398 +1,402 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
 <Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <ItemGroup Label="ProjectConfigurations">
     <ProjectConfiguration Include="Debug-ndpiReader|x64">
       <Configuration>Debug-ndpiReader</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="Debug|x64">
       <Configuration>Debug</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
   </ItemGroup>
   <PropertyGroup Label="Globals">
     <ProjectGuid>{7331961B-A2B5-45B1-B144-AFDEFBB0EB01}</ProjectGuid>
     <RootNamespace>nDPIdev</RootNamespace>
     <Keyword>Win32Proj</Keyword>
     <ProjectName>nDPI</ProjectName>
     <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
     <ConfigurationType>DynamicLibrary</ConfigurationType>
     <PlatformToolset>v142</PlatformToolset>
     <CharacterSet>NotSet</CharacterSet>
     <SpectreMitigation>false</SpectreMitigation>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug-ndpiReader|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <PlatformToolset>v142</PlatformToolset>
     <CharacterSet>NotSet</CharacterSet>
     <SpectreMitigation>false</SpectreMitigation>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
   <ImportGroup Label="ExtensionSettings">
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug-ndpiReader|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
   <PropertyGroup Label="UserMacros" />
   <PropertyGroup>
     <_ProjectFileVersion>11.0.50727.1</_ProjectFileVersion>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <LinkIncremental>true</LinkIncremental>
     <IntDir>$(SolutionDir)obj\$(ProjectName)_$(Configuration)_$(Platform)\</IntDir>
     <OutDir>$(ProjectDir)bin\$(Platform)_$(Configuration)\</OutDir>
     <IncludePath>$(IncludePath)</IncludePath>
     <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
     <Linkage-pthreads>static</Linkage-pthreads>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug-ndpiReader|x64'">
     <LinkIncremental>true</LinkIncremental>
     <IntDir>$(SolutionDir)obj\$(ProjectName)_$(Configuration)_$(Platform)\</IntDir>
     <OutDir>$(ProjectDir)bin\$(Platform)_$(Configuration)\</OutDir>
     <IncludePath>$(IncludePath)</IncludePath>
     <TargetName>ndpiReader</TargetName>
     <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
     <Linkage-pthreads>static</Linkage-pthreads>
   </PropertyGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <ClCompile>
       <Optimization>Disabled</Optimization>
       <AdditionalIncludeDirectories>$(ProjectDir)src\;$(ProjectDir)..\src\lib\protocols\;$(ProjectDir)..\src\include\;$(ProjectDir)..\;$(ProjectDir)..\src\lib\third_party\include\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
       <PreprocessorDefinitions>NDPI_LIB_COMPILATION;WIN32;_WIN64;_DEBUG;_WINDOWS;_CRT_SECURE_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <BasicRuntimeChecks>Default</BasicRuntimeChecks>
       <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
       <PrecompiledHeader>
       </PrecompiledHeader>
       <WarningLevel>Level3</WarningLevel>
       <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
       <StringPooling>false</StringPooling>
       <ProgramDataBaseFileName>$(TargetDir)$(TargetName).pdb</ProgramDataBaseFileName>
       <ExceptionHandling>false</ExceptionHandling>
       <MultiProcessorCompilation>true</MultiProcessorCompilation>
       <AdditionalUsingDirectories>$(ProjectDir);%(AdditionalUsingDirectories)</AdditionalUsingDirectories>
       <LanguageStandard_C>Default</LanguageStandard_C>
     </ClCompile>
     <Link>
       <GenerateDebugInformation>true</GenerateDebugInformation>
       <SubSystem>Windows</SubSystem>
       <AdditionalDependencies>Ws2_32.lib;%(AdditionalDependencies)</AdditionalDependencies>
       <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
       <AssemblyDebug>true</AssemblyDebug>
     </Link>
     <PostBuildEvent>
     </PostBuildEvent>
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug-ndpiReader|x64'">
     <ClCompile>
       <Optimization>Disabled</Optimization>
       <AdditionalIncludeDirectories>$(ProjectDir)src\;$(ProjectDir)..\src\lib\protocols\;$(ProjectDir)..\src\include\;$(ProjectDir)..\;$(ProjectDir)..\src\lib\third_party\include\;$(ProjectDir)..\windows\WpdPack\Include\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
       <PreprocessorDefinitions>PTW32_STATIC_LIB;STATIC_GETOPT;NDPI_LIB_COMPILATION;HAVE_STRUCT_TIMESPEC;WIN32;_WIN64;_DEBUG;_WINDOWS;_CRT_SECURE_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <BasicRuntimeChecks>Default</BasicRuntimeChecks>
       <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
       <PrecompiledHeader>
       </PrecompiledHeader>
       <WarningLevel>Level3</WarningLevel>
       <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
       <StringPooling>false</StringPooling>
       <ProgramDataBaseFileName>$(TargetDir)$(TargetName).pdb</ProgramDataBaseFileName>
       <ExceptionHandling>false</ExceptionHandling>
       <MultiProcessorCompilation>true</MultiProcessorCompilation>
       <AdditionalUsingDirectories>$(ProjectDir);%(AdditionalUsingDirectories)</AdditionalUsingDirectories>
       <LanguageStandard_C>Default</LanguageStandard_C>
     </ClCompile>
     <Link>
       <GenerateDebugInformation>true</GenerateDebugInformation>
       <SubSystem>Windows</SubSystem>
       <AdditionalDependencies>$(ProjectDir)..\windows\packages\pthreads.2.9.1.4\build\native\lib\v110\x64\Debug\static\cdecl\libpthread-static.lib;Ws2_32.lib;$(ProjectDir)..\windows\WpdPack\Lib\x64\wpcap.lib;%(AdditionalDependencies)</AdditionalDependencies>
       <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
       <AssemblyDebug>true</AssemblyDebug>
     </Link>
     <PostBuildEvent />
   </ItemDefinitionGroup>
   <ItemGroup>
     <ClCompile Include="..\example\ndpiReader.c">
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\example\reader_util.c">
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\src\lib\ndpi_analyze.c" />
     <ClCompile Include="..\src\lib\ndpi_bitmap.c" />
     <ClCompile Include="..\src\lib\ndpi_classify.c" />
     <ClCompile Include="..\src\lib\ndpi_community_id.c" />
-    <ClCompile Include="..\src\lib\ndpi_domain_classify.c" />
     <ClCompile Include="..\src\lib\ndpi_geoip.c" />
     <ClCompile Include="..\src\lib\ndpi_main.c" />
     <ClCompile Include="..\src\lib\ndpi_filter.c" />
     <ClCompile Include="..\src\lib\ndpi_memory.c" />
     <ClCompile Include="..\src\lib\ndpi_serializer.c" />
     <ClCompile Include="..\src\lib\ndpi_utils.c" />
+    <ClCompile Include="..\src\lib\ndpi_binary_bitmap.c" />
+    <ClCompile Include="..\src\lib\ndpi_hash.c" />
+    <ClCompile Include="..\src\lib\ndpi_domain_classify.c" />
+    <ClCompile Include="..\src\lib\ndpi_bitmap64.c" />
     <ClCompile Include="..\src\lib\protocols\activision.c" />
     <ClCompile Include="..\src\lib\protocols\afp.c" />
     <ClCompile Include="..\src\lib\protocols\ajp.c" />
     <ClCompile Include="..\src\lib\protocols\alicloud.c" />
     <ClCompile Include="..\src\lib\protocols\amazon_video.c" />
     <ClCompile Include="..\src\lib\protocols\among_us.c" />
     <ClCompile Include="..\src\lib\protocols\amqp.c" />
     <ClCompile Include="..\src\lib\protocols\apple_push.c" />
     <ClCompile Include="..\src\lib\protocols\avast.c" />
     <ClCompile Include="..\src\lib\protocols\avast_securedns.c" />
     <ClCompile Include="..\src\lib\protocols\bacnet.c" />
     <ClCompile Include="..\src\lib\protocols\bitcoin.c" />
     <ClCompile Include="..\src\lib\protocols\bjnp.c" />
     <ClCompile Include="..\src\lib\protocols\capwap.c" />
     <ClCompile Include="..\src\lib\protocols\cassandra.c" />
     <ClCompile Include="..\src\lib\protocols\checkmk.c" />
     <ClCompile Include="..\src\lib\protocols\collectd.c" />
     <ClCompile Include="..\src\lib\protocols\cpha.c" />
     <ClCompile Include="..\src\lib\protocols\crynet.c" />
     <ClCompile Include="..\src\lib\protocols\csgo.c" />
     <ClCompile Include="..\src\lib\protocols\diameter.c" />
     <ClCompile Include="..\src\lib\protocols\discord.c" />
     <ClCompile Include="..\src\lib\protocols\dnp3.c" />
     <ClCompile Include="..\src\lib\protocols\dnscrypt.c" />
     <ClCompile Include="..\src\lib\protocols\elastic_search.c" />
     <ClCompile Include="..\src\lib\protocols\ethernet_ip.c" />
     <ClCompile Include="..\src\lib\protocols\epicgames.c" />
     <ClCompile Include="..\src\lib\protocols\fastcgi.c" />
     <ClCompile Include="..\src\lib\protocols\fix.c" />
     <ClCompile Include="..\src\lib\protocols\genshin_impact.c" />
     <ClCompile Include="..\src\lib\protocols\hpvirtgrp.c" />
     <ClCompile Include="..\src\lib\protocols\hsrp.c" />
     <ClCompile Include="..\src\lib\protocols\i3d.c" />
     <ClCompile Include="..\src\lib\protocols\iec60870-5-104.c" />
     <ClCompile Include="..\src\lib\protocols\imo.c" />
     <ClCompile Include="..\src\lib\protocols\ipsec.c" />
     <ClCompile Include="..\src\lib\protocols\kismet.c" />
     <ClCompile Include="..\src\lib\protocols\line.c" />
     <ClCompile Include="..\src\lib\protocols\lisp.c" />
     <ClCompile Include="..\src\lib\protocols\memcached.c" />
     <ClCompile Include="..\src\lib\protocols\merakicloud.c" />
     <ClCompile Include="..\src\lib\protocols\mining.c" />
     <ClCompile Include="..\src\lib\protocols\modbus.c" />
     <ClCompile Include="..\src\lib\protocols\mongodb.c" />
     <ClCompile Include="..\src\lib\protocols\mpegdash.c" />
     <ClCompile Include="..\src\lib\protocols\natpmp.c" />
     <ClCompile Include="..\src\lib\protocols\nats.c" />
     <ClCompile Include="..\src\lib\protocols\nest_log_sink.c" />
     <ClCompile Include="..\src\lib\protocols\nintendo.c" />
     <ClCompile Include="..\src\lib\protocols\ookla.c" />
     <ClCompile Include="..\src\lib\protocols\raknet.c" />
     <ClCompile Include="..\src\lib\protocols\riotgames.c" />
     <ClCompile Include="..\src\lib\protocols\rsh.c" />
     <ClCompile Include="..\src\lib\protocols\s7comm.c" />
     <ClCompile Include="..\src\lib\protocols\sd_rtn.c" />
     <ClCompile Include="..\src\lib\protocols\smpp.c" />
     <ClCompile Include="..\src\lib\protocols\snmp_proto.c" />
     <ClCompile Include="..\src\lib\protocols\soap.c" />
     <ClCompile Include="..\src\lib\protocols\softether.c" />
     <ClCompile Include="..\src\lib\protocols\someip.c" />
     <ClCompile Include="..\src\lib\protocols\syncthing.c" />
     <ClCompile Include="..\src\lib\protocols\threema.c" />
     <ClCompile Include="..\src\lib\protocols\tinc.c" />
     <ClCompile Include="..\src\lib\protocols\tivoconnect.c" />
     <ClCompile Include="..\src\lib\protocols\tls.c" />
     <ClCompile Include="..\src\lib\protocols\tocaboca.c" />
     <ClCompile Include="..\src\lib\protocols\ultrasurf.c" />
     <ClCompile Include="..\src\lib\protocols\vxlan.c" />
     <ClCompile Include="..\src\lib\protocols\websocket.c" />
     <ClCompile Include="..\src\lib\protocols\whatsapp.c" />
     <ClCompile Include="..\src\lib\protocols\wireguard.c" />
     <ClCompile Include="..\src\lib\protocols\wsd.c" />
     <ClCompile Include="..\src\lib\protocols\xiaomi.c" />
     <ClCompile Include="..\src\lib\protocols\z3950.c" />
     <ClCompile Include="..\src\lib\protocols\zabbix.c" />
     <ClCompile Include="..\src\lib\third_party\src\ahocorasick.c" />
     <ClCompile Include="..\src\lib\third_party\src\roaring.c" />
     <ClCompile Include="..\src\lib\protocols\armagetron.c" />
     <ClCompile Include="..\src\lib\protocols\bgp.c" />
     <ClCompile Include="..\src\lib\protocols\bittorrent.c" />
     <ClCompile Include="..\src\lib\protocols\btlib.c" />
     <ClCompile Include="..\src\lib\protocols\ciscovpn.c" />
     <ClCompile Include="..\src\lib\protocols\citrix.c" />
     <ClCompile Include="..\src\lib\protocols\coap.c" />
     <ClCompile Include="..\src\lib\protocols\corba.c" />
     <ClCompile Include="..\src\lib\protocols\crossfire.c" />
     <ClCompile Include="..\src\lib\protocols\dcerpc.c" />
     <ClCompile Include="..\src\lib\protocols\dhcp.c" />
     <ClCompile Include="..\src\lib\protocols\dhcpv6.c" />
     <ClCompile Include="..\src\lib\protocols\dns.c" />
     <ClCompile Include="..\src\lib\protocols\dofus.c" />
     <ClCompile Include="..\src\lib\protocols\drda.c" />
     <ClCompile Include="..\src\lib\protocols\dropbox.c" />
     <ClCompile Include="..\src\lib\protocols\eaq.c" />
     <ClCompile Include="..\src\lib\protocols\edonkey.c" />
     <ClCompile Include="..\src\lib\protocols\ftp_control.c" />
     <ClCompile Include="..\src\lib\protocols\ftp_data.c" />
     <ClCompile Include="..\src\lib\protocols\git.c" />
     <ClCompile Include="..\src\lib\protocols\gnutella.c" />
     <ClCompile Include="..\src\lib\protocols\gtp.c" />
     <ClCompile Include="..\src\lib\protocols\guildwars.c" />
     <ClCompile Include="..\src\lib\protocols\h323.c" />
     <ClCompile Include="..\src\lib\protocols\halflife2_and_mods.c" />
     <ClCompile Include="..\src\lib\protocols\hots.c" />
     <ClCompile Include="..\src\lib\protocols\http.c" />
     <ClCompile Include="..\src\lib\protocols\iax.c" />
     <ClCompile Include="..\src\lib\protocols\icecast.c" />
     <ClCompile Include="..\src\lib\protocols\ipp.c" />
     <ClCompile Include="..\src\lib\protocols\irc.c" />
     <ClCompile Include="..\src\lib\protocols\jabber.c" />
     <ClCompile Include="..\src\lib\protocols\kakaotalk_voice.c" />
     <ClCompile Include="..\src\lib\protocols\kerberos.c" />
     <ClCompile Include="..\src\lib\protocols\kontiki.c" />
     <ClCompile Include="..\src\lib\protocols\ldap.c" />
     <ClCompile Include="..\src\lib\protocols\lotus_notes.c" />
     <ClCompile Include="..\src\lib\protocols\mail_imap.c" />
     <ClCompile Include="..\src\lib\protocols\mail_pop.c" />
     <ClCompile Include="..\src\lib\protocols\mail_smtp.c" />
     <ClCompile Include="..\src\lib\protocols\maplestory.c" />
     <ClCompile Include="..\src\lib\protocols\megaco.c" />
     <ClCompile Include="..\src\lib\protocols\mgcp.c" />
     <ClCompile Include="..\src\lib\protocols\mpegts.c" />
     <ClCompile Include="..\src\lib\protocols\mqtt.c" />
     <ClCompile Include="..\src\lib\protocols\mssql_tds.c" />
     <ClCompile Include="..\src\lib\protocols\munin.c" />
     <ClCompile Include="..\src\lib\protocols\mysql.c" />
     <ClCompile Include="..\src\lib\protocols\netbios.c" />
     <ClCompile Include="..\src\lib\protocols\netflow.c" />
     <ClCompile Include="..\src\lib\protocols\nfs.c" />
     <ClCompile Include="..\src\lib\protocols\noe.c" />
     <ClCompile Include="..\src\lib\protocols\non_tcp_udp.c" />
     <ClCompile Include="..\src\lib\protocols\ntp.c" />
     <ClCompile Include="..\src\lib\protocols\oicq.c" />
     <ClCompile Include="..\src\lib\protocols\openvpn.c" />
     <ClCompile Include="..\src\lib\protocols\oracle.c" />
     <ClCompile Include="..\src\lib\protocols\postgres.c" />
     <ClCompile Include="..\src\lib\protocols\ppstream.c" />
     <ClCompile Include="..\src\lib\protocols\pptp.c" />
     <ClCompile Include="..\src\lib\protocols\qq.c" />
     <ClCompile Include="..\src\lib\protocols\quic.c" />
     <ClCompile Include="..\src\lib\protocols\radius.c" />
     <ClCompile Include="..\src\lib\protocols\rdp.c" />
     <ClCompile Include="..\src\lib\protocols\redis_net.c" />
     <ClCompile Include="..\src\lib\protocols\rsync.c" />
     <ClCompile Include="..\src\lib\protocols\rtcp.c" />
     <ClCompile Include="..\src\lib\protocols\rtmp.c" />
     <ClCompile Include="..\src\lib\protocols\rtp.c" />
     <ClCompile Include="..\src\lib\protocols\rtsp.c" />
     <ClCompile Include="..\src\lib\protocols\rx.c" />
     <ClCompile Include="..\src\lib\protocols\sflow.c" />
     <ClCompile Include="..\src\lib\protocols\sip.c" />
     <ClCompile Include="..\src\lib\protocols\skinny.c" />
     <ClCompile Include="..\src\lib\protocols\skype.c" />
     <ClCompile Include="..\src\lib\protocols\slp.c" />
     <ClCompile Include="..\src\lib\protocols\smb.c" />
     <ClCompile Include="..\src\lib\protocols\socks45.c" />
     <ClCompile Include="..\src\lib\protocols\source_engine.c" />
     <ClCompile Include="..\src\lib\protocols\spotify.c" />
     <ClCompile Include="..\src\lib\protocols\ssdp.c" />
     <ClCompile Include="..\src\lib\protocols\ssh.c" />
     <ClCompile Include="..\src\lib\protocols\starcraft.c" />
     <ClCompile Include="..\src\lib\protocols\steam.c" />
     <ClCompile Include="..\src\lib\protocols\stun.c" />
     <ClCompile Include="..\src\lib\protocols\syslog.c" />
     <ClCompile Include="..\src\lib\protocols\tailscale.c" />
     <ClCompile Include="..\src\lib\protocols\tcp_udp.c" />
     <ClCompile Include="..\src\lib\protocols\teamspeak.c" />
     <ClCompile Include="..\src\lib\protocols\teamviewer.c" />
     <ClCompile Include="..\src\lib\protocols\telegram.c" />
     <ClCompile Include="..\src\lib\protocols\telnet.c" />
     <ClCompile Include="..\src\lib\protocols\teredo.c" />
     <ClCompile Include="..\src\lib\protocols\tftp.c" />
     <ClCompile Include="..\src\lib\protocols\thrift.c" />
     <ClCompile Include="..\src\lib\protocols\tplink_shp.c" />
     <ClCompile Include="..\src\lib\protocols\tuya_lp.c" />
     <ClCompile Include="..\src\lib\protocols\tvuplayer.c" />
     <ClCompile Include="..\src\lib\protocols\ubntac2.c" />
     <ClCompile Include="..\src\lib\protocols\usenet.c" />
     <ClCompile Include="..\src\lib\protocols\vhua.c" />
     <ClCompile Include="..\src\lib\protocols\viber.c" />
     <ClCompile Include="..\src\lib\protocols\vmware.c" />
     <ClCompile Include="..\src\lib\protocols\vnc.c" />
     <ClCompile Include="..\src\lib\protocols\warcraft3.c" />
     <ClCompile Include="..\src\lib\protocols\whoisdas.c" />
     <ClCompile Include="..\src\lib\protocols\world_of_kung_fu.c" />
     <ClCompile Include="..\src\lib\protocols\world_of_warcraft.c" />
     <ClCompile Include="..\src\lib\protocols\xbox.c" />
     <ClCompile Include="..\src\lib\protocols\xdmcp.c" />
     <ClCompile Include="..\src\lib\protocols\zattoo.c" />
     <ClCompile Include="..\src\lib\protocols\zeromq.c" />
     <ClCompile Include="..\src\lib\third_party\src\gcrypt_light.c" />
     <ClCompile Include="..\src\lib\third_party\src\libcache.c" />
     <ClCompile Include="..\src\lib\third_party\src\libinjection_html5.c" />
     <ClCompile Include="..\src\lib\third_party\src\libinjection_sqli.c" />
     <ClCompile Include="..\src\lib\third_party\src\libinjection_xss.c" />
     <ClCompile Include="..\src\lib\third_party\src\ndpi_md5.c" />
     <ClCompile Include="..\src\lib\third_party\src\ndpi_patricia.c" />
     <ClCompile Include="..\src\lib\third_party\src\ndpi_sha1.c" />
     <ClCompile Include="..\src\lib\third_party\src\sha1-fast.c" />
     <ClCompile Include="..\src\lib\third_party\src\strptime.c" />
     <ClCompile Include="..\src\lib\third_party\src\hll\MurmurHash3.c" />
     <ClCompile Include="..\src\lib\third_party\src\hll\hll.c" />
     <ClCompile Include="src\getopt.c">
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="src\win-gettimeofday.c" />
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="..\example\reader_util.h">
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
     </ClInclude>
     <ClInclude Include="..\src\include\ndpi_encryption.h" />
     <ClInclude Include="..\src\include\ndpi_main.h" />
     <ClInclude Include="..\src\include\ndpi_patricia_typedefs.h" />
     <ClInclude Include="..\src\include\ndpi_utils.h" />
     <ClInclude Include="..\src\lib\protocols\btlib.h" />
     <ClInclude Include="..\src\lib\third_party\include\ahocorasick.h" />
     <ClInclude Include="..\src\include\ndpi_includes.h" />
     <ClInclude Include="..\src\lib\third_party\include\gcrypt_light.h" />
     <ClInclude Include="..\src\lib\third_party\include\hll.h" />
     <ClInclude Include="..\src\lib\third_party\include\libcache.h" />
     <ClInclude Include="..\src\lib\third_party\include\libinjection.h" />
     <ClInclude Include="..\src\lib\third_party\include\libinjection_html5.h" />
     <ClInclude Include="..\src\lib\third_party\include\libinjection_sqli.h" />
     <ClInclude Include="..\src\lib\third_party\include\libinjection_sqli_data.h" />
     <ClInclude Include="..\src\lib\third_party\include\libinjection_xss.h" />
     <ClInclude Include="..\src\lib\third_party\include\MurmurHash3.h" />
     <ClInclude Include="..\src\lib\third_party\include\ndpi_md5.h" />
     <ClInclude Include="..\src\lib\third_party\include\ndpi_patricia.h" />
     <ClInclude Include="..\src\include\ndpi_protocol_ids.h" />
     <ClInclude Include="..\src\include\ndpi_protocols.h" />
     <ClInclude Include="..\src\include\ndpi_typedefs.h" />
     <ClInclude Include="..\src\include\ndpi_unix.h" />
     <ClInclude Include="..\src\include\ndpi_win32.h" />
     <ClInclude Include="..\src\lib\third_party\include\ndpi_sha1.h" />
     <ClInclude Include="..\src\lib\third_party\include\rce_injection.h" />
     <ClInclude Include="..\src\lib\third_party\include\roaring.h" />
     <ClInclude Include="..\src\lib\third_party\include\uthash.h" />
     <ClInclude Include="arpa\inet.h" />
     <ClInclude Include="src\getopt.h">
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
     </ClInclude>
     <ClInclude Include="src\ndpi_config.h" />
     <ClInclude Include="src\ndpi_define.h" />
+    <ClInclude Include="src\dirent.h" />
   </ItemGroup>
   <ItemGroup>
     <None Include="..\.github\workflows\build-msbuild.yml" />
     <None Include="..\src\lib\ndpi_content_match.c.inc" />
     <None Include="packages.config" />
   </ItemGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
   <ImportGroup Label="ExtensionTargets">
     <Import Project="packages\pthreads.redist.2.9.1.4\build\native\pthreads.redist.targets" Condition="Exists('packages\pthreads.redist.2.9.1.4\build\native\pthreads.redist.targets')" />
     <Import Project="packages\pthreads.2.9.1.4\build\native\pthreads.targets" Condition="Exists('packages\pthreads.2.9.1.4\build\native\pthreads.targets')" />
   </ImportGroup>
   <Target Name="EnsureNuGetPackageBuildImports" BeforeTargets="PrepareForBuild">
     <PropertyGroup>
       <ErrorText>This project references NuGet package(s) that are missing on this computer. Use NuGet Package Restore to download them.  For more information, see http://go.microsoft.com/fwlink/?LinkID=322105. The missing file is {0}.</ErrorText>
     </PropertyGroup>
     <Error Condition="!Exists('packages\pthreads.redist.2.9.1.4\build\native\pthreads.redist.targets')" Text="$([System.String]::Format('$(ErrorText)', 'packages\pthreads.redist.2.9.1.4\build\native\pthreads.redist.targets'))" />
     <Error Condition="!Exists('packages\pthreads.2.9.1.4\build\native\pthreads.targets')" Text="$([System.String]::Format('$(ErrorText)', 'packages\pthreads.2.9.1.4\build\native\pthreads.targets'))" />
   </Target>
 </Project>
diff --git a/windows/nDPI.vcxproj.filters b/windows/nDPI.vcxproj.filters
index af43e8f1..27af4a9d 100644
--- a/windows/nDPI.vcxproj.filters
+++ b/windows/nDPI.vcxproj.filters
@@ -1,306 +1,311 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
 <Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <ItemGroup>
     <ClCompile Include="..\src\lib\protocols\afp.c" />
     <ClCompile Include="..\src\lib\protocols\bjnp.c" />
     <ClCompile Include="..\src\lib\protocols\armagetron.c" />
     <ClCompile Include="..\src\lib\protocols\bgp.c" />
     <ClCompile Include="..\src\lib\protocols\bitcoin.c" />
     <ClCompile Include="..\src\lib\protocols\bittorrent.c" />
     <ClCompile Include="..\src\lib\protocols\btlib.c" />
     <ClCompile Include="..\src\lib\protocols\ciscovpn.c" />
     <ClCompile Include="..\src\lib\protocols\citrix.c" />
     <ClCompile Include="..\src\lib\protocols\coap.c" />
     <ClCompile Include="..\src\lib\protocols\corba.c" />
     <ClCompile Include="..\src\lib\protocols\crossfire.c" />
     <ClCompile Include="..\src\lib\protocols\dcerpc.c" />
     <ClCompile Include="..\src\lib\protocols\dhcp.c" />
     <ClCompile Include="..\src\lib\protocols\dhcpv6.c" />
     <ClCompile Include="..\src\lib\protocols\dns.c" />
     <ClCompile Include="..\src\lib\protocols\dofus.c" />
     <ClCompile Include="..\src\lib\protocols\drda.c" />
     <ClCompile Include="..\src\lib\protocols\dropbox.c" />
     <ClCompile Include="..\src\lib\protocols\eaq.c" />
     <ClCompile Include="..\src\lib\protocols\edonkey.c" />
     <ClCompile Include="..\src\lib\protocols\epicgames.c" />
     <ClCompile Include="..\src\lib\protocols\ftp_control.c" />
     <ClCompile Include="..\src\lib\protocols\ftp_data.c" />
     <ClCompile Include="..\src\lib\protocols\git.c" />
     <ClCompile Include="..\src\lib\protocols\gnutella.c" />
     <ClCompile Include="..\src\lib\protocols\gtp.c" />
     <ClCompile Include="..\src\lib\protocols\guildwars.c" />
     <ClCompile Include="..\src\lib\protocols\h323.c" />
     <ClCompile Include="..\src\lib\protocols\halflife2_and_mods.c" />
     <ClCompile Include="..\src\lib\protocols\http.c" />
     <ClCompile Include="..\src\lib\protocols\iax.c" />
     <ClCompile Include="..\src\lib\protocols\icecast.c" />
     <ClCompile Include="..\src\lib\protocols\ipp.c" />
     <ClCompile Include="..\src\lib\protocols\irc.c" />
     <ClCompile Include="..\src\lib\protocols\jabber.c" />
     <ClCompile Include="..\src\lib\protocols\kakaotalk_voice.c" />
     <ClCompile Include="..\src\lib\protocols\kerberos.c" />
     <ClCompile Include="..\src\lib\protocols\kontiki.c" />
     <ClCompile Include="..\src\lib\protocols\ldap.c" />
     <ClCompile Include="..\src\lib\protocols\lotus_notes.c" />
     <ClCompile Include="..\src\lib\protocols\mail_imap.c" />
     <ClCompile Include="..\src\lib\protocols\mail_pop.c" />
     <ClCompile Include="..\src\lib\protocols\mail_smtp.c" />
     <ClCompile Include="..\src\lib\protocols\maplestory.c" />
     <ClCompile Include="..\src\lib\protocols\megaco.c" />
     <ClCompile Include="..\src\lib\protocols\mgcp.c" />
     <ClCompile Include="..\src\lib\protocols\mpegts.c" />
     <ClCompile Include="..\src\lib\protocols\mqtt.c" />
     <ClCompile Include="..\src\lib\protocols\mssql_tds.c" />
     <ClCompile Include="..\src\lib\protocols\mysql.c" />
     <ClCompile Include="..\src\lib\protocols\netbios.c" />
     <ClCompile Include="..\src\lib\protocols\netflow.c" />
     <ClCompile Include="..\src\lib\protocols\nfs.c" />
     <ClCompile Include="..\src\lib\protocols\noe.c" />
     <ClCompile Include="..\src\lib\protocols\non_tcp_udp.c" />
     <ClCompile Include="..\src\lib\protocols\ntp.c" />
     <ClCompile Include="..\src\lib\protocols\openvpn.c" />
     <ClCompile Include="..\src\lib\protocols\oracle.c" />
     <ClCompile Include="..\src\lib\protocols\postgres.c" />
     <ClCompile Include="..\src\lib\protocols\ppstream.c" />
     <ClCompile Include="..\src\lib\protocols\pptp.c" />
     <ClCompile Include="..\src\lib\protocols\qq.c" />
     <ClCompile Include="..\src\lib\protocols\quic.c" />
     <ClCompile Include="..\src\lib\protocols\radius.c" />
     <ClCompile Include="..\src\lib\protocols\rdp.c" />
     <ClCompile Include="..\src\lib\protocols\redis_net.c" />
     <ClCompile Include="..\src\lib\protocols\rsync.c" />
     <ClCompile Include="..\src\lib\protocols\rtcp.c" />
     <ClCompile Include="..\src\lib\protocols\rtmp.c" />
     <ClCompile Include="..\src\lib\protocols\rtp.c" />
     <ClCompile Include="..\src\lib\protocols\rtsp.c" />
     <ClCompile Include="..\src\lib\protocols\rx.c" />
     <ClCompile Include="..\src\lib\protocols\sflow.c" />
     <ClCompile Include="..\src\lib\protocols\sip.c" />
     <ClCompile Include="..\src\lib\protocols\skinny.c" />
     <ClCompile Include="..\src\lib\protocols\skype.c" />
     <ClCompile Include="..\src\lib\protocols\smb.c" />
     <ClCompile Include="..\src\lib\protocols\socks45.c" />
     <ClCompile Include="..\src\lib\protocols\spotify.c" />
     <ClCompile Include="..\src\lib\protocols\ssdp.c" />
     <ClCompile Include="..\src\lib\protocols\ssh.c" />
     <ClCompile Include="..\src\lib\protocols\starcraft.c" />
     <ClCompile Include="..\src\lib\protocols\steam.c" />
     <ClCompile Include="..\src\lib\protocols\stun.c" />
     <ClCompile Include="..\src\lib\protocols\syslog.c" />
     <ClCompile Include="..\src\lib\protocols\tailscale.c" />
     <ClCompile Include="..\src\lib\protocols\tcp_udp.c" />
     <ClCompile Include="..\src\lib\protocols\teamspeak.c" />
     <ClCompile Include="..\src\lib\protocols\teamviewer.c" />
     <ClCompile Include="..\src\lib\protocols\telegram.c" />
     <ClCompile Include="..\src\lib\protocols\telnet.c" />
     <ClCompile Include="..\src\lib\protocols\teredo.c" />
     <ClCompile Include="..\src\lib\protocols\tftp.c" />
     <ClCompile Include="..\src\lib\protocols\tplink_shp.c" />
     <ClCompile Include="..\src\lib\protocols\tuya_lp.c" />
     <ClCompile Include="..\src\lib\protocols\tvuplayer.c" />
     <ClCompile Include="..\src\lib\protocols\ubntac2.c" />
     <ClCompile Include="..\src\lib\protocols\usenet.c" />
     <ClCompile Include="..\src\lib\protocols\vhua.c" />
     <ClCompile Include="..\src\lib\protocols\viber.c" />
     <ClCompile Include="..\src\lib\protocols\vmware.c" />
     <ClCompile Include="..\src\lib\protocols\vnc.c" />
     <ClCompile Include="..\src\lib\protocols\warcraft3.c" />
     <ClCompile Include="..\src\lib\protocols\whoisdas.c" />
     <ClCompile Include="..\src\lib\protocols\world_of_kung_fu.c" />
     <ClCompile Include="..\src\lib\protocols\world_of_warcraft.c" />
     <ClCompile Include="..\src\lib\protocols\xbox.c" />
     <ClCompile Include="..\src\lib\protocols\xdmcp.c" />
     <ClCompile Include="..\src\lib\protocols\zattoo.c" />
     <ClCompile Include="..\src\lib\protocols\zeromq.c" />
     <ClCompile Include="src\getopt.c" />
     <ClCompile Include="src\win-gettimeofday.c" />
     <ClCompile Include="..\src\lib\ndpi_analyze.c" />
     <ClCompile Include="..\src\lib\ndpi_bitmap.c" />
     <ClCompile Include="..\src\lib\ndpi_classify.c" />
     <ClCompile Include="..\src\lib\ndpi_community_id.c" />
     <ClCompile Include="..\src\lib\ndpi_geoip.c" />
     <ClCompile Include="..\src\lib\ndpi_main.c" />
     <ClCompile Include="..\src\lib\ndpi_filter.c" />
     <ClCompile Include="..\src\lib\ndpi_memory.c" />
     <ClCompile Include="..\src\lib\ndpi_serializer.c" />
     <ClCompile Include="..\src\lib\ndpi_utils.c" />
+    <ClCompile Include="..\src\lib\ndpi_binary_bitmap.c" />
+    <ClCompile Include="..\src\lib\ndpi_hash.c" />
+    <ClCompile Include="..\src\lib\ndpi_domain_classify.c" />
+    <ClCompile Include="..\src\lib\ndpi_bitmap64.c" />
     <ClCompile Include="..\src\lib\protocols\ajp.c" />
     <ClCompile Include="..\src\lib\protocols\amazon_video.c" />
     <ClCompile Include="..\src\lib\protocols\among_us.c" />
     <ClCompile Include="..\src\lib\protocols\amqp.c" />
     <ClCompile Include="..\src\lib\protocols\apple_push.c" />
     <ClCompile Include="..\src\lib\protocols\avast_securedns.c" />
     <ClCompile Include="..\src\lib\protocols\capwap.c" />
     <ClCompile Include="..\src\lib\protocols\cassandra.c" />
     <ClCompile Include="..\src\lib\protocols\checkmk.c" />
     <ClCompile Include="..\src\lib\protocols\cpha.c" />
     <ClCompile Include="..\src\lib\protocols\csgo.c" />
     <ClCompile Include="..\src\lib\protocols\diameter.c" />
     <ClCompile Include="..\src\lib\protocols\dnp3.c" />
     <ClCompile Include="..\src\lib\protocols\dnscrypt.c" />
     <ClCompile Include="..\src\lib\protocols\ethernet_ip.c" />
     <ClCompile Include="..\src\lib\protocols\fix.c" />
     <ClCompile Include="..\src\lib\protocols\genshin_impact.c" />
     <ClCompile Include="..\src\lib\protocols\hpvirtgrp.c" />
     <ClCompile Include="..\src\lib\protocols\hsrp.c" />
     <ClCompile Include="..\src\lib\protocols\iec60870-5-104.c" />
     <ClCompile Include="..\src\lib\protocols\imo.c" />
     <ClCompile Include="..\src\lib\protocols\lisp.c" />
     <ClCompile Include="..\src\lib\protocols\memcached.c" />
     <ClCompile Include="..\src\lib\protocols\merakicloud.c" />
     <ClCompile Include="..\src\lib\protocols\mining.c" />
     <ClCompile Include="..\src\lib\protocols\modbus.c" />
     <ClCompile Include="..\src\lib\protocols\mongodb.c" />
     <ClCompile Include="..\src\lib\protocols\nats.c" />
     <ClCompile Include="..\src\lib\protocols\nest_log_sink.c" />
     <ClCompile Include="..\src\lib\protocols\nintendo.c" />
     <ClCompile Include="..\src\lib\protocols\ookla.c" />
     <ClCompile Include="..\src\lib\protocols\s7comm.c" />
     <ClCompile Include="..\src\lib\protocols\smpp.c" />
     <ClCompile Include="..\src\lib\protocols\snmp_proto.c" />
     <ClCompile Include="..\src\lib\protocols\soap.c" />
     <ClCompile Include="..\src\lib\protocols\someip.c" />
     <ClCompile Include="..\src\lib\protocols\tinc.c" />
     <ClCompile Include="..\src\lib\protocols\tls.c" />
     <ClCompile Include="..\src\lib\protocols\vxlan.c" />
     <ClCompile Include="..\src\lib\protocols\websocket.c" />
     <ClCompile Include="..\src\lib\protocols\whatsapp.c" />
     <ClCompile Include="..\src\lib\protocols\wireguard.c" />
     <ClCompile Include="..\src\lib\protocols\wsd.c" />
     <ClCompile Include="..\src\lib\protocols\z3950.c" />
     <ClCompile Include="..\src\lib\protocols\zabbix.c" />
     <ClCompile Include="..\src\lib\third_party\src\ahocorasick.c">
     <ClCompile Include="..\src\lib\third_party\src\roaring.c">
       <Filter>third_party</Filter>
     </ClCompile>
     <ClCompile Include="..\src\lib\third_party\src\ndpi_sha1.c">
       <Filter>third_party</Filter>
     </ClCompile>
     <ClCompile Include="..\src\lib\third_party\src\ndpi_patricia.c">
       <Filter>third_party</Filter>
     </ClCompile>
     <ClCompile Include="..\src\lib\third_party\src\ndpi_md5.c">
       <Filter>third_party</Filter>
     </ClCompile>
     <ClCompile Include="..\src\lib\third_party\src\gcrypt_light.c">
       <Filter>third_party</Filter>
     </ClCompile>
     <ClCompile Include="..\src\lib\third_party\src\libcache.c">
       <Filter>third_party</Filter>
     </ClCompile>
     <ClCompile Include="..\src\lib\third_party\src\libinjection_html5.c">
       <Filter>third_party</Filter>
     </ClCompile>
     <ClCompile Include="..\src\lib\third_party\src\libinjection_sqli.c">
       <Filter>third_party</Filter>
     </ClCompile>
     <ClCompile Include="..\src\lib\third_party\src\libinjection_xss.c">
       <Filter>third_party</Filter>
     </ClCompile>
     <ClCompile Include="..\src\lib\third_party\src\sha1-fast.c">
       <Filter>third_party</Filter>
     </ClCompile>
     <ClCompile Include="..\src\lib\third_party\src\strptime.c">
       <Filter>third_party</Filter>
     </ClCompile>
     <ClCompile Include="..\src\lib\third_party\src\hll\MurmurHash3.c" />
       <Filter>third_party</Filter>
     </ClCompile>
     <ClCompile Include="..\src\lib\third_party\src\hll\hll.c" />
       <Filter>third_party</Filter>
     </ClCompile>
     <ClCompile Include="..\src\lib\protocols\tocaboca.c" />
     <ClCompile Include="..\src\lib\protocols\raknet.c" />
     <ClCompile Include="..\src\lib\protocols\sd_rtn.c" />
     <ClCompile Include="..\src\lib\protocols\xiaomi.c" />
     <ClCompile Include="..\src\lib\protocols\collectd.c" />
     <ClCompile Include="..\src\lib\protocols\ipsec.c" />
     <ClCompile Include="..\src\lib\protocols\mpegdash.c" />
     <ClCompile Include="..\src\lib\protocols\rsh.c" />
     <ClCompile Include="..\src\lib\protocols\i3d.c" />
     <ClCompile Include="..\src\lib\protocols\riotgames.c" />
     <ClCompile Include="..\src\lib\protocols\ultrasurf.c" />
     <ClCompile Include="..\src\lib\protocols\activision.c" />
     <ClCompile Include="..\src\lib\protocols\alicloud.c" />
     <ClCompile Include="..\src\lib\protocols\avast.c" />
     <ClCompile Include="..\src\lib\protocols\discord.c" />
     <ClCompile Include="..\src\lib\protocols\softether.c" />
     <ClCompile Include="..\src\lib\protocols\threema.c" />
     <ClCompile Include="..\src\lib\protocols\tivoconnect.c" />
     <ClCompile Include="..\src\lib\protocols\fastcgi.c" />
     <ClCompile Include="..\src\lib\protocols\kismet.c" />
     <ClCompile Include="..\src\lib\protocols\syncthing.c" />
     <ClCompile Include="..\src\lib\protocols\natpmp.c" />
     <ClCompile Include="..\src\lib\protocols\crynet.c" />
     <ClCompile Include="..\example\ndpiReader.c" />
     <ClCompile Include="..\example\reader_util.c" />
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="..\src\lib\protocols\btlib.h" />
     <ClInclude Include="..\src\include\ndpi_includes.h" />
     <ClInclude Include="..\src\include\ndpi_protocol_ids.h" />
     <ClInclude Include="..\src\include\ndpi_protocols.h" />
     <ClInclude Include="..\src\include\ndpi_typedefs.h" />
     <ClInclude Include="..\src\include\ndpi_unix.h" />
     <ClInclude Include="..\src\include\ndpi_win32.h" />
     <ClInclude Include="arpa\inet.h" />
     <ClInclude Include="src\getopt.h" />
+    <ClInclude Include="src\dirent.h" />
     <ClInclude Include="..\src\include\ndpi_encryption.h" />
     <ClInclude Include="..\src\include\ndpi_main.h" />
     <ClInclude Include="..\src\include\ndpi_utils.h" />
     <ClInclude Include="..\src\lib\third_party\include\gcrypt_light.h" />
     <ClInclude Include="..\src\lib\third_party\include\MurmurHash3.h" />
     <ClInclude Include="..\src\lib\third_party\include\rce_injection.h" />
     <ClInclude Include="..\src\lib\third_party\include\roaring.h" />
     <ClInclude Include="..\src\lib\third_party\include\uthash.h" />
     <ClInclude Include="..\src\lib\third_party\include\ahocorasick.h">
       <Filter>third_party</Filter>
     </ClInclude>
     <ClInclude Include="..\src\lib\third_party\include\ndpi_patricia.h">
       <Filter>third_party</Filter>
     </ClInclude>
     <ClInclude Include="..\src\include\ndpi_patricia_typedefs.h">
       <Filter>third_party</Filter>
     </ClInclude>
     <ClInclude Include="..\src\lib\third_party\include\ndpi_sha1.h">
       <Filter>third_party</Filter>
     </ClInclude>
     <ClInclude Include="..\src\lib\third_party\include\ndpi_md5.h">
       <Filter>third_party</Filter>
     </ClInclude>
     <ClInclude Include="..\src\lib\third_party\include\hll.h">
       <Filter>third_party</Filter>
     </ClInclude>
     <ClInclude Include="..\src\lib\third_party\include\libcache.h">
       <Filter>third_party</Filter>
     </ClInclude>
     <ClInclude Include="..\src\lib\third_party\include\libinjection.h">
       <Filter>third_party</Filter>
     </ClInclude>
     <ClInclude Include="..\src\lib\third_party\include\libinjection_html5.h">
       <Filter>third_party</Filter>
     </ClInclude>
     <ClInclude Include="..\src\lib\third_party\include\libinjection_sqli.h">
       <Filter>third_party</Filter>
     </ClInclude>
     <ClInclude Include="..\src\lib\third_party\include\libinjection_sqli_data.h">
       <Filter>third_party</Filter>
     </ClInclude>
     <ClInclude Include="..\src\lib\third_party\include\libinjection_xss.h">
       <Filter>third_party</Filter>
     </ClInclude>
     <ClInclude Include="src\ndpi_config.h" />
     <ClInclude Include="src\ndpi_define.h" />
     <ClInclude Include="..\example\reader_util.h" />
   </ItemGroup>
   <ItemGroup>
     <None Include="..\src\lib\ndpi_content_match.c.inc" />
     <None Include="..\.github\workflows\build-msbuild.yml" />
     <None Include="packages.config" />
   </ItemGroup>
   <ItemGroup>
     <Filter Include="third_party">
       <UniqueIdentifier>{51f8ee9e-a41d-4343-8115-937ed5a1ea19}</UniqueIdentifier>
     </Filter>
   </ItemGroup>
 </Project>
diff --git a/windows/src/dirent.h b/windows/src/dirent.h
new file mode 100644
index 00000000..fd1e8135
--- /dev/null
+++ b/windows/src/dirent.h
@@ -0,0 +1,1239 @@
+/*
+ * Dirent interface for Microsoft Visual Studio
+ *
+ * Copyright (C) 1998-2019 Toni Ronkko
+ * This file is part of dirent.  Dirent may be freely distributed
+ * under the MIT license.  For all details and documentation, see
+ * https://github.com/tronkko/dirent
+ */
+#ifndef DIRENT_H
+#define DIRENT_H
+
+/* Hide warnings about unreferenced local functions */
+#if defined(__clang__)
+#	pragma clang diagnostic ignored "-Wunused-function"
+#elif defined(_MSC_VER)
+#	pragma warning(disable:4505)
+#elif defined(__GNUC__)
+#	pragma GCC diagnostic ignored "-Wunused-function"
+#endif
+
+/*
+ * Include windows.h without Windows Sockets 1.1 to prevent conflicts with
+ * Windows Sockets 2.0.
+ */
+#ifndef WIN32_LEAN_AND_MEAN
+#	define WIN32_LEAN_AND_MEAN
+#endif
+#include <windows.h>
+
+#include <stdio.h>
+#include <stdarg.h>
+#include <wchar.h>
+#include <string.h>
+#include <stdlib.h>
+#include <malloc.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <errno.h>
+#include <ctype.h>
+
+/* Indicates that d_type field is available in dirent structure */
+#define _DIRENT_HAVE_D_TYPE
+
+/* Indicates that d_namlen field is available in dirent structure */
+#define _DIRENT_HAVE_D_NAMLEN
+
+/* Entries missing from MSVC 6.0 */
+#if !defined(FILE_ATTRIBUTE_DEVICE)
+#	define FILE_ATTRIBUTE_DEVICE 0x40
+#endif
+
+/* File type and permission flags for stat(), general mask */
+#if !defined(S_IFMT)
+#	define S_IFMT _S_IFMT
+#endif
+
+/* Directory bit */
+#if !defined(S_IFDIR)
+#	define S_IFDIR _S_IFDIR
+#endif
+
+/* Character device bit */
+#if !defined(S_IFCHR)
+#	define S_IFCHR _S_IFCHR
+#endif
+
+/* Pipe bit */
+#if !defined(S_IFFIFO)
+#	define S_IFFIFO _S_IFFIFO
+#endif
+
+/* Regular file bit */
+#if !defined(S_IFREG)
+#	define S_IFREG _S_IFREG
+#endif
+
+/* Read permission */
+#if !defined(S_IREAD)
+#	define S_IREAD _S_IREAD
+#endif
+
+/* Write permission */
+#if !defined(S_IWRITE)
+#	define S_IWRITE _S_IWRITE
+#endif
+
+/* Execute permission */
+#if !defined(S_IEXEC)
+#	define S_IEXEC _S_IEXEC
+#endif
+
+/* Pipe */
+#if !defined(S_IFIFO)
+#	define S_IFIFO _S_IFIFO
+#endif
+
+/* Block device */
+#if !defined(S_IFBLK)
+#	define S_IFBLK 0
+#endif
+
+/*
+ * Symbolic link.  Be ware that S_IFLNK value and S_ISLNK() macro are only
+ * usable with dirent - they do not work with stat() function call!
+ */
+#if !defined(S_IFLNK)
+#	define S_IFLNK (_S_IFDIR | _S_IFREG)
+#endif
+
+/* Socket */
+#if !defined(S_IFSOCK)
+#	define S_IFSOCK 0
+#endif
+
+/* Read user permission */
+#if !defined(S_IRUSR)
+#	define S_IRUSR S_IREAD
+#endif
+
+/* Write user permission */
+#if !defined(S_IWUSR)
+#	define S_IWUSR S_IWRITE
+#endif
+
+/* Execute user permission */
+#if !defined(S_IXUSR)
+#	define S_IXUSR 0
+#endif
+
+/* User full permissions */
+#if !defined(S_IRWXU)
+#	define S_IRWXU (S_IRUSR | S_IWUSR | S_IXUSR)
+#endif
+
+/* Read group permission */
+#if !defined(S_IRGRP)
+#	define S_IRGRP 0
+#endif
+
+/* Write group permission */
+#if !defined(S_IWGRP)
+#	define S_IWGRP 0
+#endif
+
+/* Execute group permission */
+#if !defined(S_IXGRP)
+#	define S_IXGRP 0
+#endif
+
+/* Group full permissions */
+#if !defined(S_IRWXG)
+#	define S_IRWXG (S_IRGRP | S_IWGRP | S_IXGRP)
+#endif
+
+/* Read others permission */
+#if !defined(S_IROTH)
+#	define S_IROTH 0
+#endif
+
+/* Write others permission */
+#if !defined(S_IWOTH)
+#	define S_IWOTH 0
+#endif
+
+/* Execute others permission */
+#if !defined(S_IXOTH)
+#	define S_IXOTH 0
+#endif
+
+/* Other full permissions */
+#if !defined(S_IRWXO)
+#	define S_IRWXO (S_IROTH | S_IWOTH | S_IXOTH)
+#endif
+
+/* Maximum length of file name */
+#if !defined(PATH_MAX)
+#	define PATH_MAX MAX_PATH
+#endif
+#if !defined(FILENAME_MAX)
+#	define FILENAME_MAX MAX_PATH
+#endif
+#if !defined(NAME_MAX)
+#	define NAME_MAX FILENAME_MAX
+#endif
+
+/* File type flags for d_type */
+#define DT_UNKNOWN 0
+#define DT_REG S_IFREG
+#define DT_DIR S_IFDIR
+#define DT_FIFO S_IFIFO
+#define DT_SOCK S_IFSOCK
+#define DT_CHR S_IFCHR
+#define DT_BLK S_IFBLK
+#define DT_LNK S_IFLNK
+
+/* Macros for converting between st_mode and d_type */
+#define IFTODT(mode) ((mode) & S_IFMT)
+#define DTTOIF(type) (type)
+
+/*
+ * File type macros.  Note that block devices and sockets cannot be
+ * distinguished on Windows, and the macros S_ISBLK and S_ISSOCK are only
+ * defined for compatibility.  These macros should always return false on
+ * Windows.
+ */
+#if !defined(S_ISFIFO)
+#	define S_ISFIFO(mode) (((mode) & S_IFMT) == S_IFIFO)
+#endif
+#if !defined(S_ISDIR)
+#	define S_ISDIR(mode) (((mode) & S_IFMT) == S_IFDIR)
+#endif
+#if !defined(S_ISREG)
+#	define S_ISREG(mode) (((mode) & S_IFMT) == S_IFREG)
+#endif
+#if !defined(S_ISLNK)
+#	define S_ISLNK(mode) (((mode) & S_IFMT) == S_IFLNK)
+#endif
+#if !defined(S_ISSOCK)
+#	define S_ISSOCK(mode) (((mode) & S_IFMT) == S_IFSOCK)
+#endif
+#if !defined(S_ISCHR)
+#	define S_ISCHR(mode) (((mode) & S_IFMT) == S_IFCHR)
+#endif
+#if !defined(S_ISBLK)
+#	define S_ISBLK(mode) (((mode) & S_IFMT) == S_IFBLK)
+#endif
+
+/* Return the exact length of the file name without zero terminator */
+#define _D_EXACT_NAMLEN(p) ((p)->d_namlen)
+
+/* Return the maximum size of a file name */
+#define _D_ALLOC_NAMLEN(p) ((PATH_MAX)+1)
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* Wide-character version */
+struct _wdirent {
+	/* Always zero */
+	long d_ino;
+
+	/* Position of next file in a directory stream */
+	long d_off;
+
+	/* Structure size */
+	unsigned short d_reclen;
+
+	/* Length of name without \0 */
+	size_t d_namlen;
+
+	/* File type */
+	int d_type;
+
+	/* File name */
+	wchar_t d_name[PATH_MAX+1];
+};
+typedef struct _wdirent _wdirent;
+
+struct _WDIR {
+	/* Current directory entry */
+	struct _wdirent ent;
+
+	/* Private file data */
+	WIN32_FIND_DATAW data;
+
+	/* True if data is valid */
+	int cached;
+
+	/* True if next entry is invalid */
+	int invalid;
+
+	/* Win32 search handle */
+	HANDLE handle;
+
+	/* Initial directory name */
+	wchar_t *patt;
+};
+typedef struct _WDIR _WDIR;
+
+/* Multi-byte character version */
+struct dirent {
+	/* Always zero */
+	long d_ino;
+
+	/* Position of next file in a directory stream */
+	long d_off;
+
+	/* Structure size */
+	unsigned short d_reclen;
+
+	/* Length of name without \0 */
+	size_t d_namlen;
+
+	/* File type */
+	int d_type;
+
+	/* File name */
+	char d_name[PATH_MAX+1];
+};
+typedef struct dirent dirent;
+
+struct DIR {
+	struct dirent ent;
+	struct _WDIR *wdirp;
+};
+typedef struct DIR DIR;
+
+
+/* Dirent functions */
+static DIR *opendir(const char *dirname);
+static _WDIR *_wopendir(const wchar_t *dirname);
+
+static struct dirent *readdir(DIR *dirp);
+static struct _wdirent *_wreaddir(_WDIR *dirp);
+
+static int readdir_r(
+	DIR *dirp, struct dirent *entry, struct dirent **result);
+static int _wreaddir_r(
+	_WDIR *dirp, struct _wdirent *entry, struct _wdirent **result);
+
+static int closedir(DIR *dirp);
+static int _wclosedir(_WDIR *dirp);
+
+static void rewinddir(DIR *dirp);
+static void _wrewinddir(_WDIR *dirp);
+
+static long telldir(DIR *dirp);
+static long _wtelldir(_WDIR *dirp);
+
+static void seekdir(DIR *dirp, long loc);
+static void _wseekdir(_WDIR *dirp, long loc);
+
+static int scandir(const char *dirname, struct dirent ***namelist,
+	int (*filter)(const struct dirent*),
+	int (*compare)(const struct dirent**, const struct dirent**));
+
+static int alphasort(const struct dirent **a, const struct dirent **b);
+
+static int versionsort(const struct dirent **a, const struct dirent **b);
+
+static int strverscmp(const char *a, const char *b);
+
+/* For compatibility with Symbian */
+#define wdirent _wdirent
+#define WDIR _WDIR
+#define wopendir _wopendir
+#define wreaddir _wreaddir
+#define wclosedir _wclosedir
+#define wrewinddir _wrewinddir
+#define wtelldir _wtelldir
+#define wseekdir _wseekdir
+
+/* Compatibility with older Microsoft compilers and non-Microsoft compilers */
+#if !defined(_MSC_VER) || _MSC_VER < 1400
+#	define wcstombs_s dirent_wcstombs_s
+#	define mbstowcs_s dirent_mbstowcs_s
+#endif
+
+/* Optimize dirent_set_errno() away on modern Microsoft compilers */
+#if defined(_MSC_VER) && _MSC_VER >= 1400
+#	define dirent_set_errno _set_errno
+#endif
+
+
+/* Internal utility functions */
+static WIN32_FIND_DATAW *dirent_first(_WDIR *dirp);
+static WIN32_FIND_DATAW *dirent_next(_WDIR *dirp);
+static long dirent_hash(WIN32_FIND_DATAW *datap);
+
+#if !defined(_MSC_VER) || _MSC_VER < 1400
+static int dirent_mbstowcs_s(
+	size_t *pReturnValue, wchar_t *wcstr, size_t sizeInWords,
+	const char *mbstr, size_t count);
+#endif
+
+#if !defined(_MSC_VER) || _MSC_VER < 1400
+static int dirent_wcstombs_s(
+	size_t *pReturnValue, char *mbstr, size_t sizeInBytes,
+	const wchar_t *wcstr, size_t count);
+#endif
+
+#if !defined(_MSC_VER) || _MSC_VER < 1400
+static void dirent_set_errno(int error);
+#endif
+
+
+/*
+ * Open directory stream DIRNAME for read and return a pointer to the
+ * internal working area that is used to retrieve individual directory
+ * entries.
+ */
+static _WDIR *
+_wopendir(const wchar_t *dirname)
+{
+	wchar_t *p;
+
+	/* Must have directory name */
+	if (dirname == NULL || dirname[0] == '\0') {
+		dirent_set_errno(ENOENT);
+		return NULL;
+	}
+
+	/* Allocate new _WDIR structure */
+	_WDIR *dirp = (_WDIR*) malloc(sizeof(struct _WDIR));
+	if (!dirp)
+		return NULL;
+
+	/* Reset _WDIR structure */
+	dirp->handle = INVALID_HANDLE_VALUE;
+	dirp->patt = NULL;
+	dirp->cached = 0;
+	dirp->invalid = 0;
+
+	/*
+	 * Compute the length of full path plus zero terminator
+	 *
+	 * Note that on WinRT there's no way to convert relative paths
+	 * into absolute paths, so just assume it is an absolute path.
+	 */
+#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
+	/* Desktop */
+	DWORD n = GetFullPathNameW(dirname, 0, NULL, NULL);
+#else
+	/* WinRT */
+	size_t n = wcslen(dirname);
+#endif
+
+	/* Allocate room for absolute directory name and search pattern */
+	dirp->patt = (wchar_t*) malloc(sizeof(wchar_t) * n + 16);
+	if (dirp->patt == NULL)
+		goto exit_closedir;
+
+	/*
+	 * Convert relative directory name to an absolute one.  This
+	 * allows rewinddir() to function correctly even when current
+	 * working directory is changed between opendir() and rewinddir().
+	 *
+	 * Note that on WinRT there's no way to convert relative paths
+	 * into absolute paths, so just assume it is an absolute path.
+	 */
+#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
+	/* Desktop */
+	n = GetFullPathNameW(dirname, n, dirp->patt, NULL);
+	if (n <= 0)
+		goto exit_closedir;
+#else
+	/* WinRT */
+	wcsncpy_s(dirp->patt, n+1, dirname, n);
+#endif
+
+	/* Append search pattern \* to the directory name */
+	p = dirp->patt + n;
+	switch (p[-1]) {
+	case '\\':
+	case '/':
+	case ':':
+		/* Directory ends in path separator, e.g. c:\temp\ */
+		/*NOP*/;
+		break;
+
+	default:
+		/* Directory name doesn't end in path separator */
+		*p++ = '\\';
+	}
+	*p++ = '*';
+	*p = '\0';
+
+	/* Open directory stream and retrieve the first entry */
+	if (!dirent_first(dirp))
+		goto exit_closedir;
+
+	/* Success */
+	return dirp;
+
+	/* Failure */
+exit_closedir:
+	_wclosedir(dirp);
+	return NULL;
+}
+
+/*
+ * Read next directory entry.
+ *
+ * Returns pointer to static directory entry which may be overwritten by
+ * subsequent calls to _wreaddir().
+ */
+static struct _wdirent *
+_wreaddir(_WDIR *dirp)
+{
+	/*
+	 * Read directory entry to buffer.  We can safely ignore the return
+	 * value as entry will be set to NULL in case of error.
+	 */
+	struct _wdirent *entry;
+	(void) _wreaddir_r(dirp, &dirp->ent, &entry);
+
+	/* Return pointer to statically allocated directory entry */
+	return entry;
+}
+
+/*
+ * Read next directory entry.
+ *
+ * Returns zero on success.  If end of directory stream is reached, then sets
+ * result to NULL and returns zero.
+ */
+static int
+_wreaddir_r(
+	_WDIR *dirp, struct _wdirent *entry, struct _wdirent **result)
+{
+	/* Validate directory handle */
+	if (!dirp || dirp->handle == INVALID_HANDLE_VALUE || !dirp->patt) {
+		dirent_set_errno(EBADF);
+		*result = NULL;
+		return -1;
+	}
+
+	/* Read next directory entry */
+	WIN32_FIND_DATAW *datap = dirent_next(dirp);
+	if (!datap) {
+		/* Return NULL to indicate end of directory */
+		*result = NULL;
+		return /*OK*/0;
+	}
+
+	/*
+	 * Copy file name as wide-character string.  If the file name is too
+	 * long to fit in to the destination buffer, then truncate file name
+	 * to PATH_MAX characters and zero-terminate the buffer.
+	 */
+	size_t i = 0;
+	while (i < PATH_MAX && datap->cFileName[i] != 0) {
+		entry->d_name[i] = datap->cFileName[i];
+		i++;
+	}
+	entry->d_name[i] = 0;
+
+	/* Length of file name excluding zero terminator */
+	entry->d_namlen = i;
+
+	/* Determine file type */
+	DWORD attr = datap->dwFileAttributes;
+	if ((attr & FILE_ATTRIBUTE_DEVICE) != 0)
+		entry->d_type = DT_CHR;
+	else if ((attr & FILE_ATTRIBUTE_REPARSE_POINT) != 0)
+		entry->d_type = DT_LNK;
+	else if ((attr & FILE_ATTRIBUTE_DIRECTORY) != 0)
+		entry->d_type = DT_DIR;
+	else
+		entry->d_type = DT_REG;
+
+	/* Read the next directory entry to cache */
+	datap = dirent_next(dirp);
+	if (datap) {
+		/* Compute 31-bit hash of the next directory entry */
+		entry->d_off = dirent_hash(datap);
+
+		/* Push the next directory entry back to cache */
+		dirp->cached = 1;
+	} else {
+		/* End of directory stream */
+		entry->d_off = (long) ((~0UL) >> 1);
+	}
+
+	/* Reset other fields */
+	entry->d_ino = 0;
+	entry->d_reclen = sizeof(struct _wdirent);
+
+	/* Set result address */
+	*result = entry;
+	return /*OK*/0;
+}
+
+/*
+ * Close directory stream opened by opendir() function.  This invalidates the
+ * DIR structure as well as any directory entry read previously by
+ * _wreaddir().
+ */
+static int
+_wclosedir(_WDIR *dirp)
+{
+	if (!dirp) {
+		dirent_set_errno(EBADF);
+		return /*failure*/-1;
+	}
+
+	/*
+	 * Release search handle if we have one.  Being able to handle
+	 * partially initialized _WDIR structure allows us to use this
+	 * function to handle errors occuring within _wopendir.
+	 */
+	if (dirp->handle != INVALID_HANDLE_VALUE) {
+		FindClose(dirp->handle);
+	}
+
+	/*
+	 * Release search pattern.  Note that we don't need to care if
+	 * dirp->patt is NULL or not: function free is guaranteed to act
+	 * appropriately.
+	 */
+	free(dirp->patt);
+
+	/* Release directory structure */
+	free(dirp);
+	return /*success*/0;
+}
+
+/*
+ * Rewind directory stream such that _wreaddir() returns the very first
+ * file name again.
+ */
+static void _wrewinddir(_WDIR* dirp)
+{
+	/* Check directory pointer */
+	if (!dirp || dirp->handle == INVALID_HANDLE_VALUE || !dirp->patt)
+		return;
+
+	/* Release existing search handle */
+	FindClose(dirp->handle);
+
+	/* Open new search handle */
+	dirent_first(dirp);
+}
+
+/* Get first directory entry */
+static WIN32_FIND_DATAW *
+dirent_first(_WDIR *dirp)
+{
+	/* Open directory and retrieve the first entry */
+	dirp->handle = FindFirstFileExW(
+		dirp->patt, FindExInfoStandard, &dirp->data,
+		FindExSearchNameMatch, NULL, 0);
+	if (dirp->handle == INVALID_HANDLE_VALUE)
+		goto error;
+
+	/* A directory entry is now waiting in memory */
+	dirp->cached = 1;
+	return &dirp->data;
+
+error:
+	/* Failed to open directory: no directory entry in memory */
+	dirp->cached = 0;
+	dirp->invalid = 1;
+
+	/* Set error code */
+	DWORD errorcode = GetLastError();
+	switch (errorcode) {
+	case ERROR_ACCESS_DENIED:
+		/* No read access to directory */
+		dirent_set_errno(EACCES);
+		break;
+
+	case ERROR_DIRECTORY:
+		/* Directory name is invalid */
+		dirent_set_errno(ENOTDIR);
+		break;
+
+	case ERROR_PATH_NOT_FOUND:
+	default:
+		/* Cannot find the file */
+		dirent_set_errno(ENOENT);
+	}
+	return NULL;
+}
+
+/* Get next directory entry */
+static WIN32_FIND_DATAW *
+dirent_next(_WDIR *dirp)
+{
+	/* Return NULL if seek position was invalid */
+	if (dirp->invalid)
+		return NULL;
+
+	/* Is the next directory entry already in cache? */
+	if (dirp->cached) {
+		/* Yes, a valid directory entry found in memory */
+		dirp->cached = 0;
+		return &dirp->data;
+	}
+
+	/* Read the next directory entry from stream */
+	if (FindNextFileW(dirp->handle, &dirp->data) == FALSE) {
+		/* End of directory stream */
+		return NULL;
+	}
+
+	/* Success */
+	return &dirp->data;
+}
+
+/*
+ * Compute 31-bit hash of file name.
+ *
+ * See djb2 at http://www.cse.yorku.ca/~oz/hash.html
+ */
+static long
+dirent_hash(WIN32_FIND_DATAW *datap)
+{
+	unsigned long hash = 5381;
+	unsigned long c;
+	const wchar_t *p = datap->cFileName;
+	const wchar_t *e = p + MAX_PATH;
+	while (p != e && (c = *p++) != 0) {
+		hash = (hash << 5) + hash + c;
+	}
+
+	return (long) (hash & ((~0UL) >> 1));
+}
+
+/* Open directory stream using plain old C-string */
+static DIR *opendir(const char *dirname)
+{
+	/* Must have directory name */
+	if (dirname == NULL || dirname[0] == '\0') {
+		dirent_set_errno(ENOENT);
+		return NULL;
+	}
+
+	/* Allocate memory for DIR structure */
+	struct DIR *dirp = (DIR*) malloc(sizeof(struct DIR));
+	if (!dirp)
+		return NULL;
+
+	/* Convert directory name to wide-character string */
+	wchar_t wname[PATH_MAX + 1];
+	size_t n;
+	int error = mbstowcs_s(&n, wname, PATH_MAX + 1, dirname, PATH_MAX+1);
+	if (error)
+		goto exit_failure;
+
+	/* Open directory stream using wide-character name */
+	dirp->wdirp = _wopendir(wname);
+	if (!dirp->wdirp)
+		goto exit_failure;
+
+	/* Success */
+	return dirp;
+
+	/* Failure */
+exit_failure:
+	free(dirp);
+	return NULL;
+}
+
+/* Read next directory entry */
+static struct dirent *
+readdir(DIR *dirp)
+{
+	/*
+	 * Read directory entry to buffer.  We can safely ignore the return
+	 * value as entry will be set to NULL in case of error.
+	 */
+	struct dirent *entry;
+	(void) readdir_r(dirp, &dirp->ent, &entry);
+
+	/* Return pointer to statically allocated directory entry */
+	return entry;
+}
+
+/*
+ * Read next directory entry into called-allocated buffer.
+ *
+ * Returns zero on success.  If the end of directory stream is reached, then
+ * sets result to NULL and returns zero.
+ */
+static int
+readdir_r(
+	DIR *dirp, struct dirent *entry, struct dirent **result)
+{
+	/* Read next directory entry */
+	WIN32_FIND_DATAW *datap = dirent_next(dirp->wdirp);
+	if (!datap) {
+		/* No more directory entries */
+		*result = NULL;
+		return /*OK*/0;
+	}
+
+	/* Attempt to convert file name to multi-byte string */
+	size_t n;
+	int error = wcstombs_s(
+		&n, entry->d_name, PATH_MAX + 1,
+		datap->cFileName, PATH_MAX + 1);
+
+	/*
+	 * If the file name cannot be represented by a multi-byte string, then
+	 * attempt to use old 8+3 file name.  This allows the program to
+	 * access files although file names may seem unfamiliar to the user.
+	 *
+	 * Be ware that the code below cannot come up with a short file name
+	 * unless the file system provides one.  At least VirtualBox shared
+	 * folders fail to do this.
+	 */
+	if (error && datap->cAlternateFileName[0] != '\0') {
+		error = wcstombs_s(
+			&n, entry->d_name, PATH_MAX + 1,
+			datap->cAlternateFileName, PATH_MAX + 1);
+	}
+
+	if (!error) {
+		/* Length of file name excluding zero terminator */
+		entry->d_namlen = n - 1;
+
+		/* Determine file type */
+		DWORD attr = datap->dwFileAttributes;
+		if ((attr & FILE_ATTRIBUTE_DEVICE) != 0)
+			entry->d_type = DT_CHR;
+		else if ((attr & FILE_ATTRIBUTE_REPARSE_POINT) != 0)
+			entry->d_type = DT_LNK;
+		else if ((attr & FILE_ATTRIBUTE_DIRECTORY) != 0)
+			entry->d_type = DT_DIR;
+		else
+			entry->d_type = DT_REG;
+
+		/* Get offset of next file */
+		datap = dirent_next(dirp->wdirp);
+		if (datap) {
+			/* Compute 31-bit hash of the next directory entry */
+			entry->d_off = dirent_hash(datap);
+
+			/* Push the next directory entry back to cache */
+			dirp->wdirp->cached = 1;
+		} else {
+			/* End of directory stream */
+			entry->d_off = (long) ((~0UL) >> 1);
+		}
+
+		/* Reset fields */
+		entry->d_ino = 0;
+		entry->d_reclen = sizeof(struct dirent);
+	} else {
+		/*
+		 * Cannot convert file name to multi-byte string so construct
+		 * an erroneous directory entry and return that.  Note that
+		 * we cannot return NULL as that would stop the processing
+		 * of directory entries completely.
+		 */
+		entry->d_name[0] = '?';
+		entry->d_name[1] = '\0';
+		entry->d_namlen = 1;
+		entry->d_type = DT_UNKNOWN;
+		entry->d_ino = 0;
+		entry->d_off = -1;
+		entry->d_reclen = 0;
+	}
+
+	/* Return pointer to directory entry */
+	*result = entry;
+	return /*OK*/0;
+}
+
+/* Close directory stream */
+static int
+closedir(DIR *dirp)
+{
+	int ok;
+
+	if (!dirp)
+		goto exit_failure;
+
+	/* Close wide-character directory stream */
+	ok = _wclosedir(dirp->wdirp);
+	dirp->wdirp = NULL;
+
+	/* Release multi-byte character version */
+	free(dirp);
+	return ok;
+
+exit_failure:
+	/* Invalid directory stream */
+	dirent_set_errno(EBADF);
+	return /*failure*/-1;
+}
+
+/* Rewind directory stream to beginning */
+static void
+rewinddir(DIR *dirp)
+{
+	if (!dirp)
+		return;
+
+	/* Rewind wide-character string directory stream */
+	_wrewinddir(dirp->wdirp);
+}
+
+/* Get position of directory stream */
+static long
+_wtelldir(_WDIR *dirp)
+{
+	if (!dirp || dirp->handle == INVALID_HANDLE_VALUE) {
+		dirent_set_errno(EBADF);
+		return /*failure*/-1;
+	}
+
+	/* Read next file entry */
+	WIN32_FIND_DATAW *datap = dirent_next(dirp);
+	if (!datap) {
+		/* End of directory stream */
+		return (long) ((~0UL) >> 1);
+	}
+
+	/* Store file entry to cache for readdir() */
+	dirp->cached = 1;
+
+	/* Return the 31-bit hash code to be used as stream position */
+	return dirent_hash(datap);
+}
+
+/* Get position of directory stream */
+static long
+telldir(DIR *dirp)
+{
+	if (!dirp) {
+		dirent_set_errno(EBADF);
+		return -1;
+	}
+
+	return _wtelldir(dirp->wdirp);
+}
+
+/* Seek directory stream to offset */
+static void
+_wseekdir(_WDIR *dirp, long loc)
+{
+	if (!dirp)
+		return;
+	
+	/* Directory must be open */
+	if (dirp->handle == INVALID_HANDLE_VALUE)
+		goto exit_failure;
+
+	/* Ensure that seek position is valid */
+	if (loc < 0)
+		goto exit_failure;
+
+	/* Restart directory stream from the beginning */
+	FindClose(dirp->handle);
+	if (!dirent_first(dirp))
+		goto exit_failure;
+
+	/* Reset invalid flag so that we can read from the stream again */
+	dirp->invalid = 0;
+
+	/*
+	 * Read directory entries from the beginning until the hash matches a
+	 * file name.  Be ware that hash code is only 31 bits longs and
+	 * duplicates are possible: the hash code cannot return the position
+	 * with 100.00% accuracy! Moreover, the method is slow for large
+	 * directories.
+	 */
+	long hash;
+	do {
+		/* Read next directory entry */
+		WIN32_FIND_DATAW *datap = dirent_next(dirp);
+		if (!datap) {
+			/*
+			 * End of directory stream was reached before finding
+			 * the requested location.  Perhaps the file in
+			 * question was deleted or moved out of the directory.
+			 */
+			goto exit_failure;
+		}
+
+		/* Does the file name match the hash? */
+		hash = dirent_hash(datap);
+	} while (hash != loc);
+
+	/*
+	 * File name matches the hash!  Push the directory entry back to cache
+	 * from where next readdir() will return it.
+	 */
+	dirp->cached = 1;
+	dirp->invalid = 0;
+	return;
+
+exit_failure:
+	/* Ensure that readdir will return NULL */
+	dirp->invalid = 1;
+}
+
+/* Seek directory stream to offset */
+static void
+seekdir(DIR *dirp, long loc)
+{
+	if (!dirp)
+		return;
+
+	_wseekdir(dirp->wdirp, loc);
+}
+
+/* Scan directory for entries */
+static int
+scandir(
+	const char *dirname, struct dirent ***namelist,
+	int (*filter)(const struct dirent*),
+	int (*compare)(const struct dirent**, const struct dirent**))
+{
+	int result;
+
+	/* Open directory stream */
+	DIR *dir = opendir(dirname);
+	if (!dir) {
+		/* Cannot open directory */
+		return /*Error*/ -1;
+	}
+
+	/* Read directory entries to memory */
+	struct dirent *tmp = NULL;
+	struct dirent **files = NULL;
+	size_t size = 0;
+	size_t allocated = 0;
+	while (1) {
+		/* Allocate room for a temporary directory entry */
+		if (!tmp) {
+			tmp = (struct dirent*) malloc(sizeof(struct dirent));
+			if (!tmp)
+				goto exit_failure;
+		}
+
+		/* Read directory entry to temporary area */
+		struct dirent *entry;
+		if (readdir_r(dir, tmp, &entry) != /*OK*/0)
+			goto exit_failure;
+
+		/* Stop if we already read the last directory entry */
+		if (entry == NULL)
+			goto exit_success;
+
+		/* Determine whether to include the entry in results */
+		if (filter && !filter(tmp))
+			continue;
+
+		/* Enlarge pointer table to make room for another pointer */
+		if (size >= allocated) {
+			/* Compute number of entries in the new table */
+			size_t num_entries = size * 2 + 16;
+
+			/* Allocate new pointer table or enlarge existing */
+			void *p = realloc(files, sizeof(void*) * num_entries);
+			if (!p)
+				goto exit_failure;
+
+			/* Got the memory */
+			files = (dirent**) p;
+			allocated = num_entries;
+		}
+
+		/* Store the temporary entry to ptr table */
+		files[size++] = tmp;
+		tmp = NULL;
+	}
+
+exit_failure:
+	/* Release allocated entries */
+	for (size_t i = 0; i < size; i++) {
+		free(files[i]);
+	}
+
+	/* Release the pointer table */
+	free(files);
+	files = NULL;
+
+	/* Exit with error code */
+	result = /*error*/ -1;
+	goto exit_status;
+
+exit_success:
+	/* Sort directory entries */
+	if (size > 1 && compare) {
+		qsort(files, size, sizeof(void*),
+			(int (*) (const void*, const void*)) compare);
+	}
+
+	/* Pass pointer table to caller */
+	if (namelist)
+		*namelist = files;
+
+	/* Return the number of directory entries read */
+	result = (int) size;
+
+exit_status:
+	/* Release temporary directory entry, if we had one */
+	free(tmp);
+
+	/* Close directory stream */
+	closedir(dir);
+	return result;
+}
+
+/* Alphabetical sorting */
+static int
+alphasort(const struct dirent **a, const struct dirent **b)
+{
+	return strcoll((*a)->d_name, (*b)->d_name);
+}
+
+/* Sort versions */
+static int
+versionsort(const struct dirent **a, const struct dirent **b)
+{
+	return strverscmp((*a)->d_name, (*b)->d_name);
+}
+
+/* Compare strings */
+static int
+strverscmp(const char *a, const char *b)
+{
+	size_t i = 0;
+	size_t j;
+
+	/* Find first difference */
+	while (a[i] == b[i]) {
+		if (a[i] == '\0') {
+			/* No difference */
+			return 0;
+		}
+		++i;
+	}
+
+	/* Count backwards and find the leftmost digit */
+	j = i;
+	while (j > 0 && isdigit(a[j-1])) {
+		--j;
+	}
+
+	/* Determine mode of comparison */
+	if (a[j] == '0' || b[j] == '0') {
+		/* Find the next non-zero digit */
+		while (a[j] == '0' && a[j] == b[j]) {
+			j++;
+		}
+
+		/* String with more digits is smaller, e.g 002 < 01 */
+		if (isdigit(a[j])) {
+			if (!isdigit(b[j])) {
+				return -1;
+			}
+		} else if (isdigit(b[j])) {
+			return 1;
+		}
+	} else if (isdigit(a[j]) && isdigit(b[j])) {
+		/* Numeric comparison */
+		size_t k1 = j;
+		size_t k2 = j;
+
+		/* Compute number of digits in each string */
+		while (isdigit(a[k1])) {
+			k1++;
+		}
+		while (isdigit(b[k2])) {
+			k2++;
+		}
+
+		/* Number with more digits is bigger, e.g 999 < 1000 */
+		if (k1 < k2)
+			return -1;
+		else if (k1 > k2)
+			return 1;
+	}
+
+	/* Alphabetical comparison */
+	return (int) ((unsigned char) a[i]) - ((unsigned char) b[i]);
+}
+
+/* Convert multi-byte string to wide character string */
+#if !defined(_MSC_VER) || _MSC_VER < 1400
+static int
+dirent_mbstowcs_s(
+	size_t *pReturnValue, wchar_t *wcstr,
+	size_t sizeInWords, const char *mbstr, size_t count)
+{
+	/* Older Visual Studio or non-Microsoft compiler */
+	size_t n = mbstowcs(wcstr, mbstr, sizeInWords);
+	if (wcstr && n >= count)
+		return /*error*/ 1;
+
+	/* Zero-terminate output buffer */
+	if (wcstr && sizeInWords) {
+		if (n >= sizeInWords)
+			n = sizeInWords - 1;
+		wcstr[n] = 0;
+	}
+
+	/* Length of multi-byte string with zero terminator */
+	if (pReturnValue) {
+		*pReturnValue = n + 1;
+	}
+
+	/* Success */
+	return 0;
+}
+#endif
+
+/* Convert wide-character string to multi-byte string */
+#if !defined(_MSC_VER) || _MSC_VER < 1400
+static int
+dirent_wcstombs_s(
+	size_t *pReturnValue, char *mbstr,
+	size_t sizeInBytes, const wchar_t *wcstr, size_t count)
+{
+	/* Older Visual Studio or non-Microsoft compiler */
+	size_t n = wcstombs(mbstr, wcstr, sizeInBytes);
+	if (mbstr && n >= count)
+		return /*error*/1;
+
+	/* Zero-terminate output buffer */
+	if (mbstr && sizeInBytes) {
+		if (n >= sizeInBytes) {
+			n = sizeInBytes - 1;
+		}
+		mbstr[n] = '\0';
+	}
+
+	/* Length of resulting multi-bytes string WITH zero-terminator */
+	if (pReturnValue) {
+		*pReturnValue = n + 1;
+	}
+
+	/* Success */
+	return 0;
+}
+#endif
+
+/* Set errno variable */
+#if !defined(_MSC_VER) || _MSC_VER < 1400
+static void
+dirent_set_errno(int error)
+{
+	/* Non-Microsoft compiler or older Microsoft compiler */
+	errno = error;
+}
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif /*DIRENT_H*/
