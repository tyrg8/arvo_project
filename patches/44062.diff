commit e90fb954b51dd5f1def2f5c8d63163b2bda236d7
Author: Adi (Suissa) Peleg <adip@google.com>
Date:   Tue Feb 1 11:13:40 2022 -0500

    Revert "Windows: Emulate MSG_PEEK by read (#19291)" (#19748)
    
    This reverts commit de5fd3a87be8eb37ba8730bab13c495477c06184.
    
    Reverting due to a detected fuzz issue.
    
    Signed-off-by: Adi Suissa-Peleg <adip@google.com>

diff --git a/contrib/postgres_proxy/filters/network/test/postgres_decoder_test.cc b/contrib/postgres_proxy/filters/network/test/postgres_decoder_test.cc
index edf19b4933..638e6d9ae5 100644
--- a/contrib/postgres_proxy/filters/network/test/postgres_decoder_test.cc
+++ b/contrib/postgres_proxy/filters/network/test/postgres_decoder_test.cc
@@ -639,36 +639,34 @@ class FakeBuffer : public Buffer::Instance {
 public:
   MOCK_METHOD(void, addDrainTracker, (std::function<void()>), (override));
   MOCK_METHOD(void, bindAccount, (Buffer::BufferMemoryAccountSharedPtr), (override));
   MOCK_METHOD(void, add, (const void*, uint64_t), (override));
   MOCK_METHOD(void, addBufferFragment, (Buffer::BufferFragment&), (override));
   MOCK_METHOD(void, add, (absl::string_view), (override));
   MOCK_METHOD(void, add, (const Instance&), (override));
   MOCK_METHOD(void, prepend, (absl::string_view), (override));
   MOCK_METHOD(void, prepend, (Instance&), (override));
   MOCK_METHOD(void, copyOut, (size_t, uint64_t, void*), (const, override));
-  MOCK_METHOD(uint64_t, copyOutToSlices,
-              (uint64_t size, Buffer::RawSlice* slices, uint64_t num_slice), (const, override));
   MOCK_METHOD(void, drain, (uint64_t), (override));
   MOCK_METHOD(Buffer::RawSliceVector, getRawSlices, (absl::optional<uint64_t>), (const, override));
   MOCK_METHOD(Buffer::RawSlice, frontSlice, (), (const, override));
   MOCK_METHOD(Buffer::SliceDataPtr, extractMutableFrontSlice, (), (override));
   MOCK_METHOD(uint64_t, length, (), (const, override));
   MOCK_METHOD(void*, linearize, (uint32_t), (override));
   MOCK_METHOD(void, move, (Instance&), (override));
   MOCK_METHOD(void, move, (Instance&, uint64_t), (override));
   MOCK_METHOD(Buffer::Reservation, reserveForRead, (), (override));
   MOCK_METHOD(Buffer::ReservationSingleSlice, reserveSingleSlice, (uint64_t, bool), (override));
   MOCK_METHOD(void, commit,
               (uint64_t, absl::Span<Buffer::RawSlice>, Buffer::ReservationSlicesOwnerPtr),
               (override));
   MOCK_METHOD(ssize_t, search, (const void*, uint64_t, size_t, size_t), (const, override));
   MOCK_METHOD(bool, startsWith, (absl::string_view), (const, override));
   MOCK_METHOD(std::string, toString, (), (const, override));
   MOCK_METHOD(void, setWatermarks, (uint32_t), (override));
   MOCK_METHOD(uint32_t, highWatermark, (), (const, override));
   MOCK_METHOD(bool, highWatermarkTriggered, (), (const, override));
   MOCK_METHOD(size_t, addFragments, (absl::Span<const absl::string_view>));
 };
 
 // Test verifies that decoder calls Buffer::linearize method
 // for messages which have associated 'action'.
diff --git a/envoy/buffer/buffer.h b/envoy/buffer/buffer.h
index 504e3f890b..ba28c655a6 100644
--- a/envoy/buffer/buffer.h
+++ b/envoy/buffer/buffer.h
@@ -134,364 +134,354 @@ class Instance {
 public:
   virtual ~Instance() = default;
 
   /**
    * Register function to call when the last byte in the last slice of this
    * buffer has fully drained. Note that slices may be transferred to
    * downstream buffers, drain trackers are transferred along with the bytes
    * they track so the function is called only after the last byte is drained
    * from all buffers.
    */
   virtual void addDrainTracker(std::function<void()> drain_tracker) PURE;
 
   /**
    * Binds the account to be charged for resources used by the buffer. This
    * should only be called when the buffer is empty as existing slices
    * within the buffer won't retroactively get tagged.
    *
    * @param account a shared_ptr to the account to charge.
    */
   virtual void bindAccount(BufferMemoryAccountSharedPtr account) PURE;
 
   /**
    * Copy data into the buffer (deprecated, use absl::string_view variant
    * instead).
    * TODO(htuch): Cleanup deprecated call sites.
    * @param data supplies the data address.
    * @param size supplies the data size.
    */
   virtual void add(const void* data, uint64_t size) PURE;
 
   /**
    * Add externally owned data into the buffer. No copying is done. fragment is not owned. When
    * the fragment->data() is no longer needed, fragment->done() is called.
    * @param fragment the externally owned data to add to the buffer.
    */
   virtual void addBufferFragment(BufferFragment& fragment) PURE;
 
   /**
    * Copy a string into the buffer.
    * @param data supplies the string to copy.
    */
   virtual void add(absl::string_view data) PURE;
 
   /**
    * Copy another buffer into this buffer.
    * @param data supplies the buffer to copy.
    */
   virtual void add(const Instance& data) PURE;
 
   /**
    * Prepend a string_view to the buffer.
    * @param data supplies the string_view to copy.
    */
   virtual void prepend(absl::string_view data) PURE;
 
   /**
    * Prepend data from another buffer to this buffer.
    * The supplied buffer is drained after this operation.
    * @param data supplies the buffer to copy.
    */
   virtual void prepend(Instance& data) PURE;
 
   /**
    * Copy out a section of the buffer.
    * @param start supplies the buffer index to start copying from.
    * @param size supplies the size of the output buffer.
    * @param data supplies the output buffer to fill.
    */
   virtual void copyOut(size_t start, uint64_t size, void* data) const PURE;
 
-  /**
-   * Copy out a section of the buffer to  dynamic array of slices.
-   * @param size supplies the size of the data that will be copied.
-   * @param slices supplies the output slices to fill.
-   * @param num_slice supplies the number of slices to fill.
-   * @return the number of bytes copied.
-   */
-  virtual uint64_t copyOutToSlices(uint64_t size, Buffer::RawSlice* slices,
-                                   uint64_t num_slice) const PURE;
-
   /**
    * Drain data from the buffer.
    * @param size supplies the length of data to drain.
    */
   virtual void drain(uint64_t size) PURE;
 
   /**
    * Fetch the raw buffer slices.
    * @param max_slices supplies an optional limit on the number of slices to fetch, for performance.
    * @return RawSliceVector with non-empty slices in the buffer.
    */
   virtual RawSliceVector
   getRawSlices(absl::optional<uint64_t> max_slices = absl::nullopt) const PURE;
 
   /**
    * Fetch the valid data pointer and valid data length of the first non-zero-length
    * slice in the buffer.
    * @return RawSlice the first non-empty slice in the buffer, or {nullptr, 0} if the buffer
    * is empty.
    */
   virtual RawSlice frontSlice() const PURE;
 
   /**
    * Transfer ownership of the front slice to the caller. Must only be called if the
    * buffer is not empty otherwise the implementation will have undefined behavior.
    * If the underlying slice is immutable then the implementation must create and return
    * a mutable slice that has a copy of the immutable data.
    * @return pointer to SliceData object that wraps the front slice
    */
   virtual SliceDataPtr extractMutableFrontSlice() PURE;
 
   /**
    * @return uint64_t the total length of the buffer (not necessarily contiguous in memory).
    */
   virtual uint64_t length() const PURE;
 
   /**
    * @return a pointer to the first byte of data that has been linearized out to size bytes.
    */
   virtual void* linearize(uint32_t size) PURE;
 
   /**
    * Move a buffer into this buffer. As little copying is done as possible.
    * @param rhs supplies the buffer to move.
    */
   virtual void move(Instance& rhs) PURE;
 
   /**
    * Move a portion of a buffer into this buffer. As little copying is done as possible.
    * @param rhs supplies the buffer to move.
    * @param length supplies the amount of data to move.
    */
   virtual void move(Instance& rhs, uint64_t length) PURE;
 
   /**
    * Reserve space in the buffer for reading into. The amount of space reserved is determined
    * based on buffer settings and performance considerations.
    * @return a `Reservation`, on which `commit()` can be called, or which can
    *   be destructed to discard any resources in the `Reservation`.
    */
   virtual Reservation reserveForRead() PURE;
 
   /**
    * Reserve space in the buffer in a single slice.
    * @param length the exact length of the reservation.
    * @param separate_slice specifies whether the reserved space must be in a separate slice
    *   from any other data in this buffer.
    * @return a `ReservationSingleSlice` which has exactly one slice in it.
    */
   virtual ReservationSingleSlice reserveSingleSlice(uint64_t length,
                                                     bool separate_slice = false) PURE;
 
   /**
    * Search for an occurrence of data within the buffer.
    * @param data supplies the data to search for.
    * @param size supplies the length of the data to search for.
    * @param start supplies the starting index to search from.
    * @param length limits the search to specified number of bytes starting from start index.
    * When length value is zero, entire length of data from starting index to the end is searched.
    * @return the index where the match starts or -1 if there is no match.
    */
   virtual ssize_t search(const void* data, uint64_t size, size_t start, size_t length) const PURE;
 
   /**
    * Search for an occurrence of data within entire buffer.
    * @param data supplies the data to search for.
    * @param size supplies the length of the data to search for.
    * @param start supplies the starting index to search from.
    * @return the index where the match starts or -1 if there is no match.
    */
   ssize_t search(const void* data, uint64_t size, size_t start) const {
     return search(data, size, start, 0);
   }
 
   /**
    * Search for an occurrence of data at the start of a buffer.
    * @param data supplies the data to search for.
    * @return true if this buffer starts with data, false otherwise.
    */
   virtual bool startsWith(absl::string_view data) const PURE;
 
   /**
    * Constructs a flattened string from a buffer.
    * @return the flattened string.
    */
   virtual std::string toString() const PURE;
 
   /**
    * Copy an integer out of the buffer.
    * @param start supplies the buffer index to start copying from.
    * @param Size how many bytes to read out of the buffer.
    * @param Endianness specifies the byte order to use when decoding the integer.
    * @details Size parameter: Some protocols have integer fields whose size in bytes won't match the
    * size in bytes of C++'s integer types. Take a 3-byte integer field for example, which we want to
    * represent as a 32-bit (4 bytes) integer. One option to deal with that situation is to read 4
    * bytes from the buffer and ignore 1. There are a few problems with that solution, though.
    *   * The first problem is buffer underflow: there may not be more than Size bytes available
    * (say, last field in the payload), so that's an edge case to take into consideration.
    *   * The second problem is draining the buffer after reading. With the above solution we cannot
    *     read and discard in one go. We'd need to peek 4 bytes, ignore 1 and then drain 3. That not
    *     only looks hacky since the sizes don't match, but also produces less terse code and
    * requires the caller to propagate that logic to all call sites. Things complicate even further
    * when endianness is taken into consideration: should the most or least-significant bytes be
    * padded? Dealing with this situation requires a high level of care and attention to detail.
    * Properly calculating which bytes to discard and how to displace the data is not only error
    * prone, but also shifts to the caller a burden that could be solved in a much more generic,
    * transparent and well tested manner.
    *   * The last problem in the list is sign extension, which should be properly handled when
    * reading signed types with negative values. To make matters easier, the optional Size parameter
    * can be specified in those situations where there's a need to read less bytes than a C++'s
    * integer size in bytes. For the most common case when one needs to read exactly as many bytes as
    * the size of C++'s integer, this parameter can simply be omitted and it will be automatically
    * deduced from the size of the type T
    */
   template <typename T, ByteOrder Endianness = ByteOrder::Host, size_t Size = sizeof(T)>
   T peekInt(uint64_t start = 0) const {
     static_assert(Size <= sizeof(T), "requested size is bigger than integer being read");
 
     if (length() < start + Size) {
       ExceptionUtil::throwEnvoyException("buffer underflow");
     }
 
     constexpr const auto displacement = Endianness == ByteOrder::BigEndian ? sizeof(T) - Size : 0;
 
     auto result = static_cast<T>(0);
     constexpr const auto all_bits_enabled = static_cast<T>(~static_cast<T>(0));
 
     int8_t* bytes = reinterpret_cast<int8_t*>(std::addressof(result));
     copyOut(start, Size, &bytes[displacement]);
 
     constexpr const auto most_significant_read_byte =
         Endianness == ByteOrder::BigEndian ? displacement : Size - 1;
 
     // If Size == sizeof(T), we need to make sure we don't generate an invalid left shift
     // (e.g. int32 << 32), even though we know that that branch of the conditional will.
     // not be taken. Size % sizeof(T) gives us the correct left shift when Size < sizeof(T),
     // and generates a left shift of 0 bits when Size == sizeof(T)
     const auto sign_extension_bits =
         std::is_signed<T>::value && Size < sizeof(T) && bytes[most_significant_read_byte] < 0
             ? static_cast<T>(static_cast<typename std::make_unsigned<T>::type>(all_bits_enabled)
                              << ((Size % sizeof(T)) * CHAR_BIT))
             : static_cast<T>(0);
 
     return fromEndianness<Endianness>(static_cast<T>(result)) | sign_extension_bits;
   }
 
   /**
    * Copy a little endian integer out of the buffer.
    * @param start supplies the buffer index to start copying from.
    * @param Size how many bytes to read out of the buffer.
    */
   template <typename T, size_t Size = sizeof(T)> T peekLEInt(uint64_t start = 0) const {
     return peekInt<T, ByteOrder::LittleEndian, Size>(start);
   }
 
   /**
    * Copy a big endian integer out of the buffer.
    * @param start supplies the buffer index to start copying from.
    * @param Size how many bytes to read out of the buffer.
    */
   template <typename T, size_t Size = sizeof(T)> T peekBEInt(uint64_t start = 0) const {
     return peekInt<T, ByteOrder::BigEndian, Size>(start);
   }
 
   /**
    * Copy an integer out of the buffer and drain the read data.
    * @param Size how many bytes to read out of the buffer.
    * @param Endianness specifies the byte order to use when decoding the integer.
    */
   template <typename T, ByteOrder Endianness = ByteOrder::Host, size_t Size = sizeof(T)>
   T drainInt() {
     const auto result = peekInt<T, Endianness, Size>();
     drain(Size);
     return result;
   }
 
   /**
    * Copy a little endian integer out of the buffer and drain the read data.
    * @param Size how many bytes to read out of the buffer.
    */
   template <typename T, size_t Size = sizeof(T)> T drainLEInt() {
     return drainInt<T, ByteOrder::LittleEndian, Size>();
   }
 
   /**
    * Copy a big endian integer out of the buffer and drain the read data.
    * @param Size how many bytes to read out of the buffer.
    */
   template <typename T, size_t Size = sizeof(T)> T drainBEInt() {
     return drainInt<T, ByteOrder::BigEndian, Size>();
   }
 
   /**
    * Copy a byte into the buffer.
    * @param value supplies the byte to copy into the buffer.
    */
   void writeByte(uint8_t value) { add(std::addressof(value), 1); }
 
   /**
    * Copy value as a byte into the buffer.
    * @param value supplies the byte to copy into the buffer.
    */
   template <typename T> void writeByte(T value) { writeByte(static_cast<uint8_t>(value)); }
 
   /**
    * Copy an integer into the buffer.
    * @param value supplies the integer to copy into the buffer.
    * @param Size how many bytes to write from the requested integer.
    * @param Endianness specifies the byte order to use when encoding the integer.
    */
   template <ByteOrder Endianness = ByteOrder::Host, typename T, size_t Size = sizeof(T)>
   void writeInt(T value) {
     static_assert(Size <= sizeof(T), "requested size is bigger than integer being written");
 
     const auto data = toEndianness<Endianness>(value);
     constexpr const auto displacement = Endianness == ByteOrder::BigEndian ? sizeof(T) - Size : 0;
     add(reinterpret_cast<const char*>(std::addressof(data)) + displacement, Size);
   }
 
   /**
    * Copy an integer into the buffer in little endian byte order.
    * @param value supplies the integer to copy into the buffer.
    * @param Size how many bytes to write from the requested integer.
    */
   template <typename T, size_t Size = sizeof(T)> void writeLEInt(T value) {
     writeInt<ByteOrder::LittleEndian, T, Size>(value);
   }
 
   /**
    * Copy an integer into the buffer in big endian byte order.
    * @param value supplies the integer to copy into the buffer.
    * @param Size how many bytes to write from the requested integer.
    */
   template <typename T, size_t Size = sizeof(T)> void writeBEInt(T value) {
     writeInt<ByteOrder::BigEndian, T, Size>(value);
   }
 
   /**
    * Copy multiple string type fragments to the buffer.
    * @param fragments A sequence of string views with variable length.
    * @return The total size of the data copied to the buffer.
    */
   virtual size_t addFragments(absl::Span<const absl::string_view> fragments) PURE;
 
   /**
    * Set the buffer's high watermark. The buffer's low watermark is implicitly set to half the high
    * watermark. Setting the high watermark to 0 disables watermark functionality.
    * @param watermark supplies the buffer high watermark size threshold, in bytes.
    */
   virtual void setWatermarks(uint32_t watermark) PURE;
 
   /**
    * Returns the configured high watermark. A return value of 0 indicates that watermark
    * functionality is disabled.
    */
   virtual uint32_t highWatermark() const PURE;
   /**
    * Determine if the buffer watermark trigger condition is currently set. The watermark trigger is
    * set when the buffer size exceeds the configured high watermark and is cleared once the buffer
    * size drops to the low watermark.
    * @return true if the buffer size once exceeded the high watermark and hasn't since dropped to
    * the low watermark.
    */
   virtual bool highWatermarkTriggered() const PURE;
diff --git a/source/common/buffer/buffer_impl.cc b/source/common/buffer/buffer_impl.cc
index 3b1eea4054..8c24ea4ff4 100644
--- a/source/common/buffer/buffer_impl.cc
+++ b/source/common/buffer/buffer_impl.cc
@@ -118,38 +118,6 @@ void OwnedImpl::copyOut(size_t start, uint64_t size, void* data) const {
   ASSERT(size == 0);
 }
 
-uint64_t OwnedImpl::copyOutToSlices(uint64_t size, Buffer::RawSlice* dest_slices,
-                                    uint64_t num_slice) const {
-  uint64_t total_length_to_read = std::min(size, this->length());
-  uint64_t num_bytes_read = 0;
-  uint64_t num_dest_slices_read = 0;
-  uint64_t num_src_slices_read = 0;
-  uint64_t dest_slice_offset = 0;
-  uint64_t src_slice_offset = 0;
-  while (num_dest_slices_read < num_slice && num_bytes_read < total_length_to_read) {
-    const Slice& src_slice = slices_[num_src_slices_read];
-    const Buffer::RawSlice& dest_slice = dest_slices[num_dest_slices_read];
-    uint64_t left_to_read = total_length_to_read - num_bytes_read;
-    uint64_t left_data_size_in_slice = src_slice.dataSize() - src_slice_offset;
-    uint64_t length_to_copy = std::min(
-        left_data_size_in_slice, std::min(static_cast<uint64_t>(dest_slice.len_), left_to_read));
-    memcpy(static_cast<uint8_t*>(dest_slice.mem_) + dest_slice_offset, // NOLINT(safe-memcpy)
-           src_slice.data() + src_slice_offset, length_to_copy);
-    src_slice_offset = src_slice_offset + length_to_copy;
-    dest_slice_offset = dest_slice_offset + length_to_copy;
-    if (src_slice_offset == src_slice.dataSize()) {
-      num_src_slices_read++;
-      src_slice_offset = 0;
-    }
-    if (dest_slice_offset == dest_slice.len_) {
-      num_dest_slices_read++;
-      dest_slice_offset = 0;
-    }
-    num_bytes_read += length_to_copy;
-  }
-  return num_bytes_read;
-}
-
 void OwnedImpl::drain(uint64_t size) { drainImpl(size); }
 
 void OwnedImpl::drainImpl(uint64_t size) {
diff --git a/source/common/buffer/buffer_impl.h b/source/common/buffer/buffer_impl.h
index f74dfb5493..bc8aa4ada4 100644
--- a/source/common/buffer/buffer_impl.h
+++ b/source/common/buffer/buffer_impl.h
@@ -673,76 +673,74 @@ class OwnedImpl : public LibEventInstance {
 public:
   OwnedImpl();
   OwnedImpl(absl::string_view data);
   OwnedImpl(const Instance& data);
   OwnedImpl(const void* data, uint64_t size);
   OwnedImpl(BufferMemoryAccountSharedPtr account);
 
   // Buffer::Instance
   void addDrainTracker(std::function<void()> drain_tracker) override;
   void bindAccount(BufferMemoryAccountSharedPtr account) override;
   void add(const void* data, uint64_t size) override;
   void addBufferFragment(BufferFragment& fragment) override;
   void add(absl::string_view data) override;
   void add(const Instance& data) override;
   void prepend(absl::string_view data) override;
   void prepend(Instance& data) override;
   void copyOut(size_t start, uint64_t size, void* data) const override;
-  uint64_t copyOutToSlices(uint64_t size, Buffer::RawSlice* slices,
-                           uint64_t num_slice) const override;
   void drain(uint64_t size) override;
   RawSliceVector getRawSlices(absl::optional<uint64_t> max_slices = absl::nullopt) const override;
   RawSlice frontSlice() const override;
   SliceDataPtr extractMutableFrontSlice() override;
   uint64_t length() const override;
   void* linearize(uint32_t size) override;
   void move(Instance& rhs) override;
   void move(Instance& rhs, uint64_t length) override;
   Reservation reserveForRead() override;
   ReservationSingleSlice reserveSingleSlice(uint64_t length, bool separate_slice = false) override;
   ssize_t search(const void* data, uint64_t size, size_t start, size_t length) const override;
   bool startsWith(absl::string_view data) const override;
   std::string toString() const override;
 
   // LibEventInstance
   void postProcess() override;
 
   /**
    * Create a new slice at the end of the buffer, and copy the supplied content into it.
    * @param data start of the content to copy.
    *
    */
   virtual void appendSliceForTest(const void* data, uint64_t size);
 
   /**
    * Create a new slice at the end of the buffer, and copy the supplied string into it.
    * @param data the string to append to the buffer.
    */
   virtual void appendSliceForTest(absl::string_view data);
 
   /**
    * @return the BufferMemoryAccount bound to this buffer, if any.
    */
   BufferMemoryAccountSharedPtr getAccountForTest();
 
   // Does not implement watermarking.
   // TODO(antoniovicente) Implement watermarks by merging the OwnedImpl and WatermarkBuffer
   // implementations. Also, make high-watermark config a constructor argument.
   void setWatermarks(uint32_t) override { ASSERT(false, "watermarks not implemented."); }
   uint32_t highWatermark() const override { return 0; }
   bool highWatermarkTriggered() const override { return false; }
 
   /**
    * Describe the in-memory representation of the slices in the buffer. For use
    * in tests that want to make assertions about the specific arrangement of
    * bytes in the buffer.
    */
   std::vector<Slice::SliceRepresentation> describeSlicesForTest() const;
 
   /**
    * Create a reservation for reading with a non-default length. Used in benchmark tests.
    */
   Reservation reserveForReadWithLengthForTest(uint64_t length) {
     return reserveWithMaxLength(length);
   }
 
   size_t addFragments(absl::Span<const absl::string_view> fragments) override;
diff --git a/source/common/network/BUILD b/source/common/network/BUILD
index 07e7c37838..1f352e7e59 100644
--- a/source/common/network/BUILD
+++ b/source/common/network/BUILD
@@ -182,25 +182,24 @@ envoy_cc_library(
 envoy_cc_library(
     name = "default_socket_interface_lib",
     srcs = [
         "io_socket_handle_impl.cc",
         "socket_interface_impl.cc",
         "win32_socket_handle_impl.cc",
     ],
     hdrs = [
         "io_socket_handle_impl.h",
         "socket_interface_impl.h",
         "win32_socket_handle_impl.h",
     ],
     deps = [
         ":address_lib",
         ":io_socket_error_lib",
         ":socket_interface_lib",
         ":socket_lib",
         "//envoy/event:dispatcher_interface",
         "//envoy/network:io_handle_interface",
         "//source/common/api:os_sys_calls_lib",
-        "//source/common/buffer:buffer_lib",
         "//source/common/event:dispatcher_includes",
         "@envoy_api//envoy/extensions/network/socket_interface/v3:pkg_cc_proto",
     ],
 )
diff --git a/source/common/network/win32_socket_handle_impl.cc b/source/common/network/win32_socket_handle_impl.cc
index 986562d339..c74f514469 100644
--- a/source/common/network/win32_socket_handle_impl.cc
+++ b/source/common/network/win32_socket_handle_impl.cc
@@ -18,22 +18,14 @@ namespace Network {
 
 Api::IoCallUint64Result Win32SocketHandleImpl::readv(uint64_t max_length, Buffer::RawSlice* slices,
                                                      uint64_t num_slice) {
-  if (peek_buffer_.length() != 0) {
-    return readvFromPeekBuffer(max_length, slices, num_slice);
-  }
-
   auto result = IoSocketHandleImpl::readv(max_length, slices, num_slice);
   reEnableEventBasedOnIOResult(result, Event::FileReadyType::Read);
   return result;
 }
 
 Api::IoCallUint64Result Win32SocketHandleImpl::read(Buffer::Instance& buffer,
                                                     absl::optional<uint64_t> max_length_opt) {
-  if (peek_buffer_.length() != 0) {
-    return readFromPeekBuffer(buffer, max_length_opt.value_or(UINT64_MAX));
-  }
-
   auto result = IoSocketHandleImpl::read(buffer, max_length_opt);
   reEnableEventBasedOnIOResult(result, Event::FileReadyType::Read);
   return result;
 }
@@ -79,41 +71,10 @@ Api::IoCallUint64Result Win32SocketHandleImpl::recvmmsg(RawSliceArrays& slices,
 }
 
 Api::IoCallUint64Result Win32SocketHandleImpl::recv(void* buffer, size_t length, int flags) {
-  if (flags & MSG_PEEK) {
-    return emulatePeek(buffer, length);
-  }
-
-  if (peek_buffer_.length() == 0) {
-    Api::IoCallUint64Result result = IoSocketHandleImpl::recv(buffer, length, flags);
-    reEnableEventBasedOnIOResult(result, Event::FileReadyType::Read);
-    return result;
-  } else {
-    return readFromPeekBuffer(buffer, length);
-  }
-}
 
-Api::IoCallUint64Result Win32SocketHandleImpl::emulatePeek(void* buffer, size_t length) {
-  // If there's not enough data in the peek buffer, try reading more.
-  if (length > peek_buffer_.length()) {
-    // The caller is responsible for calling with the larger size
-    // in cases it needs to do so it can't rely on transparent event activation.
-    // So in this case we should activate read again unless the read blocked.
-    Api::IoCallUint64Result peek_result = drainToPeekBuffer(length);
-
-    //  Some error happened.
-    if (!peek_result.ok()) {
-      if (peek_result.wouldBlock() && file_event_) {
-        file_event_->registerEventIfEmulatedEdge(Event::FileReadyType::Read);
-        if (peek_buffer_.length() == 0) {
-          return peek_result;
-        }
-      } else {
-        return peek_result;
-      }
-    }
-  }
-
-  return peekFromPeekBuffer(buffer, length);
+  Api::IoCallUint64Result result = IoSocketHandleImpl::recv(buffer, length, flags);
+  reEnableEventBasedOnIOResult(result, Event::FileReadyType::Read);
+  return result;
 }
 
 void Win32SocketHandleImpl::reEnableEventBasedOnIOResult(const Api::IoCallUint64Result& result,
@@ -123,69 +84,5 @@ void Win32SocketHandleImpl::reEnableEventBasedOnIOResult(const Api::IoCallUint64
   }
 }
 
-Api::IoCallUint64Result Win32SocketHandleImpl::drainToPeekBuffer(size_t length) {
-  size_t total_bytes_read = 0;
-  while (peek_buffer_.length() < length) {
-    Buffer::Reservation reservation = peek_buffer_.reserveForRead();
-    uint64_t bytes_to_read = std::min<uint64_t>(
-        static_cast<uint64_t>(length - peek_buffer_.length()), reservation.length());
-    Api::IoCallUint64Result result =
-        IoSocketHandleImpl::readv(bytes_to_read, reservation.slices(), reservation.numSlices());
-    uint64_t bytes_to_commit = result.ok() ? result.return_value_ : 0;
-    reservation.commit(bytes_to_commit);
-    total_bytes_read += bytes_to_commit;
-    if (!result.ok() || bytes_to_commit == 0) {
-      return result;
-    }
-  }
-  return Api::IoCallUint64Result(total_bytes_read, Api::IoErrorPtr(nullptr, [](Api::IoError*) {}));
-}
-
-Api::IoCallUint64Result Win32SocketHandleImpl::readFromPeekBuffer(void* buffer, size_t length) {
-  uint64_t copy_size = std::min(peek_buffer_.length(), static_cast<uint64_t>(length));
-  peek_buffer_.copyOut(0, copy_size, buffer);
-  peek_buffer_.drain(copy_size);
-  return Api::IoCallUint64Result(copy_size, Api::IoErrorPtr(nullptr, [](Api::IoError*) {}));
-}
-
-Api::IoCallUint64Result Win32SocketHandleImpl::readvFromPeekBuffer(uint64_t max_length,
-                                                                   Buffer::RawSlice* slices,
-                                                                   uint64_t num_slice) {
-  uint64_t bytes_read = peek_buffer_.copyOutToSlices(max_length, slices, num_slice);
-  peek_buffer_.drain(bytes_read);
-  return Api::IoCallUint64Result(bytes_read, Api::IoErrorPtr(nullptr, [](Api::IoError*) {}));
-}
-
-Api::IoCallUint64Result Win32SocketHandleImpl::readFromPeekBuffer(Buffer::Instance& buffer,
-                                                                  size_t length) {
-  auto lenght_to_move = std::min(peek_buffer_.length(), static_cast<uint64_t>(length));
-  buffer.move(peek_buffer_, lenght_to_move);
-  return Api::IoCallUint64Result(lenght_to_move, Api::IoErrorPtr(nullptr, [](Api::IoError*) {}));
-}
-
-Api::IoCallUint64Result Win32SocketHandleImpl::peekFromPeekBuffer(void* buffer, size_t length) {
-  uint64_t copy_size = std::min(peek_buffer_.length(), static_cast<uint64_t>(length));
-  peek_buffer_.copyOut(0, copy_size, buffer);
-  return Api::IoCallUint64Result(copy_size, Api::IoErrorPtr(nullptr, [](Api::IoError*) {}));
-}
-
-void Win32SocketHandleImpl::initializeFileEvent(Event::Dispatcher& dispatcher,
-                                                Event::FileReadyCb cb,
-                                                Event::FileTriggerType trigger, uint32_t events) {
-  IoSocketHandleImpl::initializeFileEvent(dispatcher, cb, trigger, events);
-  // Activate the file event directly when we have the data in the peek_buffer_.
-  if ((events & Event::FileReadyType::Read) && peek_buffer_.length() > 0) {
-    activateFileEvents(Event::FileReadyType::Read);
-  }
-}
-
-void Win32SocketHandleImpl::enableFileEvents(uint32_t events) {
-  IoSocketHandleImpl::enableFileEvents(events);
-  // Activate the file event directly when we have the data in the peek_buffer_.
-  if ((events & Event::FileReadyType::Read) && peek_buffer_.length() > 0) {
-    activateFileEvents(Event::FileReadyType::Read);
-  }
-}
-
 } // namespace Network
 } // namespace Envoy
diff --git a/source/common/network/win32_socket_handle_impl.h b/source/common/network/win32_socket_handle_impl.h
index f8835e5aed..b9465f71db 100644
--- a/source/common/network/win32_socket_handle_impl.h
+++ b/source/common/network/win32_socket_handle_impl.h
@@ -1,12 +1,11 @@
 #pragma once
 
 #include "envoy/api/io_error.h"
 #include "envoy/api/os_sys_calls.h"
 #include "envoy/common/platform.h"
 #include "envoy/event/dispatcher.h"
 #include "envoy/network/io_handle.h"
 
-#include "source/common/buffer/buffer_impl.h"
 #include "source/common/common/logger.h"
 #include "source/common/network/io_socket_error_impl.h"
 #include "source/common/network/io_socket_handle_impl.h"
@@ -21,59 +20,30 @@ class Win32SocketHandleImpl : public IoSocketHandleImpl {
 public:
   explicit Win32SocketHandleImpl(os_fd_t fd = INVALID_SOCKET, bool socket_v6only = false,
                                  absl::optional<int> domain = absl::nullopt)
       : IoSocketHandleImpl(fd, socket_v6only, domain) {}
 
   Api::IoCallUint64Result readv(uint64_t max_length, Buffer::RawSlice* slices,
                                 uint64_t num_slice) override;
   Api::IoCallUint64Result read(Buffer::Instance& buffer,
                                absl::optional<uint64_t> max_length) override;
 
   Api::IoCallUint64Result writev(const Buffer::RawSlice* slices, uint64_t num_slice) override;
 
   Api::IoCallUint64Result write(Buffer::Instance& buffer) override;
 
   Api::IoCallUint64Result sendmsg(const Buffer::RawSlice* slices, uint64_t num_slice, int flags,
                                   const Address::Ip* self_ip,
                                   const Address::Instance& peer_address) override;
 
   Api::IoCallUint64Result recvmsg(Buffer::RawSlice* slices, const uint64_t num_slice,
                                   uint32_t self_port, RecvMsgOutput& output) override;
 
   Api::IoCallUint64Result recvmmsg(RawSliceArrays& slices, uint32_t self_port,
                                    RecvMsgOutput& output) override;
   Api::IoCallUint64Result recv(void* buffer, size_t length, int flags) override;
 
-  void initializeFileEvent(Event::Dispatcher& dispatcher, Event::FileReadyCb cb,
-                           Event::FileTriggerType trigger, uint32_t events) override;
-  void enableFileEvents(uint32_t events) override;
-
 private:
   void reEnableEventBasedOnIOResult(const Api::IoCallUint64Result& result, uint32_t event);
-
-  // On Windows we use the MSG_PEEK on recv instead of peeking the socket
-  // we drain the socket to memory. Subsequent read calls need to read
-  // first from the class buffer and then go to the underlying socket.
-
-  // Implement the peek logic of recv for readability purposes
-  Api::IoCallUint64Result emulatePeek(void* buffer, size_t length);
-
-  /**
-   * Drain the socket into `peek_buffer_`.
-   * @param length is the desired length of data drained into the `peek_buffer_`.
-   * @return the actual length of data drained into the `peek_buffer_`.
-   */
-  Api::IoCallUint64Result drainToPeekBuffer(size_t length);
-
-  // Useful functions to read from the peek buffer based on
-  // the signatures of readv/read/recv OS socket functions.
-  Api::IoCallUint64Result readFromPeekBuffer(void* buffer, size_t length);
-  Api::IoCallUint64Result readFromPeekBuffer(Buffer::Instance& buffer, size_t length);
-  Api::IoCallUint64Result readvFromPeekBuffer(uint64_t max_length, Buffer::RawSlice* slices,
-                                              uint64_t num_slice);
-  Api::IoCallUint64Result peekFromPeekBuffer(void* buffer, size_t length);
-
-  // For windows mimic MSG_PEEK
-  Buffer::OwnedImpl peek_buffer_;
 };
 } // namespace Network
 } // namespace Envoy
diff --git a/test/common/buffer/buffer_corpus/basic b/test/common/buffer/buffer_corpus/basic
index 9f32b6d0bc..9fd31255e2 100644
--- a/test/common/buffer/buffer_corpus/basic
+++ b/test/common/buffer/buffer_corpus/basic
@@ -25,11 +25,8 @@ actions {
   copy_out {
     start: 7
     length: 200
   }
 }
-actions {
-  copy_out_to_slices: 200
-}
 actions {
   drain: 98
 }
diff --git a/test/common/buffer/buffer_fuzz.cc b/test/common/buffer/buffer_fuzz.cc
index 918c4e0d49..5fe4309c0b 100644
--- a/test/common/buffer/buffer_fuzz.cc
+++ b/test/common/buffer/buffer_fuzz.cc
@@ -70,169 +70,154 @@ class StringBuffer : public Buffer::Instance {
 public:
   void addDrainTracker(std::function<void()> drain_tracker) override {
     // Not implemented well.
     ASSERT(false);
     drain_tracker();
   }
 
   void bindAccount(Buffer::BufferMemoryAccountSharedPtr) override {
     // Not implemented.
     ASSERT(false);
   }
 
   void add(const void* data, uint64_t size) override {
     FUZZ_ASSERT(start_ + size_ + size <= data_.size());
     ::memcpy(mutableEnd(), data, size);
     size_ += size;
   }
 
   void addBufferFragment(Buffer::BufferFragment& fragment) override {
     add(fragment.data(), fragment.size());
     fragment.done();
   }
 
   void add(absl::string_view data) override { add(data.data(), data.size()); }
 
   void add(const Buffer::Instance& data) override {
     const StringBuffer& src = dynamic_cast<const StringBuffer&>(data);
     add(src.start(), src.size_);
   }
 
   void prepend(absl::string_view data) override {
     FUZZ_ASSERT(start_ >= data.size());
     start_ -= data.size();
     size_ += data.size();
     ::memcpy(mutableStart(), data.data(), data.size());
   }
 
   void prepend(Instance& data) override {
     StringBuffer& src = dynamic_cast<StringBuffer&>(data);
     prepend(src.asStringView());
     src.size_ = 0;
   }
 
   void copyOut(size_t start, uint64_t size, void* data) const override {
     ::memcpy(data, this->start() + start, size);
   }
 
-  uint64_t copyOutToSlices(uint64_t length, Buffer::RawSlice* slices,
-                           uint64_t num_slices) const override {
-    uint64_t size_copied = 0;
-    uint64_t num_slices_copied = 0;
-    while (size_copied < length && num_slices_copied < num_slices) {
-      auto copy_length = std::min((length - size_copied), slices[num_slices_copied].len_);
-      ::memcpy(slices[num_slices_copied].mem_, this->start(), copy_length);
-      size_copied += copy_length;
-      if (copy_length == slices[num_slices_copied].len_) {
-        num_slices_copied++;
-      }
-    }
-    return size_copied;
-  }
-
   void drain(uint64_t size) override {
     FUZZ_ASSERT(size <= size_);
     start_ += size;
     size_ -= size;
   }
 
   Buffer::RawSliceVector
   getRawSlices(absl::optional<uint64_t> max_slices = absl::nullopt) const override {
     ASSERT(!max_slices.has_value() || max_slices.value() >= 1);
     return {{const_cast<char*>(start()), size_}};
   }
 
   Buffer::RawSlice frontSlice() const override { return {const_cast<char*>(start()), size_}; }
 
   uint64_t length() const override { return size_; }
 
   void* linearize(uint32_t /*size*/) override {
     // Sketchy, but probably will work for test purposes.
     return mutableStart();
   }
 
   Buffer::SliceDataPtr extractMutableFrontSlice() override { PANIC("not implemented"); }
 
   void move(Buffer::Instance& rhs) override { move(rhs, rhs.length()); }
 
   void move(Buffer::Instance& rhs, uint64_t length) override {
     StringBuffer& src = dynamic_cast<StringBuffer&>(rhs);
     add(src.start(), length);
     src.start_ += length;
     src.size_ -= length;
   }
 
   Buffer::Reservation reserveForRead() override {
     auto reservation = Buffer::Reservation::bufferImplUseOnlyConstruct(*this);
     Buffer::RawSlice slice;
     slice.mem_ = mutableEnd();
     slice.len_ = data_.size() - (start_ + size_);
     reservation.bufferImplUseOnlySlices().push_back(slice);
     reservation.bufferImplUseOnlySetLength(slice.len_);
 
     return reservation;
   }
 
   Buffer::ReservationSingleSlice reserveSingleSlice(uint64_t length, bool separate_slice) override {
     ASSERT(!separate_slice);
     FUZZ_ASSERT(start_ + size_ + length <= data_.size());
 
     auto reservation = Buffer::ReservationSingleSlice::bufferImplUseOnlyConstruct(*this);
     Buffer::RawSlice slice;
     slice.mem_ = mutableEnd();
     slice.len_ = length;
     reservation.bufferImplUseOnlySlice() = slice;
 
     return reservation;
   }
 
   void commit(uint64_t length, absl::Span<Buffer::RawSlice>,
               Buffer::ReservationSlicesOwnerPtr) override {
     FUZZ_ASSERT(start_ + size_ + length <= data_.size());
     size_ += length;
   }
 
   ssize_t search(const void* data, uint64_t size, size_t start, size_t length) const override {
     UNREFERENCED_PARAMETER(length);
     return asStringView().find({static_cast<const char*>(data), size}, start);
   }
 
   bool startsWith(absl::string_view data) const override {
     return absl::StartsWith(asStringView(), data);
   }
 
   std::string toString() const override { return std::string(data_.data() + start_, size_); }
 
   size_t addFragments(absl::Span<const absl::string_view> fragments) override {
     size_t total_size_to_write = 0;
 
     for (const auto& fragment : fragments) {
       total_size_to_write += fragment.size();
       add(fragment.data(), fragment.size());
     }
     return total_size_to_write;
   }
 
   void setWatermarks(uint32_t) override {
     // Not implemented.
     // TODO(antoniovicente) Implement and add fuzz coverage as we merge the Buffer::OwnedImpl and
     // WatermarkBuffer implementations.
     ASSERT(false);
   }
 
   uint32_t highWatermark() const override { return 0; }
   bool highWatermarkTriggered() const override { return false; }
 
   absl::string_view asStringView() const { return {start(), size_}; }
 
   char* mutableStart() { return data_.data() + start_; }
 
   const char* start() const { return data_.data() + start_; }
 
   char* mutableEnd() { return mutableStart() + size_; }
 
   const char* end() const { return start() + size_; }
 
   std::array<char, 2 * TotalMaxAllocation> data_;
   uint32_t start_{TotalMaxAllocation};
   uint32_t size_{0};
 };
@@ -242,232 +227,220 @@ using BufferList = std::vector<std::unique_ptr<Buffer::Instance>>;
 // Process a single buffer operation.
 uint32_t bufferAction(Context& ctxt, char insert_value, uint32_t max_alloc, BufferList& buffers,
                       const test::common::buffer::Action& action) {
   const uint32_t target_index = action.target_index() % BufferCount;
   Buffer::Instance& target_buffer = *buffers[target_index];
   uint32_t allocated = 0;
 
   switch (action.action_selector_case()) {
   case test::common::buffer::Action::kAddBufferFragment: {
     const uint32_t size = clampSize(action.add_buffer_fragment(), max_alloc);
     allocated += size;
     void* p = ::malloc(size);
     FUZZ_ASSERT(p != nullptr);
     ::memset(p, insert_value, size);
     auto fragment =
         std::make_unique<Buffer::BufferFragmentImpl>(p, size, releaseFragmentAllocation);
     ctxt.fragments_.emplace_back(std::move(fragment));
     target_buffer.addBufferFragment(*ctxt.fragments_.back());
     break;
   }
   case test::common::buffer::Action::kAddString: {
     const uint32_t size = clampSize(action.add_string(), max_alloc);
     allocated += size;
     const std::string data(size, insert_value);
     target_buffer.add(data);
     break;
   }
   case test::common::buffer::Action::kAddBuffer: {
     const uint32_t source_index = action.add_buffer() % BufferCount;
     if (target_index == source_index) {
       break;
     }
     Buffer::Instance& source_buffer = *buffers[source_index];
     if (source_buffer.length() > max_alloc) {
       break;
     }
     allocated += source_buffer.length();
     target_buffer.add(source_buffer);
     break;
   }
   case test::common::buffer::Action::kPrependString: {
     const uint32_t size = clampSize(action.prepend_string(), max_alloc);
     allocated += size;
     const std::string data(size, insert_value);
     target_buffer.prepend(data);
     break;
   }
   case test::common::buffer::Action::kPrependBuffer: {
     const uint32_t source_index = action.prepend_buffer() % BufferCount;
     if (target_index == source_index) {
       break;
     }
     Buffer::Instance& source_buffer = *buffers[source_index];
     if (source_buffer.length() > max_alloc) {
       break;
     }
     allocated += source_buffer.length();
     target_buffer.prepend(source_buffer);
     break;
   }
   case test::common::buffer::Action::kReserveCommit: {
     const uint32_t reserve_length = clampSize(action.reserve_commit().reserve_length(), max_alloc);
     allocated += reserve_length;
     if (reserve_length == 0) {
       break;
     }
     if (reserve_length < 16384) {
       auto reservation = target_buffer.reserveSingleSlice(reserve_length);
       ::memset(reservation.slice().mem_, insert_value, reservation.slice().len_);
       reservation.commit(
           std::min<uint64_t>(action.reserve_commit().commit_length(), reservation.length()));
     } else {
       Buffer::Reservation reservation = target_buffer.reserveForRead();
       for (uint32_t i = 0; i < reservation.numSlices(); ++i) {
         ::memset(reservation.slices()[i].mem_, insert_value, reservation.slices()[i].len_);
       }
       const uint32_t target_length =
           std::min<uint32_t>(reservation.length(), action.reserve_commit().commit_length());
       reservation.commit(target_length);
     }
     break;
   }
   case test::common::buffer::Action::kCopyOut: {
     const uint32_t start =
         std::min(action.copy_out().start(), static_cast<uint32_t>(target_buffer.length()));
     const uint32_t length =
         std::min(static_cast<uint32_t>(target_buffer.length() - start), action.copy_out().length());
     // Make this static to avoid potential continuous ASAN inspired allocation.
     static uint8_t copy_buffer[TotalMaxAllocation];
     target_buffer.copyOut(start, length, copy_buffer);
     const std::string data = target_buffer.toString();
     FUZZ_ASSERT(::memcmp(copy_buffer, data.data() + start, length) == 0);
     break;
   }
-  case test::common::buffer::Action::kCopyOutToSlices: {
-    const uint32_t length =
-        std::min(static_cast<uint32_t>(target_buffer.length()), action.copy_out_to_slices());
-    Buffer::OwnedImpl buffer;
-    auto reservation = buffer.reserveForRead();
-    auto rc = target_buffer.copyOutToSlices(length, reservation.slices(), reservation.numSlices());
-    reservation.commit(rc);
-    const std::string data = buffer.toString();
-    const std::string target_data = target_buffer.toString();
-    FUZZ_ASSERT(::memcmp(data.data(), target_data.data(), reservation.length()) == 0);
-    break;
-  }
   case test::common::buffer::Action::kDrain: {
     const uint32_t previous_length = target_buffer.length();
     const uint32_t drain_length =
         std::min(static_cast<uint32_t>(target_buffer.length()), action.drain());
     target_buffer.drain(drain_length);
     FUZZ_ASSERT(previous_length - drain_length == target_buffer.length());
     break;
   }
   case test::common::buffer::Action::kLinearize: {
     const uint32_t linearize_size =
         std::min(static_cast<uint32_t>(target_buffer.length()), action.linearize());
     target_buffer.linearize(linearize_size);
     break;
   }
   case test::common::buffer::Action::kMove: {
     const uint32_t source_index = action.move().source_index() % BufferCount;
     if (target_index == source_index) {
       break;
     }
     Buffer::Instance& source_buffer = *buffers[source_index];
     if (action.move().length() == 0) {
       if (source_buffer.length() > max_alloc) {
         break;
       }
       allocated += source_buffer.length();
       target_buffer.move(source_buffer);
     } else {
       const uint32_t source_length =
           std::min(static_cast<uint32_t>(source_buffer.length()), action.move().length());
       const uint32_t move_length = clampSize(max_alloc, source_length);
       if (move_length == 0) {
         break;
       }
       target_buffer.move(source_buffer, move_length);
       allocated += move_length;
     }
     break;
   }
   case test::common::buffer::Action::kRead: {
     const uint32_t max_length = clampSize(action.read(), max_alloc);
     allocated += max_length;
     if (max_length == 0) {
       break;
     }
     int pipe_fds[2] = {0, 0};
     FUZZ_ASSERT(::pipe(pipe_fds) == 0);
     Network::IoSocketHandleImpl io_handle(pipe_fds[0]);
     FUZZ_ASSERT(::fcntl(pipe_fds[0], F_SETFL, O_NONBLOCK) == 0);
     FUZZ_ASSERT(::fcntl(pipe_fds[1], F_SETFL, O_NONBLOCK) == 0);
     std::string data(max_length, insert_value);
     const ssize_t rc = ::write(pipe_fds[1], data.data(), max_length);
     FUZZ_ASSERT(rc > 0);
     Api::IoCallUint64Result result = io_handle.read(target_buffer, max_length);
     FUZZ_ASSERT(result.return_value_ == static_cast<uint64_t>(rc));
     FUZZ_ASSERT(::close(pipe_fds[1]) == 0);
     break;
   }
   case test::common::buffer::Action::kWrite: {
     int pipe_fds[2] = {0, 0};
     FUZZ_ASSERT(::pipe(pipe_fds) == 0);
     Network::IoSocketHandleImpl io_handle(pipe_fds[1]);
     FUZZ_ASSERT(::fcntl(pipe_fds[0], F_SETFL, O_NONBLOCK) == 0);
     FUZZ_ASSERT(::fcntl(pipe_fds[1], F_SETFL, O_NONBLOCK) == 0);
     uint64_t return_value;
     do {
       const bool empty = target_buffer.length() == 0;
       const std::string previous_data = target_buffer.toString();
       const auto result = io_handle.write(target_buffer);
       FUZZ_ASSERT(result.ok());
       return_value = result.return_value_;
       ENVOY_LOG_MISC(trace, "Write return_value: {} errno: {}", return_value,
                      result.err_ != nullptr ? result.err_->getErrorDetails() : "-");
       if (empty) {
         FUZZ_ASSERT(return_value == 0);
       } else {
         auto buf = std::make_unique<char[]>(return_value);
         FUZZ_ASSERT(static_cast<uint64_t>(::read(pipe_fds[0], buf.get(), return_value)) ==
                     return_value);
         FUZZ_ASSERT(::memcmp(buf.get(), previous_data.data(), return_value) == 0);
       }
     } while (return_value > 0);
     FUZZ_ASSERT(::close(pipe_fds[0]) == 0);
     break;
   }
   case test::common::buffer::Action::kGetRawSlices: {
     const uint64_t slices_needed = target_buffer.getRawSlices().size();
     const uint64_t slices_tested =
         std::min(slices_needed, static_cast<uint64_t>(action.get_raw_slices()));
     if (slices_tested == 0) {
       break;
     }
     Buffer::RawSliceVector raw_slices = target_buffer.getRawSlices(/*max_slices=*/slices_tested);
     const uint64_t slices_obtained = raw_slices.size();
     FUZZ_ASSERT(slices_obtained <= slices_needed);
     uint64_t offset = 0;
     const std::string data = target_buffer.toString();
     for (const auto& raw_slices : raw_slices) {
       FUZZ_ASSERT(::memcmp(raw_slices.mem_, data.data() + offset, raw_slices.len_) == 0);
       offset += raw_slices.len_;
     }
     FUZZ_ASSERT(slices_needed != slices_tested || offset == target_buffer.length());
     break;
   }
   case test::common::buffer::Action::kSearch: {
     const std::string& content = action.search().content();
     const uint32_t offset = action.search().offset();
     const std::string data = target_buffer.toString();
     FUZZ_ASSERT(target_buffer.search(content.data(), content.size(), offset) ==
                 static_cast<ssize_t>(target_buffer.toString().find(content, offset)));
     break;
   }
   case test::common::buffer::Action::kStartsWith: {
     const std::string data = target_buffer.toString();
     FUZZ_ASSERT(target_buffer.startsWith(action.starts_with()) ==
                 (data.find(action.starts_with()) == 0));
     break;
   }
   default:
     // Maybe nothing is set?
     break;
   }
 
   return allocated;
 }
 
 } // namespace
diff --git a/test/common/buffer/buffer_fuzz.proto b/test/common/buffer/buffer_fuzz.proto
index 91a43f5d33..a4a18cc100 100644
--- a/test/common/buffer/buffer_fuzz.proto
+++ b/test/common/buffer/buffer_fuzz.proto
@@ -27,22 +27,21 @@ message Search {
 message Action {
   uint32 target_index = 1;
   oneof action_selector {
     uint32 add_buffer_fragment = 2;
     uint32 add_string = 3;
     uint32 add_buffer = 4;
     uint32 prepend_string = 5;
     uint32 prepend_buffer = 6;
     ReserveCommit reserve_commit = 7;
     CopyOut copy_out = 8;
     uint32 drain = 9;
     uint32 linearize = 10;
     Move move = 11;
     uint32 read = 12;
     google.protobuf.Empty write = 13;
     uint32 get_raw_slices = 14;
     Search search = 15;
     string starts_with = 16;
-    uint32 copy_out_to_slices = 17;
   }
 }
 
diff --git a/test/common/buffer/owned_impl_test.cc b/test/common/buffer/owned_impl_test.cc
index b8e639d95d..7a4adc7d30 100644
--- a/test/common/buffer/owned_impl_test.cc
+++ b/test/common/buffer/owned_impl_test.cc
@@ -1,18 +1,17 @@
 #include <memory>
-#include <string>
 
 #include "envoy/api/io_error.h"
 
 #include "source/common/buffer/buffer_impl.h"
 #include "source/common/network/io_socket_handle_impl.h"
 #include "source/common/network/win32_socket_handle_impl.h"
 
 #include "test/common/buffer/utility.h"
 #include "test/mocks/api/mocks.h"
 #include "test/test_common/logging.h"
 #include "test/test_common/threadsafe_singleton_injector.h"
 #include "test/test_common/utility.h"
 
 #include "absl/strings/str_cat.h"
 #include "gmock/gmock.h"
 #include "gtest/gtest.h"
@@ -1081,101 +1080,6 @@ void TestBufferMove(uint64_t buffer1_length, uint64_t buffer2_length,
   EXPECT_EQ(0, buffer2.length());
 }
 
-TEST_F(OwnedImplTest, CopyOutToSlicesTests) {
-  std::string data = "Hello, World!";
-  Buffer::OwnedImpl buffer;
-  buffer.prepend(data);
-
-  EXPECT_EQ(data.size(), buffer.length());
-  EXPECT_EQ(data, buffer.toString());
-
-  {
-    Buffer::OwnedImpl buf;
-    auto reservation = buf.reserveSingleSlice(1024);
-    auto slice = reservation.slice();
-    EXPECT_EQ(data.size(), buffer.copyOutToSlices(100, &slice, 1));
-    reservation.commit(data.size());
-    EXPECT_EQ(data, buffer.toString());
-  }
-
-  {
-    Buffer::OwnedImpl buf;
-    auto reservation = buf.reserveSingleSlice(5);
-    auto slice = reservation.slice();
-    EXPECT_EQ(5, buffer.copyOutToSlices(100, &slice, 1));
-    reservation.commit(5);
-    EXPECT_EQ("Hello", buf.toString());
-  }
-
-  {
-    Buffer::OwnedImpl buf;
-    auto reservation = buf.reserveForRead();
-    EXPECT_EQ(5, buffer.copyOutToSlices(5, reservation.slices(), reservation.numSlices()));
-    reservation.commit(5);
-    EXPECT_EQ("Hello", buf.toString());
-  }
-
-  {
-    Buffer::OwnedImpl buf;
-    auto reservation = buf.reserveForRead();
-    EXPECT_EQ(data.size(),
-              buffer.copyOutToSlices(100, reservation.slices(), reservation.numSlices()));
-    reservation.commit(data.size());
-    EXPECT_EQ(data, buf.toString());
-  }
-  // Test the destination buffer has smaller slice than the source buffer.
-  {
-    Buffer::OwnedImpl src_buf;
-    std::string data;
-    for (auto i = 0; i < (32 * 1024); i++) {
-      data.append(std::to_string(i % 10));
-    }
-    // Build the source buffer to have a single 32KB slice.
-    src_buf.appendSliceForTest(data);
-    EXPECT_EQ(1, src_buf.getRawSlices().size());
-    EXPECT_EQ(32 * 1024, src_buf.frontSlice().len_);
-
-    Buffer::OwnedImpl dest_buf;
-    // The destination buffer are expected to have 8 Slices, each slice has 16KB buffer.
-    auto reservation = dest_buf.reserveForRead();
-    EXPECT_EQ(8, reservation.numSlices());
-    for (uint64_t i = 0; i < reservation.numSlices(); i++) {
-      EXPECT_EQ(16 * 1024, reservation.slices()[i].len_);
-    }
-
-    // Copy single 32 KB slice's data to 8 * 16KB slices.
-    EXPECT_EQ(data.size(),
-              src_buf.copyOutToSlices(32 * 1024, reservation.slices(), reservation.numSlices()));
-    reservation.commit(data.size());
-    EXPECT_EQ(data, dest_buf.toString());
-  }
-  // Test the source buffer has smaller slice than the destination buffer.
-  {
-    Buffer::OwnedImpl src_buf;
-    // Build the source buffer to have 7 slices.
-    src_buf.appendSliceForTest("He", 2);
-    src_buf.appendSliceForTest("ll", 2);
-    src_buf.appendSliceForTest("o,", 2);
-    src_buf.appendSliceForTest(" W", 2);
-    src_buf.appendSliceForTest("or", 2);
-    src_buf.appendSliceForTest("ld", 2);
-    src_buf.appendSliceForTest("!", 1);
-    Buffer::OwnedImpl dest_buf;
-    // The destination buffer are expected to have 8 Slices, each slice has 16KB buffer.
-    auto reservation = dest_buf.reserveForRead();
-    EXPECT_EQ(8, reservation.numSlices());
-    for (uint64_t i = 0; i < reservation.numSlices(); i++) {
-      EXPECT_EQ(16 * 1024, reservation.slices()[i].len_);
-    }
-
-    // Copy data from src 7 slices into the first 16K slice of dest.
-    EXPECT_EQ(data.size(),
-              src_buf.copyOutToSlices(100, reservation.slices(), reservation.numSlices()));
-    reservation.commit(data.size());
-    EXPECT_EQ(data, dest_buf.toString());
-  }
-}
-
 // Slice size large enough to prevent slice content from being coalesced into an existing slice
 constexpr uint64_t kLargeSliceSize = 2048;
 
diff --git a/test/common/network/BUILD b/test/common/network/BUILD
index 0afaf9f640..f2390df3ce 100644
--- a/test/common/network/BUILD
+++ b/test/common/network/BUILD
@@ -408,19 +408,6 @@ envoy_cc_test(
     ],
 )
 
-envoy_cc_test(
-    name = "win32_socket_handle_impl_test",
-    srcs = ["win32_socket_handle_impl_test.cc"],
-    deps = [
-        "//source/common/buffer:buffer_lib",
-        "//source/common/common:utility_lib",
-        "//source/common/network:address_lib",
-        "//test/mocks/api:api_mocks",
-        "//test/mocks/event:event_mocks",
-        "//test/test_common:threadsafe_singleton_injector_lib",
-    ],
-)
-
 envoy_cc_test(
     name = "io_socket_handle_impl_integration_test",
     srcs = ["io_socket_handle_impl_integration_test.cc"],
diff --git a/test/common/network/win32_socket_handle_impl_test.cc b/test/common/network/win32_socket_handle_impl_test.cc
deleted file mode 100644
index c06880d9f1..0000000000
--- a/test/common/network/win32_socket_handle_impl_test.cc
+++ /dev/null
@@ -1,190 +0,0 @@
-#include "source/common/common/utility.h"
-#include "source/common/network/address_impl.h"
-#include "source/common/network/io_socket_error_impl.h"
-#include "source/common/network/io_socket_handle_impl.h"
-#include "source/common/network/listen_socket_impl.h"
-
-#include "test/mocks/api/mocks.h"
-#include "test/mocks/event/mocks.h"
-#include "test/test_common/environment.h"
-#include "test/test_common/network_utility.h"
-#include "test/test_common/threadsafe_singleton_injector.h"
-
-#include "gmock/gmock.h"
-#include "gtest/gtest.h"
-
-using testing::_;
-using testing::Invoke;
-using testing::NiceMock;
-using testing::Return;
-
-namespace Envoy {
-namespace Network {
-
-class Win32SocketHandleImplTest : public testing::Test {
-public:
-  Win32SocketHandleImplTest() : io_handle_(42) {
-    dispatcher_ = std::make_unique<NiceMock<Event::MockDispatcher>>();
-    file_event_ = new NiceMock<Event::MockFileEvent>;
-    EXPECT_CALL(*dispatcher_, createFileEvent_(42, _, _, _)).WillOnce(Return(file_event_));
-    io_handle_.setBlocking(false);
-    io_handle_.initializeFileEvent(
-        *dispatcher_, [](uint32_t) -> void {}, Event::PlatformDefaultTriggerType,
-        Event::FileReadyType::Read | Event::FileReadyType::Closed);
-  }
-
-protected:
-  std::unique_ptr<NiceMock<Event::MockDispatcher>> dispatcher_;
-  NiceMock<Event::MockFileEvent>* file_event_;
-  Network::Win32SocketHandleImpl io_handle_;
-};
-
-TEST_F(Win32SocketHandleImplTest, ReadvWithNoBufferShouldReadFromTheWire) {
-
-  Api::MockOsSysCalls os_sys_calls;
-  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);
-
-  EXPECT_CALL(os_sys_calls, readv(_, _, _))
-      .Times(1)
-      .WillRepeatedly(Return(Api::SysCallSizeResult{10, 0}));
-
-  Buffer::OwnedImpl read_buffer;
-  Buffer::Reservation reservation = read_buffer.reserveForRead();
-  auto rc = io_handle_.readv(reservation.length(), reservation.slices(), reservation.numSlices());
-  EXPECT_EQ(rc.return_value_, 10);
-}
-
-TEST_F(Win32SocketHandleImplTest, ReadvShouldReenableEventsOnBlock) {
-  Api::MockOsSysCalls os_sys_calls;
-  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);
-
-  EXPECT_CALL(os_sys_calls, readv(_, _, _))
-      .Times(1)
-      .WillRepeatedly(Return(Api::SysCallSizeResult{-1, SOCKET_ERROR_AGAIN}));
-
-  EXPECT_CALL(*file_event_, registerEventIfEmulatedEdge(_));
-  Buffer::OwnedImpl read_buffer;
-  Buffer::Reservation reservation = read_buffer.reserveForRead();
-  auto rc = io_handle_.readv(reservation.length(), reservation.slices(), reservation.numSlices());
-  EXPECT_EQ(rc.return_value_, 0);
-  EXPECT_EQ(rc.err_->getErrorCode(), Api::IoError::IoErrorCode::Again);
-}
-
-TEST_F(Win32SocketHandleImplTest, ReadvWithBufferShouldReadFromBuffer) {
-  Api::MockOsSysCalls os_sys_calls;
-  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);
-  constexpr int data_length = 10;
-  std::string data(data_length, '*');
-  EXPECT_CALL(os_sys_calls, readv(_, _, _)).WillOnce(Invoke([&](os_fd_t, const iovec* iov, int) {
-    memcpy(iov->iov_base, data.data(), data_length); // NOLINT(safe-memcpy)
-    return Api::SysCallSizeResult{data_length, 0};
-  }));
-
-  absl::FixedArray<char> buf(data_length);
-  auto rc = io_handle_.recv(buf.data(), buf.size(), MSG_PEEK);
-  EXPECT_EQ(rc.return_value_, data_length);
-  EXPECT_EQ(data, std::string(buf.data(), buf.size()));
-  Buffer::OwnedImpl read_buffer;
-  Buffer::Reservation reservation = read_buffer.reserveForRead();
-  rc = io_handle_.readv(reservation.length(), reservation.slices(), reservation.numSlices());
-  EXPECT_EQ(rc.return_value_, 10);
-  reservation.commit(rc.return_value_);
-  EXPECT_EQ(data, read_buffer.toString());
-}
-
-TEST_F(Win32SocketHandleImplTest, RecvWithoutPeekShouldReadFromWire) {
-  Api::MockOsSysCalls os_sys_calls;
-  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);
-
-  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))
-      .Times(1)
-      .WillRepeatedly(Return(Api::SysCallSizeResult{10, 0}));
-
-  absl::FixedArray<char> buf(10);
-  auto rc = io_handle_.recv(buf.data(), buf.size(), 0);
-  EXPECT_EQ(rc.return_value_, 10);
-}
-
-TEST_F(Win32SocketHandleImplTest, RecvWithPeekMultipleTimes) {
-  Api::MockOsSysCalls os_sys_calls;
-  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);
-  EXPECT_CALL(os_sys_calls, readv(_, _, _))
-      .WillOnce(Invoke([&](os_fd_t, const iovec* iov, int num_iovs) {
-        size_t size_to_read = 0;
-        for (auto i = 0; i < num_iovs; i++) {
-          size_to_read += iov[i].iov_len;
-        }
-        EXPECT_EQ(10, size_to_read);
-        return Api::SysCallSizeResult{5, 0};
-      }))
-      .WillOnce(Return(Api::SysCallSizeResult{-1, SOCKET_ERROR_AGAIN}));
-
-  EXPECT_CALL(*file_event_, registerEventIfEmulatedEdge(_));
-  absl::FixedArray<char> buf(10);
-  auto rc = io_handle_.recv(buf.data(), buf.size(), MSG_PEEK);
-  EXPECT_EQ(rc.return_value_, 5);
-  EXPECT_CALL(os_sys_calls, readv(_, _, _))
-      .WillOnce(Invoke([&](os_fd_t, const iovec* iov, int num_iovs) {
-        size_t size_to_read = 0;
-        for (auto i = 0; i < num_iovs; i++) {
-          size_to_read += iov[i].iov_len;
-        }
-        EXPECT_EQ(5, size_to_read);
-        return Api::SysCallSizeResult{5, 0};
-      }));
-  auto rc2 = io_handle_.recv(buf.data(), buf.size(), MSG_PEEK);
-  EXPECT_EQ(rc2.return_value_, 10);
-}
-
-TEST_F(Win32SocketHandleImplTest, RecvWithPeekReactivatesReadOnBlock) {
-  Api::MockOsSysCalls os_sys_calls;
-  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);
-  EXPECT_CALL(os_sys_calls, readv(_, _, _))
-      .Times(1)
-      .WillOnce(Return(Api::SysCallSizeResult{-1, SOCKET_ERROR_AGAIN}));
-
-  EXPECT_CALL(*file_event_, registerEventIfEmulatedEdge(_));
-  absl::FixedArray<char> buf(10);
-  auto rc = io_handle_.recv(buf.data(), buf.size(), MSG_PEEK);
-  EXPECT_EQ(rc.err_->getErrorCode(), Api::IoError::IoErrorCode::Again);
-}
-
-TEST_F(Win32SocketHandleImplTest, RecvWithPeekFlagReturnsFinalError) {
-  Api::MockOsSysCalls os_sys_calls;
-  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);
-  constexpr int data_length = 10;
-  EXPECT_CALL(os_sys_calls, readv(_, _, _))
-      .Times(2)
-      .WillOnce(Invoke([&](os_fd_t, const iovec*, int) {
-        return Api::SysCallSizeResult{data_length / 2, 0};
-      }))
-      .WillOnce(Return(Api::SysCallSizeResult{-1, SOCKET_ERROR_CONNRESET}));
-
-  absl::FixedArray<char> buf(data_length);
-  auto rc = io_handle_.recv(buf.data(), buf.size(), MSG_PEEK);
-  EXPECT_EQ(rc.err_->getErrorCode(), Api::IoError::IoErrorCode::ConnectionReset);
-}
-
-TEST_F(Win32SocketHandleImplTest, ReadvWithPeekShouldReadFromBuffer) {
-  Api::MockOsSysCalls os_sys_calls;
-  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);
-  constexpr int data_length = 10;
-  std::string data(data_length, '*');
-  EXPECT_CALL(os_sys_calls, readv(_, _, _)).WillOnce(Invoke([&](os_fd_t, const iovec* iov, int) {
-    memcpy(iov->iov_base, data.data(), data_length); // NOLINT(safe-memcpy)
-    return Api::SysCallSizeResult{data_length, 0};
-  }));
-
-  absl::FixedArray<char> buf(data_length);
-  auto rc = io_handle_.recv(buf.data(), buf.size(), MSG_PEEK);
-  EXPECT_EQ(rc.return_value_, data_length);
-  EXPECT_EQ(data, std::string(buf.data(), buf.size()));
-  // Second call should not make a system call, it should
-  // read from memory.
-  rc = io_handle_.recv(buf.data(), buf.size(), MSG_PEEK);
-  EXPECT_EQ(rc.return_value_, data_length);
-  EXPECT_EQ(data, std::string(buf.data(), buf.size()));
-}
-
-} // namespace Network
-} // namespace Envoy
diff --git a/test/extensions/filters/listener/proxy_protocol/proxy_protocol_test.cc b/test/extensions/filters/listener/proxy_protocol/proxy_protocol_test.cc
index 4ac4dac611..7f99111dc1 100644
--- a/test/extensions/filters/listener/proxy_protocol/proxy_protocol_test.cc
+++ b/test/extensions/filters/listener/proxy_protocol/proxy_protocol_test.cc
@@ -310,75 +310,69 @@ TEST_P(ProxyProtocolTest, V2UnsupportedAF) {
 TEST_P(ProxyProtocolTest, ErrorRecv_2) {
   // A well formed v4/tcp message, no extensions, but introduce an error on recv (e.g. socket close)
   constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,
                                 0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,
                                 0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',
                                 'r',  'e',  ' ',  'd',  'a',  't',  'a'};
   Api::MockOsSysCalls os_sys_calls;
   TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);
 
-// TODO(davinci26): Mocking should not be used to provide real system calls.
-#ifdef WIN32
-  EXPECT_CALL(os_sys_calls, readv(_, _, _))
-      .Times(AnyNumber())
-      .WillRepeatedly(Return(Api::SysCallSizeResult{-1, 0}));
-#else
-  EXPECT_CALL(os_sys_calls, readv(_, _, _))
-      .Times(AnyNumber())
-      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {
-        return os_sys_calls_actual_.readv(fd, iov, iovcnt);
-      }));
-  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))
-      .Times(AnyNumber())
-      .WillRepeatedly(Return(Api::SysCallSizeResult{-1, 0}));
-#endif
+  // TODO(davinci26): Mocking should not be used to provide real system calls.
   EXPECT_CALL(os_sys_calls, connect(_, _, _))
       .Times(AnyNumber())
       .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {
         return os_sys_calls_actual_.connect(sockfd, addr, addrlen);
       }));
+  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))
+      .Times(AnyNumber())
+      .WillOnce(Return(Api::SysCallSizeResult{-1, 0}));
   EXPECT_CALL(os_sys_calls, writev(_, _, _))
       .Times(AnyNumber())
       .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {
         return os_sys_calls_actual_.writev(fd, iov, iovcnt);
       }));
+  EXPECT_CALL(os_sys_calls, readv(_, _, _))
+      .Times(AnyNumber())
+      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {
+        return os_sys_calls_actual_.readv(fd, iov, iovcnt);
+      }));
   EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))
       .Times(AnyNumber())
       .WillRepeatedly(Invoke(
           [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {
             return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)
                 .return_value_;
           }));
   EXPECT_CALL(os_sys_calls, getsockname(_, _, _))
       .Times(AnyNumber())
       .WillRepeatedly(Invoke(
           [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {
             return os_sys_calls_actual_.getsockname(sockfd, name, namelen);
           }));
   EXPECT_CALL(os_sys_calls, shutdown(_, _))
       .Times(AnyNumber())
       .WillRepeatedly(Invoke(
           [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));
   EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {
     return os_sys_calls_actual_.close(fd);
   }));
   EXPECT_CALL(os_sys_calls, accept(_, _, _))
       .Times(AnyNumber())
       .WillRepeatedly(Invoke(
           [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {
             return os_sys_calls_actual_.accept(sockfd, addr, addrlen);
           }));
   EXPECT_CALL(os_sys_calls, supportsGetifaddrs())
       .Times(AnyNumber())
       .WillRepeatedly(
           Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));
   EXPECT_CALL(os_sys_calls, getifaddrs(_))
       .Times(AnyNumber())
       .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {
         return os_sys_calls_actual_.getifaddrs(vector);
       }));
   connect(false);
   write(buffer, sizeof(buffer));
 
   errno = 0;
   expectProxyProtoError();
 }
@@ -386,74 +380,68 @@ TEST_P(ProxyProtocolTest, ErrorRecv_2) {
 TEST_P(ProxyProtocolTest, ErrorRecv_1) {
   // A well formed v4/tcp message, no extensions, but introduce an error on recv()
   constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,
                                 0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,
                                 0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',
                                 'r',  'e',  ' ',  'd',  'a',  't',  'a'};
   Api::MockOsSysCalls os_sys_calls;
   TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);
 
   // TODO(davinci26): Mocking should not be used to provide real system calls.
-#ifdef WIN32
-  EXPECT_CALL(os_sys_calls, readv(_, _, _))
-      .Times(AnyNumber())
-      .WillRepeatedly(Return(Api::SysCallSizeResult{-1, 0}));
-#else
-  EXPECT_CALL(os_sys_calls, readv(_, _, _))
-      .Times(AnyNumber())
-      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {
-        return os_sys_calls_actual_.readv(fd, iov, iovcnt);
-      }));
   EXPECT_CALL(os_sys_calls, recv(_, _, _, _))
       .Times(AnyNumber())
       .WillRepeatedly(Return(Api::SysCallSizeResult{-1, 0}));
-#endif
   EXPECT_CALL(os_sys_calls, connect(_, _, _))
       .Times(AnyNumber())
       .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {
         return os_sys_calls_actual_.connect(sockfd, addr, addrlen);
       }));
   EXPECT_CALL(os_sys_calls, writev(_, _, _))
       .Times(AnyNumber())
       .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {
         return os_sys_calls_actual_.writev(fd, iov, iovcnt);
       }));
+  EXPECT_CALL(os_sys_calls, readv(_, _, _))
+      .Times(AnyNumber())
+      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {
+        return os_sys_calls_actual_.readv(fd, iov, iovcnt);
+      }));
   EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))
       .Times(AnyNumber())
       .WillRepeatedly(Invoke(
           [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {
             return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)
                 .return_value_;
           }));
   EXPECT_CALL(os_sys_calls, getsockname(_, _, _))
       .Times(AnyNumber())
       .WillRepeatedly(Invoke(
           [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {
             return os_sys_calls_actual_.getsockname(sockfd, name, namelen);
           }));
   EXPECT_CALL(os_sys_calls, shutdown(_, _))
       .Times(AnyNumber())
       .WillRepeatedly(Invoke(
           [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));
   EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {
     return os_sys_calls_actual_.close(fd);
   }));
   EXPECT_CALL(os_sys_calls, accept(_, _, _))
       .Times(AnyNumber())
       .WillRepeatedly(Invoke(
           [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {
             return os_sys_calls_actual_.accept(sockfd, addr, addrlen);
           }));
   EXPECT_CALL(os_sys_calls, supportsGetifaddrs())
       .Times(AnyNumber())
       .WillRepeatedly(
           Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));
   EXPECT_CALL(os_sys_calls, getifaddrs(_))
       .Times(AnyNumber())
       .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {
         return os_sys_calls_actual_.getifaddrs(vector);
       }));
   connect(false);
   write(buffer, sizeof(buffer));
 
   expectProxyProtoError();
 }
@@ -816,86 +804,75 @@ TEST_P(ProxyProtocolTest, V2Fragmented3) {
 TEST_P(ProxyProtocolTest, V2Fragmented4Error) {
   // A well-formed ipv4/tcp message, delivering all of the header +1, w/ an error
   // simulated in recv() on the +1
   constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,
                                 0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,
                                 0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',
                                 'r',  'e',  ' ',  'd',  'a',  't',  'a'};
 
   Api::MockOsSysCalls os_sys_calls;
   TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);
 
   // TODO(davinci26): Mocking should not be used to provide real system calls.
-#ifdef WIN32
-  EXPECT_CALL(os_sys_calls, readv(_, _, _))
-      .Times(AnyNumber())
-      .WillOnce(Invoke([&](os_fd_t fd, const iovec* iov, int num_iov) {
-        const Api::SysCallSizeResult x = os_sys_calls_actual_.readv(fd, iov, num_iov);
-        return x;
-      }))
-      .WillRepeatedly(Return(Api::SysCallSizeResult{-1, 0}));
-#else
   EXPECT_CALL(os_sys_calls, recv(_, _, _, _))
       .Times(AnyNumber())
       .WillRepeatedly(Invoke([this](os_fd_t fd, void* buf, size_t len, int flags) {
         return os_sys_calls_actual_.recv(fd, buf, len, flags);
       }));
   EXPECT_CALL(os_sys_calls, recv(_, _, 1, _))
       .Times(AnyNumber())
       .WillOnce(Return(Api::SysCallSizeResult{-1, 0}));
-
-  EXPECT_CALL(os_sys_calls, readv(_, _, _))
-      .Times(AnyNumber())
-      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {
-        return os_sys_calls_actual_.readv(fd, iov, iovcnt);
-      }));
-#endif
   EXPECT_CALL(os_sys_calls, connect(_, _, _))
       .Times(AnyNumber())
       .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {
         return os_sys_calls_actual_.connect(sockfd, addr, addrlen);
       }));
   EXPECT_CALL(os_sys_calls, writev(_, _, _))
       .Times(AnyNumber())
       .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {
         return os_sys_calls_actual_.writev(fd, iov, iovcnt);
       }));
+  EXPECT_CALL(os_sys_calls, readv(_, _, _))
+      .Times(AnyNumber())
+      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {
+        return os_sys_calls_actual_.readv(fd, iov, iovcnt);
+      }));
   EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))
       .Times(AnyNumber())
       .WillRepeatedly(Invoke(
           [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {
             return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)
                 .return_value_;
           }));
   EXPECT_CALL(os_sys_calls, getsockname(_, _, _))
       .Times(AnyNumber())
       .WillRepeatedly(Invoke(
           [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {
             return os_sys_calls_actual_.getsockname(sockfd, name, namelen);
           }));
   EXPECT_CALL(os_sys_calls, shutdown(_, _))
       .Times(AnyNumber())
       .WillRepeatedly(Invoke(
           [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));
   EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {
     return os_sys_calls_actual_.close(fd);
   }));
   EXPECT_CALL(os_sys_calls, accept(_, _, _))
       .Times(AnyNumber())
       .WillRepeatedly(Invoke(
           [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {
             return os_sys_calls_actual_.accept(sockfd, addr, addrlen);
           }));
   EXPECT_CALL(os_sys_calls, supportsGetifaddrs())
       .Times(AnyNumber())
       .WillRepeatedly(
           Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));
   EXPECT_CALL(os_sys_calls, getifaddrs(_))
       .Times(AnyNumber())
       .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {
         return os_sys_calls_actual_.getifaddrs(vector);
       }));
   connect(false);
   write(buffer, 17);
 
   expectProxyProtoError();
 }
@@ -903,95 +880,77 @@ TEST_P(ProxyProtocolTest, V2Fragmented4Error) {
 TEST_P(ProxyProtocolTest, V2Fragmented5Error) {
   // A well-formed ipv4/tcp message, part of the signature with an error introduced
   // in recv() on the remainder
   constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,
                                 0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,
                                 0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',
                                 'r',  'e',  ' ',  'd',  'a',  't',  'a'};
 
   Api::MockOsSysCalls os_sys_calls;
   TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);
 
   // TODO(davinci26): Mocking should not be used to provide real system calls.
-#ifdef WIN32
-  bool partial_write = false;
-  EXPECT_CALL(os_sys_calls, readv(_, _, _))
-      .Times(AnyNumber())
-      .WillRepeatedly(Invoke([&](os_fd_t fd, const iovec* iov, int num_iov) {
-        if (partial_write) {
-          ENVOY_LOG_MISC(debug, "inject failure");
-          return Api::SysCallSizeResult{-1, 0};
-        }
-        ENVOY_LOG_MISC(debug, "wire");
-        const Api::SysCallSizeResult x = os_sys_calls_actual_.readv(fd, iov, num_iov);
-        return x;
-      }));
-#else
   EXPECT_CALL(os_sys_calls, recv(_, _, _, _))
       .Times(AnyNumber())
       .WillRepeatedly(Invoke([this](os_fd_t fd, void* buf, size_t len, int flags) {
         return os_sys_calls_actual_.recv(fd, buf, len, flags);
       }));
   EXPECT_CALL(os_sys_calls, recv(_, _, 4, _))
       .Times(AnyNumber())
       .WillOnce(Return(Api::SysCallSizeResult{-1, 0}));
-  EXPECT_CALL(os_sys_calls, readv(_, _, _))
-      .Times(AnyNumber())
-      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {
-        return os_sys_calls_actual_.readv(fd, iov, iovcnt);
-      }));
-#endif
   EXPECT_CALL(os_sys_calls, connect(_, _, _))
       .Times(AnyNumber())
       .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {
         return os_sys_calls_actual_.connect(sockfd, addr, addrlen);
       }));
   EXPECT_CALL(os_sys_calls, writev(_, _, _))
       .Times(AnyNumber())
       .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {
         return os_sys_calls_actual_.writev(fd, iov, iovcnt);
       }));
+  EXPECT_CALL(os_sys_calls, readv(_, _, _))
+      .Times(AnyNumber())
+      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {
+        return os_sys_calls_actual_.readv(fd, iov, iovcnt);
+      }));
   EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))
       .Times(AnyNumber())
       .WillRepeatedly(Invoke(
           [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {
             return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)
                 .return_value_;
           }));
   EXPECT_CALL(os_sys_calls, getsockname(_, _, _))
       .Times(AnyNumber())
       .WillRepeatedly(Invoke(
           [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {
             return os_sys_calls_actual_.getsockname(sockfd, name, namelen);
           }));
   EXPECT_CALL(os_sys_calls, shutdown(_, _))
       .Times(AnyNumber())
       .WillRepeatedly(Invoke(
           [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));
   EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {
     return os_sys_calls_actual_.close(fd);
   }));
   EXPECT_CALL(os_sys_calls, accept(_, _, _))
       .Times(AnyNumber())
       .WillRepeatedly(Invoke(
           [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {
             return os_sys_calls_actual_.accept(sockfd, addr, addrlen);
           }));
   EXPECT_CALL(os_sys_calls, supportsGetifaddrs())
       .Times(AnyNumber())
       .WillRepeatedly(
           Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));
   EXPECT_CALL(os_sys_calls, getifaddrs(_))
       .Times(AnyNumber())
       .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {
         return os_sys_calls_actual_.getifaddrs(vector);
       }));
   connect(false);
   write(buffer, 10);
   dispatcher_->run(Event::Dispatcher::RunType::NonBlock);
-#ifdef WIN32
-  partial_write = true;
-#endif
   write(buffer + 10, 10);
 
   expectProxyProtoError();
 }
