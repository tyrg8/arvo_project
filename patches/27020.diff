commit c697520826d5f3e7089609c887913290f6fa55c0
Author: David Garske <david@wolfssl.com>
Date:   Fri Oct 16 15:14:02 2020 -0700

    Disable ECC key sizes < 224 bits by default. Added `--enable-eccweakcurves` or `ECC_WEAK_CURVES` to enable smaller key sizes. Currently this option is automatically enabled if `WOLFSSL_MIN_ECC_BITS` is less than 224-bits.

diff --git a/configure.ac b/configure.ac
index e832a8768..2131ed083 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1874,12 +1874,25 @@ then
         # If fastmath enabled and on x86 use speedups
         if test "x$ENABLED_FASTMATH" = "xyes" && test "$host_cpu" = "x86_64"
         then
             AM_CFLAGS="$AM_CFLAGS -DTFM_ECC192 -DTFM_ECC224 -DTFM_ECC256 -DTFM_ECC384 -DTFM_ECC521"
         fi
     fi
 fi
 
 
+# ECC Weak Key Sizes (224-bit equiv to RSA 2048 - by default disable < 224 bit ECC)
+AC_ARG_ENABLE([eccweakcurves],
+    [AS_HELP_STRING([--enable-eccweakcurves],[Enable ECC curves less than 224 bit (default: disabled)])],
+    [ ENABLED_ECCWEAKCURVES=$enableval ],
+    [ ENABLED_ECCWEAKCURVES=no ]
+    )
+
+if test "$ENABLED_ECCWEAKCURVES" = "yes"
+then
+    AM_CFLAGS="$AM_CFLAGS -DECC_WEAK_CURVES"
+fi
+
+
 # Compressed Key
 AC_ARG_ENABLE([compkey],
     [AS_HELP_STRING([--enable-compkey],[Enable compressed keys support (default: disabled)])],
@@ -6042,6 +6055,7 @@ echo "   * DH:                         $ENABLED_DH"
 echo "   * DH Default Parameters:      $ENABLED_DHDEFAULTPARAMS"
 echo "   * ECC:                        $ENABLED_ECC"
 echo "   * ECC Custom Curves           $ENABLED_ECCCUSTCURVES"
+echo "   * ECC Weak Curves             $ENABLED_ECCWEAKCURVES"
 echo "   * CURVE25519:                 $ENABLED_CURVE25519"
 echo "   * ED25519:                    $ENABLED_ED25519"
 echo "   * CURVE448:                   $ENABLED_CURVE448"
diff --git a/src/internal.c b/src/internal.c
index 458260336..04a52c94f 100644
--- a/src/internal.c
+++ b/src/internal.c
@@ -20151,1036 +20151,1036 @@ int DecodePrivateKey(WOLFSSL *ssl, word16* length)
     (void)idx;
     (void)keySz;
     (void)length;
 exit_dpk:
     return ret;
 }
 
 #endif /* WOLFSSL_TLS13 || !NO_WOLFSSL_CLIENT */
 
 #if defined(WOLFSSL_TLS13) && !defined(WOLFSSL_NO_TLS12)
     /* returns 1 if able to do TLS 1.3 otherwise 0 */
     static int TLSv1_3_Capable(WOLFSSL* ssl)
     {
     #ifndef WOLFSSL_TLS13
         return 0;
     #else
         int ret = 0;
 
         if (IsAtLeastTLSv1_3(ssl->ctx->method->version)) {
             ret = 1;
         }
 
         #ifdef OPENSSL_EXTRA
         if ((wolfSSL_get_options(ssl) & SSL_OP_NO_TLSv1_3)) {
             /* option set at run time to disable TLS 1.3 */
             ret = 0;
         }
         #endif
         return ret;
     #endif
     }
 #endif /* WOLFSSL_TLS13 */
 
 /* client only parts */
 #ifndef NO_WOLFSSL_CLIENT
 
 #ifndef WOLFSSL_NO_TLS12
 
     /* handle generation of client_hello (1) */
     int SendClientHello(WOLFSSL* ssl)
     {
         byte              *output;
         word32             length, idx = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
         int                sendSz;
         int                idSz = ssl->options.resuming
                                 ? ssl->session.sessionIDSz
                                 : 0;
         int                ret;
         word16             extSz = 0;
 
 #ifdef WOLFSSL_TLS13
         if (IsAtLeastTLSv1_3(ssl->version))
             return SendTls13ClientHello(ssl);
 #endif
 
         WOLFSSL_START(WC_FUNC_CLIENT_HELLO_SEND);
         WOLFSSL_ENTER("SendClientHello");
 
         if (ssl->suites == NULL) {
             WOLFSSL_MSG("Bad suites pointer in SendClientHello");
             return SUITES_ERROR;
         }
 
 #ifdef HAVE_SESSION_TICKET
         if (ssl->options.resuming && ssl->session.ticketLen > 0) {
             SessionTicket* ticket;
 
             ticket = TLSX_SessionTicket_Create(0, ssl->session.ticket,
                                              ssl->session.ticketLen, ssl->heap);
             if (ticket == NULL) return MEMORY_E;
 
             ret = TLSX_UseSessionTicket(&ssl->extensions, ticket, ssl->heap);
             if (ret != WOLFSSL_SUCCESS) {
                 TLSX_SessionTicket_Free(ticket, ssl->heap);
                 return ret;
             }
 
             idSz = 0;
         }
 #endif
         length = VERSION_SZ + RAN_LEN
                + idSz + ENUM_LEN
                + ssl->suites->suiteSz + SUITE_LEN
                + COMP_LEN + ENUM_LEN;
 
 #ifdef HAVE_TLS_EXTENSIONS
         /* auto populate extensions supported unless user defined */
         if ((ret = TLSX_PopulateExtensions(ssl, 0)) != 0)
             return ret;
     #ifdef HAVE_QSH
         if (QSH_Init(ssl) != 0)
             return MEMORY_E;
     #endif
         extSz = 0;
         ret = TLSX_GetRequestSize(ssl, client_hello, &extSz);
         if (ret != 0)
             return ret;
         length += extSz;
 #else
         if (IsAtLeastTLSv1_2(ssl) && ssl->suites->hashSigAlgoSz)
             extSz += HELLO_EXT_SZ + HELLO_EXT_SIGALGO_SZ
                    + ssl->suites->hashSigAlgoSz;
 #ifdef HAVE_EXTENDED_MASTER
         if (ssl->options.haveEMS)
             extSz += HELLO_EXT_SZ;
 #endif
         if (extSz != 0)
             length += extSz + HELLO_EXT_SZ_SZ;
 #endif
         sendSz = length + HANDSHAKE_HEADER_SZ + RECORD_HEADER_SZ;
 
 #ifdef WOLFSSL_DTLS
         if (ssl->options.dtls) {
             length += ENUM_LEN;   /* cookie */
             if (ssl->arrays->cookieSz != 0) length += ssl->arrays->cookieSz;
             sendSz  = length + DTLS_HANDSHAKE_HEADER_SZ + DTLS_RECORD_HEADER_SZ;
             idx    += DTLS_HANDSHAKE_EXTRA + DTLS_RECORD_EXTRA;
         }
 #endif
 
         if (IsEncryptionOn(ssl, 1))
             sendSz += MAX_MSG_EXTRA;
 
         /* check for available size */
         if ((ret = CheckAvailableSize(ssl, sendSz)) != 0)
             return ret;
 
         /* get output buffer */
         output = ssl->buffers.outputBuffer.buffer +
                  ssl->buffers.outputBuffer.length;
 
         AddHeaders(output, length, client_hello, ssl);
 
         /* client hello, first version */
         output[idx++] = ssl->version.major;
         output[idx++] = ssl->version.minor;
         ssl->chVersion = ssl->version;  /* store in case changed */
 
         /* then random */
         if (ssl->options.connectState == CONNECT_BEGIN) {
             ret = wc_RNG_GenerateBlock(ssl->rng, output + idx, RAN_LEN);
             if (ret != 0)
                 return ret;
 
             /* store random */
             XMEMCPY(ssl->arrays->clientRandom, output + idx, RAN_LEN);
         } else {
 #ifdef WOLFSSL_DTLS
             /* send same random on hello again */
             XMEMCPY(output + idx, ssl->arrays->clientRandom, RAN_LEN);
 #endif
         }
         idx += RAN_LEN;
 
         /* then session id */
         output[idx++] = (byte)idSz;
         if (idSz) {
             XMEMCPY(output + idx, ssl->session.sessionID,
                                                       ssl->session.sessionIDSz);
             idx += ssl->session.sessionIDSz;
         }
 
         /* then DTLS cookie */
 #ifdef WOLFSSL_DTLS
         if (ssl->options.dtls) {
             byte cookieSz = ssl->arrays->cookieSz;
 
             output[idx++] = cookieSz;
             if (cookieSz) {
                 XMEMCPY(&output[idx], ssl->arrays->cookie, cookieSz);
                 idx += cookieSz;
             }
         }
 #endif
         /* then cipher suites */
         c16toa(ssl->suites->suiteSz, output + idx);
         idx += OPAQUE16_LEN;
         XMEMCPY(output + idx, &ssl->suites->suites, ssl->suites->suiteSz);
         idx += ssl->suites->suiteSz;
 
         /* last, compression */
         output[idx++] = COMP_LEN;
         if (ssl->options.usingCompression)
             output[idx++] = ZLIB_COMPRESSION;
         else
             output[idx++] = NO_COMPRESSION;
 
 #ifdef HAVE_TLS_EXTENSIONS
         extSz = 0;
         ret = TLSX_WriteRequest(ssl, output + idx, client_hello, &extSz);
         if (ret != 0)
             return ret;
         idx += extSz;
 
         (void)idx; /* suppress analyzer warning, keep idx current */
 #else
         if (extSz != 0) {
             c16toa(extSz, output + idx);
             idx += HELLO_EXT_SZ_SZ;
 
             if (IsAtLeastTLSv1_2(ssl)) {
                 if (ssl->suites->hashSigAlgoSz) {
                     word16 i;
                     /* extension type */
                     c16toa(HELLO_EXT_SIG_ALGO, output + idx);
                     idx += HELLO_EXT_TYPE_SZ;
                     /* extension data length */
                     c16toa(HELLO_EXT_SIGALGO_SZ + ssl->suites->hashSigAlgoSz,
                            output + idx);
                     idx += HELLO_EXT_SZ_SZ;
                     /* sig algos length */
                     c16toa(ssl->suites->hashSigAlgoSz, output + idx);
                     idx += HELLO_EXT_SIGALGO_SZ;
                     for (i=0; i < ssl->suites->hashSigAlgoSz; i++, idx++) {
                         output[idx] = ssl->suites->hashSigAlgo[i];
                     }
                 }
             }
 #ifdef HAVE_EXTENDED_MASTER
             if (ssl->options.haveEMS) {
                 c16toa(HELLO_EXT_EXTMS, output + idx);
                 idx += HELLO_EXT_TYPE_SZ;
                 c16toa(0, output + idx);
                 idx += HELLO_EXT_SZ_SZ;
             }
 #endif
         }
 #endif
 
         if (IsEncryptionOn(ssl, 1)) {
             byte* input;
             int   inputSz = idx; /* build msg adds rec hdr */
             int   recordHeaderSz = RECORD_HEADER_SZ;
 
             if (ssl->options.dtls)
                 recordHeaderSz += DTLS_RECORD_EXTRA;
             inputSz -= recordHeaderSz;
             input = (byte*)XMALLOC(inputSz, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
             if (input == NULL)
                 return MEMORY_E;
 
             XMEMCPY(input, output + recordHeaderSz, inputSz);
             #ifdef WOLFSSL_DTLS
             if (IsDtlsNotSctpMode(ssl) &&
                     (ret = DtlsMsgPoolSave(ssl, input, inputSz, client_hello)) != 0) {
                 XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
                 return ret;
             }
             #endif
             sendSz = BuildMessage(ssl, output, sendSz, input, inputSz,
                                   handshake, 1, 0, 0, CUR_ORDER);
             XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
 
             if (sendSz < 0)
                 return sendSz;
         } else {
             #ifdef WOLFSSL_DTLS
                 if (IsDtlsNotSctpMode(ssl)) {
                     if ((ret = DtlsMsgPoolSave(ssl, output, sendSz, client_hello)) != 0)
                         return ret;
                 }
                 if (ssl->options.dtls)
                     DtlsSEQIncrement(ssl, CUR_ORDER);
             #endif
             ret = HashOutput(ssl, output, sendSz, 0);
             if (ret != 0)
                 return ret;
         }
 
         ssl->options.clientState = CLIENT_HELLO_COMPLETE;
 #ifdef OPENSSL_EXTRA
         ssl->cbmode = SSL_CB_MODE_WRITE;
         if (ssl->CBIS != NULL)
             ssl->CBIS(ssl, SSL_CB_CONNECT_LOOP, SSL_SUCCESS);
 #endif
 
 #if defined(WOLFSSL_CALLBACKS) || defined(OPENSSL_EXTRA)
         if (ssl->hsInfoOn) AddPacketName(ssl, "ClientHello");
         if (ssl->toInfoOn)
             AddPacketInfo(ssl, "ClientHello", handshake, output, sendSz,
                           WRITE_PROTO, ssl->heap);
 #endif
 
         ssl->buffers.outputBuffer.length += sendSz;
 
         ret = SendBuffered(ssl);
 
         WOLFSSL_LEAVE("SendClientHello", ret);
         WOLFSSL_END(WC_FUNC_CLIENT_HELLO_SEND);
 
         return ret;
     }
 
 
     /* handle processing of DTLS hello_verify_request (3) */
     static int DoHelloVerifyRequest(WOLFSSL* ssl, const byte* input,
                                     word32* inOutIdx, word32 size)
     {
         ProtocolVersion pv;
         byte            cookieSz;
         word32          begin = *inOutIdx;
 
 #ifdef WOLFSSL_CALLBACKS
         if (ssl->hsInfoOn) AddPacketName(ssl, "HelloVerifyRequest");
         if (ssl->toInfoOn) AddLateName("HelloVerifyRequest", &ssl->timeoutInfo);
 #endif
 
 #ifdef WOLFSSL_DTLS
         if (ssl->options.dtls) {
             DtlsMsgPoolReset(ssl);
         }
 #endif
 
         if (OPAQUE16_LEN + OPAQUE8_LEN > size)
             return BUFFER_ERROR;
 
         XMEMCPY(&pv, input + *inOutIdx, OPAQUE16_LEN);
         *inOutIdx += OPAQUE16_LEN;
 
         if (pv.major != DTLS_MAJOR ||
                          (pv.minor != DTLS_MINOR && pv.minor != DTLSv1_2_MINOR))
             return VERSION_ERROR;
 
         cookieSz = input[(*inOutIdx)++];
 
         if (cookieSz) {
             if ((*inOutIdx - begin) + cookieSz > size)
                 return BUFFER_ERROR;
 
 #ifdef WOLFSSL_DTLS
             if (cookieSz <= MAX_COOKIE_LEN) {
                 XMEMCPY(ssl->arrays->cookie, input + *inOutIdx, cookieSz);
                 ssl->arrays->cookieSz = cookieSz;
             }
 #endif
             *inOutIdx += cookieSz;
         }
 
         ssl->options.serverState = SERVER_HELLOVERIFYREQUEST_COMPLETE;
         return 0;
     }
 
 
     static WC_INLINE int DSH_CheckSessionId(WOLFSSL* ssl)
     {
         int ret = 0;
 
 #ifdef HAVE_SECRET_CALLBACK
         /* If a session secret callback exists, we are using that
          * key instead of the saved session key. */
         ret = ret || (ssl->sessionSecretCb != NULL);
 #endif
 
 #ifdef HAVE_SESSION_TICKET
         /* server may send blank ticket which may not be expected to indicate
          * existing one ok but will also be sending a new one */
         ret = ret || (ssl->session.ticketLen > 0);
 #endif
 
         ret = ret ||
               (ssl->options.haveSessionId && XMEMCMP(ssl->arrays->sessionID,
                                           ssl->session.sessionID, ID_LEN) == 0);
 
         return ret;
     }
 
     /* Check the version in the received message is valid and set protocol
      * version to use.
      *
      * ssl  The SSL/TLS object.
      * pv   The protocol version from the packet.
      * returns 0 on success, otherwise failure.
      */
     int CheckVersion(WOLFSSL *ssl, ProtocolVersion pv)
     {
     #ifdef WOLFSSL_TLS13_DRAFT
         if (pv.major == TLS_DRAFT_MAJOR) {
             pv.major = SSLv3_MAJOR;
             pv.minor = TLSv1_3_MINOR;
         }
     #endif
 
         #ifdef OPENSSL_EXTRA
         if (ssl->CBIS != NULL) {
             ssl->CBIS(ssl, SSL_CB_HANDSHAKE_START, SSL_SUCCESS);
         }
         #endif
 
         if (pv.minor > ssl->version.minor) {
             WOLFSSL_MSG("Server using higher version, fatal error");
             return VERSION_ERROR;
         }
         if (pv.minor < ssl->version.minor) {
             WOLFSSL_MSG("server using lower version");
 
             /* Check for downgrade attack. */
             if (!ssl->options.downgrade) {
                 WOLFSSL_MSG("\tno downgrade allowed, fatal error");
                 return VERSION_ERROR;
             }
             if (pv.minor < ssl->options.minDowngrade) {
                 WOLFSSL_MSG("\tversion below minimum allowed, fatal error");
                 return VERSION_ERROR;
             }
 
             #ifdef HAVE_SECURE_RENEGOTIATION
                 if (ssl->secure_renegotiation &&
                                          ssl->secure_renegotiation->enabled &&
                                          ssl->options.handShakeDone) {
                     WOLFSSL_MSG("Server changed version during scr");
                     return VERSION_ERROR;
                 }
             #endif
 
             /* Checks made - OK to downgrade. */
             if (pv.minor == SSLv3_MINOR) {
                 /* turn off tls */
                 WOLFSSL_MSG("\tdowngrading to SSLv3");
                 ssl->options.tls    = 0;
                 ssl->options.tls1_1 = 0;
                 ssl->version.minor  = SSLv3_MINOR;
             }
             else if (pv.minor == TLSv1_MINOR) {
                 /* turn off tls 1.1+ */
                 WOLFSSL_MSG("\tdowngrading to TLSv1");
                 ssl->options.tls1_1 = 0;
                 ssl->version.minor  = TLSv1_MINOR;
             }
             else if (pv.minor == TLSv1_1_MINOR) {
                 WOLFSSL_MSG("\tdowngrading to TLSv1.1");
                 ssl->version.minor  = TLSv1_1_MINOR;
             }
             else if (pv.minor == TLSv1_2_MINOR) {
                 WOLFSSL_MSG("    downgrading to TLSv1.2");
                 ssl->version.minor  = TLSv1_2_MINOR;
             }
         }
 
 #ifdef OPENSSL_EXTRA
         /* check if option is set to not allow the current version
          * set from either wolfSSL_set_options or wolfSSL_CTX_set_options */
         if (!ssl->options.dtls && ssl->options.downgrade &&
                 ssl->options.mask > 0) {
             if (ssl->version.minor == TLSv1_2_MINOR &&
              (ssl->options.mask & SSL_OP_NO_TLSv1_2) == SSL_OP_NO_TLSv1_2) {
                 WOLFSSL_MSG("\tOption set to not allow TLSv1.2, Downgrading");
                 ssl->version.minor = TLSv1_1_MINOR;
             }
             if (ssl->version.minor == TLSv1_1_MINOR &&
              (ssl->options.mask & SSL_OP_NO_TLSv1_1) == SSL_OP_NO_TLSv1_1) {
                 WOLFSSL_MSG("\tOption set to not allow TLSv1.1, Downgrading");
                 ssl->options.tls1_1 = 0;
                 ssl->version.minor = TLSv1_MINOR;
             }
             if (ssl->version.minor == TLSv1_MINOR &&
                 (ssl->options.mask & SSL_OP_NO_TLSv1) == SSL_OP_NO_TLSv1) {
                 WOLFSSL_MSG("\tOption set to not allow TLSv1, Downgrading");
                 ssl->options.tls    = 0;
                 ssl->options.tls1_1 = 0;
                 ssl->version.minor = SSLv3_MINOR;
             }
             if (ssl->version.minor == SSLv3_MINOR &&
                 (ssl->options.mask & SSL_OP_NO_SSLv3) == SSL_OP_NO_SSLv3) {
                 WOLFSSL_MSG("\tError, option set to not allow SSLv3");
                 return VERSION_ERROR;
             }
 
             if (ssl->version.minor < ssl->options.minDowngrade) {
                 WOLFSSL_MSG("\tversion below minimum allowed, fatal error");
                 return VERSION_ERROR;
             }
         }
 #endif
 
         return 0;
     }
 
     /* handle processing of server_hello (2) */
     int DoServerHello(WOLFSSL* ssl, const byte* input, word32* inOutIdx,
                       word32 helloSz)
     {
         byte            cs0;   /* cipher suite bytes 0, 1 */
         byte            cs1;
         ProtocolVersion pv;
         byte            compression;
         word32          i = *inOutIdx;
         word32          begin = i;
         int             ret;
 
         WOLFSSL_START(WC_FUNC_SERVER_HELLO_DO);
         WOLFSSL_ENTER("DoServerHello");
 
 #ifdef WOLFSSL_CALLBACKS
         if (ssl->hsInfoOn) AddPacketName(ssl, "ServerHello");
         if (ssl->toInfoOn) AddLateName("ServerHello", &ssl->timeoutInfo);
 #endif
 
         /* protocol version, random and session id length check */
         if (OPAQUE16_LEN + RAN_LEN + OPAQUE8_LEN > helloSz)
             return BUFFER_ERROR;
 
         /* protocol version */
         XMEMCPY(&pv, input + i, OPAQUE16_LEN);
         i += OPAQUE16_LEN;
 
         ret = CheckVersion(ssl, pv);
         if (ret != 0)
             return ret;
 
 #ifdef WOLFSSL_TLS13
         if (IsAtLeastTLSv1_3(pv)) {
             byte type = server_hello;
             return DoTls13ServerHello(ssl, input, inOutIdx, helloSz, &type);
         }
 #endif
 
         /* random */
         XMEMCPY(ssl->arrays->serverRandom, input + i, RAN_LEN);
         i += RAN_LEN;
 
         /* session id */
         ssl->arrays->sessionIDSz = input[i++];
 
         if (ssl->arrays->sessionIDSz > ID_LEN) {
             WOLFSSL_MSG("Invalid session ID size");
             ssl->arrays->sessionIDSz = 0;
             return BUFFER_ERROR;
         }
         else if (ssl->arrays->sessionIDSz) {
             if ((i - begin) + ssl->arrays->sessionIDSz > helloSz)
                 return BUFFER_ERROR;
 
             XMEMCPY(ssl->arrays->sessionID, input + i,
                                                       ssl->arrays->sessionIDSz);
             i += ssl->arrays->sessionIDSz;
             ssl->options.haveSessionId = 1;
         }
 
 
         /* suite and compression */
         if ((i - begin) + OPAQUE16_LEN + OPAQUE8_LEN > helloSz)
             return BUFFER_ERROR;
 
         cs0 = input[i++];
         cs1 = input[i++];
 
 #ifdef HAVE_SECURE_RENEGOTIATION
         if (ssl->secure_renegotiation && ssl->secure_renegotiation->enabled &&
                                          ssl->options.handShakeDone) {
             if (ssl->options.cipherSuite0 != cs0 ||
                 ssl->options.cipherSuite  != cs1) {
                 WOLFSSL_MSG("Server changed cipher suite during scr");
                 return MATCH_SUITE_ERROR;
             }
         }
 #endif
 
         ssl->options.cipherSuite0 = cs0;
         ssl->options.cipherSuite  = cs1;
         compression = input[i++];
 
 #ifndef WOLFSSL_NO_STRICT_CIPHER_SUITE
         {
             word32 idx, found = 0;
             /* confirm server_hello cipher suite is one sent in client_hello */
             for (idx = 0; idx < ssl->suites->suiteSz; idx += 2) {
                 if (ssl->suites->suites[idx]   == cs0 &&
                     ssl->suites->suites[idx+1] == cs1) {
                     found = 1;
                     break;
                 }
             }
             if (!found) {
                 WOLFSSL_MSG("ServerHello did not use cipher suite from ClientHello");
                 return MATCH_SUITE_ERROR;
             }
         }
 #endif /* !WOLFSSL_NO_STRICT_CIPHER_SUITE */
 
         if (compression != NO_COMPRESSION && !ssl->options.usingCompression) {
             WOLFSSL_MSG("Server forcing compression w/o support");
             return COMPRESSION_ERROR;
         }
 
         if (compression != ZLIB_COMPRESSION && ssl->options.usingCompression) {
             WOLFSSL_MSG("Server refused compression, turning off");
             ssl->options.usingCompression = 0;  /* turn off if server refused */
         }
 
         *inOutIdx = i;
 
 #ifdef HAVE_TLS_EXTENSIONS
         if ( (i - begin) < helloSz) {
             if (TLSX_SupportExtensions(ssl)) {
                 word16 totalExtSz;
 
                 if ((i - begin) + OPAQUE16_LEN > helloSz)
                     return BUFFER_ERROR;
 
                 ato16(&input[i], &totalExtSz);
                 i += OPAQUE16_LEN;
 
                 if ((i - begin) + totalExtSz > helloSz)
                     return BUFFER_ERROR;
 
                 if ((ret = TLSX_Parse(ssl, (byte *) input + i, totalExtSz,
                                                            server_hello, NULL)))
                     return ret;
 
                 i += totalExtSz;
                 *inOutIdx = i;
             }
             else
                 *inOutIdx = begin + helloSz; /* skip extensions */
         }
         else
             ssl->options.haveEMS = 0; /* If no extensions, no EMS */
 #else
         {
             int allowExt = 0;
             byte pendingEMS = 0;
 
             if ( (i - begin) < helloSz) {
                 if (ssl->version.major == SSLv3_MAJOR &&
                     ssl->version.minor >= TLSv1_MINOR) {
 
                     allowExt = 1;
                 }
 #ifdef WOLFSSL_DTLS
                 if (ssl->version.major == DTLS_MAJOR)
                     allowExt = 1;
 #endif
 
                 if (allowExt) {
                     word16 totalExtSz;
 
                     if ((i - begin) + OPAQUE16_LEN > helloSz)
                         return BUFFER_ERROR;
 
                     ato16(&input[i], &totalExtSz);
                     i += OPAQUE16_LEN;
 
                     if ((i - begin) + totalExtSz > helloSz)
                         return BUFFER_ERROR;
 
                     while (totalExtSz) {
                         word16 extId, extSz;
 
                         if (OPAQUE16_LEN + OPAQUE16_LEN > totalExtSz)
                             return BUFFER_ERROR;
 
                         ato16(&input[i], &extId);
                         i += OPAQUE16_LEN;
                         ato16(&input[i], &extSz);
                         i += OPAQUE16_LEN;
 
                         if (OPAQUE16_LEN + OPAQUE16_LEN + extSz > totalExtSz)
                             return BUFFER_ERROR;
 
                         if (extId == HELLO_EXT_EXTMS)
                             pendingEMS = 1;
                         else
                             i += extSz;
 
                         totalExtSz -= OPAQUE16_LEN + OPAQUE16_LEN + extSz;
                     }
 
                     *inOutIdx = i;
                 }
                 else
                     *inOutIdx = begin + helloSz; /* skip extensions */
             }
 
             if (!pendingEMS && ssl->options.haveEMS)
                 ssl->options.haveEMS = 0;
         }
 #endif
 
         ssl->options.serverState = SERVER_HELLO_COMPLETE;
 
         if (IsEncryptionOn(ssl, 0)) {
             *inOutIdx += ssl->keys.padSz;
         #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
             if (ssl->options.startedETMWrite &&
                                               ssl->specs.cipher_type == block) {
                 *inOutIdx += MacSize(ssl);
             }
         #endif
         }
 
 #ifdef HAVE_SECRET_CALLBACK
         if (ssl->sessionSecretCb != NULL) {
             int secretSz = SECRET_LEN;
             ret = ssl->sessionSecretCb(ssl, ssl->session.masterSecret,
                                               &secretSz, ssl->sessionSecretCtx);
             if (ret != 0 || secretSz != SECRET_LEN)
                 return SESSION_SECRET_CB_E;
         }
 #endif /* HAVE_SECRET_CALLBACK */
 
         ret = CompleteServerHello(ssl);
 
         WOLFSSL_LEAVE("DoServerHello", ret);
         WOLFSSL_END(WC_FUNC_SERVER_HELLO_DO);
 
         return ret;
     }
 
     int CompleteServerHello(WOLFSSL* ssl)
     {
         int ret;
 
         if (!ssl->options.resuming) {
             byte* down = ssl->arrays->serverRandom + RAN_LEN -
                                                          TLS13_DOWNGRADE_SZ - 1;
             byte  vers = ssl->arrays->serverRandom[RAN_LEN - 1];
     #ifdef WOLFSSL_TLS13
             if (TLSv1_3_Capable(ssl)) {
                 /* TLS v1.3 capable client not allowed to downgrade when
                  * connecting to TLS v1.3 capable server unless cipher suite
                  * demands it.
                  */
                 if (XMEMCMP(down, tls13Downgrade, TLS13_DOWNGRADE_SZ) == 0 &&
                                                      (vers == 0 || vers == 1)) {
                     SendAlert(ssl, alert_fatal, illegal_parameter);
                     return VERSION_ERROR;
                 }
             }
             else
     #endif
             if (ssl->ctx->method->version.major == SSLv3_MAJOR &&
                                 ssl->ctx->method->version.minor == TLSv1_2_MINOR
 #ifdef OPENSSL_EXTRA
                           && (wolfSSL_get_options(ssl) & SSL_OP_NO_TLSv1_2) == 0
 #endif
             ) {
                 /* TLS v1.2 capable client not allowed to downgrade when
                  * connecting to TLS v1.2 capable server.
                  */
                 if (XMEMCMP(down, tls13Downgrade, TLS13_DOWNGRADE_SZ) == 0 &&
                                                                     vers == 0) {
                     SendAlert(ssl, alert_fatal, illegal_parameter);
                     return VERSION_ERROR;
                 }
             }
         }
         else {
             if (DSH_CheckSessionId(ssl)) {
                 if (SetCipherSpecs(ssl) == 0) {
 
                     XMEMCPY(ssl->arrays->masterSecret,
                             ssl->session.masterSecret, SECRET_LEN);
             #ifdef NO_OLD_TLS
                     ret = DeriveTlsKeys(ssl);
             #else
                     ret = -1; /* default value */
                 #ifndef NO_TLS
                     if (ssl->options.tls)
                         ret = DeriveTlsKeys(ssl);
                 #endif
                     if (!ssl->options.tls)
                         ret = DeriveKeys(ssl);
             #endif /* NO_OLD_TLS */
                     ssl->options.serverState = SERVER_HELLODONE_COMPLETE;
 
                     return ret;
                 }
                 else {
                     WOLFSSL_MSG("Unsupported cipher suite, DoServerHello");
                     return UNSUPPORTED_SUITE;
                 }
             }
             else {
                 WOLFSSL_MSG("Server denied resumption attempt");
                 ssl->options.resuming = 0; /* server denied resumption try */
             }
         }
         return SetCipherSpecs(ssl);
     }
 
 #endif /* !WOLFSSL_NO_TLS12 */
 
 
     /* Make sure client setup is valid for this suite, true on success */
     int VerifyClientSuite(WOLFSSL* ssl)
     {
         int  havePSK = 0;
         byte first   = ssl->options.cipherSuite0;
         byte second  = ssl->options.cipherSuite;
 
         WOLFSSL_ENTER("VerifyClientSuite");
 
         #ifndef NO_PSK
             havePSK = ssl->options.havePSK;
         #endif
 
         if (CipherRequires(first, second, REQUIRES_PSK)) {
             WOLFSSL_MSG("Requires PSK");
             if (havePSK == 0) {
                 WOLFSSL_MSG("Don't have PSK");
                 return 0;
             }
         }
 
         return 1;  /* success */
     }
 
 #ifndef WOLFSSL_NO_TLS12
 
 #ifndef NO_CERTS
     /* handle processing of certificate_request (13) */
     static int DoCertificateRequest(WOLFSSL* ssl, const byte* input, word32*
                                     inOutIdx, word32 size)
     {
         word16 len;
         word32 begin = *inOutIdx;
     #ifdef OPENSSL_EXTRA
         int ret;
         WOLFSSL_X509* x509 = NULL;
         WOLFSSL_EVP_PKEY* pkey = NULL;
     #endif
 
         WOLFSSL_START(WC_FUNC_CERTIFICATE_REQUEST_DO);
         WOLFSSL_ENTER("DoCertificateRequest");
 
         #ifdef WOLFSSL_CALLBACKS
             if (ssl->hsInfoOn)
                 AddPacketName(ssl, "CertificateRequest");
             if (ssl->toInfoOn)
                 AddLateName("CertificateRequest", &ssl->timeoutInfo);
         #endif
 
         if (OPAQUE8_LEN > size)
             return BUFFER_ERROR;
 
         len = input[(*inOutIdx)++];
 
         if ((*inOutIdx - begin) + len > size)
             return BUFFER_ERROR;
 
         /* types, read in here */
         *inOutIdx += len;
 
         /* signature and hash signature algorithm */
         if (IsAtLeastTLSv1_2(ssl)) {
             if ((*inOutIdx - begin) + OPAQUE16_LEN > size)
                 return BUFFER_ERROR;
 
             ato16(input + *inOutIdx, &len);
             *inOutIdx += OPAQUE16_LEN;
 
             if ((*inOutIdx - begin) + len > size)
                 return BUFFER_ERROR;
 
             if (PickHashSigAlgo(ssl, input + *inOutIdx, len) != 0 &&
                                              ssl->buffers.certificate &&
                                              ssl->buffers.certificate->buffer) {
             #ifdef HAVE_PK_CALLBACKS
                 if (wolfSSL_CTX_IsPrivatePkSet(ssl->ctx)) {
                     WOLFSSL_MSG("Using PK for client private key");
                     return INVALID_PARAMETER;
                 }
             #endif
                 if (ssl->buffers.key && ssl->buffers.key->buffer) {
                     return INVALID_PARAMETER;
                 }
             }
             *inOutIdx += len;
     #ifdef WC_RSA_PSS
             ssl->pssAlgo = 0;
             if (ssl->suites->sigAlgo == rsa_pss_sa_algo)
                 ssl->pssAlgo |= 1 << ssl->suites->hashAlgo;
     #endif
         }
 
         /* authorities */
         if ((*inOutIdx - begin) + OPAQUE16_LEN > size)
             return BUFFER_ERROR;
 
         ato16(input + *inOutIdx, &len);
         *inOutIdx += OPAQUE16_LEN;
 
         if ((*inOutIdx - begin) + len > size)
             return BUFFER_ERROR;
 
         while (len) {
             word16 dnSz;
 
             if ((*inOutIdx - begin) + OPAQUE16_LEN > size)
                 return BUFFER_ERROR;
 
             ato16(input + *inOutIdx, &dnSz);
             *inOutIdx += OPAQUE16_LEN;
 
             if ((*inOutIdx - begin) + dnSz > size)
                 return BUFFER_ERROR;
 
             *inOutIdx += dnSz;
             len -= OPAQUE16_LEN + dnSz;
         }
 
     #ifdef OPENSSL_EXTRA
         /* call client cert callback if no cert has been loaded */
         if ((ssl->ctx->CBClientCert != NULL) &&
             (!ssl->buffers.certificate || !ssl->buffers.certificate->buffer)) {
 
             ret = ssl->ctx->CBClientCert(ssl, &x509, &pkey);
             if (ret == 1) {
                 if ((wolfSSL_use_certificate(ssl, x509) != WOLFSSL_SUCCESS) ||
                     (wolfSSL_use_PrivateKey(ssl, pkey) != WOLFSSL_SUCCESS)) {
                     return CLIENT_CERT_CB_ERROR;
                 }
                 wolfSSL_X509_free(x509);
                 wolfSSL_EVP_PKEY_free(pkey);
 
             } else if (ret < 0) {
                 return WOLFSSL_ERROR_WANT_X509_LOOKUP;
             }
         }
     #endif
 
         /* don't send client cert or cert verify if user hasn't provided
            cert and private key */
         if (ssl->buffers.certificate && ssl->buffers.certificate->buffer) {
         #ifdef HAVE_PK_CALLBACKS
             if (wolfSSL_CTX_IsPrivatePkSet(ssl->ctx)) {
                 WOLFSSL_MSG("Using PK for client private key");
                 ssl->options.sendVerify = SEND_CERT;
             }
         #endif
             if (ssl->buffers.key && ssl->buffers.key->buffer) {
                 ssl->options.sendVerify = SEND_CERT;
             }
         }
     #ifdef OPENSSL_EXTRA
         else
     #else
         else if (IsTLS(ssl))
     #endif
         {
             ssl->options.sendVerify = SEND_BLANK_CERT;
         }
 
         if (IsEncryptionOn(ssl, 0)) {
             *inOutIdx += ssl->keys.padSz;
         #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
             if (ssl->options.startedETMRead)
                 *inOutIdx += MacSize(ssl);
         #endif
         }
 
         WOLFSSL_LEAVE("DoCertificateRequest", 0);
         WOLFSSL_END(WC_FUNC_CERTIFICATE_REQUEST_DO);
 
         return 0;
     }
 #endif /* !NO_CERTS */
 
 
 #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || defined(HAVE_CURVE448)
 
     static int CheckCurveId(int tlsCurveId)
     {
         int ret = ECC_CURVE_ERROR;
 
         switch (tlsCurveId) {
-    #if defined(HAVE_ECC160) || defined(HAVE_ALL_CURVES)
+    #if (defined(HAVE_ECC160) || defined(HAVE_ALL_CURVES)) && defined(ECC_WEAK_CURVES)
         #ifndef NO_ECC_SECP
             case WOLFSSL_ECC_SECP160R1: return ECC_SECP160R1_OID;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_SECPR2
             case WOLFSSL_ECC_SECP160R2: return ECC_SECP160R2_OID;
         #endif /* HAVE_ECC_SECPR2 */
         #ifdef HAVE_ECC_KOBLITZ
             case WOLFSSL_ECC_SECP160K1: return ECC_SECP160K1_OID;
         #endif /* HAVE_ECC_KOBLITZ */
     #endif
-    #if defined(HAVE_ECC192) || defined(HAVE_ALL_CURVES)
+    #if (defined(HAVE_ECC192) || defined(HAVE_ALL_CURVES)) && defined(ECC_WEAK_CURVES)
         #ifndef NO_ECC_SECP
             case WOLFSSL_ECC_SECP192R1: return ECC_SECP192R1_OID;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_KOBLITZ
             case WOLFSSL_ECC_SECP192K1: return ECC_SECP192K1_OID;
         #endif /* HAVE_ECC_KOBLITZ */
     #endif
     #if defined(HAVE_ECC224) || defined(HAVE_ALL_CURVES)
         #ifndef NO_ECC_SECP
             case WOLFSSL_ECC_SECP224R1: return ECC_SECP224R1_OID;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_KOBLITZ
             case WOLFSSL_ECC_SECP224K1: return ECC_SECP224K1_OID;
         #endif /* HAVE_ECC_KOBLITZ */
     #endif
         #ifdef HAVE_CURVE25519
             case WOLFSSL_ECC_X25519: return ECC_X25519_OID;
         #endif
     #if !defined(NO_ECC256)  || defined(HAVE_ALL_CURVES)
         #ifndef NO_ECC_SECP
             case WOLFSSL_ECC_SECP256R1: return ECC_SECP256R1_OID;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_KOBLITZ
             case WOLFSSL_ECC_SECP256K1: return ECC_SECP256K1_OID;
         #endif /* HAVE_ECC_KOBLITZ */
         #ifdef HAVE_ECC_BRAINPOOL
             case WOLFSSL_ECC_BRAINPOOLP256R1: return ECC_BRAINPOOLP256R1_OID;
         #endif /* HAVE_ECC_BRAINPOOL */
     #endif
         #ifdef HAVE_CURVE448
             case WOLFSSL_ECC_X448: return ECC_X448_OID;
         #endif
     #if defined(HAVE_ECC384) || defined(HAVE_ALL_CURVES)
         #ifndef NO_ECC_SECP
             case WOLFSSL_ECC_SECP384R1: return ECC_SECP384R1_OID;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_BRAINPOOL
             case WOLFSSL_ECC_BRAINPOOLP384R1: return ECC_BRAINPOOLP384R1_OID;
         #endif /* HAVE_ECC_BRAINPOOL */
     #endif
     #if defined(HAVE_ECC512) || defined(HAVE_ALL_CURVES)
         #ifdef HAVE_ECC_BRAINPOOL
             case WOLFSSL_ECC_BRAINPOOLP512R1: return ECC_BRAINPOOLP512R1_OID;
         #endif /* HAVE_ECC_BRAINPOOL */
     #endif
     #if defined(HAVE_ECC521) || defined(HAVE_ALL_CURVES)
         #ifndef NO_ECC_SECP
             case WOLFSSL_ECC_SECP521R1: return ECC_SECP521R1_OID;
         #endif /* !NO_ECC_SECP */
     #endif
         }
 
         return ret;
     }
 
 #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
 
 /* Persistable DoServerKeyExchange arguments */
@@ -24657,5550 +24657,5550 @@ int SetTicket(WOLFSSL* ssl, const byte* ticket, word32 length)
 /* handle processing of session_ticket (4) */
 static int DoSessionTicket(WOLFSSL* ssl, const byte* input, word32* inOutIdx,
     word32 size)
 {
     word32 begin = *inOutIdx;
     word32 lifetime;
     word16 length;
     int    ret;
 
     if (ssl->expect_session_ticket == 0) {
         WOLFSSL_MSG("Unexpected session ticket");
         return SESSION_TICKET_EXPECT_E;
     }
 
     if (OPAQUE32_LEN > size)
         return BUFFER_ERROR;
 
     ato32(input + *inOutIdx, &lifetime);
     *inOutIdx += OPAQUE32_LEN;
 
     if ((*inOutIdx - begin) + OPAQUE16_LEN > size)
         return BUFFER_ERROR;
 
     ato16(input + *inOutIdx, &length);
     *inOutIdx += OPAQUE16_LEN;
 
     if ((*inOutIdx - begin) + length > size)
         return BUFFER_ERROR;
 
     if ((ret = SetTicket(ssl, input + *inOutIdx, length)) != 0)
         return ret;
     *inOutIdx += length;
     if (length > 0) {
         ssl->timeout = lifetime;
 #ifndef NO_SESSION_CACHE
         AddSession(ssl);
 #endif
     }
 
     if (IsEncryptionOn(ssl, 0)) {
         *inOutIdx += ssl->keys.padSz;
     #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
         if (ssl->options.startedETMRead)
             *inOutIdx += MacSize(ssl);
     #endif
     }
 
     ssl->expect_session_ticket = 0;
 
     return 0;
 }
 
 #endif /* !WOLFSSL_NO_TLS12 */
 
 #endif /* HAVE_SESSION_TICKET */
 
 #endif /* NO_WOLFSSL_CLIENT */
 
 #ifndef NO_CERTS
 
 #ifdef HAVE_PK_CALLBACKS
     int GetPrivateKeySigSize(WOLFSSL* ssl)
     {
         int sigSz = 0;
 
         if (ssl == NULL)
             return 0;
 
         switch (ssl->buffers.keyType) {
         #ifndef NO_RSA
         #ifdef WC_RSA_PSS
             case rsa_pss_sa_algo:
         #endif
             case rsa_sa_algo:
                 sigSz = ssl->buffers.keySz;
                 ssl->hsType = DYNAMIC_TYPE_RSA;
                 break;
         #endif
         #ifdef HAVE_ECC
             case ecc_dsa_sa_algo:
                 sigSz = wc_ecc_sig_size_calc(ssl->buffers.keySz);
                 ssl->hsType = DYNAMIC_TYPE_ECC;
                 break;
         #endif
         #ifdef HAVE_ED25519
             case ed25519_sa_algo:
                 sigSz = ED25519_SIG_SIZE; /* fixed known value */
                 ssl->hsType = DYNAMIC_TYPE_ED25519;
                 break;
         #endif
         #ifdef HAVE_ED448
             case ed448_sa_algo:
                 sigSz = ED448_SIG_SIZE; /* fixed known value */
                 ssl->hsType = DYNAMIC_TYPE_ED448;
                 break;
         #endif
             default:
                 break;
         }
         return sigSz;
     }
 #endif /* HAVE_PK_CALLBACKS */
 
 #endif /* NO_CERTS */
 
 #ifdef HAVE_ECC
     /* returns the WOLFSSL_* version of the curve from the OID sum */
     word16 GetCurveByOID(int oidSum) {
         switch(oidSum) {
-    #if defined(HAVE_ECC160) || defined(HAVE_ALL_CURVES)
+    #if (defined(HAVE_ECC160) || defined(HAVE_ALL_CURVES)) && defined(ECC_WEAK_CURVES)
         #ifndef NO_ECC_SECP
             case ECC_SECP160R1_OID:
                 return WOLFSSL_ECC_SECP160R1;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_SECPR2
             case ECC_SECP160R2_OID:
                 return WOLFSSL_ECC_SECP160R2;
         #endif /* HAVE_ECC_SECPR2 */
         #ifdef HAVE_ECC_KOBLITZ
             case ECC_SECP160K1_OID:
                 return WOLFSSL_ECC_SECP160K1;
         #endif /* HAVE_ECC_KOBLITZ */
     #endif
-    #if defined(HAVE_ECC192) || defined(HAVE_ALL_CURVES)
+    #if (defined(HAVE_ECC192) || defined(HAVE_ALL_CURVES)) && defined(ECC_WEAK_CURVES)
         #ifndef NO_ECC_SECP
             case ECC_SECP192R1_OID:
                 return WOLFSSL_ECC_SECP192R1;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_KOBLITZ
             case ECC_SECP192K1_OID:
                 return WOLFSSL_ECC_SECP192K1;
         #endif /* HAVE_ECC_KOBLITZ */
     #endif
     #if defined(HAVE_ECC224) || defined(HAVE_ALL_CURVES)
         #ifndef NO_ECC_SECP
             case ECC_SECP224R1_OID:
                 return WOLFSSL_ECC_SECP224R1;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_KOBLITZ
             case ECC_SECP224K1_OID:
                 return WOLFSSL_ECC_SECP224K1;
         #endif /* HAVE_ECC_KOBLITZ */
     #endif
     #if !defined(NO_ECC256)  || defined(HAVE_ALL_CURVES)
         #ifndef NO_ECC_SECP
             case ECC_SECP256R1_OID:
                 return WOLFSSL_ECC_SECP256R1;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_KOBLITZ
             case ECC_SECP256K1_OID:
                 return WOLFSSL_ECC_SECP256K1;
         #endif /* HAVE_ECC_KOBLITZ */
         #ifdef HAVE_ECC_BRAINPOOL
             case ECC_BRAINPOOLP256R1_OID:
                 return WOLFSSL_ECC_BRAINPOOLP256R1;
         #endif /* HAVE_ECC_BRAINPOOL */
     #endif
     #if defined(HAVE_ECC384) || defined(HAVE_ALL_CURVES)
         #ifndef NO_ECC_SECP
             case ECC_SECP384R1_OID:
                 return WOLFSSL_ECC_SECP384R1;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_BRAINPOOL
             case ECC_BRAINPOOLP384R1_OID:
                 return WOLFSSL_ECC_BRAINPOOLP384R1;
         #endif /* HAVE_ECC_BRAINPOOL */
     #endif
     #if defined(HAVE_ECC512) || defined(HAVE_ALL_CURVES)
         #ifdef HAVE_ECC_BRAINPOOL
             case ECC_BRAINPOOLP512R1_OID:
                 return WOLFSSL_ECC_BRAINPOOLP512R1;
         #endif /* HAVE_ECC_BRAINPOOL */
     #endif
     #if defined(HAVE_ECC521) || defined(HAVE_ALL_CURVES)
         #ifndef NO_ECC_SECP
             case ECC_SECP521R1_OID:
                 return WOLFSSL_ECC_SECP521R1;
         #endif /* !NO_ECC_SECP */
     #endif
             default:
                 WOLFSSL_MSG("Curve OID not compiled in or implemented");
                 return 0;
         }
     }
 #endif /* HAVE_ECC */
 
 
 #ifndef NO_WOLFSSL_SERVER
 
 #ifndef WOLFSSL_NO_TLS12
 
     /* handle generation of server_hello (2) */
     int SendServerHello(WOLFSSL* ssl)
     {
         int    ret;
         byte   *output;
         word16 length;
         word32 idx = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
         int    sendSz;
         byte   sessIdSz = ID_LEN;
         byte   echoId   = 0;  /* ticket echo id flag */
         byte   cacheOff = 0;  /* session cache off flag */
 
         WOLFSSL_START(WC_FUNC_SERVER_HELLO_SEND);
         WOLFSSL_ENTER("SendServerHello");
 
         length = VERSION_SZ + RAN_LEN
                + ID_LEN + ENUM_LEN
                + SUITE_LEN
                + ENUM_LEN;
 
 #ifdef HAVE_TLS_EXTENSIONS
         ret = TLSX_GetResponseSize(ssl, server_hello, &length);
         if (ret != 0)
             return ret;
     #ifdef HAVE_SESSION_TICKET
         if (ssl->options.useTicket) {
             /* echo session id sz can be 0,32 or bogus len in between */
             sessIdSz = ssl->arrays->sessionIDSz;
             if (sessIdSz > ID_LEN) {
                 WOLFSSL_MSG("Bad bogus session id len");
                 return BUFFER_ERROR;
             }
             if (!IsAtLeastTLSv1_3(ssl->version))
                 length -= (ID_LEN - sessIdSz);  /* adjust ID_LEN assumption */
             echoId = 1;
         }
     #endif /* HAVE_SESSION_TICKET */
 #else
         if (ssl->options.haveEMS) {
             length += HELLO_EXT_SZ_SZ + HELLO_EXT_SZ;
         }
 #endif
 
         /* is the session cache off at build or runtime */
 #ifdef NO_SESSION_CACHE
         cacheOff = 1;
 #else
         if (ssl->options.sessionCacheOff == 1) {
             cacheOff = 1;
         }
 #endif
 
         /* if no session cache don't send a session ID unless we're echoing
          * an ID as part of session tickets */
         if (echoId == 0 && cacheOff == 1) {
             length -= ID_LEN;    /* adjust ID_LEN assumption */
             sessIdSz = 0;
         }
 
         sendSz = length + HANDSHAKE_HEADER_SZ + RECORD_HEADER_SZ;
         #ifdef WOLFSSL_DTLS
         if (ssl->options.dtls) {
             /* Server Hello should use the same sequence number as the
              * Client Hello. */
             ssl->keys.dtls_sequence_number_hi = ssl->keys.curSeq_hi;
             ssl->keys.dtls_sequence_number_lo = ssl->keys.curSeq_lo;
             idx    += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
             sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
         }
         #endif /* WOLFSSL_DTLS */
 
         if (IsEncryptionOn(ssl, 1))
             sendSz += MAX_MSG_EXTRA;
 
         /* check for available size */
         if ((ret = CheckAvailableSize(ssl, sendSz)) != 0)
             return ret;
 
         /* get output buffer */
         output = ssl->buffers.outputBuffer.buffer +
                  ssl->buffers.outputBuffer.length;
 
         AddHeaders(output, length, server_hello, ssl);
 
         /* now write to output */
         /* first version */
         output[idx++] = (byte)ssl->version.major;
         output[idx++] = (byte)ssl->version.minor;
 
         /* then random and session id */
         if (!ssl->options.resuming) {
             /* generate random part and session id */
             ret = wc_RNG_GenerateBlock(ssl->rng, output + idx,
                 RAN_LEN + sizeof(sessIdSz) + sessIdSz);
             if (ret != 0)
                 return ret;
 
 #ifdef WOLFSSL_TLS13
             if (TLSv1_3_Capable(ssl)) {
                 /* TLS v1.3 capable server downgraded. */
                 XMEMCPY(output + idx + RAN_LEN - (TLS13_DOWNGRADE_SZ + 1),
                         tls13Downgrade, TLS13_DOWNGRADE_SZ);
                 output[idx + RAN_LEN - 1] = (byte)IsAtLeastTLSv1_2(ssl);
             }
             else
 #endif
             if (ssl->ctx->method->version.major == SSLv3_MAJOR &&
                           ssl->ctx->method->version.minor == TLSv1_2_MINOR &&
 #ifdef OPENSSL_EXTRA
                           (wolfSSL_get_options(ssl) & SSL_OP_NO_TLSv1_2) == 0 &&
 #endif
                                                        !IsAtLeastTLSv1_2(ssl)) {
                 /* TLS v1.2 capable server downgraded. */
                 XMEMCPY(output + idx + RAN_LEN - (TLS13_DOWNGRADE_SZ + 1),
                         tls13Downgrade, TLS13_DOWNGRADE_SZ);
                 output[idx + RAN_LEN - 1] = 0;
             }
 
             /* store info in SSL for later */
             XMEMCPY(ssl->arrays->serverRandom, output + idx, RAN_LEN);
             idx += RAN_LEN;
             output[idx++] = sessIdSz;
             XMEMCPY(ssl->arrays->sessionID, output + idx, sessIdSz);
             ssl->arrays->sessionIDSz = sessIdSz;
         }
         else {
             /* If resuming, use info from SSL */
             XMEMCPY(output + idx, ssl->arrays->serverRandom, RAN_LEN);
             idx += RAN_LEN;
             output[idx++] = sessIdSz;
             XMEMCPY(output + idx, ssl->arrays->sessionID, sessIdSz);
         }
         idx += sessIdSz;
 
 #ifdef SHOW_SECRETS
         {
             int j;
             printf("server random: ");
             for (j = 0; j < RAN_LEN; j++)
                 printf("%02x", ssl->arrays->serverRandom[j]);
             printf("\n");
         }
 #endif
 
         /* then cipher suite */
         output[idx++] = ssl->options.cipherSuite0;
         output[idx++] = ssl->options.cipherSuite;
 
         /* then compression */
         if (ssl->options.usingCompression)
             output[idx++] = ZLIB_COMPRESSION;
         else
             output[idx++] = NO_COMPRESSION;
 
         /* last, extensions */
 #ifdef HAVE_TLS_EXTENSIONS
         {
             word16 offset = 0;
             ret = TLSX_WriteResponse(ssl, output + idx, server_hello, &offset);
             if (ret != 0)
                 return ret;
             idx += offset;
         }
 #else
 #ifdef HAVE_EXTENDED_MASTER
         if (ssl->options.haveEMS) {
             c16toa(HELLO_EXT_SZ, output + idx);
             idx += HELLO_EXT_SZ_SZ;
 
             c16toa(HELLO_EXT_EXTMS, output + idx);
             idx += HELLO_EXT_TYPE_SZ;
             c16toa(0, output + idx);
             /*idx += HELLO_EXT_SZ_SZ;*/
             /* idx is not used after this point. uncomment the line above
              * if adding any more extensions in the future. */
         }
 #endif
 #endif
 
         if (IsEncryptionOn(ssl, 1)) {
             byte* input;
             int   inputSz = idx; /* build msg adds rec hdr */
             int   recordHeaderSz = RECORD_HEADER_SZ;
 
             if (ssl->options.dtls)
                 recordHeaderSz += DTLS_RECORD_EXTRA;
             inputSz -= recordHeaderSz;
             input = (byte*)XMALLOC(inputSz, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
             if (input == NULL)
                 return MEMORY_E;
 
             XMEMCPY(input, output + recordHeaderSz, inputSz);
             #ifdef WOLFSSL_DTLS
             if (IsDtlsNotSctpMode(ssl) &&
                     (ret = DtlsMsgPoolSave(ssl, input, inputSz, server_hello)) != 0) {
                 XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
                 return ret;
             }
             #endif
             sendSz = BuildMessage(ssl, output, sendSz, input, inputSz,
                                   handshake, 1, 0, 0, CUR_ORDER);
             XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
 
             if (sendSz < 0)
                 return sendSz;
         } else {
             #ifdef WOLFSSL_DTLS
                 if (IsDtlsNotSctpMode(ssl)) {
                     if ((ret = DtlsMsgPoolSave(ssl, output, sendSz, server_hello)) != 0)
                         return ret;
                 }
                 if (ssl->options.dtls)
                     DtlsSEQIncrement(ssl, CUR_ORDER);
             #endif
             ret = HashOutput(ssl, output, sendSz, 0);
             if (ret != 0)
                 return ret;
         }
 
     #if defined(WOLFSSL_CALLBACKS) || defined(OPENSSL_EXTRA)
         if (ssl->hsInfoOn)
             AddPacketName(ssl, "ServerHello");
         if (ssl->toInfoOn)
             AddPacketInfo(ssl, "ServerHello", handshake, output, sendSz,
                           WRITE_PROTO, ssl->heap);
     #endif
 
         ssl->options.serverState = SERVER_HELLO_COMPLETE;
         ssl->buffers.outputBuffer.length += sendSz;
 
         if (ssl->options.groupMessages)
             ret = 0;
         else
             ret = SendBuffered(ssl);
 
         WOLFSSL_LEAVE("SendServerHello", ret);
         WOLFSSL_END(WC_FUNC_SERVER_HELLO_SEND);
 
         return ret;
     }
 
 
 #if defined(HAVE_ECC)
 
     static byte SetCurveId(ecc_key* key)
     {
         if (key == NULL || key->dp == NULL) {
             WOLFSSL_MSG("SetCurveId: Invalid key!");
             return 0;
         }
 
         return (byte)GetCurveByOID(key->dp->oidSum);
     }
 
 #endif /* HAVE_ECC */
 
     typedef struct SskeArgs {
         byte*  output; /* not allocated */
     #if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448) || \
                                                                 !defined(NO_RSA)
         byte*  sigDataBuf;
     #endif
     #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || defined(HAVE_CURVE448)
         byte*  exportBuf;
     #endif
     #ifndef NO_RSA
         byte*  verifySig;
     #endif
         byte*  input;
         word32 idx;
         word32 tmpSigSz;
         word32 length;
         word32 sigSz;
     #if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448) || \
                                                                 !defined(NO_RSA)
         word32 sigDataSz;
     #endif
     #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || defined(HAVE_CURVE448)
         word32 exportSz;
     #endif
     #ifdef HAVE_QSH
         word32 qshSz;
     #endif
         int    sendSz;
         int    inputSz;
     } SskeArgs;
 
     static void FreeSskeArgs(WOLFSSL* ssl, void* pArgs)
     {
         SskeArgs* args = (SskeArgs*)pArgs;
 
         (void)ssl;
 
     #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || defined(HAVE_CURVE448)
         if (args->exportBuf) {
             XFREE(args->exportBuf, ssl->heap, DYNAMIC_TYPE_DER);
             args->exportBuf = NULL;
         }
     #endif
     #if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448) || \
                                            (!defined(NO_DH) && !defined(NO_RSA))
         if (args->sigDataBuf) {
             XFREE(args->sigDataBuf, ssl->heap, DYNAMIC_TYPE_SIGNATURE);
             args->sigDataBuf = NULL;
         }
     #endif
     #ifndef NO_RSA
         if (args->verifySig) {
             XFREE(args->verifySig, ssl->heap, DYNAMIC_TYPE_SIGNATURE);
             args->verifySig = NULL;
         }
     #endif
         (void)args;
     }
 
     /* handle generation of server_key_exchange (12) */
     int SendServerKeyExchange(WOLFSSL* ssl)
     {
         int ret;
     #ifdef WOLFSSL_ASYNC_CRYPT
         SskeArgs* args = (SskeArgs*)ssl->async.args;
         typedef char args_test[sizeof(ssl->async.args) >= sizeof(*args) ? 1 : -1];
         (void)sizeof(args_test);
     #else
         SskeArgs  args[1];
     #endif
 
         WOLFSSL_START(WC_FUNC_SERVER_KEY_EXCHANGE_SEND);
         WOLFSSL_ENTER("SendServerKeyExchange");
 
     #ifdef WOLFSSL_ASYNC_CRYPT
         ret = wolfSSL_AsyncPop(ssl, &ssl->options.asyncState);
         if (ret != WC_NOT_PENDING_E) {
             /* Check for error */
             if (ret < 0)
                 goto exit_sske;
         }
         else
     #endif
         {
             /* Reset state */
             ret = 0;
             ssl->options.asyncState = TLS_ASYNC_BEGIN;
             XMEMSET(args, 0, sizeof(SskeArgs));
         #ifdef WOLFSSL_ASYNC_CRYPT
             ssl->async.freeArgs = FreeSskeArgs;
         #endif
         }
 
         switch(ssl->options.asyncState)
         {
             case TLS_ASYNC_BEGIN:
             {
             #ifdef HAVE_QSH
                 if (ssl->peerQSHKeyPresent && ssl->options.haveQSH) {
                     args->qshSz = QSH_KeyGetSize(ssl);
                 }
             #endif
 
                 /* Do some checks / debug msgs */
                 switch(ssl->specs.kea)
                 {
                 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                     case ecdhe_psk_kea:
                     {
                         WOLFSSL_MSG("Using ephemeral ECDH PSK");
                         break;
                     }
                 #endif /* (HAVE_ECC || CURVE25519 || CURVE448) && !NO_PSK */
                 #if defined(HAVE_ECC)
                     case ecc_diffie_hellman_kea:
                     {
                         if (ssl->specs.static_ecdh) {
                             WOLFSSL_MSG("Using Static ECDH, not sending "
                                         "ServerKeyExchange");
                             ERROR_OUT(0, exit_sske);
                         }
 
                         WOLFSSL_MSG("Using ephemeral ECDH");
                         break;
                     }
                 #endif /* HAVE_ECC */
                 }
 
                 /* Preparing keys */
                 switch(ssl->specs.kea)
                 {
                 #ifndef NO_PSK
                     case psk_kea:
                     {
                         /* Nothing to do in this sub-state */
                         break;
                     }
                 #endif /* !NO_PSK */
                 #if !defined(NO_DH) && (!defined(NO_PSK) || !defined(NO_RSA))
                 #if !defined(NO_PSK)
                     case dhe_psk_kea:
                 #endif
                 #if !defined(NO_RSA)
                     case diffie_hellman_kea:
                 #endif
                     {
                         /* Allocate DH key buffers and generate key */
                         if (ssl->buffers.serverDH_P.buffer == NULL ||
                             ssl->buffers.serverDH_G.buffer == NULL) {
                             ERROR_OUT(NO_DH_PARAMS, exit_sske);
                         }
 
                         if (ssl->buffers.serverDH_Pub.buffer == NULL) {
                             /* Free'd in SSL_ResourceFree and FreeHandshakeResources */
                             ssl->buffers.serverDH_Pub.buffer = (byte*)XMALLOC(
                                     ssl->buffers.serverDH_P.length + OPAQUE16_LEN,
                                     ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
                             if (ssl->buffers.serverDH_Pub.buffer == NULL) {
                                 ERROR_OUT(MEMORY_E, exit_sske);
                             }
                             ssl->buffers.serverDH_Pub.length =
                                 ssl->buffers.serverDH_P.length + OPAQUE16_LEN;
                         }
 
                         if (ssl->buffers.serverDH_Priv.buffer == NULL) {
                             /* Free'd in SSL_ResourceFree and FreeHandshakeResources */
                             ssl->buffers.serverDH_Priv.buffer = (byte*)XMALLOC(
                                     ssl->buffers.serverDH_P.length + OPAQUE16_LEN,
                                     ssl->heap, DYNAMIC_TYPE_PRIVATE_KEY);
                             if (ssl->buffers.serverDH_Priv.buffer == NULL) {
                                 ERROR_OUT(MEMORY_E, exit_sske);
                             }
                             ssl->buffers.serverDH_Priv.length =
                                 ssl->buffers.serverDH_P.length + OPAQUE16_LEN;
                         }
 
                         ssl->options.dhKeySz =
                                 (word16)ssl->buffers.serverDH_P.length;
 
                         ret = AllocKey(ssl, DYNAMIC_TYPE_DH,
                                             (void**)&ssl->buffers.serverDH_Key);
                         if (ret != 0) {
                             goto exit_sske;
                         }
 
                         #if !defined(WOLFSSL_OLD_PRIME_CHECK) && \
                             !defined(HAVE_FIPS) && \
                             !defined(HAVE_SELFTEST)
                         if (ssl->options.dhDoKeyTest &&
                             !ssl->options.dhKeyTested)
                         {
                             ret = wc_DhSetCheckKey(
                                 ssl->buffers.serverDH_Key,
                                 ssl->buffers.serverDH_P.buffer,
                                 ssl->buffers.serverDH_P.length,
                                 ssl->buffers.serverDH_G.buffer,
                                 ssl->buffers.serverDH_G.length,
                                 NULL, 0, 0, ssl->rng);
                             if (ret != 0) {
                                 goto exit_sske;
                             }
                             ssl->options.dhKeyTested = 1;
                         }
                         else
                         #endif
                         {
                             ret = wc_DhSetKey(ssl->buffers.serverDH_Key,
                                 ssl->buffers.serverDH_P.buffer,
                                 ssl->buffers.serverDH_P.length,
                                 ssl->buffers.serverDH_G.buffer,
                                 ssl->buffers.serverDH_G.length);
                             if (ret != 0) {
                                 goto exit_sske;
                             }
                         }
 
                         ret = DhGenKeyPair(ssl, ssl->buffers.serverDH_Key,
                             ssl->buffers.serverDH_Priv.buffer,
                             (word32*)&ssl->buffers.serverDH_Priv.length,
                             ssl->buffers.serverDH_Pub.buffer,
                             (word32*)&ssl->buffers.serverDH_Pub.length);
                         break;
                     }
                 #endif /* !NO_DH && (!NO_PSK || !NO_RSA) */
                 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                     case ecdhe_psk_kea:
                         /* Fall through to create temp ECC key */
                 #endif /* (HAVE_ECC || CURVE25519 || CURVE448) && !NO_PSK */
                 #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                     case ecc_diffie_hellman_kea:
                     {
                     #ifdef HAVE_CURVE25519
                         if (ssl->ecdhCurveOID == ECC_X25519_OID) {
                             /* need ephemeral key now, create it if missing */
                             if (ssl->eccTempKey == NULL) {
                                 /* alloc/init on demand */
                                 ret = AllocKey(ssl, DYNAMIC_TYPE_CURVE25519,
                                     (void**)&ssl->eccTempKey);
                                 if (ret != 0) {
                                     goto exit_sske;
                                 }
                             }
 
                             if (ssl->eccTempKeyPresent == 0) {
                                 ret = X25519MakeKey(ssl,
                                         (curve25519_key*)ssl->eccTempKey, NULL);
                                 if (ret == 0 || ret == WC_PENDING_E) {
                                     ssl->eccTempKeyPresent =
                                         DYNAMIC_TYPE_CURVE25519;
                                 }
                             }
                             break;
                         }
                     #endif
                     #ifdef HAVE_CURVE448
                         if (ssl->ecdhCurveOID == ECC_X448_OID) {
                             /* need ephemeral key now, create it if missing */
                             if (ssl->eccTempKey == NULL) {
                                 /* alloc/init on demand */
                                 ret = AllocKey(ssl, DYNAMIC_TYPE_CURVE448,
                                     (void**)&ssl->eccTempKey);
                                 if (ret != 0) {
                                     goto exit_sske;
                                 }
                             }
 
                             if (ssl->eccTempKeyPresent == 0) {
                                 ret = X448MakeKey(ssl,
                                           (curve448_key*)ssl->eccTempKey, NULL);
                                 if (ret == 0 || ret == WC_PENDING_E) {
                                     ssl->eccTempKeyPresent =
                                         DYNAMIC_TYPE_CURVE448;
                                 }
                             }
                             break;
                         }
                     #endif
                     #ifdef HAVE_ECC
                         /* need ephemeral key now, create it if missing */
                         if (ssl->eccTempKey == NULL) {
                             /* alloc/init on demand */
                             ret = AllocKey(ssl, DYNAMIC_TYPE_ECC,
                                 (void**)&ssl->eccTempKey);
                             if (ret != 0) {
                                 goto exit_sske;
                             }
                         }
 
                         if (ssl->eccTempKeyPresent == 0) {
                             ret = EccMakeKey(ssl, ssl->eccTempKey, NULL);
                             if (ret == 0 || ret == WC_PENDING_E) {
                                 ssl->eccTempKeyPresent = DYNAMIC_TYPE_ECC;
                             }
                         }
                     #endif
                         break;
                     }
                 #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
                     default:
                         /* Skip ServerKeyExchange */
                         goto exit_sske;
                 } /* switch(ssl->specs.kea) */
 
                 /* Check for error */
                 if (ret != 0) {
                     goto exit_sske;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_BUILD;
             } /* case TLS_ASYNC_BEGIN */
             FALL_THROUGH;
 
             case TLS_ASYNC_BUILD:
             {
             #if (!defined(NO_DH) && !defined(NO_RSA)) || (defined(HAVE_ECC) || \
                              defined(HAVE_CURVE25519) || defined(HAVE_CURVE448))
                 word32 preSigSz, preSigIdx;
             #endif
 
                 switch(ssl->specs.kea)
                 {
                 #ifndef NO_PSK
                     case psk_kea:
                     {
                         args->idx = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
 
                         if (ssl->arrays->server_hint[0] == 0) {
                             ERROR_OUT(0, exit_sske); /* don't send */
                         }
 
                         /* include size part */
                         args->length = (word32)XSTRLEN(ssl->arrays->server_hint);
                         if (args->length > MAX_PSK_ID_LEN) {
                             ERROR_OUT(SERVER_HINT_ERROR, exit_sske);
                         }
 
                         args->length += HINT_LEN_SZ;
                         args->sendSz = args->length + HANDSHAKE_HEADER_SZ +
                                                             RECORD_HEADER_SZ;
 
                     #ifdef HAVE_QSH
                         args->length += args->qshSz;
                         args->sendSz += args->qshSz;
                     #endif
 
                     #ifdef WOLFSSL_DTLS
                         if (ssl->options.dtls) {
                             args->sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                             args->idx    += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                         }
                     #endif
 
                         if (IsEncryptionOn(ssl, 1)) {
                             args->sendSz += MAX_MSG_EXTRA;
                         }
 
                         /* check for available size */
                         if ((ret = CheckAvailableSize(ssl, args->sendSz)) != 0) {
                             goto exit_sske;
                         }
 
                         /* get output buffer */
                         args->output = ssl->buffers.outputBuffer.buffer +
                                        ssl->buffers.outputBuffer.length;
 
                         AddHeaders(args->output, args->length,
                                                     server_key_exchange, ssl);
 
                         /* key data */
                     #ifdef HAVE_QSH
                         c16toa((word16)(args->length - args->qshSz -
                                         HINT_LEN_SZ), args->output + args->idx);
                     #else
                         c16toa((word16)(args->length - HINT_LEN_SZ),
                                                       args->output + args->idx);
                     #endif
 
                         args->idx += HINT_LEN_SZ;
                         XMEMCPY(args->output + args->idx,
                                 ssl->arrays->server_hint,
                                 args->length - HINT_LEN_SZ);
                         break;
                     }
                 #endif /* !NO_PSK */
                 #if !defined(NO_DH) && !defined(NO_PSK)
                     case dhe_psk_kea:
                     {
                         word32 hintLen;
 
                         args->idx = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
                         args->length = LENGTH_SZ * 3 + /* p, g, pub */
                                  ssl->buffers.serverDH_P.length +
                                  ssl->buffers.serverDH_G.length +
                                  ssl->buffers.serverDH_Pub.length;
 
                         /* include size part */
                         hintLen = (word32)XSTRLEN(ssl->arrays->server_hint);
                         if (hintLen > MAX_PSK_ID_LEN) {
                             ERROR_OUT(SERVER_HINT_ERROR, exit_sske);
                         }
                         args->length += hintLen + HINT_LEN_SZ;
                         args->sendSz = args->length + HANDSHAKE_HEADER_SZ +
                                                             RECORD_HEADER_SZ;
 
                     #ifdef HAVE_QSH
                         args->length += args->qshSz;
                         args->sendSz += args->qshSz;
                     #endif
                     #ifdef WOLFSSL_DTLS
                         if (ssl->options.dtls) {
                             args->sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                             args->idx    += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                         }
                     #endif
 
                         if (IsEncryptionOn(ssl, 1)) {
                             args->sendSz += MAX_MSG_EXTRA;
                         }
 
                         /* check for available size */
                         if ((ret = CheckAvailableSize(ssl, args->sendSz)) != 0) {
                             goto exit_sske;
                         }
 
                         /* get output buffer */
                         args->output = ssl->buffers.outputBuffer.buffer +
                                        ssl->buffers.outputBuffer.length;
 
                         AddHeaders(args->output, args->length,
                                                     server_key_exchange, ssl);
 
                         /* key data */
                         c16toa((word16)hintLen, args->output + args->idx);
                         args->idx += HINT_LEN_SZ;
                         XMEMCPY(args->output + args->idx,
                                             ssl->arrays->server_hint, hintLen);
                         args->idx += hintLen;
 
                         /* add p, g, pub */
                         c16toa((word16)ssl->buffers.serverDH_P.length,
                             args->output + args->idx);
                         args->idx += LENGTH_SZ;
                         XMEMCPY(args->output + args->idx,
                                 ssl->buffers.serverDH_P.buffer,
                                 ssl->buffers.serverDH_P.length);
                         args->idx += ssl->buffers.serverDH_P.length;
 
                         /*  g */
                         c16toa((word16)ssl->buffers.serverDH_G.length,
                             args->output + args->idx);
                         args->idx += LENGTH_SZ;
                         XMEMCPY(args->output + args->idx,
                                 ssl->buffers.serverDH_G.buffer,
                                 ssl->buffers.serverDH_G.length);
                         args->idx += ssl->buffers.serverDH_G.length;
 
                         /*  pub */
                         c16toa((word16)ssl->buffers.serverDH_Pub.length,
                             args->output + args->idx);
                         args->idx += LENGTH_SZ;
                         XMEMCPY(args->output + args->idx,
                                 ssl->buffers.serverDH_Pub.buffer,
                                 ssl->buffers.serverDH_Pub.length);
                         /* No need to update idx, since sizes are already set */
                         /* args->idx += ssl->buffers.serverDH_Pub.length; */
                         break;
                     }
                 #endif /* !defined(NO_DH) && !defined(NO_PSK) */
                 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                     case ecdhe_psk_kea:
                     {
                         word32 hintLen;
 
                         /* curve type, named curve, length(1) */
                         args->idx = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
                         args->length = ENUM_LEN + CURVE_LEN + ENUM_LEN;
 
                         args->exportSz = MAX_EXPORT_ECC_SZ;
                         args->exportBuf = (byte*)XMALLOC(args->exportSz,
                                             ssl->heap, DYNAMIC_TYPE_DER);
                         if (args->exportBuf == NULL) {
                             ERROR_OUT(MEMORY_E, exit_sske);
                         }
                     #ifdef HAVE_CURVE25519
                         if (ssl->ecdhCurveOID == ECC_X25519_OID) {
                             if (wc_curve25519_export_public_ex(
                                     (curve25519_key*)ssl->eccTempKey,
                                     args->exportBuf, &args->exportSz,
                                     EC25519_LITTLE_ENDIAN) != 0) {
                                 ERROR_OUT(ECC_EXPORT_ERROR, exit_sske);
                             }
                         }
                         else
                     #endif
                     #ifdef HAVE_CURVE448
                         if (ssl->ecdhCurveOID == ECC_X448_OID) {
                             if (wc_curve448_export_public_ex(
                                     (curve448_key*)ssl->eccTempKey,
                                     args->exportBuf, &args->exportSz,
                                     EC448_LITTLE_ENDIAN) != 0) {
                                 ERROR_OUT(ECC_EXPORT_ERROR, exit_sske);
                             }
                         }
                         else
                     #endif
                         {
                             if (wc_ecc_export_x963(ssl->eccTempKey,
                                        args->exportBuf, &args->exportSz) != 0) {
                                 ERROR_OUT(ECC_EXPORT_ERROR, exit_sske);
                             }
                         }
                         args->length += args->exportSz;
 
                         /* include size part */
                         hintLen = (word32)XSTRLEN(ssl->arrays->server_hint);
                         if (hintLen > MAX_PSK_ID_LEN) {
                             ERROR_OUT(SERVER_HINT_ERROR, exit_sske);
                         }
                         args->length += hintLen + HINT_LEN_SZ;
                         args->sendSz = args->length + HANDSHAKE_HEADER_SZ + RECORD_HEADER_SZ;
 
                     #ifdef HAVE_QSH
                         args->length += args->qshSz;
                         args->sendSz += args->qshSz;
                     #endif
                     #ifdef WOLFSSL_DTLS
                         if (ssl->options.dtls) {
                             args->sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                             args->idx    += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                         }
                     #endif
 
                         if (IsEncryptionOn(ssl, 1)) {
                             args->sendSz += MAX_MSG_EXTRA;
                         }
 
                         /* check for available size */
                         if ((ret = CheckAvailableSize(ssl, args->sendSz)) != 0) {
                             goto exit_sske;
                         }
 
                         /* get output buffer */
                         args->output = ssl->buffers.outputBuffer.buffer +
                                        ssl->buffers.outputBuffer.length;
 
                         /* key data */
                         c16toa((word16)hintLen, args->output + args->idx);
                         args->idx += HINT_LEN_SZ;
                         XMEMCPY(args->output + args->idx,
                                             ssl->arrays->server_hint, hintLen);
                         args->idx += hintLen;
 
                         /* ECC key exchange data */
                         args->output[args->idx++] = named_curve;
                         args->output[args->idx++] = 0x00;          /* leading zero */
                     #ifdef HAVE_CURVE25519
                         if (ssl->ecdhCurveOID == ECC_X25519_OID)
                             args->output[args->idx++] = WOLFSSL_ECC_X25519;
                         else
                     #endif
                     #ifdef HAVE_CURVE448
                         if (ssl->ecdhCurveOID == ECC_X448_OID)
                             args->output[args->idx++] = WOLFSSL_ECC_X448;
                         else
                     #endif
                         {
                     #ifdef HAVE_ECC
                             args->output[args->idx++] =
                                                     SetCurveId(ssl->eccTempKey);
                     #endif
                         }
                         args->output[args->idx++] = (byte)args->exportSz;
                         XMEMCPY(args->output + args->idx, args->exportBuf,
                                                                 args->exportSz);
                         break;
                     }
                 #endif /* (HAVE_ECC || CURVE25519 || CURVE448) && !NO_PSK */
                 #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                     case ecc_diffie_hellman_kea:
                     {
                         enum wc_HashType hashType;
 
                         /* curve type, named curve, length(1) */
                         args->idx = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
                         args->length = ENUM_LEN + CURVE_LEN + ENUM_LEN;
 
                         /* Export temp ECC key and add to length */
                         args->exportSz = MAX_EXPORT_ECC_SZ;
                         args->exportBuf = (byte*)XMALLOC(args->exportSz,
                                             ssl->heap, DYNAMIC_TYPE_DER);
                         if (args->exportBuf == NULL) {
                             ERROR_OUT(MEMORY_E, exit_sske);
                         }
                     #ifdef HAVE_CURVE25519
                         if (ssl->ecdhCurveOID == ECC_X25519_OID) {
                             if (wc_curve25519_export_public_ex(
                                         (curve25519_key*)ssl->eccTempKey,
                                         args->exportBuf, &args->exportSz,
                                         EC25519_LITTLE_ENDIAN) != 0) {
                                 ERROR_OUT(ECC_EXPORT_ERROR, exit_sske);
                             }
                         }
                         else
                     #endif
                     #ifdef HAVE_CURVE448
                         if (ssl->ecdhCurveOID == ECC_X448_OID) {
                             if (wc_curve448_export_public_ex(
                                         (curve448_key*)ssl->eccTempKey,
                                         args->exportBuf, &args->exportSz,
                                         EC448_LITTLE_ENDIAN) != 0) {
                                 ERROR_OUT(ECC_EXPORT_ERROR, exit_sske);
                             }
                         }
                         else
                     #endif
                         {
                     #if defined(HAVE_ECC) && defined(HAVE_ECC_KEY_EXPORT)
                             if (wc_ecc_export_x963(ssl->eccTempKey,
                                        args->exportBuf, &args->exportSz) != 0) {
                                 ERROR_OUT(ECC_EXPORT_ERROR, exit_sske);
                             }
                      #endif
                         }
                         args->length += args->exportSz;
 
                         preSigSz  = args->length;
                         preSigIdx = args->idx;
 
                         if (ssl->buffers.key == NULL) {
                         #ifdef HAVE_PK_CALLBACKS
                             if (wolfSSL_CTX_IsPrivatePkSet(ssl->ctx)) {
                                 args->tmpSigSz = GetPrivateKeySigSize(ssl);
                                 if (args->tmpSigSz == 0) {
                                     ERROR_OUT(NO_PRIVATE_KEY, exit_sske);
                                 }
                             }
                             else
                         #endif
                                 ERROR_OUT(NO_PRIVATE_KEY, exit_sske);
                         }
                         else {
                             switch(ssl->suites->sigAlgo) {
                         #ifndef NO_RSA
                         #ifdef WC_RSA_PSS
                             case rsa_pss_sa_algo:
                         #endif
                             case rsa_sa_algo:
                             {
                                 word16 keySz;
 
                                 ssl->buffers.keyType = rsa_sa_algo;
                                 ret = DecodePrivateKey(ssl, &keySz);
                                 if (ret != 0) {
                                     goto exit_sske;
                                 }
 
                                 args->tmpSigSz = (word32)keySz;
                                 break;
                             }
                         #endif /* !NO_RSA */
                         #ifdef HAVE_ECC
                             case ecc_dsa_sa_algo:
                             {
                                 word16 keySz;
 
                                 ssl->buffers.keyType = ecc_dsa_sa_algo;
                                 ret = DecodePrivateKey(ssl, &keySz);
                                 if (ret != 0) {
                                     goto exit_sske;
                                 }
                                 /* worst case estimate */
                                 args->tmpSigSz = keySz;
                                 break;
                             }
                         #endif
                         #ifdef HAVE_ED25519
                             case ed25519_sa_algo:
                             {
                                 word16 keySz;
 
                                 ssl->buffers.keyType = ed25519_sa_algo;
                                 ret = DecodePrivateKey(ssl, &keySz);
                                 if (ret != 0) {
                                     goto exit_sske;
                                 }
 
                                 /* worst case estimate */
                                 args->tmpSigSz = ED25519_SIG_SIZE;
                                 break;
                             }
                         #endif /* HAVE_ED25519 */
                         #ifdef HAVE_ED448
                             case ed448_sa_algo:
                             {
                                 word16 keySz;
 
                                 ssl->buffers.keyType = ed448_sa_algo;
                                 ret = DecodePrivateKey(ssl, &keySz);
                                 if (ret != 0) {
                                     goto exit_sske;
                                 }
 
                                 /* worst case estimate */
                                 args->tmpSigSz = ED448_SIG_SIZE;
                                 break;
                             }
                         #endif /* HAVE_ED448 */
                             default:
                                 ERROR_OUT(ALGO_ID_E, exit_sske);  /* unsupported type */
                             } /* switch(ssl->specs.sig_algo) */
                         }
 
                         /* sig length */
                         args->length += LENGTH_SZ;
                         args->length += args->tmpSigSz;
 
                         if (IsAtLeastTLSv1_2(ssl)) {
                             args->length += HASH_SIG_SIZE;
                         }
 
                         args->sendSz = args->length + HANDSHAKE_HEADER_SZ + RECORD_HEADER_SZ;
 
                     #ifdef HAVE_QSH
                         args->length += args->qshSz;
                         args->sendSz += args->qshSz;
                     #endif
                     #ifdef WOLFSSL_DTLS
                         if (ssl->options.dtls) {
                             args->sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                             args->idx    += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                             preSigIdx = args->idx;
                         }
                     #endif
                         if (IsEncryptionOn(ssl, 1)) {
                             args->sendSz += MAX_MSG_EXTRA;
                         }
 
                         /* check for available size */
                         if ((ret = CheckAvailableSize(ssl, args->sendSz)) != 0) {
                             goto exit_sske;
                         }
 
                         /* get output buffer */
                         args->output = ssl->buffers.outputBuffer.buffer +
                                        ssl->buffers.outputBuffer.length;
 
                         /* record and message headers will be added below, when we're sure
                            of the sig length */
 
                         /* key exchange data */
                         args->output[args->idx++] = named_curve;
                         args->output[args->idx++] = 0x00;          /* leading zero */
                     #ifdef HAVE_CURVE25519
                         if (ssl->ecdhCurveOID == ECC_X25519_OID)
                             args->output[args->idx++] = WOLFSSL_ECC_X25519;
                         else
                     #endif
                     #ifdef HAVE_CURVE448
                         if (ssl->ecdhCurveOID == ECC_X448_OID)
                             args->output[args->idx++] = WOLFSSL_ECC_X448;
                         else
                     #endif
                         {
                     #ifdef HAVE_ECC
                             args->output[args->idx++] =
                                                     SetCurveId(ssl->eccTempKey);
                     #endif
                         }
                         args->output[args->idx++] = (byte)args->exportSz;
                         XMEMCPY(args->output + args->idx, args->exportBuf, args->exportSz);
                         args->idx += args->exportSz;
 
                         /* Determine hash type */
                         if (IsAtLeastTLSv1_2(ssl)) {
                             EncodeSigAlg(ssl->suites->hashAlgo,
                                          ssl->suites->sigAlgo,
                                          &args->output[args->idx]);
                             args->idx += 2;
 
                             hashType = HashAlgoToType(ssl->suites->hashAlgo);
                             if (hashType == WC_HASH_TYPE_NONE) {
                                 ERROR_OUT(ALGO_ID_E, exit_sske);
                             }
 
                         } else {
                             /* only using sha and md5 for rsa */
                         #ifndef NO_OLD_TLS
                             hashType = WC_HASH_TYPE_SHA;
                             if (ssl->suites->sigAlgo == rsa_sa_algo) {
                                 hashType = WC_HASH_TYPE_MD5_SHA;
                             }
                         #else
                             ERROR_OUT(ALGO_ID_E, exit_sske);
                         #endif
                         }
 
                         /* Signature length will be written later, when we're sure what it is */
 
                     #ifdef HAVE_FUZZER
                         if (ssl->fuzzerCb) {
                             ssl->fuzzerCb(ssl, args->output + preSigIdx,
                                 preSigSz, FUZZ_SIGNATURE, ssl->fuzzerCtx);
                         }
                     #endif
 
                         /* Assemble buffer to hash for signature */
                         args->sigDataSz = RAN_LEN + RAN_LEN + preSigSz;
                         args->sigDataBuf = (byte*)XMALLOC(args->sigDataSz,
                                             ssl->heap, DYNAMIC_TYPE_SIGNATURE);
                         if (args->sigDataBuf == NULL) {
                             ERROR_OUT(MEMORY_E, exit_sske);
                         }
                         XMEMCPY(args->sigDataBuf, ssl->arrays->clientRandom,
                                                                        RAN_LEN);
                         XMEMCPY(args->sigDataBuf+RAN_LEN,
                                             ssl->arrays->serverRandom, RAN_LEN);
                         XMEMCPY(args->sigDataBuf+RAN_LEN+RAN_LEN,
                                 args->output + preSigIdx, preSigSz);
 
                         if (ssl->suites->sigAlgo != ed25519_sa_algo &&
                                         ssl->suites->sigAlgo != ed448_sa_algo) {
                             ssl->buffers.sig.length =
                                                  wc_HashGetDigestSize(hashType);
                             if ((int)ssl->buffers.sig.length < 0) {
                                 ERROR_OUT(HASH_TYPE_E, exit_sske);
                             }
                             ssl->buffers.sig.buffer = (byte*)XMALLOC(
                                             ssl->buffers.sig.length,
                                             ssl->heap, DYNAMIC_TYPE_SIGNATURE);
                             if (ssl->buffers.sig.buffer == NULL) {
                                 ERROR_OUT(MEMORY_E, exit_sske);
                             }
 
                             /* Perform hash */
                             ret = wc_Hash(hashType, args->sigDataBuf,
                                                        args->sigDataSz,
                                                        ssl->buffers.sig.buffer,
                                                        ssl->buffers.sig.length);
                             if (ret != 0) {
                                 goto exit_sske;
                             }
                         }
 
                         args->sigSz = args->tmpSigSz;
 
                         /* Sign hash to create signature */
                         switch (ssl->suites->sigAlgo)
                         {
                         #ifndef NO_RSA
                             case rsa_sa_algo:
                             {
                                 /* For TLS 1.2 re-encode signature */
                                 if (IsAtLeastTLSv1_2(ssl)) {
                                     byte* encodedSig = (byte*)XMALLOC(
                                                   MAX_ENCODED_SIG_SZ, ssl->heap,
                                                        DYNAMIC_TYPE_SIGNATURE);
                                     if (encodedSig == NULL) {
                                         ERROR_OUT(MEMORY_E, exit_sske);
                                     }
 
                                     ssl->buffers.sig.length =
                                         wc_EncodeSignature(encodedSig,
                                             ssl->buffers.sig.buffer,
                                             ssl->buffers.sig.length,
                                             TypeHash(ssl->suites->hashAlgo));
 
                                     /* Replace sig buffer with new one */
                                     XFREE(ssl->buffers.sig.buffer, ssl->heap,
                                                        DYNAMIC_TYPE_SIGNATURE);
                                     ssl->buffers.sig.buffer = encodedSig;
                                 }
 
                                 /* write sig size here */
                                 c16toa((word16)args->sigSz,
                                     args->output + args->idx);
                                 args->idx += LENGTH_SZ;
                                 break;
                             }
                         #ifdef WC_RSA_PSS
                             case rsa_pss_sa_algo:
                                 /* write sig size here */
                                 c16toa((word16)args->sigSz,
                                     args->output + args->idx);
                                 args->idx += LENGTH_SZ;
                                 break;
                         #endif
                         #endif /* !NO_RSA */
                             case ecc_dsa_sa_algo:
                             {
                                 break;
                             }
                         #ifdef  HAVE_ED25519
                             case ed25519_sa_algo:
                                 ret = Ed25519CheckPubKey(ssl);
                                 if (ret != 0)
                                     goto exit_sske;
                                 break;
                         #endif /* HAVE_ED25519 */
                         #ifdef  HAVE_ED448
                             case ed448_sa_algo:
                                 ret = Ed448CheckPubKey(ssl);
                                 if (ret != 0)
                                     goto exit_sske;
                                 break;
                         #endif /* HAVE_ED448 */
                         } /* switch(ssl->specs.sig_algo) */
                         break;
                     }
                 #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
                 #if !defined(NO_DH) && !defined(NO_RSA)
                     case diffie_hellman_kea:
                     {
                         enum wc_HashType hashType;
 
                         args->idx = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
                         args->length = LENGTH_SZ * 3;  /* p, g, pub */
                         args->length += ssl->buffers.serverDH_P.length +
                                         ssl->buffers.serverDH_G.length +
                                         ssl->buffers.serverDH_Pub.length;
 
                         preSigIdx = args->idx;
                         preSigSz  = args->length;
 
                         if (!ssl->options.usingAnon_cipher) {
                             word16 keySz;
 
                             /* sig length */
                             args->length += LENGTH_SZ;
 
                             if (ssl->buffers.key == NULL) {
                             #ifdef HAVE_PK_CALLBACKS
                                 if (wolfSSL_CTX_IsPrivatePkSet(ssl->ctx))
                                     keySz = (word32)GetPrivateKeySigSize(ssl);
                                 else
                             #endif
                                     ERROR_OUT(NO_PRIVATE_KEY, exit_sske);
                             }
                             else
                             {
                                 if (ssl->buffers.keyType == 0)
                                     ssl->buffers.keyType = rsa_sa_algo;
                                 ret = DecodePrivateKey(ssl, &keySz);
                                 if (ret != 0) {
                                     goto exit_sske;
                                 }
                             }
 
                             if (keySz == 0) { /* test if keySz has error */
                                 ERROR_OUT(keySz, exit_sske);
                             }
 
                             args->tmpSigSz = (word32)keySz;
                             args->length += args->tmpSigSz;
 
                             if (IsAtLeastTLSv1_2(ssl)) {
                                 args->length += HASH_SIG_SIZE;
                             }
                         }
 
                         args->sendSz = args->length + HANDSHAKE_HEADER_SZ +
                                                             RECORD_HEADER_SZ;
 
                     #ifdef HAVE_QSH
                         args->length += args->qshSz;
                         args->sendSz += args->qshSz;
                     #endif
                     #ifdef WOLFSSL_DTLS
                         if (ssl->options.dtls) {
                             args->sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                             args->idx    += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                             preSigIdx = args->idx;
                         }
                     #endif
 
                         if (IsEncryptionOn(ssl, 1)) {
                             args->sendSz += MAX_MSG_EXTRA;
                         }
 
                         /* check for available size */
                         if ((ret = CheckAvailableSize(ssl, args->sendSz)) != 0) {
                             goto exit_sske;
                         }
 
                         /* get output buffer */
                         args->output = ssl->buffers.outputBuffer.buffer +
                                        ssl->buffers.outputBuffer.length;
 
                         AddHeaders(args->output, args->length,
                                                     server_key_exchange, ssl);
 
                         /* add p, g, pub */
                         c16toa((word16)ssl->buffers.serverDH_P.length,
                                                     args->output + args->idx);
                         args->idx += LENGTH_SZ;
                         XMEMCPY(args->output + args->idx,
                                               ssl->buffers.serverDH_P.buffer,
                                               ssl->buffers.serverDH_P.length);
                         args->idx += ssl->buffers.serverDH_P.length;
 
                         /*  g */
                         c16toa((word16)ssl->buffers.serverDH_G.length,
                                                     args->output + args->idx);
                         args->idx += LENGTH_SZ;
                         XMEMCPY(args->output + args->idx,
                                               ssl->buffers.serverDH_G.buffer,
                                               ssl->buffers.serverDH_G.length);
                         args->idx += ssl->buffers.serverDH_G.length;
 
                         /*  pub */
                         c16toa((word16)ssl->buffers.serverDH_Pub.length,
                                                     args->output + args->idx);
                         args->idx += LENGTH_SZ;
                         XMEMCPY(args->output + args->idx,
                                               ssl->buffers.serverDH_Pub.buffer,
                                               ssl->buffers.serverDH_Pub.length);
                         args->idx += ssl->buffers.serverDH_Pub.length;
 
                     #ifdef HAVE_FUZZER
                         if (ssl->fuzzerCb) {
                             ssl->fuzzerCb(ssl, args->output + preSigIdx,
                                 preSigSz, FUZZ_SIGNATURE, ssl->fuzzerCtx);
                         }
                     #endif
 
                         if (ssl->options.usingAnon_cipher) {
                             break;
                         }
 
                         /* Determine hash type */
                         if (IsAtLeastTLSv1_2(ssl)) {
                             EncodeSigAlg(ssl->suites->hashAlgo,
                                          ssl->suites->sigAlgo,
                                          &args->output[args->idx]);
                             args->idx += 2;
 
                             hashType = HashAlgoToType(ssl->suites->hashAlgo);
                             if (hashType == WC_HASH_TYPE_NONE) {
                                 ERROR_OUT(ALGO_ID_E, exit_sske);
                             }
                         } else {
                             /* only using sha and md5 for rsa */
                         #ifndef NO_OLD_TLS
                             hashType = WC_HASH_TYPE_SHA;
                             if (ssl->suites->sigAlgo == rsa_sa_algo) {
                                 hashType = WC_HASH_TYPE_MD5_SHA;
                             }
                         #else
                             ERROR_OUT(ALGO_ID_E, exit_sske);
                         #endif
                         }
 
                         /* signature size */
                         c16toa((word16)args->tmpSigSz, args->output + args->idx);
                         args->idx += LENGTH_SZ;
 
                         /* Assemble buffer to hash for signature */
                         args->sigDataSz = RAN_LEN + RAN_LEN + preSigSz;
                         args->sigDataBuf = (byte*)XMALLOC(args->sigDataSz,
                                             ssl->heap, DYNAMIC_TYPE_SIGNATURE);
                         if (args->sigDataBuf == NULL) {
                             ERROR_OUT(MEMORY_E, exit_sske);
                         }
                         XMEMCPY(args->sigDataBuf, ssl->arrays->clientRandom,
                                                                     RAN_LEN);
                         XMEMCPY(args->sigDataBuf+RAN_LEN,
                                         ssl->arrays->serverRandom, RAN_LEN);
                         XMEMCPY(args->sigDataBuf+RAN_LEN+RAN_LEN,
                             args->output + preSigIdx, preSigSz);
 
                         if (ssl->suites->sigAlgo != ed25519_sa_algo &&
                                         ssl->suites->sigAlgo != ed448_sa_algo) {
                             ssl->buffers.sig.length =
                                                  wc_HashGetDigestSize(hashType);
                             ssl->buffers.sig.buffer = (byte*)XMALLOC(
                                              ssl->buffers.sig.length, ssl->heap,
                                                        DYNAMIC_TYPE_SIGNATURE);
                             if (ssl->buffers.sig.buffer == NULL) {
                                 ERROR_OUT(MEMORY_E, exit_sske);
                             }
 
                             /* Perform hash */
                             ret = wc_Hash(hashType, args->sigDataBuf,
                                                        args->sigDataSz,
                                                        ssl->buffers.sig.buffer,
                                                        ssl->buffers.sig.length);
                             if (ret != 0) {
                                 goto exit_sske;
                             }
                         }
 
                         args->sigSz = args->tmpSigSz;
 
                         /* Sign hash to create signature */
                         switch (ssl->suites->sigAlgo)
                         {
                         #ifndef NO_RSA
                             case rsa_sa_algo:
                             {
                                 /* For TLS 1.2 re-encode signature */
                                 if (IsAtLeastTLSv1_2(ssl)) {
                                     byte* encodedSig = (byte*)XMALLOC(
                                                   MAX_ENCODED_SIG_SZ, ssl->heap,
                                                        DYNAMIC_TYPE_SIGNATURE);
                                     if (encodedSig == NULL) {
                                         ERROR_OUT(MEMORY_E, exit_sske);
                                     }
 
                                     ssl->buffers.sig.length =
                                         wc_EncodeSignature(encodedSig,
                                             ssl->buffers.sig.buffer,
                                             ssl->buffers.sig.length,
                                             TypeHash(ssl->suites->hashAlgo));
 
                                     /* Replace sig buffer with new one */
                                     XFREE(ssl->buffers.sig.buffer, ssl->heap,
                                                        DYNAMIC_TYPE_SIGNATURE);
                                     ssl->buffers.sig.buffer = encodedSig;
                                 }
                                 break;
                             }
                         #endif /* NO_RSA */
                         } /* switch (ssl->suites->sigAlgo) */
                         break;
                     }
                 #endif /* !defined(NO_DH) && !defined(NO_RSA) */
                 } /* switch(ssl->specs.kea) */
 
                 /* Check for error */
                 if (ret != 0) {
                     goto exit_sske;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_DO;
             } /* case TLS_ASYNC_BUILD */
             FALL_THROUGH;
 
             case TLS_ASYNC_DO:
             {
                 switch(ssl->specs.kea)
                 {
                 #ifndef NO_PSK
                     case psk_kea:
                     {
                         break;
                     }
                 #endif /* !NO_PSK */
                 #if !defined(NO_DH) && !defined(NO_PSK)
                     case dhe_psk_kea:
                     {
                         break;
                     }
                 #endif /* !defined(NO_DH) && !defined(NO_PSK) */
                 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                     case ecdhe_psk_kea:
                     {
                         break;
                     }
                 #endif /* (HAVE_ECC || CURVE25519 || CURVE448) && !NO_PSK */
                 #if defined(HAVE_ECC)  || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                     case ecc_diffie_hellman_kea:
                     {
                         /* Sign hash to create signature */
                         switch (ssl->suites->sigAlgo)
                         {
                         #ifndef NO_RSA
                         #ifdef WC_RSA_PSS
                             case rsa_pss_sa_algo:
                         #endif
                             case rsa_sa_algo:
                             {
                                 RsaKey* key = (RsaKey*)ssl->hsKey;
 
                                 ret = RsaSign(ssl,
                                     ssl->buffers.sig.buffer,
                                     ssl->buffers.sig.length,
                                     args->output + args->idx,
                                     &args->sigSz,
                                     ssl->suites->sigAlgo, ssl->suites->hashAlgo,
                                     key,
                                     ssl->buffers.key
                                 );
                                 break;
                             }
                         #endif /* !NO_RSA */
                         #ifdef HAVE_ECC
                             case ecc_dsa_sa_algo:
                             {
                                 ecc_key* key = (ecc_key*)ssl->hsKey;
 
                                 ret = EccSign(ssl,
                                     ssl->buffers.sig.buffer,
                                     ssl->buffers.sig.length,
                                     args->output + LENGTH_SZ + args->idx,
                                     &args->sigSz,
                                     key,
                             #ifdef HAVE_PK_CALLBACKS
                                     ssl->buffers.key
                             #else
                                     NULL
                             #endif
                                 );
                                 break;
                             }
                         #endif /* HAVE_ECC */
                         #ifdef HAVE_ED25519
                             case ed25519_sa_algo:
                             {
                                 ed25519_key* key = (ed25519_key*)ssl->hsKey;
 
                                 ret = Ed25519Sign(ssl,
                                     args->sigDataBuf, args->sigDataSz,
                                     args->output + LENGTH_SZ + args->idx,
                                     &args->sigSz,
                                     key,
                             #ifdef HAVE_PK_CALLBACKS
                                     ssl->buffers.key
                             #else
                                     NULL
                             #endif
                                 );
                                 break;
                             }
                         #endif
                         #ifdef HAVE_ED448
                             case ed448_sa_algo:
                             {
                                 ed448_key* key = (ed448_key*)ssl->hsKey;
 
                                 ret = Ed448Sign(ssl,
                                     args->sigDataBuf, args->sigDataSz,
                                     args->output + LENGTH_SZ + args->idx,
                                     &args->sigSz,
                                     key,
                             #ifdef HAVE_PK_CALLBACKS
                                     ssl->buffers.key
                             #else
                                     NULL
                             #endif
                                 );
                                 break;
                             }
                         #endif
                         } /* switch(ssl->specs.sig_algo) */
                         break;
                     }
                 #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
                 #if !defined(NO_DH) && !defined(NO_RSA)
                     case diffie_hellman_kea:
                     {
                         /* Sign hash to create signature */
                         switch (ssl->suites->sigAlgo)
                         {
                         #ifndef NO_RSA
                         #ifdef WC_RSA_PSS
                             case rsa_pss_sa_algo:
                         #endif
                             case rsa_sa_algo:
                             {
                                 RsaKey* key = (RsaKey*)ssl->hsKey;
 
                                 if (ssl->options.usingAnon_cipher) {
                                     break;
                                 }
 
                                 ret = RsaSign(ssl,
                                     ssl->buffers.sig.buffer,
                                     ssl->buffers.sig.length,
                                     args->output + args->idx,
                                     &args->sigSz,
                                     ssl->suites->sigAlgo, ssl->suites->hashAlgo,
                                     key,
                                     ssl->buffers.key
                                 );
                                 break;
                             }
                         #endif /* NO_RSA */
                         } /* switch (ssl->suites->sigAlgo) */
 
                         break;
                     }
                 #endif /* !defined(NO_DH) && !defined(NO_RSA) */
                 } /* switch(ssl->specs.kea) */
 
                 /* Check for error */
                 if (ret != 0) {
                     goto exit_sske;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_VERIFY;
             } /* case TLS_ASYNC_DO */
             FALL_THROUGH;
 
             case TLS_ASYNC_VERIFY:
             {
                 switch(ssl->specs.kea)
                 {
                 #ifndef NO_PSK
                     case psk_kea:
                     {
                         /* Nothing to do in this sub-state */
                         break;
                     }
                 #endif /* !NO_PSK */
                 #if !defined(NO_DH) && !defined(NO_PSK)
                     case dhe_psk_kea:
                     {
                         /* Nothing to do in this sub-state */
                         break;
                     }
                 #endif /* !defined(NO_DH) && !defined(NO_PSK) */
                 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) ||  \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                     case ecdhe_psk_kea:
                     {
                         /* Nothing to do in this sub-state */
                         break;
                     }
                 #endif /* (HAVE_ECC || CURVE25519 || CURVE448) && !NO_PSK */
                 #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                     case ecc_diffie_hellman_kea:
                     {
                         switch(ssl->suites->sigAlgo)
                         {
                         #ifndef NO_RSA
                         #ifdef WC_RSA_PSS
                             case rsa_pss_sa_algo:
                         #endif
                             case rsa_sa_algo:
                             {
                                 RsaKey* key = (RsaKey*)ssl->hsKey;
 
                                 if (args->verifySig == NULL) {
                                     if (args->sigSz == 0) {
                                         ERROR_OUT(BAD_COND_E, exit_sske);
                                     }
                                     args->verifySig = (byte*)XMALLOC(
                                                     args->sigSz, ssl->heap,
                                                     DYNAMIC_TYPE_SIGNATURE);
                                     if (!args->verifySig) {
                                         ERROR_OUT(MEMORY_E, exit_sske);
                                     }
                                     XMEMCPY(args->verifySig,
                                         args->output + args->idx, args->sigSz);
                                 }
 
                                 /* check for signature faults */
                                 ret = VerifyRsaSign(ssl,
                                     args->verifySig, args->sigSz,
                                     ssl->buffers.sig.buffer,
                                     ssl->buffers.sig.length,
                                     ssl->suites->sigAlgo, ssl->suites->hashAlgo,
                                     key, ssl->buffers.key
                                 );
                                 break;
                             }
                         #endif
                             case ecc_dsa_sa_algo:
                         #ifdef HAVE_ED25519
                             case ed25519_sa_algo:
                         #endif
                         #ifdef HAVE_ED448
                             case ed448_sa_algo:
                         #endif
                             {
                                 /* Now that we know the real sig size, write it. */
                                 c16toa((word16)args->sigSz,
                                                     args->output + args->idx);
 
                                 /* And adjust length and sendSz from estimates */
                                 args->length += args->sigSz - args->tmpSigSz;
                                 args->sendSz += args->sigSz - args->tmpSigSz;
                                 break;
                             }
                             default:
                                 ERROR_OUT(ALGO_ID_E, exit_sske);  /* unsupported type */
                         } /* switch(ssl->specs.sig_algo) */
                         break;
                     }
                 #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
                 #if !defined(NO_DH) && !defined(NO_RSA)
                     case diffie_hellman_kea:
                     {
                         switch (ssl->suites->sigAlgo)
                         {
                         #ifndef NO_RSA
                         #ifndef WC_RSA_PSS
                             case rsa_pss_sa_algo:
                         #endif
                             case rsa_sa_algo:
                             {
                                 RsaKey* key = (RsaKey*)ssl->hsKey;
 
                                 if (ssl->options.usingAnon_cipher) {
                                     break;
                                 }
 
                                 if (args->verifySig == NULL) {
                                     if (args->sigSz == 0) {
                                         ERROR_OUT(BAD_COND_E, exit_sske);
                                     }
                                     args->verifySig = (byte*)XMALLOC(
                                                       args->sigSz, ssl->heap,
                                                       DYNAMIC_TYPE_SIGNATURE);
                                     if (!args->verifySig) {
                                         ERROR_OUT(MEMORY_E, exit_sske);
                                     }
                                     XMEMCPY(args->verifySig,
                                         args->output + args->idx, args->sigSz);
                                 }
 
                                 /* check for signature faults */
                                 ret = VerifyRsaSign(ssl,
                                     args->verifySig, args->sigSz,
                                     ssl->buffers.sig.buffer,
                                     ssl->buffers.sig.length,
                                     ssl->suites->sigAlgo, ssl->suites->hashAlgo,
                                     key, ssl->buffers.key
                                 );
                                 break;
                             }
                         #endif
                         } /* switch (ssl->suites->sigAlgo) */
                         break;
                     }
                 #endif /* !defined(NO_DH) && !defined(NO_RSA) */
                 } /* switch(ssl->specs.kea) */
 
                 /* Check for error */
                 if (ret != 0) {
                     goto exit_sske;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_FINALIZE;
             } /* case TLS_ASYNC_VERIFY */
             FALL_THROUGH;
 
             case TLS_ASYNC_FINALIZE:
             {
             #ifdef HAVE_QSH
                 if (ssl->peerQSHKeyPresent) {
                     if (args->qshSz > 0) {
                         args->idx = args->sendSz - args->qshSz;
                         if (QSH_KeyExchangeWrite(ssl, 1) != 0) {
                             ERROR_OUT(MEMORY_E, exit_sske);
                         }
 
                         /* extension type */
                         c16toa(TLSX_QUANTUM_SAFE_HYBRID,
                                                     args->output + args->idx);
                         args->idx += OPAQUE16_LEN;
 
                         /* write to output and check amount written */
                         if (TLSX_QSHPK_Write(ssl->QSH_secret->list,
                             args->output + args->idx) >
                                                 args->qshSz - OPAQUE16_LEN) {
                             ERROR_OUT(MEMORY_E, exit_sske);
                         }
                     }
                 }
             #endif
 
             #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                 if (ssl->specs.kea == ecdhe_psk_kea ||
                     ssl->specs.kea == ecc_diffie_hellman_kea) {
                     /* Check output to make sure it was set */
                     if (args->output) {
                         AddHeaders(args->output, args->length,
                                                     server_key_exchange, ssl);
                     }
                     else {
                         ERROR_OUT(BUFFER_ERROR, exit_sske);
                     }
                 }
             #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
 
                 if (IsEncryptionOn(ssl, 1)) {
                     args->inputSz = args->length + HANDSHAKE_HEADER_SZ;
                     if (ssl->options.dtls)
                         args->inputSz += DTLS_HANDSHAKE_EXTRA;
                     args->input = (byte*)XMALLOC(args->inputSz, ssl->heap,
                                                         DYNAMIC_TYPE_IN_BUFFER);
                     if (args->input == NULL) {
                         ERROR_OUT(MEMORY_E, exit_sske);
                     }
 
                     if (args->output == NULL) {
                         ERROR_OUT(BUFFER_ERROR, exit_sske);
                     }
 
                     if (!ssl->options.dtls)
                         XMEMCPY(args->input, args->output + RECORD_HEADER_SZ,
                                                                  args->inputSz);
                     else
                         XMEMCPY(args->input, args->output + DTLS_RECORD_HEADER_SZ,
                                                                  args->inputSz);
 
                     #ifdef WOLFSSL_DTLS
                     if (IsDtlsNotSctpMode(ssl) &&
                         (ret = DtlsMsgPoolSave(ssl, args->input, args->inputSz, server_key_exchange))
                             != 0) {
                         goto exit_sske;
                     }
                     #endif
                     ret = BuildMessage(ssl, args->output, args->sendSz,
                                 args->input, args->inputSz, handshake, 1, 0, 0, CUR_ORDER);
                     XFREE(args->input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
                     args->input = NULL;
                         /* make sure its not double free'd on cleanup */
 
                     if (ret >= 0) {
                         args->sendSz = ret;
                         ret = 0;
                     }
                 }
                 else {
                 #ifdef WOLFSSL_DTLS
                     if (IsDtlsNotSctpMode(ssl)) {
                         if ((ret = DtlsMsgPoolSave(ssl,
                                             args->output, args->sendSz, server_key_exchange)) != 0) {
                             goto exit_sske;
                         }
                     }
 
                     if (ssl->options.dtls)
                         DtlsSEQIncrement(ssl, CUR_ORDER);
                 #endif
 
                     ret = HashOutput(ssl, args->output, args->sendSz, 0);
                     if (ret != 0) {
                         goto exit_sske;
                     }
                 }
 
             #if defined(WOLFSSL_CALLBACKS) || defined(OPENSSL_EXTRA)
                 if (ssl->hsInfoOn) {
                     AddPacketName(ssl, "ServerKeyExchange");
                 }
                 if (ssl->toInfoOn) {
                     AddPacketInfo(ssl, "ServerKeyExchange", handshake,
                         args->output, args->sendSz, WRITE_PROTO, ssl->heap);
                 }
             #endif
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_END;
             } /* case TLS_ASYNC_FINALIZE */
             FALL_THROUGH;
 
             case TLS_ASYNC_END:
             {
                 ssl->buffers.outputBuffer.length += args->sendSz;
                 if (!ssl->options.groupMessages) {
                     ret = SendBuffered(ssl);
                 }
 
                 ssl->options.serverState = SERVER_KEYEXCHANGE_COMPLETE;
                 break;
             }
             default:
                 ret = INPUT_CASE_ERROR;
         } /* switch(ssl->options.asyncState) */
 
     exit_sske:
 
         WOLFSSL_LEAVE("SendServerKeyExchange", ret);
         WOLFSSL_END(WC_FUNC_SERVER_KEY_EXCHANGE_SEND);
 
     #ifdef WOLFSSL_ASYNC_CRYPT
         /* Handle async operation */
         if (ret == WC_PENDING_E)
             return ret;
     #endif /* WOLFSSL_ASYNC_CRYPT */
 
         /* Final cleanup */
         FreeSskeArgs(ssl, args);
         FreeKeyExchange(ssl);
 
         return ret;
     }
 
 #if defined(HAVE_SERVER_RENEGOTIATION_INFO) || defined(HAVE_FALLBACK_SCSV) || \
                                                             defined(OPENSSL_ALL)
 
     /* search suites for specific one, idx on success, negative on error */
 #ifndef WOLFSSL_TLS13
     static
 #endif
     int FindSuite(Suites* suites, byte first, byte second)
     {
         int i;
 
         if (suites == NULL || suites->suiteSz == 0) {
             WOLFSSL_MSG("Suites pointer error or suiteSz 0");
             return SUITES_ERROR;
         }
 
         for (i = 0; i < suites->suiteSz-1; i += SUITE_LEN) {
             if (suites->suites[i]   == first &&
                 suites->suites[i+1] == second )
                 return i;
         }
 
         return MATCH_SUITE_ERROR;
     }
 
 #endif
 
 #endif /* !WOLFSSL_NO_TLS12 */
 
     /* Make sure server cert/key are valid for this suite, true on success */
     static int VerifyServerSuite(WOLFSSL* ssl, word16 idx)
     {
         int  haveRSA = !ssl->options.haveStaticECC;
         int  havePSK = 0;
         byte first;
         byte second;
 
         WOLFSSL_ENTER("VerifyServerSuite");
 
         if (ssl->suites == NULL) {
             WOLFSSL_MSG("Suites pointer error");
             return 0;
         }
 
         first   = ssl->suites->suites[idx];
         second  = ssl->suites->suites[idx+1];
 
         #ifndef NO_PSK
             havePSK = ssl->options.havePSK;
         #endif
 
         if (ssl->options.haveNTRU)
             haveRSA = 0;
 
         if (CipherRequires(first, second, REQUIRES_RSA)) {
             WOLFSSL_MSG("Requires RSA");
             if (haveRSA == 0) {
                 WOLFSSL_MSG("Don't have RSA");
                 return 0;
             }
         }
 
         if (CipherRequires(first, second, REQUIRES_DHE)) {
             WOLFSSL_MSG("Requires DHE");
             if (ssl->options.haveDH == 0) {
                 WOLFSSL_MSG("Don't have DHE");
                 return 0;
             }
         }
 
         if (CipherRequires(first, second, REQUIRES_ECC)) {
             WOLFSSL_MSG("Requires ECC");
             if (ssl->options.haveECC == 0) {
                 WOLFSSL_MSG("Don't have ECC");
                 return 0;
             }
         }
 
         if (CipherRequires(first, second, REQUIRES_ECC_STATIC)) {
             WOLFSSL_MSG("Requires static ECC");
             if (ssl->options.haveStaticECC == 0) {
                 WOLFSSL_MSG("Don't have static ECC");
                 return 0;
             }
         }
 
         if (CipherRequires(first, second, REQUIRES_PSK)) {
             WOLFSSL_MSG("Requires PSK");
             if (havePSK == 0) {
                 WOLFSSL_MSG("Don't have PSK");
                 return 0;
             }
         }
 
         if (CipherRequires(first, second, REQUIRES_NTRU)) {
             WOLFSSL_MSG("Requires NTRU");
             if (ssl->options.haveNTRU == 0) {
                 WOLFSSL_MSG("Don't have NTRU");
                 return 0;
             }
         }
 
         if (CipherRequires(first, second, REQUIRES_RSA_SIG)) {
             WOLFSSL_MSG("Requires RSA Signature");
             if (ssl->options.side == WOLFSSL_SERVER_END &&
                                            ssl->options.haveECDSAsig == 1) {
                 WOLFSSL_MSG("Don't have RSA Signature");
                 return 0;
             }
         }
 
 #if !defined(WOLFSSL_OLDTLS_AEAD_CIPHERSUITES)
         if (CipherRequires(first, second, REQUIRES_AEAD)) {
             WOLFSSL_MSG("Requires AEAD");
             if (ssl->version.major == SSLv3_MAJOR &&
                                            ssl->version.minor < TLSv1_2_MINOR) {
                 WOLFSSL_MSG("Version of SSL does not support AEAD ciphers");
                 return 0;
             }
 
         }
 #endif
 
 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                        defined(HAVE_CURVE448)) && defined(HAVE_SUPPORTED_CURVES)
         if (!TLSX_ValidateSupportedCurves(ssl, first, second)) {
             WOLFSSL_MSG("Don't have matching curves");
             return 0;
         }
 #endif
 
         /* ECCDHE is always supported if ECC on */
 
 #ifdef HAVE_QSH
         /* need to negotiate a classic suite in addition to TLS_QSH */
         if (first == QSH_BYTE && second == TLS_QSH) {
             if (TLSX_SupportExtensions(ssl)) {
                 ssl->options.haveQSH = 1; /* matched TLS_QSH */
             }
             else {
                 WOLFSSL_MSG("Version of SSL connection does not support "
                             "TLS_QSH");
             }
             return 0;
         }
 #endif
 
 #ifdef WOLFSSL_TLS13
         if (IsAtLeastTLSv1_3(ssl->version) &&
             ssl->options.side == WOLFSSL_SERVER_END) {
             /* Try to establish a key share. */
             int ret = TLSX_KeyShare_Establish(ssl);
             if (ret == KEY_SHARE_ERROR)
                 ssl->options.serverState = SERVER_HELLO_RETRY_REQUEST_COMPLETE;
             else if (ret != 0)
                 return 0;
         }
         else if (first == TLS13_BYTE || (first == ECC_BYTE &&
                 (second == TLS_SHA256_SHA256 || second == TLS_SHA384_SHA384))) {
             /* Can't negotiate TLS 1.3 cipher suites with lower protocol
              * version. */
             return 0;
         }
 #endif
 
         return 1;
     }
 
 #ifndef NO_WOLFSSL_SERVER
     static int CompareSuites(WOLFSSL* ssl, Suites* peerSuites, word16 i,
                              word16 j)
     {
         if (ssl->suites->suites[i]   == peerSuites->suites[j] &&
             ssl->suites->suites[i+1] == peerSuites->suites[j+1] ) {
 
             if (VerifyServerSuite(ssl, i)) {
                 int result;
                 WOLFSSL_MSG("Verified suite validity");
                 ssl->options.cipherSuite0 = ssl->suites->suites[i];
                 ssl->options.cipherSuite  = ssl->suites->suites[i+1];
                 result = SetCipherSpecs(ssl);
                 if (result == 0) {
                     result = PickHashSigAlgo(ssl, peerSuites->hashSigAlgo,
                                                      peerSuites->hashSigAlgoSz);
                 }
                 return result;
             }
             else {
                 WOLFSSL_MSG("Could not verify suite validity, continue");
             }
         }
 
         return MATCH_SUITE_ERROR;
     }
 
     int MatchSuite(WOLFSSL* ssl, Suites* peerSuites)
     {
         int ret;
         word16 i, j;
 
         WOLFSSL_ENTER("MatchSuite");
 
         /* & 0x1 equivalent % 2 */
         if (peerSuites->suiteSz == 0 || peerSuites->suiteSz & 0x1)
             return BUFFER_ERROR;
 
         if (ssl->suites == NULL)
             return SUITES_ERROR;
 
         if (!ssl->options.useClientOrder) {
             /* Server order */
             for (i = 0; i < ssl->suites->suiteSz; i += 2) {
                 for (j = 0; j < peerSuites->suiteSz; j += 2) {
                     ret = CompareSuites(ssl, peerSuites, i, j);
                     if (ret != MATCH_SUITE_ERROR)
                         return ret;
                 }
             }
         }
         else {
             /* Client order */
             for (j = 0; j < peerSuites->suiteSz; j += 2) {
                 for (i = 0; i < ssl->suites->suiteSz; i += 2) {
                     ret = CompareSuites(ssl, peerSuites, i, j);
                     if (ret != MATCH_SUITE_ERROR)
                         return ret;
                 }
             }
         }
 
         return MATCH_SUITE_ERROR;
     }
 #endif
 
 #ifdef OLD_HELLO_ALLOWED
 
     /* process old style client hello, deprecate? */
     int ProcessOldClientHello(WOLFSSL* ssl, const byte* input, word32* inOutIdx,
                               word32 inSz, word16 sz)
     {
         word32          idx = *inOutIdx;
         word16          sessionSz;
         word16          randomSz;
         word16          i, j;
         ProtocolVersion pv;
         Suites          clSuites;
         int ret = -1;
 
         (void)inSz;
         WOLFSSL_MSG("Got old format client hello");
 #ifdef WOLFSSL_CALLBACKS
         if (ssl->hsInfoOn)
             AddPacketName(ssl, "ClientHello");
         if (ssl->toInfoOn)
             AddLateName("ClientHello", &ssl->timeoutInfo);
 #endif
 
         /* manually hash input since different format */
 #ifndef NO_OLD_TLS
 #ifndef NO_MD5
         wc_Md5Update(&ssl->hsHashes->hashMd5, input + idx, sz);
 #endif
 #ifndef NO_SHA
         wc_ShaUpdate(&ssl->hsHashes->hashSha, input + idx, sz);
 #endif
 #endif
 #ifndef NO_SHA256
         if (IsAtLeastTLSv1_2(ssl)) {
             int shaRet = wc_Sha256Update(&ssl->hsHashes->hashSha256,
                                          input + idx, sz);
             if (shaRet != 0)
                 return shaRet;
         }
 #endif
 
         /* does this value mean client_hello? */
         idx++;
 
         /* version */
         pv.major = input[idx++];
         pv.minor = input[idx++];
         ssl->chVersion = pv;  /* store */
 
         if (ssl->version.minor > pv.minor) {
             byte haveRSA = 0;
             byte havePSK = 0;
             int  keySz   = 0;
 
             if (!ssl->options.downgrade) {
                 WOLFSSL_MSG("Client trying to connect with lesser version");
                 return VERSION_ERROR;
             }
             if (pv.minor < ssl->options.minDowngrade) {
                 WOLFSSL_MSG("\tversion below minimum allowed, fatal error");
                 return VERSION_ERROR;
             }
             if (pv.minor == SSLv3_MINOR) {
                 /* turn off tls */
                 WOLFSSL_MSG("\tdowngrading to SSLv3");
                 ssl->options.tls    = 0;
                 ssl->options.tls1_1 = 0;
                 ssl->version.minor  = SSLv3_MINOR;
             }
             else if (pv.minor == TLSv1_MINOR) {
                 WOLFSSL_MSG("\tdowngrading to TLSv1");
                 /* turn off tls 1.1+ */
                 ssl->options.tls1_1 = 0;
                 ssl->version.minor  = TLSv1_MINOR;
             }
             else if (pv.minor == TLSv1_1_MINOR) {
                 WOLFSSL_MSG("\tdowngrading to TLSv1.1");
                 ssl->version.minor  = TLSv1_1_MINOR;
             }
             else if (pv.minor == TLSv1_2_MINOR) {
                 WOLFSSL_MSG("    downgrading to TLSv1.2");
                 ssl->version.minor  = TLSv1_2_MINOR;
             }
 #ifndef NO_RSA
             haveRSA = 1;
 #endif
 #ifndef NO_PSK
             havePSK = ssl->options.havePSK;
 #endif
 #ifndef NO_CERTS
             keySz = ssl->buffers.keySz;
 #endif
 
             InitSuites(ssl->suites, ssl->version, keySz, haveRSA, havePSK,
                        ssl->options.haveDH, ssl->options.haveNTRU,
                        ssl->options.haveECDSAsig, ssl->options.haveECC,
                        ssl->options.haveStaticECC, ssl->options.side);
         }
 
         /* suite size */
         ato16(&input[idx], &clSuites.suiteSz);
         idx += OPAQUE16_LEN;
 
         if (clSuites.suiteSz > WOLFSSL_MAX_SUITE_SZ)
             return BUFFER_ERROR;
         /* Make sure the suiteSz is a multiple of 3. (Old Client Hello) */
         if (clSuites.suiteSz % 3 != 0)
             return BUFFER_ERROR;
         clSuites.hashSigAlgoSz = 0;
 
         /* session size */
         ato16(&input[idx], &sessionSz);
         idx += OPAQUE16_LEN;
 
         if (sessionSz > ID_LEN)
             return BUFFER_ERROR;
 
         /* random size */
         ato16(&input[idx], &randomSz);
         idx += OPAQUE16_LEN;
 
         if (randomSz > RAN_LEN)
             return BUFFER_ERROR;
 
         /* suites */
         for (i = 0, j = 0; i < clSuites.suiteSz; i += 3) {
             byte first = input[idx++];
             if (!first) { /* implicit: skip sslv2 type */
                 XMEMCPY(&clSuites.suites[j], &input[idx], SUITE_LEN);
                 j += SUITE_LEN;
             }
             idx += SUITE_LEN;
         }
         clSuites.suiteSz = j;
 
         /* session id */
         if (sessionSz) {
             XMEMCPY(ssl->arrays->sessionID, input + idx, sessionSz);
             ssl->arrays->sessionIDSz = (byte)sessionSz;
             idx += sessionSz;
             ssl->options.resuming = 1;
         }
 
         /* random */
         if (randomSz < RAN_LEN)
             XMEMSET(ssl->arrays->clientRandom, 0, RAN_LEN - randomSz);
         XMEMCPY(&ssl->arrays->clientRandom[RAN_LEN - randomSz], input + idx,
                randomSz);
         idx += randomSz;
 
         if (ssl->options.usingCompression)
             ssl->options.usingCompression = 0;  /* turn off */
 
         ssl->options.clientState = CLIENT_HELLO_COMPLETE;
         ssl->cbmode = SSL_CB_MODE_WRITE;
         *inOutIdx = idx;
 
         ssl->options.haveSessionId = 1;
         /* DoClientHello uses same resume code */
         if (ssl->options.resuming) {  /* let's try */
             WOLFSSL_SESSION* session = GetSession(ssl,
                                                   ssl->arrays->masterSecret, 1);
             #ifdef HAVE_SESSION_TICKET
                 if (ssl->options.useTicket == 1) {
                     session = &ssl->session;
                 }
             #endif
 
             if (!session) {
                 WOLFSSL_MSG("Session lookup for resume failed");
                 ssl->options.resuming = 0;
             } else {
             #ifdef HAVE_EXT_CACHE
                 wolfSSL_SESSION_free(session);
             #endif
                 if (MatchSuite(ssl, &clSuites) < 0) {
                     WOLFSSL_MSG("Unsupported cipher suite, OldClientHello");
                     return UNSUPPORTED_SUITE;
                 }
 
                 ret = wc_RNG_GenerateBlock(ssl->rng, ssl->arrays->serverRandom,
                                                                        RAN_LEN);
                 if (ret != 0)
                     return ret;
 
                 #ifdef NO_OLD_TLS
                     ret = DeriveTlsKeys(ssl);
                 #else
                     #ifndef NO_TLS
                         if (ssl->options.tls)
                             ret = DeriveTlsKeys(ssl);
                     #endif
                         if (!ssl->options.tls)
                             ret = DeriveKeys(ssl);
                 #endif
                 ssl->options.clientState = CLIENT_KEYEXCHANGE_COMPLETE;
 
                 return ret;
             }
         }
 
         ret = MatchSuite(ssl, &clSuites);
         if (ret != 0)return ret;
         return SanityCheckMsgReceived(ssl, client_hello);
     }
 
 #endif /* OLD_HELLO_ALLOWED */
 
 #ifndef WOLFSSL_NO_TLS12
 
     int HandleTlsResumption(WOLFSSL* ssl, int bogusID, Suites* clSuites)
     {
         int ret = 0;
         WOLFSSL_SESSION* session;
 
         (void)bogusID;
 
         session = GetSession(ssl, ssl->arrays->masterSecret, 1);
         #ifdef HAVE_SESSION_TICKET
             if (ssl->options.useTicket == 1) {
                 session = &ssl->session;
             } else if (bogusID == 1 && ssl->options.rejectTicket == 0) {
                 WOLFSSL_MSG("Bogus session ID without session ticket");
                 return BUFFER_ERROR;
             }
         #endif
 
         if (!session) {
             WOLFSSL_MSG("Session lookup for resume failed");
             ssl->options.resuming = 0;
         }
         else if (session->haveEMS != ssl->options.haveEMS) {
             /* RFC 7627, 5.3, server-side */
             /* if old sess didn't have EMS, but new does, full handshake */
             if (!session->haveEMS && ssl->options.haveEMS) {
                 WOLFSSL_MSG("Attempting to resume a session that didn't "
                             "use EMS with a new session with EMS. Do full "
                             "handshake.");
                 ssl->options.resuming = 0;
             }
             /* if old sess used EMS, but new doesn't, MUST abort */
             else if (session->haveEMS && !ssl->options.haveEMS) {
                 WOLFSSL_MSG("Trying to resume a session with EMS without "
                             "using EMS");
             #ifdef WOLFSSL_EXTRA_ALERTS
                 SendAlert(ssl, alert_fatal, handshake_failure);
             #endif
                 #ifdef HAVE_EXT_CACHE
                     wolfSSL_SESSION_free(session);
                 #endif
                 return EXT_MASTER_SECRET_NEEDED_E;
             }
         #ifdef HAVE_EXT_CACHE
             wolfSSL_SESSION_free(session);
         #endif
         }
         else {
         #ifndef NO_RESUME_SUITE_CHECK
             int j;
 
             /* Check client suites include the one in session */
             for (j = 0; j < clSuites->suiteSz; j += 2) {
                 if (clSuites->suites[j] == session->cipherSuite0 &&
                                 clSuites->suites[j+1] == session->cipherSuite) {
                     break;
                 }
             }
             if (j == clSuites->suiteSz) {
                 WOLFSSL_MSG("Prev session's cipher suite not in ClientHello");
             #ifdef WOLFSSL_EXTRA_ALERTS
                 SendAlert(ssl, alert_fatal, illegal_parameter);
             #endif
                 return UNSUPPORTED_SUITE;
             }
         #endif
 
         #ifdef HAVE_EXT_CACHE
             wolfSSL_SESSION_free(session);
         #endif
             if (MatchSuite(ssl, clSuites) < 0) {
                 WOLFSSL_MSG("Unsupported cipher suite, ClientHello");
                 return UNSUPPORTED_SUITE;
             }
 
             ret = wc_RNG_GenerateBlock(ssl->rng, ssl->arrays->serverRandom,
                                                                        RAN_LEN);
             if (ret != 0)
                 return ret;
 
             #ifdef NO_OLD_TLS
                 ret = DeriveTlsKeys(ssl);
             #else
                 #ifndef NO_TLS
                     if (ssl->options.tls)
                         ret = DeriveTlsKeys(ssl);
                 #endif
                     if (!ssl->options.tls)
                         ret = DeriveKeys(ssl);
             #endif
             ssl->options.clientState = CLIENT_KEYEXCHANGE_COMPLETE;
         }
 
         return ret;
     }
 
 
     /* handle processing of client_hello (1) */
     int DoClientHello(WOLFSSL* ssl, const byte* input, word32* inOutIdx,
                              word32 helloSz)
     {
         byte            b;
         byte            bogusID = 0;   /* flag for a bogus session id */
         ProtocolVersion pv;
         Suites          clSuites;
         word32          i = *inOutIdx;
         word32          begin = i;
         int             ret = 0;
 #ifdef WOLFSSL_DTLS
         Hmac            cookieHmac;
         byte            peerCookie[MAX_COOKIE_LEN];
         byte            peerCookieSz = 0;
         byte            cookieType;
         byte            cookieSz = 0;
 
         XMEMSET(&cookieHmac, 0, sizeof(Hmac));
 #endif /* WOLFSSL_DTLS */
 
         WOLFSSL_START(WC_FUNC_CLIENT_HELLO_DO);
         WOLFSSL_ENTER("DoClientHello");
 
 #ifdef WOLFSSL_CALLBACKS
         if (ssl->hsInfoOn) AddPacketName(ssl, "ClientHello");
         if (ssl->toInfoOn) AddLateName("ClientHello", &ssl->timeoutInfo);
 #endif
         /* protocol version, random and session id length check */
         if (OPAQUE16_LEN + RAN_LEN + OPAQUE8_LEN > helloSz)
             return BUFFER_ERROR;
 
         /* protocol version */
         XMEMCPY(&pv, input + i, OPAQUE16_LEN);
         ssl->chVersion = pv;   /* store */
 #ifdef WOLFSSL_DTLS
         if (IsDtlsNotSctpMode(ssl) && !IsSCR(ssl) && !ssl->options.resuming) {
             #if defined(NO_SHA) && defined(NO_SHA256)
                 #error "DTLS needs either SHA or SHA-256"
             #endif /* NO_SHA && NO_SHA256 */
 
             #if !defined(NO_SHA) && defined(NO_SHA256)
                 cookieType = WC_SHA;
                 cookieSz = WC_SHA_DIGEST_SIZE;
             #endif /* NO_SHA */
             #ifndef NO_SHA256
                 cookieType = WC_SHA256;
                 cookieSz = WC_SHA256_DIGEST_SIZE;
             #endif /* NO_SHA256 */
             ret = wc_HmacSetKey(&cookieHmac, cookieType,
                                 ssl->buffers.dtlsCookieSecret.buffer,
                                 ssl->buffers.dtlsCookieSecret.length);
             if (ret != 0) goto out;
             ret = wc_HmacUpdate(&cookieHmac,
                                 (const byte*)ssl->buffers.dtlsCtx.peer.sa,
                                 ssl->buffers.dtlsCtx.peer.sz);
             if (ret != 0) goto out;
             ret = wc_HmacUpdate(&cookieHmac, input + i, OPAQUE16_LEN);
             if (ret != 0) goto out;
         }
 #endif /* WOLFSSL_DTLS */
         i += OPAQUE16_LEN;
 
         /* Legacy protocol version cannot negotiate TLS 1.3 or higher. */
         if (pv.major == SSLv3_MAJOR && pv.minor >= TLSv1_3_MINOR)
             pv.minor = TLSv1_2_MINOR;
 
         if ((!ssl->options.dtls && ssl->version.minor > pv.minor) ||
             (ssl->options.dtls && ssl->version.minor != DTLS_MINOR
              && ssl->version.minor != DTLSv1_2_MINOR && pv.minor != DTLS_MINOR
              && pv.minor != DTLSv1_2_MINOR)) {
 
             word16 haveRSA = 0;
             word16 havePSK = 0;
             int    keySz   = 0;
 
             if (!ssl->options.downgrade) {
                 WOLFSSL_MSG("Client trying to connect with lesser version");
                 ret = VERSION_ERROR;
                 goto out;
             }
             if (pv.minor < ssl->options.minDowngrade) {
                 WOLFSSL_MSG("\tversion below minimum allowed, fatal error");
                 ret = VERSION_ERROR;
                 goto out;
             }
 
             if (pv.minor == SSLv3_MINOR) {
                 /* turn off tls */
                 WOLFSSL_MSG("\tdowngrading to SSLv3");
                 ssl->options.tls    = 0;
                 ssl->options.tls1_1 = 0;
                 ssl->version.minor  = SSLv3_MINOR;
             }
             else if (pv.minor == TLSv1_MINOR) {
                 /* turn off tls 1.1+ */
                 WOLFSSL_MSG("\tdowngrading to TLSv1");
                 ssl->options.tls1_1 = 0;
                 ssl->version.minor  = TLSv1_MINOR;
             }
             else if (pv.minor == TLSv1_1_MINOR) {
                 WOLFSSL_MSG("\tdowngrading to TLSv1.1");
                 ssl->version.minor  = TLSv1_1_MINOR;
             }
             else if (pv.minor == TLSv1_2_MINOR) {
                 WOLFSSL_MSG("    downgrading to TLSv1.2");
                 ssl->version.minor  = TLSv1_2_MINOR;
             }
 #ifndef NO_RSA
             haveRSA = 1;
 #endif
 #ifndef NO_PSK
             havePSK = ssl->options.havePSK;
 #endif
 #ifndef NO_CERTS
             keySz = ssl->buffers.keySz;
 #endif
             InitSuites(ssl->suites, ssl->version, keySz, haveRSA, havePSK,
                        ssl->options.haveDH, ssl->options.haveNTRU,
                        ssl->options.haveECDSAsig, ssl->options.haveECC,
                        ssl->options.haveStaticECC, ssl->options.side);
         }
 
 #ifdef OPENSSL_EXTRA
         /* check if option is set to not allow the current version
          * set from either wolfSSL_set_options or wolfSSL_CTX_set_options */
         if (!ssl->options.dtls && ssl->options.downgrade &&
                 ssl->options.mask > 0) {
             int reset = 0;
             if (ssl->version.minor == TLSv1_2_MINOR &&
              (ssl->options.mask & SSL_OP_NO_TLSv1_2) == SSL_OP_NO_TLSv1_2) {
                 WOLFSSL_MSG("\tOption set to not allow TLSv1.2, Downgrading");
                 ssl->version.minor = TLSv1_1_MINOR;
                 reset = 1;
             }
             if (ssl->version.minor == TLSv1_1_MINOR &&
              (ssl->options.mask & SSL_OP_NO_TLSv1_1) == SSL_OP_NO_TLSv1_1) {
                 WOLFSSL_MSG("\tOption set to not allow TLSv1.1, Downgrading");
                 ssl->options.tls1_1 = 0;
                 ssl->version.minor = TLSv1_MINOR;
                 reset = 1;
             }
             if (ssl->version.minor == TLSv1_MINOR &&
                 (ssl->options.mask & SSL_OP_NO_TLSv1) == SSL_OP_NO_TLSv1) {
                 WOLFSSL_MSG("\tOption set to not allow TLSv1, Downgrading");
                 ssl->options.tls    = 0;
                 ssl->options.tls1_1 = 0;
                 ssl->version.minor = SSLv3_MINOR;
                 reset = 1;
             }
             if (ssl->version.minor == SSLv3_MINOR &&
                 (ssl->options.mask & SSL_OP_NO_SSLv3) == SSL_OP_NO_SSLv3) {
                 WOLFSSL_MSG("\tError, option set to not allow SSLv3");
                 ret = VERSION_ERROR;
                 goto out;
             }
 
             if (ssl->version.minor < ssl->options.minDowngrade) {
                 WOLFSSL_MSG("\tversion below minimum allowed, fatal error");
                 ret = VERSION_ERROR;
                 goto out;
             }
 
             if (reset) {
                 word16 haveRSA = 0;
                 word16 havePSK = 0;
                 int    keySz   = 0;
 
             #ifndef NO_RSA
                 haveRSA = 1;
             #endif
             #ifndef NO_PSK
                 havePSK = ssl->options.havePSK;
             #endif
             #ifndef NO_CERTS
                 keySz = ssl->buffers.keySz;
             #endif
 
                 /* reset cipher suites to account for TLS version change */
                 InitSuites(ssl->suites, ssl->version, keySz, haveRSA, havePSK,
                        ssl->options.haveDH, ssl->options.haveNTRU,
                        ssl->options.haveECDSAsig, ssl->options.haveECC,
                        ssl->options.haveStaticECC, ssl->options.side);
             }
         }
 #endif
 
         /* random */
         XMEMCPY(ssl->arrays->clientRandom, input + i, RAN_LEN);
 #ifdef WOLFSSL_DTLS
         if (IsDtlsNotSctpMode(ssl) && !IsSCR(ssl) && !ssl->options.resuming) {
             ret = wc_HmacUpdate(&cookieHmac, input + i, RAN_LEN);
             if (ret != 0) goto out;
         }
 #endif /* WOLFSSL_DTLS */
         i += RAN_LEN;
 
 #ifdef SHOW_SECRETS
         {
             int j;
             printf("client random: ");
             for (j = 0; j < RAN_LEN; j++)
                 printf("%02x", ssl->arrays->clientRandom[j]);
             printf("\n");
         }
 #endif
 
         /* session id */
         b = input[i++];
 
 #ifdef HAVE_SESSION_TICKET
         if (b > 0 && b < ID_LEN) {
             bogusID = 1;
             WOLFSSL_MSG("Client sent bogus session id, let's allow for echo");
         }
 #endif
 
         if (b == ID_LEN || bogusID) {
             if ((i - begin) + b > helloSz) {
                 ret = BUFFER_ERROR;
                 goto out;
             }
 
             XMEMCPY(ssl->arrays->sessionID, input + i, b);
 #ifdef WOLFSSL_DTLS
             if (IsDtlsNotSctpMode(ssl) && !IsSCR(ssl) &&
                     !ssl->options.resuming) {
                 ret = wc_HmacUpdate(&cookieHmac, input + i - 1, b + 1);
                 if (ret != 0) goto out;
             }
 #endif /* WOLFSSL_DTLS */
             ssl->arrays->sessionIDSz = b;
             i += b;
             ssl->options.resuming = 1; /* client wants to resume */
             WOLFSSL_MSG("Client wants to resume session");
         }
         else if (b) {
             WOLFSSL_MSG("Invalid session ID size");
             ret = BUFFER_ERROR; /* session ID nor 0 neither 32 bytes long */
             goto out;
         }
 
         #ifdef WOLFSSL_DTLS
             /* cookie */
             if (ssl->options.dtls) {
 
                 if ((i - begin) + OPAQUE8_LEN > helloSz) {
                     ret = BUFFER_ERROR;
                     goto out;
                 }
 
                 peerCookieSz = input[i++];
 
                 if (peerCookieSz) {
                     if (peerCookieSz > MAX_COOKIE_LEN) {
                         ret = BUFFER_ERROR;
                         goto out;
                     }
 
                     if ((i - begin) + peerCookieSz > helloSz) {
                         ret = BUFFER_ERROR;
                         goto out;
                     }
 
                     XMEMCPY(peerCookie, input + i, peerCookieSz);
 
                     i += peerCookieSz;
                 }
             }
         #endif
 
         /* suites */
         if ((i - begin) + OPAQUE16_LEN > helloSz) {
             ret = BUFFER_ERROR;
             goto out;
         }
 
         ato16(&input[i], &clSuites.suiteSz);
         i += OPAQUE16_LEN;
 
         /* Cipher suite lists are always multiples of two in length. */
         if (clSuites.suiteSz % 2 != 0) {
             ret = BUFFER_ERROR;
             goto out;
         }
 
         /* suites and compression length check */
         if ((i - begin) + clSuites.suiteSz + OPAQUE8_LEN > helloSz) {
             ret = BUFFER_ERROR;
             goto out;
         }
 
         if (clSuites.suiteSz > WOLFSSL_MAX_SUITE_SZ) {
             ret = BUFFER_ERROR;
             goto out;
         }
 
         XMEMCPY(clSuites.suites, input + i, clSuites.suiteSz);
 
 #ifdef HAVE_SERVER_RENEGOTIATION_INFO
         /* check for TLS_EMPTY_RENEGOTIATION_INFO_SCSV suite */
         if (FindSuite(&clSuites, 0, TLS_EMPTY_RENEGOTIATION_INFO_SCSV) >= 0) {
             TLSX* extension;
 
             /* check for TLS_EMPTY_RENEGOTIATION_INFO_SCSV suite */
             ret = TLSX_AddEmptyRenegotiationInfo(&ssl->extensions, ssl->heap);
             if (ret != WOLFSSL_SUCCESS)
                 goto out;
 
             extension = TLSX_Find(ssl->extensions, TLSX_RENEGOTIATION_INFO);
             if (extension) {
                 ssl->secure_renegotiation =
                                           (SecureRenegotiation*)extension->data;
                 ssl->secure_renegotiation->enabled = 1;
             }
         }
 #endif /* HAVE_SERVER_RENEGOTIATION_INFO */
 #if defined(HAVE_FALLBACK_SCSV) || defined(OPENSSL_ALL)
         /* check for TLS_FALLBACK_SCSV suite */
         if (FindSuite(&clSuites, TLS_FALLBACK_SCSV, 0) >= 0) {
             WOLFSSL_MSG("Found Fallback SCSV");
             if (ssl->ctx->method->version.minor > pv.minor) {
                 WOLFSSL_MSG("Client trying to connect with lesser version");
                 SendAlert(ssl, alert_fatal, inappropriate_fallback);
                 ret = VERSION_ERROR;
                 goto out;
             }
         }
 #endif
 
 #ifdef WOLFSSL_DTLS
         if (IsDtlsNotSctpMode(ssl) && !IsSCR(ssl) && !ssl->options.resuming) {
             ret = wc_HmacUpdate(&cookieHmac,
                                     input + i - OPAQUE16_LEN,
                                     clSuites.suiteSz + OPAQUE16_LEN);
             if (ret != 0) goto out;
         }
 #endif /* WOLFSSL_DTLS */
         i += clSuites.suiteSz;
         clSuites.hashSigAlgoSz = 0;
 
         /* compression length */
         b = input[i++];
 
         if ((i - begin) + b > helloSz) {
             ret = BUFFER_ERROR;
             goto out;
         }
 
         if (b == 0) {
             WOLFSSL_MSG("No compression types in list");
 #ifdef WOLFSSL_EXTRA_ALERTS
             SendAlert(ssl, alert_fatal, decode_error);
 #endif
             ret = COMPRESSION_ERROR;
             goto out;
         }
 
 #ifdef WOLFSSL_DTLS
         if (IsDtlsNotSctpMode(ssl)) {
             if (!IsSCR(ssl) && !ssl->options.resuming) {
                 byte newCookie[MAX_COOKIE_LEN];
 
                 ret = wc_HmacUpdate(&cookieHmac, input + i - 1, b + 1);
                 if (ret != 0) goto out;
                 ret = wc_HmacFinal(&cookieHmac, newCookie);
                 if (ret != 0) goto out;
 
                 /* If a cookie callback is set, call it to overwrite the cookie.
                  * This should be deprecated. The code now calculates the cookie
                  * using an HMAC as expected. */
                 if (ssl->ctx->CBIOCookie != NULL &&
                     ssl->ctx->CBIOCookie(ssl, newCookie, cookieSz,
                                                  ssl->IOCB_CookieCtx) != cookieSz) {
                     ret = COOKIE_ERROR;
                     goto out;
                 }
 
                 /* Check the cookie, see if we progress the state machine. */
                 if (peerCookieSz != cookieSz ||
                     XMEMCMP(peerCookie, newCookie, cookieSz) != 0) {
 
                     /* Send newCookie to client in a HelloVerifyRequest message
                      * and let the state machine alone. */
                     ssl->msgsReceived.got_client_hello = 0;
                     ssl->keys.dtls_handshake_number = 0;
                     ssl->keys.dtls_expected_peer_handshake_number = 0;
                     *inOutIdx += helloSz;
                     ret = SendHelloVerifyRequest(ssl, newCookie, cookieSz);
                     goto out;
                 }
             }
 
             /* This was skipped in the DTLS case so we could handle the hello
              * verify request. */
             ret = HashInput(ssl, input + *inOutIdx, helloSz);
             if (ret != 0) goto out;
         }
 #endif /* WOLFSSL_DTLS */
 
         {
             /* compression match types */
             int matchNo = 0;
             int matchZlib = 0;
 
             while (b--) {
                 byte comp = input[i++];
 
                 if (comp == NO_COMPRESSION) {
                     matchNo = 1;
                 }
                 if (comp == ZLIB_COMPRESSION) {
                     matchZlib = 1;
                 }
             }
 
             if (ssl->options.usingCompression == 0 && matchNo) {
                 WOLFSSL_MSG("Matched No Compression");
             } else if (ssl->options.usingCompression && matchZlib) {
                 WOLFSSL_MSG("Matched zlib Compression");
             } else if (ssl->options.usingCompression && matchNo) {
                 WOLFSSL_MSG("Could only match no compression, turning off");
                 ssl->options.usingCompression = 0;  /* turn off */
             } else {
                 WOLFSSL_MSG("Could not match compression");
 #ifdef WOLFSSL_EXTRA_ALERTS
                 SendAlert(ssl, alert_fatal, illegal_parameter);
 #endif
                 ret = COMPRESSION_ERROR;
                 goto out;
             }
         }
 
         *inOutIdx = i;
 
         /* tls extensions */
         if ((i - begin) < helloSz) {
 #ifdef HAVE_TLS_EXTENSIONS
         #ifdef HAVE_QSH
             QSH_Init(ssl);
         #endif
             if (TLSX_SupportExtensions(ssl))
 #else
             if (IsAtLeastTLSv1_2(ssl))
 #endif
             {
                 /* Process the hello extension. Skip unsupported. */
                 word16 totalExtSz;
 
 #ifdef HAVE_TLS_EXTENSIONS
                 /* auto populate extensions supported unless user defined */
                 if ((ret = TLSX_PopulateExtensions(ssl, 1)) != 0)
                     goto out;
 #endif
 
                 if ((i - begin) + OPAQUE16_LEN > helloSz) {
                     ret = BUFFER_ERROR;
                     goto out;
                 }
 
                 ato16(&input[i], &totalExtSz);
                 i += OPAQUE16_LEN;
 
                 if ((i - begin) + totalExtSz > helloSz) {
                     ret = BUFFER_ERROR;
                     goto out;
                 }
 
 #ifdef HAVE_TLS_EXTENSIONS
                 /* tls extensions */
                 if ((ret = TLSX_Parse(ssl, (byte *) input + i, totalExtSz,
                                       client_hello, &clSuites)))
                     goto out;
     #ifdef WOLFSSL_TLS13
                 if (TLSX_Find(ssl->extensions,
                                              TLSX_SUPPORTED_VERSIONS) != NULL) {
                     WOLFSSL_MSG(
                             "Client attempting to connect with higher version");
                     ret = VERSION_ERROR;
                     goto out;
                 }
     #endif
     #if defined(OPENSSL_ALL) || defined(HAVE_STUNNEL) || defined(WOLFSSL_NGINX) || defined(WOLFSSL_HAPROXY) || defined(HAVE_LIGHTY)
                 if((ret=SNI_Callback(ssl)))
                     goto out;
                 ssl->options.side = WOLFSSL_SERVER_END;
     #endif
 
                 i += totalExtSz;
 #else
                 while (totalExtSz) {
                     word16 extId, extSz;
 
                     if (OPAQUE16_LEN + OPAQUE16_LEN > totalExtSz) {
                         ret = BUFFER_ERROR;
                         goto out;
                     }
 
                     ato16(&input[i], &extId);
                     i += OPAQUE16_LEN;
                     ato16(&input[i], &extSz);
                     i += OPAQUE16_LEN;
 
                     if (OPAQUE16_LEN + OPAQUE16_LEN + extSz > totalExtSz) {
                         ret = BUFFER_ERROR;
                         goto out;
                     }
 
                     if (extId == HELLO_EXT_SIG_ALGO) {
                         word16 hashSigAlgoSz;
 
                         ato16(&input[i], &hashSigAlgoSz);
                         i += OPAQUE16_LEN;
 
                         if (OPAQUE16_LEN + hashSigAlgoSz > extSz) {
                             ret = BUFFER_ERROR;
                             goto out;
                         }
 
                         if (hashSigAlgoSz % 2 != 0) {
                             ret = BUFFER_ERROR;
                             goto out;
                         }
 
                         clSuites.hashSigAlgoSz = hashSigAlgoSz;
                         if (clSuites.hashSigAlgoSz > WOLFSSL_MAX_SIGALGO) {
                             WOLFSSL_MSG("ClientHello SigAlgo list exceeds max, "
                                                                   "truncating");
                             clSuites.hashSigAlgoSz = WOLFSSL_MAX_SIGALGO;
                         }
 
                         XMEMCPY(clSuites.hashSigAlgo, &input[i],
                                                       clSuites.hashSigAlgoSz);
 
                         i += hashSigAlgoSz;
                     }
 #ifdef HAVE_EXTENDED_MASTER
                     else if (extId == HELLO_EXT_EXTMS)
                         ssl->options.haveEMS = 1;
 #endif
                     else
                         i += extSz;
 
                     totalExtSz -= OPAQUE16_LEN + OPAQUE16_LEN + extSz;
                 }
 #endif
                 *inOutIdx = i;
             }
             else
                 *inOutIdx = begin + helloSz; /* skip extensions */
         }
 
         ssl->options.clientState   = CLIENT_HELLO_COMPLETE;
         ssl->options.haveSessionId = 1;
 
         /* ProcessOld uses same resume code */
         if (ssl->options.resuming) {
             ret = HandleTlsResumption(ssl, bogusID, &clSuites);
             if (ret != 0)
                 goto out;
 
             #ifdef HAVE_SECURE_RENEGOTIATION
             if (ssl->secure_renegotiation &&
                     ssl->secure_renegotiation->enabled &&
                     IsEncryptionOn(ssl, 0))
                 ssl->secure_renegotiation->startScr = 1;
             #endif
 
             if (ssl->options.clientState == CLIENT_KEYEXCHANGE_COMPLETE) {
                 WOLFSSL_LEAVE("DoClientHello", ret);
                 WOLFSSL_END(WC_FUNC_CLIENT_HELLO_DO);
 
                 goto out;
             }
         }
 
 #if defined(HAVE_TLS_EXTENSIONS) && defined(HAVE_DH_DEFAULT_PARAMS)
     #if defined(HAVE_FFDHE) && defined(HAVE_SUPPORTED_CURVES)
         if (TLSX_Find(ssl->extensions, TLSX_SUPPORTED_GROUPS) != NULL) {
             /* Set FFDHE parameters or clear DHE parameters if FFDH parameters
              * present and no matches in the server's list. */
             ret = TLSX_SupportedFFDHE_Set(ssl);
             if (ret != 0)
                 goto out;
         }
     #endif
 #endif
 
         ret = MatchSuite(ssl, &clSuites);
 #ifdef WOLFSSL_EXTRA_ALERTS
         if (ret == BUFFER_ERROR)
             SendAlert(ssl, alert_fatal, decode_error);
         else if (ret < 0)
             SendAlert(ssl, alert_fatal, handshake_failure);
 #endif
 
 #ifdef HAVE_SECURE_RENEGOTIATION
         if (ssl->secure_renegotiation && ssl->secure_renegotiation->enabled &&
                 IsEncryptionOn(ssl, 0)) {
             ssl->secure_renegotiation->startScr = 1;
         }
 #endif
 #ifdef WOLFSSL_DTLS
         if (ret == 0 && ssl->options.dtls)
             DtlsMsgPoolReset(ssl);
 #endif
         WOLFSSL_LEAVE("DoClientHello", ret);
         WOLFSSL_END(WC_FUNC_CLIENT_HELLO_DO);
 
     out:
 
 #ifdef WOLFSSL_DTLS
         wc_HmacFree(&cookieHmac);
 #endif
 
         return ret;
     }
 
 
 #if (!defined(NO_RSA) || defined(HAVE_ECC) || defined(HAVE_ED25519) || \
                         defined(HAVE_ED448)) && !defined(WOLFSSL_NO_CLIENT_AUTH)
 
     typedef struct DcvArgs {
         byte*  output; /* not allocated */
         word32 sendSz;
         word16 sz;
         word32 sigSz;
         word32 idx;
         word32 begin;
         byte   hashAlgo;
         byte   sigAlgo;
     } DcvArgs;
 
     static void FreeDcvArgs(WOLFSSL* ssl, void* pArgs)
     {
         DcvArgs* args = (DcvArgs*)pArgs;
 
         (void)ssl;
         (void)args;
     }
 
     /* handle processing of certificate_verify (15) */
     static int DoCertificateVerify(WOLFSSL* ssl, byte* input,
                                 word32* inOutIdx, word32 size)
     {
         int ret = 0;
     #ifdef WOLFSSL_ASYNC_CRYPT
         DcvArgs* args = (DcvArgs*)ssl->async.args;
         typedef char args_test[sizeof(ssl->async.args) >= sizeof(*args) ? 1 : -1];
         (void)sizeof(args_test);
     #else
         DcvArgs  args[1];
     #endif
 
         WOLFSSL_START(WC_FUNC_CERTIFICATE_VERIFY_DO);
         WOLFSSL_ENTER("DoCertificateVerify");
 
     #ifdef WOLFSSL_ASYNC_CRYPT
         ret = wolfSSL_AsyncPop(ssl, &ssl->options.asyncState);
         if (ret != WC_NOT_PENDING_E) {
             /* Check for error */
             if (ret < 0)
                 goto exit_dcv;
         }
         else
     #endif
         {
             /* Reset state */
             ret = 0;
             ssl->options.asyncState = TLS_ASYNC_BEGIN;
             XMEMSET(args, 0, sizeof(DcvArgs));
             args->hashAlgo = sha_mac;
             args->sigAlgo = anonymous_sa_algo;
             args->idx = *inOutIdx;
             args->begin = *inOutIdx;
         #ifdef WOLFSSL_ASYNC_CRYPT
             ssl->async.freeArgs = FreeDcvArgs;
         #endif
         }
 
         switch(ssl->options.asyncState)
         {
             case TLS_ASYNC_BEGIN:
             {
             #ifdef WOLFSSL_CALLBACKS
                 if (ssl->hsInfoOn)
                     AddPacketName(ssl, "CertificateVerify");
                 if (ssl->toInfoOn)
                     AddLateName("CertificateVerify", &ssl->timeoutInfo);
             #endif
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_BUILD;
             } /* case TLS_ASYNC_BEGIN */
             FALL_THROUGH;
 
             case TLS_ASYNC_BUILD:
             {
                 if (IsAtLeastTLSv1_2(ssl)) {
                     if ((args->idx - args->begin) + ENUM_LEN + ENUM_LEN > size) {
                         ERROR_OUT(BUFFER_ERROR, exit_dcv);
                     }
 
                     DecodeSigAlg(&input[args->idx], &args->hashAlgo,
                                  &args->sigAlgo);
                     args->idx += 2;
                 }
             #ifndef NO_RSA
                 else if (ssl->peerRsaKey != NULL && ssl->peerRsaKeyPresent != 0)
                     args->sigAlgo = rsa_sa_algo;
             #endif
             #ifdef HAVE_ECC
                 else if (ssl->peerEccDsaKeyPresent)
                     args->sigAlgo = ecc_dsa_sa_algo;
             #endif
             #if defined(HAVE_ED25519) && !defined(NO_ED25519_CLIENT_AUTH)
                 else if (ssl->peerEd25519KeyPresent)
                     args->sigAlgo = ed25519_sa_algo;
             #endif /* HAVE_ED25519 && !NO_ED25519_CLIENT_AUTH */
             #if defined(HAVE_ED448) && !defined(NO_ED448_CLIENT_AUTH)
                 else if (ssl->peerEd448KeyPresent)
                     args->sigAlgo = ed448_sa_algo;
             #endif /* HAVE_ED448 && !NO_ED448_CLIENT_AUTH */
 
                 if ((args->idx - args->begin) + OPAQUE16_LEN > size) {
                     ERROR_OUT(BUFFER_ERROR, exit_dcv);
                 }
 
                 ato16(input + args->idx, &args->sz);
                 args->idx += OPAQUE16_LEN;
 
                 if ((args->idx - args->begin) + args->sz > size ||
                                                     args->sz > ENCRYPT_LEN) {
                     ERROR_OUT(BUFFER_ERROR, exit_dcv);
                 }
 
             #ifdef HAVE_ECC
                 if (ssl->peerEccDsaKeyPresent) {
 
                     WOLFSSL_MSG("Doing ECC peer cert verify");
 
                 /* make sure a default is defined */
                 #if !defined(NO_SHA)
                     SetDigest(ssl, sha_mac);
                 #elif !defined(NO_SHA256)
                     SetDigest(ssl, sha256_mac);
                 #elif defined(WOLFSSL_SHA384)
                     SetDigest(ssl, sha384_mac);
                 #elif defined(WOLFSSL_SHA512)
                     SetDigest(ssl, sha512_mac);
                 #else
                     #error No digest enabled for ECC sig verify
                 #endif
 
                     if (IsAtLeastTLSv1_2(ssl)) {
                         if (args->sigAlgo != ecc_dsa_sa_algo) {
                             WOLFSSL_MSG("Oops, peer sent ECC key but not in verify");
                         }
 
                         SetDigest(ssl, args->hashAlgo);
                     }
                 }
             #endif /* HAVE_ECC */
             #if defined(HAVE_ED25519) && !defined(NO_ED25519_CLIENT_AUTH)
                 if (ssl->peerEd25519KeyPresent) {
                     WOLFSSL_MSG("Doing ED25519 peer cert verify");
                     if (IsAtLeastTLSv1_2(ssl) &&
                                              args->sigAlgo != ed25519_sa_algo) {
                         WOLFSSL_MSG(
                                "Oops, peer sent ED25519 key but not in verify");
                     }
                 }
             #endif /* HAVE_ED25519 && !NO_ED25519_CLIENT_AUTH */
             #if defined(HAVE_ED448) && !defined(NO_ED448_CLIENT_AUTH)
                 if (ssl->peerEd448KeyPresent) {
                     WOLFSSL_MSG("Doing ED448 peer cert verify");
                     if (IsAtLeastTLSv1_2(ssl) &&
                                                args->sigAlgo != ed448_sa_algo) {
                         WOLFSSL_MSG(
                                  "Oops, peer sent ED448 key but not in verify");
                     }
                 }
             #endif /* HAVE_ED448 && !NO_ED448_CLIENT_AUTH */
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_DO;
             } /* case TLS_ASYNC_BUILD */
             FALL_THROUGH;
 
             case TLS_ASYNC_DO:
             {
             #ifndef NO_RSA
                 if (ssl->peerRsaKey != NULL && ssl->peerRsaKeyPresent != 0) {
                     WOLFSSL_MSG("Doing RSA peer cert verify");
 
                     ret = RsaVerify(ssl,
                         input + args->idx,
                         args->sz,
                         &args->output,
                         args->sigAlgo, args->hashAlgo,
                         ssl->peerRsaKey,
                     #ifdef HAVE_PK_CALLBACKS
                         &ssl->buffers.peerRsaKey
                     #else
                         NULL
                     #endif
                     );
                     if (ret >= 0) {
                         if (args->sigAlgo == rsa_sa_algo)
                             args->sendSz = ret;
                         else {
                             args->sigSz = ret;
                             args->sendSz = ssl->buffers.digest.length;
                         }
                         ret = 0;
                     }
                 }
             #endif /* !NO_RSA */
             #ifdef HAVE_ECC
                 if (ssl->peerEccDsaKeyPresent) {
                     WOLFSSL_MSG("Doing ECC peer cert verify");
 
                     ret = EccVerify(ssl,
                         input + args->idx, args->sz,
                         ssl->buffers.digest.buffer, ssl->buffers.digest.length,
                         ssl->peerEccDsaKey,
                     #ifdef HAVE_PK_CALLBACKS
                         &ssl->buffers.peerEccDsaKey
                     #else
                         NULL
                     #endif
                     );
                 }
             #endif /* HAVE_ECC */
             #if defined(HAVE_ED25519) && !defined(NO_ED25519_CLIENT_AUTH)
                 if (ssl->peerEd25519KeyPresent) {
                     WOLFSSL_MSG("Doing Ed25519 peer cert verify");
 
                     ret = Ed25519Verify(ssl,
                         input + args->idx, args->sz,
                         ssl->hsHashes->messages, ssl->hsHashes->prevLen,
                         ssl->peerEd25519Key,
                     #ifdef HAVE_PK_CALLBACKS
                         &ssl->buffers.peerEd25519Key
                     #else
                         NULL
                     #endif
                     );
                 }
             #endif /* HAVE_ED25519 && !NO_ED25519_CLIENT_AUTH */
             #if defined(HAVE_ED448) && !defined(NO_ED448_CLIENT_AUTH)
                 if (ssl->peerEd448KeyPresent) {
                     WOLFSSL_MSG("Doing Ed448 peer cert verify");
 
                     ret = Ed448Verify(ssl,
                         input + args->idx, args->sz,
                         ssl->hsHashes->messages, ssl->hsHashes->prevLen,
                         ssl->peerEd448Key,
                     #ifdef HAVE_PK_CALLBACKS
                         &ssl->buffers.peerEd448Key
                     #else
                         NULL
                     #endif
                     );
                 }
             #endif /* HAVE_ED448 && !NO_ED448_CLIENT_AUTH */
 
             #ifdef WOLFSSL_ASYNC_CRYPT
                 /* handle async pending */
                 if (ret == WC_PENDING_E)
                     goto exit_dcv;
             #endif
 
                 /* Check for error */
                 if (ret != 0) {
                     ret = SIG_VERIFY_E;
                     goto exit_dcv;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_VERIFY;
             } /* case TLS_ASYNC_DO */
             FALL_THROUGH;
 
             case TLS_ASYNC_VERIFY:
             {
             #ifndef NO_RSA
                 if (ssl->peerRsaKey != NULL && ssl->peerRsaKeyPresent != 0) {
                     if (IsAtLeastTLSv1_2(ssl)) {
                     #ifdef WC_RSA_PSS
                         if (args->sigAlgo == rsa_pss_sa_algo) {
                             SetDigest(ssl, args->hashAlgo);
 
                         #ifdef HAVE_SELFTEST
                             ret = wc_RsaPSS_CheckPadding(
                                             ssl->buffers.digest.buffer,
                                             ssl->buffers.digest.length,
                                             args->output, args->sigSz,
                                             HashAlgoToType(args->hashAlgo));
                         #else
                             ret = wc_RsaPSS_CheckPadding_ex(
                                             ssl->buffers.digest.buffer,
                                             ssl->buffers.digest.length,
                                             args->output, args->sigSz,
                                             HashAlgoToType(args->hashAlgo), -1,
                                             mp_count_bits(&ssl->peerRsaKey->n));
                         #endif
                             if (ret != 0) {
                                 ret = SIG_VERIFY_E;
                                 goto exit_dcv;
                             }
                         }
                         else
                     #endif
                         {
                         #ifdef WOLFSSL_SMALL_STACK
                             byte* encodedSig;
                         #else
                             byte  encodedSig[MAX_ENCODED_SIG_SZ];
                         #endif
 
                         #ifdef WOLFSSL_SMALL_STACK
                             encodedSig = (byte*)XMALLOC(MAX_ENCODED_SIG_SZ,
                                              ssl->heap, DYNAMIC_TYPE_SIGNATURE);
                             if (encodedSig == NULL) {
                                 ERROR_OUT(MEMORY_E, exit_dcv);
                             }
                         #endif
 
                             if (args->sigAlgo != rsa_sa_algo) {
                                 WOLFSSL_MSG("Oops, peer sent RSA key but not "
                                             "in verify");
                             }
 
                             SetDigest(ssl, args->hashAlgo);
 
                             args->sigSz = wc_EncodeSignature(encodedSig,
                                 ssl->buffers.digest.buffer,
                                 ssl->buffers.digest.length,
                                 TypeHash(args->hashAlgo));
 
                             if (args->sendSz != args->sigSz || !args->output ||
                                 XMEMCMP(args->output, encodedSig,
                                     min(args->sigSz, MAX_ENCODED_SIG_SZ)) != 0) {
                                 ret = VERIFY_CERT_ERROR;
                             }
 
                         #ifdef WOLFSSL_SMALL_STACK
                             XFREE(encodedSig, ssl->heap, DYNAMIC_TYPE_SIGNATURE);
                         #endif
                         }
                     }
                     else {
                         if (args->sendSz != FINISHED_SZ || !args->output ||
                             XMEMCMP(args->output,
                                 &ssl->hsHashes->certHashes, FINISHED_SZ) != 0) {
                             ret = VERIFY_CERT_ERROR;
                         }
                     }
                 }
             #endif /* !NO_RSA */
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_FINALIZE;
             } /* case TLS_ASYNC_VERIFY */
             FALL_THROUGH;
 
             case TLS_ASYNC_FINALIZE:
             {
                 if (IsEncryptionOn(ssl, 0)) {
                     args->idx += ssl->keys.padSz;
             #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
                     if (ssl->options.startedETMRead)
                         args->idx += MacSize(ssl);
             #endif
                 }
 
                 ssl->options.havePeerVerify = 1;
 
                 /* Set final index */
                 args->idx += args->sz;
                 *inOutIdx = args->idx;
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_END;
             } /* case TLS_ASYNC_FINALIZE */
 
             case TLS_ASYNC_END:
             {
                 break;
             }
             default:
                 ret = INPUT_CASE_ERROR;
         } /* switch(ssl->options.asyncState) */
 
     exit_dcv:
 
         WOLFSSL_LEAVE("DoCertificateVerify", ret);
         WOLFSSL_END(WC_FUNC_CERTIFICATE_VERIFY_DO);
 
     #ifdef WOLFSSL_ASYNC_CRYPT
         /* Handle async operation */
         if (ret == WC_PENDING_E) {
             /* Mark message as not received so it can process again */
             ssl->msgsReceived.got_certificate_verify = 0;
 
             return ret;
         }
     #endif /* WOLFSSL_ASYNC_CRYPT */
     #ifdef WOLFSSL_EXTRA_ALERTS
         if (ret == BUFFER_ERROR)
             SendAlert(ssl, alert_fatal, decode_error);
         else if (ret == SIG_VERIFY_E)
             SendAlert(ssl, alert_fatal, decrypt_error);
         else if (ret != 0)
             SendAlert(ssl, alert_fatal, bad_certificate);
     #endif
         /* Digest is not allocated, so do this to prevent free */
         ssl->buffers.digest.buffer = NULL;
         ssl->buffers.digest.length = 0;
 
         /* Final cleanup */
         FreeDcvArgs(ssl, args);
         FreeKeyExchange(ssl);
 
         return ret;
     }
 
 #endif /* (!NO_RSA || ECC || ED25519 || ED448) && !WOLFSSL_NO_CLIENT_AUTH */
 
     /* handle generation of server_hello_done (14) */
     int SendServerHelloDone(WOLFSSL* ssl)
     {
         byte* output;
         int   sendSz = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
         int   ret;
 
         WOLFSSL_START(WC_FUNC_SERVER_HELLO_DONE_SEND);
         WOLFSSL_ENTER("SendServerHelloDone");
 
     #ifdef WOLFSSL_DTLS
         if (ssl->options.dtls)
             sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
     #endif
 
         if (IsEncryptionOn(ssl, 1))
             sendSz += MAX_MSG_EXTRA;
 
         /* check for available size */
         if ((ret = CheckAvailableSize(ssl, sendSz)) != 0)
             return ret;
 
         /* get output buffer */
         output = ssl->buffers.outputBuffer.buffer +
                  ssl->buffers.outputBuffer.length;
 
         AddHeaders(output, 0, server_hello_done, ssl);
 
         if (IsEncryptionOn(ssl, 1)) {
             byte* input;
             int   inputSz = HANDSHAKE_HEADER_SZ; /* build msg adds rec hdr */
             int   recordHeaderSz = RECORD_HEADER_SZ;
 
             if (ssl->options.dtls) {
                 recordHeaderSz += DTLS_RECORD_EXTRA;
                 inputSz += DTLS_HANDSHAKE_EXTRA;
             }
 
             input = (byte*)XMALLOC(inputSz, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
             if (input == NULL)
                 return MEMORY_E;
 
             XMEMCPY(input, output + recordHeaderSz, inputSz);
             #ifdef WOLFSSL_DTLS
             if (IsDtlsNotSctpMode(ssl) &&
                     (ret = DtlsMsgPoolSave(ssl, input, inputSz, server_hello_done)) != 0) {
                 XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
                 return ret;
             }
             #endif
             sendSz = BuildMessage(ssl, output, sendSz, input, inputSz,
                                   handshake, 1, 0, 0, CUR_ORDER);
             XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
 
             if (sendSz < 0)
                 return sendSz;
         } else {
             #ifdef WOLFSSL_DTLS
                 if (IsDtlsNotSctpMode(ssl)) {
                     if ((ret = DtlsMsgPoolSave(ssl, output, sendSz, server_hello_done)) != 0)
                         return ret;
                 }
                 if (ssl->options.dtls)
                     DtlsSEQIncrement(ssl, CUR_ORDER);
             #endif
             ret = HashOutput(ssl, output, sendSz, 0);
             if (ret != 0)
                 return ret;
         }
 
     #if defined(WOLFSSL_CALLBACKS) || defined(OPENSSL_EXTRA)
         if (ssl->hsInfoOn)
             AddPacketName(ssl, "ServerHelloDone");
         if (ssl->toInfoOn)
             AddPacketInfo(ssl, "ServerHelloDone", handshake, output, sendSz,
                     WRITE_PROTO, ssl->heap);
     #endif
         ssl->options.serverState = SERVER_HELLODONE_COMPLETE;
 
         ssl->buffers.outputBuffer.length += sendSz;
 
         ret = SendBuffered(ssl);
 
         WOLFSSL_LEAVE("SendServerHelloDone", ret);
         WOLFSSL_END(WC_FUNC_SERVER_HELLO_DONE_SEND);
 
         return ret;
     }
 
 #endif /* !WOLFSSL_NO_TLS12 */
 
 #ifdef HAVE_SESSION_TICKET
 
 #define WOLFSSL_TICKET_FIXED_SZ (WOLFSSL_TICKET_NAME_SZ + \
                 WOLFSSL_TICKET_IV_SZ + WOLFSSL_TICKET_MAC_SZ + LENGTH_SZ)
 #define WOLFSSL_TICKET_ENC_SZ (SESSION_TICKET_LEN - WOLFSSL_TICKET_FIXED_SZ)
 
     /* our ticket format */
     typedef struct InternalTicket {
         ProtocolVersion pv;                    /* version when ticket created */
         byte            suite[SUITE_LEN];      /* cipher suite when created */
         byte            msecret[SECRET_LEN];   /* master secret */
         word32          timestamp;             /* born on */
         word16          haveEMS;               /* have extended master secret */
 #ifdef WOLFSSL_TLS13
         word32          ageAdd;                /* Obfuscation of age */
         word16          namedGroup;            /* Named group used */
         TicketNonce     ticketNonce;           /* Ticket nonce */
     #ifdef WOLFSSL_EARLY_DATA
         word32          maxEarlyDataSz;        /* Max size of early data */
     #endif
 #endif
     } InternalTicket;
 
     /* RFC 5077 defines this for session tickets */
     /* fit within SESSION_TICKET_LEN */
     typedef struct ExternalTicket {
         byte key_name[WOLFSSL_TICKET_NAME_SZ];  /* key context name */
         byte iv[WOLFSSL_TICKET_IV_SZ];          /* this ticket's iv */
         byte enc_len[LENGTH_SZ];                /* encrypted length */
         byte enc_ticket[WOLFSSL_TICKET_ENC_SZ]; /* encrypted internal ticket */
         byte mac[WOLFSSL_TICKET_MAC_SZ];        /* total mac */
         /* !! if add to structure, add to TICKET_FIXED_SZ !! */
     } ExternalTicket;
 
     /* create a new session ticket, 0 on success */
     int CreateTicket(WOLFSSL* ssl)
     {
         InternalTicket  it;
         ExternalTicket* et = (ExternalTicket*)ssl->session.ticket;
         int encLen;
         int ret;
         byte zeros[WOLFSSL_TICKET_MAC_SZ];   /* biggest cmp size */
 
         XMEMSET(&it, 0, sizeof(it));
 
         /* build internal */
         it.pv.major = ssl->version.major;
         it.pv.minor = ssl->version.minor;
 
         it.suite[0] = ssl->options.cipherSuite0;
         it.suite[1] = ssl->options.cipherSuite;
 
     #ifdef WOLFSSL_EARLY_DATA
         it.maxEarlyDataSz = ssl->options.maxEarlyDataSz;
     #endif
 
         if (!ssl->options.tls1_3) {
             XMEMCPY(it.msecret, ssl->arrays->masterSecret, SECRET_LEN);
             c32toa(LowResTimer(), (byte*)&it.timestamp);
             it.haveEMS = ssl->options.haveEMS;
         }
         else {
 #ifdef WOLFSSL_TLS13
             /* Client adds to ticket age to obfuscate. */
             ret = wc_RNG_GenerateBlock(ssl->rng, (byte*)&it.ageAdd,
                                                              sizeof(it.ageAdd));
             if (ret != 0)
                 return BAD_TICKET_ENCRYPT;
             ssl->session.ticketAdd = it.ageAdd;
             it.namedGroup = ssl->session.namedGroup;
             it.timestamp = TimeNowInMilliseconds();
             /* Resumption master secret. */
             XMEMCPY(it.msecret, ssl->session.masterSecret, SECRET_LEN);
             XMEMCPY(&it.ticketNonce, &ssl->session.ticketNonce,
                                                            sizeof(TicketNonce));
 #endif
         }
 
         /* encrypt */
         encLen = WOLFSSL_TICKET_ENC_SZ;  /* max size user can use */
         if (ssl->ctx->ticketEncCb == NULL) {
             ret = WOLFSSL_TICKET_RET_FATAL;
         }
         else {
             /* build external */
             XMEMCPY(et->enc_ticket, &it, sizeof(InternalTicket));
 
             ret = ssl->ctx->ticketEncCb(ssl, et->key_name, et->iv, et->mac, 1,
                                     et->enc_ticket, sizeof(InternalTicket),
                                     &encLen, ssl->ctx->ticketEncCtx);
             if (ret != WOLFSSL_TICKET_RET_OK) {
                 ForceZero(et->enc_ticket, sizeof(it));
             }
         }
         if (ret == WOLFSSL_TICKET_RET_OK) {
             if (encLen < (int)sizeof(InternalTicket) ||
                 encLen > WOLFSSL_TICKET_ENC_SZ) {
                 ForceZero(&it, sizeof(it));
                 ForceZero(et->enc_ticket, sizeof(it));
                 WOLFSSL_MSG("Bad user ticket encrypt size");
                 return BAD_TICKET_KEY_CB_SZ;
             }
 
             /* sanity checks on encrypt callback */
 
             /* internal ticket can't be the same if encrypted */
             if (XMEMCMP(et->enc_ticket, &it, sizeof(InternalTicket)) == 0) {
                 ForceZero(&it, sizeof(it));
                 ForceZero(et->enc_ticket, sizeof(it));
                 WOLFSSL_MSG("User ticket encrypt didn't encrypt");
                 return BAD_TICKET_ENCRYPT;
             }
 
             ForceZero(&it, sizeof(it));
             XMEMSET(zeros, 0, sizeof(zeros));
 
             /* name */
             if (XMEMCMP(et->key_name, zeros, WOLFSSL_TICKET_NAME_SZ) == 0) {
                 WOLFSSL_MSG("User ticket encrypt didn't set name");
                 return BAD_TICKET_ENCRYPT;
             }
 
             /* iv */
             if (XMEMCMP(et->iv, zeros, WOLFSSL_TICKET_IV_SZ) == 0) {
                 WOLFSSL_MSG("User ticket encrypt didn't set iv");
                 return BAD_TICKET_ENCRYPT;
             }
 
             /* mac */
             if (XMEMCMP(et->mac, zeros, WOLFSSL_TICKET_MAC_SZ) == 0) {
                 WOLFSSL_MSG("User ticket encrypt didn't set mac");
                 return BAD_TICKET_ENCRYPT;
             }
 
             /* set size */
             c16toa((word16)encLen, et->enc_len);
             ssl->session.ticketLen = (word16)(encLen + WOLFSSL_TICKET_FIXED_SZ);
             if (encLen < WOLFSSL_TICKET_ENC_SZ) {
                 /* move mac up since whole enc buffer not used */
                 XMEMMOVE(et->enc_ticket +encLen, et->mac,WOLFSSL_TICKET_MAC_SZ);
             }
         }
 
         return ret;
     }
 
 
     /* Parse ticket sent by client, returns callback return value */
     int DoClientTicket(WOLFSSL* ssl, const byte* input, word32 len)
     {
         ExternalTicket* et;
         InternalTicket  it;
         int             ret;
         int             outLen;
         word16          inLen;
 
         WOLFSSL_START(WC_FUNC_TICKET_DO);
         WOLFSSL_ENTER("DoClientTicket");
 
         if (len > SESSION_TICKET_LEN ||
              len < (word32)(sizeof(InternalTicket) + WOLFSSL_TICKET_FIXED_SZ)) {
             return BAD_TICKET_MSG_SZ;
         }
 
         et = (ExternalTicket*)input;
 
         /* decrypt */
         ato16(et->enc_len, &inLen);
         if (inLen > (word16)(len - WOLFSSL_TICKET_FIXED_SZ)) {
             return BAD_TICKET_MSG_SZ;
         }
         outLen = inLen;   /* may be reduced by user padding */
 
         if (ssl->ctx->ticketEncCb == NULL) {
             ret = WOLFSSL_TICKET_RET_FATAL;
         }
         else {
             ret = ssl->ctx->ticketEncCb(ssl, et->key_name, et->iv,
                                     et->enc_ticket + inLen, 0,
                                     et->enc_ticket, inLen, &outLen,
                                     ssl->ctx->ticketEncCtx);
         }
         if (ret == WOLFSSL_TICKET_RET_FATAL || ret < 0) return ret;
         if (outLen > (int)inLen || outLen < (int)sizeof(InternalTicket)) {
             WOLFSSL_MSG("Bad user ticket decrypt len");
             return BAD_TICKET_KEY_CB_SZ;
         }
 
         /* copy the decrypted ticket to avoid alignment issues */
         XMEMCPY(&it, et->enc_ticket, sizeof(InternalTicket));
         ForceZero(et->enc_ticket, sizeof(it));
 
         /* get master secret */
         if (ret == WOLFSSL_TICKET_RET_OK || ret == WOLFSSL_TICKET_RET_CREATE) {
             if (ssl->version.minor < it.pv.minor) {
                 ForceZero(&it, sizeof(it));
                 WOLFSSL_MSG("Ticket has greater version");
                 return VERSION_ERROR;
             }
             else if (ssl->version.minor > it.pv.minor) {
                 if (IsAtLeastTLSv1_3(it.pv) != IsAtLeastTLSv1_3(ssl->version)) {
                     ForceZero(&it, sizeof(it));
                     WOLFSSL_MSG("Tickets cannot be shared between "
                                                "TLS 1.3 and TLS 1.2 and lower");
                     return VERSION_ERROR;
                 }
 
                 if (!ssl->options.downgrade) {
                     ForceZero(&it, sizeof(it));
                     WOLFSSL_MSG("Ticket has lesser version");
                     return VERSION_ERROR;
                 }
 
                 WOLFSSL_MSG("Downgrading protocol due to ticket");
 
                 if (it.pv.minor < ssl->options.minDowngrade) {
                     ForceZero(&it, sizeof(it));
                     return VERSION_ERROR;
                 }
                 ssl->version.minor = it.pv.minor;
             }
 
 
             if (!IsAtLeastTLSv1_3(ssl->version)) {
                 XMEMCPY(ssl->arrays->masterSecret, it.msecret, SECRET_LEN);
                 /* Copy the haveExtendedMasterSecret property from the ticket to
                  * the saved session, so the property may be checked later. */
                 ssl->session.haveEMS = it.haveEMS;
             #ifndef NO_RESUME_SUITE_CHECK
                 ssl->session.cipherSuite0 = it.suite[0];
                 ssl->session.cipherSuite = it.suite[1];
             #endif
             }
             else {
 #ifdef WOLFSSL_TLS13
                 /* Restore information to renegotiate. */
                 ssl->session.ticketSeen = it.timestamp;
                 ssl->session.ticketAdd = it.ageAdd;
                 ssl->session.cipherSuite0 = it.suite[0];
                 ssl->session.cipherSuite = it.suite[1];
     #ifdef WOLFSSL_EARLY_DATA
                 ssl->session.maxEarlyDataSz = it.maxEarlyDataSz;
     #endif
                 /* Resumption master secret. */
                 XMEMCPY(ssl->session.masterSecret, it.msecret, SECRET_LEN);
                 XMEMCPY(&ssl->session.ticketNonce, &it.ticketNonce,
                                                            sizeof(TicketNonce));
                 ssl->session.namedGroup = it.namedGroup;
 #endif
             }
         }
 
         ForceZero(&it, sizeof(it));
 
         WOLFSSL_LEAVE("DoClientTicket", ret);
         WOLFSSL_END(WC_FUNC_TICKET_DO);
 
         return ret;
     }
 
 
     /* send Session Ticket */
     int SendTicket(WOLFSSL* ssl)
     {
         byte*              output;
         int                ret;
         int                sendSz;
         word32             length = SESSION_HINT_SZ + LENGTH_SZ;
         word32             idx    = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
 
         WOLFSSL_START(WC_FUNC_TICKET_SEND);
         WOLFSSL_ENTER("SendTicket");
 
         if (ssl->options.createTicket) {
             ret = CreateTicket(ssl);
             if (ret != 0) return ret;
         }
 
         length += ssl->session.ticketLen;
         sendSz = length + HANDSHAKE_HEADER_SZ + RECORD_HEADER_SZ;
 
         if (!ssl->options.dtls) {
             if (IsEncryptionOn(ssl, 1) && ssl->options.handShakeDone)
                 sendSz += MAX_MSG_EXTRA;
         }
         else {
         #ifdef WOLFSSL_DTLS
             sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
             idx    += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
         #endif
         }
 
         if (IsEncryptionOn(ssl, 1) && ssl->options.handShakeDone)
             sendSz += cipherExtraData(ssl);
 
         /* check for available size */
         if ((ret = CheckAvailableSize(ssl, sendSz)) != 0)
             return ret;
 
         /* get output buffer */
         output = ssl->buffers.outputBuffer.buffer +
                  ssl->buffers.outputBuffer.length;
 
         AddHeaders(output, length, session_ticket, ssl);
 
         /* hint */
         c32toa(ssl->ctx->ticketHint, output + idx);
         idx += SESSION_HINT_SZ;
 
         /* length */
         c16toa(ssl->session.ticketLen, output + idx);
         idx += LENGTH_SZ;
 
         /* ticket */
         XMEMCPY(output + idx, ssl->session.ticket, ssl->session.ticketLen);
         idx += ssl->session.ticketLen;
 
         if (IsEncryptionOn(ssl, 1) && ssl->options.handShakeDone) {
             byte* input;
             int   inputSz = idx; /* build msg adds rec hdr */
             int   recordHeaderSz = RECORD_HEADER_SZ;
 
             if (ssl->options.dtls)
                 recordHeaderSz += DTLS_RECORD_EXTRA;
             inputSz -= recordHeaderSz;
             input = (byte*)XMALLOC(inputSz, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
             if (input == NULL)
                 return MEMORY_E;
 
             XMEMCPY(input, output + recordHeaderSz, inputSz);
             sendSz = BuildMessage(ssl, output, sendSz, input, inputSz,
                                   handshake, 1, 0, 0, CUR_ORDER);
             XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
 
             if (sendSz < 0)
                 return sendSz;
         }
         else {
             #ifdef WOLFSSL_DTLS
             if (ssl->options.dtls) {
                 if ((ret = DtlsMsgPoolSave(ssl, output, sendSz, session_ticket)) != 0)
                     return ret;
 
                 DtlsSEQIncrement(ssl, CUR_ORDER);
             }
             #endif
             ret = HashOutput(ssl, output, sendSz, 0);
             if (ret != 0)
                 return ret;
         }
 
         ssl->buffers.outputBuffer.length += sendSz;
 
         if (!ssl->options.groupMessages)
             ret = SendBuffered(ssl);
 
         WOLFSSL_LEAVE("SendTicket", ret);
         WOLFSSL_END(WC_FUNC_TICKET_SEND);
 
         return ret;
     }
 
 #endif /* HAVE_SESSION_TICKET */
 
 #ifndef WOLFSSL_NO_TLS12
 
 #if defined(HAVE_SECURE_RENEGOTIATION) && \
     defined(HAVE_SERVER_RENEGOTIATION_INFO) && \
     !defined(WOLFSSL_NO_SERVER)
 
     /* handle generation of server's hello_request (0) */
     int SendHelloRequest(WOLFSSL* ssl)
     {
         byte* output;
         int sendSz = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
         int ret;
 
         WOLFSSL_START(WC_FUNC_HELLO_REQUEST_SEND);
         WOLFSSL_ENTER("SendHelloRequest");
 
         if (IsEncryptionOn(ssl, 1))
             sendSz += MAX_MSG_EXTRA;
 
         if (ssl->options.dtls)
             sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
 
         /* check for available size */
         if ((ret = CheckAvailableSize(ssl, sendSz)) != 0)
             return ret;
 
         /* get output buffer */
         output = ssl->buffers.outputBuffer.buffer +
                  ssl->buffers.outputBuffer.length;
 
         AddHeaders(output, 0, hello_request, ssl);
 
         if (IsEncryptionOn(ssl, 1)) {
             byte* input;
             int   inputSz = HANDSHAKE_HEADER_SZ; /* build msg adds rec hdr */
             int   recordHeaderSz = RECORD_HEADER_SZ;
 
             if (ssl->options.dtls) {
                 recordHeaderSz += DTLS_RECORD_EXTRA;
                 inputSz += DTLS_HANDSHAKE_EXTRA;
             }
 
             input = (byte*)XMALLOC(inputSz, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
             if (input == NULL)
                 return MEMORY_E;
 
             XMEMCPY(input, output + recordHeaderSz, inputSz);
             sendSz = BuildMessage(ssl, output, sendSz, input, inputSz,
                                   handshake, 0, 0, 0, CUR_ORDER);
             XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
 
             if (sendSz < 0)
                 return sendSz;
         }
 
         ssl->buffers.outputBuffer.length += sendSz;
 
         ret = SendBuffered(ssl);
 
         WOLFSSL_LEAVE("SendHelloRequest", ret);
         WOLFSSL_END(WC_FUNC_HELLO_REQUEST_SEND);
 
         return ret;
     }
 
 #endif /* HAVE_SECURE_RENEGOTIATION && HAVE_SERVER_RENEGOTIATION_INFO */
 
 #ifdef WOLFSSL_DTLS
     /* handle generation of DTLS hello_verify_request (3) */
     static int SendHelloVerifyRequest(WOLFSSL* ssl,
                                       const byte* cookie, byte cookieSz)
     {
         byte* output;
         int   length = VERSION_SZ + ENUM_LEN + cookieSz;
         int   idx    = DTLS_RECORD_HEADER_SZ + DTLS_HANDSHAKE_HEADER_SZ;
         int   sendSz = length + idx;
         int   ret;
 
         /* are we in scr */
         if (IsEncryptionOn(ssl, 1)) {
             sendSz += MAX_MSG_EXTRA;
         }
 
         /* check for available size */
         if ((ret = CheckAvailableSize(ssl, sendSz)) != 0)
             return ret;
 
         /* get output buffer */
         output = ssl->buffers.outputBuffer.buffer +
                  ssl->buffers.outputBuffer.length;
 
         /* Hello Verify Request should use the same sequence number as the
          * Client Hello. */
         ssl->keys.dtls_sequence_number_hi = ssl->keys.curSeq_hi;
         ssl->keys.dtls_sequence_number_lo = ssl->keys.curSeq_lo;
         AddHeaders(output, length, hello_verify_request, ssl);
 
 #ifdef OPENSSL_EXTRA
         output[idx++] = DTLS_MAJOR;
         output[idx++] = DTLS_MINOR;
 #else
         output[idx++] = ssl->version.major;
         output[idx++] = ssl->version.minor;
 #endif
 
         output[idx++] = cookieSz;
         if (cookie == NULL || cookieSz == 0)
             return COOKIE_ERROR;
 
         XMEMCPY(output + idx, cookie, cookieSz);
 
 #if defined(WOLFSSL_CALLBACKS) || defined(OPENSSL_EXTRA)
         if (ssl->hsInfoOn)
             AddPacketName(ssl, "HelloVerifyRequest");
         if (ssl->toInfoOn)
             AddPacketInfo(ssl, "HelloVerifyRequest", handshake, output,
                           sendSz, WRITE_PROTO, ssl->heap);
 #endif
 
         /* are we in scr */
         if (IsEncryptionOn(ssl, 1)) {
             byte* input;
             int   inputSz = HANDSHAKE_HEADER_SZ + length; /* build msg adds rec hdr */
             int   recordHeaderSz = RECORD_HEADER_SZ;
 
             if (ssl->options.dtls) {
                 recordHeaderSz += DTLS_RECORD_EXTRA;
                 inputSz += DTLS_HANDSHAKE_EXTRA;
             }
 
             input = (byte*)XMALLOC(inputSz, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
             if (input == NULL)
                 return MEMORY_E;
 
             XMEMCPY(input, output + recordHeaderSz, inputSz);
             sendSz = BuildMessage(ssl, output, sendSz, input, inputSz,
                                   handshake, 0, 0, 0, CUR_ORDER);
             XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
 
             if (sendSz < 0)
                 return sendSz;
         }
 
         ssl->buffers.outputBuffer.length += sendSz;
 
         return SendBuffered(ssl);
     }
 #endif /* WOLFSSL_DTLS */
 
     typedef struct DckeArgs {
         byte*  output; /* not allocated */
         word32 length;
         word32 idx;
         word32 begin;
         word32 sigSz;
     #ifndef NO_RSA
         int    lastErr;
     #endif
     } DckeArgs;
 
     static void FreeDckeArgs(WOLFSSL* ssl, void* pArgs)
     {
         DckeArgs* args = (DckeArgs*)pArgs;
 
         (void)ssl;
         (void)args;
     }
 
     /* handle processing client_key_exchange (16) */
     static int DoClientKeyExchange(WOLFSSL* ssl, byte* input, word32* inOutIdx,
                                                                     word32 size)
     {
         int ret;
     #ifdef WOLFSSL_ASYNC_CRYPT
         DckeArgs* args = (DckeArgs*)ssl->async.args;
         typedef char args_test[sizeof(ssl->async.args) >= sizeof(*args) ? 1 : -1];
         (void)sizeof(args_test);
     #else
         DckeArgs  args[1];
     #endif
 
         (void)size;
         (void)input;
 
         WOLFSSL_START(WC_FUNC_CLIENT_KEY_EXCHANGE_DO);
         WOLFSSL_ENTER("DoClientKeyExchange");
 
     #ifdef WOLFSSL_ASYNC_CRYPT
         ret = wolfSSL_AsyncPop(ssl, &ssl->options.asyncState);
         if (ret != WC_NOT_PENDING_E) {
             /* Check for error */
             if (ret < 0)
                 goto exit_dcke;
         }
         else
     #endif /* WOLFSSL_ASYNC_CRYPT */
         {
             /* Reset state */
             ret = 0;
             ssl->options.asyncState = TLS_ASYNC_BEGIN;
             XMEMSET(args, 0, sizeof(DckeArgs));
             args->idx = *inOutIdx;
             args->begin = *inOutIdx;
         #ifdef WOLFSSL_ASYNC_CRYPT
             ssl->async.freeArgs = FreeDckeArgs;
         #endif
         }
 
         /* Do Client Key Exchange State Machine */
         switch(ssl->options.asyncState)
         {
             case TLS_ASYNC_BEGIN:
             {
                 /* Sanity checks */
                 if (ssl->options.side != WOLFSSL_SERVER_END) {
                     WOLFSSL_MSG("Client received client keyexchange, attack?");
                     WOLFSSL_ERROR(ssl->error = SIDE_ERROR);
                     ERROR_OUT(WOLFSSL_FATAL_ERROR, exit_dcke);
                 }
 
                 if (ssl->options.clientState < CLIENT_HELLO_COMPLETE) {
                     WOLFSSL_MSG("Client sending keyexchange at wrong time");
                     SendAlert(ssl, alert_fatal, unexpected_message);
                     ERROR_OUT(OUT_OF_ORDER_E, exit_dcke);
                 }
 
             #if !defined(NO_CERTS) && !defined(WOLFSSL_NO_CLIENT_AUTH)
                 if (ssl->options.verifyPeer && ssl->options.failNoCert) {
                     if (!ssl->options.havePeerCert) {
                         WOLFSSL_MSG("client didn't present peer cert");
                         ERROR_OUT(NO_PEER_CERT, exit_dcke);
                     }
                 }
 
                 if (ssl->options.verifyPeer && ssl->options.failNoCertxPSK) {
                     if (!ssl->options.havePeerCert &&
                                              !ssl->options.usingPSK_cipher) {
                         WOLFSSL_MSG("client didn't present peer cert");
                         return NO_PEER_CERT;
                     }
                 }
             #endif /* !NO_CERTS && !WOLFSSL_NO_CLIENT_AUTH */
 
             #if defined(WOLFSSL_CALLBACKS)
                 if (ssl->hsInfoOn) {
                     AddPacketName(ssl, "ClientKeyExchange");
                 }
                 if (ssl->toInfoOn) {
                     AddLateName("ClientKeyExchange", &ssl->timeoutInfo);
                 }
             #endif
 
                 if (ssl->arrays->preMasterSecret == NULL) {
                     ssl->arrays->preMasterSz = ENCRYPT_LEN;
                     ssl->arrays->preMasterSecret = (byte*)XMALLOC(ENCRYPT_LEN,
                                                 ssl->heap, DYNAMIC_TYPE_SECRET);
                     if (ssl->arrays->preMasterSecret == NULL) {
                         ERROR_OUT(MEMORY_E, exit_dcke);
                     }
                     XMEMSET(ssl->arrays->preMasterSecret, 0, ENCRYPT_LEN);
                 }
 
                 switch (ssl->specs.kea) {
                 #ifndef NO_RSA
                     case rsa_kea:
                     {
                         break;
                     } /* rsa_kea */
                 #endif /* !NO_RSA */
                 #ifndef NO_PSK
                     case psk_kea:
                     {
                         /* sanity check that PSK server callback has been set */
                         if (ssl->options.server_psk_cb == NULL) {
                            WOLFSSL_MSG("No server PSK callback set");
                            ERROR_OUT(PSK_KEY_ERROR, exit_dcke);
                         }
                         break;
                     }
                 #endif /* !NO_PSK */
                 #ifdef HAVE_NTRU
                     case ntru_kea:
                     {
                         /* make sure private key exists */
                         if (ssl->buffers.key == NULL ||
                                             ssl->buffers.key->buffer == NULL) {
                             ERROR_OUT(NO_PRIVATE_KEY, exit_dcke);
                         }
                         break;
                     }
                 #endif /* HAVE_NTRU */
                 #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                     case ecc_diffie_hellman_kea:
                     {
                         break;
                     }
                 #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
                 #ifndef NO_DH
                     case diffie_hellman_kea:
                     {
                         break;
                     }
                 #endif /* !NO_DH */
                 #if !defined(NO_DH) && !defined(NO_PSK)
                     case dhe_psk_kea:
                     {
                         /* sanity check that PSK server callback has been set */
                         if (ssl->options.server_psk_cb == NULL) {
                             WOLFSSL_MSG("No server PSK callback set");
                             ERROR_OUT(PSK_KEY_ERROR, exit_dcke);
                         }
                         break;
                     }
                 #endif /* !NO_DH && !NO_PSK */
                 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                     case ecdhe_psk_kea:
                     {
                         /* sanity check that PSK server callback has been set */
                         if (ssl->options.server_psk_cb == NULL) {
                             WOLFSSL_MSG("No server PSK callback set");
                             ERROR_OUT(PSK_KEY_ERROR, exit_dcke);
                         }
                         break;
                     }
                 #endif /* (HAVE_ECC || CURVE25519 || CURVE448) && !NO_PSK */
                     default:
                         WOLFSSL_MSG("Bad kea type");
                         ret = BAD_KEA_TYPE_E;
                 } /* switch (ssl->specs.kea) */
 
                 /* Check for error */
                 if (ret != 0) {
                     goto exit_dcke;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_BUILD;
             } /* TLS_ASYNC_BEGIN */
             FALL_THROUGH;
 
             case TLS_ASYNC_BUILD:
             {
                 switch (ssl->specs.kea) {
                 #ifndef NO_RSA
                     case rsa_kea:
                     {
                         word16 keySz;
 
                         ssl->buffers.keyType = rsa_sa_algo;
                         ret = DecodePrivateKey(ssl, &keySz);
                         if (ret != 0) {
                             goto exit_dcke;
                         }
                         args->length = (word32)keySz;
                         ssl->arrays->preMasterSz = SECRET_LEN;
 
                         if (ssl->options.tls) {
                             word16 check;
 
                             if ((args->idx - args->begin) + OPAQUE16_LEN > size) {
                                 ERROR_OUT(BUFFER_ERROR, exit_dcke);
                             }
 
                             ato16(input + args->idx, &check);
                             args->idx += OPAQUE16_LEN;
 
                             if ((word32)check != args->length) {
                                 WOLFSSL_MSG("RSA explicit size doesn't match");
                         #ifdef WOLFSSL_EXTRA_ALERTS
                                 SendAlert(ssl, alert_fatal, bad_record_mac);
                         #endif
                                 ERROR_OUT(RSA_PRIVATE_ERROR, exit_dcke);
                             }
                         }
 
                         if ((args->idx - args->begin) + args->length > size) {
                             WOLFSSL_MSG("RSA message too big");
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         /* pre-load PreMasterSecret with RNG data */
                         ret = wc_RNG_GenerateBlock(ssl->rng,
                             &ssl->arrays->preMasterSecret[VERSION_SZ],
                             SECRET_LEN - VERSION_SZ);
                         if (ret != 0) {
                             goto exit_dcke;
                         }
 
                         args->output = NULL;
                         break;
                     } /* rsa_kea */
                 #endif /* !NO_RSA */
                 #ifndef NO_PSK
                     case psk_kea:
                     {
                         byte* pms = ssl->arrays->preMasterSecret;
                         word16 ci_sz;
 
                         if ((args->idx - args->begin) + OPAQUE16_LEN > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         ato16(input + args->idx, &ci_sz);
                         args->idx += OPAQUE16_LEN;
 
                         if (ci_sz > MAX_PSK_ID_LEN) {
                             ERROR_OUT(CLIENT_ID_ERROR, exit_dcke);
                         }
 
                         if ((args->idx - args->begin) + ci_sz > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         XMEMCPY(ssl->arrays->client_identity,
                                                     input + args->idx, ci_sz);
                         args->idx += ci_sz;
 
                         ssl->arrays->client_identity[ci_sz] = '\0'; /* null term */
                         ssl->arrays->psk_keySz = ssl->options.server_psk_cb(ssl,
                             ssl->arrays->client_identity, ssl->arrays->psk_key,
                             MAX_PSK_KEY_LEN);
 
                         if (ssl->arrays->psk_keySz == 0 ||
                                 ssl->arrays->psk_keySz > MAX_PSK_KEY_LEN) {
                             ERROR_OUT(PSK_KEY_ERROR, exit_dcke);
                         }
 
                         /* make psk pre master secret */
                         /* length of key + length 0s + length of key + key */
                         c16toa((word16) ssl->arrays->psk_keySz, pms);
                         pms += OPAQUE16_LEN;
 
                         XMEMSET(pms, 0, ssl->arrays->psk_keySz);
                         pms += ssl->arrays->psk_keySz;
 
                         c16toa((word16) ssl->arrays->psk_keySz, pms);
                         pms += OPAQUE16_LEN;
 
                         XMEMCPY(pms, ssl->arrays->psk_key, ssl->arrays->psk_keySz);
                         ssl->arrays->preMasterSz =
                             (ssl->arrays->psk_keySz * 2) + (OPAQUE16_LEN * 2);
                         break;
                     }
                 #endif /* !NO_PSK */
                 #ifdef HAVE_NTRU
                     case ntru_kea:
                     {
                         word16 cipherLen;
                         word16 plainLen = ENCRYPT_LEN;
 
                         if ((args->idx - args->begin) + OPAQUE16_LEN > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         ato16(input + args->idx, &cipherLen);
                         args->idx += OPAQUE16_LEN;
 
                         if (cipherLen > MAX_NTRU_ENCRYPT_SZ) {
                             ERROR_OUT(NTRU_KEY_ERROR, exit_dcke);
                         }
 
                         if ((args->idx - args->begin) + cipherLen > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         if (NTRU_OK != ntru_crypto_ntru_decrypt(
                                     (word16) ssl->buffers.key->length,
                                     ssl->buffers.key->buffer, cipherLen,
                                     input + args->idx, &plainLen,
                                     ssl->arrays->preMasterSecret)) {
                             ERROR_OUT(NTRU_DECRYPT_ERROR, exit_dcke);
                         }
 
                         if (plainLen != SECRET_LEN) {
                             ERROR_OUT(NTRU_DECRYPT_ERROR, exit_dcke);
                         }
 
                         args->idx += cipherLen;
                         ssl->arrays->preMasterSz = plainLen;
                         break;
                     }
                 #endif /* HAVE_NTRU */
                 #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                     case ecc_diffie_hellman_kea:
                     {
                     #ifdef HAVE_ECC
                         ecc_key* private_key = ssl->eccTempKey;
 
                         /* handle static private key */
                         if (ssl->specs.static_ecdh &&
                                           ssl->ecdhCurveOID != ECC_X25519_OID &&
                                           ssl->ecdhCurveOID != ECC_X448_OID) {
                             word16 keySz;
 
                             ssl->buffers.keyType = ecc_dsa_sa_algo;
                             ret = DecodePrivateKey(ssl, &keySz);
                             if (ret != 0) {
                                 goto exit_dcke;
                             }
                             private_key = (ecc_key*)ssl->hsKey;
                         }
                     #endif
 
                         /* import peer ECC key */
                         if ((args->idx - args->begin) + OPAQUE8_LEN > size) {
                         #ifdef WOLFSSL_EXTRA_ALERTS
                             SendAlert(ssl, alert_fatal, decode_error);
                         #endif
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         args->length = input[args->idx++];
 
                         if ((args->idx - args->begin) + args->length > size) {
                         #ifdef WOLFSSL_EXTRA_ALERTS
                             SendAlert(ssl, alert_fatal, decode_error);
                         #endif
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                     #ifdef HAVE_CURVE25519
                         if (ssl->ecdhCurveOID == ECC_X25519_OID) {
                         #ifdef HAVE_PK_CALLBACKS
                             /* if callback then use it for shared secret */
                             if (ssl->ctx->X25519SharedSecretCb != NULL) {
                                 break;
                             }
                         #endif
                             if (ssl->peerX25519Key == NULL) {
                                 /* alloc/init on demand */
                                 ret = AllocKey(ssl, DYNAMIC_TYPE_CURVE25519,
                                     (void**)&ssl->peerX25519Key);
                                 if (ret != 0) {
                                     goto exit_dcke;
                                 }
                             } else if (ssl->peerX25519KeyPresent) {
                                 ret = ReuseKey(ssl, DYNAMIC_TYPE_CURVE25519,
                                                ssl->peerX25519Key);
                                 ssl->peerX25519KeyPresent = 0;
                                 if (ret != 0) {
                                     goto exit_dcke;
                                 }
                             }
 
                             if ((ret = wc_curve25519_check_public(
                                     input + args->idx, args->length,
                                     EC25519_LITTLE_ENDIAN)) != 0) {
                         #ifdef WOLFSSL_EXTRA_ALERTS
                                 if (ret == BUFFER_E)
                                     SendAlert(ssl, alert_fatal, decode_error);
                                 else if (ret == ECC_OUT_OF_RANGE_E)
                                     SendAlert(ssl, alert_fatal, bad_record_mac);
                                 else {
                                     SendAlert(ssl, alert_fatal,
                                                              illegal_parameter);
                                 }
                         #endif
                                 ERROR_OUT(ECC_PEERKEY_ERROR, exit_dcke);
                             }
 
                             if (wc_curve25519_import_public_ex(
                                     input + args->idx, args->length,
                                     ssl->peerX25519Key,
                                     EC25519_LITTLE_ENDIAN)) {
                         #ifdef WOLFSSL_EXTRA_ALERTS
                                 SendAlert(ssl, alert_fatal, illegal_parameter);
                         #endif
                                 ERROR_OUT(ECC_PEERKEY_ERROR, exit_dcke);
                             }
 
                             ssl->arrays->preMasterSz = CURVE25519_KEYSIZE;
 
                             ssl->peerX25519KeyPresent = 1;
 
                             break;
                         }
                     #endif
                     #ifdef HAVE_CURVE448
                         if (ssl->ecdhCurveOID == ECC_X448_OID) {
                         #ifdef HAVE_PK_CALLBACKS
                             /* if callback then use it for shared secret */
                             if (ssl->ctx->X448SharedSecretCb != NULL) {
                                 break;
                             }
                         #endif
                             if (ssl->peerX448Key == NULL) {
                                 /* alloc/init on demand */
                                 ret = AllocKey(ssl, DYNAMIC_TYPE_CURVE448,
                                     (void**)&ssl->peerX448Key);
                                 if (ret != 0) {
                                     goto exit_dcke;
                                 }
                             } else if (ssl->peerX448KeyPresent) {
                                 ret = ReuseKey(ssl, DYNAMIC_TYPE_CURVE448,
                                                ssl->peerX448Key);
                                 ssl->peerX448KeyPresent = 0;
                                 if (ret != 0) {
                                     goto exit_dcke;
                                 }
                             }
 
                             if ((ret = wc_curve448_check_public(
                                     input + args->idx, args->length,
                                     EC448_LITTLE_ENDIAN)) != 0) {
                         #ifdef WOLFSSL_EXTRA_ALERTS
                                 if (ret == BUFFER_E)
                                     SendAlert(ssl, alert_fatal, decode_error);
                                 else if (ret == ECC_OUT_OF_RANGE_E)
                                     SendAlert(ssl, alert_fatal, bad_record_mac);
                                 else {
                                     SendAlert(ssl, alert_fatal,
                                                              illegal_parameter);
                                 }
                         #endif
                                 ERROR_OUT(ECC_PEERKEY_ERROR, exit_dcke);
                             }
 
                             if (wc_curve448_import_public_ex(
                                     input + args->idx, args->length,
                                     ssl->peerX448Key,
                                     EC448_LITTLE_ENDIAN)) {
                         #ifdef WOLFSSL_EXTRA_ALERTS
                                 SendAlert(ssl, alert_fatal, illegal_parameter);
                         #endif
                                 ERROR_OUT(ECC_PEERKEY_ERROR, exit_dcke);
                             }
 
                             ssl->arrays->preMasterSz = CURVE448_KEY_SIZE;
 
                             ssl->peerX448KeyPresent = 1;
 
                             break;
                         }
                     #endif
                 #ifdef HAVE_ECC
                     #ifdef HAVE_PK_CALLBACKS
                         /* if callback then use it for shared secret */
                         if (ssl->ctx->EccSharedSecretCb != NULL) {
                             break;
                         }
                     #endif
 
                         if (!ssl->specs.static_ecdh &&
                             ssl->eccTempKeyPresent == 0) {
                             WOLFSSL_MSG("Ecc ephemeral key not made correctly");
                             ERROR_OUT(ECC_MAKEKEY_ERROR, exit_dcke);
                         }
 
                         if (ssl->peerEccKey == NULL) {
                             /* alloc/init on demand */
                             ret = AllocKey(ssl, DYNAMIC_TYPE_ECC,
                                 (void**)&ssl->peerEccKey);
                             if (ret != 0) {
                                 goto exit_dcke;
                             }
                         } else if (ssl->peerEccKeyPresent) {
                             ret = ReuseKey(ssl, DYNAMIC_TYPE_ECC,
                                            ssl->peerEccKey);
                             ssl->peerEccKeyPresent = 0;
                             if (ret != 0) {
                                 goto exit_dcke;
                             }
                         }
 
                         if (wc_ecc_import_x963_ex(input + args->idx,
                                                   args->length, ssl->peerEccKey,
                                                   private_key->dp->id)) {
                         #ifdef WOLFSSL_EXTRA_ALERTS
                             SendAlert(ssl, alert_fatal, illegal_parameter);
                         #endif
                             ERROR_OUT(ECC_PEERKEY_ERROR, exit_dcke);
                         }
 
                         ssl->arrays->preMasterSz = private_key->dp->size;
 
                         ssl->peerEccKeyPresent = 1;
                         
                     #if defined(WOLFSSL_TLS13) || defined(HAVE_FFDHE)
                         /* client_hello may have sent FFEDH2048, which sets namedGroup, 
                             but that is not being used, so clear it */
                         /* resolves issue with server side wolfSSL_get_curve_name */
                         ssl->namedGroup = 0;
                     #endif
                 #endif /* HAVE_ECC */
 
                         break;
                     }
                 #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
                 #ifndef NO_DH
                     case diffie_hellman_kea:
                     {
                         word16 clientPubSz;
 
                         if ((args->idx - args->begin) + OPAQUE16_LEN > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         ato16(input + args->idx, &clientPubSz);
                         args->idx += OPAQUE16_LEN;
 
                         if ((args->idx - args->begin) + clientPubSz > size) {
                         #ifdef WOLFSSL_EXTRA_ALERTS
                             SendAlert(ssl, alert_fatal, decode_error);
                         #endif
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         args->sigSz = clientPubSz;
 
                         ret = AllocKey(ssl, DYNAMIC_TYPE_DH,
                                             (void**)&ssl->buffers.serverDH_Key);
                         if (ret != 0) {
                             goto exit_dcke;
                         }
 
                         ret = wc_DhSetKey(ssl->buffers.serverDH_Key,
                             ssl->buffers.serverDH_P.buffer,
                             ssl->buffers.serverDH_P.length,
                             ssl->buffers.serverDH_G.buffer,
                             ssl->buffers.serverDH_G.length);
 
                         /* set the max agree result size */
                         ssl->arrays->preMasterSz = ENCRYPT_LEN;
                         break;
                     }
                 #endif /* !NO_DH */
                 #if !defined(NO_DH) && !defined(NO_PSK)
                     case dhe_psk_kea:
                     {
                         word16 clientSz;
 
                         /* Read in the PSK hint */
                         if ((args->idx - args->begin) + OPAQUE16_LEN > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         ato16(input + args->idx, &clientSz);
                         args->idx += OPAQUE16_LEN;
                         if (clientSz > MAX_PSK_ID_LEN) {
                             ERROR_OUT(CLIENT_ID_ERROR, exit_dcke);
                         }
 
                         if ((args->idx - args->begin) + clientSz > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         XMEMCPY(ssl->arrays->client_identity, input + args->idx,
                                                                     clientSz);
                         args->idx += clientSz;
                         ssl->arrays->client_identity[clientSz] = '\0'; /* null term */
 
                         /* Read in the DHE business */
                         if ((args->idx - args->begin) + OPAQUE16_LEN > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         ato16(input + args->idx, &clientSz);
                         args->idx += OPAQUE16_LEN;
 
                         if ((args->idx - args->begin) + clientSz > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         args->sigSz = clientSz;
 
                         ret = AllocKey(ssl, DYNAMIC_TYPE_DH,
                                             (void**)&ssl->buffers.serverDH_Key);
                         if (ret != 0) {
                             goto exit_dcke;
                         }
 
                         ret = wc_DhSetKey(ssl->buffers.serverDH_Key,
                             ssl->buffers.serverDH_P.buffer,
                             ssl->buffers.serverDH_P.length,
                             ssl->buffers.serverDH_G.buffer,
                             ssl->buffers.serverDH_G.length);
 
                         break;
                     }
                 #endif /* !NO_DH && !NO_PSK */
                 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                     case ecdhe_psk_kea:
                     {
                         word16 clientSz;
 
                         /* Read in the PSK hint */
                         if ((args->idx - args->begin) + OPAQUE16_LEN > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         ato16(input + args->idx, &clientSz);
                         args->idx += OPAQUE16_LEN;
                         if (clientSz > MAX_PSK_ID_LEN) {
                             ERROR_OUT(CLIENT_ID_ERROR, exit_dcke);
                         }
                         if ((args->idx - args->begin) + clientSz > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         XMEMCPY(ssl->arrays->client_identity,
                                                    input + args->idx, clientSz);
                         args->idx += clientSz;
                         ssl->arrays->client_identity[clientSz] = '\0'; /* null term */
 
                         /* import peer ECC key */
                         if ((args->idx - args->begin) + OPAQUE8_LEN > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         args->length = input[args->idx++];
 
                         if ((args->idx - args->begin) + args->length > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         args->sigSz = ENCRYPT_LEN - OPAQUE16_LEN;
 
                     #ifdef HAVE_CURVE25519
                         if (ssl->ecdhCurveOID == ECC_X25519_OID) {
                         #ifdef HAVE_PK_CALLBACKS
                             /* if callback then use it for shared secret */
                             if (ssl->ctx->X25519SharedSecretCb != NULL) {
                                 break;
                             }
                         #endif
 
                             if (ssl->eccTempKeyPresent == 0) {
                                 WOLFSSL_MSG(
                                      "X25519 ephemeral key not made correctly");
                                 ERROR_OUT(ECC_MAKEKEY_ERROR, exit_dcke);
                             }
 
                             if (ssl->peerX25519Key == NULL) {
                                 /* alloc/init on demand */
                                 ret = AllocKey(ssl, DYNAMIC_TYPE_CURVE25519,
                                     (void**)&ssl->peerX25519Key);
                                 if (ret != 0) {
                                     goto exit_dcke;
                                 }
                             } else if (ssl->peerX25519KeyPresent) {
                                 ret = ReuseKey(ssl, DYNAMIC_TYPE_CURVE25519,
                                                ssl->peerX25519Key);
                                 ssl->peerX25519KeyPresent = 0;
                                 if (ret != 0) {
                                     goto exit_dcke;
                                 }
                             }
 
                             if ((ret = wc_curve25519_check_public(
                                     input + args->idx, args->length,
                                     EC25519_LITTLE_ENDIAN)) != 0) {
                         #ifdef WOLFSSL_EXTRA_ALERTS
                                 if (ret == BUFFER_E)
                                     SendAlert(ssl, alert_fatal, decode_error);
                                 else if (ret == ECC_OUT_OF_RANGE_E)
                                     SendAlert(ssl, alert_fatal, bad_record_mac);
                                 else {
                                     SendAlert(ssl, alert_fatal,
                                                              illegal_parameter);
                                 }
                         #endif
                                 ERROR_OUT(ECC_PEERKEY_ERROR, exit_dcke);
                             }
 
                             if (wc_curve25519_import_public_ex(
                                     input + args->idx, args->length,
                                     ssl->peerX25519Key,
                                     EC25519_LITTLE_ENDIAN)) {
                                 ERROR_OUT(ECC_PEERKEY_ERROR, exit_dcke);
                             }
 
                             ssl->peerX25519KeyPresent = 1;
 
                             break;
                         }
                     #endif
                     #ifdef HAVE_CURVE448
                         if (ssl->ecdhCurveOID == ECC_X448_OID) {
                         #ifdef HAVE_PK_CALLBACKS
                             /* if callback then use it for shared secret */
                             if (ssl->ctx->X448SharedSecretCb != NULL) {
                                 break;
                             }
                         #endif
 
                             if (ssl->eccTempKeyPresent == 0) {
                                 WOLFSSL_MSG(
                                        "X448 ephemeral key not made correctly");
                                 ERROR_OUT(ECC_MAKEKEY_ERROR, exit_dcke);
                             }
 
                             if (ssl->peerX448Key == NULL) {
                                 /* alloc/init on demand */
                                 ret = AllocKey(ssl, DYNAMIC_TYPE_CURVE448,
                                     (void**)&ssl->peerX448Key);
                                 if (ret != 0) {
                                     goto exit_dcke;
                                 }
                             } else if (ssl->peerX448KeyPresent) {
                                 ret = ReuseKey(ssl, DYNAMIC_TYPE_CURVE448,
                                                ssl->peerX448Key);
                                 ssl->peerX448KeyPresent = 0;
                                 if (ret != 0) {
                                     goto exit_dcke;
                                 }
                             }
 
                             if ((ret = wc_curve448_check_public(
                                     input + args->idx, args->length,
                                     EC448_LITTLE_ENDIAN)) != 0) {
                         #ifdef WOLFSSL_EXTRA_ALERTS
                                 if (ret == BUFFER_E)
                                     SendAlert(ssl, alert_fatal, decode_error);
                                 else if (ret == ECC_OUT_OF_RANGE_E)
                                     SendAlert(ssl, alert_fatal, bad_record_mac);
                                 else {
                                     SendAlert(ssl, alert_fatal,
                                                              illegal_parameter);
                                 }
                         #endif
                                 ERROR_OUT(ECC_PEERKEY_ERROR, exit_dcke);
                             }
 
                             if (wc_curve448_import_public_ex(
                                     input + args->idx, args->length,
                                     ssl->peerX448Key,
                                     EC448_LITTLE_ENDIAN)) {
                                 ERROR_OUT(ECC_PEERKEY_ERROR, exit_dcke);
                             }
 
                             ssl->peerX448KeyPresent = 1;
 
                             break;
                         }
                     #endif
                     #ifdef HAVE_PK_CALLBACKS
                         /* if callback then use it for shared secret */
                         if (ssl->ctx->EccSharedSecretCb != NULL) {
                             break;
                         }
                     #endif
 
                         if (ssl->eccTempKeyPresent == 0) {
                             WOLFSSL_MSG("Ecc ephemeral key not made correctly");
                             ERROR_OUT(ECC_MAKEKEY_ERROR, exit_dcke);
                         }
 
                         if (ssl->peerEccKey == NULL) {
                             /* alloc/init on demand */
                             ret = AllocKey(ssl, DYNAMIC_TYPE_ECC,
                                 (void**)&ssl->peerEccKey);
                             if (ret != 0) {
                                 goto exit_dcke;
                             }
                         }
                         else if (ssl->peerEccKeyPresent) {
                             ret = ReuseKey(ssl, DYNAMIC_TYPE_ECC,
                                            ssl->peerEccKey);
                             ssl->peerEccKeyPresent = 0;
                             if (ret != 0) {
                                 goto exit_dcke;
                             }
                         }
                         if (wc_ecc_import_x963_ex(input + args->idx,
                                  args->length, ssl->peerEccKey,
                                  ssl->eccTempKey->dp->id)) {
                             ERROR_OUT(ECC_PEERKEY_ERROR, exit_dcke);
                         }
 
                         ssl->peerEccKeyPresent = 1;
                         break;
                     }
                 #endif /* (HAVE_ECC || CURVE25519 || CURVE448) && !NO_PSK */
                     default:
                         ret = BAD_KEA_TYPE_E;
                 } /* switch (ssl->specs.kea) */
 
                 /* Check for error */
                 if (ret != 0) {
                     goto exit_dcke;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_DO;
             } /* TLS_ASYNC_BUILD */
             FALL_THROUGH;
 
             case TLS_ASYNC_DO:
             {
                 switch (ssl->specs.kea) {
                 #ifndef NO_RSA
                     case rsa_kea:
                     {
                         RsaKey* key = (RsaKey*)ssl->hsKey;
 
                         ret = RsaDec(ssl,
                             input + args->idx,
                             args->length,
                             &args->output,
                             &args->sigSz,
                             key,
                         #ifdef HAVE_PK_CALLBACKS
                             ssl->buffers.key
                         #else
                             NULL
                         #endif
                         );
 
                         /*  Errors that can occur here that should be
                          *  indistinguishable:
                          *       RSA_BUFFER_E, RSA_PAD_E and RSA_PRIVATE_ERROR
                          */
                     #ifdef WOLFSSL_ASYNC_CRYPT
                         if (ret == WC_PENDING_E)
                             goto exit_dcke;
                     #endif
                         if (ret == BAD_FUNC_ARG)
                             goto exit_dcke;
 
                         args->lastErr = ret - (SECRET_LEN - args->sigSz);
                         ret = 0;
                         break;
                     } /* rsa_kea */
                 #endif /* !NO_RSA */
                 #ifndef NO_PSK
                     case psk_kea:
                     {
                         break;
                     }
                 #endif /* !NO_PSK */
                 #ifdef HAVE_NTRU
                     case ntru_kea:
                     {
                         break;
                     }
                 #endif /* HAVE_NTRU */
                 #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                     case ecc_diffie_hellman_kea:
                     {
                         void* private_key = ssl->eccTempKey;
                         (void)private_key;
 
                     #ifdef HAVE_CURVE25519
                         if (ssl->ecdhCurveOID == ECC_X25519_OID) {
                             ret = X25519SharedSecret(ssl,
                                 (curve25519_key*)private_key,
                                 ssl->peerX25519Key,
                                 input + args->idx, &args->length,
                                 ssl->arrays->preMasterSecret,
                                 &ssl->arrays->preMasterSz,
                                 WOLFSSL_SERVER_END
                             );
                             break;
                         }
                     #endif
                     #ifdef HAVE_CURVE448
                         if (ssl->ecdhCurveOID == ECC_X448_OID) {
                             ret = X448SharedSecret(ssl,
                                 (curve448_key*)private_key,
                                 ssl->peerX448Key,
                                 input + args->idx, &args->length,
                                 ssl->arrays->preMasterSecret,
                                 &ssl->arrays->preMasterSz,
                                 WOLFSSL_SERVER_END
                             );
                             break;
                         }
                     #endif
                     #ifdef HAVE_ECC
                         if (ssl->specs.static_ecdh) {
                             private_key = ssl->hsKey;
                         }
 
                         /* Generate shared secret */
                         ret = EccSharedSecret(ssl,
                             (ecc_key*)private_key, ssl->peerEccKey,
                             input + args->idx, &args->length,
                             ssl->arrays->preMasterSecret,
                             &ssl->arrays->preMasterSz,
                             WOLFSSL_SERVER_END
                         );
                     #ifdef WOLFSSL_ASYNC_CRYPT
                         if (ret != WC_PENDING_E)
                     #endif
                         {
                             FreeKey(ssl, DYNAMIC_TYPE_ECC,
                                                       (void**)&ssl->peerEccKey);
                             ssl->peerEccKeyPresent = 0;
                         }
                     #endif
                         break;
                     }
                 #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
                 #ifndef NO_DH
                     case diffie_hellman_kea:
                     {
                         ret = DhAgree(ssl, ssl->buffers.serverDH_Key,
                             ssl->buffers.serverDH_Priv.buffer,
                             ssl->buffers.serverDH_Priv.length,
                             input + args->idx,
                             (word16)args->sigSz,
                             ssl->arrays->preMasterSecret,
                             &ssl->arrays->preMasterSz);
                         break;
                     }
                 #endif /* !NO_DH */
                 #if !defined(NO_DH) && !defined(NO_PSK)
                     case dhe_psk_kea:
                     {
                         ret = DhAgree(ssl, ssl->buffers.serverDH_Key,
                             ssl->buffers.serverDH_Priv.buffer,
                             ssl->buffers.serverDH_Priv.length,
                             input + args->idx,
                             (word16)args->sigSz,
                             ssl->arrays->preMasterSecret + OPAQUE16_LEN,
                             &ssl->arrays->preMasterSz);
                         break;
                     }
                 #endif /* !NO_DH && !NO_PSK */
                 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                     case ecdhe_psk_kea:
                     {
                     #ifdef HAVE_CURVE25519
                         if (ssl->ecdhCurveOID == ECC_X25519_OID) {
                             ret = X25519SharedSecret(ssl,
                                 (curve25519_key*)ssl->eccTempKey,
                                 ssl->peerX25519Key,
                                 input + args->idx, &args->length,
                                 ssl->arrays->preMasterSecret + OPAQUE16_LEN,
                                 &args->sigSz,
                                 WOLFSSL_SERVER_END
                             );
                         #ifdef WOLFSSL_ASYNC_CRYPT
                             if (ret != WC_PENDING_E)
                         #endif
                             {
                                 FreeKey(ssl, DYNAMIC_TYPE_CURVE25519,
                                                    (void**)&ssl->peerX25519Key);
                                 ssl->peerX25519KeyPresent = 0;
                             }
                             break;
                         }
                     #endif
                     #ifdef HAVE_CURVE448
                         if (ssl->ecdhCurveOID == ECC_X448_OID) {
                             ret = X448SharedSecret(ssl,
                                 (curve448_key*)ssl->eccTempKey,
                                 ssl->peerX448Key,
                                 input + args->idx, &args->length,
                                 ssl->arrays->preMasterSecret + OPAQUE16_LEN,
                                 &args->sigSz,
                                 WOLFSSL_SERVER_END
                             );
                         #ifdef WOLFSSL_ASYNC_CRYPT
                             if (ret != WC_PENDING_E)
                         #endif
                             {
                                 FreeKey(ssl, DYNAMIC_TYPE_CURVE448,
                                                      (void**)&ssl->peerX448Key);
                                 ssl->peerX448KeyPresent = 0;
                             }
                             break;
                         }
                     #endif
                         /* Generate shared secret */
                         ret = EccSharedSecret(ssl,
                             ssl->eccTempKey, ssl->peerEccKey,
                             input + args->idx, &args->length,
                             ssl->arrays->preMasterSecret + OPAQUE16_LEN,
                             &args->sigSz,
                             WOLFSSL_SERVER_END
                         );
                         if (!ssl->specs.static_ecdh
                     #ifdef WOLFSSL_ASYNC_CRYPT
                             && ret != WC_PENDING_E
                     #endif
                         ) {
                             FreeKey(ssl, DYNAMIC_TYPE_ECC,
                                                       (void**)&ssl->peerEccKey);
                             ssl->peerEccKeyPresent = 0;
                         }
                         break;
                     }
                 #endif /* (HAVE_ECC || CURVE25519 || CURVE448) && !NO_PSK */
                     default:
                         ret = BAD_KEA_TYPE_E;
                 } /* switch (ssl->specs.kea) */
 
                 /* Check for error */
                 if (ret != 0) {
                     goto exit_dcke;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_VERIFY;
             } /* TLS_ASYNC_DO */
             FALL_THROUGH;
 
             case TLS_ASYNC_VERIFY:
             {
                 switch (ssl->specs.kea) {
                 #ifndef NO_RSA
                     case rsa_kea:
                     {
                         byte mask;
                         int i;
 
                         /* Add the signature length to idx */
                         args->idx += args->length;
 
                     #ifdef DEBUG_WOLFSSL
                         /* check version (debug warning message only) */
                         if (args->output != NULL) {
                             if (args->output[0] != ssl->chVersion.major ||
                                 args->output[1] != ssl->chVersion.minor) {
                                 WOLFSSL_MSG("preMasterSecret version mismatch");
                             }
                         }
                     #endif
 
                         /* RFC5246 7.4.7.1:
                          * Treat incorrectly formatted message blocks and/or
                          * mismatched version numbers in a manner
                          * indistinguishable from correctly formatted RSA blocks
                          */
 
                         ret = args->lastErr;
                         args->lastErr = 0; /* reset */
                         /* On error 'ret' will be negative - top bit set */
                         mask = ((unsigned int)ret >>
                                                    ((sizeof(ret) * 8) - 1)) - 1;
 
                         /* build PreMasterSecret */
                         ssl->arrays->preMasterSecret[0] = ssl->chVersion.major;
                         ssl->arrays->preMasterSecret[1] = ssl->chVersion.minor;
 
                         if (args->output != NULL) {
                             /* Use random secret on error */
                             for (i = VERSION_SZ; i < SECRET_LEN; i++) {
                                 ssl->arrays->preMasterSecret[i] =
                                      ctMaskSel(mask, args->output[i],
                                                ssl->arrays->preMasterSecret[i]);
                             }
                         }
                         /* preMasterSecret has RNG and version set
                          * return proper length and ignore error
                          * error will be caught as decryption error
                          */
                         args->sigSz = SECRET_LEN;
                         ret = 0;
                         break;
                     } /* rsa_kea */
                 #endif /* !NO_RSA */
                 #ifndef NO_PSK
                     case psk_kea:
                     {
                         break;
                     }
                 #endif /* !NO_PSK */
                 #ifdef HAVE_NTRU
                     case ntru_kea:
                     {
                         break;
                     }
                 #endif /* HAVE_NTRU */
                 #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                     case ecc_diffie_hellman_kea:
                     {
                         /* skip past the imported peer key */
                         args->idx += args->length;
                         break;
                     }
                 #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
                 #ifndef NO_DH
                     case diffie_hellman_kea:
                     {
                         args->idx += (word16)args->sigSz;
                         break;
                     }
                 #endif /* !NO_DH */
                 #if !defined(NO_DH) && !defined(NO_PSK)
                     case dhe_psk_kea:
                     {
                         byte* pms = ssl->arrays->preMasterSecret;
                         word16 clientSz = (word16)args->sigSz;
 
                         args->idx += clientSz;
                         c16toa((word16)ssl->arrays->preMasterSz, pms);
                         ssl->arrays->preMasterSz += OPAQUE16_LEN;
                         pms += ssl->arrays->preMasterSz;
 
                         /* Use the PSK hint to look up the PSK and add it to the
                          * preMasterSecret here. */
                         ssl->arrays->psk_keySz = ssl->options.server_psk_cb(ssl,
                             ssl->arrays->client_identity, ssl->arrays->psk_key,
                             MAX_PSK_KEY_LEN);
 
                         if (ssl->arrays->psk_keySz == 0 ||
                                 ssl->arrays->psk_keySz > MAX_PSK_KEY_LEN) {
                             ERROR_OUT(PSK_KEY_ERROR, exit_dcke);
                         }
 
                         c16toa((word16) ssl->arrays->psk_keySz, pms);
                         pms += OPAQUE16_LEN;
 
                         XMEMCPY(pms, ssl->arrays->psk_key,
                                                     ssl->arrays->psk_keySz);
                         ssl->arrays->preMasterSz += ssl->arrays->psk_keySz +
                                                                 OPAQUE16_LEN;
                         break;
                     }
                 #endif /* !NO_DH && !NO_PSK */
                 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                     case ecdhe_psk_kea:
                     {
                         byte* pms = ssl->arrays->preMasterSecret;
                         word16 clientSz = (word16)args->sigSz;
 
                         /* skip past the imported peer key */
                         args->idx += args->length;
 
                         /* Add preMasterSecret */
                         c16toa(clientSz, pms);
                         ssl->arrays->preMasterSz = OPAQUE16_LEN + clientSz;
                         pms += ssl->arrays->preMasterSz;
 
                         /* Use the PSK hint to look up the PSK and add it to the
                          * preMasterSecret here. */
                         ssl->arrays->psk_keySz = ssl->options.server_psk_cb(ssl,
                             ssl->arrays->client_identity, ssl->arrays->psk_key,
                             MAX_PSK_KEY_LEN);
 
                         if (ssl->arrays->psk_keySz == 0 ||
                                    ssl->arrays->psk_keySz > MAX_PSK_KEY_LEN) {
                             ERROR_OUT(PSK_KEY_ERROR, exit_dcke);
                         }
 
                         c16toa((word16) ssl->arrays->psk_keySz, pms);
                         pms += OPAQUE16_LEN;
 
                         XMEMCPY(pms, ssl->arrays->psk_key, ssl->arrays->psk_keySz);
                         ssl->arrays->preMasterSz +=
                                       ssl->arrays->psk_keySz + OPAQUE16_LEN;
                         break;
                     }
                 #endif /* (HAVE_ECC || CURVE25519 || CURVE448) && !NO_PSK */
                     default:
                         ret = BAD_KEA_TYPE_E;
                 } /* switch (ssl->specs.kea) */
 
                 /* Check for error */
                 if (ret != 0) {
                     goto exit_dcke;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_FINALIZE;
             } /* TLS_ASYNC_VERIFY */
             FALL_THROUGH;
 
             case TLS_ASYNC_FINALIZE:
             {
                 if (IsEncryptionOn(ssl, 0)) {
                     args->idx += ssl->keys.padSz;
             #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
                     if (ssl->options.startedETMRead)
                         args->idx += MacSize(ssl);
             #endif
                 }
 
             #ifdef HAVE_QSH
                 word16 name;
 
                 if (ssl->options.haveQSH) {
                     /* extension name */
                     ato16(input + args->idx, &name);
                     args->idx += OPAQUE16_LEN;
 
                     if (name == TLSX_QUANTUM_SAFE_HYBRID) {
                         int    qshSz;
                         /* if qshSz is larger than 0 it is the
                            length of buffer used */
                         if ((qshSz = TLSX_QSHCipher_Parse(ssl,
                                 input + args->idx,
                                 size - args->idx + args->begin, 1)) < 0) {
                             ERROR_OUT(qshSz, exit_dcke);
                         }
                         args->idx += qshSz;
                     }
                     else {
                         /* unknown extension sent client ignored handshake */
                         ERROR_OUT(BUFFER_ERROR, exit_dcke);
                     }
                 }
             #endif /* HAVE_QSH */
                 ret = MakeMasterSecret(ssl);
 
                 /* Check for error */
                 if (ret != 0) {
                     goto exit_dcke;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_END;
             } /* TLS_ASYNC_FINALIZE */
             FALL_THROUGH;
 
             case TLS_ASYNC_END:
             {
                 /* Set final index */
                 *inOutIdx = args->idx;
 
                 ssl->options.clientState = CLIENT_KEYEXCHANGE_COMPLETE;
             #if !defined(NO_CERTS) && !defined(WOLFSSL_NO_CLIENT_AUTH)
                 if (ssl->options.verifyPeer) {
                     ret = BuildCertHashes(ssl, &ssl->hsHashes->certHashes);
                 }
             #endif
                 break;
             } /* TLS_ASYNC_END */
             default:
                 ret = INPUT_CASE_ERROR;
         } /* switch(ssl->options.asyncState) */
 
     exit_dcke:
 
         WOLFSSL_LEAVE("DoClientKeyExchange", ret);
         WOLFSSL_END(WC_FUNC_CLIENT_KEY_EXCHANGE_DO);
 
     #ifdef WOLFSSL_ASYNC_CRYPT
         /* Handle async operation */
         if (ret == WC_PENDING_E) {
             /* Mark message as not received so it can process again */
             ssl->msgsReceived.got_client_key_exchange = 0;
 
             return ret;
         }
     #endif /* WOLFSSL_ASYNC_CRYPT */
 
         /* Cleanup PMS */
         if (ssl->arrays->preMasterSecret != NULL) {
             ForceZero(ssl->arrays->preMasterSecret, ssl->arrays->preMasterSz);
         }
         ssl->arrays->preMasterSz = 0;
 
         /* Final cleanup */
         FreeDckeArgs(ssl, args);
         FreeKeyExchange(ssl);
 
         return ret;
     }
 
 #endif /* !WOLFSSL_NO_TLS12 */
 
 #if defined(OPENSSL_ALL) || defined(HAVE_STUNNEL) || defined(WOLFSSL_NGINX) || \
     defined(WOLFSSL_HAPROXY) || defined(HAVE_LIGHTY)
     int SNI_Callback(WOLFSSL* ssl)
     {
         /* Stunnel supports a custom sni callback to switch an SSL's ctx
         * when SNI is received. Call it now if exists */
         if(ssl && ssl->ctx && ssl->ctx->sniRecvCb) {
             WOLFSSL_MSG("Calling custom sni callback");
             if(ssl->ctx->sniRecvCb(ssl, NULL, ssl->ctx->sniRecvCbArg)
                     == alert_fatal) {
                 WOLFSSL_MSG("Error in custom sni callback. Fatal alert");
                 SendAlert(ssl, alert_fatal, unrecognized_name);
                 return FATAL_ERROR;
             }
         }
         return 0;
     }
 #endif /* OPENSSL_ALL || HAVE_STUNNEL || WOLFSSL_NGINX || WOLFSSL_HAPROXY */
 
 #endif /* NO_WOLFSSL_SERVER */
 
 
 #ifdef WOLFSSL_ASYNC_CRYPT
diff --git a/src/tls.c b/src/tls.c
index 811d280bc..5b0647ef2 100644
--- a/src/tls.c
+++ b/src/tls.c
@@ -4286,371 +4286,371 @@ static int TLSX_PointFormat_Parse(WOLFSSL* ssl, byte* input, word16 length,
 #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || defined(HAVE_CURVE448)
 int TLSX_ValidateSupportedCurves(WOLFSSL* ssl, byte first, byte second) {
     TLSX*           extension = NULL;
     SupportedCurve* curve     = NULL;
     word32          oid       = 0;
 #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || defined(HAVE_ED25519) || \
                               defined(HAVE_CURVE448) || defined(HAVE_ED448) || \
                                 (!defined(NO_RSA) && defined(WOLFSSL_STATIC_DH))
     word32          pkOid     = 0;
 #endif /* HAVE_ECC || HAVE_ED25519 || HAVE_ED448 || (!NO_RSA && STATIC_DH) */
     word32          defOid    = 0;
     word32          defSz     = 80; /* Maximum known curve size is 66. */
     word32          nextOid   = 0;
     word32          nextSz    = 80; /* Maximum known curve size is 66. */
     word32          currOid   = ssl->ecdhCurveOID;
     int             ephmSuite = 0;
     word16          octets    = 0; /* according to 'ecc_set_type ecc_sets[];' */
     int             sig       = 0; /* validate signature */
     int             key       = 0; /* validate key       */
 
     (void)oid;
     (void)pkOid;
 
     if (first == CHACHA_BYTE) {
         switch (second) {
             case TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256:
             case TLS_PSK_WITH_CHACHA20_POLY1305_SHA256:
             case TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256:
             case TLS_DHE_RSA_WITH_CHACHA20_OLD_POLY1305_SHA256:
                 return 1; /* no suite restriction */
             case TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:
             case TLS_ECDHE_RSA_WITH_CHACHA20_OLD_POLY1305_SHA256:
             case TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256:
                 break;
         }
     }
     if (first == ECC_BYTE || first == CHACHA_BYTE)
         extension = TLSX_Find(ssl->extensions, TLSX_SUPPORTED_GROUPS);
     if (!extension)
         return 1; /* no suite restriction */
 
     for (curve = (SupportedCurve*)extension->data;
          curve && !(sig && key);
          curve = curve->next) {
 
     #ifdef OPENSSL_EXTRA
         /* skip if name is not in supported ECC range */
         if (curve->name > WOLFSSL_ECC_X448)
             continue;
         /* skip if curve is disabled by user */
         if (ssl->ctx->disabledCurves & (1 << curve->name))
             continue;
     #endif
 
         /* find supported curve */
         switch (curve->name) {
 #ifdef HAVE_ECC
-    #if defined(HAVE_ECC160) || defined(HAVE_ALL_CURVES)
+    #if (defined(HAVE_ECC160) || defined(HAVE_ALL_CURVES)) && defined(ECC_WEAK_CURVES)
         #ifndef NO_ECC_SECP
             case WOLFSSL_ECC_SECP160R1:
                 pkOid = oid = ECC_SECP160R1_OID;
                 octets = 20;
                 break;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_SECPR2
             case WOLFSSL_ECC_SECP160R2:
                 pkOid = oid = ECC_SECP160R2_OID;
                 octets = 20;
                 break;
         #endif /* HAVE_ECC_SECPR2 */
         #ifdef HAVE_ECC_KOBLITZ
             case WOLFSSL_ECC_SECP160K1:
                 pkOid = oid = ECC_SECP160K1_OID;
                 octets = 20;
                 break;
         #endif /* HAVE_ECC_KOBLITZ */
-    #endif
-    #if defined(HAVE_ECC192) || defined(HAVE_ALL_CURVES)
+        #endif
+    #if (defined(HAVE_ECC192) || defined(HAVE_ALL_CURVES)) && defined(ECC_WEAK_CURVES)
         #ifndef NO_ECC_SECP
             case WOLFSSL_ECC_SECP192R1:
                 pkOid = oid = ECC_SECP192R1_OID;
                 octets = 24;
                 break;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_KOBLITZ
             case WOLFSSL_ECC_SECP192K1:
                 pkOid = oid = ECC_SECP192K1_OID;
                 octets = 24;
                 break;
         #endif /* HAVE_ECC_KOBLITZ */
     #endif
     #if defined(HAVE_ECC224) || defined(HAVE_ALL_CURVES)
         #ifndef NO_ECC_SECP
             case WOLFSSL_ECC_SECP224R1:
                 pkOid = oid = ECC_SECP224R1_OID;
                 octets = 28;
                 break;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_KOBLITZ
             case WOLFSSL_ECC_SECP224K1:
                 pkOid = oid = ECC_SECP224K1_OID;
                 octets = 28;
                 break;
         #endif /* HAVE_ECC_KOBLITZ */
     #endif
     #if !defined(NO_ECC256) || defined(HAVE_ALL_CURVES)
         #ifndef NO_ECC_SECP
             case WOLFSSL_ECC_SECP256R1:
                 pkOid = oid = ECC_SECP256R1_OID;
                 octets = 32;
                 break;
         #endif /* !NO_ECC_SECP */
     #endif /* !NO_ECC256 || HAVE_ALL_CURVES */
 #endif
         #if defined(HAVE_CURVE25519) || defined(HAVE_ED25519)
             case WOLFSSL_ECC_X25519:
                 oid = ECC_X25519_OID;
             #ifdef HAVE_ED25519
                 pkOid = ECC_ED25519_OID;
             #else
                 pkOid = ECC_X25519_OID;
             #endif
                 octets = 32;
                 break;
         #endif /* HAVE_CURVE25519 */
 #ifdef HAVE_ECC
     #if !defined(NO_ECC256) || defined(HAVE_ALL_CURVES)
         #ifdef HAVE_ECC_KOBLITZ
             case WOLFSSL_ECC_SECP256K1:
                 pkOid = oid = ECC_SECP256K1_OID;
                 octets = 32;
                 break;
         #endif /* HAVE_ECC_KOBLITZ */
         #ifdef HAVE_ECC_BRAINPOOL
             case WOLFSSL_ECC_BRAINPOOLP256R1:
                 pkOid = oid = ECC_BRAINPOOLP256R1_OID;
                 octets = 32;
                 break;
         #endif /* HAVE_ECC_BRAINPOOL */
     #endif
 #endif
         #if defined(HAVE_CURVE448) || defined(HAVE_ED448)
             case WOLFSSL_ECC_X448:
                 oid = ECC_X448_OID;
             #ifdef HAVE_ED448
                 pkOid = ECC_ED448_OID;
             #else
                 pkOid = ECC_X448_OID;
             #endif
                 octets = 57;
                 break;
         #endif /* HAVE_CURVE448 */
 #ifdef HAVE_ECC
     #if defined(HAVE_ECC384) || defined(HAVE_ALL_CURVES)
         #ifndef NO_ECC_SECP
             case WOLFSSL_ECC_SECP384R1:
                 pkOid = oid = ECC_SECP384R1_OID;
                 octets = 48;
                 break;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_BRAINPOOL
             case WOLFSSL_ECC_BRAINPOOLP384R1:
                 pkOid = oid = ECC_BRAINPOOLP384R1_OID;
                 octets = 48;
                 break;
         #endif /* HAVE_ECC_BRAINPOOL */
     #endif
     #if defined(HAVE_ECC512) || defined(HAVE_ALL_CURVES)
         #ifdef HAVE_ECC_BRAINPOOL
             case WOLFSSL_ECC_BRAINPOOLP512R1:
                 pkOid = oid = ECC_BRAINPOOLP512R1_OID;
                 octets = 64;
                 break;
         #endif /* HAVE_ECC_BRAINPOOL */
     #endif
     #if defined(HAVE_ECC521) || defined(HAVE_ALL_CURVES)
         #ifndef NO_ECC_SECP
             case WOLFSSL_ECC_SECP521R1:
                 pkOid = oid = ECC_SECP521R1_OID;
                 octets = 66;
                 break;
         #endif /* !NO_ECC_SECP */
     #endif
 #endif
             default: continue; /* unsupported curve */
         }
 
     #ifdef HAVE_ECC
         /* Set default Oid */
         if (defOid == 0 && ssl->eccTempKeySz <= octets && defSz > octets) {
             defOid = oid;
             defSz = octets;
         }
 
         /* The eccTempKeySz is the preferred ephemeral key size */
         if (currOid == 0 && ssl->eccTempKeySz == octets)
             currOid = oid;
         if ((nextOid == 0 || nextSz > octets) && ssl->eccTempKeySz <= octets) {
             nextOid = oid;
             nextSz  = octets;
         }
     #else
         if (defOid == 0 && defSz > octets) {
             defOid = oid;
             defSz = octets;
         }
 
         if (currOid == 0)
             currOid = oid;
         if (nextOid == 0 || nextSz > octets) {
             nextOid = oid;
             nextSz  = octets;
         }
     #endif
 
         if (first == ECC_BYTE) {
             switch (second) {
 #if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448)
                 /* ECDHE_ECDSA */
                 case TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:
                 case TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:
                 case TLS_ECDHE_ECDSA_WITH_RC4_128_SHA:
                 case TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:
                 case TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256:
                 case TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384:
                 case TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:
                 case TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:
                 case TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8:
                 case TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8:
                     sig |= ssl->pkCurveOID == pkOid;
                     key |= ssl->ecdhCurveOID == oid;
                     ephmSuite = 1;
                 break;
 
     #ifdef WOLFSSL_STATIC_DH
                 /* ECDH_ECDSA */
                 case TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA:
                 case TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA:
                 case TLS_ECDH_ECDSA_WITH_RC4_128_SHA:
                 case TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA:
                 case TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256:
                 case TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384:
                 case TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256:
                 case TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384:
                     if (oid == ECC_X25519_OID && defOid == oid) {
                         defOid = 0;
                         defSz = 80;
                     }
                     if (oid == ECC_X448_OID && defOid == oid) {
                         defOid = 0;
                         defSz = 80;
                     }
                     sig |= ssl->pkCurveOID == pkOid;
                     key |= ssl->pkCurveOID == oid;
                 break;
     #endif /* WOLFSSL_STATIC_DH */
 #endif /* HAVE_ECC || HAVE_ED25519 || HAVE_ED448 */
 #ifndef NO_RSA
                 /* ECDHE_RSA */
                 case TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:
                 case TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:
                 case TLS_ECDHE_RSA_WITH_RC4_128_SHA:
                 case TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:
                 case TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256:
                 case TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384:
                 case TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:
                 case TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:
                     sig = 1;
                     key |= ssl->ecdhCurveOID == oid;
                     ephmSuite = 1;
                 break;
 
     #ifdef WOLFSSL_STATIC_DH
                 /* ECDH_RSA */
                 case TLS_ECDH_RSA_WITH_AES_256_CBC_SHA:
                 case TLS_ECDH_RSA_WITH_AES_128_CBC_SHA:
                 case TLS_ECDH_RSA_WITH_RC4_128_SHA:
                 case TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA:
                 case TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256:
                 case TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384:
                 case TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256:
                 case TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384:
                     if (oid == ECC_X25519_OID && defOid == oid) {
                         defOid = 0;
                         defSz = 80;
                     }
                     if (oid == ECC_X448_OID && defOid == oid) {
                         defOid = 0;
                         defSz = 80;
                     }
                     sig = 1;
                     key |= ssl->pkCurveOID == pkOid;
                 break;
     #endif /* WOLFSSL_STATIC_DH */
 #endif
                 default:
                     if (oid == ECC_X25519_OID && defOid == oid) {
                         defOid = 0;
                         defSz = 80;
                     }
                     if (oid == ECC_X448_OID && defOid == oid) {
                         defOid = 0;
                         defSz = 80;
                     }
                     if (oid != ECC_X25519_OID && oid != ECC_X448_OID) {
                         sig = 1;
                     }
                     key = 1;
                 break;
             }
         }
 
         /* ChaCha20-Poly1305 ECC cipher suites */
         if (first == CHACHA_BYTE) {
             switch (second) {
 #if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448)
                 /* ECDHE_ECDSA */
                 case TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 :
                 case TLS_ECDHE_ECDSA_WITH_CHACHA20_OLD_POLY1305_SHA256 :
                     sig |= ssl->pkCurveOID == pkOid;
                     key |= ssl->ecdhCurveOID == oid;
                     ephmSuite = 1;
                 break;
 #endif /* HAVE_ECC || HAVE_ED25519 || HAVE_ED448 */
 #ifndef NO_RSA
                 /* ECDHE_RSA */
                 case TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 :
                 case TLS_ECDHE_RSA_WITH_CHACHA20_OLD_POLY1305_SHA256 :
                     sig = 1;
                     key |= ssl->ecdhCurveOID == oid;
                     ephmSuite = 1;
                 break;
 #endif
                 default:
                     sig = 1;
                     key = 1;
                 break;
             }
         }
     }
 
     /* Choose the default if it is at the required strength. */
 #ifdef HAVE_ECC
     if (ssl->ecdhCurveOID == 0 && defSz == ssl->eccTempKeySz)
 #else
     if (ssl->ecdhCurveOID == 0)
 #endif
     {
         key = 1;
         ssl->ecdhCurveOID = defOid;
     }
     /* Choose any curve at the required strength. */
     if (ssl->ecdhCurveOID == 0) {
         key = 1;
         ssl->ecdhCurveOID = currOid;
     }
     /* Choose the default if it is at the next highest strength. */
     if (ssl->ecdhCurveOID == 0 && defSz == nextSz)
         ssl->ecdhCurveOID = defOid;
     /* Choose any curve at the next highest strength. */
     if (ssl->ecdhCurveOID == 0)
         ssl->ecdhCurveOID = nextOid;
     /* No curve and ephemeral ECC suite requires a matching curve. */
     if (ssl->ecdhCurveOID == 0 && ephmSuite)
         key = 0;
 
     return sig && key;
 }
 #endif
 
 #endif /* NO_WOLFSSL_SERVER */
@@ -9823,192 +9823,192 @@ static byte* TLSX_QSHKeyFind_Pub(QSHKey* qsh, word16* pubLen, word16 name)
 /* Populates the default supported groups / curves */
 static int TLSX_PopulateSupportedGroups(WOLFSSL* ssl, TLSX** extensions)
 {
     int ret = WOLFSSL_SUCCESS;
 #ifdef WOLFSSL_TLS13
 #if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)
     if (ssl->options.resuming && ssl->session.namedGroup != 0) {
         return TLSX_UseSupportedCurve(extensions, ssl->session.namedGroup,
                                                                      ssl->heap);
     }
 #endif
 
 #ifdef HAVE_SUPPORTED_CURVES
     if (ssl->numGroups != 0) {
         int i;
         for (i = 0; i < ssl->numGroups; i++) {
             ret = TLSX_UseSupportedCurve(extensions, ssl->group[i], ssl->heap);
             if (ret != WOLFSSL_SUCCESS)
                 return ret;
         }
         return WOLFSSL_SUCCESS;
     }
 #endif /* HAVE_SUPPORTED_CURVES */
 #endif /* WOLFSSL_TLS13 */
 
 #if defined(HAVE_ECC) && defined(HAVE_SUPPORTED_CURVES)
         /* list in order by strength, since not all servers choose by strength */
         #if defined(HAVE_ECC521) || defined(HAVE_ALL_CURVES)
             #ifndef NO_ECC_SECP
                 ret = TLSX_UseSupportedCurve(extensions,
                                               WOLFSSL_ECC_SECP521R1, ssl->heap);
                 if (ret != WOLFSSL_SUCCESS) return ret;
             #endif
         #endif
         #if defined(HAVE_ECC512) || defined(HAVE_ALL_CURVES)
             #ifdef HAVE_ECC_BRAINPOOL
                 ret = TLSX_UseSupportedCurve(extensions,
                                         WOLFSSL_ECC_BRAINPOOLP512R1, ssl->heap);
                 if (ret != WOLFSSL_SUCCESS) return ret;
             #endif
         #endif
         #if defined(HAVE_ECC384) || defined(HAVE_ALL_CURVES)
             #ifndef NO_ECC_SECP
                 ret = TLSX_UseSupportedCurve(extensions,
                                               WOLFSSL_ECC_SECP384R1, ssl->heap);
                 if (ret != WOLFSSL_SUCCESS) return ret;
             #endif
             #ifdef HAVE_ECC_BRAINPOOL
                 ret = TLSX_UseSupportedCurve(extensions,
                                         WOLFSSL_ECC_BRAINPOOLP384R1, ssl->heap);
                 if (ret != WOLFSSL_SUCCESS) return ret;
             #endif
         #endif
 #endif /* HAVE_ECC && HAVE_SUPPORTED_CURVES */
 
         #ifndef HAVE_FIPS
             #if defined(HAVE_CURVE448)
                 ret = TLSX_UseSupportedCurve(extensions,
                                                    WOLFSSL_ECC_X448, ssl->heap);
                 if (ret != WOLFSSL_SUCCESS) return ret;
             #endif
         #endif /* HAVE_FIPS */
 
 #if defined(HAVE_ECC) && defined(HAVE_SUPPORTED_CURVES)
         #if !defined(NO_ECC256)  || defined(HAVE_ALL_CURVES)
             #ifndef NO_ECC_SECP
                 ret = TLSX_UseSupportedCurve(extensions,
                                               WOLFSSL_ECC_SECP256R1, ssl->heap);
                 if (ret != WOLFSSL_SUCCESS) return ret;
             #endif
             #ifdef HAVE_ECC_KOBLITZ
                 ret = TLSX_UseSupportedCurve(extensions,
                                               WOLFSSL_ECC_SECP256K1, ssl->heap);
                 if (ret != WOLFSSL_SUCCESS) return ret;
             #endif
             #ifdef HAVE_ECC_BRAINPOOL
                 ret = TLSX_UseSupportedCurve(extensions,
                                         WOLFSSL_ECC_BRAINPOOLP256R1, ssl->heap);
                 if (ret != WOLFSSL_SUCCESS) return ret;
             #endif
         #endif
 #endif /* HAVE_ECC && HAVE_SUPPORTED_CURVES */
 
         #ifndef HAVE_FIPS
             #if defined(HAVE_CURVE25519)
                 ret = TLSX_UseSupportedCurve(extensions,
                                                  WOLFSSL_ECC_X25519, ssl->heap);
                 if (ret != WOLFSSL_SUCCESS) return ret;
             #endif
         #endif /* HAVE_FIPS */
 
 #if defined(HAVE_ECC) && defined(HAVE_SUPPORTED_CURVES)
         #if defined(HAVE_ECC224) || defined(HAVE_ALL_CURVES)
             #ifndef NO_ECC_SECP
                 ret = TLSX_UseSupportedCurve(extensions,
                                               WOLFSSL_ECC_SECP224R1, ssl->heap);
                 if (ret != WOLFSSL_SUCCESS) return ret;
             #endif
             #ifdef HAVE_ECC_KOBLITZ
                 ret = TLSX_UseSupportedCurve(extensions,
                                               WOLFSSL_ECC_SECP224K1, ssl->heap);
                 if (ret != WOLFSSL_SUCCESS) return ret;
             #endif
         #endif
 
     #ifndef HAVE_FIPS
-        #if defined(HAVE_ECC192) || defined(HAVE_ALL_CURVES)
+        #if (defined(HAVE_ECC192) || defined(HAVE_ALL_CURVES)) && defined(ECC_WEAK_CURVES)
             #ifndef NO_ECC_SECP
                 ret = TLSX_UseSupportedCurve(extensions,
                                               WOLFSSL_ECC_SECP192R1, ssl->heap);
                 if (ret != WOLFSSL_SUCCESS) return ret;
             #endif
             #ifdef HAVE_ECC_KOBLITZ
                 ret = TLSX_UseSupportedCurve(extensions,
                                               WOLFSSL_ECC_SECP192K1, ssl->heap);
                 if (ret != WOLFSSL_SUCCESS) return ret;
             #endif
         #endif
-        #if defined(HAVE_ECC160) || defined(HAVE_ALL_CURVES)
+        #if (defined(HAVE_ECC160) || defined(HAVE_ALL_CURVES)) && defined(ECC_WEAK_CURVES)
             #ifndef NO_ECC_SECP
                 ret = TLSX_UseSupportedCurve(extensions,
                                               WOLFSSL_ECC_SECP160R1, ssl->heap);
                 if (ret != WOLFSSL_SUCCESS) return ret;
             #endif
             #ifdef HAVE_ECC_SECPR2
                 ret = TLSX_UseSupportedCurve(extensions,
                                               WOLFSSL_ECC_SECP160R2, ssl->heap);
                 if (ret != WOLFSSL_SUCCESS) return ret;
             #endif
             #ifdef HAVE_ECC_KOBLITZ
                 ret = TLSX_UseSupportedCurve(extensions,
                                               WOLFSSL_ECC_SECP160K1, ssl->heap);
                 if (ret != WOLFSSL_SUCCESS) return ret;
             #endif
         #endif
     #endif /* HAVE_FIPS */
 #endif /* HAVE_ECC && HAVE_SUPPORTED_CURVES */
 
-                /* Add FFDHE supported groups. */
+            /* Add FFDHE supported groups. */
         #ifdef HAVE_FFDHE_8192
             if (8192/8 >= ssl->options.minDhKeySz &&
                                             8192/8 <= ssl->options.maxDhKeySz) {
                 ret = TLSX_UseSupportedCurve(extensions,
                                              WOLFSSL_FFDHE_8192, ssl->heap);
                 if (ret != WOLFSSL_SUCCESS)
                     return ret;
             }
         #endif
         #ifdef HAVE_FFDHE_6144
             if (6144/8 >= ssl->options.minDhKeySz &&
                                             6144/8 <= ssl->options.maxDhKeySz) {
                 ret = TLSX_UseSupportedCurve(extensions,
                                              WOLFSSL_FFDHE_6144, ssl->heap);
                 if (ret != WOLFSSL_SUCCESS)
                     return ret;
             }
         #endif
         #ifdef HAVE_FFDHE_4096
             if (4096/8 >= ssl->options.minDhKeySz &&
                                             4096/8 <= ssl->options.maxDhKeySz) {
                 ret = TLSX_UseSupportedCurve(extensions,
                                              WOLFSSL_FFDHE_4096, ssl->heap);
                 if (ret != WOLFSSL_SUCCESS)
                     return ret;
             }
         #endif
         #ifdef HAVE_FFDHE_3072
             if (3072/8 >= ssl->options.minDhKeySz &&
                                             3072/8 <= ssl->options.maxDhKeySz) {
                 ret = TLSX_UseSupportedCurve(extensions,
                                              WOLFSSL_FFDHE_3072, ssl->heap);
                 if (ret != WOLFSSL_SUCCESS)
                     return ret;
             }
         #endif
         #ifdef HAVE_FFDHE_2048
             if (2048/8 >= ssl->options.minDhKeySz &&
                                             2048/8 <= ssl->options.maxDhKeySz) {
                 ret = TLSX_UseSupportedCurve(extensions,
                                              WOLFSSL_FFDHE_2048, ssl->heap);
                 if (ret != WOLFSSL_SUCCESS)
                     return ret;
             }
         #endif
 
     (void)ssl;
     (void)extensions;
 
     return ret;
 }
 
 #endif
diff --git a/wolfcrypt/src/ecc.c b/wolfcrypt/src/ecc.c
index 7cac4b1c2..f794043de 100644
--- a/wolfcrypt/src/ecc.c
+++ b/wolfcrypt/src/ecc.c
@@ -74,575 +74,576 @@ ECC Curve Types:
 /*
 ECC Curve Sizes:
  * ECC_USER_CURVES: Allows custom combination of key sizes below
  * HAVE_ALL_CURVES: Enable all key sizes (on unless ECC_USER_CURVES is defined)
+ * ECC_WEAK_CURVES: Enable support for weak keys < 224 bits
  * HAVE_ECC112: 112 bit key
  * HAVE_ECC128: 128 bit key
  * HAVE_ECC160: 160 bit key
  * HAVE_ECC192: 192 bit key
  * HAVE_ECC224: 224 bit key
  * HAVE_ECC239: 239 bit key
  * NO_ECC256: Disables 256 bit key (on by default)
  * HAVE_ECC320: 320 bit key
  * HAVE_ECC384: 384 bit key
  * HAVE_ECC512: 512 bit key
  * HAVE_ECC521: 521 bit key
  */
 
 
 #ifdef HAVE_ECC
 
 /* Make sure custom curves is enabled for Brainpool or Koblitz curve types */
 #if (defined(HAVE_ECC_BRAINPOOL) || defined(HAVE_ECC_KOBLITZ)) &&\
     !defined(WOLFSSL_CUSTOM_CURVES)
     #error Brainpool and Koblitz curves requires WOLFSSL_CUSTOM_CURVES
 #endif
 
 #if defined(HAVE_FIPS_VERSION) && (HAVE_FIPS_VERSION >= 2)
     /* set NO_WRAPPERS before headers, use direct internal f()s not wrappers */
     #define FIPS_NO_WRAPPERS
 
 	#ifdef USE_WINDOWS_API
 		#pragma code_seg(".fipsA$f")
 		#pragma const_seg(".fipsB$f")
 	#endif
 #endif
 
 #include <wolfssl/wolfcrypt/ecc.h>
 #include <wolfssl/wolfcrypt/asn.h>
 #include <wolfssl/wolfcrypt/error-crypt.h>
 #include <wolfssl/wolfcrypt/logging.h>
 #include <wolfssl/wolfcrypt/types.h>
 
 #ifdef WOLFSSL_HAVE_SP_ECC
 #include <wolfssl/wolfcrypt/sp.h>
 #endif
 
 #ifdef HAVE_ECC_ENCRYPT
     #include <wolfssl/wolfcrypt/hmac.h>
     #include <wolfssl/wolfcrypt/aes.h>
 #endif
 
 #ifdef HAVE_X963_KDF
     #include <wolfssl/wolfcrypt/hash.h>
 #endif
 
 #ifdef WOLF_CRYPTO_CB
     #include <wolfssl/wolfcrypt/cryptocb.h>
 #endif
 
 #ifdef NO_INLINE
     #include <wolfssl/wolfcrypt/misc.h>
 #else
     #define WOLFSSL_MISC_INCLUDED
     #include <wolfcrypt/src/misc.c>
 #endif
 
 #if defined(FREESCALE_LTC_ECC)
     #include <wolfssl/wolfcrypt/port/nxp/ksdk_port.h>
 #endif
 
 #if defined(WOLFSSL_STM32_PKA)
     #include <wolfssl/wolfcrypt/port/st/stm32.h>
 #endif
 
 #if defined(WOLFSSL_PSOC6_CRYPTO)
     #include <wolfssl/wolfcrypt/port/cypress/psoc6_crypto.h>
 #endif
 
 #ifdef WOLFSSL_SP_MATH
     #define GEN_MEM_ERR MP_MEM
 #elif defined(USE_FAST_MATH)
     #define GEN_MEM_ERR FP_MEM
 #else
     #define GEN_MEM_ERR MP_MEM
 #endif
 
 
 /* internal ECC states */
 enum {
     ECC_STATE_NONE = 0,
 
     ECC_STATE_SHARED_SEC_GEN,
     ECC_STATE_SHARED_SEC_RES,
 
     ECC_STATE_SIGN_DO,
     ECC_STATE_SIGN_ENCODE,
 
     ECC_STATE_VERIFY_DECODE,
     ECC_STATE_VERIFY_DO,
     ECC_STATE_VERIFY_RES,
 };
 
 
 /* map
    ptmul -> mulmod
 */
 
 /* 256-bit curve on by default whether user curves or not */
-#if defined(HAVE_ECC112) || defined(HAVE_ALL_CURVES)
+#if (defined(HAVE_ECC112) || defined(HAVE_ALL_CURVES)) && defined(ECC_WEAK_CURVES)
     #define ECC112
 #endif
-#if defined(HAVE_ECC128) || defined(HAVE_ALL_CURVES)
+#if (defined(HAVE_ECC128) || defined(HAVE_ALL_CURVES)) && defined(ECC_WEAK_CURVES)
     #define ECC128
 #endif
-#if defined(HAVE_ECC160) || defined(HAVE_ALL_CURVES)
+#if (defined(HAVE_ECC160) || defined(HAVE_ALL_CURVES)) && defined(ECC_WEAK_CURVES)
     #define ECC160
 #endif
-#if defined(HAVE_ECC192) || defined(HAVE_ALL_CURVES)
+#if (defined(HAVE_ECC192) || defined(HAVE_ALL_CURVES)) && defined(ECC_WEAK_CURVES)
     #define ECC192
 #endif
 #if defined(HAVE_ECC224) || defined(HAVE_ALL_CURVES)
     #define ECC224
 #endif
 #if defined(HAVE_ECC239) || defined(HAVE_ALL_CURVES)
     #define ECC239
 #endif
 #if !defined(NO_ECC256)  || defined(HAVE_ALL_CURVES)
     #define ECC256
 #endif
 #if defined(HAVE_ECC320) || defined(HAVE_ALL_CURVES)
     #define ECC320
 #endif
 #if defined(HAVE_ECC384) || defined(HAVE_ALL_CURVES)
     #define ECC384
 #endif
 #if defined(HAVE_ECC512) || defined(HAVE_ALL_CURVES)
     #define ECC512
 #endif
 #if defined(HAVE_ECC521) || defined(HAVE_ALL_CURVES)
     #define ECC521
 #endif
 
 /* The encoded OID's for ECC curves */
 #ifdef ECC112
     #ifndef NO_ECC_SECP
         #ifdef HAVE_OID_ENCODING
             #define CODED_SECP112R1    {1,3,132,0,6}
             #define CODED_SECP112R1_SZ 5
         #else
             #define CODED_SECP112R1    {0x2B,0x81,0x04,0x00,0x06}
             #define CODED_SECP112R1_SZ 5
         #endif
         #ifndef WOLFSSL_ECC_CURVE_STATIC
             static const ecc_oid_t ecc_oid_secp112r1[] = CODED_SECP112R1;
         #else
             #define ecc_oid_secp112r1 CODED_SECP112R1
         #endif
         #define ecc_oid_secp112r1_sz CODED_SECP112R1_SZ
     #endif /* !NO_ECC_SECP */
     #ifdef HAVE_ECC_SECPR2
         #ifdef HAVE_OID_ENCODING
             #define CODED_SECP112R2    {1,3,132,0,7}
             #define CODED_SECP112R2_SZ 5
         #else
             #define CODED_SECP112R2    {0x2B,0x81,0x04,0x00,0x07}
             #define CODED_SECP112R2_SZ 5
         #endif
         #ifndef WOLFSSL_ECC_CURVE_STATIC
             static const ecc_oid_t ecc_oid_secp112r2[] = CODED_SECP112R2;
         #else
             #define ecc_oid_secp112r2 CODED_SECP112R2
         #endif
         #define ecc_oid_secp112r2_sz CODED_SECP112R2_SZ
     #endif /* HAVE_ECC_SECPR2 */
 #endif /* ECC112 */
 #ifdef ECC128
     #ifndef NO_ECC_SECP
         #ifdef HAVE_OID_ENCODING
             #define CODED_SECP128R1    {1,3,132,0,28}
             #define CODED_SECP128R1_SZ 5
         #else
             #define CODED_SECP128R1    {0x2B,0x81,0x04,0x00,0x1C}
             #define CODED_SECP128R1_SZ 5
         #endif
         #ifndef WOLFSSL_ECC_CURVE_STATIC
             static const ecc_oid_t ecc_oid_secp128r1[] = CODED_SECP128R1;
         #else
             #define ecc_oid_secp128r1 CODED_SECP128R1
         #endif
         #define ecc_oid_secp128r1_sz CODED_SECP128R1_SZ
     #endif /* !NO_ECC_SECP */
     #ifdef HAVE_ECC_SECPR2
         #ifdef HAVE_OID_ENCODING
             #define CODED_SECP128R2    {1,3,132,0,29}
             #define CODED_SECP128R2_SZ 5
         #else
             #define CODED_SECP128R2    {0x2B,0x81,0x04,0x00,0x1D}
             #define CODED_SECP128R2_SZ 5
         #endif
         #ifndef WOLFSSL_ECC_CURVE_STATIC
             static const ecc_oid_t ecc_oid_secp128r2[] = CODED_SECP128R2;
         #else
             #define ecc_oid_secp128r2 CODED_SECP128R2
         #endif
         #define ecc_oid_secp128r2_sz CODED_SECP128R2_SZ
     #endif /* HAVE_ECC_SECPR2 */
 #endif /* ECC128 */
 #ifdef ECC160
     #ifndef NO_ECC_SECP
         #ifdef HAVE_OID_ENCODING
             #define CODED_SECP160R1    {1,3,132,0,8}
             #define CODED_SECP160R1_SZ 5
         #else
             #define CODED_SECP160R1    {0x2B,0x81,0x04,0x00,0x08}
             #define CODED_SECP160R1_SZ 5
         #endif
         #ifndef WOLFSSL_ECC_CURVE_STATIC
             static const ecc_oid_t ecc_oid_secp160r1[] = CODED_SECP160R1;
         #else
             #define ecc_oid_secp160r1 CODED_SECP160R1
         #endif
         #define ecc_oid_secp160r1_sz CODED_SECP160R1_SZ
     #endif /* !NO_ECC_SECP */
     #ifdef HAVE_ECC_SECPR2
         #ifdef HAVE_OID_ENCODING
             #define CODED_SECP160R2    {1,3,132,0,30}
             #define CODED_SECP160R2_SZ 5
         #else
             #define CODED_SECP160R2    {0x2B,0x81,0x04,0x00,0x1E}
             #define CODED_SECP160R2_SZ 5
         #endif
         #ifndef WOLFSSL_ECC_CURVE_STATIC
             static const ecc_oid_t ecc_oid_secp160r2[] = CODED_SECP160R2;
         #else
             #define ecc_oid_secp160r2 CODED_SECP160R2
         #endif
         #define ecc_oid_secp160r2_sz CODED_SECP160R2_SZ
     #endif /* HAVE_ECC_SECPR2 */
     #ifdef HAVE_ECC_KOBLITZ
         #ifdef HAVE_OID_ENCODING
             #define CODED_SECP160K1    {1,3,132,0,9}
             #define CODED_SECP160K1_SZ 5
         #else
             #define CODED_SECP160K1    {0x2B,0x81,0x04,0x00,0x09}
             #define CODED_SECP160K1_SZ 5
         #endif
         #ifndef WOLFSSL_ECC_CURVE_STATIC
             static const ecc_oid_t ecc_oid_secp160k1[] = CODED_SECP160K1;
         #else
             #define ecc_oid_secp160k1 CODED_SECP160K1
         #endif
         #define ecc_oid_secp160k1_sz CODED_SECP160K1_SZ
     #endif /* HAVE_ECC_KOBLITZ */
     #ifdef HAVE_ECC_BRAINPOOL
         #ifdef HAVE_OID_ENCODING
             #define CODED_BRAINPOOLP160R1    {1,3,36,3,3,2,8,1,1,1}
             #define CODED_BRAINPOOLP160R1_SZ 10
         #else
             #define CODED_BRAINPOOLP160R1    {0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x01}
             #define CODED_BRAINPOOLP160R1_SZ 9
         #endif
         #ifndef WOLFSSL_ECC_CURVE_STATIC
             static const ecc_oid_t ecc_oid_brainpoolp160r1[] = CODED_BRAINPOOLP160R1;
         #else
             #define ecc_oid_brainpoolp160r1 CODED_BRAINPOOLP160R1
         #endif
         #define ecc_oid_brainpoolp160r1_sz CODED_BRAINPOOLP160R1_SZ
     #endif /* HAVE_ECC_BRAINPOOL */
 #endif /* ECC160 */
 #ifdef ECC192
     #ifndef NO_ECC_SECP
         #ifdef HAVE_OID_ENCODING
             #define CODED_SECP192R1    {1,2,840,10045,3,1,1}
             #define CODED_SECP192R1_SZ 7
         #else
             #define CODED_SECP192R1    {0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x01}
             #define CODED_SECP192R1_SZ 8
         #endif
         #ifndef WOLFSSL_ECC_CURVE_STATIC
             static const ecc_oid_t ecc_oid_secp192r1[] = CODED_SECP192R1;
         #else
             #define ecc_oid_secp192r1 CODED_SECP192R1
         #endif
         #define ecc_oid_secp192r1_sz CODED_SECP192R1_SZ
     #endif /* !NO_ECC_SECP */
     #ifdef HAVE_ECC_SECPR2
         #ifdef HAVE_OID_ENCODING
             #define CODED_PRIME192V2    {1,2,840,10045,3,1,2}
             #define CODED_PRIME192V2_SZ 7
         #else
             #define CODED_PRIME192V2    {0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x02}
             #define CODED_PRIME192V2_SZ 8
         #endif
         #ifndef WOLFSSL_ECC_CURVE_STATIC
             static const ecc_oid_t ecc_oid_prime192v2[] = CODED_PRIME192V2;
         #else
             #define ecc_oid_prime192v2 CODED_PRIME192V2
         #endif
         #define ecc_oid_prime192v2_sz CODED_PRIME192V2_SZ
     #endif /* HAVE_ECC_SECPR2 */
     #ifdef HAVE_ECC_SECPR3
         #ifdef HAVE_OID_ENCODING
             #define CODED_PRIME192V3    {1,2,840,10045,3,1,3}
             #define CODED_PRIME192V3_SZ 7
         #else
             #define CODED_PRIME192V3    {0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x03}
             #define CODED_PRIME192V3_SZ 8
         #endif
         #ifndef WOLFSSL_ECC_CURVE_STATIC
             static const ecc_oid_t ecc_oid_prime192v3[] = CODED_PRIME192V3;
         #else
             #define ecc_oid_prime192v3 CODED_PRIME192V3
         #endif
         #define ecc_oid_prime192v3_sz CODED_PRIME192V3_SZ
     #endif /* HAVE_ECC_SECPR3 */
     #ifdef HAVE_ECC_KOBLITZ
         #ifdef HAVE_OID_ENCODING
             #define CODED_SECP192K1    {1,3,132,0,31}
             #define CODED_SECP192K1_SZ 5
         #else
             #define CODED_SECP192K1    {0x2B,0x81,0x04,0x00,0x1F}
             #define CODED_SECP192K1_SZ 5
         #endif
         #ifndef WOLFSSL_ECC_CURVE_STATIC
             static const ecc_oid_t ecc_oid_secp192k1[] = CODED_SECP192K1;
         #else
             #define ecc_oid_secp192k1 CODED_SECP192K1
         #endif
         #define ecc_oid_secp192k1_sz CODED_SECP192K1_SZ
     #endif /* HAVE_ECC_KOBLITZ */
     #ifdef HAVE_ECC_BRAINPOOL
         #ifdef HAVE_OID_ENCODING
             #define CODED_BRAINPOOLP192R1    {1,3,36,3,3,2,8,1,1,3}
             #define CODED_BRAINPOOLP192R1_SZ 10
         #else
             #define CODED_BRAINPOOLP192R1    {0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x03}
             #define CODED_BRAINPOOLP192R1_SZ 9
         #endif
         #ifndef WOLFSSL_ECC_CURVE_STATIC
             static const ecc_oid_t ecc_oid_brainpoolp192r1[] = CODED_BRAINPOOLP192R1;
         #else
             #define ecc_oid_brainpoolp192r1 CODED_BRAINPOOLP192R1
         #endif
         #define ecc_oid_brainpoolp192r1_sz CODED_BRAINPOOLP192R1_SZ
     #endif /* HAVE_ECC_BRAINPOOL */
 #endif /* ECC192 */
 #ifdef ECC224
     #ifndef NO_ECC_SECP
         #ifdef HAVE_OID_ENCODING
             #define CODED_SECP224R1    {1,3,132,0,33}
             #define CODED_SECP224R1_SZ 5
         #else
             #define CODED_SECP224R1    {0x2B,0x81,0x04,0x00,0x21}
             #define CODED_SECP224R1_SZ 5
         #endif
         #ifndef WOLFSSL_ECC_CURVE_STATIC
             static const ecc_oid_t ecc_oid_secp224r1[] = CODED_SECP224R1;
         #else
             #define ecc_oid_secp224r1 CODED_SECP224R1
         #endif
         #define ecc_oid_secp224r1_sz CODED_SECP224R1_SZ
     #endif /* !NO_ECC_SECP */
     #ifdef HAVE_ECC_KOBLITZ
         #ifdef HAVE_OID_ENCODING
             #define CODED_SECP224K1    {1,3,132,0,32}
             #define CODED_SECP224K1_SZ 5
         #else
             #define CODED_SECP224K1    {0x2B,0x81,0x04,0x00,0x20}
             #define CODED_SECP224K1_SZ 5
         #endif
         #ifndef WOLFSSL_ECC_CURVE_STATIC
             static const ecc_oid_t ecc_oid_secp224k1[] = CODED_SECP224K1;
         #else
             #define ecc_oid_secp224k1 CODED_SECP224K1
         #endif
         #define ecc_oid_secp224k1_sz CODED_SECP224K1_SZ
     #endif /* HAVE_ECC_KOBLITZ */
     #ifdef HAVE_ECC_BRAINPOOL
         #ifdef HAVE_OID_ENCODING
             #define CODED_BRAINPOOLP224R1    {1,3,36,3,3,2,8,1,1,5}
             #define CODED_BRAINPOOLP224R1_SZ 10
         #else
             #define CODED_BRAINPOOLP224R1    {0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x05}
             #define CODED_BRAINPOOLP224R1_SZ 9
         #endif
         #ifndef WOLFSSL_ECC_CURVE_STATIC
             static const ecc_oid_t ecc_oid_brainpoolp224r1[] = CODED_BRAINPOOLP224R1;
         #else
             #define ecc_oid_brainpoolp224r1 CODED_BRAINPOOLP224R1
         #endif
         #define ecc_oid_brainpoolp224r1_sz CODED_BRAINPOOLP224R1_SZ
     #endif /* HAVE_ECC_BRAINPOOL */
 #endif /* ECC224 */
 #ifdef ECC239
     #ifndef NO_ECC_SECP
         #ifdef HAVE_OID_ENCODING
             #define CODED_PRIME239V1    {1,2,840,10045,3,1,4}
             #define CODED_PRIME239V1_SZ 7
         #else
             #define CODED_PRIME239V1    {0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x04}
             #define CODED_PRIME239V1_SZ 8
         #endif
         #ifndef WOLFSSL_ECC_CURVE_STATIC
             static const ecc_oid_t ecc_oid_prime239v1[] = CODED_PRIME239V1;
         #else
             #define ecc_oid_prime239v1 CODED_PRIME239V1
         #endif
         #define ecc_oid_prime239v1_sz CODED_PRIME239V1_SZ
     #endif /* !NO_ECC_SECP */
     #ifdef HAVE_ECC_SECPR2
         #ifdef HAVE_OID_ENCODING
             #define CODED_PRIME239V2    {1,2,840,10045,3,1,5}
             #define CODED_PRIME239V2_SZ 7
         #else
             #define CODED_PRIME239V2    {0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x05}
             #define CODED_PRIME239V2_SZ 8
         #endif
         #ifndef WOLFSSL_ECC_CURVE_STATIC
             static const ecc_oid_t ecc_oid_prime239v2[] = CODED_PRIME239V2;
         #else
             #define ecc_oid_prime239v2 CODED_PRIME239V2
         #endif
         #define ecc_oid_prime239v2_sz CODED_PRIME239V2_SZ
     #endif /* HAVE_ECC_SECPR2 */
     #ifdef HAVE_ECC_SECPR3
         #ifdef HAVE_OID_ENCODING
             #define CODED_PRIME239V3    {1,2,840,10045,3,1,6}
             #define CODED_PRIME239V3_SZ 7
         #else
             #define CODED_PRIME239V3    {0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x06}
             #define CODED_PRIME239V3_SZ 8
         #endif
         #ifndef WOLFSSL_ECC_CURVE_STATIC
             static const ecc_oid_t ecc_oid_prime239v3[] = CODED_PRIME239V3;
         #else
             #define ecc_oid_prime239v3 CODED_PRIME239V3
         #endif
         #define ecc_oid_prime239v3_sz CODED_PRIME239V3_SZ
     #endif /* HAVE_ECC_SECPR3 */
 #endif /* ECC239 */
 #ifdef ECC256
     #ifndef NO_ECC_SECP
         #ifdef HAVE_OID_ENCODING
             #define CODED_SECP256R1    {1,2,840,10045,3,1,7}
             #define CODED_SECP256R1_SZ 7
         #else
             #define CODED_SECP256R1    {0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x07}
             #define CODED_SECP256R1_SZ 8
         #endif
         #ifndef WOLFSSL_ECC_CURVE_STATIC
             static const ecc_oid_t ecc_oid_secp256r1[] = CODED_SECP256R1;
         #else
             #define ecc_oid_secp256r1 CODED_SECP256R1
         #endif
         #define ecc_oid_secp256r1_sz CODED_SECP256R1_SZ
     #endif /* !NO_ECC_SECP */
     #ifdef HAVE_ECC_KOBLITZ
         #ifdef HAVE_OID_ENCODING
             #define CODED_SECP256K1    {1,3,132,0,10}
             #define CODED_SECP256K1_SZ 5
         #else
             #define CODED_SECP256K1    {0x2B,0x81,0x04,0x00,0x0A}
             #define CODED_SECP256K1_SZ 5
         #endif
         #ifndef WOLFSSL_ECC_CURVE_STATIC
             static const ecc_oid_t ecc_oid_secp256k1[] = CODED_SECP256K1;
         #else
             #define ecc_oid_secp256k1 CODED_SECP256K1
         #endif
         #define ecc_oid_secp256k1_sz CODED_SECP256K1_SZ
     #endif /* HAVE_ECC_KOBLITZ */
     #ifdef HAVE_ECC_BRAINPOOL
         #ifdef HAVE_OID_ENCODING
             #define CODED_BRAINPOOLP256R1    {1,3,36,3,3,2,8,1,1,7}
             #define CODED_BRAINPOOLP256R1_SZ 10
         #else
             #define CODED_BRAINPOOLP256R1    {0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x07}
             #define CODED_BRAINPOOLP256R1_SZ 9
         #endif
         #ifndef WOLFSSL_ECC_CURVE_STATIC
             static const ecc_oid_t ecc_oid_brainpoolp256r1[] = CODED_BRAINPOOLP256R1;
         #else
             #define ecc_oid_brainpoolp256r1 CODED_BRAINPOOLP256R1
         #endif
         #define ecc_oid_brainpoolp256r1_sz CODED_BRAINPOOLP256R1_SZ
     #endif /* HAVE_ECC_BRAINPOOL */
 #endif /* ECC256 */
 #ifdef ECC320
     #ifdef HAVE_ECC_BRAINPOOL
         #ifdef HAVE_OID_ENCODING
             #define CODED_BRAINPOOLP320R1    {1,3,36,3,3,2,8,1,1,9}
             #define CODED_BRAINPOOLP320R1_SZ 10
         #else
             #define CODED_BRAINPOOLP320R1    {0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x09}
             #define CODED_BRAINPOOLP320R1_SZ 9
         #endif
         #ifndef WOLFSSL_ECC_CURVE_STATIC
             static const ecc_oid_t ecc_oid_brainpoolp320r1[] = CODED_BRAINPOOLP320R1;
         #else
             #define ecc_oid_brainpoolp320r1 CODED_BRAINPOOLP320R1
         #endif
         #define ecc_oid_brainpoolp320r1_sz CODED_BRAINPOOLP320R1_SZ
     #endif /* HAVE_ECC_BRAINPOOL */
 #endif /* ECC320 */
 #ifdef ECC384
     #ifndef NO_ECC_SECP
         #ifdef HAVE_OID_ENCODING
             #define CODED_SECP384R1    {1,3,132,0,34}
             #define CODED_SECP384R1_SZ 5
         #else
             #define CODED_SECP384R1    {0x2B,0x81,0x04,0x00,0x22}
             #define CODED_SECP384R1_SZ 5
         #endif
         #ifndef WOLFSSL_ECC_CURVE_STATIC
             static const ecc_oid_t ecc_oid_secp384r1[] = CODED_SECP384R1;
             #define CODED_SECP384R1_OID ecc_oid_secp384r1
         #else
 			#define ecc_oid_secp384r1 CODED_SECP384R1
         #endif
         #define ecc_oid_secp384r1_sz CODED_SECP384R1_SZ
     #endif /* !NO_ECC_SECP */
     #ifdef HAVE_ECC_BRAINPOOL
         #ifdef HAVE_OID_ENCODING
             #define CODED_BRAINPOOLP384R1    {1,3,36,3,3,2,8,1,1,11}
             #define CODED_BRAINPOOLP384R1_SZ 10
         #else
             #define CODED_BRAINPOOLP384R1    {0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x0B}
             #define CODED_BRAINPOOLP384R1_SZ 9
         #endif
         #ifndef WOLFSSL_ECC_CURVE_STATIC
             static const ecc_oid_t ecc_oid_brainpoolp384r1[] = CODED_BRAINPOOLP384R1;
         #else
             #define ecc_oid_brainpoolp384r1 CODED_BRAINPOOLP384R1
         #endif
         #define ecc_oid_brainpoolp384r1_sz CODED_BRAINPOOLP384R1_SZ
     #endif /* HAVE_ECC_BRAINPOOL */
 #endif /* ECC384 */
 #ifdef ECC512
     #ifdef HAVE_ECC_BRAINPOOL
         #ifdef HAVE_OID_ENCODING
             #define CODED_BRAINPOOLP512R1    {1,3,36,3,3,2,8,1,1,13}
             #define CODED_BRAINPOOLP512R1_SZ 10
         #else
             #define CODED_BRAINPOOLP512R1    {0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x0D}
             #define CODED_BRAINPOOLP512R1_SZ 9
         #endif
         #ifndef WOLFSSL_ECC_CURVE_STATIC
             static const ecc_oid_t ecc_oid_brainpoolp512r1[] = CODED_BRAINPOOLP512R1;
         #else
             #define ecc_oid_brainpoolp512r1 CODED_BRAINPOOLP512R1
         #endif
         #define ecc_oid_brainpoolp512r1_sz CODED_BRAINPOOLP512R1_SZ
     #endif /* HAVE_ECC_BRAINPOOL */
 #endif /* ECC512 */
 #ifdef ECC521
     #ifndef NO_ECC_SECP
         #ifdef HAVE_OID_ENCODING
             #define CODED_SECP521R1     {1,3,132,0,35}
             #define CODED_SECP521R1_SZ 5
         #else
             #define CODED_SECP521R1     {0x2B,0x81,0x04,0x00,0x23}
             #define CODED_SECP521R1_SZ 5
         #endif
         #ifndef WOLFSSL_ECC_CURVE_STATIC
             static const ecc_oid_t ecc_oid_secp521r1[] = CODED_SECP521R1;
         #else
             #define ecc_oid_secp521r1 CODED_SECP521R1
         #endif
         #define ecc_oid_secp521r1_sz CODED_SECP521R1_SZ
     #endif /* !NO_ECC_SECP */
 #endif /* ECC521 */
 
 
 /* This holds the key settings.
    ***MUST*** be organized by size from smallest to largest. */
diff --git a/wolfssl/wolfcrypt/ecc.h b/wolfssl/wolfcrypt/ecc.h
index 3c7458931..ec1587d66 100644
--- a/wolfssl/wolfcrypt/ecc.h
+++ b/wolfssl/wolfcrypt/ecc.h
@@ -1,119 +1,119 @@
 /* ecc.h
  *
  * Copyright (C) 2006-2020 wolfSSL Inc.
  *
  * This file is part of wolfSSL.
  *
  * wolfSSL is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
  * wolfSSL is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA
  */
 
 /*!
     \file wolfssl/wolfcrypt/ecc.h
 */
 
 
 #ifndef WOLF_CRYPT_ECC_H
 #define WOLF_CRYPT_ECC_H
 
 #include <wolfssl/wolfcrypt/types.h>
 
 #ifdef HAVE_ECC
 
 #if defined(HAVE_FIPS) && \
     defined(HAVE_FIPS_VERSION) && (HAVE_FIPS_VERSION >= 2)
     #include <wolfssl/wolfcrypt/fips.h>
 #endif /* HAVE_FIPS_VERSION >= 2 */
 
 #include <wolfssl/wolfcrypt/integer.h>
 #include <wolfssl/wolfcrypt/random.h>
 
 #ifdef HAVE_X963_KDF
     #include <wolfssl/wolfcrypt/hash.h>
 #endif
 
 #ifdef WOLFSSL_ASYNC_CRYPT
     #include <wolfssl/wolfcrypt/async.h>
     #ifdef WOLFSSL_CERT_GEN
         #include <wolfssl/wolfcrypt/asn.h>
     #endif
 #endif
 
 #if defined(WOLFSSL_ATECC508A) || defined(WOLFSSL_ATECC608A)
     #include <wolfssl/wolfcrypt/port/atmel/atmel.h>
 #endif /* WOLFSSL_ATECC508A */
 
 #if defined(WOLFSSL_CRYPTOCELL)
     #include <wolfssl/wolfcrypt/port/arm/cryptoCell.h>
 #endif
 
 #ifdef WOLFSSL_HAVE_SP_ECC
     #include <wolfssl/wolfcrypt/sp_int.h>
 #endif
 
 
 #ifdef __cplusplus
     extern "C" {
 #endif
 
 
 /* Enable curve B parameter if needed */
 #if defined(HAVE_COMP_KEY) || defined(ECC_CACHE_CURVE)
     #ifndef USE_ECC_B_PARAM /* Allow someone to force enable */
         #define USE_ECC_B_PARAM
     #endif
 #endif
 
 
 /* Use this as the key->idx if a custom ecc_set is used for key->dp */
 #define ECC_CUSTOM_IDX    (-1)
 
 
 /* Determine max ECC bits based on enabled curves */
 #if defined(HAVE_ECC521) || defined(HAVE_ALL_CURVES)
     #define MAX_ECC_BITS    521
 #elif defined(HAVE_ECC512)
     #define MAX_ECC_BITS    512
 #elif defined(HAVE_ECC384)
     #define MAX_ECC_BITS    384
 #elif defined(HAVE_ECC320)
     #define MAX_ECC_BITS    320
 #elif !defined(NO_ECC256)
     #define MAX_ECC_BITS    256
 #elif defined(HAVE_ECC239)
     #define MAX_ECC_BITS    239
-#elif defined(HAVE_ECC224)
+#elif defined(HAVE_ECC224) && !defined(ECC_WEAK_CURVES)
     #define MAX_ECC_BITS    224
 #elif defined(HAVE_ECC192)
     #define MAX_ECC_BITS    192
 #elif defined(HAVE_ECC160)
     #define MAX_ECC_BITS    160
 #elif defined(HAVE_ECC128)
     #define MAX_ECC_BITS    128
 #elif defined(HAVE_ECC112)
     #define MAX_ECC_BITS    112
 #endif
 
 /* calculate max ECC bytes */
 #if ((MAX_ECC_BITS * 2) % 8) == 0
     #define MAX_ECC_BYTES     (MAX_ECC_BITS / 8)
 #else
     /* add byte if not aligned */
     #define MAX_ECC_BYTES     ((MAX_ECC_BITS / 8) + 1)
 #endif
 
 #ifndef ECC_MAX_PAD_SZ
     /* ECC maximum padding size (when MSB is set extra byte required for R and S) */
     #define ECC_MAX_PAD_SZ 2
 #endif
diff --git a/wolfssl/wolfcrypt/settings.h b/wolfssl/wolfcrypt/settings.h
index ad6204f2c..c3f285883 100644
--- a/wolfssl/wolfcrypt/settings.h
+++ b/wolfssl/wolfcrypt/settings.h
@@ -656,1707 +656,1714 @@ extern void *uITRON4_realloc(void *p, size_t sz) ;
 extern void uITRON4_free(void *p) ;
 
 #define XMALLOC(sz, heap, type)     uITRON4_malloc(sz)
 #define XREALLOC(p, sz, heap, type) uITRON4_realloc(p, sz)
 #define XFREE(p, heap, type)        uITRON4_free(p)
 #endif
 
 #if defined(WOLFSSL_uTKERNEL2)
   #ifndef NO_TKERNEL_MEM_POOL
     #define XMALLOC_OVERRIDE
     int   uTKernel_init_mpool(unsigned int sz); /* initializing malloc pool */
     void* uTKernel_malloc(unsigned int sz);
     void* uTKernel_realloc(void *p, unsigned int sz);
     void  uTKernel_free(void *p);
     #define XMALLOC(s, h, type)  uTKernel_malloc((s))
     #define XREALLOC(p, n, h, t) uTKernel_realloc((p), (n))
     #define XFREE(p, h, type)    uTKernel_free((p))
   #endif
 
   #ifndef NO_STDIO_FGETS_REMAP
     #include <stdio.h>
     #include "tm/tmonitor.h"
 
     /* static char* gets(char *buff); */
     static char* fgets(char *buff, int sz, XFILE fp) {
         char * p = buff;
         *p = '\0';
         while (1) {
             *p = tm_getchar(-1);
             tm_putchar(*p);
             if (*p == '\r') {
                 tm_putchar('\n');
                 *p = '\0';
                 break;
             }
             p++;
         }
         return buff;
     }
   #endif /* !NO_STDIO_FGETS_REMAP */
 #endif
 
 
 #if defined(WOLFSSL_LEANPSK) && !defined(XMALLOC_USER) && \
         !defined(NO_WOLFSSL_MEMORY)
     #include <stdlib.h>
     #define XMALLOC(s, h, type)  malloc((s))
     #define XFREE(p, h, type)    free((p))
     #define XREALLOC(p, n, h, t) realloc((p), (n))
 #endif
 
 #if defined(XMALLOC_USER) && defined(SSN_BUILDING_LIBYASSL)
     #undef  XMALLOC
     #define XMALLOC     yaXMALLOC
     #undef  XFREE
     #define XFREE       yaXFREE
     #undef  XREALLOC
     #define XREALLOC    yaXREALLOC
 #endif
 
 
 #ifdef FREERTOS
     #include "FreeRTOS.h"
 
     #if !defined(XMALLOC_USER) && !defined(NO_WOLFSSL_MEMORY) && \
         !defined(WOLFSSL_STATIC_MEMORY)
         #define XMALLOC(s, h, type)  pvPortMalloc((s))
         #define XFREE(p, h, type)    vPortFree((p))
     #endif
     /* FreeRTOS pvPortRealloc() implementation can be found here:
         https://github.com/wolfSSL/wolfssl-freertos/pull/3/files */
     #if !defined(USE_FAST_MATH) || defined(HAVE_ED25519) || defined(HAVE_ED448)
         #if defined(WOLFSSL_ESPIDF)
             /*In IDF, realloc(p, n) is equivalent to
             heap_caps_realloc(p, s, MALLOC_CAP_8BIT) */
             #define XREALLOC(p, n, h, t) realloc((p), (n))
         #else
             #define XREALLOC(p, n, h, t) pvPortRealloc((p), (n))
         #endif
     #endif
     #ifndef NO_WRITEV
         #define NO_WRITEV
     #endif
     #ifndef HAVE_SHA512
         #ifndef NO_SHA512
             #define NO_SHA512
         #endif
     #endif
     #ifndef HAVE_DH
         #ifndef NO_DH
             #define NO_DH
         #endif
     #endif
     #ifndef NO_DSA
         #define NO_DSA
     #endif
     #ifndef NO_HC128
         #define NO_HC128
     #endif
 
     #ifndef SINGLE_THREADED
         #include "semphr.h"
     #endif
 #endif
 
 #ifdef FREERTOS_TCP
     #if !defined(NO_WOLFSSL_MEMORY) && !defined(XMALLOC_USER) && \
         !defined(WOLFSSL_STATIC_MEMORY)
         #define XMALLOC(s, h, type)  pvPortMalloc((s))
         #define XFREE(p, h, type)    vPortFree((p))
     #endif
 
     #define WOLFSSL_GENSEED_FORTEST
 
     #define NO_WOLFSSL_DIR
     #define NO_WRITEV
     #define USE_FAST_MATH
     #define TFM_TIMING_RESISTANT
     #define NO_MAIN_DRIVER
 #endif
 
 #ifdef WOLFSSL_TIRTOS
     #define SIZEOF_LONG_LONG 8
     #define NO_WRITEV
     #define NO_WOLFSSL_DIR
     #define USE_FAST_MATH
     #define TFM_TIMING_RESISTANT
     #define ECC_TIMING_RESISTANT
     #define WC_RSA_BLINDING
     #define NO_DEV_RANDOM
     #define NO_FILESYSTEM
     #define USE_CERT_BUFFERS_2048
     #define NO_ERROR_STRINGS
     /* Uncomment this setting if your toolchain does not offer time.h header */
     /* #define USER_TIME */
     #define HAVE_ECC
     #define HAVE_ALPN
     #define USE_WOLF_STRTOK /* use with HAVE_ALPN */
     #define HAVE_TLS_EXTENSIONS
     #define HAVE_AESGCM
     #ifdef WOLFSSL_TI_CRYPT
         #define NO_GCM_ENCRYPT_EXTRA
         #define NO_PUBLIC_GCM_SET_IV
         #define NO_PUBLIC_CCM_SET_NONCE
     #endif
     #define HAVE_SUPPORTED_CURVES
     #define ALT_ECC_SIZE
 
     #ifdef __IAR_SYSTEMS_ICC__
         #pragma diag_suppress=Pa089
     #elif !defined(__GNUC__)
         /* Suppress the sslpro warning */
         #pragma diag_suppress=11
     #endif
 
     #include <ti/sysbios/hal/Seconds.h>
 #endif
 
 #ifdef EBSNET
     #include "rtip.h"
 
     /* #define DEBUG_WOLFSSL */
     #define NO_WOLFSSL_DIR  /* tbd */
 
     #if (POLLOS)
         #define SINGLE_THREADED
     #endif
 
     #if (RTPLATFORM)
         #if (!RTP_LITTLE_ENDIAN)
             #define BIG_ENDIAN_ORDER
         #endif
     #else
         #if (!KS_LITTLE_ENDIAN)
             #define BIG_ENDIAN_ORDER
         #endif
     #endif
 
     #if (WINMSP3)
         #undef SIZEOF_LONG
         #define SIZEOF_LONG_LONG 8
     #else
         #if !defined(SIZEOF_LONG) && !defined(SIZEOF_LONG_LONG)
             #error settings.h - please implement SIZEOF_LONG and SIZEOF_LONG_LONG
         #endif
     #endif
 
     #define XMALLOC(s, h, type) ((void *)rtp_malloc((s), SSL_PRO_MALLOC))
     #define XFREE(p, h, type) (rtp_free(p))
     #define XREALLOC(p, n, h, t) (rtp_realloc((p), (n)))
 
     #if (WINMSP3)
         #define XSTRNCASECMP(s1,s2,n)  _strnicmp((s1),(s2),(n))
     #else
         #ifndef XSTRNCASECMP
             #error settings.h - please implement XSTRNCASECMP - needed for HAVE_ECC
         #endif
     #endif
 
     #define WOLFSSL_HAVE_MAX
     #define WOLFSSL_HAVE_MIN
 
     #define USE_FAST_MATH
     #define TFM_TIMING_RESISTANT
     #define WC_RSA_BLINDING
     #define ECC_TIMING_RESISTANT
 
     #define HAVE_ECC
 
 #endif /* EBSNET */
 
 #ifdef WOLFSSL_GAME_BUILD
     #define SIZEOF_LONG_LONG 8
     #if defined(__PPU) || defined(__XENON)
         #define BIG_ENDIAN_ORDER
     #endif
 #endif
 
 #ifdef WOLFSSL_LSR
     #define HAVE_WEBSERVER
     #define SIZEOF_LONG_LONG 8
     #define WOLFSSL_LOW_MEMORY
     #define NO_WRITEV
     #define NO_SHA512
     #define NO_DH
     /* Allows use of DH with fixed points if uncommented and NO_DH is removed */
     /* WOLFSSL_DH_CONST */
     #define NO_DSA
     #define NO_HC128
     #define NO_DEV_RANDOM
     #define NO_WOLFSSL_DIR
     #define NO_RABBIT
     #ifndef NO_FILESYSTEM
         #define LSR_FS
         #include "inc/hw_types.h"
         #include "fs.h"
     #endif
     #define WOLFSSL_LWIP
     #include <errno.h>  /* for tcp errno */
     #define WOLFSSL_SAFERTOS
     #if defined(__IAR_SYSTEMS_ICC__)
         /* enum uses enum */
         #pragma diag_suppress=Pa089
     #endif
 #endif
 
 #ifdef WOLFSSL_SAFERTOS
     #ifndef SINGLE_THREADED
         #include "SafeRTOS/semphr.h"
     #endif
     #ifndef WOLFSSL_NO_MALLOC
         #include "SafeRTOS/heap.h"
     #endif
     #if !defined(XMALLOC_USER) && !defined(NO_WOLFSSL_MEMORY) && \
         !defined(WOLFSSL_STATIC_MEMORY)
         #define XMALLOC(s, h, type)  pvPortMalloc((s))
         #define XFREE(p, h, type)    vPortFree((p))
     #endif
     /* FreeRTOS pvPortRealloc() implementation can be found here:
         https://github.com/wolfSSL/wolfssl-freertos/pull/3/files */
     #if !defined(USE_FAST_MATH) || defined(HAVE_ED25519) || defined(HAVE_ED448)
         #define XREALLOC(p, n, h, t) pvPortRealloc((p), (n))
     #endif
 #endif
 
 #ifdef WOLFSSL_LOW_MEMORY
     #undef  RSA_LOW_MEM
     #define RSA_LOW_MEM
     #undef  WOLFSSL_SMALL_STACK
     #define WOLFSSL_SMALL_STACK
     #undef  TFM_TIMING_RESISTANT
     #define TFM_TIMING_RESISTANT
 #endif
 
 /* To support storing some of the large constant tables in flash memory rather than SRAM.
    Useful for processors that have limited SRAM, such as the AVR family of microtrollers. */
 #ifdef WOLFSSL_USE_FLASHMEM
     /* This is supported on the avr-gcc compiler, for more information see:
          https://gcc.gnu.org/onlinedocs/gcc/Named-Address-Spaces.html */
     #define FLASH_QUALIFIER __flash
 
     /* Copy data out of flash memory and into SRAM */
     #define XMEMCPY_P(pdest, psrc, size) memcpy_P((pdest), (psrc), (size))
 #else
     #define FLASH_QUALIFIER
 #endif
 
 #ifdef FREESCALE_MQX_5_0
     /* use normal Freescale MQX port, but with minor changes for 5.0 */
     #define FREESCALE_MQX
 #endif
 
 #ifdef FREESCALE_MQX_4_0
     /* use normal Freescale MQX port, but with minor changes for 4.0 */
     #define FREESCALE_MQX
 #endif
 
 #ifdef FREESCALE_MQX
     #define FREESCALE_COMMON
     #include "mqx.h"
     #ifndef NO_FILESYSTEM
         #include "mfs.h"
         #if (defined(MQX_USE_IO_OLD) && MQX_USE_IO_OLD) || \
             defined(FREESCALE_MQX_5_0)
             #include "fio.h"
             #define NO_STDIO_FILESYSTEM
         #else
             #include "nio.h"
         #endif
     #endif
     #ifndef SINGLE_THREADED
         #include "mutex.h"
     #endif
 
     #if !defined(XMALLOC_OVERRIDE) && !defined(XMALLOC_USER)
         #define XMALLOC_OVERRIDE
         #define XMALLOC(s, h, t)    (void *)_mem_alloc_system((s))
         #define XFREE(p, h, t)      {void* xp = (p); if ((xp)) _mem_free((xp));}
         /* Note: MQX has no realloc, using fastmath above */
     #endif
     #ifdef USE_FAST_MATH
         /* Undef first to avoid re-definition if user_settings.h defines */
         #undef TFM_TIMING_RESISTANT
         #define TFM_TIMING_RESISTANT
         #undef ECC_TIMING_RESISTANT
         #define ECC_TIMING_RESISTANT
         #undef WC_RSA_BLINDING
         #define WC_RSA_BLINDING
     #endif
 #endif
 
 #ifdef FREESCALE_KSDK_MQX
     #define FREESCALE_COMMON
     #include <mqx.h>
     #ifndef NO_FILESYSTEM
         #if (defined(MQX_USE_IO_OLD) && MQX_USE_IO_OLD) || \
             defined(FREESCALE_MQX_5_0)
             #include <fio.h>
         #else
             #include <stdio.h>
             #include <nio.h>
         #endif
     #endif
     #ifndef SINGLE_THREADED
         #include <mutex.h>
     #endif
 
     #define XMALLOC(s, h, t)    (void *)_mem_alloc_system((s))
     #define XFREE(p, h, t)      {void* xp = (p); if ((xp)) _mem_free((xp));}
     #define XREALLOC(p, n, h, t) _mem_realloc((p), (n)) /* since MQX 4.1.2 */
 
     #define MQX_FILE_PTR FILE *
     #define IO_SEEK_SET  SEEK_SET
     #define IO_SEEK_END  SEEK_END
 #endif /* FREESCALE_KSDK_MQX */
 
 #if defined(FREESCALE_FREE_RTOS) || defined(FREESCALE_KSDK_FREERTOS)
     #define NO_FILESYSTEM
     #define WOLFSSL_CRYPT_HW_MUTEX 1
 
     #if !defined(XMALLOC_USER) && !defined(NO_WOLFSSL_MEMORY)
         #define XMALLOC(s, h, type)  pvPortMalloc((s))
         #define XFREE(p, h, type)    vPortFree((p))
     #endif
 
     //#define USER_TICKS
     /* Allows use of DH with fixed points if uncommented and NO_DH is removed */
     /* WOLFSSL_DH_CONST */
     #define WOLFSSL_LWIP
     #define FREERTOS_TCP
 
     #define FREESCALE_FREE_RTOS
     #define FREERTOS_SOCKET_ERROR ( -1 )
     #define FREERTOS_EWOULDBLOCK ( -2 )
     #define FREERTOS_EINVAL ( -4 )
     #define FREERTOS_EADDRNOTAVAIL ( -5 )
     #define FREERTOS_EADDRINUSE ( -6 )
     #define FREERTOS_ENOBUFS ( -7 )
     #define FREERTOS_ENOPROTOOPT ( -8 )
 #endif /* FREESCALE_FREE_RTOS || FREESCALE_KSDK_FREERTOS */
 
 #ifdef FREESCALE_KSDK_BM
     #define FREESCALE_COMMON
     #define WOLFSSL_USER_IO
     #define SINGLE_THREADED
     #define NO_FILESYSTEM
     #ifndef TIME_OVERRIDES
         #define USER_TICKS
     #endif
 #endif /* FREESCALE_KSDK_BM */
 
 #ifdef FREESCALE_COMMON
     #define SIZEOF_LONG_LONG 8
 
     /* disable features */
     #undef  NO_WRITEV
     #define NO_WRITEV
     #undef  NO_DEV_RANDOM
     #define NO_DEV_RANDOM
     #undef  NO_RABBIT
     #define NO_RABBIT
     #undef  NO_WOLFSSL_DIR
     #define NO_WOLFSSL_DIR
     #undef  NO_RC4
     #define NO_RC4
 
     /* enable features */
     #undef  USE_FAST_MATH
     #define USE_FAST_MATH
 
     #define USE_CERT_BUFFERS_2048
     #define BENCH_EMBEDDED
 
     #define TFM_TIMING_RESISTANT
     #define ECC_TIMING_RESISTANT
 
     #undef  HAVE_ECC
     #ifndef WOLFCRYPT_FIPS_RAND
     #define HAVE_ECC
     #endif
     #ifndef NO_AES
         #undef  HAVE_AESCCM
         #define HAVE_AESCCM
         #undef  HAVE_AESGCM
         #define HAVE_AESGCM
         #undef  WOLFSSL_AES_COUNTER
         #define WOLFSSL_AES_COUNTER
         #undef  WOLFSSL_AES_DIRECT
         #define WOLFSSL_AES_DIRECT
     #endif
 
     #ifdef FREESCALE_KSDK_1_3
         #include "fsl_device_registers.h"
     #elif !defined(FREESCALE_MQX)
         /* Classic MQX does not have fsl_common.h */
         #include "fsl_common.h"
     #endif
 
     /* random seed */
     #define NO_OLD_RNGNAME
     #if   defined(FREESCALE_NO_RNG)
         /* nothing to define */
     #elif defined(FSL_FEATURE_SOC_TRNG_COUNT) && (FSL_FEATURE_SOC_TRNG_COUNT > 0)
         #define FREESCALE_KSDK_2_0_TRNG
     #elif defined(FSL_FEATURE_SOC_RNG_COUNT) && (FSL_FEATURE_SOC_RNG_COUNT > 0)
         #ifdef FREESCALE_KSDK_1_3
             #include "fsl_rnga_driver.h"
             #define FREESCALE_RNGA
             #define RNGA_INSTANCE (0)
         #else
             #define FREESCALE_KSDK_2_0_RNGA
         #endif
     #elif !defined(FREESCALE_KSDK_BM) && !defined(FREESCALE_FREE_RTOS) && !defined(FREESCALE_KSDK_FREERTOS)
         #define FREESCALE_RNGA
         #define RNGA_INSTANCE (0)
         /* defaulting to K70 RNGA, user should change if different */
         /* #define FREESCALE_K53_RNGB */
         #define FREESCALE_K70_RNGA
     #endif
 
     /* HW crypto */
     /* automatic enable based on Kinetis feature */
     /* if case manual selection is required, for example for benchmarking purposes,
      * just define FREESCALE_USE_MMCAU or FREESCALE_USE_LTC or none of these two macros (for software only)
      * both can be enabled simultaneously as LTC has priority over MMCAU in source code.
      */
     /* #define FSL_HW_CRYPTO_MANUAL_SELECTION */
     #ifndef FSL_HW_CRYPTO_MANUAL_SELECTION
         #if defined(FSL_FEATURE_SOC_MMCAU_COUNT) && FSL_FEATURE_SOC_MMCAU_COUNT
             #define FREESCALE_USE_MMCAU
         #endif
 
         #if defined(FSL_FEATURE_SOC_LTC_COUNT) && FSL_FEATURE_SOC_LTC_COUNT
             #define FREESCALE_USE_LTC
         #endif
     #else
         /* #define FREESCALE_USE_MMCAU */
         /* #define FREESCALE_USE_LTC */
     #endif
 #endif /* FREESCALE_COMMON */
 
 /* Classic pre-KSDK mmCAU library */
 #ifdef FREESCALE_USE_MMCAU_CLASSIC
     #define FREESCALE_USE_MMCAU
     #define FREESCALE_MMCAU_CLASSIC
     #define FREESCALE_MMCAU_CLASSIC_SHA
 #endif
 
 /* KSDK mmCAU library */
 #ifdef FREESCALE_USE_MMCAU
     /* AES and DES */
     #define FREESCALE_MMCAU
     /* MD5, SHA-1 and SHA-256 */
     #define FREESCALE_MMCAU_SHA
 #endif /* FREESCALE_USE_MMCAU */
 
 #ifdef FREESCALE_USE_LTC
     #if defined(FSL_FEATURE_SOC_LTC_COUNT) && FSL_FEATURE_SOC_LTC_COUNT
         #define FREESCALE_LTC
         #define LTC_BASE LTC0
 
         #if defined(FSL_FEATURE_LTC_HAS_DES) && FSL_FEATURE_LTC_HAS_DES
             #define FREESCALE_LTC_DES
         #endif
 
         #if defined(FSL_FEATURE_LTC_HAS_GCM) && FSL_FEATURE_LTC_HAS_GCM
             #define FREESCALE_LTC_AES_GCM
         #endif
 
         #if defined(FSL_FEATURE_LTC_HAS_SHA) && FSL_FEATURE_LTC_HAS_SHA
             #define FREESCALE_LTC_SHA
         #endif
 
         #if defined(FSL_FEATURE_LTC_HAS_PKHA) && FSL_FEATURE_LTC_HAS_PKHA
             #ifndef WOLFCRYPT_FIPS_RAND
             #define FREESCALE_LTC_ECC
             #endif
             #define FREESCALE_LTC_TFM
 
             /* the LTC PKHA hardware limit is 2048 bits (256 bytes) for integer arithmetic.
                the LTC_MAX_INT_BYTES defines the size of local variables that hold big integers. */
             #ifndef LTC_MAX_INT_BYTES
                 #define LTC_MAX_INT_BYTES (256)
             #endif
 
             /* This FREESCALE_LTC_TFM_RSA_4096_ENABLE macro can be defined.
              * In such a case both software and hardware algorithm
              * for TFM is linked in. The decision for which algorithm is used is determined at runtime
              * from size of inputs. If inputs and result can fit into LTC (see LTC_MAX_INT_BYTES)
              * then we call hardware algorithm, otherwise we call software algorithm.
              *
              * Chinese reminder theorem is used to break RSA 4096 exponentiations (both public and private key)
              * into several computations with 2048-bit modulus and exponents.
              */
             /* #define FREESCALE_LTC_TFM_RSA_4096_ENABLE */
 
             /* ECC-384, ECC-256, ECC-224 and ECC-192 have been enabled with LTC PKHA acceleration */
             #ifdef HAVE_ECC
                 #undef  ECC_TIMING_RESISTANT
                 #define ECC_TIMING_RESISTANT
 
                 /* the LTC PKHA hardware limit is 512 bits (64 bytes) for ECC.
                    the LTC_MAX_ECC_BITS defines the size of local variables that hold ECC parameters
                    and point coordinates */
                 #ifndef LTC_MAX_ECC_BITS
                     #define LTC_MAX_ECC_BITS (384)
                 #endif
 
                 /* Enable curves up to 384 bits */
                 #if !defined(ECC_USER_CURVES) && !defined(HAVE_ALL_CURVES)
                     #define ECC_USER_CURVES
                     #define HAVE_ECC192
                     #define HAVE_ECC224
                     #undef  NO_ECC256
                     #define HAVE_ECC384
                 #endif
             #endif
         #endif
     #endif
 #endif /* FREESCALE_USE_LTC */
 
 #ifdef FREESCALE_LTC_TFM_RSA_4096_ENABLE
     #undef  USE_CERT_BUFFERS_4096
     #define USE_CERT_BUFFERS_4096
     #undef  FP_MAX_BITS
     #define FP_MAX_BITS (8192)
 
     #undef  NO_DH
     #define NO_DH
     #undef  NO_DSA
     #define NO_DSA
 #endif /* FREESCALE_LTC_TFM_RSA_4096_ENABLE */
 
 /* if LTC has AES engine but doesn't have GCM, use software with LTC AES ECB mode */
 #if defined(FREESCALE_USE_LTC) && !defined(FREESCALE_LTC_AES_GCM)
     #define GCM_TABLE
 #endif
 
 #if defined(WOLFSSL_STM32F2) || defined(WOLFSSL_STM32F4) || \
     defined(WOLFSSL_STM32F7) || defined(WOLFSSL_STM32F1) || \
     defined(WOLFSSL_STM32L4) || defined(WOLFSSL_STM32L5) || \
     defined(WOLFSSL_STM32WB) || defined(WOLFSSL_STM32H7)
 
     #define SIZEOF_LONG_LONG 8
     #ifndef CHAR_BIT
       #define CHAR_BIT 8
     #endif
     #define NO_DEV_RANDOM
     #define NO_WOLFSSL_DIR
     #undef  NO_RABBIT
     #define NO_RABBIT
     #ifndef NO_STM32_RNG
         #undef  STM32_RNG
         #define STM32_RNG
         #ifdef WOLFSSL_STM32F427_RNG
             #include "stm32f427xx.h"
         #endif
     #endif
     #ifndef NO_STM32_CRYPTO
         #undef  STM32_CRYPTO
         #define STM32_CRYPTO
 
         #if defined(WOLFSSL_STM32L4) || defined(WOLFSSL_STM32L5) || \
             defined(WOLFSSL_STM32WB)
             #define NO_AES_192 /* hardware does not support 192-bit */
         #endif
     #endif
     #ifndef NO_STM32_HASH
         #undef  STM32_HASH
         #define STM32_HASH
     #endif
     #if !defined(__GNUC__) && !defined(__ICCARM__)
         #define KEIL_INTRINSICS
     #endif
     #define NO_OLD_RNGNAME
     #ifdef WOLFSSL_STM32_CUBEMX
         #if defined(WOLFSSL_STM32F1)
             #include "stm32f1xx_hal.h"
         #elif defined(WOLFSSL_STM32F2)
             #include "stm32f2xx_hal.h"
         #elif defined(WOLFSSL_STM32L5)
             #include "stm32l5xx_hal.h"
         #elif defined(WOLFSSL_STM32L4)
             #include "stm32l4xx_hal.h"
         #elif defined(WOLFSSL_STM32F4)
             #include "stm32f4xx_hal.h"
         #elif defined(WOLFSSL_STM32F7)
             #include "stm32f7xx_hal.h"
         #elif defined(WOLFSSL_STM32F1)
             #include "stm32f1xx_hal.h"
         #elif defined(WOLFSSL_STM32H7)
             #include "stm32h7xx_hal.h"
         #elif defined(WOLFSSL_STM32WB)
             #include "stm32wbxx_hal.h"
         #endif
         #if defined(WOLFSSL_CUBEMX_USE_LL) && defined(WOLFSSL_STM32L4)
             #include "stm32l4xx_ll_rng.h"
         #endif
 
         #ifndef STM32_HAL_TIMEOUT
             #define STM32_HAL_TIMEOUT   0xFF
         #endif
     #else
         #if defined(WOLFSSL_STM32F2)
             #include "stm32f2xx.h"
             #ifdef STM32_CRYPTO
                 #include "stm32f2xx_cryp.h"
             #endif
             #ifdef STM32_HASH
                 #include "stm32f2xx_hash.h"
             #endif
         #elif defined(WOLFSSL_STM32F4)
             #include "stm32f4xx.h"
             #ifdef STM32_CRYPTO
                 #include "stm32f4xx_cryp.h"
             #endif
             #ifdef STM32_HASH
                 #include "stm32f4xx_hash.h"
             #endif
         #elif defined(WOLFSSL_STM32L5)
             #include "stm32l5xx.h"
             #ifdef STM32_CRYPTO
                 #include "stm32l5xx_cryp.h"
             #endif
             #ifdef STM32_HASH
                 #include "stm32l5xx_hash.h"
             #endif
         #elif defined(WOLFSSL_STM32L4)
             #include "stm32l4xx.h"
             #ifdef STM32_CRYPTO
                 #include "stm32l4xx_cryp.h"
             #endif
             #ifdef STM32_HASH
                 #include "stm32l4xx_hash.h"
             #endif
         #elif defined(WOLFSSL_STM32F7)
             #include "stm32f7xx.h"
         #elif defined(WOLFSSL_STM32H7)
             #include "stm32h7xx.h"
         #elif defined(WOLFSSL_STM32F1)
             #include "stm32f1xx.h"
         #endif
     #endif /* WOLFSSL_STM32_CUBEMX */
 #endif /* WOLFSSL_STM32F2 || WOLFSSL_STM32F4 || WOLFSSL_STM32L4 || 
           WOLFSSL_STM32L5 || WOLFSSL_STM32F7 || WOLFSSL_STMWB || WOLFSSL_STM32H7 */
 #ifdef WOLFSSL_DEOS
     #include <deos.h>
     #include <timeout.h>
     #include <socketapi.h>
     #include <lwip-socket.h>
     #include <mem.h>
     #include <string.h>
     #include <stdlib.h> /* for rand_r: pseudo-random number generator */
     #include <stdio.h>  /* for snprintf */
 
     /* use external memory XMALLOC, XFREE and XREALLOC functions */
     #define XMALLOC_USER
 
     /* disable fall-back case, malloc, realloc and free are unavailable */
     #define WOLFSSL_NO_MALLOC
 
     /* file system has not been ported since it is a separate product. */
 
     #define NO_FILESYSTEM
 
     #ifdef NO_FILESYSTEM
         #define NO_WOLFSSL_DIR
         #define NO_WRITEV
     #endif
 
     #define USE_FAST_MATH
     #define TFM_TIMING_RESISTANT
     #define ECC_TIMING_RESISTANT
     #define WC_RSA_BLINDING
 
     #define HAVE_ECC
     #define ALT_ECC_SIZE
     #define TFM_ECC192
     #define TFM_ECC224
     #define TFM_ECC256
     #define TFM_ECC384
     #define TFM_ECC521
 
     #define HAVE_TLS_EXTENSIONS
     #define HAVE_SUPPORTED_CURVES
     #define HAVE_EXTENDED_MASTER
 
     #if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
         #define BIG_ENDIAN_ORDER
     #else
         #undef  BIG_ENDIAN_ORDER
         #define LITTLE_ENDIAN_ORDER
     #endif
 #endif /* WOLFSSL_DEOS*/
 
 #ifdef MICRIUM
     #include <stdlib.h>
     #include <os.h>
     #include <net_cfg.h>
     #include <net_sock.h>
     #include <net_err.h>
     #include <lib_mem.h>
     #include <lib_math.h>
 
     #define USE_FAST_MATH
     #define TFM_TIMING_RESISTANT
     #define ECC_TIMING_RESISTANT
     #define WC_RSA_BLINDING
     #define HAVE_HASHDRBG
 
     #define HAVE_ECC
     #define ALT_ECC_SIZE
     #define TFM_ECC192
     #define TFM_ECC224
     #define TFM_ECC256
     #define TFM_ECC384
     #define TFM_ECC521
 
     #define NO_RC4
     #define HAVE_TLS_EXTENSIONS
     #define HAVE_SUPPORTED_CURVES
     #define HAVE_EXTENDED_MASTER
 
     #define NO_WOLFSSL_DIR
     #define NO_WRITEV
 
     #ifndef CUSTOM_RAND_GENERATE
         #define CUSTOM_RAND_TYPE     RAND_NBR
         #define CUSTOM_RAND_GENERATE Math_Rand
     #endif
     #define STRING_USER
     #define XSTRLEN(pstr) ((CPU_SIZE_T)Str_Len((CPU_CHAR *)(pstr)))
     #define XSTRNCPY(pstr_dest, pstr_src, len_max) \
                     ((CPU_CHAR *)Str_Copy_N((CPU_CHAR *)(pstr_dest), \
                      (CPU_CHAR *)(pstr_src), (CPU_SIZE_T)(len_max)))
     #define XSTRNCMP(pstr_1, pstr_2, len_max) \
                     ((CPU_INT16S)Str_Cmp_N((CPU_CHAR *)(pstr_1), \
                      (CPU_CHAR *)(pstr_2), (CPU_SIZE_T)(len_max)))
     #define XSTRNCASECMP(pstr_1, pstr_2, len_max) \
                     ((CPU_INT16S)Str_CmpIgnoreCase_N((CPU_CHAR *)(pstr_1), \
                      (CPU_CHAR *)(pstr_2), (CPU_SIZE_T)(len_max)))
     #define XSTRSTR(pstr, pstr_srch) \
                     ((CPU_CHAR *)Str_Str((CPU_CHAR *)(pstr), \
                      (CPU_CHAR *)(pstr_srch)))
     #define XSTRNSTR(pstr, pstr_srch, len_max) \
                     ((CPU_CHAR *)Str_Str_N((CPU_CHAR *)(pstr), \
                      (CPU_CHAR *)(pstr_srch),(CPU_SIZE_T)(len_max)))
     #define XSTRNCAT(pstr_dest, pstr_cat, len_max) \
                     ((CPU_CHAR *)Str_Cat_N((CPU_CHAR *)(pstr_dest), \
                      (const CPU_CHAR *)(pstr_cat),(CPU_SIZE_T)(len_max)))
     #define XMEMSET(pmem, data_val, size) \
                     ((void)Mem_Set((void *)(pmem), \
                     (CPU_INT08U) (data_val), \
                     (CPU_SIZE_T)(size)))
     #define XMEMCPY(pdest, psrc, size) ((void)Mem_Copy((void *)(pdest), \
                      (void *)(psrc), (CPU_SIZE_T)(size)))
     #define XMEMCMP(pmem_1, pmem_2, size) \
                    (((CPU_BOOLEAN)Mem_Cmp((void *)(pmem_1), \
                                           (void *)(pmem_2), \
                      (CPU_SIZE_T)(size))) ? DEF_NO : DEF_YES)
     #define XMEMMOVE XMEMCPY
 
     #if (OS_CFG_MUTEX_EN == DEF_DISABLED)
         #define SINGLE_THREADED
     #endif
 
     #if (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_BIG)
         #define BIG_ENDIAN_ORDER
     #else
         #undef  BIG_ENDIAN_ORDER
         #define LITTLE_ENDIAN_ORDER
     #endif
 #endif /* MICRIUM */
 
 #if defined(sun) || defined(__sun)
 # if defined(__SVR4) || defined(__svr4__)
     /* Solaris */
     #ifndef WOLFSSL_SOLARIS
         #define WOLFSSL_SOLARIS
     #endif
 # else
     /* SunOS */
 # endif
 #endif
 
 #ifdef WOLFSSL_SOLARIS
     /* Avoid naming clash with fp_zero from math.h > ieefp.h */
     #define WOLFSSL_DH_CONST
 #endif
 
 #ifdef WOLFSSL_MCF5441X
     #define BIG_ENDIAN_ORDER
     #ifndef SIZEOF_LONG
         #define SIZEOF_LONG 4
     #endif
     #ifndef SIZEOF_LONG_LONG
         #define SIZEOF_LONG_LONG 8
     #endif
 #endif
 
 #ifdef WOLFSSL_QL
     #ifndef WOLFSSL_SEP
         #define WOLFSSL_SEP
     #endif
     #ifndef OPENSSL_EXTRA
         #define OPENSSL_EXTRA
     #endif
     #ifndef SESSION_CERTS
         #define SESSION_CERTS
     #endif
     #ifndef HAVE_AESCCM
         #define HAVE_AESCCM
     #endif
     #ifndef ATOMIC_USER
         #define ATOMIC_USER
     #endif
     #ifndef WOLFSSL_DER_LOAD
         #define WOLFSSL_DER_LOAD
     #endif
     #ifndef KEEP_PEER_CERT
         #define KEEP_PEER_CERT
     #endif
     #ifndef HAVE_ECC
         #define HAVE_ECC
     #endif
     #ifndef SESSION_INDEX
         #define SESSION_INDEX
     #endif
 #endif /* WOLFSSL_QL */
 
 
 #if defined(WOLFSSL_XILINX)
     #define NO_WOLFSSL_DIR
     #define NO_DEV_RANDOM
     #define HAVE_AESGCM
 #endif
 
 #if defined(WOLFSSL_XILINX_CRYPT) || defined(WOLFSSL_AFALG_XILINX)
     #if defined(WOLFSSL_ARMASM)
         #error can not use both ARMv8 instructions and XILINX hardened crypto
     #endif
     #if defined(WOLFSSL_SHA3)
         /* only SHA3-384 is supported */
         #undef WOLFSSL_NOSHA3_224
         #undef WOLFSSL_NOSHA3_256
         #undef WOLFSSL_NOSHA3_512
         #define WOLFSSL_NOSHA3_224
         #define WOLFSSL_NOSHA3_256
         #define WOLFSSL_NOSHA3_512
     #endif
     #ifdef WOLFSSL_AFALG_XILINX_AES
         #undef  WOLFSSL_AES_DIRECT
         #define WOLFSSL_AES_DIRECT
     #endif
 #endif /*(WOLFSSL_XILINX_CRYPT)*/
 
 #if defined(WOLFSSL_APACHE_MYNEWT)
     #include "os/os_malloc.h"
     #if !defined(WOLFSSL_LWIP)
         #include <mn_socket/mn_socket.h>
     #endif
 
     #if !defined(SIZEOF_LONG)
         #define SIZEOF_LONG 4
     #endif
     #if !defined(SIZEOF_LONG_LONG)
         #define SIZEOF_LONG_LONG 8
     #endif
     #if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
         #define BIG_ENDIAN_ORDER
     #else
         #undef  BIG_ENDIAN_ORDER
         #define LITTLE_ENDIAN_ORDER
     #endif
     #define NO_WRITEV
     #define WOLFSSL_USER_IO
     #define SINGLE_THREADED
     #define NO_DEV_RANDOM
     #define NO_DH
     #define NO_WOLFSSL_DIR
     #define NO_ERROR_STRINGS
     #define HAVE_ECC
     #define NO_SESSION_CACHE
     #define NO_ERROR_STRINGS
     #define XMALLOC_USER
     #define XMALLOC(sz, heap, type)     os_malloc(sz)
     #define XREALLOC(p, sz, heap, type) os_realloc(p, sz)
     #define XFREE(p, heap, type)        os_free(p)
 
 #endif /*(WOLFSSL_APACHE_MYNEWT)*/
 
 #ifdef WOLFSSL_ZEPHYR
     #include <zephyr.h>
     #include <misc/printk.h>
     #include <misc/util.h>
     #include <stdlib.h>
 
     #define WOLFSSL_DH_CONST
     #define WOLFSSL_HAVE_MIN
     #define WOLFSSL_HAVE_MAX
     #define NO_WRITEV
 
     #define USE_FLAT_BENCHMARK_H
     #define USE_FLAT_TEST_H
     #define EXIT_FAILURE 1
     #define MAIN_NO_ARGS
 
     void *z_realloc(void *ptr, size_t size);
     #define realloc   z_realloc
 
     #define CONFIG_NET_SOCKETS_POSIX_NAMES
 #endif
 
 #ifdef WOLFSSL_IMX6
     #ifndef SIZEOF_LONG_LONG
         #define SIZEOF_LONG_LONG 8
     #endif
 #endif
 
 /* if defined turn on all CAAM support */
 #ifdef WOLFSSL_IMX6_CAAM
     #undef  WOLFSSL_IMX6_CAAM_RNG
     #define WOLFSSL_IMX6_CAAM_RNG
 
     #undef  WOLFSSL_IMX6_CAAM_BLOB
     #define WOLFSSL_IMX6_CAAM_BLOB
 
 #if defined(HAVE_AESGCM) || defined(WOLFSSL_AES_XTS)
     /* large performance gain with HAVE_AES_ECB defined */
     #undef HAVE_AES_ECB
     #define HAVE_AES_ECB
 #endif
 #endif
 
 /* If DCP is used without SINGLE_THREADED, enforce WOLFSSL_CRYPT_HW_MUTEX */
 #if defined(WOLFSSL_IMXRT_DCP) && !defined(SINGLE_THREADED)
     #undef WOLFSSL_CRYPT_HW_MUTEX
     #define WOLFSSL_CRYPT_HW_MUTEX 1
 #endif
 
 #if !defined(XMALLOC_USER) && !defined(MICRIUM_MALLOC) && \
     !defined(WOLFSSL_LEANPSK) && !defined(NO_WOLFSSL_MEMORY) && \
     !defined(XMALLOC_OVERRIDE)
     #define USE_WOLFSSL_MEMORY
 #endif
 
 
 #if defined(OPENSSL_EXTRA) && !defined(NO_CERTS)
     #undef  KEEP_PEER_CERT
     #define KEEP_PEER_CERT
 #endif
 
 
 /* stream ciphers except arc4 need 32bit alignment, intel ok without */
 #ifndef XSTREAM_ALIGN
     #if defined(__x86_64__) || defined(__ia64__) || defined(__i386__)
         #define NO_XSTREAM_ALIGN
     #else
         #define XSTREAM_ALIGN
     #endif
 #endif
 
 /* write dup cannot be used with secure renegotiation because write dup
  * make write side write only and read side read only */
 #if defined(HAVE_WRITE_DUP) && defined(HAVE_SECURE_RENEGOTIATION)
     #error "WRITE DUP and SECURE RENEGOTIATION cannot both be on"
 #endif
 
 #ifdef WOLFSSL_SGX
     #ifdef _MSC_VER
         #define NO_RC4
         #ifndef HAVE_FIPS
             #define WOLFCRYPT_ONLY
             #define NO_DES3
             #define NO_SHA
             #define NO_MD5
         #else
             #define TFM_TIMING_RESISTANT
             #define NO_WOLFSSL_DIR
             #define NO_WRITEV
             #define NO_MAIN_DRIVER
             #define WOLFSSL_LOG_PRINTF
             #define WOLFSSL_DH_CONST
         #endif
     #else
         #define HAVE_ECC
         #define NO_WRITEV
         #define NO_MAIN_DRIVER
         #define USER_TICKS
         #define WOLFSSL_LOG_PRINTF
         #define WOLFSSL_DH_CONST
     #endif /* _MSC_VER */
     #if !defined(HAVE_FIPS) && !defined(NO_RSA)
         #define WC_RSA_BLINDING
     #endif
 
     #define NO_FILESYSTEM
     #define ECC_TIMING_RESISTANT
     #define TFM_TIMING_RESISTANT
     #define SINGLE_THREADED
     #define NO_ASN_TIME /* can not use headers such as windows.h */
     #define HAVE_AESGCM
     #define USE_CERT_BUFFERS_2048
     #define USE_FAST_MATH
 #endif /* WOLFSSL_SGX */
 
 /* FreeScale MMCAU hardware crypto has 4 byte alignment.
    However, KSDK fsl_mmcau.h gives API with no alignment
    requirements (4 byte alignment is managed internally by fsl_mmcau.c) */
 #ifdef FREESCALE_MMCAU
     #ifdef FREESCALE_MMCAU_CLASSIC
         #define WOLFSSL_MMCAU_ALIGNMENT 4
     #else
         #define WOLFSSL_MMCAU_ALIGNMENT 0
     #endif
 #endif
 
 /* if using hardware crypto and have alignment requirements, specify the
    requirement here.  The record header of SSL/TLS will prevent easy alignment.
    This hint tries to help as much as possible.  */
 #ifndef WOLFSSL_GENERAL_ALIGNMENT
     #ifdef WOLFSSL_AESNI
         #define WOLFSSL_GENERAL_ALIGNMENT 16
     #elif defined(XSTREAM_ALIGN)
         #define WOLFSSL_GENERAL_ALIGNMENT  4
     #elif defined(FREESCALE_MMCAU) || defined(FREESCALE_MMCAU_CLASSIC)
         #define WOLFSSL_GENERAL_ALIGNMENT  WOLFSSL_MMCAU_ALIGNMENT
     #else
         #define WOLFSSL_GENERAL_ALIGNMENT  0
     #endif
 #endif
 
 #if defined(WOLFSSL_GENERAL_ALIGNMENT) && (WOLFSSL_GENERAL_ALIGNMENT > 0)
     #if defined(_MSC_VER)
         #define XGEN_ALIGN __declspec(align(WOLFSSL_GENERAL_ALIGNMENT))
     #elif defined(__GNUC__)
         #define XGEN_ALIGN __attribute__((aligned(WOLFSSL_GENERAL_ALIGNMENT)))
     #else
         #define XGEN_ALIGN
     #endif
 #else
     #define XGEN_ALIGN
 #endif
 
 
 #ifdef __INTEL_COMPILER
     #pragma warning(disable:2259) /* explicit casts to smaller sizes, disable */
 #endif
 
 /* user can specify what curves they want with ECC_USER_CURVES otherwise
  * all curves are on by default for now */
 #ifndef ECC_USER_CURVES
     #if !defined(WOLFSSL_SP_MATH) && !defined(HAVE_ALL_CURVES)
         #define HAVE_ALL_CURVES
     #endif
 #endif
+#ifndef ECC_WEAK_CURVES
+    /* if building TLS to enable < 224 then allow weak curves */
+    /* Note: ECC 224-bit is equiv to RSA 2048 bit */
+    #if defined(WOLFSSL_MIN_ECC_BITS) && WOLFSSL_MIN_ECC_BITS < 224
+        #define ECC_WEAK_CURVES
+    #endif
+#endif
 
 /* ECC Configs */
 #ifdef HAVE_ECC
     /* By default enable Sign, Verify, DHE, Key Import and Key Export unless explicitly disabled */
     #ifndef NO_ECC_SIGN
         #undef HAVE_ECC_SIGN
         #define HAVE_ECC_SIGN
     #endif
     #ifndef NO_ECC_VERIFY
         #undef HAVE_ECC_VERIFY
         #define HAVE_ECC_VERIFY
     #endif
     #ifndef NO_ECC_CHECK_KEY
         #undef HAVE_ECC_CHECK_KEY
         #define HAVE_ECC_CHECK_KEY
     #endif
     #ifndef NO_ECC_DHE
         #undef HAVE_ECC_DHE
         #define HAVE_ECC_DHE
     #endif
     #ifndef NO_ECC_KEY_IMPORT
         #undef HAVE_ECC_KEY_IMPORT
         #define HAVE_ECC_KEY_IMPORT
     #endif
     #ifndef NO_ECC_KEY_EXPORT
         #undef HAVE_ECC_KEY_EXPORT
         #define HAVE_ECC_KEY_EXPORT
     #endif
 #endif /* HAVE_ECC */
 
 /* Curve25519 Configs */
 #ifdef HAVE_CURVE25519
     /* By default enable shared secret, key export and import */
     #ifndef NO_CURVE25519_SHARED_SECRET
         #undef HAVE_CURVE25519_SHARED_SECRET
         #define HAVE_CURVE25519_SHARED_SECRET
     #endif
     #ifndef NO_CURVE25519_KEY_EXPORT
         #undef HAVE_CURVE25519_KEY_EXPORT
         #define HAVE_CURVE25519_KEY_EXPORT
     #endif
     #ifndef NO_CURVE25519_KEY_IMPORT
         #undef HAVE_CURVE25519_KEY_IMPORT
         #define HAVE_CURVE25519_KEY_IMPORT
     #endif
 #endif /* HAVE_CURVE25519 */
 
 /* Ed25519 Configs */
 #ifdef HAVE_ED25519
     /* By default enable sign, verify, key export and import */
     #ifndef NO_ED25519_SIGN
         #undef HAVE_ED25519_SIGN
         #define HAVE_ED25519_SIGN
     #endif
     #ifndef NO_ED25519_VERIFY
         #undef HAVE_ED25519_VERIFY
         #define HAVE_ED25519_VERIFY
     #endif
     #ifndef NO_ED25519_KEY_EXPORT
         #undef HAVE_ED25519_KEY_EXPORT
         #define HAVE_ED25519_KEY_EXPORT
     #endif
     #ifndef NO_ED25519_KEY_IMPORT
         #undef HAVE_ED25519_KEY_IMPORT
         #define HAVE_ED25519_KEY_IMPORT
     #endif
 #endif /* HAVE_ED25519 */
 
 /* Curve448 Configs */
 #ifdef HAVE_CURVE448
     /* By default enable shared secret, key export and import */
     #ifndef NO_CURVE448_SHARED_SECRET
         #undef HAVE_CURVE448_SHARED_SECRET
         #define HAVE_CURVE448_SHARED_SECRET
     #endif
     #ifndef NO_CURVE448_KEY_EXPORT
         #undef HAVE_CURVE448_KEY_EXPORT
         #define HAVE_CURVE448_KEY_EXPORT
     #endif
     #ifndef NO_CURVE448_KEY_IMPORT
         #undef HAVE_CURVE448_KEY_IMPORT
         #define HAVE_CURVE448_KEY_IMPORT
     #endif
 #endif /* HAVE_CURVE448 */
 
 /* Ed448 Configs */
 #ifdef HAVE_ED448
     /* By default enable sign, verify, key export and import */
     #ifndef NO_ED448_SIGN
         #undef HAVE_ED448_SIGN
         #define HAVE_ED448_SIGN
     #endif
     #ifndef NO_ED448_VERIFY
         #undef HAVE_ED448_VERIFY
         #define HAVE_ED448_VERIFY
     #endif
     #ifndef NO_ED448_KEY_EXPORT
         #undef HAVE_ED448_KEY_EXPORT
         #define HAVE_ED448_KEY_EXPORT
     #endif
     #ifndef NO_ED448_KEY_IMPORT
         #undef HAVE_ED448_KEY_IMPORT
         #define HAVE_ED448_KEY_IMPORT
     #endif
 #endif /* HAVE_ED448 */
 
 /* AES Config */
 #ifndef NO_AES
     /* By default enable all AES key sizes, decryption and CBC */
     #ifndef AES_MAX_KEY_SIZE
         #undef  AES_MAX_KEY_SIZE
         #define AES_MAX_KEY_SIZE    256
     #endif
 
     #ifndef NO_AES_128
         #undef  WOLFSSL_AES_128
         #define WOLFSSL_AES_128
     #endif
     #if !defined(NO_AES_192) && AES_MAX_KEY_SIZE >= 192
         #undef  WOLFSSL_AES_192
         #define WOLFSSL_AES_192
     #endif
     #if !defined(NO_AES_256) && AES_MAX_KEY_SIZE >= 256
         #undef  WOLFSSL_AES_256
         #define WOLFSSL_AES_256
     #endif
     #if !defined(WOLFSSL_AES_128) && defined(HAVE_ECC_ENCRYPT)
         #warning HAVE_ECC_ENCRYPT uses AES 128 bit keys
      #endif
 
     #ifndef NO_AES_DECRYPT
         #undef  HAVE_AES_DECRYPT
         #define HAVE_AES_DECRYPT
     #endif
     #ifndef NO_AES_CBC
         #undef  HAVE_AES_CBC
         #define HAVE_AES_CBC
     #endif
     #ifdef WOLFSSL_AES_XTS
         /* AES-XTS makes calls to AES direct functions */
         #ifndef WOLFSSL_AES_DIRECT
         #define WOLFSSL_AES_DIRECT
         #endif
     #endif
     #ifdef WOLFSSL_AES_CFB
         /* AES-CFB makes calls to AES direct functions */
         #ifndef WOLFSSL_AES_DIRECT
         #define WOLFSSL_AES_DIRECT
         #endif
     #endif
 #endif
 
 #if (defined(WOLFSSL_TLS13) && defined(WOLFSSL_NO_TLS12)) || \
     (!defined(HAVE_AES_CBC) && defined(NO_DES3) && defined(NO_RC4) && \
      !defined(HAVE_CAMELLIA) && !defined(HAVE_IDEA) && \
      !defined(HAVE_NULL_CIPHER) && !defined(HAVE_HC128))
     #define WOLFSSL_AEAD_ONLY
 #endif
 
 #if !defined(NO_DH) && !defined(HAVE_FFDHE)
     #if defined(HAVE_FFDHE_2048) || defined(HAVE_FFDHE_3072) || \
             defined(HAVE_FFDHE_4096) || defined(HAVE_FFDHE_6144) || \
             defined(HAVE_FFDHE_8192)
         #define HAVE_FFDHE
     #endif
 #endif
 #if defined(HAVE_FFDHE_8192)
     #define MIN_FFDHE_FP_MAX_BITS 16384
 #elif defined(HAVE_FFDHE_6144)
     #define MIN_FFDHE_FP_MAX_BITS 12288
 #elif defined(HAVE_FFDHE_4096)
     #define MIN_FFDHE_FP_MAX_BITS 8192
 #elif defined(HAVE_FFDHE_3072)
     #define MIN_FFDHE_FP_MAX_BITS 6144
 #elif defined(HAVE_FFDHE_2048)
     #define MIN_FFDHE_FP_MAX_BITS 4096
 #else
     #define MIN_FFDHE_FP_MAX_BITS 0
 #endif
 #if defined(HAVE_FFDHE) && defined(FP_MAX_BITS)
     #if MIN_FFDHE_FP_MAX_BITS > FP_MAX_BITS
         #error "FFDHE parameters are too large for FP_MAX_BIT as set"
     #endif
 #endif
 
 /* if desktop type system and fastmath increase default max bits */
 #ifdef WOLFSSL_X86_64_BUILD
     #if defined(USE_FAST_MATH) && !defined(FP_MAX_BITS)
         #if MIN_FFDHE_FP_MAX_BITS <= 8192
             #define FP_MAX_BITS 8192
         #else
             #define FP_MAX_BITS MIN_FFDHE_FP_MAX_BITS
         #endif
     #endif
 #endif
 
 /* If using the max strength build, ensure OLD TLS is disabled. */
 #ifdef WOLFSSL_MAX_STRENGTH
     #undef NO_OLD_TLS
     #define NO_OLD_TLS
 #endif
 
 
 /* Default AES minimum auth tag sz, allow user to override */
 #ifndef WOLFSSL_MIN_AUTH_TAG_SZ
     #define WOLFSSL_MIN_AUTH_TAG_SZ 12
 #endif
 
 
 /* sniffer requires:
  * static RSA cipher suites
  * session stats and peak stats
  */
 #ifdef WOLFSSL_SNIFFER
     #ifndef WOLFSSL_STATIC_RSA
         #define WOLFSSL_STATIC_RSA
     #endif
     #ifndef WOLFSSL_STATIC_DH
         #define WOLFSSL_STATIC_DH
     #endif
     /* Allow option to be disabled. */
     #ifndef WOLFSSL_NO_SESSION_STATS
         #ifndef WOLFSSL_SESSION_STATS
             #define WOLFSSL_SESSION_STATS
         #endif
         #ifndef WOLFSSL_PEAK_SESSIONS
             #define WOLFSSL_PEAK_SESSIONS
         #endif
     #endif
 #endif
 
 /* Decode Public Key extras on by default, user can turn off with
  * WOLFSSL_NO_DECODE_EXTRA */
 #ifndef WOLFSSL_NO_DECODE_EXTRA
     #ifndef RSA_DECODE_EXTRA
         #define RSA_DECODE_EXTRA
     #endif
     #ifndef ECC_DECODE_EXTRA
         #define ECC_DECODE_EXTRA
     #endif
 #endif
 
 /* C Sharp wrapper defines */
 #ifdef HAVE_CSHARP
     #ifndef WOLFSSL_DTLS
         #define WOLFSSL_DTLS
     #endif
     #undef NO_PSK
     #undef NO_SHA256
     #undef NO_DH
 #endif
 
 /* Asynchronous Crypto */
 #ifdef WOLFSSL_ASYNC_CRYPT
     /* Make sure wolf events are enabled */
     #undef HAVE_WOLF_EVENT
     #define HAVE_WOLF_EVENT
 
     #ifdef WOLFSSL_ASYNC_CRYPT_TEST
         #define WC_ASYNC_DEV_SIZE 168
     #else
         #define WC_ASYNC_DEV_SIZE 336
     #endif
 
     #if !defined(HAVE_CAVIUM) && !defined(HAVE_INTEL_QA) && \
         !defined(WOLFSSL_ASYNC_CRYPT_TEST)
         #error No async hardware defined with WOLFSSL_ASYNC_CRYPT!
     #endif
 
     /* Enable ECC_CACHE_CURVE for ASYNC */
     #if !defined(ECC_CACHE_CURVE)
         #define ECC_CACHE_CURVE
     #endif
 #endif /* WOLFSSL_ASYNC_CRYPT */
 #ifndef WC_ASYNC_DEV_SIZE
     #define WC_ASYNC_DEV_SIZE 0
 #endif
 
 /* leantls checks */
 #ifdef WOLFSSL_LEANTLS
     #ifndef HAVE_ECC
         #error leantls build needs ECC
     #endif
 #endif /* WOLFSSL_LEANTLS*/
 
 /* restriction with static memory */
 #ifdef WOLFSSL_STATIC_MEMORY
     #if defined(HAVE_IO_POOL) || defined(XMALLOC_USER) || defined(NO_WOLFSSL_MEMORY)
          #error static memory cannot be used with HAVE_IO_POOL, XMALLOC_USER or NO_WOLFSSL_MEMORY
     #endif
     #if !defined(USE_FAST_MATH) && !defined(NO_BIG_INT)
         #error static memory requires fast math please define USE_FAST_MATH
     #endif
     #ifdef WOLFSSL_SMALL_STACK
         #error static memory does not support small stack please undefine
     #endif
 #endif /* WOLFSSL_STATIC_MEMORY */
 
 #ifdef HAVE_AES_KEYWRAP
     #ifndef WOLFSSL_AES_DIRECT
         #error AES key wrap requires AES direct please define WOLFSSL_AES_DIRECT
     #endif
 #endif
 
 #ifdef HAVE_PKCS7
     #if defined(NO_AES) && defined(NO_DES3)
         #error PKCS7 needs either AES or 3DES enabled, please enable one
     #endif
     #ifndef HAVE_AES_KEYWRAP
         #error PKCS7 requires AES key wrap please define HAVE_AES_KEYWRAP
     #endif
     #if defined(HAVE_ECC) && !defined(HAVE_X963_KDF)
         #error PKCS7 requires X963 KDF please define HAVE_X963_KDF
     #endif
 #endif
 
 #ifndef NO_PKCS12
     #undef  HAVE_PKCS12
     #define HAVE_PKCS12
 #endif
 
 #ifndef NO_PKCS8
     #undef  HAVE_PKCS8
     #define HAVE_PKCS8
 #endif
 
 #if !defined(NO_PBKDF1) || defined(WOLFSSL_ENCRYPTED_KEYS) || defined(HAVE_PKCS8) || defined(HAVE_PKCS12)
     #undef  HAVE_PBKDF1
     #define HAVE_PBKDF1
 #endif
 
 #if !defined(NO_PBKDF2) || defined(HAVE_PKCS7) || defined(HAVE_SCRYPT)
     #undef  HAVE_PBKDF2
     #define HAVE_PBKDF2
 #endif
 
 
 #if !defined(WOLFCRYPT_ONLY) && !defined(NO_OLD_TLS) && \
         (defined(NO_SHA) || defined(NO_MD5))
     #error old TLS requires MD5 and SHA
 #endif
 
 /* for backwards compatibility */
 #if defined(TEST_IPV6) && !defined(WOLFSSL_IPV6)
     #define WOLFSSL_IPV6
 #endif
 
 
 #ifdef WOLFSSL_LINUXKM
     #ifndef NO_DEV_RANDOM
         #define NO_DEV_RANDOM
     #endif
     #ifndef NO_WRITEV
         #define NO_WRITEV
     #endif
     #ifndef NO_FILESYSTEM
         #define NO_FILESYSTEM
     #endif
     #ifndef NO_STDIO_FILESYSTEM
         #define NO_STDIO_FILESYSTEM
     #endif
     #ifndef WOLFSSL_NO_SOCK
         #define WOLFSSL_NO_SOCK
     #endif
     #ifndef WOLFSSL_DH_CONST
         #define WOLFSSL_DH_CONST
     #endif
     #ifndef WOLFSSL_USER_IO
         #define WOLFSSL_USER_IO
     #endif
     #ifndef USE_WOLF_STRTOK
         #define USE_WOLF_STRTOK
     #endif
     #ifndef WOLFSSL_SP_MOD_WORD_RP
         #define WOLFSSL_SP_MOD_WORD_RP
     #endif
     #ifndef WOLFSSL_OLD_PRIME_CHECK
         #define WOLFSSL_OLD_PRIME_CHECK
     #endif
     #undef HAVE_STRINGS_H
     #undef HAVE_ERRNO_H
     #undef HAVE_THREAD_LS
     #undef WOLFSSL_HAVE_MIN
     #undef WOLFSSL_HAVE_MAX
     #define SIZEOF_LONG         8
     #define SIZEOF_LONG_LONG    8
     #define CHAR_BIT            8
     #ifndef WOLFSSL_SP_DIV_64
         #define WOLFSSL_SP_DIV_64
     #endif
     #ifndef WOLFSSL_SP_DIV_WORD_HALF
         #define WOLFSSL_SP_DIV_WORD_HALF
     #endif
     #ifndef SP_HALF_SIZE
         #define SP_HALF_SIZE        32
     #endif
     #ifndef SP_HALF_MAX
         #define SP_HALF_MAX         4294967295U
     #endif
 #endif
 
 
 /* Place any other flags or defines here */
 
 #if defined(WOLFSSL_MYSQL_COMPATIBLE) && defined(_WIN32) \
                                       && defined(HAVE_GMTIME_R)
     #undef HAVE_GMTIME_R /* don't trust macro with windows */
 #endif /* WOLFSSL_MYSQL_COMPATIBLE */
 
 #if defined(OPENSSL_ALL) || defined(WOLFSSL_NGINX) || defined(WOLFSSL_HAPROXY)
     #define SSL_OP_NO_COMPRESSION    SSL_OP_NO_COMPRESSION
     #define OPENSSL_NO_ENGINE
     #define X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT
     #ifndef OPENSSL_EXTRA
         #define OPENSSL_EXTRA
     #endif
     #ifndef HAVE_SESSION_TICKET
         #define HAVE_SESSION_TICKET
     #endif
     #ifndef HAVE_OCSP
         #define HAVE_OCSP
     #endif
     #ifndef KEEP_OUR_CERT
         #define KEEP_OUR_CERT
     #endif
     #ifndef HAVE_SNI
         #define HAVE_SNI
     #endif
 #endif
 
 #if defined(WOLFSSL_NGINX) || defined(WOLFSSL_QT) || defined(OPENSSL_ALL)
     #define SSL_CTRL_SET_TLSEXT_HOSTNAME 55
 #endif
 
 
 /* both CURVE and ED small math should be enabled */
 #ifdef CURVED25519_SMALL
         #define CURVE25519_SMALL
         #define ED25519_SMALL
 #endif
 
 /* both CURVE and ED small math should be enabled */
 #ifdef CURVED448_SMALL
         #define CURVE448_SMALL
         #define ED448_SMALL
 #endif
 
 
 #ifndef WOLFSSL_ALERT_COUNT_MAX
     #define WOLFSSL_ALERT_COUNT_MAX 5
 #endif
 
 /* warning for not using harden build options (default with ./configure) */
 #ifndef WC_NO_HARDEN
     #if (defined(USE_FAST_MATH) && !defined(TFM_TIMING_RESISTANT)) || \
         (defined(HAVE_ECC) && !defined(ECC_TIMING_RESISTANT)) || \
         (!defined(NO_RSA) && !defined(WC_RSA_BLINDING) && !defined(HAVE_FIPS) && \
             !defined(WC_NO_RNG))
 
         #ifndef _MSC_VER
             #warning "For timing resistance / side-channel attack prevention consider using harden options"
         #else
             #pragma message("Warning: For timing resistance / side-channel attack prevention consider using harden options")
         #endif
     #endif
 #endif
 
 #if defined(NO_OLD_WC_NAMES) || defined(OPENSSL_EXTRA)
     /* added to have compatibility with SHA256() */
     #if !defined(NO_OLD_SHA_NAMES) && !defined(HAVE_FIPS)
         #define NO_OLD_SHA_NAMES
     #endif
 #endif
 
 /* switch for compatibility layer functionality. Has subparts i.e. BIO/X509
  * When opensslextra is enabled all subparts should be turned on. */
 #ifdef OPENSSL_EXTRA
     #undef  OPENSSL_EXTRA_X509_SMALL
     #define OPENSSL_EXTRA_X509_SMALL
 #endif /* OPENSSL_EXTRA */
 
 /* support for converting DER to PEM */
 #if (defined(WOLFSSL_KEY_GEN) && !defined(WOLFSSL_NO_DER_TO_PEM)) || \
     defined(WOLFSSL_CERT_GEN) || defined(OPENSSL_EXTRA)
     #undef  WOLFSSL_DER_TO_PEM
     #define WOLFSSL_DER_TO_PEM
 #endif
 
 /* keep backwards compatibility enabling encrypted private key */
 #ifndef WOLFSSL_ENCRYPTED_KEYS
     #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL) || \
         defined(HAVE_WEBSERVER)
         #define WOLFSSL_ENCRYPTED_KEYS
     #endif
 #endif
 
 /* support for disabling PEM to DER */
 #if !defined(WOLFSSL_NO_PEM)
     #undef  WOLFSSL_PEM_TO_DER
     #define WOLFSSL_PEM_TO_DER
 #endif
 
 /* Parts of the openssl compatibility layer require peer certs */
 #if defined(OPENSSL_ALL) || defined(WOLFSSL_NGINX) || defined(WOLFSSL_HAPROXY)
     #undef  KEEP_PEER_CERT
     #define KEEP_PEER_CERT
 #endif
 
 /* RAW hash function APIs are not implemented with ARMv8 hardware acceleration*/
 #ifdef WOLFSSL_ARMASM
     #undef  WOLFSSL_NO_HASH_RAW
     #define WOLFSSL_NO_HASH_RAW
 #endif
 
 #if !defined(WOLFSSL_SHA384) && !defined(WOLFSSL_SHA512) && defined(NO_AES) && \
                                                           !defined(WOLFSSL_SHA3)
     #undef  WOLFSSL_NO_WORD64_OPS
     #define WOLFSSL_NO_WORD64_OPS
 #endif
 
 #if !defined(WOLFCRYPT_ONLY) && !defined(WOLFSSL_NO_TLS12)
     #undef  WOLFSSL_HAVE_PRF
     #define WOLFSSL_HAVE_PRF
 #endif
 
 #if defined(NO_AES) && defined(NO_DES3) && !defined(HAVE_CAMELLIA) && \
        !defined(WOLFSSL_HAVE_PRF) && defined(NO_PWDBASED) && !defined(HAVE_IDEA)
     #undef  WOLFSSL_NO_XOR_OPS
     #define WOLFSSL_NO_XOR_OPS
 #endif
 
 #if defined(NO_ASN) && defined(WOLFCRYPT_ONLY)
     #undef  WOLFSSL_NO_INT_ENCODE
     #define WOLFSSL_NO_INT_ENCODE
     #undef  WOLFSSL_NO_INT_DECODE
     #define WOLFSSL_NO_INT_DECODE
 #endif
 
 #if defined(WOLFCRYPT_ONLY) && defined(WOLFSSL_RSA_VERIFY_ONLY) && \
     defined(WC_NO_RSA_OAEP)
     #undef  WOLFSSL_NO_CT_OPS
     #define WOLFSSL_NO_CT_OPS
 #endif
 
 #if defined(WOLFCRYPT_ONLY) && defined(NO_AES) && !defined(HAVE_CURVE25519) && \
         !defined(HAVE_CURVE448) && defined(WC_NO_RNG) && defined(WC_NO_RSA_OAEP)
     #undef  WOLFSSL_NO_CONST_CMP
     #define WOLFSSL_NO_CONST_CMP
 #endif
 
 #if defined(WOLFCRYPT_ONLY) && defined(NO_AES) && !defined(WOLFSSL_SHA384) && \
     !defined(WOLFSSL_SHA512) && defined(WC_NO_RNG) && \
                     defined(WOLFSSL_SP_MATH) && defined(WOLFSSL_RSA_PUBLIC_ONLY)
     #undef  WOLFSSL_NO_FORCE_ZERO
     #define WOLFSSL_NO_FORCE_ZERO
 #endif
 
 /* Detect old cryptodev name */
 #if defined(WOLF_CRYPTO_DEV) && !defined(WOLF_CRYPTO_CB)
     #define WOLF_CRYPTO_CB
 #endif
 
 #if defined(WOLFSSL_TLS13) && defined(WOLFSSL_NO_SIGALG)
     #error TLS 1.3 requires the Signature Algorithms extension to be enabled
 #endif
 
 #ifndef NO_WOLFSSL_BASE64_DECODE
     #define WOLFSSL_BASE64_DECODE
 #endif
 
 #if defined(HAVE_EX_DATA) || defined(FORTRESS)
     #define MAX_EX_DATA 5  /* allow for five items of ex_data */
 #endif
 
 #ifdef NO_WOLFSSL_SMALL_STACK
     #undef WOLFSSL_SMALL_STACK
 #endif
 
 /* The client session cache requires time for timeout */
 #if defined(NO_ASN_TIME) && !defined(NO_SESSION_CACHE)
     #define NO_SESSION_CACHE
 #endif
 
 /* Use static ECC structs for Position Independant Code (PIC) */
 #if defined(__IAR_SYSTEMS_ICC__) && defined(__ROPI__)
     #define WOLFSSL_ECC_CURVE_STATIC
     #define WOLFSSL_NAMES_STATIC
     #define WOLFSSL_NO_CONSTCHARCONST
 #endif
 
 /* FIPS v1 does not support TLS v1.3 (requires RSA PSS and HKDF) */
 #if defined(HAVE_FIPS) && !defined(HAVE_FIPS_VERSION)
     #undef WC_RSA_PSS
     #undef WOLFSSL_TLS13
 #endif
 
 /* For FIPSv2 make sure the ECDSA encoding allows extra bytes
  * but make sure users consider enabling it */
 #if !defined(NO_STRICT_ECDSA_LEN) && defined(HAVE_FIPS) && \
         defined(HAVE_FIPS_VERSION) && (HAVE_FIPS_VERSION >= 2)
     /* ECDSA length checks off by default for CAVP testing
      * consider enabling strict checks in production */
     #define NO_STRICT_ECDSA_LEN
 #endif
 
 
 #ifdef __cplusplus
     }   /* extern "C" */
 #endif
 
 #endif
