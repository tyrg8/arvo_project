commit 5e9f72d3d90e8fc9cb20578a95c891631b4d91da
Author: Liviu Chircu <liviu@opensips.org>
Date:   Thu Nov 3 18:29:44 2022 +0200

    parse_via(): Fix out-of-bounds read edge-case (OSS-Fuzz)
    
    This patch fixes a possible off-by-one read overflow while parsing the
    Via buffer.  Even so, the error was mostly harmless, as the supplied
    buffer is typically much larger and is guaranteed to be NULL-terminated
    (see udp_read_req(), for example).
    
    Severity: Low
    Fixes OSS-Fuzz#52326

diff --git a/parser/parse_via.c b/parser/parse_via.c
index e497bb2ba..667fa39a3 100644
--- a/parser/parse_via.c
+++ b/parser/parse_via.c
@@ -992,1227 +992,1229 @@ char* parse_via(char* buffer, char* end, struct via_body *vbody)
 	vb=vbody; /* keep orignal vbody value, needed to set the error member
 				 in case of multiple via bodies in the same header */
 parse_again:
 	vb->error=PARSE_ERROR;
 	/* parse start of via ( SIP/2.0/UDP    )*/
 	state=F_SIP;
 	saved_state=0; /*it should generate error if it's used without set*/
 	param_start=0;
 	for(tmp=buffer;tmp<end;tmp++){
 		switch(*tmp){
 			case ' ':
 			case'\t':
 				switch(state){
 					case L_VER: /* eat space */
 					case L_PROTO:
 					case F_SIP:
 					case F_VER:
 					case F_PROTO:
 						break;
 					case FIN_UDP:
 						vb->transport.len=tmp-vb->transport.s;
 						vb->proto=PROTO_UDP;
 						state=F_HOST; /* start looking for host*/
 						goto main_via;
 					case FIN_TCP:
 						/* finished proto parsing */
 						vb->transport.len=tmp-vb->transport.s;
 						vb->proto=PROTO_TCP;
 						state=F_HOST; /* start looking for host*/
 						goto main_via;
 					case FIN_TLS:
 						/* finished proto parsing */
 						vb->transport.len=tmp-vb->transport.s;
 						vb->proto=PROTO_TLS;
 						state=F_HOST; /* start looking for host*/
 						goto main_via;
 					case FIN_SCTP:
 						/* finished proto parsing */
 						vb->transport.len=tmp-vb->transport.s;
 						vb->proto=PROTO_SCTP;
 						state=F_HOST; /* start looking for host*/
 						goto main_via;
 					case FIN_WS:
 					case WS_WSS:
 						/* finished proto parsing */
 						vb->transport.len=tmp-vb->transport.s;
 						vb->proto=PROTO_WS;
 						state=F_HOST; /* start looking for host*/
 						goto main_via;
 					case FIN_WSS:
 						/* finished proto parsing */
 						vb->transport.len=tmp-vb->transport.s;
 						vb->proto=PROTO_WSS;
 						state=F_HOST; /* start looking for host*/
 						goto main_via;
 					case OTHER_PROTO:
 						/* finished proto parsing */
 						vb->transport.len=tmp-vb->transport.s;
 						vb->proto=PROTO_OTHER;
 						state=F_HOST; /* start looking for host*/
 						goto main_via;
 					case FIN_SIP:
 						vb->name.len=tmp-vb->name.s;
 						state=L_VER;
 						break;
 					case FIN_VER:
 						vb->version.len=tmp-vb->version.s;
 						state=L_PROTO;
 						break;
 					case F_LF:
 					case F_CRLF:
 					case F_CR: /* header continues on this line */
 						state=saved_state;
 						break;
 					default:
 						LM_ERR("bad char <%c> on state %d\n", *tmp, state);
 						goto parse_error;
 				}
 				break;
 			case '\n':
 				switch(state){
 					case L_VER:
 					case F_SIP:
 					case F_VER:
 					case F_PROTO:
 					case L_PROTO:
 						saved_state=state;
 						state=F_LF;
 						break;
 					case FIN_UDP:
 						vb->transport.len=tmp-vb->transport.s;
 						vb->proto=PROTO_UDP;
 						state=F_LF;
 						saved_state=F_HOST; /* start looking for host*/
 						goto main_via;
 					case FIN_TCP:
 						vb->transport.len=tmp-vb->transport.s;
 						vb->proto=PROTO_TCP;
 						state=F_LF;
 						saved_state=F_HOST; /* start looking for host*/
 						goto main_via;
 					case FIN_TLS:
 						vb->transport.len=tmp-vb->transport.s;
 						vb->proto=PROTO_TLS;
 						state=F_LF;
 						saved_state=F_HOST; /* start looking for host*/
 						goto main_via;
 					case WS_WSS:
 					case FIN_WS:
 						vb->transport.len=tmp-vb->transport.s;
 						vb->proto=PROTO_WS;
 						state=F_LF;
 						saved_state=F_HOST; /* start looking for host*/
 						goto main_via;
 					case FIN_WSS:
 						vb->transport.len=tmp-vb->transport.s;
 						vb->proto=PROTO_WS;
 						state=F_LF;
 						saved_state=F_HOST; /* start looking for host*/
 						goto main_via;
 					case OTHER_PROTO:
 						/* finished proto parsing */
 						vb->transport.len=tmp-vb->transport.s;
 						vb->proto=PROTO_OTHER;
 						state=F_LF;
 						saved_state=F_HOST; /* start looking for host*/
 						goto main_via;
 					case FIN_SIP:
 						vb->name.len=tmp-vb->name.s;
 						state=F_LF;
 						saved_state=L_VER;
 						break;
 					case FIN_VER:
 						vb->version.len=tmp-vb->version.s;
 						state=F_LF;
 						saved_state=L_PROTO;
 						break;
 					case F_CR:
 						state=F_CRLF;
 						break;
 					case F_LF:
 					case F_CRLF:
 						state=saved_state;
 						goto endofheader;
 					default:
 						LM_ERR("bad char <%c> on state %d\n", *tmp, state);
 						goto parse_error;
 				}
 				break;
 			case '\r':
 				switch(state){
 					case L_VER:
 					case F_SIP:
 					case F_VER:
 					case F_PROTO:
 					case L_PROTO:
 						saved_state=state;
 						state=F_CR;
 						break;
 					case FIN_UDP:
 						vb->transport.len=tmp-vb->transport.s;
 						vb->proto=PROTO_UDP;
 						state=F_CR;
 						saved_state=F_HOST;
 						goto main_via;
 					case FIN_TCP:
 						vb->transport.len=tmp-vb->transport.s;
 						vb->proto=PROTO_TCP;
 						state=F_CR;
 						saved_state=F_HOST;
 						goto main_via;
 					case FIN_TLS:
 						vb->transport.len=tmp-vb->transport.s;
 						vb->proto=PROTO_TLS;
 						state=F_CR;
 						saved_state=F_HOST;
 						goto main_via;
 					case WS_WSS:
 					case FIN_WS:
 						vb->transport.len=tmp-vb->transport.s;
 						vb->proto=PROTO_WS;
 						state=F_CR;
 						saved_state=F_HOST;
 						goto main_via;
 					case FIN_WSS:
 						vb->transport.len=tmp-vb->transport.s;
 						vb->proto=PROTO_WSS;
 						state=F_CR;
 						saved_state=F_HOST;
 						goto main_via;
 					case OTHER_PROTO:
 						vb->transport.len=tmp-vb->transport.s;
 						vb->proto=PROTO_OTHER;
 						state=F_CR;
 						saved_state=F_HOST;
 						goto main_via;
 					case FIN_SIP:
 						vb->name.len=tmp-vb->name.s;
 						state=F_CR;
 						saved_state=L_VER;
 						break;
 					case FIN_VER:
 						vb->version.len=tmp-vb->version.s;
 						state=F_CR;
 						saved_state=L_PROTO;
 						break;
 					case F_LF: /*end of line ?next header?*/
 					case F_CR:
 					case F_CRLF:
 						state=saved_state;
 						goto endofheader;
 					default:
 						LM_ERR("bad char <%c> on state %d\n", *tmp, state);
 						goto parse_error;
 				}
 				break;
 
 			case '/':
 				switch(state){
 					case FIN_SIP:
 						vb->name.len=tmp-vb->name.s;
 						state=F_VER;
 						break;
 					case FIN_VER:
 						vb->version.len=tmp-vb->version.s;
 						state=F_PROTO;
 						break;
 					case L_VER:
 						state=F_VER;
 						break;
 					case L_PROTO:
 						state=F_PROTO;
 						break;
 					default:
 						LM_ERR("bad char <%c> on state %d\n", *tmp, state);
 						goto parse_error;
 				}
 				break;
 				/* match SIP*/
 			case 'S':
 			case 's':
 				switch(state){
 					case F_SIP:
 						state=SIP1;
 						vb->name.s=tmp;
 						break;
 					case TLS2:
 						state=FIN_TLS;
 						break;
 					case F_PROTO:
 						state=SCTP1;
 						vb->transport.s=tmp;
 						break;
 					case WS1:
 						state=WS_WSS;
 						break;
 					case WS_WSS:
 						state=FIN_WSS;
 						break;
 					case OTHER_PROTO:
 						break;
 					case UDP1:
 					case UDP2:
 					case FIN_UDP:
 					case TCP_TLS1:
 					case TCP2:
 					case FIN_TCP:
 					case FIN_TLS:
 					case SCTP1:
 					case SCTP2:
 					case SCTP3:
 					case FIN_SCTP:
 					case FIN_WS:
 					case FIN_WSS:
 						state=OTHER_PROTO;
 						break;
 					default:
 						LM_ERR("bad char <%c> on state %d\n", *tmp, state);
 						goto parse_error;
 				}
 				break;
 			case 'I':
 			case 'i':
 				switch(state){
 					case SIP1:
 						state=SIP2;
 						break;
 					case OTHER_PROTO:
 						break;
 					case UDP1:
 					case UDP2:
 					case FIN_UDP:
 					case TCP_TLS1:
 					case TCP2:
 					case FIN_TCP:
 					case TLS2:
 					case FIN_TLS:
 					case SCTP1:
 					case SCTP2:
 					case SCTP3:
 					case FIN_SCTP:
 					case WS1:
 					case WS_WSS:
 					case FIN_WS:
 					case FIN_WSS:
 						state=OTHER_PROTO;
 						break;
 					default:
 						LM_ERR("bad char <%c> on state %d\n", *tmp, state);
 						goto parse_error;
 				}
 				break;
 			case 'p':
 			case 'P':
 				switch(state){
 					case SIP2:
 						state=FIN_SIP;
 						break;
 					/* allow p in PROTO */
 					case UDP2:
 						state=FIN_UDP;
 						break;
 					case TCP2:
 						state=FIN_TCP;
 						break;
 					case SCTP3:
 						state=FIN_SCTP;
 						break;
 					case OTHER_PROTO:
 						break;
 					case UDP1:
 					case FIN_UDP:
 					case TCP_TLS1:
 					case FIN_TCP:
 					case TLS2:
 					case FIN_TLS:
 					case SCTP1:
 					case SCTP2:
 					case FIN_SCTP:
 					case WS1:
 					case WS_WSS:
 					case FIN_WS:
 					case FIN_WSS:
 						state=OTHER_PROTO;
 						break;
 					default:
 						LM_ERR("bad char <%c> on state %d\n", *tmp, state);
 						goto parse_error;
 				}
 				break;
 			case 'U':
 			case 'u':
 				switch(state){
 					case F_PROTO:
 						state=UDP1;
 						vb->transport.s=tmp;
 						break;
 					case OTHER_PROTO:
 						break;
 					case UDP1:
 					case UDP2:
 					case FIN_UDP:
 					case TCP_TLS1:
 					case TCP2:
 					case FIN_TCP:
 					case TLS2:
 					case FIN_TLS:
 					case SCTP1:
 					case SCTP2:
 					case SCTP3:
 					case FIN_SCTP:
 					case WS1:
 					case WS_WSS:
 					case FIN_WS:
 					case FIN_WSS:
 						state=OTHER_PROTO;
 						break;
 					default:
 						LM_ERR("bad char <%c> on state %d\n", *tmp, state);
 						goto parse_error;
 				}
 				break;
 			case 'D':
 			case 'd':
 				switch(state){
 					case UDP1:
 						state=UDP2;
 						break;
 					case OTHER_PROTO:
 						break;
 					case UDP2:
 					case FIN_UDP:
 					case TCP_TLS1:
 					case TCP2:
 					case FIN_TCP:
 					case TLS2:
 					case FIN_TLS:
 					case SCTP1:
 					case SCTP2:
 					case SCTP3:
 					case FIN_SCTP:
 					case WS1:
 					case WS_WSS:
 					case FIN_WS:
 					case FIN_WSS:
 						state=OTHER_PROTO;
 						break;
 					default:
 						LM_ERR("bad char <%c> on state %d\n", *tmp, state);
 						goto parse_error;
 				}
 				break;
 			case 'T':
 			case 't':
 				switch(state){
 					case F_PROTO:
 						state=TCP_TLS1;
 						vb->transport.s=tmp;
 						break;
 					case SCTP2:
 						state=SCTP3;
 						break;
 					case OTHER_PROTO:
 						break;
 					case UDP1:
 					case UDP2:
 					case FIN_UDP:
 					case TCP_TLS1:
 					case TCP2:
 					case FIN_TCP:
 					case TLS2:
 					case FIN_TLS:
 					case SCTP1:
 					case SCTP3:
 					case FIN_SCTP:
 					case WS1:
 					case WS_WSS:
 					case FIN_WS:
 					case FIN_WSS:
 						state=OTHER_PROTO;
 						break;
 					default:
 						LM_ERR("bad char <%c> on state %d\n", *tmp, state);
 						goto parse_error;
 				}
 				break;
 			case 'C':
 			case 'c':
 				switch(state){
 					case TCP_TLS1:
 						state=TCP2;
 						break;
 					case SCTP1:
 						state=SCTP2;
 						break;
 					case OTHER_PROTO:
 						break;
 					case UDP1:
 					case UDP2:
 					case FIN_UDP:
 					case TCP2:
 					case FIN_TCP:
 					case TLS2:
 					case FIN_TLS:
 					case SCTP2:
 					case SCTP3:
 					case FIN_SCTP:
 					case WS1:
 					case WS_WSS:
 					case FIN_WS:
 					case FIN_WSS:
 						state=OTHER_PROTO;
 						break;
 					default:
 						LM_ERR("bad char <%c> on state %d\n", *tmp, state);
 						goto parse_error;
 				}
 				break;
 			case 'L':
 			case 'l':
 				switch(state){
 					case TCP_TLS1:
 						state=TLS2;
 						break;
 					case OTHER_PROTO:
 						break;
 					case UDP1:
 					case UDP2:
 					case FIN_UDP:
 					case TCP2:
 					case FIN_TCP:
 					case TLS2:
 					case FIN_TLS:
 					case SCTP1:
 					case SCTP2:
 					case SCTP3:
 					case FIN_SCTP:
 					case WS1:
 					case WS_WSS:
 					case FIN_WS:
 					case FIN_WSS:
 						state=OTHER_PROTO;
 						break;
 					default:
 						LM_ERR("bad char <%c> on state %d\n", *tmp, state);
 						goto parse_error;
 				}
 				break;
 			case 'W':
 			case 'w':
 				switch(state){
 					case F_PROTO:
 						state=WS1;
 						vb->transport.s=tmp;
 						break;
 					case OTHER_PROTO:
 						break;
 					case UDP1:
 					case UDP2:
 					case FIN_UDP:
 					case TCP_TLS1:
 					case TCP2:
 					case FIN_TCP:
 					case TLS2:
 					case FIN_TLS:
 					case SCTP1:
 					case SCTP2:
 					case SCTP3:
 					case FIN_SCTP:
 					case WS1:
 					case WS_WSS:
 					case FIN_WS:
 					case FIN_WSS:
 						state=OTHER_PROTO;
 						break;
 					default:
 						LM_ERR("bad char <%c> on state %d\n", *tmp, state);
 						goto parse_error;
 				}
 				break;
 			/*match 2.0*/
 			case '2':
 				switch(state){
 					case F_VER:
 						state=VER1;
 						vb->version.s=tmp;
 						break;
 					case OTHER_PROTO:
 						break;
 					case UDP1:
 					case UDP2:
 					case FIN_UDP:
 					case TCP_TLS1:
 					case TCP2:
 					case FIN_TCP:
 					case TLS2:
 					case FIN_TLS:
 					case SCTP1:
 					case SCTP2:
 					case SCTP3:
 					case FIN_SCTP:
 					case WS1:
 					case WS_WSS:
 					case FIN_WS:
 					case FIN_WSS:
 						state=OTHER_PROTO;
 						break;
 					default:
 						LM_ERR("bad char <%c> on state %d\n", *tmp, state);
 						goto parse_error;
 				}
 				break;
 			case '.':
 				switch(state){
 					case VER1:
 						state=VER2;
 						break;
 					case OTHER_PROTO:
 						break;
 					case UDP1:
 					case UDP2:
 					case FIN_UDP:
 					case TCP_TLS1:
 					case TCP2:
 					case FIN_TCP:
 					case TLS2:
 					case FIN_TLS:
 					case SCTP1:
 					case SCTP2:
 					case SCTP3:
 					case FIN_SCTP:
 					case WS1:
 					case WS_WSS:
 					case FIN_WS:
 					case FIN_WSS:
 						state=OTHER_PROTO;
 						break;
 					default:
 						LM_ERR("bad char <%c> on state %d\n", *tmp, state);
 						goto parse_error;
 				}
 				 break;
 			case '0':
 				switch(state){
 					case VER2:
 						state=FIN_VER;
 						break;
 					case OTHER_PROTO:
 						break;
 					case UDP1:
 					case UDP2:
 					case FIN_UDP:
 					case TCP_TLS1:
 					case TCP2:
 					case FIN_TCP:
 					case TLS2:
 					case FIN_TLS:
 					case SCTP1:
 					case SCTP2:
 					case SCTP3:
 					case FIN_SCTP:
 					case WS1:
 					case WS_WSS:
 					case FIN_WS:
 					case FIN_WSS:
 						state=OTHER_PROTO;
 						break;
 					default:
 						LM_ERR("bad char <%c> on state %d\n", *tmp, state);
 						goto parse_error;
 				}
 				break;
 
 			default:
 				switch(state){
 					case F_PROTO:
 						state=OTHER_PROTO;
 						vb->transport.s=tmp;
 						break;
 					case OTHER_PROTO:
 						break;
 					case UDP1:
 					case UDP2:
 					case FIN_UDP:
 					case TCP_TLS1:
 					case TCP2:
 					case FIN_TCP:
 					case TLS2:
 					case FIN_TLS:
 					case SCTP1:
 					case SCTP2:
 					case SCTP3:
 					case FIN_SCTP:
 					case WS1:
 					case WS_WSS:
 					case FIN_WS:
 					case FIN_WSS:
 						state=OTHER_PROTO;
 						break;
 					default:
 						LM_ERR("bad char <%c> on state %d\n", *tmp, state);
 						goto parse_error;
 				}
 				break;
 		}
 	} /* for tmp*/
 
 	/* we should not be here! if everything is ok > main_via*/
 	LM_ERR("bad via: end of packet on state=%d\n", state);
 	goto parse_error;
 
  main_via:
 	/* inc tmp to point to the next char*/
 	tmp++;
 	c_nest=0;
 	/*state should always be F_HOST here*/;
-	for(;*tmp;tmp++){
+	for(;tmp<end;tmp++){
 		switch(*tmp){
 		case ' ':
 		case '\t':
 			switch(state){
 					case F_HOST:/*eat the spaces*/
 						break;
 					case P_HOST:
 						 /*mark end of host*/
 						 vb->host.len=tmp-vb->host.s;
 						 state=L_PORT;
 						 break;
 					case L_PORT: /*eat the spaces*/
 					case F_PORT:
 						break;
 					case P_PORT:
 						/*end of port */
 						vb->port_str.len=tmp-vb->port_str.s;
 						state=L_PARAM;
 						break;
 					case L_PARAM: /* eat the space */
 					case F_PARAM:
 						break;
 					case P_PARAM:
 					/*	*tmp=0;*/ /*!?end of param*/
 						state=L_PARAM;
 						break;
 					case L_VIA:
 					case F_VIA: /* eat the space */
 						break;
 					case F_COMMENT:
 					case P_COMMENT:
 						break;
 					case F_IP6HOST: /*no spaces allowed*/
 					case P_IP6HOST:
 						LM_ERR("bad ipv6 reference\n");
 						goto parse_error;
 					case F_CRLF:
 					case F_LF:
 					case F_CR:
 						/*previous=crlf and now =' '*/
 						state=saved_state;
 						break;
 					default:
 						LM_CRIT("on <%c>, state=%d\n",*tmp, state);
 						goto parse_error;
 				}
 			break;
 			case '\n':
 				switch(state){
 					case F_HOST:/*eat the spaces*/
 					case L_PORT: /*eat the spaces*/
 					case F_PORT:
 					case L_PARAM: /* eat the space */
 					case F_PARAM:
 					case F_VIA: /* eat the space */
 					case L_VIA:
 					case F_COMMENT:
 					case P_COMMENT:
 					case F_IP6HOST:
 					case P_IP6HOST:
 						saved_state=state;
 						state=F_LF;
 						break;
 					case P_HOST:
 						 /*mark end of host*/
 						 vb->host.len=tmp-vb->host.s;
 						 saved_state=L_PORT;
 						 state=F_LF;
 						 break;
 					case P_PORT:
 						/*end of port */
 						vb->port_str.len=tmp-vb->port_str.s;
 						saved_state=L_PARAM;
 						state=F_LF;
 						break;
 					case P_PARAM:
 					/*	*tmp=0;*/ /*!?end of param*/
 						saved_state=L_PARAM;
 						state=F_LF;
 						break;
 					case F_CR:
 						state=F_CRLF;
 						break;
 					case F_CRLF:
 					case F_LF:
 						state=saved_state;
 						goto endofheader;
 					default:
 						LM_CRIT("BUG on <%c>\n",*tmp);
 						goto  parse_error;
 				}
 			break;
 		case '\r':
 				switch(state){
 					case F_HOST:/*eat the spaces*/
 					case L_PORT: /*eat the spaces*/
 					case F_PORT:
 					case L_PARAM: /* eat the space */
 					case F_PARAM:
 					case F_VIA: /* eat the space */
 					case L_VIA:
 					case F_COMMENT:
 					case P_COMMENT:
 					case F_IP6HOST:
 					case P_IP6HOST:
 						saved_state=state;
 						state=F_CR;
 						break;
 					case P_HOST:
 						 /*mark end of host*/
 						 vb->host.len=tmp-vb->host.s;
 						 saved_state=L_PORT;
 						 state=F_CR;
 						 break;
 					case P_PORT:
 						/*end of port */
 						vb->port_str.len=tmp-vb->port_str.s;
 						saved_state=L_PARAM;
 						state=F_CR;
 						break;
 					case P_PARAM:
 					/*	*tmp=0;*/ /*!?end of param*/
 						saved_state=L_PARAM;
 						state=F_CR;
 						break;
 					case F_CRLF:
 					case F_CR:
 					case F_LF:
 						state=saved_state;
 						goto endofheader;
 					default:
 						LM_CRIT("on <%c>\n",*tmp);
 						goto parse_error;
 				}
 			break;
 
 			case ':':
 				switch(state){
 					case F_IP6HOST:
 						state=P_IP6HOST;
 						break;
 					case P_IP6HOST:
 						break;
 					case P_HOST:
 						/*mark  end of host*/
 						vb->host.len=tmp-vb->host.s;
 						state=F_PORT;
 						break;
 					case L_PORT:
 						state=F_PORT;
 						break;
 					case P_PORT:
 						LM_ERR("bad port\n");
 						goto parse_error;
 					case L_PARAM:
 					case F_PARAM:
 					case P_PARAM:
 						LM_ERR("bad char <%c> in state %d\n",
 							*tmp,state);
 						goto parse_error;
 					case L_VIA:
 					case F_VIA:
 						LM_ERR("bad char in compact via\n");
 						goto parse_error;
 					case F_CRLF:
 					case F_LF:
 					case F_CR:
 						/*previous=crlf and now !=' '*/
 						goto endofheader;
 					case F_COMMENT:/*everything is allowed in a comment*/
 						vb->comment.s=tmp;
 						state=P_COMMENT;
 						break;
 					case P_COMMENT: /*everything is allowed in a comment*/
 						break;
 					default:
 						LM_CRIT("on <%c> state %d\n", *tmp, state);
 						goto parse_error;
 				}
 				break;
 			case ';':
 				switch(state){
 					case F_HOST:
 					case F_IP6HOST:
 						LM_ERR(" no host found\n");
 						goto parse_error;
 					case P_IP6HOST:
 						LM_ERR(" bad ipv6 reference\n");
 						goto parse_error;
 					case P_HOST:
 						vb->host.len=tmp-vb->host.s;
 						state=F_PARAM;
 						param_start=tmp+1;
 						break;
 					case P_PORT:
 						/*mark the end*/
 						vb->port_str.len=tmp-vb->port_str.s;
 						/* fall through */
 					case L_PORT:
 					case L_PARAM:
 						state=F_PARAM;
 						param_start=tmp+1;
 						break;
 					case F_PORT:
 						LM_ERR(" bad char <%c> in state %d\n",
 							*tmp,state);
 						goto parse_error;
 					case F_PARAM:
 						LM_ERR("null param?\n");
 						goto parse_error;
 					case P_PARAM:
 						/*hmm next, param?*/
 						state=F_PARAM;
 						param_start=tmp+1;
 						break;
 					case L_VIA:
 					case F_VIA:
 						LM_ERR("bad char <%c> in next via\n", *tmp);
 						goto parse_error;
 					case F_CRLF:
 					case F_LF:
 					case F_CR:
 						/*previous=crlf and now !=' '*/
 						goto endofheader;
 					case F_COMMENT:/*everything is allowed in a comment*/
 						vb->comment.s=tmp;
 						state=P_COMMENT;
 						break;
 					case P_COMMENT: /*everything is allowed in a comment*/
 						break;
 
 					default:
 						LM_CRIT("on <%c> state %d\n", *tmp, state);
 						goto parse_error;
 				}
 			break;
 			case ',':
 				switch(state){
 					case F_HOST:
 					case F_IP6HOST:
 						LM_ERR("no host found\n");
 						goto parse_error;
 					case P_IP6HOST:
 						LM_ERR(" bad ipv6 reference\n");
 						goto parse_error;
 					case P_HOST:
 						/*mark the end*/
 						vb->host.len=tmp-vb->host.s;
 						state=F_VIA;
 						break;
 					case P_PORT:
 						/*mark the end*/
 						vb->port_str.len=tmp-vb->port_str.s;
 						state=F_VIA;
 						break;
 					case L_PORT:
 					case L_PARAM:
 					case P_PARAM:
 					case L_VIA:
 						state=F_VIA;
 						break;
 					case F_PORT:
 					case F_PARAM:
 						LM_ERR("invalid char <%c> in state %d\n", *tmp,state);
 						goto parse_error;
 					case F_VIA:
 						/* do  nothing,  eat ","*/
 						break;
 					case F_CRLF:
 					case F_LF:
 					case F_CR:
 						/*previous=crlf and now !=' '*/
 						goto endofheader;
 					case F_COMMENT:/*everything is allowed in a comment*/
 						vb->comment.s=tmp;
 						state=P_COMMENT;
 						break;
 					case P_COMMENT: /*everything is allowed in a comment*/
 						break;
 					default:
 						LM_CRIT("on <%c> state %d\n",*tmp, state);
 						goto  parse_error;
 				}
 			break;
 			case '(':
 				switch(state){
 					case F_HOST:
 					case F_PORT:
 					case F_PARAM:
 					case F_VIA:
 					case F_IP6HOST:
 					case P_IP6HOST: /*must be terminated in ']'*/
 						LM_ERR(" on <%c> state %d\n", *tmp, state);
 						goto  parse_error;
 					case P_HOST:
 						/*mark the end*/
 						vb->host.len=tmp-vb->host.s;
 						state=F_COMMENT;
 						c_nest++;
 						break;
 					case P_PORT:
 						/*mark the end*/
 						vb->port_str.len=tmp-vb->port_str.s;
 						state=F_COMMENT;
 						c_nest++;
 						break;
 					case P_PARAM:
 						/*mark the end*/
 						vb->params.len=tmp-vb->params.s;
 						state=F_COMMENT;
 						c_nest++;
 						break;
 					case L_PORT:
 					case L_PARAM:
 					case L_VIA:
 						state=F_COMMENT;
 						vb->params.len=tmp-vb->params.s;
 						c_nest++;
 						break;
 					case P_COMMENT:
 					case F_COMMENT:
 						c_nest++;
 						break;
 					case F_CRLF:
 					case F_LF:
 					case F_CR:
 						/*previous=crlf and now !=' '*/
 						goto endofheader;
 					default:
 						LM_CRIT("on <%c> state %d\n", *tmp, state);
 						goto  parse_error;
 				}
 			break;
 			case ')':
 				switch(state){
 					case F_COMMENT:
 					case P_COMMENT:
 						if (c_nest){
 							c_nest--;
 							if(c_nest==0){
 								state=L_VIA;
 								vb->comment.len=tmp-vb->comment.s;
 								break;
 							}
 						}else{
 							LM_ERR(" missing '(' - nesting= %d\n", c_nest);
 							 goto parse_error;
 						}
 						break;
 					case F_HOST:
 					case F_PORT:
 					case F_PARAM:
 					case F_VIA:
 					case P_HOST:
 					case P_PORT:
 					case P_PARAM:
 					case L_PORT:
 					case L_PARAM:
 					case L_VIA:
 					case F_IP6HOST:
 					case P_IP6HOST:
 						LM_ERR(" on <%c> state %d\n",*tmp, state);
 						goto  parse_error;
 					case F_CRLF:
 					case F_LF:
 					case F_CR:
 						/*previous=crlf and now !=' '*/
 						goto endofheader;
 					default:
 						LM_CRIT("on <%c> state %d\n", *tmp, state);
 						goto  parse_error;
 				}
 				break;
 			case '[':
 				switch(state){
 					case F_HOST:
 						vb->host.s=tmp; /* mark start here (include [])*/
 						state=F_IP6HOST;
 						break;
 					case F_COMMENT:/*everything is allowed in a comment*/
 						vb->comment.s=tmp;
 						state=P_COMMENT;
 						break;
 					case P_COMMENT:
 						break;
 					case F_CRLF:
 					case F_LF:
 					case F_CR:
 						/*previous=crlf and now !=' '*/
 						goto endofheader;
 					default:
 						LM_ERR("on <%c> state %d\n",*tmp, state);
 						goto  parse_error;
 				}
 				break;
 			case ']':
 				switch(state){
 					case P_IP6HOST:
 						/*mark the end*/
 						vb->host.len=(tmp-vb->host.s)+1; /* include "]" */
 						state=L_PORT;
 						break;
 					case F_CRLF:
 					case F_LF:
 					case F_CR:
 						/*previous=crlf and now !=' '*/
 						goto endofheader;
 					case F_COMMENT:/*everything is allowed in a comment*/
 						vb->comment.s=tmp;
 						state=P_COMMENT;
 						break;
 					case P_COMMENT:
 						break;
 					default:
 						LM_ERR("on <%c> state %d\n",*tmp, state);
 						goto  parse_error;
 				}
 				break;
+			case '\0':
+				break;
 
 			default:
 				switch(state){
 					case F_HOST:
 						state=P_HOST;
 						vb->host.s=tmp;
 						//break;
 					case P_HOST:
 						/*check if host allowed char*/
 						if ( (*tmp<'a' || *tmp>'z') && (*tmp<'A' || *tmp>'Z')
 						&& (*tmp<'0' || *tmp>'9') && *tmp!='-' && *tmp!='.')
 							goto parse_error;
 						break;
 					case F_PORT:
 						state=P_PORT;
 						vb->port_str.s=tmp;
 						//break;
 					case P_PORT:
 						/*check if number*/
 						if ( *tmp<'0' || *tmp>'9' )
 							goto parse_error;
 						break;
 					case F_PARAM:
 						/*state=P_PARAM*/;
 						if(vb->params.s==0) vb->params.s=param_start;
 						param=pkg_malloc(sizeof(struct via_param));
 						if (param==0){
 							LM_ERR("no pkg memory left\n");
 							goto error;
 						}
 						memset(param,0, sizeof(struct via_param));
 						param->start=param_start;
 						tmp=parse_via_param(tmp, end, &state, &saved_state,
 											param);
 
 						switch(state){
 							case F_PARAM:
 								param_start=tmp+1;
 							case L_PARAM:
 							case F_LF:
 							case F_CR:
 								vb->params.len=tmp - vb->params.s;
 								break;
 							case F_VIA:
 								vb->params.len=param->start+param->size
 												-vb->params.s;
 								break;
 							case END_OF_HEADER:
 								vb->params.len=param->start+param->size
 												-vb->params.s;
 								break;
 							case PARAM_ERROR:
 								pkg_free(param);
 								goto parse_error;
 							default:
 								pkg_free(param);
 								LM_ERR(" after parse_via_param: invalid "
 										"char <%c> on state %d\n",*tmp, state);
 								goto parse_error;
 						}
 						/*add param to the list*/
 						if (vb->last_param)	vb->last_param->next=param;
 						else				vb->param_lst=param;
 						vb->last_param=param;
 						/* update param. shortcuts */
 						switch(param->type){
 							case PARAM_BRANCH:
 								vb->branch=param;
 								break;
 							case PARAM_RECEIVED:
 								vb->received=param;
 								break;
 							case PARAM_RPORT:
 								vb->rport=param;
 								break;
 							case PARAM_I:
 								vb->i=param;
 								break;
 							case PARAM_ALIAS:
 								vb->alias=param;
 								break;
 							case PARAM_MADDR:
 								vb->maddr=param;
 								break;
 						}
 
 						if (state==END_OF_HEADER){
 							state=saved_state;
 							goto endofheader;
 						}
 						break;
 					case P_PARAM:
 						break;
 					case F_VIA:
 						/*vb->next=tmp;*/ /*???*/
 						goto nextvia;
 					case L_PORT:
 					case L_PARAM:
 					case L_VIA:
 						LM_ERR("on <%c> state %d (default)\n",*tmp, state);
 						goto  parse_error;
 					case F_COMMENT:
 						state=P_COMMENT;
 						vb->comment.s=tmp;
 						break;
 					case P_COMMENT:
 						break;
 					case F_IP6HOST:
 						state=P_IP6HOST;
 						//break;
 					case P_IP6HOST:
 						/*check if host allowed char*/
 						if ( (*tmp<'a' || *tmp>'f') && (*tmp<'A' || *tmp>'F')
 						&& (*tmp<'0' || *tmp>'9') && *tmp!=':')
 							goto parse_error;
 						break;
 					case F_CRLF:
 					case F_LF:
 					case F_CR:
 						/*previous=crlf and now !=' '*/
 						goto endofheader;
 					default:
 						LM_CRIT("invalid char <%c> in state %d\n",*tmp, state);
 						goto parse_error;
 				}
 
 
 		}
 	}
 
 	LM_DBG("end of packet reached, state=%d\n", state);
 	goto endofpacket; /*end of packet, probably should be goto error*/
diff --git a/parser/test/test_parser.c b/parser/test/test_parser.c
index d1dc0549d..627effc38 100644
--- a/parser/test/test_parser.c
+++ b/parser/test/test_parser.c
@@ -146,20 +146,24 @@ void test_parse_uri(void)
 static const struct tts {
 	const char *tmsg;
 	int tres;
 } tset[] = {
 	{
 		/* test for read overflows on EoH parsing */
 		"e \xff\xff\xff\xff     \xff\n\xff\xff  ",
 		-1,
 	}, {
 		/* test for read overflows on To header param parsing */
 		"d  \x02\x80\0\nt\0:G;150=\"a8",
 		-1,
 	}, {
 		/* test for read overflows on bad header body (no \n ending) */
 		"m  r\nu:c \x1b\r   : ]",
 		-1,
+	}, {
+		/* test for read overflow on Via header (the @end pointer) */
+		"Q e  M\nV:SIP/2.0  /1P 4rr;TT;TT;TT;TT;TT;TT;T\xd2;TT;",
+		-1,
 	},
 
 	{"\0", 0},
 };
