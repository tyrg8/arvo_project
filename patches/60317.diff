commit a77f5019f5731d79eb6f6dee7c3eb2d9d447ef2c
Author: James Almer <jamrial@gmail.com>
Date:   Fri Jun 30 22:20:28 2023 -0300

    avcodec/cbs_h266: store SubpicIdVal in the context
    
    And use it to derive CurrSubpicIdx
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavcodec/cbs_h266.h b/libavcodec/cbs_h266.h
index be3c744426..9e823919af 100644
--- a/libavcodec/cbs_h266.h
+++ b/libavcodec/cbs_h266.h
@@ -458,100 +458,101 @@ typedef struct H266RawSPS {
 typedef struct H266RawPPS {
     H266RawNALUnitHeader nal_unit_header;
 
     uint8_t  pps_pic_parameter_set_id;
     uint8_t  pps_seq_parameter_set_id;
     uint8_t  pps_mixed_nalu_types_in_pic_flag;
     uint16_t pps_pic_width_in_luma_samples;
     uint16_t pps_pic_height_in_luma_samples;
 
     uint8_t  pps_conformance_window_flag;
     uint16_t pps_conf_win_left_offset;
     uint16_t pps_conf_win_right_offset;
     uint16_t pps_conf_win_top_offset;
     uint16_t pps_conf_win_bottom_offset;
 
     uint8_t  pps_scaling_window_explicit_signalling_flag;
     int16_t  pps_scaling_win_left_offset;
     int16_t  pps_scaling_win_right_offset;
     int16_t  pps_scaling_win_top_offset;
     int16_t  pps_scaling_win_bottom_offset;
 
     uint8_t  pps_output_flag_present_flag;
     uint8_t  pps_no_pic_partition_flag;
 
     uint8_t  pps_subpic_id_mapping_present_flag;
     uint16_t pps_num_subpics_minus1;
     uint8_t  pps_subpic_id_len_minus1;
     uint16_t pps_subpic_id[VVC_MAX_SLICES];
 
     uint8_t  pps_log2_ctu_size_minus5;
     uint8_t  pps_num_exp_tile_columns_minus1;
     uint8_t  pps_num_exp_tile_rows_minus1;
     uint16_t pps_tile_column_width_minus1[VVC_MAX_TILE_COLUMNS];
     uint16_t pps_tile_row_height_minus1[VVC_MAX_TILE_ROWS];
 
     uint8_t  pps_loop_filter_across_tiles_enabled_flag;
     uint8_t  pps_rect_slice_flag;
     uint8_t  pps_single_slice_per_subpic_flag;
 
     uint16_t pps_num_slices_in_pic_minus1;
     uint8_t  pps_tile_idx_delta_present_flag;
     uint16_t pps_slice_width_in_tiles_minus1[VVC_MAX_SLICES];
     uint16_t pps_slice_height_in_tiles_minus1[VVC_MAX_SLICES];
     uint16_t pps_num_exp_slices_in_tile[VVC_MAX_SLICES];
     uint16_t pps_exp_slice_height_in_ctus_minus1[VVC_MAX_SLICES][VVC_MAX_TILE_ROWS];
     int16_t  pps_tile_idx_delta_val[VVC_MAX_SLICES];
 
     uint8_t  pps_loop_filter_across_slices_enabled_flag;
     uint8_t  pps_cabac_init_present_flag;
     uint8_t  pps_num_ref_idx_default_active_minus1[2];
     uint8_t  pps_rpl1_idx_present_flag;
     uint8_t  pps_weighted_pred_flag;
     uint8_t  pps_weighted_bipred_flag;
     uint8_t  pps_ref_wraparound_enabled_flag;
     uint16_t  pps_pic_width_minus_wraparound_offset;
     int8_t   pps_init_qp_minus26;
     uint8_t  pps_cu_qp_delta_enabled_flag;
     uint8_t  pps_chroma_tool_offsets_present_flag;
     int8_t   pps_cb_qp_offset;
     int8_t   pps_cr_qp_offset;
     uint8_t  pps_joint_cbcr_qp_offset_present_flag;
     int8_t   pps_joint_cbcr_qp_offset_value;
     uint8_t  pps_slice_chroma_qp_offsets_present_flag;
     uint8_t  pps_cu_chroma_qp_offset_list_enabled_flag;
     uint8_t  pps_chroma_qp_offset_list_len_minus1;
     uint8_t  pps_cb_qp_offset_list[6];
     uint8_t  pps_cr_qp_offset_list[6];
     uint8_t  pps_joint_cbcr_qp_offset_list[6];
     uint8_t  pps_deblocking_filter_control_present_flag;
     uint8_t  pps_deblocking_filter_override_enabled_flag;
     uint8_t  pps_deblocking_filter_disabled_flag;
     uint8_t  pps_dbf_info_in_ph_flag;
 
     int8_t   pps_luma_beta_offset_div2;
     int8_t   pps_luma_tc_offset_div2;
     int8_t   pps_cb_beta_offset_div2;
     int8_t   pps_cb_tc_offset_div2;
     int8_t   pps_cr_beta_offset_div2;
     int8_t   pps_cr_tc_offset_div2;
 
     uint8_t  pps_rpl_info_in_ph_flag;
     uint8_t  pps_sao_info_in_ph_flag;
     uint8_t  pps_alf_info_in_ph_flag;
     uint8_t  pps_wp_info_in_ph_flag;
     uint8_t  pps_qp_delta_info_in_ph_flag;
 
     uint8_t  pps_picture_header_extension_present_flag;
     uint8_t  pps_slice_header_extension_present_flag;
     uint8_t  pps_extension_flag;
     H266RawExtensionData extension_data;
 
     //calculated value;
     uint16_t num_tile_columns;
     uint16_t num_tile_rows;
     uint16_t num_tiles_in_pic;
     uint16_t slice_height_in_ctus[VVC_MAX_SLICES];
     uint16_t num_slices_in_subpic[VVC_MAX_SLICES];
+    uint16_t sub_pic_id_val[VVC_MAX_SLICES];
 } H266RawPPS;
 
 typedef struct H266RawAUD {
diff --git a/libavcodec/cbs_h266_syntax_template.c b/libavcodec/cbs_h266_syntax_template.c
index f48b89cac9..f1cd45f815 100644
--- a/libavcodec/cbs_h266_syntax_template.c
+++ b/libavcodec/cbs_h266_syntax_template.c
@@ -1530,595 +1530,604 @@ static int FUNC(sps)(CodedBitstreamContext *ctx, RWContext *rw,
 static int FUNC(pps) (CodedBitstreamContext *ctx, RWContext *rw,
                       H266RawPPS *current)
 {
     CodedBitstreamH266Context *h266 = ctx->priv_data;
     const H266RawSPS *sps;
     int err, i;
     unsigned int min_cb_size_y, divisor, ctb_size_y,
         pic_width_in_ctbs_y, pic_height_in_ctbs_y;
     uint8_t sub_width_c, sub_height_c, qp_bd_offset;
 
     static const uint8_t h266_sub_width_c[] = {
         1, 2, 2, 1
     };
     static const uint8_t h266_sub_height_c[] = {
         1, 2, 1, 1
     };
 
     HEADER("Picture Parameter Set");
 
     CHECK(FUNC(nal_unit_header) (ctx, rw,
                                  &current->nal_unit_header, VVC_PPS_NUT));
 
     ub(6, pps_pic_parameter_set_id);
     ub(4, pps_seq_parameter_set_id);
     sps = h266->sps[current->pps_seq_parameter_set_id];
     if (!sps) {
         av_log(ctx->log_ctx, AV_LOG_ERROR, "SPS id %d not available.\n",
                current->pps_seq_parameter_set_id);
         return AVERROR_INVALIDDATA;
     }
 
     flag(pps_mixed_nalu_types_in_pic_flag);
     ue(pps_pic_width_in_luma_samples,
        1, sps->sps_pic_width_max_in_luma_samples);
     ue(pps_pic_height_in_luma_samples,
        1, sps->sps_pic_height_max_in_luma_samples);
 
     min_cb_size_y = 1 << (sps->sps_log2_min_luma_coding_block_size_minus2 + 2);
     divisor = FFMAX(min_cb_size_y, 8);
     if (current->pps_pic_width_in_luma_samples % divisor ||
         current->pps_pic_height_in_luma_samples % divisor) {
         av_log(ctx->log_ctx, AV_LOG_ERROR,
                "Invalid dimensions: %ux%u not divisible "
                "by %u, MinCbSizeY = %u.\n",
                current->pps_pic_width_in_luma_samples,
                current->pps_pic_height_in_luma_samples, divisor, min_cb_size_y);
         return AVERROR_INVALIDDATA;
     }
     if (!sps->sps_res_change_in_clvs_allowed_flag &&
         (current->pps_pic_width_in_luma_samples !=
          sps->sps_pic_width_max_in_luma_samples ||
          current->pps_pic_height_in_luma_samples !=
          sps->sps_pic_height_max_in_luma_samples)) {
         av_log(ctx->log_ctx, AV_LOG_ERROR,
                "Resoltuion change is not allowed, "
                "in max resolution (%ux%u) mismatched with pps(%ux%u).\n",
                sps->sps_pic_width_max_in_luma_samples,
                sps->sps_pic_height_max_in_luma_samples,
                current->pps_pic_width_in_luma_samples,
                current->pps_pic_height_in_luma_samples);
         return AVERROR_INVALIDDATA;
     }
 
     ctb_size_y = 1 << (sps->sps_log2_ctu_size_minus5 + 5);
     if (sps->sps_ref_wraparound_enabled_flag) {
         if ((ctb_size_y / min_cb_size_y + 1) >
             (current->pps_pic_width_in_luma_samples / min_cb_size_y - 1)) {
             av_log(ctx->log_ctx, AV_LOG_ERROR,
                    "Invalid width(%u), ctb_size_y = %u, min_cb_size_y = %u.\n",
                    current->pps_pic_width_in_luma_samples,
                    ctb_size_y, min_cb_size_y);
             return AVERROR_INVALIDDATA;
         }
     }
 
     flag(pps_conformance_window_flag);
     if (current->pps_pic_width_in_luma_samples ==
         sps->sps_pic_width_max_in_luma_samples &&
         current->pps_pic_height_in_luma_samples ==
         sps->sps_pic_height_max_in_luma_samples &&
         current->pps_conformance_window_flag) {
         av_log(ctx->log_ctx, AV_LOG_ERROR,
                "Conformance window flag should not true.\n");
         return AVERROR_INVALIDDATA;
     }
 
     sub_width_c = h266_sub_width_c[sps->sps_chroma_format_idc];
     sub_height_c = h266_sub_height_c[sps->sps_chroma_format_idc];
     if (current->pps_conformance_window_flag) {
         ue(pps_conf_win_left_offset, 0, current->pps_pic_width_in_luma_samples);
         ue(pps_conf_win_right_offset,
            0, current->pps_pic_width_in_luma_samples);
         ue(pps_conf_win_top_offset, 0, current->pps_pic_height_in_luma_samples);
         ue(pps_conf_win_bottom_offset,
            0, current->pps_pic_height_in_luma_samples);
         if (sub_width_c *
             (current->pps_conf_win_left_offset +
              current->pps_conf_win_right_offset) >=
             current->pps_pic_width_in_luma_samples ||
             sub_height_c *
             (current->pps_conf_win_top_offset +
              current->pps_conf_win_bottom_offset) >=
             current->pps_pic_height_in_luma_samples) {
             av_log(ctx->log_ctx, AV_LOG_ERROR,
                    "Invalid pps conformance window: (%u, %u, %u, %u), "
                    "resolution is %ux%u, sub wxh is %ux%u.\n",
                    current->pps_conf_win_left_offset,
                    current->pps_conf_win_right_offset,
                    current->pps_conf_win_top_offset,
                    current->pps_conf_win_bottom_offset,
                    current->pps_pic_width_in_luma_samples,
                    current->pps_pic_height_in_luma_samples,
                    sub_width_c, sub_height_c);
             return AVERROR_INVALIDDATA;
         }
     } else {
         if (current->pps_pic_width_in_luma_samples ==
             sps->sps_pic_width_max_in_luma_samples &&
             current->pps_pic_height_in_luma_samples ==
             sps->sps_pic_height_max_in_luma_samples) {
             infer(pps_conf_win_left_offset, sps->sps_conf_win_left_offset);
             infer(pps_conf_win_right_offset, sps->sps_conf_win_right_offset);
             infer(pps_conf_win_top_offset, sps->sps_conf_win_top_offset);
             infer(pps_conf_win_bottom_offset, sps->sps_conf_win_bottom_offset);
         } else {
             infer(pps_conf_win_left_offset, 0);
             infer(pps_conf_win_right_offset, 0);
             infer(pps_conf_win_top_offset, 0);
             infer(pps_conf_win_bottom_offset, 0);
         }
 
     }
 
     flag(pps_scaling_window_explicit_signalling_flag);
     if (!sps->sps_ref_pic_resampling_enabled_flag &&
         current->pps_scaling_window_explicit_signalling_flag) {
         av_log(ctx->log_ctx, AV_LOG_ERROR,
                "Invalid data: sps_ref_pic_resampling_enabled_flag is false, "
                "but pps_scaling_window_explicit_signalling_flag is true.\n");
         return AVERROR_INVALIDDATA;
     }
     if (current->pps_scaling_window_explicit_signalling_flag) {
         se(pps_scaling_win_left_offset,
            -current->pps_pic_width_in_luma_samples * 15 / sub_width_c,
            current->pps_pic_width_in_luma_samples / sub_width_c);
         se(pps_scaling_win_right_offset,
            -current->pps_pic_width_in_luma_samples * 15 / sub_width_c,
            current->pps_pic_width_in_luma_samples / sub_width_c);
         se(pps_scaling_win_top_offset,
            -current->pps_pic_height_in_luma_samples * 15 / sub_height_c,
            current->pps_pic_height_in_luma_samples / sub_height_c);
         se(pps_scaling_win_bottom_offset,
            -current->pps_pic_height_in_luma_samples * 15 / sub_height_c,
            current->pps_pic_height_in_luma_samples / sub_height_c);
     } else {
         infer(pps_scaling_win_left_offset, current->pps_conf_win_left_offset);
         infer(pps_scaling_win_right_offset, current->pps_conf_win_right_offset);
         infer(pps_scaling_win_top_offset, current->pps_conf_win_top_offset);
         infer(pps_scaling_win_bottom_offset, current->pps_conf_win_bottom_offset);
     }
 
     flag(pps_output_flag_present_flag);
     flag(pps_no_pic_partition_flag);
     flag(pps_subpic_id_mapping_present_flag);
 
     if (current->pps_subpic_id_mapping_present_flag) {
         if (!current->pps_no_pic_partition_flag) {
             ue(pps_num_subpics_minus1,
                sps->sps_num_subpics_minus1, sps->sps_num_subpics_minus1);
         } else {
             infer(pps_num_subpics_minus1, 0);
         }
         ue(pps_subpic_id_len_minus1, sps->sps_subpic_id_len_minus1,
            sps->sps_subpic_id_len_minus1);
         for (i = 0; i <= current->pps_num_subpics_minus1; i++) {
             ubs(sps->sps_subpic_id_len_minus1 + 1, pps_subpic_id[i], 1, i);
         }
     }
 
+    for (i = 0; i <= sps->sps_num_subpics_minus1; i++) {
+        if (sps->sps_subpic_id_mapping_explicitly_signalled_flag)
+            current->sub_pic_id_val[i] = current->pps_subpic_id_mapping_present_flag
+                                       ? current->pps_subpic_id[i]
+                                       : sps->sps_subpic_id[i];
+        else
+            current->sub_pic_id_val[i] = i;
+    }
+
     pic_width_in_ctbs_y = AV_CEIL_RSHIFT
         (current->pps_pic_width_in_luma_samples, (sps->sps_log2_ctu_size_minus5 + 5));
     pic_height_in_ctbs_y = AV_CEIL_RSHIFT(
         current->pps_pic_height_in_luma_samples,(sps->sps_log2_ctu_size_minus5 + 5));
     if (!current->pps_no_pic_partition_flag) {
         unsigned int exp_tile_width = 0, exp_tile_height = 0;
         unsigned int unified_size, remaining_size;
 
         u(2, pps_log2_ctu_size_minus5,
           sps->sps_log2_ctu_size_minus5, sps->sps_log2_ctu_size_minus5);
         ue(pps_num_exp_tile_columns_minus1,
            0, FFMIN(pic_width_in_ctbs_y - 1, VVC_MAX_TILE_COLUMNS - 1));
         ue(pps_num_exp_tile_rows_minus1,
            0, FFMIN(pic_height_in_ctbs_y - 1, VVC_MAX_TILE_ROWS - 1));
 
         for (i = 0; i <= current->pps_num_exp_tile_columns_minus1; i++) {
             ues(pps_tile_column_width_minus1[i],
                 0, pic_width_in_ctbs_y - exp_tile_width - 1, 1, i);
             exp_tile_width += current->pps_tile_column_width_minus1[i] + 1;
         }
         for (i = 0; i <= current->pps_num_exp_tile_rows_minus1; i++) {
             ues(pps_tile_row_height_minus1[i],
                 0, pic_height_in_ctbs_y - 1, 1, i);
             exp_tile_height += current->pps_tile_row_height_minus1[i] + 1;
         }
 
         remaining_size = pic_width_in_ctbs_y;
         for (i = 0; i <= current->pps_num_exp_tile_columns_minus1; i++) {
           if (current->pps_tile_column_width_minus1[i] >= remaining_size) {
               av_log(ctx->log_ctx, AV_LOG_ERROR,
                      "Tile column width(%d) exceeds picture width\n",i);
               return AVERROR_INVALIDDATA;
           }
           remaining_size -= (current->pps_tile_column_width_minus1[i] + 1);
         }
         unified_size = (i == 0 ? pic_width_in_ctbs_y :
                         (current->pps_tile_column_width_minus1[i - 1] + 1));
         while (remaining_size > 0) {
             if (current->num_tile_columns > VVC_MAX_TILE_COLUMNS) {
                 av_log(ctx->log_ctx, AV_LOG_ERROR,
                        "NumTileColumns(%d) > than VVC_MAX_TILE_COLUMNS(%d)\n",
                        current->num_tile_columns, VVC_MAX_TILE_COLUMNS);
                 return AVERROR_INVALIDDATA;
             }
             unified_size = FFMIN(remaining_size, unified_size);
             current->pps_tile_column_width_minus1[i] = unified_size - 1;
             remaining_size -= unified_size;
             i++;
         }
         current->num_tile_columns = i;
         if (current->num_tile_columns > VVC_MAX_TILE_COLUMNS) {
             av_log(ctx->log_ctx, AV_LOG_ERROR,
                    "NumTileColumns(%d) > than VVC_MAX_TILE_COLUMNS(%d)\n",
                    current->num_tile_columns, VVC_MAX_TILE_COLUMNS);
             return AVERROR_INVALIDDATA;
         }
 
         remaining_size = pic_height_in_ctbs_y;
         for (i = 0; i <= current->pps_num_exp_tile_rows_minus1; i++) {
           if (current->pps_tile_row_height_minus1[i] >= remaining_size) {
               av_log(ctx->log_ctx, AV_LOG_ERROR,
                      "Tile row height(%d) exceeds picture height\n",i);
               return AVERROR_INVALIDDATA;
           }
           remaining_size -= (current->pps_tile_row_height_minus1[i] + 1);
         }
         unified_size = (i == 0 ? pic_height_in_ctbs_y :
                         (current->pps_tile_row_height_minus1[i - 1] + 1));
 
         while (remaining_size > 0) {
             unified_size = FFMIN(remaining_size, unified_size);
             current->pps_tile_row_height_minus1[i] = unified_size - 1;
             remaining_size -= unified_size;
             i++;
         }
         current->num_tile_rows=i;
         if (current->num_tile_rows > VVC_MAX_TILE_ROWS) {
             av_log(ctx->log_ctx, AV_LOG_ERROR,
                    "NumTileRows(%d) > than VVC_MAX_TILE_ROWS(%d)\n",
                    current->num_tile_rows, VVC_MAX_TILE_ROWS);
             return AVERROR_INVALIDDATA;
         }
 
         current->num_tiles_in_pic = current->num_tile_columns *
                                     current->num_tile_rows;
         if (current->num_tiles_in_pic > VVC_MAX_TILES_PER_AU) {
             av_log(ctx->log_ctx, AV_LOG_ERROR,
                    "NumTilesInPic(%d) > than VVC_MAX_TILES_PER_AU(%d)\n",
                    current->num_tiles_in_pic, VVC_MAX_TILES_PER_AU);
             return AVERROR_INVALIDDATA;
         }
 
         if (current->num_tiles_in_pic > 1) {
             flag(pps_loop_filter_across_tiles_enabled_flag);
             flag(pps_rect_slice_flag);
         } else {
             infer(pps_loop_filter_across_tiles_enabled_flag, 0);
             infer(pps_rect_slice_flag, 1);
         }
         if (current->pps_rect_slice_flag)
             flag(pps_single_slice_per_subpic_flag);
         else
             infer(pps_single_slice_per_subpic_flag, 1);
         if (current->pps_rect_slice_flag &&
             !current->pps_single_slice_per_subpic_flag) {
             int j;
             uint16_t tile_idx = 0, tile_x, tile_y, ctu_x, ctu_y;
             uint16_t slice_top_left_ctu_x[VVC_MAX_SLICES];
             uint16_t slice_top_left_ctu_y[VVC_MAX_SLICES];
             ue(pps_num_slices_in_pic_minus1, 0, VVC_MAX_SLICES - 1);
             if (current->pps_num_slices_in_pic_minus1 > 1)
                 flag(pps_tile_idx_delta_present_flag);
             else
                 infer(pps_tile_idx_delta_present_flag, 0);
             for (i = 0; i < current->pps_num_slices_in_pic_minus1; i++) {
                 tile_x = tile_idx % current->num_tile_columns;
                 tile_y = tile_idx / current->num_tile_columns;
                 if (tile_x != current->num_tile_columns - 1) {
                     ues(pps_slice_width_in_tiles_minus1[i],
                         0, current->num_tile_columns - 1, 1, i);
                 } else {
                     infer(pps_slice_width_in_tiles_minus1[i], 0);
                 }
                 if (tile_y != current->num_tile_rows - 1 &&
                     (current->pps_tile_idx_delta_present_flag || tile_x == 0)) {
                     ues(pps_slice_height_in_tiles_minus1[i],
                         0, current->num_tile_rows - 1, 1, i);
                 } else {
                     if (tile_y == current->num_tile_rows - 1)
                         infer(pps_slice_height_in_tiles_minus1[i], 0);
                     else
                         infer(pps_slice_height_in_tiles_minus1[i],
                               current->pps_slice_height_in_tiles_minus1[i - 1]);
                 }
 
                 ctu_x = ctu_y = 0;
                 for (j = 0; j < tile_x; j++) {
                     ctu_x += current->pps_tile_column_width_minus1[j] + 1;
                 }
                 for (j = 0; j < tile_y; j++) {
                     ctu_y += current->pps_tile_row_height_minus1[j] + 1;
                 }
                 if (current->pps_slice_width_in_tiles_minus1[i] == 0 &&
                     current->pps_slice_height_in_tiles_minus1[i] == 0 &&
                     current->pps_tile_row_height_minus1[tile_y] > 0) {
                     int num_slices_in_tile,
                         uniform_slice_height, remaining_height_in_ctbs_y;
                     remaining_height_in_ctbs_y =
                         current->pps_tile_row_height_minus1[tile_y] + 1;
                     ues(pps_num_exp_slices_in_tile[i],
                         0, current->pps_tile_row_height_minus1[tile_y], 1, i);
                     if (current->pps_num_exp_slices_in_tile[i] == 0) {
                         num_slices_in_tile = 1;
                         slice_top_left_ctu_x[i] = ctu_x;
                         slice_top_left_ctu_y[i] = ctu_y;
                     } else {
                         uint16_t slice_height_in_ctus;
                         for (j = 0; j < current->pps_num_exp_slices_in_tile[i];
                              j++) {
                             ues(pps_exp_slice_height_in_ctus_minus1[i][j], 0,
                                 current->pps_tile_row_height_minus1[tile_y], 2,
                                 i, j);
                             slice_height_in_ctus =
                                 current->
                                 pps_exp_slice_height_in_ctus_minus1[i][j] + 1;
 
                             current->slice_height_in_ctus[i + j] =
                                 slice_height_in_ctus;
                             slice_top_left_ctu_x[i + j] = ctu_x;
                             slice_top_left_ctu_y[i + j] = ctu_y;
                             ctu_y += slice_height_in_ctus;
 
                             remaining_height_in_ctbs_y -= slice_height_in_ctus;
                         }
                         uniform_slice_height = 1 +
                             (j == 0 ? current->pps_tile_row_height_minus1[tile_y] :
                             current->pps_exp_slice_height_in_ctus_minus1[i][j-1]);
                         while (remaining_height_in_ctbs_y > uniform_slice_height) {
                             current->slice_height_in_ctus[i + j] =
                                                           uniform_slice_height;
                             slice_top_left_ctu_x[i + j] = ctu_x;
                             slice_top_left_ctu_y[i + j] = ctu_y;
                             ctu_y += uniform_slice_height;
 
                             remaining_height_in_ctbs_y -= uniform_slice_height;
                             j++;
                         }
                         if (remaining_height_in_ctbs_y > 0) {
                             current->slice_height_in_ctus[i + j] =
                                 remaining_height_in_ctbs_y;
                             slice_top_left_ctu_x[i + j] = ctu_x;
                             slice_top_left_ctu_y[i + j] = ctu_y;
                             j++;
                         }
                         num_slices_in_tile = j;
                     }
                     i += num_slices_in_tile - 1;
                 } else {
                     uint16_t height = 0;
                     infer(pps_num_exp_slices_in_tile[i], 0);
                     for (j = 0;
                          j <= current->pps_slice_height_in_tiles_minus1[i];
                          j++) {
                         height +=
                            current->pps_tile_row_height_minus1[tile_y + j] + 1;
                     }
                     current->slice_height_in_ctus[i] = height;
 
                     slice_top_left_ctu_x[i] = ctu_x;
                     slice_top_left_ctu_y[i] = ctu_y;
                 }
                 if (i < current->pps_num_slices_in_pic_minus1) {
                     if (current->pps_tile_idx_delta_present_flag) {
                         ses(pps_tile_idx_delta_val[i],
                             -current->num_tiles_in_pic + 1,
                             current->num_tiles_in_pic - 1, 1, i);
                         if (current->pps_tile_idx_delta_val[i] == 0) {
                             av_log(ctx->log_ctx, AV_LOG_ERROR,
                                    "pps_tile_idx_delta_val[i] shall not be equal to 0.\n");
                         }
                         tile_idx += current->pps_tile_idx_delta_val[i];
                     } else {
                         infer(pps_tile_idx_delta_val[i], 0);
                         tile_idx +=
                             current->pps_slice_width_in_tiles_minus1[i] + 1;
                         if (tile_idx % current->num_tile_columns == 0) {
                             tile_idx +=
                                 current->pps_slice_height_in_tiles_minus1[i] *
                                 current->num_tile_columns;
                         }
                     }
                 }
             }
             if (i == current->pps_num_slices_in_pic_minus1) {
                 uint16_t height = 0;
 
                 tile_x = tile_idx % current->num_tile_columns;
                 tile_y = tile_idx / current->num_tile_columns;
 
                 ctu_x = 0, ctu_y = 0;
                 for (j = 0; j < tile_x; j++) {
                     ctu_x += current->pps_tile_column_width_minus1[j] + 1;
                 }
                 for (j = 0; j < tile_y; j++) {
                     ctu_y += current->pps_tile_row_height_minus1[j] + 1;
                 }
                 slice_top_left_ctu_x[i] = ctu_x;
                 slice_top_left_ctu_y[i] = ctu_y;
 
                 current->pps_slice_width_in_tiles_minus1[i] =
                     current->num_tile_columns - tile_x - 1;
                 current->pps_slice_height_in_tiles_minus1[i] =
                     current->num_tile_rows - tile_y - 1;
 
                 for (j = 0; j <= current->pps_slice_height_in_tiles_minus1[i];
                      j++) {
                     height +=
                         current->pps_tile_row_height_minus1[tile_y + j] + 1;
                 }
                 current->slice_height_in_ctus[i] = height;
 
                 infer(pps_num_exp_slices_in_tile[i], 0);
             }
             //now, we got all slice information, let's resolve NumSlicesInSubpic
             for (i = 0; i <= sps->sps_num_subpics_minus1; i++) {
                 current->num_slices_in_subpic[i] = 0;
                 for (j = 0; j <= current->pps_num_slices_in_pic_minus1; j++) {
                     uint16_t pos_x = 0, pos_y = 0;
                     pos_x = slice_top_left_ctu_x[j];
                     pos_y = slice_top_left_ctu_y[j];
                     if ((pos_x >= sps->sps_subpic_ctu_top_left_x[i]) &&
                         (pos_x <
                          sps->sps_subpic_ctu_top_left_x[i] +
                          sps->sps_subpic_width_minus1[i] + 1) &&
                          (pos_y >= sps->sps_subpic_ctu_top_left_y[i]) &&
                          (pos_y < sps->sps_subpic_ctu_top_left_y[i] +
                             sps->sps_subpic_height_minus1[i] + 1)) {
                         current->num_slices_in_subpic[i]++;
                     }
                 }
             }
         } else {
             if (current->pps_no_pic_partition_flag)
                 infer(pps_num_slices_in_pic_minus1, 0);
             else if (current->pps_single_slice_per_subpic_flag)
                 infer(pps_num_slices_in_pic_minus1,
                       sps->sps_num_subpics_minus1);
             // else?
         }
         if (!current->pps_rect_slice_flag ||
             current->pps_single_slice_per_subpic_flag ||
             current->pps_num_slices_in_pic_minus1 > 0)
             flag(pps_loop_filter_across_slices_enabled_flag);
         else
             infer(pps_loop_filter_across_slices_enabled_flag, 0);
     } else {
         infer(pps_num_exp_tile_columns_minus1, 0);
         infer(pps_tile_column_width_minus1[0], pic_width_in_ctbs_y - 1);
         infer(pps_num_exp_tile_rows_minus1, 0);
         infer(pps_tile_row_height_minus1[0], pic_height_in_ctbs_y - 1);
         infer(num_tile_columns, 1);
         infer(num_tile_rows, 1);
         infer(num_tiles_in_pic, 1);
     }
 
     flag(pps_cabac_init_present_flag);
     for (i = 0; i < 2; i++)
         ues(pps_num_ref_idx_default_active_minus1[i], 0, 14, 1, i);
     flag(pps_rpl1_idx_present_flag);
     flag(pps_weighted_pred_flag);
     flag(pps_weighted_bipred_flag);
     flag(pps_ref_wraparound_enabled_flag);
     if (current->pps_ref_wraparound_enabled_flag) {
         ue(pps_pic_width_minus_wraparound_offset,
            0, (current->pps_pic_width_in_luma_samples / min_cb_size_y)
            - (ctb_size_y / min_cb_size_y) - 2);
     }
 
     qp_bd_offset = 6 * sps->sps_bitdepth_minus8;
     se(pps_init_qp_minus26, -(26 + qp_bd_offset), 37);
     flag(pps_cu_qp_delta_enabled_flag);
     flag(pps_chroma_tool_offsets_present_flag);
     if (current->pps_chroma_tool_offsets_present_flag) {
         se(pps_cb_qp_offset, -12, 12);
         se(pps_cr_qp_offset, -12, 12);
         flag(pps_joint_cbcr_qp_offset_present_flag);
         if (current->pps_joint_cbcr_qp_offset_present_flag)
             se(pps_joint_cbcr_qp_offset_value, -12, 12);
         else
             infer(pps_joint_cbcr_qp_offset_value, 0);
         flag(pps_slice_chroma_qp_offsets_present_flag);
         flag(pps_cu_chroma_qp_offset_list_enabled_flag);
         if (current->pps_cu_chroma_qp_offset_list_enabled_flag) {
             ue(pps_chroma_qp_offset_list_len_minus1, 0, 5);
             for (i = 0; i <= current->pps_chroma_qp_offset_list_len_minus1; i++) {
                 ses(pps_cb_qp_offset_list[i], -12, 12, 1, i);
                 ses(pps_cr_qp_offset_list[i], -12, 12, 1, i);
                 if (current->pps_joint_cbcr_qp_offset_present_flag)
                     ses(pps_joint_cbcr_qp_offset_list[i], -12, 12, 1, i);
                 else
                     infer(pps_joint_cbcr_qp_offset_list[i], 0);
             }
         }
     } else {
         infer(pps_cb_qp_offset, 0);
         infer(pps_cr_qp_offset, 0);
         infer(pps_joint_cbcr_qp_offset_present_flag, 0);
         infer(pps_joint_cbcr_qp_offset_value, 0);
         infer(pps_slice_chroma_qp_offsets_present_flag, 0);
         infer(pps_cu_chroma_qp_offset_list_enabled_flag, 0);
     }
     flag(pps_deblocking_filter_control_present_flag);
     if (current->pps_deblocking_filter_control_present_flag) {
         flag(pps_deblocking_filter_override_enabled_flag);
         flag(pps_deblocking_filter_disabled_flag);
         if (!current->pps_no_pic_partition_flag &&
             current->pps_deblocking_filter_override_enabled_flag)
             flag(pps_dbf_info_in_ph_flag);
         else
             infer(pps_dbf_info_in_ph_flag, 0);
         if (!current->pps_deblocking_filter_disabled_flag) {
             se(pps_luma_beta_offset_div2, -12, 12);
             se(pps_luma_tc_offset_div2, -12, 12);
             if (current->pps_chroma_tool_offsets_present_flag) {
                 se(pps_cb_beta_offset_div2, -12, 12);
                 se(pps_cb_tc_offset_div2, -12, 12);
                 se(pps_cr_beta_offset_div2, -12, 12);
                 se(pps_cr_tc_offset_div2, -12, 12);
             } else {
                 infer(pps_cb_beta_offset_div2,
                       current->pps_luma_beta_offset_div2);
                 infer(pps_cb_tc_offset_div2, current->pps_luma_tc_offset_div2);
                 infer(pps_cr_beta_offset_div2,
                       current->pps_luma_beta_offset_div2);
                 infer(pps_cr_tc_offset_div2, current->pps_luma_tc_offset_div2);
             }
         } else {
             infer(pps_luma_beta_offset_div2, 0);
             infer(pps_luma_tc_offset_div2, 0);
             infer(pps_cb_beta_offset_div2, 0);
             infer(pps_cb_tc_offset_div2, 0);
             infer(pps_cr_beta_offset_div2, 0);
             infer(pps_cr_tc_offset_div2, 0);
         }
     } else {
         infer(pps_deblocking_filter_override_enabled_flag, 0);
         infer(pps_deblocking_filter_disabled_flag, 0);
         infer(pps_dbf_info_in_ph_flag, 0);
         infer(pps_luma_beta_offset_div2, 0);
         infer(pps_luma_tc_offset_div2, 0);
         infer(pps_cb_beta_offset_div2, 0);
         infer(pps_cb_tc_offset_div2, 0);
         infer(pps_cr_beta_offset_div2, 0);
         infer(pps_cr_tc_offset_div2, 0);
     }
 
     if (!current->pps_no_pic_partition_flag) {
         flag(pps_rpl_info_in_ph_flag);
         flag(pps_sao_info_in_ph_flag);
         flag(pps_alf_info_in_ph_flag);
         if ((current->pps_weighted_pred_flag ||
              current->pps_weighted_bipred_flag) &&
             current->pps_rpl_info_in_ph_flag)
             flag(pps_wp_info_in_ph_flag);
         flag(pps_qp_delta_info_in_ph_flag);
     }
     flag(pps_picture_header_extension_present_flag);
     flag(pps_slice_header_extension_present_flag);
 
     flag(pps_extension_flag);
     if (current->pps_extension_flag)
         CHECK(FUNC(extension_data) (ctx, rw, &current->extension_data));
 
     CHECK(FUNC(rbsp_trailing_bits) (ctx, rw));
     return 0;
 }
@@ -2654,408 +2663,399 @@ static int FUNC(ph) (CodedBitstreamContext *ctx, RWContext *rw,
 static int FUNC(slice_header) (CodedBitstreamContext *ctx, RWContext *rw,
                                H266RawSliceHeader *current)
 {
     CodedBitstreamH266Context *h266 = ctx->priv_data;
     const H266RawSPS *sps;
     const H266RawPPS *pps;
     const H266RawPictureHeader *ph;
     const H266RefPicLists *ref_pic_lists;
     int err, i;
     uint8_t nal_unit_type, qp_bd_offset;
     uint16_t curr_subpic_idx;
     uint16_t num_slices_in_subpic;
 
     HEADER("Slice Header");
 
     CHECK(FUNC(nal_unit_header) (ctx, rw, &current->nal_unit_header, -1));
 
     flag(sh_picture_header_in_slice_header_flag);
     if (current->sh_picture_header_in_slice_header_flag) {
         // 7.4.8 if sh_picture_header_in_slice_header_flag is true, we do not have a PH NAL unit
         CHECK(FUNC(picture_header) (ctx, rw, &current->sh_picture_header));
         ph = &current->sh_picture_header;
     } else {
         ph = h266->ph;
         if (!ph) {
             av_log(ctx->log_ctx, AV_LOG_ERROR,
                    "Picture header not available.\n");
             return AVERROR_INVALIDDATA;
         }
     }
 
     pps = h266->pps[ph->ph_pic_parameter_set_id];
     if (!pps) {
         av_log(ctx->log_ctx, AV_LOG_ERROR, "PPS id %d not available.\n",
                ph->ph_pic_parameter_set_id);
         return AVERROR_INVALIDDATA;
     }
     sps = h266->sps[pps->pps_seq_parameter_set_id];
     if (!sps) {
         av_log(ctx->log_ctx, AV_LOG_ERROR, "SPS id %d not available.\n",
                pps->pps_seq_parameter_set_id);
         return AVERROR_INVALIDDATA;
     }
 
     if (sps->sps_subpic_info_present_flag) {
         ub(sps->sps_subpic_id_len_minus1 + 1, sh_subpic_id);
-        if (sps->sps_subpic_id_mapping_explicitly_signalled_flag) {
-            for (i = 0; i <= sps->sps_num_subpics_minus1; i++) {
-                uint16_t subpic_id_val =
-                    pps->pps_subpic_id_mapping_present_flag ?
-                    pps->pps_subpic_id[i] : sps->sps_subpic_id[i];
-                if (subpic_id_val == current->sh_subpic_id) {
-                    curr_subpic_idx = i;
-                    break;
-                }
-            }
-        } else {
-            curr_subpic_idx = current->sh_subpic_id;
-            if (curr_subpic_idx > sps->sps_num_subpics_minus1) {
-                av_log(ctx->log_ctx, AV_LOG_ERROR,
-                       "sh_subpic_id(%d) should in range [0, %d]\n",
-                       curr_subpic_idx, sps->sps_num_subpics_minus1);
-                return AVERROR_INVALIDDATA;
+        for (i = 0; i <= sps->sps_num_subpics_minus1; i++) {
+            if (pps->sub_pic_id_val[i] == current->sh_subpic_id) {
+                curr_subpic_idx = i;
+                break;
             }
         }
+        if (i > sps->sps_num_subpics_minus1) {
+            av_log(ctx->log_ctx, AV_LOG_ERROR, "invalid CurrSubpicIdx %d\n", i);
+            return AVERROR_INVALIDDATA;
+        }
     } else {
         curr_subpic_idx = 0;
     }
 
     num_slices_in_subpic = pps->num_slices_in_subpic[curr_subpic_idx];
 
     if ((pps->pps_rect_slice_flag && num_slices_in_subpic > 1) ||
         (!pps->pps_rect_slice_flag && pps->num_tiles_in_pic > 1)) {
         unsigned int bits, max;
         if (!pps->pps_rect_slice_flag) {
             bits = av_ceil_log2(pps->num_tiles_in_pic);
             max = pps->num_tiles_in_pic - 1;
         } else {
             bits = av_ceil_log2(num_slices_in_subpic);
             max = num_slices_in_subpic - 1;
         }
         u(bits, sh_slice_address, 0, max);
     } else {
         infer(sh_slice_address, 0);
     }
 
     for (i = 0; i < sps->sps_num_extra_sh_bytes * 8; i++) {
         if (sps->sps_extra_sh_bit_present_flag[i])
             flags(sh_extra_bit[i], 1, i);
     }
 
     if (!pps->pps_rect_slice_flag &&
         pps->num_tiles_in_pic - current->sh_slice_address > 1)
         ue(sh_num_tiles_in_slice_minus1, 0, pps->num_tiles_in_pic - 1);
     else
         infer(sh_num_tiles_in_slice_minus1, 0);
 
     if (ph->ph_inter_slice_allowed_flag)
         ue(sh_slice_type, 0, 2);
     else
         infer(sh_slice_type, 2);
 
     nal_unit_type = current->nal_unit_header.nal_unit_type;
     if (nal_unit_type == VVC_IDR_W_RADL || nal_unit_type == VVC_IDR_N_LP ||
         nal_unit_type == VVC_CRA_NUT || nal_unit_type == VVC_GDR_NUT)
         flag(sh_no_output_of_prior_pics_flag);
     if (sps->sps_alf_enabled_flag && !pps->pps_alf_info_in_ph_flag) {
         flag(sh_alf_enabled_flag);
         if (current->sh_alf_enabled_flag) {
             ub(3, sh_num_alf_aps_ids_luma);
             for (i = 0; i < current->sh_num_alf_aps_ids_luma; i++)
                 ubs(3, sh_alf_aps_id_luma[i], 1, i);
             if (sps->sps_chroma_format_idc != 0) {
                 flag(sh_alf_cb_enabled_flag);
                 flag(sh_alf_cr_enabled_flag);
             } else {
                 infer(sh_alf_cb_enabled_flag, ph->ph_alf_cb_enabled_flag);
                 infer(sh_alf_cr_enabled_flag, ph->ph_alf_cr_enabled_flag);
             }
             if (current->sh_alf_cb_enabled_flag ||
                 current->sh_alf_cr_enabled_flag)
                 ub(3, sh_alf_aps_id_chroma);
             else
                 infer(sh_alf_aps_id_chroma, ph->ph_alf_aps_id_chroma);
             if (sps->sps_ccalf_enabled_flag) {
                 flag(sh_alf_cc_cb_enabled_flag);
                 if (current->sh_alf_cc_cb_enabled_flag)
                     ub(3, sh_alf_cc_cb_aps_id);
                 else
                     infer(sh_alf_cc_cb_aps_id, ph->ph_alf_cc_cb_aps_id);
                 flag(sh_alf_cc_cr_enabled_flag);
                 if (current->sh_alf_cc_cr_enabled_flag)
                     ub(3, sh_alf_cc_cr_aps_id);
                 else
                     infer(sh_alf_cc_cr_aps_id, ph->ph_alf_cc_cr_aps_id);
             } else {
                 infer(sh_alf_cc_cb_enabled_flag, ph->ph_alf_cc_cb_enabled_flag);
                 infer(sh_alf_cc_cr_enabled_flag, ph->ph_alf_cc_cr_enabled_flag);
                 infer(sh_alf_cc_cb_aps_id, ph->ph_alf_cc_cb_aps_id);
                 infer(sh_alf_cc_cr_aps_id, ph->ph_alf_cc_cr_aps_id);
             }
         }
     } else {
         infer(sh_alf_enabled_flag, 0);
     }
 
     if (ph->ph_lmcs_enabled_flag &&
         !current->sh_picture_header_in_slice_header_flag)
         flag(sh_lmcs_used_flag);
     else
         infer(sh_lmcs_used_flag, 0);
 
     if (ph->ph_explicit_scaling_list_enabled_flag &&
         !current->sh_picture_header_in_slice_header_flag)
         flag(sh_explicit_scaling_list_used_flag);
     else
         infer(sh_explicit_scaling_list_used_flag, 0);
 
     if (!pps->pps_rpl_info_in_ph_flag &&
         ((nal_unit_type != VVC_IDR_W_RADL &&
           nal_unit_type != VVC_IDR_N_LP) || sps->sps_idr_rpl_present_flag)) {
         CHECK(FUNC(ref_pic_lists)
               (ctx, rw, sps, pps, &current->sh_ref_pic_lists));
         ref_pic_lists = &current->sh_ref_pic_lists;
     } else {
         ref_pic_lists = &ph->ph_ref_pic_lists;
     }
     if ((current->sh_slice_type != VVC_SLICE_TYPE_I &&
          ref_pic_lists->rpl_ref_list[0].num_ref_entries > 1) ||
         (current->sh_slice_type == VVC_SLICE_TYPE_B &&
          ref_pic_lists->rpl_ref_list[1].num_ref_entries > 1)) {
         flag(sh_num_ref_idx_active_override_flag);
         if (current->sh_num_ref_idx_active_override_flag) {
             for (i = 0;
                  i < (current->sh_slice_type == VVC_SLICE_TYPE_B ? 2 : 1); i++)
                 if (ref_pic_lists->rpl_ref_list[i].num_ref_entries > 1)
                     ues(sh_num_ref_idx_active_minus1[i], 0, 14, 1, i);
                 else
                     infer(sh_num_ref_idx_active_minus1[i], 0);
         }
     } else {
         infer(sh_num_ref_idx_active_override_flag, 1);
     }
     if (current->sh_slice_type != VVC_SLICE_TYPE_I) {
         if (pps->pps_cabac_init_present_flag)
             flag(sh_cabac_init_flag);
         else
             infer(sh_cabac_init_flag, 0);
         if (ph->ph_temporal_mvp_enabled_flag && !pps->pps_rpl_info_in_ph_flag) {
             uint8_t num_ref_idx_active[2];
             for (i = 0; i < 2; i++) {
                 if (current->sh_slice_type == VVC_SLICE_TYPE_B ||
                     (current->sh_slice_type == VVC_SLICE_TYPE_P && i == 0)) {
                     if (current->sh_num_ref_idx_active_override_flag) {
                         num_ref_idx_active[i] =
                             current->sh_num_ref_idx_active_minus1[i] + 1;
                     } else {
                         num_ref_idx_active[i] =
                             FFMIN(ref_pic_lists->rpl_ref_list[i].num_ref_entries,
                                   pps->pps_num_ref_idx_default_active_minus1[i] + 1);
                     }
                 } else {
                     num_ref_idx_active[i] = 0;
                 }
             }
 
             if (current->sh_slice_type == VVC_SLICE_TYPE_B)
                 flag(sh_collocated_from_l0_flag);
             else
                 infer(sh_collocated_from_l0_flag, 1);
             if ((current->sh_collocated_from_l0_flag &&
                  num_ref_idx_active[0] > 1) ||
                 (!current->sh_collocated_from_l0_flag &&
                  num_ref_idx_active[1] > 1)) {
                 unsigned int idx = current->sh_collocated_from_l0_flag ? 0 : 1;
                 ue(sh_collocated_ref_idx, 0, num_ref_idx_active[idx] - 1);
             } else {
                 infer(sh_collocated_ref_idx, 0);
             }
             if (!pps->pps_wp_info_in_ph_flag &&
                 ((pps->pps_weighted_pred_flag &&
                   current->sh_slice_type == VVC_SLICE_TYPE_P) ||
                  (pps->pps_weighted_bipred_flag &&
                   current->sh_slice_type == VVC_SLICE_TYPE_B))) {
                 CHECK(FUNC(pred_weight_table) (ctx, rw, sps, pps, ref_pic_lists,
                                                num_ref_idx_active,
                                                &current->sh_pred_weight_table));
             }
         }
 
     }
     qp_bd_offset = 6 * sps->sps_bitdepth_minus8;
     if (!pps->pps_qp_delta_info_in_ph_flag)
         se(sh_qp_delta, -qp_bd_offset - (26 + pps->pps_init_qp_minus26),
            63 - (26 + pps->pps_init_qp_minus26));
     if (pps->pps_slice_chroma_qp_offsets_present_flag) {
         int8_t off;
 
         se(sh_cb_qp_offset, -12, 12);
         off = pps->pps_cb_qp_offset + current->sh_cb_qp_offset;
         if (off < -12 || off > 12) {
             av_log(ctx->log_ctx, AV_LOG_ERROR,
                    "pps_cb_qp_offset + sh_cb_qp_offset (%d) not in range [-12, 12].\n",
                    off);
             return AVERROR_INVALIDDATA;
         }
 
         se(sh_cr_qp_offset, -12, 12);
         off = pps->pps_cr_qp_offset + current->sh_cr_qp_offset;
         if (off < -12 || off > 12) {
             av_log(ctx->log_ctx, AV_LOG_ERROR,
                    "pps_cr_qp_offset + sh_cr_qp_offset (%d) not in range [-12, 12].\n",
                    off);
             return AVERROR_INVALIDDATA;
         }
 
         if (sps->sps_joint_cbcr_enabled_flag) {
             se(sh_joint_cbcr_qp_offset, -12, 12);
             off =
                 pps->pps_joint_cbcr_qp_offset_value +
                 current->sh_joint_cbcr_qp_offset;
             if (off < -12 || off > 12) {
                 av_log(ctx->log_ctx, AV_LOG_ERROR,
                        "pps_joint_cbcr_qp_offset_value + sh_joint_cbcr_qp_offset (%d)"
                        "not in range [-12, 12]. \n", off);
                 return AVERROR_INVALIDDATA;
             }
         } else {
             infer(sh_joint_cbcr_qp_offset, 0);
         }
     } else {
         infer(sh_cb_qp_offset, 0);
         infer(sh_cr_qp_offset, 0);
         infer(sh_joint_cbcr_qp_offset, 0);
     }
     if (pps->pps_cu_chroma_qp_offset_list_enabled_flag)
         flag(sh_cu_chroma_qp_offset_enabled_flag);
     else
         infer(sh_cu_chroma_qp_offset_enabled_flag, 0);
     if (sps->sps_sao_enabled_flag && !pps->pps_sao_info_in_ph_flag) {
         flag(sh_sao_luma_used_flag);
         if (sps->sps_chroma_format_idc != 0)
             flag(sh_sao_chroma_used_flag);
         else
             infer(sh_sao_chroma_used_flag, ph->ph_sao_chroma_enabled_flag);
     } else {
         infer(sh_sao_luma_used_flag, ph->ph_sao_luma_enabled_flag);
         infer(sh_sao_chroma_used_flag, ph->ph_sao_chroma_enabled_flag);
     }
 
     if (pps->pps_deblocking_filter_override_enabled_flag &&
         !pps->pps_dbf_info_in_ph_flag)
         flag(sh_deblocking_params_present_flag);
     else
         infer(sh_deblocking_params_present_flag, 0);
     if (current->sh_deblocking_params_present_flag) {
         if (!pps->pps_deblocking_filter_disabled_flag)
             flag(sh_deblocking_filter_disabled_flag);
         else
             infer(sh_deblocking_filter_disabled_flag,
                   !(pps->pps_deblocking_filter_disabled_flag &&
                     current->sh_deblocking_params_present_flag));
         if (!current->sh_deblocking_filter_disabled_flag) {
             se(sh_luma_beta_offset_div2, -12, 12);
             se(sh_luma_tc_offset_div2, -12, 12);
             if (pps->pps_chroma_tool_offsets_present_flag) {
                 se(sh_cb_beta_offset_div2, -12, 12);
                 se(sh_cb_tc_offset_div2, -12, 12);
                 se(sh_cr_beta_offset_div2, -12, 12);
                 se(sh_cr_tc_offset_div2, -12, 12);
             } else {
                 infer(sh_cb_beta_offset_div2,
                       current->sh_luma_beta_offset_div2);
                 infer(sh_cb_tc_offset_div2, current->sh_luma_tc_offset_div2);
                 infer(sh_cr_beta_offset_div2,
                       current->sh_luma_beta_offset_div2);
                 infer(sh_cr_tc_offset_div2, current->sh_luma_tc_offset_div2);
             }
         } else {
             infer(sh_luma_beta_offset_div2, ph->ph_luma_beta_offset_div2);
             infer(sh_luma_tc_offset_div2, ph->ph_luma_tc_offset_div2);
             if (pps->pps_chroma_tool_offsets_present_flag) {
                 infer(sh_cb_beta_offset_div2, ph->ph_cb_beta_offset_div2);
                 infer(sh_cb_tc_offset_div2, ph->ph_cb_tc_offset_div2);
                 infer(sh_cr_beta_offset_div2, ph->ph_cr_beta_offset_div2);
                 infer(sh_cr_tc_offset_div2, ph->ph_cr_beta_offset_div2);
             } else {
                 infer(sh_cb_beta_offset_div2,
                       current->sh_luma_beta_offset_div2);
                 infer(sh_cb_tc_offset_div2, current->sh_luma_tc_offset_div2);
                 infer(sh_cr_beta_offset_div2,
                       current->sh_luma_beta_offset_div2);
                 infer(sh_cr_tc_offset_div2, current->sh_luma_tc_offset_div2);
             }
         }
     }
 
     if (sps->sps_dep_quant_enabled_flag)
         flag(sh_dep_quant_used_flag);
     else
         infer(sh_dep_quant_used_flag, 0);
 
     if (sps->sps_sign_data_hiding_enabled_flag &&
         !current->sh_dep_quant_used_flag)
         flag(sh_sign_data_hiding_used_flag);
     else
         infer(sh_sign_data_hiding_used_flag, 0);
 
     if (sps->sps_transform_skip_enabled_flag &&
         !current->sh_dep_quant_used_flag &&
         !current->sh_sign_data_hiding_used_flag)
         flag(sh_ts_residual_coding_disabled_flag);
     else
         infer(sh_ts_residual_coding_disabled_flag, 0);
     if (pps->pps_slice_header_extension_present_flag) {
         ue(sh_slice_header_extension_length, 0, 256);
         for (i = 0; i < current->sh_slice_header_extension_length; i++)
             us(8, sh_slice_header_extension_data_byte[i], 0x00, 0xff, 1, i);
     }
     if (sps->sps_entry_point_offsets_present_flag) {
         int num_entry_points = 0;
         uint8_t entropy_sync = sps->sps_entropy_coding_sync_enabled_flag;
         int height;
         if (pps->pps_rect_slice_flag) {
             int width_in_tiles;
             int slice_idx = current->sh_slice_address;
             for (i = 0; i < curr_subpic_idx; i++) {
                 slice_idx += pps->num_slices_in_subpic[i];
             }
             width_in_tiles =
                 pps->pps_slice_width_in_tiles_minus1[slice_idx] + 1;
 
             if (entropy_sync)
                 height = pps->slice_height_in_ctus[slice_idx];
             else
                 height = pps->pps_slice_height_in_tiles_minus1[slice_idx] + 1;
 
             num_entry_points = width_in_tiles * height;
         } else {
             int tile_idx;
             int tile_y;
             for (tile_idx = current->sh_slice_address;
                  tile_idx <=
                  current->sh_slice_address +
                  current->sh_num_tiles_in_slice_minus1; tile_idx++) {
                 tile_y = tile_idx / pps->num_tile_rows;
                 height = pps->pps_tile_row_height_minus1[tile_y] + 1;
                 num_entry_points += (entropy_sync ? height : 1);
             }
         }
         num_entry_points--;
         if (num_entry_points > VVC_MAX_ENTRY_POINTS) {
             av_log(ctx->log_ctx, AV_LOG_ERROR, "Too many entry points: "
                    "%" PRIu16 ".\n", num_entry_points);
             return AVERROR_PATCHWELCOME;
         }
         if (num_entry_points > 0) {
             ue(sh_entry_offset_len_minus1, 0, 31);
             for (i = 0; i < num_entry_points; i++) {
                 ubs(current->sh_entry_offset_len_minus1 + 1,
                     sh_entry_point_offset_minus1[i], 1, i);
             }
         }
     }
     CHECK(FUNC(byte_alignment) (ctx, rw));
 
     return 0;
 }
