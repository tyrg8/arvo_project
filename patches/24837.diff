commit 73c1a4c6a052f467dc1ad877fbc5b4788495f730
Merge: d97b4c70 ff8fa105
Author: Francesc Alted <francesc@blosc.org>
Date:   Tue Aug 18 18:26:58 2020 +0200

    Merge pull request #144 from nmoinvaz/improvements/srcsize
    
    Added srcsize parameter to blosc2_decompress_ctx and blosc2_getitem_ctx.

diff --git a/bench/sum_openmp.c b/bench/sum_openmp.c
index c943c535..cd4ecab0 100644
--- a/bench/sum_openmp.c
+++ b/bench/sum_openmp.c
@@ -74,169 +74,169 @@
 int main(void) {
   static DTYPE udata[N];
   DTYPE chunk_buf[CHUNKSIZE];
   size_t isize = CHUNKSIZE * sizeof(DTYPE);
   DTYPE sum, compressed_sum;
   int64_t nbytes, cbytes;
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_schunk* schunk;
   int i, j, nchunk;
   blosc_timestamp_t last, current;
   double ttotal, itotal;
   char* envvar = NULL;
 
   printf("Blosc version info: %s (%s)\n",
          BLOSC_VERSION_STRING, BLOSC_VERSION_DATE);
 
   // Fill the buffer for a chunk
   if (SYNTHETIC) {
     for (j = 0; j < CHUNKSIZE; j++) {
       chunk_buf[j] = j;
     }
   }
   else {
     struct stat info;
     const char *filegrid = "rainfall-grid-150x150.bin";
     if (stat(filegrid, &info) != 0) {
       printf("Grid file %s not found!", filegrid);
       exit(1);
     }
     char *cdata = malloc(info.st_size);
 
     FILE *f = fopen(filegrid, "rb");
     size_t blocks_read = fread(cdata, info.st_size, 1, f);
     assert(blocks_read == 1);
     fclose(f);
 
     int dsize = blosc_getitem(cdata, 0, CHUNKSIZE, chunk_buf);
     if (dsize < 0) {
       printf("blosc_getitem() error.  Error code: %d\n.  Probaly reading too much data?", dsize);
       exit(1);
     }
     free(cdata);
   }
 
   // Fill the uncompressed dataset with data chunks
   for (i = 0; i < N / CHUNKSIZE; i++) {
     for (j = 0; j < CHUNKSIZE; j++) {
       udata[i * CHUNKSIZE + j] = chunk_buf[j];
     }
   }
 
   // Reduce uncompressed dataset
   ttotal = 1e10;
   sum = 0;
   for (int n = 0; n < NITER; n++) {
     sum = 0;
     blosc_set_timestamp(&last);
 #pragma omp parallel for reduction (+:sum)
     for (i = 0; i < N; i++) {
       sum += udata[i];
     }
     blosc_set_timestamp(&current);
     itotal = blosc_elapsed_secs(last, current);
     if (itotal < ttotal) ttotal = itotal;
   }
   printf("Sum for uncompressed data: %10.0f\n", (double)sum);
   printf("Sum time for uncompressed data: %.3g s, %.1f MB/s\n",
          ttotal, (isize * NCHUNKS) / (ttotal * (double)MB));
 
   // Create a super-chunk container for the compressed container
   long codec = CODEC;
   envvar = getenv("SUM_COMPRESSOR");
   if (envvar != NULL) {
     codec = blosc_compname_to_compcode(envvar);
     if (codec < 0) {
       printf("Unknown compresssor: %s\n", envvar);
       return 1;
     }
   }
-  cparams.compcode = codec;
+  cparams.compcode = (uint8_t)codec;
 
   long clevel = CLEVEL;
   envvar = getenv("SUM_CLEVEL");
   if (envvar != NULL) {
     clevel = strtol(envvar, NULL, 10);
   }
-  cparams.clevel = clevel;
+  cparams.clevel = (uint8_t)clevel;
 
   cparams.typesize = sizeof(DTYPE);
   cparams.nthreads = 1;
   dparams.nthreads = 1;
   blosc_set_timestamp(&last);
   schunk = blosc2_new_schunk(cparams, dparams, NULL);
   for (nchunk = 0; nchunk < NCHUNKS; nchunk++) {
     for (i = 0; i < CHUNKSIZE; i++) {
       chunk_buf[i] = udata[i + nchunk * CHUNKSIZE];
     }
     blosc2_schunk_append_buffer(schunk, chunk_buf, isize);
   }
   blosc_set_timestamp(&current);
   ttotal = blosc_elapsed_secs(last, current);
   nbytes = schunk->nbytes;
   cbytes = schunk->cbytes;
   printf("Compression ratio: %.1f MB -> %.1f MB (%.1fx)\n",
          nbytes / MB, cbytes / MB, (1. * nbytes) / cbytes);
   printf("Compression time: %.3g s, %.1f MB/s\n",
          ttotal, nbytes / (ttotal * MB));
 
   int nthreads = NTHREADS;
   envvar = getenv("OMP_NUM_THREADS");
   if (envvar != NULL) {
     long value;
     value = strtol(envvar, NULL, 10);
     if ((value != EINVAL) && (value >= 0)) {
       nthreads = (int)value;
     }
   }
   // Build buffers and contexts for computations
   int nchunks_thread = NCHUNKS / nthreads;
   int remaining_chunks = NCHUNKS - nchunks_thread * nthreads;
   blosc2_context **dctx = malloc(nthreads * sizeof(void*));
   DTYPE** chunk = malloc(nthreads * sizeof(void*));
   for (j = 0; j < nthreads; j++) {
     chunk[j] = malloc(CHUNKSIZE * sizeof(DTYPE));
   }
 
   // Reduce uncompressed dataset
   blosc_set_timestamp(&last);
   ttotal = 1e10;
   compressed_sum = 0;
   for (int n = 0; n < NITER; n++) {
     compressed_sum = 0;
     #pragma omp parallel for private(nchunk) reduction (+:compressed_sum)
     for (j = 0; j < nthreads; j++) {
       dctx[j] = blosc2_create_dctx(dparams);
       for (nchunk = 0; nchunk < nchunks_thread; nchunk++) {
-        blosc2_decompress_ctx(dctx[j], schunk->data[j * nchunks_thread + nchunk],
+        blosc2_decompress_ctx(dctx[j], schunk->data[j * nchunks_thread + nchunk], INT32_MAX, 
                               (void*)(chunk[j]), isize);
         for (i = 0; i < CHUNKSIZE; i++) {
           compressed_sum += chunk[j][i];
           //compressed_sum += i + (j * nchunks_thread + nchunk) * CHUNKSIZE;
         }
       }
     }
     for (nchunk = NCHUNKS - remaining_chunks; nchunk < NCHUNKS; nchunk++) {
-      blosc2_decompress_ctx(dctx[0], schunk->data[nchunk], (void*)(chunk[0]), isize);
+      blosc2_decompress_ctx(dctx[0], schunk->data[nchunk], INT32_MAX, (void*)(chunk[0]), isize);
       for (i = 0; i < CHUNKSIZE; i++) {
         compressed_sum += chunk[0][i];
         //compressed_sum += i + nchunk * CHUNKSIZE;
       }
     }
     blosc_set_timestamp(&current);
     itotal = blosc_elapsed_secs(last, current);
     if (itotal < ttotal) ttotal = itotal;
   }
   printf("Sum for *compressed* data: %10.0f\n", (double)compressed_sum);
   printf("Sum time for *compressed* data: %.3g s, %.1f MB/s\n",
          ttotal, nbytes / (ttotal * MB));
   //printf("sum, csum: %f, %f\n", sum, compressed_sum);
   if (SYNTHETIC) {
     // difficult to fulfill for single precision
     assert(sum == compressed_sum);
   }
   /* Free resources */
   blosc2_free_schunk(schunk);
 
   return 0;
 }
diff --git a/blosc/blosc2.c b/blosc/blosc2.c
index 77070f80..31bf72b8 100644
--- a/blosc/blosc2.c
+++ b/blosc/blosc2.c
@@ -964,207 +964,220 @@ int pipeline_d(blosc2_context* context, const int32_t bsize, uint8_t* dest,
 /* Decompress & unshuffle a single block */
 static int blosc_d(
     struct thread_context* thread_context, int32_t bsize,
-    int32_t leftoverblock, const uint8_t* src, uint8_t* dest, int32_t offset,
-    uint8_t* tmp, uint8_t* tmp2) {
+    int32_t leftoverblock, const uint8_t* src, size_t srcsize, uint8_t* dest,
+    int32_t offset, uint8_t* tmp, uint8_t* tmp2) {
   blosc2_context* context = thread_context->parent_context;
   uint8_t* filters = context->filters;
   uint8_t *tmp3 = thread_context->tmp4;
   int32_t compformat = (context->header_flags & 0xe0) >> 5;
+  uint8_t *src_end = (uint8_t *)src + srcsize;
   int dont_split = (context->header_flags & 0x10) >> 4;
   //uint8_t blosc_version_format = src[0];
   int nstreams;
   int32_t neblock;
   int32_t nbytes;                /* number of decompressed bytes in split */
   int32_t cbytes;                /* number of compressed bytes in split */
   int32_t ctbytes = 0;           /* number of compressed bytes in block */
   int32_t ntbytes = 0;           /* number of uncompressed bytes in block */
   uint8_t* _dest;
   int32_t typesize = context->typesize;
   int32_t nblock = offset / context->blocksize;
   const char* compname;
 
   if (context->block_maskout != NULL && context->block_maskout[nblock]) {
     // Do not decompress, but act as if we successfully decompressed everything
     return bsize;
   }
 
   int last_filter_index = last_filter(filters, 'd');
 
   if ((last_filter_index >= 0) &&
           (next_filter(filters, BLOSC2_MAX_FILTERS, 'd') != BLOSC_DELTA)) {
    // We are making use of some filter, so use a temp for destination
    _dest = tmp;
   } else {
     // If no filters, or only DELTA in pipeline
    _dest = dest + offset;
   }
 
   /* The number of compressed data streams for this block */
   if (!dont_split && !leftoverblock && !context->use_dict) {
     // We don't want to split when in a training dict state
     nstreams = (int32_t)typesize;
   }
   else {
     nstreams = 1;
   }
 
   neblock = bsize / nstreams;
   for (int j = 0; j < nstreams; j++) {
+    if (src + sizeof(int32_t) >= src_end) {
+      /* Not enough input to read compressed size */
+      return -1;
+    }
     cbytes = sw32_(src);      /* amount of compressed bytes */
     src += sizeof(int32_t);
+    if (src + cbytes >= src_end) {
+      /* Not enough input to read compressed size */
+      return -1;
+    }
     ctbytes += (int32_t)sizeof(int32_t);
 
     /* Uncompress */
     if (cbytes <= 0) {
       // A run
       if (cbytes < -255) {
         // Runs can only encode a byte
         return -2;
       }
       uint8_t value = -cbytes;
       memset(_dest, value, (unsigned int)neblock);
       nbytes = neblock;
       cbytes = 0;  // everything is encoded in the cbytes token
     }
     else if (cbytes == neblock) {
       memcpy(_dest, src, (unsigned int)neblock);
       nbytes = (int32_t)neblock;
     }
     else {
       if (compformat == BLOSC_BLOSCLZ_FORMAT) {
         nbytes = blosclz_decompress(src, cbytes, _dest, (int)neblock);
       }
   #if defined(HAVE_LZ4)
       else if (compformat == BLOSC_LZ4_FORMAT) {
         nbytes = lz4_wrap_decompress((char*)src, (size_t)cbytes,
                                      (char*)_dest, (size_t)neblock);
       }
   #endif /*  HAVE_LZ4 */
   #if defined(HAVE_LIZARD)
       else if (compformat == BLOSC_LIZARD_FORMAT) {
         nbytes = lizard_wrap_decompress((char*)src, (size_t)cbytes,
                                         (char*)_dest, (size_t)neblock);
       }
   #endif /*  HAVE_LIZARD */
   #if defined(HAVE_SNAPPY)
       else if (compformat == BLOSC_SNAPPY_FORMAT) {
         nbytes = snappy_wrap_decompress((char*)src, (size_t)cbytes,
                                         (char*)_dest, (size_t)neblock);
       }
   #endif /*  HAVE_SNAPPY */
   #if defined(HAVE_ZLIB)
       else if (compformat == BLOSC_ZLIB_FORMAT) {
         nbytes = zlib_wrap_decompress((char*)src, (size_t)cbytes,
                                       (char*)_dest, (size_t)neblock);
       }
   #endif /*  HAVE_ZLIB */
   #if defined(HAVE_ZSTD)
       else if (compformat == BLOSC_ZSTD_FORMAT) {
         nbytes = zstd_wrap_decompress(thread_context,
                                       (char*)src, (size_t)cbytes,
                                       (char*)_dest, (size_t)neblock);
       }
   #endif /*  HAVE_ZSTD */
       else {
         compname = clibcode_to_clibname(compformat);
         fprintf(stderr,
                 "Blosc has not been compiled with decompression "
                     "support for '%s' format. ", compname);
         fprintf(stderr, "Please recompile for adding this support.\n");
         return -5;    /* signals no decompression support */
       }
 
       /* Check that decompressed bytes number is correct */
       if (nbytes != neblock) {
         return -2;
       }
 
     }
     src += cbytes;
     ctbytes += cbytes;
     _dest += nbytes;
     ntbytes += nbytes;
   } /* Closes j < nstreams */
 
   if (last_filter_index >= 0) {
     int errcode = pipeline_d(context, bsize, dest, offset, tmp, tmp2, tmp3,
                              last_filter_index);
     if (errcode < 0)
       return errcode;
   }
 
   /* Return the number of uncompressed bytes */
   return (int)ntbytes;
 }
 
 
 /* Serial version for compression/decompression */
 static int serial_blosc(struct thread_context* thread_context) {
   blosc2_context* context = thread_context->parent_context;
   int32_t j, bsize, leftoverblock;
   int32_t cbytes;
   int32_t ntbytes = (int32_t)context->output_bytes;
   int32_t* bstarts = context->bstarts;
   uint8_t* tmp = thread_context->tmp;
   uint8_t* tmp2 = thread_context->tmp2;
   int dict_training = context->use_dict && (context->dict_cdict == NULL);
   bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;
 
   for (j = 0; j < context->nblocks; j++) {
     if (context->do_compress && !memcpyed && !dict_training) {
       _sw32(bstarts + j, ntbytes);
     }
     bsize = context->blocksize;
     leftoverblock = 0;
     if ((j == context->nblocks - 1) && (context->leftover > 0)) {
       bsize = context->leftover;
       leftoverblock = 1;
     }
     if (context->do_compress) {
       if (memcpyed && !context->prefilter) {
         /* We want to memcpy only */
         memcpy(context->dest + BLOSC_MAX_OVERHEAD + j * context->blocksize,
                  context->src + j * context->blocksize,
                  (unsigned int)bsize);
         cbytes = (int32_t)bsize;
       }
       else {
         /* Regular compression */
         cbytes = blosc_c(thread_context, bsize, leftoverblock, ntbytes,
                          context->destsize, context->src, j * context->blocksize,
                          context->dest + ntbytes, tmp, tmp2);
         if (cbytes == 0) {
           ntbytes = 0;              /* uncompressible data */
           break;
         }
       }
     }
     else {
       if (memcpyed) {
         // Check that sizes in header are compatible, otherwise there is a header corruption
         int32_t csize = sw32_(context->src + 12);   /* compressed buffer size */
         if (context->sourcesize + BLOSC_MAX_OVERHEAD != csize) {
           return -1;
         }
+        if (context->srcsize < BLOSC_MAX_OVERHEAD + (j * context->blocksize) + bsize) {
+          /* Not enough input to copy block */
+          return -1;
+        }
         memcpy(context->dest + j * context->blocksize,
                context->src + BLOSC_MAX_OVERHEAD + j * context->blocksize,
                (unsigned int)bsize);
         cbytes = (int32_t)bsize;
       }
       else {
         /* Regular decompression */
         cbytes = blosc_d(thread_context, bsize, leftoverblock,
-                         context->src + sw32_(bstarts + j),
+                         context->src + sw32_(bstarts + j), context->srcsize,
                          context->dest, j * context->blocksize, tmp, tmp2);
       }
     }
 
     if (cbytes < 0) {
       ntbytes = cbytes;         /* error in blosc_c or blosc_d */
       break;
     }
     ntbytes += cbytes;
   }
 
   return ntbytes;
 }
@@ -1473,82 +1486,116 @@ static uint8_t get_filter_flags(const uint8_t header_flags,
 }
 
 
-static int initialize_context_decompression(blosc2_context* context, const void* src,
+static int initialize_context_decompression(blosc2_context* context, const void* src, int32_t srcsize,
                                             void* dest, int32_t destsize) {
+  uint8_t blosc2_flags = 0;
+  int32_t cbytes;
+
   context->do_compress = 0;
   context->src = (const uint8_t*)src;
+  context->srcsize = srcsize;
   context->dest = (uint8_t*)dest;
   context->destsize = destsize;
   context->output_bytes = 0;
   context->end_threads = 0;
 
+  if (context->srcsize < BLOSC_MIN_HEADER_LENGTH) {
+    /* Not enough input to read minimum header */
+    return -1;
+  }
+
   context->header_flags = context->src[2];
   context->typesize = context->src[3];
   context->sourcesize = sw32_(context->src + 4);
   context->blocksize = sw32_(context->src + 8);
+  cbytes = sw32_(context->src + 12);
 
   // Some checks for malformed headers
   if (context->blocksize <= 0 || context->blocksize > destsize ||
-      context->typesize <= 0 || context->typesize > BLOSC_MAX_TYPESIZE) {
+      context->typesize <= 0 || context->typesize > BLOSC_MAX_TYPESIZE ||
+      cbytes > srcsize) {
     return -1;
   }
 
   /* Total blocks */
   context->nblocks = context->sourcesize / context->blocksize;
   context->leftover = context->sourcesize % context->blocksize;
   context->nblocks = (context->leftover > 0) ?
                       context->nblocks + 1 : context->nblocks;
 
   if (context->block_maskout != NULL && context->block_maskout_nitems != context->nblocks) {
     fprintf(stderr, "The number of items in block_maskout (%d) must match the number"
                     " of blocks in chunk (%d)", context->block_maskout_nitems, context->nblocks);
     return -2;
   }
 
   if ((context->header_flags & BLOSC_DOSHUFFLE) &&
       (context->header_flags & BLOSC_DOBITSHUFFLE)) {
     /* Extended header */
+    if (context->srcsize < BLOSC_EXTENDED_HEADER_LENGTH) {
+      /* Not enough input to read extended header */
+      return -1;
+    }
     uint8_t* filters = (uint8_t*)(context->src + BLOSC_MIN_HEADER_LENGTH);
     uint8_t* filters_meta = filters + 8;
-    int header_version = context->src[0];
+    uint8_t header_version = context->src[0];
     // The number of filters depends on the version of the header
     // (we need to read less because filters where not initialized to zero in blosc2 alpha series)
     int max_filters = (header_version == BLOSC2_VERSION_FORMAT_ALPHA) ? 5 : BLOSC2_MAX_FILTERS;
     for (int i = 0; i < max_filters; i++) {
       context->filters[i] = filters[i];
       context->filters_meta[i] = filters_meta[i];
     }
     context->filter_flags = filters_to_flags(filters);
-    uint8_t* blosc2_flags = (uint8_t*)(context->src + 0x1F);
     context->bstarts = (int32_t*)(context->src + BLOSC_EXTENDED_HEADER_LENGTH);
-    if (*blosc2_flags & BLOSC2_USEDICT) {
-#if defined(HAVE_ZSTD)
-      context->use_dict = 1;
-      if (context->dict_ddict != NULL) {
-          // Free the existing dictionary (probably from another chunk)
-          ZSTD_freeDDict(context->dict_ddict);
-      }
-      // The trained dictionary is after the bstarts block
-      context->dict_buffer = (void*)(context->bstarts + context->nblocks + 1);
-      context->dict_size = (size_t)sw32_(context->bstarts + context->nblocks);
-      if (context->dict_size > BLOSC2_MAXDICTSIZE) {
-        return -1;
-      }
-      context->dict_ddict = ZSTD_createDDict(context->dict_buffer, context->dict_size);
-#endif   // HAVE_ZSTD
-    }
+
+    blosc2_flags = context->src[0x1F];
   } else {
     /* Regular (Blosc1) header */
     context->filter_flags = get_filter_flags(context->header_flags,
                                              context->typesize);
     flags_to_filters(context->header_flags, context->filters);
     context->bstarts = (int32_t*)(context->src + BLOSC_MIN_HEADER_LENGTH);
   }
 
   /* Check that we have enough space to decompress */
   if (context->sourcesize > (int32_t)destsize) {
     return -1;
   }
+  const uint8_t *src_end = (context->src + context->srcsize);
+  const int32_t *bstarts_end = (int32_t *)(context->bstarts + context->nblocks);
+  if (src_end < (uint8_t *)bstarts_end) {
+    /* Not enough input to read entire `bstarts` section */
+    return -1;
+  }
+
+  /* Read optional dictionary if flag set */
+  if (blosc2_flags & BLOSC2_USEDICT) {
+#if defined(HAVE_ZSTD)
+    context->use_dict = 1;
+    if (context->dict_ddict != NULL) {
+      // Free the existing dictionary (probably from another chunk)
+      ZSTD_freeDDict(context->dict_ddict);
+    }
+    // The trained dictionary is after the bstarts block
+    if (src_end < (uint8_t *)(bstarts_end + 1)) {
+      /* Not enough input to size of dictionary */
+      return -1;
+    }
+    context->dict_size = (size_t)sw32_(bstarts_end);
+    if (src_end < (uint8_t *)(bstarts_end + 1) + context->dict_size) {
+      /* Not enough input to read entire dictionary */
+      return -1;
+    }
+    if (context->dict_size > BLOSC2_MAXDICTSIZE) {
+      /* Dictionary is larger than maximum size allowed */
+      return -1;
+    }
+    context->dict_buffer = (void*)(bstarts_end + 1);
+    context->dict_ddict = ZSTD_createDDict(context->dict_buffer, context->dict_size);
+#endif   // HAVE_ZSTD
+  }
+
 
   return 0;
 }
@@ -2027,487 +2074,524 @@ int blosc_compress(int clevel, int doshuffle, size_t typesize, size_t nbytes,
 }
 
 
-int blosc_run_decompression_with_context(blosc2_context* context, const void* src, void* dest,
-                                         size_t destsize) {
+int blosc_run_decompression_with_context(blosc2_context* context, const void* src, size_t srcsize,
+                                         void* dest, size_t destsize) {
   int32_t ntbytes;
+  uint8_t* _src = (uint8_t*)src;
+  uint8_t version;
   int error;
-  uint8_t version = ((uint8_t*)src)[0];                        /* blosc format version */
+
+  if (srcsize <= 0) {
+    /* Invalid argument */
+    return -1;
+  }
+  version = _src[0];                        /* blosc format version */
   if (version > BLOSC_VERSION_FORMAT) {
     /* Version from future */
     return -1;
   }
 
-  error = initialize_context_decompression(context, src, dest, (int32_t)destsize);
+  error = initialize_context_decompression(context, src, (int32_t)srcsize, dest, (int32_t)destsize);
   if (error < 0) {
     return error;
   }
 
   /* Check whether this buffer is memcpy'ed */
   bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;
   if (memcpyed) {
     // Check that sizes in header are compatible, otherwise there is a header corruption
     ntbytes = context->sourcesize;
-    int32_t cbytes = sw32_((int8_t*)src + 12);   /* compressed buffer size */
+    int32_t cbytes = sw32_(_src + 12);   /* compressed buffer size */
     if (ntbytes + BLOSC_MAX_OVERHEAD != cbytes) {
       return -1;
     }
     // Check that we have enough space in destination for the copy operation
     if (destsize < (size_t)ntbytes) {
       return -1;
     }
-    memcpy(dest, (uint8_t*)src + BLOSC_MAX_OVERHEAD, (unsigned int)ntbytes);
+    memcpy(dest, _src + BLOSC_MAX_OVERHEAD, (unsigned int)ntbytes);
   }
   else {
     /* Do the actual decompression */
     ntbytes = do_job(context);
     if (ntbytes < 0) {
       return -1;
     }
   }
 
   assert(ntbytes <= (int32_t)destsize);
   return ntbytes;
 }
 
 
 /* The public routine for decompression with context. */
-int blosc2_decompress_ctx(
-    blosc2_context* context, const void* src, void* dest, size_t destsize) {
+int blosc2_decompress_ctx(blosc2_context* context, const void* src, size_t srcsize,
+                          void* dest, size_t destsize) {
   int result;
 
   if (context->do_compress != 0) {
     fprintf(stderr, "Context is not meant for decompression.  Giving up.\n");
     return -10;
   }
 
-  result = blosc_run_decompression_with_context(context, src, dest, destsize);
+  result = blosc_run_decompression_with_context(context, src, srcsize, dest, destsize);
 
   // Reset a possible block_maskout
   if (context->block_maskout != NULL) {
     free(context->block_maskout);
     context->block_maskout = NULL;
   }
   context->block_maskout_nitems = 0;
 
   return result;
 }
 
 
 /* The public routine for decompression.  See blosc.h for docstrings. */
 int blosc_decompress(const void* src, void* dest, size_t destsize) {
   int result;
   char* envvar;
   long nthreads;
   blosc2_context *dctx;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
 
   /* Check whether the library should be initialized */
   if (!g_initlib) blosc_init();
 
   /* Check for a BLOSC_NTHREADS environment variable */
   envvar = getenv("BLOSC_NTHREADS");
   if (envvar != NULL) {
     nthreads = strtol(envvar, NULL, 10);
     if ((nthreads != EINVAL) && (nthreads > 0)) {
       result = blosc_set_nthreads((int)nthreads);
       if (result < 0) { return result; }
     }
   }
 
   /* Check for a BLOSC_NOLOCK environment variable.  It is important
      that this should be the last env var so that it can take the
      previous ones into account */
   envvar = getenv("BLOSC_NOLOCK");
   if (envvar != NULL) {
     dparams.nthreads = g_nthreads;
     dctx = blosc2_create_dctx(dparams);
-    result = blosc2_decompress_ctx(dctx, src, dest, destsize);
+    result = blosc2_decompress_ctx(dctx, src, INT32_MAX, dest, destsize);
     blosc2_free_ctx(dctx);
     return result;
   }
 
   pthread_mutex_lock(&global_comp_mutex);
 
   result = blosc_run_decompression_with_context(
-          g_global_context, src, dest, destsize);
+          g_global_context, src, INT32_MAX, dest, destsize);
 
   pthread_mutex_unlock(&global_comp_mutex);
 
   return result;
 }
 
 /* Specific routine optimized for decompression a small number of
    items out of a compressed chunk.  This does not use threads because
    it would affect negatively to performance. */
-int _blosc_getitem(blosc2_context* context, const void* src, int start,
-                   int nitems, void* dest) {
+int _blosc_getitem(blosc2_context* context, const void* src, size_t srcsize,
+                   int start, int nitems, void* dest) {
   uint8_t* _src = NULL;             /* current pos for source buffer */
   uint8_t flags;                    /* flags for header */
   int32_t ntbytes = 0;              /* the number of uncompressed bytes */
   int32_t nblocks;                   /* number of total blocks in buffer */
   int32_t leftover;                  /* extra bytes at end of buffer */
   int32_t* bstarts;                /* start pointers for each block */
   int32_t typesize, blocksize, nbytes;
   int32_t bsize, bsize2, ebsize, leftoverblock;
   int32_t cbytes;
   int32_t startb, stopb;
   int32_t stop = start + nitems;
   int j;
 
+  if (srcsize < BLOSC_MIN_HEADER_LENGTH) {
+    /* Not enough input to parse Blosc1 header */
+    return -1;
+  }
   _src = (uint8_t*)(src);
 
   /* Read the header block */
   flags = _src[2];                  /* flags */
   bool memcpyed = flags & (uint8_t)BLOSC_MEMCPYED;
   typesize = (int32_t)_src[3];      /* typesize */
   nbytes = sw32_(_src + 4);         /* buffer size */
   blocksize = sw32_(_src + 8);      /* block size */
   cbytes = sw32_(_src + 12);    /* compressed buffer size */
 
   ebsize = blocksize + typesize * (int32_t)sizeof(int32_t);
 
   if ((context->header_flags & BLOSC_DOSHUFFLE) &&
       (context->header_flags & BLOSC_DOBITSHUFFLE)) {
     /* Extended header */
+    if (srcsize < BLOSC_EXTENDED_HEADER_LENGTH) {
+      /* Not enough input to parse Blosc2 header */
+      return -1;
+    }
     uint8_t* filters = _src + BLOSC_MIN_HEADER_LENGTH;
     uint8_t* filters_meta = filters + 8;
     for (int i = 0; i < BLOSC2_MAX_FILTERS; i++) {
       context->filters[i] = filters[i];
       context->filters_meta[i] = filters_meta[i];
     }
     bstarts = (int32_t*)(_src + BLOSC_EXTENDED_HEADER_LENGTH);
   } else {
     /* Minimal header */
     flags_to_filters(flags, context->filters);
     bstarts = (int32_t*)(_src + BLOSC_MIN_HEADER_LENGTH);
   }
 
   // Some checks for malformed buffers
   if (blocksize <= 0 || blocksize > nbytes || typesize <= 0 || typesize > BLOSC_MAX_TYPESIZE) {
     return -1;
   }
 
   /* Compute some params */
   /* Total blocks */
   nblocks = nbytes / blocksize;
   leftover = nbytes % blocksize;
   nblocks = (leftover > 0) ? nblocks + 1 : nblocks;
 
   /* Check region boundaries */
   if ((start < 0) || (start * typesize > nbytes)) {
     fprintf(stderr, "`start` out of bounds");
     return -1;
   }
 
   if ((stop < 0) || (stop * typesize > nbytes)) {
     fprintf(stderr, "`start`+`nitems` out of bounds");
     return -1;
   }
 
+  if (_src + srcsize < (uint8_t *)(bstarts + nblocks)) {
+    /* Not enough input to read all `bstarts` */
+    return -1;
+  }
+
   for (j = 0; j < nblocks; j++) {
     bsize = blocksize;
     leftoverblock = 0;
     if ((j == nblocks - 1) && (leftover > 0)) {
       bsize = leftover;
       leftoverblock = 1;
     }
 
     /* Compute start & stop for each block */
     startb = start * (int)typesize - j * (int)blocksize;
     stopb = stop * (int)typesize - j * (int)blocksize;
     if ((startb >= (int)blocksize) || (stopb <= 0)) {
       continue;
     }
     if (startb < 0) {
       startb = 0;
     }
     if (stopb > (int)blocksize) {
       stopb = (int)blocksize;
     }
     bsize2 = stopb - startb;
 
     /* Do the actual data copy */
     if (memcpyed) {
       // Check that sizes in header are compatible, otherwise there is a header corruption
       if (nbytes + BLOSC_MAX_OVERHEAD != cbytes) {
          return -1;
       }
+      if (srcsize < BLOSC_MAX_OVERHEAD + j * blocksize + startb + bsize2) {
+        /* Not enough input to copy data */
+        return -1;
+      }
       memcpy((uint8_t*)dest + ntbytes,
              (uint8_t*)src + BLOSC_MAX_OVERHEAD + j * blocksize + startb,
              (unsigned int)bsize2);
       cbytes = (int)bsize2;
     }
     else {
       struct thread_context* scontext = context->serial_context;
 
       /* Resize the temporaries in serial context if needed */
       if (blocksize != scontext->tmp_blocksize) {
         my_free(scontext->tmp);
         scontext->tmp_nbytes = (size_t)3 * context->blocksize + ebsize;
         scontext->tmp = my_malloc(scontext->tmp_nbytes);
         scontext->tmp2 = scontext->tmp + blocksize;
         scontext->tmp3 = scontext->tmp + blocksize + ebsize;
         scontext->tmp4 = scontext->tmp + 2 * blocksize + ebsize;
         scontext->tmp_blocksize = (int32_t)blocksize;
       }
 
       // Regular decompression.  Put results in tmp2.
       // If the block is aligned and the worst case fits in destination, let's avoid a copy
       bool get_single_block = ((startb == 0) && (bsize == nitems * typesize));
       uint8_t* tmp2 = get_single_block ? dest : scontext->tmp2;
       cbytes = blosc_d(context->serial_context, bsize, leftoverblock,
-                       (uint8_t*)src + sw32_(bstarts + j),
+                       (uint8_t*)src + sw32_(bstarts + j), srcsize,
                        tmp2, 0, scontext->tmp, scontext->tmp3);
       if (cbytes < 0) {
         ntbytes = cbytes;
         break;
       }
       if (!get_single_block) {
         /* Copy to destination */
         memcpy((uint8_t *) dest + ntbytes, tmp2 + startb, (unsigned int) bsize2);
       }
       cbytes = (int)bsize2;
     }
     ntbytes += cbytes;
   }
 
   return ntbytes;
 }
 
 
 /* Specific routine optimized for decompression a small number of
    items out of a compressed chunk.  Public non-contextual API. */
 int blosc_getitem(const void* src, int start, int nitems, void* dest) {
   uint8_t* _src = (uint8_t*)(src);
   blosc2_context context;
   int result;
 
-  uint8_t version = ((uint8_t*)src)[0];                        /* blosc format version */
+  uint8_t version = _src[0];                        /* blosc format version */
   if (version > BLOSC_VERSION_FORMAT) {
     /* Version from future */
     return -1;
   }
 
   /* Minimally populate the context */
   memset(&context, 0, sizeof(blosc2_context));
   context.src = src;
   context.dest = dest;
   context.typesize = (uint8_t)_src[3];
   context.blocksize = sw32_(_src + 8);
   context.header_flags = *(_src + 2);
   context.filter_flags = get_filter_flags(context.header_flags, context.typesize);
   context.schunk = g_schunk;
   context.nthreads = 1;  // force a serial decompression; fixes #95
   context.serial_context = create_thread_context(&context, 0);
 
   /* Call the actual getitem function */
-  result = _blosc_getitem(&context, src, start, nitems, dest);
+  result = _blosc_getitem(&context, src, INT32_MAX, start, nitems, dest);
 
   /* Release resources */
   free_thread_context(context.serial_context);
   return result;
 }
 
-int blosc2_getitem_ctx(blosc2_context* context, const void* src, int start,
-    int nitems, void* dest) {
+int blosc2_getitem_ctx(blosc2_context* context, const void* src, size_t srcsize,
+    int start, int nitems, void* dest) {
   uint8_t* _src = (uint8_t*)(src);
   int result;
 
   /* Minimally populate the context */
   context->typesize = (uint8_t)_src[3];
   context->blocksize = sw32_(_src + 8);
   context->header_flags = *(_src + 2);
   context->filter_flags = get_filter_flags(*(_src + 2), context->typesize);
   if (context->serial_context == NULL) {
     context->serial_context = create_thread_context(context, 0);
   }
 
   /* Call the actual getitem function */
-  result = _blosc_getitem(context, src, start, nitems, dest);
+  result = _blosc_getitem(context, src, srcsize, start, nitems, dest);
 
   return result;
 }
 
 /* execute single compression/decompression job for a single thread_context */
 static void t_blosc_do_job(void *ctxt)
 {
   struct thread_context* thcontext = (struct thread_context*)ctxt;
   blosc2_context* context = thcontext->parent_context;
   int32_t cbytes;
   int32_t ntdest;
   int32_t tblocks;               /* number of blocks per thread */
   int32_t tblock;                /* limit block on a thread */
   int32_t nblock_;              /* private copy of nblock */
   int32_t bsize;
   int32_t leftoverblock;
   /* Parameters for threads */
   int32_t blocksize;
   int32_t ebsize;
+  int32_t srcsize;
   bool compress = context->do_compress != 0;
   int32_t maxbytes;
   int32_t nblocks;
   int32_t leftover;
   int32_t leftover2;
   int32_t* bstarts;
   const uint8_t* src;
   uint8_t* dest;
   uint8_t* tmp;
   uint8_t* tmp2;
   uint8_t* tmp3;
 
   /* Get parameters for this thread before entering the main loop */
   blocksize = context->blocksize;
   ebsize = blocksize + context->typesize * sizeof(int32_t);
   maxbytes = context->destsize;
   nblocks = context->nblocks;
   leftover = context->leftover;
   bstarts = context->bstarts;
   src = context->src;
+  srcsize = context->srcsize;
   dest = context->dest;
 
   /* Resize the temporaries if needed */
   if (blocksize != thcontext->tmp_blocksize) {
     my_free(thcontext->tmp);
     thcontext->tmp_nbytes = (size_t)3 * context->blocksize + ebsize;
     thcontext->tmp = my_malloc(thcontext->tmp_nbytes);
     thcontext->tmp2 = thcontext->tmp + blocksize;
     thcontext->tmp3 = thcontext->tmp + blocksize + ebsize;
     thcontext->tmp4 = thcontext->tmp + 2 * blocksize + ebsize;
     thcontext->tmp_blocksize = blocksize;
   }
 
   tmp = thcontext->tmp;
   tmp2 = thcontext->tmp2;
   tmp3 = thcontext->tmp3;
 
   // Determine whether we can do a static distribution of workload among different threads
   bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;
   bool static_schedule = (!compress || memcpyed) && context->block_maskout == NULL;
   if (static_schedule) {
       /* Blocks per thread */
       tblocks = nblocks / context->nthreads;
       leftover2 = nblocks % context->nthreads;
       tblocks = (leftover2 > 0) ? tblocks + 1 : tblocks;
       nblock_ = thcontext->tid * tblocks;
       tblock = nblock_ + tblocks;
       if (tblock > nblocks) {
           tblock = nblocks;
       }
   }
   else {
     // Use dynamic schedule via a queue.  Get the next block.
     pthread_mutex_lock(&context->count_mutex);
     context->thread_nblock++;
     nblock_ = context->thread_nblock;
     pthread_mutex_unlock(&context->count_mutex);
     tblock = nblocks;
   }
 
   /* Loop over blocks */
   leftoverblock = 0;
   while ((nblock_ < tblock) && (context->thread_giveup_code > 0)) {
     bsize = blocksize;
     if (nblock_ == (nblocks - 1) && (leftover > 0)) {
       bsize = leftover;
       leftoverblock = 1;
     }
     if (compress) {
       if (memcpyed) {
         if (!context->prefilter) {
           /* We want to memcpy only */
           memcpy(dest + BLOSC_MAX_OVERHEAD + nblock_ * blocksize,
                  src + nblock_ * blocksize, (unsigned int) bsize);
           cbytes = (int32_t) bsize;
         }
         else {
           /* Only the prefilter has to be executed, and this is done in blosc_c().
            * However, no further actions are needed, so we can put the result
            * directly in dest. */
           cbytes = blosc_c(thcontext, bsize, leftoverblock, 0,
                            ebsize, src, nblock_ * blocksize,
                            dest + BLOSC_MAX_OVERHEAD + nblock_ * blocksize,
                            tmp, tmp3);
         }
       }
       else {
         /* Regular compression */
         cbytes = blosc_c(thcontext, bsize, leftoverblock, 0,
                           ebsize, src, nblock_ * blocksize, tmp2, tmp, tmp3);
       }
     }
     else {
       if (memcpyed) {
         /* We want to memcpy only */
-        memcpy(dest + nblock_ * blocksize,
-               src + BLOSC_MAX_OVERHEAD + nblock_ * blocksize, (unsigned int)bsize);
-        cbytes = (int32_t)bsize;
+        if (srcsize < BLOSC_MAX_OVERHEAD + (nblock_ * blocksize) + bsize) {
+          /* Not enough input to copy data */
+          
+          cbytes = -1;
+        } else {
+          memcpy(dest + nblock_ * blocksize,
+                  src + BLOSC_MAX_OVERHEAD + nblock_ * blocksize, (unsigned int)bsize);
+          cbytes = (int32_t)bsize;
+        }
       }
       else {
-        cbytes = blosc_d(thcontext, bsize, leftoverblock,
-                          src + sw32_(bstarts + nblock_),
-                          dest, nblock_ * blocksize, tmp, tmp2);
+        if (srcsize < BLOSC_MAX_OVERHEAD + (sizeof(int32_t) * nblocks)) {
+          /* Not enough input to read all `bstarts` */
+          cbytes = -1;
+        } else {
+          cbytes = blosc_d(thcontext, bsize, leftoverblock,
+                            src + sw32_(bstarts + nblock_), srcsize,
+                            dest, nblock_ * blocksize, tmp, tmp2);
+        }
       }
     }
 
     /* Check whether current thread has to giveup */
     if (context->thread_giveup_code <= 0) {
       break;
     }
 
     /* Check results for the compressed/decompressed block */
     if (cbytes < 0) {            /* compr/decompr failure */
       /* Set giveup_code error */
       pthread_mutex_lock(&context->count_mutex);
       context->thread_giveup_code = cbytes;
       pthread_mutex_unlock(&context->count_mutex);
       break;
     }
 
     if (compress && !memcpyed) {
       /* Start critical section */
       pthread_mutex_lock(&context->count_mutex);
       ntdest = context->output_bytes;
       // Note: do not use a typical local dict_training variable here
       // because it is probably cached from previous calls if the number of
       // threads does not change (the usual thing).
       if (!(context->use_dict && context->dict_cdict == NULL)) {
         _sw32(bstarts + nblock_, (int32_t) ntdest);
       }
 
       if ((cbytes == 0) || (ntdest + cbytes > maxbytes)) {
         context->thread_giveup_code = 0;  /* uncompressible buf */
         pthread_mutex_unlock(&context->count_mutex);
         break;
       }
       context->thread_nblock++;
       nblock_ = context->thread_nblock;
       context->output_bytes += cbytes;
       pthread_mutex_unlock(&context->count_mutex);
       /* End of critical section */
 
       /* Copy the compressed buffer to destination */
       memcpy(dest + ntdest, tmp2, (unsigned int) cbytes);
     }
     else if (static_schedule) {
       nblock_++;
     }
     else {
       pthread_mutex_lock(&context->count_mutex);
       context->thread_nblock++;
       nblock_ = context->thread_nblock;
       context->output_bytes += cbytes;
       pthread_mutex_unlock(&context->count_mutex);
     }
 
   } /* closes while (nblock_) */
 
   if (static_schedule) {
     context->output_bytes = context->sourcesize;
     if (compress) {
       context->output_bytes += BLOSC_MAX_OVERHEAD;
     }
   }
 
 }
 
 /* Decompress & unshuffle several blocks in a single thread */
diff --git a/blosc/blosc2.h b/blosc/blosc2.h
index 07108bae..761b9830 100644
--- a/blosc/blosc2.h
+++ b/blosc/blosc2.h
@@ -749,78 +749,79 @@ BLOSC_EXPORT int blosc2_set_maskout(blosc2_context *ctx, bool *maskout, int nblo
 /**
  * @brief Context interface to Blosc compression. This does not require a call
  * to #blosc_init and can be called from multithreaded applications
  * without the global lock being used, so allowing Blosc be executed
  * simultaneously in those scenarios.
  *
  * @param context A blosc2_context struct with the different compression params.
  * @param nbytes The number of bytes to be compressed from the @p src buffer.
  * @param src The buffer containing the data to be compressed.
  * @param dest The buffer where the compressed data will be put.
  * @param destsize The size in bytes of the @p dest buffer.
  *
  * @return The number of bytes compressed.
  * If @p src buffer cannot be compressed into @p destsize, the return
  * value is zero and you should discard the contents of the @p dest
  * buffer.  A negative return value means that an internal error happened.
  * It could happen that context is not meant for compression (which is stated in stderr).
  * Otherwise, please report it back together with the buffer data causing this
  * and compression settings.
  */
 BLOSC_EXPORT int blosc2_compress_ctx(
         blosc2_context* context, size_t nbytes, const void* src, void* dest,
         size_t destsize);
 
 
 /**
  * @brief Context interface to Blosc decompression. This does not require a
  * call to #blosc_init and can be called from multithreaded
  * applications without the global lock being used, so allowing Blosc
  * be executed simultaneously in those scenarios.
  *
  * @param context The blosc2_context struct with the different compression params.
  * @param src The buffer of compressed data.
+ * @param srcsize The length of buffer of compressed data.
  * @param dest The buffer where the decompressed data will be put.
  * @param destsize The size in bytes of the @p dest buffer.
  *
  * @warning The @p src buffer and the @p dest buffer can not overlap.
  *
  * @remark Decompression is memory safe and guaranteed not to write the @p dest
  * buffer more than what is specified in @p destsize.
  *
  * @remark In case you want to keep under control the number of bytes read from
  * source, you can call #blosc_cbuffer_sizes first to check the @p nbytes
  * (i.e. the number of bytes to be read from @p src buffer by this function)
  * in the compressed buffer.
  *
  * @remark If #blosc2_set_maskout is called prior to this function, its
  * @p block_maskout parameter will be honored for just *one single* shot;
  * i.e. the maskout in context will be automatically reset to NULL, so
  * mask won't be used next time (unless #blosc2_set_maskout is called again).
  *
  * @return The number of bytes decompressed (i.e. the maskout blocks are not
  * counted). If an error occurs, e.g. the compressed data is corrupted,
  * @p destsize is not large enough or context is not meant for decompression,
  * then 0 (zero) or a negative value will be returned instead.
  */
 BLOSC_EXPORT int blosc2_decompress_ctx(blosc2_context* context, const void* src,
-                                       void* dest, size_t destsize);
+                                       size_t srcsize, void* dest, size_t destsize);
 
 /**
  * @brief Context interface counterpart for #blosc_getitem.
  *
  * It uses similar parameters than the blosc_getitem() function plus a
- * @p context parameter.
+ * @p context parameter and @srcsize compressed buffer length parameter.
  *
  * @return The number of bytes copied to @p dest or a negative value if
  * some error happens.
  */
 BLOSC_EXPORT int blosc2_getitem_ctx(blosc2_context* context, const void* src,
-                                    int start, int nitems, void* dest);
+                                    size_t srcsize, int start, int nitems, void* dest);
 
 
 /*********************************************************************
   Super-chunk related structures and functions.
 *********************************************************************/
 
 #define BLOSC2_MAX_METALAYERS 16
 #define BLOSC2_METALAYER_NAME_MAXLEN 31
diff --git a/blosc/context.h b/blosc/context.h
index fecc50f1..c83d7ab5 100644
--- a/blosc/context.h
+++ b/blosc/context.h
@@ -35,88 +35,90 @@
 struct blosc2_context_s {
   const uint8_t* src;
   /* The source buffer */
   uint8_t* dest;
   /* The destination buffer */
   uint8_t header_flags;
   /* Flags for header */
   int32_t sourcesize;
   /* Number of bytes in source buffer */
   int32_t nblocks;
   /* Number of total blocks in buffer */
   int32_t leftover;
   /* Extra bytes at end of buffer */
   int32_t blocksize;
   /* Length of the block in bytes */
   int32_t output_bytes;
+  /* Counter for the number of input bytes */
+  int32_t srcsize;
   /* Counter for the number of output bytes */
   int32_t destsize;
   /* Maximum size for destination buffer */
   int32_t typesize;
   /* Type size */
   int32_t* bstarts;
   /* Starts for every block inside the compressed buffer */
   int compcode;
   /* Compressor code to use */
   int clevel;
   /* Compression level (1-9) */
   int use_dict;
   /* Whether to use dicts or not */
   void* dict_buffer;
   /* The buffer to keep the trained dictionary */
   size_t dict_size;
   /* The size of the trained dictionary */
   void* dict_cdict;
   /* The dictionary in digested form for compression */
   void* dict_ddict;
   /* The dictionary in digested form for decompression */
   uint8_t filter_flags;
   /* The filter flags in the filter pipeline */
   uint8_t filters[BLOSC2_MAX_FILTERS];
   /* the (sequence of) filters */
   uint8_t filters_meta[BLOSC2_MAX_FILTERS];
   /* the metainfo for filters */
   blosc2_prefilter_fn prefilter;
   /* prefilter function */
   blosc2_prefilter_params *pparams;
   /* prefilter params */
   bool* block_maskout;
   /* The blocks that are not meant to be decompressed.
    * If NULL (default), all blocks in a chunk should be read. */
   int block_maskout_nitems;
   /* The number of items in block_maskout array (must match
    * the number of blocks in chunk) */
   blosc2_schunk* schunk;
   /* Associated super-chunk (if available) */
   struct thread_context* serial_context;
   /* Cache for temporaries for serial operation */
   int do_compress;
   /* 1 if we are compressing, 0 if decompressing */
   void *btune;
   /* Entry point for BTune persistence between runs */
 
   /* Threading */
   int nthreads;
   int new_nthreads;
   int threads_started;
   int end_threads;
   pthread_t *threads;
   struct thread_context *thread_contexts; /* only for user-managed threads */
   pthread_mutex_t count_mutex;
 #ifdef BLOSC_POSIX_BARRIERS
   pthread_barrier_t barr_init;
   pthread_barrier_t barr_finish;
 #else
   int count_threads;
   pthread_mutex_t count_threads_mutex;
   pthread_cond_t count_threads_cv;
 #endif
 #if !defined(_WIN32)
   pthread_attr_t ct_attr;      /* creation time attrs for threads */
 #endif
   int thread_giveup_code;
   /* error code when give up */
   int thread_nblock;       /* block counter */
   int dref_not_init;       /* data ref in delta not initialized */
   pthread_mutex_t delta_mutex;
   pthread_cond_t delta_cv;
 };
diff --git a/blosc/frame.c b/blosc/frame.c
index 978982f5..4394531c 100644
--- a/blosc/frame.c
+++ b/blosc/frame.c
@@ -706,29 +706,33 @@ blosc2_frame* blosc2_frame_from_sframe(uint8_t *sframe, int64_t len, bool copy)
 
 
 // Get the compressed data offsets
-uint8_t* get_coffsets(blosc2_frame *frame, int32_t header_len, int64_t cbytes) {
+uint8_t* get_coffsets(blosc2_frame *frame, int32_t header_len, int64_t cbytes, int64_t *off_cbytes) {
   if (frame->coffsets != NULL) {
     return frame->coffsets;
   }
 
   if (frame->sdata != NULL) {
     // For in-memory frames, the coffset is just one pointer away
+    if (off_cbytes != NULL)
+      *off_cbytes = cbytes;
     return frame->sdata + header_len + cbytes;
   }
 
   int64_t trailer_offset = get_trailer_offset(frame, header_len, cbytes);
-  int64_t off_cbytes = trailer_offset - (header_len + cbytes);
+  int64_t coffsets_cbytes = trailer_offset - (header_len + cbytes);
+  if (off_cbytes != NULL)
+    *off_cbytes = coffsets_cbytes;
   FILE* fp = fopen(frame->fname, "rb");
-  uint8_t* coffsets = malloc((size_t)off_cbytes);
+  uint8_t* coffsets = malloc((size_t)coffsets_cbytes);
   fseek(fp, header_len + cbytes, SEEK_SET);
-  size_t rbytes = fread(coffsets, 1, (size_t)off_cbytes, fp);
-  if (rbytes != (size_t)off_cbytes) {
+  size_t rbytes = fread(coffsets, 1, (size_t)coffsets_cbytes, fp);
+  if (rbytes != (size_t)coffsets_cbytes) {
     fprintf(stderr, "Error: cannot read the offsets out of the fileframe.\n");
     fclose(fp);
     return NULL;
   }
   fclose(fp);
   frame->coffsets = coffsets;
 
   return coffsets;
 }
@@ -945,392 +949,398 @@ int frame_get_metalayers(blosc2_frame* frame, blosc2_schunk* schunk) {
 /* Get a super-chunk out of a frame */
 blosc2_schunk* blosc2_schunk_from_frame(blosc2_frame* frame, bool copy) {
   int32_t header_len;
   int64_t frame_len;
 
   blosc2_schunk* schunk = calloc(1, sizeof(blosc2_schunk));
   schunk->frame = frame;
   int ret = get_header_info(frame, &header_len, &frame_len, &schunk->nbytes, &schunk->cbytes,
                             &schunk->chunksize, &schunk->nchunks, &schunk->typesize,
                             &schunk->compcode, &schunk->clevel, schunk->filters, schunk->filters_meta);
   if (ret < 0) {
     fprintf(stderr, "unable to get meta info from frame");
     return NULL;
   }
   int32_t nchunks = schunk->nchunks;
   int64_t nbytes = schunk->nbytes;
   (void) nbytes;
   int64_t cbytes = schunk->cbytes;
 
   // Compression and decompression contexts
   blosc2_cparams *cparams;
   blosc2_schunk_get_cparams(schunk, &cparams);
   schunk->cctx = blosc2_create_cctx(*cparams);
   free(cparams);
   blosc2_dparams *dparams;
   blosc2_schunk_get_dparams(schunk, &dparams);
   schunk->dctx = blosc2_create_dctx(*dparams);
   free(dparams);
 
   if (!copy || nchunks == 0) {
     goto out;
   }
 
   // We are not attached to a frame anymore
   schunk->frame = NULL;
 
   // Get the compressed offsets
-  uint8_t* coffsets = get_coffsets(frame, header_len, cbytes);
+  int64_t coffsets_cbytes = 0;
+  uint8_t* coffsets = get_coffsets(frame, header_len, cbytes, &coffsets_cbytes);
   if (coffsets == NULL) {
     fprintf(stderr, "Error: cannot get the offsets for the frame\n");
     return NULL;
   }
 
   // Decompress offsets
   blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_context *dctx = blosc2_create_dctx(off_dparams);
   int64_t* offsets = (int64_t *) malloc((size_t) nchunks * 8);
-  int32_t off_nbytes = blosc2_decompress_ctx(dctx, coffsets, offsets, (size_t)nchunks * 8);
+  int32_t off_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes, offsets, (size_t)nchunks * 8);
   blosc2_free_ctx(dctx);
   if (off_nbytes < 0) {
     free(offsets);
     fprintf(stderr, "Error: cannot decompress the offsets chunk");
     return NULL;
   }
 
   // We want the sparse schunk, so create the actual data chunks (and, while doing this,
   // get a guess at the blocksize used in this frame)
   schunk->data = malloc(nchunks * sizeof(void*));
   int64_t acc_nbytes = 0;
   int64_t acc_cbytes = 0;
   int32_t blocksize = 0;
   int32_t csize = 0;
   uint8_t* data_chunk = NULL;
   int32_t prev_alloc = BLOSC_MIN_HEADER_LENGTH;
   FILE* fp = NULL;
   if (frame->sdata == NULL) {
     data_chunk = malloc((size_t)prev_alloc);
     fp = fopen(frame->fname, "rb");
   }
   for (int i = 0; i < nchunks; i++) {
     if (frame->sdata != NULL) {
       data_chunk = frame->sdata + header_len + offsets[i];
       csize = sw32_(data_chunk + 12);
     }
     else {
       fseek(fp, header_len + offsets[i], SEEK_SET);
       size_t rbytes = fread(data_chunk, 1, BLOSC_MIN_HEADER_LENGTH, fp);
       assert(rbytes == BLOSC_MIN_HEADER_LENGTH);
       csize = sw32_(data_chunk + 12);
       if (csize > prev_alloc) {
         data_chunk = realloc(data_chunk, (size_t)csize);
         prev_alloc = csize;
       }
       fseek(fp, header_len + offsets[i], SEEK_SET);
       rbytes = fread(data_chunk, 1, (size_t)csize, fp);
       assert(rbytes == (size_t)csize);
     }
     uint8_t* new_chunk = malloc((size_t)csize);
     memcpy(new_chunk, data_chunk, (size_t)csize);
     schunk->data[i] = new_chunk;
     acc_nbytes += sw32_(data_chunk + 4);
     acc_cbytes += csize;
     int32_t blocksize_ = sw32_(data_chunk + 8);
     if (i == 0) {
       blocksize = blocksize_;
     }
     else if (blocksize != blocksize_) {
       // Blocksize varies
       blocksize = 0;
     }
   }
   schunk->blocksize = blocksize;
 
   if (frame->sdata == NULL) {
     free(data_chunk);
     fclose(fp);
   }
   free(offsets);
 
   assert(acc_nbytes == nbytes);
   assert(acc_cbytes == cbytes);
 
   uint8_t* usermeta;
   int32_t usermeta_len;
 
   int rc;
   out:
   rc = frame_get_metalayers(frame, schunk);
   if (rc < 0) {
     fprintf(stderr, "Error: cannot access the metalayers");
     return NULL;
   }
 
   usermeta_len = frame_get_usermeta(frame, &usermeta);
   if (usermeta_len < 0) {
     fprintf(stderr, "Error: cannot access the usermeta chunk");
     return NULL;
   }
   schunk->usermeta = usermeta;
   schunk->usermeta_len = usermeta_len;
 
   return schunk;
 }
 
 
 /* Return a compressed chunk that is part of a frame in the `chunk` parameter.
  * If the frame is disk-based, a buffer is allocated for the (compressed) chunk,
  * and hence a free is needed.  You can check if the chunk requires a free with the `needs_free`
  * parameter.
  * If the chunk does not need a free, it means that a pointer to the location in frame is returned
  * in the `chunk` parameter.
  *
  * The size of the (compressed) chunk is returned.  If some problem is detected, a negative code
  * is returned instead.
 */
 int frame_get_chunk(blosc2_frame *frame, int nchunk, uint8_t **chunk, bool *needs_free) {
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t chunksize;
   int32_t nchunks;
 
   *chunk = NULL;
   *needs_free = false;
   int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                             NULL, NULL, NULL, NULL, NULL);
   if (ret < 0) {
     fprintf(stderr, "unable to get meta info from frame");
     return -1;
   }
 
   if (nchunk >= nchunks) {
     fprintf(stderr, "nchunk ('%d') exceeds the number of chunks "
                     "('%d') in frame\n", nchunk, nchunks);
     return -2;
   }
 
   // Get the offset to chunk
-  uint8_t* coffsets = get_coffsets(frame, header_len, cbytes);
+  uint8_t* coffsets = get_coffsets(frame, header_len, cbytes, NULL);
   if (coffsets == NULL) {
     fprintf(stderr, "Error: cannot get the offset for chunk %d for the frame\n", nchunk);
     return -3;
   }
   int64_t offset;
   int rc = blosc_getitem(coffsets, nchunk, 1, &offset);
   if (rc < 0) {
     size_t nbytes_, cbytes_, blocksize_;
     blosc_cbuffer_sizes(coffsets, &nbytes_, &cbytes_, &blocksize_);
     fprintf(stderr, "Error: problems retrieving a chunk offset");
     return -4;
   }
 
   int32_t chunk_cbytes;
   if (frame->sdata == NULL) {
     FILE* fp = fopen(frame->fname, "rb");
     fseek(fp, header_len + offset + 12, SEEK_SET);
     size_t rbytes = fread(&chunk_cbytes, 1, sizeof(chunk_cbytes), fp);
     if (rbytes != sizeof(chunk_cbytes)) {
       fprintf(stderr, "Cannot read the cbytes for chunk in the fileframe.\n");
       return -5;
     }
     chunk_cbytes = sw32_(&chunk_cbytes);
     *chunk = malloc((size_t)chunk_cbytes);
     fseek(fp, header_len + offset, SEEK_SET);
     rbytes = fread(*chunk, 1, (size_t)chunk_cbytes, fp);
     if (rbytes != (size_t)chunk_cbytes) {
       fprintf(stderr, "Cannot read the chunk out of the fileframe.\n");
       return -6;
     }
     fclose(fp);
     *needs_free = true;
   } else {
     *chunk = frame->sdata + header_len + offset;
     int32_t chunk_nbytes = sw32_(*chunk + 4);
     chunk_cbytes = sw32_(*chunk + 12);
   }
 
   return chunk_cbytes;
 }
 
 
 /* Append an existing chunk into a frame. */
 void* frame_append_chunk(blosc2_frame* frame, void* chunk, blosc2_schunk* schunk) {
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t chunksize;
   int32_t nchunks;
   int rc = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
   if (rc < 0) {
     fprintf(stderr, "unable to get meta info from frame");
     return NULL;
   }
 
   int64_t trailer_offset = get_trailer_offset(frame, header_len, cbytes);
   int64_t trailer_len = frame->len - trailer_offset;
 
   /* The uncompressed and compressed sizes start at byte 4 and 12 */
   int32_t nbytes_chunk = sw32_((uint8_t*)chunk + 4);
   int32_t cbytes_chunk = sw32_((uint8_t*)chunk + 12);
   int64_t new_cbytes = cbytes + cbytes_chunk;
 
   if ((nchunks > 0) && (nbytes_chunk > chunksize)) {
     fprintf(stderr, "appending chunks with a larger chunksize than frame is not allowed yet"
                     "%d != %d", nbytes_chunk, chunksize);
     return NULL;
   }
 
   // Check that we are not appending a small chunk after another small chunk
   if ((nchunks > 0) && (nbytes_chunk < chunksize)) {
     uint8_t* last_chunk;
     bool needs_free;
     int retcode = frame_get_chunk(frame, nchunks - 1, &last_chunk, &needs_free);
     if (retcode < 0) {
       fprintf(stderr,
               "cannot get the last chunk (in position %d)", nchunks - 1);
       return NULL;
     }
     int32_t last_nbytes = sw32_(last_chunk + 4);
     if (needs_free) {
       free(last_chunk);
     }
     if ((last_nbytes < chunksize) && (nbytes < chunksize)) {
       fprintf(stderr,
               "appending two consecutive chunks with a chunksize smaller than the frame chunksize"
               "is not allowed yet: "
               "%d != %d", nbytes_chunk, chunksize);
       return NULL;
     }
   }
 
   // Get the current offsets and add one more
   int32_t off_nbytes = (nchunks + 1) * 8;
   int64_t* offsets = (int64_t *) malloc((size_t)off_nbytes);
   if (nchunks > 0) {
-    uint8_t *coffsets = get_coffsets(frame, header_len, cbytes);
+    int64_t coffsets_cbytes = 0;
+    uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, &coffsets_cbytes);
     if (coffsets == NULL) {
       fprintf(stderr, "Error: cannot get the offsets for the frame\n");
       return NULL;
     }
     // Decompress offsets
     blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;
     blosc2_context *dctx = blosc2_create_dctx(off_dparams);
-    int32_t prev_nbytes = blosc2_decompress_ctx(dctx, coffsets, offsets, (size_t) nchunks * 8);
+    int32_t prev_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes, offsets, (size_t) nchunks * 8);
     blosc2_free_ctx(dctx);
     if (prev_nbytes < 0) {
       free(offsets);
       fprintf(stderr, "Error: cannot decompress the offsets chunk");
       return NULL;
     }
   }
 
   // Add the new offset
   offsets[nchunks] = cbytes;
 
   // Re-compress the offsets again
   blosc2_context* cctx = blosc2_create_cctx(BLOSC2_CPARAMS_DEFAULTS);
   cctx->typesize = 8;
   void* off_chunk = malloc((size_t)off_nbytes + BLOSC_MAX_OVERHEAD);
   int32_t new_off_cbytes = blosc2_compress_ctx(cctx, (size_t)off_nbytes, offsets,
           off_chunk, (size_t)off_nbytes + BLOSC_MAX_OVERHEAD);
   blosc2_free_ctx(cctx);
   int64_t offset;
   int rc2 = blosc_getitem(off_chunk, nchunks, 1, &offset);
   // Safety check.  This is cheap and can save time while debugging.
   if (rc2 != 8 || offset != offsets[nchunks]) {
     fprintf(stderr, "Chunk offset has not being compressed correctly!\n");
     return NULL;
   }
   free(offsets);
   if (new_off_cbytes < 0) {
     free(off_chunk);
     return NULL;
   }
 
   int64_t new_frame_len = header_len + new_cbytes + new_off_cbytes + trailer_len;
 
   FILE* fp = NULL;
   if (frame->sdata != NULL) {
     uint8_t* framep = frame->sdata;
     /* Make space for the new chunk and copy it */
     frame->sdata = framep = realloc(framep, (size_t)new_frame_len);
     if (framep == NULL) {
       fprintf(stderr, "cannot realloc space for the frame.");
       return NULL;
     }
     /* Copy the chunk */
     memcpy(framep + header_len + cbytes, chunk, (size_t)cbytes_chunk);
     /* Copy the offsets */
     memcpy(framep + header_len + new_cbytes, off_chunk, (size_t)new_off_cbytes);
   } else {
     // fileframe
     fp = fopen(frame->fname, "rb+");
     fseek(fp, header_len + cbytes, SEEK_SET);
     size_t wbytes = fwrite(chunk, 1, (size_t)cbytes_chunk, fp);  // the new chunk
     if (wbytes != (size_t)cbytes_chunk) {
       fprintf(stderr, "cannot write the full chunk to fileframe.");
       return NULL;
     }
     wbytes = fwrite(off_chunk, 1, (size_t)new_off_cbytes, fp);  // the new offsets
     if (wbytes != (size_t)new_off_cbytes) {
       fprintf(stderr, "cannot write the offsets to fileframe.");
       return NULL;
     }
     fclose(fp);
     // Invalidate the cache for chunk offsets
     if (frame->coffsets != NULL) {
       free(frame->coffsets);
       frame->coffsets = NULL;
     }
   }
   free(chunk);
   free(off_chunk);
 
   frame->len = new_frame_len;
   rc = frame_update_header(frame, schunk, false);
   if (rc < 0) {
     return NULL;
   }
 
   rc = frame_update_trailer(frame, schunk);
   if (rc < 0) {
     return NULL;
   }
 
   return frame;
 }
 
 
 /* Decompress and return a chunk that is part of a frame. */
 int frame_decompress_chunk(blosc2_context *dctx, blosc2_frame *frame, int nchunk, void *dest, size_t nbytes) {
   uint8_t* src;
   bool needs_free;
-  int retcode = frame_get_chunk(frame, nchunk, &src, &needs_free);
-  if (retcode < 0) {
+  int chunk_cbytes = frame_get_chunk(frame, nchunk, &src, &needs_free);
+  if (chunk_cbytes < 0) {
     fprintf(stderr,
             "cannot get the chunk in position %d", nchunk);
     return -1;
   }
+  if (chunk_cbytes < sizeof(int32_t)) {
+    /* Not enough input to read `nbytes` */
+    return -1;
+  }
 
   /* Create a buffer for destination */
   int32_t nbytes_ = sw32_(src + 4);
   if (nbytes_ > (int32_t)nbytes) {
     fprintf(stderr, "Not enough space for decompressing in dest");
     return -1;
   }
 
   /* And decompress it */
-  int32_t chunksize = blosc2_decompress_ctx(dctx, src, dest, nbytes);
+  int32_t chunksize = blosc2_decompress_ctx(dctx, src, chunk_cbytes, dest, nbytes);
   if (chunksize < 0 || chunksize != nbytes_) {
     fprintf(stderr, "Error in decompressing chunk");
     return -11;
   }
 
   if (needs_free) {
     free(src);
   }
   return (int)chunksize;
 }
diff --git a/blosc/schunk.c b/blosc/schunk.c
index 807939a5..02f74d64 100644
--- a/blosc/schunk.c
+++ b/blosc/schunk.c
@@ -229,44 +229,44 @@ int blosc2_schunk_append_buffer(blosc2_schunk *schunk, void *src, size_t nbytes)
 /* Decompress and return a chunk that is part of a super-chunk. */
 int blosc2_schunk_decompress_chunk(blosc2_schunk *schunk, int nchunk,
                                    void *dest, size_t nbytes) {
 
   uint8_t* src;
   int chunksize;
   if (schunk->frame == NULL) {
     if (nchunk >= schunk->nchunks) {
       fprintf(stderr, "nchunk ('%d') exceeds the number of chunks "
                       "('%d') in super-chunk\n", nchunk, schunk->nchunks);
       return -11;
     }
     src = schunk->data[nchunk];
     int nbytes_ = sw32_(src + 4);
     if (nbytes < (size_t)nbytes_) {
       fprintf(stderr, "Buffer size is too small for the decompressed buffer "
                       "('%zd' bytes, but '%d' are needed)\n", nbytes, nbytes_);
       return -11;
     }
-
-    chunksize = blosc2_decompress_ctx(schunk->dctx, src, dest, nbytes);
+    int cbytes = sw32_(src + 12);
+    chunksize = blosc2_decompress_ctx(schunk->dctx, src, cbytes, dest, nbytes);
     if (chunksize < 0 || chunksize != nbytes_) {
       fprintf(stderr, "Error in decompressing chunk");
       return -11;
     }
   } else {
     chunksize = frame_decompress_chunk(schunk->dctx, schunk->frame, nchunk, dest, nbytes);
     if (chunksize < 0) {
       return -10;
     }
   }
   return chunksize;
 }
 
 /* Return a compressed chunk that is part of a super-chunk in the `chunk` parameter.
  * If the super-chunk is backed by a frame that is disk-based, a buffer is allocated for the
  * (compressed) chunk, and hence a free is needed.  You can check if the chunk requires a free
  * with the `needs_free` parameter.
  * If the chunk does not need a free, it means that a pointer to the location in the super-chunk
  * (or the backing in-memory frame) is returned in the `chunk` parameter.
  *
  * The size of the (compressed) chunk is returned.  If some problem is detected, a negative code
  * is returned instead.
 */
@@ -463,13 +463,13 @@ int blosc2_update_usermeta(blosc2_schunk *schunk, uint8_t *content, int32_t cont
 /* Retrieve the usermeta chunk */
 int32_t blosc2_get_usermeta(blosc2_schunk* schunk, uint8_t** content) {
   size_t nbytes, cbytes, blocksize;
   blosc_cbuffer_sizes(schunk->usermeta, &nbytes, &cbytes, &blocksize);
   *content = malloc(nbytes);
   blosc2_context *dctx = blosc2_create_dctx(BLOSC2_DPARAMS_DEFAULTS);
-  int usermeta_nbytes = blosc2_decompress_ctx(dctx, schunk->usermeta, *content, nbytes);
+  int usermeta_nbytes = blosc2_decompress_ctx(dctx, schunk->usermeta, schunk->usermeta_len, *content, nbytes);
   blosc2_free_ctx(dctx);
   if (usermeta_nbytes < 0) {
     return -1;
   }
   return (int32_t)nbytes;
 }
diff --git a/examples/contexts.c b/examples/contexts.c
index b6c92548..89832ca8 100644
--- a/examples/contexts.c
+++ b/examples/contexts.c
@@ -30,83 +30,83 @@
 int main(void) {
   static float data[SIZE];
   static float data_out[SIZE];
   static float data_dest[SIZE];
   float data_subset[5];
   float data_subset_ref[5] = {5, 6, 7, 8, 9};
   int isize = SIZE * sizeof(float), osize = SIZE * sizeof(float);
   int dsize = SIZE * sizeof(float), csize;
   int i, ret;
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_context *cctx, *dctx;
 
   /* Initialize dataset */
   for (i = 0; i < SIZE; i++) {
     data[i] = (float)i;
   }
 
   printf("Blosc version info: %s (%s)\n",
          BLOSC_VERSION_STRING, BLOSC_VERSION_DATE);
 
   /* Create a context for compression */
   cparams.typesize = sizeof(float);
   cparams.compcode = BLOSC_BLOSCLZ;
   cparams.filters[BLOSC2_MAX_FILTERS - 1] = BLOSC_SHUFFLE;
   cparams.clevel = 5;
   cparams.nthreads = NTHREADS;
   cctx = blosc2_create_cctx(cparams);
 
   /* Do the actual compression */
   csize = blosc2_compress_ctx(cctx, isize, data, data_out, osize);
   if (csize == 0) {
     printf("Buffer is uncompressible.  Giving up.\n");
     return 1;
   }
   else if (csize < 0) {
     printf("Compression error.  Error code: %d\n", csize);
     return csize;
   }
 
   printf("Compression: %d -> %d (%.1fx)\n", isize, csize, (1. * isize) / csize);
 
   /* Create a context for decompression */
   dparams.nthreads = NTHREADS;
   dctx = blosc2_create_dctx(dparams);
 
-  ret = blosc2_getitem_ctx(dctx, data_out, 5, 5, data_subset);
+  ret = blosc2_getitem_ctx(dctx, data_out, csize, 5, 5, data_subset);
   if (ret < 0) {
     printf("Error in blosc2_getitem_ctx().  Giving up.\n");
     return 1;
   }
 
   for (i = 0; i < 5; i++) {
     if (data_subset[i] != data_subset_ref[i]) {
       printf("blosc2_getitem_ctx() fetched data differs from original!\n");
       return -1;
     }
   }
   printf("Correctly extracted 5 elements from compressed chunk!\n");
 
   /* Decompress  */
-  dsize = blosc2_decompress_ctx(dctx, data_out, data_dest, dsize);
+  dsize = blosc2_decompress_ctx(dctx, data_out, csize, data_dest, dsize);
   if (dsize < 0) {
     printf("Decompression error.  Error code: %d\n", dsize);
     return dsize;
   }
 
   printf("Decompression succesful!\n");
 
   for (i = 0; i < SIZE; i++) {
     if (data[i] != data_dest[i]) {
       printf("Decompressed data differs from original!\n");
       return -1;
     }
   }
   printf("Succesful roundtrip!\n");
 
   /* Release resources */
   blosc2_free_ctx(cctx);
   blosc2_free_ctx(dctx);
 
   return 0;
 }
diff --git a/tests/test_contexts.c b/tests/test_contexts.c
index 4bccf6b9..02f93116 100644
--- a/tests/test_contexts.c
+++ b/tests/test_contexts.c
@@ -15,79 +15,79 @@
 int main(void) {
   static int32_t data[SIZE];
   static int32_t data_out[SIZE];
   static int32_t data_dest[SIZE];
   int32_t data_subset[5];
   int32_t data_subset_ref[5] = {5, 6, 7, 8, 9};
   size_t isize = SIZE * sizeof(int32_t), osize = SIZE * sizeof(int32_t);
   int dsize = SIZE * sizeof(int32_t), csize;
   int i, ret;
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_context *cctx, *dctx;
 
   /* Initialize dataset */
   for (i = 0; i < SIZE; i++) {
     data[i] = i;
   }
 
   printf("Blosc version info: %s (%s)\n",
          BLOSC_VERSION_STRING, BLOSC_VERSION_DATE);
 
   install_blosc_callback_test(); /* optionally install callback test */
 
   /* Create a context for compression */
   cparams.typesize = sizeof(int32_t);
   cparams.compcode = BLOSC_BLOSCLZ;
   cparams.filters[BLOSC2_MAX_FILTERS - 1] = BLOSC_SHUFFLE;
   cparams.clevel = 5;
   cparams.nthreads = NTHREADS;
   cctx = blosc2_create_cctx(cparams);
 
   /* Compress with clevel=5 and shuffle active  */
   csize = blosc2_compress_ctx(cctx, isize, data, data_out, osize);
   if (csize == 0) {
     printf("Buffer is uncompressible.  Giving up.\n");
     return EXIT_FAILURE;
   }
   if (csize < 0) {
     printf("Compression error.  Error code: %d\n", csize);
     return EXIT_FAILURE;
   }
 
   /* Create a context for decompression */
   dparams.nthreads = NTHREADS;
   dctx = blosc2_create_dctx(dparams);
 
-  ret = blosc2_getitem_ctx(dctx, data_out, 5, 5, data_subset);
+  ret = blosc2_getitem_ctx(dctx, data_out, csize, 5, 5, data_subset);
   if (ret < 0) {
     printf("Error in blosc2_getitem_ctx().  Giving up.\n");
     return EXIT_FAILURE;
   }
 
   for (i = 0; i < 5; i++) {
     if (data_subset[i] != data_subset_ref[i]) {
       printf("blosc2_getitem_ctx() fetched data differs from original!\n");
       return EXIT_FAILURE;
     }
   }
 
   /* Decompress  */
-  dsize = blosc2_decompress_ctx(dctx, data_out, data_dest, (size_t)dsize);
+  dsize = blosc2_decompress_ctx(dctx, data_out, csize, data_dest, (size_t)dsize);
   if (dsize < 0) {
     printf("Decompression error.  Error code: %d\n", dsize);
     return EXIT_FAILURE;
   }
 
   for (i = 0; i < SIZE; i++) {
     if (data[i] != data_dest[i]) {
       printf("Decompressed data differs from original!\n");
       return EXIT_FAILURE;
     }
   }
 
   /* Free resources */
   blosc2_free_ctx(cctx);
   blosc2_free_ctx(dctx);
 
   return EXIT_SUCCESS;
 }
diff --git a/tests/test_maskout.c b/tests/test_maskout.c
index af22c231..c373aa35 100644
--- a/tests/test_maskout.c
+++ b/tests/test_maskout.c
@@ -31,106 +31,106 @@ int nblocks;
 // Check decompression without mask
 static char *test_nomask(void) {
   blosc2_context *dctx = blosc2_create_dctx(BLOSC2_DPARAMS_DEFAULTS);
-  nbytes = blosc2_decompress_ctx(dctx, dest, dest2, bytesize);
+  nbytes = blosc2_decompress_ctx(dctx, dest, cbytes, dest2, bytesize);
   mu_assert("ERROR: nbytes is not correct", nbytes == bytesize);
 
   int64_t* _src = src;
   int64_t* _dst = dest2;
   for (int i = 0; i < size; i++) {
       mu_assert("ERROR: wrong values in dest", _dst[i] == _src[i]);
   }
 
   return 0;
 }
 
 
 // Check decompression with mask
 static char *test_mask(void) {
   blosc2_context *dctx = blosc2_create_dctx(BLOSC2_DPARAMS_DEFAULTS);
 
   memset(dest2, 0, bytesize);
   mu_assert("ERROR: setting maskout", blosc2_set_maskout(dctx, maskout, nblocks) == 0);
-  nbytes = blosc2_decompress_ctx(dctx, dest, dest2, bytesize);
+  nbytes = blosc2_decompress_ctx(dctx, dest, cbytes, dest2, bytesize);
   mu_assert("ERROR: nbytes is not correct", nbytes == bytesize);
 
   int64_t* _src = srcmasked;
   int64_t* _dst = dest2;
   for (int i = 0; i < size; i++) {
     mu_assert("ERROR: wrong values in dest", _dst[i] == _src[i]);
   }
 
   return 0;
 }
 
 
 // Check decompression with mask, and no mask aftewards
 static char *test_mask_nomask(void) {
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   dparams.nthreads = nthreads;
   blosc2_context *dctx = blosc2_create_dctx(dparams);
 
   memset(dest2, 0, bytesize);
   mu_assert("ERROR: setting maskout", blosc2_set_maskout(dctx, maskout, nblocks) == 0);
-  nbytes = blosc2_decompress_ctx(dctx, dest, dest2, bytesize);
+  nbytes = blosc2_decompress_ctx(dctx, dest, cbytes, dest2, bytesize);
   mu_assert("ERROR: nbytes is not correct w/ mask", nbytes == bytesize);
 
   int64_t* _src = srcmasked;  // masked source
   int64_t* _dst = dest2;
   for (int i = 0; i < size; i++) {
     mu_assert("ERROR: wrong values in dest", _dst[i] == _src[i]);
   }
 
   memset(dest2, 0, bytesize);
-  nbytes = blosc2_decompress_ctx(dctx, dest, dest2, bytesize);
+  nbytes = blosc2_decompress_ctx(dctx, dest, cbytes, dest2, bytesize);
   mu_assert("ERROR: nbytes is not correct w/out mask", nbytes == bytesize);
 
   _src = src;   // original source
   _dst = dest2;
   for (int i = 0; i < size; i++) {
     mu_assert("ERROR: wrong values in dest", _dst[i] == _src[i]);
   }
 
   return 0;
 }
 
 
 // Check decompression with mask, no mask, and then a different mask at last
 static char *test_mask_nomask_mask(void) {
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   dparams.nthreads = nthreads;
   blosc2_context *dctx = blosc2_create_dctx(dparams);
 
   memset(dest2, 0, bytesize);
   mu_assert("ERROR: setting maskout", blosc2_set_maskout(dctx, maskout, nblocks) == 0);
-  nbytes = blosc2_decompress_ctx(dctx, dest, dest2, bytesize);
+  nbytes = blosc2_decompress_ctx(dctx, dest, cbytes, dest2, bytesize);
   mu_assert("ERROR: nbytes is not correct w/ mask", nbytes == bytesize);
 
   int64_t* _src = srcmasked;  // masked source
   int64_t* _dst = dest2;
   for (int i = 0; i < size; i++) {
     mu_assert("ERROR: wrong values in dest", _dst[i] == _src[i]);
   }
 
   memset(dest2, 0, bytesize);
-  nbytes = blosc2_decompress_ctx(dctx, dest, dest2, bytesize);
+  nbytes = blosc2_decompress_ctx(dctx, dest, cbytes, dest2, bytesize);
   mu_assert("ERROR: nbytes is not correct w/out mask", nbytes == bytesize);
 
   _src = src;   // original source
   _dst = dest2;
   for (int i = 0; i < size; i++) {
     mu_assert("ERROR: wrong values in dest", _dst[i] == _src[i]);
   }
 
   memset(dest2, 0, bytesize);
   mu_assert("ERROR: setting maskout", blosc2_set_maskout(dctx, maskout2, nblocks) == 0);
-  nbytes = blosc2_decompress_ctx(dctx, dest, dest2, bytesize);
+  nbytes = blosc2_decompress_ctx(dctx, dest, cbytes, dest2, bytesize);
   mu_assert("ERROR: nbytes is not correct w/out mask", nbytes == bytesize);
 
   _src = srcmasked2;  // masked source
   _dst = dest2;
   for (int i = 0; i < size; i++) {
     mu_assert("ERROR: wrong values in dest", _dst[i] == _src[i]);
   }
 
   return 0;
 }
diff --git a/tests/test_prefilter.c b/tests/test_prefilter.c
index 259e5c5a..18da3c7b 100644
--- a/tests/test_prefilter.c
+++ b/tests/test_prefilter.c
@@ -58,33 +58,33 @@ int prefilter_func(blosc2_prefilter_params *pparams) {
 static char *test_prefilter1(void) {
   // Set some prefilter parameters and function
   cparams.prefilter = (blosc2_prefilter_fn)prefilter_func;
   // We need to zero the contents of the pparams.  TODO: make a constructor for ppparams.
   blosc2_prefilter_params pparams = {0};
   test_pparams tpparams = {0};
   tpparams.ninputs = 1;
   tpparams.inputs[0] = (uint8_t*)data;
   tpparams.input_typesizes[0] = cparams.typesize;
   pparams.user_data = (void*)&tpparams;
   cparams.pparams = &pparams;
   cctx = blosc2_create_cctx(cparams);
 
   csize = blosc2_compress_ctx(cctx, isize, data, data_out, osize);
   mu_assert("Compression error", csize > 0);
 
   /* Create a context for decompression */
   dctx = blosc2_create_dctx(dparams);
 
   /* Decompress  */
-  dsize = blosc2_decompress_ctx(dctx, data_out, data_dest, (size_t)dsize);
+  dsize = blosc2_decompress_ctx(dctx, data_out, csize, data_dest, (size_t)dsize);
   mu_assert("Decompression error", dsize > 0);
 
   for (int i = 0; i < SIZE; i++) {
     mu_assert("Decompressed data differs from original!", data[i] == data_dest[i]);
   }
 
   /* Free resources */
   blosc2_free_ctx(cctx);
   blosc2_free_ctx(dctx);
 
   return 0;
 }
@@ -93,39 +93,39 @@ static char *test_prefilter1(void) {
 static char *test_prefilter2(void) {
   // Set some prefilter parameters and function
   cparams.prefilter = (blosc2_prefilter_fn)prefilter_func;
   // We need to zero the contents of the pparams.  TODO: make a constructor for ppparams.
   blosc2_prefilter_params pparams = {0};
   test_pparams tpparams = {0};
   tpparams.ninputs = 2;
   tpparams.inputs[0] = (uint8_t*)data;
   tpparams.inputs[1] = (uint8_t*)data2;
   tpparams.input_typesizes[0] = cparams.typesize;
   tpparams.input_typesizes[1] = cparams.typesize;
   pparams.user_data = (void*)&tpparams;
   cparams.pparams = &pparams;
   cctx = blosc2_create_cctx(cparams);
 
   csize = blosc2_compress_ctx(cctx, isize, data, data_out, osize);
   mu_assert("Buffer is uncompressible", csize != 0);
   mu_assert("Compression error", csize > 0);
 
   /* Create a context for decompression */
   dctx = blosc2_create_dctx(dparams);
 
   /* Decompress  */
-  dsize = blosc2_decompress_ctx(dctx, data_out, data_dest, (size_t)dsize);
+  dsize = blosc2_decompress_ctx(dctx, data_out, csize, data_dest, (size_t)dsize);
   mu_assert("Decompression error", dsize > 0);
 
   for (int i = 0; i < SIZE; i++) {
     if ((data[i] + data2[i]) != data_dest[i]) {
       printf("Error in pos '%d': (%d + %d) != %d\n", i, data[i], data2[i], data_dest[i]);
     }
     mu_assert("Decompressed data differs from original!", (data[i] + data2[i]) == data_dest[i]);
   }
 
   /* Free resources */
   blosc2_free_ctx(cctx);
   blosc2_free_ctx(dctx);
 
   return 0;
 }
