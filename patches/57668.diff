commit 19cacf672930cee20feaf1f3468e3d5ac3099ffd
Author: Alan Modra <amodra@gmail.com>
Date:   Mon Apr 3 22:21:59 2023 +0930

    Use bfd_alloc memory for read_debugging_info storage
    
    Trying to free malloc'd memory used by the stabs and coff debug info
    parsers is complicated, and traversing the trees generated requires a
    lot of code.  It's better to bfd_alloc the memory which allows it all
    to be freed without fuss when the bfd is closed.  In the process of
    doing this I reverted most of commit a6336913332.
    
    Some of the stabs handling code grows arrays of pointers with realloc,
    to deal with arbitrary numbers of fields, function args, etc.  The
    code still does that but copies over to bfd_alloc memory when
    finished.  The alternative is to parse twice, once to size, then again
    to populate the arrays.  I think that complication is unwarranted.
    
    Note that there is a greater than zero chance this patch breaks
    something, eg. that I missed an attempt to free obj_alloc memory.
    Also it seems there are no tests in the binutils testsuite aimed at
    exercising objdump --debugging.
    
            * budbg.h (finish_stab, parse_stab): Update prototypes
            * debug.c: Include bucomm.h.
            (struct debug_handle): Add "abfd" field.
            (debug_init): Add "abfd" param.  bfd_alloc handle.
            (debug_xalloc, debug_xzalloc): New functions.  Use throughout
            in place of xmalloc and memset.
            (debug_start_source): Remove "name_used" param.
            * debug.h (debug_init, debug_start_source): Update prototypes.
            (debug_xalloc, debug_xzalloc): Declare.
            * objcopy.c (copy_object): Don't free dhandle.
            * objdump.c (dump_bfd): Likewise.
            * rdcoff.c (coff_get_slot): Add dhandle arg.  debug_xzalloc
            memory in place of xcalloc.  Update callers.
            (parse_coff_struct_type): Don't leak on error return.  Copy
            fields over to debug_xalloc memory.
            (parse_coff_enum_type): Copy names and vals over the
            debug_xalloc memory.
            * rddbg.c (read_debugging_info): Adjust debug_init call.
            Don't free dhandle.
            (read_section_stabs_debugging_info): Don't free shandle.
            Adjust parse_stab call.  Call finish_stab on error return.
            (read_symbol_stabs_debugging_info): Similarly.
            * stabs.c (savestring): Delete unnecessary forward declaration.
            Add dhandle param.  debug_xalloc memory.  Update callers.
            (start_stab): Delete unnecessary casts.
            (finish_stab): Add "emit" param.  Free file_types, so_string,
            and stabs handle.
            (parse_stab): Delete string_used param.  Revert code dealing
            with string_used.  Copy so_string passed to debug_set_filename
            and stored as main_filename to debug_xalloc memory.  Similarly
            for string passed to debug_start_source and push_bincl.  Copy
            args to debug_xalloc memory.  Don't leak args.
            (parse_stab_enum_type): Copy names and values to debug_xalloc
            memory.  Don't free name.
            (parse_stab_struct_type): Don't free fields.
            (parse_stab_baseclasses): Delete unnecessary cast.
            (parse_stab_struct_fields): Return debug_xalloc fields.
            (parse_stab_cpp_abbrev): Use debug_xalloc for _vb$ type name.
            (parse_stab_one_struct_field): Don't free name.
            (parse_stab_members): Copy variants and methods to
            debug_xalloc memory.  Don't free name or argtypes.
            (parse_stab_argtypes): Use debug_xalloc memory for physname
            and args.
            (push_bincl): Add dhandle param.  Use debug_xalloc memory.
            (stab_record_variable): Use debug_xalloc memory.
            (stab_emit_pending_vars): Don't free var list.
            (stab_find_slot): Add dhandle param.  Use debug_xzalloc
            memory.  Update all callers.
            (stab_find_tagged_type): Don't free name.  Use debug_xzalloc.
            (stab_demangle_qualified): Don't free name.
            (stab_demangle_template): Don't free s1.
            (stab_demangle_args): Tidy pvarargs refs.  Copy *pargs on
            success to debug_xalloc memory, free on failure.
            (stab_demangle_fund_type): Don't free name.
            (stab_demangle_v3_arglist): Copy args to debug_xalloc memory.
            Don't free dt.

diff --git a/binutils/budbg.h b/binutils/budbg.h
index 4a93b4e29b4..697b4439099 100644
--- a/binutils/budbg.h
+++ b/binutils/budbg.h
@@ -36,10 +36,10 @@ extern bool print_debugging_info
 
 extern void *start_stab (void *, bfd *, bool, asymbol **, long);
 
-extern bool finish_stab (void *, void *);
+extern bool finish_stab (void *, void *, bool);
 
 extern bool parse_stab
-  (void *, void *, int, int, bfd_vma, const char *, bool *);
+  (void *, void *, int, int, bfd_vma, const char *);
 
 extern bool write_stabs_in_sections_debugging_info
   (bfd *, void *, bfd_byte **, bfd_size_type *, bfd_byte **, bfd_size_type *);
diff --git a/binutils/debug.c b/binutils/debug.c
index fd9a98ad01b..53b45879e00 100644
--- a/binutils/debug.c
+++ b/binutils/debug.c
@@ -1,69 +1,72 @@
 /* debug.c -- Handle generic debugging information.
    Copyright (C) 1995-2023 Free Software Foundation, Inc.
    Written by Ian Lance Taylor <ian@cygnus.com>.
 
    This file is part of GNU Binutils.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
    02110-1301, USA.  */
 
 
 /* This file implements a generic debugging format.  We may eventually
    have readers which convert different formats into this generic
    format, and writers which write it out.  The initial impetus for
    this was writing a converter from stabs to HP IEEE-695 debugging
    format.  */
 
 #include "sysdep.h"
 #include <assert.h>
 #include "bfd.h"
 #include "libiberty.h"
 #include "filenames.h"
+#include "bucomm.h"
 #include "debug.h"
 
 /* Global information we keep for debugging.  A pointer to this
    structure is the debugging handle passed to all the routines.  */
 
 struct debug_handle
 {
+  /* The bfd where we objalloc memory.  */
+  bfd *abfd;
   /* A linked list of compilation units.  */
   struct debug_unit *units;
   /* The current compilation unit.  */
   struct debug_unit *current_unit;
   /* The current source file.  */
   struct debug_file *current_file;
   /* The current function.  */
   struct debug_function *current_function;
   /* The current block.  */
   struct debug_block *current_block;
   /* The current line number information for the current unit.  */
   struct debug_lineno *current_lineno;
   /* Mark.  This is used by debug_write.  */
   unsigned int mark;
   /* A struct/class ID used by debug_write.  */
   unsigned int class_id;
   /* The base for class_id for this call to debug_write.  */
   unsigned int base_id;
   /* The current line number in debug_write.  */
   struct debug_lineno *current_write_lineno;
   unsigned int current_write_lineno_index;
   /* A list of classes which have assigned ID's during debug_write.
      This is linked through the next_id field of debug_class_type.  */
   struct debug_class_id *id_list;
   /* A list used to avoid recursion during debug_type_samep.  */
   struct debug_type_compare_list *compare_list;
 };
 
 /* Information we keep for a single compilation unit.  */
@@ -600,36 +603,34 @@ debug_error (const char *message)
 /* Add an object to a namespace.  */
 
 static struct debug_name *
-debug_add_to_namespace (struct debug_handle *info ATTRIBUTE_UNUSED,
+debug_add_to_namespace (struct debug_handle *info,
 			struct debug_namespace **nsp, const char *name,
 			enum debug_object_kind kind,
 			enum debug_object_linkage linkage)
 {
   struct debug_name *n;
   struct debug_namespace *ns;
 
-  n = (struct debug_name *) xmalloc (sizeof *n);
-  memset (n, 0, sizeof *n);
+  n = debug_xzalloc (info, sizeof (*n));
 
   n->name = name;
   n->kind = kind;
   n->linkage = linkage;
 
   ns = *nsp;
   if (ns == NULL)
     {
-      ns = (struct debug_namespace *) xmalloc (sizeof *ns);
-      memset (ns, 0, sizeof *ns);
+      ns = debug_xzalloc (info, sizeof (*ns));
 
       ns->tail = &ns->list;
 
       *nsp = ns;
     }
 
   *ns->tail = n;
   ns->tail = &n->next;
 
   return n;
 }
 
 /* Add an object to the current namespace.  */
@@ -659,14 +660,31 @@ debug_add_to_current_namespace (struct debug_handle *info, const char *name,
 /* Return a handle for debugging information.  */
 
 void *
-debug_init (void)
+debug_init (bfd *abfd)
 {
   struct debug_handle *ret;
 
-  ret = (struct debug_handle *) xmalloc (sizeof *ret);
-  memset (ret, 0, sizeof *ret);
-  return (void *) ret;
+  ret = bfd_xalloc (abfd, sizeof (*ret));
+  memset (ret, 0, sizeof (*ret));
+  ret->abfd = abfd;
+  return ret;
+}
+
+void *
+debug_xalloc (void *handle, size_t size)
+{
+  struct debug_handle *info = (struct debug_handle *) handle;
+  return bfd_xalloc (info->abfd, size);
+}
+
+void *
+debug_xzalloc (void *handle, size_t size)
+{
+  struct debug_handle *info = (struct debug_handle *) handle;
+  void *mem = bfd_xalloc (info->abfd, size);
+  memset (mem, 0, size);
+  return mem;
 }
 
 /* Set the source filename.  This implicitly starts a new compilation
    unit.  */
@@ -675,88 +693,83 @@ bool
 debug_set_filename (void *handle, const char *name)
 {
   struct debug_handle *info = (struct debug_handle *) handle;
   struct debug_file *nfile;
   struct debug_unit *nunit;
 
   if (name == NULL)
     name = "";
 
-  nfile = (struct debug_file *) xmalloc (sizeof *nfile);
-  memset (nfile, 0, sizeof *nfile);
+  nfile = debug_xzalloc (info, sizeof (*nfile));
 
   nfile->filename = name;
 
-  nunit = (struct debug_unit *) xmalloc (sizeof *nunit);
-  memset (nunit, 0, sizeof *nunit);
+  nunit = debug_xzalloc (info, sizeof (*nunit));
 
   nunit->files = nfile;
   info->current_file = nfile;
 
   if (info->current_unit != NULL)
     info->current_unit->next = nunit;
   else
     {
       assert (info->units == NULL);
       info->units = nunit;
     }
 
   info->current_unit = nunit;
 
   info->current_function = NULL;
   info->current_block = NULL;
   info->current_lineno = NULL;
 
   return true;
 }
 
 /* Change source files to the given file name.  This is used for
    include files in a single compilation unit.  */
 
 bool
-debug_start_source (void *handle, const char *name, bool *name_used)
+debug_start_source (void *handle, const char *name)
 {
   struct debug_handle *info = (struct debug_handle *) handle;
   struct debug_file *f, **pf;
 
   if (name == NULL)
     name = "";
 
   if (info->current_unit == NULL)
     {
       debug_error (_("debug_start_source: no debug_set_filename call"));
       return false;
     }
 
   for (f = info->current_unit->files; f != NULL; f = f->next)
     {
       if (filename_cmp (f->filename, name) == 0)
 	{
 	  info->current_file = f;
 	  return true;
 	}
     }
 
-  f = (struct debug_file *) xmalloc (sizeof *f);
-  memset (f, 0, sizeof *f);
-
+  f = debug_xzalloc (info, sizeof (*f));
   f->filename = name;
-  *name_used = true;
 
   for (pf = &info->current_file->next;
        *pf != NULL;
        pf = &(*pf)->next)
     ;
   *pf = f;
 
   info->current_file = f;
 
   return true;
 }
 
 /* Record a function definition.  This implicitly starts a function
    block.  The debug_type argument is the type of the return value.
    The boolean indicates whether the function is globally visible.
    The bfd_vma is the address of the start of the function.  Currently
    the parameter types are specified by calls to
    debug_record_parameter.  FIXME: There is no way to specify nested
    functions.  */
@@ -765,54 +778,52 @@ bool
 debug_record_function (void *handle, const char *name,
 		       debug_type return_type, bool global,
 		       bfd_vma addr)
 {
   struct debug_handle *info = (struct debug_handle *) handle;
   struct debug_function *f;
   struct debug_block *b;
   struct debug_name *n;
 
   if (name == NULL)
     name = "";
   if (return_type == NULL)
     return false;
 
   if (info->current_unit == NULL)
     {
       debug_error (_("debug_record_function: no debug_set_filename call"));
       return false;
     }
 
-  f = (struct debug_function *) xmalloc (sizeof *f);
-  memset (f, 0, sizeof *f);
+  f = debug_xzalloc (info, sizeof (*f));
 
   f->return_type = return_type;
 
-  b = (struct debug_block *) xmalloc (sizeof *b);
-  memset (b, 0, sizeof *b);
+  b = debug_xzalloc (info, sizeof (*b));
 
   b->start = addr;
   b->end = (bfd_vma) -1;
 
   f->blocks = b;
 
   info->current_function = f;
   info->current_block = b;
 
   /* FIXME: If we could handle nested functions, this would be the
      place: we would want to use a different namespace.  */
   n = debug_add_to_namespace (info,
 			      &info->current_file->globals,
 			      name,
 			      DEBUG_OBJECT_FUNCTION,
 			      (global
 			       ? DEBUG_LINKAGE_GLOBAL
 			       : DEBUG_LINKAGE_STATIC));
   if (n == NULL)
     return false;
 
   n->u.function = f;
 
   return true;
 }
 
 /* Record a parameter for the current function.  */
@@ -821,34 +832,33 @@ bool
 debug_record_parameter (void *handle, const char *name, debug_type type,
 			enum debug_parm_kind kind, bfd_vma val)
 {
   struct debug_handle *info = (struct debug_handle *) handle;
   struct debug_parameter *p, **pp;
 
   if (name == NULL || type == NULL)
     return false;
 
   if (info->current_unit == NULL
       || info->current_function == NULL)
     {
       debug_error (_("debug_record_parameter: no current function"));
       return false;
     }
 
-  p = (struct debug_parameter *) xmalloc (sizeof *p);
-  memset (p, 0, sizeof *p);
+  p = debug_xzalloc (info, sizeof (*p));
 
   p->name = name;
   p->type = type;
   p->kind = kind;
   p->val = val;
 
   for (pp = &info->current_function->parameters;
        *pp != NULL;
        pp = &(*pp)->next)
     ;
   *pp = p;
 
   return true;
 }
 
 /* End a function.  FIXME: This should handle function nesting.  */
@@ -889,36 +899,35 @@ bool
 debug_start_block (void *handle, bfd_vma addr)
 {
   struct debug_handle *info = (struct debug_handle *) handle;
   struct debug_block *b, **pb;
 
   /* We must always have a current block: debug_record_function sets
      one up.  */
   if (info->current_unit == NULL
       || info->current_block == NULL)
     {
       debug_error (_("debug_start_block: no current block"));
       return false;
     }
 
-  b = (struct debug_block *) xmalloc (sizeof *b);
-  memset (b, 0, sizeof *b);
+  b = debug_xzalloc (info, sizeof (*b));
 
   b->parent = info->current_block;
   b->start = addr;
   b->end = (bfd_vma) -1;
 
   /* This new block is a child of the current block.  */
   for (pb = &info->current_block->children;
        *pb != NULL;
        pb = &(*pb)->next)
     ;
   *pb = b;
 
   info->current_block = b;
 
   return true;
 }
 
 /* Finish a block in a function.  This matches the call to
    debug_start_block.  The argument is the address at which this block
    ends.  */
@@ -957,55 +966,54 @@ bool
 debug_record_line (void *handle, unsigned long lineno, bfd_vma addr)
 {
   struct debug_handle *info = (struct debug_handle *) handle;
   struct debug_lineno *l;
   unsigned int i;
 
   if (info->current_unit == NULL)
     {
       debug_error (_("debug_record_line: no current unit"));
       return false;
     }
 
   l = info->current_lineno;
   if (l != NULL && l->file == info->current_file)
     {
       for (i = 0; i < DEBUG_LINENO_COUNT; i++)
 	{
 	  if (l->linenos[i] == (unsigned long) -1)
 	    {
 	      l->linenos[i] = lineno;
 	      l->addrs[i] = addr;
 	      return true;
 	    }
 	}
     }
 
   /* If we get here, then either 1) there is no current_lineno
      structure, which means this is the first line number in this
      compilation unit, 2) the current_lineno structure is for a
      different file, or 3) the current_lineno structure is full.
      Regardless, we want to allocate a new debug_lineno structure, put
      it in the right place, and make it the new current_lineno
      structure.  */
 
-  l = (struct debug_lineno *) xmalloc (sizeof *l);
-  memset (l, 0, sizeof *l);
+  l = debug_xzalloc (info, sizeof (*l));
 
   l->file = info->current_file;
   l->linenos[0] = lineno;
   l->addrs[0] = addr;
   for (i = 1; i < DEBUG_LINENO_COUNT; i++)
     l->linenos[i] = (unsigned long) -1;
 
   if (info->current_lineno != NULL)
     info->current_lineno->next = l;
   else
     info->current_unit->linenos = l;
 
   info->current_lineno = l;
 
   return true;
 }
 
 /* Start a named common block.  This is a block of variables that may
    move in memory.  */
@@ -1078,27 +1086,26 @@ bool
 debug_record_typed_const (void *handle, const char *name, debug_type type,
 			  bfd_vma val)
 {
   struct debug_handle *info = (struct debug_handle *) handle;
   struct debug_name *n;
   struct debug_typed_constant *tc;
 
   if (name == NULL || type == NULL)
     return false;
 
   n = debug_add_to_current_namespace (info, name, DEBUG_OBJECT_TYPED_CONSTANT,
 				      DEBUG_LINKAGE_NONE);
   if (n == NULL)
     return false;
 
-  tc = (struct debug_typed_constant *) xmalloc (sizeof *tc);
-  memset (tc, 0, sizeof *tc);
+  tc = debug_xzalloc (info, sizeof (*tc));
 
   tc->type = type;
   tc->val = val;
 
   n->u.typed_constant = tc;
 
   return true;
 }
 
 /* Record a label.  */
@@ -1120,71 +1127,69 @@ bool
 debug_record_variable (void *handle, const char *name, debug_type type,
 		       enum debug_var_kind kind, bfd_vma val)
 {
   struct debug_handle *info = (struct debug_handle *) handle;
   struct debug_namespace **nsp;
   enum debug_object_linkage linkage;
   struct debug_name *n;
   struct debug_variable *v;
 
   if (name == NULL || type == NULL)
     return false;
 
   if (info->current_unit == NULL
       || info->current_file == NULL)
     {
       debug_error (_("debug_record_variable: no current file"));
       return false;
     }
 
   if (kind == DEBUG_GLOBAL || kind == DEBUG_STATIC)
     {
       nsp = &info->current_file->globals;
       if (kind == DEBUG_GLOBAL)
 	linkage = DEBUG_LINKAGE_GLOBAL;
       else
 	linkage = DEBUG_LINKAGE_STATIC;
     }
   else
     {
       if (info->current_block == NULL)
 	nsp = &info->current_file->globals;
       else
 	nsp = &info->current_block->locals;
       linkage = DEBUG_LINKAGE_AUTOMATIC;
     }
 
   n = debug_add_to_namespace (info, nsp, name, DEBUG_OBJECT_VARIABLE, linkage);
   if (n == NULL)
     return false;
 
-  v = (struct debug_variable *) xmalloc (sizeof *v);
-  memset (v, 0, sizeof *v);
+  v = debug_xzalloc (info, sizeof (*v));
 
   v->kind = kind;
   v->type = type;
   v->val = val;
 
   n->u.variable = v;
 
   return true;
 }
 
 /* Make a type with a given kind and size.  */
 
 static struct debug_type_s *
-debug_make_type (struct debug_handle *info ATTRIBUTE_UNUSED,
+debug_make_type (struct debug_handle *info,
 		 enum debug_type_kind kind, unsigned int size)
 {
   struct debug_type_s *t;
 
-  t = (struct debug_type_s *) xmalloc (sizeof *t);
-  memset (t, 0, sizeof *t);
+  t = debug_xzalloc (info, sizeof (*t));
 
   t->kind = kind;
   t->size = size;
 
   return t;
 }
 
 /* Make an indirect type which may be used as a placeholder for a type
    which is referenced before it is defined.  */
@@ -1193,22 +1198,21 @@ debug_type
 debug_make_indirect_type (void *handle, debug_type *slot, const char *tag)
 {
   struct debug_handle *info = (struct debug_handle *) handle;
   struct debug_type_s *t;
   struct debug_indirect_type *i;
 
   t = debug_make_type (info, DEBUG_KIND_INDIRECT, 0);
   if (t == NULL)
     return DEBUG_TYPE_NULL;
 
-  i = (struct debug_indirect_type *) xmalloc (sizeof *i);
-  memset (i, 0, sizeof *i);
+  i = debug_xzalloc (info, sizeof (*i));
 
   i->slot = slot;
   i->tag = tag;
 
   t->u.kindirect = i;
 
   return t;
 }
 
 /* Make a void type.  There is only one of these.  */
@@ -1279,29 +1283,28 @@ debug_type
 debug_make_struct_type (void *handle, bool structp, bfd_vma size,
 			debug_field *fields)
 {
   struct debug_handle *info = (struct debug_handle *) handle;
   struct debug_type_s *t;
   struct debug_class_type *c;
 
   t = debug_make_type (info,
 		       structp ? DEBUG_KIND_STRUCT : DEBUG_KIND_UNION,
 		       size);
   if (t == NULL)
     return DEBUG_TYPE_NULL;
 
-  c = (struct debug_class_type *) xmalloc (sizeof *c);
-  memset (c, 0, sizeof *c);
+  c = debug_xzalloc (info, sizeof (*c));
 
   c->fields = fields;
 
   t->u.kclass = c;
 
   return t;
 }
 
 /* Make an object type.  The first three arguments after the handle
    are the same as for debug_make_struct_type.  The next arguments are
    a NULL terminated array of base classes, a NULL terminated array of
    methods, the type of the object holding the virtual function table
    if it is not this object, and a boolean which is true if this
    object has its own virtual function table.  */
@@ -1310,33 +1313,32 @@ debug_type
 debug_make_object_type (void *handle, bool structp, bfd_vma size,
 			debug_field *fields, debug_baseclass *baseclasses,
 			debug_method *methods, debug_type vptrbase,
 			bool ownvptr)
 {
   struct debug_handle *info = (struct debug_handle *) handle;
   struct debug_type_s *t;
   struct debug_class_type *c;
 
   t = debug_make_type (info,
 		       structp ? DEBUG_KIND_CLASS : DEBUG_KIND_UNION_CLASS,
 		       size);
   if (t == NULL)
     return DEBUG_TYPE_NULL;
 
-  c = (struct debug_class_type *) xmalloc (sizeof *c);
-  memset (c, 0, sizeof *c);
+  c = debug_xzalloc (info, sizeof (*c));
 
   c->fields = fields;
   c->baseclasses = baseclasses;
   c->methods = methods;
   if (ownvptr)
     c->vptrbase = t;
   else
     c->vptrbase = vptrbase;
 
   t->u.kclass = c;
 
   return t;
 }
 
 /* Make an enumeration type.  The arguments are a null terminated
    array of strings, and an array of corresponding values.  */
@@ -1345,23 +1347,22 @@ debug_type
 debug_make_enum_type (void *handle, const char **names,
 		      bfd_signed_vma *values)
 {
   struct debug_handle *info = (struct debug_handle *) handle;
   struct debug_type_s *t;
   struct debug_enum_type *e;
 
   t = debug_make_type (info, DEBUG_KIND_ENUM, 0);
   if (t == NULL)
     return DEBUG_TYPE_NULL;
 
-  e = (struct debug_enum_type *) xmalloc (sizeof *e);
-  memset (e, 0, sizeof *e);
+  e = debug_xzalloc (info, sizeof (*e));
 
   e->names = names;
   e->values = values;
 
   t->u.kenum = e;
 
   return t;
 }
 
 /* Make a pointer to a given type.  */
@@ -1396,27 +1397,26 @@ debug_type
 debug_make_function_type (void *handle, debug_type type,
 			  debug_type *arg_types, bool varargs)
 {
   struct debug_handle *info = (struct debug_handle *) handle;
   struct debug_type_s *t;
   struct debug_function_type *f;
 
   if (type == NULL)
     return DEBUG_TYPE_NULL;
 
   t = debug_make_type (info, DEBUG_KIND_FUNCTION, 0);
   if (t == NULL)
     return DEBUG_TYPE_NULL;
 
-  f = (struct debug_function_type *) xmalloc (sizeof *f);
-  memset (f, 0, sizeof *f);
+  f = debug_xzalloc (info, sizeof (*f));
 
   f->return_type = type;
   f->arg_types = arg_types;
   f->varargs = varargs;
 
   t->u.kfunction = f;
 
   return t;
 }
 
 /* Make a reference to a given type.  */
@@ -1445,31 +1445,30 @@ debug_type
 debug_make_range_type (void *handle, debug_type type, bfd_signed_vma lower,
 		       bfd_signed_vma upper)
 {
   struct debug_handle *info = (struct debug_handle *) handle;
   struct debug_type_s *t;
   struct debug_range_type *r;
 
   if (type == NULL)
     return DEBUG_TYPE_NULL;
 
   t = debug_make_type (info, DEBUG_KIND_RANGE, 0);
   if (t == NULL)
     return DEBUG_TYPE_NULL;
 
-  r = (struct debug_range_type *) xmalloc (sizeof *r);
-  memset (r, 0, sizeof *r);
+  r = debug_xzalloc (info, sizeof (*r));
 
   r->type = type;
   r->lower = lower;
   r->upper = upper;
 
   t->u.krange = r;
 
   return t;
 }
 
 /* Make an array type.  The second argument is the type of an element
    of the array.  The third argument is the type of a range of the
    array.  The fourth and fifth argument are the lower and upper
    bounds, respectively.  The sixth argument is true if this array is
    actually a string, as in C.  */
@@ -1478,32 +1477,31 @@ debug_type
 debug_make_array_type (void *handle, debug_type element_type,
 		       debug_type range_type, bfd_signed_vma lower,
 		       bfd_signed_vma upper, bool stringp)
 {
   struct debug_handle *info = (struct debug_handle *) handle;
   struct debug_type_s *t;
   struct debug_array_type *a;
 
   if (element_type == NULL || range_type == NULL)
     return DEBUG_TYPE_NULL;
 
   t = debug_make_type (info, DEBUG_KIND_ARRAY, 0);
   if (t == NULL)
     return DEBUG_TYPE_NULL;
 
-  a = (struct debug_array_type *) xmalloc (sizeof *a);
-  memset (a, 0, sizeof *a);
+  a = debug_xzalloc (info, sizeof (*a));
 
   a->element_type = element_type;
   a->range_type = range_type;
   a->lower = lower;
   a->upper = upper;
   a->stringp = stringp;
 
   t->u.karray = a;
 
   return t;
 }
 
 /* Make a set of a given type.  For example, a Pascal set type.  The
    boolean argument is true if this set is actually a bitstring, as in
    CHILL.  */
@@ -1512,28 +1510,27 @@ debug_type
 debug_make_set_type (void *handle, debug_type type, bool bitstringp)
 {
   struct debug_handle *info = (struct debug_handle *) handle;
   struct debug_type_s *t;
   struct debug_set_type *s;
 
   if (type == NULL)
     return DEBUG_TYPE_NULL;
 
   t = debug_make_type (info, DEBUG_KIND_SET, 0);
   if (t == NULL)
     return DEBUG_TYPE_NULL;
 
-  s = (struct debug_set_type *) xmalloc (sizeof *s);
-  memset (s, 0, sizeof *s);
+  s = debug_xzalloc (info, sizeof (*s));
 
   s->type = type;
   s->bitstringp = bitstringp;
 
   t->u.kset = s;
 
   return t;
 }
 
 /* Make a type for a pointer which is relative to an object.  The
    second argument is the type of the object to which the pointer is
    relative.  The third argument is the type that the pointer points
    to.  */
@@ -1542,28 +1539,27 @@ debug_type
 debug_make_offset_type (void *handle, debug_type base_type,
 			debug_type target_type)
 {
   struct debug_handle *info = (struct debug_handle *) handle;
   struct debug_type_s *t;
   struct debug_offset_type *o;
 
   if (base_type == NULL || target_type == NULL)
     return DEBUG_TYPE_NULL;
 
   t = debug_make_type (info, DEBUG_KIND_OFFSET, 0);
   if (t == NULL)
     return DEBUG_TYPE_NULL;
 
-  o = (struct debug_offset_type *) xmalloc (sizeof *o);
-  memset (o, 0, sizeof *o);
+  o = debug_xzalloc (info, sizeof (*o));
 
   o->base_type = base_type;
   o->target_type = target_type;
 
   t->u.koffset = o;
 
   return t;
 }
 
 /* Make a type for a method function.  The second argument is the
    return type, the third argument is the domain, and the fourth
    argument is a NULL terminated array of argument types.  */
@@ -1572,29 +1568,28 @@ debug_type
 debug_make_method_type (void *handle, debug_type return_type,
 			debug_type domain_type, debug_type *arg_types,
 			bool varargs)
 {
   struct debug_handle *info = (struct debug_handle *) handle;
   struct debug_type_s *t;
   struct debug_method_type *m;
 
   if (return_type == NULL)
     return DEBUG_TYPE_NULL;
 
   t = debug_make_type (info, DEBUG_KIND_METHOD, 0);
   if (t == NULL)
     return DEBUG_TYPE_NULL;
 
-  m = (struct debug_method_type *) xmalloc (sizeof *m);
-  memset (m, 0, sizeof *m);
+  m = debug_xzalloc (info, sizeof (*m));
 
   m->return_type = return_type;
   m->domain_type = domain_type;
   m->arg_types = arg_types;
   m->varargs = varargs;
 
   t->u.kmethod = m;
 
   return t;
 }
 
 /* Make a const qualified version of a given type.  */
@@ -1678,147 +1673,147 @@ debug_make_undefined_tagged_type (void *handle, const char *name,
    argument is the visibility of the base class.  */
 
 debug_baseclass
-debug_make_baseclass (void *handle ATTRIBUTE_UNUSED, debug_type type,
+debug_make_baseclass (void *handle, debug_type type,
 		      bfd_vma bitpos, bool is_virtual,
 		      enum debug_visibility visibility)
 {
+  struct debug_handle *info = (struct debug_handle *) handle;
   struct debug_baseclass_s *b;
 
-  b = (struct debug_baseclass_s *) xmalloc (sizeof *b);
-  memset (b, 0, sizeof *b);
+  b = debug_xzalloc (info, sizeof (*b));
 
   b->type = type;
   b->bitpos = bitpos;
   b->is_virtual = is_virtual;
   b->visibility = visibility;
 
   return b;
 }
 
 /* Make a field for a struct.  The second argument is the name.  The
    third argument is the type of the field.  The fourth argument is
    the bit position of the field.  The fifth argument is the size of
    the field (it may be zero).  The sixth argument is the visibility
    of the field.  */
 
 debug_field
-debug_make_field (void *handle ATTRIBUTE_UNUSED, const char *name,
+debug_make_field (void *handle, const char *name,
 		  debug_type type, bfd_vma bitpos, bfd_vma bitsize,
 		  enum debug_visibility visibility)
 {
+  struct debug_handle *info = (struct debug_handle *) handle;
   struct debug_field_s *f;
 
-  f = (struct debug_field_s *) xmalloc (sizeof *f);
-  memset (f, 0, sizeof *f);
+  f = debug_xzalloc (info, sizeof (*f));
 
   f->name = name;
   f->type = type;
   f->static_member = false;
   f->u.f.bitpos = bitpos;
   f->u.f.bitsize = bitsize;
   f->visibility = visibility;
 
   return f;
 }
 
 /* Make a static member of an object.  The second argument is the
    name.  The third argument is the type of the member.  The fourth
    argument is the physical name of the member (i.e., the name as a
    global variable).  The fifth argument is the visibility of the
    member.  */
 
 debug_field
-debug_make_static_member (void *handle ATTRIBUTE_UNUSED, const char *name,
+debug_make_static_member (void *handle, const char *name,
 			  debug_type type, const char *physname,
 			  enum debug_visibility visibility)
 {
+  struct debug_handle *info = (struct debug_handle *) handle;
   struct debug_field_s *f;
 
-  f = (struct debug_field_s *) xmalloc (sizeof *f);
-  memset (f, 0, sizeof *f);
+  f = debug_xzalloc (info, sizeof (*f));
 
   f->name = name;
   f->type = type;
   f->static_member = true;
   f->u.s.physname = physname;
   f->visibility = visibility;
 
   return f;
 }
 
 /* Make a method.  The second argument is the name, and the third
    argument is a NULL terminated array of method variants.  */
 
 debug_method
-debug_make_method (void *handle ATTRIBUTE_UNUSED, const char *name,
+debug_make_method (void *handle, const char *name,
 		   debug_method_variant *variants)
 {
+  struct debug_handle *info = (struct debug_handle *) handle;
   struct debug_method_s *m;
 
-  m = (struct debug_method_s *) xmalloc (sizeof *m);
-  memset (m, 0, sizeof *m);
+  m = debug_xzalloc (info, sizeof (*m));
 
   m->name = name;
   m->variants = variants;
 
   return m;
 }
 
 /* Make a method argument.  The second argument is the real name of
    the function.  The third argument is the type of the function.  The
    fourth argument is the visibility.  The fifth argument is whether
    this is a const function.  The sixth argument is whether this is a
    volatile function.  The seventh argument is the offset in the
    virtual function table, if any.  The eighth argument is the virtual
    function context.  FIXME: Are the const and volatile arguments
    necessary?  Could we just use debug_make_const_type?  */
 
 debug_method_variant
-debug_make_method_variant (void *handle ATTRIBUTE_UNUSED,
+debug_make_method_variant (void *handle,
 			   const char *physname, debug_type type,
 			   enum debug_visibility visibility,
 			   bool constp, bool volatilep,
 			   bfd_vma voffset, debug_type context)
 {
+  struct debug_handle *info = (struct debug_handle *) handle;
   struct debug_method_variant_s *m;
 
-  m = (struct debug_method_variant_s *) xmalloc (sizeof *m);
-  memset (m, 0, sizeof *m);
+  m = debug_xzalloc (info, sizeof (*m));
 
   m->physname = physname;
   m->type = type;
   m->visibility = visibility;
   m->constp = constp;
   m->volatilep = volatilep;
   m->voffset = voffset;
   m->context = context;
 
   return m;
 }
 
 /* Make a static method argument.  The arguments are the same as for
    debug_make_method_variant, except that the last two are omitted
    since a static method can not also be virtual.  */
 
 debug_method_variant
-debug_make_static_method_variant (void *handle ATTRIBUTE_UNUSED,
+debug_make_static_method_variant (void *handle,
 				  const char *physname, debug_type type,
 				  enum debug_visibility visibility,
 				  bool constp, bool volatilep)
 {
+  struct debug_handle *info = (struct debug_handle *) handle;
   struct debug_method_variant_s *m;
 
-  m = (struct debug_method_variant_s *) xmalloc (sizeof *m);
-  memset (m, 0, sizeof *m);
+  m = debug_xzalloc (info, sizeof (*m));
 
   m->physname = physname;
   m->type = type;
   m->visibility = visibility;
   m->constp = constp;
   m->volatilep = volatilep;
   m->voffset = VOFFSET_STATIC_METHOD;
 
   return m;
 }
 
 /* Name a type.  */
@@ -1827,44 +1822,43 @@ debug_type
 debug_name_type (void *handle, const char *name, debug_type type)
 {
   struct debug_handle *info = (struct debug_handle *) handle;
   struct debug_type_s *t;
   struct debug_named_type *n;
   struct debug_name *nm;
 
   if (name == NULL || type == NULL)
     return DEBUG_TYPE_NULL;
 
   if (info->current_unit == NULL
       || info->current_file == NULL)
     {
       debug_error (_("debug_name_type: no current file"));
       return DEBUG_TYPE_NULL;
     }
 
   t = debug_make_type (info, DEBUG_KIND_NAMED, 0);
   if (t == NULL)
     return DEBUG_TYPE_NULL;
 
-  n = (struct debug_named_type *) xmalloc (sizeof *n);
-  memset (n, 0, sizeof *n);
+  n = debug_xzalloc (info, sizeof (*n));
 
   n->type = type;
 
   t->u.knamed = n;
 
   /* We always add the name to the global namespace.  This is probably
      wrong in some cases, but it seems to be right for stabs.  FIXME.  */
 
   nm = debug_add_to_namespace (info, &info->current_file->globals, name,
 			       DEBUG_OBJECT_TYPE, DEBUG_LINKAGE_NONE);
   if (nm == NULL)
     return DEBUG_TYPE_NULL;
 
   nm->u.type = t;
 
   n->name = nm;
 
   return t;
 }
 
 /* Tag a type.  */
@@ -1873,51 +1867,50 @@ debug_type
 debug_tag_type (void *handle, const char *name, debug_type type)
 {
   struct debug_handle *info = (struct debug_handle *) handle;
   struct debug_type_s *t;
   struct debug_named_type *n;
   struct debug_name *nm;
 
   if (name == NULL || type == NULL)
     return DEBUG_TYPE_NULL;
 
   if (info->current_file == NULL)
     {
       debug_error (_("debug_tag_type: no current file"));
       return DEBUG_TYPE_NULL;
     }
 
   if (type->kind == DEBUG_KIND_TAGGED)
     {
       if (strcmp (type->u.knamed->name->name, name) == 0)
 	return type;
       debug_error (_("debug_tag_type: extra tag attempted"));
       return DEBUG_TYPE_NULL;
     }
 
   t = debug_make_type (info, DEBUG_KIND_TAGGED, 0);
   if (t == NULL)
     return DEBUG_TYPE_NULL;
 
-  n = (struct debug_named_type *) xmalloc (sizeof *n);
-  memset (n, 0, sizeof *n);
+  n = debug_xzalloc (info, sizeof (*n));
 
   n->type = type;
 
   t->u.knamed = n;
 
   /* We keep a global namespace of tags for each compilation unit.  I
      don't know if that is the right thing to do.  */
 
   nm = debug_add_to_namespace (info, &info->current_file->globals, name,
 			       DEBUG_OBJECT_TAG, DEBUG_LINKAGE_NONE);
   if (nm == NULL)
     return DEBUG_TYPE_NULL;
 
   nm->u.tag = t;
 
   n->name = nm;
 
   return t;
 }
 
 /* Record the size of a given type.  */
@@ -2946,60 +2939,59 @@ static bool
 debug_set_class_id (struct debug_handle *info, const char *tag,
 		    struct debug_type_s *type)
 {
   struct debug_class_type *c;
   struct debug_class_id *l;
 
   assert (type->kind == DEBUG_KIND_STRUCT
 	  || type->kind == DEBUG_KIND_UNION
 	  || type->kind == DEBUG_KIND_CLASS
 	  || type->kind == DEBUG_KIND_UNION_CLASS);
 
   c = type->u.kclass;
 
   if (c->id > info->base_id)
     return true;
 
   for (l = info->id_list; l != NULL; l = l->next)
     {
       if (l->type->kind != type->kind)
 	continue;
 
       if (tag == NULL)
 	{
 	  if (l->tag != NULL)
 	    continue;
 	}
       else
 	{
 	  if (l->tag == NULL
 	      || l->tag[0] != tag[0]
 	      || strcmp (l->tag, tag) != 0)
 	    continue;
 	}
 
       if (debug_type_samep (info, l->type, type))
 	{
 	  c->id = l->type->u.kclass->id;
 	  return true;
 	}
     }
 
   /* There are no identical types.  Use a new ID, and add it to the
      list.  */
   ++info->class_id;
   c->id = info->class_id;
 
-  l = (struct debug_class_id *) xmalloc (sizeof *l);
-  memset (l, 0, sizeof *l);
+  l = debug_xzalloc (info, sizeof (*l));
 
   l->type = type;
   l->tag = tag;
 
   l->next = info->id_list;
   info->id_list = l;
 
   return true;
 }
 
 /* See if two types are the same.  At this point, we don't care about
    tags and the like.  */
diff --git a/binutils/debug.h b/binutils/debug.h
index fd19c8bc8d4..d4998950b41 100644
--- a/binutils/debug.h
+++ b/binutils/debug.h
@@ -425,7 +425,12 @@ struct debug_write_fns
 
 /* Return a debugging handle.  */
 
-extern void *debug_init (void);
+extern void *debug_init (bfd *);
+
+/* Allocate bytes on the debug handle objalloc memory pool.  */
+
+extern void *debug_xalloc (void *, size_t);
+extern void *debug_xzalloc (void *, size_t);
 
 /* Set the source filename.  This implicitly starts a new compilation
    unit.  */
@@ -435,11 +440,11 @@ extern bool debug_set_filename (void *, const char *);
 /* Change source files to the given file name.  This is used for
    include files in a single compilation unit.  */
 
-extern bool debug_start_source (void *, const char *, bool *);
+extern bool debug_start_source (void *, const char *);
 
 /* Record a function definition.  This implicitly starts a function
    block.  The debug_type argument is the type of the return value.
    The bool indicates whether the function is globally visible.
    The bfd_vma is the address of the start of the function.  Currently
    the parameter types are specified by calls to
    debug_record_parameter.  */
diff --git a/binutils/objcopy.c b/binutils/objcopy.c
index 72585ea9ed7..957fb851432 100644
--- a/binutils/objcopy.c
+++ b/binutils/objcopy.c
@@ -2643,921 +2643,918 @@ static bool
 copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)
 {
   bfd_vma start;
   long symcount;
   asection **osections = NULL;
   asection *osec;
   asection *gnu_debuglink_section = NULL;
   bfd_size_type *gaps = NULL;
   bfd_size_type max_gap = 0;
   long symsize;
   void *dhandle;
   enum bfd_architecture iarch;
   unsigned int imach;
   unsigned int num_sec, i;
 
   if (ibfd->xvec->byteorder != obfd->xvec->byteorder
       && ibfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN
       && obfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN)
     {
       /* PR 17636: Call non-fatal so that we return to our parent who
 	 may need to tidy temporary files.  */
       non_fatal (_("unable to change endianness of '%s'"),
 		 bfd_get_archive_filename (ibfd));
       return false;
     }
 
   if (ibfd->read_only)
     {
       non_fatal (_("unable to modify '%s' due to errors"),
 		 bfd_get_archive_filename (ibfd));
       return false;
     }
 
   if (!bfd_set_format (obfd, bfd_get_format (ibfd)))
     {
       bfd_nonfatal_message (NULL, obfd, NULL, NULL);
       return false;
     }
 
   if (ibfd->sections == NULL)
     {
       non_fatal (_("error: the input file '%s' has no sections"),
 		 bfd_get_archive_filename (ibfd));
       return false;
     }
 
   /* This is a no-op on non-Coff targets.  */
   set_long_section_mode (obfd, ibfd, long_section_names);
 
   /* Set the Verilog output endianness based upon the input file's
      endianness.  We may not be producing verilog format output,
      but testing this just adds extra code this is not really
      necessary.  */
   VerilogDataEndianness = ibfd->xvec->byteorder;
 
   if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
     {
       if ((do_debug_sections & compress) != 0
 	  && do_debug_sections != compress)
 	{
 	  non_fatal (_ ("--compress-debug-sections=[zlib|zlib-gnu|zlib-gabi|"
 			"zstd] is unsupported on `%s'"),
 		     bfd_get_archive_filename (ibfd));
 	  return false;
 	}
 
       if (do_elf_stt_common)
 	{
 	  non_fatal (_("--elf-stt-common=[yes|no] is unsupported on `%s'"),
 		     bfd_get_archive_filename (ibfd));
 	  return false;
 	}
     }
 
   if (verbose)
     printf (_("copy from `%s' [%s] to `%s' [%s]\n"),
 	    bfd_get_archive_filename (ibfd), bfd_get_target (ibfd),
 	    bfd_get_filename (obfd), bfd_get_target (obfd));
 
   if (extract_symbol)
     start = 0;
   else
     {
       if (set_start_set)
 	start = set_start;
       else
 	start = bfd_get_start_address (ibfd);
       start += change_start;
     }
 
   /* Neither the start address nor the flags
      need to be set for a core file.  */
   if (bfd_get_format (obfd) != bfd_core)
     {
       flagword flags;
 
       flags = bfd_get_file_flags (ibfd);
       flags |= bfd_flags_to_set;
       flags &= ~bfd_flags_to_clear;
       flags &= bfd_applicable_file_flags (obfd);
 
       if (strip_symbols == STRIP_ALL)
 	flags &= ~HAS_RELOC;
 
       if (!bfd_set_start_address (obfd, start)
 	  || !bfd_set_file_flags (obfd, flags))
 	{
 	  bfd_nonfatal_message (NULL, ibfd, NULL, NULL);
 	  return false;
 	}
     }
 
   /* Copy architecture of input file to output file.  */
   iarch = bfd_get_arch (ibfd);
   imach = bfd_get_mach (ibfd);
   if (input_arch)
     {
       if (iarch == bfd_arch_unknown)
 	{
 	  iarch = input_arch->arch;
 	  imach = input_arch->mach;
 	}
       else
 	non_fatal (_("Input file `%s' ignores binary architecture parameter."),
 		   bfd_get_archive_filename (ibfd));
     }
   if (iarch == bfd_arch_unknown
       && bfd_get_flavour (ibfd) != bfd_target_elf_flavour
       && bfd_get_flavour (obfd) == bfd_target_elf_flavour)
     {
       const struct elf_backend_data *bed = get_elf_backend_data (obfd);
       iarch = bed->arch;
       imach = 0;
     }
   if (!bfd_set_arch_mach (obfd, iarch, imach)
       && (ibfd->target_defaulted
 	  || bfd_get_arch (ibfd) != bfd_get_arch (obfd)))
     {
       if (bfd_get_arch (ibfd) == bfd_arch_unknown)
 	non_fatal (_("Unable to recognise the format of the input file `%s'"),
 		   bfd_get_archive_filename (ibfd));
       else
 	non_fatal (_("Output file cannot represent architecture `%s'"),
 		   bfd_printable_arch_mach (bfd_get_arch (ibfd),
 					    bfd_get_mach (ibfd)));
       return false;
     }
 
   if (!bfd_set_format (obfd, bfd_get_format (ibfd)))
     {
       bfd_nonfatal_message (NULL, ibfd, NULL, NULL);
       return false;
     }
 
   if (bfd_get_flavour (obfd) == bfd_target_coff_flavour
       && bfd_pei_p (obfd))
     {
       /* Set up PE parameters.  */
       pe_data_type *pe = pe_data (obfd);
 
       /* Copy PE parameters before changing them.  */
       if (bfd_get_flavour (ibfd) == bfd_target_coff_flavour
 	  && bfd_pei_p (ibfd))
 	{
 	  pe->pe_opthdr = pe_data (ibfd)->pe_opthdr;
 
  	  if (preserve_dates)
 	    pe->timestamp = pe_data (ibfd)->coff.timestamp;
 	  else
 	    pe->timestamp = -1;
 	}
 
       if (pe_file_alignment != (bfd_vma) -1)
 	pe->pe_opthdr.FileAlignment = pe_file_alignment;
       else
 	pe_file_alignment = PE_DEF_FILE_ALIGNMENT;
 
       if (pe_heap_commit != (bfd_vma) -1)
 	pe->pe_opthdr.SizeOfHeapCommit = pe_heap_commit;
 
       if (pe_heap_reserve != (bfd_vma) -1)
 	pe->pe_opthdr.SizeOfHeapCommit = pe_heap_reserve;
 
       if (pe_image_base != (bfd_vma) -1)
 	pe->pe_opthdr.ImageBase = pe_image_base;
 
       if (pe_section_alignment != (bfd_vma) -1)
 	pe->pe_opthdr.SectionAlignment = pe_section_alignment;
       else
 	pe_section_alignment = PE_DEF_SECTION_ALIGNMENT;
 
       if (pe_stack_commit != (bfd_vma) -1)
 	pe->pe_opthdr.SizeOfStackCommit = pe_stack_commit;
 
       if (pe_stack_reserve != (bfd_vma) -1)
 	pe->pe_opthdr.SizeOfStackCommit = pe_stack_reserve;
 
       if (pe_subsystem != -1)
 	pe->pe_opthdr.Subsystem = pe_subsystem;
 
       if (pe_major_subsystem_version != -1)
 	pe->pe_opthdr.MajorSubsystemVersion = pe_major_subsystem_version;
 
       if (pe_minor_subsystem_version != -1)
 	pe->pe_opthdr.MinorSubsystemVersion = pe_minor_subsystem_version;
 
       if (pe_file_alignment > pe_section_alignment)
 	{
 	  non_fatal (_("warning: file alignment (0x%" PRIx64
 		       ") > section alignment (0x%" PRIx64 ")"),
 		     (uint64_t) pe_file_alignment,
 		     (uint64_t) pe_section_alignment);
 	}
     }
 
   free (isympp);
 
   if (osympp != isympp)
     free (osympp);
 
   isympp = NULL;
   osympp = NULL;
 
   symsize = bfd_get_symtab_upper_bound (ibfd);
   if (symsize < 0)
     {
       bfd_nonfatal_message (NULL, ibfd, NULL, NULL);
       return false;
     }
 
   osympp = isympp = (asymbol **) xmalloc (symsize);
   symcount = bfd_canonicalize_symtab (ibfd, isympp);
   if (symcount < 0)
     {
       bfd_nonfatal_message (NULL, ibfd, NULL, NULL);
       return false;
     }
   /* PR 17512: file:  d6323821
      If the symbol table could not be loaded do not pretend that we have
      any symbols.  This trips us up later on when we load the relocs.  */
   if (symcount == 0)
     {
       free (isympp);
       osympp = isympp = NULL;
     }
 
   /* BFD mandates that all output sections be created and sizes set before
      any output is done.  Thus, we traverse all sections multiple times.  */
   bfd_map_over_sections (ibfd, setup_section, obfd);
 
   if (!extract_symbol)
     setup_bfd_headers (ibfd, obfd);
 
   if (add_sections != NULL)
     {
       struct section_add *padd;
       struct section_list *pset;
 
       for (padd = add_sections; padd != NULL; padd = padd->next)
 	{
 	  flagword flags;
 
 	  pset = find_section_list (padd->name, false,
 				    SECTION_CONTEXT_SET_FLAGS);
 	  if (pset != NULL)
 	    {	      
 	      flags = pset->flags | SEC_HAS_CONTENTS;
 	      flags = check_new_section_flags (flags, obfd, padd->name);
 	    }
 	  else
 	    flags = SEC_HAS_CONTENTS | SEC_READONLY | SEC_DATA;
 
 	  /* bfd_make_section_with_flags() does not return very helpful
 	     error codes, so check for the most likely user error first.  */
 	  if (bfd_get_section_by_name (obfd, padd->name))
 	    {
 	      bfd_nonfatal_message (NULL, obfd, NULL,
 				    _("can't add section '%s'"), padd->name);
 	      return false;
 	    }
 	  else
 	    {
 	      /* We use LINKER_CREATED here so that the backend hooks
 		 will create any special section type information,
 		 instead of presuming we know what we're doing merely
 		 because we set the flags.  */
 	      padd->section = bfd_make_section_with_flags
 		(obfd, padd->name, flags | SEC_LINKER_CREATED);
 	      if (padd->section == NULL)
 		{
 		  bfd_nonfatal_message (NULL, obfd, NULL,
 					_("can't create section `%s'"),
 					padd->name);
 		  return false;
 		}
 	    }
 
 	  if (!bfd_set_section_size (padd->section, padd->size))
 	    {
 	      bfd_nonfatal_message (NULL, obfd, padd->section, NULL);
 	      return false;
 	    }
 
 	  pset = find_section_list (padd->name, false,
 				    SECTION_CONTEXT_SET_VMA | SECTION_CONTEXT_ALTER_VMA);
 	  if (pset != NULL
 	      && !bfd_set_section_vma (padd->section, pset->vma_val))
 	    {
 	      bfd_nonfatal_message (NULL, obfd, padd->section, NULL);
 	      return false;
 	    }
 
 	  pset = find_section_list (padd->name, false,
 				    SECTION_CONTEXT_SET_LMA | SECTION_CONTEXT_ALTER_LMA);
 	  if (pset != NULL)
 	    {
 	      padd->section->lma = pset->lma_val;
 
 	      if (!bfd_set_section_alignment
 		  (padd->section, bfd_section_alignment (padd->section)))
 		{
 		  bfd_nonfatal_message (NULL, obfd, padd->section, NULL);
 		  return false;
 		}
 	    }
 	}
     }
 
   if (update_sections != NULL)
     {
       struct section_add *pupdate;
 
       for (pupdate = update_sections;
 	   pupdate != NULL;
 	   pupdate = pupdate->next)
 	{
 	  pupdate->section = bfd_get_section_by_name (ibfd, pupdate->name);
 	  if (pupdate->section == NULL)
 	    {
 	      non_fatal (_("error: %s not found, can't be updated"), pupdate->name);
 	      return false;
 	    }
 
 	  osec = pupdate->section->output_section;
 	  if (!bfd_set_section_size (osec, pupdate->size))
 	    {
 	      bfd_nonfatal_message (NULL, obfd, osec, NULL);
 	      return false;
 	    }
 	}
     }
 
   merged_note_section * merged_note_sections = NULL;
   if (merge_notes)
     {
       /* This palaver is necessary because we must set the output
 	 section size first, before its contents are ready.  */
       for (osec = ibfd->sections; osec != NULL; osec = osec->next)
 	{
 	  if (! is_mergeable_note_section (ibfd, osec))
 	    continue;
 
 	  /* If the section is going to be completly deleted then
 	     do not bother to merge it.  */
 	  if (osec->output_section == NULL)
 	    continue;
 
 	  bfd_size_type size = bfd_section_size (osec);
 
 	  if (size == 0)
 	    /* This can happen, eg when stripping a binary for a second
 	       time.  See BZ 2121365 for an example.  */
 	    continue;
 
 	  merged_note_section * merged = xmalloc (sizeof * merged);
 	  merged->contents = NULL;
 	  if (! bfd_get_full_section_contents (ibfd, osec, & merged->contents))
 	    {
 	      bfd_nonfatal_message (NULL, ibfd, osec,
 				    _("warning: could not load note section"));
 	      free (merged);
 	      continue;
 	    }
 
 	  merged->size = merge_gnu_build_notes (ibfd, osec, size,
 						merged->contents);
 
 	  /* FIXME: Once we have read the contents in, we must write
 	     them out again.  So even if the mergeing has achieved
 	     nothing we still add this entry to the merge list.  */
 
 	  if (size != merged->size
 	      && !bfd_set_section_size (osec->output_section, merged->size))
 	    {
 	      bfd_nonfatal_message (NULL, obfd, osec,
 				    _("warning: failed to set merged notes size"));
 	      free (merged->contents);
 	      free (merged);
 	      continue;
 	    }
 
 	  /* Add section to list of merged sections.  */
 	  merged->sec  = osec;
 	  merged->next = merged_note_sections;
 	  merged_note_sections = merged;
 	}
     }
 
   if (dump_sections != NULL)
     {
       struct section_add * pdump;
 
       for (pdump = dump_sections; pdump != NULL; pdump = pdump->next)
 	{
 	  FILE * f;
 	  bfd_byte *contents;
 
 	  osec = bfd_get_section_by_name (ibfd, pdump->name);
 	  if (osec == NULL)
 	    {
 	      bfd_nonfatal_message (NULL, ibfd, NULL,
 				    _("can't dump section '%s' - it does not exist"),
 				    pdump->name);
 	      continue;
 	    }
 
 	  if ((bfd_section_flags (osec) & SEC_HAS_CONTENTS) == 0)
 	    {
 	      bfd_nonfatal_message (NULL, ibfd, osec,
 				    _("can't dump section - it has no contents"));
 	      continue;
 	    }
 
 	  bfd_size_type size = bfd_section_size (osec);
 	  /* Note - we allow the dumping of zero-sized sections,
 	     creating an empty file.  */
 
 	  f = fopen (pdump->filename, FOPEN_WB);
 	  if (f == NULL)
 	    {
 	      bfd_nonfatal_message (pdump->filename, NULL, NULL,
 				    _("could not open section dump file"));
 	      continue;
 	    }
 
 	  if (bfd_malloc_and_get_section (ibfd, osec, &contents))
 	    {
 	      if (size != 0 && fwrite (contents, 1, size, f) != size)
 		{
 		  non_fatal (_("error writing section contents to %s (error: %s)"),
 			     pdump->filename,
 			     strerror (errno));
 		  free (contents);
 		  fclose (f);
 		  return false;
 		}
 	    }
 	  else
 	    bfd_nonfatal_message (NULL, ibfd, osec,
 				  _("could not retrieve section contents"));
 
 	  fclose (f);
 	  free (contents);
 	}
     }
 
   if (gnu_debuglink_filename != NULL)
     {
       /* PR 15125: Give a helpful warning message if
 	 the debuglink section already exists, and
 	 allow the rest of the copy to complete.  */
       if (bfd_get_section_by_name (obfd, ".gnu_debuglink"))
 	{
 	  non_fatal (_("%s: debuglink section already exists"),
 		     bfd_get_filename (ibfd));
 	  gnu_debuglink_filename = NULL;
 	}
       else
 	{
 	  gnu_debuglink_section = bfd_create_gnu_debuglink_section
 	    (obfd, gnu_debuglink_filename);
 
 	  if (gnu_debuglink_section == NULL)
 	    {
 	      bfd_nonfatal_message (NULL, obfd, NULL,
 				    _("cannot create debug link section `%s'"),
 				    gnu_debuglink_filename);
 	      return false;
 	    }
 
 	  /* Special processing for PE format files.  We
 	     have no way to distinguish PE from COFF here.  */
 	  if (bfd_get_flavour (obfd) == bfd_target_coff_flavour)
 	    {
 	      bfd_vma debuglink_vma;
 	      asection * highest_section;
 
 	      /* The PE spec requires that all sections be adjacent and sorted
 		 in ascending order of VMA.  It also specifies that debug
 		 sections should be last.  This is despite the fact that debug
 		 sections are not loaded into memory and so in theory have no
 		 use for a VMA.
 
 		 This means that the debuglink section must be given a non-zero
 		 VMA which makes it contiguous with other debug sections.  So
 		 walk the current section list, find the section with the
 		 highest VMA and start the debuglink section after that one.  */
 	      for (osec = obfd->sections, highest_section = NULL;
 		   osec != NULL;
 		   osec = osec->next)
 		if (osec->vma > 0
 		    && (highest_section == NULL
 			|| osec->vma > highest_section->vma))
 		  highest_section = osec;
 
 	      if (highest_section)
 		debuglink_vma = BFD_ALIGN (highest_section->vma
 					   + highest_section->size,
 					   /* FIXME: We ought to be using
 					      COFF_PAGE_SIZE here or maybe
 					      bfd_section_alignment() (if it
 					      was set) but since this is for PE
 					      and we know the required alignment
 					      it is easier just to hard code it.  */
 					   0x1000);
 	      else
 		/* Umm, not sure what to do in this case.  */
 		debuglink_vma = 0x1000;
 
 	      bfd_set_section_vma (gnu_debuglink_section, debuglink_vma);
 	    }
 	}
     }
 
   num_sec = bfd_count_sections (obfd);
   if (num_sec != 0
       && (gap_fill_set || pad_to_set))
     {
       asection **set;
 
       /* We must fill in gaps between the sections and/or we must pad
 	 the last section to a specified address.  We do this by
 	 grabbing a list of the sections, sorting them by VMA, and
 	 increasing the section sizes as required to fill the gaps.
 	 We write out the gap contents below.  */
 
       osections = xmalloc (num_sec * sizeof (*osections));
       set = osections;
       bfd_map_over_sections (obfd, get_sections, &set);
 
       qsort (osections, num_sec, sizeof (*osections), compare_section_lma);
 
       gaps = xmalloc (num_sec * sizeof (*gaps));
       memset (gaps, 0, num_sec * sizeof (*gaps));
 
       if (gap_fill_set)
 	{
 	  for (i = 0; i < num_sec - 1; i++)
 	    {
 	      flagword flags;
 	      bfd_size_type size;           /* Octets.  */
 	      bfd_vma gap_start, gap_stop;  /* Octets.  */
 	      unsigned int opb1 = bfd_octets_per_byte (obfd, osections[i]);
 	      unsigned int opb2 = bfd_octets_per_byte (obfd, osections[i+1]);
 
 	      flags = bfd_section_flags (osections[i]);
 	      if ((flags & SEC_HAS_CONTENTS) == 0
 		  || (flags & SEC_LOAD) == 0)
 		continue;
 
 	      size = bfd_section_size (osections[i]);
 	      gap_start = bfd_section_lma (osections[i]) * opb1 + size;
 	      gap_stop = bfd_section_lma (osections[i + 1]) * opb2;
 	      if (gap_start < gap_stop)
 		{
 		  if (!bfd_set_section_size (osections[i],
 					     size + (gap_stop - gap_start)))
 		    {
 		      bfd_nonfatal_message (NULL, obfd, osections[i],
 					    _("Can't fill gap after section"));
 		      status = 1;
 		      break;
 		    }
 		  gaps[i] = gap_stop - gap_start;
 		  if (max_gap < gap_stop - gap_start)
 		    max_gap = gap_stop - gap_start;
 		}
 	    }
 	}
 
       if (pad_to_set)
 	{
 	  bfd_vma lma;         /* Octets.  */
 	  bfd_size_type size;  /* Octets.  */
 	  unsigned int opb = bfd_octets_per_byte (obfd, osections[num_sec - 1]);
 	  bfd_vma _pad_to = pad_to * opb;
 
 	  lma = bfd_section_lma (osections[num_sec - 1]) * opb;
 	  size = bfd_section_size (osections[num_sec - 1]);
 	  if (lma + size < _pad_to)
 	    {
 	      if (!bfd_set_section_size (osections[num_sec - 1], _pad_to - lma))
 		{
 		  bfd_nonfatal_message (NULL, obfd, osections[num_sec - 1],
 					_("can't add padding"));
 		  status = 1;
 		}
 	      else
 		{
 		  gaps[num_sec - 1] = _pad_to - (lma + size);
 		  if (max_gap < _pad_to - (lma + size))
 		    max_gap = _pad_to - (lma + size);
 		}
 	    }
 	}
     }
 
   /* Symbol filtering must happen after the output sections
      have been created, but before their contents are set.  */
   dhandle = NULL;
   if (convert_debugging)
     dhandle = read_debugging_info (ibfd, isympp, symcount, false);
 
    if ((obfd->flags & (EXEC_P | DYNAMIC)) != 0
        && (obfd->flags & HAS_RELOC) == 0)
     {
       if (bfd_keep_unused_section_symbols (obfd) || keep_section_symbols)
 	{
 	  /* Non-relocatable inputs may not have the unused section
 	     symbols.  Mark all section symbols as used to generate
 	     section symbols.  */
 	  asection *asect;
 	  for (asect = obfd->sections; asect != NULL; asect = asect->next)
 	    if (asect->symbol)
 	      asect->symbol->flags |= BSF_SECTION_SYM_USED;
 	}
       else
 	{
 	  /* Non-relocatable inputs may have the unused section symbols.
 	     Mark all section symbols as unused to excluded them.  */
 	  long s;
 	  for (s = 0; s < symcount; s++)
 	    if ((isympp[s]->flags & BSF_SECTION_SYM_USED))
 	      isympp[s]->flags &= ~BSF_SECTION_SYM_USED;
 	}
     }
 
   if (strip_symbols == STRIP_DEBUG
       || strip_symbols == STRIP_ALL
       || strip_symbols == STRIP_UNNEEDED
       || strip_symbols == STRIP_NONDEBUG
       || strip_symbols == STRIP_DWO
       || strip_symbols == STRIP_NONDWO
       || discard_locals != LOCALS_UNDEF
       || localize_hidden
       || htab_elements (strip_specific_htab) != 0
       || htab_elements (keep_specific_htab) != 0
       || htab_elements (localize_specific_htab) != 0
       || htab_elements (globalize_specific_htab) != 0
       || htab_elements (keepglobal_specific_htab) != 0
       || htab_elements (weaken_specific_htab) != 0
       || htab_elements (redefine_specific_htab) != 0
       || prefix_symbols_string
       || sections_removed
       || sections_copied
       || convert_debugging
       || change_leading_char
       || remove_leading_char
       || section_rename_list
       || weaken
       || add_symbols)
     {
       /* Mark symbols used in output relocations so that they
 	 are kept, even if they are local labels or static symbols.
 
 	 Note we iterate over the input sections examining their
 	 relocations since the relocations for the output sections
 	 haven't been set yet.  mark_symbols_used_in_relocations will
 	 ignore input sections which have no corresponding output
 	 section.  */
       if (strip_symbols != STRIP_ALL)
 	{
 	  bfd_set_error (bfd_error_no_error);
 	  bfd_map_over_sections (ibfd,
 				 mark_symbols_used_in_relocations,
 				 isympp);
 	  if (bfd_get_error () != bfd_error_no_error)
 	    {
 	      status = 1;
 	      return false;
 	    }
 	}
 
       osympp = (asymbol **) xmalloc ((symcount + add_symbols + 1) * sizeof (asymbol *));
       symcount = filter_symbols (ibfd, obfd, osympp, isympp, symcount);
     }
 
-  if (convert_debugging && dhandle != NULL)
+  if (dhandle != NULL)
     {
       bool res;
 
       res = write_debugging_info (obfd, dhandle, &symcount, &osympp);
 
-      free (dhandle);
-      dhandle = NULL; /* Paranoia...  */
-
       if (! res)
 	{
 	  status = 1;
 	  return false;
 	}
     }
 
   bfd_set_symtab (obfd, osympp, symcount);
 
   /* This has to happen before section positions are set.  */
   bfd_map_over_sections (ibfd, copy_relocations_in_section, obfd);
   if (status != 0)
     return false;
 
   /* This has to happen after the symbol table has been set.  */
   bfd_map_over_sections (ibfd, copy_section, obfd);
   if (status != 0)
     return false;
 
   if (add_sections != NULL)
     {
       struct section_add *padd;
 
       for (padd = add_sections; padd != NULL; padd = padd->next)
 	{
 	  if (! bfd_set_section_contents (obfd, padd->section, padd->contents,
 					  0, padd->size))
 	    {
 	      bfd_nonfatal_message (NULL, obfd, padd->section, NULL);
 	      return false;
 	    }
 	}
     }
 
   if (update_sections != NULL)
     {
       struct section_add *pupdate;
 
       for (pupdate = update_sections;
 	   pupdate != NULL;
 	   pupdate = pupdate->next)
 	{
 	  osec = pupdate->section->output_section;
 	  if (! bfd_set_section_contents (obfd, osec, pupdate->contents,
 					  0, pupdate->size))
 	    {
 	      bfd_nonfatal_message (NULL, obfd, osec, NULL);
 	      return false;
 	    }
 	}
     }
 
   if (merged_note_sections != NULL)
     {
       merged_note_section * merged = NULL;
 
       for (osec = obfd->sections; osec != NULL; osec = osec->next)
 	{
 	  if (! is_mergeable_note_section (obfd, osec))
 	    continue;
 
 	  if (merged == NULL)
 	    merged = merged_note_sections;
 
 	  /* It is likely that output sections are in the same order
 	     as the input sections, but do not assume that this is
 	     the case.  */
 	  if (merged->sec->output_section != osec)
 	    {
 	      for (merged = merged_note_sections;
 		   merged != NULL;
 		   merged = merged->next)
 		if (merged->sec->output_section == osec)
 		  break;
 
 	      if (merged == NULL)
 		{
 		  bfd_nonfatal_message
 		    (NULL, obfd, osec,
 		     _("error: failed to locate merged notes"));
 		  continue;
 		}
 	    }
 
 	  if (merged->contents == NULL)
 	    {
 	      bfd_nonfatal_message
 		(NULL, obfd, osec,
 		 _("error: failed to merge notes"));
 	      continue;
 	    }
 
 	  if (! bfd_set_section_contents (obfd, osec, merged->contents, 0,
 					  merged->size))
 	    {
 	      bfd_nonfatal_message
 		(NULL, obfd, osec,
 		 _("error: failed to copy merged notes into output"));
 	      return false;
 	    }
 
 	  merged = merged->next;
 	}
 
       /* Free the memory.  */
       merged_note_section * next;
       for (merged = merged_note_sections; merged != NULL; merged = next)
 	{
 	  next = merged->next;
 	  free (merged->contents);
 	  free (merged);
 	}
     }
   else if (merge_notes && ! is_strip)
     non_fatal (_("%s: Could not find any mergeable note sections"),
 	       bfd_get_filename (ibfd));
 
   if (gnu_debuglink_filename != NULL)
     {
       if (! bfd_fill_in_gnu_debuglink_section
 	  (obfd, gnu_debuglink_section, gnu_debuglink_filename))
 	{
 	  bfd_nonfatal_message (NULL, obfd, NULL,
 				_("cannot fill debug link section `%s'"),
 				gnu_debuglink_filename);
 	  return false;
 	}
     }
 
   if (gaps != NULL)
     {
       bfd_byte *buf;
 
       /* Fill in the gaps.  */
       if (max_gap > 8192)
 	max_gap = 8192;
       buf = (bfd_byte *) xmalloc (max_gap);
       memset (buf, gap_fill, max_gap);
 
       for (i = 0; i < num_sec; i++)
 	{
 	  if (gaps[i] != 0)
 	    {
 	      bfd_size_type left;
 	      file_ptr off;
 
 	      left = gaps[i];
 	      off = bfd_section_size (osections[i]) - left;
 
 	      while (left > 0)
 		{
 		  bfd_size_type now;
 
 		  if (left > 8192)
 		    now = 8192;
 		  else
 		    now = left;
 
 		  if (! bfd_set_section_contents (obfd, osections[i], buf,
 						  off, now))
 		    {
 		      bfd_nonfatal_message (NULL, obfd, osections[i], NULL);
 		      free (buf);
 		      return false;
 		    }
 
 		  left -= now;
 		  off += now;
 		}
 	    }
 	}
 
       free (buf);
       free (gaps);
       gaps = NULL;
     }
 
   /* Allow the BFD backend to copy any private data it understands
      from the input BFD to the output BFD.  This is done last to
      permit the routine to look at the filtered symbol table, which is
      important for the ECOFF code at least.  */
   if (! bfd_copy_private_bfd_data (ibfd, obfd))
     {
       bfd_nonfatal_message (NULL, obfd, NULL,
 			    _("error copying private BFD data"));
       return false;
     }
 
   /* Switch to the alternate machine code.  We have to do this at the
      very end, because we only initialize the header when we create
      the first section.  */
   if (use_alt_mach_code != 0)
     {
       if (! bfd_alt_mach_code (obfd, use_alt_mach_code))
 	{
 	  non_fatal (_("this target does not support %lu alternative machine codes"),
 		     use_alt_mach_code);
 	  if (bfd_get_flavour (obfd) == bfd_target_elf_flavour)
 	    {
 	      non_fatal (_("treating that number as an absolute e_machine value instead"));
 	      elf_elfheader (obfd)->e_machine = use_alt_mach_code;
 	    }
 	  else
 	    non_fatal (_("ignoring the alternative value"));
 	}
     }
 
   return true;
 }
 
 /* Read each archive element in turn from IBFD, copy the
    contents to temp file, and keep the temp file handle.
    If 'force_output_target' is TRUE then make sure that
    all elements in the new archive are of the type
    'output_target'.  */
diff --git a/binutils/objdump.c b/binutils/objdump.c
index 5dac13ba868..3f4399194ad 100644
--- a/binutils/objdump.c
+++ b/binutils/objdump.c
@@ -5537,201 +5537,199 @@ static void
 dump_bfd (bfd *abfd, bool is_mainfile)
 {
   const struct elf_backend_data * bed;
 
   if (bfd_big_endian (abfd))
     byte_get = byte_get_big_endian;
   else if (bfd_little_endian (abfd))
     byte_get = byte_get_little_endian;
   else
     byte_get = NULL;
 
   /* Load any separate debug information files.  */
   if (byte_get != NULL && might_need_separate_debug_info (is_mainfile))
     {
       load_separate_debug_files (abfd, bfd_get_filename (abfd));
 
       /* If asked to do so, recursively dump the separate files.  */
       if (do_follow_links)
 	{
 	  separate_info * i;
 
 	  for (i = first_separate_info; i != NULL; i = i->next)
 	    dump_bfd (i->handle, false);
 	}
     }
 
   /* Adjust user-specified start and stop limits for targets that use
      signed addresses.  */
   if (bfd_get_flavour (abfd) == bfd_target_elf_flavour
       && (bed = get_elf_backend_data (abfd)) != NULL
       && bed->sign_extend_vma)
     {
       start_address = sign_extend_address (abfd, start_address,
 					   bed->s->arch_size);
       stop_address = sign_extend_address (abfd, stop_address,
 					  bed->s->arch_size);
     }
 
   /* If we are adjusting section VMA's, change them all now.  Changing
      the BFD information is a hack.  However, we must do it, or
      bfd_find_nearest_line will not do the right thing.  */
   if (adjust_section_vma != 0)
     {
       bool has_reloc = (abfd->flags & HAS_RELOC);
       bfd_map_over_sections (abfd, adjust_addresses, &has_reloc);
     }
 
   if (is_mainfile || process_links)
     {
       if (! dump_debugging_tags && ! suppress_bfd_header)
 	printf (_("\n%s:     file format %s\n"),
 		sanitize_string (bfd_get_filename (abfd)),
 		abfd->xvec->name);
       if (dump_ar_hdrs)
 	print_arelt_descr (stdout, abfd, true, false);
       if (dump_file_header)
 	dump_bfd_header (abfd);
       if (dump_private_headers)
 	dump_bfd_private_header (abfd);
       if (dump_private_options != NULL)
 	dump_target_specific (abfd);
       if (! dump_debugging_tags && ! suppress_bfd_header)
 	putchar ('\n');
     }
 
   if (dump_symtab
       || dump_reloc_info
       || disassemble
       || dump_debugging
       || dump_dwarf_section_info)
     {
       syms = slurp_symtab (abfd);
 
       /* If following links, load any symbol tables from the linked files as well.  */
       if (do_follow_links && is_mainfile)
 	{
 	  separate_info * i;
 
 	  for (i = first_separate_info; i != NULL; i = i->next)
 	    {
 	      asymbol **  extra_syms;
 	      long        old_symcount = symcount;
 
 	      extra_syms = slurp_symtab (i->handle);
 
 	      if (extra_syms)
 		{
 		  if (old_symcount == 0)
 		    {
 		      syms = extra_syms;
 		    }
 		  else
 		    {
 		      syms = xrealloc (syms, ((symcount + old_symcount + 1)
 					      * sizeof (asymbol *)));
 		      memcpy (syms + old_symcount,
 			      extra_syms,
 			      (symcount + 1) * sizeof (asymbol *));
 		    }
 		}
 
 	      symcount += old_symcount;
 	    }
 	}
     }
 
   if (is_mainfile || process_links)
     {
       if (dump_section_headers)
 	dump_headers (abfd);
 
       if (dump_dynamic_symtab || dump_dynamic_reloc_info
 	  || (disassemble && bfd_get_dynamic_symtab_upper_bound (abfd) > 0))
 	dynsyms = slurp_dynamic_symtab (abfd);
 
       if (disassemble)
 	{
 	  synthcount = bfd_get_synthetic_symtab (abfd, symcount, syms,
 						 dynsymcount, dynsyms,
 						 &synthsyms);
 	  if (synthcount < 0)
 	    synthcount = 0;
 	}
 
       if (dump_symtab)
 	dump_symbols (abfd, false);
       if (dump_dynamic_symtab)
 	dump_symbols (abfd, true);
     }
   if (dump_dwarf_section_info)
     dump_dwarf (abfd, is_mainfile);
   if (is_mainfile || process_links)
     {
       if (dump_ctf_section_info)
 	dump_ctf (abfd, dump_ctf_section_name, dump_ctf_parent_name);
       if (dump_sframe_section_info)
 	dump_section_sframe (abfd, dump_sframe_section_name);
       if (dump_stab_section_info)
 	dump_stabs (abfd);
       if (dump_reloc_info && ! disassemble)
 	dump_relocs (abfd);
       if (dump_dynamic_reloc_info && ! disassemble)
 	dump_dynamic_relocs (abfd);
       if (dump_section_contents)
 	dump_data (abfd);
       if (disassemble)
 	disassemble_data (abfd);
     }
 
   if (dump_debugging)
     {
       void *dhandle;
 
       dhandle = read_debugging_info (abfd, syms, symcount, true);
       if (dhandle != NULL)
 	{
 	  if (!print_debugging_info (stdout, dhandle, abfd, syms,
 				     bfd_demangle,
 				     dump_debugging_tags != 0))
 	    {
 	      non_fatal (_("%s: printing debugging information failed"),
 			 bfd_get_filename (abfd));
 	      exit_status = 1;
 	    }
-
-	  free (dhandle);
 	}
       /* PR 6483: If there was no STABS debug info in the file, try
 	 DWARF instead.  */
       else if (! dump_dwarf_section_info)
 	{
 	  dwarf_select_sections_all ();
 	  dump_dwarf (abfd, is_mainfile);
 	}
     }
 
   if (syms)
     {
       free (syms);
       syms = NULL;
     }
 
   if (dynsyms)
     {
       free (dynsyms);
       dynsyms = NULL;
     }
 
   if (synthsyms)
     {
       free (synthsyms);
       synthsyms = NULL;
     }
 
   symcount = 0;
   dynsymcount = 0;
   synthcount = 0;
 
   if (is_mainfile)
     free_debug_memory ();
 }
diff --git a/binutils/rdcoff.c b/binutils/rdcoff.c
index 95b3c54cff8..17e89e87d74 100644
--- a/binutils/rdcoff.c
+++ b/binutils/rdcoff.c
@@ -84,25 +84,25 @@ static debug_type parse_coff_enum_type
 /* Return the slot for a type.  */
 
 static debug_type *
-coff_get_slot (struct coff_types **types, long indx)
+coff_get_slot (void *dhandle, struct coff_types **types, long indx)
 {
   unsigned int base_index;
 
   base_index = indx / COFF_SLOTS * COFF_SLOTS;
   indx -= base_index;
 
   while (*types && (*types)->base_index < base_index)
     types = &(*types)->next;
 
   if (*types == NULL || (*types)->base_index != base_index)
     {
-      struct coff_types *n = xcalloc (1, sizeof (*n));
+      struct coff_types *n = debug_xzalloc (dhandle, sizeof (*n));
       n->next = *types;
       n->base_index = base_index;
       *types = n;
     }
 
   return (*types)->types + indx;
 }
 
 /* Parse a COFF type code in NTYPE.  */
@@ -111,95 +111,95 @@ static debug_type
 parse_coff_type (bfd *abfd, struct coff_symbols *symbols,
 		 struct coff_types **types, long coff_symno, int ntype,
 		 union internal_auxent *pauxent, bool useaux,
 		 void *dhandle)
 {
   debug_type type;
 
   if ((ntype & ~N_BTMASK) != 0)
     {
       int newtype;
 
       newtype = DECREF (ntype);
 
       if (ISPTR (ntype))
 	{
 	  type = parse_coff_type (abfd, symbols, types, coff_symno, newtype,
 				  pauxent, useaux, dhandle);
 	  type = debug_make_pointer_type (dhandle, type);
 	}
       else if (ISFCN (ntype))
 	{
 	  type = parse_coff_type (abfd, symbols, types, coff_symno, newtype,
 				  pauxent, useaux, dhandle);
 	  type = debug_make_function_type (dhandle, type, (debug_type *) NULL,
 					   false);
 	}
       else if (ISARY (ntype))
 	{
 	  int n;
 
 	  if (pauxent == NULL)
 	    n = 0;
 	  else
 	    {
 	      unsigned short *dim;
 	      int i;
 
 	      /* FIXME: If pauxent->x_sym.x_tagndx.l == 0, gdb sets
                  the c_naux field of the syment to 0.  */
 
 	      /* Move the dimensions down, so that the next array
                  picks up the next one.  */
 	      dim = pauxent->x_sym.x_fcnary.x_ary.x_dimen;
 	      n = dim[0];
 	      for (i = 0; *dim != 0 && i < DIMNUM - 1; i++, dim++)
 		*dim = *(dim + 1);
 	      *dim = 0;
 	    }
 
 	  type = parse_coff_type (abfd, symbols, types, coff_symno, newtype,
 				  pauxent, false, dhandle);
 	  type = debug_make_array_type (dhandle, type,
 					parse_coff_base_type (abfd, symbols,
 							      types,
 							      coff_symno,
 							      T_INT,
 							      NULL, dhandle),
 					0, n - 1, false);
 	}
       else
 	{
 	  non_fatal (_("parse_coff_type: Bad type code 0x%x"), ntype);
 	  return DEBUG_TYPE_NULL;
 	}
 
       return type;
     }
 
   if (pauxent != NULL && (int32_t) pauxent->x_sym.x_tagndx.u32 > 0)
     {
       debug_type *slot;
 
       /* This is a reference to an existing type.  FIXME: gdb checks
 	 that the class is not C_STRTAG, nor C_UNTAG, nor C_ENTAG.  */
-      slot = coff_get_slot (types, pauxent->x_sym.x_tagndx.u32);
+      slot = coff_get_slot (dhandle, types, pauxent->x_sym.x_tagndx.u32);
       if (*slot != DEBUG_TYPE_NULL)
 	return *slot;
       else
 	return debug_make_indirect_type (dhandle, slot, (const char *) NULL);
     }
 
   /* If the aux entry has already been used for something, useaux will
      have been set to false, indicating that parse_coff_base_type
      should not use it.  We need to do it this way, rather than simply
      passing pauxent as NULL, because we need to be able handle
      multiple array dimensions while still discarding pauxent after
      having handled all of them.  */
   if (! useaux)
     pauxent = NULL;
 
   return parse_coff_base_type (abfd, symbols, types, coff_symno, ntype,
 			       pauxent, dhandle);
 }
 
 /* Parse a basic COFF type in NTYPE.  */
@@ -208,111 +208,111 @@ static debug_type
 parse_coff_base_type (bfd *abfd, struct coff_symbols *symbols,
 		      struct coff_types **types, long coff_symno, int ntype,
 		      union internal_auxent *pauxent, void *dhandle)
 {
   debug_type ret;
   const char *name = NULL;
 
   switch (ntype)
     {
     default:
       ret = debug_make_void_type (dhandle);
       break;
 
     case T_NULL:
     case T_VOID:
       ret = debug_make_void_type (dhandle);
       name = "void";
       break;
 
     case T_CHAR:
       ret = debug_make_int_type (dhandle, 1, false);
       name = "char";
       break;
 
     case T_SHORT:
       ret = debug_make_int_type (dhandle, 2, false);
       name = "short";
       break;
 
     case T_INT:
       /* FIXME: Perhaps the size should depend upon the architecture.  */
       ret = debug_make_int_type (dhandle, 4, false);
       name = "int";
       break;
 
     case T_LONG:
       ret = debug_make_int_type (dhandle, 4, false);
       name = "long";
       break;
 
     case T_FLOAT:
       ret = debug_make_float_type (dhandle, 4);
       name = "float";
       break;
 
     case T_DOUBLE:
       ret = debug_make_float_type (dhandle, 8);
       name = "double";
       break;
 
     case T_LNGDBL:
       ret = debug_make_float_type (dhandle, 12);
       name = "long double";
       break;
 
     case T_UCHAR:
       ret = debug_make_int_type (dhandle, 1, true);
       name = "unsigned char";
       break;
 
     case T_USHORT:
       ret = debug_make_int_type (dhandle, 2, true);
       name = "unsigned short";
       break;
 
     case T_UINT:
       ret = debug_make_int_type (dhandle, 4, true);
       name = "unsigned int";
       break;
 
     case T_ULONG:
       ret = debug_make_int_type (dhandle, 4, true);
       name = "unsigned long";
       break;
 
     case T_STRUCT:
       if (pauxent == NULL)
 	ret = debug_make_struct_type (dhandle, true, 0,
 				      (debug_field *) NULL);
       else
 	ret = parse_coff_struct_type (abfd, symbols, types, ntype, pauxent,
 				      dhandle);
       break;
 
     case T_UNION:
       if (pauxent == NULL)
 	ret = debug_make_struct_type (dhandle, false, 0, (debug_field *) NULL);
       else
 	ret = parse_coff_struct_type (abfd, symbols, types, ntype, pauxent,
 				      dhandle);
       break;
 
     case T_ENUM:
       if (pauxent == NULL)
 	ret = debug_make_enum_type (dhandle, (const char **) NULL,
 				    (bfd_signed_vma *) NULL);
       else
 	ret = parse_coff_enum_type (abfd, symbols, types, pauxent, dhandle);
       break;
     }
 
   if (name != NULL)
     ret = debug_name_type (dhandle, name, ret);
 
-  debug_type *slot = coff_get_slot (types, coff_symno);
+  debug_type *slot = coff_get_slot (dhandle, types, coff_symno);
   *slot = ret;
 
   return ret;
 }
 
 /* Parse a struct type.  */
@@ -321,107 +321,113 @@ static debug_type
 parse_coff_struct_type (bfd *abfd, struct coff_symbols *symbols,
 			struct coff_types **types, int ntype,
 			union internal_auxent *pauxent, void *dhandle)
 {
   long symend;
   int alloc;
-  debug_field *fields;
+  debug_field *fields, *xfields;
   int count;
   bool done;
 
   symend = pauxent->x_sym.x_fcnary.x_fcn.x_endndx.u32;
 
   alloc = 10;
   fields = (debug_field *) xmalloc (alloc * sizeof *fields);
   count = 0;
 
   done = false;
   while (! done
 	 && symbols->coff_symno < symend
 	 && symbols->symno < symbols->symcount)
     {
       asymbol *sym;
       long this_coff_symno;
       struct internal_syment syment;
       union internal_auxent auxent;
       union internal_auxent *psubaux;
       bfd_vma bitpos = 0, bitsize = 0;
 
       sym = symbols->syms[symbols->symno];
 
       if (! bfd_coff_get_syment (abfd, sym, &syment))
 	{
 	  non_fatal (_("bfd_coff_get_syment failed: %s"),
 		     bfd_errmsg (bfd_get_error ()));
 	  free (fields);
 	  return DEBUG_TYPE_NULL;
 	}
 
       this_coff_symno = symbols->coff_symno;
 
       ++symbols->symno;
       symbols->coff_symno += 1 + syment.n_numaux;
 
       if (syment.n_numaux == 0)
 	psubaux = NULL;
       else
 	{
 	  if (! bfd_coff_get_auxent (abfd, sym, 0, &auxent))
 	    {
 	      non_fatal (_("bfd_coff_get_auxent failed: %s"),
 			 bfd_errmsg (bfd_get_error ()));
 	      free (fields);
 	      return DEBUG_TYPE_NULL;
 	    }
 	  psubaux = &auxent;
 	}
 
       switch (syment.n_sclass)
 	{
 	case C_MOS:
 	case C_MOU:
 	  bitpos = 8 * bfd_asymbol_value (sym);
 	  bitsize = 0;
 	  break;
 
 	case C_FIELD:
 	  bitpos = bfd_asymbol_value (sym);
 	  bitsize = auxent.x_sym.x_misc.x_lnsz.x_size;
 	  break;
 
 	case C_EOS:
 	  done = true;
 	  break;
 	}
 
       if (! done)
 	{
 	  debug_type ftype;
 	  debug_field f;
 
 	  ftype = parse_coff_type (abfd, symbols, types, this_coff_symno,
 				   syment.n_type, psubaux, true, dhandle);
 	  f = debug_make_field (dhandle, bfd_asymbol_name (sym), ftype,
 				bitpos, bitsize, DEBUG_VISIBILITY_PUBLIC);
 	  if (f == DEBUG_FIELD_NULL)
-	    return DEBUG_TYPE_NULL;
+	    {
+	      free (fields);
+	      return DEBUG_TYPE_NULL;
+	    }
 
 	  if (count + 1 >= alloc)
 	    {
 	      alloc += 10;
 	      fields = ((debug_field *)
 			xrealloc (fields, alloc * sizeof *fields));
 	    }
 
 	  fields[count] = f;
 	  ++count;
 	}
     }
 
   fields[count] = DEBUG_FIELD_NULL;
+  xfields = debug_xalloc (dhandle, (count + 1) * sizeof (*fields));
+  memcpy (xfields, fields, (count + 1) * sizeof (*fields));
+  free (fields);
 
   return debug_make_struct_type (dhandle, ntype == T_STRUCT,
 				 pauxent->x_sym.x_misc.x_lnsz.x_size,
-				 fields);
+				 xfields);
 }
 
 /* Parse an enum type.  */
@@ -430,69 +436,76 @@ static debug_type
 parse_coff_enum_type (bfd *abfd, struct coff_symbols *symbols,
 		      struct coff_types **types ATTRIBUTE_UNUSED,
 		      union internal_auxent *pauxent, void *dhandle)
 {
   long symend;
   int alloc;
-  const char **names;
-  bfd_signed_vma *vals;
+  const char **names, **xnames;
+  bfd_signed_vma *vals, *xvals;
   int count;
   bool done;
 
   symend = pauxent->x_sym.x_fcnary.x_fcn.x_endndx.u32;
 
   alloc = 10;
   names = (const char **) xmalloc (alloc * sizeof *names);
   vals = (bfd_signed_vma *) xmalloc (alloc * sizeof *vals);
   count = 0;
 
   done = false;
   while (! done
 	 && symbols->coff_symno < symend
 	 && symbols->symno < symbols->symcount)
     {
       asymbol *sym;
       struct internal_syment syment;
 
       sym = symbols->syms[symbols->symno];
 
       if (! bfd_coff_get_syment (abfd, sym, &syment))
 	{
 	  non_fatal (_("bfd_coff_get_syment failed: %s"),
 		     bfd_errmsg (bfd_get_error ()));
 	  free (names);
 	  free (vals);
 	  return DEBUG_TYPE_NULL;
 	}
 
       ++symbols->symno;
       symbols->coff_symno += 1 + syment.n_numaux;
 
       switch (syment.n_sclass)
 	{
 	case C_MOE:
 	  if (count + 1 >= alloc)
 	    {
 	      alloc += 10;
 	      names = ((const char **)
 		       xrealloc (names, alloc * sizeof *names));
 	      vals = ((bfd_signed_vma *)
 		      xrealloc (vals, alloc * sizeof *vals));
 	    }
 
 	  names[count] = bfd_asymbol_name (sym);
 	  vals[count] = bfd_asymbol_value (sym);
 	  ++count;
 	  break;
 
 	case C_EOS:
 	  done = true;
 	  break;
 	}
     }
 
   names[count] = NULL;
-
-  return debug_make_enum_type (dhandle, names, vals);
+  vals[count] = 0;
+  xnames = debug_xalloc (dhandle, (count + 1) * sizeof (*names));
+  memcpy (xnames, names, (count + 1) * sizeof (*names));
+  free (names);
+  xvals = debug_xalloc (dhandle, (count + 1) * sizeof (*vals));
+  memcpy (xvals, vals, (count + 1) * sizeof (*vals));
+  free (vals);
+
+  return debug_make_enum_type (dhandle, xnames, xvals);
 }
 
 /* Handle a single COFF symbol.  */
@@ -501,86 +514,86 @@ static bool
 parse_coff_symbol (bfd *abfd ATTRIBUTE_UNUSED, struct coff_types **types,
 		   asymbol *sym, long coff_symno,
 		   struct internal_syment *psyment, void *dhandle,
 		   debug_type type, bool within_function)
 {
   switch (psyment->n_sclass)
     {
     case C_NULL:
       break;
 
     case C_AUTO:
       if (! debug_record_variable (dhandle, bfd_asymbol_name (sym), type,
 				   DEBUG_LOCAL, bfd_asymbol_value (sym)))
 	return false;
       break;
 
     case C_WEAKEXT:
     case C_EXT:
       if (! debug_record_variable (dhandle, bfd_asymbol_name (sym), type,
 				   DEBUG_GLOBAL, bfd_asymbol_value (sym)))
 	return false;
       break;
 
     case C_STAT:
       if (! debug_record_variable (dhandle, bfd_asymbol_name (sym), type,
 				   (within_function
 				    ? DEBUG_LOCAL_STATIC
 				    : DEBUG_STATIC),
 				   bfd_asymbol_value (sym)))
 	return false;
       break;
 
     case C_REG:
       /* FIXME: We may need to convert the register number.  */
       if (! debug_record_variable (dhandle, bfd_asymbol_name (sym), type,
 				   DEBUG_REGISTER, bfd_asymbol_value (sym)))
 	return false;
       break;
 
     case C_LABEL:
       break;
 
     case C_ARG:
       if (! debug_record_parameter (dhandle, bfd_asymbol_name (sym), type,
 				    DEBUG_PARM_STACK, bfd_asymbol_value (sym)))
 	return false;
       break;
 
     case C_REGPARM:
       /* FIXME: We may need to convert the register number.  */
       if (! debug_record_parameter (dhandle, bfd_asymbol_name (sym), type,
 				    DEBUG_PARM_REG, bfd_asymbol_value (sym)))
 	return false;
       break;
 
     case C_TPDEF:
       type = debug_name_type (dhandle, bfd_asymbol_name (sym), type);
       if (type == DEBUG_TYPE_NULL)
 	return false;
       break;
 
     case C_STRTAG:
     case C_UNTAG:
     case C_ENTAG:
       {
 	debug_type *slot;
 
 	type = debug_tag_type (dhandle, bfd_asymbol_name (sym), type);
 	if (type == DEBUG_TYPE_NULL)
 	  return false;
 
 	/* Store the named type into the slot, so that references get
            the name.  */
-	slot = coff_get_slot (types, coff_symno);
+	slot = coff_get_slot (dhandle, types, coff_symno);
 	*slot = type;
       }
       break;
 
     default:
       break;
     }
 
   return true;
 }
 
 /* Determine if a symbol has external visibility.  */
diff --git a/binutils/rddbg.c b/binutils/rddbg.c
index fb59f526979..944b4069f95 100644
--- a/binutils/rddbg.c
+++ b/binutils/rddbg.c
@@ -46,46 +46,45 @@ void *
 read_debugging_info (bfd *abfd, asymbol **syms, long symcount,
 		     bool no_messages)
 {
   void *dhandle;
   bool found;
 
-  dhandle = debug_init ();
+  dhandle = debug_init (abfd);
   if (dhandle == NULL)
     return NULL;
 
   if (! read_section_stabs_debugging_info (abfd, syms, symcount, dhandle,
 					   &found))
     goto err_exit;
 
   if (bfd_get_flavour (abfd) == bfd_target_aout_flavour)
     {
       if (! read_symbol_stabs_debugging_info (abfd, syms, symcount, dhandle,
 					      &found))
 	goto err_exit;
     }
 
   /* Try reading the COFF symbols if we didn't find any stabs in COFF
      sections.  */
   if (! found
       && bfd_get_flavour (abfd) == bfd_target_coff_flavour
       && symcount > 0)
     {
       if (! parse_coff (abfd, syms, symcount, dhandle))
 	goto err_exit;
       found = true;
     }
 
   if (! found)
     {
       if (! no_messages)
 	non_fatal (_("%s: no recognized debugging information"),
 		   bfd_get_filename (abfd));
     err_exit:
-      free (dhandle);
       return NULL;
     }
 
   return dhandle;
 }
 
 /* Read stabs in sections debugging information from a BFD.  */
@@ -94,186 +93,181 @@ static bool
 read_section_stabs_debugging_info (bfd *abfd, asymbol **syms, long symcount,
 				   void *dhandle, bool *pfound)
 {
   static struct
     {
       const char *secname;
       const char *strsecname;
     }
   names[] =
     {
       { ".stab", ".stabstr" },
       { "LC_SYMTAB.stabs", "LC_SYMTAB.stabstr" },
       { "$GDB_SYMBOLS$", "$GDB_STRINGS$" }
     };
   unsigned int i;
   void *shandle;
+  bool ret = false;
 
   *pfound = false;
   shandle = NULL;
 
   for (i = 0; i < sizeof names / sizeof names[0]; i++)
     {
       asection *sec, *strsec;
 
       sec = bfd_get_section_by_name (abfd, names[i].secname);
       strsec = bfd_get_section_by_name (abfd, names[i].strsecname);
       if (sec != NULL
 	  && (bfd_section_flags (sec) & SEC_HAS_CONTENTS) != 0
 	  && bfd_section_size (sec) >= 12
 	  && strsec != NULL
 	  && (bfd_section_flags (strsec) & SEC_HAS_CONTENTS) != 0)
 	{
 	  bfd_size_type stabsize, strsize;
 	  bfd_byte *stabs, *strings;
 	  bfd_byte *stab;
 	  bfd_size_type stroff, next_stroff;
 
 	  if (!bfd_malloc_and_get_section (abfd, sec, &stabs))
 	    {
 	      fprintf (stderr, "%s: %s: %s\n",
 		       bfd_get_filename (abfd), names[i].secname,
 		       bfd_errmsg (bfd_get_error ()));
-	      free (shandle);
-	      return false;
+	      goto out;
 	    }
 
 	  if (!bfd_malloc_and_get_section (abfd, strsec, &strings))
 	    {
 	      fprintf (stderr, "%s: %s: %s\n",
 		       bfd_get_filename (abfd), names[i].strsecname,
 		       bfd_errmsg (bfd_get_error ()));
-	      free (shandle);
 	      free (stabs);
-	      return false;
+	      goto out;
 	    }
 	  /* Zero terminate the strings table, just in case.  */
 	  strsize = bfd_section_size (strsec);
 	  if (strsize != 0)
 	    strings [strsize - 1] = 0;
 	  if (shandle == NULL)
 	    {
 	      shandle = start_stab (dhandle, abfd, true, syms, symcount);
 	      if (shandle == NULL)
 		{
 		  free (strings);
 		  free (stabs);
-		  return false;
+		  goto out;
 		}
 	    }
 
 	  *pfound = true;
 
 	  stroff = 0;
 	  next_stroff = 0;
 	  stabsize = bfd_section_size (sec);
 	  /* PR 17512: file: 078-60391-0.001:0.1.  */
 	  for (stab = stabs; stab <= (stabs + stabsize) - 12; stab += 12)
 	    {
 	      unsigned int strx;
 	      int type;
 	      int other ATTRIBUTE_UNUSED;
 	      int desc;
 	      bfd_vma value;
 
 	      /* This code presumes 32 bit values.  */
 
 	      strx = bfd_get_32 (abfd, stab);
 	      type = bfd_get_8 (abfd, stab + 4);
 	      other = bfd_get_8 (abfd, stab + 5);
 	      desc = bfd_get_16 (abfd, stab + 6);
 	      value = bfd_get_32 (abfd, stab + 8);
 
 	      if (type == 0)
 		{
 		  /* Special type 0 stabs indicate the offset to the
 		     next string table.  */
 		  stroff = next_stroff;
 		  next_stroff += value;
 		}
 	      else
 		{
 		  size_t len;
 		  char *f, *s;
-		  bool f_used;
 
 		  if (stroff + strx >= strsize)
 		    {
 		      fprintf (stderr, _("%s: %s: stab entry %ld is corrupt, strx = 0x%x, type = %d\n"),
 			       bfd_get_filename (abfd), names[i].secname,
 			       (long) (stab - stabs) / 12, strx, type);
 		      continue;
 		    }
 
 		  s = (char *) strings + stroff + strx;
 		  f = NULL;
 
 		  /* PR 17512: file: 002-87578-0.001:0.1.
 		     It is possible to craft a file where, without the 'strlen (s) > 0',
 		     an attempt to read the byte before 'strings' would occur.  */
 		  while ((len = strlen (s)) > 0
 			 && s[len  - 1] == '\\'
 			 && stab + 16 <= stabs + stabsize)
 		    {
 		      char *p;
 
 		      stab += 12;
 		      p = s + len - 1;
 		      *p = '\0';
 		      strx = stroff + bfd_get_32 (abfd, stab);
 		      if (strx >= strsize)
 			{
 			  fprintf (stderr, _("%s: %s: stab entry %ld is corrupt\n"),
 				   bfd_get_filename (abfd), names[i].secname,
 				   (long) (stab - stabs) / 12);
 			  break;
 			}
 
 		      s = concat (s, (char *) strings + strx,
 				  (const char *) NULL);
 
 		      /* We have to restore the backslash, because, if
 			 the linker is hashing stabs strings, we may
 			 see the same string more than once.  */
 		      *p = '\\';
 
 		      free (f);
 		      f = s;
 		    }
-		  if (!f)
-		    f = xstrdup (s);
 
 		  save_stab (type, desc, value, s);
 
-		  if (! parse_stab (dhandle, shandle, type, desc, value,
-				    f, &f_used))
+		  if (!parse_stab (dhandle, shandle, type, desc, value, s))
 		    {
 		      stab_context ();
 		      free_saved_stabs ();
 		      free (f);
-		      free (shandle);
 		      free (stabs);
 		      free (strings);
-		      return false;
+		      goto out;
 		    }
 
-		  if (!f_used)
-		    free (f);
+		  free (f);
 		}
 	    }
 
 	  free_saved_stabs ();
 	  free (stabs);
 	  free (strings);
 	}
     }
+  ret = true;
 
+ out:
   if (shandle != NULL)
     {
-      if (! finish_stab (dhandle, shandle))
+      if (! finish_stab (dhandle, shandle, ret))
 	return false;
     }
 
-  return true;
+  return ret;
 }
 
 /* Read stabs in the symbol table.  */
@@ -282,82 +276,78 @@ static bool
 read_symbol_stabs_debugging_info (bfd *abfd, asymbol **syms, long symcount,
 				  void *dhandle, bool *pfound)
 {
   void *shandle;
   asymbol **ps, **symend;
 
   shandle = NULL;
   symend = syms + symcount;
   for (ps = syms; ps < symend; ps++)
     {
       symbol_info i;
 
       bfd_get_symbol_info (abfd, *ps, &i);
 
       if (i.type == '-')
 	{
 	  const char *s;
 	  char *f;
-	  bool f_used;
 
 	  if (shandle == NULL)
 	    {
 	      shandle = start_stab (dhandle, abfd, false, syms, symcount);
 	      if (shandle == NULL)
 		return false;
 	    }
 
 	  *pfound = true;
 
 	  s = i.name;
 	  if (s == NULL || strlen (s) < 1)
-	    return false;
+	    break;
 	  f = NULL;
 
 	  while (strlen (s) > 0
 		 && s[strlen (s) - 1] == '\\'
 		 && ps + 1 < symend)
 	    {
 	      char *sc, *n;
 
 	      ++ps;
 	      sc = xstrdup (s);
 	      sc[strlen (sc) - 1] = '\0';
 	      n = concat (sc, bfd_asymbol_name (*ps), (const char *) NULL);
 	      free (sc);
 	      free (f);
 	      f = n;
 	      s = n;
 	    }
-	  if (!f)
-	    f = xstrdup (s);
 
 	  save_stab (i.stab_type, i.stab_desc, i.value, s);
 
-	  if (! parse_stab (dhandle, shandle, i.stab_type, i.stab_desc,
-			    i.value, f, &f_used))
+	  if (!parse_stab (dhandle, shandle, i.stab_type, i.stab_desc,
+			   i.value, s))
 	    {
 	      stab_context ();
 	      free (f);
-	      free_saved_stabs ();
-	      return false;
+	      break;
 	    }
 
-	  if (!f_used)
-	    free (f);
+	  free (f);
 	}
     }
+  bool ret = ps >= symend;
 
   free_saved_stabs ();
 
   if (shandle != NULL)
     {
-      if (! finish_stab (dhandle, shandle))
+      if (! finish_stab (dhandle, shandle, ret))
 	return false;
     }
 
-  return true;
+  return ret;
 }
 
 /* Record stabs strings, so that we can give some context for errors.  */
 
 #define SAVE_STABS_COUNT (16)
diff --git a/binutils/stabs.c b/binutils/stabs.c
index f5a76dda5cc..311b73b8418 100644
--- a/binutils/stabs.c
+++ b/binutils/stabs.c
@@ -146,8 +146,6 @@ struct stab_tag
   debug_type type;
 };
 
-static char *savestring (const char *, int);
-
 static void bad_stab (const char *);
 static void warn_stab (const char *, const char *);
 static bool parse_stab_string
@@ -192,14 +190,14 @@ static bool parse_stab_tilde_field
    bool *, const char *);
 static debug_type parse_stab_array_type
   (void *, struct stab_handle *, const char **, bool, const char *);
-static void push_bincl (struct stab_handle *, const char *, bfd_vma);
+static void push_bincl (void *, struct stab_handle *, const char *, bfd_vma);
 static const char *pop_bincl (struct stab_handle *);
 static bool find_excl (struct stab_handle *, const char *, bfd_vma);
 static bool stab_record_variable
   (void *, struct stab_handle *, const char *, debug_type,
    enum debug_var_kind, bfd_vma);
 static bool stab_emit_pending_vars (void *, struct stab_handle *);
-static debug_type *stab_find_slot (struct stab_handle *, const int *);
+static debug_type *stab_find_slot (void *, struct stab_handle *, const int *);
 static debug_type stab_find_type (void *, struct stab_handle *, const int *);
 static bool stab_record_type
   (void *, struct stab_handle *, const int *, debug_type);
@@ -222,14 +220,14 @@ static int demangle_flags = DMGL_ANSI;
 /* Save a string in memory.  */
 
 static char *
-savestring (const char *start, int len)
+savestring (void *dhandle, const char *start, size_t len)
 {
   char *ret;
 
-  ret = (char *) xmalloc (len + 1);
+  ret = debug_xalloc (dhandle, len + 1);
   memcpy (ret, start, len);
   ret[len] = '\0';
   return ret;
 }
 
 /* Read a number from a string.  */
@@ -370,336 +368,345 @@ void *
 start_stab (void *dhandle ATTRIBUTE_UNUSED, bfd *abfd, bool sections,
 	    asymbol **syms, long symcount)
 {
   struct stab_handle *ret;
 
-  ret = (struct stab_handle *) xmalloc (sizeof *ret);
-  memset (ret, 0, sizeof *ret);
+  ret = xmalloc (sizeof (*ret));
+  memset (ret, 0, sizeof (*ret));
   ret->abfd = abfd;
   ret->sections = sections;
   ret->syms = syms;
   ret->symcount = symcount;
   ret->files = 1;
-  ret->file_types = (struct stab_types **) xmalloc (sizeof *ret->file_types);
+  ret->file_types = xmalloc (sizeof (*ret->file_types));
   ret->file_types[0] = NULL;
-  ret->function_end = (bfd_vma) -1;
-  return (void *) ret;
+  ret->function_end = -1;
+  return ret;
 }
 
 /* When we have processed all the stabs information, we need to go
    through and fill in all the undefined tags.  */
 
 bool
-finish_stab (void *dhandle, void *handle)
+finish_stab (void *dhandle, void *handle, bool emit)
 {
   struct stab_handle *info = (struct stab_handle *) handle;
   struct stab_tag *st;
+  bool ret = true;
 
-  if (info->within_function)
+  if (emit && info->within_function)
     {
       if (! stab_emit_pending_vars (dhandle, info)
 	  || ! debug_end_function (dhandle, info->function_end))
-	return false;
-      info->within_function = false;
-      info->function_end = (bfd_vma) -1;
+	ret = false;
     }
 
-  for (st = info->tags; st != NULL; st = st->next)
-    {
-      enum debug_type_kind kind;
+  if (emit && ret)
+    for (st = info->tags; st != NULL; st = st->next)
+      {
+	enum debug_type_kind kind;
 
-      kind = st->kind;
-      if (kind == DEBUG_KIND_ILLEGAL)
-	kind = DEBUG_KIND_STRUCT;
-      st->slot = debug_make_undefined_tagged_type (dhandle, st->name, kind);
-      if (st->slot == DEBUG_TYPE_NULL)
-	return false;
-    }
+	kind = st->kind;
+	if (kind == DEBUG_KIND_ILLEGAL)
+	  kind = DEBUG_KIND_STRUCT;
+	st->slot = debug_make_undefined_tagged_type (dhandle, st->name, kind);
+	if (st->slot == DEBUG_TYPE_NULL)
+	  {
+	    ret = false;
+	    break;
+	  }
+      }
 
-  return true;
+  free (info->file_types);
+  free (info->so_string);
+  free (info);
+  return ret;
 }
 
 /* Handle a single stabs symbol.  */
 
 bool
 parse_stab (void *dhandle, void *handle, int type, int desc, bfd_vma value,
-	    const char *string, bool *string_used)
+	    const char *string)
 {
   const char * string_end;
   struct stab_handle *info = (struct stab_handle *) handle;
+  char *copy;
+  size_t len;
 
-  *string_used = false;
   /* gcc will emit two N_SO strings per compilation unit, one for the
      directory name and one for the file name.  We just collect N_SO
      strings as we see them, and start the new compilation unit when
      we see a non N_SO symbol.  */
   if (info->so_string != NULL
       && (type != N_SO || *string == '\0' || value != info->so_value))
     {
-      if (! debug_set_filename (dhandle, info->so_string))
+      len = strlen (info->so_string) + 1;
+      copy = debug_xalloc (dhandle, len);
+      memcpy (copy, info->so_string, len);
+      if (! debug_set_filename (dhandle, copy))
 	return false;
-      info->main_filename = info->so_string;
+      info->main_filename = copy;
+
+      free (info->so_string);
+      info->so_string = NULL;
 
       info->gcc_compiled = 0;
       info->n_opt_found = false;
 
       /* Generally, for stabs in the symbol table, the N_LBRAC and
 	 N_RBRAC symbols are relative to the N_SO symbol value.  */
       if (! info->sections)
 	info->file_start_offset = info->so_value;
 
       /* We need to reset the mapping from type numbers to types.  We
 	 can only free the file_types array, not the stab_types
 	 list entries due to the use of debug_make_indirect_type.  */
       info->files = 1;
-      info->file_types = ((struct stab_types **)
-			  xrealloc (info->file_types, sizeof *info->file_types));
+      info->file_types = xrealloc (info->file_types, sizeof (*info->file_types));
       info->file_types[0] = NULL;
-      info->so_string = NULL;
 
       /* Now process whatever type we just got.  */
     }
 
   string_end = string + strlen (string);
 
   switch (type)
     {
     case N_FN:
     case N_FN_SEQ:
       break;
 
     case N_LBRAC:
       /* Ignore extra outermost context from SunPRO cc and acc.  */
       if (info->n_opt_found && desc == 1)
 	break;
 
       if (! info->within_function)
 	{
 	  fprintf (stderr, _("N_LBRAC not within function\n"));
 	  return false;
 	}
 
       /* Start an inner lexical block.  */
       if (! debug_start_block (dhandle,
 			       (value
 				+ info->file_start_offset
 				+ info->function_start_offset)))
 	return false;
 
       /* Emit any pending variable definitions.  */
       if (! stab_emit_pending_vars (dhandle, info))
 	return false;
 
       ++info->block_depth;
       break;
 
     case N_RBRAC:
       /* Ignore extra outermost context from SunPRO cc and acc.  */
       if (info->n_opt_found && desc == 1)
 	break;
 
       /* We shouldn't have any pending variable definitions here, but,
          if we do, we probably need to emit them before closing the
          block.  */
       if (! stab_emit_pending_vars (dhandle, info))
 	return false;
 
       /* End an inner lexical block.  */
       if (! debug_end_block (dhandle,
 			     (value
 			      + info->file_start_offset
 			      + info->function_start_offset)))
 	return false;
 
       --info->block_depth;
       if (info->block_depth < 0)
 	{
 	  fprintf (stderr, _("Too many N_RBRACs\n"));
 	  return false;
 	}
       break;
 
     case N_SO:
       /* This always ends a function.  */
       if (info->within_function)
 	{
 	  bfd_vma endval;
 
 	  endval = value;
 	  if (*string != '\0'
 	      && info->function_end != (bfd_vma) -1
 	      && info->function_end < endval)
 	    endval = info->function_end;
 	  if (! stab_emit_pending_vars (dhandle, info)
 	      || ! debug_end_function (dhandle, endval))
 	    return false;
 	  info->within_function = false;
 	  info->function_end = (bfd_vma) -1;
 	}
 
       /* An empty string is emitted by gcc at the end of a compilation
          unit.  */
       if (*string == '\0')
 	return true;
 
       /* Just accumulate strings until we see a non N_SO symbol.  If
          the string starts with a directory separator or some other
 	 form of absolute path specification, we discard the previously
          accumulated strings.  */
       if (info->so_string == NULL)
 	info->so_string = xstrdup (string);
       else
 	{
 	  char *f;
 
 	  f = info->so_string;
 
 	  if (IS_ABSOLUTE_PATH (string))
 	    info->so_string = xstrdup (string);
 	  else
 	    info->so_string = concat (info->so_string, string,
 				      (const char *) NULL);
 	  free (f);
 	}
 
       info->so_value = value;
 
       break;
 
     case N_SOL:
       /* Start an include file.  */
-      if (! debug_start_source (dhandle, string, string_used))
+      len = strlen (string) + 1;
+      copy = debug_xalloc (dhandle, len);
+      memcpy (copy, string, len);
+      if (! debug_start_source (dhandle, copy))
 	return false;
       break;
 
     case N_BINCL:
       /* Start an include file which may be replaced.  */
-      *string_used = true;
-      push_bincl (info, string, value);
-      if (! debug_start_source (dhandle, string, string_used))
+      len = strlen (string) + 1;
+      copy = debug_xalloc (dhandle, len);
+      memcpy (copy, string, len);
+      push_bincl (dhandle, info, copy, value);
+      if (! debug_start_source (dhandle, copy))
 	return false;
       break;
 
     case N_EINCL:
       /* End an N_BINCL include.  */
-      string = pop_bincl (info);
-      if (! debug_start_source (dhandle, string, string_used))
-	{
-	  free ((char *) string);
-	  return false;
-	}
-      if (!*string_used)
-	free ((char *) string);
-      *string_used = false;
+      if (! debug_start_source (dhandle, pop_bincl (info)))
+	return false;
       break;
 
     case N_EXCL:
       /* This is a duplicate of a header file named by N_BINCL which
          was eliminated by the linker.  */
       if (! find_excl (info, string, value))
 	return false;
       break;
 
     case N_SLINE:
       if (! debug_record_line (dhandle, desc,
 			       value + (info->within_function
 					? info->function_start_offset : 0)))
 	return false;
       break;
 
     case N_BCOMM:
       if (! debug_start_common_block (dhandle, string))
 	return false;
       break;
 
     case N_ECOMM:
       if (! debug_end_common_block (dhandle, string))
 	return false;
       break;
 
     case N_FUN:
       if (*string == '\0')
 	{
 	  if (info->within_function)
 	    {
 	      /* This always marks the end of a function; we don't
                  need to worry about info->function_end.  */
 	      if (info->sections)
 		value += info->function_start_offset;
 	      if (! stab_emit_pending_vars (dhandle, info)
 		  || ! debug_end_function (dhandle, value))
 		return false;
 	      info->within_function = false;
 	      info->function_end = (bfd_vma) -1;
 	    }
 	  break;
 	}
 
       /* A const static symbol in the .text section will have an N_FUN
          entry.  We need to use these to mark the end of the function,
          in case we are looking at gcc output before it was changed to
          always emit an empty N_FUN.  We can't call debug_end_function
          here, because it might be a local static symbol.  */
       if (info->within_function
 	  && (info->function_end == (bfd_vma) -1
 	      || value < info->function_end))
 	info->function_end = value;
 
       /* Fall through.  */
       /* FIXME: gdb checks the string for N_STSYM, N_LCSYM or N_ROSYM
          symbols, and if it does not start with :S, gdb relocates the
          value to the start of the section.  gcc always seems to use
          :S, so we don't worry about this.  */
       /* Fall through.  */
     default:
       {
 	const char *colon;
 
 	colon = strchr (string, ':');
 	if (colon != NULL
 	    && (colon[1] == 'f' || colon[1] == 'F'))
 	  {
 	    if (info->within_function)
 	      {
 		bfd_vma endval;
 
 		endval = value;
 		if (info->function_end != (bfd_vma) -1
 		    && info->function_end < endval)
 		  endval = info->function_end;
 		if (! stab_emit_pending_vars (dhandle, info)
 		    || ! debug_end_function (dhandle, endval))
 		  return false;
 		info->function_end = (bfd_vma) -1;
 	      }
 	    /* For stabs in sections, line numbers and block addresses
                are offsets from the start of the function.  */
 	    if (info->sections)
 	      info->function_start_offset = value;
 	    info->within_function = true;
 	  }
 
 	if (! parse_stab_string (dhandle, info, type, desc, value, string, string_end))
 	  return false;
       }
       break;
 
     case N_OPT:
       if (string != NULL && strcmp (string, "gcc2_compiled.") == 0)
 	info->gcc_compiled = 2;
       else if (string != NULL && strcmp (string, "gcc_compiled.") == 0)
 	info->gcc_compiled = 1;
       else
 	info->n_opt_found = true;
       break;
 
     case N_OBJ:
     case N_ENDM:
     case N_MAIN:
     case N_WARNING:
       break;
     }
 
   return true;
 }
 
 /* Parse the stabs string.  */
@@ -708,467 +715,467 @@ static bool
 parse_stab_string (void *dhandle, struct stab_handle *info, int stabtype,
 		   int desc ATTRIBUTE_UNUSED, bfd_vma value,
 		   const char *string, const char * string_end)
 {
   const char *p;
   char *name;
   int type;
   debug_type dtype;
   bool synonym;
   bool self_crossref;
   debug_type *slot;
 
   p = strchr (string, ':');
   if (p == NULL)
     return true;
 
   while (p[1] == ':')
     {
       p += 2;
       p = strchr (p, ':');
       if (p == NULL)
 	{
 	  bad_stab (string);
 	  return false;
 	}
     }
 
   /* FIXME: Sometimes the special C++ names start with '.'.  */
   name = NULL;
   if (string[0] == '$')
     {
       switch (string[1])
 	{
 	case 't':
 	  name = "this";
 	  break;
 	case 'v':
 	  /* Was: name = "vptr"; */
 	  break;
 	case 'e':
 	  name = "eh_throw";
 	  break;
 	case '_':
 	  /* This was an anonymous type that was never fixed up.  */
 	  break;
 	case 'X':
 	  /* SunPRO (3.0 at least) static variable encoding.  */
 	  break;
 	default:
 	  warn_stab (string, _("unknown C++ encoded name"));
 	  break;
 	}
     }
 
   if (name == NULL)
     {
       if (p == string || (string[0] == ' ' && p == string + 1))
 	name = NULL;
       else
-	name = savestring (string, p - string);
+	name = savestring (dhandle, string, p - string);
     }
 
   ++p;
   if (ISDIGIT (*p) || *p == '(' || *p == '-')
     type = 'l';
   else if (*p == 0)
     {
       bad_stab (string);
       return false;
     }
   else
     type = *p++;
 
   switch (type)
     {
     case 'c':
       /* c is a special case, not followed by a type-number.
 	 SYMBOL:c=iVALUE for an integer constant symbol.
 	 SYMBOL:c=rVALUE for a floating constant symbol.
 	 SYMBOL:c=eTYPE,INTVALUE for an enum constant symbol.
 	 e.g. "b:c=e6,0" for "const b = blob1"
 	 (where type 6 is defined by "blobs:t6=eblob1:0,blob2:1,;").  */
       if (*p != '=')
 	{
 	  bad_stab (string);
 	  return false;
 	}
       ++p;
       switch (*p++)
 	{
 	case 'r':
 	  /* Floating point constant.  */
 	  if (! debug_record_float_const (dhandle, name, atof (p)))
 	    return false;
 	  break;
 	case 'i':
 	  /* Integer constant.  */
 	  /* Defining integer constants this way is kind of silly,
 	     since 'e' constants allows the compiler to give not only
 	     the value, but the type as well.  C has at least int,
 	     long, unsigned int, and long long as constant types;
 	     other languages probably should have at least unsigned as
 	     well as signed constants.  */
 	  if (! debug_record_int_const (dhandle, name, atoi (p)))
 	    return false;
 	  break;
 	case 'e':
 	  /* SYMBOL:c=eTYPE,INTVALUE for a constant symbol whose value
 	     can be represented as integral.
 	     e.g. "b:c=e6,0" for "const b = blob1"
 	     (where type 6 is defined by "blobs:t6=eblob1:0,blob2:1,;").  */
 	  dtype = parse_stab_type (dhandle, info, (const char *) NULL,
 				   &p, (debug_type **) NULL, string_end);
 	  if (dtype == DEBUG_TYPE_NULL)
 	    return false;
 	  if (*p != ',')
 	    {
 	      bad_stab (string);
 	      return false;
 	    }
 	  if (! debug_record_typed_const (dhandle, name, dtype, atoi (p)))
 	    return false;
 	  break;
 	default:
 	  bad_stab (string);
 	  return false;
 	}
 
       break;
 
     case 'C':
       /* The name of a caught exception.  */
       dtype = parse_stab_type (dhandle, info, (const char *) NULL,
 			       &p, (debug_type **) NULL, string_end);
       if (dtype == DEBUG_TYPE_NULL)
 	return false;
       if (! debug_record_label (dhandle, name, dtype, value))
 	return false;
       break;
 
     case 'f':
     case 'F':
       /* A function definition.  */
       dtype = parse_stab_type (dhandle, info, (const char *) NULL, &p,
 			       (debug_type **) NULL, string_end);
       if (dtype == DEBUG_TYPE_NULL)
 	return false;
       if (! debug_record_function (dhandle, name, dtype, type == 'F', value))
 	return false;
 
       /* Sun acc puts declared types of arguments here.  We don't care
 	 about their actual types (FIXME -- we should remember the whole
 	 function prototype), but the list may define some new types
 	 that we have to remember, so we must scan it now.  */
       while (*p == ';')
 	{
 	  ++p;
 	  if (parse_stab_type (dhandle, info, (const char *) NULL, &p,
 			       (debug_type **) NULL, string_end)
 	      == DEBUG_TYPE_NULL)
 	    return false;
 	}
 
       break;
 
     case 'G':
       {
 	asymbol **ps;
 
 	/* A global symbol.  The value must be extracted from the
 	   symbol table.  */
 	dtype = parse_stab_type (dhandle, info, (const char *) NULL, &p,
 				 (debug_type **) NULL, string_end);
 	if (dtype == DEBUG_TYPE_NULL)
 	  return false;
 	if (name != NULL)
 	  {
 	    char leading;
 	    long c;
 
 	    leading = bfd_get_symbol_leading_char (info->abfd);
 	    for (c = info->symcount, ps = info->syms; c > 0; --c, ++ps)
 	      {
 		const char *n;
 
 		n = bfd_asymbol_name (*ps);
 		if (leading != '\0' && *n == leading)
 		  ++n;
 		if (*n == *name && strcmp (n, name) == 0)
 		  break;
 	      }
 
 	    if (c > 0)
 	      value = bfd_asymbol_value (*ps);
 	  }
 
 	if (! stab_record_variable (dhandle, info, name, dtype, DEBUG_GLOBAL,
 				    value))
 	  return false;
       }
       break;
 
       /* This case is faked by a conditional above, when there is no
 	 code letter in the dbx data.  Dbx data never actually
 	 contains 'l'.  */
     case 'l':
     case 's':
       dtype = parse_stab_type (dhandle, info, (const char *) NULL, &p,
 			       (debug_type **) NULL, string_end);
       if (dtype == DEBUG_TYPE_NULL)
 	return false;
       if (! stab_record_variable (dhandle, info, name, dtype, DEBUG_LOCAL,
 				  value))
 	return false;
       break;
 
     case 'p':
       /* A function parameter.  */
       if (*p != 'F')
 	dtype = parse_stab_type (dhandle, info, (const char *) NULL, &p,
 				 (debug_type **) NULL, string_end);
       else
 	{
 	/* pF is a two-letter code that means a function parameter in
 	   Fortran.  The type-number specifies the type of the return
 	   value.  Translate it into a pointer-to-function type.  */
 	  ++p;
 	  dtype = parse_stab_type (dhandle, info, (const char *) NULL, &p,
 				   (debug_type **) NULL, string_end);
 	  if (dtype != DEBUG_TYPE_NULL)
 	    {
 	      debug_type ftype;
 
 	      ftype = debug_make_function_type (dhandle, dtype,
 						(debug_type *) NULL, false);
 	      dtype = debug_make_pointer_type (dhandle, ftype);
 	    }
 	}
       if (dtype == DEBUG_TYPE_NULL)
 	return false;
       if (! debug_record_parameter (dhandle, name, dtype, DEBUG_PARM_STACK,
 				    value))
 	return false;
 
       /* FIXME: At this point gdb considers rearranging the parameter
 	 address on a big endian machine if it is smaller than an int.
 	 We have no way to do that, since we don't really know much
 	 about the target.  */
       break;
 
     case 'P':
       if (stabtype == N_FUN)
 	{
 	  /* Prototype of a function referenced by this file.  */
 	  while (*p == ';')
 	    {
 	      ++p;
 	      if (parse_stab_type (dhandle, info, (const char *) NULL, &p,
 				   (debug_type **) NULL, string_end)
 		  == DEBUG_TYPE_NULL)
 		return false;
 	    }
 	  break;
 	}
       /* Fall through.  */
     case 'R':
       /* Parameter which is in a register.  */
       dtype = parse_stab_type (dhandle, info, (const char *) NULL, &p,
 			       (debug_type **) NULL, string_end);
       if (dtype == DEBUG_TYPE_NULL)
 	return false;
       if (! debug_record_parameter (dhandle, name, dtype, DEBUG_PARM_REG,
 				    value))
 	return false;
       break;
 
     case 'r':
       /* Register variable (either global or local).  */
       dtype = parse_stab_type (dhandle, info, (const char *) NULL, &p,
 			       (debug_type **) NULL, string_end);
       if (dtype == DEBUG_TYPE_NULL)
 	return false;
       if (! stab_record_variable (dhandle, info, name, dtype, DEBUG_REGISTER,
 				  value))
 	return false;
 
       /* FIXME: At this point gdb checks to combine pairs of 'p' and
 	 'r' stabs into a single 'P' stab.  */
       break;
 
     case 'S':
       /* Static symbol at top level of file.  */
       dtype = parse_stab_type (dhandle, info, (const char *) NULL, &p,
 			       (debug_type **) NULL, string_end);
       if (dtype == DEBUG_TYPE_NULL)
 	return false;
       if (! stab_record_variable (dhandle, info, name, dtype, DEBUG_STATIC,
 				  value))
 	return false;
       break;
 
     case 't':
       /* A typedef.  */
       dtype = parse_stab_type (dhandle, info, name, &p, &slot, string_end);
       if (dtype == DEBUG_TYPE_NULL)
 	return false;
       if (name == NULL)
 	{
 	  /* A nameless type.  Nothing to do.  */
 	  return true;
 	}
 
       dtype = debug_name_type (dhandle, name, dtype);
       if (dtype == DEBUG_TYPE_NULL)
 	return false;
 
       if (slot != NULL)
 	*slot = dtype;
 
       break;
 
     case 'T':
       /* Struct, union, or enum tag.  For GNU C++, this can be followed
 	 by 't' which means we are typedef'ing it as well.  */
       if (*p != 't')
 	{
 	  synonym = false;
 	  /* FIXME: gdb sets synonym to TRUE if the current language
              is C++.  */
 	}
       else
 	{
 	  synonym = true;
 	  ++p;
 	}
 
       dtype = parse_stab_type (dhandle, info, name, &p, &slot, string_end);
       if (dtype == DEBUG_TYPE_NULL)
 	return false;
       if (name == NULL)
 	return true;
 
       /* INFO->SELF_CROSSREF is set by parse_stab_type if this type is
          a cross reference to itself.  These are generated by some
          versions of g++.  */
       self_crossref = info->self_crossref;
 
       dtype = debug_tag_type (dhandle, name, dtype);
       if (dtype == DEBUG_TYPE_NULL)
 	return false;
       if (slot != NULL)
 	*slot = dtype;
 
       /* See if we have a cross reference to this tag which we can now
          fill in.  Avoid filling in a cross reference to ourselves,
          because that would lead to circular debugging information.  */
       if (! self_crossref)
 	{
 	  register struct stab_tag **pst;
 
 	  for (pst = &info->tags; *pst != NULL; pst = &(*pst)->next)
 	    {
 	      if ((*pst)->name[0] == name[0]
 		  && strcmp ((*pst)->name, name) == 0)
 		{
 		  (*pst)->slot = dtype;
 		  *pst = (*pst)->next;
 		  break;
 		}
 	    }
 	}
 
       if (synonym)
 	{
 	  dtype = debug_name_type (dhandle, name, dtype);
 	  if (dtype == DEBUG_TYPE_NULL)
 	    return false;
 
 	  if (slot != NULL)
 	    *slot = dtype;
 	}
 
       break;
 
     case 'V':
       /* Static symbol of local scope */
       dtype = parse_stab_type (dhandle, info, (const char *) NULL, &p,
 			       (debug_type **) NULL, string_end);
       if (dtype == DEBUG_TYPE_NULL)
 	return false;
       /* FIXME: gdb checks os9k_stabs here.  */
       if (! stab_record_variable (dhandle, info, name, dtype,
 				  DEBUG_LOCAL_STATIC, value))
 	return false;
       break;
 
     case 'v':
       /* Reference parameter.  */
       dtype = parse_stab_type (dhandle, info, (const char *) NULL, &p,
 			       (debug_type **) NULL, string_end);
       if (dtype == DEBUG_TYPE_NULL)
 	return false;
       if (! debug_record_parameter (dhandle, name, dtype, DEBUG_PARM_REFERENCE,
 				    value))
 	return false;
       break;
 
     case 'a':
       /* Reference parameter which is in a register.  */
       dtype = parse_stab_type (dhandle, info, (const char *) NULL, &p,
 			       (debug_type **) NULL, string_end);
       if (dtype == DEBUG_TYPE_NULL)
 	return false;
       if (! debug_record_parameter (dhandle, name, dtype, DEBUG_PARM_REF_REG,
 				    value))
 	return false;
       break;
 
     case 'X':
       /* This is used by Sun FORTRAN for "function result value".
 	 Sun claims ("dbx and dbxtool interfaces", 2nd ed)
 	 that Pascal uses it too, but when I tried it Pascal used
 	 "x:3" (local symbol) instead.  */
       dtype = parse_stab_type (dhandle, info, (const char *) NULL, &p,
 			       (debug_type **) NULL, string_end);
       if (dtype == DEBUG_TYPE_NULL)
 	return false;
       if (! stab_record_variable (dhandle, info, name, dtype, DEBUG_LOCAL,
 				  value))
 	return false;
       break;
 
     case 'Y':
       /* SUNPro C++ Namespace =Yn0.  */
       /* Skip the namespace mapping, as it is not used now.  */
       if (*p++ != 0 && *p++ == 'n' && *p++ == '0')
 	{
 	  /* =Yn0name; */
 	  while (*p && *p != ';')
 	    ++p;
 	  if (*p)
 	    return true;
 	}
       /* TODO SUNPro C++ support:
          Support default arguments after F,P parameters
          Ya = Anonymous unions
          YM,YD = Pointers to class members
          YT,YI = Templates
          YR = Run-time type information (RTTI)  */
 
       /* Fall through.  */
 
     default:
       bad_stab (string);
       return false;
     }
 
   /* FIXME: gdb converts structure values to structure pointers in a
      couple of cases, depending upon the target.  */
 
   return true;
 }
 
 /* Parse a stabs type.  The typename argument is non-NULL if this is a
    typedef or a tag definition.  The pp argument points to the stab
    string, and is updated.  The slotp argument points to a place to
    store the slot used if the type is being defined.  */
@@ -1177,489 +1184,495 @@ static debug_type
 parse_stab_type (void *                dhandle,
 		 struct stab_handle *  info,
 		 const char *          type_name,
 		 const char **         pp,
 		 debug_type **         slotp,
 		 const char *          p_end)
 {
   const char *orig;
   int typenums[2];
   int size;
   bool stringp;
   int descriptor;
   debug_type dtype;
 
   if (slotp != NULL)
     *slotp = NULL;
 
   orig = *pp;
   if (orig >= p_end)
     return DEBUG_TYPE_NULL;
 
   size = -1;
   stringp = false;
 
   info->self_crossref = false;
 
   /* Read type number if present.  The type number may be omitted.
      for instance in a two-dimensional array declared with type
      "ar1;1;10;ar1;1;10;4".  */
   if (! ISDIGIT (**pp) && **pp != '(' && **pp != '-')
     {
       /* 'typenums=' not present, type is anonymous.  Read and return
 	 the definition, but don't put it in the type vector.  */
       typenums[0] = typenums[1] = -1;
     }
   else
     {
       if (! parse_stab_type_number (pp, typenums, p_end))
 	return DEBUG_TYPE_NULL;
 
       if (**pp != '=')
 	/* Type is not being defined here.  Either it already
 	   exists, or this is a forward reference to it.  */
 	return stab_find_type (dhandle, info, typenums);
 
       /* Only set the slot if the type is being defined.  This means
          that the mapping from type numbers to types will only record
          the name of the typedef which defines a type.  If we don't do
          this, then something like
 	     typedef int foo;
 	     int i;
 	 will record that i is of type foo.  Unfortunately, stabs
 	 information is ambiguous about variable types.  For this code,
 	     typedef int foo;
 	     int i;
 	     foo j;
 	 the stabs information records both i and j as having the same
 	 type.  This could be fixed by patching the compiler.  */
       if (slotp != NULL && typenums[0] >= 0 && typenums[1] >= 0)
-	*slotp = stab_find_slot (info, typenums);
+	*slotp = stab_find_slot (dhandle, info, typenums);
 
       /* Type is being defined here.  */
       /* Skip the '='.  */
       ++*pp;
 
       while (**pp == '@')
 	{
 	  const char *p = *pp + 1;
 	  const char *attr;
 
 	  if (ISDIGIT (*p) || *p == '(' || *p == '-')
 	    /* Member type.  */
 	    break;
 
 	  /* Type attributes.  */
 	  attr = p;
 
 	  for (; *p != ';'; ++p)
 	    {
 	      if (*p == '\0')
 		{
 		  bad_stab (orig);
 		  return DEBUG_TYPE_NULL;
 		}
 	    }
 	  *pp = p + 1;
 
 	  switch (*attr)
 	    {
 	    case 's':
 	      size = atoi (attr + 1);
 	      size /= 8;  /* Size is in bits.  We store it in bytes.  */
 	      if (size <= 0)
 		size = -1;
 	      break;
 
 	    case 'S':
 	      stringp = true;
 	      break;
 
 	    case 0:
 	      bad_stab (orig);
 	      return DEBUG_TYPE_NULL;
 
 	    default:
 	      /* Ignore unrecognized type attributes, so future
 		 compilers can invent new ones.  */
 	      break;
 	    }
 	}
     }
 
   descriptor = **pp;
   ++*pp;
 
   switch (descriptor)
     {
     case 'x':
       {
 	enum debug_type_kind code;
 	const char *q1, *q2, *p;
 
 	/* A cross reference to another type.  */
 	switch (**pp)
 	  {
 	  case 's':
 	    code = DEBUG_KIND_STRUCT;
 	    break;
 	  case 'u':
 	    code = DEBUG_KIND_UNION;
 	    break;
 	  case 'e':
 	    code = DEBUG_KIND_ENUM;
 	    break;
 	  case 0:
 	      bad_stab (orig);
 	      return DEBUG_TYPE_NULL;
 	    
 	  default:
 	    /* Complain and keep going, so compilers can invent new
 	       cross-reference types.  */
 	    warn_stab (orig, _("unrecognized cross reference type"));
 	    code = DEBUG_KIND_STRUCT;
 	    break;
 	  }
 	++*pp;
 
 	q1 = strchr (*pp, '<');
 	p = strchr (*pp, ':');
 	if (p == NULL)
 	  {
 	    bad_stab (orig);
 	    return DEBUG_TYPE_NULL;
 	  }
 	if (q1 != NULL && p > q1 && p[1] == ':')
 	  {
 	    int nest = 0;
 
 	    for (q2 = q1; *q2 != '\0'; ++q2)
 	      {
 		if (*q2 == '<')
 		  ++nest;
 		else if (*q2 == '>')
 		  --nest;
 		else if (*q2 == ':' && nest == 0)
 		  break;
 	      }
 	    p = q2;
 	    if (*p != ':')
 	      {
 		bad_stab (orig);
 		return DEBUG_TYPE_NULL;
 	      }
 	  }
 
 	/* Some versions of g++ can emit stabs like
 	       fleep:T20=xsfleep:
 	   which define structures in terms of themselves.  We need to
 	   tell the caller to avoid building a circular structure.  */
 	if (type_name != NULL
 	    && strncmp (type_name, *pp, p - *pp) == 0
 	    && type_name[p - *pp] == '\0')
 	  info->self_crossref = true;
 
 	dtype = stab_find_tagged_type (dhandle, info, *pp, p - *pp, code);
 
 	*pp = p + 1;
       }
       break;
 
     case '-':
     case '0':
     case '1':
     case '2':
     case '3':
     case '4':
     case '5':
     case '6':
     case '7':
     case '8':
     case '9':
     case '(':
       {
 	const char *hold;
 	int xtypenums[2];
 
 	/* This type is defined as another type.  */
 	(*pp)--;
 	hold = *pp;
 
 	/* Peek ahead at the number to detect void.  */
 	if (! parse_stab_type_number (pp, xtypenums, p_end))
 	  return DEBUG_TYPE_NULL;
 
 	if (typenums[0] == xtypenums[0] && typenums[1] == xtypenums[1])
 	  {
 	    /* This type is being defined as itself, which means that
                it is void.  */
 	    dtype = debug_make_void_type (dhandle);
 	  }
 	else
 	  {
 	    *pp = hold;
 
 	    /* Go back to the number and have parse_stab_type get it.
 	       This means that we can deal with something like
 	       t(1,2)=(3,4)=... which the Lucid compiler uses.  */
 	    dtype = parse_stab_type (dhandle, info, (const char *) NULL,
 				     pp, (debug_type **) NULL, p_end);
 	    if (dtype == DEBUG_TYPE_NULL)
 	      return DEBUG_TYPE_NULL;
 	  }
 
 	if (typenums[0] != -1)
 	  {
 	    if (! stab_record_type (dhandle, info, typenums, dtype))
 	      return DEBUG_TYPE_NULL;
 	  }
 
 	break;
       }
 
     case '*':
       dtype = debug_make_pointer_type (dhandle,
 				       parse_stab_type (dhandle, info,
 							(const char *) NULL,
 							pp,
 							(debug_type **) NULL,
 							p_end));
       break;
 
     case '&':
       /* Reference to another type.  */
       dtype = (debug_make_reference_type
 	       (dhandle,
 		parse_stab_type (dhandle, info, (const char *) NULL, pp,
 				 (debug_type **) NULL, p_end)));
       break;
 
     case 'f':
       /* Function returning another type.  */
       /* FIXME: gdb checks os9k_stabs here.  */
       dtype = (debug_make_function_type
 	       (dhandle,
 		parse_stab_type (dhandle, info, (const char *) NULL, pp,
 				 (debug_type **) NULL, p_end),
 		(debug_type *) NULL, false));
       break;
 
     case 'k':
       /* Const qualifier on some type (Sun).  */
       /* FIXME: gdb accepts 'c' here if os9k_stabs.  */
       dtype = debug_make_const_type (dhandle,
 				     parse_stab_type (dhandle, info,
 						      (const char *) NULL,
 						      pp,
 						      (debug_type **) NULL,
 						      p_end));
       break;
 
     case 'B':
       /* Volatile qual on some type (Sun).  */
       /* FIXME: gdb accepts 'i' here if os9k_stabs.  */
       dtype = (debug_make_volatile_type
 	       (dhandle,
 		parse_stab_type (dhandle, info, (const char *) NULL, pp,
 				 (debug_type **) NULL, p_end)));
       break;
 
     case '@':
       /* Offset (class & variable) type.  This is used for a pointer
          relative to an object.  */
       {
 	debug_type domain;
 	debug_type memtype;
 
 	/* Member type.  */
 
 	domain = parse_stab_type (dhandle, info, (const char *) NULL, pp,
 				  (debug_type **) NULL, p_end);
 	if (domain == DEBUG_TYPE_NULL)
 	  return DEBUG_TYPE_NULL;
 
 	if (**pp != ',')
 	  {
 	    bad_stab (orig);
 	    return DEBUG_TYPE_NULL;
 	  }
 	++*pp;
 
 	memtype = parse_stab_type (dhandle, info, (const char *) NULL, pp,
 				   (debug_type **) NULL, p_end);
 	if (memtype == DEBUG_TYPE_NULL)
 	  return DEBUG_TYPE_NULL;
 
 	dtype = debug_make_offset_type (dhandle, domain, memtype);
       }
       break;
 
     case '#':
       /* Method (class & fn) type.  */
       if (**pp == '#')
 	{
 	  debug_type return_type;
 
 	  ++*pp;
 	  return_type = parse_stab_type (dhandle, info, (const char *) NULL,
 					 pp, (debug_type **) NULL, p_end);
 	  if (return_type == DEBUG_TYPE_NULL)
 	    return DEBUG_TYPE_NULL;
 	  if (**pp != ';')
 	    {
 	      bad_stab (orig);
 	      return DEBUG_TYPE_NULL;
 	    }
 	  ++*pp;
 	  dtype = debug_make_method_type (dhandle, return_type,
 					  DEBUG_TYPE_NULL,
 					  (debug_type *) NULL, false);
 	}
       else
 	{
 	  debug_type domain;
 	  debug_type return_type;
-	  debug_type *args;
+	  debug_type *args, *xargs;
 	  unsigned int n;
 	  unsigned int alloc;
 	  bool varargs;
 
 	  domain = parse_stab_type (dhandle, info, (const char *) NULL,
 				    pp, (debug_type **) NULL, p_end);
 	  if (domain == DEBUG_TYPE_NULL)
 	    return DEBUG_TYPE_NULL;
 
 	  if (**pp != ',')
 	    {
 	      bad_stab (orig);
 	      return DEBUG_TYPE_NULL;
 	    }
 	  ++*pp;
 
 	  return_type = parse_stab_type (dhandle, info, (const char *) NULL,
 					 pp, (debug_type **) NULL, p_end);
 	  if (return_type == DEBUG_TYPE_NULL)
 	    return DEBUG_TYPE_NULL;
 
 	  alloc = 10;
-	  args = (debug_type *) xmalloc (alloc * sizeof *args);
+	  args = xmalloc (alloc * sizeof (*args));
 	  n = 0;
 	  while (**pp != ';')
 	    {
 	      if (**pp != ',')
 		{
 		  bad_stab (orig);
+		  free (args);
 		  return DEBUG_TYPE_NULL;
 		}
 	      ++*pp;
 
 	      if (n + 1 >= alloc)
 		{
 		  alloc += 10;
-		  args = ((debug_type *)
-			  xrealloc (args, alloc * sizeof *args));
+		  args = xrealloc (args, alloc * sizeof (*args));
 		}
 
 	      args[n] = parse_stab_type (dhandle, info, (const char *) NULL,
 					 pp, (debug_type **) NULL, p_end);
 	      if (args[n] == DEBUG_TYPE_NULL)
-		return DEBUG_TYPE_NULL;
+		{
+		  free (args);
+		  return DEBUG_TYPE_NULL;
+		}
 	      ++n;
 	    }
 	  ++*pp;
 
 	  /* If the last type is not void, then this function takes a
 	     variable number of arguments.  Otherwise, we must strip
 	     the void type.  */
 	  if (n == 0
 	      || debug_get_type_kind (dhandle, args[n - 1]) != DEBUG_KIND_VOID)
 	    varargs = true;
 	  else
 	    {
 	      --n;
 	      varargs = false;
 	    }
 
 	  args[n] = DEBUG_TYPE_NULL;
+	  xargs = debug_xalloc (dhandle, (n + 1) * sizeof (*args));
+	  memcpy (xargs, args, (n + 1) * sizeof (*args));
+	  free (args);
 
-	  dtype = debug_make_method_type (dhandle, return_type, domain, args,
+	  dtype = debug_make_method_type (dhandle, return_type, domain, xargs,
 					  varargs);
 	}
       break;
 
     case 'r':
       /* Range type.  */
       dtype = parse_stab_range_type (dhandle, info, type_name, pp, typenums, p_end);
       break;
 
     case 'b':
       /* FIXME: gdb checks os9k_stabs here.  */
       /* Sun ACC builtin int type.  */
       dtype = parse_stab_sun_builtin_type (dhandle, pp, p_end);
       break;
 
     case 'R':
       /* Sun ACC builtin float type.  */
       dtype = parse_stab_sun_floating_type (dhandle, pp, p_end);
       break;
 
     case 'e':
       /* Enumeration type.  */
       dtype = parse_stab_enum_type (dhandle, pp, p_end);
       break;
 
     case 's':
     case 'u':
       /* Struct or union type.  */
       dtype = parse_stab_struct_type (dhandle, info, type_name, pp,
 				      descriptor == 's', typenums, p_end);
       break;
 
     case 'a':
       /* Array type.  */
       if (**pp != 'r')
 	{
 	  bad_stab (orig);
 	  return DEBUG_TYPE_NULL;
 	}
       ++*pp;
 
       dtype = parse_stab_array_type (dhandle, info, pp, stringp, p_end);
       break;
 
     case 'S':
       dtype = debug_make_set_type (dhandle,
 				   parse_stab_type (dhandle, info,
 						    (const char *) NULL,
 						    pp,
 						    (debug_type **) NULL,
 						    p_end),
 				   stringp);
       break;
 
     default:
       bad_stab (orig);
       return DEBUG_TYPE_NULL;
     }
 
   if (dtype == DEBUG_TYPE_NULL)
     return DEBUG_TYPE_NULL;
 
   if (typenums[0] != -1)
     {
       if (! stab_record_type (dhandle, info, typenums, dtype))
 	return DEBUG_TYPE_NULL;
     }
 
   if (size != -1)
     {
       if (! debug_record_type_size (dhandle, dtype, (unsigned int) size))
 	return DEBUG_TYPE_NULL;
     }
 
   return dtype;
 }
 
 /* Read a number by which a type is referred to in dbx data, or
    perhaps read a pair (FILENUM, TYPENUM) in parentheses.  Just a
    single number N is equivalent to (0,N).  Return the two numbers by
    storing them in the vector TYPENUMS.  */
@@ -2008,97 +2021,100 @@ static debug_type
 parse_stab_enum_type (void *dhandle, const char **pp, const char * p_end)
 {
   const char *orig;
-  const char **names;
-  bfd_signed_vma *values;
+  const char **names, **xnames;
+  bfd_signed_vma *values, *xvalues;
   unsigned int n;
   unsigned int alloc;
 
   orig = *pp;
   if (orig >= p_end)
     return DEBUG_TYPE_NULL;
 
   /* FIXME: gdb checks os9k_stabs here.  */
 
   /* The aix4 compiler emits an extra field before the enum members;
      my guess is it's a type of some sort.  Just ignore it.  */
   if (**pp == '-')
     {
       while (**pp != ':' && **pp != 0)
 	++*pp;
 
       if (**pp == 0)
 	{
 	  bad_stab (orig);
 	  return DEBUG_TYPE_NULL;
 	}
       ++*pp;
     }
 
   /* Read the value-names and their values.
      The input syntax is NAME:VALUE,NAME:VALUE, and so on.
      A semicolon or comma instead of a NAME means the end.  */
   alloc = 10;
-  names = (const char **) xmalloc (alloc * sizeof *names);
-  values = (bfd_signed_vma *) xmalloc (alloc * sizeof *values);
+  names = xmalloc (alloc * sizeof (*names));
+  values = xmalloc (alloc * sizeof (*values));
   n = 0;
   while (**pp != '\0' && **pp != ';' && **pp != ',')
     {
       const char *p;
       char *name;
       bfd_signed_vma val;
 
       p = *pp;
       while (*p != ':' && *p != 0)
 	++p;
 
       if (*p == 0)
 	{
 	  bad_stab (orig);
 	  free (names);
 	  free (values);
 	  return DEBUG_TYPE_NULL;
 	}
 
-      name = savestring (*pp, p - *pp);
+      name = savestring (dhandle, *pp, p - *pp);
 
       *pp = p + 1;
       val = (bfd_signed_vma) parse_number (pp, (bool *) NULL, p_end);
       if (**pp != ',')
 	{
 	  bad_stab (orig);
-	  free (name);
 	  free (names);
 	  free (values);
 	  return DEBUG_TYPE_NULL;
 	}
       ++*pp;
 
       if (n + 1 >= alloc)
 	{
 	  alloc += 10;
-	  names = ((const char **)
-		   xrealloc (names, alloc * sizeof *names));
-	  values = ((bfd_signed_vma *)
-		    xrealloc (values, alloc * sizeof *values));
+	  names = xrealloc (names, alloc * sizeof (*names));
+	  values = xrealloc (values, alloc * sizeof (*values));
 	}
 
       names[n] = name;
       values[n] = val;
       ++n;
     }
 
   names[n] = NULL;
   values[n] = 0;
+  xnames = debug_xalloc (dhandle, (n + 1) * sizeof (*names));
+  memcpy (xnames, names, (n + 1) * sizeof (*names));
+  free (names);
+  xvalues = debug_xalloc (dhandle, (n + 1) * sizeof (*names));
+  memcpy (xvalues, values, (n + 1) * sizeof (*names));
+  free (values);
 
   if (**pp == ';')
     ++*pp;
 
-  return debug_make_enum_type (dhandle, names, values);
+  return debug_make_enum_type (dhandle, xnames, xvalues);
 }
 
 /* Read the description of a structure (or union type) and return an object
    describing the type.
 
    PP points to a character pointer that points to the next unconsumed token
    in the stabs string.  For example, given stabs "A:T4=s4a:1,0,32;;",
    *PP will point to "4a:1,0,32;;".  */
@@ -2107,64 +2123,61 @@ static debug_type
 parse_stab_struct_type (void *dhandle,
 			struct stab_handle *info,
 			const char *tagname,
 			const char **pp,
 			bool structp,
 			const int *typenums,
 			const char *p_end)
 {
   bfd_vma size;
   debug_baseclass *baseclasses;
   debug_field *fields = NULL;
   bool statics;
   debug_method *methods;
   debug_type vptrbase;
   bool ownvptr;
 
   /* Get the size.  */
   size = parse_number (pp, (bool *) NULL, p_end);
 
   /* Get the other information.  */
   if (! parse_stab_baseclasses (dhandle, info, pp, &baseclasses, p_end)
       || ! parse_stab_struct_fields (dhandle, info, pp, &fields, &statics, p_end)
       || ! parse_stab_members (dhandle, info, tagname, pp, typenums, &methods, p_end)
       || ! parse_stab_tilde_field (dhandle, info, pp, typenums, &vptrbase,
 				   &ownvptr, p_end))
-    {
-      free (fields);
-      return DEBUG_TYPE_NULL;
-    }
+    return DEBUG_TYPE_NULL;
 
   if (! statics
       && baseclasses == NULL
       && methods == NULL
       && vptrbase == DEBUG_TYPE_NULL
       && ! ownvptr)
     return debug_make_struct_type (dhandle, structp, size, fields);
 
   return debug_make_object_type (dhandle, structp, size, fields, baseclasses,
 				 methods, vptrbase, ownvptr);
 }
 
 /* The stabs for C++ derived classes contain baseclass information which
    is marked by a '!' character after the total size.  This function is
    called when we encounter the baseclass marker, and slurps up all the
    baseclass information.
 
    Immediately following the '!' marker is the number of base classes that
    the class is derived from, followed by information for each base class.
    For each base class, there are two visibility specifiers, a bit offset
    to the base class information within the derived class, a reference to
    the type for the base class, and a terminating semicolon.
 
    A typical example, with two base classes, would be "!2,020,19;0264,21;".
 						       ^^ ^ ^ ^  ^ ^  ^
 	Baseclass information marker __________________|| | | |  | |  |
 	Number of baseclasses __________________________| | | |  | |  |
 	Visibility specifiers (2) ________________________| | |  | |  |
 	Offset in bits from start of class _________________| |  | |  |
 	Type number for base class ___________________________|  | |  |
 	Visibility specifiers (2) _______________________________| |  |
 	Offset in bits from start of class ________________________|  |
 	Type number of base class ____________________________________|
 
   Return TRUE for success, FALSE for failure.  */
@@ -2173,132 +2186,132 @@ static bool
 parse_stab_baseclasses (void *                dhandle,
 			struct stab_handle *  info,
 			const char **         pp,
 			debug_baseclass **    retp,
 			const char *          p_end)
 {
   const char *orig;
   unsigned int c, i;
   debug_baseclass *classes;
 
   *retp = NULL;
 
   orig = *pp;
   if (orig >= p_end)
     return false;
 
   if (**pp != '!')
     {
       /* No base classes.  */
       return true;
     }
   ++*pp;
 
   c = (unsigned int) parse_number (pp, (bool *) NULL, p_end);
 
   if (**pp != ',')
     {
       bad_stab (orig);
       return false;
     }
   ++*pp;
 
-  classes = (debug_baseclass *) xmalloc ((c + 1) * sizeof (**retp));
+  classes = debug_xalloc (dhandle, (c + 1) * sizeof (*classes));
 
   for (i = 0; i < c; i++)
     {
       bool is_virtual;
       enum debug_visibility visibility;
       bfd_vma bitpos;
       debug_type type;
 
       switch (**pp)
 	{
 	case '0':
 	  is_virtual = false;
 	  break;
 	case '1':
 	  is_virtual = true;
 	  break;
 	case 0:
 	  bad_stab (orig);
 	  return false;
 	default:
 	  warn_stab (orig, _("unknown virtual character for baseclass"));
 	  is_virtual = false;
 	  break;
 	}
       ++*pp;
 
       switch (**pp)
 	{
 	case '0':
 	  visibility = DEBUG_VISIBILITY_PRIVATE;
 	  break;
 	case '1':
 	  visibility = DEBUG_VISIBILITY_PROTECTED;
 	  break;
 	case '2':
 	  visibility = DEBUG_VISIBILITY_PUBLIC;
 	  break;
 	case 0:
 	  bad_stab (orig);
 	  return false;
 	default:
 	  warn_stab (orig, _("unknown visibility character for baseclass"));
 	  visibility = DEBUG_VISIBILITY_PUBLIC;
 	  break;
 	}
       ++*pp;
 
       /* The remaining value is the bit offset of the portion of the
 	 object corresponding to this baseclass.  Always zero in the
 	 absence of multiple inheritance.  */
       bitpos = parse_number (pp, (bool *) NULL, p_end);
       if (**pp != ',')
 	{
 	  bad_stab (orig);
 	  return false;
 	}
       ++*pp;
 
       type = parse_stab_type (dhandle, info, (const char *) NULL, pp,
 			      (debug_type **) NULL, p_end);
       if (type == DEBUG_TYPE_NULL)
 	return false;
 
       classes[i] = debug_make_baseclass (dhandle, type, bitpos, is_virtual,
 					 visibility);
       if (classes[i] == DEBUG_BASECLASS_NULL)
 	return false;
 
       if (**pp != ';')
 	return false;
       ++*pp;
     }
 
   classes[i] = DEBUG_BASECLASS_NULL;
 
   *retp = classes;
 
   return true;
 }
 
 /* Read struct or class data fields.  They have the form:
 
 	NAME : [VISIBILITY] TYPENUM , BITPOS , BITSIZE ;
 
    At the end, we see a semicolon instead of a field.
 
    In C++, this may wind up being NAME:?TYPENUM:PHYSNAME; for
    a static field.
 
    The optional VISIBILITY is one of:
 
 	'/0'	(VISIBILITY_PRIVATE)
 	'/1'	(VISIBILITY_PROTECTED)
 	'/2'	(VISIBILITY_PUBLIC)
 	'/9'	(VISIBILITY_IGNORE)
 
    or nothing, for C style fields with public visibility.
 
    Returns 1 for success, 0 for failure.  */
@@ -2307,90 +2320,92 @@ static bool
 parse_stab_struct_fields (void *dhandle,
 			  struct stab_handle *info,
 			  const char **pp,
 			  debug_field **retp,
 			  bool *staticsp,
 			  const char * p_end)
 {
   const char *orig;
   const char *p;
-  debug_field *fields;
+  debug_field *fields, *xfields;
   unsigned int c;
   unsigned int alloc;
 
   *retp = NULL;
   *staticsp = false;
 
   orig = *pp;
   if (orig >= p_end)
     return false;
 
   c = 0;
   alloc = 10;
-  fields = (debug_field *) xmalloc (alloc * sizeof *fields);
+  fields = xmalloc (alloc * sizeof (*fields));
   while (**pp != ';')
     {
       /* FIXME: gdb checks os9k_stabs here.  */
 
       p = *pp;
 
       /* Add 1 to c to leave room for NULL pointer at end.  */
       if (c + 1 >= alloc)
 	{
 	  alloc += 10;
-	  fields = ((debug_field *)
-		    xrealloc (fields, alloc * sizeof *fields));
+	  fields = xrealloc (fields, alloc * sizeof (*fields));
 	}
 
       /* If it starts with CPLUS_MARKER it is a special abbreviation,
 	 unless the CPLUS_MARKER is followed by an underscore, in
 	 which case it is just the name of an anonymous type, which we
 	 should handle like any other type name.  We accept either '$'
 	 or '.', because a field name can never contain one of these
 	 characters except as a CPLUS_MARKER.  */
 
       if ((*p == '$' || *p == '.') && p[1] != '_')
 	{
 	  ++*pp;
 	  if (! parse_stab_cpp_abbrev (dhandle, info, pp, fields + c, p_end))
 	    {
 	      free (fields);
 	      return false;
 	    }
 	  ++c;
 	  continue;
 	}
 
       /* Look for the ':' that separates the field name from the field
 	 values.  Data members are delimited by a single ':', while member
 	 functions are delimited by a pair of ':'s.  When we hit the member
 	 functions (if any), terminate scan loop and return.  */
 
       p = strchr (p, ':');
       if (p == NULL)
 	{
 	  bad_stab (orig);
 	  free (fields);
 	  return false;
 	}
 
       if (p[1] == ':')
 	break;
 
       if (! parse_stab_one_struct_field (dhandle, info, pp, p, fields + c,
 					 staticsp, p_end))
 	{
 	  free (fields);
 	  return false;
 	}
 
       ++c;
     }
 
   fields[c] = DEBUG_FIELD_NULL;
+  xfields = debug_xalloc (dhandle, (c + 1) * sizeof (*fields));
+  memcpy (xfields, fields, (c + 1) * sizeof (*fields));
+  free (fields);
 
-  *retp = fields;
+  *retp = xfields;
 
   return true;
 }
 
 /* Special GNU C++ name.  */
@@ -2399,100 +2414,104 @@ static bool
 parse_stab_cpp_abbrev (void *                dhandle,
 		       struct stab_handle *  info,
 		       const char **         pp,
 		       debug_field *         retp,
 		       const char *          p_end)
 {
   const char *orig;
   int cpp_abbrev;
   debug_type context;
   const char *name;
   const char *type_name;
   debug_type type;
   bfd_vma bitpos;
+  size_t len;
 
   *retp = DEBUG_FIELD_NULL;
 
   orig = *pp;
   if (orig >= p_end)
     return false;
 
   if (**pp != 'v')
     {
       bad_stab (*pp);
       return false;
     }
   ++*pp;
 
   cpp_abbrev = **pp;
   if (cpp_abbrev == 0)
     {
       bad_stab (orig);
       return false;
     }
   ++*pp;
 
   /* At this point, *pp points to something like "22:23=*22...", where
      the type number before the ':' is the "context" and everything
      after is a regular type definition.  Lookup the type, find it's
      name, and construct the field name.  */
 
   context = parse_stab_type (dhandle, info, (const char *) NULL, pp,
 			     (debug_type **) NULL, p_end);
   if (context == DEBUG_TYPE_NULL)
     return false;
 
   switch (cpp_abbrev)
     {
     case 'f':
       /* $vf -- a virtual function table pointer.  */
       name = "_vptr$";
       break;
     case 'b':
       /* $vb -- a virtual bsomethingorother */
       type_name = debug_get_type_name (dhandle, context);
       if (type_name == NULL)
 	{
 	  warn_stab (orig, _("unnamed $vb type"));
 	  type_name = "FOO";
 	}
-      name = concat ("_vb$", type_name, (const char *) NULL);
+      len = strlen (type_name);
+      name = debug_xalloc (dhandle, len + sizeof ("_vb$"));
+      memcpy ((char *) name, "_vb$", sizeof ("_vb$") - 1);
+      memcpy ((char *) name + sizeof ("_vb$") - 1, type_name, len + 1);
       break;
     default:
       warn_stab (orig, _("unrecognized C++ abbreviation"));
       name = "INVALID_CPLUSPLUS_ABBREV";
       break;
     }
 
   if (**pp != ':')
     {
       bad_stab (orig);
       return false;
     }
   ++*pp;
 
   type = parse_stab_type (dhandle, info, (const char *) NULL, pp,
 			  (debug_type **) NULL, p_end);
   if (**pp != ',')
     {
       bad_stab (orig);
       return false;
     }
   ++*pp;
 
   bitpos = parse_number (pp, (bool *) NULL, p_end);
   if (**pp != ';')
     {
       bad_stab (orig);
       return false;
     }
   ++*pp;
 
   *retp = debug_make_field (dhandle, name, type, bitpos, 0,
 			    DEBUG_VISIBILITY_PRIVATE);
   if (*retp == DEBUG_FIELD_NULL)
     return false;
 
   return true;
 }
 
 /* Parse a single field in a struct or union.  */
@@ -2501,148 +2520,141 @@ static bool
 parse_stab_one_struct_field (void *dhandle,
 			     struct stab_handle *info,
 			     const char **pp,
 			     const char *p,
 			     debug_field *retp,
 			     bool *staticsp,
 			     const char *p_end)
 {
   const char *orig;
   char *name;
   enum debug_visibility visibility;
   debug_type type;
   bfd_vma bitpos;
   bfd_vma bitsize;
 
   orig = *pp;
   if (orig >= p_end)
     return false;
 
   /* FIXME: gdb checks ARM_DEMANGLING here.  */
 
-  name = savestring (*pp, p - *pp);
+  name = savestring (dhandle, *pp, p - *pp);
 
   *pp = p + 1;
 
   if (**pp != '/')
     visibility = DEBUG_VISIBILITY_PUBLIC;
   else
     {
       ++*pp;
       switch (**pp)
 	{
 	case '0':
 	  visibility = DEBUG_VISIBILITY_PRIVATE;
 	  break;
 	case '1':
 	  visibility = DEBUG_VISIBILITY_PROTECTED;
 	  break;
 	case '2':
 	  visibility = DEBUG_VISIBILITY_PUBLIC;
 	  break;
 	case 0:
 	  bad_stab (orig);
 	  return false;
 	default:
 	  warn_stab (orig, _("unknown visibility character for field"));
 	  visibility = DEBUG_VISIBILITY_PUBLIC;
 	  break;
 	}
       ++*pp;
     }
 
   type = parse_stab_type (dhandle, info, (const char *) NULL, pp,
 			  (debug_type **) NULL, p_end);
   if (type == DEBUG_TYPE_NULL)
-    {
-      free (name);
-      return false;
-    }
+    return false;
 
   if (**pp == ':')
     {
       char *varname;
 
       /* This is a static class member.  */
       ++*pp;
       p = strchr (*pp, ';');
       if (p == NULL)
 	{
 	  bad_stab (orig);
-	  free (name);
 	  return false;
 	}
 
-      varname = savestring (*pp, p - *pp);
+      varname = savestring (dhandle, *pp, p - *pp);
 
       *pp = p + 1;
 
       *retp = debug_make_static_member (dhandle, name, type, varname,
 					visibility);
       *staticsp = true;
 
       return true;
     }
 
   if (**pp != ',')
     {
       bad_stab (orig);
-      free (name);
       return false;
     }
   ++*pp;
 
   bitpos = parse_number (pp, (bool *) NULL, p_end);
   if (**pp != ',')
     {
       bad_stab (orig);
-      free (name);
       return false;
     }
   ++*pp;
 
   bitsize = parse_number (pp, (bool *) NULL, p_end);
   if (**pp != ';')
     {
       bad_stab (orig);
-      free (name);
       return false;
     }
   ++*pp;
 
   if (bitpos == 0 && bitsize == 0)
     {
       /* This can happen in two cases: (1) at least for gcc 2.4.5 or
 	 so, it is a field which has been optimized out.  The correct
 	 stab for this case is to use VISIBILITY_IGNORE, but that is a
 	 recent invention.  (2) It is a 0-size array.  For example
 	 union { int num; char str[0]; } foo.  Printing "<no value>"
 	 for str in "p foo" is OK, since foo.str (and thus foo.str[3])
 	 will continue to work, and a 0-size array as a whole doesn't
 	 have any contents to print.
 
 	 I suspect this probably could also happen with gcc -gstabs
 	 (not -gstabs+) for static fields, and perhaps other C++
 	 extensions.  Hopefully few people use -gstabs with gdb, since
 	 it is intended for dbx compatibility.  */
       visibility = DEBUG_VISIBILITY_IGNORE;
     }
 
   /* FIXME: gdb does some stuff here to mark fields as unpacked.  */
 
   *retp = debug_make_field (dhandle, name, type, bitpos, bitsize, visibility);
 
   return true;
 }
 
 /* Read member function stabs info for C++ classes.  The form of each member
    function data is:
 
 	NAME :: TYPENUM[=type definition] ARGS : PHYSNAME ;
 
    An example with two member functions is:
 
 	afunc1::20=##15;:i;2A.;afunc2::20:i;2A.;
 
    For the case of overloaded operators, the format is op$::*.funcs, where
    $ is the CPLUS_MARKER (usually '$'), `*' holds the place for an operator
    name (such as `+=') and `.' marks the end of the operator name.  */
@@ -2651,331 +2663,335 @@ static bool
 parse_stab_members (void *                dhandle,
 		    struct stab_handle *  info,
 		    const char *          tagname,
 		    const char **         pp,
 		    const int *           typenums,
 		    debug_method **       retp,
 		    const char *          p_end)
 {
   const char *orig;
-  debug_method *methods;
+  debug_method *methods, *xmethods;
   unsigned int c;
   unsigned int alloc;
   char *name = NULL;
-  debug_method_variant *variants = NULL;
+  debug_method_variant *variants = NULL, *xvariants;
   char *argtypes = NULL;
 
   *retp = NULL;
 
   orig = *pp;
   if (orig >= p_end)
     return false;
 
   alloc = 0;
   methods = NULL;
   c = 0;
 
   while (**pp != ';')
     {
       const char *p;
       unsigned int cvars;
       unsigned int allocvars;
       debug_type look_ahead_type;
 
       p = strchr (*pp, ':');
       if (p == NULL || p[1] != ':')
 	break;
 
       /* FIXME: Some systems use something other than '$' here.  */
       if ((*pp)[0] != 'o' || (*pp)[1] != 'p' || (*pp)[2] != '$')
 	{
-	  name = savestring (*pp, p - *pp);
+	  name = savestring (dhandle, *pp, p - *pp);
 	  *pp = p + 2;
 	}
       else
 	{
 	  /* This is a completely weird case.  In order to stuff in the
 	     names that might contain colons (the usual name delimiter),
 	     Mike Tiemann defined a different name format which is
 	     signalled if the identifier is "op$".  In that case, the
 	     format is "op$::XXXX." where XXXX is the name.  This is
 	     used for names like "+" or "=".  YUUUUUUUK!  FIXME!  */
 	  *pp = p + 2;
 	  for (p = *pp; *p != '.' && *p != '\0'; p++)
 	    ;
 	  if (*p != '.')
 	    {
 	      bad_stab (orig);
 	      goto fail;
 	    }
-	  name = savestring (*pp, p - *pp);
+	  name = savestring (dhandle, *pp, p - *pp);
 	  *pp = p + 1;
 	}
 
       allocvars = 10;
-      variants = ((debug_method_variant *)
-		  xmalloc (allocvars * sizeof *variants));
+      variants = xmalloc (allocvars * sizeof (*variants));
       cvars = 0;
 
       look_ahead_type = DEBUG_TYPE_NULL;
 
       do
 	{
 	  debug_type type;
 	  bool stub;
 	  enum debug_visibility visibility;
 	  bool constp, volatilep, staticp;
 	  bfd_vma voffset;
 	  debug_type context;
 	  const char *physname;
 	  bool varargs;
 
 	  if (look_ahead_type != DEBUG_TYPE_NULL)
 	    {
 	      /* g++ version 1 kludge */
 	      type = look_ahead_type;
 	      look_ahead_type = DEBUG_TYPE_NULL;
 	    }
 	  else
 	    {
 	      type = parse_stab_type (dhandle, info, (const char *) NULL, pp,
 				      (debug_type **) NULL, p_end);
 	      if (type == DEBUG_TYPE_NULL)
 		goto fail;
 
 	      if (**pp != ':')
 		{
 		  bad_stab (orig);
 		  goto fail;
 		}
 	    }
 
 	  ++*pp;
 	  p = strchr (*pp, ';');
 	  if (p == NULL)
 	    {
 	      bad_stab (orig);
 	      goto fail;
 	    }
 
 	  stub = false;
 	  if (debug_get_type_kind (dhandle, type) == DEBUG_KIND_METHOD
 	      && debug_get_parameter_types (dhandle, type, &varargs) == NULL)
 	    stub = true;
 
-	  argtypes = savestring (*pp, p - *pp);
+	  argtypes = savestring (dhandle, *pp, p - *pp);
 	  *pp = p + 1;
 
 	  switch (**pp)
 	    {
 	    case '0':
 	      visibility = DEBUG_VISIBILITY_PRIVATE;
 	      break;
 	    case '1':
 	      visibility = DEBUG_VISIBILITY_PROTECTED;
 	      break;
 	    case 0:
 	      bad_stab (orig);
 	      goto fail;
 	    default:
 	      visibility = DEBUG_VISIBILITY_PUBLIC;
 	      break;
 	    }
 	  ++*pp;
 
 	  constp = false;
 	  volatilep = false;
 	  switch (**pp)
 	    {
 	    case 'A':
 	      /* Normal function.  */
 	      ++*pp;
 	      break;
 	    case 'B':
 	      /* const member function.  */
 	      constp = true;
 	      ++*pp;
 	      break;
 	    case 'C':
 	      /* volatile member function.  */
 	      volatilep = true;
 	      ++*pp;
 	      break;
 	    case 'D':
 	      /* const volatile member function.  */
 	      constp = true;
 	      volatilep = true;
 	      ++*pp;
 	      break;
 	    case '*':
 	    case '?':
 	    case '.':
 	      /* File compiled with g++ version 1; no information.  */
 	      break;
 	    default:
 	      warn_stab (orig, _("const/volatile indicator missing"));
 	      break;
 	    }
 
 	  staticp = false;
 	  switch (**pp)
 	    {
 	    case '*':
 	      /* virtual member function, followed by index.  The sign
 		 bit is supposedly set to distinguish
 		 pointers-to-methods from virtual function indices.  */
 	      ++*pp;
 	      voffset = parse_number (pp, (bool *) NULL, p_end);
 	      if (**pp != ';')
 		{
 		  bad_stab (orig);
 		  goto fail;
 		}
 	      ++*pp;
 	      voffset &= 0x7fffffff;
 
 	      if (**pp == ';' || **pp == '\0')
 		{
 		  /* Must be g++ version 1.  */
 		  context = DEBUG_TYPE_NULL;
 		}
 	      else
 		{
 		  /* Figure out from whence this virtual function
 		     came.  It may belong to virtual function table of
 		     one of its baseclasses.  */
 		  look_ahead_type = parse_stab_type (dhandle, info,
 						     (const char *) NULL,
 						     pp,
 						     (debug_type **) NULL,
 						     p_end);
 		  if (**pp == ':')
 		    {
 		      /* g++ version 1 overloaded methods.  */
 		      context = DEBUG_TYPE_NULL;
 		    }
 		  else
 		    {
 		      context = look_ahead_type;
 		      look_ahead_type = DEBUG_TYPE_NULL;
 		      if (**pp != ';')
 			{
 			  bad_stab (orig);
 			  goto fail;
 			}
 		      ++*pp;
 		    }
 		}
 	      break;
 
 	    case '?':
 	      /* static member function.  */
 	      ++*pp;
 	      staticp = true;
 	      voffset = 0;
 	      context = DEBUG_TYPE_NULL;
 	      if (strncmp (argtypes, name, strlen (name)) != 0)
 		stub = true;
 	      break;
 
 	    default:
 	      warn_stab (orig, "member function type missing");
 	      voffset = 0;
 	      context = DEBUG_TYPE_NULL;
 	      break;
 
 	    case '.':
 	      ++*pp;
 	      voffset = 0;
 	      context = DEBUG_TYPE_NULL;
 	      break;
 	    }
 
 	  /* If the type is not a stub, then the argtypes string is
              the physical name of the function.  Otherwise the
              argtypes string is the mangled form of the argument
              types, and the full type and the physical name must be
              extracted from them.  */
 	  physname = argtypes;
 	  if (stub)
 	    {
 	      debug_type class_type, return_type;
 
 	      class_type = stab_find_type (dhandle, info, typenums);
 	      if (class_type == DEBUG_TYPE_NULL)
 		goto fail;
 	      return_type = debug_get_return_type (dhandle, type);
 	      if (return_type == DEBUG_TYPE_NULL)
 		{
 		  bad_stab (orig);
 		  goto fail;
 		}
 	      type = parse_stab_argtypes (dhandle, info, class_type, name,
 					  tagname, return_type, argtypes,
 					  constp, volatilep, &physname);
 	      if (type == DEBUG_TYPE_NULL)
 		goto fail;
 	    }
 
 	  if (cvars + 1 >= allocvars)
 	    {
 	      allocvars += 10;
-	      variants = ((debug_method_variant *)
-			  xrealloc (variants,
-				    allocvars * sizeof *variants));
+	      variants = xrealloc (variants, allocvars * sizeof (*variants));
 	    }
 
 	  if (! staticp)
 	    variants[cvars] = debug_make_method_variant (dhandle, physname,
 							 type, visibility,
 							 constp, volatilep,
 							 voffset, context);
 	  else
 	    variants[cvars] = debug_make_static_method_variant (dhandle,
 								physname,
 								type,
 								visibility,
 								constp,
 								volatilep);
 	  if (variants[cvars] == DEBUG_METHOD_VARIANT_NULL)
 	    goto fail;
 
 	  ++cvars;
 	}
       while (**pp != ';' && **pp != '\0');
 
       variants[cvars] = DEBUG_METHOD_VARIANT_NULL;
+      xvariants = debug_xalloc (dhandle, (cvars + 1) * sizeof (*variants));
+      memcpy (xvariants, variants, (cvars + 1) * sizeof (*variants));
+      free (variants);
 
       if (**pp != '\0')
 	++*pp;
 
       if (c + 1 >= alloc)
 	{
 	  alloc += 10;
-	  methods = ((debug_method *)
-		     xrealloc (methods, alloc * sizeof *methods));
+	  methods = xrealloc (methods, alloc * sizeof (*methods));
 	}
 
-      methods[c] = debug_make_method (dhandle, name, variants);
+      methods[c] = debug_make_method (dhandle, name, xvariants);
 
       ++c;
     }
 
+  xmethods = methods;
   if (methods != NULL)
-    methods[c] = DEBUG_METHOD_NULL;
+    {
+      methods[c] = DEBUG_METHOD_NULL;
+      xmethods = debug_xalloc (dhandle, (c + 1) * sizeof (*methods));
+      memcpy (xmethods, methods, (c + 1) * sizeof (*methods));
+      free (methods);
+    }
 
-  *retp = methods;
+  *retp = xmethods;
 
   return true;
 
  fail:
-  free (name);
   free (variants);
-  free (argtypes);
+  free (methods);
   return false;
 }
 
 /* Parse a string representing argument types for a method.  Stabs
    tries to save space by packing argument types into a mangled
    string.  This string should give us enough information to extract
    both argument types and the physical name of the function, given
    the tag name.  */
@@ -2984,108 +3000,108 @@ static debug_type
 parse_stab_argtypes (void *dhandle, struct stab_handle *info,
 		     debug_type class_type, const char *fieldname,
 		     const char *tagname, debug_type return_type,
 		     const char *argtypes, bool constp,
 		     bool volatilep, const char **pphysname)
 {
   bool is_full_physname_constructor;
   bool is_constructor;
   bool is_destructor;
   bool is_v3;
   debug_type *args;
   bool varargs;
   unsigned int physname_len = 0;
 
   /* Constructors are sometimes handled specially.  */
   is_full_physname_constructor = ((argtypes[0] == '_'
 				   && argtypes[1] == '_'
 				   && (ISDIGIT (argtypes[2])
 				       || argtypes[2] == 'Q'
 				       || argtypes[2] == 't'))
 				  || startswith (argtypes, "__ct"));
 
   is_constructor = (is_full_physname_constructor
 		    || (tagname != NULL
 			&& strcmp (fieldname, tagname) == 0));
   is_destructor = ((argtypes[0] == '_'
 		    && (argtypes[1] == '$' || argtypes[1] == '.')
 		    && argtypes[2] == '_')
 		   || startswith (argtypes, "__dt"));
   is_v3 = argtypes[0] == '_' && argtypes[1] == 'Z';
 
   if (!(is_destructor || is_full_physname_constructor || is_v3))
     {
       unsigned int len;
       const char *const_prefix;
       const char *volatile_prefix;
       char buf[20];
       unsigned int mangled_name_len;
       char *physname;
 
       len = tagname == NULL ? 0 : strlen (tagname);
       const_prefix = constp ? "C" : "";
       volatile_prefix = volatilep ? "V" : "";
 
       if (len == 0)
 	sprintf (buf, "__%s%s", const_prefix, volatile_prefix);
       else if (tagname != NULL && strchr (tagname, '<') != NULL)
 	{
 	  /* Template methods are fully mangled.  */
 	  sprintf (buf, "__%s%s", const_prefix, volatile_prefix);
 	  tagname = NULL;
 	  len = 0;
 	}
       else
 	sprintf (buf, "__%s%s%d", const_prefix, volatile_prefix, len);
 
       mangled_name_len = ((is_constructor ? 0 : strlen (fieldname))
 			  + strlen (buf)
 			  + len
 			  + strlen (argtypes)
 			  + 1);
 
       if (fieldname[0] == 'o'
 	  && fieldname[1] == 'p'
 	  && (fieldname[2] == '$' || fieldname[2] == '.'))
 	{
 	  /* Opname selection is no longer supported by libiberty's demangler.  */
 	  return DEBUG_TYPE_NULL;
 	}
 
-      physname = (char *) xmalloc (mangled_name_len);
+      physname = debug_xalloc (dhandle, mangled_name_len);
       if (is_constructor)
 	physname[0] = '\0';
       else
 	strcpy (physname, fieldname);
 
       physname_len = strlen (physname);
       strcat (physname, buf);
       if (tagname != NULL)
 	strcat (physname, tagname);
       strcat (physname, argtypes);
 
       *pphysname = physname;
     }
 
   if (*argtypes == '\0' || is_destructor)
     {
-      args = (debug_type *) xmalloc (sizeof *args);
+      args = debug_xalloc (dhandle, sizeof (*args));
       *args = NULL;
       return debug_make_method_type (dhandle, return_type, class_type, args,
 				     false);
     }
 
   args = stab_demangle_argtypes (dhandle, info, *pphysname, &varargs, physname_len);
   if (args == NULL)
     return DEBUG_TYPE_NULL;
 
   return debug_make_method_type (dhandle, return_type, class_type, args,
 				 varargs);
 }
 
 /* The tail end of stabs for C++ classes that contain a virtual function
    pointer contains a tilde, a %, and a type number.
    The type number refers to the base class (possibly this class itself) which
    contains the vtable pointer for the current class.
 
    This function is called when we have parsed all the method declarations,
    so we can look for the vptr base class info.  */
@@ -3290,27 +3306,26 @@ struct bincl_file
 /* Start a new N_BINCL file, pushing it onto the stack.  */
 
 static void
-push_bincl (struct stab_handle *info, const char *name, bfd_vma hash)
+push_bincl (void *dhandle, struct stab_handle *info, const char *name,
+	    bfd_vma hash)
 {
   struct bincl_file *n;
 
-  n = (struct bincl_file *) xmalloc (sizeof *n);
+  n = debug_xalloc (dhandle, sizeof *n);
   n->next = info->bincl_list;
   n->next_stack = info->bincl_stack;
   n->name = name;
   n->hash = hash;
   n->file = info->files;
   n->file_types = NULL;
   info->bincl_list = n;
   info->bincl_stack = n;
 
   ++info->files;
-  info->file_types = ((struct stab_types **)
-		      xrealloc (info->file_types,
-				(info->files
-				 * sizeof *info->file_types)));
+  info->file_types = xrealloc (info->file_types,
+			       info->files * sizeof (*info->file_types));
   info->file_types[n->file] = NULL;
 }
 
 /* Finish an N_BINCL file, at an N_EINCL, popping the name off the
    stack.  */
@@ -3341,29 +3356,27 @@ static bool
 find_excl (struct stab_handle *info, const char *name, bfd_vma hash)
 {
   struct bincl_file *l;
 
   ++info->files;
-  info->file_types = ((struct stab_types **)
-		      xrealloc (info->file_types,
-				(info->files
-				 * sizeof *info->file_types)));
+  info->file_types = xrealloc (info->file_types,
+			       info->files * sizeof (*info->file_types));
 
   for (l = info->bincl_list; l != NULL; l = l->next)
     if (l->hash == hash && strcmp (l->name, name) == 0)
       break;
   if (l == NULL)
     {
       warn_stab (name, _("Undefined N_EXCL"));
       info->file_types[info->files - 1] = NULL;
       return true;
     }
 
   info->file_types[info->files - 1] = l->file_types;
 
   return true;
 }
 
 /* Handle a variable definition.  gcc emits variable definitions for a
    block before the N_LBRAC, so we must hold onto them until we see
    it.  The SunPRO compiler emits variable definitions after the
    N_LBRAC, so we can call debug_record_variable immediately.  */
@@ -3372,26 +3385,25 @@ static bool
 stab_record_variable (void *dhandle, struct stab_handle *info,
 		      const char *name, debug_type type,
 		      enum debug_var_kind kind, bfd_vma val)
 {
   struct stab_pending_var *v;
 
   if ((kind == DEBUG_GLOBAL || kind == DEBUG_STATIC)
       || ! info->within_function
       || (info->gcc_compiled == 0 && info->n_opt_found))
     return debug_record_variable (dhandle, name, type, kind, val);
 
-  v = (struct stab_pending_var *) xmalloc (sizeof *v);
-  memset (v, 0, sizeof *v);
+  v = debug_xzalloc (dhandle, sizeof (*v));
 
   v->next = info->pending;
   v->name = name;
   v->type = type;
   v->kind = kind;
   v->val = val;
   info->pending = v;
 
   return true;
 }
 
 /* Emit pending variable definitions.  This is called after we see the
    N_LBRAC that starts the block.  */
@@ -3400,60 +3412,56 @@ static bool
 stab_emit_pending_vars (void *dhandle, struct stab_handle *info)
 {
   struct stab_pending_var *v;
 
   v = info->pending;
   while (v != NULL)
     {
-      struct stab_pending_var *next;
-
       if (! debug_record_variable (dhandle, v->name, v->type, v->kind, v->val))
 	return false;
 
-      next = v->next;
-      free (v);
-      v = next;
+      v = v->next;
     }
 
   info->pending = NULL;
 
   return true;
 }
 
 /* Find the slot for a type in the database.  */
 
 static debug_type *
-stab_find_slot (struct stab_handle *info, const int *typenums)
+stab_find_slot (void *dhandle, struct stab_handle *info, const int *typenums)
 {
   unsigned int filenum;
   unsigned int tindex;
   unsigned int base_index;
   struct stab_types **ps;
 
   filenum = typenums[0];
   tindex = typenums[1];
 
   if (filenum >= info->files)
     {
       fprintf (stderr, _("Type file number %d out of range\n"), filenum);
       return NULL;
     }
 
   ps = info->file_types + filenum;
   base_index = tindex / STAB_TYPES_SLOTS * STAB_TYPES_SLOTS;
   tindex -= base_index;
   while (*ps && (*ps)->base_index < base_index)
     ps = &(*ps)->next;
 
   if (*ps == NULL || (*ps)->base_index != base_index)
     {
-      struct stab_types *n = xcalloc (1, sizeof (*n));
+      struct stab_types *n = debug_xzalloc (dhandle, sizeof (*n));
       n->next = *ps;
       n->base_index = base_index;
       *ps = n;
     }
 
   return (*ps)->types + tindex;
 }
 
 /* Find a type given a type number.  If the type has not been
    allocated yet, create an indirect type.  */
@@ -3462,40 +3470,40 @@ static debug_type
 stab_find_type (void *dhandle, struct stab_handle *info, const int *typenums)
 {
   debug_type *slot;
 
   if (typenums[0] == 0 && typenums[1] < 0)
     {
       /* A negative type number indicates an XCOFF builtin type.  */
       return stab_xcoff_builtin_type (dhandle, info, typenums[1]);
     }
 
-  slot = stab_find_slot (info, typenums);
+  slot = stab_find_slot (dhandle, info, typenums);
   if (slot == NULL)
     return DEBUG_TYPE_NULL;
 
   if (*slot == DEBUG_TYPE_NULL)
     return debug_make_indirect_type (dhandle, slot, (const char *) NULL);
 
   return *slot;
 }
 
 /* Record that a given type number refers to a given type.  */
 
 static bool
-stab_record_type (void *dhandle ATTRIBUTE_UNUSED, struct stab_handle *info,
+stab_record_type (void *dhandle, struct stab_handle *info,
 		  const int *typenums, debug_type type)
 {
   debug_type *slot;
 
-  slot = stab_find_slot (info, typenums);
+  slot = stab_find_slot (dhandle, info, typenums);
   if (slot == NULL)
     return false;
 
   /* gdb appears to ignore type redefinitions, so we do as well.  */
 
   *slot = type;
 
   return true;
 }
 
 /* Return an XCOFF builtin type.  */
@@ -3681,61 +3689,56 @@ static debug_type
 stab_find_tagged_type (void *dhandle, struct stab_handle *info,
 		       const char *p, int len, enum debug_type_kind kind)
 {
   char *name;
   debug_type dtype;
   struct stab_tag *st;
 
-  name = savestring (p, len);
+  name = savestring (dhandle, p, len);
 
   /* We pass DEBUG_KIND_ILLEGAL because we want all tags in the same
      namespace.  This is right for C, and I don't know how to handle
      other languages.  FIXME.  */
   dtype = debug_find_tagged_type (dhandle, name, DEBUG_KIND_ILLEGAL);
   if (dtype != DEBUG_TYPE_NULL)
-    {
-      free (name);
-      return dtype;
-    }
+    return dtype;
 
   /* We need to allocate an entry on the undefined tag list.  */
   for (st = info->tags; st != NULL; st = st->next)
     {
       if (st->name[0] == name[0]
 	  && strcmp (st->name, name) == 0)
 	{
 	  if (st->kind == DEBUG_KIND_ILLEGAL)
 	    st->kind = kind;
-	  free (name);
 	  break;
 	}
     }
   if (st == NULL)
     {
-      st = (struct stab_tag *) xmalloc (sizeof *st);
-      memset (st, 0, sizeof *st);
+      st = debug_xzalloc (dhandle, sizeof (*st));
 
       st->next = info->tags;
       st->name = name;
       st->kind = kind;
       st->slot = DEBUG_TYPE_NULL;
       st->type = debug_make_indirect_type (dhandle, &st->slot, name);
       info->tags = st;
     }
 
   return st->type;
 }
 
 /* In order to get the correct argument types for a stubbed method, we
    need to extract the argument types from a C++ mangled string.
    Since the argument types can refer back to the return type, this
    means that we must demangle the entire physical name.  In gdb this
    is done by calling cplus_demangle and running the results back
    through the C++ expression parser.  Since we have no expression
    parser, we must duplicate much of the work of cplus_demangle here.
 
    We assume that GNU style demangling is used, since this is only
    done for method stubs, and only g++ should output that form of
    debugging information.  */
 
 /* This structure is used to hold a pointer to type information which
    demangling a string.  */
@@ -3863,47 +3866,45 @@ static debug_type *
 stab_demangle_argtypes (void *dhandle, struct stab_handle *info,
 			const char *physname, bool *pvarargs,
 			unsigned int physname_len)
 {
   struct stab_demangle_info minfo;
 
   /* Check for the g++ V3 ABI.  */
   if (physname[0] == '_' && physname[1] == 'Z')
     return stab_demangle_v3_argtypes (dhandle, info, physname, pvarargs);
 
   minfo.dhandle = dhandle;
   minfo.info = info;
   minfo.args = NULL;
   minfo.varargs = false;
   minfo.typestring_alloc = 10;
-  minfo.typestrings = ((struct stab_demangle_typestring *)
-		       xmalloc (minfo.typestring_alloc
-				* sizeof *minfo.typestrings));
+  minfo.typestrings
+    = xmalloc (minfo.typestring_alloc * sizeof (*minfo.typestrings));
   minfo.typestring_count = 0;
 
   /* cplus_demangle checks for special GNU mangled forms, but we can't
      see any of them in mangled method argument types.  */
 
   if (! stab_demangle_prefix (&minfo, &physname, physname_len))
     goto error_return;
 
   if (*physname != '\0')
     {
       if (! stab_demangle_signature (&minfo, &physname))
 	goto error_return;
     }
 
   free (minfo.typestrings);
-  minfo.typestrings = NULL;
 
   if (minfo.args == NULL)
     fprintf (stderr, _("no argument types in mangled string\n"));
 
   *pvarargs = minfo.varargs;
   return minfo.args;
 
  error_return:
   free (minfo.typestrings);
   return NULL;
 }
 
 /* Demangle the prefix of the mangled name.  */
@@ -4147,172 +4148,165 @@ static bool
 stab_demangle_qualified (struct stab_demangle_info *minfo, const char **pp,
 			 debug_type *ptype)
 {
   const char *orig;
   const char *p;
   unsigned int qualifiers;
   debug_type context;
 
   orig = *pp;
 
   switch ((*pp)[1])
     {
     case '_':
       /* GNU mangled name with more than 9 classes.  The count is
 	 preceded by an underscore (to distinguish it from the <= 9
 	 case) and followed by an underscore.  */
       p = *pp + 2;
       if (! ISDIGIT (*p) || *p == '0')
 	{
 	  stab_bad_demangle (orig);
 	  return false;
 	}
       qualifiers = atoi (p);
       while (ISDIGIT (*p))
 	++p;
       if (*p != '_')
 	{
 	  stab_bad_demangle (orig);
 	  return false;
 	}
       *pp = p + 1;
       break;
 
     case '1': case '2': case '3': case '4': case '5':
     case '6': case '7': case '8': case '9':
       qualifiers = (*pp)[1] - '0';
       /* Skip an optional underscore after the count.  */
       if ((*pp)[2] == '_')
 	++*pp;
       *pp += 2;
       break;
 
     case '0':
     default:
       stab_bad_demangle (orig);
       return false;
     }
 
   context = DEBUG_TYPE_NULL;
 
   /* Pick off the names.  */
   while (qualifiers-- > 0)
     {
       if (**pp == '_')
 	++*pp;
       if (**pp == 't')
 	{
 	  char *name;
 
 	  if (! stab_demangle_template (minfo, pp,
 					ptype != NULL ? &name : NULL))
 	    return false;
 
 	  if (ptype != NULL)
 	    {
 	      context = stab_find_tagged_type (minfo->dhandle, minfo->info,
 					       name, strlen (name),
 					       DEBUG_KIND_CLASS);
-	      free (name);
 	      if (context == DEBUG_TYPE_NULL)
 		return false;
 	    }
 	}
       else
 	{
 	  unsigned int len;
 
 	  len = stab_demangle_count (pp);
 	  if (strlen (*pp) < len)
 	    {
 	      stab_bad_demangle (orig);
 	      return false;
 	    }
 
 	  if (ptype != NULL)
 	    {
 	      const debug_field *fields;
 
 	      fields = NULL;
 	      if (context != DEBUG_TYPE_NULL)
 		fields = debug_get_fields (minfo->dhandle, context);
 
 	      context = DEBUG_TYPE_NULL;
 
 	      if (fields != NULL)
 		{
 		  char *name;
 
 		  /* Try to find the type by looking through the
                      fields of context until we find a field with the
                      same type.  This ought to work for a class
                      defined within a class, but it won't work for,
                      e.g., an enum defined within a class.  stabs does
                      not give us enough information to figure out the
                      latter case.  */
 
-		  name = savestring (*pp, len);
+		  name = savestring (minfo->dhandle, *pp, len);
 
 		  for (; *fields != DEBUG_FIELD_NULL; fields++)
 		    {
 		      debug_type ft;
 		      const char *dn;
 
 		      ft = debug_get_field_type (minfo->dhandle, *fields);
 		      if (ft == NULL)
-			{
-			  free (name);
-			  return false;
-			}
+			return false;
 		      dn = debug_get_type_name (minfo->dhandle, ft);
 		      if (dn != NULL && strcmp (dn, name) == 0)
 			{
 			  context = ft;
 			  break;
 			}
 		    }
-
-		  free (name);
 		}
 
 	      if (context == DEBUG_TYPE_NULL)
 		{
 		  /* We have to fall back on finding the type by name.
                      If there are more types to come, then this must
                      be a class.  Otherwise, it could be anything.  */
 
 		  if (qualifiers == 0)
 		    {
 		      char *name;
 
-		      name = savestring (*pp, len);
+		      name = savestring (minfo->dhandle, *pp, len);
 		      context = debug_find_named_type (minfo->dhandle,
 						       name);
-		      free (name);
 		    }
 
 		  if (context == DEBUG_TYPE_NULL)
 		    {
 		      context = stab_find_tagged_type (minfo->dhandle,
 						       minfo->info,
 						       *pp, len,
 						       (qualifiers == 0
 							? DEBUG_KIND_ILLEGAL
 							: DEBUG_KIND_CLASS));
 		      if (context == DEBUG_TYPE_NULL)
 			return false;
 		    }
 		}
 	    }
 
 	  *pp += len;
 	}
     }
 
   if (ptype != NULL)
     *ptype = context;
 
   return true;
 }
 
 /* Demangle a template.  If PNAME is not NULL, this sets *PNAME to a
    string representation of the template.  */
@@ -4321,219 +4315,217 @@ static bool
 stab_demangle_template (struct stab_demangle_info *minfo, const char **pp,
 			char **pname)
 {
   const char *orig;
   unsigned int r, i;
 
   orig = *pp;
 
   ++*pp;
 
   /* Skip the template name.  */
   r = stab_demangle_count (pp);
   if (r == 0 || strlen (*pp) < r)
     {
       stab_bad_demangle (orig);
       return false;
     }
   *pp += r;
 
   /* Get the size of the parameter list.  */
   if (stab_demangle_get_count (pp, &r) == 0)
     {
       stab_bad_demangle (orig);
       return false;
     }
 
   for (i = 0; i < r; i++)
     {
       if (**pp == 'Z')
 	{
 	  /* This is a type parameter.  */
 	  ++*pp;
 	  if (! stab_demangle_type (minfo, pp, (debug_type *) NULL))
 	    return false;
 	}
       else
 	{
 	  const char *old_p;
 	  bool pointerp, realp, integralp, charp, boolp;
 	  bool done;
 
 	  old_p = *pp;
 	  pointerp = false;
 	  realp = false;
 	  integralp = false;
 	  charp = false;
 	  boolp = false;
 	  done = false;
 
 	  /* This is a value parameter.  */
 
 	  if (! stab_demangle_type (minfo, pp, (debug_type *) NULL))
 	    return false;
 
 	  while (*old_p != '\0' && ! done)
 	    {
 	      switch (*old_p)
 		{
 		case 'P':
 		case 'p':
 		case 'R':
 		  pointerp = true;
 		  done = true;
 		  break;
 		case 'C':	/* Const.  */
 		case 'S':	/* Signed.  */
 		case 'U':	/* Unsigned.  */
 		case 'V':	/* Volatile.  */
 		case 'F':	/* Function.  */
 		case 'M':	/* Member function.  */
 		case 'O':	/* ??? */
 		  ++old_p;
 		  break;
 		case 'Q':	/* Qualified name.  */
 		  integralp = true;
 		  done = true;
 		  break;
 		case 'T':	/* Remembered type.  */
 		  abort ();
 		case 'v':	/* Void.  */
 		  abort ();
 		case 'x':	/* Long long.  */
 		case 'l':	/* Long.  */
 		case 'i':	/* Int.  */
 		case 's':	/* Short.  */
 		case 'w':	/* Wchar_t.  */
 		  integralp = true;
 		  done = true;
 		  break;
 		case 'b':	/* Bool.  */
 		  boolp = true;
 		  done = true;
 		  break;
 		case 'c':	/* Char.  */
 		  charp = true;
 		  done = true;
 		  break;
 		case 'r':	/* Long double.  */
 		case 'd':	/* Double.  */
 		case 'f':	/* Float.  */
 		  realp = true;
 		  done = true;
 		  break;
 		default:
 		  /* Assume it's a user defined integral type.  */
 		  integralp = true;
 		  done = true;
 		  break;
 		}
 	    }
 
 	  if (integralp)
 	    {
 	      if (**pp == 'm')
 		++*pp;
 	      while (ISDIGIT (**pp))
 		++*pp;
 	    }
 	  else if (charp)
 	    {
 	      unsigned int val;
 
 	      if (**pp == 'm')
 		++*pp;
 	      val = stab_demangle_count (pp);
 	      if (val == 0)
 		{
 		  stab_bad_demangle (orig);
 		  return false;
 		}
 	    }
 	  else if (boolp)
 	    {
 	      unsigned int val;
 
 	      val = stab_demangle_count (pp);
 	      if (val != 0 && val != 1)
 		{
 		  stab_bad_demangle (orig);
 		  return false;
 		}
 	    }
 	  else if (realp)
 	    {
 	      if (**pp == 'm')
 		++*pp;
 	      while (ISDIGIT (**pp))
 		++*pp;
 	      if (**pp == '.')
 		{
 		  ++*pp;
 		  while (ISDIGIT (**pp))
 		    ++*pp;
 		}
 	      if (**pp == 'e')
 		{
 		  ++*pp;
 		  while (ISDIGIT (**pp))
 		    ++*pp;
 		}
 	    }
 	  else if (pointerp)
 	    {
 	      unsigned int len;
 
 	      len = stab_demangle_count (pp);
 	      if (len == 0)
 		{
 		  stab_bad_demangle (orig);
 		  return false;
 		}
 	      *pp += len;
 	    }
 	}
     }
 
   /* We can translate this to a string fairly easily by invoking the
      regular demangling routine.  */
   if (pname != NULL)
     {
       char *s1, *s2, *s3, *s4 = NULL;
       char *from, *to;
 
-      s1 = savestring (orig, *pp - orig);
+      s1 = savestring (minfo->dhandle, orig, *pp - orig);
 
       s2 = concat ("NoSuchStrinG__", s1, (const char *) NULL);
 
-      free (s1);
-
       s3 = cplus_demangle (s2, demangle_flags);
 
       free (s2);
 
       if (s3 != NULL)
 	s4 = strstr (s3, "::NoSuchStrinG");
       if (s3 == NULL || s4 == NULL)
 	{
 	  stab_bad_demangle (orig);
 	  free (s3);
 	  return false;
 	}
 
       /* Eliminating all spaces, except those between > characters,
          makes it more likely that the demangled name will match the
          name which g++ used as the structure name.  */
       for (from = to = s3; from != s4; ++from)
 	if (*from != ' '
 	    || (from[1] == '>' && from > s3 && from[-1] == '>'))
 	  *to++ = *from;
 
-      *pname = savestring (s3, to - s3);
+      *pname = savestring (minfo->dhandle, s3, to - s3);
 
       free (s3);
     }
 
   return true;
 }
 
 /* Demangle a class name.  */
@@ -4569,78 +4561,83 @@ static bool
 stab_demangle_args (struct stab_demangle_info *minfo, const char **pp,
 		    debug_type **pargs, bool *pvarargs)
 {
   const char *orig;
   unsigned int alloc, count;
 
   orig = *pp;
 
   alloc = 10;
   if (pargs != NULL)
-    {
-      *pargs = (debug_type *) xmalloc (alloc * sizeof **pargs);
-      *pvarargs = false;
-    }
+    *pargs = xmalloc (alloc * sizeof (**pargs));
+  if (pvarargs != NULL)
+    *pvarargs = false;
   count = 0;
 
   while (**pp != '_' && **pp != '\0' && **pp != 'e')
     {
       if (**pp == 'N' || **pp == 'T')
 	{
 	  char temptype;
 	  unsigned int r, t;
 
 	  temptype = **pp;
 	  ++*pp;
 
 	  if (temptype == 'T')
 	    r = 1;
 	  else
 	    {
 	      if (! stab_demangle_get_count (pp, &r))
-		{
-		  stab_bad_demangle (orig);
-		  return false;
-		}
+		goto bad;
 	    }
 
-	  if (! stab_demangle_get_count (pp, &t))
-	    {
-	      stab_bad_demangle (orig);
-	      return false;
-	    }
+	  if (!stab_demangle_get_count (pp, &t)
+	      || t >= minfo->typestring_count)
+	    goto bad;
 
-	  if (t >= minfo->typestring_count)
-	    {
-	      stab_bad_demangle (orig);
-	      return false;
-	    }
 	  while (r-- > 0)
 	    {
 	      const char *tem;
 
 	      tem = minfo->typestrings[t].typestring;
 	      if (! stab_demangle_arg (minfo, &tem, pargs, &count, &alloc))
-		return false;
+		goto fail;
 	    }
 	}
       else
 	{
 	  if (! stab_demangle_arg (minfo, pp, pargs, &count, &alloc))
-	    return false;
+	    goto fail;
 	}
     }
 
   if (pargs != NULL)
-    (*pargs)[count] = DEBUG_TYPE_NULL;
+    {
+      debug_type *xargs;
+      (*pargs)[count] = DEBUG_TYPE_NULL;
+       xargs = debug_xalloc (minfo->dhandle, (count + 1) * sizeof (*xargs));
+       memcpy (xargs, *pargs, (count + 1) * sizeof (*xargs));
+       free (*pargs);
+       *pargs = xargs;
+    }
 
   if (**pp == 'e')
     {
-      if (pargs != NULL)
+      if (pvarargs != NULL)
 	*pvarargs = true;
       ++*pp;
     }
-
   return true;
+
+ bad:
+  stab_bad_demangle (orig);
+ fail:
+  if (pargs != NULL)
+    {
+      free (*pargs);
+      *pargs = NULL;
+    }
+  return false;
 }
 
 /* Demangle a single argument.  */
@@ -4649,33 +4646,32 @@ static bool
 stab_demangle_arg (struct stab_demangle_info *minfo, const char **pp,
 		   debug_type **pargs, unsigned int *pcount,
 		   unsigned int *palloc)
 {
   const char *start;
   debug_type type;
 
   start = *pp;
   if (! stab_demangle_type (minfo, pp,
 			    pargs == NULL ? (debug_type *) NULL : &type)
       || ! stab_demangle_remember_type (minfo, start, *pp - start))
     return false;
 
   if (pargs != NULL)
     {
       if (type == DEBUG_TYPE_NULL)
 	return false;
 
       if (*pcount + 1 >= *palloc)
 	{
 	  *palloc += 10;
-	  *pargs = ((debug_type *)
-		    xrealloc (*pargs, *palloc * sizeof **pargs));
+	  *pargs = xrealloc (*pargs, *palloc * sizeof (**pargs));
 	}
       (*pargs)[*pcount] = type;
       ++*pcount;
     }
 
   return true;
 }
 
 /* Demangle a type.  If the ptype argument is not NULL, *ptype is set
    to the newly allocated type.  */
@@ -4944,252 +4940,250 @@ static bool
 stab_demangle_fund_type (struct stab_demangle_info *minfo, const char **pp,
 			 debug_type *ptype)
 {
   const char *orig;
   bool constp, volatilep, unsignedp, signedp;
   bool done;
 
   orig = *pp;
 
   constp = false;
   volatilep = false;
   unsignedp = false;
   signedp = false;
 
   done = false;
   while (! done)
     {
       switch (**pp)
 	{
 	case 'C':
 	  constp = true;
 	  ++*pp;
 	  break;
 
 	case 'U':
 	  unsignedp = true;
 	  ++*pp;
 	  break;
 
 	case 'S':
 	  signedp = true;
 	  ++*pp;
 	  break;
 
 	case 'V':
 	  volatilep = true;
 	  ++*pp;
 	  break;
 
 	default:
 	  done = true;
 	  break;
 	}
     }
 
   switch (**pp)
     {
     case '\0':
     case '_':
       /* cplus_demangle permits this, but I don't know what it means.  */
       stab_bad_demangle (orig);
       break;
 
     case 'v': /* void */
       if (ptype != NULL)
 	{
 	  *ptype = debug_find_named_type (minfo->dhandle, "void");
 	  if (*ptype == DEBUG_TYPE_NULL)
 	    *ptype = debug_make_void_type (minfo->dhandle);
 	}
       ++*pp;
       break;
 
     case 'x': /* long long */
       if (ptype != NULL)
 	{
 	  *ptype = debug_find_named_type (minfo->dhandle,
 					  (unsignedp
 					   ? "long long unsigned int"
 					   : "long long int"));
 	  if (*ptype == DEBUG_TYPE_NULL)
 	    *ptype = debug_make_int_type (minfo->dhandle, 8, unsignedp);
 	}
       ++*pp;
       break;
 
     case 'l': /* long */
       if (ptype != NULL)
 	{
 	  *ptype = debug_find_named_type (minfo->dhandle,
 					  (unsignedp
 					   ? "long unsigned int"
 					   : "long int"));
 	  if (*ptype == DEBUG_TYPE_NULL)
 	    *ptype = debug_make_int_type (minfo->dhandle, 4, unsignedp);
 	}
       ++*pp;
       break;
 
     case 'i': /* int */
       if (ptype != NULL)
 	{
 	  *ptype = debug_find_named_type (minfo->dhandle,
 					  (unsignedp
 					   ? "unsigned int"
 					   : "int"));
 	  if (*ptype == DEBUG_TYPE_NULL)
 	    *ptype = debug_make_int_type (minfo->dhandle, 4, unsignedp);
 	}
       ++*pp;
       break;
 
     case 's': /* short */
       if (ptype != NULL)
 	{
 	  *ptype = debug_find_named_type (minfo->dhandle,
 					  (unsignedp
 					   ? "short unsigned int"
 					   : "short int"));
 	  if (*ptype == DEBUG_TYPE_NULL)
 	    *ptype = debug_make_int_type (minfo->dhandle, 2, unsignedp);
 	}
       ++*pp;
       break;
 
     case 'b': /* bool */
       if (ptype != NULL)
 	{
 	  *ptype = debug_find_named_type (minfo->dhandle, "bool");
 	  if (*ptype == DEBUG_TYPE_NULL)
 	    *ptype = debug_make_bool_type (minfo->dhandle, 4);
 	}
       ++*pp;
       break;
 
     case 'c': /* char */
       if (ptype != NULL)
 	{
 	  *ptype = debug_find_named_type (minfo->dhandle,
 					  (unsignedp
 					   ? "unsigned char"
 					   : (signedp
 					      ? "signed char"
 					      : "char")));
 	  if (*ptype == DEBUG_TYPE_NULL)
 	    *ptype = debug_make_int_type (minfo->dhandle, 1, unsignedp);
 	}
       ++*pp;
       break;
 
     case 'w': /* wchar_t */
       if (ptype != NULL)
 	{
 	  *ptype = debug_find_named_type (minfo->dhandle, "__wchar_t");
 	  if (*ptype == DEBUG_TYPE_NULL)
 	    *ptype = debug_make_int_type (minfo->dhandle, 2, true);
 	}
       ++*pp;
       break;
 
     case 'r': /* long double */
       if (ptype != NULL)
 	{
 	  *ptype = debug_find_named_type (minfo->dhandle, "long double");
 	  if (*ptype == DEBUG_TYPE_NULL)
 	    *ptype = debug_make_float_type (minfo->dhandle, 8);
 	}
       ++*pp;
       break;
 
     case 'd': /* double */
       if (ptype != NULL)
 	{
 	  *ptype = debug_find_named_type (minfo->dhandle, "double");
 	  if (*ptype == DEBUG_TYPE_NULL)
 	    *ptype = debug_make_float_type (minfo->dhandle, 8);
 	}
       ++*pp;
       break;
 
     case 'f': /* float */
       if (ptype != NULL)
 	{
 	  *ptype = debug_find_named_type (minfo->dhandle, "float");
 	  if (*ptype == DEBUG_TYPE_NULL)
 	    *ptype = debug_make_float_type (minfo->dhandle, 4);
 	}
       ++*pp;
       break;
 
     case 'G':
       ++*pp;
       if (! ISDIGIT (**pp))
 	{
 	  stab_bad_demangle (orig);
 	  return false;
 	}
       /* Fall through.  */
     case '0': case '1': case '2': case '3': case '4':
     case '5': case '6': case '7': case '8': case '9':
       {
 	const char *hold;
 
 	if (! stab_demangle_class (minfo, pp, &hold))
 	  return false;
 	if (ptype != NULL)
 	  {
 	    char *name;
 
-	    name = savestring (hold, *pp - hold);
+	    name = savestring (minfo->dhandle, hold, *pp - hold);
 	    *ptype = debug_find_named_type (minfo->dhandle, name);
-	    free (name);
 	    if (*ptype == DEBUG_TYPE_NULL)
 	      {
 		/* FIXME: It is probably incorrect to assume that
                    undefined types are tagged types.  */
 		*ptype = stab_find_tagged_type (minfo->dhandle, minfo->info,
 						hold, *pp - hold,
 						DEBUG_KIND_ILLEGAL);
 		if (*ptype == DEBUG_TYPE_NULL)
 		  return false;
 	      }
 	  }
       }
       break;
 
     case 't':
       {
 	char *name;
 
 	if (! stab_demangle_template (minfo, pp,
 				      ptype != NULL ? &name : NULL))
 	  return false;
 	if (ptype != NULL)
 	  {
 	    *ptype = stab_find_tagged_type (minfo->dhandle, minfo->info,
 					    name, strlen (name),
 					    DEBUG_KIND_CLASS);
-	    free (name);
 	    if (*ptype == DEBUG_TYPE_NULL)
 	      return false;
 	  }
       }
       break;
 
     default:
       stab_bad_demangle (orig);
       return false;
     }
 
   if (ptype != NULL)
     {
       if (constp)
 	*ptype = debug_make_const_type (minfo->dhandle, *ptype);
       if (volatilep)
 	*ptype = debug_make_volatile_type (minfo->dhandle, *ptype);
     }
 
   return true;
 }
 
 /* Remember a type string in a demangled string.  */
@@ -5198,28 +5192,27 @@ static bool
 stab_demangle_remember_type (struct stab_demangle_info *minfo,
 			     const char *p, int len)
 {
   if (minfo->typestring_count >= minfo->typestring_alloc)
     {
       minfo->typestring_alloc += 10;
-      minfo->typestrings = ((struct stab_demangle_typestring *)
-			    xrealloc (minfo->typestrings,
-				      (minfo->typestring_alloc
-				       * sizeof *minfo->typestrings)));
+      minfo->typestrings
+	= xrealloc (minfo->typestrings,
+		    minfo->typestring_alloc * sizeof (*minfo->typestrings));
     }
 
   minfo->typestrings[minfo->typestring_count].typestring = p;
   minfo->typestrings[minfo->typestring_count].len = (unsigned int) len;
   ++minfo->typestring_count;
 
   return true;
 }
 
 /* Demangle names encoded using the g++ V3 ABI.  The newer versions of
    g++ which use this ABI do not encode ordinary method argument types
    in a mangled name; they simply output the argument types.  However,
    for a static method, g++ simply outputs the return type and the
    physical name.  So in that case we need to demangle the name here.
    Here PHYSNAME is the physical name of the function, and we set the
    variable pointed at by PVARARGS to indicate whether this function
    is varargs.  This returns NULL, or a NULL terminated array of
    argument types.  */
@@ -5266,63 +5259,66 @@ static debug_type *
 stab_demangle_v3_arglist (void *dhandle, struct stab_handle *info,
 			  struct demangle_component *arglist,
 			  bool *pvarargs)
 {
   struct demangle_component *dc;
   unsigned int alloc, count;
-  debug_type *pargs;
+  debug_type *pargs, *xargs;
 
   alloc = 10;
-  pargs = (debug_type *) xmalloc (alloc * sizeof *pargs);
+  pargs = xmalloc (alloc * sizeof (*pargs));
   *pvarargs = false;
 
   count = 0;
 
   for (dc = arglist;
        dc != NULL;
        dc = dc->u.s_binary.right)
     {
       debug_type arg;
       bool varargs;
 
       if (dc->type != DEMANGLE_COMPONENT_ARGLIST)
 	{
 	  fprintf (stderr, _("Unexpected type in v3 arglist demangling\n"));
 	  free (pargs);
 	  return NULL;
 	}
 
       /* PR 13925: Cope if the demangler returns an empty
 	 context for a function with no arguments.  */
       if (dc->u.s_binary.left == NULL)
 	break;
 
       arg = stab_demangle_v3_arg (dhandle, info, dc->u.s_binary.left,
 				  NULL, &varargs);
       if (arg == NULL)
 	{
 	  if (varargs)
 	    {
 	      *pvarargs = true;
 	      continue;
 	    }
 	  free (pargs);
 	  return NULL;
 	}
 
       if (count + 1 >= alloc)
 	{
 	  alloc += 10;
-	  pargs = (debug_type *) xrealloc (pargs, alloc * sizeof *pargs);
+	  pargs = xrealloc (pargs, alloc * sizeof (*pargs));
 	}
 
       pargs[count] = arg;
       ++count;
     }
 
   pargs[count] = DEBUG_TYPE_NULL;
+  xargs = debug_xalloc (dhandle, (count + 1) * sizeof (*pargs));
+  memcpy (xargs, pargs, (count + 1) * sizeof (*pargs));
+  free (pargs);
 
-  return pargs;
+  return xargs;
 }
 
 /* Convert a struct demangle_component tree describing an argument
    type into a debug_type.  */
@@ -5331,231 +5327,228 @@ static debug_type
 stab_demangle_v3_arg (void *dhandle, struct stab_handle *info,
 		      struct demangle_component *dc, debug_type context,
 		      bool *pvarargs)
 {
   debug_type dt;
 
   if (pvarargs != NULL)
     *pvarargs = false;
 
   switch (dc->type)
     {
       /* FIXME: These are demangle component types which we probably
 	 need to handle one way or another.  */
     case DEMANGLE_COMPONENT_LOCAL_NAME:
     case DEMANGLE_COMPONENT_TYPED_NAME:
     case DEMANGLE_COMPONENT_TEMPLATE_PARAM:
     case DEMANGLE_COMPONENT_CTOR:
     case DEMANGLE_COMPONENT_DTOR:
     case DEMANGLE_COMPONENT_JAVA_CLASS:
     case DEMANGLE_COMPONENT_RESTRICT_THIS:
     case DEMANGLE_COMPONENT_VOLATILE_THIS:
     case DEMANGLE_COMPONENT_CONST_THIS:
     case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:
     case DEMANGLE_COMPONENT_COMPLEX:
     case DEMANGLE_COMPONENT_IMAGINARY:
     case DEMANGLE_COMPONENT_VENDOR_TYPE:
     case DEMANGLE_COMPONENT_ARRAY_TYPE:
     case DEMANGLE_COMPONENT_PTRMEM_TYPE:
     case DEMANGLE_COMPONENT_ARGLIST:
     default:
       fprintf (stderr, _("Unrecognized demangle component %d\n"),
 	       (int) dc->type);
       return NULL;
 
     case DEMANGLE_COMPONENT_NAME:
       if (context != NULL)
 	{
 	  const debug_field *fields;
 
 	  fields = debug_get_fields (dhandle, context);
 	  if (fields != NULL)
 	    {
 	      /* Try to find this type by looking through the context
 		 class.  */
 	      for (; *fields != DEBUG_FIELD_NULL; fields++)
 		{
 		  debug_type ft;
 		  const char *dn;
 
 		  ft = debug_get_field_type (dhandle, *fields);
 		  if (ft == NULL)
 		    return NULL;
 		  dn = debug_get_type_name (dhandle, ft);
 		  if (dn != NULL
 		      && (int) strlen (dn) == dc->u.s_name.len
 		      && strncmp (dn, dc->u.s_name.s, dc->u.s_name.len) == 0)
 		    return ft;
 		}
 	    }
 	}
       return stab_find_tagged_type (dhandle, info, dc->u.s_name.s,
 				    dc->u.s_name.len, DEBUG_KIND_ILLEGAL);
 
     case DEMANGLE_COMPONENT_QUAL_NAME:
       context = stab_demangle_v3_arg (dhandle, info, dc->u.s_binary.left,
 				      context, NULL);
       if (context == NULL)
 	return NULL;
       return stab_demangle_v3_arg (dhandle, info, dc->u.s_binary.right,
 				   context, NULL);
 
     case DEMANGLE_COMPONENT_TEMPLATE:
       {
 	char *p;
 	size_t alc;
 
 	/* We print this component to get a class name which we can
 	   use.  FIXME: This probably won't work if the template uses
 	   template parameters which refer to an outer template.  */
 	p = cplus_demangle_print (DMGL_PARAMS | demangle_flags, dc, 20, &alc);
 	if (p == NULL)
 	  {
 	    fprintf (stderr, _("Failed to print demangled template\n"));
 	    return NULL;
 	  }
 	dt = stab_find_tagged_type (dhandle, info, p, strlen (p),
 				    DEBUG_KIND_CLASS);
 	free (p);
 	return dt;
       }
 
     case DEMANGLE_COMPONENT_SUB_STD:
       return stab_find_tagged_type (dhandle, info, dc->u.s_string.string,
 				    dc->u.s_string.len, DEBUG_KIND_ILLEGAL);
 
     case DEMANGLE_COMPONENT_RESTRICT:
     case DEMANGLE_COMPONENT_VOLATILE:
     case DEMANGLE_COMPONENT_CONST:
     case DEMANGLE_COMPONENT_POINTER:
     case DEMANGLE_COMPONENT_REFERENCE:
       dt = stab_demangle_v3_arg (dhandle, info, dc->u.s_binary.left, NULL,
 				 NULL);
       if (dt == NULL)
 	return NULL;
 
       switch (dc->type)
 	{
 	default:
 	  abort ();
 	case DEMANGLE_COMPONENT_RESTRICT:
 	  /* FIXME: We have no way to represent restrict.  */
 	  return dt;
 	case DEMANGLE_COMPONENT_VOLATILE:
 	  return debug_make_volatile_type (dhandle, dt);
 	case DEMANGLE_COMPONENT_CONST:
 	  return debug_make_const_type (dhandle, dt);
 	case DEMANGLE_COMPONENT_POINTER:
 	  return debug_make_pointer_type (dhandle, dt);
 	case DEMANGLE_COMPONENT_REFERENCE:
 	  return debug_make_reference_type (dhandle, dt);
 	}
 
     case DEMANGLE_COMPONENT_FUNCTION_TYPE:
       {
 	debug_type *pargs;
 	bool varargs;
 
 	if (dc->u.s_binary.left == NULL)
 	  {
 	    /* In this case the return type is actually unknown.
 	       However, I'm not sure this will ever arise in practice;
 	       normally an unknown return type would only appear at
 	       the top level, which is handled above.  */
 	    dt = debug_make_void_type (dhandle);
 	  }
 	else
 	  dt = stab_demangle_v3_arg (dhandle, info, dc->u.s_binary.left, NULL,
 				     NULL);
 	if (dt == NULL)
 	  return NULL;
 
 	pargs = stab_demangle_v3_arglist (dhandle, info,
 					  dc->u.s_binary.right,
 					  &varargs);
 	if (pargs == NULL)
-	  {
-	    free (dt);
-	    return NULL;
-	  }
+	  return NULL;
 
 	return debug_make_function_type (dhandle, dt, pargs, varargs);
       }
 
     case DEMANGLE_COMPONENT_BUILTIN_TYPE:
       {
 	char *p;
 	size_t alc;
 	debug_type ret;
 
 	/* We print this component in order to find out the type name.
 	   FIXME: Should we instead expose the
 	   demangle_builtin_type_info structure?  */
 	p = cplus_demangle_print (DMGL_PARAMS | demangle_flags, dc, 20, &alc);
 	if (p == NULL)
 	  {
 	    fprintf (stderr, _("Couldn't get demangled builtin type\n"));
 	    return NULL;
 	  }
 
 	/* The mangling is based on the type, but does not itself
 	   indicate what the sizes are.  So we have to guess.  */
 	if (strcmp (p, "signed char") == 0)
 	  ret = debug_make_int_type (dhandle, 1, false);
 	else if (strcmp (p, "bool") == 0)
 	  ret = debug_make_bool_type (dhandle, 1);
 	else if (strcmp (p, "char") == 0)
 	  ret = debug_make_int_type (dhandle, 1, false);
 	else if (strcmp (p, "double") == 0)
 	  ret = debug_make_float_type (dhandle, 8);
 	else if (strcmp (p, "long double") == 0)
 	  ret = debug_make_float_type (dhandle, 8);
 	else if (strcmp (p, "float") == 0)
 	  ret = debug_make_float_type (dhandle, 4);
 	else if (strcmp (p, "__float128") == 0)
 	  ret = debug_make_float_type (dhandle, 16);
 	else if (strcmp (p, "unsigned char") == 0)
 	  ret = debug_make_int_type (dhandle, 1, true);
 	else if (strcmp (p, "int") == 0)
 	  ret = debug_make_int_type (dhandle, 4, false);
 	else if (strcmp (p, "unsigned int") == 0)
 	  ret = debug_make_int_type (dhandle, 4, true);
 	else if (strcmp (p, "long") == 0)
 	  ret = debug_make_int_type (dhandle, 4, false);
 	else if (strcmp (p, "unsigned long") == 0)
 	  ret = debug_make_int_type (dhandle, 4, true);
 	else if (strcmp (p, "__int128") == 0)
 	  ret = debug_make_int_type (dhandle, 16, false);
 	else if (strcmp (p, "unsigned __int128") == 0)
 	  ret = debug_make_int_type (dhandle, 16, true);
 	else if (strcmp (p, "short") == 0)
 	  ret = debug_make_int_type (dhandle, 2, false);
 	else if (strcmp (p, "unsigned short") == 0)
 	  ret = debug_make_int_type (dhandle, 2, true);
 	else if (strcmp (p, "void") == 0)
 	  ret = debug_make_void_type (dhandle);
 	else if (strcmp (p, "wchar_t") == 0)
 	  ret = debug_make_int_type (dhandle, 4, true);
 	else if (strcmp (p, "long long") == 0)
 	  ret = debug_make_int_type (dhandle, 8, false);
 	else if (strcmp (p, "unsigned long long") == 0)
 	  ret = debug_make_int_type (dhandle, 8, true);
 	else if (strcmp (p, "...") == 0)
 	  {
 	    if (pvarargs == NULL)
 	      fprintf (stderr, _("Unexpected demangled varargs\n"));
 	    else
 	      *pvarargs = true;
 	    ret = NULL;
 	  }
 	else
 	  {
 	    fprintf (stderr, _("Unrecognized demangled builtin type\n"));
 	    ret = NULL;
 	  }
 
 	free (p);
 
 	return ret;
       }
     }
 }
