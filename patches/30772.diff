commit 5a222cc79dc67ce01477da3a3ee10edf1076c655
Author: Aleix Alcacer <aleixalcacer@gmail.com>
Date:   Fri Feb 5 13:38:32 2021 +0100

    Implemented multiple variable-length metalayers

diff --git a/.gitignore b/.gitignore
index 1596d016..2a1181be 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,2 +1,4 @@
 bench/bench
 build/
+.idea
+cmake-build-*
diff --git a/CMakeLists.txt b/CMakeLists.txt
index bfce61e5..7930e5b1 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -121,6 +121,10 @@ option(PREFER_EXTERNAL_ZSTD
 
 set(CMAKE_MODULE_PATH "${PROJECT_SOURCE_DIR}/cmake")
 
+if (ENABLE_ASAN)
+    message(STATUS "Enabling ASAN")
+    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -g -Os -fno-omit-frame-pointer -fsanitize=address")
+endif()
 
 if(NOT DEACTIVATE_LZ4)
     if(PREFER_EXTERNAL_LZ4)
diff --git a/README_CFRAME_FORMAT.rst b/README_CFRAME_FORMAT.rst
index 68adc8cd..6ff24515 100644
--- a/README_CFRAME_FORMAT.rst
+++ b/README_CFRAME_FORMAT.rst
@@ -75,103 +75,107 @@ At the end of the header *metalayers* are stored which contain meta-information
 frame. It is up to the user to store whatever data they want with the only (strong) suggestion that they be stored
 using the msgpack format. Here is the format for the *metalayers*::
 
-  |-52|-53|-54|-55|-56|-----------------------
-  | 93| cd| idx   | de| map_of_metalayers
-  |---|---------------|-----------------------
-    ^   ^    ^      ^
-    |   |    |      |
-    |   |    |      +--[msgpack] map of name/offset pairs
-    |   |    +--size of the map
-    |   +--[msgpack] uint16
-    +-- [msgpack] fixarray with 3 elements
+    |-52|-53|-54|-55|-56|-57|-58|====================|---|---|---|================|
+    | 93| cd| idx   | de| size  | meta keys/values   | dc|  idy  | meta content   |
+    |---|---|-------|---|---|---|====================|---|-------|================|
+     ^   ^      ^     ^     ^             ^            ^     ^            ^
+     |   |      |     |     |             |            |     |            +-- [msgpack] bin32
+     |   |      |     |     |             |            |     +-- number of elements in the array
+     |   |      |     |     |             |            +-- [msgpack] array16
+     |   |      |     |     |             +-- [msgpack] fixstr/int32
+     |   |      |     |     +-- number of elements in the map
+     |   |      |     +-- [msgpack] map of name/offset pairs
+     |   |      +-- size of metalayers
+     |   +-- [msgpack] uint16
+     +-- [msgpack] fixarray with 3 elements
 
 :header_size:
     (``int32``) Size of the header of the frame (including metalayers).
 
 :frame_size:
     (``uint64``) Size of the whole frame (including compressed data).
 
 :general_flags:
     (``uint8``) General flags.
 
     :``0`` to ``3``:
         Format version.
     :``4`` and ``5``:
         Enumerated for chunk offsets.
 
         :``0``:
             32-bit
         :``1``:
             64-bit
         :``2``:
             128-bit
         :``3``:
             256-bit
     :``6``:
         Chunks of fixed length (0) or variable length (1)
     :``7``:
         Reserved
 
 :frame_type:
     (``uint8``) The type of frame.
 
     :``0`` to ``3``:
         Enumerated for the type of frame (up to 16).
 
         :``0``:
             ``Contiguous``
         :``1``:
             ``Sparse (directory)``
         :``2 to 15``:
             Reserved
 
     :``4`` to ``7``: Reserved for user-defined frame types (up to 16)
 
 :codec_flags:
     (``uint8``) Compressor enumeration (defaults for all the chunks in storage).
 
     :``0`` to ``3``:
         Enumerated for codecs (up to 16).
 
         :``0``:
             ``blosclz``
         :``1``:
             ``lz4`` or ``lz4hc``
         :``2``:
             ``snappy``
         :``3``:
             ``zlib``
         :``4``:
             ``zstd``
         :``5 to 15``:
             Reserved
     :``4`` to ``7``: Compression level (up to 16)
 
 :reserved_flags:
     (``uint8``) Space reserved.
 
 :uncompressed_size:
     (``int64``) Size of uncompressed data in frame (excluding metadata).
 
 :compressed_size:
     (``int64``) Size of compressed data in frame (excluding metadata).
 
 :type_size:
     (``int32``) Size of each item.
 
 :chunk_size:
     (``int32``) Size of each data chunk.  0 if not a fixed chunksize.
 
 :tcomp:
     (``int16``) Number of threads for compression.  If 0, same than `cctx`.
 
 :tdecomp:
     (``int16``) Number of threads for decompression.  If 0, same than `dctx`.
 
 :map of metalayers:
     This is a *msgpack-formattted* map for the different metalayers.  The keys will be a string (0xa0 + namelen) for
     the names of the metalayers, followed by an int32 (0xd2) for the *offset* of the value of this metalayer.  The
-    actual value will be encoded as a bin32 (0xc6) value later in frame.
+    actual value will be encoded as a bin32 (0xc6) value later in header.
 
 Chunks
 ------
@@ -229,33 +233,29 @@ Trailer
 The trailer for the frame is encoded via `msgpack <https://msgpack.org>`_ and contains a user meta data chunk and
 a fingerprint.::
 
-    |-0-|-1-|-2-|-3-|-4-|-5-|-6-|====================|---|---------------|---|---|=================|
-    | 9X| aX| c6| usermeta_len  |   usermeta_chunk   | ce| trailer_len   | d8|fpt| fingerprint     |
-    |---|---|---|---------------|====================|---|---------------|---|---|=================|
-      ^   ^   ^       ^                                ^       ^           ^   ^
-      |   |   |       |                                |       |           |   +-- fingerprint type
-      |   |   |       |                                |       |           +--[msgpack] fixext 16
-      |   |   |       |                                |       +-- trailer length (network endian)
-      |   |   |       |                                +--[msgpack] uint32 for trailer length
-      |   |   |       +--[msgpack] usermeta length (network endian)
+    |-0-|-1-|================|---|---------------|---|---|---------------|
+    | 9X| aX| vlmetalayers   | ce| trailer_len   | d8|fpt| fingerprint   |
+    |---|---|================|---|---------------|---|---|---------------|
+      ^   ^   ^    ^           ^       ^           ^   ^
+      |   |   |    |           |       |           |   +-- fingerprint type
+      |   |   |    |           |       |           +--[msgpack] fixext 16
+      |   |   |    |           |       +-- trailer length (network endian)
+      |   |   |    |           +--[msgpack] uint32 for trailer length
+      |   |   |    +--Variable-length metalayers (See header metalayers)
       |   |   +---[msgpack] bin32 for usermeta
       |   +------[msgpack] int8 for trailer version
       +---[msgpack] fixarray with X=4 elements
 
-The *usermeta* chunk which stores the user meta data can change in size during the lifetime of the frame.
-This is an important feature and the reason why the *usermeta* is stored in the trailer and not in the header.
+The *vlmetalayers* object which stores the variable-length user meta data can change in size during the lifetime of the frame.
+This is an important feature and the reason why the *vlmetalayers* are stored in the trailer and not in the header.
+However, the *vlmetalayers* follows the same format than the metalayers stored in the header.
 
-:usermeta_len:
-    (``int32``) The length of the usermeta chunk.
-
-:usermeta_chunk:
-    (``varlen``) The usermeta chunk (a Blosc chunk).
 
 :trailer_len:
     (``uint32``) Size of the trailer of the frame (including usermeta chunk).
 
 :fpt:
     (``int8``) Fingerprint type:  0 -> no fp; 1 -> 32-bit; 2 -> 64-bit; 3 -> 128-bit
 
 :fingerprint:
-    (``uint128``) Fix storage space for the fingerprint, padded to the left.
+    (``uint128``) Fix storage space for the fingerprint (16 bytes), padded to the left.
\ No newline at end of file
diff --git a/RELEASE_NOTES.md b/RELEASE_NOTES.md
index 16e04af5..f1c36f40 100644
--- a/RELEASE_NOTES.md
+++ b/RELEASE_NOTES.md
@@ -96,35 +96,35 @@ Changes from 2.0.0-beta.2 to 2.0.0-beta.3
 Changes from 2.0.0-beta.1 to 2.0.0-beta.2
 ========================================
 
-* A new `usermeta` chunk in `schunk` allows to store arbitrary meta-information
+* A new `vlmetalayers` chunk in `schunk` allows to store arbitrary meta-information
   that is up to the user.  If the `schunk` has an attached `frame`, the later
   will be updated accordingly too.  For more info, see PR #74 and docstrings of
-  new `blosc2_update_usermeta()` and `blosc2_get_usermeta()` functions.
+  new `blosc2_update_vlmetalayer()` and `blosc2_get_vlmetalayer()` functions.
 
 * Metalayers must now be attached to super-chunks, not frames.  The reason is
   that frames are increasingly treated as a storage specifier (in-memory or
   disk now, but can be other means in the future), whereas the actual API for
   I/O (including metainfo) goes into super-chunks.  See PR #75.
 
 * New frame format documented in
   [README_CFRAME_FORMAT.rst](README_CFRAME_FORMAT.rst). Remember that the frame
   format is not written in stone yet, so some changes may be introduced before
   getting out of beta.
 
 * BREAKING CHANGE: the format for frames has changed and
   BLOSC2_VERSION_FRAME_FORMAT is now set to 1.  There is no attempt to support
   previous formats, but there will probably be backward compatibility support
   starting from version 1 on.
 
 * BREAKING CHANGE: the next APIs have been renamed:
   + blosc2_frame_has_metalayer -> blosc2_has_metalayer
   + blosc2_frame_add_metalayer -> blosc2_add_metalayer
   + blosc2_frame_update_metalayer -> blosc2_update_metalayer
   + blosc2_frame_metalayer -> blosc2_get_metalayer
 
   Although the API was declared stable in beta.1, the fact that metalayers are
   attached now to super-chunks directly, made this change completely necessary.
 
 * BREAKING CHANGE: the next symbols have been renamed:
   + BLOSC_CPARAMS_DEFAULTS -> BLOSC2_CPARAMS_DEFAULTS
   + BLOSC_DPARAMS_DEFAULTS -> BLOSC2_DPARAMS_DEFAULTS
diff --git a/blosc/blosc2.h b/blosc/blosc2.h
index ca36722e..1d493383 100644
--- a/blosc/blosc2.h
+++ b/blosc/blosc2.h
@@ -248,39 +248,41 @@ enum {
 /**
  * @brief Error codes
  */
 enum {
   BLOSC2_ERROR_SUCCESS = 0,           //<! Success
   BLOSC2_ERROR_FAILURE = -1,          //<! Generic failure
   BLOSC2_ERROR_STREAM = 2,            //<! Bad stream
   BLOSC2_ERROR_DATA = -3,             //<! Invalid data
   BLOSC2_ERROR_MEMORY_ALLOC = -4,     //<! Memory alloc/realloc failure
   BLOSC2_ERROR_READ_BUFFER = -5,      //!< Not enough space to read
   BLOSC2_ERROR_WRITE_BUFFER = -6,     //!< Not enough space to write
   BLOSC2_ERROR_CODEC_SUPPORT = -7,    //!< Codec not supported
   BLOSC2_ERROR_CODEC_PARAM = -8,      //!< Invalid parameter supplied to codec
   BLOSC2_ERROR_CODEC_DICT = -9,       //!< Codec dictionary error
   BLOSC2_ERROR_VERSION_SUPPORT = -10, //!< Version not supported
   BLOSC2_ERROR_INVALID_HEADER = -11,  //!< Invalid value in header
   BLOSC2_ERROR_INVALID_PARAM = -12,   //!< Invalid parameter supplied to function
   BLOSC2_ERROR_FILE_READ = -13,       //!< File read failure
   BLOSC2_ERROR_FILE_WRITE = -14,      //!< File write failure
   BLOSC2_ERROR_FILE_OPEN = -15,       //!< File open failure
   BLOSC2_ERROR_NOT_FOUND = -16,       //!< Not found
   BLOSC2_ERROR_RUN_LENGTH = -17,      //!< Bad run length encoding
   BLOSC2_ERROR_FILTER_PIPELINE = -18, //!< Filter pipeline error
   BLOSC2_ERROR_CHUNK_INSERT = -19,    //!< Chunk insert failure
   BLOSC2_ERROR_CHUNK_APPEND = -20,    //!< Chunk append failure
   BLOSC2_ERROR_CHUNK_UPDATE = -21,    //!< Chunk update failure
   BLOSC2_ERROR_2GB_LIMIT = -22,       //!< Sizes larger than 2gb not supported
   BLOSC2_ERROR_SCHUNK_COPY = -23,     //!< Super-chunk copy failure
   BLOSC2_ERROR_FRAME_TYPE = -24,      //!< Wrong type for frame
+  BLOSC2_ERROR_FILE_TRUNCATE = -25,   //!< File truncate failure
+
 };
 
 /**
  * @brief Initialize the Blosc library environment.
  *
  * You must call this previous to any other Blosc call, unless you want
  * Blosc to be used simultaneously in a multi-threaded environment, in
  * which case you can use the
  * @see #blosc2_compress_ctx #blosc2_decompress_ctx pair.
  */
@@ -997,30 +999,33 @@ BLOSC_EXPORT int blosc2_decompress_ctx(blosc2_context* context, const void* src,
 /**
  * @brief Context interface counterpart for #blosc_getitem.
  *
  * It uses many of the same parameters as blosc_getitem() function with
  * a few additions.
  *
  * @param context Context pointer.
  * @param srcsize Compressed buffer length.
  * @param destsize Output buffer length.
  *
  * @return The number of bytes copied to @p dest or a negative value if
  * some error happens.
  */
 BLOSC_EXPORT int blosc2_getitem_ctx(blosc2_context* context, const void* src,
                                     int32_t srcsize, int start, int nitems, void* dest,
                                     int32_t destsize);
 
 
 /*********************************************************************
   Super-chunk related structures and functions.
 *********************************************************************/
 
 #define BLOSC2_MAX_METALAYERS 16
 #define BLOSC2_METALAYER_NAME_MAXLEN 31
 
+#define BLOSC2_MAX_VLMETALAYERS BLOSC2_MAX_METALAYERS
+#define BLOSC2_USERMETA_NAME_MAXLEN BLOSC2_METALAYER_NAME_MAXLEN
+
 /**
  * @brief This struct is meant for holding storage parameters for a
  * for a blosc2 container, allowing to specify, for example, how to interpret
  * the contents included in the schunk.
  */
@@ -1058,63 +1063,63 @@ typedef struct blosc2_metalayer {
 /**
  * @brief This struct is the standard container for Blosc 2 compressed data.
  *
  * This is essentially a container for Blosc 1 chunks of compressed data,
  * and it allows to overcome the 32-bit limitation in Blosc 1. Optionally,
  * a #blosc2_frame can be attached so as to store the compressed chunks contiguously.
  */
 typedef struct blosc2_schunk {
   uint8_t version;
   uint8_t compcode;
   //!< The default compressor. Each chunk can override this.
   uint8_t clevel;
   //!< The compression level and other compress params.
   int32_t typesize;
   //!< The type size.
   int32_t blocksize;
   //!< The requested size of the compressed blocks (0; meaning automatic).
   int32_t chunksize;
   //!< Size of each chunk. 0 if not a fixed chunksize.
   uint8_t filters[BLOSC2_MAX_FILTERS];
   //!< The (sequence of) filters.  8-bit per filter.
   uint8_t filters_meta[BLOSC2_MAX_FILTERS];
   //!< Metadata for filters. 8-bit per meta-slot.
   int32_t nchunks;
   //!< Number of chunks in super-chunk.
   int64_t nbytes;
   //!< The data size + metadata size + header size (uncompressed).
   int64_t cbytes;
   //!< The data size + metadata size + header size (compressed).
   uint8_t** data;
   //!< Pointer to chunk data pointers buffer.
   size_t data_len;
   //!< Length of the chunk data pointers buffer.
   blosc2_storage* storage;
   //!< Pointer to storage info.
   blosc2_frame* frame;
   //!< Pointer to frame used as store for chunks.
   //!<uint8_t* ctx;
   //!< Context for the thread holder. NULL if not acquired.
   blosc2_context* cctx;
   //!< Context for compression
   blosc2_context* dctx;
   //!< Context for decompression.
   struct blosc2_metalayer *metalayers[BLOSC2_MAX_METALAYERS];
   //!< The array of metalayers.
   int16_t nmetalayers;
-  //!< The number of metalayers in the frame
-  uint8_t* usermeta;
-  //<! The user-defined metadata.
-  int32_t usermeta_len;
-  //<! The (compressed) length of the user-defined metadata.
+  //!< The number of metalayers in the super-chunk
+  struct blosc2_metalayer *vlmetalayers[BLOSC2_MAX_VLMETALAYERS];
+  //<! The array of variable-length metalayers.
+  int16_t nvlmetalayers;
+  //!< The number of variable-length metalayers.
 } blosc2_schunk;
 
 /**
  * @brief Create a new super-chunk.
  *
  * @param storage The storage properties.
  *
  * @remark In case that storage.urlpath is not NULL, the data is stored
  * on-disk.  If the data file(s) exist, they are *overwritten*.
  *
  * @return The new super-chunk.
  */
@@ -1415,84 +1420,106 @@ BLOSC_EXPORT int blosc2_update_metalayer(blosc2_schunk *schunk, const char *name
 /**
  * @brief Get the content out of a metalayer.
  *
  * @param schunk The frame containing the metalayer.
  * @param name The name of the metalayer.
  * @param content The pointer where the content will be put.
  * @param content_len The length of the content.
  *
  * @warning The @p **content receives a malloc'ed copy of the content.
  * The user is responsible of freeing it.
  *
  * @return If successful, the index of the new metalayer. Else, return a negative value.
  */
 BLOSC_EXPORT int blosc2_get_metalayer(blosc2_schunk *schunk, const char *name, uint8_t **content,
                                       uint32_t *content_len);
 
 
 /*********************************************************************
-  Usermeta functions.
+  Variable-length metalayers functions.
 *********************************************************************/
 
 /**
- * @brief Update content into a usermeta chunk.
+ * @brief Find whether the schunk has a variable-length metalayer or not.
  *
- * If the @p schunk has an attached frame, the later will be updated accordingly too.
+ * @param schunk The super-chunk from which the variable-length metalayer will be checked.
+ * @param name The name of the variable-length metalayer to be checked.
  *
- * @param schunk The super-chunk to add the usermeta chunk.
- * @param content The content of the usermeta chunk.
+ * @return If successful, return the index of the variable-length metalayer. Else, return a negative value.
+ */
+BLOSC_EXPORT int blosc2_has_vlmetalayer(blosc2_schunk *schunk, const char *name);
+
+/**
+ * @brief Add content into a new variable-length metalayer.
+ *
+ * @param schunk The super-chunk to which the variable-length metalayer should be added.
+ * @param name The name of the variable-length metalayer.
+ * @param content The content to be added.
  * @param content_len The length of the content.
- * @param cparams The parameters for compressing the usermeta chunk.
+ * @param cparams The parameters for compressing the variable-length metalayer content.
  *
- * @note The previous content, if any, will be overwritten by the new content.
- * The user is responsible to keep the new content in sync with any previous content.
+ * @return If successful, the index of the new variable-length metalayer. Else, return a negative value.
+ */
+BLOSC_EXPORT int blosc2_add_vlmetalayer(blosc2_schunk *schunk, const char *name,
+                                        uint8_t *content, uint32_t content_len, blosc2_cparams *cparams);
+
+/**
+ * @brief Update the content of an existing variable-length metalayer.
  *
- * @return If successful, return the number of compressed bytes that takes the content.
- * Else, a negative value.
+ * @param schunk The super-chunk containing the variable-length metalayer.
+ * @param name The name of the variable-length metalayer to be updated.
+ * @param content The new content of the variable-length metalayer.
+ * @param content_len The length of the content.
+ *
+ * @return If successful, the index of the variable-length metalayer. Else, return a negative value.
  */
-BLOSC_EXPORT int blosc2_update_usermeta(blosc2_schunk *schunk, uint8_t *content,
-                                        int32_t content_len, blosc2_cparams cparams);
+BLOSC_EXPORT int blosc2_update_vlmetalayer(blosc2_schunk *schunk, const char *name,
+                                           uint8_t *content, uint32_t content_len, blosc2_cparams *cparams);
 
-/* @brief Retrieve the usermeta chunk in a decompressed form.
+/**
+ * @brief Get the content out of a variable-length metalayer.
  *
- * @param schunk The super-chunk to which add the usermeta chunk.
- * @param content The content of the usermeta chunk (output).
+ * @param schunk The super-chunk containing the variable-length metalayer.
+ * @param name The name of the variable-length metalayer.
+ * @param content The pointer where the content will be put.
+ * @param content_len The pointer where the length of the content will be put.
  *
- * @note The user is responsible to free the @p content buffer.
+ * @warning The @p **content receives a malloc'ed copy of the content.
+ * The user is responsible of freeing it.
  *
- * @return If successful, return the size of the (decompressed) chunk.
- * Else, a negative value.
+ * @return If successful, the index of the new variable-length metalayer. Else, return a negative value.
  */
-BLOSC_EXPORT int blosc2_get_usermeta(blosc2_schunk* schunk, uint8_t** content);
+BLOSC_EXPORT int blosc2_get_vlmetalayer(blosc2_schunk *schunk, const char *name,
+                                        uint8_t **content, uint32_t *content_len);
 
 
 /*********************************************************************
   Time measurement utilities.
 *********************************************************************/
 
 #if defined(_WIN32)
 /* For QueryPerformanceCounter(), etc. */
   #include <windows.h>
 #elif defined(__MACH__)
 #include <mach/clock.h>
 #include <mach/mach.h>
 #include <time.h>
 #elif defined(__unix__)
 #if defined(__linux__)
     #include <time.h>
   #else
     #include <sys/time.h>
   #endif
 #else
   #error Unable to detect platform.
 #endif
 
 /* The type of timestamp used on this system. */
 #if defined(_WIN32)
 #define blosc_timestamp_t LARGE_INTEGER
 #else
 #define blosc_timestamp_t struct timespec
 #endif
 
 /*
  * Set a timestamp.
  */
diff --git a/blosc/frame.c b/blosc/frame.c
index a4bfc6d7..455c10a7 100644
--- a/blosc/frame.c
+++ b/blosc/frame.c
@@ -1,84 +1,132 @@
 /*********************************************************************
   Blosc - Blocked Shuffling and Compression Library
 
   Author: The Blosc Developers <blosc@blosc.org>
   Creation date: 2018-07-04
 
   See LICENSE.txt for details about copyright and rights to use.
 **********************************************************************/
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <stdbool.h>
 #include <sys/stat.h>
 #include "blosc2.h"
 #include "blosc-private.h"
 #include "context.h"
 #include "frame.h"
 #include "sframe.h"
 
 #if defined(_WIN32) && !defined(__MINGW32__)
 #include <windows.h>
   #include <malloc.h>
 
 /* stdint.h only available in VS2010 (VC++ 16.0) and newer */
   #if defined(_MSC_VER) && _MSC_VER < 1600
     #include "win32/stdint-windows.h"
   #else
     #include <stdint.h>
   #endif
 
   #define fseek _fseeki64
 
 #endif  /* _WIN32 */
 
 /* If C11 is supported, use it's built-in aligned allocation. */
 #if __STDC_VERSION__ >= 201112L
 #include <stdalign.h>
 #endif
 
+// Truncate file
+#if defined(_WIN32)
+#include <io.h>
+#define TRUNCATE _chsize_s
+#else
+#include <unistd.h>
+#define TRUNCATE ftruncate
+#endif
+
+void little_store(void *dest, const void *pa, int size) {
+  bool little_endian = is_little_endian();
+  if (little_endian) {
+    memcpy(dest, pa, size);
+  }
+  else {
+    uint8_t* pa_ = (uint8_t*)pa;
+    uint8_t* pa2_ = malloc((size_t)size);
+    switch (size) {
+      case 8:
+        pa2_[0] = pa_[7];
+        pa2_[1] = pa_[6];
+        pa2_[2] = pa_[5];
+        pa2_[3] = pa_[4];
+        pa2_[4] = pa_[3];
+        pa2_[5] = pa_[2];
+        pa2_[6] = pa_[1];
+        pa2_[7] = pa_[0];
+        break;
+      case 4:
+        pa2_[0] = pa_[3];
+        pa2_[1] = pa_[2];
+        pa2_[2] = pa_[1];
+        pa2_[3] = pa_[0];
+        break;
+      case 2:
+        pa2_[0] = pa_[1];
+        pa2_[1] = pa_[0];
+        break;
+      case 1:
+        pa2_[0] = pa_[1];
+        break;
+      default:
+        BLOSC_TRACE_ERROR("Unhandled size: %d.", size);
+    }
+    memcpy(dest, pa2_, size);
+    free(pa2_);
+  }
+}
 
 // big <-> little-endian and store it in a memory position.  Sizes supported: 1, 2, 4, 8 bytes.
-void swap_store(void *dest, const void *pa, int size) {
+void big_store(void *dest, const void *pa, int size) {
     bool little_endian = is_little_endian();
-    if (little_endian) {
+    if (!little_endian) {
       memcpy(dest, pa, size);
     }
     else {
       uint8_t* pa_ = (uint8_t*)pa;
       uint8_t* pa2_ = malloc((size_t)size);
       switch (size) {
         case 8:
           pa2_[0] = pa_[7];
           pa2_[1] = pa_[6];
           pa2_[2] = pa_[5];
           pa2_[3] = pa_[4];
           pa2_[4] = pa_[3];
           pa2_[5] = pa_[2];
           pa2_[6] = pa_[1];
           pa2_[7] = pa_[0];
           break;
       case 4:
           pa2_[0] = pa_[3];
           pa2_[1] = pa_[2];
           pa2_[2] = pa_[1];
           pa2_[3] = pa_[0];
           break;
       case 2:
           pa2_[0] = pa_[1];
           pa2_[1] = pa_[0];
           break;
       case 1:
           pa2_[0] = pa_[1];
           break;
       default:
         BLOSC_TRACE_ERROR("Unhandled size: %d.", size);
     }
     memcpy(dest, pa2_, size);
     free(pa2_);
   }
 }
 
 
 /* Create a new (empty) frame */
@@ -116,270 +164,270 @@ int frame_free(blosc2_frame_s* frame) {
 void *new_header_frame(blosc2_schunk *schunk, blosc2_frame_s *frame) {
   if (frame == NULL) {
     return NULL;
   }
   uint8_t* h2 = calloc(FRAME_HEADER_MINLEN, 1);
   uint8_t* h2p = h2;
 
   // The msgpack header starts here
   *h2p = 0x90;  // fixarray...
   *h2p += 13;   // ...with 13 elements
   h2p += 1;
 
   // Magic number
   *h2p = 0xa0 + 8;  // str with 8 elements
   h2p += 1;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
   strcpy((char*)h2p, "b2frame");
   h2p += 8;
 
   // Header size
   *h2p = 0xd2;  // int32
   h2p += 1 + 4;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // Total frame size
   *h2p = 0xcf;  // uint64
   // Fill it with frame->len which is known *after* the creation of the frame (e.g. when updating the header)
   int64_t flen = frame->len;
-  swap_store(h2 + FRAME_LEN, &flen, sizeof(flen));
+  big_store(h2 + FRAME_LEN, &flen, sizeof(flen));
   h2p += 1 + 8;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // Flags
   *h2p = 0xa0 + 4;  // str with 4 elements
   h2p += 1;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // General flags
   *h2p = BLOSC2_VERSION_FRAME_FORMAT;  // version
   *h2p += 0x10;  // 64-bit offsets.  We only support this for now.
   h2p += 1;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // Frame type
   // We only support contiguous and sparse directories frames currently
   *h2p = frame->sframe ? 1 : 0;
   h2p += 1;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // Codec flags
   *h2p = schunk->compcode;
   *h2p += (schunk->clevel) << 4u;  // clevel
   h2p += 1;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // Reserved flags
   *h2p = 0;
   h2p += 1;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // Uncompressed size
   *h2p = 0xd3;  // int64
   h2p += 1;
   int64_t nbytes = schunk->nbytes;
-  swap_store(h2p, &nbytes, sizeof(nbytes));
+  big_store(h2p, &nbytes, sizeof(nbytes));
   h2p += 8;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // Compressed size
   *h2p = 0xd3;  // int64
   h2p += 1;
   int64_t cbytes = schunk->cbytes;
-  swap_store(h2p, &cbytes, sizeof(cbytes));
+  big_store(h2p, &cbytes, sizeof(cbytes));
   h2p += 8;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // Type size
   *h2p = 0xd2;  // int32
   h2p += 1;
   int32_t typesize = schunk->typesize;
-  swap_store(h2p, &typesize, sizeof(typesize));
+  big_store(h2p, &typesize, sizeof(typesize));
   h2p += 4;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // Chunk size
   *h2p = 0xd2;  // int32
   h2p += 1;
   int32_t chunksize = schunk->chunksize;
-  swap_store(h2p, &chunksize, sizeof(chunksize));
+  big_store(h2p, &chunksize, sizeof(chunksize));
   h2p += 4;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // Number of threads for compression
   *h2p = 0xd1;  // int16
   h2p += 1;
   int16_t nthreads = (int16_t)schunk->cctx->nthreads;
-  swap_store(h2p, &nthreads, sizeof(nthreads));
+  big_store(h2p, &nthreads, sizeof(nthreads));
   h2p += 2;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // Number of threads for decompression
   *h2p = 0xd1;  // int16
   h2p += 1;
   nthreads = (int16_t)schunk->dctx->nthreads;
-  swap_store(h2p, &nthreads, sizeof(nthreads));
+  big_store(h2p, &nthreads, sizeof(nthreads));
   h2p += 2;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
-  // The boolean for FRAME_HAS_USERMETA
-  *h2p = (schunk->usermeta_len > 0) ? (uint8_t)0xc3 : (uint8_t)0xc2;
+  // The boolean for variable-length metalayers
+  *h2p = (schunk->nvlmetalayers > 0) ? (uint8_t)0xc3 : (uint8_t)0xc2;
   h2p += 1;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // The space for FRAME_FILTER_PIPELINE
   *h2p = 0xd8;  //  fixext 16
   h2p += 1;
   if (BLOSC2_MAX_FILTERS > FRAME_FILTER_PIPELINE_MAX) {
     return NULL;
   }
   // Store the filter pipeline in header
   uint8_t* mp_filters = h2 + FRAME_FILTER_PIPELINE + 1;
   uint8_t* mp_meta = h2 + FRAME_FILTER_PIPELINE + 1 + FRAME_FILTER_PIPELINE_MAX;
   int nfilters = 0;
   for (int i = 0; i < BLOSC2_MAX_FILTERS; i++) {
     if (schunk->filters[i] != BLOSC_NOFILTER) {
       mp_filters[nfilters] = schunk->filters[i];
       mp_meta[nfilters] = schunk->filters_meta[i];
       nfilters++;
     }
   }
   *h2p = (uint8_t)nfilters;
   h2p += 1;
   h2p += 16;
   if (h2p - h2 != FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   int32_t hsize = FRAME_HEADER_MINLEN;
 
   // Now, deal with metalayers
   int16_t nmetalayers = schunk->nmetalayers;
   if (nmetalayers < 0 || nmetalayers > BLOSC2_MAX_METALAYERS) {
     return NULL;
   }
 
   // Make space for the header of metalayers (array marker, size, map of offsets)
   h2 = realloc(h2, (size_t)hsize + 1 + 1 + 2 + 1 + 2);
   h2p = h2 + hsize;
 
   // The msgpack header for the metalayers (array_marker, size, map of offsets, list of metalayers)
   *h2p = 0x90 + 3;  // array with 3 elements
   h2p += 1;
 
   // Size for the map (index) of offsets, including this uint16 size (to be filled out later on)
   *h2p = 0xcd;  // uint16
   h2p += 1 + 2;
 
   // Map (index) of offsets for optional metalayers
   *h2p = 0xde;  // map 16 with N keys
   h2p += 1;
-  swap_store(h2p, &nmetalayers, sizeof(nmetalayers));
+  big_store(h2p, &nmetalayers, sizeof(nmetalayers));
   h2p += sizeof(nmetalayers);
   int32_t current_header_len = (int32_t)(h2p - h2);
   int32_t *offtooff = malloc(nmetalayers * sizeof(int32_t));
   for (int nmetalayer = 0; nmetalayer < nmetalayers; nmetalayer++) {
     if (frame == NULL) {
       return NULL;
     }
     blosc2_metalayer *metalayer = schunk->metalayers[nmetalayer];
     uint8_t namelen = (uint8_t) strlen(metalayer->name);
     h2 = realloc(h2, (size_t)current_header_len + 1 + namelen + 1 + 4);
     h2p = h2 + current_header_len;
     // Store the metalayer
     if (namelen >= (1U << 5U)) {  // metalayer strings cannot be longer than 32 bytes
       free(offtooff);
       return NULL;
     }
     *h2p = (uint8_t)0xa0 + namelen;  // str
     h2p += 1;
     memcpy(h2p, metalayer->name, namelen);
     h2p += namelen;
     // Space for storing the offset for the value of this metalayer
     *h2p = 0xd2;  // int32
     h2p += 1;
     offtooff[nmetalayer] = (int32_t)(h2p - h2);
     h2p += 4;
     current_header_len += 1 + namelen + 1 + 4;
   }
   int32_t hsize2 = (int32_t)(h2p - h2);
   if (hsize2 != current_header_len) {  // sanity check
     return NULL;
   }
 
   // Map size + int16 size
   if ((uint32_t) (hsize2 - hsize) >= (1U << 16U)) {
     return NULL;
   }
   uint16_t map_size = (uint16_t) (hsize2 - hsize);
-  swap_store(h2 + FRAME_IDX_SIZE, &map_size, sizeof(map_size));
+  big_store(h2 + FRAME_IDX_SIZE, &map_size, sizeof(map_size));
 
   // Make space for an (empty) array
   hsize = (int32_t)(h2p - h2);
   h2 = realloc(h2, (size_t)hsize + 2 + 1 + 2);
   h2p = h2 + hsize;
 
   // Now, store the values in an array
   *h2p = 0xdc;  // array 16 with N elements
   h2p += 1;
-  swap_store(h2p, &nmetalayers, sizeof(nmetalayers));
+  big_store(h2p, &nmetalayers, sizeof(nmetalayers));
   h2p += sizeof(nmetalayers);
   current_header_len = (int32_t)(h2p - h2);
   for (int nmetalayer = 0; nmetalayer < nmetalayers; nmetalayer++) {
     if (frame == NULL) {
       return NULL;
     }
     blosc2_metalayer *metalayer = schunk->metalayers[nmetalayer];
     h2 = realloc(h2, (size_t)current_header_len + 1 + 4 + metalayer->content_len);
     h2p = h2 + current_header_len;
     // Store the serialized contents for this metalayer
     *h2p = 0xc6;  // bin32
     h2p += 1;
-    swap_store(h2p, &(metalayer->content_len), sizeof(metalayer->content_len));
+    big_store(h2p, &(metalayer->content_len), sizeof(metalayer->content_len));
     h2p += 4;
     memcpy(h2p, metalayer->content, metalayer->content_len);  // buffer, no need to swap
     h2p += metalayer->content_len;
     // Update the offset now that we know it
-    swap_store(h2 + offtooff[nmetalayer], &current_header_len, sizeof(current_header_len));
+    big_store(h2 + offtooff[nmetalayer], &current_header_len, sizeof(current_header_len));
     current_header_len += 1 + 4 + metalayer->content_len;
   }
   free(offtooff);
   hsize = (int32_t)(h2p - h2);
   if (hsize != current_header_len) {  // sanity check
     return NULL;
   }
 
   // Set the length of the whole header now that we know it
-  swap_store(h2 + FRAME_HEADER_LEN, &hsize, sizeof(hsize));
+  big_store(h2 + FRAME_HEADER_LEN, &hsize, sizeof(hsize));
 
   return h2;
 }
@@ -388,103 +436,103 @@ void *new_header_frame(blosc2_schunk *schunk, blosc2_frame_s *frame) {
 int get_header_info(blosc2_frame_s *frame, int32_t *header_len, int64_t *frame_len, int64_t *nbytes,
                     int64_t *cbytes, int32_t *chunksize, int32_t *nchunks, int32_t *typesize,
                     uint8_t *compcode, uint8_t *clevel, uint8_t *filters, uint8_t *filters_meta) {
   uint8_t* framep = frame->cframe;
   uint8_t header[FRAME_HEADER_MINLEN];
 
   if (frame->len <= 0) {
     return BLOSC2_ERROR_READ_BUFFER;
   }
 
   if (frame->cframe == NULL) {
     size_t rbytes = 0;
     FILE* fp = NULL;
     if (frame->sframe) {
       fp = sframe_open_index(frame->urlpath, "rb");
     }
     else {
       fp = fopen(frame->urlpath, "rb");
     }
     if (fp != NULL) {
       rbytes = fread(header, 1, FRAME_HEADER_MINLEN, fp);
       fclose(fp);
     }
     (void) rbytes;
     if (rbytes != FRAME_HEADER_MINLEN) {
       return BLOSC2_ERROR_FILE_READ;
     }
     framep = header;
   }
 
   // Consistency check for frame type
   uint8_t frame_type = framep[FRAME_TYPE];
   if (frame->sframe) {
     if (frame_type != FRAME_DIRECTORY_TYPE) {
       return BLOSC2_ERROR_FRAME_TYPE;
     }
   } else {
     if (frame_type != FRAME_CONTIGUOUS_TYPE) {
       return BLOSC2_ERROR_FRAME_TYPE;
     }
   }
 
   // Fetch some internal lengths
-  swap_store(header_len, framep + FRAME_HEADER_LEN, sizeof(*header_len));
-  swap_store(frame_len, framep + FRAME_LEN, sizeof(*frame_len));
-  swap_store(nbytes, framep + FRAME_NBYTES, sizeof(*nbytes));
-  swap_store(cbytes, framep + FRAME_CBYTES, sizeof(*cbytes));
-  swap_store(chunksize, framep + FRAME_CHUNKSIZE, sizeof(*chunksize));
+  big_store(header_len, framep + FRAME_HEADER_LEN, sizeof(*header_len));
+  big_store(frame_len, framep + FRAME_LEN, sizeof(*frame_len));
+  big_store(nbytes, framep + FRAME_NBYTES, sizeof(*nbytes));
+  big_store(cbytes, framep + FRAME_CBYTES, sizeof(*cbytes));
+  big_store(chunksize, framep + FRAME_CHUNKSIZE, sizeof(*chunksize));
   if (typesize != NULL) {
-    swap_store(typesize, framep + FRAME_TYPESIZE, sizeof(*typesize));
+    big_store(typesize, framep + FRAME_TYPESIZE, sizeof(*typesize));
   }
 
   if (*header_len <= 0 || *header_len > *frame_len) {
     BLOSC_TRACE_ERROR("Header length is invalid or exceeds length of the frame.");
     return BLOSC2_ERROR_INVALID_HEADER;
   }
 
   // Codecs
   uint8_t frame_codecs = framep[FRAME_CODECS];
   if (clevel != NULL) {
     *clevel = frame_codecs >> 4u;
   }
   if (compcode != NULL) {
     *compcode = frame_codecs & 0xFu;
   }
 
   // Filters
   if (filters != NULL && filters_meta != NULL) {
     uint8_t nfilters = framep[FRAME_FILTER_PIPELINE];
     if (nfilters > BLOSC2_MAX_FILTERS) {
       BLOSC_TRACE_ERROR("The number of filters in frame header are too large for Blosc2.");
       return BLOSC2_ERROR_INVALID_HEADER;
     }
     uint8_t *filters_ = framep + FRAME_FILTER_PIPELINE + 1;
     uint8_t *filters_meta_ = framep + FRAME_FILTER_PIPELINE + 1 + FRAME_FILTER_PIPELINE_MAX;
     for (int i = 0; i < nfilters; i++) {
       filters[i] = filters_[i];
       filters_meta[i] = filters_meta_[i];
     }
   }
 
   if (*nbytes > 0 && *chunksize > 0) {
     // We can compute the number of chunks only when the frame has actual data
     *nchunks = (int32_t) (*nbytes / *chunksize);
     if (*nbytes % *chunksize > 0) {
       if (*nchunks == INT32_MAX) {
         BLOSC_TRACE_ERROR("Number of chunks exceeds maximum allowed.");
         return BLOSC2_ERROR_INVALID_HEADER;
       }
       *nchunks += 1;
     }
 
     // Sanity check for compressed sizes
     if ((*cbytes < 0) || ((int64_t)*nchunks * *chunksize < *nbytes)) {
       BLOSC_TRACE_ERROR("Invalid compressed size in frame header.");
       return BLOSC2_ERROR_INVALID_HEADER;
     }
   } else {
     *nchunks = 0;
   }
 
   return 0;
 }
@@ -502,26 +550,26 @@ int64_t get_trailer_offset(blosc2_frame_s *frame, int32_t header_len, bool has_c
 // Update the length in the header
 int update_frame_len(blosc2_frame_s* frame, int64_t len) {
   int rc = 1;
   if (frame->cframe != NULL) {
-    swap_store(frame->cframe + FRAME_LEN, &len, sizeof(int64_t));
+    big_store(frame->cframe + FRAME_LEN, &len, sizeof(int64_t));
   }
   else {
     FILE* fp = NULL;
     if (frame->sframe) {
       fp = sframe_open_index(frame->urlpath, "rb+");
     }
     else {
       fp = fopen(frame->urlpath, "rb+");
     }
     fseek(fp, FRAME_LEN, SEEK_SET);
     int64_t swap_len;
-    swap_store(&swap_len, &len, sizeof(int64_t));
+    big_store(&swap_len, &len, sizeof(int64_t));
     size_t wbytes = fwrite(&swap_len, 1, sizeof(int64_t), fp);
     fclose(fp);
     if (wbytes != sizeof(int64_t)) {
       BLOSC_TRACE_ERROR("Cannot write the frame length in header.");
       return BLOSC2_ERROR_FILE_WRITE;
     }
   }
   return rc;
 }
@@ -530,336 +578,441 @@ int update_frame_len(blosc2_frame_s* frame, int64_t len) {
 int frame_update_trailer(blosc2_frame_s* frame, blosc2_schunk* schunk) {
   if (frame != NULL && frame->len == 0) {
     BLOSC_TRACE_ERROR("The trailer cannot be updated on empty frames.");
   }
 
   // Create the trailer in msgpack (see the frame format document)
-  uint32_t trailer_len = FRAME_TRAILER_MINLEN + schunk->usermeta_len;
+  uint32_t trailer_len = FRAME_TRAILER_MINLEN;
   uint8_t* trailer = (uint8_t*)calloc((size_t)trailer_len, 1);
   uint8_t* ptrailer = trailer;
   *ptrailer = 0x90 + 4;  // fixarray with 4 elements
   ptrailer += 1;
   // Trailer format version
   *ptrailer = FRAME_TRAILER_VERSION;
   ptrailer += 1;
-  // usermeta
-  *ptrailer = 0xc6;     // bin32
+
+  int32_t current_trailer_len = (int32_t)(ptrailer - trailer);
+
+  // Now, deal with variable-length metalayers
+  int16_t nvlmetalayers = schunk->nvlmetalayers;
+  if (nvlmetalayers < 0 || nvlmetalayers > BLOSC2_MAX_METALAYERS) {
+    return -1;
+  }
+
+  // Make space for the header of metalayers (array marker, size, map of offsets)
+  trailer = realloc(trailer, (size_t) current_trailer_len + 1 + 1 + 2 + 1 + 2);
+  ptrailer = trailer + current_trailer_len;
+
+  // The msgpack header for the metalayers (array_marker, size, map of offsets, list of metalayers)
+  *ptrailer = 0x90 + 3;  // array with 3 elements
+  ptrailer += 1;
+
+  int32_t tsize = (ptrailer - trailer);
+
+  // Size for the map (index) of metalayer offsets, including this uint16 size (to be filled out later on)
+  *ptrailer = 0xcd;  // uint16
+  ptrailer += 1 + 2;
+
+  // Map (index) of offsets for optional metalayers
+  *ptrailer = 0xde;  // map 16 with N keys
+  ptrailer += 1;
+  big_store(ptrailer, &nvlmetalayers, sizeof(nvlmetalayers));
+  ptrailer += sizeof(nvlmetalayers);
+  current_trailer_len = (int32_t)(ptrailer - trailer);
+  int32_t *offtodata = malloc(nvlmetalayers * sizeof(int32_t));
+  for (int nvlmetalayer = 0; nvlmetalayer < nvlmetalayers; nvlmetalayer++) {
+    if (frame == NULL) {
+      return -1;
+    }
+    blosc2_metalayer *vlmetalayer = schunk->vlmetalayers[nvlmetalayer];
+    uint8_t name_len = (uint8_t) strlen(vlmetalayer->name);
+    trailer = realloc(trailer, (size_t)current_trailer_len + 1 + name_len + 1 + 4);
+    ptrailer = trailer + current_trailer_len;
+    // Store the vlmetalayer
+    if (name_len >= (1U << 5U)) {  // metalayer strings cannot be longer than 32 bytes
+      free(offtodata);
+      return -1;
+    }
+    *ptrailer = (uint8_t)0xa0 + name_len;  // str
+    ptrailer += 1;
+    memcpy(ptrailer, vlmetalayer->name, name_len);
+    ptrailer += name_len;
+    // Space for storing the offset for the value of this vlmetalayer
+    *ptrailer = 0xd2;  // int32
+    ptrailer += 1;
+    offtodata[nvlmetalayer] = (int32_t)(ptrailer - trailer);
+    ptrailer += 4;
+    current_trailer_len += 1 + name_len + 1 + 4;
+  }
+  int32_t tsize2 = (int32_t)(ptrailer - trailer);
+  if (tsize2 != current_trailer_len) {  // sanity check
+    return -1;
+  }
+
+  // Map size + int16 size
+  if ((uint32_t) (tsize2 - tsize) >= (1U << 16U)) {
+    return -1;
+  }
+  uint16_t map_size = (uint16_t) (tsize2 - tsize);
+  big_store(trailer + 4, &map_size, sizeof(map_size));
+
+  // Make space for an (empty) array
+  tsize = (int32_t)(ptrailer - trailer);
+  trailer = realloc(trailer, (size_t) tsize + 2 + 1 + 2);
+  ptrailer = trailer + tsize;
+
+  // Now, store the values in an array
+  *ptrailer = 0xdc;  // array 16 with N elements
   ptrailer += 1;
-  swap_store(ptrailer, &(schunk->usermeta_len), 4);
-  ptrailer += 4;
-  if (schunk->usermeta_len > 0)
-    memcpy(ptrailer, schunk->usermeta, schunk->usermeta_len);
-  ptrailer += schunk->usermeta_len;
+  big_store(ptrailer, &nvlmetalayers, sizeof(nvlmetalayers));
+  ptrailer += sizeof(nvlmetalayers);
+  current_trailer_len = (int32_t)(ptrailer - trailer);
+  for (int nvlmetalayer = 0; nvlmetalayer < nvlmetalayers; nvlmetalayer++) {
+    if (frame == NULL) {
+      return -1;
+    }
+    blosc2_metalayer *vlmetalayer = schunk->vlmetalayers[nvlmetalayer];
+    trailer = realloc(trailer, (size_t)current_trailer_len + 1 + 4 + vlmetalayer->content_len);
+    ptrailer = trailer + current_trailer_len;
+    // Store the serialized contents for this vlmetalayer
+    *ptrailer = 0xc6;  // bin32
+    ptrailer += 1;
+    big_store(ptrailer, &(vlmetalayer->content_len), sizeof(vlmetalayer->content_len));
+    ptrailer += 4;
+    memcpy(ptrailer, vlmetalayer->content, vlmetalayer->content_len);  // buffer, no need to swap
+    ptrailer += vlmetalayer->content_len;
+    // Update the offset now that we know it
+    big_store(trailer + offtodata[nvlmetalayer], &current_trailer_len, sizeof(current_trailer_len));
+    current_trailer_len += 1 + 4 + vlmetalayer->content_len;
+  }
+  free(offtodata);
+  tsize = (int32_t)(ptrailer - trailer);
+  if (tsize != current_trailer_len) {  // sanity check
+    return -1;
+  }
+
+  trailer = realloc(trailer, (size_t)current_trailer_len + 23);
+  ptrailer = trailer + current_trailer_len;
+  trailer_len = (ptrailer - trailer) + 23;
+
   // Trailer length
   *ptrailer = 0xce;  // uint32
   ptrailer += 1;
-  swap_store(ptrailer, &(trailer_len), sizeof(uint32_t));
+  big_store(ptrailer, &trailer_len, sizeof(uint32_t));
   ptrailer += sizeof(uint32_t);
   // Up to 16 bytes for frame fingerprint (using XXH3 included in https://github.com/Cyan4973/xxHash)
   // Maybe someone would need 256-bit in the future, but for the time being 128-bit seems like a good tradeoff
   *ptrailer = 0xd8;  // fixext 16
   ptrailer += 1;
   *ptrailer = 0;  // fingerprint type: 0 -> no fp; 1 -> 32-bit; 2 -> 64-bit; 3 -> 128-bit
   ptrailer += 1;
+
   // Uncomment this when we compute an actual fingerprint
   // memcpy(ptrailer, xxh3_fingerprint, sizeof(xxh3_fingerprint));
   ptrailer += 16;
+
   // Sanity check
   if (ptrailer - trailer != trailer_len) {
     return BLOSC2_ERROR_DATA;
   }
+
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t chunksize;
   int32_t nchunks;
   int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                             NULL, NULL, NULL, NULL, NULL);
   if (ret < 0) {
     BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
     return ret;
   }
 
   int64_t trailer_offset = get_trailer_offset(frame, header_len, nbytes > 0);
 
   // Update the trailer.  As there are no internal offsets to the trailer section,
   // and it is always at the end of the frame, we can just write (or overwrite) it
   // at the end of the frame.
   if (frame->cframe != NULL) {
     frame->cframe = realloc(frame->cframe, (size_t)(trailer_offset + trailer_len));
     if (frame->cframe == NULL) {
       BLOSC_TRACE_ERROR("Cannot realloc space for the frame.");
       return BLOSC2_ERROR_MEMORY_ALLOC;
     }
     memcpy(frame->cframe + trailer_offset, trailer, trailer_len);
   }
   else {
     FILE* fp = NULL;
     if (frame->sframe) {
       fp = sframe_open_index(frame->urlpath, "rb+");
     }
     else {
       fp = fopen(frame->urlpath, "rb+");
     }
     fseek(fp, trailer_offset, SEEK_SET);
     size_t wbytes = fwrite(trailer, 1, trailer_len, fp);
-    fclose(fp);
     if (wbytes != (size_t)trailer_len) {
       BLOSC_TRACE_ERROR("Cannot write the trailer length in trailer.");
       return BLOSC2_ERROR_FILE_WRITE;
     }
+    if (TRUNCATE(fileno(fp), trailer_offset + trailer_len) != 0) {
+      BLOSC_TRACE_ERROR("Cannot truncate the frame.");
+      return BLOSC2_ERROR_FILE_TRUNCATE;
+    }
+    fclose(fp);
+
   }
   free(trailer);
 
   int rc = update_frame_len(frame, trailer_offset + trailer_len);
   if (rc < 0) {
     return rc;
   }
   frame->len = trailer_offset + trailer_len;
   frame->trailer_len = trailer_len;
 
   return 1;
 }
 
 
 /* Initialize a frame out of a file */
 blosc2_frame_s* frame_from_file(const char* urlpath) {
   // Get the length of the frame
   uint8_t header[FRAME_HEADER_MINLEN];
   uint8_t trailer[FRAME_TRAILER_MINLEN];
 
   FILE* fp = NULL;
   bool sframe = false;
   struct stat path_stat;
 
   if(stat(urlpath, &path_stat) < 0) {
     BLOSC_TRACE_ERROR("Cannot get information about the path %s.", urlpath);
     return NULL;
   }
   char* urlpath_cpy;
   if (path_stat.st_mode & S_IFDIR) {
     char last_char = urlpath[strlen(urlpath) - 1];
     if (last_char == '\\' || last_char == '/') {
       urlpath_cpy = malloc(strlen(urlpath));
       strncpy(urlpath_cpy,urlpath, strlen(urlpath) - 1);
       urlpath_cpy[strlen(urlpath) - 1] = '\0';
     }
     else {
       urlpath_cpy = malloc(strlen(urlpath) + 1);
       strcpy(urlpath_cpy, urlpath);
     }
     fp = sframe_open_index(urlpath_cpy, "rb");
     sframe = true;
   }
   else {
     urlpath_cpy = malloc(strlen(urlpath) + 1);
     strcpy(urlpath_cpy, urlpath);
     fp = fopen(urlpath, "rb");
   }
   size_t rbytes = fread(header, 1, FRAME_HEADER_MINLEN, fp);
   if (rbytes != FRAME_HEADER_MINLEN) {
     BLOSC_TRACE_ERROR("Cannot read from file '%s'.", urlpath);
     fclose(fp);
     free(urlpath_cpy);
     return NULL;
   }
   int64_t frame_len;
-  swap_store(&frame_len, header + FRAME_LEN, sizeof(frame_len));
+  big_store(&frame_len, header + FRAME_LEN, sizeof(frame_len));
 
   blosc2_frame_s* frame = calloc(1, sizeof(blosc2_frame_s));
   frame->urlpath = urlpath_cpy;
   frame->len = frame_len;
   frame->sframe = sframe;
 
   // Now, the trailer length
   fseek(fp, frame_len - FRAME_TRAILER_MINLEN, SEEK_SET);
   rbytes = fread(trailer, 1, FRAME_TRAILER_MINLEN, fp);
   fclose(fp);
   if (rbytes != FRAME_TRAILER_MINLEN) {
     BLOSC_TRACE_ERROR("Cannot read from file '%s'.", urlpath);
     free(urlpath_cpy);
     free(frame);
     return NULL;
   }
   int trailer_offset = FRAME_TRAILER_MINLEN - FRAME_TRAILER_LEN_OFFSET;
   if (trailer[trailer_offset - 1] != 0xce) {
     free(urlpath_cpy);
     free(frame);
     return NULL;
   }
   uint32_t trailer_len;
-  swap_store(&trailer_len, trailer + trailer_offset, sizeof(trailer_len));
+  big_store(&trailer_len, trailer + trailer_offset, sizeof(trailer_len));
   frame->trailer_len = trailer_len;
 
   return frame;
 }
 
 
 /* Initialize a frame out of a contiguous frame buffer */
 blosc2_frame_s* frame_from_cframe(uint8_t *cframe, int64_t len, bool copy) {
   // Get the length of the frame
   const uint8_t* header = cframe;
   int64_t frame_len;
   if (len < FRAME_HEADER_MINLEN) {
     return NULL;
   }
-  swap_store(&frame_len, header + FRAME_LEN, sizeof(frame_len));
+  big_store(&frame_len, header + FRAME_LEN, sizeof(frame_len));
   if (frame_len != len) {   // sanity check
     return NULL;
   }
 
   blosc2_frame_s* frame = calloc(1, sizeof(blosc2_frame_s));
   frame->len = frame_len;
 
   // Now, the trailer length
   const uint8_t* trailer = cframe + frame_len - FRAME_TRAILER_MINLEN;
   int trailer_offset = FRAME_TRAILER_MINLEN - FRAME_TRAILER_LEN_OFFSET;
   if (trailer[trailer_offset - 1] != 0xce) {
     free(frame);
     return NULL;
   }
   uint32_t trailer_len;
-  swap_store(&trailer_len, trailer + trailer_offset, sizeof(trailer_len));
+  big_store(&trailer_len, trailer + trailer_offset, sizeof(trailer_len));
   frame->trailer_len = trailer_len;
 
   if (copy) {
     frame->cframe = malloc((size_t)len);
     memcpy(frame->cframe, cframe, (size_t)len);
   }
   else {
     frame->cframe = cframe;
     frame->avoid_cframe_free = true;
   }
 
   return frame;
 }
 
 
 /* Create a frame out of a super-chunk. */
 int64_t frame_from_schunk(blosc2_schunk *schunk, blosc2_frame_s *frame) {
   int32_t nchunks = schunk->nchunks;
   int64_t cbytes = schunk->cbytes;
   FILE* fp = NULL;
 
   uint8_t* h2 = new_header_frame(schunk, frame);
   if (h2 == NULL) {
     return BLOSC2_ERROR_DATA;
   }
   uint32_t h2len;
-  swap_store(&h2len, h2 + FRAME_HEADER_LEN, sizeof(h2len));
+  big_store(&h2len, h2 + FRAME_HEADER_LEN, sizeof(h2len));
   // Build the offsets chunk
   int32_t chunksize = -1;
   int32_t off_cbytes = 0;
   uint64_t coffset = 0;
   int32_t off_nbytes = nchunks * sizeof(int64_t);
   uint64_t* data_tmp = malloc(off_nbytes);
   bool needs_free = false;
   for (int i = 0; i < nchunks; i++) {
     uint8_t* data_chunk;
     if (frame->sframe) {
       sframe_get_chunk(frame, i, &data_chunk, &needs_free);
     }
     else {
       data_chunk = schunk->data[i];
     }
     int32_t chunk_cbytes = sw32_(data_chunk + BLOSC2_CHUNK_CBYTES);
     data_tmp[i] = coffset;
     coffset += chunk_cbytes;
     int32_t chunksize_ = sw32_(data_chunk + BLOSC2_CHUNK_NBYTES);
     if (i == 0) {
       chunksize = chunksize_;
     }
     else if (chunksize != chunksize_) {
       // Variable size  // TODO: update flags for this (or do not use them at all)
       chunksize = 0;
     }
     if (needs_free) {
       free(data_chunk);
     }
   }
   if ((int64_t)coffset != cbytes) {
     free(data_tmp);
     return BLOSC2_ERROR_DATA;
   }
   uint8_t *off_chunk = NULL;
   if (nchunks > 0) {
     // Compress the chunk of offsets
     off_chunk = malloc(off_nbytes + BLOSC_MAX_OVERHEAD);
     blosc2_context *cctx = blosc2_create_cctx(BLOSC2_CPARAMS_DEFAULTS);
     cctx->typesize = sizeof(int64_t);
     off_cbytes = blosc2_compress_ctx(cctx, data_tmp, off_nbytes, off_chunk,
                                      off_nbytes + BLOSC_MAX_OVERHEAD);
     blosc2_free_ctx(cctx);
     if (off_cbytes < 0) {
       free(off_chunk);
       free(h2);
       return off_cbytes;
     }
   }
   else {
     off_cbytes = 0;
   }
   free(data_tmp);
 
   // Now that we know them, fill the chunksize and frame length in header
-  swap_store(h2 + FRAME_CHUNKSIZE, &chunksize, sizeof(chunksize));
-  frame->len = h2len + cbytes + off_cbytes + FRAME_TRAILER_MINLEN + schunk->usermeta_len;
+  big_store(h2 + FRAME_CHUNKSIZE, &chunksize, sizeof(chunksize));
+  frame->len = h2len + cbytes + off_cbytes + FRAME_TRAILER_MINLEN;
   if (frame->sframe) {
-    frame->len = h2len + off_cbytes + FRAME_TRAILER_MINLEN + schunk->usermeta_len;
+    frame->len = h2len + off_cbytes + FRAME_TRAILER_MINLEN;
   }
   int64_t tbytes = frame->len;
-  swap_store(h2 + FRAME_LEN, &tbytes, sizeof(tbytes));
+  big_store(h2 + FRAME_LEN, &tbytes, sizeof(tbytes));
 
   // Create the frame and put the header at the beginning
   if (frame->urlpath == NULL) {
     frame->cframe = malloc((size_t)frame->len);
     memcpy(frame->cframe, h2, h2len);
   }
   else {
     if (frame->sframe) {
       fp = sframe_open_index(frame->urlpath, "wb");
     }
     else {
       fp = fopen(frame->urlpath, "wb");
     }
     fwrite(h2, h2len, 1, fp);
   }
   free(h2);
 
   // Fill the frame with the actual data chunks
   if (!frame->sframe) {
     coffset = 0;
     for (int i = 0; i < nchunks; i++) {
       uint8_t* data_chunk = schunk->data[i];
       int32_t chunk_cbytes = sw32_(data_chunk + BLOSC2_CHUNK_CBYTES);
       if (frame->urlpath == NULL) {
         memcpy(frame->cframe + h2len + coffset, data_chunk, (size_t)chunk_cbytes);
       } else {
         fwrite(data_chunk, (size_t)chunk_cbytes, 1, fp);
       }
       coffset += chunk_cbytes;
     }
     if ((int64_t)coffset != cbytes) {
       return BLOSC2_ERROR_FAILURE;
     }
   }
 
   // Copy the offsets chunk at the end of the frame
   if (frame->urlpath == NULL) {
     memcpy(frame->cframe + h2len + cbytes, off_chunk, off_cbytes);
   }
   else {
     fwrite(off_chunk, (size_t)off_cbytes, 1, fp);
     fclose(fp);
   }
   free(off_chunk);
   int rc = frame_update_trailer(frame, schunk);
   if (rc < 0) {
     return rc;
   }
 
   return frame->len;
 }
 
 
 // Get the compressed data offsets
@@ -922,275 +1075,189 @@ uint8_t* get_coffsets(blosc2_frame_s *frame, int32_t header_len, int64_t cbytes,
 int frame_update_header(blosc2_frame_s* frame, blosc2_schunk* schunk, bool new) {
   uint8_t* framep = frame->cframe;
   uint8_t header[FRAME_HEADER_MINLEN];
 
   if (frame->len <= 0) {
     return BLOSC2_ERROR_INVALID_PARAM;
   }
 
   if (new && schunk->cbytes > 0) {
     BLOSC_TRACE_ERROR("New metalayers cannot be added after actual data "
                       "has been appended.");
     return BLOSC2_ERROR_INVALID_PARAM;
   }
 
   if (frame->cframe == NULL) {
     size_t rbytes = 0;
     FILE* fp = NULL;
     if (frame->sframe) {
       fp = sframe_open_index(frame->urlpath, "rb+");
     }
     else {
       fp = fopen(frame->urlpath, "rb");
     }
     if (fp != NULL) {
       rbytes = fread(header, 1, FRAME_HEADER_MINLEN, fp);
       fclose(fp);
     }
     (void) rbytes;
     if (rbytes != FRAME_HEADER_MINLEN) {
       return BLOSC2_ERROR_FILE_WRITE;
     }
     framep = header;
   }
   uint32_t prev_h2len;
-  swap_store(&prev_h2len, framep + FRAME_HEADER_LEN, sizeof(prev_h2len));
+  big_store(&prev_h2len, framep + FRAME_HEADER_LEN, sizeof(prev_h2len));
 
   // Build a new header
   uint8_t* h2 = new_header_frame(schunk, frame);
   uint32_t h2len;
-  swap_store(&h2len, h2 + FRAME_HEADER_LEN, sizeof(h2len));
+  big_store(&h2len, h2 + FRAME_HEADER_LEN, sizeof(h2len));
 
   // The frame length is outdated when adding a new metalayer, so update it
   if (new) {
     int64_t frame_len = h2len;  // at adding time, we only have to worry of the header for now
-    swap_store(h2 + FRAME_LEN, &frame_len, sizeof(frame_len));
+    big_store(h2 + FRAME_LEN, &frame_len, sizeof(frame_len));
     frame->len = frame_len;
   }
 
   if (!new && prev_h2len != h2len) {
     BLOSC_TRACE_ERROR("The new metalayer sizes should be equal the existing ones.");
     return BLOSC2_ERROR_DATA;
   }
 
   FILE* fp = NULL;
   if (frame->cframe == NULL) {
     // Write updated header down to file
     if (frame->sframe) {
       fp = sframe_open_index(frame->urlpath, "rb+");
     }
     else {
       fp = fopen(frame->urlpath, "rb+");
     }
     if (fp != NULL) {
       fwrite(h2, h2len, 1, fp);
       fclose(fp);
     }
   }
   else {
     if (new) {
       frame->cframe = realloc(frame->cframe, h2len);
     }
     memcpy(frame->cframe, h2, h2len);
   }
   free(h2);
 
   return 1;
 }
 
 
-/* Get the (compressed) usermeta chunk out of a frame */
-int32_t frame_get_usermeta(blosc2_frame_s* frame, uint8_t** usermeta) {
-  int32_t header_len;
-  int64_t frame_len;
-  int64_t nbytes;
-  int64_t cbytes;
-  int32_t chunksize;
-  int32_t nchunks;
-  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
-                            NULL, NULL, NULL, NULL, NULL);
-  if (ret < 0) {
-    BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
-    return ret;
-  }
-  int64_t trailer_offset = get_trailer_offset(frame, header_len, nbytes > 0);
-  if (trailer_offset < 0) {
-    BLOSC_TRACE_ERROR("Unable to get the trailer offset from frame.");
-    return BLOSC2_ERROR_INVALID_HEADER;
-  }
-  if (trailer_offset + FRAME_TRAILER_USERMETA_LEN_OFFSET + (signed)sizeof(int32_t) > frame_len) {
-    BLOSC_TRACE_ERROR("Invalid trailer offset exceeds frame length.");
-    return BLOSC2_ERROR_READ_BUFFER;
-  }
-
-  // Get the size of usermeta (inside the trailer)
-  int32_t usermeta_len_network;
-  if (frame->cframe != NULL) {
-    memcpy(&usermeta_len_network, frame->cframe + trailer_offset + FRAME_TRAILER_USERMETA_LEN_OFFSET, sizeof(int32_t));
-  }
-  else {
-    FILE* fp = NULL;
-    if (frame->sframe) {
-      fp = sframe_open_index(frame->urlpath, "rb");
-    }
-    else {
-      fp = fopen(frame->urlpath, "rb");
-    }
-    fseek(fp, trailer_offset + FRAME_TRAILER_USERMETA_LEN_OFFSET, SEEK_SET);
-    size_t rbytes = fread(&usermeta_len_network, 1, sizeof(int32_t), fp);
-    fclose(fp);
-    if (rbytes != sizeof(int32_t)) {
-      BLOSC_TRACE_ERROR("Cannot access the usermeta_len out of the frame.");
-      return BLOSC2_ERROR_READ_BUFFER;
-    }
-  }
-  int32_t usermeta_len;
-  swap_store(&usermeta_len, &usermeta_len_network, sizeof(int32_t));
-
-  if (usermeta_len < 0) {
-    BLOSC_TRACE_ERROR("Invalid usermeta length.");
-    return BLOSC2_ERROR_READ_BUFFER;
-  }
-  if (usermeta_len == 0) {
-    *usermeta = NULL;
-    return 0;
-  }
-  if (trailer_offset + FRAME_TRAILER_USERMETA_OFFSET + usermeta_len > frame_len) {
-    BLOSC_TRACE_ERROR("Invalid usermeta offset exceeds frame length.");
-    return BLOSC2_ERROR_INVALID_HEADER;
-  }
-
-  *usermeta = malloc(usermeta_len);
-  if (frame->cframe != NULL) {
-    memcpy(*usermeta, frame->cframe + trailer_offset + FRAME_TRAILER_USERMETA_OFFSET, usermeta_len);
-  }
-  else {
-    FILE* fp = NULL;
-    if (frame->sframe) {
-      fp = sframe_open_index(frame->urlpath, "rb+");
-    }
-    else {
-      fp = fopen(frame->urlpath, "rb+");
-    }
-    fseek(fp, trailer_offset + FRAME_TRAILER_USERMETA_OFFSET, SEEK_SET);
-    size_t rbytes = fread(*usermeta, 1, usermeta_len, fp);
-    fclose(fp);
-    if (rbytes != (size_t)usermeta_len) {
-      BLOSC_TRACE_ERROR("Cannot read the complete usermeta chunk in frame. %ld != %ld.",
-              (long)rbytes, (long)usermeta_len);
-      return BLOSC2_ERROR_READ_BUFFER;
-    }
-  }
-
-  return usermeta_len;
-}
-
 static int frame_get_metalayers_from_header(blosc2_frame_s* frame, blosc2_schunk* schunk, uint8_t* header,
                                             int32_t header_len) {
   int64_t header_pos = FRAME_IDX_SIZE;
 
   // Get the size for the index of metalayers
   uint16_t idx_size;
   header_pos += sizeof(idx_size);
   if (header_len < header_pos) {
     return BLOSC2_ERROR_READ_BUFFER;
   }
-  swap_store(&idx_size, header + FRAME_IDX_SIZE, sizeof(idx_size));
+  big_store(&idx_size, header + FRAME_IDX_SIZE, sizeof(idx_size));
 
   // Get the actual index of metalayers
   uint8_t* metalayers_idx = header + FRAME_IDX_SIZE + 2;
   header_pos += 1;
   if (header_len < header_pos) {
     return BLOSC2_ERROR_READ_BUFFER;
   }
   if (metalayers_idx[0] != 0xde) {   // sanity check
     return BLOSC2_ERROR_DATA;
   }
   uint8_t* idxp = metalayers_idx + 1;
   uint16_t nmetalayers;
   header_pos += sizeof(nmetalayers);
   if (header_len < header_pos) {
     return BLOSC2_ERROR_READ_BUFFER;
   }
-  swap_store(&nmetalayers, idxp, sizeof(uint16_t));
+  big_store(&nmetalayers, idxp, sizeof(uint16_t));
   idxp += 2;
   if (nmetalayers < 0 || nmetalayers > BLOSC2_MAX_METALAYERS) {
     return BLOSC2_ERROR_DATA;
   }
   schunk->nmetalayers = nmetalayers;
 
   // Populate the metalayers and its serialized values
   for (int nmetalayer = 0; nmetalayer < nmetalayers; nmetalayer++) {
     header_pos += 1;
     if (header_len < header_pos) {
       return BLOSC2_ERROR_READ_BUFFER;
     }
     if ((*idxp & 0xe0u) != 0xa0u) {   // sanity check
       return BLOSC2_ERROR_DATA;
     }
     blosc2_metalayer* metalayer = calloc(sizeof(blosc2_metalayer), 1);
     schunk->metalayers[nmetalayer] = metalayer;
 
     // Populate the metalayer string
     int8_t nslen = *idxp & (uint8_t)0x1F;
     idxp += 1;
     header_pos += nslen;
     if (header_len < header_pos) {
       return BLOSC2_ERROR_READ_BUFFER;
     }
     char* ns = malloc((size_t)nslen + 1);
     memcpy(ns, idxp, nslen);
     ns[nslen] = '\0';
     idxp += nslen;
     metalayer->name = ns;
 
     // Populate the serialized value for this metalayer
     // Get the offset
     header_pos += 1;
     if (header_len < header_pos) {
       return BLOSC2_ERROR_READ_BUFFER;
     }
     if ((*idxp & 0xffu) != 0xd2u) {   // sanity check
       return BLOSC2_ERROR_DATA;
     }
     idxp += 1;
     int32_t offset;
     header_pos += sizeof(offset);
     if (header_len < header_pos) {
       return BLOSC2_ERROR_READ_BUFFER;
     }
-    swap_store(&offset, idxp, sizeof(offset));
+    big_store(&offset, idxp, sizeof(offset));
     idxp += 4;
     if (offset < 0 || offset >= header_len) {
       // Offset is less than zero or exceeds header length
       return BLOSC2_ERROR_DATA;
     }
     // Go to offset and see if we have the correct marker
     uint8_t* content_marker = header + offset;
     if (*content_marker != 0xc6) {
       return BLOSC2_ERROR_DATA;
     }
 
     // Read the size of the content
     int32_t content_len;
     header_pos += sizeof(content_len);
     if (header_len < header_pos) {
       return BLOSC2_ERROR_READ_BUFFER;
     }
-    swap_store(&content_len, content_marker + 1, sizeof(content_len));
+    big_store(&content_len, content_marker + 1, sizeof(content_len));
     if (content_len < 0) {
       return BLOSC2_ERROR_DATA;
     }
     metalayer->content_len = content_len;
 
     // Finally, read the content
     header_pos += content_len;
     if (header_len < header_pos) {
       return BLOSC2_ERROR_READ_BUFFER;
     }
     char* content = malloc((size_t)content_len);
     memcpy(content, content_marker + 1 + 4, (size_t)content_len);
     metalayer->content = (uint8_t*)content;
   }
 
   return 1;
 }
@@ -1198,51 +1265,214 @@ static int frame_get_metalayers_from_header(blosc2_frame_s* frame, blosc2_schunk
 int frame_get_metalayers(blosc2_frame_s* frame, blosc2_schunk* schunk) {
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t chunksize;
   int32_t nchunks;
   int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                             NULL, NULL, NULL, NULL, NULL);
   if (ret < 0) {
     BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
     return ret;
   }
 
   // Get the header
   uint8_t* header = NULL;
   if (frame->cframe != NULL) {
     header = frame->cframe;
   } else {
     size_t rbytes = 0;
     header = malloc(header_len);
     FILE* fp = NULL;
     if (frame->sframe) {
       fp = sframe_open_index(frame->urlpath, "rb");
     }
     else {
       fp = fopen(frame->urlpath, "rb");
     }
     if (fp != NULL) {
       rbytes = fread(header, 1, header_len, fp);
       fclose(fp);
     }
     if (rbytes != (size_t) header_len) {
       BLOSC_TRACE_ERROR("Cannot access the header out of the frame.");
       free(header);
       return BLOSC2_ERROR_FILE_READ;
     }
   }
 
   ret = frame_get_metalayers_from_header(frame, schunk, header, header_len);
 
   if (frame->cframe == NULL) {
     free(header);
   }
 
   return ret;
 }
 
+static int frame_get_vlmetalayers_from_trailer(blosc2_frame* frame, blosc2_schunk* schunk, uint8_t* trailer,
+                                               int32_t trailer_len) {
+  int64_t trailer_pos = FRAME_TRAILER_VLMETALAYERS;
+
+  // Get the size for the index of metalayers
+  uint16_t idx_size;
+  trailer_pos += 2 + sizeof(idx_size);
+  if (trailer_len < trailer_pos) {
+    return BLOSC2_ERROR_READ_BUFFER;
+  }
+  big_store(&idx_size, trailer + FRAME_TRAILER_VLMETALAYERS + 2, sizeof(idx_size));
+
+  // Get the actual index of metalayers
+  uint8_t* metalayers_idx = trailer + FRAME_TRAILER_VLMETALAYERS + 4;
+  trailer_pos += 1;
+  if (trailer_len < trailer_pos) {
+    return BLOSC2_ERROR_READ_BUFFER;
+  }
+  if (metalayers_idx[0] != 0xde) {   // sanity check
+    return BLOSC2_ERROR_DATA;
+  }
+  uint8_t* idxp = metalayers_idx + 1;
+  uint16_t nmetalayers;
+  trailer_pos += sizeof(nmetalayers);
+  if (trailer_len < trailer_pos) {
+    return BLOSC2_ERROR_READ_BUFFER;
+  }
+  big_store(&nmetalayers, idxp, sizeof(uint16_t));
+  idxp += 2;
+  if (nmetalayers < 0 || nmetalayers > BLOSC2_MAX_VLMETALAYERS) {
+    return BLOSC2_ERROR_DATA;
+  }
+  schunk->nvlmetalayers = nmetalayers;
+
+  // Populate the metalayers and its serialized values
+  for (int nmetalayer = 0; nmetalayer < nmetalayers; nmetalayer++) {
+    trailer_pos += 1;
+    if (trailer_len < trailer_pos) {
+      return BLOSC2_ERROR_READ_BUFFER;
+    }
+    if ((*idxp & 0xe0u) != 0xa0u) {   // sanity check
+      return BLOSC2_ERROR_DATA;
+    }
+    blosc2_metalayer* metalayer = calloc(sizeof(blosc2_metalayer), 1);
+    schunk->vlmetalayers[nmetalayer] = metalayer;
+
+    // Populate the metalayer string
+    int8_t nslen = *idxp & (uint8_t)0x1F;
+    idxp += 1;
+    trailer_pos += nslen;
+    if (trailer_len < trailer_pos) {
+      return BLOSC2_ERROR_READ_BUFFER;
+    }
+    char* ns = malloc((size_t)nslen + 1);
+    memcpy(ns, idxp, nslen);
+    ns[nslen] = '\0';
+    idxp += nslen;
+    metalayer->name = ns;
+
+    // Populate the serialized value for this metalayer
+    // Get the offset
+    trailer_pos += 1;
+    if (trailer_len < trailer_pos) {
+      return BLOSC2_ERROR_READ_BUFFER;
+    }
+    if ((*idxp & 0xffu) != 0xd2u) {   // sanity check
+      return BLOSC2_ERROR_DATA;
+    }
+    idxp += 1;
+    int32_t offset;
+    trailer_pos += sizeof(offset);
+    if (trailer_len < trailer_pos) {
+      return BLOSC2_ERROR_READ_BUFFER;
+    }
+    big_store(&offset, idxp, sizeof(offset));
+    idxp += 4;
+    if (offset < 0 || offset >= trailer_len) {
+      // Offset is less than zero or exceeds trailer length
+      return BLOSC2_ERROR_DATA;
+    }
+    // Go to offset and see if we have the correct marker
+    uint8_t* content_marker = trailer + offset;
+    if (*content_marker != 0xc6) {
+      return BLOSC2_ERROR_DATA;
+    }
+
+    // Read the size of the content
+    int32_t content_len;
+    trailer_pos += sizeof(content_len);
+    if (trailer_len < trailer_pos) {
+      return BLOSC2_ERROR_READ_BUFFER;
+    }
+    big_store(&content_len, content_marker + 1, sizeof(content_len));
+    metalayer->content_len = content_len;
+
+    // Finally, read the content
+    trailer_pos += content_len;
+    if (trailer_len < trailer_pos) {
+      return BLOSC2_ERROR_READ_BUFFER;
+    }
+    char* content = malloc((size_t)content_len);
+    memcpy(content, content_marker + 1 + 4, (size_t)content_len);
+    metalayer->content = (uint8_t*)content;
+  }
+  return 1;
+}
+
+int frame_get_vlmetalayers(blosc2_frame_s* frame, blosc2_schunk* schunk) {
+  int32_t header_len;
+  int64_t frame_len;
+  int64_t nbytes;
+  int64_t cbytes;
+  int32_t chunksize;
+  int32_t nchunks;
+  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
+                            NULL, NULL, NULL, NULL, NULL);
+  if (ret < 0) {
+    BLOSC_TRACE_ERROR("Unable to get the trailer info from frame.");
+    return ret;
+  }
+
+
+  int32_t trailer_offset = get_trailer_offset(frame, header_len, nbytes > 0);
+  int32_t trailer_len = frame->trailer_len;
+
+  // Get the trailer
+  uint8_t* trailer = NULL;
+  if (frame->cframe != NULL) {
+    trailer = frame->cframe + trailer_offset;
+  } else {
+    size_t rbytes = 0;
+    trailer = malloc(trailer_len);
+    FILE* fp = NULL;
+    if (frame->sframe) {
+      char* eframe_name = malloc(strlen(frame->urlpath) + strlen("/chunks.b2frame") + 1);
+      sprintf(eframe_name, "%s/chunks.b2frame", frame->urlpath);
+      fp = fopen(eframe_name, "rb");
+      free(eframe_name);
+    }
+    else {
+      fp = fopen(frame->urlpath, "rb");
+    }
+    if (fp != NULL) {
+      fseek(fp, trailer_offset, SEEK_SET);
+      rbytes = fread(trailer, 1, trailer_len, fp);
+      fclose(fp);
+    }
+    if (rbytes != (size_t) trailer_len) {
+      BLOSC_TRACE_ERROR("Cannot access the trailer out of the fileframe.");
+      free(trailer);
+      return BLOSC2_ERROR_FILE_READ;
+    }
+  }
+
+  ret = frame_get_vlmetalayers_from_trailer(frame, schunk, trailer, trailer_len);
+
+  if (frame->cframe == NULL) {
+    free(trailer);
+  }
+
+  return ret;
+}
+
 
 blosc2_storage* get_new_storage(const blosc2_storage* storage, const blosc2_cparams* cdefaults,
                                 const blosc2_dparams* ddefaults) {
@@ -1281,187 +1511,182 @@ blosc2_storage* get_new_storage(const blosc2_storage* storage, const blosc2_cpar
 /* Get a super-chunk out of a frame */
 blosc2_schunk* frame_to_schunk(blosc2_frame_s* frame, bool copy) {
   int32_t header_len;
   int64_t frame_len;
 
   blosc2_schunk* schunk = calloc(1, sizeof(blosc2_schunk));
   schunk->frame = (blosc2_frame*)frame;
   int ret = get_header_info(frame, &header_len, &frame_len, &schunk->nbytes, &schunk->cbytes,
                             &schunk->chunksize, &schunk->nchunks, &schunk->typesize,
                             &schunk->compcode, &schunk->clevel, schunk->filters, schunk->filters_meta);
   if (ret < 0) {
     BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
     blosc2_schunk_free(schunk);
     return NULL;
   }
   int32_t nchunks = schunk->nchunks;
   int64_t nbytes = schunk->nbytes;
   (void) nbytes;
   int64_t cbytes = schunk->cbytes;
 
   // Compression and decompression contexts
   blosc2_cparams *cparams;
   blosc2_schunk_get_cparams(schunk, &cparams);
   schunk->cctx = blosc2_create_cctx(*cparams);
   blosc2_dparams *dparams;
   blosc2_schunk_get_dparams(schunk, &dparams);
   schunk->dctx = blosc2_create_dctx(*dparams);
   blosc2_storage storage = {.contiguous = copy ? false : true};
   schunk->storage = get_new_storage(&storage, cparams, dparams);
   free(cparams);
   free(dparams);
 
   if (!copy) {
     goto out;
   }
 
   // We are not attached to a frame anymore
   schunk->frame = NULL;
 
   if (nchunks == 0) {
     goto out;
   }
 
   // Get the compressed offsets
   int32_t coffsets_cbytes = 0;
   uint8_t* coffsets = get_coffsets(frame, header_len, cbytes, &coffsets_cbytes);
   if (coffsets == NULL) {
     blosc2_schunk_free(schunk);
     BLOSC_TRACE_ERROR("Cannot get the offsets for the frame.");
     return NULL;
   }
 
   // Decompress offsets
   blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_context *dctx = blosc2_create_dctx(off_dparams);
   int64_t* offsets = (int64_t *) malloc((size_t)nchunks * 8);
   int32_t off_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes,
                                              offsets, nchunks * sizeof(int64_t));
   blosc2_free_ctx(dctx);
   if (off_nbytes < 0) {
     free(offsets);
     blosc2_schunk_free(schunk);
     BLOSC_TRACE_ERROR("Cannot decompress the offsets chunk.");
     return NULL;
   }
 
   // We want the contiguous schunk, so create the actual data chunks (and, while doing this,
   // get a guess at the blocksize used in this frame)
   int64_t acc_nbytes = 0;
   int64_t acc_cbytes = 0;
   int32_t blocksize = 0;
   int32_t csize = 0;
   uint8_t* data_chunk = NULL;
   int32_t prev_alloc = BLOSC_MIN_HEADER_LENGTH;
   FILE* fp = NULL;
   if (frame->cframe == NULL) {
     data_chunk = malloc((size_t)prev_alloc);
     if (!frame->sframe) {
       // If not the chunks won't be in the frame
       fp = fopen(frame->urlpath, "rb");
       if (fp == NULL) {
         free(data_chunk);
         free(offsets);
         blosc2_schunk_free(schunk);
         return NULL;
       }
     }
   }
   schunk->data = malloc(nchunks * sizeof(void*));
   for (int i = 0; i < nchunks; i++) {
     if (frame->cframe != NULL) {
       data_chunk = frame->cframe + header_len + offsets[i];
       csize = sw32_(data_chunk + BLOSC2_CHUNK_CBYTES);
     }
     else {
       size_t rbytes;
       bool needs_free = false;
       if (frame->sframe) {
         rbytes = sframe_get_chunk(frame, offsets[i], &data_chunk, &needs_free);
       }
       else {
         fseek(fp, header_len + offsets[i], SEEK_SET);
         rbytes = fread(data_chunk, 1, BLOSC_MIN_HEADER_LENGTH, fp);
         if (rbytes != BLOSC_MIN_HEADER_LENGTH) {
           fclose(fp);
           return NULL;
         }
       }
       if (rbytes != BLOSC_MIN_HEADER_LENGTH) {
         if (frame->sframe) {
           free(data_chunk);
         }
         else {
           fclose(fp);
         }
         free(offsets);
         blosc2_schunk_free(schunk);
         return NULL;
       }
       csize = sw32_(data_chunk + BLOSC2_CHUNK_CBYTES);
       if (csize > prev_alloc) {
         data_chunk = realloc(data_chunk, (size_t)csize);
         prev_alloc = csize;
       }
       if (!frame->sframe) {
         fseek(fp, header_len + offsets[i], SEEK_SET);
         rbytes = fread(data_chunk, 1, (size_t)csize, fp);
         if (rbytes != (size_t)csize) {
           fclose(fp);
           free(offsets);
           blosc2_schunk_free(schunk);
           return NULL;
         }
       }
     }
     uint8_t* new_chunk = malloc((size_t)csize);
     memcpy(new_chunk, data_chunk, (size_t)csize);
     schunk->data[i] = new_chunk;
     acc_nbytes += sw32_(data_chunk + BLOSC2_CHUNK_NBYTES);
     acc_cbytes += csize;
     int32_t blocksize_ = sw32_(data_chunk + BLOSC2_CHUNK_BLOCKSIZE);
     if (i == 0) {
       blocksize = blocksize_;
     }
     else if (blocksize != blocksize_) {
       // Blocksize varies
       blocksize = 0;
     }
   }
   schunk->blocksize = blocksize;
 
   if (frame->cframe == NULL) {
     free(data_chunk);
     if (!frame->sframe) {
       fclose(fp);
     }
   }
   free(offsets);
 
   if (acc_nbytes != nbytes || acc_cbytes != cbytes) {
     blosc2_schunk_free(schunk);
     return NULL;
   }
 
-  uint8_t* usermeta;
-  int32_t usermeta_len;
-
   int rc;
   out:
   rc = frame_get_metalayers(frame, schunk);
   if (rc < 0) {
     blosc2_schunk_free(schunk);
     BLOSC_TRACE_ERROR("Cannot access the metalayers.");
     return NULL;
   }
 
-  usermeta_len = frame_get_usermeta(frame, &usermeta);
-  if (usermeta_len < 0) {
+  rc = frame_get_vlmetalayers(frame, schunk);
+  if (rc < 0) {
     blosc2_schunk_free(schunk);
-    BLOSC_TRACE_ERROR("Cannot access the usermeta chunk.");
+    BLOSC_TRACE_ERROR("Cannot access the vlmetalayers.");
     return NULL;
   }
-  schunk->usermeta = usermeta;
-  schunk->usermeta_len = usermeta_len;
 
   return schunk;
 }
@@ -1480,21 +1705,23 @@ int sort_offset(const void* a, const void* b) {
 }
 
 
-int get_coffset(blosc2_frame_s* frame, int32_t header_len, int64_t cbytes, int32_t nchunk, int64_t *offset) {
+int64_t get_coffset(blosc2_frame_s* frame, int32_t header_len, int64_t cbytes, int32_t nchunk) {
   // Get the offset to nchunk
+  int64_t offset;
   uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, NULL);
   if (coffsets == NULL) {
     BLOSC_TRACE_ERROR("Cannot get the offset for chunk %d for the frame.", nchunk);
     return BLOSC2_ERROR_DATA;
   }
 
   // Get the 64-bit offset
-  int rc = blosc_getitem(coffsets, nchunk, 1, offset);
+  int rc = blosc_getitem(coffsets, nchunk, 1, &offset);
   if (rc < 0) {
     BLOSC_TRACE_ERROR("Problems retrieving a chunk offset.");
+    return rc;
   }
-  return rc;
+  return offset;
 }
 
 
 // Detect and return a chunk with special values in offsets (only zeros and NaNs)
@@ -1537,434 +1764,424 @@ int frame_special_chunk(int64_t special_value, int32_t nbytes, int32_t typesize,
 /* Return a compressed chunk that is part of a frame in the `chunk` parameter.
  * If the frame is disk-based, a buffer is allocated for the (compressed) chunk,
  * and hence a free is needed.  You can check if the chunk requires a free with the `needs_free`
  * parameter.
  * If the chunk does not need a free, it means that a pointer to the location in frame is returned
  * in the `chunk` parameter.
  *
  * The size of the (compressed) chunk is returned.  If some problem is detected, a negative code
  * is returned instead.
 */
 int frame_get_chunk(blosc2_frame_s *frame, int nchunk, uint8_t **chunk, bool *needs_free) {
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t chunksize;
   int32_t nchunks;
   int32_t typesize;
   int32_t chunk_cbytes;
-  int64_t offset;
 
   *chunk = NULL;
   *needs_free = false;
   int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                             &typesize, NULL, NULL, NULL, NULL);
   if (ret < 0) {
     BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
     return ret;
   }
 
   if (nchunk >= nchunks) {
     BLOSC_TRACE_ERROR("nchunk ('%d') exceeds the number of chunks "
                     "('%d') in frame.", nchunk, nchunks);
     return BLOSC2_ERROR_INVALID_PARAM;
   }
 
   // Get the offset to nchunk
-  ret = get_coffset(frame, header_len, cbytes, nchunk, &offset);
-  if (ret < 0) {
-    BLOSC_TRACE_ERROR("Unable to get offset to chunk %d.", nchunk);
-    return ret;
-  }
+  int64_t offset = get_coffset(frame, header_len, cbytes, nchunk);
 
   if (offset < 0) {
     // Special value
     chunk_cbytes = BLOSC_EXTENDED_HEADER_LENGTH;
     int rc = frame_special_chunk(offset, chunksize, typesize, chunk, chunk_cbytes, needs_free);
     if (rc < 0) {
       return rc;
     }
     goto end;
   }
 
   if (frame->sframe) {
     // Sparse on-disk
     nchunk = offset;
     return sframe_get_chunk(frame, nchunk, chunk, needs_free);
   }
   if (frame->cframe == NULL) {
     FILE* fp = fopen(frame->urlpath, "rb");
     fseek(fp, header_len + offset + BLOSC2_CHUNK_CBYTES, SEEK_SET);
     size_t rbytes = fread(&chunk_cbytes, 1, sizeof(chunk_cbytes), fp);
     if (rbytes != sizeof(chunk_cbytes)) {
       BLOSC_TRACE_ERROR("Cannot read the cbytes for chunk in the frame.");
       fclose(fp);
       return BLOSC2_ERROR_FILE_READ;
     }
     chunk_cbytes = sw32_(&chunk_cbytes);
     *chunk = malloc((size_t)chunk_cbytes);
     fseek(fp, header_len + offset, SEEK_SET);
     rbytes = fread(*chunk, 1, (size_t)chunk_cbytes, fp);
     fclose(fp);
     if (rbytes != (size_t)chunk_cbytes) {
       BLOSC_TRACE_ERROR("Cannot read the chunk out of the frame.");
       return BLOSC2_ERROR_FILE_READ;
     }
     *needs_free = true;
   } else {
     // The chunk is in memory and just one pointer away
     *chunk = frame->cframe + header_len + offset;
     chunk_cbytes = sw32_(*chunk + BLOSC2_CHUNK_CBYTES);
   }
 
   end:
   return chunk_cbytes;
 }
 
 
 /* Return a compressed chunk that is part of a frame in the `chunk` parameter.
  * If the frame is disk-based, a buffer is allocated for the (lazy) chunk,
  * and hence a free is needed.  You can check if the chunk requires a free with the `needs_free`
  * parameter.
  * If the chunk does not need a free, it means that the frame is in memory and that just a
  * pointer to the location of the chunk in memory is returned.
  *
  * The size of the (compressed, potentially lazy) chunk is returned.  If some problem is detected,
  * a negative code is returned instead.
 */
 int frame_get_lazychunk(blosc2_frame_s *frame, int nchunk, uint8_t **chunk, bool *needs_free) {
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t chunksize;
   int32_t nchunks;
   int32_t typesize;
   size_t lazychunk_cbytes;
-  int64_t offset;
 
   *chunk = NULL;
   *needs_free = false;
   int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                             &typesize, NULL, NULL, NULL, NULL);
   if (ret < 0) {
     BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
     return ret;
   }
 
   if (nchunk >= nchunks) {
     BLOSC_TRACE_ERROR("nchunk ('%d') exceeds the number of chunks "
                       "('%d') in frame.", nchunk, nchunks);
     return BLOSC2_ERROR_INVALID_PARAM;
   }
 
   // Get the offset to nchunk
-  ret = get_coffset(frame, header_len, cbytes, nchunk, &offset);
-  if (ret < 0) {
-    BLOSC_TRACE_ERROR("Unable to get offset to chunk %d.", nchunk);
-    return ret;
-  }
+  int64_t offset = get_coffset(frame, header_len, cbytes, nchunk);
 
   if (offset < 0) {
     // Special value
     lazychunk_cbytes = BLOSC_EXTENDED_HEADER_LENGTH;
     int rc = frame_special_chunk(offset, chunksize, typesize, chunk,
                                  (int32_t)lazychunk_cbytes, needs_free);
     if (rc < 0) {
       return rc;
     }
     goto end;
   }
 
   if (frame->cframe == NULL) {
     // TODO: make this portable across different endianness
     // Get info for building a lazy chunk
     size_t chunk_nbytes;
     size_t chunk_cbytes;
     size_t chunk_blocksize;
     uint8_t header[BLOSC_MIN_HEADER_LENGTH];
     FILE* fp = NULL;
     if (frame->sframe) {
       // The chunk is not in the frame
       fp = sframe_open_chunk(frame->urlpath, offset, "rb");
     }
     else {
       fp = fopen(frame->urlpath, "rb");
       fseek(fp, header_len + offset, SEEK_SET);
     }
     size_t rbytes = fread(header, 1, BLOSC_MIN_HEADER_LENGTH, fp);
     if (rbytes != BLOSC_MIN_HEADER_LENGTH) {
       BLOSC_TRACE_ERROR("Cannot read the header for chunk in the frame.");
       fclose(fp);
       return BLOSC2_ERROR_FILE_READ;
     }
     blosc_cbuffer_sizes(header, &chunk_nbytes, &chunk_cbytes, &chunk_blocksize);
     size_t nblocks = chunk_nbytes / chunk_blocksize;
     size_t leftover_block = chunk_nbytes % chunk_blocksize;
     nblocks = leftover_block ? nblocks + 1 : nblocks;
     // Allocate space for the lazy chunk
     size_t trailer_len = sizeof(int32_t) + sizeof(int64_t) + nblocks * sizeof(int32_t);
     size_t trailer_offset = BLOSC_EXTENDED_HEADER_LENGTH + nblocks * sizeof(int32_t);
     lazychunk_cbytes = trailer_offset + trailer_len;
     *chunk = malloc(lazychunk_cbytes);
     *needs_free = true;
     // Read just the full header and bstarts section too (lazy partial length)
     if (frame->sframe) {
       fseek(fp, 0, SEEK_SET);
     }
     else {
       fseek(fp, header_len + offset, SEEK_SET);
     }
     rbytes = fread(*chunk, 1, trailer_offset, fp);
     fclose(fp);
     if (rbytes != trailer_offset) {
       BLOSC_TRACE_ERROR("Cannot read the (lazy) chunk out of the frame.");
       return BLOSC2_ERROR_FILE_READ;
     }
 
     // Mark chunk as lazy
     uint8_t* blosc2_flags = *chunk + BLOSC2_CHUNK_BLOSC2_FLAGS;
     *blosc2_flags |= 0x08U;
 
     // Add the trailer (currently, nchunk + offset + block_csizes)
     *(int32_t*)(*chunk + trailer_offset) = nchunk;
     *(int64_t*)(*chunk + trailer_offset + sizeof(int32_t)) = header_len + offset;
 
     int32_t* block_csizes = malloc(nblocks * sizeof(int32_t));
 
     int memcpyed = *(*chunk + BLOSC2_CHUNK_FLAGS) & (uint8_t)BLOSC_MEMCPYED;
     if (memcpyed) {
       // When memcpyed the blocksizes are trivial to compute
       for (int i = 0; i < (int)nblocks; i++) {
         block_csizes[i] = (int)chunk_blocksize;
       }
     }
     else {
       // In regular, compressed chunks, we need to sort the bstarts (they can be out
       // of order because of multi-threading), and get a reverse index too.
       memcpy(block_csizes, *chunk + BLOSC_EXTENDED_HEADER_LENGTH, nblocks * sizeof(int32_t));
       // Helper structure to keep track of original indexes
       struct csize_idx *csize_idx = malloc(nblocks * sizeof(struct csize_idx));
       for (int n = 0; n < (int)nblocks; n++) {
         csize_idx[n].val = block_csizes[n];
         csize_idx[n].idx = n;
       }
       qsort(csize_idx, nblocks, sizeof(struct csize_idx), &sort_offset);
       // Compute the actual csizes
       int idx;
       for (int n = 0; n < (int)nblocks - 1; n++) {
         idx = csize_idx[n].idx;
         block_csizes[idx] = csize_idx[n + 1].val - csize_idx[n].val;
       }
       idx = csize_idx[nblocks - 1].idx;
       block_csizes[idx] = (int)chunk_cbytes - csize_idx[nblocks - 1].val;
       free(csize_idx);
     }
     // Copy the csizes at the end of the trailer
     void *trailer_csizes = *chunk + lazychunk_cbytes - nblocks * sizeof(int32_t);
     memcpy(trailer_csizes, block_csizes, nblocks * sizeof(int32_t));
     free(block_csizes);
   } else {
     // The chunk is in memory and just one pointer away
     *chunk = frame->cframe + header_len + offset;
     lazychunk_cbytes = sw32_(*chunk + BLOSC2_CHUNK_CBYTES);
   }
 
   end:
   return (int)lazychunk_cbytes;
 }
 
 
 /* Append an existing chunk into a frame. */
 void* frame_append_chunk(blosc2_frame_s* frame, void* chunk, blosc2_schunk* schunk) {
   int8_t* chunk_ = chunk;
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t chunksize;
   int32_t nchunks;
   int rc = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
   if (rc < 0) {
     BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
     return NULL;
   }
 
   /* The uncompressed and compressed sizes start at byte 4 and 12 */
   int32_t nbytes_chunk = sw32_((uint8_t*)chunk + BLOSC2_CHUNK_NBYTES);
   int32_t cbytes_chunk = sw32_((uint8_t*)chunk + BLOSC2_CHUNK_CBYTES);
 
   if ((nchunks > 0) && (nbytes_chunk > chunksize)) {
     BLOSC_TRACE_ERROR("Appending chunks with a larger chunksize than frame is "
                       "not allowed yet %d != %d.", nbytes_chunk, chunksize);
     return NULL;
   }
 
   // Check that we are not appending a small chunk after another small chunk
   if (chunksize == 0 && (nchunks > 0) && (nbytes_chunk < chunksize)) {
     uint8_t* last_chunk;
     bool needs_free;
     int retcode = frame_get_lazychunk(frame, nchunks - 1, &last_chunk, &needs_free);
     if (retcode < 0) {
       BLOSC_TRACE_ERROR("Cannot get the last chunk (in position %d).",
                         nchunks - 1);
       return NULL;
     }
     int32_t last_nbytes = sw32_(last_chunk + BLOSC2_CHUNK_NBYTES);
     if (needs_free) {
       free(last_chunk);
     }
     if ((last_nbytes < chunksize) && (nbytes < chunksize)) {
       BLOSC_TRACE_ERROR("Appending two consecutive chunks with a chunksize smaller "
                         "than the frame chunksize is not allowed yet: %d != %d.",
                         nbytes_chunk, chunksize);
       return NULL;
     }
   }
 
   // Get the current offsets and add one more
   int32_t off_nbytes = (nchunks + 1) * sizeof(int64_t);
   int64_t* offsets = (int64_t *) malloc((size_t)off_nbytes);
   if (nchunks > 0) {
     int32_t coffsets_cbytes;
     uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, &coffsets_cbytes);
     if (coffsets == NULL) {
       BLOSC_TRACE_ERROR("Cannot get the offsets for the frame.");
       free(offsets);
       return NULL;
     }
     if (coffsets_cbytes == 0) {
       coffsets_cbytes = cbytes;
     }
 
     // Decompress offsets
     blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;
     blosc2_context *dctx = blosc2_create_dctx(off_dparams);
     int32_t prev_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes, offsets,
                                                 nchunks * sizeof(int64_t));
     blosc2_free_ctx(dctx);
     if (prev_nbytes < 0) {
       free(offsets);
       BLOSC_TRACE_ERROR("Cannot decompress the offsets chunk.");
       return NULL;
     }
   }
 
   // Add the new offset
   int special_value = (chunk_[BLOSC2_CHUNK_BLOSC2_FLAGS] & 0x30) >> 4;
   uint64_t offset_value = ((uint64_t)1 << 63);
   switch (special_value) {
     case BLOSC2_ZERO_RUNLEN:
       // Zero chunk.  Code it in a special way.
-      offset_value += (uint64_t)BLOSC2_ZERO_RUNLEN << (8 * 7);  // indicate a chunk of zeros
-      swap_store(offsets + nchunks, &offset_value, sizeof(uint64_t));
+      offset_value += (uint64_t) BLOSC2_ZERO_RUNLEN << (8 * 7);  // indicate a chunk of zeros
+      little_store(offsets + nchunks, &offset_value, sizeof(uint64_t));
       cbytes_chunk = 0;   // we don't need to store the chunk
       break;
     case BLOSC2_NAN_RUNLEN:
       // NaN chunk.  Code it in a special way.
       offset_value += (uint64_t)BLOSC2_NAN_RUNLEN << (8 * 7);  // indicate a chunk of NANs
-      swap_store(offsets + nchunks, &offset_value, sizeof(uint64_t));
+      little_store(offsets + nchunks, &offset_value, sizeof(uint64_t));
       cbytes_chunk = 0;   // we don't need to store the chunk
       break;
     default:
       if (frame->sframe) {
         offsets[nchunks] = nchunks;
       }
       else {
         offsets[nchunks] = cbytes;
       }
   }
 
   // Re-compress the offsets again
   blosc2_context* cctx = blosc2_create_cctx(BLOSC2_CPARAMS_DEFAULTS);
   cctx->typesize = sizeof(int64_t);  // 64-bit offsets
   // The params below have been fine-tuned with the zero_runlen bench
   cctx->nthreads = 4;  // 4 threads seems a decent default for nowadays CPUs
   // cctx->compcode = BLOSC_LZ4;
   void* off_chunk = malloc((size_t)off_nbytes + BLOSC_MAX_OVERHEAD);
   int32_t new_off_cbytes = blosc2_compress_ctx(cctx, offsets, off_nbytes,
                                                off_chunk, off_nbytes + BLOSC_MAX_OVERHEAD);
   blosc2_free_ctx(cctx);
 
   free(offsets);
   if (new_off_cbytes < 0) {
     free(off_chunk);
     return NULL;
   }
 
   int64_t new_cbytes = cbytes + cbytes_chunk;
   int64_t new_frame_len;
   if (frame->sframe) {
     new_frame_len = header_len + 0 + new_off_cbytes + frame->trailer_len;
   }
   else {
     new_frame_len = header_len + new_cbytes + new_off_cbytes + frame->trailer_len;
   }
 
   FILE* fp = NULL;
   if (frame->cframe != NULL) {
     uint8_t* framep = frame->cframe;
     /* Make space for the new chunk and copy it */
     frame->cframe = framep = realloc(framep, (size_t)new_frame_len);
     if (framep == NULL) {
       BLOSC_TRACE_ERROR("Cannot realloc space for the frame.");
       return NULL;
     }
     /* Copy the chunk */
     memcpy(framep + header_len + cbytes, chunk, (size_t)cbytes_chunk);
     /* Copy the offsets */
     memcpy(framep + header_len + new_cbytes, off_chunk, (size_t)new_off_cbytes);
   }
   else {
     size_t wbytes;
     if (frame->sframe) {
       // Update the offsets chunk in the chunks frame
       if (cbytes_chunk != 0) {
         if (sframe_create_chunk(frame, chunk, nchunks, cbytes_chunk) == NULL) {
           BLOSC_TRACE_ERROR("Cannot write the full chunk.");
           return NULL;
         }
       }
       fp = sframe_open_index(frame->urlpath, "rb+");
       fseek(fp, header_len, SEEK_SET);
     }
     else {
       // Regular frame
       fp = fopen(frame->urlpath, "rb+");
       fseek(fp, header_len + cbytes, SEEK_SET);
       wbytes = fwrite(chunk, 1, (size_t)cbytes_chunk, fp);  // the new chunk
       if (wbytes != (size_t)cbytes_chunk) {
         BLOSC_TRACE_ERROR("Cannot write the full chunk to frame.");
         fclose(fp);
         return NULL;
       }
     }
     wbytes = fwrite(off_chunk, 1, (size_t)new_off_cbytes, fp);  // the new offsets
     fclose(fp);
     if (wbytes != (size_t)new_off_cbytes) {
       BLOSC_TRACE_ERROR("Cannot write the offsets to frame.");
       return NULL;
     }
   }
   // Invalidate the cache for chunk offsets
   if (frame->coffsets != NULL) {
     free(frame->coffsets);
     frame->coffsets = NULL;
   }
   free(chunk);  // chunk has always to be a copy when reaching here...
   free(off_chunk);
 
   frame->len = new_frame_len;
   rc = frame_update_header(frame, schunk, false);
   if (rc < 0) {
     return NULL;
   }
 
   rc = frame_update_trailer(frame, schunk);
   if (rc < 0) {
     return NULL;
   }
 
   return frame;
 }
@@ -1973,170 +2190,170 @@ void* frame_append_chunk(blosc2_frame_s* frame, void* chunk, blosc2_schunk* schu
 void* frame_insert_chunk(blosc2_frame_s* frame, int nchunk, void* chunk, blosc2_schunk* schunk) {
   uint8_t* chunk_ = chunk;
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t chunksize;
   int32_t nchunks;
   int rc = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
   if (rc < 0) {
     BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
     return NULL;
   }
 
   int32_t cbytes_chunk = sw32_(chunk_ + BLOSC2_CHUNK_CBYTES);
 
   // Get the current offsets
   int32_t off_nbytes = (nchunks + 1) * 8;
   int64_t* offsets = (int64_t *) malloc((size_t)off_nbytes);
   if (nchunks > 0) {
     int32_t coffsets_cbytes = 0;
     uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, &coffsets_cbytes);
     if (coffsets == NULL) {
       BLOSC_TRACE_ERROR("Cannot get the offsets for the frame.");
       return NULL;
     }
     if (coffsets_cbytes == 0) {
       coffsets_cbytes = cbytes;
     }
 
     // Decompress offsets
     blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;
     blosc2_context *dctx = blosc2_create_dctx(off_dparams);
     int32_t prev_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes, offsets, nchunks * 8);
     blosc2_free_ctx(dctx);
     if (prev_nbytes < 0) {
       free(offsets);
       BLOSC_TRACE_ERROR("Cannot decompress the offsets chunk.");
       return NULL;
     }
   }
 
   // TODO: Improvement: Check if new chunk is smaller than previous one
 
   // Add the new offset
   int special_value = (chunk_[BLOSC2_CHUNK_BLOSC2_FLAGS] & 0x30) >> 4;
   uint64_t offset_value = ((uint64_t)1 << 63);
   switch (special_value) {
     case BLOSC2_ZERO_RUNLEN:
       // Zero chunk.  Code it in a special way.
       offset_value += (uint64_t)BLOSC2_ZERO_RUNLEN << (8 * 7);  // indicate a chunk of zeros
       for (int i = nchunks; i > nchunk; i--) {
         offsets[i] = offsets[i - 1];
       }
-      swap_store(offsets + nchunk, &offset_value, sizeof(uint64_t));
+      little_store(offsets + nchunk, &offset_value, sizeof(uint64_t));
       cbytes_chunk = 0;   // we don't need to store the chunk
           break;
     case BLOSC2_NAN_RUNLEN:
       // NaN chunk.  Code it in a special way.
       offset_value += (uint64_t)BLOSC2_NAN_RUNLEN << (8 * 7);  // indicate a chunk of NANs
       for (int i = nchunks; i > nchunk; i--) {
         offsets[i] = offsets[i - 1];
       }
-      swap_store(offsets + nchunk, &offset_value, sizeof(uint64_t));
+      little_store(offsets + nchunk, &offset_value, sizeof(uint64_t));
       cbytes_chunk = 0;   // we don't need to store the chunk
       break;
     default:
       // Add the new offset
       for (int i = nchunks; i > nchunk; i--) {
         offsets[i] = offsets[i - 1];
       }
       if (frame->sframe) {
         offsets[nchunk] = nchunks;
       }
       else {
         offsets[nchunk] = cbytes;
       }
   }
 
   // Re-compress the offsets again
   blosc2_context* cctx = blosc2_create_cctx(BLOSC2_CPARAMS_DEFAULTS);
   cctx->typesize = 8;
   void* off_chunk = malloc((size_t)off_nbytes + BLOSC_MAX_OVERHEAD);
   int32_t new_off_cbytes = blosc2_compress_ctx(cctx, offsets, off_nbytes,
                                                off_chunk, off_nbytes + BLOSC_MAX_OVERHEAD);
   blosc2_free_ctx(cctx);
 
   free(offsets);
   if (new_off_cbytes < 0) {
     free(off_chunk);
     return NULL;
   }
 
   int64_t new_cbytes = cbytes + cbytes_chunk;
 
   int64_t new_frame_len;
   if (frame->sframe) {
     new_frame_len = header_len + 0 + new_off_cbytes + frame->trailer_len;
   }
   else {
     new_frame_len = header_len + new_cbytes + new_off_cbytes + frame->trailer_len;
   }
 
   // Add the chunk and update meta
   FILE* fp = NULL;
   if (frame->cframe != NULL) {
     uint8_t* framep = frame->cframe;
     /* Make space for the new chunk and copy it */
     frame->cframe = framep = realloc(framep, (size_t)new_frame_len);
     if (framep == NULL) {
       BLOSC_TRACE_ERROR("Cannot realloc space for the frame.");
       return NULL;
     }
     /* Copy the chunk */
     memcpy(framep + header_len + cbytes, chunk, (size_t)cbytes_chunk);
     /* Copy the offsets */
     memcpy(framep + header_len + new_cbytes, off_chunk, (size_t)new_off_cbytes);
   } else {
     size_t wbytes;
     if (frame->sframe) {
       if (cbytes_chunk != 0) {
         if (sframe_create_chunk(frame, chunk, nchunks, cbytes_chunk) == NULL) {
           BLOSC_TRACE_ERROR("Cannot write the full chunk.");
           return NULL;
         }
       }
       // Update the offsets chunk in the chunks frame
       fp = sframe_open_index(frame->urlpath, "rb+");
       fseek(fp, header_len + 0, SEEK_SET);
     }
     else {
       // Regular frame
       fp = fopen(frame->urlpath, "rb+");
       fseek(fp, header_len + cbytes, SEEK_SET);
       wbytes = fwrite(chunk, 1, (size_t)cbytes_chunk, fp);  // the new chunk
       if (wbytes != (size_t)cbytes_chunk) {
         BLOSC_TRACE_ERROR("Cannot write the full chunk to frame.");
         fclose(fp);
         return NULL;
       }
     }
     wbytes = fwrite(off_chunk, 1, (size_t)new_off_cbytes, fp);  // the new offsets
     fclose(fp);
     if (wbytes != (size_t)new_off_cbytes) {
       BLOSC_TRACE_ERROR("Cannot write the offsets to frame.");
       return NULL;
     }
     // Invalidate the cache for chunk offsets
     if (frame->coffsets != NULL) {
       free(frame->coffsets);
       frame->coffsets = NULL;
     }
   }
   free(chunk);  // chunk has always to be a copy when reaching here...
   free(off_chunk);
 
   frame->len = new_frame_len;
   rc = frame_update_header(frame, schunk, false);
   if (rc < 0) {
     return NULL;
   }
 
   rc = frame_update_trailer(frame, schunk);
   if (rc < 0) {
     return NULL;
   }
 
   return frame;
 }
@@ -2145,163 +2362,163 @@ void* frame_insert_chunk(blosc2_frame_s* frame, int nchunk, void* chunk, blosc2_
 void* frame_update_chunk(blosc2_frame_s* frame, int nchunk, void* chunk, blosc2_schunk* schunk) {
   uint8_t *chunk_ = (uint8_t *) chunk;
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t chunksize;
   int32_t nchunks;
   int rc = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
   if (rc < 0) {
     BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
     return NULL;
   }
   if (nchunk >= nchunks) {
     BLOSC_TRACE_ERROR("The chunk must already exist.");
     return NULL;
   }
 
   int32_t cbytes_chunk = sw32_((uint8_t*)chunk + BLOSC2_CHUNK_CBYTES);
 
   // Get the current offsets
   int32_t off_nbytes = nchunks * 8;
   int64_t* offsets = (int64_t *) malloc((size_t)off_nbytes);
   if (nchunks > 0) {
     int32_t coffsets_cbytes = 0;
     uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, &coffsets_cbytes);
     if (coffsets == NULL) {
       BLOSC_TRACE_ERROR("Cannot get the offsets for the frame.");
       return NULL;
     }
     if (coffsets_cbytes == 0) {
       coffsets_cbytes = cbytes;
     }
 
     // Decompress offsets
     blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;
     blosc2_context *dctx = blosc2_create_dctx(off_dparams);
     int32_t prev_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes, offsets, nchunks * 8);
     blosc2_free_ctx(dctx);
     if (prev_nbytes < 0) {
       free(offsets);
       BLOSC_TRACE_ERROR("Cannot decompress the offsets chunk.");
       return NULL;
     }
   }
 
   // Add the new offset
   int special_value = (chunk_[BLOSC2_CHUNK_BLOSC2_FLAGS] & 0x30) >> 4;
   uint64_t offset_value = ((uint64_t)1 << 63);
   switch (special_value) {
     case BLOSC2_ZERO_RUNLEN:
       // Zero chunk.  Code it in a special way.
       offset_value += (uint64_t)BLOSC2_ZERO_RUNLEN << (8 * 7);  // indicate a chunk of zeros
-      swap_store(offsets + nchunk, &offset_value, sizeof(uint64_t));
+      little_store(offsets + nchunk, &offset_value, sizeof(uint64_t));
       cbytes_chunk = 0;   // we don't need to store the chunk
       break;
     case BLOSC2_NAN_RUNLEN:
       // NaN chunk.  Code it in a special way.
       offset_value += (uint64_t)BLOSC2_NAN_RUNLEN << (8 * 7);  // indicate a chunk of NANs
-      swap_store(offsets + nchunk, &offset_value, sizeof(uint64_t));
+      little_store(offsets + nchunk, &offset_value, sizeof(uint64_t));
       cbytes_chunk = 0;   // we don't need to store the chunk
       break;
     default:
       if (frame->sframe) {
         // In case there was a reorder
         offsets[nchunk] = nchunk;
       }
       else {
         // Add the new offset
         offsets[nchunk] = cbytes;
       }
   }
 
   // Re-compress the offsets again
   blosc2_context* cctx = blosc2_create_cctx(BLOSC2_CPARAMS_DEFAULTS);
   cctx->typesize = 8;
   void* off_chunk = malloc((size_t)off_nbytes + BLOSC_MAX_OVERHEAD);
   int32_t new_off_cbytes = blosc2_compress_ctx(cctx, offsets, off_nbytes,
                                                off_chunk, off_nbytes + BLOSC_MAX_OVERHEAD);
   blosc2_free_ctx(cctx);
 
   free(offsets);
   if (new_off_cbytes < 0) {
     free(off_chunk);
     return NULL;
   }
 
   int64_t new_cbytes = schunk->cbytes;
   int64_t new_frame_len;
   if (frame->sframe) {
     // The chunk is not stored in the frame
     new_frame_len = header_len + 0 + new_off_cbytes + frame->trailer_len;
   }
   else {
     new_frame_len = header_len + new_cbytes + new_off_cbytes + frame->trailer_len;
   }
 
   FILE* fp = NULL;
   if (frame->cframe != NULL) {
     uint8_t* framep = frame->cframe;
     /* Make space for the new chunk and copy it */
     frame->cframe = framep = realloc(framep, (size_t)new_frame_len);
     if (framep == NULL) {
       BLOSC_TRACE_ERROR("Cannot realloc space for the frame.");
       return NULL;
     }
     /* Copy the chunk */
     memcpy(framep + header_len + cbytes, chunk, (size_t)cbytes_chunk);
     /* Copy the offsets */
     memcpy(framep + header_len + new_cbytes, off_chunk, (size_t)new_off_cbytes);
   } else {
     size_t wbytes;
     if (frame->sframe) {
       if (cbytes_chunk) {
         if (sframe_create_chunk(frame, chunk, nchunk, cbytes_chunk) == NULL) {
           BLOSC_TRACE_ERROR("Cannot write the full chunk.");
           return NULL;
         }
       }
       // Update the offsets chunk in the chunks frame
       fp = sframe_open_index(frame->urlpath, "rb+");
       fseek(fp, header_len + 0, SEEK_SET);
     }
     else {
       // Regular frame
       fp = fopen(frame->urlpath, "rb+");
       fseek(fp, header_len + cbytes, SEEK_SET);
       wbytes = fwrite(chunk, 1, (size_t)cbytes_chunk, fp);  // the new chunk
       if (wbytes != (size_t)cbytes_chunk) {
         BLOSC_TRACE_ERROR("Cannot write the full chunk to frame.");
         fclose(fp);
         return NULL;
       }
     }
     wbytes = fwrite(off_chunk, 1, (size_t)new_off_cbytes, fp);  // the new offsets
     fclose(fp);
     if (wbytes != (size_t)new_off_cbytes) {
       BLOSC_TRACE_ERROR("Cannot write the offsets to frame.");
       return NULL;
     }
     // Invalidate the cache for chunk offsets
     if (frame->coffsets != NULL) {
       free(frame->coffsets);
       frame->coffsets = NULL;
     }
   }
   free(chunk);  // chunk has always to be a copy when reaching here...
   free(off_chunk);
 
   frame->len = new_frame_len;
   rc = frame_update_header(frame, schunk, false);
   if (rc < 0) {
     return NULL;
   }
 
   rc = frame_update_trailer(frame, schunk);
   if (rc < 0) {
     return NULL;
   }
 
   return frame;
 }
diff --git a/blosc/frame.h b/blosc/frame.h
index 964db93a..3a34fa20 100644
--- a/blosc/frame.h
+++ b/blosc/frame.h
@@ -1,50 +1,49 @@
 /*********************************************************************
   Blosc - Blocked Shuffling and Compression Library
 
   Author: The Blosc Developers <blosc@blosc.org>
 
   See LICENSE.txt for details about copyright and rights to use.
 **********************************************************************/
 
 #ifndef BLOSC_FRAME_H
 #define BLOSC_FRAME_H
 
 #include <stdio.h>
 #include <stdint.h>
 
 // Different types of frames
 #define FRAME_CONTIGUOUS_TYPE 0
 #define FRAME_DIRECTORY_TYPE 1
 
 
 // Constants for metadata placement in header
 #define FRAME_HEADER_MAGIC 2
 #define FRAME_HEADER_LEN (FRAME_HEADER_MAGIC + 8 + 1)  // 11
 #define FRAME_LEN (FRAME_HEADER_LEN + 4 + 1)  // 16
 #define FRAME_FLAGS (FRAME_LEN + 8 + 1)  // 25
 #define FRAME_TYPE (FRAME_FLAGS + 1)  // 26
 #define FRAME_CODECS (FRAME_FLAGS + 2)  // 27
 #define FRAME_NBYTES (FRAME_FLAGS + 4 + 1)  // 30
 #define FRAME_CBYTES (FRAME_NBYTES + 8 + 1)  // 39
 #define FRAME_TYPESIZE (FRAME_CBYTES + 8 + 1) // 48
 #define FRAME_CHUNKSIZE (FRAME_TYPESIZE + 4 + 1)  // 53
 #define FRAME_NTHREADS_C (FRAME_CHUNKSIZE + 4 + 1)  // 58
 #define FRAME_NTHREADS_D (FRAME_NTHREADS_C + 2 + 1)  // 61
 #define FRAME_HAS_USERMETA (FRAME_NTHREADS_D + 2)  // 63
 #define FRAME_FILTER_PIPELINE (FRAME_HAS_USERMETA + 1 + 1) // 65
 #define FRAME_HEADER_MINLEN (FRAME_FILTER_PIPELINE + 1 + 16)  // 82 <- minimum length
 #define FRAME_METALAYERS (FRAME_HEADER_MINLEN)  // 82
 #define FRAME_IDX_SIZE (FRAME_METALAYERS + 1 + 1)  // 84
 
 #define FRAME_FILTER_PIPELINE_MAX (8)  // the maximum number of filters that can be stored in header
 
 #define FRAME_TRAILER_VERSION_BETA2 (0U)  // for beta.2 and former
 #define FRAME_TRAILER_VERSION (1U)        // can be up to 127
 
-#define FRAME_TRAILER_USERMETA_LEN_OFFSET (3)  // offset to usermeta length
-#define FRAME_TRAILER_USERMETA_OFFSET (7)  // offset to usermeta chunk
-#define FRAME_TRAILER_MINLEN (30)  // minimum length for the trailer (msgpack overhead)
+#define FRAME_TRAILER_MINLEN (35)  // minimum length for the trailer (msgpack overhead)
 #define FRAME_TRAILER_LEN_OFFSET (22)  // offset to trailer length (counting from the end)
+#define FRAME_TRAILER_VLMETALAYERS (2)
 
 
 typedef struct {
diff --git a/blosc/schunk.c b/blosc/schunk.c
index 22036ee8..13fda537 100644
--- a/blosc/schunk.c
+++ b/blosc/schunk.c
@@ -184,109 +184,110 @@ blosc2_schunk *blosc2_schunk_empty(int nchunks, const blosc2_storage storage) {
 /* Create a copy of a super-chunk */
 blosc2_schunk* blosc2_schunk_copy(blosc2_schunk *schunk, blosc2_storage storage) {
   if (schunk == NULL) {
     BLOSC_TRACE_ERROR("Can not copy a NULL `schunk`.");
     return NULL;
   }
 
   // Check if cparams are equals
   bool cparams_equal = true;
   blosc2_cparams cparams = {0};
   if (storage.cparams == NULL) {
     // When cparams are not specified, just use the same of schunk
     cparams.typesize = schunk->cctx->typesize;
     cparams.clevel = schunk->cctx->clevel;
     cparams.compcode = schunk->cctx->compcode;
     cparams.use_dict = schunk->cctx->use_dict;
     cparams.blocksize = schunk->cctx->blocksize;
     memcpy(cparams.filters, schunk->cctx->filters, BLOSC2_MAX_FILTERS);
     memcpy(cparams.filters_meta, schunk->cctx->filters_meta, BLOSC2_MAX_FILTERS);
     storage.cparams = &cparams;
   }
   else {
     cparams = *storage.cparams;
   }
   if (cparams.blocksize == 0) {
     // TODO: blocksize should be read from schunk->blocksize
     // For this, it should be updated during the first append
     // (or change API to make this a property during schunk creation).
     cparams.blocksize = schunk->cctx->blocksize;
   }
 
   if (cparams.typesize != schunk->cctx->typesize ||
       cparams.clevel != schunk->cctx->clevel ||
       cparams.compcode != schunk->cctx->compcode ||
       cparams.use_dict != schunk->cctx->use_dict ||
       cparams.blocksize != schunk->cctx->blocksize) {
     cparams_equal = false;
   }
   for (int i = 0; i < BLOSC2_MAX_FILTERS; ++i) {
     if (cparams.filters[i] != schunk->cctx->filters[i] ||
         cparams.filters_meta[i] != schunk->cctx->filters_meta[i]) {
       cparams_equal = false;
     }
   }
 
   // Create new schunk
   blosc2_schunk *new_schunk = blosc2_schunk_new(storage);
   if (new_schunk == NULL) {
     BLOSC_TRACE_ERROR("Can not create a new schunk");
     return NULL;
   }
 
   // Copy metalayers
   for (int nmeta = 0; nmeta < schunk->nmetalayers; ++nmeta) {
     blosc2_metalayer *meta = schunk->metalayers[nmeta];
     if (blosc2_add_metalayer(new_schunk, meta->name, meta->content, meta->content_len) < 0) {
       BLOSC_TRACE_ERROR("Con not add %s `metalayer`.", meta->name);
       return NULL;
     }
   }
 
   // Copy chunks
   if (cparams_equal) {
     for (int nchunk = 0; nchunk < schunk->nchunks; ++nchunk) {
       uint8_t *chunk;
       bool needs_free;
       if (blosc2_schunk_get_chunk(schunk, nchunk, &chunk, &needs_free) < 0) {
         BLOSC_TRACE_ERROR("Can not get the `chunk` %d.", nchunk);
         return NULL;
       }
       if (blosc2_schunk_append_chunk(new_schunk, chunk, !needs_free) < 0) {
         BLOSC_TRACE_ERROR("Can not append the `chunk` into super-chunk.");
         return NULL;
       }
     }
   } else {
-    uint8_t *buffer = malloc(schunk->chunksize);
+    int32_t chunksize = schunk->chunksize == -1 ? 0 : schunk->chunksize;
+    uint8_t *buffer = malloc(chunksize);
     for (int nchunk = 0; nchunk < schunk->nchunks; ++nchunk) {
       if (blosc2_schunk_decompress_chunk(schunk, nchunk, buffer, schunk->chunksize) < 0) {
         BLOSC_TRACE_ERROR("Can not decompress the `chunk` %d.", nchunk);
         return NULL;
       }
       if (blosc2_schunk_append_buffer(new_schunk, buffer, schunk->chunksize) < 0) {
         BLOSC_TRACE_ERROR("Can not append the `buffer` into super-chunk.");
         return NULL;
       }
     }
     free(buffer);
   }
 
-  // Copy user meta
-  if (schunk->usermeta != NULL) {
-    uint8_t *usermeta;
-    int32_t usermeta_len = blosc2_get_usermeta(schunk, &usermeta);
-    if (usermeta_len < 0) {
-      BLOSC_TRACE_ERROR("Can not get `usermeta` from schunk");
-      return NULL;
+  // Copy vlmetalayers
+  for (int nmeta = 0; nmeta < schunk->nvlmetalayers; ++nmeta) {
+    uint8_t *content;
+    uint32_t content_len;
+    char* name = schunk->vlmetalayers[nmeta]->name;
+    if (blosc2_get_vlmetalayer(schunk, name, &content, &content_len) < 0) {
+      BLOSC_TRACE_ERROR("Can not get %s `umetalayer`.", name);
     }
-    if (blosc2_update_usermeta(new_schunk, usermeta, usermeta_len, cparams) < 0) {
-      BLOSC_TRACE_ERROR("Can not update the `usermeta`.");
+    if (blosc2_add_vlmetalayer(new_schunk, name, content, content_len, NULL) < 0) {
+      BLOSC_TRACE_ERROR("Can not add %s `umetalayer`.", name);
       return NULL;
     }
-    free(usermeta);
+    free(content);
   }
   return new_schunk;
 }
 
 
 /* Open an existing super-chunk that is on-disk (no copy is made). */
@@ -384,50 +385,58 @@ int64_t blosc2_schunk_to_file(blosc2_schunk* schunk, const char* urlpath) {
 /* Free all memory from a super-chunk. */
 int blosc2_schunk_free(blosc2_schunk *schunk) {
   if (schunk->data != NULL) {
     for (int i = 0; i < schunk->nchunks; i++) {
       free(schunk->data[i]);
     }
     free(schunk->data);
   }
   if (schunk->cctx != NULL)
     blosc2_free_ctx(schunk->cctx);
   if (schunk->dctx != NULL)
     blosc2_free_ctx(schunk->dctx);
 
   if (schunk->nmetalayers > 0) {
     for (int i = 0; i < schunk->nmetalayers; i++) {
       if (schunk->metalayers[i] != NULL) {
         if (schunk->metalayers[i]->name != NULL)
           free(schunk->metalayers[i]->name);
         if (schunk->metalayers[i]->content != NULL)
           free(schunk->metalayers[i]->content);
         free(schunk->metalayers[i]);
       }
     }
     schunk->nmetalayers = 0;
   }
 
   if (schunk->storage != NULL) {
     if (schunk->storage->urlpath != NULL) {
       free(schunk->storage->urlpath);
     }
     free(schunk->storage->cparams);
     free(schunk->storage->dparams);
     free(schunk->storage);
   }
 
   if (schunk->frame != NULL) {
     frame_free((blosc2_frame_s *) schunk->frame);
   }
 
-  if (schunk->usermeta_len > 0) {
-    free(schunk->usermeta);
+  if (schunk->nvlmetalayers > 0) {
+    for (int i = 0; i < schunk->nvlmetalayers; ++i) {
+      if (schunk->vlmetalayers[i] != NULL) {
+        if (schunk->vlmetalayers[i]->name != NULL)
+          free(schunk->vlmetalayers[i]->name);
+        if (schunk->vlmetalayers[i]->content != NULL)
+          free(schunk->vlmetalayers[i]->content);
+        free(schunk->vlmetalayers[i]);
+      }
+    }
   }
 
   free(schunk);
 
   return 0;
 }
 
 
 /* Create a super-chunk out of a contiguous frame buffer */
@@ -991,73 +1000,162 @@ int blosc2_update_metalayer(blosc2_schunk *schunk, const char *name, uint8_t *co
 /* Get the content out of a metalayer.
  *
  * The `**content` receives a malloc'ed copy of the content.  The user is responsible of freeing it.
  *
  * If successful, return the index of the new metalayer.  Else, return a negative value.
  */
 int blosc2_get_metalayer(blosc2_schunk *schunk, const char *name, uint8_t **content,
                          uint32_t *content_len) {
   int nmetalayer = blosc2_has_metalayer(schunk, name);
   if (nmetalayer < 0) {
     BLOSC_TRACE_ERROR("Metalayer \"%s\" not found.", name);
     return nmetalayer;
   }
   *content_len = (uint32_t)schunk->metalayers[nmetalayer]->content_len;
   *content = malloc((size_t)*content_len);
   memcpy(*content, schunk->metalayers[nmetalayer]->content, (size_t)*content_len);
   return nmetalayer;
 }
 
+/* Find whether the schunk has a variable-length metalayer or not.
+ *
+ * If successful, return the index of the variable-length metalayer.  Else, return a negative value.
+ */
+int blosc2_has_vlmetalayer(blosc2_schunk *schunk, const char *name) {
+  if (strlen(name) > BLOSC2_METALAYER_NAME_MAXLEN) {
+    BLOSC_TRACE_ERROR("Variable-length metalayer names cannot be larger than %d chars.", BLOSC2_METALAYER_NAME_MAXLEN);
+    return BLOSC2_ERROR_INVALID_PARAM;
+  }
 
-/* Update the content of the usermeta chunk. */
-int blosc2_update_usermeta(blosc2_schunk *schunk, uint8_t *content, int32_t content_len,
-                           blosc2_cparams cparams) {
-  if ((uint32_t) content_len > (1u << 31u)) {
-    BLOSC_TRACE_ERROR("content_len cannot exceed 2 GB.");
-    return BLOSC2_ERROR_2GB_LIMIT;
+  for (int numeta = 0; numeta < schunk->nvlmetalayers; numeta++) {
+    if (strcmp(name, schunk->vlmetalayers[numeta]->name) == 0) {
+      return numeta;
+    }
   }
+  return BLOSC2_ERROR_NOT_FOUND;
+}
 
-  // Compress the usermeta chunk
-  void* usermeta_chunk = malloc(content_len + BLOSC_MAX_OVERHEAD);
-  blosc2_context *cctx = blosc2_create_cctx(cparams);
-  int usermeta_cbytes = blosc2_compress_ctx(cctx, content, content_len, usermeta_chunk,
-                                            content_len + BLOSC_MAX_OVERHEAD);
-  blosc2_free_ctx(cctx);
-  if (usermeta_cbytes < 0) {
-    free(usermeta_chunk);
-    return usermeta_cbytes;
+int umetalayer_flush(blosc2_schunk* schunk) {
+  int rc;
+  if (schunk->frame == NULL) {
+    return BLOSC2_ERROR_SUCCESS;
+  }
+  rc = frame_update_header(schunk->frame, schunk, false);
+  if (rc < 0) {
+    BLOSC_TRACE_ERROR("Unable to update metalayers into frame.");
+    return rc;
+  }
+  rc = frame_update_trailer(schunk->frame, schunk);
+  if (rc < 0) {
+    BLOSC_TRACE_ERROR("Unable to update trailer into frame.");
+    return rc;
   }
+  return rc;
+}
 
-  // Update the contents of the usermeta chunk
-  if (schunk->usermeta_len > 0) {
-    free(schunk->usermeta);
+/* Add content into a new variable-length metalayer.
+ *
+ * If successful, return the index of the new variable-length metalayer.  Else, return a negative value.
+ */
+int blosc2_add_vlmetalayer(blosc2_schunk *schunk, const char *name, uint8_t *content, uint32_t content_len,
+                           blosc2_cparams *cparams) {
+  int numeta = blosc2_has_vlmetalayer(schunk, name);
+  if (numeta >= 0) {
+    BLOSC_TRACE_ERROR("Variable-length metalayer \"%s\" already exists.", name);
+    return BLOSC2_ERROR_INVALID_PARAM;
   }
-  schunk->usermeta = malloc(usermeta_cbytes);
-  memcpy(schunk->usermeta, usermeta_chunk, usermeta_cbytes);
-  free(usermeta_chunk);
-  schunk->usermeta_len = usermeta_cbytes;
 
-  blosc2_frame_s* frame = (blosc2_frame_s*)schunk->frame;
-  if (frame != NULL) {
-    int rc = frame_update_trailer(frame, schunk);
-    if (rc < 0) {
-      return rc;
-    }
+  // Add the umeta
+  blosc2_metalayer *umeta = malloc(sizeof(blosc2_metalayer));
+  umeta->name = strdup(name);
+  uint8_t* content_buf = malloc((size_t) content_len + BLOSC_MAX_OVERHEAD);
+
+  blosc2_context *cctx;
+  if (cparams != NULL) {
+    cctx = blosc2_create_cctx(*cparams);
+  } else {
+    cctx = blosc2_create_cctx(BLOSC2_CPARAMS_DEFAULTS);
+  }
+
+  int csize = blosc2_compress_ctx(cctx, content, content_len, content_buf, content_len + BLOSC_MAX_OVERHEAD);
+  if (csize < 0) {
+    BLOSC_TRACE_ERROR("Can not compress the `%s` variable-length metalayer.", name);
+    return csize;
   }
+  blosc2_free_ctx(cctx);
+
+  umeta->content = realloc(content_buf, csize);
+  umeta->content_len = csize;
+  schunk->vlmetalayers[schunk->nvlmetalayers] = umeta;
+  schunk->nvlmetalayers += 1;
 
-  return usermeta_cbytes;
+  // Propagate to frames
+  int rc = umetalayer_flush(schunk);
+  if (rc < 0) {
+    BLOSC_TRACE_ERROR("Can not propagate de `%s` variable-length metalayer to a frame.", name);
+    return rc;
+  }
+
+  return schunk->nvlmetalayers - 1;
 }
 
 
-/* Retrieve the usermeta chunk */
-int32_t blosc2_get_usermeta(blosc2_schunk* schunk, uint8_t** content) {
+int blosc2_get_vlmetalayer(blosc2_schunk *schunk, const char *name, uint8_t **content,
+                           uint32_t *content_len) {
+  int numeta = blosc2_has_vlmetalayer(schunk, name);
+  if (numeta < 0) {
+    BLOSC_TRACE_ERROR("User metalayer \"%s\" not found.", name);
+    return numeta;
+  }
+  blosc2_metalayer *meta = schunk->vlmetalayers[numeta];
   size_t nbytes, cbytes, blocksize;
-  blosc_cbuffer_sizes(schunk->usermeta, &nbytes, &cbytes, &blocksize);
-  *content = malloc(nbytes);
-  blosc2_context *dctx = blosc2_create_dctx(BLOSC2_DPARAMS_DEFAULTS);
-  int usermeta_nbytes = blosc2_decompress_ctx(dctx, schunk->usermeta, schunk->usermeta_len, *content, (int32_t)nbytes);
-  blosc2_free_ctx(dctx);
-  if (usermeta_nbytes < 0) {
-    return usermeta_nbytes;
-  }
-  return (int32_t)nbytes;
+  blosc_cbuffer_sizes(meta->content, &nbytes, &cbytes, &blocksize);
+  if (cbytes != meta->content_len) {
+    BLOSC_TRACE_ERROR("User metalayer \"%s\" is corrupted.", meta->name);
+    return BLOSC2_ERROR_DATA;
+  }
+  *content_len = nbytes;
+  *content = malloc((size_t) nbytes);
+  int nbytes_ = blosc2_decompress_ctx(schunk->dctx, meta->content, meta->content_len, *content, nbytes);
+  if (nbytes_ != nbytes) {
+    BLOSC_TRACE_ERROR("User metalayer \"%s\" is corrupted.", meta->name);
+    return BLOSC2_ERROR_READ_BUFFER;
+  }
+  return numeta;
 }
+
+int blosc2_update_vlmetalayer(blosc2_schunk *schunk, const char *name, uint8_t *content, uint32_t content_len,
+                              blosc2_cparams *cparams) {
+  int numeta = blosc2_has_vlmetalayer(schunk, name);
+  if (numeta < 0) {
+    BLOSC_TRACE_ERROR("User umeta \"%s\" not found.", name);
+    return numeta;
+  }
+
+  blosc2_metalayer *umeta = schunk->vlmetalayers[numeta];
+  free(umeta->content);
+  uint8_t* content_buf = malloc((size_t) content_len + BLOSC_MAX_OVERHEAD);
+
+  blosc2_context *cctx;
+  if (cparams != NULL) {
+    cctx = blosc2_create_cctx(*cparams);
+  } else {
+    cctx = blosc2_create_cctx(BLOSC2_CPARAMS_DEFAULTS);
+  }
+
+  int csize = blosc2_compress_ctx(cctx, content, content_len, content_buf, content_len + BLOSC_MAX_OVERHEAD);
+  if (csize < 0) {
+    BLOSC_TRACE_ERROR("Can not compress the `%s` variable-length metalayer.", name);
+    return csize;
+  }
+  umeta->content = realloc(content_buf, csize);
+  umeta->content_len = csize;
+
+  // Propagate to frames
+  int rc = umetalayer_flush(schunk);
+  if (rc < 0) {
+    BLOSC_TRACE_ERROR("Can not propagate de `%s` variable-length metalayer to a frame.", name);
+    return rc;
+  }
+
+  return numeta;
+}
\ No newline at end of file
diff --git a/examples/CMakeLists.txt b/examples/CMakeLists.txt
index 7d652c1f..f9c1276c 100644
--- a/examples/CMakeLists.txt
+++ b/examples/CMakeLists.txt
@@ -1,7 +1,7 @@
 # sources for examples
 set(SOURCES contexts delta_schunk_ex multithread simple frame_metalayers noinit find_roots)
 if(NOT DEACTIVATE_LZ4)
-    set(SOURCES ${SOURCES} schunk_simple frame_simple sframe_simple frame_backed_schunk compress_file)
+    set(SOURCES ${SOURCES} schunk_simple frame_simple frame_umetalayers sframe_simple frame_backed_schunk compress_file)
 endif()
 if(NOT DEACTIVATE_ZSTD)
     set(SOURCES ${SOURCES} zstd_dict)
diff --git a/examples/frame_simple.c b/examples/frame_simple.c
index d1669a85..9f8c6278 100644
--- a/examples/frame_simple.c
+++ b/examples/frame_simple.c
@@ -42,141 +42,160 @@
 int main(void) {
   static int32_t data[CHUNKSIZE];
   static int32_t data_dest[CHUNKSIZE];
   static int32_t data_dest2[CHUNKSIZE];
   size_t isize = CHUNKSIZE * sizeof(int32_t);
   int64_t nbytes, cbytes;
   int i, nchunk;
   int nchunks;
   blosc_timestamp_t last, current;
   double ttotal;
 
   printf("Blosc version info: %s (%s)\n",
          BLOSC_VERSION_STRING, BLOSC_VERSION_DATE);
 
   /* Create a super-chunk container */
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   cparams.typesize = sizeof(int32_t);
   cparams.compcode = BLOSC_LZ4;
   cparams.clevel = 9;
   cparams.nthreads = NTHREADS;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   dparams.nthreads = NTHREADS;
   blosc2_storage storage = {.cparams=&cparams, .dparams=&dparams};
   blosc2_schunk* schunk = blosc2_schunk_new(storage);
 
   // Add some data
   blosc_set_timestamp(&last);
   for (nchunk = 0; nchunk < NCHUNKS; nchunk++) {
     for (i = 0; i < CHUNKSIZE; i++) {
       data[i] = i * nchunk;
     }
     nchunks = blosc2_schunk_append_buffer(schunk, data, isize);
     assert(nchunks == nchunk + 1);
   }
 
-  // Add some usermeta data
-  int umlen = blosc2_update_usermeta(schunk, (uint8_t *) "This is a usermeta content.....", 32,
-                                     BLOSC2_CPARAMS_DEFAULTS);
+  // Add some vlmetalayers data
+  uint32_t content_len = 10;
+  uint8_t *content = malloc(content_len);
+  for (uint32_t j = 0; j < content_len; ++j) {
+    content[j] = (uint8_t) j;
+  }
+  int umlen = blosc2_add_vlmetalayer(schunk, "umetalayer", content, content_len, NULL);
+  free(content);
   if (umlen < 0) {
-    printf("Cannot write usermeta chunk");
+    printf("Cannot write vlmetalayers chunk");
     return umlen;
   }
 
   /* Gather some info */
   nbytes = schunk->nbytes;
   cbytes = schunk->cbytes;
   blosc_set_timestamp(&current);
   ttotal = blosc_elapsed_secs(last, current);
   printf("Compression ratio: %.1f MB -> %.1f MB (%.1fx)\n",
          nbytes / MB, cbytes / MB, (1. * nbytes) / cbytes);
   printf("Compression time: %.3g s, %.1f MB/s\n",
          ttotal, nbytes / (ttotal * MB));
   uint8_t* usermeta;
-  int content_len = blosc2_get_usermeta(schunk, &usermeta);
-  printf("Usermeta in schunk: '%s' with length: %d\n", usermeta, content_len);
+
+  blosc2_get_vlmetalayer(schunk, "umetalayer", &usermeta, &content_len);
+  printf("Usermeta length: %d\n", content_len);
+  for (int j = 0; j < content_len; ++j) {
+    printf("%3d", usermeta[j]);
+  }
+  printf("\n");
   free(usermeta);
 
   // Start different conversions between schunks, frames and fileframes
 
   // super-chunk -> cframe (contiguous frame, or buffer)
   blosc_set_timestamp(&last);
   uint8_t* cframe;
   bool cframe_needs_free;
   int64_t frame_len = blosc2_schunk_to_buffer(schunk, &cframe, &cframe_needs_free);
   if (frame_len < 0) {
     return frame_len;
   }
   blosc_set_timestamp(&current);
   ttotal = blosc_elapsed_secs(last, current);
   printf("Time for schunk -> frame: %.3g s, %.1f MB/s\n",
          ttotal, nbytes / (ttotal * MB));
   printf("Frame length in memory: %ld bytes\n", (long)frame_len);
 
   // super-chunk -> fileframe (contiguous frame, on-disk)
   blosc_set_timestamp(&last);
   frame_len = blosc2_schunk_to_file(schunk, "frame_simple.b2frame");
   if (frame_len < 0) {
     return frame_len;
   }
   printf("Frame length on disk: %ld bytes\n", (long)frame_len);
   blosc_set_timestamp(&current);
   ttotal = blosc_elapsed_secs(last, current);
   printf("Time for frame -> fileframe (frame_simple.b2frame): %.3g s, %.1f GB/s\n",
          ttotal, nbytes / (ttotal * GB));
 
   // fileframe (file) -> schunk2 (on-disk contiguous, super-chunk)
   blosc_set_timestamp(&last);
   blosc2_schunk* schunk2 = blosc2_schunk_open("frame_simple.b2frame");
   blosc_set_timestamp(&current);
   ttotal = blosc_elapsed_secs(last, current);
   printf("Time for fileframe (%s) -> frame : %.3g s, %.1f GB/s\n",
          schunk2->storage->urlpath, ttotal, nbytes / (ttotal * GB));
 
   // frame1 (in-memory) -> schunk
   blosc_set_timestamp(&last);
   // The next creates a schunk from the in-memory frame
   blosc2_schunk* schunk1 = blosc2_schunk_from_buffer(cframe, frame_len, false);
   if (schunk1 == NULL) {
     printf("Bad conversion frame1 -> schunk1!\n");
     return -1;
   }
   blosc_set_timestamp(&current);
   ttotal = blosc_elapsed_secs(last, current);
   printf("Time for frame -> schunk: %.3g s, %.1f GB/s\n",
          ttotal, nbytes / (ttotal * GB));
 
 
   /* Retrieve and decompress the chunks from the super-chunks and compare values */
   for (nchunk = 0; nchunk < NCHUNKS; nchunk++) {
     int32_t dsize = blosc2_schunk_decompress_chunk(schunk1, nchunk, data_dest, isize);
     if (dsize < 0) {
       printf("Decompression error in schunk1.  Error code: %d\n", dsize);
       return dsize;
     }
     dsize = blosc2_schunk_decompress_chunk(schunk2, nchunk, data_dest2, isize);
     if (dsize < 0) {
       printf("Decompression error in schunk2.  Error code: %d\n", dsize);
       return dsize;
     }
     /* Check integrity of this chunk */
     for (i = 0; i < CHUNKSIZE; i++) {
       assert (data_dest[i] == i * nchunk);
       assert (data_dest2[i] == i * nchunk);
     }
   }
   printf("Successful roundtrip schunk <-> frame <-> fileframe !\n");
 
-  content_len = blosc2_get_usermeta(schunk1, &usermeta);
-  printf("Usermeta in schunk1: '%s' with length: %d\n", usermeta, content_len);
+  blosc2_get_vlmetalayer(schunk1, "umetalayer", &usermeta, &content_len);
+  for (int j = 0; j < content_len; ++j) {
+    printf("%3d", usermeta[j]);
+  }
+  printf("\n");
+  free(usermeta);
+  blosc2_get_vlmetalayer(schunk2, "umetalayer", &usermeta, &content_len);
+  for (int j = 0; j < content_len; ++j) {
+    printf("%3d", usermeta[j]);
+  }
+  printf("\n");
   free(usermeta);
 
   /* Free resources */
   blosc2_schunk_free(schunk);
   blosc2_schunk_free(schunk1);
   blosc2_schunk_free(schunk2);
   if (cframe_needs_free) {
     free(cframe);
   }
 
   return 0;
 }
diff --git a/examples/frame_umetalayers.c b/examples/frame_umetalayers.c
new file mode 100644
index 00000000..e2d69c5e
--- /dev/null
+++ b/examples/frame_umetalayers.c
@@ -0,0 +1,95 @@
+/*
+  Copyright (C) 2018  Francesc Alted
+  http://blosc.org
+  License: BSD 3-Clause (see LICENSE.txt)
+
+  Example program demonstrating use of the Blosc filter from C code.
+
+  To compile this program:
+
+  $ gcc frame_simple.c -o frame_simple -lblosc2
+
+  To run:
+
+  $ ./frame_simple
+  Blosc version info: 2.0.0a6.dev ($Date:: 2018-05-18 #$)
+  Compression ratio: 381.5 MB -> 9.5 MB (40.2x)
+  Compression time: 0.705 s, 541.0 MB/s
+  Time for schunk -> frame: 0.00796 s, 47905.3 MB/s
+  Frame length in memory: 9940344 bytes
+  Frame length on disk: 9940344 bytes
+  Time for frame -> fileframe (frame_simple.b2frame): 0.0108 s, 35159.6 MB/s
+  Time for fileframe (frame_simple.b2frame) -> frame : 0.000254 s, 1.5e+06 MB/s
+  Time for frame -> schunk: 1.1e-05 s, 3.48e+07 MB/s
+  Time for fileframe -> schunk: 1.25e-05 s, 3.05e+07 MB/s
+  Successful roundtrip schunk <-> frame <-> fileframe !
+
+ */
+
+#include <stdio.h>
+#include <assert.h>
+#include <blosc2.h>
+
+#define KB  1024.
+#define MB  (1024*KB)
+#define GB  (1024*MB)
+
+#define CHUNKSIZE (200 * 1000)
+#define NCHUNKS 100
+#define NTHREADS 4
+
+
+int main(void) {
+  size_t isize = CHUNKSIZE * sizeof(int32_t);
+
+  printf("Blosc version info: %s (%s)\n",
+         BLOSC_VERSION_STRING, BLOSC_VERSION_DATE);
+
+  /* Create a super-chunk container */
+  blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
+  cparams.typesize = sizeof(int32_t);
+  cparams.compcode = BLOSC_LZ4;
+  cparams.clevel = 9;
+  cparams.nthreads = NTHREADS;
+  blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
+  dparams.nthreads = NTHREADS;
+  blosc2_storage storage = {.contiguous=true, .urlpath="umeta.b2frame", .cparams=&cparams, .dparams=&dparams};
+  blosc2_schunk* schunk = blosc2_schunk_new(storage);
+
+
+  // Add a metalayer
+  int umlen = blosc2_add_metalayer(schunk, "umetalayer", (uint8_t *) "This is a vlmetalayers content...", 10);
+  if (umlen < 0) {
+    printf("Cannot write vlmetalayers chunk");
+    return umlen;
+  }
+
+  // Add some vlmetalayers data
+  umlen = blosc2_add_vlmetalayer(schunk, "umetalayer", (uint8_t *) "This is a vlmetalayers content...", 32, NULL);
+  if (umlen < 0) {
+    printf("Cannot write vlmetalayers chunk");
+    return umlen;
+  }
+
+  // Add some vlmetalayers data
+  umlen = blosc2_add_vlmetalayer(schunk, "umetalayer2", (uint8_t *) "This is a content...", 10, NULL);
+  if (umlen < 0) {
+    printf("Cannot write vlmetalayers chunk");
+    return umlen;
+  }
+
+  umlen = blosc2_update_vlmetalayer(schunk, "umetalayer", (uint8_t *) "This is a another umetalayer content...", 20,
+                                    NULL);
+  if (umlen < 0) {
+    printf("Cannot write vlmetalayers chunk");
+    return umlen;
+  }
+
+  blosc2_schunk *sc = blosc2_schunk_open("umeta.b2frame");
+
+  /* Free resources */
+  blosc2_schunk_free(schunk);
+  blosc2_schunk_free(sc);
+
+  return 0;
+}
diff --git a/examples/sframe_simple.c b/examples/sframe_simple.c
index c8125402..f9ba31b6 100644
--- a/examples/sframe_simple.c
+++ b/examples/sframe_simple.c
@@ -29,78 +29,81 @@
 int main(void) {
   static int32_t data[CHUNKSIZE];
   static int32_t data_dest[CHUNKSIZE];
   size_t isize = CHUNKSIZE * sizeof(int32_t);
   int dsize;
   int64_t nbytes, cbytes;
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_schunk* schunk;
   int i, nchunk;
   blosc_timestamp_t last, current;
   double ttotal;
 
   printf("Blosc version info: %s (%s)\n", blosc_get_version_string(), BLOSC_VERSION_DATE);
   /* Create a super-chunk container */
   cparams.typesize = sizeof(int32_t);
   cparams.clevel = 9;
   cparams.nthreads = NTHREADS;
   dparams.nthreads = NTHREADS;
   blosc2_storage storage = {false, "dir1.b2frame", .cparams=&cparams, .dparams=&dparams};
+  /* Remove directory */
+  blosc2_remove_dir(storage.urlpath);
+
   schunk = blosc2_schunk_new(storage);
 
   blosc_set_timestamp(&last);
   for (nchunk = 0; nchunk < NCHUNKS; nchunk++) {
     for (i = 0; i < CHUNKSIZE; i++) {
       data[i] = i * nchunk;
     }
     int nchunks = blosc2_schunk_append_buffer(schunk, data, isize);
     if (nchunks != nchunk + 1) {
       printf("Unexpected nchunks!");
       return -1;
     }
   }
   /* Gather some info */
   nbytes = schunk->nbytes;
   cbytes = schunk->cbytes;
   blosc_set_timestamp(&current);
   ttotal = blosc_elapsed_secs(last, current);
   printf("Compression ratio: %.1f MB -> %.1f MB (%.1fx)\n",
          nbytes / MB, cbytes / MB, (1. * nbytes) / cbytes);
   printf("Compression time: %.3g s, %.1f MB/s\n",
          ttotal, nbytes / (ttotal * MB));
 
   /* Retrieve and decompress the chunks (0-based count) */
   blosc_set_timestamp(&last);
   for (nchunk = NCHUNKS-1; nchunk >= 0; nchunk--) {
     dsize = blosc2_schunk_decompress_chunk(schunk, nchunk, data_dest, isize);
     if (dsize < 0) {
       printf("Decompression error.  Error code: %d\n", dsize);
       return dsize;
     }
   }
   blosc_set_timestamp(&current);
   ttotal = blosc_elapsed_secs(last, current);
   printf("Decompression time: %.3g s, %.1f MB/s\n",
          ttotal, nbytes / (ttotal * MB));
 
   /* Check integrity of the second chunk (made of non-zeros) */
   blosc2_schunk_decompress_chunk(schunk, 1, data_dest, isize);
   for (i = 0; i < CHUNKSIZE; i++) {
     if (data_dest[i] != i) {
       printf("Decompressed data differs from original %d, %d!\n",
              i, data_dest[i]);
       return -1;
     }
   }
 
   printf("Successful roundtrip data <-> schunk !\n");
 
   /* Remove directory */
   blosc2_remove_dir(storage.urlpath);
   /* Free resources */
   /* Destroy the super-chunk */
   blosc2_schunk_free(schunk);
 
   return 0;
 }
 
diff --git a/tests/test_copy.c b/tests/test_copy.c
index f86831f6..ea8c9062 100644
--- a/tests/test_copy.c
+++ b/tests/test_copy.c
@@ -86,97 +86,98 @@ CUTEST_TEST_SETUP(copy) {
 CUTEST_TEST_TEST(copy) {
   CUTEST_GET_PARAMETER(nchunks, int32_t);
   CUTEST_GET_PARAMETER(different_cparams, bool);
   CUTEST_GET_PARAMETER(metalayers, bool);
   CUTEST_GET_PARAMETER(usermeta, bool);
   CUTEST_GET_PARAMETER(backend, test_copy_backend);
   CUTEST_GET_PARAMETER(backend2, test_copy_backend);
 
   /* Free resources */
   if (backend.urlpath != NULL && backend.contiguous == false) {
     blosc2_remove_dir(backend.urlpath);
   }
   if (backend2.urlpath != NULL && backend2.contiguous == false) {
     blosc2_remove_dir(backend2.urlpath);
   }
 
   int32_t itemsize = data->cparams.typesize;
   int32_t isize = CHUNKSIZE * itemsize;
 
   int32_t *data_buffer = malloc(isize);
   memset(data_buffer, 0, isize);
 
   int32_t *rec_buffer = malloc(isize);
 
   /* Initialize the Blosc compressor */
   blosc_init();
 
   /* Create a super-chunk container */
   blosc2_storage storage = {.cparams=&data->cparams, .contiguous=backend.contiguous, .urlpath = backend.urlpath};
   blosc2_schunk *schunk = blosc2_schunk_new(storage);
   CUTEST_ASSERT("Error creating a schunk", schunk != NULL);
 
   char* meta_name = "test_copy";
   uint32_t meta_content_len = 8;
   int64_t meta_content = -66;
 
   if (metalayers) {
     blosc2_add_metalayer(schunk, meta_name, (uint8_t *) &meta_content, meta_content_len);
   }
   if (usermeta) {
-    blosc2_update_usermeta(schunk, (uint8_t *) &meta_content, meta_content_len, *storage.cparams);
+    blosc2_add_vlmetalayer(schunk, "umetalayer", (uint8_t *) &meta_content, meta_content_len, NULL);
   }
 
   /* Append the chunks */
   for (int nchunk = 0; nchunk < nchunks; nchunk++) {
     int nc = blosc2_schunk_append_buffer(schunk, data_buffer, isize);
     CUTEST_ASSERT("Error appending chunk", nc >= 0);
   }
 
   /* Copy schunk */
   blosc2_storage storage2 = {.contiguous=backend2.contiguous, .urlpath = backend2.urlpath};
   storage2.cparams = different_cparams ? &data->cparams2 : &data->cparams;
   blosc2_schunk * schunk_copy = blosc2_schunk_copy(schunk, storage2);
   CUTEST_ASSERT("Error copying a schunk", schunk_copy != NULL);
 
   if (metalayers) {
     int64_t *content = malloc(meta_content_len);
     uint32_t content_len;
     blosc2_get_metalayer(schunk_copy, meta_name,  (uint8_t **) &content, &content_len);
     CUTEST_ASSERT("Metalayers are not equals.", *content == meta_content);
     free(content);
   }
   if (usermeta) {
+    uint32_t content_len;
     int64_t *content;
-    blosc2_get_usermeta(schunk_copy,  (uint8_t **) &content);
+    blosc2_get_vlmetalayer(schunk_copy, "umetalayer", (uint8_t **) &content, &content_len);
     CUTEST_ASSERT("Usermeta are not equal.", *content == meta_content);
     free(content);
   }
   for (int nchunk = 0; nchunk < nchunks; nchunk++) {
     int dsize;
     dsize = blosc2_schunk_decompress_chunk(schunk, nchunk, data_buffer, isize);
     CUTEST_ASSERT("Decompression error", dsize >= 0);
     CUTEST_ASSERT("Decompression size is not equal to input size", dsize == (int) isize);
 
     dsize = blosc2_schunk_decompress_chunk(schunk_copy, nchunk, rec_buffer, isize);
     CUTEST_ASSERT("Decompression error", dsize >= 0);
     CUTEST_ASSERT("Decompression size is not equal to input size", dsize == (int) isize);
   }
 
   /* Free resources */
   free(data_buffer);
   free(rec_buffer);
 
   /* Destroy the super-chunk */
   blosc2_schunk_free(schunk);
   blosc2_schunk_free(schunk_copy);
 
   /* Free resources */
   if (backend.urlpath != NULL && backend.contiguous == false) {
     blosc2_remove_dir(backend.urlpath);
   }
   if (backend2.urlpath != NULL && backend2.contiguous == false) {
     blosc2_remove_dir(backend2.urlpath);
   }
 
   return 0;
 }
diff --git a/tests/test_empty_schunk.c b/tests/test_empty_schunk.c
index 1f3b7ee1..b00a442a 100644
--- a/tests/test_empty_schunk.c
+++ b/tests/test_empty_schunk.c
@@ -23,120 +23,122 @@ bool copy;
 static char* test_schunk(void) {
   static int32_t data[CHUNKSIZE];
   static int32_t data_dest[CHUNKSIZE];
   int32_t isize = CHUNKSIZE * sizeof(int32_t);
   int64_t nbytes, cbytes;
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_schunk* schunk;
 
   /* Initialize the Blosc compressor */
   blosc_init();
 
   /* Create a super-chunk container */
   cparams.typesize = sizeof(int32_t);
   cparams.nthreads = NTHREADS;
   dparams.nthreads = NTHREADS;
   blosc2_storage storage = {.cparams=&cparams, .dparams=&dparams};
   schunk = blosc2_schunk_empty(nchunks, storage);
 
   // Add a couple of metalayers
   blosc2_add_metalayer(schunk, "metalayer1", (uint8_t*)"my metalayer1", sizeof("my metalayer1"));
   blosc2_add_metalayer(schunk, "metalayer2", (uint8_t*)"my metalayer1", sizeof("my metalayer1"));
 
   bool needs_free;
   int32_t datasize = sizeof(int32_t) * CHUNKSIZE;
   int32_t chunksize = sizeof(int32_t) * CHUNKSIZE + BLOSC_MAX_OVERHEAD;
 
   // Feed it with data
   uint8_t *chunk;
   int csize;
   int nchunks_;
 
   for (int nchunk = 0; nchunk < nchunks; nchunk++) {
     for (int i = 0; i < CHUNKSIZE; i++) {
       data[i] = i + nchunk * CHUNKSIZE;
     }
 
     chunk = malloc(chunksize);
     csize = blosc2_compress_ctx(schunk->cctx, data, datasize, chunk, chunksize);
     mu_assert("ERROR: chunk cannot be compressed", csize >= 0);
     nchunks_ = blosc2_schunk_update_chunk(schunk, nchunk, chunk, copy);
     mu_assert("ERROR: bad append in schunk", nchunks_ == nchunks);
 
     chunk = malloc(chunksize);
     csize = blosc2_compress_ctx(schunk->cctx, data, datasize, chunk, chunksize);
     mu_assert("ERROR: chunk cannot be compressed", csize >= 0);
     nchunks_ = blosc2_schunk_update_chunk(schunk, nchunk, chunk, copy);
 
     mu_assert("ERROR: bad append in schunk", nchunks_ == nchunks);
 
     if (copy) {
       free(chunk);
     }
   }
 
   blosc2_update_metalayer(schunk, "metalayer2", (uint8_t*)"my metalayer2", sizeof("my metalayer2"));
   // Attach some user metadata into it
-  blosc2_update_usermeta(schunk, (uint8_t *) "testing the usermeta", 16, BLOSC2_CPARAMS_DEFAULTS);
+  blosc2_add_vlmetalayer(schunk, "umetalayer", (uint8_t *) "testing the vlmetalayers", 16, NULL);
 
   /* Gather some info */
   nbytes = schunk->nbytes;
   cbytes = schunk->cbytes;
   if (nchunks > 0) {
     mu_assert("ERROR: bad compression ratio in frame", nbytes > 10 * cbytes);
   }
 
   // Exercise the metadata retrieval machinery
   size_t nbytes_, cbytes_, blocksize;
   nbytes = 0;
   cbytes = 0;
   for (int nchunk = 0; nchunk < nchunks; nchunk++) {
     cbytes_ = blosc2_schunk_get_chunk(schunk, nchunk, &chunk, &needs_free);
     mu_assert("ERROR: chunk cannot be retrieved correctly.", cbytes_ >= 0);
     blosc_cbuffer_sizes(chunk, &nbytes_, &cbytes_, &blocksize);
     nbytes += nbytes_;
     cbytes += cbytes_;
     if (needs_free) {
       free(chunk);
     }
   }
   mu_assert("ERROR: nbytes is not correct", nbytes == schunk->nbytes);
   mu_assert("ERROR: cbytes is not correct", cbytes == schunk->cbytes);
 
   // Check that the chunks have been decompressed correctly
   for (int nchunk = 0; nchunk < nchunks; nchunk++) {
     cbytes = blosc2_schunk_decompress_chunk(schunk, nchunk, (void *) data_dest, isize);
     mu_assert("ERROR: chunk cannot be decompressed correctly.", cbytes >= 0);
     for (int i = 0; i < CHUNKSIZE; i++) {
       mu_assert("ERROR: bad roundtrip",data_dest[i] == i + nchunk * CHUNKSIZE);
     }
   }
 
   // metalayers
   uint8_t* content;
   uint32_t content_len;
   blosc2_get_metalayer(schunk, "metalayer1", &content, &content_len);
   mu_assert("ERROR: bad metalayer content", strncmp((char*)content, "my metalayer1", content_len) == 0);
   if (content != NULL) {
     free(content);
   }
   blosc2_get_metalayer(schunk, "metalayer2", &content, &content_len);
   mu_assert("ERROR: bad metalayer content", strncmp((char*)content, "my metalayer2", content_len) == 0);
   if (content != NULL) {
     free(content);
   }
 
-  // Check the usermeta
+  // Check the vlmetalayers
   uint8_t* content2;
-  int32_t content2_len = blosc2_get_usermeta(schunk, &content2);
-  mu_assert("ERROR: bad usermeta", strncmp((char*)content2, "testing the usermeta", 16) == 0);
+  uint32_t content2_len;
+  blosc2_get_vlmetalayer(schunk, "umetalayer", &content2, &content2_len);
+
+  mu_assert("ERROR: bad vlmetalayers", strncmp((char*)content2, "testing the vlmetalayers", 16) == 0);
   mu_assert("ERROR: bad usermeta_len", content2_len == 16);
   free(content2);
 
   /* Free resources */
   blosc2_schunk_free(schunk);
   /* Destroy the Blosc environment */
   blosc_destroy();
 
   return EXIT_SUCCESS;
 }
diff --git a/tests/test_frame.c b/tests/test_frame.c
index cacc8891..edda4d6c 100644
--- a/tests/test_frame.c
+++ b/tests/test_frame.c
@@ -38,221 +38,224 @@ char buf[256];
 static char* test_frame(void) {
   int32_t isize = CHUNKSIZE * sizeof(int32_t);
   int32_t *data = malloc(isize);
   int32_t *data_dest = malloc(isize);
   int dsize;
   int64_t nbytes, cbytes;
   uint8_t* buffer;
   bool buffer_needs_free;
 
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   if (filter_pipeline) {
     cparams.filters[BLOSC2_MAX_FILTERS - 2] = BLOSC_DELTA;
     cparams.filters_meta[BLOSC2_MAX_FILTERS - 2] = 0;
   }
   blosc2_schunk* schunk;
 
   /* Initialize the Blosc compressor */
   blosc_init();
 
   /* Create a frame container */
   cparams.typesize = sizeof(int32_t);
   if (splits) {
     // Use a codec that splits blocks (important for lazy chunks).
     // Only BLOSCLZ is doing that.
     cparams.compcode = BLOSC_BLOSCLZ;
   }
 #if defined(HAVE_LZ4)
   else {
     cparams.compcode = BLOSC_LZ4;
   }
 #endif
   if (multithread) {
     cparams.nthreads = NTHREADS;
     dparams.nthreads = NTHREADS;
   }
   else {
     cparams.nthreads = 1;
     dparams.nthreads = 1;
   }
   blosc2_storage storage = {.contiguous=true, .urlpath=fname, .cparams=&cparams, .dparams=&dparams};
   schunk = blosc2_schunk_new(storage);
   mu_assert("blosc2_schunk_new() failed", schunk != NULL);
   char* content = "This is a pretty long string with a good number of chars";
   char* content2 = "This is a pretty long string with a good number of chars; longer than content";
   char* content3 = "This is a short string, and shorter than content";
   uint8_t* content_;
   size_t content_len = strlen(content);
   size_t content_len2 = strlen(content2);
   size_t content_len3 = strlen(content3);
 
   if (metalayers) {
     blosc2_add_metalayer(schunk, "metalayer1", (uint8_t*)"my metalayer1", sizeof("my metalayer1"));
     blosc2_add_metalayer(schunk, "metalayer2", (uint8_t*)"my metalayer1", sizeof("my metalayer1"));
   }
 
   if (usermeta) {
-    blosc2_update_usermeta(schunk, (uint8_t *) content, (int32_t) content_len, BLOSC2_CPARAMS_DEFAULTS);
+    blosc2_add_vlmetalayer(schunk, "umetalayer", (uint8_t *) content, (int32_t) content_len, NULL);
   }
 
   if (!sparse_schunk) {
     if (free_new) {
       if (fname != NULL) {
         blosc2_schunk_free(schunk);
         schunk = blosc2_schunk_open(fname);
         mu_assert("blosc2_schunk_open() failed", schunk != NULL);
         mu_assert("storage is not recovered correctly",
                   schunk->storage->contiguous == true);
         mu_assert("cparams are not recovered correctly",
                   schunk->storage->cparams->clevel == BLOSC2_CPARAMS_DEFAULTS.clevel);
         mu_assert("dparams are not recovered correctly",
                   schunk->storage->dparams->nthreads == BLOSC2_DPARAMS_DEFAULTS.nthreads);
       } else {
         // Dump the schunk into a buffer and regenerate it from there
         int64_t buffer_len = blosc2_schunk_to_buffer(schunk, &buffer, &buffer_needs_free);
         mu_assert("blosc2_schunk_to_buffer() failed", buffer_len > 0);
         blosc2_schunk* schunk2 = blosc2_schunk_from_buffer(buffer, buffer_len, true);
         mu_assert("blosc2_schunk_from_buffer() failed", schunk2 != NULL);
         // We've made a copy, so it is safe to clean the original schunk up
         blosc2_schunk_free(schunk);
         schunk = schunk2;
         if (buffer_needs_free) {
           free(buffer);
         }
       }
     }
   }
 
   if (metalayers) {
     uint8_t* _content;
     uint32_t _content_len;
     blosc2_get_metalayer(schunk, "metalayer1", &_content, &_content_len);
     mu_assert("ERROR: bad metalayer content", strncmp((char*)_content, "my metalayer1", _content_len) == 0);
     if (_content != NULL) {
       free(_content);
     }
     blosc2_get_metalayer(schunk, "metalayer2", &_content, &_content_len);
     mu_assert("ERROR: bad metalayer content", strncmp((char*)_content, "my metalayer1", _content_len) == 0);
     if (_content != NULL) {
       free(_content);
     }
   }
 
   if (usermeta) {
-    int content_len_ = blosc2_get_usermeta(schunk, &content_);
-    mu_assert("ERROR: bad usermeta length in frame", (size_t) content_len_ == content_len);
-    mu_assert("ERROR: bad usermeta data in frame", strncmp((char*)content_, content, content_len) == 0);
+    uint32_t content_len_;
+    blosc2_get_vlmetalayer(schunk, "umetalayer", &content_, &content_len_);
+    mu_assert("ERROR: bad vlmetalayers length in frame", (size_t) content_len_ == content_len);
+    mu_assert("ERROR: bad vlmetalayers data in frame", strncmp((char*)content_, content, content_len) == 0);
     free(content_);
-    blosc2_update_usermeta(schunk, (uint8_t *) content2, (int32_t) content_len2, BLOSC2_CPARAMS_DEFAULTS);
+    blosc2_update_vlmetalayer(schunk, "umetalayer", (uint8_t *) content2, (int32_t) content_len2, NULL);
   }
 
   // Feed it with data
   int _nchunks = 0;
   for (int nchunk = 0; nchunk < nchunks; nchunk++) {
     for (int i = 0; i < CHUNKSIZE; i++) {
       data[i] = i + nchunk * CHUNKSIZE;
     }
     _nchunks = blosc2_schunk_append_buffer(schunk, data, isize);
     mu_assert("ERROR: bad append in frame", _nchunks >= 0);
   }
   mu_assert("ERROR: wrong number of append chunks", _nchunks == nchunks);
 
   if (!sparse_schunk && schunk->frame != NULL) {
     blosc2_frame_s* frame = (blosc2_frame_s*)schunk->frame;
     mu_assert("ERROR: frame->len must be larger or equal than schunk->cbytes",
               frame->len >= schunk->cbytes + FRAME_HEADER_MINLEN);
   }
 
   if (metalayers) {
     uint8_t* _content;
     uint32_t _content_len;
     blosc2_get_metalayer(schunk, "metalayer1", &_content, &_content_len);
     mu_assert("ERROR: bad metalayer content", strncmp((char*)_content, "my metalayer1", _content_len) == 0);
     if (_content != NULL) {
       free(_content);
     }
     blosc2_get_metalayer(schunk, "metalayer2", &_content, &_content_len);
     mu_assert("ERROR: bad metalayer content", strncmp((char*)_content, "my metalayer1", _content_len) == 0);
     if (_content != NULL) {
       free(_content);
     }
     blosc2_update_metalayer(schunk, "metalayer2", (uint8_t*)"my metalayer2", sizeof("my metalayer2"));
   }
 
   if (usermeta) {
-    int content_len_ = blosc2_get_usermeta(schunk, &content_);
-    mu_assert("ERROR: bad usermeta length in frame", (size_t) content_len_ == content_len2);
-    mu_assert("ERROR: bad usermeta data in frame", strncmp((char*)content_, content2, content_len2) == 0);
+    uint32_t content_len_;
+    blosc2_get_vlmetalayer(schunk, "umetalayer", &content_, &content_len_);
+    mu_assert("ERROR: bad vlmetalayers length in frame", (size_t) content_len_ == content_len2);
+    mu_assert("ERROR: bad vlmetalayers data in frame", strncmp((char*)content_, content2, content_len2) == 0);
     free(content_);
-    blosc2_update_usermeta(schunk, (uint8_t *) content3, (int32_t) content_len3, BLOSC2_CPARAMS_DEFAULTS);
+    blosc2_update_vlmetalayer(schunk, "umetalayer", (uint8_t *) content3, (int32_t) content_len3, NULL);
   }
 
   if (!sparse_schunk) {
     if (free_new) {
       if (fname != NULL) {
         blosc2_schunk_free(schunk);
         schunk = blosc2_schunk_open(fname);
       } else {
         // Dump the schunk to a buffer and regenerate it from there
         int64_t buffer_len = blosc2_schunk_to_buffer(schunk, &buffer, &buffer_needs_free);
         mu_assert("blosc2_schunk_to_buffer() failed (2)", buffer_len > 0);
         blosc2_schunk* schunk2 = blosc2_schunk_from_buffer(buffer, buffer_len, true);
         mu_assert("blosc2_schunk_from_buffer() failed (2)", schunk2 != NULL);
         // We've made a copy, so it is safe to clean the original schunk up
         blosc2_schunk_free(schunk);
         schunk = schunk2;
         if (buffer_needs_free) {
           free(buffer);
         }
       }
     }
   }
 
   /* Gather some info */
   nbytes = schunk->nbytes;
   cbytes = schunk->cbytes;
   if (nchunks > 0) {
     mu_assert("ERROR: bad compression ratio in frame", nbytes > 10 * cbytes);
   }
 
   // Check that the chunks have been decompressed correctly
   for (int nchunk = 0; nchunk < nchunks; nchunk++) {
     dsize = blosc2_schunk_decompress_chunk(schunk, nchunk, (void *) data_dest, isize);
     mu_assert("ERROR: chunk cannot be decompressed correctly.", dsize >= 0);
     for (int i = 0; i < CHUNKSIZE; i++) {
       mu_assert("ERROR: bad roundtrip",data_dest[i] == i + nchunk * CHUNKSIZE);
     }
   }
 
   if (metalayers) {
     uint8_t* _content;
     uint32_t _content_len;
     blosc2_get_metalayer(schunk, "metalayer1", &_content, &_content_len);
     mu_assert("ERROR: bad metalayer content", strncmp((char*)_content, "my metalayer1", _content_len) == 0);
     if (_content != NULL) {
       free(_content);
     }
     blosc2_get_metalayer(schunk, "metalayer2", &_content, &_content_len);
     mu_assert("ERROR: bad metalayer content", strncmp((char*)_content, "my metalayer2", _content_len) == 0);
     if (_content != NULL) {
       free(_content);
     }
   }
 
   if (usermeta) {
-    int content_len_ = blosc2_get_usermeta(schunk, &content_);
-    mu_assert("ERROR: bad usermeta length in frame", (size_t) content_len_ == content_len3);
-    mu_assert("ERROR: bad usermeta data in frame", strncmp((char*)content_, content3, content_len3) == 0);
+    uint32_t content_len_;
+    blosc2_get_vlmetalayer(schunk, "umetalayer", &content_, &content_len_);
+    mu_assert("ERROR: bad vlmetalayers length in frame", (size_t) content_len_ == content_len3);
+    mu_assert("ERROR: bad vlmetalayers data in frame", strncmp((char*)content_, content3, content_len3) == 0);
     free(content_);
   }
 
   /* Free resources */
   free(data_dest);
   free(data);
   blosc2_schunk_free(schunk);
 
   /* Destroy the Blosc environment */
   blosc_destroy();
 
   return EXIT_SUCCESS;
 }
diff --git a/tests/test_schunk.c b/tests/test_schunk.c
index 8419d847..e9e550e4 100644
--- a/tests/test_schunk.c
+++ b/tests/test_schunk.c
@@ -22,97 +22,104 @@ int nchunks;
 static char* test_schunk(void) {
   static int32_t data[CHUNKSIZE];
   static int32_t data_dest[CHUNKSIZE];
   int32_t isize = CHUNKSIZE * sizeof(int32_t);
   int dsize;
   int64_t nbytes, cbytes;
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_schunk* schunk;
 
   /* Initialize the Blosc compressor */
   blosc_init();
 
   /* Create a super-chunk container */
   cparams.typesize = sizeof(int32_t);
   cparams.clevel = 5;
   cparams.nthreads = NTHREADS;
   dparams.nthreads = NTHREADS;
   blosc2_storage storage = {.cparams=&cparams, .dparams=&dparams};
   schunk = blosc2_schunk_new(storage);
 
   // Add a couple of metalayers
   blosc2_add_metalayer(schunk, "metalayer1", (uint8_t*)"my metalayer1", sizeof("my metalayer1"));
   blosc2_add_metalayer(schunk, "metalayer2", (uint8_t*)"my metalayer1", sizeof("my metalayer1"));
 
   // Feed it with data
   for (int nchunk = 0; nchunk < nchunks; nchunk++) {
     for (int i = 0; i < CHUNKSIZE; i++) {
       data[i] = i + nchunk * CHUNKSIZE;
     }
     int nchunks_ = blosc2_schunk_append_buffer(schunk, data, isize);
     mu_assert("ERROR: bad append in frame", nchunks_ > 0);
   }
 
   blosc2_update_metalayer(schunk, "metalayer2", (uint8_t*)"my metalayer2", sizeof("my metalayer2"));
+
   // Attach some user metadata into it
-  blosc2_update_usermeta(schunk, (uint8_t *) "testing the usermeta", 16, BLOSC2_CPARAMS_DEFAULTS);
+  blosc2_add_vlmetalayer(schunk, "umetalayer1", (uint8_t *) "testing the vlmetalayers", 23, NULL);
+  blosc2_add_vlmetalayer(schunk, "umetalayer2", (uint8_t *) "vlmetalayers", 11, NULL);
 
   /* Gather some info */
   nbytes = schunk->nbytes;
   cbytes = schunk->cbytes;
   if (nchunks > 0) {
     mu_assert("ERROR: bad compression ratio in frame", nbytes > 10 * cbytes);
   }
 
   // Exercise the metadata retrieval machinery
   bool needs_free;
   uint8_t* chunk;
   size_t nbytes_, cbytes_, blocksize;
   nbytes = 0;
   cbytes = 0;
   for (int nchunk = 0; nchunk < nchunks; nchunk++) {
     dsize = blosc2_schunk_get_chunk(schunk, nchunk, &chunk, &needs_free);
     mu_assert("ERROR: chunk cannot be retrieved correctly.", dsize >= 0);
     blosc_cbuffer_sizes(chunk, &nbytes_, &cbytes_, &blocksize);
     nbytes += nbytes_;
     cbytes += cbytes_;
     if (needs_free) {
       free(chunk);
     }
   }
   mu_assert("ERROR: nbytes is not correct", nbytes == schunk->nbytes);
   mu_assert("ERROR: cbytes is not correct", cbytes == schunk->cbytes);
 
   // Check that the chunks have been decompressed correctly
   for (int nchunk = 0; nchunk < nchunks; nchunk++) {
     dsize = blosc2_schunk_decompress_chunk(schunk, nchunk, (void *) data_dest, isize);
     mu_assert("ERROR: chunk cannot be decompressed correctly.", dsize >= 0);
     for (int i = 0; i < CHUNKSIZE; i++) {
       mu_assert("ERROR: bad roundtrip",data_dest[i] == i + nchunk * CHUNKSIZE);
     }
   }
+  // update metalayer
+  blosc2_update_vlmetalayer(schunk, "umetalayer1", (uint8_t *) "testing the  vlmetalayers", 24, NULL);
 
   // metalayers
   uint8_t* content;
   uint32_t content_len;
   blosc2_get_metalayer(schunk, "metalayer1", &content, &content_len);
   mu_assert("ERROR: bad metalayer content", strncmp((char*)content, "my metalayer1", content_len) == 0);
   free(content);
   blosc2_get_metalayer(schunk, "metalayer2", &content, &content_len);
   mu_assert("ERROR: bad metalayer content", strncmp((char*)content, "my metalayer2", content_len) == 0);
   free(content);
 
-  // Check the usermeta
+  // Check the vlmetalayers
   uint8_t* content2;
-  int32_t content2_len = blosc2_get_usermeta(schunk, &content2);
-  mu_assert("ERROR: bad usermeta", strncmp((char*)content2, "testing the usermeta", 16) == 0);
-  mu_assert("ERROR: bad usermeta_len", content2_len == 16);
+  uint32_t content2_len;
+  blosc2_get_vlmetalayer(schunk, "umetalayer1", &content2, &content2_len);
+  mu_assert("ERROR: bad umetalayer content", strncmp((char*)content2, "testing the  vlmetalayers", content2_len) == 0);
+
+  blosc2_get_vlmetalayer(schunk, "umetalayer2", &content2, &content2_len);
+  mu_assert("ERROR: bad umetalayer content", strncmp((char*)content2, "vlmetalayers", content2_len) == 0);
   free(content2);
 
   /* Free resources */
   blosc2_schunk_free(schunk);
   /* Destroy the Blosc environment */
   blosc_destroy();
 
   return EXIT_SUCCESS;
 }
diff --git a/tests/test_sframe.c b/tests/test_sframe.c
index 4b4b9772..fd515332 100644
--- a/tests/test_sframe.c
+++ b/tests/test_sframe.c
@@ -31,177 +31,184 @@ char buf[256];
 static char* test_sframe(void) {
   size_t isize = CHUNKSIZE * sizeof(int32_t);
   int32_t* data = malloc(isize);
   int32_t* data_dest = malloc(isize);
   int dsize;
   int64_t nbytes, cbytes;
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   if (filter_pipeline) {
     cparams.filters[BLOSC2_MAX_FILTERS - 2] = BLOSC_DELTA;
     cparams.filters_meta[BLOSC2_MAX_FILTERS - 2] = 0;
   }
   blosc2_schunk* schunk;
 
   /* Initialize the Blosc compressor */
   blosc_init();
 
   /* Create a frame container */
   cparams.typesize = sizeof(int32_t);
   if (splits) {
     // Use a codec that splits blocks (important for lazy chunks).
     // Only BLOSCLZ is doing that.
     cparams.compcode = BLOSC_BLOSCLZ;
   }
 #if defined(HAVE_LZ4)
   else {
     cparams.compcode = BLOSC_LZ4;
   }
 #endif
   if (multithread) {
     cparams.nthreads = NTHREADS;
     dparams.nthreads = NTHREADS;
   }
   else {
     cparams.nthreads = 1;
     dparams.nthreads = 1;
   }
   blosc2_storage storage = {.contiguous=false, .urlpath=directory, .cparams=&cparams, .dparams=&dparams};
+  /* Remove directory */
+  blosc2_remove_dir(storage.urlpath);
+
   schunk = blosc2_schunk_new(storage);
   mu_assert("blosc2_schunk_new() failed", schunk != NULL);
   char* content = "This is a pretty long string with a good number of chars";
   char* content2 = "This is a pretty long string with a good number of chars; longer than content";
   char* content3 = "This is a short string, and shorter than content";
   uint8_t* content_;
   size_t content_len = strlen(content);
   size_t content_len2 = strlen(content2);
   size_t content_len3 = strlen(content3);
 
   if (metalayers) {
     blosc2_add_metalayer(schunk, "metalayer1", (uint8_t*)"my metalayer1", sizeof("my metalayer1"));
     blosc2_add_metalayer(schunk, "metalayer2", (uint8_t*)"my metalayer1", sizeof("my metalayer1"));
   }
 
   if (usermeta) {
-    blosc2_update_usermeta(schunk, (uint8_t *) content, (int32_t) content_len, BLOSC2_CPARAMS_DEFAULTS);
+    blosc2_add_vlmetalayer(schunk, "umetalayer", (uint8_t *) content, (int32_t) content_len, NULL);
+    blosc2_add_vlmetalayer(schunk, "umetalayer2", (uint8_t *) content2, (int32_t) content_len2, NULL);
   }
 
   if (free_new) {
     blosc2_schunk_free(schunk);
     schunk = blosc2_schunk_open(directory);
     mu_assert("blosc2_schunk_open() failed", schunk != NULL);
   }
 
   if (metalayers) {
     uint8_t* _content;
     uint32_t _content_len;
     blosc2_get_metalayer(schunk, "metalayer1", &_content, &_content_len);
     mu_assert("ERROR: bad metalayer content", strncmp((char*)_content, "my metalayer1", _content_len) == 0);
     if (_content != NULL) {
       free(_content);
     }
     blosc2_get_metalayer(schunk, "metalayer2", &_content, &_content_len);
     mu_assert("ERROR: bad metalayer content", strncmp((char*)_content, "my metalayer1", _content_len) == 0);
     if (_content != NULL) {
       free(_content);
     }
   }
 
   if (usermeta) {
-    int content_len_ = blosc2_get_usermeta(schunk, &content_);
-    mu_assert("ERROR: bad usermeta length in frame", (size_t) content_len_ == content_len);
-    mu_assert("ERROR: bad usermeta data in frame", strncmp((char*)content_, content, content_len) == 0);
+    uint32_t content_len_;
+    blosc2_get_vlmetalayer(schunk, "umetalayer", &content_, &content_len_);
+    mu_assert("ERROR: bad vlmetalayers length in frame", (size_t) content_len_ == content_len);
+    mu_assert("ERROR: bad vlmetalayers data in frame", strncmp((char*)content_, content, content_len) == 0);
     free(content_);
-    blosc2_update_usermeta(schunk, (uint8_t *) content2, (int32_t) content_len2, BLOSC2_CPARAMS_DEFAULTS);
+    blosc2_update_vlmetalayer(schunk, "umetalayer", (uint8_t *) content2, (int32_t) content_len2, NULL);
   }
 
   // Feed it with data
   int _nchunks = 0;
   for (int nchunk = 0; nchunk < nchunks; nchunk++) {
     for (int i = 0; i < CHUNKSIZE; i++) {
       data[i] = i + nchunk * CHUNKSIZE;
     }
     _nchunks = blosc2_schunk_append_buffer(schunk, data, isize);
     mu_assert("ERROR: bad append in frame", nchunk >= 0);
   }
   mu_assert("ERROR: wrong number of append chunks", _nchunks == nchunks);
 
   if (metalayers) {
     uint8_t* _content;
     uint32_t _content_len;
     blosc2_get_metalayer(schunk, "metalayer1", &_content, &_content_len);
     mu_assert("ERROR: bad metalayer content", strncmp((char*)_content, "my metalayer1", _content_len) == 0);
     if (_content != NULL) {
       free(_content);
     }
     blosc2_get_metalayer(schunk, "metalayer2", &_content, &_content_len);
     mu_assert("ERROR: bad metalayer content", strncmp((char*)_content, "my metalayer1", _content_len) == 0);
     if (_content != NULL) {
       free(_content);
     }
     blosc2_update_metalayer(schunk, "metalayer2", (uint8_t*)"my metalayer2", sizeof("my metalayer2"));
   }
 
   if (usermeta) {
-    int content_len_ = blosc2_get_usermeta(schunk, &content_);
-    mu_assert("ERROR: bad usermeta length in frame", (size_t) content_len_ == content_len2);
-    mu_assert("ERROR: bad usermeta data in frame", strncmp((char*)content_, content2, content_len2) == 0);
+    uint32_t content_len_;
+    blosc2_get_vlmetalayer(schunk, "umetalayer", &content_, &content_len_);
+    mu_assert("ERROR: bad vlmetalayers length in frame", (size_t) content_len_ == content_len2);
+    mu_assert("ERROR: bad vlmetalayers data in frame", strncmp((char*)content_, content2, content_len2) == 0);
     free(content_);
-    blosc2_update_usermeta(schunk, (uint8_t *) content3, (int32_t) content_len3, BLOSC2_CPARAMS_DEFAULTS);
+    blosc2_update_vlmetalayer(schunk, "umetalayer", (uint8_t *) content3, (int32_t) content_len3, NULL);
   }
 
   if (free_new) {
     blosc2_schunk_free(schunk);
     schunk = blosc2_schunk_open(directory);
     mu_assert("blosc2_schunk_open() failed (2)", schunk != NULL);
   }
 
   /* Gather some info */
   nbytes = schunk->nbytes;
   cbytes = schunk->cbytes;
   if (nchunks > 0) {
     mu_assert("ERROR: bad compression ratio in frame", nbytes > 10 * cbytes);
   }
 
   // Check that the chunks have been decompressed correctly
   for (int nchunk = 0; nchunk < nchunks; nchunk++) {
     dsize = blosc2_schunk_decompress_chunk(schunk, nchunk, (void *) data_dest, isize);
     mu_assert("ERROR: chunk cannot be decompressed correctly.", dsize >= 0);
     for (int i = 0; i < CHUNKSIZE; i++) {
       mu_assert("ERROR: bad roundtrip", data_dest[i] == i + nchunk * CHUNKSIZE);
     }
   }
 
   if (metalayers) {
     uint8_t* _content;
     uint32_t _content_len;
     blosc2_get_metalayer(schunk, "metalayer1", &_content, &_content_len);
     mu_assert("ERROR: bad metalayer content", strncmp((char*)_content, "my metalayer1", _content_len) == 0);
     if (_content != NULL) {
       free(_content);
     }
     blosc2_get_metalayer(schunk, "metalayer2", &_content, &_content_len);
     mu_assert("ERROR: bad metalayer content", strncmp((char*)_content, "my metalayer2", _content_len) == 0);
     if (_content != NULL) {
       free(_content);
     }
   }
 
   if (usermeta) {
-    int content_len_ = blosc2_get_usermeta(schunk, &content_);
-    mu_assert("ERROR: bad usermeta length in frame", (size_t) content_len_ == content_len3);
-    mu_assert("ERROR: bad usermeta data in frame", strncmp((char*)content_, content3, content_len3) == 0);
+    uint32_t content_len_;
+    blosc2_get_vlmetalayer(schunk, "umetalayer", &content_, &content_len_);
+    mu_assert("ERROR: bad vlmetalayers length in frame", (size_t) content_len_ == content_len3);
+    mu_assert("ERROR: bad vlmetalayers data in frame", strncmp((char*)content_, content3, content_len3) == 0);
     free(content_);
   }
 
   /* Remove directory */
   blosc2_remove_dir(storage.urlpath);
   /* Free resources */
   free(data_dest);
   free(data);
   blosc2_schunk_free(schunk);
 
   /* Destroy the Blosc environment */
   blosc_destroy();
 
   return EXIT_SUCCESS;
 }
