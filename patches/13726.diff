commit c10df533f658e068cfcadbf400c65b9dd579040a
Author: pancake <pancake@nopcode.org>
Date:   Thu May 9 11:51:50 2019 +0200

    Fix ASAN crash (1byte oobread in dex)

diff --git a/libr/bin/p/bin_dex.c b/libr/bin/p/bin_dex.c
index 6b1521e90d..715d42f281 100644
--- a/libr/bin/p/bin_dex.c
+++ b/libr/bin/p/bin_dex.c
@@ -38,36 +38,37 @@ static ut64 get_method_flags(ut64 MA);
 static char *getstr(RBinDexObj *bin, int idx) {
 	ut8 buf[6];
 	ut64 len;
 	int uleblen;
 	// null terminate the buf wtf
 	if (!bin || idx < 0 || idx >= bin->header.strings_size || !bin->strings) {
 		return NULL;
 	}
 	if (bin->strings[idx] >= bin->size) {
 		return NULL;
 	}
 	if (r_buf_read_at (bin->b, bin->strings[idx], buf, sizeof (buf)) < 1) {
 		return NULL;
 	}
 	r_buf_write_at (bin->b, r_buf_size (bin->b) - 1, (ut8 *)"\x00", 1);
 	uleblen = r_uleb128 (buf, sizeof (buf), &len) - buf;
 	if (!uleblen || uleblen >= bin->size) {
 		return NULL;
 	}
 	if (!len || len >= bin->size) {
 		return NULL;
 	}
 	if (bin->strings[idx] + uleblen >= bin->strings[idx] + bin->header.strings_size) {
 		return NULL;
 	}
 	ut8 *ptr = R_NEWS (ut8, len + 1);
 	if (!ptr) {
 		return NULL;
 	}
 	r_buf_read_at (bin->b, bin->strings[idx] + uleblen, ptr, len + 1);
+	ptr[len] = 0;
 	if (len != r_utf8_strlen (ptr)) {
 		// eprintf ("WARNING: Invalid string for index %d\n", idx);
 		return NULL;
 	}
 	return (char *)ptr;
 }
diff --git a/libr/core/cmd.c b/libr/core/cmd.c
index 92e675129b..d61b15c3c7 100644
--- a/libr/core/cmd.c
+++ b/libr/core/cmd.c
@@ -1092,212 +1092,211 @@ R_API int r_line_hist_sdb_down(RLine *line) {
 static int cmd_kuery(void *data, const char *input) {
 	char buf[1024], *out;
 	RCore *core = (RCore*)data;
 	const char *sp, *p = "[sdb]> ";
 	const int buflen = sizeof (buf) - 1;
 	Sdb *s = core->sdb;
 	
 	char *cur_pos, *cur_cmd, *next_cmd = NULL;
 	char *temp_pos, *temp_cmd, *temp_storage = NULL;
 
 	switch (input[0]) {
 
 	case 'j':
 		out = sdb_querys (s, NULL, 0, "anal/**");
 		if (!out) {
 			r_cons_println ("No Output from sdb");
 			break;
 		}
 
 		r_cons_printf ("{\"anal\":{");
 
 		while (*out) {
 			cur_pos = strchr (out, '\n');
 			if (!cur_pos) {
 					break;
 			}
 			cur_cmd = r_str_ndup (out, cur_pos - out);
 
 			r_cons_printf ("\n\n\"%s\" : [", cur_cmd);
 
 			next_cmd = r_str_newf ("anal/%s/*", cur_cmd);
 			temp_storage = sdb_querys (s, NULL, 0, next_cmd);
 
 			if (!temp_storage) {
 				r_cons_println ("\nEMPTY\n");
 				r_cons_printf ("],\n\n");
 				out += cur_pos - out + 1;
 				continue;
 			}
 
 			while (*temp_storage) {
 				temp_pos = strchr (temp_storage, '\n');
 				if (!temp_pos) {
 					break;
 				}
 				
 				temp_cmd = r_str_ndup (temp_storage, temp_pos - temp_storage);
 				r_cons_printf ("\"%s\",", temp_cmd);
 				temp_storage += temp_pos - temp_storage + 1;
 			}
 
 			r_cons_printf ("],\n\n");
 			out += cur_pos - out + 1;
 		}
 
 		r_cons_printf ("}}");
 		free (next_cmd);
 		free (temp_storage);
 		break;
 
 	case ' ':
 		out = sdb_querys (s, NULL, 0, input + 1);
 		if (out) {
 			r_cons_println (out);
 		}
 		free (out);
 		break;
 	//case 's': r_pair_save (s, input + 3); break;
 	//case 'l': r_pair_load (sdb, input + 3); break;
 	case '\0':
 		sdb_foreach (s, callback_foreach_kv, NULL);
 		break;
 	// TODO: add command to list all namespaces // sdb_ns_foreach ?
 	case 's':
 		if (core->http_up) {
 			return false;
 		}
 		if (!r_cons_is_interactive ()) {
 			return false;
 		}
 		if (input[1] == ' ') {
 			char *n, *o, *p = strdup (input + 2);
 			// TODO: slash split here? or inside sdb_ns ?
 			for (n = o = p; n; o = n) {
 				n = strchr (o, '/'); // SDB_NS_SEPARATOR NAMESPACE
 				if (n) {
 					*n++ = 0;
 				}
 				s = sdb_ns (s, o, 1);
 			}
 			free (p);
 		}
 		if (!s) {
 			s = core->sdb;
 		}
 		RLine *line = core->cons->line;
 		if (!line->sdbshell_hist) {
 			line->sdbshell_hist = r_list_newf (free);
 			r_list_append (line->sdbshell_hist, r_str_new ("\0"));
 		}
 		RList *sdb_hist = line->sdbshell_hist;
 		r_line_set_hist_callback (line, &r_line_hist_sdb_up, &r_line_hist_sdb_down);
 		for (;;) {
 			r_line_set_prompt (p);
 			if (r_cons_fgets (buf, buflen, 0, NULL) < 1) {
 				break;
 			}
 			if (!*buf) {
 				break;
 			}
 			if (sdb_hist) {
 				if ((r_list_length (sdb_hist) == 1) || (r_list_length (sdb_hist) > 1 && strcmp (r_list_get_n (sdb_hist, 1), buf))) {
 					r_list_insert (sdb_hist, 1, strdup (buf));
 				}
 				line->sdbshell_hist_iter = sdb_hist->head;
 			}
 			out = sdb_querys (s, NULL, 0, buf);
 			if (out) {
 				r_cons_println (out);
 			}
 		}
 		r_line_set_hist_callback (core->cons->line, &r_line_hist_cmd_up, &r_line_hist_cmd_down);
 		break;
 	case 'o':
 		if (r_sandbox_enable (0)) {
 			eprintf ("This command is disabled in sandbox mode\n");
 			return 0;
 		}
 		if (input[1] == ' ') {
 			char *fn = strdup (input + 2);
 			if (!fn) {
 				eprintf("Unable to allocate memory\n");
 				return 0;
 			}
 			char *ns = strchr (fn, ' ');
 			if (ns) {
 				Sdb *db;
 				*ns++ = 0;
 				if (r_file_exists (fn)) {
 					db = sdb_ns_path (core->sdb, ns, 1);
 					if (db) {
 						Sdb *newdb = sdb_new (NULL, fn, 0);
 						if (newdb) {
 							sdb_drain  (db, newdb);
 						} else {
 							eprintf ("Cannot open sdb '%s'\n", fn);
 						}
 					} else {
 						eprintf ("Cannot find sdb '%s'\n", ns);
 					}
 				} else {
 					eprintf ("Cannot open file\n");
 				}
 			} else {
 				eprintf ("Missing sdb namespace\n");
 			}
 			free (fn);
 		} else {
 			eprintf ("Usage: ko [file] [namespace]\n");
 		}
 		break;
 	case 'd':
 		if (r_sandbox_enable (0)) {
 			eprintf ("This command is disabled in sandbox mode\n");
 			return 0;
 		}
 		if (input[1] == ' ') {
 			char *fn = strdup (input + 2);
 			char *ns = strchr (fn, ' ');
 			if (ns) {
 				*ns++ = 0;
 				Sdb *db = sdb_ns_path (core->sdb, ns, 0);
 				if (db) {
 					sdb_file (db, fn);
 					sdb_sync (db);
 				} else {
 					eprintf ("Cannot find sdb '%s'\n", ns);
 				}
 			} else {
 				eprintf ("Missing sdb namespace\n");
 			}
 			free (fn);
 		} else {
 			eprintf ("Usage: kd [file] [namespace]\n");
 		}
 		break;
-	case '?': {
-			r_core_cmd_help (core, help_msg_k);
-		}
+	case '?':
+		r_core_cmd_help (core, help_msg_k);
 		break;
 	}
 
 	if (input[0] == '\0') {
 		/* nothing more to do, the command has been parsed. */
 		return 0;
 	}
 
 	sp = strchr (input + 1, ' ');
 	if (sp) {
 		char *inp = strdup (input);
 		inp [(size_t)(sp - input)] = 0;
 		s = sdb_ns (core->sdb, inp + 1, 1);
 		out = sdb_querys (s, NULL, 0, sp + 1);
 		if (out) {
 			r_cons_println (out);
 			free (out);
 		}
 		free (inp);
 		return 0;
 	}
 	return 0;
 }
