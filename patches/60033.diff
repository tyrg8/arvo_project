commit 18032cdc408e92aa4c07de1e9226fb01f662e833
Merge: 514ea2d0b af0facad9
Author: JacobBarthelmeh <jacob@wolfssl.com>
Date:   Fri Jun 23 16:19:31 2023 -0700

    Merge pull request #6535 from dgarske/wpas_small
    
    Fix for `--enable-wpas=small`

diff --git a/src/ssl_asn1.c b/src/ssl_asn1.c
index fb33a2548..e9ece79df 100644
--- a/src/ssl_asn1.c
+++ b/src/ssl_asn1.c
@@ -1581,69 +1581,69 @@ void wolfSSL_ASN1_OBJECT_free(WOLFSSL_ASN1_OBJECT* obj)
 /* Duplicate the ASN.1 OBJECT_ID object.
  *
  * @param [in] obj  ASN.1 OBJECT_ID object to copy.
  * @return  New ASN.1 OBJECT_ID object on success.
  * @return  NULL when obj is NULL or dynamic memory allocation fails.
  */
 WOLFSSL_ASN1_OBJECT* wolfSSL_ASN1_OBJECT_dup(WOLFSSL_ASN1_OBJECT* obj)
 {
     WOLFSSL_ASN1_OBJECT* dupl = NULL;
 
     WOLFSSL_ENTER("wolfSSL_ASN1_OBJECT_dup");
 
     /* Validate parameter. */
     if (obj == NULL) {
         WOLFSSL_MSG("Bad parameter");
     }
     /* Create a new ASN.1 OBJECT_ID object to return. */
     else if ((dupl = wolfSSL_ASN1_OBJECT_new()) == NULL) {
         WOLFSSL_MSG("wolfSSL_ASN1_OBJECT_new error");
     }
     if (dupl != NULL) {
         /* Copy short name. */
         XMEMCPY(dupl->sName, obj->sName, WOLFSSL_MAX_SNAME);
         /* Copy simple fields. */
         dupl->type  = obj->type;
         dupl->grp   = obj->grp;
         dupl->nid   = obj->nid;
         dupl->objSz = obj->objSz;
         /* Check for encoding. */
         if (obj->obj) {
             /* Allocate memory for ASN.1 OBJECT_ID DER encoding. */
             dupl->obj = (const unsigned char*)XMALLOC(obj->objSz, NULL,
                 DYNAMIC_TYPE_ASN1);
             if (dupl->obj == NULL) {
                 WOLFSSL_MSG("ASN1 obj malloc error");
                 wolfSSL_ASN1_OBJECT_free(dupl);
                 dupl = NULL;
             }
             else {
                 /* Encoding buffer was dynamically allocated. */
                 dupl->dynamic |= WOLFSSL_ASN1_DYNAMIC_DATA;
                 /* Copy DER encoding. */
                 XMEMCPY((byte*)dupl->obj, obj->obj, obj->objSz);
             }
         }
     }
 
     return dupl;
 }
 #endif /* OPENSSL_EXTRA || OPENSSL_EXTRA_X509_SMALL */
 #endif /* !NO_ASN */
 
-#ifdef OPENSSL_EXTRA
+#if defined(OPENSSL_EXTRA) || defined(WOLFSSL_WPAS_SMALL)
 
 /**
  * Parse DER encoding and return header information.
  *
  * *in is moved to the value of the ASN1 object
  *
  * @param [in, out] in     Pointer to BER encoded data.
  * @param [out]     len    Length of parsed ASN1 object
  * @param [out]     tag    Tag value of parsed ASN1 object
  * @param [out]     cls    Class of parsed ASN1 object
  * @param [in]      inLen  Length of *in buffer
  * @return int  Depends on which bits are set in the returned int:
  *              0x80 an error occurred during parsing.
  *              0x20 parsed object is constructed.
  *              0x01 the parsed object length is indefinite.
  */
@@ -1803,67 +1803,71 @@ int wolfSSL_i2d_ASN1_OBJECT(WOLFSSL_ASN1_OBJECT *a, unsigned char **pp)
 /* Create an ASN.1 OBJECT_ID object from the content octets.
  *
  * @param [out]     a    Pointer to return ASN.1 OBJECT_ID object.
  * @param [in, out] pp   Pointer to buffer holding content octets.
  * @param [in]      len  Length of content octets in bytes.
  * @return  New ASN.1 OBJECT_ID object on success.
  * @return  NULL when pp or *pp is NULL or length is less than or equal zero.
  * @return  NULL when dynamic memory allocation fails.
  */
 WOLFSSL_ASN1_OBJECT *wolfSSL_c2i_ASN1_OBJECT(WOLFSSL_ASN1_OBJECT **a,
         const unsigned char **pp, long len)
 {
     int err = 0;
     WOLFSSL_ASN1_OBJECT* ret = NULL;
 
     WOLFSSL_ENTER("wolfSSL_c2i_ASN1_OBJECT");
 
     /* Validate parameters. */
     if ((pp == NULL) || (*pp == NULL) || (len <= 0)) {
         WOLFSSL_MSG("Bad parameter");
         err = 1;
     }
 
     /* Create a new ASN.1 OBJECT_ID object. */
     if ((!err) && ((ret = wolfSSL_ASN1_OBJECT_new()) == NULL)) {
         WOLFSSL_MSG("wolfSSL_ASN1_OBJECT_new error");
         err = 1;
     }
 
     if (!err) {
         /* Allocate memory for content octets. */
         ret->obj = (const unsigned char*)XMALLOC((size_t)len, NULL,
             DYNAMIC_TYPE_ASN1);
         if (ret->obj == NULL) {
             WOLFSSL_MSG("error allocating asn data memory");
             wolfSSL_ASN1_OBJECT_free(ret);
             ret = NULL;
             err = 1;
         }
     }
 
     if (!err) {
         /* Content octets buffer was dynamically allocated. */
         ret->dynamic |= WOLFSSL_ASN1_DYNAMIC_DATA;
         /* Copy in content octets and set size. */
         XMEMCPY((byte*)ret->obj, *pp, (size_t)len);
         ret->objSz = (unsigned int)len;
 
         /* Move pointer to after data copied out. */
         *pp += len;
         /* Return ASN.1 OBJECT_ID object through a if required. */
         if (a != NULL) {
             *a = ret;
         }
     }
 
     return ret;
 }
 
+#endif /* OPENSSL_EXTRA || WOLFSSL_WPAS_SMALL */
+
+#ifdef OPENSSL_EXTRA
+
 /* Write at most buf_len bytes of textual representation of ASN.1 OBJECT_ID.
  *
  * @param [in, out] buf      Buffer to write to.
  * @param [in]      buf_len  Length of buffer in bytes.
  * @param [in]      a        ASN.1 OBJECT_ID object.
  * @return  Number of bytes written on success.
  * @return  0 on failure.
  */
@@ -3196,41 +3200,41 @@ static long long wolfssl_time_to_unix_time(int sec, int minute, int hour,
 /* Convert ASN.1 TIME object to Unix time (GMT).
  *
  * @param [in]  t     ASN.1 TIME object.
  * @param [out] secs  Number of seconds since 00:00:00 01/01/1970.
  * @return  1 on success.
  * @return  0 when conversion of time fails.
  */
 static int wolfssl_asn1_time_to_secs(const WOLFSSL_ASN1_TIME* t,
     long long* secs)
 {
     int ret = 1;
     struct tm tm_s;
     struct tm *tmGmt = &tm_s;
 
     /* Convert ASN.1 TIME to broken-down time. NULL treated as current time. */
     ret = wolfSSL_ASN1_TIME_to_tm(t, tmGmt);
     if (ret != 1) {
         WOLFSSL_MSG("Failed to convert from time to struct tm.");
     }
     else {
         /* We use wolfssl_time_to_unix_time here instead of XMKTIME to avoid the
          * Year 2038 problem on platforms where time_t is 32 bits. struct tm
          * stores the year as years since 1900, so we add 1900 to the year. */
         *secs = wolfssl_time_to_unix_time(tmGmt->tm_sec, tmGmt->tm_min,
             tmGmt->tm_hour, tmGmt->tm_mday, tmGmt->tm_mon,
             tmGmt->tm_year + 1900);
     }
 
     return ret;
 }
 
 /* Calculate difference in time of two ASN.1 TIME objects.
  *
  * @param [out] days  Number of whole days between from and to.
- * @param [out] secs  Number of serconds less than a day between from and to.
+ * @param [out] secs  Number of seconds less than a day between from and to.
  * @param [in]  from  ASN.1 TIME object as start time.
  * @param [in]  to    ASN.1 TIME object as end time.
  * @return  1 on success.
  * @return  0 when days or secs is NULL.
  * @return  0 when conversion of time fails.
  */
@@ -3877,52 +3881,52 @@ int wolfSSL_ASN1_TIME_print(WOLFSSL_BIO* bio, const WOLFSSL_ASN1_TIME* asnTime)
 #ifndef NO_BIO
 /* Print the ASN.1 UTC TIME object as a string to BIO.
  *
  * @param [in] bio      BIO to write to.
  * @param [in] asnTime  ASN.1 UTC TIME object.
  * @return  1 on success.
  * @return  0 when bio or asnTime is NULL.
  * @return  0 when ASN.1 type is not UTC TIME.
  * @return  0 when creating human readable string fails.
  * @return  0 when writing to BIO fails.
  */
 int wolfSSL_ASN1_UTCTIME_print(WOLFSSL_BIO* bio, const WOLFSSL_ASN1_UTCTIME* a)
 {
     int ret = 1;
 
     WOLFSSL_ENTER("wolfSSL_ASN1_UTCTIME_print");
 
     /* Validate parameters. */
     if ((bio == NULL) || (a == NULL)) {
         ret = 0;
     }
     /* Validate ASN.1 UTC TIME object is of type UTC_TIME. */
     if ((ret == 1) && (a->type != V_ASN1_UTCTIME)) {
         WOLFSSL_MSG("Error, not UTC_TIME");
         ret = 0;
     }
 
     if (ret == 1) {
         /* Use generic time printing function to do work. */
         ret = wolfSSL_ASN1_TIME_print(bio, a);
     }
 
     return ret;
 }
 #endif /* !NO_BIO */
 
 #endif /* OPENSSL_EXTRA */
 
 #endif /* !NO_ASN_TIME */
 
 /*******************************************************************************
  * ASN1_TYPE APIs
  ******************************************************************************/
 
-#ifdef OPENSSL_EXTRA
+#if defined(OPENSSL_EXTRA) || defined(WOLFSSL_WPAS_SMALL)
 
 /**
  * Allocate a new ASN.1 TYPE object.
  *
  * @return  New empty ASN.1 TYPE object on success.
  * @return  NULL when dynamic memory allocation fails.
  */
@@ -3944,72 +3948,73 @@ WOLFSSL_ASN1_TYPE* wolfSSL_ASN1_TYPE_new(void)
 /* Free the ASN.1 TYPE object's value field.
  *
  * @param [in, out] at  ASN.1 TYPE object.
  */
 static void wolfssl_asn1_type_free_value(WOLFSSL_ASN1_TYPE* at)
 {
     switch (at->type) {
         case V_ASN1_NULL:
             break;
         case V_ASN1_OBJECT:
             wolfSSL_ASN1_OBJECT_free(at->value.object);
             break;
         case V_ASN1_UTCTIME:
-        #ifndef NO_ASN_TIME
+        #if !defined(NO_ASN_TIME) && defined(OPENSSL_EXTRA)
             wolfSSL_ASN1_TIME_free(at->value.utctime);
         #endif
             break;
         case V_ASN1_GENERALIZEDTIME:
-        #ifndef NO_ASN_TIME
+        #if !defined(NO_ASN_TIME) && defined(OPENSSL_EXTRA)
             wolfSSL_ASN1_TIME_free(at->value.generalizedtime);
         #endif
             break;
         case V_ASN1_UTF8STRING:
         case V_ASN1_PRINTABLESTRING:
         case V_ASN1_T61STRING:
         case V_ASN1_IA5STRING:
         case V_ASN1_UNIVERSALSTRING:
         case V_ASN1_SEQUENCE:
             wolfSSL_ASN1_STRING_free(at->value.asn1_string);
             break;
         default:
             break;
     }
 }
 
 /**
  * Free ASN.1 TYPE object and its value.
  *
  * @param [in, out] at  ASN.1 TYPE object.
  */
 void wolfSSL_ASN1_TYPE_free(WOLFSSL_ASN1_TYPE* at)
 {
     if (at != NULL) {
         /* Dispose of value in ASN.1 TYPE object. */
         wolfssl_asn1_type_free_value(at);
     }
     /* Dispose of ASN.1 TYPE object. */
     XFREE(at, NULL, DYNAMIC_TYPE_OPENSSL);
 }
 
-#endif /* OPENSSL_EXTRA */
+#endif /* OPENSSL_EXTRA || WOLFSSL_WPAS_SMALL */
 
-#if defined(OPENSSL_ALL) || defined(OPENSSL_EXTRA) || defined(WOLFSSL_WPAS)
+#if defined(OPENSSL_ALL) || defined(OPENSSL_EXTRA) || defined(WOLFSSL_WPAS) || \
+    defined(WOLFSSL_WPAS_SMALL)
 /**
  * Set ASN.1 TYPE object with a type and value.
  *
  * Type of value for different types:
  *   V_ASN1_NULL            : Value should be NULL.
  *   V_ASN1_OBJECT          : WOLFSSL_ASN1_OBJECT.
  *   V_ASN1_UTCTIME         : WOLFSSL_ASN1_TIME.
  *   V_ASN1_GENERALIZEDTIME : WOLFSSL_ASN1_TIME.
  *   V_ASN1_UTF8STRING      : WOLFSSL_ASN1_STRING.
  *   V_ASN1_PRINTABLESTRING : WOLFSSL_ASN1_STRING.
  *   V_ASN1_T61STRING       : WOLFSSL_ASN1_STRING.
  *   V_ASN1_IA5STRING       : WOLFSSL_ASN1_STRING.
  *   V_ASN1_UNINVERSALSTRING: WOLFSSL_ASN1_STRING.
  *   V_ASN1_SEQUENCE        : WOLFSSL_ASN1_STRING.
  *
  * @param [in, out] a      ASN.1 TYPE object to set.
  * @param [in]      type   ASN.1 type of value.
  * @param [in]      value  Value to store.
  */
diff --git a/src/x509.c b/src/x509.c
index bc1c48992..860eea185 100644
--- a/src/x509.c
+++ b/src/x509.c
@@ -519,32 +519,36 @@ WOLFSSL_X509_EXTENSION* wolfSSL_X509_get_ext(const WOLFSSL_X509* x509, int loc)
 int wolfSSL_X509_get_ext_by_OBJ(const WOLFSSL_X509 *x,
         const WOLFSSL_ASN1_OBJECT *obj, int lastpos)
 {
     const WOLF_STACK_OF(WOLFSSL_X509_EXTENSION) *sk;
 
     if (!x || !obj) {
         WOLFSSL_MSG("Bad parameter");
         return -1;
     }
 
     sk = wolfSSL_X509_get0_extensions(x);
     if (!sk) {
         WOLFSSL_MSG("No extensions");
         return -1;
     }
     lastpos++;
     if (lastpos < 0)
         lastpos = 0;
     for (; lastpos < wolfSSL_sk_num(sk); lastpos++)
         if (wolfSSL_OBJ_cmp((WOLFSSL_ASN1_OBJECT*)wolfSSL_sk_value(sk,
                         lastpos), obj) == 0)
             return lastpos;
     return -1;
 }
 
+#endif /* OPENSSL_ALL || OPENSSL_EXTRA */
+
+#if defined(OPENSSL_ALL) || defined(OPENSSL_EXTRA) || \
+    defined(WOLFSSL_WPAS_SMALL)
 /* Set a general name from the DNS entry data.
  *
  * @param [in]      dns  DNS entry.
  * @param [in, out] gn   General name to place data in.
  * @return  1 on success.
  * @return  0 on failure.
  */
@@ -649,8 +653,10 @@ static int wolfssl_dns_entry_othername_to_gn(DNS_entry* dns,
     ret = 1;
 err:
     return ret;
 }
+#endif /* OPENSSL_ALL || WOLFSSL_WPAS_SMALL */
 
+#if defined(OPENSSL_ALL) || defined(OPENSSL_EXTRA)
 static int wolfssl_x509_alt_names_to_gn(WOLFSSL_X509* x509,
     WOLFSSL_X509_EXTENSION* ext)
 {
@@ -2111,29 +2117,29 @@ int wolfSSL_X509_get_ext_by_NID(const WOLFSSL_X509* x509, int nid, int lastPos)
 out:
 
     FreeDecodedCert(cert);
 #ifdef WOLFSSL_SMALL_STACK
     XFREE(cert, x509->heap, DYNAMIC_TYPE_DCERT);
 #endif
 
     return found ? extCount : WOLFSSL_FATAL_ERROR;
 }
 
-#endif /* OPENSSL_ALL */
+#endif /* OPENSSL_ALL || OPENSSL_EXTRA */
 
 #if defined(OPENSSL_EXTRA) || defined(WOLFSSL_WPAS_SMALL)
 /* Looks for the extension matching the passed in nid
  *
  * c   : if not null then is set to status value -2 if multiple occurrences
  *       of the extension are found, -1 if not found, 0 if found and not
  *       critical, and 1 if found and critical.
  * nid : Extension OID to be found.
  * idx : if NULL return first extension found match, otherwise start search at
  *       idx location and set idx to the location of extension returned.
  * returns NULL or a pointer to an WOLFSSL_ASN1_BIT_STRING (for KEY_USAGE_OID)
  * or WOLFSSL_STACK (for other)
  * holding extension structure
  *
  * NOTE code for decoding extensions is in asn.c DecodeCertExtensions --
  * use already decoded extension in this function to avoid decoding twice.
  * Currently we do not make use of idx since getting pre decoded extensions.
  */
diff --git a/wolfssl/wolfcrypt/settings.h b/wolfssl/wolfcrypt/settings.h
index 9497fc860..a14364d4d 100644
--- a/wolfssl/wolfcrypt/settings.h
+++ b/wolfssl/wolfcrypt/settings.h
@@ -748,2359 +748,2365 @@ extern void *uITRON4_realloc(void *p, size_t sz) ;
 extern void uITRON4_free(void *p) ;
 
 #define XMALLOC(sz, heap, type)     uITRON4_malloc(sz)
 #define XREALLOC(p, sz, heap, type) uITRON4_realloc(p, sz)
 #define XFREE(p, heap, type)        uITRON4_free(p)
 #endif
 
 #if defined(WOLFSSL_uTKERNEL2)
   #ifndef NO_TKERNEL_MEM_POOL
     #define XMALLOC_OVERRIDE
     int   uTKernel_init_mpool(unsigned int sz); /* initializing malloc pool */
     void* uTKernel_malloc(unsigned int sz);
     void* uTKernel_realloc(void *p, unsigned int sz);
     void  uTKernel_free(void *p);
     #define XMALLOC(s, h, type)  uTKernel_malloc((s))
     #define XREALLOC(p, n, h, t) uTKernel_realloc((p), (n))
     #define XFREE(p, h, type)    uTKernel_free((p))
   #endif
 
   #ifndef NO_STDIO_FGETS_REMAP
     #include <stdio.h>
     #include "tm/tmonitor.h"
 
     /* static char* gets(char *buff); */
     static char* fgets(char *buff, int sz, XFILE fp) {
         char * s = buff;
         *s = '\0';
         while (1) {
             *s = tm_getchar(-1);
             tm_putchar(*s);
             if (*s == '\r') {
                 tm_putchar('\n');
                 *s = '\0';
                 break;
             }
             s++;
         }
         return buff;
     }
   #endif /* !NO_STDIO_FGETS_REMAP */
 #endif
 
 
 #if defined(WOLFSSL_LEANPSK) && !defined(XMALLOC_USER) && \
         !defined(NO_WOLFSSL_MEMORY)
     #include <stdlib.h>
     #define XMALLOC(s, h, type)  malloc((s))
     #define XFREE(p, h, type)    free((p))
     #define XREALLOC(p, n, h, t) realloc((p), (n))
 #endif
 
 #if defined(XMALLOC_USER) && defined(SSN_BUILDING_LIBYASSL)
     #undef  XMALLOC
     #define XMALLOC     yaXMALLOC
     #undef  XFREE
     #define XFREE       yaXFREE
     #undef  XREALLOC
     #define XREALLOC    yaXREALLOC
 #endif
 
 
 #ifdef FREERTOS
     #include "FreeRTOS.h"
     #include <task.h>
 
     #if !defined(XMALLOC_USER) && !defined(NO_WOLFSSL_MEMORY) && \
         !defined(WOLFSSL_STATIC_MEMORY) && !defined(WOLFSSL_TRACK_MEMORY)
         #define XMALLOC(s, h, type)  pvPortMalloc((s))
         #define XFREE(p, h, type)    vPortFree((p))
         #if defined(WOLFSSL_ESPIDF)
                 /* In IDF, realloc(p, n) is equivalent to
                  * heap_caps_realloc(p, s, MALLOC_CAP_8BIT) */
                 #define XREALLOC(p, n, h, t) realloc((p), (n))
         /* FreeRTOS pvPortRealloc() implementation can be found here:
          * https://github.com/wolfSSL/wolfssl-freertos/pull/3/files */
         #elif defined(USE_INTEGER_HEAP_MATH) || defined(OPENSSL_EXTRA)
                 #define XREALLOC(p, n, h, t) pvPortRealloc((p), (n))
         #endif
     #endif
 
     #ifndef NO_WRITEV
         #define NO_WRITEV
     #endif
     #ifndef HAVE_SHA512
         #ifndef NO_SHA512
             #define NO_SHA512
         #endif
     #endif
     #ifndef HAVE_DH
         #ifndef NO_DH
             #define NO_DH
         #endif
     #endif
     #ifndef NO_DSA
         #define NO_DSA
     #endif
 
     #ifndef SINGLE_THREADED
         #include "semphr.h"
     #endif
 #endif
 
 #ifdef FREERTOS_TCP
     #if !defined(NO_WOLFSSL_MEMORY) && !defined(XMALLOC_USER) && \
         !defined(WOLFSSL_STATIC_MEMORY)
         #define XMALLOC(s, h, type)  pvPortMalloc((s))
         #define XFREE(p, h, type)    vPortFree((p))
     #endif
 
     #define WOLFSSL_GENSEED_FORTEST
 
     #define NO_WOLFSSL_DIR
     #define NO_WRITEV
     #define TFM_TIMING_RESISTANT
     #define NO_MAIN_DRIVER
 #endif
 
 #ifdef WOLFSSL_TI_CRYPT
     #define NO_GCM_ENCRYPT_EXTRA
     #define NO_PUBLIC_GCM_SET_IV
     #define NO_PUBLIC_CCM_SET_NONCE
 #endif
 
 #ifdef WOLFSSL_TIRTOS
     #define SIZEOF_LONG_LONG 8
     #define NO_WRITEV
     #define NO_WOLFSSL_DIR
 
     /* Enable SP math by default, unless fast math
      * specified in user_settings.
      */
     #ifndef USE_FAST_MATH
         #define WOLFSSL_HAVE_SP_ECC
         #define SP_WORD_SIZE 32
         #define WOLFSSL_HAVE_SP_RSA
         #define WOLFSSL_SP_4096
     #endif
     #define TFM_TIMING_RESISTANT
     #define ECC_TIMING_RESISTANT
     #define WC_RSA_BLINDING
     #define NO_DEV_RANDOM
     #define NO_FILESYSTEM
     #define NO_SIG_WRAPPER
     #define NO_MAIN_DRIVER
     #define USE_CERT_BUFFERS_2048
     #define NO_ERROR_STRINGS
     /* Uncomment this setting if your toolchain does not offer time.h header */
     /* #define USER_TIME */
     #define HAVE_ECC
     #define HAVE_ALPN
     #define USE_WOLF_STRTOK /* use with HAVE_ALPN */
     #define HAVE_TLS_EXTENSIONS
     #define HAVE_AESGCM
     #define HAVE_SUPPORTED_CURVES
     #ifdef __IAR_SYSTEMS_ICC__
         #pragma diag_suppress=Pa089
     #elif !defined(__GNUC__)
         /* Suppress the sslpro warning */
         #pragma diag_suppress=11
     #endif
     #include <ti/sysbios/hal/Seconds.h>
 #endif
 
 #ifdef EBSNET
     #include "rtip.h"
 
     /* #define DEBUG_WOLFSSL */
     #define NO_WOLFSSL_DIR  /* tbd */
 
     #if (POLLOS)
         #define SINGLE_THREADED
     #endif
 
     #if (defined(RTPLATFORM) && (RTPLATFORM != 0))
         #if (!RTP_LITTLE_ENDIAN)
             #define BIG_ENDIAN_ORDER
         #endif
     #else
         #if (!KS_LITTLE_ENDIAN)
             #define BIG_ENDIAN_ORDER
         #endif
     #endif
 
     #if (WINMSP3)
         #undef SIZEOF_LONG
         #define SIZEOF_LONG_LONG 8
     #else
         #if !defined(SIZEOF_LONG) && !defined(SIZEOF_LONG_LONG)
             #error settings.h - please implement SIZEOF_LONG and SIZEOF_LONG_LONG
         #endif
     #endif
 
     #if (WINMSP3)
         #define strtok_r strtok_s
     #endif
 
     #define XMALLOC(s, h, type) ((void *)rtp_malloc((s), SSL_PRO_MALLOC))
     #define XFREE(p, h, type) (rtp_free(p))
     #define XREALLOC(p, n, h, t) (rtp_realloc((p), (n), (t)))
 
     #if (WINMSP3)
         #define XSTRNCASECMP(s1,s2,n)  _strnicmp((s1),(s2),(n))
     #else
         #ifndef XSTRNCASECMP
             #error settings.h - please implement XSTRNCASECMP - needed for HAVE_ECC
         #endif
     #endif
 
     #define WOLFSSL_HAVE_MAX
     #define WOLFSSL_HAVE_MIN
 
     #define TFM_TIMING_RESISTANT
     #define WC_RSA_BLINDING
     #define ECC_TIMING_RESISTANT
 
     #define HAVE_ECC
 
 #endif /* EBSNET */
 
 #ifdef WOLFSSL_GAME_BUILD
     #define SIZEOF_LONG_LONG 8
 #endif
 
 #ifdef WOLFSSL_LSR
     #define HAVE_WEBSERVER
     #define SIZEOF_LONG_LONG 8
     #define WOLFSSL_LOW_MEMORY
     #define NO_WRITEV
     #define NO_SHA512
     #define NO_DH
     /* Allows use of DH with fixed points if uncommented and NO_DH is removed */
     /* WOLFSSL_DH_CONST */
     #define NO_DSA
     #define NO_DEV_RANDOM
     #define NO_WOLFSSL_DIR
     #ifndef NO_FILESYSTEM
         #define LSR_FS
         #include "inc/hw_types.h"
         #include "fs.h"
     #endif
     #define WOLFSSL_LWIP
     #include <errno.h>  /* for tcp errno */
     #define WOLFSSL_SAFERTOS
     #if defined(__IAR_SYSTEMS_ICC__)
         /* enum uses enum */
         #pragma diag_suppress=Pa089
     #endif
 #endif
 
 #ifdef WOLFSSL_SAFERTOS
     #ifndef SINGLE_THREADED
         #include "SafeRTOS/semphr.h"
     #endif
     #ifndef WOLFSSL_NO_MALLOC
         #include "SafeRTOS/heap.h"
     #endif
     #if !defined(XMALLOC_USER) && !defined(NO_WOLFSSL_MEMORY) && \
         !defined(WOLFSSL_STATIC_MEMORY)
         #define XMALLOC(s, h, type)  pvPortMalloc((s))
         #define XFREE(p, h, type)    vPortFree((p))
 
         /* FreeRTOS pvPortRealloc() implementation can be found here:
             https://github.com/wolfSSL/wolfssl-freertos/pull/3/files */
         #if !defined(USE_FAST_MATH) || defined(HAVE_ED25519) || \
             defined(HAVE_ED448)
             #define XREALLOC(p, n, h, t) pvPortRealloc((p), (n))
         #endif
     #endif
 #endif
 
 #ifdef WOLFSSL_LOW_MEMORY
     #undef  RSA_LOW_MEM
     #define RSA_LOW_MEM
     #undef  WOLFSSL_SMALL_STACK
     #define WOLFSSL_SMALL_STACK
     #undef  TFM_TIMING_RESISTANT
     #define TFM_TIMING_RESISTANT
 #endif
 
 /* To support storing some of the large constant tables in flash memory rather than SRAM.
    Useful for processors that have limited SRAM, such as the AVR family of microtrollers. */
 #ifdef WOLFSSL_USE_FLASHMEM
     /* This is supported on the avr-gcc compiler, for more information see:
          https://gcc.gnu.org/onlinedocs/gcc/Named-Address-Spaces.html */
     #define FLASH_QUALIFIER __flash
 
     /* Copy data out of flash memory and into SRAM */
     #define XMEMCPY_P(pdest, psrc, size) memcpy_P((pdest), (psrc), (size))
 #else
     #define FLASH_QUALIFIER
 #endif
 
 #ifdef FREESCALE_MQX_5_0
     /* use normal Freescale MQX port, but with minor changes for 5.0 */
     #define FREESCALE_MQX
 #endif
 
 #ifdef FREESCALE_MQX_4_0
     /* use normal Freescale MQX port, but with minor changes for 4.0 */
     #define FREESCALE_MQX
 #endif
 
 #ifdef FREESCALE_MQX
     #define FREESCALE_COMMON
     #include "mqx.h"
     #ifndef NO_FILESYSTEM
         #include "mfs.h"
         #if (defined(MQX_USE_IO_OLD) && MQX_USE_IO_OLD) || \
             defined(FREESCALE_MQX_5_0)
             #include "fio.h"
             #define NO_STDIO_FILESYSTEM
         #else
             #include "nio.h"
         #endif
     #endif
     #ifndef SINGLE_THREADED
         #include "mutex.h"
     #endif
 
     #if !defined(XMALLOC_OVERRIDE) && !defined(XMALLOC_USER)
         #define XMALLOC_OVERRIDE
         #define XMALLOC(s, h, t)    (void *)_mem_alloc_system((s))
         #define XFREE(p, h, t)      {void* xp = (p); if ((xp)) _mem_free((xp));}
         /* Note: MQX has no realloc, using fastmath above */
     #endif
     #ifdef USE_FAST_MATH
         /* Undef first to avoid re-definition if user_settings.h defines */
         #undef TFM_TIMING_RESISTANT
         #define TFM_TIMING_RESISTANT
         #undef ECC_TIMING_RESISTANT
         #define ECC_TIMING_RESISTANT
         #undef WC_RSA_BLINDING
         #define WC_RSA_BLINDING
     #endif
 #endif
 
 #ifdef FREESCALE_KSDK_MQX
     #define FREESCALE_COMMON
     #include <mqx.h>
     #ifndef NO_FILESYSTEM
         #if (defined(MQX_USE_IO_OLD) && MQX_USE_IO_OLD) || \
             defined(FREESCALE_MQX_5_0)
             #include <fio.h>
         #else
             #include <stdio.h>
             #include <nio.h>
         #endif
     #endif
     #ifndef SINGLE_THREADED
         #include <mutex.h>
     #endif
 
     #define XMALLOC(s, h, t)    (void *)_mem_alloc_system((s))
     #define XFREE(p, h, t)      {void* xp = (p); if ((xp)) _mem_free((xp));}
     #define XREALLOC(p, n, h, t) _mem_realloc((p), (n)) /* since MQX 4.1.2 */
 
     #define MQX_FILE_PTR FILE *
     #define IO_SEEK_SET  SEEK_SET
     #define IO_SEEK_END  SEEK_END
 #endif /* FREESCALE_KSDK_MQX */
 
 #if defined(FREESCALE_FREE_RTOS) || defined(FREESCALE_KSDK_FREERTOS)
     #define NO_FILESYSTEM
     #define WOLFSSL_CRYPT_HW_MUTEX 1
 
     #if !defined(XMALLOC_USER) && !defined(NO_WOLFSSL_MEMORY)
         #define XMALLOC(s, h, type)  pvPortMalloc((s))
         #define XFREE(p, h, type)    vPortFree((p))
     #endif
 
     /* #define USER_TICKS */
     /* Allows use of DH with fixed points if uncommented and NO_DH is removed */
     /* WOLFSSL_DH_CONST */
     #define WOLFSSL_LWIP
     #define FREERTOS_TCP
 
     #define FREESCALE_FREE_RTOS
     #define FREERTOS_SOCKET_ERROR ( -1 )
     #define FREERTOS_EWOULDBLOCK ( -2 )
     #define FREERTOS_EINVAL ( -4 )
     #define FREERTOS_EADDRNOTAVAIL ( -5 )
     #define FREERTOS_EADDRINUSE ( -6 )
     #define FREERTOS_ENOBUFS ( -7 )
     #define FREERTOS_ENOPROTOOPT ( -8 )
 #endif /* FREESCALE_FREE_RTOS || FREESCALE_KSDK_FREERTOS */
 
 #ifdef FREESCALE_KSDK_BM
     #define FREESCALE_COMMON
     #define WOLFSSL_USER_IO
     #define SINGLE_THREADED
     #define NO_FILESYSTEM
     #ifndef TIME_OVERRIDES
         #define USER_TICKS
     #endif
 #endif /* FREESCALE_KSDK_BM */
 
 #ifdef FREESCALE_COMMON
     #define SIZEOF_LONG_LONG 8
 
     /* disable features */
     #undef  NO_WRITEV
     #define NO_WRITEV
     #undef  NO_DEV_RANDOM
     #define NO_DEV_RANDOM
     #undef  NO_WOLFSSL_DIR
     #define NO_WOLFSSL_DIR
     #undef  NO_RC4
     #define NO_RC4
 
     /* enable features */
     #define USE_CERT_BUFFERS_2048
     #define BENCH_EMBEDDED
 
     #define TFM_TIMING_RESISTANT
     #define ECC_TIMING_RESISTANT
 
     #undef  HAVE_ECC
     #ifndef WOLFCRYPT_FIPS_RAND
     #define HAVE_ECC
     #endif
     #ifndef NO_AES
         #undef  HAVE_AESCCM
         #define HAVE_AESCCM
         #undef  HAVE_AESGCM
         #define HAVE_AESGCM
         #undef  WOLFSSL_AES_COUNTER
         #define WOLFSSL_AES_COUNTER
         #undef  WOLFSSL_AES_DIRECT
         #define WOLFSSL_AES_DIRECT
     #endif
 
     #ifdef FREESCALE_KSDK_1_3
         #include "fsl_device_registers.h"
     #elif !defined(FREESCALE_MQX)
         /* Classic MQX does not have fsl_common.h */
         #include "fsl_common.h"
     #endif
 
     /* random seed */
     #define NO_OLD_RNGNAME
     #if   defined(FREESCALE_NO_RNG)
         /* nothing to define */
     #elif defined(FSL_FEATURE_SOC_TRNG_COUNT) && (FSL_FEATURE_SOC_TRNG_COUNT > 0)
         #define FREESCALE_KSDK_2_0_TRNG
     #elif defined(FSL_FEATURE_SOC_RNG_COUNT) && (FSL_FEATURE_SOC_RNG_COUNT > 0)
         #ifdef FREESCALE_KSDK_1_3
             #include "fsl_rnga_driver.h"
             #define FREESCALE_RNGA
             #define RNGA_INSTANCE (0)
         #else
             #define FREESCALE_KSDK_2_0_RNGA
         #endif
     #elif !defined(FREESCALE_KSDK_BM) && !defined(FREESCALE_FREE_RTOS) && !defined(FREESCALE_KSDK_FREERTOS)
         #define FREESCALE_RNGA
         #define RNGA_INSTANCE (0)
         /* defaulting to K70 RNGA, user should change if different */
         /* #define FREESCALE_K53_RNGB */
         #define FREESCALE_K70_RNGA
     #endif
 
     /* HW crypto */
     /* automatic enable based on Kinetis feature */
     /* if case manual selection is required, for example for benchmarking purposes,
      * just define FREESCALE_USE_MMCAU or FREESCALE_USE_LTC or none of these two macros (for software only)
      * both can be enabled simultaneously as LTC has priority over MMCAU in source code.
      */
     /* #define FSL_HW_CRYPTO_MANUAL_SELECTION */
     #ifndef FSL_HW_CRYPTO_MANUAL_SELECTION
         #if defined(FSL_FEATURE_SOC_MMCAU_COUNT) && FSL_FEATURE_SOC_MMCAU_COUNT
             #define FREESCALE_USE_MMCAU
         #endif
 
         #if defined(FSL_FEATURE_SOC_LTC_COUNT) && FSL_FEATURE_SOC_LTC_COUNT
             #define FREESCALE_USE_LTC
         #endif
     #else
         /* #define FREESCALE_USE_MMCAU */
         /* #define FREESCALE_USE_LTC */
     #endif
 #endif /* FREESCALE_COMMON */
 
 /* Classic pre-KSDK mmCAU library */
 #ifdef FREESCALE_USE_MMCAU_CLASSIC
     #define FREESCALE_USE_MMCAU
     #define FREESCALE_MMCAU_CLASSIC
     #define FREESCALE_MMCAU_CLASSIC_SHA
 #endif
 
 /* KSDK mmCAU library */
 #ifdef FREESCALE_USE_MMCAU
     /* AES and DES */
     #define FREESCALE_MMCAU
     /* MD5, SHA-1 and SHA-256 */
     #define FREESCALE_MMCAU_SHA
 #endif /* FREESCALE_USE_MMCAU */
 
 #ifdef FREESCALE_USE_LTC
     #if defined(FSL_FEATURE_SOC_LTC_COUNT) && FSL_FEATURE_SOC_LTC_COUNT
         #define FREESCALE_LTC
         #define LTC_BASE LTC0
 
         #if defined(FSL_FEATURE_LTC_HAS_DES) && FSL_FEATURE_LTC_HAS_DES
             #define FREESCALE_LTC_DES
         #endif
 
         #if defined(FSL_FEATURE_LTC_HAS_GCM) && FSL_FEATURE_LTC_HAS_GCM
             #define FREESCALE_LTC_AES_GCM
         #endif
 
         #if defined(FSL_FEATURE_LTC_HAS_SHA) && FSL_FEATURE_LTC_HAS_SHA
             #define FREESCALE_LTC_SHA
         #endif
 
         #if defined(FSL_FEATURE_LTC_HAS_PKHA) && FSL_FEATURE_LTC_HAS_PKHA
             #ifndef WOLFCRYPT_FIPS_RAND
             #define FREESCALE_LTC_ECC
             #endif
             #define FREESCALE_LTC_TFM
 
             /* the LTC PKHA hardware limit is 2048 bits (256 bytes) for integer arithmetic.
                the LTC_MAX_INT_BYTES defines the size of local variables that hold big integers. */
             /* size is multiplication of 2 big ints */
             #if !defined(NO_RSA) || !defined(NO_DH)
                 #define LTC_MAX_INT_BYTES   (256*2)
             #else
                 #define LTC_MAX_INT_BYTES   (48*2)
             #endif
 
             /* This FREESCALE_LTC_TFM_RSA_4096_ENABLE macro can be defined.
              * In such a case both software and hardware algorithm
              * for TFM is linked in. The decision for which algorithm is used is determined at runtime
              * from size of inputs. If inputs and result can fit into LTC (see LTC_MAX_INT_BYTES)
              * then we call hardware algorithm, otherwise we call software algorithm.
              *
              * Chinese reminder theorem is used to break RSA 4096 exponentiations (both public and private key)
              * into several computations with 2048-bit modulus and exponents.
              */
             /* #define FREESCALE_LTC_TFM_RSA_4096_ENABLE */
 
             /* ECC-384, ECC-256, ECC-224 and ECC-192 have been enabled with LTC PKHA acceleration */
             #ifdef HAVE_ECC
                 #undef  ECC_TIMING_RESISTANT
                 #define ECC_TIMING_RESISTANT
 
                 /* the LTC PKHA hardware limit is 512 bits (64 bytes) for ECC.
                    the LTC_MAX_ECC_BITS defines the size of local variables that hold ECC parameters
                    and point coordinates */
                 #ifndef LTC_MAX_ECC_BITS
                     #define LTC_MAX_ECC_BITS (384)
                 #endif
 
                 /* Enable curves up to 384 bits */
                 #if !defined(ECC_USER_CURVES) && !defined(HAVE_ALL_CURVES)
                     #define ECC_USER_CURVES
                     #define HAVE_ECC192
                     #define HAVE_ECC224
                     #undef  NO_ECC256
                     #define HAVE_ECC384
                 #endif
             #endif
         #endif
     #endif
 #endif /* FREESCALE_USE_LTC */
 
 #ifdef FREESCALE_LTC_TFM_RSA_4096_ENABLE
     #undef  USE_CERT_BUFFERS_4096
     #define USE_CERT_BUFFERS_4096
     #undef  FP_MAX_BITS
     #define FP_MAX_BITS (8192)
     #undef  SP_INT_BITS
     #define SP_INT_BITS (4096)
 
     #undef  NO_DH
     #define NO_DH
     #undef  NO_DSA
     #define NO_DSA
 #endif /* FREESCALE_LTC_TFM_RSA_4096_ENABLE */
 
 /* if LTC has AES engine but doesn't have GCM, use software with LTC AES ECB mode */
 #if defined(FREESCALE_USE_LTC) && !defined(FREESCALE_LTC_AES_GCM)
     #define GCM_TABLE
 #endif
 
 #if defined(WOLFSSL_MAXQ1065) || defined(WOLFSSL_MAXQ108X)
 
     #define MAXQ10XX_MODULE_INIT
 
     #define HAVE_PK_CALLBACKS
     #define WOLFSSL_STATIC_PSK
     /* Server side support to be added at a later date. */
     #define NO_WOLFSSL_SERVER
     /* Need WOLFSSL_PUBLIC_ASN to use ProcessPeerCert callback. */
     #define WOLFSSL_PUBLIC_ASN
 
     #ifdef HAVE_PTHREAD
         #define WOLFSSL_CRYPT_HW_MUTEX 1
         #define MAXQ10XX_MUTEX
     #endif
 
     #define WOLFSSL_MAXQ10XX_CRYPTO
     #define WOLFSSL_MAXQ10XX_TLS
 
 
     #if defined(WOLFSSL_MAXQ1065)
         #define MAXQ_DEVICE_ID 1065
     #elif defined(WOLFSSL_MAXQ108X)
         #define MAXQ_DEVICE_ID 1080
     #else
         #error "There is only support for MAXQ1065 or MAXQ1080"
     #endif
 
     #if defined(WOLFSSL_TICKET_NONCE_MALLOC)
         #error "WOLFSSL_TICKET_NONCE_MALLOC disables the HKDF expand callbacks."
     #endif
 
 #endif /* WOLFSSL_MAXQ1065 || WOLFSSL_MAXQ108X */
 
 #if defined(WOLFSSL_STM32F2) || defined(WOLFSSL_STM32F4) || \
     defined(WOLFSSL_STM32F7) || defined(WOLFSSL_STM32F1) || \
     defined(WOLFSSL_STM32L4) || defined(WOLFSSL_STM32L5) || \
     defined(WOLFSSL_STM32WB) || defined(WOLFSSL_STM32H7) || \
     defined(WOLFSSL_STM32G0) || defined(WOLFSSL_STM32U5) || \
     defined(WOLFSSL_STM32H5)
 
     #define SIZEOF_LONG_LONG 8
     #ifndef CHAR_BIT
       #define CHAR_BIT 8
     #endif
     #define NO_DEV_RANDOM
     #define NO_WOLFSSL_DIR
     #ifndef NO_STM32_RNG
         #undef  STM32_RNG
         #define STM32_RNG
         #ifdef WOLFSSL_STM32F427_RNG
             #include "stm32f427xx.h"
         #endif
     #endif
     #ifndef NO_STM32_CRYPTO
         #undef  STM32_CRYPTO
         #define STM32_CRYPTO
 
         #if defined(WOLFSSL_STM32L4) || defined(WOLFSSL_STM32L5) || \
             defined(WOLFSSL_STM32WB) || defined(WOLFSSL_STM32U5)
             #define NO_AES_192 /* hardware does not support 192-bit */
         #endif
     #endif
     #ifndef NO_STM32_HASH
         #undef  STM32_HASH
         #define STM32_HASH
     #endif
     #if !defined(__GNUC__) && !defined(__ICCARM__)
         #define KEIL_INTRINSICS
     #endif
     #define NO_OLD_RNGNAME
     #ifdef WOLFSSL_STM32_CUBEMX
         #if defined(WOLFSSL_STM32F1)
             #include "stm32f1xx_hal.h"
         #elif defined(WOLFSSL_STM32F2)
             #include "stm32f2xx_hal.h"
         #elif defined(WOLFSSL_STM32L5)
             #include "stm32l5xx_hal.h"
         #elif defined(WOLFSSL_STM32L4)
             #include "stm32l4xx_hal.h"
         #elif defined(WOLFSSL_STM32F4)
             #include "stm32f4xx_hal.h"
         #elif defined(WOLFSSL_STM32F7)
             #include "stm32f7xx_hal.h"
         #elif defined(WOLFSSL_STM32F1)
             #include "stm32f1xx_hal.h"
         #elif defined(WOLFSSL_STM32H7)
             #include "stm32h7xx_hal.h"
         #elif defined(WOLFSSL_STM32WB)
             #include "stm32wbxx_hal.h"
         #elif defined(WOLFSSL_STM32G0)
             #include "stm32g0xx_hal.h"
         #elif defined(WOLFSSL_STM32U5)
             #include "stm32u5xx_hal.h"
         #elif defined(WOLFSSL_STM32H5)
             #include "stm32h5xx_hal.h"
         #endif
         #if defined(WOLFSSL_CUBEMX_USE_LL) && defined(WOLFSSL_STM32L4)
             #include "stm32l4xx_ll_rng.h"
         #endif
 
         #ifndef STM32_HAL_TIMEOUT
             #define STM32_HAL_TIMEOUT   0xFF
         #endif
     #else
         #if defined(WOLFSSL_STM32F2)
             #include "stm32f2xx.h"
             #ifdef STM32_CRYPTO
                 #include "stm32f2xx_cryp.h"
             #endif
             #ifdef STM32_HASH
                 #include "stm32f2xx_hash.h"
             #endif
         #elif defined(WOLFSSL_STM32F4)
             #include "stm32f4xx.h"
             #ifdef STM32_CRYPTO
                 #include "stm32f4xx_cryp.h"
             #endif
             #ifdef STM32_HASH
                 #include "stm32f4xx_hash.h"
             #endif
         #elif defined(WOLFSSL_STM32L5)
             #include "stm32l5xx.h"
             #ifdef STM32_CRYPTO
                 #include "stm32l5xx_cryp.h"
             #endif
             #ifdef STM32_HASH
                 #include "stm32l5xx_hash.h"
             #endif
         #elif defined(WOLFSSL_STM32L4)
             #include "stm32l4xx.h"
             #ifdef STM32_CRYPTO
                 #include "stm32l4xx_cryp.h"
             #endif
             #ifdef STM32_HASH
                 #include "stm32l4xx_hash.h"
             #endif
         #elif defined(WOLFSSL_STM32F7)
             #include "stm32f7xx.h"
         #elif defined(WOLFSSL_STM32H7)
             #include "stm32h7xx.h"
         #elif defined(WOLFSSL_STM32F1)
             #include "stm32f1xx.h"
         #endif
     #endif /* WOLFSSL_STM32_CUBEMX */
 #endif /* WOLFSSL_STM32F2 || WOLFSSL_STM32F4 || WOLFSSL_STM32L4 ||
           WOLFSSL_STM32L5 || WOLFSSL_STM32F7 || WOLFSSL_STMWB ||
           WOLFSSL_STM32H7 || WOLFSSL_STM32G0 || WOLFSSL_STM32U5 ||
           WOLFSSL_STM32H5 */
 #ifdef WOLFSSL_DEOS
     #include <deos.h>
     #include <timeout.h>
     #include <socketapi.h>
     #include <lwip-socket.h>
     #include <mem.h>
     #include <string.h>
     #include <stdlib.h> /* for rand_r: pseudo-random number generator */
     #include <stdio.h>  /* for snprintf */
 
     /* use external memory XMALLOC, XFREE and XREALLOC functions */
     #define XMALLOC_USER
 
     /* disable fall-back case, malloc, realloc and free are unavailable */
     #define WOLFSSL_NO_MALLOC
 
     /* file system has not been ported since it is a separate product. */
 
     #define NO_FILESYSTEM
 
     #ifdef NO_FILESYSTEM
         #define NO_WOLFSSL_DIR
         #define NO_WRITEV
     #endif
 
     #define TFM_TIMING_RESISTANT
     #define ECC_TIMING_RESISTANT
     #define WC_RSA_BLINDING
 
     #define HAVE_ECC
     #define TFM_ECC192
     #define TFM_ECC224
     #define TFM_ECC256
     #define TFM_ECC384
     #define TFM_ECC521
 
     #define HAVE_TLS_EXTENSIONS
     #define HAVE_SUPPORTED_CURVES
     #define HAVE_EXTENDED_MASTER
 
     #if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
         #define BIG_ENDIAN_ORDER
     #else
         #undef  BIG_ENDIAN_ORDER
         #define LITTLE_ENDIAN_ORDER
     #endif
 #endif /* WOLFSSL_DEOS*/
 
 #ifdef MICRIUM
     #include <stdlib.h>
     #include <os.h>
     #if defined(RTOS_MODULE_NET_AVAIL) || (APP_CFG_TCPIP_EN == DEF_ENABLED)
         #include <net_cfg.h>
         #include <net_sock.h>
         #if (OS_VERSION < 50000)
             #include <net_err.h>
         #endif
     #endif
     #include <lib_mem.h>
     #include <lib_math.h>
     #include <lib_str.h>
     #include  <stdio.h>
     #include <string.h>
 
     #define TFM_TIMING_RESISTANT
     #define ECC_TIMING_RESISTANT
     #define WC_RSA_BLINDING
     #define HAVE_HASHDRBG
 
     #define HAVE_ECC
     #if !defined(WOLFSSL_STATIC_MEMORY) && !defined(WOLFSSL_NO_MALLOC)
         #define ALT_ECC_SIZE
     #endif
     #define TFM_ECC192
     #define TFM_ECC224
     #define TFM_ECC256
     #define TFM_ECC384
     #define TFM_ECC521
 
     #define NO_RC4
     #define HAVE_TLS_EXTENSIONS
     #define HAVE_SUPPORTED_CURVES
     #define HAVE_EXTENDED_MASTER
 
     #define NO_WOLFSSL_DIR
     #define NO_WRITEV
 
     #if !defined(WOLFSSL_SILABS_SE_ACCEL) && !defined(STM32_RNG) && \
         !defined(CUSTOM_RAND_GENERATE)
         #define CUSTOM_RAND_TYPE     RAND_NBR
         #define CUSTOM_RAND_GENERATE Math_Rand
     #endif
     #define STRING_USER
     #define XSTRCASECMP(s1,s2) strcasecmp((s1),(s2))
     #define XSTRCMP(s1,s2) strcmp((s1),(s2))
     #define XSTRLEN(pstr) ((CPU_SIZE_T)Str_Len((CPU_CHAR *)(pstr)))
     #define XSTRNCPY(pstr_dest, pstr_src, len_max) \
                     ((CPU_CHAR *)Str_Copy_N((CPU_CHAR *)(pstr_dest), \
                      (CPU_CHAR *)(pstr_src), (CPU_SIZE_T)(len_max)))
     #define XSTRNCMP(pstr_1, pstr_2, len_max) \
                     ((CPU_INT16S)Str_Cmp_N((CPU_CHAR *)(pstr_1), \
                      (CPU_CHAR *)(pstr_2), (CPU_SIZE_T)(len_max)))
     #define XSTRNCASECMP(pstr_1, pstr_2, len_max) \
                     ((CPU_INT16S)Str_CmpIgnoreCase_N((CPU_CHAR *)(pstr_1), \
                      (CPU_CHAR *)(pstr_2), (CPU_SIZE_T)(len_max)))
     #define XSTRSTR(pstr, pstr_srch) \
                     ((CPU_CHAR *)Str_Str((CPU_CHAR *)(pstr), \
                      (CPU_CHAR *)(pstr_srch)))
     #define XSTRNSTR(pstr, pstr_srch, len_max) \
                     ((CPU_CHAR *)Str_Str_N((CPU_CHAR *)(pstr), \
                      (CPU_CHAR *)(pstr_srch),(CPU_SIZE_T)(len_max)))
     #define XSTRNCAT(pstr_dest, pstr_cat, len_max) \
                     ((CPU_CHAR *)Str_Cat_N((CPU_CHAR *)(pstr_dest), \
                      (const CPU_CHAR *)(pstr_cat),(CPU_SIZE_T)(len_max)))
     #ifndef XATOI /* if custom XATOI is not already defined */
         #define XATOI(s) atoi((s))
     #endif
     #if defined(USE_WOLF_STRTOK)
         #define XSTRTOK(s1, d, ptr) wc_strtok((s1), (d), (ptr))
     #else
         #define XSTRTOK(s1, d, ptr) strtok_r((s1), (d), (ptr))
     #endif
     #define XMEMSET(pmem, data_val, size) \
                     ((void)Mem_Set((void *)(pmem), \
                     (CPU_INT08U) (data_val), \
                     (CPU_SIZE_T)(size)))
     #define XMEMCPY(pdest, psrc, size) ((void)Mem_Copy((void *)(pdest), \
                      (void *)(psrc), (CPU_SIZE_T)(size)))
 
     #if (OS_VERSION < 50000)
         #define XMEMCMP(pmem_1, pmem_2, size)                   \
                    (((CPU_BOOLEAN)Mem_Cmp((void *)(pmem_1),     \
                                           (void *)(pmem_2),     \
                      (CPU_SIZE_T)(size))) ? DEF_NO : DEF_YES)
     #else
       /* Work around for Micrium OS version 5.8 change in behavior
        * that returns DEF_NO for 0 size compare
        */
         #define XMEMCMP(pmem_1, pmem_2, size)                           \
             (( (size < 1 ) ||                                           \
                ((CPU_BOOLEAN)Mem_Cmp((void *)(pmem_1),                  \
                                      (void *)(pmem_2),                  \
                                      (CPU_SIZE_T)(size)) == DEF_YES))   \
              ? 0 : 1)
         #define XSNPRINTF snprintf
     #endif
 
     #define XMEMMOVE(pdest, psrc, size) ((void)Mem_Move((void *)(pdest), \
                      (void *)(psrc), (CPU_SIZE_T)(size)))
 
     #if (OS_CFG_MUTEX_EN == DEF_DISABLED)
         #define SINGLE_THREADED
     #endif
 
     #if (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_BIG)
         #define BIG_ENDIAN_ORDER
     #else
         #undef  BIG_ENDIAN_ORDER
         #define LITTLE_ENDIAN_ORDER
     #endif
 #endif /* MICRIUM */
 
 #if defined(sun) || defined(__sun)
 # if defined(__SVR4) || defined(__svr4__)
     /* Solaris */
     #ifndef WOLFSSL_SOLARIS
         #define WOLFSSL_SOLARIS
     #endif
 # else
     /* SunOS */
 # endif
 #endif
 
 #ifdef WOLFSSL_SOLARIS
     /* Avoid naming clash with fp_zero from math.h > ieefp.h */
     #define WOLFSSL_DH_CONST
 #endif
 
 #ifdef WOLFSSL_MCF5441X
     #define BIG_ENDIAN_ORDER
     #ifndef SIZEOF_LONG
         #define SIZEOF_LONG 4
     #endif
     #ifndef SIZEOF_LONG_LONG
         #define SIZEOF_LONG_LONG 8
     #endif
 #endif
 
 #ifdef WOLFSSL_QL
     #ifndef WOLFSSL_SEP
         #define WOLFSSL_SEP
     #endif
     #ifndef OPENSSL_EXTRA
         #define OPENSSL_EXTRA
     #endif
     #ifndef SESSION_CERTS
         #define SESSION_CERTS
     #endif
     #ifndef HAVE_AESCCM
         #define HAVE_AESCCM
     #endif
     #ifndef ATOMIC_USER
         #define ATOMIC_USER
     #endif
     #ifndef WOLFSSL_DER_LOAD
         #define WOLFSSL_DER_LOAD
     #endif
     #ifndef KEEP_PEER_CERT
         #define KEEP_PEER_CERT
     #endif
     #ifndef HAVE_ECC
         #define HAVE_ECC
     #endif
     #ifndef SESSION_INDEX
         #define SESSION_INDEX
     #endif
 #endif /* WOLFSSL_QL */
 
 
 #if defined(WOLFSSL_XILINX)
     #if !defined(WOLFSSL_XILINX_CRYPT_VERSAL)
         #define NO_DEV_RANDOM
     #endif
     #define NO_WOLFSSL_DIR
     #define HAVE_AESGCM
 #endif
 
 #if defined(WOLFSSL_XILINX_CRYPT) || defined(WOLFSSL_AFALG_XILINX)
     #if defined(WOLFSSL_ARMASM)
         #error can not use both ARMv8 instructions and XILINX hardened crypto
     #endif
     #if defined(WOLFSSL_SHA3)
         /* only SHA3-384 is supported */
         #undef WOLFSSL_NOSHA3_224
         #undef WOLFSSL_NOSHA3_256
         #undef WOLFSSL_NOSHA3_512
         #define WOLFSSL_NOSHA3_224
         #define WOLFSSL_NOSHA3_256
         #define WOLFSSL_NOSHA3_512
     #endif
     #ifdef WOLFSSL_AFALG_XILINX_AES
         #undef  WOLFSSL_AES_DIRECT
         #define WOLFSSL_AES_DIRECT
     #endif
 #endif /*(WOLFSSL_XILINX_CRYPT)*/
 
 #ifdef WOLFSSL_KCAPI_AES
     #define WOLFSSL_AES_GCM_FIXED_IV_AAD
 #endif
 #ifdef WOLFSSL_KCAPI_ECC
     #undef  ECC_USER_CURVES
     #define ECC_USER_CURVES
     #undef  NO_ECC256
     #undef  HAVE_ECC384
     #define HAVE_ECC384
     #undef  HAVE_ECC521
     #define HAVE_ECC521
 #endif
 
 #if defined(WOLFSSL_APACHE_MYNEWT)
     #include "os/os_malloc.h"
     #if !defined(WOLFSSL_LWIP)
         #include <mn_socket/mn_socket.h>
     #endif
 
     #if !defined(SIZEOF_LONG)
         #define SIZEOF_LONG 4
     #endif
     #if !defined(SIZEOF_LONG_LONG)
         #define SIZEOF_LONG_LONG 8
     #endif
     #if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
         #define BIG_ENDIAN_ORDER
     #else
         #undef  BIG_ENDIAN_ORDER
         #define LITTLE_ENDIAN_ORDER
     #endif
     #define NO_WRITEV
     #define WOLFSSL_USER_IO
     #define SINGLE_THREADED
     #define NO_DEV_RANDOM
     #define NO_DH
     #define NO_WOLFSSL_DIR
     #define NO_ERROR_STRINGS
     #define HAVE_ECC
     #define NO_SESSION_CACHE
     #define NO_ERROR_STRINGS
     #define XMALLOC_USER
     #define XMALLOC(sz, heap, type)     os_malloc(sz)
     #define XREALLOC(p, sz, heap, type) os_realloc(p, sz)
     #define XFREE(p, heap, type)        os_free(p)
 
 #endif /*(WOLFSSL_APACHE_MYNEWT)*/
 
 #ifdef WOLFSSL_ZEPHYR
     #include <zephyr/kernel.h>
     #include <zephyr/sys/printk.h>
     #include <zephyr/sys/util.h>
     #include <stdlib.h>
 
     #define WOLFSSL_DH_CONST
     #define WOLFSSL_HAVE_MAX
     #define NO_WRITEV
 
     #define USE_FLAT_BENCHMARK_H
     #define USE_FLAT_TEST_H
     #define EXIT_FAILURE 1
     #define MAIN_NO_ARGS
 
     void *z_realloc(void *ptr, size_t size);
     #define realloc   z_realloc
 
     #ifndef CONFIG_NET_SOCKETS_POSIX_NAMES
     #define CONFIG_NET_SOCKETS_POSIX_NAMES
     #endif
 #endif
 
 #ifdef WOLFSSL_IMX6
     #ifndef SIZEOF_LONG_LONG
         #define SIZEOF_LONG_LONG 8
     #endif
 #endif
 
 /* Setting supported CAAM algorithms */
 #ifdef WOLFSSL_IMX6Q_CAAM
     #undef  WOLFSSL_CAAM
     #define WOLFSSL_CAAM
 
     /* hardware does not support AES-GCM and ECC
      * has the low power AES module only (no high power with GCM) */
     #define WOLFSSL_LP_ONLY_CAAM_AES
     #define WOLFSSL_NO_CAAM_ECC
 #endif
 
 #ifdef WOLFSSL_SECO_CAAM
     #define WOLFSSL_CAAM
 
     #define WOLFSSL_HASH_KEEP
     #define WOLFSSL_NO_CAAM_BLOB
 #endif
 
 #ifdef WOLFSSL_IMXRT1170_CAAM
     #define WOLFSSL_CAAM
 #endif
 
 /* OS specific support so far */
 #ifdef WOLFSSL_QNX_CAAM
     /* shim layer for QNX hashing not yet implemented */
     #define WOLFSSL_NO_CAAM_HASH
 #endif
 
 #ifdef WOLFSSL_CAAM
     /* switch for all AES type algos */
     #undef  WOLFSSL_CAAM_CIPHER
     #define WOLFSSL_CAAM_CIPHER
     #ifdef WOLFSSL_CAAM_CIPHER
         #ifndef WOLFSSL_LP_ONLY_CAAM_AES
             /* GCM and XTS mode are only available in the high power module */
             #define WOLFSSL_CAAM_AESGCM
             #define WOLFSSL_CAAM_AESXTS
         #endif
         #define WOLFSSL_CAAM_AESCCM
         #define WOLFSSL_CAAM_AESCTR
         #define WOLFSSL_CAAM_AESCBC
         #define WOLFSSL_CAAM_CMAC
     #endif /* WOLFSSL_CAAM_CIPHER */
     #if defined(HAVE_AESGCM) || defined(WOLFSSL_AES_XTS) || \
             defined(WOLFSSL_CMAC)
         /* large performance gain with HAVE_AES_ECB defined */
         #undef HAVE_AES_ECB
         #define HAVE_AES_ECB
 
         /* @TODO used for now until plugging in caam aes use with qnx */
         #undef WOLFSSL_AES_DIRECT
         #define WOLFSSL_AES_DIRECT
     #endif
 
     /* switch for all hashing algos */
     #ifndef WOLFSSL_NO_CAAM_HASH
         #define WOLFSSL_CAAM_HASH
     #endif
     #if defined(WOLFSSL_DEVCRYPTO_HMAC)
         /* HMAC is through the devcrypto calls */
         #define WOLFSSL_CAAM_HMAC
     #endif
 
     /* public key operations */
     #ifndef WOLFSSL_NO_CAAM_ECC
         #undef  WOLFSSL_CAAM_ECC
         #define WOLFSSL_CAAM_ECC
     #endif
 
     /* so far curve25519 support was only done with the SECO */
     #ifdef WOLFSSL_SECO_CAAM
         #define WOLFSSL_CAAM_CURVE25519
     #endif
 
     /* Blob support */
     #ifndef WOLFSSL_NO_CAAM_BLOB
         #define WOLFSSL_CAAM_BLOB
     #endif
 #endif
 
 #if defined(NO_WC_SSIZE_TYPE) || defined(ssize_t)
     /* ssize_t comes from system headers or user_settings.h */
 #elif defined(WC_SSIZE_TYPE)
     typedef WC_SSIZE_TYPE ssize_t;
 #elif defined(_MSC_VER)
     #include <BaseTsd.h>
     typedef SSIZE_T ssize_t;
 #endif
 
 /* If DCP is used without SINGLE_THREADED, enforce WOLFSSL_CRYPT_HW_MUTEX */
 #if defined(WOLFSSL_IMXRT_DCP) && !defined(SINGLE_THREADED)
     #undef WOLFSSL_CRYPT_HW_MUTEX
     #define WOLFSSL_CRYPT_HW_MUTEX 1
 #endif
 
 #if !defined(XMALLOC_USER) && !defined(MICRIUM_MALLOC) && \
     !defined(WOLFSSL_LEANPSK) && !defined(NO_WOLFSSL_MEMORY) && \
     !defined(XMALLOC_OVERRIDE)
     #define USE_WOLFSSL_MEMORY
 #endif
 
 #ifdef WOLFSSL_EMBOS
     #include "RTOS.h"
     #if !defined(XMALLOC_USER) && !defined(NO_WOLFSSL_MEMORY) && \
         !defined(WOLFSSL_STATIC_MEMORY)
         #define XMALLOC(s, h, type)  OS_HEAP_malloc((s))
         #define XFREE(p, h, type)    OS_HEAP_free((p))
         #define XREALLOC(p, n, h, t) OS_HEAP_realloc(((p), (n))
     #endif
 #endif
 
 #if defined(OPENSSL_EXTRA) && !defined(NO_CERTS)
     #undef  KEEP_PEER_CERT
     #define KEEP_PEER_CERT
 #endif
 
 
 /* stream ciphers except arc4 need 32bit alignment, intel ok without */
 #ifndef XSTREAM_ALIGN
     #if defined(__x86_64__) || defined(__ia64__) || defined(__i386__)
         #define NO_XSTREAM_ALIGN
     #else
         #define XSTREAM_ALIGN
     #endif
 #endif
 
 /* write dup cannot be used with secure renegotiation because write dup
  * make write side write only and read side read only */
 #if defined(HAVE_WRITE_DUP) && defined(HAVE_SECURE_RENEGOTIATION)
     #error "WRITE DUP and SECURE RENEGOTIATION cannot both be on"
 #endif
 
 #ifdef WOLFSSL_SGX
     #ifdef _MSC_VER
         #define NO_RC4
         #ifndef HAVE_FIPS
             #define WOLFCRYPT_ONLY
             #define NO_DES3
             #define NO_SHA
             #define NO_MD5
         #else
             #define TFM_TIMING_RESISTANT
             #define NO_WOLFSSL_DIR
             #define NO_WRITEV
             #define NO_MAIN_DRIVER
             #define WOLFSSL_LOG_PRINTF
             #define WOLFSSL_DH_CONST
         #endif
     #else
         #define HAVE_ECC
         #define NO_WRITEV
         #define NO_MAIN_DRIVER
         #define USER_TICKS
         #define WOLFSSL_LOG_PRINTF
         #define WOLFSSL_DH_CONST
     #endif /* _MSC_VER */
     #if !defined(HAVE_FIPS) && !defined(NO_RSA)
         #define WC_RSA_BLINDING
     #endif
 
     #define NO_FILESYSTEM
     #define ECC_TIMING_RESISTANT
     #define TFM_TIMING_RESISTANT
     #define SINGLE_THREADED
     #define NO_ASN_TIME /* can not use headers such as windows.h */
     #define HAVE_AESGCM
     #define USE_CERT_BUFFERS_2048
 #endif /* WOLFSSL_SGX */
 
 /* FreeScale MMCAU hardware crypto has 4 byte alignment.
    However, KSDK fsl_mmcau.h gives API with no alignment
    requirements (4 byte alignment is managed internally by fsl_mmcau.c) */
 #ifdef FREESCALE_MMCAU
     #ifdef FREESCALE_MMCAU_CLASSIC
         #define WOLFSSL_MMCAU_ALIGNMENT 4
     #else
         #define WOLFSSL_MMCAU_ALIGNMENT 0
     #endif
 #endif
 
 /* if using hardware crypto and have alignment requirements, specify the
    requirement here.  The record header of SSL/TLS will prevent easy alignment.
    This hint tries to help as much as possible.  */
 #ifndef WOLFSSL_GENERAL_ALIGNMENT
     #ifdef WOLFSSL_AESNI
         #define WOLFSSL_GENERAL_ALIGNMENT 16
     #elif defined(XSTREAM_ALIGN)
         #define WOLFSSL_GENERAL_ALIGNMENT  4
     #elif defined(FREESCALE_MMCAU) || defined(FREESCALE_MMCAU_CLASSIC)
         #define WOLFSSL_GENERAL_ALIGNMENT  WOLFSSL_MMCAU_ALIGNMENT
     #else
         #define WOLFSSL_GENERAL_ALIGNMENT  0
     #endif
 #endif
 
 #if defined(WOLFSSL_GENERAL_ALIGNMENT) && (WOLFSSL_GENERAL_ALIGNMENT > 0)
     #if defined(_MSC_VER)
         #define XGEN_ALIGN __declspec(align(WOLFSSL_GENERAL_ALIGNMENT))
     #elif defined(__GNUC__)
         #define XGEN_ALIGN __attribute__((aligned(WOLFSSL_GENERAL_ALIGNMENT)))
     #else
         #define XGEN_ALIGN
     #endif
 #else
     #define XGEN_ALIGN
 #endif
 
 #if defined(__mips) || defined(__mips64) || \
     defined(WOLFSSL_SP_MIPS64) || defined(WOLFSSL_SP_MIPS)
     #undef WOLFSSL_SP_INT_DIGIT_ALIGN
     #define WOLFSSL_SP_INT_DIGIT_ALIGN
 #endif
 #ifdef __APPLE__
     #define WOLFSSL_SP_NO_DYN_STACK
 #endif
 
 #ifdef __INTEL_COMPILER
     #pragma warning(disable:2259) /* explicit casts to smaller sizes, disable */
 #endif
 
 
 
 /* ---------------------------------------------------------------------------
  * Math Library Selection (in order of preference)
  * ---------------------------------------------------------------------------
  */
 #if !defined(HAVE_FIPS_VERSION) || \
     (defined(HAVE_FIPS_VERSION) && (HAVE_FIPS_VERSION >= 5))
     #if defined(WOLFSSL_SP_MATH_ALL)
         /*  1) SP Math: wolfSSL proprietary math implementation (sp_int.c).
          *      Constant time: Always
          *      Enable:        WOLFSSL_SP_MATH_ALL
          */
     #elif defined(WOLFSSL_SP_MATH)
         /*  2) SP Math with restricted key sizes: wolfSSL proprietary math
          *         implementation (sp_*.c).
          *      Constant time: Always
          *      Enable:        WOLFSSL_SP_MATH
          */
     #elif defined(USE_FAST_MATH)
         /*  3) Tom's Fast Math: Stack based (tfm.c)
          *      Constant time: Only with TFM_TIMING_RESISTANT
          *      Enable:        USE_FAST_MATH
          */
     #elif defined(USE_INTEGER_HEAP_MATH)
         /*  4) Integer Heap Math:  Heap based (integer.c)
          *      Constant time: Not supported
          *      Enable:        USE_INTEGER_HEAP_MATH
          */
     #elif defined(NO_BIG_INT)
         /*  5) No big integer math libraries
          */
     #else
         /* default is SP Math. */
         #define WOLFSSL_SP_MATH_ALL
     #endif
 #else
     /* FIPS 140-2 or older */
     /* Default to fast math (tfm.c), but allow heap math (integer.c) */
     #if !defined(USE_INTEGER_HEAP_MATH)
         #undef  USE_FAST_MATH
         #define USE_FAST_MATH
         #ifndef FP_MAX_BITS
             #define FP_MAX_BITS 8192
         #endif
     #endif
 #endif
 
 /* Verify that only one of the above multi-precision math libraries is enabled */
 #if (defined(WOLFSSL_SP_MATH_ALL) && \
         (defined(USE_FAST_MATH) || defined(USE_INTEGER_HEAP_MATH))) || \
     (defined(USE_FAST_MATH) && defined(USE_INTEGER_HEAP_MATH))
     #error Cannot enable more than one multiple precision math library!
 #endif
 /*----------------------------------------------------------------------------*/
 
 
 
 /* user can specify what curves they want with ECC_USER_CURVES otherwise
  * all curves are on by default for now */
 #ifndef ECC_USER_CURVES
     #ifdef WOLFSSL_SP_MATH
         /* for single precision math only make sure the enabled key sizes are
          * included in the ECC curve table */
         #if defined(WOLFSSL_SP_384) && !defined(HAVE_ECC384)
             #define HAVE_ECC384
         #endif
         #if defined(WOLFSSL_SP_521) && !defined(HAVE_ECC521)
             #define HAVE_ECC521
         #endif
     #elif !defined(HAVE_ALL_CURVES)
         #define HAVE_ALL_CURVES
     #endif
 #endif
 
 /* The minimum allowed ECC key size */
 /* Note: 224-bits is equivalent to 2048-bit RSA */
 #ifndef ECC_MIN_KEY_SZ
     #ifdef WOLFSSL_MIN_ECC_BITS
         #define ECC_MIN_KEY_SZ WOLFSSL_MIN_ECC_BITS
     #else
         #if defined(WOLFSSL_HARDEN_TLS) && \
             !defined(WOLFSSL_HARDEN_TLS_NO_PKEY_CHECK)
             /* Using guidance from section 5.6.1
              * https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf */
             #if WOLFSSL_HARDEN_TLS >= 128
                 #define ECC_MIN_KEY_SZ 256
             #elif WOLFSSL_HARDEN_TLS >= 112
                 #define ECC_MIN_KEY_SZ 224
             #endif
         #elif FIPS_VERSION_GE(2,0)
             /* FIPSv2 and ready (for now) includes 192-bit support */
             #define ECC_MIN_KEY_SZ 192
         #else
             #define ECC_MIN_KEY_SZ 224
         #endif
     #endif
 #endif
 
 #if defined(WOLFSSL_HARDEN_TLS) && ECC_MIN_KEY_SZ < 224 && \
     !defined(WOLFSSL_HARDEN_TLS_NO_PKEY_CHECK)
     /* Implementations MUST NOT negotiate cipher suites offering less than
      * 112 bits of security.
      * https://www.rfc-editor.org/rfc/rfc9325#section-4.1
      * Using guidance from section 5.6.1
      * https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf */
     #error "For 112 bits of security ECC needs at least 224 bit keys"
 #endif
 
 /* ECC Configs */
 #ifdef HAVE_ECC
     /* By default enable Sign, Verify, DHE, Key Import and Key Export unless
      * explicitly disabled */
     #if !defined(NO_ECC_SIGN) && \
             (!defined(ECC_TIMING_RESISTANT) || \
             (defined(ECC_TIMING_RESISTANT) && !defined(WC_NO_RNG)))
         #undef HAVE_ECC_SIGN
         #define HAVE_ECC_SIGN
     #endif
     #ifndef NO_ECC_VERIFY
         #undef HAVE_ECC_VERIFY
         #define HAVE_ECC_VERIFY
     #endif
     #ifndef NO_ECC_CHECK_KEY
         #undef HAVE_ECC_CHECK_KEY
         #define HAVE_ECC_CHECK_KEY
     #endif
     #if !defined(NO_ECC_DHE) && !defined(WC_NO_RNG)
         #undef HAVE_ECC_DHE
         #define HAVE_ECC_DHE
     #endif
     #ifndef NO_ECC_KEY_IMPORT
         #undef HAVE_ECC_KEY_IMPORT
         #define HAVE_ECC_KEY_IMPORT
     #endif
     /* The ECC key export requires mp_int or SP */
     #if (!defined(NO_ECC_KEY_EXPORT) && defined(WOLFSSL_SP_MATH)) || \
         (!defined(NO_ECC_KEY_EXPORT) && !defined(NO_BIG_INT))
         #undef HAVE_ECC_KEY_EXPORT
         #define HAVE_ECC_KEY_EXPORT
     #endif
 #endif /* HAVE_ECC */
 
 #if defined(OPENSSL_EXTRA) && defined(HAVE_ECC) && \
     !defined(WOLFSSL_ATECC508A) && !defined(WOLFSSL_ATECC608A) && \
     !defined(WOLFSSL_CRYPTOCELL) && !defined(WOLFSSL_SE050) && \
     !defined(WOLF_CRYPTO_CB_ONLY_ECC) && !defined(WOLFSSL_STM32_PKA)
     #undef  USE_ECC_B_PARAM
     #define USE_ECC_B_PARAM
 #endif
 
 /* Curve25519 Configs */
 #ifdef HAVE_CURVE25519
     /* By default enable shared secret, key export and import */
     #ifndef NO_CURVE25519_SHARED_SECRET
         #undef HAVE_CURVE25519_SHARED_SECRET
         #define HAVE_CURVE25519_SHARED_SECRET
     #endif
     #ifndef NO_CURVE25519_KEY_EXPORT
         #undef HAVE_CURVE25519_KEY_EXPORT
         #define HAVE_CURVE25519_KEY_EXPORT
     #endif
     #ifndef NO_CURVE25519_KEY_IMPORT
         #undef HAVE_CURVE25519_KEY_IMPORT
         #define HAVE_CURVE25519_KEY_IMPORT
     #endif
 #endif /* HAVE_CURVE25519 */
 
 /* Ed25519 Configs */
 #ifdef HAVE_ED25519
     /* By default enable sign, verify, key export and import */
     #ifndef NO_ED25519_SIGN
         #undef HAVE_ED25519_SIGN
         #define HAVE_ED25519_SIGN
     #endif
     #ifndef NO_ED25519_VERIFY
         #undef HAVE_ED25519_VERIFY
         #define HAVE_ED25519_VERIFY
         #ifdef WOLFSSL_ED25519_STREAMING_VERIFY
             #undef WOLFSSL_ED25519_PERSISTENT_SHA
             #define WOLFSSL_ED25519_PERSISTENT_SHA
         #endif
     #endif
     #ifndef NO_ED25519_KEY_EXPORT
         #undef HAVE_ED25519_KEY_EXPORT
         #define HAVE_ED25519_KEY_EXPORT
     #endif
     #ifndef NO_ED25519_KEY_IMPORT
         #undef HAVE_ED25519_KEY_IMPORT
         #define HAVE_ED25519_KEY_IMPORT
     #endif
 #endif /* HAVE_ED25519 */
 
 /* Curve448 Configs */
 #ifdef HAVE_CURVE448
     /* By default enable shared secret, key export and import */
     #ifndef NO_CURVE448_SHARED_SECRET
         #undef HAVE_CURVE448_SHARED_SECRET
         #define HAVE_CURVE448_SHARED_SECRET
     #endif
     #ifndef NO_CURVE448_KEY_EXPORT
         #undef HAVE_CURVE448_KEY_EXPORT
         #define HAVE_CURVE448_KEY_EXPORT
     #endif
     #ifndef NO_CURVE448_KEY_IMPORT
         #undef HAVE_CURVE448_KEY_IMPORT
         #define HAVE_CURVE448_KEY_IMPORT
     #endif
 #endif /* HAVE_CURVE448 */
 
 /* Ed448 Configs */
 #ifdef HAVE_ED448
     /* By default enable sign, verify, key export and import */
     #ifndef NO_ED448_SIGN
         #undef HAVE_ED448_SIGN
         #define HAVE_ED448_SIGN
     #endif
     #ifndef NO_ED448_VERIFY
         #undef HAVE_ED448_VERIFY
         #define HAVE_ED448_VERIFY
         #ifdef WOLFSSL_ED448_STREAMING_VERIFY
             #undef WOLFSSL_ED448_PERSISTENT_SHA
             #define WOLFSSL_ED448_PERSISTENT_SHA
         #endif
     #endif
     #ifndef NO_ED448_KEY_EXPORT
         #undef HAVE_ED448_KEY_EXPORT
         #define HAVE_ED448_KEY_EXPORT
     #endif
     #ifndef NO_ED448_KEY_IMPORT
         #undef HAVE_ED448_KEY_IMPORT
         #define HAVE_ED448_KEY_IMPORT
     #endif
 #endif /* HAVE_ED448 */
 
 /* AES Config */
 #ifndef NO_AES
     /* By default enable all AES key sizes, decryption and CBC */
     #ifndef AES_MAX_KEY_SIZE
         #undef  AES_MAX_KEY_SIZE
         #define AES_MAX_KEY_SIZE    256
     #endif
 
     #ifndef NO_AES_128
         #undef  WOLFSSL_AES_128
         #define WOLFSSL_AES_128
     #endif
     #if !defined(NO_AES_192) && AES_MAX_KEY_SIZE >= 192
         #undef  WOLFSSL_AES_192
         #define WOLFSSL_AES_192
     #endif
     #if !defined(NO_AES_256) && AES_MAX_KEY_SIZE >= 256
         #undef  WOLFSSL_AES_256
         #define WOLFSSL_AES_256
     #endif
     #if !defined(WOLFSSL_AES_128) && !defined(WOLFSSL_AES_256) && \
         defined(HAVE_ECC_ENCRYPT)
         #warning HAVE_ECC_ENCRYPT uses AES 128/256 bit keys
      #endif
 
     #ifndef NO_AES_DECRYPT
         #undef  HAVE_AES_DECRYPT
         #define HAVE_AES_DECRYPT
     #endif
     #ifndef NO_AES_CBC
         #undef  HAVE_AES_CBC
         #define HAVE_AES_CBC
     #endif
     #ifdef WOLFSSL_AES_XTS
         /* AES-XTS makes calls to AES direct functions */
         #ifndef WOLFSSL_AES_DIRECT
         #define WOLFSSL_AES_DIRECT
         #endif
     #endif
     #ifdef WOLFSSL_AES_CFB
         /* AES-CFB makes calls to AES direct functions */
         #ifndef WOLFSSL_AES_DIRECT
         #define WOLFSSL_AES_DIRECT
         #endif
     #endif
 #endif
 
 #if (defined(WOLFSSL_TLS13) && defined(WOLFSSL_NO_TLS12)) || \
     (!defined(HAVE_AES_CBC) && defined(NO_DES3) && defined(NO_RC4) && \
      !defined(HAVE_CAMELLIA) & !defined(HAVE_NULL_CIPHER))
     #define WOLFSSL_AEAD_ONLY
 #endif
 
 #if !defined(HAVE_PUBLIC_FFDHE) && !defined(NO_DH) && \
     !defined(WOLFSSL_NO_PUBLIC_FFDHE) && \
     (defined(HAVE_SELFTEST) || FIPS_VERSION_LE(2,0))
     /* This should only be enabled for FIPS v2 or older. It enables use of the
      * older wc_Dh_ffdhe####_Get() API's */
     #define HAVE_PUBLIC_FFDHE
 #endif
 
 #if !defined(NO_DH) && !defined(HAVE_FFDHE)
     #if defined(HAVE_FFDHE_2048) || defined(HAVE_FFDHE_3072) || \
             defined(HAVE_FFDHE_4096) || defined(HAVE_FFDHE_6144) || \
             defined(HAVE_FFDHE_8192)
         #define HAVE_FFDHE
     #endif
 #endif
 #if defined(HAVE_FFDHE_8192)
     #define MIN_FFDHE_BITS 8192
 #elif defined(HAVE_FFDHE_6144)
     #define MIN_FFDHE_BITS 6144
 #elif defined(HAVE_FFDHE_4096)
     #define MIN_FFDHE_BITS 4096
 #elif defined(HAVE_FFDHE_3072)
     #define MIN_FFDHE_BITS 3072
 #elif defined(HAVE_FFDHE_2048)
     #define MIN_FFDHE_BITS 2048
 #else
     #define MIN_FFDHE_BITS 0
 #endif
 #define MIN_FFDHE_FP_MAX_BITS   (MIN_FFDHE_BITS * 2)
 #if defined(HAVE_FFDHE) && defined(FP_MAX_BITS)
     #if MIN_FFDHE_FP_MAX_BITS > FP_MAX_BITS
         #error "FFDHE parameters are too large for FP_MAX_BIT as set"
     #endif
 #endif
 #if defined(HAVE_FFDHE) && defined(SP_INT_BITS)
     #if MIN_FFDHE_BITS > SP_INT_BITS
         #error "FFDHE parameters are too large for SP_INT_BIT as set"
     #endif
 #endif
 
 /* if desktop type system and fastmath increase default max bits */
 #if defined(WOLFSSL_X86_64_BUILD) || defined(WOLFSSL_AARCH64_BUILD)
     #if defined(USE_FAST_MATH) && !defined(FP_MAX_BITS)
         #if MIN_FFDHE_FP_MAX_BITS <= 8192
             #define FP_MAX_BITS     8192
         #else
             #define FP_MAX_BITS     MIN_FFDHE_FP_MAX_BITS
         #endif
     #endif
     #if defined(WOLFSSL_SP_MATH_ALL) && !defined(SP_INT_BITS)
         #ifdef WOLFSSL_MYSQL_COMPATIBLE
             #define SP_INT_BITS     8192
         #elif MIN_FFDHE_BITS <= 4096
             #define SP_INT_BITS     4096
         #else
             #define SP_INT_BITS     MIN_FFDHE_BITS
         #endif
     #endif
 #endif
 
 /* If using the max strength build, ensure OLD TLS is disabled. */
 #ifdef WOLFSSL_MAX_STRENGTH
     #undef NO_OLD_TLS
     #define NO_OLD_TLS
 #endif
 
 
 /* Default AES minimum auth tag sz, allow user to override */
 #ifndef WOLFSSL_MIN_AUTH_TAG_SZ
     #define WOLFSSL_MIN_AUTH_TAG_SZ 12
 #endif
 
 
 /* sniffer requires:
  * static RSA cipher suites
  * session stats and peak stats
  */
 #ifdef WOLFSSL_SNIFFER
     #ifndef WOLFSSL_STATIC_RSA
         #define WOLFSSL_STATIC_RSA
     #endif
     #ifndef WOLFSSL_STATIC_DH
         #define WOLFSSL_STATIC_DH
     #endif
     /* Allow option to be disabled. */
     #ifndef WOLFSSL_NO_SESSION_STATS
         #ifndef WOLFSSL_SESSION_STATS
             #define WOLFSSL_SESSION_STATS
         #endif
         #ifndef WOLFSSL_PEAK_SESSIONS
             #define WOLFSSL_PEAK_SESSIONS
         #endif
     #endif
 #endif
 
 /* Decode Public Key extras on by default, user can turn off with
  * WOLFSSL_NO_DECODE_EXTRA */
 #ifndef WOLFSSL_NO_DECODE_EXTRA
     #ifndef RSA_DECODE_EXTRA
         #define RSA_DECODE_EXTRA
     #endif
     #ifndef ECC_DECODE_EXTRA
         #define ECC_DECODE_EXTRA
     #endif
 #endif
 
 /* C Sharp wrapper defines */
 #ifdef HAVE_CSHARP
     #ifndef WOLFSSL_DTLS
         #define WOLFSSL_DTLS
     #endif
     #undef NO_PSK
     #undef NO_SHA256
     #undef NO_DH
 #endif
 
 /* Asynchronous Crypto */
 #ifdef WOLFSSL_ASYNC_CRYPT
     #if !defined(HAVE_CAVIUM) && !defined(HAVE_INTEL_QA) && \
         !defined(WOLFSSL_ASYNC_CRYPT_SW)
         #error No async backend defined with WOLFSSL_ASYNC_CRYPT!
     #endif
 
     /* Make sure wolf events are enabled */
     #undef HAVE_WOLF_EVENT
     #define HAVE_WOLF_EVENT
 
     #ifdef WOLFSSL_ASYNC_CRYPT_SW
         #define WC_ASYNC_DEV_SIZE 168
     #else
         #define WC_ASYNC_DEV_SIZE 336
     #endif
 
     /* Enable ECC_CACHE_CURVE for ASYNC */
     #if !defined(ECC_CACHE_CURVE)
         #define ECC_CACHE_CURVE
     #endif
 #endif /* WOLFSSL_ASYNC_CRYPT */
 #ifndef WC_ASYNC_DEV_SIZE
     #define WC_ASYNC_DEV_SIZE 0
 #endif
 #ifdef HAVE_INTEL_QA /* Disable SHA512/224 and SHA512/256 support for QAT */
     #define WOLFSSL_NOSHA512_224
     #define WOLFSSL_NOSHA512_256
 #endif
 /* leantls checks */
 #ifdef WOLFSSL_LEANTLS
     #ifndef HAVE_ECC
         #error leantls build needs ECC
     #endif
 #endif /* WOLFSSL_LEANTLS*/
 
 /* restriction with static memory */
 #ifdef WOLFSSL_STATIC_MEMORY
     #if defined(HAVE_IO_POOL) || defined(XMALLOC_USER) || defined(NO_WOLFSSL_MEMORY)
          #error static memory cannot be used with HAVE_IO_POOL, XMALLOC_USER or NO_WOLFSSL_MEMORY
     #endif
     #if !defined(WOLFSSL_SP_MATH_ALL) && !defined(USE_FAST_MATH) && \
         !defined(WOLFSSL_SP_MATH) && !defined(NO_BIG_INT)
          #error The static memory option is only supported for fast math or SP Math
     #endif
     #ifdef WOLFSSL_SMALL_STACK
         #error static memory does not support small stack please undefine
     #endif
 #endif /* WOLFSSL_STATIC_MEMORY */
 
 #ifdef HAVE_AES_KEYWRAP
     #ifndef WOLFSSL_AES_DIRECT
         #error AES key wrap requires AES direct please define WOLFSSL_AES_DIRECT
     #endif
 #endif
 
 #ifdef HAVE_PKCS7
     #if defined(NO_AES) && defined(NO_DES3)
         #error PKCS7 needs either AES or 3DES enabled, please enable one
     #endif
     #ifndef HAVE_AES_KEYWRAP
         #error PKCS7 requires AES key wrap please define HAVE_AES_KEYWRAP
     #endif
     #if defined(HAVE_ECC) && !defined(HAVE_X963_KDF)
         #error PKCS7 requires X963 KDF please define HAVE_X963_KDF
     #endif
 #endif
 
 #ifndef NO_PKCS12
     #undef  HAVE_PKCS12
     #define HAVE_PKCS12
 #endif
 
 #if !defined(NO_PKCS8) || defined(HAVE_PKCS12)
     #undef  HAVE_PKCS8
     #define HAVE_PKCS8
 #endif
 
 #if !defined(NO_PBKDF1) || defined(WOLFSSL_ENCRYPTED_KEYS) || \
     defined(HAVE_PKCS8) || defined(HAVE_PKCS12)
     #undef  HAVE_PBKDF1
     #define HAVE_PBKDF1
 #endif
 
 #if !defined(NO_PBKDF2) || defined(HAVE_PKCS7) || defined(HAVE_SCRYPT)
     #undef  HAVE_PBKDF2
     #define HAVE_PBKDF2
 #endif
 
 
 #if !defined(WOLFCRYPT_ONLY) && !defined(NO_OLD_TLS) && \
         (defined(NO_SHA) || defined(NO_MD5))
     #error old TLS requires MD5 and SHA
 #endif
 
 /* for backwards compatibility */
 #if defined(TEST_IPV6) && !defined(WOLFSSL_IPV6)
     #define WOLFSSL_IPV6
 #endif
 
 
 #ifdef WOLFSSL_LINUXKM
     #ifdef HAVE_CONFIG_H
         #include <config.h>
         #undef HAVE_CONFIG_H
     #endif
     #ifndef NO_DEV_RANDOM
         #define NO_DEV_RANDOM
     #endif
     #ifndef NO_WRITEV
         #define NO_WRITEV
     #endif
     #ifndef NO_FILESYSTEM
         #define NO_FILESYSTEM
     #endif
     #ifndef NO_STDIO_FILESYSTEM
         #define NO_STDIO_FILESYSTEM
     #endif
     #ifndef WOLFSSL_NO_SOCK
         #define WOLFSSL_NO_SOCK
     #endif
     #ifndef WOLFSSL_DH_CONST
         #define WOLFSSL_DH_CONST
     #endif
     #ifndef WOLFSSL_USER_IO
         #define WOLFSSL_USER_IO
     #endif
     #ifndef USE_WOLF_STRTOK
         #define USE_WOLF_STRTOK
     #endif
     #ifndef WOLFSSL_OLD_PRIME_CHECK
         #define WOLFSSL_OLD_PRIME_CHECK
     #endif
     #ifndef WOLFSSL_TEST_SUBROUTINE
         #define WOLFSSL_TEST_SUBROUTINE static
     #endif
     #undef HAVE_STRINGS_H
     #undef HAVE_ERRNO_H
     #undef HAVE_THREAD_LS
     #undef WOLFSSL_HAVE_MIN
     #undef WOLFSSL_HAVE_MAX
     #define SIZEOF_LONG         8
     #define SIZEOF_LONG_LONG    8
     #define CHAR_BIT            8
     #ifndef WOLFSSL_SP_DIV_64
         #define WOLFSSL_SP_DIV_64
     #endif
     #ifndef WOLFSSL_SP_DIV_WORD_HALF
         #define WOLFSSL_SP_DIV_WORD_HALF
     #endif
 #endif
 
 
 /* Place any other flags or defines here */
 
 #if defined(WOLFSSL_MYSQL_COMPATIBLE) && defined(_WIN32) \
                                       && defined(HAVE_GMTIME_R)
     #undef HAVE_GMTIME_R /* don't trust macro with windows */
 #endif /* WOLFSSL_MYSQL_COMPATIBLE */
 
 #if (defined(OPENSSL_ALL) || defined(WOLFSSL_NGINX) || defined(WOLFSSL_HAPROXY) \
  || defined(HAVE_LIGHTY)) && !defined(NO_TLS)
     #define OPENSSL_NO_ENGINE
     #ifndef OPENSSL_EXTRA
         #define OPENSSL_EXTRA
     #endif
     /* Session Tickets will be enabled when --enable-opensslall is used.
      * Time is required for ticket expiration checking */
     #if !defined(HAVE_SESSION_TICKET) && !defined(NO_ASN_TIME)
         #define HAVE_SESSION_TICKET
     #endif
     /* OCSP will be enabled in configure.ac when --enable-opensslall is used,
      * but do not force all users to have it enabled. */
     #ifndef HAVE_OCSP
         /*#define HAVE_OCSP*/
     #endif
     #ifndef KEEP_OUR_CERT
         #define KEEP_OUR_CERT
     #endif
     #ifndef HAVE_SNI
         #define HAVE_SNI
     #endif
 #endif
 
+/* Make sure setting OPENSSL_ALL also sets OPENSSL_EXTRA. */
+#if defined(OPENSSL_ALL) && !defined(OPENSSL_EXTRA)
+    #define OPENSSL_EXTRA
+#endif
+
 #ifdef HAVE_SNI
     #define SSL_CTRL_SET_TLSEXT_HOSTNAME 55
 #endif
 
 /* Disable time checking if no timer */
 #if defined(NO_ASN_TIME)
     #define NO_ASN_TIME_CHECK
 #endif
 
 /* both CURVE and ED small math should be enabled */
 #ifdef CURVED25519_SMALL
     #define CURVE25519_SMALL
     #define ED25519_SMALL
 #endif
 
 /* both CURVE and ED small math should be enabled */
 #ifdef CURVED448_SMALL
     #define CURVE448_SMALL
     #define ED448_SMALL
 #endif
 
 
 #ifndef WOLFSSL_ALERT_COUNT_MAX
     #define WOLFSSL_ALERT_COUNT_MAX 5
 #endif
 
 /* warning for not using harden build options (default with ./configure) */
 /* do not warn if big integer support is disabled */
 #if !defined(WC_NO_HARDEN) && !defined(NO_BIG_INT)
     #if (defined(USE_FAST_MATH) && !defined(TFM_TIMING_RESISTANT)) || \
         (defined(HAVE_ECC) && !defined(ECC_TIMING_RESISTANT)) || \
         (!defined(NO_RSA) && !defined(WC_RSA_BLINDING) && !defined(HAVE_FIPS) && \
             !defined(WC_NO_RNG))
 
         #ifndef _MSC_VER
             #warning "For timing resistance / side-channel attack prevention consider using harden options"
         #else
             #pragma message("Warning: For timing resistance / side-channel attack prevention consider using harden options")
         #endif
     #endif
 #endif
 
 #ifdef OPENSSL_COEXIST
     /* make sure old names are disabled */
     #ifndef NO_OLD_SSL_NAMES
         #define NO_OLD_SSL_NAMES
     #endif
     #ifndef NO_OLD_WC_NAMES
         #define NO_OLD_WC_NAMES
     #endif
 #endif
 
 #if defined(NO_OLD_WC_NAMES) || defined(OPENSSL_EXTRA)
     /* added to have compatibility with SHA256() */
     #if !defined(NO_OLD_SHA_NAMES) && (!defined(HAVE_FIPS) || \
             FIPS_VERSION_GT(2,0))
         #define NO_OLD_SHA_NAMES
     #endif
     #if !defined(NO_OLD_MD5_NAME) && (!defined(HAVE_FIPS) || \
             FIPS_VERSION_GT(2,0))
         #define NO_OLD_MD5_NAME
     #endif
 #endif
 
 /* switch for compatibility layer functionality. Has subparts i.e. BIO/X509
  * When opensslextra is enabled all subparts should be turned on. */
 #ifdef OPENSSL_EXTRA
     #undef  OPENSSL_EXTRA_X509_SMALL
     #define OPENSSL_EXTRA_X509_SMALL
 #endif /* OPENSSL_EXTRA */
 
 /* support for converting DER to PEM */
 #if (defined(WOLFSSL_KEY_GEN) && !defined(WOLFSSL_NO_DER_TO_PEM)) || \
     defined(WOLFSSL_CERT_GEN) || defined(OPENSSL_EXTRA)
     #undef  WOLFSSL_DER_TO_PEM
     #define WOLFSSL_DER_TO_PEM
 #endif
 
 /* keep backwards compatibility enabling encrypted private key */
 #ifndef WOLFSSL_ENCRYPTED_KEYS
     #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL) || \
         defined(HAVE_WEBSERVER)
         #define WOLFSSL_ENCRYPTED_KEYS
     #endif
 #endif
 
 /* support for disabling PEM to DER */
 #if !defined(WOLFSSL_NO_PEM) && !defined(NO_CODING)
     #undef  WOLFSSL_PEM_TO_DER
     #define WOLFSSL_PEM_TO_DER
 #endif
 
 /* Parts of the openssl compatibility layer require peer certs */
 #if defined(OPENSSL_ALL) || defined(WOLFSSL_NGINX) || defined(WOLFSSL_HAPROXY) \
  || defined(HAVE_LIGHTY)
     #undef  KEEP_PEER_CERT
     #define KEEP_PEER_CERT
 #endif
 
 /*
  * Keeps the "Finished" messages after a TLS handshake for use as the so-called
  * "tls-unique" channel binding. See comment in internal.h around clientFinished
  * and serverFinished for more information.
  */
 #if defined(OPENSSL_ALL) || defined(WOLFSSL_HAPROXY) || defined(WOLFSSL_WPAS)
     #undef  WOLFSSL_HAVE_TLS_UNIQUE
     #define WOLFSSL_HAVE_TLS_UNIQUE
 #endif
 
 /* RAW hash function APIs are not implemented */
 #if defined(WOLFSSL_ARMASM) || defined(WOLFSSL_AFALG_HASH)
     #undef  WOLFSSL_NO_HASH_RAW
     #define WOLFSSL_NO_HASH_RAW
 #endif
 
 /* XChacha not implemented with ARM assembly ChaCha */
 #if defined(WOLFSSL_ARMASM)
     #undef HAVE_XCHACHA
 #endif
 
 #if !defined(WOLFSSL_SHA384) && !defined(WOLFSSL_SHA512) && defined(NO_AES) && \
                                                           !defined(WOLFSSL_SHA3)
     #undef  WOLFSSL_NO_WORD64_OPS
     #define WOLFSSL_NO_WORD64_OPS
 #endif
 
 #if !defined(WOLFCRYPT_ONLY) && \
     (!defined(WOLFSSL_NO_TLS12) || defined(HAVE_KEYING_MATERIAL))
     #undef  WOLFSSL_HAVE_PRF
     #define WOLFSSL_HAVE_PRF
 #endif
 
 #if defined(NO_ASN) && defined(WOLFCRYPT_ONLY) && !defined(WOLFSSL_WOLFSSH)
     #undef  WOLFSSL_NO_INT_ENCODE
     #define WOLFSSL_NO_INT_ENCODE
 #endif
 
 #if defined(NO_ASN) && defined(WOLFCRYPT_ONLY)
     #undef  WOLFSSL_NO_INT_DECODE
     #define WOLFSSL_NO_INT_DECODE
 #endif
 
 #if defined(WOLFCRYPT_ONLY) && defined(WOLFSSL_RSA_VERIFY_ONLY) && \
     defined(WC_NO_RSA_OAEP)
     #undef  WOLFSSL_NO_CT_OPS
     #define WOLFSSL_NO_CT_OPS
 #endif
 
 #if defined(WOLFCRYPT_ONLY) && defined(NO_AES) && !defined(HAVE_CURVE25519) && \
         !defined(HAVE_CURVE448) && defined(WC_NO_RNG) && defined(WC_NO_RSA_OAEP)
     #undef  WOLFSSL_NO_CONST_CMP
     #define WOLFSSL_NO_CONST_CMP
 #endif
 
 #if defined(WOLFCRYPT_ONLY) && defined(NO_AES) && !defined(WOLFSSL_SHA384) && \
     !defined(WOLFSSL_SHA512) && defined(WC_NO_RNG) && \
     !defined(WOLFSSL_SP_MATH) && !defined(WOLFSSL_SP_MATH_ALL) \
     && !defined(USE_FAST_MATH)
     #undef  WOLFSSL_NO_FORCE_ZERO
     #define WOLFSSL_NO_FORCE_ZERO
 #endif
 
 /* Detect old cryptodev name */
 #if defined(WOLF_CRYPTO_DEV) && !defined(WOLF_CRYPTO_CB)
     #define WOLF_CRYPTO_CB
 #endif
 
 #if defined(WOLFSSL_TLS13) && defined(WOLFSSL_NO_SIGALG)
     #error TLS 1.3 requires the Signature Algorithms extension to be enabled
 #endif
 
 #ifndef NO_WOLFSSL_BASE64_DECODE
     #define WOLFSSL_BASE64_DECODE
 #endif
 
 #if defined(HAVE_EX_DATA) || defined(FORTRESS)
     #if defined(FORTRESS) && !defined(HAVE_EX_DATA)
         #define HAVE_EX_DATA
     #endif
     #ifndef MAX_EX_DATA
     #define MAX_EX_DATA 5  /* allow for five items of ex_data */
     #endif
 #endif
 
 #ifdef NO_WOLFSSL_SMALL_STACK
     #undef WOLFSSL_SMALL_STACK
 #endif
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SMALL_STACK_STATIC) && \
     !defined(NO_WOLFSSL_SMALL_STACK_STATIC)
 #define WOLFSSL_SMALL_STACK_STATIC
 #endif
 
 #ifdef WOLFSSL_SMALL_STACK_STATIC
     #undef WOLFSSL_SMALL_STACK_STATIC
     #define WOLFSSL_SMALL_STACK_STATIC static
 #else
     #define WOLFSSL_SMALL_STACK_STATIC
 #endif
 
 /* The client session cache requires time for timeout */
 #if defined(NO_ASN_TIME) && !defined(NO_SESSION_CACHE)
     #define NO_SESSION_CACHE
 #endif
 
 #if defined(NO_ASN_TIME) && !defined(WOLFSSL_NO_DEF_TICKET_ENC_CB)
     #define WOLFSSL_NO_DEF_TICKET_ENC_CB
 #endif
 #if defined(NO_ASN_TIME) && defined(HAVE_SESSION_TICKET)
     #undef HAVE_SESSION_TICKET
 #endif
 
 /* Use static ECC structs for Position Independent Code (PIC) */
 #if defined(__IAR_SYSTEMS_ICC__) && defined(__ROPI__)
     #define WOLFSSL_ECC_CURVE_STATIC
     #define WOLFSSL_NAMES_STATIC
     #define WOLFSSL_NO_CONSTCHARCONST
 #endif
 
 /* FIPS v1 does not support TLS v1.3 (requires RSA PSS and HKDF) */
 #if FIPS_VERSION_EQ(1,0)
     #undef WC_RSA_PSS
     #undef WOLFSSL_TLS13
 #endif
 
 /* FIPS v2 does not support WOLFSSL_PSS_LONG_SALT */
 #if FIPS_VERSION_EQ(2,0)
     #ifdef WOLFSSL_PSS_LONG_SALT
         #undef WOLFSSL_PSS_LONG_SALT
     #endif
 #endif
 
 /* For FIPSv2 make sure the ECDSA encoding allows extra bytes
  * but make sure users consider enabling it */
 #if !defined(NO_STRICT_ECDSA_LEN) && FIPS_VERSION_GE(2,0)
     /* ECDSA length checks off by default for CAVP testing
      * consider enabling strict checks in production */
     #define NO_STRICT_ECDSA_LEN
 #endif
 
 /* Do not allow using small stack with no malloc */
 #if defined(WOLFSSL_NO_MALLOC) && \
     (defined(WOLFSSL_SMALL_STACK) || defined(WOLFSSL_SMALL_STACK_CACHE))
     #error Small stack cannot be used with no malloc (WOLFSSL_NO_MALLOC)
 #endif
 
 /* Enable DH Extra for QT, openssl all, openssh and static ephemeral */
 /* Allows export/import of DH key and params as DER */
 #if !defined(NO_DH) && !defined(WOLFSSL_DH_EXTRA) && \
     (defined(WOLFSSL_QT) || defined(OPENSSL_ALL) || defined(WOLFSSL_OPENSSH) || \
      defined(WOLFSSL_STATIC_EPHEMERAL))
     #define WOLFSSL_DH_EXTRA
 #endif
 
 /* DH Extra is not supported on FIPS v1 or v2 (is missing DhKey .pub/.priv) */
 #if defined(WOLFSSL_DH_EXTRA) && defined(HAVE_FIPS) && FIPS_VERSION_LE(2,0)
     #undef WOLFSSL_DH_EXTRA
 #endif
 
 /* wc_Sha512.devId isn't available before FIPS 5.1 */
 #if defined(HAVE_FIPS) && FIPS_VERSION_LT(5,1)
     #define NO_SHA2_CRYPTO_CB
 #endif
 
 /* Enable HAVE_ONE_TIME_AUTH by default for use with TLS cipher suites
  * when poly1305 is enabled
  */
 #if defined(HAVE_POLY1305) && !defined(HAVE_ONE_TIME_AUTH)
     #define HAVE_ONE_TIME_AUTH
 #endif
 
 /* Check for insecure build combination:
  * secure renegotiation   [enabled]
  * extended master secret [disabled]
  * session resumption     [enabled]
  */
 #if defined(HAVE_SECURE_RENEGOTIATION) && !defined(HAVE_EXTENDED_MASTER) && \
     (defined(HAVE_SESSION_TICKET) || !defined(NO_SESSION_CACHE))
     /* secure renegotiation requires extended master secret with resumption */
     #ifndef _MSC_VER
         #warning Extended master secret must be enabled with secure renegotiation and session resumption
     #else
         #pragma message("Warning: Extended master secret must be enabled with secure renegotiation and session resumption")
     #endif
 
     /* Note: "--enable-renegotiation-indication" ("HAVE_RENEGOTIATION_INDICATION")
      * only sends the secure renegotiation extension, but is not actually supported.
      * This was added because some TLS peers required it even if not used, so we call
      * this "(FAKE Secure Renegotiation)"
      */
 #endif
 
 /* if secure renegotiation is enabled, make sure server info is enabled */
 #if !defined(HAVE_RENEGOTIATION_INDICATION) &&                               \
   !defined(HAVE_SERVER_RENEGOTIATION_INFO) &&   \
   defined(HAVE_SECURE_RENEGOTIATION) &&         \
   !defined(NO_WOLFSSL_SERVER)
     #define HAVE_SERVER_RENEGOTIATION_INFO
 #endif
 
 /* Crypto callbacks should enable hash flag support */
 #if defined(WOLF_CRYPTO_CB) && !defined(WOLFSSL_HASH_FLAGS)
     /* FIPS v1 and v2 do not support hash flags, so do not allow it with
      * crypto callbacks */
     #if !defined(HAVE_FIPS) || (defined(HAVE_FIPS) && \
             defined(HAVE_FIPS_VERSION) && HAVE_FIPS_VERSION >= 3)
         #define WOLFSSL_HASH_FLAGS
     #endif
 #endif
 
 #ifdef WOLFSSL_HAVE_KYBER
 #define HAVE_PQC
 #endif
 
 /* Enable Post-Quantum Cryptography if we have liboqs from the OpenQuantumSafe
  * group */
 #ifdef HAVE_LIBOQS
 #define HAVE_PQC
 #define HAVE_FALCON
 #define HAVE_DILITHIUM
 #define HAVE_SPHINCS
 #ifndef WOLFSSL_HAVE_KYBER
     #define WOLFSSL_HAVE_KYBER
     #define WOLFSSL_KYBER512
     #define WOLFSSL_KYBER768
     #define WOLFSSL_KYBER1024
 #endif
 #endif
 
 #ifdef HAVE_PQM4
 #define HAVE_PQC
 #define WOLFSSL_HAVE_KYBER
 #define WOLFSSL_KYBER512
 #define WOLFSSL_NO_KYBER768
 #define WOLFSSL_NO_KYBER1024
 #endif
 
 #if defined(HAVE_PQC) && !defined(HAVE_LIBOQS) && !defined(HAVE_PQM4) && \
     !defined(WOLFSSL_HAVE_KYBER)
 #error Please do not define HAVE_PQC yourself.
 #endif
 
 #if defined(HAVE_PQC) && defined(HAVE_LIBOQS) && defined(HAVE_PQM4)
 #error Please do not define both HAVE_LIBOQS and HAVE_PQM4.
 #endif
 
 /* SRTP requires DTLS */
 #if defined(WOLFSSL_SRTP) && !defined(WOLFSSL_DTLS)
     #error The SRTP extension requires DTLS
 #endif
 
 /* Are we using an external private key store like:
  *     PKCS11 / HSM / crypto callback / PK callback */
 #if !defined(WOLF_PRIVATE_KEY_ID) && !defined(NO_WOLF_PRIVATE_KEY_ID) && \
         (defined(HAVE_PKCS11) || defined(HAVE_PK_CALLBACKS) || \
          defined(WOLF_CRYPTO_CB) || defined(WOLFSSL_KCAPI))
          /* Enables support for using wolfSSL_CTX_use_PrivateKey_Id and
           *   wolfSSL_CTX_use_PrivateKey_Label */
         #define WOLF_PRIVATE_KEY_ID
 #endif
 
 /* With titan cache size there is too many sessions to fit with the default
  * multiplier of 8 */
 #if defined(TITAN_SESSION_CACHE) && !defined(NO_SESSION_CACHE_REF)
     #define NO_SESSION_CACHE_REF
 #endif
 
 /* (D)TLS v1.3 requires 64-bit number wrappers */
 #if defined(WOLFSSL_TLS13) || defined(WOLFSSL_DTLS_DROP_STATS)
     #undef WOLFSSL_W64_WRAPPER
     #define WOLFSSL_W64_WRAPPER
 #endif
 
 /* DTLS v1.3 requires AES ECB if using AES */
 #if defined(WOLFSSL_DTLS13) && !defined(NO_AES) && \
     !defined(WOLFSSL_AES_DIRECT)
 #define WOLFSSL_AES_DIRECT
 #endif
 
 #if defined(WOLFSSL_DTLS13) && (!defined(WOLFSSL_DTLS) || \
                                 !defined(WOLFSSL_TLS13))
 #error "DTLS v1.3 requires both WOLFSSL_TLS13 and WOLFSSL_DTLS"
 #endif
 
 #if defined(WOLFSSL_DTLS_CID) && !defined(WOLFSSL_DTLS13)
 #error "ConnectionID is supported for DTLSv1.3 only"
 #endif
 
 /* RSA Key Checking is disabled by default unless WOLFSSL_RSA_KEY_CHECK is
  *   defined or FIPS v2 3389, FIPS v5 or later.
  * Not allowed for:
  *   RSA public only, CAVP selftest, fast RSA, user RSA, QAT or CryptoCell */
 #if (defined(WOLFSSL_RSA_KEY_CHECK) || (defined(HAVE_FIPS) && FIPS_VERSION_GE(2,0))) && \
     !defined(WOLFSSL_NO_RSA_KEY_CHECK) && !defined(WOLFSSL_RSA_PUBLIC_ONLY) && \
     !defined(HAVE_USER_RSA) && !defined(HAVE_FAST_RSA) && \
     !defined(HAVE_INTEL_QA) && !defined(WOLFSSL_CRYPTOCELL) && \
     !defined(HAVE_SELFTEST)
 
     #undef  WOLFSSL_RSA_KEY_CHECK
     #define WOLFSSL_RSA_KEY_CHECK
 #endif
 
 /* SHAKE - Not allowed in FIPS */
 #if defined(WOLFSSL_SHA3) && !defined(HAVE_SELFTEST) && !defined(HAVE_FIPS)
     #ifndef WOLFSSL_NO_SHAKE128
         #undef  WOLFSSL_SHAKE128
         #define WOLFSSL_SHAKE128
     #endif
     #ifndef WOLFSSL_NO_SHAKE256
         #undef  WOLFSSL_SHAKE256
         #define WOLFSSL_SHAKE256
     #endif
 #else
     #undef  WOLFSSL_NO_SHAKE128
     #define WOLFSSL_NO_SHAKE128
     #undef  WOLFSSL_NO_SHAKE256
     #define WOLFSSL_NO_SHAKE256
 #endif
 
 /* Encrypted Client Hello - requires HPKE */
 #if defined(HAVE_ECH) && !defined(HAVE_HPKE)
     #define HAVE_HPKE
 #endif
 
 /* Provide way to forcefully disable use of XREALLOC */
 #ifdef WOLFSSL_NO_REALLOC
     #undef XREALLOC
 #endif
 
 
 /* ---------------------------------------------------------------------------
  * Deprecated Algorithm Handling
  *   Unless allowed via a build macro, disable support
  * ---------------------------------------------------------------------------*/
 
 /* RC4: Per RFC7465 Feb 2015, the cipher suite has been deprecated due to a
  * number of exploits capable of decrypting portions of encrypted messages. */
 #ifndef WOLFSSL_ALLOW_RC4
     #undef  NO_RC4
     #define NO_RC4
 #endif
 
 #if !defined(WOLFSSL_NO_ASYNC_IO) || defined(WOLFSSL_ASYNC_CRYPT) || \
      defined(WOLFSSL_NONBLOCK_OCSP)
     /* Enable asynchronous support in TLS functions to support one or more of
      * the following:
      * - re-entry after a network blocking return
      * - re-entry after OCSP blocking return
      * - asynchronous cryptography */
     #undef WOLFSSL_ASYNC_IO
     #define WOLFSSL_ASYNC_IO
 #endif
 
 #ifdef WOLFSSL_SYS_CA_CERTS
     #ifdef NO_FILESYSTEM
         /* Turning off WOLFSSL_SYS_CA_CERTS b/c NO_FILESYSTEM is defined */
         #undef WOLFSSL_SYS_CA_CERTS
     #endif
 
     #ifdef NO_CERTS
         /* Turning off WOLFSSL_SYS_CA_CERTS b/c NO_CERTS is defined */
         #undef WOLFSSL_SYS_CA_CERTS
     #endif
 
     #if defined(__APPLE__) && !defined(HAVE_SECURITY_SECTRUSTSETTINGS_H)
         /* Turning off WOLFSSL_SYS_CA_CERTS b/c no Security/SecTrustSettings.h header */
         #undef WOLFSSL_SYS_CA_CERTS
     #endif
 #endif /* WOLFSSL_SYS_CA_CERTS */
 
 #if defined(SESSION_CACHE_DYNAMIC_MEM) && defined(PERSIST_SESSION_CACHE)
 #error "Dynamic session cache currently does not support persistent session cache."
 #endif
 
 #ifdef WOLFSSL_HARDEN_TLS
     #if defined(HAVE_TRUNCATED_HMAC) && !defined(WOLFSSL_HARDEN_TLS_ALLOW_TRUNCATED_HMAC)
         #error "Truncated HMAC Extension not allowed https://www.rfc-editor.org/rfc/rfc9325#section-4.6"
     #endif
     #if !defined(NO_OLD_TLS) && !defined(WOLFSSL_HARDEN_TLS_ALLOW_OLD_TLS)
         #error "TLS < 1.2 protocol versions not allowed https://www.rfc-editor.org/rfc/rfc9325#section-3.1.1"
     #endif
     #if !defined(WOLFSSL_NO_TLS12) && !defined(HAVE_SECURE_RENEGOTIATION) && \
         !defined(HAVE_SERVER_RENEGOTIATION_INFO) && !defined(WOLFSSL_HARDEN_TLS_NO_SCR_CHECK)
         #error "TLS 1.2 requires at least HAVE_SERVER_RENEGOTIATION_INFO to send the secure renegotiation extension https://www.rfc-editor.org/rfc/rfc9325#section-3.5"
     #endif
     #if !defined(WOLFSSL_EXTRA_ALERTS) || !defined(WOLFSSL_CHECK_ALERT_ON_ERR)
         #error "RFC9325 requires some additional alerts to be sent"
     #endif
     /* Ciphersuite check done in internal.h */
 #endif
 
+
 #ifdef __cplusplus
     }   /* extern "C" */
 #endif
 
 #endif
