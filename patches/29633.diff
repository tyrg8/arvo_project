commit 465767437da1bcf99a375295799d33948d9fc5f0
Author: Sitsofe Wheeler <sitsofe@yahoo.com>
Date:   Sat Jan 16 10:41:02 2021 +0000

    options: fix buffer overrun
    
    Google's OSS-fuzz turned up a buffer overrun with value of the filename
    option due to an overrun in a MAX_PATH sized buffer. To reproduce
    compile fio with address sanitizer options like the following
    
    LDFLAGS="-fsanitize=address" ./configure --disable-optimizations \
          --extra-cflags="-fsanitize=address"
    
    The issue is demonstrated by the following job:
    
    % COUNT=$(getconf PATH_MAX /); printf "[t]\nfilename=%${COUNT}s" \
      | sed 's/ /@/g' | fio --parse-only -
    =================================================================
    ==45748==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffee8e35780 at pc 0x00010735a343 bp 0x7ffee8e35270 sp 0x7ffee8e34a08
    WRITE of size 1025 at 0x7ffee8e35780 thread T0
        #0 0x10735a342 in wrap_vsprintf (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0x22342)
        #1 0x10735a9ac in wrap_sprintf (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0x229ac)
        #2 0x106e83b01 in add_file filesetup.c:1656
        #3 0x106ee8c87 in str_filename_cb options.c:1320
        #4 0x106ee1b44 in __handle_option parse.c:792
        #5 0x106ed99ad in handle_option parse.c:1014
        #6 0x106eda07d in parse_option parse.c:1184
        #7 0x106ef10ea in fio_options_parse options.c:5199
        #8 0x106e27684 in __parse_jobs_ini init.c:2076
        #9 0x106e25377 in parse_jobs_ini init.c:2127
        #10 0x106e2c971 in parse_options init.c:2989
        #11 0x106ffc884 in main fio.c:42
        #12 0x7fff702f1cc8 in start (libdyld.dylib:x86_64+0x1acc8)
    
    Address 0x7ffee8e35780 is located in stack of thread T0 at offset 1056 in frame
        #0 0x106e836ef in add_file filesetup.c:1644
    
      This frame has 1 object(s):
        [32, 1056) 'file_name' (line 1646) <== Memory access at offset 1056 overflows this variable
    
    Return an error message to the user by doing the following:
    
    - Allow "regular" string options to have a maxlen parameter
    - Set the filename option to have a maxlen of MAX_PATH
    
    Signed-off-by: Sitsofe Wheeler <sitsofe@yahoo.com>

diff --git a/options.c b/options.c
index 0b4c48d6..955bf959 100644
--- a/options.c
+++ b/options.c
@@ -1639,3222 +1639,3223 @@ static int gtod_cpu_verify(const struct fio_option *o, void *data)
 /*
  * Map of job/command line options
  */
 struct fio_option fio_options[FIO_MAX_OPTS] = {
 	{
 		.name	= "description",
 		.lname	= "Description of job",
 		.type	= FIO_OPT_STR_STORE,
 		.off1	= offsetof(struct thread_options, description),
 		.help	= "Text job description",
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_DESC,
 	},
 	{
 		.name	= "name",
 		.lname	= "Job name",
 		.type	= FIO_OPT_STR_STORE,
 		.off1	= offsetof(struct thread_options, name),
 		.help	= "Name of this job",
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_DESC,
 	},
 	{
 		.name	= "wait_for",
 		.lname	= "Waitee name",
 		.type	= FIO_OPT_STR_STORE,
 		.off1	= offsetof(struct thread_options, wait_for),
 		.help	= "Name of the job this one wants to wait for before starting",
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_DESC,
 	},
 	{
 		.name	= "filename",
 		.lname	= "Filename(s)",
 		.type	= FIO_OPT_STR_STORE,
 		.off1	= offsetof(struct thread_options, filename),
+		.maxlen	= PATH_MAX,
 		.cb	= str_filename_cb,
 		.prio	= -1, /* must come after "directory" */
 		.help	= "File(s) to use for the workload",
 		.category = FIO_OPT_C_FILE,
 		.group	= FIO_OPT_G_FILENAME,
 	},
 	{
 		.name	= "directory",
 		.lname	= "Directory",
 		.type	= FIO_OPT_STR_STORE,
 		.off1	= offsetof(struct thread_options, directory),
 		.cb	= str_directory_cb,
 		.help	= "Directory to store files in",
 		.category = FIO_OPT_C_FILE,
 		.group	= FIO_OPT_G_FILENAME,
 	},
 	{
 		.name	= "filename_format",
 		.lname	= "Filename Format",
 		.type	= FIO_OPT_STR_STORE,
 		.off1	= offsetof(struct thread_options, filename_format),
 		.prio	= -1, /* must come after "directory" */
 		.help	= "Override default $jobname.$jobnum.$filenum naming",
 		.def	= "$jobname.$jobnum.$filenum",
 		.category = FIO_OPT_C_FILE,
 		.group	= FIO_OPT_G_FILENAME,
 	},
 	{
 		.name	= "unique_filename",
 		.lname	= "Unique Filename",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, unique_filename),
 		.help	= "For network clients, prefix file with source IP",
 		.def	= "1",
 		.category = FIO_OPT_C_FILE,
 		.group	= FIO_OPT_G_FILENAME,
 	},
 	{
 		.name	= "lockfile",
 		.lname	= "Lockfile",
 		.type	= FIO_OPT_STR,
 		.off1	= offsetof(struct thread_options, file_lock_mode),
 		.help	= "Lock file when doing IO to it",
 		.prio	= 1,
 		.parent	= "filename",
 		.hide	= 0,
 		.def	= "none",
 		.category = FIO_OPT_C_FILE,
 		.group	= FIO_OPT_G_FILENAME,
 		.posval = {
 			  { .ival = "none",
 			    .oval = FILE_LOCK_NONE,
 			    .help = "No file locking",
 			  },
 			  { .ival = "exclusive",
 			    .oval = FILE_LOCK_EXCLUSIVE,
 			    .help = "Exclusive file lock",
 			  },
 			  {
 			    .ival = "readwrite",
 			    .oval = FILE_LOCK_READWRITE,
 			    .help = "Read vs write lock",
 			  },
 		},
 	},
 	{
 		.name	= "opendir",
 		.lname	= "Open directory",
 		.type	= FIO_OPT_STR_STORE,
 		.off1	= offsetof(struct thread_options, opendir),
 		.cb	= str_opendir_cb,
 		.help	= "Recursively add files from this directory and down",
 		.category = FIO_OPT_C_FILE,
 		.group	= FIO_OPT_G_FILENAME,
 	},
 	{
 		.name	= "rw",
 		.lname	= "Read/write",
 		.alias	= "readwrite",
 		.type	= FIO_OPT_STR,
 		.cb	= str_rw_cb,
 		.off1	= offsetof(struct thread_options, td_ddir),
 		.help	= "IO direction",
 		.def	= "read",
 		.verify	= rw_verify,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IO_BASIC,
 		.posval = {
 			  { .ival = "read",
 			    .oval = TD_DDIR_READ,
 			    .help = "Sequential read",
 			  },
 			  { .ival = "write",
 			    .oval = TD_DDIR_WRITE,
 			    .help = "Sequential write",
 			  },
 			  { .ival = "trim",
 			    .oval = TD_DDIR_TRIM,
 			    .help = "Sequential trim",
 			  },
 			  { .ival = "randread",
 			    .oval = TD_DDIR_RANDREAD,
 			    .help = "Random read",
 			  },
 			  { .ival = "randwrite",
 			    .oval = TD_DDIR_RANDWRITE,
 			    .help = "Random write",
 			  },
 			  { .ival = "randtrim",
 			    .oval = TD_DDIR_RANDTRIM,
 			    .help = "Random trim",
 			  },
 			  { .ival = "rw",
 			    .oval = TD_DDIR_RW,
 			    .help = "Sequential read and write mix",
 			  },
 			  { .ival = "readwrite",
 			    .oval = TD_DDIR_RW,
 			    .help = "Sequential read and write mix",
 			  },
 			  { .ival = "randrw",
 			    .oval = TD_DDIR_RANDRW,
 			    .help = "Random read and write mix"
 			  },
 			  { .ival = "trimwrite",
 			    .oval = TD_DDIR_TRIMWRITE,
 			    .help = "Trim and write mix, trims preceding writes"
 			  },
 		},
 	},
 	{
 		.name	= "rw_sequencer",
 		.lname	= "RW Sequencer",
 		.type	= FIO_OPT_STR,
 		.off1	= offsetof(struct thread_options, rw_seq),
 		.help	= "IO offset generator modifier",
 		.def	= "sequential",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IO_BASIC,
 		.posval = {
 			  { .ival = "sequential",
 			    .oval = RW_SEQ_SEQ,
 			    .help = "Generate sequential offsets",
 			  },
 			  { .ival = "identical",
 			    .oval = RW_SEQ_IDENT,
 			    .help = "Generate identical offsets",
 			  },
 		},
 	},
 
 	{
 		.name	= "ioengine",
 		.lname	= "IO Engine",
 		.type	= FIO_OPT_STR_STORE,
 		.off1	= offsetof(struct thread_options, ioengine),
 		.help	= "IO engine to use",
 		.def	= FIO_PREFERRED_ENGINE,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IO_BASIC,
 		.posval	= {
 			  { .ival = "sync",
 			    .help = "Use read/write",
 			  },
 			  { .ival = "psync",
 			    .help = "Use pread/pwrite",
 			  },
 			  { .ival = "vsync",
 			    .help = "Use readv/writev",
 			  },
 #ifdef CONFIG_PWRITEV
 			  { .ival = "pvsync",
 			    .help = "Use preadv/pwritev",
 			  },
 #endif
 #ifdef FIO_HAVE_PWRITEV2
 			  { .ival = "pvsync2",
 			    .help = "Use preadv2/pwritev2",
 			  },
 #endif
 #ifdef CONFIG_LIBAIO
 			  { .ival = "libaio",
 			    .help = "Linux native asynchronous IO",
 			  },
 #endif
 #ifdef ARCH_HAVE_IOURING
 			  { .ival = "io_uring",
 			    .help = "Fast Linux native aio",
 			  },
 #endif
 #ifdef CONFIG_POSIXAIO
 			  { .ival = "posixaio",
 			    .help = "POSIX asynchronous IO",
 			  },
 #endif
 #ifdef CONFIG_SOLARISAIO
 			  { .ival = "solarisaio",
 			    .help = "Solaris native asynchronous IO",
 			  },
 #endif
 #ifdef CONFIG_WINDOWSAIO
 			  { .ival = "windowsaio",
 			    .help = "Windows native asynchronous IO"
 			  },
 #endif
 #ifdef CONFIG_RBD
 			  { .ival = "rbd",
 			    .help = "Rados Block Device asynchronous IO"
 			  },
 #endif
 			  { .ival = "mmap",
 			    .help = "Memory mapped IO"
 			  },
 #ifdef CONFIG_LINUX_SPLICE
 			  { .ival = "splice",
 			    .help = "splice/vmsplice based IO",
 			  },
 			  { .ival = "netsplice",
 			    .help = "splice/vmsplice to/from the network",
 			  },
 #endif
 #ifdef FIO_HAVE_SGIO
 			  { .ival = "sg",
 			    .help = "SCSI generic v3 IO",
 			  },
 #endif
 			  { .ival = "null",
 			    .help = "Testing engine (no data transfer)",
 			  },
 			  { .ival = "net",
 			    .help = "Network IO",
 			  },
 			  { .ival = "cpuio",
 			    .help = "CPU cycle burner engine",
 			  },
 #ifdef CONFIG_RDMA
 			  { .ival = "rdma",
 			    .help = "RDMA IO engine",
 			  },
 #endif
 #ifdef CONFIG_LINUX_EXT4_MOVE_EXTENT
 			  { .ival = "e4defrag",
 			    .help = "ext4 defrag engine",
 			  },
 #endif
 #ifdef CONFIG_LINUX_FALLOCATE
 			  { .ival = "falloc",
 			    .help = "fallocate() file based engine",
 			  },
 #endif
 #ifdef CONFIG_GFAPI
 			  { .ival = "gfapi",
 			    .help = "Glusterfs libgfapi(sync) based engine"
 			  },
 			  { .ival = "gfapi_async",
 			    .help = "Glusterfs libgfapi(async) based engine"
 			  },
 #endif
 #ifdef CONFIG_LIBHDFS
 			  { .ival = "libhdfs",
 			    .help = "Hadoop Distributed Filesystem (HDFS) engine"
 			  },
 #endif
 #ifdef CONFIG_PMEMBLK
 			  { .ival = "pmemblk",
 			    .help = "PMDK libpmemblk based IO engine",
 			  },
 
 #endif
 #ifdef CONFIG_IME
 			  { .ival = "ime_psync",
 			    .help = "DDN's IME synchronous IO engine",
 			  },
 			  { .ival = "ime_psyncv",
 			    .help = "DDN's IME synchronous IO engine using iovecs",
 			  },
 			  { .ival = "ime_aio",
 			    .help = "DDN's IME asynchronous IO engine",
 			  },
 #endif
 #ifdef CONFIG_LINUX_DEVDAX
 			  { .ival = "dev-dax",
 			    .help = "DAX Device based IO engine",
 			  },
 #endif
 			  {
 			    .ival = "filecreate",
 			    .help = "File creation engine",
 			  },
 			  { .ival = "external",
 			    .help = "Load external engine (append name)",
 			    .cb = str_ioengine_external_cb,
 			  },
 #ifdef CONFIG_LIBPMEM
 			  { .ival = "libpmem",
 			    .help = "PMDK libpmem based IO engine",
 			  },
 #endif
 #ifdef CONFIG_HTTP
 			  { .ival = "http",
 			    .help = "HTTP (WebDAV/S3) IO engine",
 			  },
 #endif
 			  { .ival = "nbd",
 			    .help = "Network Block Device (NBD) IO engine"
 			  },
 		},
 	},
 	{
 		.name	= "iodepth",
 		.lname	= "IO Depth",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, iodepth),
 		.help	= "Number of IO buffers to keep in flight",
 		.minval = 1,
 		.interval = 1,
 		.def	= "1",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IO_BASIC,
 	},
 	{
 		.name	= "iodepth_batch",
 		.lname	= "IO Depth batch",
 		.alias	= "iodepth_batch_submit",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, iodepth_batch),
 		.help	= "Number of IO buffers to submit in one go",
 		.parent	= "iodepth",
 		.hide	= 1,
 		.interval = 1,
 		.def	= "1",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IO_BASIC,
 	},
 	{
 		.name	= "iodepth_batch_complete_min",
 		.lname	= "Min IO depth batch complete",
 		.alias	= "iodepth_batch_complete",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, iodepth_batch_complete_min),
 		.help	= "Min number of IO buffers to retrieve in one go",
 		.parent	= "iodepth",
 		.hide	= 1,
 		.minval	= 0,
 		.interval = 1,
 		.def	= "1",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IO_BASIC,
 	},
 	{
 		.name	= "iodepth_batch_complete_max",
 		.lname	= "Max IO depth batch complete",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, iodepth_batch_complete_max),
 		.help	= "Max number of IO buffers to retrieve in one go",
 		.parent	= "iodepth",
 		.hide	= 1,
 		.minval	= 0,
 		.interval = 1,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IO_BASIC,
 	},
 	{
 		.name	= "iodepth_low",
 		.lname	= "IO Depth batch low",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, iodepth_low),
 		.help	= "Low water mark for queuing depth",
 		.parent	= "iodepth",
 		.hide	= 1,
 		.interval = 1,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IO_BASIC,
 	},
 	{
 		.name	= "serialize_overlap",
 		.lname	= "Serialize overlap",
 		.off1	= offsetof(struct thread_options, serialize_overlap),
 		.type	= FIO_OPT_BOOL,
 		.help	= "Wait for in-flight IOs that collide to complete",
 		.parent	= "iodepth",
 		.def	= "0",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IO_BASIC,
 	},
 	{
 		.name	= "io_submit_mode",
 		.lname	= "IO submit mode",
 		.type	= FIO_OPT_STR,
 		.off1	= offsetof(struct thread_options, io_submit_mode),
 		.help	= "How IO submissions and completions are done",
 		.def	= "inline",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IO_BASIC,
 		.posval = {
 			  { .ival = "inline",
 			    .oval = IO_MODE_INLINE,
 			    .help = "Submit and complete IO inline",
 			  },
 			  { .ival = "offload",
 			    .oval = IO_MODE_OFFLOAD,
 			    .help = "Offload submit and complete to threads",
 			  },
 		},
 	},
 	{
 		.name	= "size",
 		.lname	= "Size",
 		.type	= FIO_OPT_STR_VAL,
 		.cb	= str_size_cb,
 		.off1	= offsetof(struct thread_options, size),
 		.help	= "Total size of device or files",
 		.interval = 1024 * 1024,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "io_size",
 		.alias	= "io_limit",
 		.lname	= "IO Size",
 		.type	= FIO_OPT_STR_VAL,
 		.cb	= str_io_size_cb,
 		.off1	= offsetof(struct thread_options, io_size),
 		.help	= "Total size of I/O to be performed",
 		.interval = 1024 * 1024,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "fill_device",
 		.lname	= "Fill device",
 		.alias	= "fill_fs",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, fill_device),
 		.help	= "Write until an ENOSPC error occurs",
 		.def	= "0",
 		.category = FIO_OPT_C_FILE,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "filesize",
 		.lname	= "File size",
 		.type	= FIO_OPT_STR_VAL,
 		.off1	= offsetof(struct thread_options, file_size_low),
 		.off2	= offsetof(struct thread_options, file_size_high),
 		.minval = 1,
 		.help	= "Size of individual files",
 		.interval = 1024 * 1024,
 		.category = FIO_OPT_C_FILE,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "file_append",
 		.lname	= "File append",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, file_append),
 		.help	= "IO will start at the end of the file(s)",
 		.def	= "0",
 		.category = FIO_OPT_C_FILE,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "offset",
 		.lname	= "IO offset",
 		.alias	= "fileoffset",
 		.type	= FIO_OPT_STR_VAL,
 		.cb	= str_offset_cb,
 		.off1	= offsetof(struct thread_options, start_offset),
 		.help	= "Start IO from this offset",
 		.def	= "0",
 		.interval = 1024 * 1024,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "offset_align",
 		.lname	= "IO offset alignment",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, start_offset_align),
 		.help	= "Start IO from this offset alignment",
 		.def	= "0",
 		.interval = 512,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "offset_increment",
 		.lname	= "IO offset increment",
 		.type	= FIO_OPT_STR_VAL,
 		.cb	= str_offset_increment_cb,
 		.off1	= offsetof(struct thread_options, offset_increment),
 		.help	= "What is the increment from one offset to the next",
 		.parent = "offset",
 		.hide	= 1,
 		.def	= "0",
 		.interval = 1024 * 1024,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "number_ios",
 		.lname	= "Number of IOs to perform",
 		.type	= FIO_OPT_STR_VAL,
 		.off1	= offsetof(struct thread_options, number_ios),
 		.help	= "Force job completion after this number of IOs",
 		.def	= "0",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "bs",
 		.lname	= "Block size",
 		.alias	= "blocksize",
 		.type	= FIO_OPT_ULL,
 		.off1	= offsetof(struct thread_options, bs[DDIR_READ]),
 		.off2	= offsetof(struct thread_options, bs[DDIR_WRITE]),
 		.off3	= offsetof(struct thread_options, bs[DDIR_TRIM]),
 		.minval = 1,
 		.help	= "Block size unit",
 		.def	= "4096",
 		.parent = "rw",
 		.hide	= 1,
 		.interval = 512,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "ba",
 		.lname	= "Block size align",
 		.alias	= "blockalign",
 		.type	= FIO_OPT_ULL,
 		.off1	= offsetof(struct thread_options, ba[DDIR_READ]),
 		.off2	= offsetof(struct thread_options, ba[DDIR_WRITE]),
 		.off3	= offsetof(struct thread_options, ba[DDIR_TRIM]),
 		.minval	= 1,
 		.help	= "IO block offset alignment",
 		.parent	= "rw",
 		.hide	= 1,
 		.interval = 512,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "bsrange",
 		.lname	= "Block size range",
 		.alias	= "blocksize_range",
 		.type	= FIO_OPT_RANGE,
 		.off1	= offsetof(struct thread_options, min_bs[DDIR_READ]),
 		.off2	= offsetof(struct thread_options, max_bs[DDIR_READ]),
 		.off3	= offsetof(struct thread_options, min_bs[DDIR_WRITE]),
 		.off4	= offsetof(struct thread_options, max_bs[DDIR_WRITE]),
 		.off5	= offsetof(struct thread_options, min_bs[DDIR_TRIM]),
 		.off6	= offsetof(struct thread_options, max_bs[DDIR_TRIM]),
 		.minval = 1,
 		.help	= "Set block size range (in more detail than bs)",
 		.parent = "rw",
 		.hide	= 1,
 		.interval = 4096,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "bssplit",
 		.lname	= "Block size split",
 		.type	= FIO_OPT_STR_ULL,
 		.cb	= str_bssplit_cb,
 		.off1	= offsetof(struct thread_options, bssplit),
 		.help	= "Set a specific mix of block sizes",
 		.parent	= "rw",
 		.hide	= 1,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "bs_unaligned",
 		.lname	= "Block size unaligned",
 		.alias	= "blocksize_unaligned",
 		.type	= FIO_OPT_STR_SET,
 		.off1	= offsetof(struct thread_options, bs_unaligned),
 		.help	= "Don't sector align IO buffer sizes",
 		.parent = "rw",
 		.hide	= 1,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "bs_is_seq_rand",
 		.lname	= "Block size division is seq/random (not read/write)",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, bs_is_seq_rand),
 		.help	= "Consider any blocksize setting to be sequential,random",
 		.def	= "0",
 		.parent = "blocksize",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "randrepeat",
 		.lname	= "Random repeatable",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, rand_repeatable),
 		.help	= "Use repeatable random IO pattern",
 		.def	= "1",
 		.parent = "rw",
 		.hide	= 1,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_RANDOM,
 	},
 	{
 		.name	= "randseed",
 		.lname	= "The random generator seed",
 		.type	= FIO_OPT_STR_VAL,
 		.off1	= offsetof(struct thread_options, rand_seed),
 		.help	= "Set the random generator seed value",
 		.def	= "0x89",
 		.parent = "rw",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_RANDOM,
 	},
 	{
 		.name	= "norandommap",
 		.lname	= "No randommap",
 		.type	= FIO_OPT_STR_SET,
 		.off1	= offsetof(struct thread_options, norandommap),
 		.help	= "Accept potential duplicate random blocks",
 		.parent = "rw",
 		.hide	= 1,
 		.hide_on_set = 1,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_RANDOM,
 	},
 	{
 		.name	= "softrandommap",
 		.lname	= "Soft randommap",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, softrandommap),
 		.help	= "Set norandommap if randommap allocation fails",
 		.parent	= "norandommap",
 		.hide	= 1,
 		.def	= "0",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_RANDOM,
 	},
 	{
 		.name	= "random_generator",
 		.lname	= "Random Generator",
 		.type	= FIO_OPT_STR,
 		.off1	= offsetof(struct thread_options, random_generator),
 		.help	= "Type of random number generator to use",
 		.def	= "tausworthe",
 		.posval	= {
 			  { .ival = "tausworthe",
 			    .oval = FIO_RAND_GEN_TAUSWORTHE,
 			    .help = "Strong Tausworthe generator",
 			  },
 			  { .ival = "lfsr",
 			    .oval = FIO_RAND_GEN_LFSR,
 			    .help = "Variable length LFSR",
 			  },
 			  {
 			    .ival = "tausworthe64",
 			    .oval = FIO_RAND_GEN_TAUSWORTHE64,
 			    .help = "64-bit Tausworthe variant",
 			  },
 		},
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_RANDOM,
 	},
 	{
 		.name	= "random_distribution",
 		.lname	= "Random Distribution",
 		.type	= FIO_OPT_STR,
 		.off1	= offsetof(struct thread_options, random_distribution),
 		.cb	= str_random_distribution_cb,
 		.help	= "Random offset distribution generator",
 		.def	= "random",
 		.posval	= {
 			  { .ival = "random",
 			    .oval = FIO_RAND_DIST_RANDOM,
 			    .help = "Completely random",
 			  },
 			  { .ival = "zipf",
 			    .oval = FIO_RAND_DIST_ZIPF,
 			    .help = "Zipf distribution",
 			  },
 			  { .ival = "pareto",
 			    .oval = FIO_RAND_DIST_PARETO,
 			    .help = "Pareto distribution",
 			  },
 			  { .ival = "normal",
 			    .oval = FIO_RAND_DIST_GAUSS,
 			    .help = "Normal (Gaussian) distribution",
 			  },
 			  { .ival = "zoned",
 			    .oval = FIO_RAND_DIST_ZONED,
 			    .help = "Zoned random distribution",
 			  },
 			  { .ival = "zoned_abs",
 			    .oval = FIO_RAND_DIST_ZONED_ABS,
 			    .help = "Zoned absolute random distribution",
 			  },
 		},
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_RANDOM,
 	},
 	{
 		.name	= "percentage_random",
 		.lname	= "Percentage Random",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, perc_rand[DDIR_READ]),
 		.off2	= offsetof(struct thread_options, perc_rand[DDIR_WRITE]),
 		.off3	= offsetof(struct thread_options, perc_rand[DDIR_TRIM]),
 		.maxval	= 100,
 		.help	= "Percentage of seq/random mix that should be random",
 		.def	= "100,100,100",
 		.interval = 5,
 		.inverse = "percentage_sequential",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_RANDOM,
 	},
 	{
 		.name	= "percentage_sequential",
 		.lname	= "Percentage Sequential",
 		.type	= FIO_OPT_DEPRECATED,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_RANDOM,
 	},
 	{
 		.name	= "allrandrepeat",
 		.lname	= "All Random Repeat",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, allrand_repeatable),
 		.help	= "Use repeatable random numbers for everything",
 		.def	= "0",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_RANDOM,
 	},
 	{
 		.name	= "nrfiles",
 		.lname	= "Number of files",
 		.alias	= "nr_files",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, nr_files),
 		.help	= "Split job workload between this number of files",
 		.def	= "1",
 		.interval = 1,
 		.category = FIO_OPT_C_FILE,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "openfiles",
 		.lname	= "Number of open files",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, open_files),
 		.help	= "Number of files to keep open at the same time",
 		.category = FIO_OPT_C_FILE,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "file_service_type",
 		.lname	= "File service type",
 		.type	= FIO_OPT_STR,
 		.cb	= str_fst_cb,
 		.off1	= offsetof(struct thread_options, file_service_type),
 		.help	= "How to select which file to service next",
 		.def	= "roundrobin",
 		.category = FIO_OPT_C_FILE,
 		.group	= FIO_OPT_G_INVALID,
 		.posval	= {
 			  { .ival = "random",
 			    .oval = FIO_FSERVICE_RANDOM,
 			    .help = "Choose a file at random (uniform)",
 			  },
 			  { .ival = "zipf",
 			    .oval = FIO_FSERVICE_ZIPF,
 			    .help = "Zipf randomized",
 			  },
 			  { .ival = "pareto",
 			    .oval = FIO_FSERVICE_PARETO,
 			    .help = "Pareto randomized",
 			  },
 			  { .ival = "normal",
 			    .oval = FIO_FSERVICE_GAUSS,
 			    .help = "Normal (Gaussian) randomized",
 			  },
 			  { .ival = "gauss",
 			    .oval = FIO_FSERVICE_GAUSS,
 			    .help = "Alias for normal",
 			  },
 			  { .ival = "roundrobin",
 			    .oval = FIO_FSERVICE_RR,
 			    .help = "Round robin select files",
 			  },
 			  { .ival = "sequential",
 			    .oval = FIO_FSERVICE_SEQ,
 			    .help = "Finish one file before moving to the next",
 			  },
 		},
 		.parent = "nrfiles",
 		.hide	= 1,
 	},
 	{
 		.name	= "fallocate",
 		.lname	= "Fallocate",
 		.type	= FIO_OPT_STR,
 		.off1	= offsetof(struct thread_options, fallocate_mode),
 		.help	= "Whether pre-allocation is performed when laying out files",
 #ifdef FIO_HAVE_DEFAULT_FALLOCATE
 		.def	= "native",
 #else
 		.def	= "none",
 #endif
 		.category = FIO_OPT_C_FILE,
 		.group	= FIO_OPT_G_INVALID,
 		.posval	= {
 			  { .ival = "none",
 			    .oval = FIO_FALLOCATE_NONE,
 			    .help = "Do not pre-allocate space",
 			  },
 			  { .ival = "native",
 			    .oval = FIO_FALLOCATE_NATIVE,
 			    .help = "Use native pre-allocation if possible",
 			  },
 #ifdef CONFIG_POSIX_FALLOCATE
 			  { .ival = "posix",
 			    .oval = FIO_FALLOCATE_POSIX,
 			    .help = "Use posix_fallocate()",
 			  },
 #endif
 #ifdef CONFIG_LINUX_FALLOCATE
 			  { .ival = "keep",
 			    .oval = FIO_FALLOCATE_KEEP_SIZE,
 			    .help = "Use fallocate(..., FALLOC_FL_KEEP_SIZE, ...)",
 			  },
 #endif
 			  { .ival = "truncate",
 			    .oval = FIO_FALLOCATE_TRUNCATE,
 			    .help = "Truncate file to final size instead of allocating"
 			  },
 			  /* Compatibility with former boolean values */
 			  { .ival = "0",
 			    .oval = FIO_FALLOCATE_NONE,
 			    .help = "Alias for 'none'",
 			  },
 #ifdef CONFIG_POSIX_FALLOCATE
 			  { .ival = "1",
 			    .oval = FIO_FALLOCATE_POSIX,
 			    .help = "Alias for 'posix'",
 			  },
 #endif
 		},
 	},
 	{
 		.name	= "fadvise_hint",
 		.lname	= "Fadvise hint",
 		.type	= FIO_OPT_STR,
 		.off1	= offsetof(struct thread_options, fadvise_hint),
 		.posval	= {
 			  { .ival = "0",
 			    .oval = F_ADV_NONE,
 			    .help = "Don't issue fadvise/madvise",
 			  },
 			  { .ival = "1",
 			    .oval = F_ADV_TYPE,
 			    .help = "Advise using fio IO pattern",
 			  },
 			  { .ival = "random",
 			    .oval = F_ADV_RANDOM,
 			    .help = "Advise using FADV_RANDOM",
 			  },
 			  { .ival = "sequential",
 			    .oval = F_ADV_SEQUENTIAL,
 			    .help = "Advise using FADV_SEQUENTIAL",
 			  },
 		},
 		.help	= "Use fadvise() to advise the kernel on IO pattern",
 		.def	= "1",
 		.category = FIO_OPT_C_FILE,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "fsync",
 		.lname	= "Fsync",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, fsync_blocks),
 		.help	= "Issue fsync for writes every given number of blocks",
 		.def	= "0",
 		.interval = 1,
 		.category = FIO_OPT_C_FILE,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "fdatasync",
 		.lname	= "Fdatasync",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, fdatasync_blocks),
 		.help	= "Issue fdatasync for writes every given number of blocks",
 		.def	= "0",
 		.interval = 1,
 		.category = FIO_OPT_C_FILE,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "write_barrier",
 		.lname	= "Write barrier",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, barrier_blocks),
 		.help	= "Make every Nth write a barrier write",
 		.def	= "0",
 		.interval = 1,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_INVALID,
 	},
 #ifdef CONFIG_SYNC_FILE_RANGE
 	{
 		.name	= "sync_file_range",
 		.lname	= "Sync file range",
 		.posval	= {
 			  { .ival = "wait_before",
 			    .oval = SYNC_FILE_RANGE_WAIT_BEFORE,
 			    .help = "SYNC_FILE_RANGE_WAIT_BEFORE",
 			    .orval  = 1,
 			  },
 			  { .ival = "write",
 			    .oval = SYNC_FILE_RANGE_WRITE,
 			    .help = "SYNC_FILE_RANGE_WRITE",
 			    .orval  = 1,
 			  },
 			  {
 			    .ival = "wait_after",
 			    .oval = SYNC_FILE_RANGE_WAIT_AFTER,
 			    .help = "SYNC_FILE_RANGE_WAIT_AFTER",
 			    .orval  = 1,
 			  },
 		},
 		.type	= FIO_OPT_STR_MULTI,
 		.cb	= str_sfr_cb,
 		.off1	= offsetof(struct thread_options, sync_file_range),
 		.help	= "Use sync_file_range()",
 		.category = FIO_OPT_C_FILE,
 		.group	= FIO_OPT_G_INVALID,
 	},
 #else
 	{
 		.name	= "sync_file_range",
 		.lname	= "Sync file range",
 		.type	= FIO_OPT_UNSUPPORTED,
 		.help	= "Your platform does not support sync_file_range",
 	},
 #endif
 	{
 		.name	= "direct",
 		.lname	= "Direct I/O",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, odirect),
 		.help	= "Use O_DIRECT IO (negates buffered)",
 		.def	= "0",
 		.inverse = "buffered",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IO_TYPE,
 	},
 	{
 		.name	= "atomic",
 		.lname	= "Atomic I/O",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, oatomic),
 		.help	= "Use Atomic IO with O_DIRECT (implies O_DIRECT)",
 		.def	= "0",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IO_TYPE,
 	},
 	{
 		.name	= "buffered",
 		.lname	= "Buffered I/O",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, odirect),
 		.neg	= 1,
 		.help	= "Use buffered IO (negates direct)",
 		.def	= "1",
 		.inverse = "direct",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IO_TYPE,
 	},
 	{
 		.name	= "overwrite",
 		.lname	= "Overwrite",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, overwrite),
 		.help	= "When writing, set whether to overwrite current data",
 		.def	= "0",
 		.category = FIO_OPT_C_FILE,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "loops",
 		.lname	= "Loops",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, loops),
 		.help	= "Number of times to run the job",
 		.def	= "1",
 		.interval = 1,
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_RUNTIME,
 	},
 	{
 		.name	= "numjobs",
 		.lname	= "Number of jobs",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, numjobs),
 		.help	= "Duplicate this job this many times",
 		.def	= "1",
 		.interval = 1,
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_RUNTIME,
 	},
 	{
 		.name	= "startdelay",
 		.lname	= "Start delay",
 		.type	= FIO_OPT_STR_VAL_TIME,
 		.off1	= offsetof(struct thread_options, start_delay),
 		.off2	= offsetof(struct thread_options, start_delay_high),
 		.help	= "Only start job when this period has passed",
 		.def	= "0",
 		.is_seconds = 1,
 		.is_time = 1,
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_RUNTIME,
 	},
 	{
 		.name	= "runtime",
 		.lname	= "Runtime",
 		.alias	= "timeout",
 		.type	= FIO_OPT_STR_VAL_TIME,
 		.off1	= offsetof(struct thread_options, timeout),
 		.help	= "Stop workload when this amount of time has passed",
 		.def	= "0",
 		.is_seconds = 1,
 		.is_time = 1,
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_RUNTIME,
 	},
 	{
 		.name	= "time_based",
 		.lname	= "Time based",
 		.type	= FIO_OPT_STR_SET,
 		.off1	= offsetof(struct thread_options, time_based),
 		.help	= "Keep running until runtime/timeout is met",
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_RUNTIME,
 	},
 	{
 		.name	= "verify_only",
 		.lname	= "Verify only",
 		.type	= FIO_OPT_STR_SET,
 		.off1	= offsetof(struct thread_options, verify_only),
 		.help	= "Verifies previously written data is still valid",
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_RUNTIME,
 	},
 	{
 		.name	= "ramp_time",
 		.lname	= "Ramp time",
 		.type	= FIO_OPT_STR_VAL_TIME,
 		.off1	= offsetof(struct thread_options, ramp_time),
 		.help	= "Ramp up time before measuring performance",
 		.is_seconds = 1,
 		.is_time = 1,
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_RUNTIME,
 	},
 	{
 		.name	= "clocksource",
 		.lname	= "Clock source",
 		.type	= FIO_OPT_STR,
 		.cb	= fio_clock_source_cb,
 		.off1	= offsetof(struct thread_options, clocksource),
 		.help	= "What type of timing source to use",
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_CLOCK,
 		.posval	= {
 #ifdef CONFIG_GETTIMEOFDAY
 			  { .ival = "gettimeofday",
 			    .oval = CS_GTOD,
 			    .help = "Use gettimeofday(2) for timing",
 			  },
 #endif
 #ifdef CONFIG_CLOCK_GETTIME
 			  { .ival = "clock_gettime",
 			    .oval = CS_CGETTIME,
 			    .help = "Use clock_gettime(2) for timing",
 			  },
 #endif
 #ifdef ARCH_HAVE_CPU_CLOCK
 			  { .ival = "cpu",
 			    .oval = CS_CPUCLOCK,
 			    .help = "Use CPU private clock",
 			  },
 #endif
 		},
 	},
 	{
 		.name	= "mem",
 		.alias	= "iomem",
 		.lname	= "I/O Memory",
 		.type	= FIO_OPT_STR,
 		.cb	= str_mem_cb,
 		.off1	= offsetof(struct thread_options, mem_type),
 		.help	= "Backing type for IO buffers",
 		.def	= "malloc",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_INVALID,
 		.posval	= {
 			  { .ival = "malloc",
 			    .oval = MEM_MALLOC,
 			    .help = "Use malloc(3) for IO buffers",
 			  },
 #ifndef CONFIG_NO_SHM
 			  { .ival = "shm",
 			    .oval = MEM_SHM,
 			    .help = "Use shared memory segments for IO buffers",
 			  },
 #ifdef FIO_HAVE_HUGETLB
 			  { .ival = "shmhuge",
 			    .oval = MEM_SHMHUGE,
 			    .help = "Like shm, but use huge pages",
 			  },
 #endif
 #endif
 			  { .ival = "mmap",
 			    .oval = MEM_MMAP,
 			    .help = "Use mmap(2) (file or anon) for IO buffers",
 			  },
 			  { .ival = "mmapshared",
 			    .oval = MEM_MMAPSHARED,
 			    .help = "Like mmap, but use the shared flag",
 			  },
 #ifdef FIO_HAVE_HUGETLB
 			  { .ival = "mmaphuge",
 			    .oval = MEM_MMAPHUGE,
 			    .help = "Like mmap, but use huge pages",
 			  },
 #endif
 #ifdef CONFIG_CUDA
 			  { .ival = "cudamalloc",
 			    .oval = MEM_CUDA_MALLOC,
 			    .help = "Allocate GPU device memory for GPUDirect RDMA",
 			  },
 #endif
 		  },
 	},
 	{
 		.name	= "iomem_align",
 		.alias	= "mem_align",
 		.lname	= "I/O memory alignment",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, mem_align),
 		.minval	= 0,
 		.help	= "IO memory buffer offset alignment",
 		.def	= "0",
 		.parent	= "iomem",
 		.hide	= 1,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "verify",
 		.lname	= "Verify",
 		.type	= FIO_OPT_STR,
 		.off1	= offsetof(struct thread_options, verify),
 		.help	= "Verify data written",
 		.def	= "0",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_VERIFY,
 		.posval = {
 			  { .ival = "0",
 			    .oval = VERIFY_NONE,
 			    .help = "Don't do IO verification",
 			  },
 			  { .ival = "md5",
 			    .oval = VERIFY_MD5,
 			    .help = "Use md5 checksums for verification",
 			  },
 			  { .ival = "crc64",
 			    .oval = VERIFY_CRC64,
 			    .help = "Use crc64 checksums for verification",
 			  },
 			  { .ival = "crc32",
 			    .oval = VERIFY_CRC32,
 			    .help = "Use crc32 checksums for verification",
 			  },
 			  { .ival = "crc32c-intel",
 			    .oval = VERIFY_CRC32C,
 			    .help = "Use crc32c checksums for verification (hw assisted, if available)",
 			  },
 			  { .ival = "crc32c",
 			    .oval = VERIFY_CRC32C,
 			    .help = "Use crc32c checksums for verification (hw assisted, if available)",
 			  },
 			  { .ival = "crc16",
 			    .oval = VERIFY_CRC16,
 			    .help = "Use crc16 checksums for verification",
 			  },
 			  { .ival = "crc7",
 			    .oval = VERIFY_CRC7,
 			    .help = "Use crc7 checksums for verification",
 			  },
 			  { .ival = "sha1",
 			    .oval = VERIFY_SHA1,
 			    .help = "Use sha1 checksums for verification",
 			  },
 			  { .ival = "sha256",
 			    .oval = VERIFY_SHA256,
 			    .help = "Use sha256 checksums for verification",
 			  },
 			  { .ival = "sha512",
 			    .oval = VERIFY_SHA512,
 			    .help = "Use sha512 checksums for verification",
 			  },
 			  { .ival = "sha3-224",
 			    .oval = VERIFY_SHA3_224,
 			    .help = "Use sha3-224 checksums for verification",
 			  },
 			  { .ival = "sha3-256",
 			    .oval = VERIFY_SHA3_256,
 			    .help = "Use sha3-256 checksums for verification",
 			  },
 			  { .ival = "sha3-384",
 			    .oval = VERIFY_SHA3_384,
 			    .help = "Use sha3-384 checksums for verification",
 			  },
 			  { .ival = "sha3-512",
 			    .oval = VERIFY_SHA3_512,
 			    .help = "Use sha3-512 checksums for verification",
 			  },
 			  { .ival = "xxhash",
 			    .oval = VERIFY_XXHASH,
 			    .help = "Use xxhash checksums for verification",
 			  },
 			  /* Meta information was included into verify_header,
 			   * 'meta' verification is implied by default. */
 			  { .ival = "meta",
 			    .oval = VERIFY_HDR_ONLY,
 			    .help = "Use io information for verification. "
 				    "Now is implied by default, thus option is obsolete, "
 				    "don't use it",
 			  },
 			  { .ival = "pattern",
 			    .oval = VERIFY_PATTERN_NO_HDR,
 			    .help = "Verify strict pattern",
 			  },
 			  {
 			    .ival = "null",
 			    .oval = VERIFY_NULL,
 			    .help = "Pretend to verify",
 			  },
 		},
 	},
 	{
 		.name	= "do_verify",
 		.lname	= "Perform verify step",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, do_verify),
 		.help	= "Run verification stage after write",
 		.def	= "1",
 		.parent = "verify",
 		.hide	= 1,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_VERIFY,
 	},
 	{
 		.name	= "verifysort",
 		.lname	= "Verify sort",
 		.type	= FIO_OPT_SOFT_DEPRECATED,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_VERIFY,
 	},
 	{
 		.name	= "verifysort_nr",
 		.lname	= "Verify Sort Nr",
 		.type	= FIO_OPT_SOFT_DEPRECATED,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_VERIFY,
 	},
 	{
 		.name   = "verify_interval",
 		.lname	= "Verify interval",
 		.type   = FIO_OPT_INT,
 		.off1   = offsetof(struct thread_options, verify_interval),
 		.minval	= 2 * sizeof(struct verify_header),
 		.help   = "Store verify buffer header every N bytes",
 		.parent	= "verify",
 		.hide	= 1,
 		.interval = 2 * sizeof(struct verify_header),
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_VERIFY,
 	},
 	{
 		.name	= "verify_offset",
 		.lname	= "Verify offset",
 		.type	= FIO_OPT_INT,
 		.help	= "Offset verify header location by N bytes",
 		.off1	= offsetof(struct thread_options, verify_offset),
 		.minval	= sizeof(struct verify_header),
 		.parent	= "verify",
 		.hide	= 1,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_VERIFY,
 	},
 	{
 		.name	= "verify_pattern",
 		.lname	= "Verify pattern",
 		.type	= FIO_OPT_STR,
 		.cb	= str_verify_pattern_cb,
 		.off1	= offsetof(struct thread_options, verify_pattern),
 		.help	= "Fill pattern for IO buffers",
 		.parent	= "verify",
 		.hide	= 1,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_VERIFY,
 	},
 	{
 		.name	= "verify_fatal",
 		.lname	= "Verify fatal",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, verify_fatal),
 		.def	= "0",
 		.help	= "Exit on a single verify failure, don't continue",
 		.parent = "verify",
 		.hide	= 1,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_VERIFY,
 	},
 	{
 		.name	= "verify_dump",
 		.lname	= "Verify dump",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, verify_dump),
 		.def	= "0",
 		.help	= "Dump contents of good and bad blocks on failure",
 		.parent = "verify",
 		.hide	= 1,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_VERIFY,
 	},
 	{
 		.name	= "verify_async",
 		.lname	= "Verify asynchronously",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, verify_async),
 		.def	= "0",
 		.help	= "Number of async verifier threads to use",
 		.parent	= "verify",
 		.hide	= 1,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_VERIFY,
 	},
 	{
 		.name	= "verify_backlog",
 		.lname	= "Verify backlog",
 		.type	= FIO_OPT_STR_VAL,
 		.off1	= offsetof(struct thread_options, verify_backlog),
 		.help	= "Verify after this number of blocks are written",
 		.parent	= "verify",
 		.hide	= 1,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_VERIFY,
 	},
 	{
 		.name	= "verify_backlog_batch",
 		.lname	= "Verify backlog batch",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, verify_batch),
 		.help	= "Verify this number of IO blocks",
 		.parent	= "verify",
 		.hide	= 1,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_VERIFY,
 	},
 #ifdef FIO_HAVE_CPU_AFFINITY
 	{
 		.name	= "verify_async_cpus",
 		.lname	= "Async verify CPUs",
 		.type	= FIO_OPT_STR,
 		.cb	= str_verify_cpus_allowed_cb,
 		.off1	= offsetof(struct thread_options, verify_cpumask),
 		.help	= "Set CPUs allowed for async verify threads",
 		.parent	= "verify_async",
 		.hide	= 1,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_VERIFY,
 	},
 #else
 	{
 		.name	= "verify_async_cpus",
 		.lname	= "Async verify CPUs",
 		.type	= FIO_OPT_UNSUPPORTED,
 		.help	= "Your platform does not support CPU affinities",
 	},
 #endif
 	{
 		.name	= "experimental_verify",
 		.lname	= "Experimental Verify",
 		.off1	= offsetof(struct thread_options, experimental_verify),
 		.type	= FIO_OPT_BOOL,
 		.help	= "Enable experimental verification",
 		.parent	= "verify",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_VERIFY,
 	},
 	{
 		.name	= "verify_state_load",
 		.lname	= "Load verify state",
 		.off1	= offsetof(struct thread_options, verify_state),
 		.type	= FIO_OPT_BOOL,
 		.help	= "Load verify termination state",
 		.parent	= "verify",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_VERIFY,
 	},
 	{
 		.name	= "verify_state_save",
 		.lname	= "Save verify state",
 		.off1	= offsetof(struct thread_options, verify_state_save),
 		.type	= FIO_OPT_BOOL,
 		.def	= "1",
 		.help	= "Save verify state on termination",
 		.parent	= "verify",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_VERIFY,
 	},
 #ifdef FIO_HAVE_TRIM
 	{
 		.name	= "trim_percentage",
 		.lname	= "Trim percentage",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, trim_percentage),
 		.minval = 0,
 		.maxval = 100,
 		.help	= "Number of verify blocks to trim (i.e., discard)",
 		.parent	= "verify",
 		.def	= "0",
 		.interval = 1,
 		.hide	= 1,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_TRIM,
 	},
 	{
 		.name	= "trim_verify_zero",
 		.lname	= "Verify trim zero",
 		.type	= FIO_OPT_BOOL,
 		.help	= "Verify that trimmed (i.e., discarded) blocks are returned as zeroes",
 		.off1	= offsetof(struct thread_options, trim_zero),
 		.parent	= "trim_percentage",
 		.hide	= 1,
 		.def	= "1",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_TRIM,
 	},
 	{
 		.name	= "trim_backlog",
 		.lname	= "Trim backlog",
 		.type	= FIO_OPT_STR_VAL,
 		.off1	= offsetof(struct thread_options, trim_backlog),
 		.help	= "Trim after this number of blocks are written",
 		.parent	= "trim_percentage",
 		.hide	= 1,
 		.interval = 1,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_TRIM,
 	},
 	{
 		.name	= "trim_backlog_batch",
 		.lname	= "Trim backlog batch",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, trim_batch),
 		.help	= "Trim this number of IO blocks",
 		.parent	= "trim_percentage",
 		.hide	= 1,
 		.interval = 1,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_TRIM,
 	},
 #else
 	{
 		.name	= "trim_percentage",
 		.lname	= "Trim percentage",
 		.type	= FIO_OPT_UNSUPPORTED,
 		.help	= "Fio does not support TRIM on your platform",
 	},
 	{
 		.name	= "trim_verify_zero",
 		.lname	= "Verify trim zero",
 		.type	= FIO_OPT_UNSUPPORTED,
 		.help	= "Fio does not support TRIM on your platform",
 	},
 	{
 		.name	= "trim_backlog",
 		.lname	= "Trim backlog",
 		.type	= FIO_OPT_UNSUPPORTED,
 		.help	= "Fio does not support TRIM on your platform",
 	},
 	{
 		.name	= "trim_backlog_batch",
 		.lname	= "Trim backlog batch",
 		.type	= FIO_OPT_UNSUPPORTED,
 		.help	= "Fio does not support TRIM on your platform",
 	},
 #endif
 	{
 		.name	= "write_iolog",
 		.lname	= "Write I/O log",
 		.type	= FIO_OPT_STR_STORE,
 		.off1	= offsetof(struct thread_options, write_iolog_file),
 		.help	= "Store IO pattern to file",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IOLOG,
 	},
 	{
 		.name	= "read_iolog",
 		.lname	= "Read I/O log",
 		.type	= FIO_OPT_STR_STORE,
 		.off1	= offsetof(struct thread_options, read_iolog_file),
 		.help	= "Playback IO pattern from file",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IOLOG,
 	},
 	{
 		.name	= "read_iolog_chunked",
 		.lname	= "Read I/O log in parts",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, read_iolog_chunked),
 		.def	= "0",
 		.parent	= "read_iolog",
 		.help	= "Parse IO pattern in chunks",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IOLOG,
 	},
 	{
 		.name	= "replay_no_stall",
 		.lname	= "Don't stall on replay",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, no_stall),
 		.def	= "0",
 		.parent	= "read_iolog",
 		.hide	= 1,
 		.help	= "Playback IO pattern file as fast as possible without stalls",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IOLOG,
 	},
 	{
 		.name	= "replay_redirect",
 		.lname	= "Redirect device for replay",
 		.type	= FIO_OPT_STR_STORE,
 		.off1	= offsetof(struct thread_options, replay_redirect),
 		.parent	= "read_iolog",
 		.hide	= 1,
 		.help	= "Replay all I/O onto this device, regardless of trace device",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IOLOG,
 	},
 	{
 		.name	= "replay_scale",
 		.lname	= "Replace offset scale factor",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, replay_scale),
 		.parent	= "read_iolog",
 		.def	= "1",
 		.help	= "Align offsets to this blocksize",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IOLOG,
 	},
 	{
 		.name	= "replay_align",
 		.lname	= "Replace alignment",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, replay_align),
 		.parent	= "read_iolog",
 		.help	= "Scale offset down by this factor",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IOLOG,
 		.pow2	= 1,
 	},
 	{
 		.name	= "replay_time_scale",
 		.lname	= "Replay Time Scale",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, replay_time_scale),
 		.def	= "100",
 		.minval	= 1,
 		.parent	= "read_iolog",
 		.hide	= 1,
 		.help	= "Scale time for replay events",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IOLOG,
 	},
 	{
 		.name	= "replay_skip",
 		.lname	= "Replay Skip",
 		.type	= FIO_OPT_STR,
 		.cb	= str_replay_skip_cb,
 		.off1	= offsetof(struct thread_options, replay_skip),
 		.parent	= "read_iolog",
 		.help	= "Skip certain IO types (read,write,trim,flush)",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IOLOG,
 	},
 	{
 		.name	= "merge_blktrace_file",
 		.lname	= "Merged blktrace output filename",
 		.type	= FIO_OPT_STR_STORE,
 		.off1	= offsetof(struct thread_options, merge_blktrace_file),
 		.help	= "Merged blktrace output filename",
 		.category = FIO_OPT_C_IO,
 		.group = FIO_OPT_G_IOLOG,
 	},
 	{
 		.name	= "merge_blktrace_scalars",
 		.lname	= "Percentage to scale each trace",
 		.type	= FIO_OPT_FLOAT_LIST,
 		.off1	= offsetof(struct thread_options, merge_blktrace_scalars),
 		.maxlen	= FIO_IO_U_LIST_MAX_LEN,
 		.help	= "Percentage to scale each trace",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IOLOG,
 	},
 	{
 		.name	= "merge_blktrace_iters",
 		.lname	= "Number of iterations to run per trace",
 		.type	= FIO_OPT_FLOAT_LIST,
 		.off1	= offsetof(struct thread_options, merge_blktrace_iters),
 		.maxlen	= FIO_IO_U_LIST_MAX_LEN,
 		.help	= "Number of iterations to run per trace",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IOLOG,
 	},
 	{
 		.name	= "exec_prerun",
 		.lname	= "Pre-execute runnable",
 		.type	= FIO_OPT_STR_STORE,
 		.off1	= offsetof(struct thread_options, exec_prerun),
 		.help	= "Execute this file prior to running job",
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "exec_postrun",
 		.lname	= "Post-execute runnable",
 		.type	= FIO_OPT_STR_STORE,
 		.off1	= offsetof(struct thread_options, exec_postrun),
 		.help	= "Execute this file after running job",
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_INVALID,
 	},
 #ifdef FIO_HAVE_IOSCHED_SWITCH
 	{
 		.name	= "ioscheduler",
 		.lname	= "I/O scheduler",
 		.type	= FIO_OPT_STR_STORE,
 		.off1	= offsetof(struct thread_options, ioscheduler),
 		.help	= "Use this IO scheduler on the backing device",
 		.category = FIO_OPT_C_FILE,
 		.group	= FIO_OPT_G_INVALID,
 	},
 #else
 	{
 		.name	= "ioscheduler",
 		.lname	= "I/O scheduler",
 		.type	= FIO_OPT_UNSUPPORTED,
 		.help	= "Your platform does not support IO scheduler switching",
 	},
 #endif
 	{
 		.name	= "zonemode",
 		.lname	= "Zone mode",
 		.help	= "Mode for the zonesize, zonerange and zoneskip parameters",
 		.type	= FIO_OPT_STR,
 		.off1	= offsetof(struct thread_options, zone_mode),
 		.def	= "none",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_ZONE,
 		.posval	= {
 			   { .ival = "none",
 			     .oval = ZONE_MODE_NONE,
 			     .help = "no zoning",
 			   },
 			   { .ival = "strided",
 			     .oval = ZONE_MODE_STRIDED,
 			     .help = "strided mode - random I/O is restricted to a single zone",
 			   },
 			   { .ival = "zbd",
 			     .oval = ZONE_MODE_ZBD,
 			     .help = "zoned block device mode - random I/O selects one of multiple zones randomly",
 			   },
 		},
 	},
 	{
 		.name	= "zonesize",
 		.lname	= "Zone size",
 		.type	= FIO_OPT_STR_VAL,
 		.off1	= offsetof(struct thread_options, zone_size),
 		.help	= "Amount of data to read per zone",
 		.def	= "0",
 		.interval = 1024 * 1024,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_ZONE,
 	},
 	{
 		.name	= "zonecapacity",
 		.lname	= "Zone capacity",
 		.type	= FIO_OPT_STR_VAL,
 		.off1	= offsetof(struct thread_options, zone_capacity),
 		.help	= "Capacity per zone",
 		.def	= "0",
 		.interval = 1024 * 1024,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_ZONE,
 	},
 	{
 		.name	= "zonerange",
 		.lname	= "Zone range",
 		.type	= FIO_OPT_STR_VAL,
 		.off1	= offsetof(struct thread_options, zone_range),
 		.help	= "Give size of an IO zone",
 		.def	= "0",
 		.interval = 1024 * 1024,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_ZONE,
 	},
 	{
 		.name	= "zoneskip",
 		.lname	= "Zone skip",
 		.type	= FIO_OPT_STR_VAL,
 		.off1	= offsetof(struct thread_options, zone_skip),
 		.help	= "Space between IO zones",
 		.def	= "0",
 		.interval = 1024 * 1024,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_ZONE,
 	},
 	{
 		.name	= "read_beyond_wp",
 		.lname	= "Allow reads beyond the zone write pointer",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, read_beyond_wp),
 		.help	= "Allow reads beyond the zone write pointer",
 		.def	= "0",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "max_open_zones",
 		.lname	= "Per device/file maximum number of open zones",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, max_open_zones),
 		.maxval	= ZBD_MAX_OPEN_ZONES,
 		.help	= "Limit on the number of simultaneously opened sequential write zones with zonemode=zbd",
 		.def	= "0",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "job_max_open_zones",
 		.lname	= "Job maximum number of open zones",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, job_max_open_zones),
 		.maxval	= ZBD_MAX_OPEN_ZONES,
 		.help	= "Limit on the number of simultaneously opened sequential write zones with zonemode=zbd by one thread/process",
 		.def	= "0",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "zone_reset_threshold",
 		.lname	= "Zone reset threshold",
 		.help	= "Zoned block device reset threshold",
 		.type	= FIO_OPT_FLOAT_LIST,
 		.maxlen	= 1,
 		.off1	= offsetof(struct thread_options, zrt),
 		.minfp	= 0,
 		.maxfp	= 1,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_ZONE,
 	},
 	{
 		.name	= "zone_reset_frequency",
 		.lname	= "Zone reset frequency",
 		.help	= "Zoned block device zone reset frequency in HZ",
 		.type	= FIO_OPT_FLOAT_LIST,
 		.maxlen	= 1,
 		.off1	= offsetof(struct thread_options, zrf),
 		.minfp	= 0,
 		.maxfp	= 1,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_ZONE,
 	},
 	{
 		.name	= "lockmem",
 		.lname	= "Lock memory",
 		.type	= FIO_OPT_STR_VAL,
 		.off1	= offsetof(struct thread_options, lockmem),
 		.help	= "Lock down this amount of memory (per worker)",
 		.def	= "0",
 		.interval = 1024 * 1024,
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "rwmixread",
 		.lname	= "Read/write mix read",
 		.type	= FIO_OPT_INT,
 		.cb	= str_rwmix_read_cb,
 		.off1	= offsetof(struct thread_options, rwmix[DDIR_READ]),
 		.maxval	= 100,
 		.help	= "Percentage of mixed workload that is reads",
 		.def	= "50",
 		.interval = 5,
 		.inverse = "rwmixwrite",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_RWMIX,
 	},
 	{
 		.name	= "rwmixwrite",
 		.lname	= "Read/write mix write",
 		.type	= FIO_OPT_INT,
 		.cb	= str_rwmix_write_cb,
 		.off1	= offsetof(struct thread_options, rwmix[DDIR_WRITE]),
 		.maxval	= 100,
 		.help	= "Percentage of mixed workload that is writes",
 		.def	= "50",
 		.interval = 5,
 		.inverse = "rwmixread",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_RWMIX,
 	},
 	{
 		.name	= "rwmixcycle",
 		.lname	= "Read/write mix cycle",
 		.type	= FIO_OPT_DEPRECATED,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_RWMIX,
 	},
 	{
 		.name	= "nice",
 		.lname	= "Nice",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, nice),
 		.help	= "Set job CPU nice value",
 		.minval	= -20,
 		.maxval	= 19,
 		.def	= "0",
 		.interval = 1,
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_CRED,
 	},
 #ifdef FIO_HAVE_IOPRIO
 	{
 		.name	= "prio",
 		.lname	= "I/O nice priority",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, ioprio),
 		.help	= "Set job IO priority value",
 		.minval	= IOPRIO_MIN_PRIO,
 		.maxval	= IOPRIO_MAX_PRIO,
 		.interval = 1,
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_CRED,
 	},
 #else
 	{
 		.name	= "prio",
 		.lname	= "I/O nice priority",
 		.type	= FIO_OPT_UNSUPPORTED,
 		.help	= "Your platform does not support IO priorities",
 	},
 #endif
 #ifdef FIO_HAVE_IOPRIO_CLASS
 #ifndef FIO_HAVE_IOPRIO
 #error "FIO_HAVE_IOPRIO_CLASS requires FIO_HAVE_IOPRIO"
 #endif
 	{
 		.name	= "prioclass",
 		.lname	= "I/O nice priority class",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, ioprio_class),
 		.help	= "Set job IO priority class",
 		.minval	= IOPRIO_MIN_PRIO_CLASS,
 		.maxval	= IOPRIO_MAX_PRIO_CLASS,
 		.interval = 1,
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_CRED,
 	},
 #else
 	{
 		.name	= "prioclass",
 		.lname	= "I/O nice priority class",
 		.type	= FIO_OPT_UNSUPPORTED,
 		.help	= "Your platform does not support IO priority classes",
 	},
 #endif
 	{
 		.name	= "thinktime",
 		.lname	= "Thinktime",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, thinktime),
 		.help	= "Idle time between IO buffers (usec)",
 		.def	= "0",
 		.is_time = 1,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_THINKTIME,
 	},
 	{
 		.name	= "thinktime_spin",
 		.lname	= "Thinktime spin",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, thinktime_spin),
 		.help	= "Start think time by spinning this amount (usec)",
 		.def	= "0",
 		.is_time = 1,
 		.parent	= "thinktime",
 		.hide	= 1,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_THINKTIME,
 	},
 	{
 		.name	= "thinktime_blocks",
 		.lname	= "Thinktime blocks",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, thinktime_blocks),
 		.help	= "IO buffer period between 'thinktime'",
 		.def	= "1",
 		.parent	= "thinktime",
 		.hide	= 1,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_THINKTIME,
 	},
 	{
 		.name	= "rate",
 		.lname	= "I/O rate",
 		.type	= FIO_OPT_ULL,
 		.off1	= offsetof(struct thread_options, rate[DDIR_READ]),
 		.off2	= offsetof(struct thread_options, rate[DDIR_WRITE]),
 		.off3	= offsetof(struct thread_options, rate[DDIR_TRIM]),
 		.help	= "Set bandwidth rate",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_RATE,
 	},
 	{
 		.name	= "rate_min",
 		.alias	= "ratemin",
 		.lname	= "I/O min rate",
 		.type	= FIO_OPT_ULL,
 		.off1	= offsetof(struct thread_options, ratemin[DDIR_READ]),
 		.off2	= offsetof(struct thread_options, ratemin[DDIR_WRITE]),
 		.off3	= offsetof(struct thread_options, ratemin[DDIR_TRIM]),
 		.help	= "Job must meet this rate or it will be shutdown",
 		.parent	= "rate",
 		.hide	= 1,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_RATE,
 	},
 	{
 		.name	= "rate_iops",
 		.lname	= "I/O rate IOPS",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, rate_iops[DDIR_READ]),
 		.off2	= offsetof(struct thread_options, rate_iops[DDIR_WRITE]),
 		.off3	= offsetof(struct thread_options, rate_iops[DDIR_TRIM]),
 		.help	= "Limit IO used to this number of IO operations/sec",
 		.hide	= 1,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_RATE,
 	},
 	{
 		.name	= "rate_iops_min",
 		.lname	= "I/O min rate IOPS",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, rate_iops_min[DDIR_READ]),
 		.off2	= offsetof(struct thread_options, rate_iops_min[DDIR_WRITE]),
 		.off3	= offsetof(struct thread_options, rate_iops_min[DDIR_TRIM]),
 		.help	= "Job must meet this rate or it will be shut down",
 		.parent	= "rate_iops",
 		.hide	= 1,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_RATE,
 	},
 	{
 		.name	= "rate_process",
 		.lname	= "Rate Process",
 		.type	= FIO_OPT_STR,
 		.off1	= offsetof(struct thread_options, rate_process),
 		.help	= "What process controls how rated IO is managed",
 		.def	= "linear",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_RATE,
 		.posval = {
 			  { .ival = "linear",
 			    .oval = RATE_PROCESS_LINEAR,
 			    .help = "Linear rate of IO",
 			  },
 			  {
 			    .ival = "poisson",
 			    .oval = RATE_PROCESS_POISSON,
 			    .help = "Rate follows Poisson process",
 			  },
 		},
 		.parent = "rate",
 	},
 	{
 		.name	= "rate_cycle",
 		.alias	= "ratecycle",
 		.lname	= "I/O rate cycle",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, ratecycle),
 		.help	= "Window average for rate limits (msec)",
 		.def	= "1000",
 		.parent = "rate",
 		.hide	= 1,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_RATE,
 	},
 	{
 		.name	= "rate_ignore_thinktime",
 		.lname	= "Rate ignore thinktime",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, rate_ign_think),
 		.help	= "Rated IO ignores thinktime settings",
 		.parent = "rate",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_RATE,
 	},
 	{
 		.name	= "max_latency",
 		.lname	= "Max Latency (usec)",
 		.type	= FIO_OPT_STR_VAL_TIME,
 		.off1	= offsetof(struct thread_options, max_latency),
 		.help	= "Maximum tolerated IO latency (usec)",
 		.is_time = 1,
 		.category = FIO_OPT_C_IO,
 		.group = FIO_OPT_G_LATPROF,
 	},
 	{
 		.name	= "latency_target",
 		.lname	= "Latency Target (usec)",
 		.type	= FIO_OPT_STR_VAL_TIME,
 		.off1	= offsetof(struct thread_options, latency_target),
 		.help	= "Ramp to max queue depth supporting this latency",
 		.is_time = 1,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_LATPROF,
 	},
 	{
 		.name	= "latency_window",
 		.lname	= "Latency Window (usec)",
 		.type	= FIO_OPT_STR_VAL_TIME,
 		.off1	= offsetof(struct thread_options, latency_window),
 		.help	= "Time to sustain latency_target",
 		.is_time = 1,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_LATPROF,
 	},
 	{
 		.name	= "latency_percentile",
 		.lname	= "Latency Percentile",
 		.type	= FIO_OPT_FLOAT_LIST,
 		.off1	= offsetof(struct thread_options, latency_percentile),
 		.help	= "Percentile of IOs must be below latency_target",
 		.def	= "100",
 		.maxlen	= 1,
 		.minfp	= 0.0,
 		.maxfp	= 100.0,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_LATPROF,
 	},
 	{
 		.name	= "latency_run",
 		.lname	= "Latency Run",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, latency_run),
 		.help	= "Keep adjusting queue depth to match latency_target",
 		.def	= "0",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_LATPROF,
 	},
 	{
 		.name	= "invalidate",
 		.lname	= "Cache invalidate",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, invalidate_cache),
 		.help	= "Invalidate buffer/page cache prior to running job",
 		.def	= "1",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IO_TYPE,
 	},
 	{
 		.name	= "sync",
 		.lname	= "Synchronous I/O",
 		.type	= FIO_OPT_STR,
 		.off1	= offsetof(struct thread_options, sync_io),
 		.help	= "Use synchronous write IO",
 		.def	= "none",
 		.hide	= 1,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IO_TYPE,
 		.posval = {
 			  { .ival = "none",
 			    .oval = 0,
 			  },
 			  { .ival = "0",
 			    .oval = 0,
 			  },
 			  { .ival = "sync",
 			    .oval = O_SYNC,
 			  },
 			  { .ival = "1",
 			    .oval = O_SYNC,
 			  },
 #ifdef O_DSYNC
 			  { .ival = "dsync",
 			    .oval = O_DSYNC,
 			  },
 #endif
 		},
 	},
 #ifdef FIO_HAVE_WRITE_HINT
 	{
 		.name	= "write_hint",
 		.lname	= "Write hint",
 		.type	= FIO_OPT_STR,
 		.off1	= offsetof(struct thread_options, write_hint),
 		.help	= "Set expected write life time",
 		.category = FIO_OPT_C_ENGINE,
 		.group	= FIO_OPT_G_INVALID,
 		.posval = {
 			  { .ival = "none",
 			    .oval = RWH_WRITE_LIFE_NONE,
 			  },
 			  { .ival = "short",
 			    .oval = RWH_WRITE_LIFE_SHORT,
 			  },
 			  { .ival = "medium",
 			    .oval = RWH_WRITE_LIFE_MEDIUM,
 			  },
 			  { .ival = "long",
 			    .oval = RWH_WRITE_LIFE_LONG,
 			  },
 			  { .ival = "extreme",
 			    .oval = RWH_WRITE_LIFE_EXTREME,
 			  },
 		},
 	},
 #endif
 	{
 		.name	= "create_serialize",
 		.lname	= "Create serialize",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, create_serialize),
 		.help	= "Serialize creation of job files",
 		.def	= "1",
 		.category = FIO_OPT_C_FILE,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "create_fsync",
 		.lname	= "Create fsync",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, create_fsync),
 		.help	= "fsync file after creation",
 		.def	= "1",
 		.category = FIO_OPT_C_FILE,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "create_on_open",
 		.lname	= "Create on open",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, create_on_open),
 		.help	= "Create files when they are opened for IO",
 		.def	= "0",
 		.category = FIO_OPT_C_FILE,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "create_only",
 		.lname	= "Create Only",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, create_only),
 		.help	= "Only perform file creation phase",
 		.category = FIO_OPT_C_FILE,
 		.def	= "0",
 	},
 	{
 		.name	= "allow_file_create",
 		.lname	= "Allow file create",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, allow_create),
 		.help	= "Permit fio to create files, if they don't exist",
 		.def	= "1",
 		.category = FIO_OPT_C_FILE,
 		.group	= FIO_OPT_G_FILENAME,
 	},
 	{
 		.name	= "allow_mounted_write",
 		.lname	= "Allow mounted write",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, allow_mounted_write),
 		.help	= "Allow writes to a mounted partition",
 		.def	= "0",
 		.category = FIO_OPT_C_FILE,
 		.group	= FIO_OPT_G_FILENAME,
 	},
 	{
 		.name	= "pre_read",
 		.lname	= "Pre-read files",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, pre_read),
 		.help	= "Pre-read files before starting official testing",
 		.def	= "0",
 		.category = FIO_OPT_C_FILE,
 		.group	= FIO_OPT_G_INVALID,
 	},
 #ifdef FIO_HAVE_CPU_AFFINITY
 	{
 		.name	= "cpumask",
 		.lname	= "CPU mask",
 		.type	= FIO_OPT_INT,
 		.cb	= str_cpumask_cb,
 		.off1	= offsetof(struct thread_options, cpumask),
 		.help	= "CPU affinity mask",
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_CRED,
 	},
 	{
 		.name	= "cpus_allowed",
 		.lname	= "CPUs allowed",
 		.type	= FIO_OPT_STR,
 		.cb	= str_cpus_allowed_cb,
 		.off1	= offsetof(struct thread_options, cpumask),
 		.help	= "Set CPUs allowed",
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_CRED,
 	},
 	{
 		.name	= "cpus_allowed_policy",
 		.lname	= "CPUs allowed distribution policy",
 		.type	= FIO_OPT_STR,
 		.off1	= offsetof(struct thread_options, cpus_allowed_policy),
 		.help	= "Distribution policy for cpus_allowed",
 		.parent = "cpus_allowed",
 		.prio	= 1,
 		.posval = {
 			  { .ival = "shared",
 			    .oval = FIO_CPUS_SHARED,
 			    .help = "Mask shared between threads",
 			  },
 			  { .ival = "split",
 			    .oval = FIO_CPUS_SPLIT,
 			    .help = "Mask split between threads",
 			  },
 		},
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_CRED,
 	},
 #else
 	{
 		.name	= "cpumask",
 		.lname	= "CPU mask",
 		.type	= FIO_OPT_UNSUPPORTED,
 		.help	= "Your platform does not support CPU affinities",
 	},
 	{
 		.name	= "cpus_allowed",
 		.lname	= "CPUs allowed",
 		.type	= FIO_OPT_UNSUPPORTED,
 		.help	= "Your platform does not support CPU affinities",
 	},
 	{
 		.name	= "cpus_allowed_policy",
 		.lname	= "CPUs allowed distribution policy",
 		.type	= FIO_OPT_UNSUPPORTED,
 		.help	= "Your platform does not support CPU affinities",
 	},
 #endif
 #ifdef CONFIG_LIBNUMA
 	{
 		.name	= "numa_cpu_nodes",
 		.lname	= "NUMA CPU Nodes",
 		.type	= FIO_OPT_STR,
 		.cb	= str_numa_cpunodes_cb,
 		.off1	= offsetof(struct thread_options, numa_cpunodes),
 		.help	= "NUMA CPU nodes bind",
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "numa_mem_policy",
 		.lname	= "NUMA Memory Policy",
 		.type	= FIO_OPT_STR,
 		.cb	= str_numa_mpol_cb,
 		.off1	= offsetof(struct thread_options, numa_memnodes),
 		.help	= "NUMA memory policy setup",
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_INVALID,
 	},
 #else
 	{
 		.name	= "numa_cpu_nodes",
 		.lname	= "NUMA CPU Nodes",
 		.type	= FIO_OPT_UNSUPPORTED,
 		.help	= "Build fio with libnuma-dev(el) to enable this option",
 	},
 	{
 		.name	= "numa_mem_policy",
 		.lname	= "NUMA Memory Policy",
 		.type	= FIO_OPT_UNSUPPORTED,
 		.help	= "Build fio with libnuma-dev(el) to enable this option",
 	},
 #endif
 #ifdef CONFIG_CUDA
 	{
 		.name	= "gpu_dev_id",
 		.lname	= "GPU device ID",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, gpu_dev_id),
 		.help	= "Set GPU device ID for GPUDirect RDMA",
 		.def    = "0",
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_INVALID,
 	},
 #endif
 	{
 		.name	= "end_fsync",
 		.lname	= "End fsync",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, end_fsync),
 		.help	= "Include fsync at the end of job",
 		.def	= "0",
 		.category = FIO_OPT_C_FILE,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "fsync_on_close",
 		.lname	= "Fsync on close",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, fsync_on_close),
 		.help	= "fsync files on close",
 		.def	= "0",
 		.category = FIO_OPT_C_FILE,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "unlink",
 		.lname	= "Unlink file",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, unlink),
 		.help	= "Unlink created files after job has completed",
 		.def	= "0",
 		.category = FIO_OPT_C_FILE,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "unlink_each_loop",
 		.lname	= "Unlink file after each loop of a job",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, unlink_each_loop),
 		.help	= "Unlink created files after each loop in a job has completed",
 		.def	= "0",
 		.category = FIO_OPT_C_FILE,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "exitall",
 		.lname	= "Exit-all on terminate",
 		.type	= FIO_OPT_STR_SET,
 		.cb	= str_exitall_cb,
 		.help	= "Terminate all jobs when one exits",
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_PROCESS,
 	},
 	{
 		.name	= "exit_what",
 		.lname	= "What jobs to quit on terminate",
 		.type	= FIO_OPT_STR,
 		.off1	= offsetof(struct thread_options, exit_what),
 		.help	= "Fine-grained control for exitall",
 		.def	= "group",
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_PROCESS,
 		.posval	= {
 			  { .ival = "group",
 			    .oval = TERMINATE_GROUP,
 			    .help = "exit_all=1 default behaviour",
 			  },
 			  { .ival = "stonewall",
 			    .oval = TERMINATE_STONEWALL,
 			    .help = "quit all currently running jobs; continue with next stonewall",
 			  },
 			  { .ival = "all",
 			    .oval = TERMINATE_ALL,
 			    .help = "Quit everything",
 			  },
 		},
 	},
 	{
 		.name	= "exitall_on_error",
 		.lname	= "Exit-all on terminate in error",
 		.type	= FIO_OPT_STR_SET,
 		.off1	= offsetof(struct thread_options, exitall_error),
 		.help	= "Terminate all jobs when one exits in error",
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_PROCESS,
 	},
 	{
 		.name	= "stonewall",
 		.lname	= "Wait for previous",
 		.alias	= "wait_for_previous",
 		.type	= FIO_OPT_STR_SET,
 		.off1	= offsetof(struct thread_options, stonewall),
 		.help	= "Insert a hard barrier between this job and previous",
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_PROCESS,
 	},
 	{
 		.name	= "new_group",
 		.lname	= "New group",
 		.type	= FIO_OPT_STR_SET,
 		.off1	= offsetof(struct thread_options, new_group),
 		.help	= "Mark the start of a new group (for reporting)",
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_PROCESS,
 	},
 	{
 		.name	= "thread",
 		.lname	= "Thread",
 		.type	= FIO_OPT_STR_SET,
 		.off1	= offsetof(struct thread_options, use_thread),
 		.help	= "Use threads instead of processes",
 #ifdef CONFIG_NO_SHM
 		.def	= "1",
 		.no_warn_def = 1,
 #endif
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_PROCESS,
 	},
 	{
 		.name	= "per_job_logs",
 		.lname	= "Per Job Logs",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, per_job_logs),
 		.help	= "Include job number in generated log files or not",
 		.def	= "1",
 		.category = FIO_OPT_C_LOG,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "write_bw_log",
 		.lname	= "Write bandwidth log",
 		.type	= FIO_OPT_STR,
 		.off1	= offsetof(struct thread_options, bw_log_file),
 		.cb	= str_write_bw_log_cb,
 		.help	= "Write log of bandwidth during run",
 		.category = FIO_OPT_C_LOG,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "write_lat_log",
 		.lname	= "Write latency log",
 		.type	= FIO_OPT_STR,
 		.off1	= offsetof(struct thread_options, lat_log_file),
 		.cb	= str_write_lat_log_cb,
 		.help	= "Write log of latency during run",
 		.category = FIO_OPT_C_LOG,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "write_iops_log",
 		.lname	= "Write IOPS log",
 		.type	= FIO_OPT_STR,
 		.off1	= offsetof(struct thread_options, iops_log_file),
 		.cb	= str_write_iops_log_cb,
 		.help	= "Write log of IOPS during run",
 		.category = FIO_OPT_C_LOG,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "log_avg_msec",
 		.lname	= "Log averaging (msec)",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, log_avg_msec),
 		.help	= "Average bw/iops/lat logs over this period of time",
 		.def	= "0",
 		.category = FIO_OPT_C_LOG,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "log_hist_msec",
 		.lname	= "Log histograms (msec)",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, log_hist_msec),
 		.help	= "Dump completion latency histograms at frequency of this time value",
 		.def	= "0",
 		.category = FIO_OPT_C_LOG,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "log_hist_coarseness",
 		.lname	= "Histogram logs coarseness",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, log_hist_coarseness),
 		.help	= "Integer in range [0,6]. Higher coarseness outputs"
 			" fewer histogram bins per sample. The number of bins for"
 			" these are [1216, 608, 304, 152, 76, 38, 19] respectively.",
 		.def	= "0",
 		.category = FIO_OPT_C_LOG,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "write_hist_log",
 		.lname	= "Write latency histogram logs",
 		.type	= FIO_OPT_STR,
 		.off1	= offsetof(struct thread_options, hist_log_file),
 		.cb	= str_write_hist_log_cb,
 		.help	= "Write log of latency histograms during run",
 		.category = FIO_OPT_C_LOG,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "log_max_value",
 		.lname	= "Log maximum instead of average",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, log_max),
 		.help	= "Log max sample in a window instead of average",
 		.def	= "0",
 		.category = FIO_OPT_C_LOG,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "log_offset",
 		.lname	= "Log offset of IO",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, log_offset),
 		.help	= "Include offset of IO for each log entry",
 		.def	= "0",
 		.category = FIO_OPT_C_LOG,
 		.group	= FIO_OPT_G_INVALID,
 	},
 #ifdef CONFIG_ZLIB
 	{
 		.name	= "log_compression",
 		.lname	= "Log compression",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, log_gz),
 		.help	= "Log in compressed chunks of this size",
 		.minval	= 1024ULL,
 		.maxval	= 512 * 1024 * 1024ULL,
 		.category = FIO_OPT_C_LOG,
 		.group	= FIO_OPT_G_INVALID,
 	},
 #ifdef FIO_HAVE_CPU_AFFINITY
 	{
 		.name	= "log_compression_cpus",
 		.lname	= "Log Compression CPUs",
 		.type	= FIO_OPT_STR,
 		.cb	= str_log_cpus_allowed_cb,
 		.off1	= offsetof(struct thread_options, log_gz_cpumask),
 		.parent = "log_compression",
 		.help	= "Limit log compression to these CPUs",
 		.category = FIO_OPT_C_LOG,
 		.group	= FIO_OPT_G_INVALID,
 	},
 #else
 	{
 		.name	= "log_compression_cpus",
 		.lname	= "Log Compression CPUs",
 		.type	= FIO_OPT_UNSUPPORTED,
 		.help	= "Your platform does not support CPU affinities",
 	},
 #endif
 	{
 		.name	= "log_store_compressed",
 		.lname	= "Log store compressed",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, log_gz_store),
 		.help	= "Store logs in a compressed format",
 		.category = FIO_OPT_C_LOG,
 		.group	= FIO_OPT_G_INVALID,
 	},
 #else
 	{
 		.name	= "log_compression",
 		.lname	= "Log compression",
 		.type	= FIO_OPT_UNSUPPORTED,
 		.help	= "Install libz-dev(el) to get compression support",
 	},
 	{
 		.name	= "log_store_compressed",
 		.lname	= "Log store compressed",
 		.type	= FIO_OPT_UNSUPPORTED,
 		.help	= "Install libz-dev(el) to get compression support",
 	},
 #endif
 	{
 		.name = "log_unix_epoch",
 		.lname = "Log epoch unix",
 		.type = FIO_OPT_BOOL,
 		.off1 = offsetof(struct thread_options, log_unix_epoch),
 		.help = "Use Unix time in log files",
 		.category = FIO_OPT_C_LOG,
 		.group = FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "block_error_percentiles",
 		.lname	= "Block error percentiles",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, block_error_hist),
 		.help	= "Record trim block errors and make a histogram",
 		.def	= "0",
 		.category = FIO_OPT_C_LOG,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "bwavgtime",
 		.lname	= "Bandwidth average time",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, bw_avg_time),
 		.help	= "Time window over which to calculate bandwidth"
 			  " (msec)",
 		.def	= "500",
 		.parent	= "write_bw_log",
 		.hide	= 1,
 		.interval = 100,
 		.category = FIO_OPT_C_LOG,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "iopsavgtime",
 		.lname	= "IOPS average time",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, iops_avg_time),
 		.help	= "Time window over which to calculate IOPS (msec)",
 		.def	= "500",
 		.parent	= "write_iops_log",
 		.hide	= 1,
 		.interval = 100,
 		.category = FIO_OPT_C_LOG,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "group_reporting",
 		.lname	= "Group reporting",
 		.type	= FIO_OPT_STR_SET,
 		.off1	= offsetof(struct thread_options, group_reporting),
 		.help	= "Do reporting on a per-group basis",
 		.category = FIO_OPT_C_STAT,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "stats",
 		.lname	= "Stats",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, stats),
 		.help	= "Enable collection of stats",
 		.def	= "1",
 		.category = FIO_OPT_C_STAT,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "zero_buffers",
 		.lname	= "Zero I/O buffers",
 		.type	= FIO_OPT_STR_SET,
 		.off1	= offsetof(struct thread_options, zero_buffers),
 		.help	= "Init IO buffers to all zeroes",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IO_BUF,
 	},
 	{
 		.name	= "refill_buffers",
 		.lname	= "Refill I/O buffers",
 		.type	= FIO_OPT_STR_SET,
 		.off1	= offsetof(struct thread_options, refill_buffers),
 		.help	= "Refill IO buffers on every IO submit",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IO_BUF,
 	},
 	{
 		.name	= "scramble_buffers",
 		.lname	= "Scramble I/O buffers",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, scramble_buffers),
 		.help	= "Slightly scramble buffers on every IO submit",
 		.def	= "1",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IO_BUF,
 	},
 	{
 		.name	= "buffer_pattern",
 		.lname	= "Buffer pattern",
 		.type	= FIO_OPT_STR,
 		.cb	= str_buffer_pattern_cb,
 		.off1	= offsetof(struct thread_options, buffer_pattern),
 		.help	= "Fill pattern for IO buffers",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IO_BUF,
 	},
 	{
 		.name	= "buffer_compress_percentage",
 		.lname	= "Buffer compression percentage",
 		.type	= FIO_OPT_INT,
 		.cb	= str_buffer_compress_cb,
 		.off1	= offsetof(struct thread_options, compress_percentage),
 		.maxval	= 100,
 		.minval	= 0,
 		.help	= "How compressible the buffer is (approximately)",
 		.interval = 5,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IO_BUF,
 	},
 	{
 		.name	= "buffer_compress_chunk",
 		.lname	= "Buffer compression chunk size",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, compress_chunk),
 		.parent	= "buffer_compress_percentage",
 		.hide	= 1,
 		.help	= "Size of compressible region in buffer",
 		.def	= "512",
 		.interval = 256,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IO_BUF,
 	},
 	{
 		.name	= "dedupe_percentage",
 		.lname	= "Dedupe percentage",
 		.type	= FIO_OPT_INT,
 		.cb	= str_dedupe_cb,
 		.off1	= offsetof(struct thread_options, dedupe_percentage),
 		.maxval	= 100,
 		.minval	= 0,
 		.help	= "Percentage of buffers that are dedupable",
 		.interval = 1,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IO_BUF,
 	},
 	{
 		.name	= "clat_percentiles",
 		.lname	= "Completion latency percentiles",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, clat_percentiles),
 		.help	= "Enable the reporting of completion latency percentiles",
 		.def	= "1",
 		.category = FIO_OPT_C_STAT,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "lat_percentiles",
 		.lname	= "IO latency percentiles",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, lat_percentiles),
 		.help	= "Enable the reporting of IO latency percentiles",
 		.def	= "0",
 		.category = FIO_OPT_C_STAT,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "slat_percentiles",
 		.lname	= "Submission latency percentiles",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, slat_percentiles),
 		.help	= "Enable the reporting of submission latency percentiles",
 		.def	= "0",
 		.category = FIO_OPT_C_STAT,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "percentile_list",
 		.lname	= "Percentile list",
 		.type	= FIO_OPT_FLOAT_LIST,
 		.off1	= offsetof(struct thread_options, percentile_list),
 		.off2	= offsetof(struct thread_options, percentile_precision),
 		.help	= "Specify a custom list of percentiles to report for "
 			  "completion latency and block errors",
 		.def    = "1:5:10:20:30:40:50:60:70:80:90:95:99:99.5:99.9:99.95:99.99",
 		.maxlen	= FIO_IO_U_LIST_MAX_LEN,
 		.minfp	= 0.0,
 		.maxfp	= 100.0,
 		.category = FIO_OPT_C_STAT,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "significant_figures",
 		.lname	= "Significant figures",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, sig_figs),
 		.maxval	= 10,
 		.minval	= 1,
 		.help	= "Significant figures for output-format set to normal",
 		.def	= "4",
 		.interval = 1,
 		.category = FIO_OPT_C_STAT,
 		.group	= FIO_OPT_G_INVALID,
 	},
 
 #ifdef FIO_HAVE_DISK_UTIL
 	{
 		.name	= "disk_util",
 		.lname	= "Disk utilization",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, do_disk_util),
 		.help	= "Log disk utilization statistics",
 		.def	= "1",
 		.category = FIO_OPT_C_STAT,
 		.group	= FIO_OPT_G_INVALID,
 	},
 #else
 	{
 		.name	= "disk_util",
 		.lname	= "Disk utilization",
 		.type	= FIO_OPT_UNSUPPORTED,
 		.help	= "Your platform does not support disk utilization",
 	},
 #endif
 	{
 		.name	= "gtod_reduce",
 		.lname	= "Reduce gettimeofday() calls",
 		.type	= FIO_OPT_BOOL,
 		.help	= "Greatly reduce number of gettimeofday() calls",
 		.cb	= str_gtod_reduce_cb,
 		.def	= "0",
 		.hide_on_set = 1,
 		.category = FIO_OPT_C_STAT,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "disable_lat",
 		.lname	= "Disable all latency stats",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, disable_lat),
 		.help	= "Disable latency numbers",
 		.parent	= "gtod_reduce",
 		.hide	= 1,
 		.def	= "0",
 		.category = FIO_OPT_C_STAT,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "disable_clat",
 		.lname	= "Disable completion latency stats",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, disable_clat),
 		.help	= "Disable completion latency numbers",
 		.parent	= "gtod_reduce",
 		.hide	= 1,
 		.def	= "0",
 		.category = FIO_OPT_C_STAT,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "disable_slat",
 		.lname	= "Disable submission latency stats",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, disable_slat),
 		.help	= "Disable submission latency numbers",
 		.parent	= "gtod_reduce",
 		.hide	= 1,
 		.def	= "0",
 		.category = FIO_OPT_C_STAT,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "disable_bw_measurement",
 		.alias	= "disable_bw",
 		.lname	= "Disable bandwidth stats",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, disable_bw),
 		.help	= "Disable bandwidth logging",
 		.parent	= "gtod_reduce",
 		.hide	= 1,
 		.def	= "0",
 		.category = FIO_OPT_C_STAT,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "gtod_cpu",
 		.lname	= "Dedicated gettimeofday() CPU",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, gtod_cpu),
 		.help	= "Set up dedicated gettimeofday() thread on this CPU",
 		.verify	= gtod_cpu_verify,
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_CLOCK,
 	},
 	{
 		.name	= "unified_rw_reporting",
 		.lname	= "Unified RW Reporting",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, unified_rw_rep),
 		.help	= "Unify reporting across data direction",
 		.def	= "0",
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "continue_on_error",
 		.lname	= "Continue on error",
 		.type	= FIO_OPT_STR,
 		.off1	= offsetof(struct thread_options, continue_on_error),
 		.help	= "Continue on non-fatal errors during IO",
 		.def	= "none",
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_ERR,
 		.posval = {
 			  { .ival = "none",
 			    .oval = ERROR_TYPE_NONE,
 			    .help = "Exit when an error is encountered",
 			  },
 			  { .ival = "read",
 			    .oval = ERROR_TYPE_READ,
 			    .help = "Continue on read errors only",
 			  },
 			  { .ival = "write",
 			    .oval = ERROR_TYPE_WRITE,
 			    .help = "Continue on write errors only",
 			  },
 			  { .ival = "io",
 			    .oval = ERROR_TYPE_READ | ERROR_TYPE_WRITE,
 			    .help = "Continue on any IO errors",
 			  },
 			  { .ival = "verify",
 			    .oval = ERROR_TYPE_VERIFY,
 			    .help = "Continue on verify errors only",
 			  },
 			  { .ival = "all",
 			    .oval = ERROR_TYPE_ANY,
 			    .help = "Continue on all io and verify errors",
 			  },
 			  { .ival = "0",
 			    .oval = ERROR_TYPE_NONE,
 			    .help = "Alias for 'none'",
 			  },
 			  { .ival = "1",
 			    .oval = ERROR_TYPE_ANY,
 			    .help = "Alias for 'all'",
 			  },
 		},
 	},
 	{
 		.name	= "ignore_error",
 		.lname	= "Ignore Error",
 		.type	= FIO_OPT_STR,
 		.cb	= str_ignore_error_cb,
 		.off1	= offsetof(struct thread_options, ignore_error_nr),
 		.help	= "Set a specific list of errors to ignore",
 		.parent	= "rw",
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_ERR,
 	},
 	{
 		.name	= "error_dump",
 		.lname	= "Error Dump",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, error_dump),
 		.def	= "0",
 		.help	= "Dump info on each error",
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_ERR,
 	},
 	{
 		.name	= "profile",
 		.lname	= "Profile",
 		.type	= FIO_OPT_STR_STORE,
 		.off1	= offsetof(struct thread_options, profile),
 		.help	= "Select a specific builtin performance test",
 		.category = FIO_OPT_C_PROFILE,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "cgroup",
 		.lname	= "Cgroup",
 		.type	= FIO_OPT_STR_STORE,
 		.off1	= offsetof(struct thread_options, cgroup),
 		.help	= "Add job to cgroup of this name",
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_CGROUP,
 	},
 	{
 		.name	= "cgroup_nodelete",
 		.lname	= "Cgroup no-delete",
 		.type	= FIO_OPT_BOOL,
 		.off1	= offsetof(struct thread_options, cgroup_nodelete),
 		.help	= "Do not delete cgroups after job completion",
 		.def	= "0",
 		.parent	= "cgroup",
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_CGROUP,
 	},
 	{
 		.name	= "cgroup_weight",
 		.lname	= "Cgroup weight",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, cgroup_weight),
 		.help	= "Use given weight for cgroup",
 		.minval = 100,
 		.maxval	= 1000,
 		.parent	= "cgroup",
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_CGROUP,
 	},
 	{
 		.name	= "uid",
 		.lname	= "User ID",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, uid),
 		.help	= "Run job with this user ID",
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_CRED,
 	},
 	{
 		.name	= "gid",
 		.lname	= "Group ID",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, gid),
 		.help	= "Run job with this group ID",
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_CRED,
 	},
 	{
 		.name	= "kb_base",
 		.lname	= "KB Base",
 		.type	= FIO_OPT_STR,
 		.off1	= offsetof(struct thread_options, kb_base),
 		.prio	= 1,
 		.def	= "1024",
 		.posval = {
 			  { .ival = "1024",
 			    .oval = 1024,
 			    .help = "Inputs invert IEC and SI prefixes (for compatibility); outputs prefer binary",
 			  },
 			  { .ival = "1000",
 			    .oval = 1000,
 			    .help = "Inputs use IEC and SI prefixes; outputs prefer SI",
 			  },
 		},
 		.help	= "Unit prefix interpretation for quantities of data (IEC and SI)",
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "unit_base",
 		.lname	= "Unit for quantities of data (Bits or Bytes)",
 		.type	= FIO_OPT_STR,
 		.off1	= offsetof(struct thread_options, unit_base),
 		.prio	= 1,
 		.posval = {
 			  { .ival = "0",
 			    .oval = N2S_NONE,
 			    .help = "Auto-detect",
 			  },
 			  { .ival = "8",
 			    .oval = N2S_BYTEPERSEC,
 			    .help = "Normal (byte based)",
 			  },
 			  { .ival = "1",
 			    .oval = N2S_BITPERSEC,
 			    .help = "Bit based",
 			  },
 		},
 		.help	= "Bit multiple of result summary data (8 for byte, 1 for bit)",
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "hugepage-size",
 		.lname	= "Hugepage size",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, hugepage_size),
 		.help	= "When using hugepages, specify size of each page",
 		.def	= __fio_stringify(FIO_HUGE_PAGE),
 		.interval = 1024 * 1024,
 		.category = FIO_OPT_C_GENERAL,
 		.group	= FIO_OPT_G_INVALID,
 	},
 	{
 		.name	= "flow_id",
 		.lname	= "I/O flow ID",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, flow_id),
 		.help	= "The flow index ID to use",
 		.def	= "0",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IO_FLOW,
 	},
 	{
 		.name	= "flow",
 		.lname	= "I/O flow weight",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, flow),
 		.help	= "Weight for flow control of this job",
 		.parent	= "flow_id",
 		.hide	= 1,
 		.def	= "0",
 		.maxval	= FLOW_MAX_WEIGHT,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IO_FLOW,
 	},
 	{
 		.name	= "flow_watermark",
 		.lname	= "I/O flow watermark",
 		.type	= FIO_OPT_SOFT_DEPRECATED,
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IO_FLOW,
 	},
 	{
 		.name	= "flow_sleep",
 		.lname	= "I/O flow sleep",
 		.type	= FIO_OPT_INT,
 		.off1	= offsetof(struct thread_options, flow_sleep),
 		.help	= "How many microseconds to sleep after being held"
 			" back by the flow control mechanism",
 		.parent	= "flow_id",
 		.hide	= 1,
 		.def	= "0",
 		.category = FIO_OPT_C_IO,
 		.group	= FIO_OPT_G_IO_FLOW,
 	},
 	{
 		.name   = "steadystate",
 		.lname  = "Steady state threshold",
 		.alias  = "ss",
 		.type   = FIO_OPT_STR,
 		.off1   = offsetof(struct thread_options, ss_state),
 		.cb	= str_steadystate_cb,
 		.help   = "Define the criterion and limit to judge when a job has reached steady state",
 		.def	= "iops_slope:0.01%",
 		.posval	= {
 			  { .ival = "iops",
 			    .oval = FIO_SS_IOPS,
 			    .help = "maximum mean deviation of IOPS measurements",
 			  },
 			  { .ival = "iops_slope",
 			    .oval = FIO_SS_IOPS_SLOPE,
 			    .help = "slope calculated from IOPS measurements",
 			  },
 			  { .ival = "bw",
 			    .oval = FIO_SS_BW,
 			    .help = "maximum mean deviation of bandwidth measurements",
 			  },
 			  {
 			    .ival = "bw_slope",
 			    .oval = FIO_SS_BW_SLOPE,
 			    .help = "slope calculated from bandwidth measurements",
 			  },
 		},
 		.category = FIO_OPT_C_GENERAL,
 		.group  = FIO_OPT_G_RUNTIME,
 	},
         {
 		.name   = "steadystate_duration",
 		.lname  = "Steady state duration",
 		.alias  = "ss_dur",
 		.parent	= "steadystate",
 		.type   = FIO_OPT_STR_VAL_TIME,
 		.off1   = offsetof(struct thread_options, ss_dur),
 		.help   = "Stop workload upon attaining steady state for specified duration",
 		.def    = "0",
 		.is_seconds = 1,
 		.is_time = 1,
 		.category = FIO_OPT_C_GENERAL,
 		.group  = FIO_OPT_G_RUNTIME,
 	},
         {
 		.name   = "steadystate_ramp_time",
 		.lname  = "Steady state ramp time",
 		.alias  = "ss_ramp",
 		.parent	= "steadystate",
 		.type   = FIO_OPT_STR_VAL_TIME,
 		.off1   = offsetof(struct thread_options, ss_ramp_time),
 		.help   = "Delay before initiation of data collection for steady state job termination testing",
 		.def    = "0",
 		.is_seconds = 1,
 		.is_time = 1,
 		.category = FIO_OPT_C_GENERAL,
 		.group  = FIO_OPT_G_RUNTIME,
 	},
 	{
 		.name = NULL,
 	},
 };
diff --git a/parse.c b/parse.c
index c28d82ef..44bf9507 100644
--- a/parse.c
+++ b/parse.c
@@ -540,427 +540,432 @@ static bool val_too_small(const struct fio_option *o, unsigned long long val,
 static int __handle_option(const struct fio_option *o, const char *ptr,
 			   void *data, int first, int more, int curr)
 {
 	int il=0, *ilp;
 	fio_fp64_t *flp;
 	long long ull, *ullp;
 	long ul2;
 	long long ull1, ull2;
 	double uf;
 	char **cp = NULL;
 	int ret = 0, is_time = 0;
 	const struct value_pair *vp;
 	struct value_pair posval[PARSE_MAX_VP];
 	int i, all_skipped = 1;
 
 	dprint(FD_PARSE, "__handle_option=%s, type=%s, ptr=%s\n", o->name,
 							opt_type_name(o), ptr);
 
 	if (!ptr && o->type != FIO_OPT_STR_SET && o->type != FIO_OPT_STR) {
 		log_err("Option %s requires an argument\n", o->name);
 		return 1;
 	}
 
 	switch (o->type) {
 	case FIO_OPT_STR:
 	case FIO_OPT_STR_ULL:
 	case FIO_OPT_STR_MULTI: {
 		fio_opt_str_fn *fn = o->cb;
 
 		posval_sort(o, posval);
 
 		ret = 1;
 		for (i = 0; i < PARSE_MAX_VP; i++) {
 			vp = &posval[i];
 			if (!vp->ival || vp->ival[0] == '\0')
 				continue;
 			all_skipped = 0;
 			if (!ptr)
 				break;
 			if (!strncmp(vp->ival, ptr, str_match_len(vp, ptr))) {
 				ret = 0;
 				if (!o->off1)
 					continue;
 				if (o->type == FIO_OPT_STR_ULL)
 					val_store(ullp, vp->oval, o->off1, vp->orval, data, o);
 				else
 					val_store(ilp, vp->oval, o->off1, vp->orval, data, o);
 				continue;
 			}
 		}
 
 		if (ret && !all_skipped)
 			show_option_values(o);
 		else if (fn)
 			ret = fn(data, ptr);
 		break;
 	}
 	case FIO_OPT_STR_VAL_TIME:
 		is_time = 1;
 		fallthrough;
 	case FIO_OPT_ULL:
 	case FIO_OPT_INT:
 	case FIO_OPT_STR_VAL: {
 		fio_opt_str_val_fn *fn = o->cb;
 		char tmp[128], *p;
 
 		if (!is_time && o->is_time)
 			is_time = o->is_time;
 
 		snprintf(tmp, sizeof(tmp), "%s", ptr);
 		p = strchr(tmp, ',');
 		if (p)
 			*p = '\0';
 
 		if (is_time)
 			ret = check_str_time(tmp, &ull, o->is_seconds);
 		else
 			ret = check_str_bytes(tmp, &ull, data);
 
 		dprint(FD_PARSE, "  ret=%d, out=%llu\n", ret, ull);
 
 		if (ret)
 			break;
 		if (o->pow2 && !is_power_of_2(ull)) {
 			log_err("%s: must be a power-of-2\n", o->name);
 			return 1;
 		}
 
 		if (val_too_large(o, ull, o->type == FIO_OPT_INT)) {
 			log_err("%s: max value out of range: %llu"
 				" (%llu max)\n", o->name, ull, o->maxval);
 			return 1;
 		}
 		if (val_too_small(o, ull, o->type == FIO_OPT_INT)) {
 			log_err("%s: min value out of range: %lld"
 				" (%d min)\n", o->name, ull, o->minval);
 			return 1;
 		}
 		if (o->posval[0].ival) {
 			posval_sort(o, posval);
 
 			ret = 1;
 			for (i = 0; i < PARSE_MAX_VP; i++) {
 				vp = &posval[i];
 				if (!vp->ival || vp->ival[0] == '\0')
 					continue;
 				if (vp->oval == ull) {
 					ret = 0;
 					break;
 				}
 			}
 			if (ret) {
 				log_err("fio: value %llu not allowed:\n", ull);
 				show_option_values(o);
 				return 1;
 			}
 		}
 
 		if (fn)
 			ret = fn(data, &ull);
 		else {
 			if (o->type == FIO_OPT_INT) {
 				if (first)
 					val_store(ilp, ull, o->off1, 0, data, o);
 				if (curr == 1) {
 					if (o->off2)
 						val_store(ilp, ull, o->off2, 0, data, o);
 				}
 				if (curr == 2) {
 					if (o->off3)
 						val_store(ilp, ull, o->off3, 0, data, o);
 				}
 				if (!more) {
 					if (curr < 1) {
 						if (o->off2)
 							val_store(ilp, ull, o->off2, 0, data, o);
 					}
 					if (curr < 2) {
 						if (o->off3)
 							val_store(ilp, ull, o->off3, 0, data, o);
 					}
 				}
 			} else if (o->type == FIO_OPT_ULL) {
 				if (first)
 					val_store(ullp, ull, o->off1, 0, data, o);
 				if (curr == 1) {
 					if (o->off2)
 						val_store(ullp, ull, o->off2, 0, data, o);
 				}
 				if (curr == 2) {
 					if (o->off3)
 						val_store(ullp, ull, o->off3, 0, data, o);
 				}
 				if (!more) {
 					if (curr < 1) {
 						if (o->off2)
 							val_store(ullp, ull, o->off2, 0, data, o);
 					}
 					if (curr < 2) {
 						if (o->off3)
 							val_store(ullp, ull, o->off3, 0, data, o);
 					}
 				}
 			} else {
 				if (first)
 					val_store(ullp, ull, o->off1, 0, data, o);
 				if (!more) {
 					if (o->off2)
 						val_store(ullp, ull, o->off2, 0, data, o);
 				}
 			}
 		}
 		break;
 	}
 	case FIO_OPT_FLOAT_LIST: {
 		char *cp2;
 
 		if (first) {
 			/*
 			** Initialize precision to 0 and zero out list
 			** in case specified list is shorter than default
 			*/
 			if (o->off2) {
 				ul2 = 0;
 				ilp = td_var(data, o, o->off2);
 				*ilp = ul2;
 			}
 
 			flp = td_var(data, o, o->off1);
 			for(i = 0; i < o->maxlen; i++)
 				flp[i].u.f = 0.0;
 		}
 		if (curr >= o->maxlen) {
 			log_err("the list exceeding max length %d\n",
 					o->maxlen);
 			return 1;
 		}
 		if (!str_to_float(ptr, &uf, 0)) { /* this breaks if we ever have lists of times */
 			log_err("not a floating point value: %s\n", ptr);
 			return 1;
 		}
 		if (o->minfp || o->maxfp) {
 			if (uf > o->maxfp) {
 				log_err("value out of range: %f"
 					" (range max: %f)\n", uf, o->maxfp);
 				return 1;
 			}
 			if (uf < o->minfp) {
 				log_err("value out of range: %f"
 					" (range min: %f)\n", uf, o->minfp);
 				return 1;
 			}
 		}
 
 		flp = td_var(data, o, o->off1);
 		flp[curr].u.f = uf;
 
 		dprint(FD_PARSE, "  out=%f\n", uf);
 
 		/*
 		** Calculate precision for output by counting
 		** number of digits after period. Find first
 		** period in entire remaining list each time
 		*/
 		cp2 = strchr(ptr, '.');
 		if (cp2 != NULL) {
 			int len = 0;
 
 			while (*++cp2 != '\0' && *cp2 >= '0' && *cp2 <= '9')
 				len++;
 
 			if (o->off2) {
 				ilp = td_var(data, o, o->off2);
 				if (len > *ilp)
 					*ilp = len;
 			}
 		}
 
 		break;
 	}
 	case FIO_OPT_STR_STORE: {
 		fio_opt_str_fn *fn = o->cb;
 
 		if (!strlen(ptr))
 			return 1;
 
 		if (o->off1) {
 			cp = td_var(data, o, o->off1);
 			*cp = strdup(ptr);
+			if (strlen(ptr) > o->maxlen - 1) {
+				log_err("value exceeds max length of %d\n",
+					o->maxlen);
+				return 1;
+			}
 		}
 
 		if (fn)
 			ret = fn(data, ptr);
 		else if (o->posval[0].ival) {
 			posval_sort(o, posval);
 
 			ret = 1;
 			for (i = 0; i < PARSE_MAX_VP; i++) {
 				vp = &posval[i];
 				if (!vp->ival || vp->ival[0] == '\0' || !cp)
 					continue;
 				all_skipped = 0;
 				if (!strncmp(vp->ival, ptr, str_match_len(vp, ptr))) {
 					char *rest;
 
 					ret = 0;
 					if (vp->cb)
 						fn = vp->cb;
 					rest = strstr(*cp ?: ptr, ":");
 					if (rest) {
 						if (*cp)
 							*rest = '\0';
 						ptr = rest + 1;
 					} else
 						ptr = NULL;
 					break;
 				}
 			}
 		}
 
 		if (!all_skipped) {
 			if (ret && !*cp)
 				show_option_values(o);
 			else if (ret && *cp)
 				ret = 0;
 			else if (fn && ptr)
 				ret = fn(data, ptr);
 		}
 
 		break;
 	}
 	case FIO_OPT_RANGE: {
 		char tmp[128];
 		char *p1, *p2;
 
 		snprintf(tmp, sizeof(tmp), "%s", ptr);
 
 		/* Handle bsrange with separate read,write values: */
 		p1 = strchr(tmp, ',');
 		if (p1)
 			*p1 = '\0';
 
 		p1 = strchr(tmp, '-');
 		if (!p1) {
 			p1 = strchr(tmp, ':');
 			if (!p1) {
 				ret = 1;
 				break;
 			}
 		}
 
 		p2 = p1 + 1;
 		*p1 = '\0';
 		p1 = tmp;
 
 		ret = 1;
 		if (!check_range_bytes(p1, &ull1, data) &&
 			!check_range_bytes(p2, &ull2, data)) {
 			ret = 0;
 			if (ull1 > ull2) {
 				unsigned long long foo = ull1;
 
 				ull1 = ull2;
 				ull2 = foo;
 			}
 
 			if (first) {
 				val_store(ullp, ull1, o->off1, 0, data, o);
 				val_store(ullp, ull2, o->off2, 0, data, o);
 			}
 			if (curr == 1) {
 				if (o->off3 && o->off4) {
 					val_store(ullp, ull1, o->off3, 0, data, o);
 					val_store(ullp, ull2, o->off4, 0, data, o);
 				}
 			}
 			if (curr == 2) {
 				if (o->off5 && o->off6) {
 					val_store(ullp, ull1, o->off5, 0, data, o);
 					val_store(ullp, ull2, o->off6, 0, data, o);
 				}
 			}
 			if (!more) {
 				if (curr < 1) {
 					if (o->off3 && o->off4) {
 						val_store(ullp, ull1, o->off3, 0, data, o);
 						val_store(ullp, ull2, o->off4, 0, data, o);
 					}
 				}
 				if (curr < 2) {
 					if (o->off5 && o->off6) {
 						val_store(ullp, ull1, o->off5, 0, data, o);
 						val_store(ullp, ull2, o->off6, 0, data, o);
 					}
 				}
 			}
 		}
 
 		break;
 	}
 	case FIO_OPT_BOOL:
 	case FIO_OPT_STR_SET: {
 		fio_opt_int_fn *fn = o->cb;
 
 		if (ptr)
 			ret = check_int(ptr, &il);
 		else if (o->type == FIO_OPT_BOOL)
 			ret = 1;
 		else
 			il = 1;
 
 		dprint(FD_PARSE, "  ret=%d, out=%d\n", ret, il);
 
 		if (ret)
 			break;
 
 		if (o->maxval && il > (int) o->maxval) {
 			log_err("max value out of range: %d (%llu max)\n",
 								il, o->maxval);
 			return 1;
 		}
 		if (o->minval && il < o->minval) {
 			log_err("min value out of range: %d (%d min)\n",
 								il, o->minval);
 			return 1;
 		}
 
 		if (o->neg)
 			il = !il;
 
 		if (fn)
 			ret = fn(data, &il);
 		else {
 			if (first)
 				val_store(ilp, il, o->off1, 0, data, o);
 			if (!more) {
 				if (o->off2)
 					val_store(ilp, il, o->off2, 0, data, o);
 			}
 		}
 		break;
 	}
 	case FIO_OPT_DEPRECATED:
 		ret = 1;
 		fallthrough;
 	case FIO_OPT_SOFT_DEPRECATED:
 		log_info("Option %s is deprecated\n", o->name);
 		break;
 	default:
 		log_err("Bad option type %u\n", o->type);
 		ret = 1;
 	}
 
 	if (ret)
 		return ret;
 
 	if (o->verify) {
 		ret = o->verify(o, data);
 		if (ret) {
 			log_err("Correct format for offending option\n");
 			log_err("%20s: %s\n", o->name, o->help);
 			show_option_help(o, 1);
 		}
 	}
 
 	return ret;
 }
