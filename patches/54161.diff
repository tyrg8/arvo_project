commit d8440f4d711a654b511f50f79c0445b26f9dd1e1
Author: Nanang Izzuddin <nanang@teluu.com>
Date:   Tue Dec 20 11:39:12 2022 +0700

    Merge pull request from GHSA-9pfh-r8x4-w26w
    
    * Fix buffer overread in STUN message decoder
    
    * Updates based on comments

diff --git a/pjnath/include/pjnath/stun_msg.h b/pjnath/include/pjnath/stun_msg.h
index b52f95c58..e49f096f3 100644
--- a/pjnath/include/pjnath/stun_msg.h
+++ b/pjnath/include/pjnath/stun_msg.h
@@ -442,94 +442,98 @@ typedef enum pj_stun_status
 
    \endverbatim
  */
+#pragma pack(1)
 typedef struct pj_stun_msg_hdr
 {
     /**
      * STUN message type, which the first two bits must be zeroes.
      */
     pj_uint16_t         type;
 
     /**
      * The message length is the size, in bytes, of the message not
      * including the 20 byte STUN header.
      */
     pj_uint16_t         length;
 
     /**
      * The magic cookie is a fixed value, 0x2112A442 (PJ_STUN_MAGIC constant).
      * In the previous version of this specification [15] this field was part 
      * of the transaction ID.
      */
     pj_uint32_t         magic;
 
     /**
      * The transaction ID is a 96 bit identifier.  STUN transactions are
      * identified by their unique 96-bit transaction ID.  For request/
      * response transactions, the transaction ID is chosen by the STUN
      * client and MUST be unique for each new STUN transaction generated by
      * that STUN client.  The transaction ID MUST be uniformly and randomly
      * distributed between 0 and 2**96 - 1. 
      */
     pj_uint8_t          tsx_id[12];
 
 } pj_stun_msg_hdr;
+#pragma pack()
 
 
 /**
  * This structre describes STUN attribute header. Each attribute is
  * TLV encoded, with a 16 bit type, 16 bit length, and variable value.
  * Each STUN attribute ends on a 32 bit boundary:
  *
  * \verbatim
 
         0                   1                   2                   3
         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |         Type                  |            Length             |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 
    \endverbatim
  */
+#pragma pack(1)
 typedef struct pj_stun_attr_hdr
 {
     /**
      * STUN attribute type.
      */
     pj_uint16_t         type;
 
     /**
      * The Length refers to the length of the actual useful content of the
      * Value portion of the attribute, measured in bytes. The value
      * in the Length field refers to the length of the Value part of the
      * attribute prior to padding - i.e., the useful content.
      */
     pj_uint16_t         length;
 
 } pj_stun_attr_hdr;
+#pragma pack()
 
 
 /**
  * This structure describes STUN generic IP address attribute, used for
  * example to represent STUN MAPPED-ADDRESS attribute.
  *
  * The generic IP address attribute indicates the transport address.
  * It consists of an eight bit address family, and a sixteen bit port,
  * followed by a fixed length value representing the IP address.  If the
  * address family is IPv4, the address is 32 bits, in network byte
  * order.  If the address family is IPv6, the address is 128 bits in
  * network byte order.
  *
  * The format of the generic IP address attribute is:
  *
  * \verbatim
 
         0                   1                   2                   3
         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |x x x x x x x x|    Family     |           Port                |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |                   Address  (variable)
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 
    \endverbatim
  */
diff --git a/pjnath/src/pjnath/stun_msg.c b/pjnath/src/pjnath/stun_msg.c
index 3def6b3ea..e904a0ba4 100644
--- a/pjnath/src/pjnath/stun_msg.c
+++ b/pjnath/src/pjnath/stun_msg.c
@@ -733,20 +733,20 @@ PJ_DEF(pj_str_t) pj_stun_get_err_reason(int err_code)
 /*
  * Set padding character.
  */
 PJ_DEF(int) pj_stun_set_padding_char(int chr)
 {
     int old_pad = padding_char;
     padding_char = chr;
     return old_pad;
 }
 
 
 //////////////////////////////////////////////////////////////////////////////
 
 
 #define INIT_ATTR(a,t,l)    (a)->hdr.type=(pj_uint16_t)(t), \
                             (a)->hdr.length=(pj_uint16_t)(l)
-#define ATTR_HDR_LEN        4
+#define ATTR_HDR_LEN        sizeof(pj_stun_attr_hdr)
 
 static pj_uint16_t GETVAL16H(const pj_uint8_t *buf, unsigned pos)
 {
@@ -2297,258 +2297,266 @@ PJ_DEF(pj_status_t) pj_stun_msg_create_response(pj_pool_t *pool,
 /*
  * Parse incoming packet into STUN message.
  */
 PJ_DEF(pj_status_t) pj_stun_msg_decode(pj_pool_t *pool,
                                        const pj_uint8_t *pdu,
                                        pj_size_t pdu_len,
                                        unsigned options,
                                        pj_stun_msg **p_msg,
                                        pj_size_t *p_parsed_len,
                                        pj_stun_msg **p_response)
 {
     
     pj_stun_msg *msg;
     const pj_uint8_t *start_pdu = pdu;
     pj_bool_t has_msg_int = PJ_FALSE;
     pj_bool_t has_fingerprint = PJ_FALSE;
     pj_status_t status;
 
     PJ_UNUSED_ARG(options);
 
     PJ_ASSERT_RETURN(pool && pdu && pdu_len && p_msg, PJ_EINVAL);
     PJ_ASSERT_RETURN(sizeof(pj_stun_msg_hdr) == 20, PJ_EBUG);
 
     if (p_parsed_len)
         *p_parsed_len = 0;
     if (p_response)
         *p_response = NULL;
 
     /* Check if this is a STUN message, if necessary */
     if (options & PJ_STUN_CHECK_PACKET) {
         status = pj_stun_msg_check(pdu, pdu_len, options);
         if (status != PJ_SUCCESS)
             return status;
+    } else {
+        /* For safety, verify packet length at least */
+        pj_uint32_t msg_len = GETVAL16H(pdu, 2) + 20;
+        if (msg_len > pdu_len ||
+            ((options & PJ_STUN_IS_DATAGRAM) && msg_len != pdu_len))
+        {
+            return PJNATH_EINSTUNMSGLEN;
+        }
     }
 
     /* Create the message, copy the header, and convert to host byte order */
     msg = PJ_POOL_ZALLOC_T(pool, pj_stun_msg);
     pj_memcpy(&msg->hdr, pdu, sizeof(pj_stun_msg_hdr));
     msg->hdr.type = pj_ntohs(msg->hdr.type);
     msg->hdr.length = pj_ntohs(msg->hdr.length);
     msg->hdr.magic = pj_ntohl(msg->hdr.magic);
 
     pdu += sizeof(pj_stun_msg_hdr);
     /* pdu_len -= sizeof(pj_stun_msg_hdr); */
     pdu_len = msg->hdr.length;
 
     /* No need to create response if this is not a request */
     if (!PJ_STUN_IS_REQUEST(msg->hdr.type))
         p_response = NULL;
 
     /* Parse attributes */
-    while (pdu_len >= 4) {
+    while (pdu_len >= ATTR_HDR_LEN) {
         unsigned attr_type, attr_val_len;
         const struct attr_desc *adesc;
 
         /* Get attribute type and length. If length is not aligned
          * to 4 bytes boundary, add padding.
          */
         attr_type = GETVAL16H(pdu, 0);
         attr_val_len = GETVAL16H(pdu, 2);
         attr_val_len = (attr_val_len + 3) & (~3);
 
         /* Check length */
-        if (pdu_len < attr_val_len) {
+        if (pdu_len < attr_val_len + ATTR_HDR_LEN) {
             pj_str_t err_msg;
             char err_msg_buf[80];
 
             err_msg.ptr = err_msg_buf;
             err_msg.slen = pj_ansi_snprintf(err_msg_buf, sizeof(err_msg_buf),
                                             "Attribute %s has invalid length",
                                             pj_stun_get_attr_name(attr_type));
 
             PJ_LOG(4,(THIS_FILE, "Error decoding message: %.*s",
                       (int)err_msg.slen, err_msg.ptr));
 
             if (p_response) {
                 pj_stun_msg_create_response(pool, msg, 
                                             PJ_STUN_SC_BAD_REQUEST, 
                                             &err_msg, p_response);
             }
             return PJNATH_ESTUNINATTRLEN;
         }
 
         /* Get the attribute descriptor */
         adesc = find_attr_desc(attr_type);
 
         if (adesc == NULL) {
             /* Unrecognized attribute */
             pj_stun_binary_attr *attr = NULL;
 
             PJ_LOG(5,(THIS_FILE, "Unrecognized attribute type 0x%x", 
                       attr_type));
 
             /* Is this a fatal condition? */
             if (attr_type <= 0x7FFF) {
                 /* This is a mandatory attribute, we must return error
                  * if we don't understand the attribute.
                  */
                 if (p_response) {
                     unsigned err_code = PJ_STUN_SC_UNKNOWN_ATTRIBUTE;
 
                     status = pj_stun_msg_create_response(pool, msg,
                                                          err_code, NULL, 
                                                          p_response);
                     if (status==PJ_SUCCESS) {
                         pj_uint16_t d = (pj_uint16_t)attr_type;
                         pj_stun_msg_add_unknown_attr(pool, *p_response, 1, &d);
                     }
                 }
 
                 return PJ_STATUS_FROM_STUN_CODE(PJ_STUN_SC_UNKNOWN_ATTRIBUTE);
             }
 
             /* Make sure we have rooms for the new attribute */
             if (msg->attr_count >= PJ_STUN_MAX_ATTR) {
                 if (p_response) {
                     pj_stun_msg_create_response(pool, msg,
                                                 PJ_STUN_SC_SERVER_ERROR,
                                                 NULL, p_response);
                 }
                 return PJNATH_ESTUNTOOMANYATTR;
             }
 
             /* Create binary attribute to represent this */
             status = pj_stun_binary_attr_create(pool, attr_type, pdu+4, 
                                                 GETVAL16H(pdu, 2), &attr);
             if (status != PJ_SUCCESS) {
                 if (p_response) {
                     pj_stun_msg_create_response(pool, msg,
                                                 PJ_STUN_SC_SERVER_ERROR,
                                                 NULL, p_response);
                 }
 
                 PJ_LOG(4,(THIS_FILE, 
                           "Error parsing unknown STUN attribute type %d",
                           attr_type));
 
                 return status;
             }
 
             /* Add the attribute */
             msg->attr[msg->attr_count++] = &attr->hdr;
 
         } else {
             void *attr;
             char err_msg1[PJ_ERR_MSG_SIZE],
                  err_msg2[PJ_ERR_MSG_SIZE];
 
             /* Parse the attribute */
             status = (adesc->decode_attr)(pool, pdu, &msg->hdr, &attr);
 
             if (status != PJ_SUCCESS) {
                 pj_strerror(status, err_msg1, sizeof(err_msg1));
 
                 if (p_response) {
                     pj_str_t e;
 
                     e.ptr = err_msg2;
                     e.slen= pj_ansi_snprintf(err_msg2, sizeof(err_msg2),
                                              "%s in %s",
                                              err_msg1,
                                              pj_stun_get_attr_name(attr_type));
                     if (e.slen < 1 || e.slen >= (int)sizeof(err_msg2))
                         e.slen = sizeof(err_msg2) - 1;
                     pj_stun_msg_create_response(pool, msg,
                                                 PJ_STUN_SC_BAD_REQUEST,
                                                 &e, p_response);
                 }
 
                 PJ_LOG(4,(THIS_FILE, 
                           "Error parsing STUN attribute %s: %s",
                           pj_stun_get_attr_name(attr_type), 
                           err_msg1));
 
                 return status;
             }
 
             if (attr_type == PJ_STUN_ATTR_MESSAGE_INTEGRITY && 
                 !has_fingerprint) 
             {
                 if (has_msg_int) {
                     /* Already has MESSAGE-INTEGRITY */
                     if (p_response) {
                         pj_stun_msg_create_response(pool, msg,
                                                     PJ_STUN_SC_BAD_REQUEST,
                                                     NULL, p_response);
                     }
                     return PJNATH_ESTUNDUPATTR;
                 }
                 has_msg_int = PJ_TRUE;
 
             } else if (attr_type == PJ_STUN_ATTR_FINGERPRINT) {
                 if (has_fingerprint) {
                     /* Already has FINGERPRINT */
                     if (p_response) {
                         pj_stun_msg_create_response(pool, msg,
                                                     PJ_STUN_SC_BAD_REQUEST,
                                                     NULL, p_response);
                     }
                     return PJNATH_ESTUNDUPATTR;
                 }
                 has_fingerprint = PJ_TRUE;
             } else {
                 if (has_fingerprint) {
                     /* Another attribute is found which is not FINGERPRINT
                      * after FINGERPRINT. Note that non-FINGERPRINT is
                      * allowed to appear after M-I
                      */
                     if (p_response) {
                         pj_stun_msg_create_response(pool, msg,
                                                     PJ_STUN_SC_BAD_REQUEST,
                                                     NULL, p_response);
                     }
                     return PJNATH_ESTUNFINGERPOS;
                 }
             }
 
             /* Make sure we have rooms for the new attribute */
             if (msg->attr_count >= PJ_STUN_MAX_ATTR) {
                 if (p_response) {
                     pj_stun_msg_create_response(pool, msg,
                                                 PJ_STUN_SC_SERVER_ERROR,
                                                 NULL, p_response);
                 }
                 return PJNATH_ESTUNTOOMANYATTR;
             }
 
             /* Add the attribute */
             msg->attr[msg->attr_count++] = (pj_stun_attr_hdr*)attr;
         }
 
         /* Next attribute */
         if (attr_val_len + 4 >= pdu_len) {
             pdu += pdu_len;
             pdu_len = 0;
         } else {
             pdu += (attr_val_len + 4);
             pdu_len -= (attr_val_len + 4);
         }
     }
 
     if (pdu_len > 0) {
         /* Stray trailing bytes */
         PJ_LOG(4,(THIS_FILE, 
                   "Error decoding STUN message: unparsed trailing %d bytes",
                   pdu_len));
         return PJNATH_EINSTUNMSGLEN;
     }
 
     *p_msg = msg;
 
     if (p_parsed_len)
         *p_parsed_len = (pdu - start_pdu);
 
     return PJ_SUCCESS;
 }
 
 /*
