commit 27231c3f5283458908ad912fbf8a302875fe2928
Merge: 8d6d6b48c 4caba7de8
Author: Kim Kulling <kimkulling@users.noreply.github.com>
Date:   Mon Aug 16 20:48:17 2021 +0200

    Merge branch 'master' into bound

diff --git a/code/AssetLib/3DS/3DSExporter.cpp b/code/AssetLib/3DS/3DSExporter.cpp
index 92a6d5aa7..0beecd563 100644
--- a/code/AssetLib/3DS/3DSExporter.cpp
+++ b/code/AssetLib/3DS/3DSExporter.cpp
@@ -272,98 +272,98 @@ int Discreet3DSExporter::WriteHierarchy(const aiNode &node, int seq, int sibling
 // ------------------------------------------------------------------------------------------------
 void Discreet3DSExporter::WriteMaterials() {
     for (unsigned int i = 0; i < scene->mNumMaterials; ++i) {
         ChunkWriter curRootChunk(writer, Discreet3DS::CHUNK_MAT_MATERIAL);
         const aiMaterial &mat = *scene->mMaterials[i];
 
         {
             ChunkWriter chunk(writer, Discreet3DS::CHUNK_MAT_MATNAME);
             const std::string &name = GetMaterialName(mat, i);
             WriteString(name);
         }
 
         aiColor3D color;
         if (mat.Get(AI_MATKEY_COLOR_DIFFUSE, color) == AI_SUCCESS) {
             ChunkWriter curChunk(writer, Discreet3DS::CHUNK_MAT_DIFFUSE);
             WriteColor(color);
         }
 
         if (mat.Get(AI_MATKEY_COLOR_SPECULAR, color) == AI_SUCCESS) {
             ChunkWriter curChunk(writer, Discreet3DS::CHUNK_MAT_SPECULAR);
             WriteColor(color);
         }
-                
+
         if (mat.Get(AI_MATKEY_COLOR_AMBIENT, color) == AI_SUCCESS) {
             ChunkWriter curChunk(writer, Discreet3DS::CHUNK_MAT_AMBIENT);
             WriteColor(color);
         }
 
         float f;
         if (mat.Get(AI_MATKEY_OPACITY, f) == AI_SUCCESS) {
             ChunkWriter chunk(writer, Discreet3DS::CHUNK_MAT_TRANSPARENCY);
             WritePercentChunk(1.0f - f);
         }
 
         if (mat.Get(AI_MATKEY_COLOR_EMISSIVE, color) == AI_SUCCESS) {
             ChunkWriter curChunk(writer, Discreet3DS::CHUNK_MAT_SELF_ILLUM);
             WriteColor(color);
         }
 
         aiShadingMode shading_mode = aiShadingMode_Flat;
         if (mat.Get(AI_MATKEY_SHADING_MODEL, shading_mode) == AI_SUCCESS) {
             ChunkWriter chunk(writer, Discreet3DS::CHUNK_MAT_SHADING);
 
             Discreet3DS::shadetype3ds shading_mode_out;
             switch (shading_mode) {
             case aiShadingMode_Flat:
             case aiShadingMode_NoShading:
                 shading_mode_out = Discreet3DS::Flat;
                 break;
 
             case aiShadingMode_Gouraud:
             case aiShadingMode_Toon:
             case aiShadingMode_OrenNayar:
             case aiShadingMode_Minnaert:
                 shading_mode_out = Discreet3DS::Gouraud;
                 break;
 
             case aiShadingMode_Phong:
             case aiShadingMode_Blinn:
             case aiShadingMode_CookTorrance:
             case aiShadingMode_Fresnel:
                 shading_mode_out = Discreet3DS::Phong;
                 break;
 
             default:
                 shading_mode_out = Discreet3DS::Flat;
                 ai_assert(false);
             };
             writer.PutU2(static_cast<uint16_t>(shading_mode_out));
         }
 
         if (mat.Get(AI_MATKEY_SHININESS, f) == AI_SUCCESS) {
             ChunkWriter chunk(writer, Discreet3DS::CHUNK_MAT_SHININESS);
             WritePercentChunk(f);
         }
 
         if (mat.Get(AI_MATKEY_SHININESS_STRENGTH, f) == AI_SUCCESS) {
             ChunkWriter chunk(writer, Discreet3DS::CHUNK_MAT_SHININESS_PERCENT);
             WritePercentChunk(f);
         }
 
         int twosided;
         if (mat.Get(AI_MATKEY_TWOSIDED, twosided) == AI_SUCCESS && twosided != 0) {
             ChunkWriter chunk(writer, Discreet3DS::CHUNK_MAT_TWO_SIDE);
             writer.PutI2(1);
         }
 
         WriteTexture(mat, aiTextureType_DIFFUSE, Discreet3DS::CHUNK_MAT_TEXTURE);
         WriteTexture(mat, aiTextureType_HEIGHT, Discreet3DS::CHUNK_MAT_BUMPMAP);
         WriteTexture(mat, aiTextureType_OPACITY, Discreet3DS::CHUNK_MAT_OPACMAP);
         WriteTexture(mat, aiTextureType_SHININESS, Discreet3DS::CHUNK_MAT_MAT_SHINMAP);
         WriteTexture(mat, aiTextureType_SPECULAR, Discreet3DS::CHUNK_MAT_SPECMAP);
         WriteTexture(mat, aiTextureType_EMISSIVE, Discreet3DS::CHUNK_MAT_SELFIMAP);
         WriteTexture(mat, aiTextureType_REFLECTION, Discreet3DS::CHUNK_MAT_REFLMAP);
     }
 }
 
 // ------------------------------------------------------------------------------------------------
diff --git a/code/AssetLib/3MF/3MFXmlTags.h b/code/AssetLib/3MF/3MFXmlTags.h
index d447556d6..9fa2affd4 100644
--- a/code/AssetLib/3MF/3MFXmlTags.h
+++ b/code/AssetLib/3MF/3MFXmlTags.h
@@ -46,64 +46,64 @@ namespace D3MF {
 namespace XmlTag {
     // Root tag
     const char* const RootTag = "3MF";
 
     // Meta-data
     const char* const meta = "metadata";
     const char* const meta_name = "name";
 
     // Model-data specific tags
     const char* const model = "model";
     const char* const model_unit = "unit";
     const char* const metadata = "metadata";
     const char* const resources = "resources";
     const char* const object = "object";
     const char* const mesh = "mesh";
     const char* const components = "components";
     const char* const component = "component";
     const char* const vertices = "vertices";
     const char* const vertex = "vertex";
     const char* const triangles = "triangles";
     const char* const triangle = "triangle";
     const char* const x = "x";
     const char* const y = "y";
     const char* const z = "z";
     const char* const v1 = "v1";
     const char* const v2 = "v2";
     const char* const v3 = "v3";
     const char* const id = "id";
     const char* const pid = "pid";
     const char* const pindex = "pindex";
     const char* const p1 = "p1";
     const char* const name = "name";
     const char* const type = "type";
     const char* const build = "build";
     const char* const item = "item";
     const char* const objectid = "objectid";
     const char* const transform = "transform";
 
     // Material definitions
     const char* const basematerials = "basematerials";
     const char* const basematerials_id = "id";
     const char* const basematerials_base = "base";
     const char* const basematerials_name = "name";
     const char* const basematerials_displaycolor = "displaycolor";
 
     // Meta info tags
     const char* const CONTENT_TYPES_ARCHIVE = "[Content_Types].xml";
     const char* const ROOT_RELATIONSHIPS_ARCHIVE = "_rels/.rels";
     const char* const SCHEMA_CONTENTTYPES = "http://schemas.openxmlformats.org/package/2006/content-types";
     const char* const SCHEMA_RELATIONSHIPS = "http://schemas.openxmlformats.org/package/2006/relationships";
     const char* const RELS_RELATIONSHIP_CONTAINER = "Relationships";
     const char* const RELS_RELATIONSHIP_NODE = "Relationship";
     const char* const RELS_ATTRIB_TARGET = "Target";
     const char* const RELS_ATTRIB_TYPE = "Type";
     const char* const RELS_ATTRIB_ID = "Id";
     const char* const PACKAGE_START_PART_RELATIONSHIP_TYPE = "http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel";
     const char* const PACKAGE_PRINT_TICKET_RELATIONSHIP_TYPE = "http://schemas.microsoft.com/3dmanufacturing/2013/01/printticket";
     const char* const PACKAGE_TEXTURE_RELATIONSHIP_TYPE = "http://schemas.microsoft.com/3dmanufacturing/2013/01/3dtexture";
     const char* const PACKAGE_CORE_PROPERTIES_RELATIONSHIP_TYPE = "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties";
     const char* const PACKAGE_THUMBNAIL_RELATIONSHIP_TYPE = "http://schemas.openxmlformats.org/package/2006/relationships/metadata/thumbnail";
-    }
+}
 
 } // Namespace D3MF
 } // Namespace Assimp
diff --git a/code/AssetLib/3MF/D3MFImporter.cpp b/code/AssetLib/3MF/D3MFImporter.cpp
index 747af7cfc..a56b82d63 100644
--- a/code/AssetLib/3MF/D3MFImporter.cpp
+++ b/code/AssetLib/3MF/D3MFImporter.cpp
@@ -238,320 +238,320 @@ public:
 private:
     void addObjectToNode(aiNode *parent, Object *obj, aiMatrix4x4 nodeTransform) {
         ai_assert(nullptr != obj);
 
         aiNode *sceneNode = new aiNode(obj->mName);
         sceneNode->mNumMeshes = static_cast<unsigned int>(obj->mMeshes.size());
         sceneNode->mMeshes = new unsigned int[sceneNode->mNumMeshes];
         std::copy(obj->mMeshIndex.begin(), obj->mMeshIndex.end(), sceneNode->mMeshes);
 
         sceneNode->mTransformation = nodeTransform;
         if (nullptr != parent) {
             parent->addChildren(1, &sceneNode);
         }
 
         for (size_t i = 0; i < obj->mComponents.size(); ++i) {
             Component c = obj->mComponents[i];
             auto it = mResourcesDictionnary.find(c.mObjectId);
             if (it != mResourcesDictionnary.end() && it->second->getType() == ResourceType::RT_Object) {
                 addObjectToNode(sceneNode, static_cast<Object *>(it->second), c.mTransformation);
             }
         }
     }
 
     bool getNodeAttribute(const XmlNode &node, const std::string &attribute, std::string &value) {
         pugi::xml_attribute objectAttribute = node.attribute(attribute.c_str());
         if (!objectAttribute.empty()) {
             value = objectAttribute.as_string();
             return true;
         }
 
         return false;
     }
 
     bool getNodeAttribute(const XmlNode &node, const std::string &attribute, int &value) {
         std::string strValue;
         bool ret = getNodeAttribute(node, attribute, strValue);
         if (ret) {
             value = std::atoi(strValue.c_str());
             return true;
-        } 
+        }
 
         return false;
     }
 
     aiMatrix4x4 parseTransformMatrix(std::string matrixStr) {
         // split the string
         std::vector<float> numbers;
         std::string currentNumber;
         for (size_t i = 0; i < matrixStr.size(); ++i) {
             const char c = matrixStr[i];
             if (c == ' ') {
                 if (currentNumber.size() > 0) {
                     float f = std::stof(currentNumber);
                     numbers.push_back(f);
                     currentNumber.clear();
                 }
             } else {
                 currentNumber.push_back(c);
             }
         }
         if (currentNumber.size() > 0) {
             const float f = std::stof(currentNumber);
             numbers.push_back(f);
         }
 
         aiMatrix4x4 transformMatrix;
         transformMatrix.a1 = numbers[0];
         transformMatrix.b1 = numbers[1];
         transformMatrix.c1 = numbers[2];
         transformMatrix.d1 = 0;
 
         transformMatrix.a2 = numbers[3];
         transformMatrix.b2 = numbers[4];
         transformMatrix.c2 = numbers[5];
         transformMatrix.d2 = 0;
 
         transformMatrix.a3 = numbers[6];
         transformMatrix.b3 = numbers[7];
         transformMatrix.c3 = numbers[8];
         transformMatrix.d3 = 0;
 
         transformMatrix.a4 = numbers[9];
         transformMatrix.b4 = numbers[10];
         transformMatrix.c4 = numbers[11];
         transformMatrix.d4 = 1;
 
         return transformMatrix;
     }
 
     void ReadObject(XmlNode &node) {
         int id = -1, pid = -1, pindex = -1;
         bool hasId = getNodeAttribute(node, XmlTag::id, id);
         bool hasPid = getNodeAttribute(node, XmlTag::pid, pid);
         bool hasPindex = getNodeAttribute(node, XmlTag::pindex, pindex);
         if (!hasId) {
             return;
         }
 
         Object *obj = new Object(id);
 
         for (XmlNode &currentNode : node.children()) {
             const std::string &currentName = currentNode.name();
             if (currentName == D3MF::XmlTag::mesh) {
                 auto mesh = ReadMesh(currentNode);
                 mesh->mName.Set(ai_to_string(id));
 
                 if (hasPid) {
                     auto it = mResourcesDictionnary.find(pid);
                     if (hasPindex && it != mResourcesDictionnary.end() && it->second->getType() == ResourceType::RT_BaseMaterials) {
                         BaseMaterials *materials = static_cast<BaseMaterials *>(it->second);
                         mesh->mMaterialIndex = materials->mMaterialIndex[pindex];
                     }
                 }
 
                 obj->mMeshes.push_back(mesh);
                 obj->mMeshIndex.push_back(mMeshCount);
                 mMeshCount++;
             } else if (currentName == D3MF::XmlTag::components) {
                 for (XmlNode &currentSubNode : currentNode.children()) {
                     const std::string subNodeName = currentSubNode.name();
                     if (subNodeName == D3MF::XmlTag::component) {
                         int objectId = -1;
                         std::string componentTransformStr;
                         aiMatrix4x4 componentTransform;
                         if (getNodeAttribute(currentSubNode, D3MF::XmlTag::transform, componentTransformStr)) {
                             componentTransform = parseTransformMatrix(componentTransformStr);
                         }
 
                         if (getNodeAttribute(currentSubNode, D3MF::XmlTag::objectid, objectId)) {
                             obj->mComponents.push_back({ objectId, componentTransform });
                         }
                     }
                 }
             }
         }
 
         mResourcesDictionnary.insert(std::make_pair(id, obj));
     }
 
     aiMesh *ReadMesh(XmlNode &node) {
         aiMesh *mesh = new aiMesh();
 
         for (XmlNode &currentNode : node.children()) {
             const std::string currentName = currentNode.name();
             if (currentName == XmlTag::vertices) {
                 ImportVertices(currentNode, mesh);
             } else if (currentName == XmlTag::triangles) {
                 ImportTriangles(currentNode, mesh);
             }
         }
 
         return mesh;
     }
 
     void ReadMetadata(XmlNode &node) {
         pugi::xml_attribute attribute = node.attribute(D3MF::XmlTag::meta_name);
         const std::string name = attribute.as_string();
         const std::string value = node.value();
         if (name.empty()) {
             return;
         }
 
         MetaEntry entry;
         entry.name = name;
         entry.value = value;
         mMetaData.push_back(entry);
     }
 
     void ImportVertices(XmlNode &node, aiMesh *mesh) {
         std::vector<aiVector3D> vertices;
         for (XmlNode &currentNode : node.children()) {
             const std::string currentName = currentNode.name();
             if (currentName == XmlTag::vertex) {
                 vertices.push_back(ReadVertex(currentNode));
             }
         }
 
         mesh->mNumVertices = static_cast<unsigned int>(vertices.size());
         mesh->mVertices = new aiVector3D[mesh->mNumVertices];
         std::copy(vertices.begin(), vertices.end(), mesh->mVertices);
     }
 
     aiVector3D ReadVertex(XmlNode &node) {
         aiVector3D vertex;
         vertex.x = ai_strtof(node.attribute(XmlTag::x).as_string(), nullptr);
         vertex.y = ai_strtof(node.attribute(XmlTag::y).as_string(), nullptr);
         vertex.z = ai_strtof(node.attribute(XmlTag::z).as_string(), nullptr);
 
         return vertex;
     }
 
     void ImportTriangles(XmlNode &node, aiMesh *mesh) {
         std::vector<aiFace> faces;
         for (XmlNode &currentNode : node.children()) {
             const std::string currentName = currentNode.name();
             if (currentName == XmlTag::triangle) {
                 aiFace face = ReadTriangle(currentNode);
                 faces.push_back(face);
 
                 int pid = 0, p1 = 0;
                 bool hasPid = getNodeAttribute(currentNode, D3MF::XmlTag::pid, pid);
                 bool hasP1 = getNodeAttribute(currentNode, D3MF::XmlTag::p1, p1);
 
                 if (hasPid && hasP1) {
                     auto it = mResourcesDictionnary.find(pid);
                     if (it != mResourcesDictionnary.end()) {
                         if (it->second->getType() == ResourceType::RT_BaseMaterials) {
                             BaseMaterials *baseMaterials = static_cast<BaseMaterials *>(it->second);
                             mesh->mMaterialIndex = baseMaterials->mMaterialIndex[p1];
                         }
                         // TODO: manage the separation into several meshes if the triangles of the mesh do not all refer to the same material
                     }
                 }
             }
         }
 
         mesh->mNumFaces = static_cast<unsigned int>(faces.size());
         mesh->mFaces = new aiFace[mesh->mNumFaces];
         mesh->mPrimitiveTypes = aiPrimitiveType_TRIANGLE;
 
         std::copy(faces.begin(), faces.end(), mesh->mFaces);
     }
 
     aiFace ReadTriangle(XmlNode &node) {
         aiFace face;
 
         face.mNumIndices = 3;
         face.mIndices = new unsigned int[face.mNumIndices];
         face.mIndices[0] = static_cast<unsigned int>(std::atoi(node.attribute(XmlTag::v1).as_string()));
         face.mIndices[1] = static_cast<unsigned int>(std::atoi(node.attribute(XmlTag::v2).as_string()));
         face.mIndices[2] = static_cast<unsigned int>(std::atoi(node.attribute(XmlTag::v3).as_string()));
 
         return face;
     }
 
     void ReadBaseMaterials(XmlNode &node) {
         int id = -1;
         if (getNodeAttribute(node, D3MF::XmlTag::basematerials_id, id)) {
             BaseMaterials *baseMaterials = new BaseMaterials(id);
 
             for (XmlNode &currentNode : node.children()) {
                 const std::string currentName = currentNode.name();
                 if (currentName == XmlTag::basematerials_base) {
                     baseMaterials->mMaterialIndex.push_back(mMaterialCount);
                     baseMaterials->mMaterials.push_back(readMaterialDef(currentNode, id));
                     ++mMaterialCount;
                 }
             }
 
             mResourcesDictionnary.insert(std::make_pair(id, baseMaterials));
         }
     }
 
     bool parseColor(const char *color, aiColor4D &diffuse) {
         if (nullptr == color) {
             return false;
         }
 
         //format of the color string: #RRGGBBAA or #RRGGBB (3MF Core chapter 5.1.1)
         const size_t len = strlen(color);
         if (9 != len && 7 != len) {
             return false;
         }
 
         const char *buf(color);
         if ('#' != buf[0]) {
             return false;
         }
 
         char r[3] = { buf[1], buf[2], '\0' };
         diffuse.r = static_cast<ai_real>(strtol(r, nullptr, 16)) / ai_real(255.0);
 
         char g[3] = { buf[3], buf[4], '\0' };
         diffuse.g = static_cast<ai_real>(strtol(g, nullptr, 16)) / ai_real(255.0);
 
         char b[3] = { buf[5], buf[6], '\0' };
         diffuse.b = static_cast<ai_real>(strtol(b, nullptr, 16)) / ai_real(255.0);
 
         if (7 == len)
             return true;
 
         char a[3] = { buf[7], buf[8], '\0' };
         diffuse.a = static_cast<ai_real>(strtol(a, nullptr, 16)) / ai_real(255.0);
 
         return true;
     }
 
     void assignDiffuseColor(XmlNode &node, aiMaterial *mat) {
         const char *color = node.attribute(XmlTag::basematerials_displaycolor).as_string();
         aiColor4D diffuse;
         if (parseColor(color, diffuse)) {
             mat->AddProperty<aiColor4D>(&diffuse, 1, AI_MATKEY_COLOR_DIFFUSE);
         }
     }
 
     aiMaterial *readMaterialDef(XmlNode &node, unsigned int basematerialsId) {
         aiMaterial *material = new aiMaterial();
         material->mNumProperties = 0;
         std::string name;
         bool hasName = getNodeAttribute(node, D3MF::XmlTag::basematerials_name, name);
 
         std::string stdMaterialName;
         const std::string strId(ai_to_string(basematerialsId));
         stdMaterialName += "id";
         stdMaterialName += strId;
         stdMaterialName += "_";
         if (hasName) {
             stdMaterialName += std::string(name);
         } else {
             stdMaterialName += "basemat_";
             stdMaterialName += ai_to_string(mMaterialCount - basematerialsId);
         }
 
         aiString assimpMaterialName(stdMaterialName);
         material->AddProperty(&assimpMaterialName, AI_MATKEY_NAME);
 
         assignDiffuseColor(node, material);
 
         return material;
     }
diff --git a/code/AssetLib/AMF/AMFImporter.cpp b/code/AssetLib/AMF/AMFImporter.cpp
index 615882b6a..88a38b827 100644
--- a/code/AssetLib/AMF/AMFImporter.cpp
+++ b/code/AssetLib/AMF/AMFImporter.cpp
@@ -291,61 +291,61 @@ void AMFImporter::ParseHelper_Node_Exit() {
 // <amf
 // unit="" - The units to be used. May be "inch", "millimeter", "meter", "feet", or "micron".
 // version="" - Version of file format.
 // >
 // </amf>
 // Root XML element.
 // Multi elements - No.
 void AMFImporter::ParseNode_Root() {
     AMFNodeElementBase *ne = nullptr;
     XmlNode *root = mXmlParser->findNode("amf");
     if (nullptr == root) {
         throw DeadlyImportError("Root node \"amf\" not found.");
     }
     XmlNode node = *root;
     mUnit = ai_tolower(std::string(node.attribute("unit").as_string()));
-    
+
     mVersion = node.attribute("version").as_string();
 
     // Read attributes for node <amf>.
     // Check attributes
     if (!mUnit.empty()) {
         if ((mUnit != "inch") && (mUnit != "millimeters") && (mUnit != "millimeter") && (mUnit != "meter") && (mUnit != "feet") && (mUnit != "micron")) {
             Throw_IncorrectAttrValue("unit", mUnit);
         }
     }
 
     // create root node element.
     ne = new AMFRoot(nullptr);
 
     mNodeElement_Cur = ne; // set first "current" element
     // and assign attribute's values
     ((AMFRoot *)ne)->Unit = mUnit;
     ((AMFRoot *)ne)->Version = mVersion;
 
     // Check for child nodes
     for (XmlNode &currentNode : node.children() ) {
         const std::string currentName = currentNode.name();
         if (currentName == "object") {
             ParseNode_Object(currentNode);
         } else if (currentName == "material") {
             ParseNode_Material(currentNode);
         } else if (currentName == "texture") {
             ParseNode_Texture(currentNode);
         } else if (currentName == "constellation") {
             ParseNode_Constellation(currentNode);
         } else if (currentName == "metadata") {
             ParseNode_Metadata(currentNode);
         }
         mNodeElement_Cur = ne;
     }
     mNodeElement_Cur = ne; // force restore "current" element
     mNodeElement_List.push_back(ne); // add to node element list because its a new object in graph.
 }
 
 // <constellation
 // id="" - The Object ID of the new constellation being defined.
 // >
 // </constellation>
 // A collection of objects or constellations with specific relative locations.
 // Multi elements - Yes.
 // Parent element - <amf>.
diff --git a/code/AssetLib/AMF/AMFImporter_Geometry.cpp b/code/AssetLib/AMF/AMFImporter_Geometry.cpp
index 1fd2c49a4..1d2a1f5b4 100644
--- a/code/AssetLib/AMF/AMFImporter_Geometry.cpp
+++ b/code/AssetLib/AMF/AMFImporter_Geometry.cpp
@@ -49,44 +49,44 @@ namespace Assimp {
 // <mesh>
 // </mesh>
 // A 3D mesh hull.
 // Multi elements - Yes.
 // Parent element - <object>.
 void AMFImporter::ParseNode_Mesh(XmlNode &node) {
     AMFNodeElementBase *ne = nullptr;
 
     // Check for child nodes
     if (0 != ASSIMP_stricmp(node.name(), "mesh")) {
         return;
     }
     // create new mesh object.
     ne = new AMFMesh(mNodeElement_Cur);
     bool found_verts = false, found_volumes = false;
     if (!node.empty()) {
         ParseHelper_Node_Enter(ne);
         pugi::xml_node vertNode = node.child("vertices");
         if (!vertNode.empty()) {
             ParseNode_Vertices(vertNode);
             found_verts = true;
         }
 
         pugi::xml_node volumeNode = node.child("volume");
         if (!volumeNode.empty()) {
             ParseNode_Volume(volumeNode);
             found_volumes = true;
         }
         ParseHelper_Node_Exit();
-    } 
+    }
 
     if (!found_verts && !found_volumes) {
         mNodeElement_Cur->Child.push_back(ne);
     } // if(!mReader->isEmptyElement()) else
 
     // and to node element list because its a new object in graph.
     mNodeElement_List.push_back(ne);
 }
 
 // <vertices>
 // </vertices>
 // The list of vertices to be used in defining triangles.
 // Multi elements - No.
 // Parent element - <mesh>.
@@ -186,56 +186,56 @@ void AMFImporter::ParseNode_Coordinates(XmlNode &node) {
 // <volume
 // materialid="" - Which material to use.
 // type=""       - What this volume describes can be "region" or "support". If none specified, "object" is assumed. If support, then the geometric
 //                 requirements 1-8 listed in section 5 do not need to be maintained.
 // >
 // </volume>
 // Defines a volume from the established vertex list.
 // Multi elements - Yes.
 // Parent element - <mesh>.
 void AMFImporter::ParseNode_Volume(XmlNode &node) {
     std::string materialid;
     std::string type;
     AMFNodeElementBase *ne = new AMFVolume(mNodeElement_Cur);
 
     // Read attributes for node <color>.
     // and assign read data
-   
+
     ((AMFVolume *)ne)->MaterialID = node.attribute("materialid").as_string();
-     
+
     ((AMFVolume *)ne)->Type = type;
     // Check for child nodes
     bool col_read = false;
     if (!node.empty()) {
         ParseHelper_Node_Enter(ne);
         for (auto &currentNode : node.children()) {
             const std::string currentName = currentNode.name();
             if (currentName == "color") {
                 if (col_read) Throw_MoreThanOnceDefined(currentName, "color", "Only one color can be defined for <volume>.");
                 ParseNode_Color(currentNode);
                 col_read = true;
             } else if (currentName == "triangle") {
                 ParseNode_Triangle(currentNode);
             } else if (currentName == "metadata") {
                 ParseNode_Metadata(currentNode);
             } else if (currentName == "volume") {
                 ParseNode_Metadata(currentNode);
             }
         }
         ParseHelper_Node_Exit();
     } else {
         mNodeElement_Cur->Child.push_back(ne); // Add element to child list of current element
     }
 
     mNodeElement_List.push_back(ne); // and to node element list because its a new object in graph.
 }
 
 // <triangle>
 // </triangle>
 // Defines a 3D triangle from three vertices, according to the right-hand rule (counter-clockwise when looking from the outside).
 // Multi elements - Yes.
 // Parent element - <volume>.
 //
 // Children elements:
 //   <v1>, <v2>, <v3>
 //   Multi elements - No.
 //   Index of the desired vertices in a triangle or edge.
diff --git a/code/AssetLib/AMF/AMFImporter_Postprocess.cpp b/code/AssetLib/AMF/AMFImporter_Postprocess.cpp
index 43d0de52f..d56d6681d 100644
--- a/code/AssetLib/AMF/AMFImporter_Postprocess.cpp
+++ b/code/AssetLib/AMF/AMFImporter_Postprocess.cpp
@@ -59,24 +59,24 @@ namespace Assimp {
 aiColor4D AMFImporter::SPP_Material::GetColor(const float /*pX*/, const float /*pY*/, const float /*pZ*/) const {
     aiColor4D tcol;
 
     // Check if stored data are supported.
     if (!Composition.empty()) {
         throw DeadlyImportError("IME. GetColor for composition");
     }
 
     if (Color->Composed) {
         throw DeadlyImportError("IME. GetColor, composed color");
     }
 
     tcol = Color->Color;
-    
+
     // Check if default color must be used
     if ((tcol.r == 0) && (tcol.g == 0) && (tcol.b == 0) && (tcol.a == 0)) {
         tcol.r = 0.5f;
         tcol.g = 0.5f;
         tcol.b = 0.5f;
         tcol.a = 1;
     }
 
     return tcol;
 }
@@ -84,47 +84,47 @@ aiColor4D AMFImporter::SPP_Material::GetColor(const float /*pX*/, const float /*
 void AMFImporter::PostprocessHelper_CreateMeshDataArray(const AMFMesh &nodeElement, std::vector<aiVector3D> &vertexCoordinateArray,
         std::vector<AMFColor *> &pVertexColorArray) const {
     AMFVertices  *vn = nullptr;
     size_t col_idx;
 
     // All data stored in "vertices", search for it.
     for (AMFNodeElementBase *ne_child : nodeElement.Child) {
         if (ne_child->Type == AMFNodeElementBase::ENET_Vertices) {
             vn = (AMFVertices*)ne_child;
         }
     }
 
     // If "vertices" not found then no work for us.
     if (vn == nullptr) {
         return;
     }
 
     // all coordinates stored as child and we need to reserve space for future push_back's.
-    vertexCoordinateArray.reserve(vn->Child.size()); 
+    vertexCoordinateArray.reserve(vn->Child.size());
 
     // colors count equal vertices count.
-    pVertexColorArray.resize(vn->Child.size()); 
+    pVertexColorArray.resize(vn->Child.size());
     col_idx = 0;
 
     // Inside vertices collect all data and place to arrays
     for (AMFNodeElementBase *vn_child : vn->Child) {
         // vertices, colors
         if (vn_child->Type == AMFNodeElementBase::ENET_Vertex) {
             // by default clear color for current vertex
             pVertexColorArray[col_idx] = nullptr;
 
             for (AMFNodeElementBase *vtx : vn_child->Child) {
                 if (vtx->Type == AMFNodeElementBase::ENET_Coordinates) {
                     vertexCoordinateArray.push_back(((AMFCoordinates *)vtx)->Coordinate);
                     continue;
                 }
 
                 if (vtx->Type == AMFNodeElementBase::ENET_Color) {
                     pVertexColorArray[col_idx] = (AMFColor *)vtx;
                     continue;
                 }
             }
 
             ++col_idx;
         }
     }
 }
diff --git a/code/AssetLib/Assjson/mesh_splitter.cpp b/code/AssetLib/Assjson/mesh_splitter.cpp
index 24385f9a0..9301cc27e 100644
--- a/code/AssetLib/Assjson/mesh_splitter.cpp
+++ b/code/AssetLib/Assjson/mesh_splitter.cpp
@@ -98,223 +98,223 @@ VertexWeightTable* ComputeVertexBoneWeightTable(const aiMesh* pMesh) {
 // ------------------------------------------------------------------------------------------------
 void MeshSplitter :: SplitMesh(unsigned int a, aiMesh* in_mesh, std::vector<std::pair<aiMesh*, unsigned int> >& source_mesh_map) {
 	// TODO: should better use std::(multi)set for source_mesh_map.
 
 	if (in_mesh->mNumVertices <= LIMIT)	{
 		source_mesh_map.push_back(std::make_pair(in_mesh,a));
 		return;
 	}
 
 	// build a per-vertex weight list if necessary
 	VertexWeightTable* avPerVertexWeights = ComputeVertexBoneWeightTable(in_mesh);
 
 	// we need to split this mesh into sub meshes. Estimate submesh size
 	const unsigned int sub_meshes = (in_mesh->mNumVertices / LIMIT) + 1;
 
-	// create a std::vector<unsigned int> to remember which vertices have already 
+	// create a std::vector<unsigned int> to remember which vertices have already
 	// been copied and to which position (i.e. output index)
 	std::vector<unsigned int> was_copied_to;
 	was_copied_to.resize(in_mesh->mNumVertices,WAS_NOT_COPIED);
 
 	// Try to find a good estimate for the number of output faces
 	// per mesh. Add 12.5% as buffer
 	unsigned int size_estimated = in_mesh->mNumFaces / sub_meshes;
 	size_estimated += size_estimated / 8;
 
 	// now generate all submeshes
 	unsigned int base = 0;
 	while (true) {
 		const unsigned int out_vertex_index = LIMIT;
 
-		aiMesh* out_mesh = new aiMesh();			
+		aiMesh* out_mesh = new aiMesh();
 		out_mesh->mNumVertices = 0;
 		out_mesh->mMaterialIndex = in_mesh->mMaterialIndex;
 
 		// the name carries the adjacency information between the meshes
 		out_mesh->mName = in_mesh->mName;
 
 		typedef std::vector<aiVertexWeight> BoneWeightList;
 		if (in_mesh->HasBones())	{
 			out_mesh->mBones = new aiBone*[in_mesh->mNumBones]();
 		}
 
 		// clear the temporary helper array
 		if (base)	{
 			std::fill(was_copied_to.begin(), was_copied_to.end(), WAS_NOT_COPIED);
 		}
 
 		std::vector<aiFace> vFaces;
 
 		// reserve enough storage for most cases
 		if (in_mesh->HasPositions()) {
 			out_mesh->mVertices = new aiVector3D[out_vertex_index];
 		}
 
 		if (in_mesh->HasNormals()) {
 			out_mesh->mNormals = new aiVector3D[out_vertex_index];
 		}
 
 		if (in_mesh->HasTangentsAndBitangents())	{
 			out_mesh->mTangents = new aiVector3D[out_vertex_index];
 			out_mesh->mBitangents = new aiVector3D[out_vertex_index];
 		}
 
 		for (unsigned int c = 0; in_mesh->HasVertexColors(c);++c)	{
 			out_mesh->mColors[c] = new aiColor4D[out_vertex_index];
 		}
 
 		for (unsigned int c = 0; in_mesh->HasTextureCoords(c);++c)	{
 			out_mesh->mNumUVComponents[c] = in_mesh->mNumUVComponents[c];
 			out_mesh->mTextureCoords[c] = new aiVector3D[out_vertex_index];
 		}
 		vFaces.reserve(size_estimated);
 
 		// (we will also need to copy the array of indices)
 		while (base < in_mesh->mNumFaces) {
 			const unsigned int iNumIndices = in_mesh->mFaces[base].mNumIndices;
 
 			// doesn't catch degenerates but is quite fast
 			unsigned int iNeed = 0;
 			for (unsigned int v = 0; v < iNumIndices;++v)	{
 				unsigned int index = in_mesh->mFaces[base].mIndices[v];
 
 				// check whether we do already have this vertex
 				if (WAS_NOT_COPIED == was_copied_to[index])	{
-					iNeed++; 
+					iNeed++;
 				}
 			}
 			if (out_mesh->mNumVertices + iNeed > out_vertex_index)	{
 				// don't use this face
 				break;
 			}
 
 			vFaces.push_back(aiFace());
 			aiFace& rFace = vFaces.back();
 
 			// setup face type and number of indices
 			rFace.mNumIndices = iNumIndices;
 			rFace.mIndices = new unsigned int[iNumIndices];
 
 			// need to update the output primitive types
 			switch (rFace.mNumIndices)
 			{
 			case 1:
 				out_mesh->mPrimitiveTypes |= aiPrimitiveType_POINT;
 				break;
 			case 2:
 				out_mesh->mPrimitiveTypes |= aiPrimitiveType_LINE;
 				break;
 			case 3:
 				out_mesh->mPrimitiveTypes |= aiPrimitiveType_TRIANGLE;
 				break;
 			default:
 				out_mesh->mPrimitiveTypes |= aiPrimitiveType_POLYGON;
 			}
 
 			// and copy the contents of the old array, offset them by current base
 			for (unsigned int v = 0; v < iNumIndices;++v) {
 				const unsigned int index = in_mesh->mFaces[base].mIndices[v];
 
 				// check whether we do already have this vertex
 				if (WAS_NOT_COPIED != was_copied_to[index]) {
 					rFace.mIndices[v] = was_copied_to[index];
 					continue;
 				}
 
 				// copy positions
 				out_mesh->mVertices[out_mesh->mNumVertices] = (in_mesh->mVertices[index]);
 
 				// copy normals
 				if (in_mesh->HasNormals()) {
 					out_mesh->mNormals[out_mesh->mNumVertices] = (in_mesh->mNormals[index]);
 				}
 
 				// copy tangents/bi-tangents
 				if (in_mesh->HasTangentsAndBitangents()) {
 					out_mesh->mTangents[out_mesh->mNumVertices] = (in_mesh->mTangents[index]);
 					out_mesh->mBitangents[out_mesh->mNumVertices] = (in_mesh->mBitangents[index]);
 				}
 
 				// texture coordinates
 				for (unsigned int c = 0;  c < AI_MAX_NUMBER_OF_TEXTURECOORDS;++c) {
 					if (in_mesh->HasTextureCoords( c)) {
 						out_mesh->mTextureCoords[c][out_mesh->mNumVertices] = in_mesh->mTextureCoords[c][index];
 					}
 				}
-				// vertex colors 
+				// vertex colors
 				for (unsigned int c = 0;  c < AI_MAX_NUMBER_OF_COLOR_SETS;++c) {
 					if (in_mesh->HasVertexColors( c)) {
 						out_mesh->mColors[c][out_mesh->mNumVertices] = in_mesh->mColors[c][index];
 					}
 				}
 				// check whether we have bone weights assigned to this vertex
 				rFace.mIndices[v] = out_mesh->mNumVertices;
 				if (avPerVertexWeights) {
 					VertexWeightTable& table = avPerVertexWeights[ out_mesh->mNumVertices ];
 					for (VertexWeightTable::const_iterator iter = table.begin(), end = table.end(); iter != end;++iter) {
 						// allocate the bone weight array if necessary and store it in the mBones field (HACK!)
 						BoneWeightList* weight_list = reinterpret_cast<BoneWeightList*>(out_mesh->mBones[(*iter).first]);
 						if (!weight_list) {
 							weight_list = new BoneWeightList();
 							out_mesh->mBones[(*iter).first] = reinterpret_cast<aiBone*>(weight_list);
 						}
 						weight_list->push_back(aiVertexWeight(out_mesh->mNumVertices,(*iter).second));
 					}
 				}
 
 				was_copied_to[index] = out_mesh->mNumVertices;
 				out_mesh->mNumVertices++;
 			}
 			base++;
 			if(out_mesh->mNumVertices == out_vertex_index) {
 				// break here. The face is only added if it was complete
 				break;
 			}
 		}
 
 		// check which bones we'll need to create for this submesh
 		if (in_mesh->HasBones()) {
 			aiBone** ppCurrent = out_mesh->mBones;
 			for (unsigned int k = 0; k < in_mesh->mNumBones;++k) {
 				// check whether the bone exists
 				BoneWeightList* const weight_list = reinterpret_cast<BoneWeightList*>(out_mesh->mBones[k]);
 
 				if (weight_list) {
 					const aiBone* const bone_in = in_mesh->mBones[k];
 					aiBone* const bone_out = new aiBone();
 					*ppCurrent++ = bone_out;
 					bone_out->mName = aiString(bone_in->mName);
 					bone_out->mOffsetMatrix =bone_in->mOffsetMatrix;
 					bone_out->mNumWeights = (unsigned int)weight_list->size();
 					bone_out->mWeights = new aiVertexWeight[bone_out->mNumWeights];
 
 					// copy the vertex weights
 					::memcpy(bone_out->mWeights, &(*weight_list)[0],bone_out->mNumWeights * sizeof(aiVertexWeight));
 
 					delete weight_list;
 					out_mesh->mNumBones++;
 				}
 			}
 		}
 
 		// copy the face list to the mesh
 		out_mesh->mFaces = new aiFace[vFaces.size()];
 		out_mesh->mNumFaces = (unsigned int)vFaces.size();
 
 		for (unsigned int p = 0; p < out_mesh->mNumFaces;++p) {
 			out_mesh->mFaces[p] = vFaces[p];
 		}
 
 		// add the newly created mesh to the list
 		source_mesh_map.push_back(std::make_pair(out_mesh,a));
 
 		if (base == in_mesh->mNumFaces) {
 			break;
 		}
 	}
 
 	// delete the per-vertex weight list again
 	delete[] avPerVertexWeights;
 
 	// now delete the old mesh data
 	delete in_mesh;
 }
diff --git a/code/AssetLib/Assjson/mesh_splitter.h b/code/AssetLib/Assjson/mesh_splitter.h
index 326f73b41..3bb26118a 100644
--- a/code/AssetLib/Assjson/mesh_splitter.h
+++ b/code/AssetLib/Assjson/mesh_splitter.h
@@ -21,18 +21,18 @@ struct aiMesh;
 struct aiNode;
 
 // ---------------------------------------------------------------------------
 /** Splits meshes of unique vertices into meshes with no more vertices than
- *  a given, configurable threshold value. 
+ *  a given, configurable threshold value.
  */
-class MeshSplitter 
+class MeshSplitter
 {
 
 public:
-	
+
 	void SetLimit(unsigned int l) {
 		LIMIT = l;
 	}
 
 	unsigned int GetLimit() const {
 		return LIMIT;
 	}
diff --git a/code/AssetLib/Assxml/AssxmlExporter.cpp b/code/AssetLib/Assxml/AssxmlExporter.cpp
index 847ba0d7e..d244813b1 100644
--- a/code/AssetLib/Assxml/AssxmlExporter.cpp
+++ b/code/AssetLib/Assxml/AssxmlExporter.cpp
@@ -50,7 +50,7 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <assimp/IOSystem.hpp>
 #include <assimp/Exporter.hpp>
 
-namespace Assimp   { 
+namespace Assimp   {
 
 void ExportSceneAssxml(const char* pFile, IOSystem* pIOSystem, const aiScene* pScene, const ExportProperties* /*pProperties*/)
 {
diff --git a/code/AssetLib/Blender/BlenderModifier.h b/code/AssetLib/Blender/BlenderModifier.h
index daf120087..d2fea43c1 100644
--- a/code/AssetLib/Blender/BlenderModifier.h
+++ b/code/AssetLib/Blender/BlenderModifier.h
@@ -52,48 +52,48 @@ namespace Assimp {
 namespace Blender {
 
 // -------------------------------------------------------------------------------------------
-/** 
+/**
  *  Dummy base class for all blender modifiers. Modifiers are reused between imports, so
- *  they should be stateless and not try to cache model data. 
+ *  they should be stateless and not try to cache model data.
  */
 // -------------------------------------------------------------------------------------------
 class BlenderModifier {
 public:
     /**
      *  The class destructor, virtual.
      */
     virtual ~BlenderModifier() {
         // empty
     }
 
     // --------------------
-    /** 
+    /**
      *  Check if *this* modifier is active, given a ModifierData& block.
      */
     virtual bool IsActive( const ModifierData& /*modin*/) {
         return false;
     }
 
     // --------------------
-    /** 
+    /**
      *  Apply the modifier to a given output node. The original data used
      *  to construct the node is given as well. Not called unless IsActive()
-     *  was called and gave positive response. 
+     *  was called and gave positive response.
      */
     virtual void DoIt(aiNode& /*out*/,
         ConversionData& /*conv_data*/,
         const ElemBase& orig_modifier,
         const Scene& /*in*/,
         const Object& /*orig_object*/
     ) {
         ASSIMP_LOG_INFO("This modifier is not supported, skipping: ",orig_modifier.dna_type );
         return;
     }
 };
 
 // -------------------------------------------------------------------------------------------
-/** 
- *  Manage all known modifiers and instance and apply them if necessary 
+/**
+ *  Manage all known modifiers and instance and apply them if necessary
  */
 // -------------------------------------------------------------------------------------------
 class BlenderModifierShowcase {
@@ -109,12 +109,12 @@ public:
 private:
     TempArray< std::vector,BlenderModifier > cached_modifiers;
 };
 
 // MODIFIERS /////////////////////////////////////////////////////////////////////////////////
 
 // -------------------------------------------------------------------------------------------
-/** 
- *  Mirror modifier. Status: implemented. 
+/**
+ *  Mirror modifier. Status: implemented.
  */
 // -------------------------------------------------------------------------------------------
 class BlenderModifier_Mirror : public BlenderModifier {
diff --git a/code/AssetLib/C4D/C4DImporter.cpp b/code/AssetLib/C4D/C4DImporter.cpp
index 5408daa68..14a94958b 100644
--- a/code/AssetLib/C4D/C4DImporter.cpp
+++ b/code/AssetLib/C4D/C4DImporter.cpp
@@ -126,74 +126,74 @@ const aiImporterDesc* C4DImporter::GetInfo () const {
 // ------------------------------------------------------------------------------------------------
 // Imports the given file into the given scene structure.
 void C4DImporter::InternReadFile( const std::string& pFile, aiScene* pScene, IOSystem* pIOHandler) {
     std::unique_ptr<IOStream> file( pIOHandler->Open( pFile));
 
     if( file.get() == nullptr ) {
         ThrowException("failed to open file " + pFile);
     }
 
     const size_t file_size = file->FileSize();
 
     std::vector<uint8_t> mBuffer(file_size);
     file->Read(&mBuffer[0], 1, file_size);
 
     Filename f;
     f.SetMemoryReadMode(&mBuffer[0], file_size);
 
     // open document first
     BaseDocument* doc = LoadDocument(f, SCENEFILTER_OBJECTS | SCENEFILTER_MATERIALS);
     if(doc == nullptr ) {
         ThrowException("failed to read document " + pFile);
     }
 
     // Generate the root-node
     pScene->mRootNode = new aiNode("<C4DRoot>");
-    
+
     // convert left-handed to right-handed
     pScene->mRootNode->mTransformation.a1 = 0.01f;
     pScene->mRootNode->mTransformation.b2 = 0.01f;
-    pScene->mRootNode->mTransformation.c3 = -0.01f; 
-    
+    pScene->mRootNode->mTransformation.c3 = -0.01f;
+
     // first convert all materials
     ReadMaterials(doc->GetFirstMaterial());
 
     // process C4D scene-graph recursively
     try {
         RecurseHierarchy(doc->GetFirstObject(), pScene->mRootNode);
     } catch(...) {
         for(aiMesh* mesh : meshes) {
             delete mesh;
         }
         BaseDocument::Free(doc);
         throw;
     }
     BaseDocument::Free(doc);
 
     // copy meshes over
     pScene->mNumMeshes = static_cast<unsigned int>(meshes.size());
     pScene->mMeshes = new aiMesh*[pScene->mNumMeshes]();
     std::copy(meshes.begin(), meshes.end(), pScene->mMeshes);
 
     // copy materials over, adding a default material if necessary
     unsigned int mat_count = static_cast<unsigned int>(materials.size());
     for(aiMesh* mesh : meshes) {
         ai_assert(mesh->mMaterialIndex <= mat_count);
         if(mesh->mMaterialIndex >= mat_count) {
             ++mat_count;
 
             std::unique_ptr<aiMaterial> def_material(new aiMaterial());
             const aiString name(AI_DEFAULT_MATERIAL_NAME);
             def_material->AddProperty(&name, AI_MATKEY_NAME);
 
             materials.push_back(def_material.release());
             break;
         }
     }
 
     pScene->mNumMaterials = static_cast<unsigned int>(materials.size());
     pScene->mMaterials = new aiMaterial*[pScene->mNumMaterials]();
     std::copy(materials.begin(), materials.end(), pScene->mMaterials);
 }
 
 
 // ------------------------------------------------------------------------------------------------
diff --git a/code/AssetLib/COB/COBLoader.cpp b/code/AssetLib/COB/COBLoader.cpp
index 822bce16d..3bef260e5 100644
--- a/code/AssetLib/COB/COBLoader.cpp
+++ b/code/AssetLib/COB/COBLoader.cpp
@@ -877,50 +877,50 @@ private:
 // ------------------------------------------------------------------------------------------------
 void COBImporter::ReadBinaryFile(Scene &out, StreamReaderLE *reader) {
     if (nullptr == reader) {
         return;
     }
 
     while (1) {
         std::string type;
         type += reader->GetI1();
         type += reader->GetI1();
-        type += reader->GetI1(); 
+        type += reader->GetI1();
         type += reader->GetI1();
 
         ChunkInfo nfo;
         nfo.version = reader->GetI2() * 10;
         nfo.version += reader->GetI2();
 
         nfo.id = reader->GetI4();
         nfo.parent_id = reader->GetI4();
         nfo.size = reader->GetI4();
 
         if (type == "PolH") {
             ReadPolH_Binary(out, *reader, nfo);
         } else if (type == "BitM") {
             ReadBitM_Binary(out, *reader, nfo);
         } else if (type == "Grou") {
             ReadGrou_Binary(out, *reader, nfo);
         } else if (type == "Lght") {
             ReadLght_Binary(out, *reader, nfo);
         } else if (type == "Came") {
             ReadCame_Binary(out, *reader, nfo);
         } else if (type == "Mat1") {
             ReadMat1_Binary(out, *reader, nfo);
         } else if (type == "Unit") {
             ReadUnit_Binary(out, *reader, nfo);
         } else if (type == "OLay") {
             // ignore layer index silently.
             if (nfo.size != static_cast<unsigned int>(-1)) {
                 reader->IncPtr(nfo.size);
             } else
                 return UnsupportedChunk_Binary(*reader, nfo, type.c_str());
         } else if (type == "END ") {
             return;
         } else {
             UnsupportedChunk_Binary(*reader, nfo, type.c_str());
         }
     }
 }
 
 // ------------------------------------------------------------------------------------------------
diff --git a/code/AssetLib/COB/COBLoader.h b/code/AssetLib/COB/COBLoader.h
index 2317d094e..e4d41e500 100644
--- a/code/AssetLib/COB/COBLoader.h
+++ b/code/AssetLib/COB/COBLoader.h
@@ -76,8 +76,8 @@ class COBImporter : public BaseImporter
 {
 public:
     COBImporter();
     ~COBImporter();
-    
+
     // --------------------
     bool CanRead( const std::string& pFile, IOSystem* pIOHandler,
         bool checkSig) const;
diff --git a/code/AssetLib/Collada/ColladaLoader.cpp b/code/AssetLib/Collada/ColladaLoader.cpp
index ee8f97203..ccb2bb336 100644
--- a/code/AssetLib/Collada/ColladaLoader.cpp
+++ b/code/AssetLib/Collada/ColladaLoader.cpp
@@ -1668,30 +1668,30 @@ void ColladaLoader::FillMaterials(const ColladaParser &pParser, aiScene * /*pSce
 // ------------------------------------------------------------------------------------------------
 // Constructs materials from the collada material definitions
 void ColladaLoader::BuildMaterials(ColladaParser &pParser, aiScene * /*pScene*/) {
     newMats.reserve(pParser.mMaterialLibrary.size());
 
     for (ColladaParser::MaterialLibrary::const_iterator matIt = pParser.mMaterialLibrary.begin();
             matIt != pParser.mMaterialLibrary.end(); ++matIt) {
         const Material &material = matIt->second;
         // a material is only a reference to an effect
         ColladaParser::EffectLibrary::iterator effIt = pParser.mEffectLibrary.find(material.mEffect);
-        if (effIt == pParser.mEffectLibrary.end())  
+        if (effIt == pParser.mEffectLibrary.end())
             continue;
         Effect &effect = effIt->second;
 
         // create material
         aiMaterial *mat = new aiMaterial;
         aiString name(material.mName.empty() ? matIt->first : material.mName);
         mat->AddProperty(&name, AI_MATKEY_NAME);
 
         // store the material
         mMaterialIndexByName[matIt->first] = newMats.size();
         newMats.push_back(std::pair<Effect *, aiMaterial *>(&effect, mat));
     }
     // ScenePreprocessor generates a default material automatically if none is there.
     // All further code here in this loader works well without a valid material so
     // we can safely let it to ScenePreprocessor.
 }
 
 // ------------------------------------------------------------------------------------------------
 // Resolves the texture name for the given effect texture entry and loads the texture data
diff --git a/code/AssetLib/Collada/ColladaParser.cpp b/code/AssetLib/Collada/ColladaParser.cpp
index 37c7274f4..7aa37a112 100644
--- a/code/AssetLib/Collada/ColladaParser.cpp
+++ b/code/AssetLib/Collada/ColladaParser.cpp
@@ -219,47 +219,43 @@ std::string ColladaParser::ReadZaeManifest(ZipArchiveIOSystem &zip_archive) {
 // ------------------------------------------------------------------------------------------------
 // Convert a path read from a collada file to the usual representation
 void ColladaParser::UriDecodePath(aiString &ss) {
     // TODO: collada spec, p 22. Handle URI correctly.
     // For the moment we're just stripping the file:// away to make it work.
     // Windows doesn't seem to be able to find stuff like
     // 'file://..\LWO\LWO2\MappingModes\earthSpherical.jpg'
     if (0 == strncmp(ss.data, "file://", 7)) {
         ss.length -= 7;
         memmove(ss.data, ss.data + 7, ss.length);
         ss.data[ss.length] = '\0';
     }
 
     // Maxon Cinema Collada Export writes "file:///C:\andsoon" with three slashes...
     // I need to filter it without destroying linux paths starting with "/somewhere"
-#if defined(_MSC_VER)
     if (ss.data[0] == '/' && isalpha((unsigned char)ss.data[1]) && ss.data[2] == ':') {
-#else
-    if (ss.data[0] == '/' && isalpha((unsigned char)ss.data[1]) && ss.data[2] == ':') {
-#endif
         --ss.length;
         ::memmove(ss.data, ss.data + 1, ss.length);
         ss.data[ss.length] = 0;
     }
 
     // find and convert all %xy special chars
     char *out = ss.data;
     for (const char *it = ss.data; it != ss.data + ss.length; /**/) {
         if (*it == '%' && (it + 3) < ss.data + ss.length) {
             // separate the number to avoid dragging in chars from behind into the parsing
             char mychar[3] = { it[1], it[2], 0 };
             size_t nbr = strtoul16(mychar);
             it += 3;
             *out++ = (char)(nbr & 0xFF);
         } else {
             *out++ = *it++;
         }
     }
 
     // adjust length and terminator of the shortened string
     *out = 0;
     ai_assert(out > ss.data);
     ss.length = static_cast<ai_uint32>(out - ss.data);
 }
 
 // ------------------------------------------------------------------------------------------------
 // Reads the contents of the file
diff --git a/code/AssetLib/DXF/DXFLoader.cpp b/code/AssetLib/DXF/DXFLoader.cpp
index 49d572b0b..2e38ed976 100644
--- a/code/AssetLib/DXF/DXFLoader.cpp
+++ b/code/AssetLib/DXF/DXFLoader.cpp
@@ -522,32 +522,32 @@ void DXFImporter::ParseBlock(DXF::LineReader& reader, DXF::FileData& output) {
 // ------------------------------------------------------------------------------------------------
 void DXFImporter::ParseEntities(DXF::LineReader& reader, DXF::FileData& output) {
     // Push a new block onto the stack.
     output.blocks.push_back( DXF::Block() );
     DXF::Block& block = output.blocks.back();
 
     block.name = AI_DXF_ENTITIES_MAGIC_BLOCK;
 
     while( !reader.End() && !reader.Is(0,"ENDSEC")) {
         if (reader.Is(0,"POLYLINE")) {
             ParsePolyLine(++reader,output);
             continue;
         }
 
         else if (reader.Is(0,"INSERT")) {
             ParseInsertion(++reader,output);
             continue;
         }
 
         else if (reader.Is(0,"3DFACE") || reader.Is(0,"LINE") || reader.Is(0,"3DLINE")) {
             //http://sourceforge.net/tracker/index.php?func=detail&aid=2970566&group_id=226462&atid=1067632
             Parse3DFace(++reader, output);
             continue;
         }
 
         ++reader;
     }
 
-    ASSIMP_LOG_VERBOSE_DEBUG( "DXF: got ", block.lines.size()," polylines and ", block.insertions.size(), 
+    ASSIMP_LOG_VERBOSE_DEBUG( "DXF: got ", block.lines.size()," polylines and ", block.insertions.size(),
         " inserted blocks in ENTITIES" );
 }
 
diff --git a/code/AssetLib/DXF/DXFLoader.h b/code/AssetLib/DXF/DXFLoader.h
index 5319d2528..6649deb34 100644
--- a/code/AssetLib/DXF/DXFLoader.h
+++ b/code/AssetLib/DXF/DXFLoader.h
@@ -54,16 +54,16 @@ namespace Assimp    {
 // Forward declarations
 namespace DXF {
     class LineReader;
     struct FileData;
     struct PolyLine;
     struct Block;
     struct InsertBlock;
 
     typedef std::map<std::string, const DXF::Block*> BlockMap;
 }
 
 // ---------------------------------------------------------------------------
-/** 
+/**
  *  @brief  DXF importer implementation.
  */
 class DXFImporter : public BaseImporter {
diff --git a/code/AssetLib/FBX/FBXConverter.cpp b/code/AssetLib/FBX/FBXConverter.cpp
index f489e37a4..e0da78583 100644
--- a/code/AssetLib/FBX/FBXConverter.cpp
+++ b/code/AssetLib/FBX/FBXConverter.cpp
@@ -687,182 +687,182 @@ std::string FBXConverter::NameTransformationChainNode(const std::string &name, T
 bool FBXConverter::GenerateTransformationNodeChain(const Model &model, const std::string &name, std::vector<PotentialNode> &output_nodes,
         std::vector<PotentialNode> &post_output_nodes) {
     const PropertyTable &props = model.Props();
     const Model::RotOrder rot = model.RotationOrder();
 
     bool ok;
 
     aiMatrix4x4 chain[TransformationComp_MAXIMUM];
 
     ai_assert(TransformationComp_MAXIMUM < 32);
     std::uint32_t chainBits = 0;
     // A node won't need a node chain if it only has these.
     const std::uint32_t chainMaskSimple = (1 << TransformationComp_Translation) + (1 << TransformationComp_Scaling) + (1 << TransformationComp_Rotation);
     // A node will need a node chain if it has any of these.
     const std::uint32_t chainMaskComplex = ((1 << (TransformationComp_MAXIMUM)) - 1) - chainMaskSimple;
 
     std::fill_n(chain, static_cast<unsigned int>(TransformationComp_MAXIMUM), aiMatrix4x4());
 
     // generate transformation matrices for all the different transformation components
     const float zero_epsilon = Math::getEpsilon<float>();
     const aiVector3D all_ones(1.0f, 1.0f, 1.0f);
 
     const aiVector3D &PreRotation = PropertyGet<aiVector3D>(props, "PreRotation", ok);
     if (ok && PreRotation.SquareLength() > zero_epsilon) {
         chainBits = chainBits | (1 << TransformationComp_PreRotation);
 
         GetRotationMatrix(Model::RotOrder::RotOrder_EulerXYZ, PreRotation, chain[TransformationComp_PreRotation]);
     }
 
     const aiVector3D &PostRotation = PropertyGet<aiVector3D>(props, "PostRotation", ok);
     if (ok && PostRotation.SquareLength() > zero_epsilon) {
         chainBits = chainBits | (1 << TransformationComp_PostRotation);
 
         GetRotationMatrix(Model::RotOrder::RotOrder_EulerXYZ, PostRotation, chain[TransformationComp_PostRotation]);
     }
 
     const aiVector3D &RotationPivot = PropertyGet<aiVector3D>(props, "RotationPivot", ok);
     if (ok && RotationPivot.SquareLength() > zero_epsilon) {
         chainBits = chainBits | (1 << TransformationComp_RotationPivot) | (1 << TransformationComp_RotationPivotInverse);
 
         aiMatrix4x4::Translation(RotationPivot, chain[TransformationComp_RotationPivot]);
         aiMatrix4x4::Translation(-RotationPivot, chain[TransformationComp_RotationPivotInverse]);
     }
 
     const aiVector3D &RotationOffset = PropertyGet<aiVector3D>(props, "RotationOffset", ok);
     if (ok && RotationOffset.SquareLength() > zero_epsilon) {
         chainBits = chainBits | (1 << TransformationComp_RotationOffset);
 
         aiMatrix4x4::Translation(RotationOffset, chain[TransformationComp_RotationOffset]);
     }
 
     const aiVector3D &ScalingOffset = PropertyGet<aiVector3D>(props, "ScalingOffset", ok);
     if (ok && ScalingOffset.SquareLength() > zero_epsilon) {
         chainBits = chainBits | (1 << TransformationComp_ScalingOffset);
 
         aiMatrix4x4::Translation(ScalingOffset, chain[TransformationComp_ScalingOffset]);
     }
 
     const aiVector3D &ScalingPivot = PropertyGet<aiVector3D>(props, "ScalingPivot", ok);
     if (ok && ScalingPivot.SquareLength() > zero_epsilon) {
         chainBits = chainBits | (1 << TransformationComp_ScalingPivot) | (1 << TransformationComp_ScalingPivotInverse);
 
         aiMatrix4x4::Translation(ScalingPivot, chain[TransformationComp_ScalingPivot]);
         aiMatrix4x4::Translation(-ScalingPivot, chain[TransformationComp_ScalingPivotInverse]);
     }
 
     const aiVector3D &Translation = PropertyGet<aiVector3D>(props, "Lcl Translation", ok);
     if (ok && Translation.SquareLength() > zero_epsilon) {
         chainBits = chainBits | (1 << TransformationComp_Translation);
 
         aiMatrix4x4::Translation(Translation, chain[TransformationComp_Translation]);
     }
 
     const aiVector3D &Scaling = PropertyGet<aiVector3D>(props, "Lcl Scaling", ok);
     if (ok && (Scaling - all_ones).SquareLength() > zero_epsilon) {
         chainBits = chainBits | (1 << TransformationComp_Scaling);
 
         aiMatrix4x4::Scaling(Scaling, chain[TransformationComp_Scaling]);
     }
 
     const aiVector3D &Rotation = PropertyGet<aiVector3D>(props, "Lcl Rotation", ok);
     if (ok && Rotation.SquareLength() > zero_epsilon) {
         chainBits = chainBits | (1 << TransformationComp_Rotation);
 
         GetRotationMatrix(rot, Rotation, chain[TransformationComp_Rotation]);
     }
 
     const aiVector3D &GeometricScaling = PropertyGet<aiVector3D>(props, "GeometricScaling", ok);
     if (ok && (GeometricScaling - all_ones).SquareLength() > zero_epsilon) {
         chainBits = chainBits | (1 << TransformationComp_GeometricScaling);
         aiMatrix4x4::Scaling(GeometricScaling, chain[TransformationComp_GeometricScaling]);
         aiVector3D GeometricScalingInverse = GeometricScaling;
         bool canscale = true;
         for (unsigned int i = 0; i < 3; ++i) {
             if (std::fabs(GeometricScalingInverse[i]) > zero_epsilon) {
                 GeometricScalingInverse[i] = 1.0f / GeometricScaling[i];
             } else {
                 FBXImporter::LogError("cannot invert geometric scaling matrix with a 0.0 scale component");
                 canscale = false;
                 break;
             }
         }
         if (canscale) {
             chainBits = chainBits | (1 << TransformationComp_GeometricScalingInverse);
             aiMatrix4x4::Scaling(GeometricScalingInverse, chain[TransformationComp_GeometricScalingInverse]);
         }
     }
 
     const aiVector3D &GeometricRotation = PropertyGet<aiVector3D>(props, "GeometricRotation", ok);
     if (ok && GeometricRotation.SquareLength() > zero_epsilon) {
         chainBits = chainBits | (1 << TransformationComp_GeometricRotation) | (1 << TransformationComp_GeometricRotationInverse);
         GetRotationMatrix(rot, GeometricRotation, chain[TransformationComp_GeometricRotation]);
         GetRotationMatrix(rot, GeometricRotation, chain[TransformationComp_GeometricRotationInverse]);
         chain[TransformationComp_GeometricRotationInverse].Inverse();
     }
 
     const aiVector3D &GeometricTranslation = PropertyGet<aiVector3D>(props, "GeometricTranslation", ok);
     if (ok && GeometricTranslation.SquareLength() > zero_epsilon) {
         chainBits = chainBits | (1 << TransformationComp_GeometricTranslation) | (1 << TransformationComp_GeometricTranslationInverse);
         aiMatrix4x4::Translation(GeometricTranslation, chain[TransformationComp_GeometricTranslation]);
         aiMatrix4x4::Translation(-GeometricTranslation, chain[TransformationComp_GeometricTranslationInverse]);
     }
 
     // now, if we have more than just Translation, Scaling and Rotation,
     // we need to generate a full node chain to accommodate for assimp's
     // lack to express pivots and offsets.
     if ((chainBits & chainMaskComplex) && doc.Settings().preservePivots) {
         FBXImporter::LogInfo("generating full transformation chain for node: ", name);
 
         // query the anim_chain_bits dictionary to find out which chain elements
         // have associated node animation channels. These can not be dropped
         // even if they have identity transform in bind pose.
         NodeAnimBitMap::const_iterator it = node_anim_chain_bits.find(name);
         const unsigned int anim_chain_bitmask = (it == node_anim_chain_bits.end() ? 0 : (*it).second);
 
         unsigned int bit = 0x1;
         for (size_t i = 0; i < TransformationComp_MAXIMUM; ++i, bit <<= 1) {
             const TransformationComp comp = static_cast<TransformationComp>(i);
 
             if ((chainBits & bit) == 0 && (anim_chain_bitmask & bit) == 0) {
                 continue;
             }
 
             if (comp == TransformationComp_PostRotation) {
                 chain[i] = chain[i].Inverse();
             }
 
             PotentialNode nd;
             nd->mName.Set(NameTransformationChainNode(name, comp));
             nd->mTransformation = chain[i];
 
             // geometric inverses go in a post-node chain
             if (comp == TransformationComp_GeometricScalingInverse ||
                     comp == TransformationComp_GeometricRotationInverse ||
                     comp == TransformationComp_GeometricTranslationInverse) {
                 post_output_nodes.emplace_back(std::move(nd));
             } else {
                 output_nodes.emplace_back(std::move(nd));
             }
         }
 
         ai_assert(output_nodes.size());
         return true;
     }
 
     // else, we can just multiply the matrices together
     PotentialNode nd;
 
     // name passed to the method is already unique
     nd->mName.Set(name);
     // for (const auto &transform : chain) {
     // skip inverse chain for no preservePivots
     for (unsigned int i = TransformationComp_Translation; i < TransformationComp_MAXIMUM; i++) {
       nd->mTransformation = nd->mTransformation * chain[i];
     }
     output_nodes.push_back(std::move(nd));
     return false;
 }
-  
+
 void FBXConverter::SetupNodeMetadata(const Model &model, aiNode &nd) {
     const PropertyTable &props = model.Props();
     DirectPropertyMap unparsedProperties = props.GetUnparsedProperties();
@@ -3556,34 +3556,34 @@ void FBXConverter::TransferDataToScene() {
 void FBXConverter::ConvertOrphanedEmbeddedTextures() {
     // in C++14 it could be:
     // for (auto&& [id, object] : objects)
     for (auto &&id_and_object : doc.Objects()) {
         auto &&id = std::get<0>(id_and_object);
         auto &&object = std::get<1>(id_and_object);
         // If an object doesn't have parent
         if (doc.ConnectionsBySource().count(id) == 0) {
             const Texture *realTexture = nullptr;
             try {
                 const auto &element = object->GetElement();
                 const Token &key = element.KeyToken();
                 const char *obtype = key.begin();
                 const size_t length = static_cast<size_t>(key.end() - key.begin());
                 if (strncmp(obtype, "Texture", length) == 0) {
                     if (const Texture *texture = static_cast<const Texture *>(object->Get())) {
                         if (texture->Media() && texture->Media()->ContentLength() > 0) {
                             realTexture = texture;
                         }
-                    }    
+                    }
                 }
             } catch (...) {
                 // do nothing
             }
             if (realTexture) {
                 const Video *media = realTexture->Media();
                 unsigned int index = ConvertVideo(*media);
                 textures_converted[media] = index;
             }
         }
     }
 }
 
 // ------------------------------------------------------------------------------------------------
diff --git a/code/AssetLib/FBX/FBXConverter.h b/code/AssetLib/FBX/FBXConverter.h
index d208ab429..b9a494695 100644
--- a/code/AssetLib/FBX/FBXConverter.h
+++ b/code/AssetLib/FBX/FBXConverter.h
@@ -76,9 +76,9 @@ namespace Assimp {
 namespace FBX {
 
 class Document;
-/** 
+/**
  *  Convert a FBX #Document to #aiScene
  *  @param out Empty scene to be populated
  *  @param doc Parsed FBX document
  *  @param removeEmptyBones Will remove bones, which do not have any references to vertices.
  */
@@ -119,298 +119,298 @@ public:
 private:
     // ------------------------------------------------------------------------------------------------
     // find scene root and trigger recursive scene conversion
     void ConvertRootNode();
 
     // ------------------------------------------------------------------------------------------------
     // collect and assign child nodes
     void ConvertNodes(uint64_t id, aiNode *parent, aiNode *root_node);
 
     // ------------------------------------------------------------------------------------------------
     void ConvertLights(const Model& model, const std::string &orig_name );
 
     // ------------------------------------------------------------------------------------------------
     void ConvertCameras(const Model& model, const std::string &orig_name );
 
     // ------------------------------------------------------------------------------------------------
     void ConvertLight( const Light& light, const std::string &orig_name );
 
     // ------------------------------------------------------------------------------------------------
     void ConvertCamera( const Camera& cam, const std::string &orig_name );
 
     // ------------------------------------------------------------------------------------------------
     void GetUniqueName( const std::string &name, std::string& uniqueName );
 
     // ------------------------------------------------------------------------------------------------
     // this returns unified names usable within assimp identifiers (i.e. no space characters -
     // while these would be allowed, they are a potential trouble spot so better not use them).
     const char* NameTransformationComp(TransformationComp comp);
 
     // ------------------------------------------------------------------------------------------------
     // Returns an unique name for a node or traverses up a hierarchy until a non-empty name is found and
     // then makes this name unique
     std::string MakeUniqueNodeName(const Model* const model, const aiNode& parent);
 
     // ------------------------------------------------------------------------------------------------
     // note: this returns the REAL fbx property names
     const char* NameTransformationCompProperty(TransformationComp comp);
 
     // ------------------------------------------------------------------------------------------------
     aiVector3D TransformationCompDefaultValue(TransformationComp comp);
 
     // ------------------------------------------------------------------------------------------------
     void GetRotationMatrix(Model::RotOrder mode, const aiVector3D& rotation, aiMatrix4x4& out);
     // ------------------------------------------------------------------------------------------------
     /**
     *  checks if a node has more than just scaling, rotation and translation components
     */
     bool NeedsComplexTransformationChain(const Model& model);
 
     // ------------------------------------------------------------------------------------------------
     // note: name must be a FixNodeName() result
     std::string NameTransformationChainNode(const std::string& name, TransformationComp comp);
 
     // ------------------------------------------------------------------------------------------------
     /**
     *  note: memory for output_nodes is managed by the caller, via the PotentialNode struct.
     */
     struct PotentialNode;
     bool GenerateTransformationNodeChain(const Model& model, const std::string& name, std::vector<PotentialNode>& output_nodes, std::vector<PotentialNode>& post_output_nodes);
 
     // ------------------------------------------------------------------------------------------------
     void SetupNodeMetadata(const Model& model, aiNode& nd);
 
     // ------------------------------------------------------------------------------------------------
     void ConvertModel(const Model &model, aiNode *parent, aiNode *root_node,
                       const aiMatrix4x4 &absolute_transform);
-    
+
     // ------------------------------------------------------------------------------------------------
     // MeshGeometry -> aiMesh, return mesh index + 1 or 0 if the conversion failed
     std::vector<unsigned int>
     ConvertMesh(const MeshGeometry &mesh, const Model &model, aiNode *parent, aiNode *root_node,
                 const aiMatrix4x4 &absolute_transform);
 
     // ------------------------------------------------------------------------------------------------
     std::vector<unsigned int> ConvertLine(const LineGeometry& line, aiNode *root_node);
 
     // ------------------------------------------------------------------------------------------------
     aiMesh* SetupEmptyMesh(const Geometry& mesh, aiNode *parent);
 
     // ------------------------------------------------------------------------------------------------
     unsigned int ConvertMeshSingleMaterial(const MeshGeometry &mesh, const Model &model,
                                            const aiMatrix4x4 &absolute_transform, aiNode *parent,
                                            aiNode *root_node);
 
     // ------------------------------------------------------------------------------------------------
     std::vector<unsigned int>
     ConvertMeshMultiMaterial(const MeshGeometry &mesh, const Model &model, aiNode *parent, aiNode *root_node,
                              const aiMatrix4x4 &absolute_transform);
 
     // ------------------------------------------------------------------------------------------------
     unsigned int ConvertMeshMultiMaterial(const MeshGeometry &mesh, const Model &model, MatIndexArray::value_type index,
                                           aiNode *parent, aiNode *root_node, const aiMatrix4x4 &absolute_transform);
 
     // ------------------------------------------------------------------------------------------------
     static const unsigned int NO_MATERIAL_SEPARATION = /* std::numeric_limits<unsigned int>::max() */
         static_cast<unsigned int>(-1);
 
     // ------------------------------------------------------------------------------------------------
     /**
     *  - if materialIndex == NO_MATERIAL_SEPARATION, materials are not taken into
     *    account when determining which weights to include.
     *  - outputVertStartIndices is only used when a material index is specified, it gives for
     *    each output vertex the DOM index it maps to.
     */
     void ConvertWeights(aiMesh *out, const MeshGeometry &geo, const aiMatrix4x4 &absolute_transform,
             aiNode *parent = nullptr, unsigned int materialIndex = NO_MATERIAL_SEPARATION,
             std::vector<unsigned int> *outputVertStartIndices = nullptr);
 
     // ------------------------------------------------------------------------------------------------
     void ConvertCluster(std::vector<aiBone *> &local_mesh_bones, const Cluster *cl,
                         std::vector<size_t> &out_indices, std::vector<size_t> &index_out_indices,
                         std::vector<size_t> &count_out_indices, const aiMatrix4x4 &absolute_transform,
                         aiNode *parent );
 
     // ------------------------------------------------------------------------------------------------
     void ConvertMaterialForMesh(aiMesh* out, const Model& model, const MeshGeometry& geo,
         MatIndexArray::value_type materialIndex);
 
     // ------------------------------------------------------------------------------------------------
     unsigned int GetDefaultMaterial();
 
     // ------------------------------------------------------------------------------------------------
     // Material -> aiMaterial
     unsigned int ConvertMaterial(const Material& material, const MeshGeometry* const mesh);
 
     // ------------------------------------------------------------------------------------------------
     // Video -> aiTexture
     unsigned int ConvertVideo(const Video& video);
 
     // ------------------------------------------------------------------------------------------------
     // convert embedded texture if necessary and return actual texture path
     aiString GetTexturePath(const Texture* tex);
 
     // ------------------------------------------------------------------------------------------------
     void TrySetTextureProperties(aiMaterial* out_mat, const TextureMap& textures,
         const std::string& propName,
         aiTextureType target, const MeshGeometry* const mesh);
 
     // ------------------------------------------------------------------------------------------------
     void TrySetTextureProperties(aiMaterial* out_mat, const LayeredTextureMap& layeredTextures,
         const std::string& propName,
         aiTextureType target, const MeshGeometry* const mesh);
 
     // ------------------------------------------------------------------------------------------------
     void SetTextureProperties(aiMaterial* out_mat, const TextureMap& textures, const MeshGeometry* const mesh);
 
     // ------------------------------------------------------------------------------------------------
     void SetTextureProperties(aiMaterial* out_mat, const LayeredTextureMap& layeredTextures, const MeshGeometry* const mesh);
 
     // ------------------------------------------------------------------------------------------------
     aiColor3D GetColorPropertyFromMaterial(const PropertyTable& props, const std::string& baseName,
         bool& result);
     aiColor3D GetColorPropertyFactored(const PropertyTable& props, const std::string& colorName,
         const std::string& factorName, bool& result, bool useTemplate = true);
     aiColor3D GetColorProperty(const PropertyTable& props, const std::string& colorName,
         bool& result, bool useTemplate = true);
 
     // ------------------------------------------------------------------------------------------------
     void SetShadingPropertiesCommon(aiMaterial* out_mat, const PropertyTable& props);
     void SetShadingPropertiesRaw(aiMaterial* out_mat, const PropertyTable& props, const TextureMap& textures, const MeshGeometry* const mesh);
 
     // ------------------------------------------------------------------------------------------------
     // get the number of fps for a FrameRate enumerated value
     static double FrameRateToDouble(FileGlobalSettings::FrameRate fp, double customFPSVal = -1.0);
 
     // ------------------------------------------------------------------------------------------------
     // convert animation data to aiAnimation et al
     void ConvertAnimations();
 
     // ------------------------------------------------------------------------------------------------
     // takes a fbx node name and returns the identifier to be used in the assimp output scene.
     // the function is guaranteed to provide consistent results over multiple invocations
     // UNLESS RenameNode() is called for a particular node name.
     std::string FixNodeName(const std::string& name);
     std::string FixAnimMeshName(const std::string& name);
 
     typedef std::map<const AnimationCurveNode*, const AnimationLayer*> LayerMap;
 
     // XXX: better use multi_map ..
     typedef std::map<std::string, std::vector<const AnimationCurveNode*> > NodeMap;
 
     // ------------------------------------------------------------------------------------------------
     void ConvertAnimationStack(const AnimationStack& st);
 
     // ------------------------------------------------------------------------------------------------
     void ProcessMorphAnimDatas(std::map<std::string, morphAnimData*>* morphAnimDatas, const BlendShapeChannel* bsc, const AnimationCurveNode* node);
 
     // ------------------------------------------------------------------------------------------------
     void GenerateNodeAnimations(std::vector<aiNodeAnim*>& node_anims,
         const std::string& fixed_name,
         const std::vector<const AnimationCurveNode*>& curves,
         const LayerMap& layer_map,
         int64_t start, int64_t stop,
         double& max_time,
         double& min_time);
 
     // ------------------------------------------------------------------------------------------------
     bool IsRedundantAnimationData(const Model& target,
         TransformationComp comp,
         const std::vector<const AnimationCurveNode*>& curves);
 
     // ------------------------------------------------------------------------------------------------
     aiNodeAnim* GenerateRotationNodeAnim(const std::string& name,
         const Model& target,
         const std::vector<const AnimationCurveNode*>& curves,
         const LayerMap& layer_map,
         int64_t start, int64_t stop,
         double& max_time,
         double& min_time);
 
     // ------------------------------------------------------------------------------------------------
     aiNodeAnim* GenerateScalingNodeAnim(const std::string& name,
         const Model& /*target*/,
         const std::vector<const AnimationCurveNode*>& curves,
         const LayerMap& layer_map,
         int64_t start, int64_t stop,
         double& max_time,
         double& min_time);
 
     // ------------------------------------------------------------------------------------------------
     aiNodeAnim* GenerateTranslationNodeAnim(const std::string& name,
         const Model& /*target*/,
         const std::vector<const AnimationCurveNode*>& curves,
         const LayerMap& layer_map,
         int64_t start, int64_t stop,
         double& max_time,
         double& min_time,
         bool inverse = false);
 
     // ------------------------------------------------------------------------------------------------
     // generate node anim, extracting only Rotation, Scaling and Translation from the given chain
     aiNodeAnim* GenerateSimpleNodeAnim(const std::string& name,
         const Model& target,
         NodeMap::const_iterator chain[TransformationComp_MAXIMUM],
         NodeMap::const_iterator iterEnd,
         int64_t start, int64_t stop,
         double& maxTime,
         double& minTime);
 
     // key (time), value, mapto (component index)
     typedef std::tuple<std::shared_ptr<KeyTimeList>, std::shared_ptr<KeyValueList>, unsigned int > KeyFrameList;
     typedef std::vector<KeyFrameList> KeyFrameListList;
 
     // ------------------------------------------------------------------------------------------------
     KeyFrameListList GetKeyframeList(const std::vector<const AnimationCurveNode*>& nodes, int64_t start, int64_t stop);
 
     // ------------------------------------------------------------------------------------------------
     KeyTimeList GetKeyTimeList(const KeyFrameListList& inputs);
 
     // ------------------------------------------------------------------------------------------------
     void InterpolateKeys(aiVectorKey* valOut, const KeyTimeList& keys, const KeyFrameListList& inputs,
         const aiVector3D& def_value,
         double& max_time,
         double& min_time);
 
     // ------------------------------------------------------------------------------------------------
     void InterpolateKeys(aiQuatKey* valOut, const KeyTimeList& keys, const KeyFrameListList& inputs,
         const aiVector3D& def_value,
         double& maxTime,
         double& minTime,
         Model::RotOrder order);
 
     // ------------------------------------------------------------------------------------------------
     // euler xyz -> quat
     aiQuaternion EulerToQuaternion(const aiVector3D& rot, Model::RotOrder order);
 
     // ------------------------------------------------------------------------------------------------
     void ConvertScaleKeys(aiNodeAnim* na, const std::vector<const AnimationCurveNode*>& nodes, const LayerMap& /*layers*/,
         int64_t start, int64_t stop,
         double& maxTime,
         double& minTime);
 
     // ------------------------------------------------------------------------------------------------
     void ConvertTranslationKeys(aiNodeAnim* na, const std::vector<const AnimationCurveNode*>& nodes,
         const LayerMap& /*layers*/,
         int64_t start, int64_t stop,
         double& maxTime,
         double& minTime);
 
     // ------------------------------------------------------------------------------------------------
     void ConvertRotationKeys(aiNodeAnim* na, const std::vector<const AnimationCurveNode*>& nodes,
         const LayerMap& /*layers*/,
         int64_t start, int64_t stop,
         double& maxTime,
         double& minTime,
         Model::RotOrder order);
 
     // ------------------------------------------------------------------------------------------------
     // Copy global geometric data and some information about the source asset into scene metadata.
     void ConvertGlobalSettings();
 
     // ------------------------------------------------------------------------------------------------
     // copy generated meshes, animations, lights, cameras and textures to the output scene
     void TransferDataToScene();
 
     // ------------------------------------------------------------------------------------------------
     // FBX file could have embedded textures not connected to anything
     void ConvertOrphanedEmbeddedTextures();
diff --git a/code/AssetLib/FBX/FBXDocument.cpp b/code/AssetLib/FBX/FBXDocument.cpp
index 0c4435348..8e0439e18 100644
--- a/code/AssetLib/FBX/FBXDocument.cpp
+++ b/code/AssetLib/FBX/FBXDocument.cpp
@@ -635,10 +635,10 @@ std::vector<const Connection*> Document::GetConnectionsBySourceSequenced(uint64_
 }
 
 // ------------------------------------------------------------------------------------------------
-std::vector<const Connection*> Document::GetConnectionsBySourceSequenced(uint64_t source, 
+std::vector<const Connection*> Document::GetConnectionsBySourceSequenced(uint64_t source,
         const char* const* classnames, size_t count) const
 {
     return GetConnectionsSequenced(source, true, ConnectionsBySource(),classnames, count);
 }
 
 // ------------------------------------------------------------------------------------------------
diff --git a/code/AssetLib/FBX/FBXExportNode.h b/code/AssetLib/FBX/FBXExportNode.h
index 6ef27972d..3aca98939 100644
--- a/code/AssetLib/FBX/FBXExportNode.h
+++ b/code/AssetLib/FBX/FBXExportNode.h
@@ -60,11 +60,11 @@ namespace FBX {
 }
 
 class FBX::Node {
-public: 
+public:
     // TODO: accessors
     std::string name; // node name
     std::vector<FBX::FBXExportProperty> properties; // node properties
     std::vector<FBX::Node> children; // child nodes
 
     // some nodes always pretend they have children...
     bool force_has_children = false;
diff --git a/code/AssetLib/FBX/FBXExporter.cpp b/code/AssetLib/FBX/FBXExporter.cpp
index c19c593dd..84a77e18d 100644
--- a/code/AssetLib/FBX/FBXExporter.cpp
+++ b/code/AssetLib/FBX/FBXExporter.cpp
@@ -496,29 +496,29 @@ void FBXExporter::WriteGlobalSettings ()
 void FBXExporter::WriteDocuments ()
 {
     if (!binary) {
         WriteAsciiSectionHeader("Documents Description");
     }
-    
+
     // not sure what the use of multiple documents would be,
     // or whether any end-application supports it
     FBX::Node docs("Documents");
     docs.AddChild("Count", int32_t(1));
     FBX::Node doc("Document");
 
     // generate uid
     int64_t uid = generate_uid();
     doc.AddProperties(uid, "", "Scene");
     FBX::Node p("Properties70");
     p.AddP70("SourceObject", "object", "", ""); // what is this even for?
     p.AddP70string("ActiveAnimStackName", ""); // should do this properly?
     doc.AddChild(p);
 
     // UID for root node in scene hierarchy.
     // always set to 0 in the case of a single document.
     // not sure what happens if more than one document exists,
     // but that won't matter to us as we're exporting a single scene.
     doc.AddChild("RootNode", int64_t(0));
 
     docs.AddChild(doc);
     docs.Dump(outfile, binary, 0);
 }
@@ -1076,1390 +1076,1390 @@ int64_t to_ktime(double time) {
 void FBXExporter::WriteObjects ()
 {
     if (!binary) {
         WriteAsciiSectionHeader("Object properties");
     }
     // numbers should match those given in definitions! make sure to check
     StreamWriterLE outstream(outfile);
     FBX::Node object_node("Objects");
     int indent = 0;
     object_node.Begin(outstream, binary, indent);
     object_node.EndProperties(outstream, binary, indent);
     object_node.BeginChildren(outstream, binary, indent);
 
     bool bJoinIdenticalVertices = mProperties->GetPropertyBool("bJoinIdenticalVertices", true);
     std::vector<std::vector<int32_t>> vVertexIndice;//save vertex_indices as it is needed later
 
     // geometry (aiMesh)
     mesh_uids.clear();
     indent = 1;
     for (size_t mi = 0; mi < mScene->mNumMeshes; ++mi) {
         // it's all about this mesh
         aiMesh* m = mScene->mMeshes[mi];
 
         // start the node record
         FBX::Node n("Geometry");
         int64_t uid = generate_uid();
         mesh_uids.push_back(uid);
         n.AddProperty(uid);
         n.AddProperty(FBX::SEPARATOR + "Geometry");
         n.AddProperty("Mesh");
         n.Begin(outstream, binary, indent);
         n.DumpProperties(outstream, binary, indent);
         n.EndProperties(outstream, binary, indent);
         n.BeginChildren(outstream, binary, indent);
         indent = 2;
 
         // output vertex data - each vertex should be unique (probably)
         std::vector<double> flattened_vertices;
         // index of original vertex in vertex data vector
         std::vector<int32_t> vertex_indices;
         // map of vertex value to its index in the data vector
         std::map<aiVector3D,size_t> index_by_vertex_value;
         if(bJoinIdenticalVertices){
             int32_t index = 0;
             for (size_t vi = 0; vi < m->mNumVertices; ++vi) {
                 aiVector3D vtx = m->mVertices[vi];
                 auto elem = index_by_vertex_value.find(vtx);
                 if (elem == index_by_vertex_value.end()) {
                     vertex_indices.push_back(index);
                     index_by_vertex_value[vtx] = index;
                     flattened_vertices.push_back(vtx[0]);
                     flattened_vertices.push_back(vtx[1]);
                     flattened_vertices.push_back(vtx[2]);
                     ++index;
                 } else {
                     vertex_indices.push_back(int32_t(elem->second));
                 }
             }
         }
         else { // do not join vertex, respect the export flag
             vertex_indices.resize(m->mNumVertices);
             std::iota(vertex_indices.begin(), vertex_indices.end(), 0);
             for(unsigned int v = 0; v < m->mNumVertices; ++ v) {
                 aiVector3D vtx = m->mVertices[v];
                 flattened_vertices.push_back(vtx.x);
                 flattened_vertices.push_back(vtx.y);
                 flattened_vertices.push_back(vtx.z);
             }
         }
         vVertexIndice.push_back(vertex_indices);
 
         FBX::Node::WritePropertyNode(
             "Vertices", flattened_vertices, outstream, binary, indent
         );
 
         // output polygon data as a flattened array of vertex indices.
         // the last vertex index of each polygon is negated and - 1
         std::vector<int32_t> polygon_data;
         for (size_t fi = 0; fi < m->mNumFaces; ++fi) {
             const aiFace &f = m->mFaces[fi];
             for (size_t pvi = 0; pvi < f.mNumIndices - 1; ++pvi) {
                 polygon_data.push_back(vertex_indices[f.mIndices[pvi]]);
             }
             polygon_data.push_back(
                 -1 - vertex_indices[f.mIndices[f.mNumIndices-1]]
             );
         }
         FBX::Node::WritePropertyNode(
             "PolygonVertexIndex", polygon_data, outstream, binary, indent
         );
 
         // here could be edges but they're insane.
         // it's optional anyway, so let's ignore it.
 
         FBX::Node::WritePropertyNode(
             "GeometryVersion", int32_t(124), outstream, binary, indent
         );
 
         // normals, if any
         if (m->HasNormals()) {
             FBX::Node normals("LayerElementNormal", int32_t(0));
             normals.Begin(outstream, binary, indent);
             normals.DumpProperties(outstream, binary, indent);
             normals.EndProperties(outstream, binary, indent);
             normals.BeginChildren(outstream, binary, indent);
             indent = 3;
             FBX::Node::WritePropertyNode(
                 "Version", int32_t(101), outstream, binary, indent
             );
             FBX::Node::WritePropertyNode(
                 "Name", "", outstream, binary, indent
             );
             FBX::Node::WritePropertyNode(
                 "MappingInformationType", "ByPolygonVertex",
                 outstream, binary, indent
             );
             // TODO: vertex-normals or indexed normals when appropriate
             FBX::Node::WritePropertyNode(
                 "ReferenceInformationType", "Direct",
                 outstream, binary, indent
             );
             std::vector<double> normal_data;
             normal_data.reserve(3 * polygon_data.size());
             for (size_t fi = 0; fi < m->mNumFaces; ++fi) {
                 const aiFace &f = m->mFaces[fi];
                 for (size_t pvi = 0; pvi < f.mNumIndices; ++pvi) {
                     const aiVector3D &curN = m->mNormals[f.mIndices[pvi]];
                     normal_data.push_back(curN.x);
                     normal_data.push_back(curN.y);
                     normal_data.push_back(curN.z);
                 }
             }
             FBX::Node::WritePropertyNode(
                 "Normals", normal_data, outstream, binary, indent
             );
             // note: version 102 has a NormalsW also... not sure what it is,
             // so we can stick with version 101 for now.
             indent = 2;
             normals.End(outstream, binary, indent, true);
         }
 
         // colors, if any
         // TODO only one color channel currently
         const int32_t colorChannelIndex = 0;
         if (m->HasVertexColors(colorChannelIndex)) {
             FBX::Node vertexcolors("LayerElementColor", int32_t(colorChannelIndex));
             vertexcolors.Begin(outstream, binary, indent);
             vertexcolors.DumpProperties(outstream, binary, indent);
             vertexcolors.EndProperties(outstream, binary, indent);
             vertexcolors.BeginChildren(outstream, binary, indent);
             indent = 3;
             FBX::Node::WritePropertyNode(
                 "Version", int32_t(101), outstream, binary, indent
             );
             char layerName[8];
             sprintf(layerName, "COLOR_%d", colorChannelIndex);
             FBX::Node::WritePropertyNode(
                 "Name", (const char*)layerName, outstream, binary, indent
             );
             FBX::Node::WritePropertyNode(
                 "MappingInformationType", "ByPolygonVertex",
                 outstream, binary, indent
             );
             FBX::Node::WritePropertyNode(
                 "ReferenceInformationType", "Direct",
                 outstream, binary, indent
             );
             std::vector<double> color_data;
             color_data.reserve(4 * polygon_data.size());
             for (size_t fi = 0; fi < m->mNumFaces; ++fi) {
                 const aiFace &f = m->mFaces[fi];
                 for (size_t pvi = 0; pvi < f.mNumIndices; ++pvi) {
                     const aiColor4D &c = m->mColors[colorChannelIndex][f.mIndices[pvi]];
                     color_data.push_back(c.r);
                     color_data.push_back(c.g);
                     color_data.push_back(c.b);
                     color_data.push_back(c.a);
                 }
             }
             FBX::Node::WritePropertyNode(
                 "Colors", color_data, outstream, binary, indent
             );
             indent = 2;
             vertexcolors.End(outstream, binary, indent, true);
         }
-        
+
         // uvs, if any
         for (size_t uvi = 0; uvi < m->GetNumUVChannels(); ++uvi) {
             if (m->mNumUVComponents[uvi] > 2) {
                 // FBX only supports 2-channel UV maps...
                 // or at least i'm not sure how to indicate a different number
                 std::stringstream err;
                 err << "Only 2-channel UV maps supported by FBX,";
                 err << " but mesh " << mi;
                 if (m->mName.length) {
                     err << " (" << m->mName.C_Str() << ")";
                 }
                 err << " UV map " << uvi;
                 err << " has " << m->mNumUVComponents[uvi];
                 err << " components! Data will be preserved,";
                 err << " but may be incorrectly interpreted on load.";
                 ASSIMP_LOG_WARN(err.str());
             }
             FBX::Node uv("LayerElementUV", int32_t(uvi));
             uv.Begin(outstream, binary, indent);
             uv.DumpProperties(outstream, binary, indent);
             uv.EndProperties(outstream, binary, indent);
             uv.BeginChildren(outstream, binary, indent);
             indent = 3;
             FBX::Node::WritePropertyNode(
                 "Version", int32_t(101), outstream, binary, indent
             );
             // it doesn't seem like assimp keeps the uv map name,
             // so just leave it blank.
             FBX::Node::WritePropertyNode(
                 "Name", "", outstream, binary, indent
             );
             FBX::Node::WritePropertyNode(
                 "MappingInformationType", "ByPolygonVertex",
                 outstream, binary, indent
             );
             FBX::Node::WritePropertyNode(
                 "ReferenceInformationType", "IndexToDirect",
                 outstream, binary, indent
             );
 
             std::vector<double> uv_data;
             std::vector<int32_t> uv_indices;
             std::map<aiVector3D,int32_t> index_by_uv;
             int32_t index = 0;
             for (size_t fi = 0; fi < m->mNumFaces; ++fi) {
                 const aiFace &f = m->mFaces[fi];
                 for (size_t pvi = 0; pvi < f.mNumIndices; ++pvi) {
                     const aiVector3D &curUv =
                         m->mTextureCoords[uvi][f.mIndices[pvi]];
                     auto elem = index_by_uv.find(curUv);
                     if (elem == index_by_uv.end()) {
                         index_by_uv[curUv] = index;
                         uv_indices.push_back(index);
                         for (unsigned int x = 0; x < m->mNumUVComponents[uvi]; ++x) {
                             uv_data.push_back(curUv[x]);
                         }
                         ++index;
                     } else {
                         uv_indices.push_back(elem->second);
                     }
                 }
             }
             FBX::Node::WritePropertyNode(
                 "UV", uv_data, outstream, binary, indent
             );
             FBX::Node::WritePropertyNode(
                 "UVIndex", uv_indices, outstream, binary, indent
             );
             indent = 2;
             uv.End(outstream, binary, indent, true);
         }
 
         // i'm not really sure why this material section exists,
         // as the material is linked via "Connections".
         // it seems to always have the same "0" value.
         FBX::Node mat("LayerElementMaterial", int32_t(0));
         mat.AddChild("Version", int32_t(101));
         mat.AddChild("Name", "");
         mat.AddChild("MappingInformationType", "AllSame");
         mat.AddChild("ReferenceInformationType", "IndexToDirect");
         std::vector<int32_t> mat_indices = {0};
         mat.AddChild("Materials", mat_indices);
         mat.Dump(outstream, binary, indent);
 
         // finally we have the layer specifications,
         // which select the normals / UV set / etc to use.
         // TODO: handle multiple uv sets correctly?
         FBX::Node layer("Layer", int32_t(0));
         layer.AddChild("Version", int32_t(100));
         FBX::Node le("LayerElement");
         le.AddChild("Type", "LayerElementNormal");
         le.AddChild("TypedIndex", int32_t(0));
         layer.AddChild(le);
         // TODO only 1 color channel currently
         le = FBX::Node("LayerElement");
         le.AddChild("Type", "LayerElementColor");
         le.AddChild("TypedIndex", int32_t(0));
         layer.AddChild(le);
         le = FBX::Node("LayerElement");
         le.AddChild("Type", "LayerElementMaterial");
         le.AddChild("TypedIndex", int32_t(0));
         layer.AddChild(le);
         le = FBX::Node("LayerElement");
         le.AddChild("Type", "LayerElementUV");
         le.AddChild("TypedIndex", int32_t(0));
         layer.AddChild(le);
         layer.Dump(outstream, binary, indent);
 
         for(unsigned int lr = 1; lr < m->GetNumUVChannels(); ++ lr)
         {
             FBX::Node layerExtra("Layer", int32_t(lr));
             layerExtra.AddChild("Version", int32_t(100));
             FBX::Node leExtra("LayerElement");
             leExtra.AddChild("Type", "LayerElementUV");
             leExtra.AddChild("TypedIndex", int32_t(lr));
             layerExtra.AddChild(leExtra);
             layerExtra.Dump(outstream, binary, indent);
         }
         // finish the node record
         indent = 1;
         n.End(outstream, binary, indent, true);
     }
 
 
     // aiMaterial
     material_uids.clear();
     for (size_t i = 0; i < mScene->mNumMaterials; ++i) {
         // it's all about this material
         aiMaterial* m = mScene->mMaterials[i];
 
         // these are used to receive material data
         float f; aiColor3D c;
 
         // start the node record
         FBX::Node n("Material");
 
         int64_t uid = generate_uid();
         material_uids.push_back(uid);
         n.AddProperty(uid);
 
         aiString name;
         m->Get(AI_MATKEY_NAME, name);
         n.AddProperty(name.C_Str() + FBX::SEPARATOR + "Material");
 
         n.AddProperty("");
 
         n.AddChild("Version", int32_t(102));
         f = 0;
         m->Get(AI_MATKEY_SHININESS, f);
         bool phong = (f > 0);
         if (phong) {
             n.AddChild("ShadingModel", "phong");
         } else {
             n.AddChild("ShadingModel", "lambert");
         }
         n.AddChild("MultiLayer", int32_t(0));
 
         FBX::Node p("Properties70");
 
         // materials exported using the FBX SDK have two sets of fields.
         // there are the properties specified in the PropertyTemplate,
         // which are those supported by the modernFBX SDK,
         // and an extra set of properties with simpler names.
         // The extra properties are a legacy material system from pre-2009.
         //
         // In the modern system, each property has "color" and "factor".
         // Generally the interpretation of these seems to be
         // that the colour is multiplied by the factor before use,
         // but this is not always clear-cut.
         //
         // Usually assimp only stores the colour,
         // so we can just leave the factors at the default "1.0".
 
         // first we can export the "standard" properties
         if (m->Get(AI_MATKEY_COLOR_AMBIENT, c) == aiReturn_SUCCESS) {
             p.AddP70colorA("AmbientColor", c.r, c.g, c.b);
             //p.AddP70numberA("AmbientFactor", 1.0);
         }
         if (m->Get(AI_MATKEY_COLOR_DIFFUSE, c) == aiReturn_SUCCESS) {
             p.AddP70colorA("DiffuseColor", c.r, c.g, c.b);
             //p.AddP70numberA("DiffuseFactor", 1.0);
         }
         if (m->Get(AI_MATKEY_COLOR_TRANSPARENT, c) == aiReturn_SUCCESS) {
             // "TransparentColor" / "TransparencyFactor"...
             // thanks FBX, for your insightful interpretation of consistency
             p.AddP70colorA("TransparentColor", c.r, c.g, c.b);
             // TransparencyFactor defaults to 0.0, so set it to 1.0.
             // note: Maya always sets this to 1.0,
             // so we can't use it sensibly as "Opacity".
             // In stead we rely on the legacy "Opacity" value, below.
             // Blender also relies on "Opacity" not "TransparencyFactor",
             // probably for a similar reason.
             p.AddP70numberA("TransparencyFactor", 1.0);
         }
         if (m->Get(AI_MATKEY_COLOR_REFLECTIVE, c) == aiReturn_SUCCESS) {
             p.AddP70colorA("ReflectionColor", c.r, c.g, c.b);
         }
         if (m->Get(AI_MATKEY_REFLECTIVITY, f) == aiReturn_SUCCESS) {
             p.AddP70numberA("ReflectionFactor", f);
         }
         if (phong) {
             if (m->Get(AI_MATKEY_COLOR_SPECULAR, c) == aiReturn_SUCCESS) {
                 p.AddP70colorA("SpecularColor", c.r, c.g, c.b);
             }
             if (m->Get(AI_MATKEY_SHININESS_STRENGTH, f) == aiReturn_SUCCESS) {
                 p.AddP70numberA("ShininessFactor", f);
             }
             if (m->Get(AI_MATKEY_SHININESS, f) == aiReturn_SUCCESS) {
                 p.AddP70numberA("ShininessExponent", f);
             }
             if (m->Get(AI_MATKEY_REFLECTIVITY, f) == aiReturn_SUCCESS) {
                 p.AddP70numberA("ReflectionFactor", f);
             }
         }
 
         // Now the legacy system.
         // For safety let's include it.
         // thrse values don't exist in the property template,
         // and usually are completely ignored when loading.
         // One notable exception is the "Opacity" property,
         // which Blender uses as (1.0 - alpha).
         c.r = 0.0f; c.g = 0.0f; c.b = 0.0f;
         m->Get(AI_MATKEY_COLOR_EMISSIVE, c);
         p.AddP70vector("Emissive", c.r, c.g, c.b);
         c.r = 0.2f; c.g = 0.2f; c.b = 0.2f;
         m->Get(AI_MATKEY_COLOR_AMBIENT, c);
         p.AddP70vector("Ambient", c.r, c.g, c.b);
         c.r = 0.8f; c.g = 0.8f; c.b = 0.8f;
         m->Get(AI_MATKEY_COLOR_DIFFUSE, c);
         p.AddP70vector("Diffuse", c.r, c.g, c.b);
         // The FBX SDK determines "Opacity" from transparency colour (RGB)
         // and factor (F) as: O = (1.0 - F * ((R + G + B) / 3)).
         // However we actually have an opacity value,
         // so we should take it from AI_MATKEY_OPACITY if possible.
         // It might make more sense to use TransparencyFactor,
         // but Blender actually loads "Opacity" correctly, so let's use it.
         f = 1.0f;
         if (m->Get(AI_MATKEY_COLOR_TRANSPARENT, c) == aiReturn_SUCCESS) {
             f = 1.0f - ((c.r + c.g + c.b) / 3.0f);
         }
         m->Get(AI_MATKEY_OPACITY, f);
         p.AddP70double("Opacity", f);
         if (phong) {
             // specular color is multiplied by shininess_strength
             c.r = 0.2f; c.g = 0.2f; c.b = 0.2f;
             m->Get(AI_MATKEY_COLOR_SPECULAR, c);
             f = 1.0f;
             m->Get(AI_MATKEY_SHININESS_STRENGTH, f);
             p.AddP70vector("Specular", f*c.r, f*c.g, f*c.b);
             f = 20.0f;
             m->Get(AI_MATKEY_SHININESS, f);
             p.AddP70double("Shininess", f);
             // Legacy "Reflectivity" is F*F*((R+G+B)/3),
             // where F is the proportion of light reflected (AKA reflectivity),
             // and RGB is the reflective colour of the material.
             // No idea why, but we might as well set it the same way.
             f = 0.0f;
             m->Get(AI_MATKEY_REFLECTIVITY, f);
             c.r = 1.0f, c.g = 1.0f, c.b = 1.0f;
             m->Get(AI_MATKEY_COLOR_REFLECTIVE, c);
             p.AddP70double("Reflectivity", f*f*((c.r+c.g+c.b)/3.0));
         }
 
         n.AddChild(p);
 
         n.Dump(outstream, binary, indent);
     }
 
     // we need to look up all the images we're using,
     // so we can generate uids, and eliminate duplicates.
     std::map<std::string, int64_t> uid_by_image;
     for (size_t i = 0; i < mScene->mNumMaterials; ++i) {
         aiString texpath;
         aiMaterial* mat = mScene->mMaterials[i];
         for (
             size_t tt = aiTextureType_DIFFUSE;
             tt < aiTextureType_UNKNOWN;
             ++tt
         ){
             const aiTextureType textype = static_cast<aiTextureType>(tt);
             const size_t texcount = mat->GetTextureCount(textype);
             for (size_t j = 0; j < texcount; ++j) {
                 mat->GetTexture(textype, (unsigned int)j, &texpath);
                 const std::string texstring = texpath.C_Str();
                 auto elem = uid_by_image.find(texstring);
                 if (elem == uid_by_image.end()) {
                     uid_by_image[texstring] = generate_uid();
                 }
             }
         }
     }
 
     // FbxVideo - stores images used by textures.
     for (const auto &it : uid_by_image) {
         FBX::Node n("Video");
         const int64_t& uid = it.second;
         const std::string name = ""; // TODO: ... name???
         n.AddProperties(uid, name + FBX::SEPARATOR + "Video", "Clip");
         n.AddChild("Type", "Clip");
         FBX::Node p("Properties70");
         // TODO: get full path... relative path... etc... ugh...
         // for now just use the same path for everything,
         // and hopefully one of them will work out.
         std::string path = it.first;
         // try get embedded texture
         const aiTexture* embedded_texture = mScene->GetEmbeddedTexture(it.first.c_str());
         if (embedded_texture != nullptr) {
             // change the path (use original filename, if available. If name is empty, concatenate texture index with file extension)
             std::stringstream newPath;
             if (embedded_texture->mFilename.length > 0) {
                 newPath << embedded_texture->mFilename.C_Str();
             } else if (embedded_texture->achFormatHint[0]) {
                 int texture_index = std::stoi(path.substr(1, path.size() - 1));
                 newPath << texture_index << "." << embedded_texture->achFormatHint;
             }
             path = newPath.str();
             // embed the texture
             size_t texture_size = static_cast<size_t>(embedded_texture->mWidth * std::max(embedded_texture->mHeight, 1u));
             if (binary) {
                 // embed texture as binary data
                 std::vector<uint8_t> tex_data;
                 tex_data.resize(texture_size);
                 memcpy(&tex_data[0], (char*)embedded_texture->pcData, texture_size);
                 n.AddChild("Content", tex_data);
             } else {
                 // embed texture in base64 encoding
                 std::string encoded_texture = FBX::Util::EncodeBase64((char*)embedded_texture->pcData, texture_size);
                 n.AddChild("Content", encoded_texture);
             }
         }
         p.AddP70("Path", "KString", "XRefUrl", "", path);
         n.AddChild(p);
         n.AddChild("UseMipMap", int32_t(0));
         n.AddChild("Filename", path);
         n.AddChild("RelativeFilename", path);
         n.Dump(outstream, binary, indent);
     }
 
     // Textures
     // referenced by material_index/texture_type pairs.
     std::map<std::pair<size_t,size_t>,int64_t> texture_uids;
     const std::map<aiTextureType,std::string> prop_name_by_tt = {
         {aiTextureType_DIFFUSE,      "DiffuseColor"},
         {aiTextureType_SPECULAR,     "SpecularColor"},
         {aiTextureType_AMBIENT,      "AmbientColor"},
         {aiTextureType_EMISSIVE,     "EmissiveColor"},
         {aiTextureType_HEIGHT,       "Bump"},
         {aiTextureType_NORMALS,      "NormalMap"},
         {aiTextureType_SHININESS,    "ShininessExponent"},
         {aiTextureType_OPACITY,      "TransparentColor"},
         {aiTextureType_DISPLACEMENT, "DisplacementColor"},
         //{aiTextureType_LIGHTMAP, "???"},
         {aiTextureType_REFLECTION,   "ReflectionColor"}
         //{aiTextureType_UNKNOWN, ""}
     };
     for (size_t i = 0; i < mScene->mNumMaterials; ++i) {
         // textures are attached to materials
         aiMaterial* mat = mScene->mMaterials[i];
         int64_t material_uid = material_uids[i];
 
         for (
             size_t j = aiTextureType_DIFFUSE;
             j < aiTextureType_UNKNOWN;
             ++j
         ) {
             const aiTextureType tt = static_cast<aiTextureType>(j);
             size_t n = mat->GetTextureCount(tt);
 
             if (n < 1) { // no texture of this type
                 continue;
             }
 
             if (n > 1) {
                 // TODO: multilayer textures
                 std::stringstream err;
                 err << "Multilayer textures not supported (for now),";
                 err << " skipping texture type " << j;
                 err << " of material " << i;
                 ASSIMP_LOG_WARN(err.str());
             }
 
             // get image path for this (single-image) texture
             aiString tpath;
             if (mat->GetTexture(tt, 0, &tpath) != aiReturn_SUCCESS) {
                 std::stringstream err;
                 err << "Failed to get texture 0 for texture of type " << tt;
                 err << " on material " << i;
                 err << ", however GetTextureCount returned 1.";
                 throw DeadlyExportError(err.str());
             }
             const std::string texture_path(tpath.C_Str());
 
             // get connected image uid
             auto elem = uid_by_image.find(texture_path);
             if (elem == uid_by_image.end()) {
                 // this should never happen
                 std::stringstream err;
                 err << "Failed to find video element for texture with path";
                 err << " \"" << texture_path << "\"";
                 err << ", type " << j << ", material " << i;
                 throw DeadlyExportError(err.str());
             }
             const int64_t image_uid = elem->second;
 
             // get the name of the material property to connect to
             auto elem2 = prop_name_by_tt.find(tt);
             if (elem2 == prop_name_by_tt.end()) {
                 // don't know how to handle this type of texture,
                 // so skip it.
                 std::stringstream err;
                 err << "Not sure how to handle texture of type " << j;
                 err << " on material " << i;
                 err << ", skipping...";
                 ASSIMP_LOG_WARN(err.str());
                 continue;
             }
             const std::string& prop_name = elem2->second;
 
             // generate a uid for this texture
             const int64_t texture_uid = generate_uid();
 
             // link the texture to the material
             connections.emplace_back(
                 "C", "OP", texture_uid, material_uid, prop_name
             );
 
             // link the image data to the texture
             connections.emplace_back("C", "OO", image_uid, texture_uid);
 
             aiUVTransform trafo;
             unsigned int max = sizeof(aiUVTransform);
             aiGetMaterialFloatArray(mat, AI_MATKEY_UVTRANSFORM(aiTextureType_DIFFUSE, 0), (ai_real *)&trafo, &max);
 
             // now write the actual texture node
             FBX::Node tnode("Texture");
             // TODO: some way to determine texture name?
             const std::string texture_name = "" + FBX::SEPARATOR + "Texture";
             tnode.AddProperties(texture_uid, texture_name, "");
             // there really doesn't seem to be a better type than this:
             tnode.AddChild("Type", "TextureVideoClip");
             tnode.AddChild("Version", int32_t(202));
             tnode.AddChild("TextureName", texture_name);
             FBX::Node p("Properties70");
             p.AddP70vectorA("Translation", trafo.mTranslation[0], trafo.mTranslation[1], 0.0);
             p.AddP70vectorA("Rotation", 0, 0, trafo.mRotation);
             p.AddP70vectorA("Scaling", trafo.mScaling[0], trafo.mScaling[1], 0.0);
             p.AddP70enum("CurrentTextureBlendMode", 0); // TODO: verify
             //p.AddP70string("UVSet", ""); // TODO: how should this work?
             p.AddP70bool("UseMaterial", 1);
             tnode.AddChild(p);
             // can't easily detrmine which texture path will be correct,
             // so just store what we have in every field.
             // these being incorrect is a common problem with FBX anyway.
             tnode.AddChild("FileName", texture_path);
             tnode.AddChild("RelativeFilename", texture_path);
             tnode.AddChild("ModelUVTranslation", double(0.0), double(0.0));
             tnode.AddChild("ModelUVScaling", double(1.0), double(1.0));
             tnode.AddChild("Texture_Alpha_Source", "None");
             tnode.AddChild(
                 "Cropping", int32_t(0), int32_t(0), int32_t(0), int32_t(0)
             );
             tnode.Dump(outstream, binary, indent);
         }
     }
 
     // Blendshapes, if any
     for (size_t mi = 0; mi < mScene->mNumMeshes; ++mi) {
       const aiMesh* m = mScene->mMeshes[mi];
       if (m->mNumAnimMeshes == 0) {
         continue;
       }
       // make a deformer for this mesh
       int64_t deformer_uid = generate_uid();
       FBX::Node dnode("Deformer");
       dnode.AddProperties(deformer_uid, m->mName.data + FBX::SEPARATOR + "Blendshapes", "BlendShape");
       dnode.AddChild("Version", int32_t(101));
       dnode.Dump(outstream, binary, indent);
       // connect it
       connections.emplace_back("C", "OO", deformer_uid, mesh_uids[mi]);
       std::vector<int32_t> vertex_indices = vVertexIndice[mi];
 
       for (unsigned int am = 0; am < m->mNumAnimMeshes; ++am) {
         aiAnimMesh *pAnimMesh = m->mAnimMeshes[am];
         std::string blendshape_name = pAnimMesh->mName.data;
 
         // start the node record
         FBX::Node bsnode("Geometry");
         int64_t blendshape_uid = generate_uid();
         mesh_uids.push_back(blendshape_uid);
         bsnode.AddProperty(blendshape_uid);
         bsnode.AddProperty(blendshape_name + FBX::SEPARATOR + "Blendshape");
         bsnode.AddProperty("Shape");
-        bsnode.AddChild("Version", int32_t(100));        
+        bsnode.AddChild("Version", int32_t(100));
         bsnode.Begin(outstream, binary, indent);
         bsnode.DumpProperties(outstream, binary, indent);
         bsnode.EndProperties(outstream, binary, indent);
         bsnode.BeginChildren(outstream, binary, indent);
         indent++;
         if (pAnimMesh->HasPositions()) {
           std::vector<int32_t>shape_indices;
           std::vector<double>pPositionDiff;
           std::vector<double>pNormalDiff;
 
           for (unsigned int vt = 0; vt < vertex_indices.size(); ++vt) {
               aiVector3D pDiff = (pAnimMesh->mVertices[vertex_indices[vt]] - m->mVertices[vertex_indices[vt]]);
               if(pDiff.Length()>1e-8){
                 shape_indices.push_back(vertex_indices[vt]);
                 pPositionDiff.push_back(pDiff[0]);
                 pPositionDiff.push_back(pDiff[1]);
                 pPositionDiff.push_back(pDiff[2]);
 
                 if (pAnimMesh->HasNormals()) {
                     aiVector3D nDiff = (pAnimMesh->mNormals[vertex_indices[vt]] - m->mNormals[vertex_indices[vt]]);
                     pNormalDiff.push_back(nDiff[0]);
                     pNormalDiff.push_back(nDiff[1]);
                     pNormalDiff.push_back(nDiff[2]);
                 }
               }
           }
 
           FBX::Node::WritePropertyNode(
               "Indexes", shape_indices, outstream, binary, indent
           );
 
           FBX::Node::WritePropertyNode(
               "Vertices", pPositionDiff, outstream, binary, indent
           );
 
           if (pNormalDiff.size()>0) {
             FBX::Node::WritePropertyNode(
                 "Normals", pNormalDiff, outstream, binary, indent
             );
           }
         }
         indent--;
         bsnode.End(outstream, binary, indent, true);
 
         // Add blendshape Channel Deformer
         FBX::Node sdnode("Deformer");
         const int64_t blendchannel_uid = generate_uid();
         sdnode.AddProperties(
             blendchannel_uid, blendshape_name + FBX::SEPARATOR + "SubDeformer", "BlendShapeChannel"
         );
         sdnode.AddChild("Version", int32_t(100));
         sdnode.AddChild("DeformPercent", float_t(0.0));
         FBX::Node p("Properties70");
         p.AddP70numberA("DeformPercent", 0.0);
         sdnode.AddChild(p);
         // TODO: Normally just one weight per channel, adding stub for later development
         std::vector<float>fFullWeights;
         fFullWeights.push_back(100.);
         sdnode.AddChild("FullWeights", fFullWeights);
         sdnode.Dump(outstream, binary, indent);
 
         connections.emplace_back("C", "OO", blendchannel_uid, deformer_uid);
         connections.emplace_back("C", "OO", blendshape_uid, blendchannel_uid);
       }
     }
 
     // bones.
     //
     // output structure:
     // subset of node hierarchy that are "skeleton",
     // i.e. do not have meshes but only bones.
     // but.. i'm not sure how anyone could guarantee that...
     //
     // input...
     // well, for each mesh it has "bones",
     // and the bone names correspond to nodes.
     // of course we also need the parent nodes,
     // as they give some of the transform........
     //
     // well. we can assume a sane input, i suppose.
     //
     // so input is the bone node hierarchy,
     // with an extra thing for the transformation of the MESH in BONE space.
     //
     // output is a set of bone nodes,
     // a "bindpose" which indicates the default local transform of all bones,
     // and a set of "deformers".
     // each deformer is parented to a mesh geometry,
     // and has one or more "subdeformer"s as children.
     // each subdeformer has one bone node as a child,
     // and represents the influence of that bone on the grandparent mesh.
     // the subdeformer has a list of indices, and weights,
     // with indices specifying vertex indices,
     // and weights specifying the corresponding influence of this bone.
     // it also has Transform and TransformLink elements,
     // specifying the transform of the MESH in BONE space,
     // and the transformation of the BONE in WORLD space,
     // likely in the bindpose.
     //
     // the input bone structure is different but similar,
     // storing the number of weights for this bone,
     // and an array of (vertex index, weight) pairs.
     //
     // one sticky point is that the number of vertices may not match,
     // because assimp splits vertices by normal, uv, etc.
 
     // functor for aiNode sorting
     struct SortNodeByName
     {
         bool operator()(const aiNode *lhs, const aiNode *rhs) const
         {
             return strcmp(lhs->mName.C_Str(), rhs->mName.C_Str()) < 0;
         }
     };
 
     // first we should mark the skeleton for each mesh.
     // the skeleton must include not only the aiBones,
     // but also all their parent nodes.
     // anything that affects the position of any bone node must be included.
     // Use SorNodeByName to make sure the exported result will be the same across all systems
     // Otherwise the aiNodes of the skeleton would be sorted based on the pointer address, which isn't consistent
     std::vector<std::set<const aiNode*, SortNodeByName>> skeleton_by_mesh(mScene->mNumMeshes);
     // at the same time we can build a list of all the skeleton nodes,
     // which will be used later to mark them as type "limbNode".
     std::unordered_set<const aiNode*> limbnodes;
-    
+
     //actual bone nodes in fbx, without parenting-up
     std::unordered_set<std::string> setAllBoneNamesInScene;
     for(unsigned int m = 0; m < mScene->mNumMeshes; ++ m)
     {
         aiMesh* pMesh = mScene->mMeshes[m];
         for(unsigned int b = 0; b < pMesh->mNumBones; ++ b)
             setAllBoneNamesInScene.insert(pMesh->mBones[b]->mName.data);
     }
     aiMatrix4x4 mxTransIdentity;
-    
+
     // and a map of nodes by bone name, as finding them is annoying.
     std::map<std::string,aiNode*> node_by_bone;
     for (size_t mi = 0; mi < mScene->mNumMeshes; ++mi) {
         const aiMesh* m = mScene->mMeshes[mi];
         std::set<const aiNode*, SortNodeByName> skeleton;
         for (size_t bi =0; bi < m->mNumBones; ++bi) {
             const aiBone* b = m->mBones[bi];
             const std::string name(b->mName.C_Str());
             auto elem = node_by_bone.find(name);
             aiNode* n;
             if (elem != node_by_bone.end()) {
                 n = elem->second;
             } else {
                 n = mScene->mRootNode->FindNode(b->mName);
                 if (!n) {
                     // this should never happen
                     std::stringstream err;
                     err << "Failed to find node for bone: \"" << name << "\"";
                     throw DeadlyExportError(err.str());
                 }
                 node_by_bone[name] = n;
                 limbnodes.insert(n);
             }
             skeleton.insert(n);
             // mark all parent nodes as skeleton as well,
             // up until we find the root node,
             // or else the node containing the mesh,
             // or else the parent of a node containig the mesh.
             for (
                 const aiNode* parent = n->mParent;
                 parent && parent != mScene->mRootNode;
                 parent = parent->mParent
             ) {
                 // if we've already done this node we can skip it all
                 if (skeleton.count(parent)) {
                     break;
                 }
                 // ignore fbx transform nodes as these will be collapsed later
                 // TODO: cache this by aiNode*
                 const std::string node_name(parent->mName.C_Str());
                 if (node_name.find(MAGIC_NODE_TAG) != std::string::npos) {
                     continue;
                 }
                 //not a bone in scene && no effect in transform
                 if(setAllBoneNamesInScene.find(node_name)==setAllBoneNamesInScene.end()
                    && parent->mTransformation == mxTransIdentity) {
                         continue;
                 }
                 // otherwise check if this is the root of the skeleton
                 bool end = false;
                 // is the mesh part of this node?
                 for (size_t i = 0; i < parent->mNumMeshes; ++i) {
                     if (parent->mMeshes[i] == mi) {
                         end = true;
                         break;
                     }
                 }
                 // is the mesh in one of the children of this node?
                 for (size_t j = 0; j < parent->mNumChildren; ++j) {
                     aiNode* child = parent->mChildren[j];
                     for (size_t i = 0; i < child->mNumMeshes; ++i) {
                         if (child->mMeshes[i] == mi) {
                             end = true;
                             break;
                         }
                     }
                     if (end) { break; }
                 }
-                
+
                 // if it was the skeleton root we can finish here
                 if (end) { break; }
             }
         }
         skeleton_by_mesh[mi] = skeleton;
     }
 
     // we'll need the uids for the bone nodes, so generate them now
     for (size_t i = 0; i < mScene->mNumMeshes; ++i) {
         auto &s = skeleton_by_mesh[i];
         for (const aiNode* n : s) {
             auto elem = node_uids.find(n);
             if (elem == node_uids.end()) {
                 node_uids[n] = generate_uid();
             }
         }
     }
 
     // now, for each aiMesh, we need to export a deformer,
     // and for each aiBone a subdeformer,
     // which should have all the skinning info.
     // these will need to be connected properly to the mesh,
     // and we can do that all now.
     for (size_t mi = 0; mi < mScene->mNumMeshes; ++mi) {
         const aiMesh* m = mScene->mMeshes[mi];
         if (!m->HasBones()) {
             continue;
         }
         // make a deformer for this mesh
         int64_t deformer_uid = generate_uid();
         FBX::Node dnode("Deformer");
         dnode.AddProperties(deformer_uid, FBX::SEPARATOR + "Deformer", "Skin");
         dnode.AddChild("Version", int32_t(101));
         // "acuracy"... this is not a typo....
         dnode.AddChild("Link_DeformAcuracy", double(50));
         dnode.AddChild("SkinningType", "Linear"); // TODO: other modes?
         dnode.Dump(outstream, binary, indent);
 
         // connect it
         connections.emplace_back("C", "OO", deformer_uid, mesh_uids[mi]);
 
         //computed before
         std::vector<int32_t>& vertex_indices = vVertexIndice[mi];
 
         // TODO, FIXME: this won't work if anything is not in the bind pose.
         // for now if such a situation is detected, we throw an exception.
         std::set<const aiBone*> not_in_bind_pose;
         std::set<const aiNode*> no_offset_matrix;
 
         // first get this mesh's position in world space,
         // as we'll need it for each subdeformer.
         //
         // ...of course taking the position of the MESH doesn't make sense,
         // as it can be instanced to many nodes.
         // All we can do is assume no instancing,
         // and take the first node we find that contains the mesh.
         aiNode* mesh_node = get_node_for_mesh((unsigned int)mi, mScene->mRootNode);
         aiMatrix4x4 mesh_xform = get_world_transform(mesh_node, mScene);
 
         // now make a subdeformer for each bone in the skeleton
         const std::set<const aiNode*, SortNodeByName> skeleton= skeleton_by_mesh[mi];
         for (const aiNode* bone_node : skeleton) {
             // if there's a bone for this node, find it
             const aiBone* b = nullptr;
             for (size_t bi = 0; bi < m->mNumBones; ++bi) {
                 // TODO: this probably should index by something else
                 const std::string name(m->mBones[bi]->mName.C_Str());
                 if (node_by_bone[name] == bone_node) {
                     b = m->mBones[bi];
                     break;
                 }
             }
             if (!b) {
                 no_offset_matrix.insert(bone_node);
             }
 
             // start the subdeformer node
             const int64_t subdeformer_uid = generate_uid();
             FBX::Node sdnode("Deformer");
             sdnode.AddProperties(
                 subdeformer_uid, FBX::SEPARATOR + "SubDeformer", "Cluster"
             );
             sdnode.AddChild("Version", int32_t(100));
             sdnode.AddChild("UserData", "", "");
 
             std::set<int32_t> setWeightedVertex;
             // add indices and weights, if any
             if (b) {
                 std::vector<int32_t> subdef_indices;
                 std::vector<double> subdef_weights;
                 int32_t last_index = -1;
                 for (size_t wi = 0; wi < b->mNumWeights; ++wi) {
                     int32_t vi = vertex_indices[b->mWeights[wi].mVertexId];
                     bool bIsWeightedAlready = (setWeightedVertex.find(vi) != setWeightedVertex.end());
                     if (vi == last_index || bIsWeightedAlready) {
                         // only for vertices we exported to fbx
                         // TODO, FIXME: this assumes identically-located vertices
                         // will always deform in the same way.
                         // as assimp doesn't store a separate list of "positions",
                         // there's not much that can be done about this
                         // other than assuming that identical position means
                         // identical vertex.
                         continue;
                     }
                     setWeightedVertex.insert(vi);
                     subdef_indices.push_back(vi);
                     subdef_weights.push_back(b->mWeights[wi].mWeight);
                     last_index = vi;
                 }
                 // yes, "indexes"
                 sdnode.AddChild("Indexes", subdef_indices);
                 sdnode.AddChild("Weights", subdef_weights);
             }
 
             // transform is the transform of the mesh, but in bone space.
             // if the skeleton is in the bind pose,
             // we can take the inverse of the world-space bone transform
             // and multiply by the world-space transform of the mesh.
             aiMatrix4x4 bone_xform = get_world_transform(bone_node, mScene);
             aiMatrix4x4 inverse_bone_xform = bone_xform;
             inverse_bone_xform.Inverse();
             aiMatrix4x4 tr = inverse_bone_xform * mesh_xform;
 
             sdnode.AddChild("Transform", tr);
 
 
             sdnode.AddChild("TransformLink", bone_xform);
             // note: this means we ALWAYS rely on the mesh node transform
             // being unchanged from the time the skeleton was bound.
             // there's not really any way around this at the moment.
 
             // done
             sdnode.Dump(outstream, binary, indent);
 
             // lastly, connect to the parent deformer
             connections.emplace_back(
                 "C", "OO", subdeformer_uid, deformer_uid
             );
 
             // we also need to connect the limb node to the subdeformer.
             connections.emplace_back(
                 "C", "OO", node_uids[bone_node], subdeformer_uid
             );
         }
 
         // if we cannot create a valid FBX file, simply die.
         // this will both prevent unnecessary bug reports,
         // and tell the user what they can do to fix the situation
         // (i.e. export their model in the bind pose).
         if (no_offset_matrix.size() && not_in_bind_pose.size()) {
             std::stringstream err;
             err << "Not enough information to construct bind pose";
             err << " for mesh " << mi << "!";
             err << " Transform matrix for bone \"";
             err << (*not_in_bind_pose.begin())->mName.C_Str() << "\"";
             if (not_in_bind_pose.size() > 1) {
                 err << " (and " << not_in_bind_pose.size() - 1 << " more)";
             }
             err << " does not match mOffsetMatrix,";
             err << " and node \"";
             err << (*no_offset_matrix.begin())->mName.C_Str() << "\"";
             if (no_offset_matrix.size() > 1) {
                 err << " (and " << no_offset_matrix.size() - 1 << " more)";
             }
             err << " has no offset matrix to rely on.";
             err << " Please ensure bones are in the bind pose to export.";
             throw DeadlyExportError(err.str());
         }
 
     }
 
     // BindPose
     //
     // This is a legacy system, which should be unnecessary.
     //
     // Somehow including it slows file loading by the official FBX SDK,
     // and as it can reconstruct it from the deformers anyway,
     // this is not currently included.
     //
     // The code is kept here in case it's useful in the future,
     // but it's pretty much a hack anyway,
     // as assimp doesn't store bindpose information for full skeletons.
     //
     /*for (size_t mi = 0; mi < mScene->mNumMeshes; ++mi) {
         aiMesh* mesh = mScene->mMeshes[mi];
         if (! mesh->HasBones()) { continue; }
         int64_t bindpose_uid = generate_uid();
         FBX::Node bpnode("Pose");
         bpnode.AddProperty(bindpose_uid);
         // note: this uid is never linked or connected to anything.
         bpnode.AddProperty(FBX::SEPARATOR + "Pose"); // blank name
         bpnode.AddProperty("BindPose");
 
         bpnode.AddChild("Type", "BindPose");
         bpnode.AddChild("Version", int32_t(100));
 
         aiNode* mesh_node = get_node_for_mesh(mi, mScene->mRootNode);
 
         // next get the whole skeleton for this mesh.
         // we need it all to define the bindpose section.
         // the FBX SDK will complain if it's missing,
         // and also if parents of used bones don't have a subdeformer.
         // order shouldn't matter.
         std::set<aiNode*> skeleton;
         for (size_t bi = 0; bi < mesh->mNumBones; ++bi) {
             // bone node should have already been indexed
             const aiBone* b = mesh->mBones[bi];
             const std::string bone_name(b->mName.C_Str());
             aiNode* parent = node_by_bone[bone_name];
             // insert all nodes down to the root or mesh node
             while (
                 parent
                 && parent != mScene->mRootNode
                 && parent != mesh_node
             ) {
                 skeleton.insert(parent);
                 parent = parent->mParent;
             }
         }
 
         // number of pose nodes. includes one for the mesh itself.
         bpnode.AddChild("NbPoseNodes", int32_t(1 + skeleton.size()));
 
         // the first pose node is always the mesh itself
         FBX::Node pose("PoseNode");
         pose.AddChild("Node", mesh_uids[mi]);
         aiMatrix4x4 mesh_node_xform = get_world_transform(mesh_node, mScene);
         pose.AddChild("Matrix", mesh_node_xform);
         bpnode.AddChild(pose);
 
         for (aiNode* bonenode : skeleton) {
             // does this node have a uid yet?
             int64_t node_uid;
             auto node_uid_iter = node_uids.find(bonenode);
             if (node_uid_iter != node_uids.end()) {
                 node_uid = node_uid_iter->second;
             } else {
                 node_uid = generate_uid();
                 node_uids[bonenode] = node_uid;
             }
 
             // make a pose thingy
             pose = FBX::Node("PoseNode");
             pose.AddChild("Node", node_uid);
             aiMatrix4x4 node_xform = get_world_transform(bonenode, mScene);
             pose.AddChild("Matrix", node_xform);
             bpnode.AddChild(pose);
         }
 
         // now write it
         bpnode.Dump(outstream, binary, indent);
     }*/
 
     // lights
     indent = 1;
     lights_uids.clear();
     for (size_t li = 0; li < mScene->mNumLights; ++li) {
         aiLight* l = mScene->mLights[li];
 
         int64_t uid = generate_uid();
         const std::string lightNodeAttributeName = l->mName.C_Str() + FBX::SEPARATOR + "NodeAttribute";
 
         FBX::Node lna("NodeAttribute");
         lna.AddProperties(uid, lightNodeAttributeName, "Light");
         FBX::Node lnap("Properties70");
 
         // Light color.
         lnap.AddP70colorA("Color", l->mColorDiffuse.r, l->mColorDiffuse.g, l->mColorDiffuse.b);
 
         // TODO Assimp light description is quite concise and do not handle light intensity.
         // Default value to 1000W.
         lnap.AddP70numberA("Intensity", 1000);
 
         // FBXLight::EType conversion
         switch (l->mType) {
         case aiLightSource_POINT:
             lnap.AddP70enum("LightType", 0);
             break;
         case aiLightSource_DIRECTIONAL:
             lnap.AddP70enum("LightType", 1);
             break;
         case aiLightSource_SPOT:
             lnap.AddP70enum("LightType", 2);
             lnap.AddP70numberA("InnerAngle", AI_RAD_TO_DEG(l->mAngleInnerCone));
             lnap.AddP70numberA("OuterAngle", AI_RAD_TO_DEG(l->mAngleOuterCone));
             break;
         // TODO Assimp do not handle 'area' nor 'volume' lights, but FBX does.
         /*case aiLightSource_AREA:
             lnap.AddP70enum("LightType", 3);
             lnap.AddP70enum("AreaLightShape", 0); // 0=Rectangle, 1=Sphere
             break;
         case aiLightSource_VOLUME:
             lnap.AddP70enum("LightType", 4);
             break;*/
         default:
             break;
         }
 
         // Did not understood how to configure the decay so disabling attenuation.
         lnap.AddP70enum("DecayType", 0);
 
         // Dump to FBX stream
         lna.AddChild(lnap);
         lna.AddChild("TypeFlags", FBX::FBXExportProperty("Light"));
         lna.AddChild("GeometryVersion", FBX::FBXExportProperty(int32_t(124)));
         lna.Dump(outstream, binary, indent);
 
         // Store name and uid (will be used later when parsing scene nodes)
         lights_uids[l->mName.C_Str()] = uid;
     }
 
     // TODO: cameras
 
     // write nodes (i.e. model hierarchy)
     // start at root node
     WriteModelNodes(
         outstream, mScene->mRootNode, 0, limbnodes
     );
 
     // animations
     //
     // in FBX there are:
     // * AnimationStack - corresponds to an aiAnimation
     // * AnimationLayer - a combinable animation component
     // * AnimationCurveNode - links the property to be animated
     // * AnimationCurve - defines animation data for a single property value
     //
     // the CurveNode also provides the default value for a property,
     // such as the X, Y, Z coordinates for animatable translation.
     //
     // the Curve only specifies values for one component of the property,
     // so there will be a separate AnimationCurve for X, Y, and Z.
     //
     // Assimp has:
     // * aiAnimation - basically corresponds to an AnimationStack
     // * aiNodeAnim - defines all animation for one aiNode
     // * aiVectorKey/aiQuatKey - define the keyframe data for T/R/S
     //
     // assimp has no equivalent for AnimationLayer,
     // and these are flattened on FBX import.
     // we can assume there will be one per AnimationStack.
     //
     // the aiNodeAnim contains all animation data for a single aiNode,
     // which will correspond to three AnimationCurveNode's:
     // one each for translation, rotation and scale.
     // The data for each of these will be put in 9 AnimationCurve's,
     // T.X, T.Y, T.Z, R.X, R.Y, R.Z, etc.
 
     // AnimationStack / aiAnimation
     std::vector<int64_t> animation_stack_uids(mScene->mNumAnimations);
     for (size_t ai = 0; ai < mScene->mNumAnimations; ++ai) {
         int64_t animstack_uid = generate_uid();
         animation_stack_uids[ai] = animstack_uid;
         const aiAnimation* anim = mScene->mAnimations[ai];
 
         FBX::Node asnode("AnimationStack");
         std::string name = anim->mName.C_Str() + FBX::SEPARATOR + "AnimStack";
         asnode.AddProperties(animstack_uid, name, "");
         FBX::Node p("Properties70");
         p.AddP70time("LocalStart", 0); // assimp doesn't store this
         p.AddP70time("LocalStop", to_ktime(anim->mDuration, anim));
         p.AddP70time("ReferenceStart", 0);
         p.AddP70time("ReferenceStop", to_ktime(anim->mDuration, anim));
         asnode.AddChild(p);
 
         // this node absurdly always pretends it has children
         // (in this case it does, but just in case...)
         asnode.force_has_children = true;
         asnode.Dump(outstream, binary, indent);
 
         // note: animation stacks are not connected to anything
     }
 
     // AnimationLayer - one per aiAnimation
     std::vector<int64_t> animation_layer_uids(mScene->mNumAnimations);
     for (size_t ai = 0; ai < mScene->mNumAnimations; ++ai) {
         int64_t animlayer_uid = generate_uid();
         animation_layer_uids[ai] = animlayer_uid;
         FBX::Node alnode("AnimationLayer");
         alnode.AddProperties(animlayer_uid, FBX::SEPARATOR + "AnimLayer", "");
 
         // this node absurdly always pretends it has children
         alnode.force_has_children = true;
         alnode.Dump(outstream, binary, indent);
 
         // connect to the relevant animstack
         connections.emplace_back(
             "C", "OO", animlayer_uid, animation_stack_uids[ai]
         );
     }
 
     // AnimCurveNode - three per aiNodeAnim
     std::vector<std::vector<std::array<int64_t,3>>> curve_node_uids;
     for (size_t ai = 0; ai < mScene->mNumAnimations; ++ai) {
         const aiAnimation* anim = mScene->mAnimations[ai];
         const int64_t layer_uid = animation_layer_uids[ai];
         std::vector<std::array<int64_t,3>> nodeanim_uids;
         for (size_t nai = 0; nai < anim->mNumChannels; ++nai) {
             const aiNodeAnim* na = anim->mChannels[nai];
             // get the corresponding aiNode
             const aiNode* node = mScene->mRootNode->FindNode(na->mNodeName);
             // and its transform
             const aiMatrix4x4 node_xfm = get_world_transform(node, mScene);
             aiVector3D T, R, S;
             node_xfm.Decompose(S, R, T);
 
             // AnimationCurveNode uids
             std::array<int64_t,3> ids;
             ids[0] = generate_uid(); // T
             ids[1] = generate_uid(); // R
             ids[2] = generate_uid(); // S
 
             // translation
             WriteAnimationCurveNode(outstream,
                 ids[0], "T", T, "Lcl Translation",
                 layer_uid, node_uids[node]
             );
 
             // rotation
             WriteAnimationCurveNode(outstream,
                 ids[1], "R", R, "Lcl Rotation",
                 layer_uid, node_uids[node]
             );
 
             // scale
             WriteAnimationCurveNode(outstream,
                 ids[2], "S", S, "Lcl Scale",
                 layer_uid, node_uids[node]
             );
 
             // store the uids for later use
             nodeanim_uids.push_back(ids);
         }
         curve_node_uids.push_back(nodeanim_uids);
     }
 
     // AnimCurve - defines actual keyframe data.
     // there's a separate curve for every component of every vector,
     // for example a transform curvenode will have separate X/Y/Z AnimCurve's
     for (size_t ai = 0; ai < mScene->mNumAnimations; ++ai) {
         const aiAnimation* anim = mScene->mAnimations[ai];
         for (size_t nai = 0; nai < anim->mNumChannels; ++nai) {
             const aiNodeAnim* na = anim->mChannels[nai];
             // get the corresponding aiNode
             const aiNode* node = mScene->mRootNode->FindNode(na->mNodeName);
             // and its transform
             const aiMatrix4x4 node_xfm = get_world_transform(node, mScene);
             aiVector3D T, R, S;
             node_xfm.Decompose(S, R, T);
             const std::array<int64_t,3>& ids = curve_node_uids[ai][nai];
 
             std::vector<int64_t> times;
             std::vector<float> xval, yval, zval;
 
             // position/translation
             for (size_t ki = 0; ki < na->mNumPositionKeys; ++ki) {
                 const aiVectorKey& k = na->mPositionKeys[ki];
                 times.push_back(to_ktime(k.mTime));
                 xval.push_back(k.mValue.x);
                 yval.push_back(k.mValue.y);
                 zval.push_back(k.mValue.z);
             }
             // one curve each for X, Y, Z
             WriteAnimationCurve(outstream, T.x, times, xval, ids[0], "d|X");
             WriteAnimationCurve(outstream, T.y, times, yval, ids[0], "d|Y");
             WriteAnimationCurve(outstream, T.z, times, zval, ids[0], "d|Z");
 
             // rotation
             times.clear(); xval.clear(); yval.clear(); zval.clear();
             for (size_t ki = 0; ki < na->mNumRotationKeys; ++ki) {
                 const aiQuatKey& k = na->mRotationKeys[ki];
                 times.push_back(to_ktime(k.mTime));
                 // TODO: aiQuaternion method to convert to Euler...
                 aiMatrix4x4 m(k.mValue.GetMatrix());
                 aiVector3D qs, qr, qt;
                 m.Decompose(qs, qr, qt);
                 qr *= DEG;
                 xval.push_back(qr.x);
                 yval.push_back(qr.y);
                 zval.push_back(qr.z);
             }
             WriteAnimationCurve(outstream, R.x, times, xval, ids[1], "d|X");
             WriteAnimationCurve(outstream, R.y, times, yval, ids[1], "d|Y");
             WriteAnimationCurve(outstream, R.z, times, zval, ids[1], "d|Z");
 
             // scaling/scale
             times.clear(); xval.clear(); yval.clear(); zval.clear();
             for (size_t ki = 0; ki < na->mNumScalingKeys; ++ki) {
                 const aiVectorKey& k = na->mScalingKeys[ki];
                 times.push_back(to_ktime(k.mTime));
                 xval.push_back(k.mValue.x);
                 yval.push_back(k.mValue.y);
                 zval.push_back(k.mValue.z);
             }
             WriteAnimationCurve(outstream, S.x, times, xval, ids[2], "d|X");
             WriteAnimationCurve(outstream, S.y, times, yval, ids[2], "d|Y");
             WriteAnimationCurve(outstream, S.z, times, zval, ids[2], "d|Z");
         }
     }
 
     indent = 0;
     object_node.End(outstream, binary, indent, true);
 }
 
 // convenience map of magic node name strings to FBX properties,
 // including the expected type of transform.
diff --git a/code/AssetLib/FBX/FBXMaterial.cpp b/code/AssetLib/FBX/FBXMaterial.cpp
index aaa043c12..7eb047177 100644
--- a/code/AssetLib/FBX/FBXMaterial.cpp
+++ b/code/AssetLib/FBX/FBXMaterial.cpp
@@ -142,93 +142,93 @@ Material::~Material() {
 
 // ------------------------------------------------------------------------------------------------
 Texture::Texture(uint64_t id, const Element& element, const Document& doc, const std::string& name) :
-        Object(id,element,name), 
-        uvScaling(1.0f,1.0f), 
+        Object(id,element,name),
+        uvScaling(1.0f,1.0f),
         media(0) {
     const Scope& sc = GetRequiredScope(element);
 
     const Element* const Type = sc["Type"];
     const Element* const FileName = sc["FileName"];
     const Element* const RelativeFilename = sc["RelativeFilename"];
     const Element* const ModelUVTranslation = sc["ModelUVTranslation"];
     const Element* const ModelUVScaling = sc["ModelUVScaling"];
     const Element* const Texture_Alpha_Source = sc["Texture_Alpha_Source"];
     const Element* const Cropping = sc["Cropping"];
 
     if(Type) {
         type = ParseTokenAsString(GetRequiredToken(*Type,0));
     }
 
     if(FileName) {
         fileName = ParseTokenAsString(GetRequiredToken(*FileName,0));
     }
 
     if(RelativeFilename) {
         relativeFileName = ParseTokenAsString(GetRequiredToken(*RelativeFilename,0));
     }
 
     if(ModelUVTranslation) {
         uvTrans = aiVector2D(ParseTokenAsFloat(GetRequiredToken(*ModelUVTranslation,0)),
             ParseTokenAsFloat(GetRequiredToken(*ModelUVTranslation,1))
         );
     }
 
     if(ModelUVScaling) {
         uvScaling = aiVector2D(ParseTokenAsFloat(GetRequiredToken(*ModelUVScaling,0)),
             ParseTokenAsFloat(GetRequiredToken(*ModelUVScaling,1))
         );
     }
 
     if(Cropping) {
         crop[0] = ParseTokenAsInt(GetRequiredToken(*Cropping,0));
         crop[1] = ParseTokenAsInt(GetRequiredToken(*Cropping,1));
         crop[2] = ParseTokenAsInt(GetRequiredToken(*Cropping,2));
         crop[3] = ParseTokenAsInt(GetRequiredToken(*Cropping,3));
     } else {
         // vc8 doesn't support the crop() syntax in initialization lists
         // (and vc9 WARNS about the new (i.e. compliant) behaviour).
         crop[0] = crop[1] = crop[2] = crop[3] = 0;
     }
 
     if(Texture_Alpha_Source) {
         alphaSource = ParseTokenAsString(GetRequiredToken(*Texture_Alpha_Source,0));
     }
 
     props = GetPropertyTable(doc,"Texture.FbxFileTexture",element,sc);
 
     // 3DS Max and FBX SDK use "Scaling" and "Translation" instead of "ModelUVScaling" and "ModelUVTranslation". Use these properties if available.
     bool ok;
     const aiVector3D& scaling = PropertyGet<aiVector3D>(*props, "Scaling", ok);
     if (ok) {
         uvScaling.x = scaling.x;
         uvScaling.y = scaling.y;
     }
 
     const aiVector3D& trans = PropertyGet<aiVector3D>(*props, "Translation", ok);
     if (ok) {
         uvTrans.x = trans.x;
         uvTrans.y = trans.y;
     }
 
     const aiVector3D &rotation = PropertyGet<aiVector3D>(*props, "Rotation", ok);
     if (ok) {
         uvRotation = rotation.z;
     }
 
     // resolve video links
     if(doc.Settings().readTextures) {
         const std::vector<const Connection*>& conns = doc.GetConnectionsByDestinationSequenced(ID());
         for(const Connection* con : conns) {
             const Object* const ob = con->SourceObject();
             if (nullptr == ob) {
                 DOMWarning("failed to read source object for texture link, ignoring",&element);
                 continue;
             }
 
             const Video* const video = dynamic_cast<const Video*>(ob);
             if(video) {
                 media = video;
             }
         }
     }
 }
@@ -278,89 +278,89 @@ void LayeredTexture::fillTexture(const Document& doc) {
 
 // ------------------------------------------------------------------------------------------------
 Video::Video(uint64_t id, const Element& element, const Document& doc, const std::string& name) :
-        Object(id,element,name), 
-        contentLength(0), 
+        Object(id,element,name),
+        contentLength(0),
         content(0) {
     const Scope& sc = GetRequiredScope(element);
 
     const Element* const Type = sc["Type"];
     const Element* const FileName = sc.FindElementCaseInsensitive("FileName");  //some files retain the information as "Filename", others "FileName", who knows
     const Element* const RelativeFilename = sc["RelativeFilename"];
     const Element* const Content = sc["Content"];
 
     if(Type) {
         type = ParseTokenAsString(GetRequiredToken(*Type,0));
     }
 
     if(FileName) {
         fileName = ParseTokenAsString(GetRequiredToken(*FileName,0));
     }
 
     if(RelativeFilename) {
         relativeFileName = ParseTokenAsString(GetRequiredToken(*RelativeFilename,0));
     }
 
     if(Content && !Content->Tokens().empty()) {
         //this field is omitted when the embedded texture is already loaded, let's ignore if it's not found
         try {
             const Token& token = GetRequiredToken(*Content, 0);
             const char* data = token.begin();
             if (!token.IsBinary()) {
                 if (*data != '"') {
                     DOMError("embedded content is not surrounded by quotation marks", &element);
                 } else {
                     size_t targetLength = 0;
                     auto numTokens = Content->Tokens().size();
                     // First time compute size (it could be large like 64Gb and it is good to allocate it once)
                     for (uint32_t tokenIdx = 0; tokenIdx < numTokens; ++tokenIdx) {
                         const Token& dataToken = GetRequiredToken(*Content, tokenIdx);
                         size_t tokenLength = dataToken.end() - dataToken.begin() - 2; // ignore double quotes
                         const char* base64data = dataToken.begin() + 1;
                         const size_t outLength = Util::ComputeDecodedSizeBase64(base64data, tokenLength);
                         if (outLength == 0) {
                             DOMError("Corrupted embedded content found", &element);
                         }
                         targetLength += outLength;
                     }
                     if (targetLength == 0) {
                         DOMError("Corrupted embedded content found", &element);
                     }
                     content = new uint8_t[targetLength];
                     contentLength = static_cast<uint64_t>(targetLength);
                     size_t dst_offset = 0;
                     for (uint32_t tokenIdx = 0; tokenIdx < numTokens; ++tokenIdx) {
                         const Token& dataToken = GetRequiredToken(*Content, tokenIdx);
                         size_t tokenLength = dataToken.end() - dataToken.begin() - 2; // ignore double quotes
                         const char* base64data = dataToken.begin() + 1;
                         dst_offset += Util::DecodeBase64(base64data, tokenLength, content + dst_offset, targetLength - dst_offset);
                     }
                     if (targetLength != dst_offset) {
                         delete[] content;
                         contentLength = 0;
                         DOMError("Corrupted embedded content found", &element);
                     }
                 }
             } else if (static_cast<size_t>(token.end() - data) < 5) {
                 DOMError("binary data array is too short, need five (5) bytes for type signature and element count", &element);
             } else if (*data != 'R') {
                 DOMWarning("video content is not raw binary data, ignoring", &element);
             } else {
                 // read number of elements
                 uint32_t len = 0;
                 ::memcpy(&len, data + 1, sizeof(len));
                 AI_SWAP4(len);
 
                 contentLength = len;
 
                 content = new uint8_t[len];
                 ::memcpy(content, data + 5, len);
             }
         } catch (const runtime_error& runtimeError) {
             //we don't need the content data for contents that has already been loaded
             ASSIMP_LOG_VERBOSE_DEBUG("Caught exception in FBXMaterial (likely because content was already loaded): ",
                     runtimeError.what());
         }
     }
 
     props = GetPropertyTable(doc,"Video.FbxVideo",element,sc);
 }
diff --git a/code/AssetLib/FBX/FBXMeshGeometry.cpp b/code/AssetLib/FBX/FBXMeshGeometry.cpp
index 5aecb61b5..6aeebcbe3 100644
--- a/code/AssetLib/FBX/FBXMeshGeometry.cpp
+++ b/code/AssetLib/FBX/FBXMeshGeometry.cpp
@@ -626,43 +626,43 @@ void MeshGeometry::ReadVertexDataBinormals(std::vector<aiVector3D>& binormals_ou
 // ------------------------------------------------------------------------------------------------
 void MeshGeometry::ReadVertexDataMaterials(std::vector<int>& materials_out, const Scope& source,
     const std::string& MappingInformationType,
     const std::string& ReferenceInformationType)
 {
     const size_t face_count = m_faces.size();
     if( 0 == face_count )
     {
         return;
     }
-    
+
     // materials are handled separately. First of all, they are assigned per-face
     // and not per polyvert. Secondly, ReferenceInformationType=IndexToDirect
     // has a slightly different meaning for materials.
     ParseVectorDataArray(materials_out,GetRequiredElement(source,"Materials"));
 
     if (MappingInformationType == "AllSame") {
         // easy - same material for all faces
         if (materials_out.empty()) {
             FBXImporter::LogError("expected material index, ignoring");
             return;
         } else if (materials_out.size() > 1) {
             FBXImporter::LogWarn("expected only a single material index, ignoring all except the first one");
             materials_out.clear();
         }
 
         materials_out.resize(m_vertices.size());
         std::fill(materials_out.begin(), materials_out.end(), materials_out.at(0));
     } else if (MappingInformationType == "ByPolygon" && ReferenceInformationType == "IndexToDirect") {
         materials_out.resize(face_count);
 
         if(materials_out.size() != face_count) {
             FBXImporter::LogError("length of input data unexpected for ByPolygon mapping: ",
                 materials_out.size(), ", expected ", face_count
             );
             return;
         }
     } else {
         FBXImporter::LogError("ignoring material assignments, access type not implemented: ",
             MappingInformationType, ",", ReferenceInformationType);
     }
 }
 // ------------------------------------------------------------------------------------------------
diff --git a/code/AssetLib/FBX/FBXMeshGeometry.h b/code/AssetLib/FBX/FBXMeshGeometry.h
index ae17860e3..862693b4b 100644
--- a/code/AssetLib/FBX/FBXMeshGeometry.h
+++ b/code/AssetLib/FBX/FBXMeshGeometry.h
@@ -52,8 +52,8 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 namespace Assimp {
 namespace FBX {
 
-/** 
- *  DOM base class for all kinds of FBX geometry 
+/**
+ *  DOM base class for all kinds of FBX geometry
  */
 class Geometry : public Object
 {
@@ -76,7 +76,7 @@ private:
 typedef std::vector<int> MatIndexArray;
 
 
-/** 
+/**
  *  DOM class for FBX geometry of type "Mesh"
  */
 class MeshGeometry : public Geometry
@@ -83,50 +83,50 @@ class MeshGeometry : public Geometry
 {
 public:
     /** The class constructor */
     MeshGeometry( uint64_t id, const Element& element, const std::string& name, const Document& doc );
-    
+
     /** The class destructor */
     virtual ~MeshGeometry();
 
     /** Get a list of all vertex points, non-unique*/
     const std::vector<aiVector3D>& GetVertices() const;
 
     /** Get a list of all vertex normals or an empty array if
     *  no normals are specified. */
     const std::vector<aiVector3D>& GetNormals() const;
 
     /** Get a list of all vertex tangents or an empty array
     *  if no tangents are specified */
     const std::vector<aiVector3D>& GetTangents() const;
 
     /** Get a list of all vertex bi-normals or an empty array
     *  if no bi-normals are specified */
     const std::vector<aiVector3D>& GetBinormals() const;
 
     /** Return list of faces - each entry denotes a face and specifies
     *  how many vertices it has. Vertices are taken from the
     *  vertex data arrays in sequential order. */
     const std::vector<unsigned int>& GetFaceIndexCounts() const;
 
     /** Get a UV coordinate slot, returns an empty array if
     *  the requested slot does not exist. */
     const std::vector<aiVector2D>& GetTextureCoords( unsigned int index ) const;
 
     /** Get a UV coordinate slot, returns an empty array if
     *  the requested slot does not exist. */
     std::string GetTextureCoordChannelName( unsigned int index ) const;
 
     /** Get a vertex color coordinate slot, returns an empty array if
     *  the requested slot does not exist. */
     const std::vector<aiColor4D>& GetVertexColors( unsigned int index ) const;
 
     /** Get per-face-vertex material assignments */
     const MatIndexArray& GetMaterialIndices() const;
 
     /** Convert from a fbx file vertex index (for example from a #Cluster weight) or nullptr
     * if the vertex index is not valid. */
     const unsigned int* ToOutputVertexIndex( unsigned int in_index, unsigned int& count ) const;
 
     /** Determine the face to which a particular output vertex index belongs.
     *  This mapping is always unique. */
     unsigned int FaceForVertexIndex( unsigned int in_index ) const;
diff --git a/code/AssetLib/FBX/FBXProperties.h b/code/AssetLib/FBX/FBXProperties.h
index 9ab784fa7..d1d6b87ab 100644
--- a/code/AssetLib/FBX/FBXProperties.h
+++ b/code/AssetLib/FBX/FBXProperties.h
@@ -98,7 +98,7 @@ typedef std::fbx_unordered_map<std::string,std::shared_ptr<Property> > DirectPro
 typedef std::fbx_unordered_map<std::string,const Property*>            PropertyMap;
 typedef std::fbx_unordered_map<std::string,const Element*>             LazyPropertyMap;
 
-/** 
+/**
  *  Represents a property table as can be found in the newer FBX files (Properties60, Properties70)
  */
 class PropertyTable {
@@ -130,7 +130,7 @@ private:
 
 // ------------------------------------------------------------------------------------------------
 template <typename T>
-inline 
+inline
 T PropertyGet(const PropertyTable& in, const std::string& name, const T& defaultValue) {
     const Property* const prop = in.Get(name);
     if( nullptr == prop) {
@@ -148,7 +148,7 @@ T PropertyGet(const PropertyTable& in, const std::string& name, const T& default
 
 // ------------------------------------------------------------------------------------------------
 template <typename T>
-inline 
+inline
 T PropertyGet(const PropertyTable& in, const std::string& name, bool& result, bool useTemplate=false ) {
     const Property* prop = in.Get(name);
     if( nullptr == prop) {
diff --git a/code/AssetLib/FBX/FBXUtil.cpp b/code/AssetLib/FBX/FBXUtil.cpp
index 66abf0565..3fe791b97 100644
--- a/code/AssetLib/FBX/FBXUtil.cpp
+++ b/code/AssetLib/FBX/FBXUtil.cpp
@@ -100,16 +100,16 @@ std::string GetLineAndColumnText(unsigned int line, unsigned int column)
 // ------------------------------------------------------------------------------------------------
 std::string GetTokenText(const Token* tok)
 {
     if(tok->IsBinary()) {
-        return static_cast<std::string>( Formatter::format() << 
+        return static_cast<std::string>( Formatter::format() <<
             " (" << TokenTypeString(tok->Type()) <<
             ", offset 0x" << std::hex << tok->Offset() << ") " );
     }
 
     return static_cast<std::string>( Formatter::format() <<
         " (" << TokenTypeString(tok->Type()) <<
         ", line " << tok->Line() <<
         ", col " << tok->Column() << ") " );
 }
 
 // Generated by this formula: T["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[i]] = i;
diff --git a/code/AssetLib/HMP/HMPLoader.cpp b/code/AssetLib/HMP/HMPLoader.cpp
index cd14cb9c3..97c1858fb 100644
--- a/code/AssetLib/HMP/HMPLoader.cpp
+++ b/code/AssetLib/HMP/HMPLoader.cpp
@@ -109,64 +109,64 @@ const aiImporterDesc *HMPImporter::GetInfo() const {
 // ------------------------------------------------------------------------------------------------
 // Imports the given file into the given scene structure.
 void HMPImporter::InternReadFile(const std::string &pFile,
         aiScene *_pScene, IOSystem *_pIOHandler) {
     pScene = _pScene;
     mIOHandler = _pIOHandler;
     std::unique_ptr<IOStream> file(mIOHandler->Open(pFile));
 
     // Check whether we can read from the file
     if (file.get() == nullptr) {
         throw DeadlyImportError("Failed to open HMP file ", pFile, ".");
     }
 
     // Check whether the HMP file is large enough to contain
     // at least the file header
     const size_t fileSize = file->FileSize();
     if (fileSize < 50)
         throw DeadlyImportError("HMP File is too small.");
 
     // Allocate storage and copy the contents of the file to a memory buffer
     mBuffer = new uint8_t[fileSize];
     file->Read((void *)mBuffer, 1, fileSize);
     iFileSize = (unsigned int)fileSize;
 
     // Determine the file subtype and call the appropriate member function
     const uint32_t iMagic = *((uint32_t *)this->mBuffer);
 
     // HMP4 format
     if (AI_HMP_MAGIC_NUMBER_LE_4 == iMagic ||
             AI_HMP_MAGIC_NUMBER_BE_4 == iMagic) {
         ASSIMP_LOG_DEBUG("HMP subtype: 3D GameStudio A4, magic word is HMP4");
         InternReadFile_HMP4();
     }
     // HMP5 format
     else if (AI_HMP_MAGIC_NUMBER_LE_5 == iMagic ||
              AI_HMP_MAGIC_NUMBER_BE_5 == iMagic) {
         ASSIMP_LOG_DEBUG("HMP subtype: 3D GameStudio A5, magic word is HMP5");
         InternReadFile_HMP5();
     }
     // HMP7 format
     else if (AI_HMP_MAGIC_NUMBER_LE_7 == iMagic ||
              AI_HMP_MAGIC_NUMBER_BE_7 == iMagic) {
         ASSIMP_LOG_DEBUG("HMP subtype: 3D GameStudio A7, magic word is HMP7");
         InternReadFile_HMP7();
     } else {
         // Print the magic word to the logger
         std::string szBuffer = ai_str_toprintable((const char *)&iMagic, sizeof(iMagic));
-    
+
         delete[] mBuffer;
         mBuffer = nullptr;
-        
+
         // We're definitely unable to load this file
         throw DeadlyImportError("Unknown HMP subformat ", pFile,
                                 ". Magic word (", szBuffer, ") is not known");
     }
 
     // Set the AI_SCENE_FLAGS_TERRAIN bit
     pScene->mFlags |= AI_SCENE_FLAGS_TERRAIN;
 
     delete[] mBuffer;
     mBuffer = nullptr;
 }
 
 // ------------------------------------------------------------------------------------------------
diff --git a/code/AssetLib/IFC/IFCCurve.cpp b/code/AssetLib/IFC/IFCCurve.cpp
index 28cd9690c..3ded43bc0 100644
--- a/code/AssetLib/IFC/IFCCurve.cpp
+++ b/code/AssetLib/IFC/IFCCurve.cpp
@@ -514,12 +514,12 @@ IfcFloat Curve::GetParametricRangeDelta() const {
 
 // ------------------------------------------------------------------------------------------------
 size_t Curve::EstimateSampleCount(IfcFloat a, IfcFloat b) const {
-    (void)(a); (void)(b);  
+    (void)(a); (void)(b);
     ai_assert( InRange( a ) );
     ai_assert( InRange( b ) );
 
     // arbitrary default value, deriving classes should supply better suited values
     return 16;
 }
 
 // ------------------------------------------------------------------------------------------------
diff --git a/code/AssetLib/IFC/IFCOpenings.cpp b/code/AssetLib/IFC/IFCOpenings.cpp
index b7665582c..d6671b885 100644
--- a/code/AssetLib/IFC/IFCOpenings.cpp
+++ b/code/AssetLib/IFC/IFCOpenings.cpp
@@ -850,168 +850,168 @@ void FindLikelyCrossingLines(ContourVector::iterator current)
 // ------------------------------------------------------------------------------------------------
 size_t CloseWindows(ContourVector& contours,
     const IfcMatrix4& minv,
     OpeningRefVector& contours_to_openings,
     TempMesh& curmesh)
 {
     size_t closed = 0;
     // For all contour points, check if one of the assigned openings does
     // already have points assigned to it. In this case, assume this is
     // the other side of the wall and generate connections between
     // the two holes in order to close the window.
 
     // All this gets complicated by the fact that contours may pertain to
     // multiple openings(due to merging of adjacent or overlapping openings).
     // The code is based on the assumption that this happens symmetrically
     // on both sides of the wall. If it doesn't (which would be a bug anyway)
     // wrong geometry may be generated.
     for (ContourVector::iterator it = contours.begin(), end = contours.end(); it != end; ++it) {
         if ((*it).IsInvalid()) {
             continue;
         }
         OpeningRefs& refs = contours_to_openings[std::distance(contours.begin(), it)];
 
         bool has_other_side = false;
         for(const TempOpening* opening : refs) {
             if(!opening->wallPoints.empty()) {
                 has_other_side = true;
                 break;
             }
         }
 
         if (has_other_side) {
 
             ContourRefVector adjacent_contours;
 
             // prepare a skiplist for this contour. The skiplist is used to
             // eliminate unwanted contour lines for adjacent windows and
             // those bordering the outer frame.
             (*it).PrepareSkiplist();
 
             FindAdjacentContours(it, contours);
             FindBorderContours(it);
 
             // if the window is the result of a finite union or intersection of rectangles,
             // there shouldn't be any crossing or diagonal lines in it. Such lines would
             // be artifacts caused by numerical inaccuracies or other bugs in polyclipper
             // and our own code. Since rectangular openings are by far the most frequent
             // case, it is worth filtering for this corner case.
             if((*it).is_rectangular) {
                 FindLikelyCrossingLines(it);
             }
 
             ai_assert((*it).skiplist.size() == (*it).contour.size());
 
             SkipList::const_iterator skipbegin = (*it).skiplist.begin();
 
             curmesh.mVerts.reserve(curmesh.mVerts.size() + (*it).contour.size() * 4);
             curmesh.mVertcnt.reserve(curmesh.mVertcnt.size() + (*it).contour.size());
 
 			bool reverseCountourFaces = false;
 
             // compare base poly normal and contour normal to detect if we need to reverse the face winding
 			if(curmesh.mVertcnt.size() > 0) {
 				IfcVector3 basePolyNormal = TempMesh::ComputePolygonNormal(curmesh.mVerts.data(), curmesh.mVertcnt.front());
-				
+
 				std::vector<IfcVector3> worldSpaceContourVtx(it->contour.size());
-				
+
 				for(size_t a = 0; a < it->contour.size(); ++a)
 					worldSpaceContourVtx[a] = minv * IfcVector3(it->contour[a].x, it->contour[a].y, 0.0);
-				
+
 				IfcVector3 contourNormal = TempMesh::ComputePolygonNormal(worldSpaceContourVtx.data(), worldSpaceContourVtx.size());
-				
+
 				reverseCountourFaces = (contourNormal * basePolyNormal) > 0.0;
 			}
 
             // XXX this algorithm is really a bit inefficient - both in terms
             // of constant factor and of asymptotic runtime.
             std::vector<bool>::const_iterator skipit = skipbegin;
 
             IfcVector3 start0;
             IfcVector3 start1;
 
             const Contour::const_iterator cbegin = (*it).contour.begin(), cend = (*it).contour.end();
 
             bool drop_this_edge = false;
             for (Contour::const_iterator cit = cbegin; cit != cend; ++cit, drop_this_edge = *skipit++) {
                 const IfcVector2& proj_point = *cit;
 
                 // Locate the closest opposite point. This should be a good heuristic to
                 // connect only the points that are really intended to be connected.
                 IfcFloat best = static_cast<IfcFloat>(1e10);
                 IfcVector3 bestv;
 
                 const IfcVector3 world_point = minv * IfcVector3(proj_point.x,proj_point.y,0.0f);
 
                 for(const TempOpening* opening : refs) {
                     for(const IfcVector3& other : opening->wallPoints) {
                         const IfcFloat sqdist = (world_point - other).SquareLength();
 
                         if (sqdist < best) {
                             // avoid self-connections
                             if(sqdist < 1e-5) {
                                 continue;
                             }
 
                             bestv = other;
                             best = sqdist;
                         }
                     }
                 }
 
                 if (drop_this_edge) {
                     curmesh.mVerts.pop_back();
                     curmesh.mVerts.pop_back();
                 }
                 else {
                     curmesh.mVerts.push_back(((cit == cbegin) != reverseCountourFaces) ? world_point : bestv);
                     curmesh.mVerts.push_back(((cit == cbegin) != reverseCountourFaces) ? bestv : world_point);
 
                     curmesh.mVertcnt.push_back(4);
                     ++closed;
                 }
 
                 if (cit == cbegin) {
                     start0 = world_point;
                     start1 = bestv;
                     continue;
                 }
 
                 curmesh.mVerts.push_back(reverseCountourFaces ? bestv : world_point);
                 curmesh.mVerts.push_back(reverseCountourFaces ? world_point : bestv);
 
                 if (cit == cend - 1) {
                     drop_this_edge = *skipit;
 
                     // Check if the final connection (last to first element) is itself
                     // a border edge that needs to be dropped.
                     if (drop_this_edge) {
                         --closed;
                         curmesh.mVertcnt.pop_back();
                         curmesh.mVerts.pop_back();
                         curmesh.mVerts.pop_back();
                     }
                     else {
                         curmesh.mVerts.push_back(reverseCountourFaces ? start0 : start1);
                         curmesh.mVerts.push_back(reverseCountourFaces ? start1 : start0);
                     }
                 }
             }
         }
         else {
 
             const Contour::const_iterator cbegin = (*it).contour.begin(), cend = (*it).contour.end();
             for(TempOpening* opening : refs) {
                 ai_assert(opening->wallPoints.empty());
                 opening->wallPoints.reserve(opening->wallPoints.capacity() + (*it).contour.size());
                 for (Contour::const_iterator cit = cbegin; cit != cend; ++cit) {
 
                     const IfcVector2& proj_point = *cit;
                     opening->wallPoints.push_back(minv * IfcVector3(proj_point.x,proj_point.y,0.0f));
                 }
             }
         }
     }
     return closed;
 }
 
 // ------------------------------------------------------------------------------------------------
diff --git a/code/AssetLib/IFC/IFCReaderGen1_2x3.cpp b/code/AssetLib/IFC/IFCReaderGen1_2x3.cpp
index 2cfa22530..a6f7ae3eb 100644
--- a/code/AssetLib/IFC/IFCReaderGen1_2x3.cpp
+++ b/code/AssetLib/IFC/IFCReaderGen1_2x3.cpp
@@ -5,8 +5,8 @@ Open Asset Import Library (ASSIMP)
 Copyright (c) 2006-2020, ASSIMP Development Team
 All rights reserved.
 
-Redistribution and use of this software in source and binary forms, 
-with or without modification, are permitted provided that the 
+Redistribution and use of this software in source and binary forms,
+with or without modification, are permitted provided that the
 following conditions are met:
 
 * Redistributions of source code must retain the above
@@ -23,16 +23,16 @@ following conditions are met:
   derived from this software without specific prior
   written permission of the ASSIMP Development Team.
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 ----------------------------------------------------------------------
@@ -1059,33 +1059,33 @@ template <> size_t GenericFill<NotImplemented>(const STEP::DB& /*db*/, const LIS
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcRoot>(const DB& db, const LIST& params, IfcRoot* in)
 {
 	size_t base = 0;
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcRoot"); }    do { // convert the 'GlobalId' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcRoot,4>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->GlobalId, arg, db ); break; } 
+        try { GenericConvert( in->GlobalId, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcRoot to be a `IfcGloballyUniqueId`")); }
     } while(0);
     do { // convert the 'OwnerHistory' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcRoot,4>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->OwnerHistory, arg, db ); break; } 
+        try { GenericConvert( in->OwnerHistory, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcRoot to be a `IfcOwnerHistory`")); }
     } while(0);
     do { // convert the 'Name' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcRoot,4>::aux_is_derived[2]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Name, arg, db ); break; } 
+        try { GenericConvert( in->Name, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcRoot to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'Description' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcRoot,4>::aux_is_derived[3]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Description, arg, db ); break; } 
+        try { GenericConvert( in->Description, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcRoot to be a `IfcText`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1141,38 +1141,38 @@ template <> size_t GenericFill<IfcElectricTimeControlType>(const DB& db, const L
 {
 	size_t base = GenericFill(db,params,static_cast<IfcFlowControllerType*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcRepresentation>(const DB& db, const LIST& params, IfcRepresentation* in)
 {
 	size_t base = 0;
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcRepresentation"); }    do { // convert the 'ContextOfItems' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcRepresentation,4>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->ContextOfItems, arg, db ); break; } 
+        try { GenericConvert( in->ContextOfItems, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcRepresentation to be a `IfcRepresentationContext`")); }
     } while(0);
     do { // convert the 'RepresentationIdentifier' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcRepresentation,4>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->RepresentationIdentifier, arg, db ); break; } 
+        try { GenericConvert( in->RepresentationIdentifier, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcRepresentation to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'RepresentationType' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcRepresentation,4>::aux_is_derived[2]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->RepresentationType, arg, db ); break; } 
+        try { GenericConvert( in->RepresentationType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcRepresentation to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'Items' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcRepresentation,4>::aux_is_derived[3]=true; break; }
-        try { GenericConvert( in->Items, arg, db ); break; } 
+        try { GenericConvert( in->Items, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcRepresentation to be a `SET [1:?] OF IfcRepresentationItem`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1227,19 +1227,19 @@ template <> size_t GenericFill<IfcCoilType>(const DB& db, const LIST& params, If
 {
 	size_t base = GenericFill(db,params,static_cast<IfcEnergyConversionDeviceType*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcObject>(const DB& db, const LIST& params, IfcObject* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcObjectDefinition*>(in));
 	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcObject"); }    do { // convert the 'ObjectType' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcObject,1>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ObjectType, arg, db ); break; } 
+        try { GenericConvert( in->ObjectType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcObject to be a `IfcLabel`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1280,65 +1280,65 @@ template <> size_t GenericFill<IfcTextLiteralWithExtent>(const DB& db, const LIS
 {
 	size_t base = GenericFill(db,params,static_cast<IfcTextLiteral*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcProductRepresentation>(const DB& db, const LIST& params, IfcProductRepresentation* in)
 {
 	size_t base = 0;
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcProductRepresentation"); }    do { // convert the 'Name' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcProductRepresentation,3>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Name, arg, db ); break; } 
+        try { GenericConvert( in->Name, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcProductRepresentation to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'Description' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcProductRepresentation,3>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Description, arg, db ); break; } 
+        try { GenericConvert( in->Description, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcProductRepresentation to be a `IfcText`")); }
     } while(0);
     do { // convert the 'Representations' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcProductRepresentation,3>::aux_is_derived[2]=true; break; }
-        try { GenericConvert( in->Representations, arg, db ); break; } 
+        try { GenericConvert( in->Representations, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcProductRepresentation to be a `LIST [1:?] OF IfcRepresentation`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcProduct>(const DB& db, const LIST& params, IfcProduct* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcObject*>(in));
 	if (params.GetSize() < 7) { throw STEP::TypeError("expected 7 arguments to IfcProduct"); }    do { // convert the 'ObjectPlacement' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcProduct,2>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ObjectPlacement, arg, db ); break; } 
+        try { GenericConvert( in->ObjectPlacement, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcProduct to be a `IfcObjectPlacement`")); }
     } while(0);
     do { // convert the 'Representation' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcProduct,2>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Representation, arg, db ); break; } 
+        try { GenericConvert( in->Representation, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to IfcProduct to be a `IfcProductRepresentation`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcElement>(const DB& db, const LIST& params, IfcElement* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcProduct*>(in));
 	if (params.GetSize() < 8) { throw STEP::TypeError("expected 8 arguments to IfcElement"); }    do { // convert the 'Tag' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcElement,1>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Tag, arg, db ); break; } 
+        try { GenericConvert( in->Tag, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to IfcElement to be a `IfcIdentifier`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1366,23 +1366,23 @@ template <> size_t GenericFill<IfcBoundedCurve>(const DB& db, const LIST& params
 {
 	size_t base = GenericFill(db,params,static_cast<IfcCurve*>(in));
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcCompositeCurve>(const DB& db, const LIST& params, IfcCompositeCurve* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcBoundedCurve*>(in));
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcCompositeCurve"); }    do { // convert the 'Segments' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcCompositeCurve,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Segments, arg, db ); break; } 
+        try { GenericConvert( in->Segments, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcCompositeCurve to be a `LIST [1:?] OF IfcCompositeCurveSegment`")); }
     } while(0);
     do { // convert the 'SelfIntersect' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcCompositeCurve,2>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->SelfIntersect, arg, db ); break; } 
+        try { GenericConvert( in->SelfIntersect, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcCompositeCurve to be a `LOGICAL`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1390,71 +1390,71 @@ template <> size_t GenericFill<Ifc2DCompositeCurve>(const DB& db, const LIST& pa
 {
 	size_t base = GenericFill(db,params,static_cast<IfcCompositeCurve*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcCartesianTransformationOperator>(const DB& db, const LIST& params, IfcCartesianTransformationOperator* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcCartesianTransformationOperator"); }    do { // convert the 'Axis1' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcCartesianTransformationOperator,4>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Axis1, arg, db ); break; } 
+        try { GenericConvert( in->Axis1, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcCartesianTransformationOperator to be a `IfcDirection`")); }
     } while(0);
     do { // convert the 'Axis2' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcCartesianTransformationOperator,4>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Axis2, arg, db ); break; } 
+        try { GenericConvert( in->Axis2, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcCartesianTransformationOperator to be a `IfcDirection`")); }
     } while(0);
     do { // convert the 'LocalOrigin' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcCartesianTransformationOperator,4>::aux_is_derived[2]=true; break; }
-        try { GenericConvert( in->LocalOrigin, arg, db ); break; } 
+        try { GenericConvert( in->LocalOrigin, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcCartesianTransformationOperator to be a `IfcCartesianPoint`")); }
     } while(0);
     do { // convert the 'Scale' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcCartesianTransformationOperator,4>::aux_is_derived[3]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Scale, arg, db ); break; } 
+        try { GenericConvert( in->Scale, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcCartesianTransformationOperator to be a `REAL`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcCartesianTransformationOperator3D>(const DB& db, const LIST& params, IfcCartesianTransformationOperator3D* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcCartesianTransformationOperator*>(in));
 	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcCartesianTransformationOperator3D"); }    do { // convert the 'Axis3' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcCartesianTransformationOperator3D,1>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Axis3, arg, db ); break; } 
+        try { GenericConvert( in->Axis3, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcCartesianTransformationOperator3D to be a `IfcDirection`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcProperty>(const DB& db, const LIST& params, IfcProperty* in)
 {
 	size_t base = 0;
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcProperty"); }    do { // convert the 'Name' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcProperty,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Name, arg, db ); break; } 
+        try { GenericConvert( in->Name, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcProperty to be a `IfcIdentifier`")); }
     } while(0);
     do { // convert the 'Description' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcProperty,2>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Description, arg, db ); break; } 
+        try { GenericConvert( in->Description, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcProperty to be a `IfcText`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1489,17 +1489,17 @@ template <> size_t GenericFill<IfcSurface>(const DB& db, const LIST& params, Ifc
 {
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcElementarySurface>(const DB& db, const LIST& params, IfcElementarySurface* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcSurface*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcElementarySurface"); }    do { // convert the 'Position' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcElementarySurface,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Position, arg, db ); break; } 
+        try { GenericConvert( in->Position, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcElementarySurface to be a `IfcAxis2Placement3D`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1507,29 +1507,29 @@ template <> size_t GenericFill<IfcPlane>(const DB& db, const LIST& params, IfcPl
 {
 	size_t base = GenericFill(db,params,static_cast<IfcElementarySurface*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcPlane"); }	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcBooleanResult>(const DB& db, const LIST& params, IfcBooleanResult* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcBooleanResult"); }    do { // convert the 'Operator' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcBooleanResult,3>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Operator, arg, db ); break; } 
+        try { GenericConvert( in->Operator, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcBooleanResult to be a `IfcBooleanOperator`")); }
     } while(0);
     do { // convert the 'FirstOperand' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcBooleanResult,3>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->FirstOperand, arg, db ); break; } 
+        try { GenericConvert( in->FirstOperand, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcBooleanResult to be a `IfcBooleanOperand`")); }
     } while(0);
     do { // convert the 'SecondOperand' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcBooleanResult,3>::aux_is_derived[2]=true; break; }
-        try { GenericConvert( in->SecondOperand, arg, db ); break; } 
+        try { GenericConvert( in->SecondOperand, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcBooleanResult to be a `IfcBooleanOperand`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1543,17 +1543,17 @@ template <> size_t GenericFill<IfcSolidModel>(const DB& db, const LIST& params,
 {
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcManifoldSolidBrep>(const DB& db, const LIST& params, IfcManifoldSolidBrep* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcSolidModel*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcManifoldSolidBrep"); }    do { // convert the 'Outer' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcManifoldSolidBrep,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Outer, arg, db ); break; } 
+        try { GenericConvert( in->Outer, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcManifoldSolidBrep to be a `IfcClosedShell`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1622,22 +1622,22 @@ template <> size_t GenericFill<IfcTask>(const DB& db, const LIST& params, IfcTas
 {
 	size_t base = GenericFill(db,params,static_cast<IfcProcess*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcRelFillsElement>(const DB& db, const LIST& params, IfcRelFillsElement* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcRelConnects*>(in));
 	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcRelFillsElement"); }    do { // convert the 'RelatingOpeningElement' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelatingOpeningElement, arg, db ); break; } 
+        try { GenericConvert( in->RelatingOpeningElement, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcRelFillsElement to be a `IfcOpeningElement`")); }
     } while(0);
     do { // convert the 'RelatedBuildingElement' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelatedBuildingElement, arg, db ); break; } 
+        try { GenericConvert( in->RelatedBuildingElement, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcRelFillsElement to be a `IfcElement`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1673,22 +1673,22 @@ template <> size_t GenericFill<IfcSubContractResource>(const DB& db, const LIST&
 {
 	size_t base = GenericFill(db,params,static_cast<IfcConstructionResource*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcRelContainedInSpatialStructure>(const DB& db, const LIST& params, IfcRelContainedInSpatialStructure* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcRelConnects*>(in));
 	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcRelContainedInSpatialStructure"); }    do { // convert the 'RelatedElements' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelatedElements, arg, db ); break; } 
+        try { GenericConvert( in->RelatedElements, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcRelContainedInSpatialStructure to be a `SET [1:?] OF IfcProduct`")); }
     } while(0);
     do { // convert the 'RelatingStructure' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelatingStructure, arg, db ); break; } 
+        try { GenericConvert( in->RelatingStructure, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcRelContainedInSpatialStructure to be a `IfcSpatialStructureElement`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1764,48 +1764,48 @@ template <> size_t GenericFill<IfcOrientedEdge>(const DB& db, const LIST& params
 {
 	size_t base = GenericFill(db,params,static_cast<IfcEdge*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcDirection>(const DB& db, const LIST& params, IfcDirection* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcDirection"); }    do { // convert the 'DirectionRatios' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->DirectionRatios, arg, db ); break; } 
+        try { GenericConvert( in->DirectionRatios, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcDirection to be a `LIST [2:3] OF REAL`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcProfileDef>(const DB& db, const LIST& params, IfcProfileDef* in)
 {
 	size_t base = 0;
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcProfileDef"); }    do { // convert the 'ProfileType' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcProfileDef,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->ProfileType, arg, db ); break; } 
+        try { GenericConvert( in->ProfileType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcProfileDef to be a `IfcProfileTypeEnum`")); }
     } while(0);
     do { // convert the 'ProfileName' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcProfileDef,2>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ProfileName, arg, db ); break; } 
+        try { GenericConvert( in->ProfileName, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcProfileDef to be a `IfcLabel`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcParameterizedProfileDef>(const DB& db, const LIST& params, IfcParameterizedProfileDef* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcProfileDef*>(in));
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcParameterizedProfileDef"); }    do { // convert the 'Position' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcParameterizedProfileDef,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Position, arg, db ); break; } 
+        try { GenericConvert( in->Position, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcParameterizedProfileDef to be a `IfcAxis2Placement2D`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1901,72 +1901,72 @@ template <> size_t GenericFill<IfcCondenserType>(const DB& db, const LIST& param
 {
 	size_t base = GenericFill(db,params,static_cast<IfcEnergyConversionDeviceType*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcCircleProfileDef>(const DB& db, const LIST& params, IfcCircleProfileDef* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcParameterizedProfileDef*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcCircleProfileDef"); }    do { // convert the 'Radius' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcCircleProfileDef,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Radius, arg, db ); break; } 
+        try { GenericConvert( in->Radius, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcCircleProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcCircleHollowProfileDef>(const DB& db, const LIST& params, IfcCircleHollowProfileDef* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcCircleProfileDef*>(in));
 	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcCircleHollowProfileDef"); }    do { // convert the 'WallThickness' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->WallThickness, arg, db ); break; } 
+        try { GenericConvert( in->WallThickness, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcCircleHollowProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcPlacement>(const DB& db, const LIST& params, IfcPlacement* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcPlacement"); }    do { // convert the 'Location' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcPlacement,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Location, arg, db ); break; } 
+        try { GenericConvert( in->Location, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcPlacement to be a `IfcCartesianPoint`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcAxis2Placement3D>(const DB& db, const LIST& params, IfcAxis2Placement3D* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcPlacement*>(in));
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcAxis2Placement3D"); }    do { // convert the 'Axis' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Axis, arg, db ); break; } 
+        try { GenericConvert( in->Axis, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcAxis2Placement3D to be a `IfcDirection`")); }
     } while(0);
     do { // convert the 'RefDirection' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->RefDirection, arg, db ); break; } 
+        try { GenericConvert( in->RefDirection, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcAxis2Placement3D to be a `IfcDirection`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcPresentationStyle>(const DB& db, const LIST& params, IfcPresentationStyle* in)
 {
 	size_t base = 0;
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcPresentationStyle"); }    do { // convert the 'Name' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcPresentationStyle,1>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Name, arg, db ); break; } 
+        try { GenericConvert( in->Name, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcPresentationStyle to be a `IfcLabel`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1974,45 +1974,45 @@ template <> size_t GenericFill<IfcEquipmentElement>(const DB& db, const LIST& pa
 {
 	size_t base = GenericFill(db,params,static_cast<IfcElement*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcCompositeCurveSegment>(const DB& db, const LIST& params, IfcCompositeCurveSegment* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcCompositeCurveSegment"); }    do { // convert the 'Transition' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Transition, arg, db ); break; } 
+        try { GenericConvert( in->Transition, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcCompositeCurveSegment to be a `IfcTransitionCode`")); }
     } while(0);
     do { // convert the 'SameSense' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->SameSense, arg, db ); break; } 
+        try { GenericConvert( in->SameSense, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcCompositeCurveSegment to be a `BOOLEAN`")); }
     } while(0);
     do { // convert the 'ParentCurve' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->ParentCurve, arg, db ); break; } 
+        try { GenericConvert( in->ParentCurve, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcCompositeCurveSegment to be a `IfcCurve`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcRectangleProfileDef>(const DB& db, const LIST& params, IfcRectangleProfileDef* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcParameterizedProfileDef*>(in));
 	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcRectangleProfileDef"); }    do { // convert the 'XDim' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcRectangleProfileDef,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->XDim, arg, db ); break; } 
+        try { GenericConvert( in->XDim, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcRectangleProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'YDim' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcRectangleProfileDef,2>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->YDim, arg, db ); break; } 
+        try { GenericConvert( in->YDim, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcRectangleProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -2097,57 +2097,57 @@ template <> size_t GenericFill<IfcAngularDimension>(const DB& db, const LIST& pa
 {
 	size_t base = GenericFill(db,params,static_cast<IfcDimensionCurveDirectedCallout*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcLocalPlacement>(const DB& db, const LIST& params, IfcLocalPlacement* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcObjectPlacement*>(in));
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcLocalPlacement"); }    do { // convert the 'PlacementRelTo' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->PlacementRelTo, arg, db ); break; } 
+        try { GenericConvert( in->PlacementRelTo, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcLocalPlacement to be a `IfcObjectPlacement`")); }
     } while(0);
     do { // convert the 'RelativePlacement' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelativePlacement, arg, db ); break; } 
+        try { GenericConvert( in->RelativePlacement, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcLocalPlacement to be a `IfcAxis2Placement`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcSweptAreaSolid>(const DB& db, const LIST& params, IfcSweptAreaSolid* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcSolidModel*>(in));
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcSweptAreaSolid"); }    do { // convert the 'SweptArea' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcSweptAreaSolid,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->SweptArea, arg, db ); break; } 
+        try { GenericConvert( in->SweptArea, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcSweptAreaSolid to be a `IfcProfileDef`")); }
     } while(0);
     do { // convert the 'Position' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcSweptAreaSolid,2>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->Position, arg, db ); break; } 
+        try { GenericConvert( in->Position, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcSweptAreaSolid to be a `IfcAxis2Placement3D`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcRevolvedAreaSolid>(const DB& db, const LIST& params, IfcRevolvedAreaSolid* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcSweptAreaSolid*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcRevolvedAreaSolid"); }    do { // convert the 'Axis' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Axis, arg, db ); break; } 
+        try { GenericConvert( in->Axis, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcRevolvedAreaSolid to be a `IfcAxis1Placement`")); }
     } while(0);
     do { // convert the 'Angle' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Angle, arg, db ); break; } 
+        try { GenericConvert( in->Angle, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcRevolvedAreaSolid to be a `IfcPlaneAngleMeasure`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -2162,72 +2162,72 @@ template <> size_t GenericFill<IfcRadiusDimension>(const DB& db, const LIST& par
 {
 	size_t base = GenericFill(db,params,static_cast<IfcDimensionCurveDirectedCallout*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcSweptDiskSolid>(const DB& db, const LIST& params, IfcSweptDiskSolid* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcSolidModel*>(in));
 	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcSweptDiskSolid"); }    do { // convert the 'Directrix' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Directrix, arg, db ); break; } 
+        try { GenericConvert( in->Directrix, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcSweptDiskSolid to be a `IfcCurve`")); }
     } while(0);
     do { // convert the 'Radius' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Radius, arg, db ); break; } 
+        try { GenericConvert( in->Radius, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcSweptDiskSolid to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'InnerRadius' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->InnerRadius, arg, db ); break; } 
+        try { GenericConvert( in->InnerRadius, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcSweptDiskSolid to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'StartParam' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->StartParam, arg, db ); break; } 
+        try { GenericConvert( in->StartParam, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcSweptDiskSolid to be a `IfcParameterValue`")); }
     } while(0);
     do { // convert the 'EndParam' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->EndParam, arg, db ); break; } 
+        try { GenericConvert( in->EndParam, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcSweptDiskSolid to be a `IfcParameterValue`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcHalfSpaceSolid>(const DB& db, const LIST& params, IfcHalfSpaceSolid* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcHalfSpaceSolid"); }    do { // convert the 'BaseSurface' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcHalfSpaceSolid,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->BaseSurface, arg, db ); break; } 
+        try { GenericConvert( in->BaseSurface, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcHalfSpaceSolid to be a `IfcSurface`")); }
     } while(0);
     do { // convert the 'AgreementFlag' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcHalfSpaceSolid,2>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->AgreementFlag, arg, db ); break; } 
+        try { GenericConvert( in->AgreementFlag, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcHalfSpaceSolid to be a `BOOLEAN`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcPolygonalBoundedHalfSpace>(const DB& db, const LIST& params, IfcPolygonalBoundedHalfSpace* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcHalfSpaceSolid*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcPolygonalBoundedHalfSpace"); }    do { // convert the 'Position' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Position, arg, db ); break; } 
+        try { GenericConvert( in->Position, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcPolygonalBoundedHalfSpace to be a `IfcAxis2Placement3D`")); }
     } while(0);
     do { // convert the 'PolygonalBoundary' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->PolygonalBoundary, arg, db ); break; } 
+        try { GenericConvert( in->PolygonalBoundary, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcPolygonalBoundedHalfSpace to be a `IfcBoundedCurve`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -2242,34 +2242,34 @@ template <> size_t GenericFill<IfcCooledBeamType>(const DB& db, const LIST& para
 {
 	size_t base = GenericFill(db,params,static_cast<IfcEnergyConversionDeviceType*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcProject>(const DB& db, const LIST& params, IfcProject* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcObject*>(in));
 	if (params.GetSize() < 9) { throw STEP::TypeError("expected 9 arguments to IfcProject"); }    do { // convert the 'LongName' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->LongName, arg, db ); break; } 
+        try { GenericConvert( in->LongName, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcProject to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'Phase' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Phase, arg, db ); break; } 
+        try { GenericConvert( in->Phase, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to IfcProject to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'RepresentationContexts' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RepresentationContexts, arg, db ); break; } 
+        try { GenericConvert( in->RepresentationContexts, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to IfcProject to be a `SET [1:?] OF IfcRepresentationContext`")); }
     } while(0);
     do { // convert the 'UnitsInContext' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->UnitsInContext, arg, db ); break; } 
+        try { GenericConvert( in->UnitsInContext, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to IfcProject to be a `IfcUnitAssignment`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -2319,61 +2319,61 @@ template <> size_t GenericFill<IfcValveType>(const DB& db, const LIST& params, I
 {
 	size_t base = GenericFill(db,params,static_cast<IfcFlowControllerType*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcTrimmedCurve>(const DB& db, const LIST& params, IfcTrimmedCurve* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcBoundedCurve*>(in));
 	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcTrimmedCurve"); }    do { // convert the 'BasisCurve' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->BasisCurve, arg, db ); break; } 
+        try { GenericConvert( in->BasisCurve, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcTrimmedCurve to be a `IfcCurve`")); }
     } while(0);
     do { // convert the 'Trim1' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Trim1, arg, db ); break; } 
+        try { GenericConvert( in->Trim1, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcTrimmedCurve to be a `SET [1:2] OF IfcTrimmingSelect`")); }
     } while(0);
     do { // convert the 'Trim2' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Trim2, arg, db ); break; } 
+        try { GenericConvert( in->Trim2, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcTrimmedCurve to be a `SET [1:2] OF IfcTrimmingSelect`")); }
     } while(0);
     do { // convert the 'SenseAgreement' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->SenseAgreement, arg, db ); break; } 
+        try { GenericConvert( in->SenseAgreement, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcTrimmedCurve to be a `BOOLEAN`")); }
     } while(0);
     do { // convert the 'MasterRepresentation' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->MasterRepresentation, arg, db ); break; } 
+        try { GenericConvert( in->MasterRepresentation, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcTrimmedCurve to be a `IfcTrimmingPreference`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcRelDefines>(const DB& db, const LIST& params, IfcRelDefines* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcRelationship*>(in));
 	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcRelDefines"); }    do { // convert the 'RelatedObjects' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcRelDefines,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->RelatedObjects, arg, db ); break; } 
+        try { GenericConvert( in->RelatedObjects, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcRelDefines to be a `SET [1:?] OF IfcObject`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcRelDefinesByProperties>(const DB& db, const LIST& params, IfcRelDefinesByProperties* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcRelDefines*>(in));
 	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcRelDefinesByProperties"); }    do { // convert the 'RelatingPropertyDefinition' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcRelDefinesByProperties,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->RelatingPropertyDefinition, arg, db ); break; } 
+        try { GenericConvert( in->RelatingPropertyDefinition, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcRelDefinesByProperties to be a `IfcPropertySetDefinition`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -2395,18 +2395,18 @@ template <> size_t GenericFill<IfcHumidifierType>(const DB& db, const LIST& para
 {
 	size_t base = GenericFill(db,params,static_cast<IfcEnergyConversionDeviceType*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcArbitraryOpenProfileDef>(const DB& db, const LIST& params, IfcArbitraryOpenProfileDef* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcProfileDef*>(in));
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcArbitraryOpenProfileDef"); }    do { // convert the 'Curve' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcArbitraryOpenProfileDef,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Curve, arg, db ); break; } 
+        try { GenericConvert( in->Curve, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcArbitraryOpenProfileDef to be a `IfcBoundedCurve`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -2561,24 +2561,24 @@ template <> size_t GenericFill<IfcOutletType>(const DB& db, const LIST& params,
 {
 	size_t base = GenericFill(db,params,static_cast<IfcFlowTerminalType*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcRelDecomposes>(const DB& db, const LIST& params, IfcRelDecomposes* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcRelationship*>(in));
 	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcRelDecomposes"); }    do { // convert the 'RelatingObject' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcRelDecomposes,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->RelatingObject, arg, db ); break; } 
+        try { GenericConvert( in->RelatingObject, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcRelDecomposes to be a `IfcObjectDefinition`")); }
     } while(0);
     do { // convert the 'RelatedObjects' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcRelDecomposes,2>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->RelatedObjects, arg, db ); break; } 
+        try { GenericConvert( in->RelatedObjects, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcRelDecomposes to be a `SET [1:?] OF IfcObjectDefinition`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -2586,17 +2586,17 @@ template <> size_t GenericFill<IfcCovering>(const DB& db, const LIST& params, If
 {
 	size_t base = GenericFill(db,params,static_cast<IfcBuildingElement*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcPolyline>(const DB& db, const LIST& params, IfcPolyline* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcBoundedCurve*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcPolyline"); }    do { // convert the 'Points' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Points, arg, db ); break; } 
+        try { GenericConvert( in->Points, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcPolyline to be a `LIST [2:?] OF IfcCartesianPoint`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -2618,22 +2618,22 @@ template <> size_t GenericFill<IfcFastener>(const DB& db, const LIST& params, If
 {
 	size_t base = GenericFill(db,params,static_cast<IfcElementComponent*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcMappedItem>(const DB& db, const LIST& params, IfcMappedItem* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcRepresentationItem*>(in));
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcMappedItem"); }    do { // convert the 'MappingSource' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->MappingSource, arg, db ); break; } 
+        try { GenericConvert( in->MappingSource, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcMappedItem to be a `IfcRepresentationMap`")); }
     } while(0);
     do { // convert the 'MappingTarget' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->MappingTarget, arg, db ); break; } 
+        try { GenericConvert( in->MappingTarget, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcMappedItem to be a `IfcCartesianTransformationOperator`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -2648,25 +2648,25 @@ template <> size_t GenericFill<IfcCrewResource>(const DB& db, const LIST& params
 {
 	size_t base = GenericFill(db,params,static_cast<IfcConstructionResource*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcNamedUnit>(const DB& db, const LIST& params, IfcNamedUnit* in)
 {
 	size_t base = 0;
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcNamedUnit"); }    do { // convert the 'Dimensions' argument
         std::shared_ptr<const DataType> arg = params[base++];
 		if (dynamic_cast<const UNSET*>(&*arg)) break;
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcNamedUnit,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Dimensions, arg, db ); break; } 
+        try { GenericConvert( in->Dimensions, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcNamedUnit to be a `IfcDimensionalExponents`")); }
     } while(0);
     do { // convert the 'UnitType' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcNamedUnit,2>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->UnitType, arg, db ); break; } 
+        try { GenericConvert( in->UnitType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcNamedUnit to be a `IfcUnitEnum`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -2709,61 +2709,61 @@ template <> size_t GenericFill<IfcStyledRepresentation>(const DB& db, const LIST
 {
 	size_t base = GenericFill(db,params,static_cast<IfcStyleModel*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcSpatialStructureElement>(const DB& db, const LIST& params, IfcSpatialStructureElement* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcProduct*>(in));
 	if (params.GetSize() < 9) { throw STEP::TypeError("expected 9 arguments to IfcSpatialStructureElement"); }    do { // convert the 'LongName' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcSpatialStructureElement,2>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->LongName, arg, db ); break; } 
+        try { GenericConvert( in->LongName, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to IfcSpatialStructureElement to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'CompositionType' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcSpatialStructureElement,2>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->CompositionType, arg, db ); break; } 
+        try { GenericConvert( in->CompositionType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to IfcSpatialStructureElement to be a `IfcElementCompositionEnum`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcBuilding>(const DB& db, const LIST& params, IfcBuilding* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcSpatialStructureElement*>(in));
 	if (params.GetSize() < 12) { throw STEP::TypeError("expected 12 arguments to IfcBuilding"); }    do { // convert the 'ElevationOfRefHeight' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ElevationOfRefHeight, arg, db ); break; } 
+        try { GenericConvert( in->ElevationOfRefHeight, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 9 to IfcBuilding to be a `IfcLengthMeasure`")); }
     } while(0);
     do { // convert the 'ElevationOfTerrain' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ElevationOfTerrain, arg, db ); break; } 
+        try { GenericConvert( in->ElevationOfTerrain, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 10 to IfcBuilding to be a `IfcLengthMeasure`")); }
     } while(0);
     do { // convert the 'BuildingAddress' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->BuildingAddress, arg, db ); break; } 
+        try { GenericConvert( in->BuildingAddress, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 11 to IfcBuilding to be a `IfcPostalAddress`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcConnectedFaceSet>(const DB& db, const LIST& params, IfcConnectedFaceSet* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcTopologicalRepresentationItem*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcConnectedFaceSet"); }    do { // convert the 'CfsFaces' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcConnectedFaceSet,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->CfsFaces, arg, db ); break; } 
+        try { GenericConvert( in->CfsFaces, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcConnectedFaceSet to be a `SET [1:?] OF IfcFace`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -2778,18 +2778,18 @@ template <> size_t GenericFill<IfcFacetedBrep>(const DB& db, const LIST& params,
 {
 	size_t base = GenericFill(db,params,static_cast<IfcManifoldSolidBrep*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcConic>(const DB& db, const LIST& params, IfcConic* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcCurve*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcConic"); }    do { // convert the 'Position' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcConic,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Position, arg, db ); break; } 
+        try { GenericConvert( in->Position, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcConic to be a `IfcAxis2Placement`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -2825,43 +2825,43 @@ template <> size_t GenericFill<IfcCompressorType>(const DB& db, const LIST& para
 {
 	size_t base = GenericFill(db,params,static_cast<IfcFlowMovingDeviceType*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcIShapeProfileDef>(const DB& db, const LIST& params, IfcIShapeProfileDef* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcParameterizedProfileDef*>(in));
 	if (params.GetSize() < 8) { throw STEP::TypeError("expected 8 arguments to IfcIShapeProfileDef"); }    do { // convert the 'OverallWidth' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcIShapeProfileDef,5>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->OverallWidth, arg, db ); break; } 
+        try { GenericConvert( in->OverallWidth, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcIShapeProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'OverallDepth' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcIShapeProfileDef,5>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->OverallDepth, arg, db ); break; } 
+        try { GenericConvert( in->OverallDepth, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcIShapeProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'WebThickness' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcIShapeProfileDef,5>::aux_is_derived[2]=true; break; }
-        try { GenericConvert( in->WebThickness, arg, db ); break; } 
+        try { GenericConvert( in->WebThickness, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcIShapeProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'FlangeThickness' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcIShapeProfileDef,5>::aux_is_derived[3]=true; break; }
-        try { GenericConvert( in->FlangeThickness, arg, db ); break; } 
+        try { GenericConvert( in->FlangeThickness, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to IfcIShapeProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'FilletRadius' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcIShapeProfileDef,5>::aux_is_derived[4]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->FilletRadius, arg, db ); break; } 
+        try { GenericConvert( in->FilletRadius, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to IfcIShapeProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -2925,23 +2925,23 @@ template <> size_t GenericFill<IfcStructuralPointConnection>(const DB& db, const
 {
 	size_t base = GenericFill(db,params,static_cast<IfcStructuralConnection*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcPropertyListValue>(const DB& db, const LIST& params, IfcPropertyListValue* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcSimpleProperty*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcPropertyListValue"); }    do { // convert the 'ListValues' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->ListValues, arg, db ); break; } 
+        try { GenericConvert( in->ListValues, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcPropertyListValue to be a `LIST [1:?] OF IfcValue`")); }
     } while(0);
     do { // convert the 'Unit' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Unit, arg, db ); break; } 
+        try { GenericConvert( in->Unit, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcPropertyListValue to be a `IfcUnit`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -2956,50 +2956,50 @@ template <> size_t GenericFill<IfcElectricGeneratorType>(const DB& db, const LIS
 {
 	size_t base = GenericFill(db,params,static_cast<IfcEnergyConversionDeviceType*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcDoor>(const DB& db, const LIST& params, IfcDoor* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcBuildingElement*>(in));
 	if (params.GetSize() < 10) { throw STEP::TypeError("expected 10 arguments to IfcDoor"); }    do { // convert the 'OverallHeight' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->OverallHeight, arg, db ); break; } 
+        try { GenericConvert( in->OverallHeight, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to IfcDoor to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'OverallWidth' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->OverallWidth, arg, db ); break; } 
+        try { GenericConvert( in->OverallWidth, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 9 to IfcDoor to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcStyledItem>(const DB& db, const LIST& params, IfcStyledItem* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcRepresentationItem*>(in));
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcStyledItem"); }    do { // convert the 'Item' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcStyledItem,3>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Item, arg, db ); break; } 
+        try { GenericConvert( in->Item, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcStyledItem to be a `IfcRepresentationItem`")); }
     } while(0);
     do { // convert the 'Styles' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcStyledItem,3>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->Styles, arg, db ); break; } 
+        try { GenericConvert( in->Styles, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcStyledItem to be a `SET [1:?] OF IfcPresentationStyleAssignment`")); }
     } while(0);
     do { // convert the 'Name' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcStyledItem,3>::aux_is_derived[2]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Name, arg, db ); break; } 
+        try { GenericConvert( in->Name, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcStyledItem to be a `IfcLabel`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -3014,18 +3014,18 @@ template <> size_t GenericFill<IfcAnnotationSymbolOccurrence>(const DB& db, cons
 {
 	size_t base = GenericFill(db,params,static_cast<IfcAnnotationOccurrence*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcArbitraryClosedProfileDef>(const DB& db, const LIST& params, IfcArbitraryClosedProfileDef* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcProfileDef*>(in));
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcArbitraryClosedProfileDef"); }    do { // convert the 'OuterCurve' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcArbitraryClosedProfileDef,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->OuterCurve, arg, db ); break; } 
+        try { GenericConvert( in->OuterCurve, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcArbitraryClosedProfileDef to be a `IfcCurve`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -3033,22 +3033,22 @@ template <> size_t GenericFill<IfcArbitraryProfileDefWithVoids>(const DB& db, co
 {
 	size_t base = GenericFill(db,params,static_cast<IfcArbitraryClosedProfileDef*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcLine>(const DB& db, const LIST& params, IfcLine* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcCurve*>(in));
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcLine"); }    do { // convert the 'Pnt' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Pnt, arg, db ); break; } 
+        try { GenericConvert( in->Pnt, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcLine to be a `IfcCartesianPoint`")); }
     } while(0);
     do { // convert the 'Dir' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Dir, arg, db ); break; } 
+        try { GenericConvert( in->Dir, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcLine to be a `IfcVector`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -3063,24 +3063,24 @@ template <> size_t GenericFill<IfcAirTerminalBoxType>(const DB& db, const LIST&
 {
 	size_t base = GenericFill(db,params,static_cast<IfcFlowControllerType*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcPropertySingleValue>(const DB& db, const LIST& params, IfcPropertySingleValue* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcSimpleProperty*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcPropertySingleValue"); }    do { // convert the 'NominalValue' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->NominalValue, arg, db ); break; } 
+        try { GenericConvert( in->NominalValue, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcPropertySingleValue to be a `IfcValue`")); }
     } while(0);
     do { // convert the 'Unit' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Unit, arg, db ); break; } 
+        try { GenericConvert( in->Unit, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcPropertySingleValue to be a `IfcUnit`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -3102,18 +3102,18 @@ template <> size_t GenericFill<IfcStair>(const DB& db, const LIST& params, IfcSt
 {
 	size_t base = GenericFill(db,params,static_cast<IfcBuildingElement*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcSurfaceStyleShading>(const DB& db, const LIST& params, IfcSurfaceStyleShading* in)
 {
 	size_t base = 0;
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcSurfaceStyleShading"); }    do { // convert the 'SurfaceColour' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcSurfaceStyleShading,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->SurfaceColour, arg, db ); break; } 
+        try { GenericConvert( in->SurfaceColour, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcSurfaceStyleShading to be a `IfcColourRgb`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
diff --git a/code/AssetLib/IFC/IFCReaderGen2_2x3.cpp b/code/AssetLib/IFC/IFCReaderGen2_2x3.cpp
index c58c7c42f..0d7051195 100644
--- a/code/AssetLib/IFC/IFCReaderGen2_2x3.cpp
+++ b/code/AssetLib/IFC/IFCReaderGen2_2x3.cpp
@@ -5,8 +5,8 @@ Open Asset Import Library (ASSIMP)
 Copyright (c) 2006-2020, ASSIMP Development Team
 All rights reserved.
 
-Redistribution and use of this software in source and binary forms, 
-with or without modification, are permitted provided that the 
+Redistribution and use of this software in source and binary forms,
+with or without modification, are permitted provided that the
 following conditions are met:
 
 * Redistributions of source code must retain the above
@@ -23,16 +23,16 @@ following conditions are met:
   derived from this software without specific prior
   written permission of the ASSIMP Development Team.
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 ----------------------------------------------------------------------
@@ -57,16 +57,16 @@ namespace STEP {
 template <> size_t GenericFill<IfcSurfaceStyle>(const DB& db, const LIST& params, IfcSurfaceStyle* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcPresentationStyle*>(in));
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcSurfaceStyle"); }    do { // convert the 'Side' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Side, arg, db ); break; } 
+        try { GenericConvert( in->Side, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcSurfaceStyle to be a `IfcSurfaceSide`")); }
     } while(0);
     do { // convert the 'Styles' argument
         std::shared_ptr<const DataType> arg = params[ base++ ];
-        try { GenericConvert( in->Styles, arg, db ); break; } 
+        try { GenericConvert( in->Styles, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcSurfaceStyle to be a `SET [1:5] OF IfcSurfaceStyleElementSelect`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -109,18 +109,18 @@ template <> size_t GenericFill<IfcDuctSegmentType>(const DB& db, const LIST& par
 {
 	size_t base = GenericFill(db,params,static_cast<IfcFlowSegmentType*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcFace>(const DB& db, const LIST& params, IfcFace* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcTopologicalRepresentationItem*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcFace"); }    do { // convert the 'Bounds' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcFace,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Bounds, arg, db ); break; } 
+        try { GenericConvert( in->Bounds, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcFace to be a `SET [1:?] OF IfcFaceBound`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -163,35 +163,35 @@ template <> size_t GenericFill<IfcPlanarBox>(const DB& db, const LIST& params, I
 {
 	size_t base = GenericFill(db,params,static_cast<IfcPlanarExtent*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcColourSpecification>(const DB& db, const LIST& params, IfcColourSpecification* in)
 {
 	size_t base = 0;
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcColourSpecification"); }    do { // convert the 'Name' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcColourSpecification,1>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Name, arg, db ); break; } 
+        try { GenericConvert( in->Name, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcColourSpecification to be a `IfcLabel`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcVector>(const DB& db, const LIST& params, IfcVector* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcVector"); }    do { // convert the 'Orientation' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Orientation, arg, db ); break; } 
+        try { GenericConvert( in->Orientation, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcVector to be a `IfcDirection`")); }
     } while(0);
     do { // convert the 'Magnitude' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Magnitude, arg, db ); break; } 
+        try { GenericConvert( in->Magnitude, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcVector to be a `IfcLengthMeasure`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -199,27 +199,27 @@ template <> size_t GenericFill<IfcBeam>(const DB& db, const LIST& params, IfcBea
 {
 	size_t base = GenericFill(db,params,static_cast<IfcBuildingElement*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcColourRgb>(const DB& db, const LIST& params, IfcColourRgb* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcColourSpecification*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcColourRgb"); }    do { // convert the 'Red' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Red, arg, db ); break; } 
+        try { GenericConvert( in->Red, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcColourRgb to be a `IfcNormalisedRatioMeasure`")); }
     } while(0);
     do { // convert the 'Green' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Green, arg, db ); break; } 
+        try { GenericConvert( in->Green, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcColourRgb to be a `IfcNormalisedRatioMeasure`")); }
     } while(0);
     do { // convert the 'Blue' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Blue, arg, db ); break; } 
+        try { GenericConvert( in->Blue, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcColourRgb to be a `IfcNormalisedRatioMeasure`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -234,42 +234,42 @@ template <> size_t GenericFill<IfcStructuralPlanarActionVarying>(const DB& db, c
 {
 	size_t base = GenericFill(db,params,static_cast<IfcStructuralPlanarAction*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcSite>(const DB& db, const LIST& params, IfcSite* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcSpatialStructureElement*>(in));
 	if (params.GetSize() < 14) { throw STEP::TypeError("expected 14 arguments to IfcSite"); }    do { // convert the 'RefLatitude' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->RefLatitude, arg, db ); break; } 
+        try { GenericConvert( in->RefLatitude, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 9 to IfcSite to be a `IfcCompoundPlaneAngleMeasure`")); }
     } while(0);
     do { // convert the 'RefLongitude' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->RefLongitude, arg, db ); break; } 
+        try { GenericConvert( in->RefLongitude, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 10 to IfcSite to be a `IfcCompoundPlaneAngleMeasure`")); }
     } while(0);
     do { // convert the 'RefElevation' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->RefElevation, arg, db ); break; } 
+        try { GenericConvert( in->RefElevation, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 11 to IfcSite to be a `IfcLengthMeasure`")); }
     } while(0);
     do { // convert the 'LandTitleNumber' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->LandTitleNumber, arg, db ); break; } 
+        try { GenericConvert( in->LandTitleNumber, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 12 to IfcSite to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'SiteAddress' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->SiteAddress, arg, db ); break; } 
+        try { GenericConvert( in->SiteAddress, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 13 to IfcSite to be a `IfcPostalAddress`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -403,42 +403,42 @@ template <> size_t GenericFill<IfcWasteTerminalType>(const DB& db, const LIST& p
 {
 	size_t base = GenericFill(db,params,static_cast<IfcFlowTerminalType*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcBSplineCurve>(const DB& db, const LIST& params, IfcBSplineCurve* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcBoundedCurve*>(in));
 	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcBSplineCurve"); }    do { // convert the 'Degree' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcBSplineCurve,5>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Degree, arg, db ); break; } 
+        try { GenericConvert( in->Degree, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcBSplineCurve to be a `INTEGER`")); }
     } while(0);
     do { // convert the 'ControlPointsList' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcBSplineCurve,5>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->ControlPointsList, arg, db ); break; } 
+        try { GenericConvert( in->ControlPointsList, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcBSplineCurve to be a `LIST [2:?] OF IfcCartesianPoint`")); }
     } while(0);
     do { // convert the 'CurveForm' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcBSplineCurve,5>::aux_is_derived[2]=true; break; }
-        try { GenericConvert( in->CurveForm, arg, db ); break; } 
+        try { GenericConvert( in->CurveForm, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcBSplineCurve to be a `IfcBSplineCurveForm`")); }
     } while(0);
     do { // convert the 'ClosedCurve' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcBSplineCurve,5>::aux_is_derived[3]=true; break; }
-        try { GenericConvert( in->ClosedCurve, arg, db ); break; } 
+        try { GenericConvert( in->ClosedCurve, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcBSplineCurve to be a `LOGICAL`")); }
     } while(0);
     do { // convert the 'SelfIntersect' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcBSplineCurve,5>::aux_is_derived[4]=true; break; }
-        try { GenericConvert( in->SelfIntersect, arg, db ); break; } 
+        try { GenericConvert( in->SelfIntersect, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcBSplineCurve to be a `LOGICAL`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -467,16 +467,16 @@ template <> size_t GenericFill<IfcAnnotation>(const DB& db, const LIST& params,
 {
 	size_t base = GenericFill(db,params,static_cast<IfcProduct*>(in));
 	if (params.GetSize() < 7) { throw STEP::TypeError("expected 7 arguments to IfcAnnotation"); }	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcShellBasedSurfaceModel>(const DB& db, const LIST& params, IfcShellBasedSurfaceModel* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcShellBasedSurfaceModel"); }    do { // convert the 'SbsmBoundary' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->SbsmBoundary, arg, db ); break; } 
+        try { GenericConvert( in->SbsmBoundary, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcShellBasedSurfaceModel to be a `SET [1:?] OF IfcShell`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -484,22 +484,22 @@ template <> size_t GenericFill<IfcActionRequest>(const DB& db, const LIST& param
 {
 	size_t base = GenericFill(db,params,static_cast<IfcControl*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcExtrudedAreaSolid>(const DB& db, const LIST& params, IfcExtrudedAreaSolid* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcSweptAreaSolid*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcExtrudedAreaSolid"); }    do { // convert the 'ExtrudedDirection' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->ExtrudedDirection, arg, db ); break; } 
+        try { GenericConvert( in->ExtrudedDirection, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcExtrudedAreaSolid to be a `IfcDirection`")); }
     } while(0);
     do { // convert the 'Depth' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Depth, arg, db ); break; } 
+        try { GenericConvert( in->Depth, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcExtrudedAreaSolid to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -514,22 +514,22 @@ template <> size_t GenericFill<IfcFillAreaStyleHatching>(const DB& db, const LIS
 {
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcRelVoidsElement>(const DB& db, const LIST& params, IfcRelVoidsElement* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcRelConnects*>(in));
 	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcRelVoidsElement"); }    do { // convert the 'RelatingBuildingElement' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelatingBuildingElement, arg, db ); break; } 
+        try { GenericConvert( in->RelatingBuildingElement, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcRelVoidsElement to be a `IfcElement`")); }
     } while(0);
     do { // convert the 'RelatedOpeningElement' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelatedOpeningElement, arg, db ); break; } 
+        try { GenericConvert( in->RelatedOpeningElement, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcRelVoidsElement to be a `IfcFeatureElementSubtraction`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -537,24 +537,24 @@ template <> size_t GenericFill<IfcSurfaceCurveSweptAreaSolid>(const DB& db, cons
 {
 	size_t base = GenericFill(db,params,static_cast<IfcSweptAreaSolid*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcCartesianTransformationOperator3DnonUniform>(const DB& db, const LIST& params, IfcCartesianTransformationOperator3DnonUniform* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcCartesianTransformationOperator3D*>(in));
 	if (params.GetSize() < 7) { throw STEP::TypeError("expected 7 arguments to IfcCartesianTransformationOperator3DnonUniform"); }    do { // convert the 'Scale2' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Scale2, arg, db ); break; } 
+        try { GenericConvert( in->Scale2, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcCartesianTransformationOperator3DnonUniform to be a `REAL`")); }
     } while(0);
     do { // convert the 'Scale3' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Scale3, arg, db ); break; } 
+        try { GenericConvert( in->Scale3, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to IfcCartesianTransformationOperator3DnonUniform to be a `REAL`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -625,18 +625,18 @@ template <> size_t GenericFill<IfcBoxedHalfSpace>(const DB& db, const LIST& para
 {
 	size_t base = GenericFill(db,params,static_cast<IfcHalfSpaceSolid*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcAxis2Placement2D>(const DB& db, const LIST& params, IfcAxis2Placement2D* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcPlacement*>(in));
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcAxis2Placement2D"); }    do { // convert the 'RefDirection' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->RefDirection, arg, db ); break; } 
+        try { GenericConvert( in->RefDirection, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcAxis2Placement2D to be a `IfcDirection`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -651,16 +651,16 @@ template <> size_t GenericFill<IfcPoint>(const DB& db, const LIST& params, IfcPo
 {
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcCartesianPoint>(const DB& db, const LIST& params, IfcCartesianPoint* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcPoint*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcCartesianPoint"); }    do { // convert the 'Coordinates' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Coordinates, arg, db ); break; } 
+        try { GenericConvert( in->Coordinates, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcCartesianPoint to be a `LIST [1:3] OF IfcLengthMeasure`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -675,16 +675,16 @@ template <> size_t GenericFill<IfcLoop>(const DB& db, const LIST& params, IfcLoo
 {
 	size_t base = GenericFill(db,params,static_cast<IfcTopologicalRepresentationItem*>(in));
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcPolyLoop>(const DB& db, const LIST& params, IfcPolyLoop* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcLoop*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcPolyLoop"); }    do { // convert the 'Polygon' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Polygon, arg, db ); break; } 
+        try { GenericConvert( in->Polygon, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcPolyLoop to be a `LIST [3:?] OF IfcCartesianPoint`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -706,58 +706,58 @@ template <> size_t GenericFill<IfcTrapeziumProfileDef>(const DB& db, const LIST&
 {
 	size_t base = GenericFill(db,params,static_cast<IfcParameterizedProfileDef*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcRepresentationContext>(const DB& db, const LIST& params, IfcRepresentationContext* in)
 {
 	size_t base = 0;
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcRepresentationContext"); }    do { // convert the 'ContextIdentifier' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcRepresentationContext,2>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ContextIdentifier, arg, db ); break; } 
+        try { GenericConvert( in->ContextIdentifier, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcRepresentationContext to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'ContextType' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcRepresentationContext,2>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ContextType, arg, db ); break; } 
+        try { GenericConvert( in->ContextType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcRepresentationContext to be a `IfcLabel`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcGeometricRepresentationContext>(const DB& db, const LIST& params, IfcGeometricRepresentationContext* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcRepresentationContext*>(in));
 	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcGeometricRepresentationContext"); }    do { // convert the 'CoordinateSpaceDimension' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcGeometricRepresentationContext,4>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->CoordinateSpaceDimension, arg, db ); break; } 
+        try { GenericConvert( in->CoordinateSpaceDimension, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcGeometricRepresentationContext to be a `IfcDimensionCount`")); }
     } while(0);
     do { // convert the 'Precision' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcGeometricRepresentationContext,4>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Precision, arg, db ); break; } 
+        try { GenericConvert( in->Precision, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcGeometricRepresentationContext to be a `REAL`")); }
     } while(0);
     do { // convert the 'WorldCoordinateSystem' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcGeometricRepresentationContext,4>::aux_is_derived[2]=true; break; }
-        try { GenericConvert( in->WorldCoordinateSystem, arg, db ); break; } 
+        try { GenericConvert( in->WorldCoordinateSystem, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcGeometricRepresentationContext to be a `IfcAxis2Placement`")); }
     } while(0);
     do { // convert the 'TrueNorth' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcGeometricRepresentationContext,4>::aux_is_derived[3]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->TrueNorth, arg, db ); break; } 
+        try { GenericConvert( in->TrueNorth, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcGeometricRepresentationContext to be a `IfcDirection`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -765,23 +765,23 @@ template <> size_t GenericFill<IfcCurveBoundedPlane>(const DB& db, const LIST& p
 {
 	size_t base = GenericFill(db,params,static_cast<IfcBoundedSurface*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcSIUnit>(const DB& db, const LIST& params, IfcSIUnit* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcNamedUnit*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcSIUnit"); }    do { // convert the 'Prefix' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Prefix, arg, db ); break; } 
+        try { GenericConvert( in->Prefix, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcSIUnit to be a `IfcSIPrefix`")); }
     } while(0);
     do { // convert the 'Name' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Name, arg, db ); break; } 
+        try { GenericConvert( in->Name, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcSIUnit to be a `IfcSIUnitName`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -796,18 +796,18 @@ template <> size_t GenericFill<IfcStructuralPointReaction>(const DB& db, const L
 {
 	size_t base = GenericFill(db,params,static_cast<IfcStructuralReaction*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcAxis1Placement>(const DB& db, const LIST& params, IfcAxis1Placement* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcPlacement*>(in));
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcAxis1Placement"); }    do { // convert the 'Axis' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Axis, arg, db ); break; } 
+        try { GenericConvert( in->Axis, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcAxis1Placement to be a `IfcDirection`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -850,22 +850,22 @@ template <> size_t GenericFill<IfcScheduleTimeControl>(const DB& db, const LIST&
 {
 	size_t base = GenericFill(db,params,static_cast<IfcControl*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcRepresentationMap>(const DB& db, const LIST& params, IfcRepresentationMap* in)
 {
 	size_t base = 0;
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcRepresentationMap"); }    do { // convert the 'MappingOrigin' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->MappingOrigin, arg, db ); break; } 
+        try { GenericConvert( in->MappingOrigin, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcRepresentationMap to be a `IfcAxis2Placement`")); }
     } while(0);
     do { // convert the 'MappedRepresentation' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->MappedRepresentation, arg, db ); break; } 
+        try { GenericConvert( in->MappedRepresentation, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcRepresentationMap to be a `IfcRepresentation`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1004,22 +1004,22 @@ template <> size_t GenericFill<IfcRelOverridesProperties>(const DB& db, const LI
 {
 	size_t base = GenericFill(db,params,static_cast<IfcRelDefinesByProperties*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcMeasureWithUnit>(const DB& db, const LIST& params, IfcMeasureWithUnit* in)
 {
 	size_t base = 0;
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcMeasureWithUnit"); }    do { // convert the 'ValueComponent' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->ValueComponent, arg, db ); break; } 
+        try { GenericConvert( in->ValueComponent, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcMeasureWithUnit to be a `IfcValue`")); }
     } while(0);
     do { // convert the 'UnitComponent' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->UnitComponent, arg, db ); break; } 
+        try { GenericConvert( in->UnitComponent, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcMeasureWithUnit to be a `IfcUnit`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1118,16 +1118,16 @@ template <> size_t GenericFill<IfcRelAggregates>(const DB& db, const LIST& param
 {
 	size_t base = GenericFill(db,params,static_cast<IfcRelDecomposes*>(in));
 	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcRelAggregates"); }	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcFaceBasedSurfaceModel>(const DB& db, const LIST& params, IfcFaceBasedSurfaceModel* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcFaceBasedSurfaceModel"); }    do { // convert the 'FbsmFaces' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->FbsmFaces, arg, db ); break; } 
+        try { GenericConvert( in->FbsmFaces, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcFaceBasedSurfaceModel to be a `SET [1:?] OF IfcConnectedFaceSet`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1163,24 +1163,24 @@ template <> size_t GenericFill<IfcUShapeProfileDef>(const DB& db, const LIST& pa
 {
 	size_t base = GenericFill(db,params,static_cast<IfcParameterizedProfileDef*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcFaceBound>(const DB& db, const LIST& params, IfcFaceBound* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcTopologicalRepresentationItem*>(in));
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcFaceBound"); }    do { // convert the 'Bound' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcFaceBound,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Bound, arg, db ); break; } 
+        try { GenericConvert( in->Bound, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcFaceBound to be a `IfcLoop`")); }
     } while(0);
     do { // convert the 'Orientation' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcFaceBound,2>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->Orientation, arg, db ); break; } 
+        try { GenericConvert( in->Orientation, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcFaceBound to be a `BOOLEAN`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1208,22 +1208,22 @@ template <> size_t GenericFill<IfcConstructionEquipmentResource>(const DB& db, c
 {
 	size_t base = GenericFill(db,params,static_cast<IfcConstructionResource*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcComplexProperty>(const DB& db, const LIST& params, IfcComplexProperty* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcProperty*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcComplexProperty"); }    do { // convert the 'UsageName' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->UsageName, arg, db ); break; } 
+        try { GenericConvert( in->UsageName, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcComplexProperty to be a `IfcIdentifier`")); }
     } while(0);
     do { // convert the 'HasProperties' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->HasProperties, arg, db ); break; } 
+        try { GenericConvert( in->HasProperties, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcComplexProperty to be a `SET [1:?] OF IfcProperty`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1266,17 +1266,17 @@ template <> size_t GenericFill<IfcDoorStyle>(const DB& db, const LIST& params, I
 {
 	size_t base = GenericFill(db,params,static_cast<IfcTypeProduct*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcUnitAssignment>(const DB& db, const LIST& params, IfcUnitAssignment* in)
 {
 	size_t base = 0;
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcUnitAssignment"); }    do { // convert the 'Units' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Units, arg, db ); break; } 
+        try { GenericConvert( in->Units, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcUnitAssignment to be a `SET [1:?] OF IfcUnit`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1298,23 +1298,23 @@ template <> size_t GenericFill<IfcFlowSegment>(const DB& db, const LIST& params,
 {
 	size_t base = GenericFill(db,params,static_cast<IfcDistributionFlowElement*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcElementQuantity>(const DB& db, const LIST& params, IfcElementQuantity* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcPropertySetDefinition*>(in));
 	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcElementQuantity"); }    do { // convert the 'MethodOfMeasurement' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->MethodOfMeasurement, arg, db ); break; } 
+        try { GenericConvert( in->MethodOfMeasurement, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcElementQuantity to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'Quantities' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Quantities, arg, db ); break; } 
+        try { GenericConvert( in->Quantities, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcElementQuantity to be a `SET [1:?] OF IfcPhysicalQuantity`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1371,17 +1371,17 @@ template <> size_t GenericFill<IfcStructuralLoadGroup>(const DB& db, const LIST&
 {
 	size_t base = GenericFill(db,params,static_cast<IfcGroup*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcPresentationStyleAssignment>(const DB& db, const LIST& params, IfcPresentationStyleAssignment* in)
 {
 	size_t base = 0;
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcPresentationStyleAssignment"); }    do { // convert the 'Styles' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Styles, arg, db ); break; } 
+        try { GenericConvert( in->Styles, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcPresentationStyleAssignment to be a `SET [1:?] OF IfcPresentationStyleSelect`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1410,23 +1410,23 @@ template <> size_t GenericFill<IfcPort>(const DB& db, const LIST& params, IfcPor
 {
 	size_t base = GenericFill(db,params,static_cast<IfcProduct*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcSpace>(const DB& db, const LIST& params, IfcSpace* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcSpatialStructureElement*>(in));
 	if (params.GetSize() < 11) { throw STEP::TypeError("expected 11 arguments to IfcSpace"); }    do { // convert the 'InteriorOrExteriorSpace' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->InteriorOrExteriorSpace, arg, db ); break; } 
+        try { GenericConvert( in->InteriorOrExteriorSpace, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 9 to IfcSpace to be a `IfcInternalOrExternalEnum`")); }
     } while(0);
     do { // convert the 'ElevationWithFlooring' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ElevationWithFlooring, arg, db ); break; } 
+        try { GenericConvert( in->ElevationWithFlooring, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 10 to IfcSpace to be a `IfcLengthMeasure`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1476,43 +1476,43 @@ template <> size_t GenericFill<IfcElectricalElement>(const DB& db, const LIST& p
 {
 	size_t base = GenericFill(db,params,static_cast<IfcElement*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcSurfaceStyleWithTextures>(const DB& db, const LIST& params, IfcSurfaceStyleWithTextures* in)
 {
 	size_t base = 0;
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcSurfaceStyleWithTextures"); }    do { // convert the 'Textures' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Textures, arg, db ); break; } 
+        try { GenericConvert( in->Textures, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcSurfaceStyleWithTextures to be a `LIST [1:?] OF IfcSurfaceTexture`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcBoundingBox>(const DB& db, const LIST& params, IfcBoundingBox* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcBoundingBox"); }    do { // convert the 'Corner' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Corner, arg, db ); break; } 
+        try { GenericConvert( in->Corner, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcBoundingBox to be a `IfcCartesianPoint`")); }
     } while(0);
     do { // convert the 'XDim' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->XDim, arg, db ); break; } 
+        try { GenericConvert( in->XDim, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcBoundingBox to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'YDim' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->YDim, arg, db ); break; } 
+        try { GenericConvert( in->YDim, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcBoundingBox to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'ZDim' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->ZDim, arg, db ); break; } 
+        try { GenericConvert( in->ZDim, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcBoundingBox to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1527,17 +1527,17 @@ template <> size_t GenericFill<IfcMove>(const DB& db, const LIST& params, IfcMov
 {
 	size_t base = GenericFill(db,params,static_cast<IfcTask*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcCircle>(const DB& db, const LIST& params, IfcCircle* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcConic*>(in));
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcCircle"); }    do { // convert the 'Radius' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Radius, arg, db ); break; } 
+        try { GenericConvert( in->Radius, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcCircle to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1615,22 +1615,22 @@ template <> size_t GenericFill<IfcProjectionElement>(const DB& db, const LIST& p
 {
 	size_t base = GenericFill(db,params,static_cast<IfcFeatureElementAddition*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcConversionBasedUnit>(const DB& db, const LIST& params, IfcConversionBasedUnit* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcNamedUnit*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcConversionBasedUnit"); }    do { // convert the 'Name' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Name, arg, db ); break; } 
+        try { GenericConvert( in->Name, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcConversionBasedUnit to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'ConversionFactor' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->ConversionFactor, arg, db ); break; } 
+        try { GenericConvert( in->ConversionFactor, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcConversionBasedUnit to be a `IfcMeasureWithUnit`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1736,22 +1736,22 @@ template <> size_t GenericFill<IfcWorkPlan>(const DB& db, const LIST& params, If
 {
 	size_t base = GenericFill(db,params,static_cast<IfcWorkControl*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcEllipse>(const DB& db, const LIST& params, IfcEllipse* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcConic*>(in));
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcEllipse"); }    do { // convert the 'SemiAxis1' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->SemiAxis1, arg, db ); break; } 
+        try { GenericConvert( in->SemiAxis1, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcEllipse to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'SemiAxis2' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->SemiAxis2, arg, db ); break; } 
+        try { GenericConvert( in->SemiAxis2, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcEllipse to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1808,70 +1808,70 @@ template <> size_t GenericFill<IfcShapeRepresentation>(const DB& db, const LIST&
 {
 	size_t base = GenericFill(db,params,static_cast<IfcShapeModel*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcPropertySet>(const DB& db, const LIST& params, IfcPropertySet* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcPropertySetDefinition*>(in));
 	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcPropertySet"); }    do { // convert the 'HasProperties' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->HasProperties, arg, db ); break; } 
+        try { GenericConvert( in->HasProperties, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcPropertySet to be a `SET [1:?] OF IfcProperty`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcSurfaceStyleRendering>(const DB& db, const LIST& params, IfcSurfaceStyleRendering* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcSurfaceStyleShading*>(in));
 	if (params.GetSize() < 9) { throw STEP::TypeError("expected 9 arguments to IfcSurfaceStyleRendering"); }    do { // convert the 'Transparency' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Transparency, arg, db ); break; } 
+        try { GenericConvert( in->Transparency, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcSurfaceStyleRendering to be a `IfcNormalisedRatioMeasure`")); }
     } while(0);
     do { // convert the 'DiffuseColour' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->DiffuseColour, arg, db ); break; } 
+        try { GenericConvert( in->DiffuseColour, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcSurfaceStyleRendering to be a `IfcColourOrFactor`")); }
     } while(0);
     do { // convert the 'TransmissionColour' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->TransmissionColour, arg, db ); break; } 
+        try { GenericConvert( in->TransmissionColour, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcSurfaceStyleRendering to be a `IfcColourOrFactor`")); }
     } while(0);
     do { // convert the 'DiffuseTransmissionColour' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->DiffuseTransmissionColour, arg, db ); break; } 
+        try { GenericConvert( in->DiffuseTransmissionColour, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcSurfaceStyleRendering to be a `IfcColourOrFactor`")); }
     } while(0);
     do { // convert the 'ReflectionColour' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ReflectionColour, arg, db ); break; } 
+        try { GenericConvert( in->ReflectionColour, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcSurfaceStyleRendering to be a `IfcColourOrFactor`")); }
     } while(0);
     do { // convert the 'SpecularColour' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->SpecularColour, arg, db ); break; } 
+        try { GenericConvert( in->SpecularColour, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to IfcSurfaceStyleRendering to be a `IfcColourOrFactor`")); }
     } while(0);
     do { // convert the 'SpecularHighlight' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->SpecularHighlight, arg, db ); break; } 
+        try { GenericConvert( in->SpecularHighlight, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to IfcSurfaceStyleRendering to be a `IfcSpecularHighlightSelect`")); }
     } while(0);
     do { // convert the 'ReflectanceMethod' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->ReflectanceMethod, arg, db ); break; } 
+        try { GenericConvert( in->ReflectanceMethod, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to IfcSurfaceStyleRendering to be a `IfcReflectanceMethodEnum`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
diff --git a/code/AssetLib/IFC/IFCReaderGen_4.cpp b/code/AssetLib/IFC/IFCReaderGen_4.cpp
index 9eb3e2446..179322902 100644
--- a/code/AssetLib/IFC/IFCReaderGen_4.cpp
+++ b/code/AssetLib/IFC/IFCReaderGen_4.cpp
@@ -5,8 +5,8 @@ Open Asset Import Library (ASSIMP)
 Copyright (c) 2006-2020, ASSIMP Development Team
 All rights reserved.
 
-Redistribution and use of this software in source and binary forms, 
-with or without modification, are permitted provided that the 
+Redistribution and use of this software in source and binary forms,
+with or without modification, are permitted provided that the
 following conditions are met:
 
 * Redistributions of source code must retain the above
@@ -23,16 +23,16 @@ following conditions are met:
   derived from this software without specific prior
   written permission of the ASSIMP Development Team.
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 ----------------------------------------------------------------------
@@ -1250,34 +1250,34 @@ template <> size_t GenericFill<NotImplemented>(const STEP::DB& db, const LIST& p
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcRoot>(const DB& db, const LIST& params, IfcRoot* in)
 {
 	size_t base = 0;
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcRoot"); }    do { // convert the 'GlobalId' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRoot,4>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->GlobalId, arg, db ); break; } 
+        try { GenericConvert( in->GlobalId, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcRoot to be a `IfcGloballyUniqueId`")); }
     } while(0);
     do { // convert the 'OwnerHistory' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRoot,4>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->OwnerHistory, arg, db ); break; } 
+        try { GenericConvert( in->OwnerHistory, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcRoot to be a `IfcOwnerHistory`")); }
     } while(0);
     do { // convert the 'Name' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRoot,4>::aux_is_derived[2]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Name, arg, db ); break; } 
+        try { GenericConvert( in->Name, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcRoot to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'Description' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRoot,4>::aux_is_derived[3]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Description, arg, db ); break; } 
+        try { GenericConvert( in->Description, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcRoot to be a `IfcText`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1285,18 +1285,18 @@ template <> size_t GenericFill<IfcObjectDefinition>(const DB& db, const LIST& pa
 {
 	size_t base = GenericFill(db,params,static_cast<IfcRoot*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcObjectDefinition"); }	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcObject>(const DB& db, const LIST& params, IfcObject* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcObjectDefinition*>(in));
 	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcObject"); }    do { // convert the 'ObjectType' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcObject,1>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ObjectType, arg, db ); break; } 
+        try { GenericConvert( in->ObjectType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcObject to be a `IfcLabel`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1318,39 +1318,39 @@ template <> size_t GenericFill<IfcActor>(const DB& db, const LIST& params, IfcAc
 {
 	size_t base = GenericFill(db,params,static_cast<IfcObject*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcProduct>(const DB& db, const LIST& params, IfcProduct* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcObject*>(in));
 	if (params.GetSize() < 7) { throw STEP::TypeError("expected 7 arguments to IfcProduct"); }    do { // convert the 'ObjectPlacement' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcProduct,2>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ObjectPlacement, arg, db ); break; } 
+        try { GenericConvert( in->ObjectPlacement, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcProduct to be a `IfcObjectPlacement`")); }
     } while(0);
     do { // convert the 'Representation' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcProduct,2>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Representation, arg, db ); break; } 
+        try { GenericConvert( in->Representation, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to IfcProduct to be a `IfcProductRepresentation`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcElement>(const DB& db, const LIST& params, IfcElement* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcProduct*>(in));
 	if (params.GetSize() < 8) { throw STEP::TypeError("expected 8 arguments to IfcElement"); }    do { // convert the 'Tag' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcElement,1>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Tag, arg, db ); break; } 
+        try { GenericConvert( in->Tag, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to IfcElement to be a `IfcIdentifier`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1433,17 +1433,17 @@ template <> size_t GenericFill<IfcSolidModel>(const DB& db, const LIST& params,
 {
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcManifoldSolidBrep>(const DB& db, const LIST& params, IfcManifoldSolidBrep* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcSolidModel*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcManifoldSolidBrep"); }    do { // convert the 'Outer' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcManifoldSolidBrep,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Outer, arg, db ); break; } 
+        try { GenericConvert( in->Outer, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcManifoldSolidBrep to be a `IfcClosedShell`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1465,17 +1465,17 @@ template <> size_t GenericFill<IfcTopologicalRepresentationItem>(const DB& db, c
 {
 	size_t base = GenericFill(db,params,static_cast<IfcRepresentationItem*>(in));
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcFace>(const DB& db, const LIST& params, IfcFace* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcTopologicalRepresentationItem*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcFace"); }    do { // convert the 'Bounds' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcFace,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Bounds, arg, db ); break; } 
+        try { GenericConvert( in->Bounds, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcFace to be a `SET [1:?] OF IfcFaceBound`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1615,60 +1615,60 @@ template <> size_t GenericFill<IfcAnnotationFillArea>(const DB& db, const LIST&
 {
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcProfileDef>(const DB& db, const LIST& params, IfcProfileDef* in)
 {
 	size_t base = 0;
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcProfileDef"); }    do { // convert the 'ProfileType' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcProfileDef,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->ProfileType, arg, db ); break; } 
+        try { GenericConvert( in->ProfileType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcProfileDef to be a `IfcProfileTypeEnum`")); }
     } while(0);
     do { // convert the 'ProfileName' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcProfileDef,2>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ProfileName, arg, db ); break; } 
+        try { GenericConvert( in->ProfileName, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcProfileDef to be a `IfcLabel`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcArbitraryClosedProfileDef>(const DB& db, const LIST& params, IfcArbitraryClosedProfileDef* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcProfileDef*>(in));
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcArbitraryClosedProfileDef"); }    do { // convert the 'OuterCurve' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcArbitraryClosedProfileDef,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->OuterCurve, arg, db ); break; } 
+        try { GenericConvert( in->OuterCurve, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcArbitraryClosedProfileDef to be a `IfcCurve`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcArbitraryOpenProfileDef>(const DB& db, const LIST& params, IfcArbitraryOpenProfileDef* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcProfileDef*>(in));
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcArbitraryOpenProfileDef"); }    do { // convert the 'Curve' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcArbitraryOpenProfileDef,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Curve, arg, db ); break; } 
+        try { GenericConvert( in->Curve, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcArbitraryOpenProfileDef to be a `IfcBoundedCurve`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcArbitraryProfileDefWithVoids>(const DB& db, const LIST& params, IfcArbitraryProfileDefWithVoids* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcArbitraryClosedProfileDef*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcArbitraryProfileDefWithVoids"); }    do { // convert the 'InnerCurves' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->InnerCurves, arg, db ); break; } 
+        try { GenericConvert( in->InnerCurves, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcArbitraryProfileDefWithVoids to be a `SET [1:?] OF IfcCurve`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1683,19 +1683,19 @@ template <> size_t GenericFill<IfcAsset>(const DB& db, const LIST& params, IfcAs
 {
 	size_t base = GenericFill(db,params,static_cast<IfcGroup*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcParameterizedProfileDef>(const DB& db, const LIST& params, IfcParameterizedProfileDef* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcProfileDef*>(in));
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcParameterizedProfileDef"); }    do { // convert the 'Position' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcParameterizedProfileDef,1>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Position, arg, db ); break; } 
+        try { GenericConvert( in->Position, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcParameterizedProfileDef to be a `IfcAxis2Placement2D`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1717,60 +1717,60 @@ template <> size_t GenericFill<IfcAudioVisualApplianceType>(const DB& db, const
 {
 	size_t base = GenericFill(db,params,static_cast<IfcFlowTerminalType*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcPlacement>(const DB& db, const LIST& params, IfcPlacement* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcPlacement"); }    do { // convert the 'Location' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcPlacement,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Location, arg, db ); break; } 
+        try { GenericConvert( in->Location, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcPlacement to be a `IfcCartesianPoint`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcAxis1Placement>(const DB& db, const LIST& params, IfcAxis1Placement* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcPlacement*>(in));
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcAxis1Placement"); }    do { // convert the 'Axis' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Axis, arg, db ); break; } 
+        try { GenericConvert( in->Axis, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcAxis1Placement to be a `IfcDirection`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcAxis2Placement2D>(const DB& db, const LIST& params, IfcAxis2Placement2D* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcPlacement*>(in));
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcAxis2Placement2D"); }    do { // convert the 'RefDirection' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->RefDirection, arg, db ); break; } 
+        try { GenericConvert( in->RefDirection, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcAxis2Placement2D to be a `IfcDirection`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcAxis2Placement3D>(const DB& db, const LIST& params, IfcAxis2Placement3D* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcPlacement*>(in));
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcAxis2Placement3D"); }    do { // convert the 'Axis' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Axis, arg, db ); break; } 
+        try { GenericConvert( in->Axis, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcAxis2Placement3D to be a `IfcDirection`")); }
     } while(0);
     do { // convert the 'RefDirection' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->RefDirection, arg, db ); break; } 
+        try { GenericConvert( in->RefDirection, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcAxis2Placement3D to be a `IfcDirection`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1784,41 +1784,41 @@ template <> size_t GenericFill<IfcBoundedCurve>(const DB& db, const LIST& params
 {
 	size_t base = GenericFill(db,params,static_cast<IfcCurve*>(in));
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcBSplineCurve>(const DB& db, const LIST& params, IfcBSplineCurve* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcBoundedCurve*>(in));
 	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcBSplineCurve"); }    do { // convert the 'Degree' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcBSplineCurve,5>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Degree, arg, db ); break; } 
+        try { GenericConvert( in->Degree, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcBSplineCurve to be a `IfcInteger`")); }
     } while(0);
     do { // convert the 'ControlPointsList' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcBSplineCurve,5>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->ControlPointsList, arg, db ); break; } 
+        try { GenericConvert( in->ControlPointsList, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcBSplineCurve to be a `LIST [2:?] OF IfcCartesianPoint`")); }
     } while(0);
     do { // convert the 'CurveForm' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcBSplineCurve,5>::aux_is_derived[2]=true; break; }
-        try { GenericConvert( in->CurveForm, arg, db ); break; } 
+        try { GenericConvert( in->CurveForm, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcBSplineCurve to be a `IfcBSplineCurveForm`")); }
     } while(0);
     do { // convert the 'ClosedCurve' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcBSplineCurve,5>::aux_is_derived[3]=true; break; }
-        try { GenericConvert( in->ClosedCurve, arg, db ); break; } 
+        try { GenericConvert( in->ClosedCurve, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcBSplineCurve to be a `IfcLogical`")); }
     } while(0);
     do { // convert the 'SelfIntersect' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcBSplineCurve,5>::aux_is_derived[4]=true; break; }
-        try { GenericConvert( in->SelfIntersect, arg, db ); break; } 
+        try { GenericConvert( in->SelfIntersect, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcBSplineCurve to be a `IfcLogical`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1921,30 +1921,30 @@ template <> size_t GenericFill<IfcBoilerType>(const DB& db, const LIST& params,
 {
 	size_t base = GenericFill(db,params,static_cast<IfcEnergyConversionDeviceType*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcBooleanResult>(const DB& db, const LIST& params, IfcBooleanResult* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcBooleanResult"); }    do { // convert the 'Operator' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcBooleanResult,3>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Operator, arg, db ); break; } 
+        try { GenericConvert( in->Operator, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcBooleanResult to be a `IfcBooleanOperator`")); }
     } while(0);
     do { // convert the 'FirstOperand' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcBooleanResult,3>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->FirstOperand, arg, db ); break; } 
+        try { GenericConvert( in->FirstOperand, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcBooleanResult to be a `IfcBooleanOperand`")); }
     } while(0);
     do { // convert the 'SecondOperand' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcBooleanResult,3>::aux_is_derived[2]=true; break; }
-        try { GenericConvert( in->SecondOperand, arg, db ); break; } 
+        try { GenericConvert( in->SecondOperand, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcBooleanResult to be a `IfcBooleanOperand`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1952,23 +1952,23 @@ template <> size_t GenericFill<IfcBooleanClippingResult>(const DB& db, const LIS
 {
 	size_t base = GenericFill(db,params,static_cast<IfcBooleanResult*>(in));
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcBooleanClippingResult"); }	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcCompositeCurve>(const DB& db, const LIST& params, IfcCompositeCurve* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcBoundedCurve*>(in));
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcCompositeCurve"); }    do { // convert the 'Segments' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcCompositeCurve,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Segments, arg, db ); break; } 
+        try { GenericConvert( in->Segments, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcCompositeCurve to be a `LIST [1:?] OF IfcCompositeCurveSegment`")); }
     } while(0);
     do { // convert the 'SelfIntersect' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcCompositeCurve,2>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->SelfIntersect, arg, db ); break; } 
+        try { GenericConvert( in->SelfIntersect, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcCompositeCurve to be a `IfcLogical`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -1983,50 +1983,50 @@ template <> size_t GenericFill<IfcBoundaryCurve>(const DB& db, const LIST& param
 {
 	size_t base = GenericFill(db,params,static_cast<IfcCompositeCurveOnSurface*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcBoundingBox>(const DB& db, const LIST& params, IfcBoundingBox* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcBoundingBox"); }    do { // convert the 'Corner' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Corner, arg, db ); break; } 
+        try { GenericConvert( in->Corner, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcBoundingBox to be a `IfcCartesianPoint`")); }
     } while(0);
     do { // convert the 'XDim' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->XDim, arg, db ); break; } 
+        try { GenericConvert( in->XDim, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcBoundingBox to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'YDim' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->YDim, arg, db ); break; } 
+        try { GenericConvert( in->YDim, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcBoundingBox to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'ZDim' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->ZDim, arg, db ); break; } 
+        try { GenericConvert( in->ZDim, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcBoundingBox to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcHalfSpaceSolid>(const DB& db, const LIST& params, IfcHalfSpaceSolid* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcHalfSpaceSolid"); }    do { // convert the 'BaseSurface' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcHalfSpaceSolid,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->BaseSurface, arg, db ); break; } 
+        try { GenericConvert( in->BaseSurface, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcHalfSpaceSolid to be a `IfcSurface`")); }
     } while(0);
     do { // convert the 'AgreementFlag' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcHalfSpaceSolid,2>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->AgreementFlag, arg, db ); break; } 
+        try { GenericConvert( in->AgreementFlag, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcHalfSpaceSolid to be a `IfcBoolean`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -2034,56 +2034,56 @@ template <> size_t GenericFill<IfcBoxedHalfSpace>(const DB& db, const LIST& para
 {
 	size_t base = GenericFill(db,params,static_cast<IfcHalfSpaceSolid*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcSpatialElement>(const DB& db, const LIST& params, IfcSpatialElement* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcProduct*>(in));
 	if (params.GetSize() < 8) { throw STEP::TypeError("expected 8 arguments to IfcSpatialElement"); }    do { // convert the 'LongName' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcSpatialElement,1>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->LongName, arg, db ); break; } 
+        try { GenericConvert( in->LongName, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to IfcSpatialElement to be a `IfcLabel`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcSpatialStructureElement>(const DB& db, const LIST& params, IfcSpatialStructureElement* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcSpatialElement*>(in));
 	if (params.GetSize() < 9) { throw STEP::TypeError("expected 9 arguments to IfcSpatialStructureElement"); }    do { // convert the 'CompositionType' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcSpatialStructureElement,1>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->CompositionType, arg, db ); break; } 
+        try { GenericConvert( in->CompositionType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to IfcSpatialStructureElement to be a `IfcElementCompositionEnum`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcBuilding>(const DB& db, const LIST& params, IfcBuilding* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcSpatialStructureElement*>(in));
 	if (params.GetSize() < 12) { throw STEP::TypeError("expected 12 arguments to IfcBuilding"); }    do { // convert the 'ElevationOfRefHeight' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ElevationOfRefHeight, arg, db ); break; } 
+        try { GenericConvert( in->ElevationOfRefHeight, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 9 to IfcBuilding to be a `IfcLengthMeasure`")); }
     } while(0);
     do { // convert the 'ElevationOfTerrain' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ElevationOfTerrain, arg, db ); break; } 
+        try { GenericConvert( in->ElevationOfTerrain, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 10 to IfcBuilding to be a `IfcLengthMeasure`")); }
     } while(0);
     do { // convert the 'BuildingAddress' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->BuildingAddress, arg, db ); break; } 
+        try { GenericConvert( in->BuildingAddress, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 11 to IfcBuilding to be a `IfcPostalAddress`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -2259,16 +2259,16 @@ template <> size_t GenericFill<IfcPoint>(const DB& db, const LIST& params, IfcPo
 {
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcCartesianPoint>(const DB& db, const LIST& params, IfcCartesianPoint* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcPoint*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcCartesianPoint"); }    do { // convert the 'Coordinates' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Coordinates, arg, db ); break; } 
+        try { GenericConvert( in->Coordinates, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcCartesianPoint to be a `LIST [1:3] OF IfcLengthMeasure`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -2290,39 +2290,39 @@ template <> size_t GenericFill<IfcCartesianPointList3D>(const DB& db, const LIST
 {
 	size_t base = GenericFill(db,params,static_cast<IfcCartesianPointList*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcCartesianTransformationOperator>(const DB& db, const LIST& params, IfcCartesianTransformationOperator* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcCartesianTransformationOperator"); }    do { // convert the 'Axis1' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcCartesianTransformationOperator,4>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Axis1, arg, db ); break; } 
+        try { GenericConvert( in->Axis1, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcCartesianTransformationOperator to be a `IfcDirection`")); }
     } while(0);
     do { // convert the 'Axis2' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcCartesianTransformationOperator,4>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Axis2, arg, db ); break; } 
+        try { GenericConvert( in->Axis2, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcCartesianTransformationOperator to be a `IfcDirection`")); }
     } while(0);
     do { // convert the 'LocalOrigin' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcCartesianTransformationOperator,4>::aux_is_derived[2]=true; break; }
-        try { GenericConvert( in->LocalOrigin, arg, db ); break; } 
+        try { GenericConvert( in->LocalOrigin, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcCartesianTransformationOperator to be a `IfcCartesianPoint`")); }
     } while(0);
     do { // convert the 'Scale' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcCartesianTransformationOperator,4>::aux_is_derived[3]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Scale, arg, db ); break; } 
+        try { GenericConvert( in->Scale, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcCartesianTransformationOperator to be a `IfcReal`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -2337,37 +2337,37 @@ template <> size_t GenericFill<IfcCartesianTransformationOperator2DnonUniform>(c
 {
 	size_t base = GenericFill(db,params,static_cast<IfcCartesianTransformationOperator2D*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcCartesianTransformationOperator3D>(const DB& db, const LIST& params, IfcCartesianTransformationOperator3D* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcCartesianTransformationOperator*>(in));
 	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcCartesianTransformationOperator3D"); }    do { // convert the 'Axis3' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcCartesianTransformationOperator3D,1>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Axis3, arg, db ); break; } 
+        try { GenericConvert( in->Axis3, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcCartesianTransformationOperator3D to be a `IfcDirection`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcCartesianTransformationOperator3DnonUniform>(const DB& db, const LIST& params, IfcCartesianTransformationOperator3DnonUniform* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcCartesianTransformationOperator3D*>(in));
 	if (params.GetSize() < 7) { throw STEP::TypeError("expected 7 arguments to IfcCartesianTransformationOperator3DnonUniform"); }    do { // convert the 'Scale2' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Scale2, arg, db ); break; } 
+        try { GenericConvert( in->Scale2, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcCartesianTransformationOperator3DnonUniform to be a `IfcReal`")); }
     } while(0);
     do { // convert the 'Scale3' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Scale3, arg, db ); break; } 
+        try { GenericConvert( in->Scale3, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to IfcCartesianTransformationOperator3DnonUniform to be a `IfcReal`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -2403,52 +2403,52 @@ template <> size_t GenericFill<IfcChimneyType>(const DB& db, const LIST& params,
 {
 	size_t base = GenericFill(db,params,static_cast<IfcBuildingElementType*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcConic>(const DB& db, const LIST& params, IfcConic* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcCurve*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcConic"); }    do { // convert the 'Position' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcConic,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Position, arg, db ); break; } 
+        try { GenericConvert( in->Position, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcConic to be a `IfcAxis2Placement`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcCircle>(const DB& db, const LIST& params, IfcCircle* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcConic*>(in));
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcCircle"); }    do { // convert the 'Radius' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Radius, arg, db ); break; } 
+        try { GenericConvert( in->Radius, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcCircle to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcCircleProfileDef>(const DB& db, const LIST& params, IfcCircleProfileDef* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcParameterizedProfileDef*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcCircleProfileDef"); }    do { // convert the 'Radius' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcCircleProfileDef,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Radius, arg, db ); break; } 
+        try { GenericConvert( in->Radius, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcCircleProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcCircleHollowProfileDef>(const DB& db, const LIST& params, IfcCircleHollowProfileDef* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcCircleProfileDef*>(in));
 	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcCircleHollowProfileDef"); }    do { // convert the 'WallThickness' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->WallThickness, arg, db ); break; } 
+        try { GenericConvert( in->WallThickness, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcCircleHollowProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -2463,18 +2463,18 @@ template <> size_t GenericFill<IfcCivilElementType>(const DB& db, const LIST& pa
 {
 	size_t base = GenericFill(db,params,static_cast<IfcElementType*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcConnectedFaceSet>(const DB& db, const LIST& params, IfcConnectedFaceSet* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcTopologicalRepresentationItem*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcConnectedFaceSet"); }    do { // convert the 'CfsFaces' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcConnectedFaceSet,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->CfsFaces, arg, db ); break; } 
+        try { GenericConvert( in->CfsFaces, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcConnectedFaceSet to be a `SET [1:?] OF IfcFace`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -2495,40 +2495,40 @@ template <> size_t GenericFill<IfcCoilType>(const DB& db, const LIST& params, If
 {
 	size_t base = GenericFill(db,params,static_cast<IfcEnergyConversionDeviceType*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcColourSpecification>(const DB& db, const LIST& params, IfcColourSpecification* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcPresentationItem*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcColourSpecification"); }    do { // convert the 'Name' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcColourSpecification,1>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Name, arg, db ); break; } 
+        try { GenericConvert( in->Name, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcColourSpecification to be a `IfcLabel`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcColourRgb>(const DB& db, const LIST& params, IfcColourRgb* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcColourSpecification*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcColourRgb"); }    do { // convert the 'Red' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Red, arg, db ); break; } 
+        try { GenericConvert( in->Red, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcColourRgb to be a `IfcNormalisedRatioMeasure`")); }
     } while(0);
     do { // convert the 'Green' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Green, arg, db ); break; } 
+        try { GenericConvert( in->Green, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcColourRgb to be a `IfcNormalisedRatioMeasure`")); }
     } while(0);
     do { // convert the 'Blue' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Blue, arg, db ); break; } 
+        try { GenericConvert( in->Blue, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcColourRgb to be a `IfcNormalisedRatioMeasure`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -2571,40 +2571,40 @@ template <> size_t GenericFill<IfcPropertyAbstraction>(const DB& db, const LIST&
 {
 	size_t base = 0;
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcProperty>(const DB& db, const LIST& params, IfcProperty* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcPropertyAbstraction*>(in));
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcProperty"); }    do { // convert the 'Name' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcProperty,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Name, arg, db ); break; } 
+        try { GenericConvert( in->Name, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcProperty to be a `IfcIdentifier`")); }
     } while(0);
     do { // convert the 'Description' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcProperty,2>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Description, arg, db ); break; } 
+        try { GenericConvert( in->Description, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcProperty to be a `IfcText`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcComplexProperty>(const DB& db, const LIST& params, IfcComplexProperty* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcProperty*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcComplexProperty"); }    do { // convert the 'UsageName' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->UsageName, arg, db ); break; } 
+        try { GenericConvert( in->UsageName, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcComplexProperty to be a `IfcIdentifier`")); }
     } while(0);
     do { // convert the 'HasProperties' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->HasProperties, arg, db ); break; } 
+        try { GenericConvert( in->HasProperties, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcComplexProperty to be a `SET [1:?] OF IfcProperty`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -2612,29 +2612,29 @@ template <> size_t GenericFill<IfcPropertyDefinition>(const DB& db, const LIST&
 {
 	size_t base = GenericFill(db,params,static_cast<IfcRoot*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcPropertyDefinition"); }	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcCompositeCurveSegment>(const DB& db, const LIST& params, IfcCompositeCurveSegment* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcCompositeCurveSegment"); }    do { // convert the 'Transition' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcCompositeCurveSegment,3>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Transition, arg, db ); break; } 
+        try { GenericConvert( in->Transition, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcCompositeCurveSegment to be a `IfcTransitionCode`")); }
     } while(0);
     do { // convert the 'SameSense' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcCompositeCurveSegment,3>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->SameSense, arg, db ); break; } 
+        try { GenericConvert( in->SameSense, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcCompositeCurveSegment to be a `IfcBoolean`")); }
     } while(0);
     do { // convert the 'ParentCurve' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcCompositeCurveSegment,3>::aux_is_derived[2]=true; break; }
-        try { GenericConvert( in->ParentCurve, arg, db ); break; } 
+        try { GenericConvert( in->ParentCurve, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcCompositeCurveSegment to be a `IfcCurve`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -2754,65 +2754,65 @@ template <> size_t GenericFill<IfcConstructionProductResourceType>(const DB& db,
 {
 	size_t base = GenericFill(db,params,static_cast<IfcConstructionResourceType*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcContext>(const DB& db, const LIST& params, IfcContext* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcObjectDefinition*>(in));
 	if (params.GetSize() < 9) { throw STEP::TypeError("expected 9 arguments to IfcContext"); }    do { // convert the 'ObjectType' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcContext,5>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ObjectType, arg, db ); break; } 
+        try { GenericConvert( in->ObjectType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcContext to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'LongName' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcContext,5>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->LongName, arg, db ); break; } 
+        try { GenericConvert( in->LongName, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcContext to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'Phase' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcContext,5>::aux_is_derived[2]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Phase, arg, db ); break; } 
+        try { GenericConvert( in->Phase, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to IfcContext to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'RepresentationContexts' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcContext,5>::aux_is_derived[3]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->RepresentationContexts, arg, db ); break; } 
+        try { GenericConvert( in->RepresentationContexts, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to IfcContext to be a `SET [1:?] OF IfcRepresentationContext`")); }
     } while(0);
     do { // convert the 'UnitsInContext' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcContext,5>::aux_is_derived[4]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->UnitsInContext, arg, db ); break; } 
+        try { GenericConvert( in->UnitsInContext, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to IfcContext to be a `IfcUnitAssignment`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcNamedUnit>(const DB& db, const LIST& params, IfcNamedUnit* in)
 {
 	size_t base = 0;
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcNamedUnit"); }    do { // convert the 'Dimensions' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcNamedUnit,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Dimensions, arg, db ); break; } 
+        try { GenericConvert( in->Dimensions, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcNamedUnit to be a `IfcDimensionalExponents`")); }
     } while(0);
     do { // convert the 'UnitType' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcNamedUnit,2>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->UnitType, arg, db ); break; } 
+        try { GenericConvert( in->UnitType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcNamedUnit to be a `IfcUnitEnum`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -2834,24 +2834,24 @@ template <> size_t GenericFill<IfcControllerType>(const DB& db, const LIST& para
 {
 	size_t base = GenericFill(db,params,static_cast<IfcDistributionControlElementType*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcConversionBasedUnit>(const DB& db, const LIST& params, IfcConversionBasedUnit* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcNamedUnit*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcConversionBasedUnit"); }    do { // convert the 'Name' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcConversionBasedUnit,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Name, arg, db ); break; } 
+        try { GenericConvert( in->Name, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcConversionBasedUnit to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'ConversionFactor' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcConversionBasedUnit,2>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->ConversionFactor, arg, db ); break; } 
+        try { GenericConvert( in->ConversionFactor, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcConversionBasedUnit to be a `IfcMeasureWithUnit`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -2964,31 +2964,31 @@ template <> size_t GenericFill<IfcCurveBoundedSurface>(const DB& db, const LIST&
 {
 	size_t base = GenericFill(db,params,static_cast<IfcBoundedSurface*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcPresentationStyle>(const DB& db, const LIST& params, IfcPresentationStyle* in)
 {
 	size_t base = 0;
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcPresentationStyle"); }    do { // convert the 'Name' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcPresentationStyle,1>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Name, arg, db ); break; } 
+        try { GenericConvert( in->Name, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcPresentationStyle to be a `IfcLabel`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcElementarySurface>(const DB& db, const LIST& params, IfcElementarySurface* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcSurface*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcElementarySurface"); }    do { // convert the 'Position' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcElementarySurface,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Position, arg, db ); break; } 
+        try { GenericConvert( in->Position, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcElementarySurface to be a `IfcAxis2Placement3D`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -3017,17 +3017,17 @@ template <> size_t GenericFill<IfcDerivedProfileDef>(const DB& db, const LIST& p
 {
 	size_t base = GenericFill(db,params,static_cast<IfcProfileDef*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcDirection>(const DB& db, const LIST& params, IfcDirection* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcDirection"); }    do { // convert the 'DirectionRatios' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->DirectionRatios, arg, db ); break; } 
+        try { GenericConvert( in->DirectionRatios, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcDirection to be a `LIST [2:3] OF IfcReal`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -3084,47 +3084,47 @@ template <> size_t GenericFill<IfcDistributionPort>(const DB& db, const LIST& pa
 {
 	size_t base = GenericFill(db,params,static_cast<IfcPort*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcDoor>(const DB& db, const LIST& params, IfcDoor* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcBuildingElement*>(in));
 	if (params.GetSize() < 13) { throw STEP::TypeError("expected 13 arguments to IfcDoor"); }    do { // convert the 'OverallHeight' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcDoor,5>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->OverallHeight, arg, db ); break; } 
+        try { GenericConvert( in->OverallHeight, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to IfcDoor to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'OverallWidth' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcDoor,5>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->OverallWidth, arg, db ); break; } 
+        try { GenericConvert( in->OverallWidth, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 9 to IfcDoor to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'PredefinedType' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcDoor,5>::aux_is_derived[2]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->PredefinedType, arg, db ); break; } 
+        try { GenericConvert( in->PredefinedType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 10 to IfcDoor to be a `IfcDoorTypeEnum`")); }
     } while(0);
     do { // convert the 'OperationType' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcDoor,5>::aux_is_derived[3]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->OperationType, arg, db ); break; } 
+        try { GenericConvert( in->OperationType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 11 to IfcDoor to be a `IfcDoorTypeOperationEnum`")); }
     } while(0);
     do { // convert the 'UserDefinedOperationType' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcDoor,5>::aux_is_derived[4]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->UserDefinedOperationType, arg, db ); break; } 
+        try { GenericConvert( in->UserDefinedOperationType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 12 to IfcDoor to be a `IfcLabel`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -3354,38 +3354,38 @@ template <> size_t GenericFill<IfcQuantitySet>(const DB& db, const LIST& params,
 {
 	size_t base = GenericFill(db,params,static_cast<IfcPropertySetDefinition*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcQuantitySet"); }	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcElementQuantity>(const DB& db, const LIST& params, IfcElementQuantity* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcQuantitySet*>(in));
 	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcElementQuantity"); }    do { // convert the 'MethodOfMeasurement' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->MethodOfMeasurement, arg, db ); break; } 
+        try { GenericConvert( in->MethodOfMeasurement, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcElementQuantity to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'Quantities' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Quantities, arg, db ); break; } 
+        try { GenericConvert( in->Quantities, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcElementQuantity to be a `SET [1:?] OF IfcPhysicalQuantity`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcEllipse>(const DB& db, const LIST& params, IfcEllipse* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcConic*>(in));
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcEllipse"); }    do { // convert the 'SemiAxis1' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->SemiAxis1, arg, db ); break; } 
+        try { GenericConvert( in->SemiAxis1, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcEllipse to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'SemiAxis2' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->SemiAxis2, arg, db ); break; } 
+        try { GenericConvert( in->SemiAxis2, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcEllipse to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -3477,43 +3477,43 @@ template <> size_t GenericFill<IfcExternalSpatialElement>(const DB& db, const LI
 {
 	size_t base = GenericFill(db,params,static_cast<IfcExternalSpatialStructureElement*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcSweptAreaSolid>(const DB& db, const LIST& params, IfcSweptAreaSolid* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcSolidModel*>(in));
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcSweptAreaSolid"); }    do { // convert the 'SweptArea' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcSweptAreaSolid,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->SweptArea, arg, db ); break; } 
+        try { GenericConvert( in->SweptArea, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcSweptAreaSolid to be a `IfcProfileDef`")); }
     } while(0);
     do { // convert the 'Position' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcSweptAreaSolid,2>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Position, arg, db ); break; } 
+        try { GenericConvert( in->Position, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcSweptAreaSolid to be a `IfcAxis2Placement3D`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcExtrudedAreaSolid>(const DB& db, const LIST& params, IfcExtrudedAreaSolid* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcSweptAreaSolid*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcExtrudedAreaSolid"); }    do { // convert the 'ExtrudedDirection' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcExtrudedAreaSolid,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->ExtrudedDirection, arg, db ); break; } 
+        try { GenericConvert( in->ExtrudedDirection, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcExtrudedAreaSolid to be a `IfcDirection`")); }
     } while(0);
     do { // convert the 'Depth' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcExtrudedAreaSolid,2>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->Depth, arg, db ); break; } 
+        try { GenericConvert( in->Depth, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcExtrudedAreaSolid to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -3521,35 +3521,35 @@ template <> size_t GenericFill<IfcExtrudedAreaSolidTapered>(const DB& db, const
 {
 	size_t base = GenericFill(db,params,static_cast<IfcExtrudedAreaSolid*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcFaceBasedSurfaceModel>(const DB& db, const LIST& params, IfcFaceBasedSurfaceModel* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcFaceBasedSurfaceModel"); }    do { // convert the 'FbsmFaces' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->FbsmFaces, arg, db ); break; } 
+        try { GenericConvert( in->FbsmFaces, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcFaceBasedSurfaceModel to be a `SET [1:?] OF IfcConnectedFaceSet`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcFaceBound>(const DB& db, const LIST& params, IfcFaceBound* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcTopologicalRepresentationItem*>(in));
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcFaceBound"); }    do { // convert the 'Bound' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcFaceBound,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Bound, arg, db ); break; } 
+        try { GenericConvert( in->Bound, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcFaceBound to be a `IfcLoop`")); }
     } while(0);
     do { // convert the 'Orientation' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcFaceBound,2>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->Orientation, arg, db ); break; } 
+        try { GenericConvert( in->Orientation, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcFaceBound to be a `IfcBoolean`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -3764,58 +3764,58 @@ template <> size_t GenericFill<IfcGeometricCurveSet>(const DB& db, const LIST& p
 {
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricSet*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcRepresentationContext>(const DB& db, const LIST& params, IfcRepresentationContext* in)
 {
 	size_t base = 0;
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcRepresentationContext"); }    do { // convert the 'ContextIdentifier' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRepresentationContext,2>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ContextIdentifier, arg, db ); break; } 
+        try { GenericConvert( in->ContextIdentifier, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcRepresentationContext to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'ContextType' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRepresentationContext,2>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ContextType, arg, db ); break; } 
+        try { GenericConvert( in->ContextType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcRepresentationContext to be a `IfcLabel`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcGeometricRepresentationContext>(const DB& db, const LIST& params, IfcGeometricRepresentationContext* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcRepresentationContext*>(in));
 	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcGeometricRepresentationContext"); }    do { // convert the 'CoordinateSpaceDimension' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcGeometricRepresentationContext,4>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->CoordinateSpaceDimension, arg, db ); break; } 
+        try { GenericConvert( in->CoordinateSpaceDimension, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcGeometricRepresentationContext to be a `IfcDimensionCount`")); }
     } while(0);
     do { // convert the 'Precision' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcGeometricRepresentationContext,4>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Precision, arg, db ); break; } 
+        try { GenericConvert( in->Precision, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcGeometricRepresentationContext to be a `IfcReal`")); }
     } while(0);
     do { // convert the 'WorldCoordinateSystem' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcGeometricRepresentationContext,4>::aux_is_derived[2]=true; break; }
-        try { GenericConvert( in->WorldCoordinateSystem, arg, db ); break; } 
+        try { GenericConvert( in->WorldCoordinateSystem, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcGeometricRepresentationContext to be a `IfcAxis2Placement`")); }
     } while(0);
     do { // convert the 'TrueNorth' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcGeometricRepresentationContext,4>::aux_is_derived[3]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->TrueNorth, arg, db ); break; } 
+        try { GenericConvert( in->TrueNorth, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcGeometricRepresentationContext to be a `IfcDirection`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -3871,50 +3871,50 @@ template <> size_t GenericFill<IfcHumidifierType>(const DB& db, const LIST& para
 {
 	size_t base = GenericFill(db,params,static_cast<IfcEnergyConversionDeviceType*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcIShapeProfileDef>(const DB& db, const LIST& params, IfcIShapeProfileDef* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcParameterizedProfileDef*>(in));
 	if (params.GetSize() < 10) { throw STEP::TypeError("expected 10 arguments to IfcIShapeProfileDef"); }    do { // convert the 'OverallWidth' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->OverallWidth, arg, db ); break; } 
+        try { GenericConvert( in->OverallWidth, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcIShapeProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'OverallDepth' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->OverallDepth, arg, db ); break; } 
+        try { GenericConvert( in->OverallDepth, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcIShapeProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'WebThickness' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->WebThickness, arg, db ); break; } 
+        try { GenericConvert( in->WebThickness, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcIShapeProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'FlangeThickness' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->FlangeThickness, arg, db ); break; } 
+        try { GenericConvert( in->FlangeThickness, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to IfcIShapeProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'FilletRadius' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->FilletRadius, arg, db ); break; } 
+        try { GenericConvert( in->FilletRadius, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to IfcIShapeProfileDef to be a `IfcNonNegativeLengthMeasure`")); }
     } while(0);
     do { // convert the 'FlangeEdgeRadius' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->FlangeEdgeRadius, arg, db ); break; } 
+        try { GenericConvert( in->FlangeEdgeRadius, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to IfcIShapeProfileDef to be a `IfcNonNegativeLengthMeasure`")); }
     } while(0);
     do { // convert the 'FlangeSlope' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->FlangeSlope, arg, db ); break; } 
+        try { GenericConvert( in->FlangeSlope, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 9 to IfcIShapeProfileDef to be a `IfcPlaneAngleMeasure`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -4083,81 +4083,81 @@ template <> size_t GenericFill<IfcLightSourceSpot>(const DB& db, const LIST& par
 {
 	size_t base = GenericFill(db,params,static_cast<IfcLightSourcePositional*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcLine>(const DB& db, const LIST& params, IfcLine* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcCurve*>(in));
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcLine"); }    do { // convert the 'Pnt' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Pnt, arg, db ); break; } 
+        try { GenericConvert( in->Pnt, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcLine to be a `IfcCartesianPoint`")); }
     } while(0);
     do { // convert the 'Dir' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Dir, arg, db ); break; } 
+        try { GenericConvert( in->Dir, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcLine to be a `IfcVector`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcLocalPlacement>(const DB& db, const LIST& params, IfcLocalPlacement* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcObjectPlacement*>(in));
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcLocalPlacement"); }    do { // convert the 'PlacementRelTo' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->PlacementRelTo, arg, db ); break; } 
+        try { GenericConvert( in->PlacementRelTo, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcLocalPlacement to be a `IfcObjectPlacement`")); }
     } while(0);
     do { // convert the 'RelativePlacement' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelativePlacement, arg, db ); break; } 
+        try { GenericConvert( in->RelativePlacement, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcLocalPlacement to be a `IfcAxis2Placement`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcMappedItem>(const DB& db, const LIST& params, IfcMappedItem* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcRepresentationItem*>(in));
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcMappedItem"); }    do { // convert the 'MappingSource' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->MappingSource, arg, db ); break; } 
+        try { GenericConvert( in->MappingSource, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcMappedItem to be a `IfcRepresentationMap`")); }
     } while(0);
     do { // convert the 'MappingTarget' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->MappingTarget, arg, db ); break; } 
+        try { GenericConvert( in->MappingTarget, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcMappedItem to be a `IfcCartesianTransformationOperator`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcProductRepresentation>(const DB& db, const LIST& params, IfcProductRepresentation* in)
 {
 	size_t base = 0;
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcProductRepresentation"); }    do { // convert the 'Name' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcProductRepresentation,3>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Name, arg, db ); break; } 
+        try { GenericConvert( in->Name, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcProductRepresentation to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'Description' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcProductRepresentation,3>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Description, arg, db ); break; } 
+        try { GenericConvert( in->Description, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcProductRepresentation to be a `IfcText`")); }
     } while(0);
     do { // convert the 'Representations' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcProductRepresentation,3>::aux_is_derived[2]=true; break; }
-        try { GenericConvert( in->Representations, arg, db ); break; } 
+        try { GenericConvert( in->Representations, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcProductRepresentation to be a `LIST [1:?] OF IfcRepresentation`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -4165,22 +4165,22 @@ template <> size_t GenericFill<IfcMaterialDefinitionRepresentation>(const DB& db
 {
 	size_t base = GenericFill(db,params,static_cast<IfcProductRepresentation*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcMeasureWithUnit>(const DB& db, const LIST& params, IfcMeasureWithUnit* in)
 {
 	size_t base = 0;
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcMeasureWithUnit"); }    do { // convert the 'ValueComponent' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->ValueComponent, arg, db ); break; } 
+        try { GenericConvert( in->ValueComponent, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcMeasureWithUnit to be a `IfcValue`")); }
     } while(0);
     do { // convert the 'UnitComponent' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->UnitComponent, arg, db ); break; } 
+        try { GenericConvert( in->UnitComponent, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcMeasureWithUnit to be a `IfcUnit`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -4279,19 +4279,19 @@ template <> size_t GenericFill<IfcOpenShell>(const DB& db, const LIST& params, I
 {
 	size_t base = GenericFill(db,params,static_cast<IfcConnectedFaceSet*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcOpeningElement>(const DB& db, const LIST& params, IfcOpeningElement* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcFeatureElementSubtraction*>(in));
 	if (params.GetSize() < 9) { throw STEP::TypeError("expected 9 arguments to IfcOpeningElement"); }    do { // convert the 'PredefinedType' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcOpeningElement,1>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->PredefinedType, arg, db ); break; } 
+        try { GenericConvert( in->PredefinedType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to IfcOpeningElement to be a `IfcOpeningElementTypeEnum`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -4452,33 +4452,33 @@ template <> size_t GenericFill<IfcPointOnSurface>(const DB& db, const LIST& para
 {
 	size_t base = GenericFill(db,params,static_cast<IfcPoint*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcPolyLoop>(const DB& db, const LIST& params, IfcPolyLoop* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcLoop*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcPolyLoop"); }    do { // convert the 'Polygon' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Polygon, arg, db ); break; } 
+        try { GenericConvert( in->Polygon, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcPolyLoop to be a `LIST [3:?] OF IfcCartesianPoint`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcPolygonalBoundedHalfSpace>(const DB& db, const LIST& params, IfcPolygonalBoundedHalfSpace* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcHalfSpaceSolid*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcPolygonalBoundedHalfSpace"); }    do { // convert the 'Position' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Position, arg, db ); break; } 
+        try { GenericConvert( in->Position, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcPolygonalBoundedHalfSpace to be a `IfcAxis2Placement3D`")); }
     } while(0);
     do { // convert the 'PolygonalBoundary' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->PolygonalBoundary, arg, db ); break; } 
+        try { GenericConvert( in->PolygonalBoundary, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcPolygonalBoundedHalfSpace to be a `IfcBoundedCurve`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -4493,28 +4493,28 @@ template <> size_t GenericFill<IfcPolygonalFaceSet>(const DB& db, const LIST& pa
 {
 	size_t base = GenericFill(db,params,static_cast<IfcTessellatedFaceSet*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcPolyline>(const DB& db, const LIST& params, IfcPolyline* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcBoundedCurve*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcPolyline"); }    do { // convert the 'Points' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Points, arg, db ); break; } 
+        try { GenericConvert( in->Points, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcPolyline to be a `LIST [2:?] OF IfcCartesianPoint`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcPresentationStyleAssignment>(const DB& db, const LIST& params, IfcPresentationStyleAssignment* in)
 {
 	size_t base = 0;
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcPresentationStyleAssignment"); }    do { // convert the 'Styles' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Styles, arg, db ); break; } 
+        try { GenericConvert( in->Styles, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcPresentationStyleAssignment to be a `SET [1:?] OF IfcPresentationStyleSelect`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -4583,24 +4583,24 @@ template <> size_t GenericFill<IfcPropertyEnumeratedValue>(const DB& db, const L
 {
 	size_t base = GenericFill(db,params,static_cast<IfcSimpleProperty*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcPropertyListValue>(const DB& db, const LIST& params, IfcPropertyListValue* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcSimpleProperty*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcPropertyListValue"); }    do { // convert the 'ListValues' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ListValues, arg, db ); break; } 
+        try { GenericConvert( in->ListValues, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcPropertyListValue to be a `LIST [1:?] OF IfcValue`")); }
     } while(0);
     do { // convert the 'Unit' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Unit, arg, db ); break; } 
+        try { GenericConvert( in->Unit, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcPropertyListValue to be a `IfcUnit`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -4608,35 +4608,35 @@ template <> size_t GenericFill<IfcPropertyReferenceValue>(const DB& db, const LI
 {
 	size_t base = GenericFill(db,params,static_cast<IfcSimpleProperty*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcPropertySet>(const DB& db, const LIST& params, IfcPropertySet* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcPropertySetDefinition*>(in));
 	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcPropertySet"); }    do { // convert the 'HasProperties' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->HasProperties, arg, db ); break; } 
+        try { GenericConvert( in->HasProperties, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcPropertySet to be a `SET [1:?] OF IfcProperty`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcPropertySingleValue>(const DB& db, const LIST& params, IfcPropertySingleValue* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcSimpleProperty*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcPropertySingleValue"); }    do { // convert the 'NominalValue' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->NominalValue, arg, db ); break; } 
+        try { GenericConvert( in->NominalValue, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcPropertySingleValue to be a `IfcValue`")); }
     } while(0);
     do { // convert the 'Unit' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Unit, arg, db ); break; } 
+        try { GenericConvert( in->Unit, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcPropertySingleValue to be a `IfcUnit`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -4749,24 +4749,24 @@ template <> size_t GenericFill<IfcRationalBSplineSurfaceWithKnots>(const DB& db,
 {
 	size_t base = GenericFill(db,params,static_cast<IfcBSplineSurfaceWithKnots*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcRectangleProfileDef>(const DB& db, const LIST& params, IfcRectangleProfileDef* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcParameterizedProfileDef*>(in));
 	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcRectangleProfileDef"); }    do { // convert the 'XDim' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRectangleProfileDef,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->XDim, arg, db ); break; } 
+        try { GenericConvert( in->XDim, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcRectangleProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'YDim' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRectangleProfileDef,2>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->YDim, arg, db ); break; } 
+        try { GenericConvert( in->YDim, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcRectangleProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -4843,21 +4843,21 @@ template <> size_t GenericFill<IfcRelDecomposes>(const DB& db, const LIST& param
 {
 	size_t base = GenericFill(db,params,static_cast<IfcRelationship*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcRelDecomposes"); }	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcRelAggregates>(const DB& db, const LIST& params, IfcRelAggregates* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcRelDecomposes*>(in));
 	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcRelAggregates"); }    do { // convert the 'RelatingObject' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelatingObject, arg, db ); break; } 
+        try { GenericConvert( in->RelatingObject, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcRelAggregates to be a `IfcObjectDefinition`")); }
     } while(0);
     do { // convert the 'RelatedObjects' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelatedObjects, arg, db ); break; } 
+        try { GenericConvert( in->RelatedObjects, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcRelAggregates to be a `SET [1:?] OF IfcObjectDefinition`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -4865,21 +4865,21 @@ template <> size_t GenericFill<IfcRelConnects>(const DB& db, const LIST& params,
 {
 	size_t base = GenericFill(db,params,static_cast<IfcRelationship*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcRelConnects"); }	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcRelContainedInSpatialStructure>(const DB& db, const LIST& params, IfcRelContainedInSpatialStructure* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcRelConnects*>(in));
 	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcRelContainedInSpatialStructure"); }    do { // convert the 'RelatedElements' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelatedElements, arg, db ); break; } 
+        try { GenericConvert( in->RelatedElements, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcRelContainedInSpatialStructure to be a `SET [1:?] OF IfcProduct`")); }
     } while(0);
     do { // convert the 'RelatingStructure' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelatingStructure, arg, db ); break; } 
+        try { GenericConvert( in->RelatingStructure, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcRelContainedInSpatialStructure to be a `IfcSpatialElement`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -4887,53 +4887,53 @@ template <> size_t GenericFill<IfcRelDefines>(const DB& db, const LIST& params,
 {
 	size_t base = GenericFill(db,params,static_cast<IfcRelationship*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcRelDefines"); }	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcRelDefinesByProperties>(const DB& db, const LIST& params, IfcRelDefinesByProperties* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcRelDefines*>(in));
 	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcRelDefinesByProperties"); }    do { // convert the 'RelatedObjects' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelatedObjects, arg, db ); break; } 
+        try { GenericConvert( in->RelatedObjects, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcRelDefinesByProperties to be a `SET [1:?] OF IfcObjectDefinition`")); }
     } while(0);
     do { // convert the 'RelatingPropertyDefinition' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelatingPropertyDefinition, arg, db ); break; } 
+        try { GenericConvert( in->RelatingPropertyDefinition, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcRelDefinesByProperties to be a `IfcPropertySetDefinitionSelect`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcRelFillsElement>(const DB& db, const LIST& params, IfcRelFillsElement* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcRelConnects*>(in));
 	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcRelFillsElement"); }    do { // convert the 'RelatingOpeningElement' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelatingOpeningElement, arg, db ); break; } 
+        try { GenericConvert( in->RelatingOpeningElement, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcRelFillsElement to be a `IfcOpeningElement`")); }
     } while(0);
     do { // convert the 'RelatedBuildingElement' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelatedBuildingElement, arg, db ); break; } 
+        try { GenericConvert( in->RelatedBuildingElement, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcRelFillsElement to be a `IfcElement`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcRelVoidsElement>(const DB& db, const LIST& params, IfcRelVoidsElement* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcRelDecomposes*>(in));
 	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcRelVoidsElement"); }    do { // convert the 'RelatingBuildingElement' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelatingBuildingElement, arg, db ); break; } 
+        try { GenericConvert( in->RelatingBuildingElement, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcRelVoidsElement to be a `IfcElement`")); }
     } while(0);
     do { // convert the 'RelatedOpeningElement' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelatedOpeningElement, arg, db ); break; } 
+        try { GenericConvert( in->RelatedOpeningElement, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcRelVoidsElement to be a `IfcFeatureElementSubtraction`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -4941,72 +4941,72 @@ template <> size_t GenericFill<IfcReparametrisedCompositeCurveSegment>(const DB&
 {
 	size_t base = GenericFill(db,params,static_cast<IfcCompositeCurveSegment*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcRepresentation>(const DB& db, const LIST& params, IfcRepresentation* in)
 {
 	size_t base = 0;
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcRepresentation"); }    do { // convert the 'ContextOfItems' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRepresentation,4>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->ContextOfItems, arg, db ); break; } 
+        try { GenericConvert( in->ContextOfItems, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcRepresentation to be a `IfcRepresentationContext`")); }
     } while(0);
     do { // convert the 'RepresentationIdentifier' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRepresentation,4>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->RepresentationIdentifier, arg, db ); break; } 
+        try { GenericConvert( in->RepresentationIdentifier, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcRepresentation to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'RepresentationType' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRepresentation,4>::aux_is_derived[2]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->RepresentationType, arg, db ); break; } 
+        try { GenericConvert( in->RepresentationType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcRepresentation to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'Items' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRepresentation,4>::aux_is_derived[3]=true; break; }
-        try { GenericConvert( in->Items, arg, db ); break; } 
+        try { GenericConvert( in->Items, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcRepresentation to be a `SET [1:?] OF IfcRepresentationItem`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcRepresentationMap>(const DB& db, const LIST& params, IfcRepresentationMap* in)
 {
 	size_t base = 0;
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcRepresentationMap"); }    do { // convert the 'MappingOrigin' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->MappingOrigin, arg, db ); break; } 
+        try { GenericConvert( in->MappingOrigin, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcRepresentationMap to be a `IfcAxis2Placement`")); }
     } while(0);
     do { // convert the 'MappedRepresentation' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->MappedRepresentation, arg, db ); break; } 
+        try { GenericConvert( in->MappedRepresentation, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcRepresentationMap to be a `IfcRepresentation`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcRevolvedAreaSolid>(const DB& db, const LIST& params, IfcRevolvedAreaSolid* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcSweptAreaSolid*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcRevolvedAreaSolid"); }    do { // convert the 'Axis' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRevolvedAreaSolid,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Axis, arg, db ); break; } 
+        try { GenericConvert( in->Axis, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcRevolvedAreaSolid to be a `IfcAxis1Placement`")); }
     } while(0);
     do { // convert the 'Angle' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRevolvedAreaSolid,2>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->Angle, arg, db ); break; } 
+        try { GenericConvert( in->Angle, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcRevolvedAreaSolid to be a `IfcPlaneAngleMeasure`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -5049,23 +5049,23 @@ template <> size_t GenericFill<IfcRoundedRectangleProfileDef>(const DB& db, cons
 {
 	size_t base = GenericFill(db,params,static_cast<IfcRectangleProfileDef*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcSIUnit>(const DB& db, const LIST& params, IfcSIUnit* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcNamedUnit*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcSIUnit"); }    do { // convert the 'Prefix' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Prefix, arg, db ); break; } 
+        try { GenericConvert( in->Prefix, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcSIUnit to be a `IfcSIPrefix`")); }
     } while(0);
     do { // convert the 'Name' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Name, arg, db ); break; } 
+        try { GenericConvert( in->Name, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcSIUnit to be a `IfcSIUnitName`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -5136,53 +5136,53 @@ template <> size_t GenericFill<IfcShapeRepresentation>(const DB& db, const LIST&
 {
 	size_t base = GenericFill(db,params,static_cast<IfcShapeModel*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcShellBasedSurfaceModel>(const DB& db, const LIST& params, IfcShellBasedSurfaceModel* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcShellBasedSurfaceModel"); }    do { // convert the 'SbsmBoundary' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->SbsmBoundary, arg, db ); break; } 
+        try { GenericConvert( in->SbsmBoundary, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcShellBasedSurfaceModel to be a `SET [1:?] OF IfcShell`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcSite>(const DB& db, const LIST& params, IfcSite* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcSpatialStructureElement*>(in));
 	if (params.GetSize() < 14) { throw STEP::TypeError("expected 14 arguments to IfcSite"); }    do { // convert the 'RefLatitude' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->RefLatitude, arg, db ); break; } 
+        try { GenericConvert( in->RefLatitude, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 9 to IfcSite to be a `IfcCompoundPlaneAngleMeasure`")); }
     } while(0);
     do { // convert the 'RefLongitude' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->RefLongitude, arg, db ); break; } 
+        try { GenericConvert( in->RefLongitude, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 10 to IfcSite to be a `IfcCompoundPlaneAngleMeasure`")); }
     } while(0);
     do { // convert the 'RefElevation' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->RefElevation, arg, db ); break; } 
+        try { GenericConvert( in->RefElevation, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 11 to IfcSite to be a `IfcLengthMeasure`")); }
     } while(0);
     do { // convert the 'LandTitleNumber' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->LandTitleNumber, arg, db ); break; } 
+        try { GenericConvert( in->LandTitleNumber, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 12 to IfcSite to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'SiteAddress' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->SiteAddress, arg, db ); break; } 
+        try { GenericConvert( in->SiteAddress, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 13 to IfcSite to be a `IfcPostalAddress`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -5225,24 +5225,24 @@ template <> size_t GenericFill<IfcSolarDeviceType>(const DB& db, const LIST& par
 {
 	size_t base = GenericFill(db,params,static_cast<IfcEnergyConversionDeviceType*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcSpace>(const DB& db, const LIST& params, IfcSpace* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcSpatialStructureElement*>(in));
 	if (params.GetSize() < 11) { throw STEP::TypeError("expected 11 arguments to IfcSpace"); }    do { // convert the 'PredefinedType' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->PredefinedType, arg, db ); break; } 
+        try { GenericConvert( in->PredefinedType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 9 to IfcSpace to be a `IfcSpaceTypeEnum`")); }
     } while(0);
     do { // convert the 'ElevationWithFlooring' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ElevationWithFlooring, arg, db ); break; } 
+        try { GenericConvert( in->ElevationWithFlooring, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 10 to IfcSpace to be a `IfcLengthMeasure`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -5530,29 +5530,29 @@ template <> size_t GenericFill<IfcStyleModel>(const DB& db, const LIST& params,
 {
 	size_t base = GenericFill(db,params,static_cast<IfcRepresentation*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcStyledItem>(const DB& db, const LIST& params, IfcStyledItem* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcRepresentationItem*>(in));
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcStyledItem"); }    do { // convert the 'Item' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Item, arg, db ); break; } 
+        try { GenericConvert( in->Item, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcStyledItem to be a `IfcRepresentationItem`")); }
     } while(0);
     do { // convert the 'Styles' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Styles, arg, db ); break; } 
+        try { GenericConvert( in->Styles, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcStyledItem to be a `SET [1:?] OF IfcStyleAssignmentSelect`")); }
     } while(0);
     do { // convert the 'Name' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Name, arg, db ); break; } 
+        try { GenericConvert( in->Name, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcStyledItem to be a `IfcLabel`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -5616,138 +5616,138 @@ template <> size_t GenericFill<IfcSurfaceOfRevolution>(const DB& db, const LIST&
 {
 	size_t base = GenericFill(db,params,static_cast<IfcSweptSurface*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcSurfaceStyle>(const DB& db, const LIST& params, IfcSurfaceStyle* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcPresentationStyle*>(in));
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcSurfaceStyle"); }    do { // convert the 'Side' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Side, arg, db ); break; } 
+        try { GenericConvert( in->Side, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcSurfaceStyle to be a `IfcSurfaceSide`")); }
     } while(0);
     do { // convert the 'Styles' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Styles, arg, db ); break; } 
+        try { GenericConvert( in->Styles, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcSurfaceStyle to be a `SET [1:5] OF IfcSurfaceStyleElementSelect`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcSurfaceStyleShading>(const DB& db, const LIST& params, IfcSurfaceStyleShading* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcPresentationItem*>(in));
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcSurfaceStyleShading"); }    do { // convert the 'SurfaceColour' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcSurfaceStyleShading,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->SurfaceColour, arg, db ); break; } 
+        try { GenericConvert( in->SurfaceColour, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcSurfaceStyleShading to be a `IfcColourRgb`")); }
     } while(0);
     do { // convert the 'Transparency' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcSurfaceStyleShading,2>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Transparency, arg, db ); break; } 
+        try { GenericConvert( in->Transparency, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcSurfaceStyleShading to be a `IfcNormalisedRatioMeasure`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcSurfaceStyleRendering>(const DB& db, const LIST& params, IfcSurfaceStyleRendering* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcSurfaceStyleShading*>(in));
 	if (params.GetSize() < 9) { throw STEP::TypeError("expected 9 arguments to IfcSurfaceStyleRendering"); }    do { // convert the 'DiffuseColour' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->DiffuseColour, arg, db ); break; } 
+        try { GenericConvert( in->DiffuseColour, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcSurfaceStyleRendering to be a `IfcColourOrFactor`")); }
     } while(0);
     do { // convert the 'TransmissionColour' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->TransmissionColour, arg, db ); break; } 
+        try { GenericConvert( in->TransmissionColour, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcSurfaceStyleRendering to be a `IfcColourOrFactor`")); }
     } while(0);
     do { // convert the 'DiffuseTransmissionColour' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->DiffuseTransmissionColour, arg, db ); break; } 
+        try { GenericConvert( in->DiffuseTransmissionColour, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcSurfaceStyleRendering to be a `IfcColourOrFactor`")); }
     } while(0);
     do { // convert the 'ReflectionColour' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ReflectionColour, arg, db ); break; } 
+        try { GenericConvert( in->ReflectionColour, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcSurfaceStyleRendering to be a `IfcColourOrFactor`")); }
     } while(0);
     do { // convert the 'SpecularColour' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->SpecularColour, arg, db ); break; } 
+        try { GenericConvert( in->SpecularColour, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to IfcSurfaceStyleRendering to be a `IfcColourOrFactor`")); }
     } while(0);
     do { // convert the 'SpecularHighlight' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->SpecularHighlight, arg, db ); break; } 
+        try { GenericConvert( in->SpecularHighlight, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to IfcSurfaceStyleRendering to be a `IfcSpecularHighlightSelect`")); }
     } while(0);
     do { // convert the 'ReflectanceMethod' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->ReflectanceMethod, arg, db ); break; } 
+        try { GenericConvert( in->ReflectanceMethod, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to IfcSurfaceStyleRendering to be a `IfcReflectanceMethodEnum`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcSurfaceStyleWithTextures>(const DB& db, const LIST& params, IfcSurfaceStyleWithTextures* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcPresentationItem*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcSurfaceStyleWithTextures"); }    do { // convert the 'Textures' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Textures, arg, db ); break; } 
+        try { GenericConvert( in->Textures, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcSurfaceStyleWithTextures to be a `LIST [1:?] OF IfcSurfaceTexture`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcSweptDiskSolid>(const DB& db, const LIST& params, IfcSweptDiskSolid* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcSolidModel*>(in));
 	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcSweptDiskSolid"); }    do { // convert the 'Directrix' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcSweptDiskSolid,5>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Directrix, arg, db ); break; } 
+        try { GenericConvert( in->Directrix, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcSweptDiskSolid to be a `IfcCurve`")); }
     } while(0);
     do { // convert the 'Radius' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcSweptDiskSolid,5>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->Radius, arg, db ); break; } 
+        try { GenericConvert( in->Radius, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcSweptDiskSolid to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'InnerRadius' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcSweptDiskSolid,5>::aux_is_derived[2]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->InnerRadius, arg, db ); break; } 
+        try { GenericConvert( in->InnerRadius, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcSweptDiskSolid to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'StartParam' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcSweptDiskSolid,5>::aux_is_derived[3]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->StartParam, arg, db ); break; } 
+        try { GenericConvert( in->StartParam, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcSweptDiskSolid to be a `IfcParameterValue`")); }
     } while(0);
     do { // convert the 'EndParam' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcSweptDiskSolid,5>::aux_is_derived[4]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->EndParam, arg, db ); break; } 
+        try { GenericConvert( in->EndParam, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcSweptDiskSolid to be a `IfcParameterValue`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -5916,37 +5916,37 @@ template <> size_t GenericFill<IfcTriangulatedFaceSet>(const DB& db, const LIST&
 {
 	size_t base = GenericFill(db,params,static_cast<IfcTessellatedFaceSet*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcTrimmedCurve>(const DB& db, const LIST& params, IfcTrimmedCurve* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcBoundedCurve*>(in));
 	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcTrimmedCurve"); }    do { // convert the 'BasisCurve' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->BasisCurve, arg, db ); break; } 
+        try { GenericConvert( in->BasisCurve, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcTrimmedCurve to be a `IfcCurve`")); }
     } while(0);
     do { // convert the 'Trim1' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Trim1, arg, db ); break; } 
+        try { GenericConvert( in->Trim1, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcTrimmedCurve to be a `SET [1:2] OF IfcTrimmingSelect`")); }
     } while(0);
     do { // convert the 'Trim2' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Trim2, arg, db ); break; } 
+        try { GenericConvert( in->Trim2, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcTrimmedCurve to be a `SET [1:2] OF IfcTrimmingSelect`")); }
     } while(0);
     do { // convert the 'SenseAgreement' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->SenseAgreement, arg, db ); break; } 
+        try { GenericConvert( in->SenseAgreement, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcTrimmedCurve to be a `IfcBoolean`")); }
     } while(0);
     do { // convert the 'MasterRepresentation' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->MasterRepresentation, arg, db ); break; } 
+        try { GenericConvert( in->MasterRepresentation, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcTrimmedCurve to be a `IfcTrimmingPreference`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -5968,17 +5968,17 @@ template <> size_t GenericFill<IfcUShapeProfileDef>(const DB& db, const LIST& pa
 {
 	size_t base = GenericFill(db,params,static_cast<IfcParameterizedProfileDef*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcUnitAssignment>(const DB& db, const LIST& params, IfcUnitAssignment* in)
 {
 	size_t base = 0;
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcUnitAssignment"); }    do { // convert the 'Units' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Units, arg, db ); break; } 
+        try { GenericConvert( in->Units, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcUnitAssignment to be a `SET [1:?] OF IfcUnit`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
@@ -6021,22 +6021,22 @@ template <> size_t GenericFill<IfcValveType>(const DB& db, const LIST& params, I
 {
 	size_t base = GenericFill(db,params,static_cast<IfcFlowControllerType*>(in));
 // this data structure is not used yet, so there is no code generated to fill its members
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
 template <> size_t GenericFill<IfcVector>(const DB& db, const LIST& params, IfcVector* in)
 {
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcVector"); }    do { // convert the 'Orientation' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Orientation, arg, db ); break; } 
+        try { GenericConvert( in->Orientation, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcVector to be a `IfcDirection`")); }
     } while(0);
     do { // convert the 'Magnitude' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Magnitude, arg, db ); break; } 
+        try { GenericConvert( in->Magnitude, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcVector to be a `IfcLengthMeasure`")); }
     } while(0);
 	return base;
 }
 // -----------------------------------------------------------------------------------------------------------
diff --git a/code/AssetLib/IFC/IFCReaderGen_4.h b/code/AssetLib/IFC/IFCReaderGen_4.h
index 0f184cd02..abf021911 100644
--- a/code/AssetLib/IFC/IFCReaderGen_4.h
+++ b/code/AssetLib/IFC/IFCReaderGen_4.h
@@ -5,8 +5,8 @@ Open Asset Import Library (ASSIMP)
 Copyright (c) 2006-2020, ASSIMP Development Team
 All rights reserved.
 
-Redistribution and use of this software in source and binary forms, 
-with or without modification, are permitted provided that the 
+Redistribution and use of this software in source and binary forms,
+with or without modification, are permitted provided that the
 following conditions are met:
 
 * Redistributions of source code must retain the above
@@ -23,16 +23,16 @@ following conditions are met:
   derived from this software without specific prior
   written permission of the ASSIMP Development Team.
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 ----------------------------------------------------------------------
@@ -50,4819 +50,4819 @@ namespace IFC {
 namespace Schema_4 {
 
 	using namespace STEP;
 	using namespace STEP::EXPRESS;
-	
-	
+
+
 	struct NotImplemented : public ObjectHelper<NotImplemented,0> {
-		
+
 	};
-	
+
 
 	// ******************************************************************************
 	// IFC Custom data types
 	// ******************************************************************************
 
 
     // C++ wrapper type for IfcStrippedOptional
     typedef BOOLEAN IfcStrippedOptional;
     // C++ wrapper type for IfcAbsorbedDoseMeasure
     typedef REAL IfcAbsorbedDoseMeasure;
     // C++ wrapper type for IfcAccelerationMeasure
     typedef REAL IfcAccelerationMeasure;
     // C++ wrapper type for IfcAmountOfSubstanceMeasure
     typedef REAL IfcAmountOfSubstanceMeasure;
     // C++ wrapper type for IfcAngularVelocityMeasure
     typedef REAL IfcAngularVelocityMeasure;
     // C++ wrapper type for IfcArcIndex
     typedef ListOf< INTEGER, 3, 3 > IfcArcIndex;
     // C++ wrapper type for IfcAreaDensityMeasure
     typedef REAL IfcAreaDensityMeasure;
     // C++ wrapper type for IfcAreaMeasure
     typedef REAL IfcAreaMeasure;
     // C++ wrapper type for IfcBoolean
     typedef BOOLEAN IfcBoolean;
     // C++ wrapper type for IfcBoxAlignment
     typedef STRING IfcBoxAlignment;
     // C++ wrapper type for IfcCardinalPointReference
     typedef INTEGER IfcCardinalPointReference;
     // C++ wrapper type for IfcCompoundPlaneAngleMeasure
     typedef ListOf< INTEGER, 3, 4 > IfcCompoundPlaneAngleMeasure;
     // C++ wrapper type for IfcContextDependentMeasure
     typedef REAL IfcContextDependentMeasure;
     // C++ wrapper type for IfcCountMeasure
     typedef NUMBER IfcCountMeasure;
     // C++ wrapper type for IfcCurvatureMeasure
     typedef REAL IfcCurvatureMeasure;
     // C++ wrapper type for IfcDate
     typedef STRING IfcDate;
     // C++ wrapper type for IfcDateTime
     typedef STRING IfcDateTime;
     // C++ wrapper type for IfcDayInMonthNumber
     typedef INTEGER IfcDayInMonthNumber;
     // C++ wrapper type for IfcDayInWeekNumber
     typedef INTEGER IfcDayInWeekNumber;
     // C++ wrapper type for IfcDescriptiveMeasure
     typedef STRING IfcDescriptiveMeasure;
     // C++ wrapper type for IfcDimensionCount
     typedef INTEGER IfcDimensionCount;
     // C++ wrapper type for IfcDoseEquivalentMeasure
     typedef REAL IfcDoseEquivalentMeasure;
     // C++ wrapper type for IfcDuration
     typedef STRING IfcDuration;
     // C++ wrapper type for IfcDynamicViscosityMeasure
     typedef REAL IfcDynamicViscosityMeasure;
     // C++ wrapper type for IfcElectricCapacitanceMeasure
     typedef REAL IfcElectricCapacitanceMeasure;
     // C++ wrapper type for IfcElectricChargeMeasure
     typedef REAL IfcElectricChargeMeasure;
     // C++ wrapper type for IfcElectricConductanceMeasure
     typedef REAL IfcElectricConductanceMeasure;
     // C++ wrapper type for IfcElectricCurrentMeasure
     typedef REAL IfcElectricCurrentMeasure;
     // C++ wrapper type for IfcElectricResistanceMeasure
     typedef REAL IfcElectricResistanceMeasure;
     // C++ wrapper type for IfcElectricVoltageMeasure
     typedef REAL IfcElectricVoltageMeasure;
     // C++ wrapper type for IfcEnergyMeasure
     typedef REAL IfcEnergyMeasure;
     // C++ wrapper type for IfcFontStyle
     typedef STRING IfcFontStyle;
     // C++ wrapper type for IfcFontVariant
     typedef STRING IfcFontVariant;
     // C++ wrapper type for IfcFontWeight
     typedef STRING IfcFontWeight;
     // C++ wrapper type for IfcForceMeasure
     typedef REAL IfcForceMeasure;
     // C++ wrapper type for IfcFrequencyMeasure
     typedef REAL IfcFrequencyMeasure;
     // C++ wrapper type for IfcGloballyUniqueId
     typedef STRING IfcGloballyUniqueId;
     // C++ wrapper type for IfcHeatFluxDensityMeasure
     typedef REAL IfcHeatFluxDensityMeasure;
     // C++ wrapper type for IfcHeatingValueMeasure
     typedef REAL IfcHeatingValueMeasure;
     // C++ wrapper type for IfcIdentifier
     typedef STRING IfcIdentifier;
     // C++ wrapper type for IfcIlluminanceMeasure
     typedef REAL IfcIlluminanceMeasure;
     // C++ wrapper type for IfcInductanceMeasure
     typedef REAL IfcInductanceMeasure;
     // C++ wrapper type for IfcInteger
     typedef INTEGER IfcInteger;
     // C++ wrapper type for IfcIntegerCountRateMeasure
     typedef INTEGER IfcIntegerCountRateMeasure;
     // C++ wrapper type for IfcIonConcentrationMeasure
     typedef REAL IfcIonConcentrationMeasure;
     // C++ wrapper type for IfcIsothermalMoistureCapacityMeasure
     typedef REAL IfcIsothermalMoistureCapacityMeasure;
     // C++ wrapper type for IfcKinematicViscosityMeasure
     typedef REAL IfcKinematicViscosityMeasure;
     // C++ wrapper type for IfcLabel
     typedef STRING IfcLabel;
     // C++ wrapper type for IfcLanguageId
     typedef STRING IfcLanguageId;
     // C++ wrapper type for IfcLengthMeasure
     typedef REAL IfcLengthMeasure;
     // C++ wrapper type for IfcLineIndex
     typedef ListOf< INTEGER, 2, 0 > IfcLineIndex;
     // C++ wrapper type for IfcLinearForceMeasure
     typedef REAL IfcLinearForceMeasure;
     // C++ wrapper type for IfcLinearMomentMeasure
     typedef REAL IfcLinearMomentMeasure;
     // C++ wrapper type for IfcLinearStiffnessMeasure
     typedef REAL IfcLinearStiffnessMeasure;
     // C++ wrapper type for IfcLinearVelocityMeasure
     typedef REAL IfcLinearVelocityMeasure;
     // C++ wrapper type for IfcLogical
     typedef LOGICAL IfcLogical;
     // C++ wrapper type for IfcLuminousFluxMeasure
     typedef REAL IfcLuminousFluxMeasure;
     // C++ wrapper type for IfcLuminousIntensityDistributionMeasure
     typedef REAL IfcLuminousIntensityDistributionMeasure;
     // C++ wrapper type for IfcLuminousIntensityMeasure
     typedef REAL IfcLuminousIntensityMeasure;
     // C++ wrapper type for IfcMagneticFluxDensityMeasure
     typedef REAL IfcMagneticFluxDensityMeasure;
     // C++ wrapper type for IfcMagneticFluxMeasure
     typedef REAL IfcMagneticFluxMeasure;
     // C++ wrapper type for IfcMassDensityMeasure
     typedef REAL IfcMassDensityMeasure;
     // C++ wrapper type for IfcMassFlowRateMeasure
     typedef REAL IfcMassFlowRateMeasure;
     // C++ wrapper type for IfcMassMeasure
     typedef REAL IfcMassMeasure;
     // C++ wrapper type for IfcMassPerLengthMeasure
     typedef REAL IfcMassPerLengthMeasure;
     // C++ wrapper type for IfcModulusOfElasticityMeasure
     typedef REAL IfcModulusOfElasticityMeasure;
     // C++ wrapper type for IfcModulusOfLinearSubgradeReactionMeasure
     typedef REAL IfcModulusOfLinearSubgradeReactionMeasure;
     // C++ wrapper type for IfcModulusOfRotationalSubgradeReactionMeasure
     typedef REAL IfcModulusOfRotationalSubgradeReactionMeasure;
     // C++ wrapper type for IfcModulusOfSubgradeReactionMeasure
     typedef REAL IfcModulusOfSubgradeReactionMeasure;
     // C++ wrapper type for IfcMoistureDiffusivityMeasure
     typedef REAL IfcMoistureDiffusivityMeasure;
     // C++ wrapper type for IfcMolecularWeightMeasure
     typedef REAL IfcMolecularWeightMeasure;
     // C++ wrapper type for IfcMomentOfInertiaMeasure
     typedef REAL IfcMomentOfInertiaMeasure;
     // C++ wrapper type for IfcMonetaryMeasure
     typedef REAL IfcMonetaryMeasure;
     // C++ wrapper type for IfcMonthInYearNumber
     typedef INTEGER IfcMonthInYearNumber;
     // C++ wrapper type for IfcNonNegativeLengthMeasure
     typedef REAL IfcNonNegativeLengthMeasure;
     // C++ wrapper type for IfcNormalisedRatioMeasure
     typedef REAL IfcNormalisedRatioMeasure;
     // C++ wrapper type for IfcNumericMeasure
     typedef NUMBER IfcNumericMeasure;
     // C++ wrapper type for IfcPHMeasure
     typedef REAL IfcPHMeasure;
     // C++ wrapper type for IfcParameterValue
     typedef REAL IfcParameterValue;
     // C++ wrapper type for IfcPlanarForceMeasure
     typedef REAL IfcPlanarForceMeasure;
     // C++ wrapper type for IfcPlaneAngleMeasure
     typedef REAL IfcPlaneAngleMeasure;
     // C++ wrapper type for IfcPositiveInteger
     typedef INTEGER IfcPositiveInteger;
     // C++ wrapper type for IfcPositiveLengthMeasure
     typedef REAL IfcPositiveLengthMeasure;
     // C++ wrapper type for IfcPositivePlaneAngleMeasure
     typedef REAL IfcPositivePlaneAngleMeasure;
     // C++ wrapper type for IfcPositiveRatioMeasure
     typedef REAL IfcPositiveRatioMeasure;
     // C++ wrapper type for IfcPowerMeasure
     typedef REAL IfcPowerMeasure;
     // C++ wrapper type for IfcPresentableText
     typedef STRING IfcPresentableText;
     // C++ wrapper type for IfcPressureMeasure
     typedef REAL IfcPressureMeasure;
     // C++ wrapper type for IfcRadioActivityMeasure
     typedef REAL IfcRadioActivityMeasure;
     // C++ wrapper type for IfcRatioMeasure
     typedef REAL IfcRatioMeasure;
     // C++ wrapper type for IfcReal
     typedef REAL IfcReal;
     // C++ wrapper type for IfcRotationalFrequencyMeasure
     typedef REAL IfcRotationalFrequencyMeasure;
     // C++ wrapper type for IfcRotationalMassMeasure
     typedef REAL IfcRotationalMassMeasure;
     // C++ wrapper type for IfcRotationalStiffnessMeasure
     typedef REAL IfcRotationalStiffnessMeasure;
     // C++ wrapper type for IfcSectionModulusMeasure
     typedef REAL IfcSectionModulusMeasure;
     // C++ wrapper type for IfcSectionalAreaIntegralMeasure
     typedef REAL IfcSectionalAreaIntegralMeasure;
     // C++ wrapper type for IfcShearModulusMeasure
     typedef REAL IfcShearModulusMeasure;
     // C++ wrapper type for IfcSolidAngleMeasure
     typedef REAL IfcSolidAngleMeasure;
     // C++ wrapper type for IfcSoundPowerLevelMeasure
     typedef REAL IfcSoundPowerLevelMeasure;
     // C++ wrapper type for IfcSoundPowerMeasure
     typedef REAL IfcSoundPowerMeasure;
     // C++ wrapper type for IfcSoundPressureLevelMeasure
     typedef REAL IfcSoundPressureLevelMeasure;
     // C++ wrapper type for IfcSoundPressureMeasure
     typedef REAL IfcSoundPressureMeasure;
     // C++ wrapper type for IfcSpecificHeatCapacityMeasure
     typedef REAL IfcSpecificHeatCapacityMeasure;
     // C++ wrapper type for IfcSpecularExponent
     typedef REAL IfcSpecularExponent;
     // C++ wrapper type for IfcSpecularRoughness
     typedef REAL IfcSpecularRoughness;
     // C++ wrapper type for IfcTemperatureGradientMeasure
     typedef REAL IfcTemperatureGradientMeasure;
     // C++ wrapper type for IfcTemperatureRateOfChangeMeasure
     typedef REAL IfcTemperatureRateOfChangeMeasure;
     // C++ wrapper type for IfcText
     typedef STRING IfcText;
     // C++ wrapper type for IfcTextAlignment
     typedef STRING IfcTextAlignment;
     // C++ wrapper type for IfcTextDecoration
     typedef STRING IfcTextDecoration;
     // C++ wrapper type for IfcTextFontName
     typedef STRING IfcTextFontName;
     // C++ wrapper type for IfcTextTransformation
     typedef STRING IfcTextTransformation;
     // C++ wrapper type for IfcThermalAdmittanceMeasure
     typedef REAL IfcThermalAdmittanceMeasure;
     // C++ wrapper type for IfcThermalConductivityMeasure
     typedef REAL IfcThermalConductivityMeasure;
     // C++ wrapper type for IfcThermalExpansionCoefficientMeasure
     typedef REAL IfcThermalExpansionCoefficientMeasure;
     // C++ wrapper type for IfcThermalResistanceMeasure
     typedef REAL IfcThermalResistanceMeasure;
     // C++ wrapper type for IfcThermalTransmittanceMeasure
     typedef REAL IfcThermalTransmittanceMeasure;
     // C++ wrapper type for IfcThermodynamicTemperatureMeasure
     typedef REAL IfcThermodynamicTemperatureMeasure;
     // C++ wrapper type for IfcTime
     typedef STRING IfcTime;
     // C++ wrapper type for IfcTimeMeasure
     typedef REAL IfcTimeMeasure;
     // C++ wrapper type for IfcTimeStamp
     typedef INTEGER IfcTimeStamp;
     // C++ wrapper type for IfcTorqueMeasure
     typedef REAL IfcTorqueMeasure;
     // C++ wrapper type for IfcURIReference
     typedef STRING IfcURIReference;
     // C++ wrapper type for IfcVaporPermeabilityMeasure
     typedef REAL IfcVaporPermeabilityMeasure;
     // C++ wrapper type for IfcVolumeMeasure
     typedef REAL IfcVolumeMeasure;
     // C++ wrapper type for IfcVolumetricFlowRateMeasure
     typedef REAL IfcVolumetricFlowRateMeasure;
     // C++ wrapper type for IfcWarpingConstantMeasure
     typedef REAL IfcWarpingConstantMeasure;
     // C++ wrapper type for IfcWarpingMomentMeasure
     typedef REAL IfcWarpingMomentMeasure;
     // C++ wrapper type for IfcActionRequestTypeEnum
     typedef ENUMERATION IfcActionRequestTypeEnum;
     // C++ wrapper type for IfcActionSourceTypeEnum
     typedef ENUMERATION IfcActionSourceTypeEnum;
     // C++ wrapper type for IfcActionTypeEnum
     typedef ENUMERATION IfcActionTypeEnum;
     // C++ wrapper type for IfcActuatorTypeEnum
     typedef ENUMERATION IfcActuatorTypeEnum;
     // C++ wrapper type for IfcAddressTypeEnum
     typedef ENUMERATION IfcAddressTypeEnum;
     // C++ wrapper type for IfcAirTerminalBoxTypeEnum
     typedef ENUMERATION IfcAirTerminalBoxTypeEnum;
     // C++ wrapper type for IfcAirTerminalTypeEnum
     typedef ENUMERATION IfcAirTerminalTypeEnum;
     // C++ wrapper type for IfcAirToAirHeatRecoveryTypeEnum
     typedef ENUMERATION IfcAirToAirHeatRecoveryTypeEnum;
     // C++ wrapper type for IfcAlarmTypeEnum
     typedef ENUMERATION IfcAlarmTypeEnum;
     // C++ wrapper type for IfcAnalysisModelTypeEnum
     typedef ENUMERATION IfcAnalysisModelTypeEnum;
     // C++ wrapper type for IfcAnalysisTheoryTypeEnum
     typedef ENUMERATION IfcAnalysisTheoryTypeEnum;
     // C++ wrapper type for IfcArithmeticOperatorEnum
     typedef ENUMERATION IfcArithmeticOperatorEnum;
     // C++ wrapper type for IfcAssemblyPlaceEnum
     typedef ENUMERATION IfcAssemblyPlaceEnum;
     // C++ wrapper type for IfcAudioVisualApplianceTypeEnum
     typedef ENUMERATION IfcAudioVisualApplianceTypeEnum;
     // C++ wrapper type for IfcBSplineCurveForm
     typedef ENUMERATION IfcBSplineCurveForm;
     // C++ wrapper type for IfcBSplineSurfaceForm
     typedef ENUMERATION IfcBSplineSurfaceForm;
     // C++ wrapper type for IfcBeamTypeEnum
     typedef ENUMERATION IfcBeamTypeEnum;
     // C++ wrapper type for IfcBenchmarkEnum
     typedef ENUMERATION IfcBenchmarkEnum;
     // C++ wrapper type for IfcBoilerTypeEnum
     typedef ENUMERATION IfcBoilerTypeEnum;
     // C++ wrapper type for IfcBooleanOperator
     typedef ENUMERATION IfcBooleanOperator;
     // C++ wrapper type for IfcBuildingElementPartTypeEnum
     typedef ENUMERATION IfcBuildingElementPartTypeEnum;
     // C++ wrapper type for IfcBuildingElementProxyTypeEnum
     typedef ENUMERATION IfcBuildingElementProxyTypeEnum;
     // C++ wrapper type for IfcBuildingSystemTypeEnum
     typedef ENUMERATION IfcBuildingSystemTypeEnum;
     // C++ wrapper type for IfcBurnerTypeEnum
     typedef ENUMERATION IfcBurnerTypeEnum;
     // C++ wrapper type for IfcCableCarrierFittingTypeEnum
     typedef ENUMERATION IfcCableCarrierFittingTypeEnum;
     // C++ wrapper type for IfcCableCarrierSegmentTypeEnum
     typedef ENUMERATION IfcCableCarrierSegmentTypeEnum;
     // C++ wrapper type for IfcCableFittingTypeEnum
     typedef ENUMERATION IfcCableFittingTypeEnum;
     // C++ wrapper type for IfcCableSegmentTypeEnum
     typedef ENUMERATION IfcCableSegmentTypeEnum;
     // C++ wrapper type for IfcChangeActionEnum
     typedef ENUMERATION IfcChangeActionEnum;
     // C++ wrapper type for IfcChillerTypeEnum
     typedef ENUMERATION IfcChillerTypeEnum;
     // C++ wrapper type for IfcChimneyTypeEnum
     typedef ENUMERATION IfcChimneyTypeEnum;
     // C++ wrapper type for IfcCoilTypeEnum
     typedef ENUMERATION IfcCoilTypeEnum;
     // C++ wrapper type for IfcColumnTypeEnum
     typedef ENUMERATION IfcColumnTypeEnum;
     // C++ wrapper type for IfcCommunicationsApplianceTypeEnum
     typedef ENUMERATION IfcCommunicationsApplianceTypeEnum;
     // C++ wrapper type for IfcComplexPropertyTemplateTypeEnum
     typedef ENUMERATION IfcComplexPropertyTemplateTypeEnum;
     // C++ wrapper type for IfcCompressorTypeEnum
     typedef ENUMERATION IfcCompressorTypeEnum;
     // C++ wrapper type for IfcCondenserTypeEnum
     typedef ENUMERATION IfcCondenserTypeEnum;
     // C++ wrapper type for IfcConnectionTypeEnum
     typedef ENUMERATION IfcConnectionTypeEnum;
     // C++ wrapper type for IfcConstraintEnum
     typedef ENUMERATION IfcConstraintEnum;
     // C++ wrapper type for IfcConstructionEquipmentResourceTypeEnum
     typedef ENUMERATION IfcConstructionEquipmentResourceTypeEnum;
     // C++ wrapper type for IfcConstructionMaterialResourceTypeEnum
     typedef ENUMERATION IfcConstructionMaterialResourceTypeEnum;
     // C++ wrapper type for IfcConstructionProductResourceTypeEnum
     typedef ENUMERATION IfcConstructionProductResourceTypeEnum;
     // C++ wrapper type for IfcControllerTypeEnum
     typedef ENUMERATION IfcControllerTypeEnum;
     // C++ wrapper type for IfcCooledBeamTypeEnum
     typedef ENUMERATION IfcCooledBeamTypeEnum;
     // C++ wrapper type for IfcCoolingTowerTypeEnum
     typedef ENUMERATION IfcCoolingTowerTypeEnum;
     // C++ wrapper type for IfcCostItemTypeEnum
     typedef ENUMERATION IfcCostItemTypeEnum;
     // C++ wrapper type for IfcCostScheduleTypeEnum
     typedef ENUMERATION IfcCostScheduleTypeEnum;
     // C++ wrapper type for IfcCoveringTypeEnum
     typedef ENUMERATION IfcCoveringTypeEnum;
     // C++ wrapper type for IfcCrewResourceTypeEnum
     typedef ENUMERATION IfcCrewResourceTypeEnum;
     // C++ wrapper type for IfcCurtainWallTypeEnum
     typedef ENUMERATION IfcCurtainWallTypeEnum;
     // C++ wrapper type for IfcCurveInterpolationEnum
     typedef ENUMERATION IfcCurveInterpolationEnum;
     // C++ wrapper type for IfcDamperTypeEnum
     typedef ENUMERATION IfcDamperTypeEnum;
     // C++ wrapper type for IfcDataOriginEnum
     typedef ENUMERATION IfcDataOriginEnum;
     // C++ wrapper type for IfcDerivedUnitEnum
     typedef ENUMERATION IfcDerivedUnitEnum;
     // C++ wrapper type for IfcDirectionSenseEnum
     typedef ENUMERATION IfcDirectionSenseEnum;
     // C++ wrapper type for IfcDiscreteAccessoryTypeEnum
     typedef ENUMERATION IfcDiscreteAccessoryTypeEnum;
     // C++ wrapper type for IfcDistributionChamberElementTypeEnum
     typedef ENUMERATION IfcDistributionChamberElementTypeEnum;
     // C++ wrapper type for IfcDistributionPortTypeEnum
     typedef ENUMERATION IfcDistributionPortTypeEnum;
     // C++ wrapper type for IfcDistributionSystemEnum
     typedef ENUMERATION IfcDistributionSystemEnum;
     // C++ wrapper type for IfcDocumentConfidentialityEnum
     typedef ENUMERATION IfcDocumentConfidentialityEnum;
     // C++ wrapper type for IfcDocumentStatusEnum
     typedef ENUMERATION IfcDocumentStatusEnum;
     // C++ wrapper type for IfcDoorPanelOperationEnum
     typedef ENUMERATION IfcDoorPanelOperationEnum;
     // C++ wrapper type for IfcDoorPanelPositionEnum
     typedef ENUMERATION IfcDoorPanelPositionEnum;
     // C++ wrapper type for IfcDoorStyleConstructionEnum
     typedef ENUMERATION IfcDoorStyleConstructionEnum;
     // C++ wrapper type for IfcDoorStyleOperationEnum
     typedef ENUMERATION IfcDoorStyleOperationEnum;
     // C++ wrapper type for IfcDoorTypeEnum
     typedef ENUMERATION IfcDoorTypeEnum;
     // C++ wrapper type for IfcDoorTypeOperationEnum
     typedef ENUMERATION IfcDoorTypeOperationEnum;
     // C++ wrapper type for IfcDuctFittingTypeEnum
     typedef ENUMERATION IfcDuctFittingTypeEnum;
     // C++ wrapper type for IfcDuctSegmentTypeEnum
     typedef ENUMERATION IfcDuctSegmentTypeEnum;
     // C++ wrapper type for IfcDuctSilencerTypeEnum
     typedef ENUMERATION IfcDuctSilencerTypeEnum;
     // C++ wrapper type for IfcElectricApplianceTypeEnum
     typedef ENUMERATION IfcElectricApplianceTypeEnum;
     // C++ wrapper type for IfcElectricDistributionBoardTypeEnum
     typedef ENUMERATION IfcElectricDistributionBoardTypeEnum;
     // C++ wrapper type for IfcElectricFlowStorageDeviceTypeEnum
     typedef ENUMERATION IfcElectricFlowStorageDeviceTypeEnum;
     // C++ wrapper type for IfcElectricGeneratorTypeEnum
     typedef ENUMERATION IfcElectricGeneratorTypeEnum;
     // C++ wrapper type for IfcElectricMotorTypeEnum
     typedef ENUMERATION IfcElectricMotorTypeEnum;
     // C++ wrapper type for IfcElectricTimeControlTypeEnum
     typedef ENUMERATION IfcElectricTimeControlTypeEnum;
     // C++ wrapper type for IfcElementAssemblyTypeEnum
     typedef ENUMERATION IfcElementAssemblyTypeEnum;
     // C++ wrapper type for IfcElementCompositionEnum
     typedef ENUMERATION IfcElementCompositionEnum;
     // C++ wrapper type for IfcEngineTypeEnum
     typedef ENUMERATION IfcEngineTypeEnum;
     // C++ wrapper type for IfcEvaporativeCoolerTypeEnum
     typedef ENUMERATION IfcEvaporativeCoolerTypeEnum;
     // C++ wrapper type for IfcEvaporatorTypeEnum
     typedef ENUMERATION IfcEvaporatorTypeEnum;
     // C++ wrapper type for IfcEventTriggerTypeEnum
     typedef ENUMERATION IfcEventTriggerTypeEnum;
     // C++ wrapper type for IfcEventTypeEnum
     typedef ENUMERATION IfcEventTypeEnum;
     // C++ wrapper type for IfcExternalSpatialElementTypeEnum
     typedef ENUMERATION IfcExternalSpatialElementTypeEnum;
     // C++ wrapper type for IfcFanTypeEnum
     typedef ENUMERATION IfcFanTypeEnum;
     // C++ wrapper type for IfcFastenerTypeEnum
     typedef ENUMERATION IfcFastenerTypeEnum;
     // C++ wrapper type for IfcFilterTypeEnum
     typedef ENUMERATION IfcFilterTypeEnum;
     // C++ wrapper type for IfcFireSuppressionTerminalTypeEnum
     typedef ENUMERATION IfcFireSuppressionTerminalTypeEnum;
     // C++ wrapper type for IfcFlowDirectionEnum
     typedef ENUMERATION IfcFlowDirectionEnum;
     // C++ wrapper type for IfcFlowInstrumentTypeEnum
     typedef ENUMERATION IfcFlowInstrumentTypeEnum;
     // C++ wrapper type for IfcFlowMeterTypeEnum
     typedef ENUMERATION IfcFlowMeterTypeEnum;
     // C++ wrapper type for IfcFootingTypeEnum
     typedef ENUMERATION IfcFootingTypeEnum;
     // C++ wrapper type for IfcFurnitureTypeEnum
     typedef ENUMERATION IfcFurnitureTypeEnum;
     // C++ wrapper type for IfcGeographicElementTypeEnum
     typedef ENUMERATION IfcGeographicElementTypeEnum;
     // C++ wrapper type for IfcGeometricProjectionEnum
     typedef ENUMERATION IfcGeometricProjectionEnum;
     // C++ wrapper type for IfcGlobalOrLocalEnum
     typedef ENUMERATION IfcGlobalOrLocalEnum;
     // C++ wrapper type for IfcGridTypeEnum
     typedef ENUMERATION IfcGridTypeEnum;
     // C++ wrapper type for IfcHeatExchangerTypeEnum
     typedef ENUMERATION IfcHeatExchangerTypeEnum;
     // C++ wrapper type for IfcHumidifierTypeEnum
     typedef ENUMERATION IfcHumidifierTypeEnum;
     // C++ wrapper type for IfcInterceptorTypeEnum
     typedef ENUMERATION IfcInterceptorTypeEnum;
     // C++ wrapper type for IfcInternalOrExternalEnum
     typedef ENUMERATION IfcInternalOrExternalEnum;
     // C++ wrapper type for IfcInventoryTypeEnum
     typedef ENUMERATION IfcInventoryTypeEnum;
     // C++ wrapper type for IfcJunctionBoxTypeEnum
     typedef ENUMERATION IfcJunctionBoxTypeEnum;
     // C++ wrapper type for IfcKnotType
     typedef ENUMERATION IfcKnotType;
     // C++ wrapper type for IfcLaborResourceTypeEnum
     typedef ENUMERATION IfcLaborResourceTypeEnum;
     // C++ wrapper type for IfcLampTypeEnum
     typedef ENUMERATION IfcLampTypeEnum;
     // C++ wrapper type for IfcLayerSetDirectionEnum
     typedef ENUMERATION IfcLayerSetDirectionEnum;
     // C++ wrapper type for IfcLightDistributionCurveEnum
     typedef ENUMERATION IfcLightDistributionCurveEnum;
     // C++ wrapper type for IfcLightEmissionSourceEnum
     typedef ENUMERATION IfcLightEmissionSourceEnum;
     // C++ wrapper type for IfcLightFixtureTypeEnum
     typedef ENUMERATION IfcLightFixtureTypeEnum;
     // C++ wrapper type for IfcLoadGroupTypeEnum
     typedef ENUMERATION IfcLoadGroupTypeEnum;
     // C++ wrapper type for IfcLogicalOperatorEnum
     typedef ENUMERATION IfcLogicalOperatorEnum;
     // C++ wrapper type for IfcMechanicalFastenerTypeEnum
     typedef ENUMERATION IfcMechanicalFastenerTypeEnum;
     // C++ wrapper type for IfcMedicalDeviceTypeEnum
     typedef ENUMERATION IfcMedicalDeviceTypeEnum;
     // C++ wrapper type for IfcMemberTypeEnum
     typedef ENUMERATION IfcMemberTypeEnum;
     // C++ wrapper type for IfcMotorConnectionTypeEnum
     typedef ENUMERATION IfcMotorConnectionTypeEnum;
     // C++ wrapper type for IfcNullStyle
     typedef ENUMERATION IfcNullStyle;
     // C++ wrapper type for IfcObjectTypeEnum
     typedef ENUMERATION IfcObjectTypeEnum;
     // C++ wrapper type for IfcObjectiveEnum
     typedef ENUMERATION IfcObjectiveEnum;
     // C++ wrapper type for IfcOccupantTypeEnum
     typedef ENUMERATION IfcOccupantTypeEnum;
     // C++ wrapper type for IfcOpeningElementTypeEnum
     typedef ENUMERATION IfcOpeningElementTypeEnum;
     // C++ wrapper type for IfcOutletTypeEnum
     typedef ENUMERATION IfcOutletTypeEnum;
     // C++ wrapper type for IfcPerformanceHistoryTypeEnum
     typedef ENUMERATION IfcPerformanceHistoryTypeEnum;
     // C++ wrapper type for IfcPermeableCoveringOperationEnum
     typedef ENUMERATION IfcPermeableCoveringOperationEnum;
     // C++ wrapper type for IfcPermitTypeEnum
     typedef ENUMERATION IfcPermitTypeEnum;
     // C++ wrapper type for IfcPhysicalOrVirtualEnum
     typedef ENUMERATION IfcPhysicalOrVirtualEnum;
     // C++ wrapper type for IfcPileConstructionEnum
     typedef ENUMERATION IfcPileConstructionEnum;
     // C++ wrapper type for IfcPileTypeEnum
     typedef ENUMERATION IfcPileTypeEnum;
     // C++ wrapper type for IfcPipeFittingTypeEnum
     typedef ENUMERATION IfcPipeFittingTypeEnum;
     // C++ wrapper type for IfcPipeSegmentTypeEnum
     typedef ENUMERATION IfcPipeSegmentTypeEnum;
     // C++ wrapper type for IfcPlateTypeEnum
     typedef ENUMERATION IfcPlateTypeEnum;
     // C++ wrapper type for IfcPreferredSurfaceCurveRepresentation
     typedef ENUMERATION IfcPreferredSurfaceCurveRepresentation;
     // C++ wrapper type for IfcProcedureTypeEnum
     typedef ENUMERATION IfcProcedureTypeEnum;
     // C++ wrapper type for IfcProfileTypeEnum
     typedef ENUMERATION IfcProfileTypeEnum;
     // C++ wrapper type for IfcProjectOrderTypeEnum
     typedef ENUMERATION IfcProjectOrderTypeEnum;
     // C++ wrapper type for IfcProjectedOrTrueLengthEnum
     typedef ENUMERATION IfcProjectedOrTrueLengthEnum;
     // C++ wrapper type for IfcProjectionElementTypeEnum
     typedef ENUMERATION IfcProjectionElementTypeEnum;
     // C++ wrapper type for IfcPropertySetTemplateTypeEnum
     typedef ENUMERATION IfcPropertySetTemplateTypeEnum;
     // C++ wrapper type for IfcProtectiveDeviceTrippingUnitTypeEnum
     typedef ENUMERATION IfcProtectiveDeviceTrippingUnitTypeEnum;
     // C++ wrapper type for IfcProtectiveDeviceTypeEnum
     typedef ENUMERATION IfcProtectiveDeviceTypeEnum;
     // C++ wrapper type for IfcPumpTypeEnum
     typedef ENUMERATION IfcPumpTypeEnum;
     // C++ wrapper type for IfcRailingTypeEnum
     typedef ENUMERATION IfcRailingTypeEnum;
     // C++ wrapper type for IfcRampFlightTypeEnum
     typedef ENUMERATION IfcRampFlightTypeEnum;
     // C++ wrapper type for IfcRampTypeEnum
     typedef ENUMERATION IfcRampTypeEnum;
     // C++ wrapper type for IfcRecurrenceTypeEnum
     typedef ENUMERATION IfcRecurrenceTypeEnum;
     // C++ wrapper type for IfcReflectanceMethodEnum
     typedef ENUMERATION IfcReflectanceMethodEnum;
     // C++ wrapper type for IfcReinforcingBarRoleEnum
     typedef ENUMERATION IfcReinforcingBarRoleEnum;
     // C++ wrapper type for IfcReinforcingBarSurfaceEnum
     typedef ENUMERATION IfcReinforcingBarSurfaceEnum;
     // C++ wrapper type for IfcReinforcingBarTypeEnum
     typedef ENUMERATION IfcReinforcingBarTypeEnum;
     // C++ wrapper type for IfcReinforcingMeshTypeEnum
     typedef ENUMERATION IfcReinforcingMeshTypeEnum;
     // C++ wrapper type for IfcRoleEnum
     typedef ENUMERATION IfcRoleEnum;
     // C++ wrapper type for IfcRoofTypeEnum
     typedef ENUMERATION IfcRoofTypeEnum;
     // C++ wrapper type for IfcSIPrefix
     typedef ENUMERATION IfcSIPrefix;
     // C++ wrapper type for IfcSIUnitName
     typedef ENUMERATION IfcSIUnitName;
     // C++ wrapper type for IfcSanitaryTerminalTypeEnum
     typedef ENUMERATION IfcSanitaryTerminalTypeEnum;
     // C++ wrapper type for IfcSectionTypeEnum
     typedef ENUMERATION IfcSectionTypeEnum;
     // C++ wrapper type for IfcSensorTypeEnum
     typedef ENUMERATION IfcSensorTypeEnum;
     // C++ wrapper type for IfcSequenceEnum
     typedef ENUMERATION IfcSequenceEnum;
     // C++ wrapper type for IfcShadingDeviceTypeEnum
     typedef ENUMERATION IfcShadingDeviceTypeEnum;
     // C++ wrapper type for IfcSimplePropertyTemplateTypeEnum
     typedef ENUMERATION IfcSimplePropertyTemplateTypeEnum;
     // C++ wrapper type for IfcSlabTypeEnum
     typedef ENUMERATION IfcSlabTypeEnum;
     // C++ wrapper type for IfcSolarDeviceTypeEnum
     typedef ENUMERATION IfcSolarDeviceTypeEnum;
     // C++ wrapper type for IfcSpaceHeaterTypeEnum
     typedef ENUMERATION IfcSpaceHeaterTypeEnum;
     // C++ wrapper type for IfcSpaceTypeEnum
     typedef ENUMERATION IfcSpaceTypeEnum;
     // C++ wrapper type for IfcSpatialZoneTypeEnum
     typedef ENUMERATION IfcSpatialZoneTypeEnum;
     // C++ wrapper type for IfcStackTerminalTypeEnum
     typedef ENUMERATION IfcStackTerminalTypeEnum;
     // C++ wrapper type for IfcStairFlightTypeEnum
     typedef ENUMERATION IfcStairFlightTypeEnum;
     // C++ wrapper type for IfcStairTypeEnum
     typedef ENUMERATION IfcStairTypeEnum;
     // C++ wrapper type for IfcStateEnum
     typedef ENUMERATION IfcStateEnum;
     // C++ wrapper type for IfcStructuralCurveActivityTypeEnum
     typedef ENUMERATION IfcStructuralCurveActivityTypeEnum;
     // C++ wrapper type for IfcStructuralCurveMemberTypeEnum
     typedef ENUMERATION IfcStructuralCurveMemberTypeEnum;
     // C++ wrapper type for IfcStructuralSurfaceActivityTypeEnum
     typedef ENUMERATION IfcStructuralSurfaceActivityTypeEnum;
     // C++ wrapper type for IfcStructuralSurfaceMemberTypeEnum
     typedef ENUMERATION IfcStructuralSurfaceMemberTypeEnum;
     // C++ wrapper type for IfcSubContractResourceTypeEnum
     typedef ENUMERATION IfcSubContractResourceTypeEnum;
     // C++ wrapper type for IfcSurfaceFeatureTypeEnum
     typedef ENUMERATION IfcSurfaceFeatureTypeEnum;
     // C++ wrapper type for IfcSurfaceSide
     typedef ENUMERATION IfcSurfaceSide;
     // C++ wrapper type for IfcSwitchingDeviceTypeEnum
     typedef ENUMERATION IfcSwitchingDeviceTypeEnum;
     // C++ wrapper type for IfcSystemFurnitureElementTypeEnum
     typedef ENUMERATION IfcSystemFurnitureElementTypeEnum;
     // C++ wrapper type for IfcTankTypeEnum
     typedef ENUMERATION IfcTankTypeEnum;
     // C++ wrapper type for IfcTaskDurationEnum
     typedef ENUMERATION IfcTaskDurationEnum;
     // C++ wrapper type for IfcTaskTypeEnum
     typedef ENUMERATION IfcTaskTypeEnum;
     // C++ wrapper type for IfcTendonAnchorTypeEnum
     typedef ENUMERATION IfcTendonAnchorTypeEnum;
     // C++ wrapper type for IfcTendonTypeEnum
     typedef ENUMERATION IfcTendonTypeEnum;
     // C++ wrapper type for IfcTextPath
     typedef ENUMERATION IfcTextPath;
     // C++ wrapper type for IfcTimeSeriesDataTypeEnum
     typedef ENUMERATION IfcTimeSeriesDataTypeEnum;
     // C++ wrapper type for IfcTransformerTypeEnum
     typedef ENUMERATION IfcTransformerTypeEnum;
     // C++ wrapper type for IfcTransitionCode
     typedef ENUMERATION IfcTransitionCode;
     // C++ wrapper type for IfcTransportElementTypeEnum
     typedef ENUMERATION IfcTransportElementTypeEnum;
     // C++ wrapper type for IfcTrimmingPreference
     typedef ENUMERATION IfcTrimmingPreference;
     // C++ wrapper type for IfcTubeBundleTypeEnum
     typedef ENUMERATION IfcTubeBundleTypeEnum;
     // C++ wrapper type for IfcUnitEnum
     typedef ENUMERATION IfcUnitEnum;
     // C++ wrapper type for IfcUnitaryControlElementTypeEnum
     typedef ENUMERATION IfcUnitaryControlElementTypeEnum;
     // C++ wrapper type for IfcUnitaryEquipmentTypeEnum
     typedef ENUMERATION IfcUnitaryEquipmentTypeEnum;
     // C++ wrapper type for IfcValveTypeEnum
     typedef ENUMERATION IfcValveTypeEnum;
     // C++ wrapper type for IfcVibrationIsolatorTypeEnum
     typedef ENUMERATION IfcVibrationIsolatorTypeEnum;
     // C++ wrapper type for IfcVoidingFeatureTypeEnum
     typedef ENUMERATION IfcVoidingFeatureTypeEnum;
     // C++ wrapper type for IfcWallTypeEnum
     typedef ENUMERATION IfcWallTypeEnum;
     // C++ wrapper type for IfcWasteTerminalTypeEnum
     typedef ENUMERATION IfcWasteTerminalTypeEnum;
     // C++ wrapper type for IfcWindowPanelOperationEnum
     typedef ENUMERATION IfcWindowPanelOperationEnum;
     // C++ wrapper type for IfcWindowPanelPositionEnum
     typedef ENUMERATION IfcWindowPanelPositionEnum;
     // C++ wrapper type for IfcWindowStyleConstructionEnum
     typedef ENUMERATION IfcWindowStyleConstructionEnum;
     // C++ wrapper type for IfcWindowStyleOperationEnum
     typedef ENUMERATION IfcWindowStyleOperationEnum;
     // C++ wrapper type for IfcWindowTypeEnum
     typedef ENUMERATION IfcWindowTypeEnum;
     // C++ wrapper type for IfcWindowTypePartitioningEnum
     typedef ENUMERATION IfcWindowTypePartitioningEnum;
     // C++ wrapper type for IfcWorkCalendarTypeEnum
     typedef ENUMERATION IfcWorkCalendarTypeEnum;
     // C++ wrapper type for IfcWorkPlanTypeEnum
     typedef ENUMERATION IfcWorkPlanTypeEnum;
     // C++ wrapper type for IfcWorkScheduleTypeEnum
     typedef ENUMERATION IfcWorkScheduleTypeEnum;
     // C++ wrapper type for IfcActorSelect
     typedef SELECT IfcActorSelect;
     // C++ wrapper type for IfcAppliedValueSelect
     typedef SELECT IfcAppliedValueSelect;
     // C++ wrapper type for IfcAxis2Placement
     typedef SELECT IfcAxis2Placement;
     // C++ wrapper type for IfcBendingParameterSelect
     typedef SELECT IfcBendingParameterSelect;
     // C++ wrapper type for IfcBooleanOperand
     typedef SELECT IfcBooleanOperand;
     // C++ wrapper type for IfcClassificationReferenceSelect
     typedef SELECT IfcClassificationReferenceSelect;
     // C++ wrapper type for IfcClassificationSelect
     typedef SELECT IfcClassificationSelect;
     // C++ wrapper type for IfcColour
     typedef SELECT IfcColour;
     // C++ wrapper type for IfcColourOrFactor
     typedef SELECT IfcColourOrFactor;
     // C++ wrapper type for IfcCoordinateReferenceSystemSelect
     typedef SELECT IfcCoordinateReferenceSystemSelect;
     // C++ wrapper type for IfcCsgSelect
     typedef SELECT IfcCsgSelect;
     // C++ wrapper type for IfcCurveFontOrScaledCurveFontSelect
     typedef SELECT IfcCurveFontOrScaledCurveFontSelect;
     // C++ wrapper type for IfcCurveOnSurface
     typedef SELECT IfcCurveOnSurface;
     // C++ wrapper type for IfcCurveOrEdgeCurve
     typedef SELECT IfcCurveOrEdgeCurve;
     // C++ wrapper type for IfcCurveStyleFontSelect
     typedef SELECT IfcCurveStyleFontSelect;
     // C++ wrapper type for IfcDefinitionSelect
     typedef SELECT IfcDefinitionSelect;
     // C++ wrapper type for IfcDerivedMeasureValue
     typedef SELECT IfcDerivedMeasureValue;
     // C++ wrapper type for IfcDocumentSelect
     typedef SELECT IfcDocumentSelect;
     // C++ wrapper type for IfcFillStyleSelect
     typedef SELECT IfcFillStyleSelect;
     // C++ wrapper type for IfcGeometricSetSelect
     typedef SELECT IfcGeometricSetSelect;
     // C++ wrapper type for IfcGridPlacementDirectionSelect
     typedef SELECT IfcGridPlacementDirectionSelect;
     // C++ wrapper type for IfcHatchLineDistanceSelect
     typedef SELECT IfcHatchLineDistanceSelect;
     // C++ wrapper type for IfcLayeredItem
     typedef SELECT IfcLayeredItem;
     // C++ wrapper type for IfcLibrarySelect
     typedef SELECT IfcLibrarySelect;
     // C++ wrapper type for IfcLightDistributionDataSourceSelect
     typedef SELECT IfcLightDistributionDataSourceSelect;
     // C++ wrapper type for IfcMaterialSelect
     typedef SELECT IfcMaterialSelect;
     // C++ wrapper type for IfcMeasureValue
     typedef SELECT IfcMeasureValue;
     // C++ wrapper type for IfcMetricValueSelect
     typedef SELECT IfcMetricValueSelect;
     // C++ wrapper type for IfcModulusOfRotationalSubgradeReactionSelect
     typedef SELECT IfcModulusOfRotationalSubgradeReactionSelect;
     // C++ wrapper type for IfcModulusOfSubgradeReactionSelect
     typedef SELECT IfcModulusOfSubgradeReactionSelect;
     // C++ wrapper type for IfcModulusOfTranslationalSubgradeReactionSelect
     typedef SELECT IfcModulusOfTranslationalSubgradeReactionSelect;
     // C++ wrapper type for IfcObjectReferenceSelect
     typedef SELECT IfcObjectReferenceSelect;
     // C++ wrapper type for IfcPointOrVertexPoint
     typedef SELECT IfcPointOrVertexPoint;
     // C++ wrapper type for IfcPresentationStyleSelect
     typedef SELECT IfcPresentationStyleSelect;
     // C++ wrapper type for IfcProcessSelect
     typedef SELECT IfcProcessSelect;
     // C++ wrapper type for IfcProductRepresentationSelect
     typedef SELECT IfcProductRepresentationSelect;
     // C++ wrapper type for IfcProductSelect
     typedef SELECT IfcProductSelect;
     // C++ wrapper type for IfcPropertySetDefinitionSelect
     typedef SELECT IfcPropertySetDefinitionSelect;
     // C++ wrapper type for IfcResourceObjectSelect
     typedef SELECT IfcResourceObjectSelect;
     // C++ wrapper type for IfcResourceSelect
     typedef SELECT IfcResourceSelect;
     // C++ wrapper type for IfcRotationalStiffnessSelect
     typedef SELECT IfcRotationalStiffnessSelect;
     // C++ wrapper type for IfcSegmentIndexSelect
     typedef SELECT IfcSegmentIndexSelect;
     // C++ wrapper type for IfcShell
     typedef SELECT IfcShell;
     // C++ wrapper type for IfcSimpleValue
     typedef SELECT IfcSimpleValue;
     // C++ wrapper type for IfcSizeSelect
     typedef SELECT IfcSizeSelect;
     // C++ wrapper type for IfcSolidOrShell
     typedef SELECT IfcSolidOrShell;
     // C++ wrapper type for IfcSpaceBoundarySelect
     typedef SELECT IfcSpaceBoundarySelect;
     // C++ wrapper type for IfcSpecularHighlightSelect
     typedef SELECT IfcSpecularHighlightSelect;
     // C++ wrapper type for IfcStructuralActivityAssignmentSelect
     typedef SELECT IfcStructuralActivityAssignmentSelect;
     // C++ wrapper type for IfcStyleAssignmentSelect
     typedef SELECT IfcStyleAssignmentSelect;
     // C++ wrapper type for IfcSurfaceOrFaceSurface
     typedef SELECT IfcSurfaceOrFaceSurface;
     // C++ wrapper type for IfcSurfaceStyleElementSelect
     typedef SELECT IfcSurfaceStyleElementSelect;
     // C++ wrapper type for IfcTextFontSelect
     typedef SELECT IfcTextFontSelect;
     // C++ wrapper type for IfcTimeOrRatioSelect
     typedef SELECT IfcTimeOrRatioSelect;
     // C++ wrapper type for IfcTranslationalStiffnessSelect
     typedef SELECT IfcTranslationalStiffnessSelect;
     // C++ wrapper type for IfcTrimmingSelect
     typedef SELECT IfcTrimmingSelect;
     // C++ wrapper type for IfcUnit
     typedef SELECT IfcUnit;
     // C++ wrapper type for IfcValue
     typedef SELECT IfcValue;
     // C++ wrapper type for IfcVectorOrDirection
     typedef SELECT IfcVectorOrDirection;
     // C++ wrapper type for IfcWarpingStiffnessSelect
     typedef SELECT IfcWarpingStiffnessSelect;
 
 
 	// ******************************************************************************
 	// IFC Entities
 	// ******************************************************************************
 
 	struct IfcRoot;
 	struct IfcObjectDefinition;
 	struct IfcObject;
 	struct IfcControl;
 	struct IfcActionRequest;
 	struct IfcActor;
 	typedef NotImplemented IfcActorRole; // (not currently used by Assimp)
 	struct IfcProduct;
 	struct IfcElement;
 	struct IfcDistributionElement;
 	struct IfcDistributionControlElement;
 	struct IfcActuator;
 	struct IfcTypeObject;
 	struct IfcTypeProduct;
 	struct IfcElementType;
 	struct IfcDistributionElementType;
 	struct IfcDistributionControlElementType;
 	struct IfcActuatorType;
 	typedef NotImplemented IfcAddress; // (not currently used by Assimp)
 	struct IfcRepresentationItem;
 	struct IfcGeometricRepresentationItem;
 	struct IfcSolidModel;
 	struct IfcManifoldSolidBrep;
 	struct IfcAdvancedBrep;
 	struct IfcAdvancedBrepWithVoids;
 	struct IfcTopologicalRepresentationItem;
 	struct IfcFace;
 	struct IfcFaceSurface;
 	struct IfcAdvancedFace;
 	struct IfcDistributionFlowElement;
 	struct IfcFlowTerminal;
 	struct IfcAirTerminal;
 	struct IfcFlowController;
 	struct IfcAirTerminalBox;
 	struct IfcDistributionFlowElementType;
 	struct IfcFlowControllerType;
 	struct IfcAirTerminalBoxType;
 	struct IfcFlowTerminalType;
 	struct IfcAirTerminalType;
 	struct IfcEnergyConversionDevice;
 	struct IfcAirToAirHeatRecovery;
 	struct IfcEnergyConversionDeviceType;
 	struct IfcAirToAirHeatRecoveryType;
 	struct IfcAlarm;
 	struct IfcAlarmType;
 	struct IfcAnnotation;
 	struct IfcAnnotationFillArea;
 	typedef NotImplemented IfcApplication; // (not currently used by Assimp)
 	typedef NotImplemented IfcAppliedValue; // (not currently used by Assimp)
 	typedef NotImplemented IfcApproval; // (not currently used by Assimp)
 	typedef NotImplemented IfcResourceLevelRelationship; // (not currently used by Assimp)
 	typedef NotImplemented IfcApprovalRelationship; // (not currently used by Assimp)
 	struct IfcProfileDef;
 	struct IfcArbitraryClosedProfileDef;
 	struct IfcArbitraryOpenProfileDef;
 	struct IfcArbitraryProfileDefWithVoids;
 	struct IfcGroup;
 	struct IfcAsset;
 	struct IfcParameterizedProfileDef;
 	struct IfcAsymmetricIShapeProfileDef;
 	struct IfcAudioVisualAppliance;
 	struct IfcAudioVisualApplianceType;
 	struct IfcPlacement;
 	struct IfcAxis1Placement;
 	struct IfcAxis2Placement2D;
 	struct IfcAxis2Placement3D;
 	struct IfcCurve;
 	struct IfcBoundedCurve;
 	struct IfcBSplineCurve;
 	struct IfcBSplineCurveWithKnots;
 	struct IfcSurface;
 	struct IfcBoundedSurface;
 	struct IfcBSplineSurface;
 	struct IfcBSplineSurfaceWithKnots;
 	struct IfcBuildingElement;
 	struct IfcBeam;
 	struct IfcBeamStandardCase;
 	struct IfcBuildingElementType;
 	struct IfcBeamType;
 	struct IfcPresentationItem;
 	typedef NotImplemented IfcSurfaceTexture; // (not currently used by Assimp)
 	typedef NotImplemented IfcBlobTexture; // (not currently used by Assimp)
 	struct IfcCsgPrimitive3D;
 	struct IfcBlock;
 	struct IfcBoiler;
 	struct IfcBoilerType;
 	struct IfcBooleanResult;
 	struct IfcBooleanClippingResult;
 	typedef NotImplemented IfcBoundaryCondition; // (not currently used by Assimp)
 	struct IfcCompositeCurve;
 	struct IfcCompositeCurveOnSurface;
 	struct IfcBoundaryCurve;
 	typedef NotImplemented IfcBoundaryEdgeCondition; // (not currently used by Assimp)
 	typedef NotImplemented IfcBoundaryFaceCondition; // (not currently used by Assimp)
 	typedef NotImplemented IfcBoundaryNodeCondition; // (not currently used by Assimp)
 	typedef NotImplemented IfcBoundaryNodeConditionWarping; // (not currently used by Assimp)
 	struct IfcBoundingBox;
 	struct IfcHalfSpaceSolid;
 	struct IfcBoxedHalfSpace;
 	struct IfcSpatialElement;
 	struct IfcSpatialStructureElement;
 	struct IfcBuilding;
 	struct IfcElementComponent;
 	struct IfcBuildingElementPart;
 	struct IfcElementComponentType;
 	struct IfcBuildingElementPartType;
 	struct IfcBuildingElementProxy;
 	struct IfcBuildingElementProxyType;
 	struct IfcBuildingStorey;
 	struct IfcSystem;
 	struct IfcBuildingSystem;
 	struct IfcBurner;
 	struct IfcBurnerType;
 	struct IfcCShapeProfileDef;
 	struct IfcFlowFitting;
 	struct IfcCableCarrierFitting;
 	struct IfcFlowFittingType;
 	struct IfcCableCarrierFittingType;
 	struct IfcFlowSegment;
 	struct IfcCableCarrierSegment;
 	struct IfcFlowSegmentType;
 	struct IfcCableCarrierSegmentType;
 	struct IfcCableFitting;
 	struct IfcCableFittingType;
 	struct IfcCableSegment;
 	struct IfcCableSegmentType;
 	struct IfcPoint;
 	struct IfcCartesianPoint;
 	struct IfcCartesianPointList;
 	struct IfcCartesianPointList2D;
 	struct IfcCartesianPointList3D;
 	struct IfcCartesianTransformationOperator;
 	struct IfcCartesianTransformationOperator2D;
 	struct IfcCartesianTransformationOperator2DnonUniform;
 	struct IfcCartesianTransformationOperator3D;
 	struct IfcCartesianTransformationOperator3DnonUniform;
 	struct IfcCenterLineProfileDef;
 	struct IfcChiller;
 	struct IfcChillerType;
 	struct IfcChimney;
 	struct IfcChimneyType;
 	struct IfcConic;
 	struct IfcCircle;
 	struct IfcCircleProfileDef;
 	struct IfcCircleHollowProfileDef;
 	struct IfcCivilElement;
 	struct IfcCivilElementType;
 	typedef NotImplemented IfcExternalInformation; // (not currently used by Assimp)
 	typedef NotImplemented IfcClassification; // (not currently used by Assimp)
 	typedef NotImplemented IfcExternalReference; // (not currently used by Assimp)
 	typedef NotImplemented IfcClassificationReference; // (not currently used by Assimp)
 	struct IfcConnectedFaceSet;
 	struct IfcClosedShell;
 	struct IfcCoil;
 	struct IfcCoilType;
 	struct IfcColourSpecification;
 	struct IfcColourRgb;
 	typedef NotImplemented IfcColourRgbList; // (not currently used by Assimp)
 	struct IfcColumn;
 	struct IfcColumnStandardCase;
 	struct IfcColumnType;
 	struct IfcCommunicationsAppliance;
 	struct IfcCommunicationsApplianceType;
 	struct IfcPropertyAbstraction;
 	struct IfcProperty;
 	struct IfcComplexProperty;
 	struct IfcPropertyDefinition;
 	typedef NotImplemented IfcPropertyTemplateDefinition; // (not currently used by Assimp)
 	typedef NotImplemented IfcPropertyTemplate; // (not currently used by Assimp)
 	typedef NotImplemented IfcComplexPropertyTemplate; // (not currently used by Assimp)
 	struct IfcCompositeCurveSegment;
 	struct IfcCompositeProfileDef;
 	struct IfcFlowMovingDevice;
 	struct IfcCompressor;
 	struct IfcFlowMovingDeviceType;
 	struct IfcCompressorType;
 	struct IfcCondenser;
 	struct IfcCondenserType;
 	typedef NotImplemented IfcConnectionGeometry; // (not currently used by Assimp)
 	typedef NotImplemented IfcConnectionCurveGeometry; // (not currently used by Assimp)
 	typedef NotImplemented IfcConnectionPointGeometry; // (not currently used by Assimp)
 	typedef NotImplemented IfcConnectionPointEccentricity; // (not currently used by Assimp)
 	typedef NotImplemented IfcConnectionSurfaceGeometry; // (not currently used by Assimp)
 	typedef NotImplemented IfcConnectionVolumeGeometry; // (not currently used by Assimp)
 	typedef NotImplemented IfcConstraint; // (not currently used by Assimp)
 	struct IfcResource;
 	struct IfcConstructionResource;
 	struct IfcConstructionEquipmentResource;
 	struct IfcTypeResource;
 	struct IfcConstructionResourceType;
 	struct IfcConstructionEquipmentResourceType;
 	struct IfcConstructionMaterialResource;
 	struct IfcConstructionMaterialResourceType;
 	struct IfcConstructionProductResource;
 	struct IfcConstructionProductResourceType;
 	struct IfcContext;
 	struct IfcNamedUnit;
 	struct IfcContextDependentUnit;
 	struct IfcController;
 	struct IfcControllerType;
 	struct IfcConversionBasedUnit;
 	struct IfcConversionBasedUnitWithOffset;
 	struct IfcCooledBeam;
 	struct IfcCooledBeamType;
 	struct IfcCoolingTower;
 	struct IfcCoolingTowerType;
 	typedef NotImplemented IfcCoordinateOperation; // (not currently used by Assimp)
 	typedef NotImplemented IfcCoordinateReferenceSystem; // (not currently used by Assimp)
 	struct IfcCostItem;
 	struct IfcCostSchedule;
 	typedef NotImplemented IfcCostValue; // (not currently used by Assimp)
 	struct IfcCovering;
 	struct IfcCoveringType;
 	struct IfcCrewResource;
 	struct IfcCrewResourceType;
 	struct IfcCsgSolid;
 	typedef NotImplemented IfcCurrencyRelationship; // (not currently used by Assimp)
 	struct IfcCurtainWall;
 	struct IfcCurtainWallType;
 	struct IfcCurveBoundedPlane;
 	struct IfcCurveBoundedSurface;
 	struct IfcPresentationStyle;
 	typedef NotImplemented IfcCurveStyle; // (not currently used by Assimp)
 	typedef NotImplemented IfcCurveStyleFont; // (not currently used by Assimp)
 	typedef NotImplemented IfcCurveStyleFontAndScaling; // (not currently used by Assimp)
 	typedef NotImplemented IfcCurveStyleFontPattern; // (not currently used by Assimp)
 	struct IfcElementarySurface;
 	struct IfcCylindricalSurface;
 	struct IfcDamper;
 	struct IfcDamperType;
 	struct IfcDerivedProfileDef;
 	typedef NotImplemented IfcDerivedUnit; // (not currently used by Assimp)
 	typedef NotImplemented IfcDerivedUnitElement; // (not currently used by Assimp)
 	typedef NotImplemented IfcDimensionalExponents; // (not currently used by Assimp)
 	struct IfcDirection;
 	struct IfcDiscreteAccessory;
 	struct IfcDiscreteAccessoryType;
 	struct IfcDistributionChamberElement;
 	struct IfcDistributionChamberElementType;
 	struct IfcDistributionSystem;
 	struct IfcDistributionCircuit;
 	struct IfcPort;
 	struct IfcDistributionPort;
 	typedef NotImplemented IfcDocumentInformation; // (not currently used by Assimp)
 	typedef NotImplemented IfcDocumentInformationRelationship; // (not currently used by Assimp)
 	typedef NotImplemented IfcDocumentReference; // (not currently used by Assimp)
 	struct IfcDoor;
 	struct IfcPropertySetDefinition;
 	typedef NotImplemented IfcPreDefinedPropertySet; // (not currently used by Assimp)
 	typedef NotImplemented IfcDoorLiningProperties; // (not currently used by Assimp)
 	typedef NotImplemented IfcDoorPanelProperties; // (not currently used by Assimp)
 	struct IfcDoorStandardCase;
 	struct IfcDoorStyle;
 	struct IfcDoorType;
 	typedef NotImplemented IfcPreDefinedItem; // (not currently used by Assimp)
 	typedef NotImplemented IfcPreDefinedColour; // (not currently used by Assimp)
 	typedef NotImplemented IfcDraughtingPreDefinedColour; // (not currently used by Assimp)
 	typedef NotImplemented IfcPreDefinedCurveFont; // (not currently used by Assimp)
 	typedef NotImplemented IfcDraughtingPreDefinedCurveFont; // (not currently used by Assimp)
 	struct IfcDuctFitting;
 	struct IfcDuctFittingType;
 	struct IfcDuctSegment;
 	struct IfcDuctSegmentType;
 	struct IfcFlowTreatmentDevice;
 	struct IfcDuctSilencer;
 	struct IfcFlowTreatmentDeviceType;
 	struct IfcDuctSilencerType;
 	struct IfcEdge;
 	struct IfcEdgeCurve;
 	struct IfcLoop;
 	struct IfcEdgeLoop;
 	struct IfcElectricAppliance;
 	struct IfcElectricApplianceType;
 	struct IfcElectricDistributionBoard;
 	struct IfcElectricDistributionBoardType;
 	struct IfcFlowStorageDevice;
 	struct IfcElectricFlowStorageDevice;
 	struct IfcFlowStorageDeviceType;
 	struct IfcElectricFlowStorageDeviceType;
 	struct IfcElectricGenerator;
 	struct IfcElectricGeneratorType;
 	struct IfcElectricMotor;
 	struct IfcElectricMotorType;
 	struct IfcElectricTimeControl;
 	struct IfcElectricTimeControlType;
 	struct IfcElementAssembly;
 	struct IfcElementAssemblyType;
 	struct IfcQuantitySet;
 	struct IfcElementQuantity;
 	struct IfcEllipse;
 	struct IfcEllipseProfileDef;
 	struct IfcEngine;
 	struct IfcEngineType;
 	struct IfcEvaporativeCooler;
 	struct IfcEvaporativeCoolerType;
 	struct IfcEvaporator;
 	struct IfcEvaporatorType;
 	struct IfcProcess;
 	struct IfcEvent;
 	typedef NotImplemented IfcSchedulingTime; // (not currently used by Assimp)
 	typedef NotImplemented IfcEventTime; // (not currently used by Assimp)
 	struct IfcTypeProcess;
 	struct IfcEventType;
 	typedef NotImplemented IfcExtendedProperties; // (not currently used by Assimp)
 	typedef NotImplemented IfcExternalReferenceRelationship; // (not currently used by Assimp)
 	struct IfcExternalSpatialStructureElement;
 	struct IfcExternalSpatialElement;
 	typedef NotImplemented IfcExternallyDefinedHatchStyle; // (not currently used by Assimp)
 	typedef NotImplemented IfcExternallyDefinedSurfaceStyle; // (not currently used by Assimp)
 	typedef NotImplemented IfcExternallyDefinedTextFont; // (not currently used by Assimp)
 	struct IfcSweptAreaSolid;
 	struct IfcExtrudedAreaSolid;
 	struct IfcExtrudedAreaSolidTapered;
 	struct IfcFaceBasedSurfaceModel;
 	struct IfcFaceBound;
 	struct IfcFaceOuterBound;
 	struct IfcFacetedBrep;
 	struct IfcFacetedBrepWithVoids;
 	typedef NotImplemented IfcStructuralConnectionCondition; // (not currently used by Assimp)
 	typedef NotImplemented IfcFailureConnectionCondition; // (not currently used by Assimp)
 	struct IfcFan;
 	struct IfcFanType;
 	struct IfcFastener;
 	struct IfcFastenerType;
 	struct IfcFeatureElement;
 	struct IfcFeatureElementAddition;
 	struct IfcFeatureElementSubtraction;
 	typedef NotImplemented IfcFillAreaStyle; // (not currently used by Assimp)
 	struct IfcFillAreaStyleHatching;
 	struct IfcFillAreaStyleTiles;
 	struct IfcFilter;
 	struct IfcFilterType;
 	struct IfcFireSuppressionTerminal;
 	struct IfcFireSuppressionTerminalType;
 	struct IfcFixedReferenceSweptAreaSolid;
 	struct IfcFlowInstrument;
 	struct IfcFlowInstrumentType;
 	struct IfcFlowMeter;
 	struct IfcFlowMeterType;
 	struct IfcFooting;
 	struct IfcFootingType;
 	struct IfcFurnishingElement;
 	struct IfcFurnishingElementType;
 	struct IfcFurniture;
 	struct IfcFurnitureType;
 	struct IfcGeographicElement;
 	struct IfcGeographicElementType;
 	struct IfcGeometricSet;
 	struct IfcGeometricCurveSet;
 	struct IfcRepresentationContext;
 	struct IfcGeometricRepresentationContext;
 	struct IfcGeometricRepresentationSubContext;
 	struct IfcGrid;
 	typedef NotImplemented IfcGridAxis; // (not currently used by Assimp)
 	struct IfcObjectPlacement;
 	struct IfcGridPlacement;
 	struct IfcHeatExchanger;
 	struct IfcHeatExchangerType;
 	struct IfcHumidifier;
 	struct IfcHumidifierType;
 	struct IfcIShapeProfileDef;
 	typedef NotImplemented IfcImageTexture; // (not currently used by Assimp)
 	typedef NotImplemented IfcIndexedColourMap; // (not currently used by Assimp)
 	struct IfcIndexedPolyCurve;
 	struct IfcTessellatedItem;
 	struct IfcIndexedPolygonalFace;
 	struct IfcIndexedPolygonalFaceWithVoids;
 	typedef NotImplemented IfcTextureCoordinate; // (not currently used by Assimp)
 	typedef NotImplemented IfcIndexedTextureMap; // (not currently used by Assimp)
 	typedef NotImplemented IfcIndexedTriangleTextureMap; // (not currently used by Assimp)
 	struct IfcInterceptor;
 	struct IfcInterceptorType;
 	struct IfcSurfaceCurve;
 	struct IfcIntersectionCurve;
 	struct IfcInventory;
 	typedef NotImplemented IfcTimeSeries; // (not currently used by Assimp)
 	typedef NotImplemented IfcIrregularTimeSeries; // (not currently used by Assimp)
 	typedef NotImplemented IfcIrregularTimeSeriesValue; // (not currently used by Assimp)
 	struct IfcJunctionBox;
 	struct IfcJunctionBoxType;
 	struct IfcLShapeProfileDef;
 	struct IfcLaborResource;
 	struct IfcLaborResourceType;
 	typedef NotImplemented IfcLagTime; // (not currently used by Assimp)
 	struct IfcLamp;
 	struct IfcLampType;
 	typedef NotImplemented IfcLibraryInformation; // (not currently used by Assimp)
 	typedef NotImplemented IfcLibraryReference; // (not currently used by Assimp)
 	typedef NotImplemented IfcLightDistributionData; // (not currently used by Assimp)
 	struct IfcLightFixture;
 	struct IfcLightFixtureType;
 	typedef NotImplemented IfcLightIntensityDistribution; // (not currently used by Assimp)
 	struct IfcLightSource;
 	struct IfcLightSourceAmbient;
 	struct IfcLightSourceDirectional;
 	struct IfcLightSourceGoniometric;
 	struct IfcLightSourcePositional;
 	struct IfcLightSourceSpot;
 	struct IfcLine;
 	struct IfcLocalPlacement;
 	typedef NotImplemented IfcMapConversion; // (not currently used by Assimp)
 	struct IfcMappedItem;
 	typedef NotImplemented IfcMaterialDefinition; // (not currently used by Assimp)
 	typedef NotImplemented IfcMaterial; // (not currently used by Assimp)
 	typedef NotImplemented IfcMaterialClassificationRelationship; // (not currently used by Assimp)
 	typedef NotImplemented IfcMaterialConstituent; // (not currently used by Assimp)
 	typedef NotImplemented IfcMaterialConstituentSet; // (not currently used by Assimp)
 	struct IfcProductRepresentation;
 	struct IfcMaterialDefinitionRepresentation;
 	typedef NotImplemented IfcMaterialLayer; // (not currently used by Assimp)
 	typedef NotImplemented IfcMaterialLayerSet; // (not currently used by Assimp)
 	typedef NotImplemented IfcMaterialUsageDefinition; // (not currently used by Assimp)
 	typedef NotImplemented IfcMaterialLayerSetUsage; // (not currently used by Assimp)
 	typedef NotImplemented IfcMaterialLayerWithOffsets; // (not currently used by Assimp)
 	typedef NotImplemented IfcMaterialList; // (not currently used by Assimp)
 	typedef NotImplemented IfcMaterialProfile; // (not currently used by Assimp)
 	typedef NotImplemented IfcMaterialProfileSet; // (not currently used by Assimp)
 	typedef NotImplemented IfcMaterialProfileSetUsage; // (not currently used by Assimp)
 	typedef NotImplemented IfcMaterialProfileSetUsageTapering; // (not currently used by Assimp)
 	typedef NotImplemented IfcMaterialProfileWithOffsets; // (not currently used by Assimp)
 	typedef NotImplemented IfcMaterialProperties; // (not currently used by Assimp)
 	typedef NotImplemented IfcMaterialRelationship; // (not currently used by Assimp)
 	struct IfcMeasureWithUnit;
 	struct IfcMechanicalFastener;
 	struct IfcMechanicalFastenerType;
 	struct IfcMedicalDevice;
 	struct IfcMedicalDeviceType;
 	struct IfcMember;
 	struct IfcMemberStandardCase;
 	struct IfcMemberType;
 	typedef NotImplemented IfcMetric; // (not currently used by Assimp)
 	struct IfcMirroredProfileDef;
 	typedef NotImplemented IfcMonetaryUnit; // (not currently used by Assimp)
 	struct IfcMotorConnection;
 	struct IfcMotorConnectionType;
 	typedef NotImplemented IfcObjective; // (not currently used by Assimp)
 	struct IfcOccupant;
 	struct IfcOffsetCurve2D;
 	struct IfcOffsetCurve3D;
 	struct IfcOpenShell;
 	struct IfcOpeningElement;
 	struct IfcOpeningStandardCase;
 	typedef NotImplemented IfcOrganization; // (not currently used by Assimp)
 	typedef NotImplemented IfcOrganizationRelationship; // (not currently used by Assimp)
 	struct IfcOrientedEdge;
 	struct IfcOuterBoundaryCurve;
 	struct IfcOutlet;
 	struct IfcOutletType;
 	typedef NotImplemented IfcOwnerHistory; // (not currently used by Assimp)
 	struct IfcPath;
 	struct IfcPcurve;
 	struct IfcPerformanceHistory;
 	typedef NotImplemented IfcPermeableCoveringProperties; // (not currently used by Assimp)
 	struct IfcPermit;
 	typedef NotImplemented IfcPerson; // (not currently used by Assimp)
 	typedef NotImplemented IfcPersonAndOrganization; // (not currently used by Assimp)
 	typedef NotImplemented IfcPhysicalQuantity; // (not currently used by Assimp)
 	typedef NotImplemented IfcPhysicalComplexQuantity; // (not currently used by Assimp)
 	typedef NotImplemented IfcPhysicalSimpleQuantity; // (not currently used by Assimp)
 	struct IfcPile;
 	struct IfcPileType;
 	struct IfcPipeFitting;
 	struct IfcPipeFittingType;
 	struct IfcPipeSegment;
 	struct IfcPipeSegmentType;
 	typedef NotImplemented IfcPixelTexture; // (not currently used by Assimp)
 	struct IfcPlanarExtent;
 	struct IfcPlanarBox;
 	struct IfcPlane;
 	struct IfcPlate;
 	struct IfcPlateStandardCase;
 	struct IfcPlateType;
 	struct IfcPointOnCurve;
 	struct IfcPointOnSurface;
 	struct IfcPolyLoop;
 	struct IfcPolygonalBoundedHalfSpace;
 	struct IfcTessellatedFaceSet;
 	struct IfcPolygonalFaceSet;
 	struct IfcPolyline;
 	typedef NotImplemented IfcPostalAddress; // (not currently used by Assimp)
 	typedef NotImplemented IfcPreDefinedProperties; // (not currently used by Assimp)
 	typedef NotImplemented IfcPreDefinedTextFont; // (not currently used by Assimp)
 	typedef NotImplemented IfcPresentationLayerAssignment; // (not currently used by Assimp)
 	typedef NotImplemented IfcPresentationLayerWithStyle; // (not currently used by Assimp)
 	struct IfcPresentationStyleAssignment;
 	struct IfcProcedure;
 	struct IfcProcedureType;
 	struct IfcProductDefinitionShape;
 	typedef NotImplemented IfcProfileProperties; // (not currently used by Assimp)
 	struct IfcProject;
 	struct IfcProjectLibrary;
 	struct IfcProjectOrder;
 	typedef NotImplemented IfcProjectedCRS; // (not currently used by Assimp)
 	struct IfcProjectionElement;
 	struct IfcSimpleProperty;
 	struct IfcPropertyBoundedValue;
 	typedef NotImplemented IfcPropertyDependencyRelationship; // (not currently used by Assimp)
 	struct IfcPropertyEnumeratedValue;
 	typedef NotImplemented IfcPropertyEnumeration; // (not currently used by Assimp)
 	struct IfcPropertyListValue;
 	struct IfcPropertyReferenceValue;
 	struct IfcPropertySet;
 	typedef NotImplemented IfcPropertySetTemplate; // (not currently used by Assimp)
 	struct IfcPropertySingleValue;
 	struct IfcPropertyTableValue;
 	struct IfcProtectiveDevice;
 	struct IfcProtectiveDeviceTrippingUnit;
 	struct IfcProtectiveDeviceTrippingUnitType;
 	struct IfcProtectiveDeviceType;
 	struct IfcProxy;
 	struct IfcPump;
 	struct IfcPumpType;
 	typedef NotImplemented IfcQuantityArea; // (not currently used by Assimp)
 	typedef NotImplemented IfcQuantityCount; // (not currently used by Assimp)
 	typedef NotImplemented IfcQuantityLength; // (not currently used by Assimp)
 	typedef NotImplemented IfcQuantityTime; // (not currently used by Assimp)
 	typedef NotImplemented IfcQuantityVolume; // (not currently used by Assimp)
 	typedef NotImplemented IfcQuantityWeight; // (not currently used by Assimp)
 	struct IfcRailing;
 	struct IfcRailingType;
 	struct IfcRamp;
 	struct IfcRampFlight;
 	struct IfcRampFlightType;
 	struct IfcRampType;
 	struct IfcRationalBSplineCurveWithKnots;
 	struct IfcRationalBSplineSurfaceWithKnots;
 	struct IfcRectangleProfileDef;
 	struct IfcRectangleHollowProfileDef;
 	struct IfcRectangularPyramid;
 	struct IfcRectangularTrimmedSurface;
 	typedef NotImplemented IfcRecurrencePattern; // (not currently used by Assimp)
 	typedef NotImplemented IfcReference; // (not currently used by Assimp)
 	typedef NotImplemented IfcRegularTimeSeries; // (not currently used by Assimp)
 	typedef NotImplemented IfcReinforcementBarProperties; // (not currently used by Assimp)
 	typedef NotImplemented IfcReinforcementDefinitionProperties; // (not currently used by Assimp)
 	struct IfcReinforcingElement;
 	struct IfcReinforcingBar;
 	struct IfcReinforcingElementType;
 	struct IfcReinforcingBarType;
 	struct IfcReinforcingMesh;
 	struct IfcReinforcingMeshType;
 	struct IfcRelationship;
 	struct IfcRelDecomposes;
 	struct IfcRelAggregates;
 	typedef NotImplemented IfcRelAssigns; // (not currently used by Assimp)
 	typedef NotImplemented IfcRelAssignsToActor; // (not currently used by Assimp)
 	typedef NotImplemented IfcRelAssignsToControl; // (not currently used by Assimp)
 	typedef NotImplemented IfcRelAssignsToGroup; // (not currently used by Assimp)
 	typedef NotImplemented IfcRelAssignsToGroupByFactor; // (not currently used by Assimp)
 	typedef NotImplemented IfcRelAssignsToProcess; // (not currently used by Assimp)
 	typedef NotImplemented IfcRelAssignsToProduct; // (not currently used by Assimp)
 	typedef NotImplemented IfcRelAssignsToResource; // (not currently used by Assimp)
 	typedef NotImplemented IfcRelAssociates; // (not currently used by Assimp)
 	typedef NotImplemented IfcRelAssociatesApproval; // (not currently used by Assimp)
 	typedef NotImplemented IfcRelAssociatesClassification; // (not currently used by Assimp)
 	typedef NotImplemented IfcRelAssociatesConstraint; // (not currently used by Assimp)
 	typedef NotImplemented IfcRelAssociatesDocument; // (not currently used by Assimp)
 	typedef NotImplemented IfcRelAssociatesLibrary; // (not currently used by Assimp)
 	typedef NotImplemented IfcRelAssociatesMaterial; // (not currently used by Assimp)
 	struct IfcRelConnects;
 	typedef NotImplemented IfcRelConnectsElements; // (not currently used by Assimp)
 	typedef NotImplemented IfcRelConnectsPathElements; // (not currently used by Assimp)
 	typedef NotImplemented IfcRelConnectsPortToElement; // (not currently used by Assimp)
 	typedef NotImplemented IfcRelConnectsPorts; // (not currently used by Assimp)
 	typedef NotImplemented IfcRelConnectsStructuralActivity; // (not currently used by Assimp)
 	typedef NotImplemented IfcRelConnectsStructuralMember; // (not currently used by Assimp)
 	typedef NotImplemented IfcRelConnectsWithEccentricity; // (not currently used by Assimp)
 	typedef NotImplemented IfcRelConnectsWithRealizingElements; // (not currently used by Assimp)
 	struct IfcRelContainedInSpatialStructure;
 	typedef NotImplemented IfcRelCoversBldgElements; // (not currently used by Assimp)
 	typedef NotImplemented IfcRelCoversSpaces; // (not currently used by Assimp)
 	typedef NotImplemented IfcRelDeclares; // (not currently used by Assimp)
 	struct IfcRelDefines;
 	typedef NotImplemented IfcRelDefinesByObject; // (not currently used by Assimp)
 	struct IfcRelDefinesByProperties;
 	typedef NotImplemented IfcRelDefinesByTemplate; // (not currently used by Assimp)
 	typedef NotImplemented IfcRelDefinesByType; // (not currently used by Assimp)
 	struct IfcRelFillsElement;
 	typedef NotImplemented IfcRelFlowControlElements; // (not currently used by Assimp)
 	typedef NotImplemented IfcRelInterferesElements; // (not currently used by Assimp)
 	typedef NotImplemented IfcRelNests; // (not currently used by Assimp)
 	typedef NotImplemented IfcRelProjectsElement; // (not currently used by Assimp)
 	typedef NotImplemented IfcRelReferencedInSpatialStructure; // (not currently used by Assimp)
 	typedef NotImplemented IfcRelSequence; // (not currently used by Assimp)
 	typedef NotImplemented IfcRelServicesBuildings; // (not currently used by Assimp)
 	typedef NotImplemented IfcRelSpaceBoundary; // (not currently used by Assimp)
 	typedef NotImplemented IfcRelSpaceBoundary1stLevel; // (not currently used by Assimp)
 	typedef NotImplemented IfcRelSpaceBoundary2ndLevel; // (not currently used by Assimp)
 	struct IfcRelVoidsElement;
 	struct IfcReparametrisedCompositeCurveSegment;
 	struct IfcRepresentation;
 	struct IfcRepresentationMap;
 	typedef NotImplemented IfcResourceApprovalRelationship; // (not currently used by Assimp)
 	typedef NotImplemented IfcResourceConstraintRelationship; // (not currently used by Assimp)
 	typedef NotImplemented IfcResourceTime; // (not currently used by Assimp)
 	struct IfcRevolvedAreaSolid;
 	struct IfcRevolvedAreaSolidTapered;
 	struct IfcRightCircularCone;
 	struct IfcRightCircularCylinder;
 	struct IfcRoof;
 	struct IfcRoofType;
 	struct IfcRoundedRectangleProfileDef;
 	struct IfcSIUnit;
 	struct IfcSanitaryTerminal;
 	struct IfcSanitaryTerminalType;
 	struct IfcSeamCurve;
 	typedef NotImplemented IfcSectionProperties; // (not currently used by Assimp)
 	typedef NotImplemented IfcSectionReinforcementProperties; // (not currently used by Assimp)
 	struct IfcSectionedSpine;
 	struct IfcSensor;
 	struct IfcSensorType;
 	struct IfcShadingDevice;
 	struct IfcShadingDeviceType;
 	typedef NotImplemented IfcShapeAspect; // (not currently used by Assimp)
 	struct IfcShapeModel;
 	struct IfcShapeRepresentation;
 	struct IfcShellBasedSurfaceModel;
 	typedef NotImplemented IfcSimplePropertyTemplate; // (not currently used by Assimp)
 	struct IfcSite;
 	struct IfcSlab;
 	struct IfcSlabElementedCase;
 	struct IfcSlabStandardCase;
 	struct IfcSlabType;
 	typedef NotImplemented IfcSlippageConnectionCondition; // (not currently used by Assimp)
 	struct IfcSolarDevice;
 	struct IfcSolarDeviceType;
 	struct IfcSpace;
 	struct IfcSpaceHeater;
 	struct IfcSpaceHeaterType;
 	struct IfcSpatialElementType;
 	struct IfcSpatialStructureElementType;
 	struct IfcSpaceType;
 	struct IfcSpatialZone;
 	struct IfcSpatialZoneType;
 	struct IfcSphere;
 	struct IfcSphericalSurface;
 	struct IfcStackTerminal;
 	struct IfcStackTerminalType;
 	struct IfcStair;
 	struct IfcStairFlight;
 	struct IfcStairFlightType;
 	struct IfcStairType;
 	struct IfcStructuralActivity;
 	struct IfcStructuralAction;
 	struct IfcStructuralAnalysisModel;
 	struct IfcStructuralItem;
 	struct IfcStructuralConnection;
 	struct IfcStructuralCurveAction;
 	struct IfcStructuralCurveConnection;
 	struct IfcStructuralMember;
 	struct IfcStructuralCurveMember;
 	struct IfcStructuralCurveMemberVarying;
 	struct IfcStructuralReaction;
 	struct IfcStructuralCurveReaction;
 	struct IfcStructuralLinearAction;
 	typedef NotImplemented IfcStructuralLoad; // (not currently used by Assimp)
 	struct IfcStructuralLoadGroup;
 	struct IfcStructuralLoadCase;
 	typedef NotImplemented IfcStructuralLoadConfiguration; // (not currently used by Assimp)
 	typedef NotImplemented IfcStructuralLoadOrResult; // (not currently used by Assimp)
 	typedef NotImplemented IfcStructuralLoadStatic; // (not currently used by Assimp)
 	typedef NotImplemented IfcStructuralLoadLinearForce; // (not currently used by Assimp)
 	typedef NotImplemented IfcStructuralLoadPlanarForce; // (not currently used by Assimp)
 	typedef NotImplemented IfcStructuralLoadSingleDisplacement; // (not currently used by Assimp)
 	typedef NotImplemented IfcStructuralLoadSingleDisplacementDistortion; // (not currently used by Assimp)
 	typedef NotImplemented IfcStructuralLoadSingleForce; // (not currently used by Assimp)
 	typedef NotImplemented IfcStructuralLoadSingleForceWarping; // (not currently used by Assimp)
 	typedef NotImplemented IfcStructuralLoadTemperature; // (not currently used by Assimp)
 	struct IfcStructuralSurfaceAction;
 	struct IfcStructuralPlanarAction;
 	struct IfcStructuralPointAction;
 	struct IfcStructuralPointConnection;
 	struct IfcStructuralPointReaction;
 	struct IfcStructuralResultGroup;
 	struct IfcStructuralSurfaceConnection;
 	struct IfcStructuralSurfaceMember;
 	struct IfcStructuralSurfaceMemberVarying;
 	struct IfcStructuralSurfaceReaction;
 	struct IfcStyleModel;
 	struct IfcStyledItem;
 	struct IfcStyledRepresentation;
 	struct IfcSubContractResource;
 	struct IfcSubContractResourceType;
 	struct IfcSubedge;
 	struct IfcSurfaceCurveSweptAreaSolid;
 	struct IfcSurfaceFeature;
 	struct IfcSweptSurface;
 	struct IfcSurfaceOfLinearExtrusion;
 	struct IfcSurfaceOfRevolution;
 	typedef NotImplemented IfcSurfaceReinforcementArea; // (not currently used by Assimp)
 	struct IfcSurfaceStyle;
 	typedef NotImplemented IfcSurfaceStyleLighting; // (not currently used by Assimp)
 	typedef NotImplemented IfcSurfaceStyleRefraction; // (not currently used by Assimp)
 	struct IfcSurfaceStyleShading;
 	struct IfcSurfaceStyleRendering;
 	struct IfcSurfaceStyleWithTextures;
 	struct IfcSweptDiskSolid;
 	struct IfcSweptDiskSolidPolygonal;
 	struct IfcSwitchingDevice;
 	struct IfcSwitchingDeviceType;
 	struct IfcSystemFurnitureElement;
 	struct IfcSystemFurnitureElementType;
 	struct IfcTShapeProfileDef;
 	typedef NotImplemented IfcTable; // (not currently used by Assimp)
 	typedef NotImplemented IfcTableColumn; // (not currently used by Assimp)
 	typedef NotImplemented IfcTableRow; // (not currently used by Assimp)
 	struct IfcTank;
 	struct IfcTankType;
 	struct IfcTask;
 	typedef NotImplemented IfcTaskTime; // (not currently used by Assimp)
 	typedef NotImplemented IfcTaskTimeRecurring; // (not currently used by Assimp)
 	struct IfcTaskType;
 	typedef NotImplemented IfcTelecomAddress; // (not currently used by Assimp)
 	struct IfcTendon;
 	struct IfcTendonAnchor;
 	struct IfcTendonAnchorType;
 	struct IfcTendonType;
 	struct IfcTextLiteral;
 	struct IfcTextLiteralWithExtent;
 	typedef NotImplemented IfcTextStyle; // (not currently used by Assimp)
 	typedef NotImplemented IfcTextStyleFontModel; // (not currently used by Assimp)
 	typedef NotImplemented IfcTextStyleForDefinedFont; // (not currently used by Assimp)
 	typedef NotImplemented IfcTextStyleTextModel; // (not currently used by Assimp)
 	typedef NotImplemented IfcTextureCoordinateGenerator; // (not currently used by Assimp)
 	typedef NotImplemented IfcTextureMap; // (not currently used by Assimp)
 	typedef NotImplemented IfcTextureVertex; // (not currently used by Assimp)
 	typedef NotImplemented IfcTextureVertexList; // (not currently used by Assimp)
 	typedef NotImplemented IfcTimePeriod; // (not currently used by Assimp)
 	typedef NotImplemented IfcTimeSeriesValue; // (not currently used by Assimp)
 	struct IfcTopologyRepresentation;
 	struct IfcToroidalSurface;
 	struct IfcTransformer;
 	struct IfcTransformerType;
 	struct IfcTransportElement;
 	struct IfcTransportElementType;
 	struct IfcTrapeziumProfileDef;
 	struct IfcTriangulatedFaceSet;
 	struct IfcTrimmedCurve;
 	struct IfcTubeBundle;
 	struct IfcTubeBundleType;
 	struct IfcUShapeProfileDef;
 	struct IfcUnitAssignment;
 	struct IfcUnitaryControlElement;
 	struct IfcUnitaryControlElementType;
 	struct IfcUnitaryEquipment;
 	struct IfcUnitaryEquipmentType;
 	struct IfcValve;
 	struct IfcValveType;
 	struct IfcVector;
 	struct IfcVertex;
 	struct IfcVertexLoop;
 	struct IfcVertexPoint;
 	struct IfcVibrationIsolator;
 	struct IfcVibrationIsolatorType;
 	struct IfcVirtualElement;
 	typedef NotImplemented IfcVirtualGridIntersection; // (not currently used by Assimp)
 	struct IfcVoidingFeature;
 	struct IfcWall;
 	struct IfcWallElementedCase;
 	struct IfcWallStandardCase;
 	struct IfcWallType;
 	struct IfcWasteTerminal;
 	struct IfcWasteTerminalType;
 	struct IfcWindow;
 	typedef NotImplemented IfcWindowLiningProperties; // (not currently used by Assimp)
 	typedef NotImplemented IfcWindowPanelProperties; // (not currently used by Assimp)
 	struct IfcWindowStandardCase;
 	struct IfcWindowStyle;
 	struct IfcWindowType;
 	struct IfcWorkCalendar;
 	struct IfcWorkControl;
 	struct IfcWorkPlan;
 	struct IfcWorkSchedule;
 	typedef NotImplemented IfcWorkTime; // (not currently used by Assimp)
 	struct IfcZShapeProfileDef;
 	struct IfcZone;
 
 
 
     // C++ wrapper for IfcRoot
     struct IfcRoot :  ObjectHelper<IfcRoot,4> { IfcRoot() : Object("IfcRoot") {}
 		IfcGloballyUniqueId::Out GlobalId;
 		Maybe< Lazy< NotImplemented > > OwnerHistory;
 		Maybe< IfcLabel::Out > Name;
 		Maybe< IfcText::Out > Description;
     };
 
     // C++ wrapper for IfcObjectDefinition
     struct IfcObjectDefinition : IfcRoot, ObjectHelper<IfcObjectDefinition,0> { IfcObjectDefinition() : Object("IfcObjectDefinition") {}
 
     };
 
     // C++ wrapper for IfcObject
     struct IfcObject : IfcObjectDefinition, ObjectHelper<IfcObject,1> { IfcObject() : Object("IfcObject") {}
 		Maybe< IfcLabel::Out > ObjectType;
     };
 
     // C++ wrapper for IfcControl
     struct IfcControl : IfcObject, ObjectHelper<IfcControl,1> { IfcControl() : Object("IfcControl") {}
 		Maybe< IfcIdentifier::Out > Identification;
     };
 
     // C++ wrapper for IfcActionRequest
     struct IfcActionRequest : IfcControl, ObjectHelper<IfcActionRequest,3> { IfcActionRequest() : Object("IfcActionRequest") {}
 		Maybe< IfcActionRequestTypeEnum::Out > PredefinedType;
 		Maybe< IfcLabel::Out > Status;
 		Maybe< IfcText::Out > LongDescription;
     };
 
     // C++ wrapper for IfcActor
     struct IfcActor : IfcObject, ObjectHelper<IfcActor,1> { IfcActor() : Object("IfcActor") {}
 		IfcActorSelect::Out TheActor;
     };
 
     // C++ wrapper for IfcProduct
     struct IfcProduct : IfcObject, ObjectHelper<IfcProduct,2> { IfcProduct() : Object("IfcProduct") {}
 		Maybe< Lazy< IfcObjectPlacement > > ObjectPlacement;
 		Maybe< Lazy< IfcProductRepresentation > > Representation;
     };
 
     // C++ wrapper for IfcElement
     struct IfcElement : IfcProduct, ObjectHelper<IfcElement,1> { IfcElement() : Object("IfcElement") {}
 		Maybe< IfcIdentifier::Out > Tag;
     };
 
     // C++ wrapper for IfcDistributionElement
     struct IfcDistributionElement : IfcElement, ObjectHelper<IfcDistributionElement,0> { IfcDistributionElement() : Object("IfcDistributionElement") {}
 
     };
 
     // C++ wrapper for IfcDistributionControlElement
     struct IfcDistributionControlElement : IfcDistributionElement, ObjectHelper<IfcDistributionControlElement,0> { IfcDistributionControlElement() : Object("IfcDistributionControlElement") {}
 
     };
 
     // C++ wrapper for IfcActuator
     struct IfcActuator : IfcDistributionControlElement, ObjectHelper<IfcActuator,1> { IfcActuator() : Object("IfcActuator") {}
 		Maybe< IfcActuatorTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcTypeObject
     struct IfcTypeObject : IfcObjectDefinition, ObjectHelper<IfcTypeObject,2> { IfcTypeObject() : Object("IfcTypeObject") {}
 		Maybe< IfcIdentifier::Out > ApplicableOccurrence;
 		Maybe< ListOf< Lazy< IfcPropertySetDefinition >, 1, 0 > > HasPropertySets;
     };
 
     // C++ wrapper for IfcTypeProduct
     struct IfcTypeProduct : IfcTypeObject, ObjectHelper<IfcTypeProduct,2> { IfcTypeProduct() : Object("IfcTypeProduct") {}
 		Maybe< ListOf< Lazy< IfcRepresentationMap >, 1, 0 > > RepresentationMaps;
 		Maybe< IfcLabel::Out > Tag;
     };
 
     // C++ wrapper for IfcElementType
     struct IfcElementType : IfcTypeProduct, ObjectHelper<IfcElementType,1> { IfcElementType() : Object("IfcElementType") {}
 		Maybe< IfcLabel::Out > ElementType;
     };
 
     // C++ wrapper for IfcDistributionElementType
     struct IfcDistributionElementType : IfcElementType, ObjectHelper<IfcDistributionElementType,0> { IfcDistributionElementType() : Object("IfcDistributionElementType") {}
 
     };
 
     // C++ wrapper for IfcDistributionControlElementType
     struct IfcDistributionControlElementType : IfcDistributionElementType, ObjectHelper<IfcDistributionControlElementType,0> { IfcDistributionControlElementType() : Object("IfcDistributionControlElementType") {}
 
     };
 
     // C++ wrapper for IfcActuatorType
     struct IfcActuatorType : IfcDistributionControlElementType, ObjectHelper<IfcActuatorType,1> { IfcActuatorType() : Object("IfcActuatorType") {}
 		IfcActuatorTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcRepresentationItem
     struct IfcRepresentationItem :  ObjectHelper<IfcRepresentationItem,0> { IfcRepresentationItem() : Object("IfcRepresentationItem") {}
 
     };
 
     // C++ wrapper for IfcGeometricRepresentationItem
     struct IfcGeometricRepresentationItem : IfcRepresentationItem, ObjectHelper<IfcGeometricRepresentationItem,0> { IfcGeometricRepresentationItem() : Object("IfcGeometricRepresentationItem") {}
 
     };
 
     // C++ wrapper for IfcSolidModel
     struct IfcSolidModel : IfcGeometricRepresentationItem, ObjectHelper<IfcSolidModel,0> { IfcSolidModel() : Object("IfcSolidModel") {}
 
     };
 
     // C++ wrapper for IfcManifoldSolidBrep
     struct IfcManifoldSolidBrep : IfcSolidModel, ObjectHelper<IfcManifoldSolidBrep,1> { IfcManifoldSolidBrep() : Object("IfcManifoldSolidBrep") {}
 		Lazy< IfcClosedShell > Outer;
     };
 
     // C++ wrapper for IfcAdvancedBrep
     struct IfcAdvancedBrep : IfcManifoldSolidBrep, ObjectHelper<IfcAdvancedBrep,0> { IfcAdvancedBrep() : Object("IfcAdvancedBrep") {}
 
     };
 
     // C++ wrapper for IfcAdvancedBrepWithVoids
     struct IfcAdvancedBrepWithVoids : IfcAdvancedBrep, ObjectHelper<IfcAdvancedBrepWithVoids,1> { IfcAdvancedBrepWithVoids() : Object("IfcAdvancedBrepWithVoids") {}
 		ListOf< Lazy< IfcClosedShell >, 1, 0 > Voids;
     };
 
     // C++ wrapper for IfcTopologicalRepresentationItem
     struct IfcTopologicalRepresentationItem : IfcRepresentationItem, ObjectHelper<IfcTopologicalRepresentationItem,0> { IfcTopologicalRepresentationItem() : Object("IfcTopologicalRepresentationItem") {}
 
     };
 
     // C++ wrapper for IfcFace
     struct IfcFace : IfcTopologicalRepresentationItem, ObjectHelper<IfcFace,1> { IfcFace() : Object("IfcFace") {}
 		ListOf< Lazy< IfcFaceBound >, 1, 0 > Bounds;
     };
 
     // C++ wrapper for IfcFaceSurface
     struct IfcFaceSurface : IfcFace, ObjectHelper<IfcFaceSurface,2> { IfcFaceSurface() : Object("IfcFaceSurface") {}
 		Lazy< IfcSurface > FaceSurface;
 		IfcBoolean::Out SameSense;
     };
 
     // C++ wrapper for IfcAdvancedFace
     struct IfcAdvancedFace : IfcFaceSurface, ObjectHelper<IfcAdvancedFace,0> { IfcAdvancedFace() : Object("IfcAdvancedFace") {}
 
     };
 
     // C++ wrapper for IfcDistributionFlowElement
     struct IfcDistributionFlowElement : IfcDistributionElement, ObjectHelper<IfcDistributionFlowElement,0> { IfcDistributionFlowElement() : Object("IfcDistributionFlowElement") {}
 
     };
 
     // C++ wrapper for IfcFlowTerminal
     struct IfcFlowTerminal : IfcDistributionFlowElement, ObjectHelper<IfcFlowTerminal,0> { IfcFlowTerminal() : Object("IfcFlowTerminal") {}
 
     };
 
     // C++ wrapper for IfcAirTerminal
     struct IfcAirTerminal : IfcFlowTerminal, ObjectHelper<IfcAirTerminal,1> { IfcAirTerminal() : Object("IfcAirTerminal") {}
 		Maybe< IfcAirTerminalTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcFlowController
     struct IfcFlowController : IfcDistributionFlowElement, ObjectHelper<IfcFlowController,0> { IfcFlowController() : Object("IfcFlowController") {}
 
     };
 
     // C++ wrapper for IfcAirTerminalBox
     struct IfcAirTerminalBox : IfcFlowController, ObjectHelper<IfcAirTerminalBox,1> { IfcAirTerminalBox() : Object("IfcAirTerminalBox") {}
 		Maybe< IfcAirTerminalBoxTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcDistributionFlowElementType
     struct IfcDistributionFlowElementType : IfcDistributionElementType, ObjectHelper<IfcDistributionFlowElementType,0> { IfcDistributionFlowElementType() : Object("IfcDistributionFlowElementType") {}
 
     };
 
     // C++ wrapper for IfcFlowControllerType
     struct IfcFlowControllerType : IfcDistributionFlowElementType, ObjectHelper<IfcFlowControllerType,0> { IfcFlowControllerType() : Object("IfcFlowControllerType") {}
 
     };
 
     // C++ wrapper for IfcAirTerminalBoxType
     struct IfcAirTerminalBoxType : IfcFlowControllerType, ObjectHelper<IfcAirTerminalBoxType,1> { IfcAirTerminalBoxType() : Object("IfcAirTerminalBoxType") {}
 		IfcAirTerminalBoxTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcFlowTerminalType
     struct IfcFlowTerminalType : IfcDistributionFlowElementType, ObjectHelper<IfcFlowTerminalType,0> { IfcFlowTerminalType() : Object("IfcFlowTerminalType") {}
 
     };
 
     // C++ wrapper for IfcAirTerminalType
     struct IfcAirTerminalType : IfcFlowTerminalType, ObjectHelper<IfcAirTerminalType,1> { IfcAirTerminalType() : Object("IfcAirTerminalType") {}
 		IfcAirTerminalTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcEnergyConversionDevice
     struct IfcEnergyConversionDevice : IfcDistributionFlowElement, ObjectHelper<IfcEnergyConversionDevice,0> { IfcEnergyConversionDevice() : Object("IfcEnergyConversionDevice") {}
 
     };
 
     // C++ wrapper for IfcAirToAirHeatRecovery
     struct IfcAirToAirHeatRecovery : IfcEnergyConversionDevice, ObjectHelper<IfcAirToAirHeatRecovery,1> { IfcAirToAirHeatRecovery() : Object("IfcAirToAirHeatRecovery") {}
 		Maybe< IfcAirToAirHeatRecoveryTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcEnergyConversionDeviceType
     struct IfcEnergyConversionDeviceType : IfcDistributionFlowElementType, ObjectHelper<IfcEnergyConversionDeviceType,0> { IfcEnergyConversionDeviceType() : Object("IfcEnergyConversionDeviceType") {}
 
     };
 
     // C++ wrapper for IfcAirToAirHeatRecoveryType
     struct IfcAirToAirHeatRecoveryType : IfcEnergyConversionDeviceType, ObjectHelper<IfcAirToAirHeatRecoveryType,1> { IfcAirToAirHeatRecoveryType() : Object("IfcAirToAirHeatRecoveryType") {}
 		IfcAirToAirHeatRecoveryTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcAlarm
     struct IfcAlarm : IfcDistributionControlElement, ObjectHelper<IfcAlarm,1> { IfcAlarm() : Object("IfcAlarm") {}
 		Maybe< IfcAlarmTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcAlarmType
     struct IfcAlarmType : IfcDistributionControlElementType, ObjectHelper<IfcAlarmType,1> { IfcAlarmType() : Object("IfcAlarmType") {}
 		IfcAlarmTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcAnnotation
     struct IfcAnnotation : IfcProduct, ObjectHelper<IfcAnnotation,0> { IfcAnnotation() : Object("IfcAnnotation") {}
 
     };
 
     // C++ wrapper for IfcAnnotationFillArea
     struct IfcAnnotationFillArea : IfcGeometricRepresentationItem, ObjectHelper<IfcAnnotationFillArea,2> { IfcAnnotationFillArea() : Object("IfcAnnotationFillArea") {}
 		Lazy< IfcCurve > OuterBoundary;
 		Maybe< ListOf< Lazy< IfcCurve >, 1, 0 > > InnerBoundaries;
     };
 
     // C++ wrapper for IfcProfileDef
     struct IfcProfileDef :  ObjectHelper<IfcProfileDef,2> { IfcProfileDef() : Object("IfcProfileDef") {}
 		IfcProfileTypeEnum::Out ProfileType;
 		Maybe< IfcLabel::Out > ProfileName;
     };
 
     // C++ wrapper for IfcArbitraryClosedProfileDef
     struct IfcArbitraryClosedProfileDef : IfcProfileDef, ObjectHelper<IfcArbitraryClosedProfileDef,1> { IfcArbitraryClosedProfileDef() : Object("IfcArbitraryClosedProfileDef") {}
 		Lazy< IfcCurve > OuterCurve;
     };
 
     // C++ wrapper for IfcArbitraryOpenProfileDef
     struct IfcArbitraryOpenProfileDef : IfcProfileDef, ObjectHelper<IfcArbitraryOpenProfileDef,1> { IfcArbitraryOpenProfileDef() : Object("IfcArbitraryOpenProfileDef") {}
 		Lazy< IfcBoundedCurve > Curve;
     };
 
     // C++ wrapper for IfcArbitraryProfileDefWithVoids
     struct IfcArbitraryProfileDefWithVoids : IfcArbitraryClosedProfileDef, ObjectHelper<IfcArbitraryProfileDefWithVoids,1> { IfcArbitraryProfileDefWithVoids() : Object("IfcArbitraryProfileDefWithVoids") {}
 		ListOf< Lazy< IfcCurve >, 1, 0 > InnerCurves;
     };
 
     // C++ wrapper for IfcGroup
     struct IfcGroup : IfcObject, ObjectHelper<IfcGroup,0> { IfcGroup() : Object("IfcGroup") {}
 
     };
 
     // C++ wrapper for IfcAsset
     struct IfcAsset : IfcGroup, ObjectHelper<IfcAsset,9> { IfcAsset() : Object("IfcAsset") {}
 		Maybe< IfcIdentifier::Out > Identification;
 		Maybe< Lazy< NotImplemented > > OriginalValue;
 		Maybe< Lazy< NotImplemented > > CurrentValue;
 		Maybe< Lazy< NotImplemented > > TotalReplacementCost;
 		Maybe< IfcActorSelect::Out > Owner;
 		Maybe< IfcActorSelect::Out > User;
 		Maybe< Lazy< NotImplemented > > ResponsiblePerson;
 		Maybe< IfcDate::Out > IncorporationDate;
 		Maybe< Lazy< NotImplemented > > DepreciatedValue;
     };
 
     // C++ wrapper for IfcParameterizedProfileDef
     struct IfcParameterizedProfileDef : IfcProfileDef, ObjectHelper<IfcParameterizedProfileDef,1> { IfcParameterizedProfileDef() : Object("IfcParameterizedProfileDef") {}
 		Maybe< Lazy< IfcAxis2Placement2D > > Position;
     };
 
     // C++ wrapper for IfcAsymmetricIShapeProfileDef
     struct IfcAsymmetricIShapeProfileDef : IfcParameterizedProfileDef, ObjectHelper<IfcAsymmetricIShapeProfileDef,12> { IfcAsymmetricIShapeProfileDef() : Object("IfcAsymmetricIShapeProfileDef") {}
 		IfcPositiveLengthMeasure::Out BottomFlangeWidth;
 		IfcPositiveLengthMeasure::Out OverallDepth;
 		IfcPositiveLengthMeasure::Out WebThickness;
 		IfcPositiveLengthMeasure::Out BottomFlangeThickness;
 		Maybe< IfcNonNegativeLengthMeasure::Out > BottomFlangeFilletRadius;
 		IfcPositiveLengthMeasure::Out TopFlangeWidth;
 		Maybe< IfcPositiveLengthMeasure::Out > TopFlangeThickness;
 		Maybe< IfcNonNegativeLengthMeasure::Out > TopFlangeFilletRadius;
 		Maybe< IfcNonNegativeLengthMeasure::Out > BottomFlangeEdgeRadius;
 		Maybe< IfcPlaneAngleMeasure::Out > BottomFlangeSlope;
 		Maybe< IfcNonNegativeLengthMeasure::Out > TopFlangeEdgeRadius;
 		Maybe< IfcPlaneAngleMeasure::Out > TopFlangeSlope;
     };
 
     // C++ wrapper for IfcAudioVisualAppliance
     struct IfcAudioVisualAppliance : IfcFlowTerminal, ObjectHelper<IfcAudioVisualAppliance,1> { IfcAudioVisualAppliance() : Object("IfcAudioVisualAppliance") {}
 		Maybe< IfcAudioVisualApplianceTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcAudioVisualApplianceType
     struct IfcAudioVisualApplianceType : IfcFlowTerminalType, ObjectHelper<IfcAudioVisualApplianceType,1> { IfcAudioVisualApplianceType() : Object("IfcAudioVisualApplianceType") {}
 		IfcAudioVisualApplianceTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcPlacement
     struct IfcPlacement : IfcGeometricRepresentationItem, ObjectHelper<IfcPlacement,1> { IfcPlacement() : Object("IfcPlacement") {}
 		Lazy< IfcCartesianPoint > Location;
     };
 
     // C++ wrapper for IfcAxis1Placement
     struct IfcAxis1Placement : IfcPlacement, ObjectHelper<IfcAxis1Placement,1> { IfcAxis1Placement() : Object("IfcAxis1Placement") {}
 		Maybe< Lazy< IfcDirection > > Axis;
     };
 
     // C++ wrapper for IfcAxis2Placement2D
     struct IfcAxis2Placement2D : IfcPlacement, ObjectHelper<IfcAxis2Placement2D,1> { IfcAxis2Placement2D() : Object("IfcAxis2Placement2D") {}
 		Maybe< Lazy< IfcDirection > > RefDirection;
     };
 
     // C++ wrapper for IfcAxis2Placement3D
     struct IfcAxis2Placement3D : IfcPlacement, ObjectHelper<IfcAxis2Placement3D,2> { IfcAxis2Placement3D() : Object("IfcAxis2Placement3D") {}
 		Maybe< Lazy< IfcDirection > > Axis;
 		Maybe< Lazy< IfcDirection > > RefDirection;
     };
 
     // C++ wrapper for IfcCurve
     struct IfcCurve : IfcGeometricRepresentationItem, ObjectHelper<IfcCurve,0> { IfcCurve() : Object("IfcCurve") {}
 
     };
 
     // C++ wrapper for IfcBoundedCurve
     struct IfcBoundedCurve : IfcCurve, ObjectHelper<IfcBoundedCurve,0> { IfcBoundedCurve() : Object("IfcBoundedCurve") {}
 
     };
 
     // C++ wrapper for IfcBSplineCurve
     struct IfcBSplineCurve : IfcBoundedCurve, ObjectHelper<IfcBSplineCurve,5> { IfcBSplineCurve() : Object("IfcBSplineCurve") {}
 		IfcInteger::Out Degree;
 		ListOf< Lazy< IfcCartesianPoint >, 2, 0 > ControlPointsList;
 		IfcBSplineCurveForm::Out CurveForm;
 		IfcLogical::Out ClosedCurve;
 		IfcLogical::Out SelfIntersect;
     };
 
     // C++ wrapper for IfcBSplineCurveWithKnots
     struct IfcBSplineCurveWithKnots : IfcBSplineCurve, ObjectHelper<IfcBSplineCurveWithKnots,3> { IfcBSplineCurveWithKnots() : Object("IfcBSplineCurveWithKnots") {}
 		ListOf< IfcInteger, 2, 0 >::Out KnotMultiplicities;
 		ListOf< IfcParameterValue, 2, 0 >::Out Knots;
 		IfcKnotType::Out KnotSpec;
     };
 
     // C++ wrapper for IfcSurface
     struct IfcSurface : IfcGeometricRepresentationItem, ObjectHelper<IfcSurface,0> { IfcSurface() : Object("IfcSurface") {}
 
     };
 
     // C++ wrapper for IfcBoundedSurface
     struct IfcBoundedSurface : IfcSurface, ObjectHelper<IfcBoundedSurface,0> { IfcBoundedSurface() : Object("IfcBoundedSurface") {}
 
     };
 
     // C++ wrapper for IfcBSplineSurface
     struct IfcBSplineSurface : IfcBoundedSurface, ObjectHelper<IfcBSplineSurface,6> { IfcBSplineSurface() : Object("IfcBSplineSurface") {}
 		IfcInteger::Out UDegree;
 		IfcInteger::Out VDegree;
 		IfcBSplineSurfaceForm::Out SurfaceForm;
 		IfcLogical::Out UClosed;
 		IfcLogical::Out VClosed;
 		IfcLogical::Out SelfIntersect;
     };
 
     // C++ wrapper for IfcBSplineSurfaceWithKnots
     struct IfcBSplineSurfaceWithKnots : IfcBSplineSurface, ObjectHelper<IfcBSplineSurfaceWithKnots,5> { IfcBSplineSurfaceWithKnots() : Object("IfcBSplineSurfaceWithKnots") {}
 		ListOf< IfcInteger, 2, 0 >::Out UMultiplicities;
 		ListOf< IfcInteger, 2, 0 >::Out VMultiplicities;
 		ListOf< IfcParameterValue, 2, 0 >::Out UKnots;
 		ListOf< IfcParameterValue, 2, 0 >::Out VKnots;
 		IfcKnotType::Out KnotSpec;
     };
 
     // C++ wrapper for IfcBuildingElement
     struct IfcBuildingElement : IfcElement, ObjectHelper<IfcBuildingElement,0> { IfcBuildingElement() : Object("IfcBuildingElement") {}
 
     };
 
     // C++ wrapper for IfcBeam
     struct IfcBeam : IfcBuildingElement, ObjectHelper<IfcBeam,1> { IfcBeam() : Object("IfcBeam") {}
 		Maybe< IfcBeamTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcBeamStandardCase
     struct IfcBeamStandardCase : IfcBeam, ObjectHelper<IfcBeamStandardCase,0> { IfcBeamStandardCase() : Object("IfcBeamStandardCase") {}
 
     };
 
     // C++ wrapper for IfcBuildingElementType
     struct IfcBuildingElementType : IfcElementType, ObjectHelper<IfcBuildingElementType,0> { IfcBuildingElementType() : Object("IfcBuildingElementType") {}
 
     };
 
     // C++ wrapper for IfcBeamType
     struct IfcBeamType : IfcBuildingElementType, ObjectHelper<IfcBeamType,1> { IfcBeamType() : Object("IfcBeamType") {}
 		IfcBeamTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcPresentationItem
     struct IfcPresentationItem :  ObjectHelper<IfcPresentationItem,0> { IfcPresentationItem() : Object("IfcPresentationItem") {}
 
     };
 
     // C++ wrapper for IfcCsgPrimitive3D
     struct IfcCsgPrimitive3D : IfcGeometricRepresentationItem, ObjectHelper<IfcCsgPrimitive3D,1> { IfcCsgPrimitive3D() : Object("IfcCsgPrimitive3D") {}
 		Lazy< IfcAxis2Placement3D > Position;
     };
 
     // C++ wrapper for IfcBlock
     struct IfcBlock : IfcCsgPrimitive3D, ObjectHelper<IfcBlock,3> { IfcBlock() : Object("IfcBlock") {}
 		IfcPositiveLengthMeasure::Out XLength;
 		IfcPositiveLengthMeasure::Out YLength;
 		IfcPositiveLengthMeasure::Out ZLength;
     };
 
     // C++ wrapper for IfcBoiler
     struct IfcBoiler : IfcEnergyConversionDevice, ObjectHelper<IfcBoiler,1> { IfcBoiler() : Object("IfcBoiler") {}
 		Maybe< IfcBoilerTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcBoilerType
     struct IfcBoilerType : IfcEnergyConversionDeviceType, ObjectHelper<IfcBoilerType,1> { IfcBoilerType() : Object("IfcBoilerType") {}
 		IfcBoilerTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcBooleanResult
     struct IfcBooleanResult : IfcGeometricRepresentationItem, ObjectHelper<IfcBooleanResult,3> { IfcBooleanResult() : Object("IfcBooleanResult") {}
 		IfcBooleanOperator::Out Operator;
 		IfcBooleanOperand::Out FirstOperand;
 		IfcBooleanOperand::Out SecondOperand;
     };
 
     // C++ wrapper for IfcBooleanClippingResult
     struct IfcBooleanClippingResult : IfcBooleanResult, ObjectHelper<IfcBooleanClippingResult,0> { IfcBooleanClippingResult() : Object("IfcBooleanClippingResult") {}
 
     };
 
     // C++ wrapper for IfcCompositeCurve
     struct IfcCompositeCurve : IfcBoundedCurve, ObjectHelper<IfcCompositeCurve,2> { IfcCompositeCurve() : Object("IfcCompositeCurve") {}
 		ListOf< Lazy< IfcCompositeCurveSegment >, 1, 0 > Segments;
 		IfcLogical::Out SelfIntersect;
     };
 
     // C++ wrapper for IfcCompositeCurveOnSurface
     struct IfcCompositeCurveOnSurface : IfcCompositeCurve, ObjectHelper<IfcCompositeCurveOnSurface,0> { IfcCompositeCurveOnSurface() : Object("IfcCompositeCurveOnSurface") {}
 
     };
 
     // C++ wrapper for IfcBoundaryCurve
     struct IfcBoundaryCurve : IfcCompositeCurveOnSurface, ObjectHelper<IfcBoundaryCurve,0> { IfcBoundaryCurve() : Object("IfcBoundaryCurve") {}
 
     };
 
     // C++ wrapper for IfcBoundingBox
     struct IfcBoundingBox : IfcGeometricRepresentationItem, ObjectHelper<IfcBoundingBox,4> { IfcBoundingBox() : Object("IfcBoundingBox") {}
 		Lazy< IfcCartesianPoint > Corner;
 		IfcPositiveLengthMeasure::Out XDim;
 		IfcPositiveLengthMeasure::Out YDim;
 		IfcPositiveLengthMeasure::Out ZDim;
     };
 
     // C++ wrapper for IfcHalfSpaceSolid
     struct IfcHalfSpaceSolid : IfcGeometricRepresentationItem, ObjectHelper<IfcHalfSpaceSolid,2> { IfcHalfSpaceSolid() : Object("IfcHalfSpaceSolid") {}
 		Lazy< IfcSurface > BaseSurface;
 		IfcBoolean::Out AgreementFlag;
     };
 
     // C++ wrapper for IfcBoxedHalfSpace
     struct IfcBoxedHalfSpace : IfcHalfSpaceSolid, ObjectHelper<IfcBoxedHalfSpace,1> { IfcBoxedHalfSpace() : Object("IfcBoxedHalfSpace") {}
 		Lazy< IfcBoundingBox > Enclosure;
     };
 
     // C++ wrapper for IfcSpatialElement
     struct IfcSpatialElement : IfcProduct, ObjectHelper<IfcSpatialElement,1> { IfcSpatialElement() : Object("IfcSpatialElement") {}
 		Maybe< IfcLabel::Out > LongName;
     };
 
     // C++ wrapper for IfcSpatialStructureElement
     struct IfcSpatialStructureElement : IfcSpatialElement, ObjectHelper<IfcSpatialStructureElement,1> { IfcSpatialStructureElement() : Object("IfcSpatialStructureElement") {}
 		Maybe< IfcElementCompositionEnum::Out > CompositionType;
     };
 
     // C++ wrapper for IfcBuilding
     struct IfcBuilding : IfcSpatialStructureElement, ObjectHelper<IfcBuilding,3> { IfcBuilding() : Object("IfcBuilding") {}
 		Maybe< IfcLengthMeasure::Out > ElevationOfRefHeight;
 		Maybe< IfcLengthMeasure::Out > ElevationOfTerrain;
 		Maybe< Lazy< NotImplemented > > BuildingAddress;
     };
 
     // C++ wrapper for IfcElementComponent
     struct IfcElementComponent : IfcElement, ObjectHelper<IfcElementComponent,0> { IfcElementComponent() : Object("IfcElementComponent") {}
 
     };
 
     // C++ wrapper for IfcBuildingElementPart
     struct IfcBuildingElementPart : IfcElementComponent, ObjectHelper<IfcBuildingElementPart,1> { IfcBuildingElementPart() : Object("IfcBuildingElementPart") {}
 		Maybe< IfcBuildingElementPartTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcElementComponentType
     struct IfcElementComponentType : IfcElementType, ObjectHelper<IfcElementComponentType,0> { IfcElementComponentType() : Object("IfcElementComponentType") {}
 
     };
 
     // C++ wrapper for IfcBuildingElementPartType
     struct IfcBuildingElementPartType : IfcElementComponentType, ObjectHelper<IfcBuildingElementPartType,1> { IfcBuildingElementPartType() : Object("IfcBuildingElementPartType") {}
 		IfcBuildingElementPartTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcBuildingElementProxy
     struct IfcBuildingElementProxy : IfcBuildingElement, ObjectHelper<IfcBuildingElementProxy,1> { IfcBuildingElementProxy() : Object("IfcBuildingElementProxy") {}
 		Maybe< IfcBuildingElementProxyTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcBuildingElementProxyType
     struct IfcBuildingElementProxyType : IfcBuildingElementType, ObjectHelper<IfcBuildingElementProxyType,1> { IfcBuildingElementProxyType() : Object("IfcBuildingElementProxyType") {}
 		IfcBuildingElementProxyTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcBuildingStorey
     struct IfcBuildingStorey : IfcSpatialStructureElement, ObjectHelper<IfcBuildingStorey,1> { IfcBuildingStorey() : Object("IfcBuildingStorey") {}
 		Maybe< IfcLengthMeasure::Out > Elevation;
     };
 
     // C++ wrapper for IfcSystem
     struct IfcSystem : IfcGroup, ObjectHelper<IfcSystem,0> { IfcSystem() : Object("IfcSystem") {}
 
     };
 
     // C++ wrapper for IfcBuildingSystem
     struct IfcBuildingSystem : IfcSystem, ObjectHelper<IfcBuildingSystem,2> { IfcBuildingSystem() : Object("IfcBuildingSystem") {}
 		Maybe< IfcBuildingSystemTypeEnum::Out > PredefinedType;
 		Maybe< IfcLabel::Out > LongName;
     };
 
     // C++ wrapper for IfcBurner
     struct IfcBurner : IfcEnergyConversionDevice, ObjectHelper<IfcBurner,1> { IfcBurner() : Object("IfcBurner") {}
 		Maybe< IfcBurnerTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcBurnerType
     struct IfcBurnerType : IfcEnergyConversionDeviceType, ObjectHelper<IfcBurnerType,1> { IfcBurnerType() : Object("IfcBurnerType") {}
 		IfcBurnerTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcCShapeProfileDef
     struct IfcCShapeProfileDef : IfcParameterizedProfileDef, ObjectHelper<IfcCShapeProfileDef,5> { IfcCShapeProfileDef() : Object("IfcCShapeProfileDef") {}
 		IfcPositiveLengthMeasure::Out Depth;
 		IfcPositiveLengthMeasure::Out Width;
 		IfcPositiveLengthMeasure::Out WallThickness;
 		IfcPositiveLengthMeasure::Out Girth;
 		Maybe< IfcNonNegativeLengthMeasure::Out > InternalFilletRadius;
     };
 
     // C++ wrapper for IfcFlowFitting
     struct IfcFlowFitting : IfcDistributionFlowElement, ObjectHelper<IfcFlowFitting,0> { IfcFlowFitting() : Object("IfcFlowFitting") {}
 
     };
 
     // C++ wrapper for IfcCableCarrierFitting
     struct IfcCableCarrierFitting : IfcFlowFitting, ObjectHelper<IfcCableCarrierFitting,1> { IfcCableCarrierFitting() : Object("IfcCableCarrierFitting") {}
 		Maybe< IfcCableCarrierFittingTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcFlowFittingType
     struct IfcFlowFittingType : IfcDistributionFlowElementType, ObjectHelper<IfcFlowFittingType,0> { IfcFlowFittingType() : Object("IfcFlowFittingType") {}
 
     };
 
     // C++ wrapper for IfcCableCarrierFittingType
     struct IfcCableCarrierFittingType : IfcFlowFittingType, ObjectHelper<IfcCableCarrierFittingType,1> { IfcCableCarrierFittingType() : Object("IfcCableCarrierFittingType") {}
 		IfcCableCarrierFittingTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcFlowSegment
     struct IfcFlowSegment : IfcDistributionFlowElement, ObjectHelper<IfcFlowSegment,0> { IfcFlowSegment() : Object("IfcFlowSegment") {}
 
     };
 
     // C++ wrapper for IfcCableCarrierSegment
     struct IfcCableCarrierSegment : IfcFlowSegment, ObjectHelper<IfcCableCarrierSegment,1> { IfcCableCarrierSegment() : Object("IfcCableCarrierSegment") {}
 		Maybe< IfcCableCarrierSegmentTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcFlowSegmentType
     struct IfcFlowSegmentType : IfcDistributionFlowElementType, ObjectHelper<IfcFlowSegmentType,0> { IfcFlowSegmentType() : Object("IfcFlowSegmentType") {}
 
     };
 
     // C++ wrapper for IfcCableCarrierSegmentType
     struct IfcCableCarrierSegmentType : IfcFlowSegmentType, ObjectHelper<IfcCableCarrierSegmentType,1> { IfcCableCarrierSegmentType() : Object("IfcCableCarrierSegmentType") {}
 		IfcCableCarrierSegmentTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcCableFitting
     struct IfcCableFitting : IfcFlowFitting, ObjectHelper<IfcCableFitting,1> { IfcCableFitting() : Object("IfcCableFitting") {}
 		Maybe< IfcCableFittingTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcCableFittingType
     struct IfcCableFittingType : IfcFlowFittingType, ObjectHelper<IfcCableFittingType,1> { IfcCableFittingType() : Object("IfcCableFittingType") {}
 		IfcCableFittingTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcCableSegment
     struct IfcCableSegment : IfcFlowSegment, ObjectHelper<IfcCableSegment,1> { IfcCableSegment() : Object("IfcCableSegment") {}
 		Maybe< IfcCableSegmentTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcCableSegmentType
     struct IfcCableSegmentType : IfcFlowSegmentType, ObjectHelper<IfcCableSegmentType,1> { IfcCableSegmentType() : Object("IfcCableSegmentType") {}
 		IfcCableSegmentTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcPoint
     struct IfcPoint : IfcGeometricRepresentationItem, ObjectHelper<IfcPoint,0> { IfcPoint() : Object("IfcPoint") {}
 
     };
 
     // C++ wrapper for IfcCartesianPoint
     struct IfcCartesianPoint : IfcPoint, ObjectHelper<IfcCartesianPoint,1> { IfcCartesianPoint() : Object("IfcCartesianPoint") {}
 		ListOf< IfcLengthMeasure, 1, 3 >::Out Coordinates;
     };
 
     // C++ wrapper for IfcCartesianPointList
     struct IfcCartesianPointList : IfcGeometricRepresentationItem, ObjectHelper<IfcCartesianPointList,0> { IfcCartesianPointList() : Object("IfcCartesianPointList") {}
 
     };
 
     // C++ wrapper for IfcCartesianPointList2D
     struct IfcCartesianPointList2D : IfcCartesianPointList, ObjectHelper<IfcCartesianPointList2D,0> { IfcCartesianPointList2D() : Object("IfcCartesianPointList2D") {}
 
     };
 
     // C++ wrapper for IfcCartesianPointList3D
     struct IfcCartesianPointList3D : IfcCartesianPointList, ObjectHelper<IfcCartesianPointList3D,0> { IfcCartesianPointList3D() : Object("IfcCartesianPointList3D") {}
 
     };
 
     // C++ wrapper for IfcCartesianTransformationOperator
     struct IfcCartesianTransformationOperator : IfcGeometricRepresentationItem, ObjectHelper<IfcCartesianTransformationOperator,4> { IfcCartesianTransformationOperator() : Object("IfcCartesianTransformationOperator") {}
 		Maybe< Lazy< IfcDirection > > Axis1;
 		Maybe< Lazy< IfcDirection > > Axis2;
 		Lazy< IfcCartesianPoint > LocalOrigin;
 		Maybe< IfcReal::Out > Scale;
     };
 
     // C++ wrapper for IfcCartesianTransformationOperator2D
     struct IfcCartesianTransformationOperator2D : IfcCartesianTransformationOperator, ObjectHelper<IfcCartesianTransformationOperator2D,0> { IfcCartesianTransformationOperator2D() : Object("IfcCartesianTransformationOperator2D") {}
 
     };
 
     // C++ wrapper for IfcCartesianTransformationOperator2DnonUniform
     struct IfcCartesianTransformationOperator2DnonUniform : IfcCartesianTransformationOperator2D, ObjectHelper<IfcCartesianTransformationOperator2DnonUniform,1> { IfcCartesianTransformationOperator2DnonUniform() : Object("IfcCartesianTransformationOperator2DnonUniform") {}
 		Maybe< IfcReal::Out > Scale2;
     };
 
     // C++ wrapper for IfcCartesianTransformationOperator3D
     struct IfcCartesianTransformationOperator3D : IfcCartesianTransformationOperator, ObjectHelper<IfcCartesianTransformationOperator3D,1> { IfcCartesianTransformationOperator3D() : Object("IfcCartesianTransformationOperator3D") {}
 		Maybe< Lazy< IfcDirection > > Axis3;
     };
 
     // C++ wrapper for IfcCartesianTransformationOperator3DnonUniform
     struct IfcCartesianTransformationOperator3DnonUniform : IfcCartesianTransformationOperator3D, ObjectHelper<IfcCartesianTransformationOperator3DnonUniform,2> { IfcCartesianTransformationOperator3DnonUniform() : Object("IfcCartesianTransformationOperator3DnonUniform") {}
 		Maybe< IfcReal::Out > Scale2;
 		Maybe< IfcReal::Out > Scale3;
     };
 
     // C++ wrapper for IfcCenterLineProfileDef
     struct IfcCenterLineProfileDef : IfcArbitraryOpenProfileDef, ObjectHelper<IfcCenterLineProfileDef,1> { IfcCenterLineProfileDef() : Object("IfcCenterLineProfileDef") {}
 		IfcPositiveLengthMeasure::Out Thickness;
     };
 
     // C++ wrapper for IfcChiller
     struct IfcChiller : IfcEnergyConversionDevice, ObjectHelper<IfcChiller,1> { IfcChiller() : Object("IfcChiller") {}
 		Maybe< IfcChillerTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcChillerType
     struct IfcChillerType : IfcEnergyConversionDeviceType, ObjectHelper<IfcChillerType,1> { IfcChillerType() : Object("IfcChillerType") {}
 		IfcChillerTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcChimney
     struct IfcChimney : IfcBuildingElement, ObjectHelper<IfcChimney,1> { IfcChimney() : Object("IfcChimney") {}
 		Maybe< IfcChimneyTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcChimneyType
     struct IfcChimneyType : IfcBuildingElementType, ObjectHelper<IfcChimneyType,1> { IfcChimneyType() : Object("IfcChimneyType") {}
 		IfcChimneyTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcConic
     struct IfcConic : IfcCurve, ObjectHelper<IfcConic,1> { IfcConic() : Object("IfcConic") {}
 		IfcAxis2Placement::Out Position;
     };
 
     // C++ wrapper for IfcCircle
     struct IfcCircle : IfcConic, ObjectHelper<IfcCircle,1> { IfcCircle() : Object("IfcCircle") {}
 		IfcPositiveLengthMeasure::Out Radius;
     };
 
     // C++ wrapper for IfcCircleProfileDef
     struct IfcCircleProfileDef : IfcParameterizedProfileDef, ObjectHelper<IfcCircleProfileDef,1> { IfcCircleProfileDef() : Object("IfcCircleProfileDef") {}
 		IfcPositiveLengthMeasure::Out Radius;
     };
 
     // C++ wrapper for IfcCircleHollowProfileDef
     struct IfcCircleHollowProfileDef : IfcCircleProfileDef, ObjectHelper<IfcCircleHollowProfileDef,1> { IfcCircleHollowProfileDef() : Object("IfcCircleHollowProfileDef") {}
 		IfcPositiveLengthMeasure::Out WallThickness;
     };
 
     // C++ wrapper for IfcCivilElement
     struct IfcCivilElement : IfcElement, ObjectHelper<IfcCivilElement,0> { IfcCivilElement() : Object("IfcCivilElement") {}
 
     };
 
     // C++ wrapper for IfcCivilElementType
     struct IfcCivilElementType : IfcElementType, ObjectHelper<IfcCivilElementType,0> { IfcCivilElementType() : Object("IfcCivilElementType") {}
 
     };
 
     // C++ wrapper for IfcConnectedFaceSet
     struct IfcConnectedFaceSet : IfcTopologicalRepresentationItem, ObjectHelper<IfcConnectedFaceSet,1> { IfcConnectedFaceSet() : Object("IfcConnectedFaceSet") {}
 		ListOf< Lazy< IfcFace >, 1, 0 > CfsFaces;
     };
 
     // C++ wrapper for IfcClosedShell
     struct IfcClosedShell : IfcConnectedFaceSet, ObjectHelper<IfcClosedShell,0> { IfcClosedShell() : Object("IfcClosedShell") {}
 
     };
 
     // C++ wrapper for IfcCoil
     struct IfcCoil : IfcEnergyConversionDevice, ObjectHelper<IfcCoil,1> { IfcCoil() : Object("IfcCoil") {}
 		Maybe< IfcCoilTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcCoilType
     struct IfcCoilType : IfcEnergyConversionDeviceType, ObjectHelper<IfcCoilType,1> { IfcCoilType() : Object("IfcCoilType") {}
 		IfcCoilTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcColourSpecification
     struct IfcColourSpecification : IfcPresentationItem, ObjectHelper<IfcColourSpecification,1> { IfcColourSpecification() : Object("IfcColourSpecification") {}
 		Maybe< IfcLabel::Out > Name;
     };
 
     // C++ wrapper for IfcColourRgb
     struct IfcColourRgb : IfcColourSpecification, ObjectHelper<IfcColourRgb,3> { IfcColourRgb() : Object("IfcColourRgb") {}
 		IfcNormalisedRatioMeasure::Out Red;
 		IfcNormalisedRatioMeasure::Out Green;
 		IfcNormalisedRatioMeasure::Out Blue;
     };
 
     // C++ wrapper for IfcColumn
     struct IfcColumn : IfcBuildingElement, ObjectHelper<IfcColumn,1> { IfcColumn() : Object("IfcColumn") {}
 		Maybe< IfcColumnTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcColumnStandardCase
     struct IfcColumnStandardCase : IfcColumn, ObjectHelper<IfcColumnStandardCase,0> { IfcColumnStandardCase() : Object("IfcColumnStandardCase") {}
 
     };
 
     // C++ wrapper for IfcColumnType
     struct IfcColumnType : IfcBuildingElementType, ObjectHelper<IfcColumnType,1> { IfcColumnType() : Object("IfcColumnType") {}
 		IfcColumnTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcCommunicationsAppliance
     struct IfcCommunicationsAppliance : IfcFlowTerminal, ObjectHelper<IfcCommunicationsAppliance,1> { IfcCommunicationsAppliance() : Object("IfcCommunicationsAppliance") {}
 		Maybe< IfcCommunicationsApplianceTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcCommunicationsApplianceType
     struct IfcCommunicationsApplianceType : IfcFlowTerminalType, ObjectHelper<IfcCommunicationsApplianceType,1> { IfcCommunicationsApplianceType() : Object("IfcCommunicationsApplianceType") {}
 		IfcCommunicationsApplianceTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcPropertyAbstraction
     struct IfcPropertyAbstraction :  ObjectHelper<IfcPropertyAbstraction,0> { IfcPropertyAbstraction() : Object("IfcPropertyAbstraction") {}
 
     };
 
     // C++ wrapper for IfcProperty
     struct IfcProperty : IfcPropertyAbstraction, ObjectHelper<IfcProperty,2> { IfcProperty() : Object("IfcProperty") {}
 		IfcIdentifier::Out Name;
 		Maybe< IfcText::Out > Description;
     };
 
     // C++ wrapper for IfcComplexProperty
     struct IfcComplexProperty : IfcProperty, ObjectHelper<IfcComplexProperty,2> { IfcComplexProperty() : Object("IfcComplexProperty") {}
 		IfcIdentifier::Out UsageName;
 		ListOf< Lazy< IfcProperty >, 1, 0 > HasProperties;
     };
 
     // C++ wrapper for IfcPropertyDefinition
     struct IfcPropertyDefinition : IfcRoot, ObjectHelper<IfcPropertyDefinition,0> { IfcPropertyDefinition() : Object("IfcPropertyDefinition") {}
 
     };
 
     // C++ wrapper for IfcCompositeCurveSegment
     struct IfcCompositeCurveSegment : IfcGeometricRepresentationItem, ObjectHelper<IfcCompositeCurveSegment,3> { IfcCompositeCurveSegment() : Object("IfcCompositeCurveSegment") {}
 		IfcTransitionCode::Out Transition;
 		IfcBoolean::Out SameSense;
 		Lazy< IfcCurve > ParentCurve;
     };
 
     // C++ wrapper for IfcCompositeProfileDef
     struct IfcCompositeProfileDef : IfcProfileDef, ObjectHelper<IfcCompositeProfileDef,2> { IfcCompositeProfileDef() : Object("IfcCompositeProfileDef") {}
 		ListOf< Lazy< IfcProfileDef >, 2, 0 > Profiles;
 		Maybe< IfcLabel::Out > Label;
     };
 
     // C++ wrapper for IfcFlowMovingDevice
     struct IfcFlowMovingDevice : IfcDistributionFlowElement, ObjectHelper<IfcFlowMovingDevice,0> { IfcFlowMovingDevice() : Object("IfcFlowMovingDevice") {}
 
     };
 
     // C++ wrapper for IfcCompressor
     struct IfcCompressor : IfcFlowMovingDevice, ObjectHelper<IfcCompressor,1> { IfcCompressor() : Object("IfcCompressor") {}
 		Maybe< IfcCompressorTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcFlowMovingDeviceType
     struct IfcFlowMovingDeviceType : IfcDistributionFlowElementType, ObjectHelper<IfcFlowMovingDeviceType,0> { IfcFlowMovingDeviceType() : Object("IfcFlowMovingDeviceType") {}
 
     };
 
     // C++ wrapper for IfcCompressorType
     struct IfcCompressorType : IfcFlowMovingDeviceType, ObjectHelper<IfcCompressorType,1> { IfcCompressorType() : Object("IfcCompressorType") {}
 		IfcCompressorTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcCondenser
     struct IfcCondenser : IfcEnergyConversionDevice, ObjectHelper<IfcCondenser,1> { IfcCondenser() : Object("IfcCondenser") {}
 		Maybe< IfcCondenserTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcCondenserType
     struct IfcCondenserType : IfcEnergyConversionDeviceType, ObjectHelper<IfcCondenserType,1> { IfcCondenserType() : Object("IfcCondenserType") {}
 		IfcCondenserTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcResource
     struct IfcResource : IfcObject, ObjectHelper<IfcResource,2> { IfcResource() : Object("IfcResource") {}
 		Maybe< IfcIdentifier::Out > Identification;
 		Maybe< IfcText::Out > LongDescription;
     };
 
     // C++ wrapper for IfcConstructionResource
     struct IfcConstructionResource : IfcResource, ObjectHelper<IfcConstructionResource,3> { IfcConstructionResource() : Object("IfcConstructionResource") {}
 		Maybe< Lazy< NotImplemented > > Usage;
 		Maybe< ListOf< Lazy< NotImplemented >, 1, 0 > > BaseCosts;
 		Maybe< Lazy< NotImplemented > > BaseQuantity;
     };
 
     // C++ wrapper for IfcConstructionEquipmentResource
     struct IfcConstructionEquipmentResource : IfcConstructionResource, ObjectHelper<IfcConstructionEquipmentResource,1> { IfcConstructionEquipmentResource() : Object("IfcConstructionEquipmentResource") {}
 		Maybe< IfcConstructionEquipmentResourceTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcTypeResource
     struct IfcTypeResource : IfcTypeObject, ObjectHelper<IfcTypeResource,3> { IfcTypeResource() : Object("IfcTypeResource") {}
 		Maybe< IfcIdentifier::Out > Identification;
 		Maybe< IfcText::Out > LongDescription;
 		Maybe< IfcLabel::Out > ResourceType;
     };
 
     // C++ wrapper for IfcConstructionResourceType
     struct IfcConstructionResourceType : IfcTypeResource, ObjectHelper<IfcConstructionResourceType,2> { IfcConstructionResourceType() : Object("IfcConstructionResourceType") {}
 		Maybe< ListOf< Lazy< NotImplemented >, 1, 0 > > BaseCosts;
 		Maybe< Lazy< NotImplemented > > BaseQuantity;
     };
 
     // C++ wrapper for IfcConstructionEquipmentResourceType
     struct IfcConstructionEquipmentResourceType : IfcConstructionResourceType, ObjectHelper<IfcConstructionEquipmentResourceType,1> { IfcConstructionEquipmentResourceType() : Object("IfcConstructionEquipmentResourceType") {}
 		IfcConstructionEquipmentResourceTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcConstructionMaterialResource
     struct IfcConstructionMaterialResource : IfcConstructionResource, ObjectHelper<IfcConstructionMaterialResource,1> { IfcConstructionMaterialResource() : Object("IfcConstructionMaterialResource") {}
 		Maybe< IfcConstructionMaterialResourceTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcConstructionMaterialResourceType
     struct IfcConstructionMaterialResourceType : IfcConstructionResourceType, ObjectHelper<IfcConstructionMaterialResourceType,1> { IfcConstructionMaterialResourceType() : Object("IfcConstructionMaterialResourceType") {}
 		IfcConstructionMaterialResourceTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcConstructionProductResource
     struct IfcConstructionProductResource : IfcConstructionResource, ObjectHelper<IfcConstructionProductResource,1> { IfcConstructionProductResource() : Object("IfcConstructionProductResource") {}
 		Maybe< IfcConstructionProductResourceTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcConstructionProductResourceType
     struct IfcConstructionProductResourceType : IfcConstructionResourceType, ObjectHelper<IfcConstructionProductResourceType,1> { IfcConstructionProductResourceType() : Object("IfcConstructionProductResourceType") {}
 		IfcConstructionProductResourceTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcContext
     struct IfcContext : IfcObjectDefinition, ObjectHelper<IfcContext,5> { IfcContext() : Object("IfcContext") {}
 		Maybe< IfcLabel::Out > ObjectType;
 		Maybe< IfcLabel::Out > LongName;
 		Maybe< IfcLabel::Out > Phase;
 		Maybe< ListOf< Lazy< IfcRepresentationContext >, 1, 0 > > RepresentationContexts;
 		Maybe< Lazy< IfcUnitAssignment > > UnitsInContext;
     };
 
     // C++ wrapper for IfcNamedUnit
     struct IfcNamedUnit :  ObjectHelper<IfcNamedUnit,2> { IfcNamedUnit() : Object("IfcNamedUnit") {}
 		Lazy< NotImplemented > Dimensions;
 		IfcUnitEnum::Out UnitType;
     };
 
     // C++ wrapper for IfcContextDependentUnit
     struct IfcContextDependentUnit : IfcNamedUnit, ObjectHelper<IfcContextDependentUnit,1> { IfcContextDependentUnit() : Object("IfcContextDependentUnit") {}
 		IfcLabel::Out Name;
     };
 
     // C++ wrapper for IfcController
     struct IfcController : IfcDistributionControlElement, ObjectHelper<IfcController,1> { IfcController() : Object("IfcController") {}
 		Maybe< IfcControllerTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcControllerType
     struct IfcControllerType : IfcDistributionControlElementType, ObjectHelper<IfcControllerType,1> { IfcControllerType() : Object("IfcControllerType") {}
 		IfcControllerTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcConversionBasedUnit
     struct IfcConversionBasedUnit : IfcNamedUnit, ObjectHelper<IfcConversionBasedUnit,2> { IfcConversionBasedUnit() : Object("IfcConversionBasedUnit") {}
 		IfcLabel::Out Name;
 		Lazy< IfcMeasureWithUnit > ConversionFactor;
     };
 
     // C++ wrapper for IfcConversionBasedUnitWithOffset
     struct IfcConversionBasedUnitWithOffset : IfcConversionBasedUnit, ObjectHelper<IfcConversionBasedUnitWithOffset,1> { IfcConversionBasedUnitWithOffset() : Object("IfcConversionBasedUnitWithOffset") {}
 		IfcReal::Out ConversionOffset;
     };
 
     // C++ wrapper for IfcCooledBeam
     struct IfcCooledBeam : IfcEnergyConversionDevice, ObjectHelper<IfcCooledBeam,1> { IfcCooledBeam() : Object("IfcCooledBeam") {}
 		Maybe< IfcCooledBeamTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcCooledBeamType
     struct IfcCooledBeamType : IfcEnergyConversionDeviceType, ObjectHelper<IfcCooledBeamType,1> { IfcCooledBeamType() : Object("IfcCooledBeamType") {}
 		IfcCooledBeamTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcCoolingTower
     struct IfcCoolingTower : IfcEnergyConversionDevice, ObjectHelper<IfcCoolingTower,1> { IfcCoolingTower() : Object("IfcCoolingTower") {}
 		Maybe< IfcCoolingTowerTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcCoolingTowerType
     struct IfcCoolingTowerType : IfcEnergyConversionDeviceType, ObjectHelper<IfcCoolingTowerType,1> { IfcCoolingTowerType() : Object("IfcCoolingTowerType") {}
 		IfcCoolingTowerTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcCostItem
     struct IfcCostItem : IfcControl, ObjectHelper<IfcCostItem,3> { IfcCostItem() : Object("IfcCostItem") {}
 		Maybe< IfcCostItemTypeEnum::Out > PredefinedType;
 		Maybe< ListOf< Lazy< NotImplemented >, 1, 0 > > CostValues;
 		Maybe< ListOf< Lazy< NotImplemented >, 1, 0 > > CostQuantities;
     };
 
     // C++ wrapper for IfcCostSchedule
     struct IfcCostSchedule : IfcControl, ObjectHelper<IfcCostSchedule,4> { IfcCostSchedule() : Object("IfcCostSchedule") {}
 		Maybe< IfcCostScheduleTypeEnum::Out > PredefinedType;
 		Maybe< IfcLabel::Out > Status;
 		Maybe< IfcDateTime::Out > SubmittedOn;
 		Maybe< IfcDateTime::Out > UpdateDate;
     };
 
     // C++ wrapper for IfcCovering
     struct IfcCovering : IfcBuildingElement, ObjectHelper<IfcCovering,1> { IfcCovering() : Object("IfcCovering") {}
 		Maybe< IfcCoveringTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcCoveringType
     struct IfcCoveringType : IfcBuildingElementType, ObjectHelper<IfcCoveringType,1> { IfcCoveringType() : Object("IfcCoveringType") {}
 		IfcCoveringTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcCrewResource
     struct IfcCrewResource : IfcConstructionResource, ObjectHelper<IfcCrewResource,1> { IfcCrewResource() : Object("IfcCrewResource") {}
 		Maybe< IfcCrewResourceTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcCrewResourceType
     struct IfcCrewResourceType : IfcConstructionResourceType, ObjectHelper<IfcCrewResourceType,1> { IfcCrewResourceType() : Object("IfcCrewResourceType") {}
 		IfcCrewResourceTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcCsgSolid
     struct IfcCsgSolid : IfcSolidModel, ObjectHelper<IfcCsgSolid,1> { IfcCsgSolid() : Object("IfcCsgSolid") {}
 		IfcCsgSelect::Out TreeRootExpression;
     };
 
     // C++ wrapper for IfcCurtainWall
     struct IfcCurtainWall : IfcBuildingElement, ObjectHelper<IfcCurtainWall,1> { IfcCurtainWall() : Object("IfcCurtainWall") {}
 		Maybe< IfcCurtainWallTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcCurtainWallType
     struct IfcCurtainWallType : IfcBuildingElementType, ObjectHelper<IfcCurtainWallType,1> { IfcCurtainWallType() : Object("IfcCurtainWallType") {}
 		IfcCurtainWallTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcCurveBoundedPlane
     struct IfcCurveBoundedPlane : IfcBoundedSurface, ObjectHelper<IfcCurveBoundedPlane,3> { IfcCurveBoundedPlane() : Object("IfcCurveBoundedPlane") {}
 		Lazy< IfcPlane > BasisSurface;
 		Lazy< IfcCurve > OuterBoundary;
 		ListOf< Lazy< IfcCurve >, 0, 0 > InnerBoundaries;
     };
 
     // C++ wrapper for IfcCurveBoundedSurface
     struct IfcCurveBoundedSurface : IfcBoundedSurface, ObjectHelper<IfcCurveBoundedSurface,3> { IfcCurveBoundedSurface() : Object("IfcCurveBoundedSurface") {}
 		Lazy< IfcSurface > BasisSurface;
 		ListOf< Lazy< IfcBoundaryCurve >, 1, 0 > Boundaries;
 		IfcBoolean::Out ImplicitOuter;
     };
 
     // C++ wrapper for IfcPresentationStyle
     struct IfcPresentationStyle :  ObjectHelper<IfcPresentationStyle,1> { IfcPresentationStyle() : Object("IfcPresentationStyle") {}
 		Maybe< IfcLabel::Out > Name;
     };
 
     // C++ wrapper for IfcElementarySurface
     struct IfcElementarySurface : IfcSurface, ObjectHelper<IfcElementarySurface,1> { IfcElementarySurface() : Object("IfcElementarySurface") {}
 		Lazy< IfcAxis2Placement3D > Position;
     };
 
     // C++ wrapper for IfcCylindricalSurface
     struct IfcCylindricalSurface : IfcElementarySurface, ObjectHelper<IfcCylindricalSurface,1> { IfcCylindricalSurface() : Object("IfcCylindricalSurface") {}
 		IfcPositiveLengthMeasure::Out Radius;
     };
 
     // C++ wrapper for IfcDamper
     struct IfcDamper : IfcFlowController, ObjectHelper<IfcDamper,1> { IfcDamper() : Object("IfcDamper") {}
 		Maybe< IfcDamperTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcDamperType
     struct IfcDamperType : IfcFlowControllerType, ObjectHelper<IfcDamperType,1> { IfcDamperType() : Object("IfcDamperType") {}
 		IfcDamperTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcDerivedProfileDef
     struct IfcDerivedProfileDef : IfcProfileDef, ObjectHelper<IfcDerivedProfileDef,3> { IfcDerivedProfileDef() : Object("IfcDerivedProfileDef") {}
 		Lazy< IfcProfileDef > ParentProfile;
 		Lazy< IfcCartesianTransformationOperator2D > Operator;
 		Maybe< IfcLabel::Out > Label;
     };
 
     // C++ wrapper for IfcDirection
     struct IfcDirection : IfcGeometricRepresentationItem, ObjectHelper<IfcDirection,1> { IfcDirection() : Object("IfcDirection") {}
 		ListOf< IfcReal, 2, 3 >::Out DirectionRatios;
     };
 
     // C++ wrapper for IfcDiscreteAccessory
     struct IfcDiscreteAccessory : IfcElementComponent, ObjectHelper<IfcDiscreteAccessory,1> { IfcDiscreteAccessory() : Object("IfcDiscreteAccessory") {}
 		Maybe< IfcDiscreteAccessoryTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcDiscreteAccessoryType
     struct IfcDiscreteAccessoryType : IfcElementComponentType, ObjectHelper<IfcDiscreteAccessoryType,1> { IfcDiscreteAccessoryType() : Object("IfcDiscreteAccessoryType") {}
 		IfcDiscreteAccessoryTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcDistributionChamberElement
     struct IfcDistributionChamberElement : IfcDistributionFlowElement, ObjectHelper<IfcDistributionChamberElement,1> { IfcDistributionChamberElement() : Object("IfcDistributionChamberElement") {}
 		Maybe< IfcDistributionChamberElementTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcDistributionChamberElementType
     struct IfcDistributionChamberElementType : IfcDistributionFlowElementType, ObjectHelper<IfcDistributionChamberElementType,1> { IfcDistributionChamberElementType() : Object("IfcDistributionChamberElementType") {}
 		IfcDistributionChamberElementTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcDistributionSystem
     struct IfcDistributionSystem : IfcSystem, ObjectHelper<IfcDistributionSystem,2> { IfcDistributionSystem() : Object("IfcDistributionSystem") {}
 		Maybe< IfcLabel::Out > LongName;
 		Maybe< IfcDistributionSystemEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcDistributionCircuit
     struct IfcDistributionCircuit : IfcDistributionSystem, ObjectHelper<IfcDistributionCircuit,0> { IfcDistributionCircuit() : Object("IfcDistributionCircuit") {}
 
     };
 
     // C++ wrapper for IfcPort
     struct IfcPort : IfcProduct, ObjectHelper<IfcPort,0> { IfcPort() : Object("IfcPort") {}
 
     };
 
     // C++ wrapper for IfcDistributionPort
     struct IfcDistributionPort : IfcPort, ObjectHelper<IfcDistributionPort,3> { IfcDistributionPort() : Object("IfcDistributionPort") {}
 		Maybe< IfcFlowDirectionEnum::Out > FlowDirection;
 		Maybe< IfcDistributionPortTypeEnum::Out > PredefinedType;
 		Maybe< IfcDistributionSystemEnum::Out > SystemType;
     };
 
     // C++ wrapper for IfcDoor
     struct IfcDoor : IfcBuildingElement, ObjectHelper<IfcDoor,5> { IfcDoor() : Object("IfcDoor") {}
 		Maybe< IfcPositiveLengthMeasure::Out > OverallHeight;
 		Maybe< IfcPositiveLengthMeasure::Out > OverallWidth;
 		Maybe< IfcDoorTypeEnum::Out > PredefinedType;
 		Maybe< IfcDoorTypeOperationEnum::Out > OperationType;
 		Maybe< IfcLabel::Out > UserDefinedOperationType;
     };
 
     // C++ wrapper for IfcPropertySetDefinition
     struct IfcPropertySetDefinition : IfcPropertyDefinition, ObjectHelper<IfcPropertySetDefinition,0> { IfcPropertySetDefinition() : Object("IfcPropertySetDefinition") {}
 
     };
 
     // C++ wrapper for IfcDoorStandardCase
     struct IfcDoorStandardCase : IfcDoor, ObjectHelper<IfcDoorStandardCase,0> { IfcDoorStandardCase() : Object("IfcDoorStandardCase") {}
 
     };
 
     // C++ wrapper for IfcDoorStyle
     struct IfcDoorStyle : IfcTypeProduct, ObjectHelper<IfcDoorStyle,4> { IfcDoorStyle() : Object("IfcDoorStyle") {}
 		IfcDoorStyleOperationEnum::Out OperationType;
 		IfcDoorStyleConstructionEnum::Out ConstructionType;
 		IfcBoolean::Out ParameterTakesPrecedence;
 		IfcBoolean::Out Sizeable;
     };
 
     // C++ wrapper for IfcDoorType
     struct IfcDoorType : IfcBuildingElementType, ObjectHelper<IfcDoorType,4> { IfcDoorType() : Object("IfcDoorType") {}
 		IfcDoorTypeEnum::Out PredefinedType;
 		IfcDoorTypeOperationEnum::Out OperationType;
 		Maybe< IfcBoolean::Out > ParameterTakesPrecedence;
 		Maybe< IfcLabel::Out > UserDefinedOperationType;
     };
 
     // C++ wrapper for IfcDuctFitting
     struct IfcDuctFitting : IfcFlowFitting, ObjectHelper<IfcDuctFitting,1> { IfcDuctFitting() : Object("IfcDuctFitting") {}
 		Maybe< IfcDuctFittingTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcDuctFittingType
     struct IfcDuctFittingType : IfcFlowFittingType, ObjectHelper<IfcDuctFittingType,1> { IfcDuctFittingType() : Object("IfcDuctFittingType") {}
 		IfcDuctFittingTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcDuctSegment
     struct IfcDuctSegment : IfcFlowSegment, ObjectHelper<IfcDuctSegment,1> { IfcDuctSegment() : Object("IfcDuctSegment") {}
 		Maybe< IfcDuctSegmentTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcDuctSegmentType
     struct IfcDuctSegmentType : IfcFlowSegmentType, ObjectHelper<IfcDuctSegmentType,1> { IfcDuctSegmentType() : Object("IfcDuctSegmentType") {}
 		IfcDuctSegmentTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcFlowTreatmentDevice
     struct IfcFlowTreatmentDevice : IfcDistributionFlowElement, ObjectHelper<IfcFlowTreatmentDevice,0> { IfcFlowTreatmentDevice() : Object("IfcFlowTreatmentDevice") {}
 
     };
 
     // C++ wrapper for IfcDuctSilencer
     struct IfcDuctSilencer : IfcFlowTreatmentDevice, ObjectHelper<IfcDuctSilencer,1> { IfcDuctSilencer() : Object("IfcDuctSilencer") {}
 		Maybe< IfcDuctSilencerTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcFlowTreatmentDeviceType
     struct IfcFlowTreatmentDeviceType : IfcDistributionFlowElementType, ObjectHelper<IfcFlowTreatmentDeviceType,0> { IfcFlowTreatmentDeviceType() : Object("IfcFlowTreatmentDeviceType") {}
 
     };
 
     // C++ wrapper for IfcDuctSilencerType
     struct IfcDuctSilencerType : IfcFlowTreatmentDeviceType, ObjectHelper<IfcDuctSilencerType,1> { IfcDuctSilencerType() : Object("IfcDuctSilencerType") {}
 		IfcDuctSilencerTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcEdge
     struct IfcEdge : IfcTopologicalRepresentationItem, ObjectHelper<IfcEdge,2> { IfcEdge() : Object("IfcEdge") {}
 		Lazy< IfcVertex > EdgeStart;
 		Lazy< IfcVertex > EdgeEnd;
     };
 
     // C++ wrapper for IfcEdgeCurve
     struct IfcEdgeCurve : IfcEdge, ObjectHelper<IfcEdgeCurve,2> { IfcEdgeCurve() : Object("IfcEdgeCurve") {}
 		Lazy< IfcCurve > EdgeGeometry;
 		IfcBoolean::Out SameSense;
     };
 
     // C++ wrapper for IfcLoop
     struct IfcLoop : IfcTopologicalRepresentationItem, ObjectHelper<IfcLoop,0> { IfcLoop() : Object("IfcLoop") {}
 
     };
 
     // C++ wrapper for IfcEdgeLoop
     struct IfcEdgeLoop : IfcLoop, ObjectHelper<IfcEdgeLoop,1> { IfcEdgeLoop() : Object("IfcEdgeLoop") {}
 		ListOf< Lazy< IfcOrientedEdge >, 1, 0 > EdgeList;
     };
 
     // C++ wrapper for IfcElectricAppliance
     struct IfcElectricAppliance : IfcFlowTerminal, ObjectHelper<IfcElectricAppliance,1> { IfcElectricAppliance() : Object("IfcElectricAppliance") {}
 		Maybe< IfcElectricApplianceTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcElectricApplianceType
     struct IfcElectricApplianceType : IfcFlowTerminalType, ObjectHelper<IfcElectricApplianceType,1> { IfcElectricApplianceType() : Object("IfcElectricApplianceType") {}
 		IfcElectricApplianceTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcElectricDistributionBoard
     struct IfcElectricDistributionBoard : IfcFlowController, ObjectHelper<IfcElectricDistributionBoard,1> { IfcElectricDistributionBoard() : Object("IfcElectricDistributionBoard") {}
 		Maybe< IfcElectricDistributionBoardTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcElectricDistributionBoardType
     struct IfcElectricDistributionBoardType : IfcFlowControllerType, ObjectHelper<IfcElectricDistributionBoardType,1> { IfcElectricDistributionBoardType() : Object("IfcElectricDistributionBoardType") {}
 		IfcElectricDistributionBoardTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcFlowStorageDevice
     struct IfcFlowStorageDevice : IfcDistributionFlowElement, ObjectHelper<IfcFlowStorageDevice,0> { IfcFlowStorageDevice() : Object("IfcFlowStorageDevice") {}
 
     };
 
     // C++ wrapper for IfcElectricFlowStorageDevice
     struct IfcElectricFlowStorageDevice : IfcFlowStorageDevice, ObjectHelper<IfcElectricFlowStorageDevice,1> { IfcElectricFlowStorageDevice() : Object("IfcElectricFlowStorageDevice") {}
 		Maybe< IfcElectricFlowStorageDeviceTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcFlowStorageDeviceType
     struct IfcFlowStorageDeviceType : IfcDistributionFlowElementType, ObjectHelper<IfcFlowStorageDeviceType,0> { IfcFlowStorageDeviceType() : Object("IfcFlowStorageDeviceType") {}
 
     };
 
     // C++ wrapper for IfcElectricFlowStorageDeviceType
     struct IfcElectricFlowStorageDeviceType : IfcFlowStorageDeviceType, ObjectHelper<IfcElectricFlowStorageDeviceType,1> { IfcElectricFlowStorageDeviceType() : Object("IfcElectricFlowStorageDeviceType") {}
 		IfcElectricFlowStorageDeviceTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcElectricGenerator
     struct IfcElectricGenerator : IfcEnergyConversionDevice, ObjectHelper<IfcElectricGenerator,1> { IfcElectricGenerator() : Object("IfcElectricGenerator") {}
 		Maybe< IfcElectricGeneratorTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcElectricGeneratorType
     struct IfcElectricGeneratorType : IfcEnergyConversionDeviceType, ObjectHelper<IfcElectricGeneratorType,1> { IfcElectricGeneratorType() : Object("IfcElectricGeneratorType") {}
 		IfcElectricGeneratorTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcElectricMotor
     struct IfcElectricMotor : IfcEnergyConversionDevice, ObjectHelper<IfcElectricMotor,1> { IfcElectricMotor() : Object("IfcElectricMotor") {}
 		Maybe< IfcElectricMotorTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcElectricMotorType
     struct IfcElectricMotorType : IfcEnergyConversionDeviceType, ObjectHelper<IfcElectricMotorType,1> { IfcElectricMotorType() : Object("IfcElectricMotorType") {}
 		IfcElectricMotorTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcElectricTimeControl
     struct IfcElectricTimeControl : IfcFlowController, ObjectHelper<IfcElectricTimeControl,1> { IfcElectricTimeControl() : Object("IfcElectricTimeControl") {}
 		Maybe< IfcElectricTimeControlTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcElectricTimeControlType
     struct IfcElectricTimeControlType : IfcFlowControllerType, ObjectHelper<IfcElectricTimeControlType,1> { IfcElectricTimeControlType() : Object("IfcElectricTimeControlType") {}
 		IfcElectricTimeControlTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcElementAssembly
     struct IfcElementAssembly : IfcElement, ObjectHelper<IfcElementAssembly,2> { IfcElementAssembly() : Object("IfcElementAssembly") {}
 		Maybe< IfcAssemblyPlaceEnum::Out > AssemblyPlace;
 		Maybe< IfcElementAssemblyTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcElementAssemblyType
     struct IfcElementAssemblyType : IfcElementType, ObjectHelper<IfcElementAssemblyType,1> { IfcElementAssemblyType() : Object("IfcElementAssemblyType") {}
 		IfcElementAssemblyTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcQuantitySet
     struct IfcQuantitySet : IfcPropertySetDefinition, ObjectHelper<IfcQuantitySet,0> { IfcQuantitySet() : Object("IfcQuantitySet") {}
 
     };
 
     // C++ wrapper for IfcElementQuantity
     struct IfcElementQuantity : IfcQuantitySet, ObjectHelper<IfcElementQuantity,2> { IfcElementQuantity() : Object("IfcElementQuantity") {}
 		Maybe< IfcLabel::Out > MethodOfMeasurement;
 		ListOf< Lazy< NotImplemented >, 1, 0 > Quantities;
     };
 
     // C++ wrapper for IfcEllipse
     struct IfcEllipse : IfcConic, ObjectHelper<IfcEllipse,2> { IfcEllipse() : Object("IfcEllipse") {}
 		IfcPositiveLengthMeasure::Out SemiAxis1;
 		IfcPositiveLengthMeasure::Out SemiAxis2;
     };
 
     // C++ wrapper for IfcEllipseProfileDef
     struct IfcEllipseProfileDef : IfcParameterizedProfileDef, ObjectHelper<IfcEllipseProfileDef,2> { IfcEllipseProfileDef() : Object("IfcEllipseProfileDef") {}
 		IfcPositiveLengthMeasure::Out SemiAxis1;
 		IfcPositiveLengthMeasure::Out SemiAxis2;
     };
 
     // C++ wrapper for IfcEngine
     struct IfcEngine : IfcEnergyConversionDevice, ObjectHelper<IfcEngine,1> { IfcEngine() : Object("IfcEngine") {}
 		Maybe< IfcEngineTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcEngineType
     struct IfcEngineType : IfcEnergyConversionDeviceType, ObjectHelper<IfcEngineType,1> { IfcEngineType() : Object("IfcEngineType") {}
 		IfcEngineTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcEvaporativeCooler
     struct IfcEvaporativeCooler : IfcEnergyConversionDevice, ObjectHelper<IfcEvaporativeCooler,1> { IfcEvaporativeCooler() : Object("IfcEvaporativeCooler") {}
 		Maybe< IfcEvaporativeCoolerTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcEvaporativeCoolerType
     struct IfcEvaporativeCoolerType : IfcEnergyConversionDeviceType, ObjectHelper<IfcEvaporativeCoolerType,1> { IfcEvaporativeCoolerType() : Object("IfcEvaporativeCoolerType") {}
 		IfcEvaporativeCoolerTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcEvaporator
     struct IfcEvaporator : IfcEnergyConversionDevice, ObjectHelper<IfcEvaporator,1> { IfcEvaporator() : Object("IfcEvaporator") {}
 		Maybe< IfcEvaporatorTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcEvaporatorType
     struct IfcEvaporatorType : IfcEnergyConversionDeviceType, ObjectHelper<IfcEvaporatorType,1> { IfcEvaporatorType() : Object("IfcEvaporatorType") {}
 		IfcEvaporatorTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcProcess
     struct IfcProcess : IfcObject, ObjectHelper<IfcProcess,2> { IfcProcess() : Object("IfcProcess") {}
 		Maybe< IfcIdentifier::Out > Identification;
 		Maybe< IfcText::Out > LongDescription;
     };
 
     // C++ wrapper for IfcEvent
     struct IfcEvent : IfcProcess, ObjectHelper<IfcEvent,4> { IfcEvent() : Object("IfcEvent") {}
 		Maybe< IfcEventTypeEnum::Out > PredefinedType;
 		Maybe< IfcEventTriggerTypeEnum::Out > EventTriggerType;
 		Maybe< IfcLabel::Out > UserDefinedEventTriggerType;
 		Maybe< Lazy< NotImplemented > > EventOccurenceTime;
     };
 
     // C++ wrapper for IfcTypeProcess
     struct IfcTypeProcess : IfcTypeObject, ObjectHelper<IfcTypeProcess,3> { IfcTypeProcess() : Object("IfcTypeProcess") {}
 		Maybe< IfcIdentifier::Out > Identification;
 		Maybe< IfcText::Out > LongDescription;
 		Maybe< IfcLabel::Out > ProcessType;
     };
 
     // C++ wrapper for IfcEventType
     struct IfcEventType : IfcTypeProcess, ObjectHelper<IfcEventType,3> { IfcEventType() : Object("IfcEventType") {}
 		IfcEventTypeEnum::Out PredefinedType;
 		IfcEventTriggerTypeEnum::Out EventTriggerType;
 		Maybe< IfcLabel::Out > UserDefinedEventTriggerType;
     };
 
     // C++ wrapper for IfcExternalSpatialStructureElement
     struct IfcExternalSpatialStructureElement : IfcSpatialElement, ObjectHelper<IfcExternalSpatialStructureElement,0> { IfcExternalSpatialStructureElement() : Object("IfcExternalSpatialStructureElement") {}
 
     };
 
     // C++ wrapper for IfcExternalSpatialElement
     struct IfcExternalSpatialElement : IfcExternalSpatialStructureElement, ObjectHelper<IfcExternalSpatialElement,1> { IfcExternalSpatialElement() : Object("IfcExternalSpatialElement") {}
 		Maybe< IfcExternalSpatialElementTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcSweptAreaSolid
     struct IfcSweptAreaSolid : IfcSolidModel, ObjectHelper<IfcSweptAreaSolid,2> { IfcSweptAreaSolid() : Object("IfcSweptAreaSolid") {}
 		Lazy< IfcProfileDef > SweptArea;
 		Maybe< Lazy< IfcAxis2Placement3D > > Position;
     };
 
     // C++ wrapper for IfcExtrudedAreaSolid
     struct IfcExtrudedAreaSolid : IfcSweptAreaSolid, ObjectHelper<IfcExtrudedAreaSolid,2> { IfcExtrudedAreaSolid() : Object("IfcExtrudedAreaSolid") {}
 		Lazy< IfcDirection > ExtrudedDirection;
 		IfcPositiveLengthMeasure::Out Depth;
     };
 
     // C++ wrapper for IfcExtrudedAreaSolidTapered
     struct IfcExtrudedAreaSolidTapered : IfcExtrudedAreaSolid, ObjectHelper<IfcExtrudedAreaSolidTapered,1> { IfcExtrudedAreaSolidTapered() : Object("IfcExtrudedAreaSolidTapered") {}
 		Lazy< IfcProfileDef > EndSweptArea;
     };
 
     // C++ wrapper for IfcFaceBasedSurfaceModel
     struct IfcFaceBasedSurfaceModel : IfcGeometricRepresentationItem, ObjectHelper<IfcFaceBasedSurfaceModel,1> { IfcFaceBasedSurfaceModel() : Object("IfcFaceBasedSurfaceModel") {}
 		ListOf< Lazy< IfcConnectedFaceSet >, 1, 0 > FbsmFaces;
     };
 
     // C++ wrapper for IfcFaceBound
     struct IfcFaceBound : IfcTopologicalRepresentationItem, ObjectHelper<IfcFaceBound,2> { IfcFaceBound() : Object("IfcFaceBound") {}
 		Lazy< IfcLoop > Bound;
 		IfcBoolean::Out Orientation;
     };
 
     // C++ wrapper for IfcFaceOuterBound
     struct IfcFaceOuterBound : IfcFaceBound, ObjectHelper<IfcFaceOuterBound,0> { IfcFaceOuterBound() : Object("IfcFaceOuterBound") {}
 
     };
 
     // C++ wrapper for IfcFacetedBrep
     struct IfcFacetedBrep : IfcManifoldSolidBrep, ObjectHelper<IfcFacetedBrep,0> { IfcFacetedBrep() : Object("IfcFacetedBrep") {}
 
     };
 
     // C++ wrapper for IfcFacetedBrepWithVoids
     struct IfcFacetedBrepWithVoids : IfcFacetedBrep, ObjectHelper<IfcFacetedBrepWithVoids,1> { IfcFacetedBrepWithVoids() : Object("IfcFacetedBrepWithVoids") {}
 		ListOf< Lazy< IfcClosedShell >, 1, 0 > Voids;
     };
 
     // C++ wrapper for IfcFan
     struct IfcFan : IfcFlowMovingDevice, ObjectHelper<IfcFan,1> { IfcFan() : Object("IfcFan") {}
 		Maybe< IfcFanTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcFanType
     struct IfcFanType : IfcFlowMovingDeviceType, ObjectHelper<IfcFanType,1> { IfcFanType() : Object("IfcFanType") {}
 		IfcFanTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcFastener
     struct IfcFastener : IfcElementComponent, ObjectHelper<IfcFastener,1> { IfcFastener() : Object("IfcFastener") {}
 		Maybe< IfcFastenerTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcFastenerType
     struct IfcFastenerType : IfcElementComponentType, ObjectHelper<IfcFastenerType,1> { IfcFastenerType() : Object("IfcFastenerType") {}
 		IfcFastenerTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcFeatureElement
     struct IfcFeatureElement : IfcElement, ObjectHelper<IfcFeatureElement,0> { IfcFeatureElement() : Object("IfcFeatureElement") {}
 
     };
 
     // C++ wrapper for IfcFeatureElementAddition
     struct IfcFeatureElementAddition : IfcFeatureElement, ObjectHelper<IfcFeatureElementAddition,0> { IfcFeatureElementAddition() : Object("IfcFeatureElementAddition") {}
 
     };
 
     // C++ wrapper for IfcFeatureElementSubtraction
     struct IfcFeatureElementSubtraction : IfcFeatureElement, ObjectHelper<IfcFeatureElementSubtraction,0> { IfcFeatureElementSubtraction() : Object("IfcFeatureElementSubtraction") {}
 
     };
 
     // C++ wrapper for IfcFillAreaStyleHatching
     struct IfcFillAreaStyleHatching : IfcGeometricRepresentationItem, ObjectHelper<IfcFillAreaStyleHatching,5> { IfcFillAreaStyleHatching() : Object("IfcFillAreaStyleHatching") {}
 		Lazy< NotImplemented > HatchLineAppearance;
 		IfcHatchLineDistanceSelect::Out StartOfNextHatchLine;
 		Maybe< Lazy< IfcCartesianPoint > > PointOfReferenceHatchLine;
 		Maybe< Lazy< IfcCartesianPoint > > PatternStart;
 		IfcPlaneAngleMeasure::Out HatchLineAngle;
     };
 
     // C++ wrapper for IfcFillAreaStyleTiles
     struct IfcFillAreaStyleTiles : IfcGeometricRepresentationItem, ObjectHelper<IfcFillAreaStyleTiles,3> { IfcFillAreaStyleTiles() : Object("IfcFillAreaStyleTiles") {}
 		ListOf< Lazy< IfcVector >, 2, 2 > TilingPattern;
 		ListOf< Lazy< IfcStyledItem >, 1, 0 > Tiles;
 		IfcPositiveRatioMeasure::Out TilingScale;
     };
 
     // C++ wrapper for IfcFilter
     struct IfcFilter : IfcFlowTreatmentDevice, ObjectHelper<IfcFilter,1> { IfcFilter() : Object("IfcFilter") {}
 		Maybe< IfcFilterTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcFilterType
     struct IfcFilterType : IfcFlowTreatmentDeviceType, ObjectHelper<IfcFilterType,1> { IfcFilterType() : Object("IfcFilterType") {}
 		IfcFilterTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcFireSuppressionTerminal
     struct IfcFireSuppressionTerminal : IfcFlowTerminal, ObjectHelper<IfcFireSuppressionTerminal,1> { IfcFireSuppressionTerminal() : Object("IfcFireSuppressionTerminal") {}
 		Maybe< IfcFireSuppressionTerminalTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcFireSuppressionTerminalType
     struct IfcFireSuppressionTerminalType : IfcFlowTerminalType, ObjectHelper<IfcFireSuppressionTerminalType,1> { IfcFireSuppressionTerminalType() : Object("IfcFireSuppressionTerminalType") {}
 		IfcFireSuppressionTerminalTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcFixedReferenceSweptAreaSolid
     struct IfcFixedReferenceSweptAreaSolid : IfcSweptAreaSolid, ObjectHelper<IfcFixedReferenceSweptAreaSolid,4> { IfcFixedReferenceSweptAreaSolid() : Object("IfcFixedReferenceSweptAreaSolid") {}
 		Lazy< IfcCurve > Directrix;
 		Maybe< IfcParameterValue::Out > StartParam;
 		Maybe< IfcParameterValue::Out > EndParam;
 		Lazy< IfcDirection > FixedReference;
     };
 
     // C++ wrapper for IfcFlowInstrument
     struct IfcFlowInstrument : IfcDistributionControlElement, ObjectHelper<IfcFlowInstrument,1> { IfcFlowInstrument() : Object("IfcFlowInstrument") {}
 		Maybe< IfcFlowInstrumentTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcFlowInstrumentType
     struct IfcFlowInstrumentType : IfcDistributionControlElementType, ObjectHelper<IfcFlowInstrumentType,1> { IfcFlowInstrumentType() : Object("IfcFlowInstrumentType") {}
 		IfcFlowInstrumentTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcFlowMeter
     struct IfcFlowMeter : IfcFlowController, ObjectHelper<IfcFlowMeter,1> { IfcFlowMeter() : Object("IfcFlowMeter") {}
 		Maybe< IfcFlowMeterTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcFlowMeterType
     struct IfcFlowMeterType : IfcFlowControllerType, ObjectHelper<IfcFlowMeterType,1> { IfcFlowMeterType() : Object("IfcFlowMeterType") {}
 		IfcFlowMeterTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcFooting
     struct IfcFooting : IfcBuildingElement, ObjectHelper<IfcFooting,1> { IfcFooting() : Object("IfcFooting") {}
 		Maybe< IfcFootingTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcFootingType
     struct IfcFootingType : IfcBuildingElementType, ObjectHelper<IfcFootingType,1> { IfcFootingType() : Object("IfcFootingType") {}
 		IfcFootingTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcFurnishingElement
     struct IfcFurnishingElement : IfcElement, ObjectHelper<IfcFurnishingElement,0> { IfcFurnishingElement() : Object("IfcFurnishingElement") {}
 
     };
 
     // C++ wrapper for IfcFurnishingElementType
     struct IfcFurnishingElementType : IfcElementType, ObjectHelper<IfcFurnishingElementType,0> { IfcFurnishingElementType() : Object("IfcFurnishingElementType") {}
 
     };
 
     // C++ wrapper for IfcFurniture
     struct IfcFurniture : IfcFurnishingElement, ObjectHelper<IfcFurniture,1> { IfcFurniture() : Object("IfcFurniture") {}
 		Maybe< IfcFurnitureTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcFurnitureType
     struct IfcFurnitureType : IfcFurnishingElementType, ObjectHelper<IfcFurnitureType,2> { IfcFurnitureType() : Object("IfcFurnitureType") {}
 		IfcAssemblyPlaceEnum::Out AssemblyPlace;
 		Maybe< IfcFurnitureTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcGeographicElement
     struct IfcGeographicElement : IfcElement, ObjectHelper<IfcGeographicElement,1> { IfcGeographicElement() : Object("IfcGeographicElement") {}
 		Maybe< IfcGeographicElementTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcGeographicElementType
     struct IfcGeographicElementType : IfcElementType, ObjectHelper<IfcGeographicElementType,1> { IfcGeographicElementType() : Object("IfcGeographicElementType") {}
 		IfcGeographicElementTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcGeometricSet
     struct IfcGeometricSet : IfcGeometricRepresentationItem, ObjectHelper<IfcGeometricSet,1> { IfcGeometricSet() : Object("IfcGeometricSet") {}
 		ListOf< IfcGeometricSetSelect, 1, 0 >::Out Elements;
     };
 
     // C++ wrapper for IfcGeometricCurveSet
     struct IfcGeometricCurveSet : IfcGeometricSet, ObjectHelper<IfcGeometricCurveSet,0> { IfcGeometricCurveSet() : Object("IfcGeometricCurveSet") {}
 
     };
 
     // C++ wrapper for IfcRepresentationContext
     struct IfcRepresentationContext :  ObjectHelper<IfcRepresentationContext,2> { IfcRepresentationContext() : Object("IfcRepresentationContext") {}
 		Maybe< IfcLabel::Out > ContextIdentifier;
 		Maybe< IfcLabel::Out > ContextType;
     };
 
     // C++ wrapper for IfcGeometricRepresentationContext
     struct IfcGeometricRepresentationContext : IfcRepresentationContext, ObjectHelper<IfcGeometricRepresentationContext,4> { IfcGeometricRepresentationContext() : Object("IfcGeometricRepresentationContext") {}
 		IfcDimensionCount::Out CoordinateSpaceDimension;
 		Maybe< IfcReal::Out > Precision;
 		IfcAxis2Placement::Out WorldCoordinateSystem;
 		Maybe< Lazy< IfcDirection > > TrueNorth;
     };
 
     // C++ wrapper for IfcGeometricRepresentationSubContext
     struct IfcGeometricRepresentationSubContext : IfcGeometricRepresentationContext, ObjectHelper<IfcGeometricRepresentationSubContext,4> { IfcGeometricRepresentationSubContext() : Object("IfcGeometricRepresentationSubContext") {}
 		Lazy< IfcGeometricRepresentationContext > ParentContext;
 		Maybe< IfcPositiveRatioMeasure::Out > TargetScale;
 		IfcGeometricProjectionEnum::Out TargetView;
 		Maybe< IfcLabel::Out > UserDefinedTargetView;
     };
 
     // C++ wrapper for IfcGrid
     struct IfcGrid : IfcProduct, ObjectHelper<IfcGrid,4> { IfcGrid() : Object("IfcGrid") {}
 		ListOf< Lazy< NotImplemented >, 1, 0 > UAxes;
 		ListOf< Lazy< NotImplemented >, 1, 0 > VAxes;
 		Maybe< ListOf< Lazy< NotImplemented >, 1, 0 > > WAxes;
 		Maybe< IfcGridTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcObjectPlacement
     struct IfcObjectPlacement :  ObjectHelper<IfcObjectPlacement,0> { IfcObjectPlacement() : Object("IfcObjectPlacement") {}
 
     };
 
     // C++ wrapper for IfcGridPlacement
     struct IfcGridPlacement : IfcObjectPlacement, ObjectHelper<IfcGridPlacement,2> { IfcGridPlacement() : Object("IfcGridPlacement") {}
 		Lazy< NotImplemented > PlacementLocation;
 		Maybe< IfcGridPlacementDirectionSelect::Out > PlacementRefDirection;
     };
 
     // C++ wrapper for IfcHeatExchanger
     struct IfcHeatExchanger : IfcEnergyConversionDevice, ObjectHelper<IfcHeatExchanger,1> { IfcHeatExchanger() : Object("IfcHeatExchanger") {}
 		Maybe< IfcHeatExchangerTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcHeatExchangerType
     struct IfcHeatExchangerType : IfcEnergyConversionDeviceType, ObjectHelper<IfcHeatExchangerType,1> { IfcHeatExchangerType() : Object("IfcHeatExchangerType") {}
 		IfcHeatExchangerTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcHumidifier
     struct IfcHumidifier : IfcEnergyConversionDevice, ObjectHelper<IfcHumidifier,1> { IfcHumidifier() : Object("IfcHumidifier") {}
 		Maybe< IfcHumidifierTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcHumidifierType
     struct IfcHumidifierType : IfcEnergyConversionDeviceType, ObjectHelper<IfcHumidifierType,1> { IfcHumidifierType() : Object("IfcHumidifierType") {}
 		IfcHumidifierTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcIShapeProfileDef
     struct IfcIShapeProfileDef : IfcParameterizedProfileDef, ObjectHelper<IfcIShapeProfileDef,7> { IfcIShapeProfileDef() : Object("IfcIShapeProfileDef") {}
 		IfcPositiveLengthMeasure::Out OverallWidth;
 		IfcPositiveLengthMeasure::Out OverallDepth;
 		IfcPositiveLengthMeasure::Out WebThickness;
 		IfcPositiveLengthMeasure::Out FlangeThickness;
 		Maybe< IfcNonNegativeLengthMeasure::Out > FilletRadius;
 		Maybe< IfcNonNegativeLengthMeasure::Out > FlangeEdgeRadius;
 		Maybe< IfcPlaneAngleMeasure::Out > FlangeSlope;
     };
 
     // C++ wrapper for IfcIndexedPolyCurve
     struct IfcIndexedPolyCurve : IfcBoundedCurve, ObjectHelper<IfcIndexedPolyCurve,3> { IfcIndexedPolyCurve() : Object("IfcIndexedPolyCurve") {}
 		Lazy< IfcCartesianPointList > Points;
 		Maybe< ListOf< IfcSegmentIndexSelect, 1, 0 >::Out > Segments;
 		Maybe< IfcBoolean::Out > SelfIntersect;
     };
 
     // C++ wrapper for IfcTessellatedItem
     struct IfcTessellatedItem : IfcGeometricRepresentationItem, ObjectHelper<IfcTessellatedItem,0> { IfcTessellatedItem() : Object("IfcTessellatedItem") {}
 
     };
 
     // C++ wrapper for IfcIndexedPolygonalFace
     struct IfcIndexedPolygonalFace : IfcTessellatedItem, ObjectHelper<IfcIndexedPolygonalFace,1> { IfcIndexedPolygonalFace() : Object("IfcIndexedPolygonalFace") {}
 		ListOf< IfcPositiveInteger, 3, 0 >::Out CoordIndex;
     };
 
     // C++ wrapper for IfcIndexedPolygonalFaceWithVoids
     struct IfcIndexedPolygonalFaceWithVoids : IfcIndexedPolygonalFace, ObjectHelper<IfcIndexedPolygonalFaceWithVoids,0> { IfcIndexedPolygonalFaceWithVoids() : Object("IfcIndexedPolygonalFaceWithVoids") {}
 
     };
 
     // C++ wrapper for IfcInterceptor
     struct IfcInterceptor : IfcFlowTreatmentDevice, ObjectHelper<IfcInterceptor,1> { IfcInterceptor() : Object("IfcInterceptor") {}
 		Maybe< IfcInterceptorTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcInterceptorType
     struct IfcInterceptorType : IfcFlowTreatmentDeviceType, ObjectHelper<IfcInterceptorType,1> { IfcInterceptorType() : Object("IfcInterceptorType") {}
 		IfcInterceptorTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcSurfaceCurve
     struct IfcSurfaceCurve : IfcCurve, ObjectHelper<IfcSurfaceCurve,3> { IfcSurfaceCurve() : Object("IfcSurfaceCurve") {}
 		Lazy< IfcCurve > Curve3D;
 		ListOf< Lazy< IfcPcurve >, 1, 2 > AssociatedGeometry;
 		IfcPreferredSurfaceCurveRepresentation::Out MasterRepresentation;
     };
 
     // C++ wrapper for IfcIntersectionCurve
     struct IfcIntersectionCurve : IfcSurfaceCurve, ObjectHelper<IfcIntersectionCurve,0> { IfcIntersectionCurve() : Object("IfcIntersectionCurve") {}
 
     };
 
     // C++ wrapper for IfcInventory
     struct IfcInventory : IfcGroup, ObjectHelper<IfcInventory,6> { IfcInventory() : Object("IfcInventory") {}
 		Maybe< IfcInventoryTypeEnum::Out > PredefinedType;
 		Maybe< IfcActorSelect::Out > Jurisdiction;
 		Maybe< ListOf< Lazy< NotImplemented >, 1, 0 > > ResponsiblePersons;
 		Maybe< IfcDate::Out > LastUpdateDate;
 		Maybe< Lazy< NotImplemented > > CurrentValue;
 		Maybe< Lazy< NotImplemented > > OriginalValue;
     };
 
     // C++ wrapper for IfcJunctionBox
     struct IfcJunctionBox : IfcFlowFitting, ObjectHelper<IfcJunctionBox,1> { IfcJunctionBox() : Object("IfcJunctionBox") {}
 		Maybe< IfcJunctionBoxTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcJunctionBoxType
     struct IfcJunctionBoxType : IfcFlowFittingType, ObjectHelper<IfcJunctionBoxType,1> { IfcJunctionBoxType() : Object("IfcJunctionBoxType") {}
 		IfcJunctionBoxTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcLShapeProfileDef
     struct IfcLShapeProfileDef : IfcParameterizedProfileDef, ObjectHelper<IfcLShapeProfileDef,6> { IfcLShapeProfileDef() : Object("IfcLShapeProfileDef") {}
 		IfcPositiveLengthMeasure::Out Depth;
 		Maybe< IfcPositiveLengthMeasure::Out > Width;
 		IfcPositiveLengthMeasure::Out Thickness;
 		Maybe< IfcNonNegativeLengthMeasure::Out > FilletRadius;
 		Maybe< IfcNonNegativeLengthMeasure::Out > EdgeRadius;
 		Maybe< IfcPlaneAngleMeasure::Out > LegSlope;
     };
 
     // C++ wrapper for IfcLaborResource
     struct IfcLaborResource : IfcConstructionResource, ObjectHelper<IfcLaborResource,1> { IfcLaborResource() : Object("IfcLaborResource") {}
 		Maybe< IfcLaborResourceTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcLaborResourceType
     struct IfcLaborResourceType : IfcConstructionResourceType, ObjectHelper<IfcLaborResourceType,1> { IfcLaborResourceType() : Object("IfcLaborResourceType") {}
 		IfcLaborResourceTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcLamp
     struct IfcLamp : IfcFlowTerminal, ObjectHelper<IfcLamp,1> { IfcLamp() : Object("IfcLamp") {}
 		Maybe< IfcLampTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcLampType
     struct IfcLampType : IfcFlowTerminalType, ObjectHelper<IfcLampType,1> { IfcLampType() : Object("IfcLampType") {}
 		IfcLampTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcLightFixture
     struct IfcLightFixture : IfcFlowTerminal, ObjectHelper<IfcLightFixture,1> { IfcLightFixture() : Object("IfcLightFixture") {}
 		Maybe< IfcLightFixtureTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcLightFixtureType
     struct IfcLightFixtureType : IfcFlowTerminalType, ObjectHelper<IfcLightFixtureType,1> { IfcLightFixtureType() : Object("IfcLightFixtureType") {}
 		IfcLightFixtureTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcLightSource
     struct IfcLightSource : IfcGeometricRepresentationItem, ObjectHelper<IfcLightSource,4> { IfcLightSource() : Object("IfcLightSource") {}
 		Maybe< IfcLabel::Out > Name;
 		Lazy< IfcColourRgb > LightColour;
 		Maybe< IfcNormalisedRatioMeasure::Out > AmbientIntensity;
 		Maybe< IfcNormalisedRatioMeasure::Out > Intensity;
     };
 
     // C++ wrapper for IfcLightSourceAmbient
     struct IfcLightSourceAmbient : IfcLightSource, ObjectHelper<IfcLightSourceAmbient,0> { IfcLightSourceAmbient() : Object("IfcLightSourceAmbient") {}
 
     };
 
     // C++ wrapper for IfcLightSourceDirectional
     struct IfcLightSourceDirectional : IfcLightSource, ObjectHelper<IfcLightSourceDirectional,1> { IfcLightSourceDirectional() : Object("IfcLightSourceDirectional") {}
 		Lazy< IfcDirection > Orientation;
     };
 
     // C++ wrapper for IfcLightSourceGoniometric
     struct IfcLightSourceGoniometric : IfcLightSource, ObjectHelper<IfcLightSourceGoniometric,6> { IfcLightSourceGoniometric() : Object("IfcLightSourceGoniometric") {}
 		Lazy< IfcAxis2Placement3D > Position;
 		Maybe< Lazy< IfcColourRgb > > ColourAppearance;
 		IfcThermodynamicTemperatureMeasure::Out ColourTemperature;
 		IfcLuminousFluxMeasure::Out LuminousFlux;
 		IfcLightEmissionSourceEnum::Out LightEmissionSource;
 		IfcLightDistributionDataSourceSelect::Out LightDistributionDataSource;
     };
 
     // C++ wrapper for IfcLightSourcePositional
     struct IfcLightSourcePositional : IfcLightSource, ObjectHelper<IfcLightSourcePositional,5> { IfcLightSourcePositional() : Object("IfcLightSourcePositional") {}
 		Lazy< IfcCartesianPoint > Position;
 		IfcPositiveLengthMeasure::Out Radius;
 		IfcReal::Out ConstantAttenuation;
 		IfcReal::Out DistanceAttenuation;
 		IfcReal::Out QuadricAttenuation;
     };
 
     // C++ wrapper for IfcLightSourceSpot
     struct IfcLightSourceSpot : IfcLightSourcePositional, ObjectHelper<IfcLightSourceSpot,4> { IfcLightSourceSpot() : Object("IfcLightSourceSpot") {}
 		Lazy< IfcDirection > Orientation;
 		Maybe< IfcReal::Out > ConcentrationExponent;
 		IfcPositivePlaneAngleMeasure::Out SpreadAngle;
 		IfcPositivePlaneAngleMeasure::Out BeamWidthAngle;
     };
 
     // C++ wrapper for IfcLine
     struct IfcLine : IfcCurve, ObjectHelper<IfcLine,2> { IfcLine() : Object("IfcLine") {}
 		Lazy< IfcCartesianPoint > Pnt;
 		Lazy< IfcVector > Dir;
     };
 
     // C++ wrapper for IfcLocalPlacement
     struct IfcLocalPlacement : IfcObjectPlacement, ObjectHelper<IfcLocalPlacement,2> { IfcLocalPlacement() : Object("IfcLocalPlacement") {}
 		Maybe< Lazy< IfcObjectPlacement > > PlacementRelTo;
 		IfcAxis2Placement::Out RelativePlacement;
     };
 
     // C++ wrapper for IfcMappedItem
     struct IfcMappedItem : IfcRepresentationItem, ObjectHelper<IfcMappedItem,2> { IfcMappedItem() : Object("IfcMappedItem") {}
 		Lazy< IfcRepresentationMap > MappingSource;
 		Lazy< IfcCartesianTransformationOperator > MappingTarget;
     };
 
     // C++ wrapper for IfcProductRepresentation
     struct IfcProductRepresentation :  ObjectHelper<IfcProductRepresentation,3> { IfcProductRepresentation() : Object("IfcProductRepresentation") {}
 		Maybe< IfcLabel::Out > Name;
 		Maybe< IfcText::Out > Description;
 		ListOf< Lazy< IfcRepresentation >, 1, 0 > Representations;
     };
 
     // C++ wrapper for IfcMaterialDefinitionRepresentation
     struct IfcMaterialDefinitionRepresentation : IfcProductRepresentation, ObjectHelper<IfcMaterialDefinitionRepresentation,1> { IfcMaterialDefinitionRepresentation() : Object("IfcMaterialDefinitionRepresentation") {}
 		Lazy< NotImplemented > RepresentedMaterial;
     };
 
     // C++ wrapper for IfcMeasureWithUnit
     struct IfcMeasureWithUnit :  ObjectHelper<IfcMeasureWithUnit,2> { IfcMeasureWithUnit() : Object("IfcMeasureWithUnit") {}
 		IfcValue::Out ValueComponent;
 		IfcUnit::Out UnitComponent;
     };
 
     // C++ wrapper for IfcMechanicalFastener
     struct IfcMechanicalFastener : IfcElementComponent, ObjectHelper<IfcMechanicalFastener,3> { IfcMechanicalFastener() : Object("IfcMechanicalFastener") {}
 		Maybe< IfcPositiveLengthMeasure::Out > NominalDiameter;
 		Maybe< IfcPositiveLengthMeasure::Out > NominalLength;
 		Maybe< IfcMechanicalFastenerTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcMechanicalFastenerType
     struct IfcMechanicalFastenerType : IfcElementComponentType, ObjectHelper<IfcMechanicalFastenerType,3> { IfcMechanicalFastenerType() : Object("IfcMechanicalFastenerType") {}
 		IfcMechanicalFastenerTypeEnum::Out PredefinedType;
 		Maybe< IfcPositiveLengthMeasure::Out > NominalDiameter;
 		Maybe< IfcPositiveLengthMeasure::Out > NominalLength;
     };
 
     // C++ wrapper for IfcMedicalDevice
     struct IfcMedicalDevice : IfcFlowTerminal, ObjectHelper<IfcMedicalDevice,1> { IfcMedicalDevice() : Object("IfcMedicalDevice") {}
 		Maybe< IfcMedicalDeviceTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcMedicalDeviceType
     struct IfcMedicalDeviceType : IfcFlowTerminalType, ObjectHelper<IfcMedicalDeviceType,1> { IfcMedicalDeviceType() : Object("IfcMedicalDeviceType") {}
 		IfcMedicalDeviceTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcMember
     struct IfcMember : IfcBuildingElement, ObjectHelper<IfcMember,1> { IfcMember() : Object("IfcMember") {}
 		Maybe< IfcMemberTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcMemberStandardCase
     struct IfcMemberStandardCase : IfcMember, ObjectHelper<IfcMemberStandardCase,0> { IfcMemberStandardCase() : Object("IfcMemberStandardCase") {}
 
     };
 
     // C++ wrapper for IfcMemberType
     struct IfcMemberType : IfcBuildingElementType, ObjectHelper<IfcMemberType,1> { IfcMemberType() : Object("IfcMemberType") {}
 		IfcMemberTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcMirroredProfileDef
     struct IfcMirroredProfileDef : IfcDerivedProfileDef, ObjectHelper<IfcMirroredProfileDef,0> { IfcMirroredProfileDef() : Object("IfcMirroredProfileDef") {}
 
     };
 
     // C++ wrapper for IfcMotorConnection
     struct IfcMotorConnection : IfcEnergyConversionDevice, ObjectHelper<IfcMotorConnection,1> { IfcMotorConnection() : Object("IfcMotorConnection") {}
 		Maybe< IfcMotorConnectionTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcMotorConnectionType
     struct IfcMotorConnectionType : IfcEnergyConversionDeviceType, ObjectHelper<IfcMotorConnectionType,1> { IfcMotorConnectionType() : Object("IfcMotorConnectionType") {}
 		IfcMotorConnectionTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcOccupant
     struct IfcOccupant : IfcActor, ObjectHelper<IfcOccupant,1> { IfcOccupant() : Object("IfcOccupant") {}
 		Maybe< IfcOccupantTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcOffsetCurve2D
     struct IfcOffsetCurve2D : IfcCurve, ObjectHelper<IfcOffsetCurve2D,3> { IfcOffsetCurve2D() : Object("IfcOffsetCurve2D") {}
 		Lazy< IfcCurve > BasisCurve;
 		IfcLengthMeasure::Out Distance;
 		IfcLogical::Out SelfIntersect;
     };
 
     // C++ wrapper for IfcOffsetCurve3D
     struct IfcOffsetCurve3D : IfcCurve, ObjectHelper<IfcOffsetCurve3D,4> { IfcOffsetCurve3D() : Object("IfcOffsetCurve3D") {}
 		Lazy< IfcCurve > BasisCurve;
 		IfcLengthMeasure::Out Distance;
 		IfcLogical::Out SelfIntersect;
 		Lazy< IfcDirection > RefDirection;
     };
 
     // C++ wrapper for IfcOpenShell
     struct IfcOpenShell : IfcConnectedFaceSet, ObjectHelper<IfcOpenShell,0> { IfcOpenShell() : Object("IfcOpenShell") {}
 
     };
 
     // C++ wrapper for IfcOpeningElement
     struct IfcOpeningElement : IfcFeatureElementSubtraction, ObjectHelper<IfcOpeningElement,1> { IfcOpeningElement() : Object("IfcOpeningElement") {}
 		Maybe< IfcOpeningElementTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcOpeningStandardCase
     struct IfcOpeningStandardCase : IfcOpeningElement, ObjectHelper<IfcOpeningStandardCase,0> { IfcOpeningStandardCase() : Object("IfcOpeningStandardCase") {}
 
     };
 
     // C++ wrapper for IfcOrientedEdge
     struct IfcOrientedEdge : IfcEdge, ObjectHelper<IfcOrientedEdge,2> { IfcOrientedEdge() : Object("IfcOrientedEdge") {}
 		Lazy< IfcEdge > EdgeElement;
 		IfcBoolean::Out Orientation;
     };
 
     // C++ wrapper for IfcOuterBoundaryCurve
     struct IfcOuterBoundaryCurve : IfcBoundaryCurve, ObjectHelper<IfcOuterBoundaryCurve,0> { IfcOuterBoundaryCurve() : Object("IfcOuterBoundaryCurve") {}
 
     };
 
     // C++ wrapper for IfcOutlet
     struct IfcOutlet : IfcFlowTerminal, ObjectHelper<IfcOutlet,1> { IfcOutlet() : Object("IfcOutlet") {}
 		Maybe< IfcOutletTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcOutletType
     struct IfcOutletType : IfcFlowTerminalType, ObjectHelper<IfcOutletType,1> { IfcOutletType() : Object("IfcOutletType") {}
 		IfcOutletTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcPath
     struct IfcPath : IfcTopologicalRepresentationItem, ObjectHelper<IfcPath,1> { IfcPath() : Object("IfcPath") {}
 		ListOf< Lazy< IfcOrientedEdge >, 1, 0 > EdgeList;
     };
 
     // C++ wrapper for IfcPcurve
     struct IfcPcurve : IfcCurve, ObjectHelper<IfcPcurve,2> { IfcPcurve() : Object("IfcPcurve") {}
 		Lazy< IfcSurface > BasisSurface;
 		Lazy< IfcCurve > ReferenceCurve;
     };
 
     // C++ wrapper for IfcPerformanceHistory
     struct IfcPerformanceHistory : IfcControl, ObjectHelper<IfcPerformanceHistory,2> { IfcPerformanceHistory() : Object("IfcPerformanceHistory") {}
 		IfcLabel::Out LifeCyclePhase;
 		Maybe< IfcPerformanceHistoryTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcPermit
     struct IfcPermit : IfcControl, ObjectHelper<IfcPermit,3> { IfcPermit() : Object("IfcPermit") {}
 		Maybe< IfcPermitTypeEnum::Out > PredefinedType;
 		Maybe< IfcLabel::Out > Status;
 		Maybe< IfcText::Out > LongDescription;
     };
 
     // C++ wrapper for IfcPile
     struct IfcPile : IfcBuildingElement, ObjectHelper<IfcPile,2> { IfcPile() : Object("IfcPile") {}
 		Maybe< IfcPileTypeEnum::Out > PredefinedType;
 		Maybe< IfcPileConstructionEnum::Out > ConstructionType;
     };
 
     // C++ wrapper for IfcPileType
     struct IfcPileType : IfcBuildingElementType, ObjectHelper<IfcPileType,1> { IfcPileType() : Object("IfcPileType") {}
 		IfcPileTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcPipeFitting
     struct IfcPipeFitting : IfcFlowFitting, ObjectHelper<IfcPipeFitting,1> { IfcPipeFitting() : Object("IfcPipeFitting") {}
 		Maybe< IfcPipeFittingTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcPipeFittingType
     struct IfcPipeFittingType : IfcFlowFittingType, ObjectHelper<IfcPipeFittingType,1> { IfcPipeFittingType() : Object("IfcPipeFittingType") {}
 		IfcPipeFittingTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcPipeSegment
     struct IfcPipeSegment : IfcFlowSegment, ObjectHelper<IfcPipeSegment,1> { IfcPipeSegment() : Object("IfcPipeSegment") {}
 		Maybe< IfcPipeSegmentTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcPipeSegmentType
     struct IfcPipeSegmentType : IfcFlowSegmentType, ObjectHelper<IfcPipeSegmentType,1> { IfcPipeSegmentType() : Object("IfcPipeSegmentType") {}
 		IfcPipeSegmentTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcPlanarExtent
     struct IfcPlanarExtent : IfcGeometricRepresentationItem, ObjectHelper<IfcPlanarExtent,2> { IfcPlanarExtent() : Object("IfcPlanarExtent") {}
 		IfcLengthMeasure::Out SizeInX;
 		IfcLengthMeasure::Out SizeInY;
     };
 
     // C++ wrapper for IfcPlanarBox
     struct IfcPlanarBox : IfcPlanarExtent, ObjectHelper<IfcPlanarBox,1> { IfcPlanarBox() : Object("IfcPlanarBox") {}
 		IfcAxis2Placement::Out Placement;
     };
 
     // C++ wrapper for IfcPlane
     struct IfcPlane : IfcElementarySurface, ObjectHelper<IfcPlane,0> { IfcPlane() : Object("IfcPlane") {}
 
     };
 
     // C++ wrapper for IfcPlate
     struct IfcPlate : IfcBuildingElement, ObjectHelper<IfcPlate,1> { IfcPlate() : Object("IfcPlate") {}
 		Maybe< IfcPlateTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcPlateStandardCase
     struct IfcPlateStandardCase : IfcPlate, ObjectHelper<IfcPlateStandardCase,0> { IfcPlateStandardCase() : Object("IfcPlateStandardCase") {}
 
     };
 
     // C++ wrapper for IfcPlateType
     struct IfcPlateType : IfcBuildingElementType, ObjectHelper<IfcPlateType,1> { IfcPlateType() : Object("IfcPlateType") {}
 		IfcPlateTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcPointOnCurve
     struct IfcPointOnCurve : IfcPoint, ObjectHelper<IfcPointOnCurve,2> { IfcPointOnCurve() : Object("IfcPointOnCurve") {}
 		Lazy< IfcCurve > BasisCurve;
 		IfcParameterValue::Out PointParameter;
     };
 
     // C++ wrapper for IfcPointOnSurface
     struct IfcPointOnSurface : IfcPoint, ObjectHelper<IfcPointOnSurface,3> { IfcPointOnSurface() : Object("IfcPointOnSurface") {}
 		Lazy< IfcSurface > BasisSurface;
 		IfcParameterValue::Out PointParameterU;
 		IfcParameterValue::Out PointParameterV;
     };
 
     // C++ wrapper for IfcPolyLoop
     struct IfcPolyLoop : IfcLoop, ObjectHelper<IfcPolyLoop,1> { IfcPolyLoop() : Object("IfcPolyLoop") {}
 		ListOf< Lazy< IfcCartesianPoint >, 3, 0 > Polygon;
     };
 
     // C++ wrapper for IfcPolygonalBoundedHalfSpace
     struct IfcPolygonalBoundedHalfSpace : IfcHalfSpaceSolid, ObjectHelper<IfcPolygonalBoundedHalfSpace,2> { IfcPolygonalBoundedHalfSpace() : Object("IfcPolygonalBoundedHalfSpace") {}
 		Lazy< IfcAxis2Placement3D > Position;
 		Lazy< IfcBoundedCurve > PolygonalBoundary;
     };
 
     // C++ wrapper for IfcTessellatedFaceSet
     struct IfcTessellatedFaceSet : IfcTessellatedItem, ObjectHelper<IfcTessellatedFaceSet,1> { IfcTessellatedFaceSet() : Object("IfcTessellatedFaceSet") {}
 		Lazy< IfcCartesianPointList3D > Coordinates;
     };
 
     // C++ wrapper for IfcPolygonalFaceSet
     struct IfcPolygonalFaceSet : IfcTessellatedFaceSet, ObjectHelper<IfcPolygonalFaceSet,3> { IfcPolygonalFaceSet() : Object("IfcPolygonalFaceSet") {}
 		Maybe< IfcBoolean::Out > Closed;
 		ListOf< Lazy< IfcIndexedPolygonalFace >, 1, 0 > Faces;
 		Maybe< ListOf< IfcPositiveInteger, 1, 0 >::Out > PnIndex;
     };
 
     // C++ wrapper for IfcPolyline
     struct IfcPolyline : IfcBoundedCurve, ObjectHelper<IfcPolyline,1> { IfcPolyline() : Object("IfcPolyline") {}
 		ListOf< Lazy< IfcCartesianPoint >, 2, 0 > Points;
     };
 
     // C++ wrapper for IfcPresentationStyleAssignment
     struct IfcPresentationStyleAssignment :  ObjectHelper<IfcPresentationStyleAssignment,1> { IfcPresentationStyleAssignment() : Object("IfcPresentationStyleAssignment") {}
 		ListOf< IfcPresentationStyleSelect, 1, 0 >::Out Styles;
     };
 
     // C++ wrapper for IfcProcedure
     struct IfcProcedure : IfcProcess, ObjectHelper<IfcProcedure,1> { IfcProcedure() : Object("IfcProcedure") {}
 		Maybe< IfcProcedureTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcProcedureType
     struct IfcProcedureType : IfcTypeProcess, ObjectHelper<IfcProcedureType,1> { IfcProcedureType() : Object("IfcProcedureType") {}
 		IfcProcedureTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcProductDefinitionShape
     struct IfcProductDefinitionShape : IfcProductRepresentation, ObjectHelper<IfcProductDefinitionShape,0> { IfcProductDefinitionShape() : Object("IfcProductDefinitionShape") {}
 
     };
 
     // C++ wrapper for IfcProject
     struct IfcProject : IfcContext, ObjectHelper<IfcProject,0> { IfcProject() : Object("IfcProject") {}
 
     };
 
     // C++ wrapper for IfcProjectLibrary
     struct IfcProjectLibrary : IfcContext, ObjectHelper<IfcProjectLibrary,0> { IfcProjectLibrary() : Object("IfcProjectLibrary") {}
 
     };
 
     // C++ wrapper for IfcProjectOrder
     struct IfcProjectOrder : IfcControl, ObjectHelper<IfcProjectOrder,3> { IfcProjectOrder() : Object("IfcProjectOrder") {}
 		Maybe< IfcProjectOrderTypeEnum::Out > PredefinedType;
 		Maybe< IfcLabel::Out > Status;
 		Maybe< IfcText::Out > LongDescription;
     };
 
     // C++ wrapper for IfcProjectionElement
     struct IfcProjectionElement : IfcFeatureElementAddition, ObjectHelper<IfcProjectionElement,1> { IfcProjectionElement() : Object("IfcProjectionElement") {}
 		Maybe< IfcProjectionElementTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcSimpleProperty
     struct IfcSimpleProperty : IfcProperty, ObjectHelper<IfcSimpleProperty,0> { IfcSimpleProperty() : Object("IfcSimpleProperty") {}
 
     };
 
     // C++ wrapper for IfcPropertyBoundedValue
     struct IfcPropertyBoundedValue : IfcSimpleProperty, ObjectHelper<IfcPropertyBoundedValue,4> { IfcPropertyBoundedValue() : Object("IfcPropertyBoundedValue") {}
 		Maybe< IfcValue::Out > UpperBoundValue;
 		Maybe< IfcValue::Out > LowerBoundValue;
 		Maybe< IfcUnit::Out > Unit;
 		Maybe< IfcValue::Out > SetPointValue;
     };
 
     // C++ wrapper for IfcPropertyEnumeratedValue
     struct IfcPropertyEnumeratedValue : IfcSimpleProperty, ObjectHelper<IfcPropertyEnumeratedValue,2> { IfcPropertyEnumeratedValue() : Object("IfcPropertyEnumeratedValue") {}
 		Maybe< ListOf< IfcValue, 1, 0 >::Out > EnumerationValues;
 		Maybe< Lazy< NotImplemented > > EnumerationReference;
     };
 
     // C++ wrapper for IfcPropertyListValue
     struct IfcPropertyListValue : IfcSimpleProperty, ObjectHelper<IfcPropertyListValue,2> { IfcPropertyListValue() : Object("IfcPropertyListValue") {}
 		Maybe< ListOf< IfcValue, 1, 0 >::Out > ListValues;
 		Maybe< IfcUnit::Out > Unit;
     };
 
     // C++ wrapper for IfcPropertyReferenceValue
     struct IfcPropertyReferenceValue : IfcSimpleProperty, ObjectHelper<IfcPropertyReferenceValue,2> { IfcPropertyReferenceValue() : Object("IfcPropertyReferenceValue") {}
 		Maybe< IfcText::Out > UsageName;
 		Maybe< IfcObjectReferenceSelect::Out > PropertyReference;
     };
 
     // C++ wrapper for IfcPropertySet
     struct IfcPropertySet : IfcPropertySetDefinition, ObjectHelper<IfcPropertySet,1> { IfcPropertySet() : Object("IfcPropertySet") {}
 		ListOf< Lazy< IfcProperty >, 1, 0 > HasProperties;
     };
 
     // C++ wrapper for IfcPropertySingleValue
     struct IfcPropertySingleValue : IfcSimpleProperty, ObjectHelper<IfcPropertySingleValue,2> { IfcPropertySingleValue() : Object("IfcPropertySingleValue") {}
 		Maybe< IfcValue::Out > NominalValue;
 		Maybe< IfcUnit::Out > Unit;
     };
 
     // C++ wrapper for IfcPropertyTableValue
     struct IfcPropertyTableValue : IfcSimpleProperty, ObjectHelper<IfcPropertyTableValue,6> { IfcPropertyTableValue() : Object("IfcPropertyTableValue") {}
 		Maybe< ListOf< IfcValue, 1, 0 >::Out > DefiningValues;
 		Maybe< ListOf< IfcValue, 1, 0 >::Out > DefinedValues;
 		Maybe< IfcText::Out > Expression;
 		Maybe< IfcUnit::Out > DefiningUnit;
 		Maybe< IfcUnit::Out > DefinedUnit;
 		Maybe< IfcCurveInterpolationEnum::Out > CurveInterpolation;
     };
 
     // C++ wrapper for IfcProtectiveDevice
     struct IfcProtectiveDevice : IfcFlowController, ObjectHelper<IfcProtectiveDevice,1> { IfcProtectiveDevice() : Object("IfcProtectiveDevice") {}
 		Maybe< IfcProtectiveDeviceTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcProtectiveDeviceTrippingUnit
     struct IfcProtectiveDeviceTrippingUnit : IfcDistributionControlElement, ObjectHelper<IfcProtectiveDeviceTrippingUnit,1> { IfcProtectiveDeviceTrippingUnit() : Object("IfcProtectiveDeviceTrippingUnit") {}
 		Maybe< IfcProtectiveDeviceTrippingUnitTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcProtectiveDeviceTrippingUnitType
     struct IfcProtectiveDeviceTrippingUnitType : IfcDistributionControlElementType, ObjectHelper<IfcProtectiveDeviceTrippingUnitType,1> { IfcProtectiveDeviceTrippingUnitType() : Object("IfcProtectiveDeviceTrippingUnitType") {}
 		IfcProtectiveDeviceTrippingUnitTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcProtectiveDeviceType
     struct IfcProtectiveDeviceType : IfcFlowControllerType, ObjectHelper<IfcProtectiveDeviceType,1> { IfcProtectiveDeviceType() : Object("IfcProtectiveDeviceType") {}
 		IfcProtectiveDeviceTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcProxy
     struct IfcProxy : IfcProduct, ObjectHelper<IfcProxy,2> { IfcProxy() : Object("IfcProxy") {}
 		IfcObjectTypeEnum::Out ProxyType;
 		Maybe< IfcLabel::Out > Tag;
     };
 
     // C++ wrapper for IfcPump
     struct IfcPump : IfcFlowMovingDevice, ObjectHelper<IfcPump,1> { IfcPump() : Object("IfcPump") {}
 		Maybe< IfcPumpTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcPumpType
     struct IfcPumpType : IfcFlowMovingDeviceType, ObjectHelper<IfcPumpType,1> { IfcPumpType() : Object("IfcPumpType") {}
 		IfcPumpTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcRailing
     struct IfcRailing : IfcBuildingElement, ObjectHelper<IfcRailing,1> { IfcRailing() : Object("IfcRailing") {}
 		Maybe< IfcRailingTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcRailingType
     struct IfcRailingType : IfcBuildingElementType, ObjectHelper<IfcRailingType,1> { IfcRailingType() : Object("IfcRailingType") {}
 		IfcRailingTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcRamp
     struct IfcRamp : IfcBuildingElement, ObjectHelper<IfcRamp,1> { IfcRamp() : Object("IfcRamp") {}
 		Maybe< IfcRampTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcRampFlight
     struct IfcRampFlight : IfcBuildingElement, ObjectHelper<IfcRampFlight,1> { IfcRampFlight() : Object("IfcRampFlight") {}
 		Maybe< IfcRampFlightTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcRampFlightType
     struct IfcRampFlightType : IfcBuildingElementType, ObjectHelper<IfcRampFlightType,1> { IfcRampFlightType() : Object("IfcRampFlightType") {}
 		IfcRampFlightTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcRampType
     struct IfcRampType : IfcBuildingElementType, ObjectHelper<IfcRampType,1> { IfcRampType() : Object("IfcRampType") {}
 		IfcRampTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcRationalBSplineCurveWithKnots
     struct IfcRationalBSplineCurveWithKnots : IfcBSplineCurveWithKnots, ObjectHelper<IfcRationalBSplineCurveWithKnots,1> { IfcRationalBSplineCurveWithKnots() : Object("IfcRationalBSplineCurveWithKnots") {}
 		ListOf< IfcReal, 2, 0 >::Out WeightsData;
     };
 
     // C++ wrapper for IfcRationalBSplineSurfaceWithKnots
     struct IfcRationalBSplineSurfaceWithKnots : IfcBSplineSurfaceWithKnots, ObjectHelper<IfcRationalBSplineSurfaceWithKnots,0> { IfcRationalBSplineSurfaceWithKnots() : Object("IfcRationalBSplineSurfaceWithKnots") {}
 
     };
 
     // C++ wrapper for IfcRectangleProfileDef
     struct IfcRectangleProfileDef : IfcParameterizedProfileDef, ObjectHelper<IfcRectangleProfileDef,2> { IfcRectangleProfileDef() : Object("IfcRectangleProfileDef") {}
 		IfcPositiveLengthMeasure::Out XDim;
 		IfcPositiveLengthMeasure::Out YDim;
     };
 
     // C++ wrapper for IfcRectangleHollowProfileDef
     struct IfcRectangleHollowProfileDef : IfcRectangleProfileDef, ObjectHelper<IfcRectangleHollowProfileDef,3> { IfcRectangleHollowProfileDef() : Object("IfcRectangleHollowProfileDef") {}
 		IfcPositiveLengthMeasure::Out WallThickness;
 		Maybe< IfcNonNegativeLengthMeasure::Out > InnerFilletRadius;
 		Maybe< IfcNonNegativeLengthMeasure::Out > OuterFilletRadius;
     };
 
     // C++ wrapper for IfcRectangularPyramid
     struct IfcRectangularPyramid : IfcCsgPrimitive3D, ObjectHelper<IfcRectangularPyramid,3> { IfcRectangularPyramid() : Object("IfcRectangularPyramid") {}
 		IfcPositiveLengthMeasure::Out XLength;
 		IfcPositiveLengthMeasure::Out YLength;
 		IfcPositiveLengthMeasure::Out Height;
     };
 
     // C++ wrapper for IfcRectangularTrimmedSurface
     struct IfcRectangularTrimmedSurface : IfcBoundedSurface, ObjectHelper<IfcRectangularTrimmedSurface,7> { IfcRectangularTrimmedSurface() : Object("IfcRectangularTrimmedSurface") {}
 		Lazy< IfcSurface > BasisSurface;
 		IfcParameterValue::Out U1;
 		IfcParameterValue::Out V1;
 		IfcParameterValue::Out U2;
 		IfcParameterValue::Out V2;
 		IfcBoolean::Out Usense;
 		IfcBoolean::Out Vsense;
     };
 
     // C++ wrapper for IfcReinforcingElement
     struct IfcReinforcingElement : IfcElementComponent, ObjectHelper<IfcReinforcingElement,1> { IfcReinforcingElement() : Object("IfcReinforcingElement") {}
 		Maybe< IfcLabel::Out > SteelGrade;
     };
 
     // C++ wrapper for IfcReinforcingBar
     struct IfcReinforcingBar : IfcReinforcingElement, ObjectHelper<IfcReinforcingBar,5> { IfcReinforcingBar() : Object("IfcReinforcingBar") {}
 		Maybe< IfcPositiveLengthMeasure::Out > NominalDiameter;
 		Maybe< IfcAreaMeasure::Out > CrossSectionArea;
 		Maybe< IfcPositiveLengthMeasure::Out > BarLength;
 		Maybe< IfcReinforcingBarTypeEnum::Out > PredefinedType;
 		Maybe< IfcReinforcingBarSurfaceEnum::Out > BarSurface;
     };
 
     // C++ wrapper for IfcReinforcingElementType
     struct IfcReinforcingElementType : IfcElementComponentType, ObjectHelper<IfcReinforcingElementType,0> { IfcReinforcingElementType() : Object("IfcReinforcingElementType") {}
 
     };
 
     // C++ wrapper for IfcReinforcingBarType
     struct IfcReinforcingBarType : IfcReinforcingElementType, ObjectHelper<IfcReinforcingBarType,7> { IfcReinforcingBarType() : Object("IfcReinforcingBarType") {}
 		IfcReinforcingBarTypeEnum::Out PredefinedType;
 		Maybe< IfcPositiveLengthMeasure::Out > NominalDiameter;
 		Maybe< IfcAreaMeasure::Out > CrossSectionArea;
 		Maybe< IfcPositiveLengthMeasure::Out > BarLength;
 		Maybe< IfcReinforcingBarSurfaceEnum::Out > BarSurface;
 		Maybe< IfcLabel::Out > BendingShapeCode;
 		Maybe< ListOf< IfcBendingParameterSelect, 1, 0 >::Out > BendingParameters;
     };
 
     // C++ wrapper for IfcReinforcingMesh
     struct IfcReinforcingMesh : IfcReinforcingElement, ObjectHelper<IfcReinforcingMesh,9> { IfcReinforcingMesh() : Object("IfcReinforcingMesh") {}
 		Maybe< IfcPositiveLengthMeasure::Out > MeshLength;
 		Maybe< IfcPositiveLengthMeasure::Out > MeshWidth;
 		Maybe< IfcPositiveLengthMeasure::Out > LongitudinalBarNominalDiameter;
 		Maybe< IfcPositiveLengthMeasure::Out > TransverseBarNominalDiameter;
 		Maybe< IfcAreaMeasure::Out > LongitudinalBarCrossSectionArea;
 		Maybe< IfcAreaMeasure::Out > TransverseBarCrossSectionArea;
 		Maybe< IfcPositiveLengthMeasure::Out > LongitudinalBarSpacing;
 		Maybe< IfcPositiveLengthMeasure::Out > TransverseBarSpacing;
 		Maybe< IfcReinforcingMeshTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcReinforcingMeshType
     struct IfcReinforcingMeshType : IfcReinforcingElementType, ObjectHelper<IfcReinforcingMeshType,11> { IfcReinforcingMeshType() : Object("IfcReinforcingMeshType") {}
 		IfcReinforcingMeshTypeEnum::Out PredefinedType;
 		Maybe< IfcPositiveLengthMeasure::Out > MeshLength;
 		Maybe< IfcPositiveLengthMeasure::Out > MeshWidth;
 		Maybe< IfcPositiveLengthMeasure::Out > LongitudinalBarNominalDiameter;
 		Maybe< IfcPositiveLengthMeasure::Out > TransverseBarNominalDiameter;
 		Maybe< IfcAreaMeasure::Out > LongitudinalBarCrossSectionArea;
 		Maybe< IfcAreaMeasure::Out > TransverseBarCrossSectionArea;
 		Maybe< IfcPositiveLengthMeasure::Out > LongitudinalBarSpacing;
 		Maybe< IfcPositiveLengthMeasure::Out > TransverseBarSpacing;
 		Maybe< IfcLabel::Out > BendingShapeCode;
 		Maybe< ListOf< IfcBendingParameterSelect, 1, 0 >::Out > BendingParameters;
     };
 
     // C++ wrapper for IfcRelationship
     struct IfcRelationship : IfcRoot, ObjectHelper<IfcRelationship,0> { IfcRelationship() : Object("IfcRelationship") {}
 
     };
 
     // C++ wrapper for IfcRelDecomposes
     struct IfcRelDecomposes : IfcRelationship, ObjectHelper<IfcRelDecomposes,0> { IfcRelDecomposes() : Object("IfcRelDecomposes") {}
 
     };
 
     // C++ wrapper for IfcRelAggregates
     struct IfcRelAggregates : IfcRelDecomposes, ObjectHelper<IfcRelAggregates,2> { IfcRelAggregates() : Object("IfcRelAggregates") {}
 		Lazy< IfcObjectDefinition > RelatingObject;
 		ListOf< Lazy< IfcObjectDefinition >, 1, 0 > RelatedObjects;
     };
 
     // C++ wrapper for IfcRelConnects
     struct IfcRelConnects : IfcRelationship, ObjectHelper<IfcRelConnects,0> { IfcRelConnects() : Object("IfcRelConnects") {}
 
     };
 
     // C++ wrapper for IfcRelContainedInSpatialStructure
     struct IfcRelContainedInSpatialStructure : IfcRelConnects, ObjectHelper<IfcRelContainedInSpatialStructure,2> { IfcRelContainedInSpatialStructure() : Object("IfcRelContainedInSpatialStructure") {}
 		ListOf< Lazy< IfcProduct >, 1, 0 > RelatedElements;
 		Lazy< IfcSpatialElement > RelatingStructure;
     };
 
     // C++ wrapper for IfcRelDefines
     struct IfcRelDefines : IfcRelationship, ObjectHelper<IfcRelDefines,0> { IfcRelDefines() : Object("IfcRelDefines") {}
 
     };
 
     // C++ wrapper for IfcRelDefinesByProperties
     struct IfcRelDefinesByProperties : IfcRelDefines, ObjectHelper<IfcRelDefinesByProperties,2> { IfcRelDefinesByProperties() : Object("IfcRelDefinesByProperties") {}
 		ListOf< Lazy< IfcObjectDefinition >, 1, 0 > RelatedObjects;
 		IfcPropertySetDefinitionSelect::Out RelatingPropertyDefinition;
     };
 
     // C++ wrapper for IfcRelFillsElement
     struct IfcRelFillsElement : IfcRelConnects, ObjectHelper<IfcRelFillsElement,2> { IfcRelFillsElement() : Object("IfcRelFillsElement") {}
 		Lazy< IfcOpeningElement > RelatingOpeningElement;
 		Lazy< IfcElement > RelatedBuildingElement;
     };
 
     // C++ wrapper for IfcRelVoidsElement
     struct IfcRelVoidsElement : IfcRelDecomposes, ObjectHelper<IfcRelVoidsElement,2> { IfcRelVoidsElement() : Object("IfcRelVoidsElement") {}
 		Lazy< IfcElement > RelatingBuildingElement;
 		Lazy< IfcFeatureElementSubtraction > RelatedOpeningElement;
     };
 
     // C++ wrapper for IfcReparametrisedCompositeCurveSegment
     struct IfcReparametrisedCompositeCurveSegment : IfcCompositeCurveSegment, ObjectHelper<IfcReparametrisedCompositeCurveSegment,1> { IfcReparametrisedCompositeCurveSegment() : Object("IfcReparametrisedCompositeCurveSegment") {}
 		IfcParameterValue::Out ParamLength;
     };
 
     // C++ wrapper for IfcRepresentation
     struct IfcRepresentation :  ObjectHelper<IfcRepresentation,4> { IfcRepresentation() : Object("IfcRepresentation") {}
 		Lazy< IfcRepresentationContext > ContextOfItems;
 		Maybe< IfcLabel::Out > RepresentationIdentifier;
 		Maybe< IfcLabel::Out > RepresentationType;
 		ListOf< Lazy< IfcRepresentationItem >, 1, 0 > Items;
     };
 
     // C++ wrapper for IfcRepresentationMap
     struct IfcRepresentationMap :  ObjectHelper<IfcRepresentationMap,2> { IfcRepresentationMap() : Object("IfcRepresentationMap") {}
 		IfcAxis2Placement::Out MappingOrigin;
 		Lazy< IfcRepresentation > MappedRepresentation;
     };
 
     // C++ wrapper for IfcRevolvedAreaSolid
     struct IfcRevolvedAreaSolid : IfcSweptAreaSolid, ObjectHelper<IfcRevolvedAreaSolid,2> { IfcRevolvedAreaSolid() : Object("IfcRevolvedAreaSolid") {}
 		Lazy< IfcAxis1Placement > Axis;
 		IfcPlaneAngleMeasure::Out Angle;
     };
 
     // C++ wrapper for IfcRevolvedAreaSolidTapered
     struct IfcRevolvedAreaSolidTapered : IfcRevolvedAreaSolid, ObjectHelper<IfcRevolvedAreaSolidTapered,1> { IfcRevolvedAreaSolidTapered() : Object("IfcRevolvedAreaSolidTapered") {}
 		Lazy< IfcProfileDef > EndSweptArea;
     };
 
     // C++ wrapper for IfcRightCircularCone
     struct IfcRightCircularCone : IfcCsgPrimitive3D, ObjectHelper<IfcRightCircularCone,2> { IfcRightCircularCone() : Object("IfcRightCircularCone") {}
 		IfcPositiveLengthMeasure::Out Height;
 		IfcPositiveLengthMeasure::Out BottomRadius;
     };
 
     // C++ wrapper for IfcRightCircularCylinder
     struct IfcRightCircularCylinder : IfcCsgPrimitive3D, ObjectHelper<IfcRightCircularCylinder,2> { IfcRightCircularCylinder() : Object("IfcRightCircularCylinder") {}
 		IfcPositiveLengthMeasure::Out Height;
 		IfcPositiveLengthMeasure::Out Radius;
     };
 
     // C++ wrapper for IfcRoof
     struct IfcRoof : IfcBuildingElement, ObjectHelper<IfcRoof,1> { IfcRoof() : Object("IfcRoof") {}
 		Maybe< IfcRoofTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcRoofType
     struct IfcRoofType : IfcBuildingElementType, ObjectHelper<IfcRoofType,1> { IfcRoofType() : Object("IfcRoofType") {}
 		IfcRoofTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcRoundedRectangleProfileDef
     struct IfcRoundedRectangleProfileDef : IfcRectangleProfileDef, ObjectHelper<IfcRoundedRectangleProfileDef,1> { IfcRoundedRectangleProfileDef() : Object("IfcRoundedRectangleProfileDef") {}
 		IfcPositiveLengthMeasure::Out RoundingRadius;
     };
 
     // C++ wrapper for IfcSIUnit
     struct IfcSIUnit : IfcNamedUnit, ObjectHelper<IfcSIUnit,2> { IfcSIUnit() : Object("IfcSIUnit") {}
 		Maybe< IfcSIPrefix::Out > Prefix;
 		IfcSIUnitName::Out Name;
     };
 
     // C++ wrapper for IfcSanitaryTerminal
     struct IfcSanitaryTerminal : IfcFlowTerminal, ObjectHelper<IfcSanitaryTerminal,1> { IfcSanitaryTerminal() : Object("IfcSanitaryTerminal") {}
 		Maybe< IfcSanitaryTerminalTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcSanitaryTerminalType
     struct IfcSanitaryTerminalType : IfcFlowTerminalType, ObjectHelper<IfcSanitaryTerminalType,1> { IfcSanitaryTerminalType() : Object("IfcSanitaryTerminalType") {}
 		IfcSanitaryTerminalTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcSeamCurve
     struct IfcSeamCurve : IfcSurfaceCurve, ObjectHelper<IfcSeamCurve,0> { IfcSeamCurve() : Object("IfcSeamCurve") {}
 
     };
 
     // C++ wrapper for IfcSectionedSpine
     struct IfcSectionedSpine : IfcGeometricRepresentationItem, ObjectHelper<IfcSectionedSpine,3> { IfcSectionedSpine() : Object("IfcSectionedSpine") {}
 		Lazy< IfcCompositeCurve > SpineCurve;
 		ListOf< Lazy< IfcProfileDef >, 2, 0 > CrossSections;
 		ListOf< Lazy< IfcAxis2Placement3D >, 2, 0 > CrossSectionPositions;
     };
 
     // C++ wrapper for IfcSensor
     struct IfcSensor : IfcDistributionControlElement, ObjectHelper<IfcSensor,1> { IfcSensor() : Object("IfcSensor") {}
 		Maybe< IfcSensorTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcSensorType
     struct IfcSensorType : IfcDistributionControlElementType, ObjectHelper<IfcSensorType,1> { IfcSensorType() : Object("IfcSensorType") {}
 		IfcSensorTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcShadingDevice
     struct IfcShadingDevice : IfcBuildingElement, ObjectHelper<IfcShadingDevice,1> { IfcShadingDevice() : Object("IfcShadingDevice") {}
 		Maybe< IfcShadingDeviceTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcShadingDeviceType
     struct IfcShadingDeviceType : IfcBuildingElementType, ObjectHelper<IfcShadingDeviceType,1> { IfcShadingDeviceType() : Object("IfcShadingDeviceType") {}
 		IfcShadingDeviceTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcShapeModel
     struct IfcShapeModel : IfcRepresentation, ObjectHelper<IfcShapeModel,0> { IfcShapeModel() : Object("IfcShapeModel") {}
 
     };
 
     // C++ wrapper for IfcShapeRepresentation
     struct IfcShapeRepresentation : IfcShapeModel, ObjectHelper<IfcShapeRepresentation,0> { IfcShapeRepresentation() : Object("IfcShapeRepresentation") {}
 
     };
 
     // C++ wrapper for IfcShellBasedSurfaceModel
     struct IfcShellBasedSurfaceModel : IfcGeometricRepresentationItem, ObjectHelper<IfcShellBasedSurfaceModel,1> { IfcShellBasedSurfaceModel() : Object("IfcShellBasedSurfaceModel") {}
 		ListOf< IfcShell, 1, 0 >::Out SbsmBoundary;
     };
 
     // C++ wrapper for IfcSite
     struct IfcSite : IfcSpatialStructureElement, ObjectHelper<IfcSite,5> { IfcSite() : Object("IfcSite") {}
 		Maybe< IfcCompoundPlaneAngleMeasure::Out > RefLatitude;
 		Maybe< IfcCompoundPlaneAngleMeasure::Out > RefLongitude;
 		Maybe< IfcLengthMeasure::Out > RefElevation;
 		Maybe< IfcLabel::Out > LandTitleNumber;
 		Maybe< Lazy< NotImplemented > > SiteAddress;
     };
 
     // C++ wrapper for IfcSlab
     struct IfcSlab : IfcBuildingElement, ObjectHelper<IfcSlab,1> { IfcSlab() : Object("IfcSlab") {}
 		Maybe< IfcSlabTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcSlabElementedCase
     struct IfcSlabElementedCase : IfcSlab, ObjectHelper<IfcSlabElementedCase,0> { IfcSlabElementedCase() : Object("IfcSlabElementedCase") {}
 
     };
 
     // C++ wrapper for IfcSlabStandardCase
     struct IfcSlabStandardCase : IfcSlab, ObjectHelper<IfcSlabStandardCase,0> { IfcSlabStandardCase() : Object("IfcSlabStandardCase") {}
 
     };
 
     // C++ wrapper for IfcSlabType
     struct IfcSlabType : IfcBuildingElementType, ObjectHelper<IfcSlabType,1> { IfcSlabType() : Object("IfcSlabType") {}
 		IfcSlabTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcSolarDevice
     struct IfcSolarDevice : IfcEnergyConversionDevice, ObjectHelper<IfcSolarDevice,1> { IfcSolarDevice() : Object("IfcSolarDevice") {}
 		Maybe< IfcSolarDeviceTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcSolarDeviceType
     struct IfcSolarDeviceType : IfcEnergyConversionDeviceType, ObjectHelper<IfcSolarDeviceType,1> { IfcSolarDeviceType() : Object("IfcSolarDeviceType") {}
 		IfcSolarDeviceTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcSpace
     struct IfcSpace : IfcSpatialStructureElement, ObjectHelper<IfcSpace,2> { IfcSpace() : Object("IfcSpace") {}
 		Maybe< IfcSpaceTypeEnum::Out > PredefinedType;
 		Maybe< IfcLengthMeasure::Out > ElevationWithFlooring;
     };
 
     // C++ wrapper for IfcSpaceHeater
     struct IfcSpaceHeater : IfcFlowTerminal, ObjectHelper<IfcSpaceHeater,1> { IfcSpaceHeater() : Object("IfcSpaceHeater") {}
 		Maybe< IfcSpaceHeaterTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcSpaceHeaterType
     struct IfcSpaceHeaterType : IfcFlowTerminalType, ObjectHelper<IfcSpaceHeaterType,1> { IfcSpaceHeaterType() : Object("IfcSpaceHeaterType") {}
 		IfcSpaceHeaterTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcSpatialElementType
     struct IfcSpatialElementType : IfcTypeProduct, ObjectHelper<IfcSpatialElementType,1> { IfcSpatialElementType() : Object("IfcSpatialElementType") {}
 		Maybe< IfcLabel::Out > ElementType;
     };
 
     // C++ wrapper for IfcSpatialStructureElementType
     struct IfcSpatialStructureElementType : IfcSpatialElementType, ObjectHelper<IfcSpatialStructureElementType,0> { IfcSpatialStructureElementType() : Object("IfcSpatialStructureElementType") {}
 
     };
 
     // C++ wrapper for IfcSpaceType
     struct IfcSpaceType : IfcSpatialStructureElementType, ObjectHelper<IfcSpaceType,2> { IfcSpaceType() : Object("IfcSpaceType") {}
 		IfcSpaceTypeEnum::Out PredefinedType;
 		Maybe< IfcLabel::Out > LongName;
     };
 
     // C++ wrapper for IfcSpatialZone
     struct IfcSpatialZone : IfcSpatialElement, ObjectHelper<IfcSpatialZone,1> { IfcSpatialZone() : Object("IfcSpatialZone") {}
 		Maybe< IfcSpatialZoneTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcSpatialZoneType
     struct IfcSpatialZoneType : IfcSpatialElementType, ObjectHelper<IfcSpatialZoneType,2> { IfcSpatialZoneType() : Object("IfcSpatialZoneType") {}
 		IfcSpatialZoneTypeEnum::Out PredefinedType;
 		Maybe< IfcLabel::Out > LongName;
     };
 
     // C++ wrapper for IfcSphere
     struct IfcSphere : IfcCsgPrimitive3D, ObjectHelper<IfcSphere,1> { IfcSphere() : Object("IfcSphere") {}
 		IfcPositiveLengthMeasure::Out Radius;
     };
 
     // C++ wrapper for IfcSphericalSurface
     struct IfcSphericalSurface : IfcElementarySurface, ObjectHelper<IfcSphericalSurface,1> { IfcSphericalSurface() : Object("IfcSphericalSurface") {}
 		IfcPositiveLengthMeasure::Out Radius;
     };
 
     // C++ wrapper for IfcStackTerminal
     struct IfcStackTerminal : IfcFlowTerminal, ObjectHelper<IfcStackTerminal,1> { IfcStackTerminal() : Object("IfcStackTerminal") {}
 		Maybe< IfcStackTerminalTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcStackTerminalType
     struct IfcStackTerminalType : IfcFlowTerminalType, ObjectHelper<IfcStackTerminalType,1> { IfcStackTerminalType() : Object("IfcStackTerminalType") {}
 		IfcStackTerminalTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcStair
     struct IfcStair : IfcBuildingElement, ObjectHelper<IfcStair,1> { IfcStair() : Object("IfcStair") {}
 		Maybe< IfcStairTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcStairFlight
     struct IfcStairFlight : IfcBuildingElement, ObjectHelper<IfcStairFlight,5> { IfcStairFlight() : Object("IfcStairFlight") {}
 		Maybe< IfcInteger::Out > NumberOfRisers;
 		Maybe< IfcInteger::Out > NumberOfTreads;
 		Maybe< IfcPositiveLengthMeasure::Out > RiserHeight;
 		Maybe< IfcPositiveLengthMeasure::Out > TreadLength;
 		Maybe< IfcStairFlightTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcStairFlightType
     struct IfcStairFlightType : IfcBuildingElementType, ObjectHelper<IfcStairFlightType,1> { IfcStairFlightType() : Object("IfcStairFlightType") {}
 		IfcStairFlightTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcStairType
     struct IfcStairType : IfcBuildingElementType, ObjectHelper<IfcStairType,1> { IfcStairType() : Object("IfcStairType") {}
 		IfcStairTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcStructuralActivity
     struct IfcStructuralActivity : IfcProduct, ObjectHelper<IfcStructuralActivity,2> { IfcStructuralActivity() : Object("IfcStructuralActivity") {}
 		Lazy< NotImplemented > AppliedLoad;
 		IfcGlobalOrLocalEnum::Out GlobalOrLocal;
     };
 
     // C++ wrapper for IfcStructuralAction
     struct IfcStructuralAction : IfcStructuralActivity, ObjectHelper<IfcStructuralAction,1> { IfcStructuralAction() : Object("IfcStructuralAction") {}
 		Maybe< IfcBoolean::Out > DestabilizingLoad;
     };
 
     // C++ wrapper for IfcStructuralAnalysisModel
     struct IfcStructuralAnalysisModel : IfcSystem, ObjectHelper<IfcStructuralAnalysisModel,5> { IfcStructuralAnalysisModel() : Object("IfcStructuralAnalysisModel") {}
 		IfcAnalysisModelTypeEnum::Out PredefinedType;
 		Maybe< Lazy< IfcAxis2Placement3D > > OrientationOf2DPlane;
 		Maybe< ListOf< Lazy< IfcStructuralLoadGroup >, 1, 0 > > LoadedBy;
 		Maybe< ListOf< Lazy< IfcStructuralResultGroup >, 1, 0 > > HasResults;
 		Maybe< Lazy< IfcObjectPlacement > > SharedPlacement;
     };
 
     // C++ wrapper for IfcStructuralItem
     struct IfcStructuralItem : IfcProduct, ObjectHelper<IfcStructuralItem,0> { IfcStructuralItem() : Object("IfcStructuralItem") {}
 
     };
 
     // C++ wrapper for IfcStructuralConnection
     struct IfcStructuralConnection : IfcStructuralItem, ObjectHelper<IfcStructuralConnection,1> { IfcStructuralConnection() : Object("IfcStructuralConnection") {}
 		Maybe< Lazy< NotImplemented > > AppliedCondition;
     };
 
     // C++ wrapper for IfcStructuralCurveAction
     struct IfcStructuralCurveAction : IfcStructuralAction, ObjectHelper<IfcStructuralCurveAction,2> { IfcStructuralCurveAction() : Object("IfcStructuralCurveAction") {}
 		Maybe< IfcProjectedOrTrueLengthEnum::Out > ProjectedOrTrue;
 		IfcStructuralCurveActivityTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcStructuralCurveConnection
     struct IfcStructuralCurveConnection : IfcStructuralConnection, ObjectHelper<IfcStructuralCurveConnection,1> { IfcStructuralCurveConnection() : Object("IfcStructuralCurveConnection") {}
 		Lazy< IfcDirection > Axis;
     };
 
     // C++ wrapper for IfcStructuralMember
     struct IfcStructuralMember : IfcStructuralItem, ObjectHelper<IfcStructuralMember,0> { IfcStructuralMember() : Object("IfcStructuralMember") {}
 
     };
 
     // C++ wrapper for IfcStructuralCurveMember
     struct IfcStructuralCurveMember : IfcStructuralMember, ObjectHelper<IfcStructuralCurveMember,2> { IfcStructuralCurveMember() : Object("IfcStructuralCurveMember") {}
 		IfcStructuralCurveMemberTypeEnum::Out PredefinedType;
 		Lazy< IfcDirection > Axis;
     };
 
     // C++ wrapper for IfcStructuralCurveMemberVarying
     struct IfcStructuralCurveMemberVarying : IfcStructuralCurveMember, ObjectHelper<IfcStructuralCurveMemberVarying,0> { IfcStructuralCurveMemberVarying() : Object("IfcStructuralCurveMemberVarying") {}
 
     };
 
     // C++ wrapper for IfcStructuralReaction
     struct IfcStructuralReaction : IfcStructuralActivity, ObjectHelper<IfcStructuralReaction,0> { IfcStructuralReaction() : Object("IfcStructuralReaction") {}
 
     };
 
     // C++ wrapper for IfcStructuralCurveReaction
     struct IfcStructuralCurveReaction : IfcStructuralReaction, ObjectHelper<IfcStructuralCurveReaction,1> { IfcStructuralCurveReaction() : Object("IfcStructuralCurveReaction") {}
 		IfcStructuralCurveActivityTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcStructuralLinearAction
     struct IfcStructuralLinearAction : IfcStructuralCurveAction, ObjectHelper<IfcStructuralLinearAction,0> { IfcStructuralLinearAction() : Object("IfcStructuralLinearAction") {}
 
     };
 
     // C++ wrapper for IfcStructuralLoadGroup
     struct IfcStructuralLoadGroup : IfcGroup, ObjectHelper<IfcStructuralLoadGroup,5> { IfcStructuralLoadGroup() : Object("IfcStructuralLoadGroup") {}
 		IfcLoadGroupTypeEnum::Out PredefinedType;
 		IfcActionTypeEnum::Out ActionType;
 		IfcActionSourceTypeEnum::Out ActionSource;
 		Maybe< IfcRatioMeasure::Out > Coefficient;
 		Maybe< IfcLabel::Out > Purpose;
     };
 
     // C++ wrapper for IfcStructuralLoadCase
     struct IfcStructuralLoadCase : IfcStructuralLoadGroup, ObjectHelper<IfcStructuralLoadCase,1> { IfcStructuralLoadCase() : Object("IfcStructuralLoadCase") {}
 		Maybe< ListOf< IfcRatioMeasure, 3, 3 >::Out > SelfWeightCoefficients;
     };
 
     // C++ wrapper for IfcStructuralSurfaceAction
     struct IfcStructuralSurfaceAction : IfcStructuralAction, ObjectHelper<IfcStructuralSurfaceAction,2> { IfcStructuralSurfaceAction() : Object("IfcStructuralSurfaceAction") {}
 		Maybe< IfcProjectedOrTrueLengthEnum::Out > ProjectedOrTrue;
 		IfcStructuralSurfaceActivityTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcStructuralPlanarAction
     struct IfcStructuralPlanarAction : IfcStructuralSurfaceAction, ObjectHelper<IfcStructuralPlanarAction,0> { IfcStructuralPlanarAction() : Object("IfcStructuralPlanarAction") {}
 
     };
 
     // C++ wrapper for IfcStructuralPointAction
     struct IfcStructuralPointAction : IfcStructuralAction, ObjectHelper<IfcStructuralPointAction,0> { IfcStructuralPointAction() : Object("IfcStructuralPointAction") {}
 
     };
 
     // C++ wrapper for IfcStructuralPointConnection
     struct IfcStructuralPointConnection : IfcStructuralConnection, ObjectHelper<IfcStructuralPointConnection,1> { IfcStructuralPointConnection() : Object("IfcStructuralPointConnection") {}
 		Maybe< Lazy< IfcAxis2Placement3D > > ConditionCoordinateSystem;
     };
 
     // C++ wrapper for IfcStructuralPointReaction
     struct IfcStructuralPointReaction : IfcStructuralReaction, ObjectHelper<IfcStructuralPointReaction,0> { IfcStructuralPointReaction() : Object("IfcStructuralPointReaction") {}
 
     };
 
     // C++ wrapper for IfcStructuralResultGroup
     struct IfcStructuralResultGroup : IfcGroup, ObjectHelper<IfcStructuralResultGroup,3> { IfcStructuralResultGroup() : Object("IfcStructuralResultGroup") {}
 		IfcAnalysisTheoryTypeEnum::Out TheoryType;
 		Maybe< Lazy< IfcStructuralLoadGroup > > ResultForLoadGroup;
 		IfcBoolean::Out IsLinear;
     };
 
     // C++ wrapper for IfcStructuralSurfaceConnection
     struct IfcStructuralSurfaceConnection : IfcStructuralConnection, ObjectHelper<IfcStructuralSurfaceConnection,0> { IfcStructuralSurfaceConnection() : Object("IfcStructuralSurfaceConnection") {}
 
     };
 
     // C++ wrapper for IfcStructuralSurfaceMember
     struct IfcStructuralSurfaceMember : IfcStructuralMember, ObjectHelper<IfcStructuralSurfaceMember,2> { IfcStructuralSurfaceMember() : Object("IfcStructuralSurfaceMember") {}
 		IfcStructuralSurfaceMemberTypeEnum::Out PredefinedType;
 		Maybe< IfcPositiveLengthMeasure::Out > Thickness;
     };
 
     // C++ wrapper for IfcStructuralSurfaceMemberVarying
     struct IfcStructuralSurfaceMemberVarying : IfcStructuralSurfaceMember, ObjectHelper<IfcStructuralSurfaceMemberVarying,0> { IfcStructuralSurfaceMemberVarying() : Object("IfcStructuralSurfaceMemberVarying") {}
 
     };
 
     // C++ wrapper for IfcStructuralSurfaceReaction
     struct IfcStructuralSurfaceReaction : IfcStructuralReaction, ObjectHelper<IfcStructuralSurfaceReaction,1> { IfcStructuralSurfaceReaction() : Object("IfcStructuralSurfaceReaction") {}
 		IfcStructuralSurfaceActivityTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcStyleModel
     struct IfcStyleModel : IfcRepresentation, ObjectHelper<IfcStyleModel,0> { IfcStyleModel() : Object("IfcStyleModel") {}
 
     };
 
     // C++ wrapper for IfcStyledItem
     struct IfcStyledItem : IfcRepresentationItem, ObjectHelper<IfcStyledItem,3> { IfcStyledItem() : Object("IfcStyledItem") {}
 		Maybe< Lazy< IfcRepresentationItem > > Item;
 		ListOf< IfcStyleAssignmentSelect, 1, 0 >::Out Styles;
 		Maybe< IfcLabel::Out > Name;
     };
 
     // C++ wrapper for IfcStyledRepresentation
     struct IfcStyledRepresentation : IfcStyleModel, ObjectHelper<IfcStyledRepresentation,0> { IfcStyledRepresentation() : Object("IfcStyledRepresentation") {}
 
     };
 
     // C++ wrapper for IfcSubContractResource
     struct IfcSubContractResource : IfcConstructionResource, ObjectHelper<IfcSubContractResource,1> { IfcSubContractResource() : Object("IfcSubContractResource") {}
 		Maybe< IfcSubContractResourceTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcSubContractResourceType
     struct IfcSubContractResourceType : IfcConstructionResourceType, ObjectHelper<IfcSubContractResourceType,1> { IfcSubContractResourceType() : Object("IfcSubContractResourceType") {}
 		IfcSubContractResourceTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcSubedge
     struct IfcSubedge : IfcEdge, ObjectHelper<IfcSubedge,1> { IfcSubedge() : Object("IfcSubedge") {}
 		Lazy< IfcEdge > ParentEdge;
     };
 
     // C++ wrapper for IfcSurfaceCurveSweptAreaSolid
     struct IfcSurfaceCurveSweptAreaSolid : IfcSweptAreaSolid, ObjectHelper<IfcSurfaceCurveSweptAreaSolid,4> { IfcSurfaceCurveSweptAreaSolid() : Object("IfcSurfaceCurveSweptAreaSolid") {}
 		Lazy< IfcCurve > Directrix;
 		Maybe< IfcParameterValue::Out > StartParam;
 		Maybe< IfcParameterValue::Out > EndParam;
 		Lazy< IfcSurface > ReferenceSurface;
     };
 
     // C++ wrapper for IfcSurfaceFeature
     struct IfcSurfaceFeature : IfcFeatureElement, ObjectHelper<IfcSurfaceFeature,1> { IfcSurfaceFeature() : Object("IfcSurfaceFeature") {}
 		Maybe< IfcSurfaceFeatureTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcSweptSurface
     struct IfcSweptSurface : IfcSurface, ObjectHelper<IfcSweptSurface,2> { IfcSweptSurface() : Object("IfcSweptSurface") {}
 		Lazy< IfcProfileDef > SweptCurve;
 		Maybe< Lazy< IfcAxis2Placement3D > > Position;
     };
 
     // C++ wrapper for IfcSurfaceOfLinearExtrusion
     struct IfcSurfaceOfLinearExtrusion : IfcSweptSurface, ObjectHelper<IfcSurfaceOfLinearExtrusion,2> { IfcSurfaceOfLinearExtrusion() : Object("IfcSurfaceOfLinearExtrusion") {}
 		Lazy< IfcDirection > ExtrudedDirection;
 		IfcLengthMeasure::Out Depth;
     };
 
     // C++ wrapper for IfcSurfaceOfRevolution
     struct IfcSurfaceOfRevolution : IfcSweptSurface, ObjectHelper<IfcSurfaceOfRevolution,1> { IfcSurfaceOfRevolution() : Object("IfcSurfaceOfRevolution") {}
 		Lazy< IfcAxis1Placement > AxisPosition;
     };
 
     // C++ wrapper for IfcSurfaceStyle
     struct IfcSurfaceStyle : IfcPresentationStyle, ObjectHelper<IfcSurfaceStyle,2> { IfcSurfaceStyle() : Object("IfcSurfaceStyle") {}
 		IfcSurfaceSide::Out Side;
 		ListOf< IfcSurfaceStyleElementSelect, 1, 5 >::Out Styles;
     };
 
     // C++ wrapper for IfcSurfaceStyleShading
     struct IfcSurfaceStyleShading : IfcPresentationItem, ObjectHelper<IfcSurfaceStyleShading,2> { IfcSurfaceStyleShading() : Object("IfcSurfaceStyleShading") {}
 		Lazy< IfcColourRgb > SurfaceColour;
 		Maybe< IfcNormalisedRatioMeasure::Out > Transparency;
     };
 
     // C++ wrapper for IfcSurfaceStyleRendering
     struct IfcSurfaceStyleRendering : IfcSurfaceStyleShading, ObjectHelper<IfcSurfaceStyleRendering,7> { IfcSurfaceStyleRendering() : Object("IfcSurfaceStyleRendering") {}
 		Maybe< IfcColourOrFactor::Out > DiffuseColour;
 		Maybe< IfcColourOrFactor::Out > TransmissionColour;
 		Maybe< IfcColourOrFactor::Out > DiffuseTransmissionColour;
 		Maybe< IfcColourOrFactor::Out > ReflectionColour;
 		Maybe< IfcColourOrFactor::Out > SpecularColour;
 		Maybe< IfcSpecularHighlightSelect::Out > SpecularHighlight;
 		IfcReflectanceMethodEnum::Out ReflectanceMethod;
     };
 
     // C++ wrapper for IfcSurfaceStyleWithTextures
     struct IfcSurfaceStyleWithTextures : IfcPresentationItem, ObjectHelper<IfcSurfaceStyleWithTextures,1> { IfcSurfaceStyleWithTextures() : Object("IfcSurfaceStyleWithTextures") {}
 		ListOf< Lazy< NotImplemented >, 1, 0 > Textures;
     };
 
     // C++ wrapper for IfcSweptDiskSolid
     struct IfcSweptDiskSolid : IfcSolidModel, ObjectHelper<IfcSweptDiskSolid,5> { IfcSweptDiskSolid() : Object("IfcSweptDiskSolid") {}
 		Lazy< IfcCurve > Directrix;
 		IfcPositiveLengthMeasure::Out Radius;
 		Maybe< IfcPositiveLengthMeasure::Out > InnerRadius;
 		Maybe< IfcParameterValue::Out > StartParam;
 		Maybe< IfcParameterValue::Out > EndParam;
     };
 
     // C++ wrapper for IfcSweptDiskSolidPolygonal
     struct IfcSweptDiskSolidPolygonal : IfcSweptDiskSolid, ObjectHelper<IfcSweptDiskSolidPolygonal,1> { IfcSweptDiskSolidPolygonal() : Object("IfcSweptDiskSolidPolygonal") {}
 		Maybe< IfcPositiveLengthMeasure::Out > FilletRadius;
     };
 
     // C++ wrapper for IfcSwitchingDevice
     struct IfcSwitchingDevice : IfcFlowController, ObjectHelper<IfcSwitchingDevice,1> { IfcSwitchingDevice() : Object("IfcSwitchingDevice") {}
 		Maybe< IfcSwitchingDeviceTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcSwitchingDeviceType
     struct IfcSwitchingDeviceType : IfcFlowControllerType, ObjectHelper<IfcSwitchingDeviceType,1> { IfcSwitchingDeviceType() : Object("IfcSwitchingDeviceType") {}
 		IfcSwitchingDeviceTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcSystemFurnitureElement
     struct IfcSystemFurnitureElement : IfcFurnishingElement, ObjectHelper<IfcSystemFurnitureElement,1> { IfcSystemFurnitureElement() : Object("IfcSystemFurnitureElement") {}
 		Maybe< IfcSystemFurnitureElementTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcSystemFurnitureElementType
     struct IfcSystemFurnitureElementType : IfcFurnishingElementType, ObjectHelper<IfcSystemFurnitureElementType,1> { IfcSystemFurnitureElementType() : Object("IfcSystemFurnitureElementType") {}
 		Maybe< IfcSystemFurnitureElementTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcTShapeProfileDef
     struct IfcTShapeProfileDef : IfcParameterizedProfileDef, ObjectHelper<IfcTShapeProfileDef,9> { IfcTShapeProfileDef() : Object("IfcTShapeProfileDef") {}
 		IfcPositiveLengthMeasure::Out Depth;
 		IfcPositiveLengthMeasure::Out FlangeWidth;
 		IfcPositiveLengthMeasure::Out WebThickness;
 		IfcPositiveLengthMeasure::Out FlangeThickness;
 		Maybe< IfcNonNegativeLengthMeasure::Out > FilletRadius;
 		Maybe< IfcNonNegativeLengthMeasure::Out > FlangeEdgeRadius;
 		Maybe< IfcNonNegativeLengthMeasure::Out > WebEdgeRadius;
 		Maybe< IfcPlaneAngleMeasure::Out > WebSlope;
 		Maybe< IfcPlaneAngleMeasure::Out > FlangeSlope;
     };
 
     // C++ wrapper for IfcTank
     struct IfcTank : IfcFlowStorageDevice, ObjectHelper<IfcTank,1> { IfcTank() : Object("IfcTank") {}
 		Maybe< IfcTankTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcTankType
     struct IfcTankType : IfcFlowStorageDeviceType, ObjectHelper<IfcTankType,1> { IfcTankType() : Object("IfcTankType") {}
 		IfcTankTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcTask
     struct IfcTask : IfcProcess, ObjectHelper<IfcTask,6> { IfcTask() : Object("IfcTask") {}
 		Maybe< IfcLabel::Out > Status;
 		Maybe< IfcLabel::Out > WorkMethod;
 		IfcBoolean::Out IsMilestone;
 		Maybe< IfcInteger::Out > Priority;
 		Maybe< Lazy< NotImplemented > > TaskTime;
 		Maybe< IfcTaskTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcTaskType
     struct IfcTaskType : IfcTypeProcess, ObjectHelper<IfcTaskType,2> { IfcTaskType() : Object("IfcTaskType") {}
 		IfcTaskTypeEnum::Out PredefinedType;
 		Maybe< IfcLabel::Out > WorkMethod;
     };
 
     // C++ wrapper for IfcTendon
     struct IfcTendon : IfcReinforcingElement, ObjectHelper<IfcTendon,8> { IfcTendon() : Object("IfcTendon") {}
 		Maybe< IfcTendonTypeEnum::Out > PredefinedType;
 		Maybe< IfcPositiveLengthMeasure::Out > NominalDiameter;
 		Maybe< IfcAreaMeasure::Out > CrossSectionArea;
 		Maybe< IfcForceMeasure::Out > TensionForce;
 		Maybe< IfcPressureMeasure::Out > PreStress;
 		Maybe< IfcNormalisedRatioMeasure::Out > FrictionCoefficient;
 		Maybe< IfcPositiveLengthMeasure::Out > AnchorageSlip;
 		Maybe< IfcPositiveLengthMeasure::Out > MinCurvatureRadius;
     };
 
     // C++ wrapper for IfcTendonAnchor
     struct IfcTendonAnchor : IfcReinforcingElement, ObjectHelper<IfcTendonAnchor,1> { IfcTendonAnchor() : Object("IfcTendonAnchor") {}
 		Maybe< IfcTendonAnchorTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcTendonAnchorType
     struct IfcTendonAnchorType : IfcReinforcingElementType, ObjectHelper<IfcTendonAnchorType,1> { IfcTendonAnchorType() : Object("IfcTendonAnchorType") {}
 		IfcTendonAnchorTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcTendonType
     struct IfcTendonType : IfcReinforcingElementType, ObjectHelper<IfcTendonType,4> { IfcTendonType() : Object("IfcTendonType") {}
 		IfcTendonTypeEnum::Out PredefinedType;
 		Maybe< IfcPositiveLengthMeasure::Out > NominalDiameter;
 		Maybe< IfcAreaMeasure::Out > CrossSectionArea;
 		Maybe< IfcPositiveLengthMeasure::Out > SheathDiameter;
     };
 
     // C++ wrapper for IfcTextLiteral
     struct IfcTextLiteral : IfcGeometricRepresentationItem, ObjectHelper<IfcTextLiteral,3> { IfcTextLiteral() : Object("IfcTextLiteral") {}
 		IfcPresentableText::Out Literal;
 		IfcAxis2Placement::Out Placement;
 		IfcTextPath::Out Path;
     };
 
     // C++ wrapper for IfcTextLiteralWithExtent
     struct IfcTextLiteralWithExtent : IfcTextLiteral, ObjectHelper<IfcTextLiteralWithExtent,2> { IfcTextLiteralWithExtent() : Object("IfcTextLiteralWithExtent") {}
 		Lazy< IfcPlanarExtent > Extent;
 		IfcBoxAlignment::Out BoxAlignment;
     };
 
     // C++ wrapper for IfcTopologyRepresentation
     struct IfcTopologyRepresentation : IfcShapeModel, ObjectHelper<IfcTopologyRepresentation,0> { IfcTopologyRepresentation() : Object("IfcTopologyRepresentation") {}
 
     };
 
     // C++ wrapper for IfcToroidalSurface
     struct IfcToroidalSurface : IfcElementarySurface, ObjectHelper<IfcToroidalSurface,2> { IfcToroidalSurface() : Object("IfcToroidalSurface") {}
 		IfcPositiveLengthMeasure::Out MajorRadius;
 		IfcPositiveLengthMeasure::Out MinorRadius;
     };
 
     // C++ wrapper for IfcTransformer
     struct IfcTransformer : IfcEnergyConversionDevice, ObjectHelper<IfcTransformer,1> { IfcTransformer() : Object("IfcTransformer") {}
 		Maybe< IfcTransformerTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcTransformerType
     struct IfcTransformerType : IfcEnergyConversionDeviceType, ObjectHelper<IfcTransformerType,1> { IfcTransformerType() : Object("IfcTransformerType") {}
 		IfcTransformerTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcTransportElement
     struct IfcTransportElement : IfcElement, ObjectHelper<IfcTransportElement,1> { IfcTransportElement() : Object("IfcTransportElement") {}
 		Maybe< IfcTransportElementTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcTransportElementType
     struct IfcTransportElementType : IfcElementType, ObjectHelper<IfcTransportElementType,1> { IfcTransportElementType() : Object("IfcTransportElementType") {}
 		IfcTransportElementTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcTrapeziumProfileDef
     struct IfcTrapeziumProfileDef : IfcParameterizedProfileDef, ObjectHelper<IfcTrapeziumProfileDef,4> { IfcTrapeziumProfileDef() : Object("IfcTrapeziumProfileDef") {}
 		IfcPositiveLengthMeasure::Out BottomXDim;
 		IfcPositiveLengthMeasure::Out TopXDim;
 		IfcPositiveLengthMeasure::Out YDim;
 		IfcLengthMeasure::Out TopXOffset;
     };
 
     // C++ wrapper for IfcTriangulatedFaceSet
     struct IfcTriangulatedFaceSet : IfcTessellatedFaceSet, ObjectHelper<IfcTriangulatedFaceSet,2> { IfcTriangulatedFaceSet() : Object("IfcTriangulatedFaceSet") {}
 		Maybe< IfcBoolean::Out > Closed;
 		Maybe< ListOf< IfcPositiveInteger, 1, 0 >::Out > PnIndex;
     };
 
     // C++ wrapper for IfcTrimmedCurve
     struct IfcTrimmedCurve : IfcBoundedCurve, ObjectHelper<IfcTrimmedCurve,5> { IfcTrimmedCurve() : Object("IfcTrimmedCurve") {}
 		Lazy< IfcCurve > BasisCurve;
 		ListOf< IfcTrimmingSelect, 1, 2 >::Out Trim1;
 		ListOf< IfcTrimmingSelect, 1, 2 >::Out Trim2;
 		IfcBoolean::Out SenseAgreement;
 		IfcTrimmingPreference::Out MasterRepresentation;
     };
 
     // C++ wrapper for IfcTubeBundle
     struct IfcTubeBundle : IfcEnergyConversionDevice, ObjectHelper<IfcTubeBundle,1> { IfcTubeBundle() : Object("IfcTubeBundle") {}
 		Maybe< IfcTubeBundleTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcTubeBundleType
     struct IfcTubeBundleType : IfcEnergyConversionDeviceType, ObjectHelper<IfcTubeBundleType,1> { IfcTubeBundleType() : Object("IfcTubeBundleType") {}
 		IfcTubeBundleTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcUShapeProfileDef
     struct IfcUShapeProfileDef : IfcParameterizedProfileDef, ObjectHelper<IfcUShapeProfileDef,7> { IfcUShapeProfileDef() : Object("IfcUShapeProfileDef") {}
 		IfcPositiveLengthMeasure::Out Depth;
 		IfcPositiveLengthMeasure::Out FlangeWidth;
 		IfcPositiveLengthMeasure::Out WebThickness;
 		IfcPositiveLengthMeasure::Out FlangeThickness;
 		Maybe< IfcNonNegativeLengthMeasure::Out > FilletRadius;
 		Maybe< IfcNonNegativeLengthMeasure::Out > EdgeRadius;
 		Maybe< IfcPlaneAngleMeasure::Out > FlangeSlope;
     };
 
     // C++ wrapper for IfcUnitAssignment
     struct IfcUnitAssignment :  ObjectHelper<IfcUnitAssignment,1> { IfcUnitAssignment() : Object("IfcUnitAssignment") {}
 		ListOf< IfcUnit, 1, 0 >::Out Units;
     };
 
     // C++ wrapper for IfcUnitaryControlElement
     struct IfcUnitaryControlElement : IfcDistributionControlElement, ObjectHelper<IfcUnitaryControlElement,1> { IfcUnitaryControlElement() : Object("IfcUnitaryControlElement") {}
 		Maybe< IfcUnitaryControlElementTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcUnitaryControlElementType
     struct IfcUnitaryControlElementType : IfcDistributionControlElementType, ObjectHelper<IfcUnitaryControlElementType,1> { IfcUnitaryControlElementType() : Object("IfcUnitaryControlElementType") {}
 		IfcUnitaryControlElementTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcUnitaryEquipment
     struct IfcUnitaryEquipment : IfcEnergyConversionDevice, ObjectHelper<IfcUnitaryEquipment,1> { IfcUnitaryEquipment() : Object("IfcUnitaryEquipment") {}
 		Maybe< IfcUnitaryEquipmentTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcUnitaryEquipmentType
     struct IfcUnitaryEquipmentType : IfcEnergyConversionDeviceType, ObjectHelper<IfcUnitaryEquipmentType,1> { IfcUnitaryEquipmentType() : Object("IfcUnitaryEquipmentType") {}
 		IfcUnitaryEquipmentTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcValve
     struct IfcValve : IfcFlowController, ObjectHelper<IfcValve,1> { IfcValve() : Object("IfcValve") {}
 		Maybe< IfcValveTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcValveType
     struct IfcValveType : IfcFlowControllerType, ObjectHelper<IfcValveType,1> { IfcValveType() : Object("IfcValveType") {}
 		IfcValveTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcVector
     struct IfcVector : IfcGeometricRepresentationItem, ObjectHelper<IfcVector,2> { IfcVector() : Object("IfcVector") {}
 		Lazy< IfcDirection > Orientation;
 		IfcLengthMeasure::Out Magnitude;
     };
 
     // C++ wrapper for IfcVertex
     struct IfcVertex : IfcTopologicalRepresentationItem, ObjectHelper<IfcVertex,0> { IfcVertex() : Object("IfcVertex") {}
 
     };
 
     // C++ wrapper for IfcVertexLoop
     struct IfcVertexLoop : IfcLoop, ObjectHelper<IfcVertexLoop,1> { IfcVertexLoop() : Object("IfcVertexLoop") {}
 		Lazy< IfcVertex > LoopVertex;
     };
 
     // C++ wrapper for IfcVertexPoint
     struct IfcVertexPoint : IfcVertex, ObjectHelper<IfcVertexPoint,1> { IfcVertexPoint() : Object("IfcVertexPoint") {}
 		Lazy< IfcPoint > VertexGeometry;
     };
 
     // C++ wrapper for IfcVibrationIsolator
     struct IfcVibrationIsolator : IfcElementComponent, ObjectHelper<IfcVibrationIsolator,1> { IfcVibrationIsolator() : Object("IfcVibrationIsolator") {}
 		Maybe< IfcVibrationIsolatorTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcVibrationIsolatorType
     struct IfcVibrationIsolatorType : IfcElementComponentType, ObjectHelper<IfcVibrationIsolatorType,1> { IfcVibrationIsolatorType() : Object("IfcVibrationIsolatorType") {}
 		IfcVibrationIsolatorTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcVirtualElement
     struct IfcVirtualElement : IfcElement, ObjectHelper<IfcVirtualElement,0> { IfcVirtualElement() : Object("IfcVirtualElement") {}
 
     };
 
     // C++ wrapper for IfcVoidingFeature
     struct IfcVoidingFeature : IfcFeatureElementSubtraction, ObjectHelper<IfcVoidingFeature,1> { IfcVoidingFeature() : Object("IfcVoidingFeature") {}
 		Maybe< IfcVoidingFeatureTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcWall
     struct IfcWall : IfcBuildingElement, ObjectHelper<IfcWall,1> { IfcWall() : Object("IfcWall") {}
 		Maybe< IfcWallTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcWallElementedCase
     struct IfcWallElementedCase : IfcWall, ObjectHelper<IfcWallElementedCase,0> { IfcWallElementedCase() : Object("IfcWallElementedCase") {}
 
     };
 
     // C++ wrapper for IfcWallStandardCase
     struct IfcWallStandardCase : IfcWall, ObjectHelper<IfcWallStandardCase,0> { IfcWallStandardCase() : Object("IfcWallStandardCase") {}
 
     };
 
     // C++ wrapper for IfcWallType
     struct IfcWallType : IfcBuildingElementType, ObjectHelper<IfcWallType,1> { IfcWallType() : Object("IfcWallType") {}
 		IfcWallTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcWasteTerminal
     struct IfcWasteTerminal : IfcFlowTerminal, ObjectHelper<IfcWasteTerminal,1> { IfcWasteTerminal() : Object("IfcWasteTerminal") {}
 		Maybe< IfcWasteTerminalTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcWasteTerminalType
     struct IfcWasteTerminalType : IfcFlowTerminalType, ObjectHelper<IfcWasteTerminalType,1> { IfcWasteTerminalType() : Object("IfcWasteTerminalType") {}
 		IfcWasteTerminalTypeEnum::Out PredefinedType;
     };
 
     // C++ wrapper for IfcWindow
     struct IfcWindow : IfcBuildingElement, ObjectHelper<IfcWindow,5> { IfcWindow() : Object("IfcWindow") {}
 		Maybe< IfcPositiveLengthMeasure::Out > OverallHeight;
 		Maybe< IfcPositiveLengthMeasure::Out > OverallWidth;
 		Maybe< IfcWindowTypeEnum::Out > PredefinedType;
 		Maybe< IfcWindowTypePartitioningEnum::Out > PartitioningType;
 		Maybe< IfcLabel::Out > UserDefinedPartitioningType;
     };
 
     // C++ wrapper for IfcWindowStandardCase
     struct IfcWindowStandardCase : IfcWindow, ObjectHelper<IfcWindowStandardCase,0> { IfcWindowStandardCase() : Object("IfcWindowStandardCase") {}
 
     };
 
     // C++ wrapper for IfcWindowStyle
     struct IfcWindowStyle : IfcTypeProduct, ObjectHelper<IfcWindowStyle,4> { IfcWindowStyle() : Object("IfcWindowStyle") {}
 		IfcWindowStyleConstructionEnum::Out ConstructionType;
 		IfcWindowStyleOperationEnum::Out OperationType;
 		IfcBoolean::Out ParameterTakesPrecedence;
 		IfcBoolean::Out Sizeable;
     };
 
     // C++ wrapper for IfcWindowType
     struct IfcWindowType : IfcBuildingElementType, ObjectHelper<IfcWindowType,4> { IfcWindowType() : Object("IfcWindowType") {}
 		IfcWindowTypeEnum::Out PredefinedType;
 		IfcWindowTypePartitioningEnum::Out PartitioningType;
 		Maybe< IfcBoolean::Out > ParameterTakesPrecedence;
 		Maybe< IfcLabel::Out > UserDefinedPartitioningType;
     };
 
     // C++ wrapper for IfcWorkCalendar
     struct IfcWorkCalendar : IfcControl, ObjectHelper<IfcWorkCalendar,3> { IfcWorkCalendar() : Object("IfcWorkCalendar") {}
 		Maybe< ListOf< Lazy< NotImplemented >, 1, 0 > > WorkingTimes;
 		Maybe< ListOf< Lazy< NotImplemented >, 1, 0 > > ExceptionTimes;
 		Maybe< IfcWorkCalendarTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcWorkControl
     struct IfcWorkControl : IfcControl, ObjectHelper<IfcWorkControl,7> { IfcWorkControl() : Object("IfcWorkControl") {}
 		IfcDateTime::Out CreationDate;
 		Maybe< ListOf< Lazy< NotImplemented >, 1, 0 > > Creators;
 		Maybe< IfcLabel::Out > Purpose;
 		Maybe< IfcDuration::Out > Duration;
 		Maybe< IfcDuration::Out > TotalFloat;
 		IfcDateTime::Out StartTime;
 		Maybe< IfcDateTime::Out > FinishTime;
     };
 
     // C++ wrapper for IfcWorkPlan
     struct IfcWorkPlan : IfcWorkControl, ObjectHelper<IfcWorkPlan,1> { IfcWorkPlan() : Object("IfcWorkPlan") {}
 		Maybe< IfcWorkPlanTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcWorkSchedule
     struct IfcWorkSchedule : IfcWorkControl, ObjectHelper<IfcWorkSchedule,1> { IfcWorkSchedule() : Object("IfcWorkSchedule") {}
 		Maybe< IfcWorkScheduleTypeEnum::Out > PredefinedType;
     };
 
     // C++ wrapper for IfcZShapeProfileDef
     struct IfcZShapeProfileDef : IfcParameterizedProfileDef, ObjectHelper<IfcZShapeProfileDef,6> { IfcZShapeProfileDef() : Object("IfcZShapeProfileDef") {}
 		IfcPositiveLengthMeasure::Out Depth;
 		IfcPositiveLengthMeasure::Out FlangeWidth;
 		IfcPositiveLengthMeasure::Out WebThickness;
 		IfcPositiveLengthMeasure::Out FlangeThickness;
 		Maybe< IfcNonNegativeLengthMeasure::Out > FilletRadius;
 		Maybe< IfcNonNegativeLengthMeasure::Out > EdgeRadius;
     };
 
     // C++ wrapper for IfcZone
     struct IfcZone : IfcSystem, ObjectHelper<IfcZone,1> { IfcZone() : Object("IfcZone") {}
 		Maybe< IfcLabel::Out > LongName;
     };
 
 	void GetSchema(EXPRESS::ConversionSchema& out);
 
 } //! IFC
diff --git a/code/AssetLib/Irr/IRRLoader.h b/code/AssetLib/Irr/IRRLoader.h
index 535f6481d..da90902ed 100644
--- a/code/AssetLib/Irr/IRRLoader.h
+++ b/code/AssetLib/Irr/IRRLoader.h
@@ -273,13 +273,13 @@ private:
         std::vector<aiNodeAnim*>& anims);
 
 private:
-    /// Configuration option: desired output FPS 
+    /// Configuration option: desired output FPS
     double fps;
 
     /// Configuration option: speed flag was set?
     bool configSpeedFlag;
 };
 
 } // end of namespace Assimp
 
 #endif // AI_IRRIMPORTER_H_INC
diff --git a/code/AssetLib/LWO/LWOAnimation.h b/code/AssetLib/LWO/LWOAnimation.h
index 1ed8caf88..64aa5980a 100644
--- a/code/AssetLib/LWO/LWOAnimation.h
+++ b/code/AssetLib/LWO/LWOAnimation.h
@@ -113,34 +113,34 @@ enum PrePostBehaviour
 // ---------------------------------------------------------------------------
 /** \brief Data structure for a LWO animation keyframe
  */
 struct Key {
-    Key() AI_NO_EXCEPT 
+    Key() AI_NO_EXCEPT
     : time()
     , value()
     , inter(IT_LINE)
     , params() {
         // empty
     }
 
     //! Current time
     double time;
 
     //! Current value
     float value;
 
     //! How to interpolate this key with previous key?
     InterpolationType inter;
 
     //! Interpolation parameters
     float params[5];
 
 
     // for std::find()
     operator double () {
         return time;
     }
 };
 
 // ---------------------------------------------------------------------------
 /** \brief Data structure for a LWO animation envelope
  */
diff --git a/code/AssetLib/LWS/LWSLoader.cpp b/code/AssetLib/LWS/LWSLoader.cpp
index 01a50b6e4..cb07787fa 100644
--- a/code/AssetLib/LWS/LWSLoader.cpp
+++ b/code/AssetLib/LWS/LWSLoader.cpp
@@ -193,69 +193,69 @@ void LWSImporter::SetupProperties(const Importer *pImp) {
 // ------------------------------------------------------------------------------------------------
 // Read an envelope description
 void LWSImporter::ReadEnvelope(const LWS::Element &dad, LWO::Envelope &fill) {
     if (dad.children.empty()) {
         ASSIMP_LOG_ERROR("LWS: Envelope descriptions must not be empty");
         return;
     }
 
     // reserve enough storage
     std::list<LWS::Element>::const_iterator it = dad.children.begin();
-    
+
     fill.keys.reserve(strtoul10(it->tokens[1].c_str()));
 
     for (++it; it != dad.children.end(); ++it) {
         const char *c = (*it).tokens[1].c_str();
 
         if ((*it).tokens[0] == "Key") {
             fill.keys.push_back(LWO::Key());
             LWO::Key &key = fill.keys.back();
 
             float f;
             SkipSpaces(&c);
             c = fast_atoreal_move<float>(c, key.value);
             SkipSpaces(&c);
             c = fast_atoreal_move<float>(c, f);
 
             key.time = f;
 
             unsigned int span = strtoul10(c, &c), num = 0;
             switch (span) {
                 case 0:
                     key.inter = LWO::IT_TCB;
                     num = 5;
                     break;
                 case 1:
                 case 2:
                     key.inter = LWO::IT_HERM;
                     num = 5;
                     break;
                 case 3:
                     key.inter = LWO::IT_LINE;
                     num = 0;
                     break;
                 case 4:
                     key.inter = LWO::IT_STEP;
                     num = 0;
                     break;
                 case 5:
                     key.inter = LWO::IT_BEZ2;
                     num = 4;
                     break;
                 default:
                     ASSIMP_LOG_ERROR("LWS: Unknown span type");
             }
             for (unsigned int i = 0; i < num; ++i) {
                 SkipSpaces(&c);
                 c = fast_atoreal_move<float>(c, key.params[i]);
             }
         } else if ((*it).tokens[0] == "Behaviors") {
             SkipSpaces(&c);
             fill.pre = (LWO::PrePostBehaviour)strtoul10(c, &c);
             SkipSpaces(&c);
             fill.post = (LWO::PrePostBehaviour)strtoul10(c, &c);
         }
     }
 }
 
 // ------------------------------------------------------------------------------------------------
 // Read animation channels in the old LightWave animation format
@@ -462,37 +462,37 @@ void LWSImporter::BuildGraph(aiNode *nd, LWS::NodeDesc &src, std::vector<Attachm
 // ------------------------------------------------------------------------------------------------
 // Determine the exact location of a LWO file
 std::string LWSImporter::FindLWOFile(const std::string &in) {
     // insert missing directory separator if necessary
     std::string tmp(in);
     if (in.length() > 3 && in[1] == ':' && in[2] != '\\' && in[2] != '/') {
         tmp = in[0] + (std::string(":\\") + in.substr(2));
-    } 
+    }
 
     if (io->Exists(tmp)) {
         return in;
     }
 
     // file is not accessible for us ... maybe it's packed by
     // LightWave's 'Package Scene' command?
 
     // Relevant for us are the following two directories:
     // <folder>\Objects\<hh>\<*>.lwo
     // <folder>\Scenes\<hh>\<*>.lws
     // where <hh> is optional.
 
     std::string test = std::string("..") + (io->getOsSeparator() + tmp);
     if (io->Exists(test)) {
         return test;
     }
 
     test = std::string("..") + (io->getOsSeparator() + test);
     if (io->Exists(test)) {
         return test;
     }
 
     // return original path, maybe the IOsystem knows better
     return tmp;
 }
 
 // ------------------------------------------------------------------------------------------------
 // Read file into given scene data structure
diff --git a/code/AssetLib/M3D/M3DWrapper.h b/code/AssetLib/M3D/M3DWrapper.h
index ba838d71d..dcb82a83a 100644
--- a/code/AssetLib/M3D/M3DWrapper.h
+++ b/code/AssetLib/M3D/M3DWrapper.h
@@ -71,30 +71,30 @@ class M3DWrapper {
 public:
 	/// Construct an empty M3D model
 	explicit M3DWrapper();
 
 	/// Construct an M3D model from provided buffer
 	/// @note The m3d.h SDK function does not mark the data as const. Have assumed it does not write.
 	/// BUG: SECURITY: The m3d.h SDK cannot be informed of the buffer size. BUFFER OVERFLOW IS CERTAIN
 	explicit M3DWrapper(IOSystem *pIOHandler, const std::vector<unsigned char> &buffer);
 
 	/// Theclasss destructor.
     ~M3DWrapper();
 
 	/// Will reset the wrapper, all data will become nullptr.
     void reset();
 
 	// The Name access, empty string returned when no m3d instance.
-	std::string Name() const; 
+	std::string Name() const;
 
 	/// Executes a save.
 	unsigned char *Save(int quality, int flags, unsigned int &size);
-    
+
     /// Clearer
 	void ClearSave();
 
     /// True for m3d instance exists.
 	explicit operator bool() const;
 
 	// Allow direct access to M3D API
 	m3d_t *operator->() const;
 	m3d_t *M3D() const;
@@ -113,20 +113,20 @@ inline std::string M3DWrapper::Name() const {
     return std::string();
 }
 
-inline M3DWrapper::operator bool() const { 
-    return m3d_ != nullptr; 
+inline M3DWrapper::operator bool() const {
+    return m3d_ != nullptr;
 }
 
 inline m3d_t *M3DWrapper::operator->() const {
-    return m3d_; 
+    return m3d_;
 }
 
 inline m3d_t *M3DWrapper::M3D() const {
-    return m3d_; 
+    return m3d_;
 }
 
 } // namespace Assimp
 
 #endif
 
 #endif // AI_M3DWRAPPER_H_INC
diff --git a/code/AssetLib/M3D/m3d.h b/code/AssetLib/M3D/m3d.h
index 28bf19482..3adcd5bef 100644
--- a/code/AssetLib/M3D/m3d.h
+++ b/code/AssetLib/M3D/m3d.h
@@ -799,37 +799,37 @@ unsigned char *_m3dstbi_zlib_compress(unsigned char *data, int data_len, int *ou
     {
         unsigned int s1 = 1, s2 = 0;
         int blocklen = (int)(data_len % 5552);
         j = 0;
         while (j < data_len) {
             for (i = 0; i < blocklen; ++i)
                 s1 += data[j + i], s2 += s1;
             s1 %= 65521, s2 %= 65521;
             j += blocklen;
             blocklen = 5552;
         }
         _m3dstbiw___sbpush(out, STBIW_UCHAR(s2 >> 8));
         _m3dstbiw___sbpush(out, STBIW_UCHAR(s2));
         _m3dstbiw___sbpush(out, STBIW_UCHAR(s1 >> 8));
         _m3dstbiw___sbpush(out, STBIW_UCHAR(s1));
     }
     *out_len = _m3dstbiw___sbn(out);
     STBIW_MEMMOVE(_m3dstbiw___sbraw(out), out, *out_len);
     return (unsigned char *)_m3dstbiw___sbraw(out);
 }
 #define stbi_zlib_compress _m3dstbi_zlib_compress
 #else
 unsigned char *_m3dstbi_zlib_compress(unsigned char *data, int data_len, int *out_len, int quality);
 #endif
 
 #define M3D_CHUNKMAGIC(m, a, b, c, d) ((m)[0] == (a) && (m)[1] == (b) && (m)[2] == (c) && (m)[3] == (d))
 
 #include <locale.h> /* sprintf and strtod cares about number locale */
 #include <stdio.h> /* get sprintf */
 #ifdef M3D_PROFILING
 #include <sys/time.h>
 #endif
 
-#if !defined(M3D_NOIMPORTER) 
+#if !defined(M3D_NOIMPORTER)
 /* helper functions for the ASCII parser */
 static char *_m3d_findarg(char *s) {
     while (s && *s && *s != ' ' && *s != '\t' && *s != '\r' && *s != '\n')
@@ -3089,1557 +3089,1557 @@ static char *_m3d_prtbone(char *ptr, m3db_t *bone, M3D_INDEX numbone, M3D_INDEX
 /**
  * Function to encode an in-memory model into on storage Model 3D format
  */
 unsigned char *m3d_save(m3d_t *model, int quality, int flags, unsigned int *size) {
     const char *ol;
     char *ptr;
     char vc_s, vi_s, si_s, ci_s, ti_s, bi_s, nb_s, sk_s, fc_s, hi_s, fi_s;
     char *sn = NULL, *sl = NULL, *sa = NULL, *sd = NULL;
     unsigned char *out = NULL, *z = NULL, weights[M3D_NUMBONE], *norm = NULL;
     unsigned int i = 0, j = 0, k = 0, l = 0, n = 0, len = 0, chunklen = 0, *length = NULL;
     M3D_FLOAT scale = (M3D_FLOAT)0.0, min_x, max_x, min_y, max_y, min_z, max_z;
     M3D_INDEX last, *vrtxidx = NULL, *mtrlidx = NULL, *tmapidx = NULL, *skinidx = NULL;
     uint32_t idx, numcmap = 0, *cmap = NULL, numvrtx = 0, maxvrtx = 0, numtmap = 0, maxtmap = 0, numproc = 0;
     uint32_t numskin = 0, maxskin = 0, numstr = 0, maxt = 0, maxbone = 0, numgrp = 0, maxgrp = 0, *grpidx = NULL;
     uint8_t *opa = nullptr;
     m3dcd_t *cd;
     m3dc_t *cmd;
     m3dstr_t *str = NULL;
     m3dvsave_t *vrtx = NULL, vertex;
     m3dtisave_t *tmap = NULL, tcoord;
     m3dssave_t *skin = NULL, sk;
     m3dfsave_t *face = NULL;
     m3dhdr_t *h = NULL;
     m3dm_t *m;
     m3da_t *a;
 
     if (!model) {
         if (size) *size = 0;
         return NULL;
     }
     model->errcode = M3D_SUCCESS;
     if (flags & M3D_EXP_ASCII) quality = M3D_EXP_DOUBLE;
     vrtxidx = (M3D_INDEX *)M3D_MALLOC(model->numvertex * sizeof(M3D_INDEX));
     if (!vrtxidx) goto memerr;
     memset(vrtxidx, 255, model->numvertex * sizeof(M3D_INDEX));
     if (model->numvertex && !(flags & M3D_EXP_NONORMAL)) {
         norm = (unsigned char *)M3D_MALLOC(model->numvertex * sizeof(unsigned char));
         if (!norm) goto memerr;
         memset(norm, 0, model->numvertex * sizeof(unsigned char));
     }
     if (model->nummaterial && !(flags & M3D_EXP_NOMATERIAL)) {
         mtrlidx = (M3D_INDEX *)M3D_MALLOC(model->nummaterial * sizeof(M3D_INDEX));
         if (!mtrlidx) goto memerr;
         memset(mtrlidx, 255, model->nummaterial * sizeof(M3D_INDEX));
         opa = (uint8_t *)M3D_MALLOC(model->nummaterial * 2 * sizeof(M3D_INDEX));
         if (!opa) goto memerr;
         memset(opa, 255, model->nummaterial * 2 * sizeof(M3D_INDEX));
     }
     if (model->numtmap && !(flags & M3D_EXP_NOTXTCRD)) {
         tmapidx = (M3D_INDEX *)M3D_MALLOC(model->numtmap * sizeof(M3D_INDEX));
         if (!tmapidx) goto memerr;
         memset(tmapidx, 255, model->numtmap * sizeof(M3D_INDEX));
     }
     /** collect array elements that are actually referenced **/
     if (!(flags & M3D_EXP_NOFACE)) {
         /* face */
         if (model->numface && model->face) {
             M3D_LOG("Processing mesh face");
             face = (m3dfsave_t *)M3D_MALLOC(model->numface * sizeof(m3dfsave_t));
             if (!face) goto memerr;
             for (i = 0; i < model->numface; i++) {
                 memcpy(&face[i].data, &model->face[i], sizeof(m3df_t));
                 face[i].group = 0;
                 face[i].opacity = 255;
                 if (!(flags & M3D_EXP_NOMATERIAL) && model->face[i].materialid < model->nummaterial) {
                     if (model->material[model->face[i].materialid].numprop) {
                         mtrlidx[model->face[i].materialid] = 0;
                         if (opa[model->face[i].materialid * 2]) {
                             m = &model->material[model->face[i].materialid];
                             for (j = 0; j < m->numprop; j++)
                                 if (m->prop[j].type == m3dp_Kd) {
                                     opa[model->face[i].materialid * 2 + 1] = ((uint8_t *)&m->prop[j].value.color)[3];
                                     break;
                                 }
                             for (j = 0; j < m->numprop; j++)
                                 if (m->prop[j].type == m3dp_d) {
                                     opa[model->face[i].materialid * 2 + 1] = (uint8_t)(m->prop[j].value.fnum * 255);
                                     break;
                                 }
                             opa[model->face[i].materialid * 2] = 0;
                         }
                         face[i].opacity = opa[model->face[i].materialid * 2 + 1];
                     } else
                         face[i].data.materialid = M3D_UNDEF;
                 }
                 for (j = 0; j < 3; j++) {
                     k = model->face[i].vertex[j];
                     if (k < model->numvertex)
                         vrtxidx[k] = 0;
                     if (!(flags & M3D_EXP_NOCMAP)) {
                         cmap = _m3d_addcmap(cmap, &numcmap, model->vertex[k].color);
                         if (!cmap) goto memerr;
                     }
                     k = model->face[i].normal[j];
                     if (k < model->numvertex && !(flags & M3D_EXP_NONORMAL)) {
                         vrtxidx[k] = 0;
                         norm[k] = 1;
                     }
                     k = model->face[i].texcoord[j];
                     if (k < model->numtmap && !(flags & M3D_EXP_NOTXTCRD))
                         tmapidx[k] = 0;
                 }
                 /* convert from CW to CCW */
                 if (flags & M3D_EXP_IDOSUCK) {
                     j = face[i].data.vertex[1];
                     face[i].data.vertex[1] = face[i].data.vertex[2];
                     face[i].data.vertex[2] = face[i].data.vertex[1];
                     j = face[i].data.normal[1];
                     face[i].data.normal[1] = face[i].data.normal[2];
                     face[i].data.normal[2] = face[i].data.normal[1];
                     j = face[i].data.texcoord[1];
                     face[i].data.texcoord[1] = face[i].data.texcoord[2];
                     face[i].data.texcoord[2] = face[i].data.texcoord[1];
                 }
             }
         }
         if (model->numshape && model->shape) {
             M3D_LOG("Processing shape face");
             for (i = 0; i < model->numshape; i++) {
                 if (!model->shape[i].numcmd) continue;
                 str = _m3d_addstr(str, &numstr, model->shape[i].name);
                 if (!str) goto memerr;
                 for (j = 0; j < model->shape[i].numcmd; j++) {
                     cmd = &model->shape[i].cmd[j];
                     if (cmd->type >= (unsigned int)(sizeof(m3d_commandtypes) / sizeof(m3d_commandtypes[0])) || !cmd->arg)
                         continue;
                     if (cmd->type == m3dc_mesh) {
                         if (numgrp + 2 < maxgrp) {
                             maxgrp += 1024;
                             grpidx = (uint32_t *)realloc(grpidx, maxgrp * sizeof(uint32_t));
                             if (!grpidx) goto memerr;
                             if (!numgrp) {
                                 grpidx[0] = 0;
                                 grpidx[1] = model->numface;
                                 numgrp += 2;
                             }
                         }
                         grpidx[numgrp + 0] = cmd->arg[0];
                         grpidx[numgrp + 1] = cmd->arg[0] + cmd->arg[1];
                         numgrp += 2;
                     }
                     cd = &m3d_commandtypes[cmd->type];
                     for (k = n = 0, l = cd->p; k < l; k++)
                         switch (cd->a[((k - n) % (cd->p - n)) + n]) {
                         case m3dcp_mi_t:
                             if (!(flags & M3D_EXP_NOMATERIAL) && cmd->arg[k] < model->nummaterial)
                                 mtrlidx[cmd->arg[k]] = 0;
                             break;
                         case m3dcp_ti_t:
                             if (!(flags & M3D_EXP_NOTXTCRD) && cmd->arg[k] < model->numtmap)
                                 tmapidx[cmd->arg[k]] = 0;
                             break;
                         case m3dcp_qi_t:
                         case m3dcp_vi_t:
                             if (cmd->arg[k] < model->numvertex)
                                 vrtxidx[cmd->arg[k]] = 0;
                             break;
                         case m3dcp_va_t:
                             n = k + 1;
                             l += (cmd->arg[k] - 1) * (cd->p - k - 1);
                             break;
                         }
                 }
             }
         }
         if (model->numface && face) {
             if (numgrp && grpidx) {
                 qsort(grpidx, numgrp, sizeof(uint32_t), _m3d_grpcmp);
                 for (i = j = 0; i < model->numface && j < numgrp; i++) {
                     while (j < numgrp && grpidx[j] < i)
                         j++;
                     face[i].group = j;
                 }
             }
             qsort(face, model->numface, sizeof(m3dfsave_t), _m3d_facecmp);
         }
         if (grpidx) {
             M3D_FREE(grpidx);
             grpidx = NULL;
         }
         if (model->numlabel && model->label) {
             M3D_LOG("Processing annotation labels");
             for (i = 0; i < model->numlabel; i++) {
                 str = _m3d_addstr(str, &numstr, model->label[i].name);
                 str = _m3d_addstr(str, &numstr, model->label[i].lang);
                 str = _m3d_addstr(str, &numstr, model->label[i].text);
                 if (!(flags & M3D_EXP_NOCMAP)) {
                     cmap = _m3d_addcmap(cmap, &numcmap, model->label[i].color);
                     if (!cmap) goto memerr;
                 }
                 if (model->label[i].vertexid < model->numvertex)
                     vrtxidx[model->label[i].vertexid] = 0;
             }
             qsort(model->label, model->numlabel, sizeof(m3dl_t), _m3d_lblcmp);
         }
     } else if (!(flags & M3D_EXP_NOMATERIAL)) {
         /* without a face, simply add all materials, because it can be an mtllib */
         for (i = 0; i < model->nummaterial; i++)
             mtrlidx[i] = i;
     }
     /* bind-pose skeleton */
     if (model->numbone && model->bone && !(flags & M3D_EXP_NOBONE)) {
         M3D_LOG("Processing bones");
         for (i = 0; i < model->numbone; i++) {
             str = _m3d_addstr(str, &numstr, model->bone[i].name);
             if (!str) goto memerr;
             k = model->bone[i].pos;
             if (k < model->numvertex)
                 vrtxidx[k] = 0;
             k = model->bone[i].ori;
             if (k < model->numvertex)
                 vrtxidx[k] = 0;
         }
     }
     /* actions, animated skeleton poses */
     if (model->numaction && model->action && !(flags & M3D_EXP_NOACTION)) {
         M3D_LOG("Processing action list");
         for (j = 0; j < model->numaction; j++) {
             a = &model->action[j];
             str = _m3d_addstr(str, &numstr, a->name);
             if (!str) goto memerr;
             if (a->numframe > 65535) a->numframe = 65535;
             for (i = 0; i < a->numframe; i++) {
                 for (l = 0; l < a->frame[i].numtransform; l++) {
                     k = a->frame[i].transform[l].pos;
                     if (k < model->numvertex)
                         vrtxidx[k] = 0;
                     k = a->frame[i].transform[l].ori;
                     if (k < model->numvertex)
                         vrtxidx[k] = 0;
                 }
                 if (l > maxt) maxt = l;
             }
         }
     }
     /* add colors to color map and texture names to string table */
     if (!(flags & M3D_EXP_NOMATERIAL)) {
         M3D_LOG("Processing materials");
         for (i = k = 0; i < model->nummaterial; i++) {
             if (mtrlidx[i] == M3D_UNDEF || !model->material[i].numprop) continue;
             mtrlidx[i] = k++;
             m = &model->material[i];
             str = _m3d_addstr(str, &numstr, m->name);
             if (!str) goto memerr;
             if (m->prop)
                 for (j = 0; j < m->numprop; j++) {
                     if (!(flags & M3D_EXP_NOCMAP) && m->prop[j].type < 128) {
                         for (l = 0; l < sizeof(m3d_propertytypes) / sizeof(m3d_propertytypes[0]); l++) {
                             if (m->prop[j].type == m3d_propertytypes[l].id && m3d_propertytypes[l].format == m3dpf_color) {
                                 ((uint8_t *)&m->prop[j].value.color)[3] = opa[i * 2 + 1];
                                 cmap = _m3d_addcmap(cmap, &numcmap, m->prop[j].value.color);
                                 if (!cmap) goto memerr;
                                 break;
                             }
                         }
                     }
                     if (m->prop[j].type >= 128 && m->prop[j].value.textureid < model->numtexture &&
                             model->texture[m->prop[j].value.textureid].name) {
                         str = _m3d_addstr(str, &numstr, model->texture[m->prop[j].value.textureid].name);
                         if (!str) goto memerr;
                     }
                 }
         }
     }
     /* if there's only one black color, don't store it */
     if (numcmap == 1 && cmap && !cmap[0]) numcmap = 0;
 
     /** compress lists **/
     if (model->numtmap && !(flags & M3D_EXP_NOTXTCRD)) {
         M3D_LOG("Compressing tmap");
         tmap = (m3dtisave_t *)M3D_MALLOC(model->numtmap * sizeof(m3dtisave_t));
         if (!tmap) goto memerr;
         for (i = 0; i < model->numtmap; i++) {
             if (tmapidx[i] == M3D_UNDEF) continue;
             switch (quality) {
             case M3D_EXP_INT8:
                 l = (unsigned int)(model->tmap[i].u * 255);
                 tcoord.data.u = (M3D_FLOAT)l / (M3D_FLOAT)255.0;
                 l = (unsigned int)(model->tmap[i].v * 255);
                 tcoord.data.v = (M3D_FLOAT)l / (M3D_FLOAT)255.0;
                 break;
             case M3D_EXP_INT16:
                 l = (unsigned int)(model->tmap[i].u * 65535);
                 tcoord.data.u = (M3D_FLOAT)l / (M3D_FLOAT)65535.0;
                 l = (unsigned int)(model->tmap[i].v * 65535);
                 tcoord.data.v = (M3D_FLOAT)l / (M3D_FLOAT)65535.0;
                 break;
             default:
                 tcoord.data.u = model->tmap[i].u;
                 tcoord.data.v = model->tmap[i].v;
                 break;
             }
             if (flags & M3D_EXP_FLIPTXTCRD)
                 tcoord.data.v = (M3D_FLOAT)1.0 - tcoord.data.v;
             tcoord.oldidx = i;
             memcpy(&tmap[numtmap++], &tcoord, sizeof(m3dtisave_t));
         }
         if (numtmap) {
             qsort(tmap, numtmap, sizeof(m3dtisave_t), _m3d_ticmp);
             memcpy(&tcoord.data, &tmap[0], sizeof(m3dti_t));
             for (i = 0; i < numtmap; i++) {
                 if (memcmp(&tcoord.data, &tmap[i].data, sizeof(m3dti_t))) {
                     memcpy(&tcoord.data, &tmap[i].data, sizeof(m3dti_t));
                     maxtmap++;
                 }
                 tmap[i].newidx = maxtmap;
                 tmapidx[tmap[i].oldidx] = maxtmap;
             }
             maxtmap++;
         }
     }
     if (model->numskin && model->skin && !(flags & M3D_EXP_NOBONE)) {
         M3D_LOG("Compressing skin");
         skinidx = (M3D_INDEX *)M3D_MALLOC(model->numskin * sizeof(M3D_INDEX));
         if (!skinidx) goto memerr;
         skin = (m3dssave_t *)M3D_MALLOC(model->numskin * sizeof(m3dssave_t));
         if (!skin) goto memerr;
         memset(skinidx, 255, model->numskin * sizeof(M3D_INDEX));
         for (i = 0; i < model->numvertex; i++) {
             if (vrtxidx[i] != M3D_UNDEF && model->vertex[i].skinid < model->numskin)
                 skinidx[model->vertex[i].skinid] = 0;
         }
         for (i = 0; i < model->numskin; i++) {
             if (skinidx[i] == M3D_UNDEF) continue;
             memset(&sk, 0, sizeof(m3dssave_t));
             for (j = 0, min_x = (M3D_FLOAT)0.0; j < M3D_NUMBONE && model->skin[i].boneid[j] != M3D_UNDEF &&
                                                 model->skin[i].weight[j] > (M3D_FLOAT)0.0;
                     j++) {
                 sk.data.boneid[j] = model->skin[i].boneid[j];
                 sk.data.weight[j] = model->skin[i].weight[j];
                 min_x += sk.data.weight[j];
             }
             if (j > maxbone) maxbone = j;
             if (min_x != (M3D_FLOAT)1.0 && min_x != (M3D_FLOAT)0.0)
                 for (j = 0; j < M3D_NUMBONE && sk.data.weight[j] > (M3D_FLOAT)0.0; j++)
                     sk.data.weight[j] /= min_x;
             sk.oldidx = i;
             memcpy(&skin[numskin++], &sk, sizeof(m3dssave_t));
         }
         if (numskin) {
             qsort(skin, numskin, sizeof(m3dssave_t), _m3d_skincmp);
             memcpy(&sk.data, &skin[0].data, sizeof(m3ds_t));
             for (i = 0; i < numskin; i++) {
                 if (memcmp(&sk.data, &skin[i].data, sizeof(m3ds_t))) {
                     memcpy(&sk.data, &skin[i].data, sizeof(m3ds_t));
                     maxskin++;
                 }
                 skin[i].newidx = maxskin;
                 skinidx[skin[i].oldidx] = maxskin;
             }
             maxskin++;
         }
     }
 
     M3D_LOG("Compressing vertex list");
     min_x = min_y = min_z = (M3D_FLOAT)1e10;
     max_x = max_y = max_z = (M3D_FLOAT)-1e10;
     if (vrtxidx) {
         vrtx = (m3dvsave_t *)M3D_MALLOC(model->numvertex * sizeof(m3dvsave_t));
         if (!vrtx) goto memerr;
         for (i = numvrtx = 0; i < model->numvertex; i++) {
             if (vrtxidx[i] == M3D_UNDEF) continue;
             _m3d_round(quality, &model->vertex[i], &vertex.data);
             vertex.norm = norm ? norm[i] : 0;
             if (vertex.data.skinid != M3D_INDEXMAX && !vertex.norm) {
                 vertex.data.skinid = vertex.data.skinid != M3D_UNDEF && skinidx ? skinidx[vertex.data.skinid] : M3D_UNDEF;
                 if (vertex.data.x > max_x) max_x = vertex.data.x;
                 if (vertex.data.x < min_x) min_x = vertex.data.x;
                 if (vertex.data.y > max_y) max_y = vertex.data.y;
                 if (vertex.data.y < min_y) min_y = vertex.data.y;
                 if (vertex.data.z > max_z) max_z = vertex.data.z;
                 if (vertex.data.z < min_z) min_z = vertex.data.z;
             }
 #ifdef M3D_VERTEXTYPE
             vertex.data.type = 0;
 #endif
             vertex.oldidx = i;
             memcpy(&vrtx[numvrtx++], &vertex, sizeof(m3dvsave_t));
         }
         if (numvrtx) {
             qsort(vrtx, numvrtx, sizeof(m3dvsave_t), _m3d_vrtxcmp);
             memcpy(&vertex.data, &vrtx[0].data, sizeof(m3dv_t));
             for (i = 0; i < numvrtx; i++) {
                 if (memcmp(&vertex.data, &vrtx[i].data, vrtx[i].norm ? 3 * sizeof(M3D_FLOAT) : sizeof(m3dv_t))) {
                     memcpy(&vertex.data, &vrtx[i].data, sizeof(m3dv_t));
                     maxvrtx++;
                 }
                 vrtx[i].newidx = maxvrtx;
                 vrtxidx[vrtx[i].oldidx] = maxvrtx;
             }
             maxvrtx++;
         }
     }
     if (skinidx) {
         M3D_FREE(skinidx);
         skinidx = NULL;
     }
     if (norm) {
         M3D_FREE(norm);
         norm = NULL;
     }
 
     /* normalize to bounding cube */
     if (numvrtx && !(flags & M3D_EXP_NORECALC)) {
         M3D_LOG("Normalizing coordinates");
         if (min_x < (M3D_FLOAT)0.0) min_x = -min_x;
         if (max_x < (M3D_FLOAT)0.0) max_x = -max_x;
         if (min_y < (M3D_FLOAT)0.0) min_y = -min_y;
         if (max_y < (M3D_FLOAT)0.0) max_y = -max_y;
         if (min_z < (M3D_FLOAT)0.0) min_z = -min_z;
         if (max_z < (M3D_FLOAT)0.0) max_z = -max_z;
         scale = min_x;
         if (max_x > scale) scale = max_x;
         if (min_y > scale) scale = min_y;
         if (max_y > scale) scale = max_y;
         if (min_z > scale) scale = min_z;
         if (max_z > scale) scale = max_z;
         if (scale == (M3D_FLOAT)0.0) scale = (M3D_FLOAT)1.0;
         if (scale != (M3D_FLOAT)1.0) {
             for (i = 0; i < numvrtx; i++) {
                 if (vrtx[i].data.skinid == M3D_INDEXMAX) continue;
                 vrtx[i].data.x /= scale;
                 vrtx[i].data.y /= scale;
                 vrtx[i].data.z /= scale;
             }
         }
     }
     if (model->scale > (M3D_FLOAT)0.0) scale = model->scale;
     if (scale <= (M3D_FLOAT)0.0) scale = (M3D_FLOAT)1.0;
 
     /* meta info */
     sn = _m3d_safestr(model->name && *model->name ? model->name : (char *)"(noname)", 2);
     sl = _m3d_safestr(model->license ? model->license : (char *)"MIT", 2);
     sa = _m3d_safestr(model->author ? model->author : getenv("LOGNAME"), 2);
     if (!sn || !sl || !sa) {
     memerr:
         if (vrtxidx) M3D_FREE(vrtxidx);
         if (mtrlidx) M3D_FREE(mtrlidx);
         if (tmapidx) M3D_FREE(tmapidx);
         if (skinidx) M3D_FREE(skinidx);
         if (grpidx) M3D_FREE(grpidx);
         if (norm) M3D_FREE(norm);
         if (face) M3D_FREE(face);
         if (cmap) M3D_FREE(cmap);
         if (tmap) M3D_FREE(tmap);
         if (skin) M3D_FREE(skin);
         if (str) M3D_FREE(str);
         if (vrtx) M3D_FREE(vrtx);
         if (sn) M3D_FREE(sn);
         if (sl) M3D_FREE(sl);
         if (sa) M3D_FREE(sa);
         if (sd) M3D_FREE(sd);
         if (out) M3D_FREE(out);
         if (h) M3D_FREE(h);
         M3D_LOG("Out of memory");
         model->errcode = M3D_ERR_ALLOC;
         return NULL;
     }
 
     M3D_LOG("Serializing model");
     if (flags & M3D_EXP_ASCII) {
         /* use CRLF to make model creators on Win happy... */
         sd = _m3d_safestr(model->desc, 1);
         if (!sd) goto memerr;
         ol = setlocale(LC_NUMERIC, NULL);
         setlocale(LC_NUMERIC, "C");
         /* header */
         len = 64 + (unsigned int)(strlen(sn) + strlen(sl) + strlen(sa) + strlen(sd));
         out = (unsigned char *)M3D_MALLOC(len);
         if (!out) {
             setlocale(LC_NUMERIC, ol);
             goto memerr;
         }
         ptr = (char *)out;
         ptr += sprintf(ptr, "3dmodel %g\r\n%s\r\n%s\r\n%s\r\n%s\r\n\r\n", scale,
                 sn, sl, sa, sd);
         M3D_FREE(sl);
         M3D_FREE(sa);
         M3D_FREE(sd);
         sl = sa = sd = NULL;
         /* preview chunk */
         if (model->preview.data && model->preview.length) {
             sl = _m3d_safestr(sn, 0);
             if (sl) {
                 ptr -= (uintptr_t)out;
                 len = (unsigned int)((uintptr_t)ptr + (uintptr_t)20);
                 out = (unsigned char *)M3D_REALLOC(out, len);
                 ptr += (uintptr_t)out;
                 if (!out) {
                     setlocale(LC_NUMERIC, ol);
                     goto memerr;
                 }
                 ptr += sprintf(ptr, "Preview\r\n%s.png\r\n\r\n", sl);
                 M3D_FREE(sl);
                 sl = NULL;
             }
         }
         M3D_FREE(sn);
         sn = NULL;
         /* texture map */
         if (numtmap && tmap && !(flags & M3D_EXP_NOTXTCRD) && !(flags & M3D_EXP_NOFACE)) {
             ptr -= (uintptr_t)out;
             len = (unsigned int)((uintptr_t)ptr + (uintptr_t)(maxtmap * 32) + (uintptr_t)12);
             out = (unsigned char *)M3D_REALLOC(out, len);
             ptr += (uintptr_t)out;
             if (!out) {
                 setlocale(LC_NUMERIC, ol);
                 goto memerr;
             }
             ptr += sprintf(ptr, "Textmap\r\n");
             last = M3D_UNDEF;
             for (i = 0; i < numtmap; i++) {
                 if (tmap[i].newidx == last) continue;
                 last = tmap[i].newidx;
                 ptr += sprintf(ptr, "%g %g\r\n", tmap[i].data.u, tmap[i].data.v);
             }
             ptr += sprintf(ptr, "\r\n");
         }
         /* vertex chunk */
         if (numvrtx && vrtx && !(flags & M3D_EXP_NOFACE)) {
             ptr -= (uintptr_t)out;
             len = (unsigned int)((uintptr_t)ptr + (uintptr_t)(maxvrtx * 128) + (uintptr_t)10);
             out = (unsigned char *)M3D_REALLOC(out, len);
             ptr += (uintptr_t)out;
             if (!out) {
                 setlocale(LC_NUMERIC, ol);
                 goto memerr;
             }
             ptr += sprintf(ptr, "Vertex\r\n");
             last = M3D_UNDEF;
             for (i = 0; i < numvrtx; i++) {
                 if (vrtx[i].newidx == last) continue;
                 last = vrtx[i].newidx;
                 ptr += sprintf(ptr, "%g %g %g %g", vrtx[i].data.x, vrtx[i].data.y, vrtx[i].data.z, vrtx[i].data.w);
                 if (!(flags & M3D_EXP_NOCMAP) && vrtx[i].data.color)
                     ptr += sprintf(ptr, " #%08x", vrtx[i].data.color);
                 if (!(flags & M3D_EXP_NOBONE) && model->numbone && maxskin && vrtx[i].data.skinid < M3D_INDEXMAX) {
                     if (skin[vrtx[i].data.skinid].data.weight[0] == (M3D_FLOAT)1.0)
                         ptr += sprintf(ptr, " %d", skin[vrtx[i].data.skinid].data.boneid[0]);
                     else
                         for (j = 0; j < M3D_NUMBONE && skin[vrtx[i].data.skinid].data.boneid[j] != M3D_UNDEF &&
                                     skin[vrtx[i].data.skinid].data.weight[j] > (M3D_FLOAT)0.0;
                                 j++)
                             ptr += sprintf(ptr, " %d:%g", skin[vrtx[i].data.skinid].data.boneid[j],
                                     skin[vrtx[i].data.skinid].data.weight[j]);
                 }
                 ptr += sprintf(ptr, "\r\n");
             }
             ptr += sprintf(ptr, "\r\n");
         }
         /* bones chunk */
         if (model->numbone && model->bone && !(flags & M3D_EXP_NOBONE)) {
             ptr -= (uintptr_t)out;
             len = (unsigned int)((uintptr_t)ptr + (uintptr_t)9);
             for (i = 0; i < model->numbone; i++) {
                 len += (unsigned int)strlen(model->bone[i].name) + 128;
             }
             out = (unsigned char *)M3D_REALLOC(out, len);
             ptr += (uintptr_t)out;
             if (!out) {
                 setlocale(LC_NUMERIC, ol);
                 goto memerr;
             }
             ptr += sprintf(ptr, "Bones\r\n");
             ptr = _m3d_prtbone(ptr, model->bone, model->numbone, M3D_UNDEF, 0, vrtxidx);
             ptr += sprintf(ptr, "\r\n");
         }
         /* materials */
         if (model->nummaterial && !(flags & M3D_EXP_NOMATERIAL)) {
             for (j = 0; j < model->nummaterial; j++) {
                 if (mtrlidx[j] == M3D_UNDEF || !model->material[j].numprop || !model->material[j].prop) continue;
                 m = &model->material[j];
                 sn = _m3d_safestr(m->name, 0);
                 if (!sn) {
                     setlocale(LC_NUMERIC, ol);
                     goto memerr;
                 }
                 ptr -= (uintptr_t)out;
                 len = (unsigned int)((uintptr_t)ptr + (uintptr_t)strlen(sn) + (uintptr_t)12);
                 for (i = 0; i < m->numprop; i++) {
                     if (m->prop[i].type < 128)
                         len += 32;
                     else if (m->prop[i].value.textureid < model->numtexture && model->texture[m->prop[i].value.textureid].name)
                         len += (unsigned int)strlen(model->texture[m->prop[i].value.textureid].name) + 16;
                 }
                 out = (unsigned char *)M3D_REALLOC(out, len);
                 ptr += (uintptr_t)out;
                 if (!out) {
                     setlocale(LC_NUMERIC, ol);
                     goto memerr;
                 }
                 ptr += sprintf(ptr, "Material %s\r\n", sn);
                 M3D_FREE(sn);
                 sn = NULL;
                 for (i = 0; i < m->numprop; i++) {
                     k = 256;
                     if (m->prop[i].type >= 128) {
                         for (l = 0; l < sizeof(m3d_propertytypes) / sizeof(m3d_propertytypes[0]); l++)
                             if (m->prop[i].type == m3d_propertytypes[l].id) {
                                 sn = m3d_propertytypes[l].key;
                                 break;
                             }
                         if (!sn)
                             for (l = 0; l < sizeof(m3d_propertytypes) / sizeof(m3d_propertytypes[0]); l++)
                                 if (m->prop[i].type - 128 == m3d_propertytypes[l].id) {
                                     sn = m3d_propertytypes[l].key;
                                     break;
                                 }
                         k = sn ? m3dpf_map : 256;
                     } else {
                         for (l = 0; l < sizeof(m3d_propertytypes) / sizeof(m3d_propertytypes[0]); l++)
                             if (m->prop[i].type == m3d_propertytypes[l].id) {
                                 sn = m3d_propertytypes[l].key;
                                 k = m3d_propertytypes[l].format;
                                 break;
                             }
                     }
                     switch (k) {
                     case m3dpf_color: ptr += sprintf(ptr, "%s #%08x\r\n", sn, m->prop[i].value.color); break;
                     case m3dpf_uint8:
                     case m3dpf_uint16:
                     case m3dpf_uint32: ptr += sprintf(ptr, "%s %d\r\n", sn, m->prop[i].value.num); break;
                     case m3dpf_float: ptr += sprintf(ptr, "%s %g\r\n", sn, m->prop[i].value.fnum); break;
                     case m3dpf_map:
                         if (m->prop[i].value.textureid < model->numtexture &&
                                 model->texture[m->prop[i].value.textureid].name) {
                             sl = _m3d_safestr(model->texture[m->prop[i].value.textureid].name, 0);
                             if (!sl) {
                                 setlocale(LC_NUMERIC, ol);
                                 goto memerr;
                             }
                             if (*sl)
                                 ptr += sprintf(ptr, "map_%s %s\r\n", sn, sl);
                             M3D_FREE(sn);
                             M3D_FREE(sl);
                             sl = NULL;
                         }
                         break;
                     }
                     sn = NULL;
                 }
                 ptr += sprintf(ptr, "\r\n");
             }
         }
         /* procedural face */
         if (model->numinlined && model->inlined && !(flags & M3D_EXP_NOFACE)) {
             /* all inlined assets which are not textures should be procedural surfaces */
             for (j = 0; j < model->numinlined; j++) {
                 if (!model->inlined[j].name || !*model->inlined[j].name || !model->inlined[j].length || !model->inlined[j].data ||
                         (model->inlined[j].data[1] == 'P' && model->inlined[j].data[2] == 'N' && model->inlined[j].data[3] == 'G'))
                     continue;
                 for (i = k = 0; i < model->numtexture; i++) {
                     if (!strcmp(model->inlined[j].name, model->texture[i].name)) {
                         k = 1;
                         break;
                     }
                 }
                 if (k) continue;
                 sn = _m3d_safestr(model->inlined[j].name, 0);
                 if (!sn) {
                     setlocale(LC_NUMERIC, ol);
                     goto memerr;
                 }
                 ptr -= (uintptr_t)out;
                 len = (unsigned int)((uintptr_t)ptr + (uintptr_t)strlen(sn) + (uintptr_t)18);
                 out = (unsigned char *)M3D_REALLOC(out, len);
                 ptr += (uintptr_t)out;
                 if (!out) {
                     setlocale(LC_NUMERIC, ol);
                     goto memerr;
                 }
                 ptr += sprintf(ptr, "Procedural\r\n%s\r\n\r\n", sn);
                 M3D_FREE(sn);
                 sn = NULL;
             }
         }
         /* mesh face */
         if (model->numface && face && !(flags & M3D_EXP_NOFACE)) {
             ptr -= (uintptr_t)out;
             len = (unsigned int)((uintptr_t)ptr + (uintptr_t)(model->numface * 128) + (uintptr_t)6);
             last = M3D_UNDEF;
             if (!(flags & M3D_EXP_NOMATERIAL))
                 for (i = 0; i < model->numface; i++) {
                     j = face[i].data.materialid < model->nummaterial ? face[i].data.materialid : M3D_UNDEF;
                     if (j != last) {
                         last = j;
                         if (last < model->nummaterial)
                             len += (unsigned int)strlen(model->material[last].name);
                         len += 6;
                     }
                 }
             out = (unsigned char *)M3D_REALLOC(out, len);
             ptr += (uintptr_t)out;
             if (!out) {
                 setlocale(LC_NUMERIC, ol);
                 goto memerr;
             }
             ptr += sprintf(ptr, "Mesh\r\n");
             last = M3D_UNDEF;
             for (i = 0; i < model->numface; i++) {
                 j = face[i].data.materialid < model->nummaterial ? face[i].data.materialid : M3D_UNDEF;
                 if (!(flags & M3D_EXP_NOMATERIAL) && j != last) {
                     last = j;
                     if (last < model->nummaterial) {
                         sn = _m3d_safestr(model->material[last].name, 0);
                         if (!sn) {
                             setlocale(LC_NUMERIC, ol);
                             goto memerr;
                         }
                         ptr += sprintf(ptr, "use %s\r\n", sn);
                         M3D_FREE(sn);
                         sn = NULL;
                     } else
                         ptr += sprintf(ptr, "use\r\n");
                 }
                 /* hardcoded triangles. Should be repeated as many times as the number of edges in polygon */
                 for (j = 0; j < 3; j++) {
                     ptr += sprintf(ptr, "%s%d", j ? " " : "", vrtxidx[face[i].data.vertex[j]]);
                     k = M3D_NOTDEFINED;
                     if (!(flags & M3D_EXP_NOTXTCRD) && (face[i].data.texcoord[j] != M3D_UNDEF) &&
                             (tmapidx[face[i].data.texcoord[j]] != M3D_UNDEF)) {
                         k = tmapidx[face[i].data.texcoord[j]];
                         ptr += sprintf(ptr, "/%d", k);
                     }
                     if (!(flags & M3D_EXP_NONORMAL) && (face[i].data.normal[j] != M3D_UNDEF))
                         ptr += sprintf(ptr, "%s/%d", k == M3D_NOTDEFINED ? "/" : "", vrtxidx[face[i].data.normal[j]]);
                 }
                 ptr += sprintf(ptr, "\r\n");
             }
             ptr += sprintf(ptr, "\r\n");
         }
         /* mathematical shapes face */
         if (model->numshape && (!(flags & M3D_EXP_NOFACE))) {
             for (j = 0; j < model->numshape; j++) {
                 sn = _m3d_safestr(model->shape[j].name, 0);
                 if (!sn) {
                     setlocale(LC_NUMERIC, ol);
                     goto memerr;
                 }
                 ptr -= (uintptr_t)out;
                 len = (unsigned int)((uintptr_t)ptr + (uintptr_t)strlen(sn) + (uintptr_t)33);
                 out = (unsigned char *)M3D_REALLOC(out, len);
                 ptr += (uintptr_t)out;
                 if (!out) {
                     setlocale(LC_NUMERIC, ol);
                     goto memerr;
                 }
                 ptr += sprintf(ptr, "Shape %s\r\n", sn);
                 M3D_FREE(sn);
                 sn = NULL;
                 if (model->shape[j].group != M3D_UNDEF && !(flags & M3D_EXP_NOBONE))
                     ptr += sprintf(ptr, "group %d\r\n", model->shape[j].group);
                 for (i = 0; i < model->shape[j].numcmd; i++) {
                     cmd = &model->shape[j].cmd[i];
                     if (cmd->type >= (unsigned int)(sizeof(m3d_commandtypes) / sizeof(m3d_commandtypes[0])) || !cmd->arg)
                         continue;
                     cd = &m3d_commandtypes[cmd->type];
                     ptr -= (uintptr_t)out;
                     len = (unsigned int)((uintptr_t)ptr + (uintptr_t)strlen(cd->key) + (uintptr_t)3);
                     for (k = 0; k < cd->p; k++)
                         switch (cd->a[k]) {
                         case m3dcp_mi_t:
                             if (cmd->arg[k] != M3D_NOTDEFINED) {
                                 len += (unsigned int)strlen(model->material[cmd->arg[k]].name) + 1;
                             }
                             break;
                         case m3dcp_va_t:
                             len += cmd->arg[k] * (cd->p - k - 1) * 16;
                             k = cd->p;
                             break;
                         default: len += 16; break;
                         }
                     out = (unsigned char *)M3D_REALLOC(out, len);
                     ptr += (uintptr_t)out;
                     if (!out) {
                         setlocale(LC_NUMERIC, ol);
                         goto memerr;
                     }
                     ptr += sprintf(ptr, "%s", cd->key);
                     for (k = n = 0, l = cd->p; k < l; k++) {
                         switch (cd->a[((k - n) % (cd->p - n)) + n]) {
                         case m3dcp_mi_t:
                             if (cmd->arg[k] != M3D_NOTDEFINED) {
                                 sn = _m3d_safestr(model->material[cmd->arg[k]].name, 0);
                                 if (!sn) {
                                     setlocale(LC_NUMERIC, ol);
                                     goto memerr;
                                 }
                                 ptr += sprintf(ptr, " %s", sn);
                                 M3D_FREE(sn);
                                 sn = NULL;
                             }
                             break;
                         case m3dcp_vc_t: ptr += sprintf(ptr, " %g", *((float *)&cmd->arg[k])); break;
                         case m3dcp_va_t:
                             ptr += sprintf(ptr, " %d[", cmd->arg[k]);
                             n = k + 1;
                             l += (cmd->arg[k] - 1) * (cd->p - k - 1);
                             break;
                         default: ptr += sprintf(ptr, " %d", cmd->arg[k]); break;
                         }
                     }
                     ptr += sprintf(ptr, "%s\r\n", l > cd->p ? " ]" : "");
                 }
                 ptr += sprintf(ptr, "\r\n");
             }
         }
         /* annotation labels */
         if (model->numlabel && model->label && !(flags & M3D_EXP_NOFACE)) {
             for (i = 0, j = 3, length = NULL; i < model->numlabel; i++) {
                 if (model->label[i].name) j += (unsigned int)strlen(model->label[i].name);
                 if (model->label[i].lang) j += (unsigned int)strlen(model->label[i].lang);
                 if (model->label[i].text) j += (unsigned int)strlen(model->label[i].text);
                 j += 40;
             }
             ptr -= (uintptr_t)out;
             len = (unsigned int)((uintptr_t)ptr + (uintptr_t)j);
             out = (unsigned char *)M3D_REALLOC(out, len);
             ptr += (uintptr_t)out;
             if (!out) {
                 setlocale(LC_NUMERIC, ol);
                 goto memerr;
             }
             for (i = 0; i < model->numlabel; i++) {
                 if (!i || _m3d_strcmp(sl, model->label[i].lang) || _m3d_strcmp(sn, model->label[i].name)) {
                     sl = model->label[i].lang;
                     sn = model->label[i].name;
                     sd = _m3d_safestr(sn, 0);
                     if (!sd) {
                         setlocale(LC_NUMERIC, ol);
                         sn = sl = NULL;
                         goto memerr;
                     }
                     if (i) ptr += sprintf(ptr, "\r\n");
                     ptr += sprintf(ptr, "Labels %s\r\n", sd);
                     M3D_FREE(sd);
                     sd = NULL;
                     if (model->label[i].color)
                         ptr += sprintf(ptr, "color #0x%08x\r\n", model->label[i].color);
                     if (sl && *sl) {
                         sd = _m3d_safestr(sl, 0);
                         if (!sd) {
                             setlocale(LC_NUMERIC, ol);
                             sn = sl = NULL;
                             goto memerr;
                         }
                         ptr += sprintf(ptr, "lang %s\r\n", sd);
                         M3D_FREE(sd);
                         sd = NULL;
                     }
                 }
                 sd = _m3d_safestr(model->label[i].text, 2);
                 if (!sd) {
                     setlocale(LC_NUMERIC, ol);
                     sn = sl = NULL;
                     goto memerr;
                 }
                 ptr += sprintf(ptr, "%d %s\r\n", model->label[i].vertexid, sd);
                 M3D_FREE(sd);
                 sd = NULL;
             }
             ptr += sprintf(ptr, "\r\n");
             sn = sl = NULL;
         }
         /* actions */
         if (model->numaction && model->action && !(flags & M3D_EXP_NOACTION)) {
             for (j = 0; j < model->numaction; j++) {
                 a = &model->action[j];
                 sn = _m3d_safestr(a->name, 0);
                 if (!sn) {
                     setlocale(LC_NUMERIC, ol);
                     goto memerr;
                 }
                 ptr -= (uintptr_t)out;
                 len = (unsigned int)((uintptr_t)ptr + (uintptr_t)strlen(sn) + (uintptr_t)48);
                 for (i = 0; i < a->numframe; i++)
                     len += a->frame[i].numtransform * 128 + 8;
                 out = (unsigned char *)M3D_REALLOC(out, len);
                 ptr += (uintptr_t)out;
                 if (!out) {
                     setlocale(LC_NUMERIC, ol);
                     goto memerr;
                 }
                 ptr += sprintf(ptr, "Action %d %s\r\n", a->durationmsec, sn);
                 M3D_FREE(sn);
                 sn = NULL;
                 for (i = 0; i < a->numframe; i++) {
                     ptr += sprintf(ptr, "frame %d\r\n", a->frame[i].msec);
                     for (k = 0; k < a->frame[i].numtransform; k++) {
                         ptr += sprintf(ptr, "%d %d %d\r\n", a->frame[i].transform[k].boneid,
                                 vrtxidx[a->frame[i].transform[k].pos], vrtxidx[a->frame[i].transform[k].ori]);
                     }
                 }
                 ptr += sprintf(ptr, "\r\n");
             }
         }
         /* inlined assets */
         if (model->numinlined && model->inlined) {
             for (i = j = 0; i < model->numinlined; i++)
                 if (model->inlined[i].name)
                     j += (unsigned int)strlen(model->inlined[i].name) + 6;
             if (j > 0) {
                 ptr -= (uintptr_t)out;
                 len = (unsigned int)((uintptr_t)ptr + (uintptr_t)j + (uintptr_t)16);
                 out = (unsigned char *)M3D_REALLOC(out, len);
                 ptr += (uintptr_t)out;
                 if (!out) {
                     setlocale(LC_NUMERIC, ol);
                     goto memerr;
                 }
                 ptr += sprintf(ptr, "Assets\r\n");
                 for (i = 0; i < model->numinlined; i++)
                     if (model->inlined[i].name)
                         ptr += sprintf(ptr, "%s%s\r\n", model->inlined[i].name, strrchr(model->inlined[i].name, '.') ? "" : ".png");
                 ptr += sprintf(ptr, "\r\n");
             }
         }
         /* extra info */
         if (model->numextra && (flags & M3D_EXP_EXTRA)) {
             for (i = 0; i < model->numextra; i++) {
                 if (model->extra[i]->length < 9) continue;
                 ptr -= (uintptr_t)out;
                 len = (unsigned int)((uintptr_t)ptr + (uintptr_t)17 + (uintptr_t)(model->extra[i]->length * 3));
                 out = (unsigned char *)M3D_REALLOC(out, len);
                 ptr += (uintptr_t)out;
                 if (!out) {
                     setlocale(LC_NUMERIC, ol);
                     goto memerr;
                 }
                 ptr += sprintf(ptr, "Extra %c%c%c%c\r\n",
                         model->extra[i]->magic[0] > ' ' ? model->extra[i]->magic[0] : '_',
                         model->extra[i]->magic[1] > ' ' ? model->extra[i]->magic[1] : '_',
                         model->extra[i]->magic[2] > ' ' ? model->extra[i]->magic[2] : '_',
                         model->extra[i]->magic[3] > ' ' ? model->extra[i]->magic[3] : '_');
                 for (j = 0; j < model->extra[i]->length; j++)
                     ptr += sprintf(ptr, "%02x ", *((unsigned char *)model->extra + sizeof(m3dchunk_t) + j));
                 ptr--;
                 ptr += sprintf(ptr, "\r\n\r\n");
             }
         }
         setlocale(LC_NUMERIC, ol);
         len = (unsigned int)((uintptr_t)ptr - (uintptr_t)out);
         out = (unsigned char *)M3D_REALLOC(out, len + 1);
         if (!out) goto memerr;
         out[len] = 0;
     } else
     {
         /* stricly only use LF (newline) in binary */
         sd = _m3d_safestr(model->desc, 3);
         if (!sd) goto memerr;
         /* header */
         h = (m3dhdr_t *)M3D_MALLOC(sizeof(m3dhdr_t) + strlen(sn) + strlen(sl) + strlen(sa) + strlen(sd) + 4);
         if (!h) goto memerr;
         memcpy((uint8_t *)h, "HEAD", 4);
         h->length = sizeof(m3dhdr_t);
         h->scale = scale;
         i = (unsigned int)strlen(sn);
         memcpy((uint8_t *)h + h->length, sn, i + 1);
         h->length += i + 1;
         M3D_FREE(sn);
         i = (unsigned int)strlen(sl);
         memcpy((uint8_t *)h + h->length, sl, i + 1);
         h->length += i + 1;
         M3D_FREE(sl);
         i = (unsigned int)strlen(sa);
         memcpy((uint8_t *)h + h->length, sa, i + 1);
         h->length += i + 1;
         M3D_FREE(sa);
         i = (unsigned int)strlen(sd);
         memcpy((uint8_t *)h + h->length, sd, i + 1);
         h->length += i + 1;
         M3D_FREE(sd);
         sn = sl = sa = sd = NULL;
         if (model->inlined)
             for (i = 0; i < model->numinlined; i++) {
                 if (model->inlined[i].name && *model->inlined[i].name && model->inlined[i].length > 0) {
                     str = _m3d_addstr(str, &numstr, model->inlined[i].name);
                     if (!str) goto memerr;
                 }
             }
         if (str)
             for (i = 0; i < numstr; i++) {
                 h = _m3d_addhdr(h, &str[i]);
                 if (!h) goto memerr;
             }
         vc_s = quality == M3D_EXP_INT8 ? 1 : (quality == M3D_EXP_INT16 ? 2 : (quality == M3D_EXP_DOUBLE ? 8 : 4));
         vi_s = maxvrtx < 254 ? 1 : (maxvrtx < 65534 ? 2 : 4);
         si_s = h->length - 16 < 254 ? 1 : (h->length - 16 < 65534 ? 2 : 4);
         ci_s = !numcmap || !cmap ? 0 : (numcmap < 254 ? 1 : (numcmap < 65534 ? 2 : 4));
         ti_s = !maxtmap || !tmap ? 0 : (maxtmap < 254 ? 1 : (maxtmap < 65534 ? 2 : 4));
         bi_s = !model->numbone || !model->bone || (flags & M3D_EXP_NOBONE) ? 0 : (model->numbone < 254 ? 1 : (model->numbone < 65534 ? 2 : 4));
         nb_s = maxbone < 2 ? 1 : (maxbone == 2 ? 2 : (maxbone <= 4 ? 4 : 8));
         sk_s = !bi_s || !maxskin || !skin ? 0 : (maxskin < 254 ? 1 : (maxskin < 65534 ? 2 : 4));
         fc_s = maxt < 254 ? 1 : (maxt < 65534 ? 2 : 4);
         hi_s = !model->numshape || !model->shape || (flags & M3D_EXP_NOFACE) ? 0 : (model->numshape < 254 ? 1 : (model->numshape < 65534 ? 2 : 4));
         fi_s = !model->numface || !model->face || (flags & M3D_EXP_NOFACE) ? 0 : (model->numface < 254 ? 1 : (model->numface < 65534 ? 2 : 4));
         h->types = (vc_s == 8 ? (3 << 0) : (vc_s == 2 ? (1 << 0) : (vc_s == 1 ? (0 << 0) : (2 << 0)))) |
                    (vi_s == 2 ? (1 << 2) : (vi_s == 1 ? (0 << 2) : (2 << 2))) |
                    (si_s == 2 ? (1 << 4) : (si_s == 1 ? (0 << 4) : (2 << 4))) |
                    (ci_s == 2 ? (1 << 6) : (ci_s == 1 ? (0 << 6) : (ci_s == 4 ? (2 << 6) : (3 << 6)))) |
                    (ti_s == 2 ? (1 << 8) : (ti_s == 1 ? (0 << 8) : (ti_s == 4 ? (2 << 8) : (3 << 8)))) |
                    (bi_s == 2 ? (1 << 10) : (bi_s == 1 ? (0 << 10) : (bi_s == 4 ? (2 << 10) : (3 << 10)))) |
                    (nb_s == 2 ? (1 << 12) : (nb_s == 1 ? (0 << 12) : (2 << 12))) |
                    (sk_s == 2 ? (1 << 14) : (sk_s == 1 ? (0 << 14) : (sk_s == 4 ? (2 << 14) : (3 << 14)))) |
                    (fc_s == 2 ? (1 << 16) : (fc_s == 1 ? (0 << 16) : (2 << 16))) |
                    (hi_s == 2 ? (1 << 18) : (hi_s == 1 ? (0 << 18) : (hi_s == 4 ? (2 << 18) : (3 << 18)))) |
                    (fi_s == 2 ? (1 << 20) : (fi_s == 1 ? (0 << 20) : (fi_s == 4 ? (2 << 20) : (3 << 20))));
         len = h->length;
         /* preview image chunk, must be the first if exists */
         if (model->preview.data && model->preview.length) {
             chunklen = 8 + model->preview.length;
             h = (m3dhdr_t *)M3D_REALLOC(h, len + chunklen);
             if (!h) goto memerr;
             memcpy((uint8_t *)h + len, "PRVW", 4);
             *((uint32_t *)((uint8_t *)h + len + 4)) = chunklen;
             memcpy((uint8_t *)h + len + 8, model->preview.data, model->preview.length);
             len += chunklen;
         }
         /* color map */
         if (numcmap && cmap && ci_s < 4 && !(flags & M3D_EXP_NOCMAP)) {
             chunklen = 8 + numcmap * sizeof(uint32_t);
             h = (m3dhdr_t *)M3D_REALLOC(h, len + chunklen);
             if (!h) goto memerr;
             memcpy((uint8_t *)h + len, "CMAP", 4);
             *((uint32_t *)((uint8_t *)h + len + 4)) = chunklen;
             memcpy((uint8_t *)h + len + 8, cmap, chunklen - 8);
             len += chunklen;
         } else
             numcmap = 0;
         /* texture map */
         if (numtmap && tmap && !(flags & M3D_EXP_NOTXTCRD) && !(flags & M3D_EXP_NOFACE)) {
             chunklen = 8 + maxtmap * vc_s * 2;
             h = (m3dhdr_t *)M3D_REALLOC(h, len + chunklen);
             if (!h) goto memerr;
             memcpy((uint8_t *)h + len, "TMAP", 4);
             length = (uint32_t *)((uint8_t *)h + len + 4);
             out = (uint8_t *)h + len + 8;
             last = M3D_UNDEF;
             for (i = 0; i < numtmap; i++) {
                 if (tmap[i].newidx == last) continue;
                 last = tmap[i].newidx;
                 switch (vc_s) {
                 case 1:
                     *out++ = (uint8_t)(tmap[i].data.u * 255);
                     *out++ = (uint8_t)(tmap[i].data.v * 255);
                     break;
                 case 2:
                     *((uint16_t *)out) = (uint16_t)(tmap[i].data.u * 65535);
                     out += 2;
                     *((uint16_t *)out) = (uint16_t)(tmap[i].data.v * 65535);
                     out += 2;
                     break;
                 case 4:
                     *((float *)out) = tmap[i].data.u;
                     out += 4;
                     *((float *)out) = tmap[i].data.v;
                     out += 4;
                     break;
                 case 8:
                     *((double *)out) = tmap[i].data.u;
                     out += 8;
                     *((double *)out) = tmap[i].data.v;
                     out += 8;
                     break;
                 }
             }
             *length = (uint32_t)((uintptr_t)out - (uintptr_t)((uint8_t *)h + len));
             out = NULL;
             len += *length;
         }
         /* vertex */
         if (numvrtx && vrtx) {
             chunklen = 8 + maxvrtx * (ci_s + sk_s + 4 * vc_s);
             h = (m3dhdr_t *)M3D_REALLOC(h, len + chunklen);
             if (!h) goto memerr;
             memcpy((uint8_t *)h + len, "VRTS", 4);
             length = (uint32_t *)((uint8_t *)h + len + 4);
             out = (uint8_t *)h + len + 8;
             last = M3D_UNDEF;
             for (i = 0; i < numvrtx; i++) {
                 if (vrtx[i].newidx == last) continue;
                 last = vrtx[i].newidx;
                 switch (vc_s) {
                 case 1:
                     *out++ = (int8_t)(vrtx[i].data.x * 127);
                     *out++ = (int8_t)(vrtx[i].data.y * 127);
                     *out++ = (int8_t)(vrtx[i].data.z * 127);
                     *out++ = (int8_t)(vrtx[i].data.w * 127);
                     break;
                 case 2:
                     *((int16_t *)out) = (int16_t)(vrtx[i].data.x * 32767);
                     out += 2;
                     *((int16_t *)out) = (int16_t)(vrtx[i].data.y * 32767);
                     out += 2;
                     *((int16_t *)out) = (int16_t)(vrtx[i].data.z * 32767);
                     out += 2;
                     *((int16_t *)out) = (int16_t)(vrtx[i].data.w * 32767);
                     out += 2;
                     break;
                 case 4:
                     memcpy(out, &vrtx[i].data.x, sizeof(float));
                     out += 4;
                     memcpy(out, &vrtx[i].data.y, sizeof(float));
                     out += 4;
                     memcpy(out, &vrtx[i].data.z, sizeof(float));
                     out += 4;
                     memcpy(out, &vrtx[i].data.w, sizeof(float));
                     out += 4;
                     break;
                 case 8:
                     *((double *)out) = vrtx[i].data.x;
                     out += 8;
                     *((double *)out) = vrtx[i].data.y;
                     out += 8;
                     *((double *)out) = vrtx[i].data.z;
                     out += 8;
                     *((double *)out) = vrtx[i].data.w;
                     out += 8;
                     break;
                 }
                 idx = _m3d_cmapidx(cmap, numcmap, vrtx[i].data.color);
                 switch (ci_s) {
                 case 1: *out++ = (uint8_t)(idx); break;
                 case 2:
                     *((uint16_t *)out) = (uint16_t)(idx);
                     out += 2;
                     break;
                 case 4:
                     *((uint32_t *)out) = vrtx[i].data.color;
                     out += 4;
                     break;
                 }
                 out = _m3d_addidx(out, sk_s, vrtx[i].data.skinid);
             }
             uint32_t v = (uint32_t)((uintptr_t)out - (uintptr_t)((uint8_t *)h + len));
             memcpy(length, &v, sizeof(uint32_t));
             //*length = (uint32_t)((uintptr_t)out - (uintptr_t)((uint8_t *)h + len));
             out = NULL;
             len += v;
         }
         /* bones chunk */
         if (model->numbone && model->bone && !(flags & M3D_EXP_NOBONE)) {
             i = 8 + bi_s + sk_s + model->numbone * (bi_s + si_s + 2 * vi_s);
             chunklen = i + numskin * nb_s * (bi_s + 1);
             h = (m3dhdr_t *)M3D_REALLOC(h, len + chunklen);
             if (!h) goto memerr;
             memcpy((uint8_t *)h + len, "BONE", 4);
             length = (uint32_t *)((uint8_t *)h + len + 4);
             out = (uint8_t *)h + len + 8;
             out = _m3d_addidx(out, bi_s, model->numbone);
             out = _m3d_addidx(out, sk_s, maxskin);
             for (i = 0; i < model->numbone; i++) {
                 out = _m3d_addidx(out, bi_s, model->bone[i].parent);
                 out = _m3d_addidx(out, si_s, _m3d_stridx(str, numstr, model->bone[i].name));
                 out = _m3d_addidx(out, vi_s, vrtxidx[model->bone[i].pos]);
                 out = _m3d_addidx(out, vi_s, vrtxidx[model->bone[i].ori]);
             }
             if (numskin && skin && sk_s) {
                 last = M3D_UNDEF;
                 for (i = 0; i < numskin; i++) {
                     if (skin[i].newidx == last) continue;
                     last = skin[i].newidx;
                     memset(&weights, 0, nb_s);
                     for (j = 0; j < (uint32_t)nb_s && skin[i].data.boneid[j] != M3D_UNDEF &&
                                 skin[i].data.weight[j] > (M3D_FLOAT)0.0;
                             j++)
                         weights[j] = (uint8_t)(skin[i].data.weight[j] * 255);
                     switch (nb_s) {
                     case 1: weights[0] = 255; break;
                     case 2:
                         *((uint16_t *)out) = *((uint16_t *)&weights[0]);
                         out += 2;
                         break;
                     case 4:
                         *((uint32_t *)out) = *((uint32_t *)&weights[0]);
                         out += 4;
                         break;
                     case 8:
                         *((uint64_t *)out) = *((uint64_t *)&weights[0]);
                         out += 8;
                         break;
                     }
                     for (j = 0; j < (uint32_t)nb_s && skin[i].data.boneid[j] != M3D_UNDEF && weights[j]; j++) {
                         out = _m3d_addidx(out, bi_s, skin[i].data.boneid[j]);
                         *length += bi_s;
                     }
                 }
             }
             *length = (uint32_t)((uintptr_t)out - (uintptr_t)((uint8_t *)h + len));
             out = NULL;
             len += *length;
         }
         /* materials */
         if (model->nummaterial && !(flags & M3D_EXP_NOMATERIAL)) {
             for (j = 0; j < model->nummaterial; j++) {
                 if (mtrlidx[j] == M3D_UNDEF || !model->material[j].numprop || !model->material[j].prop) continue;
                 m = &model->material[j];
                 chunklen = 12 + si_s + m->numprop * 5;
                 h = (m3dhdr_t *)M3D_REALLOC(h, len + chunklen);
                 if (!h) goto memerr;
                 memcpy((uint8_t *)h + len, "MTRL", 4);
                 length = (uint32_t *)((uint8_t *)h + len + 4);
                 out = (uint8_t *)h + len + 8;
                 out = _m3d_addidx(out, si_s, _m3d_stridx(str, numstr, m->name));
                 for (i = 0; i < m->numprop; i++) {
                     if (m->prop[i].type >= 128) {
                         if (m->prop[i].value.textureid >= model->numtexture ||
                                 !model->texture[m->prop[i].value.textureid].name) continue;
                         k = m3dpf_map;
                     } else {
                         for (k = 256, l = 0; l < sizeof(m3d_propertytypes) / sizeof(m3d_propertytypes[0]); l++)
                             if (m->prop[i].type == m3d_propertytypes[l].id) {
                                 k = m3d_propertytypes[l].format;
                                 break;
                             }
                     }
                     if (k == 256) continue;
                     *out++ = m->prop[i].type;
                     switch (k) {
                     case m3dpf_color:
                         if (!(flags & M3D_EXP_NOCMAP)) {
                             idx = _m3d_cmapidx(cmap, numcmap, m->prop[i].value.color);
                             switch (ci_s) {
                             case 1: *out++ = (uint8_t)(idx); break;
                             case 2:
                                 *((uint16_t *)out) = (uint16_t)(idx);
                                 out += 2;
                                 break;
                             case 4:
                                 *((uint32_t *)out) = (uint32_t)(m->prop[i].value.color);
                                 out += 4;
                                 break;
                             }
                         } else
                             out--;
                         break;
                     case m3dpf_uint8: *out++ = (uint8_t)m->prop[i].value.num; break;
                     case m3dpf_uint16:
                         *((uint16_t *)out) = (uint16_t)m->prop[i].value.num;
                         out += 2;
                         break;
                     case m3dpf_uint32:
                         *((uint32_t *)out) = m->prop[i].value.num;
                         out += 4;
                         break;
                     case m3dpf_float:
                         *((float *)out) = m->prop[i].value.fnum;
                         out += 4;
                         break;
 
                     case m3dpf_map:
                         idx = _m3d_stridx(str, numstr, model->texture[m->prop[i].value.textureid].name);
                         out = _m3d_addidx(out, si_s, idx);
                         break;
                     }
                 }
                 *length = (uint32_t)((uintptr_t)out - (uintptr_t)((uint8_t *)h + len));
                 len += *length;
                 out = NULL;
             }
         }
         /* procedural face */
         if (model->numinlined && model->inlined && !(flags & M3D_EXP_NOFACE)) {
             /* all inlined assets which are not textures should be procedural surfaces */
             for (j = 0; j < model->numinlined; j++) {
                 if (!model->inlined[j].name || !model->inlined[j].name[0] || model->inlined[j].length < 4 ||
                         !model->inlined[j].data || (model->inlined[j].data[1] == 'P' && model->inlined[j].data[2] == 'N' && model->inlined[j].data[3] == 'G'))
                     continue;
                 for (i = k = 0; i < model->numtexture; i++) {
                     if (!strcmp(model->inlined[j].name, model->texture[i].name)) {
                         k = 1;
                         break;
                     }
                 }
                 if (k) continue;
                 numproc++;
                 chunklen = 8 + si_s;
                 h = (m3dhdr_t *)M3D_REALLOC(h, len + chunklen);
                 if (!h) goto memerr;
                 memcpy((uint8_t *)h + len, "PROC", 4);
                 *((uint32_t *)((uint8_t *)h + len + 4)) = chunklen;
                 out = (uint8_t *)h + len + 8;
                 out = _m3d_addidx(out, si_s, _m3d_stridx(str, numstr, model->inlined[j].name));
                 out = NULL;
                 len += chunklen;
             }
         }
         /* mesh face */
         if (model->numface && face && !(flags & M3D_EXP_NOFACE)) {
             chunklen = 8 + si_s + model->numface * (6 * vi_s + 3 * ti_s + si_s + 1);
             h = (m3dhdr_t *)M3D_REALLOC(h, len + chunklen);
             if (!h) goto memerr;
             memcpy((uint8_t *)h + len, "MESH", 4);
             length = (uint32_t *)((uint8_t *)h + len + 4);
             out = (uint8_t *)h + len + 8;
             last = M3D_UNDEF;
             for (i = 0; i < model->numface; i++) {
                 if (!(flags & M3D_EXP_NOMATERIAL) && face[i].data.materialid != last) {
                     last = face[i].data.materialid;
                     idx = last < model->nummaterial ? _m3d_stridx(str, numstr, model->material[last].name) : 0;
                     *out++ = 0;
                     out = _m3d_addidx(out, si_s, idx);
                 }
                 /* hardcoded triangles. */
                 k = (3 << 4) |
                     (((flags & M3D_EXP_NOTXTCRD) || !ti_s || face[i].data.texcoord[0] == M3D_UNDEF ||
                              face[i].data.texcoord[1] == M3D_UNDEF || face[i].data.texcoord[2] == M3D_UNDEF) ?
                                     0 :
                                     1) |
                     (((flags & M3D_EXP_NONORMAL) || face[i].data.normal[0] == M3D_UNDEF ||
                              face[i].data.normal[1] == M3D_UNDEF || face[i].data.normal[2] == M3D_UNDEF) ?
                                     0 :
                                     2);
                 *out++ = (uint8_t)k;
                 for (j = 0; j < 3; j++) {
                     out = _m3d_addidx(out, vi_s, vrtxidx[face[i].data.vertex[j]]);
                     if (k & 1)
                         out = _m3d_addidx(out, ti_s, tmapidx[face[i].data.texcoord[j]]);
                     if (k & 2)
                         out = _m3d_addidx(out, vi_s, vrtxidx[face[i].data.normal[j]]);
                 }
             }
             uint32_t v = (uint32_t)((uintptr_t)out - (uintptr_t)((uint8_t *)h + len));
             memcpy(length, &v, sizeof(uint32_t));
             len += v;
             out = NULL;
         }
         /* mathematical shapes face */
         if (model->numshape && model->shape && !(flags & M3D_EXP_NOFACE)) {
             for (j = 0; j < model->numshape; j++) {
                 chunklen = 12 + si_s + model->shape[j].numcmd * (M3D_CMDMAXARG + 1) * 4;
                 h = (m3dhdr_t *)M3D_REALLOC(h, len + chunklen);
                 if (!h) goto memerr;
                 memcpy((uint8_t *)h + len, "SHPE", 4);
                 length = (uint32_t *)((uint8_t *)h + len + 4);
                 out = (uint8_t *)h + len + 8;
                 out = _m3d_addidx(out, si_s, _m3d_stridx(str, numstr, model->shape[j].name));
                 out = _m3d_addidx(out, bi_s, model->shape[j].group);
                 for (i = 0; i < model->shape[j].numcmd; i++) {
                     cmd = &model->shape[j].cmd[i];
                     if (cmd->type >= (unsigned int)(sizeof(m3d_commandtypes) / sizeof(m3d_commandtypes[0])) || !cmd->arg)
                         continue;
                     cd = &m3d_commandtypes[cmd->type];
                     *out++ = (cmd->type & 0x7F) | (cmd->type > 127 ? 0x80 : 0);
                     if (cmd->type > 127) *out++ = (cmd->type >> 7) & 0xff;
                     for (k = n = 0, l = cd->p; k < l; k++) {
                         switch (cd->a[((k - n) % (cd->p - n)) + n]) {
                         case m3dcp_mi_t:
                             out = _m3d_addidx(out, si_s, cmd->arg[k] < model->nummaterial ? _m3d_stridx(str, numstr, model->material[cmd->arg[k]].name) : 0);
                             break;
                         case m3dcp_vc_t:
                             min_x = *((float *)&cmd->arg[k]);
                             switch (vc_s) {
                             case 1: *out++ = (int8_t)(min_x * 127); break;
                             case 2:
                                 *((int16_t *)out) = (int16_t)(min_x * 32767);
                                 out += 2;
                                 break;
                             case 4:
                                 *((float *)out) = min_x;
                                 out += 4;
                                 break;
                             case 8:
                                 *((double *)out) = min_x;
                                 out += 8;
                                 break;
                             }
                             break;
                         case m3dcp_hi_t: out = _m3d_addidx(out, hi_s, cmd->arg[k]); break;
                         case m3dcp_fi_t: out = _m3d_addidx(out, fi_s, cmd->arg[k]); break;
                         case m3dcp_ti_t: out = _m3d_addidx(out, ti_s, cmd->arg[k]); break;
                         case m3dcp_qi_t:
                         case m3dcp_vi_t: out = _m3d_addidx(out, vi_s, cmd->arg[k]); break;
                         case m3dcp_i1_t: out = _m3d_addidx(out, 1, cmd->arg[k]); break;
                         case m3dcp_i2_t: out = _m3d_addidx(out, 2, cmd->arg[k]); break;
                         case m3dcp_i4_t: out = _m3d_addidx(out, 4, cmd->arg[k]); break;
                         case m3dcp_va_t:
                             out = _m3d_addidx(out, 4, cmd->arg[k]);
                             n = k + 1;
                             l += (cmd->arg[k] - 1) * (cd->p - k - 1);
                             break;
                         }
                     }
                 }
                 uint32_t v = (uint32_t)((uintptr_t)out - (uintptr_t)((uint8_t *)h + len));
                 memcpy( length, &v, sizeof(uint32_t));
                 len += v;
                 out = NULL;
             }
         }
         /* annotation labels */
         if (model->numlabel && model->label) {
             for (i = 0, length = NULL; i < model->numlabel; i++) {
                 if (!i || _m3d_strcmp(sl, model->label[i].lang) || _m3d_strcmp(sn, model->label[i].name)) {
                     sl = model->label[i].lang;
                     sn = model->label[i].name;
                     if (length) {
                         *length = (uint32_t)((uintptr_t)out - (uintptr_t)((uint8_t *)h + len));
                         len += *length;
                     }
                     chunklen = 8 + 2 * si_s + ci_s + model->numlabel * (vi_s + si_s);
                     h = (m3dhdr_t *)M3D_REALLOC(h, len + chunklen);
                     if (!h) {
                         sn = NULL;
                         sl = NULL;
                         goto memerr;
                     }
                     memcpy((uint8_t *)h + len, "LBLS", 4);
                     length = (uint32_t *)((uint8_t *)h + len + 4);
                     out = (uint8_t *)h + len + 8;
                     out = _m3d_addidx(out, si_s, _m3d_stridx(str, numstr, model->label[l].name));
                     out = _m3d_addidx(out, si_s, _m3d_stridx(str, numstr, model->label[l].lang));
                     idx = _m3d_cmapidx(cmap, numcmap, model->label[i].color);
                     switch (ci_s) {
                     case 1: *out++ = (uint8_t)(idx); break;
                     case 2:
                         *((uint16_t *)out) = (uint16_t)(idx);
                         out += 2;
                         break;
                     case 4:
                         *((uint32_t *)out) = model->label[i].color;
                         out += 4;
                         break;
                     }
                 }
                 out = _m3d_addidx(out, vi_s, vrtxidx[model->label[i].vertexid]);
                 out = _m3d_addidx(out, si_s, _m3d_stridx(str, numstr, model->label[l].text));
             }
             if (length) {
                 uint32_t v = (uint32_t)((uintptr_t)out - (uintptr_t)((uint8_t *)h + len));
-                memcpy( length, &v, sizeof(uint32_t));                
+                memcpy( length, &v, sizeof(uint32_t));
                 len += v;
             }
             out = NULL;
             sn = sl = NULL;
         }
         /* actions */
         if (model->numaction && model->action && model->numbone && model->bone && !(flags & M3D_EXP_NOACTION)) {
             for (j = 0; j < model->numaction; j++) {
                 a = &model->action[j];
                 chunklen = 14 + si_s + a->numframe * (4 + fc_s + maxt * (bi_s + 2 * vi_s));
                 h = (m3dhdr_t *)M3D_REALLOC(h, len + chunklen);
                 if (!h) goto memerr;
                 memcpy((uint8_t *)h + len, "ACTN", 4);
                 length = (uint32_t *)((uint8_t *)h + len + 4);
                 out = (uint8_t *)h + len + 8;
                 out = _m3d_addidx(out, si_s, _m3d_stridx(str, numstr, a->name));
                 *((uint16_t *)out) = (uint16_t)(a->numframe);
                 out += 2;
                 *((uint32_t *)out) = (uint32_t)(a->durationmsec);
                 out += 4;
                 for (i = 0; i < a->numframe; i++) {
                     *((uint32_t *)out) = (uint32_t)(a->frame[i].msec);
                     out += 4;
                     out = _m3d_addidx(out, fc_s, a->frame[i].numtransform);
                     for (k = 0; k < a->frame[i].numtransform; k++) {
                         out = _m3d_addidx(out, bi_s, a->frame[i].transform[k].boneid);
                         out = _m3d_addidx(out, vi_s, vrtxidx[a->frame[i].transform[k].pos]);
                         out = _m3d_addidx(out, vi_s, vrtxidx[a->frame[i].transform[k].ori]);
                     }
                 }
                 uint32_t v = (uint32_t)((uintptr_t)out - (uintptr_t)((uint8_t *)h + len));
-                memcpy( length, &v, sizeof(uint32_t));                
+                memcpy( length, &v, sizeof(uint32_t));
                 len += v;
                 out = NULL;
             }
         }
         /* inlined assets */
         if (model->numinlined && model->inlined && (numproc || (flags & M3D_EXP_INLINE))) {
             for (j = 0; j < model->numinlined; j++) {
                 if (!model->inlined[j].name || !model->inlined[j].name[0] || model->inlined[j].length < 4 || !model->inlined[j].data)
                     continue;
                 if (!(flags & M3D_EXP_INLINE)) {
                     if (model->inlined[j].data[1] == 'P' && model->inlined[j].data[2] == 'N' && model->inlined[j].data[3] == 'G')
                         continue;
                     for (i = k = 0; i < model->numtexture; i++) {
                         if (!strcmp(model->inlined[j].name, model->texture[i].name)) {
                             k = 1;
                             break;
                         }
                     }
                     if (k) continue;
                 }
                 chunklen = 8 + si_s + model->inlined[j].length;
                 h = (m3dhdr_t *)M3D_REALLOC(h, len + chunklen);
                 if (!h) goto memerr;
                 memcpy((uint8_t *)h + len, "ASET", 4);
                 *((uint32_t *)((uint8_t *)h + len + 4)) = chunklen;
                 out = (uint8_t *)h + len + 8;
                 out = _m3d_addidx(out, si_s, _m3d_stridx(str, numstr, model->inlined[j].name));
                 memcpy(out, model->inlined[j].data, model->inlined[j].length);
                 out = NULL;
                 len += chunklen;
             }
         }
         /* extra chunks */
         if (model->numextra && model->extra && (flags & M3D_EXP_EXTRA)) {
             for (j = 0; j < model->numextra; j++) {
                 if (!model->extra[j] || model->extra[j]->length < 8)
                     continue;
                 chunklen = model->extra[j]->length;
                 h = (m3dhdr_t *)M3D_REALLOC(h, len + chunklen);
                 if (!h) goto memerr;
                 memcpy((uint8_t *)h + len, model->extra[j], chunklen);
                 len += chunklen;
             }
         }
         /* add end chunk */
         h = (m3dhdr_t *)M3D_REALLOC(h, len + 4);
         if (!h) goto memerr;
         memcpy((uint8_t *)h + len, "OMD3", 4);
         len += 4;
         /* zlib compress */
         if (!(flags & M3D_EXP_NOZLIB)) {
             M3D_LOG("Deflating chunks");
             z = stbi_zlib_compress((unsigned char *)h, len, (int *)&l, 9);
             if (z && l > 0 && l < len) {
                 len = l;
                 M3D_FREE(h);
                 h = (m3dhdr_t *)z;
             }
         }
         /* add file header at the begining */
         len += 8;
         out = (unsigned char *)M3D_MALLOC(len);
         if (!out) goto memerr;
         memcpy(out, "3DMO", 4);
         *((uint32_t *)(out + 4)) = len;
         memcpy(out + 8, h, len - 8);
     }
     if (size) *size = out ? len : 0;
     if (vrtxidx) M3D_FREE(vrtxidx);
     if (mtrlidx) M3D_FREE(mtrlidx);
     if (tmapidx) M3D_FREE(tmapidx);
     if (skinidx) M3D_FREE(skinidx);
     if (norm) M3D_FREE(norm);
     if (face) M3D_FREE(face);
     if (cmap) M3D_FREE(cmap);
     if (tmap) M3D_FREE(tmap);
     if (skin) M3D_FREE(skin);
     if (str) M3D_FREE(str);
     if (vrtx) M3D_FREE(vrtx);
     if (h) M3D_FREE(h);
     return out;
 }
 #endif
 
 #endif /* M3D_IMPLEMENTATION */
 
 #ifdef __cplusplus
 }
 #ifdef M3D_CPPWRAPPER
 #include <memory>
 #include <string>
 #include <vector>
 
 /*** C++ wrapper class ***/
diff --git a/code/AssetLib/MD5/MD5Loader.cpp b/code/AssetLib/MD5/MD5Loader.cpp
index 0d9c77b71..9fba60c61 100644
--- a/code/AssetLib/MD5/MD5Loader.cpp
+++ b/code/AssetLib/MD5/MD5Loader.cpp
@@ -340,224 +340,224 @@ void MD5Importer::AttachChilds_Anim(int iParentID, aiNode *piParent, AnimBoneLis
 // ------------------------------------------------------------------------------------------------
 // Load a MD5MESH file
 void MD5Importer::LoadMD5MeshFile() {
     std::string filename = mFile + "md5mesh";
     std::unique_ptr<IOStream> file(mIOHandler->Open(filename, "rb"));
 
     // Check whether we can read from the file
     if (file.get() == nullptr || !file->FileSize()) {
         ASSIMP_LOG_WARN("Failed to access MD5MESH file: ", filename);
         return;
     }
     mHadMD5Mesh = true;
     LoadFileIntoMemory(file.get());
 
     // now construct a parser and parse the file
     MD5::MD5Parser parser(mBuffer, mFileSize);
 
     // load the mesh information from it
     MD5::MD5MeshParser meshParser(parser.mSections);
 
     // create the bone hierarchy - first the root node and dummy nodes for all meshes
     mScene->mRootNode = new aiNode("<MD5_Root>");
     mScene->mRootNode->mNumChildren = 2;
     mScene->mRootNode->mChildren = new aiNode *[2];
 
     // build the hierarchy from the MD5MESH file
     aiNode *pcNode = mScene->mRootNode->mChildren[1] = new aiNode();
     pcNode->mName.Set("<MD5_Hierarchy>");
     pcNode->mParent = mScene->mRootNode;
     AttachChilds_Mesh(-1, pcNode, meshParser.mJoints);
 
     pcNode = mScene->mRootNode->mChildren[0] = new aiNode();
     pcNode->mName.Set("<MD5_Mesh>");
     pcNode->mParent = mScene->mRootNode;
 
 #if 0
     if (pScene->mRootNode->mChildren[1]->mNumChildren) /* start at the right hierarchy level */
         SkeletonMeshBuilder skeleton_maker(pScene,pScene->mRootNode->mChildren[1]->mChildren[0]);
 #else
 
     // FIX: MD5 files exported from Blender can have empty meshes
     for (std::vector<MD5::MeshDesc>::const_iterator it = meshParser.mMeshes.begin(), end = meshParser.mMeshes.end(); it != end; ++it) {
         if (!(*it).mFaces.empty() && !(*it).mVertices.empty()) {
             ++mScene->mNumMaterials;
         }
     }
 
     // generate all meshes
     mScene->mNumMeshes = mScene->mNumMaterials;
     mScene->mMeshes = new aiMesh *[mScene->mNumMeshes];
     mScene->mMaterials = new aiMaterial *[mScene->mNumMeshes];
 
     //  storage for node mesh indices
     pcNode->mNumMeshes = mScene->mNumMeshes;
     pcNode->mMeshes = new unsigned int[pcNode->mNumMeshes];
     for (unsigned int m = 0; m < pcNode->mNumMeshes; ++m) {
         pcNode->mMeshes[m] = m;
     }
 
     unsigned int n = 0;
     for (std::vector<MD5::MeshDesc>::iterator it = meshParser.mMeshes.begin(), end = meshParser.mMeshes.end(); it != end; ++it) {
         MD5::MeshDesc &meshSrc = *it;
         if (meshSrc.mFaces.empty() || meshSrc.mVertices.empty()) {
             continue;
         }
 
         aiMesh *mesh = mScene->mMeshes[n] = new aiMesh();
         mesh->mPrimitiveTypes = aiPrimitiveType_TRIANGLE;
 
         // generate unique vertices in our internal verbose format
         MakeDataUnique(meshSrc);
 
         std::string name(meshSrc.mShader.C_Str());
         name += ".msh";
         mesh->mName = name;
         mesh->mNumVertices = (unsigned int)meshSrc.mVertices.size();
         mesh->mVertices = new aiVector3D[mesh->mNumVertices];
         mesh->mTextureCoords[0] = new aiVector3D[mesh->mNumVertices];
         mesh->mNumUVComponents[0] = 2;
 
         // copy texture coordinates
         aiVector3D *pv = mesh->mTextureCoords[0];
         for (MD5::VertexList::const_iterator iter = meshSrc.mVertices.begin(); iter != meshSrc.mVertices.end(); ++iter, ++pv) {
             pv->x = (*iter).mUV.x;
             pv->y = 1.0f - (*iter).mUV.y; // D3D to OpenGL
             pv->z = 0.0f;
         }
 
         // sort all bone weights - per bone
         unsigned int *piCount = new unsigned int[meshParser.mJoints.size()];
         ::memset(piCount, 0, sizeof(unsigned int) * meshParser.mJoints.size());
 
         for (MD5::VertexList::const_iterator iter = meshSrc.mVertices.begin(); iter != meshSrc.mVertices.end(); ++iter, ++pv) {
             for (unsigned int jub = (*iter).mFirstWeight, w = jub; w < jub + (*iter).mNumWeights; ++w) {
                 MD5::WeightDesc &weightDesc = meshSrc.mWeights[w];
                 /* FIX for some invalid exporters */
                 if (!(weightDesc.mWeight < AI_MD5_WEIGHT_EPSILON && weightDesc.mWeight >= -AI_MD5_WEIGHT_EPSILON)) {
                     ++piCount[weightDesc.mBone];
                 }
             }
         }
 
         // check how many we will need
         for (unsigned int p = 0; p < meshParser.mJoints.size(); ++p) {
             if (piCount[p]) mesh->mNumBones++;
         }
 
         // just for safety
         if (mesh->mNumBones) {
             mesh->mBones = new aiBone *[mesh->mNumBones];
             for (unsigned int q = 0, h = 0; q < meshParser.mJoints.size(); ++q) {
                 if (!piCount[q]) continue;
                 aiBone *p = mesh->mBones[h] = new aiBone();
                 p->mNumWeights = piCount[q];
                 p->mWeights = new aiVertexWeight[p->mNumWeights];
                 p->mName = aiString(meshParser.mJoints[q].mName);
                 p->mOffsetMatrix = meshParser.mJoints[q].mInvTransform;
 
                 // store the index for later use
                 MD5::BoneDesc &boneSrc = meshParser.mJoints[q];
                 boneSrc.mMap = h++;
 
                 // compute w-component of quaternion
                 MD5::ConvertQuaternion(boneSrc.mRotationQuat, boneSrc.mRotationQuatConverted);
             }
 
             pv = mesh->mVertices;
             for (MD5::VertexList::const_iterator iter = meshSrc.mVertices.begin(); iter != meshSrc.mVertices.end(); ++iter, ++pv) {
                 // compute the final vertex position from all single weights
                 *pv = aiVector3D();
 
                 // there are models which have weights which don't sum to 1 ...
                 ai_real fSum = 0.0;
                 for (unsigned int jub = (*iter).mFirstWeight, w = jub; w < jub + (*iter).mNumWeights; ++w) {
                     fSum += meshSrc.mWeights[w].mWeight;
                 }
                 if (!fSum) {
                     ASSIMP_LOG_ERROR("MD5MESH: The sum of all vertex bone weights is 0");
                     continue;
                 }
 
                 // process bone weights
                 for (unsigned int jub = (*iter).mFirstWeight, w = jub; w < jub + (*iter).mNumWeights; ++w) {
                     if (w >= meshSrc.mWeights.size()) {
                         throw DeadlyImportError("MD5MESH: Invalid weight index");
                     }
 
                     MD5::WeightDesc &weightDesc = meshSrc.mWeights[w];
-                    if (weightDesc.mWeight < AI_MD5_WEIGHT_EPSILON && weightDesc.mWeight >= -AI_MD5_WEIGHT_EPSILON) { 
+                    if (weightDesc.mWeight < AI_MD5_WEIGHT_EPSILON && weightDesc.mWeight >= -AI_MD5_WEIGHT_EPSILON) {
                         continue;
                     }
 
                     const ai_real fNewWeight = weightDesc.mWeight / fSum;
 
                     // transform the local position into worldspace
                     MD5::BoneDesc &boneSrc = meshParser.mJoints[weightDesc.mBone];
                     const aiVector3D v = boneSrc.mRotationQuatConverted.Rotate(weightDesc.vOffsetPosition);
 
                     // use the original weight to compute the vertex position
                     // (some MD5s seem to depend on the invalid weight values ...)
                     *pv += ((boneSrc.mPositionXYZ + v) * (ai_real)weightDesc.mWeight);
 
                     aiBone *bone = mesh->mBones[boneSrc.mMap];
                     *bone->mWeights++ = aiVertexWeight((unsigned int)(pv - mesh->mVertices), fNewWeight);
                 }
             }
 
             // undo our nice offset tricks ...
             for (unsigned int p = 0; p < mesh->mNumBones; ++p) {
                 mesh->mBones[p]->mWeights -= mesh->mBones[p]->mNumWeights;
             }
         }
 
         delete[] piCount;
 
         // now setup all faces - we can directly copy the list
         // (however, take care that the aiFace destructor doesn't delete the mIndices array)
         mesh->mNumFaces = (unsigned int)meshSrc.mFaces.size();
         mesh->mFaces = new aiFace[mesh->mNumFaces];
         for (unsigned int c = 0; c < mesh->mNumFaces; ++c) {
             mesh->mFaces[c].mNumIndices = 3;
             mesh->mFaces[c].mIndices = meshSrc.mFaces[c].mIndices;
             meshSrc.mFaces[c].mIndices = nullptr;
         }
 
         // generate a material for the mesh
         aiMaterial *mat = new aiMaterial();
         mScene->mMaterials[n] = mat;
 
         // insert the typical doom3 textures:
         // nnn_local.tga  - normal map
         // nnn_h.tga      - height map
         // nnn_s.tga      - specular map
         // nnn_d.tga      - diffuse map
         if (meshSrc.mShader.length && !strchr(meshSrc.mShader.data, '.')) {
 
             aiString temp(meshSrc.mShader);
             temp.Append("_local.tga");
             mat->AddProperty(&temp, AI_MATKEY_TEXTURE_NORMALS(0));
 
             temp = aiString(meshSrc.mShader);
             temp.Append("_s.tga");
             mat->AddProperty(&temp, AI_MATKEY_TEXTURE_SPECULAR(0));
 
             temp = aiString(meshSrc.mShader);
             temp.Append("_d.tga");
             mat->AddProperty(&temp, AI_MATKEY_TEXTURE_DIFFUSE(0));
 
             temp = aiString(meshSrc.mShader);
             temp.Append("_h.tga");
             mat->AddProperty(&temp, AI_MATKEY_TEXTURE_HEIGHT(0));
 
             // set this also as material name
             mat->AddProperty(&meshSrc.mShader, AI_MATKEY_NAME);
         } else {
             mat->AddProperty(&meshSrc.mShader, AI_MATKEY_TEXTURE_DIFFUSE(0));
         }
         mesh->mMaterialIndex = n++;
     }
 #endif
 }
 
 // ------------------------------------------------------------------------------------------------
 // Load an MD5ANIM file
diff --git a/code/AssetLib/MDC/MDCFileData.h b/code/AssetLib/MDC/MDCFileData.h
index 616556f03..a8f3aea43 100644
--- a/code/AssetLib/MDC/MDCFileData.h
+++ b/code/AssetLib/MDC/MDCFileData.h
@@ -98,43 +98,43 @@ struct Header {
 // ---------------------------------------------------------------------------
 /** \brief Data structure for a MDC file's surface header
  */
 struct Surface {
     uint32_t ulIdent ;
     char ucName [ AI_MDC_MAXQPATH ] ;
     uint32_t ulFlags ;
     uint32_t ulNumCompFrames ;
     uint32_t ulNumBaseFrames ;
     uint32_t ulNumShaders ;
     uint32_t ulNumVertices ;
     uint32_t ulNumTriangles ;
     uint32_t ulOffsetTriangles ;
     uint32_t ulOffsetShaders ;
     uint32_t ulOffsetTexCoords ;
     uint32_t ulOffsetBaseVerts ;
     uint32_t ulOffsetCompVerts ;
     uint32_t ulOffsetFrameBaseFrames ;
     uint32_t ulOffsetFrameCompFrames ;
     uint32_t ulOffsetEnd;
     Surface() AI_NO_EXCEPT
     : ulIdent()
     , ulFlags()
     , ulNumCompFrames()
     , ulNumBaseFrames()
-    , ulNumShaders() 
+    , ulNumShaders()
     , ulNumVertices()
     , ulNumTriangles()
     , ulOffsetTriangles()
     , ulOffsetShaders()
     , ulOffsetTexCoords()
-    , ulOffsetBaseVerts() 
+    , ulOffsetBaseVerts()
     , ulOffsetCompVerts()
     , ulOffsetFrameBaseFrames()
     , ulOffsetFrameCompFrames()
     , ulOffsetEnd() {
         ucName[AI_MDC_MAXQPATH-1] = '\0';
     }
 } PACK_STRUCT;
 
 // ---------------------------------------------------------------------------
 /** \brief Data structure for a MDC frame
  */
diff --git a/code/AssetLib/MDL/HalfLife/HL1MDLLoader.cpp b/code/AssetLib/MDL/HalfLife/HL1MDLLoader.cpp
index e6576b344..1ff86fe27 100644
--- a/code/AssetLib/MDL/HalfLife/HL1MDLLoader.cpp
+++ b/code/AssetLib/MDL/HalfLife/HL1MDLLoader.cpp
@@ -545,383 +545,383 @@ void HL1MDLLoader::read_bones() {
     * Because the mesh triangles are comprised of strips and
     fans, it is necessary to convert each primitive to
     triangles, respectively (3 indices per face).
 */
 void HL1MDLLoader::read_meshes() {
     if (!header_->numbodyparts) {
         return;
     }
 
     int total_verts = 0;
     int total_triangles = 0;
     total_models_ = 0;
 
     const Bodypart_HL1 *pbodypart = (const Bodypart_HL1 *)((uint8_t *)header_ + header_->bodypartindex);
     const Model_HL1 *pmodel = nullptr;
     const Mesh_HL1 *pmesh = nullptr;
 
     const Texture_HL1 *ptexture = (const Texture_HL1 *)((uint8_t *)texture_header_ + texture_header_->textureindex);
     short *pskinref = (short *)((uint8_t *)texture_header_ + texture_header_->skinindex);
 
     scene_->mNumMeshes = 0;
 
     std::vector<std::string> unique_bodyparts_names;
     unique_bodyparts_names.resize(header_->numbodyparts);
 
     // Count the number of meshes.
 
     for (int i = 0; i < header_->numbodyparts; ++i, ++pbodypart) {
         unique_bodyparts_names[i] = pbodypart->name;
 
         pmodel = (Model_HL1 *)((uint8_t *)header_ + pbodypart->modelindex);
         for (int j = 0; j < pbodypart->nummodels; ++j, ++pmodel) {
             scene_->mNumMeshes += pmodel->nummesh;
             total_verts += pmodel->numverts;
         }
 
         total_models_ += pbodypart->nummodels;
     }
 
     // Display limit infos.
     if (total_verts > AI_MDL_HL1_MAX_VERTICES) {
         log_warning_limit_exceeded<AI_MDL_HL1_MAX_VERTICES>(total_verts, "vertices");
     }
 
     if (scene_->mNumMeshes > AI_MDL_HL1_MAX_MESHES) {
         log_warning_limit_exceeded<AI_MDL_HL1_MAX_MESHES>(scene_->mNumMeshes, "meshes");
     }
 
     if (total_models_ > AI_MDL_HL1_MAX_MODELS) {
         log_warning_limit_exceeded<AI_MDL_HL1_MAX_MODELS>(total_models_, "models");
     }
 
     // Ensure bodyparts have unique names.
     unique_name_generator_.set_template_name("Bodypart");
     unique_name_generator_.make_unique(unique_bodyparts_names);
 
     // Now do the same for each model.
     pbodypart = (const Bodypart_HL1 *)((uint8_t *)header_ + header_->bodypartindex);
 
     // Prepare template name for bodypart models.
     std::vector<std::string> unique_models_names;
     unique_models_names.resize(total_models_);
 
     unsigned int model_index = 0;
 
     for (int i = 0; i < header_->numbodyparts; ++i, ++pbodypart) {
         pmodel = (Model_HL1 *)((uint8_t *)header_ + pbodypart->modelindex);
         for (int j = 0; j < pbodypart->nummodels; ++j, ++pmodel, ++model_index)
             unique_models_names[model_index] = pmodel->name;
     }
 
     unique_name_generator_.set_template_name("Model");
     unique_name_generator_.make_unique(unique_models_names);
 
     unsigned int mesh_index = 0;
 
     scene_->mMeshes = new aiMesh *[scene_->mNumMeshes];
 
     pbodypart = (const Bodypart_HL1 *)((uint8_t *)header_ + header_->bodypartindex);
 
     /* Create a node that will represent the mesh hierarchy.
 
         <MDL_bodyparts>
             |
             +-- bodypart --+-- model -- [mesh index, mesh index, ...]
             |              |
             |              +-- model -- [mesh index, mesh index, ...]
-            |              |           
+            |              |
             |              ...
             |
             |-- bodypart -- ...
             |
             ...
      */
     aiNode *bodyparts_node = new aiNode(AI_MDL_HL1_NODE_BODYPARTS);
     rootnode_children_.push_back(bodyparts_node);
     bodyparts_node->mNumChildren = static_cast<unsigned int>(header_->numbodyparts);
     bodyparts_node->mChildren = new aiNode *[bodyparts_node->mNumChildren];
     aiNode **bodyparts_node_ptr = bodyparts_node->mChildren;
 
     // The following variables are defined here so they don't have
     // to be recreated every iteration.
 
     // Model_HL1 vertices, in bind pose space.
     std::vector<aiVector3D> bind_pose_vertices;
 
     // Model_HL1 normals, in bind pose space.
     std::vector<aiVector3D> bind_pose_normals;
 
     // Used to contain temporary information for building a mesh.
     std::vector<HL1MeshTrivert> triverts;
 
     std::vector<short> tricmds;
 
     // Which triverts to use for the mesh.
     std::vector<short> mesh_triverts_indices;
 
     std::vector<HL1MeshFace> mesh_faces;
 
     /* triverts that have the same vertindex, but have different normindex,s,t values.
        Similar triverts are mapped from vertindex to a list of similar triverts. */
     std::map<short, std::set<short>> triverts_similars;
 
     // triverts per bone.
     std::map<int, std::set<short>> bone_triverts;
 
     /** This function adds a trivert index to the list of triverts per bone.
      * \param[in] bone The bone that affects the trivert at index \p trivert_index.
      * \param[in] trivert_index The trivert index.
      */
     auto AddTrivertToBone = [&](int bone, short trivert_index) {
         if (bone_triverts.count(bone) == 0)
             bone_triverts.insert({ bone, std::set<short>{ trivert_index }});
         else
             bone_triverts[bone].insert(trivert_index);
     };
 
     /** This function creates and appends a new trivert to the list of triverts.
      * \param[in] trivert The trivert to use as a prototype.
      * \param[in] bone The bone that affects \p trivert.
      */
     auto AddSimilarTrivert = [&](const Trivert &trivert, const int bone) {
         HL1MeshTrivert new_trivert(trivert);
         new_trivert.localindex = static_cast<short>(mesh_triverts_indices.size());
 
         short new_trivert_index = static_cast<short>(triverts.size());
 
         if (triverts_similars.count(trivert.vertindex) == 0)
             triverts_similars.insert({ trivert.vertindex, std::set<short>{ new_trivert_index }});
         else
             triverts_similars[trivert.vertindex].insert(new_trivert_index);
 
         triverts.push_back(new_trivert);
 
         mesh_triverts_indices.push_back(new_trivert_index);
         tricmds.push_back(new_trivert.localindex);
         AddTrivertToBone(bone, new_trivert.localindex);
     };
 
     model_index = 0;
 
     for (int i = 0; i < header_->numbodyparts; ++i, ++pbodypart, ++bodyparts_node_ptr) {
         pmodel = (const Model_HL1 *)((uint8_t *)header_ + pbodypart->modelindex);
 
         // Create bodypart node for the mesh tree hierarchy.
         aiNode *bodypart_node = (*bodyparts_node_ptr) = new aiNode(unique_bodyparts_names[i]);
         bodypart_node->mParent = bodyparts_node;
         bodypart_node->mMetaData = aiMetadata::Alloc(1);
         bodypart_node->mMetaData->Set(0, "Base", pbodypart->base);
 
         bodypart_node->mNumChildren = static_cast<unsigned int>(pbodypart->nummodels);
         bodypart_node->mChildren = new aiNode *[bodypart_node->mNumChildren];
         aiNode **bodypart_models_ptr = bodypart_node->mChildren;
 
         for (int j = 0; j < pbodypart->nummodels;
                 ++j, ++pmodel, ++bodypart_models_ptr, ++model_index) {
 
             pmesh = (const Mesh_HL1 *)((uint8_t *)header_ + pmodel->meshindex);
 
             uint8_t *pvertbone = ((uint8_t *)header_ + pmodel->vertinfoindex);
             uint8_t *pnormbone = ((uint8_t *)header_ + pmodel->norminfoindex);
             vec3_t *pstudioverts = (vec3_t *)((uint8_t *)header_ + pmodel->vertindex);
             vec3_t *pstudionorms = (vec3_t *)((uint8_t *)header_ + pmodel->normindex);
 
             // Each vertex and normal is in local space, so transform
             // each of them to bring them in bind pose.
             bind_pose_vertices.resize(pmodel->numverts);
             bind_pose_normals.resize(pmodel->numnorms);
             for (size_t k = 0; k < bind_pose_vertices.size(); ++k) {
                 const vec3_t &vert = pstudioverts[k];
                 bind_pose_vertices[k] = temp_bones_[pvertbone[k]].absolute_transform * aiVector3D(vert[0], vert[1], vert[2]);
             }
             for (size_t k = 0; k < bind_pose_normals.size(); ++k) {
                 const vec3_t &norm = pstudionorms[k];
                 // Compute the normal matrix to transform the normal into bind pose,
                 // without affecting its length.
                 const aiMatrix4x4 normal_matrix = aiMatrix4x4(temp_bones_[pnormbone[k]].absolute_transform).Inverse().Transpose();
                 bind_pose_normals[k] = normal_matrix * aiVector3D(norm[0], norm[1], norm[2]);
             }
 
             // Create model node for the mesh tree hierarchy.
             aiNode *model_node = (*bodypart_models_ptr) = new aiNode(unique_models_names[model_index]);
             model_node->mParent = bodypart_node;
             model_node->mNumMeshes = static_cast<unsigned int>(pmodel->nummesh);
             model_node->mMeshes = new unsigned int[model_node->mNumMeshes];
             unsigned int *model_meshes_ptr = model_node->mMeshes;
 
             for (int k = 0; k < pmodel->nummesh; ++k, ++pmesh, ++mesh_index, ++model_meshes_ptr) {
                 *model_meshes_ptr = mesh_index;
 
                 // Read triverts.
                 short *ptricmds = (short *)((uint8_t *)header_ + pmesh->triindex);
                 float texcoords_s_scale = 1.0f / (float)ptexture[pskinref[pmesh->skinref]].width;
                 float texcoords_t_scale = 1.0f / (float)ptexture[pskinref[pmesh->skinref]].height;
 
                 // Reset the data for the upcoming mesh.
                 triverts.clear();
                 triverts.resize(pmodel->numverts);
                 mesh_triverts_indices.clear();
                 mesh_faces.clear();
                 triverts_similars.clear();
                 bone_triverts.clear();
 
                 int l;
                 while ((l = *(ptricmds++))) {
                     bool is_triangle_fan = false;
 
                     if (l < 0) {
                         l = -l;
                         is_triangle_fan = true;
                     }
 
                     // Clear the list of tris for the upcoming tris.
                     tricmds.clear();
 
                     for (; l > 0; l--, ptricmds += 4) {
                         const Trivert *input_trivert = reinterpret_cast<const Trivert *>(ptricmds);
                         const int bone = pvertbone[input_trivert->vertindex];
 
                         HL1MeshTrivert *private_trivert = &triverts[input_trivert->vertindex];
                         if (private_trivert->localindex == -1) {
                             // First time referenced.
                             *private_trivert = *input_trivert;
                             private_trivert->localindex = static_cast<short>(mesh_triverts_indices.size());
                             mesh_triverts_indices.push_back(input_trivert->vertindex);
                             tricmds.push_back(private_trivert->localindex);
                             AddTrivertToBone(bone, private_trivert->localindex);
                         } else if (*private_trivert == *input_trivert) {
                             // Exists and is the same.
                             tricmds.push_back(private_trivert->localindex);
                         } else {
                             // No similar trivert associated to the trivert currently processed.
                             if (triverts_similars.count(input_trivert->vertindex) == 0)
                                 AddSimilarTrivert(*input_trivert, bone);
                             else {
                                 // Search in the list of similar triverts to see if the
                                 // trivert in process is already registered.
                                 short similar_index = -1;
                                 for (auto it = triverts_similars[input_trivert->vertindex].cbegin();
                                         similar_index == -1 && it != triverts_similars[input_trivert->vertindex].cend();
                                         ++it) {
                                     if (triverts[*it] == *input_trivert)
                                         similar_index = *it;
                                 }
 
                                 // If a similar trivert has been found, reuse it.
                                 // Otherwise, add it.
                                 if (similar_index == -1)
                                     AddSimilarTrivert(*input_trivert, bone);
                                 else
                                     tricmds.push_back(triverts[similar_index].localindex);
                             }
                         }
                     }
 
                     // Build mesh faces.
                     const int num_faces = static_cast<int>(tricmds.size() - 2);
                     mesh_faces.reserve(num_faces);
 
                     if (is_triangle_fan) {
                         for (int faceIdx = 0; faceIdx < num_faces; ++faceIdx) {
                             mesh_faces.push_back(HL1MeshFace{
                                     tricmds[0],
                                     tricmds[faceIdx + 1],
                                     tricmds[faceIdx + 2] });
                         }
                     } else {
                         for (int faceIdx = 0; faceIdx < num_faces; ++faceIdx) {
                             if (faceIdx & 1) {
                                 // Preserve winding order.
                                 mesh_faces.push_back(HL1MeshFace{
                                         tricmds[faceIdx + 1],
                                         tricmds[faceIdx],
                                         tricmds[faceIdx + 2] });
                             } else {
                                 mesh_faces.push_back(HL1MeshFace{
                                         tricmds[faceIdx],
                                         tricmds[faceIdx + 1],
                                         tricmds[faceIdx + 2] });
                             }
                         }
                     }
 
                     total_triangles += num_faces;
                 }
 
                 // Create the scene mesh.
                 aiMesh *scene_mesh = scene_->mMeshes[mesh_index] = new aiMesh();
                 scene_mesh->mPrimitiveTypes = aiPrimitiveType::aiPrimitiveType_TRIANGLE;
                 scene_mesh->mMaterialIndex = pskinref[pmesh->skinref];
 
                 scene_mesh->mNumVertices = static_cast<unsigned int>(mesh_triverts_indices.size());
 
                 if (scene_mesh->mNumVertices) {
                     scene_mesh->mVertices = new aiVector3D[scene_mesh->mNumVertices];
                     scene_mesh->mNormals = new aiVector3D[scene_mesh->mNumVertices];
 
                     scene_mesh->mNumUVComponents[0] = 2;
                     scene_mesh->mTextureCoords[0] = new aiVector3D[scene_mesh->mNumVertices];
 
                     // Add vertices.
                     for (unsigned int v = 0; v < scene_mesh->mNumVertices; ++v) {
                         const HL1MeshTrivert *pTrivert = &triverts[mesh_triverts_indices[v]];
                         scene_mesh->mVertices[v] = bind_pose_vertices[pTrivert->vertindex];
                         scene_mesh->mNormals[v] = bind_pose_normals[pTrivert->normindex];
                         scene_mesh->mTextureCoords[0][v] = aiVector3D(
                                 pTrivert->s * texcoords_s_scale,
                                 pTrivert->t * -texcoords_t_scale, 0);
                     }
 
                     // Add face and indices.
                     scene_mesh->mNumFaces = static_cast<unsigned int>(mesh_faces.size());
                     scene_mesh->mFaces = new aiFace[scene_mesh->mNumFaces];
 
                     for (unsigned int f = 0; f < scene_mesh->mNumFaces; ++f) {
                         aiFace *face = &scene_mesh->mFaces[f];
                         face->mNumIndices = 3;
                         face->mIndices = new unsigned int[3];
                         face->mIndices[0] = mesh_faces[f].v2;
                         face->mIndices[1] = mesh_faces[f].v1;
                         face->mIndices[2] = mesh_faces[f].v0;
                     }
 
                     // Add mesh bones.
                     scene_mesh->mNumBones = static_cast<unsigned int>(bone_triverts.size());
                     scene_mesh->mBones = new aiBone *[scene_mesh->mNumBones];
 
                     aiBone **scene_bone_ptr = scene_mesh->mBones;
 
                     for (auto bone_it = bone_triverts.cbegin();
                             bone_it != bone_triverts.cend();
                             ++bone_it, ++scene_bone_ptr) {
                         const int bone_index = bone_it->first;
 
                         aiBone *scene_bone = (*scene_bone_ptr) = new aiBone();
                         scene_bone->mName = temp_bones_[bone_index].node->mName;
 
                         scene_bone->mOffsetMatrix = temp_bones_[bone_index].offset_matrix;
 
                         auto vertex_ids = bone_triverts.at(bone_index);
 
                         // Add vertex weight per bone.
                         scene_bone->mNumWeights = static_cast<unsigned int>(vertex_ids.size());
                         aiVertexWeight *vertex_weight_ptr = scene_bone->mWeights = new aiVertexWeight[scene_bone->mNumWeights];
 
                         for (auto vertex_it = vertex_ids.begin();
                                 vertex_it != vertex_ids.end();
                                 ++vertex_it, ++vertex_weight_ptr) {
                             vertex_weight_ptr->mVertexId = *vertex_it;
                             vertex_weight_ptr->mWeight = 1.0f;
                         }
                     }
                 }
             }
         }
     }
 
     if (total_triangles > AI_MDL_HL1_MAX_TRIANGLES) {
         log_warning_limit_exceeded<AI_MDL_HL1_MAX_TRIANGLES>(total_triangles, "triangles");
     }
 }
 
 // ------------------------------------------------------------------------------------------------
@@ -1268,43 +1268,43 @@ void HL1MDLLoader::read_bone_controllers() {
 // ------------------------------------------------------------------------------------------------
 void HL1MDLLoader::read_global_info() {
     aiNode *global_info_node = new aiNode(AI_MDL_HL1_NODE_GLOBAL_INFO);
     rootnode_children_.push_back(global_info_node);
 
     aiMetadata *md = global_info_node->mMetaData = aiMetadata::Alloc(import_settings_.read_misc_global_info ? 16 : 11);
     md->Set(0, "Version", AI_MDL_HL1_VERSION);
     md->Set(1, "NumBodyparts", header_->numbodyparts);
     md->Set(2, "NumModels", total_models_);
     md->Set(3, "NumBones", header_->numbones);
     md->Set(4, "NumAttachments", import_settings_.read_attachments ? header_->numattachments : 0);
     md->Set(5, "NumSkinFamilies", texture_header_->numskinfamilies);
     md->Set(6, "NumHitboxes", import_settings_.read_hitboxes ? header_->numhitboxes : 0);
     md->Set(7, "NumBoneControllers", import_settings_.read_bone_controllers ? header_->numbonecontrollers : 0);
     md->Set(8, "NumSequences", import_settings_.read_animations ? header_->numseq : 0);
     md->Set(9, "NumBlendControllers", import_settings_.read_blend_controllers ? num_blend_controllers_ : 0);
     md->Set(10, "NumTransitionNodes", import_settings_.read_sequence_transitions ? header_->numtransitions : 0);
 
     if (import_settings_.read_misc_global_info) {
         md->Set(11, "EyePosition", aiVector3D(header_->eyeposition[0], header_->eyeposition[1], header_->eyeposition[2]));
         md->Set(12, "HullMin", aiVector3D(header_->min[0], header_->min[1], header_->min[2]));
         md->Set(13, "HullMax", aiVector3D(header_->max[0], header_->max[1], header_->max[2]));
         md->Set(14, "CollisionMin", aiVector3D(header_->bbmin[0], header_->bbmin[1], header_->bbmin[2]));
         md->Set(15, "CollisionMax", aiVector3D(header_->bbmax[0], header_->bbmax[1], header_->bbmax[2]));
     }
 }
 
 // ------------------------------------------------------------------------------------------------
 /** @brief This method reads a compressed anim value.
 *
 *   @note The structure of this method is taken from HL2 source code.
 *   Although this is from HL2, it's implementation is almost identical
 *   to code found in HL1 SDK. See HL1 and HL2 SDKs for more info.
-*   
+*
 *   source:
 *       HL1 source code.
 *           file: studio_render.cpp
 *           function(s): CalcBoneQuaternion and CalcBonePosition
 *
 *       HL2 source code.
 *           file: bone_setup.cpp
 *           function(s): ExtractAnimValue
 */
diff --git a/code/AssetLib/MMD/MMDPmxParser.cpp b/code/AssetLib/MMD/MMDPmxParser.cpp
index d57dc169a..be3b10248 100644
--- a/code/AssetLib/MMD/MMDPmxParser.cpp
+++ b/code/AssetLib/MMD/MMDPmxParser.cpp
@@ -52,554 +52,554 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 namespace pmx
 {
 	int ReadIndex(std::istream *stream, int size)
 	{
 		switch (size)
 		{
 		case 1:
 			uint8_t tmp8;
 			stream->read((char*) &tmp8, sizeof(uint8_t));
 			if (255 == tmp8)
 			{
 				return -1;
 			}
 			else {
 				return (int) tmp8;
 			}
 		case 2:
 			uint16_t tmp16;
 			stream->read((char*) &tmp16, sizeof(uint16_t));
 			if (65535 == tmp16)
 			{
 				return -1;
 			}
 			else {
 				return (int) tmp16;
 			}
 		case 4:
 			int tmp32;
 			stream->read((char*) &tmp32, sizeof(int));
 			return tmp32;
 		default:
 			return -1;
 		}
 	}
 
 	std::string ReadString(std::istream *stream, uint8_t encoding)
 	{
 		int size;
 		stream->read((char*) &size, sizeof(int));
 		std::vector<char> buffer;
 		if (size == 0)
 		{
 			return std::string();
 		}
 		buffer.reserve(size);
 		stream->read((char*) buffer.data(), size);
 		if (encoding == 0)
 		{
 			// UTF16 to UTF8
 			const uint16_t* sourceStart = (uint16_t*)buffer.data();
 			const unsigned int targetSize = size * 3; // enough to encode
 			char *targetStart = new char[targetSize];
             std::memset(targetStart, 0, targetSize * sizeof(char));
-            
+
             utf8::utf16to8( sourceStart, sourceStart + size/2, targetStart );
 
 			std::string result(targetStart);
             delete [] targetStart;
 			return result;
 		}
 		else
 		{
 			// the name is already UTF8
 			return std::string((const char*)buffer.data(), size);
 		}
 	}
 
 	void PmxSetting::Read(std::istream *stream)
 	{
 		uint8_t count;
 		stream->read((char*) &count, sizeof(uint8_t));
 		if (count < 8)
 		{
 			throw DeadlyImportError("MMD: invalid size");
 		}
 		stream->read((char*) &encoding, sizeof(uint8_t));
 		stream->read((char*) &uv, sizeof(uint8_t));
 		stream->read((char*) &vertex_index_size, sizeof(uint8_t));
 		stream->read((char*) &texture_index_size, sizeof(uint8_t));
 		stream->read((char*) &material_index_size, sizeof(uint8_t));
 		stream->read((char*) &bone_index_size, sizeof(uint8_t));
 		stream->read((char*) &morph_index_size, sizeof(uint8_t));
 		stream->read((char*) &rigidbody_index_size, sizeof(uint8_t));
 		uint8_t temp;
 		for (int i = 8; i < count; i++)
 		{
 			stream->read((char*)&temp, sizeof(uint8_t));
 		}
 	}
 
 	void PmxVertexSkinningBDEF1::Read(std::istream *stream, PmxSetting *setting)
 	{
 		this->bone_index = ReadIndex(stream, setting->bone_index_size);
 	}
 
 	void PmxVertexSkinningBDEF2::Read(std::istream *stream, PmxSetting *setting)
 	{
 		this->bone_index1 = ReadIndex(stream, setting->bone_index_size);
 		this->bone_index2 = ReadIndex(stream, setting->bone_index_size);
 		stream->read((char*) &this->bone_weight, sizeof(float));
 	}
 
 	void PmxVertexSkinningBDEF4::Read(std::istream *stream, PmxSetting *setting)
 	{
 		this->bone_index1 = ReadIndex(stream, setting->bone_index_size);
 		this->bone_index2 = ReadIndex(stream, setting->bone_index_size);
 		this->bone_index3 = ReadIndex(stream, setting->bone_index_size);
 		this->bone_index4 = ReadIndex(stream, setting->bone_index_size);
 		stream->read((char*) &this->bone_weight1, sizeof(float));
 		stream->read((char*) &this->bone_weight2, sizeof(float));
 		stream->read((char*) &this->bone_weight3, sizeof(float));
 		stream->read((char*) &this->bone_weight4, sizeof(float));
 	}
 
 	void PmxVertexSkinningSDEF::Read(std::istream *stream, PmxSetting *setting)
 	{
 		this->bone_index1 = ReadIndex(stream, setting->bone_index_size);
 		this->bone_index2 = ReadIndex(stream, setting->bone_index_size);
 		stream->read((char*) &this->bone_weight, sizeof(float));
 		stream->read((char*) this->sdef_c, sizeof(float) * 3);
 		stream->read((char*) this->sdef_r0, sizeof(float) * 3);
 		stream->read((char*) this->sdef_r1, sizeof(float) * 3);
 	}
 
 	void PmxVertexSkinningQDEF::Read(std::istream *stream, PmxSetting *setting)
 	{
 		this->bone_index1 = ReadIndex(stream, setting->bone_index_size);
 		this->bone_index2 = ReadIndex(stream, setting->bone_index_size);
 		this->bone_index3 = ReadIndex(stream, setting->bone_index_size);
 		this->bone_index4 = ReadIndex(stream, setting->bone_index_size);
 		stream->read((char*) &this->bone_weight1, sizeof(float));
 		stream->read((char*) &this->bone_weight2, sizeof(float));
 		stream->read((char*) &this->bone_weight3, sizeof(float));
 		stream->read((char*) &this->bone_weight4, sizeof(float));
 	}
 
 	void PmxVertex::Read(std::istream *stream, PmxSetting *setting)
 	{
 		stream->read((char*) this->position, sizeof(float) * 3);
 		stream->read((char*) this->normal, sizeof(float) * 3);
 		stream->read((char*) this->uv, sizeof(float) * 2);
 		for (int i = 0; i < setting->uv; ++i)
 		{
 			stream->read((char*) this->uva[i], sizeof(float) * 4);
 		}
 		stream->read((char*) &this->skinning_type, sizeof(PmxVertexSkinningType));
 		switch (this->skinning_type)
 		{
 		case PmxVertexSkinningType::BDEF1:
 			this->skinning = mmd::make_unique<PmxVertexSkinningBDEF1>();
 			break;
 		case PmxVertexSkinningType::BDEF2:
 			this->skinning = mmd::make_unique<PmxVertexSkinningBDEF2>();
 			break;
 		case PmxVertexSkinningType::BDEF4:
 			this->skinning = mmd::make_unique<PmxVertexSkinningBDEF4>();
 			break;
 		case PmxVertexSkinningType::SDEF:
 			this->skinning = mmd::make_unique<PmxVertexSkinningSDEF>();
 			break;
 		case PmxVertexSkinningType::QDEF:
 			this->skinning = mmd::make_unique<PmxVertexSkinningQDEF>();
 			break;
 		default:
 			throw "invalid skinning type";
 		}
 		this->skinning->Read(stream, setting);
 		stream->read((char*) &this->edge, sizeof(float));
 	}
 
 	void PmxMaterial::Read(std::istream *stream, PmxSetting *setting)
 	{
 		this->material_name = ReadString(stream, setting->encoding);
 		this->material_english_name = ReadString(stream, setting->encoding);
 		stream->read((char*) this->diffuse, sizeof(float) * 4);
 		stream->read((char*) this->specular, sizeof(float) * 3);
 		stream->read((char*) &this->specularlity, sizeof(float));
 		stream->read((char*) this->ambient, sizeof(float) * 3);
 		stream->read((char*) &this->flag, sizeof(uint8_t));
 		stream->read((char*) this->edge_color, sizeof(float) * 4);
 		stream->read((char*) &this->edge_size, sizeof(float));
 		this->diffuse_texture_index = ReadIndex(stream, setting->texture_index_size);
 		this->sphere_texture_index = ReadIndex(stream, setting->texture_index_size);
 		stream->read((char*) &this->sphere_op_mode, sizeof(uint8_t));
 		stream->read((char*) &this->common_toon_flag, sizeof(uint8_t));
 		if (this->common_toon_flag)
 		{
 			stream->read((char*) &this->toon_texture_index, sizeof(uint8_t));
 		}
 		else {
 			this->toon_texture_index = ReadIndex(stream, setting->texture_index_size);
 		}
 		this->memo = ReadString(stream, setting->encoding);
 		stream->read((char*) &this->index_count, sizeof(int));
 	}
 
 	void PmxIkLink::Read(std::istream *stream, PmxSetting *setting)
 	{
 		this->link_target = ReadIndex(stream, setting->bone_index_size);
 		stream->read((char*) &this->angle_lock, sizeof(uint8_t));
 		if (angle_lock == 1)
 		{
 			stream->read((char*) this->max_radian, sizeof(float) * 3);
 			stream->read((char*) this->min_radian, sizeof(float) * 3);
 		}
 	}
 
 	void PmxBone::Read(std::istream *stream, PmxSetting *setting)
 	{
 		this->bone_name = ReadString(stream, setting->encoding);
 		this->bone_english_name = ReadString(stream, setting->encoding);
 		stream->read((char*) this->position, sizeof(float) * 3);
 		this->parent_index = ReadIndex(stream, setting->bone_index_size);
 		stream->read((char*) &this->level, sizeof(int));
 		stream->read((char*) &this->bone_flag, sizeof(uint16_t));
 		if (this->bone_flag & 0x0001) {
 			this->target_index = ReadIndex(stream, setting->bone_index_size);
 		}
 		else {
 			stream->read((char*)this->offset, sizeof(float) * 3);
 		}
 		if (this->bone_flag & (0x0100 | 0x0200)) {
 			this->grant_parent_index = ReadIndex(stream, setting->bone_index_size);
 			stream->read((char*) &this->grant_weight, sizeof(float));
 		}
 		if (this->bone_flag & 0x0400) {
 			stream->read((char*)this->lock_axis_orientation, sizeof(float) * 3);
 		}
 		if (this->bone_flag & 0x0800) {
 			stream->read((char*)this->local_axis_x_orientation, sizeof(float) * 3);
 			stream->read((char*)this->local_axis_y_orientation, sizeof(float) * 3);
 		}
 		if (this->bone_flag & 0x2000) {
 			stream->read((char*) &this->key, sizeof(int));
 		}
 		if (this->bone_flag & 0x0020) {
 			this->ik_target_bone_index = ReadIndex(stream, setting->bone_index_size);
 			stream->read((char*) &ik_loop, sizeof(int));
 			stream->read((char*) &ik_loop_angle_limit, sizeof(float));
 			stream->read((char*) &ik_link_count, sizeof(int));
 			this->ik_links = mmd::make_unique<PmxIkLink []>(ik_link_count);
 			for (int i = 0; i < ik_link_count; i++) {
 				ik_links[i].Read(stream, setting);
 			}
 		}
 	}
 
 	void PmxMorphVertexOffset::Read(std::istream *stream, PmxSetting *setting)
 	{
 		this->vertex_index = ReadIndex(stream, setting->vertex_index_size);
 		stream->read((char*)this->position_offset, sizeof(float) * 3);
 	}
 
 	void PmxMorphUVOffset::Read(std::istream *stream, PmxSetting *setting)
 	{
 		this->vertex_index = ReadIndex(stream, setting->vertex_index_size);
 		stream->read((char*)this->uv_offset, sizeof(float) * 4);
 	}
 
 	void PmxMorphBoneOffset::Read(std::istream *stream, PmxSetting *setting)
 	{
 		this->bone_index = ReadIndex(stream, setting->bone_index_size);
 		stream->read((char*)this->translation, sizeof(float) * 3);
 		stream->read((char*)this->rotation, sizeof(float) * 4);
 	}
 
 	void PmxMorphMaterialOffset::Read(std::istream *stream, PmxSetting *setting)
 	{
 		this->material_index = ReadIndex(stream, setting->material_index_size);
 		stream->read((char*) &this->offset_operation, sizeof(uint8_t));
 		stream->read((char*)this->diffuse, sizeof(float) * 4);
 		stream->read((char*)this->specular, sizeof(float) * 3);
 		stream->read((char*) &this->specularity, sizeof(float));
 		stream->read((char*)this->ambient, sizeof(float) * 3);
 		stream->read((char*)this->edge_color, sizeof(float) * 4);
 		stream->read((char*) &this->edge_size, sizeof(float));
 		stream->read((char*)this->texture_argb, sizeof(float) * 4);
 		stream->read((char*)this->sphere_texture_argb, sizeof(float) * 4);
 		stream->read((char*)this->toon_texture_argb, sizeof(float) * 4);
 	}
 
 	void PmxMorphGroupOffset::Read(std::istream *stream, PmxSetting *setting)
 	{
 		this->morph_index = ReadIndex(stream, setting->morph_index_size);
 		stream->read((char*) &this->morph_weight, sizeof(float));
 	}
 
 	void PmxMorphFlipOffset::Read(std::istream *stream, PmxSetting *setting)
 	{
 		this->morph_index = ReadIndex(stream, setting->morph_index_size);
 		stream->read((char*) &this->morph_value, sizeof(float));
 	}
 
 	void PmxMorphImplusOffset::Read(std::istream *stream, PmxSetting *setting)
 	{
 		this->rigid_body_index = ReadIndex(stream, setting->rigidbody_index_size);
 		stream->read((char*) &this->is_local, sizeof(uint8_t));
 		stream->read((char*)this->velocity, sizeof(float) * 3);
 		stream->read((char*)this->angular_torque, sizeof(float) * 3);
 	}
 
 	void PmxMorph::Read(std::istream *stream, PmxSetting *setting)
 	{
 		this->morph_name = ReadString(stream, setting->encoding);
 		this->morph_english_name = ReadString(stream, setting->encoding);
 		stream->read((char*) &category, sizeof(MorphCategory));
 		stream->read((char*) &morph_type, sizeof(MorphType));
 		stream->read((char*) &this->offset_count, sizeof(int));
 		switch (this->morph_type)
 		{
 		case MorphType::Group:
 			group_offsets = mmd::make_unique<PmxMorphGroupOffset []>(this->offset_count);
 			for (int i = 0; i < offset_count; i++)
 			{
 				group_offsets[i].Read(stream, setting);
 			}
 			break;
 		case MorphType::Vertex:
 			vertex_offsets = mmd::make_unique<PmxMorphVertexOffset []>(this->offset_count);
 			for (int i = 0; i < offset_count; i++)
 			{
 				vertex_offsets[i].Read(stream, setting);
 			}
 			break;
 		case MorphType::Bone:
 			bone_offsets = mmd::make_unique<PmxMorphBoneOffset []>(this->offset_count);
 			for (int i = 0; i < offset_count; i++)
 			{
 				bone_offsets[i].Read(stream, setting);
 			}
 			break;
 		case MorphType::Matrial:
 			material_offsets = mmd::make_unique<PmxMorphMaterialOffset []>(this->offset_count);
 			for (int i = 0; i < offset_count; i++)
 			{
 				material_offsets[i].Read(stream, setting);
 			}
 			break;
 		case MorphType::UV:
 		case MorphType::AdditionalUV1:
 		case MorphType::AdditionalUV2:
 		case MorphType::AdditionalUV3:
 		case MorphType::AdditionalUV4:
 			uv_offsets = mmd::make_unique<PmxMorphUVOffset []>(this->offset_count);
 			for (int i = 0; i < offset_count; i++)
 			{
 				uv_offsets[i].Read(stream, setting);
 			}
 			break;
 		default:
             throw DeadlyImportError("MMD: unknown morth type");
 		}
 	}
 
 	void PmxFrameElement::Read(std::istream *stream, PmxSetting *setting)
 	{
 		stream->read((char*) &this->element_target, sizeof(uint8_t));
 		if (this->element_target == 0x00)
 		{
 			this->index = ReadIndex(stream, setting->bone_index_size);
 		}
 		else {
 			this->index = ReadIndex(stream, setting->morph_index_size);
 		}
 	}
 
 	void PmxFrame::Read(std::istream *stream, PmxSetting *setting)
 	{
 		this->frame_name = ReadString(stream, setting->encoding);
 		this->frame_english_name = ReadString(stream, setting->encoding);
 		stream->read((char*) &this->frame_flag, sizeof(uint8_t));
 		stream->read((char*) &this->element_count, sizeof(int));
 		this->elements = mmd::make_unique<PmxFrameElement []>(this->element_count);
 		for (int i = 0; i < this->element_count; i++)
 		{
 			this->elements[i].Read(stream, setting);
 		}
 	}
 
 	void PmxRigidBody::Read(std::istream *stream, PmxSetting *setting)
 	{
 		this->girid_body_name = ReadString(stream, setting->encoding);
 		this->girid_body_english_name = ReadString(stream, setting->encoding);
 		this->target_bone = ReadIndex(stream, setting->bone_index_size);
 		stream->read((char*) &this->group, sizeof(uint8_t));
 		stream->read((char*) &this->mask, sizeof(uint16_t));
 		stream->read((char*) &this->shape, sizeof(uint8_t));
 		stream->read((char*) this->size, sizeof(float) * 3);
 		stream->read((char*) this->position, sizeof(float) * 3);
 		stream->read((char*) this->orientation, sizeof(float) * 3);
 		stream->read((char*) &this->mass, sizeof(float));
 		stream->read((char*) &this->move_attenuation, sizeof(float));
 		stream->read((char*) &this->rotation_attenuation, sizeof(float));
 		stream->read((char*) &this->repulsion, sizeof(float));
 		stream->read((char*) &this->friction, sizeof(float));
 		stream->read((char*) &this->physics_calc_type, sizeof(uint8_t));
 	}
 
 	void PmxJointParam::Read(std::istream *stream, PmxSetting *setting)
 	{
 		this->rigid_body1 = ReadIndex(stream, setting->rigidbody_index_size);
 		this->rigid_body2 = ReadIndex(stream, setting->rigidbody_index_size);
 		stream->read((char*) this->position, sizeof(float) * 3);
 		stream->read((char*) this->orientaiton, sizeof(float) * 3);
 		stream->read((char*) this->move_limitation_min, sizeof(float) * 3);
 		stream->read((char*) this->move_limitation_max, sizeof(float) * 3);
 		stream->read((char*) this->rotation_limitation_min, sizeof(float) * 3);
 		stream->read((char*) this->rotation_limitation_max, sizeof(float) * 3);
 		stream->read((char*) this->spring_move_coefficient, sizeof(float) * 3);
 		stream->read((char*) this->spring_rotation_coefficient, sizeof(float) * 3);
 	}
 
 	void PmxJoint::Read(std::istream *stream, PmxSetting *setting)
 	{
 		this->joint_name = ReadString(stream, setting->encoding);
 		this->joint_english_name = ReadString(stream, setting->encoding);
 		stream->read((char*) &this->joint_type, sizeof(uint8_t));
 		this->param.Read(stream, setting);
 	}
 
 	void PmxAncherRigidBody::Read(std::istream *stream, PmxSetting *setting)
 	{
 		this->related_rigid_body = ReadIndex(stream, setting->rigidbody_index_size);
 		this->related_vertex = ReadIndex(stream, setting->vertex_index_size);
 		stream->read((char*) &this->is_near, sizeof(uint8_t));
 	}
 
     void PmxSoftBody::Read(std::istream * /*stream*/, PmxSetting * /*setting*/)
 	{
         throw DeadlyImportError("MMD: Soft Body support is not implemented.");
     }
 
 	void PmxModel::Init()
 	{
 		this->version = 0.0f;
 		this->model_name.clear();
 		this->model_english_name.clear();
 		this->model_comment.clear();
 		this->model_english_comment.clear();
 		this->vertex_count = 0;
 		this->vertices = nullptr;
 		this->index_count = 0;
 		this->indices = nullptr;
 		this->texture_count = 0;
 		this->textures = nullptr;
 		this->material_count = 0;
 		this->materials = nullptr;
 		this->bone_count = 0;
 		this->bones = nullptr;
 		this->morph_count = 0;
 		this->morphs = nullptr;
 		this->frame_count = 0;
 		this->frames = nullptr;
 		this->rigid_body_count = 0;
 		this->rigid_bodies = nullptr;
 		this->joint_count = 0;
 		this->joints = nullptr;
 		this->soft_body_count = 0;
 		this->soft_bodies = nullptr;
 	}
 
 	void PmxModel::Read(std::istream *stream)
 	{
 		char magic[4];
 		stream->read((char*) magic, sizeof(char) * 4);
 		if (magic[0] != 0x50 || magic[1] != 0x4d || magic[2] != 0x58 || magic[3] != 0x20)
         {
-      throw DeadlyImportError("MMD: Invalid magic number.");
-    }
+            throw DeadlyImportError("MMD: Invalid magic number.");
+        }
 		stream->read((char*) &version, sizeof(float));
 		if (version != 2.0f && version != 2.1f)
 		{
             throw DeadlyImportError("MMD: Unsupported version (must be 2.0 or 2.1): ", ai_to_string(version));
-    }
+        }
 		this->setting.Read(stream);
 
 		this->model_name = ReadString(stream, setting.encoding);
 		this->model_english_name = ReadString(stream, setting.encoding);
 		this->model_comment = ReadString(stream, setting.encoding);
 		this->model_english_comment = ReadString(stream, setting.encoding);
 
 		// read vertices
 		stream->read((char*) &vertex_count, sizeof(int));
 		this->vertices = mmd::make_unique<PmxVertex []>(vertex_count);
 		for (int i = 0; i < vertex_count; i++)
 		{
 			vertices[i].Read(stream, &setting);
 		}
 
 		// read indices
 		stream->read((char*) &index_count, sizeof(int));
 		this->indices = mmd::make_unique<int []>(index_count);
 		for (int i = 0; i < index_count; i++)
 		{
 			this->indices[i] = ReadIndex(stream, setting.vertex_index_size);
 		}
 
 		// read texture names
 		stream->read((char*) &texture_count, sizeof(int));
 		this->textures = mmd::make_unique<std::string []>(texture_count);
 		for (int i = 0; i < texture_count; i++)
 		{
 			this->textures[i] = ReadString(stream, setting.encoding);
 		}
 
 		// read materials
 		stream->read((char*) &material_count, sizeof(int));
 		this->materials = mmd::make_unique<PmxMaterial []>(material_count);
 		for (int i = 0; i < material_count; i++)
 		{
 			this->materials[i].Read(stream, &setting);
 		}
 
 		// read bones
 		stream->read((char*) &this->bone_count, sizeof(int));
 		this->bones = mmd::make_unique<PmxBone []>(this->bone_count);
 		for (int i = 0; i < this->bone_count; i++)
 		{
 			this->bones[i].Read(stream, &setting);
 		}
 
 		// read morphs
 		stream->read((char*) &this->morph_count, sizeof(int));
 		this->morphs = mmd::make_unique<PmxMorph []>(this->morph_count);
 		for (int i = 0; i < this->morph_count; i++)
 		{
 			this->morphs[i].Read(stream, &setting);
 		}
 
 		// read display frames
 		stream->read((char*) &this->frame_count, sizeof(int));
 		this->frames = mmd::make_unique<PmxFrame []>(this->frame_count);
 		for (int i = 0; i < this->frame_count; i++)
 		{
 			this->frames[i].Read(stream, &setting);
 		}
 
 		// read rigid bodies
 		stream->read((char*) &this->rigid_body_count, sizeof(int));
 		this->rigid_bodies = mmd::make_unique<PmxRigidBody []>(this->rigid_body_count);
 		for (int i = 0; i < this->rigid_body_count; i++)
 		{
 			this->rigid_bodies[i].Read(stream, &setting);
 		}
 
 		// read joints
 		stream->read((char*) &this->joint_count, sizeof(int));
 		this->joints = mmd::make_unique<PmxJoint []>(this->joint_count);
 		for (int i = 0; i < this->joint_count; i++)
 		{
 			this->joints[i].Read(stream, &setting);
 		}
 	}
 }
diff --git a/code/AssetLib/OFF/OFFLoader.cpp b/code/AssetLib/OFF/OFFLoader.cpp
index 360ffc51b..fb8f3b424 100644
--- a/code/AssetLib/OFF/OFFLoader.cpp
+++ b/code/AssetLib/OFF/OFFLoader.cpp
@@ -119,227 +119,227 @@ static void NextToken(const char **car, const char* end) {
 // ------------------------------------------------------------------------------------------------
 // Imports the given file into the given scene structure.
 void OFFImporter::InternReadFile( const std::string& pFile, aiScene* pScene, IOSystem* pIOHandler) {
     std::unique_ptr<IOStream> file( pIOHandler->Open( pFile, "rb"));
 
     // Check whether we can read from the file
     if( file.get() == nullptr) {
         throw DeadlyImportError( "Failed to open OFF file ", pFile, ".");
     }
 
     // allocate storage and copy the contents of the file to a memory buffer
     std::vector<char> mBuffer2;
     TextFileToBuffer(file.get(),mBuffer2);
     const char* buffer = &mBuffer2[0];
 
     // Proper OFF header parser. We only implement normal loading for now.
     bool hasTexCoord = false, hasNormals = false, hasColors = false;
     bool hasHomogenous = false, hasDimension = false;
     unsigned int dimensions = 3;
     const char* car = buffer;
     const char* end = buffer + mBuffer2.size();
     NextToken(&car, end);
-    
+
     if (car < end - 2 && car[0] == 'S' && car[1] == 'T') {
       hasTexCoord = true; car += 2;
     }
     if (car < end - 1 && car[0] == 'C') {
       hasColors = true; car++;
     }
     if (car < end- 1 && car[0] == 'N') {
       hasNormals = true; car++;
     }
     if (car < end - 1 && car[0] == '4') {
       hasHomogenous = true; car++;
     }
     if (car < end - 1 && car[0] == 'n') {
       hasDimension = true; car++;
     }
     if (car < end - 3 && car[0] == 'O' && car[1] == 'F' && car[2] == 'F') {
         car += 3;
 	NextToken(&car, end);
     } else {
       // in case there is no OFF header (which is allowed by the
       // specification...), then we might have unintentionally read an
       // additional dimension from the primitive count fields
       dimensions = 3;
       hasHomogenous = false;
       NextToken(&car, end);
-      
+
       // at this point the next token should be an integer number
       if (car >= end - 1 || *car < '0' || *car > '9') {
 	throw DeadlyImportError("OFF: Header is invalid");
       }
     }
     if (hasDimension) {
         dimensions = strtoul10(car, &car);
 	NextToken(&car, end);
     }
     if (dimensions > 3) {
         throw DeadlyImportError
 	  ("OFF: Number of vertex coordinates higher than 3 unsupported");
     }
 
     NextToken(&car, end);
     const unsigned int numVertices = strtoul10(car, &car);
     NextToken(&car, end);
     const unsigned int numFaces = strtoul10(car, &car);
     NextToken(&car, end);
     strtoul10(car, &car);  // skip edge count
     NextToken(&car, end);
 
     if (!numVertices) {
         throw DeadlyImportError("OFF: There are no valid vertices");
     }
     if (!numFaces) {
         throw DeadlyImportError("OFF: There are no valid faces");
     }
 
     pScene->mNumMeshes = 1;
     pScene->mMeshes = new aiMesh*[ pScene->mNumMeshes ];
 
     aiMesh* mesh = new aiMesh();
     pScene->mMeshes[0] = mesh;
 
     mesh->mNumFaces = numFaces;
     aiFace* faces = new aiFace[mesh->mNumFaces];
     mesh->mFaces = faces;
 
     mesh->mNumVertices = numVertices;
     mesh->mVertices = new aiVector3D[numVertices];
     mesh->mNormals = hasNormals ? new aiVector3D[numVertices] : nullptr;
     mesh->mColors[0] = hasColors ? new aiColor4D[numVertices] : nullptr;
 
     if (hasTexCoord) {
         mesh->mNumUVComponents[0] = 2;
         mesh->mTextureCoords[0] = new aiVector3D[numVertices];
     }
     char line[4096];
     buffer = car;
     const char *sz = car;
 
     // now read all vertex lines
     for (unsigned int i = 0; i < numVertices; ++i) {
         if(!GetNextLine(buffer, line)) {
             ASSIMP_LOG_ERROR("OFF: The number of verts in the header is incorrect");
             break;
         }
-        aiVector3D& v = mesh->mVertices[i];	
+        aiVector3D& v = mesh->mVertices[i];
         sz = line;
 
 	// helper array to write a for loop over possible dimension values
 	ai_real* vec[3] = {&v.x, &v.y, &v.z};
 
 	// stop at dimensions: this allows loading 1D or 2D coordinate vertices
         for (unsigned int dim = 0; dim < dimensions; ++dim ) {
 	    SkipSpaces(&sz);
 	    sz = fast_atoreal_move<ai_real>(sz, *vec[dim]);
 	}
 
 	// if has homogenous coordinate, divide others by this one
 	if (hasHomogenous) {
 	    SkipSpaces(&sz);
 	    ai_real w = 1.;
 	    sz = fast_atoreal_move<ai_real>(sz, w);
             for (unsigned int dim = 0; dim < dimensions; ++dim ) {
 	        *(vec[dim]) /= w;
 	    }
 	}
 
 	// read optional normals
 	if (hasNormals) {
 	    aiVector3D& n = mesh->mNormals[i];
 	    SkipSpaces(&sz);
 	    sz = fast_atoreal_move<ai_real>(sz,(ai_real&)n.x);
 	    SkipSpaces(&sz);
 	    sz = fast_atoreal_move<ai_real>(sz,(ai_real&)n.y);
 	    SkipSpaces(&sz);
 	    fast_atoreal_move<ai_real>(sz,(ai_real&)n.z);
 	}
-	
+
 	// reading colors is a pain because the specification says it can be
 	// integers or floats, and any number of them between 1 and 4 included,
 	// until the next comment or end of line
 	// in theory should be testing type !
 	if (hasColors) {
 	    aiColor4D& c = mesh->mColors[0][i];
 	    SkipSpaces(&sz);
 	    sz = fast_atoreal_move<ai_real>(sz,(ai_real&)c.r);
             if (*sz != '#' && *sz != '\n' && *sz != '\r') {
 	        SkipSpaces(&sz);
 	        sz = fast_atoreal_move<ai_real>(sz,(ai_real&)c.g);
             } else {
 	        c.g = 0.;
 	    }
             if (*sz != '#' && *sz != '\n' && *sz != '\r') {
 	        SkipSpaces(&sz);
 	        sz = fast_atoreal_move<ai_real>(sz,(ai_real&)c.b);
             } else {
 	        c.b = 0.;
 	    }
             if (*sz != '#' && *sz != '\n' && *sz != '\r') {
 	        SkipSpaces(&sz);
 	        sz = fast_atoreal_move<ai_real>(sz,(ai_real&)c.a);
             } else {
 	        c.a = 1.;
 	    }
 	}
         if (hasTexCoord) {
 	    aiVector3D& t = mesh->mTextureCoords[0][i];
 	    SkipSpaces(&sz);
 	    sz = fast_atoreal_move<ai_real>(sz,(ai_real&)t.x);
 	    SkipSpaces(&sz);
 	    fast_atoreal_move<ai_real>(sz,(ai_real&)t.y);
 	}
     }
 
     // load faces with their indices
     faces = mesh->mFaces;
     for (unsigned int i = 0; i < numFaces; ) {
         if(!GetNextLine(buffer,line)) {
             ASSIMP_LOG_ERROR("OFF: The number of faces in the header is incorrect");
             break;
         }
         unsigned int idx;
         sz = line; SkipSpaces(&sz);
         idx = strtoul10(sz,&sz);
         if(!idx || idx > 9) {
 	    ASSIMP_LOG_ERROR("OFF: Faces with zero indices aren't allowed");
             --mesh->mNumFaces;
             continue;
 	}
 	faces->mNumIndices = idx;
         faces->mIndices = new unsigned int[faces->mNumIndices];
         for (unsigned int m = 0; m < faces->mNumIndices;++m) {
             SkipSpaces(&sz);
             idx = strtoul10(sz,&sz);
             if (idx >= numVertices) {
                 ASSIMP_LOG_ERROR("OFF: Vertex index is out of range");
                 idx = numVertices - 1;
             }
             faces->mIndices[m] = idx;
         }
         ++i;
         ++faces;
     }
-    
+
     // generate the output node graph
     pScene->mRootNode = new aiNode();
     pScene->mRootNode->mName.Set("<OFFRoot>");
     pScene->mRootNode->mNumMeshes = 1;
     pScene->mRootNode->mMeshes = new unsigned int [pScene->mRootNode->mNumMeshes];
     pScene->mRootNode->mMeshes[0] = 0;
 
     // generate a default material
     pScene->mNumMaterials = 1;
     pScene->mMaterials = new aiMaterial*[pScene->mNumMaterials];
     aiMaterial* pcMat = new aiMaterial();
 
     aiColor4D clr( ai_real( 0.6 ), ai_real( 0.6 ), ai_real( 0.6 ), ai_real( 1.0 ) );
     pcMat->AddProperty(&clr,1,AI_MATKEY_COLOR_DIFFUSE);
     pScene->mMaterials[0] = pcMat;
 
     const int twosided = 1;
     pcMat->AddProperty(&twosided, 1, AI_MATKEY_TWOSIDED);
 }
 
 #endif // !! ASSIMP_BUILD_NO_OFF_IMPORTER
diff --git a/code/AssetLib/Obj/ObjExporter.h b/code/AssetLib/Obj/ObjExporter.h
index 3a46da780..a64f38f74 100644
--- a/code/AssetLib/Obj/ObjExporter.h
+++ b/code/AssetLib/Obj/ObjExporter.h
@@ -64,10 +64,10 @@ class ObjExporter {
 public:
     /// Constructor for a specific scene to export
     ObjExporter(const char* filename, const aiScene* pScene, bool noMtl=false);
     ~ObjExporter();
     std::string GetMaterialLibName();
     std::string GetMaterialLibFileName();
-    
+
     /// public string-streams to write all output into
     std::ostringstream mOutput, mOutputMat;
 
@@ -105,86 +105,86 @@ private:
 private:
     std::string filename;
     const aiScene* const pScene;
 
     struct vertexData {
         aiVector3D vp;
         aiColor3D vc; // OBJ does not support 4D color
     };
 
     std::vector<aiVector3D> vn, vt;
     std::vector<aiColor4D> vc;
     std::vector<vertexData> vp;
     bool useVc;
 
     struct vertexDataCompare {
         bool operator() ( const vertexData& a, const vertexData& b ) const {
             // position
             if (a.vp.x < b.vp.x) return true;
             if (a.vp.x > b.vp.x) return false;
             if (a.vp.y < b.vp.y) return true;
             if (a.vp.y > b.vp.y) return false;
             if (a.vp.z < b.vp.z) return true;
             if (a.vp.z > b.vp.z) return false;
 
             // color
             if (a.vc.r < b.vc.r) return true;
             if (a.vc.r > b.vc.r) return false;
             if (a.vc.g < b.vc.g) return true;
             if (a.vc.g > b.vc.g) return false;
             if (a.vc.b < b.vc.b) return true;
             if (a.vc.b > b.vc.b) return false;
             return false;
         }
     };
 
-    struct aiVectorCompare { 
-        bool operator() (const aiVector3D& a, const aiVector3D& b) const { 
-            if(a.x < b.x) return true; 
-            if(a.x > b.x) return false; 
-            if(a.y < b.y) return true; 
-            if(a.y > b.y) return false; 
-            if(a.z < b.z) return true; 
+    struct aiVectorCompare {
+        bool operator() (const aiVector3D& a, const aiVector3D& b) const {
+            if(a.x < b.x) return true;
+            if(a.x > b.x) return false;
+            if(a.y < b.y) return true;
+            if(a.y > b.y) return false;
+            if(a.z < b.z) return true;
             return false;
         }
     };
 
     template <class T, class Compare = std::less<T>>
     class indexMap {
         int mNextIndex;
         typedef std::map<T, int, Compare> dataType;
         dataType vecMap;
-    
+
     public:
         indexMap()
         : mNextIndex(1) {
             // empty
         }
 
         int getIndex(const T& key) {
             typename dataType::iterator vertIt = vecMap.find(key);
             // vertex already exists, so reference it
             if(vertIt != vecMap.end()){
                 return vertIt->second;
             }
             return vecMap[key] = mNextIndex++;
         };
 
         void getKeys( std::vector<T>& keys ) {
             keys.resize(vecMap.size());
             for(typename dataType::iterator it = vecMap.begin(); it != vecMap.end(); ++it){
                 keys[it->second-1] = it->first;
             }
         };
     };
 
     indexMap<aiVector3D, aiVectorCompare> mVnMap, mVtMap;
     indexMap<vertexData, vertexDataCompare> mVpMap;
     std::vector<MeshInstance> mMeshes;
 
     // this endl() doesn't flush() the stream
     const std::string endl;
 };
 
 }
 
 #endif
diff --git a/code/AssetLib/Obj/ObjFileMtlImporter.cpp b/code/AssetLib/Obj/ObjFileMtlImporter.cpp
index bf1b70c90..94e57c26b 100644
--- a/code/AssetLib/Obj/ObjFileMtlImporter.cpp
+++ b/code/AssetLib/Obj/ObjFileMtlImporter.cpp
@@ -110,98 +110,98 @@ ObjFileMtlImporter::~ObjFileMtlImporter() {
 // -------------------------------------------------------------------
 //  Loads the material description
 void ObjFileMtlImporter::load() {
     if (m_DataIt == m_DataItEnd)
         return;
 
     while (m_DataIt != m_DataItEnd) {
         switch (*m_DataIt) {
             case 'k':
             case 'K': {
                 ++m_DataIt;
                 if (*m_DataIt == 'a') // Ambient color
                 {
                     ++m_DataIt;
                     getColorRGBA(&m_pModel->m_pCurrentMaterial->ambient);
                 } else if (*m_DataIt == 'd') {
                     // Diffuse color
                     ++m_DataIt;
                     getColorRGBA(&m_pModel->m_pCurrentMaterial->diffuse);
                 } else if (*m_DataIt == 's') {
                     ++m_DataIt;
                     getColorRGBA(&m_pModel->m_pCurrentMaterial->specular);
                 } else if (*m_DataIt == 'e') {
                     ++m_DataIt;
                     getColorRGBA(&m_pModel->m_pCurrentMaterial->emissive);
                 }
                 m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
             } break;
             case 'T': {
                 ++m_DataIt;
                 // Material transmission color
                 if (*m_DataIt == 'f')  {
                     ++m_DataIt;
                     getColorRGBA(&m_pModel->m_pCurrentMaterial->transparent);
                 } else if (*m_DataIt == 'r')  {
                     // Material transmission alpha value
                     ++m_DataIt;
                     ai_real d;
                     getFloatValue(d);
-                    m_pModel->m_pCurrentMaterial->alpha = static_cast<ai_real>(1.0) - d;                    
+                    m_pModel->m_pCurrentMaterial->alpha = static_cast<ai_real>(1.0) - d;
                 }
                 m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
             } break;
             case 'd': {
                 if (*(m_DataIt + 1) == 'i' && *(m_DataIt + 2) == 's' && *(m_DataIt + 3) == 'p') {
                     // A displacement map
                     getTexture();
                 } else {
                     // Alpha value
                     ++m_DataIt;
                     getFloatValue(m_pModel->m_pCurrentMaterial->alpha);
                     m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
                 }
             } break;
 
             case 'N':
             case 'n': {
                 ++m_DataIt;
                 switch (*m_DataIt) {
                     case 's': // Specular exponent
                         ++m_DataIt;
                         getFloatValue(m_pModel->m_pCurrentMaterial->shineness);
                         break;
                     case 'i': // Index Of refraction
                         ++m_DataIt;
                         getFloatValue(m_pModel->m_pCurrentMaterial->ior);
                         break;
                     case 'e': // New material
                         createMaterial();
                         break;
                 }
                 m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
             } break;
 
             case 'm': // Texture
             case 'b': // quick'n'dirty - for 'bump' sections
             case 'r': // quick'n'dirty - for 'refl' sections
             {
                 getTexture();
                 m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
             } break;
 
             case 'i': // Illumination model
             {
                 m_DataIt = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
                 getIlluminationModel(m_pModel->m_pCurrentMaterial->illumination_model);
                 m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
             } break;
 
             default: {
                 m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
             } break;
         }
     }
 }
 
 // -------------------------------------------------------------------
 //  Loads a color definition
diff --git a/code/AssetLib/SMD/SMDLoader.cpp b/code/AssetLib/SMD/SMDLoader.cpp
index de9c65c4a..90f0b7697 100644
--- a/code/AssetLib/SMD/SMDLoader.cpp
+++ b/code/AssetLib/SMD/SMDLoader.cpp
@@ -407,49 +407,49 @@ void SMDImporter::CreateOutputMeshes() {
 // ------------------------------------------------------------------------------------------------
 // add bone child nodes
 void SMDImporter::AddBoneChildren(aiNode* pcNode, uint32_t iParent) {
     ai_assert( nullptr != pcNode );
     ai_assert( 0 == pcNode->mNumChildren );
     ai_assert( nullptr == pcNode->mChildren);
 
     // first count ...
     for (unsigned int i = 0; i < asBones.size();++i) {
         SMD::Bone& bone = asBones[i];
         if (bone.iParent == iParent) {
             ++pcNode->mNumChildren;
         }
     }
 
     // now allocate the output array
     pcNode->mChildren = new aiNode*[pcNode->mNumChildren];
 
     // and fill all subnodes
     unsigned int qq( 0 );
     for (unsigned int i = 0; i < asBones.size();++i) {
         SMD::Bone& bone = asBones[i];
         if (bone.iParent != iParent) {
             continue;
         }
 
         aiNode* pc = pcNode->mChildren[qq++] = new aiNode();
         pc->mName.Set(bone.mName);
 
         // store the local transformation matrix of the bind pose
         if (bone.sAnim.asKeys.size()) {
             pc->mTransformation = bone.sAnim.asKeys[0].matrix;
         }
 
-        if (bone.iParent == static_cast<uint32_t>(-1)) { 
+        if (bone.iParent == static_cast<uint32_t>(-1)) {
             bone.mOffsetMatrix = pc->mTransformation;
         } else {
             bone.mOffsetMatrix = asBones[bone.iParent].mOffsetMatrix * pc->mTransformation;
         }
 
         pc->mParent = pcNode;
 
         // add children to this node, too
         AddBoneChildren(pc,i);
     }
 }
 
 // ------------------------------------------------------------------------------------------------
 // create output nodes
diff --git a/code/AssetLib/STEPParser/STEPFileReader.cpp b/code/AssetLib/STEPParser/STEPFileReader.cpp
index ac6d83672..360277912 100644
--- a/code/AssetLib/STEPParser/STEPFileReader.cpp
+++ b/code/AssetLib/STEPParser/STEPFileReader.cpp
@@ -58,16 +58,16 @@ using namespace Assimp;
 namespace EXPRESS = STEP::EXPRESS;
 
 // ------------------------------------------------------------------------------------------------
-std::string AddLineNumber(const std::string& s,uint64_t line /*= LINE_NOT_SPECIFIED*/, const std::string& prefix = "")
+std::string AddLineNumber(const std::string& s,uint64_t line /*= LINE_NOT_SPECIFIED*/, const std::string& prefix = std::string())
 {
     return line == STEP::SyntaxError::LINE_NOT_SPECIFIED ? prefix+s : static_cast<std::string>( (Formatter::format(),prefix,"(line ",line,") ",s) );
 }
 
 // ------------------------------------------------------------------------------------------------
-std::string AddEntityID(const std::string& s,uint64_t entity /*= ENTITY_NOT_SPECIFIED*/, const std::string& prefix = "")
+std::string AddEntityID(const std::string& s,uint64_t entity /*= ENTITY_NOT_SPECIFIED*/, const std::string& prefix = std::string())
 {
     return entity == STEP::TypeError::ENTITY_NOT_SPECIFIED ? prefix+s : static_cast<std::string>( (Formatter::format(),prefix,"(entity #",entity,") ",s));
 }
 
 
 // ------------------------------------------------------------------------------------------------
diff --git a/code/AssetLib/STL/STLExporter.cpp b/code/AssetLib/STL/STLExporter.cpp
index bd4d96c71..59c6148ee 100644
--- a/code/AssetLib/STL/STLExporter.cpp
+++ b/code/AssetLib/STL/STLExporter.cpp
@@ -60,42 +60,42 @@ namespace Assimp    {
 // ------------------------------------------------------------------------------------------------
 // Worker function for exporting a scene to Stereolithograpy. Prototyped and registered in Exporter.cpp
 void ExportSceneSTL(const char* pFile,IOSystem* pIOSystem, const aiScene* pScene, const ExportProperties* pProperties )
 {
     bool exportPointClouds = pProperties->GetPropertyBool(AI_CONFIG_EXPORT_POINT_CLOUDS);
 
     // invoke the exporter
     STLExporter exporter(pFile, pScene, exportPointClouds );
 
     if (exporter.mOutput.fail()) {
         throw DeadlyExportError("output data creation failed. Most likely the file became too large: " + std::string(pFile));
     }
-    
+
     // we're still here - export successfully completed. Write the file.
     std::unique_ptr<IOStream> outfile (pIOSystem->Open(pFile,"wt"));
     if (outfile == nullptr) {
         throw DeadlyExportError("could not open output .stl file: " + std::string(pFile));
     }
 
     outfile->Write( exporter.mOutput.str().c_str(), static_cast<size_t>(exporter.mOutput.tellp()),1);
 }
 void ExportSceneSTLBinary(const char* pFile,IOSystem* pIOSystem, const aiScene* pScene, const ExportProperties* pProperties )
 {
     bool exportPointClouds = pProperties->GetPropertyBool(AI_CONFIG_EXPORT_POINT_CLOUDS);
 
     // invoke the exporter
     STLExporter exporter(pFile, pScene, exportPointClouds, true);
 
     if (exporter.mOutput.fail()) {
         throw DeadlyExportError("output data creation failed. Most likely the file became too large: " + std::string(pFile));
     }
-    
+
     // we're still here - export successfully completed. Write the file.
     std::unique_ptr<IOStream> outfile (pIOSystem->Open(pFile,"wb"));
     if (outfile == nullptr) {
         throw DeadlyExportError("could not open output .stl file: " + std::string(pFile));
     }
 
     outfile->Write( exporter.mOutput.str().c_str(), static_cast<size_t>(exporter.mOutput.tellp()),1);
 }
 
 } // end of namespace Assimp
@@ -106,49 +106,49 @@ static const char *EndSolidToken = "endsolid";
 // ------------------------------------------------------------------------------------------------
 STLExporter::STLExporter(const char* _filename, const aiScene* pScene, bool exportPointClouds, bool binary)
 : filename(_filename)
 , endl("\n")
 {
     // make sure that all formatting happens using the standard, C locale and not the user's current locale
     const std::locale& l = std::locale("C");
     mOutput.imbue(l);
     mOutput.precision(ASSIMP_AI_REAL_TEXT_PRECISION);
     if (binary) {
         char buf[80] = {0} ;
         buf[0] = 'A'; buf[1] = 's'; buf[2] = 's'; buf[3] = 'i'; buf[4] = 'm'; buf[5] = 'p';
         buf[6] = 'S'; buf[7] = 'c'; buf[8] = 'e'; buf[9] = 'n'; buf[10] = 'e';
         mOutput.write(buf, 80);
         unsigned int meshnum = 0;
         for(unsigned int i = 0; i < pScene->mNumMeshes; ++i) {
             for (unsigned int j = 0; j < pScene->mMeshes[i]->mNumFaces; ++j) {
                 meshnum++;
             }
         }
         AI_SWAP4(meshnum);
         mOutput.write((char *)&meshnum, 4);
 
         if (exportPointClouds) {
             throw DeadlyExportError("This functionality is not yet implemented for binary output.");
         }
 
         for(unsigned int i = 0; i < pScene->mNumMeshes; ++i) {
             WriteMeshBinary(pScene->mMeshes[i]);
         }
     } else {
 
         // Exporting only point clouds
         if (exportPointClouds) {
             WritePointCloud("Assimp_Pointcloud", pScene );
             return;
-        } 
+        }
 
-        // Export the assimp mesh 
+        // Export the assimp mesh
         const std::string name = "AssimpScene";
         mOutput << SolidToken << " " << name << endl;
         for(unsigned int i = 0; i < pScene->mNumMeshes; ++i) {
             WriteMesh(pScene->mMeshes[ i ]);
         }
         mOutput << EndSolidToken << " " << name << endl;
     }
 }
 
 // ------------------------------------------------------------------------------------------------
diff --git a/code/AssetLib/STL/STLLoader.cpp b/code/AssetLib/STL/STLLoader.cpp
index 433fb14c7..8cfe63e0d 100644
--- a/code/AssetLib/STL/STLLoader.cpp
+++ b/code/AssetLib/STL/STLLoader.cpp
@@ -236,178 +236,178 @@ void STLImporter::InternReadFile(const std::string &pFile, aiScene *pScene, IOSy
 // ------------------------------------------------------------------------------------------------
 // Read an ASCII STL file
 void STLImporter::LoadASCIIFile(aiNode *root) {
     std::vector<aiMesh *> meshes;
     std::vector<aiNode *> nodes;
     const char *sz = mBuffer;
     const char *bufferEnd = mBuffer + mFileSize;
     std::vector<aiVector3D> positionBuffer;
     std::vector<aiVector3D> normalBuffer;
 
     // try to guess how many vertices we could have
     // assume we'll need 160 bytes for each face
     size_t sizeEstimate = std::max(1u, mFileSize / 160u) * 3;
     positionBuffer.reserve(sizeEstimate);
     normalBuffer.reserve(sizeEstimate);
 
     while (IsAsciiSTL(sz, static_cast<unsigned int>(bufferEnd - sz))) {
         std::vector<unsigned int> meshIndices;
         aiMesh *pMesh = new aiMesh();
         pMesh->mMaterialIndex = 0;
         meshIndices.push_back((unsigned int)meshes.size());
         meshes.push_back(pMesh);
         aiNode *node = new aiNode;
         node->mParent = root;
         nodes.push_back(node);
         SkipSpaces(&sz);
         ai_assert(!IsLineEnd(sz));
 
         sz += 5; // skip the "solid"
         SkipSpaces(&sz);
         const char *szMe = sz;
         while (!::IsSpaceOrNewLine(*sz)) {
             sz++;
         }
 
         size_t temp = (size_t)(sz - szMe);
         // setup the name of the node
         if ( temp ) {
             if (temp >= MAXLEN) {
                 throw DeadlyImportError("STL: Node name too long");
             }
             std::string name(szMe, temp);
             node->mName.Set(name.c_str());
             pMesh->mName.Set(name.c_str());
         } else {
             mScene->mRootNode->mName.Set("<STL_ASCII>");
         }
 
         unsigned int faceVertexCounter = 3;
         for (;;) {
             // go to the next token
             if (!SkipSpacesAndLineEnd(&sz)) {
                 // seems we're finished although there was no end marker
                 ASSIMP_LOG_WARN("STL: unexpected EOF. \'endsolid\' keyword was expected");
                 break;
             }
             // facet normal -0.13 -0.13 -0.98
             if (!strncmp(sz, "facet", 5) && IsSpaceOrNewLine(*(sz + 5)) && *(sz + 5) != '\0') {
 
                 if (faceVertexCounter != 3) {
                     ASSIMP_LOG_WARN("STL: A new facet begins but the old is not yet complete");
                 }
                 faceVertexCounter = 0;
                 normalBuffer.push_back(aiVector3D());
                 aiVector3D *vn = &normalBuffer.back();
 
                 sz += 6;
                 SkipSpaces(&sz);
                 if (strncmp(sz, "normal", 6)) {
                     ASSIMP_LOG_WARN("STL: a facet normal vector was expected but not found");
                 } else {
                     if (sz[6] == '\0') {
                         throw DeadlyImportError("STL: unexpected EOF while parsing facet");
                     }
                     sz += 7;
                     SkipSpaces(&sz);
                     sz = fast_atoreal_move<ai_real>(sz, (ai_real &)vn->x);
                     SkipSpaces(&sz);
                     sz = fast_atoreal_move<ai_real>(sz, (ai_real &)vn->y);
                     SkipSpaces(&sz);
                     sz = fast_atoreal_move<ai_real>(sz, (ai_real &)vn->z);
                     normalBuffer.push_back(*vn);
                     normalBuffer.push_back(*vn);
                 }
             } else if (!strncmp(sz, "vertex", 6) && ::IsSpaceOrNewLine(*(sz + 6))) { // vertex 1.50000 1.50000 0.00000
                 if (faceVertexCounter >= 3) {
                     ASSIMP_LOG_ERROR("STL: a facet with more than 3 vertices has been found");
                     ++sz;
                 } else {
                     if (sz[6] == '\0') {
                         throw DeadlyImportError("STL: unexpected EOF while parsing facet");
                     }
                     sz += 7;
                     SkipSpaces(&sz);
                     positionBuffer.push_back(aiVector3D());
                     aiVector3D *vn = &positionBuffer.back();
                     sz = fast_atoreal_move<ai_real>(sz, (ai_real &)vn->x);
                     SkipSpaces(&sz);
                     sz = fast_atoreal_move<ai_real>(sz, (ai_real &)vn->y);
                     SkipSpaces(&sz);
                     sz = fast_atoreal_move<ai_real>(sz, (ai_real &)vn->z);
                     faceVertexCounter++;
                 }
             } else if (!::strncmp(sz, "endsolid", 8)) {
                 do {
                     ++sz;
                 } while (!::IsLineEnd(*sz));
                 SkipSpacesAndLineEnd(&sz);
                 // finished!
                 break;
             } else { // else skip the whole identifier
                 do {
                     ++sz;
                 } while (!::IsSpaceOrNewLine(*sz));
             }
         }
 
         if (positionBuffer.empty()) {
             pMesh->mNumFaces = 0;
             ASSIMP_LOG_WARN("STL: mesh is empty or invalid; no data loaded");
         }
         if (positionBuffer.size() % 3 != 0) {
             pMesh->mNumFaces = 0;
             throw DeadlyImportError("STL: Invalid number of vertices");
         }
         if (normalBuffer.size() != positionBuffer.size()) {
             pMesh->mNumFaces = 0;
             throw DeadlyImportError("Normal buffer size does not match position buffer size");
         }
 
         // only process positionbuffer when filled, else exception when accessing with index operator
         // see line 353: only warning is triggered
         // see line 373(now): access to empty positionbuffer with index operator forced exception
         if (!positionBuffer.empty()) {
             pMesh->mNumFaces = static_cast<unsigned int>(positionBuffer.size() / 3);
             pMesh->mNumVertices = static_cast<unsigned int>(positionBuffer.size());
             pMesh->mVertices = new aiVector3D[pMesh->mNumVertices];
             for (size_t i=0; i<pMesh->mNumVertices; ++i ) {
                 pMesh->mVertices[i].x = positionBuffer[i].x;
-                pMesh->mVertices[i].y = positionBuffer[i].y;                
+                pMesh->mVertices[i].y = positionBuffer[i].y;
                 pMesh->mVertices[i].z = positionBuffer[i].z;
             }
             positionBuffer.clear();
         }
         // also only process normalBuffer when filled, else exception when accessing with index operator
         if (!normalBuffer.empty()) {
             pMesh->mNormals = new aiVector3D[pMesh->mNumVertices];
             for (size_t i=0; i<pMesh->mNumVertices; ++i ) {
                 pMesh->mNormals[i].x = normalBuffer[i].x;
-                pMesh->mNormals[i].y = normalBuffer[i].y;                
+                pMesh->mNormals[i].y = normalBuffer[i].y;
                 pMesh->mNormals[i].z = normalBuffer[i].z;
             }
             normalBuffer.clear();
         }
 
         // now copy faces
         addFacesToMesh(pMesh);
 
         // assign the meshes to the current node
         pushMeshesToNode(meshIndices, node);
     }
 
     // now add the loaded meshes
     mScene->mNumMeshes = (unsigned int)meshes.size();
     mScene->mMeshes = new aiMesh *[mScene->mNumMeshes];
     for (size_t i = 0; i < meshes.size(); i++) {
         mScene->mMeshes[i] = meshes[i];
     }
 
     root->mNumChildren = (unsigned int)nodes.size();
     root->mChildren = new aiNode *[root->mNumChildren];
     for (size_t i = 0; i < nodes.size(); ++i) {
         root->mChildren[i] = nodes[i];
     }
 }
 
 // ------------------------------------------------------------------------------------------------
 // Read a binary STL file
diff --git a/code/AssetLib/Step/StepExporter.cpp b/code/AssetLib/Step/StepExporter.cpp
index dfe5bab67..1228c72ea 100644
--- a/code/AssetLib/Step/StepExporter.cpp
+++ b/code/AssetLib/Step/StepExporter.cpp
@@ -160,220 +160,252 @@ StepExporter::StepExporter(const aiScene* pScene, IOSystem* pIOSystem, const std
 // ------------------------------------------------------------------------------------------------
 // Starts writing the contents
 void StepExporter::WriteFile()
 {
     // see http://shodhganga.inflibnet.ac.in:8080/jspui/bitstream/10603/14116/11/11_chapter%203.pdf
     // note, that all realnumber values must be comma separated in x files
     mOutput.setf(std::ios::fixed);
     // precision for double
     // see http://stackoverflow.com/questions/554063/how-do-i-print-a-double-value-with-full-precision-using-cout
     mOutput.precision(ASSIMP_AI_REAL_TEXT_PRECISION);
 
     // standard color
     aiColor4D fColor;
     fColor.r = 0.8f;
     fColor.g = 0.8f;
     fColor.b = 0.8f;
 
     int ind = 100; // the start index to be used
-    int faceEntryLen = 30; // number of entries for a triangle/face
+    std::vector<int> faceEntryLen; // numbers of entries for a triangle/face
     // prepare unique (count triangles and vertices)
 
     VectorIndexUMap uniqueVerts; // use a map to reduce find complexity to log(n)
     VectorIndexUMap::iterator it;
-    int countFace = 0;
 
     for (unsigned int i=0; i<mScene->mNumMeshes; ++i)
     {
         aiMesh* mesh = mScene->mMeshes[i];
         for (unsigned int j=0; j<mesh->mNumFaces; ++j)
         {
             aiFace* face = &(mesh->mFaces[j]);
 
-            if (face->mNumIndices == 3) countFace++;
+            if (face->mNumIndices >= 3) faceEntryLen.push_back(15 + 5 * face->mNumIndices);
         }
         for (unsigned int j=0; j<mesh->mNumVertices; ++j)
         {
             aiVector3D* v = &(mesh->mVertices[j]);
             it =uniqueVerts.find(v);
             if (it == uniqueVerts.end())
             {
                 uniqueVerts[v] = -1; // first mark the vector as not transformed
             }
         }
     }
 
     static const unsigned int date_nb_chars = 20;
     char date_str[date_nb_chars];
     std::time_t date = std::time(nullptr);
     std::strftime(date_str, date_nb_chars, "%Y-%m-%dT%H:%M:%S", std::localtime(&date));
 
     // write the header
     mOutput << "ISO-10303-21" << endstr;
     mOutput << "HEADER" << endstr;
     mOutput << "FILE_DESCRIPTION(('STEP AP214'),'1')" << endstr;
     mOutput << "FILE_NAME('" << mFile << ".stp','" << date_str << "',(' '),(' '),'Spatial InterOp 3D',' ',' ')" << endstr;
     mOutput << "FILE_SCHEMA(('automotive_design'))" << endstr;
     mOutput << "ENDSEC" << endstr;
 
     // write the top of data
     mOutput << "DATA" << endstr;
     mOutput << "#1=MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION(' ',(";
-    for (int i=0; i<countFace; ++i)
+    size_t countFace = faceEntryLen.size();
+    size_t faceLenIndex = ind + 2 * uniqueVerts.size();
+    for (size_t i=0; i<countFace; ++i)
     {
-        mOutput << "#" << i*faceEntryLen + ind + 2*uniqueVerts.size();
+        mOutput << "#" << faceLenIndex;
         if (i!=countFace-1) mOutput << ",";
+        faceLenIndex += faceEntryLen[i];
     }
     mOutput << "),#6)" << endstr;
 
     mOutput << "#2=PRODUCT_DEFINITION_CONTEXT('',#7,'design')" << endstr;
     mOutput << "#3=APPLICATION_PROTOCOL_DEFINITION('INTERNATIONAL STANDARD','automotive_design',1994,#7)" << endstr;
     mOutput << "#4=PRODUCT_CATEGORY_RELATIONSHIP('NONE','NONE',#8,#9)" << endstr;
     mOutput << "#5=SHAPE_DEFINITION_REPRESENTATION(#10,#11)" << endstr;
     mOutput << "#6= (GEOMETRIC_REPRESENTATION_CONTEXT(3)GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT((#12))GLOBAL_UNIT_ASSIGNED_CONTEXT((#13,#14,#15))REPRESENTATION_CONTEXT('NONE','WORKSPACE'))" << endstr;
     mOutput << "#7=APPLICATION_CONTEXT(' ')" << endstr;
     mOutput << "#8=PRODUCT_CATEGORY('part','NONE')" << endstr;
     mOutput << "#9=PRODUCT_RELATED_PRODUCT_CATEGORY('detail',' ',(#17))" << endstr;
     mOutput << "#10=PRODUCT_DEFINITION_SHAPE('NONE','NONE',#18)" << endstr;
     mOutput << "#11=MANIFOLD_SURFACE_SHAPE_REPRESENTATION('Root',(#16,#19),#6)" << endstr;
     mOutput << "#12=UNCERTAINTY_MEASURE_WITH_UNIT(LENGTH_MEASURE(1.0E-006),#13,'','')" << endstr;
     mOutput << "#13=(CONVERSION_BASED_UNIT('METRE',#20)LENGTH_UNIT()NAMED_UNIT(#21))" << endstr;
     mOutput << "#14=(NAMED_UNIT(#22)PLANE_ANGLE_UNIT()SI_UNIT($,.RADIAN.))" << endstr;
     mOutput << "#15=(NAMED_UNIT(#22)SOLID_ANGLE_UNIT()SI_UNIT($,.STERADIAN.))" << endstr;
     mOutput << "#16=SHELL_BASED_SURFACE_MODEL('Root',(#29))" << endstr;
     mOutput << "#17=PRODUCT('Root','Root','Root',(#23))" << endstr;
     mOutput << "#18=PRODUCT_DEFINITION('NONE','NONE',#24,#2)" << endstr;
     mOutput << "#19=AXIS2_PLACEMENT_3D('',#25,#26,#27)" << endstr;
     mOutput << "#20=LENGTH_MEASURE_WITH_UNIT(LENGTH_MEASURE(1.0),#28)" << endstr;
     mOutput << "#21=DIMENSIONAL_EXPONENTS(1.0,0.0,0.0,0.0,0.0,0.0,0.0)" << endstr;
     mOutput << "#22=DIMENSIONAL_EXPONENTS(0.0,0.0,0.0,0.0,0.0,0.0,0.0)" << endstr;
     mOutput << "#23=PRODUCT_CONTEXT('',#7,'mechanical')" << endstr;
     mOutput << "#24=PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE(' ','NONE',#17,.NOT_KNOWN.)" << endstr;
     mOutput << "#25=CARTESIAN_POINT('',(0.0,0.0,0.0))" << endstr;
     mOutput << "#26=DIRECTION('',(0.0,0.0,1.0))" << endstr;
     mOutput << "#27=DIRECTION('',(1.0,0.0,0.0))" << endstr;
     mOutput << "#28= (NAMED_UNIT(#21)LENGTH_UNIT()SI_UNIT(.MILLI.,.METRE.))" << endstr;
     mOutput << "#29=CLOSED_SHELL('',(";
-    for (int i=0; i<countFace; ++i)
+    faceLenIndex = ind + 2 * uniqueVerts.size() + 8;
+    for (size_t i=0; i<countFace; ++i)
     {
-        mOutput << "#" << i*faceEntryLen + ind + 2*uniqueVerts.size() + 8;
+        mOutput << "#" << faceLenIndex;
         if (i!=countFace-1) mOutput << ",";
+        faceLenIndex += faceEntryLen[i];
     }
     mOutput << "))" << endstr;
 
     // write all the unique transformed CARTESIAN and VERTEX
     for (MeshesByNodeMap::const_iterator it2 = meshes.begin(); it2 != meshes.end(); ++it2)
     {
         const aiNode& node = *(*it2).first;
         unsigned int mesh_idx = (*it2).second;
 
         const aiMesh* mesh = mScene->mMeshes[mesh_idx];
         aiMatrix4x4& trafo = trafos[&node];
         for (unsigned int i = 0; i < mesh->mNumVertices; ++i)
         {
             aiVector3D* v = &(mesh->mVertices[i]);
             it = uniqueVerts.find(v);
             if (it->second >=0 ) continue;
             it->second = ind; // this one is new, so set the index (ind)
             aiVector3D vt = trafo * (*v); // transform the coordinate
             mOutput << "#" << it->second << "=CARTESIAN_POINT('',(" << vt.x << "," << vt.y << "," << vt.z << "))" << endstr;
             mOutput << "#" << it->second+1 << "=VERTEX_POINT('',#" << it->second << ")" << endstr;
             ind += 2;
         }
     }
 
     // write the triangles
     for (unsigned int i=0; i<mScene->mNumMeshes; ++i)
     {
         aiMesh* mesh = mScene->mMeshes[i];
         for (unsigned int j=0; j<mesh->mNumFaces; ++j)
         {
             aiFace* face = &(mesh->mFaces[j]);
 
-            if (face->mNumIndices != 3) continue;
-
-            aiVector3D* v1 = &(mesh->mVertices[face->mIndices[0]]);
-            aiVector3D* v2 = &(mesh->mVertices[face->mIndices[1]]);
-            aiVector3D* v3 = &(mesh->mVertices[face->mIndices[2]]);
-            aiVector3D dv12 = *v2 - *v1;
-            aiVector3D dv23 = *v3 - *v2;
-            aiVector3D dv31 = *v1 - *v3;
-            aiVector3D dv13 = *v3 - *v1;
-            dv12.Normalize();
-            dv23.Normalize();
-            dv31.Normalize();
-            dv13.Normalize();
-
-            aiVector3D dvY = dv12;
-            aiVector3D dvX = dvY ^ dv13;
-            dvX.Normalize();
+            const int numIndices = face->mNumIndices;
+            if (numIndices < 3) continue;
 
-            int pid1 = uniqueVerts.find(v1)->second;
-            int pid2 = uniqueVerts.find(v2)->second;
-            int pid3 = uniqueVerts.find(v3)->second;
+            std::vector<int> pidArray(numIndices, -1); // vertex id
+            std::vector<aiVector3D> dvArray(numIndices); // edge dir
+            for (int k = 0; k < numIndices; ++k)
+            {
+                aiVector3D *v1 = &(mesh->mVertices[face->mIndices[k]]);
+                pidArray[k] = uniqueVerts.find(v1)->second;
+
+                aiVector3D *v2 = nullptr;
+                if (k + 1 == numIndices)
+                    v2 = &(mesh->mVertices[face->mIndices[0]]);
+                else
+                    v2 = &(mesh->mVertices[face->mIndices[k + 1]]);
+                dvArray[k] = *v2 - *v1;
+                dvArray[k].Normalize();
+            }
+
+            aiVector3D dvY = dvArray[1];
+            aiVector3D dvX = dvY ^ dvArray[0];
+            dvX.Normalize();
 
             // mean vertex color for the face if available
             if (mesh->HasVertexColors(0))
             {
                 fColor.r = 0.0;
                 fColor.g = 0.0;
                 fColor.b = 0.0;
                 fColor += mesh->mColors[0][face->mIndices[0]];
                 fColor += mesh->mColors[0][face->mIndices[1]];
                 fColor += mesh->mColors[0][face->mIndices[2]];
                 fColor /= 3.0f;
             }
 
             int sid = ind; // the sub index
             mOutput << "#" << sid << "=STYLED_ITEM('',(#" << sid+1 << "),#" << sid+8 << ")" << endstr; /* the item that must be referenced in #1 */
             /* This is the color information of the Triangle */
             mOutput << "#" << sid+1 << "=PRESENTATION_STYLE_ASSIGNMENT((#" << sid+2 << "))" << endstr;
             mOutput << "#" << sid+2 << "=SURFACE_STYLE_USAGE(.BOTH.,#" << sid+3 << ")" << endstr;
             mOutput << "#" << sid+3 << "=SURFACE_SIDE_STYLE('',(#" << sid+4 << "))" << endstr;
             mOutput << "#" << sid+4 << "=SURFACE_STYLE_FILL_AREA(#" << sid+5 << ")" << endstr;
             mOutput << "#" << sid+5 << "=FILL_AREA_STYLE('',(#" << sid+6 << "))" << endstr;
             mOutput << "#" << sid+6 << "=FILL_AREA_STYLE_COLOUR('',#" << sid+7 << ")" << endstr;
             mOutput << "#" << sid+7 << "=COLOUR_RGB(''," << fColor.r << "," << fColor.g << "," << fColor.b << ")" << endstr;
 
             /* this is the geometry */
             mOutput << "#" << sid+8 << "=FACE_SURFACE('',(#" << sid+13 << "),#" << sid+9<< ",.T.)" << endstr; /* the face that must be referenced in 29 */
 
             /* 2 directions of the plane */
             mOutput << "#" << sid+9 << "=PLANE('',#" << sid+10 << ")" << endstr;
-            mOutput << "#" << sid+10 << "=AXIS2_PLACEMENT_3D('',#" << pid1 << ", #" << sid+11 << ",#" << sid+12 << ")" << endstr;
+            mOutput << "#" << sid+10 << "=AXIS2_PLACEMENT_3D('',#" << pidArray[0] << ",#" << sid+11 << ",#" << sid+12 << ")" << endstr;
 
             mOutput << "#" << sid + 11 << "=DIRECTION('',(" << dvX.x << "," << dvX.y << "," << dvX.z << "))" << endstr;
             mOutput << "#" << sid + 12 << "=DIRECTION('',(" << dvY.x << "," << dvY.y << "," << dvY.z << "))" << endstr;
 
             mOutput << "#" << sid+13 << "=FACE_BOUND('',#" << sid+14 << ",.T.)" << endstr;
-            mOutput << "#" << sid+14 << "=EDGE_LOOP('',(#" << sid+15 << ",#" << sid+16 << ",#" << sid+17 << "))" << endstr;
+            mOutput << "#" << sid+14 << "=EDGE_LOOP('',(";
+            int edgeLoopStart = sid + 15;
+            for (int k = 0; k < numIndices; ++k)
+            {
+                if (k == 0)
+                    mOutput << "#";
+                else
+                    mOutput << ",#";
+                mOutput << edgeLoopStart + k;
+            }
+            mOutput << "))" << endstr;
 
             /* edge loop  */
-            mOutput << "#" << sid+15 << "=ORIENTED_EDGE('',*,*,#" << sid+18 << ",.T.)" << endstr;
-            mOutput << "#" << sid+16 << "=ORIENTED_EDGE('',*,*,#" << sid+19 << ",.T.)" << endstr;
-            mOutput << "#" << sid+17 << "=ORIENTED_EDGE('',*,*,#" << sid+20 << ",.T.)" << endstr;
+            int orientedEdgesStart = edgeLoopStart + numIndices;
+            for (int k=0; k < numIndices; k++)
+            {
+                mOutput << "#" << edgeLoopStart+k << "=ORIENTED_EDGE('',*,*,#" << orientedEdgesStart + k << ",.T.)" << endstr;
+            }
 
             /* oriented edges */
-            mOutput << "#" << sid+18 << "=EDGE_CURVE('',#" << pid1+1 << ",#" << pid2+1 << ",#" << sid+21 << ",.F.)" << endstr;
-            mOutput << "#" << sid+19 << "=EDGE_CURVE('',#" << pid2+1 << ",#" << pid3+1 << ",#" << sid+22 << ",.T.)" << endstr;
-            mOutput << "#" << sid+20 << "=EDGE_CURVE('',#" << pid3+1 << ",#" << pid1+1 << ",#" << sid+23 << ",.T.)" << endstr;
-
-            /* 3 lines and 3 vectors for the lines for the 3 edge curves */
-            mOutput << "#" << sid+21 << "=LINE('',#" << pid1 << ",#" << sid+24 << ")" << endstr;
-            mOutput << "#" << sid+22 << "=LINE('',#" << pid2 << ",#" << sid+25 << ")" << endstr;
-            mOutput << "#" << sid+23 << "=LINE('',#" << pid3 << ",#" << sid+26 << ")" << endstr;
-            mOutput << "#" << sid+24 << "=VECTOR('',#" << sid+27 << ",1.0)" << endstr;
-            mOutput << "#" << sid+25 << "=VECTOR('',#" << sid+28 << ",1.0)" << endstr;
-            mOutput << "#" << sid+26 << "=VECTOR('',#" << sid+29 << ",1.0)" << endstr;
-            mOutput << "#" << sid+27 << "=DIRECTION('',(" << dv12.x << "," << dv12.y << "," << dv12.z << "))" << endstr;
-            mOutput << "#" << sid+28 << "=DIRECTION('',(" << dv23.x << "," << dv23.y << "," << dv23.z << "))" << endstr;
-            mOutput << "#" << sid+29 << "=DIRECTION('',(" << dv31.x << "," << dv31.y << "," << dv31.z << "))" << endstr;
-            ind += faceEntryLen; // increase counter
+            int lineStart = orientedEdgesStart + numIndices;
+            for (int k=0; k < numIndices; ++k)
+            {
+                if (k == 0)
+                    mOutput << "#" << orientedEdgesStart+k << "=EDGE_CURVE('',#" << pidArray[k]+1 << ",#" << pidArray[k+1]+1 << ",#" << lineStart+k << ",.F.)" << endstr;
+                else if (k+1 == numIndices)
+                    mOutput << "#" << orientedEdgesStart+k << "=EDGE_CURVE('',#" << pidArray[k]+1 << ",#" << pidArray[0]+1 << ",#" << lineStart+k << ",.T.)" << endstr;
+                else
+                    mOutput << "#" << orientedEdgesStart+k << "=EDGE_CURVE('',#" << pidArray[k]+1 << ",#" << pidArray[k+1]+1 << ",#" << lineStart+k << ",.T.)" << endstr;
+            }
+
+            /* n lines and n vectors for the lines for the n edge curves */
+            int vectorStart = lineStart + numIndices;
+            for (int k=0; k < numIndices; ++k)
+            {
+                mOutput << "#" << lineStart+k << "=LINE('',#" << pidArray[k] << ",#" << vectorStart+k << ")" << endstr;
+            }
+
+            int directionStart = vectorStart + numIndices;
+            for (int k=0; k < numIndices; ++k)
+            {
+                mOutput << "#" << vectorStart+k << "=VECTOR('',#" << directionStart+k << ",1.0)" << endstr;
+            }
+
+            for (int k=0; k < numIndices; ++k)
+            {
+                const aiVector3D &dv = dvArray[k];
+                mOutput << "#" << directionStart + k << "=DIRECTION('',(" << dv.x << "," << dv.y << "," << dv.z << "))" << endstr;
+            }
+            ind += 15 + 5*numIndices; // increase counter
         }
     }
 
     mOutput << "ENDSEC" << endstr; // end of data section
     mOutput << "END-ISO-10303-21" << endstr; // end of file
 }
 
 #endif
 #endif
diff --git a/code/AssetLib/X/XFileExporter.cpp b/code/AssetLib/X/XFileExporter.cpp
index bd997a3c5..b95cb7abf 100644
--- a/code/AssetLib/X/XFileExporter.cpp
+++ b/code/AssetLib/X/XFileExporter.cpp
@@ -70,35 +70,35 @@ namespace Assimp
 // ------------------------------------------------------------------------------------------------
 // Worker function for exporting a scene to Collada. Prototyped and registered in Exporter.cpp
 void ExportSceneXFile(const char* pFile,IOSystem* pIOSystem, const aiScene* pScene, const ExportProperties* pProperties)
 {
     std::string path = DefaultIOSystem::absolutePath(std::string(pFile));
     std::string file = DefaultIOSystem::completeBaseName(std::string(pFile));
 
     // create/copy Properties
     ExportProperties props(*pProperties);
 
     // set standard properties if not set
     if (!props.HasPropertyBool(AI_CONFIG_EXPORT_XFILE_64BIT)) props.SetPropertyBool(AI_CONFIG_EXPORT_XFILE_64BIT, false);
 
     // invoke the exporter
     XFileExporter iDoTheExportThing( pScene, pIOSystem, path, file, &props);
 
     if (iDoTheExportThing.mOutput.fail()) {
         throw DeadlyExportError("output data creation failed. Most likely the file became too large: " + std::string(pFile));
     }
-    
+
     // we're still here - export successfully completed. Write result to the given IOSYstem
     std::unique_ptr<IOStream> outfile (pIOSystem->Open(pFile,"wt"));
     if (outfile == nullptr) {
         throw DeadlyExportError("could not open output .x file: " + std::string(pFile));
     }
 
     // XXX maybe use a small wrapper around IOStream that behaves like std::stringstream in order to avoid the extra copy.
     outfile->Write( iDoTheExportThing.mOutput.str().c_str(), static_cast<size_t>(iDoTheExportThing.mOutput.tellp()),1);
 }
 
 } // end of namespace Assimp
 
 
 // ------------------------------------------------------------------------------------------------
 // Constructor for a specific scene to export
diff --git a/code/AssetLib/X/XFileExporter.h b/code/AssetLib/X/XFileExporter.h
index 32b75b3d1..620d282b6 100644
--- a/code/AssetLib/X/XFileExporter.h
+++ b/code/AssetLib/X/XFileExporter.h
@@ -77,26 +77,26 @@ public:
 protected:
     /// Starts writing the contents
     void WriteFile();
 
     /// Writes the asset header
     void WriteHeader();
 
     /// write a frame transform
     void WriteFrameTransform(aiMatrix4x4& m);
 
     /// Recursively writes the given node
     void WriteNode( aiNode* pNode );
 
     /// write a mesh entry of the scene
     void WriteMesh( aiMesh* mesh);
 
     /// Enters a new xml element, which increases the indentation
     void PushTag() { startstr.append( "  "); }
 
     /// Leaves an element, decreasing the indentation
-    void PopTag() { 
-        ai_assert( startstr.length() > 1); 
-        startstr.erase( startstr.length() - 2); 
+    void PopTag() {
+        ai_assert( startstr.length() > 1);
+        startstr.erase( startstr.length() - 2);
     }
 
 public:
diff --git a/code/AssetLib/X/XFileImporter.cpp b/code/AssetLib/X/XFileImporter.cpp
index df1aba331..4c8c54551 100644
--- a/code/AssetLib/X/XFileImporter.cpp
+++ b/code/AssetLib/X/XFileImporter.cpp
@@ -568,135 +568,133 @@ void XFileImporter::CreateAnimations( aiScene* pScene, const XFile::Scene* pData
 // ------------------------------------------------------------------------------------------------
 // Converts all materials in the given array and stores them in the scene's material list.
 void XFileImporter::ConvertMaterials( aiScene* pScene, std::vector<XFile::Material>& pMaterials)
 {
     // count the non-referrer materials in the array
     unsigned int numNewMaterials( 0 );
     for ( unsigned int a = 0; a < pMaterials.size(); ++a ) {
         if ( !pMaterials[ a ].mIsReference ) {
             ++numNewMaterials;
         }
     }
 
     // resize the scene's material list to offer enough space for the new materials
     if( numNewMaterials > 0 ) {
         aiMaterial** prevMats = pScene->mMaterials;
         pScene->mMaterials = new aiMaterial*[pScene->mNumMaterials + numNewMaterials];
         if( nullptr != prevMats)  {
             ::memcpy( pScene->mMaterials, prevMats, pScene->mNumMaterials * sizeof( aiMaterial*));
             delete [] prevMats;
         }
     }
 
     // convert all the materials given in the array
     for( unsigned int a = 0; a < pMaterials.size(); ++a ) {
         XFile::Material& oldMat = pMaterials[a];
         if( oldMat.mIsReference) {
             // find the material it refers to by name, and store its index
             for( size_t b = 0; b < pScene->mNumMaterials; ++b ) {
                 aiString name;
                 pScene->mMaterials[b]->Get( AI_MATKEY_NAME, name);
                 if( strcmp( name.C_Str(), oldMat.mName.data()) == 0 ) {
                     oldMat.sceneIndex = a;
                     break;
                 }
             }
 
             if( oldMat.sceneIndex == SIZE_MAX ) {
                 ASSIMP_LOG_WARN( "Could not resolve global material reference \"", oldMat.mName, "\"" );
                 oldMat.sceneIndex = 0;
             }
 
             continue;
         }
 
         aiMaterial* mat = new aiMaterial;
         aiString name;
         name.Set( oldMat.mName);
         mat->AddProperty( &name, AI_MATKEY_NAME);
 
         // Shading model: hard-coded to PHONG, there is no such information in an XFile
         // FIX (aramis): If the specular exponent is 0, use gouraud shading. This is a bugfix
         // for some models in the SDK (e.g. good old tiny.x)
         int shadeMode = (int)oldMat.mSpecularExponent == 0.0f
             ? aiShadingMode_Gouraud : aiShadingMode_Phong;
 
         mat->AddProperty<int>( &shadeMode, 1, AI_MATKEY_SHADING_MODEL);
         // material colours
         // Unclear: there's no ambient colour, but emissive. What to put for ambient?
         // Probably nothing at all, let the user select a suitable default.
         mat->AddProperty( &oldMat.mEmissive, 1, AI_MATKEY_COLOR_EMISSIVE);
         mat->AddProperty( &oldMat.mDiffuse, 1, AI_MATKEY_COLOR_DIFFUSE);
         mat->AddProperty( &oldMat.mSpecular, 1, AI_MATKEY_COLOR_SPECULAR);
         mat->AddProperty( &oldMat.mSpecularExponent, 1, AI_MATKEY_SHININESS);
 
 
         // texture, if there is one
         if (1 == oldMat.mTextures.size() ) {
             const XFile::TexEntry& otex = oldMat.mTextures.back();
             if (otex.mName.length()) {
                 // if there is only one texture assume it contains the diffuse color
                 aiString tex( otex.mName);
                 if ( otex.mIsNormalMap ) {
                     mat->AddProperty( &tex, AI_MATKEY_TEXTURE_NORMALS( 0 ) );
                 } else {
                     mat->AddProperty( &tex, AI_MATKEY_TEXTURE_DIFFUSE( 0 ) );
                 }
             }
         } else {
             // Otherwise ... try to search for typical strings in the
             // texture's file name like 'bump' or 'diffuse'
             unsigned int iHM = 0,iNM = 0,iDM = 0,iSM = 0,iAM = 0,iEM = 0;
             for( unsigned int b = 0; b < oldMat.mTextures.size(); ++b ) {
                 const XFile::TexEntry& otex = oldMat.mTextures[b];
                 std::string sz = otex.mName;
                 if ( !sz.length() ) {
                     continue;
                 }
 
                 // find the file name
                 std::string::size_type s = sz.find_last_of("\\/");
                 if ( std::string::npos == s ) {
                     s = 0;
                 }
 
                 // cut off the file extension
                 std::string::size_type sExt = sz.find_last_of('.');
                 if (std::string::npos != sExt){
                     sz[sExt] = '\0';
                 }
 
                 // convert to lower case for easier comparison
                 for ( unsigned int c = 0; c < sz.length(); ++c ) {
-                    if ( isalpha( (unsigned char) sz[ c ] ) ) {
-                        sz[ c ] = (char) tolower( (unsigned char) sz[ c ] );
-                    }
+                    sz[ c ] = (char) tolower( (unsigned char) sz[ c ] );
                 }
 
                 // Place texture filename property under the corresponding name
                 aiString tex( oldMat.mTextures[b].mName);
 
                 // bump map
                 if (std::string::npos != sz.find("bump", s) || std::string::npos != sz.find("height", s)) {
                     mat->AddProperty( &tex, AI_MATKEY_TEXTURE_HEIGHT(iHM++));
                 } else if (otex.mIsNormalMap || std::string::npos != sz.find( "normal", s) || std::string::npos != sz.find("nm", s)) {
                     mat->AddProperty( &tex, AI_MATKEY_TEXTURE_NORMALS(iNM++));
                 } else if (std::string::npos != sz.find( "spec", s) || std::string::npos != sz.find( "glanz", s)) {
                     mat->AddProperty( &tex, AI_MATKEY_TEXTURE_SPECULAR(iSM++));
                 } else if (std::string::npos != sz.find( "ambi", s) || std::string::npos != sz.find( "env", s)) {
                     mat->AddProperty( &tex, AI_MATKEY_TEXTURE_AMBIENT(iAM++));
                 } else if (std::string::npos != sz.find( "emissive", s) || std::string::npos != sz.find( "self", s)) {
                     mat->AddProperty( &tex, AI_MATKEY_TEXTURE_EMISSIVE(iEM++));
                 } else {
                     // Assume it is a diffuse texture
                     mat->AddProperty( &tex, AI_MATKEY_TEXTURE_DIFFUSE(iDM++));
                 }
             }
         }
 
         pScene->mMaterials[pScene->mNumMaterials] = mat;
         oldMat.sceneIndex = pScene->mNumMaterials;
         pScene->mNumMaterials++;
     }
 }
 
 #endif // !! ASSIMP_BUILD_NO_X_IMPORTER
diff --git a/code/AssetLib/X3D/X3DImporter.cpp b/code/AssetLib/X3D/X3DImporter.cpp
index 121b7490e..71c35c369 100644
--- a/code/AssetLib/X3D/X3DImporter.cpp
+++ b/code/AssetLib/X3D/X3DImporter.cpp
@@ -179,7 +179,7 @@ void X3DImporter::InternReadFile( const std::string &pFile, aiScene *pScene, IOS
 const aiImporterDesc *X3DImporter::GetInfo() const {
     return &Description;
 }
 
-} 
+}
 
 #endif // !ASSIMP_BUILD_NO_X3D_IMPORTER
diff --git a/code/AssetLib/XGL/XGLLoader.cpp b/code/AssetLib/XGL/XGLLoader.cpp
index 3b84d7ba9..20c2c7079 100644
--- a/code/AssetLib/XGL/XGLLoader.cpp
+++ b/code/AssetLib/XGL/XGLLoader.cpp
@@ -239,26 +239,26 @@ void XGLImporter::InternReadFile(const std::string &pFile, aiScene *pScene, IOSy
 // ------------------------------------------------------------------------------------------------
 void XGLImporter::ReadWorld(XmlNode &node, TempScope &scope) {
     for (XmlNode &currentNode : node.children()) {
         const std::string &s = ai_stdStrToLower(currentNode.name());
-        
+
 		// XXX right now we'd skip <lighting> if it comes after
 		// <object> or <mesh>
 		if (s == "lighting") {
             ReadLighting(currentNode, scope);
 		} else if (s == "object" || s == "mesh" || s == "mat") {
 			break;
 		}
 	}
 
 	aiNode *const nd = ReadObject(node, scope, true);
 	if (!nd) {
 		ThrowException("failure reading <world>");
 	}
 	if (!nd->mName.length) {
 		nd->mName.Set("WORLD");
 	}
 
 	m_scene->mRootNode = nd;
 }
 
 // ------------------------------------------------------------------------------------------------
diff --git a/code/AssetLib/glTF/glTFCommon.h b/code/AssetLib/glTF/glTFCommon.h
index 0506ad056..6f35e7881 100644
--- a/code/AssetLib/glTF/glTFCommon.h
+++ b/code/AssetLib/glTF/glTFCommon.h
@@ -195,12 +195,12 @@ inline void CopyValue(const glTFCommon::mat4 &v, aiMatrix4x4 &o) {
 inline std::string getCurrentAssetDir(const std::string &pFile) {
     std::string path = pFile;
     int pos = std::max(int(pFile.rfind('/')), int(pFile.rfind('\\')));
     if (pos == int(std::string::npos)) {
-        return "";
+        return std::string();
     }
 
     return pFile.substr(0, pos + 1);
 }
 #if _MSC_VER
 #    pragma warning(pop)
 #endif // _MSC_VER
diff --git a/code/AssetLib/glTF2/glTF2Asset.h b/code/AssetLib/glTF2/glTF2Asset.h
index bb97e3732..cd6c1c89d 100644
--- a/code/AssetLib/glTF2/glTF2Asset.h
+++ b/code/AssetLib/glTF2/glTF2Asset.h
@@ -359,48 +359,48 @@ struct Nullable {
 struct CustomExtension {
     //
     // A struct containing custom extension data added to a glTF2 file
     // Has to contain Object, Array, String, Double, Uint64, and Int64 at a minimum
     // String, Double, Uint64, and Int64 are stored in the Nullables
     // Object and Array are stored in the std::vector
     //
     std::string name;
 
     Nullable<std::string> mStringValue;
     Nullable<double> mDoubleValue;
     Nullable<uint64_t> mUint64Value;
     Nullable<int64_t> mInt64Value;
     Nullable<bool> mBoolValue;
 
     // std::vector<CustomExtension> handles both Object and Array
     Nullable<std::vector<CustomExtension>> mValues;
 
     operator bool() const {
         return Size() != 0;
     }
 
     size_t Size() const {
         if (mValues.isPresent) {
             return mValues.value.size();
         } else if (mStringValue.isPresent || mDoubleValue.isPresent || mUint64Value.isPresent || mInt64Value.isPresent || mBoolValue.isPresent) {
             return 1;
         }
         return 0;
     }
 
     CustomExtension() = default;
-    
+
     ~CustomExtension() = default;
-    
+
     CustomExtension(const CustomExtension &other) :
             name(other.name),
             mStringValue(other.mStringValue),
             mDoubleValue(other.mDoubleValue),
             mUint64Value(other.mUint64Value),
             mInt64Value(other.mInt64Value),
             mBoolValue(other.mBoolValue),
             mValues(other.mValues) {
         // empty
     }
 };
 
 //! Base class for all glTF top-level objects
diff --git a/code/AssetLib/glTF2/glTF2Asset.inl b/code/AssetLib/glTF2/glTF2Asset.inl
index 58095c7bd..d5f5b5cd0 100644
--- a/code/AssetLib/glTF2/glTF2Asset.inl
+++ b/code/AssetLib/glTF2/glTF2Asset.inl
@@ -393,37 +393,37 @@ inline void CopyFaceIndex_Draco(Buffer &decodedIndexBuffer, const draco::Mesh &d
 inline void SetDecodedIndexBuffer_Draco(const draco::Mesh &dracoMesh, Mesh::Primitive &prim) {
     if (!prim.indices || dracoMesh.num_faces() == 0)
         return;
 
     // Create a decoded Index buffer (if there is one)
     size_t componentBytes = prim.indices->GetBytesPerComponent();
 
     std::unique_ptr<Buffer> decodedIndexBuffer(new Buffer());
     decodedIndexBuffer->Grow(dracoMesh.num_faces() * 3 * componentBytes);
 
     // If accessor uses the same size as draco implementation, copy the draco buffer directly
 
     // Usually uint32_t but shouldn't assume
     if (sizeof(dracoMesh.face(draco::FaceIndex(0))[0]) == componentBytes) {
         memcpy(decodedIndexBuffer->GetPointer(), &dracoMesh.face(draco::FaceIndex(0))[0], decodedIndexBuffer->byteLength);
         return;
     }
 
     // Not same size, convert
     switch (componentBytes) {
-        case sizeof(uint32_t): 
-            CopyFaceIndex_Draco<uint32_t>(*decodedIndexBuffer, dracoMesh); 
+        case sizeof(uint32_t):
+            CopyFaceIndex_Draco<uint32_t>(*decodedIndexBuffer, dracoMesh);
             break;
-        case sizeof(uint16_t): 
-            CopyFaceIndex_Draco<uint16_t>(*decodedIndexBuffer, dracoMesh); 
+        case sizeof(uint16_t):
+            CopyFaceIndex_Draco<uint16_t>(*decodedIndexBuffer, dracoMesh);
             break;
-        case sizeof(uint8_t): 
-            CopyFaceIndex_Draco<uint8_t>(*decodedIndexBuffer, dracoMesh); 
+        case sizeof(uint8_t):
+            CopyFaceIndex_Draco<uint8_t>(*decodedIndexBuffer, dracoMesh);
             break;
         default:
             ai_assert(false);
             break;
     }
 
     // Assign this alternate data buffer to the accessor
     prim.indices->decodedBuffer.swap(decodedIndexBuffer);
 }
@@ -450,45 +450,45 @@ static bool GetAttributeForAllPoints_Draco(const draco::Mesh &dracoMesh,
 inline void SetDecodedAttributeBuffer_Draco(const draco::Mesh &dracoMesh, uint32_t dracoAttribId, Accessor &accessor) {
     // Create decoded buffer
     const draco::PointAttribute *pDracoAttribute = dracoMesh.GetAttributeByUniqueId(dracoAttribId);
     if (pDracoAttribute == nullptr) {
         throw DeadlyImportError("GLTF: Invalid draco attribute id: ", dracoAttribId);
     }
 
     size_t componentBytes = accessor.GetBytesPerComponent();
 
     std::unique_ptr<Buffer> decodedAttribBuffer(new Buffer());
     decodedAttribBuffer->Grow(dracoMesh.num_points() * pDracoAttribute->num_components() * componentBytes);
 
     switch (accessor.componentType) {
-        case ComponentType_BYTE: 
-            GetAttributeForAllPoints_Draco<int8_t>(dracoMesh, *pDracoAttribute, *decodedAttribBuffer); 
+        case ComponentType_BYTE:
+            GetAttributeForAllPoints_Draco<int8_t>(dracoMesh, *pDracoAttribute, *decodedAttribBuffer);
             break;
         case ComponentType_UNSIGNED_BYTE:
-            GetAttributeForAllPoints_Draco<uint8_t>(dracoMesh, *pDracoAttribute, *decodedAttribBuffer); 
+            GetAttributeForAllPoints_Draco<uint8_t>(dracoMesh, *pDracoAttribute, *decodedAttribBuffer);
             break;
         case ComponentType_SHORT:
             GetAttributeForAllPoints_Draco<int16_t>(dracoMesh, *pDracoAttribute, *decodedAttribBuffer);
             break;
-        case ComponentType_UNSIGNED_SHORT: 
-            GetAttributeForAllPoints_Draco<uint16_t>(dracoMesh, *pDracoAttribute, *decodedAttribBuffer); 
+        case ComponentType_UNSIGNED_SHORT:
+            GetAttributeForAllPoints_Draco<uint16_t>(dracoMesh, *pDracoAttribute, *decodedAttribBuffer);
             break;
-        case ComponentType_UNSIGNED_INT: 
-            GetAttributeForAllPoints_Draco<uint32_t>(dracoMesh, *pDracoAttribute, *decodedAttribBuffer); 
+        case ComponentType_UNSIGNED_INT:
+            GetAttributeForAllPoints_Draco<uint32_t>(dracoMesh, *pDracoAttribute, *decodedAttribBuffer);
             break;
-        case ComponentType_FLOAT: 
-            GetAttributeForAllPoints_Draco<float>(dracoMesh, *pDracoAttribute, *decodedAttribBuffer); 
+        case ComponentType_FLOAT:
+            GetAttributeForAllPoints_Draco<float>(dracoMesh, *pDracoAttribute, *decodedAttribBuffer);
             break;
         default:
             ai_assert(false);
             break;
     }
 
     // Assign this alternate data buffer to the accessor
     accessor.decodedBuffer.swap(decodedAttribBuffer);
 }
 
 #endif // ASSIMP_ENABLE_DRACO
 
 //
 // LazyDict methods
 //
@@ -840,11 +840,11 @@ inline bool Buffer::ReplaceData_joint(const size_t pBufferData_Offset, const siz
 
 inline size_t Buffer::AppendData(uint8_t *data, size_t length) {
     const size_t offset = this->byteLength;
-    
+
     // Force alignment to 4 bits
     const size_t paddedLength = (length + 3) & ~3;
     Grow(paddedLength);
     memcpy(mData.get() + offset, data, length);
     memset(mData.get() + offset + length, 0, paddedLength - length);
     return offset;
 }
diff --git a/code/AssetLib/glTF2/glTF2AssetWriter.inl b/code/AssetLib/glTF2/glTF2AssetWriter.inl
index bf7dbbb2e..115cdf903 100644
--- a/code/AssetLib/glTF2/glTF2AssetWriter.inl
+++ b/code/AssetLib/glTF2/glTF2AssetWriter.inl
@@ -46,925 +46,925 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 namespace glTF2 {
 
     using rapidjson::StringBuffer;
     using rapidjson::PrettyWriter;
     using rapidjson::Writer;
     using rapidjson::StringRef;
     using rapidjson::StringRef;
 
     namespace {
 
         template<typename T, size_t N>
         inline Value& MakeValue(Value& val, T(&r)[N], MemoryPoolAllocator<>& al) {
             val.SetArray();
             val.Reserve(N, al);
             for (decltype(N) i = 0; i < N; ++i) {
                 val.PushBack(r[i], al);
             }
             return val;
         }
 
         template<typename T>
         inline Value& MakeValue(Value& val, const std::vector<T> & r, MemoryPoolAllocator<>& al) {
             val.SetArray();
             val.Reserve(static_cast<rapidjson::SizeType>(r.size()), al);
             for (unsigned int i = 0; i < r.size(); ++i) {
                 val.PushBack(r[i], al);
             }
             return val;
         }
 
         template<typename C, typename T>
         inline Value& MakeValueCast(Value& val, const std::vector<T> & r, MemoryPoolAllocator<>& al) {
             val.SetArray();
             val.Reserve(static_cast<rapidjson::SizeType>(r.size()), al);
             for (unsigned int i = 0; i < r.size(); ++i) {
                 val.PushBack(static_cast<C>(r[i]), al);
             }
             return val;
         }
 
         template<typename T>
         inline Value& MakeValue(Value& val, T r, MemoryPoolAllocator<>& /*al*/) {
             val.Set(r);
 
             return val;
         }
 
         template<class T>
         inline void AddRefsVector(Value& obj, const char* fieldId, std::vector< Ref<T> >& v, MemoryPoolAllocator<>& al) {
             if (v.empty()) return;
             Value lst;
             lst.SetArray();
             lst.Reserve(unsigned(v.size()), al);
             for (size_t i = 0; i < v.size(); ++i) {
                 lst.PushBack(v[i]->index, al);
             }
             obj.AddMember(StringRef(fieldId), lst, al);
         }
 
 
     }
 
     inline void Write(Value& obj, Accessor& a, AssetWriter& w)
     {
         if (a.bufferView) {
             obj.AddMember("bufferView", a.bufferView->index, w.mAl);
             obj.AddMember("byteOffset", (unsigned int)a.byteOffset, w.mAl);
         }
         obj.AddMember("componentType", int(a.componentType), w.mAl);
         obj.AddMember("count", (unsigned int)a.count, w.mAl);
         obj.AddMember("type", StringRef(AttribType::ToString(a.type)), w.mAl);
         Value vTmpMax, vTmpMin;
         if (a.componentType == ComponentType_FLOAT) {
             obj.AddMember("max", MakeValue(vTmpMax, a.max, w.mAl), w.mAl);
             obj.AddMember("min", MakeValue(vTmpMin, a.min, w.mAl), w.mAl);
         } else {
             obj.AddMember("max", MakeValueCast<int64_t>(vTmpMax, a.max, w.mAl), w.mAl);
             obj.AddMember("min", MakeValueCast<int64_t>(vTmpMin, a.min, w.mAl), w.mAl);
         }
 
         if (a.sparse) {
             Value sparseValue;
             sparseValue.SetObject();
 
             //count
             sparseValue.AddMember("count", (unsigned int)a.sparse->count, w.mAl);
 
             //indices
             Value indices;
             indices.SetObject();
             indices.AddMember("bufferView", a.sparse->indices->index, w.mAl);
             indices.AddMember("byteOffset", (unsigned int)a.sparse->indicesByteOffset, w.mAl);
             indices.AddMember("componentType", int(a.sparse->indicesType), w.mAl);
             sparseValue.AddMember("indices", indices, w.mAl);
 
             //values
             Value values;
             values.SetObject();
             values.AddMember("bufferView", a.sparse->values->index, w.mAl);
             values.AddMember("byteOffset", (unsigned int)a.sparse->valuesByteOffset, w.mAl);
             sparseValue.AddMember("values", values, w.mAl);
 
             obj.AddMember("sparse", sparseValue, w.mAl);
         }
     }
 
     inline void Write(Value& obj, Animation& a, AssetWriter& w)
     {
         /****************** Channels *******************/
         Value channels;
         channels.SetArray();
         channels.Reserve(unsigned(a.channels.size()), w.mAl);
 
         for (size_t i = 0; i < unsigned(a.channels.size()); ++i) {
             Animation::Channel& c = a.channels[i];
             Value valChannel;
             valChannel.SetObject();
             {
                 valChannel.AddMember("sampler", c.sampler, w.mAl);
 
                 Value valTarget;
                 valTarget.SetObject();
                 {
                     valTarget.AddMember("node", c.target.node->index, w.mAl);
                     switch (c.target.path) {
                         case AnimationPath_TRANSLATION:
                             valTarget.AddMember("path", "translation", w.mAl);
                             break;
                         case AnimationPath_ROTATION:
                             valTarget.AddMember("path", "rotation", w.mAl);
                             break;
                         case AnimationPath_SCALE:
                             valTarget.AddMember("path", "scale", w.mAl);
                             break;
                         case AnimationPath_WEIGHTS:
                             valTarget.AddMember("path", "weights", w.mAl);
                             break;
                     }
                 }
                 valChannel.AddMember("target", valTarget, w.mAl);
             }
             channels.PushBack(valChannel, w.mAl);
         }
         obj.AddMember("channels", channels, w.mAl);
 
         /****************** Samplers *******************/
         Value valSamplers;
         valSamplers.SetArray();
 
         for (size_t i = 0; i < unsigned(a.samplers.size()); ++i) {
             Animation::Sampler& s = a.samplers[i];
             Value valSampler;
             valSampler.SetObject();
             {
                 valSampler.AddMember("input", s.input->index, w.mAl);
                 switch (s.interpolation) {
                     case Interpolation_LINEAR:
                         valSampler.AddMember("interpolation", "LINEAR", w.mAl);
                         break;
                     case Interpolation_STEP:
                         valSampler.AddMember("interpolation", "STEP", w.mAl);
                         break;
                     case Interpolation_CUBICSPLINE:
                         valSampler.AddMember("interpolation", "CUBICSPLINE", w.mAl);
                         break;
                 }
                 valSampler.AddMember("output", s.output->index, w.mAl);
             }
             valSamplers.PushBack(valSampler, w.mAl);
         }
         obj.AddMember("samplers", valSamplers, w.mAl);
     }
 
     inline void Write(Value& obj, Buffer& b, AssetWriter& w)
     {
         obj.AddMember("byteLength", static_cast<uint64_t>(b.byteLength), w.mAl);
 
         const auto uri = b.GetURI();
         const auto relativeUri = uri.substr(uri.find_last_of("/\\") + 1u);
         obj.AddMember("uri", Value(relativeUri, w.mAl).Move(), w.mAl);
     }
 
     inline void Write(Value& obj, BufferView& bv, AssetWriter& w)
     {
         obj.AddMember("buffer", bv.buffer->index, w.mAl);
         obj.AddMember("byteOffset", static_cast<uint64_t>(bv.byteOffset), w.mAl);
         obj.AddMember("byteLength", static_cast<uint64_t>(bv.byteLength), w.mAl);
         if (bv.byteStride != 0) {
             obj.AddMember("byteStride", bv.byteStride, w.mAl);
         }
         if (bv.target != BufferViewTarget_NONE) {
             obj.AddMember("target", int(bv.target), w.mAl);
         }
     }
 
     inline void Write(Value& /*obj*/, Camera& /*c*/, AssetWriter& /*w*/)
     {
 
     }
 
     inline void Write(Value& /*obj*/, Light& /*c*/, AssetWriter& /*w*/)
     {
 
     }
 
     inline void Write(Value& obj, Image& img, AssetWriter& w)
     {
         //basisu: no need to handle .ktx2, .basis, write as is
         if (img.bufferView) {
             obj.AddMember("bufferView", img.bufferView->index, w.mAl);
             obj.AddMember("mimeType", Value(img.mimeType, w.mAl).Move(), w.mAl);
         }
         else {
             std::string uri;
             if (img.HasData()) {
                 uri = "data:" + (img.mimeType.empty() ? "application/octet-stream" : img.mimeType);
                 uri += ";base64,";
                 glTFCommon::Util::EncodeBase64(img.GetData(), img.GetDataLength(), uri);
             }
             else {
                 uri = img.uri;
             }
 
             obj.AddMember("uri", Value(uri, w.mAl).Move(), w.mAl);
         }
     }
 
     namespace {
         inline void SetTexBasic(TextureInfo t, Value& tex, MemoryPoolAllocator<>& al)
         {
             tex.SetObject();
             tex.AddMember("index", t.texture->index, al);
 
             if (t.texCoord != 0) {
                 tex.AddMember("texCoord", t.texCoord, al);
             }
         }
 
         inline void WriteTex(Value& obj, TextureInfo t, const char* propName, MemoryPoolAllocator<>& al)
         {
 
             if (t.texture) {
                 Value tex;
 
                 SetTexBasic(t, tex, al);
 
                 obj.AddMember(StringRef(propName), tex, al);
             }
         }
 
         inline void WriteTex(Value& obj, NormalTextureInfo t, const char* propName, MemoryPoolAllocator<>& al)
         {
 
             if (t.texture) {
                 Value tex;
 
                 SetTexBasic(t, tex, al);
 
                 if (t.scale != 1) {
                     tex.AddMember("scale", t.scale, al);
                 }
 
                 obj.AddMember(StringRef(propName), tex, al);
             }
         }
 
         inline void WriteTex(Value& obj, OcclusionTextureInfo t, const char* propName, MemoryPoolAllocator<>& al)
         {
 
             if (t.texture) {
                 Value tex;
 
                 SetTexBasic(t, tex, al);
 
                 if (t.strength != 1) {
                     tex.AddMember("strength", t.strength, al);
                 }
 
                 obj.AddMember(StringRef(propName), tex, al);
             }
         }
 
         template<size_t N>
         inline void WriteVec(Value& obj, float(&prop)[N], const char* propName, MemoryPoolAllocator<>& al)
         {
             Value arr;
             obj.AddMember(StringRef(propName), MakeValue(arr, prop, al), al);
         }
 
         template<size_t N>
         inline void WriteVec(Value& obj, float(&prop)[N], const char* propName, const float(&defaultVal)[N], MemoryPoolAllocator<>& al)
         {
             if (!std::equal(std::begin(prop), std::end(prop), std::begin(defaultVal))) {
                 WriteVec(obj, prop, propName, al);
             }
         }
 
         inline void WriteFloat(Value& obj, float prop, const char* propName, MemoryPoolAllocator<>& al)
         {
             Value num;
             obj.AddMember(StringRef(propName), MakeValue(num, prop, al), al);
         }
     }
 
     inline void Write(Value& obj, Material& m, AssetWriter& w)
     {
         Value pbrMetallicRoughness;
         pbrMetallicRoughness.SetObject();
         {
             WriteTex(pbrMetallicRoughness, m.pbrMetallicRoughness.baseColorTexture, "baseColorTexture", w.mAl);
             WriteTex(pbrMetallicRoughness, m.pbrMetallicRoughness.metallicRoughnessTexture, "metallicRoughnessTexture", w.mAl);
             WriteVec(pbrMetallicRoughness, m.pbrMetallicRoughness.baseColorFactor, "baseColorFactor", defaultBaseColor, w.mAl);
 
             if (m.pbrMetallicRoughness.metallicFactor != 1) {
                 WriteFloat(pbrMetallicRoughness, m.pbrMetallicRoughness.metallicFactor, "metallicFactor", w.mAl);
             }
 
             if (m.pbrMetallicRoughness.roughnessFactor != 1) {
                 WriteFloat(pbrMetallicRoughness, m.pbrMetallicRoughness.roughnessFactor, "roughnessFactor", w.mAl);
             }
         }
 
         if (!pbrMetallicRoughness.ObjectEmpty()) {
             obj.AddMember("pbrMetallicRoughness", pbrMetallicRoughness, w.mAl);
         }
 
         WriteTex(obj, m.normalTexture, "normalTexture", w.mAl);
         WriteTex(obj, m.emissiveTexture, "emissiveTexture", w.mAl);
         WriteTex(obj, m.occlusionTexture, "occlusionTexture", w.mAl);
         WriteVec(obj, m.emissiveFactor, "emissiveFactor", defaultEmissiveFactor, w.mAl);
 
         if (m.alphaCutoff != 0.5) {
             WriteFloat(obj, m.alphaCutoff, "alphaCutoff", w.mAl);
         }
 
         if (m.alphaMode != "OPAQUE") {
             obj.AddMember("alphaMode", Value(m.alphaMode, w.mAl).Move(), w.mAl);
         }
 
         if (m.doubleSided) {
             obj.AddMember("doubleSided", m.doubleSided, w.mAl);
         }
 
         Value exts;
         exts.SetObject();
 
         if (m.pbrSpecularGlossiness.isPresent) {
             Value pbrSpecularGlossiness;
             pbrSpecularGlossiness.SetObject();
 
             PbrSpecularGlossiness &pbrSG = m.pbrSpecularGlossiness.value;
 
             //pbrSpecularGlossiness
             WriteVec(pbrSpecularGlossiness, pbrSG.diffuseFactor, "diffuseFactor", defaultDiffuseFactor, w.mAl);
             WriteVec(pbrSpecularGlossiness, pbrSG.specularFactor, "specularFactor", defaultSpecularFactor, w.mAl);
 
             if (pbrSG.glossinessFactor != 1) {
                 WriteFloat(pbrSpecularGlossiness, pbrSG.glossinessFactor, "glossinessFactor", w.mAl);
             }
 
             WriteTex(pbrSpecularGlossiness, pbrSG.diffuseTexture, "diffuseTexture", w.mAl);
             WriteTex(pbrSpecularGlossiness, pbrSG.specularGlossinessTexture, "specularGlossinessTexture", w.mAl);
 
             if (!pbrSpecularGlossiness.ObjectEmpty()) {
                 exts.AddMember("KHR_materials_pbrSpecularGlossiness", pbrSpecularGlossiness, w.mAl);
             }
         }
 
         if (m.unlit) {
           Value unlit;
           unlit.SetObject();
           exts.AddMember("KHR_materials_unlit", unlit, w.mAl);
         }
 
         if (m.materialSheen.isPresent) {
             Value materialSheen(rapidjson::Type::kObjectType);
 
             MaterialSheen &sheen = m.materialSheen.value;
 
             WriteVec(materialSheen, sheen.sheenColorFactor, "sheenColorFactor", defaultSheenFactor, w.mAl);
 
             if (sheen.sheenRoughnessFactor != 0.f) {
                 WriteFloat(materialSheen, sheen.sheenRoughnessFactor, "sheenRoughnessFactor", w.mAl);
             }
 
             WriteTex(materialSheen, sheen.sheenColorTexture, "sheenColorTexture", w.mAl);
             WriteTex(materialSheen, sheen.sheenRoughnessTexture, "sheenRoughnessTexture", w.mAl);
 
             if (!materialSheen.ObjectEmpty()) {
                 exts.AddMember("KHR_materials_sheen", materialSheen, w.mAl);
             }
         }
 
         if (m.materialClearcoat.isPresent) {
             Value materialClearcoat(rapidjson::Type::kObjectType);
 
             MaterialClearcoat &clearcoat = m.materialClearcoat.value;
 
             if (clearcoat.clearcoatFactor != 0.f) {
                 WriteFloat(materialClearcoat, clearcoat.clearcoatFactor, "clearcoatFactor", w.mAl);
             }
 
             if (clearcoat.clearcoatRoughnessFactor != 0.f) {
                 WriteFloat(materialClearcoat, clearcoat.clearcoatRoughnessFactor, "clearcoatRoughnessFactor", w.mAl);
             }
 
             WriteTex(materialClearcoat, clearcoat.clearcoatTexture, "clearcoatTexture", w.mAl);
             WriteTex(materialClearcoat, clearcoat.clearcoatRoughnessTexture, "clearcoatRoughnessTexture", w.mAl);
             WriteTex(materialClearcoat, clearcoat.clearcoatNormalTexture, "clearcoatNormalTexture", w.mAl);
-                        
+
             if (!materialClearcoat.ObjectEmpty()) {
                 exts.AddMember("KHR_materials_clearcoat", materialClearcoat, w.mAl);
             }
         }
 
         if (m.materialTransmission.isPresent) {
             Value materialTransmission(rapidjson::Type::kObjectType);
 
             MaterialTransmission &transmission = m.materialTransmission.value;
 
             if (transmission.transmissionFactor != 0.f) {
                 WriteFloat(materialTransmission, transmission.transmissionFactor, "transmissionFactor", w.mAl);
             }
 
             WriteTex(materialTransmission, transmission.transmissionTexture, "transmissionTexture", w.mAl);
-                                   
+
             if (!materialTransmission.ObjectEmpty()) {
                 exts.AddMember("KHR_materials_transmission", materialTransmission, w.mAl);
             }
         }
 
         if (!exts.ObjectEmpty()) {
             obj.AddMember("extensions", exts, w.mAl);
         }
     }
 
     namespace {
         inline void WriteAttrs(AssetWriter& w, Value& attrs, Mesh::AccessorList& lst,
             const char* semantic, bool forceNumber = false)
         {
             if (lst.empty()) return;
             if (lst.size() == 1 && !forceNumber) {
                 attrs.AddMember(StringRef(semantic), lst[0]->index, w.mAl);
             }
             else {
                 for (size_t i = 0; i < lst.size(); ++i) {
                     char buffer[32];
                     ai_snprintf(buffer, 32, "%s_%d", semantic, int(i));
                     attrs.AddMember(Value(buffer, w.mAl).Move(), lst[i]->index, w.mAl);
                 }
             }
         }
     }
 
     inline void Write(Value& obj, Mesh& m, AssetWriter& w)
     {
 		/****************** Primitives *******************/
         Value primitives;
         primitives.SetArray();
         primitives.Reserve(unsigned(m.primitives.size()), w.mAl);
 
         for (size_t i = 0; i < m.primitives.size(); ++i) {
             Mesh::Primitive& p = m.primitives[i];
             Value prim;
             prim.SetObject();
 
             // Extensions
             if (p.ngonEncoded)
             {
                 Value exts;
                 exts.SetObject();
 
                 Value FB_ngon_encoding;
                 FB_ngon_encoding.SetObject();
 
                 exts.AddMember(StringRef("FB_ngon_encoding"), FB_ngon_encoding, w.mAl);
                 prim.AddMember("extensions", exts, w.mAl);
             }
 
             {
                 prim.AddMember("mode", Value(int(p.mode)).Move(), w.mAl);
 
                 if (p.material)
                     prim.AddMember("material", p.material->index, w.mAl);
 
                 if (p.indices)
                     prim.AddMember("indices", p.indices->index, w.mAl);
 
                 Value attrs;
                 attrs.SetObject();
                 {
                     WriteAttrs(w, attrs, p.attributes.position, "POSITION");
                     WriteAttrs(w, attrs, p.attributes.normal, "NORMAL");
                     WriteAttrs(w, attrs, p.attributes.texcoord, "TEXCOORD", true);
                     WriteAttrs(w, attrs, p.attributes.color, "COLOR", true);
                     WriteAttrs(w, attrs, p.attributes.joint, "JOINTS", true);
                     WriteAttrs(w, attrs, p.attributes.weight, "WEIGHTS", true);
                 }
                 prim.AddMember("attributes", attrs, w.mAl);
 
                 // targets for blendshapes
                 if (p.targets.size() > 0) {
                     Value tjs;
                     tjs.SetArray();
                     tjs.Reserve(unsigned(p.targets.size()), w.mAl);
                     for (unsigned int t = 0; t < p.targets.size(); ++t) {
                         Value tj;
                         tj.SetObject();
                         {
                             WriteAttrs(w, tj, p.targets[t].position, "POSITION");
                             WriteAttrs(w, tj, p.targets[t].normal, "NORMAL");
                             WriteAttrs(w, tj, p.targets[t].tangent, "TANGENT");
                         }
                         tjs.PushBack(tj, w.mAl);
                     }
                     prim.AddMember("targets", tjs, w.mAl);
                 }
             }
             primitives.PushBack(prim, w.mAl);
         }
 
         obj.AddMember("primitives", primitives, w.mAl);
         // targetNames
         if (m.targetNames.size() > 0) {
             Value extras;
             extras.SetObject();
             Value targetNames;
             targetNames.SetArray();
             targetNames.Reserve(unsigned(m.targetNames.size()), w.mAl);
             for (unsigned int n = 0; n < m.targetNames.size(); ++n) {
                 std::string name = m.targetNames[n];
                 Value tname;
                 tname.SetString(name.c_str(), w.mAl);
                 targetNames.PushBack(tname, w.mAl);
             }
             extras.AddMember("targetNames", targetNames, w.mAl);
             obj.AddMember("extras", extras, w.mAl);
         }
     }
 
     inline void Write(Value& obj, Node& n, AssetWriter& w)
     {
         if (n.matrix.isPresent) {
             Value val;
             obj.AddMember("matrix", MakeValue(val, n.matrix.value, w.mAl).Move(), w.mAl);
         }
 
         if (n.translation.isPresent) {
             Value val;
             obj.AddMember("translation", MakeValue(val, n.translation.value, w.mAl).Move(), w.mAl);
         }
 
         if (n.scale.isPresent) {
             Value val;
             obj.AddMember("scale", MakeValue(val, n.scale.value, w.mAl).Move(), w.mAl);
         }
         if (n.rotation.isPresent) {
             Value val;
             obj.AddMember("rotation", MakeValue(val, n.rotation.value, w.mAl).Move(), w.mAl);
         }
 
         AddRefsVector(obj, "children", n.children, w.mAl);
 
         if (!n.meshes.empty()) {
             obj.AddMember("mesh", n.meshes[0]->index, w.mAl);
         }
 
         if (n.skin) {
             obj.AddMember("skin", n.skin->index, w.mAl);
         }
-        
+
         //gltf2 spec does not support "skeletons" under node
         if(n.skeletons.size()) {
             AddRefsVector(obj, "skeletons", n.skeletons, w.mAl);
         }
     }
 
     inline void Write(Value& /*obj*/, Program& /*b*/, AssetWriter& /*w*/)
     {
 
     }
 
     inline void Write(Value& obj, Sampler& b, AssetWriter& w)
     {
         if (!b.name.empty()) {
             obj.AddMember("name", b.name, w.mAl);
         }
 
         if (b.wrapS != SamplerWrap::UNSET && b.wrapS != SamplerWrap::Repeat) {
             obj.AddMember("wrapS", static_cast<unsigned int>(b.wrapS), w.mAl);
         }
 
         if (b.wrapT != SamplerWrap::UNSET && b.wrapT != SamplerWrap::Repeat) {
             obj.AddMember("wrapT", static_cast<unsigned int>(b.wrapT), w.mAl);
         }
 
         if (b.magFilter != SamplerMagFilter::UNSET) {
             obj.AddMember("magFilter", static_cast<unsigned int>(b.magFilter), w.mAl);
         }
 
         if (b.minFilter != SamplerMinFilter::UNSET) {
             obj.AddMember("minFilter", static_cast<unsigned int>(b.minFilter), w.mAl);
         }
     }
 
     inline void Write(Value& scene, Scene& s, AssetWriter& w)
     {
         AddRefsVector(scene, "nodes", s.nodes, w.mAl);
     }
 
     inline void Write(Value& /*obj*/, Shader& /*b*/, AssetWriter& /*w*/)
     {
 
     }
 
     inline void Write(Value& obj, Skin& b, AssetWriter& w)
     {
         /****************** jointNames *******************/
         Value vJointNames;
         vJointNames.SetArray();
         vJointNames.Reserve(unsigned(b.jointNames.size()), w.mAl);
 
         for (size_t i = 0; i < unsigned(b.jointNames.size()); ++i) {
             vJointNames.PushBack(b.jointNames[i]->index, w.mAl);
         }
         obj.AddMember("joints", vJointNames, w.mAl);
 
         if (b.bindShapeMatrix.isPresent) {
             Value val;
             obj.AddMember("bindShapeMatrix", MakeValue(val, b.bindShapeMatrix.value, w.mAl).Move(), w.mAl);
         }
 
         if (b.inverseBindMatrices) {
             obj.AddMember("inverseBindMatrices", b.inverseBindMatrices->index, w.mAl);
         }
 
     }
 
     inline void Write(Value& obj, Texture& tex, AssetWriter& w)
     {
         if (tex.source) {
             obj.AddMember("source", tex.source->index, w.mAl);
         }
         if (tex.sampler) {
             obj.AddMember("sampler", tex.sampler->index, w.mAl);
         }
     }
 
 
     inline AssetWriter::AssetWriter(Asset& a)
         : mDoc()
         , mAsset(a)
         , mAl(mDoc.GetAllocator())
     {
         mDoc.SetObject();
 
         WriteMetadata();
         WriteExtensionsUsed();
 
         // Dump the contents of the dictionaries
         for (size_t i = 0; i < a.mDicts.size(); ++i) {
             a.mDicts[i]->WriteObjects(*this);
         }
 
         // Add the target scene field
         if (mAsset.scene) {
             mDoc.AddMember("scene", mAsset.scene->index, mAl);
         }
-        
+
         if(mAsset.extras) {
             mDoc.AddMember("extras", *mAsset.extras, mAl);
         }
     }
 
     inline void AssetWriter::WriteFile(const char* path)
     {
         std::unique_ptr<IOStream> jsonOutFile(mAsset.OpenFile(path, "wt", true));
 
         if (jsonOutFile == 0) {
             throw DeadlyExportError("Could not open output file: " + std::string(path));
         }
 
         StringBuffer docBuffer;
 
         PrettyWriter<StringBuffer> writer(docBuffer);
         if (!mDoc.Accept(writer)) {
             throw DeadlyExportError("Failed to write scene data!");
         }
 
         if (jsonOutFile->Write(docBuffer.GetString(), docBuffer.GetSize(), 1) != 1) {
             throw DeadlyExportError("Failed to write scene data!");
         }
 
         // Write buffer data to separate .bin files
         for (unsigned int i = 0; i < mAsset.buffers.Size(); ++i) {
             Ref<Buffer> b = mAsset.buffers.Get(i);
 
             std::string binPath = b->GetURI();
 
             std::unique_ptr<IOStream> binOutFile(mAsset.OpenFile(binPath, "wb", true));
 
             if (binOutFile == 0) {
                 throw DeadlyExportError("Could not open output file: " + binPath);
             }
 
             if (b->byteLength > 0) {
                 if (binOutFile->Write(b->GetPointer(), b->byteLength, 1) != 1) {
                     throw DeadlyExportError("Failed to write binary file: " + binPath);
                 }
             }
         }
     }
 
     inline void AssetWriter::WriteGLBFile(const char* path)
     {
         std::unique_ptr<IOStream> outfile(mAsset.OpenFile(path, "wb", true));
 
         if (outfile == 0) {
             throw DeadlyExportError("Could not open output file: " + std::string(path));
         }
 
         Ref<Buffer> bodyBuffer = mAsset.GetBodyBuffer();
         if (bodyBuffer->byteLength > 0) {
             rapidjson::Value glbBodyBuffer;
             glbBodyBuffer.SetObject();
             glbBodyBuffer.AddMember("byteLength", static_cast<uint64_t>(bodyBuffer->byteLength), mAl);
             mDoc["buffers"].PushBack(glbBodyBuffer, mAl);
         }
 
         // Padding with spaces as required by the spec
         uint32_t padding = 0x20202020;
 
         //
         // JSON chunk
         //
 
         StringBuffer docBuffer;
         Writer<StringBuffer> writer(docBuffer);
         if (!mDoc.Accept(writer)) {
             throw DeadlyExportError("Failed to write scene data!");
         }
 
         uint32_t jsonChunkLength = (docBuffer.GetSize() + 3) & ~3; // Round up to next multiple of 4
         auto paddingLength = jsonChunkLength - docBuffer.GetSize();
 
         GLB_Chunk jsonChunk;
         jsonChunk.chunkLength = jsonChunkLength;
         jsonChunk.chunkType = ChunkType_JSON;
         AI_SWAP4(jsonChunk.chunkLength);
 
         outfile->Seek(sizeof(GLB_Header), aiOrigin_SET);
         if (outfile->Write(&jsonChunk, 1, sizeof(GLB_Chunk)) != sizeof(GLB_Chunk)) {
             throw DeadlyExportError("Failed to write scene data header!");
         }
         if (outfile->Write(docBuffer.GetString(), 1, docBuffer.GetSize()) != docBuffer.GetSize()) {
             throw DeadlyExportError("Failed to write scene data!");
         }
         if (paddingLength && outfile->Write(&padding, 1, paddingLength) != paddingLength) {
             throw DeadlyExportError("Failed to write scene data padding!");
         }
 
         //
         // Binary chunk
         //
 
         int GLB_Chunk_count = 1;
         uint32_t binaryChunkLength = 0;
         if (bodyBuffer->byteLength > 0) {
             binaryChunkLength = (bodyBuffer->byteLength + 3) & ~3; // Round up to next multiple of 4
-            
+
             auto curPaddingLength = binaryChunkLength - bodyBuffer->byteLength;
             ++GLB_Chunk_count;
 
             GLB_Chunk binaryChunk;
             binaryChunk.chunkLength = binaryChunkLength;
             binaryChunk.chunkType = ChunkType_BIN;
             AI_SWAP4(binaryChunk.chunkLength);
 
             size_t bodyOffset = sizeof(GLB_Header) + sizeof(GLB_Chunk) + jsonChunk.chunkLength;
             outfile->Seek(bodyOffset, aiOrigin_SET);
             if (outfile->Write(&binaryChunk, 1, sizeof(GLB_Chunk)) != sizeof(GLB_Chunk)) {
                 throw DeadlyExportError("Failed to write body data header!");
             }
             if (outfile->Write(bodyBuffer->GetPointer(), 1, bodyBuffer->byteLength) != bodyBuffer->byteLength) {
                 throw DeadlyExportError("Failed to write body data!");
             }
             if (curPaddingLength && outfile->Write(&padding, 1, paddingLength) != paddingLength) {
                 throw DeadlyExportError("Failed to write body data padding!");
             }
         }
 
         //
         // Header
         //
 
         GLB_Header header;
         memcpy(header.magic, AI_GLB_MAGIC_NUMBER, sizeof(header.magic));
 
         header.version = 2;
         AI_SWAP4(header.version);
 
         header.length = uint32_t(sizeof(GLB_Header) + GLB_Chunk_count * sizeof(GLB_Chunk) + jsonChunkLength + binaryChunkLength);
         AI_SWAP4(header.length);
 
         outfile->Seek(0, aiOrigin_SET);
         if (outfile->Write(&header, 1, sizeof(GLB_Header)) != sizeof(GLB_Header)) {
             throw DeadlyExportError("Failed to write the header!");
         }
     }
 
     inline void AssetWriter::WriteMetadata()
     {
         Value asset;
         asset.SetObject();
         asset.AddMember("version", Value(mAsset.asset.version, mAl).Move(), mAl);
         asset.AddMember("generator", Value(mAsset.asset.generator, mAl).Move(), mAl);
         if (!mAsset.asset.copyright.empty())
             asset.AddMember("copyright", Value(mAsset.asset.copyright, mAl).Move(), mAl);
         mDoc.AddMember("asset", asset, mAl);
     }
 
     inline void AssetWriter::WriteExtensionsUsed()
     {
         Value exts;
         exts.SetArray();
         {
             // This is used to export pbrSpecularGlossiness materials with GLTF 2.
             if (this->mAsset.extensionsUsed.KHR_materials_pbrSpecularGlossiness) {
                 exts.PushBack(StringRef("KHR_materials_pbrSpecularGlossiness"), mAl);
             }
 
             if (this->mAsset.extensionsUsed.KHR_materials_unlit) {
               exts.PushBack(StringRef("KHR_materials_unlit"), mAl);
             }
 
             if (this->mAsset.extensionsUsed.KHR_materials_sheen) {
                 exts.PushBack(StringRef("KHR_materials_sheen"), mAl);
             }
-                        
+
             if (this->mAsset.extensionsUsed.KHR_materials_clearcoat) {
                 exts.PushBack(StringRef("KHR_materials_clearcoat"), mAl);
             }
 
             if (this->mAsset.extensionsUsed.KHR_materials_transmission) {
                 exts.PushBack(StringRef("KHR_materials_transmission"), mAl);
             }
 
             if (this->mAsset.extensionsUsed.FB_ngon_encoding) {
                 exts.PushBack(StringRef("FB_ngon_encoding"), mAl);
             }
-            
+
             if (this->mAsset.extensionsUsed.KHR_texture_basisu) {
                 exts.PushBack(StringRef("KHR_texture_basisu"), mAl);
             }
         }
 
         if (!exts.Empty())
             mDoc.AddMember("extensionsUsed", exts, mAl);
-            
+
         //basisu extensionRequired
         Value extsReq;
         extsReq.SetArray();
         if (this->mAsset.extensionsUsed.KHR_texture_basisu) {
             extsReq.PushBack(StringRef("KHR_texture_basisu"), mAl);
             mDoc.AddMember("extensionsRequired", extsReq, mAl);
         }
     }
 
     template<class T>
     void AssetWriter::WriteObjects(LazyDict<T>& d)
     {
         if (d.mObjs.empty()) return;
 
         Value* container = &mDoc;
 		const char* context = "Document";
 
         if (d.mExtId) {
             Value* exts = FindObject(mDoc, "extensions");
             if (nullptr != exts) {
                 mDoc.AddMember("extensions", Value().SetObject().Move(), mDoc.GetAllocator());
                 exts = FindObject(mDoc, "extensions");
             }
 
             container = FindObjectInContext(*exts, d.mExtId, "extensions");
             if (nullptr != container) {
                 exts->AddMember(StringRef(d.mExtId), Value().SetObject().Move(), mDoc.GetAllocator());
                 container = FindObjectInContext(*exts, d.mExtId, "extensions");
                 context = d.mExtId;
             }
         }
 
         Value *dict = FindArrayInContext(*container, d.mDictId, context);
         if (nullptr == dict) {
             container->AddMember(StringRef(d.mDictId), Value().SetArray().Move(), mDoc.GetAllocator());
             dict = FindArrayInContext(*container, d.mDictId, context);
             if (nullptr == dict) {
                 return;
             }
         }
 
         for (size_t i = 0; i < d.mObjs.size(); ++i) {
             if (d.mObjs[i]->IsSpecial()) {
                 continue;
             }
 
             Value obj;
             obj.SetObject();
 
             if (!d.mObjs[i]->name.empty()) {
                 obj.AddMember("name", StringRef(d.mObjs[i]->name.c_str()), mAl);
             }
 
             Write(obj, *d.mObjs[i], *this);
 
             dict->PushBack(obj, mAl);
         }
     }
 
     template<class T>
     void WriteLazyDict(LazyDict<T>& d, AssetWriter& w)
     {
         w.WriteObjects(d);
     }
 
 }
diff --git a/code/Common/DefaultIOStream.cpp b/code/Common/DefaultIOStream.cpp
index ba9b9d625..557fbc78f 100644
--- a/code/Common/DefaultIOStream.cpp
+++ b/code/Common/DefaultIOStream.cpp
@@ -60,9 +60,9 @@ template <size_t sizeOfPointer>
 inline int select_fseek(FILE *file, int64_t offset, int origin) {
     return ::fseek(file, static_cast<long>(offset), origin);
 }
 
 
-    
+
 #if defined _WIN32 && (!defined __GNUC__ || __MSVCRT_VERSION__ >= 0x0601)
 template <>
 inline size_t select_ftell<8>(FILE *file) {
@@ -73,9 +73,9 @@ template <>
 inline int select_fseek<8>(FILE *file, int64_t offset, int origin) {
     return ::_fseeki64(file, offset, origin);
 }
 
 #endif // #if defined _WIN32 && (!defined __GNUC__ || __MSVCRT_VERSION__ >= 0x0601)
-    
+
 } // namespace
 
 // ----------------------------------------------------------------------------------
@@ -89,14 +89,14 @@ DefaultIOStream::~DefaultIOStream() {
 // ----------------------------------------------------------------------------------
 size_t DefaultIOStream::Read(void *pvBuffer,
         size_t pSize,
         size_t pCount) {
     if (0 == pCount) {
         return 0;
     }
     ai_assert(nullptr != pvBuffer);
     ai_assert(0 != pSize);
-    
+
     return (mFile ? ::fread(pvBuffer, pSize, pCount, mFile) : 0);
 }
 
 // ----------------------------------------------------------------------------------
diff --git a/code/Common/DefaultIOSystem.cpp b/code/Common/DefaultIOSystem.cpp
index 98d51a17d..1ed615b84 100644
--- a/code/Common/DefaultIOSystem.cpp
+++ b/code/Common/DefaultIOSystem.cpp
@@ -66,12 +66,12 @@ const std::wstring wdummy;
 static std::wstring Utf8ToWide(const char *in) {
     if (nullptr == in) {
         return wdummy;
     }
     int size = MultiByteToWideChar(CP_UTF8, 0, in, -1, nullptr, 0);
     // size includes terminating null; std::wstring adds null automatically
     std::wstring out(static_cast<size_t>(size) - 1, L'\0');
     MultiByteToWideChar(CP_UTF8, 0, in, -1, &out[0], size);
-    
+
     return out;
 }
 
@@ -80,15 +80,15 @@ const std::string dummy;
 static std::string WideToUtf8(const wchar_t *in) {
     if (nullptr == in) {
         return dummy;
     }
     int size = WideCharToMultiByte(CP_UTF8, 0, in, -1, nullptr, 0, nullptr, nullptr);
     // size includes terminating null; std::string adds null automatically
     std::string out(static_cast<size_t>(size) - 1, '\0');
     WideCharToMultiByte(CP_UTF8, 0, in, -1, &out[0], size, nullptr, nullptr);
-    
+
     return out;
 }
 #endif
 
 // ------------------------------------------------------------------------------------------------
 // Tests for the existence of a file at the given path.
@@ -113,25 +113,25 @@ bool DefaultIOSystem::Exists(const char *pFile) const {
 // ------------------------------------------------------------------------------------------------
 // Open a new file with a given path.
 IOStream *DefaultIOSystem::Open(const char *strFile, const char *strMode) {
     ai_assert(strFile != nullptr);
     ai_assert(strMode != nullptr);
     FILE *file;
 #ifdef _WIN32
     std::wstring name = Utf8ToWide(strFile);
     if (name.empty()) {
         return nullptr;
     }
-    
+
     file = ::_wfopen(name.c_str(), Utf8ToWide(strMode).c_str());
 #else
     file = ::fopen(strFile, strMode);
 #endif
     if (!file) {
         return nullptr;
     }
 
     return new DefaultIOStream(file, strFile);
 }
 
 // ------------------------------------------------------------------------------------------------
 // Closes the given file and releases all resources associated with it.
diff --git a/code/Common/Exporter.cpp b/code/Common/Exporter.cpp
index ebcc955df..512bbf447 100644
--- a/code/Common/Exporter.cpp
+++ b/code/Common/Exporter.cpp
@@ -82,8 +82,8 @@ namespace Assimp {
 // PostStepRegistry.cpp
 void GetPostProcessingStepInstanceList(std::vector< BaseProcess* >& out);
 
 // ------------------------------------------------------------------------------------------------
-// Exporter worker function prototypes. Do not use const, because some exporter need to convert 
+// Exporter worker function prototypes. Do not use const, because some exporter need to convert
 // the scene temporary
 #ifndef ASSIMP_BUILD_NO_COLLADA_EXPORTER
 void ExportSceneCollada(const char*,IOSystem*, const aiScene*, const ExportProperties*);
@@ -338,27 +338,27 @@ void Exporter::SetProgressHandler(ProgressHandler* pHandler) {
 // ------------------------------------------------------------------------------------------------
 const aiExportDataBlob* Exporter::ExportToBlob( const aiScene* pScene, const char* pFormatId,
                                                 unsigned int pPreprocessing, const ExportProperties* pProperties) {
 	ai_assert(nullptr != pimpl);
     if (pimpl->blob) {
         delete pimpl->blob;
         pimpl->blob = nullptr;
     }
-    
+
     auto baseName = pProperties ? pProperties->GetPropertyString(AI_CONFIG_EXPORT_BLOB_NAME, AI_BLOBIO_MAGIC) : AI_BLOBIO_MAGIC;
 
     std::shared_ptr<IOSystem> old = pimpl->mIOSystem;
     BlobIOSystem *blobio = new BlobIOSystem(baseName);
     pimpl->mIOSystem = std::shared_ptr<IOSystem>( blobio );
 
     if (AI_SUCCESS != Export(pScene,pFormatId,blobio->GetMagicFileName(), pPreprocessing, pProperties)) {
         pimpl->mIOSystem = old;
         return nullptr;
     }
 
     pimpl->blob = blobio->GetBlobChain();
     pimpl->mIOSystem = old;
 
     return pimpl->blob;
 }
 
 // ------------------------------------------------------------------------------------------------
diff --git a/code/Common/FileSystemFilter.h b/code/Common/FileSystemFilter.h
index 6585f9df6..6782dd9e5 100644
--- a/code/Common/FileSystemFilter.h
+++ b/code/Common/FileSystemFilter.h
@@ -64,155 +64,155 @@ class FileSystemFilter : public IOSystem
 {
 public:
     /** Constructor. */
     FileSystemFilter(const std::string& file, IOSystem* old)
     : mWrapped  (old)
     , mSrc_file(file)
     , mSep(mWrapped->getOsSeparator()) {
         ai_assert(nullptr != mWrapped);
 
         // Determine base directory
         mBase = mSrc_file;
         std::string::size_type ss2;
         if (std::string::npos != (ss2 = mBase.find_last_of("\\/")))  {
             mBase.erase(ss2,mBase.length()-ss2);
         } else {
             mBase = std::string();
         }
 
         // make sure the directory is terminated properly
         char s;
 
         if ( mBase.empty() ) {
             mBase = ".";
             mBase += getOsSeparator();
         } else if ((s = *(mBase.end()-1)) != '\\' && s != '/') {
             mBase += getOsSeparator();
         }
 
         DefaultLogger::get()->info("Import root directory is \'", mBase, "\'");
     }
 
     /** Destructor. */
     ~FileSystemFilter() {
         // empty
     }
 
     // -------------------------------------------------------------------
     /** Tests for the existence of a file at the given path. */
     bool Exists( const char* pFile) const {
         ai_assert( nullptr != mWrapped );
-        
+
         std::string tmp = pFile;
 
         // Currently this IOSystem is also used to open THE ONE FILE.
         if (tmp != mSrc_file)    {
             BuildPath(tmp);
             Cleanup(tmp);
         }
 
         return mWrapped->Exists(tmp);
     }
 
     // -------------------------------------------------------------------
     /** Returns the directory separator. */
     char getOsSeparator() const {
         return mSep;
     }
 
     // -------------------------------------------------------------------
     /** Open a new file with a given path. */
     IOStream* Open( const char* pFile, const char* pMode = "rb") {
         ai_assert( nullptr != mWrapped );
         if ( nullptr == pFile || nullptr == pMode ) {
             return nullptr;
         }
-        
+
         ai_assert( nullptr != pFile );
         ai_assert( nullptr != pMode );
 
         // First try the unchanged path
         IOStream* s = mWrapped->Open(pFile,pMode);
 
         if (nullptr == s) {
             std::string tmp = pFile;
 
             // Try to convert between absolute and relative paths
             BuildPath(tmp);
             s = mWrapped->Open(tmp,pMode);
 
             if (nullptr == s) {
                 // Finally, look for typical issues with paths
                 // and try to correct them. This is our last
                 // resort.
                 tmp = pFile;
                 Cleanup(tmp);
                 BuildPath(tmp);
                 s = mWrapped->Open(tmp,pMode);
             }
         }
 
         return s;
     }
 
     // -------------------------------------------------------------------
     /** Closes the given file and releases all resources associated with it. */
     void Close( IOStream* pFile) {
         ai_assert( nullptr != mWrapped );
         return mWrapped->Close(pFile);
     }
 
     // -------------------------------------------------------------------
     /** Compare two paths */
     bool ComparePaths (const char* one, const char* second) const {
         ai_assert( nullptr != mWrapped );
         return mWrapped->ComparePaths (one,second);
     }
 
     // -------------------------------------------------------------------
     /** Pushes a new directory onto the directory stack. */
     bool PushDirectory(const std::string &path ) {
         ai_assert( nullptr != mWrapped );
         return mWrapped->PushDirectory(path);
     }
 
     // -------------------------------------------------------------------
     /** Returns the top directory from the stack. */
     const std::string &CurrentDirectory() const {
         ai_assert( nullptr != mWrapped );
         return mWrapped->CurrentDirectory();
     }
 
     // -------------------------------------------------------------------
     /** Returns the number of directories stored on the stack. */
     size_t StackSize() const {
         ai_assert( nullptr != mWrapped );
         return mWrapped->StackSize();
     }
 
     // -------------------------------------------------------------------
     /** Pops the top directory from the stack. */
     bool PopDirectory() {
         ai_assert( nullptr != mWrapped );
         return mWrapped->PopDirectory();
     }
 
     // -------------------------------------------------------------------
     /** Creates an new directory at the given path. */
     bool CreateDirectory(const std::string &path) {
         ai_assert( nullptr != mWrapped );
         return mWrapped->CreateDirectory(path);
     }
 
     // -------------------------------------------------------------------
     /** Will change the current directory to the given path. */
     bool ChangeDirectory(const std::string &path) {
         ai_assert( nullptr != mWrapped );
         return mWrapped->ChangeDirectory(path);
     }
 
     // -------------------------------------------------------------------
     /** Delete file. */
     bool DeleteFile(const std::string &file) {
         ai_assert( nullptr != mWrapped );
         return mWrapped->DeleteFile(file);
     }
diff --git a/code/Common/Importer.cpp b/code/Common/Importer.cpp
index a2ad041fb..d0ed3c788 100644
--- a/code/Common/Importer.cpp
+++ b/code/Common/Importer.cpp
@@ -200,51 +200,51 @@ Importer::~Importer() {
 // ------------------------------------------------------------------------------------------------
 // Register a custom post-processing step
 aiReturn Importer::RegisterPPStep(BaseProcess* pImp) {
     ai_assert( nullptr != pImp );
-    
+
     ASSIMP_BEGIN_EXCEPTION_REGION();
 
         pimpl->mPostProcessingSteps.push_back(pImp);
         ASSIMP_LOG_INFO("Registering custom post-processing step");
 
     ASSIMP_END_EXCEPTION_REGION(aiReturn);
     return AI_SUCCESS;
 }
 
 // ------------------------------------------------------------------------------------------------
 // Register a custom loader plugin
 aiReturn Importer::RegisterLoader(BaseImporter* pImp) {
     ai_assert(nullptr != pImp);
-    
+
     ASSIMP_BEGIN_EXCEPTION_REGION();
 
     // --------------------------------------------------------------------
     // Check whether we would have two loaders for the same file extension
     // This is absolutely OK, but we should warn the developer of the new
     // loader that his code will probably never be called if the first
     // loader is a bit too lazy in his file checking.
     // --------------------------------------------------------------------
     std::set<std::string> st;
     std::string baked;
     pImp->GetExtensionList(st);
 
     for(std::set<std::string>::const_iterator it = st.begin(); it != st.end(); ++it) {
 
 #ifdef ASSIMP_BUILD_DEBUG
         if (IsExtensionSupported(*it)) {
             ASSIMP_LOG_WARN("The file extension ", *it, " is already in use");
         }
 #endif
         baked += *it;
     }
 
     // add the loader
     pimpl->mImporter.push_back(pImp);
     ASSIMP_LOG_INFO("Registering custom importer for these file extensions: ", baked);
     ASSIMP_END_EXCEPTION_REGION(aiReturn);
-    
+
     return AI_SUCCESS;
 }
 
 // ------------------------------------------------------------------------------------------------
 // Unregister a custom loader plugin
@@ -295,73 +295,73 @@ aiReturn Importer::UnregisterPPStep(BaseProcess* pImp) {
 // ------------------------------------------------------------------------------------------------
 // Supplies a custom IO handler to the importer to open and access files.
 void Importer::SetIOHandler( IOSystem* pIOHandler) {
     ai_assert(nullptr != pimpl);
-    
+
     ASSIMP_BEGIN_EXCEPTION_REGION();
     // If the new handler is zero, allocate a default IO implementation.
     if (!pIOHandler) {
         // Release pointer in the possession of the caller
         pimpl->mIOHandler = new DefaultIOSystem();
         pimpl->mIsDefaultHandler = true;
     } else if (pimpl->mIOHandler != pIOHandler) { // Otherwise register the custom handler
         delete pimpl->mIOHandler;
         pimpl->mIOHandler = pIOHandler;
         pimpl->mIsDefaultHandler = false;
     }
     ASSIMP_END_EXCEPTION_REGION(void);
 }
 
 // ------------------------------------------------------------------------------------------------
 // Get the currently set IO handler
 IOSystem* Importer::GetIOHandler() const {
     ai_assert(nullptr != pimpl);
-    
+
     return pimpl->mIOHandler;
 }
 
 // ------------------------------------------------------------------------------------------------
 // Check whether a custom IO handler is currently set
 bool Importer::IsDefaultIOHandler() const {
     ai_assert(nullptr != pimpl);
-    
+
     return pimpl->mIsDefaultHandler;
 }
 
 // ------------------------------------------------------------------------------------------------
 // Supplies a custom progress handler to get regular callbacks during importing
 void Importer::SetProgressHandler ( ProgressHandler* pHandler ) {
     ai_assert(nullptr != pimpl);
-    
+
     ASSIMP_BEGIN_EXCEPTION_REGION();
-    
+
     // If the new handler is zero, allocate a default implementation.
     if (!pHandler) {
         // Release pointer in the possession of the caller
         pimpl->mProgressHandler = new DefaultProgressHandler();
         pimpl->mIsDefaultProgressHandler = true;
     } else if (pimpl->mProgressHandler != pHandler) { // Otherwise register the custom handler
         delete pimpl->mProgressHandler;
         pimpl->mProgressHandler = pHandler;
         pimpl->mIsDefaultProgressHandler = false;
     }
     ASSIMP_END_EXCEPTION_REGION(void);
 }
 
 // ------------------------------------------------------------------------------------------------
 // Get the currently set progress handler
 ProgressHandler* Importer::GetProgressHandler() const {
     ai_assert(nullptr != pimpl);
-    
+
     return pimpl->mProgressHandler;
 }
 
 // ------------------------------------------------------------------------------------------------
 // Check whether a custom progress handler is currently set
 bool Importer::IsDefaultProgressHandler() const {
     ai_assert(nullptr != pimpl);
-    
+
     return pimpl->mIsDefaultProgressHandler;
 }
 
 // ------------------------------------------------------------------------------------------------
 // Validate post process step flags
@@ -380,66 +380,66 @@ bool _ValidateFlags(unsigned int pFlags) {
 // ------------------------------------------------------------------------------------------------
 // Free the current scene
 void Importer::FreeScene( ) {
     ai_assert(nullptr != pimpl);
-    
+
     ASSIMP_BEGIN_EXCEPTION_REGION();
 
     delete pimpl->mScene;
     pimpl->mScene = nullptr;
 
     pimpl->mErrorString = std::string();
     pimpl->mException = std::exception_ptr();
     ASSIMP_END_EXCEPTION_REGION(void);
 }
 
 // ------------------------------------------------------------------------------------------------
 // Get the current error string, if any
 const char* Importer::GetErrorString() const {
     ai_assert(nullptr != pimpl);
-    
+
     // Must remain valid as long as ReadFile() or FreeFile() are not called
     return pimpl->mErrorString.c_str();
 }
 
 const std::exception_ptr& Importer::GetException() const {
     ai_assert(nullptr != pimpl);
-    
+
     // Must remain valid as long as ReadFile() or FreeFile() are not called
     return pimpl->mException;
 }
 
 // ------------------------------------------------------------------------------------------------
 // Enable extra-verbose mode
 void Importer::SetExtraVerbose(bool bDo) {
     ai_assert(nullptr != pimpl);
-    
+
     pimpl->bExtraVerbose = bDo;
 }
 
 // ------------------------------------------------------------------------------------------------
 // Get the current scene
 const aiScene* Importer::GetScene() const {
     ai_assert(nullptr != pimpl);
-    
+
     return pimpl->mScene;
 }
 
 // ------------------------------------------------------------------------------------------------
 // Orphan the current scene and return it.
 aiScene* Importer::GetOrphanedScene() {
     ai_assert(nullptr != pimpl);
-    
+
     aiScene* s = pimpl->mScene;
 
     ASSIMP_BEGIN_EXCEPTION_REGION();
     pimpl->mScene = nullptr;
 
     pimpl->mErrorString = std::string();
     pimpl->mException = std::exception_ptr();
     ASSIMP_END_EXCEPTION_REGION(aiScene*);
-    
+
     return s;
 }
 
 // ------------------------------------------------------------------------------------------------
 // Validate post-processing flags
@@ -484,446 +484,446 @@ bool Importer::ValidateFlags(unsigned int pFlags) const {
 // ------------------------------------------------------------------------------------------------
 const aiScene* Importer::ReadFileFromMemory( const void* pBuffer,
     size_t pLength,
     unsigned int pFlags,
     const char* pHint /*= ""*/) {
     ai_assert(nullptr != pimpl);
-    
+
     ASSIMP_BEGIN_EXCEPTION_REGION();
     if (!pHint) {
         pHint = "";
     }
 
     if (!pBuffer || !pLength || strlen(pHint) > MaxLenHint ) {
         pimpl->mErrorString = "Invalid parameters passed to ReadFileFromMemory()";
         return nullptr;
     }
 
     // prevent deletion of the previous IOHandler
     IOSystem* io = pimpl->mIOHandler;
     pimpl->mIOHandler = nullptr;
 
     SetIOHandler(new MemoryIOSystem((const uint8_t*)pBuffer,pLength,io));
 
     // read the file and recover the previous IOSystem
     static const size_t BufSize(Importer::MaxLenHint + 28);
     char fbuff[BufSize];
     ai_snprintf(fbuff, BufSize, "%s.%s",AI_MEMORYIO_MAGIC_FILENAME,pHint);
 
     ReadFile(fbuff,pFlags);
     SetIOHandler(io);
 
     ASSIMP_END_EXCEPTION_REGION_WITH_ERROR_STRING(const aiScene*, pimpl->mErrorString, pimpl->mException);
     return pimpl->mScene;
 }
 
 // ------------------------------------------------------------------------------------------------
 void WriteLogOpening(const std::string& file) {
-    
+
     ASSIMP_LOG_INFO("Load ", file);
 
     // print a full version dump. This is nice because we don't
     // need to ask the authors of incoming bug reports for
     // the library version they're using - a log dump is
     // sufficient.
     const unsigned int flags = aiGetCompileFlags();
     std::stringstream stream;
     stream << "Assimp " << aiGetVersionMajor() << "." << aiGetVersionMinor() << "." << aiGetVersionRevision() << " "
 #if defined(ASSIMP_BUILD_ARCHITECTURE)
            << ASSIMP_BUILD_ARCHITECTURE
 #elif defined(_M_IX86) || defined(__x86_32__) || defined(__i386__)
            << "x86"
 #elif defined(_M_X64) || defined(__x86_64__)
            << "amd64"
 #elif defined(_M_IA64) || defined(__ia64__)
            << "itanium"
 #elif defined(__ppc__) || defined(__powerpc__)
            << "ppc32"
 #elif defined(__powerpc64__)
            << "ppc64"
 #elif defined(__arm__)
            << "arm"
 #else
            << "<unknown architecture>"
 #endif
            << " "
 #if defined(ASSIMP_BUILD_COMPILER)
            << (ASSIMP_BUILD_COMPILER)
 #elif defined(_MSC_VER)
            << "msvc"
 #elif defined(__GNUC__)
            << "gcc"
 #elif defined(__clang__)
            << "clang"
 #elif defined(__EMSCRIPTEN__)
            << "emscripten"
 #elif defined(__MINGW32__)
            << "MinGW-w64 32bit"
 #elif defined(__MINGW64__)
            << "MinGW-w64 64bit"
 #else
            << "<unknown compiler>"
 #endif
 
 #ifdef ASSIMP_BUILD_DEBUG
            << " debug"
 #endif
 
            << (flags & ASSIMP_CFLAGS_NOBOOST ? " noboost" : "")
            << (flags & ASSIMP_CFLAGS_SHARED ? " shared" : "")
            << (flags & ASSIMP_CFLAGS_SINGLETHREADED ? " singlethreaded" : "")
            << (flags & ASSIMP_CFLAGS_DOUBLE_SUPPORT ? " double : " : "single : ");
 
     ASSIMP_LOG_DEBUG(stream.str());
 }
 
 // ------------------------------------------------------------------------------------------------
 // Reads the given file and returns its contents if successful.
 const aiScene* Importer::ReadFile( const char* _pFile, unsigned int pFlags) {
     ai_assert(nullptr != pimpl);
-    
+
     ASSIMP_BEGIN_EXCEPTION_REGION();
     const std::string pFile(_pFile);
 
     // ----------------------------------------------------------------------
     // Put a large try block around everything to catch all std::exception's
     // that might be thrown by STL containers or by new().
     // ImportErrorException's are throw by ourselves and caught elsewhere.
     //-----------------------------------------------------------------------
 
     WriteLogOpening(pFile);
 
 #ifdef ASSIMP_CATCH_GLOBAL_EXCEPTIONS
     try
 #endif // ! ASSIMP_CATCH_GLOBAL_EXCEPTIONS
     {
         // Check whether this Importer instance has already loaded
         // a scene. In this case we need to delete the old one
         if (pimpl->mScene)  {
 
             ASSIMP_LOG_DEBUG("(Deleting previous scene)");
             FreeScene();
         }
 
         // First check if the file is accessible at all
         if( !pimpl->mIOHandler->Exists( pFile)) {
 
             pimpl->mErrorString = "Unable to open file \"" + pFile + "\".";
             ASSIMP_LOG_ERROR(pimpl->mErrorString);
             return nullptr;
         }
 
         std::unique_ptr<Profiler> profiler(GetPropertyInteger(AI_CONFIG_GLOB_MEASURE_TIME, 0) ? new Profiler() : nullptr);
         if (profiler) {
             profiler->BeginRegion("total");
         }
 
         // Find an worker class which can handle the file
         BaseImporter* imp = nullptr;
         SetPropertyInteger("importerIndex", -1);
         for( unsigned int a = 0; a < pimpl->mImporter.size(); a++)  {
 
             if( pimpl->mImporter[a]->CanRead( pFile, pimpl->mIOHandler, false)) {
                 imp = pimpl->mImporter[a];
                 SetPropertyInteger("importerIndex", a);
                 break;
             }
         }
 
         if (!imp)   {
             // not so bad yet ... try format auto detection.
             const std::string::size_type s = pFile.find_last_of('.');
             if (s != std::string::npos) {
                 ASSIMP_LOG_INFO("File extension not known, trying signature-based detection");
                 for( unsigned int a = 0; a < pimpl->mImporter.size(); a++)  {
                     if( pimpl->mImporter[a]->CanRead( pFile, pimpl->mIOHandler, true)) {
                         imp = pimpl->mImporter[a];
                         SetPropertyInteger("importerIndex", a);
                         break;
                     }
                 }
             }
             // Put a proper error message if no suitable importer was found
             if( !imp)   {
                 pimpl->mErrorString = "No suitable reader found for the file format of file \"" + pFile + "\".";
                 ASSIMP_LOG_ERROR(pimpl->mErrorString);
                 return nullptr;
             }
         }
 
         // Get file size for progress handler
         IOStream * fileIO = pimpl->mIOHandler->Open( pFile );
         uint32_t fileSize = 0;
         if (fileIO)
         {
             fileSize = static_cast<uint32_t>(fileIO->FileSize());
             pimpl->mIOHandler->Close( fileIO );
         }
 
         // Dispatch the reading to the worker class for this format
         const aiImporterDesc *desc( imp->GetInfo() );
         std::string ext( "unknown" );
         if ( nullptr != desc ) {
             ext = desc->mName;
         }
         ASSIMP_LOG_INFO("Found a matching importer for this file format: ", ext, "." );
         pimpl->mProgressHandler->UpdateFileRead( 0, fileSize );
 
         if (profiler) {
             profiler->BeginRegion("import");
         }
 
         pimpl->mScene = imp->ReadFile( this, pFile, pimpl->mIOHandler);
         pimpl->mProgressHandler->UpdateFileRead( fileSize, fileSize );
 
         if (profiler) {
             profiler->EndRegion("import");
         }
 
         SetPropertyString("sourceFilePath", pFile);
 
         // If successful, apply all active post processing steps to the imported data
         if( pimpl->mScene)  {
             if (!pimpl->mScene->mMetaData || !pimpl->mScene->mMetaData->HasKey(AI_METADATA_SOURCE_FORMAT)) {
                 if (!pimpl->mScene->mMetaData) {
                     pimpl->mScene->mMetaData = new aiMetadata;
                 }
                 pimpl->mScene->mMetaData->Add(AI_METADATA_SOURCE_FORMAT, aiString(ext));
             }
 
 #ifndef ASSIMP_BUILD_NO_VALIDATEDS_PROCESS
             // The ValidateDS process is an exception. It is executed first, even before ScenePreprocessor is called.
             if (pFlags & aiProcess_ValidateDataStructure) {
                 ValidateDSProcess ds;
                 ds.ExecuteOnScene (this);
                 if (!pimpl->mScene) {
                     return nullptr;
                 }
             }
 #endif // no validation
 
             // Preprocess the scene and prepare it for post-processing
             if (profiler) {
                 profiler->BeginRegion("preprocess");
             }
 
             ScenePreprocessor pre(pimpl->mScene);
             pre.ProcessScene();
 
             if (profiler) {
                 profiler->EndRegion("preprocess");
             }
 
             // Ensure that the validation process won't be called twice
             ApplyPostProcessing(pFlags & (~aiProcess_ValidateDataStructure));
         }
         // if failed, extract the error string
         else if( !pimpl->mScene) {
             pimpl->mErrorString = imp->GetErrorText();
             pimpl->mException = imp->GetException();
         }
 
         // clear any data allocated by post-process steps
         pimpl->mPPShared->Clean();
 
         if (profiler) {
             profiler->EndRegion("total");
         }
     }
 #ifdef ASSIMP_CATCH_GLOBAL_EXCEPTIONS
     catch (std::exception &e) {
 #if (defined _MSC_VER) &&   (defined _CPPRTTI)
         // if we have RTTI get the full name of the exception that occurred
         pimpl->mErrorString = std::string(typeid( e ).name()) + ": " + e.what();
 #else
         pimpl->mErrorString = std::string("std::exception: ") + e.what();
 #endif
 
         ASSIMP_LOG_ERROR(pimpl->mErrorString);
         delete pimpl->mScene; pimpl->mScene = nullptr;
     }
 #endif // ! ASSIMP_CATCH_GLOBAL_EXCEPTIONS
 
     // either successful or failure - the pointer expresses it anyways
     ASSIMP_END_EXCEPTION_REGION_WITH_ERROR_STRING(const aiScene*, pimpl->mErrorString, pimpl->mException);
-    
+
     return pimpl->mScene;
 }
 
 
 // ------------------------------------------------------------------------------------------------
 // Apply post-processing to the currently bound scene
 const aiScene* Importer::ApplyPostProcessing(unsigned int pFlags) {
     ai_assert(nullptr != pimpl);
-    
+
     ASSIMP_BEGIN_EXCEPTION_REGION();
     // Return immediately if no scene is active
     if (!pimpl->mScene) {
         return nullptr;
     }
 
     // If no flags are given, return the current scene with no further action
     if (!pFlags) {
         return pimpl->mScene;
     }
 
     // In debug builds: run basic flag validation
     ai_assert(_ValidateFlags(pFlags));
     ASSIMP_LOG_INFO("Entering post processing pipeline");
 
 #ifndef ASSIMP_BUILD_NO_VALIDATEDS_PROCESS
     // The ValidateDS process plays an exceptional role. It isn't contained in the global
     // list of post-processing steps, so we need to call it manually.
     if (pFlags & aiProcess_ValidateDataStructure) {
         ValidateDSProcess ds;
         ds.ExecuteOnScene (this);
         if (!pimpl->mScene) {
             return nullptr;
         }
     }
 #endif // no validation
 #ifdef ASSIMP_BUILD_DEBUG
     if (pimpl->bExtraVerbose)
     {
 #ifdef ASSIMP_BUILD_NO_VALIDATEDS_PROCESS
         ASSIMP_LOG_ERROR("Verbose Import is not available due to build settings");
 #endif  // no validation
         pFlags |= aiProcess_ValidateDataStructure;
     }
 #else
     if (pimpl->bExtraVerbose) {
         ASSIMP_LOG_WARN("Not a debug build, ignoring extra verbose setting");
     }
 #endif // ! DEBUG
 
     std::unique_ptr<Profiler> profiler(GetPropertyInteger(AI_CONFIG_GLOB_MEASURE_TIME, 0) ? new Profiler() : nullptr);
     for( unsigned int a = 0; a < pimpl->mPostProcessingSteps.size(); a++)   {
         BaseProcess* process = pimpl->mPostProcessingSteps[a];
         pimpl->mProgressHandler->UpdatePostProcess(static_cast<int>(a), static_cast<int>(pimpl->mPostProcessingSteps.size()) );
         if( process->IsActive( pFlags)) {
             if (profiler) {
                 profiler->BeginRegion("postprocess");
             }
 
             process->ExecuteOnScene ( this );
 
             if (profiler) {
                 profiler->EndRegion("postprocess");
             }
         }
         if( !pimpl->mScene) {
             break;
         }
 #ifdef ASSIMP_BUILD_DEBUG
 
 #ifdef ASSIMP_BUILD_NO_VALIDATEDS_PROCESS
         continue;
 #endif  // no validation
 
         // If the extra verbose mode is active, execute the ValidateDataStructureStep again - after each step
         if (pimpl->bExtraVerbose)   {
             ASSIMP_LOG_DEBUG("Verbose Import: re-validating data structures");
 
             ValidateDSProcess ds;
             ds.ExecuteOnScene (this);
             if( !pimpl->mScene) {
                 ASSIMP_LOG_ERROR("Verbose Import: failed to re-validate data structures");
                 break;
             }
         }
 #endif // ! DEBUG
     }
-    pimpl->mProgressHandler->UpdatePostProcess( static_cast<int>(pimpl->mPostProcessingSteps.size()), 
+    pimpl->mProgressHandler->UpdatePostProcess( static_cast<int>(pimpl->mPostProcessingSteps.size()),
         static_cast<int>(pimpl->mPostProcessingSteps.size()) );
 
     // update private scene flags
     if( pimpl->mScene ) {
       ScenePriv(pimpl->mScene)->mPPStepsApplied |= pFlags;
     }
 
     // clear any data allocated by post-process steps
     pimpl->mPPShared->Clean();
     ASSIMP_LOG_INFO("Leaving post processing pipeline");
 
     ASSIMP_END_EXCEPTION_REGION(const aiScene*);
-    
+
     return pimpl->mScene;
 }
 
 // ------------------------------------------------------------------------------------------------
 const aiScene* Importer::ApplyCustomizedPostProcessing( BaseProcess *rootProcess, bool requestValidation ) {
     ai_assert(nullptr != pimpl);
-    
+
     ASSIMP_BEGIN_EXCEPTION_REGION();
 
     // Return immediately if no scene is active
     if ( nullptr == pimpl->mScene ) {
         return nullptr;
     }
 
     // If no flags are given, return the current scene with no further action
     if (nullptr == rootProcess) {
         return pimpl->mScene;
     }
 
     // In debug builds: run basic flag validation
     ASSIMP_LOG_INFO( "Entering customized post processing pipeline" );
 
 #ifndef ASSIMP_BUILD_NO_VALIDATEDS_PROCESS
     // The ValidateDS process plays an exceptional role. It isn't contained in the global
     // list of post-processing steps, so we need to call it manually.
     if ( requestValidation )
     {
         ValidateDSProcess ds;
         ds.ExecuteOnScene( this );
         if ( !pimpl->mScene ) {
             return nullptr;
         }
     }
 #endif // no validation
 #ifdef ASSIMP_BUILD_DEBUG
     if ( pimpl->bExtraVerbose )
     {
 #ifdef ASSIMP_BUILD_NO_VALIDATEDS_PROCESS
         ASSIMP_LOG_ERROR( "Verbose Import is not available due to build settings" );
 #endif  // no validation
     }
 #else
     if ( pimpl->bExtraVerbose ) {
         ASSIMP_LOG_WARN( "Not a debug build, ignoring extra verbose setting" );
     }
 #endif // ! DEBUG
 
     std::unique_ptr<Profiler> profiler(GetPropertyInteger(AI_CONFIG_GLOB_MEASURE_TIME, 0) ? new Profiler() : nullptr);
 
     if ( profiler ) {
         profiler->BeginRegion( "postprocess" );
     }
 
     rootProcess->ExecuteOnScene( this );
 
     if ( profiler ) {
         profiler->EndRegion( "postprocess" );
     }
 
     // If the extra verbose mode is active, execute the ValidateDataStructureStep again - after each step
     if ( pimpl->bExtraVerbose || requestValidation  ) {
         ASSIMP_LOG_DEBUG( "Verbose Import: revalidating data structures" );
 
         ValidateDSProcess ds;
         ds.ExecuteOnScene( this );
         if ( !pimpl->mScene ) {
             ASSIMP_LOG_ERROR( "Verbose Import: failed to revalidate data structures" );
         }
     }
 
     // clear any data allocated by post-process steps
     pimpl->mPPShared->Clean();
     ASSIMP_LOG_INFO( "Leaving customized post processing pipeline" );
 
     ASSIMP_END_EXCEPTION_REGION( const aiScene* );
 
     return pimpl->mScene;
 }
 
 // ------------------------------------------------------------------------------------------------
 // Helper function to check whether an extension is supported by ASSIMP
@@ -934,38 +934,38 @@ bool Importer::IsExtensionSupported(const char* szExtension) const {
 // ------------------------------------------------------------------------------------------------
 size_t Importer::GetImporterCount() const {
     ai_assert(nullptr != pimpl);
-    
+
     return pimpl->mImporter.size();
 }
 
 // ------------------------------------------------------------------------------------------------
 const aiImporterDesc* Importer::GetImporterInfo(size_t index) const {
     ai_assert(nullptr != pimpl);
-    
+
     if (index >= pimpl->mImporter.size()) {
         return nullptr;
     }
     return pimpl->mImporter[index]->GetInfo();
 }
 
 
 // ------------------------------------------------------------------------------------------------
 BaseImporter* Importer::GetImporter (size_t index) const {
     ai_assert(nullptr != pimpl);
-    
+
     if (index >= pimpl->mImporter.size()) {
         return nullptr;
     }
     return pimpl->mImporter[index];
 }
 
 // ------------------------------------------------------------------------------------------------
 // Find a loader plugin for a given file extension
 BaseImporter* Importer::GetImporter (const char* szExtension) const {
     ai_assert(nullptr != pimpl);
-    
+
     return GetImporter(GetImporterIndex(szExtension));
 }
 
 // ------------------------------------------------------------------------------------------------
 // Find a loader plugin for a given file extension
@@ -1001,112 +1001,112 @@ size_t Importer::GetImporterIndex (const char* szExtension) const {
 // ------------------------------------------------------------------------------------------------
 // Helper function to build a list of all file extensions supported by ASSIMP
 void Importer::GetExtensionList(aiString& szOut) const {
     ai_assert(nullptr != pimpl);
-    
+
     ASSIMP_BEGIN_EXCEPTION_REGION();
     std::set<std::string> str;
     for (std::vector<BaseImporter*>::const_iterator i =  pimpl->mImporter.begin();i != pimpl->mImporter.end();++i)  {
         (*i)->GetExtensionList(str);
     }
 
 	// List can be empty
 	if( !str.empty() ) {
 		for (std::set<std::string>::const_iterator it = str.begin();; ) {
 			szOut.Append("*.");
 			szOut.Append((*it).c_str());
 
 			if (++it == str.end()) {
 				break;
 			}
 			szOut.Append(";");
 		}
 	}
     ASSIMP_END_EXCEPTION_REGION(void);
 }
 
 // ------------------------------------------------------------------------------------------------
 // Set a configuration property
 bool Importer::SetPropertyInteger(const char* szName, int iValue) {
     ai_assert(nullptr != pimpl);
-    
+
     bool existing;
     ASSIMP_BEGIN_EXCEPTION_REGION();
         existing = SetGenericProperty<int>(pimpl->mIntProperties, szName,iValue);
     ASSIMP_END_EXCEPTION_REGION(bool);
     return existing;
 }
 
 // ------------------------------------------------------------------------------------------------
 // Set a configuration property
 bool Importer::SetPropertyFloat(const char* szName, ai_real iValue) {
     ai_assert(nullptr != pimpl);
-    
+
     bool existing;
     ASSIMP_BEGIN_EXCEPTION_REGION();
         existing = SetGenericProperty<ai_real>(pimpl->mFloatProperties, szName,iValue);
     ASSIMP_END_EXCEPTION_REGION(bool);
     return existing;
 }
 
 // ------------------------------------------------------------------------------------------------
 // Set a configuration property
 bool Importer::SetPropertyString(const char* szName, const std::string& value) {
     ai_assert(nullptr != pimpl);
-    
+
     bool existing;
     ASSIMP_BEGIN_EXCEPTION_REGION();
         existing = SetGenericProperty<std::string>(pimpl->mStringProperties, szName,value);
     ASSIMP_END_EXCEPTION_REGION(bool);
     return existing;
 }
 
 // ------------------------------------------------------------------------------------------------
 // Set a configuration property
 bool Importer::SetPropertyMatrix(const char* szName, const aiMatrix4x4& value) {
     ai_assert(nullptr != pimpl);
-    
+
     bool existing;
     ASSIMP_BEGIN_EXCEPTION_REGION();
         existing = SetGenericProperty<aiMatrix4x4>(pimpl->mMatrixProperties, szName,value);
     ASSIMP_END_EXCEPTION_REGION(bool);
     return existing;
 }
 
 // ------------------------------------------------------------------------------------------------
 // Get a configuration property
 int Importer::GetPropertyInteger(const char* szName, int iErrorReturn /*= 0xffffffff*/) const {
     ai_assert(nullptr != pimpl);
-    
+
     return GetGenericProperty<int>(pimpl->mIntProperties,szName,iErrorReturn);
 }
 
 // ------------------------------------------------------------------------------------------------
 // Get a configuration property
 ai_real Importer::GetPropertyFloat(const char* szName, ai_real iErrorReturn /*= 10e10*/) const {
     ai_assert(nullptr != pimpl);
-    
+
     return GetGenericProperty<ai_real>(pimpl->mFloatProperties,szName,iErrorReturn);
 }
 
 // ------------------------------------------------------------------------------------------------
 // Get a configuration property
 std::string Importer::GetPropertyString(const char* szName, const std::string& iErrorReturn /*= ""*/) const {
     ai_assert(nullptr != pimpl);
-    
+
     return GetGenericProperty<std::string>(pimpl->mStringProperties,szName,iErrorReturn);
 }
 
 // ------------------------------------------------------------------------------------------------
 // Get a configuration property
 aiMatrix4x4 Importer::GetPropertyMatrix(const char* szName, const aiMatrix4x4& iErrorReturn /*= aiMatrix4x4()*/) const {
     ai_assert(nullptr != pimpl);
-    
+
     return GetGenericProperty<aiMatrix4x4>(pimpl->mMatrixProperties,szName,iErrorReturn);
 }
 
 // ------------------------------------------------------------------------------------------------
 // Get the memory requirements of a single node
-inline 
+inline
 void AddNodeWeight(unsigned int& iScene,const aiNode* pcNode) {
     if ( nullptr == pcNode ) {
         return;
@@ -1123,103 +1123,103 @@ void AddNodeWeight(unsigned int& iScene,const aiNode* pcNode) {
 // ------------------------------------------------------------------------------------------------
 // Get the memory requirements of the scene
 void Importer::GetMemoryRequirements(aiMemoryInfo& in) const {
     ai_assert(nullptr != pimpl);
-    
+
     in = aiMemoryInfo();
     aiScene* mScene = pimpl->mScene;
 
     // return if we have no scene loaded
     if (!mScene)
         return;
 
     in.total = sizeof(aiScene);
 
     // add all meshes
     for (unsigned int i = 0; i < mScene->mNumMeshes;++i) {
         in.meshes += sizeof(aiMesh);
         if (mScene->mMeshes[i]->HasPositions()) {
             in.meshes += sizeof(aiVector3D) * mScene->mMeshes[i]->mNumVertices;
         }
 
         if (mScene->mMeshes[i]->HasNormals()) {
             in.meshes += sizeof(aiVector3D) * mScene->mMeshes[i]->mNumVertices;
         }
 
         if (mScene->mMeshes[i]->HasTangentsAndBitangents()) {
             in.meshes += sizeof(aiVector3D) * mScene->mMeshes[i]->mNumVertices * 2;
         }
 
         for (unsigned int a = 0; a < AI_MAX_NUMBER_OF_COLOR_SETS;++a) {
             if (mScene->mMeshes[i]->HasVertexColors(a)) {
                 in.meshes += sizeof(aiColor4D) * mScene->mMeshes[i]->mNumVertices;
             } else {
                 break;
             }
         }
         for (unsigned int a = 0; a < AI_MAX_NUMBER_OF_TEXTURECOORDS;++a) {
             if (mScene->mMeshes[i]->HasTextureCoords(a)) {
                 in.meshes += sizeof(aiVector3D) * mScene->mMeshes[i]->mNumVertices;
             } else {
                 break;
             }
         }
         if (mScene->mMeshes[i]->HasBones()) {
             in.meshes += sizeof(void*) * mScene->mMeshes[i]->mNumBones;
             for (unsigned int p = 0; p < mScene->mMeshes[i]->mNumBones;++p) {
                 in.meshes += sizeof(aiBone);
                 in.meshes += mScene->mMeshes[i]->mBones[p]->mNumWeights * sizeof(aiVertexWeight);
             }
         }
         in.meshes += (sizeof(aiFace) + 3 * sizeof(unsigned int))*mScene->mMeshes[i]->mNumFaces;
     }
     in.total += in.meshes;
 
     // add all embedded textures
     for (unsigned int i = 0; i < mScene->mNumTextures;++i) {
         const aiTexture* pc = mScene->mTextures[i];
         in.textures += sizeof(aiTexture);
         if (pc->mHeight) {
             in.textures += 4 * pc->mHeight * pc->mWidth;
         } else {
             in.textures += pc->mWidth;
         }
     }
     in.total += in.textures;
 
     // add all animations
     for (unsigned int i = 0; i < mScene->mNumAnimations;++i) {
         const aiAnimation* pc = mScene->mAnimations[i];
         in.animations += sizeof(aiAnimation);
 
         // add all bone anims
         for (unsigned int a = 0; a < pc->mNumChannels; ++a) {
             const aiNodeAnim* pc2 = pc->mChannels[a];
             in.animations += sizeof(aiNodeAnim);
             in.animations += pc2->mNumPositionKeys * sizeof(aiVectorKey);
             in.animations += pc2->mNumScalingKeys * sizeof(aiVectorKey);
             in.animations += pc2->mNumRotationKeys * sizeof(aiQuatKey);
         }
     }
     in.total += in.animations;
 
     // add all cameras and all lights
     in.total += in.cameras = sizeof(aiCamera) *  mScene->mNumCameras;
     in.total += in.lights  = sizeof(aiLight)  *  mScene->mNumLights;
 
     // add all nodes
     AddNodeWeight(in.nodes,mScene->mRootNode);
     in.total += in.nodes;
 
     // add all materials
     for (unsigned int i = 0; i < mScene->mNumMaterials;++i) {
         const aiMaterial* pc = mScene->mMaterials[i];
         in.materials += sizeof(aiMaterial);
         in.materials += pc->mNumAllocated * sizeof(void*);
 
         for (unsigned int a = 0; a < pc->mNumProperties;++a) {
             in.materials += pc->mProperties[a]->mDataLength;
         }
     }
 
     in.total += in.materials;
 }
diff --git a/code/Common/Importer.h b/code/Common/Importer.h
index e7da7f439..0e04f9452 100644
--- a/code/Common/Importer.h
+++ b/code/Common/Importer.h
@@ -162,76 +162,76 @@ class ASSIMP_API BatchLoader {
 public:
     //! @cond never
     // -------------------------------------------------------------------
     /** Wraps a full list of configuration properties for an importer.
      *  Properties can be set using SetGenericProperty */
     struct PropertyMap {
         ImporterPimpl::IntPropertyMap     ints;
         ImporterPimpl::FloatPropertyMap   floats;
         ImporterPimpl::StringPropertyMap  strings;
         ImporterPimpl::MatrixPropertyMap  matrices;
 
         bool operator == (const PropertyMap& prop) const {
             // fixme: really isocpp? gcc complains
             return ints == prop.ints && floats == prop.floats && strings == prop.strings && matrices == prop.matrices;
         }
 
         bool empty () const {
             return ints.empty() && floats.empty() && strings.empty() && matrices.empty();
         }
     };
     //! @endcond
 
     // -------------------------------------------------------------------
     /** Construct a batch loader from a given IO system to be used
-     *  to access external files 
+     *  to access external files
      */
     explicit BatchLoader(IOSystem* pIO, bool validate = false );
 
     // -------------------------------------------------------------------
     /** The class destructor.
      */
     ~BatchLoader();
 
     // -------------------------------------------------------------------
     /** Sets the validation step. True for enable validation during postprocess.
      *  @param  enable  True for validation.
      */
     void setValidation( bool enabled );
-    
+
     // -------------------------------------------------------------------
     /** Returns the current validation step.
      *  @return The current validation step.
      */
     bool getValidation() const;
-    
+
     // -------------------------------------------------------------------
     /** Add a new file to the list of files to be loaded.
      *  @param file File to be loaded
      *  @param steps Post-processing steps to be executed on the file
      *  @param map Optional configuration properties
      *  @return 'Load request channel' - an unique ID that can later
      *    be used to access the imported file data.
      *  @see GetImport */
     unsigned int AddLoadRequest (
         const std::string& file,
         unsigned int steps = 0,
             const PropertyMap *map = nullptr
         );
 
     // -------------------------------------------------------------------
     /** Get an imported scene.
      *  This polls the import from the internal request list.
      *  If an import is requested several times, this function
      *  can be called several times, too.
      *
      *  @param which LRWC returned by AddLoadRequest().
      *  @return nullptr if there is no scene with this file name
      *  in the queue of the scene hasn't been loaded yet. */
     aiScene* GetImport(
         unsigned int which
         );
 
     // -------------------------------------------------------------------
     /** Waits until all scenes have been loaded. This returns
      *  immediately if no scenes are queued.*/
     void LoadAll();
diff --git a/code/Common/ImporterRegistry.cpp b/code/Common/ImporterRegistry.cpp
index ddfcf6798..5df096166 100644
--- a/code/Common/ImporterRegistry.cpp
+++ b/code/Common/ImporterRegistry.cpp
@@ -205,176 +205,176 @@ corresponding preprocessor flag to selectively disable formats.
 namespace Assimp {
 
 // ------------------------------------------------------------------------------------------------
-void GetImporterInstanceList(std::vector<BaseImporter *> &out) {    
-    
+void GetImporterInstanceList(std::vector<BaseImporter *> &out) {
+
     // Some importers may be unimplemented or otherwise unsuitable for general use
     // in their current state. Devs can set ASSIMP_ENABLE_DEV_IMPORTERS in their
     // local environment to enable them, otherwise they're left out of the registry.
     const char *envStr = std::getenv("ASSIMP_ENABLE_DEV_IMPORTERS");
     bool devImportersEnabled = envStr && strcmp(envStr, "0");
 
     // Ensure no unused var warnings if all uses are #ifndef'd away below:
     (void)devImportersEnabled;
 
     // ----------------------------------------------------------------------------
     // Add an instance of each worker class here
     // (register_new_importers_here)
     // ----------------------------------------------------------------------------
     out.reserve(64);
 #if (!defined ASSIMP_BUILD_NO_X_IMPORTER)
     out.push_back(new XFileImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_OBJ_IMPORTER)
     out.push_back(new ObjFileImporter());
 #endif
 #ifndef ASSIMP_BUILD_NO_AMF_IMPORTER
     out.push_back(new AMFImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_3DS_IMPORTER)
     out.push_back(new Discreet3DSImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_M3D_IMPORTER)
     out.push_back(new M3DImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_MD3_IMPORTER)
     out.push_back(new MD3Importer());
 #endif
 #if (!defined ASSIMP_BUILD_NO_MD2_IMPORTER)
     out.push_back(new MD2Importer());
 #endif
 #if (!defined ASSIMP_BUILD_NO_PLY_IMPORTER)
     out.push_back(new PLYImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_MDL_IMPORTER)
     out.push_back(new MDLImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_ASE_IMPORTER)
 #if (!defined ASSIMP_BUILD_NO_3DS_IMPORTER)
     out.push_back(new ASEImporter());
 #endif
 #endif
 #if (!defined ASSIMP_BUILD_NO_HMP_IMPORTER)
     out.push_back(new HMPImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_SMD_IMPORTER)
     out.push_back(new SMDImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_MDC_IMPORTER)
     out.push_back(new MDCImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_MD5_IMPORTER)
     out.push_back(new MD5Importer());
 #endif
 #if (!defined ASSIMP_BUILD_NO_STL_IMPORTER)
     out.push_back(new STLImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_LWO_IMPORTER)
     out.push_back(new LWOImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_DXF_IMPORTER)
     out.push_back(new DXFImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_NFF_IMPORTER)
     out.push_back(new NFFImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_RAW_IMPORTER)
     out.push_back(new RAWImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_SIB_IMPORTER)
     out.push_back(new SIBImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_OFF_IMPORTER)
     out.push_back(new OFFImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_AC_IMPORTER)
     out.push_back(new AC3DImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_BVH_IMPORTER)
     out.push_back(new BVHLoader());
 #endif
 #if (!defined ASSIMP_BUILD_NO_IRRMESH_IMPORTER)
     out.push_back(new IRRMeshImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_IRR_IMPORTER)
     out.push_back(new IRRImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_Q3D_IMPORTER)
     out.push_back(new Q3DImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_B3D_IMPORTER)
     out.push_back(new B3DImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_COLLADA_IMPORTER)
     out.push_back(new ColladaLoader());
 #endif
 #if (!defined ASSIMP_BUILD_NO_TERRAGEN_IMPORTER)
     out.push_back(new TerragenImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_CSM_IMPORTER)
     out.push_back(new CSMImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_3D_IMPORTER)
     out.push_back(new UnrealImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_LWS_IMPORTER)
     out.push_back(new LWSImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_OGRE_IMPORTER)
     out.push_back(new Ogre::OgreImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_OPENGEX_IMPORTER)
     out.push_back(new OpenGEX::OpenGEXImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_MS3D_IMPORTER)
     out.push_back(new MS3DImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_COB_IMPORTER)
     out.push_back(new COBImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_BLEND_IMPORTER)
     out.push_back(new BlenderImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_Q3BSP_IMPORTER)
     out.push_back(new Q3BSPFileImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_NDO_IMPORTER)
     out.push_back(new NDOImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_IFC_IMPORTER)
     out.push_back(new IFCImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_XGL_IMPORTER)
     out.push_back(new XGLImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_FBX_IMPORTER)
     out.push_back(new FBXImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_ASSBIN_IMPORTER)
     out.push_back(new AssbinImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_GLTF_IMPORTER && !defined ASSIMP_BUILD_NO_GLTF1_IMPORTER)
     out.push_back(new glTFImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_GLTF_IMPORTER && !defined ASSIMP_BUILD_NO_GLTF2_IMPORTER)
     out.push_back(new glTF2Importer());
 #endif
 #if (!defined ASSIMP_BUILD_NO_C4D_IMPORTER)
     out.push_back(new C4DImporter());
 #endif
 #if (!defined ASSIMP_BUILD_NO_3MF_IMPORTER)
     out.push_back(new D3MFImporter());
 #endif
 #ifndef ASSIMP_BUILD_NO_X3D_IMPORTER
     if (devImportersEnabled) { // https://github.com/assimp/assimp/issues/3647
         out.push_back(new X3DImporter());
     }
 #endif
 #ifndef ASSIMP_BUILD_NO_MMD_IMPORTER
     out.push_back(new MMDImporter());
 #endif
     //#ifndef ASSIMP_BUILD_NO_STEP_IMPORTER
     //    out.push_back(new StepFile::StepFileImporter());
     //#endif
 }
 
 /** will delete all registered importers. */
diff --git a/code/Common/Win32DebugLogStream.h b/code/Common/Win32DebugLogStream.h
index 3385aa8ce..51f1ab178 100644
--- a/code/Common/Win32DebugLogStream.h
+++ b/code/Common/Win32DebugLogStream.h
@@ -71,19 +71,19 @@ public:
 };
 
 // ---------------------------------------------------------------------------
-inline 
-Win32DebugLogStream::Win32DebugLogStream(){ 
+inline
+Win32DebugLogStream::Win32DebugLogStream(){
     // empty
 }
 
 // ---------------------------------------------------------------------------
-inline 
+inline
 Win32DebugLogStream::~Win32DebugLogStream(){
     // empty
 }
 
 // ---------------------------------------------------------------------------
-inline 
+inline
 void Win32DebugLogStream::write(const char* message) {
     ::OutputDebugStringA( message);
 }
diff --git a/code/PostProcessing/ArmaturePopulate.h b/code/PostProcessing/ArmaturePopulate.h
index 08a72bd66..ded8b4886 100644
--- a/code/PostProcessing/ArmaturePopulate.h
+++ b/code/PostProcessing/ArmaturePopulate.h
@@ -70,43 +70,43 @@ class ASSIMP_API ArmaturePopulate : public BaseProcess {
 public:
     /// The default class constructor.
     ArmaturePopulate();
 
     /// The class destructor.
     virtual ~ArmaturePopulate();
 
     /// Overwritten, @see BaseProcess
     virtual bool IsActive( unsigned int pFlags ) const;
 
     /// Overwritten, @see BaseProcess
     virtual void SetupProperties( const Importer* pImp );
 
     /// Overwritten, @see BaseProcess
     virtual void Execute( aiScene* pScene );
 
     static aiNode *GetArmatureRoot(aiNode *bone_node,
                                       std::vector<aiBone *> &bone_list);
 
     static bool IsBoneNode(const aiString &bone_name,
                               std::vector<aiBone *> &bones);
 
     static aiNode *GetNodeFromStack(const aiString &node_name,
                                        std::vector<aiNode *> &nodes);
 
     static void BuildNodeList(const aiNode *current_node,
                                  std::vector<aiNode *> &nodes);
 
     static void BuildBoneList(aiNode *current_node, const aiNode *root_node,
                                  const aiScene *scene,
-                                 std::vector<aiBone *> &bones);                        
+                                 std::vector<aiBone *> &bones);
 
     static void BuildBoneStack(aiNode *current_node, const aiNode *root_node,
                                   const aiScene *scene,
                                   const std::vector<aiBone *> &bones,
                                   std::map<aiBone *, aiNode *> &bone_stack,
                                   std::vector<aiNode *> &node_stack);
 };
 
 } // Namespace Assimp
 
 
 #endif // SCALE_PROCESS_H_
diff --git a/code/PostProcessing/DropFaceNormalsProcess.cpp b/code/PostProcessing/DropFaceNormalsProcess.cpp
index c01ac35e5..21abf9693 100644
--- a/code/PostProcessing/DropFaceNormalsProcess.cpp
+++ b/code/PostProcessing/DropFaceNormalsProcess.cpp
@@ -99,13 +99,13 @@ void DropFaceNormalsProcess::Execute( aiScene* pScene) {
 // ------------------------------------------------------------------------------------------------
 // Executes the post processing step on the given imported data.
 bool DropFaceNormalsProcess::DropMeshFaceNormals (aiMesh* mesh) {
     ai_assert(nullptr != mesh);
 
     if (nullptr == mesh->mNormals) {
         return false;
     }
-    
+
     delete[] mesh->mNormals;
     mesh->mNormals = nullptr;
     return true;
 }
diff --git a/code/PostProcessing/EmbedTexturesProcess.cpp b/code/PostProcessing/EmbedTexturesProcess.cpp
index 500032c39..d7720de98 100644
--- a/code/PostProcessing/EmbedTexturesProcess.cpp
+++ b/code/PostProcessing/EmbedTexturesProcess.cpp
@@ -103,59 +103,59 @@ void EmbedTexturesProcess::Execute(aiScene* pScene) {
 bool EmbedTexturesProcess::addTexture(aiScene *pScene, const std::string &path) const {
     std::streampos imageSize = 0;
     std::string    imagePath = path;
 
     // Test path directly
     if (!mIOHandler->Exists(imagePath)) {
         ASSIMP_LOG_WARN("EmbedTexturesProcess: Cannot find image: ", imagePath, ". Will try to find it in root folder.");
 
         // Test path in root path
         imagePath = mRootPath + path;
         if (!mIOHandler->Exists(imagePath)) {
             // Test path basename in root path
             imagePath = mRootPath + path.substr(path.find_last_of("\\/") + 1u);
             if (!mIOHandler->Exists(imagePath)) {
                 ASSIMP_LOG_ERROR("EmbedTexturesProcess: Unable to embed texture: ", path, ".");
                 return false;
             }
         }
     }
     IOStream* pFile = mIOHandler->Open(imagePath);
     if (pFile == nullptr) {
         ASSIMP_LOG_ERROR("EmbedTexturesProcess: Unable to embed texture: ", path, ".");
         return false;
     }
     imageSize = pFile->FileSize();
 
     aiTexel* imageContent = new aiTexel[ 1ul + static_cast<unsigned long>( imageSize ) / sizeof(aiTexel)];
     pFile->Seek(0, aiOrigin_SET);
     pFile->Read(reinterpret_cast<char*>(imageContent), imageSize, 1);
     mIOHandler->Close(pFile);
 
     // Enlarging the textures table
     unsigned int textureId = pScene->mNumTextures++;
     auto oldTextures = pScene->mTextures;
     pScene->mTextures = new aiTexture*[pScene->mNumTextures];
     ::memmove(pScene->mTextures, oldTextures, sizeof(aiTexture*) * (pScene->mNumTextures - 1u));
     delete [] oldTextures;
-    
+
     // Add the new texture
     auto pTexture = new aiTexture;
     pTexture->mHeight = 0; // Means that this is still compressed
     pTexture->mWidth = static_cast<uint32_t>(imageSize);
     pTexture->pcData = imageContent;
 
     auto extension = path.substr(path.find_last_of('.') + 1u);
     extension = ai_tolower(extension);
     if (extension == "jpeg") {
         extension = "jpg";
     }
 
     size_t len = extension.size();
     if (len > HINTMAXTEXTURELEN -1 ) {
         len = HINTMAXTEXTURELEN - 1;
     }
     ::strncpy(pTexture->achFormatHint, extension.c_str(), len);
     pScene->mTextures[textureId] = pTexture;
 
     return true;
 }
diff --git a/code/PostProcessing/FindDegenerates.cpp b/code/PostProcessing/FindDegenerates.cpp
index eae91ff02..3809abf50 100644
--- a/code/PostProcessing/FindDegenerates.cpp
+++ b/code/PostProcessing/FindDegenerates.cpp
@@ -86,33 +86,33 @@ void FindDegeneratesProcess::SetupProperties(const Importer* pImp) {
 // ------------------------------------------------------------------------------------------------
 // Executes the post processing step on the given imported data.
 void FindDegeneratesProcess::Execute( aiScene* pScene) {
     ASSIMP_LOG_DEBUG("FindDegeneratesProcess begin");
     if ( nullptr == pScene) {
         return;
     }
-    
+
     std::unordered_map<unsigned int, unsigned int> meshMap;
     meshMap.reserve(pScene->mNumMeshes);
 
     const unsigned int originalNumMeshes = pScene->mNumMeshes;
     unsigned int targetIndex = 0;
     for (unsigned int i = 0; i < pScene->mNumMeshes; ++i) {
         // Do not process point cloud, ExecuteOnMesh works only with faces data
         if ((pScene->mMeshes[i]->mPrimitiveTypes != aiPrimitiveType::aiPrimitiveType_POINT) && ExecuteOnMesh(pScene->mMeshes[i])) {
             delete pScene->mMeshes[i];
             // Not strictly required, but clean:
             pScene->mMeshes[i] = nullptr;
         } else {
             meshMap[i] = targetIndex;
             pScene->mMeshes[targetIndex] = pScene->mMeshes[i];
             ++targetIndex;
         }
     }
     pScene->mNumMeshes = targetIndex;
 
     if (meshMap.size() < originalNumMeshes) {
         updateSceneGraph(pScene->mRootNode, meshMap);
     }
 
     ASSIMP_LOG_DEBUG("FindDegeneratesProcess finished");
 }
diff --git a/code/PostProcessing/FindInstancesProcess.cpp b/code/PostProcessing/FindInstancesProcess.cpp
index ab5f52b78..d46afc201 100644
--- a/code/PostProcessing/FindInstancesProcess.cpp
+++ b/code/PostProcessing/FindInstancesProcess.cpp
@@ -118,160 +118,160 @@ void UpdateMeshIndices(aiNode* node, unsigned int* lookup)
 // ------------------------------------------------------------------------------------------------
 // Executes the post processing step on the given imported data.
 void FindInstancesProcess::Execute( aiScene* pScene)
 {
     ASSIMP_LOG_DEBUG("FindInstancesProcess begin");
     if (pScene->mNumMeshes) {
 
         // use a pseudo hash for all meshes in the scene to quickly find
         // the ones which are possibly equal. This step is executed early
         // in the pipeline, so we could, depending on the file format,
         // have several thousand small meshes. That's too much for a brute
         // everyone-against-everyone check involving up to 10 comparisons
         // each.
         std::unique_ptr<uint64_t[]> hashes (new uint64_t[pScene->mNumMeshes]);
         std::unique_ptr<unsigned int[]> remapping (new unsigned int[pScene->mNumMeshes]);
 
         unsigned int numMeshesOut = 0;
         for (unsigned int i = 0; i < pScene->mNumMeshes; ++i) {
 
             aiMesh* inst = pScene->mMeshes[i];
             hashes[i] = GetMeshHash(inst);
 
-            // Find an appropriate epsilon 
+            // Find an appropriate epsilon
             // to compare position differences against
             float epsilon = ComputePositionEpsilon(inst);
             epsilon *= epsilon;
 
             for (int a = i-1; a >= 0; --a) {
                 if (hashes[i] == hashes[a])
                 {
                     aiMesh* orig = pScene->mMeshes[a];
                     if (!orig)
                         continue;
 
                     // check for hash collision .. we needn't check
                     // the vertex format, it *must* match due to the
                     // (brilliant) construction of the hash
                     if (orig->mNumBones       != inst->mNumBones      ||
                         orig->mNumFaces       != inst->mNumFaces      ||
                         orig->mNumVertices    != inst->mNumVertices   ||
                         orig->mMaterialIndex  != inst->mMaterialIndex ||
                         orig->mPrimitiveTypes != inst->mPrimitiveTypes)
                         continue;
 
                     // up to now the meshes are equal. Now compare vertex positions, normals,
                     // tangents and bitangents using this epsilon.
                     if (orig->HasPositions()) {
                         if(!CompareArrays(orig->mVertices,inst->mVertices,orig->mNumVertices,epsilon))
                             continue;
                     }
                     if (orig->HasNormals()) {
                         if(!CompareArrays(orig->mNormals,inst->mNormals,orig->mNumVertices,epsilon))
                             continue;
                     }
                     if (orig->HasTangentsAndBitangents()) {
                         if (!CompareArrays(orig->mTangents,inst->mTangents,orig->mNumVertices,epsilon) ||
                             !CompareArrays(orig->mBitangents,inst->mBitangents,orig->mNumVertices,epsilon))
                             continue;
                     }
 
                     // use a constant epsilon for colors and UV coordinates
                     static const float uvEpsilon = 10e-4f;
                     {
                         unsigned int j, end = orig->GetNumUVChannels();
                         for(j = 0; j < end; ++j) {
                             if (!orig->mTextureCoords[j]) {
                                 continue;
                             }
                             if(!CompareArrays(orig->mTextureCoords[j],inst->mTextureCoords[j],orig->mNumVertices,uvEpsilon)) {
                                 break;
                             }
                         }
                         if (j != end) {
                             continue;
                         }
                     }
                     {
                         unsigned int j, end = orig->GetNumColorChannels();
                         for(j = 0; j < end; ++j) {
                             if (!orig->mColors[j]) {
                                 continue;
                             }
                             if(!CompareArrays(orig->mColors[j],inst->mColors[j],orig->mNumVertices,uvEpsilon)) {
                                 break;
                             }
                         }
                         if (j != end) {
                             continue;
                         }
                     }
 
                     // These two checks are actually quite expensive and almost *never* required.
                     // Almost. That's why they're still here. But there's no reason to do them
                     // in speed-targeted imports.
                     if (!configSpeedFlag) {
 
                         // It seems to be strange, but we really need to check whether the
                         // bones are identical too. Although it's extremely unprobable
                         // that they're not if control reaches here, we need to deal
                         // with unprobable cases, too. It could still be that there are
                         // equal shapes which are deformed differently.
                         if (!CompareBones(orig,inst))
                             continue;
 
                         // For completeness ... compare even the index buffers for equality
                         // face order & winding order doesn't care. Input data is in verbose format.
                         std::unique_ptr<unsigned int[]> ftbl_orig(new unsigned int[orig->mNumVertices]);
                         std::unique_ptr<unsigned int[]> ftbl_inst(new unsigned int[orig->mNumVertices]);
 
                         for (unsigned int tt = 0; tt < orig->mNumFaces;++tt) {
                             aiFace& f = orig->mFaces[tt];
                             for (unsigned int nn = 0; nn < f.mNumIndices;++nn)
                                 ftbl_orig[f.mIndices[nn]] = tt;
 
                             aiFace& f2 = inst->mFaces[tt];
                             for (unsigned int nn = 0; nn < f2.mNumIndices;++nn)
                                 ftbl_inst[f2.mIndices[nn]] = tt;
                         }
                         if (0 != ::memcmp(ftbl_inst.get(),ftbl_orig.get(),orig->mNumVertices*sizeof(unsigned int)))
                             continue;
                     }
 
                     // We're still here. Or in other words: 'inst' is an instance of 'orig'.
                     // Place a marker in our list that we can easily update mesh indices.
                     remapping[i] = remapping[a];
 
                     // Delete the instanced mesh, we don't need it anymore
                     delete inst;
                     pScene->mMeshes[i] = nullptr;
                     break;
                 }
             }
 
             // If we didn't find a match for the current mesh: keep it
             if (pScene->mMeshes[i]) {
                 remapping[i] = numMeshesOut++;
             }
         }
         ai_assert(0 != numMeshesOut);
         if (numMeshesOut != pScene->mNumMeshes) {
 
             // Collapse the meshes array by removing all nullptr entries
             for (unsigned int real = 0, i = 0; real < numMeshesOut; ++i) {
                 if (pScene->mMeshes[i])
                     pScene->mMeshes[real++] = pScene->mMeshes[i];
             }
 
             // And update the node graph with our nice lookup table
             UpdateMeshIndices(pScene->mRootNode,remapping.get());
 
             // write to log
             if (!DefaultLogger::isNullLogger()) {
                 ASSIMP_LOG_INFO( "FindInstancesProcess finished. Found ", (pScene->mNumMeshes - numMeshesOut), " instances" );
             }
             pScene->mNumMeshes = numMeshesOut;
         } else {
             ASSIMP_LOG_DEBUG("FindInstancesProcess finished. No instanced meshes found");
         }
     }
 }
diff --git a/code/PostProcessing/MakeVerboseFormat.h b/code/PostProcessing/MakeVerboseFormat.h
index c1db76dca..4304a3afa 100644
--- a/code/PostProcessing/MakeVerboseFormat.h
+++ b/code/PostProcessing/MakeVerboseFormat.h
@@ -97,8 +97,8 @@ public:
 public:
 
     // -------------------------------------------------------------------
     /** Checks whether the scene is already in verbose format.
-    * @param pScene The data to check. 
+    * @param pScene The data to check.
     * @return true if the scene is already in verbose format. */
     static bool IsVerboseFormat(const aiScene* pScene);
 
diff --git a/code/PostProcessing/RemoveRedundantMaterials.cpp b/code/PostProcessing/RemoveRedundantMaterials.cpp
index c252f37a5..36745fb1d 100644
--- a/code/PostProcessing/RemoveRedundantMaterials.cpp
+++ b/code/PostProcessing/RemoveRedundantMaterials.cpp
@@ -86,136 +86,136 @@ void RemoveRedundantMatsProcess::SetupProperties(const Importer* pImp)
 // ------------------------------------------------------------------------------------------------
 // Executes the post processing step on the given imported data.
 void RemoveRedundantMatsProcess::Execute( aiScene* pScene)
 {
     ASSIMP_LOG_DEBUG("RemoveRedundantMatsProcess begin");
 
     unsigned int redundantRemoved = 0, unreferencedRemoved = 0;
     if (pScene->mNumMaterials)
     {
         // Find out which materials are referenced by meshes
         std::vector<bool> abReferenced(pScene->mNumMaterials,false);
         for (unsigned int i = 0;i < pScene->mNumMeshes;++i)
             abReferenced[pScene->mMeshes[i]->mMaterialIndex] = true;
 
         // If a list of materials to be excluded was given, match the list with
         // our imported materials and 'salt' all positive matches to ensure that
         // we get unique hashes later.
         if (mConfigFixedMaterials.length()) {
 
             std::list<std::string> strings;
             ConvertListToStrings(mConfigFixedMaterials,strings);
 
             for (unsigned int i = 0; i < pScene->mNumMaterials;++i) {
                 aiMaterial* mat = pScene->mMaterials[i];
 
                 aiString name;
                 mat->Get(AI_MATKEY_NAME,name);
 
                 if (name.length) {
                     std::list<std::string>::const_iterator it = std::find(strings.begin(), strings.end(), name.data);
                     if (it != strings.end()) {
 
                         // Our brilliant 'salt': A single material property with ~ as first
                         // character to mark it as internal and temporary.
                         const int dummy = 1;
                         ((aiMaterial*)mat)->AddProperty(&dummy,1,"~RRM.UniqueMaterial",0,0);
 
                         // Keep this material even if no mesh references it
                         abReferenced[i] = true;
                         ASSIMP_LOG_VERBOSE_DEBUG( "Found positive match in exclusion list: \'", name.data, "\'");
                     }
                 }
             }
         }
 
         // TODO: re-implement this algorithm to work in-place
         unsigned int *aiMappingTable = new unsigned int[pScene->mNumMaterials];
         for ( unsigned int i=0; i<pScene->mNumMaterials; i++ ) {
             aiMappingTable[ i ] = 0;
         }
         unsigned int iNewNum = 0;
 
         // Iterate through all materials and calculate a hash for them
         // store all hashes in a list and so a quick search whether
         // we do already have a specific hash. This allows us to
         // determine which materials are identical.
         uint32_t *aiHashes = new uint32_t[ pScene->mNumMaterials ];;
         for (unsigned int i = 0; i < pScene->mNumMaterials;++i)
         {
             // No mesh is referencing this material, remove it.
             if (!abReferenced[i]) {
                 ++unreferencedRemoved;
                 delete pScene->mMaterials[i];
                 pScene->mMaterials[i] = nullptr;
                 continue;
             }
 
             // Check all previously mapped materials for a matching hash.
             // On a match we can delete this material and just make it ref to the same index.
             uint32_t me = aiHashes[i] = ComputeMaterialHash(pScene->mMaterials[i]);
             for (unsigned int a = 0; a < i;++a)
             {
                 if (abReferenced[a] && me == aiHashes[a]) {
                     ++redundantRemoved;
                     me = 0;
                     aiMappingTable[i] = aiMappingTable[a];
                     delete pScene->mMaterials[i];
                     pScene->mMaterials[i] = nullptr;
                     break;
                 }
             }
             // This is a new material that is referenced, add to the map.
             if (me) {
                 aiMappingTable[i] = iNewNum++;
             }
         }
         // If the new material count differs from the original,
         // we need to rebuild the material list and remap mesh material indexes.
         if (iNewNum != pScene->mNumMaterials) {
             ai_assert(iNewNum > 0);
             aiMaterial** ppcMaterials = new aiMaterial*[iNewNum];
             ::memset(ppcMaterials,0,sizeof(void*)*iNewNum);
             for (unsigned int p = 0; p < pScene->mNumMaterials;++p)
             {
                 // if the material is not referenced ... remove it
                 if (!abReferenced[p]) {
                     continue;
                 }
 
                 // generate new names for modified materials that had no names
                 const unsigned int idx = aiMappingTable[p];
                 if (ppcMaterials[idx]) {
                     aiString sz;
                     if( ppcMaterials[idx]->Get(AI_MATKEY_NAME, sz) != AI_SUCCESS ) {
                         sz.length = ::ai_snprintf(sz.data,MAXLEN,"JoinedMaterial_#%u",p);
                         ((aiMaterial*)ppcMaterials[idx])->AddProperty(&sz,AI_MATKEY_NAME);
                     }
                 } else {
                     ppcMaterials[idx] = pScene->mMaterials[p];
                 }
             }
             // update all material indices
             for (unsigned int p = 0; p < pScene->mNumMeshes;++p) {
                 aiMesh* mesh = pScene->mMeshes[p];
                 ai_assert(nullptr != mesh);
                 mesh->mMaterialIndex = aiMappingTable[mesh->mMaterialIndex];
             }
             // delete the old material list
             delete[] pScene->mMaterials;
             pScene->mMaterials = ppcMaterials;
             pScene->mNumMaterials = iNewNum;
         }
         // delete temporary storage
         delete[] aiHashes;
         delete[] aiMappingTable;
     }
     if (redundantRemoved == 0 && unreferencedRemoved == 0)
     {
         ASSIMP_LOG_DEBUG("RemoveRedundantMatsProcess finished ");
     }
     else
     {
-        ASSIMP_LOG_INFO("RemoveRedundantMatsProcess finished. Removed ", redundantRemoved, " redundant and ", 
+        ASSIMP_LOG_INFO("RemoveRedundantMatsProcess finished. Removed ", redundantRemoved, " redundant and ",
             unreferencedRemoved, " unused materials.");
     }
 }
diff --git a/code/PostProcessing/ScaleProcess.cpp b/code/PostProcessing/ScaleProcess.cpp
index 0a3e29c42..63dd0443d 100644
--- a/code/PostProcessing/ScaleProcess.cpp
+++ b/code/PostProcessing/ScaleProcess.cpp
@@ -71,11 +71,11 @@ bool ScaleProcess::IsActive( unsigned int pFlags ) const {
 void ScaleProcess::SetupProperties( const Importer* pImp ) {
     // User scaling
     mScale = pImp->GetPropertyFloat( AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY, 1.0f );
 
     // File scaling * Application Scaling
     float importerScale = pImp->GetPropertyFloat( AI_CONFIG_APP_SCALE_KEY, 1.0f );
 
-    // apply scale to the scale 
+    // apply scale to the scale
     // helps prevent bugs with backward compatibility for anyone using normal scaling.
     mScale *= importerScale;
 }
@@ -83,126 +83,126 @@ void ScaleProcess::SetupProperties( const Importer* pImp ) {
 void ScaleProcess::Execute( aiScene* pScene ) {
     if(mScale == 1.0f)  {
         return; // nothing to scale
     }
-    
+
     ai_assert( mScale != 0 );
     ai_assert( nullptr != pScene );
     ai_assert( nullptr != pScene->mRootNode );
 
     if ( nullptr == pScene ) {
         return;
     }
 
     if ( nullptr == pScene->mRootNode ) {
         return;
     }
-    
+
     // Process animations and update position transform to new unit system
     for( unsigned int animationID = 0; animationID < pScene->mNumAnimations; animationID++ )
     {
         aiAnimation* animation = pScene->mAnimations[animationID];
 
         for( unsigned int animationChannel = 0; animationChannel < animation->mNumChannels; animationChannel++)
         {
             aiNodeAnim* anim = animation->mChannels[animationChannel];
-            
+
             for( unsigned int posKey = 0; posKey < anim->mNumPositionKeys; posKey++)
             {
                 aiVectorKey& vectorKey = anim->mPositionKeys[posKey];
                 vectorKey.mValue *= mScale;
             }
         }
     }
 
     for( unsigned int meshID = 0; meshID < pScene->mNumMeshes; meshID++)
     {
-        aiMesh *mesh = pScene->mMeshes[meshID]; 
-        
+        aiMesh *mesh = pScene->mMeshes[meshID];
+
         // Reconstruct mesh vertexes to the new unit system
         for( unsigned int vertexID = 0; vertexID < mesh->mNumVertices; vertexID++)
         {
             aiVector3D& vertex = mesh->mVertices[vertexID];
             vertex *= mScale;
         }
 
 
         // bone placement / scaling
         for( unsigned int boneID = 0; boneID < mesh->mNumBones; boneID++)
         {
-            // Reconstruct matrix by transform rather than by scale 
+            // Reconstruct matrix by transform rather than by scale
             // This prevent scale values being changed which can
-            // be meaningful in some cases 
+            // be meaningful in some cases
             // like when you want the modeller to see 1:1 compatibility.
             aiBone* bone = mesh->mBones[boneID];
 
             aiVector3D pos, scale;
             aiQuaternion rotation;
 
             bone->mOffsetMatrix.Decompose( scale, rotation, pos);
-            
+
             aiMatrix4x4 translation;
             aiMatrix4x4::Translation( pos * mScale, translation );
-            
+
             aiMatrix4x4 scaling;
             aiMatrix4x4::Scaling( aiVector3D(scale), scaling );
 
             aiMatrix4x4 RotMatrix = aiMatrix4x4 (rotation.GetMatrix());
 
             bone->mOffsetMatrix = translation * RotMatrix * scaling;
         }
 
 
         // animation mesh processing
         // convert by position rather than scale.
         for( unsigned int animMeshID = 0; animMeshID < mesh->mNumAnimMeshes; animMeshID++)
         {
             aiAnimMesh * animMesh = mesh->mAnimMeshes[animMeshID];
-            
+
             for( unsigned int vertexID = 0; vertexID < animMesh->mNumVertices; vertexID++)
             {
                 aiVector3D& vertex = animMesh->mVertices[vertexID];
                 vertex *= mScale;
             }
         }
     }
 
     traverseNodes( pScene->mRootNode );
 }
 
-void ScaleProcess::traverseNodes( aiNode *node, unsigned int nested_node_id ) {    
+void ScaleProcess::traverseNodes( aiNode *node, unsigned int nested_node_id ) {
     applyScaling( node );
 
     for( size_t i = 0; i < node->mNumChildren; i++)
     {
         // recurse into the tree until we are done!
-        traverseNodes( node->mChildren[i], nested_node_id+1 ); 
+        traverseNodes( node->mChildren[i], nested_node_id+1 );
     }
 }
 
 void ScaleProcess::applyScaling( aiNode *currentNode ) {
     if ( nullptr != currentNode ) {
-        // Reconstruct matrix by transform rather than by scale 
+        // Reconstruct matrix by transform rather than by scale
         // This prevent scale values being changed which can
-        // be meaningful in some cases 
-        // like when you want the modeller to 
+        // be meaningful in some cases
+        // like when you want the modeller to
         // see 1:1 compatibility.
-        
+
         aiVector3D pos, scale;
         aiQuaternion rotation;
         currentNode->mTransformation.Decompose( scale, rotation, pos);
-        
+
         aiMatrix4x4 translation;
         aiMatrix4x4::Translation( pos * mScale, translation );
-        
+
         aiMatrix4x4 scaling;
 
         // note: we do not use mScale here, this is on purpose.
         aiMatrix4x4::Scaling( scale, scaling );
 
         aiMatrix4x4 RotMatrix = aiMatrix4x4 (rotation.GetMatrix());
 
         currentNode->mTransformation = translation * RotMatrix * scaling;
     }
 }
 
 } // Namespace Assimp
diff --git a/code/PostProcessing/ScaleProcess.h b/code/PostProcessing/ScaleProcess.h
index d88490b1c..4dc7e3559 100644
--- a/code/PostProcessing/ScaleProcess.h
+++ b/code/PostProcessing/ScaleProcess.h
@@ -53,10 +53,10 @@ struct aiNode;
 namespace Assimp {
 
 // ---------------------------------------------------------------------------
 /** ScaleProcess: Class to rescale the whole model.
  * Now rescales animations, bones, and blend shapes properly.
- * Please note this will not write to 'scale' transform it will rewrite mesh 
- * and matrixes so that your scale values 
+ * Please note this will not write to 'scale' transform it will rewrite mesh
+ * and matrixes so that your scale values
  * from your model package are preserved, so this is completely intentional
  * bugs should be reported as soon as they are found.
 */
diff --git a/code/PostProcessing/SplitByBoneCountProcess.cpp b/code/PostProcessing/SplitByBoneCountProcess.cpp
index 2613d8561..ed5b9411e 100644
--- a/code/PostProcessing/SplitByBoneCountProcess.cpp
+++ b/code/PostProcessing/SplitByBoneCountProcess.cpp
@@ -157,299 +157,299 @@ void SplitByBoneCountProcess::Execute( aiScene* pScene)
 // ------------------------------------------------------------------------------------------------
 // Splits the given mesh by bone count.
 void SplitByBoneCountProcess::SplitMesh( const aiMesh* pMesh, std::vector<aiMesh*>& poNewMeshes) const
 {
     // skip if not necessary
     if( pMesh->mNumBones <= mMaxBoneCount )
     {
         return;
     }
 
     // necessary optimisation: build a list of all affecting bones for each vertex
     // TODO: (thom) maybe add a custom allocator here to avoid allocating tens of thousands of small arrays
     typedef std::pair<unsigned int, float> BoneWeight;
     std::vector< std::vector<BoneWeight> > vertexBones( pMesh->mNumVertices);
     for( unsigned int a = 0; a < pMesh->mNumBones; ++a)
     {
         const aiBone* bone = pMesh->mBones[a];
         for( unsigned int b = 0; b < bone->mNumWeights; ++b)
         {
           if (bone->mWeights[b].mWeight > 0.0f)
           {
             int vertexId = bone->mWeights[b].mVertexId;
             vertexBones[vertexId].push_back( BoneWeight( a, bone->mWeights[b].mWeight));
             if (vertexBones[vertexId].size() > mMaxBoneCount)
             {
               throw DeadlyImportError("SplitByBoneCountProcess: Single face requires more bones than specified max bone count!");
             }
           }
         }
     }
 
     unsigned int numFacesHandled = 0;
     std::vector<bool> isFaceHandled( pMesh->mNumFaces, false);
     while( numFacesHandled < pMesh->mNumFaces )
     {
         // which bones are used in the current submesh
         unsigned int numBones = 0;
         std::vector<bool> isBoneUsed( pMesh->mNumBones, false);
         // indices of the faces which are going to go into this submesh
         std::vector<unsigned int> subMeshFaces;
         subMeshFaces.reserve( pMesh->mNumFaces);
         // accumulated vertex count of all the faces in this submesh
         unsigned int numSubMeshVertices = 0;
 
         // add faces to the new submesh as long as all bones affecting the faces' vertices fit in the limit
         for( unsigned int a = 0; a < pMesh->mNumFaces; ++a)
         {
             // skip if the face is already stored in a submesh
             if( isFaceHandled[a] )
             {
                 continue;
             }
             // a small local set of new bones for the current face. State of all used bones for that face
             // can only be updated AFTER the face is completely analysed. Thanks to imre for the fix.
             std::set<unsigned int> newBonesAtCurrentFace;
-          
+
             const aiFace& face = pMesh->mFaces[a];
             // check every vertex if its bones would still fit into the current submesh
             for( unsigned int b = 0; b < face.mNumIndices; ++b )
             {
               const std::vector<BoneWeight>& vb = vertexBones[face.mIndices[b]];
               for( unsigned int c = 0; c < vb.size(); ++c)
               {
                 unsigned int boneIndex = vb[c].first;
                 if( !isBoneUsed[boneIndex] )
                 {
                   newBonesAtCurrentFace.insert(boneIndex);
-                }   
+                }
               }
             }
 
             // leave out the face if the new bones required for this face don't fit the bone count limit anymore
             if( numBones + newBonesAtCurrentFace.size() > mMaxBoneCount )
             {
                 continue;
             }
 
             // mark all new bones as necessary
             for (std::set<unsigned int>::iterator it = newBonesAtCurrentFace.begin(); it != newBonesAtCurrentFace.end(); ++it)
             {
               if (!isBoneUsed[*it])
               {
                 isBoneUsed[*it] = true;
                 numBones++;
               }
             }
 
             // store the face index and the vertex count
             subMeshFaces.push_back( a);
             numSubMeshVertices += face.mNumIndices;
 
             // remember that this face is handled
             isFaceHandled[a] = true;
             numFacesHandled++;
         }
 
         // create a new mesh to hold this subset of the source mesh
         aiMesh* newMesh = new aiMesh;
         if( pMesh->mName.length > 0 )
         {
             newMesh->mName.Set( format() << pMesh->mName.data << "_sub" << poNewMeshes.size());
         }
         newMesh->mMaterialIndex = pMesh->mMaterialIndex;
         newMesh->mPrimitiveTypes = pMesh->mPrimitiveTypes;
         poNewMeshes.push_back( newMesh);
 
         // create all the arrays for this mesh if the old mesh contained them
         newMesh->mNumVertices = numSubMeshVertices;
         newMesh->mNumFaces = static_cast<unsigned int>(subMeshFaces.size());
         newMesh->mVertices = new aiVector3D[newMesh->mNumVertices];
         if( pMesh->HasNormals() )
         {
             newMesh->mNormals = new aiVector3D[newMesh->mNumVertices];
         }
         if( pMesh->HasTangentsAndBitangents() )
         {
             newMesh->mTangents = new aiVector3D[newMesh->mNumVertices];
             newMesh->mBitangents = new aiVector3D[newMesh->mNumVertices];
         }
         for( unsigned int a = 0; a < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++a )
         {
             if( pMesh->HasTextureCoords( a) )
             {
                 newMesh->mTextureCoords[a] = new aiVector3D[newMesh->mNumVertices];
             }
             newMesh->mNumUVComponents[a] = pMesh->mNumUVComponents[a];
         }
         for( unsigned int a = 0; a < AI_MAX_NUMBER_OF_COLOR_SETS; ++a )
         {
             if( pMesh->HasVertexColors( a) )
             {
                 newMesh->mColors[a] = new aiColor4D[newMesh->mNumVertices];
             }
         }
 
         // and copy over the data, generating faces with linear indices along the way
         newMesh->mFaces = new aiFace[subMeshFaces.size()];
         unsigned int nvi = 0; // next vertex index
         std::vector<unsigned int> previousVertexIndices( numSubMeshVertices, std::numeric_limits<unsigned int>::max()); // per new vertex: its index in the source mesh
         for( unsigned int a = 0; a < subMeshFaces.size(); ++a )
         {
             const aiFace& srcFace = pMesh->mFaces[subMeshFaces[a]];
             aiFace& dstFace = newMesh->mFaces[a];
             dstFace.mNumIndices = srcFace.mNumIndices;
             dstFace.mIndices = new unsigned int[dstFace.mNumIndices];
 
             // accumulate linearly all the vertices of the source face
             for( unsigned int b = 0; b < dstFace.mNumIndices; ++b )
             {
                 unsigned int srcIndex = srcFace.mIndices[b];
                 dstFace.mIndices[b] = nvi;
                 previousVertexIndices[nvi] = srcIndex;
 
                 newMesh->mVertices[nvi] = pMesh->mVertices[srcIndex];
                 if( pMesh->HasNormals() )
                 {
                     newMesh->mNormals[nvi] = pMesh->mNormals[srcIndex];
                 }
                 if( pMesh->HasTangentsAndBitangents() )
                 {
                     newMesh->mTangents[nvi] = pMesh->mTangents[srcIndex];
                     newMesh->mBitangents[nvi] = pMesh->mBitangents[srcIndex];
                 }
                 for( unsigned int c = 0; c < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++c )
                 {
                     if( pMesh->HasTextureCoords( c) )
                     {
                         newMesh->mTextureCoords[c][nvi] = pMesh->mTextureCoords[c][srcIndex];
                     }
                 }
                 for( unsigned int c = 0; c < AI_MAX_NUMBER_OF_COLOR_SETS; ++c )
                 {
                     if( pMesh->HasVertexColors( c) )
                     {
                         newMesh->mColors[c][nvi] = pMesh->mColors[c][srcIndex];
                     }
                 }
 
                 nvi++;
             }
         }
 
         ai_assert( nvi == numSubMeshVertices );
 
         // Create the bones for the new submesh: first create the bone array
         newMesh->mNumBones = 0;
         newMesh->mBones = new aiBone*[numBones];
 
         std::vector<unsigned int> mappedBoneIndex( pMesh->mNumBones, std::numeric_limits<unsigned int>::max());
         for( unsigned int a = 0; a < pMesh->mNumBones; ++a )
         {
             if( !isBoneUsed[a] )
             {
                 continue;
             }
 
             // create the new bone
             const aiBone* srcBone = pMesh->mBones[a];
             aiBone* dstBone = new aiBone;
             mappedBoneIndex[a] = newMesh->mNumBones;
             newMesh->mBones[newMesh->mNumBones++] = dstBone;
             dstBone->mName = srcBone->mName;
             dstBone->mOffsetMatrix = srcBone->mOffsetMatrix;
             dstBone->mNumWeights = 0;
         }
 
         ai_assert( newMesh->mNumBones == numBones );
 
         // iterate over all new vertices and count which bones affected its old vertex in the source mesh
         for( unsigned int a = 0; a < numSubMeshVertices; ++a )
         {
             unsigned int oldIndex = previousVertexIndices[a];
             const std::vector<BoneWeight>& bonesOnThisVertex = vertexBones[oldIndex];
 
             for( unsigned int b = 0; b < bonesOnThisVertex.size(); ++b )
             {
                 unsigned int newBoneIndex = mappedBoneIndex[ bonesOnThisVertex[b].first ];
                 if( newBoneIndex != std::numeric_limits<unsigned int>::max() )
                 {
                     newMesh->mBones[newBoneIndex]->mNumWeights++;
                 }
             }
         }
 
         // allocate all bone weight arrays accordingly
         for( unsigned int a = 0; a < newMesh->mNumBones; ++a )
         {
             aiBone* bone = newMesh->mBones[a];
             ai_assert( bone->mNumWeights > 0 );
             bone->mWeights = new aiVertexWeight[bone->mNumWeights];
             bone->mNumWeights = 0; // for counting up in the next step
         }
 
         // now copy all the bone vertex weights for all the vertices which made it into the new submesh
         for( unsigned int a = 0; a < numSubMeshVertices; ++a)
         {
             // find the source vertex for it in the source mesh
             unsigned int previousIndex = previousVertexIndices[a];
             // these bones were affecting it
             const std::vector<BoneWeight>& bonesOnThisVertex = vertexBones[previousIndex];
             // all of the bones affecting it should be present in the new submesh, or else
             // the face it comprises shouldn't be present
             for( unsigned int b = 0; b < bonesOnThisVertex.size(); ++b)
             {
                 unsigned int newBoneIndex = mappedBoneIndex[ bonesOnThisVertex[b].first ];
                 ai_assert( newBoneIndex != std::numeric_limits<unsigned int>::max() );
                 aiVertexWeight* dstWeight = newMesh->mBones[newBoneIndex]->mWeights + newMesh->mBones[newBoneIndex]->mNumWeights;
                 newMesh->mBones[newBoneIndex]->mNumWeights++;
 
                 dstWeight->mVertexId = a;
                 dstWeight->mWeight = bonesOnThisVertex[b].second;
             }
         }
 
         // ... and copy all the morph targets for all the vertices which made it into the new submesh
         if (pMesh->mNumAnimMeshes > 0) {
             newMesh->mNumAnimMeshes = pMesh->mNumAnimMeshes;
             newMesh->mAnimMeshes = new aiAnimMesh*[newMesh->mNumAnimMeshes];
-            
+
             for (unsigned int morphIdx = 0; morphIdx < newMesh->mNumAnimMeshes; ++morphIdx) {
                 aiAnimMesh* origTarget = pMesh->mAnimMeshes[morphIdx];
                 aiAnimMesh* newTarget = new aiAnimMesh;
                 newTarget->mName = origTarget->mName;
                 newTarget->mWeight = origTarget->mWeight;
                 newTarget->mNumVertices = numSubMeshVertices;
                 newTarget->mVertices = new aiVector3D[numSubMeshVertices];
                 newMesh->mAnimMeshes[morphIdx] = newTarget;
-                
+
                 if (origTarget->HasNormals()) {
                     newTarget->mNormals = new aiVector3D[numSubMeshVertices];
                 }
-                
+
                 if (origTarget->HasTangentsAndBitangents()) {
                     newTarget->mTangents = new aiVector3D[numSubMeshVertices];
                     newTarget->mBitangents = new aiVector3D[numSubMeshVertices];
                 }
-                
+
                 for( unsigned int vi = 0; vi < numSubMeshVertices; ++vi) {
                     // find the source vertex for it in the source mesh
                     unsigned int previousIndex = previousVertexIndices[vi];
                     newTarget->mVertices[vi] = origTarget->mVertices[previousIndex];
 
                     if (newTarget->HasNormals()) {
                         newTarget->mNormals[vi] = origTarget->mNormals[previousIndex];
                     }
                     if (newTarget->HasTangentsAndBitangents()) {
                         newTarget->mTangents[vi] = origTarget->mTangents[previousIndex];
                         newTarget->mBitangents[vi] = origTarget->mBitangents[previousIndex];
                     }
                 }
             }
         }
 
         // I have the strange feeling that this will break apart at some point in time...
     }
 }
 
 // ------------------------------------------------------------------------------------------------
 // Recursively updates the node's mesh list to account for the changed mesh list
diff --git a/code/PostProcessing/SplitLargeMeshes.cpp b/code/PostProcessing/SplitLargeMeshes.cpp
index ed680cf7f..cb614edaa 100644
--- a/code/PostProcessing/SplitLargeMeshes.cpp
+++ b/code/PostProcessing/SplitLargeMeshes.cpp
@@ -37,13 +37,13 @@ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 ----------------------------------------------------------------------
 */
 
-/** 
+/**
  *  @file Implementation of the SplitLargeMeshes postprocessing step
  */
 
 // internal headers of the post-processing framework
 #include "SplitLargeMeshes.h"
 #include "ProcessHelper.h"
@@ -345,43 +345,43 @@ bool SplitLargeMeshesProcess_Vertex::IsActive( unsigned int pFlags) const {
 // ------------------------------------------------------------------------------------------------
 // Executes the post processing step on the given imported data.
 void SplitLargeMeshesProcess_Vertex::Execute( aiScene* pScene) {
     if (0xffffffff == this->LIMIT || nullptr == pScene ) {
         return;
     }
 
     ASSIMP_LOG_DEBUG("SplitLargeMeshesProcess_Vertex begin");
 
     std::vector<std::pair<aiMesh*, unsigned int> > avList;
 
-    //Check for point cloud first, 
+    //Check for point cloud first,
     //Do not process point cloud, splitMesh works only with faces data
     for (unsigned int a = 0; a < pScene->mNumMeshes; a++) {
         if ( pScene->mMeshes[a]->mPrimitiveTypes == aiPrimitiveType_POINT ) {
             return;
         }
     }
 
     for( unsigned int a = 0; a < pScene->mNumMeshes; ++a ) {
         this->SplitMesh(a, pScene->mMeshes[a], avList);
     }
 
     if (avList.size() != pScene->mNumMeshes) {
         // it seems something has been split. rebuild the mesh list
         delete[] pScene->mMeshes;
         pScene->mNumMeshes = (unsigned int)avList.size();
         pScene->mMeshes = new aiMesh*[avList.size()];
 
         for (unsigned int i = 0; i < avList.size();++i) {
             pScene->mMeshes[i] = avList[i].first;
         }
 
         // now we need to update all nodes
         SplitLargeMeshesProcess_Triangle::UpdateNode(pScene->mRootNode,avList);
         ASSIMP_LOG_INFO("SplitLargeMeshesProcess_Vertex finished. Meshes have been split");
     } else {
         ASSIMP_LOG_DEBUG("SplitLargeMeshesProcess_Vertex finished. There was nothing to do");
     }
 }
 
 // ------------------------------------------------------------------------------------------------
 // Setup properties
diff --git a/code/PostProcessing/TextureTransform.cpp b/code/PostProcessing/TextureTransform.cpp
index 681b047c0..74b00d92c 100644
--- a/code/PostProcessing/TextureTransform.cpp
+++ b/code/PostProcessing/TextureTransform.cpp
@@ -220,348 +220,348 @@ inline const char* MappingModeToChar(aiTextureMapMode map)
 // ------------------------------------------------------------------------------------------------
 void TextureTransformStep::Execute( aiScene* pScene)
 {
     ASSIMP_LOG_DEBUG("TransformUVCoordsProcess begin");
 
 
     /*  We build a per-mesh list of texture transformations we'll need
      *  to apply. To achieve this, we iterate through all materials,
      *  find all textures and get their transformations and UV indices.
      *  Then we search for all meshes using this material.
      */
     typedef std::list<STransformVecInfo> MeshTrafoList;
     std::vector<MeshTrafoList> meshLists(pScene->mNumMeshes);
 
     for (unsigned int i = 0; i < pScene->mNumMaterials;++i) {
 
         aiMaterial* mat = pScene->mMaterials[i];
         for (unsigned int a = 0; a < mat->mNumProperties;++a)   {
 
             aiMaterialProperty* prop = mat->mProperties[a];
             if (!::strcmp( prop->mKey.data, "$tex.file"))   {
                 STransformVecInfo info;
 
                 // Setup a shortcut structure to allow for a fast updating
                 // of the UV index later
                 TTUpdateInfo update;
                 update.mat = (aiMaterial*) mat;
                 update.semantic = prop->mSemantic;
                 update.index = prop->mIndex;
 
                 // Get textured properties and transform
                 for (unsigned int a2 = 0; a2 < mat->mNumProperties;++a2)  {
                     aiMaterialProperty* prop2 = mat->mProperties[a2];
                     if (prop2->mSemantic != prop->mSemantic || prop2->mIndex != prop->mIndex) {
                         continue;
                     }
 
                     if ( !::strcmp( prop2->mKey.data, "$tex.uvwsrc")) {
                         info.uvIndex = *((int*)prop2->mData);
 
                         // Store a direct pointer for later use
                         update.directShortcut = (unsigned int*) prop2->mData;
                     }
 
                     else if ( !::strcmp( prop2->mKey.data, "$tex.mapmodeu")) {
                         info.mapU = *((aiTextureMapMode*)prop2->mData);
                     }
                     else if ( !::strcmp( prop2->mKey.data, "$tex.mapmodev")) {
                         info.mapV = *((aiTextureMapMode*)prop2->mData);
                     }
                     else if ( !::strcmp( prop2->mKey.data, "$tex.uvtrafo"))  {
                         // ValidateDS should check this
                         ai_assert(prop2->mDataLength >= 20);
                         ::memcpy(&info.mTranslation.x,prop2->mData,sizeof(float)*5);
 
                         // Directly remove this property from the list
                         mat->mNumProperties--;
                         for (unsigned int a3 = a2; a3 < mat->mNumProperties;++a3) {
                             mat->mProperties[a3] = mat->mProperties[a3+1];
                         }
 
                         delete prop2;
 
                         // Warn: could be an underflow, but this does not invoke undefined behaviour
                         --a2;
                     }
                 }
 
                 // Find out which transformations are to be evaluated
                 if (!(configFlags & AI_UVTRAFO_ROTATION)) {
                     info.mRotation = 0.f;
                 }
                 if (!(configFlags & AI_UVTRAFO_SCALING)) {
                     info.mScaling = aiVector2D(1.f,1.f);
                 }
                 if (!(configFlags & AI_UVTRAFO_TRANSLATION)) {
                     info.mTranslation = aiVector2D(0.f,0.f);
                 }
 
                 // Do some preprocessing
                 PreProcessUVTransform(info);
                 info.uvIndex = std::min(info.uvIndex,AI_MAX_NUMBER_OF_TEXTURECOORDS -1u);
 
                 // Find out whether this material is used by more than
                 // one mesh. This will make our task much, much more difficult!
                 unsigned int cnt = 0;
                 for (unsigned int n = 0; n < pScene->mNumMeshes;++n)    {
                     if (pScene->mMeshes[n]->mMaterialIndex == i)
                         ++cnt;
                 }
 
                 if (!cnt)
                     continue;
                 else if (1 != cnt)  {
                     // This material is referenced by more than one mesh!
                     // So we need to make sure the UV index for the texture
                     // is identical for each of it ...
                     info.lockedPos = AI_TT_UV_IDX_LOCK_TBD;
                 }
 
                 // Get all corresponding meshes
                 for (unsigned int n = 0; n < pScene->mNumMeshes;++n)    {
                     aiMesh* mesh = pScene->mMeshes[n];
                     if (mesh->mMaterialIndex != i || !mesh->mTextureCoords[0])
                         continue;
 
                     unsigned int uv = info.uvIndex;
                     if (!mesh->mTextureCoords[uv])  {
                         // If the requested UV index is not available, take the first one instead.
                         uv = 0;
                     }
 
                     if (mesh->mNumUVComponents[info.uvIndex] >= 3){
                         ASSIMP_LOG_WARN("UV transformations on 3D mapping channels are not supported");
                         continue;
                     }
 
                     MeshTrafoList::iterator it;
 
                     // Check whether we have this transform setup already
                     for (it = meshLists[n].begin();it != meshLists[n].end(); ++it)  {
 
                         if ((*it) == info && (*it).uvIndex == uv)   {
                             (*it).updateList.push_back(update);
                             break;
                         }
                     }
 
                     if (it == meshLists[n].end())   {
                         meshLists[n].push_back(info);
                         meshLists[n].back().uvIndex = uv;
                         meshLists[n].back().updateList.push_back(update);
                     }
                 }
             }
         }
     }
 
     char buffer[1024]; // should be sufficiently large
     unsigned int outChannels = 0, inChannels = 0, transformedChannels = 0;
 
     // Now process all meshes. Important: we don't remove unreferenced UV channels.
     // This is a job for the RemoveUnreferencedData-Step.
     for (unsigned int q = 0; q < pScene->mNumMeshes;++q)    {
 
         aiMesh* mesh = pScene->mMeshes[q];
         MeshTrafoList& trafo =  meshLists[q];
 
         inChannels += mesh->GetNumUVChannels();
 
         if (!mesh->mTextureCoords[0] || trafo.empty() ||  (trafo.size() == 1 && trafo.begin()->IsUntransformed())) {
             outChannels += mesh->GetNumUVChannels();
             continue;
         }
 
         // Move untransformed UV channels to the first position in the list ....
         // except if we need a new locked index which should be as small as possible
         bool veto = false, need = false;
         unsigned int cnt = 0;
         unsigned int untransformed = 0;
 
         MeshTrafoList::iterator it,it2;
         for (it = trafo.begin();it != trafo.end(); ++it,++cnt)  {
 
             if (!(*it).IsUntransformed()) {
                 need = true;
             }
 
             if ((*it).lockedPos == AI_TT_UV_IDX_LOCK_TBD)   {
                 // Lock this index and make sure it won't be changed
                 (*it).lockedPos = cnt;
                 veto = true;
                 continue;
             }
 
             if (!veto && it != trafo.begin() && (*it).IsUntransformed())    {
                 for (it2 = trafo.begin();it2 != it; ++it2) {
                     if (!(*it2).IsUntransformed())
                         break;
                 }
                 trafo.insert(it2,*it);
                 trafo.erase(it);
                 break;
             }
         }
         if (!need)
             continue;
 
         // Find all that are not at their 'locked' position and move them to it.
         // Conflicts are possible but quite unlikely.
         cnt = 0;
         for (it = trafo.begin();it != trafo.end(); ++it,++cnt) {
             if ((*it).lockedPos != AI_TT_UV_IDX_LOCK_NONE && (*it).lockedPos != cnt) {
                 it2 = trafo.begin();unsigned int t = 0;
                 while (t != (*it).lockedPos)
                     ++it2;
 
                 if ((*it2).lockedPos != AI_TT_UV_IDX_LOCK_NONE) {
                     ASSIMP_LOG_ERROR("Channel mismatch, can't compute all transformations properly [design bug]");
                     continue;
                 }
 
                 std::swap(*it2,*it);
                 if ((*it).lockedPos == untransformed)
                     untransformed = cnt;
             }
         }
 
         // ... and add dummies for all unreferenced channels
         // at the end of the list
         bool ref[AI_MAX_NUMBER_OF_TEXTURECOORDS];
         for (unsigned int n = 0; n < AI_MAX_NUMBER_OF_TEXTURECOORDS;++n)
             ref[n] = !mesh->mTextureCoords[n];
 
         for (it = trafo.begin();it != trafo.end(); ++it)
             ref[(*it).uvIndex] = true;
 
         for (unsigned int n = 0; n < AI_MAX_NUMBER_OF_TEXTURECOORDS;++n) {
             if (ref[n])
                 continue;
             trafo.push_back(STransformVecInfo());
             trafo.back().uvIndex = n;
         }
 
         // Then check whether this list breaks the channel limit.
         // The unimportant ones are at the end of the list, so
         // it shouldn't be too worse if we remove them.
         unsigned int size = (unsigned int)trafo.size();
         if (size > AI_MAX_NUMBER_OF_TEXTURECOORDS) {
 
             if (!DefaultLogger::isNullLogger()) {
-                ASSIMP_LOG_ERROR(static_cast<unsigned int>(trafo.size()), " UV channels required but just ", 
+                ASSIMP_LOG_ERROR(static_cast<unsigned int>(trafo.size()), " UV channels required but just ",
                     AI_MAX_NUMBER_OF_TEXTURECOORDS, " available");
             }
             size = AI_MAX_NUMBER_OF_TEXTURECOORDS;
         }
 
 
         aiVector3D* old[AI_MAX_NUMBER_OF_TEXTURECOORDS];
         for (unsigned int n = 0; n < AI_MAX_NUMBER_OF_TEXTURECOORDS;++n)
             old[n] = mesh->mTextureCoords[n];
 
         // Now continue and generate the output channels. Channels
         // that we're not going to need later can be overridden.
         it = trafo.begin();
         for (unsigned int n = 0; n < trafo.size();++n,++it) {
 
             if (n >= size)  {
                 // Try to use an untransformed channel for all channels we threw over board
                 UpdateUVIndex((*it).updateList,untransformed);
                 continue;
             }
 
             outChannels++;
 
             // Write to the log
             if (!DefaultLogger::isNullLogger()) {
                 ::ai_snprintf(buffer,1024,"Mesh %u, channel %u: t(%.3f,%.3f), s(%.3f,%.3f), r(%.3f), %s%s",
                     q,n,
                     (*it).mTranslation.x,
                     (*it).mTranslation.y,
                     (*it).mScaling.x,
                     (*it).mScaling.y,
                     AI_RAD_TO_DEG( (*it).mRotation),
                     MappingModeToChar ((*it).mapU),
                     MappingModeToChar ((*it).mapV));
 
                 ASSIMP_LOG_INFO(buffer);
             }
 
             // Check whether we need a new buffer here
             if (mesh->mTextureCoords[n])    {
 
                 it2 = it;++it2;
                 for (unsigned int m = n+1; m < size;++m, ++it2) {
 
                     if ((*it2).uvIndex == n){
                         it2 = trafo.begin();
                         break;
                     }
                 }
                 if (it2 == trafo.begin()){
                     mesh->mTextureCoords[n] = new aiVector3D[mesh->mNumVertices];
                 }
             }
             else mesh->mTextureCoords[n] = new aiVector3D[mesh->mNumVertices];
 
             aiVector3D* src = old[(*it).uvIndex];
             aiVector3D* dest, *end;
             dest = mesh->mTextureCoords[n];
 
             ai_assert(nullptr != src);
 
             // Copy the data to the destination array
             if (dest != src)
                 ::memcpy(dest,src,sizeof(aiVector3D)*mesh->mNumVertices);
 
             end = dest + mesh->mNumVertices;
 
             // Build a transformation matrix and transform all UV coords with it
             if (!(*it).IsUntransformed()) {
                 const aiVector2D& trl = (*it).mTranslation;
                 const aiVector2D& scl = (*it).mScaling;
 
                 // fixme: simplify ..
                 ++transformedChannels;
                 aiMatrix3x3 matrix;
 
                 aiMatrix3x3 m2,m3,m4,m5;
 
                 m4.a1 = scl.x;
                 m4.b2 = scl.y;
 
                 m2.a3 = m2.b3 = 0.5f;
                 m3.a3 = m3.b3 = -0.5f;
 
                 if ((*it).mRotation > AI_TT_ROTATION_EPSILON )
                     aiMatrix3x3::RotationZ((*it).mRotation,matrix);
 
                 m5.a3 += trl.x; m5.b3 += trl.y;
                 matrix = m2 * m4 * matrix * m3 * m5;
 
                 for (src = dest; src != end; ++src) { /* manual homogenious divide */
                     src->z = 1.f;
                     *src = matrix * *src;
                     src->x /= src->z;
                     src->y /= src->z;
                     src->z = 0.f;
                 }
             }
 
             // Update all UV indices
             UpdateUVIndex((*it).updateList,n);
         }
     }
 
     // Print some detailed statistics into the log
     if (!DefaultLogger::isNullLogger()) {
 
         if (transformedChannels)    {
             ASSIMP_LOG_INFO("TransformUVCoordsProcess end: ", outChannels, " output channels (in: ", inChannels, ", modified: ", transformedChannels,")");
         } else {
             ASSIMP_LOG_DEBUG("TransformUVCoordsProcess finished");
         }
     }
 }
 
 
diff --git a/code/PostProcessing/TriangulateProcess.cpp b/code/PostProcessing/TriangulateProcess.cpp
index 0f71320b8..b7928ee59 100644
--- a/code/PostProcessing/TriangulateProcess.cpp
+++ b/code/PostProcessing/TriangulateProcess.cpp
@@ -79,83 +79,83 @@ using namespace Assimp;
 namespace {
 
     /**
      * @brief Helper struct used to simplify NGON encoding functions.
      */
     struct NGONEncoder {
         NGONEncoder() : mLastNGONFirstIndex((unsigned int)-1) {}
 
         /**
          * @brief Encode the current triangle, and make sure it is recognized as a triangle.
-         * 
+         *
          * This method will rotate indices in tri if needed in order to avoid tri to be considered
          * part of the previous ngon. This method is to be used whenever you want to emit a real triangle,
          * and make sure it is seen as a triangle.
-         * 
+         *
          * @param tri Triangle to encode.
          */
         void ngonEncodeTriangle(aiFace * tri) {
             ai_assert(tri->mNumIndices == 3);
 
             // Rotate indices in new triangle to avoid ngon encoding false ngons
             // Otherwise, the new triangle would be considered part of the previous NGON.
             if (isConsideredSameAsLastNgon(tri)) {
                 std::swap(tri->mIndices[0], tri->mIndices[2]);
                 std::swap(tri->mIndices[1], tri->mIndices[2]);
             }
 
             mLastNGONFirstIndex = tri->mIndices[0];
         }
 
         /**
          * @brief Encode a quad (2 triangles) in ngon encoding, and make sure they are seen as a single ngon.
-         * 
+         *
          * @param tri1 First quad triangle
          * @param tri2 Second quad triangle
-         * 
+         *
          * @pre Triangles must be properly fanned from the most appropriate vertex.
          */
         void ngonEncodeQuad(aiFace *tri1, aiFace *tri2) {
             ai_assert(tri1->mNumIndices == 3);
             ai_assert(tri2->mNumIndices == 3);
             ai_assert(tri1->mIndices[0] == tri2->mIndices[0]);
 
             // If the selected fanning vertex is the same as the previously
             // emitted ngon, we use the opposite vertex which also happens to work
             // for tri-fanning a concave quad.
             // ref: https://github.com/assimp/assimp/pull/3695#issuecomment-805999760
             if (isConsideredSameAsLastNgon(tri1)) {
                 // Right-rotate indices for tri1 (index 2 becomes the new fanning vertex)
                 std::swap(tri1->mIndices[0], tri1->mIndices[2]);
                 std::swap(tri1->mIndices[1], tri1->mIndices[2]);
 
                 // Left-rotate indices for tri2 (index 2 becomes the new fanning vertex)
                 std::swap(tri2->mIndices[1], tri2->mIndices[2]);
                 std::swap(tri2->mIndices[0], tri2->mIndices[2]);
 
                 ai_assert(tri1->mIndices[0] == tri2->mIndices[0]);
             }
 
             mLastNGONFirstIndex = tri1->mIndices[0];
         }
 
         /**
          * @brief Check whether this triangle would be considered part of the lastly emitted ngon or not.
-         * 
+         *
          * @param tri Current triangle.
          * @return true If used as is, this triangle will be part of last ngon.
          * @return false If used as is, this triangle is not considered part of the last ngon.
          */
         bool isConsideredSameAsLastNgon(const aiFace * tri) const {
             ai_assert(tri->mNumIndices == 3);
             return tri->mIndices[0] == mLastNGONFirstIndex;
         }
 
     private:
         unsigned int mLastNGONFirstIndex;
     };
 
 }
 
 
 // ------------------------------------------------------------------------------------------------
 // Constructor to be privately used by Importer
@@ -203,426 +203,426 @@ void TriangulateProcess::Execute( aiScene* pScene)
 // ------------------------------------------------------------------------------------------------
 // Triangulates the given mesh.
 bool TriangulateProcess::TriangulateMesh( aiMesh* pMesh)
 {
     // Now we have aiMesh::mPrimitiveTypes, so this is only here for test cases
     if (!pMesh->mPrimitiveTypes)    {
         bool bNeed = false;
 
         for( unsigned int a = 0; a < pMesh->mNumFaces; a++) {
             const aiFace& face = pMesh->mFaces[a];
 
             if( face.mNumIndices != 3)  {
                 bNeed = true;
             }
         }
         if (!bNeed)
             return false;
     }
     else if (!(pMesh->mPrimitiveTypes & aiPrimitiveType_POLYGON)) {
         return false;
     }
 
     // Find out how many output faces we'll get
     uint32_t numOut = 0, max_out = 0;
     bool get_normals = true;
     for( unsigned int a = 0; a < pMesh->mNumFaces; a++) {
         aiFace& face = pMesh->mFaces[a];
         if (face.mNumIndices <= 4) {
             get_normals = false;
         }
         if( face.mNumIndices <= 3) {
             numOut++;
 
         }
         else {
             numOut += face.mNumIndices-2;
             max_out = std::max(max_out,face.mNumIndices);
         }
     }
 
     // Just another check whether aiMesh::mPrimitiveTypes is correct
     ai_assert(numOut != pMesh->mNumFaces);
 
     aiVector3D *nor_out = nullptr;
 
     // if we don't have normals yet, but expect them to be a cheap side
     // product of triangulation anyway, allocate storage for them.
     if (!pMesh->mNormals && get_normals) {
         // XXX need a mechanism to inform the GenVertexNormals process to treat these normals as preprocessed per-face normals
     //  nor_out = pMesh->mNormals = new aiVector3D[pMesh->mNumVertices];
     }
 
     // the output mesh will contain triangles, but no polys anymore
     pMesh->mPrimitiveTypes |= aiPrimitiveType_TRIANGLE;
     pMesh->mPrimitiveTypes &= ~aiPrimitiveType_POLYGON;
 
     // The mesh becomes NGON encoded now, during the triangulation process.
     pMesh->mPrimitiveTypes |= aiPrimitiveType_NGONEncodingFlag;
 
     aiFace* out = new aiFace[numOut](), *curOut = out;
     std::vector<aiVector3D> temp_verts3d(max_out+2); /* temporary storage for vertices */
     std::vector<aiVector2D> temp_verts(max_out+2);
 
     NGONEncoder ngonEncoder;
 
     // Apply vertex colors to represent the face winding?
 #ifdef AI_BUILD_TRIANGULATE_COLOR_FACE_WINDING
     if (!pMesh->mColors[0])
         pMesh->mColors[0] = new aiColor4D[pMesh->mNumVertices];
     else
         new(pMesh->mColors[0]) aiColor4D[pMesh->mNumVertices];
 
     aiColor4D* clr = pMesh->mColors[0];
 #endif
 
 #ifdef AI_BUILD_TRIANGULATE_DEBUG_POLYS
     FILE* fout = fopen(POLY_OUTPUT_FILE,"a");
 #endif
 
     const aiVector3D* verts = pMesh->mVertices;
 
     // use std::unique_ptr to avoid slow std::vector<bool> specialiations
     std::unique_ptr<bool[]> done(new bool[max_out]);
     for( unsigned int a = 0; a < pMesh->mNumFaces; a++) {
         aiFace& face = pMesh->mFaces[a];
 
         unsigned int* idx = face.mIndices;
         int num = (int)face.mNumIndices, ear = 0, tmp, prev = num-1, next = 0, max = num;
 
         // Apply vertex colors to represent the face winding?
 #ifdef AI_BUILD_TRIANGULATE_COLOR_FACE_WINDING
         for (unsigned int i = 0; i < face.mNumIndices; ++i) {
             aiColor4D& c = clr[idx[i]];
             c.r = (i+1) / (float)max;
             c.b = 1.f - c.r;
         }
 #endif
 
         aiFace* const last_face = curOut;
 
         // if it's a simple point,line or triangle: just copy it
         if( face.mNumIndices <= 3)
         {
             aiFace& nface = *curOut++;
             nface.mNumIndices = face.mNumIndices;
             nface.mIndices    = face.mIndices;
             face.mIndices = nullptr;
 
             // points and lines don't require ngon encoding (and are not supported either!)
             if (nface.mNumIndices == 3) ngonEncoder.ngonEncodeTriangle(&nface);
 
             continue;
         }
         // optimized code for quadrilaterals
         else if ( face.mNumIndices == 4) {
 
             // quads can have at maximum one concave vertex. Determine
             // this vertex (if it exists) and start tri-fanning from
             // it.
             unsigned int start_vertex = 0;
             for (unsigned int i = 0; i < 4; ++i) {
                 const aiVector3D& v0 = verts[face.mIndices[(i+3) % 4]];
                 const aiVector3D& v1 = verts[face.mIndices[(i+2) % 4]];
                 const aiVector3D& v2 = verts[face.mIndices[(i+1) % 4]];
 
                 const aiVector3D& v = verts[face.mIndices[i]];
 
                 aiVector3D left = (v0-v);
                 aiVector3D diag = (v1-v);
                 aiVector3D right = (v2-v);
 
                 left.Normalize();
                 diag.Normalize();
                 right.Normalize();
 
                 const float angle = std::acos(left*diag) + std::acos(right*diag);
                 if (angle > AI_MATH_PI_F) {
                     // this is the concave point
                     start_vertex = i;
                     break;
                 }
             }
 
             const unsigned int temp[] = {face.mIndices[0], face.mIndices[1], face.mIndices[2], face.mIndices[3]};
 
             aiFace& nface = *curOut++;
             nface.mNumIndices = 3;
             nface.mIndices = face.mIndices;
 
             nface.mIndices[0] = temp[start_vertex];
             nface.mIndices[1] = temp[(start_vertex + 1) % 4];
             nface.mIndices[2] = temp[(start_vertex + 2) % 4];
 
             aiFace& sface = *curOut++;
             sface.mNumIndices = 3;
             sface.mIndices = new unsigned int[3];
 
             sface.mIndices[0] = temp[start_vertex];
             sface.mIndices[1] = temp[(start_vertex + 2) % 4];
             sface.mIndices[2] = temp[(start_vertex + 3) % 4];
 
             // prevent double deletion of the indices field
             face.mIndices = nullptr;
 
             ngonEncoder.ngonEncodeQuad(&nface, &sface);
 
             continue;
         }
         else
         {
             // A polygon with more than 3 vertices can be either concave or convex.
             // Usually everything we're getting is convex and we could easily
             // triangulate by tri-fanning. However, LightWave is probably the only
             // modeling suite to make extensive use of highly concave, monster polygons ...
             // so we need to apply the full 'ear cutting' algorithm to get it right.
 
             // REQUIREMENT: polygon is expected to be simple and *nearly* planar.
             // We project it onto a plane to get a 2d triangle.
 
             // Collect all vertices of of the polygon.
             for (tmp = 0; tmp < max; ++tmp) {
                 temp_verts3d[tmp] = verts[idx[tmp]];
             }
 
             // Get newell normal of the polygon. Store it for future use if it's a polygon-only mesh
             aiVector3D n;
             NewellNormal<3,3,3>(n,max,&temp_verts3d.front().x,&temp_verts3d.front().y,&temp_verts3d.front().z);
             if (nor_out) {
                  for (tmp = 0; tmp < max; ++tmp)
                      nor_out[idx[tmp]] = n;
             }
 
             // Select largest normal coordinate to ignore for projection
             const float ax = (n.x>0 ? n.x : -n.x);
             const float ay = (n.y>0 ? n.y : -n.y);
             const float az = (n.z>0 ? n.z : -n.z);
 
             unsigned int ac = 0, bc = 1; /* no z coord. projection to xy */
             float inv = n.z;
             if (ax > ay) {
                 if (ax > az) { /* no x coord. projection to yz */
                     ac = 1; bc = 2;
                     inv = n.x;
                 }
             }
             else if (ay > az) { /* no y coord. projection to zy */
                 ac = 2; bc = 0;
                 inv = n.y;
             }
 
             // Swap projection axes to take the negated projection vector into account
             if (inv < 0.f) {
                 std::swap(ac,bc);
             }
 
             for (tmp =0; tmp < max; ++tmp) {
                 temp_verts[tmp].x = verts[idx[tmp]][ac];
                 temp_verts[tmp].y = verts[idx[tmp]][bc];
                 done[tmp] = false;
             }
 
 #ifdef AI_BUILD_TRIANGULATE_DEBUG_POLYS
             // plot the plane onto which we mapped the polygon to a 2D ASCII pic
             aiVector2D bmin,bmax;
             ArrayBounds(&temp_verts[0],max,bmin,bmax);
 
             char grid[POLY_GRID_Y][POLY_GRID_X+POLY_GRID_XPAD];
             std::fill_n((char*)grid,POLY_GRID_Y*(POLY_GRID_X+POLY_GRID_XPAD),' ');
 
             for (int i =0; i < max; ++i) {
                 const aiVector2D& v = (temp_verts[i] - bmin) / (bmax-bmin);
                 const size_t x = static_cast<size_t>(v.x*(POLY_GRID_X-1)), y = static_cast<size_t>(v.y*(POLY_GRID_Y-1));
                 char* loc = grid[y]+x;
                 if (grid[y][x] != ' ') {
                     for(;*loc != ' '; ++loc);
                     *loc++ = '_';
                 }
                 *(loc+::ai_snprintf(loc, POLY_GRID_XPAD,"%i",i)) = ' ';
             }
 
 
             for(size_t y = 0; y < POLY_GRID_Y; ++y) {
                 grid[y][POLY_GRID_X+POLY_GRID_XPAD-1] = '\0';
                 fprintf(fout,"%s\n",grid[y]);
             }
 
             fprintf(fout,"\ntriangulation sequence: ");
 #endif
 
             //
             // FIXME: currently this is the slow O(kn) variant with a worst case
             // complexity of O(n^2) (I think). Can be done in O(n).
             while (num > 3) {
 
                 // Find the next ear of the polygon
                 int num_found = 0;
                 for (ear = next;;prev = ear,ear = next) {
 
                     // break after we looped two times without a positive match
                     for (next=ear+1;done[(next>=max?next=0:next)];++next);
                     if (next < ear) {
                         if (++num_found == 2) {
                             break;
                         }
                     }
                     const aiVector2D* pnt1 = &temp_verts[ear],
                         *pnt0 = &temp_verts[prev],
                         *pnt2 = &temp_verts[next];
 
                     // Must be a convex point. Assuming ccw winding, it must be on the right of the line between p-1 and p+1.
                     if (OnLeftSideOfLine2D(*pnt0,*pnt2,*pnt1)) {
                         continue;
                     }
 
                     // and no other point may be contained in this triangle
                     for ( tmp = 0; tmp < max; ++tmp) {
 
                         // We need to compare the actual values because it's possible that multiple indexes in
                         // the polygon are referring to the same position. concave_polygon.obj is a sample
                         //
                         // FIXME: Use 'epsiloned' comparisons instead? Due to numeric inaccuracies in
                         // PointInTriangle() I'm guessing that it's actually possible to construct
                         // input data that would cause us to end up with no ears. The problem is,
                         // which epsilon? If we chose a too large value, we'd get wrong results
                         const aiVector2D& vtmp = temp_verts[tmp];
                         if ( vtmp != *pnt1 && vtmp != *pnt2 && vtmp != *pnt0 && PointInTriangle2D(*pnt0,*pnt1,*pnt2,vtmp)) {
                             break;
                         }
                     }
                     if (tmp != max) {
                         continue;
                     }
 
                     // this vertex is an ear
                     break;
                 }
                 if (num_found == 2) {
 
                     // Due to the 'two ear theorem', every simple polygon with more than three points must
                     // have 2 'ears'. Here's definitely something wrong ... but we don't give up yet.
                     //
 
                     // Instead we're continuing with the standard tri-fanning algorithm which we'd
                     // use if we had only convex polygons. That's life.
                     ASSIMP_LOG_ERROR("Failed to triangulate polygon (no ear found). Probably not a simple polygon?");
 
 #ifdef AI_BUILD_TRIANGULATE_DEBUG_POLYS
                     fprintf(fout,"critical error here, no ear found! ");
 #endif
                     num = 0;
                     break;
 
-                    /*curOut -= (max-num); // undo all previous work 
+                    /*curOut -= (max-num); // undo all previous work
                     for (tmp = 0; tmp < max-2; ++tmp) {
                         aiFace& nface = *curOut++;
 
                         nface.mNumIndices = 3;
                         if (!nface.mIndices)
                             nface.mIndices = new unsigned int[3];
 
                         nface.mIndices[0] = 0;
                         nface.mIndices[1] = tmp+1;
                         nface.mIndices[2] = tmp+2;
 
                     }
                     num = 0;
                     break;*/
                 }
 
                 aiFace& nface = *curOut++;
                 nface.mNumIndices = 3;
 
                 if (!nface.mIndices) {
                     nface.mIndices = new unsigned int[3];
                 }
 
                 // setup indices for the new triangle ...
                 nface.mIndices[0] = prev;
                 nface.mIndices[1] = ear;
                 nface.mIndices[2] = next;
 
                 // exclude the ear from most further processing
                 done[ear] = true;
                 --num;
             }
             if (num > 0) {
                 // We have three indices forming the last 'ear' remaining. Collect them.
                 aiFace& nface = *curOut++;
                 nface.mNumIndices = 3;
                 if (!nface.mIndices) {
                     nface.mIndices = new unsigned int[3];
                 }
 
                 for (tmp = 0; done[tmp]; ++tmp);
                 nface.mIndices[0] = tmp;
 
                 for (++tmp; done[tmp]; ++tmp);
                 nface.mIndices[1] = tmp;
 
                 for (++tmp; done[tmp]; ++tmp);
                 nface.mIndices[2] = tmp;
 
             }
         }
 
 #ifdef AI_BUILD_TRIANGULATE_DEBUG_POLYS
 
         for(aiFace* f = last_face; f != curOut; ++f) {
             unsigned int* i = f->mIndices;
             fprintf(fout," (%i %i %i)",i[0],i[1],i[2]);
         }
 
         fprintf(fout,"\n*********************************************************************\n");
         fflush(fout);
 
 #endif
 
         for(aiFace* f = last_face; f != curOut; ) {
             unsigned int* i = f->mIndices;
 
             //  drop dumb 0-area triangles - deactivated for now:
             //FindDegenerates post processing step can do the same thing
             //if (std::fabs(GetArea2D(temp_verts[i[0]],temp_verts[i[1]],temp_verts[i[2]])) < 1e-5f) {
             //    ASSIMP_LOG_VERBOSE_DEBUG("Dropping triangle with area 0");
             //    --curOut;
 
             //    delete[] f->mIndices;
             //    f->mIndices = nullptr;
 
             //    for(aiFace* ff = f; ff != curOut; ++ff) {
             //        ff->mNumIndices = (ff+1)->mNumIndices;
             //        ff->mIndices = (ff+1)->mIndices;
             //        (ff+1)->mIndices = nullptr;
             //    }
             //    continue;
             //}
 
             i[0] = idx[i[0]];
             i[1] = idx[i[1]];
             i[2] = idx[i[2]];
 
             // IMPROVEMENT: Polygons are not supported yet by this ngon encoding + triangulation step.
             //              So we encode polygons as regular triangles. No way to reconstruct the original
             //              polygon in this case.
             ngonEncoder.ngonEncodeTriangle(f);
             ++f;
         }
 
         delete[] face.mIndices;
         face.mIndices = nullptr;
     }
 
 #ifdef AI_BUILD_TRIANGULATE_DEBUG_POLYS
     fclose(fout);
 #endif
 
     // kill the old faces
     delete [] pMesh->mFaces;
 
     // ... and store the new ones
     pMesh->mFaces    = out;
     pMesh->mNumFaces = (unsigned int)(curOut-out); /* not necessarily equal to numOut */
     return true;
 }
 
 #endif // !! ASSIMP_BUILD_NO_TRIANGULATE_PROCESS
diff --git a/doc/dox.h b/doc/dox.h
index a4516dc7a..409e775d4 100644
--- a/doc/dox.h
+++ b/doc/dox.h
@@ -90,8 +90,8 @@ but not all of them are *open-source*. If there's an accompagning '<file>\source
 @section main_install Installation
 
 assimp can be used in two ways: linking against the pre-built libraries or building the library on your own. The former
-option is the easiest, but the assimp distribution contains pre-built libraries only for Visual C++ 2013, 2015 and 2017. 
-For other compilers you'll have to build assimp for yourself. Which is hopefully as hassle-free as the other way, but 
+option is the easiest, but the assimp distribution contains pre-built libraries only for Visual C++ 2013, 2015 and 2017.
+For other compilers you'll have to build assimp for yourself. Which is hopefully as hassle-free as the other way, but
 needs a bit more work. Both ways are described at the @link install Installation page. @endlink
 If you want to use assimp on Ubuntu you can install it via the following command:
 
@@ -145,7 +145,7 @@ to your include paths (Menu-&gt;Extras-&gt;Options-&gt;Projects and Solutions-&g
 and the assimp/lib/&lt;Compiler&gt; path to your linker paths (Menu-&gt;Extras-&gt;Options-&gt;Projects and Solutions-&gt;VC++ Directories-&gt;Library files).
 This is necessary only once to setup all paths inside you IDE.
 
-To use the library in your C++ project you can simply generate a project file via cmake. One way is to add the assimp-folder 
+To use the library in your C++ project you can simply generate a project file via cmake. One way is to add the assimp-folder
 as a subdirectory via the cmake-command
 
 @code
@@ -158,7 +158,7 @@ Now just add the assimp-dependency to your application:
 TARGET_LINK_LIBRARIES(my_game assimp)
 @endcode
 
-If done correctly you should now be able to compile, link, run and use the application. 
+If done correctly you should now be able to compile, link, run and use the application.
 
 
 @section install_own Building the library from scratch
@@ -170,7 +170,7 @@ to build the library just open a command-prompt / bash, navigate into the repo-f
 cmake CMakeLists.txt
 @endcode
 
-A project-file of your default make-system ( like gnu-make on linux or Visual-Studio on Windows ) will be generated. 
+A project-file of your default make-system ( like gnu-make on linux or Visual-Studio on Windows ) will be generated.
 Run the build and you are done. You can find the libs at assimp/lib and the dll's / so's at bin.
 
 @section assimp_dll Windows DLL Build
@@ -496,10 +496,10 @@ X3  Y3  Z3  T3
 @endcode
 with <tt>(X1, X2, X3)</tt> being the local X base vector, <tt>(Y1, Y2, Y3)</tt> being the local
 Y base vector, <tt>(Z1, Z2, Z3)</tt> being the local Z base vector and <tt>(T1, T2, T3)</tt> being the
-offset of the local origin (the translational part). 
+offset of the local origin (the translational part).
 All matrices in the library use row-major storage order. That means that the matrix elements are
-stored row-by-row, i.e. they end up like this in memory: 
-<tt>[X1, Y1, Z1, T1, X2, Y2, Z2, T2, X3, Y3, Z3, T3, 0, 0, 0, 1]</tt>. 
+stored row-by-row, i.e. they end up like this in memory:
+<tt>[X1, Y1, Z1, T1, X2, Y2, Z2, T2, X3, Y3, Z3, T3, 0, 0, 0, 1]</tt>.
 
 Note that this is neither the OpenGL format nor the DirectX format, because both of them specify the
 matrix layout such that the translational part occupies three consecutive addresses in memory (so those
@@ -1498,7 +1498,7 @@ Just copy'n'paste the template from Appendix A and adapt it for your needs.
 with DefaultLogger::get()->[error, warn, debug, info].
 </li>
 <li>
-Make sure that your loader compiles against all build configurations on all supported platforms. You can use our CI-build to check several platforms 
+Make sure that your loader compiles against all build configurations on all supported platforms. You can use our CI-build to check several platforms
 like Windows and Linux ( 32 bit and 64 bit ).
 </li>
 <li>
diff --git a/doc/dox_cmd.h b/doc/dox_cmd.h
index 78e755d56..79ea3a861 100644
--- a/doc/dox_cmd.h
+++ b/doc/dox_cmd.h
@@ -12,7 +12,7 @@
 
 @section intro Introduction
 
-This document describes the usage of assimp's command line tools. 
+This document describes the usage of assimp's command line tools.
 This is *not* the SDK reference and programming-related stuff is not covered here.
 <br><br>
 <b>NOTE</b>: For simplicity, the following sections are written with Windows in mind. However
@@ -29,29 +29,29 @@ assimp [command] [parameters]
 The following commands are available:
 
 <table border="1">
- 
+
   <tr>
     <td><b>@link version version @endlink</b></td>
     <td>Retrieve the current version of assimp</td>
   </tr>
   <tr>
     <td><b>@link help help @endlink</b></td>
     <td>Get a list of all commands (yes, it's this list ...)</td>
   </tr>
    <tr>
     <td><b>@link dump dump @endlink</b></td>
     <td>Generate a human-readable text dump of a model</td>
   </tr>
    <tr>
     <td><b>@link extract extract @endlink</b></td>
     <td>Extract an embedded texture image</td>
   </tr>
    <tr>
     <td><b>@link iinfo info @endlink</b></td>
     <td>Load a model and print basic statistics</td>
   </tr>
    <tr>
     <td><b>@link cmpdump cmpdump @endlink</b></td>
     <td>Regression checking tool</td>
   </tr>
 </table>
@@ -184,7 +184,7 @@ Generate a text or binary dump of a model. This is the core component of Assimp'
 regression test suite but it could also be useful for other developers to quickly
 examine the contents of a model. Note that text dumps are not intended to be used as
 intermediate format, Assimp is not able to read them again, nor is the file format
-stable or well-defined. It may change with every revision without notice. 
+stable or well-defined. It may change with every revision without notice.
 Binary dumps (*.assbin) are backwards- and forwards-compatible.
 
 <h3>Syntax:</h3>
@@ -199,7 +199,7 @@ assimp dump <model> [<out>] [-b] [-s] [common parameters]
 <p>
 <tt>
 model<br></tt><br>
-Required. Relative or absolute path to the input model. 
+Required. Relative or absolute path to the input model.
 </p>
 <p>
 <tt>
@@ -220,7 +220,7 @@ The long form of this parameter is <tt>--binary</tt>.
 </tt><br>
 Optional. If this switch is specified, the dump is shortened to include only
 min/max values for all vertex components and animation channels. The resulting
-file is much smaller, but the original model can't be reconstructed from it. This is 
+file is much smaller, but the original model can't be reconstructed from it. This is
 used by Assimp's regression test suite, comparing those minidumps provides
 a fast way to verify whether a loader works correctly or not.
 The long form of this parameter is <tt>--short</tt>.
@@ -229,7 +229,7 @@ The long form of this parameter is <tt>--short</tt>.
 <p>
 <tt>
 common parameters<br></tt><br>
-Optional. Import configuration & postprocessing. 
+Optional. Import configuration & postprocessing.
 See the @link common common parameters page @endlink for more information.
 </p>
 
@@ -248,7 +248,7 @@ The log output is included with the dump.
 
 @code
 assimp dump files\*.*
-assimp dump files\*.* 
+assimp dump files\*.*
 @endcode
 
 Dumps all loadable model files in the 'files' subdir. The output dumps are named
@@ -275,14 +275,14 @@ assimp extract <model> [<out>] [-t<n>] [-f<fmt>] [-ba] [-s] [common parameters]
 <p>
 <tt>
 model<br></tt><br>
-Required. Relative or absolute path to the input model. 
+Required. Relative or absolute path to the input model.
 </p>
 <p>
 <tt>
 out<br></tt><br>
 Optional. Relative or absolute path to write the output images to. If the file name is
 omitted the output images are named <tt><model-filename></tt><br>
-The suffix <tt>_img&lt;n&gt;</tt> is appended to the file name if the -s switch is not specified 
+The suffix <tt>_img&lt;n&gt;</tt> is appended to the file name if the -s switch is not specified
 (where <tt>&lt;n&gt;</tt> is the zero-based index of the texture in the model file).<br>
 
 The output file format is determined from the given file extension. Supported
@@ -296,7 +296,7 @@ written in their native file format (e.g. jpg).
 <p>
 <tt>-t&lt;n&gt;<br>
 </tt><br>
-Optional. Specifies the (zero-based) index of the embedded texture to be extracted from 
+Optional. Specifies the (zero-based) index of the embedded texture to be extracted from
 the model. If this option is *not* specified all textures found are exported.
 The long form of this parameter is <tt>--texture=&lt;n&gt;</tt>.
 </p>
@@ -348,8 +348,8 @@ imported data structure and writes it to <tt>test_img0.bmp</tt>.
 
 
 @code
-assimp extract files\*.mdl *.bmp 
-assimp extract files\*.mdl *.bmp 
+assimp extract files\*.mdl *.bmp
+assimp extract files\*.mdl *.bmp
 @endcode
 
 Extracts all embedded textures from all loadable .mdl files in the 'files' subdirectory
@@ -361,152 +361,152 @@ and writes them to bitmaps which are named <tt><model-file>_img<image-index>.bmp
 /**
 @page common Common parameters
 
-The parameters described on this page are commonly used by almost every assimp command. They 
+The parameters described on this page are commonly used by almost every assimp command. They
 specify how the library will postprocess the imported data. This is done by several
 configurable pipeline stages, called 'post processing steps'. Below you can find a list
-of all supported steps along with short descriptions of what they're doing. <br><b>Programmers</b>: 
+of all supported steps along with short descriptions of what they're doing. <br><b>Programmers</b>:
 more information can be found in the <tt>aiPostProcess.h</tt> header.
 
 <table border="1">
   <tr>
     <th>Parameter</th>
     <th>Long parameter</th>
 	<th>Description</th>
   </tr>
   <tr>
     <td><tt>-ptv</tt></td>
     <td><tt>--pretransform-vertices</tt></td>
-	<td>Move all vertices into worldspace and collapse the scene graph. Animation data is lost. 
+	<td>Move all vertices into worldspace and collapse the scene graph. Animation data is lost.
 	This is intended for applications which don't support scenegraph-oriented rendering.</td>
   </tr>
   <tr>
     <td><tt>-gsn</tt></td>
     <td><tt>--gen-smooth-normals</tt></td>
 	<td>Computes 'smooth' per-vertex normal vectors if necessary. Mutually exclusive with -gn</td>
   </tr>
   <tr>
     <td><tt>-gn</tt></td>
     <td><tt>--gen-normals</tt></td>
 	<td>Computes 'hard' per-face normal vectors if necessary. Mutually exclusive with -gsn</td>
   </tr>
   <tr>
     <td><tt>-cts</tt></td>
     <td><tt>--calc-tangent-space</tt></td>
 	<td>If one UV channel and normal vectors are given, compute tangents and bitangents</td>
   </tr>
   <tr>
     <td><tt>-jiv</tt></td>
     <td><tt>--join-identical-vertices</tt></td>
 	<td>Optimize the index buffer. If this flag is not specified all vertices are referenced once.</td>
   </tr>
   <tr>
     <td><tt>-rrm</tt></td>
     <td><tt>--remove-redundant-materials</tt></td>
 	<td>Remove redundant materials from the imported data.</td>
   </tr>
   <tr>
     <td><tt>-fd</tt></td>
     <td><tt>--find-degenerates</tt></td>
 	<td>Find and process degenerates primitives.</td>
   </tr>
   <tr>
     <td><tt>-slm</tt></td>
     <td><tt>--split-large-meshes</tt></td>
 	<td>Split large meshes over a specific threshold in smaller sub meshes. The default vertex & face limit is 1000000</td>
   </tr>
   <tr>
     <td><tt>-lbw</tt></td>
     <td><tt>--limit-bone-weights</tt></td>
 	<td>Limit the number of bones influencing a single vertex. The default limit is 4.</td>
   </tr>
   <tr>
     <td><tt>-vds</tt></td>
     <td><tt>--validate-data-structure</tt></td>
 	<td>Performs a full validation of the imported data structure. Recommended to avoid crashes if
 	an import plugin produces rubbish</td>
   </tr>
    <tr>
     <td><tt>-icl</tt></td>
     <td><tt>--improve-cache-locality</tt></td>
-	<td>Improve the cache locality of the vertex buffer by reordering the index buffer 
+	<td>Improve the cache locality of the vertex buffer by reordering the index buffer
 	to achieve a lower ACMR (average post-transform vertex cache miss ratio)</td>
   </tr>
   <tr>
     <td><tt>-sbpt</tt></td>
     <td><tt>--sort-by-ptype</tt></td>
 	<td>Splits meshes which consist of more than one kind of primitives (e.g. lines and triangles mixed up)
 	in 'clean' submeshes. </td>
   </tr>
   <tr>
     <td><tt>-lh</tt></td>
     <td><tt>--convert-to-lh</tt></td>
 	<td>Converts the imported data to left-handed coordinate space</td>
   </tr>
    <tr>
     <td><tt>-fuv</tt></td>
     <td><tt>--flip-uv</tt></td>
 	<td>Flip UV coordinates from upper-left origin to lower-left origin</td>
   </tr>
    <tr>
     <td><tt>-fwo</tt></td>
     <td><tt>--flip-winding-order</tt></td>
 	<td>Flip face winding order from CCW to CW</td>
   </tr>
   <tr>
     <td><tt>-ett</tt></td>
     <td><tt>--evaluate-texture-transform</tt></td>
 	<td>Evaluate per-texture UV transformations (e.g scaling, offset) and build pretransformed UV channels</td>
   </tr>
    <tr>
     <td><tt>-guv</tt></td>
     <td><tt>--gen-uvcoords</tt></td>
 	<td>Replace abstract mapping descriptions, such as 'spherical' or 'cylindrical' with proper UV channels</td>
   </tr>
     <tr>
     <td><tt>-fixn</tt></td>
     <td><tt>--fix-normals</tt></td>
 	<td>Run a heuristic algorithm to detect meshes with wrong face winding order/normals. </td>
   </tr>
    <tr>
     <td><tt>-tri</tt></td>
     <td><tt>--triangulate</tt></td>
 	<td>Triangulate poylgons with 4 and more points. Lines, points and triangles are not affected. </td>
   </tr>
    <tr>
     <td><tt>-fi</tt></td>
     <td><tt>--find-instances</tt></td>
 	<td>Search the data structure for instanced meshes and replace them by references. This can
 	reduce vertex/face counts but the postprocessing-step takes some time.</td>
   </tr>
   <tr>
     <td><tt>-og</tt></td>
     <td><tt>--optimize-graph</tt></td>
 	<td>Simplify and optimize the scenegraph. Use it with care, all hierarchy information could be lost.
 	Animations remain untouched. </td>
   </tr>
   <tr>
     <td><tt>-om</tt></td>
     <td><tt>--optimize-meshes</tt></td>
 	<td>Optimize mesh usage. Meshes are merged, if possible. Very effective in combination with <tt>--optimize-graph</tt></td>
   </tr>
   <tr>
     <td><tt>-tuv</tt></td>
     <td><tt>--transform-uv-coords</tt></td>
     <td>Will transform uv-coordinates if possible.</td>
   </tr>
   <tr>
     <td><tt>-fid</tt></td>
     <td><tt>--find-invalid-data</tt></td>
     <td>Will look for invalid data in the imported model structure.</td>
   </tr>
   <tr>
     <td><tt>-db</tt></td>
     <td><tt>--debone</tt></td>
     <td>Removes nearly losslessly or according to a configured threshold bones from the model.</td>
   </tr>
   <tr>
     <td><tt>-sbc</tt></td>
     <td><tt>--split-by-bone-count</tt></td>
     <td>Split meshes with too many bones. Necessary for our (limited) hardware skinning shader.</td>
   </tr>
 </table>
@@ -515,27 +515,27 @@ For convenience some default postprocessing configurations are provided.
 The corresponding command line parameter is <tt>-c&lt;name&gt;</tt> (or <tt>--config=&lt;name&gt;</tt>).
 
 <table border="1">
- 
+
   <tr>
     <th>Name</th>
     <th>Description</th>
 	<th>List of steps executed</th>
   </tr>
   <tr>
     <td>fast</td>
     <td>Fast post processing config, performs some essential optimizations and computes tangents</td>
 	<td><tt>-cts, -gn, -jiv, -tri, -guv, -sbpt</tt></td>
   </tr>
     <tr>
     <td>default</td>
     <td>Balanced post processing config; performs most optimizations</td>
 	<td><tt>-cts, -gsn, -jiv, -icl, -lbw, -rrm, -slm, -tri, -guv, -sbpt, -fd, -fiv</tt></td>
   </tr>
     <tr>
     <td>full</td>
     <td>Full post processing. May take a while but results in best output quality for most purposes</td>
 	<td><tt>-cts, -gsn, -jiv, -icl, -lbw, -rrm, -slm, -tri, -guv, -sbpt, -fd, -fiv, -fi, -vds -om</tt></td>
   </tr>
  </table>
 
  The <tt>-tuv, -ptv, -og</tt> flags always need to be enabled manually.
@@ -543,23 +543,23 @@ The corresponding command line parameter is <tt>-c&lt;name&gt;</tt> (or <tt>--co
 There are also some common flags to customize Assimp's logging behaviour:
 
 <table border="1">
- 
+
   <tr>
     <th>Name</th>
     <th>Description</th>
   </tr>
   <tr>
     <td><tt>-l</tt> or <tt>--show-log</tt></td>
     <td>Show log file on console window (stderr)</td>
   </tr>
     <tr>
     <td><tt>-lo&lt;file&gt;</tt> or <tt>--log-out=&lt;file&gt;</tt></td>
     <td>Streams the log to &lt;file&gt;</td>
   </tr>
     <tr>
     <td><tt>-v</tt> or <tt>--verbose</tt></td>
-    <td>Enables verbose logging. Debug messages will be produced too. This might 
+    <td>Enables verbose logging. Debug messages will be produced too. This might
 	decrease loading performance and result in *very* long logs ... use with caution if you experience strange issues.</td>
   </tr>
  </table>
  */
diff --git a/fuzz/assimp_fuzzer.cc b/fuzz/assimp_fuzzer.cc
index b65ee0236..33748c10f 100644
--- a/fuzz/assimp_fuzzer.cc
+++ b/fuzz/assimp_fuzzer.cc
@@ -48,12 +48,12 @@ using namespace Assimp;
 extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t dataSize) {
 	aiLogStream stream = aiGetPredefinedLogStream(aiDefaultLogStream_STDOUT,NULL);
 	aiAttachLogStream(&stream);
 
     Importer importer;
     const aiScene *sc = importer.ReadFileFromMemory(data, dataSize,
         aiProcessPreset_TargetRealtime_Quality, nullptr );
 
     aiDetachLogStream(&stream);
-    
+
     return 0;
 }
diff --git a/include/assimp/BaseImporter.h b/include/assimp/BaseImporter.h
index 38bec1afd..54b5daac1 100644
--- a/include/assimp/BaseImporter.h
+++ b/include/assimp/BaseImporter.h
@@ -88,102 +88,102 @@ class ASSIMP_API BaseImporter {
 public:
     /** Constructor to be privately used by #Importer */
     BaseImporter() AI_NO_EXCEPT;
 
     /** Destructor, private as well */
     virtual ~BaseImporter();
 
     // -------------------------------------------------------------------
     /** Returns whether the class can handle the format of the given file.
      *
      * The implementation should be as quick as possible. A check for
      * the file extension is enough. If no suitable loader is found with
      * this strategy, CanRead() is called again, the 'checkSig' parameter
      * set to true this time. Now the implementation is expected to
      * perform a full check of the file structure, possibly searching the
      * first bytes of the file for magic identifiers or keywords.
      *
      * @param pFile Path and file name of the file to be examined.
      * @param pIOHandler The IO handler to use for accessing any file.
      * @param checkSig Set to true if this method is called a second time.
      *   This time, the implementation may take more time to examine the
      *   contents of the file to be loaded for magic bytes, keywords, etc
      *   to be able to load files with unknown/not existent file extensions.
      * @return true if the class can read this file, false if not.
      */
     virtual bool CanRead(
             const std::string &pFile,
             IOSystem *pIOHandler,
             bool checkSig) const = 0;
 
     // -------------------------------------------------------------------
     /** Imports the given file and returns the imported data.
      * If the import succeeds, ownership of the data is transferred to
      * the caller. If the import fails, nullptr is returned. The function
      * takes care that any partially constructed data is destroyed
      * beforehand.
      *
      * @param pImp #Importer object hosting this loader.
      * @param pFile Path of the file to be imported.
      * @param pIOHandler IO-Handler used to open this and possible other files.
      * @return The imported data or nullptr if failed. If it failed a
      * human-readable error description can be retrieved by calling
      * GetErrorText()
      *
      * @note This function is not intended to be overridden. Implement
      * InternReadFile() to do the import. If an exception is thrown somewhere
      * in InternReadFile(), this function will catch it and transform it into
      *  a suitable response to the caller.
      */
     aiScene *ReadFile(
             Importer *pImp,
             const std::string &pFile,
             IOSystem *pIOHandler);
 
     // -------------------------------------------------------------------
     /** Returns the error description of the last error that occurred.
      * If the error is due to a std::exception, this will return the message.
      * Exceptions can also be accessed with GetException().
      * @return A description of the last error that occurred. An empty
      * string if there was no error.
      */
     const std::string &GetErrorText() const {
         return m_ErrorText;
     }
 
     // -------------------------------------------------------------------
     /** Returns the exception of the last exception that occurred.
      * Note: Exceptions are not the only source of error details, so GetErrorText
      * should be consulted too.
-     * @return The last exception that occurred. 
+     * @return The last exception that occurred.
      */
     const std::exception_ptr& GetException() const {
         return m_Exception;
     }
 
     // -------------------------------------------------------------------
     /** Called prior to ReadFile().
      * The function is a request to the importer to update its configuration
      * basing on the Importer's configuration property list.
      * @param pImp Importer instance
      */
     virtual void SetupProperties(
             const Importer *pImp);
 
     // -------------------------------------------------------------------
     /** Called by #Importer::GetImporterInfo to get a description of
      *  some loader features. Importers must provide this information. */
     virtual const aiImporterDesc *GetInfo() const = 0;
 
     /**
      * Will be called only by scale process when scaling is requested.
      */
     void SetFileScale(double scale) {
         fileScale = scale;
     }
 
     // -------------------------------------------------------------------
     /** Called by #Importer::GetExtensionList for each loaded importer.
      *  Take the extension list contained in the structure returned by
      *  #GetInfo and insert all file extensions into the given set.
      *  @param extension set to collect file extensions in*/
     void GetExtensionList(std::set<std::string> &extensions);
diff --git a/include/assimp/Compiler/poppack1.h b/include/assimp/Compiler/poppack1.h
index a8e9a3c7e..ff501bc0c 100644
--- a/include/assimp/Compiler/poppack1.h
+++ b/include/assimp/Compiler/poppack1.h
@@ -1,22 +1,22 @@
 
 // ===============================================================================
-// May be included multiple times - resets structure packing to the defaults 
-// for all supported compilers. Reverts the changes made by #include <pushpack1.h> 
+// May be included multiple times - resets structure packing to the defaults
+// for all supported compilers. Reverts the changes made by #include <pushpack1.h>
 //
 // Currently this works on the following compilers:
 // MSVC 7,8,9
 // GCC
 // BORLAND (complains about 'pack state changed but not reverted', but works)
 // ===============================================================================
 
 #ifndef AI_PUSHPACK_IS_DEFINED
 #	error pushpack1.h must be included after poppack1.h
 #endif
 
 // reset packing to the original value
 #if (defined(_MSC_VER) && !defined(__clang__)) ||  defined(__BORLANDC__) || defined (__BCPLUSPLUS__)
 #	pragma pack( pop )
 #endif
 #undef PACK_STRUCT
 
 #undef AI_PUSHPACK_IS_DEFINED
diff --git a/include/assimp/Compiler/pushpack1.h b/include/assimp/Compiler/pushpack1.h
index 2a5e2dfe6..b32ed172c 100644
--- a/include/assimp/Compiler/pushpack1.h
+++ b/include/assimp/Compiler/pushpack1.h
@@ -1,43 +1,43 @@
 
 
 // ===============================================================================
-// May be included multiple times - sets structure packing to 1 
+// May be included multiple times - sets structure packing to 1
 // for all supported compilers. #include <poppack1.h> reverts the changes.
 //
 // Currently this works on the following compilers:
 // MSVC 7,8,9
 // GCC
 // BORLAND (complains about 'pack state changed but not reverted', but works)
 // Clang
 //
 //
 // USAGE:
 //
 // struct StructToBePacked {
 // } PACK_STRUCT;
 //
 // ===============================================================================
 
 #ifdef AI_PUSHPACK_IS_DEFINED
 #	error poppack1.h must be included after pushpack1.h
 #endif
 
 #if (defined(_MSC_VER) && !defined(__clang__)) ||  defined(__BORLANDC__) ||	defined (__BCPLUSPLUS__)
 #	pragma pack(push,1)
 #	define PACK_STRUCT
 #elif defined( __GNUC__ ) || defined(__clang__)
 #	if !defined(HOST_MINGW)
 #		define PACK_STRUCT	__attribute__((__packed__))
 #	else
 #		define PACK_STRUCT	__attribute__((gcc_struct, __packed__))
 #	endif
 #else
 #	error Compiler not supported
 #endif
 
 #if defined(_MSC_VER)
 // C4103: Packing was changed after the inclusion of the header, probably missing #pragma pop
-#	pragma warning (disable : 4103) 
+#	pragma warning (disable : 4103)
 #endif
 
 #define AI_PUSHPACK_IS_DEFINED
diff --git a/include/assimp/Exceptional.h b/include/assimp/Exceptional.h
index 98e2a3321..1bf399cbc 100644
--- a/include/assimp/Exceptional.h
+++ b/include/assimp/Exceptional.h
@@ -59,13 +59,13 @@ using std::runtime_error;
 class ASSIMP_API DeadlyErrorBase : public runtime_error {
 protected:
     DeadlyErrorBase(Assimp::Formatter::format f);
-    
+
     template<typename... T, typename U>
     DeadlyErrorBase(Assimp::Formatter::format f, U&& u, T&&... args) :
             DeadlyErrorBase(std::move(f << std::forward<U>(u)), std::forward<T>(args)...) {}
 };
 
 // ---------------------------------------------------------------------------
 /** FOR IMPORTER PLUGINS ONLY: Simple exception class to be thrown if an
  *  unrecoverable error occurs while importing. Loading APIs return
  *  nullptr instead of a valid aiScene then.  */
diff --git a/include/assimp/Exporter.hpp b/include/assimp/Exporter.hpp
index 8e78ac954..6ab35a8f0 100644
--- a/include/assimp/Exporter.hpp
+++ b/include/assimp/Exporter.hpp
@@ -336,158 +336,158 @@ public:
 public:
     /** Standard constructor
     * @see ExportProperties()
     */
     ExportProperties();
 
     // -------------------------------------------------------------------
     /** Copy constructor.
      *
      * This copies the configuration properties of another ExportProperties.
      * @see ExportProperties(const ExportProperties& other)
      */
     ExportProperties(const ExportProperties &other);
 
     // -------------------------------------------------------------------
     /** Set an integer configuration property.
      * @param szName Name of the property. All supported properties
      *   are defined in the aiConfig.g header (all constants share the
      *   prefix AI_CONFIG_XXX and are simple strings).
      * @param iValue New value of the property
      * @return true if the property was set before. The new value replaces
      *   the previous value in this case.
      * @note Property of different types (float, int, string ..) are kept
      *   on different stacks, so calling SetPropertyInteger() for a
      *   floating-point property has no effect - the loader will call
      *   GetPropertyFloat() to read the property, but it won't be there.
      */
     bool SetPropertyInteger(const char *szName, int iValue);
 
     // -------------------------------------------------------------------
     /** Set a boolean configuration property. Boolean properties
      *  are stored on the integer stack internally so it's possible
      *  to set them via #SetPropertyBool and query them with
      *  #GetPropertyBool and vice versa.
      * @see SetPropertyInteger()
      */
     bool SetPropertyBool(const char *szName, bool value) {
         return SetPropertyInteger(szName, value);
     }
 
     // -------------------------------------------------------------------
     /** Set a floating-point configuration property.
      * @see SetPropertyInteger()
      */
     bool SetPropertyFloat(const char *szName, ai_real fValue);
 
     // -------------------------------------------------------------------
     /** Set a string configuration property.
      * @see SetPropertyInteger()
      */
     bool SetPropertyString(const char *szName, const std::string &sValue);
 
     // -------------------------------------------------------------------
     /** Set a matrix configuration property.
      * @see SetPropertyInteger()
      */
     bool SetPropertyMatrix(const char *szName, const aiMatrix4x4 &sValue);
-    
+
     bool SetPropertyCallback(const char *szName, const std::function<void *(void *)> &f);
 
     // -------------------------------------------------------------------
     /** Get a configuration property.
      * @param szName Name of the property. All supported properties
      *   are defined in the aiConfig.g header (all constants share the
      *   prefix AI_CONFIG_XXX).
      * @param iErrorReturn Value that is returned if the property
      *   is not found.
      * @return Current value of the property
      * @note Property of different types (float, int, string ..) are kept
      *   on different lists, so calling SetPropertyInteger() for a
      *   floating-point property has no effect - the loader will call
      *   GetPropertyFloat() to read the property, but it won't be there.
      */
     int GetPropertyInteger(const char *szName,
             int iErrorReturn = 0xffffffff) const;
 
     // -------------------------------------------------------------------
     /** Get a boolean configuration property. Boolean properties
      *  are stored on the integer stack internally so it's possible
      *  to set them via #SetPropertyBool and query them with
      *  #GetPropertyBool and vice versa.
      * @see GetPropertyInteger()
      */
     bool GetPropertyBool(const char *szName, bool bErrorReturn = false) const {
         return GetPropertyInteger(szName, bErrorReturn) != 0;
     }
 
     // -------------------------------------------------------------------
     /** Get a floating-point configuration property
      * @see GetPropertyInteger()
      */
     ai_real GetPropertyFloat(const char *szName,
             ai_real fErrorReturn = 10e10f) const;
 
     // -------------------------------------------------------------------
     /** Get a string configuration property
      *
      *  The return value remains valid until the property is modified.
      * @see GetPropertyInteger()
      */
     const std::string GetPropertyString(const char *szName,
             const std::string &sErrorReturn = "") const;
 
     // -------------------------------------------------------------------
     /** Get a matrix configuration property
      *
      *  The return value remains valid until the property is modified.
      * @see GetPropertyInteger()
      */
     const aiMatrix4x4 GetPropertyMatrix(const char *szName,
             const aiMatrix4x4 &sErrorReturn = aiMatrix4x4()) const;
 
     std::function<void *(void *)> GetPropertyCallback(const char* szName) const;
 
     // -------------------------------------------------------------------
     /** Determine a integer configuration property has been set.
     * @see HasPropertyInteger()
      */
     bool HasPropertyInteger(const char *szName) const;
 
     /** Determine a boolean configuration property has been set.
     * @see HasPropertyBool()
      */
     bool HasPropertyBool(const char *szName) const;
 
     /** Determine a boolean configuration property has been set.
     * @see HasPropertyFloat()
      */
     bool HasPropertyFloat(const char *szName) const;
 
     /** Determine a String configuration property has been set.
     * @see HasPropertyString()
      */
     bool HasPropertyString(const char *szName) const;
 
     /** Determine a Matrix configuration property has been set.
     * @see HasPropertyMatrix()
      */
     bool HasPropertyMatrix(const char *szName) const;
 
     bool HasPropertyCallback(const char *szName) const;
 
     /** List of integer properties */
     IntPropertyMap mIntProperties;
 
     /** List of floating-point properties */
     FloatPropertyMap mFloatProperties;
 
     /** List of string properties */
     StringPropertyMap mStringProperties;
 
     /** List of Matrix properties */
     MatrixPropertyMap mMatrixProperties;
 
     CallbackPropertyMap mCallbackProperties;
 };
 
 // ----------------------------------------------------------------------------------
diff --git a/include/assimp/IOStreamBuffer.h b/include/assimp/IOStreamBuffer.h
index ee4ac0953..c3b7327ff 100644
--- a/include/assimp/IOStreamBuffer.h
+++ b/include/assimp/IOStreamBuffer.h
@@ -65,54 +65,54 @@ class IOStreamBuffer {
 public:
     /// @brief  The class constructor.
     IOStreamBuffer( size_t cache = 4096 * 4096 );
 
     /// @brief  The class destructor.
     ~IOStreamBuffer();
 
     /// @brief  Will open the cached access for a given stream.
     /// @param  stream      The stream to cache.
     /// @return true if successful.
     bool open( IOStream *stream );
 
     /// @brief  Will close the cached access.
     /// @return true if successful.
     bool close();
 
     /// @brief  Returns the file-size.
     /// @return The file-size.
     size_t size() const;
-    
+
     /// @brief  Returns the cache size.
     /// @return The cache size.
     size_t cacheSize() const;
 
     /// @brief  Will read the next block.
     /// @return true if successful.
     bool readNextBlock();
 
     /// @brief  Returns the number of blocks to read.
     /// @return The number of blocks.
     size_t getNumBlocks() const;
 
     /// @brief  Returns the current block index.
     /// @return The current block index.
     size_t getCurrentBlockIndex() const;
 
     /// @brief  Returns the current file pos.
     /// @return The current file pos.
     size_t getFilePos() const;
 
     /// @brief  Will read the next line.
     /// @param  buffer      The buffer for the next line.
     /// @return true if successful.
     bool getNextDataLine( std::vector<T> &buffer, T continuationToken );
 
     /// @brief  Will read the next line ascii or binary end line char.
     /// @param  buffer      The buffer for the next line.
     /// @return true if successful.
     bool getNextLine(std::vector<T> &buffer);
 
     /// @brief  Will read the next block.
     /// @param  buffer      The buffer for the next block.
     /// @return true if successful.
     bool getNextBlock( std::vector<T> &buffer );
@@ -249,38 +249,38 @@ AI_FORCE_INLINE
 bool IOStreamBuffer<T>::getNextDataLine( std::vector<T> &buffer, T continuationToken ) {
     buffer.resize( m_cacheSize );
     if ( m_cachePos >= m_cacheSize || 0 == m_filePos ) {
         if ( !readNextBlock() ) {
             return false;
         }
     }
 
     size_t i = 0;
     for( ;; ) {
         if ( continuationToken == m_cache[ m_cachePos ] && IsLineEnd( m_cache[ m_cachePos + 1 ] ) ) {
             ++m_cachePos;
             while ( m_cache[ m_cachePos ] != '\n' ) {
                 ++m_cachePos;
             }
             ++m_cachePos;
         } else if ( IsLineEnd ( m_cache[ m_cachePos ] ) ) {
             break;
         }
 
         buffer[ i ] = m_cache[ m_cachePos ];
         ++m_cachePos;
         ++i;
         if (m_cachePos >= size()) {
             break;
         }
         if ( m_cachePos >= m_cacheSize ) {
             if ( !readNextBlock() ) {
                 return false;
             }
         }
     }
-    
+
     buffer[ i ] = '\n';
     ++m_cachePos;
 
     return true;
 }
@@ -334,20 +334,20 @@ template<class T>
 AI_FORCE_INLINE
 bool IOStreamBuffer<T>::getNextBlock( std::vector<T> &buffer) {
     // Return the last block-value if getNextLine was used before
-    if ( 0 != m_cachePos ) {      
+    if ( 0 != m_cachePos ) {
         buffer = std::vector<T>( m_cache.begin() + m_cachePos, m_cache.end() );
         m_cachePos = 0;
     } else {
         if ( !readNextBlock() ) {
             return false;
         }
 
         buffer = std::vector<T>(m_cache.begin(), m_cache.end());
     }
 
     return true;
 }
 
 } // !ns Assimp
 
 #endif // AI_IOSTREAMBUFFER_H_INC
diff --git a/include/assimp/IOSystem.hpp b/include/assimp/IOSystem.hpp
index 76f876440..7be373cf1 100644
--- a/include/assimp/IOSystem.hpp
+++ b/include/assimp/IOSystem.hpp
@@ -39,36 +39,36 @@ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ---------------------------------------------------------------------------
 */
 
 /** @file IOSystem.hpp
  *  @brief File system wrapper for C++. Inherit this class to supply
  *  custom file handling logic to the Import library.
 */
 
 #pragma once
 #ifndef AI_IOSYSTEM_H_INC
 #define AI_IOSYSTEM_H_INC
 
 #ifdef __GNUC__
 #   pragma GCC system_header
 #endif
 
 #ifndef __cplusplus
 #   error This header requires C++ to be used. aiFileIO.h is the \
     corresponding C interface.
 #endif
 
 #include "types.h"
 
 #ifdef _WIN32
-#   include <direct.h>  
-#   include <stdlib.h>  
-#   include <stdio.h>  
+#   include <direct.h>
+#   include <stdlib.h>
+#   include <stdio.h>
 #else
 #   include <sys/stat.h>
 #   include <sys/types.h>
 #   include <unistd.h>
 #endif // _WIN32
 
 #include <vector>
@@ -76,15 +76,15 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 namespace Assimp    {
 
     class IOStream;
 
 // ---------------------------------------------------------------------------
 /** @brief CPP-API: Interface to the file system.
  *
  *  Derive an own implementation from this interface to supply custom file handling
  *  to the importer library. If you implement this interface, you also want to
  *  supply a custom implementation for IOStream.
  *
- *  @see Importer::SetIOHandler() 
+ *  @see Importer::SetIOHandler()
  */
 class ASSIMP_API IOSystem
 #ifndef SWIG
diff --git a/include/assimp/Logger.hpp b/include/assimp/Logger.hpp
index 3ca4a6cb2..aa7ffba7c 100644
--- a/include/assimp/Logger.hpp
+++ b/include/assimp/Logger.hpp
@@ -96,90 +96,90 @@ public:
 public:
 
     /** @brief  Virtual destructor */
     virtual ~Logger();
 
     // ----------------------------------------------------------------------
-    /** @brief  Writes a info message
-     *  @param  message Info message*/
+    /** @brief  Writes a debug message
+     *  @param  message Debug message*/
     void debug(const char* message);
 
     template<typename... T>
     void debug(T&&... args) {
         debug(formatMessage(std::forward<T>(args)...).c_str());
     }
 
     // ----------------------------------------------------------------------
-	/** @brief  Writes a debug message
+    /** @brief  Writes a debug message
      *   @param message Debug message*/
     void verboseDebug(const char* message);
-    
+
     template<typename... T>
     void verboseDebug(T&&... args) {
         verboseDebug(formatMessage(std::forward<T>(args)...).c_str());
     }
 
     // ----------------------------------------------------------------------
     /** @brief  Writes a info message
      *  @param  message Info message*/
     void info(const char* message);
 
     template<typename... T>
     void info(T&&... args) {
         info(formatMessage(std::forward<T>(args)...).c_str());
     }
 
     // ----------------------------------------------------------------------
     /** @brief  Writes a warning message
      *  @param  message Warn message*/
     void warn(const char* message);
 
     template<typename... T>
     void warn(T&&... args) {
         warn(formatMessage(std::forward<T>(args)...).c_str());
     }
 
     // ----------------------------------------------------------------------
     /** @brief  Writes an error message
-     *  @param  message Info message*/
+     *  @param  message Error message*/
     void error(const char* message);
 
     template<typename... T>
     void error(T&&... args) {
         error(formatMessage(std::forward<T>(args)...).c_str());
     }
 
     // ----------------------------------------------------------------------
     /** @brief  Set a new log severity.
      *  @param  log_severity New severity for logging*/
     void setLogSeverity(LogSeverity log_severity);
 
     // ----------------------------------------------------------------------
     /** @brief Get the current log severity*/
     LogSeverity getLogSeverity() const;
 
     // ----------------------------------------------------------------------
     /** @brief  Attach a new log-stream
      *
      *  The logger takes ownership of the stream and is responsible
      *  for its destruction (which is done using ::delete when the logger
      *  itself is destroyed). Call detachStream to detach a stream and to
      *  gain ownership of it again.
      *   @param pStream  Log-stream to attach
      *  @param severity  Message filter, specified which types of log
      *    messages are dispatched to the stream. Provide a bitwise
      *    combination of the ErrorSeverity flags.
      *  @return true if the stream has been attached, false otherwise.*/
     virtual bool attachStream(LogStream *pStream,
         unsigned int severity = Debugging | Err | Warn | Info) = 0;
 
     // ----------------------------------------------------------------------
     /** @brief  Detach a still attached stream from the logger (or
      *          modify the filter flags bits)
      *   @param pStream Log-stream instance for detaching
      *  @param severity Provide a bitwise combination of the ErrorSeverity
      *    flags. This value is &~ed with the current flags of the stream,
      *    if the result is 0 the stream is detached from the Logger and
      *    the caller retakes the possession of the stream.
      *  @return true if the stream has been detached, false otherwise.*/
     virtual bool detachStream(LogStream *pStream,
         unsigned int severity = Debugging | Err | Warn | Info) = 0;
diff --git a/include/assimp/MemoryIOWrapper.h b/include/assimp/MemoryIOWrapper.h
index 86dc5ea60..24f6a85d1 100644
--- a/include/assimp/MemoryIOWrapper.h
+++ b/include/assimp/MemoryIOWrapper.h
@@ -57,10 +57,10 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <stdint.h>
 
 namespace Assimp    {
-    
+
 #define AI_MEMORYIO_MAGIC_FILENAME "$$$___magic___$$$"
 #define AI_MEMORYIO_MAGIC_FILENAME_LENGTH 17
 
 // ----------------------------------------------------------------------------------
 /** Implementation of IOStream to read directly from a memory buffer */
 // ----------------------------------------------------------------------------------
@@ -68,76 +68,76 @@ class MemoryIOStream : public IOStream {
 public:
     MemoryIOStream (const uint8_t* buff, size_t len, bool own = false)
     : buffer (buff)
     , length(len)
     , pos((size_t)0)
     , own(own) {
         // empty
     }
 
     ~MemoryIOStream ()  {
         if(own) {
             delete[] buffer;
         }
     }
 
     // -------------------------------------------------------------------
     // Read from stream
     size_t Read(void* pvBuffer, size_t pSize, size_t pCount)    {
         ai_assert(nullptr != pvBuffer);
         ai_assert(0 != pSize);
-        
+
         const size_t cnt = std::min( pCount, (length-pos) / pSize);
         const size_t ofs = pSize * cnt;
 
         ::memcpy(pvBuffer,buffer+pos,ofs);
         pos += ofs;
 
         return cnt;
     }
 
     // -------------------------------------------------------------------
     // Write to stream
     size_t Write(const void* /*pvBuffer*/, size_t /*pSize*/,size_t /*pCount*/)  {
         ai_assert(false); // won't be needed
         return 0;
     }
 
     // -------------------------------------------------------------------
     // Seek specific position
     aiReturn Seek(size_t pOffset, aiOrigin pOrigin) {
         if (aiOrigin_SET == pOrigin) {
             if (pOffset > length) {
                 return AI_FAILURE;
             }
             pos = pOffset;
         } else if (aiOrigin_END == pOrigin) {
             if (pOffset > length) {
                 return AI_FAILURE;
             }
             pos = length-pOffset;
         } else {
             if (pOffset+pos > length) {
                 return AI_FAILURE;
             }
             pos += pOffset;
         }
         return AI_SUCCESS;
     }
 
     // -------------------------------------------------------------------
     // Get current seek position
     size_t Tell() const {
         return pos;
     }
 
     // -------------------------------------------------------------------
     // Get size of file
     size_t FileSize() const {
         return length;
     }
 
     // -------------------------------------------------------------------
     // Flush file contents
     void Flush() {
         ai_assert(false); // won't be needed
     }
@@ -154,86 +154,86 @@ class MemoryIOSystem : public IOSystem {
 public:
     /** Constructor. */
     MemoryIOSystem(const uint8_t* buff, size_t len, IOSystem* io)
     : buffer(buff)
     , length(len)
     , existing_io(io)
     , created_streams() {
         // empty
     }
 
     /** Destructor. */
     ~MemoryIOSystem() {
     }
 
     // -------------------------------------------------------------------
     /** Tests for the existence of a file at the given path. */
     bool Exists(const char* pFile) const override {
         if (0 == strncmp( pFile, AI_MEMORYIO_MAGIC_FILENAME, AI_MEMORYIO_MAGIC_FILENAME_LENGTH ) ) {
             return true;
         }
         return existing_io ? existing_io->Exists(pFile) : false;
     }
 
     // -------------------------------------------------------------------
     /** Returns the directory separator. */
     char getOsSeparator() const override {
         return existing_io ? existing_io->getOsSeparator()
                            : '/';  // why not? it doesn't care
     }
 
     // -------------------------------------------------------------------
     /** Open a new file with a given path. */
     IOStream* Open(const char* pFile, const char* pMode = "rb") override {
         if ( 0 == strncmp( pFile, AI_MEMORYIO_MAGIC_FILENAME, AI_MEMORYIO_MAGIC_FILENAME_LENGTH ) ) {
             created_streams.emplace_back(new MemoryIOStream(buffer, length));
             return created_streams.back();
         }
         return existing_io ? existing_io->Open(pFile, pMode) : NULL;
     }
 
     // -------------------------------------------------------------------
     /** Closes the given file and releases all resources associated with it. */
     void Close( IOStream* pFile) override {
         auto it = std::find(created_streams.begin(), created_streams.end(), pFile);
         if (it != created_streams.end()) {
             delete pFile;
             created_streams.erase(it);
         } else if (existing_io) {
             existing_io->Close(pFile);
         }
     }
 
     // -------------------------------------------------------------------
     /** Compare two paths */
     bool ComparePaths(const char* one, const char* second) const override {
         return existing_io ? existing_io->ComparePaths(one, second) : false;
     }
 
-    bool PushDirectory( const std::string &path ) override { 
+    bool PushDirectory( const std::string &path ) override {
         return existing_io ? existing_io->PushDirectory(path) : false;
     }
 
     const std::string &CurrentDirectory() const override {
         static std::string empty;
         return existing_io ? existing_io->CurrentDirectory() : empty;
     }
 
     size_t StackSize() const override {
         return existing_io ? existing_io->StackSize() : 0;
     }
 
     bool PopDirectory() override {
         return existing_io ? existing_io->PopDirectory() : false;
     }
 
     bool CreateDirectory( const std::string &path ) override {
         return existing_io ? existing_io->CreateDirectory(path) : false;
     }
 
     bool ChangeDirectory( const std::string &path ) override {
         return existing_io ? existing_io->ChangeDirectory(path) : false;
     }
 
     bool DeleteFile( const std::string &file ) override {
         return existing_io ? existing_io->DeleteFile(file) : false;
     }
diff --git a/include/assimp/SmallVector.h b/include/assimp/SmallVector.h
index bcb8482a9..fb78f5a97 100644
--- a/include/assimp/SmallVector.h
+++ b/include/assimp/SmallVector.h
@@ -53,81 +53,81 @@ Based on CppCon 2016: Chandler Carruth "High Performance Code 201: Hybrid Data S
 namespace Assimp {
 
 // --------------------------------------------------------------------------------------------
-/// @brief Small vector with inplace storage. 
+/// @brief Small vector with inplace storage.
 ///
 /// Reduces heap allocations when list is shorter. It uses a small array for a dedicated size.
-/// When the growing gets bigger than this small cache a dynamic growing algorithm will be 
+/// When the growing gets bigger than this small cache a dynamic growing algorithm will be
 /// used.
 // --------------------------------------------------------------------------------------------
 template<typename T, unsigned int Capacity>
 class SmallVector {
 public:
     /// @brief  The default class constructor.
-    SmallVector() : 
+    SmallVector() :
             mStorage(mInplaceStorage),
             mSize(0),
             mCapacity(Capacity) {
         // empty
     }
 
     /// @brief  The class destructor.
     ~SmallVector() {
         if (mStorage != mInplaceStorage) {
             delete [] mStorage;
         }
     }
 
     /// @brief  Will push a new item. The capacity will grow in case of a too small capacity.
     /// @param  item    [in] The item to push at the end of the vector.
     void push_back(const T& item) {
         if (mSize < mCapacity) {
             mStorage[mSize++] = item;
             return;
         }
-        
+
         push_back_and_grow(item);
     }
 
     /// @brief  Will resize the vector.
     /// @param  newSize     [in] The new size.
     void resize(size_t newSize) {
         if (newSize > mCapacity) {
             grow(newSize);
         }
         mSize = newSize;
     }
 
     /// @brief  Returns the current size of the vector.
     /// @return The current size.
     size_t size() const {
         return mSize;
     }
 
     /// @brief  Returns a pointer to the first item.
     /// @return The first item as a pointer.
     T* begin() {
         return mStorage;
     }
 
     /// @brief  Returns a pointer to the end.
     /// @return The end as a pointer.
     T* end() {
         return &mStorage[mSize];
     }
 
     /// @brief  Returns a const pointer to the first item.
     /// @return The first item as a const pointer.
     T* begin() const {
         return mStorage;
     }
 
     /// @brief  Returns a const pointer to the end.
     /// @return The end as a const pointer.
     T* end() const {
         return &mStorage[mSize];
     }
 
     SmallVector(const SmallVector &) = delete;
     SmallVector(SmallVector &&) = delete;
     SmallVector &operator = (const SmallVector &) = delete;
     SmallVector &operator = (SmallVector &&) = delete;
diff --git a/include/assimp/SmoothingGroups.inl b/include/assimp/SmoothingGroups.inl
index a32626e00..08c2dfa53 100644
--- a/include/assimp/SmoothingGroups.inl
+++ b/include/assimp/SmoothingGroups.inl
@@ -7,8 +7,8 @@ Copyright (c) 2006-2021, assimp team
 
 All rights reserved.
 
-Redistribution and use of this software in source and binary forms, 
-with or without modification, are permitted provided that the following 
+Redistribution and use of this software in source and binary forms,
+with or without modification, are permitted provided that the following
 conditions are met:
 
 * Redistributions of source code must retain the above
@@ -25,16 +25,16 @@ conditions are met:
   derived from this software without specific prior
   written permission of the assimp team.
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ---------------------------------------------------------------------------
 */
@@ -60,82 +60,82 @@ template <class T>
 void ComputeNormalsWithSmoothingsGroups(MeshWithSmoothingGroups<T>& sMesh)
 {
     // First generate face normals
     sMesh.mNormals.resize(sMesh.mPositions.size(),aiVector3D());
     for( unsigned int a = 0; a < sMesh.mFaces.size(); a++)
     {
         T& face = sMesh.mFaces[a];
 
         aiVector3D* pV1 = &sMesh.mPositions[face.mIndices[0]];
         aiVector3D* pV2 = &sMesh.mPositions[face.mIndices[1]];
         aiVector3D* pV3 = &sMesh.mPositions[face.mIndices[2]];
 
         aiVector3D pDelta1 = *pV2 - *pV1;
         aiVector3D pDelta2 = *pV3 - *pV1;
         aiVector3D vNor = pDelta1 ^ pDelta2;
 
         for (unsigned int c = 0; c < 3;++c)
             sMesh.mNormals[face.mIndices[c]] = vNor;
     }
 
-    // calculate the position bounds so we have a reliable epsilon to check position differences against 
+    // calculate the position bounds so we have a reliable epsilon to check position differences against
     aiVector3D minVec( 1e10f, 1e10f, 1e10f), maxVec( -1e10f, -1e10f, -1e10f);
     for( unsigned int a = 0; a < sMesh.mPositions.size(); a++)
     {
         minVec.x = std::min( minVec.x, sMesh.mPositions[a].x);
         minVec.y = std::min( minVec.y, sMesh.mPositions[a].y);
         minVec.z = std::min( minVec.z, sMesh.mPositions[a].z);
         maxVec.x = std::max( maxVec.x, sMesh.mPositions[a].x);
         maxVec.y = std::max( maxVec.y, sMesh.mPositions[a].y);
         maxVec.z = std::max( maxVec.z, sMesh.mPositions[a].z);
     }
     const float posEpsilon = (maxVec - minVec).Length() * 1e-5f;
     std::vector<aiVector3D> avNormals;
     avNormals.resize(sMesh.mNormals.size());
-    
+
     // now generate the spatial sort tree
     SGSpatialSort sSort;
     for( typename std::vector<T>::iterator i =  sMesh.mFaces.begin();
         i != sMesh.mFaces.end();++i)
     {
         for (unsigned int c = 0; c < 3;++c)
             sSort.Add(sMesh.mPositions[(*i).mIndices[c]],(*i).mIndices[c],(*i).iSmoothGroup);
     }
     sSort.Prepare();
 
     std::vector<bool> vertexDone(sMesh.mPositions.size(),false);
     for( typename std::vector<T>::iterator i =  sMesh.mFaces.begin();
         i != sMesh.mFaces.end();++i)
     {
         std::vector<unsigned int> poResult;
         for (unsigned int c = 0; c < 3;++c)
         {
             unsigned int idx = (*i).mIndices[c];
             if (vertexDone[idx])continue;
 
             sSort.FindPositions(sMesh.mPositions[idx],(*i).iSmoothGroup,
                 posEpsilon,poResult);
 
             aiVector3D vNormals;
             for (std::vector<unsigned int>::const_iterator
                 a =  poResult.begin();
                 a != poResult.end();++a)
             {
                 vNormals += sMesh.mNormals[(*a)];
             }
             vNormals.NormalizeSafe();
 
             // write back into all affected normals
             for (std::vector<unsigned int>::const_iterator
                 a =  poResult.begin();
                 a != poResult.end();++a)
             {
                 idx = *a;
                 avNormals [idx] = vNormals;
                 vertexDone[idx] = true;
             }
         }
     }
     sMesh.mNormals = avNormals;
 }
 
 #endif // !! AI_SMOOTHINGGROUPS_INL_INCLUDED
diff --git a/include/assimp/XmlParser.h b/include/assimp/XmlParser.h
index 18d48f337..9c2dc419e 100644
--- a/include/assimp/XmlParser.h
+++ b/include/assimp/XmlParser.h
@@ -81,290 +81,290 @@ using XmlNode = pugi::xml_node;
 using XmlAttribute = pugi::xml_attribute;
 
 /// @brief The Xml-Parser class.
 ///
 /// Use this parser if you have to import any kind of xml-format.
 ///
 /// An example:
 /// @code
 /// TXmlParser<XmlNode> theParser;
 /// if (theParser.parse(fileStream)) {
 ///     auto node = theParser.getRootNode();
 ///     for ( auto currentNode : node.children()) {
 ///         // Will loop over all children
 ///     }
 /// }
 /// @endcode
-/// @tparam TNodeType 
+/// @tparam TNodeType
 template <class TNodeType>
 class TXmlParser {
 public:
     /// @brief The default class constructor.
     TXmlParser() :
             mDoc(nullptr),
             mData() {
         // empty
     }
 
     ///	@brief  The class destructor.
     ~TXmlParser() {
         clear();
     }
 
     ///	@brief  Will clear the parsed xml-file.
     void clear() {
         if(mData.empty()) {
             mDoc = nullptr;
             return;
         }
         mData.clear();
         delete mDoc;
         mDoc = nullptr;
     }
 
     ///	@brief  Will search for a child-node by its name
     /// @param  name     [in] The name of the child-node.
-    /// @return The node instance or nullptr, if nothing was found.   
+    /// @return The node instance or nullptr, if nothing was found.
     TNodeType *findNode(const std::string &name) {
         if (name.empty()) {
             return nullptr;
         }
 
         if (nullptr == mDoc) {
             return nullptr;
         }
 
         find_node_by_name_predicate predicate(name);
         mCurrent = mDoc->find_node(predicate);
         if (mCurrent.empty()) {
             return nullptr;
         }
 
         return &mCurrent;
     }
 
     /// @brief  Will return true, if the node is a child-node.
     /// @param  name    [in] The name of the child node to look for.
     /// @return true, if the node is a child-node or false if not.
     bool hasNode(const std::string &name) {
         return nullptr != findNode(name);
     }
 
     /// @brief  Will parse an xml-file from a given stream.
     /// @param  stream      The input stream.
     /// @return true, if the parsing was successful, false if not.
     bool parse(IOStream *stream) {
         if (nullptr == stream) {
             ASSIMP_LOG_DEBUG("Stream is nullptr.");
             return false;
         }
 
         const size_t len = stream->FileSize();
         mData.resize(len + 1);
         memset(&mData[0], '\0', len + 1);
         stream->Read(&mData[0], 1, len);
-        
+
         mDoc = new pugi::xml_document();
         pugi::xml_parse_result parse_result = mDoc->load_string(&mData[0], pugi::parse_full);
         if (parse_result.status == pugi::status_ok) {
             return true;
-        } 
+        }
 
         ASSIMP_LOG_DEBUG("Error while parse xml.", std::string(parse_result.description()), " @ ", parse_result.offset);
 
         return false;
     }
 
     /// @brief  Will return truem if a root node is there.
     /// @return true in case of an existing root.
     bool hasRoot() const {
         return nullptr != mDoc;
     }
     /// @brief  Will return the document pointer, is nullptr if no xml-file was parsed.
     /// @return The pointer showing to the document.
     pugi::xml_document *getDocument() const {
         return mDoc;
     }
 
     /// @brief  Will return the root node, const version.
     /// @return The root node.
     const TNodeType getRootNode() const {
         static pugi::xml_node none;
         if (nullptr == mDoc) {
             return none;
         }
         return mDoc->root();
     }
 
     /// @brief  Will return the root node, non-const version.
     /// @return The root node.
     TNodeType getRootNode() {
         static pugi::xml_node none;
         if (nullptr == mDoc) {
             return none;
         }
         return mDoc->root();
     }
 
     /// @brief Will check if a node with the given name is in.
     /// @param node     [in] The node to look in.
     /// @param name     [in] The name of the child-node.
     /// @return true, if node was found, false if not.
     static inline bool hasNode(XmlNode &node, const char *name) {
         pugi::xml_node child = node.find_child(find_node_by_name_predicate(name));
         return !child.empty();
     }
 
     /// @brief Will check if an attribute is part of the XmlNode.
     /// @param xmlNode  [in] The node to search in.
     /// @param name     [in} The attribute name to look for.
     /// @return true, if the was found, false if not.
     static inline bool hasAttribute(XmlNode &xmlNode, const char *name) {
         pugi::xml_attribute attr = xmlNode.attribute(name);
         return !attr.empty();
     }
 
     /// @brief Will try to get an unsigned int attribute value.
     /// @param xmlNode  [in] The node to search in.
     /// @param name     [in] The attribute name to look for.
     /// @param val      [out] The unsigned int value from the attribute.
     /// @return true, if the node contains an attribute with the given name and if the value is an unsigned int.
     static inline bool getUIntAttribute(XmlNode &xmlNode, const char *name, unsigned int &val) {
         pugi::xml_attribute attr = xmlNode.attribute(name);
         if (attr.empty()) {
             return false;
         }
 
         val = attr.as_uint();
         return true;
     }
 
     /// @brief Will try to get an int attribute value.
     /// @param xmlNode  [in] The node to search in.
     /// @param name     [in] The attribute name to look for.
     /// @param val      [out] The int value from the attribute.
     /// @return true, if the node contains an attribute with the given name and if the value is an int.
     static inline bool getIntAttribute(XmlNode &xmlNode, const char *name, int &val ) {
         pugi::xml_attribute attr = xmlNode.attribute(name);
         if (attr.empty()) {
             return false;
         }
 
         val = attr.as_int();
         return true;
     }
 
     /// @brief Will try to get a real attribute value.
     /// @param xmlNode  [in] The node to search in.
     /// @param name     [in] The attribute name to look for.
     /// @param val      [out] The real value from the attribute.
     /// @return true, if the node contains an attribute with the given name and if the value is a real.
     static inline bool getRealAttribute( XmlNode &xmlNode, const char *name, ai_real &val ) {
         pugi::xml_attribute attr = xmlNode.attribute(name);
         if (attr.empty()) {
             return false;
         }
 #ifdef ASSIMP_DOUBLE_PRECISION
         val = attr.as_double();
 #else
         val = attr.as_float();
 #endif
         return true;
     }
 
     /// @brief Will try to get a float attribute value.
     /// @param xmlNode  [in] The node to search in.
     /// @param name     [in] The attribute name to look for.
     /// @param val      [out] The float value from the attribute.
     /// @return true, if the node contains an attribute with the given name and if the value is a float.
     static inline bool getFloatAttribute(XmlNode &xmlNode, const char *name, float &val) {
         pugi::xml_attribute attr = xmlNode.attribute(name);
         if (attr.empty()) {
             return false;
         }
 
         val = attr.as_float();
         return true;
 
     }
 
     /// @brief Will try to get a double attribute value.
     /// @param xmlNode  [in] The node to search in.
     /// @param name     [in] The attribute name to look for.
     /// @param val      [out] The double value from the attribute.
     /// @return true, if the node contains an attribute with the given name and if the value is a double.
     static inline bool getDoubleAttribute(XmlNode &xmlNode, const char *name, double &val) {
         pugi::xml_attribute attr = xmlNode.attribute(name);
         if (attr.empty()) {
             return false;
         }
 
         val = attr.as_double();
         return true;
     }
 
     /// @brief Will try to get a std::string attribute value.
     /// @param xmlNode  [in] The node to search in.
     /// @param name     [in] The attribute name to look for.
     /// @param val      [out] The std::string value from the attribute.
     /// @return true, if the node contains an attribute with the given name and if the value is a std::string.
     static inline bool getStdStrAttribute(XmlNode &xmlNode, const char *name, std::string &val) {
         pugi::xml_attribute attr = xmlNode.attribute(name);
         if (attr.empty()) {
             return false;
         }
 
         val = attr.as_string();
         return true;
     }
 
     /// @brief Will try to get a bool attribute value.
     /// @param xmlNode  [in] The node to search in.
     /// @param name     [in] The attribute name to look for.
     /// @param val      [out] The bool value from the attribute.
     /// @return true, if the node contains an attribute with the given name and if the value is a bool.
     static inline bool getBoolAttribute( XmlNode &xmlNode, const char *name, bool &val ) {
         pugi::xml_attribute attr = xmlNode.attribute(name);
         if (attr.empty()) {
             return false;
         }
 
         val = attr.as_bool();
         return true;
 
     }
 
     /// @brief Will try to get the value of the node as a string.
     /// @param node     [in] The node to search in.
     /// @param text     [out] The value as a text.
     /// @return true, if the value can be read out.
     static inline bool getValueAsString( XmlNode &node, std::string &text ) {
         text = std::string();
         if (node.empty()) {
             return false;
         }
 
         text = node.text().as_string();
 
         return true;
     }
 
     /// @brief Will try to get the value of the node as a float.
     /// @param node     [in] The node to search in.
     /// @param text     [out] The value as a float.
     /// @return true, if the value can be read out.
     static inline bool getValueAsFloat( XmlNode &node, ai_real &v ) {
         if (node.empty()) {
             return false;
         }
 
         v = node.text().as_float();
 
         return true;
 
     }
 
  private:
     pugi::xml_document *mDoc;
     TNodeType mCurrent;
     std::vector<char> mData;
 };
@@ -457,11 +457,11 @@ public:
     }
 
 private:
-    XmlNode &mParent; 
+    XmlNode &mParent;
     std::vector<XmlNode> mNodes;
     size_t mIndex;
 };
 
 } // namespace Assimp
 
 #endif // !! INCLUDED_AI_IRRXML_WRAPPER
diff --git a/include/assimp/ai_assert.h b/include/assimp/ai_assert.h
index 6736b24c9..b377b6e8b 100644
--- a/include/assimp/ai_assert.h
+++ b/include/assimp/ai_assert.h
@@ -49,16 +49,16 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 namespace Assimp
 {
     // Assert violation behavior can be customized: see AssertHandler.h.
     ASSIMP_API void aiAssertViolation(const char* failedExpression, const char* file, int line);
 }
 
 #    define ai_assert(expression) (void)((!!(expression)) || (Assimp::aiAssertViolation(#expression, __FILE__, __LINE__), 0))
 #    define ai_assert_entry() ai_assert(false)
 
 #else
 #   define  ai_assert(expression)
-#   define  ai_assert_entry() 
+#   define  ai_assert_entry()
 #endif // ASSIMP_BUILD_DEBUG
 
 #endif // AI_ASSERT_H_INC
 
diff --git a/include/assimp/anim.h b/include/assimp/anim.h
index 79841a537..dcd054d1e 100644
--- a/include/assimp/anim.h
+++ b/include/assimp/anim.h
@@ -37,22 +37,22 @@ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ---------------------------------------------------------------------------
 */
 
-/** 
+/**
   * @file   anim.h
   * @brief  Defines the data structures in which the imported animations
   *         are returned.
   */
 #pragma once
 #ifndef AI_ANIM_H_INC
 #define AI_ANIM_H_INC
 
 #ifdef __GNUC__
 #pragma GCC system_header
 #endif
 
 #include <assimp/quaternion.h>
 #include <assimp/types.h>
 
 #ifdef __cplusplus
@@ -477,12 +477,12 @@ struct aiAnimation {
 /// @brief  Some C++ utilities for inter- and extrapolation
 namespace Assimp {
 
 // ---------------------------------------------------------------------------
-/** 
+/**
   * @brief CPP-API: Utility class to simplify interpolations of various data types.
   *
   *  The type of interpolation is chosen automatically depending on the
-  *  types of the arguments. 
+  *  types of the arguments.
   */
 template <typename T>
 struct Interpolator {
diff --git a/include/assimp/cimport.h b/include/assimp/cimport.h
index b4a172742..d660eebb1 100644
--- a/include/assimp/cimport.h
+++ b/include/assimp/cimport.h
@@ -888,42 +888,42 @@ ASSIMP_API void aiMatrix3Inverse(
 // --------------------------------------------------------------------------------
 /** Get the determinant of a 3x3 matrix.
  *  @param mat Matrix to get the determinant from
  */
 ASSIMP_API float aiMatrix3Determinant(
         const C_STRUCT aiMatrix3x3 *mat);
 
 // --------------------------------------------------------------------------------
 /** Get a 3x3 rotation matrix around the Z axis.
- *  @param mat Receives the output matrix 
+ *  @param mat Receives the output matrix
  *  @param angle Rotation angle, in radians
  */
 ASSIMP_API void aiMatrix3RotationZ(
         C_STRUCT aiMatrix3x3 *mat,
         const float angle);
 
 // --------------------------------------------------------------------------------
 /** Returns a 3x3 rotation matrix for a rotation around an arbitrary axis.
- *  @param mat Receives the output matrix 
+ *  @param mat Receives the output matrix
  *  @param axis Rotation axis, should be a normalized vector
  *  @param angle Rotation angle, in radians
  */
 ASSIMP_API void aiMatrix3FromRotationAroundAxis(
         C_STRUCT aiMatrix3x3 *mat,
         const C_STRUCT aiVector3D *axis,
         const float angle);
 
 // --------------------------------------------------------------------------------
 /** Get a 3x3 translation matrix.
- *  @param mat Receives the output matrix 
+ *  @param mat Receives the output matrix
  *  @param translation The translation vector
  */
 ASSIMP_API void aiMatrix3Translation(
         C_STRUCT aiMatrix3x3 *mat,
         const C_STRUCT aiVector2D *translation);
 
 // --------------------------------------------------------------------------------
 /** Create a 3x3 matrix that rotates one vector to another vector.
- *  @param mat Receives the output matrix 
+ *  @param mat Receives the output matrix
  *  @param from Vector to rotate from
  *  @param to Vector to rotate to
  */
@@ -1047,20 +1047,20 @@ ASSIMP_API void aiMatrix4DecomposeIntoScalingAxisAnglePosition(
 // --------------------------------------------------------------------------------
 /** Decompose a transformation matrix into its rotational and
  *  translational components.
  *
  * @param mat Matrix to decompose
  * @param rotation Receives the rotational component
  * @param position Receives the translational component.
  */
 ASSIMP_API void aiMatrix4DecomposeNoScaling(
         const C_STRUCT aiMatrix4x4 *mat,
         C_STRUCT aiQuaternion *rotation,
         C_STRUCT aiVector3D *position);
 
 // --------------------------------------------------------------------------------
 /** Creates a 4x4 matrix from a set of euler angles.
- *  @param mat Receives the output matrix 
+ *  @param mat Receives the output matrix
  *  @param x Rotation angle for the x-axis, in radians
  *  @param y Rotation angle for the y-axis, in radians
  *  @param z Rotation angle for the z-axis, in radians
  */
@@ -1127,18 +1127,18 @@ ASSIMP_API void aiMatrix4Scaling(
 // --------------------------------------------------------------------------------
 /** Create a 4x4 matrix that rotates one vector to another vector.
  *  @param mat Receives the output matrix
  *  @param from Vector to rotate from
  *  @param to Vector to rotate to
  */
 ASSIMP_API void aiMatrix4FromTo(
         C_STRUCT aiMatrix4x4 *mat,
         const C_STRUCT aiVector3D *from,
         const C_STRUCT aiVector3D *to);
 
 // --------------------------------------------------------------------------------
 /** Create a Quaternion from euler angles.
- *  @param q Receives the output quaternion 
+ *  @param q Receives the output quaternion
  *  @param x Rotation angle for the x-axis, in radians
  *  @param y Rotation angle for the y-axis, in radians
  *  @param z Rotation angle for the z-axis, in radians
  */
diff --git a/include/assimp/defs.h b/include/assimp/defs.h
index d61fd7901..8d1011a28 100644
--- a/include/assimp/defs.h
+++ b/include/assimp/defs.h
@@ -37,206 +37,206 @@ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ---------------------------------------------------------------------------
 */
 
 /** @file defs.h
  *  @brief Assimp build configuration setup. See the notes in the comment
  *  blocks to find out how to customize _your_ Assimp build.
  */
 
 #pragma once
 #ifndef AI_DEFINES_H_INC
 #define AI_DEFINES_H_INC
 
 #ifdef __GNUC__
 #pragma GCC system_header
 #endif
 
 #include <assimp/config.h>
 
 //////////////////////////////////////////////////////////////////////////
 /* Define ASSIMP_BUILD_NO_XX_IMPORTER to disable a specific
  * file format loader. The loader is be excluded from the
  * build in this case. 'XX' stands for the most common file
  * extension of the file format. E.g.:
  * ASSIMP_BUILD_NO_X_IMPORTER disables the X loader.
  *
  * If you're unsure about that, take a look at the implementation of the
  * import plugin you wish to disable. You'll find the right define in the
  * first lines of the corresponding unit.
  *
  * Other (mixed) configuration switches are listed here:
  *    ASSIMP_BUILD_NO_COMPRESSED_X
  *      - Disable support for compressed X files (zip)
  *    ASSIMP_BUILD_NO_COMPRESSED_BLEND
  *      - Disable support for compressed Blender files (zip)
  *    ASSIMP_BUILD_NO_COMPRESSED_IFC
  *      - Disable support for IFCZIP files (unzip)
  */
 //////////////////////////////////////////////////////////////////////////
 
 #ifndef ASSIMP_BUILD_NO_COMPRESSED_X
 #define ASSIMP_BUILD_NEED_Z_INFLATE
 #endif
 
 #ifndef ASSIMP_BUILD_NO_COMPRESSED_BLEND
 #define ASSIMP_BUILD_NEED_Z_INFLATE
 #endif
 
 #ifndef ASSIMP_BUILD_NO_COMPRESSED_IFC
 #define ASSIMP_BUILD_NEED_Z_INFLATE
 #define ASSIMP_BUILD_NEED_UNZIP
 #endif
 
 #ifndef ASSIMP_BUILD_NO_Q3BSP_IMPORTER
 #define ASSIMP_BUILD_NEED_Z_INFLATE
 #define ASSIMP_BUILD_NEED_UNZIP
 #endif
 
 //////////////////////////////////////////////////////////////////////////
 /* Define ASSIMP_BUILD_NO_XX_PROCESS to disable a specific
  * post processing step. This is the current list of process names ('XX'):
  * CALCTANGENTS
  * JOINVERTICES
  * TRIANGULATE
  * DROPFACENORMALS
  * GENFACENORMALS
  * GENVERTEXNORMALS
  * REMOVEVC
  * SPLITLARGEMESHES
  * PRETRANSFORMVERTICES
  * LIMITBONEWEIGHTS
  * VALIDATEDS
  * IMPROVECACHELOCALITY
  * FIXINFACINGNORMALS
  * REMOVE_REDUNDANTMATERIALS
  * OPTIMIZEGRAPH
  * SORTBYPTYPE
  * FINDINVALIDDATA
  * TRANSFORMTEXCOORDS
  * GENUVCOORDS
  * ENTITYMESHBUILDER
  * EMBEDTEXTURES
  * MAKELEFTHANDED
  * FLIPUVS
  * FLIPWINDINGORDER
  * OPTIMIZEMESHES
  * OPTIMIZEANIMS
  * OPTIMIZEGRAPH
  * GENENTITYMESHES
  * FIXTEXTUREPATHS
  * GENBOUNDINGBOXES */
 //////////////////////////////////////////////////////////////////////////
 
 #ifdef _WIN32
 #undef ASSIMP_API
 //////////////////////////////////////////////////////////////////////////
 /* Define 'ASSIMP_BUILD_DLL_EXPORT' to build a DLL of the library */
 //////////////////////////////////////////////////////////////////////////
 #ifdef ASSIMP_BUILD_DLL_EXPORT
 #define ASSIMP_API __declspec(dllexport)
 #define ASSIMP_API_WINONLY __declspec(dllexport)
 
 //////////////////////////////////////////////////////////////////////////
 /* Define 'ASSIMP_DLL' before including Assimp to link to ASSIMP in
      * an external DLL under Windows. Default is static linkage. */
 //////////////////////////////////////////////////////////////////////////
 #elif (defined ASSIMP_DLL)
 #define ASSIMP_API __declspec(dllimport)
 #define ASSIMP_API_WINONLY __declspec(dllimport)
 #else
 #define ASSIMP_API
 #define ASSIMP_API_WINONLY
 #endif
 #elif defined(SWIG)
 /* Do nothing, the relevant defines are all in AssimpSwigPort.i */
 #else
 #define ASSIMP_API __attribute__((visibility("default")))
 #define ASSIMP_API_WINONLY
 #endif // _WIN32
 
 #ifdef _MSC_VER
   #pragma warning(disable : 4521 4512 4714 4127 4351 4510)
   #ifdef ASSIMP_BUILD_DLL_EXPORT
     #pragma warning(disable : 4251)
   #endif
   /* Force the compiler to inline a function, if possible */
-  #define AI_FORCE_INLINE inline 
+  #define AI_FORCE_INLINE inline
 
   /* Tells the compiler that a function never returns. Used in code analysis
    * to skip dead paths (e.g. after an assertion evaluated to false). */
   #define AI_WONT_RETURN __declspec(noreturn)
 #elif defined(SWIG)
   /* Do nothing, the relevant defines are all in AssimpSwigPort.i */
 #else
   #define AI_WONT_RETURN
   #define AI_FORCE_INLINE inline
 #endif // (defined _MSC_VER)
 
 #ifdef __GNUC__
 #define AI_WONT_RETURN_SUFFIX __attribute__((noreturn))
 #else
 #define AI_WONT_RETURN_SUFFIX
 #endif // (defined __clang__)
 
 #ifdef __cplusplus
 /* No explicit 'struct' and 'enum' tags for C++, this keeps showing up
      * in doxydocs.
      */
 #define C_STRUCT
 #define C_ENUM
 #else
 //////////////////////////////////////////////////////////////////////////
 /* To build the documentation, make sure ASSIMP_DOXYGEN_BUILD
      * is defined by Doxygen's preprocessor. The corresponding
      * entries in the DOXYFILE are: */
 //////////////////////////////////////////////////////////////////////////
 #if 0
     ENABLE_PREPROCESSING   = YES
     MACRO_EXPANSION        = YES
     EXPAND_ONLY_PREDEF     = YES
     SEARCH_INCLUDES        = YES
     INCLUDE_PATH           =
     INCLUDE_FILE_PATTERNS  =
     PREDEFINED             = ASSIMP_DOXYGEN_BUILD=1
     EXPAND_AS_DEFINED      = C_STRUCT C_ENUM
     SKIP_FUNCTION_MACROS   = YES
 #endif
 //////////////////////////////////////////////////////////////////////////
 /* Doxygen gets confused if we use c-struct typedefs to avoid
      * the explicit 'struct' notation. This trick here has the same
      * effect as the TYPEDEF_HIDES_STRUCT option, but we don't need
      * to typedef all structs/enums. */
 //////////////////////////////////////////////////////////////////////////
 #if (defined ASSIMP_DOXYGEN_BUILD)
 #define C_STRUCT
 #define C_ENUM
 #else
 #define C_STRUCT struct
 #define C_ENUM enum
 #endif
 #endif
 
 #if (defined(__BORLANDC__) || defined(__BCPLUSPLUS__))
 #error Currently, Borland is unsupported. Feel free to port Assimp.
 #endif
 
 //////////////////////////////////////////////////////////////////////////
 /* Define ASSIMP_BUILD_SINGLETHREADED to compile assimp
      * without threading support. The library doesn't utilize
      * threads then and is itself not threadsafe. */
 //////////////////////////////////////////////////////////////////////////
 #ifndef ASSIMP_BUILD_SINGLETHREADED
 #define ASSIMP_BUILD_SINGLETHREADED
 #endif
 
 #if defined(_DEBUG) || !defined(NDEBUG)
 #define ASSIMP_BUILD_DEBUG
 #endif
 
 //////////////////////////////////////////////////////////////////////////
 /* Define ASSIMP_DOUBLE_PRECISION to compile assimp
      * with double precision support (64-bit). */
 //////////////////////////////////////////////////////////////////////////
 
 #ifdef ASSIMP_DOUBLE_PRECISION
diff --git a/include/assimp/fast_atof.h b/include/assimp/fast_atof.h
index aea793f35..43bbbff64 100644
--- a/include/assimp/fast_atof.h
+++ b/include/assimp/fast_atof.h
@@ -191,52 +191,52 @@ inline
 uint64_t strtoul10_64( const char* in, const char** out=0, unsigned int* max_inout=0) {
     unsigned int cur = 0;
     uint64_t value = 0;
 
     if ( *in < '0' || *in > '9' ) {
         // The string is known to be bad, so don't risk printing the whole thing.
-        throw ExceptionType("The string \"", ai_str_toprintable(in, 30), "\" cannot be converted into a value." );
+        throw ExceptionType("The string \"", ai_str_toprintable(in, (int)strlen(in)), "\" cannot be converted into a value." );
     }
 
     for ( ;; ) {
         if ( *in < '0' || *in > '9' ) {
             break;
         }
 
         const uint64_t new_value = ( value * (uint64_t) 10 ) + ( (uint64_t) ( *in - '0' ) );
 
         // numeric overflow, we rely on you
         if ( new_value < value ) {
             ASSIMP_LOG_WARN( "Converting the string \"", in, "\" into a value resulted in overflow." );
             return 0;
         }
 
         value = new_value;
 
         ++in;
         ++cur;
 
         if (max_inout && *max_inout == cur) {
             if (out) { /* skip to end */
                 while ( *in >= '0' && *in <= '9' ) {
                     ++in;
                 }
                 *out = in;
             }
 
             return value;
         }
     }
     if ( out ) {
         *out = in;
     }
 
     if ( max_inout ) {
         *max_inout = cur;
     }
 
     return value;
 }
 
 // ------------------------------------------------------------------------------------
 // signed variant of strtoul10_64
 // ------------------------------------------------------------------------------------
@@ -268,88 +268,88 @@ inline
 const char* fast_atoreal_move(const char* c, Real& out, bool check_comma = true) {
     Real f = 0;
 
     bool inv = (*c == '-');
     if (inv || *c == '+') {
         ++c;
     }
 
     if ((c[0] == 'N' || c[0] == 'n') && ASSIMP_strincmp(c, "nan", 3) == 0) {
         out = std::numeric_limits<Real>::quiet_NaN();
         c += 3;
         return c;
     }
 
     if ((c[0] == 'I' || c[0] == 'i') && ASSIMP_strincmp(c, "inf", 3) == 0) {
         out = std::numeric_limits<Real>::infinity();
         if (inv) {
             out = -out;
         }
         c += 3;
         if ((c[0] == 'I' || c[0] == 'i') && ASSIMP_strincmp(c, "inity", 5) == 0) {
             c += 5;
         }
         return c;
      }
 
     if (!(c[0] >= '0' && c[0] <= '9') &&
             !((c[0] == '.' || (check_comma && c[0] == ',')) && c[1] >= '0' && c[1] <= '9')) {
         // The string is known to be bad, so don't risk printing the whole thing.
-        throw ExceptionType("Cannot parse string \"", ai_str_toprintable(c, 30),
+        throw ExceptionType("Cannot parse string \"", ai_str_toprintable(c, (int)strlen(c)),
                                     "\" as a real number: does not start with digit "
                                     "or decimal point followed by digit.");
     }
 
     if (*c != '.' && (! check_comma || c[0] != ',')) {
         f = static_cast<Real>( strtoul10_64<ExceptionType> ( c, &c) );
     }
 
     if ((*c == '.' || (check_comma && c[0] == ',')) && c[1] >= '0' && c[1] <= '9') {
         ++c;
 
         // NOTE: The original implementation is highly inaccurate here. The precision of a single
         // IEEE 754 float is not high enough, everything behind the 6th digit tends to be more
         // inaccurate than it would need to be. Casting to double seems to solve the problem.
         // strtol_64 is used to prevent integer overflow.
 
         // Another fix: this tends to become 0 for long numbers if we don't limit the maximum
         // number of digits to be read. AI_FAST_ATOF_RELAVANT_DECIMALS can be a value between
         // 1 and 15.
         unsigned int diff = AI_FAST_ATOF_RELAVANT_DECIMALS;
         double pl = static_cast<double>( strtoul10_64<ExceptionType> ( c, &c, &diff ));
 
         pl *= fast_atof_table[diff];
         f += static_cast<Real>( pl );
     }
     // For backwards compatibility: eat trailing dots, but not trailing commas.
     else if (*c == '.') {
         ++c;
     }
 
     // A major 'E' must be allowed. Necessary for proper reading of some DXF files.
     // Thanks to Zhao Lei to point out that this if() must be outside the if (*c == '.' ..)
     if (*c == 'e' || *c == 'E') {
         ++c;
         const bool einv = (*c=='-');
         if (einv || *c=='+') {
             ++c;
         }
 
         // The reason float constants are used here is that we've seen cases where compilers
         // would perform such casts on compile-time constants at runtime, which would be
         // bad considering how frequently fast_atoreal_move<float> is called in Assimp.
         Real exp = static_cast<Real>( strtoul10_64<ExceptionType>(c, &c) );
         if (einv) {
             exp = -exp;
         }
         f *= std::pow(static_cast<Real>(10.0), exp);
     }
 
     if (inv) {
         f = -f;
     }
     out = f;
     return c;
 }
 
 // ------------------------------------------------------------------------------------
 // The same but more human.
diff --git a/include/assimp/light.h b/include/assimp/light.h
index bc37de43a..48efdaebd 100644
--- a/include/assimp/light.h
+++ b/include/assimp/light.h
@@ -105,159 +105,159 @@ enum aiLightSourceType
 // ---------------------------------------------------------------------------
 /** Helper structure to describe a light source.
  *
  *  Assimp supports multiple sorts of light sources, including
  *  directional, point and spot lights. All of them are defined with just
  *  a single structure and distinguished by their parameters.
  *  Note - some file formats (such as 3DS, ASE) export a "target point" -
  *  the point a spot light is looking at (it can even be animated). Assimp
  *  writes the target point as a subnode of a spotlights's main node,
  *  called "<spotName>.Target". However, this is just additional information
  *  then, the transformation tracks of the main node make the
  *  spot light already point in the right direction.
 */
 struct aiLight
 {
     /** The name of the light source.
      *
      *  There must be a node in the scenegraph with the same name.
      *  This node specifies the position of the light in the scene
      *  hierarchy and can be animated.
      */
     C_STRUCT aiString mName;
 
     /** The type of the light source.
      *
      * aiLightSource_UNDEFINED is not a valid value for this member.
      */
     C_ENUM aiLightSourceType mType;
 
     /** Position of the light source in space. Relative to the
      *  transformation of the node corresponding to the light.
      *
      *  The position is undefined for directional lights.
      */
     C_STRUCT aiVector3D mPosition;
 
     /** Direction of the light source in space. Relative to the
      *  transformation of the node corresponding to the light.
      *
      *  The direction is undefined for point lights. The vector
      *  may be normalized, but it needn't.
      */
     C_STRUCT aiVector3D mDirection;
 
     /** Up direction of the light source in space. Relative to the
      *  transformation of the node corresponding to the light.
      *
      *  The direction is undefined for point lights. The vector
      *  may be normalized, but it needn't.
      */
     C_STRUCT aiVector3D mUp;
 
     /** Constant light attenuation factor.
      *
      *  The intensity of the light source at a given distance 'd' from
      *  the light's position is
      *  @code
      *  Atten = 1/( att0 + att1 * d + att2 * d*d)
      *  @endcode
      *  This member corresponds to the att0 variable in the equation.
      *  Naturally undefined for directional lights.
      */
     float mAttenuationConstant;
 
     /** Linear light attenuation factor.
      *
      *  The intensity of the light source at a given distance 'd' from
      *  the light's position is
      *  @code
      *  Atten = 1/( att0 + att1 * d + att2 * d*d)
      *  @endcode
      *  This member corresponds to the att1 variable in the equation.
      *  Naturally undefined for directional lights.
      */
     float mAttenuationLinear;
 
     /** Quadratic light attenuation factor.
      *
      *  The intensity of the light source at a given distance 'd' from
      *  the light's position is
      *  @code
      *  Atten = 1/( att0 + att1 * d + att2 * d*d)
      *  @endcode
      *  This member corresponds to the att2 variable in the equation.
      *  Naturally undefined for directional lights.
      */
     float mAttenuationQuadratic;
 
     /** Diffuse color of the light source
      *
      *  The diffuse light color is multiplied with the diffuse
      *  material color to obtain the final color that contributes
      *  to the diffuse shading term.
      */
     C_STRUCT aiColor3D mColorDiffuse;
 
     /** Specular color of the light source
      *
      *  The specular light color is multiplied with the specular
      *  material color to obtain the final color that contributes
      *  to the specular shading term.
      */
     C_STRUCT aiColor3D mColorSpecular;
 
     /** Ambient color of the light source
      *
      *  The ambient light color is multiplied with the ambient
      *  material color to obtain the final color that contributes
      *  to the ambient shading term. Most renderers will ignore
      *  this value it, is just a remaining of the fixed-function pipeline
      *  that is still supported by quite many file formats.
      */
     C_STRUCT aiColor3D mColorAmbient;
 
     /** Inner angle of a spot light's light cone.
      *
      *  The spot light has maximum influence on objects inside this
      *  angle. The angle is given in radians. It is 2PI for point
      *  lights and undefined for directional lights.
      */
     float mAngleInnerCone;
 
     /** Outer angle of a spot light's light cone.
      *
      *  The spot light does not affect objects outside this angle.
      *  The angle is given in radians. It is 2PI for point lights and
      *  undefined for directional lights. The outer angle must be
      *  greater than or equal to the inner angle.
      *  It is assumed that the application uses a smooth
      *  interpolation between the inner and the outer cone of the
      *  spot light.
      */
     float mAngleOuterCone;
 
     /** Size of area light source. */
     C_STRUCT aiVector2D mSize;
 
 #ifdef __cplusplus
 
     aiLight() AI_NO_EXCEPT
         :   mType                 (aiLightSource_UNDEFINED)
         ,   mAttenuationConstant  (0.f)
         ,   mAttenuationLinear    (1.f)
         ,   mAttenuationQuadratic (0.f)
         ,   mAngleInnerCone       ((float)AI_MATH_TWO_PI)
         ,   mAngleOuterCone       ((float)AI_MATH_TWO_PI)
         ,   mSize                 (0.f, 0.f)
     {
     }
 
 #endif
 };
 
 #ifdef __cplusplus
 }
-#endif 
+#endif
 
 
 #endif // !! AI_LIGHT_H_INC
diff --git a/include/assimp/material.h b/include/assimp/material.h
index f0207c6de..250ad90d5 100644
--- a/include/assimp/material.h
+++ b/include/assimp/material.h
@@ -173,182 +173,182 @@ enum aiTextureMapping {
 // ---------------------------------------------------------------------------
 /** @brief Defines the purpose of a texture
  *
  *  This is a very difficult topic. Different 3D packages support different
  *  kinds of textures. For very common texture types, such as bumpmaps, the
  *  rendering results depend on implementation details in the rendering
  *  pipelines of these applications. Assimp loads all texture references from
  *  the model file and tries to determine which of the predefined texture
  *  types below is the best choice to match the original use of the texture
  *  as closely as possible.<br>
  *
  *  In content pipelines you'll usually define how textures have to be handled,
  *  and the artists working on models have to conform to this specification,
  *  regardless which 3D tool they're using.
  */
 enum aiTextureType {
     /** Dummy value.
      *
      *  No texture, but the value to be used as 'texture semantic'
      *  (#aiMaterialProperty::mSemantic) for all material properties
      *  *not* related to textures.
      */
     aiTextureType_NONE = 0,
 
-    /** LEGACY API MATERIALS 
-     * Legacy refers to materials which 
+    /** LEGACY API MATERIALS
+     * Legacy refers to materials which
      * Were originally implemented in the specifications around 2000.
      * These must never be removed, as most engines support them.
      */
 
     /** The texture is combined with the result of the diffuse
      *  lighting equation.
      *  OR
      *  PBR Specular/Glossiness
      */
     aiTextureType_DIFFUSE = 1,
 
     /** The texture is combined with the result of the specular
      *  lighting equation.
      *  OR
      *  PBR Specular/Glossiness
      */
     aiTextureType_SPECULAR = 2,
 
     /** The texture is combined with the result of the ambient
      *  lighting equation.
      */
     aiTextureType_AMBIENT = 3,
 
     /** The texture is added to the result of the lighting
      *  calculation. It isn't influenced by incoming light.
      */
     aiTextureType_EMISSIVE = 4,
 
     /** The texture is a height map.
      *
      *  By convention, higher gray-scale values stand for
      *  higher elevations from the base height.
      */
     aiTextureType_HEIGHT = 5,
 
     /** The texture is a (tangent space) normal-map.
      *
      *  Again, there are several conventions for tangent-space
      *  normal maps. Assimp does (intentionally) not
      *  distinguish here.
      */
     aiTextureType_NORMALS = 6,
 
     /** The texture defines the glossiness of the material.
      *
      *  The glossiness is in fact the exponent of the specular
      *  (phong) lighting equation. Usually there is a conversion
      *  function defined to map the linear color values in the
      *  texture to a suitable exponent. Have fun.
     */
     aiTextureType_SHININESS = 7,
 
     /** The texture defines per-pixel opacity.
      *
      *  Usually 'white' means opaque and 'black' means
      *  'transparency'. Or quite the opposite. Have fun.
     */
     aiTextureType_OPACITY = 8,
 
     /** Displacement texture
      *
      *  The exact purpose and format is application-dependent.
      *  Higher color values stand for higher vertex displacements.
     */
     aiTextureType_DISPLACEMENT = 9,
 
     /** Lightmap texture (aka Ambient Occlusion)
      *
      *  Both 'Lightmaps' and dedicated 'ambient occlusion maps' are
      *  covered by this material property. The texture contains a
      *  scaling value for the final color value of a pixel. Its
      *  intensity is not affected by incoming light.
     */
     aiTextureType_LIGHTMAP = 10,
 
     /** Reflection texture
      *
      * Contains the color of a perfect mirror reflection.
      * Rarely used, almost never for real-time applications.
     */
     aiTextureType_REFLECTION = 11,
 
     /** PBR Materials
      * PBR definitions from maya and other modelling packages now use this standard.
      * This was originally introduced around 2012.
      * Support for this is in game engines like Godot, Unreal or Unity3D.
      * Modelling packages which use this are very common now.
      */
 
     aiTextureType_BASE_COLOR = 12,
     aiTextureType_NORMAL_CAMERA = 13,
     aiTextureType_EMISSION_COLOR = 14,
     aiTextureType_METALNESS = 15,
     aiTextureType_DIFFUSE_ROUGHNESS = 16,
     aiTextureType_AMBIENT_OCCLUSION = 17,
 
     /** PBR Material Modifiers
     * Some modern renderers have further PBR modifiers that may be overlaid
     * on top of the 'base' PBR materials for additional realism.
     * These use multiple texture maps, so only the base type is directly defined
     */
 
     /** Sheen
     * Generally used to simulate textiles that are covered in a layer of microfibers
     * eg velvet
     * https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen
     */
     aiTextureType_SHEEN = 19,
 
     /** Clearcoat
     * Simulates a layer of 'polish' or 'laquer' layered on top of a PBR substrate
     * https://autodesk.github.io/standard-surface/#closures/coating
     * https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
     */
     aiTextureType_CLEARCOAT = 20,
 
     /** Transmission
     * Simulates transmission through the surface
     * May include further information such as wall thickness
     */
     aiTextureType_TRANSMISSION = 21,
 
     /** Unknown texture
      *
      *  A texture reference that does not match any of the definitions
      *  above is considered to be 'unknown'. It is still imported,
      *  but is excluded from any further post-processing.
     */
     aiTextureType_UNKNOWN = 18,
 
 #ifndef SWIG
     _aiTextureType_Force32Bit = INT_MAX
 #endif
 };
 
 #define AI_TEXTURE_TYPE_MAX aiTextureType_UNKNOWN
 
 // -------------------------------------------------------------------------------
 // Get a string for a given aiTextureType
 ASSIMP_API const char *TextureTypeToString(enum aiTextureType in);
 
 // ---------------------------------------------------------------------------
 /** @brief Defines all shading models supported by the library
- * 
+ *
  *  Property: #AI_MATKEY_SHADING_MODEL
- * 
+ *
  *  The list of shading modes has been taken from Blender.
  *  See Blender documentation for more information. The API does
  *  not distinguish between "specular" and "diffuse" shaders (thus the
  *  specular term for diffuse shading models like Oren-Nayar remains
  *  undefined). <br>
  *  Again, this value is just a hint. Assimp tries to select the shader whose
  *  most common implementation matches the original rendering results of the
  *  3D modeler which wrote a particular model as closely as possible.
  *
  */
diff --git a/include/assimp/matrix4x4.h b/include/assimp/matrix4x4.h
index c929ef2a9..6caf7686c 100644
--- a/include/assimp/matrix4x4.h
+++ b/include/assimp/matrix4x4.h
@@ -74,187 +74,187 @@ class aiMatrix4x4t {
 public:
 
     /** set to identity */
     aiMatrix4x4t() AI_NO_EXCEPT;
 
     /** construction from single values */
     aiMatrix4x4t (  TReal _a1, TReal _a2, TReal _a3, TReal _a4,
                     TReal _b1, TReal _b2, TReal _b3, TReal _b4,
                     TReal _c1, TReal _c2, TReal _c3, TReal _c4,
                     TReal _d1, TReal _d2, TReal _d3, TReal _d4);
 
 
     /** construction from 3x3 matrix, remaining elements are set to identity */
     explicit aiMatrix4x4t( const aiMatrix3x3t<TReal>& m);
 
     /** construction from position, rotation and scaling components
      * @param scaling The scaling for the x,y,z axes
      * @param rotation The rotation as a hamilton quaternion
      * @param position The position for the x,y,z axes
      */
     aiMatrix4x4t(const aiVector3t<TReal>& scaling, const aiQuaterniont<TReal>& rotation,
         const aiVector3t<TReal>& position);
 
     // array access operators
 	/** @fn TReal* operator[] (unsigned int p_iIndex)
 	 *  @param [in] p_iIndex - index of the row.
 	 *  @return pointer to pointed row.
 	 */
     TReal* operator[]       (unsigned int p_iIndex);
 
 	/** @fn const TReal* operator[] (unsigned int p_iIndex) const
 	 *  @overload TReal* operator[] (unsigned int p_iIndex)
 	 */
     const TReal* operator[] (unsigned int p_iIndex) const;
 
     // comparison operators
     bool operator== (const aiMatrix4x4t& m) const;
     bool operator!= (const aiMatrix4x4t& m) const;
 
     bool Equal(const aiMatrix4x4t& m, TReal epsilon = 1e-6) const;
 
     // matrix multiplication.
     aiMatrix4x4t& operator *= (const aiMatrix4x4t& m);
     aiMatrix4x4t  operator *  (const aiMatrix4x4t& m) const;
     aiMatrix4x4t operator * (const TReal& aFloat) const;
     aiMatrix4x4t operator + (const aiMatrix4x4t& aMatrix) const;
 
     template <typename TOther>
     operator aiMatrix4x4t<TOther> () const;
 
     // -------------------------------------------------------------------
     /** @brief Transpose the matrix */
     aiMatrix4x4t& Transpose();
 
     // -------------------------------------------------------------------
     /** @brief Invert the matrix.
      *  If the matrix is not invertible all elements are set to qnan.
      *  Beware, use (f != f) to check whether a TReal f is qnan.
      */
     aiMatrix4x4t& Inverse();
     TReal Determinant() const;
 
 
     // -------------------------------------------------------------------
     /** @brief Returns true of the matrix is the identity matrix.
      *  The check is performed against a not so small epsilon.
      */
     inline bool IsIdentity() const;
 
     // -------------------------------------------------------------------
     /** @brief Decompose a trafo matrix into its original components
      *  @param scaling Receives the output scaling for the x,y,z axes
      *  @param rotation Receives the output rotation as a hamilton
      *   quaternion
      *  @param position Receives the output position for the x,y,z axes
      */
     void Decompose (aiVector3t<TReal>& scaling, aiQuaterniont<TReal>& rotation,
         aiVector3t<TReal>& position) const;
 
 	// -------------------------------------------------------------------
 	/** @fn void Decompose(aiVector3t<TReal>& pScaling, aiVector3t<TReal>& pRotation, aiVector3t<TReal>& pPosition) const
      *  @brief Decompose a trafo matrix into its original components.
      * Thx to good FAQ at http://www.gamedev.ru/code/articles/faq_matrix_quat
      *  @param [out] pScaling - Receives the output scaling for the x,y,z axes.
      *  @param [out] pRotation - Receives the output rotation as a Euler angles.
      *  @param [out] pPosition - Receives the output position for the x,y,z axes.
      */
     void Decompose(aiVector3t<TReal>& pScaling, aiVector3t<TReal>& pRotation, aiVector3t<TReal>& pPosition) const;
 
 	// -------------------------------------------------------------------
 	/** @fn void Decompose(aiVector3t<TReal>& pScaling, aiVector3t<TReal>& pRotationAxis, TReal& pRotationAngle, aiVector3t<TReal>& pPosition) const
      *  @brief Decompose a trafo matrix into its original components
 	 * Thx to good FAQ at http://www.gamedev.ru/code/articles/faq_matrix_quat
      *  @param [out] pScaling - Receives the output scaling for the x,y,z axes.
      *  @param [out] pRotationAxis - Receives the output rotation axis.
 	 *  @param [out] pRotationAngle - Receives the output rotation angle for @ref pRotationAxis.
      *  @param [out] pPosition - Receives the output position for the x,y,z axes.
      */
     void Decompose(aiVector3t<TReal>& pScaling, aiVector3t<TReal>& pRotationAxis, TReal& pRotationAngle, aiVector3t<TReal>& pPosition) const;
 
     // -------------------------------------------------------------------
     /** @brief Decompose a trafo matrix with no scaling into its
      *    original components
      *  @param rotation Receives the output rotation as a hamilton
      *    quaternion
      *  @param position Receives the output position for the x,y,z axes
      */
     void DecomposeNoScaling (aiQuaterniont<TReal>& rotation,
         aiVector3t<TReal>& position) const;
 
     // -------------------------------------------------------------------
     /** @brief Creates a trafo matrix from a set of euler angles
      *  @param x Rotation angle for the x-axis, in radians
      *  @param y Rotation angle for the y-axis, in radians
      *  @param z Rotation angle for the z-axis, in radians
      */
     aiMatrix4x4t& FromEulerAnglesXYZ(TReal x, TReal y, TReal z);
     aiMatrix4x4t& FromEulerAnglesXYZ(const aiVector3t<TReal>& blubb);
 
     // -------------------------------------------------------------------
     /** @brief Returns a rotation matrix for a rotation around the x axis
      *  @param a Rotation angle, in radians
      *  @param out Receives the output matrix
      *  @return Reference to the output matrix
      */
     static aiMatrix4x4t& RotationX(TReal a, aiMatrix4x4t& out);
 
     // -------------------------------------------------------------------
     /** @brief Returns a rotation matrix for a rotation around the y axis
      *  @param a Rotation angle, in radians
      *  @param out Receives the output matrix
      *  @return Reference to the output matrix
      */
     static aiMatrix4x4t& RotationY(TReal a, aiMatrix4x4t& out);
 
     // -------------------------------------------------------------------
     /** @brief Returns a rotation matrix for a rotation around the z axis
      *  @param a Rotation angle, in radians
      *  @param out Receives the output matrix
      *  @return Reference to the output matrix
      */
     static aiMatrix4x4t& RotationZ(TReal a, aiMatrix4x4t& out);
 
     // -------------------------------------------------------------------
     /** Returns a rotation matrix for a rotation around an arbitrary axis.
      *  @param a Rotation angle, in radians
      *  @param axis Rotation axis, should be a normalized vector.
      *  @param out Receives the output matrix
      *  @return Reference to the output matrix
      */
     static aiMatrix4x4t& Rotation(TReal a, const aiVector3t<TReal>& axis,
             aiMatrix4x4t& out);
 
     // -------------------------------------------------------------------
     /** @brief Returns a translation matrix
      *  @param v Translation vector
      *  @param out Receives the output matrix
      *  @return Reference to the output matrix
      */
-    static aiMatrix4x4t& Translation( const aiVector3t<TReal>& v, 
+    static aiMatrix4x4t& Translation( const aiVector3t<TReal>& v,
             aiMatrix4x4t& out);
 
     // -------------------------------------------------------------------
     /** @brief Returns a scaling matrix
      *  @param v Scaling vector
      *  @param out Receives the output matrix
      *  @return Reference to the output matrix
      */
     static aiMatrix4x4t& Scaling( const aiVector3t<TReal>& v, aiMatrix4x4t& out);
 
     // -------------------------------------------------------------------
     /** @brief A function for creating a rotation matrix that rotates a
      *  vector called "from" into another vector called "to".
      * Input : from[3], to[3] which both must be *normalized* non-zero vectors
      * Output: mtx[3][3] -- a 3x3 matrix in column-major form
      * Authors: Tomas Mueller, John Hughes
      *          "Efficiently Building a Matrix to Rotate One Vector to Another"
      *          Journal of Graphics Tools, 4(4):1-4, 1999
      */
     static aiMatrix4x4t& FromToMatrix(const aiVector3t<TReal>& from,
             const aiVector3t<TReal>& to, aiMatrix4x4t& out);
 
     TReal a1, a2, a3, a4;
     TReal b1, b2, b3, b4;
     TReal c1, c2, c3, c4;
     TReal d1, d2, d3, d4;
 };
diff --git a/include/assimp/matrix4x4.inl b/include/assimp/matrix4x4.inl
index 88315ac28..c1dd87b65 100644
--- a/include/assimp/matrix4x4.inl
+++ b/include/assimp/matrix4x4.inl
@@ -416,52 +416,52 @@ AI_FORCE_INLINE
 void aiMatrix4x4t<TReal>::Decompose(aiVector3t<TReal>& pScaling, aiVector3t<TReal>& pRotation, aiVector3t<TReal>& pPosition) const {
 	ASSIMP_MATRIX4_4_DECOMPOSE_PART;
 
     /*
     assuming a right-handed coordinate system
     and post-multiplication of column vectors,
     the rotation matrix for an euler XYZ rotation is M = Rz * Ry * Rx.
     combining gives:
-    
+
         |  CE  BDE-AF  ADE+BF  0  |
     M = |  CF  BDF+AE  ADF-BE  0  |
         |  -D    CB      AC    0  |
         |   0     0       0    1  |
 
     where
 	A = cos(angle_x), B = sin(angle_x);
 	C = cos(angle_y), D = sin(angle_y);
 	E = cos(angle_z), F = sin(angle_z);
 	*/
 
 	// Use a small epsilon to solve floating-point inaccuracies
     const TReal epsilon = Assimp::Math::getEpsilon<TReal>();
 
 	pRotation.y  = std::asin(-vCols[0].z);// D. Angle around oY.
 
 	TReal C = std::cos(pRotation.y);
 
 	if(std::fabs(C) > epsilon)
 	{
 		// Finding angle around oX.
 		TReal tan_x = vCols[2].z / C;// A
 		TReal tan_y = vCols[1].z / C;// B
 
 		pRotation.x = std::atan2(tan_y, tan_x);
 		// Finding angle around oZ.
 		tan_x = vCols[0].x / C;// E
 		tan_y = vCols[0].y / C;// F
 		pRotation.z = std::atan2(tan_y, tan_x);
 	}
 	else
 	{// oY is fixed.
 		pRotation.x = 0;// Set angle around oX to 0. => A == 1, B == 0, C == 0, D == 1.
 
 		// And finding angle around oZ.
 		TReal tan_x =  vCols[1].y;// BDF+AE => E
 		TReal tan_y = -vCols[1].x;// BDE-AF => F
 
 		pRotation.z = std::atan2(tan_y, tan_x);
 	}
 }
 
 #undef ASSIMP_MATRIX4_4_DECOMPOSE_PART
diff --git a/include/assimp/mesh.h b/include/assimp/mesh.h
index 989ed3800..e3aa847ff 100644
--- a/include/assimp/mesh.h
+++ b/include/assimp/mesh.h
@@ -363,79 +363,79 @@ struct aiBone {
 // ---------------------------------------------------------------------------
 /** @brief Enumerates the types of geometric primitives supported by Assimp.
  *
  *  @see aiFace Face data structure
  *  @see aiProcess_SortByPType Per-primitive sorting of meshes
  *  @see aiProcess_Triangulate Automatic triangulation
  *  @see AI_CONFIG_PP_SBP_REMOVE Removal of specific primitive types.
  */
 enum aiPrimitiveType {
     /** A point primitive.
      *
      * This is just a single vertex in the virtual world,
      * #aiFace contains just one index for such a primitive.
      */
     aiPrimitiveType_POINT = 0x1,
 
     /** A line primitive.
      *
      * This is a line defined through a start and an end position.
      * #aiFace contains exactly two indices for such a primitive.
      */
     aiPrimitiveType_LINE = 0x2,
 
     /** A triangular primitive.
      *
      * A triangle consists of three indices.
      */
     aiPrimitiveType_TRIANGLE = 0x4,
 
     /** A higher-level polygon with more than 3 edges.
      *
      * A triangle is a polygon, but polygon in this context means
      * "all polygons that are not triangles". The "Triangulate"-Step
      * is provided for your convenience, it splits all polygons in
      * triangles (which are much easier to handle).
      */
     aiPrimitiveType_POLYGON = 0x8,
 
     /**
      * A flag to determine whether this triangles only mesh is NGON encoded.
-     * 
+     *
      * NGON encoding is a special encoding that tells whether 2 or more consecutive triangles
      * should be considered as a triangle fan. This is identified by looking at the first vertex index.
      * 2 consecutive triangles with the same 1st vertex index are part of the same
      * NGON.
-     * 
-     * At the moment, only quads (concave or convex) are supported, meaning that polygons are 'seen' as 
+     *
+     * At the moment, only quads (concave or convex) are supported, meaning that polygons are 'seen' as
      * triangles, as usual after a triangulation pass.
-     * 
+     *
      * To get an NGON encoded mesh, please use the aiProcess_Triangulate post process.
-     * 
+     *
      * @see aiProcess_Triangulate
      * @link https://github.com/KhronosGroup/glTF/pull/1620
      */
     aiPrimitiveType_NGONEncodingFlag = 0x10,
 
 /** This value is not used. It is just here to force the
      *  compiler to map this enum to a 32 Bit integer.
      */
 #ifndef SWIG
     _aiPrimitiveType_Force32Bit = INT_MAX
 #endif
 }; //! enum aiPrimitiveType
 
 // Get the #aiPrimitiveType flag for a specific number of face indices
 #define AI_PRIMITIVE_TYPE_FOR_N_INDICES(n) \
     ((n) > 3 ? aiPrimitiveType_POLYGON : (aiPrimitiveType)(1u << ((n)-1)))
 
 // ---------------------------------------------------------------------------
 /** @brief An AnimMesh is an attachment to an #aiMesh stores per-vertex
  *  animations for a particular frame.
  *
  *  You may think of an #aiAnimMesh as a `patch` for the host mesh, which
  *  replaces only certain vertex data streams at a particular time.
  *  Each mesh stores n attached attached meshes (#aiMesh::mAnimMeshes).
  *  The actual relationship between the time line and anim meshes is
  *  established by #aiMeshAnim, which references singular mesh attachments
  *  by their ID and binds them to a time offset.
 */
diff --git a/include/assimp/postprocess.h b/include/assimp/postprocess.h
index ca2c2c22d..5e887b0b1 100644
--- a/include/assimp/postprocess.h
+++ b/include/assimp/postprocess.h
@@ -60,649 +60,649 @@ extern "C" {
 // -----------------------------------------------------------------------------------
 /** @enum  aiPostProcessSteps
  *  @brief Defines the flags for all possible post processing steps.
  *
  *  @note Some steps are influenced by properties set on the Assimp::Importer itself
  *
  *  @see Assimp::Importer::ReadFile()
  *  @see Assimp::Importer::SetPropertyInteger()
  *  @see aiImportFile
  *  @see aiImportFileEx
  */
 // -----------------------------------------------------------------------------------
 enum aiPostProcessSteps
 {
 
     // -------------------------------------------------------------------------
     /** <hr>Calculates the tangents and bitangents for the imported meshes.
      *
      * Does nothing if a mesh does not have normals. You might want this post
      * processing step to be executed if you plan to use tangent space calculations
      * such as normal mapping  applied to the meshes. There's an importer property,
      * <tt>#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</tt>, which allows you to specify
      * a maximum smoothing angle for the algorithm. However, usually you'll
      * want to leave it at the default value.
      */
     aiProcess_CalcTangentSpace = 0x1,
 
     // -------------------------------------------------------------------------
     /** <hr>Identifies and joins identical vertex data sets within all
      *  imported meshes.
      *
      * After this step is run, each mesh contains unique vertices,
      * so a vertex may be used by multiple faces. You usually want
      * to use this post processing step. If your application deals with
      * indexed geometry, this step is compulsory or you'll just waste rendering
      * time. <b>If this flag is not specified</b>, no vertices are referenced by
      * more than one face and <b>no index buffer is required</b> for rendering.
      */
     aiProcess_JoinIdenticalVertices = 0x2,
 
     // -------------------------------------------------------------------------
     /** <hr>Converts all the imported data to a left-handed coordinate space.
      *
      * By default the data is returned in a right-handed coordinate space (which
      * OpenGL prefers). In this space, +X points to the right,
      * +Z points towards the viewer, and +Y points upwards. In the DirectX
      * coordinate space +X points to the right, +Y points upwards, and +Z points
      * away from the viewer.
      *
      * You'll probably want to consider this flag if you use Direct3D for
      * rendering. The #aiProcess_ConvertToLeftHanded flag supersedes this
      * setting and bundles all conversions typically required for D3D-based
      * applications.
      */
     aiProcess_MakeLeftHanded = 0x4,
 
     // -------------------------------------------------------------------------
     /** <hr>Triangulates all faces of all meshes.
      *
      * By default the imported mesh data might contain faces with more than 3
      * indices. For rendering you'll usually want all faces to be triangles.
      * This post processing step splits up faces with more than 3 indices into
      * triangles. Line and point primitives are *not* modified! If you want
      * 'triangles only' with no other kinds of primitives, try the following
      * solution:
      * <ul>
      * <li>Specify both #aiProcess_Triangulate and #aiProcess_SortByPType </li>
      * <li>Ignore all point and line meshes when you process assimp's output</li>
      * </ul>
      */
     aiProcess_Triangulate = 0x8,
 
     // -------------------------------------------------------------------------
     /** <hr>Removes some parts of the data structure (animations, materials,
      *  light sources, cameras, textures, vertex components).
      *
      * The  components to be removed are specified in a separate
      * importer property, <tt>#AI_CONFIG_PP_RVC_FLAGS</tt>. This is quite useful
      * if you don't need all parts of the output structure. Vertex colors
      * are rarely used today for example... Calling this step to remove unneeded
      * data from the pipeline as early as possible results in increased
      * performance and a more optimized output data structure.
      * This step is also useful if you want to force Assimp to recompute
      * normals or tangents. The corresponding steps don't recompute them if
      * they're already there (loaded from the source asset). By using this
      * step you can make sure they are NOT there.
      *
      * This flag is a poor one, mainly because its purpose is usually
      * misunderstood. Consider the following case: a 3D model has been exported
      * from a CAD app, and it has per-face vertex colors. Vertex positions can't be
      * shared, thus the #aiProcess_JoinIdenticalVertices step fails to
      * optimize the data because of these nasty little vertex colors.
      * Most apps don't even process them, so it's all for nothing. By using
      * this step, unneeded components are excluded as early as possible
      * thus opening more room for internal optimizations.
      */
     aiProcess_RemoveComponent = 0x10,
 
     // -------------------------------------------------------------------------
     /** <hr>Generates normals for all faces of all meshes.
      *
      * This is ignored if normals are already there at the time this flag
      * is evaluated. Model importers try to load them from the source file, so
      * they're usually already there. Face normals are shared between all points
      * of a single face, so a single point can have multiple normals, which
      * forces the library to duplicate vertices in some cases.
      * #aiProcess_JoinIdenticalVertices is *senseless* then.
      *
      * This flag may not be specified together with #aiProcess_GenSmoothNormals.
      */
     aiProcess_GenNormals = 0x20,
 
     // -------------------------------------------------------------------------
     /** <hr>Generates smooth normals for all vertices in the mesh.
     *
     * This is ignored if normals are already there at the time this flag
     * is evaluated. Model importers try to load them from the source file, so
     * they're usually already there.
     *
     * This flag may not be specified together with
     * #aiProcess_GenNormals. There's a importer property,
     * <tt>#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</tt> which allows you to specify
     * an angle maximum for the normal smoothing algorithm. Normals exceeding
     * this limit are not smoothed, resulting in a 'hard' seam between two faces.
     * Using a decent angle here (e.g. 80 degrees) results in very good visual
     * appearance.
     */
     aiProcess_GenSmoothNormals = 0x40,
 
     // -------------------------------------------------------------------------
     /** <hr>Splits large meshes into smaller sub-meshes.
     *
     * This is quite useful for real-time rendering, where the number of triangles
     * which can be maximally processed in a single draw-call is limited
     * by the video driver/hardware. The maximum vertex buffer is usually limited
     * too. Both requirements can be met with this step: you may specify both a
     * triangle and vertex limit for a single mesh.
     *
     * The split limits can (and should!) be set through the
     * <tt>#AI_CONFIG_PP_SLM_VERTEX_LIMIT</tt> and <tt>#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</tt>
     * importer properties. The default values are <tt>#AI_SLM_DEFAULT_MAX_VERTICES</tt> and
     * <tt>#AI_SLM_DEFAULT_MAX_TRIANGLES</tt>.
     *
     * Note that splitting is generally a time-consuming task, but only if there's
     * something to split. The use of this step is recommended for most users.
     */
     aiProcess_SplitLargeMeshes = 0x80,
 
     // -------------------------------------------------------------------------
     /** <hr>Removes the node graph and pre-transforms all vertices with
     * the local transformation matrices of their nodes.
     *
     * If the resulting scene can be reduced to a single mesh, with a single
     * material, no lights, and no cameras, then the output scene will contain
-    * only a root node (with no children) that references the single mesh. 
+    * only a root node (with no children) that references the single mesh.
     * Otherwise, the output scene will be reduced to a root node with a single
-    * level of child nodes, each one referencing one mesh, and each mesh 
-    * referencing one material. 
+    * level of child nodes, each one referencing one mesh, and each mesh
+    * referencing one material.
     *
     * In either case, for rendering, you can
     * simply render all meshes in order - you don't need to pay
     * attention to local transformations and the node hierarchy.
     * Animations are removed during this step.
     * This step is intended for applications without a scenegraph.
     * The step CAN cause some problems: if e.g. a mesh of the asset
     * contains normals and another, using the same material index, does not,
     * they will be brought together, but the first meshes's part of
     * the normal list is zeroed. However, these artifacts are rare.
     * @note The <tt>#AI_CONFIG_PP_PTV_NORMALIZE</tt> configuration property
     * can be set to normalize the scene's spatial dimension to the -1...1
     * range.
     */
     aiProcess_PreTransformVertices = 0x100,
 
     // -------------------------------------------------------------------------
     /** <hr>Limits the number of bones simultaneously affecting a single vertex
     *  to a maximum value.
     *
     * If any vertex is affected by more than the maximum number of bones, the least
     * important vertex weights are removed and the remaining vertex weights are
     * renormalized so that the weights still sum up to 1.
     * The default bone weight limit is 4 (defined as <tt>#AI_LMW_MAX_WEIGHTS</tt> in
     * config.h), but you can use the <tt>#AI_CONFIG_PP_LBW_MAX_WEIGHTS</tt> importer
     * property to supply your own limit to the post processing step.
     *
     * If you intend to perform the skinning in hardware, this post processing
     * step might be of interest to you.
     */
     aiProcess_LimitBoneWeights = 0x200,
 
     // -------------------------------------------------------------------------
     /** <hr>Validates the imported scene data structure.
      * This makes sure that all indices are valid, all animations and
      * bones are linked correctly, all material references are correct .. etc.
      *
      * It is recommended that you capture Assimp's log output if you use this flag,
      * so you can easily find out what's wrong if a file fails the
      * validation. The validator is quite strict and will find *all*
      * inconsistencies in the data structure... It is recommended that plugin
      * developers use it to debug their loaders. There are two types of
      * validation failures:
      * <ul>
      * <li>Error: There's something wrong with the imported data. Further
      *   postprocessing is not possible and the data is not usable at all.
      *   The import fails. #Importer::GetErrorString() or #aiGetErrorString()
      *   carry the error message around.</li>
      * <li>Warning: There are some minor issues (e.g. 1000000 animation
      *   keyframes with the same time), but further postprocessing and use
      *   of the data structure is still safe. Warning details are written
      *   to the log file, <tt>#AI_SCENE_FLAGS_VALIDATION_WARNING</tt> is set
      *   in #aiScene::mFlags</li>
      * </ul>
      *
      * This post-processing step is not time-consuming. Its use is not
      * compulsory, but recommended.
     */
     aiProcess_ValidateDataStructure = 0x400,
 
     // -------------------------------------------------------------------------
     /** <hr>Reorders triangles for better vertex cache locality.
      *
      * The step tries to improve the ACMR (average post-transform vertex cache
      * miss ratio) for all meshes. The implementation runs in O(n) and is
      * roughly based on the 'tipsify' algorithm (see <a href="
      * http://www.cs.princeton.edu/gfx/pubs/Sander_2007_%3ETR/tipsy.pdf">this
      * paper</a>).
      *
      * If you intend to render huge models in hardware, this step might
      * be of interest to you. The <tt>#AI_CONFIG_PP_ICL_PTCACHE_SIZE</tt>
      * importer property can be used to fine-tune the cache optimization.
      */
     aiProcess_ImproveCacheLocality = 0x800,
 
     // -------------------------------------------------------------------------
     /** <hr>Searches for redundant/unreferenced materials and removes them.
      *
      * This is especially useful in combination with the
      * #aiProcess_PreTransformVertices and #aiProcess_OptimizeMeshes flags.
      * Both join small meshes with equal characteristics, but they can't do
      * their work if two meshes have different materials. Because several
      * material settings are lost during Assimp's import filters,
      * (and because many exporters don't check for redundant materials), huge
      * models often have materials which are are defined several times with
      * exactly the same settings.
      *
      * Several material settings not contributing to the final appearance of
      * a surface are ignored in all comparisons (e.g. the material name).
      * So, if you're passing additional information through the
      * content pipeline (probably using *magic* material names), don't
      * specify this flag. Alternatively take a look at the
      * <tt>#AI_CONFIG_PP_RRM_EXCLUDE_LIST</tt> importer property.
      */
     aiProcess_RemoveRedundantMaterials = 0x1000,
 
     // -------------------------------------------------------------------------
     /** <hr>This step tries to determine which meshes have normal vectors
      * that are facing inwards and inverts them.
      *
      * The algorithm is simple but effective:
      * the bounding box of all vertices + their normals is compared against
      * the volume of the bounding box of all vertices without their normals.
      * This works well for most objects, problems might occur with planar
      * surfaces. However, the step tries to filter such cases.
      * The step inverts all in-facing normals. Generally it is recommended
      * to enable this step, although the result is not always correct.
     */
     aiProcess_FixInfacingNormals = 0x2000,
 
 
 
     // -------------------------------------------------------------------------
-    /** 
+    /**
      * This step generically populates aiBone->mArmature and aiBone->mNode generically
      * The point of these is it saves you later having to calculate these elements
      * This is useful when handling rest information or skin information
-     * If you have multiple armatures on your models we strongly recommend enabling this 
-     * Instead of writing your own multi-root, multi-armature lookups we have done the 
+     * If you have multiple armatures on your models we strongly recommend enabling this
+     * Instead of writing your own multi-root, multi-armature lookups we have done the
      * hard work for you :)
    */
     aiProcess_PopulateArmatureData = 0x4000,
 
     // -------------------------------------------------------------------------
     /** <hr>This step splits meshes with more than one primitive type in
      *  homogeneous sub-meshes.
      *
      *  The step is executed after the triangulation step. After the step
      *  returns, just one bit is set in aiMesh::mPrimitiveTypes. This is
      *  especially useful for real-time rendering where point and line
      *  primitives are often ignored or rendered separately.
      *  You can use the <tt>#AI_CONFIG_PP_SBP_REMOVE</tt> importer property to
      *  specify which primitive types you need. This can be used to easily
      *  exclude lines and points, which are rarely used, from the import.
     */
     aiProcess_SortByPType = 0x8000,
 
     // -------------------------------------------------------------------------
     /** <hr>This step searches all meshes for degenerate primitives and
      *  converts them to proper lines or points.
      *
      * A face is 'degenerate' if one or more of its points are identical.
      * To have the degenerate stuff not only detected and collapsed but
      * removed, try one of the following procedures:
      * <br><b>1.</b> (if you support lines and points for rendering but don't
      *    want the degenerates)<br>
      * <ul>
      *   <li>Specify the #aiProcess_FindDegenerates flag.
      *   </li>
      *   <li>Set the <tt>#AI_CONFIG_PP_FD_REMOVE</tt> importer property to
      *       1. This will cause the step to remove degenerate triangles from the
      *       import as soon as they're detected. They won't pass any further
      *       pipeline steps.
      *   </li>
      * </ul>
      * <br><b>2.</b>(if you don't support lines and points at all)<br>
      * <ul>
      *   <li>Specify the #aiProcess_FindDegenerates flag.
      *   </li>
      *   <li>Specify the #aiProcess_SortByPType flag. This moves line and
      *     point primitives to separate meshes.
      *   </li>
      *   <li>Set the <tt>#AI_CONFIG_PP_SBP_REMOVE</tt> importer property to
      *       @code aiPrimitiveType_POINTS | aiPrimitiveType_LINES
      *       @endcode to cause SortByPType to reject point
      *       and line meshes from the scene.
      *   </li>
      * </ul>
      *
      * This step also removes very small triangles with a surface area smaller
      * than 10^-6. If you rely on having these small triangles, or notice holes
      * in your model, set the property <tt>#AI_CONFIG_PP_FD_CHECKAREA</tt> to
      * false.
      * @note Degenerate polygons are not necessarily evil and that's why
      * they're not removed by default. There are several file formats which
      * don't support lines or points, and some exporters bypass the
      * format specification and write them as degenerate triangles instead.
     */
     aiProcess_FindDegenerates = 0x10000,
 
     // -------------------------------------------------------------------------
     /** <hr>This step searches all meshes for invalid data, such as zeroed
      *  normal vectors or invalid UV coords and removes/fixes them. This is
      *  intended to get rid of some common exporter errors.
      *
      * This is especially useful for normals. If they are invalid, and
      * the step recognizes this, they will be removed and can later
      * be recomputed, i.e. by the #aiProcess_GenSmoothNormals flag.<br>
      * The step will also remove meshes that are infinitely small and reduce
      * animation tracks consisting of hundreds if redundant keys to a single
      * key. The <tt>AI_CONFIG_PP_FID_ANIM_ACCURACY</tt> config property decides
      * the accuracy of the check for duplicate animation tracks.
     */
     aiProcess_FindInvalidData = 0x20000,
 
     // -------------------------------------------------------------------------
     /** <hr>This step converts non-UV mappings (such as spherical or
      *  cylindrical mapping) to proper texture coordinate channels.
      *
      * Most applications will support UV mapping only, so you will
      * probably want to specify this step in every case. Note that Assimp is not
      * always able to match the original mapping implementation of the
      * 3D app which produced a model perfectly. It's always better to let the
      * modelling app compute the UV channels - 3ds max, Maya, Blender,
      * LightWave, and Modo do this for example.
      *
      * @note If this step is not requested, you'll need to process the
      * <tt>#AI_MATKEY_MAPPING</tt> material property in order to display all assets
      * properly.
      */
     aiProcess_GenUVCoords = 0x40000,
 
     // -------------------------------------------------------------------------
     /** <hr>This step applies per-texture UV transformations and bakes
      *  them into stand-alone vtexture coordinate channels.
      *
      * UV transformations are specified per-texture - see the
      * <tt>#AI_MATKEY_UVTRANSFORM</tt> material key for more information.
      * This step processes all textures with
      * transformed input UV coordinates and generates a new (pre-transformed) UV channel
      * which replaces the old channel. Most applications won't support UV
      * transformations, so you will probably want to specify this step.
      *
      * @note UV transformations are usually implemented in real-time apps by
      * transforming texture coordinates at vertex shader stage with a 3x3
      * (homogenous) transformation matrix.
     */
     aiProcess_TransformUVCoords = 0x80000,
 
     // -------------------------------------------------------------------------
     /** <hr>This step searches for duplicate meshes and replaces them
      *  with references to the first mesh.
      *
      *  This step takes a while, so don't use it if speed is a concern.
      *  Its main purpose is to workaround the fact that many export
      *  file formats don't support instanced meshes, so exporters need to
      *  duplicate meshes. This step removes the duplicates again. Please
      *  note that Assimp does not currently support per-node material
      *  assignment to meshes, which means that identical meshes with
      *  different materials are currently *not* joined, although this is
      *  planned for future versions.
      */
     aiProcess_FindInstances = 0x100000,
 
     // -------------------------------------------------------------------------
     /** <hr>A post-processing step to reduce the number of meshes.
      *
      *  This will, in fact, reduce the number of draw calls.
      *
      *  This is a very effective optimization and is recommended to be used
      *  together with #aiProcess_OptimizeGraph, if possible. The flag is fully
      *  compatible with both #aiProcess_SplitLargeMeshes and #aiProcess_SortByPType.
     */
     aiProcess_OptimizeMeshes  = 0x200000,
 
 
     // -------------------------------------------------------------------------
     /** <hr>A post-processing step to optimize the scene hierarchy.
      *
      *  Nodes without animations, bones, lights or cameras assigned are
      *  collapsed and joined.
      *
      *  Node names can be lost during this step. If you use special 'tag nodes'
      *  to pass additional information through your content pipeline, use the
      *  <tt>#AI_CONFIG_PP_OG_EXCLUDE_LIST</tt> importer property to specify a
      *  list of node names you want to be kept. Nodes matching one of the names
      *  in this list won't be touched or modified.
      *
      *  Use this flag with caution. Most simple files will be collapsed to a
      *  single node, so complex hierarchies are usually completely lost. This is not
      *  useful for editor environments, but probably a very effective
      *  optimization if you just want to get the model data, convert it to your
      *  own format, and render it as fast as possible.
      *
      *  This flag is designed to be used with #aiProcess_OptimizeMeshes for best
      *  results.
      *
      *  @note 'Crappy' scenes with thousands of extremely small meshes packed
      *  in deeply nested nodes exist for almost all file formats.
      *  #aiProcess_OptimizeMeshes in combination with #aiProcess_OptimizeGraph
      *  usually fixes them all and makes them renderable.
     */
     aiProcess_OptimizeGraph  = 0x400000,
 
     // -------------------------------------------------------------------------
     /** <hr>This step flips all UV coordinates along the y-axis and adjusts
      * material settings and bitangents accordingly.
      *
      * <b>Output UV coordinate system:</b>
      * @code
      * 0y|0y ---------- 1x|0y
      * |                 |
      * |                 |
      * |                 |
      * 0x|1y ---------- 1x|1y
      * @endcode
      *
      * You'll probably want to consider this flag if you use Direct3D for
      * rendering. The #aiProcess_ConvertToLeftHanded flag supersedes this
      * setting and bundles all conversions typically required for D3D-based
      * applications.
     */
     aiProcess_FlipUVs = 0x800000,
 
     // -------------------------------------------------------------------------
     /** <hr>This step adjusts the output face winding order to be CW.
      *
      * The default face winding order is counter clockwise (CCW).
      *
      * <b>Output face order:</b>
      * @code
      *       x2
      *
      *                         x0
      *  x1
      * @endcode
     */
     aiProcess_FlipWindingOrder  = 0x1000000,
 
     // -------------------------------------------------------------------------
     /** <hr>This step splits meshes with many bones into sub-meshes so that each
      * sub-mesh has fewer or as many bones as a given limit.
     */
     aiProcess_SplitByBoneCount  = 0x2000000,
 
     // -------------------------------------------------------------------------
     /** <hr>This step removes bones losslessly or according to some threshold.
      *
      *  In some cases (i.e. formats that require it) exporters are forced to
      *  assign dummy bone weights to otherwise static meshes assigned to
      *  animated meshes. Full, weight-based skinning is expensive while
      *  animating nodes is extremely cheap, so this step is offered to clean up
      *  the data in that regard.
      *
      *  Use <tt>#AI_CONFIG_PP_DB_THRESHOLD</tt> to control this.
      *  Use <tt>#AI_CONFIG_PP_DB_ALL_OR_NONE</tt> if you want bones removed if and
      *  only if all bones within the scene qualify for removal.
     */
     aiProcess_Debone  = 0x4000000,
 
 
 
     // -------------------------------------------------------------------------
     /** <hr>This step will perform a global scale of the model.
     *
     *  Some importers are providing a mechanism to define a scaling unit for the
     *  model. This post processing step can be used to do so. You need to get the
     *  global scaling from your importer settings like in FBX. Use the flag
     *  AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY from the global property table to configure this.
     *
     *  Use <tt>#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</tt> to setup the global scaling factor.
     */
     aiProcess_GlobalScale = 0x8000000,
 
     // -------------------------------------------------------------------------
     /** <hr>A postprocessing step to embed of textures.
      *
      *  This will remove external data dependencies for textures.
      *  If a texture's file does not exist at the specified path
      *  (due, for instance, to an absolute path generated on another system),
      *  it will check if a file with the same name exists at the root folder
      *  of the imported model. And if so, it uses that.
      */
     aiProcess_EmbedTextures  = 0x10000000,
-        
+
     // aiProcess_GenEntityMeshes = 0x100000,
     // aiProcess_OptimizeAnimations = 0x200000
     // aiProcess_FixTexturePaths = 0x200000
 
 
     aiProcess_ForceGenNormals = 0x20000000,
 
     // -------------------------------------------------------------------------
     /** <hr>Drops normals for all faces of all meshes.
      *
      * This is ignored if no normals are present.
      * Face normals are shared between all points of a single face,
      * so a single point can have multiple normals, which
      * forces the library to duplicate vertices in some cases.
      * #aiProcess_JoinIdenticalVertices is *senseless* then.
      * This process gives sense back to aiProcess_JoinIdenticalVertices
      */
     aiProcess_DropNormals = 0x40000000,
 
     // -------------------------------------------------------------------------
     /**
      */
     aiProcess_GenBoundingBoxes = 0x80000000
 };
 
 
 // ---------------------------------------------------------------------------------------
 /** @def aiProcess_ConvertToLeftHanded
  *  @brief Shortcut flag for Direct3D-based applications.
  *
  *  Supersedes the #aiProcess_MakeLeftHanded and #aiProcess_FlipUVs and
  *  #aiProcess_FlipWindingOrder flags.
  *  The output data matches Direct3D's conventions: left-handed geometry, upper-left
  *  origin for UV coordinates and finally clockwise face order, suitable for CCW culling.
  *
  *  @deprecated
  */
 #define aiProcess_ConvertToLeftHanded ( \
     aiProcess_MakeLeftHanded     | \
     aiProcess_FlipUVs            | \
     aiProcess_FlipWindingOrder   | \
     0 )
 
 
 // ---------------------------------------------------------------------------------------
 /** @def aiProcessPreset_TargetRealtime_Fast
  *  @brief Default postprocess configuration optimizing the data for real-time rendering.
  *
  *  Applications would want to use this preset to load models on end-user PCs,
  *  maybe for direct use in game.
  *
  * If you're using DirectX, don't forget to combine this value with
  * the #aiProcess_ConvertToLeftHanded step. If you don't support UV transformations
  * in your application apply the #aiProcess_TransformUVCoords step, too.
  *  @note Please take the time to read the docs for the steps enabled by this preset.
  *  Some of them offer further configurable properties, while some of them might not be of
  *  use for you so it might be better to not specify them.
  */
 #define aiProcessPreset_TargetRealtime_Fast ( \
     aiProcess_CalcTangentSpace      |  \
     aiProcess_GenNormals            |  \
     aiProcess_JoinIdenticalVertices |  \
     aiProcess_Triangulate           |  \
     aiProcess_GenUVCoords           |  \
     aiProcess_SortByPType           |  \
     0 )
 
  // ---------------------------------------------------------------------------------------
  /** @def aiProcessPreset_TargetRealtime_Quality
   *  @brief Default postprocess configuration optimizing the data for real-time rendering.
   *
   *  Unlike #aiProcessPreset_TargetRealtime_Fast, this configuration
   *  performs some extra optimizations to improve rendering speed and
   *  to minimize memory usage. It could be a good choice for a level editor
   *  environment where import speed is not so important.
   *
   *  If you're using DirectX, don't forget to combine this value with
   *  the #aiProcess_ConvertToLeftHanded step. If you don't support UV transformations
   *  in your application apply the #aiProcess_TransformUVCoords step, too.
   *  @note Please take the time to read the docs for the steps enabled by this preset.
   *  Some of them offer further configurable properties, while some of them might not be
   *  of use for you so it might be better to not specify them.
   */
 #define aiProcessPreset_TargetRealtime_Quality ( \
     aiProcess_CalcTangentSpace              |  \
     aiProcess_GenSmoothNormals              |  \
     aiProcess_JoinIdenticalVertices         |  \
     aiProcess_ImproveCacheLocality          |  \
     aiProcess_LimitBoneWeights              |  \
     aiProcess_RemoveRedundantMaterials      |  \
     aiProcess_SplitLargeMeshes              |  \
     aiProcess_Triangulate                   |  \
     aiProcess_GenUVCoords                   |  \
     aiProcess_SortByPType                   |  \
     aiProcess_FindDegenerates               |  \
     aiProcess_FindInvalidData               |  \
     0 )
 
  // ---------------------------------------------------------------------------------------
  /** @def aiProcessPreset_TargetRealtime_MaxQuality
   *  @brief Default postprocess configuration optimizing the data for real-time rendering.
   *
   *  This preset enables almost every optimization step to achieve perfectly
   *  optimized data. It's your choice for level editor environments where import speed
   *  is not important.
   *
   *  If you're using DirectX, don't forget to combine this value with
   *  the #aiProcess_ConvertToLeftHanded step. If you don't support UV transformations
   *  in your application, apply the #aiProcess_TransformUVCoords step, too.
   *  @note Please take the time to read the docs for the steps enabled by this preset.
   *  Some of them offer further configurable properties, while some of them might not be
   *  of use for you so it might be better to not specify them.
   */
 #define aiProcessPreset_TargetRealtime_MaxQuality ( \
     aiProcessPreset_TargetRealtime_Quality   |  \
     aiProcess_FindInstances                  |  \
     aiProcess_ValidateDataStructure          |  \
     aiProcess_OptimizeMeshes                 |  \
     0 )
 
 
 #ifdef __cplusplus
 } // end of extern "C"
 #endif
 
 #endif // AI_POSTPROCESS_H_INC
diff --git a/include/assimp/scene.h b/include/assimp/scene.h
index 522ddc6dc..25858ac38 100644
--- a/include/assimp/scene.h
+++ b/include/assimp/scene.h
@@ -62,382 +62,382 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #ifdef __cplusplus
 #  include <cstdlib>
 extern "C" {
 #endif
 
 #ifdef __GNUC__
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wattributes"
 #endif
 
 // -------------------------------------------------------------------------------
-/** 
+/**
  * A node in the imported hierarchy.
  *
  * Each node has name, a parent node (except for the root node),
  * a transformation relative to its parent and possibly several child nodes.
  * Simple file formats don't support hierarchical structures - for these formats
  * the imported scene does consist of only a single root node without children.
  */
 // -------------------------------------------------------------------------------
 struct ASSIMP_API aiNode
 {
     /** The name of the node.
      *
      * The name might be empty (length of zero) but all nodes which
      * need to be referenced by either bones or animations are named.
      * Multiple nodes may have the same name, except for nodes which are referenced
      * by bones (see #aiBone and #aiMesh::mBones). Their names *must* be unique.
      *
      * Cameras and lights reference a specific node by name - if there
      * are multiple nodes with this name, they are assigned to each of them.
      * <br>
      * There are no limitations with regard to the characters contained in
      * the name string as it is usually taken directly from the source file.
      *
      * Implementations should be able to handle tokens such as whitespace, tabs,
      * line feeds, quotation marks, ampersands etc.
      *
      * Sometimes assimp introduces new nodes not present in the source file
      * into the hierarchy (usually out of necessity because sometimes the
      * source hierarchy format is simply not compatible). Their names are
      * surrounded by @verbatim <> @endverbatim e.g.
      *  @verbatim<DummyRootNode> @endverbatim.
      */
     C_STRUCT aiString mName;
 
     /** The transformation relative to the node's parent. */
     C_STRUCT aiMatrix4x4 mTransformation;
 
     /** Parent node. nullptr if this node is the root node. */
     C_STRUCT aiNode* mParent;
 
     /** The number of child nodes of this node. */
     unsigned int mNumChildren;
 
     /** The child nodes of this node. nullptr if mNumChildren is 0. */
     C_STRUCT aiNode** mChildren;
 
     /** The number of meshes of this node. */
     unsigned int mNumMeshes;
 
     /** The meshes of this node. Each entry is an index into the
       * mesh list of the #aiScene.
       */
     unsigned int* mMeshes;
 
     /** Metadata associated with this node or nullptr if there is no metadata.
       *  Whether any metadata is generated depends on the source file format. See the
       * @link importer_notes @endlink page for more information on every source file
       * format. Importers that don't document any metadata don't write any.
       */
     C_STRUCT aiMetadata* mMetaData;
 
 #ifdef __cplusplus
     /** Constructor */
     aiNode();
 
     /** Construction from a specific name */
     explicit aiNode(const std::string& name);
 
     /** Destructor */
     ~aiNode();
 
     /** Searches for a node with a specific name, beginning at this
      *  nodes. Normally you will call this method on the root node
      *  of the scene.
      *
      *  @param name Name to search for
      *  @return nullptr or a valid Node if the search was successful.
      */
-    inline 
+    inline
     const aiNode* FindNode(const aiString& name) const {
         return FindNode(name.data);
     }
 
-    inline 
+    inline
     aiNode* FindNode(const aiString& name) {
         return FindNode(name.data);
     }
 
     const aiNode* FindNode(const char* name) const;
 
     aiNode* FindNode(const char* name);
 
     /**
      * @brief   Will add new children.
      * @param   numChildren  Number of children to add.
      * @param   children     The array with pointers showing to the children.
      */
     void addChildren(unsigned int numChildren, aiNode **children);
 #endif // __cplusplus
 };
 
 #ifdef __GNUC__
 #pragma GCC diagnostic pop
 #endif
 
 // -------------------------------------------------------------------------------
 /**
  * Specifies that the scene data structure that was imported is not complete.
  * This flag bypasses some internal validations and allows the import
  * of animation skeletons, material libraries or camera animation paths
  * using Assimp. Most applications won't support such data.
  */
 #define AI_SCENE_FLAGS_INCOMPLETE   0x1
 
 /**
  * This flag is set by the validation postprocess-step (aiPostProcess_ValidateDS)
  * if the validation is successful. In a validated scene you can be sure that
  * any cross references in the data structure (e.g. vertex indices) are valid.
  */
 #define AI_SCENE_FLAGS_VALIDATED    0x2
 
 /**
  * This flag is set by the validation postprocess-step (aiPostProcess_ValidateDS)
  * if the validation is successful but some issues have been found.
  * This can for example mean that a texture that does not exist is referenced
  * by a material or that the bone weights for a vertex don't sum to 1.0 ... .
  * In most cases you should still be able to use the import. This flag could
  * be useful for applications which don't capture Assimp's log output.
  */
 #define AI_SCENE_FLAGS_VALIDATION_WARNING   0x4
 
 /**
  * This flag is currently only set by the aiProcess_JoinIdenticalVertices step.
  * It indicates that the vertices of the output meshes aren't in the internal
  * verbose format anymore. In the verbose format all vertices are unique,
  * no vertex is ever referenced by more than one face.
  */
 #define AI_SCENE_FLAGS_NON_VERBOSE_FORMAT   0x8
 
  /**
  * Denotes pure height-map terrain data. Pure terrains usually consist of quads,
  * sometimes triangles, in a regular grid. The x,y coordinates of all vertex
  * positions refer to the x,y coordinates on the terrain height map, the z-axis
  * stores the elevation at a specific point.
  *
  * TER (Terragen) and HMP (3D Game Studio) are height map formats.
  * @note Assimp is probably not the best choice for loading *huge* terrains -
  * fully triangulated data takes extremely much free store and should be avoided
  * as long as possible (typically you'll do the triangulation when you actually
  * need to render it).
  */
 #define AI_SCENE_FLAGS_TERRAIN 0x10
 
  /**
  * Specifies that the scene data can be shared between structures. For example:
  * one vertex in few faces. \ref AI_SCENE_FLAGS_NON_VERBOSE_FORMAT can not be
  * used for this because \ref AI_SCENE_FLAGS_NON_VERBOSE_FORMAT has internal
  * meaning about postprocessing steps.
  */
 #define AI_SCENE_FLAGS_ALLOW_SHARED			0x20
 
 // -------------------------------------------------------------------------------
 /** The root structure of the imported data.
  *
  *  Everything that was imported from the given file can be accessed from here.
  *  Objects of this class are generally maintained and owned by Assimp, not
  *  by the caller. You shouldn't want to instance it, nor should you ever try to
  *  delete a given scene on your own.
  */
 // -------------------------------------------------------------------------------
 struct aiScene
 {
     /** Any combination of the AI_SCENE_FLAGS_XXX flags. By default
     * this value is 0, no flags are set. Most applications will
     * want to reject all scenes with the AI_SCENE_FLAGS_INCOMPLETE
     * bit set.
     */
     unsigned int mFlags;
 
     /** The root node of the hierarchy.
     *
     * There will always be at least the root node if the import
     * was successful (and no special flags have been set).
     * Presence of further nodes depends on the format and content
     * of the imported file.
     */
     C_STRUCT aiNode* mRootNode;
 
     /** The number of meshes in the scene. */
     unsigned int mNumMeshes;
 
     /** The array of meshes.
     *
     * Use the indices given in the aiNode structure to access
     * this array. The array is mNumMeshes in size. If the
     * AI_SCENE_FLAGS_INCOMPLETE flag is not set there will always
     * be at least ONE material.
     */
     C_STRUCT aiMesh** mMeshes;
 
     /** The number of materials in the scene. */
     unsigned int mNumMaterials;
 
     /** The array of materials.
     *
     * Use the index given in each aiMesh structure to access this
     * array. The array is mNumMaterials in size. If the
     * AI_SCENE_FLAGS_INCOMPLETE flag is not set there will always
     * be at least ONE material.
     */
     C_STRUCT aiMaterial** mMaterials;
 
     /** The number of animations in the scene. */
     unsigned int mNumAnimations;
 
     /** The array of animations.
     *
     * All animations imported from the given file are listed here.
     * The array is mNumAnimations in size.
     */
     C_STRUCT aiAnimation** mAnimations;
 
     /** The number of textures embedded into the file */
     unsigned int mNumTextures;
 
     /** The array of embedded textures.
     *
     * Not many file formats embed their textures into the file.
     * An example is Quake's MDL format (which is also used by
     * some GameStudio versions)
     */
     C_STRUCT aiTexture** mTextures;
 
     /** The number of light sources in the scene. Light sources
     * are fully optional, in most cases this attribute will be 0
         */
     unsigned int mNumLights;
 
     /** The array of light sources.
     *
     * All light sources imported from the given file are
     * listed here. The array is mNumLights in size.
     */
     C_STRUCT aiLight** mLights;
 
     /** The number of cameras in the scene. Cameras
     * are fully optional, in most cases this attribute will be 0
         */
     unsigned int mNumCameras;
 
     /** The array of cameras.
     *
     * All cameras imported from the given file are listed here.
     * The array is mNumCameras in size. The first camera in the
     * array (if existing) is the default camera view into
     * the scene.
     */
     C_STRUCT aiCamera** mCameras;
 
     /**
      *  @brief  The global metadata assigned to the scene itself.
      *
      *  This data contains global metadata which belongs to the scene like
      *  unit-conversions, versions, vendors or other model-specific data. This
      *  can be used to store format-specific metadata as well.
      */
     C_STRUCT aiMetadata* mMetaData;
 
     /** The name of the scene itself.
      */
     C_STRUCT aiString mName;
 
 #ifdef __cplusplus
 
     //! Default constructor - set everything to 0/nullptr
     ASSIMP_API aiScene();
 
     //! Destructor
     ASSIMP_API ~aiScene();
 
     //! Check whether the scene contains meshes
     //! Unless no special scene flags are set this will always be true.
-    inline bool HasMeshes() const { 
-        return mMeshes != nullptr && mNumMeshes > 0; 
+    inline bool HasMeshes() const {
+        return mMeshes != nullptr && mNumMeshes > 0;
     }
 
     //! Check whether the scene contains materials
     //! Unless no special scene flags are set this will always be true.
-    inline bool HasMaterials() const { 
-        return mMaterials != nullptr && mNumMaterials > 0; 
+    inline bool HasMaterials() const {
+        return mMaterials != nullptr && mNumMaterials > 0;
     }
 
     //! Check whether the scene contains lights
-    inline bool HasLights() const { 
-        return mLights != nullptr && mNumLights > 0; 
+    inline bool HasLights() const {
+        return mLights != nullptr && mNumLights > 0;
     }
 
     //! Check whether the scene contains textures
     inline bool HasTextures() const {
-        return mTextures != nullptr && mNumTextures > 0; 
+        return mTextures != nullptr && mNumTextures > 0;
     }
 
     //! Check whether the scene contains cameras
     inline bool HasCameras() const {
-        return mCameras != nullptr && mNumCameras > 0; 
+        return mCameras != nullptr && mNumCameras > 0;
     }
 
     //! Check whether the scene contains animations
-    inline bool HasAnimations() const { 
-        return mAnimations != nullptr && mNumAnimations > 0; 
+    inline bool HasAnimations() const {
+        return mAnimations != nullptr && mNumAnimations > 0;
     }
 
     //! Returns a short filename from a full path
     static const char* GetShortFilename(const char* filename) {
         const char* lastSlash = strrchr(filename, '/');
         if (lastSlash == nullptr) {
             lastSlash = strrchr(filename, '\\');
         }
         const char* shortFilename = lastSlash != nullptr ? lastSlash + 1 : filename;
         return shortFilename;
     }
 
     //! Returns an embedded texture
     const aiTexture* GetEmbeddedTexture(const char* filename) const {
         return GetEmbeddedTextureAndIndex(filename).first;
     }
 
     //! Returns an embedded texture and its index
     std::pair<const aiTexture*, int> GetEmbeddedTextureAndIndex(const char* filename) const {
         if(nullptr==filename) {
             return std::make_pair(nullptr, -1);
         }
         // lookup using texture ID (if referenced like: "*1", "*2", etc.)
         if ('*' == *filename) {
             int index = std::atoi(filename + 1);
             if (0 > index || mNumTextures <= static_cast<unsigned>(index)) {
                 return std::make_pair(nullptr, -1);
             }
             return std::make_pair(mTextures[index], index);
         }
         // lookup using filename
         const char* shortFilename = GetShortFilename(filename);
         if (nullptr == shortFilename) {
             return std::make_pair(nullptr, -1);
         }
 
         for (unsigned int i = 0; i < mNumTextures; i++) {
             const char* shortTextureFilename = GetShortFilename(mTextures[i]->mFilename.C_Str());
             if (strcmp(shortTextureFilename, shortFilename) == 0) {
                 return std::make_pair(mTextures[i], i);
             }
         }
         return std::make_pair(nullptr, -1);
     }
 #endif // __cplusplus
 
     /**  Internal data, do not touch */
 #ifdef __cplusplus
     void* mPrivate;
 #else
     char* mPrivate;
 #endif
 
 };
 
 #ifdef __cplusplus
 } //! namespace Assimp
 #endif
 
 #endif // AI_SCENE_H_INC
diff --git a/include/assimp/vector2.inl b/include/assimp/vector2.inl
index 0ca440e72..b51dd0ec2 100644
--- a/include/assimp/vector2.inl
+++ b/include/assimp/vector2.inl
@@ -190,7 +190,7 @@ aiVector2t<TReal> operator + (const aiVector2t<TReal>& v1, const aiVector2t<TRea
 // ------------------------------------------------------------------------------------------------
 // symmetric subtraction
 template <typename TReal>
-inline 
+inline
 aiVector2t<TReal> operator - (const aiVector2t<TReal>& v1, const aiVector2t<TReal>& v2) {
     return aiVector2t<TReal>( v1.x - v2.x, v1.y - v2.y);
 }
@@ -198,7 +198,7 @@ aiVector2t<TReal> operator - (const aiVector2t<TReal>& v1, const aiVector2t<TRea
 // ------------------------------------------------------------------------------------------------
 // scalar product
 template <typename TReal>
-inline 
+inline
 TReal operator * (const aiVector2t<TReal>& v1, const aiVector2t<TReal>& v2) {
     return v1.x*v2.x + v1.y*v2.y;
 }
@@ -206,7 +206,7 @@ TReal operator * (const aiVector2t<TReal>& v1, const aiVector2t<TReal>& v2) {
 // ------------------------------------------------------------------------------------------------
 // scalar multiplication
 template <typename TReal>
-inline 
+inline
 aiVector2t<TReal> operator * ( TReal f, const aiVector2t<TReal>& v) {
     return aiVector2t<TReal>( f*v.x, f*v.y);
 }
@@ -214,7 +214,7 @@ aiVector2t<TReal> operator * ( TReal f, const aiVector2t<TReal>& v) {
 // ------------------------------------------------------------------------------------------------
 // and the other way around
 template <typename TReal>
-inline 
+inline
 aiVector2t<TReal> operator * ( const aiVector2t<TReal>& v, TReal f) {
     return aiVector2t<TReal>( f*v.x, f*v.y);
 }
@@ -222,7 +222,7 @@ aiVector2t<TReal> operator * ( const aiVector2t<TReal>& v, TReal f) {
 // ------------------------------------------------------------------------------------------------
 // scalar division
 template <typename TReal>
-inline 
+inline
 aiVector2t<TReal> operator / ( const aiVector2t<TReal>& v, TReal f) {
     return v * (1/f);
 }
@@ -230,7 +230,7 @@ aiVector2t<TReal> operator / ( const aiVector2t<TReal>& v, TReal f) {
 // ------------------------------------------------------------------------------------------------
 // vector division
 template <typename TReal>
-inline 
+inline
 aiVector2t<TReal> operator / ( const aiVector2t<TReal>& v, const aiVector2t<TReal>& v2) {
     return aiVector2t<TReal>(v.x / v2.x,v.y / v2.y);
 }
@@ -238,7 +238,7 @@ aiVector2t<TReal> operator / ( const aiVector2t<TReal>& v, const aiVector2t<TRea
 // ------------------------------------------------------------------------------------------------
 // vector negation
 template <typename TReal>
-inline 
+inline
 aiVector2t<TReal> operator - ( const aiVector2t<TReal>& v) {
     return aiVector2t<TReal>( -v.x, -v.y);
 }
diff --git a/packaging/windows-innosetup/readme_installer.txt b/packaging/windows-innosetup/readme_installer.txt
index 6ea969dc1..252c396af 100644
--- a/packaging/windows-innosetup/readme_installer.txt
+++ b/packaging/windows-innosetup/readme_installer.txt
@@ -10,7 +10,7 @@ http://assimp.sf.net
 Troubleshooting
 ===============
 
-1. Missing d3dx9_(some-number).dll? 
+1. Missing d3dx9_(some-number).dll?
 Install the latest DirectX runtime or grab the file from somewhere (that's evil but mostly fine).
 
 2. Application configuration not correct / missing msvcr***.dll?
diff --git a/packaging/windows-innosetup/readme_installer_vieweronly.txt b/packaging/windows-innosetup/readme_installer_vieweronly.txt
index 1e84c577d..0acd6ef52 100644
--- a/packaging/windows-innosetup/readme_installer_vieweronly.txt
+++ b/packaging/windows-innosetup/readme_installer_vieweronly.txt
@@ -19,7 +19,7 @@ Viewer
 Troubleshooting
 ===============
 
-1. Missing d3dx9_(number).dll? 
+1. Missing d3dx9_(number).dll?
 Install the latest DirectX runtime or grab the file from somewhere (that's evil but mostly fine).
 
 2. Application configuration not correct / missing msvcr***.dll?
diff --git a/packaging/windows-mkzip/bin_readme.txt b/packaging/windows-mkzip/bin_readme.txt
index 5cff1f30e..f4402d6bf 100644
--- a/packaging/windows-mkzip/bin_readme.txt
+++ b/packaging/windows-mkzip/bin_readme.txt
@@ -19,7 +19,7 @@ Viewer
 Troubleshooting
 ===============
 
-1. Missing d3dx9_42.dll? 
+1. Missing d3dx9_42.dll?
 Install the latest DirectX runtime or grab the file from somewhere (that's evil but mostly fine).
 
 2. Application configuration not correct / missing msv*** DLLs?
diff --git a/port/AndroidJNI/CMakeLists.txt b/port/AndroidJNI/CMakeLists.txt
index 43e842848..8c821c72a 100644
--- a/port/AndroidJNI/CMakeLists.txt
+++ b/port/AndroidJNI/CMakeLists.txt
@@ -3,12 +3,12 @@ cmake_minimum_required(VERSION 3.10)
 include_directories(./)
 include_directories(./../../)
 add_library( # Defines the name of the library.
-             android_jniiosystem 
+             android_jniiosystem
 
              # Implements a static library.
-             STATIC 
+             STATIC
 
              # relative path to source file(s).
              AndroidJNIIOSystem.cpp
              BundledAssetIOSystem.cpp
 )
diff --git a/port/AssimpDelphi/Readme.txt b/port/AssimpDelphi/Readme.txt
index 07d6935ae..1ec6d2109 100644
--- a/port/AssimpDelphi/Readme.txt
+++ b/port/AssimpDelphi/Readme.txt
@@ -1,6 +1,6 @@
 This is a set of Delphi units for using the Assimp C DLL.  This was created for use with Delphi 7, but should be usable as-is or with minimal modifications with later Delphi versions.
 
-This set of headers is enough to load and display a model with external textures.  Since I'm not familiar with animated models and some of the other functionality of the assimp library, I did not convert the headers for those features. 
+This set of headers is enough to load and display a model with external textures.  Since I'm not familiar with animated models and some of the other functionality of the assimp library, I did not convert the headers for those features.
 
 See http://sourceforge.net/tracker/?func=detail&aid=3212646&group_id=226462&atid=1067634 for the original patch
 
diff --git a/port/jassimp/jassimp-native/src/jassimp.cpp b/port/jassimp/jassimp-native/src/jassimp.cpp
index 0cf01b1e3..6661ce9c4 100644
--- a/port/jassimp/jassimp-native/src/jassimp.cpp
+++ b/port/jassimp/jassimp-native/src/jassimp.cpp
@@ -1,21 +1,21 @@
 #include "jassimp.h"
 
 #include <assimp/Importer.hpp>
 #include <assimp/ProgressHandler.hpp>
 #include <assimp/scene.h>
 #include <assimp/IOStream.hpp>
 #include <assimp/IOSystem.hpp>
 
 
 #ifdef JNI_LOG
 #ifdef ANDROID
 #include <android/log.h>
 #define lprintf(...) __android_log_print(ANDROID_LOG_VERBOSE, __func__, __VA_ARGS__)
 #else
 #define lprintf(...) printf (__VA_ARGS__)
 #endif /* ANDROID */
 #else
-#define lprintf 
+#define lprintf
 #endif
 
 static std::string gLastErrorString;
@@ -45,29 +45,29 @@ public:
 static bool createInstance(JNIEnv *env, const char* className, jobject& newInstance)
 {
 	jclass clazz = env->FindClass(className);
 	SmartLocalRef clazzRef(env, clazz);
 
 	if (NULL == clazz)
 	{
 		lprintf("could not find class %s\n", className);
 		return false;
 	}
 
 	jmethodID ctr_id = env->GetMethodID(clazz, "<init>", "()V");
 
 	if (NULL == ctr_id)
 	{
 		lprintf("could not find no-arg constructor for class %s\n", className);
 		return false;
 	}
 
 	newInstance = env->NewObject(clazz, ctr_id);
 
-	if (NULL == newInstance) 
+	if (NULL == newInstance)
 	{
 		lprintf("error calling no-arg constructor for class %s\n", className);
 		return false;
 	}
 
 	return true;
 }
@@ -76,29 +76,29 @@ static bool createInstance(JNIEnv *env, const char* className, jobject& newInsta
 static bool createInstance(JNIEnv *env, const char* className, const char* signature,/* const*/ jvalue* params, jobject& newInstance)
 {
 	jclass clazz = env->FindClass(className);
 	SmartLocalRef clazzRef(env, clazz);
 
 	if (NULL == clazz)
 	{
 		lprintf("could not find class %s\n", className);
 		return false;
 	}
 
 	jmethodID ctr_id = env->GetMethodID(clazz, "<init>", signature);
 
 	if (NULL == ctr_id)
 	{
 		lprintf("could not find no-arg constructor for class %s\n", className);
 		return false;
 	}
 
 	newInstance = env->NewObjectA(clazz, ctr_id, params);
 
-	if (NULL == newInstance) 
+	if (NULL == newInstance)
 	{
 		lprintf("error calling  constructor for class %s, signature %s\n", className, signature);
 		return false;
 	}
 
 	return true;
 }
@@ -229,27 +229,27 @@ static bool getStaticField(JNIEnv *env, const char* className, const char* field
 }
 
 
-static bool call(JNIEnv *env, jobject object, const char* typeName, const char* methodName, 
+static bool call(JNIEnv *env, jobject object, const char* typeName, const char* methodName,
 	const char* signature,/* const*/ jvalue* params)
 {
 	jclass clazz = env->FindClass(typeName);
 	SmartLocalRef clazzRef(env, clazz);
 
 	if (NULL == clazz)
 	{
 		lprintf("could not find class %s\n", typeName);
 		return false;
 	}
 
 	jmethodID mid = env->GetMethodID(clazz, methodName, signature);
 
 	if (NULL == mid)
 	{
 		lprintf("could not find method %s with signature %s in type %s\n", methodName, signature, typeName);
 		return false;
 	}
 
 	jboolean jReturnValue = env->CallBooleanMethodA(object, mid, params);
 
 	return (bool)jReturnValue;
 }
@@ -275,103 +275,103 @@ static bool callv(JNIEnv *env, jobject object, const char* typeName,
 	return true;
 }
 
-static jobject callo(JNIEnv *env, jobject object, const char* typeName, const char* methodName, 
+static jobject callo(JNIEnv *env, jobject object, const char* typeName, const char* methodName,
 	const char* signature,/* const*/ jvalue* params)
 {
 	jclass clazz = env->FindClass(typeName);
 	SmartLocalRef clazzRef(env, clazz);
 
 	if (NULL == clazz)
 	{
 		lprintf("could not find class %s\n", typeName);
 		return NULL;
 	}
 
 	jmethodID mid = env->GetMethodID(clazz, methodName, signature);
 
 	if (NULL == mid)
 	{
 		lprintf("could not find method %s with signature %s in type %s\n", methodName, signature, typeName);
 		return NULL;
 	}
 
 	jobject jReturnValue = env->CallObjectMethodA(object, mid, params);
 
 	return jReturnValue;
 }
 
-static int calli(JNIEnv *env, jobject object, const char* typeName, const char* methodName, 
+static int calli(JNIEnv *env, jobject object, const char* typeName, const char* methodName,
 	const char* signature)
 {
 	jclass clazz = env->FindClass(typeName);
 	SmartLocalRef clazzRef(env, clazz);
 
 	if (NULL == clazz)
 	{
 		lprintf("could not find class %s\n", typeName);
 		return false;
 	}
 
 	jmethodID mid = env->GetMethodID(clazz, methodName, signature);
 
 	if (NULL == mid)
 	{
 		lprintf("could not find method %s with signature %s in type %s\n", methodName, signature, typeName);
 		return false;
 	}
 
 	jint jReturnValue = env->CallIntMethod(object, mid);
 
 	return (int) jReturnValue;
 }
 
-static int callc(JNIEnv *env, jobject object, const char* typeName, const char* methodName, 
+static int callc(JNIEnv *env, jobject object, const char* typeName, const char* methodName,
 	const char* signature)
 {
 	jclass clazz = env->FindClass(typeName);
 	SmartLocalRef clazzRef(env, clazz);
 
 	if (NULL == clazz)
 	{
 		lprintf("could not find class %s\n", typeName);
 		return false;
 	}
 
 	jmethodID mid = env->GetMethodID(clazz, methodName, signature);
 
 	if (NULL == mid)
 	{
 		lprintf("could not find method %s with signature %s in type %s\n", methodName, signature, typeName);
 		return false;
 	}
 
 	jint jReturnValue = env->CallCharMethod(object, mid);
 
 	return (int) jReturnValue;
 }
 
 
-static bool callStaticObject(JNIEnv *env, const char* typeName, const char* methodName, 
+static bool callStaticObject(JNIEnv *env, const char* typeName, const char* methodName,
 	const char* signature,/* const*/ jvalue* params, jobject& returnValue)
 {
 	jclass clazz = env->FindClass(typeName);
 	SmartLocalRef clazzRef(env, clazz);
 
 	if (NULL == clazz)
 	{
 		lprintf("could not find class %s\n", typeName);
 		return false;
 	}
 
 	jmethodID mid = env->GetStaticMethodID(clazz, methodName, signature);
 
 	if (NULL == mid)
 	{
 		lprintf("could not find method %s with signature %s in type %s\n", methodName, signature, typeName);
 		return false;
 	}
 
 	returnValue = env->CallStaticObjectMethodA(clazz, mid, params);
 
 	return true;
 }
@@ -441,172 +441,172 @@ static bool copyBufferArray(JNIEnv *env, jobject jMesh, const char* jBufferName,
 
 class JavaIOStream : public Assimp::IOStream
 {
-private:	
+private:
 	size_t pos;
 	size_t size;
 	char* buffer;
 	jobject jIOStream;
 
-	
+
 public:
 	JavaIOStream(size_t size, char* buffer, jobject jIOStream) :
 	pos(0),
 	size(size),
 	buffer(buffer),
 	jIOStream(jIOStream)
 	{};
-	
-	
-    ~JavaIOStream(void) 
+
+
+    ~JavaIOStream(void)
     {
     	free(buffer);
-    }; 
+    };
 
     size_t Read(void* pvBuffer, size_t pSize, size_t pCount)
     {
     	const size_t cnt = std::min(pCount,(size - pos)/pSize);
 		const size_t ofs = pSize*cnt;
-	
+
 	    memcpy(pvBuffer, buffer + pos, ofs);
 	    pos += ofs;
-	
+
 	    return cnt;
     };
-    size_t Write(const void* pvBuffer, size_t pSize, size_t pCount) 
+    size_t Write(const void* pvBuffer, size_t pSize, size_t pCount)
     {
         return 0;
     };
-    
+
     aiReturn Seek(size_t pOffset, aiOrigin pOrigin)
     {
 	    if (aiOrigin_SET == pOrigin) {
 	        if (pOffset >= size) {
 	            return AI_FAILURE;
 	        }
 	        pos = pOffset;
 	    }
 	    else if (aiOrigin_END == pOrigin) {
 	        if (pOffset >= size) {
 	            return AI_FAILURE;
 	        }
 	        pos = size-pOffset;
 	    }
 	    else {
 	        if (pOffset + pos >= size) {
 	            return AI_FAILURE;
 	        }
 	        pos += pOffset;
 	    }
 	    return AI_SUCCESS;
     };
-    
+
     size_t Tell(void) const
     {
     	return pos;
     };
-    
+
     size_t FileSize() const
     {
     	return size;
     };
-    
+
     void Flush() {};
-    
-    
+
+
     jobject javaObject()
     {
     	return jIOStream;
     };
-    
-    
+
+
 };
- 
+
 
 class JavaIOSystem : public Assimp::IOSystem {
 	private:
     JNIEnv* mJniEnv;
 	jobject& mJavaIOSystem;
-	
+
 	public:
 	JavaIOSystem(JNIEnv* env, jobject& javaIOSystem) :
 		mJniEnv(env),
 		mJavaIOSystem(javaIOSystem)
 	{};
-	
+
     bool Exists( const char* pFile) const
     {
     	jvalue params[1];
 		params[0].l = mJniEnv->NewStringUTF(pFile);
 	    return call(mJniEnv, mJavaIOSystem, "jassimp/AiIOSystem", "exists", "(Ljava/lang/String;)Z", params);
 
     };
     char getOsSeparator() const
     {
 	    return (char) callc(mJniEnv, mJavaIOSystem, "jassimp/AiIOSystem", "getOsSeparator", "()C");
     };
-    
+
     Assimp::IOStream* Open(const char* pFile,const char* pMode = "rb")
     {
         jvalue params[2];
 		params[0].l = mJniEnv->NewStringUTF(pFile);
 		params[1].l = mJniEnv->NewStringUTF(pMode);
-		
-		
+
+
 	    jobject jStream = callo(mJniEnv, mJavaIOSystem, "jassimp/AiIOSystem", "open", "(Ljava/lang/String;Ljava/lang/String;)Ljassimp/AiIOStream;", params);
 	    if(NULL == jStream)
 	    {
 	    	lprintf("NULL object from AiIOSystem.open\n");
 	    	return NULL;
 	    }
-	    
+	
 	    size_t size = calli(mJniEnv, jStream, "jassimp/AiIOStream", "getFileSize", "()I");
 	    lprintf("Model file size is %d\n", size);
-	    
+	
 	    char* buffer = (char*)malloc(size);
 	    jobject javaBuffer = mJniEnv->NewDirectByteBuffer(buffer, size);
-	    
+	
 	    jvalue readParams[1];
 	    readParams[0].l = javaBuffer;
 	    if(call(mJniEnv, jStream, "jassimp/AiIOStream", "read", "(Ljava/nio/ByteBuffer;)Z", readParams))
 	    {
 	    	return new JavaIOStream(size, buffer, jStream);
 		}
 		else
 		{
 			lprintf("Read failure on AiIOStream.read");
 			free(buffer);
 			return NULL;
 		}
 
     };
     void Close( Assimp::IOStream* pFile)
     {
-    	
+
 		jvalue params[1];
 		params[0].l = ((JavaIOStream*) pFile)->javaObject();
 		callv(mJniEnv, mJavaIOSystem, "jassimp/AiIOSystem", "close", "(Ljassimp/AiIOStream;)V", params);
     	delete pFile;
     };
-    
 
-	
+
+
 };
 
 class JavaProgressHandler : public Assimp::ProgressHandler {
 	private:
     JNIEnv* mJniEnv;
 	jobject& mJavaProgressHandler;
-	
+
 	public:
 	JavaProgressHandler(JNIEnv* env, jobject& javaProgressHandler) :
 		mJniEnv(env),
 		mJavaProgressHandler(javaProgressHandler)
 	{};
-	
+
     bool Update(float percentage)
     {
     	jvalue params[1];
 		params[0].f = percentage;
 	    return call(mJniEnv, mJavaProgressHandler, "jassimp/AiProgressHandler", "update", "(F)Z", params);
     }
 };
@@ -614,412 +614,412 @@ class JavaProgressHandler : public Assimp::ProgressHandler {
 static bool loadMeshes(JNIEnv *env, const aiScene* cScene, jobject& jScene)
 {
 	for (unsigned int meshNr = 0; meshNr < cScene->mNumMeshes; meshNr++)
 	{
 		const aiMesh *cMesh = cScene->mMeshes[meshNr];
 
 		lprintf("converting mesh %s ...\n", cMesh->mName.C_Str());
 
 		/* create mesh */
 		jobject jMesh = NULL;
 		SmartLocalRef refMesh(env, jMesh);
 
-		if (!createInstance(env, "jassimp/AiMesh", jMesh)) 
+		if (!createInstance(env, "jassimp/AiMesh", jMesh))
 		{
 			return false;
 		}
 
-		
+
 		/* add mesh to m_meshes java.util.List */
 		jobject jMeshes = NULL;
 		SmartLocalRef refMeshes(env, jMeshes);
 
 		if (!getField(env, jScene, "m_meshes", "Ljava/util/List;", jMeshes))
 		{
 			return false;
 		}
 
 		jvalue addParams[1];
 		addParams[0].l = jMesh;
 		if (!call(env, jMeshes, "java/util/Collection", "add", "(Ljava/lang/Object;)Z", addParams))
 		{
 			return false;
 		}
 
 
 		/* set general mesh data in java */
 		jvalue setTypesParams[1];
 		setTypesParams[0].i = cMesh->mPrimitiveTypes;
 		if (!callv(env, jMesh, "jassimp/AiMesh", "setPrimitiveTypes", "(I)V", setTypesParams))
 		{
 			return false;
 		}
 
 
 		if (!setIntField(env, jMesh, "m_materialIndex", cMesh->mMaterialIndex))
 		{
 			return false;
 		}
 
 		jstring nameString = env->NewStringUTF(cMesh->mName.C_Str());
 		SmartLocalRef refNameString(env, nameString);
 		if (!setObjectField(env, jMesh, "m_name", "Ljava/lang/String;", nameString))
 		{
 			return false;
 		}
 
 
 		/* determine face buffer size */
 		bool isPureTriangle = cMesh->mPrimitiveTypes == aiPrimitiveType_TRIANGLE;
 		size_t faceBufferSize;
-		if (isPureTriangle) 
+		if (isPureTriangle)
 		{
 			faceBufferSize = cMesh->mNumFaces * 3 * sizeof(unsigned int);
 		}
 		else
 		{
 			int numVertexReferences = 0;
 			for (unsigned int face = 0; face < cMesh->mNumFaces; face++)
 			{
 				numVertexReferences += cMesh->mFaces[face].mNumIndices;
 			}
 
 			faceBufferSize = numVertexReferences * sizeof(unsigned int);
 		}
 
 
 		/* allocate buffers - we do this from java so they can be garbage collected */
 		jvalue allocateBuffersParams[4];
 		allocateBuffersParams[0].i = cMesh->mNumVertices;
 		allocateBuffersParams[1].i = cMesh->mNumFaces;
 		allocateBuffersParams[2].z = isPureTriangle;
 		allocateBuffersParams[3].i = (jint) faceBufferSize;
 		if (!callv(env, jMesh, "jassimp/AiMesh", "allocateBuffers", "(IIZI)V", allocateBuffersParams))
 		{
 			return false;
 		}
 
 
 		if (cMesh->mNumVertices > 0)
 		{
 			/* push vertex data to java */
 			if (!copyBuffer(env, jMesh, "m_vertices", cMesh->mVertices, cMesh->mNumVertices * sizeof(aiVector3D)))
 			{
 				lprintf("could not copy vertex data\n");
 				return false;
 			}
 
 			lprintf("    with %u vertices\n", cMesh->mNumVertices);
 		}
 
 
 		/* push face data to java */
 		if (cMesh->mNumFaces > 0)
 		{
-			if (isPureTriangle) 
+			if (isPureTriangle)
 			{
 				char* faceBuffer = (char*) malloc(faceBufferSize);
 
 				size_t faceDataSize = 3 * sizeof(unsigned int);
 				for (unsigned int face = 0; face < cMesh->mNumFaces; face++)
 				{
 					memcpy(faceBuffer + face * faceDataSize, cMesh->mFaces[face].mIndices, faceDataSize);
 				}
 
 				bool res = copyBuffer(env, jMesh, "m_faces", faceBuffer, faceBufferSize);
 
 				free(faceBuffer);
 
-				if (!res) 
+				if (!res)
 				{
 					lprintf("could not copy face data\n");
 					return false;
 				}
 			}
 			else
 			{
 				char* faceBuffer = (char*) malloc(faceBufferSize);
 				char* offsetBuffer = (char*) malloc(cMesh->mNumFaces * sizeof(unsigned int));
 
 				size_t faceBufferPos = 0;
 				for (unsigned int face = 0; face < cMesh->mNumFaces; face++)
 				{
 					size_t faceBufferOffset = faceBufferPos / sizeof(unsigned int);
 					memcpy(offsetBuffer + face * sizeof(unsigned int), &faceBufferOffset, sizeof(unsigned int));
 
 					size_t faceDataSize = cMesh->mFaces[face].mNumIndices * sizeof(unsigned int);
 					memcpy(faceBuffer + faceBufferPos, cMesh->mFaces[face].mIndices, faceDataSize);
 					faceBufferPos += faceDataSize;
 				}
-		
+
 				if (faceBufferPos != faceBufferSize)
 				{
 					/* this should really not happen */
 					lprintf("faceBufferPos %u, faceBufferSize %u\n", faceBufferPos, faceBufferSize);
 					env->FatalError("error copying face data");
 					exit(-1);
 				}
 
 
 				bool res = copyBuffer(env, jMesh, "m_faces", faceBuffer, faceBufferSize);
 				res &= copyBuffer(env, jMesh, "m_faceOffsets", offsetBuffer, cMesh->mNumFaces * sizeof(unsigned int));
 
 				free(faceBuffer);
 				free(offsetBuffer);
 
-				if (!res) 
+				if (!res)
 				{
 					lprintf("could not copy face data\n");
 					return false;
 				}
 			}
 
 			lprintf("    with %u faces\n", cMesh->mNumFaces);
 		}
 
 
 		/* push normals to java */
 		if (cMesh->HasNormals())
 		{
 			jvalue allocateDataChannelParams[2];
 			allocateDataChannelParams[0].i = 0;
 			allocateDataChannelParams[1].i = 0;
 			if (!callv(env, jMesh, "jassimp/AiMesh", "allocateDataChannel", "(II)V", allocateDataChannelParams))
 			{
 				lprintf("could not allocate normal data channel\n");
 				return false;
 			}
 			if (!copyBuffer(env, jMesh, "m_normals", cMesh->mNormals, cMesh->mNumVertices * 3 * sizeof(float)))
 			{
 				lprintf("could not copy normal data\n");
 				return false;
 			}
 
 			lprintf("    with normals\n");
 		}
 
 
 		/* push tangents to java */
 		if (cMesh->mTangents != NULL)
 		{
 			jvalue allocateDataChannelParams[2];
 			allocateDataChannelParams[0].i = 1;
 			allocateDataChannelParams[1].i = 0;
 			if (!callv(env, jMesh, "jassimp/AiMesh", "allocateDataChannel", "(II)V", allocateDataChannelParams))
 			{
 				lprintf("could not allocate tangents data channel\n");
 				return false;
 			}
 			if (!copyBuffer(env, jMesh, "m_tangents", cMesh->mTangents, cMesh->mNumVertices * 3 * sizeof(float)))
 			{
 				lprintf("could not copy tangents data\n");
 				return false;
 			}
 
 			lprintf("    with tangents\n");
 		}
 
 
 		/* push bitangents to java */
 		if (cMesh->mBitangents != NULL)
 		{
 			jvalue allocateDataChannelParams[2];
 			allocateDataChannelParams[0].i = 2;
 			allocateDataChannelParams[1].i = 0;
 			if (!callv(env, jMesh, "jassimp/AiMesh", "allocateDataChannel", "(II)V", allocateDataChannelParams))
 			{
 				lprintf("could not allocate bitangents data channel\n");
 				return false;
 			}
 			if (!copyBuffer(env, jMesh, "m_bitangents", cMesh->mBitangents, cMesh->mNumVertices * 3 * sizeof(float)))
 			{
 				lprintf("could not copy bitangents data\n");
 				return false;
 			}
 
 			lprintf("    with bitangents\n");
 		}
 
 
 		/* push color sets to java */
 		for (int c = 0; c < AI_MAX_NUMBER_OF_COLOR_SETS; c++)
 		{
 			if (cMesh->mColors[c] != NULL)
 			{
 				jvalue allocateDataChannelParams[2];
 				allocateDataChannelParams[0].i = 3;
 				allocateDataChannelParams[1].i = c;
 				if (!callv(env, jMesh, "jassimp/AiMesh", "allocateDataChannel", "(II)V", allocateDataChannelParams))
 				{
 					lprintf("could not allocate colorset data channel\n");
 					return false;
 				}
 				if (!copyBufferArray(env, jMesh, "m_colorsets", c, cMesh->mColors[c], cMesh->mNumVertices * 4 * sizeof(float)))
 				{
 					lprintf("could not copy colorset data\n");
 					return false;
 				}
 
 				lprintf("    with colorset[%d]\n", c);
 			}
 		}
 
 
 		/* push tex coords to java */
 		for (int c = 0; c < AI_MAX_NUMBER_OF_TEXTURECOORDS; c++)
 		{
 			if (cMesh->mTextureCoords[c] != NULL)
 			{
 				jvalue allocateDataChannelParams[2];
 
 				switch (cMesh->mNumUVComponents[c])
 				{
 				case 1:
 					allocateDataChannelParams[0].i = 4;
 					break;
 				case 2:
 					allocateDataChannelParams[0].i = 5;
 					break;
 				case 3:
 					allocateDataChannelParams[0].i = 6;
 					break;
 				default:
 					return false;
 				}
 
 				allocateDataChannelParams[1].i = c;
 				if (!callv(env, jMesh, "jassimp/AiMesh", "allocateDataChannel", "(II)V", allocateDataChannelParams))
 				{
 					lprintf("could not allocate texture coordinates data channel\n");
 					return false;
 				}
 
 				/* gather data */
 				size_t coordBufferSize = cMesh->mNumVertices * cMesh->mNumUVComponents[c] * sizeof(float);
 				char* coordBuffer = (char*) malloc(coordBufferSize);
 				size_t coordBufferOffset = 0;
 
 				for (unsigned int v = 0; v < cMesh->mNumVertices; v++)
 				{
 					memcpy(coordBuffer + coordBufferOffset, &cMesh->mTextureCoords[c][v], cMesh->mNumUVComponents[c] * sizeof(float));
 					coordBufferOffset += cMesh->mNumUVComponents[c] * sizeof(float);
 				}
 
 				if (coordBufferOffset != coordBufferSize)
 				{
 					/* this should really not happen */
 					lprintf("coordBufferPos %u, coordBufferSize %u\n", coordBufferOffset, coordBufferSize);
 					env->FatalError("error copying coord data");
 					exit(-1);
 				}
 
 				bool res = copyBufferArray(env, jMesh, "m_texcoords", c, coordBuffer, coordBufferSize);
 
 				free(coordBuffer);
 
 				if (!res)
 				{
 					lprintf("could not copy texture coordinates data\n");
 					return false;
 				}
 
 				lprintf("    with %uD texcoord[%d]\n", cMesh->mNumUVComponents[c], c);
 			}
 		}
 
 
 		for (unsigned int b = 0; b < cMesh->mNumBones; b++)
 		{
 			aiBone *cBone = cMesh->mBones[b];
 
 			jobject jBone;
 			SmartLocalRef refBone(env, jBone);
-			if (!createInstance(env, "jassimp/AiBone", jBone)) 
+			if (!createInstance(env, "jassimp/AiBone", jBone))
 			{
 				return false;
 			}
 
 			/* add bone to bone list */
 			jobject jBones = NULL;
 			SmartLocalRef refBones(env, jBones);
 			if (!getField(env, jMesh, "m_bones", "Ljava/util/List;", jBones))
 			{
 				return false;
 			}
 
 			jvalue addParams[1];
 			addParams[0].l = jBone;
 			if (!call(env, jBones, "java/util/Collection", "add", "(Ljava/lang/Object;)Z", addParams))
 			{
 				return false;
 			}
 
 			/* set bone data */
 			jstring boneNameString = env->NewStringUTF(cBone->mName.C_Str());
 			SmartLocalRef refNameString(env, boneNameString);
 			if (!setObjectField(env, jBone, "m_name", "Ljava/lang/String;", boneNameString))
 			{
 				return false;
 			}
 
 			/* add bone weights */
 			for (unsigned int w = 0; w < cBone->mNumWeights; w++)
 			{
 				jobject jBoneWeight;
 				SmartLocalRef refBoneWeight(env, jBoneWeight);
 				if (!createInstance(env, "jassimp/AiBoneWeight", jBoneWeight))
 				{
 					return false;
 				}
 
 				/* add boneweight to bone list */
 				jobject jBoneWeights = NULL;
 				SmartLocalRef refBoneWeights(env, jBoneWeights);
 				if (!getField(env, jBone, "m_boneWeights", "Ljava/util/List;", jBoneWeights))
 				{
 					return false;
 				}
 
 				/* copy offset matrix */
 				jfloatArray jMatrixArr = env->NewFloatArray(16);
 				SmartLocalRef refMatrixArr(env, jMatrixArr);
 				env->SetFloatArrayRegion(jMatrixArr, 0, 16, (jfloat*) &cBone->mOffsetMatrix);
 
 				jvalue wrapParams[1];
 				wrapParams[0].l = jMatrixArr;
 				jobject jMatrix;
 				SmartLocalRef refMatrix(env, jMatrix);
-				
+
 				if (!callStaticObject(env, "jassimp/Jassimp", "wrapMatrix", "([F)Ljava/lang/Object;", wrapParams, jMatrix))
 				{
 					return false;
 				}
 
 				if (!setObjectField(env, jBone, "m_offsetMatrix", "Ljava/lang/Object;", jMatrix))
 				{
 					return false;
 				}
 
 
 				jvalue addBwParams[1];
 				addBwParams[0].l = jBoneWeight;
 				if (!call(env, jBoneWeights, "java/util/Collection", "add", "(Ljava/lang/Object;)Z", addBwParams))
 				{
 					return false;
 				}
 
 
 				if (!setIntField(env, jBoneWeight, "m_vertexId", cBone->mWeights[w].mVertexId))
 				{
 					return false;
 				}
-				
+
 				if (!setFloatField(env, jBoneWeight, "m_weight", cBone->mWeights[w].mWeight))
 				{
 					return false;
 				}
 			}
 		}
 	}
 
 	return true;
 }
@@ -1184,78 +1184,78 @@ static bool loadMetadata(JNIEnv *env, const aiNode* cNode, jobject& jNode)
 static bool loadSceneNode(JNIEnv *env, const aiNode *cNode, jobject parent, jobject* loadedNode = NULL)
 {
 	lprintf("   converting node %s ...\n", cNode->mName.C_Str());
 
 	/* wrap matrix */
 	jfloatArray jMatrixArr = env->NewFloatArray(16);
 	SmartLocalRef refMatrixArr(env, jMatrixArr);
 	env->SetFloatArrayRegion(jMatrixArr, 0, 16, (jfloat*) &cNode->mTransformation);
 
 	jvalue wrapMatParams[1];
 	wrapMatParams[0].l = jMatrixArr;
 	jobject jMatrix;
 	SmartLocalRef refMatrix(env, jMatrix);
 
 	if (!callStaticObject(env, "jassimp/Jassimp", "wrapMatrix", "([F)Ljava/lang/Object;", wrapMatParams, jMatrix))
 	{
 		return false;
 	}
 
 
 	/* create mesh references array */
 	jintArray jMeshrefArr = env->NewIntArray(cNode->mNumMeshes);
 	SmartLocalRef refMeshrefArr(env, jMeshrefArr);
 
 	jint *temp = (jint*) malloc(sizeof(jint) * cNode->mNumMeshes);
 
 	for (unsigned int i = 0; i < cNode->mNumMeshes; i++)
 	{
 		temp[i] = cNode->mMeshes[i];
 	}
 	env->SetIntArrayRegion(jMeshrefArr, 0, cNode->mNumMeshes, (jint*) temp);
 
 	free(temp);
 
 
 	/* convert name */
 	jstring jNodeName = env->NewStringUTF(cNode->mName.C_Str());
 	SmartLocalRef refNodeName(env, jNodeName);
 
 	/* wrap scene node */
 	jvalue wrapNodeParams[4];
 	wrapNodeParams[0].l = parent;
 	wrapNodeParams[1].l = jMatrix;
 	wrapNodeParams[2].l = jMeshrefArr;
 	wrapNodeParams[3].l = jNodeName;
 	jobject jNode;
 	if (!callStaticObject(env, "jassimp/Jassimp", "wrapSceneNode",
-		"(Ljava/lang/Object;Ljava/lang/Object;[ILjava/lang/String;)Ljava/lang/Object;", wrapNodeParams, jNode)) 
+		"(Ljava/lang/Object;Ljava/lang/Object;[ILjava/lang/String;)Ljava/lang/Object;", wrapNodeParams, jNode))
 	{
 		return false;
 	}
 
 
 	/* and recurse */
 	for (unsigned int c = 0; c < cNode->mNumChildren; c++)
 	{
 		if (!loadSceneNode(env, cNode->mChildren[c], jNode))
 		{
 			return false;
 		}
 	}
 
     if (NULL != loadedNode)
     {
         if(cNode->mMetaData) {
             if(!loadMetadata(env, cNode, jNode))
             {
                 return false;
             }
         }
 
         *loadedNode = jNode;
     } else {
         env->DeleteLocalRef(jNode);
     }
 
 	return true;
 }
@@ -1287,542 +1287,542 @@ static bool loadSceneGraph(JNIEnv *env, const aiScene* cScene, jobject& jScene)
 }
 
 
-static bool loadMaterials(JNIEnv *env, const aiScene* cScene, jobject& jScene) 
+static bool loadMaterials(JNIEnv *env, const aiScene* cScene, jobject& jScene)
 {
 	for (unsigned int m = 0; m < cScene->mNumMaterials; m++)
 	{
 		const aiMaterial* cMaterial = cScene->mMaterials[m];
 
 		lprintf("converting material %d ...\n", m);
 
 		jobject jMaterial = NULL;
 		SmartLocalRef refMaterial(env, jMaterial);
 
 		if (!createInstance(env, "jassimp/AiMaterial", jMaterial))
 		{
 			return false;
 		}
 
 		/* add material to m_materials java.util.List */
 		jobject jMaterials = NULL;
 		SmartLocalRef refMaterials(env, jMaterials);
 
 		if (!getField(env, jScene, "m_materials", "Ljava/util/List;", jMaterials))
 		{
 			return false;
 		}
 
 		jvalue addMatParams[1];
 		addMatParams[0].l = jMaterial;
 		if (!call(env, jMaterials, "java/util/Collection", "add", "(Ljava/lang/Object;)Z", addMatParams))
 		{
 			return false;
 		}
 
 		/* set texture numbers */
-		for (int ttInd = aiTextureType_DIFFUSE; ttInd < aiTextureType_UNKNOWN; ttInd++) 
+		for (int ttInd = aiTextureType_DIFFUSE; ttInd < aiTextureType_UNKNOWN; ttInd++)
 		{
 			aiTextureType tt = static_cast<aiTextureType>(ttInd);
 
 			unsigned int num = cMaterial->GetTextureCount(tt);
 
 			lprintf("   found %d textures of type %d ...\n", num, ttInd);
 
 			jvalue setNumberParams[2];
 			setNumberParams[0].i = ttInd;
 			setNumberParams[1].i = num;
 
 			if (!callv(env, jMaterial, "jassimp/AiMaterial", "setTextureNumber", "(II)V", setNumberParams))
 			{
 				return false;
 			}
 		}
 
 
 		for (unsigned int p = 0; p < cMaterial->mNumProperties; p++)
 		{
-			//printf("%s - %u - %u\n", cScene->mMaterials[m]->mProperties[p]->mKey.C_Str(), 
+			//printf("%s - %u - %u\n", cScene->mMaterials[m]->mProperties[p]->mKey.C_Str(),
 			//	cScene->mMaterials[m]->mProperties[p]->mSemantic,
 			//	cScene->mMaterials[m]->mProperties[p]->mDataLength);
 
 			const aiMaterialProperty* cProperty = cMaterial->mProperties[p];
 
 			lprintf("   converting property %s ...\n", cProperty->mKey.C_Str());
 
 			jobject jProperty = NULL;
 			SmartLocalRef refProperty(env, jProperty);
 
 			jvalue constructorParams[5];
 			jstring keyString = env->NewStringUTF(cProperty->mKey.C_Str());
 			SmartLocalRef refKeyString(env, keyString);
 			constructorParams[0].l = keyString;
 			constructorParams[1].i = cProperty->mSemantic;
 			constructorParams[2].i = cProperty->mIndex;
 			constructorParams[3].i = cProperty->mType;
 
 
 			/* special case conversion for color3 */
-			if (NULL != strstr(cProperty->mKey.C_Str(), "clr") && 
+			if (NULL != strstr(cProperty->mKey.C_Str(), "clr") &&
 				cProperty->mType == aiPTI_Float &&
-				cProperty->mDataLength == 3 * sizeof(float)) 
+				cProperty->mDataLength == 3 * sizeof(float))
 			{
 				jobject jData = NULL;
 				SmartLocalRef refData(env, jData);
 
 				/* wrap color */
 				jvalue wrapColorParams[3];
 				wrapColorParams[0].f = ((float*) cProperty->mData)[0];
 				wrapColorParams[1].f = ((float*) cProperty->mData)[1];
 				wrapColorParams[2].f = ((float*) cProperty->mData)[2];
 				if (!callStaticObject(env, "jassimp/Jassimp", "wrapColor3", "(FFF)Ljava/lang/Object;", wrapColorParams, jData))
 				{
 					return false;
 				}
 
 				constructorParams[4].l = jData;
-				if (!createInstance(env, "jassimp/AiMaterial$Property", "(Ljava/lang/String;IIILjava/lang/Object;)V", 
+				if (!createInstance(env, "jassimp/AiMaterial$Property", "(Ljava/lang/String;IIILjava/lang/Object;)V",
 					constructorParams, jProperty))
 				{
 					return false;
 				}
 			}
 			/* special case conversion for color4 */
-			else if (NULL != strstr(cProperty->mKey.C_Str(), "clr") && 
+			else if (NULL != strstr(cProperty->mKey.C_Str(), "clr") &&
 				cProperty->mType == aiPTI_Float &&
-				cProperty->mDataLength == 4 * sizeof(float)) 
+				cProperty->mDataLength == 4 * sizeof(float))
 			{
 				jobject jData = NULL;
 				SmartLocalRef refData(env, jData);
 
 				/* wrap color */
 				jvalue wrapColorParams[4];
 				wrapColorParams[0].f = ((float*) cProperty->mData)[0];
 				wrapColorParams[1].f = ((float*) cProperty->mData)[1];
 				wrapColorParams[2].f = ((float*) cProperty->mData)[2];
 				wrapColorParams[3].f = ((float*) cProperty->mData)[3];
 				if (!callStaticObject(env, "jassimp/Jassimp", "wrapColor4", "(FFFF)Ljava/lang/Object;", wrapColorParams, jData))
 				{
 					return false;
 				}
 
 				constructorParams[4].l = jData;
-				if (!createInstance(env, "jassimp/AiMaterial$Property", "(Ljava/lang/String;IIILjava/lang/Object;)V", 
+				if (!createInstance(env, "jassimp/AiMaterial$Property", "(Ljava/lang/String;IIILjava/lang/Object;)V",
 					constructorParams, jProperty))
 				{
 					return false;
 				}
 			}
-			else if (cProperty->mType == aiPTI_Float && cProperty->mDataLength == sizeof(float)) 
+			else if (cProperty->mType == aiPTI_Float && cProperty->mDataLength == sizeof(float))
 			{
 				jobject jData = NULL;
 				SmartLocalRef refData(env, jData);
 
 				jvalue newFloatParams[1];
 				newFloatParams[0].f = ((float*) cProperty->mData)[0];
 				if (!createInstance(env, "java/lang/Float", "(F)V", newFloatParams, jData))
 				{
 					return false;
 				}
 
 				constructorParams[4].l = jData;
-				if (!createInstance(env, "jassimp/AiMaterial$Property", "(Ljava/lang/String;IIILjava/lang/Object;)V", 
+				if (!createInstance(env, "jassimp/AiMaterial$Property", "(Ljava/lang/String;IIILjava/lang/Object;)V",
 					constructorParams, jProperty))
 				{
 					return false;
 				}
 			}
-			else if (cProperty->mType == aiPTI_Integer && cProperty->mDataLength == sizeof(int)) 
+			else if (cProperty->mType == aiPTI_Integer && cProperty->mDataLength == sizeof(int))
 			{
 				jobject jData = NULL;
 				SmartLocalRef refData(env, jData);
 
 				jvalue newIntParams[1];
 				newIntParams[0].i = ((int*) cProperty->mData)[0];
 				if (!createInstance(env, "java/lang/Integer", "(I)V", newIntParams, jData))
 				{
 					return false;
 				}
 
 				constructorParams[4].l = jData;
-				if (!createInstance(env, "jassimp/AiMaterial$Property", "(Ljava/lang/String;IIILjava/lang/Object;)V", 
+				if (!createInstance(env, "jassimp/AiMaterial$Property", "(Ljava/lang/String;IIILjava/lang/Object;)V",
 					constructorParams, jProperty))
 				{
 					return false;
 				}
 			}
-			else if (cProperty->mType == aiPTI_String) 
+			else if (cProperty->mType == aiPTI_String)
 			{
 				/* skip length prefix */
 				jobject jData = env->NewStringUTF(cProperty->mData + 4);
 				SmartLocalRef refData(env, jData);
 
 				constructorParams[4].l = jData;
-				if (!createInstance(env, "jassimp/AiMaterial$Property", "(Ljava/lang/String;IIILjava/lang/Object;)V", 
+				if (!createInstance(env, "jassimp/AiMaterial$Property", "(Ljava/lang/String;IIILjava/lang/Object;)V",
 					constructorParams, jProperty))
 				{
 					return false;
 				}
 			}
-			else 
+			else
 			{
 				constructorParams[4].i = cProperty->mDataLength;
 
 				/* generic copy code, uses dump ByteBuffer on java side */
 				if (!createInstance(env, "jassimp/AiMaterial$Property", "(Ljava/lang/String;IIII)V", constructorParams, jProperty))
 				{
 					return false;
 				}
 
 				jobject jBuffer = NULL;
 				SmartLocalRef refBuffer(env, jBuffer);
 				if (!getField(env, jProperty, "m_data", "Ljava/lang/Object;", jBuffer))
 				{
 					return false;
 				}
 
 				if (env->GetDirectBufferCapacity(jBuffer) != cProperty->mDataLength)
 				{
 					lprintf("invalid direct buffer\n");
 					return false;
 				}
 
 				void* jBufferPtr = env->GetDirectBufferAddress(jBuffer);
 
 				if (NULL == jBufferPtr)
 				{
 					lprintf("could not access direct buffer\n");
 					return false;
 				}
 
 				memcpy(jBufferPtr, cProperty->mData, cProperty->mDataLength);
 			}
 
 
 			/* add property */
 			jobject jProperties = NULL;
 			SmartLocalRef refProperties(env, jProperties);
 			if (!getField(env, jMaterial, "m_properties", "Ljava/util/List;", jProperties))
 			{
 				return false;
 			}
 
 			jvalue addPropParams[1];
 			addPropParams[0].l = jProperty;
 			if (!call(env, jProperties, "java/util/Collection", "add", "(Ljava/lang/Object;)Z", addPropParams))
 			{
 				return false;
 			}
 		}
 	}
 
 	lprintf("materials finished\n");
 
 	return true;
 }
 
 
-static bool loadAnimations(JNIEnv *env, const aiScene* cScene, jobject& jScene) 
+static bool loadAnimations(JNIEnv *env, const aiScene* cScene, jobject& jScene)
 {
 	lprintf("converting %d animations ...\n", cScene->mNumAnimations);
 
 	for (unsigned int a = 0; a < cScene->mNumAnimations; a++)
 	{
 		const aiAnimation *cAnimation = cScene->mAnimations[a];
 
 		lprintf("   converting animation %s ...\n", cAnimation->mName.C_Str());
 
 		jobject jAnimation;
 		SmartLocalRef refAnimation(env, jAnimation);
 
 		jvalue newAnimParams[3];
 		jstring nameString = env->NewStringUTF(cAnimation->mName.C_Str());
 		SmartLocalRef refNameString(env, nameString);
 		newAnimParams[0].l = nameString;
 		newAnimParams[1].d = cAnimation->mDuration;
 		newAnimParams[2].d = cAnimation->mTicksPerSecond;
 
 		if (!createInstance(env, "jassimp/AiAnimation", "(Ljava/lang/String;DD)V", newAnimParams, jAnimation))
 		{
 			return false;
 		}
 
 		/* add animation to m_animations java.util.List */
 		jobject jAnimations = NULL;
 		SmartLocalRef refAnimations(env, jAnimations);
 
 		if (!getField(env, jScene, "m_animations", "Ljava/util/List;", jAnimations))
 		{
 			return false;
 		}
 
 		jvalue addParams[1];
 		addParams[0].l = jAnimation;
 		if (!call(env, jAnimations, "java/util/Collection", "add", "(Ljava/lang/Object;)Z", addParams))
 		{
 			return false;
 		}
 
 
 		for (unsigned int c = 0; c < cAnimation->mNumChannels; c++)
 		{
 			const aiNodeAnim *cNodeAnim = cAnimation->mChannels[c];
 
 			jobject jNodeAnim;
 			SmartLocalRef refNodeAnim(env, jNodeAnim);
 
 			jvalue newNodeAnimParams[6];
 			jstring animationName = env->NewStringUTF(cNodeAnim->mNodeName.C_Str());
 			SmartLocalRef refAnimationName(env, animationName);
 			newNodeAnimParams[0].l = animationName;
 			newNodeAnimParams[1].i = cNodeAnim->mNumPositionKeys;
 			newNodeAnimParams[2].i = cNodeAnim->mNumRotationKeys;
 			newNodeAnimParams[3].i = cNodeAnim->mNumScalingKeys;
 			newNodeAnimParams[4].i = cNodeAnim->mPreState;
 			newNodeAnimParams[5].i = cNodeAnim->mPostState;
 
 			if (!createInstance(env, "jassimp/AiNodeAnim", "(Ljava/lang/String;IIIII)V", newNodeAnimParams, jNodeAnim))
 			{
 				return false;
 			}
 
 
 			/* add nodeanim to m_animations java.util.List */
 			jobject jNodeAnims = NULL;
 			SmartLocalRef refNodeAnims(env, jNodeAnims);
 
 			if (!getField(env, jAnimation, "m_nodeAnims", "Ljava/util/List;", jNodeAnims))
 			{
 				return false;
 			}
 
 			jvalue addParams[1];
 			addParams[0].l = jNodeAnim;
 			if (!call(env, jNodeAnims, "java/util/Collection", "add", "(Ljava/lang/Object;)Z", addParams))
 			{
 				return false;
 			}
 
 			/* copy keys */
-			if (!copyBuffer(env, jNodeAnim, "m_posKeys", cNodeAnim->mPositionKeys, 
+			if (!copyBuffer(env, jNodeAnim, "m_posKeys", cNodeAnim->mPositionKeys,
 				cNodeAnim->mNumPositionKeys * sizeof(aiVectorKey)))
 			{
 				return false;
 			}
 
-			if (!copyBuffer(env, jNodeAnim, "m_rotKeys", cNodeAnim->mRotationKeys, 
+			if (!copyBuffer(env, jNodeAnim, "m_rotKeys", cNodeAnim->mRotationKeys,
 				cNodeAnim->mNumRotationKeys * sizeof(aiQuatKey)))
 			{
 				return false;
 			}
 
-			if (!copyBuffer(env, jNodeAnim, "m_scaleKeys", cNodeAnim->mScalingKeys, 
+			if (!copyBuffer(env, jNodeAnim, "m_scaleKeys", cNodeAnim->mScalingKeys,
 				cNodeAnim->mNumScalingKeys * sizeof(aiVectorKey)))
 			{
 				return false;
 			}
 		}
 	}
 
 	lprintf("converting animations finished\n");
 
 	return true;
 }
 
 
-static bool loadLights(JNIEnv *env, const aiScene* cScene, jobject& jScene) 
+static bool loadLights(JNIEnv *env, const aiScene* cScene, jobject& jScene)
 {
 	lprintf("converting %d lights ...\n", cScene->mNumLights);
 
 	for (unsigned int l = 0; l < cScene->mNumLights; l++)
 	{
 		const aiLight *cLight = cScene->mLights[l];
 
 		lprintf("converting light %s ...\n", cLight->mName.C_Str());
 
 		/* wrap color nodes */
 		jvalue wrapColorParams[3];
 		wrapColorParams[0].f = cLight->mColorDiffuse.r;
 		wrapColorParams[1].f = cLight->mColorDiffuse.g;
 		wrapColorParams[2].f = cLight->mColorDiffuse.b;
 		jobject jDiffuse;
 		SmartLocalRef refDiffuse(env, jDiffuse);
 		if (!callStaticObject(env, "jassimp/Jassimp", "wrapColor3", "(FFF)Ljava/lang/Object;", wrapColorParams, jDiffuse))
 		{
 			return false;
 		}
 
 		wrapColorParams[0].f = cLight->mColorSpecular.r;
 		wrapColorParams[1].f = cLight->mColorSpecular.g;
 		wrapColorParams[2].f = cLight->mColorSpecular.b;
 		jobject jSpecular;
 		SmartLocalRef refSpecular(env, jSpecular);
 		if (!callStaticObject(env, "jassimp/Jassimp", "wrapColor3", "(FFF)Ljava/lang/Object;", wrapColorParams, jSpecular))
 		{
 			return false;
 		}
 
 		wrapColorParams[0].f = cLight->mColorAmbient.r;
 		wrapColorParams[1].f = cLight->mColorAmbient.g;
 		wrapColorParams[2].f = cLight->mColorAmbient.b;
 		jobject jAmbient;
 		SmartLocalRef refAmbient(env, jAmbient);
 		if (!callStaticObject(env, "jassimp/Jassimp", "wrapColor3", "(FFF)Ljava/lang/Object;", wrapColorParams, jAmbient))
 		{
 			return false;
 		}
 
 
 		/* wrap vec3 nodes */
 		jvalue wrapVec3Params[3];
 		wrapVec3Params[0].f = cLight->mPosition.x;
 		wrapVec3Params[1].f = cLight->mPosition.y;
 		wrapVec3Params[2].f = cLight->mPosition.z;
 		jobject jPosition;
 		SmartLocalRef refPosition(env, jPosition);
 		if (!callStaticObject(env, "jassimp/Jassimp", "wrapVec3", "(FFF)Ljava/lang/Object;", wrapVec3Params, jPosition))
 		{
 			return false;
 		}
 
 		wrapVec3Params[0].f = cLight->mPosition.x;
 		wrapVec3Params[1].f = cLight->mPosition.y;
 		wrapVec3Params[2].f = cLight->mPosition.z;
 		jobject jDirection;
 		SmartLocalRef refDirection(env, jDirection);
 		if (!callStaticObject(env, "jassimp/Jassimp", "wrapVec3", "(FFF)Ljava/lang/Object;", wrapVec3Params, jDirection))
 		{
 			return false;
 		}
 
 
 		jobject jLight;
 		SmartLocalRef refLight(env, jLight);
 		jvalue params[12];
 		jstring lightName = env->NewStringUTF(cLight->mName.C_Str());
 		SmartLocalRef refLightName(env, lightName);
 		params[0].l = lightName;
 		params[1].i = cLight->mType;
 		params[2].l = jPosition;
 		params[3].l = jDirection;
 		params[4].f = cLight->mAttenuationConstant;
 		params[5].f = cLight->mAttenuationLinear;
 		params[6].f = cLight->mAttenuationQuadratic;
 		params[7].l = jDiffuse;
 		params[8].l = jSpecular;
 		params[9].l = jAmbient;
 		params[10].f = cLight->mAngleInnerCone;
 		params[11].f = cLight->mAngleOuterCone;
-		
+
 		if (!createInstance(env, "jassimp/AiLight", "(Ljava/lang/String;ILjava/lang/Object;Ljava/lang/Object;FFFLjava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;FF)V",
 			params, jLight))
 		{
 			return false;
 		}
 
 		/* add light to m_lights java.util.List */
 		jobject jLights = NULL;
 		SmartLocalRef refLights(env, jLights);
 
 		if (!getField(env, jScene, "m_lights", "Ljava/util/List;", jLights))
 		{
 			return false;
 		}
 
 		jvalue addParams[1];
 		addParams[0].l = jLight;
 		if (!call(env, jLights, "java/util/Collection", "add", "(Ljava/lang/Object;)Z", addParams))
 		{
 			return false;
 		}
 	}
 
-	lprintf("converting lights finished ...\n"); 
+	lprintf("converting lights finished ...\n");
 
 	return true;
 }
 
 
-static bool loadCameras(JNIEnv *env, const aiScene* cScene, jobject& jScene) 
+static bool loadCameras(JNIEnv *env, const aiScene* cScene, jobject& jScene)
 {
 	lprintf("converting %d cameras ...\n", cScene->mNumCameras);
 
 	for (unsigned int c = 0; c < cScene->mNumCameras; c++)
 	{
 		const aiCamera *cCamera = cScene->mCameras[c];
 
 		lprintf("converting camera %s ...\n", cCamera->mName.C_Str());
 
 		/* wrap color nodes */
 		jvalue wrapPositionParams[3];
 		wrapPositionParams[0].f = cCamera->mPosition.x;
 		wrapPositionParams[1].f = cCamera->mPosition.y;
 		wrapPositionParams[2].f = cCamera->mPosition.z;
 		jobject jPosition;
 		SmartLocalRef refPosition(env, jPosition);
 		if (!callStaticObject(env, "jassimp/Jassimp", "wrapVec3", "(FFF)Ljava/lang/Object;", wrapPositionParams, jPosition))
 		{
 			return false;
 		}
 
 		wrapPositionParams[0].f = cCamera->mUp.x;
 		wrapPositionParams[1].f = cCamera->mUp.y;
 		wrapPositionParams[2].f = cCamera->mUp.z;
 		jobject jUp;
 		SmartLocalRef refUp(env, jUp);
 		if (!callStaticObject(env, "jassimp/Jassimp", "wrapVec3", "(FFF)Ljava/lang/Object;", wrapPositionParams, jUp))
 		{
 			return false;
 		}
 
 		wrapPositionParams[0].f = cCamera->mLookAt.x;
 		wrapPositionParams[1].f = cCamera->mLookAt.y;
 		wrapPositionParams[2].f = cCamera->mLookAt.z;
 		jobject jLookAt;
 		SmartLocalRef refLookAt(env, jLookAt);
 		if (!callStaticObject(env, "jassimp/Jassimp", "wrapVec3", "(FFF)Ljava/lang/Object;", wrapPositionParams, jLookAt))
 		{
 			return false;
 		}
 
 
 		jobject jCamera;
 		SmartLocalRef refCamera(env, jCamera);
 
 		jvalue params[8];
 		jstring cameraName = env->NewStringUTF(cCamera->mName.C_Str());
 		SmartLocalRef refCameraName(env, cameraName);
 		params[0].l = cameraName;
 		params[1].l = jPosition;
 		params[2].l = jUp;
 		params[3].l = jLookAt;
 		params[4].f = cCamera->mHorizontalFOV;
 		params[5].f = cCamera->mClipPlaneNear;
 		params[6].f = cCamera->mClipPlaneFar;
 		params[7].f = cCamera->mAspect;
-		
+
 		if (!createInstance(env, "jassimp/AiCamera", "(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;FFFF)V",
 			params, jCamera))
 		{
 			return false;
 		}
 
 		/* add camera to m_cameras java.util.List */
 		jobject jCameras = NULL;
 		SmartLocalRef refCameras(env, jCameras);
 		if (!getField(env, jScene, "m_cameras", "Ljava/util/List;", jCameras))
 		{
 			return false;
 		}
 
 		jvalue addParams[1];
 		addParams[0].l = jCamera;
 		if (!call(env, jCameras, "java/util/Collection", "add", "(Ljava/lang/Object;)Z", addParams))
 		{
 			return false;
 		}
 	}
 
 	lprintf("converting cameras finished\n");
 
 	return true;
 }
@@ -1901,70 +1901,70 @@ JNIEXPORT jstring JNICALL Java_jassimp_Jassimp_getErrorString
 JNIEXPORT jobject JNICALL Java_jassimp_Jassimp_aiImportFile
   (JNIEnv *env, jclass jClazz, jstring jFilename, jlong postProcess, jobject ioSystem, jobject progressHandler)
 {
-	jobject jScene = NULL; 
+	jobject jScene = NULL;
 
 	/* convert params */
 	const char* cFilename = env->GetStringUTFChars(jFilename, NULL);
-	
+
     Assimp::Importer imp;
 
-	
+
 	if(ioSystem != NULL)
 	{
-		imp.SetIOHandler(new JavaIOSystem(env, ioSystem));		
+		imp.SetIOHandler(new JavaIOSystem(env, ioSystem));
 		lprintf("Created aiFileIO\n");
 	}
-	
+
 	if(progressHandler != NULL)
 	{
 		imp.SetProgressHandler(new JavaProgressHandler(env, progressHandler));
 	}
-	
+
 	lprintf("opening file: %s\n", cFilename);
 
 	/* do import */
 	const aiScene *cScene = imp.ReadFile(cFilename, (unsigned int) postProcess);
 
 	if (!cScene)
 	{
 		lprintf("import file returned null\n");
 		goto error;
 	}
 
-	if (!createInstance(env, "jassimp/AiScene", jScene)) 
+	if (!createInstance(env, "jassimp/AiScene", jScene))
 	{
 		goto error;
 	}
 
 	if (!loadMeshes(env, cScene, jScene))
 	{
 		goto error;
 	}
 
 	if (!loadMaterials(env, cScene, jScene))
 	{
 		goto error;
 	}
 
 	if (!loadAnimations(env, cScene, jScene))
 	{
 		goto error;
 	}
 
 	if (!loadLights(env, cScene, jScene))
 	{
 		goto error;
 	}
 
 	if (!loadCameras(env, cScene, jScene))
 	{
 		goto error;
 	}
 
 	if (!loadSceneGraph(env, cScene, jScene))
 	{
 		goto error;
 	}
 
 	/* jump over error handling section */
 	goto end;
diff --git a/samples/SimpleAssimpViewX/ModelLoaderHelperClasses.h b/samples/SimpleAssimpViewX/ModelLoaderHelperClasses.h
index 0e6dfab3c..1803ad122 100644
--- a/samples/SimpleAssimpViewX/ModelLoaderHelperClasses.h
+++ b/samples/SimpleAssimpViewX/ModelLoaderHelperClasses.h
@@ -1,98 +1,98 @@
 //
 //  v002MeshHelper.h
 //  v002 Model Importer
 //
 //  Created by vade on 9/26/10.
 //  Copyright 2010 __MyCompanyName__. All rights reserved.
 //
 
 #import <Cocoa/Cocoa.h>
 #import <OpenGL/OpenGL.h>
 #import "color4.h"
 #import "vector3.h"
 #import "vector2.h"
 #import "matrix4x4.h"
 
 /* workflow:
 
- 1) create a new scene wrapper 
+ 1) create a new scene wrapper
  2) populate an array of of meshHelpers for each mesh in the original scene
  3) (eventually) create an animator instance
  4) scale the asset (needed?)
  5) create the asset data (GL resources, textures etc)
     5a) for each mesh create a material instance
     5b) create a static vertex buffer
     5c) create index buffer
     5d) populate the index buffer
-    5e) (eventually) gather weights    
+    5e) (eventually) gather weights
 */
 
 #define BUFFER_OFFSET(i) ((char *)NULL + (i))
 
-struct Vertex 
+struct Vertex
 {
     aiVector3D vPosition;
     aiVector3D vNormal;
-    
+
     aiColor4D  dColorDiffuse;
     aiVector3D vTangent;
     aiVector3D vBitangent;
     aiVector3D vTextureUV;
     aiVector3D vTextureUV2;
     unsigned char mBoneIndices[4];
     unsigned char mBoneWeights[4]; // last Weight not used, calculated inside the vertex shader
 };
 
 
 // Helper Class to store GPU related resources from a given aiMesh
 // Modeled after AssimpView asset helper
-@interface MeshHelper : NSObject 
-{        
+@interface MeshHelper : NSObject
+{
     // Display list ID, this one shots *all drawing* of the mesh. Only ever use this to draw. Booya.
     GLuint displayList;
-    
+
     // VAO that encapsulates all VBO drawing state
     GLuint vao;
-    
+
     // VBOs
     GLuint vertexBuffer;
     GLuint indexBuffer;
     GLuint normalBuffer;
     GLuint numIndices;
-        
+
     // texture
     GLuint textureID;
-    
-    // Material 
+
+    // Material
     aiColor4D diffuseColor;
     aiColor4D specularColor;
     aiColor4D ambientColor;
     aiColor4D emissiveColor;
-    
+
     GLfloat opacity;
     GLfloat shininess;
     GLfloat specularStrength;
-    
+
     BOOL twoSided;
 }
 
 @property (readwrite, assign) GLuint vao;
 @property (readwrite, assign) GLuint displayList;
 
 @property (readwrite, assign) GLuint vertexBuffer;
 @property (readwrite, assign) GLuint indexBuffer;
 @property (readwrite, assign) GLuint normalBuffer;
 @property (readwrite, assign) GLuint numIndices;
 
 @property (readwrite, assign) GLuint textureID;
 
 @property (readwrite, assign) aiColor4D* diffuseColor;
 @property (readwrite, assign) aiColor4D* specularColor;
 @property (readwrite, assign) aiColor4D* ambientColor;
 @property (readwrite, assign) aiColor4D* emissiveColor;
 
 @property (readwrite, assign) GLfloat opacity;
 @property (readwrite, assign) GLfloat shininess;
 @property (readwrite, assign) GLfloat specularStrength;
 @property (readwrite, assign) BOOL twoSided;
 @end
diff --git a/samples/SimpleAssimpViewX/MyDocument.h b/samples/SimpleAssimpViewX/MyDocument.h
index 16745dc3c..67675e306 100644
--- a/samples/SimpleAssimpViewX/MyDocument.h
+++ b/samples/SimpleAssimpViewX/MyDocument.h
@@ -1,60 +1,60 @@
 //
 //  MyDocument.h
 //  DisplayLinkAsyncMoviePlayer
 //
 //  Created by vade on 10/26/10.
 //  Copyright __MyCompanyName__ 2010 . All rights reserved.
 //
 
 
 #import "ModelLoaderHelperClasses.h"
 
 // assimp include files. These three are usually needed.
 #import "cimport.h"
 #import "postprocess.h"
 #import "scene.h"
 #import "types.h"
 
 #import <Cocoa/Cocoa.h>
 #import <OpenGL/OpenGL.h>
 #import <Quartz/Quartz.h>
 
 
-@interface MyDocument : NSPersistentDocument 
+@interface MyDocument : NSPersistentDocument
 {
     CVDisplayLinkRef _displayLink;
     NSOpenGLContext* _glContext;
     NSOpenGLPixelFormat* _glPixelFormat;
-    
+
     NSView* _view;
-    
+
     // Assimp Stuff
     aiScene* _scene;
     aiVector3D scene_min, scene_max, scene_center;
-    double normalizedScale;    
-    
+    double normalizedScale;
+
     // Our array of textures.
     GLuint *textureIds;
-    
+
     // only used if we use
-    NSMutableArray* modelMeshes;   
+    NSMutableArray* modelMeshes;
     BOOL builtBuffers;
-    
-    NSMutableDictionary* textureDictionary;	// Array of Dicionaries that map image filenames to textureIds      
+
+    NSMutableDictionary* textureDictionary;	// Array of Dicionaries that map image filenames to textureIds
 }
 
 @property (retain) IBOutlet NSView* _view;
 
 
 - (CVReturn)displayLinkRenderCallback:(const CVTimeStamp *)timeStamp;
 - (void) render;
 
 - (void) drawMeshesInContext:(CGLContextObj)cgl_ctx;
 - (void) createGLResourcesInContext:(CGLContextObj)cgl_ctx;
 - (void) deleteGLResourcesInContext:(CGLContextObj)cgl_ctx;
 
 - (void) loadTexturesInContext:(CGLContextObj)cgl_ctx withModelPath:(NSString*) modelPath;
 - (void) getBoundingBoxWithMinVector:(aiVector3D*) min maxVectr:(aiVector3D*) max;
 - (void) getBoundingBoxForNode:(const aiNode*)nd  minVector:(aiVector3D*) min maxVector:(aiVector3D*) max matrix:(aiMatrix4x4*) trafo;
 
 @end
diff --git a/samples/SimpleOpenGL/Sample_SimpleOpenGL.c b/samples/SimpleOpenGL/Sample_SimpleOpenGL.c
index bcb109564..7aa306ed4 100644
--- a/samples/SimpleOpenGL/Sample_SimpleOpenGL.c
+++ b/samples/SimpleOpenGL/Sample_SimpleOpenGL.c
@@ -29,8 +29,8 @@
 
 /* ---------------------------------------------------------------------------- */
 inline static void print_run_command(const char* command_name) {
-	printf("Run '%s %s' for more information.\n", 
+	printf("Run '%s %s' for more information.\n",
 		PROJECT_NAME, command_name);
 }
 
 /* ---------------------------------------------------------------------------- */
@@ -43,19 +43,19 @@ inline static void print_error(const char* msg) {
 
 /* ---------------------------------------------------------------------------- */
 inline static void print_usage() {
-	static const char* usage_format = 
+	static const char* usage_format =
 		"Usage: "
 		PROJECT_NAME
 		" <file>"	 DOUBLE_NEW_LINE
 		"where:"	 DOUBLE_NEW_LINE
 		"  %-10s %s" DOUBLE_NEW_LINE
 		"options:"	 DOUBLE_NEW_LINE
 		"  %-10s %s" DOUBLE_NEW_LINE;
 	printf(usage_format,
 		// where
 		"file", "The input model file to load.",
 		// options
 		COMMAND_USAGE, "Display usage.");
 }
 
 /* the global Assimp scene object */
diff --git a/samples/SimpleTexturedDirectx11/CMakeLists.txt b/samples/SimpleTexturedDirectx11/CMakeLists.txt
index 82144caa9..007ada3af 100644
--- a/samples/SimpleTexturedDirectx11/CMakeLists.txt
+++ b/samples/SimpleTexturedDirectx11/CMakeLists.txt
@@ -24,15 +24,15 @@ LINK_DIRECTORIES(
 )
 
 ADD_EXECUTABLE( assimp_simpletextureddirectx11 WIN32
-  SimpleTexturedDirectx11/Mesh.h 
+  SimpleTexturedDirectx11/Mesh.h
   SimpleTexturedDirectx11/ModelLoader.cpp
   SimpleTexturedDirectx11/ModelLoader.h
   #SimpleTexturedDirectx11/PixelShader.hlsl
   SimpleTexturedDirectx11/TextureLoader.cpp
-  SimpleTexturedDirectx11/TextureLoader.h 
-  #SimpleTexturedDirectx11/VertexShader.hlsl  
+  SimpleTexturedDirectx11/TextureLoader.h
+  #SimpleTexturedDirectx11/VertexShader.hlsl
   SimpleTexturedDirectx11/main.cpp
   SimpleTexturedDirectx11/SafeRelease.hpp
   ${SAMPLES_SHARED_CODE_DIR}/UTFConverter.cpp
   ${SAMPLES_SHARED_CODE_DIR}/UTFConverter.h
 )
diff --git a/samples/SimpleTexturedDirectx11/SimpleTexturedDirectx11/ModelLoader.cpp b/samples/SimpleTexturedDirectx11/SimpleTexturedDirectx11/ModelLoader.cpp
index 92760d691..18bb10f1e 100644
--- a/samples/SimpleTexturedDirectx11/SimpleTexturedDirectx11/ModelLoader.cpp
+++ b/samples/SimpleTexturedDirectx11/SimpleTexturedDirectx11/ModelLoader.cpp
@@ -1,11 +1,11 @@
 #include "ModelLoader.h"
 
-ModelLoader::ModelLoader() : 
+ModelLoader::ModelLoader() :
         dev_(nullptr),
         devcon_(nullptr),
         meshes_(),
         directory_(),
         textures_loaded_(),
         hwnd_(nullptr) {
     // empty
 }
diff --git a/samples/SimpleTexturedDirectx11/SimpleTexturedDirectx11/TextureLoader.cpp b/samples/SimpleTexturedDirectx11/SimpleTexturedDirectx11/TextureLoader.cpp
index 01ba343e8..a02c53ca6 100644
--- a/samples/SimpleTexturedDirectx11/SimpleTexturedDirectx11/TextureLoader.cpp
+++ b/samples/SimpleTexturedDirectx11/SimpleTexturedDirectx11/TextureLoader.cpp
@@ -137,71 +137,71 @@ struct WICConvert
 static WICConvert g_WICConvert[] =
 {
 	// Note target GUID in this conversion table must be one of those directly supported formats (above).
 
 	{ GUID_WICPixelFormatBlackWhite,            GUID_WICPixelFormat8bppGray }, // DXGI_FORMAT_R8_UNORM
 
-	{ GUID_WICPixelFormat1bppIndexed,           GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM 
-	{ GUID_WICPixelFormat2bppIndexed,           GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM 
-	{ GUID_WICPixelFormat4bppIndexed,           GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM 
-	{ GUID_WICPixelFormat8bppIndexed,           GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM 
+	{ GUID_WICPixelFormat1bppIndexed,           GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM
+	{ GUID_WICPixelFormat2bppIndexed,           GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM
+	{ GUID_WICPixelFormat4bppIndexed,           GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM
+	{ GUID_WICPixelFormat8bppIndexed,           GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM
 
-	{ GUID_WICPixelFormat2bppGray,              GUID_WICPixelFormat8bppGray }, // DXGI_FORMAT_R8_UNORM 
-	{ GUID_WICPixelFormat4bppGray,              GUID_WICPixelFormat8bppGray }, // DXGI_FORMAT_R8_UNORM 
+	{ GUID_WICPixelFormat2bppGray,              GUID_WICPixelFormat8bppGray }, // DXGI_FORMAT_R8_UNORM
+	{ GUID_WICPixelFormat4bppGray,              GUID_WICPixelFormat8bppGray }, // DXGI_FORMAT_R8_UNORM
 
-	{ GUID_WICPixelFormat16bppGrayFixedPoint,   GUID_WICPixelFormat16bppGrayHalf }, // DXGI_FORMAT_R16_FLOAT 
-	{ GUID_WICPixelFormat32bppGrayFixedPoint,   GUID_WICPixelFormat32bppGrayFloat }, // DXGI_FORMAT_R32_FLOAT 
+	{ GUID_WICPixelFormat16bppGrayFixedPoint,   GUID_WICPixelFormat16bppGrayHalf }, // DXGI_FORMAT_R16_FLOAT
+	{ GUID_WICPixelFormat32bppGrayFixedPoint,   GUID_WICPixelFormat32bppGrayFloat }, // DXGI_FORMAT_R32_FLOAT
 
 #ifdef DXGI_1_2_FORMATS
 
 	{ GUID_WICPixelFormat16bppBGR555,           GUID_WICPixelFormat16bppBGRA5551 }, // DXGI_FORMAT_B5G5R5A1_UNORM
 
 #else
 
 	{ GUID_WICPixelFormat16bppBGR555,           GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM
 	{ GUID_WICPixelFormat16bppBGRA5551,         GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM
 	{ GUID_WICPixelFormat16bppBGR565,           GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM
 
 #endif // DXGI_1_2_FORMATS
 
 	{ GUID_WICPixelFormat32bppBGR101010,        GUID_WICPixelFormat32bppRGBA1010102 }, // DXGI_FORMAT_R10G10B10A2_UNORM
 
-	{ GUID_WICPixelFormat24bppBGR,              GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM 
-	{ GUID_WICPixelFormat24bppRGB,              GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM 
-	{ GUID_WICPixelFormat32bppPBGRA,            GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM 
-	{ GUID_WICPixelFormat32bppPRGBA,            GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM 
+	{ GUID_WICPixelFormat24bppBGR,              GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM
+	{ GUID_WICPixelFormat24bppRGB,              GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM
+	{ GUID_WICPixelFormat32bppPBGRA,            GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM
+	{ GUID_WICPixelFormat32bppPRGBA,            GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM
 
 	{ GUID_WICPixelFormat48bppRGB,              GUID_WICPixelFormat64bppRGBA }, // DXGI_FORMAT_R16G16B16A16_UNORM
 	{ GUID_WICPixelFormat48bppBGR,              GUID_WICPixelFormat64bppRGBA }, // DXGI_FORMAT_R16G16B16A16_UNORM
 	{ GUID_WICPixelFormat64bppBGRA,             GUID_WICPixelFormat64bppRGBA }, // DXGI_FORMAT_R16G16B16A16_UNORM
 	{ GUID_WICPixelFormat64bppPRGBA,            GUID_WICPixelFormat64bppRGBA }, // DXGI_FORMAT_R16G16B16A16_UNORM
 	{ GUID_WICPixelFormat64bppPBGRA,            GUID_WICPixelFormat64bppRGBA }, // DXGI_FORMAT_R16G16B16A16_UNORM
 
-	{ GUID_WICPixelFormat48bppRGBFixedPoint,    GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT 
-	{ GUID_WICPixelFormat48bppBGRFixedPoint,    GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT 
-	{ GUID_WICPixelFormat64bppRGBAFixedPoint,   GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT 
-	{ GUID_WICPixelFormat64bppBGRAFixedPoint,   GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT 
-	{ GUID_WICPixelFormat64bppRGBFixedPoint,    GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT 
-	{ GUID_WICPixelFormat64bppRGBHalf,          GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT 
-	{ GUID_WICPixelFormat48bppRGBHalf,          GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT 
-
-	{ GUID_WICPixelFormat96bppRGBFixedPoint,    GUID_WICPixelFormat128bppRGBAFloat }, // DXGI_FORMAT_R32G32B32A32_FLOAT 
-	{ GUID_WICPixelFormat128bppPRGBAFloat,      GUID_WICPixelFormat128bppRGBAFloat }, // DXGI_FORMAT_R32G32B32A32_FLOAT 
-	{ GUID_WICPixelFormat128bppRGBFloat,        GUID_WICPixelFormat128bppRGBAFloat }, // DXGI_FORMAT_R32G32B32A32_FLOAT 
-	{ GUID_WICPixelFormat128bppRGBAFixedPoint,  GUID_WICPixelFormat128bppRGBAFloat }, // DXGI_FORMAT_R32G32B32A32_FLOAT 
-	{ GUID_WICPixelFormat128bppRGBFixedPoint,   GUID_WICPixelFormat128bppRGBAFloat }, // DXGI_FORMAT_R32G32B32A32_FLOAT 
-
-	{ GUID_WICPixelFormat32bppCMYK,             GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM 
+	{ GUID_WICPixelFormat48bppRGBFixedPoint,    GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT
+	{ GUID_WICPixelFormat48bppBGRFixedPoint,    GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT
+	{ GUID_WICPixelFormat64bppRGBAFixedPoint,   GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT
+	{ GUID_WICPixelFormat64bppBGRAFixedPoint,   GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT
+	{ GUID_WICPixelFormat64bppRGBFixedPoint,    GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT
+	{ GUID_WICPixelFormat64bppRGBHalf,          GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT
+	{ GUID_WICPixelFormat48bppRGBHalf,          GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT
+
+	{ GUID_WICPixelFormat96bppRGBFixedPoint,    GUID_WICPixelFormat128bppRGBAFloat }, // DXGI_FORMAT_R32G32B32A32_FLOAT
+	{ GUID_WICPixelFormat128bppPRGBAFloat,      GUID_WICPixelFormat128bppRGBAFloat }, // DXGI_FORMAT_R32G32B32A32_FLOAT
+	{ GUID_WICPixelFormat128bppRGBFloat,        GUID_WICPixelFormat128bppRGBAFloat }, // DXGI_FORMAT_R32G32B32A32_FLOAT
+	{ GUID_WICPixelFormat128bppRGBAFixedPoint,  GUID_WICPixelFormat128bppRGBAFloat }, // DXGI_FORMAT_R32G32B32A32_FLOAT
+	{ GUID_WICPixelFormat128bppRGBFixedPoint,   GUID_WICPixelFormat128bppRGBAFloat }, // DXGI_FORMAT_R32G32B32A32_FLOAT
+
+	{ GUID_WICPixelFormat32bppCMYK,             GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM
 	{ GUID_WICPixelFormat64bppCMYK,             GUID_WICPixelFormat64bppRGBA }, // DXGI_FORMAT_R16G16B16A16_UNORM
 	{ GUID_WICPixelFormat40bppCMYKAlpha,        GUID_WICPixelFormat64bppRGBA }, // DXGI_FORMAT_R16G16B16A16_UNORM
 	{ GUID_WICPixelFormat80bppCMYKAlpha,        GUID_WICPixelFormat64bppRGBA }, // DXGI_FORMAT_R16G16B16A16_UNORM
 
 #if (_WIN32_WINNT >= 0x0602 /*_WIN32_WINNT_WIN8*/)
 	{ GUID_WICPixelFormat32bppRGB,              GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM
 	{ GUID_WICPixelFormat64bppRGB,              GUID_WICPixelFormat64bppRGBA }, // DXGI_FORMAT_R16G16B16A16_UNORM
-	{ GUID_WICPixelFormat64bppPRGBAHalf,        GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT 
+	{ GUID_WICPixelFormat64bppPRGBAHalf,        GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT
 #endif
 
 																					// We don't support n-channel formats
 };
 
 //--------------------------------------------------------------------------------------
diff --git a/samples/SimpleTexturedDirectx11/SimpleTexturedDirectx11/main.cpp b/samples/SimpleTexturedDirectx11/SimpleTexturedDirectx11/main.cpp
index 02e2b6088..3f8d15320 100644
--- a/samples/SimpleTexturedDirectx11/SimpleTexturedDirectx11/main.cpp
+++ b/samples/SimpleTexturedDirectx11/SimpleTexturedDirectx11/main.cpp
@@ -125,114 +125,114 @@ LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
 int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE /*hPrevInstance*/,
 	LPWSTR /*lpCmdLine*/, int nCmdShow)
 {
 	int argc;
 	LPWSTR* argv = CommandLineToArgvW(GetCommandLineW(), &argc);
 	if (!argv) {
-		MessageBox(nullptr, 
+		MessageBox(nullptr,
 			TEXT("An error occured while reading command line arguments."),
 			TEXT("Error!"),
 			MB_ICONERROR | MB_OK);
 		return EXIT_FAILURE;
 	}
 
 	// Free memory allocated from CommandLineToArgvW.
 	auto free_command_line_allocated_memory = [&argv]() {
 		if (argv) {
 			LocalFree(argv);
 			argv = nullptr;
 		}
 	};
 
 	// Ensure that a model file has been specified.
 	if (argc < 2) {
-		MessageBox(nullptr, 
-			TEXT("No model file specified. The program will now close."), 
+		MessageBox(nullptr,
+			TEXT("No model file specified. The program will now close."),
 			TEXT("Error!"),
 			MB_ICONERROR | MB_OK);
 		free_command_line_allocated_memory();
 		return EXIT_FAILURE;
 	}
 
 	// Retrieve the model file path.
 	g_ModelPath = UTFConverter(argv[1]).str();
 
 	free_command_line_allocated_memory();
-	
+
 	WNDCLASSEX wc;
 	MSG msg;
 
 	wc.cbSize = sizeof(WNDCLASSEX);
 	wc.style = 0;
 	wc.lpfnWndProc = WndProc;
 	wc.cbClsExtra = 0;
 	wc.cbWndExtra = 0;
 	wc.hInstance = hInstance;
 	wc.hIcon = LoadIcon(nullptr, IDI_APPLICATION);
 	wc.hCursor = LoadCursor(nullptr, IDC_ARROW);
 	wc.hbrBackground = nullptr;
 	wc.lpszMenuName = nullptr;
 	wc.lpszClassName = g_szClassName;
 	wc.hIconSm = LoadIcon(nullptr, IDI_APPLICATION);
 
 	if (!RegisterClassEx(&wc))
 	{
 		MessageBox(nullptr, "Window Registration Failed!", "Error!",
 			MB_ICONEXCLAMATION | MB_OK);
 		return 0;
 	}
 
 	RECT wr = { 0,0, SCREEN_WIDTH, SCREEN_HEIGHT };
 	AdjustWindowRect(&wr, WS_OVERLAPPEDWINDOW, FALSE);
 
 	g_hwnd = CreateWindowEx(
 		WS_EX_CLIENTEDGE,
 		g_szClassName,
 		" Simple Textured Directx11 Sample ",
 		WS_OVERLAPPEDWINDOW,
 		CW_USEDEFAULT, CW_USEDEFAULT, wr.right - wr.left, wr.bottom - wr.top,
 		nullptr, nullptr, hInstance, nullptr
 	);
 
 	if (g_hwnd == nullptr)
 	{
 		MessageBox(nullptr, "Window Creation Failed!", "Error!",
 			MB_ICONEXCLAMATION | MB_OK);
 		return 0;
 	}
 
 	ShowWindow(g_hwnd, nCmdShow);
 	UpdateWindow(g_hwnd);
 
 	width = wr.right - wr.left;
 	height = wr.bottom - wr.top;
 
 	try {
 		InitD3D(hInstance, g_hwnd);
 
 		while (true)
 		{
 
 			if (PeekMessage(&msg, nullptr, 0, 0, PM_REMOVE))
 			{
 				TranslateMessage(&msg);
 				DispatchMessage(&msg);
 
 				if (msg.message == WM_QUIT)
 					break;
 			}
 
 			RenderFrame();
 		}
 
 		CleanD3D();
 		return static_cast<int>(msg.wParam);
 	} catch (const std::exception& e) {
 		MessageBox(g_hwnd, e.what(), TEXT("Error!"), MB_ICONERROR | MB_OK);
 		CleanD3D();
 		return EXIT_FAILURE;
 	} catch (...) {
 		MessageBox(g_hwnd, TEXT("Caught an unknown exception."), TEXT("Error!"), MB_ICONERROR | MB_OK);
 		CleanD3D();
 		return EXIT_FAILURE;
 	}
 }
@@ -573,22 +573,22 @@ void InitGraphics()
 HRESULT	CompileShaderFromFile(LPCWSTR pFileName, const D3D_SHADER_MACRO* pDefines, LPCSTR pEntryPoint, LPCSTR pShaderModel, ID3DBlob** ppBytecodeBlob)
 {
 	UINT compileFlags = D3DCOMPILE_ENABLE_STRICTNESS | D3DCOMPILE_PACK_MATRIX_COLUMN_MAJOR;
-	
+
 #ifdef _DEBUG
 	compileFlags |= D3DCOMPILE_DEBUG;
 #endif
 
 	ID3DBlob* pErrorBlob = nullptr;
 
 	HRESULT result = D3DCompileFromFile(pFileName, pDefines, D3D_COMPILE_STANDARD_FILE_INCLUDE, pEntryPoint, pShaderModel, compileFlags, 0, ppBytecodeBlob, &pErrorBlob);
 	if (FAILED(result))
 	{
 		if (pErrorBlob != nullptr)
 			OutputDebugStringA((LPCSTR)pErrorBlob->GetBufferPointer());
 	}
 
 	if (pErrorBlob != nullptr)
 		pErrorBlob->Release();
 
 	return result;
 }
diff --git a/samples/SimpleTexturedOpenGL/SimpleTexturedOpenGL/src/model_loading.cpp b/samples/SimpleTexturedOpenGL/SimpleTexturedOpenGL/src/model_loading.cpp
index aa2344118..9ceeec62e 100644
--- a/samples/SimpleTexturedOpenGL/SimpleTexturedOpenGL/src/model_loading.cpp
+++ b/samples/SimpleTexturedOpenGL/SimpleTexturedOpenGL/src/model_loading.cpp
@@ -548,43 +548,43 @@ int DrawGLScene()				//Here's where we do all the drawing
 void KillGLWindow()			// Properly Kill The Window
 {
 	if (fullscreen)					// Are We In Fullscreen Mode?
 	{
 		ChangeDisplaySettings(nullptr, 0);	// If So Switch Back To The Desktop
 		ShowCursor(TRUE);					// Show Mouse Pointer
 	}
 
 	if (hRC)					// Do We Have A Rendering Context?
 	{
 		if (!wglMakeCurrent(nullptr, nullptr))	// Are We Able To Release The DC And RC Contexts?
 		{
 			MessageBox(nullptr, TEXT("Release Of DC And RC Failed."), TEXT("SHUTDOWN ERROR"), MB_OK | MB_ICONINFORMATION);
 		}
 
 		if (!wglDeleteContext(hRC))			// Are We Able To Delete The RC?
 		{
 			MessageBox(nullptr, TEXT("Release Rendering Context Failed."), TEXT("SHUTDOWN ERROR"), MB_OK | MB_ICONINFORMATION);
 		}
 		hRC = nullptr;
 	}
 
 	if (hDC)
 	{
 		if (!ReleaseDC(g_hWnd, hDC)) // Are We able to Release The DC?
 			MessageBox(nullptr, TEXT("Release Device Context Failed."), TEXT("SHUTDOWN ERROR"), MB_OK | MB_ICONINFORMATION);
 		hDC = nullptr;
 	}
 
 	if (g_hWnd)
 	{
 		if (!DestroyWindow(g_hWnd)) // Are We Able To Destroy The Window
 			MessageBox(nullptr, TEXT("Could Not Release hWnd."), TEXT("SHUTDOWN ERROR"), MB_OK | MB_ICONINFORMATION);
 		g_hWnd = nullptr;
-	} 
+	}
 
 	if (g_hInstance)
 	{
 		if (!UnregisterClass(TEXT("OpenGL"), g_hInstance)) // Are We Able To Unregister Class
 			MessageBox(nullptr, TEXT("Could Not Unregister Class."), TEXT("SHUTDOWN ERROR"), MB_OK | MB_ICONINFORMATION);
 		g_hInstance = nullptr;
 	}
 }
@@ -599,158 +599,158 @@ GLboolean abortGLInit(const char* abortMessage)
 BOOL CreateGLWindow(const char* title, int width, int height, int bits, bool fullscreenflag)
 {
 	GLuint		PixelFormat;		// Hold the result after searching for a match
 	WNDCLASS	wc;					// Window Class Structure
 	DWORD		dwExStyle;			// Window Extended Style
 	DWORD		dwStyle;			// Window Style
 	RECT		WindowRect;			// Grabs Rectangle Upper Left / Lower Right Values
 	WindowRect.left		= (long)0;
 	WindowRect.right	= (long)width;
 	WindowRect.top		= (long)0;
 	WindowRect.bottom	= (long)height;
 
 	fullscreen = fullscreenflag;
 
 	g_hInstance = GetModuleHandle(nullptr);	// Grab An Instance For Our Window
 	wc.style		= CS_HREDRAW | CS_VREDRAW | CS_OWNDC; // Redraw On Move, And Own DC For Window
 	wc.lpfnWndProc	= (WNDPROC) WndProc;		// WndProc handles Messages
 	wc.cbClsExtra	= 0;	// No Extra Window Data
 	wc.cbWndExtra	= 0;	// No Extra Window Data
 	wc.hInstance	= g_hInstance;
 	wc.hIcon		= LoadIcon(nullptr, IDI_WINLOGO);	// Load The Default Icon
 	wc.hCursor		= LoadCursor(nullptr, IDC_ARROW);	// Load the default arrow
 	wc.hbrBackground= nullptr;						// No Background required for OpenGL
 	wc.lpszMenuName	= nullptr;						// No Menu
 	wc.lpszClassName= TEXT("OpenGL");		        // Class Name
 
 	if (!RegisterClass(&wc))
 	{
 		MessageBox(nullptr, TEXT("Failed to register the window class"), TEXT("ERROR"), MB_OK | MB_ICONEXCLAMATION);
 		return FALSE;		//exit and return false
 	}
 
 	if (fullscreen)		// attempt fullscreen mode
 	{
 		DEVMODE dmScreenSettings;								// Device Mode
 		memset(&dmScreenSettings, 0, sizeof(dmScreenSettings));	// Make Sure Memory's Cleared
 		dmScreenSettings.dmSize = sizeof(dmScreenSettings);		// Size Of the devmode structure
 		dmScreenSettings.dmPelsWidth	= width;				// Selected Screen Width
 		dmScreenSettings.dmPelsHeight	= height;				// Selected Screen Height
 		dmScreenSettings.dmBitsPerPel	= bits;					// bits per pixel
 		dmScreenSettings.dmFields		= DM_BITSPERPEL|DM_PELSWIDTH|DM_PELSHEIGHT;
 
 		// Try To Set Selected Mode and Get Results. NOTE: CDS_FULLSCREEN Gets Rid Of Start Bar.
 		if (ChangeDisplaySettings(&dmScreenSettings, CDS_FULLSCREEN)!=DISP_CHANGE_SUCCESSFUL)
 		{
 			// If The Mode Fails, Offer Two Options.  Quit Or Run In A Window.
 			if (MessageBox(nullptr,TEXT("The Requested Fullscreen Mode Is Not Supported By\nYour Video Card. Use Windowed Mode Instead?"),TEXT("NeHe GL"),MB_YESNO|MB_ICONEXCLAMATION)==IDYES)
 			{
 				fullscreen = FALSE;		// Select Windowed Mode (Fullscreen = FALSE)
 			}
 			else
 			{
 				//Popup Messagebox: Closing
 				MessageBox(nullptr, TEXT("Program will close now."), TEXT("ERROR"), MB_OK|MB_ICONSTOP);
 				return FALSE; //exit, return false
 			}
 		}
 	}
 
 	if (fullscreen)		// when mode really succeeded
 	{
 		dwExStyle=WS_EX_APPWINDOW;		// Window Extended Style
 		dwStyle=WS_POPUP;
 		ShowCursor(FALSE);
 	}
 	else
 	{
 		dwExStyle=WS_EX_APPWINDOW | WS_EX_WINDOWEDGE;	// Window extended style
 		dwStyle=WS_OVERLAPPEDWINDOW;					// Windows style
 	}
 
 	AdjustWindowRectEx(&WindowRect, dwStyle, FALSE, dwExStyle);		// Adjust Window To True Requestes Size
 
 	if (nullptr == (g_hWnd=CreateWindowEx(dwExStyle,			// Extended Style For The Window
 								TEXT("OpenGL"),						// Class Name
 								UTFConverter(title).c_wstr(),							// Window Title
 								WS_CLIPSIBLINGS |				// Required Window Style
 								WS_CLIPCHILDREN |				// Required Window Style
 								dwStyle,						// Selected WIndow Style
 								0, 0,							// Window Position
 								WindowRect.right-WindowRect.left, // Calc adjusted Window Width
 								WindowRect.bottom-WindowRect.top, // Calc adjustes Window Height
 								nullptr,						// No Parent Window
 								nullptr,						// No Menu
 								g_hInstance,					// Instance
 								nullptr )))						// Don't pass anything To WM_CREATE
 	{
 		abortGLInit("Window Creation Error.");
 		return FALSE;
 	}
 
 	static	PIXELFORMATDESCRIPTOR pfd=					// pfd Tells Windows How We Want Things To Be
 	{
 		sizeof(PIXELFORMATDESCRIPTOR),					// Size Of This Pixel Format Descriptor
 		1,												// Version Number
 		PFD_DRAW_TO_WINDOW |							// Format Must Support Window
 		PFD_SUPPORT_OPENGL |							// Format Must Support OpenGL
 		PFD_DOUBLEBUFFER,								// Must Support Double Buffering
 		PFD_TYPE_RGBA,									// Request An RGBA Format
 		BYTE(bits),											// Select Our Color Depth
 		0, 0, 0, 0, 0, 0,								// Color Bits Ignored
 		0,												// No Alpha Buffer
 		0,												// Shift Bit Ignored
 		0,												// No Accumulation Buffer
 		0, 0, 0, 0,										// Accumulation Bits Ignored
 		16,												// 16Bit Z-Buffer (Depth Buffer)
 		0,												// No Stencil Buffer
 		0,												// No Auxiliary Buffer
 		PFD_MAIN_PLANE,									// Main Drawing Layer
 		0,												// Reserved
 		0, 0, 0											// Layer Masks Ignored
 	};
 
 	if (nullptr == (hDC=GetDC(g_hWnd)))					// Did we get the Device Context?
 	{
 		abortGLInit("Can't Create A GL Device Context.");
 		return FALSE;
 	}
 
 	if (0 == (PixelFormat=ChoosePixelFormat(hDC, &pfd))) // Did We Find a matching pixel Format?
 	{
 		abortGLInit("Can't Find Suitable PixelFormat");
 		return FALSE;
 	}
 
 	if (!SetPixelFormat(hDC, PixelFormat, &pfd))
 	{
 		abortGLInit("Can't Set The PixelFormat");
 		return FALSE;
 	}
 
-	if (nullptr == (hRC=wglCreateContext(hDC))) 
+	if (nullptr == (hRC=wglCreateContext(hDC)))
 	{
 		abortGLInit("Can't Create A GL Rendering Context.");
 		return FALSE;
 	}
 
 	if (!(wglMakeCurrent(hDC,hRC)))						// Try to activate the rendering context
 	{
 		abortGLInit("Can't Activate The Rendering Context");
 		return FALSE;
 	}
 
 	//// *** everything okay ***
 
 	ShowWindow(g_hWnd, SW_SHOW);	// Show The Window
 	SetForegroundWindow(g_hWnd);	// Slightly Higher Prio
 	SetFocus(g_hWnd);				// Sets Keyboard Focus To The Window
 	ReSizeGLScene(width, height);	// Set Up Our Perspective GL Screen
 
 	if (!InitGL())
 	{
 		abortGLInit("Initialization failed");
 		return FALSE;
 	}
 
 	return TRUE;
 }
diff --git a/test/models-nonbsd/3D/mar_rifle.source.txt b/test/models-nonbsd/3D/mar_rifle.source.txt
index c0cd5fe6d..d7183b7b6 100644
--- a/test/models-nonbsd/3D/mar_rifle.source.txt
+++ b/test/models-nonbsd/3D/mar_rifle.source.txt
@@ -1,7 +1,7 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
 =====================================================================
 
@@ -11,8 +11,8 @@ Notice found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
diff --git a/test/models-nonbsd/3DS/cart_wheel.source.txt b/test/models-nonbsd/3DS/cart_wheel.source.txt
index 6f43a3a22..bf74fa057 100644
--- a/test/models-nonbsd/3DS/cart_wheel.source.txt
+++ b/test/models-nonbsd/3DS/cart_wheel.source.txt
@@ -1,7 +1,7 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
 =====================================================================
 
@@ -11,8 +11,8 @@ Notice found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
diff --git a/test/models-nonbsd/3DS/mar_rifle.source.txt b/test/models-nonbsd/3DS/mar_rifle.source.txt
index 6f43a3a22..bf74fa057 100644
--- a/test/models-nonbsd/3DS/mar_rifle.source.txt
+++ b/test/models-nonbsd/3DS/mar_rifle.source.txt
@@ -1,7 +1,7 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
 =====================================================================
 
@@ -11,8 +11,8 @@ Notice found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
diff --git a/test/models-nonbsd/3DS/mp5_sil.source.txt b/test/models-nonbsd/3DS/mp5_sil.source.txt
index 6f43a3a22..bf74fa057 100644
--- a/test/models-nonbsd/3DS/mp5_sil.source.txt
+++ b/test/models-nonbsd/3DS/mp5_sil.source.txt
@@ -1,7 +1,7 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
 =====================================================================
 
@@ -11,8 +11,8 @@ Notice found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
diff --git a/test/models-nonbsd/ASE/Rifle.source.txt b/test/models-nonbsd/ASE/Rifle.source.txt
index 1b96f8564..802c57045 100644
--- a/test/models-nonbsd/ASE/Rifle.source.txt
+++ b/test/models-nonbsd/ASE/Rifle.source.txt
@@ -1,7 +1,7 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
 =====================================================================
 
@@ -11,9 +11,9 @@ Notice found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
 
diff --git a/test/models-nonbsd/ASE/Rifle2.source.txt b/test/models-nonbsd/ASE/Rifle2.source.txt
index 3fa628db4..7b50d1645 100644
--- a/test/models-nonbsd/ASE/Rifle2.source.txt
+++ b/test/models-nonbsd/ASE/Rifle2.source.txt
@@ -1,7 +1,7 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
 =====================================================================
 
@@ -11,9 +11,9 @@ Notice found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
 
diff --git a/test/models-nonbsd/BLEND/fleurOptonl.source.txt b/test/models-nonbsd/BLEND/fleurOptonl.source.txt
index b9c58b5d9..d4c583620 100644
--- a/test/models-nonbsd/BLEND/fleurOptonl.source.txt
+++ b/test/models-nonbsd/BLEND/fleurOptonl.source.txt
@@ -10,7 +10,7 @@ Puoi utilizzarlo liberamente, modificarlo e migliorarlo.
 ************* Ma attenzione!! *********************
 
 Nel modificare e utilizzare i modelli, ricorda comunque sempre che :
-"il diritto morale all'integrità dell'opera (diritto dell'autore originale) non ti consente di apportare all'opera deformazioni o modificazioni, od ogni altro atto a danno dell'opera stessa, che possano essere di pregiudizio all'onore o alla reputazione dell'autore (la valutazione della lesione dell'onore o della reputazione avviene sulla base di elementi psicologici soggettivi)" 
+"il diritto morale all'integrità dell'opera (diritto dell'autore originale) non ti consente di apportare all'opera deformazioni o modificazioni, od ogni altro atto a danno dell'opera stessa, che possano essere di pregiudizio all'onore o alla reputazione dell'autore (la valutazione della lesione dell'onore o della reputazione avviene sulla base di elementi psicologici soggettivi)"
 (dalle faq di Creative Commons Italia)
 http://www.creativecommons.it/node/165#27
 
@@ -26,7 +26,7 @@ In particolare, sara' da me considerata lesione d'onore l'uso e/o l'adattamento
 
 Se lo fate rischiate la denuncia e il risarcimento danni.
 Per qualsiasi chiarimento in proposito potete comunque scrivermi.
-Questo e' un diritto garantito per legge a me come ad ogni altro artista. 
+Questo e' un diritto garantito per legge a me come ad ogni altro artista.
 L'utilizzo della Creative Commons non influisce su questo diritto.
 
 ************************************************
@@ -45,10 +45,10 @@ work, so you are not allowed to do exactely what you want with my models.
 The author (that is me) has the right to prevent distortion, mutilation, or other modification of his work which would be prejudicial to his or her honor or reputation.
 
 Me, i consider to be prejudicial to my honor, the modification and/or the use of my models in projects that are related to:
- 
+
 	Racism and hatred instigation.
 	War promotion.
 	Cruelty toward animals.
 	Political an religious propaganda.
 	Pornography.
 	Outlaw and unethical behaviours encouragement.
@@ -69,15 +69,15 @@ Note
 
 Questo e' stato il mio secondo modello completo.
 Per questo motivo potrebbe contenere errori e imprecisioni.
- 
+
 Al momento, questi sono i difetti che ho notato:
-	
+
 	- Non e' nell'origine degli assi.
 	- lo scheletro ha il centro spostato di lato
 	- Nel texture sheet c'e' spazio sprecato.
-	
 
-	
+
+
 ###################
 
 Notes
@@ -86,7 +86,7 @@ This was my first complete model, so it probably contains something
 wrong.
 
 At the moment, this is what i noticed:
-	
+
 	- She's not in the origin of axis
 	- Armature's center is not in armature's center.
 	- Texture sheet contains wasted space.
diff --git a/test/models-nonbsd/DXF/rifle.source.txt b/test/models-nonbsd/DXF/rifle.source.txt
index a2585afad..fa25f10db 100644
--- a/test/models-nonbsd/DXF/rifle.source.txt
+++ b/test/models-nonbsd/DXF/rifle.source.txt
@@ -1,7 +1,7 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
 =====================================================================
 
@@ -11,9 +11,9 @@ Notice found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
 
diff --git a/test/models-nonbsd/FBX/2013_ASCII/cart_wheel.source.txt b/test/models-nonbsd/FBX/2013_ASCII/cart_wheel.source.txt
index 6f43a3a22..bf74fa057 100644
--- a/test/models-nonbsd/FBX/2013_ASCII/cart_wheel.source.txt
+++ b/test/models-nonbsd/FBX/2013_ASCII/cart_wheel.source.txt
@@ -1,7 +1,7 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
 =====================================================================
 
@@ -11,8 +11,8 @@ Notice found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
diff --git a/test/models-nonbsd/FBX/2013_ASCII/kwxport_test_vcolors.fbx.source.txt b/test/models-nonbsd/FBX/2013_ASCII/kwxport_test_vcolors.fbx.source.txt
index 94ee48e4a..7c81e612f 100644
--- a/test/models-nonbsd/FBX/2013_ASCII/kwxport_test_vcolors.fbx.source.txt
+++ b/test/models-nonbsd/FBX/2013_ASCII/kwxport_test_vcolors.fbx.source.txt
@@ -1,9 +1,9 @@
 From kwxport
 http://www.kwxport.org/
 
->> 
-The kW Xport plug-in source is released under the MIT license. 
-Basically, it means "feel free to use it; credit the source; don't sue me 
+>>
+The kW Xport plug-in source is released under the MIT license.
+Basically, it means "feel free to use it; credit the source; don't sue me
 if something goes wrong."
 >>
 
diff --git a/test/models-nonbsd/FBX/2013_ASCII/mar_rifle.source.txt b/test/models-nonbsd/FBX/2013_ASCII/mar_rifle.source.txt
index 6f43a3a22..bf74fa057 100644
--- a/test/models-nonbsd/FBX/2013_ASCII/mar_rifle.source.txt
+++ b/test/models-nonbsd/FBX/2013_ASCII/mar_rifle.source.txt
@@ -1,7 +1,7 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
 =====================================================================
 
@@ -11,8 +11,8 @@ Notice found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
diff --git a/test/models-nonbsd/FBX/2013_ASCII/mp5_sil.source.txt b/test/models-nonbsd/FBX/2013_ASCII/mp5_sil.source.txt
index 6f43a3a22..bf74fa057 100644
--- a/test/models-nonbsd/FBX/2013_ASCII/mp5_sil.source.txt
+++ b/test/models-nonbsd/FBX/2013_ASCII/mp5_sil.source.txt
@@ -1,7 +1,7 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
 =====================================================================
 
@@ -11,8 +11,8 @@ Notice found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
diff --git a/test/models-nonbsd/FBX/2013_BINARY/cart_wheel.source.txt b/test/models-nonbsd/FBX/2013_BINARY/cart_wheel.source.txt
index 6f43a3a22..bf74fa057 100644
--- a/test/models-nonbsd/FBX/2013_BINARY/cart_wheel.source.txt
+++ b/test/models-nonbsd/FBX/2013_BINARY/cart_wheel.source.txt
@@ -1,7 +1,7 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
 =====================================================================
 
@@ -11,8 +11,8 @@ Notice found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
diff --git a/test/models-nonbsd/FBX/2013_BINARY/kwxport_test_vcolors.fbx.source.txt b/test/models-nonbsd/FBX/2013_BINARY/kwxport_test_vcolors.fbx.source.txt
index 94ee48e4a..7c81e612f 100644
--- a/test/models-nonbsd/FBX/2013_BINARY/kwxport_test_vcolors.fbx.source.txt
+++ b/test/models-nonbsd/FBX/2013_BINARY/kwxport_test_vcolors.fbx.source.txt
@@ -1,9 +1,9 @@
 From kwxport
 http://www.kwxport.org/
 
->> 
-The kW Xport plug-in source is released under the MIT license. 
-Basically, it means "feel free to use it; credit the source; don't sue me 
+>>
+The kW Xport plug-in source is released under the MIT license.
+Basically, it means "feel free to use it; credit the source; don't sue me
 if something goes wrong."
 >>
 
diff --git a/test/models-nonbsd/FBX/2013_BINARY/mar_rifle.source.txt b/test/models-nonbsd/FBX/2013_BINARY/mar_rifle.source.txt
index 6f43a3a22..bf74fa057 100644
--- a/test/models-nonbsd/FBX/2013_BINARY/mar_rifle.source.txt
+++ b/test/models-nonbsd/FBX/2013_BINARY/mar_rifle.source.txt
@@ -1,7 +1,7 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
 =====================================================================
 
@@ -11,8 +11,8 @@ Notice found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
diff --git a/test/models-nonbsd/FBX/2013_BINARY/mp5_sil.source.txt b/test/models-nonbsd/FBX/2013_BINARY/mp5_sil.source.txt
index 6f43a3a22..bf74fa057 100644
--- a/test/models-nonbsd/FBX/2013_BINARY/mp5_sil.source.txt
+++ b/test/models-nonbsd/FBX/2013_BINARY/mp5_sil.source.txt
@@ -1,7 +1,7 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
 =====================================================================
 
@@ -11,8 +11,8 @@ Notice found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
diff --git a/test/models-nonbsd/LWO/LWO2/LWSReferences/QuickDraw.source.txt b/test/models-nonbsd/LWO/LWO2/LWSReferences/QuickDraw.source.txt
index aaa244217..80afd30a7 100644
--- a/test/models-nonbsd/LWO/LWO2/LWSReferences/QuickDraw.source.txt
+++ b/test/models-nonbsd/LWO/LWO2/LWSReferences/QuickDraw.source.txt
@@ -1,10 +1,10 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
-"These 3d models are contributed by John Hoffman and are based on 
-characters from a cartoon show called "Jayce and the wheel warriors" 
+"These 3d models are contributed by John Hoffman and are based on
+characters from a cartoon show called "Jayce and the wheel warriors"
 (except the marauder) John's site: http://www3.sympatico.ca/john.hoffman"
 
 =====================================================================
@@ -15,9 +15,9 @@ Notice found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
 
diff --git a/test/models-nonbsd/LWO/LWO2/rifle.source.txt b/test/models-nonbsd/LWO/LWO2/rifle.source.txt
index 5523bbc0c..5774ecc0e 100644
--- a/test/models-nonbsd/LWO/LWO2/rifle.source.txt
+++ b/test/models-nonbsd/LWO/LWO2/rifle.source.txt
@@ -1,7 +1,7 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
 =====================================================================
 
@@ -11,9 +11,9 @@ Notice found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
 
diff --git a/test/models-nonbsd/MD2/source.txt b/test/models-nonbsd/MD2/source.txt
index 6f43a3a22..bf74fa057 100644
--- a/test/models-nonbsd/MD2/source.txt
+++ b/test/models-nonbsd/MD2/source.txt
@@ -1,7 +1,7 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
 =====================================================================
 
@@ -11,8 +11,8 @@ Notice found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
diff --git a/test/models-nonbsd/MD5/BoarMan.source.txt b/test/models-nonbsd/MD5/BoarMan.source.txt
index 50b2dfb53..69f0c79a2 100644
--- a/test/models-nonbsd/MD5/BoarMan.source.txt
+++ b/test/models-nonbsd/MD5/BoarMan.source.txt
@@ -1,8 +1,8 @@
 
-License: Creative Commons 
+License: Creative Commons
 			- Remix
 			- Share alike
 			- Attribution Author: zphr (Christian Lenke)
-			
+
 
 
diff --git a/test/models-nonbsd/MDL/IDPO (Quake1)/gijoe-readme.txt b/test/models-nonbsd/MDL/IDPO (Quake1)/gijoe-readme.txt
index 2febb0583..84ce9fd95 100644
--- a/test/models-nonbsd/MDL/IDPO (Quake1)/gijoe-readme.txt	
+++ b/test/models-nonbsd/MDL/IDPO (Quake1)/gijoe-readme.txt	
@@ -4,9 +4,9 @@ Version  : 1
 Date     : 11/05/97
 Author   : Kenneth Whelan
 Email    : JWHELAN@pop.prodigy.net
-Credits  : id software, Larry Hama, Steven Polge, and Rene Post for making Quake ME 
-					
-	
+Credits  : id software, Larry Hama, Steven Polge, and Rene Post for making Quake ME
+
+
 
 Build time: ??? Time???
 
@@ -14,7 +14,7 @@ Type of Mod
 -----------
 Quake C  : no
 Sound    : no
-MDL      : Yes  
+MDL      : Yes
 
 
 Format of QuakeC (if a Quake C Mod)
@@ -29,8 +29,8 @@ Description of the Modification
 -------------------------------
 
 This is a new player.mdl for quake. It's main use is for bots. The Skins are Snake Eyes v4, Duke v3, Low-Light,
-Storm Shadow v2, Shockwave, Repeater, Gung-Ho, Shipwreck, Dusty v3, and 
-Tunnel Rat v2. 
+Storm Shadow v2, Shockwave, Repeater, Gung-Ho, Shipwreck, Dusty v3, and
+Tunnel Rat v2.
 
 
 
@@ -40,7 +40,7 @@ None that I know of.
 How to Install the Modification
 -------------------------------
 
-First back up the current player.mdl(copy player.mdl player.bak). Just put 
+First back up the current player.mdl(copy player.mdl player.bak). Just put
 it in the progs dir in the hack your using, if any.
 
 Technical Details
diff --git a/test/models-nonbsd/MDL/IDPO (Quake1)/steg.txt b/test/models-nonbsd/MDL/IDPO (Quake1)/steg.txt
index c07c2f126..cbddccb7e 100644
--- a/test/models-nonbsd/MDL/IDPO (Quake1)/steg.txt	
+++ b/test/models-nonbsd/MDL/IDPO (Quake1)/steg.txt	
@@ -16,17 +16,17 @@ E-mail:  sgalbrai@linknet.kitsap.lib.wa.us
 WWW:     www.oz.net/~simitar
 
 
-This model can be used or modified for any purpose 
+This model can be used or modified for any purpose
 as long as this text document is included with it
-and all modellers listed in this document are 
+and all modellers listed in this document are
 listed wherever credits are appropriate for that
 purpose.
 
 
-Help Wanted:  
+Help Wanted:
 
 The Free Models Project can use help with
-models and in other areas, such as legal boilerplate 
+models and in other areas, such as legal boilerplate
 for models.
 
 WWW:     www.oz.net/~simitar/model.html
diff --git a/test/models-nonbsd/MDL/IDPO (Quake1)/tekmechbot.txt b/test/models-nonbsd/MDL/IDPO (Quake1)/tekmechbot.txt
index dc0149b01..3b3dd9042 100644
--- a/test/models-nonbsd/MDL/IDPO (Quake1)/tekmechbot.txt	
+++ b/test/models-nonbsd/MDL/IDPO (Quake1)/tekmechbot.txt	
@@ -8,7 +8,7 @@ that the FMP is a great concept !!
 
 There is some movement in the model.
 The legs can be animated for walking, stomping, or running
-around ! 
+around !
 Ok, it's my first model, so I will work on less polygony
 in the future ;-)
 
@@ -18,9 +18,9 @@ Contact:       ebuy@optelnow.net  (E-MAIL)
 Date Created:  7/07/2000
 ======================================================
 
-This model can be used or modified for any purpose 
+This model can be used or modified for any purpose
 as long as this text document is included with it
-and all modelers listed in this document are 
+and all modelers listed in this document are
 listed wherever credits are appropriate for that
 purpose.
 
diff --git a/test/models-nonbsd/NFF/NFFSense8/credits.txt b/test/models-nonbsd/NFF/NFFSense8/credits.txt
index f3cef4d09..bad7fbf15 100644
--- a/test/models-nonbsd/NFF/NFFSense8/credits.txt
+++ b/test/models-nonbsd/NFF/NFFSense8/credits.txt
@@ -1,4 +1,4 @@
 teapot.nff, home4.nff - http://www.martinreddy.net/ukvrsig/wtk.html
 
-cokecan.nff -www.vrupl.evl.uic.edu/Eng591_Pages/cokecan.nff 
+cokecan.nff -www.vrupl.evl.uic.edu/Eng591_Pages/cokecan.nff
 TODO: License status to be confirmed
diff --git a/test/models-nonbsd/OBJ/rifle.source.txt b/test/models-nonbsd/OBJ/rifle.source.txt
index 1d2cec5cf..f7b93fd0f 100644
--- a/test/models-nonbsd/OBJ/rifle.source.txt
+++ b/test/models-nonbsd/OBJ/rifle.source.txt
@@ -1,7 +1,7 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
 =====================================================================
 
@@ -11,9 +11,9 @@ Notices found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
 
diff --git a/test/models/3DS/UVTransformTest/note.txt b/test/models/3DS/UVTransformTest/note.txt
index 4c8bfedd2..9a6bab030 100644
--- a/test/models/3DS/UVTransformTest/note.txt
+++ b/test/models/3DS/UVTransformTest/note.txt
@@ -1,5 +1,5 @@
-All 'mirror' files are not absolutely correct. That's mainly 
-because it's difficult convert Max' handling of mirroring to 
+All 'mirror' files are not absolutely correct. That's mainly
+because it's difficult convert Max' handling of mirroring to
 our's.
 
 In other words: TO DO, but only if someone REALLY needs it.
diff --git a/test/models/ASE/MotionCaptureROM.source.txt b/test/models/ASE/MotionCaptureROM.source.txt
index 2b961906a..f34e056ef 100644
--- a/test/models/ASE/MotionCaptureROM.source.txt
+++ b/test/models/ASE/MotionCaptureROM.source.txt
@@ -1,3 +1,3 @@
-"MotionCaptureROM.ase" - Free for any purpose. 
+"MotionCaptureROM.ase" - Free for any purpose.
 
 NOTE: The errors in the middle of the animation are caused by problems during recording, it's not an importer issue.
diff --git a/test/models/Collada/kwxport_test_vcolors.dae.source.txt b/test/models/Collada/kwxport_test_vcolors.dae.source.txt
index 94ee48e4a..7c81e612f 100644
--- a/test/models/Collada/kwxport_test_vcolors.dae.source.txt
+++ b/test/models/Collada/kwxport_test_vcolors.dae.source.txt
@@ -1,9 +1,9 @@
 From kwxport
 http://www.kwxport.org/
 
->> 
-The kW Xport plug-in source is released under the MIT license. 
-Basically, it means "feel free to use it; credit the source; don't sue me 
+>>
+The kW Xport plug-in source is released under the MIT license.
+Basically, it means "feel free to use it; credit the source; don't sue me
 if something goes wrong."
 >>
 
diff --git a/test/models/IRR/warn_dwarf_scaling_is_intended.txt b/test/models/IRR/warn_dwarf_scaling_is_intended.txt
index f651a8643..d0e4ea361 100644
--- a/test/models/IRR/warn_dwarf_scaling_is_intended.txt
+++ b/test/models/IRR/warn_dwarf_scaling_is_intended.txt
@@ -1,3 +1,3 @@
 for dawfInCellar_ChildOfCellar & dawfInCellar_SameHierarchy:
 
-the strange scalings of cellar and dwarf are intended. 
+the strange scalings of cellar and dwarf are intended.
diff --git a/test/models/MD2/faerie-source.txt b/test/models/MD2/faerie-source.txt
index 4906ff4d1..afb00a170 100644
--- a/test/models/MD2/faerie-source.txt
+++ b/test/models/MD2/faerie-source.txt
@@ -1,5 +1,5 @@
 
-From IRRLICHT/media 
+From IRRLICHT/media
 
 
 The Irrlicht Engine License
diff --git a/test/models/MD2/sidney-source.txt b/test/models/MD2/sidney-source.txt
index 4906ff4d1..afb00a170 100644
--- a/test/models/MD2/sidney-source.txt
+++ b/test/models/MD2/sidney-source.txt
@@ -1,5 +1,5 @@
 
-From IRRLICHT/media 
+From IRRLICHT/media
 
 
 The Irrlicht Engine License
diff --git a/test/models/Q3D/E-AT-AT.source.txt b/test/models/Q3D/E-AT-AT.source.txt
index 2df8826f1..900ee552c 100644
--- a/test/models/Q3D/E-AT-AT.source.txt
+++ b/test/models/Q3D/E-AT-AT.source.txt
@@ -5,4 +5,4 @@ Downloaded 4th November 08 (Obama ftw!)
 Copyright notice found on the page:
 
 Where do the models in the archive come from?
-All 3D files available from the3darchive.com are from the public domain. 
+All 3D files available from the3darchive.com are from the public domain.
diff --git a/test/models/Q3D/earth.source.txt b/test/models/Q3D/earth.source.txt
index 2df8826f1..900ee552c 100644
--- a/test/models/Q3D/earth.source.txt
+++ b/test/models/Q3D/earth.source.txt
@@ -5,4 +5,4 @@ Downloaded 4th November 08 (Obama ftw!)
 Copyright notice found on the page:
 
 Where do the models in the archive come from?
-All 3D files available from the3darchive.com are from the public domain. 
+All 3D files available from the3darchive.com are from the public domain.
diff --git a/test/models/WRL/credits.txt b/test/models/WRL/credits.txt
index 055f73734..7be7fa192 100644
--- a/test/models/WRL/credits.txt
+++ b/test/models/WRL/credits.txt
@@ -1,2 +1,2 @@
 "MotionCaptureROM.ase" Recorded using ViconIQ.
-Converted to VRML with 3DS Max 2008. 
+Converted to VRML with 3DS Max 2008.
diff --git a/test/models/X/anim_test.txt b/test/models/X/anim_test.txt
index 3d270dc7d..f2ef6c056 100644
--- a/test/models/X/anim_test.txt
+++ b/test/models/X/anim_test.txt
@@ -4,6 +4,6 @@ Frame 1 - 10: Zylinder knickt ein, so dass der Knick in Richtung z+ zeigt.
 Frame 10 - 18: Zylinder-Spitze streckt sich in Richtung z-.
 Frame 18 - 24: Zylinder-Spitze bewegt sich zu Position in Richtung x+
 
-Remarks: The exporter failed here for some reasons... although the mesh referres to four bones, only two of them are stored in the corresponding node hierarchy. So you have a mesh with 4 bones, a hirarchy with 2 nodes and a animation that affects only those two nodes. 
+Remarks: The exporter failed here for some reasons... although the mesh referres to four bones, only two of them are stored in the corresponding node hierarchy. So you have a mesh with 4 bones, a hirarchy with 2 nodes and a animation that affects only those two nodes.
 
 There is no timing given for the animation. You have to scale the animation manually. For this file, the timing seems to be 24 ticks per second.
diff --git a/test/models/X/kwxport_test_cubewithvcolors.source.txt b/test/models/X/kwxport_test_cubewithvcolors.source.txt
index 94ee48e4a..7c81e612f 100644
--- a/test/models/X/kwxport_test_cubewithvcolors.source.txt
+++ b/test/models/X/kwxport_test_cubewithvcolors.source.txt
@@ -1,9 +1,9 @@
 From kwxport
 http://www.kwxport.org/
 
->> 
-The kW Xport plug-in source is released under the MIT license. 
-Basically, it means "feel free to use it; credit the source; don't sue me 
+>>
+The kW Xport plug-in source is released under the MIT license.
+Basically, it means "feel free to use it; credit the source; don't sue me
 if something goes wrong."
 >>
 
diff --git a/test/models/X/test.txt b/test/models/X/test.txt
index eaf9d9c3c..9452855b3 100644
--- a/test/models/X/test.txt
+++ b/test/models/X/test.txt
@@ -1,3 +1,3 @@
 Simple textured test cube exported from Maya. Has a texture that does label each cube side uniquely, but the sides do not match DirectX coordinate space.
 
-Is not readable using D3DXLoadFrameHierarchy, needs custom text parsing. 
+Is not readable using D3DXLoadFrameHierarchy, needs custom text parsing.
diff --git a/test/models/invalid/readme.txt b/test/models/invalid/readme.txt
index cab740a84..6ad8b4380 100644
--- a/test/models/invalid/readme.txt
+++ b/test/models/invalid/readme.txt
@@ -4,9 +4,9 @@ GENERAL
 *********************************************************
 
 
-The files in this directory are invalid ... some of them are empty, 
+The files in this directory are invalid ... some of them are empty,
 others have invalid vertices or faces, others are prepared to make
- assimp allocate a few hundreds gigs of memory ... most are 
+ assimp allocate a few hundreds gigs of memory ... most are
 actually regression tests, i.e. there was once a bugfix that
 fixed the respective loaders.
 
@@ -18,8 +18,8 @@ crash.
 FILES
 *********************************************************
 
-OutOfMemory.off - the number of faces is invalid. There won't be 
-  enough memory so std::vector::reserve() will most likely fail. 
+OutOfMemory.off - the number of faces is invalid. There won't be
+  enough memory so std::vector::reserve() will most likely fail.
   The exception should be caught in Importer.cpp.
 
 empty.<x> - These files are completely empty. The corresponding
diff --git a/test/regression/README.txt b/test/regression/README.txt
index 3e90a143b..a37da9255 100644
--- a/test/regression/README.txt
+++ b/test/regression/README.txt
@@ -8,14 +8,14 @@ against a regression database provided with assimp (db.zip). A few failures
 are totally fine (see sections 7+). You need to worry if a huge
 majority of all files in a particular format (or post-processing configuration)
 fails as this might be a sign of a recent regression in assimp's codebase or
-gross incompatibility with your system or compiler. 
+gross incompatibility with your system or compiler.
 
 2) What do I need?
 ---------------------------------------------------------------------------------
  - You need Python installed (2.7+, 3.x). On Windows, run the scripts using "py".
  - You need to build the assimp command line tool (ASSIMP_BUILD_ASSIMP_TOOLS
    CMake build flag). Both run.py and gen_db.py take the full path to the binary
    as first command line parameter.
 
 3) How to add more test files?
 ---------------------------------------------------------------------------------
@@ -53,8 +53,8 @@ Edit the reg_settings.py file and add the path to your repository to
 The regression database includes mini dumps of the aiScene data structure, i.e.
 the scene hierarchy plus the sizes of all data arrays MUST match. Floating-point
 data buffers, such as vertex positions are handled less strictly: min, max and
-average values are stored with low precision. This takes hardware- or 
-compiler-specific differences in floating-point computations into account. 
+average values are stored with low precision. This takes hardware- or
+compiler-specific differences in floating-point computations into account.
 Generally, almost all significant regressions will be detected while the
 number of false positives is relatively low.
 
diff --git a/test/unit/AbstractImportExportBase.h b/test/unit/AbstractImportExportBase.h
index 72530aedc..7651d2e52 100644
--- a/test/unit/AbstractImportExportBase.h
+++ b/test/unit/AbstractImportExportBase.h
@@ -67,7 +67,7 @@ bool AbstractImportExportBase::importerTest() {
     return true;
 }
 
-inline 
+inline
 bool AbstractImportExportBase::exporterTest() {
     return true;
 }
diff --git a/test/unit/Common/utStandardShapes.cpp b/test/unit/Common/utStandardShapes.cpp
index a5df5d898..e1bb6eef9 100644
--- a/test/unit/Common/utStandardShapes.cpp
+++ b/test/unit/Common/utStandardShapes.cpp
@@ -43,15 +43,15 @@ class utStandardShapes : public ::testing::Test {
 TEST_F( utStandardShapes, testMakeMesh ) {
     // Make sphere positions
     std::vector<aiVector3D> positions;
     Assimp::StandardShapes::MakeSphere(1, positions);
 
     // Make mesh
     const auto numIndicesPerPrimitive = 3u;
     aiMesh *aiMeshPtr = Assimp::StandardShapes::MakeMesh(positions, numIndicesPerPrimitive);
 
     // The mNumIndices member of the second face is now incorrect
     const auto& face = aiMeshPtr->mFaces[0];
-    EXPECT_EQ(face.mNumIndices, numIndicesPerPrimitive); 
+    EXPECT_EQ(face.mNumIndices, numIndicesPerPrimitive);
     delete aiMeshPtr;
 }
 
diff --git a/test/unit/ImportExport/MDL/utMDLImporter_HL1_Nodes.cpp b/test/unit/ImportExport/MDL/utMDLImporter_HL1_Nodes.cpp
index ff3b4930c..6fa92f950 100644
--- a/test/unit/ImportExport/MDL/utMDLImporter_HL1_Nodes.cpp
+++ b/test/unit/ImportExport/MDL/utMDLImporter_HL1_Nodes.cpp
@@ -58,341 +58,341 @@ class utMDLImporter_HL1_Nodes : public ::testing::Test {
 public:
     /**
     * @note The following tests require a basic understanding
     * of the SMD format. For more information about SMD format,
     * please refer to the SMD importer or go to VDC
     * (Valve Developer Community).
     */
 
     /*  Given a model with bones that have empty names,
         verify that all the bones of the imported model
         have unique and no empty names.
 
         ""        <----+---- empty names
         ""        <----+
         ""        <----+
         "Bone_3"       |
         ""        <----+
         "Bone_2"       |
-        "Bone_5"       | 
+        "Bone_5"       |
         ""        <----+
         ""        <----+
     */
     void emptyBonesNames() {
         Assimp::Importer importer;
         const aiScene *scene = importer.ReadFile(ASSIMP_TEST_MDL_HL1_MODELS_DIR "unnamed_bones.mdl", aiProcess_ValidateDataStructure);
         EXPECT_NE(nullptr, scene);
 
         const std::vector<std::string> expected_bones_names = {
             "Bone",
             "Bone_0",
             "Bone_1",
             "Bone_3",
             "Bone_4",
             "Bone_2",
             "Bone_5",
             "Bone_6",
             "Bone_7"
         };
 
         expect_named_children(scene, AI_MDL_HL1_NODE_BONES, expected_bones_names);
     }
 
     /*  Given a model with bodyparts that have empty names,
         verify that the imported model contains bodyparts with
         unique and no empty names.
 
         $body ""           <----+---- empty names
         $body "Bodypart_1"      |
         $body "Bodypart_5"      |
         $body "Bodypart_6"      |
         $body ""           <----+
         $body "Bodypart_2"      |
         $body ""           <----+
         $body "Bodypart_3"      |
         $body ""           <----+
     */
     void emptyBodypartsNames() {
         Assimp::Importer importer;
         const aiScene *scene = importer.ReadFile(ASSIMP_TEST_MDL_HL1_MODELS_DIR "unnamed_bodyparts.mdl", aiProcess_ValidateDataStructure);
         EXPECT_NE(nullptr, scene);
 
         const std::vector<std::string> expected_bodyparts_names = {
             "Bodypart",
             "Bodypart_1",
             "Bodypart_5",
             "Bodypart_6",
             "Bodypart_0",
             "Bodypart_2",
             "Bodypart_4",
             "Bodypart_3",
             "Bodypart_7"
         };
 
         expect_named_children(scene, AI_MDL_HL1_NODE_BODYPARTS, expected_bodyparts_names);
     }
 
     /*  Given a model with bodyparts that have duplicate names,
         verify that the imported model contains bodyparts with
         unique and no duplicate names.
 
         $body "Bodypart"   <-----+
         $body "Bodypart_1" <--+  |
         $body "Bodypart_2"    |  |
         $body "Bodypart1"     |  |
-        $body "Bodypart"   ---|--+ 
+        $body "Bodypart"   ---|--+
         $body "Bodypart_1" ---+  |
         $body "Bodypart2"        |
         $body "Bodypart"   ------+
         $body "Bodypart_4"
     */
     void duplicateBodypartsNames() {
         Assimp::Importer importer;
         const aiScene *scene = importer.ReadFile(ASSIMP_TEST_MDL_HL1_MODELS_DIR "duplicate_bodyparts.mdl", aiProcess_ValidateDataStructure);
         EXPECT_NE(nullptr, scene);
 
         const std::vector<std::string> expected_bodyparts_names = {
             "Bodypart",
             "Bodypart_1",
             "Bodypart_2",
             "Bodypart1",
             "Bodypart_0",
             "Bodypart_1_0",
             "Bodypart2",
             "Bodypart_3",
             "Bodypart_4"
         };
 
         expect_named_children(scene, AI_MDL_HL1_NODE_BODYPARTS, expected_bodyparts_names);
     }
 
     /*  Given a model with several bodyparts that contains multiple
         sub models with the same file name, verify for each bodypart
         sub model of the imported model that they have a unique name.
 
         $bodygroup "first_bodypart"
         {
             studio "triangle"   <------+ duplicate file names.
             studio "triangle"   -------+
         }                              |
                                        |
         $bodygroup "second_bodypart"   |
         {                              |
             studio "triangle"   -------+ same as first bodypart, but with same file.
             studio "triangle"   -------+
         }
 
         $bodygroup "last_bodypart"
         {
             studio "triangle2"  <------+ duplicate names.
             studio "triangle2"  -------+
         }
     */
     void duplicateSubModelsNames() {
         Assimp::Importer importer;
         const aiScene *scene = importer.ReadFile(ASSIMP_TEST_MDL_HL1_MODELS_DIR "duplicate_submodels.mdl", aiProcess_ValidateDataStructure);
         EXPECT_NE(nullptr, scene);
 
         const std::vector<std::vector<std::string>> expected_bodypart_sub_models_names = {
             {
                     "triangle",
                     "triangle_0",
             },
             {
                     "triangle_1",
                     "triangle_2",
             },
             {
                     "triangle2",
                     "triangle2_0",
             }
         };
 
         const aiNode *bodyparts_node = scene->mRootNode->FindNode(AI_MDL_HL1_NODE_BODYPARTS);
         EXPECT_NE(nullptr, bodyparts_node);
         EXPECT_EQ(3u, bodyparts_node->mNumChildren);
         for (unsigned int i = 0; i < bodyparts_node->mNumChildren; ++i) {
             expect_named_children(bodyparts_node->mChildren[i],
                     expected_bodypart_sub_models_names[i]);
         }
     }
 
     /*  Given a model with sequences that have duplicate names, verify
         that each sequence from the imported model has a unique
         name.
 
         $sequence "idle_1" <-------+
         $sequence "idle"   <----+  |
         $sequence "idle_2"      |  |
         $sequence "idle"   -----+  |
         $sequence "idle_0"      |  |
         $sequence "idle_1" -----|--+
         $sequence "idle_3"      |
         $sequence "idle"   -----+
         $sequence "idle_7"
     */
     void duplicateSequenceNames() {
         Assimp::Importer importer;
         const aiScene *scene = importer.ReadFile(ASSIMP_TEST_MDL_HL1_MODELS_DIR "duplicate_sequences.mdl", aiProcess_ValidateDataStructure);
         EXPECT_NE(nullptr, scene);
 
         const std::vector<std::string> expected_sequence_names = {
             "idle_1",
             "idle",
             "idle_2",
             "idle_4",
             "idle_0",
             "idle_1_0",
             "idle_3",
             "idle_5",
             "idle_7"
         };
 
         expect_named_children(scene, AI_MDL_HL1_NODE_SEQUENCE_INFOS, expected_sequence_names);
     }
 
     /*  Given a model with sequences that have empty names, verify
         that each sequence from the imported model has a unique
         name.
 
         $sequence ""            <----+---- empty names
         $sequence "Sequence_1"       |
         $sequence ""            <----+
         $sequence "Sequence_4"       |
         $sequence ""            <----+
         $sequence "Sequence_8"       |
         $sequence ""            <----+
         $sequence "Sequence_2"       |
         $sequence ""            <----+
     */
     void emptySequenceNames() {
         Assimp::Importer importer;
         const aiScene *scene = importer.ReadFile(ASSIMP_TEST_MDL_HL1_MODELS_DIR "unnamed_sequences.mdl", aiProcess_ValidateDataStructure);
         EXPECT_NE(nullptr, scene);
 
         const std::vector<std::string> expected_sequence_names = {
             "Sequence",
             "Sequence_1",
             "Sequence_0",
             "Sequence_4",
             "Sequence_3",
             "Sequence_8",
             "Sequence_5",
             "Sequence_2",
             "Sequence_6"
         };
 
         expect_named_children(scene, AI_MDL_HL1_NODE_SEQUENCE_INFOS, expected_sequence_names);
     }
 
     /*  Given a model with sequence groups that have duplicate names,
         verify that each sequence group from the imported model has
         a unique name.
 
         "default"
         $sequencegroup "SequenceGroup"    <----+
         $sequencegroup "SequenceGroup_1"       |
         $sequencegroup "SequenceGroup_5"  <----|--+
         $sequencegroup "SequenceGroup"    -----+  |
         $sequencegroup "SequenceGroup_0"       |  |
         $sequencegroup "SequenceGroup"    -----+  |
         $sequencegroup "SequenceGroup_5"  --------+
         $sequencegroup "SequenceGroup_6"
         $sequencegroup "SequenceGroup_2"
     */
     void duplicateSequenceGroupNames() {
         Assimp::Importer importer;
         const aiScene *scene = importer.ReadFile(ASSIMP_TEST_MDL_HL1_MODELS_DIR "duplicate_sequence_groups/duplicate_sequence_groups.mdl", aiProcess_ValidateDataStructure);
         EXPECT_NE(nullptr, scene);
 
         const std::vector<std::string> expected_sequence_names = {
             "default",
             "SequenceGroup",
             "SequenceGroup_1",
             "SequenceGroup_5",
             "SequenceGroup_3",
             "SequenceGroup_0",
             "SequenceGroup_4",
             "SequenceGroup_5_0",
             "SequenceGroup_6",
             "SequenceGroup_2"
         };
 
         expect_named_children(scene, AI_MDL_HL1_NODE_SEQUENCE_GROUPS, expected_sequence_names);
     }
 
     /*  Given a model with sequence groups that have empty names,
         verify that each sequence group from the imported model has
         a unique name.
 
         "default"
         $sequencegroup ""                 <----+---- empty names
         $sequencegroup "SequenceGroup_2"       |
         $sequencegroup "SequenceGroup_6"       |
         $sequencegroup ""                 <----+
         $sequencegroup ""                 <----+
         $sequencegroup "SequenceGroup_1"       |
         $sequencegroup "SequenceGroup_5"       |
         $sequencegroup ""                 <----+
         $sequencegroup "SequenceGroup_4"
     */
     void emptySequenceGroupNames() {
         Assimp::Importer importer;
         const aiScene *scene = importer.ReadFile(ASSIMP_TEST_MDL_HL1_MODELS_DIR "unnamed_sequence_groups/unnamed_sequence_groups.mdl", aiProcess_ValidateDataStructure);
         EXPECT_NE(nullptr, scene);
 
         const std::vector<std::string> expected_sequence_names = {
             "default",
             "SequenceGroup",
             "SequenceGroup_2",
             "SequenceGroup_6",
             "SequenceGroup_0",
             "SequenceGroup_3",
             "SequenceGroup_1",
             "SequenceGroup_5",
             "SequenceGroup_7",
             "SequenceGroup_4"
         };
 
         expect_named_children(scene, AI_MDL_HL1_NODE_SEQUENCE_GROUPS, expected_sequence_names);
     }
 
     /*  Verify that mOffsetMatrix applies the correct
         inverse bind pose transform. */
     void offsetMatrixUnappliesTransformations() {
 
         const float TOLERANCE = 0.01f;
 
         Assimp::Importer importer;
         const aiScene *scene = importer.ReadFile(MDL_HL1_FILE_MAN, aiProcess_ValidateDataStructure);
         EXPECT_NE(nullptr, scene);
 
         aiNode *scene_bones_node = scene->mRootNode->FindNode(AI_MDL_HL1_NODE_BONES);
 
         const aiMatrix4x4 identity_matrix;
 
         for (unsigned int i = 0; i < scene->mNumMeshes; ++i) {
             aiMesh *scene_mesh = scene->mMeshes[i];
             for (unsigned int j = 0; j < scene_mesh->mNumBones; ++j) {
                 aiBone *scene_mesh_bone = scene_mesh->mBones[j];
 
                 // Store local node transforms.
                 aiNode *n = scene_bones_node->FindNode(scene_mesh_bone->mName);
                 std::vector<aiMatrix4x4> bone_matrices = { n->mTransformation };
                 while (n->mParent != scene->mRootNode) {
                     n = n->mParent;
                     bone_matrices.push_back(n->mTransformation);
                 }
 
                 // Compute absolute node transform.
                 aiMatrix4x4 transform;
                 for (auto it = bone_matrices.rbegin(); it != bone_matrices.rend(); ++it)
                     transform *= *it;
 
                 // Unapply the transformation using the offset matrix.
                 aiMatrix4x4 unapplied_transform = scene_mesh_bone->mOffsetMatrix * transform;
 
                 // Ensure that we have, approximatively, the identity matrix.
                 expect_equal_matrices(identity_matrix, unapplied_transform, TOLERANCE);
             }
         }
     }
diff --git a/test/unit/RandomNumberGeneration.h b/test/unit/RandomNumberGeneration.h
index 81fcfb59c..892e78c06 100644
--- a/test/unit/RandomNumberGeneration.h
+++ b/test/unit/RandomNumberGeneration.h
@@ -53,18 +53,18 @@ class RandomUniformRealGenerator {
 public:
     RandomUniformRealGenerator() :
             dist_(),
-            rd_(), 
+            rd_(),
             re_(rd_())  {
         // empty
     }
-    
+
     RandomUniformRealGenerator(T min, T max) :
             dist_(min, max),
             rd_(),
             re_(rd_())  {
         // empty
     }
 
     inline T next() {
         return dist_(re_);
     }
diff --git a/test/unit/SceneDiffer.cpp b/test/unit/SceneDiffer.cpp
index 6ea28671a..368589bf3 100644
--- a/test/unit/SceneDiffer.cpp
+++ b/test/unit/SceneDiffer.cpp
@@ -48,7 +48,7 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 namespace Assimp {
 
-SceneDiffer::SceneDiffer() 
+SceneDiffer::SceneDiffer()
 : m_diffs() {
     // empty
 }
diff --git a/test/unit/SceneDiffer.h b/test/unit/SceneDiffer.h
index 9e04c7210..e0dc6005a 100644
--- a/test/unit/SceneDiffer.h
+++ b/test/unit/SceneDiffer.h
@@ -71,5 +71,5 @@ protected:
 private:
     std::vector<std::string> m_diffs;
 };
 
-} 
+}
diff --git a/test/unit/TestIOSystem.h b/test/unit/TestIOSystem.h
index fdc3cc49b..4a42b23f0 100644
--- a/test/unit/TestIOSystem.h
+++ b/test/unit/TestIOSystem.h
@@ -55,30 +55,30 @@ class TestIOSystem : public IOSystem {
 public:
     TestIOSystem()
     : IOSystem() {
         // empty
     }
 
     virtual ~TestIOSystem() {
         // empty
     }
-    
+
     virtual bool Exists( const char* ) const {
         return true;
     }
 
     virtual char getOsSeparator() const {
         return Sep[ 0 ];
     }
 
     virtual IOStream* Open( const char* pFile, const char* pMode = "rb" ) {
         EXPECT_NE( nullptr, pFile );
         EXPECT_NE( nullptr, pMode );
         return NULL;
     }
 
     virtual void Close( IOStream* pFile ) {
         EXPECT_NE( nullptr, pFile );
     }
 };
 
 } // Namespace Assimp
diff --git a/test/unit/utDefaultIOStream.cpp b/test/unit/utDefaultIOStream.cpp
index 800fddbc9..d3e2c8a7e 100644
--- a/test/unit/utDefaultIOStream.cpp
+++ b/test/unit/utDefaultIOStream.cpp
@@ -59,25 +59,25 @@ itor sapien ornare sagittis volutpat."};
 TEST_F( utDefaultIOStream, FileSizeTest ) {
     const auto dataSize = sizeof(data);
     const auto dataCount = dataSize / sizeof(*data);
 
     char fpath[] = { TMP_PATH"rndfp.XXXXXX" };
     auto* fs = MakeTmpFile(fpath);
     ASSERT_NE(nullptr, fs);
     {
         auto written = std::fwrite(data, sizeof(*data), dataCount, fs );
         EXPECT_NE( 0U, written );
-    
+
         auto vflush = std::fflush( fs );
         ASSERT_EQ(vflush, 0);
 
 		std::fclose(fs);
 		fs = std::fopen(fpath, "r");
 
 		ASSERT_NE(nullptr, fs);
 
         TestDefaultIOStream myStream( fs, fpath);
         size_t size = myStream.FileSize();
         EXPECT_EQ( size, dataSize);
     }
     remove(fpath);
 }
diff --git a/test/unit/utFBXImporterExporter.cpp b/test/unit/utFBXImporterExporter.cpp
index c78d56b97..4cfc9b152 100644
--- a/test/unit/utFBXImporterExporter.cpp
+++ b/test/unit/utFBXImporterExporter.cpp
@@ -321,52 +321,52 @@ TEST_F(utFBXImporterExporter, importCubesWithOutOfRangeFloat) {
 TEST_F(utFBXImporterExporter, importMaxPbrMaterialsMetalRoughness) {
     Assimp::Importer importer;
     const aiScene *scene = importer.ReadFile(ASSIMP_TEST_MODELS_DIR "/FBX/maxPbrMaterial_metalRough.fbx", aiProcess_ValidateDataStructure);
     ASSERT_NE(nullptr, scene);
     ASSERT_TRUE(scene->mRootNode);
 
     ASSERT_EQ(scene->mNumMaterials, 1u);
     const aiMaterial* mat = scene->mMaterials[0];
     aiString texture;
     ASSERT_EQ(mat->Get(AI_MATKEY_TEXTURE(aiTextureType_BASE_COLOR, 0), texture), AI_SUCCESS);
     EXPECT_EQ(texture, aiString("Textures\\albedo.png"));
     ASSERT_EQ(mat->Get(AI_MATKEY_TEXTURE(aiTextureType_METALNESS, 0), texture), AI_SUCCESS);
     EXPECT_EQ(texture, aiString("Textures\\metalness.png"));
     ASSERT_EQ(mat->Get(AI_MATKEY_TEXTURE(aiTextureType_EMISSION_COLOR, 0), texture), AI_SUCCESS);
     EXPECT_EQ(texture, aiString("Textures\\emission.png"));
     ASSERT_EQ(mat->Get(AI_MATKEY_TEXTURE(aiTextureType_NORMAL_CAMERA, 0), texture), AI_SUCCESS);
     EXPECT_EQ(texture, aiString("Textures\\normal.png"));
     ASSERT_EQ(mat->Get(AI_MATKEY_TEXTURE(aiTextureType_DIFFUSE_ROUGHNESS, 0), texture), AI_SUCCESS);
     EXPECT_EQ(texture, aiString("Textures\\roughness.png"));
     ASSERT_EQ(mat->Get(AI_MATKEY_TEXTURE(aiTextureType_AMBIENT_OCCLUSION, 0), texture), AI_SUCCESS);
     EXPECT_EQ(texture, aiString("Textures\\occlusion.png"));
     ASSERT_EQ(mat->Get(AI_MATKEY_TEXTURE(aiTextureType_OPACITY, 0), texture), AI_SUCCESS);
     EXPECT_EQ(texture, aiString("Textures\\opacity.png"));
 
     // The material contains values for standard properties (e.g. SpecularColor), where 3ds Max has presumably
     // used formulas to map the Pbr values into the standard material model. However, the pbr values themselves
     // are available in the material as untyped "raw" properties. We check that these are correctly parsed:
 
     aiColor4D baseColor;
     ASSERT_EQ(mat->Get("$raw.3dsMax|main|basecolor", aiTextureType_NONE, 0, baseColor), aiReturn_SUCCESS);
     EXPECT_EQ(baseColor, aiColor4D(0, 1, 1, 1));
 
     float metalness;
     ASSERT_EQ(mat->Get("$raw.3dsMax|main|metalness", aiTextureType_NONE, 0, metalness), aiReturn_SUCCESS);
     EXPECT_EQ(metalness, 0.25f);
 
     float roughness;
     ASSERT_EQ(mat->Get("$raw.3dsMax|main|roughness", aiTextureType_NONE, 0, roughness), aiReturn_SUCCESS);
     EXPECT_EQ(roughness, 0.5f);
 
     int useGlossiness;
     ASSERT_EQ(mat->Get("$raw.3dsMax|main|useGlossiness", aiTextureType_NONE, 0, useGlossiness), aiReturn_SUCCESS);
     EXPECT_EQ(useGlossiness, 2); // 1 = Roughness map is glossiness, 2 = Roughness map is roughness.
 
     float bumpMapAmt; // Presumably amount.
     ASSERT_EQ(mat->Get("$raw.3dsMax|main|bump_map_amt", aiTextureType_NONE, 0, bumpMapAmt), aiReturn_SUCCESS);
     EXPECT_EQ(bumpMapAmt, 0.75f);
-    
+
     aiColor4D emitColor;
     ASSERT_EQ(mat->Get("$raw.3dsMax|main|emit_color", aiTextureType_NONE, 0, emitColor), aiReturn_SUCCESS);
     EXPECT_EQ(emitColor, aiColor4D(1, 1, 0, 1));
 }
@@ -374,52 +374,52 @@ TEST_F(utFBXImporterExporter, importMaxPbrMaterialsMetalRoughness) {
 TEST_F(utFBXImporterExporter, importMaxPbrMaterialsSpecularGloss) {
     Assimp::Importer importer;
     const aiScene *scene = importer.ReadFile(ASSIMP_TEST_MODELS_DIR "/FBX/maxPbrMaterial_specGloss.fbx", aiProcess_ValidateDataStructure);
     ASSERT_NE(nullptr, scene);
     ASSERT_TRUE(scene->mRootNode);
 
     ASSERT_EQ(scene->mNumMaterials, 1u);
     const aiMaterial* mat = scene->mMaterials[0];
     aiString texture;
     ASSERT_EQ(mat->Get(AI_MATKEY_TEXTURE(aiTextureType_BASE_COLOR, 0), texture), AI_SUCCESS);
     EXPECT_EQ(texture, aiString("Textures\\albedo.png"));
     ASSERT_EQ(mat->Get(AI_MATKEY_TEXTURE(aiTextureType_SPECULAR, 0), texture), AI_SUCCESS);
     EXPECT_EQ(texture, aiString("Textures\\specular.png"));
     ASSERT_EQ(mat->Get(AI_MATKEY_TEXTURE(aiTextureType_EMISSION_COLOR, 0), texture), AI_SUCCESS);
     EXPECT_EQ(texture, aiString("Textures\\emission.png"));
     ASSERT_EQ(mat->Get(AI_MATKEY_TEXTURE(aiTextureType_NORMAL_CAMERA, 0), texture), AI_SUCCESS);
     EXPECT_EQ(texture, aiString("Textures\\normal.png"));
     ASSERT_EQ(mat->Get(AI_MATKEY_TEXTURE(aiTextureType_SHININESS, 0), texture), AI_SUCCESS);
     EXPECT_EQ(texture, aiString("Textures\\glossiness.png"));
     ASSERT_EQ(mat->Get(AI_MATKEY_TEXTURE(aiTextureType_AMBIENT_OCCLUSION, 0), texture), AI_SUCCESS);
     EXPECT_EQ(texture, aiString("Textures\\occlusion.png"));
     ASSERT_EQ(mat->Get(AI_MATKEY_TEXTURE(aiTextureType_OPACITY, 0), texture), AI_SUCCESS);
     EXPECT_EQ(texture, aiString("Textures\\opacity.png"));
 
     // The material contains values for standard properties (e.g. SpecularColor), where 3ds Max has presumably
     // used formulas to map the Pbr values into the standard material model. However, the pbr values themselves
     // are available in the material as untyped "raw" properties. We check that these are correctly parsed:
 
     aiColor4D baseColor;
     ASSERT_EQ(mat->Get("$raw.3dsMax|main|basecolor", aiTextureType_NONE, 0, baseColor), aiReturn_SUCCESS);
     EXPECT_EQ(baseColor, aiColor4D(0, 1, 1, 1));
 
     aiColor4D specular;
     ASSERT_EQ(mat->Get("$raw.3dsMax|main|Specular", aiTextureType_NONE, 0, specular), aiReturn_SUCCESS);
     EXPECT_EQ(specular, aiColor4D(1, 1, 0, 1));
 
     float glossiness;
     ASSERT_EQ(mat->Get("$raw.3dsMax|main|glossiness", aiTextureType_NONE, 0, glossiness), aiReturn_SUCCESS);
     EXPECT_EQ(glossiness, 0.33f);
 
     int useGlossiness;
     ASSERT_EQ(mat->Get("$raw.3dsMax|main|useGlossiness", aiTextureType_NONE, 0, useGlossiness), aiReturn_SUCCESS);
     EXPECT_EQ(useGlossiness, 1); // 1 = Glossiness map is glossiness, 2 = Glossiness map is roughness.
 
     float bumpMapAmt; // Presumably amount.
     ASSERT_EQ(mat->Get("$raw.3dsMax|main|bump_map_amt", aiTextureType_NONE, 0, bumpMapAmt), aiReturn_SUCCESS);
     EXPECT_EQ(bumpMapAmt, 0.66f);
-    
+
     aiColor4D emitColor;
     ASSERT_EQ(mat->Get("$raw.3dsMax|main|emit_color", aiTextureType_NONE, 0, emitColor), aiReturn_SUCCESS);
     EXPECT_EQ(emitColor, aiColor4D(1, 0, 1, 1));
 }
diff --git a/test/unit/utFindDegenerates.cpp b/test/unit/utFindDegenerates.cpp
index 1f8e8e93f..6f2abebfb 100644
--- a/test/unit/utFindDegenerates.cpp
+++ b/test/unit/utFindDegenerates.cpp
@@ -174,35 +174,35 @@ namespace
 TEST_F(FindDegeneratesProcessTest, meshRemoval) {
     mProcess->EnableAreaCheck(true);
     mProcess->EnableInstantRemoval(true);
     mProcess->ExecuteOnMesh(mMesh);
 
     std::unique_ptr<aiScene> scene(new aiScene);
     scene->mNumMeshes = 5;
     scene->mMeshes = new aiMesh*[5];
 
     /// Use the mesh which doesn't get completely stripped of faces from the main test.
     aiMesh* meshWhichSurvives = mMesh;
     mMesh = nullptr;
 
     scene->mMeshes[0] = getDegenerateMesh().release();
     scene->mMeshes[1] = getDegenerateMesh().release();
     scene->mMeshes[2] = meshWhichSurvives;
     scene->mMeshes[3] = getDegenerateMesh().release();
     scene->mMeshes[4] = getDegenerateMesh().release();
 
     scene->mRootNode = new aiNode;
     scene->mRootNode->mNumMeshes = 5;
     scene->mRootNode->mMeshes = new unsigned int[5];
     scene->mRootNode->mMeshes[0] = 0;
     scene->mRootNode->mMeshes[1] = 1;
     scene->mRootNode->mMeshes[2] = 2;
     scene->mRootNode->mMeshes[3] = 3;
     scene->mRootNode->mMeshes[4] = 4;
 
-    mProcess->Execute(scene.get());    
+    mProcess->Execute(scene.get());
 
     EXPECT_EQ(scene->mNumMeshes, 1u);
     EXPECT_EQ(scene->mMeshes[0], meshWhichSurvives);
     EXPECT_EQ(scene->mRootNode->mNumMeshes, 1u);
-    EXPECT_EQ(scene->mRootNode->mMeshes[0], 0u);    
+    EXPECT_EQ(scene->mRootNode->mMeshes[0], 0u);
 }
diff --git a/test/unit/utIOStreamBuffer.cpp b/test/unit/utIOStreamBuffer.cpp
index 6d0d6a7d7..a0e4660df 100644
--- a/test/unit/utIOStreamBuffer.cpp
+++ b/test/unit/utIOStreamBuffer.cpp
@@ -79,63 +79,63 @@ itor sapien ornare sagittis volutpat."};
 TEST_F( IOStreamBufferTest, open_close_Test ) {
     IOStreamBuffer<char> myBuffer;
 
     EXPECT_FALSE( myBuffer.open( nullptr ) );
     EXPECT_FALSE( myBuffer.close() );
-    
+
     const auto dataSize = sizeof(data);
     const auto dataCount = dataSize / sizeof(*data);
 
     char fname[]={ "octest.XXXXXX" };
     auto* fs = MakeTmpFile(fname);
     ASSERT_NE(nullptr, fs);
-    
+
     auto written = std::fwrite( data, sizeof(*data), dataCount, fs );
     EXPECT_NE( 0U, written );
     auto flushResult = std::fflush( fs );
 	ASSERT_EQ(0, flushResult);
 	std::fclose( fs );
 	fs = std::fopen(fname, "r");
 	ASSERT_NE(nullptr, fs);
     {
         TestDefaultIOStream myStream( fs, fname );
 
         EXPECT_TRUE( myBuffer.open( &myStream ) );
         EXPECT_FALSE( myBuffer.open( &myStream ) );
         EXPECT_TRUE( myBuffer.close() );
     }
     remove(fname);
 }
 
 TEST_F( IOStreamBufferTest, readlineTest ) {
-    
+
     const auto dataSize = sizeof(data);
     const auto dataCount = dataSize / sizeof(*data);
 
     char fname[]={ "readlinetest.XXXXXX" };
     auto* fs = MakeTmpFile(fname);
     ASSERT_NE(nullptr, fs);
 
     auto written = std::fwrite( data, sizeof(*data), dataCount, fs );
     EXPECT_NE( 0U, written );
 
 	auto flushResult = std::fflush(fs);
 	ASSERT_EQ(0, flushResult);
 	std::fclose(fs);
 	fs = std::fopen(fname, "r");
 	ASSERT_NE(nullptr, fs);
 
     const auto tCacheSize = 26u;
 
     IOStreamBuffer<char> myBuffer( tCacheSize );
     EXPECT_EQ(tCacheSize, myBuffer.cacheSize() );
 
     TestDefaultIOStream myStream( fs, fname );
     auto size = myStream.FileSize();
     auto numBlocks = size / myBuffer.cacheSize();
     if ( size % myBuffer.cacheSize() > 0 ) {
         numBlocks++;
     }
     EXPECT_TRUE( myBuffer.open( &myStream ) );
     EXPECT_EQ( numBlocks, myBuffer.getNumBlocks() );
     EXPECT_TRUE( myBuffer.close() );
 }
diff --git a/test/unit/utIOSystem.cpp b/test/unit/utIOSystem.cpp
index 767984deb..1e866515e 100644
--- a/test/unit/utIOSystem.cpp
+++ b/test/unit/utIOSystem.cpp
@@ -50,12 +50,12 @@ using namespace Assimp;
 
 class IOSystemTest : public ::testing::Test {
 public:
-    virtual void SetUp() { 
-        pImp = new TestIOSystem(); 
+    virtual void SetUp() {
+        pImp = new TestIOSystem();
     }
-    
-    virtual void TearDown() { 
-        delete pImp; 
+
+    virtual void TearDown() {
+        delete pImp;
     }
 
 protected:
diff --git a/test/unit/utIssues.cpp b/test/unit/utIssues.cpp
index cb1adb22c..5eeed6ad8 100644
--- a/test/unit/utIssues.cpp
+++ b/test/unit/utIssues.cpp
@@ -60,24 +60,24 @@ class utIssues : public ::testing::Test {
 TEST_F( utIssues, OpacityBugWhenExporting_727 ) {
     float opacity;
     aiScene *scene( TestModelFacttory::createDefaultTestModel( opacity ) );
     Assimp::Importer importer;
     Assimp::Exporter exporter;
-                
+
     std::string path = "dae";
     const aiExportFormatDesc *desc = exporter.GetExportFormatDescription( 0 );
     EXPECT_NE( desc, nullptr );
     path.append(".");
     path.append( desc->fileExtension );
     EXPECT_EQ( AI_SUCCESS, exporter.Export( scene, desc->id, path ) );
     const aiScene *newScene( importer.ReadFile( path, aiProcess_ValidateDataStructure ) );
     ASSERT_NE( nullptr, newScene );
     float newOpacity;
     if ( newScene->mNumMaterials > 0 ) {
         std::cout << "Desc = " << desc->description << "\n";
         EXPECT_EQ( AI_SUCCESS, newScene->mMaterials[ 0 ]->Get( AI_MATKEY_OPACITY, newOpacity ) );
         EXPECT_FLOAT_EQ( opacity, newOpacity );
     }
     delete scene;
 }
 
 #endif // ASSIMP_BUILD_NO_EXPORT
diff --git a/test/unit/utVersion.cpp b/test/unit/utVersion.cpp
index 0189cd2a9..0de6ef39c 100644
--- a/test/unit/utVersion.cpp
+++ b/test/unit/utVersion.cpp
@@ -55,7 +55,7 @@ TEST_F( utVersion, aiGetLegalStringTest ) {
 TEST_F( utVersion, aiGetVersionMinorTest ) {
     EXPECT_EQ( aiGetVersionMinor(), 0U );
 }
-    
+
 TEST_F( utVersion, aiGetVersionMajorTest ) {
     EXPECT_EQ( aiGetVersionMajor(), 5U );
 }
diff --git a/test/unit/utglTF2ImportExport.cpp b/test/unit/utglTF2ImportExport.cpp
index 2c000bb37..90070d63e 100644
--- a/test/unit/utglTF2ImportExport.cpp
+++ b/test/unit/utglTF2ImportExport.cpp
@@ -684,21 +684,21 @@ TEST_F(utglTF2ImportExport, norootnode_issue_3269) {
 TEST_F(utglTF2ImportExport, indexOutOfRange) {
     // The contents of an asset should not lead to an assert.
     Assimp::Importer importer;
 
     struct LogObserver : Assimp::LogStream {
         bool m_observedWarning = false;
         void write(const char *message) override {
             m_observedWarning = m_observedWarning || std::strstr(message, "faces were dropped");
         }
     };
     LogObserver logObserver;
-    
+
     DefaultLogger::get()->attachStream(&logObserver);
     const aiScene *scene = importer.ReadFile(ASSIMP_TEST_MODELS_DIR "/glTF2/IndexOutOfRange/IndexOutOfRange.gltf", aiProcess_ValidateDataStructure);
     ASSERT_NE(scene, nullptr);
     ASSERT_NE(scene->mRootNode, nullptr);
     ASSERT_EQ(scene->mNumMeshes, 1u);
     EXPECT_EQ(scene->mMeshes[0]->mNumFaces, 11u);
     DefaultLogger::get()->detachStream(&logObserver);
     EXPECT_TRUE(logObserver.m_observedWarning);
 }
diff --git a/tools/assimp_cmd/CMakeLists.txt b/tools/assimp_cmd/CMakeLists.txt
index 3a39fa748..5aeac0f7b 100644
--- a/tools/assimp_cmd/CMakeLists.txt
+++ b/tools/assimp_cmd/CMakeLists.txt
@@ -1,39 +1,39 @@
 # Open Asset Import Library (assimp)
 # ----------------------------------------------------------------------
-# 
+#
 # Copyright (c) 2006-2021, assimp team
 
 
 # All rights reserved.
 #
 # Redistribution and use of this software in source and binary forms,
 # with or without modification, are permitted provided that the
 # following conditions are met:
 #
 # * Redistributions of source code must retain the above
 #   copyright notice, this list of conditions and the
 #   following disclaimer.
 #
 # * Redistributions in binary form must reproduce the above
 #   copyright notice, this list of conditions and the
 #   following disclaimer in the documentation and/or other
 #   materials provided with the distribution.
 #
 # * Neither the name of the assimp team, nor the names of its
 #   contributors may be used to endorse or promote products
 #   derived from this software without specific prior
 #   written permission of the assimp team.
 #
 # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 # A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #
 #----------------------------------------------------------------------
diff --git a/tools/assimp_cmd/Export.cpp b/tools/assimp_cmd/Export.cpp
index 1e2f10541..6c3c41de9 100644
--- a/tools/assimp_cmd/Export.cpp
+++ b/tools/assimp_cmd/Export.cpp
@@ -7,8 +7,8 @@ Copyright (c) 2006-2021, assimp team
 
 All rights reserved.
 
-Redistribution and use of this software in source and binary forms, 
-with or without modification, are permitted provided that the following 
+Redistribution and use of this software in source and binary forms,
+with or without modification, are permitted provided that the following
 conditions are met:
 
 * Redistributions of source code must retain the above
@@ -25,16 +25,16 @@ conditions are met:
   derived from this software without specific prior
   written permission of the assimp team.
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ---------------------------------------------------------------------------
 */
diff --git a/tools/assimp_cmd/ImageExtractor.cpp b/tools/assimp_cmd/ImageExtractor.cpp
index 105c4fe37..23aa9c249 100644
--- a/tools/assimp_cmd/ImageExtractor.cpp
+++ b/tools/assimp_cmd/ImageExtractor.cpp
@@ -7,8 +7,8 @@ Copyright (c) 2006-2021, assimp team
 
 All rights reserved.
 
-Redistribution and use of this software in source and binary forms, 
-with or without modification, are permitted provided that the following 
+Redistribution and use of this software in source and binary forms,
+with or without modification, are permitted provided that the following
 conditions are met:
 
 * Redistributions of source code must retain the above
@@ -25,16 +25,16 @@ conditions are met:
   derived from this software without specific prior
   written permission of the assimp team.
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ---------------------------------------------------------------------------
 */
@@ -216,146 +216,146 @@ int DoExport(const aiTexture *tx, FILE *p, const std::string &extension, unsigne
 // -----------------------------------------------------------------------------------
 // Implementation of the assimp extract utility
 int Assimp_Extract(const char *const *params, unsigned int num) {
     const char *const invalid = "assimp extract: Invalid number of arguments. See \'assimp extract --help\'\n";
     // assimp extract in out [options]
     if (num < 1) {
         printf(invalid);
         return AssimpCmdError::InvalidNumberOfArguments;
     }
 
     // --help
     if (!strcmp(params[0], "-h") || !strcmp(params[0], "--help") || !strcmp(params[0], "-?")) {
         printf("%s", AICMD_MSG_DUMP_HELP_E);
         return AssimpCmdError::Success;
     }
 
     std::string in = std::string(params[0]);
     std::string out = (num > 1 ? std::string(params[1]) : "-");
 
     // get import flags
     ImportData import;
     ProcessStandardArguments(import, params + 1, num - 1);
 
     bool nosuffix = false;
     unsigned int texIdx = 0xffffffff, flags = 0;
 
     // process other flags
     std::string extension = "bmp";
     for (unsigned int i = (out[0] == '-' ? 1 : 2); i < num; ++i) {
         if (!params[i]) {
             continue;
         }
 
         if (!strncmp(params[i], "-f", 2)) {
             extension = std::string(params[i] + 2);
         } else if (!strncmp(params[i], "--format=", 9)) {
             extension = std::string(params[i] + 9);
         } else if (!strcmp(params[i], "--nosuffix") || !strcmp(params[i], "-s")) {
             nosuffix = true;
         } else if (!strncmp(params[i], "--texture=", 10)) {
             texIdx = Assimp::strtoul10(params[i] + 10);
         } else if (!strncmp(params[i], "-t", 2)) {
             texIdx = Assimp::strtoul10(params[i] + 2);
         } else if (!strcmp(params[i], "-ba") || !strcmp(params[i], "--bmp-with-alpha")) {
             flags |= AI_EXTRACT_WRITE_BMP_ALPHA;
         }
 #if 0
         else {
             printf("Unknown parameter: %s\n",params[i]);
             return 10;
         }
 #endif
     }
 
     std::transform(extension.begin(), extension.end(), extension.begin(), ai_tolower<char>);
 
     if (out[0] == '-') {
         // take file name from input file
         std::string::size_type s = in.find_last_of('.');
         if (s == std::string::npos)
             s = in.length();
 
         out = in.substr(0, s);
     }
 
     // take file extension from file name, if given
     std::string::size_type s = out.find_last_of('.');
     if (s != std::string::npos) {
         extension = out.substr(s + 1, in.length() - (s + 1));
         out = out.substr(0, s);
     }
 
     // import the main model
     const aiScene *scene = ImportModel(import, in);
     if (!scene) {
         printf("assimp extract: Unable to load input file %s\n", in.c_str());
         return AssimpCmdError::FailedToLoadInputFile;
     }
 
     // get the texture(s) to be exported
     if (texIdx != 0xffffffff) {
 
         // check whether the requested texture is existing
         if (texIdx >= scene->mNumTextures) {
             ::printf("assimp extract: Texture %u requested, but there are just %i textures\n",
                     texIdx, scene->mNumTextures);
             return AssimpCmdExtractError::TextureIndexIsOutOfRange;
         }
     } else {
         ::printf("assimp extract: Exporting %i textures\n", scene->mNumTextures);
     }
 
     // now write all output textures
     for (unsigned int i = 0; i < scene->mNumTextures; ++i) {
         if (texIdx != 0xffffffff && texIdx != i) {
             continue;
         }
 
         const aiTexture *tex = scene->mTextures[i];
         std::string out_cpy = out, out_ext = extension;
 
         // append suffix if necessary - always if all textures are exported
         if (!nosuffix || (texIdx == 0xffffffff)) {
             out_cpy.append("_img");
             char tmp[10];
             Assimp::ASSIMP_itoa10(tmp, i);
 
             out_cpy.append(std::string(tmp));
         }
 
         // if the texture is a compressed one, we'll export
         // it to its native file format
         if (!tex->mHeight) {
             printf("assimp extract: Texture %u is compressed (%s). Writing native file format.\n",
                     i, tex->achFormatHint);
 
             // modify file extension
             out_ext = std::string(tex->achFormatHint);
         }
         out_cpy.append("." + out_ext);
 
         // open output file
         FILE *p = ::fopen(out_cpy.c_str(), "wb");
         if (!p) {
             printf("assimp extract: Unable to open output file %s\n", out_cpy.c_str());
             return AssimpCmdError::FailedToOpenOutputFile;
         }
         int m;
 
         if (!tex->mHeight) {
             m = (1 != fwrite(tex->pcData, tex->mWidth, 1, p)) ?
                         static_cast<int>(AssimpCmdError::Success) :
                         static_cast<int>(AssimpCmdExtractError::FailedToExportCompressedTexture);
         } else {
             m = DoExport(tex, p, extension, flags);
         }
         ::fclose(p);
 
         printf("assimp extract: Wrote texture %u to %s\n", i, out_cpy.c_str());
         if (texIdx != 0xffffffff) {
             return m;
         }
     }
-    
+
     return AssimpCmdError::Success;
 }
diff --git a/tools/assimp_cmd/Info.cpp b/tools/assimp_cmd/Info.cpp
index e0d511a73..2c35ba227 100644
--- a/tools/assimp_cmd/Info.cpp
+++ b/tools/assimp_cmd/Info.cpp
@@ -280,204 +280,204 @@ void PrintHierarchy(
 // -----------------------------------------------------------------------------------
 // Implementation of the assimp info utility to print basic file info
 int Assimp_Info (const char* const* params, unsigned int num) {
 	// --help
 	if (!strcmp( params[0],"-h")||!strcmp( params[0],"--help")||!strcmp( params[0],"-?") ) {
 		printf("%s",AICMD_MSG_INFO_HELP_E);
 		return AssimpCmdError::Success;
 	}
 
 	// asssimp info <file> [-r]
 	if (num < 1) {
 		printf("assimp info: Invalid number of arguments. "
 			"See \'assimp info --help\'\n");
 		return AssimpCmdError::InvalidNumberOfArguments;
 	}
 
 	const std::string in  = std::string(params[0]);
 
 	// get -r and -v arguments
 	bool raw = false;
 	bool verbose = false;
 	bool silent = false;
 	for(unsigned int i = 1; i < num; ++i) {
 		if (!strcmp(params[i],"--raw")||!strcmp(params[i],"-r")) {
 			raw = true;
 		}
 		if (!strcmp(params[i],"--verbose")||!strcmp(params[i],"-v")) {
 			verbose = true;
 		}
 		if (!strcmp(params[i], "--silent") || !strcmp(params[i], "-s")) {
 			silent = true;
 		}
 	}
 
 	// Verbose and silent at the same time are not allowed
 	if ( verbose && silent ) {
 		printf("assimp info: Invalid arguments, verbose and silent at the same time are forbitten. ");
 		return AssimpCmdInfoError::InvalidCombinaisonOfArguments;
 	}
-	
+
 	// Parse post-processing flags unless -r was specified
 	ImportData import;
 	if (!raw) {
 		// get import flags
 		ProcessStandardArguments(import, params + 1, num - 1);
 
 		//No custom post process flags defined, we set all the post process flags active
 		if(import.ppFlags == 0)
 			import.ppFlags |= aiProcessPreset_TargetRealtime_MaxQuality;
 	}
 
 	// import the main model
 	const aiScene* scene = ImportModel(import,in);
 	if (!scene) {
 		printf("assimp info: Unable to load input file %s\n",
 			in.c_str());
 		return AssimpCmdError::FailedToLoadInputFile;
 	}
 
 	aiMemoryInfo mem;
 	globalImporter->GetMemoryRequirements(mem);
 
 
 	static const char* format_string =
 		"Memory consumption: %i B\n"
 		"Nodes:              %i\n"
 		"Maximum depth       %i\n"
 		"Meshes:             %i\n"
 		"Animations:         %i\n"
 		"Textures (embed.):  %i\n"
 		"Materials:          %i\n"
 		"Cameras:            %i\n"
 		"Lights:             %i\n"
 		"Vertices:           %i\n"
 		"Faces:              %i\n"
 		"Bones:              %i\n"
 		"Animation Channels: %i\n"
 		"Primitive Types:    %s\n"
 		"Average faces/mesh  %i\n"
 		"Average verts/mesh  %i\n"
 		"Minimum point      (%f %f %f)\n"
 		"Maximum point      (%f %f %f)\n"
 		"Center point       (%f %f %f)\n"
 
 		;
 
 	aiVector3D special_points[3];
 	FindSpecialPoints(scene,special_points);
 	printf(format_string,
 		mem.total,
 		CountNodes(scene->mRootNode),
 		GetMaxDepth(scene->mRootNode),
 		scene->mNumMeshes,
 		scene->mNumAnimations,
 		scene->mNumTextures,
 		scene->mNumMaterials,
 		scene->mNumCameras,
 		scene->mNumLights,
 		CountVertices(scene),
 		CountFaces(scene),
 		CountBones(scene),
 		CountAnimChannels(scene),
 		FindPTypes(scene).c_str(),
 		GetAvgFacePerMesh(scene),
 		GetAvgVertsPerMesh(scene),
 		special_points[0][0],special_points[0][1],special_points[0][2],
 		special_points[1][0],special_points[1][1],special_points[1][2],
 		special_points[2][0],special_points[2][1],special_points[2][2]
 		)
 	;
 
 	if (silent)
 	{
 		printf("\n");
 		return AssimpCmdError::Success;
 	}
 
 	// meshes
 	if (scene->mNumMeshes) {
 		printf("\nMeshes:  (name) [vertices / bones / faces | primitive_types]\n");
 	}
 	for (unsigned int i = 0; i < scene->mNumMeshes; ++i) {
 		const aiMesh* mesh = scene->mMeshes[i];
 		printf("    %d (%s)", i, mesh->mName.C_Str());
 		printf(
 			": [%d / %d / %d |",
 			mesh->mNumVertices,
 			mesh->mNumBones,
 			mesh->mNumFaces
 		);
 		const unsigned int ptypes = mesh->mPrimitiveTypes;
 		if (ptypes & aiPrimitiveType_POINT) { printf(" point"); }
 		if (ptypes & aiPrimitiveType_LINE) { printf(" line"); }
 		if (ptypes & aiPrimitiveType_TRIANGLE) { printf(" triangle"); }
 		if (ptypes & aiPrimitiveType_POLYGON) { printf(" polygon"); }
 		printf("]\n");
 	}
 
 	// materials
 	unsigned int total=0;
 	for(unsigned int i = 0;i < scene->mNumMaterials; ++i) {
 		aiString name;
 		if (AI_SUCCESS==aiGetMaterialString(scene->mMaterials[i],AI_MATKEY_NAME,&name)) {
 			printf("%s\n    \'%s\'",(total++?"":"\nNamed Materials:" ),name.data);
 		}
 	}
 	if(total) {
 		printf("\n");
 	}
 
 	// textures
 	total=0;
 	for(unsigned int i = 0;i < scene->mNumMaterials; ++i) {
 		aiString name;
 		static const aiTextureType types[] = {
 			aiTextureType_NONE,
 			aiTextureType_DIFFUSE,
 			aiTextureType_SPECULAR,
 			aiTextureType_AMBIENT,
 			aiTextureType_EMISSIVE,
 			aiTextureType_HEIGHT,
 			aiTextureType_NORMALS,
 			aiTextureType_SHININESS,
 			aiTextureType_OPACITY,
 			aiTextureType_DISPLACEMENT,
 			aiTextureType_LIGHTMAP,
 			aiTextureType_REFLECTION,
 			aiTextureType_BASE_COLOR,
 			aiTextureType_NORMAL_CAMERA,
 			aiTextureType_EMISSION_COLOR,
 			aiTextureType_METALNESS,
 			aiTextureType_DIFFUSE_ROUGHNESS,
 			aiTextureType_AMBIENT_OCCLUSION,
 			aiTextureType_UNKNOWN
 		};
 		for(unsigned int type = 0; type < sizeof(types)/sizeof(types[0]); ++type) {
 			for(unsigned int idx = 0;AI_SUCCESS==aiGetMaterialString(scene->mMaterials[i],
 				AI_MATKEY_TEXTURE(types[type],idx),&name); ++idx) {
 				printf("%s\n    \'%s\'",(total++?"":"\nTexture Refs:" ),name.data);
 			}
 		}
 	}
 	if(total) {
 		printf("\n");
 	}
 
 	// animations
 	total=0;
 	for(unsigned int i = 0;i < scene->mNumAnimations; ++i) {
 		if (scene->mAnimations[i]->mName.length) {
 			printf("%s\n     \'%s\'",(total++?"":"\nNamed Animations:" ),scene->mAnimations[i]->mName.data);
 		}
 	}
 	if(total) {
 		printf("\n");
 	}
 
 	// node hierarchy
 	printf("\nNode hierarchy:\n");
 	PrintHierarchy(scene->mRootNode,"",verbose);
 
 	printf("\n");
 	return AssimpCmdError::Success;
 }
diff --git a/tools/assimp_cmd/Main.cpp b/tools/assimp_cmd/Main.cpp
index 2fb7559bb..8d76e1f5e 100644
--- a/tools/assimp_cmd/Main.cpp
+++ b/tools/assimp_cmd/Main.cpp
@@ -9,8 +9,8 @@ Copyright (c) 2006-2021, assimp team
 
 All rights reserved.
 
-Redistribution and use of this software in source and binary forms, 
-with or without modification, are permitted provided that the following 
+Redistribution and use of this software in source and binary forms,
+with or without modification, are permitted provided that the following
 conditions are met:
 
 * Redistributions of source code must retain the above
@@ -27,16 +27,16 @@ conditions are met:
   derived from this software without specific prior
   written permission of the assimp team.
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ---------------------------------------------------------------------------
 */
@@ -47,205 +47,205 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #include "Main.h"
 
-const char* AICMD_MSG_ABOUT = 
+const char* AICMD_MSG_ABOUT =
 "------------------------------------------------------ \n"
 "Open Asset Import Library (\"Assimp\", https://github.com/assimp/assimp) \n"
 " -- Commandline toolchain --\n"
 "------------------------------------------------------ \n\n"
 
 "Version %i.%i %s%s%s%s%s(GIT commit %x)\n\n";
 
-const char* AICMD_MSG_HELP = 
+const char* AICMD_MSG_HELP =
 "assimp <verb> <parameters>\n\n"
 " verbs:\n"
 " \tinfo       - Quick file stats\n"
 " \tlistext    - List all known file extensions available for import\n"
 " \tknowext    - Check whether a file extension is recognized by Assimp\n"
 #ifndef ASSIMP_BUILD_NO_EXPORT
 " \texport     - Export a file to one of the supported output formats\n"
 " \tlistexport - List all supported export formats\n"
 " \texportinfo - Show basic information on a specific export format\n"
 #endif
 " \textract    - Extract embedded texture images\n"
 " \tdump       - Convert models to a binary or textual dump (ASSBIN/ASSXML)\n"
 " \tcmpdump    - Compare dumps created using \'assimp dump <file> -s ...\'\n"
 " \tversion    - Display Assimp version\n"
 "\n Use \'assimp <verb> --help\' for detailed help on a command.\n"
 ;
 
 /*extern*/ Assimp::Importer* globalImporter = NULL;
 
 #ifndef ASSIMP_BUILD_NO_EXPORT
 /*extern*/ Assimp::Exporter* globalExporter = NULL;
 #endif
 
 // ------------------------------------------------------------------------------
 // Application entry point
 int main (int argc, char* argv[])
 {
 	if (argc <= 1)	{
 		printf("assimp: No command specified. Use \'assimp help\' for a detailed command list\n");
 		return AssimpCmdError::Success;
 	}
 
 	// assimp version
 	// Display version information
 	if (! strcmp(argv[1], "version")) {
 		const unsigned int flags = aiGetCompileFlags();
 		printf(AICMD_MSG_ABOUT,
 			aiGetVersionMajor(),
 			aiGetVersionMinor(),
 			(flags & ASSIMP_CFLAGS_DEBUG ?			"-debug "   : ""),
 			(flags & ASSIMP_CFLAGS_NOBOOST ?		"-noboost " : ""),
 			(flags & ASSIMP_CFLAGS_SHARED ?			"-shared "  : ""),
 			(flags & ASSIMP_CFLAGS_SINGLETHREADED ? "-st "      : ""),
 			(flags & ASSIMP_CFLAGS_STLPORT ?		"-stlport " : ""),
 			aiGetVersionRevision());
 
 		return AssimpCmdError::Success;
 	}
 
 	// assimp help
-	// Display some basic help (--help and -h work as well 
+	// Display some basic help (--help and -h work as well
 	// because people could try them intuitively)
 	if (!strcmp(argv[1], "help") || !strcmp(argv[1], "--help") || !strcmp(argv[1], "-h")) {
 		printf("%s",AICMD_MSG_HELP);
 		return AssimpCmdError::Success;
 	}
 
 	// assimp cmpdump
-	// Compare two mini model dumps (regression suite) 
+	// Compare two mini model dumps (regression suite)
 	if (! strcmp(argv[1], "cmpdump")) {
 		return Assimp_CompareDump (&argv[2],argc-2);
 	}
 
 	// construct global importer and exporter instances
 	Assimp::Importer imp;
 	imp.SetPropertyBool("GLOB_MEASURE_TIME",true);
 	globalImporter = &imp;
 
 #ifndef ASSIMP_BUILD_NO_EXPORT
-	// 
+	//
 	Assimp::Exporter exp;
 	globalExporter = &exp;
 #endif
 
 	// assimp listext
 	// List all file extensions supported by Assimp
 	if (! strcmp(argv[1], "listext")) {
 		aiString s;
 		imp.GetExtensionList(s);
 
 		printf("%s\n",s.data);
 		return AssimpCmdError::Success;
 	}
 
 #ifndef ASSIMP_BUILD_NO_EXPORT
 	// assimp listexport
 	// List all export file formats supported by Assimp (not the file extensions, just the format identifiers!)
 	if (! strcmp(argv[1], "listexport")) {
 		aiString s;
-		
+
 		for(size_t i = 0, end = exp.GetExportFormatCount(); i < end; ++i) {
 			const aiExportFormatDesc* const e = exp.GetExportFormatDescription(i);
 			s.Append( e->id );
 			if (i!=end-1) {
 				s.Append("\n");
 			}
 		}
 
 		printf("%s\n",s.data);
 		return AssimpCmdError::Success;
 	}
 
 
 	// assimp exportinfo
 	// stat an export format
 	if (! strcmp(argv[1], "exportinfo")) {
 		aiString s;
 
 		if (argc<3) {
 			printf("Expected file format id\n");
 			return AssimpCmdError::NoFileFormatSpecified;
 		}
 
 		for(size_t i = 0, end = exp.GetExportFormatCount(); i < end; ++i) {
 			const aiExportFormatDesc* const e = exp.GetExportFormatDescription(i);
 			if (!strcmp(e->id,argv[2])) {
 				printf("%s\n%s\n%s\n",e->id,e->fileExtension,e->description);
 				return AssimpCmdError::Success;
 			}
 		}
-		
+
 		printf("Unknown file format id: \'%s\'\n",argv[2]);
 		return AssimpCmdError::UnknownFileFormat;
 	}
 
 	// assimp export
 	// Export a model to a file
 	if (! strcmp(argv[1], "export")) {
 		return Assimp_Export (&argv[2],argc-2);
 	}
 
 #endif
 
 	// assimp knowext
 	// Check whether a particular file extension is known by us, return 0 on success
 	if (! strcmp(argv[1], "knowext")) {
 		if (argc<3) {
 			printf("Expected file extension");
 			return AssimpCmdError::NoFileExtensionSpecified;
 		}
 		const bool b = imp.IsExtensionSupported(argv[2]);
 		printf("File extension \'%s\'  is %sknown\n",argv[2],(b?"":"not "));
 		return b? AssimpCmdError::Success : AssimpCmdError::UnknownFileExtension;
 	}
 
 	// assimp info
 	// Print basic model statistics
 	if (! strcmp(argv[1], "info")) {
 		return Assimp_Info ((const char**)&argv[2],argc-2);
 	}
 
-	// assimp dump 
-	// Dump a model to a file 
+	// assimp dump
+	// Dump a model to a file
 	if (! strcmp(argv[1], "dump")) {
 		return Assimp_Dump (&argv[2],argc-2);
 	}
 
-	// assimp extract 
+	// assimp extract
 	// Extract an embedded texture from a file
 	if (! strcmp(argv[1], "extract")) {
 		return Assimp_Extract (&argv[2],argc-2);
 	}
 
 	// assimp testbatchload
 	// Used by /test/other/streamload.py to load a list of files
 	// using the same importer instance to check for incompatible
 	// importers.
 	if (! strcmp(argv[1], "testbatchload")) {
 		return Assimp_TestBatchLoad (&argv[2],argc-2);
 	}
 
 	printf("Unrecognized command. Use \'assimp help\' for a detailed command list\n");
 	return AssimpCmdError::UnrecognizedCommand;
 }
 
 
 // ------------------------------------------------------------------------------
 void SetLogStreams(const ImportData& imp)
 {
 	printf("\nAttaching log stream   ...           OK\n");
-		
+
 	unsigned int flags = 0;
 	if (imp.logFile.length()) {
 		flags |= aiDefaultLogStream_FILE;
 	}
 	if (imp.showLog) {
 		flags |= aiDefaultLogStream_STDERR;
 	}
 	DefaultLogger::create(imp.logFile.c_str(),imp.verbose ? Logger::VERBOSE : Logger::NORMAL,flags);
 }
 
 
 // ------------------------------------------------------------------------------
@@ -264,278 +264,278 @@ void PrintHorBar()
 // ------------------------------------------------------------------------------
 // Import a specific file
 const aiScene* ImportModel(
-	const ImportData& imp, 
+	const ImportData& imp,
 	const std::string& path)
 {
 	// Attach log streams
 	if (imp.log) {
 		SetLogStreams(imp);
 	}
 	printf("Launching asset import ...           OK\n");
 
 	// Now validate this flag combination
 	if(!globalImporter->ValidateFlags(imp.ppFlags)) {
 		printf("ERROR: Unsupported post-processing flags \n");
 		return NULL;
 	}
 	printf("Validating postprocessing flags ...  OK\n");
 	if (imp.showLog) {
 		PrintHorBar();
 	}
-		
+
 
 	// do the actual import, measure time
 	const clock_t first = clock();
 	const aiScene* scene = globalImporter->ReadFile(path,imp.ppFlags);
 
 	if (imp.showLog) {
 		PrintHorBar();
 	}
 	if (!scene) {
 		printf("ERROR: Failed to load file: %s\n", globalImporter->GetErrorString());
 		return NULL;
 	}
 
 	const clock_t second = ::clock();
 	const double seconds = static_cast<double>(second-first) / CLOCKS_PER_SEC;
 
 	printf("Importing file ...                   OK \n   import took approx. %.5f seconds\n"
 		"\n",seconds);
 
-	if (imp.log) { 
+	if (imp.log) {
 		FreeLogStreams();
 	}
 	return scene;
 }
 
 #ifndef ASSIMP_BUILD_NO_EXPORT
 // ------------------------------------------------------------------------------
-bool ExportModel(const aiScene* pOut,  
-	const ImportData& imp, 
+bool ExportModel(const aiScene* pOut,
+	const ImportData& imp,
 	const std::string& path,
 	const char* pID)
 {
 	// Attach log streams
 	if (imp.log) {
 		SetLogStreams(imp);
 	}
 	printf("Launching asset export ...           OK\n");
 
 	if (imp.showLog) {
 		PrintHorBar();
 	}
 
 	aiMatrix4x4 rx, ry, rz;
     aiMatrix4x4::RotationX(imp.rot.x, rx);
     aiMatrix4x4::RotationY(imp.rot.y, ry);
     aiMatrix4x4::RotationZ(imp.rot.z, rz);
 	pOut->mRootNode->mTransformation *= rx;
     pOut->mRootNode->mTransformation *= ry;
     pOut->mRootNode->mTransformation *= rz;
 
 	// do the actual export, measure time
 	const clock_t first = clock();
 	const aiReturn res = globalExporter->Export(pOut,pID,path);
 
 	if (imp.showLog) {
 		PrintHorBar();
 	}
 	if (res != AI_SUCCESS) {
 		printf("Failed to write file\n");
 		printf("ERROR: %s\n", globalExporter->GetErrorString());
 		return false;
 	}
 
 	const clock_t second = ::clock();
 	const double seconds = static_cast<double>(second-first) / CLOCKS_PER_SEC;
 
 	printf("Exporting file ...                   OK \n   export took approx. %.5f seconds\n"
 		"\n",seconds);
 
-	if (imp.log) { 
+	if (imp.log) {
 		FreeLogStreams();
 	}
 
 	return true;
 }
 #endif
 
 // ------------------------------------------------------------------------------
 // Process standard arguments
 int ProcessStandardArguments(
-	ImportData& fill, 
+	ImportData& fill,
 	const char* const * params,
 	unsigned int num)
 {
 	// -ptv    --pretransform-vertices
 	// -gsn    --gen-smooth-normals
 	// -gn     --gen-normals
 	// -cts    --calc-tangent-space
 	// -jiv    --join-identical-vertices
 	// -rrm    --remove-redundant-materials
 	// -fd     --find-degenerates
 	// -slm    --split-large-meshes
 	// -lbw    --limit-bone-weights
 	// -vds    --validate-data-structure
 	// -icl    --improve-cache-locality
 	// -sbpt   --sort-by-ptype
 	// -lh     --convert-to-lh
 	// -fuv    --flip-uv
 	// -fwo    --flip-winding-order
 	// -tuv    --transform-uv-coords
 	// -guv    --gen-uvcoords
 	// -fid    --find-invalid-data
 	// -fixn   --fix normals
 	// -tri    --triangulate
 	// -fi     --find-instances
 	// -og     --optimize-graph
 	// -om     --optimize-meshes
 	// -db     --debone
 	// -sbc    --split-by-bone-count
 	// -gs	   --global-scale
 	//
 	// -c<file> --config-file=<file>
 
-	for (unsigned int i = 0; i < num;++i) 
+	for (unsigned int i = 0; i < num;++i)
 	{
         const char *param = params[ i ];
         printf( "param = %s\n", param );
 		if (! strcmp( param, "-ptv") || ! strcmp( param, "--pretransform-vertices")) {
 			fill.ppFlags |= aiProcess_PreTransformVertices;
 		}
 		else if (! strcmp( param, "-gsn") || ! strcmp( param, "--gen-smooth-normals")) {
 			fill.ppFlags |= aiProcess_GenSmoothNormals;
 		}
     else if (! strcmp( param, "-dn") || ! strcmp( param, "--drop-normals")) {
 			fill.ppFlags |= aiProcess_DropNormals;
 		}
 		else if (! strcmp( param, "-gn") || ! strcmp( param, "--gen-normals")) {
 			fill.ppFlags |= aiProcess_GenNormals;
 		}
 		else if (! strcmp( param, "-jiv") || ! strcmp( param, "--join-identical-vertices")) {
 			fill.ppFlags |= aiProcess_JoinIdenticalVertices;
 		}
 		else if (! strcmp( param, "-rrm") || ! strcmp( param, "--remove-redundant-materials")) {
 			fill.ppFlags |= aiProcess_RemoveRedundantMaterials;
 		}
 		else if (! strcmp( param, "-fd") || ! strcmp( param, "--find-degenerates")) {
 			fill.ppFlags |= aiProcess_FindDegenerates;
 		}
 		else if (! strcmp( param, "-slm") || ! strcmp( param, "--split-large-meshes")) {
 			fill.ppFlags |= aiProcess_SplitLargeMeshes;
 		}
 		else if (! strcmp( param, "-lbw") || ! strcmp( param, "--limit-bone-weights")) {
 			fill.ppFlags |= aiProcess_LimitBoneWeights;
 		}
 		else if (! strcmp( param, "-vds") || ! strcmp( param, "--validate-data-structure")) {
 			fill.ppFlags |= aiProcess_ValidateDataStructure;
 		}
 		else if (! strcmp( param, "-icl") || ! strcmp( param, "--improve-cache-locality")) {
 			fill.ppFlags |= aiProcess_ImproveCacheLocality;
 		}
 		else if (! strcmp( param, "-sbpt") || ! strcmp( param, "--sort-by-ptype")) {
 			fill.ppFlags |= aiProcess_SortByPType;
 		}
 		else if (! strcmp( param, "-lh") || ! strcmp( param, "--left-handed")) {
 			fill.ppFlags |= aiProcess_ConvertToLeftHanded;
 		}
 		else if (! strcmp( param, "-fuv") || ! strcmp( param, "--flip-uv")) {
 			fill.ppFlags |= aiProcess_FlipUVs;
 		}
 		else if (! strcmp( param, "-fwo") || ! strcmp( param, "--flip-winding-order")) {
 			fill.ppFlags |= aiProcess_FlipWindingOrder;
 		}
 		else if (! strcmp( param, "-tuv") || ! strcmp( param, "--transform-uv-coords")) {
 			fill.ppFlags |= aiProcess_TransformUVCoords;
 		}
 		else if (! strcmp( param, "-guv") || ! strcmp( param, "--gen-uvcoords")) {
 			fill.ppFlags |= aiProcess_GenUVCoords;
 		}
 		else if (! strcmp( param, "-fid") || ! strcmp( param, "--find-invalid-data")) {
 			fill.ppFlags |= aiProcess_FindInvalidData;
 		}
 		else if (! strcmp( param, "-fixn") || ! strcmp( param, "--fix-normals")) {
 			fill.ppFlags |= aiProcess_FixInfacingNormals;
 		}
 		else if (! strcmp( param, "-tri") || ! strcmp( param, "--triangulate")) {
 			fill.ppFlags |= aiProcess_Triangulate;
 		}
 		else if (! strcmp( param, "-cts") || ! strcmp( param, "--calc-tangent-space")) {
 			fill.ppFlags |= aiProcess_CalcTangentSpace;
 		}
 		else if (! strcmp( param, "-fi") || ! strcmp( param, "--find-instances")) {
 			fill.ppFlags |= aiProcess_FindInstances;
 		}
 		else if (! strcmp( param, "-og") || ! strcmp( param, "--optimize-graph")) {
 			fill.ppFlags |= aiProcess_OptimizeGraph;
 		}
 		else if (! strcmp( param, "-om") || ! strcmp( param, "--optimize-meshes")) {
 			fill.ppFlags |= aiProcess_OptimizeMeshes;
 		}
 		else if (! strcmp( param, "-db") || ! strcmp( param, "--debone")) {
 			fill.ppFlags |= aiProcess_Debone;
 		}
 		else if (! strcmp( param, "-sbc") || ! strcmp( param, "--split-by-bone-count")) {
 			fill.ppFlags |= aiProcess_SplitByBoneCount;
 		}
 		else if (!strcmp(param, "-embtex") || ! strcmp(param, "--embed-textures")) {
 			fill.ppFlags |= aiProcess_EmbedTextures;
 		}
 		else if (!strcmp(param, "-gs") || ! strcmp(param, "--global-scale")) {
 			fill.ppFlags |= aiProcess_GlobalScale;
 		}
 		else if (! strncmp( param, "-c",2) || ! strncmp( param, "--config=",9)) {
 			const unsigned int ofs = (params[i][1] == '-' ? 9 : 2);
 
 			// use default configurations
             if (!strncmp( param + ofs, "full", 4 )) {
                 fill.ppFlags |= aiProcessPreset_TargetRealtime_MaxQuality;
             } else if (!strncmp( param + ofs, "default", 7 )) {
 				fill.ppFlags |= aiProcessPreset_TargetRealtime_Quality;
 			} else if (! strncmp( param +ofs,"fast",4)) {
 				fill.ppFlags |= aiProcessPreset_TargetRealtime_Fast;
 			}
 		} else if (! strcmp( param, "-l") || ! strcmp( param, "--show-log")) {
 			fill.showLog = true;
 		}
 		else if (! strcmp( param, "-v") || ! strcmp( param, "--verbose")) {
 			fill.verbose = true;
 		}
 		else if (!strncmp(params[i], "-rx=", 4) || !strncmp(params[i], "--rotation-x=", 13)) {
             std::string value = std::string(params[i] + (params[i][1] == '-' ? 13 : 4));
             fill.rot.x = std::stof(value);
-		} 
+		}
 		else if (!strncmp(params[i], "-ry=", 4) || !strncmp(params[i], "--rotation-y=", 13)) {
             std::string value = std::string(params[i] + (params[i][1] == '-' ? 13 : 4));
             fill.rot.y = std::stof(value);
-        } 
+        }
 		else if (!strncmp(params[i], "-rz=", 4) || !strncmp(params[i], "--rotation-z=", 13)) {
             std::string value = std::string(params[i] + (params[i][1] == '-' ? 13 : 4));
             fill.rot.z = std::stof(value);
         }
 		else if (! strncmp( param, "--log-out=",10) || ! strncmp( param, "-lo",3)) {
 			fill.logFile = std::string(params[i]+(params[i][1] == '-' ? 10 : 3));
 			if (!fill.logFile.length()) {
 				fill.logFile = "assimp-log.txt";
 			}
 		}
 	}
 
 	if (fill.logFile.length() || fill.showLog || fill.verbose) {
 		fill.log = true;
 	}
 
 	return AssimpCmdError::Success;
 }
 
 // ------------------------------------------------------------------------------
 int Assimp_TestBatchLoad (
-	const char* const* params, 
+	const char* const* params,
 	unsigned int num)
 {
 	for(unsigned int i = 0; i < num; ++i) {
 		globalImporter->ReadFile(params[i],aiProcessPreset_TargetRealtime_MaxQuality);
 		// we're totally silent. scene destructs automatically.
 	}
 	return AssimpCmdError::Success;
 }
diff --git a/tools/assimp_cmd/Main.h b/tools/assimp_cmd/Main.h
index e7fbb6c75..5ac306abd 100644
--- a/tools/assimp_cmd/Main.h
+++ b/tools/assimp_cmd/Main.h
@@ -7,8 +7,8 @@ Copyright (c) 2006-2021, assimp team
 
 All rights reserved.
 
-Redistribution and use of this software in source and binary forms, 
-with or without modification, are permitted provided that the following 
+Redistribution and use of this software in source and binary forms,
+with or without modification, are permitted provided that the following
 conditions are met:
 
 * Redistributions of source code must retain the above
@@ -25,16 +25,16 @@ conditions are met:
   derived from this software without specific prior
   written permission of the assimp team.
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ---------------------------------------------------------------------------
 */
@@ -140,64 +140,64 @@ enum AssimpCmdError {
 // ------------------------------------------------------------------------------
 /** Process standard arguments
  *
  *  @param fill Filled by function
  *  @param params Command line parameters to be processed
  *  @param num NUmber of params
  *  @return An #AssimpCmdError value. */
-int ProcessStandardArguments(ImportData& fill, 
+int ProcessStandardArguments(ImportData& fill,
 	const char* const* params,
 	unsigned int num);
 
 // ------------------------------------------------------------------------------
 /** Import a specific model file
  *  @param imp Import configuration to be used
  *  @param path Path to the file to be read */
 const aiScene* ImportModel(
-	const ImportData& imp, 
+	const ImportData& imp,
 	const std::string& path);
 
 #ifndef ASSIMP_BUILD_NO_EXPORT
 
 // ------------------------------------------------------------------------------
 /** Export a specific model file
  *  @param imp Import configuration to be used
  *  @param path Path to the file to be written
  *  @param format Format id*/
-bool ExportModel(const aiScene* pOut, 
-	const ImportData& imp, 
+bool ExportModel(const aiScene* pOut,
+	const ImportData& imp,
 	const std::string& path,
 	const char* pID);
 
 #endif
 
 // ------------------------------------------------------------------------------
 /** assimp_dump utility
  *  @param params Command line parameters to 'assimp dump'
  *  @param Number of params
  *  @return An #AssimpCmdError value.*/
 int Assimp_Dump (
-	const char* const* params, 
+	const char* const* params,
 	unsigned int num);
 
 /// \enum AssimpCmdExportError
 /// \brief Error codes used by the 'Export' utility.
 enum AssimpCmdExportError {
 	FailedToImportModel = AssimpCmdError::LastAssimpCmdError,
 	FailedToExportModel,
 
 	// Add new error codes here...
-	
+
 	LastAssimpCmdExportError, // Must be last.
 };
 
 // ------------------------------------------------------------------------------
 /** assimp_export utility
  *  @param params Command line parameters to 'assimp export'
  *  @param Number of params
  *  @return Either an #AssimpCmdError or #AssimpCmdExportError value. */
 int Assimp_Export (
-	const char* const* params, 
+	const char* const* params,
 	unsigned int num);
 
 /// \enum AssimpCmdExtractError
 /// \brief Error codes used by the 'Image Extractor' utility.
@@ -214,11 +214,11 @@ enum AssimpCmdExtractError {
 // ------------------------------------------------------------------------------
 /** assimp_extract utility
  *  @param params Command line parameters to 'assimp extract'
  *  @param Number of params
  *  @return Either an #AssimpCmdError or #AssimpCmdExtractError value. */
 int Assimp_Extract (
-	const char* const* params, 
+	const char* const* params,
 	unsigned int num);
 
 /// \enum AssimpCmdCompareDumpError
 /// \brief Error codes used by the 'Compare Dump' utility.
@@ -235,11 +235,11 @@ enum AssimpCmdCompareDumpError {
 // ------------------------------------------------------------------------------
 /** assimp_cmpdump utility
  *  @param params Command line parameters to 'assimp cmpdump'
  *  @param Number of params
  *  @return Either an #AssimpCmdError or #AssimpCmdCompareDumpError. */
 int Assimp_CompareDump (
-	const char* const* params, 
+	const char* const* params,
 	unsigned int num);
 
 /// \enum AssimpCmdInfoError
 /// \brief Error codes used by the 'Info' utility.
@@ -254,20 +254,20 @@ enum AssimpCmdInfoError {
 // ------------------------------------------------------------------------------
 /** @brief assimp info utility
  *  @param params Command line parameters to 'assimp info'
  *  @param Number of params
  *  @return Either an #AssimpCmdError or #AssimpCmdInfoError value. */
 int Assimp_Info (
-	const char* const* params, 
+	const char* const* params,
 	unsigned int num);
 
 // ------------------------------------------------------------------------------
 /** @brief assimp testbatchload utility
  *  @param params Command line parameters to 'assimp testbatchload'
  *  @param Number of params
  *  @return An #AssimpCmdError value. */
 int Assimp_TestBatchLoad (
-	const char* const* params, 
+	const char* const* params,
 	unsigned int num);
 
 
 #endif // !! AICMD_MAIN_INCLUDED
diff --git a/tools/assimp_cmd/WriteDump.cpp b/tools/assimp_cmd/WriteDump.cpp
index 5809d4ce6..fd8839a17 100644
--- a/tools/assimp_cmd/WriteDump.cpp
+++ b/tools/assimp_cmd/WriteDump.cpp
@@ -7,8 +7,8 @@ Copyright (c) 2006-2021, assimp team
 
 All rights reserved.
 
-Redistribution and use of this software in source and binary forms, 
-with or without modification, are permitted provided that the following 
+Redistribution and use of this software in source and binary forms,
+with or without modification, are permitted provided that the following
 conditions are met:
 
 * Redistributions of source code must retain the above
@@ -25,16 +25,16 @@ conditions are met:
   derived from this software without specific prior
   written permission of the assimp team.
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ---------------------------------------------------------------------------
 */
diff --git a/tools/assimp_cmd/resource.h b/tools/assimp_cmd/resource.h
index c516b5e5c..caf3a0a69 100644
--- a/tools/assimp_cmd/resource.h
+++ b/tools/assimp_cmd/resource.h
@@ -1,21 +1,21 @@
 //{{NO_DEPENDENCIES}}
 // Microsoft Visual C++ generated include file.
 // Used by assimp_view.rc
 //
 #define IDC_MYICON                      2
 #define IDD_ASSIMP_VIEW_DIALOG          102
 #define IDD_ABOUTBOX                    103
 #define IDI_ASSIMP_VIEW                 107
 
 
 // Next default values for new objects
-// 
+//
 #ifdef APSTUDIO_INVOKED
 #ifndef APSTUDIO_READONLY_SYMBOLS
 #define _APS_NO_MFC                     1
 #define _APS_NEXT_RESOURCE_VALUE        159
 #define _APS_NEXT_COMMAND_VALUE         32831
 #define _APS_NEXT_CONTROL_VALUE         1052
 #define _APS_NEXT_SYMED_VALUE           110
 #endif
 #endif
diff --git a/tools/assimp_view/AnimEvaluator.h b/tools/assimp_view/AnimEvaluator.h
index 566247604..394ebef4a 100644
--- a/tools/assimp_view/AnimEvaluator.h
+++ b/tools/assimp_view/AnimEvaluator.h
@@ -53,7 +53,7 @@ struct aiAnimation;
 
 namespace AssimpView {
 
-/** 
+/**
  *  @brief  Calculates transformations for a given timestamp from a set of animation tracks. Not directly useful,
  *          better use the AnimPlayer class.
  */
@@ -61,22 +61,22 @@ class AnimEvaluator {
 public:
     /// @brief  Constructor on a given animation. The animation is fixed throughout the lifetime of
     /// the object.
     /// @param pAnim    The animation to calculate poses for. Ownership of the animation object stays
     ///                 at the caller, the evaluator just keeps a reference to it as long as it persists.
     AnimEvaluator(const aiAnimation *pAnim);
 
     /// @brief  The class destructor.
     ~AnimEvaluator();
 
-    /// @brief Evaluates the animation tracks for a given time stamp. 
-    /// The calculated pose can be retrieved as an array of transformation 
+    /// @brief Evaluates the animation tracks for a given time stamp.
+    /// The calculated pose can be retrieved as an array of transformation
     /// matrices afterwards by calling GetTransformations().
-    /// @param pTime    The time for which you want to evaluate the animation, in seconds. 
-    ///                 Will be mapped into the animation cycle, so it can get an arbitrary 
+    /// @param pTime    The time for which you want to evaluate the animation, in seconds.
+    ///                 Will be mapped into the animation cycle, so it can get an arbitrary
     ///                 value. Best use with ever-increasing time stamps.
     void Evaluate(double pTime);
 
-    /// @brief  Returns the transform matrices calculated at the last Evaluate() call. 
+    /// @brief  Returns the transform matrices calculated at the last Evaluate() call.
     ///         The array matches the mChannels array of the aiAnimation.
     const std::vector<aiMatrix4x4> &GetTransformations() const { return mTransforms; }
 
diff --git a/tools/assimp_view/CMakeLists.txt b/tools/assimp_view/CMakeLists.txt
index 8ff556f05..0199392fe 100644
--- a/tools/assimp_view/CMakeLists.txt
+++ b/tools/assimp_view/CMakeLists.txt
@@ -1,39 +1,39 @@
 # Open Asset Import Library (assimp)
 # ----------------------------------------------------------------------
-# 
+#
 # Copyright (c) 2006-2021, assimp team
 
 
 # All rights reserved.
 #
 # Redistribution and use of this software in source and binary forms,
 # with or without modification, are permitted provided that the
 # following conditions are met:
 #
 # * Redistributions of source code must retain the above
 #   copyright notice, this list of conditions and the
 #   following disclaimer.
 #
 # * Redistributions in binary form must reproduce the above
 #   copyright notice, this list of conditions and the
 #   following disclaimer in the documentation and/or other
 #   materials provided with the distribution.
 #
 # * Neither the name of the assimp team, nor the names of its
 #   contributors may be used to endorse or promote products
 #   derived from this software without specific prior
 #   written permission of the assimp team.
 #
 # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 # A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #
 #----------------------------------------------------------------------
diff --git a/tools/assimp_view/Display.cpp b/tools/assimp_view/Display.cpp
index 4178ab955..ac9aa5329 100644
--- a/tools/assimp_view/Display.cpp
+++ b/tools/assimp_view/Display.cpp
@@ -104,10 +104,10 @@ void GetNodeCount(aiNode* pcNode, unsigned int* piCnt)
 //-------------------------------------------------------------------------------
 int CDisplay::EnableAnimTools(BOOL hm) {
     EnableWindow(GetDlgItem(g_hDlg,IDC_PLAY),hm);
     EnableWindow(GetDlgItem(g_hDlg,IDC_SLIDERANIM),hm);
-    
+
     return 1;
 }
 
 //-------------------------------------------------------------------------------
 // Fill animation combo box
@@ -147,75 +147,75 @@ int CDisplay::ClearDisplayList(void)
 {
     // clear the combo box
     TreeView_DeleteAllItems(GetDlgItem(g_hDlg,IDC_TREE1));
     this->Reset();
     return 1;
 }
 //-------------------------------------------------------------------------------
 // Add a specific node to the display list
 int CDisplay::AddNodeToDisplayList(
     unsigned int iIndex,
     unsigned int iDepth,
     aiNode* pcNode,
     HTREEITEM hRoot)
 {
     ai_assert(nullptr != pcNode);
     ai_assert(nullptr != hRoot);
 
     char chTemp[MAXLEN];
 
     if(0 == pcNode->mName.length)   {
         if (iIndex >= 100)  {
             iIndex += iDepth  * 1000;
         }
         else if (iIndex >= 10)
         {
             iIndex += iDepth  * 100;
         }
-        else 
+        else
 			iIndex += iDepth  * 10;
         ai_snprintf(chTemp, MAXLEN,"Node %u",iIndex);
     }
     else {
         ai_snprintf(chTemp, MAXLEN,"%s",pcNode->mName.data);
     }
     ai_snprintf(chTemp+strlen(chTemp), MAXLEN- strlen(chTemp),  iIndex ? " (%i)" : " (%i meshes)",pcNode->mNumMeshes);
 
     TVITEMEXW tvi;
     TVINSERTSTRUCTW sNew;
 
     wchar_t tmp[512];
     int t = MultiByteToWideChar(CP_UTF8,0,chTemp,-1,tmp,512);
 
     tvi.pszText = tmp;
     tvi.cchTextMax = (int)t;
 
     tvi.mask = TVIF_TEXT | TVIF_SELECTEDIMAGE | TVIF_IMAGE | TVIF_HANDLE | TVIF_PARAM;
     tvi.iImage = this->m_aiImageList[AI_VIEW_IMGLIST_NODE];
     tvi.iSelectedImage = this->m_aiImageList[AI_VIEW_IMGLIST_NODE];
     tvi.lParam = (LPARAM)5;
 
     sNew.itemex = tvi;
     sNew.hInsertAfter = TVI_LAST;
     sNew.hParent = hRoot;
 
     // add the item to the list
     HTREEITEM hTexture = (HTREEITEM)SendMessage(GetDlgItem(g_hDlg,IDC_TREE1),
         TVM_INSERTITEMW,
         0,
         (LPARAM)(LPTVINSERTSTRUCT)&sNew);
 
     // recursively add all child nodes
     ++iDepth;
     for (unsigned int i = 0; i< pcNode->mNumChildren;++i){
         AddNodeToDisplayList(i,iDepth,pcNode->mChildren[i],hTexture);
     }
 
     // add the node to the list
     NodeInfo info;
     info.hTreeItem = hTexture;
     info.psNode = pcNode;
     this->AddNode(info);
     return 1;
 }
 
 //-------------------------------------------------------------------------------
@@ -968,125 +968,125 @@ int CDisplay::OnSetupMaterialView(MaterialInfo* pcNew)
     // redraw the color fields in the UI --- their purpose has possibly changed
     UpdateColorFieldsInUI();
     UpdateWindow(g_hDlg);
     return 1;
 }
 //-------------------------------------------------------------------------------
 int CDisplay::OnSetupTextureView(TextureInfo* pcNew)
 {
     ai_assert(nullptr != pcNew);
 
     if (this->m_pcCurrentTexture == pcNew)return 2;
 
     if (VIEWMODE_NODE == this->m_iViewMode)
     {
         ShowNormalUIComponents();
     }
 
     if ((aiTextureType_OPACITY | 0x40000000) == pcNew->iType)
     {
         // for opacity textures display a warn message
         CLogDisplay::Instance().AddEntry("[INFO] This texture is not existing in the "
             "original mesh",D3DCOLOR_ARGB(0xFF,0xFF,0xFF,0));
         CLogDisplay::Instance().AddEntry("It is a copy of the alpha channel of the first "
             "diffuse texture",D3DCOLOR_ARGB(0xFF,0xFF,0xFF,0));
     }
 
     // check whether the pattern background effect is supported
     if (g_sCaps.PixelShaderVersion < D3DPS_VERSION(3,0))
     {
         CLogDisplay::Instance().AddEntry("[WARN] The background shader won't work "
             "on your system, it required PS 3.0 hardware. A default color is used ...",
             D3DCOLOR_ARGB(0xFF,0xFF,0x00,0));
     }
 
     this->m_fTextureZoom = 1000.0f;
     this->m_vTextureOffset.x = this->m_vTextureOffset.y = 0.0f;
 
     this->m_pcCurrentTexture = pcNew;
     this->SetViewMode(VIEWMODE_TEXTURE);
 
     // now ... change the meaning of the statistics fields
     SetWindowText(GetDlgItem(g_hDlg,IDC_NUMVERTS),"Width:");
     SetWindowText(GetDlgItem(g_hDlg,IDC_NUMNODES),"Height:");
     SetWindowText(GetDlgItem(g_hDlg,IDC_NUMFACES),"Format:");
     SetWindowText(GetDlgItem(g_hDlg,IDC_NUMSHADERS),"MIPs:");
     SetWindowText(GetDlgItem(g_hDlg,IDC_NUMMATS),"UV:");
     SetWindowText(GetDlgItem(g_hDlg,IDC_NUMMESHES),"Blend:");
     SetWindowText(GetDlgItem(g_hDlg,IDC_LOADTIME),"Op:");
 
     // and fill them with data
     D3DSURFACE_DESC sDesc;
     if (pcNew->piTexture && *pcNew->piTexture) {
         (*pcNew->piTexture)->GetLevelDesc(0,&sDesc);
         char szTemp[128];
 
         sprintf(szTemp,"%i",sDesc.Width);
         SetWindowText(GetDlgItem(g_hDlg,IDC_EVERT),szTemp);
 
         sprintf(szTemp,"%i",sDesc.Height);
         SetWindowText(GetDlgItem(g_hDlg,IDC_ENODEWND),szTemp);
 
         sprintf(szTemp,"%i",(*pcNew->piTexture)->GetLevelCount());
         SetWindowText(GetDlgItem(g_hDlg,IDC_ESHADER),szTemp);
 
         sprintf(szTemp,"%u",pcNew->iUV);
         SetWindowText(GetDlgItem(g_hDlg,IDC_EMAT),szTemp);
 
         sprintf(szTemp,"%f",pcNew->fBlend);
         SetWindowText(GetDlgItem(g_hDlg,IDC_EMESH),szTemp);
 
         const char* szOp;
         switch (pcNew->eOp)
         {
         case aiTextureOp_Add:
             szOp = "add";
             break;
         case aiTextureOp_Subtract:
             szOp = "sub";
             break;
         case aiTextureOp_Divide:
             szOp = "div";
             break;
         case aiTextureOp_SignedAdd:
             szOp = "addsign";
             break;
         case aiTextureOp_SmoothAdd:
             szOp = "addsmooth";
             break;
-        default: 
+        default:
             szOp = "mul";
             break;
         };
         SetWindowText(GetDlgItem(g_hDlg,IDC_ELOAD),szOp);
 
         // NOTE: Format is always ARGB8888 since other formats are
         // converted to this format ...
         SetWindowText(GetDlgItem(g_hDlg,IDC_EFACE),"ARGB8");
 
         // check whether this is the default texture
         if (pcNew->piTexture)
         {
             // {9785DA94-1D96-426b-B3CB-BADC36347F5E}
             static const GUID guidPrivateData =
             { 0x9785da94, 0x1d96, 0x426b,
             { 0xb3, 0xcb, 0xba, 0xdc, 0x36, 0x34, 0x7f, 0x5e } };
 
             uint32_t iData = 0;
             DWORD dwSize = 4;
             (*pcNew->piTexture)->GetPrivateData(guidPrivateData,&iData,&dwSize);
 
             if (0xFFFFFFFF == iData)
             {
                 CLogDisplay::Instance().AddEntry("[ERROR] Texture could not be loaded. "
                     "The displayed texture is a default texture",
                     D3DCOLOR_ARGB(0xFF,0xFF,0,0));
                 return 0;
             }
         }
     }
     // redraw the color fields in the UI --- their purpose has possibly changed
     UpdateColorFieldsInUI();
     UpdateWindow(g_hDlg);
     return 1;
 }
 //-------------------------------------------------------------------------------
diff --git a/tools/assimp_view/MessageProc.cpp b/tools/assimp_view/MessageProc.cpp
index 580d35bf1..56831eb2a 100644
--- a/tools/assimp_view/MessageProc.cpp
+++ b/tools/assimp_view/MessageProc.cpp
@@ -2150,285 +2150,285 @@ using namespace AssimpView;
 //-------------------------------------------------------------------------------
 // Entry point to the application
 //-------------------------------------------------------------------------------
 int APIENTRY _tWinMain(HINSTANCE hInstance,
                        HINSTANCE hPrevInstance,
                        LPTSTR    lpCmdLine,
                        int       nCmdShow)
 {
     UNREFERENCED_PARAMETER(hPrevInstance);
     UNREFERENCED_PARAMETER(lpCmdLine);
 
     // needed for the RichEdit control in the about/help dialog
     LoadLibrary( "riched20.dll" );
 
     // load windows common controls library to get XP style
     InitCommonControls();
 
     // initialize the IDirect3D9 interface
     g_hInstance = hInstance;
     if (0 == InitD3D()) {
         MessageBox(nullptr,"Failed to initialize Direct3D 9",
             "ASSIMP ModelViewer",MB_OK);
         return -6;
     }
 
     // create the main dialog
     HWND hDlg = CreateDialog(hInstance,MAKEINTRESOURCE(IDD_DIALOGMAIN),
         nullptr,&MessageProc);
 
     // ensure we get high priority
     ::SetPriorityClass(GetCurrentProcess(),HIGH_PRIORITY_CLASS);
 
     // initialize the default logger if necessary
     Assimp::DefaultLogger::create("",Assimp::Logger::VERBOSE);
 
     CLogWindow::Instance().pcStream = new CMyLogStream();
     Assimp::DefaultLogger::get()->attachStream(CLogWindow::Instance().pcStream,
         Assimp::DefaultLogger::Debugging | Assimp::DefaultLogger::Info |
         Assimp::DefaultLogger::Err | Assimp::DefaultLogger::Warn);
 
     if (nullptr == hDlg) {
         MessageBox(nullptr,"Failed to create dialog from resource",
             "ASSIMP ModelViewer",MB_OK);
         return -5;
     }
 
     // display the window
     g_hDlg = hDlg;
     MSG uMsg;
     memset(&uMsg,0,sizeof( MSG));
     ShowWindow( hDlg, nCmdShow );
     UpdateWindow( hDlg );
 
     // create the D3D device object
     if (0 == CreateDevice(g_sOptions.bMultiSample,false,true)) {
         MessageBox(nullptr,"Failed to initialize Direct3D 9 (2)",
             "ASSIMP ModelViewer",MB_OK);
         return -4;
     }
-    
+
     CLogDisplay::Instance().AddEntry("[OK] Here we go!");
 
     // create the log window
     CLogWindow::Instance().Init();
     // set the focus to the main window
     SetFocus(g_hDlg);
 
     // recover background skyboxes/textures from the last session
     HKEY hRegistry;
     union {
         char szFileName[MAX_PATH];
         D3DCOLOR clrColor;
     };
     DWORD dwTemp = MAX_PATH;
     RegCreateKeyEx(HKEY_CURRENT_USER,
         "Software\\ASSIMP\\Viewer",0,nullptr,0,KEY_ALL_ACCESS, nullptr, &hRegistry,nullptr);
     if(ERROR_SUCCESS == RegQueryValueEx(hRegistry,"LastSkyBoxSrc",nullptr,nullptr,
         (BYTE*)szFileName,&dwTemp) && '\0' != szFileName[0])
         {
         CBackgroundPainter::Instance().SetCubeMapBG(szFileName);
         }
     else if(ERROR_SUCCESS == RegQueryValueEx(hRegistry,"LastTextureSrc",nullptr,nullptr,
         (BYTE*)szFileName,&dwTemp) && '\0' != szFileName[0])
         {
         CBackgroundPainter::Instance().SetTextureBG(szFileName);
         }
     else if(ERROR_SUCCESS == RegQueryValueEx(hRegistry,"Color",nullptr,nullptr,
         (BYTE*)&clrColor,&dwTemp))
         {
         CBackgroundPainter::Instance().SetColor(clrColor);
         }
     RegCloseKey(hRegistry);
 
     // now handle command line arguments
     HandleCommandLine(lpCmdLine);
 
     double adLast[30];
     for (int i = 0; i < 30;++i)adLast[i] = 0.0f;
     int iCurrent = 0;
 
     double g_dCurTime = 0;
     double g_dLastTime = 0;
     while( uMsg.message != WM_QUIT )
         {
         if( PeekMessage( &uMsg, nullptr, 0, 0, PM_REMOVE ) )
             {
             TranslateMessage( &uMsg );
             DispatchMessage( &uMsg );
 
             if (WM_CHAR == uMsg.message)
                 {
 
                 switch ((char)uMsg.wParam)
                     {
                     case 'M':
                     case 'm':
 
                         CheckDlgButton(g_hDlg,IDC_TOGGLEMS,
                             IsDlgButtonChecked(g_hDlg,IDC_TOGGLEMS) == BST_CHECKED
                             ? BST_UNCHECKED : BST_CHECKED);
 
                         ToggleMS();
                         break;
 
                     case 'L':
                     case 'l':
 
                         CheckDlgButton(g_hDlg,IDC_3LIGHTS,
                             IsDlgButtonChecked(g_hDlg,IDC_3LIGHTS) == BST_CHECKED
                             ? BST_UNCHECKED : BST_CHECKED);
 
                         ToggleMultipleLights();
                         break;
 
                     case 'P':
                     case 'p':
 
                         CheckDlgButton(g_hDlg,IDC_LOWQUALITY,
                             IsDlgButtonChecked(g_hDlg,IDC_LOWQUALITY) == BST_CHECKED
                             ? BST_UNCHECKED : BST_CHECKED);
 
                         ToggleLowQuality();
                         break;
 
                     case 'D':
                     case 'd':
 
                         CheckDlgButton(g_hDlg,IDC_TOGGLEMAT,
                             IsDlgButtonChecked(g_hDlg,IDC_TOGGLEMAT) == BST_CHECKED
                             ? BST_UNCHECKED : BST_CHECKED);
 
                         ToggleMats();
                         break;
 
 
                     case 'N':
                     case 'n':
 
                         CheckDlgButton(g_hDlg,IDC_TOGGLENORMALS,
                             IsDlgButtonChecked(g_hDlg,IDC_TOGGLENORMALS) == BST_CHECKED
                             ? BST_UNCHECKED : BST_CHECKED);
                         ToggleNormals();
                         break;
 
 
                     case 'S':
                     case 's':
 
                         CheckDlgButton(g_hDlg,IDC_NOSPECULAR,
                             IsDlgButtonChecked(g_hDlg,IDC_NOSPECULAR) == BST_CHECKED
                             ? BST_UNCHECKED : BST_CHECKED);
 
                         ToggleSpecular();
                         break;
 
                     case 'A':
                     case 'a':
 
                         CheckDlgButton(g_hDlg,IDC_AUTOROTATE,
                             IsDlgButtonChecked(g_hDlg,IDC_AUTOROTATE) == BST_CHECKED
                             ? BST_UNCHECKED : BST_CHECKED);
 
                         ToggleAutoRotate();
                         break;
 
 
                     case 'R':
                     case 'r':
 
                         CheckDlgButton(g_hDlg,IDC_LIGHTROTATE,
                             IsDlgButtonChecked(g_hDlg,IDC_LIGHTROTATE) == BST_CHECKED
                             ? BST_UNCHECKED : BST_CHECKED);
 
                         ToggleLightRotate();
                         break;
 
                     case 'Z':
                     case 'z':
 
                         CheckDlgButton(g_hDlg,IDC_ZOOM,
                             IsDlgButtonChecked(g_hDlg,IDC_ZOOM) == BST_CHECKED
                             ? BST_UNCHECKED : BST_CHECKED);
 
                         ToggleFPSView();
                         break;
 
 
                     case 'W':
                     case 'w':
 
                         CheckDlgButton(g_hDlg,IDC_TOGGLEWIRE,
                             IsDlgButtonChecked(g_hDlg,IDC_TOGGLEWIRE) == BST_CHECKED
                             ? BST_UNCHECKED : BST_CHECKED);
 
                         ToggleWireFrame();
                         break;
 
                     case 'K':
                     case 'k':
 
                         CheckDlgButton(g_hDlg,IDC_SHOWSKELETON,
                             IsDlgButtonChecked(g_hDlg,IDC_SHOWSKELETON) == BST_CHECKED
                             ? BST_UNCHECKED : BST_CHECKED);
 
                         ToggleSkeleton();
                         break;
 
                     case 'C':
                     case 'c':
 
                         CheckDlgButton(g_hDlg,IDC_BFCULL,
                             IsDlgButtonChecked(g_hDlg,IDC_BFCULL) == BST_CHECKED
                             ? BST_UNCHECKED : BST_CHECKED);
 
                         ToggleCulling();
                         break;
 
                     case 'T':
                     case 't':
 
                         CheckDlgButton(g_hDlg,IDC_NOAB,
                             IsDlgButtonChecked(g_hDlg,IDC_NOAB) == BST_CHECKED
                             ? BST_UNCHECKED : BST_CHECKED);
 
                         ToggleTransparency();
                         break;
                     }
                 }
             }
 
 
         // render the scene
         CDisplay::Instance().OnRender();
 
         // measure FPS, average it out
         g_dCurTime     = timeGetTime();
         g_fElpasedTime = (float)((g_dCurTime - g_dLastTime) * 0.001);
         g_dLastTime    = g_dCurTime;
 
         adLast[iCurrent++] = 1.0f / g_fElpasedTime;
 
         double dFPS = 0.0;
         for (int i = 0; i < 30; ++i) {
             dFPS += adLast[ i ];
         }
         dFPS /= 30.0;
 
         if (30 == iCurrent) {
             iCurrent = 0;
             if (dFPS != g_fFPS) {
                 g_fFPS = dFPS;
                 char szOut[256];
 
                 sprintf(szOut,"%i",(int)floorf((float)dFPS+0.5f));
                 SetDlgItemText(g_hDlg,IDC_EFPS,szOut);
             }
         }
     }
     DeleteAsset();
     Assimp::DefaultLogger::kill();
     ShutdownDevice();
     ShutdownD3D();
 
     return 0;
 }
diff --git a/tools/assimp_view/Shaders.cpp b/tools/assimp_view/Shaders.cpp
index a3404d5bf..b8ee8dbf8 100644
--- a/tools/assimp_view/Shaders.cpp
+++ b/tools/assimp_view/Shaders.cpp
@@ -7,8 +7,8 @@ Copyright (c) 2006-2021, assimp team
 
 All rights reserved.
 
-Redistribution and use of this software in source and binary forms, 
-with or without modification, are permitted provided that the following 
+Redistribution and use of this software in source and binary forms,
+with or without modification, are permitted provided that the following
 conditions are met:
 
 * Redistributions of source code must retain the above
@@ -25,16 +25,16 @@ conditions are met:
   derived from this software without specific prior
   written permission of the assimp team.
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ---------------------------------------------------------------------------
 */
diff --git a/tools/assimp_view/assimp_view.cpp b/tools/assimp_view/assimp_view.cpp
index 5ab7c53ad..e780e2aaf 100644
--- a/tools/assimp_view/assimp_view.cpp
+++ b/tools/assimp_view/assimp_view.cpp
@@ -7,8 +7,8 @@ Copyright (c) 2006-2021, assimp team
 
 All rights reserved.
 
-Redistribution and use of this software in source and binary forms, 
-with or without modification, are permitted provided that the following 
+Redistribution and use of this software in source and binary forms,
+with or without modification, are permitted provided that the following
 conditions are met:
 
 * Redistributions of source code must retain the above
@@ -25,16 +25,16 @@ contributors may be used to endorse or promote products
 derived from this software without specific prior
 written permission of the assimp team.
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ---------------------------------------------------------------------------
 */
diff --git a/tools/assimp_view/resource.h b/tools/assimp_view/resource.h
index 5077f6ccf..754eb69bd 100644
--- a/tools/assimp_view/resource.h
+++ b/tools/assimp_view/resource.h
@@ -1,235 +1,235 @@
 //{{NO_DEPENDENCIES}}
 // Microsoft Visual C++ generated include file.
 // Used by assimp_view.rc
 //
 #define IDC_MYICON                      2
 #define IDD_ASSIMP_VIEW_DIALOG          102
 #define IDD_ABOUTBOX                    103
 #define IDI_ASSIMP_VIEW                 107
 #define IDI_SMALL                       108
 #define IDR_MAINFRAME                   128
 #define IDD_DIALOGMAIN                  129
 #define IDB_BITMAP1                     130
 #define IDR_MENU1                       131
 #define IDD_LOADDIALOG                  132
 #define IDB_BITMAP2                     134
 #define IDD_AVHELP                      135
 #define IDR_TEXT1                       138
 #define IDR_MAX                         140
 #define IDB_MAXCIRCLEMASK               141
 #define IDB_MAXCIRCLE                   142
 #define IDR_HUD                         143
 #define IDR_HUDMASK                     144
 #define IDB_BANIM                       145
 #define IDB_BITMAP4                     146
 #define IDB_BDISPLAY                    146
 #define IDB_BITMAP5                     147
 #define IDB_BINTER                      147
 #define IDB_BITMAP6                     148
 #define IDB_BRENDERING                  148
 #define IDB_BITMAP7                     149
 #define IDB_BSTATS                      149
 #define IDB_BTX                         150
 #define IDB_BITMAP8                     151
 #define IDB_BFX                         151
 #define IDB_BITMAP9                     152
 #define IDB_BNODE                       152
 #define IDB_BITMAP10                    153
 #define IDB_BROOT                       153
 #define IDD_LOGVIEW                     154
 #define IDB_BTXI                        155
 #define IDR_TXPOPUP                     156
 #define IDR_MATPOPUP                    157
 #define IDD_DIALOGSMOOTH                159
 #define SVNRevision                     700
 #define IDC_CHECK1                      1000
 #define IDC_TOGGLEMS                    1000
 #define IDC_CHECK2                      1001
 #define IDC_TOGGLEWIRE                  1001
 #define IDC_CHECK3                      1002
 #define IDC_TOGGLEMAT                   1002
 #define IDC_CHECK4                      1003
 #define IDC_TOGGLENORMALS               1003
 #define IDC_CHECK5                      1004
 #define IDC_AUTOROTATE                  1004
 #define IDC_RT                          1006
 #define IDC_NUMVERTS                    1007
 #define IDC_NUMFACES                    1008
 #define IDC_NUMMATS                     1009
 #define IDC_FPS                         1010
 #define IDC_EFPS                        1011
 #define IDC_EMAT                        1012
 #define IDC_EFACE                       1013
 #define IDC_EVERT                       1014
 #define IDC_CHECK6                      1015
 #define IDC_LIGHTROTATE                 1015
 #define IDC_3LIGHTS                     1016
 #define IDC_PROGRESS                    1016
 #define IDC_LOADTIME                    1017
 #define IDC_ELOAD                       1018
 #define IDC_CHECK7                      1019
 #define IDC_ZOOM                        1019
 #define IDC_CHECK8                      1020
 #define IDC_LOWQUALITY                  1020
 #define IDC_NUMMATS2                    1021
 #define IDC_NUMSHADERS                  1021
 #define IDC_ESHADER                     1022
 #define IDC_RICHEDIT21                  1023
 #define IDC_EMESH                       1023
 #define IDC_CHECK9                      1024
 #define IDC_NOSPECULAR                  1024
 #define IDC_PLAYANIM                    1025
 #define IDC_3LIGHTS2                    1025
 #define IDC_NOAB                        1025
 #define IDC_SPEED                       1026
 #define IDC_COMBO1                      1027
 #define IDC_PINORDER                    1028
 #define IDC_NOSPECULAR2                 1028
 #define IDC_SSPEED                      1029
 #define IDC_SANIM                       1030
 #define IDC_SANIMGB                     1031
 #define IDC_ENODE                       1031
 #define IDC_ESHADER2                    1032
 #define IDC_ETEX                        1032
 #define IDC_TREE1                       1033
 #define IDC_EDIT1                       1034
 #define IDC_BLUBB                       1037
 #define IDC_BLABLA                      1038
 #define IDC_NUMNODES                    1038
 #define IDC_LCOLOR1                     1041
 #define IDC_LCOLOR2                     1042
 #define IDC_ENODEWND                    1043
 #define IDC_LCOLOR3                     1044
 #define IDC_LRESET                      1046
 #define IDC_NUMMESHES                   1047
 #define IDC_VIEWMAT                     1048
 #define IDC_VIEWMATRIX                  1048
 #define IDC_SLIDERANIM                  1052
 #define IDC_PLAY                        1053
 #define IDC_SHOWSKELETON                1054
 #define IDC_BFCULL                      1055
 #define IDC_EDITSM                      1056
 #define ID_VIEWER_OPEN                  32771
 #define ID_VIEWER_CLOSETHIS             32772
 #define ID_VIEWER_CLOSEASSET            32773
 #define ID_VIEWER_QUIT                  32774
 #define ID__ABOUT                       32775
 #define ID__HELP                        32776
 #define ID_VIEWER_SAVESCREENSHOTTOFILE  32777
 #define ID_VIEWER_RESETVIEW             32778
 #define ID_BACKGROUND_LOADTEXTURE       32779
 #define ID_BACKGROUND_CLEAR             32780
 #define ID_BACKGROUND_SETCOLOR          32781
 #define ID_Menu                         32782
 #define ID_BACKGROUND_LOADSKYBOX        32783
 #define ID_VIEWER_H                     32784
 #define ID_TOOLS_LOGWINDOW              32785
 #define ID_TOOLS_SAVELOGTOFILE          32786
 #define ID_TOOLS_CLEARLOG               32787
 #define ID_VIEWER_RECENTFILES           32788
 #define ID_VIEWER_MEMORYCONSUMATION     32789
 #define ID_VIEWER_CLEARHISTORY          32790
 #define ID_TOOLS_ORIGINALNORMALS        32791
 #define ID_TOOLS_SMOOTHNORMALS          32792
 #define ID_TOOLS_HARDNORMALS            32793
 #define ID_TOOLS_FLIPNORMALS            32794
 #define ID__S                           32795
 #define ID__FEEDBACK                    32796
 #define ID_FEEDBACK_GH                  32797
 #define ID_FEEDBACK_FEATUREREQUEST      32798
 #define ID_FEEDBACK_DONATE              32799
 #define ID_ANIMATION_PLAYALLINORDER     32800
 #define ID_TOOLS_STEREOVIEW             32801
 #define ID_EGNEKLGEG_EGEG               32802
 #define ID_HEY_REPLACE                  32803
 #define ID_HEY_EXPORT                   32804
 #define ID_HEY_REMOVE                   32805
 #define ID_SOLONG_ADDDIFFUSETEXTURE     32806
 #define ID_SOLONG_ADDSPECULARTEXTURE    32807
 #define ID_SOLONG_ADDAMBIENTTEXTURE     32808
 #define ID_SOLONG_ADDEMISSIVETEXTURE    32809
 #define ID_SOLONG_ADDOPACITYTEXTURE     32810
 #define ID_SOLONG_ADDNORMAL             32811
 #define ID_SOLONG_ADDSHININESSTEXTURE   32812
 #define ID_SOLONG_CLEARDIFFUSECOLOR     32813
 #define ID_SOLONG_CLEARSPECULARCOLOR    32814
 #define ID_SOLONG_CLEARAMBIENTCOLOR     32815
 #define ID_SOLONG_CLEAREMISSIVECOLOR    32816
 #define ID_SOLONG_CLEARTRANSPARENCY     32817
 #define ID_SOLONG_MAKEDEFAULTMATERIAL   32818
 #define ID_HEY_RESETTEXTURE             32819
 #define ID_SOLONG_SETSHADINGMODE        32820
 #define ID_SETSHADINGMODE_GOURAUD       32821
 #define ID_SETSHADINGMODE_PHONG         32822
 #define ID_OPTIMIZE_OPTIMIZEACMR        32823
 #define ID_OPTIMIZE_OPTIMIZEOVERDRAW    32824
 #define ID_OPTIMIZE_OPTIMIZEBOTH        32825
 #define ID_VERTEXCACHELOCALITY_FINDCURRENT 32826
 #define ID_VERTEXCACHELOCALITY_OPTIMIZE 32827
 #define ID_VERTEXCACHELOCALITY_FINDBEST 32828
 #define ID_OPTIMIZE_SCENEGRAPH          32829
 #define ID_SCENEGRAPH_SMALLESTPOSSIBLEGRAPH 32830
 #define ID_SMOOTHNORMALS_5              32831
 #define ID_SMOOTHNORMALS_6              32832
 #define ID_SMOOTHNORMALS_MAXANGLE60     32833
 #define ID_SMOOTHNORMALS_MAXANGLE90     32834
 #define ID_SMOOTHNORMALS_MAXANGLE120    32835
 #define ID_SMOOTHNORMALS_NOLIMIT        32836
 #define ID_SMOOTHNORMALS_30             32837
 #define ID_SMOOTHNORMALS_40             32838
 #define ID_SMOOTHNORMALS_60             32839
 #define ID_SMOOTHNORMALS_90             32840
 #define ID_SMOOTHNORMALS_120            32841
 #define ID_Menu32842                    32842
 #define ID_SMOOTHANGLE_30               32843
 #define ID_SMOOTHANGLE_40               32844
 #define ID_SMOOTHANGLE_50               32845
 #define ID_SMOOTHANGLE_60               32846
 #define ID_SMOOTHANGLE_70               32847
 #define ID_SMOOTHANGLE_90               32848
 #define ID_SMOOTHANGLE_120              32849
 #define ID_SMOOTHANGLE_NONE             32850
 #define ID_TOOLS_SETANGLELIMIT          32851
 #define ID_VIEWER_PP_JIV                32852
 #define ID_VIEWER_PP_RRM                32852
 #define ID_VIEWER_PP_OM                 32853
 #define ID_VIEWER_PP_OG                 32854
 #define ID_VIEWER_PP_FIM                32855
 #define ID_VIEWER_PP_VDS                32856
 #define ID_VIEWER_PP_PTV                32857
 #define ID_VIEWER_PP_ICL                32858
 #define ID_VIEWER_PP_FIN                32859
 #define ID_VIEWER_PP_FD                 32860
 #define ID_VIEWER_PP_FID                32861
 #define ID_VIEWER_PP_GUV                32862
 #define ID_VIEWER_PP_TUV                32863
 #define ID_VIEWER_PP_RLINE_PNT          32864
 #define ID_REPORTBUG                    32865
 #define ID_FR                           32866
 #define ID__WEBSITE                     32867
 #define ID__SF                          32868
 #define ID__                            32869
 #define ID__WEBSITESF                   32870
 #define ID_IMPORTSETTINGS_CALCULATETANGENTSPACE 32871
 #define ID_VIEWER_CTS                   32872
 #define ID_VIEWER_PP_CTS                32873
 #define ID_VIEWER_RELOAD                32874
 #define ID_VIEWER_PP_RRM2               32875
 #define ID_IMPORTSETTINGS_RESETTODEFAULT 32876
 #define ID_IMPORTSETTINGS_OPENPOST      32877
 #define ID_EXPORT                       32878
 #define ID_IMPORTSETTINGS_REMOVEDUMMYBONES 32879
 #define ID_VIEWER_PP_DB                 32880
 #define IDC_STATIC                      -1
 
 // Next default values for new objects
-// 
+//
 #ifdef APSTUDIO_INVOKED
 #ifndef APSTUDIO_READONLY_SYMBOLS
 #define _APS_NO_MFC                     1
 #define _APS_NEXT_RESOURCE_VALUE        160
 #define _APS_NEXT_COMMAND_VALUE         32881
 #define _APS_NEXT_CONTROL_VALUE         1059
 #define _APS_NEXT_SYMED_VALUE           110
 #endif
 #endif
