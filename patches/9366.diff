commit 1adc53a3ec46fb28fb3f3d544214442e33450498
Author: Cristy <urban-warrior@imagemagick.org>
Date:   Fri Jul 13 19:54:53 2018 -0400

    https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=9366

diff --git a/MagickCore/draw.c b/MagickCore/draw.c
index 29aad764d..23df35ba2 100644
--- a/MagickCore/draw.c
+++ b/MagickCore/draw.c
@@ -234,177 +234,177 @@ MagickExport DrawInfo *AcquireDrawInfo(void)
   draw_info=(DrawInfo *) AcquireCriticalMemory(sizeof(*draw_info));
   GetDrawInfo((ImageInfo *) NULL,draw_info);
   return(draw_info);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   C l o n e D r a w I n f o                                                 %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  CloneDrawInfo() makes a copy of the given draw_info structure.  If NULL
 %  is specified, a new DrawInfo structure is created initialized to default
 %  values.
 %
 %  The format of the CloneDrawInfo method is:
 %
 %      DrawInfo *CloneDrawInfo(const ImageInfo *image_info,
 %        const DrawInfo *draw_info)
 %
 %  A description of each parameter follows:
 %
 %    o image_info: the image info.
 %
 %    o draw_info: the draw info.
 %
 */
 MagickExport DrawInfo *CloneDrawInfo(const ImageInfo *image_info,
   const DrawInfo *draw_info)
 {
   DrawInfo
     *clone_info;
 
   ExceptionInfo
     *exception;
 
   clone_info=(DrawInfo *) AcquireCriticalMemory(sizeof(*clone_info));
   GetDrawInfo(image_info,clone_info);
   if (draw_info == (DrawInfo *) NULL)
     return(clone_info);
   exception=AcquireExceptionInfo();
   if (clone_info->primitive != (char *) NULL)
     (void) CloneString(&clone_info->primitive,draw_info->primitive);
   if (draw_info->geometry != (char *) NULL)
     (void) CloneString(&clone_info->geometry,draw_info->geometry);
   clone_info->compliance=draw_info->compliance;
   clone_info->viewbox=draw_info->viewbox;
   clone_info->affine=draw_info->affine;
   clone_info->gravity=draw_info->gravity;
   clone_info->fill=draw_info->fill;
   clone_info->stroke=draw_info->stroke;
   clone_info->stroke_width=draw_info->stroke_width;
   if (draw_info->fill_pattern != (Image *) NULL)
     clone_info->fill_pattern=CloneImage(draw_info->fill_pattern,0,0,MagickTrue,
       exception);
   if (draw_info->stroke_pattern != (Image *) NULL)
     clone_info->stroke_pattern=CloneImage(draw_info->stroke_pattern,0,0,
       MagickTrue,exception);
   clone_info->stroke_antialias=draw_info->stroke_antialias;
   clone_info->text_antialias=draw_info->text_antialias;
   clone_info->fill_rule=draw_info->fill_rule;
   clone_info->linecap=draw_info->linecap;
   clone_info->linejoin=draw_info->linejoin;
   clone_info->miterlimit=draw_info->miterlimit;
   clone_info->dash_offset=draw_info->dash_offset;
   clone_info->decorate=draw_info->decorate;
   clone_info->compose=draw_info->compose;
   if (draw_info->text != (char *) NULL)
     (void) CloneString(&clone_info->text,draw_info->text);
   if (draw_info->font != (char *) NULL)
     (void) CloneString(&clone_info->font,draw_info->font);
   if (draw_info->metrics != (char *) NULL)
     (void) CloneString(&clone_info->metrics,draw_info->metrics);
   if (draw_info->family != (char *) NULL)
     (void) CloneString(&clone_info->family,draw_info->family);
   clone_info->style=draw_info->style;
   clone_info->stretch=draw_info->stretch;
   clone_info->weight=draw_info->weight;
   if (draw_info->encoding != (char *) NULL)
     (void) CloneString(&clone_info->encoding,draw_info->encoding);
   clone_info->pointsize=draw_info->pointsize;
   clone_info->kerning=draw_info->kerning;
   clone_info->interline_spacing=draw_info->interline_spacing;
   clone_info->interword_spacing=draw_info->interword_spacing;
   clone_info->direction=draw_info->direction;
   if (draw_info->density != (char *) NULL)
     (void) CloneString(&clone_info->density,draw_info->density);
   clone_info->align=draw_info->align;
   clone_info->undercolor=draw_info->undercolor;
   clone_info->border_color=draw_info->border_color;
   if (draw_info->server_name != (char *) NULL)
     (void) CloneString(&clone_info->server_name,draw_info->server_name);
   if (draw_info->dash_pattern != (double *) NULL)
     {
       register ssize_t
         x;
 
       for (x=0; fabs(draw_info->dash_pattern[x]) >= MagickEpsilon; x++) ;
-      clone_info->dash_pattern=(double *) AcquireQuantumMemory((size_t) x+1UL,
+      clone_info->dash_pattern=(double *) AcquireQuantumMemory((size_t) (x+2),
         sizeof(*clone_info->dash_pattern));
       if (clone_info->dash_pattern == (double *) NULL)
         ThrowFatalException(ResourceLimitFatalError,
           "UnableToAllocateDashPattern");
       (void) memcpy(clone_info->dash_pattern,draw_info->dash_pattern,(size_t)
-        (x+1)*sizeof(*clone_info->dash_pattern));
+        (x+2)*sizeof(*clone_info->dash_pattern));
     }
   clone_info->gradient=draw_info->gradient;
   if (draw_info->gradient.stops != (StopInfo *) NULL)
     {
       size_t
         number_stops;
 
       number_stops=clone_info->gradient.number_stops;
       clone_info->gradient.stops=(StopInfo *) AcquireQuantumMemory((size_t)
         number_stops,sizeof(*clone_info->gradient.stops));
       if (clone_info->gradient.stops == (StopInfo *) NULL)
         ThrowFatalException(ResourceLimitFatalError,
           "UnableToAllocateDashPattern");
       (void) memcpy(clone_info->gradient.stops,draw_info->gradient.stops,
         (size_t) number_stops*sizeof(*clone_info->gradient.stops));
     }
   clone_info->bounds=draw_info->bounds;
   clone_info->fill_alpha=draw_info->fill_alpha;
   clone_info->stroke_alpha=draw_info->stroke_alpha;
   clone_info->element_reference=draw_info->element_reference;
   clone_info->clip_path=draw_info->clip_path;
   clone_info->clip_units=draw_info->clip_units;
   if (draw_info->clip_mask != (char *) NULL)
     (void) CloneString(&clone_info->clip_mask,draw_info->clip_mask);
   if (draw_info->clipping_mask != (Image *) NULL)
     clone_info->clipping_mask=CloneImage(draw_info->clipping_mask,0,0,
       MagickTrue,exception);
   if (draw_info->composite_mask != (Image *) NULL)
     clone_info->composite_mask=CloneImage(draw_info->composite_mask,0,0,
       MagickTrue,exception);
   clone_info->render=draw_info->render;
   clone_info->debug=IsEventLogging();
   exception=DestroyExceptionInfo(exception);
   return(clone_info);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 +   C o n v e r t P a t h T o P o l y g o n                                   %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  ConvertPathToPolygon() converts a path to the more efficient sorted
 %  rendering form.
 %
 %  The format of the ConvertPathToPolygon method is:
 %
 %      PolygonInfo *ConvertPathToPolygon(const PathInfo *path_info)
 %
 %  A description of each parameter follows:
 %
 %    o Method ConvertPathToPolygon returns the path in a more efficient sorted
 %      rendering form of type PolygonInfo.
 %
 %    o draw_info: Specifies a pointer to an DrawInfo structure.
 %
 %    o path_info: Specifies a pointer to an PathInfo structure.
 %
 %
 */
 
 #if defined(__cplusplus) || defined(c_plusplus)
@@ -2364,1963 +2364,1963 @@ static inline void TracePoint(PrimitiveInfo *primitive_info,
 MagickExport MagickBooleanType DrawImage(Image *image,const DrawInfo *draw_info,
   ExceptionInfo *exception)
 {
 #define RenderImageTag  "Render/Image"
 
   AffineMatrix
     affine,
     current;
 
   char
     keyword[MagickPathExtent],
     geometry[MagickPathExtent],
     *next_token,
     pattern[MagickPathExtent],
     *primitive,
     *token;
 
   const char
     *q;
 
   double
     angle,
     coordinates,
     cursor,
     factor,
     primitive_extent;
 
   DrawInfo
     **graphic_context;
 
   MagickBooleanType
     proceed;
 
   MagickStatusType
     status;
 
   MVGInfo
     mvg_info;
 
   PointInfo
     point;
 
   PrimitiveInfo
     *primitive_info;
 
   PrimitiveType
     primitive_type;
 
   register const char
     *p;
 
   register ssize_t
     i,
     x;
 
   SegmentInfo
     bounds;
 
   size_t
     extent,
     number_points,
     number_stops;
 
   SplayTreeInfo
     *macros;
 
   ssize_t
     defsDepth,
     j,
     k,
     n,
     symbolDepth;
 
   StopInfo
     *stops;
 
   assert(image != (Image *) NULL);
   assert(image->signature == MagickCoreSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
   assert(draw_info != (DrawInfo *) NULL);
   assert(draw_info->signature == MagickCoreSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"...");
   if ((draw_info->primitive == (char *) NULL) ||
       (*draw_info->primitive == '\0'))
     return(MagickFalse);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(DrawEvent,GetMagickModule(),"begin draw-image");
   if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)
     return(MagickFalse);
   if (image->alpha_trait == UndefinedPixelTrait)
     {
       status=SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);
       if (status == MagickFalse)
         return(status);
     }
   primitive=(char *) NULL;
   if (*draw_info->primitive != '@')
     primitive=AcquireString(draw_info->primitive);
   else
     if ((strlen(draw_info->primitive) > 1) &&
         (*(draw_info->primitive+1) != '-'))
       primitive=FileToString(draw_info->primitive+1,~0UL,exception);
   if (primitive == (char *) NULL)
     return(MagickFalse);
   primitive_extent=(double) strlen(primitive);
   (void) SetImageArtifact(image,"MVG",primitive);
   n=0;
   number_stops=0;
   stops=(StopInfo *) NULL;
   /*
     Allocate primitive info memory.
   */
   graphic_context=(DrawInfo **) AcquireMagickMemory(sizeof(*graphic_context));
   if (graphic_context == (DrawInfo **) NULL)
     {
       primitive=DestroyString(primitive);
       ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
         image->filename);
     }
   number_points=4096;
   primitive_info=(PrimitiveInfo *) AcquireQuantumMemory((size_t) number_points,
     sizeof(*primitive_info));
   if (primitive_info == (PrimitiveInfo *) NULL)
     {
       primitive=DestroyString(primitive);
       for ( ; n >= 0; n--)
         graphic_context[n]=DestroyDrawInfo(graphic_context[n]);
       graphic_context=(DrawInfo **) RelinquishMagickMemory(graphic_context);
       ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
         image->filename);
     }
   (void) memset(primitive_info,0,(size_t) number_points*
     sizeof(*primitive_info));
   mvg_info.primitive_info=(&primitive_info);
   mvg_info.extent=(&number_points);
   mvg_info.offset=0;
   mvg_info.exception=exception;
   graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,draw_info);
   graphic_context[n]->viewbox=image->page;
   if ((image->page.width == 0) || (image->page.height == 0))
     {
       graphic_context[n]->viewbox.width=image->columns;
       graphic_context[n]->viewbox.height=image->rows;
     }
   token=AcquireString(primitive);
   extent=strlen(token)+MagickPathExtent;
   defsDepth=0;
   symbolDepth=0;
   cursor=0.0;
   macros=GetMVGMacros(primitive);
   status=MagickTrue;
   for (q=primitive; *q != '\0'; )
   {
     /*
       Interpret graphic primitive.
     */
     GetNextToken(q,&q,MagickPathExtent,keyword);
     if (*keyword == '\0')
       break;
     if (*keyword == '#')
       {
         /*
           Comment.
         */
         while ((*q != '\n') && (*q != '\0'))
           q++;
         continue;
       }
     p=q-strlen(keyword)-1;
     primitive_type=UndefinedPrimitive;
     current=graphic_context[n]->affine;
     GetAffineMatrix(&affine);
     switch (*keyword)
     {
       case ';':
         break;
       case 'a':
       case 'A':
       {
         if (LocaleCompare("affine",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             affine.sx=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             affine.rx=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             affine.ry=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             affine.sy=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             affine.tx=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             affine.ty=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             break;
           }
         if (LocaleCompare("alpha",keyword) == 0)
           {
             primitive_type=AlphaPrimitive;
             break;
           }
         if (LocaleCompare("arc",keyword) == 0)
           {
             primitive_type=ArcPrimitive;
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'b':
       case 'B':
       {
         if (LocaleCompare("bezier",keyword) == 0)
           {
             primitive_type=BezierPrimitive;
             break;
           }
         if (LocaleCompare("border-color",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             status&=QueryColorCompliance(token,AllCompliance,
               &graphic_context[n]->border_color,exception);
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'c':
       case 'C':
       {
         if (LocaleCompare("class",keyword) == 0)
           {
             const char
               *mvg_class;
 
             GetNextToken(q,&q,extent,token);
             if (*token == '\0')
               {
                 status=MagickFalse;
                 break;
               }
             mvg_class=(const char *) GetValueFromSplayTree(macros,token);
             if (mvg_class != (const char *) NULL)
               {
                 char
                   *elements;
 
                 ssize_t
                   offset;
 
                 /*
                   Inject class elements in stream.
                 */
                 offset=(ssize_t) (p-primitive);
                 elements=AcquireString(primitive);
                 elements[offset]='\0';
                 (void) ConcatenateString(&elements,mvg_class);
                 (void) ConcatenateString(&elements,"\n");
                 (void) ConcatenateString(&elements,q);
                 primitive=DestroyString(primitive);
                 primitive=elements;
                 q=primitive+offset;
               }
             break;
           }
         if (LocaleCompare("clip-path",keyword) == 0)
           {
             const char
               *clip_path;
 
             /*
               Take a node from within the MVG document, and duplicate it here.
             */
             GetNextToken(q,&q,extent,token);
             if (*token == '\0')
               {
                 status=MagickFalse;
                 break;
               }
             (void) CloneString(&graphic_context[n]->clip_mask,token);
             clip_path=(const char *) GetValueFromSplayTree(macros,token);
             if (clip_path != (const char *) NULL)
               {
                 if (graphic_context[n]->clipping_mask != (Image *) NULL)
                   graphic_context[n]->clipping_mask=
                     DestroyImage(graphic_context[n]->clipping_mask);
                 graphic_context[n]->clipping_mask=DrawClippingMask(image,
                   graphic_context[n],token,clip_path,exception);
                 if (draw_info->compliance != SVGCompliance)
                   (void) DrawClipPath(image,graphic_context[n],
                     graphic_context[n]->clip_mask,exception);
               }
             break;
           }
         if (LocaleCompare("clip-rule",keyword) == 0)
           {
             ssize_t
               fill_rule;
 
             GetNextToken(q,&q,extent,token);
             fill_rule=ParseCommandOption(MagickFillRuleOptions,MagickFalse,
               token);
             if (fill_rule == -1)
               {
                 status=MagickFalse;
                 break;
               }
             graphic_context[n]->fill_rule=(FillRule) fill_rule;
             break;
           }
         if (LocaleCompare("clip-units",keyword) == 0)
           {
             ssize_t
               clip_units;
 
             GetNextToken(q,&q,extent,token);
             clip_units=ParseCommandOption(MagickClipPathOptions,MagickFalse,
               token);
             if (clip_units == -1)
               {
                 status=MagickFalse;
                 break;
               }
             graphic_context[n]->clip_units=(ClipPathUnits) clip_units;
             if (clip_units == ObjectBoundingBox)
               {
                 GetAffineMatrix(&current);
                 affine.sx=draw_info->bounds.x2;
                 affine.sy=draw_info->bounds.y2;
                 affine.tx=draw_info->bounds.x1;
                 affine.ty=draw_info->bounds.y1;
                 break;
               }
             break;
           }
         if (LocaleCompare("circle",keyword) == 0)
           {
             primitive_type=CirclePrimitive;
             break;
           }
         if (LocaleCompare("color",keyword) == 0)
           {
             primitive_type=ColorPrimitive;
             break;
           }
         if (LocaleCompare("compliance",keyword) == 0)
           {
             /*
               MVG compliance associates a clipping mask with an image; SVG
               compliance associates a clipping mask with a graphics context.
             */
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->compliance=(ComplianceType) ParseCommandOption(
               MagickComplianceOptions,MagickFalse,token);
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'd':
       case 'D':
       {
         if (LocaleCompare("decorate",keyword) == 0)
           {
             ssize_t
               decorate;
 
             GetNextToken(q,&q,extent,token);
             decorate=ParseCommandOption(MagickDecorateOptions,MagickFalse,
               token);
             if (decorate == -1)
               {
                 status=MagickFalse;
                 break;
               }
             graphic_context[n]->decorate=(DecorationType) decorate;
             break;
           }
         if (LocaleCompare("density",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             (void) CloneString(&graphic_context[n]->density,token);
             break;
           }
         if (LocaleCompare("direction",keyword) == 0)
           {
             ssize_t
               direction;
 
             GetNextToken(q,&q,extent,token);
             direction=ParseCommandOption(MagickDirectionOptions,MagickFalse,
               token);
             if (direction == -1)
               status=MagickFalse;
             else
               graphic_context[n]->direction=(DirectionType) direction;
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'e':
       case 'E':
       {
         if (LocaleCompare("ellipse",keyword) == 0)
           {
             primitive_type=EllipsePrimitive;
             break;
           }
         if (LocaleCompare("encoding",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             (void) CloneString(&graphic_context[n]->encoding,token);
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'f':
       case 'F':
       {
         if (LocaleCompare("fill",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             if (graphic_context[n]->clip_path != MagickFalse)
               break;
             (void) FormatLocaleString(pattern,MagickPathExtent,"%s",token);
             if (GetImageArtifact(image,pattern) != (const char *) NULL)
               (void) DrawPatternPath(image,draw_info,token,
                 &graphic_context[n]->fill_pattern,exception);
             else
               {
                 status&=QueryColorCompliance(token,AllCompliance,
                   &graphic_context[n]->fill,exception);
                 if (graphic_context[n]->fill_alpha != OpaqueAlpha)
                   graphic_context[n]->fill.alpha=graphic_context[n]->fill_alpha;
               }
             break;
           }
         if (LocaleCompare("fill-opacity",keyword) == 0)
           {
             double
               opacity;
 
             GetNextToken(q,&q,extent,token);
             if (graphic_context[n]->clip_path != MagickFalse)
               break;
             factor=strchr(token,'%') != (char *) NULL ? 0.01 : 1.0;
             opacity=MagickMin(MagickMax(factor*
               StringToDouble(token,&next_token),0.0),1.0);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             graphic_context[n]->fill_alpha*=opacity;
             if (graphic_context[n]->fill_alpha != OpaqueAlpha)
               graphic_context[n]->fill.alpha=graphic_context[n]->fill_alpha;
             break;
           }
         if (LocaleCompare("fill-rule",keyword) == 0)
           {
             ssize_t
               fill_rule;
 
             GetNextToken(q,&q,extent,token);
             fill_rule=ParseCommandOption(MagickFillRuleOptions,MagickFalse,
               token);
             if (fill_rule == -1)
               {
                 status=MagickFalse;
                 break;
               }
             graphic_context[n]->fill_rule=(FillRule) fill_rule;
             break;
           }
         if (LocaleCompare("font",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             (void) CloneString(&graphic_context[n]->font,token);
             if (LocaleCompare("none",token) == 0)
               graphic_context[n]->font=(char *) RelinquishMagickMemory(
                 graphic_context[n]->font);
             break;
           }
         if (LocaleCompare("font-family",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             (void) CloneString(&graphic_context[n]->family,token);
             break;
           }
         if (LocaleCompare("font-size",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->pointsize=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             break;
           }
         if (LocaleCompare("font-stretch",keyword) == 0)
           {
             ssize_t
               stretch;
 
             GetNextToken(q,&q,extent,token);
             stretch=ParseCommandOption(MagickStretchOptions,MagickFalse,token);
             if (stretch == -1)
               {
                 status=MagickFalse;
                 break;
               }
             graphic_context[n]->stretch=(StretchType) stretch;
             break;
           }
         if (LocaleCompare("font-style",keyword) == 0)
           {
             ssize_t
               style;
 
             GetNextToken(q,&q,extent,token);
             style=ParseCommandOption(MagickStyleOptions,MagickFalse,token);
             if (style == -1)
               {
                 status=MagickFalse;
                 break;
               }
             graphic_context[n]->style=(StyleType) style;
             break;
           }
         if (LocaleCompare("font-weight",keyword) == 0)
           {
             ssize_t
               weight;
 
             GetNextToken(q,&q,extent,token);
             weight=ParseCommandOption(MagickWeightOptions,MagickFalse,token);
             if (weight == -1)
               weight=(ssize_t) StringToUnsignedLong(token);
             graphic_context[n]->weight=(size_t) weight;
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'g':
       case 'G':
       {
         if (LocaleCompare("gradient-units",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             break;
           }
         if (LocaleCompare("gravity",keyword) == 0)
           {
             ssize_t
               gravity;
 
             GetNextToken(q,&q,extent,token);
             gravity=ParseCommandOption(MagickGravityOptions,MagickFalse,token);
             if (gravity == -1)
               {
                 status=MagickFalse;
                 break;
               }
             graphic_context[n]->gravity=(GravityType) gravity;
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'i':
       case 'I':
       {
         if (LocaleCompare("image",keyword) == 0)
           {
             ssize_t
               compose;
 
             primitive_type=ImagePrimitive;
             GetNextToken(q,&q,extent,token);
             compose=ParseCommandOption(MagickComposeOptions,MagickFalse,token);
             if (compose == -1)
               {
                 status=MagickFalse;
                 break;
               }
             graphic_context[n]->compose=(CompositeOperator) compose;
             break;
           }
         if (LocaleCompare("interline-spacing",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->interline_spacing=StringToDouble(token,
               &next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             break;
           }
         if (LocaleCompare("interword-spacing",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->interword_spacing=StringToDouble(token,
               &next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'k':
       case 'K':
       {
         if (LocaleCompare("kerning",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->kerning=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'l':
       case 'L':
       {
         if (LocaleCompare("line",keyword) == 0)
           {
             primitive_type=LinePrimitive;
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'm':
       case 'M':
       {
         if (LocaleCompare("mask",keyword) == 0)
           {
             const char
               *mask_path;
 
             /*
               Take a node from within the MVG document, and duplicate it here.
             */
             GetNextToken(q,&q,extent,token);
             mask_path=(const char *) GetValueFromSplayTree(macros,token);
             if (mask_path != (const char *) NULL)
               {
                 if (graphic_context[n]->composite_mask != (Image *) NULL)
                   graphic_context[n]->composite_mask=
                     DestroyImage(graphic_context[n]->composite_mask);
                 graphic_context[n]->composite_mask=DrawCompositeMask(image,
                   graphic_context[n],token,mask_path,exception);
                 if (draw_info->compliance != SVGCompliance)
                   status=SetImageMask(image,CompositePixelMask,
                     graphic_context[n]->composite_mask,exception);
               }
             break;
           }
         break;
       }
       case 'o':
       case 'O':
       {
         if (LocaleCompare("offset",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             break;
           }
         if (LocaleCompare("opacity",keyword) == 0)
           {
             double
               opacity;
 
             GetNextToken(q,&q,extent,token);
             if (graphic_context[n]->clip_path != MagickFalse)
               break;
             factor=strchr(token,'%') != (char *) NULL ? 0.01 : 1.0;
             opacity=MagickMin(MagickMax(factor*
               StringToDouble(token,&next_token),0.0),1.0);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             graphic_context[n]->fill_alpha*=opacity;
             if (graphic_context[n]->fill_alpha != OpaqueAlpha)
               graphic_context[n]->fill.alpha=graphic_context[n]->fill_alpha;
             graphic_context[n]->stroke_alpha*=opacity;
             if (graphic_context[n]->stroke_alpha != OpaqueAlpha)
               graphic_context[n]->stroke.alpha=graphic_context[n]->stroke_alpha;
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'p':
       case 'P':
       {
         if (LocaleCompare("path",keyword) == 0)
           {
             primitive_type=PathPrimitive;
             break;
           }
         if (LocaleCompare("point",keyword) == 0)
           {
             primitive_type=PointPrimitive;
             break;
           }
         if (LocaleCompare("polyline",keyword) == 0)
           {
             primitive_type=PolylinePrimitive;
             break;
           }
         if (LocaleCompare("polygon",keyword) == 0)
           {
             primitive_type=PolygonPrimitive;
             break;
           }
         if (LocaleCompare("pop",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             if (LocaleCompare("class",token) == 0)
               break;
             if (LocaleCompare("clip-path",token) == 0)
               break;
             if (LocaleCompare("defs",token) == 0)
               {
                 defsDepth--;
                 graphic_context[n]->render=defsDepth > 0 ? MagickFalse :
                   MagickTrue;
                 break;
               }
             if (LocaleCompare("gradient",token) == 0)
               break;
             if (LocaleCompare("graphic-context",token) == 0)
               {
                 if (n <= 0)
                   {
                     (void) ThrowMagickException(exception,GetMagickModule(),
                       DrawError,"UnbalancedGraphicContextPushPop","`%s'",token);
                     status=MagickFalse;
                     n=0;
                     break;
                   }
                 if ((graphic_context[n]->clip_mask != (char *) NULL) &&
                     (draw_info->compliance != SVGCompliance))
                   if (LocaleCompare(graphic_context[n]->clip_mask,
                       graphic_context[n-1]->clip_mask) != 0)
                     (void) SetImageMask(image,WritePixelMask,(Image *) NULL,
                       exception);
                 graphic_context[n]=DestroyDrawInfo(graphic_context[n]);
                 n--;
                 break;
               }
             if (LocaleCompare("mask",token) == 0)
               break;
             if (LocaleCompare("pattern",token) == 0)
               break;
             if (LocaleCompare("symbol",token) == 0)
               {
                 symbolDepth--;
                 graphic_context[n]->render=symbolDepth > 0 ? MagickFalse :
                   MagickTrue;
                 break;
               }
             status=MagickFalse;
             break;
           }
         if (LocaleCompare("push",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             if (LocaleCompare("class",token) == 0)
               {
                 /*
                   Class context.
                 */
                 for (p=q; *q != '\0'; )
                 {
                   GetNextToken(q,&q,extent,token);
                   if (LocaleCompare(token,"pop") != 0)
                     continue;
                   GetNextToken(q,(const char **) NULL,extent,token);
                   if (LocaleCompare(token,"class") != 0)
                     continue;
                   break;
                 }
                 GetNextToken(q,&q,extent,token);
                 break;
               }
             if (LocaleCompare("clip-path",token) == 0)
               {
                 char
                   name[MaxTextExtent];
 
                 const char
                   *clip_path;
 
                 GetNextToken(q,&q,extent,token);
                 (void) FormatLocaleString(name,MaxTextExtent,"%s",token);
                 clip_path=(const char *) GetValueFromSplayTree(macros,name);
                 if (clip_path != (const char *) NULL)
                   (void) SetImageArtifact(image,name,clip_path);
                 break;
               }
             if (LocaleCompare("defs",token) == 0)
               {
                 defsDepth++;
                 graphic_context[n]->render=defsDepth > 0 ? MagickFalse :
                   MagickTrue;
                 break;
               }
             if (LocaleCompare("gradient",token) == 0)
               {
                 char
                   key[2*MagickPathExtent],
                   name[MagickPathExtent],
                   type[MagickPathExtent];
 
                 SegmentInfo
                   segment;
 
                 GetNextToken(q,&q,extent,token);
                 (void) CopyMagickString(name,token,MagickPathExtent);
                 GetNextToken(q,&q,extent,token);
                 (void) CopyMagickString(type,token,MagickPathExtent);
                 GetNextToken(q,&q,extent,token);
                 segment.x1=StringToDouble(token,&next_token);
                 if (token == next_token)
                   ThrowPointExpectedException(token,exception);
                 GetNextToken(q,&q,extent,token);
                 if (*token == ',')
                   GetNextToken(q,&q,extent,token);
                 segment.y1=StringToDouble(token,&next_token);
                 if (token == next_token)
                   ThrowPointExpectedException(token,exception);
                 GetNextToken(q,&q,extent,token);
                 if (*token == ',')
                   GetNextToken(q,&q,extent,token);
                 segment.x2=StringToDouble(token,&next_token);
                 if (token == next_token)
                   ThrowPointExpectedException(token,exception);
                 GetNextToken(q,&q,extent,token);
                 if (*token == ',')
                   GetNextToken(q,&q,extent,token);
                 segment.y2=StringToDouble(token,&next_token);
                 if (token == next_token)
                   ThrowPointExpectedException(token,exception);
                 if (LocaleCompare(type,"radial") == 0)
                   {
                     GetNextToken(q,&q,extent,token);
                     if (*token == ',')
                       GetNextToken(q,&q,extent,token);
                   }
                 for (p=q; *q != '\0'; )
                 {
                   GetNextToken(q,&q,extent,token);
                   if (LocaleCompare(token,"pop") != 0)
                     continue;
                   GetNextToken(q,(const char **) NULL,extent,token);
                   if (LocaleCompare(token,"gradient") != 0)
                     continue;
                   break;
                 }
                 if ((q == (char *) NULL) || (p == (char *) NULL) || ((q-4) < p))
                   {
                     status=MagickFalse;
                     break;
                   }
                 (void) CopyMagickString(token,p,(size_t) (q-p-4+1));
                 bounds.x1=graphic_context[n]->affine.sx*segment.x1+
                   graphic_context[n]->affine.ry*segment.y1+
                   graphic_context[n]->affine.tx;
                 bounds.y1=graphic_context[n]->affine.rx*segment.x1+
                   graphic_context[n]->affine.sy*segment.y1+
                   graphic_context[n]->affine.ty;
                 bounds.x2=graphic_context[n]->affine.sx*segment.x2+
                   graphic_context[n]->affine.ry*segment.y2+
                   graphic_context[n]->affine.tx;
                 bounds.y2=graphic_context[n]->affine.rx*segment.x2+
                   graphic_context[n]->affine.sy*segment.y2+
                   graphic_context[n]->affine.ty;
                 (void) FormatLocaleString(key,MagickPathExtent,"%s",name);
                 (void) SetImageArtifact(image,key,token);
                 (void) FormatLocaleString(key,MagickPathExtent,"%s-type",name);
                 (void) SetImageArtifact(image,key,type);
                 (void) FormatLocaleString(key,MagickPathExtent,"%s-geometry",
                   name);
                 (void) FormatLocaleString(geometry,MagickPathExtent,
                   "%gx%g%+.15g%+.15g",
                   MagickMax(fabs(bounds.x2-bounds.x1+1.0),1.0),
                   MagickMax(fabs(bounds.y2-bounds.y1+1.0),1.0),
                   bounds.x1,bounds.y1);
                 (void) SetImageArtifact(image,key,geometry);
                 GetNextToken(q,&q,extent,token);
                 break;
               }
             if (LocaleCompare("graphic-context",token) == 0)
               {
                 n++;
                 graphic_context=(DrawInfo **) ResizeQuantumMemory(
                   graphic_context,(size_t) (n+1),sizeof(*graphic_context));
                 if (graphic_context == (DrawInfo **) NULL)
                   {
                     (void) ThrowMagickException(exception,GetMagickModule(),
                       ResourceLimitError,"MemoryAllocationFailed","`%s'",
                       image->filename);
                     break;
                   }
                 graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,
                   graphic_context[n-1]);
                 if (*q == '"')
                   GetNextToken(q,&q,extent,token);
                 break;
               }
             if (LocaleCompare("mask",token) == 0)
               {
                 GetNextToken(q,&q,extent,token);
                 break;
               }
             if (LocaleCompare("pattern",token) == 0)
               {
                 char
                   key[2*MagickPathExtent],
                   name[MagickPathExtent];
 
                 RectangleInfo
                   bounds;
 
                 GetNextToken(q,&q,extent,token);
                 (void) CopyMagickString(name,token,MagickPathExtent);
                 GetNextToken(q,&q,extent,token);
                 bounds.x=(ssize_t) ceil(StringToDouble(token,&next_token)-0.5);
                 if (token == next_token)
                   ThrowPointExpectedException(token,exception);
                 GetNextToken(q,&q,extent,token);
                 if (*token == ',')
                   GetNextToken(q,&q,extent,token);
                 bounds.y=(ssize_t) ceil(StringToDouble(token,&next_token)-0.5);
                 if (token == next_token)
                   ThrowPointExpectedException(token,exception);
                 GetNextToken(q,&q,extent,token);
                 if (*token == ',')
                   GetNextToken(q,&q,extent,token);
                 bounds.width=(size_t) floor(StringToDouble(token,&next_token)+
                   0.5);
                 if (token == next_token)
                   ThrowPointExpectedException(token,exception);
                 GetNextToken(q,&q,extent,token);
                 if (*token == ',')
                   GetNextToken(q,&q,extent,token);
                 bounds.height=(size_t) floor(StringToDouble(token,&next_token)+
                   0.5);
                 if (token == next_token)
                   ThrowPointExpectedException(token,exception);
                 for (p=q; *q != '\0'; )
                 {
                   GetNextToken(q,&q,extent,token);
                   if (LocaleCompare(token,"pop") != 0)
                     continue;
                   GetNextToken(q,(const char **) NULL,extent,token);
                   if (LocaleCompare(token,"pattern") != 0)
                     continue;
                   break;
                 }
                 if ((q == (char *) NULL) || (p == (char *) NULL) || ((q-4) < p))
                   {
                     status=MagickFalse;
                     break;
                   }
                 (void) CopyMagickString(token,p,(size_t) (q-p-4+1));
                 (void) FormatLocaleString(key,MagickPathExtent,"%s",name);
                 (void) SetImageArtifact(image,key,token);
                 (void) FormatLocaleString(key,MagickPathExtent,"%s-geometry",
                   name);
                 (void) FormatLocaleString(geometry,MagickPathExtent,
                   "%.20gx%.20g%+.20g%+.20g",(double) bounds.width,(double)
                   bounds.height,(double) bounds.x,(double) bounds.y);
                 (void) SetImageArtifact(image,key,geometry);
                 GetNextToken(q,&q,extent,token);
                 break;
               }
             if (LocaleCompare("symbol",token) == 0)
               {
                 symbolDepth++;
                 graphic_context[n]->render=symbolDepth > 0 ? MagickFalse :
                   MagickTrue;
                 break;
               }
             status=MagickFalse;
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'r':
       case 'R':
       {
         if (LocaleCompare("rectangle",keyword) == 0)
           {
             primitive_type=RectanglePrimitive;
             break;
           }
         if (LocaleCompare("rotate",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             angle=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             affine.sx=cos(DegreesToRadians(fmod((double) angle,360.0)));
             affine.rx=sin(DegreesToRadians(fmod((double) angle,360.0)));
             affine.ry=(-sin(DegreesToRadians(fmod((double) angle,360.0))));
             affine.sy=cos(DegreesToRadians(fmod((double) angle,360.0)));
             break;
           }
         if (LocaleCompare("roundRectangle",keyword) == 0)
           {
             primitive_type=RoundRectanglePrimitive;
             break;
           }
         status=MagickFalse;
         break;
       }
       case 's':
       case 'S':
       {
         if (LocaleCompare("scale",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             affine.sx=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             affine.sy=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             break;
           }
         if (LocaleCompare("skewX",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             angle=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             affine.ry=sin(DegreesToRadians(angle));
             break;
           }
         if (LocaleCompare("skewY",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             angle=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             affine.rx=(-tan(DegreesToRadians(angle)/2.0));
             break;
           }
         if (LocaleCompare("stop-color",keyword) == 0)
           {
             PixelInfo
               stop_color;
 
             number_stops++;
             if (number_stops == 1)
               stops=(StopInfo *) AcquireQuantumMemory(2,sizeof(*stops));
             else
               if (number_stops > 2)
                 stops=(StopInfo *) ResizeQuantumMemory(stops,number_stops,
                   sizeof(*stops));
             if (stops == (StopInfo *) NULL)
               {
                 (void) ThrowMagickException(exception,GetMagickModule(),
                   ResourceLimitError,"MemoryAllocationFailed","`%s'",
                   image->filename);
                 break;
               }
             GetNextToken(q,&q,extent,token);
             status&=QueryColorCompliance(token,AllCompliance,&stop_color,
               exception);
             stops[number_stops-1].color=stop_color;
             GetNextToken(q,&q,extent,token);
             factor=strchr(token,'%') != (char *) NULL ? 0.01 : 1.0;
             stops[number_stops-1].offset=factor*StringToDouble(token,
               &next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             break;
           }
         if (LocaleCompare("stroke",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             if (graphic_context[n]->clip_path != MagickFalse)
               break;
             (void) FormatLocaleString(pattern,MagickPathExtent,"%s",token);
             if (GetImageArtifact(image,pattern) != (const char *) NULL)
               (void) DrawPatternPath(image,draw_info,token,
                 &graphic_context[n]->stroke_pattern,exception);
             else
               {
                 status&=QueryColorCompliance(token,AllCompliance,
                   &graphic_context[n]->stroke,exception);
                 if (graphic_context[n]->stroke_alpha != OpaqueAlpha)
                   graphic_context[n]->stroke.alpha=
                     graphic_context[n]->stroke_alpha;
                }
             break;
           }
         if (LocaleCompare("stroke-antialias",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->stroke_antialias=StringToLong(token) != 0 ?
               MagickTrue : MagickFalse;
             break;
           }
         if (LocaleCompare("stroke-dasharray",keyword) == 0)
           {
             if (graphic_context[n]->dash_pattern != (double *) NULL)
               graphic_context[n]->dash_pattern=(double *)
                 RelinquishMagickMemory(graphic_context[n]->dash_pattern);
             if (IsPoint(q) != MagickFalse)
               {
                 const char
                   *r;
 
                 r=q;
                 GetNextToken(r,&r,extent,token);
                 if (*token == ',')
                   GetNextToken(r,&r,extent,token);
                 for (x=0; IsPoint(token) != MagickFalse; x++)
                 {
                   GetNextToken(r,&r,extent,token);
                   if (*token == ',')
                     GetNextToken(r,&r,extent,token);
                 }
                 graphic_context[n]->dash_pattern=(double *)
-                  AcquireQuantumMemory((size_t) (2UL*x+2UL),
+                  AcquireQuantumMemory((size_t) (2*x+2),
                   sizeof(*graphic_context[n]->dash_pattern));
                 if (graphic_context[n]->dash_pattern == (double *) NULL)
                   {
                     (void) ThrowMagickException(exception,GetMagickModule(),
                       ResourceLimitError,"MemoryAllocationFailed","`%s'",
                       image->filename);
                     status=MagickFalse;
                     break;
                   }
                 (void) memset(graphic_context[n]->dash_pattern,0,(size_t)
-                  (2UL*x+2UL)*sizeof(*graphic_context[n]->dash_pattern));
+                  (2*x+2)*sizeof(*graphic_context[n]->dash_pattern));
                 for (j=0; j < x; j++)
                 {
                   GetNextToken(q,&q,extent,token);
                   if (*token == ',')
                     GetNextToken(q,&q,extent,token);
                   graphic_context[n]->dash_pattern[j]=StringToDouble(token,
                     &next_token);
                   if (token == next_token)
                     ThrowPointExpectedException(token,exception);
                   if (graphic_context[n]->dash_pattern[j] < 0.0)
                     status=MagickFalse;
                 }
                 if ((x & 0x01) != 0)
                   for ( ; j < (2*x); j++)
                     graphic_context[n]->dash_pattern[j]=
                       graphic_context[n]->dash_pattern[j-x];
                 graphic_context[n]->dash_pattern[j]=0.0;
                 break;
               }
             GetNextToken(q,&q,extent,token);
             break;
           }
         if (LocaleCompare("stroke-dashoffset",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->dash_offset=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             break;
           }
         if (LocaleCompare("stroke-linecap",keyword) == 0)
           {
             ssize_t
               linecap;
 
             GetNextToken(q,&q,extent,token);
             linecap=ParseCommandOption(MagickLineCapOptions,MagickFalse,token);
             if (linecap == -1)
               {
                 status=MagickFalse;
                 break;
               }
             graphic_context[n]->linecap=(LineCap) linecap;
             break;
           }
         if (LocaleCompare("stroke-linejoin",keyword) == 0)
           {
             ssize_t
               linejoin;
 
             GetNextToken(q,&q,extent,token);
             linejoin=ParseCommandOption(MagickLineJoinOptions,MagickFalse,
               token);
             if (linejoin == -1)
               {
                 status=MagickFalse;
                 break;
               }
             graphic_context[n]->linejoin=(LineJoin) linejoin;
             break;
           }
         if (LocaleCompare("stroke-miterlimit",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->miterlimit=StringToUnsignedLong(token);
             break;
           }
         if (LocaleCompare("stroke-opacity",keyword) == 0)
           {
             double
               opacity;
 
             GetNextToken(q,&q,extent,token);
             if (graphic_context[n]->clip_path != MagickFalse)
               break;
             factor=strchr(token,'%') != (char *) NULL ? 0.01 : 1.0;
             opacity=MagickMin(MagickMax(factor*
               StringToDouble(token,&next_token),0.0),1.0);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             graphic_context[n]->stroke_alpha*=opacity;
             if (graphic_context[n]->stroke_alpha != OpaqueAlpha)
               graphic_context[n]->stroke.alpha=graphic_context[n]->stroke_alpha;
             break;
           }
         if (LocaleCompare("stroke-width",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             if (graphic_context[n]->clip_path != MagickFalse)
               break;
             graphic_context[n]->stroke_width=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             break;
           }
         status=MagickFalse;
         break;
       }
       case 't':
       case 'T':
       {
         if (LocaleCompare("text",keyword) == 0)
           {
             primitive_type=TextPrimitive;
             break;
           }
         if (LocaleCompare("text-align",keyword) == 0)
           {
             ssize_t
               align;
 
             GetNextToken(q,&q,extent,token);
             align=ParseCommandOption(MagickAlignOptions,MagickFalse,token);
             if (align == -1)
               {
                 status=MagickFalse;
                 break;
               }
             graphic_context[n]->align=(AlignType) align;
             break;
           }
         if (LocaleCompare("text-anchor",keyword) == 0)
           {
             ssize_t
               align;
 
             GetNextToken(q,&q,extent,token);
             align=ParseCommandOption(MagickAlignOptions,MagickFalse,token);
             if (align == -1)
               {
                 status=MagickFalse;
                 break;
               }
             graphic_context[n]->align=(AlignType) align;
             break;
           }
         if (LocaleCompare("text-antialias",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->text_antialias=StringToLong(token) != 0 ?
               MagickTrue : MagickFalse;
             break;
           }
         if (LocaleCompare("text-undercolor",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             status&=QueryColorCompliance(token,AllCompliance,
               &graphic_context[n]->undercolor,exception);
             break;
           }
         if (LocaleCompare("translate",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             affine.tx=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             affine.ty=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             cursor=0.0;
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'u':
       case 'U':
       {
         if (LocaleCompare("use",keyword) == 0)
           {
             const char
               *use;
 
             /*
               Get a macro from the MVG document, and "use" it here.
             */
             GetNextToken(q,&q,extent,token);
             use=(const char *) GetValueFromSplayTree(macros,token);
             if (use != (const char *) NULL)
               {
                 DrawInfo
                   *clone_info;
 
                 clone_info=CloneDrawInfo((ImageInfo *) NULL,graphic_context[n]);
                 (void) CloneString(&clone_info->primitive,use);
                 status=DrawImage(image,clone_info,exception);
                 clone_info=DestroyDrawInfo(clone_info);
               }
             break;
           }
         break;
       }
       case 'v':
       case 'V':
       {
         if (LocaleCompare("viewbox",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->viewbox.x=(ssize_t) ceil(StringToDouble(token,
               &next_token)-0.5);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             graphic_context[n]->viewbox.y=(ssize_t) ceil(StringToDouble(token,
               &next_token)-0.5);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             graphic_context[n]->viewbox.width=(size_t) floor(StringToDouble(
               token,&next_token)+0.5);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             graphic_context[n]->viewbox.height=(size_t) floor(StringToDouble(
               token,&next_token)+0.5);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             break;
           }
         status=MagickFalse;
         break;
       }
       default:
       {
         status=MagickFalse;
         break;
       }
     }
     if (status == MagickFalse)
       break;
     if ((fabs(affine.sx-1.0) >= MagickEpsilon) ||
         (fabs(affine.rx) >= MagickEpsilon) || (fabs(affine.ry) >= MagickEpsilon) ||
         (fabs(affine.sy-1.0) >= MagickEpsilon) ||
         (fabs(affine.tx) >= MagickEpsilon) || (fabs(affine.ty) >= MagickEpsilon))
       {
         graphic_context[n]->affine.sx=current.sx*affine.sx+current.ry*affine.rx;
         graphic_context[n]->affine.rx=current.rx*affine.sx+current.sy*affine.rx;
         graphic_context[n]->affine.ry=current.sx*affine.ry+current.ry*affine.sy;
         graphic_context[n]->affine.sy=current.rx*affine.ry+current.sy*affine.sy;
         graphic_context[n]->affine.tx=current.sx*affine.tx+current.ry*affine.ty+
           current.tx;
         graphic_context[n]->affine.ty=current.rx*affine.tx+current.sy*affine.ty+
           current.ty;
       }
     if (primitive_type == UndefinedPrimitive)
       {
         if (*q == '\0')
           {
             if (number_stops > 1)
               {
                 GradientType
                   type;
 
               type=LinearGradient;
               if (draw_info->gradient.type == RadialGradient)
                 type=RadialGradient;
               (void) GradientImage(image,type,PadSpread,stops,number_stops,
                 exception);
              }
            if (number_stops > 0)
              stops=(StopInfo *) RelinquishMagickMemory(stops);
           }
         if ((image->debug != MagickFalse) && (q > p))
           (void) LogMagickEvent(DrawEvent,GetMagickModule(),"  %.*s",(int)
             (q-p-1),p);
         continue;
       }
     /*
       Parse the primitive attributes.
     */
     i=0;
     mvg_info.offset=i;
     j=0;
     primitive_info[0].point.x=0.0;
     primitive_info[0].point.y=0.0;
     primitive_info[0].coordinates=0;
     primitive_info[0].method=FloodfillMethod;
     primitive_info[0].closed_subpath=MagickFalse;
     for (x=0; *q != '\0'; x++)
     {
       /*
         Define points.
       */
       if (IsPoint(q) == MagickFalse)
         break;
       GetNextToken(q,&q,extent,token);
       point.x=StringToDouble(token,&next_token);
       if (token == next_token)
         ThrowPointExpectedException(token,exception);
       GetNextToken(q,&q,extent,token);
       if (*token == ',')
         GetNextToken(q,&q,extent,token);
       point.y=StringToDouble(token,&next_token);
       if (token == next_token)
         ThrowPointExpectedException(token,exception);
       GetNextToken(q,(const char **) NULL,extent,token);
       if (*token == ',')
         GetNextToken(q,&q,extent,token);
       primitive_info[i].primitive=primitive_type;
       primitive_info[i].point=point;
       primitive_info[i].coordinates=0;
       primitive_info[i].method=FloodfillMethod;
       primitive_info[i].closed_subpath=MagickFalse;
       i++;
       mvg_info.offset=i;
       if (i < (ssize_t) number_points)
         continue;
       status&=CheckPrimitiveExtent(&mvg_info,number_points);
     }
     if (status == MagickFalse)
       break;
     primitive_info[j].primitive=primitive_type;
     primitive_info[j].coordinates=(size_t) x;
     primitive_info[j].method=FloodfillMethod;
     primitive_info[j].closed_subpath=MagickFalse;
     primitive_info[j].text=(char *) NULL;
     /*
       Circumscribe primitive within a circle.
     */
     bounds.x1=primitive_info[j].point.x;
     bounds.y1=primitive_info[j].point.y;
     bounds.x2=primitive_info[j].point.x;
     bounds.y2=primitive_info[j].point.y;
     for (k=1; k < (ssize_t) primitive_info[j].coordinates; k++)
     {
       point=primitive_info[j+k].point;
       if (point.x < bounds.x1)
         bounds.x1=point.x;
       if (point.y < bounds.y1)
         bounds.y1=point.y;
       if (point.x > bounds.x2)
         bounds.x2=point.x;
       if (point.y > bounds.y2)
         bounds.y2=point.y;
     }
     /*
       Speculate how many points our primitive might consume.
     */
     coordinates=(double) primitive_info[j].coordinates;
     switch (primitive_type)
     {
       case RectanglePrimitive:
       {
         coordinates*=5.0;
         break;
       }
       case RoundRectanglePrimitive:
       {
         double
           alpha,
           beta,
           radius;
 
         alpha=bounds.x2-bounds.x1;
         beta=bounds.y2-bounds.y1;
         radius=hypot((double) alpha,(double) beta);
         coordinates*=5.0;
         coordinates+=2.0*((size_t) ceil((double) MagickPI*radius))+6.0*
           BezierQuantum+360.0;
         break;
       }
       case BezierPrimitive:
       {
         coordinates=(double) (BezierQuantum*primitive_info[j].coordinates);
         if (primitive_info[j].coordinates > (107*BezierQuantum))
           {
             (void) ThrowMagickException(exception,GetMagickModule(),DrawError,
               "TooManyBezierCoordinates","`%s'",token);
             status=MagickFalse;
             break;
           }
         break;
       }
       case PathPrimitive:
       {
         char
           *s,
           *t;
 
         GetNextToken(q,&q,extent,token);
         coordinates=1.0;
         t=token;
         for (s=token; *s != '\0'; s=t)
         {
           double
             value;
 
           value=StringToDouble(s,&t);
           (void) value;
           if (s == t)
             {
               t++;
               continue;
             }
           coordinates++;
         }
         for (s=token; *s != '\0'; s++)
           if (strspn(s,"AaCcQqSsTt") != 0)
             coordinates+=(20.0*BezierQuantum)+360.0;
         break;
       }
       case CirclePrimitive:
       case ArcPrimitive:
       case EllipsePrimitive:
       {
         double
           alpha,
           beta,
           radius;
 
         alpha=bounds.x2-bounds.x1;
         beta=bounds.y2-bounds.y1;
         radius=hypot(alpha,beta);
         coordinates=2.0*(ceil(MagickPI*radius))+6.0*BezierQuantum+360.0;
         if (coordinates > (107*BezierQuantum))
           {
             (void) ThrowMagickException(exception,GetMagickModule(),DrawError,
               "TooManyBezierCoordinates","`%s'",token);
             status=MagickFalse;
           }
         break;
       }
       default:
         break;
     }
     if (coordinates > MaxBezierCoordinates)
       {
         (void) ThrowMagickException(exception,GetMagickModule(),
           ResourceLimitError,"MemoryAllocationFailed","`%s'",token);
         status=MagickFalse;
       }
     if (status == MagickFalse)
       break;
     if (((size_t) (i+coordinates)) >= number_points)
       {
         /*
           Resize based on speculative points required by primitive.
         */
         number_points+=coordinates+1;
         if (number_points < (size_t) coordinates)
           {
             (void) ThrowMagickException(exception,GetMagickModule(),
               ResourceLimitError,"MemoryAllocationFailed","`%s'",
               image->filename);
             break;
           }
         mvg_info.offset=i;
         status&=CheckPrimitiveExtent(&mvg_info,number_points);
       }
     status&=CheckPrimitiveExtent(&mvg_info,4096);
     if (status == MagickFalse)
       break;
     mvg_info.offset=j;
     switch (primitive_type)
     {
       case PointPrimitive:
       default:
       {
         if (primitive_info[j].coordinates != 1)
           {
             status=MagickFalse;
             break;
           }
         TracePoint(primitive_info+j,primitive_info[j].point);
         i=(ssize_t) (j+primitive_info[j].coordinates);
         break;
       }
       case LinePrimitive:
       {
         if (primitive_info[j].coordinates != 2)
           {
             status=MagickFalse;
             break;
           }
         TraceLine(primitive_info+j,primitive_info[j].point,
           primitive_info[j+1].point);
         i=(ssize_t) (j+primitive_info[j].coordinates);
         break;
       }
       case RectanglePrimitive:
       {
         if (primitive_info[j].coordinates != 2)
           {
             status=MagickFalse;
             break;
           }
         TraceRectangle(primitive_info+j,primitive_info[j].point,
           primitive_info[j+1].point);
         i=(ssize_t) (j+primitive_info[j].coordinates);
         break;
       }
       case RoundRectanglePrimitive:
       {
         if (primitive_info[j].coordinates != 3)
           {
             status=MagickFalse;
             break;
           }
         if ((primitive_info[j+2].point.x < 0.0) ||
             (primitive_info[j+2].point.y < 0.0))
           {
             status=MagickFalse;
             break;
           }
         if ((primitive_info[j+1].point.x-primitive_info[j].point.x) < 0.0)
           {
             status=MagickFalse;
             break;
           }
         if ((primitive_info[j+1].point.y-primitive_info[j].point.y) < 0.0)
           {
             status=MagickFalse;
             break;
           }
         TraceRoundRectangle(&mvg_info,primitive_info[j].point,
           primitive_info[j+1].point,primitive_info[j+2].point);
         i=(ssize_t) (j+primitive_info[j].coordinates);
         break;
       }
       case ArcPrimitive:
       {
         if (primitive_info[j].coordinates != 3)
           {
             primitive_type=UndefinedPrimitive;
             break;
           }
         TraceArc(&mvg_info,primitive_info[j].point,primitive_info[j+1].point,
           primitive_info[j+2].point);
         i=(ssize_t) (j+primitive_info[j].coordinates);
         break;
       }
       case EllipsePrimitive:
       {
         if (primitive_info[j].coordinates != 3)
           {
             status=MagickFalse;
             break;
           }
         if ((primitive_info[j+1].point.x < 0.0) ||
             (primitive_info[j+1].point.y < 0.0))
           {
             status=MagickFalse;
             break;
           }
         TraceEllipse(&mvg_info,primitive_info[j].point,
           primitive_info[j+1].point,primitive_info[j+2].point);
         i=(ssize_t) (j+primitive_info[j].coordinates);
         break;
       }
       case CirclePrimitive:
       {
         if (primitive_info[j].coordinates != 2)
           {
             status=MagickFalse;
             break;
           }
         TraceCircle(&mvg_info,primitive_info[j].point,
           primitive_info[j+1].point);
         i=(ssize_t) (j+primitive_info[j].coordinates);
         break;
       }
       case PolylinePrimitive:
       {
         if (primitive_info[j].coordinates < 1)
           {
             status=MagickFalse;
             break;
           }
         break;
       }
       case PolygonPrimitive:
       {
         if (primitive_info[j].coordinates < 3)
           {
             status=MagickFalse;
             break;
           }
         primitive_info[i]=primitive_info[j];
         primitive_info[i].coordinates=0;
         primitive_info[j].coordinates++;
         primitive_info[j].closed_subpath=MagickTrue;
         i++;
         break;
       }
       case BezierPrimitive:
       {
         if (primitive_info[j].coordinates < 3)
           {
             status=MagickFalse;
             break;
           }
         TraceBezier(&mvg_info,primitive_info[j].coordinates);
         i=(ssize_t) (j+primitive_info[j].coordinates);
         break;
       }
       case PathPrimitive:
       {
         coordinates=(double) TracePath(&mvg_info,token,exception);
         if (coordinates == 0.0)
           {
             status=MagickFalse;
             break;
           }
         i=(ssize_t) (j+coordinates);
         break;
       }
       case AlphaPrimitive:
       case ColorPrimitive:
       {
         ssize_t
           method;
 
         if (primitive_info[j].coordinates != 1)
           {
             status=MagickFalse;
             break;
           }
         GetNextToken(q,&q,extent,token);
         method=ParseCommandOption(MagickMethodOptions,MagickFalse,token);
         if (method == -1)
           {
             status=MagickFalse;
             break;
           }
         primitive_info[j].method=(PaintMethod) method;
         break;
       }
       case TextPrimitive:
       {
         char
           geometry[MagickPathExtent];
 
         DrawInfo
           *clone_info;
 
         TypeMetric
           metrics;
 
         if (primitive_info[j].coordinates != 1)
           {
             status=MagickFalse;
             break;
           }
         if (*token != ',')
           GetNextToken(q,&q,extent,token);
         (void) CloneString(&primitive_info[j].text,token);
         /*
           Compute text cursor offset.
         */
         clone_info=CloneDrawInfo((ImageInfo *) NULL,graphic_context[n]);
         if ((fabs(primitive_info->point.x) < MagickEpsilon) &&
             (fabs(primitive_info->point.y) < MagickEpsilon))
           primitive_info->point.x+=cursor;
         (void) FormatLocaleString(geometry,MagickPathExtent,"%+f%+f",
           primitive_info->point.x,primitive_info->point.y);
         clone_info->render=MagickFalse;
         clone_info->text=AcquireString(token);
         (void) ConcatenateString(&clone_info->text," ");
         status&=GetTypeMetrics(image,clone_info,&metrics,exception);
         clone_info=DestroyDrawInfo(clone_info);
         cursor+=metrics.width;
         break;
       }
       case ImagePrimitive:
       {
         if (primitive_info[j].coordinates != 2)
           {
             status=MagickFalse;
             break;
           }
         GetNextToken(q,&q,extent,token);
         (void) CloneString(&primitive_info[j].text,token);
         break;
       }
     }
     mvg_info.offset=i;
     if (primitive_info == (PrimitiveInfo *) NULL)
       break;
     if ((image->debug != MagickFalse) && (q > p))
       (void) LogMagickEvent(DrawEvent,GetMagickModule(),"  %.*s",(int) (q-p-1),
         p);
     if (status == MagickFalse)
       break;
     primitive_info[i].primitive=UndefinedPrimitive;
     if (i == 0)
       continue;
     /*
       Transform points.
     */
     for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++)
     {
       point=primitive_info[i].point;
       primitive_info[i].point.x=graphic_context[n]->affine.sx*point.x+
         graphic_context[n]->affine.ry*point.y+graphic_context[n]->affine.tx;
       primitive_info[i].point.y=graphic_context[n]->affine.rx*point.x+
         graphic_context[n]->affine.sy*point.y+graphic_context[n]->affine.ty;
       point=primitive_info[i].point;
       if (point.x < graphic_context[n]->bounds.x1)
         graphic_context[n]->bounds.x1=point.x;
       if (point.y < graphic_context[n]->bounds.y1)
         graphic_context[n]->bounds.y1=point.y;
       if (point.x > graphic_context[n]->bounds.x2)
         graphic_context[n]->bounds.x2=point.x;
       if (point.y > graphic_context[n]->bounds.y2)
         graphic_context[n]->bounds.y2=point.y;
       if (primitive_info[i].primitive == ImagePrimitive)
         break;
       if (i >= (ssize_t) number_points)
         ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
     }
     if (graphic_context[n]->render != MagickFalse)
       {
         if ((n != 0) && (draw_info->compliance != SVGCompliance) &&
             (graphic_context[n]->clip_mask != (char *) NULL) &&
             (LocaleCompare(graphic_context[n]->clip_mask,
              graphic_context[n-1]->clip_mask) != 0))
           status&=DrawClipPath(image,graphic_context[n],
             graphic_context[n]->clip_mask,exception);
         status&=DrawPrimitive(image,graphic_context[n],primitive_info,
           exception);
       }
     proceed=SetImageProgress(image,RenderImageTag,q-primitive,(MagickSizeType)
       primitive_extent);
     if (proceed == MagickFalse)
       break;
     if (status == 0)
       break;
   }
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(DrawEvent,GetMagickModule(),"end draw-image");
   /*
     Relinquish resources.
   */
   macros=DestroySplayTree(macros);
   token=DestroyString(token);
   if (primitive_info != (PrimitiveInfo *) NULL)
     {
       for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++)
         if ((primitive_info[i].primitive == TextPrimitive) ||
             (primitive_info[i].primitive == ImagePrimitive))
           if (primitive_info[i].text != (char *) NULL)
             primitive_info[i].text=DestroyString(primitive_info[i].text);
       primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(primitive_info);
     }
   primitive=DestroyString(primitive);
   if (stops != (StopInfo *) NULL)
     stops=(StopInfo *) RelinquishMagickMemory(stops);
   for ( ; n >= 0; n--)
     graphic_context[n]=DestroyDrawInfo(graphic_context[n]);
   graphic_context=(DrawInfo **) RelinquishMagickMemory(graphic_context);
   if (status == MagickFalse)
     ThrowBinaryException(DrawError,"NonconformingDrawingPrimitiveDefinition",
       keyword);
   return(status != 0 ? MagickTrue : MagickFalse);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   D r a w P a t t e r n P a t h                                             %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  DrawPatternPath() draws a pattern.
 %
 %  The format of the DrawPatternPath method is:
 %
 %      MagickBooleanType DrawPatternPath(Image *image,const DrawInfo *draw_info,
 %        const char *name,Image **pattern,ExceptionInfo *exception)
 %
 %  A description of each parameter follows:
 %
 %    o image: the image.
 %
 %    o draw_info: the draw info.
 %
 %    o name: the pattern name.
 %
 %    o image: the image.
 %
 %    o exception: return any errors or warnings in this structure.
 %
 */
diff --git a/coders/miff.c b/coders/miff.c
index 8ba78ca6e..7d8ceaccd 100644
--- a/coders/miff.c
+++ b/coders/miff.c
@@ -414,1325 +414,1330 @@ static void RelinquishZIPMemory(voidpf context,voidpf memory)
 static Image *ReadMIFFImage(const ImageInfo *image_info,
   ExceptionInfo *exception)
 {
 #define BZipMaxExtent(x)  ((x)+((x)/100)+600)
 #define LZMAMaxExtent(x)  ((x)+((x)/3)+128)
 #define ThrowMIFFException(exception,message) \
 { \
   if (quantum_info != (QuantumInfo *) NULL) \
     quantum_info=DestroyQuantumInfo(quantum_info); \
   if (compress_pixels != (unsigned char *) NULL) \
     compress_pixels=(unsigned char *) RelinquishMagickMemory(compress_pixels); \
   ThrowReaderException((exception),(message)); \
 }
 #define ZipMaxExtent(x)  ((x)+(((x)+7) >> 3)+(((x)+63) >> 6)+11)
 
 #if defined(MAGICKCORE_BZLIB_DELEGATE)
   bz_stream
     bzip_info;
 #endif
 
   char
     id[MagickPathExtent],
     keyword[MagickPathExtent],
     *options;
 
   double
     version;
 
   GeometryInfo
     geometry_info;
 
   Image
     *image;
 
   int
     c;
 
   LinkedListInfo
     *profiles;
 
 #if defined(MAGICKCORE_LZMA_DELEGATE)
   lzma_stream
     initialize_lzma = LZMA_STREAM_INIT,
     lzma_info;
 
   lzma_allocator
     allocator;
 #endif
 
   MagickBooleanType
     status;
 
   PixelInfo
     pixel;
 
   MagickStatusType
     flags;
 
   QuantumFormatType
     quantum_format;
 
   QuantumInfo
     *quantum_info;
 
   QuantumType
     quantum_type;
 
   register ssize_t
     i;
 
   size_t
     compress_extent,
+    extent,
     length,
     packet_size;
 
   ssize_t
     count;
 
   unsigned char
     *compress_pixels,
     *pixels;
 
   size_t
     colors;
 
   ssize_t
     y;
 
 #if defined(MAGICKCORE_ZLIB_DELEGATE)
   z_stream
     zip_info;
 #endif
 
   /*
     Open image file.
   */
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickCoreSignature);
   if (image_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",
       image_info->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickCoreSignature);
   image=AcquireImage(image_info,exception);
   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
   if (status == MagickFalse)
     {
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
   /*
     Decode image header;  header terminates one character beyond a ':'.
   */
   c=ReadBlobByte(image);
   if (c == EOF)
     ThrowReaderException(CorruptImageError,"ImproperImageHeader");
   *id='\0';
   compress_pixels=(unsigned char *) NULL;
   quantum_info=(QuantumInfo *) NULL;
   (void) memset(keyword,0,sizeof(keyword));
   version=0.0;
   (void) version;
   do
   {
     /*
       Decode image header;  header terminates one character beyond a ':'.
     */
     SetGeometryInfo(&geometry_info);
     length=MagickPathExtent;
     options=AcquireString((char *) NULL);
     quantum_format=UndefinedQuantumFormat;
     profiles=(LinkedListInfo *) NULL;
     colors=0;
     image->depth=8UL;
     image->compression=NoCompression;
     while ((isgraph(c) != MagickFalse) && (c != (int) ':'))
     {
       register char
         *p;
 
       if (c == (int) '{')
         {
           char
             *comment;
 
           /*
             Read comment-- any text between { }.
           */
           length=MagickPathExtent;
           comment=AcquireString((char *) NULL);
           for (p=comment; comment != (char *) NULL; p++)
           {
             c=ReadBlobByte(image);
             if (c == (int) '\\')
               c=ReadBlobByte(image);
             else
               if ((c == EOF) || (c == (int) '}'))
                 break;
             if ((size_t) (p-comment+1) >= length)
               {
                 *p='\0';
                 length<<=1;
                 comment=(char *) ResizeQuantumMemory(comment,length+
                   MagickPathExtent,sizeof(*comment));
                 if (comment == (char *) NULL)
                   break;
                 p=comment+strlen(comment);
               }
             *p=(char) c;
           }
           if (comment == (char *) NULL)
             {
               options=DestroyString(options);
               ThrowMIFFException(ResourceLimitError,"MemoryAllocationFailed");
             }
           *p='\0';
           (void) SetImageProperty(image,"comment",comment,exception);
           comment=DestroyString(comment);
           c=ReadBlobByte(image);
         }
       else
         if (isalnum(c) != MagickFalse)
           {
             /*
               Get the keyword.
             */
             length=MagickPathExtent-1;
             p=keyword;
             do
             {
               if (c == (int) '=')
                 break;
               if ((size_t) (p-keyword) < (MagickPathExtent-1))
                 *p++=(char) c;
               c=ReadBlobByte(image);
             } while (c != EOF);
             *p='\0';
             p=options;
             while ((isspace((int) ((unsigned char) c)) != 0) && (c != EOF))
               c=ReadBlobByte(image);
             if (c == (int) '=')
               {
                 /*
                   Get the keyword value.
                 */
                 c=ReadBlobByte(image);
                 while ((c != (int) '}') && (c != EOF))
                 {
                   if ((size_t) (p-options+1) >= length)
                     {
                       *p='\0';
                       length<<=1;
                       options=(char *) ResizeQuantumMemory(options,length+
                         MagickPathExtent,sizeof(*options));
                       if (options == (char *) NULL)
                         break;
                       p=options+strlen(options);
                     }
                   *p++=(char) c;
                   c=ReadBlobByte(image);
                   if (c == '\\')
                     {
                       c=ReadBlobByte(image);
                       if (c == (int) '}')
                         {
                           *p++=(char) c;
                           c=ReadBlobByte(image);
                         }
                     }
                   if (*options != '{')
                     if (isspace((int) ((unsigned char) c)) != 0)
                       break;
                 }
                 if (options == (char *) NULL)
                   ThrowMIFFException(ResourceLimitError,
                     "MemoryAllocationFailed");
               }
             *p='\0';
             if (*options == '{')
               (void) CopyMagickString(options,options+1,strlen(options));
             /*
               Assign a value to the specified keyword.
             */
             switch (*keyword)
             {
               case 'a':
               case 'A':
               {
                 if (LocaleCompare(keyword,"alpha-trait") == 0)
                   {
                     ssize_t
                       alpha_trait;
 
                     alpha_trait=ParseCommandOption(MagickPixelTraitOptions,
                       MagickFalse,options);
                     if (alpha_trait < 0)
                       break;
                     image->alpha_trait=(PixelTrait) alpha_trait;
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               case 'b':
               case 'B':
               {
                 if (LocaleCompare(keyword,"background-color") == 0)
                   {
                     (void) QueryColorCompliance(options,AllCompliance,
                       &image->background_color,exception);
                     break;
                   }
                 if (LocaleCompare(keyword,"blue-primary") == 0)
                   {
                     flags=ParseGeometry(options,&geometry_info);
                     image->chromaticity.blue_primary.x=geometry_info.rho;
                     image->chromaticity.blue_primary.y=geometry_info.sigma;
                     if ((flags & SigmaValue) == 0)
                       image->chromaticity.blue_primary.y=
                         image->chromaticity.blue_primary.x;
                     break;
                   }
                 if (LocaleCompare(keyword,"border-color") == 0)
                   {
                     (void) QueryColorCompliance(options,AllCompliance,
                       &image->border_color,exception);
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               case 'c':
               case 'C':
               {
                 if (LocaleCompare(keyword,"class") == 0)
                   {
                     ssize_t
                       storage_class;
 
                     storage_class=ParseCommandOption(MagickClassOptions,
                       MagickFalse,options);
                     if (storage_class < 0)
                       break;
                     image->storage_class=(ClassType) storage_class;
                     break;
                   }
                 if (LocaleCompare(keyword,"colors") == 0)
                   {
                     colors=StringToUnsignedLong(options);
                     break;
                   }
                 if (LocaleCompare(keyword,"colorspace") == 0)
                   {
                     ssize_t
                       colorspace;
 
                     colorspace=ParseCommandOption(MagickColorspaceOptions,
                       MagickFalse,options);
                     if (colorspace < 0)
                       break;
                     image->colorspace=(ColorspaceType) colorspace;
                     break;
                   }
                 if (LocaleCompare(keyword,"compression") == 0)
                   {
                     ssize_t
                       compression;
 
                     compression=ParseCommandOption(MagickCompressOptions,
                       MagickFalse,options);
                     if (compression < 0)
                       break;
                     image->compression=(CompressionType) compression;
                     break;
                   }
                 if (LocaleCompare(keyword,"columns") == 0)
                   {
                     image->columns=StringToUnsignedLong(options);
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               case 'd':
               case 'D':
               {
                 if (LocaleCompare(keyword,"delay") == 0)
                   {
                     image->delay=StringToUnsignedLong(options);
                     break;
                   }
                 if (LocaleCompare(keyword,"depth") == 0)
                   {
                     image->depth=StringToUnsignedLong(options);
                     break;
                   }
                 if (LocaleCompare(keyword,"dispose") == 0)
                   {
                     ssize_t
                       dispose;
 
                     dispose=ParseCommandOption(MagickDisposeOptions,MagickFalse,
                       options);
                     if (dispose < 0)
                       break;
                     image->dispose=(DisposeType) dispose;
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               case 'e':
               case 'E':
               {
                 if (LocaleCompare(keyword,"endian") == 0)
                   {
                     ssize_t
                       endian;
 
                     endian=ParseCommandOption(MagickEndianOptions,MagickFalse,
                       options);
                     if (endian < 0)
                       break;
                     image->endian=(EndianType) endian;
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               case 'g':
               case 'G':
               {
                 if (LocaleCompare(keyword,"gamma") == 0)
                   {
                     image->gamma=StringToDouble(options,(char **) NULL);
                     break;
                   }
                 if (LocaleCompare(keyword,"gravity") == 0)
                   {
                     ssize_t
                       gravity;
 
                     gravity=ParseCommandOption(MagickGravityOptions,MagickFalse,
                       options);
                     if (gravity < 0)
                       break;
                     image->gravity=(GravityType) gravity;
                     break;
                   }
                 if (LocaleCompare(keyword,"green-primary") == 0)
                   {
                     flags=ParseGeometry(options,&geometry_info);
                     image->chromaticity.green_primary.x=geometry_info.rho;
                     image->chromaticity.green_primary.y=geometry_info.sigma;
                     if ((flags & SigmaValue) == 0)
                       image->chromaticity.green_primary.y=
                         image->chromaticity.green_primary.x;
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               case 'i':
               case 'I':
               {
                 if (LocaleCompare(keyword,"id") == 0)
                   {
                     (void) CopyMagickString(id,options,MagickPathExtent);
                     break;
                   }
                 if (LocaleCompare(keyword,"iterations") == 0)
                   {
                     image->iterations=StringToUnsignedLong(options);
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               case 'm':
               case 'M':
               {
                 if (LocaleCompare(keyword,"matte") == 0)
                   {
                     ssize_t
                       matte;
 
                     matte=ParseCommandOption(MagickBooleanOptions,MagickFalse,
                       options);
                     if (matte < 0)
                       break;
                     image->alpha_trait=matte == 0 ? UndefinedPixelTrait :
                       BlendPixelTrait;
                     break;
                   }
                 if (LocaleCompare(keyword,"mattecolor") == 0)
                   {
                     (void) QueryColorCompliance(options,AllCompliance,
                       &image->matte_color,exception);
                     break;
                   }
                 if (LocaleCompare(keyword,"montage") == 0)
                   {
                     (void) CloneString(&image->montage,options);
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               case 'o':
               case 'O':
               {
                 if (LocaleCompare(keyword,"orientation") == 0)
                   {
                     ssize_t
                       orientation;
 
                     orientation=ParseCommandOption(MagickOrientationOptions,
                       MagickFalse,options);
                     if (orientation < 0)
                       break;
                     image->orientation=(OrientationType) orientation;
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               case 'p':
               case 'P':
               {
                 if (LocaleCompare(keyword,"page") == 0)
                   {
                     char
                       *geometry;
 
                     geometry=GetPageGeometry(options);
                     (void) ParseAbsoluteGeometry(geometry,&image->page);
                     geometry=DestroyString(geometry);
                     break;
                   }
                 if (LocaleCompare(keyword,"pixel-intensity") == 0)
                   {
                     ssize_t
                       intensity;
 
                     intensity=ParseCommandOption(MagickPixelIntensityOptions,
                       MagickFalse,options);
                     if (intensity < 0)
                       break;
                     image->intensity=(PixelIntensityMethod) intensity;
                     break;
                   }
                 if (LocaleCompare(keyword,"profile") == 0)
                   {
                     if (profiles == (LinkedListInfo *) NULL)
                       profiles=NewLinkedList(0);
                     (void) AppendValueToLinkedList(profiles,
                       AcquireString(options));
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               case 'q':
               case 'Q':
               {
                 if (LocaleCompare(keyword,"quality") == 0)
                   {
                     image->quality=StringToUnsignedLong(options);
                     break;
                   }
                 if ((LocaleCompare(keyword,"quantum-format") == 0) ||
                     (LocaleCompare(keyword,"quantum:format") == 0))
                   {
                     ssize_t
                       format;
 
                     format=ParseCommandOption(MagickQuantumFormatOptions,
                       MagickFalse,options);
                     if (format < 0)
                       break;
                     quantum_format=(QuantumFormatType) format;
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               case 'r':
               case 'R':
               {
                 if (LocaleCompare(keyword,"red-primary") == 0)
                   {
                     flags=ParseGeometry(options,&geometry_info);
                     image->chromaticity.red_primary.x=geometry_info.rho;
                     image->chromaticity.red_primary.y=geometry_info.sigma;
                     if ((flags & SigmaValue) == 0)
                       image->chromaticity.red_primary.y=
                         image->chromaticity.red_primary.x;
                     break;
                   }
                 if (LocaleCompare(keyword,"rendering-intent") == 0)
                   {
                     ssize_t
                       rendering_intent;
 
                     rendering_intent=ParseCommandOption(MagickIntentOptions,
                       MagickFalse,options);
                     if (rendering_intent < 0)
                       break;
                     image->rendering_intent=(RenderingIntent) rendering_intent;
                     break;
                   }
                 if (LocaleCompare(keyword,"resolution") == 0)
                   {
                     flags=ParseGeometry(options,&geometry_info);
                     image->resolution.x=geometry_info.rho;
                     image->resolution.y=geometry_info.sigma;
                     if ((flags & SigmaValue) == 0)
                       image->resolution.y=image->resolution.x;
                     break;
                   }
                 if (LocaleCompare(keyword,"rows") == 0)
                   {
                     image->rows=StringToUnsignedLong(options);
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               case 's':
               case 'S':
               {
                 if (LocaleCompare(keyword,"scene") == 0)
                   {
                     image->scene=StringToUnsignedLong(options);
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               case 't':
               case 'T':
               {
                 if (LocaleCompare(keyword,"ticks-per-second") == 0)
                   {
                     image->ticks_per_second=(ssize_t) StringToLong(options);
                     break;
                   }
                 if (LocaleCompare(keyword,"tile-offset") == 0)
                   {
                     char
                       *geometry;
 
                     geometry=GetPageGeometry(options);
                     (void) ParseAbsoluteGeometry(geometry,&image->tile_offset);
                     geometry=DestroyString(geometry);
                     break;
                   }
                 if (LocaleCompare(keyword,"type") == 0)
                   {
                     ssize_t
                       type;
 
                     type=ParseCommandOption(MagickTypeOptions,MagickFalse,
                       options);
                     if (type < 0)
                       break;
                     image->type=(ImageType) type;
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               case 'u':
               case 'U':
               {
                 if (LocaleCompare(keyword,"units") == 0)
                   {
                     ssize_t
                       units;
 
                     units=ParseCommandOption(MagickResolutionOptions,
                       MagickFalse,options);
                     if (units < 0)
                       break;
                     image->units=(ResolutionType) units;
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               case 'v':
               case 'V':
               {
                 if (LocaleCompare(keyword,"version") == 0)
                   {
                     version=StringToDouble(options,(char **) NULL);
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               case 'w':
               case 'W':
               {
                 if (LocaleCompare(keyword,"white-point") == 0)
                   {
                     flags=ParseGeometry(options,&geometry_info);
                     image->chromaticity.white_point.x=geometry_info.rho;
                     image->chromaticity.white_point.y=geometry_info.sigma;
                     if ((flags & SigmaValue) == 0)
                       image->chromaticity.white_point.y=
                         image->chromaticity.white_point.x;
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               default:
               {
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
             }
           }
         else
           c=ReadBlobByte(image);
       while (isspace((int) ((unsigned char) c)) != 0)
         c=ReadBlobByte(image);
     }
     options=DestroyString(options);
     (void) ReadBlobByte(image);
     /*
       Verify that required image information is defined.
     */
     if ((LocaleCompare(id,"ImageMagick") != 0) || (image->depth > 64) ||
         (image->storage_class == UndefinedClass) ||
         (image->compression == UndefinedCompression) ||
         (image->colorspace == UndefinedColorspace) ||
         (image->columns == 0) || (image->rows == 0))
       {
         if (profiles != (LinkedListInfo *) NULL)
           profiles=DestroyLinkedList(profiles,RelinquishMagickMemory);
         if (image->previous == (Image *) NULL)
           ThrowMIFFException(CorruptImageError,"ImproperImageHeader");
         DeleteImageFromList(&image);
         (void) ThrowMagickException(exception,GetMagickModule(),
           CorruptImageError,"ImproperImageHeader","`%s'",image->filename);
         break;
       }
     if (image->montage != (char *) NULL)
       {
         register char
           *p;
 
         /*
           Image directory.
         */
         length=MagickPathExtent;
         image->directory=AcquireString((char *) NULL);
         p=image->directory;
         do
         {
           *p='\0';
           if ((strlen(image->directory)+MagickPathExtent) >= length)
             {
               /*
                 Allocate more memory for the image directory.
               */
               length<<=1;
               image->directory=(char *) ResizeQuantumMemory(image->directory,
                 length+MagickPathExtent,sizeof(*image->directory));
               if (image->directory == (char *) NULL)
                 ThrowMIFFException(CorruptImageError,"UnableToReadImageData");
               p=image->directory+strlen(image->directory);
             }
           c=ReadBlobByte(image);
           if (c == EOF)
             break;
           *p++=(char) c;
         } while (c != (int) '\0');
       }
     if (profiles != (LinkedListInfo *) NULL)
       {
         const char
           *name;
 
         StringInfo
           *profile;
 
         /*
           Read image profiles.
         */
         ResetLinkedListIterator(profiles);
         name=(const char *) GetNextValueInLinkedList(profiles);
         while (name != (const char *) NULL)
         {
           length=ReadBlobMSBLong(image);
           if ((MagickSizeType) length > GetBlobSize(image))
             break;
           profile=AcquireStringInfo(length);
           if (profile == (StringInfo *) NULL)
             break;
           count=ReadBlob(image,length,GetStringInfoDatum(profile));
           if (count != (ssize_t) length)
             {
               profile=DestroyStringInfo(profile);
               break;
             }
           status=SetImageProfile(image,name,profile,exception);
           profile=DestroyStringInfo(profile);
           if (status == MagickFalse)
             break;
           name=(const char *) GetNextValueInLinkedList(profiles);
         }
         profiles=DestroyLinkedList(profiles,RelinquishMagickMemory);
       }
     image->depth=GetImageQuantumDepth(image,MagickFalse);
     if (image->storage_class == PseudoClass)
       {
         unsigned char
           *colormap;
 
         /*
           Create image colormap.
         */
         packet_size=(size_t) (3UL*image->depth/8UL);
         if ((MagickSizeType) colors > GetBlobSize(image))
           ThrowMIFFException(CorruptImageError,"InsufficientImageDataInFile");
         if (((MagickSizeType) packet_size*colors) > GetBlobSize(image))
           ThrowMIFFException(CorruptImageError,"InsufficientImageDataInFile");
         status=AcquireImageColormap(image,colors != 0 ? colors : 256,exception);
         if (status == MagickFalse)
           ThrowMIFFException(ResourceLimitError,"MemoryAllocationFailed");
         if (colors != 0)
           {
             const unsigned char
               *p;
 
             /*
               Read image colormap from file.
             */
             colormap=(unsigned char *) AcquireQuantumMemory(image->colors,
               packet_size*sizeof(*colormap));
             if (colormap == (unsigned char *) NULL)
               ThrowMIFFException(ResourceLimitError,"MemoryAllocationFailed");
             count=ReadBlob(image,packet_size*image->colors,colormap);
             p=colormap;
             switch (image->depth)
             {
               default:
               {
                 colormap=(unsigned char *) RelinquishMagickMemory(colormap);
                 ThrowMIFFException(CorruptImageError,"ImageDepthNotSupported");
                 break;
               }
               case 8:
               {
                 unsigned char
                   char_pixel;
 
                 for (i=0; i < (ssize_t) image->colors; i++)
                 {
                   p=PushCharPixel(p,&char_pixel);
                   image->colormap[i].red=(MagickRealType)
                     ScaleCharToQuantum(char_pixel);
                   p=PushCharPixel(p,&char_pixel);
                   image->colormap[i].green=(MagickRealType)
                     ScaleCharToQuantum(char_pixel);
                   p=PushCharPixel(p,&char_pixel);
                   image->colormap[i].blue=(MagickRealType)
                     ScaleCharToQuantum(char_pixel);
                 }
                 break;
               }
               case 16:
               {
                 unsigned short
                   short_pixel;
 
                 for (i=0; i < (ssize_t) image->colors; i++)
                 {
                   p=PushShortPixel(MSBEndian,p,&short_pixel);
                   image->colormap[i].red=(MagickRealType)
                     ScaleShortToQuantum(short_pixel);
                   p=PushShortPixel(MSBEndian,p,&short_pixel);
                   image->colormap[i].green=(MagickRealType)
                     ScaleShortToQuantum(short_pixel);
                   p=PushShortPixel(MSBEndian,p,&short_pixel);
                   image->colormap[i].blue=(MagickRealType)
                     ScaleShortToQuantum(short_pixel);
                 }
                 break;
               }
               case 32:
               {
                 unsigned int
                   long_pixel;
 
                 for (i=0; i < (ssize_t) image->colors; i++)
                 {
                   p=PushLongPixel(MSBEndian,p,&long_pixel);
                   image->colormap[i].red=(MagickRealType)
                     ScaleLongToQuantum(long_pixel);
                   p=PushLongPixel(MSBEndian,p,&long_pixel);
                   image->colormap[i].green=(MagickRealType)
                     ScaleLongToQuantum(long_pixel);
                   p=PushLongPixel(MSBEndian,p,&long_pixel);
                   image->colormap[i].blue=(MagickRealType)
                     ScaleLongToQuantum(long_pixel);
                 }
                 break;
               }
             }
             colormap=(unsigned char *) RelinquishMagickMemory(colormap);
           }
       }
     if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
       if (image->scene >= (image_info->scene+image_info->number_scenes-1))
         break;
     status=SetImageExtent(image,image->columns,image->rows,exception);
     if (status == MagickFalse)
       return(DestroyImageList(image));
     status=ResetImagePixels(image,exception);
     if (status == MagickFalse)
       return(DestroyImageList(image));
     /*
       Allocate image pixels.
     */
     quantum_info=AcquireQuantumInfo(image_info,image);
     if (quantum_info == (QuantumInfo *) NULL)
       ThrowMIFFException(ResourceLimitError,"MemoryAllocationFailed");
     if (quantum_format != UndefinedQuantumFormat)
       {
         status=SetQuantumFormat(image,quantum_info,quantum_format);
         if (status == MagickFalse)
           ThrowMIFFException(ResourceLimitError,"MemoryAllocationFailed");
       }
     packet_size=(size_t) (quantum_info->depth/8);
     if (image->storage_class == DirectClass)
       packet_size=(size_t) (3*quantum_info->depth/8);
     if (IsGrayColorspace(image->colorspace) != MagickFalse)
       packet_size=quantum_info->depth/8;
     if (image->alpha_trait != UndefinedPixelTrait)
       packet_size+=quantum_info->depth/8;
     if (image->colorspace == CMYKColorspace)
       packet_size+=quantum_info->depth/8;
     if (image->compression == RLECompression)
       packet_size++;
     compress_extent=MagickMax(MagickMax(BZipMaxExtent(packet_size*
       image->columns),LZMAMaxExtent(packet_size*image->columns)),
       ZipMaxExtent(packet_size*image->columns));
     compress_pixels=(unsigned char *) AcquireQuantumMemory(compress_extent,
       sizeof(*compress_pixels));
     if (compress_pixels == (unsigned char *) NULL)
       ThrowMIFFException(ResourceLimitError,"MemoryAllocationFailed");
     /*
       Read image pixels.
     */
     quantum_type=RGBQuantum;
     if (image->alpha_trait != UndefinedPixelTrait)
       quantum_type=RGBAQuantum;
     if (image->colorspace == CMYKColorspace)
       {
         quantum_type=CMYKQuantum;
         if (image->alpha_trait != UndefinedPixelTrait)
           quantum_type=CMYKAQuantum;
       }
     if (IsGrayColorspace(image->colorspace) != MagickFalse)
       {
         quantum_type=GrayQuantum;
         if (image->alpha_trait != UndefinedPixelTrait)
           quantum_type=GrayAlphaQuantum;
       }
     if (image->storage_class == PseudoClass)
       {
         quantum_type=IndexQuantum;
         if (image->alpha_trait != UndefinedPixelTrait)
           quantum_type=IndexAlphaQuantum;
       }
     status=MagickTrue;
     GetPixelInfo(image,&pixel);
 #if defined(MAGICKCORE_BZLIB_DELEGATE)
    (void) memset(&bzip_info,0,sizeof(bzip_info));
 #endif
 #if defined(MAGICKCORE_LZMA_DELEGATE)
     (void) memset(&allocator,0,sizeof(allocator));
 #endif
 #if defined(MAGICKCORE_ZLIB_DELEGATE)
     (void) memset(&zip_info,0,sizeof(zip_info));
 #endif
     switch (image->compression)
     {
 #if defined(MAGICKCORE_BZLIB_DELEGATE)
       case BZipCompression:
       {
         int
           code;
 
         bzip_info.bzalloc=AcquireBZIPMemory;
         bzip_info.bzfree=RelinquishBZIPMemory;
         bzip_info.opaque=(void *) image;
         code=BZ2_bzDecompressInit(&bzip_info,(int) image_info->verbose,
           MagickFalse);
         if (code != BZ_OK)
           status=MagickFalse;
         break;
       }
 #endif
 #if defined(MAGICKCORE_LZMA_DELEGATE)
       case LZMACompression:
       {
         int
           code;
 
         allocator.alloc=AcquireLZMAMemory;
         allocator.free=RelinquishLZMAMemory;
         allocator.opaque=(void *) image;
         lzma_info=initialize_lzma;
         lzma_info.allocator=(&allocator);
         code=lzma_auto_decoder(&lzma_info,(uint64_t) -1,0);
         if (code != LZMA_OK)
           status=MagickFalse;
         break;
       }
 #endif
 #if defined(MAGICKCORE_ZLIB_DELEGATE)
       case LZWCompression:
       case ZipCompression:
       {
         int
           code;
 
         zip_info.zalloc=AcquireZIPMemory;
         zip_info.zfree=RelinquishZIPMemory;
         zip_info.opaque=(voidpf) image;
         code=inflateInit(&zip_info);
         if (code != Z_OK)
           status=MagickFalse;
         break;
       }
 #endif
       case RLECompression:
         break;
       default:
         break;
     }
     pixels=(unsigned char *) GetQuantumPixels(quantum_info);
     length=0;
     for (y=0; y < (ssize_t) image->rows; y++)
     {
       register ssize_t
         x;
 
       register Quantum
         *magick_restrict q;
 
       if (status == MagickFalse)
         break;
       q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
       if (q == (Quantum *) NULL)
         break;
+      extent=0;
       switch (image->compression)
       {
 #if defined(MAGICKCORE_BZLIB_DELEGATE)
         case BZipCompression:
         {
           bzip_info.next_out=(char *) pixels;
           bzip_info.avail_out=(unsigned int) (packet_size*image->columns);
           do
           {
             int
               code;
 
             if (bzip_info.avail_in == 0)
               {
                 bzip_info.next_in=(char *) compress_pixels;
                 length=(size_t) BZipMaxExtent(packet_size*image->columns);
                 if (version != 0.0)
                   length=(size_t) ReadBlobMSBLong(image);
                 if (length <= compress_extent)
                   bzip_info.avail_in=(unsigned int) ReadBlob(image,length,
                     (unsigned char *) bzip_info.next_in);
                 if ((length > compress_extent) ||
                     ((size_t) bzip_info.avail_in != length))
                   {
                     (void) BZ2_bzDecompressEnd(&bzip_info);
                     ThrowMIFFException(CorruptImageError,
                       "UnableToReadImageData");
                   }
               }
             code=BZ2_bzDecompress(&bzip_info);
             if ((code != BZ_OK) && (code != BZ_STREAM_END))
               {
                 status=MagickFalse;
                 break;
               }
             if (code == BZ_STREAM_END)
               break;
           } while (bzip_info.avail_out != 0);
-          (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
+          extent=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
             quantum_type,pixels,exception);
           break;
         }
 #endif
 #if defined(MAGICKCORE_LZMA_DELEGATE)
         case LZMACompression:
         {
           lzma_info.next_out=pixels;
           lzma_info.avail_out=packet_size*image->columns;
           do
           {
             int
               code;
 
             if (lzma_info.avail_in == 0)
               {
                 lzma_info.next_in=compress_pixels;
                 length=(size_t) ReadBlobMSBLong(image);
                 if (length <= compress_extent)
                   lzma_info.avail_in=(unsigned int) ReadBlob(image,length,
                     (unsigned char *) lzma_info.next_in);
                 if ((length > compress_extent) ||
                     (lzma_info.avail_in != length))
                   {
                     lzma_end(&lzma_info);
                     ThrowMIFFException(CorruptImageError,
                       "UnableToReadImageData");
                   }
               }
             code=lzma_code(&lzma_info,LZMA_RUN);
             if ((code != LZMA_OK) && (code != LZMA_STREAM_END))
               {
                 status=MagickFalse;
                 break;
               }
             if (code == LZMA_STREAM_END)
               break;
           } while (lzma_info.avail_out != 0);
-          (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
+          extent=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
             quantum_type,pixels,exception);
           break;
         }
 #endif
 #if defined(MAGICKCORE_ZLIB_DELEGATE)
         case LZWCompression:
         case ZipCompression:
         {
           zip_info.next_out=pixels;
           zip_info.avail_out=(uInt) (packet_size*image->columns);
           do
           {
             int
               code;
 
             if (zip_info.avail_in == 0)
               {
                 zip_info.next_in=compress_pixels;
                 length=(size_t) ZipMaxExtent(packet_size*image->columns);
                 if (version != 0.0)
                   length=(size_t) ReadBlobMSBLong(image);
                 if (length <= compress_extent)
                   zip_info.avail_in=(unsigned int) ReadBlob(image,length,
                     zip_info.next_in);
                 if ((length > compress_extent) ||
                     ((size_t) zip_info.avail_in != length))
                   {
                     (void) inflateEnd(&zip_info);
                     ThrowMIFFException(CorruptImageError,
                       "UnableToReadImageData");
                   }
               }
             code=inflate(&zip_info,Z_SYNC_FLUSH);
             if ((code != Z_OK) && (code != Z_STREAM_END))
               {
                 status=MagickFalse;
                 break;
               }
             if (code == Z_STREAM_END)
               break;
           } while (zip_info.avail_out != 0);
-          (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
+          extent=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
             quantum_type,pixels,exception);
           break;
         }
 #endif
         case RLECompression:
         {
           for (x=0; x < (ssize_t) image->columns; x++)
           {
             if (length == 0)
               {
                 count=ReadBlob(image,packet_size,pixels);
                 if (count != (ssize_t) packet_size)
                   ThrowMIFFException(CorruptImageError,"UnableToReadImageData");
                 PushRunlengthPacket(image,pixels,&length,&pixel,exception);
               }
             length--;
             if (image->storage_class == PseudoClass)
               SetPixelIndex(image,ClampToQuantum(pixel.index),q);
             else
               {
                 SetPixelRed(image,ClampToQuantum(pixel.red),q);
                 SetPixelGreen(image,ClampToQuantum(pixel.green),q);
                 SetPixelBlue(image,ClampToQuantum(pixel.blue),q);
                 if (image->colorspace == CMYKColorspace)
                   SetPixelBlack(image,ClampToQuantum(pixel.black),q);
               }
             if (image->alpha_trait != UndefinedPixelTrait)
               SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);
             q+=GetPixelChannels(image);
           }
+          extent=(size_t) x;
           break;
         }
         default:
         {
           count=ReadBlob(image,packet_size*image->columns,pixels);
           if (count != (ssize_t) (packet_size*image->columns))
             ThrowMIFFException(CorruptImageError,"UnableToReadImageData");
-          (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
+          extent=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
             quantum_type,pixels,exception);
           break;
         }
       }
+      if (extent < image->columns)
+        break;
       if (SyncAuthenticPixels(image,exception) == MagickFalse)
         break;
     }
     SetQuantumImageType(image,quantum_type);
     switch (image->compression)
     {
 #if defined(MAGICKCORE_BZLIB_DELEGATE)
       case BZipCompression:
       {
         int
           code;
 
         if (version == 0.0)
           {
             MagickOffsetType
               offset;
 
             offset=SeekBlob(image,-((MagickOffsetType) bzip_info.avail_in),
               SEEK_CUR);
             if (offset < 0)
               {
                 (void) BZ2_bzDecompressEnd(&bzip_info);
                 ThrowMIFFException(CorruptImageError,"ImproperImageHeader");
               }
           }
         code=BZ2_bzDecompressEnd(&bzip_info);
         if (code != BZ_OK)
           status=MagickFalse;
         break;
       }
 #endif
 #if defined(MAGICKCORE_LZMA_DELEGATE)
       case LZMACompression:
       {
         int
           code;
 
         code=lzma_code(&lzma_info,LZMA_FINISH);
         if ((code != LZMA_STREAM_END) && (code != LZMA_OK))
           status=MagickFalse;
         lzma_end(&lzma_info);
         break;
       }
 #endif
 #if defined(MAGICKCORE_ZLIB_DELEGATE)
       case LZWCompression:
       case ZipCompression:
       {
         int
           code;
 
         if (version == 0.0)
           {
             MagickOffsetType
               offset;
 
             offset=SeekBlob(image,-((MagickOffsetType) zip_info.avail_in),
               SEEK_CUR);
             if (offset < 0)
               {
                 (void) inflateEnd(&zip_info);
                 ThrowMIFFException(CorruptImageError,"ImproperImageHeader");
               }
           }
         code=inflateEnd(&zip_info);
         if (code != Z_OK)
           status=MagickFalse;
         break;
       }
 #endif
       default:
         break;
     }
     quantum_info=DestroyQuantumInfo(quantum_info);
     compress_pixels=(unsigned char *) RelinquishMagickMemory(compress_pixels);
     if (((y != (ssize_t) image->rows)) || (status == MagickFalse))
       {
         image=DestroyImageList(image);
         return((Image *) NULL);
       }
     if (EOFBlob(image) != MagickFalse)
       {
         ThrowFileException(exception,CorruptImageError,"UnexpectedEndOfFile",
           image->filename);
         break;
       }
     /*
       Proceed to next image.
     */
     if (image_info->number_scenes != 0)
       if (image->scene >= (image_info->scene+image_info->number_scenes-1))
         break;
     do
     {
       c=ReadBlobByte(image);
     } while ((isgraph(c) == MagickFalse) && (c != EOF));
     if (c != EOF)
       {
         /*
           Allocate next image structure.
         */
         AcquireNextImage(image_info,image,exception);
         if (GetNextImageInList(image) == (Image *) NULL)
           {
             status=MagickFalse;
             break;
           }
         image=SyncNextImageInList(image);
         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
           GetBlobSize(image));
         if (status == MagickFalse)
           break;
       }
   } while (c != EOF);
   (void) CloseBlob(image);
   if (status == MagickFalse)
     return(DestroyImageList(image));
   return(GetFirstImageInList(image));
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   R e g i s t e r M I F F I m a g e                                         %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  RegisterMIFFImage() adds properties for the MIFF image format to the list of
 %  supported formats.  The properties include the image format tag, a method to
 %  read and/or write the format, whether the format supports the saving of more
 %  than one frame to the same file or blob, whether the format supports native
 %  in-memory I/O, and a brief description of the format.
 %
 %  The format of the RegisterMIFFImage method is:
 %
 %      size_t RegisterMIFFImage(void)
 %
 */
