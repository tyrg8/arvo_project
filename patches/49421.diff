commit 3f897554837966b71aa3bfd72dd7ce482e5e55ae
Author: Alex <93376818+sashashura@users.noreply.github.com>
Date:   Thu Aug 25 14:10:32 2022 +0100

    Fix multiple memory corruption errors revealed by fuzzing (#5342)
    
    * Fix multiple memory corruption errors revealed by fuzzing
    
    Fixes the following crashes:
    https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=32178
    https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=32228
    https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=33217
    https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=33762
    https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=34134
    https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=35640
    https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=36663
    https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=37041
    https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=37125
    https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=39438
    https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40058
    https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40120
    https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=41152
    
    * Merge with ply_io.cpp from #4299
    
    * Added PCLPointCloud2::at
    
    * more `at`
    
    * more memcpy eliminated
    
    * remove spaces
    
    * Update io/src/ply_io.cpp
    
    * Apply suggestions from code review
    
    * Apply suggestions from code review
    
    Co-authored-by: Markus Vieth <39675748+mvieth@users.noreply.github.com>
    
    * Fix origins of warnings
    
    Co-authored-by: Markus Vieth <39675748+mvieth@users.noreply.github.com>

diff --git a/common/include/pcl/PCLPointCloud2.h b/common/include/pcl/PCLPointCloud2.h
index 50520f66e..cf78ad396 100644
--- a/common/include/pcl/PCLPointCloud2.h
+++ b/common/include/pcl/PCLPointCloud2.h
@@ -13,114 +13,142 @@
 namespace pcl
 {
 
   struct PCL_EXPORTS PCLPointCloud2
   {
     ::pcl::PCLHeader header;
 
     uindex_t height = 0;
     uindex_t width = 0;
 
     std::vector<::pcl::PCLPointField>  fields;
 
     static_assert(BOOST_ENDIAN_BIG_BYTE || BOOST_ENDIAN_LITTLE_BYTE, "unable to determine system endianness");
     std::uint8_t is_bigendian = BOOST_ENDIAN_BIG_BYTE;
     uindex_t point_step = 0;
     uindex_t row_step = 0;
 
     std::vector<std::uint8_t> data;
 
     std::uint8_t is_dense = 0;
 
   public:
     using Ptr = shared_ptr< ::pcl::PCLPointCloud2>;
     using ConstPtr = shared_ptr<const ::pcl::PCLPointCloud2>;
 
     //////////////////////////////////////////////////////////////////////////
     /** \brief Inplace concatenate two pcl::PCLPointCloud2
       *
       * IFF the layout of all the fields in both the clouds is the same, this command
       * doesn't remove any fields named "_" (aka marked as skip). For comparison of field
       * names, "rgb" and "rgba" are considered equivalent
       * However, if the order and/or number of non-skip fields is different, the skip fields
       * are dropped and non-skip fields copied selectively.
       * This function returns an error if
       *   * the total number of non-skip fields is different
       *   * the non-skip field names are named differently (excluding "rbg{a}") in serial order
       *   * the endian-ness of both clouds is different
       * \param[in,out] cloud1 the first input and output point cloud dataset
       * \param[in] cloud2 the second input point cloud dataset
       * \return true if successful, false if failed (e.g., name/number of fields differs)
       */
     static bool
     concatenate (pcl::PCLPointCloud2 &cloud1, const pcl::PCLPointCloud2 &cloud2);
 
     /** \brief Concatenate two pcl::PCLPointCloud2
       * \param[in] cloud1 the first input point cloud dataset
       * \param[in] cloud2 the second input point cloud dataset
       * \param[out] cloud_out the resultant output point cloud dataset
       * \return true if successful, false if failed (e.g., name/number of fields differs)
       */
     static bool
     concatenate (const PCLPointCloud2 &cloud1,
                  const PCLPointCloud2 &cloud2,
                  PCLPointCloud2 &cloud_out)
     {
       cloud_out = cloud1;
       return concatenate(cloud_out, cloud2);
     }
 
     /** \brief Add a point cloud to the current cloud.
       * \param[in] rhs the cloud to add to the current cloud
       * \return the new cloud as a concatenation of the current cloud and the new given cloud
       */
     PCLPointCloud2&
     operator += (const PCLPointCloud2& rhs);
 
     /** \brief Add a point cloud to another cloud.
       * \param[in] rhs the cloud to add to the current cloud
       * \return the new cloud as a concatenation of the current cloud and the new given cloud
       */
     inline PCLPointCloud2
     operator + (const PCLPointCloud2& rhs)
     {
       return (PCLPointCloud2 (*this) += rhs);
     }
+
+    /** \brief Get value at specified offset.
+      * \param[in] point_index point index.
+      * \param[in] field_offset offset.
+      * \return value at the given offset.
+      */
+    template<typename T> inline
+    const T& at(const pcl::uindex_t& point_index, const pcl::uindex_t& field_offset) const {
+      const auto position = point_index * point_step + field_offset;
+      if (data.size () >= (position + sizeof(T)))
+        return reinterpret_cast<const T&>(data[position]);
+      else
+        throw std::out_of_range("PCLPointCloud2::at");
+    }
+
+    /** \brief Get value at specified offset.
+      * \param[in] point_index point index.
+      * \param[in] field_offset offset.
+      * \return value at the given offset.
+      */
+    template<typename T> inline
+    T& at(const pcl::uindex_t& point_index, const pcl::uindex_t& field_offset) {
+      const auto position = point_index * point_step + field_offset;
+      if (data.size () >= (position + sizeof(T)))
+        return reinterpret_cast<T&>(data[position]);
+      else
+        throw std::out_of_range("PCLPointCloud2::at");
+    }
   }; // struct PCLPointCloud2
 
   using PCLPointCloud2Ptr = PCLPointCloud2::Ptr;
   using PCLPointCloud2ConstPtr = PCLPointCloud2::ConstPtr;
 
   inline std::ostream& operator<<(std::ostream& s, const  ::pcl::PCLPointCloud2 &v)
   {
     s << "header: " << std::endl;
     s << v.header;
     s << "height: ";
     s << "  " << v.height << std::endl;
     s << "width: ";
     s << "  " << v.width << std::endl;
     s << "fields[]" << std::endl;
     for (std::size_t i = 0; i < v.fields.size (); ++i)
     {
       s << "  fields[" << i << "]: ";
       s << std::endl;
       s << "    " << v.fields[i] << std::endl;
     }
     s << "is_bigendian: ";
     s << "  " << v.is_bigendian << std::endl;
     s << "point_step: ";
     s << "  " << v.point_step << std::endl;
     s << "row_step: ";
     s << "  " << v.row_step << std::endl;
     s << "data[]" << std::endl;
     for (std::size_t i = 0; i < v.data.size (); ++i)
     {
       s << "  data[" << i << "]: ";
       s << "  " << v.data[i] << std::endl;
     }
     s << "is_dense: ";
     s << "  " << v.is_dense << std::endl;
 
     return (s);
   }
 
 } // namespace pcl
diff --git a/io/include/pcl/io/ply_io.h b/io/include/pcl/io/ply_io.h
index 515592ae8..e7d9a0274 100644
--- a/io/include/pcl/io/ply_io.h
+++ b/io/include/pcl/io/ply_io.h
@@ -52,844 +52,842 @@
 namespace pcl
 {
   /** \brief Point Cloud Data (PLY) file format reader.
     *
     * The PLY data format is organized in the following way:
     * lines beginning with "comment" are treated as comments
     *   - ply
     *   - format [ascii|binary_little_endian|binary_big_endian] 1.0
     *   - element vertex COUNT
     *   - property float x 
     *   - property float y 
     *   - [property float z] 
     *   - [property float normal_x] 
     *   - [property float normal_y] 
     *   - [property float normal_z] 
     *   - [property uchar red] 
     *   - [property uchar green] 
     *   - [property uchar blue] ...
     *   - ascii/binary point coordinates
     *   - [element camera 1]
     *   - [property float view_px] ...
     *   - [element range_grid COUNT]
     *   - [property list uchar int vertex_indices]
     *   - end header
     *
     * \author Nizar Sallem
     * \ingroup io
     */
   class PCL_EXPORTS PLYReader : public FileReader
   {
     public:
       enum
       {
         PLY_V0 = 0,
         PLY_V1 = 1
       };
       
       PLYReader ()
         : origin_ (Eigen::Vector4f::Zero ())
         , orientation_ (Eigen::Matrix3f::Zero ())
         , cloud_ ()
         , vertex_count_ (0)
         , vertex_offset_before_ (0)
         , range_grid_ (nullptr)
         , rgb_offset_before_ (0)
         , do_resize_ (false)
         , polygons_ (nullptr)
         , r_(0), g_(0), b_(0)
         , a_(0), rgba_(0)
       {}
 
       PLYReader (const PLYReader &p)
         : origin_ (Eigen::Vector4f::Zero ())
         , orientation_ (Eigen::Matrix3f::Zero ())
         , cloud_ ()
         , vertex_count_ (0)
         , vertex_offset_before_ (0)
         , range_grid_ (nullptr)
         , rgb_offset_before_ (0)
         , do_resize_ (false)
         , polygons_ (nullptr)
         , r_(0), g_(0), b_(0)
         , a_(0), rgba_(0)
       {
         *this = p;
       }
 
       PLYReader&
       operator = (const PLYReader &p)
       {
         origin_ = p.origin_;
         orientation_ = p.orientation_;
         range_grid_ = p.range_grid_;
         polygons_ = p.polygons_;
         return (*this);
       }
 
       ~PLYReader () override { delete range_grid_; }
       /** \brief Read a point cloud data header from a PLY file.
         *
         * Load only the meta information (number of points, their types, etc),
         * and not the points themselves, from a given PLY file. Useful for fast
         * evaluation of the underlying data structure.
         *
         * Returns:
         *  * < 0 (-1) on error
         *  * > 0 on success
         * \param[in] file_name the name of the file to load
         * \param[out] cloud the resultant point cloud dataset (only the header will be filled)
         * \param[in] origin the sensor data acquisition origin (translation)
         * \param[in] orientation the sensor data acquisition origin (rotation)
         * \param[out] ply_version the PLY version read from the file
         * \param[out] data_type the type of PLY data stored in the file
         * \param[out] data_idx the data index
         * \param[in] offset the offset in the file where to expect the true header to begin.
         * One usage example for setting the offset parameter is for reading
         * data from a TAR "archive containing multiple files: TAR files always
         * add a 512 byte header in front of the actual file, so set the offset
         * to the next byte after the header (e.g., 513).
         */
       int 
       readHeader (const std::string &file_name, pcl::PCLPointCloud2 &cloud,
                   Eigen::Vector4f &origin, Eigen::Quaternionf &orientation,
                   int &ply_version, int &data_type, unsigned int &data_idx, const int offset = 0) override;
 
       /** \brief Read a point cloud data from a PLY file and store it into a pcl/PCLPointCloud2.
         * \param[in] file_name the name of the file containing the actual PointCloud data
         * \param[out] cloud the resultant PointCloud message read from disk
         * \param[in] origin the sensor data acquisition origin (translation)
         * \param[in] orientation the sensor data acquisition origin (rotation)
         * \param[out] ply_version the PLY version read from the file
         * \param[in] offset the offset in the file where to expect the true header to begin.
         * One usage example for setting the offset parameter is for reading
         * data from a TAR "archive containing multiple files: TAR files always
         * add a 512 byte header in front of the actual file, so set the offset
         * to the next byte after the header (e.g., 513).
         */
       int 
       read (const std::string &file_name, pcl::PCLPointCloud2 &cloud,
             Eigen::Vector4f &origin, Eigen::Quaternionf &orientation, int& ply_version, const int offset = 0) override;
 
       /** \brief Read a point cloud data from a PLY file and store it into a pcl/PCLPointCloud2.
         * \note This function is provided for backwards compatibility only
         * \param[in] file_name the name of the file containing the actual PointCloud data
         * \param[out] cloud the resultant PointCloud message read from disk
         * \param[in] offset the offset in the file where to expect the true header to begin.
         * One usage example for setting the offset parameter is for reading
         * data from a TAR "archive containing multiple files: TAR files always
         * add a 512 byte header in front of the actual file, so set the offset
         * to the next byte after the header (e.g., 513).
         */
       inline int 
       read (const std::string &file_name, pcl::PCLPointCloud2 &cloud, const int offset = 0)
       {
         Eigen::Vector4f origin;
         Eigen::Quaternionf orientation;
         int ply_version;
         return read (file_name, cloud, origin, orientation, ply_version, offset);
       }
 
       /** \brief Read a point cloud data from any PLY file, and convert it to the given template format.
         * \param[in] file_name the name of the file containing the actual PointCloud data
         * \param[out] cloud the resultant PointCloud message read from disk
         * \param[in] offset the offset in the file where to expect the true header to begin.
         * One usage example for setting the offset parameter is for reading
         * data from a TAR "archive containing multiple files: TAR files always
         * add a 512 byte header in front of the actual file, so set the offset
         * to the next byte after the header (e.g., 513).
         */
       template<typename PointT> inline int
       read (const std::string &file_name, pcl::PointCloud<PointT> &cloud, const int offset = 0)
       {
         pcl::PCLPointCloud2 blob;
         int ply_version;
         int res = read (file_name, blob, cloud.sensor_origin_, cloud.sensor_orientation_,
                         ply_version, offset);
 
         // Exit in case of error
         if (res < 0)
           return (res);
         pcl::fromPCLPointCloud2 (blob, cloud);
         return (0);
       }
       
       /** \brief Read a point cloud data from a PLY file and store it into a pcl/PolygonMesh.
         *
         * \param[in] file_name the name of the file containing the actual PointCloud data
         * \param[out] mesh the resultant PolygonMesh message read from disk
         * \param[in] origin the sensor data acquisition origin (translation)
         * \param[in] orientation the sensor data acquisition origin (rotation)
         * \param[out] ply_version the PLY version read from the file
         * \param[in] offset the offset in the file where to expect the true header to begin.
         * One usage example for setting the offset parameter is for reading
         * data from a TAR "archive containing multiple files: TAR files always
         * add a 512 byte header in front of the actual file, so set the offset
         * to the next byte after the header (e.g., 513).
         */
       int
       read (const std::string &file_name, pcl::PolygonMesh &mesh,
             Eigen::Vector4f &origin, Eigen::Quaternionf &orientation,
             int& ply_version, const int offset = 0);
 
       /** \brief Read a point cloud data from a PLY file and store it into a pcl/PolygonMesh.
         *
         * \param[in] file_name the name of the file containing the actual PointCloud data
         * \param[out] mesh the resultant PolygonMesh message read from disk
         * \param[in] offset the offset in the file where to expect the true header to begin.
         * One usage example for setting the offset parameter is for reading
         * data from a TAR "archive containing multiple files: TAR files always
         * add a 512 byte header in front of the actual file, so set the offset
         * to the next byte after the header (e.g., 513).
         */
       int
       read (const std::string &file_name, pcl::PolygonMesh &mesh, const int offset = 0);
 
     private:
       ::pcl::io::ply::ply_parser parser_;
 
       bool
       parse (const std::string& istream_filename);
 
       /** \brief Info callback function
         * \param[in] filename PLY file read
         * \param[in] line_number line triggering the callback
         * \param[in] message information message
         */
       void 
       infoCallback (const std::string& filename, std::size_t line_number, const std::string& message)
       {
         PCL_DEBUG ("[pcl::PLYReader] %s:%lu: %s\n", filename.c_str (), line_number, message.c_str ());
       }
       
       /** \brief Warning callback function
         * \param[in] filename PLY file read
         * \param[in] line_number line triggering the callback
         * \param[in] message warning message
         */
       void 
       warningCallback (const std::string& filename, std::size_t line_number, const std::string& message)
       {
         PCL_WARN ("[pcl::PLYReader] %s:%lu: %s\n", filename.c_str (), line_number, message.c_str ());
       }
       
       /** \brief Error callback function
         * \param[in] filename PLY file read
         * \param[in] line_number line triggering the callback
         * \param[in] message error message
         */
       void 
       errorCallback (const std::string& filename, std::size_t line_number, const std::string& message)
       {
         PCL_ERROR ("[pcl::PLYReader] %s:%lu: %s\n", filename.c_str (), line_number, message.c_str ());
       }
       
       /** \brief function called when the keyword element is parsed
         * \param[in] element_name element name
         * \param[in] count number of instances
         */
       std::tuple<std::function<void ()>, std::function<void ()> > 
       elementDefinitionCallback (const std::string& element_name, std::size_t count);
       
       bool
       endHeaderCallback ();
 
       /** \brief function called when a scalar property is parsed
         * \param[in] element_name element name to which the property belongs
         * \param[in] property_name property name
         */
       template <typename ScalarType> std::function<void (ScalarType)> 
       scalarPropertyDefinitionCallback (const std::string& element_name, const std::string& property_name);
 
       /** \brief function called when a list property is parsed
         * \param[in] element_name element name to which the property belongs
         * \param[in] property_name list property name
         */
       template <typename SizeType, typename ScalarType>
       std::tuple<std::function<void (SizeType)>, std::function<void (ScalarType)>, std::function<void ()> >
       listPropertyDefinitionCallback (const std::string& element_name, const std::string& property_name);
       
       /** \brief function called at the beginning of a list property parsing.
         * \param[in] size number of elements in the list
         */
       template <typename SizeType> void
       vertexListPropertyBeginCallback (const std::string& property_name, SizeType size);
 
       /** \brief function called when a list element is parsed.
         * \param[in] value the list's element value
         */
       template <typename ContentType> void
       vertexListPropertyContentCallback (ContentType value);
 
       /** \brief function called at the end of a list property parsing */
       inline void
       vertexListPropertyEndCallback ();
 
       /** Callback function for an anonymous vertex scalar property.
         * Writes down a double value in cloud data.
         * param[in] value double value parsed
         */
       template<typename Scalar> void
       vertexScalarPropertyCallback (Scalar value);
 
       /** Callback function for vertex RGB color.
         * This callback is in charge of packing red green and blue in a single int
         * before writing it down in cloud data.
         * param[in] color_name color name in {red, green, blue}
         * param[in] color value of {red, green, blue} property
         */
       inline void
       vertexColorCallback (const std::string& color_name, pcl::io::ply::uint8 color);
 
       /** Callback function for vertex intensity.
         * converts intensity from int to float before writing it down in cloud data.
         * param[in] intensity
         */
       inline void
       vertexIntensityCallback (pcl::io::ply::uint8 intensity);
 
       /** Callback function for vertex alpha.
         * extracts RGB value, append alpha and put it back
         * param[in] alpha
         */
       inline void
       vertexAlphaCallback (pcl::io::ply::uint8 alpha);
       
       /** Callback function for origin x component.
         * param[in] value origin x value
         */
       inline void
       originXCallback (const float& value) { origin_[0] = value; }
       
       /** Callback function for origin y component.
         * param[in] value origin y value
         */
       inline void
       originYCallback (const float& value) { origin_[1] = value; }
 
       /** Callback function for origin z component.
         * param[in] value origin z value
         */      
       inline void
       originZCallback (const float& value) { origin_[2] = value; }
     
       /** Callback function for orientation x axis x component.
         * param[in] value orientation x axis x value
         */
       inline void
       orientationXaxisXCallback (const float& value) { orientation_ (0,0) = value; }
       
       /** Callback function for orientation x axis y component.
         * param[in] value orientation x axis y value
         */
       inline void
       orientationXaxisYCallback (const float& value) { orientation_ (0,1) = value; }
       
       /** Callback function for orientation x axis z component.
         * param[in] value orientation x axis z value
         */
       inline void
       orientationXaxisZCallback (const float& value) { orientation_ (0,2) = value; }
       
       /** Callback function for orientation y axis x component.
         * param[in] value orientation y axis x value
         */
       inline void
       orientationYaxisXCallback (const float& value) { orientation_ (1,0) = value; }
       
       /** Callback function for orientation y axis y component.
         * param[in] value orientation y axis y value
         */
       inline void
       orientationYaxisYCallback (const float& value) { orientation_ (1,1) = value; }
 
       /** Callback function for orientation y axis z component.
         * param[in] value orientation y axis z value
         */
       inline void
       orientationYaxisZCallback (const float& value) { orientation_ (1,2) = value; }
       
       /** Callback function for orientation z axis x component.
         * param[in] value orientation z axis x value
         */
       inline void
       orientationZaxisXCallback (const float& value) { orientation_ (2,0) = value; }
     
       /** Callback function for orientation z axis y component.
         * param[in] value orientation z axis y value
         */
       inline void
       orientationZaxisYCallback (const float& value) { orientation_ (2,1) = value; }
       
       /** Callback function for orientation z axis z component.
         * param[in] value orientation z axis z value
         */
       inline void
       orientationZaxisZCallback (const float& value) { orientation_ (2,2) = value; }
       
       /** Callback function to set the cloud height
         * param[in] height cloud height
         */
       inline void
       cloudHeightCallback (const int &height) { cloud_->height = height; }
 
       /** Callback function to set the cloud width
         * param[in] width cloud width
         */
       inline void
       cloudWidthCallback (const int &width) { cloud_->width = width; }
         
       /** Append a scalar property to the cloud fields.
         * param[in] name property name
         * param[in] count property count: 1 for scalar properties and higher for a
         * list property.
         */
       template<typename Scalar> void
       appendScalarProperty (const std::string& name, const std::size_t& count = 1);
 
       /** Amend property from cloud fields identified by \a old_name renaming
         * it \a new_name.
         * param[in] old_name property old name
         * param[in] new_name property new name
         */
       void
       amendProperty (const std::string& old_name, const std::string& new_name, std::uint8_t datatype = 0);
 
       /** Callback function for the begin of vertex line */
       void
       vertexBeginCallback ();
 
       /** Callback function for the end of vertex line */
       void
       vertexEndCallback ();
 
       /** Callback function for the begin of range_grid line */
       void
       rangeGridBeginCallback ();
 
       /** Callback function for the begin of range_grid vertex_indices property 
         * param[in] size vertex_indices list size  
         */
       void
       rangeGridVertexIndicesBeginCallback (pcl::io::ply::uint8 size);
 
       /** Callback function for each range_grid vertex_indices element
         * param[in] vertex_index index of the vertex in vertex_indices
         */      
       void
       rangeGridVertexIndicesElementCallback (pcl::io::ply::int32 vertex_index);
 
       /** Callback function for the end of a range_grid vertex_indices property */
       void
       rangeGridVertexIndicesEndCallback ();
 
       /** Callback function for the end of a range_grid element end */
       void
       rangeGridEndCallback ();
 
       /** Callback function for obj_info */
       void
       objInfoCallback (const std::string& line);
 
       /** Callback function for the begin of face line */
       void
       faceBeginCallback ();
 
       /** Callback function for the begin of face vertex_indices property
         * param[in] size vertex_indices list size
         */
       void
       faceVertexIndicesBeginCallback (pcl::io::ply::uint8 size);
 
       /** Callback function for each face vertex_indices element
         * param[in] vertex_index index of the vertex in vertex_indices
         */
       void
       faceVertexIndicesElementCallback (pcl::io::ply::int32 vertex_index);
 
       /** Callback function for the end of a face vertex_indices property */
       void
       faceVertexIndicesEndCallback ();
 
       /** Callback function for the end of a face element end */
       void
       faceEndCallback ();
 
       /// origin
       Eigen::Vector4f origin_;
 
       /// orientation
       Eigen::Matrix3f orientation_;
 
       //vertex element artifacts
       pcl::PCLPointCloud2 *cloud_;
       std::size_t vertex_count_;
       int vertex_offset_before_;
       //range element artifacts
       std::vector<std::vector <int> > *range_grid_;
       std::size_t rgb_offset_before_;
       bool do_resize_;
       //face element artifact
       std::vector<pcl::Vertices> *polygons_;
     public:
       PCL_MAKE_ALIGNED_OPERATOR_NEW
       
     private:
       // RGB values stored by vertexColorCallback()
       std::int32_t r_, g_, b_;
       // Color values stored by vertexAlphaCallback()
       std::uint32_t a_, rgba_;
   };
 
   /** \brief Point Cloud Data (PLY) file format writer.
     * \author Nizar Sallem
     * \ingroup io
     */
   class PCL_EXPORTS PLYWriter : public FileWriter
   {
     public:
       ///Constructor
       PLYWriter () = default;
 
       ///Destructor
       ~PLYWriter () override = default;
 
       /** \brief Generate the header of a PLY v.7 file format
         * \param[in] cloud the point cloud data message
         * \param[in] origin the sensor data acquisition origin (translation)
         * \param[in] orientation the sensor data acquisition origin (rotation)
         * \param[in] valid_points number of valid points (finite ones for range_grid and
         * all of them for camer)
         * \param[in] use_camera if set to true then PLY file will use element camera else
         * element range_grid will be used.
         */
       inline std::string
       generateHeaderBinary (const pcl::PCLPointCloud2 &cloud,
                             const Eigen::Vector4f &origin, 
                             const Eigen::Quaternionf &orientation,
                             int valid_points,
                             bool use_camera = true)
       {
         return (generateHeader (cloud, origin, orientation, true, use_camera, valid_points));
       }
       
       /** \brief Generate the header of a PLY v.7 file format
         * \param[in] cloud the point cloud data message
         * \param[in] origin the sensor data acquisition origin (translation)
         * \param[in] orientation the sensor data acquisition origin (rotation)
         * \param[in] valid_points number of valid points (finite ones for range_grid and
         * all of them for camer)
         * \param[in] use_camera if set to true then PLY file will use element camera else
         * element range_grid will be used.
         */
       inline std::string
       generateHeaderASCII (const pcl::PCLPointCloud2 &cloud,
                            const Eigen::Vector4f &origin, 
                            const Eigen::Quaternionf &orientation,
                            int valid_points,
                            bool use_camera = true)
       {
         return (generateHeader (cloud, origin, orientation, false, use_camera, valid_points));
       }
 
       /** \brief Save point cloud data to a PLY file containing n-D points, in ASCII format
         * \param[in] file_name the output file name
         * \param[in] cloud the point cloud data message
         * \param[in] origin the sensor data acquisition origin (translation)
         * \param[in] orientation the sensor data acquisition origin (rotation)
         * \param[in] precision the specified output numeric stream precision (default: 8)
         * \param[in] use_camera if set to true then PLY file will use element camera else
         * element range_grid will be used.
         */
       int 
       writeASCII (const std::string &file_name, const pcl::PCLPointCloud2 &cloud,
                   const Eigen::Vector4f &origin = Eigen::Vector4f::Zero (), 
                   const Eigen::Quaternionf &orientation = Eigen::Quaternionf::Identity (),
                   int precision = 8,
                   bool use_camera = true);
 
       /** \brief Save point cloud data to a PLY file containing n-D points, in BINARY format
         * \param[in] file_name the output file name
         * \param[in] cloud the point cloud data message
         * \param[in] origin the sensor data acquisition origin (translation)
         * \param[in] orientation the sensor data acquisition origin (rotation)
         * \param[in] use_camera if set to true then PLY file will use element camera else
         * element range_grid will be used
         */
       int 
       writeBinary (const std::string &file_name, const pcl::PCLPointCloud2 &cloud,
                    const Eigen::Vector4f &origin = Eigen::Vector4f::Zero (), 
                    const Eigen::Quaternionf &orientation = Eigen::Quaternionf::Identity (),
                    bool use_camera = true);
 
       /** \brief Save point cloud data to a PLY file containing n-D points
         * \param[in] file_name the output file name
         * \param[in] cloud the point cloud data message
         * \param[in] origin the sensor acquisition origin
         * \param[in] orientation the sensor acquisition orientation
         * \param[in] binary set to true if the file is to be written in a binary
         * PLY format, false (default) for ASCII
         */
       inline int
       write (const std::string &file_name, const pcl::PCLPointCloud2 &cloud,
              const Eigen::Vector4f &origin = Eigen::Vector4f::Zero (), 
              const Eigen::Quaternionf &orientation = Eigen::Quaternionf::Identity (),
              const bool binary = false) override
       {
         if (binary)
           return (this->writeBinary (file_name, cloud, origin, orientation, true));
         return (this->writeASCII (file_name, cloud, origin, orientation, 8, true));
       }
 
       /** \brief Save point cloud data to a PLY file containing n-D points
         * \param[in] file_name the output file name
         * \param[in] cloud the point cloud data message
         * \param[in] origin the sensor acquisition origin
         * \param[in] orientation the sensor acquisition orientation
         * \param[in] binary set to true if the file is to be written in a binary
         * PLY format, false (default) for ASCII
         * \param[in] use_camera set to true to use camera element and false to
         * use range_grid element
         */
       inline int
       write (const std::string &file_name, const pcl::PCLPointCloud2 &cloud,
              const Eigen::Vector4f &origin = Eigen::Vector4f::Zero (), 
              const Eigen::Quaternionf &orientation = Eigen::Quaternionf::Identity (),
              bool binary = false,
              bool use_camera = true)
       {
         if (binary)
           return (this->writeBinary (file_name, cloud, origin, orientation, use_camera));
         return (this->writeASCII (file_name, cloud, origin, orientation, 8, use_camera));
       }
 
       /** \brief Save point cloud data to a PLY file containing n-D points
         * \param[in] file_name the output file name
         * \param[in] cloud the point cloud data message (boost shared pointer)
         * \param[in] origin the sensor acquisition origin
         * \param[in] orientation the sensor acquisition orientation
         * \param[in] binary set to true if the file is to be written in a binary
         * PLY format, false (default) for ASCII
         * \param[in] use_camera set to true to use camera element and false to
         * use range_grid element
         */
       inline int
       write (const std::string &file_name, const pcl::PCLPointCloud2::ConstPtr &cloud,
              const Eigen::Vector4f &origin = Eigen::Vector4f::Zero (), 
              const Eigen::Quaternionf &orientation = Eigen::Quaternionf::Identity (),
              bool binary = false,
              bool use_camera = true)
       {
         return (write (file_name, *cloud, origin, orientation, binary, use_camera));
       }
 
       /** \brief Save point cloud data to a PLY file containing n-D points
         * \param[in] file_name the output file name
         * \param[in] cloud the pcl::PointCloud data
         * \param[in] binary set to true if the file is to be written in a binary
         * PLY format, false (default) for ASCII
         * \param[in] use_camera set to true to use camera element and false to
         * use range_grid element
         */
       template<typename PointT> inline int
       write (const std::string &file_name, 
              const pcl::PointCloud<PointT> &cloud, 
              bool binary = false,
              bool use_camera = true)
       {
         Eigen::Vector4f origin = cloud.sensor_origin_;
         Eigen::Quaternionf orientation = cloud.sensor_orientation_;
 
         pcl::PCLPointCloud2 blob;
         pcl::toPCLPointCloud2 (cloud, blob);
 
         // Save the data
         return (this->write (file_name, blob, origin, orientation, binary, use_camera));
       }
       
     private:
       /** \brief Generate a PLY header.
         * \param[in] cloud the input point cloud
         * \param[in] binary whether the PLY file should be saved as binary data (true) or ascii (false)
         */
       std::string
       generateHeader (const pcl::PCLPointCloud2 &cloud,
                       const Eigen::Vector4f &origin, 
                       const Eigen::Quaternionf &orientation,
                       bool binary, 
                       bool use_camera,
                       int valid_points);
       
       void
-      writeContentWithCameraASCII (int nr_points, 
-                                   int point_size,
+      writeContentWithCameraASCII (int nr_points,
                                    const pcl::PCLPointCloud2 &cloud,
                                    const Eigen::Vector4f &origin, 
                                    const Eigen::Quaternionf &orientation,
                                    std::ofstream& fs);
 
       void
-      writeContentWithRangeGridASCII (int nr_points, 
-                                      int point_size,
+      writeContentWithRangeGridASCII (int nr_points,
                                       const pcl::PCLPointCloud2 &cloud,
                                       std::ostringstream& fs,
                                       int& nb_valid_points);
   };
 
   namespace io
   {
     /** \brief Load a PLY v.6 file into a PCLPointCloud2 type.
       *
       * Any PLY files containing sensor data will generate a warning as a
       * pcl/PCLPointCloud2 message cannot hold the sensor origin.
       *
       * \param[in] file_name the name of the file to load
       * \param[in] cloud the resultant templated point cloud
       * \ingroup io
       */
     inline int
     loadPLYFile (const std::string &file_name, pcl::PCLPointCloud2 &cloud)
     {
       pcl::PLYReader p;
       return (p.read (file_name, cloud));
     }
 
     /** \brief Load any PLY file into a PCLPointCloud2 type.
       * \param[in] file_name the name of the file to load
       * \param[in] cloud the resultant templated point cloud
       * \param[in] origin the sensor acquisition origin (only for > PLY_V7 - null if not present)
       * \param[in] orientation the sensor acquisition orientation if available, 
       * identity if not present
       * \ingroup io
       */
     inline int
     loadPLYFile (const std::string &file_name, pcl::PCLPointCloud2 &cloud,
                  Eigen::Vector4f &origin, Eigen::Quaternionf &orientation)
     {
       pcl::PLYReader p;
       int ply_version;
       return (p.read (file_name, cloud, origin, orientation, ply_version));
     }
 
     /** \brief Load any PLY file into a templated PointCloud type
       * \param[in] file_name the name of the file to load
       * \param[in] cloud the resultant templated point cloud
       * \ingroup io
       */
     template<typename PointT> inline int
     loadPLYFile (const std::string &file_name, pcl::PointCloud<PointT> &cloud)
     {
       pcl::PLYReader p;
       return (p.read (file_name, cloud));
     }
 
     /** \brief Load a PLY file into a PolygonMesh type.
       *
       * Any PLY files containing sensor data will generate a warning as a
       * pcl/PolygonMesh message cannot hold the sensor origin.
       *
       * \param[in] file_name the name of the file to load
       * \param[in] mesh the resultant polygon mesh
       * \ingroup io
       */
     inline int
     loadPLYFile (const std::string &file_name, pcl::PolygonMesh &mesh)
     {
       pcl::PLYReader p;
       return (p.read (file_name, mesh));
     }
 
     /** \brief Save point cloud data to a PLY file containing n-D points
       * \param[in] file_name the output file name
       * \param[in] cloud the point cloud data message
       * \param[in] origin the sensor data acquisition origin (translation)
       * \param[in] orientation the sensor data acquisition origin (rotation)
       * \param[in] binary_mode true for binary mode, false (default) for ASCII
       * \param[in] use_camera
       * \ingroup io
       */
     inline int 
     savePLYFile (const std::string &file_name, const pcl::PCLPointCloud2 &cloud,
                  const Eigen::Vector4f &origin = Eigen::Vector4f::Zero (), 
                  const Eigen::Quaternionf &orientation = Eigen::Quaternionf::Identity (),
                  bool binary_mode = false, bool use_camera = true)
     {
       PLYWriter w;
       return (w.write (file_name, cloud, origin, orientation, binary_mode, use_camera));
     }
 
     /** \brief Templated version for saving point cloud data to a PLY file
       * containing a specific given cloud format
       * \param[in] file_name the output file name
       * \param[in] cloud the point cloud data message
       * \param[in] binary_mode true for binary mode, false (default) for ASCII
       * \ingroup io
       */
     template<typename PointT> inline int
     savePLYFile (const std::string &file_name, const pcl::PointCloud<PointT> &cloud, bool binary_mode = false)
     {
       PLYWriter w;
       return (w.write<PointT> (file_name, cloud, binary_mode));
     }
 
     /** \brief Templated version for saving point cloud data to a PLY file
       * containing a specific given cloud format.
       * \param[in] file_name the output file name
       * \param[in] cloud the point cloud data message
       * \ingroup io
       */
     template<typename PointT> inline int
     savePLYFileASCII (const std::string &file_name, const pcl::PointCloud<PointT> &cloud)
     {
       PLYWriter w;
       return (w.write<PointT> (file_name, cloud, false));
     }
 
     /** \brief Templated version for saving point cloud data to a PLY file containing a specific given cloud format.
       * \param[in] file_name the output file name
       * \param[in] cloud the point cloud data message
       * \ingroup io
       */
     template<typename PointT> inline int
     savePLYFileBinary (const std::string &file_name, const pcl::PointCloud<PointT> &cloud)
     {
       PLYWriter w;
       return (w.write<PointT> (file_name, cloud, true));
     }
 
     /** \brief Templated version for saving point cloud data to a PLY file containing a specific given cloud format
       * \param[in] file_name the output file name
       * \param[in] cloud the point cloud data message
       * \param[in] indices the set of indices to save
       * \param[in] binary_mode true for binary mode, false (default) for ASCII
       * \ingroup io
       */
     template<typename PointT> int
     savePLYFile (const std::string &file_name, const pcl::PointCloud<PointT> &cloud,
                  const pcl::Indices &indices, bool binary_mode = false)
     {
       // Copy indices to a new point cloud
       pcl::PointCloud<PointT> cloud_out;
       copyPointCloud (cloud, indices, cloud_out);
       // Save the data
       PLYWriter w;
       return (w.write<PointT> (file_name, cloud_out, binary_mode));
     }
 
     /** \brief Saves a PolygonMesh in ascii PLY format.
       * \param[in] file_name the name of the file to write to disk
       * \param[in] mesh the polygonal mesh to save
       * \param[in] precision the output ASCII precision default 5
       * \ingroup io
       */
     PCL_EXPORTS int
     savePLYFile (const std::string &file_name, const pcl::PolygonMesh &mesh, unsigned precision = 5);
     
     /** \brief Saves a PolygonMesh in binary PLY format.
       * \param[in] file_name the name of the file to write to disk
       * \param[in] mesh the polygonal mesh to save
       * \ingroup io
       */
     PCL_EXPORTS int
     savePLYFileBinary (const std::string &file_name, const pcl::PolygonMesh &mesh);
   }
 }
diff --git a/io/src/ply_io.cpp b/io/src/ply_io.cpp
index ff5a3706b..3e584a22a 100644
--- a/io/src/ply_io.cpp
+++ b/io/src/ply_io.cpp
@@ -1,51 +1,52 @@
 /*
  * Software License Agreement (BSD License)
  *
  *  Copyright (c) 2009, Willow Garage, Inc.
  *  All rights reserved.
  *
  *  Redistribution and use in source and binary forms, with or without
  *  modification, are permitted provided that the following conditions
  *  are met:
  *
  *   * Redistributions of source code must retain the above copyright
  *     notice, this list of conditions and the following disclaimer.
  *   * Redistributions in binary form must reproduce the above
  *     copyright notice, this list of conditions and the following
  *     disclaimer in the documentation and/or other materials provided
  *     with the distribution.
  *   * Neither the name of Willow Garage, Inc. nor the names of its
  *     contributors may be used to endorse or promote products derived
  *     from this software without specific prior written permission.
  *
  *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  *  POSSIBILITY OF SUCH DAMAGE.
  *
  * $Id$
  *
  */
 
 #include <pcl/point_types.h>
 #include <pcl/common/io.h>
 #include <pcl/io/ply_io.h>
 
+#include <algorithm>
 #include <cstdlib>
 #include <fstream>
 #include <functional>
 #include <string>
 #include <tuple>
 
 // https://www.boost.org/doc/libs/1_70_0/libs/filesystem/doc/index.htm#Coding-guidelines
 #define BOOST_FILESYSTEM_NO_DEPRECATED
 #include <boost/filesystem.hpp>
 #include <boost/algorithm/string.hpp> // for split
@@ -136,222 +137,232 @@ pcl::PLYReader::amendProperty (const std::string& old_name, const std::string& n
 namespace pcl
 {
   template <>
   std::function<void (pcl::io::ply::float32)>
   PLYReader::scalarPropertyDefinitionCallback (const std::string& element_name, const std::string& property_name)
   {
     if (element_name == "vertex")
     {
       appendScalarProperty<pcl::io::ply::float32> (property_name, 1);
       return ([this] (pcl::io::ply::float32 value) { vertexScalarPropertyCallback<pcl::io::ply::float32> (value); });
     }
     if (element_name == "camera")
     {
       if (property_name == "view_px")
       {
         return [this] (const float& value) { originXCallback (value); };
       }
       if (property_name == "view_py")
       {
         return [this] (const float& value) { originYCallback (value); };
       }
       if (property_name == "view_pz")
       {
         return [this] (const float& value) { originZCallback (value); };
       }
       if (property_name == "x_axisx")
       {
         return [this] (const float& value) { orientationXaxisXCallback (value); };
       }
       if (property_name == "x_axisy")
       {
         return [this] (const float& value) { orientationXaxisYCallback (value); };
       }
       if (property_name == "x_axisz")
       {
         return [this] (const float& value) { orientationXaxisZCallback (value); };
       }
       if (property_name == "y_axisx")
       {
         return [this] (const float& value) { orientationYaxisXCallback (value); };
       }
       if (property_name == "y_axisy")
       {
         return [this] (const float& value) { orientationYaxisYCallback (value); };
       }
       if (property_name == "y_axisz")
       {
         return [this] (const float& value) { orientationYaxisZCallback (value); };
       }
       if (property_name == "z_axisx")
       {
         return [this] (const float& value) { orientationZaxisXCallback (value); };
       }
       if (property_name == "z_axisy")
       {
         return [this] (const float& value) { orientationZaxisYCallback (value); };
       }
       if (property_name == "z_axisz")
       {
         return [this] (const float& value) { orientationZaxisZCallback (value); };
       }
     }
     return {};
   }
 
   template <> std::function<void (pcl::io::ply::uint8)>
   PLYReader::scalarPropertyDefinitionCallback (const std::string& element_name, const std::string& property_name)
   {
     if (element_name == "vertex")
     {
       if ((property_name == "red") || (property_name == "green") || (property_name == "blue") ||
           (property_name == "diffuse_red") || (property_name == "diffuse_green") || (property_name == "diffuse_blue"))
       {
         if ((property_name == "red") || (property_name == "diffuse_red"))
           appendScalarProperty<pcl::io::ply::float32> ("rgb");
         return [this, property_name] (pcl::io::ply::uint8 color) { vertexColorCallback (property_name, color); };
       }
       if (property_name == "alpha")
       {
         amendProperty ("rgb", "rgba", pcl::PCLPointField::UINT32);
         return [this] (pcl::io::ply::uint8 alpha) { vertexAlphaCallback (alpha); };
       }
       if (property_name == "intensity")
       {
         appendScalarProperty<pcl::io::ply::float32> (property_name);
         return [this] (pcl::io::ply::uint8 intensity) { vertexIntensityCallback (intensity); };
       }
       appendScalarProperty<pcl::io::ply::uint8> (property_name);
       return ([this] (pcl::io::ply::uint8 value) { vertexScalarPropertyCallback<pcl::io::ply::uint8> (value); });
     }
     return {};
   }
 
   template <> std::function<void (pcl::io::ply::int32)>
   PLYReader::scalarPropertyDefinitionCallback (const std::string& element_name, const std::string& property_name)
   {
     if (element_name == "vertex")
     {
       appendScalarProperty<pcl::io::ply::int32> (property_name, 1);
       return ([this] (pcl::io::ply::uint32 value) { vertexScalarPropertyCallback<pcl::io::ply::uint32> (value); });
     }
     if (element_name == "camera")
     {
       if (property_name == "viewportx")
       {
         return [this] (const int& width) { cloudWidthCallback (width); };
       }
       if (property_name == "viewporty")
       {
         return [this] (const int& height) { cloudHeightCallback (height); };
       }
       return {};
     }
     return {};
   }
 
   template <typename Scalar> std::function<void (Scalar)>
   PLYReader::scalarPropertyDefinitionCallback (const std::string& element_name, const std::string& property_name)
   {
     if (element_name == "vertex")
     {
       appendScalarProperty<Scalar> (property_name, 1);
       return ([this] (Scalar value) { vertexScalarPropertyCallback<Scalar> (value); });
     }
     return {};
   }
 
   template<typename T> inline
   std::enable_if_t<std::is_floating_point<T>::value>
   unsetDenseFlagIfNotFinite(T value, PCLPointCloud2* cloud)
   {
     //MSVC is missing bool std::isfinite(IntegralType arg); variant, so we implement an own template specialization for this
     if (!std::isfinite(value))
       cloud->is_dense = false;
   }
 
   template<typename T> inline
   std::enable_if_t<std::is_integral<T>::value>
   unsetDenseFlagIfNotFinite(T /* value */, PCLPointCloud2* /* cloud */)
   {
   }
 
   template<typename Scalar> void
   PLYReader::vertexScalarPropertyCallback (Scalar value)
   {
-    unsetDenseFlagIfNotFinite(value, cloud_);
-
-    memcpy (&cloud_->data[vertex_count_ * cloud_->point_step + vertex_offset_before_],
-            &value,
-            sizeof (Scalar));
-    vertex_offset_before_ += static_cast<int> (sizeof (Scalar));
+    try
+    {
+      unsetDenseFlagIfNotFinite(value, cloud_);
+      cloud_->at<Scalar>(vertex_count_, vertex_offset_before_) = value;
+      vertex_offset_before_ += static_cast<int> (sizeof (Scalar));
+    }
+    catch(const std::out_of_range&)
+    {
+      PCL_WARN ("[pcl::PLYReader::vertexScalarPropertyCallback] Incorrect data index specified (%lu)!\n", vertex_count_ * cloud_->point_step + vertex_offset_before_);
+      assert(false);
+    }
   }
 
   template <typename SizeType> void
   PLYReader::vertexListPropertyBeginCallback (const std::string& name, SizeType size)
   {
     // Adjust size only once
     if (vertex_count_ == 0)
     {
       auto finder = cloud_->fields.rbegin ();
       for (; finder != cloud_->fields.rend (); ++finder)
         if (finder->name == name)
           break;
       assert (finder != cloud_->fields.rend ());
       finder->count = size;
     }
   }
 
   template<typename ContentType> void
   PLYReader::vertexListPropertyContentCallback (ContentType value)
   {
-    unsetDenseFlagIfNotFinite(value, cloud_);
-
-    memcpy (&cloud_->data[vertex_count_ * cloud_->point_step + vertex_offset_before_],
-            &value,
-            sizeof (ContentType));
-    vertex_offset_before_ += static_cast<int> (sizeof (ContentType));
+    try
+    {
+      unsetDenseFlagIfNotFinite(value, cloud_);
+      cloud_->at<ContentType>(vertex_count_, vertex_offset_before_) = value;
+      vertex_offset_before_ += static_cast<int> (sizeof (ContentType));
+    }
+    catch(const std::out_of_range&)
+    {
+      PCL_WARN ("[pcl::PLYReader::vertexListPropertyContentCallback] Incorrect data index specified (%lu)!\n", vertex_count_ * cloud_->point_step + vertex_offset_before_);
+      assert(false);
+    }
   }
 
   template <typename SizeType, typename ContentType>
   std::tuple<std::function<void (SizeType)>, std::function<void (ContentType)>, std::function<void ()> >
   pcl::PLYReader::listPropertyDefinitionCallback (const std::string& element_name, const std::string& property_name)
   {
     if ((element_name == "range_grid") && (property_name == "vertex_indices" || property_name == "vertex_index"))
     {
       return std::tuple<std::function<void (SizeType)>, std::function<void (ContentType)>, std::function<void ()> > (
         [this] (SizeType size) { rangeGridVertexIndicesBeginCallback (size); },
         [this] (ContentType vertex_index) { rangeGridVertexIndicesElementCallback (vertex_index); },
         [this] { rangeGridVertexIndicesEndCallback (); }
       );
     }
     if ((element_name == "face") && (property_name == "vertex_indices" || property_name == "vertex_index") && polygons_)
     {
       return std::tuple<std::function<void (SizeType)>, std::function<void (ContentType)>, std::function<void ()> > (
         [this] (SizeType size) { faceVertexIndicesBeginCallback (size); },
         [this] (ContentType vertex_index) { faceVertexIndicesElementCallback (vertex_index); },
         [this] { faceVertexIndicesEndCallback (); }
       );
     }
     if (element_name == "vertex")
     {
       cloud_->fields.emplace_back();
       pcl::PCLPointField &current_field = cloud_->fields.back ();
       current_field.name = property_name;
       current_field.offset = cloud_->point_step;
       current_field.datatype = pcl::traits::asEnum<ContentType>::value;
       current_field.count = 1u; // value will be updated once first vertex is read
       if (sizeof (ContentType) + cloud_->point_step < std::numeric_limits<std::uint32_t>::max ())
         cloud_->point_step += static_cast<std::uint32_t> (sizeof (ContentType));
       else
         cloud_->point_step = static_cast<std::uint32_t> (std::numeric_limits<std::uint32_t>::max ());
       do_resize_ = true;
       return std::tuple<std::function<void (SizeType)>, std::function<void (ContentType)>, std::function<void ()> > (
         std::bind (&pcl::PLYReader::vertexListPropertyBeginCallback<SizeType>, this, property_name, std::placeholders::_1),
         [this] (ContentType value) { vertexListPropertyContentCallback (value); },
         [this] { vertexListPropertyEndCallback (); }
       );
     }
     PCL_WARN("[pcl::PLYReader::listPropertyDefinitionCallback] no fitting callbacks. element_name=%s, property_name=%s\n", element_name.c_str(), property_name.c_str());
     return {};
   }
 }
@@ -360,48 +371,48 @@ void
 pcl::PLYReader::vertexColorCallback (const std::string& color_name, pcl::io::ply::uint8 color)
 {
   if ((color_name == "red") || (color_name == "diffuse_red"))
   {
     r_ = std::int32_t (color);
     rgb_offset_before_ = vertex_offset_before_;
   }
   if ((color_name == "green") || (color_name == "diffuse_green"))
   {
     g_ = std::int32_t (color);
   }
   if ((color_name == "blue") || (color_name == "diffuse_blue"))
   {
     b_ = std::int32_t (color);
     std::int32_t rgb = r_ << 16 | g_ << 8 | b_;
-    memcpy (&cloud_->data[vertex_count_ * cloud_->point_step + rgb_offset_before_],
-            &rgb,
-            sizeof (pcl::io::ply::float32));
-    vertex_offset_before_ += static_cast<int> (sizeof (pcl::io::ply::float32));
+    try
+    {
+      cloud_->at<std::int32_t>(vertex_count_, rgb_offset_before_) = rgb;
+      vertex_offset_before_ += static_cast<int> (sizeof (pcl::io::ply::float32));
+    }
+    catch(const std::out_of_range&)
+    {
+      PCL_WARN ("[pcl::PLYReader::vertexColorCallback] Incorrect data index specified (%lu)!\n", vertex_count_ * cloud_->point_step + rgb_offset_before_);
+      assert(false);
+    }
   }
 }
 
 void
 pcl::PLYReader::vertexAlphaCallback (pcl::io::ply::uint8 alpha)
 {
-  a_ = std::uint32_t (alpha);
   // get anscient rgb value and store it in rgba
-  memcpy (&rgba_,
-          &cloud_->data[vertex_count_ * cloud_->point_step + rgb_offset_before_],
-          sizeof (pcl::io::ply::float32));
+  rgba_ = cloud_->at<std::uint32_t>(vertex_count_, rgb_offset_before_);
   // append alpha
+  a_ = std::uint32_t (alpha);
   rgba_ |= a_ << 24;
   // put rgba back
-  memcpy (&cloud_->data[vertex_count_ * cloud_->point_step + rgb_offset_before_],
-          &rgba_,
-          sizeof (std::uint32_t));
+  cloud_->at<std::uint32_t>(vertex_count_, rgb_offset_before_) = rgba_;
 }
 
 void
 pcl::PLYReader::vertexIntensityCallback (pcl::io::ply::uint8 intensity)
 {
   pcl::io::ply::float32 intensity_ (intensity);
-  memcpy (&cloud_->data[vertex_count_ * cloud_->point_step + vertex_offset_before_],
-          &intensity_,
-          sizeof (pcl::io::ply::float32));
+  cloud_->at<pcl::io::ply::float32>(vertex_count_, vertex_offset_before_) = intensity_;
   vertex_offset_before_ += static_cast<int> (sizeof (pcl::io::ply::float32));
 }
 
@@ -564,64 +575,96 @@ int
 pcl::PLYReader::read (const std::string &file_name, pcl::PCLPointCloud2 &cloud,
                       Eigen::Vector4f &origin, Eigen::Quaternionf &orientation, int &ply_version, const int)
 {
   // kept only for backward compatibility
   int data_type;
   unsigned int data_idx;
 
   if (!fs::exists (file_name))
   {
     PCL_ERROR ("[pcl::PLYReader::read] File (%s) not found!\n",file_name.c_str ());
     return (-1);
   }
 
   if (this->readHeader (file_name, cloud, origin, orientation, ply_version, data_type, data_idx))
   {
     PCL_ERROR ("[pcl::PLYReader::read] problem parsing header!\n");
     return (-1);
   }
 
   // a range_grid element was found ?
   std::size_t r_size;
   if ((r_size  = (*range_grid_).size ()) > 0 && r_size != vertex_count_)
   {
     //cloud.header = cloud_->header;
     std::vector<std::uint8_t> data ((*range_grid_).size () * cloud.point_step);
     const static float f_nan = std::numeric_limits <float>::quiet_NaN ();
     const static double d_nan = std::numeric_limits <double>::quiet_NaN ();
     for (std::size_t r = 0; r < r_size; ++r)
     {
       if ((*range_grid_)[r].empty ())
       {
         for (const auto &field : cloud_->fields)
           if (field.datatype == ::pcl::PCLPointField::FLOAT32)
-            memcpy (&data[r * cloud_->point_step + field.offset],
+          {
+            const auto idx = r * cloud_->point_step + field.offset;
+            if (idx + sizeof (float) > data.size())
+            {
+              PCL_ERROR ("[pcl::PLYReader::read] invalid data index (%lu)!\n", idx);
+              return (-1);
+            }
+            memcpy (&data[idx],
                     reinterpret_cast<const char*> (&f_nan), sizeof (float));
+          }
           else if (field.datatype == ::pcl::PCLPointField::FLOAT64)
-            memcpy (&data[r * cloud_->point_step + field.offset],
+          {
+            const auto idx = r * cloud_->point_step + field.offset;
+            if (idx + sizeof (double) > data.size())
+            {
+              PCL_ERROR ("[pcl::PLYReader::read] invalid data index (%lu)!\n", idx);
+              return (-1);
+            }
+            memcpy (&data[idx],
                     reinterpret_cast<const char*> (&d_nan), sizeof (double));
+          }
           else
-            memset (&data[r * cloud_->point_step + field.offset], 0,
-                    pcl::getFieldSize (field.datatype) * field.count);
+          {
+            const auto idx = r * cloud_->point_step + field.offset;
+            if (idx + pcl::getFieldSize (field.datatype) * field.count > data.size())
+            {
+              PCL_ERROR ("[pcl::PLYReader::read] invalid data index (%lu)!\n", idx);
+              return (-1);
+            }
+            std::fill_n(&data[idx],
+                        pcl::getFieldSize (field.datatype) * field.count, 0);
+          }
       }
       else
-        memcpy (&data[r* cloud_->point_step], &cloud_->data[(*range_grid_)[r][0] * cloud_->point_step], cloud_->point_step);
+      {
+        const auto srcIdx = (*range_grid_)[r][0] * cloud_->point_step;
+        if (srcIdx + cloud_->point_step > cloud_->data.size())
+        {
+          PCL_ERROR ("[pcl::PLYReader::read] invalid data index (%lu)!\n", srcIdx);
+          return (-1);
+        }
+        memcpy (&data[r* cloud_->point_step], &cloud_->data[srcIdx], cloud_->point_step);
+      }
     }
     cloud_->data.swap (data);
   }
 
   orientation_ = Eigen::Quaternionf (orientation);
   origin_ = origin;
 
   for (auto &field : cloud_->fields)
   {
     if (field.name == "nx")
       field.name = "normal_x";
     if (field.name == "ny")
       field.name = "normal_y";
     if (field.name == "nz")
       field.name = "normal_z";
   }
   return (0);
 }
 
 ////////////////////////////////////////////////////////////////////////////////////////
@@ -629,66 +672,98 @@ int
 pcl::PLYReader::read (const std::string &file_name, pcl::PolygonMesh &mesh,
                       Eigen::Vector4f &origin, Eigen::Quaternionf &orientation,
                       int &ply_version, const int offset)
 {
   // kept only for backward compatibility
   int data_type;
   unsigned int data_idx;
   polygons_ = &(mesh.polygons);
 
   if (!fs::exists (file_name))
   {
     PCL_ERROR ("[pcl::PLYReader::read] File (%s) not found!\n",file_name.c_str ());
     return (-1);
   }
 
   if (this->readHeader (file_name, mesh.cloud, origin, orientation, ply_version, data_type, data_idx, offset))
   {
     PCL_ERROR ("[pcl::PLYReader::read] problem parsing header!\n");
     return (-1);
   }
 
   // a range_grid element was found ?
   std::size_t r_size;
   if ((r_size  = (*range_grid_).size ()) > 0 && r_size != vertex_count_)
   {
     //cloud.header = cloud_->header;
     std::vector<std::uint8_t> data ((*range_grid_).size () * mesh.cloud.point_step);
     const static float f_nan = std::numeric_limits <float>::quiet_NaN ();
     const static double d_nan = std::numeric_limits <double>::quiet_NaN ();
     for (std::size_t r = 0; r < r_size; ++r)
     {
       if ((*range_grid_)[r].empty ())
       {
         for (const auto &field : cloud_->fields)
           if (field.datatype == ::pcl::PCLPointField::FLOAT32)
-            memcpy (&data[r * cloud_->point_step + field.offset],
+          {
+            const auto idx = r * cloud_->point_step + field.offset;
+            if (idx + sizeof (float) > data.size())
+            {
+              PCL_ERROR ("[pcl::PLYReader::read] invalid data index (%lu)!\n", idx);
+              return (-1);
+            }
+            memcpy (&data[idx],
                     reinterpret_cast<const char*> (&f_nan), sizeof (float));
+          }
           else if (field.datatype == ::pcl::PCLPointField::FLOAT64)
-            memcpy (&data[r * cloud_->point_step + field.offset],
+          {
+            const auto idx = r * cloud_->point_step + field.offset;
+            if (idx + sizeof (double) > data.size())
+            {
+              PCL_ERROR ("[pcl::PLYReader::read] invalid data index (%lu)!\n", idx);
+              return (-1);
+            }
+            memcpy (&data[idx],
                     reinterpret_cast<const char*> (&d_nan), sizeof (double));
+          }
           else
-            memset (&data[r * cloud_->point_step + field.offset], 0,
-                    pcl::getFieldSize (field.datatype) * field.count);
+          {
+            const auto idx = r * cloud_->point_step + field.offset;
+            if (idx + pcl::getFieldSize (field.datatype) * field.count > data.size())
+            {
+              PCL_ERROR ("[pcl::PLYReader::read] invalid data index (%lu)!\n", idx);
+              return (-1);
+            }
+            std::fill_n(&data[idx],
+                        pcl::getFieldSize (field.datatype) * field.count, 0);
+          }
       }
       else
-        memcpy (&data[r* cloud_->point_step], &cloud_->data[(*range_grid_)[r][0] * cloud_->point_step], cloud_->point_step);
+      {
+        const auto srcIdx = (*range_grid_)[r][0] * cloud_->point_step;
+        if (srcIdx + cloud_->point_step > cloud_->data.size())
+        {
+          PCL_ERROR ("[pcl::PLYReader::read] invalid data index (%lu)!\n", srcIdx);
+          return (-1);
+        }
+        memcpy (&data[r* cloud_->point_step], &cloud_->data[srcIdx], cloud_->point_step);
+      }
     }
     cloud_->data.swap (data);
   }
 
   orientation_ = Eigen::Quaternionf (orientation);
   origin_ = origin;
 
   for (auto &field : cloud_->fields)
   {
     if (field.name == "nx")
       field.name = "normal_x";
     if (field.name == "ny")
       field.name = "normal_y";
     if (field.name == "nz")
       field.name = "normal_z";
   }
   return (0);
 }
 
 ////////////////////////////////////////////////////////////////////////////////////////
@@ -842,333 +917,281 @@ int
 pcl::PLYWriter::writeASCII (const std::string &file_name,
                             const pcl::PCLPointCloud2 &cloud,
                             const Eigen::Vector4f &origin,
                             const Eigen::Quaternionf &orientation,
                             int precision,
                             bool use_camera)
 {
   if (cloud.data.empty ())
   {
     PCL_ERROR ("[pcl::PLYWriter::writeASCII] Input point cloud has no data!\n");
     return (-1);
   }
 
   std::ofstream fs;
   fs.precision (precision);
   // Open file
   fs.open (file_name.c_str ());
   if (!fs)
   {
     PCL_ERROR ("[pcl::PLYWriter::writeASCII] Error during opening (%s)!\n", file_name.c_str ());
     return (-1);
   }
 
   unsigned int nr_points  = cloud.width * cloud.height;
-  unsigned int point_size = static_cast<unsigned int> (cloud.data.size () / nr_points);
 
   // Write the header information if available
   if (use_camera)
   {
     fs << generateHeader (cloud, origin, orientation, false, use_camera, nr_points);
-    writeContentWithCameraASCII (nr_points, point_size, cloud, origin, orientation, fs);
+    writeContentWithCameraASCII (nr_points, cloud, origin, orientation, fs);
   }
   else
   {
     std::ostringstream os;
     int nr_valid_points;
-    writeContentWithRangeGridASCII (nr_points, point_size, cloud, os, nr_valid_points);
+    writeContentWithRangeGridASCII (nr_points, cloud, os, nr_valid_points);
     fs << generateHeader (cloud, origin, orientation, false, use_camera, nr_valid_points);
     fs << os.str ();
   }
 
   // Close file
   fs.close ();
   return (0);
 }
 
 void
 pcl::PLYWriter::writeContentWithCameraASCII (int nr_points,
-                                             int point_size,
                                              const pcl::PCLPointCloud2 &cloud,
                                              const Eigen::Vector4f &origin,
                                              const Eigen::Quaternionf &orientation,
                                              std::ofstream& fs)
 {
   // Iterate through the points
   for (int i = 0; i < nr_points; ++i)
   {
     for (std::size_t d = 0; d < cloud.fields.size (); ++d)
     {
       int count = cloud.fields[d].count;
       if (count == 0)
         count = 1; //workaround
 
       if (count > 1)
         fs << count << " ";
       for (int c = 0; c < count; ++c)
       {
         switch (cloud.fields[d].datatype)
         {
           case pcl::PCLPointField::INT8:
           {
-            char value;
-            memcpy (&value, &cloud.data[i * point_size + cloud.fields[d].offset + c * sizeof (char)], sizeof (char));
-            fs << boost::numeric_cast<int> (value);
+            fs << boost::numeric_cast<int> (cloud.at<char>(i, cloud.fields[d].offset + c * sizeof (char)));
             break;
           }
           case pcl::PCLPointField::UINT8:
           {
-            unsigned char value;
-            memcpy (&value, &cloud.data[i * point_size + cloud.fields[d].offset + c * sizeof (unsigned char)], sizeof (unsigned char));
-            fs << boost::numeric_cast<int> (value);
+            fs << boost::numeric_cast<int> (cloud.at<unsigned char>(i, cloud.fields[d].offset + c * sizeof (unsigned char)));
             break;
           }
           case pcl::PCLPointField::INT16:
           {
-            short value;
-            memcpy (&value, &cloud.data[i * point_size + cloud.fields[d].offset + c * sizeof (short)], sizeof (short));
-            fs << boost::numeric_cast<int> (value);
+            fs << boost::numeric_cast<int> (cloud.at<short>(i, cloud.fields[d].offset + c * sizeof (short)));
             break;
           }
           case pcl::PCLPointField::UINT16:
           {
-            unsigned short value;
-            memcpy (&value, &cloud.data[i * point_size + cloud.fields[d].offset + c * sizeof (unsigned short)], sizeof (unsigned short));
-            fs << boost::numeric_cast<int> (value);
+            fs << boost::numeric_cast<int> (cloud.at<unsigned short>(i, cloud.fields[d].offset + c * sizeof (unsigned short)));
             break;
           }
           case pcl::PCLPointField::INT32:
           {
-            int value;
-            memcpy (&value, &cloud.data[i * point_size + cloud.fields[d].offset + c * sizeof (int)], sizeof (int));
-            fs << value;
+            fs << cloud.at<int>(i, cloud.fields[d].offset + c * sizeof (int));
             break;
           }
           case pcl::PCLPointField::UINT32:
           {
             if (cloud.fields[d].name.find ("rgba") == std::string::npos)
             {
-              unsigned int value;
-              memcpy (&value, &cloud.data[i * point_size + cloud.fields[d].offset + c * sizeof (unsigned int)], sizeof (unsigned int));
-              fs << value;
+              fs << cloud.at<unsigned int>(i, cloud.fields[d].offset + c * sizeof (unsigned int));
             }
             else
             {
-              pcl::RGB color;
-              memcpy (&color, &cloud.data[i * point_size + cloud.fields[d].offset + c * sizeof (unsigned int)], sizeof (pcl::RGB));
-              int r = color.r;
-              int g = color.g;
-              int b = color.b;
-              int a = color.a;
-              fs << r << " " << g << " " << b << " " << a;
+              const pcl::RGB& color = cloud.at<pcl::RGB>(i, cloud.fields[d].offset + c * sizeof (pcl::RGB));
+              fs << static_cast<int>(color.r) << " " << static_cast<int>(color.g) << " " << static_cast<int>(color.b) << " " << static_cast<int>(color.a);
             }
             break;
           }
           case pcl::PCLPointField::FLOAT32:
           {
             if (cloud.fields[d].name.find ("rgb") == std::string::npos)
             {
-              float value;
-              memcpy (&value, &cloud.data[i * point_size + cloud.fields[d].offset + c * sizeof (float)], sizeof (float));
-              fs << value;
+              fs << cloud.at<float>(i, cloud.fields[d].offset + c * sizeof (float));
             }
             else
             {
-              pcl::RGB color;
-              memcpy (&color, &cloud.data[i * point_size + cloud.fields[d].offset + c * sizeof (float)], sizeof (pcl::RGB));
-              int r = color.r;
-              int g = color.g;
-              int b = color.b;
-              fs << r << " " << g << " " << b;
+              const pcl::RGB& color = cloud.at<pcl::RGB>(i, cloud.fields[d].offset + c * sizeof (pcl::RGB));
+              fs << static_cast<int>(color.r) << " " << static_cast<int>(color.g) << " " << static_cast<int>(color.b);
             }
             break;
           }
           case pcl::PCLPointField::FLOAT64:
           {
-            double value;
-            memcpy (&value, &cloud.data[i * point_size + cloud.fields[d].offset + c * sizeof (double)], sizeof (double));
-            fs << value;
+            fs << cloud.at<double>(i, cloud.fields[d].offset + c * sizeof (double));
             break;
           }
           default:
             PCL_WARN ("[pcl::PLYWriter::writeASCII] Incorrect field data type specified (%d)!\n", cloud.fields[d].datatype);
             break;
         }
 
         if (d < cloud.fields.size () - 1 || c < static_cast<int> (cloud.fields[d].count) - 1)
           fs << " ";
       }
     }
     fs << '\n';
   }
   // Append sensor information
   if (origin[3] != 0)
     fs << origin[0]/origin[3] << " " << origin[1]/origin[3] << " " << origin[2]/origin[3] << " ";
   else
     fs << origin[0] << " " << origin[1] << " " << origin[2] << " ";
 
   Eigen::Matrix3f R = orientation.toRotationMatrix ();
   fs << R (0,0) << " " << R (0,1) << " " << R (0,2) << " ";
   fs << R (1,0) << " " << R (1,1) << " " << R (1,2) << " ";
   fs << R (2,0) << " " << R (2,1) << " " << R (2,2) << " ";
   // No focal
   fs << 0 << " ";
   // No scale
   fs << 0 << " " << 0 << " ";
   // No center
   fs << 0 << " " << 0 << " ";
   // Viewport set to width x height
   fs << cloud.width << " " << cloud.height << " ";
   // No corrections
   fs << 0 << " " << 0;
   fs << std::endl;
   fs.flush ();
 }
 
 void
 pcl::PLYWriter::writeContentWithRangeGridASCII (int nr_points,
-                                                int point_size,
                                                 const pcl::PCLPointCloud2 &cloud,
                                                 std::ostringstream& fs,
                                                 int& valid_points)
 {
   valid_points = 0;
   std::vector<std::vector <int> > grids (nr_points);
   // Iterate through the points
   for (int i = 0; i < nr_points; ++i)
   {
     std::ostringstream line;
     bool is_valid_line = true;
     for (std::size_t d = 0; d < cloud.fields.size (); ++d)
     {
       int count = cloud.fields[d].count;
       if (count == 0)
         count = 1; //workaround
       if (count > 1)
         fs << count << " ";
       for (int c = 0; c < count; ++c)
       {
         switch (cloud.fields[d].datatype)
         {
           case pcl::PCLPointField::INT8:
           {
-            char value;
-            memcpy (&value, &cloud.data[i * point_size + cloud.fields[d].offset + c * sizeof (char)], sizeof (char));
-            line << boost::numeric_cast<int> (value);
+            line << boost::numeric_cast<int> (cloud.at<char>(i, cloud.fields[d].offset + c * sizeof (char)));
             break;
           }
           case pcl::PCLPointField::UINT8:
           {
-            unsigned char value;
-            memcpy (&value, &cloud.data[i * point_size + cloud.fields[d].offset + c * sizeof (unsigned char)], sizeof (unsigned char));
-            line << boost::numeric_cast<int> (value);
+            line << boost::numeric_cast<int> (cloud.at<unsigned char>(i, cloud.fields[d].offset + c * sizeof (unsigned char)));
             break;
           }
           case pcl::PCLPointField::INT16:
           {
-            short value;
-            memcpy (&value, &cloud.data[i * point_size + cloud.fields[d].offset + c * sizeof (short)], sizeof (short));
-            line << boost::numeric_cast<int> (value);
+            line << boost::numeric_cast<int> (cloud.at<short>(i, cloud.fields[d].offset + c * sizeof (short)));
             break;
           }
           case pcl::PCLPointField::UINT16:
           {
-            unsigned short value;
-            memcpy (&value, &cloud.data[i * point_size + cloud.fields[d].offset + c * sizeof (unsigned short)], sizeof (unsigned short));
-            line << boost::numeric_cast<int> (value);
+            line << boost::numeric_cast<int> (cloud.at<unsigned short>(i, cloud.fields[d].offset + c * sizeof (unsigned short)));
             break;
           }
           case pcl::PCLPointField::INT32:
           {
-            int value;
-            memcpy (&value, &cloud.data[i * point_size + cloud.fields[d].offset + c * sizeof (int)], sizeof (int));
-            line << value;
+            line << cloud.at<int>(i, cloud.fields[d].offset + c * sizeof (int));
             break;
           }
           case pcl::PCLPointField::UINT32:
           {
             if (cloud.fields[d].name.find ("rgba") == std::string::npos)
             {
-              unsigned int value;
-              memcpy (&value, &cloud.data[i * point_size + cloud.fields[d].offset + c * sizeof (unsigned int)], sizeof (unsigned int));
-              line << value;
+              line << cloud.at<unsigned int>(i, cloud.fields[d].offset + c * sizeof (unsigned int));
             }
             else
             {
-              pcl::RGB color;
-              memcpy (&color, &cloud.data[i * point_size + cloud.fields[d].offset + c * sizeof (unsigned int)], sizeof (pcl::RGB));
-              int r = color.r;
-              int g = color.g;
-              int b = color.b;
-              int a = color.a;
-              line << r << " " << g << " " << b << " " << a;
+              const pcl::RGB& color = cloud.at<pcl::RGB>(i, cloud.fields[d].offset + c * sizeof (pcl::RGB));
+              line << static_cast<int>(color.r) << " " << static_cast<int>(color.g) << " " << static_cast<int>(color.b) << " " << static_cast<int>(color.a);
             }
             break;
           }
           case pcl::PCLPointField::FLOAT32:
           {
             if (cloud.fields[d].name.find ("rgb") == std::string::npos)
             {
-              float value;
-              memcpy (&value, &cloud.data[i * point_size + cloud.fields[d].offset + c * sizeof (float)], sizeof (float));
+              const float& value = cloud.at<float>(i, cloud.fields[d].offset + c * sizeof (float));
               // Test if x-coordinate is NaN, thus an invalid point
               if ("x" == cloud.fields[d].name)
               {
                 if (!std::isfinite(value))
                   is_valid_line = false;
               }
               line << value;
             }
             else
             {
-              pcl::RGB color;
-              memcpy (&color, &cloud.data[i * point_size + cloud.fields[d].offset + c * sizeof (float)], sizeof (pcl::RGB));
-              int r = color.r;
-              int g = color.g;
-              int b = color.b;
-              line << r << " " << g << " " << b;
+              const pcl::RGB& color = cloud.at<pcl::RGB>(i, cloud.fields[d].offset + c * sizeof (pcl::RGB));
+              line << static_cast<int>(color.r) << " " << static_cast<int>(color.g) << " " << static_cast<int>(color.b);
             }
             break;
           }
           case pcl::PCLPointField::FLOAT64:
           {
-            double value;
-            memcpy (&value, &cloud.data[i * point_size + cloud.fields[d].offset + c * sizeof (double)], sizeof (double));
-            line << value;
+            line << cloud.at<double>(i, cloud.fields[d].offset + c * sizeof (double));
             break;
           }
           default:
             PCL_WARN ("[pcl::PLYWriter::writeASCII] Incorrect field data type specified (%d)!\n", cloud.fields[d].datatype);
             break;
         }
 
         if (d < cloud.fields.size () - 1 || c < static_cast<int> (cloud.fields[d].count) - 1)
           line << " ";
       }
     }
 
     if (is_valid_line)
     {
       grids[i].push_back (valid_points);
       fs << line.str () << '\n';
       ++valid_points;
     }
   }
 
   // If point cloud is organized, then append range grid
   if (cloud.height > 1)
   {
     for (int i = 0; i < nr_points; ++i)
     {
       fs << grids [i].size ();
       for (std::vector <int>::const_iterator it = grids [i].begin ();
            it != grids [i].end ();
            ++it)
         fs << " " << *it;
       fs << '\n';
     }
   }
 
   fs.flush ();
 }
 
 ////////////////////////////////////////////////////////////////////////////////////////
@@ -1176,270 +1199,243 @@ int
 pcl::PLYWriter::writeBinary (const std::string &file_name,
                              const pcl::PCLPointCloud2 &cloud,
                              const Eigen::Vector4f &origin,
                              const Eigen::Quaternionf &orientation,
                              bool use_camera)
 {
   if (cloud.data.empty ())
   {
     PCL_ERROR ("[pcl::PLYWriter::writeBinary] Input point cloud has no data!\n");
     return (-1);
   }
 
   std::ofstream fs;
   fs.open (file_name.c_str ());      // Open file
   if (!fs)
   {
     PCL_ERROR ("[pcl::PLYWriter::writeBinary] Error during opening (%s)!\n", file_name.c_str ());
     return (-1);
   }
 
   unsigned int nr_points  = cloud.width * cloud.height;
-  unsigned int point_size = static_cast<unsigned int> (cloud.data.size () / nr_points);
 
   // Compute the range_grid, if necessary, and then write out the PLY header
   bool doRangeGrid = !use_camera && cloud.height > 1;
   std::vector<pcl::io::ply::int32> rangegrid (nr_points);
   if (doRangeGrid)
   {
     unsigned int valid_points = 0;
 
     // Determine the field containing the x-coordinate
     int xfield = pcl::getFieldIndex (cloud, "x");
     if (xfield >= 0 && cloud.fields[xfield].datatype != pcl::PCLPointField::FLOAT32)
       xfield = -1;
 
     // If no x-coordinate field exists, then assume all points are valid
     if (xfield < 0)
     {
       for (unsigned int i=0; i < nr_points; ++i)
         rangegrid[i] = i;
       valid_points = nr_points;
     }
     // Otherwise, look at their x-coordinates to determine if points are valid
     else
     {
       for (std::size_t i=0; i < nr_points; ++i)
       {
-        float value;
-        memcpy(&value, &cloud.data[i * point_size + cloud.fields[xfield].offset], sizeof(float));
+        const float& value = cloud.at<float>(i, cloud.fields[xfield].offset);
         if (std::isfinite(value))
         {
           rangegrid[i] = valid_points;
           ++valid_points;
         }
         else
           rangegrid[i] = -1;
       }
     }
     fs << generateHeader (cloud, origin, orientation, true, use_camera, valid_points);
   }
   else
   {
     fs << generateHeader (cloud, origin, orientation, true, use_camera, nr_points);
   }
 
   // Close the file
   fs.close ();
   // Open file in binary appendable
   std::ofstream fpout (file_name.c_str (), std::ios::app | std::ios::binary);
   if (!fpout)
   {
     PCL_ERROR ("[pcl::PLYWriter::writeBinary] Error during reopening (%s)!\n", file_name.c_str ());
     return (-1);
   }
 
   // Iterate through the points
   for (unsigned int i = 0; i < nr_points; ++i)
   {
     // Skip writing any invalid points from range_grid
     if (doRangeGrid && rangegrid[i] < 0)
       continue;
 
     std::size_t total = 0;
     for (std::size_t d = 0; d < cloud.fields.size (); ++d)
     {
       int count = cloud.fields[d].count;
       if (count == 0)
         count = 1; //workaround
       if (count > 1)
       {
         static unsigned int ucount (count);
         fpout.write (reinterpret_cast<const char*> (&ucount), sizeof (unsigned int));
       }
       // Ignore invalid padded dimensions that are inherited from binary data
       if (cloud.fields[d].name == "_")
       {
         total += cloud.fields[d].count; // jump over this many elements in the string token
         continue;
       }
 
       for (int c = 0; c < count; ++c)
       {
         switch (cloud.fields[d].datatype)
         {
           case pcl::PCLPointField::INT8:
           {
-            char value;
-            memcpy (&value, &cloud.data[i * point_size + cloud.fields[d].offset + (total + c) * sizeof (char)], sizeof (char));
-            fpout.write (reinterpret_cast<const char*> (&value), sizeof (char));
+            fpout.write (&cloud.at<char>(i, cloud.fields[d].offset + (total + c) * sizeof (char)), sizeof (char));
             break;
           }
           case pcl::PCLPointField::UINT8:
           {
-            unsigned char value;
-            memcpy (&value, &cloud.data[i * point_size + cloud.fields[d].offset + (total + c) * sizeof (unsigned char)], sizeof (unsigned char));
-            fpout.write (reinterpret_cast<const char*> (&value), sizeof (unsigned char));
+            fpout.write (reinterpret_cast<const char*> (&cloud.at<unsigned char>(i, cloud.fields[d].offset + (total + c) * sizeof (unsigned char))), sizeof (unsigned char));
             break;
           }
           case pcl::PCLPointField::INT16:
           {
-            short value;
-            memcpy (&value, &cloud.data[i * point_size + cloud.fields[d].offset + (total + c) * sizeof (short)], sizeof (short));
-            fpout.write (reinterpret_cast<const char*> (&value), sizeof (short));
+            fpout.write (reinterpret_cast<const char*> (&cloud.at<short>(i, cloud.fields[d].offset + (total + c) * sizeof (short))), sizeof (short));
             break;
           }
           case pcl::PCLPointField::UINT16:
           {
-            unsigned short value;
-            memcpy (&value, &cloud.data[i * point_size + cloud.fields[d].offset + (total + c) * sizeof (unsigned short)], sizeof (unsigned short));
-            fpout.write (reinterpret_cast<const char*> (&value), sizeof (unsigned short));
+            fpout.write (reinterpret_cast<const char*> (&cloud.at<unsigned short>(i, cloud.fields[d].offset + (total + c) * sizeof (unsigned short))), sizeof (unsigned short));
             break;
           }
           case pcl::PCLPointField::INT32:
           {
-            int value;
-            memcpy (&value, &cloud.data[i * point_size + cloud.fields[d].offset + (total + c) * sizeof (int)], sizeof (int));
-            fpout.write (reinterpret_cast<const char*> (&value), sizeof (int));
+            fpout.write (reinterpret_cast<const char*> (&cloud.at<int>(i, cloud.fields[d].offset + (total + c) * sizeof (int))), sizeof (int));
             break;
           }
           case pcl::PCLPointField::UINT32:
           {
             if (cloud.fields[d].name.find ("rgba") == std::string::npos)
             {
-              unsigned int value;
-              memcpy (&value, &cloud.data[i * point_size + cloud.fields[d].offset + (total + c) * sizeof (unsigned int)], sizeof (unsigned int));
-              fpout.write (reinterpret_cast<const char*> (&value), sizeof (unsigned int));
+              fpout.write (reinterpret_cast<const char*> (&cloud.at<unsigned int>(i, cloud.fields[d].offset + (total + c) * sizeof (unsigned int))), sizeof (unsigned int));
             }
             else
             {
-              pcl::RGB color;
-              memcpy (&color, &cloud.data[i * point_size + cloud.fields[d].offset + (total + c) * sizeof (unsigned int)], sizeof (pcl::RGB));
-              unsigned char r = color.r;
-              unsigned char g = color.g;
-              unsigned char b = color.b;
-              unsigned char a = color.a;
-              fpout.write (reinterpret_cast<const char*> (&r), sizeof (unsigned char));
-              fpout.write (reinterpret_cast<const char*> (&g), sizeof (unsigned char));
-              fpout.write (reinterpret_cast<const char*> (&b), sizeof (unsigned char));
-              fpout.write (reinterpret_cast<const char*> (&a), sizeof (unsigned char));
+              const pcl::RGB& color = cloud.at<pcl::RGB>(i, cloud.fields[d].offset + (total + c) * sizeof (pcl::RGB));
+              fpout.write (reinterpret_cast<const char*> (&color.r), sizeof (unsigned char));
+              fpout.write (reinterpret_cast<const char*> (&color.g), sizeof (unsigned char));
+              fpout.write (reinterpret_cast<const char*> (&color.b), sizeof (unsigned char));
+              fpout.write (reinterpret_cast<const char*> (&color.a), sizeof (unsigned char));
             }
             break;
           }
           case pcl::PCLPointField::FLOAT32:
           {
             if (cloud.fields[d].name.find ("rgb") == std::string::npos)
             {
-              float value;
-              memcpy (&value, &cloud.data[i * point_size + cloud.fields[d].offset + (total + c) * sizeof (float)], sizeof (float));
-              fpout.write (reinterpret_cast<const char*> (&value), sizeof (float));
+              fpout.write (reinterpret_cast<const char*> (&cloud.at<float>(i, cloud.fields[d].offset + (total + c) * sizeof (float))), sizeof (float));
             }
             else
             {
-              pcl::RGB color;
-              memcpy (&color, &cloud.data[i * point_size + cloud.fields[d].offset + (total + c) * sizeof (float)], sizeof (pcl::RGB));
-              unsigned char r = color.r;
-              unsigned char g = color.g;
-              unsigned char b = color.b;
-              fpout.write (reinterpret_cast<const char*> (&r), sizeof (unsigned char));
-              fpout.write (reinterpret_cast<const char*> (&g), sizeof (unsigned char));
-              fpout.write (reinterpret_cast<const char*> (&b), sizeof (unsigned char));
+              const pcl::RGB& color = cloud.at<pcl::RGB>(i, cloud.fields[d].offset + (total + c) * sizeof (pcl::RGB));
+              fpout.write (reinterpret_cast<const char*> (&color.r), sizeof (unsigned char));
+              fpout.write (reinterpret_cast<const char*> (&color.g), sizeof (unsigned char));
+              fpout.write (reinterpret_cast<const char*> (&color.b), sizeof (unsigned char));
             }
             break;
           }
           case pcl::PCLPointField::FLOAT64:
           {
-            double value;
-            memcpy (&value, &cloud.data[i * point_size + cloud.fields[d].offset + (total + c) * sizeof (double)], sizeof (double));
-            fpout.write (reinterpret_cast<const char*> (&value), sizeof (double));
+            fpout.write (reinterpret_cast<const char*> (&cloud.at<double>(i, cloud.fields[d].offset + (total + c) * sizeof (double))), sizeof (double));
             break;
           }
           default:
             PCL_WARN ("[pcl::PLYWriter::writeBinary] Incorrect field data type specified (%d)!\n", cloud.fields[d].datatype);
             break;
         }
       }
     }
   }
 
   if (use_camera)
   {
     // Append sensor information
     float t;
     for (int i = 0; i < 3; ++i)
     {
       if (origin[3] != 0)
         t = origin[i]/origin[3];
       else
         t = origin[i];
       fpout.write (reinterpret_cast<const char*> (&t), sizeof (float));
     }
     Eigen::Matrix3f R = orientation.toRotationMatrix ();
     for (int i = 0; i < 3; ++i)
       for (int j = 0; j < 3; ++j)
     {
       fpout.write (reinterpret_cast<const char*> (&R (i, j)),sizeof (float));
     }
 
     /////////////////////////////////////////////////////
     // Append those properties directly.               //
     // They are for perspective cameras so just put 0  //
     //                                                 //
     // property float focal                            //
     // property float scalex                           //
     // property float scaley                           //
     // property float centerx                          //
     // property float centery                          //
     // and later on                                    //
     // property float k1                               //
     // property float k2                               //
     /////////////////////////////////////////////////////
 
     const float zerof = 0;
     for (int i = 0; i < 5; ++i)
       fpout.write (reinterpret_cast<const char*> (&zerof), sizeof (float));
 
     // width and height
     int width = cloud.width;
     fpout.write (reinterpret_cast<const char*> (&width), sizeof (int));
 
     int height = cloud.height;
     fpout.write (reinterpret_cast<const char*> (&height), sizeof (int));
 
     for (int i = 0; i < 2; ++i)
       fpout.write (reinterpret_cast<const char*> (&zerof), sizeof (float));
   }
   else if (doRangeGrid)
   {
     // Write out range_grid
     for (std::size_t i=0; i < nr_points; ++i)
     {
       pcl::io::ply::uint8 listlen;
 
       if (rangegrid[i] >= 0)
       {
         listlen = 1;
         fpout.write (reinterpret_cast<const char*> (&listlen), sizeof (pcl::io::ply::uint8));
         fpout.write (reinterpret_cast<const char*> (&rangegrid[i]), sizeof (pcl::io::ply::int32));
       }
       else
       {
         listlen = 0;
         fpout.write (reinterpret_cast<const char*> (&listlen), sizeof (pcl::io::ply::uint8));
       }
     }
   }
 
   // Close file
   fpout.close ();
   return (0);
 }
@@ -1493,98 +1489,89 @@ int
 pcl::io::savePLYFile (const std::string &file_name, const pcl::PolygonMesh &mesh, unsigned precision)
 {
   if (mesh.cloud.data.empty ())
   {
     PCL_ERROR ("[pcl::io::savePLYFile] Input point cloud has no data!\n");
     return (-1);
   }
   // Open file
   std::ofstream fs;
   fs.precision (precision);
   fs.open (file_name.c_str ());
   if (!fs)
   {
     PCL_ERROR ("[pcl::io::savePLYFile] Error during opening (%s)!\n", file_name.c_str ());
     return (-1);
   }
 
   // number of points
   std::size_t nr_points  = mesh.cloud.width * mesh.cloud.height;
-  std::size_t point_size = mesh.cloud.data.size () / nr_points;
 
   pcl::io::writePLYHeader (fs, mesh, "ascii 1.0");
 
   // Write down vertices
   for (std::size_t i = 0; i < nr_points; ++i)
   {
     int xyz = 0;
     for (std::size_t d = 0; d < mesh.cloud.fields.size (); ++d)
     {
       // adding vertex
       if ((mesh.cloud.fields[d].datatype == pcl::PCLPointField::FLOAT32) && (
           mesh.cloud.fields[d].name == "x" ||
           mesh.cloud.fields[d].name == "y" ||
           mesh.cloud.fields[d].name == "z"))
       {
-        float value;
-        memcpy (&value, &mesh.cloud.data[i * point_size + mesh.cloud.fields[d].offset], sizeof (float));
-        fs << value << " ";
+        fs << mesh.cloud.at<float>(i, mesh.cloud.fields[d].offset) << " ";
         // if (++xyz == 3)
         //   break;
         ++xyz;
       }
       else if ((mesh.cloud.fields[d].datatype == pcl::PCLPointField::FLOAT32) &&
                 (mesh.cloud.fields[d].name == "rgb"))
 
       {
-        pcl::RGB color;
-        memcpy (&color, &mesh.cloud.data[i * point_size + mesh.cloud.fields[d].offset], sizeof (RGB));
+        const pcl::RGB& color = mesh.cloud.at<RGB>(i, mesh.cloud.fields[d].offset);
         fs << int (color.r) << " " << int (color.g) << " " << int (color.b) << " ";
       }
       else if ((mesh.cloud.fields[d].datatype == pcl::PCLPointField::UINT32) &&
                (mesh.cloud.fields[d].name == "rgba"))
       {
-        pcl::RGB color;
-        memcpy (&color, &mesh.cloud.data[i * point_size + mesh.cloud.fields[d].offset], sizeof (RGB));
+        const pcl::RGB& color = mesh.cloud.at<RGB>(i, mesh.cloud.fields[d].offset);
         fs << int (color.r) << " " << int (color.g) << " " << int (color.b) << " " << int (color.a) << " ";
       }
       else if ((mesh.cloud.fields[d].datatype == pcl::PCLPointField::FLOAT32) && (
                 mesh.cloud.fields[d].name == "normal_x" ||
                 mesh.cloud.fields[d].name == "normal_y" ||
                 mesh.cloud.fields[d].name == "normal_z"))
       {
-        float value;
-        memcpy (&value, &mesh.cloud.data[i * point_size + mesh.cloud.fields[d].offset], sizeof(float));
-        fs << value << " ";
+        fs << mesh.cloud.at<float>(i, mesh.cloud.fields[d].offset) << " ";
       }
       else if ((mesh.cloud.fields[d].datatype == pcl::PCLPointField::FLOAT32) && (
                 mesh.cloud.fields[d].name == "curvature"))
       {
-        float value;
-        memcpy(&value, &mesh.cloud.data[i * point_size + mesh.cloud.fields[d].offset], sizeof(float));
-        fs << value << " ";
+        fs << mesh.cloud.at<float>(i, mesh.cloud.fields[d].offset) << " ";
       }
     }
     if (xyz != 3)
     {
       PCL_ERROR ("[pcl::io::savePLYFile] Input point cloud has no XYZ data!\n");
       return (-2);
     }
     fs << '\n';
   }
 
   // Write down faces
   PCL_DEBUG ("[pcl::io::savePLYFile] Saving %zu polygons/faces\n", mesh.polygons.size());
   for (const pcl::Vertices& polygon : mesh.polygons)
   {
     fs << polygon.vertices.size ();
     for (const auto& vertex : polygon.vertices)
       fs << " " << vertex;
     fs << '\n';
   }
 
   // Close file
   fs.close ();
   return (0);
 }
 
 ////////////////////////////////////////////////////////////////////////////////////////
@@ -1592,111 +1579,102 @@ int
 pcl::io::savePLYFileBinary (const std::string &file_name, const pcl::PolygonMesh &mesh)
 {
   if (mesh.cloud.data.empty ())
   {
     PCL_ERROR ("[pcl::io::savePLYFile] Input point cloud has no data!\n");
     return (-1);
   }
   // Open file
   std::ofstream fs;
   fs.open (file_name.c_str ());
   if (!fs)
   {
     PCL_ERROR ("[pcl::io::savePLYFile] Error during opening (%s)!\n", file_name.c_str ());
     return (-1);
   }
 
   // number of points
   std::size_t nr_points  = mesh.cloud.width * mesh.cloud.height;
-  std::size_t point_size = mesh.cloud.data.size () / nr_points;
 
   pcl::io::writePLYHeader(fs, mesh, (mesh.cloud.is_bigendian ? "binary_big_endian 1.0" : "binary_little_endian 1.0"));
 
   // Close the file
   fs.close ();
   // Open file in binary appendable
   std::ofstream fpout (file_name.c_str (), std::ios::app | std::ios::binary);
   if (!fpout)
   {
     PCL_ERROR ("[pcl::io::writePLYFileBinary] Error during reopening (%s)!\n", file_name.c_str ());
     return (-1);
   }
 
   // Write down vertices
   for (std::size_t i = 0; i < nr_points; ++i)
   {
     int xyz = 0;
     for (std::size_t d = 0; d < mesh.cloud.fields.size (); ++d)
     {
       // adding vertex
       if ((mesh.cloud.fields[d].datatype == pcl::PCLPointField::FLOAT32) && (
           mesh.cloud.fields[d].name == "x" ||
           mesh.cloud.fields[d].name == "y" ||
           mesh.cloud.fields[d].name == "z"))
       {
-        float value;
-        memcpy (&value, &mesh.cloud.data[i * point_size + mesh.cloud.fields[d].offset], sizeof (float));
-        fpout.write (reinterpret_cast<const char*> (&value), sizeof (float));
+        fpout.write (reinterpret_cast<const char*> (&mesh.cloud.at<float>(i, mesh.cloud.fields[d].offset)), sizeof (float));
         // if (++xyz == 3)
         //   break;
         ++xyz;
       }
       else if ((mesh.cloud.fields[d].datatype == pcl::PCLPointField::FLOAT32) &&
                 (mesh.cloud.fields[d].name == "rgb"))
 
       {
-        pcl::RGB color;
-        memcpy (&color, &mesh.cloud.data[i * point_size + mesh.cloud.fields[d].offset], sizeof (RGB));
+        const pcl::RGB& color = mesh.cloud.at<RGB>(i, mesh.cloud.fields[d].offset);
         fpout.write (reinterpret_cast<const char*> (&color.r), sizeof (unsigned char));
         fpout.write (reinterpret_cast<const char*> (&color.g), sizeof (unsigned char));
         fpout.write (reinterpret_cast<const char*> (&color.b), sizeof (unsigned char));
       }
       else if ((mesh.cloud.fields[d].datatype == pcl::PCLPointField::UINT32) &&
                (mesh.cloud.fields[d].name == "rgba"))
       {
-        pcl::RGB color;
-        memcpy (&color, &mesh.cloud.data[i * point_size + mesh.cloud.fields[d].offset], sizeof (RGB));
+        const pcl::RGB& color = mesh.cloud.at<RGB>(i, mesh.cloud.fields[d].offset);
         fpout.write (reinterpret_cast<const char*> (&color.r), sizeof (unsigned char));
         fpout.write (reinterpret_cast<const char*> (&color.g), sizeof (unsigned char));
         fpout.write (reinterpret_cast<const char*> (&color.b), sizeof (unsigned char));
         fpout.write (reinterpret_cast<const char*> (&color.a), sizeof (unsigned char));
       }
       else if ((mesh.cloud.fields[d].datatype == pcl::PCLPointField::FLOAT32) && (
                mesh.cloud.fields[d].name == "normal_x" ||
                mesh.cloud.fields[d].name == "normal_y" ||
                mesh.cloud.fields[d].name == "normal_z"))
       {
-        float value;
-        memcpy (&value, &mesh.cloud.data[i * point_size + mesh.cloud.fields[d].offset], sizeof (float));
-        fpout.write (reinterpret_cast<const char*> (&value), sizeof (float));
+        fpout.write (reinterpret_cast<const char*> (&mesh.cloud.at<float>(i, mesh.cloud.fields[d].offset)), sizeof (float));
       }
       else if ((mesh.cloud.fields[d].datatype == pcl::PCLPointField::FLOAT32) && 
                (mesh.cloud.fields[d].name == "curvature"))
       {
-        float value;
-        memcpy (&value, &mesh.cloud.data[i * point_size + mesh.cloud.fields[d].offset], sizeof (float));
-        fpout.write (reinterpret_cast<const char*> (&value), sizeof (float));        
+        fpout.write (reinterpret_cast<const char*> (&mesh.cloud.at<float>(i, mesh.cloud.fields[d].offset)), sizeof (float));
       }
     }
     if (xyz != 3)
     {
-      PCL_ERROR ("[pcl::io::savePLYFile] Input point cloud has no XYZ data!\n");
+      PCL_ERROR ("[pcl::io::savePLYFileBinary] Input point cloud has no XYZ data!\n");
       return (-2);
     }
   }
 
   // Write down faces
   for (const pcl::Vertices& polygon : mesh.polygons)
   {
     unsigned char value = static_cast<unsigned char> (polygon.vertices.size ());
     fpout.write (reinterpret_cast<const char*> (&value), sizeof (unsigned char));
     for (const int value : polygon.vertices)
     {
       //fs << mesh.polygons[i].vertices[j] << " ";
       fpout.write (reinterpret_cast<const char*> (&value), sizeof (int));
     }
   }
 
   // Close file
   fpout.close ();
   return (0);
 }
