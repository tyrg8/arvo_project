commit e9a2fc0083e784230b5e348185a5a910be644535
Author: Egor Pugin <egor.pugin@gmail.com>
Date:   Wed Mar 10 14:36:59 2021 +0300

    More std::string replacements.

diff --git a/src/api/baseapi.cpp b/src/api/baseapi.cpp
index 0a9e1836..fd3a725d 100644
--- a/src/api/baseapi.cpp
+++ b/src/api/baseapi.cpp
@@ -812,86 +812,86 @@ PageIterator* TessBaseAPI::AnalyseLayout(bool merge_similar_words) {
 /**
  * Recognize the tesseract global image and return the result as Tesseract
  * internal structures.
  */
 int TessBaseAPI::Recognize(ETEXT_DESC* monitor) {
   if (tesseract_ == nullptr)
     return -1;
   if (FindLines() != 0)
     return -1;
   delete page_res_;
   if (block_list_->empty()) {
     page_res_ = new PAGE_RES(false, block_list_,
                              &tesseract_->prev_word_best_choice_);
     return 0; // Empty page.
   }
 
   tesseract_->SetBlackAndWhitelist();
   recognition_done_ = true;
 #ifndef DISABLED_LEGACY_ENGINE
   if (tesseract_->tessedit_resegment_from_line_boxes) {
     page_res_ = tesseract_->ApplyBoxes(input_file_.c_str(), true, block_list_);
   } else if (tesseract_->tessedit_resegment_from_boxes) {
     page_res_ = tesseract_->ApplyBoxes(input_file_.c_str(), false, block_list_);
   } else
 #endif  // ndef DISABLED_LEGACY_ENGINE
   {
     page_res_ = new PAGE_RES(tesseract_->AnyLSTMLang(),
                              block_list_, &tesseract_->prev_word_best_choice_);
   }
 
   if (page_res_ == nullptr) {
     return -1;
   }
 
   if (tesseract_->tessedit_train_line_recognizer) {
     if (!tesseract_->TrainLineRecognizer(input_file_.c_str(), output_file_, block_list_)) {
       return -1;
     }
     tesseract_->CorrectClassifyWords(page_res_);
     return 0;
   }
 #ifndef DISABLED_LEGACY_ENGINE
   if (tesseract_->tessedit_make_boxes_from_boxes) {
     tesseract_->CorrectClassifyWords(page_res_);
     return 0;
   }
 #endif  // ndef DISABLED_LEGACY_ENGINE
 
   int result = 0;
   if (tesseract_->interactive_display_mode) {
     #ifndef GRAPHICS_DISABLED
     tesseract_->pgeditor_main(rect_width_, rect_height_, page_res_);
     #endif // !GRAPHICS_DISABLED
     // The page_res is invalid after an interactive session, so cleanup
     // in a way that lets us continue to the next page without crashing.
     delete page_res_;
     page_res_ = nullptr;
     return -1;
   #ifndef DISABLED_LEGACY_ENGINE
   } else if (tesseract_->tessedit_train_from_boxes) {
-    STRING fontname;
+    std::string fontname;
     ExtractFontName(output_file_.c_str(), &fontname);
     tesseract_->ApplyBoxTraining(fontname, page_res_);
   } else if (tesseract_->tessedit_ambigs_training) {
     FILE* training_output_file =
       tesseract_->init_recog_training(input_file_.c_str());
     // OCR the page segmented into words by tesseract.
     tesseract_->recog_training_segmented(
         input_file_.c_str(), page_res_, monitor, training_output_file);
     fclose(training_output_file);
   #endif  // ndef DISABLED_LEGACY_ENGINE
   } else {
     // Now run the main recognition.
     bool wait_for_text = true;
     GetBoolVariable("paragraph_text_based", &wait_for_text);
     if (!wait_for_text) DetectParagraphs(false);
     if (tesseract_->recog_all_words(page_res_, monitor, nullptr, nullptr, 0)) {
       if (wait_for_text) DetectParagraphs(true);
     } else {
       result = -1;
     }
   }
   return result;
 }
 
 // Takes ownership of the input pix.
@@ -1533,117 +1533,117 @@ const int kLatinChs[] = {
 /**
  * The recognized text is returned as a char* which is coded
  * as UNLV format Latin-1 with specific reject and suspect codes.
  * Returned string must be freed with the delete [] operator.
  */
 char* TessBaseAPI::GetUNLVText() {
   if (tesseract_ == nullptr ||
       (!recognition_done_ && Recognize(nullptr) < 0))
     return nullptr;
   bool tilde_crunch_written = false;
   bool last_char_was_newline = true;
   bool last_char_was_tilde = false;
 
   int total_length = TextLength(nullptr);
   PAGE_RES_IT   page_res_it(page_res_);
   char* result = new char[total_length];
   char* ptr = result;
   for (page_res_it.restart_page(); page_res_it.word () != nullptr;
        page_res_it.forward()) {
     WERD_RES *word = page_res_it.word();
     // Process the current word.
     if (word->unlv_crunch_mode != CR_NONE) {
       if (word->unlv_crunch_mode != CR_DELETE &&
           (!tilde_crunch_written ||
            (word->unlv_crunch_mode == CR_KEEP_SPACE &&
             word->word->space() > 0 &&
             !word->word->flag(W_FUZZY_NON) &&
             !word->word->flag(W_FUZZY_SP)))) {
         if (!word->word->flag(W_BOL) &&
             word->word->space() > 0 &&
             !word->word->flag(W_FUZZY_NON) &&
             !word->word->flag(W_FUZZY_SP)) {
           /* Write a space to separate from preceding good text */
           *ptr++ = ' ';
           last_char_was_tilde = false;
         }
         if (!last_char_was_tilde) {
           // Write a reject char.
           last_char_was_tilde = true;
           *ptr++ = kUNLVReject;
           tilde_crunch_written = true;
           last_char_was_newline = false;
         }
       }
     } else {
       // NORMAL PROCESSING of non tilde crunched words.
       tilde_crunch_written = false;
       tesseract_->set_unlv_suspects(word);
       const char* wordstr = word->best_choice->unichar_string().c_str();
-      const STRING& lengths = word->best_choice->unichar_lengths();
+      const auto &lengths = word->best_choice->unichar_lengths();
       int length = lengths.length();
       int i = 0;
       int offset = 0;
 
       if (last_char_was_tilde &&
           word->word->space() == 0 && wordstr[offset] == ' ') {
         // Prevent adjacent tilde across words - we know that adjacent tildes
         // within words have been removed.
         // Skip the first character.
         offset = lengths[i++];
       }
       if (i < length && wordstr[offset] != 0) {
         if (!last_char_was_newline)
           *ptr++ = ' ';
         else
           last_char_was_newline = false;
         for (; i < length; offset += lengths[i++]) {
           if (wordstr[offset] == ' ' ||
               wordstr[offset] == kTesseractReject) {
             *ptr++ = kUNLVReject;
             last_char_was_tilde = true;
           } else {
             if (word->reject_map[i].rejected())
               *ptr++ = kUNLVSuspect;
             UNICHAR ch(wordstr + offset, lengths[i]);
             int uni_ch = ch.first_uni();
             for (int j = 0; kUniChs[j] != 0; ++j) {
               if (kUniChs[j] == uni_ch) {
                 uni_ch = kLatinChs[j];
                 break;
               }
             }
             if (uni_ch <= 0xff) {
               *ptr++ = static_cast<char>(uni_ch);
               last_char_was_tilde = false;
             } else {
               *ptr++ = kUNLVReject;
               last_char_was_tilde = true;
             }
           }
         }
       }
     }
     if (word->word->flag(W_EOL) && !last_char_was_newline) {
       /* Add a new line output */
       *ptr++ = '\n';
       tilde_crunch_written = false;
       last_char_was_newline = true;
       last_char_was_tilde = false;
     }
   }
   *ptr++ = '\n';
   *ptr = '\0';
   return result;
 }
 
 #ifndef DISABLED_LEGACY_ENGINE
 
 /**
  * Detect the orientation of the input image and apparent script (alphabet).
  * orient_deg is the detected clockwise rotation of the input image in degrees
  * (0, 90, 180, 270)
  * orient_conf is the confidence (15.0 is reasonably confident)
  * script_name is an ASCII string, the name of the script, e.g. "Latin"
  * script_conf is confidence level in the script
  * Returns true on success and writes values to each parameter as an output
  */
diff --git a/src/ccmain/docqual.cpp b/src/ccmain/docqual.cpp
index f74f9ead..570675f8 100644
--- a/src/ccmain/docqual.cpp
+++ b/src/ccmain/docqual.cpp
@@ -481,37 +481,37 @@ void Tesseract::tilde_crunch(PAGE_RES_IT &page_res_it) {
 bool Tesseract::terrible_word_crunch(WERD_RES* word,
                                      GARBAGE_LEVEL garbage_level) {
   float rating_per_ch;
   int adjusted_len;
   int crunch_mode = 0;
 
   if ((word->best_choice->unichar_string().length() == 0) ||
       (strspn(word->best_choice->unichar_string().c_str(), " ") ==
-       word->best_choice->unichar_string().unsigned_size()))
+       word->best_choice->unichar_string().size()))
     crunch_mode = 1;
   else {
     adjusted_len = word->reject_map.length ();
     if (adjusted_len > crunch_rating_max)
       adjusted_len = crunch_rating_max;
     rating_per_ch = word->best_choice->rating () / adjusted_len;
 
     if (rating_per_ch > crunch_terrible_rating)
       crunch_mode = 2;
     else if (crunch_terrible_garbage && (garbage_level == G_TERRIBLE))
       crunch_mode = 3;
     else if ((word->best_choice->certainty () < crunch_poor_garbage_cert) &&
       (garbage_level != G_OK))
       crunch_mode = 4;
     else if ((rating_per_ch > crunch_poor_garbage_rate) &&
       (garbage_level != G_OK))
       crunch_mode = 5;
   }
   if (crunch_mode > 0) {
     if (crunch_debug > 2) {
       tprintf ("Terrible_word_crunch (%d) on \"%s\"\n",
         crunch_mode, word->best_choice->unichar_string().c_str());
     }
     return true;
   }
   else
     return false;
 }
diff --git a/src/ccstruct/ratngs.cpp b/src/ccstruct/ratngs.cpp
index ea40c859..274b73c0 100644
--- a/src/ccstruct/ratngs.cpp
+++ b/src/ccstruct/ratngs.cpp
@@ -210,33 +210,33 @@ const char *ScriptPosToString(enum ScriptPos script_pos) {
 /**
  * WERD_CHOICE::WERD_CHOICE
  *
  * Constructor to build a WERD_CHOICE from the given string.
  * The function assumes that src_string is not nullptr.
  */
 WERD_CHOICE::WERD_CHOICE(const char *src_string,
                          const UNICHARSET &unicharset)
     : unicharset_(&unicharset){
   std::vector<UNICHAR_ID> encoding;
   std::vector<char> lengths;
   std::string cleaned = unicharset.CleanupString(src_string);
   if (unicharset.encode_string(cleaned.c_str(), true, &encoding, &lengths,
                                nullptr)) {
     lengths.push_back('\0');
-    STRING src_lengths = &lengths[0];
+    std::string src_lengths = &lengths[0];
     this->init(cleaned.c_str(), src_lengths.c_str(), 0.0, 0.0, NO_PERM);
   } else {  // There must have been an invalid unichar in the string.
     this->init(8);
     this->make_bad();
   }
 }
 
 /**
  * WERD_CHOICE::init
  *
  * Helper function to build a WERD_CHOICE from the given string,
  * fragment lengths, rating, certainty and permuter.
  *
  * The function assumes that src_string is not nullptr.
  * src_lengths argument could be nullptr, in which case the unichars
  * in src_string are assumed to all be of length 1.
  */
@@ -441,25 +441,25 @@ bool WERD_CHOICE::has_rtl_unichar_id() const {
 /**
  * string_and_lengths
  *
  * Populates the given word_str with unichars from unichar_ids and
  * and word_lengths_str with the corresponding unichar lengths.
  */
-void WERD_CHOICE::string_and_lengths(STRING *word_str,
-                                     STRING *word_lengths_str) const {
+void WERD_CHOICE::string_and_lengths(std::string *word_str,
+                                     std::string *word_lengths_str) const {
   *word_str = "";
   if (word_lengths_str != nullptr) *word_lengths_str = "";
   for (int i = 0; i < length_; ++i) {
     const char *ch = unicharset_->id_to_unichar_ext(unichar_ids_[i]);
     *word_str += ch;
     if (word_lengths_str != nullptr) {
       *word_lengths_str += (char)strlen(ch);
     }
   }
 }
 
 /**
  * append_unichar_id
  *
  * Make sure there is enough space in the word for the new unichar id
  * and call append_unichar_id_space_allocated().
  */
diff --git a/src/ccstruct/ratngs.h b/src/ccstruct/ratngs.h
index c2bc962a..ef2fb194 100644
--- a/src/ccstruct/ratngs.h
+++ b/src/ccstruct/ratngs.h
@@ -266,377 +266,377 @@ const char *ScriptPosToString(ScriptPos script_pos);
 class TESS_API WERD_CHOICE : public ELIST_LINK {
  public:
   static const float kBadRating;
   static const char *permuter_name(uint8_t permuter);
 
   WERD_CHOICE(const UNICHARSET *unicharset)
     : unicharset_(unicharset) { this->init(8); }
   WERD_CHOICE(const UNICHARSET *unicharset, int reserved)
     : unicharset_(unicharset) { this->init(reserved); }
   WERD_CHOICE(const char *src_string,
               const char *src_lengths,
               float src_rating,
               float src_certainty,
               uint8_t src_permuter,
               const UNICHARSET &unicharset)
     : unicharset_(&unicharset) {
     this->init(src_string, src_lengths, src_rating,
                src_certainty, src_permuter);
   }
   WERD_CHOICE(const char *src_string, const UNICHARSET &unicharset);
   WERD_CHOICE(const WERD_CHOICE &word)
       : ELIST_LINK(word), unicharset_(word.unicharset_) {
     this->init(word.length());
     this->operator=(word);
   }
   ~WERD_CHOICE();
 
   const UNICHARSET *unicharset() const {
     return unicharset_;
   }
   inline int length() const {
     return length_;
   }
   float adjust_factor() const {
     return adjust_factor_;
   }
   void set_adjust_factor(float factor) {
     adjust_factor_ = factor;
   }
   inline const UNICHAR_ID *unichar_ids() const {
     return unichar_ids_;
   }
   inline UNICHAR_ID unichar_id(int index) const {
     assert(index < length_);
     return unichar_ids_[index];
   }
   inline int state(int index) const {
     return state_[index];
   }
   ScriptPos BlobPosition(int index) const {
     if (index < 0 || index >= length_)
       return SP_NORMAL;
     return script_pos_[index];
   }
   inline float rating() const {
     return rating_;
   }
   inline float certainty() const {
     return certainty_;
   }
   inline float certainty(int index) const {
     return certainties_[index];
   }
   inline float min_x_height() const {
     return min_x_height_;
   }
   inline float max_x_height() const {
     return max_x_height_;
   }
   inline void set_x_heights(float min_height, float max_height) {
     min_x_height_ = min_height;
     max_x_height_ = max_height;
   }
   inline uint8_t permuter() const {
     return permuter_;
   }
   const char *permuter_name() const;
   // Returns the BLOB_CHOICE_LIST corresponding to the given index in the word,
   // taken from the appropriate cell in the ratings MATRIX.
   // Borrowed pointer, so do not delete.
   BLOB_CHOICE_LIST* blob_choices(int index, MATRIX* ratings) const;
 
   // Returns the MATRIX_COORD corresponding to the location in the ratings
   // MATRIX for the given index into the word.
   MATRIX_COORD MatrixCoord(int index) const;
 
   inline void set_unichar_id(UNICHAR_ID unichar_id, int index) {
     assert(index < length_);
     unichar_ids_[index] = unichar_id;
   }
   bool dangerous_ambig_found() const {
     return dangerous_ambig_found_;
   }
   void set_dangerous_ambig_found_(bool value) {
     dangerous_ambig_found_ = value;
   }
   inline void set_rating(float new_val) {
     rating_ = new_val;
   }
   inline void set_certainty(float new_val) {
     certainty_ = new_val;
   }
   inline void set_permuter(uint8_t perm) {
     permuter_ = perm;
   }
   // Note: this function should only be used if all the fields
   // are populated manually with set_* functions (rather than
   // (copy)constructors and append_* functions).
   inline void set_length(int len) {
     ASSERT_HOST(reserved_ >= len);
     length_ = len;
   }
 
   /// Make more space in unichar_id_ and fragment_lengths_ arrays.
   inline void double_the_size() {
     if (reserved_ > 0) {
       unichar_ids_ = GenericVector<UNICHAR_ID>::double_the_size_memcpy(
           reserved_, unichar_ids_);
       script_pos_ = GenericVector<ScriptPos>::double_the_size_memcpy(
           reserved_, script_pos_);
       state_ = GenericVector<int>::double_the_size_memcpy(
           reserved_, state_);
       certainties_ = GenericVector<float>::double_the_size_memcpy(
           reserved_, certainties_);
       reserved_ *= 2;
     } else {
       unichar_ids_ = new UNICHAR_ID[1];
       script_pos_ = new ScriptPos[1];
       state_ = new int[1];
       certainties_ = new float[1];
       reserved_ = 1;
     }
   }
 
   /// Initializes WERD_CHOICE - reserves length slots in unichar_ids_ and
   /// fragment_length_ arrays. Sets other values to default (blank) values.
   inline void init(int reserved) {
     reserved_ = reserved;
     if (reserved > 0) {
       unichar_ids_ = new UNICHAR_ID[reserved];
       script_pos_ = new ScriptPos[reserved];
       state_ = new int[reserved];
       certainties_ = new float[reserved];
     } else {
       unichar_ids_ = nullptr;
       script_pos_ = nullptr;
       state_ = nullptr;
       certainties_ = nullptr;
     }
     length_ = 0;
     adjust_factor_ = 1.0f;
     rating_ = 0.0;
     certainty_ = FLT_MAX;
     min_x_height_ = 0.0f;
     max_x_height_ = FLT_MAX;
     permuter_ = NO_PERM;
     unichars_in_script_order_ = false;  // Tesseract is strict left-to-right.
     dangerous_ambig_found_ = false;
   }
 
   /// Helper function to build a WERD_CHOICE from the given string,
   /// fragment lengths, rating, certainty and permuter.
   /// The function assumes that src_string is not nullptr.
   /// src_lengths argument could be nullptr, in which case the unichars
   /// in src_string are assumed to all be of length 1.
   void init(const char *src_string, const char *src_lengths,
             float src_rating, float src_certainty,
             uint8_t src_permuter);
 
   /// Set the fields in this choice to be default (bad) values.
   inline void make_bad() {
     length_ = 0;
     rating_ = kBadRating;
     certainty_ = -FLT_MAX;
   }
 
   /// This function assumes that there is enough space reserved
   /// in the WERD_CHOICE for adding another unichar.
   /// This is an efficient alternative to append_unichar_id().
   inline void append_unichar_id_space_allocated(
       UNICHAR_ID unichar_id, int blob_count,
       float rating, float certainty) {
     assert(reserved_ > length_);
     length_++;
     this->set_unichar_id(unichar_id, blob_count,
                          rating, certainty, length_-1);
   }
 
   void append_unichar_id(UNICHAR_ID unichar_id, int blob_count,
                          float rating, float certainty);
 
   inline void set_unichar_id(UNICHAR_ID unichar_id, int blob_count,
                              float rating, float certainty, int index) {
     assert(index < length_);
     unichar_ids_[index] = unichar_id;
     state_[index] = blob_count;
     certainties_[index] = certainty;
     script_pos_[index] = SP_NORMAL;
     rating_ += rating;
     if (certainty < certainty_) {
       certainty_ = certainty;
     }
   }
   // Sets the entries for the given index from the BLOB_CHOICE, assuming
   // unit fragment lengths, but setting the state for this index to blob_count.
   void set_blob_choice(int index, int blob_count,
                        const BLOB_CHOICE* blob_choice);
 
   bool contains_unichar_id(UNICHAR_ID unichar_id) const;
   void remove_unichar_ids(int index, int num);
   inline void remove_last_unichar_id() { --length_; }
   inline void remove_unichar_id(int index) {
     this->remove_unichar_ids(index, 1);
   }
   bool has_rtl_unichar_id() const;
   void reverse_and_mirror_unichar_ids();
 
   // Returns the half-open interval of unichar_id indices [start, end) which
   // enclose the core portion of this word -- the part after stripping
   // punctuation from the left and right.
   void punct_stripped(int *start_core, int *end_core) const;
 
   // Returns the indices [start, end) containing the core of the word, stripped
   // of any superscript digits on either side. (i.e., the non-footnote part
   // of the word). There is no guarantee that the output range is non-empty.
   void GetNonSuperscriptSpan(int *start, int *end) const;
 
   // Return a copy of this WERD_CHOICE with the choices [start, end).
   // The result is useful only for checking against a dictionary.
   WERD_CHOICE shallow_copy(int start, int end) const;
 
-  void string_and_lengths(STRING *word_str, STRING *word_lengths_str) const;
-  const STRING debug_string() const {
-    STRING word_str;
+  void string_and_lengths(std::string *word_str, std::string *word_lengths_str) const;
+  std::string debug_string() const {
+    std::string word_str;
     for (int i = 0; i < length_; ++i) {
       word_str += unicharset_->debug_str(unichar_ids_[i]);
       word_str += " ";
     }
     return word_str;
   }
   // Returns true if any unichar_id in the word is a non-space-delimited char.
   bool ContainsAnyNonSpaceDelimited() const {
     for (int i = 0; i < length_; ++i) {
       if (!unicharset_->IsSpaceDelimited(unichar_ids_[i])) return true;
     }
     return false;
   }
   // Returns true if the word is all spaces.
   bool IsAllSpaces() const {
     for (int i = 0; i < length_; ++i) {
       if (unichar_ids_[i] != UNICHAR_SPACE) return false;
     }
     return true;
   }
 
   // Call this to override the default (strict left to right graphemes)
   // with the fact that some engine produces a "reading order" set of
   // Graphemes for each word.
   bool set_unichars_in_script_order(bool in_script_order) {
     return unichars_in_script_order_ = in_script_order;
   }
 
   bool unichars_in_script_order() const {
     return unichars_in_script_order_;
   }
 
   // Returns a UTF-8 string equivalent to the current choice
   // of UNICHAR IDs.
-  STRING &unichar_string() {
+  std::string &unichar_string() {
       this->string_and_lengths(&unichar_string_, &unichar_lengths_);
       return unichar_string_;
   }
 
   // Returns a UTF-8 string equivalent to the current choice
   // of UNICHAR IDs.
-  const STRING &unichar_string() const {
+  const std::string &unichar_string() const {
     this->string_and_lengths(&unichar_string_, &unichar_lengths_);
     return unichar_string_;
   }
 
   // Returns the lengths, one byte each, representing the number of bytes
   // required in the unichar_string for each UNICHAR_ID.
-  const STRING &unichar_lengths() const {
+  const std::string &unichar_lengths() const {
     this->string_and_lengths(&unichar_string_, &unichar_lengths_);
     return unichar_lengths_;
   }
 
   // Sets up the script_pos_ member using the blobs_list to get the bln
   // bounding boxes, *this to get the unichars, and this->unicharset
   // to get the target positions. If small_caps is true, sub/super are not
   // considered, but dropcaps are.
   // NOTE: blobs_list should be the chopped_word blobs. (Fully segemented.)
   void SetScriptPositions(bool small_caps, TWERD* word, int debug = 0);
   // Sets the script_pos_ member from some source positions with a given length.
   void SetScriptPositions(const ScriptPos* positions, int length);
   // Sets all the script_pos_ positions to the given position.
   void SetAllScriptPositions(ScriptPos position);
 
   static ScriptPos ScriptPositionOf(bool print_debug,
                                                const UNICHARSET& unicharset,
                                                const TBOX& blob_box,
                                                UNICHAR_ID unichar_id);
 
   // Returns the "dominant" script ID for the word.  By "dominant", the script
   // must account for at least half the characters.  Otherwise, it returns 0.
   // Note that for Japanese, Hiragana and Katakana are simply treated as Han.
   int GetTopScriptID() const;
 
   // Fixes the state_ for a chop at the given blob_posiiton.
   void UpdateStateForSplit(int blob_position);
 
   // Returns the sum of all the state elements, being the total number of blobs.
   int TotalOfStates() const;
 
   void print() const { this->print(""); }
   void print(const char *msg) const;
   // Prints the segmentation state with an introductory message.
   void print_state(const char *msg) const;
 
   // Displays the segmentation state of *this (if not the same as the last
   // one displayed) and waits for a click in the window.
   void DisplaySegmentation(TWERD* word);
 
   WERD_CHOICE& operator+= (     // concatanate
     const WERD_CHOICE & second);// second on first
 
   WERD_CHOICE& operator= (const WERD_CHOICE& source);
 
  private:
   const UNICHARSET *unicharset_;
   // TODO(rays) Perhaps replace the multiple arrays with an array of structs?
   // unichar_ids_ is an array of classifier "results" that make up a word.
   // For each unichar_ids_[i], script_pos_[i] has the sub/super/normal position
   // of each unichar_id.
   // state_[i] indicates the number of blobs in WERD_RES::chopped_word that
   // were put together to make the classification results in the ith position
   // in unichar_ids_, and certainties_[i] is the certainty of the choice that
   // was used in this word.
   // == Change from before ==
   // Previously there was fragment_lengths_ that allowed a word to be
   // artificially composed of multiple fragment results. Since the new
   // segmentation search doesn't do fragments, treatment of fragments has
   // been moved to a lower level, augmenting the ratings matrix with the
   // combined fragments, and allowing the language-model/segmentation-search
   // to deal with only the combined unichar_ids.
   UNICHAR_ID *unichar_ids_;  // unichar ids that represent the text of the word
   ScriptPos* script_pos_;  // Normal/Sub/Superscript of each unichar.
   int* state_;               // Number of blobs in each unichar.
   float* certainties_;       // Certainty of each unichar.
   int reserved_;             // size of the above arrays
   int length_;               // word length
   // Factor that was used to adjust the rating.
   float adjust_factor_;
   // Rating is the sum of the ratings of the individual blobs in the word.
   float rating_;             // size related
   // certainty is the min (worst) certainty of the individual blobs in the word.
   float certainty_;          // absolute
   // xheight computed from the result, or 0 if inconsistent.
   float min_x_height_;
   float max_x_height_;
   uint8_t permuter_;           // permuter code
 
   // Normally, the ratings_ matrix represents the recognition results in order
   // from left-to-right.  However, some engines (say Cube) may return
   // recognition results in the order of the script's major reading direction
   // (for Arabic, that is right-to-left).
   bool unichars_in_script_order_;
   // True if NoDangerousAmbig found an ambiguity.
   bool dangerous_ambig_found_;
 
   // The following variables are populated and passed by reference any
   // time unichar_string() or unichar_lengths() are called.
-  mutable STRING unichar_string_;
-  mutable STRING unichar_lengths_;
+  mutable std::string unichar_string_;
+  mutable std::string unichar_lengths_;
 };
 
 // Make WERD_CHOICE listable.
diff --git a/src/ccutil/ccutil.h b/src/ccutil/ccutil.h
index 5cc39f2b..af3b24b1 100644
--- a/src/ccutil/ccutil.h
+++ b/src/ccutil/ccutil.h
@@ -44,39 +44,39 @@ namespace tesseract {
 class TESS_API CCUtil {
  public:
   CCUtil();
   virtual ~CCUtil();
 
  public:
   // Read the arguments and set up the data path.
   void main_setup(
                   const char *argv0,        // program name
                   const char *basename      // name of image
                  );
   ParamsVectors *params() { return &params_; }
 
-  STRING datadir;        // dir for data files
-  STRING imagebasename;  // name of image
-  STRING lang;
-  STRING language_data_path_prefix;
+  std::string datadir;        // dir for data files
+  std::string imagebasename;  // name of image
+  std::string lang;
+  std::string language_data_path_prefix;
   UNICHARSET unicharset;
 #ifndef DISABLED_LEGACY_ENGINE
   UnicharAmbigs unichar_ambigs;
 #endif
-  STRING imagefile;  // image file name
-  STRING directory;  // main directory
+  std::string imagefile;  // image file name
+  std::string directory;  // main directory
 
  private:
   ParamsVectors params_;
 
  public:
   // Member parameters.
   // These have to be declared and initialized after params_ member, since
   // params_ should be initialized before parameters are added to it.
   INT_VAR_H(ambigs_debug_level, 0, "Debug level for unichar ambiguities");
   BOOL_VAR_H(use_ambigs_for_adaption, false,
              "Use ambigs for deciding whether to adapt to a character");
 };
 
 }  // namespace tesseract
 
 #endif  // TESSERACT_CCUTIL_CCUTIL_H_
diff --git a/src/ccutil/params.h b/src/ccutil/params.h
index 459c1ab6..1ec63983 100644
--- a/src/ccutil/params.h
+++ b/src/ccutil/params.h
@@ -203,35 +203,35 @@ class BoolParam : public Param {
 class StringParam : public Param {
  public:
   StringParam(const char* value, const char* name, const char* comment,
               bool init, ParamsVectors* vec)
       : Param(name, comment, init) {
     value_ = value;
     default_ = value;
     params_vec_ = &(vec->string_params);
     vec->string_params.push_back(this);
   }
   ~StringParam() { ParamUtils::RemoveParam<StringParam>(this, params_vec_); }
-  operator STRING&() { return value_; }
+  operator std::string &() { return value_; }
   const char* c_str() const { return value_.c_str(); }
   bool empty() { return value_.length() <= 0; }
-  bool operator==(const STRING& other) { return value_ == other; }
-  void operator=(const STRING& value) { value_ = value; }
-  void set_value(const STRING& value) { value_ = value; }
+  bool operator==(const std::string &other) { return value_ == other; }
+  void operator=(const std::string &value) { value_ = value; }
+  void set_value(const std::string &value) { value_ = value; }
   void ResetToDefault() { value_ = default_; }
   void ResetFrom(const ParamsVectors* vec) {
     for (auto* param : vec->string_params) {
       if (strcmp(param->name_str(), name_) == 0) {
         // printf("overriding param %s=%s by =%s\n", name_, value_,
         // param->c_str());
         value_ = *param;
         break;
       }
     }
   }
 
  private:
-  STRING value_;
-  STRING default_;
+  std::string value_;
+  std::string default_;
   // Pointer to the vector that contains this param (not owned by this class).
   std::vector<StringParam*>* params_vec_;
 };
diff --git a/src/classify/blobclass.cpp b/src/classify/blobclass.cpp
index 497ad045..aee290c0 100644
--- a/src/classify/blobclass.cpp
+++ b/src/classify/blobclass.cpp
@@ -38,30 +38,30 @@ static STRING_VAR(classify_font_name, kUnknownFontName,
 // Finds the name of the training font and returns it in fontname, by cutting
 // it out based on the expectation that the filename is of the form:
 // /path/to/dir/[lang].[fontname].exp[num]
 // The [lang], [fontname] and [num] fields should not have '.' characters.
 // If the global parameter classify_font_name is set, its value is used instead.
-void ExtractFontName(const char* filename, STRING* fontname) {
+void ExtractFontName(const char* filename, std::string* fontname) {
   *fontname = classify_font_name;
   if (*fontname == kUnknownFontName) {
     // filename is expected to be of the form [lang].[fontname].exp[num]
     // The [lang], [fontname] and [num] fields should not have '.' characters.
     const char *basename = strrchr(filename, '/');
     const char *firstdot = strchr(basename ? basename : filename, '.');
     const char *lastdot  = strrchr(filename, '.');
     if (firstdot != lastdot && firstdot != nullptr && lastdot != nullptr) {
       ++firstdot;
       *fontname = firstdot;
-      fontname->truncate_at(lastdot - firstdot);
+      fontname->resize(lastdot - firstdot);
     }
   }
 }
 
 
 /*---------------------------------------------------------------------------*/
 
 // Extracts features from the given blob and saves them in the tr_file_data_
 // member variable.
 // fontname:  Name of font that this blob was printed in.
 // cn_denorm: Character normalization transformation to apply to the blob.
 // fx_info:   Character normalization parameters computed with cn_denorm.
 // blob_text: Ground truth text for the blob.
diff --git a/src/classify/blobclass.h b/src/classify/blobclass.h
index 94532fc9..c5c83cf8 100644
--- a/src/classify/blobclass.h
+++ b/src/classify/blobclass.h
@@ -30,10 +30,10 @@ namespace tesseract {
 // Finds the name of the training font and returns it in fontname, by cutting
 // it out based on the expectation that the filename is of the form:
 // /path/to/dir/[lang].[fontname].exp[num]
 // The [lang], [fontname] and [num] fields should not have '.' characters.
 // If the global parameter classify_font_name is set, its value is used instead.
-void ExtractFontName(const char* filename, STRING* fontname);
+void ExtractFontName(const char* filename, std::string* fontname);
 
 }  // namespace tesseract.
 
 #endif
diff --git a/src/dict/dict.cpp b/src/dict/dict.cpp
index eb69b569..506f9779 100644
--- a/src/dict/dict.cpp
+++ b/src/dict/dict.cpp
@@ -207,142 +207,142 @@ void Dict::SetupForLoad(DawgCache* dawg_cache) {
 // Loads the dawgs needed by Tesseract. Call FinishLoad() after.
 void Dict::Load(const STRING& lang, TessdataManager* data_file) {
   // Load dawgs_.
   if (load_punc_dawg) {
     punc_dawg_ = dawg_cache_->GetSquishedDawg(lang, TESSDATA_PUNC_DAWG,
                                               dawg_debug_level, data_file);
     if (punc_dawg_) dawgs_ += punc_dawg_;
   }
   if (load_system_dawg) {
     Dawg* system_dawg = dawg_cache_->GetSquishedDawg(
         lang, TESSDATA_SYSTEM_DAWG, dawg_debug_level, data_file);
     if (system_dawg) dawgs_ += system_dawg;
   }
   if (load_number_dawg) {
     Dawg* number_dawg = dawg_cache_->GetSquishedDawg(
         lang, TESSDATA_NUMBER_DAWG, dawg_debug_level, data_file);
     if (number_dawg) dawgs_ += number_dawg;
   }
   if (load_bigram_dawg) {
     bigram_dawg_ = dawg_cache_->GetSquishedDawg(lang, TESSDATA_BIGRAM_DAWG,
                                                 dawg_debug_level, data_file);
     // The bigram_dawg_ is NOT used like the other dawgs! DO NOT add to the
     // dawgs_!!
   }
   if (load_freq_dawg) {
     freq_dawg_ = dawg_cache_->GetSquishedDawg(lang, TESSDATA_FREQ_DAWG,
                                               dawg_debug_level, data_file);
     if (freq_dawg_) dawgs_ += freq_dawg_;
   }
   if (load_unambig_dawg) {
     unambig_dawg_ = dawg_cache_->GetSquishedDawg(lang, TESSDATA_UNAMBIG_DAWG,
                                                  dawg_debug_level, data_file);
     if (unambig_dawg_) dawgs_ += unambig_dawg_;
   }
 
-  STRING name;
+  std::string name;
   if (!user_words_suffix.empty() || !user_words_file.empty()) {
     Trie* trie_ptr = new Trie(DAWG_TYPE_WORD, lang, USER_DAWG_PERM,
                               getUnicharset().size(), dawg_debug_level);
     if (!user_words_file.empty()) {
       name = user_words_file;
     } else {
       name = getCCUtil()->language_data_path_prefix;
       name += user_words_suffix;
     }
     if (!trie_ptr->read_and_add_word_list(name.c_str(), getUnicharset(),
                                           Trie::RRP_REVERSE_IF_HAS_RTL)) {
       tprintf("Error: failed to load %s\n", name.c_str());
       delete trie_ptr;
     } else {
       dawgs_ += trie_ptr;
     }
   }
 
   if (!user_patterns_suffix.empty() || !user_patterns_file.empty()) {
     Trie* trie_ptr = new Trie(DAWG_TYPE_PATTERN, lang, USER_PATTERN_PERM,
                               getUnicharset().size(), dawg_debug_level);
     trie_ptr->initialize_patterns(&(getUnicharset()));
     if (!user_patterns_file.empty()) {
       name = user_patterns_file;
     } else {
       name = getCCUtil()->language_data_path_prefix;
       name += user_patterns_suffix;
     }
     if (!trie_ptr->read_pattern_list(name.c_str(), getUnicharset())) {
       tprintf("Error: failed to load %s\n", name.c_str());
       delete trie_ptr;
     } else {
       dawgs_ += trie_ptr;
     }
   }
 
   document_words_ = new Trie(DAWG_TYPE_WORD, lang, DOC_DAWG_PERM,
                              getUnicharset().size(), dawg_debug_level);
   dawgs_ += document_words_;
 
   // This dawg is temporary and should not be searched by letter_is_ok.
   pending_words_ = new Trie(DAWG_TYPE_WORD, lang, NO_PERM,
                             getUnicharset().size(), dawg_debug_level);
 }
 
 // Loads the dawgs needed by the LSTM model. Call FinishLoad() after.
 void Dict::LoadLSTM(const STRING& lang, TessdataManager* data_file) {
   // Load dawgs_.
   if (load_punc_dawg) {
     punc_dawg_ = dawg_cache_->GetSquishedDawg(lang, TESSDATA_LSTM_PUNC_DAWG,
                                               dawg_debug_level, data_file);
     if (punc_dawg_) dawgs_ += punc_dawg_;
   }
   if (load_system_dawg) {
     Dawg* system_dawg = dawg_cache_->GetSquishedDawg(
         lang, TESSDATA_LSTM_SYSTEM_DAWG, dawg_debug_level, data_file);
     if (system_dawg) dawgs_ += system_dawg;
   }
   if (load_number_dawg) {
     Dawg* number_dawg = dawg_cache_->GetSquishedDawg(
         lang, TESSDATA_LSTM_NUMBER_DAWG, dawg_debug_level, data_file);
     if (number_dawg) dawgs_ += number_dawg;
   }
 
   // stolen from Dict::Load (but needs params_ from Tesseract
   // langdata/config/api):
-  STRING name;
+  std::string name;
   if (!user_words_suffix.empty() || !user_words_file.empty()) {
     Trie* trie_ptr = new Trie(DAWG_TYPE_WORD, lang, USER_DAWG_PERM,
                               getUnicharset().size(), dawg_debug_level);
     if (!user_words_file.empty()) {
       name = user_words_file;
     } else {
       name = getCCUtil()->language_data_path_prefix;
       name += user_words_suffix;
     }
     if (!trie_ptr->read_and_add_word_list(name.c_str(), getUnicharset(),
                                           Trie::RRP_REVERSE_IF_HAS_RTL)) {
       tprintf("Error: failed to load %s\n", name.c_str());
       delete trie_ptr;
     } else {
       dawgs_ += trie_ptr;
     }
   }
 
   if (!user_patterns_suffix.empty() || !user_patterns_file.empty()) {
     Trie* trie_ptr = new Trie(DAWG_TYPE_PATTERN, lang, USER_PATTERN_PERM,
                               getUnicharset().size(), dawg_debug_level);
     trie_ptr->initialize_patterns(&(getUnicharset()));
     if (!user_patterns_file.empty()) {
       name = user_patterns_file;
     } else {
       name = getCCUtil()->language_data_path_prefix;
       name += user_patterns_suffix;
     }
     if (!trie_ptr->read_pattern_list(name.c_str(), getUnicharset())) {
       tprintf("Error: failed to load %s\n", name.c_str());
       delete trie_ptr;
     } else {
       dawgs_ += trie_ptr;
     }
   }
 }
 
 // Completes the loading process after Load() and/or LoadLSTM().
 // Returns false if no dictionaries were loaded.
@@ -642,56 +642,56 @@ void Dict::default_dawgs(DawgPositionVector* dawg_pos_vec,
 void Dict::add_document_word(const WERD_CHOICE& best_choice) {
   // Do not add hyphenated word parts to the document dawg.
   // hyphen_word_ will be non-nullptr after the set_hyphen_word() is
   // called when the first part of the hyphenated word is
   // discovered and while the second part of the word is recognized.
   // hyphen_word_ is cleared in cc_recg() before the next word on
   // the line is recognized.
   if (hyphen_word_) return;
 
   int stringlen = best_choice.length();
 
   if (valid_word(best_choice) || stringlen < 2) return;
 
   // Discard words that contain >= kDocDictMaxRepChars repeating unichars.
   if (best_choice.length() >= kDocDictMaxRepChars) {
     int num_rep_chars = 1;
     UNICHAR_ID uch_id = best_choice.unichar_id(0);
     for (int i = 1; i < best_choice.length(); ++i) {
       if (best_choice.unichar_id(i) != uch_id) {
         num_rep_chars = 1;
         uch_id = best_choice.unichar_id(i);
       } else {
         ++num_rep_chars;
         if (num_rep_chars == kDocDictMaxRepChars) return;
       }
     }
   }
 
   if (best_choice.certainty() < doc_dict_certainty_threshold ||
       stringlen == 2) {
     if (best_choice.certainty() < doc_dict_pending_threshold) return;
 
     if (!pending_words_->word_in_dawg(best_choice)) {
       if (stringlen > 2 ||
           (stringlen == 2 &&
            getUnicharset().get_isupper(best_choice.unichar_id(0)) &&
            getUnicharset().get_isupper(best_choice.unichar_id(1)))) {
         pending_words_->add_word_to_dawg(best_choice);
       }
       return;
     }
   }
 
   if (save_doc_words) {
-    STRING filename(getCCUtil()->imagefile);
+    std::string filename(getCCUtil()->imagefile);
     filename += ".doc";
     FILE* doc_word_file = fopen(filename.c_str(), "a");
     if (doc_word_file == nullptr) {
       tprintf("Error: Could not open file %s\n", filename.c_str());
       ASSERT_HOST(doc_word_file);
     }
     fprintf(doc_word_file, "%s\n", best_choice.debug_string().c_str());
     fclose(doc_word_file);
   }
   document_words_->add_word_to_dawg(best_choice);
 }
