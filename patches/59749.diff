commit beef8b001431b39738266f96879215d92caaf184
Author: Sean Parkinson <sean@wolfssl.com>
Date:   Fri Jun 16 10:29:52 2023 +1000

    outputBuffer - use idx field
    
    dtls13.c:
    Change end of outputBuffer data calculations to use function
    GetOutputBuffer().
      Use idx when calculating unused byte count of outputBuffer.
    
    internal.c:
    Change end of outputBuffer data calculations to use function
    GetOutputBuffer().
      Use GetOutputBuffer() to calculate end of data in outputBuffer.
      GrowOutputBuffer():
    Calculate new size to allocate to include already written data in
    case of static buffer.
        Copy all data including already written count (idx).
      CheckAvailableSize():
        Don't subtract idx from length when checking MTU size.
    Do subtract idx from bufferSize to determine count of unused bytes
    in outputBuffer.

diff --git a/src/dtls13.c b/src/dtls13.c
index 2e0f68ad6..b5fecafd7 100644
--- a/src/dtls13.c
+++ b/src/dtls13.c
@@ -410,20 +410,20 @@ static WC_INLINE int FragIsInOutputBuffer(WOLFSSL* ssl, const byte* frag)
 static int Dtls13SendFragFromBuffer(WOLFSSL* ssl, byte* output, word16 length)
 {
     byte* buf;
     int ret;
 
     if (FragIsInOutputBuffer(ssl, output))
         return BAD_FUNC_ARG;
 
     ret = CheckAvailableSize(ssl, length);
     if (ret != 0)
         return ret;
 
-    buf = ssl->buffers.outputBuffer.buffer + ssl->buffers.outputBuffer.length;
+    buf = GetOutputBuffer(ssl);
 
     XMEMCPY(buf, output, length);
 
     ssl->buffers.outputBuffer.length += length;
 
     return SendBuffered(ssl);
 }
@@ -895,68 +895,67 @@ static int Dtls13SendOneFragmentRtx(WOLFSSL* ssl,
 static int Dtls13SendFragmentedInternal(WOLFSSL* ssl)
 {
     int fragLength, rlHeaderLength;
     int remainingSize, maxFragment;
     int recordLength;
     byte isEncrypted;
     byte* output;
     int ret;
 
     isEncrypted = Dtls13TypeIsEncrypted(
         (enum HandShakeType)ssl->dtls13FragHandshakeType);
     rlHeaderLength = Dtls13GetRlHeaderLength(ssl, isEncrypted);
     maxFragment = wolfSSL_GetMaxFragSize(ssl, MAX_RECORD_SIZE);
 
     remainingSize = ssl->dtls13MessageLength - ssl->dtls13FragOffset;
 
     while (remainingSize > 0) {
 
         fragLength = maxFragment - rlHeaderLength - DTLS_HANDSHAKE_HEADER_SZ;
 
         recordLength = maxFragment;
 
         if (fragLength > remainingSize) {
             fragLength = remainingSize;
             recordLength =
                 fragLength + rlHeaderLength + DTLS_HANDSHAKE_HEADER_SZ;
         }
 
         ret = CheckAvailableSize(ssl, recordLength + MAX_MSG_EXTRA);
         if (ret != 0)
             return ret;
 
-        output =
-            ssl->buffers.outputBuffer.buffer + ssl->buffers.outputBuffer.length;
+        output = GetOutputBuffer(ssl);
 
         ret = Dtls13HandshakeAddHeaderFrag(ssl, output + rlHeaderLength,
             (enum HandShakeType)ssl->dtls13FragHandshakeType,
             ssl->dtls13FragOffset, fragLength, ssl->dtls13MessageLength);
         if (ret != 0) {
             Dtls13FreeFragmentsBuffer(ssl);
             return ret;
         }
 
         XMEMCPY(output + rlHeaderLength + DTLS_HANDSHAKE_HEADER_SZ,
             ssl->dtls13FragmentsBuffer.buffer + ssl->dtls13FragOffset,
             fragLength);
 
         ret = Dtls13SendOneFragmentRtx(ssl,
             (enum HandShakeType)ssl->dtls13FragHandshakeType,
             (word16)recordLength + MAX_MSG_EXTRA, output, (word32)recordLength, 0);
         if (ret == WANT_WRITE) {
             ssl->dtls13FragOffset += fragLength;
             return ret;
         }
 
         if (ret != 0) {
             Dtls13FreeFragmentsBuffer(ssl);
             return ret;
         }
 
         ssl->dtls13FragOffset += fragLength;
         remainingSize -= fragLength;
     }
 
     /* we sent all fragments */
     Dtls13FreeFragmentsBuffer(ssl);
     return 0;
 }
@@ -1472,95 +1471,94 @@ static void Dtls13RtxMoveToEndOfList(WOLFSSL* ssl, Dtls13RtxRecord** prevNext,
 static int Dtls13RtxSendBuffered(WOLFSSL* ssl)
 {
     word16 headerLength;
     Dtls13RtxRecord *r, **prevNext;
     w64wrapper seq;
     byte* output;
     int isLast;
     int sendSz;
     word32 now;
     int ret;
 
     WOLFSSL_ENTER("Dtls13RtxSendBuffered");
 
     now = LowResTimer();
     if (now - ssl->dtls13Rtx.lastRtx < DTLS13_MIN_RTX_INTERVAL) {
 #ifdef WOLFSSL_DEBUG_TLS
         WOLFSSL_MSG("Avoid too fast retransmission");
 #endif /* WOLFSSL_DEBUG_TLS */
         return 0;
     }
 
     ssl->dtls13Rtx.lastRtx = now;
 
     r = ssl->dtls13Rtx.rtxRecords;
     prevNext = &ssl->dtls13Rtx.rtxRecords;
     while (r != NULL) {
         isLast = r->next == NULL;
         WOLFSSL_MSG("Dtls13Rtx One Record");
 
         headerLength = Dtls13GetRlHeaderLength(ssl, !w64IsZero(r->epoch));
 
         sendSz = r->length + headerLength;
 
         if (!w64IsZero(r->epoch))
             sendSz += MAX_MSG_EXTRA;
 
         ret = CheckAvailableSize(ssl, sendSz);
         if (ret != 0)
             return ret;
 
-        output =
-            ssl->buffers.outputBuffer.buffer + ssl->buffers.outputBuffer.length;
+        output = GetOutputBuffer(ssl);
 
         XMEMCPY(output + headerLength, r->data, r->length);
 
         if (!w64Equal(ssl->dtls13EncryptEpoch->epochNumber, r->epoch)) {
             ret = Dtls13SetEpochKeys(ssl, r->epoch, ENCRYPT_SIDE_ONLY);
             if (ret != 0)
                 return ret;
         }
 
         seq = ssl->dtls13EncryptEpoch->nextSeqNumber;
 
         ret = Dtls13SendFragment(ssl, output, (word16)sendSz, r->length + headerLength,
             (enum HandShakeType)r->handshakeType, 0,
             isLast || !ssl->options.groupMessages);
         if (ret != 0 && ret != WANT_WRITE)
             return ret;
 
         if (r->rnIdx >= DTLS13_RETRANS_RN_SIZE)
             r->rnIdx = 0;
 
 #ifdef WOLFSSL_DEBUG_TLS
         WOLFSSL_MSG_EX("tracking r hs: %d with seq: %ld", r->handshakeType,
             seq);
 #endif /* WOLFSSL_DEBUG_TLS */
 
         r->seq[r->rnIdx] = seq;
         r->rnIdx++;
 
         if (ret == WANT_WRITE) {
             /* this fragment will be sent eventually. Move it to the end of the
                list so next time we start with a new one. */
             Dtls13RtxMoveToEndOfList(ssl, prevNext, r);
             return ret;
         }
 
         prevNext = &r->next;
         r = r->next;
     }
 
     return 0;
 }
 
 /**
  * Dtls13HandshakeRecv() - process an handshake message. Deal with
  fragmentation if needed
  * @ssl: [in] ssl object
  * @input: [in] input buffer
  * @size: [in] input buffer size
  * @type: [out] content type
  * @processedSize: [out] amount of byte processed
  *
  * returns 0 on success
  */
@@ -2307,58 +2305,57 @@ static int Dtls13GetAckListLength(Dtls13RecordNumber* list, word16* length)
 static int Dtls13WriteAckMessage(WOLFSSL* ssl,
     Dtls13RecordNumber* recordNumberList, word32* length)
 {
     word16 msgSz, headerLength;
     byte *output, *ackMessage;
     word32 sendSz;
     int ret;
 
     sendSz = 0;
 
     if (ssl->dtls13EncryptEpoch == NULL)
         return BAD_STATE_E;
 
     if (w64IsZero(ssl->dtls13EncryptEpoch->epochNumber)) {
         /* unprotected ACK */
         headerLength = DTLS_RECORD_HEADER_SZ;
     }
     else {
         headerLength = Dtls13GetRlHeaderLength(ssl, 1);
         sendSz += MAX_MSG_EXTRA;
     }
 
     ret = Dtls13GetAckListLength(recordNumberList, &msgSz);
     if (ret != 0)
         return ret;
 
     sendSz += headerLength;
 
     /* ACK list 2 bytes length field */
     sendSz += OPAQUE16_LEN;
 
     /* ACK list */
     sendSz += msgSz;
 
     ret = CheckAvailableSize(ssl, sendSz);
     if (ret != 0)
         return ret;
 
-    output =
-        ssl->buffers.outputBuffer.buffer + ssl->buffers.outputBuffer.length;
+    output = GetOutputBuffer(ssl);
 
     ackMessage = output + headerLength;
 
     c16toa(msgSz, ackMessage);
     ackMessage += OPAQUE16_LEN;
 
     while (recordNumberList != NULL) {
         c64toa(&recordNumberList->epoch, ackMessage);
         ackMessage += OPAQUE64_LEN;
         c64toa(&recordNumberList->seq, ackMessage);
         ackMessage += OPAQUE64_LEN;
         recordNumberList = recordNumberList->next;
     }
 
     *length = msgSz + OPAQUE16_LEN;
 
     return 0;
 }
@@ -2583,72 +2580,71 @@ int DoDtls13Ack(WOLFSSL* ssl, const byte* input, word32 inputSize,
 int SendDtls13Ack(WOLFSSL* ssl)
 {
     word32 outputSize;
     int headerSize;
     word32 length;
     byte* output;
     int ret;
 
     if (ssl->dtls13EncryptEpoch == NULL)
         return BAD_STATE_E;
 
     WOLFSSL_ENTER("SendDtls13Ack");
 
     ret = 0;
 
     /* The handshake is not complete and the client didn't setup the TRAFFIC0
        epoch yet */
     if (ssl->options.side == WOLFSSL_SERVER_END &&
         !ssl->options.handShakeDone &&
         w64GTE(ssl->dtls13Epoch, w64From32(0, DTLS13_EPOCH_TRAFFIC0))) {
         ret = Dtls13SetEpochKeys(ssl, w64From32(0, DTLS13_EPOCH_HANDSHAKE),
             ENCRYPT_SIDE_ONLY);
     }
     else if (!w64Equal(ssl->dtls13Epoch,
                  ssl->dtls13EncryptEpoch->epochNumber)) {
         ret = Dtls13SetEpochKeys(ssl, ssl->dtls13Epoch, ENCRYPT_SIDE_ONLY);
     }
 
     if (ret != 0)
         return ret;
 
     if (w64IsZero(ssl->dtls13EncryptEpoch->epochNumber)) {
 
         ret = Dtls13WriteAckMessage(ssl, ssl->dtls13Rtx.seenRecords, &length);
         if (ret != 0)
             return ret;
 
-        output =
-            ssl->buffers.outputBuffer.buffer + ssl->buffers.outputBuffer.length;
+        output = GetOutputBuffer(ssl);
 
         ret = Dtls13RlAddPlaintextHeader(ssl, output, ack, (word16)length);
         if (ret != 0)
             return ret;
 
         ssl->buffers.outputBuffer.length += length + DTLS_RECORD_HEADER_SZ;
     }
     else {
 
         ret = Dtls13WriteAckMessage(ssl, ssl->dtls13Rtx.seenRecords, &length);
         if (ret != 0)
             return ret;
 
-        output =
-            ssl->buffers.outputBuffer.buffer + ssl->buffers.outputBuffer.length;
+        output = GetOutputBuffer(ssl);
 
         outputSize = ssl->buffers.outputBuffer.bufferSize -
+                     ssl->buffers.outputBuffer.idx -
                      ssl->buffers.outputBuffer.length;
 
         headerSize = Dtls13GetRlHeaderLength(ssl, 1);
 
         ret = BuildTls13Message(ssl, output, outputSize, output + headerSize,
             length, ack, 0, 0, 0);
         if (ret < 0)
             return ret;
 
         ssl->buffers.outputBuffer.length += ret;
     }
 
     Dtls13RtxFlushAcks(ssl);
 
     return SendBuffered(ssl);
 }
diff --git a/src/internal.c b/src/internal.c
index 5f9629c8a..ca166e8d9 100644
--- a/src/internal.c
+++ b/src/internal.c
@@ -8920,143 +8920,140 @@ int VerifyForTxDtlsMsgDelete(WOLFSSL* ssl, DtlsMsg* item)
 /* DtlsMsgPoolSend() will send the stored transmit list. The stored list is
  * updated with new sequence numbers, and will be re-encrypted if needed. */
 int DtlsMsgPoolSend(WOLFSSL* ssl, int sendOnlyFirstPacket)
 {
     int ret = 0;
     DtlsMsg* pool;
 
     WOLFSSL_ENTER("DtlsMsgPoolSend");
 
     pool = ssl->dtls_tx_msg == NULL ? ssl->dtls_tx_msg_list : ssl->dtls_tx_msg;
 
     if (pool != NULL) {
         if ((ssl->options.side == WOLFSSL_SERVER_END &&
              !(ssl->options.acceptState == ACCEPT_BEGIN_RENEG ||
                ssl->options.acceptState == SERVER_HELLO_DONE ||
                ssl->options.acceptState == ACCEPT_FINISHED_DONE ||
                ssl->options.acceptState == ACCEPT_THIRD_REPLY_DONE)) ||
             (ssl->options.side == WOLFSSL_CLIENT_END &&
              !(ssl->options.connectState == CLIENT_HELLO_SENT ||
                ssl->options.connectState == HELLO_AGAIN_REPLY ||
                ssl->options.connectState == FINISHED_DONE ||
                ssl->options.connectState == SECOND_REPLY_DONE))) {
 
             WOLFSSL_ERROR(DTLS_RETX_OVER_TX);
             ssl->error = DTLS_RETX_OVER_TX;
             return WOLFSSL_FATAL_ERROR;
         }
 
         while (pool != NULL) {
             int epochOrder;
 
             if (pool->epoch == 0) {
                 DtlsRecordLayerHeader* dtls;
 
                 dtls = (DtlsRecordLayerHeader*)pool->raw;
                 /* If the stored record's epoch is 0, and the currently set
                  * epoch is 0, use the "current order" sequence number.
                  * If the stored record's epoch is 0 and the currently set
                  * epoch is not 0, the stored record is considered a "previous
                  * order" sequence number. */
                 epochOrder = (ssl->keys.dtls_epoch == 0) ?
                              CUR_ORDER : PREV_ORDER;
 
                 WriteSEQ(ssl, epochOrder, dtls->sequence_number);
                 DtlsSEQIncrement(ssl, epochOrder);
                 if ((ret = CheckAvailableSize(ssl, pool->sz)) != 0) {
                     WOLFSSL_ERROR(ret);
                     return ret;
                 }
 
-                XMEMCPY(ssl->buffers.outputBuffer.buffer +
-                        ssl->buffers.outputBuffer.idx +
-                        ssl->buffers.outputBuffer.length,
-                        pool->raw, pool->sz);
+                XMEMCPY(GetOutputBuffer(ssl), pool->raw, pool->sz);
                 ssl->buffers.outputBuffer.length += pool->sz;
             }
             else {
                 /* Handle sending packets from previous epoch */
                 byte*  input;
                 byte*  output;
                 int    inputSz, sendSz;
 
                 input = pool->raw;
                 inputSz = pool->sz;
                 sendSz = inputSz + cipherExtraData(ssl);
 
 #ifdef HAVE_SECURE_RENEGOTIATION
                 /*
                  * CUR_ORDER will use ssl->secure_renegotiation from epoch 2+.
                  * ssl->keys otherwise
                  * PREV_ORDER will always use ssl->keys
                  */
                 if (DtlsSCRKeysSet(ssl)) {
                     if (pool->epoch == ssl->secure_renegotiation->tmp_keys.dtls_epoch)
                         epochOrder = CUR_ORDER;
                     else
                         epochOrder = PREV_ORDER;
                 }
                 else {
                     epochOrder = CUR_ORDER;
                 }
 #else
                 epochOrder = CUR_ORDER;
 #endif
 
 
                 /* add back in record header space from saved pool size */
                 sendSz += DTLS_RECORD_HEADER_SZ;
 
                 if ((ret = CheckAvailableSize(ssl, sendSz)) != 0) {
                     WOLFSSL_ERROR(ret);
                     return ret;
                 }
 
                 output = GetOutputBuffer(ssl);
                 if (inputSz != ENUM_LEN)
                     sendSz = BuildMessage(ssl, output, sendSz, input, inputSz,
                                           handshake, 0, 0, 0, epochOrder);
                 else
                     /* inputSz == ENUM_LEN must mean that this is a change cipher
                      * spec message */
                     sendSz = BuildMessage(ssl, output, sendSz, input, inputSz,
                                           change_cipher_spec, 0, 0, 0, epochOrder);
 
                 if (sendSz < 0) {
                     WOLFSSL_ERROR(BUILD_MSG_ERROR);
                     return BUILD_MSG_ERROR;
                 }
 
                 ssl->buffers.outputBuffer.length += sendSz;
             }
 
 
             if (!ssl->options.groupMessages)
                 ret = SendBuffered(ssl);
 
             /**
              * on server side, retransmission is being triggered only by sending
              * first message of given flight, in order to trigger client
              * to retransmit its whole flight. Sending the whole previous flight
              * could lead to retransmission of previous client flight for each
              * server message from previous flight. Therefore one message should
              * be enough to do the trick.
              */
             if (sendOnlyFirstPacket &&
                 ssl->options.side == WOLFSSL_SERVER_END)
                 pool = NULL;
             else
                 pool = pool->next;
             ssl->dtls_tx_msg = pool;
         }
 
         if (ret == 0 && ssl->options.groupMessages)
             ret = SendBuffered(ssl);
     }
 
     WOLFSSL_LEAVE("DtlsMsgPoolSend()", ret);
     return ret;
 }
 
 #endif /* WOLFSSL_DTLS */
 
 #if defined(WOLFSSL_ALLOW_SSLV3) && !defined(NO_OLD_TLS)
@@ -9943,18 +9940,19 @@ retry:
 /* Switch dynamic output buffer back to static, buffer is assumed clear */
 void ShrinkOutputBuffer(WOLFSSL* ssl)
 {
     WOLFSSL_MSG("Shrinking output buffer");
     XFREE(ssl->buffers.outputBuffer.buffer - ssl->buffers.outputBuffer.offset,
           ssl->heap, DYNAMIC_TYPE_OUT_BUFFER);
     ssl->buffers.outputBuffer.buffer = ssl->buffers.outputBuffer.staticBuffer;
     ssl->buffers.outputBuffer.bufferSize  = STATIC_BUFFER_LEN;
     ssl->buffers.outputBuffer.dynamicFlag = 0;
     ssl->buffers.outputBuffer.offset      = 0;
+    /* idx and length are assumed to be 0. */
 }
 
 
 /* Switch dynamic input buffer back to static, keep any remaining input */
 /* forced free means cleaning up */
 /* Be *CAREFUL* where this function is called. ProcessReply relies on
  * inputBuffer.idx *NOT* changing inside the ProcessReply function. ProcessReply
  * calls ShrinkInputBuffer itself when it is safe to do so. Don't overuse it. */
@@ -10083,69 +10081,69 @@ byte* GetOutputBuffer(WOLFSSL* ssl)
 /* Grow the output buffer */
 static WC_INLINE int GrowOutputBuffer(WOLFSSL* ssl, int size)
 {
     byte* tmp;
 #if WOLFSSL_GENERAL_ALIGNMENT > 0
     byte  hdrSz = ssl->options.dtls ? DTLS_RECORD_HEADER_SZ :
                                       RECORD_HEADER_SZ;
     byte align = WOLFSSL_GENERAL_ALIGNMENT;
 #else
     const byte align = WOLFSSL_GENERAL_ALIGNMENT;
 #endif
+    int newSz = size + ssl->buffers.outputBuffer.idx +
+                ssl->buffers.outputBuffer.length;
 
 #if WOLFSSL_GENERAL_ALIGNMENT > 0
     /* the encrypted data will be offset from the front of the buffer by
        the header, if the user wants encrypted alignment they need
        to define their alignment requirement */
 
     while (align < hdrSz)
         align *= 2;
 #endif
 
-    tmp = (byte*)XMALLOC(size + ssl->buffers.outputBuffer.length + align,
-                             ssl->heap, DYNAMIC_TYPE_OUT_BUFFER);
+    tmp = (byte*)XMALLOC(newSz + align, ssl->heap, DYNAMIC_TYPE_OUT_BUFFER);
     WOLFSSL_MSG("growing output buffer");
 
     if (tmp == NULL)
         return MEMORY_E;
 
 #if WOLFSSL_GENERAL_ALIGNMENT > 0
     if (align)
         tmp += align - hdrSz;
 #endif
 
 #ifdef WOLFSSL_STATIC_MEMORY
     /* can be from IO memory pool which does not need copy if same buffer */
     if (ssl->buffers.outputBuffer.length &&
             tmp == ssl->buffers.outputBuffer.buffer) {
-        ssl->buffers.outputBuffer.bufferSize =
-            size + ssl->buffers.outputBuffer.length;
+        ssl->buffers.outputBuffer.bufferSize = newSz;
         return 0;
     }
 #endif
 
     if (ssl->buffers.outputBuffer.length)
         XMEMCPY(tmp, ssl->buffers.outputBuffer.buffer,
+               ssl->buffers.outputBuffer.idx +
                ssl->buffers.outputBuffer.length);
 
     if (ssl->buffers.outputBuffer.dynamicFlag) {
         XFREE(ssl->buffers.outputBuffer.buffer -
               ssl->buffers.outputBuffer.offset, ssl->heap,
               DYNAMIC_TYPE_OUT_BUFFER);
     }
     ssl->buffers.outputBuffer.dynamicFlag = 1;
 
 #if WOLFSSL_GENERAL_ALIGNMENT > 0
     if (align)
         ssl->buffers.outputBuffer.offset = align - hdrSz;
     else
 #endif
         ssl->buffers.outputBuffer.offset = 0;
 
     ssl->buffers.outputBuffer.buffer = tmp;
-    ssl->buffers.outputBuffer.bufferSize = size +
-                                           ssl->buffers.outputBuffer.length;
+    ssl->buffers.outputBuffer.bufferSize = newSz;
     return 0;
 }
 
 
 /* Grow the input buffer, should only be to read cert or big app data */
@@ -10231,56 +10229,56 @@ int GrowInputBuffer(WOLFSSL* ssl, int size, int usedLength)
 /* Check available size into output buffer, make room if needed.
  * This function needs to be called before anything gets put
  * into the output buffers since it flushes pending data if it
  * predicts that the msg will exceed MTU. */
 int CheckAvailableSize(WOLFSSL *ssl, int size)
 {
     if (size < 0) {
         WOLFSSL_MSG("CheckAvailableSize() called with negative number");
         return BAD_FUNC_ARG;
     }
 
 #ifdef WOLFSSL_DTLS
     if (ssl->options.dtls) {
-        if (size + ssl->buffers.outputBuffer.length -
-            ssl->buffers.outputBuffer.idx >
+        if (size + ssl->buffers.outputBuffer.length >
 #if defined(WOLFSSL_SCTP) || defined(WOLFSSL_DTLS_MTU)
                 ssl->dtlsMtuSz
 #else
                 ssl->dtls_expected_rx
 #endif
                 ) {
             int ret;
             WOLFSSL_MSG("CheckAvailableSize() flushing buffer "
                         "to make room for new message");
             if ((ret = SendBuffered(ssl)) != 0) {
                 return ret;
             }
         }
         if (size > (int)
 #if defined(WOLFSSL_SCTP) || defined(WOLFSSL_DTLS_MTU)
                 ssl->dtlsMtuSz
 #else
                 ssl->dtls_expected_rx
 #endif
 #ifdef WOLFSSL_DTLS13
             /* DTLS1.3 uses the output buffer to store the full message and deal
                with fragmentation later in dtls13HandshakeSend() */
             && !IsAtLeastTLSv1_3(ssl->version)
 #endif /* WOLFSSL_DTLS13 */
             ) {
             WOLFSSL_MSG("CheckAvailableSize() called with size greater than MTU.");
             return DTLS_SIZE_ERROR;
         }
     }
 #endif
 
-    if (ssl->buffers.outputBuffer.bufferSize - ssl->buffers.outputBuffer.length
-                                             < (word32)size) {
+    if ((ssl->buffers.outputBuffer.bufferSize -
+             ssl->buffers.outputBuffer.length -
+             ssl->buffers.outputBuffer.idx) < (word32)size) {
         if (GrowOutputBuffer(ssl, size) < 0)
             return MEMORY_E;
     }
 
     return 0;
 }
 
 #ifdef WOLFSSL_DTLS13
@@ -21826,306 +21824,304 @@ int SendCertificate(WOLFSSL* ssl)
 /* handle generation of certificate_request (13) */
 int SendCertificateRequest(WOLFSSL* ssl)
 {
     byte   *output;
     int    ret;
     int    sendSz;
     word32 i = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
     word32 dnLen = 0;
 #if defined(OPENSSL_ALL) || defined(WOLFSSL_NGINX) || defined(HAVE_LIGHTY)
     WOLF_STACK_OF(WOLFSSL_X509_NAME)* names;
 #endif
     const Suites* suites = WOLFSSL_SUITES(ssl);
 
     int  typeTotal = 1;  /* only 1 for now */
     int  reqSz = ENUM_LEN + typeTotal + REQ_HEADER_SZ;  /* add auth later */
 
     WOLFSSL_START(WC_FUNC_CERTIFICATE_REQUEST_SEND);
     WOLFSSL_ENTER("SendCertificateRequest");
 
     if (IsAtLeastTLSv1_2(ssl))
         reqSz += LENGTH_SZ + suites->hashSigAlgoSz;
 
 #if defined(OPENSSL_ALL) || defined(WOLFSSL_NGINX) || defined(HAVE_LIGHTY)
     /* Certificate Authorities */
     names = SSL_CA_NAMES(ssl);
     while (names != NULL) {
         byte seq[MAX_SEQ_SZ];
         WOLFSSL_X509_NAME* name = names->data.name;
 
         if (name != NULL) {
             /* 16-bit length | SEQ | Len | DER of name */
             dnLen += OPAQUE16_LEN + SetSequence(name->rawLen, seq) +
                         name->rawLen;
         }
         names = names->next;
     }
     reqSz += dnLen;
 #endif
 
     if (ssl->options.usingPSK_cipher || ssl->options.usingAnon_cipher)
         return 0;  /* not needed */
 
     sendSz = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ + reqSz;
 
     if (!ssl->options.dtls) {
         if (IsEncryptionOn(ssl, 1))
             sendSz += MAX_MSG_EXTRA;
     }
     else {
     #ifdef WOLFSSL_DTLS
         sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
         i      += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
     #endif
     }
 
     if (IsEncryptionOn(ssl, 1))
         sendSz += cipherExtraData(ssl);
 
     /* Set this in case CheckAvailableSize returns a WANT_WRITE so that state
      * is not advanced yet */
     ssl->options.buildingMsg = 1;
 
     /* check for available size */
     if ((ret = CheckAvailableSize(ssl, sendSz)) != 0)
         return ret;
 
     /* get output buffer */
-    output = ssl->buffers.outputBuffer.buffer +
-             ssl->buffers.outputBuffer.length;
+    output = GetOutputBuffer(ssl);
 
     AddHeaders(output, reqSz, certificate_request, ssl);
 
     /* write to output */
     output[i++] = (byte)typeTotal;  /* # of types */
 #ifdef HAVE_ECC
     if ((ssl->options.cipherSuite0 == ECC_BYTE ||
          ssl->options.cipherSuite0 == CHACHA_BYTE) &&
                      ssl->specs.sig_algo == ecc_dsa_sa_algo) {
         output[i++] = ecdsa_sign;
     } else
 #endif /* HAVE_ECC */
     {
         output[i++] = rsa_sign;
     }
 
     /* supported hash/sig */
     if (IsAtLeastTLSv1_2(ssl)) {
         c16toa(suites->hashSigAlgoSz, &output[i]);
         i += OPAQUE16_LEN;
 
         XMEMCPY(&output[i], suites->hashSigAlgo, suites->hashSigAlgoSz);
         i += suites->hashSigAlgoSz;
     }
 
     /* Certificate Authorities */
     c16toa((word16)dnLen, &output[i]);  /* auth's */
     i += REQ_HEADER_SZ;
 #if defined(OPENSSL_ALL) || defined(WOLFSSL_NGINX) || defined(HAVE_LIGHTY)
     names = SSL_CA_NAMES(ssl);
     while (names != NULL) {
         byte seq[MAX_SEQ_SZ];
         WOLFSSL_X509_NAME* name = names->data.name;
 
         if (name != NULL) {
             c16toa((word16)name->rawLen +
                    (word16)SetSequence(name->rawLen, seq), &output[i]);
             i += OPAQUE16_LEN;
             i += SetSequence(name->rawLen, output + i);
             XMEMCPY(output + i, name->raw, name->rawLen);
             i += name->rawLen;
         }
         names = names->next;
     }
 #endif
     (void)i;
 
         if (IsEncryptionOn(ssl, 1)) {
             byte* input = NULL;
             int   inputSz = i; /* build msg adds rec hdr */
             int   recordHeaderSz = RECORD_HEADER_SZ;
 
             if (ssl->options.dtls)
                 recordHeaderSz += DTLS_RECORD_EXTRA;
             inputSz -= recordHeaderSz;
 
             if (inputSz <= 0) {
                 WOLFSSL_MSG("Send Cert Req bad inputSz");
                 return BUFFER_E;
             }
 
             input = (byte*)XMALLOC(inputSz, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
             if (input == NULL)
                 return MEMORY_E;
 
             XMEMCPY(input, output + recordHeaderSz, inputSz);
             #ifdef WOLFSSL_DTLS
             if (IsDtlsNotSctpMode(ssl) &&
                     (ret = DtlsMsgPoolSave(ssl, input, inputSz, certificate_request)) != 0) {
                 XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
                 return ret;
             }
             #endif
             sendSz = BuildMessage(ssl, output, sendSz, input, inputSz,
                                   handshake, 1, 0, 0, CUR_ORDER);
             XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
 
             if (sendSz < 0)
                 return sendSz;
         } else {
             sendSz = i;
             #ifdef WOLFSSL_DTLS
                 if (IsDtlsNotSctpMode(ssl)) {
                     if ((ret = DtlsMsgPoolSave(ssl, output, sendSz, certificate_request)) != 0)
                         return ret;
                 }
                 if (ssl->options.dtls)
                     DtlsSEQIncrement(ssl, CUR_ORDER);
             #endif
             ret = HashOutput(ssl, output, sendSz, 0);
             if (ret != 0)
                 return ret;
         }
 
     #if defined(WOLFSSL_CALLBACKS) || defined(OPENSSL_EXTRA)
         if (ssl->hsInfoOn)
             AddPacketName(ssl, "CertificateRequest");
         if (ssl->toInfoOn) {
             ret = AddPacketInfo(ssl, "CertificateRequest", handshake, output,
                     sendSz, WRITE_PROTO, 0, ssl->heap);
             if (ret != 0)
                 return ret;
         }
     #endif
     ssl->buffers.outputBuffer.length += sendSz;
     if (ssl->options.groupMessages)
         ret = 0;
     else
         ret = SendBuffered(ssl);
 
     ssl->options.buildingMsg = 0;
 
     WOLFSSL_LEAVE("SendCertificateRequest", ret);
     WOLFSSL_END(WC_FUNC_CERTIFICATE_REQUEST_SEND);
 
     return ret;
 }
 
 #ifndef NO_WOLFSSL_SERVER
 #if defined(HAVE_CERTIFICATE_STATUS_REQUEST) \
  || defined(HAVE_CERTIFICATE_STATUS_REQUEST_V2)
 static int BuildCertificateStatus(WOLFSSL* ssl, byte type, buffer* status,
                                                                      byte count)
 {
     byte*  output  = NULL;
     word32 idx     = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
     word32 length  = ENUM_LEN;
     int    sendSz  = 0;
     int    ret     = 0;
     int    i       = 0;
 
     WOLFSSL_ENTER("BuildCertificateStatus");
 
     switch (type) {
         case WOLFSSL_CSR2_OCSP_MULTI:
             length += OPAQUE24_LEN;
             FALL_THROUGH; /* followed by */
 
         case WOLFSSL_CSR2_OCSP:
             for (i = 0; i < count; i++)
                 length += OPAQUE24_LEN + status[i].length;
         break;
 
         default:
             return 0;
     }
 
     sendSz = idx + length;
 
     if (ssl->keys.encryptionOn)
         sendSz += MAX_MSG_EXTRA;
 
     /* Set this in case CheckAvailableSize returns a WANT_WRITE so that state
      * is not advanced yet */
     ssl->options.buildingMsg = 1;
 
     if ((ret = CheckAvailableSize(ssl, sendSz)) == 0) {
-        output = ssl->buffers.outputBuffer.buffer +
-                 ssl->buffers.outputBuffer.length;
+        output = GetOutputBuffer(ssl);
 
         AddHeaders(output, length, certificate_status, ssl);
 
         output[idx++] = type;
 
         if (type == WOLFSSL_CSR2_OCSP_MULTI) {
             c32to24(length - (ENUM_LEN + OPAQUE24_LEN), output + idx);
             idx += OPAQUE24_LEN;
         }
 
         for (i = 0; i < count; i++) {
             c32to24(status[i].length, output + idx);
             idx += OPAQUE24_LEN;
 
             XMEMCPY(output + idx, status[i].buffer, status[i].length);
             idx += status[i].length;
         }
 
         if (IsEncryptionOn(ssl, 1)) {
             byte* input;
             int   inputSz = idx; /* build msg adds rec hdr */
             int   recordHeaderSz = RECORD_HEADER_SZ;
 
             if (ssl->options.dtls)
                 recordHeaderSz += DTLS_RECORD_EXTRA;
             inputSz -= recordHeaderSz;
             input = (byte*)XMALLOC(inputSz, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
             if (input == NULL)
                 return MEMORY_E;
 
             XMEMCPY(input, output + recordHeaderSz, inputSz);
             #ifdef WOLFSSL_DTLS
                 ret = DtlsMsgPoolSave(ssl, input, inputSz, certificate_status);
             #endif
             if (ret == 0)
                 sendSz = BuildMessage(ssl, output, sendSz, input, inputSz,
                                       handshake, 1, 0, 0, CUR_ORDER);
             XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
 
             if (sendSz < 0)
                 ret = sendSz;
         }
         else {
             #ifdef WOLFSSL_DTLS
                 if (ret == 0 && IsDtlsNotSctpMode(ssl))
                     ret = DtlsMsgPoolSave(ssl, output, sendSz, certificate_status);
                 if (ret == 0 && ssl->options.dtls)
                     DtlsSEQIncrement(ssl, CUR_ORDER);
             #endif
             ret = HashOutput(ssl, output, sendSz, 0);
         }
 
     #if defined(WOLFSSL_CALLBACKS) || defined(OPENSSL_EXTRA)
         if (ret == 0 && ssl->hsInfoOn)
             AddPacketName(ssl, "CertificateStatus");
         if (ret == 0 && ssl->toInfoOn) {
             ret = AddPacketInfo(ssl, "CertificateStatus", handshake, output,
                     sendSz, WRITE_PROTO, 0, ssl->heap);
             if (ret != 0)
                 return ret;
         }
     #endif
 
         if (ret == 0) {
             ssl->options.buildingMsg = 0;
             ssl->buffers.outputBuffer.length += sendSz;
             if (!ssl->options.groupMessages)
                 ret = SendBuffered(ssl);
         }
     }
 
     WOLFSSL_LEAVE("BuildCertificateStatus", ret);
     return ret;
 }
 #endif
 #endif /* NO_WOLFSSL_SERVER */
 
 /* handle generation of certificate_status (22) */
@@ -22473,251 +22469,250 @@ static int CheckTLS13AEADSendLimit(WOLFSSL* ssl)
 int SendData(WOLFSSL* ssl, const void* data, int sz)
 {
     int sent = 0,  /* plainText size */
         sendSz,
         ret;
 #if defined(WOLFSSL_EARLY_DATA) && defined(WOLFSSL_EARLY_DATA_GROUP)
     int groupMsgs = 0;
 #endif
 
     if (ssl->error == WANT_WRITE
     #ifdef WOLFSSL_ASYNC_CRYPT
         || ssl->error == WC_PENDING_E
     #endif
     ) {
         ssl->error = 0;
     }
 
     /* don't allow write after decrypt or mac error */
     if (ssl->error == VERIFY_MAC_ERROR || ssl->error == DECRYPT_ERROR) {
         /* For DTLS allow these possible errors and allow the session
             to continue despite them */
         if (ssl->options.dtls) {
             ssl->error = 0;
         }
         else {
             WOLFSSL_MSG("Not allowing write after decrypt or mac error");
             return WOLFSSL_FATAL_ERROR;
         }
     }
 
 #ifdef WOLFSSL_EARLY_DATA
     if (ssl->earlyData != no_early_data) {
         if (ssl->options.handShakeState == HANDSHAKE_DONE) {
             WOLFSSL_MSG("handshake complete, trying to send early data");
             ssl->error = BUILD_MSG_ERROR;
             return WOLFSSL_FATAL_ERROR;
         }
     #ifdef WOLFSSL_EARLY_DATA_GROUP
         groupMsgs = 1;
     #endif
     }
     else
 #endif
     if (ssl->options.handShakeState != HANDSHAKE_DONE && !IsSCR(ssl)) {
         int err;
         WOLFSSL_MSG("handshake not complete, trying to finish");
         if ( (err = wolfSSL_negotiate(ssl)) != WOLFSSL_SUCCESS) {
         #ifdef WOLFSSL_ASYNC_CRYPT
             /* if async would block return WANT_WRITE */
             if (ssl->error == WC_PENDING_E) {
                 return WOLFSSL_CBIO_ERR_WANT_WRITE;
             }
         #endif
             return  err;
         }
     }
 
     /* last time system socket output buffer was full, try again to send */
     if (ssl->buffers.outputBuffer.length > 0
     #if defined(WOLFSSL_EARLY_DATA) && defined(WOLFSSL_EARLY_DATA_GROUP)
         && !groupMsgs
     #endif
         ) {
         WOLFSSL_MSG("output buffer was full, trying to send again");
         if ( (ssl->error = SendBuffered(ssl)) < 0) {
             WOLFSSL_ERROR(ssl->error);
             if (ssl->error == SOCKET_ERROR_E && (ssl->options.connReset ||
                                                  ssl->options.isClosed)) {
                 ssl->error = SOCKET_PEER_CLOSED_E;
                 WOLFSSL_ERROR(ssl->error);
                 return 0;  /* peer reset or closed */
             }
             return ssl->error;
         }
         else {
             /* advance sent to previous sent + plain size just sent */
             sent = ssl->buffers.prevSent + ssl->buffers.plainSz;
             WOLFSSL_MSG("sent write buffered data");
 
             if (sent > sz) {
                 WOLFSSL_MSG("error: write() after WANT_WRITE with short size");
                 return ssl->error = BAD_FUNC_ARG;
             }
         }
     }
 
     ret = RetrySendAlert(ssl);
     if (ret != 0) {
         ssl->error = ret;
         return WOLFSSL_FATAL_ERROR;
     }
 
     for (;;) {
         byte* out;
         byte* sendBuffer = (byte*)data + sent;  /* may switch on comp */
         int   buffSz;                           /* may switch on comp */
         int   outputSz;
 #ifdef HAVE_LIBZ
         byte  comp[MAX_RECORD_SIZE + MAX_COMP_EXTRA];
 #endif
 
 #if defined(WOLFSSL_TLS13) && !defined(WOLFSSL_TLS13_IGNORE_AEAD_LIMITS)
         if (IsAtLeastTLSv1_3(ssl->version)) {
             ret = CheckTLS13AEADSendLimit(ssl);
             if (ret != 0) {
                 ssl->error = ret;
                 return WOLFSSL_FATAL_ERROR;
             }
         }
 #endif
 
 #ifdef WOLFSSL_DTLS13
         if (ssl->options.dtls && ssl->options.tls1_3) {
             byte isEarlyData = 0;
 
             if (ssl->dtls13EncryptEpoch == NULL)
                 return ssl->error = BAD_STATE_E;
 
 #ifdef WOLFSSL_EARLY_DATA
             isEarlyData = ssl->earlyData != no_early_data;
 #endif
 
             if (isEarlyData) {
 #ifdef WOLFSSL_EARLY_DATA
                 ret = Dtls13SetEpochKeys(ssl,
                     w64From32(0x0, DTLS13_EPOCH_EARLYDATA), ENCRYPT_SIDE_ONLY);
                 if (ret != 0) {
                     WOLFSSL_MSG(
                         "trying to send early data without epoch 1");
                     ssl->error = BUILD_MSG_ERROR;
                     return WOLFSSL_FATAL_ERROR;
                 }
 #endif /* WOLFSSL_EARLY_DATA */
             }
             else if (!w64Equal(
                          ssl->dtls13EncryptEpoch->epochNumber,
                          ssl->dtls13Epoch)) {
                 ret = Dtls13SetEpochKeys(
                     ssl, ssl->dtls13Epoch, ENCRYPT_SIDE_ONLY);
                 if (ret != 0) {
                     ssl->error = BUILD_MSG_ERROR;
                     return WOLFSSL_FATAL_ERROR;
                 }
             }
         }
 #endif /* WOLFSSL_DTLS13 */
 
 #ifdef WOLFSSL_DTLS
         if (ssl->options.dtls) {
             buffSz = wolfSSL_GetMaxFragSize(ssl, sz - sent);
         }
         else
 #endif
         {
             buffSz = wolfSSL_GetMaxFragSize(ssl, sz - sent);
 
         }
 
         if (sent == sz) break;
 
 #if defined(WOLFSSL_DTLS) && !defined(WOLFSSL_NO_DTLS_SIZE_CHECK)
         if (ssl->options.dtls && (buffSz < sz - sent)) {
             ssl->error = DTLS_SIZE_ERROR;
             WOLFSSL_ERROR(ssl->error);
             return ssl->error;
         }
 #endif
         outputSz = buffSz + COMP_EXTRA + DTLS_RECORD_HEADER_SZ;
         if (IsEncryptionOn(ssl, 1) || ssl->options.tls1_3)
             outputSz += cipherExtraData(ssl);
 
         /* check for available size */
         if ((ret = CheckAvailableSize(ssl, outputSz)) != 0)
             return ssl->error = ret;
 
         /* get output buffer */
-        out = ssl->buffers.outputBuffer.buffer +
-              ssl->buffers.outputBuffer.length;
+        out = GetOutputBuffer(ssl);
 
 #ifdef HAVE_LIBZ
         if (ssl->options.usingCompression) {
             buffSz = myCompress(ssl, sendBuffer, buffSz, comp, sizeof(comp));
             if (buffSz < 0) {
                 return buffSz;
             }
             sendBuffer = comp;
         }
 #endif
         if (!ssl->options.tls1_3) {
 #ifdef WOLFSSL_ASYNC_CRYPT
             if (ssl->async == NULL) {
                 ssl->async = (struct WOLFSSL_ASYNC*)
                         XMALLOC(sizeof(struct WOLFSSL_ASYNC), ssl->heap,
                                 DYNAMIC_TYPE_ASYNC);
                 if (ssl->async == NULL)
                     return MEMORY_E;
                 ssl->async->freeArgs = NULL;
             }
 #endif
             sendSz = BuildMessage(ssl, out, outputSz, sendBuffer, buffSz,
                                   application_data, 0, 0, 1, CUR_ORDER);
         }
         else {
 #ifdef WOLFSSL_TLS13
             sendSz = BuildTls13Message(ssl, out, outputSz, sendBuffer, buffSz,
                                        application_data, 0, 0, 1);
 #else
             sendSz = BUFFER_ERROR;
 #endif
         }
         if (sendSz < 0) {
         #ifdef WOLFSSL_ASYNC_CRYPT
             if (sendSz == WC_PENDING_E)
                 ssl->error = sendSz;
         #endif
             return BUILD_MSG_ERROR;
         }
 
 #ifdef WOLFSSL_ASYNC_CRYPT
         FreeAsyncCtx(ssl, 0);
 #endif
         ssl->buffers.outputBuffer.length += sendSz;
 
         if ( (ssl->error = SendBuffered(ssl)) < 0) {
             WOLFSSL_ERROR(ssl->error);
             /* store for next call if WANT_WRITE or user embedSend() that
                doesn't present like WANT_WRITE */
             ssl->buffers.plainSz  = buffSz;
             ssl->buffers.prevSent = sent;
             if (ssl->error == SOCKET_ERROR_E && (ssl->options.connReset ||
                                                  ssl->options.isClosed)) {
                 ssl->error = SOCKET_PEER_CLOSED_E;
                 WOLFSSL_ERROR(ssl->error);
                 return 0;  /* peer reset or closed */
             }
             return ssl->error;
         }
 
         sent += buffSz;
 
         /* only one message per attempt */
         if (ssl->options.partialWrite == 1) {
             WOLFSSL_MSG("Partial Write on, only sending one record");
             break;
         }
     }
 
     return sent;
 }
 
 /* process input data */
@@ -26246,1263 +26241,1262 @@ exit_dpk:
 #ifndef WOLFSSL_NO_TLS12
 #if (!defined(NO_WOLFSSL_CLIENT) && (!defined(NO_DH) || defined(HAVE_ECC) || \
       defined(HAVE_CURVE25519) || defined(HAVE_CURVE448))) || \
     (!defined(NO_WOLFSSL_SERVER) && (defined(HAVE_ECC) || \
       ((defined(HAVE_CURVE25519) || defined(HAVE_CURVE448)) && \
        (defined(HAVE_ED25519) || defined(HAVE_ED448) || !defined(NO_RSA)))) || \
      (!defined(NO_DH) && (!defined(NO_RSA) || defined(HAVE_ANON))))
 static int HashSkeData(WOLFSSL* ssl, enum wc_HashType hashType,
     const byte* data, int sz, byte sigAlgo)
 {
     int ret = 0;
     int digest_sz = wc_HashGetDigestSize(hashType);
 
     if (digest_sz <= 0) {
         ret = BUFFER_ERROR;
     }
 
     if (ret == 0) {
         /* buffer for signature */
         ssl->buffers.sig.buffer = (byte*)XMALLOC(SEED_LEN + sz, ssl->heap,
                                                         DYNAMIC_TYPE_SIGNATURE);
         if (ssl->buffers.sig.buffer == NULL) {
             ret = MEMORY_E;
         }
     }
     if (ret == 0) {
         ssl->buffers.sig.length = SEED_LEN + sz;
 
         /* build message to hash */
         XMEMCPY(ssl->buffers.sig.buffer, ssl->arrays->clientRandom, RAN_LEN);
         XMEMCPY(&ssl->buffers.sig.buffer[RAN_LEN], ssl->arrays->serverRandom,
             RAN_LEN);
         /* message */
         XMEMCPY(&ssl->buffers.sig.buffer[RAN_LEN * 2], data, sz);
     }
     if (ret == 0 && sigAlgo != ed25519_sa_algo && sigAlgo != ed448_sa_algo) {
          ssl->buffers.digest.length = (unsigned int)digest_sz;
 
         /* buffer for hash */
         if (!ssl->buffers.digest.buffer) {
             if (!ssl->options.dontFreeDigest) {
                 XFREE(ssl->buffers.digest.buffer, ssl->heap,
                     DYNAMIC_TYPE_DIGEST);
             }
         }
         ssl->options.dontFreeDigest = 0;
 
         ssl->buffers.digest.buffer = (byte*)XMALLOC(ssl->buffers.digest.length,
             ssl->heap, DYNAMIC_TYPE_DIGEST);
         if (ssl->buffers.digest.buffer == NULL) {
             ret = MEMORY_E;
         }
     }
     if (ret == 0 && sigAlgo != ed25519_sa_algo && sigAlgo != ed448_sa_algo) {
         /* Perform hash. Only wc_Hash supports MD5_SHA1. */
         ret = wc_Hash(hashType, ssl->buffers.sig.buffer,
                                 ssl->buffers.sig.length,
                                 ssl->buffers.digest.buffer,
                                 ssl->buffers.digest.length);
 #ifdef HAVE_PK_CALLBACKS
         if (ssl->ctx->ProcessServerSigKexCb == NULL)
 #endif
         {
             /* No further processing will be done. It can be freed. */
             XFREE(ssl->buffers.sig.buffer, ssl->heap, DYNAMIC_TYPE_SIGNATURE);
             ssl->buffers.sig.buffer = NULL;
         }
     }
 
     return ret;
 }
 #endif
 #endif /* !WOLFSSL_NO_TLS12 */
 
 /* client only parts */
 #ifndef NO_WOLFSSL_CLIENT
 
 #ifndef WOLFSSL_NO_TLS12
 
     /* handle generation of client_hello (1) */
     int SendClientHello(WOLFSSL* ssl)
     {
         byte              *output;
         word32             length, idx = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
         int                sendSz;
         int                idSz;
         int                ret;
         word16             extSz = 0;
         const Suites*      suites;
 
         if (ssl == NULL) {
             return BAD_FUNC_ARG;
         }
 
         idSz = ssl->options.resuming ? ssl->session->sessionIDSz : 0;
 
 #ifdef WOLFSSL_TLS13
         if (IsAtLeastTLSv1_3(ssl->version))
             return SendTls13ClientHello(ssl);
 #endif
 
         WOLFSSL_START(WC_FUNC_CLIENT_HELLO_SEND);
         WOLFSSL_ENTER("SendClientHello");
 
         suites = WOLFSSL_SUITES(ssl);
 
         if (suites == NULL) {
             WOLFSSL_MSG("Bad suites pointer in SendClientHello");
             return SUITES_ERROR;
         }
 
 #ifdef HAVE_SESSION_TICKET
         if (ssl->options.resuming && ssl->session->ticketLen > 0) {
             SessionTicket* ticket;
 
             ticket = TLSX_SessionTicket_Create(0, ssl->session->ticket,
                                              ssl->session->ticketLen, ssl->heap);
             if (ticket == NULL) return MEMORY_E;
 
             ret = TLSX_UseSessionTicket(&ssl->extensions, ticket, ssl->heap);
             if (ret != WOLFSSL_SUCCESS) {
                 TLSX_SessionTicket_Free(ticket, ssl->heap);
                 return ret;
             }
 
             idSz = 0;
         }
 #endif
         length = VERSION_SZ + RAN_LEN
                + idSz + ENUM_LEN
                + SUITE_LEN
                + COMP_LEN + ENUM_LEN;
 #ifndef NO_FORCE_SCR_SAME_SUITE
         if (IsSCR(ssl))
             length += SUITE_LEN;
         else
 #endif
             length += suites->suiteSz;
 
 #ifdef HAVE_TLS_EXTENSIONS
         /* auto populate extensions supported unless user defined */
         if ((ret = TLSX_PopulateExtensions(ssl, 0)) != 0)
             return ret;
         extSz = 0;
         ret = TLSX_GetRequestSize(ssl, client_hello, &extSz);
         if (ret != 0)
             return ret;
         length += extSz;
 #else
         if (IsAtLeastTLSv1_2(ssl) && suites->hashSigAlgoSz)
             extSz += HELLO_EXT_SZ + HELLO_EXT_SIGALGO_SZ
                    + suites->hashSigAlgoSz;
 #ifdef HAVE_EXTENDED_MASTER
         if (ssl->options.haveEMS)
             extSz += HELLO_EXT_SZ;
 #endif
         if (extSz != 0)
             length += extSz + HELLO_EXT_SZ_SZ;
 #endif
         sendSz = length + HANDSHAKE_HEADER_SZ + RECORD_HEADER_SZ;
 
         if (ssl->arrays == NULL) {
             return BAD_FUNC_ARG;
         }
 
 #ifdef WOLFSSL_DTLS
         if (ssl->options.dtls) {
             length += ENUM_LEN;   /* cookie */
             if (ssl->arrays->cookieSz != 0) length += ssl->arrays->cookieSz;
             sendSz  = length + DTLS_HANDSHAKE_HEADER_SZ + DTLS_RECORD_HEADER_SZ;
             idx    += DTLS_HANDSHAKE_EXTRA + DTLS_RECORD_EXTRA;
         }
 #endif
 
         if (IsEncryptionOn(ssl, 1))
             sendSz += MAX_MSG_EXTRA;
 
         /* Set this in case CheckAvailableSize returns a WANT_WRITE so that state
          * is not advanced yet */
         ssl->options.buildingMsg = 1;
 
         /* check for available size */
         if ((ret = CheckAvailableSize(ssl, sendSz)) != 0)
             return ret;
 
         /* get output buffer */
-        output = ssl->buffers.outputBuffer.buffer +
-                 ssl->buffers.outputBuffer.length;
+        output = GetOutputBuffer(ssl);
 
         AddHeaders(output, length, client_hello, ssl);
 
         /* client hello, first version */
         output[idx++] = ssl->version.major;
         output[idx++] = ssl->version.minor;
         ssl->chVersion = ssl->version;  /* store in case changed */
 
         /* then random */
         if (ssl->options.connectState == CONNECT_BEGIN) {
             ret = wc_RNG_GenerateBlock(ssl->rng, output + idx, RAN_LEN);
             if (ret != 0)
                 return ret;
 
             /* store random */
             XMEMCPY(ssl->arrays->clientRandom, output + idx, RAN_LEN);
         } else {
 #ifdef WOLFSSL_DTLS
             /* send same random on hello again */
             XMEMCPY(output + idx, ssl->arrays->clientRandom, RAN_LEN);
 #endif
         }
         idx += RAN_LEN;
 
         /* then session id */
         output[idx++] = (byte)idSz;
         if (idSz) {
             XMEMCPY(output + idx, ssl->session->sessionID,
                                                       ssl->session->sessionIDSz);
             idx += ssl->session->sessionIDSz;
         }
 
         /* then DTLS cookie */
 #ifdef WOLFSSL_DTLS
         if (ssl->options.dtls) {
             byte cookieSz = ssl->arrays->cookieSz;
 
             output[idx++] = cookieSz;
             if (cookieSz) {
                 XMEMCPY(&output[idx], ssl->arrays->cookie, cookieSz);
                 idx += cookieSz;
             }
         }
 #endif
 
 #ifndef NO_FORCE_SCR_SAME_SUITE
         if (IsSCR(ssl)) {
             c16toa(SUITE_LEN, output + idx);
             idx += OPAQUE16_LEN;
             output[idx++] = ssl->options.cipherSuite0;
             output[idx++] = ssl->options.cipherSuite;
         }
         else
 #endif
         {
             /* then cipher suites */
             c16toa(suites->suiteSz, output + idx);
             idx += OPAQUE16_LEN;
             XMEMCPY(output + idx, &suites->suites, suites->suiteSz);
             idx += suites->suiteSz;
         }
 
         /* last, compression */
         output[idx++] = COMP_LEN;
         if (ssl->options.usingCompression)
             output[idx++] = ZLIB_COMPRESSION;
         else
             output[idx++] = NO_COMPRESSION;
 
 #ifdef HAVE_TLS_EXTENSIONS
         extSz = 0;
         ret = TLSX_WriteRequest(ssl, output + idx, client_hello, &extSz);
         if (ret != 0)
             return ret;
         idx += extSz;
 
         (void)idx; /* suppress analyzer warning, keep idx current */
 #else
         if (extSz != 0) {
             c16toa(extSz, output + idx);
             idx += HELLO_EXT_SZ_SZ;
 
             if (IsAtLeastTLSv1_2(ssl)) {
                 if (suites->hashSigAlgoSz) {
                     word16 i;
                     /* extension type */
                     c16toa(HELLO_EXT_SIG_ALGO, output + idx);
                     idx += HELLO_EXT_TYPE_SZ;
                     /* extension data length */
                     c16toa(HELLO_EXT_SIGALGO_SZ + suites->hashSigAlgoSz,
                            output + idx);
                     idx += HELLO_EXT_SZ_SZ;
                     /* sig algos length */
                     c16toa(suites->hashSigAlgoSz, output + idx);
                     idx += HELLO_EXT_SIGALGO_SZ;
                     for (i=0; i < suites->hashSigAlgoSz; i++, idx++) {
                         output[idx] = suites->hashSigAlgo[i];
                     }
                 }
             }
 #ifdef HAVE_EXTENDED_MASTER
             if (ssl->options.haveEMS) {
                 c16toa(HELLO_EXT_EXTMS, output + idx);
                 idx += HELLO_EXT_TYPE_SZ;
                 c16toa(0, output + idx);
                 idx += HELLO_EXT_SZ_SZ;
             }
 #endif
         }
 #endif
 
         if (IsEncryptionOn(ssl, 1)) {
             byte* input;
             int   inputSz = idx; /* build msg adds rec hdr */
             int   recordHeaderSz = RECORD_HEADER_SZ;
 
             if (ssl->options.dtls)
                 recordHeaderSz += DTLS_RECORD_EXTRA;
             inputSz -= recordHeaderSz;
             input = (byte*)XMALLOC(inputSz, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
             if (input == NULL)
                 return MEMORY_E;
 
             XMEMCPY(input, output + recordHeaderSz, inputSz);
             #ifdef WOLFSSL_DTLS
             if (IsDtlsNotSctpMode(ssl) &&
                     (ret = DtlsMsgPoolSave(ssl, input, inputSz, client_hello)) != 0) {
                 XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
                 return ret;
             }
             #endif
             sendSz = BuildMessage(ssl, output, sendSz, input, inputSz,
                                   handshake, 1, 0, 0, CUR_ORDER);
             XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
 
             if (sendSz < 0)
                 return sendSz;
         } else {
             #ifdef WOLFSSL_DTLS
                 if (IsDtlsNotSctpMode(ssl)) {
                     if ((ret = DtlsMsgPoolSave(ssl, output, sendSz, client_hello)) != 0)
                         return ret;
                 }
                 if (ssl->options.dtls)
                     DtlsSEQIncrement(ssl, CUR_ORDER);
             #endif
             ret = HashOutput(ssl, output, sendSz, 0);
             if (ret != 0)
                 return ret;
         }
 
         ssl->options.clientState = CLIENT_HELLO_COMPLETE;
 #ifdef OPENSSL_EXTRA
         ssl->cbmode = SSL_CB_MODE_WRITE;
         if (ssl->CBIS != NULL)
             ssl->CBIS(ssl, SSL_CB_CONNECT_LOOP, WOLFSSL_SUCCESS);
 #endif
 
 #if defined(WOLFSSL_CALLBACKS) || defined(OPENSSL_EXTRA)
         if (ssl->hsInfoOn) AddPacketName(ssl, "ClientHello");
         if (ssl->toInfoOn) {
             ret = AddPacketInfo(ssl, "ClientHello", handshake, output, sendSz,
                           WRITE_PROTO, 0, ssl->heap);
             if (ret != 0)
                 return ret;
         }
 #endif
 
         ssl->options.buildingMsg = 0;
 
         ssl->buffers.outputBuffer.length += sendSz;
 
         ret = SendBuffered(ssl);
 
         WOLFSSL_LEAVE("SendClientHello", ret);
         WOLFSSL_END(WC_FUNC_CLIENT_HELLO_SEND);
 
         return ret;
     }
 
 
     /* handle processing of DTLS hello_verify_request (3) */
     int DoHelloVerifyRequest(WOLFSSL* ssl, const byte* input, word32* inOutIdx,
         word32 size)
     {
         ProtocolVersion pv;
         byte            cookieSz;
         word32          begin = *inOutIdx;
 
 #ifdef WOLFSSL_CALLBACKS
         if (ssl->hsInfoOn) AddPacketName(ssl, "HelloVerifyRequest");
         if (ssl->toInfoOn) AddLateName("HelloVerifyRequest", &ssl->timeoutInfo);
 #endif
 
 #ifdef WOLFSSL_DTLS
         if (ssl->options.dtls) {
             DtlsMsgPoolReset(ssl);
         }
 #endif
 
         if (OPAQUE16_LEN + OPAQUE8_LEN > size)
             return BUFFER_ERROR;
 
         XMEMCPY(&pv, input + *inOutIdx, OPAQUE16_LEN);
         *inOutIdx += OPAQUE16_LEN;
 
         if (pv.major != DTLS_MAJOR ||
                          (pv.minor != DTLS_MINOR && pv.minor != DTLSv1_2_MINOR))
             return VERSION_ERROR;
 
         cookieSz = input[(*inOutIdx)++];
 
         if (cookieSz) {
             if ((*inOutIdx - begin) + cookieSz > size)
                 return BUFFER_ERROR;
 
 #ifdef WOLFSSL_DTLS
             if (cookieSz <= MAX_COOKIE_LEN) {
                 XMEMCPY(ssl->arrays->cookie, input + *inOutIdx, cookieSz);
                 ssl->arrays->cookieSz = cookieSz;
             }
 #endif
             *inOutIdx += cookieSz;
         }
 
 #if defined(WOLFSSL_DTLS13) && defined(WOLFSSL_TLS13)
         if (IsAtLeastTLSv1_3(ssl->version) && ssl->options.dtls) {
             /* we sent a TLSv1.3 ClientHello but received a
              * HELLO_VERIFY_REQUEST */
             if (!ssl->options.downgrade ||
                     ssl->options.minDowngrade < pv.minor)
                 return VERSION_ERROR;
         }
 #endif /* defined(WOLFSSL_DTLS13) && defined(WOLFSSL_TLS13) */
 
         ssl->options.serverState = SERVER_HELLOVERIFYREQUEST_COMPLETE;
 
         return 0;
     }
 
 
     static WC_INLINE int DSH_CheckSessionId(WOLFSSL* ssl)
     {
         int ret = 0;
 
 #ifdef HAVE_SECRET_CALLBACK
         /* If a session secret callback exists, we are using that
          * key instead of the saved session key. Requires a ticket. */
         ret = ret || (ssl->sessionSecretCb != NULL
 #ifdef HAVE_SESSION_TICKET
                 && ssl->session->ticketLen > 0
 #endif
                 );
 #endif
 
 #ifdef HAVE_SESSION_TICKET
         /* server may send blank ticket which may not be expected to indicate
          * existing one ok but will also be sending a new one */
         ret = ret || (ssl->session->ticketLen > 0);
 #endif
 
         ret = ret ||
               (ssl->options.haveSessionId && XMEMCMP(ssl->arrays->sessionID,
                                           ssl->session->sessionID, ID_LEN) == 0);
 
         return ret;
     }
 
     /* Check the version in the received message is valid and set protocol
      * version to use.
      *
      * ssl  The SSL/TLS object.
      * pv   The protocol version from the packet.
      * returns 0 on success, otherwise failure.
      */
     int CheckVersion(WOLFSSL *ssl, ProtocolVersion pv)
     {
         byte lowerVersion, higherVersion;
     #ifdef WOLFSSL_TLS13_DRAFT
         if (pv.major == TLS_DRAFT_MAJOR) {
             pv.major = SSLv3_MAJOR;
             pv.minor = TLSv1_3_MINOR;
         }
     #endif
 
         #ifdef OPENSSL_EXTRA
         if (ssl->CBIS != NULL) {
             ssl->CBIS(ssl, SSL_CB_HANDSHAKE_START, WOLFSSL_SUCCESS);
         }
         #endif
 
         if (ssl->options.dtls) {
             if (pv.major != DTLS_MAJOR || pv.minor == DTLS_BOGUS_MINOR) {
                 WOLFSSL_ERROR_VERBOSE(VERSION_ERROR);
                 return VERSION_ERROR;
             }
             lowerVersion = pv.minor > ssl->version.minor;
             higherVersion = pv.minor < ssl->version.minor;
         }
         else {
             if (pv.major != SSLv3_MAJOR) {
                 WOLFSSL_ERROR_VERBOSE(VERSION_ERROR);
                 return VERSION_ERROR;
             }
             lowerVersion = pv.minor < ssl->version.minor;
             higherVersion = pv.minor > ssl->version.minor;
         }
 
         if (higherVersion) {
             WOLFSSL_MSG("Server using higher version, fatal error");
             WOLFSSL_ERROR_VERBOSE(VERSION_ERROR);
             return VERSION_ERROR;
         }
         if (lowerVersion) {
             WOLFSSL_MSG("server using lower version");
 
             /* Check for downgrade attack. */
             if (!ssl->options.downgrade) {
                 WOLFSSL_MSG("\tno downgrade allowed, fatal error");
                 WOLFSSL_ERROR_VERBOSE(VERSION_ERROR);
                 return VERSION_ERROR;
             }
             if ((!ssl->options.dtls && pv.minor < ssl->options.minDowngrade) ||
                 (ssl->options.dtls && pv.minor > ssl->options.minDowngrade)) {
                 WOLFSSL_MSG("\tversion below minimum allowed, fatal error");
                 WOLFSSL_ERROR_VERBOSE(VERSION_ERROR);
                 return VERSION_ERROR;
             }
 
             #ifdef HAVE_SECURE_RENEGOTIATION
                 if (ssl->secure_renegotiation &&
                                          ssl->secure_renegotiation->enabled &&
                                          ssl->options.handShakeDone) {
                     WOLFSSL_MSG("Server changed version during scr");
                     WOLFSSL_ERROR_VERBOSE(VERSION_ERROR);
                     return VERSION_ERROR;
                 }
             #endif
 
             /* Checks made - OK to downgrade. */
                 ssl->version.minor = pv.minor;
                 switch(pv.minor) {
                 case SSLv3_MINOR:
                     /* turn off tls */
                     WOLFSSL_MSG("\tdowngrading to SSLv3");
                     ssl->options.tls    = 0;
                     ssl->options.tls1_1 = 0;
                     break;
                 case TLSv1_MINOR:
                     /* turn off tls 1.1+ */
                     WOLFSSL_MSG("\tdowngrading to TLSv1");
                     ssl->options.tls1_1 = 0;
                     break;
                 case TLSv1_1_MINOR:
                     WOLFSSL_MSG("\tdowngrading to TLSv1.1");
                     break;
                 case DTLS_MINOR:
                     WOLFSSL_MSG("\tdowngrading to DTLSv1.1");
                     break;
                 case TLSv1_2_MINOR:
                     WOLFSSL_MSG("\tdowngrading to TLSv1.2");
                     break;
                 case DTLSv1_2_MINOR:
                     WOLFSSL_MSG("\tdowngrading to DTLSv1.2");
                     break;
                 default:
                     WOLFSSL_MSG("\tbad minor version");
                     WOLFSSL_ERROR_VERBOSE(VERSION_ERROR);
                     return VERSION_ERROR;
                 }
         }
 
         /* check if option is set to not allow the current version
          * set from either wolfSSL_set_options or wolfSSL_CTX_set_options */
         if (!ssl->options.dtls && ssl->options.downgrade &&
             ssl->options.mask > 0) {
 
             if (ssl->version.minor == TLSv1_2_MINOR &&
                (ssl->options.mask & WOLFSSL_OP_NO_TLSv1_2) ==
                 WOLFSSL_OP_NO_TLSv1_2) {
                 WOLFSSL_MSG("\tOption set to not allow TLSv1.2, Downgrading");
                 ssl->version.minor = TLSv1_1_MINOR;
             }
 
             if (ssl->version.minor == TLSv1_1_MINOR &&
                (ssl->options.mask & WOLFSSL_OP_NO_TLSv1_1) ==
                 WOLFSSL_OP_NO_TLSv1_1) {
                 WOLFSSL_MSG("\tOption set to not allow TLSv1.1, Downgrading");
                 ssl->options.tls1_1 = 0;
                 ssl->version.minor = TLSv1_MINOR;
             }
 
             if (ssl->version.minor == TLSv1_MINOR &&
                 (ssl->options.mask & WOLFSSL_OP_NO_TLSv1) ==
                 WOLFSSL_OP_NO_TLSv1) {
                 WOLFSSL_MSG("\tOption set to not allow TLSv1, Downgrading");
                 ssl->options.tls    = 0;
                 ssl->options.tls1_1 = 0;
                 ssl->version.minor = SSLv3_MINOR;
             }
 
             if (ssl->version.minor == SSLv3_MINOR &&
                 (ssl->options.mask & WOLFSSL_OP_NO_SSLv3) ==
                 WOLFSSL_OP_NO_SSLv3) {
                 WOLFSSL_MSG("\tError, option set to not allow SSLv3");
                 WOLFSSL_ERROR_VERBOSE(VERSION_ERROR);
                 return VERSION_ERROR;
             }
 
             if (ssl->version.minor < ssl->options.minDowngrade) {
                 WOLFSSL_MSG("\tversion below minimum allowed, fatal error");
                 WOLFSSL_ERROR_VERBOSE(VERSION_ERROR);
                 return VERSION_ERROR;
             }
         }
 
         return 0;
     }
 
     /* handle processing of server_hello (2) */
     int DoServerHello(WOLFSSL* ssl, const byte* input, word32* inOutIdx,
                       word32 helloSz)
     {
         byte            cs0;   /* cipher suite bytes 0, 1 */
         byte            cs1;
         ProtocolVersion pv;
         byte            compression;
         word32          i = *inOutIdx;
         word32          begin = i;
         int             ret;
 
         WOLFSSL_START(WC_FUNC_SERVER_HELLO_DO);
         WOLFSSL_ENTER("DoServerHello");
 
 #ifdef WOLFSSL_CALLBACKS
         if (ssl->hsInfoOn) AddPacketName(ssl, "ServerHello");
         if (ssl->toInfoOn) AddLateName("ServerHello", &ssl->timeoutInfo);
 #endif
 
         /* protocol version, random and session id length check */
         if (OPAQUE16_LEN + RAN_LEN + OPAQUE8_LEN > helloSz)
             return BUFFER_ERROR;
 
         /* protocol version */
         XMEMCPY(&pv, input + i, OPAQUE16_LEN);
         i += OPAQUE16_LEN;
 
         ret = CheckVersion(ssl, pv);
         if (ret != 0) {
             SendAlert(ssl, alert_fatal, wolfssl_alert_protocol_version);
             return ret;
         }
 
 #ifdef WOLFSSL_TLS13
         if (IsAtLeastTLSv1_3(pv)) {
             byte type = server_hello;
             return DoTls13ServerHello(ssl, input, inOutIdx, helloSz, &type);
         }
 #endif
 
         /* random */
         XMEMCPY(ssl->arrays->serverRandom, input + i, RAN_LEN);
         i += RAN_LEN;
 
         /* session id */
         ssl->arrays->sessionIDSz = input[i++];
 
         if (ssl->arrays->sessionIDSz > ID_LEN) {
             WOLFSSL_MSG("Invalid session ID size");
             ssl->arrays->sessionIDSz = 0;
             return BUFFER_ERROR;
         }
         else if (ssl->arrays->sessionIDSz) {
             if ((i - begin) + ssl->arrays->sessionIDSz > helloSz)
                 return BUFFER_ERROR;
 
             XMEMCPY(ssl->arrays->sessionID, input + i,
                                                       ssl->arrays->sessionIDSz);
             i += ssl->arrays->sessionIDSz;
             ssl->options.haveSessionId = 1;
         }
 
 
         /* suite and compression */
         if ((i - begin) + OPAQUE16_LEN + OPAQUE8_LEN > helloSz)
             return BUFFER_ERROR;
 
         cs0 = input[i++];
         cs1 = input[i++];
 
 #ifndef WOLFSSL_NO_STRICT_CIPHER_SUITE
 #if defined(HAVE_SECURE_RENEGOTIATION) && !defined(NO_FORCE_SCR_SAME_SUITE)
         if (IsSCR(ssl)) {
             if (ssl->options.cipherSuite0 != cs0 ||
                 ssl->options.cipherSuite  != cs1) {
                 WOLFSSL_MSG("Server changed cipher suite during scr");
                 WOLFSSL_ERROR_VERBOSE(MATCH_SUITE_ERROR);
                 return MATCH_SUITE_ERROR;
             }
         }
         else
 #endif
         {
             word32 idx, found = 0;
             const Suites* suites = WOLFSSL_SUITES(ssl);
             /* confirm server_hello cipher suite is one sent in client_hello */
             for (idx = 0; idx < suites->suiteSz; idx += 2) {
                 if (suites->suites[idx]   == cs0 &&
                     suites->suites[idx+1] == cs1) {
                     found = 1;
                     break;
                 }
             }
             if (!found) {
                 WOLFSSL_MSG("ServerHello did not use cipher suite from ClientHello");
                 WOLFSSL_ERROR_VERBOSE(MATCH_SUITE_ERROR);
                 return MATCH_SUITE_ERROR;
             }
         }
 #endif /* !WOLFSSL_NO_STRICT_CIPHER_SUITE */
 
         ssl->options.cipherSuite0 = cs0;
         ssl->options.cipherSuite  = cs1;
     #ifdef WOLFSSL_DEBUG_TLS
         WOLFSSL_MSG("Chosen cipher suite:");
         WOLFSSL_MSG(GetCipherNameInternal(ssl->options.cipherSuite0,
                                           ssl->options.cipherSuite));
     #endif
 
         compression = input[i++];
 
         if (compression != NO_COMPRESSION && !ssl->options.usingCompression) {
             WOLFSSL_MSG("Server forcing compression w/o support");
             WOLFSSL_ERROR_VERBOSE(COMPRESSION_ERROR);
             return COMPRESSION_ERROR;
         }
 
         if (compression != ZLIB_COMPRESSION && ssl->options.usingCompression) {
             WOLFSSL_MSG("Server refused compression, turning off");
             ssl->options.usingCompression = 0;  /* turn off if server refused */
         }
 
         *inOutIdx = i;
 
 #ifdef HAVE_TLS_EXTENSIONS
         if ( (i - begin) < helloSz) {
             if (TLSX_SupportExtensions(ssl)) {
                 word16 totalExtSz;
 
                 if ((i - begin) + OPAQUE16_LEN > helloSz)
                     return BUFFER_ERROR;
 
                 ato16(&input[i], &totalExtSz);
                 i += OPAQUE16_LEN;
 
                 if ((i - begin) + totalExtSz > helloSz)
                     return BUFFER_ERROR;
 
                 if ((ret = TLSX_Parse(ssl, (byte *) input + i, totalExtSz,
                                                            server_hello, NULL)))
                     return ret;
 
                 i += totalExtSz;
                 *inOutIdx = i;
             }
             else
                 *inOutIdx = begin + helloSz; /* skip extensions */
         }
         else
             ssl->options.haveEMS = 0; /* If no extensions, no EMS */
 #else
         {
             byte pendingEMS = 0;
 
             if ( (i - begin) < helloSz) {
                 int allowExt = 0;
 
                 if (ssl->version.major == SSLv3_MAJOR &&
                     ssl->version.minor >= TLSv1_MINOR) {
 
                     allowExt = 1;
                 }
 #ifdef WOLFSSL_DTLS
                 if (ssl->version.major == DTLS_MAJOR)
                     allowExt = 1;
 #endif
 
                 if (allowExt) {
                     word16 totalExtSz;
 
                     if ((i - begin) + OPAQUE16_LEN > helloSz)
                         return BUFFER_ERROR;
 
                     ato16(&input[i], &totalExtSz);
                     i += OPAQUE16_LEN;
 
                     if ((i - begin) + totalExtSz > helloSz)
                         return BUFFER_ERROR;
 
                     while (totalExtSz) {
                         word16 extId, extSz;
 
                         if (OPAQUE16_LEN + OPAQUE16_LEN > totalExtSz)
                             return BUFFER_ERROR;
 
                         ato16(&input[i], &extId);
                         i += OPAQUE16_LEN;
                         ato16(&input[i], &extSz);
                         i += OPAQUE16_LEN;
 
                         if (OPAQUE16_LEN + OPAQUE16_LEN + extSz > totalExtSz)
                             return BUFFER_ERROR;
 
                         if (extId == HELLO_EXT_EXTMS)
                             pendingEMS = 1;
                         else
                             i += extSz;
 
                         totalExtSz -= OPAQUE16_LEN + OPAQUE16_LEN + extSz;
                     }
 
                     *inOutIdx = i;
                 }
                 else
                     *inOutIdx = begin + helloSz; /* skip extensions */
             }
 
             if (!pendingEMS && ssl->options.haveEMS)
                 ssl->options.haveEMS = 0;
         }
 #endif
 
 #if defined(WOLFSSL_HARDEN_TLS) && !defined(WOLFSSL_HARDEN_TLS_NO_SCR_CHECK)
         if (ssl->secure_renegotiation == NULL ||
                 !ssl->secure_renegotiation->enabled) {
             /* If the server does not acknowledge the extension, the client
              * MUST generate a fatal handshake_failure alert prior to
              * terminating the connection.
              * https://www.rfc-editor.org/rfc/rfc9325#name-renegotiation-in-tls-12 */
             WOLFSSL_MSG("ServerHello did not contain SCR extension");
             return SECURE_RENEGOTIATION_E;
         }
 #endif
 
         ssl->options.serverState = SERVER_HELLO_COMPLETE;
 
         if (IsEncryptionOn(ssl, 0)) {
             *inOutIdx += ssl->keys.padSz;
         #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
             if (ssl->options.startedETMWrite &&
                                               ssl->specs.cipher_type == block) {
                 *inOutIdx += MacSize(ssl);
             }
         #endif
         }
 
 #ifdef HAVE_SECRET_CALLBACK
         if (ssl->sessionSecretCb != NULL
 #ifdef HAVE_SESSION_TICKET
                 && ssl->session->ticketLen > 0
 #endif
                 ) {
             int secretSz = SECRET_LEN;
             ret = ssl->sessionSecretCb(ssl, ssl->session->masterSecret,
                                               &secretSz, ssl->sessionSecretCtx);
             if (ret != 0 || secretSz != SECRET_LEN) {
                 WOLFSSL_ERROR_VERBOSE(SESSION_SECRET_CB_E);
                 return SESSION_SECRET_CB_E;
             }
         }
 #endif /* HAVE_SECRET_CALLBACK */
 
         ret = CompleteServerHello(ssl);
 
         WOLFSSL_LEAVE("DoServerHello", ret);
         WOLFSSL_END(WC_FUNC_SERVER_HELLO_DO);
 
         return ret;
     }
 
     int CompleteServerHello(WOLFSSL* ssl)
     {
         int ret;
 
         if (!ssl->options.resuming) {
             byte* down = ssl->arrays->serverRandom + RAN_LEN -
                                                          TLS13_DOWNGRADE_SZ - 1;
             byte  vers = ssl->arrays->serverRandom[RAN_LEN - 1];
     #ifdef WOLFSSL_TLS13
             if (TLSv1_3_Capable(ssl)) {
                 /* TLS v1.3 capable client not allowed to downgrade when
                  * connecting to TLS v1.3 capable server unless cipher suite
                  * demands it.
                  */
                 if (XMEMCMP(down, tls13Downgrade, TLS13_DOWNGRADE_SZ) == 0 &&
                                                      (vers == 0 || vers == 1)) {
                     SendAlert(ssl, alert_fatal, illegal_parameter);
                     WOLFSSL_ERROR_VERBOSE(VERSION_ERROR);
                     return VERSION_ERROR;
                 }
             }
             else
     #endif
             if (ssl->ctx->method->version.major == SSLv3_MAJOR &&
                 ssl->ctx->method->version.minor == TLSv1_2_MINOR &&
                 (wolfSSL_get_options(ssl) & WOLFSSL_OP_NO_TLSv1_2) == 0) {
                 /* TLS v1.2 capable client not allowed to downgrade when
                  * connecting to TLS v1.2 capable server.
                  */
                 if (XMEMCMP(down, tls13Downgrade, TLS13_DOWNGRADE_SZ) == 0 &&
                                                                     vers == 0) {
                     SendAlert(ssl, alert_fatal, illegal_parameter);
                     WOLFSSL_ERROR_VERBOSE(VERSION_ERROR);
                     return VERSION_ERROR;
                 }
             }
         }
         else {
             if (DSH_CheckSessionId(ssl)) {
                 if (SetCipherSpecs(ssl) == 0) {
 
                     XMEMCPY(ssl->arrays->masterSecret,
                             ssl->session->masterSecret, SECRET_LEN);
             #ifdef NO_OLD_TLS
                     ret = DeriveTlsKeys(ssl);
             #else
                     ret = -1; /* default value */
                 #ifndef NO_TLS
                     if (ssl->options.tls)
                         ret = DeriveTlsKeys(ssl);
                 #endif
                     if (!ssl->options.tls)
                         ret = DeriveKeys(ssl);
             #endif /* NO_OLD_TLS */
                     /* SERVER: peer auth based on session secret. */
                     ssl->options.peerAuthGood = (ret == 0);
                     ssl->options.serverState = SERVER_HELLODONE_COMPLETE;
 
                     return ret;
                 }
                 else {
                     WOLFSSL_MSG("Unsupported cipher suite, DoServerHello");
                     WOLFSSL_ERROR_VERBOSE(UNSUPPORTED_SUITE);
                     return UNSUPPORTED_SUITE;
                 }
             }
             else {
                 WOLFSSL_MSG("Server denied resumption attempt");
                 ssl->options.resuming = 0; /* server denied resumption try */
             }
         }
         return SetCipherSpecs(ssl);
     }
 
 #endif /* !WOLFSSL_NO_TLS12 */
 
 
     /* Make sure client setup is valid for this suite, true on success */
     int VerifyClientSuite(word16 havePSK, byte cipherSuite0, byte cipherSuite)
     {
         (void)havePSK;
 
         WOLFSSL_ENTER("VerifyClientSuite");
 
         if (CipherRequires(cipherSuite0, cipherSuite, REQUIRES_PSK)) {
             WOLFSSL_MSG("Requires PSK");
         #ifndef NO_PSK
             if (havePSK == 0)
         #endif
             {
                 WOLFSSL_MSG("Don't have PSK");
                 return 0;
             }
         }
 
         return 1;  /* success */
     }
 
 #ifndef WOLFSSL_NO_TLS12
 
 #ifndef NO_CERTS
     /* handle processing of certificate_request (13) */
     static int DoCertificateRequest(WOLFSSL* ssl, const byte* input, word32*
                                     inOutIdx, word32 size)
     {
         word16 len;
         word32 begin = *inOutIdx;
     #if defined(OPENSSL_EXTRA) || defined(OPENSSL_ALL) || \
         defined(WOLFSSL_NGINX) || defined(HAVE_LIGHTY)
         int ret;
     #endif
     #ifdef OPENSSL_EXTRA
         WOLFSSL_X509* x509 = NULL;
         WOLFSSL_EVP_PKEY* pkey = NULL;
     #endif
 
         WOLFSSL_START(WC_FUNC_CERTIFICATE_REQUEST_DO);
         WOLFSSL_ENTER("DoCertificateRequest");
 
         #ifdef WOLFSSL_CALLBACKS
             if (ssl->hsInfoOn)
                 AddPacketName(ssl, "CertificateRequest");
             if (ssl->toInfoOn)
                 AddLateName("CertificateRequest", &ssl->timeoutInfo);
         #endif
 
         if (OPAQUE8_LEN > size)
             return BUFFER_ERROR;
 
         len = input[(*inOutIdx)++];
 
         if ((*inOutIdx - begin) + len > size)
             return BUFFER_ERROR;
 
         /* types, read in here */
         *inOutIdx += len;
 
         /* signature and hash signature algorithm */
         if (IsAtLeastTLSv1_2(ssl)) {
             if ((*inOutIdx - begin) + OPAQUE16_LEN > size)
                 return BUFFER_ERROR;
 
             ato16(input + *inOutIdx, &len);
             *inOutIdx += OPAQUE16_LEN;
 
             if ((len > size) || ((*inOutIdx - begin) + len > size))
                 return BUFFER_ERROR;
 
             if (PickHashSigAlgo(ssl, input + *inOutIdx, len) != 0 &&
                                              ssl->buffers.certificate &&
                                              ssl->buffers.certificate->buffer) {
             #ifdef HAVE_PK_CALLBACKS
                 if (wolfSSL_CTX_IsPrivatePkSet(ssl->ctx)) {
                     WOLFSSL_MSG("Using PK for client private key");
                     WOLFSSL_ERROR_VERBOSE(INVALID_PARAMETER);
                     return INVALID_PARAMETER;
                 }
             #endif
                 if (ssl->buffers.key && ssl->buffers.key->buffer) {
                     WOLFSSL_ERROR_VERBOSE(INVALID_PARAMETER);
                     return INVALID_PARAMETER;
                 }
             }
             *inOutIdx += len;
     #ifdef WC_RSA_PSS
             ssl->pssAlgo = 0;
             if (ssl->options.sigAlgo == rsa_pss_sa_algo)
                 ssl->pssAlgo |= 1 << ssl->options.hashAlgo;
     #endif
         }
 
         /* authorities */
         if ((*inOutIdx - begin) + OPAQUE16_LEN > size)
             return BUFFER_ERROR;
 
         /* DN seq length */
         ato16(input + *inOutIdx, &len);
         *inOutIdx += OPAQUE16_LEN;
 
         if ((*inOutIdx - begin) + len > size)
             return BUFFER_ERROR;
 
     #if defined(OPENSSL_ALL) || defined(WOLFSSL_NGINX) || defined(HAVE_LIGHTY)
         if (ssl->ca_names != ssl->ctx->ca_names)
             wolfSSL_sk_X509_NAME_pop_free(ssl->ca_names, NULL);
         ssl->ca_names = wolfSSL_sk_X509_NAME_new(NULL);
         if (ssl->ca_names == NULL) {
             return MEMORY_ERROR;
         }
     #endif
 
         while (len) {
             word16 dnSz;
 
             if ((*inOutIdx - begin) + OPAQUE16_LEN > size)
                 return BUFFER_ERROR;
 
             ato16(input + *inOutIdx, &dnSz);
             *inOutIdx += OPAQUE16_LEN;
 
             if ((*inOutIdx - begin) + dnSz > size)
                 return BUFFER_ERROR;
 
         #if defined(OPENSSL_ALL) || defined(WOLFSSL_NGINX) || defined(HAVE_LIGHTY)
             {
                 WOLFSSL_X509_NAME* name = NULL;
                 /* Use a DecodedCert struct to get access to GetName to
                  * parse DN name */
 #ifdef WOLFSSL_SMALL_STACK
                 DecodedCert *cert = (DecodedCert *)XMALLOC(
                     sizeof(*cert), ssl->heap, DYNAMIC_TYPE_DCERT);
                 if (cert == NULL)
                     return MEMORY_ERROR;
 #else
                 DecodedCert cert[1];
 #endif
 
                 InitDecodedCert(cert, input + *inOutIdx, dnSz, ssl->heap);
 
                 ret = GetName(cert, SUBJECT, dnSz);
 
                 if (ret == 0) {
                     if ((name = wolfSSL_X509_NAME_new()) == NULL)
                         ret = MEMORY_ERROR;
                 }
 
                 if (ret == 0) {
                     CopyDecodedName(name, cert, SUBJECT);
                 }
 
                 if (ret == 0) {
                     if (wolfSSL_sk_X509_NAME_push(ssl->ca_names, name)
                         == WOLFSSL_FAILURE)
                     {
                         ret = MEMORY_ERROR;
                     }
                 }
 
                 FreeDecodedCert(cert);
 
 #ifdef WOLFSSL_SMALL_STACK
                 XFREE(cert, ssl->heap, DYNAMIC_TYPE_DCERT);
 #endif
                 if (ret != 0) {
                     if (name != NULL)
                         wolfSSL_X509_NAME_free(name);
                     return ret;
                 }
             }
         #endif
 
             *inOutIdx += dnSz;
             len -= OPAQUE16_LEN + dnSz;
         }
 
     #ifdef OPENSSL_EXTRA
         /* call client cert callback if no cert has been loaded */
         if ((ssl->ctx->CBClientCert != NULL) &&
             (!ssl->buffers.certificate || !ssl->buffers.certificate->buffer)) {
 
             ret = ssl->ctx->CBClientCert(ssl, &x509, &pkey);
             if (ret == 1) {
                 if ((wolfSSL_use_certificate(ssl, x509) != WOLFSSL_SUCCESS) ||
                     (wolfSSL_use_PrivateKey(ssl, pkey) != WOLFSSL_SUCCESS)) {
                     WOLFSSL_ERROR_VERBOSE(CLIENT_CERT_CB_ERROR);
                     return CLIENT_CERT_CB_ERROR;
                 }
                 wolfSSL_X509_free(x509);
                 wolfSSL_EVP_PKEY_free(pkey);
 
             }
             else if (ret < 0) {
                 return WOLFSSL_ERROR_WANT_X509_LOOKUP;
             }
         }
         if ((ret = CertSetupCbWrapper(ssl)) != 0)
             return ret;
     #endif
 
         /* don't send client cert or cert verify if user hasn't provided
            cert and private key */
         if (ssl->buffers.certificate && ssl->buffers.certificate->buffer) {
         #ifdef HAVE_PK_CALLBACKS
             if (wolfSSL_CTX_IsPrivatePkSet(ssl->ctx)) {
                 WOLFSSL_MSG("Using PK for client private key");
                 ssl->options.sendVerify = SEND_CERT;
             }
         #endif
             if (ssl->buffers.key && ssl->buffers.key->buffer) {
                 ssl->options.sendVerify = SEND_CERT;
             }
         }
     #ifdef OPENSSL_EXTRA
         else
     #else
         else if (IsTLS(ssl) || ssl->options.dtls)
     #endif
         {
             ssl->options.sendVerify = SEND_BLANK_CERT;
         }
 
         if (IsEncryptionOn(ssl, 0)) {
             *inOutIdx += ssl->keys.padSz;
         #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
             if (ssl->options.startedETMRead)
                 *inOutIdx += MacSize(ssl);
         #endif
         }
 
         WOLFSSL_LEAVE("DoCertificateRequest", 0);
         WOLFSSL_END(WC_FUNC_CERTIFICATE_REQUEST_DO);
 
         return 0;
     }
 #endif /* !NO_CERTS */
 
 
 #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || defined(HAVE_CURVE448)
 
     static int CheckCurveId(int tlsCurveId)
     {
         int ret = ECC_CURVE_ERROR;
 
         switch (tlsCurveId) {
     #if (defined(HAVE_ECC160) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 160
         #ifndef NO_ECC_SECP
             case WOLFSSL_ECC_SECP160R1: return ECC_SECP160R1_OID;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_SECPR2
             case WOLFSSL_ECC_SECP160R2: return ECC_SECP160R2_OID;
         #endif /* HAVE_ECC_SECPR2 */
         #ifdef HAVE_ECC_KOBLITZ
             case WOLFSSL_ECC_SECP160K1: return ECC_SECP160K1_OID;
         #endif /* HAVE_ECC_KOBLITZ */
     #endif
     #if (defined(HAVE_ECC192) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 192
         #ifndef NO_ECC_SECP
             case WOLFSSL_ECC_SECP192R1: return ECC_SECP192R1_OID;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_KOBLITZ
             case WOLFSSL_ECC_SECP192K1: return ECC_SECP192K1_OID;
         #endif /* HAVE_ECC_KOBLITZ */
     #endif
     #if (defined(HAVE_ECC224) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 224
         #ifndef NO_ECC_SECP
             case WOLFSSL_ECC_SECP224R1: return ECC_SECP224R1_OID;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_KOBLITZ
             case WOLFSSL_ECC_SECP224K1: return ECC_SECP224K1_OID;
         #endif /* HAVE_ECC_KOBLITZ */
     #endif
         #if defined(HAVE_CURVE25519) && ECC_MIN_KEY_SZ <= 256
             case WOLFSSL_ECC_X25519: return ECC_X25519_OID;
         #endif
     #if (!defined(NO_ECC256)  || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 256
         #ifndef NO_ECC_SECP
             case WOLFSSL_ECC_SECP256R1: return ECC_SECP256R1_OID;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_KOBLITZ
             case WOLFSSL_ECC_SECP256K1: return ECC_SECP256K1_OID;
         #endif /* HAVE_ECC_KOBLITZ */
         #ifdef HAVE_ECC_BRAINPOOL
             case WOLFSSL_ECC_BRAINPOOLP256R1: return ECC_BRAINPOOLP256R1_OID;
         #endif /* HAVE_ECC_BRAINPOOL */
     #endif
         #if defined(HAVE_CURVE448) && ECC_MIN_KEY_SZ <= 448
             case WOLFSSL_ECC_X448: return ECC_X448_OID;
         #endif
     #if (defined(HAVE_ECC384) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 384
         #ifndef NO_ECC_SECP
             case WOLFSSL_ECC_SECP384R1: return ECC_SECP384R1_OID;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_BRAINPOOL
             case WOLFSSL_ECC_BRAINPOOLP384R1: return ECC_BRAINPOOLP384R1_OID;
         #endif /* HAVE_ECC_BRAINPOOL */
     #endif
     #if (defined(HAVE_ECC512) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 512
         #ifdef HAVE_ECC_BRAINPOOL
             case WOLFSSL_ECC_BRAINPOOLP512R1: return ECC_BRAINPOOLP512R1_OID;
         #endif /* HAVE_ECC_BRAINPOOL */
     #endif
     #if (defined(HAVE_ECC521) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 521
         #ifndef NO_ECC_SECP
             case WOLFSSL_ECC_SECP521R1: return ECC_SECP521R1_OID;
         #endif /* !NO_ECC_SECP */
     #endif
             default: break;
         }
 
         return ret;
     }
 
 #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
 
 /* Persistable DoServerKeyExchange arguments */
@@ -28840,1197 +28834,1196 @@ static void FreeSckeArgs(WOLFSSL* ssl, void* pArgs)
 /* handle generation client_key_exchange (16) */
 int SendClientKeyExchange(WOLFSSL* ssl)
 {
     int ret = 0;
 #ifdef WOLFSSL_ASYNC_IO
     SckeArgs* args = NULL;
     WOLFSSL_ASSERT_SIZEOF_GE(ssl->async->args, *args);
 #else
     SckeArgs  args[1];
 #endif
 
     WOLFSSL_START(WC_FUNC_CLIENT_KEY_EXCHANGE_SEND);
     WOLFSSL_ENTER("SendClientKeyExchange");
 
 #ifdef OPENSSL_EXTRA
     ssl->options.clientState = CLIENT_KEYEXCHANGE_COMPLETE;
     ssl->cbmode = SSL_CB_MODE_WRITE;
     if (ssl->CBIS != NULL)
         ssl->CBIS(ssl, SSL_CB_CONNECT_LOOP, WOLFSSL_SUCCESS);
 #endif
 
 #ifdef WOLFSSL_ASYNC_IO
     if (ssl->async == NULL) {
         ssl->async = (struct WOLFSSL_ASYNC*)
                 XMALLOC(sizeof(struct WOLFSSL_ASYNC), ssl->heap,
                         DYNAMIC_TYPE_ASYNC);
         if (ssl->async == NULL)
             ERROR_OUT(MEMORY_E, exit_scke);
         XMEMSET(ssl->async, 0, sizeof(struct WOLFSSL_ASYNC));
     }
     args = (SckeArgs*)ssl->async->args;
 
 #ifdef WOLFSSL_ASYNC_CRYPT
     ret = wolfSSL_AsyncPop(ssl, &ssl->options.asyncState);
     if (ret != WC_NOT_PENDING_E) {
         /* Check for error */
         if (ret < 0)
             goto exit_scke;
     }
     else
 #endif
     if (ssl->options.buildingMsg) {
         /* Continue building the message */
     }
     else
 #endif
     {
         /* Reset state */
         ret = 0;
         ssl->options.asyncState = TLS_ASYNC_BEGIN;
         XMEMSET(args, 0, sizeof(SckeArgs));
         /* Set this in case CheckAvailableSize returns a WANT_WRITE so that state
          * is not advanced yet */
         ssl->options.buildingMsg = 1;
     #ifdef WOLFSSL_ASYNC_IO
         ssl->async->freeArgs = FreeSckeArgs;
     #endif
     }
 
     switch(ssl->options.asyncState)
     {
         case TLS_ASYNC_BEGIN:
         {
             switch (ssl->specs.kea) {
             #ifndef NO_RSA
                 case rsa_kea:
                     if (ssl->peerRsaKey == NULL ||
                         ssl->peerRsaKeyPresent == 0) {
                         ERROR_OUT(NO_PEER_KEY, exit_scke);
                     }
                     break;
             #endif
             #ifndef NO_DH
                 case diffie_hellman_kea:
                     if (ssl->buffers.serverDH_P.buffer == NULL ||
                         ssl->buffers.serverDH_G.buffer == NULL ||
                         ssl->buffers.serverDH_Pub.buffer == NULL) {
                         ERROR_OUT(NO_PEER_KEY, exit_scke);
                     }
                     break;
             #endif /* NO_DH */
             #ifndef NO_PSK
                 case psk_kea:
                     /* sanity check that PSK client callback has been set */
                     if (ssl->options.client_psk_cb == NULL) {
                         WOLFSSL_MSG("No client PSK callback set");
                         ERROR_OUT(PSK_KEY_ERROR, exit_scke);
                     }
                     break;
             #endif /* NO_PSK */
             #if !defined(NO_DH) && !defined(NO_PSK)
                 case dhe_psk_kea:
                     if (ssl->buffers.serverDH_P.buffer == NULL ||
                         ssl->buffers.serverDH_G.buffer == NULL ||
                         ssl->buffers.serverDH_Pub.buffer == NULL) {
                         ERROR_OUT(NO_PEER_KEY, exit_scke);
                     }
 
                     /* sanity check that PSK client callback has been set */
                     if (ssl->options.client_psk_cb == NULL) {
                         WOLFSSL_MSG("No client PSK callback set");
                         ERROR_OUT(PSK_KEY_ERROR, exit_scke);
                     }
                     break;
             #endif /* !NO_DH && !NO_PSK */
             #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                 case ecdhe_psk_kea:
                     /* sanity check that PSK client callback has been set */
                     if (ssl->options.client_psk_cb == NULL) {
                         WOLFSSL_MSG("No client PSK callback set");
                         ERROR_OUT(PSK_KEY_ERROR, exit_scke);
                     }
 
                 #ifdef HAVE_CURVE25519
                     if (ssl->peerX25519KeyPresent) {
                         /* Check client ECC public key */
                         if (!ssl->peerX25519Key || !ssl->peerX25519Key->dp) {
                             ERROR_OUT(NO_PEER_KEY, exit_scke);
                         }
 
                     #ifdef HAVE_PK_CALLBACKS
                         /* if callback then use it for shared secret */
                         if (ssl->ctx->X25519SharedSecretCb != NULL) {
                             break;
                         }
                     #endif
 
                         /* create private key */
                         ssl->hsType = DYNAMIC_TYPE_CURVE25519;
                         ret = AllocKey(ssl, ssl->hsType, &ssl->hsKey);
                         if (ret != 0) {
                             goto exit_scke;
                         }
 
                         ret = X25519MakeKey(ssl, (curve25519_key*)ssl->hsKey,
                                             ssl->peerX25519Key);
                         break;
                     }
                 #endif
                 #ifdef HAVE_CURVE448
                     if (ssl->peerX448KeyPresent) {
                         /* Check client ECC public key */
                         if (!ssl->peerX448Key) {
                             ERROR_OUT(NO_PEER_KEY, exit_scke);
                         }
 
                     #ifdef HAVE_PK_CALLBACKS
                         /* if callback then use it for shared secret */
                         if (ssl->ctx->X448SharedSecretCb != NULL) {
                             break;
                         }
                     #endif
 
                         /* create private key */
                         ssl->hsType = DYNAMIC_TYPE_CURVE448;
                         ret = AllocKey(ssl, ssl->hsType, &ssl->hsKey);
                         if (ret != 0) {
                             goto exit_scke;
                         }
 
                         ret = X448MakeKey(ssl, (curve448_key*)ssl->hsKey,
                                           ssl->peerX448Key);
                         break;
                     }
                 #endif
                     /* Check client ECC public key */
                     if (!ssl->peerEccKey || !ssl->peerEccKeyPresent ||
                                             !ssl->peerEccKey->dp) {
                         ERROR_OUT(NO_PEER_KEY, exit_scke);
                     }
 
                 #ifdef HAVE_PK_CALLBACKS
                     /* if callback then use it for shared secret */
                     if (ssl->ctx->EccSharedSecretCb != NULL) {
                         break;
                     }
                 #endif
 
                     /* create ephemeral private key */
                     ssl->hsType = DYNAMIC_TYPE_ECC;
                     ret = AllocKey(ssl, ssl->hsType, &ssl->hsKey);
                     if (ret != 0) {
                         goto exit_scke;
                     }
 
                     ret = EccMakeKey(ssl, (ecc_key*)ssl->hsKey, ssl->peerEccKey);
 
                     break;
             #endif /* (HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448) && !NO_PSK */
             #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                 case ecc_diffie_hellman_kea:
                 {
                 #ifdef HAVE_ECC
                     ecc_key* peerKey;
                 #endif
 
             #ifdef HAVE_PK_CALLBACKS
                     /* if callback then use it for shared secret */
                 #ifdef HAVE_CURVE25519
                     if (ssl->ecdhCurveOID == ECC_X25519_OID) {
                         if (ssl->ctx->X25519SharedSecretCb != NULL)
                             break;
                     }
                     else
                 #endif
                 #ifdef HAVE_CURVE448
                     if (ssl->ecdhCurveOID == ECC_X448_OID) {
                         if (ssl->ctx->X448SharedSecretCb != NULL)
                             break;
                     }
                     else
                 #endif
                 #ifdef HAVE_ECC
                     if (ssl->ctx->EccSharedSecretCb != NULL) {
                         break;
                     }
                     else
                 #endif
                     {
                     }
             #endif /* HAVE_PK_CALLBACKS */
 
                 #ifdef HAVE_CURVE25519
                     if (ssl->peerX25519KeyPresent) {
                         if (!ssl->peerX25519Key || !ssl->peerX25519Key->dp) {
                             ERROR_OUT(NO_PEER_KEY, exit_scke);
                         }
 
                         /* create private key */
                         ssl->hsType = DYNAMIC_TYPE_CURVE25519;
                         ret = AllocKey(ssl, ssl->hsType, &ssl->hsKey);
                         if (ret != 0) {
                             goto exit_scke;
                         }
 
                         ret = X25519MakeKey(ssl, (curve25519_key*)ssl->hsKey,
                                             ssl->peerX25519Key);
                         break;
                     }
                 #endif
                 #ifdef HAVE_CURVE448
                     if (ssl->peerX448KeyPresent) {
                         if (!ssl->peerX448Key) {
                             ERROR_OUT(NO_PEER_KEY, exit_scke);
                         }
 
                         /* create private key */
                         ssl->hsType = DYNAMIC_TYPE_CURVE448;
                         ret = AllocKey(ssl, ssl->hsType, &ssl->hsKey);
                         if (ret != 0) {
                             goto exit_scke;
                         }
 
                         ret = X448MakeKey(ssl, (curve448_key*)ssl->hsKey,
                                           ssl->peerX448Key);
                         break;
                     }
                 #endif
                 #ifdef HAVE_ECC
                     if (ssl->specs.static_ecdh) {
                         /* Note: EccDsa is really fixed Ecc key here */
                         if (!ssl->peerEccDsaKey || !ssl->peerEccDsaKeyPresent) {
                             ERROR_OUT(NO_PEER_KEY, exit_scke);
                         }
                         peerKey = ssl->peerEccDsaKey;
                     }
                     else {
                         if (!ssl->peerEccKey || !ssl->peerEccKeyPresent) {
                             ERROR_OUT(NO_PEER_KEY, exit_scke);
                         }
                         peerKey = ssl->peerEccKey;
                     }
                     if (peerKey == NULL) {
                         ERROR_OUT(NO_PEER_KEY, exit_scke);
                     }
 
                     /* create ephemeral private key */
                     ssl->hsType = DYNAMIC_TYPE_ECC;
                     ret = AllocKey(ssl, ssl->hsType, &ssl->hsKey);
                     if (ret != 0) {
                         goto exit_scke;
                     }
 
                     ret = EccMakeKey(ssl, (ecc_key*)ssl->hsKey, peerKey);
                 #endif /* HAVE_ECC */
 
                     break;
                 }
             #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
 
                 default:
                     ret = BAD_KEA_TYPE_E;
             } /* switch(ssl->specs.kea) */
 
             /* Check for error */
             if (ret != 0) {
                 goto exit_scke;
             }
 
             /* Advance state and proceed */
             ssl->options.asyncState = TLS_ASYNC_BUILD;
         } /* case TLS_ASYNC_BEGIN */
         FALL_THROUGH;
 
         case TLS_ASYNC_BUILD:
         {
             args->encSz = MAX_ENCRYPT_SZ;
             args->encSecret = (byte*)XMALLOC(MAX_ENCRYPT_SZ, ssl->heap,
                                                     DYNAMIC_TYPE_SECRET);
             if (args->encSecret == NULL) {
                 ERROR_OUT(MEMORY_E, exit_scke);
             }
             if (ssl->arrays->preMasterSecret == NULL) {
                 ssl->arrays->preMasterSz = ENCRYPT_LEN;
                 ssl->arrays->preMasterSecret = (byte*)XMALLOC(ENCRYPT_LEN,
                                                 ssl->heap, DYNAMIC_TYPE_SECRET);
                 if (ssl->arrays->preMasterSecret == NULL) {
                     ERROR_OUT(MEMORY_E, exit_scke);
                 }
                 XMEMSET(ssl->arrays->preMasterSecret, 0, ENCRYPT_LEN);
             }
 
             switch(ssl->specs.kea)
             {
             #ifndef NO_RSA
                 case rsa_kea:
                 {
                     #ifdef HAVE_PK_CALLBACKS
                     if (ssl->ctx->GenPreMasterCb) {
                         void* ctx = wolfSSL_GetGenPreMasterCtx(ssl);
                         ret = ssl->ctx->GenPreMasterCb(ssl,
                             ssl->arrays->preMasterSecret, ENCRYPT_LEN, ctx);
                         if (ret != 0 && ret != PROTOCOLCB_UNAVAILABLE) {
                             goto exit_scke;
                         }
                     }
                     if (!ssl->ctx->GenPreMasterCb || ret == PROTOCOLCB_UNAVAILABLE)
                     #endif
                     {
                         /* build PreMasterSecret with RNG data */
                         ret = wc_RNG_GenerateBlock(ssl->rng,
                             &ssl->arrays->preMasterSecret[VERSION_SZ],
                             SECRET_LEN - VERSION_SZ);
                         if (ret != 0) {
                             goto exit_scke;
                         }
 
                         ssl->arrays->preMasterSecret[0] = ssl->chVersion.major;
                         ssl->arrays->preMasterSecret[1] = ssl->chVersion.minor;
 
                         ssl->arrays->preMasterSz = SECRET_LEN;
                     }
                     break;
                 }
             #endif /* !NO_RSA */
             #ifndef NO_DH
                 case diffie_hellman_kea:
                 {
                     ssl->buffers.sig.length = ENCRYPT_LEN;
                     ssl->buffers.sig.buffer = (byte*)XMALLOC(ENCRYPT_LEN,
                                             ssl->heap, DYNAMIC_TYPE_SIGNATURE);
                     if (ssl->buffers.sig.buffer == NULL) {
                         ERROR_OUT(MEMORY_E, exit_scke);
                     }
 
                     ret = AllocKey(ssl, DYNAMIC_TYPE_DH,
                                             (void**)&ssl->buffers.serverDH_Key);
                     if (ret != 0) {
                         goto exit_scke;
                     }
 
 #if defined(HAVE_FFDHE) && !defined(HAVE_PUBLIC_FFDHE)
                     if (ssl->namedGroup) {
                         ret = wc_DhSetNamedKey(ssl->buffers.serverDH_Key,
                                 ssl->namedGroup);
                         if (ret != 0) {
                             goto exit_scke;
                         }
                         ssl->buffers.sig.length =
                             wc_DhGetNamedKeyMinSize(ssl->namedGroup);
                     }
                     else
 #endif
                     #if !defined(HAVE_FIPS) && !defined(HAVE_SELFTEST) && \
                         !defined(WOLFSSL_OLD_PRIME_CHECK)
                     if (ssl->options.dhDoKeyTest &&
                         !ssl->options.dhKeyTested)
                     {
                         ret = wc_DhSetCheckKey(ssl->buffers.serverDH_Key,
                             ssl->buffers.serverDH_P.buffer,
                             ssl->buffers.serverDH_P.length,
                             ssl->buffers.serverDH_G.buffer,
                             ssl->buffers.serverDH_G.length,
                             NULL, 0, 0, ssl->rng);
                         if (ret != 0) {
                             goto exit_scke;
                         }
                         ssl->options.dhKeyTested = 1;
                     }
                     else
                     #endif
                     {
                         ret = wc_DhSetKey(ssl->buffers.serverDH_Key,
                             ssl->buffers.serverDH_P.buffer,
                             ssl->buffers.serverDH_P.length,
                             ssl->buffers.serverDH_G.buffer,
                             ssl->buffers.serverDH_G.length);
                         if (ret != 0) {
                             goto exit_scke;
                         }
                     }
 
                     /* for DH, encSecret is Yc, agree is pre-master */
                     ret = DhGenKeyPair(ssl, ssl->buffers.serverDH_Key,
                         ssl->buffers.sig.buffer, (word32*)&ssl->buffers.sig.length,
                         args->encSecret, &args->encSz);
 
                     /* set the max agree result size */
                     ssl->arrays->preMasterSz = ENCRYPT_LEN;
                     break;
                 }
             #endif /* !NO_DH */
             #ifndef NO_PSK
                 case psk_kea:
                 {
                     byte* pms = ssl->arrays->preMasterSecret;
                     int cbret = (int)ssl->options.client_psk_cb(ssl,
                         ssl->arrays->server_hint, ssl->arrays->client_identity,
                         MAX_PSK_ID_LEN, ssl->arrays->psk_key, MAX_PSK_KEY_LEN);
 
                     if (cbret == 0 || cbret > MAX_PSK_KEY_LEN) {
                         if (cbret != USE_HW_PSK) {
                             ERROR_OUT(PSK_KEY_ERROR, exit_scke);
                         }
                     }
 
                     if (cbret == USE_HW_PSK) {
                         /* USE_HW_PSK indicates that the hardware has the PSK
                          * and generates the premaster secret. */
                         ssl->arrays->psk_keySz = 0;
                     }
                     else {
                         ssl->arrays->psk_keySz = (word32)cbret;
                     }
 
                     /* Ensure the buffer is null-terminated. */
                     ssl->arrays->client_identity[MAX_PSK_ID_LEN] = '\0';
                     args->encSz = (word32)XSTRLEN(ssl->arrays->client_identity);
                     if (args->encSz > MAX_PSK_ID_LEN) {
                         ERROR_OUT(CLIENT_ID_ERROR, exit_scke);
                     }
                     XMEMCPY(args->encSecret, ssl->arrays->client_identity,
                             args->encSz);
                     ssl->options.peerAuthGood = 1;
                     if (cbret != USE_HW_PSK) {
                         /* CLIENT: Pre-shared Key for peer authentication. */
 
                         /* make psk pre master secret */
                         /* length of key + length 0s + length of key + key */
                         c16toa((word16)ssl->arrays->psk_keySz, pms);
                         pms += OPAQUE16_LEN;
                         XMEMSET(pms, 0, ssl->arrays->psk_keySz);
                         pms += ssl->arrays->psk_keySz;
                         c16toa((word16)ssl->arrays->psk_keySz, pms);
                         pms += OPAQUE16_LEN;
                         XMEMCPY(pms, ssl->arrays->psk_key,
                                 ssl->arrays->psk_keySz);
                         ssl->arrays->preMasterSz = (ssl->arrays->psk_keySz * 2)
                                                    + (2 * OPAQUE16_LEN);
                         ForceZero(ssl->arrays->psk_key, ssl->arrays->psk_keySz);
                         ssl->arrays->psk_keySz = 0; /* No further need */
                     }
                     break;
                 }
             #endif /* !NO_PSK */
             #if !defined(NO_DH) && !defined(NO_PSK)
                 case dhe_psk_kea:
                 {
                     word32 esSz = 0;
                     args->output = args->encSecret;
 
                     ssl->arrays->psk_keySz = ssl->options.client_psk_cb(ssl,
                          ssl->arrays->server_hint, ssl->arrays->client_identity,
                          MAX_PSK_ID_LEN, ssl->arrays->psk_key, MAX_PSK_KEY_LEN);
                     if (ssl->arrays->psk_keySz == 0 ||
                                      ssl->arrays->psk_keySz > MAX_PSK_KEY_LEN) {
                         ERROR_OUT(PSK_KEY_ERROR, exit_scke);
                     }
                     ssl->arrays->client_identity[MAX_PSK_ID_LEN] = '\0'; /* null term */
                     esSz = (word32)XSTRLEN(ssl->arrays->client_identity);
 
                     if (esSz > MAX_PSK_ID_LEN) {
                         ERROR_OUT(CLIENT_ID_ERROR, exit_scke);
                     }
                     /* CLIENT: Pre-shared Key for peer authentication. */
                     ssl->options.peerAuthGood = 1;
 
                     ssl->buffers.sig.length = ENCRYPT_LEN;
                     ssl->buffers.sig.buffer = (byte*)XMALLOC(ENCRYPT_LEN,
                                             ssl->heap, DYNAMIC_TYPE_SIGNATURE);
                     if (ssl->buffers.sig.buffer == NULL) {
                         ERROR_OUT(MEMORY_E, exit_scke);
                     }
 
                     c16toa((word16)esSz, args->output);
                     args->output += OPAQUE16_LEN;
                     XMEMCPY(args->output, ssl->arrays->client_identity, esSz);
                     args->output += esSz;
                     args->length = args->encSz - esSz - OPAQUE16_LEN;
                     args->encSz = esSz + OPAQUE16_LEN;
 
                     ret = AllocKey(ssl, DYNAMIC_TYPE_DH,
                                             (void**)&ssl->buffers.serverDH_Key);
                     if (ret != 0) {
                         goto exit_scke;
                     }
 
                     #if !defined(HAVE_FIPS) && !defined(HAVE_SELFTEST) && \
                         !defined(WOLFSSL_OLD_PRIME_CHECK)
                     if (ssl->options.dhDoKeyTest &&
                         !ssl->options.dhKeyTested)
                     {
                         ret = wc_DhSetCheckKey(ssl->buffers.serverDH_Key,
                             ssl->buffers.serverDH_P.buffer,
                             ssl->buffers.serverDH_P.length,
                             ssl->buffers.serverDH_G.buffer,
                             ssl->buffers.serverDH_G.length,
                             NULL, 0, 0, ssl->rng);
                         if (ret != 0) {
                             goto exit_scke;
                         }
                         ssl->options.dhKeyTested = 1;
                     }
                     else
                     #endif
                     {
                         ret = wc_DhSetKey(ssl->buffers.serverDH_Key,
                             ssl->buffers.serverDH_P.buffer,
                             ssl->buffers.serverDH_P.length,
                             ssl->buffers.serverDH_G.buffer,
                             ssl->buffers.serverDH_G.length);
                         if (ret != 0) {
                             goto exit_scke;
                         }
                     }
 
                     /* for DH, encSecret is Yc, agree is pre-master */
                     ret = DhGenKeyPair(ssl, ssl->buffers.serverDH_Key,
                             ssl->buffers.sig.buffer,
                             (word32*)&ssl->buffers.sig.length,
                             args->output + OPAQUE16_LEN, &args->length);
                     break;
                 }
             #endif /* !NO_DH && !NO_PSK */
             #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                 case ecdhe_psk_kea:
                 {
                     word32 esSz = 0;
                     args->output = args->encSecret;
 
                     /* Send PSK client identity */
                     ssl->arrays->psk_keySz = ssl->options.client_psk_cb(ssl,
                          ssl->arrays->server_hint, ssl->arrays->client_identity,
                          MAX_PSK_ID_LEN, ssl->arrays->psk_key, MAX_PSK_KEY_LEN);
                     if (ssl->arrays->psk_keySz == 0 ||
                                      ssl->arrays->psk_keySz > MAX_PSK_KEY_LEN) {
                         ERROR_OUT(PSK_KEY_ERROR, exit_scke);
                     }
                     ssl->arrays->client_identity[MAX_PSK_ID_LEN] = '\0'; /* null term */
                     esSz = (word32)XSTRLEN(ssl->arrays->client_identity);
                     if (esSz > MAX_PSK_ID_LEN) {
                         ERROR_OUT(CLIENT_ID_ERROR, exit_scke);
                     }
                     /* CLIENT: Pre-shared Key for peer authentication. */
                     ssl->options.peerAuthGood = 1;
 
                     /* place size and identity in output buffer sz:identity */
                     c16toa((word16)esSz, args->output);
                     args->output += OPAQUE16_LEN;
                     XMEMCPY(args->output, ssl->arrays->client_identity, esSz);
                     args->output += esSz;
                     args->encSz = esSz + OPAQUE16_LEN;
 
                     /* length is used for public key size */
                     args->length = MAX_ENCRYPT_SZ;
 
                     /* Create shared ECC key leaving room at the beginning
                        of buffer for size of shared key. */
                     ssl->arrays->preMasterSz = ENCRYPT_LEN - OPAQUE16_LEN;
 
                 #ifdef HAVE_CURVE25519
                     if (ssl->ecdhCurveOID == ECC_X25519_OID) {
                     #ifdef HAVE_PK_CALLBACKS
                         /* if callback then use it for shared secret */
                         if (ssl->ctx->X25519SharedSecretCb != NULL) {
                             break;
                         }
                     #endif
 
                         ret = wc_curve25519_export_public_ex(
                                 (curve25519_key*)ssl->hsKey,
                                 args->output + OPAQUE8_LEN, &args->length,
                                 EC25519_LITTLE_ENDIAN);
                         if (ret != 0) {
                             ERROR_OUT(ECC_EXPORT_ERROR, exit_scke);
                         }
 
                         break;
                     }
                 #endif
                 #ifdef HAVE_CURVE448
                     if (ssl->ecdhCurveOID == ECC_X448_OID) {
                     #ifdef HAVE_PK_CALLBACKS
                         /* if callback then use it for shared secret */
                         if (ssl->ctx->X448SharedSecretCb != NULL) {
                             break;
                         }
                     #endif
 
                         ret = wc_curve448_export_public_ex(
                                 (curve448_key*)ssl->hsKey,
                                 args->output + OPAQUE8_LEN, &args->length,
                                 EC448_LITTLE_ENDIAN);
                         if (ret != 0) {
                             ERROR_OUT(ECC_EXPORT_ERROR, exit_scke);
                         }
 
                         break;
                     }
                 #endif
                 #ifdef HAVE_PK_CALLBACKS
                     /* if callback then use it for shared secret */
                     if (ssl->ctx->EccSharedSecretCb != NULL) {
                         break;
                     }
                 #endif
 
                     /* Place ECC key in output buffer, leaving room for size */
                     PRIVATE_KEY_UNLOCK();
                     ret = wc_ecc_export_x963((ecc_key*)ssl->hsKey,
                                     args->output + OPAQUE8_LEN, &args->length);
                     PRIVATE_KEY_LOCK();
                     if (ret != 0) {
                         ERROR_OUT(ECC_EXPORT_ERROR, exit_scke);
                     }
 
                     break;
                 }
             #endif /* (HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448) && !NO_PSK */
             #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                 case ecc_diffie_hellman_kea:
                 {
                     ssl->arrays->preMasterSz = ENCRYPT_LEN;
 
                 #ifdef HAVE_CURVE25519
                     if (ssl->hsType == DYNAMIC_TYPE_CURVE25519) {
                     #ifdef HAVE_PK_CALLBACKS
                         /* if callback then use it for shared secret */
                         if (ssl->ctx->X25519SharedSecretCb != NULL) {
                             break;
                         }
                     #endif
 
                         ret = wc_curve25519_export_public_ex(
                                 (curve25519_key*)ssl->hsKey,
                                 args->encSecret + OPAQUE8_LEN, &args->encSz,
                                 EC25519_LITTLE_ENDIAN);
                         if (ret != 0) {
                             ERROR_OUT(ECC_EXPORT_ERROR, exit_scke);
                         }
 
                         break;
                     }
                 #endif
                 #ifdef HAVE_CURVE448
                     if (ssl->hsType == DYNAMIC_TYPE_CURVE448) {
                     #ifdef HAVE_PK_CALLBACKS
                         /* if callback then use it for shared secret */
                         if (ssl->ctx->X448SharedSecretCb != NULL) {
                             break;
                         }
                     #endif
 
                         ret = wc_curve448_export_public_ex(
                                 (curve448_key*)ssl->hsKey,
                                 args->encSecret + OPAQUE8_LEN, &args->encSz,
                                 EC448_LITTLE_ENDIAN);
                         if (ret != 0) {
                             ERROR_OUT(ECC_EXPORT_ERROR, exit_scke);
                         }
 
                         break;
                     }
                 #endif
                 #if defined(HAVE_ECC) && defined(HAVE_ECC_KEY_EXPORT)
                 #ifdef HAVE_PK_CALLBACKS
                     /* if callback then use it for shared secret */
                     if (ssl->ctx->EccSharedSecretCb != NULL) {
                         break;
                     }
                 #endif
 
                     /* Place ECC key in buffer, leaving room for size */
                     PRIVATE_KEY_UNLOCK();
                     ret = wc_ecc_export_x963((ecc_key*)ssl->hsKey,
                                 args->encSecret + OPAQUE8_LEN, &args->encSz);
                     PRIVATE_KEY_LOCK();
                     if (ret != 0) {
                         ERROR_OUT(ECC_EXPORT_ERROR, exit_scke);
                     }
                 #endif /* HAVE_ECC */
                     break;
                 }
             #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
 
                 default:
                     ret = BAD_KEA_TYPE_E;
             } /* switch(ssl->specs.kea) */
 
             /* Check for error */
             if (ret != 0) {
                 goto exit_scke;
             }
 
             /* Advance state and proceed */
             ssl->options.asyncState = TLS_ASYNC_DO;
         } /* case TLS_ASYNC_BUILD */
         FALL_THROUGH;
 
         case TLS_ASYNC_DO:
         {
             switch(ssl->specs.kea)
             {
             #ifndef NO_RSA
                 case rsa_kea:
                 {
                         ret = RsaEnc(ssl,
                             ssl->arrays->preMasterSecret, SECRET_LEN,
                             args->encSecret, &args->encSz,
                             ssl->peerRsaKey,
                         #if defined(HAVE_PK_CALLBACKS)
                             &ssl->buffers.peerRsaKey
                         #else
                             NULL
                         #endif
                         );
 
                     break;
                 }
             #endif /* !NO_RSA */
             #ifndef NO_DH
                 case diffie_hellman_kea:
                 {
                     ret = DhAgree(ssl, ssl->buffers.serverDH_Key,
                         ssl->buffers.sig.buffer, ssl->buffers.sig.length,
                         ssl->buffers.serverDH_Pub.buffer,
                         ssl->buffers.serverDH_Pub.length,
                         ssl->arrays->preMasterSecret,
                         &ssl->arrays->preMasterSz,
                         ssl->buffers.serverDH_P.buffer,
                         ssl->buffers.serverDH_P.length);
                     break;
                 }
             #endif /* !NO_DH */
             #ifndef NO_PSK
                 case psk_kea:
                 {
                     break;
                 }
             #endif /* !NO_PSK */
             #if !defined(NO_DH) && !defined(NO_PSK)
                 case dhe_psk_kea:
                 {
                     ret = DhAgree(ssl, ssl->buffers.serverDH_Key,
                         ssl->buffers.sig.buffer, ssl->buffers.sig.length,
                         ssl->buffers.serverDH_Pub.buffer,
                         ssl->buffers.serverDH_Pub.length,
                         ssl->arrays->preMasterSecret + OPAQUE16_LEN,
                         &ssl->arrays->preMasterSz,
                         ssl->buffers.serverDH_P.buffer,
                         ssl->buffers.serverDH_P.length);
                     break;
                 }
             #endif /* !NO_DH && !NO_PSK */
             #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                 case ecdhe_psk_kea:
                 {
                 #ifdef HAVE_CURVE25519
                     if (ssl->peerX25519KeyPresent) {
                         ret = X25519SharedSecret(ssl,
                             (curve25519_key*)ssl->hsKey, ssl->peerX25519Key,
                             args->output + OPAQUE8_LEN, &args->length,
                             ssl->arrays->preMasterSecret + OPAQUE16_LEN,
                             &ssl->arrays->preMasterSz,
                             WOLFSSL_CLIENT_END
                         );
                         if (!ssl->specs.static_ecdh
                         #ifdef WOLFSSL_ASYNC_CRYPT
                             && ret != WC_PENDING_E
                         #endif
                         ) {
                             FreeKey(ssl, DYNAMIC_TYPE_CURVE25519,
                                                    (void**)&ssl->peerX25519Key);
                             ssl->peerX25519KeyPresent = 0;
                         }
                         break;
                     }
                 #endif
                 #ifdef HAVE_CURVE448
                     if (ssl->peerX448KeyPresent) {
                         ret = X448SharedSecret(ssl,
                             (curve448_key*)ssl->hsKey, ssl->peerX448Key,
                             args->output + OPAQUE8_LEN, &args->length,
                             ssl->arrays->preMasterSecret + OPAQUE16_LEN,
                             &ssl->arrays->preMasterSz,
                             WOLFSSL_CLIENT_END
                         );
                         if (!ssl->specs.static_ecdh
                         #ifdef WOLFSSL_ASYNC_CRYPT
                             && ret != WC_PENDING_E
                         #endif
                         ) {
                             FreeKey(ssl, DYNAMIC_TYPE_CURVE448,
                                                      (void**)&ssl->peerX448Key);
                             ssl->peerX448KeyPresent = 0;
                         }
                         break;
                     }
                 #endif
                     ret = EccSharedSecret(ssl,
                         (ecc_key*)ssl->hsKey, ssl->peerEccKey,
                         args->output + OPAQUE8_LEN, &args->length,
                         ssl->arrays->preMasterSecret + OPAQUE16_LEN,
                         &ssl->arrays->preMasterSz,
                         WOLFSSL_CLIENT_END
                     );
                 #ifdef WOLFSSL_ASYNC_CRYPT
                     if (ret != WC_PENDING_E)
                 #endif
                     {
                         FreeKey(ssl, DYNAMIC_TYPE_ECC,
                                                       (void**)&ssl->peerEccKey);
                         ssl->peerEccKeyPresent = 0;
                     }
                     break;
                 }
             #endif /* (HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448) && !NO_PSK */
             #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                 case ecc_diffie_hellman_kea:
                 {
                 #ifdef HAVE_ECC
                     ecc_key* peerKey;
                 #endif
 
                 #ifdef HAVE_CURVE25519
                     if (ssl->peerX25519KeyPresent) {
                         ret = X25519SharedSecret(ssl,
                             (curve25519_key*)ssl->hsKey, ssl->peerX25519Key,
                             args->encSecret + OPAQUE8_LEN, &args->encSz,
                             ssl->arrays->preMasterSecret,
                             &ssl->arrays->preMasterSz,
                             WOLFSSL_CLIENT_END
                         );
                         if (!ssl->specs.static_ecdh
                         #ifdef WOLFSSL_ASYNC_CRYPT
                             && ret != WC_PENDING_E
                         #endif
                         ) {
                             FreeKey(ssl, DYNAMIC_TYPE_CURVE25519,
                                                    (void**)&ssl->peerX25519Key);
                             ssl->peerX25519KeyPresent = 0;
                         }
                         break;
                     }
                 #endif
                 #ifdef HAVE_CURVE448
                     if (ssl->peerX448KeyPresent) {
                         ret = X448SharedSecret(ssl,
                             (curve448_key*)ssl->hsKey, ssl->peerX448Key,
                             args->encSecret + OPAQUE8_LEN, &args->encSz,
                             ssl->arrays->preMasterSecret,
                             &ssl->arrays->preMasterSz,
                             WOLFSSL_CLIENT_END
                         );
                         if (!ssl->specs.static_ecdh
                         #ifdef WOLFSSL_ASYNC_CRYPT
                             && ret != WC_PENDING_E
                         #endif
                         ) {
                             FreeKey(ssl, DYNAMIC_TYPE_CURVE448,
                                                      (void**)&ssl->peerX448Key);
                             ssl->peerX448KeyPresent = 0;
                         }
                         break;
                     }
                 #endif
                 #ifdef HAVE_ECC
                     peerKey = (ssl->specs.static_ecdh) ?
                               ssl->peerEccDsaKey : ssl->peerEccKey;
 
                     ret = EccSharedSecret(ssl,
                               (ecc_key*)ssl->hsKey, peerKey,
                               args->encSecret + OPAQUE8_LEN, &args->encSz,
                               ssl->arrays->preMasterSecret,
                               &ssl->arrays->preMasterSz,
                               WOLFSSL_CLIENT_END);
 
                     if (!ssl->specs.static_ecdh
                 #ifdef WOLFSSL_ASYNC_CRYPT
                         && ret != WC_PENDING_E
                 #endif
                      && !ssl->options.keepResources) {
                         FreeKey(ssl, DYNAMIC_TYPE_ECC,
                                                       (void**)&ssl->peerEccKey);
                         ssl->peerEccKeyPresent = 0;
                     }
                 #endif
 
                     break;
                 }
             #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
 
                 default:
                     ret = BAD_KEA_TYPE_E;
             } /* switch(ssl->specs.kea) */
 
             /* Check for error */
             if (ret != 0) {
                 goto exit_scke;
             }
 
             /* Advance state and proceed */
             ssl->options.asyncState = TLS_ASYNC_VERIFY;
         } /* case TLS_ASYNC_DO */
         FALL_THROUGH;
 
         case TLS_ASYNC_VERIFY:
         {
             switch(ssl->specs.kea)
             {
             #ifndef NO_RSA
                 case rsa_kea:
                 {
                     break;
                 }
             #endif /* !NO_RSA */
             #ifndef NO_DH
                 case diffie_hellman_kea:
                 {
                     break;
                 }
             #endif /* !NO_DH */
             #ifndef NO_PSK
                 case psk_kea:
                 {
                     break;
                 }
             #endif /* !NO_PSK */
             #if !defined(NO_DH) && !defined(NO_PSK)
                 case dhe_psk_kea:
                 {
                     byte* pms = ssl->arrays->preMasterSecret;
 
                     /* validate args */
                     if (args->output == NULL || args->length == 0) {
                         ERROR_OUT(BAD_FUNC_ARG, exit_scke);
                     }
 
                     c16toa((word16)args->length, args->output);
                     args->encSz += args->length + OPAQUE16_LEN;
                     c16toa((word16)ssl->arrays->preMasterSz, pms);
                     ssl->arrays->preMasterSz += OPAQUE16_LEN;
                     pms += ssl->arrays->preMasterSz;
 
                     /* make psk pre master secret */
                     /* length of key + length 0s + length of key + key */
                     c16toa((word16)ssl->arrays->psk_keySz, pms);
                     pms += OPAQUE16_LEN;
                     XMEMCPY(pms, ssl->arrays->psk_key, ssl->arrays->psk_keySz);
                     ssl->arrays->preMasterSz +=
                                          ssl->arrays->psk_keySz + OPAQUE16_LEN;
                     ForceZero(ssl->arrays->psk_key, ssl->arrays->psk_keySz);
                     ssl->arrays->psk_keySz = 0; /* No further need */
                     break;
                 }
             #endif /* !NO_DH && !NO_PSK */
             #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                 case ecdhe_psk_kea:
                 {
                     byte* pms = ssl->arrays->preMasterSecret;
 
                     /* validate args */
                     if (args->output == NULL || args->length > ENCRYPT_LEN) {
                         ERROR_OUT(BAD_FUNC_ARG, exit_scke);
                     }
 
                     /* place size of public key in output buffer */
                     *args->output = (byte)args->length;
                     args->encSz += args->length + OPAQUE8_LEN;
 
                     /* Create pre master secret is the concatenation of
                        eccSize + eccSharedKey + pskSize + pskKey */
                     c16toa((word16)ssl->arrays->preMasterSz, pms);
                     ssl->arrays->preMasterSz += OPAQUE16_LEN;
                     pms += ssl->arrays->preMasterSz;
 
                     c16toa((word16)ssl->arrays->psk_keySz, pms);
                     pms += OPAQUE16_LEN;
                     XMEMCPY(pms, ssl->arrays->psk_key, ssl->arrays->psk_keySz);
                     ssl->arrays->preMasterSz +=
                                           ssl->arrays->psk_keySz + OPAQUE16_LEN;
 
                     ForceZero(ssl->arrays->psk_key, ssl->arrays->psk_keySz);
                     ssl->arrays->psk_keySz = 0; /* No further need */
                     break;
                 }
             #endif /* (HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448) && !NO_PSK */
             #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                 case ecc_diffie_hellman_kea:
                 {
                     if (args->encSecret == NULL) {
                         ret = BAD_STATE_E;
                         goto exit_scke;
                     }
                     else {
                         /* place size of public key in buffer */
                         *args->encSecret = (byte)args->encSz;
                         args->encSz += OPAQUE8_LEN;
                     }
                     break;
                 }
             #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
 
                 default:
                     ret = BAD_KEA_TYPE_E;
             } /* switch(ssl->specs.kea) */
 
             /* Check for error */
             if (ret != 0) {
                 goto exit_scke;
             }
 
             /* Advance state and proceed */
             ssl->options.asyncState = TLS_ASYNC_FINALIZE;
         } /* case TLS_ASYNC_VERIFY */
         FALL_THROUGH;
 
         case TLS_ASYNC_FINALIZE:
         {
             word32 tlsSz = 0;
             word32 idx = 0;
 
             if (ssl->options.tls || ssl->specs.kea == diffie_hellman_kea) {
                 tlsSz = 2;
             }
 
             if (ssl->specs.kea == ecc_diffie_hellman_kea ||
                 ssl->specs.kea == dhe_psk_kea ||
                 ssl->specs.kea == ecdhe_psk_kea) { /* always off */
                 tlsSz = 0;
             }
 
             idx = HANDSHAKE_HEADER_SZ + RECORD_HEADER_SZ;
             args->sendSz = args->encSz + tlsSz + idx;
 
         #ifdef WOLFSSL_DTLS
             if (ssl->options.dtls) {
                 idx    += DTLS_HANDSHAKE_EXTRA + DTLS_RECORD_EXTRA;
                 args->sendSz += DTLS_HANDSHAKE_EXTRA + DTLS_RECORD_EXTRA;
             }
         #endif
 
             if (IsEncryptionOn(ssl, 1)) {
                 args->sendSz += MAX_MSG_EXTRA;
             }
 
             /* check for available size */
             if ((ret = CheckAvailableSize(ssl, args->sendSz)) != 0)
                 goto exit_scke;
 
             /* get output buffer */
-            args->output = ssl->buffers.outputBuffer.buffer +
-                           ssl->buffers.outputBuffer.length;
+            args->output = GetOutputBuffer(ssl);
 
             AddHeaders(args->output, args->encSz + tlsSz, client_key_exchange, ssl);
 
             if (tlsSz) {
                 c16toa((word16)args->encSz, &args->output[idx]);
                 idx += OPAQUE16_LEN;
             }
             XMEMCPY(args->output + idx, args->encSecret, args->encSz);
             idx += args->encSz;
 
             if (IsEncryptionOn(ssl, 1)) {
                 int recordHeaderSz = RECORD_HEADER_SZ;
 
                 if (ssl->options.dtls)
                     recordHeaderSz += DTLS_RECORD_EXTRA;
                 args->inputSz = idx - recordHeaderSz; /* buildmsg adds rechdr */
                 args->input = (byte*)XMALLOC(args->inputSz, ssl->heap,
                                                        DYNAMIC_TYPE_IN_BUFFER);
                 if (args->input == NULL) {
                     ERROR_OUT(MEMORY_E, exit_scke);
                 }
 
                 XMEMCPY(args->input, args->output + recordHeaderSz,
                                                                 args->inputSz);
             }
 
             /* Advance state and proceed */
             ssl->options.asyncState = TLS_ASYNC_END;
         } /* case TLS_ASYNC_FINALIZE */
         FALL_THROUGH;
 
         case TLS_ASYNC_END:
         {
             if (IsEncryptionOn(ssl, 1)) {
             #ifdef WOLFSSL_DTLS
                 if (IsDtlsNotSctpMode(ssl) &&
                         (ret = DtlsMsgPoolSave(ssl, args->input, args->inputSz, client_key_exchange)) != 0) {
                     goto exit_scke;
                 }
             #endif
                 ret = BuildMessage(ssl, args->output, args->sendSz,
                             args->input, args->inputSz, handshake, 1, 0, 0, CUR_ORDER);
                 XFREE(args->input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
                 args->input = NULL; /* make sure its not double free'd on cleanup */
 
                 if (ret >= 0) {
                     args->sendSz = ret;
                     ret = 0;
                 }
             }
             else {
             #ifdef WOLFSSL_DTLS
                 if (IsDtlsNotSctpMode(ssl)) {
                     if ((ret = DtlsMsgPoolSave(ssl, args->output, args->sendSz, client_key_exchange)) != 0) {
                         goto exit_scke;
                     }
                 }
                 if (ssl->options.dtls)
                     DtlsSEQIncrement(ssl, CUR_ORDER);
             #endif
                 ret = HashOutput(ssl, args->output, args->sendSz, 0);
             }
 
             if (ret != 0) {
                 goto exit_scke;
             }
 
         #if defined(WOLFSSL_CALLBACKS) || defined(OPENSSL_EXTRA)
             if (ssl->hsInfoOn)
                 AddPacketName(ssl, "ClientKeyExchange");
             if (ssl->toInfoOn) {
                 ret = AddPacketInfo(ssl, "ClientKeyExchange", handshake,
                          args->output, args->sendSz, WRITE_PROTO, 0, ssl->heap);
                 if (ret != 0) {
                     goto exit_scke;
                 }
             }
         #endif
 
             ssl->buffers.outputBuffer.length += args->sendSz;
 
             if (!ssl->options.groupMessages) {
                 ret = SendBuffered(ssl);
             }
             if (ret == 0 || ret == WANT_WRITE) {
                 int tmpRet = MakeMasterSecret(ssl);
                 if (tmpRet != 0) {
                     ret = tmpRet;   /* save WANT_WRITE unless more serious */
                 }
                 ssl->options.clientState = CLIENT_KEYEXCHANGE_COMPLETE;
                 ssl->options.buildingMsg = 0;
             }
         #if defined(OPENSSL_EXTRA) && defined(HAVE_SECRET_CALLBACK)
             if (ssl->keyLogCb != NULL) {
                 int secretSz = SECRET_LEN;
                 ret = ssl->keyLogCb(ssl, ssl->arrays->masterSecret, &secretSz,
                                                                         NULL);
                 if (ret != 0 || secretSz != SECRET_LEN)
                     return SESSION_SECRET_CB_E;
             }
         #endif /* OPENSSL_EXTRA && HAVE_SECRET_CALLBACK */
             break;
         }
         default:
             ret = INPUT_CASE_ERROR;
     } /* switch(ssl->options.asyncState) */
