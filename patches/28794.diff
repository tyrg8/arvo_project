commit a60ac0c45c7fb940d348c72c6c4f9a19548ad569
Author: John Stiles <johnstiles@google.com>
Date:   Tue Dec 22 08:59:51 2020 -0500

    Fix for fuzzer-discovered crash with swizzles.
    
    We need to rescan after optimizing away expressions that might exist
    in the CFG/definition map, since we are rebuilding them from scratch and
    not just stripping off excess parts from them.
    
    Change-Id: I843a2ea3fc38428e7c0bd0e2bf7a7d41101345e3
    Bug: oss-fuzz:28794
    Reviewed-on: https://skia-review.googlesource.com/c/skia/+/344972
    Commit-Queue: John Stiles <johnstiles@google.com>
    Reviewed-by: Brian Osman <brianosman@google.com>
    Auto-Submit: John Stiles <johnstiles@google.com>

diff --git a/gn/sksl_tests.gni b/gn/sksl_tests.gni
index 7ecba3f169..6e8b6a39c3 100644
--- a/gn/sksl_tests.gni
+++ b/gn/sksl_tests.gni
@@ -200,178 +200,179 @@ sksl_spirv_tests = [
 sksl_shared_tests = [
   "$_tests/sksl/intrinsics/Abs.sksl",
   "$_tests/sksl/intrinsics/Acos.sksl",
   "$_tests/sksl/intrinsics/Acosh.sksl",
   "$_tests/sksl/intrinsics/All.sksl",
   "$_tests/sksl/intrinsics/Any.sksl",
   "$_tests/sksl/intrinsics/Asin.sksl",
   "$_tests/sksl/intrinsics/Asinh.sksl",
   "$_tests/sksl/intrinsics/Atan.sksl",
   "$_tests/sksl/intrinsics/Atanh.sksl",
   "$_tests/sksl/intrinsics/Ceil.sksl",
   "$_tests/sksl/intrinsics/Clamp.sksl",
   "$_tests/sksl/intrinsics/Cos.sksl",
   "$_tests/sksl/intrinsics/Cosh.sksl",
   "$_tests/sksl/intrinsics/Cross.sksl",
   "$_tests/sksl/intrinsics/Degrees.sksl",
   "$_tests/sksl/intrinsics/Determinant.sksl",
   "$_tests/sksl/intrinsics/DFdx.sksl",
   "$_tests/sksl/intrinsics/DFdy.sksl",
   "$_tests/sksl/intrinsics/Distance.sksl",
   "$_tests/sksl/intrinsics/Dot.sksl",
   "$_tests/sksl/intrinsics/Equal.sksl",
   "$_tests/sksl/intrinsics/Exp.sksl",
   "$_tests/sksl/intrinsics/Exp2.sksl",
   "$_tests/sksl/intrinsics/FaceForward.sksl",
   "$_tests/sksl/intrinsics/FindLSB.sksl",
   "$_tests/sksl/intrinsics/FindMSB.sksl",
   "$_tests/sksl/intrinsics/FloatBitsToInt.sksl",
   "$_tests/sksl/intrinsics/FloatBitsToUint.sksl",
   "$_tests/sksl/intrinsics/Floor.sksl",
   "$_tests/sksl/intrinsics/Fma.sksl",
   "$_tests/sksl/intrinsics/Fract.sksl",
   "$_tests/sksl/intrinsics/Frexp.sksl",
   "$_tests/sksl/intrinsics/Fwidth.sksl",
   "$_tests/sksl/intrinsics/GreaterThan.sksl",
   "$_tests/sksl/intrinsics/GreaterThanEqual.sksl",
   "$_tests/sksl/intrinsics/IntBitsToFloat.sksl",
   "$_tests/sksl/intrinsics/Inverse.sksl",
   "$_tests/sksl/intrinsics/Inversesqrt.sksl",
   "$_tests/sksl/intrinsics/IsInf.sksl",
   "$_tests/sksl/intrinsics/IsNan.sksl",
   "$_tests/sksl/intrinsics/Ldexp.sksl",
   "$_tests/sksl/intrinsics/Length.sksl",
   "$_tests/sksl/intrinsics/LessThan.sksl",
   "$_tests/sksl/intrinsics/LessThanEqual.sksl",
   "$_tests/sksl/intrinsics/Log.sksl",
   "$_tests/sksl/intrinsics/Log2.sksl",
   "$_tests/sksl/intrinsics/MatrixCompMult.sksl",
   "$_tests/sksl/intrinsics/Max.sksl",
   "$_tests/sksl/intrinsics/Min.sksl",
   "$_tests/sksl/intrinsics/Mix.sksl",
   "$_tests/sksl/intrinsics/Mod.sksl",
   "$_tests/sksl/intrinsics/Modf.sksl",
   "$_tests/sksl/intrinsics/Normalize.sksl",
   "$_tests/sksl/intrinsics/Not.sksl",
   "$_tests/sksl/intrinsics/NotEqual.sksl",
   "$_tests/sksl/intrinsics/OuterProduct.sksl",
   "$_tests/sksl/intrinsics/Pack.sksl",
   "$_tests/sksl/intrinsics/Pow.sksl",
   "$_tests/sksl/intrinsics/Radians.sksl",
   "$_tests/sksl/intrinsics/Reflect.sksl",
   "$_tests/sksl/intrinsics/Refract.sksl",
   "$_tests/sksl/intrinsics/Round.sksl",
   "$_tests/sksl/intrinsics/RoundEven.sksl",
   "$_tests/sksl/intrinsics/Saturate.sksl",
   "$_tests/sksl/intrinsics/Sign.sksl",
   "$_tests/sksl/intrinsics/Sin.sksl",
   "$_tests/sksl/intrinsics/Sinh.sksl",
   "$_tests/sksl/intrinsics/Smoothstep.sksl",
   "$_tests/sksl/intrinsics/Sqrt.sksl",
   "$_tests/sksl/intrinsics/Step.sksl",
   "$_tests/sksl/intrinsics/Tan.sksl",
   "$_tests/sksl/intrinsics/Tanh.sksl",
   "$_tests/sksl/intrinsics/Transpose.sksl",
   "$_tests/sksl/intrinsics/Trunc.sksl",
   "$_tests/sksl/intrinsics/UintBitsToFloat.sksl",
   "$_tests/sksl/intrinsics/Unpack.sksl",
   "$_tests/sksl/shared/ArrayConstructors.sksl",
   "$_tests/sksl/shared/ArrayIndexTypes.sksl",
   "$_tests/sksl/shared/ArrayTypes.sksl",
   "$_tests/sksl/shared/Assignment.sksl",
   "$_tests/sksl/shared/BoolFolding.sksl",
   "$_tests/sksl/shared/Caps.sksl",
   "$_tests/sksl/shared/CastsRoundTowardZero.sksl",
   "$_tests/sksl/shared/Clockwise.sksl",
   "$_tests/sksl/shared/ComplexDelete.sksl",
   "$_tests/sksl/shared/ConstArray.sksl",
   "$_tests/sksl/shared/ConstVariableComparison.sksl",
   "$_tests/sksl/shared/ConstantIf.sksl",
   "$_tests/sksl/shared/Control.sksl",
   "$_tests/sksl/shared/DeadDoWhileLoop.sksl",
   "$_tests/sksl/shared/DeadIfStatement.sksl",
   "$_tests/sksl/shared/DeadLoopVariable.sksl",
   "$_tests/sksl/shared/DeadStripFunctions.sksl",
   "$_tests/sksl/shared/DependentInitializers.sksl",
   "$_tests/sksl/shared/DerivativesUnused.sksl",
   "$_tests/sksl/shared/Discard.sksl",
   "$_tests/sksl/shared/Enum.sksl",
   "$_tests/sksl/shared/FloatFolding.sksl",
   "$_tests/sksl/shared/FragCoordsFlipY.sksl",
   "$_tests/sksl/shared/FragCoordsNew.sksl",
   "$_tests/sksl/shared/FragCoordsOld.sksl",
   "$_tests/sksl/shared/FunctionArgumentMatch.sksl",
   "$_tests/sksl/shared/FunctionPrototype.sksl",
   "$_tests/sksl/shared/Functions.sksl",
   "$_tests/sksl/shared/GaussianBlur.sksl",
   "$_tests/sksl/shared/GeometricIntrinsics.sksl",
   "$_tests/sksl/shared/Geometry.geom",
   "$_tests/sksl/shared/GeometryExtension.geom",
   "$_tests/sksl/shared/GeometryGSInvocations.geom",
   "$_tests/sksl/shared/GeometryNoGSInvocations.geom",
   "$_tests/sksl/shared/GeometryNoGSInvocationsReorder.geom",
   "$_tests/sksl/shared/Height.sksl",
   "$_tests/sksl/shared/HelloWorld.sksl",
   "$_tests/sksl/shared/Hex.sksl",
   "$_tests/sksl/shared/InstanceID.vert",
   "$_tests/sksl/shared/IntFolding.sksl",
   "$_tests/sksl/shared/InterfaceBlockAnonymous.sksl",
   "$_tests/sksl/shared/InterfaceBlockArray.sksl",
   "$_tests/sksl/shared/InterfaceBlockNamed.sksl",
   "$_tests/sksl/shared/Matrices.sksl",
   "$_tests/sksl/shared/MatrixFolding.sksl",
   "$_tests/sksl/shared/MixedTypeCommaOperator.sksl",
   "$_tests/sksl/shared/MultipleAssignments.sksl",
   "$_tests/sksl/shared/NegatedVectorLiteral.sksl",
   "$_tests/sksl/shared/NoFragCoordsPos.vert",
   "$_tests/sksl/shared/NoFragCoordsPosRT.vert",
   "$_tests/sksl/shared/NormalizationGeo.geom",
   "$_tests/sksl/shared/NormalizationVert.vert",
   "$_tests/sksl/shared/NumberConversions.sksl",
   "$_tests/sksl/shared/Offset.sksl",
   "$_tests/sksl/shared/Operators.sksl",
   "$_tests/sksl/shared/Ossfuzz26167.sksl",
   "$_tests/sksl/shared/Ossfuzz27614.sksl",
   "$_tests/sksl/shared/Ossfuzz28050.sksl",
+  "$_tests/sksl/shared/Ossfuzz28794.sksl",
   "$_tests/sksl/shared/OutParams.sksl",
   "$_tests/sksl/shared/OutParamsTricky.sksl",
   "$_tests/sksl/shared/RectangleTexture.sksl",
   "$_tests/sksl/shared/ResizeMatrix.sksl",
   "$_tests/sksl/shared/SampleMask.sksl",
   "$_tests/sksl/shared/ScopedSymbol.sksl",
   "$_tests/sksl/shared/ShortCircuitBoolFolding.sksl",
   "$_tests/sksl/shared/StackingVectorCasts.sksl",
   "$_tests/sksl/shared/StaticIf.sksl",
   "$_tests/sksl/shared/StaticSwitch.sksl",
   "$_tests/sksl/shared/StaticSwitchWithBreak.sksl",
   "$_tests/sksl/shared/StaticSwitchWithBreakInsideBlock.sksl",
   "$_tests/sksl/shared/StaticSwitchWithConditionalBreak.sksl",
   "$_tests/sksl/shared/StaticSwitchWithConditionalBreakInsideBlock.sksl",
   "$_tests/sksl/shared/StaticSwitchWithFallthroughA.sksl",
   "$_tests/sksl/shared/StaticSwitchWithFallthroughB.sksl",
   "$_tests/sksl/shared/StaticSwitchWithStaticConditionalBreak.sksl",
   "$_tests/sksl/shared/StaticSwitchWithStaticConditionalBreakInsideBlock.sksl",
   "$_tests/sksl/shared/Structs.sksl",
   "$_tests/sksl/shared/StructMaxDepth.sksl",
   "$_tests/sksl/shared/Switch.sksl",
   "$_tests/sksl/shared/SwitchContainingDeadCode.sksl",
   "$_tests/sksl/shared/SwitchWithFallthrough.sksl",
   "$_tests/sksl/shared/SwizzleBoolConstants.sksl",
   "$_tests/sksl/shared/SwizzleByIndex.sksl",
   "$_tests/sksl/shared/SwizzleConstants.sksl",
   "$_tests/sksl/shared/SwizzleLTRB.sksl",
   "$_tests/sksl/shared/SwizzleOpt.sksl",
   "$_tests/sksl/shared/SwizzleScalar.sksl",
   "$_tests/sksl/shared/TernaryAsLValueEntirelyFoldable.sksl",
   "$_tests/sksl/shared/TernaryAsLValueFoldableTest.sksl",
   "$_tests/sksl/shared/Texture1D.sksl",
   "$_tests/sksl/shared/Texture2D.sksl",
   "$_tests/sksl/shared/TextureSharpen.sksl",
   "$_tests/sksl/shared/UnaryPositiveNegative.sksl",
   "$_tests/sksl/shared/UniformArray.sksl",
   "$_tests/sksl/shared/UnusedVariables.sksl",
   "$_tests/sksl/shared/VectorConstructors.sksl",
   "$_tests/sksl/shared/VectorFolding.sksl",
   "$_tests/sksl/shared/VertexEarlyReturn.vert",
   "$_tests/sksl/shared/VertexID.vert",
   "$_tests/sksl/shared/Width.sksl",
 ]
diff --git a/src/sksl/SkSLCFGGenerator.cpp b/src/sksl/SkSLCFGGenerator.cpp
index aabd3a865c..61a45b7fd4 100644
--- a/src/sksl/SkSLCFGGenerator.cpp
+++ b/src/sksl/SkSLCFGGenerator.cpp
@@ -101,40 +101,50 @@ void BasicBlock::dump() const {
 bool BasicBlock::tryRemoveExpressionBefore(std::vector<BasicBlock::Node>::iterator* iter,
                                            Expression* e) {
     if (e->is<TernaryExpression>()) {
         return false;
     }
     bool result;
     if ((*iter)->isExpression()) {
         SkASSERT((*iter)->expression()->get() != e);
+        // Remember the expression that we started on.
         Expression* old = (*iter)->expression()->get();
+        // Back up `iter` until we find the expression that we want to remove. (If we don't find
+        // that expression at all, fail and rescan.)
         do {
             if ((*iter) == fNodes.begin()) {
                 return false;
             }
             --(*iter);
         } while (!(*iter)->isExpression() || (*iter)->expression()->get() != e);
 
+        // `iter` now points to our expression that needs removal. Erase it.
         result = this->tryRemoveExpression(iter);
 
+        // Move `iter` forward again until we find the expression we started on.
         while (!(*iter)->isExpression() || (*iter)->expression()->get() != old) {
             SkASSERT(*iter != fNodes.end());
             ++(*iter);
         }
     } else {
+        // Remember the statement that we started on.
         Statement* old = (*iter)->statement()->get();
+        // Back up `iter` until we find the expression that we want to remove. (If we don't find
+        // that expression at all, fail and rescan.)
         do {
             if ((*iter) == fNodes.begin()) {
                 return false;
             }
             --(*iter);
         } while (!(*iter)->isExpression() || (*iter)->expression()->get() != e);
 
+        // `iter` now points to our expression that needs removal. Erase it.
         result = this->tryRemoveExpression(iter);
 
+        // Move `iter` forward again until we find the statement we started on.
         while (!(*iter)->isStatement() || (*iter)->statement()->get() != old) {
             SkASSERT(*iter != fNodes.end());
             ++(*iter);
         }
     }
     return result;
 }
diff --git a/src/sksl/SkSLCompiler.cpp b/src/sksl/SkSLCompiler.cpp
index 0285e71bbb..ae6c225525 100644
--- a/src/sksl/SkSLCompiler.cpp
+++ b/src/sksl/SkSLCompiler.cpp
@@ -857,471 +857,468 @@ static void clear_write(Expression& expr) {
 void Compiler::simplifyExpression(DefinitionMap& definitions,
                                   BasicBlock& b,
                                   std::vector<BasicBlock::Node>::iterator* iter,
                                   OptimizationContext* optimizationContext) {
     Expression* expr = (*iter)->expression()->get();
     SkASSERT(expr);
 
     if ((*iter)->fConstantPropagation) {
         std::unique_ptr<Expression> optimized = expr->constantPropagate(*fIRGenerator,
                                                                         definitions);
         if (optimized) {
             optimizationContext->fUpdated = true;
             optimized = fIRGenerator->coerce(std::move(optimized), expr->type());
             SkASSERT(optimized);
             // Remove references within 'expr', add references within 'optimized'
             optimizationContext->fUsage->replace(expr, optimized.get());
             if (!try_replace_expression(&b, iter, &optimized)) {
                 optimizationContext->fNeedsRescan = true;
                 return;
             }
             SkASSERT((*iter)->isExpression());
             expr = (*iter)->expression()->get();
         }
     }
     switch (expr->kind()) {
         case Expression::Kind::kVariableReference: {
             const VariableReference& ref = expr->as<VariableReference>();
             const Variable* var = ref.variable();
             if (ref.refKind() != VariableReference::RefKind::kWrite &&
                 ref.refKind() != VariableReference::RefKind::kPointer &&
                 var->storage() == Variable::Storage::kLocal && !definitions[var] &&
                 optimizationContext->fSilences.find(var) == optimizationContext->fSilences.end()) {
                 optimizationContext->fSilences.insert(var);
                 this->error(expr->fOffset,
                             "'" + var->name() + "' has not been assigned");
             }
             break;
         }
         case Expression::Kind::kTernary: {
             TernaryExpression* t = &expr->as<TernaryExpression>();
             if (t->test()->is<BoolLiteral>()) {
                 // ternary has a constant test, replace it with either the true or
                 // false branch
                 if (t->test()->as<BoolLiteral>().value()) {
                     (*iter)->setExpression(std::move(t->ifTrue()), optimizationContext->fUsage);
                 } else {
                     (*iter)->setExpression(std::move(t->ifFalse()), optimizationContext->fUsage);
                 }
                 optimizationContext->fUpdated = true;
                 optimizationContext->fNeedsRescan = true;
             }
             break;
         }
         case Expression::Kind::kBinary: {
             BinaryExpression* bin = &expr->as<BinaryExpression>();
             if (dead_assignment(*bin, optimizationContext->fUsage)) {
                 delete_left(&b, iter, optimizationContext);
                 break;
             }
             Expression& left = *bin->left();
             Expression& right = *bin->right();
             const Type& leftType = left.type();
             const Type& rightType = right.type();
             // collapse useless expressions like x * 1 or x + 0
             if ((!leftType.isScalar() && !leftType.isVector()) ||
                 (!rightType.isScalar() && !rightType.isVector())) {
                 break;
             }
             switch (bin->getOperator()) {
                 case Token::Kind::TK_STAR:
                     if (is_constant(left, 1)) {
                         if (leftType.isVector() && rightType.isScalar()) {
                             // float4(1) * x -> float4(x)
                             vectorize_right(&b, iter, optimizationContext);
                         } else {
                             // 1 * x -> x
                             // 1 * float4(x) -> float4(x)
                             // float4(1) * float4(x) -> float4(x)
                             delete_left(&b, iter, optimizationContext);
                         }
                     }
                     else if (is_constant(left, 0)) {
                         if (leftType.isScalar() && rightType.isVector() &&
                             !right.hasSideEffects()) {
                             // 0 * float4(x) -> float4(0)
                             vectorize_left(&b, iter, optimizationContext);
                         } else {
                             // 0 * x -> 0
                             // float4(0) * x -> float4(0)
                             // float4(0) * float4(x) -> float4(0)
                             if (!right.hasSideEffects()) {
                                 delete_right(&b, iter, optimizationContext);
                             }
                         }
                     }
                     else if (is_constant(right, 1)) {
                         if (leftType.isScalar() && rightType.isVector()) {
                             // x * float4(1) -> float4(x)
                             vectorize_left(&b, iter, optimizationContext);
                         } else {
                             // x * 1 -> x
                             // float4(x) * 1 -> float4(x)
                             // float4(x) * float4(1) -> float4(x)
                             delete_right(&b, iter, optimizationContext);
                         }
                     }
                     else if (is_constant(right, 0)) {
                         if (leftType.isVector() && rightType.isScalar() && !left.hasSideEffects()) {
                             // float4(x) * 0 -> float4(0)
                             vectorize_right(&b, iter, optimizationContext);
                         } else {
                             // x * 0 -> 0
                             // x * float4(0) -> float4(0)
                             // float4(x) * float4(0) -> float4(0)
                             if (!left.hasSideEffects()) {
                                 delete_left(&b, iter, optimizationContext);
                             }
                         }
                     }
                     break;
                 case Token::Kind::TK_PLUS:
                     if (is_constant(left, 0)) {
                         if (leftType.isVector() && rightType.isScalar()) {
                             // float4(0) + x -> float4(x)
                             vectorize_right(&b, iter, optimizationContext);
                         } else {
                             // 0 + x -> x
                             // 0 + float4(x) -> float4(x)
                             // float4(0) + float4(x) -> float4(x)
                             delete_left(&b, iter, optimizationContext);
                         }
                     } else if (is_constant(right, 0)) {
                         if (leftType.isScalar() && rightType.isVector()) {
                             // x + float4(0) -> float4(x)
                             vectorize_left(&b, iter, optimizationContext);
                         } else {
                             // x + 0 -> x
                             // float4(x) + 0 -> float4(x)
                             // float4(x) + float4(0) -> float4(x)
                             delete_right(&b, iter, optimizationContext);
                         }
                     }
                     break;
                 case Token::Kind::TK_MINUS:
                     if (is_constant(right, 0)) {
                         if (leftType.isScalar() && rightType.isVector()) {
                             // x - float4(0) -> float4(x)
                             vectorize_left(&b, iter, optimizationContext);
                         } else {
                             // x - 0 -> x
                             // float4(x) - 0 -> float4(x)
                             // float4(x) - float4(0) -> float4(x)
                             delete_right(&b, iter, optimizationContext);
                         }
                     }
                     break;
                 case Token::Kind::TK_SLASH:
                     if (is_constant(right, 1)) {
                         if (leftType.isScalar() && rightType.isVector()) {
                             // x / float4(1) -> float4(x)
                             vectorize_left(&b, iter, optimizationContext);
                         } else {
                             // x / 1 -> x
                             // float4(x) / 1 -> float4(x)
                             // float4(x) / float4(1) -> float4(x)
                             delete_right(&b, iter, optimizationContext);
                         }
                     } else if (is_constant(left, 0)) {
                         if (leftType.isScalar() && rightType.isVector() &&
                             !right.hasSideEffects()) {
                             // 0 / float4(x) -> float4(0)
                             vectorize_left(&b, iter, optimizationContext);
                         } else {
                             // 0 / x -> 0
                             // float4(0) / x -> float4(0)
                             // float4(0) / float4(x) -> float4(0)
                             if (!right.hasSideEffects()) {
                                 delete_right(&b, iter, optimizationContext);
                             }
                         }
                     }
                     break;
                 case Token::Kind::TK_PLUSEQ:
                     if (is_constant(right, 0)) {
                         clear_write(left);
                         delete_right(&b, iter, optimizationContext);
                     }
                     break;
                 case Token::Kind::TK_MINUSEQ:
                     if (is_constant(right, 0)) {
                         clear_write(left);
                         delete_right(&b, iter, optimizationContext);
                     }
                     break;
                 case Token::Kind::TK_STAREQ:
                     if (is_constant(right, 1)) {
                         clear_write(left);
                         delete_right(&b, iter, optimizationContext);
                     }
                     break;
                 case Token::Kind::TK_SLASHEQ:
                     if (is_constant(right, 1)) {
                         clear_write(left);
                         delete_right(&b, iter, optimizationContext);
                     }
                     break;
                 default:
                     break;
             }
             break;
         }
         case Expression::Kind::kConstructor: {
             // Find constructors embedded inside constructors and flatten them out where possible.
             //   -  float4(float2(1, 2), 3, 4)                -->  float4(1, 2, 3, 4)
             //   -  float4(w, float3(sin(x), cos(y), tan(z))) -->  float4(w, sin(x), cos(y), tan(z))
             // Leave single-argument constructors alone, though. These might be casts or splats.
             Constructor& c = expr->as<Constructor>();
             if (c.type().columns() > 1) {
                 // Inspect each constructor argument to see if it's a candidate for flattening.
                 // Remember matched arguments in a bitfield, "argsToOptimize".
                 int argsToOptimize = 0;
                 int currBit = 1;
                 for (const std::unique_ptr<Expression>& arg : c.arguments()) {
                     if (arg->is<Constructor>()) {
                         Constructor& inner = arg->as<Constructor>();
                         if (inner.arguments().size() > 1 &&
                             inner.type().componentType() == c.type().componentType()) {
                             argsToOptimize |= currBit;
                         }
                     }
                     currBit <<= 1;
                 }
                 if (argsToOptimize) {
                     // We found at least one argument that could be flattened out. Re-walk the
                     // constructor args and flatten the candidates we found during our initial pass.
                     ExpressionArray flattened;
                     flattened.reserve_back(c.type().columns());
                     currBit = 1;
                     for (const std::unique_ptr<Expression>& arg : c.arguments()) {
                         if (argsToOptimize & currBit) {
                             Constructor& inner = arg->as<Constructor>();
                             for (const std::unique_ptr<Expression>& innerArg : inner.arguments()) {
                                 flattened.push_back(innerArg->clone());
                             }
                         } else {
                             flattened.push_back(arg->clone());
                         }
                         currBit <<= 1;
                     }
                     auto optimized = std::unique_ptr<Expression>(
                             new Constructor(c.fOffset, &c.type(), std::move(flattened)));
                     // No fUsage change; no references have been added or removed anywhere.
                     optimizationContext->fUpdated = true;
                     if (!try_replace_expression(&b, iter, &optimized)) {
                         optimizationContext->fNeedsRescan = true;
                         return;
                     }
                     SkASSERT((*iter)->isExpression());
                     break;
                 }
             }
             break;
         }
         case Expression::Kind::kSwizzle: {
             Swizzle& s = expr->as<Swizzle>();
             // Detect identity swizzles like `foo.rgba`.
             if ((int) s.components().size() == s.base()->type().columns()) {
                 bool identity = true;
                 for (int i = 0; i < (int) s.components().size(); ++i) {
                     if (s.components()[i] != i) {
                         identity = false;
                         break;
                     }
                 }
                 if (identity) {
                     optimizationContext->fUpdated = true;
                     // No fUsage change: foo.rgba and foo have equivalent reference counts
                     if (!try_replace_expression(&b, iter, &s.base())) {
                         optimizationContext->fNeedsRescan = true;
                         return;
                     }
                     SkASSERT((*iter)->isExpression());
                     break;
                 }
             }
             // Detect swizzles of swizzles, e.g. replace `foo.argb.r000` with `foo.a000`.
             if (s.base()->is<Swizzle>()) {
                 Swizzle& base = s.base()->as<Swizzle>();
                 ComponentArray final;
                 for (int c : s.components()) {
                     final.push_back(base.components()[c]);
                 }
                 optimizationContext->fUpdated = true;
                 std::unique_ptr<Expression> replacement(new Swizzle(*fContext, base.base()->clone(),
                                                                     final));
                 // No fUsage change: `foo.gbr.gbr` and `foo.brg` have equivalent reference counts
                 if (!try_replace_expression(&b, iter, &replacement)) {
                     optimizationContext->fNeedsRescan = true;
                     return;
                 }
                 SkASSERT((*iter)->isExpression());
                 break;
             }
             // Optimize swizzles of constructors.
             if (s.base()->is<Constructor>()) {
                 Constructor& base = s.base()->as<Constructor>();
                 std::unique_ptr<Expression> replacement;
                 const Type& componentType = base.type().componentType();
                 int swizzleSize = s.components().size();
 
                 // The IR generator has already converted any zero/one swizzle components into
                 // constructors containing zero/one args. Confirm that this is true by checking that
                 // our swizzle components are all `xyzw` (values 0 through 3).
                 SkASSERT(std::all_of(s.components().begin(), s.components().end(),
                                      [](int8_t c) { return c >= 0 && c <= 3; }));
 
                 if (base.arguments().size() == 1 && base.arguments().front()->type().isScalar()) {
                     // `half4(scalar).zyy` can be optimized to `half3(scalar)`. The swizzle
                     // components don't actually matter since all fields are the same.
                     ExpressionArray newArgs;
                     newArgs.push_back(base.arguments().front()->clone());
                     replacement = std::make_unique<Constructor>(
                             base.fOffset,
                             &componentType.toCompound(*fContext, swizzleSize, /*rows=*/1),
                             std::move(newArgs));
 
-                    // No fUsage change: `half4(foo).xy` and `half2(foo)` have equivalent reference
-                    // counts.
+                    // We're replacing an expression with a cloned version; we'll need a rescan.
+                    // There's no fUsage change: `half4(foo).xy` and `half2(foo)` have equivalent
+                    // reference counts.
+                    try_replace_expression(&b, iter, &replacement);
                     optimizationContext->fUpdated = true;
-                    if (!try_replace_expression(&b, iter, &replacement)) {
-                        optimizationContext->fNeedsRescan = true;
-                        return;
-                    }
-                    SkASSERT((*iter)->isExpression());
+                    optimizationContext->fNeedsRescan = true;
                     break;
                 }
 
                 // Swizzles can duplicate some elements and discard others, e.g.
                 // `half4(1, 2, 3, 4).xxz` --> `half3(1, 1, 3)`. However, there are constraints:
                 // - Expressions with side effects need to occur exactly once, even if they
                 //   would otherwise be swizzle-eliminated
                 // - Non-trivial expressions should not be repeated, but elimination is OK.
                 //
                 // Look up the argument for the constructor at each index. This is typically simple
                 // but for weird cases like `half4(bar.yz, half2(foo))`, it can be harder than it
                 // seems. This example would result in:
                 //     argMap[0] = {.fArgIndex = 0, .fComponent = 0}   (bar.yz     .x)
                 //     argMap[1] = {.fArgIndex = 0, .fComponent = 1}   (bar.yz     .y)
                 //     argMap[2] = {.fArgIndex = 1, .fComponent = 0}   (half2(foo) .x)
                 //     argMap[3] = {.fArgIndex = 1, .fComponent = 1}   (half2(foo) .y)
                 struct ConstructorArgMap {
                     int8_t fArgIndex;
                     int8_t fComponent;
                 };
 
                 int numConstructorArgs = base.type().columns();
                 ConstructorArgMap argMap[4] = {};
                 int writeIdx = 0;
                 for (int argIdx = 0; argIdx < (int) base.arguments().size(); ++argIdx) {
                     const Expression& expr = *base.arguments()[argIdx];
                     int argWidth = expr.type().columns();
                     for (int componentIdx = 0; componentIdx < argWidth; ++componentIdx) {
                         argMap[writeIdx].fArgIndex = argIdx;
                         argMap[writeIdx].fComponent = componentIdx;
                         ++writeIdx;
                     }
                 }
                 SkASSERT(writeIdx == numConstructorArgs);
 
                 // Count up the number of times each constructor argument is used by the
                 // swizzle.
                 //    `half4(bar.yz, half2(foo)).xwxy` -> { 3, 1 }
                 // - bar.yz    is referenced 3 times, by `.x_xy`
                 // - half(foo) is referenced 1 time,  by `._w__`
                 int8_t exprUsed[4] = {};
                 for (int c : s.components()) {
                     exprUsed[argMap[c].fArgIndex]++;
                 }
 
                 bool safeToOptimize = true;
                 for (int index = 0; index < numConstructorArgs; ++index) {
                     int8_t constructorArgIndex = argMap[index].fArgIndex;
                     const Expression& baseArg = *base.arguments()[constructorArgIndex];
 
                     // Check that non-trivial expressions are not swizzled in more than once.
                     if (exprUsed[constructorArgIndex] > 1 &&
                             !Analysis::IsTrivialExpression(baseArg)) {
                         safeToOptimize = false;
                         break;
                     }
                     // Check that side-effect-bearing expressions are swizzled in exactly once.
                     if (exprUsed[constructorArgIndex] != 1 && baseArg.hasSideEffects()) {
                         safeToOptimize = false;
                         break;
                     }
                 }
 
                 if (safeToOptimize) {
                     struct ReorderedArgument {
                         int8_t fArgIndex;
                         ComponentArray fComponents;
                     };
                     SkSTArray<4, ReorderedArgument> reorderedArgs;
                     for (int c : s.components()) {
                         const ConstructorArgMap& argument = argMap[c];
                         const Expression& baseArg = *base.arguments()[argument.fArgIndex];
 
                         if (baseArg.type().isScalar()) {
                             // This argument is a scalar; add it to the list as-is.
                             SkASSERT(argument.fComponent == 0);
                             reorderedArgs.push_back({argument.fArgIndex,
                                                      ComponentArray{}});
                         } else {
                             // This argument is a component from a vector.
                             SkASSERT(argument.fComponent < baseArg.type().columns());
                             if (reorderedArgs.empty() ||
                                 reorderedArgs.back().fArgIndex != argument.fArgIndex) {
                                 // This can't be combined with the previous argument. Add a new one.
                                 reorderedArgs.push_back({argument.fArgIndex,
                                                          ComponentArray{argument.fComponent}});
                             } else {
                                 // Since we know this argument uses components, it should already
                                 // have at least one component set.
                                 SkASSERT(!reorderedArgs.back().fComponents.empty());
                                 // Build up the current argument with one more component.
                                 reorderedArgs.back().fComponents.push_back(argument.fComponent);
                             }
                         }
                     }
 
                     // Convert our reordered argument list to an actual array of expressions, with
                     // the new order and any new inner swizzles that need to be applied. Note that
                     // we expect followup passes to clean up the inner swizzles.
                     ExpressionArray newArgs;
                     newArgs.reserve_back(swizzleSize);
                     for (const ReorderedArgument& reorderedArg : reorderedArgs) {
                         const Expression& baseArg = *base.arguments()[reorderedArg.fArgIndex];
                         if (reorderedArg.fComponents.empty()) {
                             newArgs.push_back(baseArg.clone());
                         } else {
                             newArgs.push_back(std::make_unique<Swizzle>(*fContext, baseArg.clone(),
                                                                         reorderedArg.fComponents));
                         }
                     }
 
                     // Create a new constructor.
                     replacement = std::make_unique<Constructor>(
                             base.fOffset,
                             &componentType.toCompound(*fContext, swizzleSize, /*rows=*/1),
                             std::move(newArgs));
 
-                    // Remove references within 'expr', add references within 'optimized'
-                    optimizationContext->fUpdated = true;
+                    // Remove references within 'expr', add references within 'replacement.'
                     optimizationContext->fUsage->replace(expr, replacement.get());
-                    if (!try_replace_expression(&b, iter, &replacement)) {
-                        optimizationContext->fNeedsRescan = true;
-                        return;
-                    }
-                    SkASSERT((*iter)->isExpression());
+
+                    // We're replacing an expression with a cloned version; we'll need a rescan.
+                    try_replace_expression(&b, iter, &replacement);
+                    optimizationContext->fUpdated = true;
+                    optimizationContext->fNeedsRescan = true;
                 }
                 break;
             }
             break;
         }
         default:
             break;
     }
 }
 
 // Returns true if this statement could potentially execute a break at the current level. We ignore
 // nested loops and switches, since any breaks inside of them will merely break the loop / switch.
diff --git a/tests/sksl/shared/Ossfuzz28794.sksl b/tests/sksl/shared/Ossfuzz28794.sksl
new file mode 100644
index 0000000000..a4f1f20373
--- /dev/null
+++ b/tests/sksl/shared/Ossfuzz28794.sksl
@@ -0,0 +1,5 @@
+void main() {
+    int i = int(sqrt(1));
+    (i)*half4(i=3).x1.x;
+    sk_FragColor.x = half(i);
+}
diff --git a/tests/sksl/shared/golden/Ossfuzz28794.asm.frag b/tests/sksl/shared/golden/Ossfuzz28794.asm.frag
new file mode 100644
index 0000000000..eb69f48234
--- /dev/null
+++ b/tests/sksl/shared/golden/Ossfuzz28794.asm.frag
@@ -0,0 +1,46 @@
+OpCapability Shader
+%1 = OpExtInstImport "GLSL.std.450"
+OpMemoryModel Logical GLSL450
+OpEntryPoint Fragment %main "main" %sk_FragColor %sk_Clockwise
+OpExecutionMode %main OriginUpperLeft
+OpName %sk_FragColor "sk_FragColor"
+OpName %sk_Clockwise "sk_Clockwise"
+OpName %main "main"
+OpName %i "i"
+OpDecorate %sk_FragColor RelaxedPrecision
+OpDecorate %sk_FragColor Location 0
+OpDecorate %sk_FragColor Index 0
+OpDecorate %sk_Clockwise RelaxedPrecision
+OpDecorate %sk_Clockwise BuiltIn FrontFacing
+OpDecorate %23 RelaxedPrecision
+%float = OpTypeFloat 32
+%v4float = OpTypeVector %float 4
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+%sk_FragColor = OpVariable %_ptr_Output_v4float Output
+%bool = OpTypeBool
+%_ptr_Input_bool = OpTypePointer Input %bool
+%sk_Clockwise = OpVariable %_ptr_Input_bool Input
+%void = OpTypeVoid
+%11 = OpTypeFunction %void
+%int = OpTypeInt 32 1
+%_ptr_Function_int = OpTypePointer Function %int
+%float_1 = OpConstant %float 1
+%int_3 = OpConstant %int 3
+%float_3 = OpConstant %float 3
+%_ptr_Output_float = OpTypePointer Output %float
+%int_0 = OpConstant %int 0
+%main = OpFunction %void None %11
+%12 = OpLabel
+%i = OpVariable %_ptr_Function_int Function
+%17 = OpExtInst %float %1 Sqrt %float_1
+%16 = OpConvertFToS %int %17
+OpStore %i %16
+%20 = OpLoad %int %i
+%19 = OpConvertSToF %float %20
+OpStore %i %int_3
+%21 = OpConvertSToF %float %int_3
+%23 = OpFMul %float %19 %21
+%25 = OpAccessChain %_ptr_Output_float %sk_FragColor %int_0
+OpStore %25 %float_3
+OpReturn
+OpFunctionEnd
diff --git a/tests/sksl/shared/golden/Ossfuzz28794.glsl b/tests/sksl/shared/golden/Ossfuzz28794.glsl
new file mode 100644
index 0000000000..ae2b29b00d
--- /dev/null
+++ b/tests/sksl/shared/golden/Ossfuzz28794.glsl
@@ -0,0 +1,7 @@
+
+out vec4 sk_FragColor;
+void main() {
+    int i = int(sqrt(1.0));
+    float(i) * float(i = 3);
+    sk_FragColor.x = 3.0;
+}
diff --git a/tests/sksl/shared/golden/Ossfuzz28794.metal b/tests/sksl/shared/golden/Ossfuzz28794.metal
new file mode 100644
index 0000000000..7fac041176
--- /dev/null
+++ b/tests/sksl/shared/golden/Ossfuzz28794.metal
@@ -0,0 +1,16 @@
+#include <metal_stdlib>
+#include <simd/simd.h>
+using namespace metal;
+struct Inputs {
+};
+struct Outputs {
+    float4 sk_FragColor [[color(0)]];
+};
+fragment Outputs fragmentMain(Inputs _in [[stage_in]], bool _frontFacing [[front_facing]], float4 _fragCoord [[position]]) {
+    Outputs _outputStruct;
+    thread Outputs* _out = &_outputStruct;
+    int i = int(sqrt(1.0));
+    float(i) * float(i = 3);
+    _out->sk_FragColor.x = 3.0;
+    return *_out;
+}
