commit 4cf85073e634fc43bc3a09e2a3b70279bd0b5043
Author: Brian Osman <brianosman@google.com>
Date:   Thu Jan 14 14:18:10 2021 -0500

    Enforce (valid) array sizes in many more places
    
    Unsized arrays are now allowed in exactly one place: On the declaration
    of an interface block. This satisfies the one existing use-case, which
    is the gl_in (sk_in) declaration for geometry shaders. There is no other
    useful scenario, and most of our backends don't support them anyway.
    
    Several spots were using less strict checks when attaching sizes to
    arrays, allowing for zero or negative-sized arrays, so those are all
    fixed now.
    
    The existing tests that initialize arrays are still a problem, because
    Metal doesn't support that (neither does GLES2). Also, ArrayConstructors
    has gone from generating an error in the Vulkan backend, to invalid
    SPIR-V.
    
    Bug: skia:11013
    Bug: skia:11127
    Change-Id: Ib08dfe9aeec96bf605661665d6f166419d27e8bc
    Reviewed-on: https://skia-review.googlesource.com/c/skia/+/353817
    Commit-Queue: Brian Osman <brianosman@google.com>
    Reviewed-by: John Stiles <johnstiles@google.com>

diff --git a/gn/sksl_tests.gni b/gn/sksl_tests.gni
index e1124c3cbc..e64db8a974 100644
--- a/gn/sksl_tests.gni
+++ b/gn/sksl_tests.gni
@@ -68,103 +68,102 @@ sksl_fp_tests = [
 sksl_error_tests = [
   "$_tests/sksl/errors/ArgumentCountMismatch.sksl",
   "$_tests/sksl/errors/ArgumentMismatch.sksl",
   "$_tests/sksl/errors/ArgumentModifiers.sksl",
   "$_tests/sksl/errors/ArrayIndexOutOfRange.sksl",
   "$_tests/sksl/errors/ArrayReturnTypes.sksl",
   "$_tests/sksl/errors/ArrayTooManyDimensions.sksl",
   "$_tests/sksl/errors/ArrayUnspecifiedDimensions.sksl",
   "$_tests/sksl/errors/AssignmentTypeMismatch.sksl",
   "$_tests/sksl/errors/BadCaps.sksl",
   "$_tests/sksl/errors/BadFieldAccess.sksl",
   "$_tests/sksl/errors/BadIndex.sksl",
   "$_tests/sksl/errors/BadModifiers.sksl",
   "$_tests/sksl/errors/BinaryInvalidType.sksl",
   "$_tests/sksl/errors/BinaryTypeCoercion.sksl",
   "$_tests/sksl/errors/BinaryTypeMismatch.sksl",
   "$_tests/sksl/errors/BitShiftFloat.sksl",
   "$_tests/sksl/errors/BitShiftFloatMatrix.sksl",
   "$_tests/sksl/errors/BitShiftFloatVector.sksl",
   "$_tests/sksl/errors/BooleanArithmetic.sksl",
   "$_tests/sksl/errors/BreakOutsideLoop.sksl",
   "$_tests/sksl/errors/CallNonFunction.sksl",
   "$_tests/sksl/errors/CanExitWithoutReturningValue.sksl",
   "$_tests/sksl/errors/ConstructorArgumentCount.sksl",
   "$_tests/sksl/errors/ConstructorTypeMismatch.sksl",
   "$_tests/sksl/errors/ContinueOutsideLoop.sksl",
   "$_tests/sksl/errors/DivideByZero.sksl",
   "$_tests/sksl/errors/DoTypeMismatch.sksl",
   "$_tests/sksl/errors/DuplicateFunction.sksl",
   "$_tests/sksl/errors/DuplicateOutput.sksl",
   "$_tests/sksl/errors/DuplicateSymbol.sksl",
   "$_tests/sksl/errors/EnumValueMustBeConstInt.sksl",
   "$_tests/sksl/errors/ErrorsInDeadCode.sksl",
-  "$_tests/sksl/errors/FieldAfterRuntimeArray.sksl",
   "$_tests/sksl/errors/FloatRemainder.sksl",
   "$_tests/sksl/errors/ForTypeMismatch.sksl",
   "$_tests/sksl/errors/GenericArgumentMismatch.sksl",
   "$_tests/sksl/errors/IfTypeMismatch.sksl",
   "$_tests/sksl/errors/InVarWithInitializerExpression.sksl",
   "$_tests/sksl/errors/InterfaceBlockScope.sksl",
   "$_tests/sksl/errors/InterfaceBlockStorageModifiers.sksl",
   "$_tests/sksl/errors/InterfaceBlockWithNoMembers.sksl",
   "$_tests/sksl/errors/InvalidAssignment.sksl",
   "$_tests/sksl/errors/InvalidOutParams.sksl",
   "$_tests/sksl/errors/InvalidToken.sksl",
   "$_tests/sksl/errors/InvalidUnary.sksl",
   "$_tests/sksl/errors/MismatchedNumbers.sksl",
   "$_tests/sksl/errors/ModifiersInStruct.sksl",
   "$_tests/sksl/errors/OpaqueTypeAssignment.sksl",
   "$_tests/sksl/errors/OpaqueTypeConstruction.sksl",
   "$_tests/sksl/errors/OpaqueTypeInArray.sksl",
   "$_tests/sksl/errors/OpaqueTypeInInterfaceBlock.sksl",
   "$_tests/sksl/errors/OpaqueTypeInStruct.sksl",
   "$_tests/sksl/errors/OpenArray.sksl",
   "$_tests/sksl/errors/Ossfuzz26700.sksl",
   "$_tests/sksl/errors/Ossfuzz26759.sksl",
   "$_tests/sksl/errors/Ossfuzz27650.sksl",
   "$_tests/sksl/errors/Ossfuzz27663.sksl",
   "$_tests/sksl/errors/Ossfuzz29085.sksl",
   "$_tests/sksl/errors/OverflowFloatLiteral.sksl",
   "$_tests/sksl/errors/OverflowIntLiteral.sksl",
   "$_tests/sksl/errors/OverflowParamArraySize.sksl",
   "$_tests/sksl/errors/OverflowUintLiteral.sksl",
   "$_tests/sksl/errors/PrivateTypes.sksl",
   "$_tests/sksl/errors/RedeclareBasicType.sksl",
   "$_tests/sksl/errors/RedeclareEnum.sksl",
   "$_tests/sksl/errors/RedeclareSamplerType.sksl",
   "$_tests/sksl/errors/RedeclareStruct.sksl",
   "$_tests/sksl/errors/RedeclareStructTypeWithName.sksl",
   "$_tests/sksl/errors/RedeclareUserType.sksl",
   "$_tests/sksl/errors/RedeclareVariable.sksl",
   "$_tests/sksl/errors/ReturnDifferentType.sksl",
   "$_tests/sksl/errors/ReturnFromVoid.sksl",
   "$_tests/sksl/errors/ReturnMissingValue.sksl",
   "$_tests/sksl/errors/ReturnTypeMismatch.sksl",
   "$_tests/sksl/errors/SelfReferentialInitializerExpression.sksl",
   "$_tests/sksl/errors/SpuriousFloat.sksl",
   "$_tests/sksl/errors/StaticIfTest.sksl",
   "$_tests/sksl/errors/StaticSwitchConditionalBreak.sksl",
   "$_tests/sksl/errors/StaticSwitchTest.sksl",
   "$_tests/sksl/errors/StructTooDeeplyNested.sksl",
   "$_tests/sksl/errors/SwitchDuplicateCase.sksl",
   "$_tests/sksl/errors/SwitchTypes.sksl",
   "$_tests/sksl/errors/SwizzleConstantOutput.sksl",
   "$_tests/sksl/errors/SwizzleMatrix.sksl",
   "$_tests/sksl/errors/SwizzleOnlyLiterals.sksl",
   "$_tests/sksl/errors/SwizzleOutOfBounds.sksl",
   "$_tests/sksl/errors/SwizzleTooManyComponents.sksl",
   "$_tests/sksl/errors/TernaryMismatch.sksl",
   "$_tests/sksl/errors/UndeclaredFunction.sksl",
   "$_tests/sksl/errors/UndefinedFunction.sksl",
   "$_tests/sksl/errors/UndefinedSymbol.sksl",
   "$_tests/sksl/errors/Unreachable.sksl",
   "$_tests/sksl/errors/UnsupportedGLSLIdentifiers.sksl",
   "$_tests/sksl/errors/UseWithoutInitializeArrayIndex.sksl",
   "$_tests/sksl/errors/UseWithoutInitializeBinaryExpr.sksl",
   "$_tests/sksl/errors/UseWithoutInitializeDeadIf.sksl",
   "$_tests/sksl/errors/UseWithoutInitializeDeadSwitch.sksl",
   "$_tests/sksl/errors/UseWithoutInitializeReturnValue.sksl",
   "$_tests/sksl/errors/UseWithoutInitializeVarDecl.sksl",
   "$_tests/sksl/errors/UsingInvalidValue.sksl",
   "$_tests/sksl/errors/WhileTypeMismatch.sksl",
 ]
diff --git a/src/sksl/SkSLIRGenerator.cpp b/src/sksl/SkSLIRGenerator.cpp
index 80d1e5a2eb..4034376841 100644
--- a/src/sksl/SkSLIRGenerator.cpp
+++ b/src/sksl/SkSLIRGenerator.cpp
@@ -262,200 +262,203 @@ std::unique_ptr<Statement> IRGenerator::convertVarDeclarationStatement(const AST
     }
 }
 
+int IRGenerator::convertArraySize(int offset, const ASTNode& s) {
+    if (!s) {
+        this->errorReporter().error(offset, "array must have a size");
+        return 0;
+    }
+    auto size = this->coerce(this->convertExpression(s), *fContext.fTypes.fInt);
+    if (!size) {
+        return 0;
+    }
+    if (!size->is<IntLiteral>()) {
+        this->errorReporter().error(size->fOffset, "array size must be an integer");
+        return 0;
+    }
+    SKSL_INT count = size->as<IntLiteral>().value();
+    if (count <= 0) {
+        this->errorReporter().error(size->fOffset, "array size must be positive");
+        return 0;
+    }
+    if (!SkTFitsIn<int>(count)) {
+        this->errorReporter().error(size->fOffset, "array size is too large");
+        return 0;
+    }
+    return static_cast<int>(count);
+}
+
 StatementArray IRGenerator::convertVarDeclarations(const ASTNode& decls,
                                                    Variable::Storage storage) {
     SkASSERT(decls.fKind == ASTNode::Kind::kVarDeclarations);
     auto declarationsIter = decls.begin();
     const Modifiers& modifiers = declarationsIter++->getModifiers();
     const ASTNode& rawType = *(declarationsIter++);
     const Type* baseType = this->convertType(rawType);
     if (!baseType) {
         return {};
     }
     if (baseType->componentType().isOpaque() && storage != Variable::Storage::kGlobal) {
         this->errorReporter().error(
                 decls.fOffset,
                 "variables of type '" + baseType->displayName() + "' must be global");
     }
     if (fKind != Program::kFragmentProcessor_Kind) {
         if ((modifiers.fFlags & Modifiers::kIn_Flag) && baseType->isMatrix()) {
             this->errorReporter().error(decls.fOffset, "'in' variables may not have matrix type");
         }
         if ((modifiers.fFlags & Modifiers::kIn_Flag) &&
             (modifiers.fFlags & Modifiers::kUniform_Flag)) {
             this->errorReporter().error(
                     decls.fOffset,
                     "'in uniform' variables only permitted within fragment processors");
         }
         if (modifiers.fLayout.fWhen.fLength) {
             this->errorReporter().error(decls.fOffset,
                                         "'when' is only permitted within fragment processors");
         }
         if (modifiers.fLayout.fFlags & Layout::kTracked_Flag) {
             this->errorReporter().error(decls.fOffset,
                                         "'tracked' is only permitted within fragment processors");
         }
         if (modifiers.fLayout.fCType != Layout::CType::kDefault) {
             this->errorReporter().error(decls.fOffset,
                                         "'ctype' is only permitted within fragment processors");
         }
         if (modifiers.fLayout.fKey) {
             this->errorReporter().error(decls.fOffset,
                                         "'key' is only permitted within fragment processors");
         }
     }
     if (fKind == Program::kRuntimeEffect_Kind) {
         if ((modifiers.fFlags & Modifiers::kIn_Flag) &&
             *baseType != *fContext.fTypes.fFragmentProcessor) {
             this->errorReporter().error(decls.fOffset,
                                         "'in' variables not permitted in runtime effects");
         }
     }
     if (modifiers.fLayout.fKey && (modifiers.fFlags & Modifiers::kUniform_Flag)) {
         this->errorReporter().error(decls.fOffset, "'key' is not permitted on 'uniform' variables");
     }
     if (modifiers.fLayout.fMarker.fLength) {
         if (fKind != Program::kRuntimeEffect_Kind) {
             this->errorReporter().error(decls.fOffset,
                                         "'marker' is only permitted in runtime effects");
         }
         if (!(modifiers.fFlags & Modifiers::kUniform_Flag)) {
             this->errorReporter().error(decls.fOffset,
                                         "'marker' is only permitted on 'uniform' variables");
         }
         if (*baseType != *fContext.fTypes.fFloat4x4) {
             this->errorReporter().error(decls.fOffset,
                                         "'marker' is only permitted on float4x4 variables");
         }
     }
     if (modifiers.fLayout.fFlags & Layout::kSRGBUnpremul_Flag) {
         if (fKind != Program::kRuntimeEffect_Kind) {
             this->errorReporter().error(decls.fOffset,
                                         "'srgb_unpremul' is only permitted in runtime effects");
         }
         if (!(modifiers.fFlags & Modifiers::kUniform_Flag)) {
             this->errorReporter().error(decls.fOffset,
                                         "'srgb_unpremul' is only permitted on 'uniform' variables");
         }
         auto validColorXformType = [](const Type& t) {
             return t.isVector() && t.componentType().isFloat() &&
                    (t.columns() == 3 || t.columns() == 4);
         };
         if (!validColorXformType(*baseType) && !(baseType->isArray() &&
                                                  validColorXformType(baseType->componentType()))) {
             this->errorReporter().error(decls.fOffset,
                                         "'srgb_unpremul' is only permitted on half3, half4, "
                                         "float3, or float4 variables");
         }
     }
     if (modifiers.fFlags & Modifiers::kVarying_Flag) {
         if (fKind != Program::kRuntimeEffect_Kind) {
             this->errorReporter().error(decls.fOffset,
                                         "'varying' is only permitted in runtime effects");
         }
         if (!baseType->isFloat() &&
             !(baseType->isVector() && baseType->componentType().isFloat())) {
             this->errorReporter().error(decls.fOffset, "'varying' must be float scalar or vector");
         }
     }
     int permitted = Modifiers::kConst_Flag;
     if (storage == Variable::Storage::kGlobal) {
         permitted |= Modifiers::kIn_Flag | Modifiers::kOut_Flag | Modifiers::kUniform_Flag |
                      Modifiers::kFlat_Flag | Modifiers::kVarying_Flag |
                      Modifiers::kNoPerspective_Flag | Modifiers::kPLS_Flag |
                      Modifiers::kPLSIn_Flag | Modifiers::kPLSOut_Flag |
                      Modifiers::kRestrict_Flag | Modifiers::kVolatile_Flag |
                      Modifiers::kReadOnly_Flag | Modifiers::kWriteOnly_Flag |
                      Modifiers::kCoherent_Flag | Modifiers::kBuffer_Flag;
     }
     this->checkModifiers(decls.fOffset, modifiers, permitted);
 
     StatementArray varDecls;
     for (; declarationsIter != decls.end(); ++declarationsIter) {
         const ASTNode& varDecl = *declarationsIter;
         if (modifiers.fLayout.fLocation == 0 && modifiers.fLayout.fIndex == 0 &&
             (modifiers.fFlags & Modifiers::kOut_Flag) && fKind == Program::kFragment_Kind &&
             varDecl.getVarData().fName != "sk_FragColor") {
             this->errorReporter().error(varDecl.fOffset,
                                         "out location=0, index=0 is reserved for sk_FragColor");
         }
         const ASTNode::VarData& varData = varDecl.getVarData();
         const Type* type = baseType;
         int arraySize = 0;
         auto iter = varDecl.begin();
         if (iter != varDecl.end()) {
             if (varData.fIsArray) {
                 if (type->isOpaque()) {
                     this->errorReporter().error(
                             varDecl.fOffset,
                             "opaque type '" + type->name() + "' may not be used in an array");
                 }
                 const ASTNode& rawSize = *iter++;
-                if (rawSize) {
-                    auto size = this->coerce(this->convertExpression(rawSize),
-                                             *fContext.fTypes.fInt);
-                    if (!size) {
-                        return {};
-                    }
-                    if (!size->is<IntLiteral>()) {
-                        this->errorReporter().error(size->fOffset, "array size must be an integer");
-                        return {};
-                    }
-                    SKSL_INT count = size->as<IntLiteral>().value();
-                    if (count <= 0) {
-                        this->errorReporter().error(size->fOffset, "array size must be positive");
-                        return {};
-                    }
-                    arraySize = count;
-                } else {
-                    arraySize = Type::kUnsizedArray;
+                arraySize = this->convertArraySize(varDecl.fOffset, rawSize);
+                if (!arraySize) {
+                    return {};
                 }
                 type = fSymbolTable->addArrayDimension(type, arraySize);
             }
         }
         auto var = std::make_unique<Variable>(varDecl.fOffset, fModifiers->addToPool(modifiers),
                                               varData.fName, type, fIsBuiltinCode, storage);
         if (var->name() == Compiler::RTADJUST_NAME) {
             SkASSERT(!fRTAdjust);
             SkASSERT(var->type() == *fContext.fTypes.fFloat4);
             fRTAdjust = var.get();
         }
         std::unique_ptr<Expression> value;
-        if (iter == varDecl.end()) {
-            if (arraySize == Type::kUnsizedArray) {
-                this->errorReporter().error(
-                        varDecl.fOffset,
-                        "arrays without an explicit size must use an initializer expression");
-                return {};
-            }
-        } else {
+        if (iter != varDecl.end()) {
             value = this->convertExpression(*iter);
             if (!value) {
                 return {};
             }
             if (type->isOpaque()) {
                 this->errorReporter().error(
                         value->fOffset,
                         "opaque type '" + type->name() + "' cannot use initializer expressions");
             }
             if (modifiers.fFlags & Modifiers::kIn_Flag) {
                 this->errorReporter().error(value->fOffset,
                                             "'in' variables cannot use initializer expressions");
             }
             value = this->coerce(std::move(value), *type);
             if (!value) {
                 return {};
             }
             var->setInitialValue(value.get());
         }
         const Symbol* symbol = (*fSymbolTable)[var->name()];
         if (symbol && storage == Variable::Storage::kGlobal && var->name() == "sk_FragColor") {
             // Already defined, ignore.
         } else {
             varDecls.push_back(std::make_unique<VarDeclaration>(var.get(), baseType, arraySize,
                                                                 std::move(value)));
             fSymbolTable->add(std::move(var));
         }
     }
     return varDecls;
 }
@@ -935,231 +938,234 @@ void IRGenerator::checkModifiers(int offset, const Modifiers& modifiers, int per
 void IRGenerator::convertFunction(const ASTNode& f) {
     AutoClear clear(&fReferencedIntrinsics);
     auto iter = f.begin();
     const Type* returnType = this->convertType(*(iter++), /*allowVoid=*/true);
     if (returnType == nullptr) {
         return;
     }
     auto typeIsAllowed = [&](const Type* t) {
 #if defined(SKSL_STANDALONE)
         return true;
 #else
         GrSLType unusedSLType;
         return fKind != Program::kRuntimeEffect_Kind ||
                type_to_grsltype(fContext, *t, &unusedSLType);
 #endif
     };
     if (returnType->isArray() || !typeIsAllowed(returnType)) {
         this->errorReporter().error(
                 f.fOffset, "functions may not return type '" + returnType->displayName() + "'");
         return;
     }
     if (!fIsBuiltinCode && *returnType != *fContext.fTypes.fVoid &&
         returnType->componentType().isOpaque()) {
         this->errorReporter().error(
                 f.fOffset,
                 "functions may not return opaque type '" + returnType->displayName() + "'");
         return;
     }
     const ASTNode::FunctionData& funcData = f.getFunctionData();
     this->checkModifiers(f.fOffset, funcData.fModifiers, Modifiers::kHasSideEffects_Flag |
                                                          Modifiers::kInline_Flag);
     std::vector<const Variable*> parameters;
     for (size_t i = 0; i < funcData.fParameterCount; ++i) {
         const ASTNode& param = *(iter++);
         SkASSERT(param.fKind == ASTNode::Kind::kParameter);
         ASTNode::ParameterData pd = param.getParameterData();
         this->checkModifiers(param.fOffset, pd.fModifiers, Modifiers::kIn_Flag |
                                                            Modifiers::kOut_Flag);
         auto paramIter = param.begin();
         const Type* type = this->convertType(*(paramIter++));
         if (!type) {
             return;
         }
         if (pd.fIsArray) {
-            int arraySize = (paramIter++)->getInt();
+            int arraySize = this->convertArraySize(param.fOffset, *paramIter++);
+            if (!arraySize) {
+                return;
+            }
             type = fSymbolTable->addArrayDimension(type, arraySize);
         }
         // Only the (builtin) declarations of 'sample' are allowed to have FP parameters.
         // (You can pass other opaque types to functions safely; this restriction is
         // fragment-processor specific.)
         if ((*type == *fContext.fTypes.fFragmentProcessor && !fIsBuiltinCode) ||
             !typeIsAllowed(type)) {
             this->errorReporter().error(
                     param.fOffset, "parameters of type '" + type->displayName() + "' not allowed");
             return;
         }
 
         Modifiers m = pd.fModifiers;
         if (funcData.fName == "main" && (fKind == Program::kRuntimeEffect_Kind ||
                                          fKind == Program::kFragmentProcessor_Kind)) {
             if (i == 0) {
                 // We verify that the type is correct later, for now, if there is a parameter to
                 // a .fp or runtime-effect main(), it's supposed to be the coords:
                 m.fLayout.fBuiltin = SK_MAIN_COORDS_BUILTIN;
             }
         }
 
         const Variable* var = fSymbolTable->takeOwnershipOfSymbol(
                 std::make_unique<Variable>(param.fOffset, fModifiers->addToPool(m), pd.fName, type,
                                            fIsBuiltinCode, Variable::Storage::kParameter));
         parameters.push_back(var);
     }
 
     auto paramIsCoords = [&](int idx) {
         return parameters[idx]->type() == *fContext.fTypes.fFloat2 &&
                parameters[idx]->modifiers().fFlags == 0 &&
                parameters[idx]->modifiers().fLayout.fBuiltin == SK_MAIN_COORDS_BUILTIN;
     };
 
     if (funcData.fName == "main") {
         switch (fKind) {
             case Program::kRuntimeEffect_Kind: {
                 // (half4|float4) main()  -or-  (half4|float4) main(float2)
                 if (*returnType != *fContext.fTypes.fHalf4 &&
                     *returnType != *fContext.fTypes.fFloat4) {
                     this->errorReporter().error(f.fOffset,
                                                 "'main' must return: 'vec4', 'float4', or 'half4'");
                     return;
                 }
                 bool validParams = (parameters.size() == 0) ||
                                    (parameters.size() == 1 && paramIsCoords(0));
                 if (!validParams) {
                     this->errorReporter().error(
                             f.fOffset, "'main' parameters must be: (), (vec2), or (float2)");
                     return;
                 }
                 break;
             }
             case Program::kFragmentProcessor_Kind: {
                 if (*returnType != *fContext.fTypes.fHalf4) {
                     this->errorReporter().error(f.fOffset, ".fp 'main' must return 'half4'");
                     return;
                 }
                 bool validParams = (parameters.size() == 0) ||
                                    (parameters.size() == 1 && paramIsCoords(0));
                 if (!validParams) {
                     this->errorReporter().error(
                             f.fOffset, ".fp 'main' must be declared main() or main(float2)");
                     return;
                 }
                 break;
             }
             case Program::kGeneric_Kind:
                 break;
             default:
                 if (parameters.size()) {
                     this->errorReporter().error(f.fOffset, "shader 'main' must have zero parameters");
                 }
                 break;
         }
     }
 
     // find existing declaration
     const FunctionDeclaration* decl = nullptr;
     const Symbol* entry = (*fSymbolTable)[funcData.fName];
     if (entry) {
         std::vector<const FunctionDeclaration*> functions;
         switch (entry->kind()) {
             case Symbol::Kind::kUnresolvedFunction:
                 functions = entry->as<UnresolvedFunction>().functions();
                 break;
             case Symbol::Kind::kFunctionDeclaration:
                 functions.push_back(&entry->as<FunctionDeclaration>());
                 break;
             default:
                 this->errorReporter().error(f.fOffset,
                                             "symbol '" + funcData.fName + "' was already defined");
                 return;
         }
         for (const FunctionDeclaration* other : functions) {
             SkASSERT(other->name() == funcData.fName);
             if (parameters.size() == other->parameters().size()) {
                 bool match = true;
                 for (size_t i = 0; i < parameters.size(); i++) {
                     if (parameters[i]->type() != other->parameters()[i]->type()) {
                         match = false;
                         break;
                     }
                 }
                 if (match) {
                     if (*returnType != other->returnType()) {
                         FunctionDeclaration newDecl(f.fOffset,
                                                     fModifiers->addToPool(funcData.fModifiers),
                                                     funcData.fName,
                                                     parameters,
                                                     returnType,
                                                     fIsBuiltinCode);
                         this->errorReporter().error(
                                 f.fOffset, "functions '" + newDecl.description() + "' and '" +
                                            other->description() + "' differ only in return type");
                         return;
                     }
                     decl = other;
                     for (size_t i = 0; i < parameters.size(); i++) {
                         if (parameters[i]->modifiers() != other->parameters()[i]->modifiers()) {
                             this->errorReporter().error(
                                     f.fOffset,
                                     "modifiers on parameter " + to_string((uint64_t)i + 1) +
                                             " differ between declaration and definition");
                             return;
                         }
                     }
                     if (other->definition() && !other->isBuiltin()) {
                         this->errorReporter().error(
                                 f.fOffset, "duplicate definition of " + other->description());
                         return;
                     }
                     break;
                 }
             }
         }
     }
     if (!decl) {
         // Conservatively assume all user-defined functions have side effects.
         Modifiers declModifiers = funcData.fModifiers;
         if (!fIsBuiltinCode) {
             declModifiers.fFlags |= Modifiers::kHasSideEffects_Flag;
         }
 
         // Create a new declaration.
         decl = fSymbolTable->add(
                 std::make_unique<FunctionDeclaration>(f.fOffset,
                                                       fModifiers->addToPool(declModifiers),
                                                       funcData.fName,
                                                       parameters,
                                                       returnType,
                                                       fIsBuiltinCode));
     }
     if (iter == f.end()) {
         // If there's no body, we've found a prototype.
         fProgramElements->push_back(std::make_unique<FunctionPrototype>(f.fOffset, decl,
                                                                         fIsBuiltinCode));
     } else {
         // Compile function body.
         SkASSERT(!fCurrentFunction);
         fCurrentFunction = decl;
 
         AutoSymbolTable table(this);
         for (const Variable* param : decl->parameters()) {
             fSymbolTable->addWithoutOwnership(param);
         }
         bool needInvocationIDWorkaround = fInvocations != -1 && funcData.fName == "main" &&
                                           fCaps && !fCaps->gsInvocationsSupport();
         std::unique_ptr<Block> body = this->convertBlock(*iter);
         fCurrentFunction = nullptr;
         if (!body) {
             return;
         }
         if (needInvocationIDWorkaround) {
             body = this->applyInvocationIDWorkaround(std::move(body));
         }
         if (Program::kVertex_Kind == fKind && funcData.fName == "main" && fRTAdjust) {
             body->children().push_back(this->getNormalizeSkPositionCode());
         }
         auto result = std::make_unique<FunctionDefinition>(
                 f.fOffset, decl, fIsBuiltinCode, std::move(body), std::move(fReferencedIntrinsics));
         decl->setDefinition(result.get());
         result->setSource(&f);
         fProgramElements->push_back(std::move(result));
     }
 }
@@ -1182,104 +1188,88 @@ std::unique_ptr<StructDefinition> IRGenerator::convertStructDefinition(const AST
 std::unique_ptr<InterfaceBlock> IRGenerator::convertInterfaceBlock(const ASTNode& intf) {
     if (fKind != Program::kFragment_Kind &&
         fKind != Program::kVertex_Kind &&
         fKind != Program::kGeometry_Kind) {
         this->errorReporter().error(intf.fOffset, "interface block is not allowed here");
         return nullptr;
     }
 
     SkASSERT(intf.fKind == ASTNode::Kind::kInterfaceBlock);
     ASTNode::InterfaceBlockData id = intf.getInterfaceBlockData();
     std::shared_ptr<SymbolTable> old = fSymbolTable;
     std::shared_ptr<SymbolTable> symbols;
     std::vector<Type::Field> fields;
     bool foundRTAdjust = false;
     auto iter = intf.begin();
     {
         AutoSymbolTable table(this);
         symbols = fSymbolTable;
-        bool haveRuntimeArray = false;
         for (size_t i = 0; i < id.fDeclarationCount; ++i) {
             StatementArray decls = this->convertVarDeclarations(*(iter++),
                                                                 Variable::Storage::kInterfaceBlock);
             if (decls.empty()) {
                 return nullptr;
             }
             for (const auto& decl : decls) {
                 const VarDeclaration& vd = decl->as<VarDeclaration>();
                 if (vd.var().type().isOpaque()) {
                     this->errorReporter().error(decl->fOffset,
                                                 "opaque type '" + vd.var().type().name() +
                                                         "' is not permitted in an interface block");
                 }
-                if (haveRuntimeArray) {
-                    this->errorReporter().error(decl->fOffset,
-                                                "only the last entry in an interface block may be "
-                                                "a runtime-sized array");
-                }
                 if (&vd.var() == fRTAdjust) {
                     foundRTAdjust = true;
                     SkASSERT(vd.var().type() == *fContext.fTypes.fFloat4);
                     fRTAdjustFieldIndex = fields.size();
                 }
                 fields.push_back(Type::Field(vd.var().modifiers(), vd.var().name(),
                                             &vd.var().type()));
                 if (vd.value()) {
                     this->errorReporter().error(
                             decl->fOffset,
                             "initializers are not permitted on interface block fields");
                 }
-                if (vd.var().type().isArray() &&
-                    vd.var().type().columns() == Type::kUnsizedArray) {
-                    haveRuntimeArray = true;
-                }
             }
         }
     }
     const Type* type = old->takeOwnershipOfSymbol(Type::MakeStructType(intf.fOffset, id.fTypeName,
                                                                        fields));
     int arraySize = 0;
     if (id.fIsArray) {
         const ASTNode& size = *(iter++);
         if (size) {
-            std::unique_ptr<Expression> converted = this->convertExpression(size);
-            if (!converted) {
-                return nullptr;
-            }
-            if (!converted->is<IntLiteral>()) {
-                this->errorReporter().error(intf.fOffset, "array size must be specified");
-                return nullptr;
-            }
-            arraySize = converted->as<IntLiteral>().value();
-            if (arraySize <= 0) {
-                this->errorReporter().error(converted->fOffset, "array size must be positive");
+            // convertArraySize rejects unsized arrays. This is the one place we allow those, but
+            // we've already checked for that, so this is verifying the other aspects (constant,
+            // positive, not too large).
+            arraySize = this->convertArraySize(size.fOffset, size);
+            if (!arraySize) {
                 return nullptr;
             }
         } else {
             arraySize = Type::kUnsizedArray;
         }
         type = symbols->addArrayDimension(type, arraySize);
     }
     const Variable* var = old->takeOwnershipOfSymbol(
             std::make_unique<Variable>(intf.fOffset,
                                        fModifiers->addToPool(id.fModifiers),
                                        id.fInstanceName.fLength ? id.fInstanceName : id.fTypeName,
                                        type,
                                        fIsBuiltinCode,
                                        Variable::Storage::kGlobal));
     if (foundRTAdjust) {
         fRTAdjustInterfaceBlock = var;
     }
     if (id.fInstanceName.fLength) {
         old->addWithoutOwnership(var);
     } else {
         for (size_t i = 0; i < fields.size(); i++) {
             old->add(std::make_unique<Field>(intf.fOffset, var, (int)i));
         }
     }
     return std::make_unique<InterfaceBlock>(intf.fOffset,
                                             var,
                                             id.fTypeName,
                                             id.fInstanceName,
                                             arraySize,
                                             symbols);
 }
@@ -1372,37 +1362,40 @@ bool IRGenerator::typeContainsPrivateFields(const Type& type) {
 const Type* IRGenerator::convertType(const ASTNode& type, bool allowVoid) {
     ASTNode::TypeData td = type.getTypeData();
     const Symbol* symbol = (*fSymbolTable)[td.fName];
     if (!symbol || !symbol->is<Type>()) {
         this->errorReporter().error(type.fOffset, "unknown type '" + td.fName + "'");
         return nullptr;
     }
     const Type* result = &symbol->as<Type>();
     const bool isArray = (type.begin() != type.end());
     if (*result == *fContext.fTypes.fVoid) {
         if (!allowVoid) {
             this->errorReporter().error(type.fOffset,
                                         "type '" + td.fName + "' not allowed in this context");
             return nullptr;
         }
         if (isArray) {
             this->errorReporter().error(type.fOffset,
                                         "type '" + td.fName + "' may not be used in an array");
             return nullptr;
         }
     }
     if (!fIsBuiltinCode && this->typeContainsPrivateFields(*result)) {
         this->errorReporter().error(type.fOffset, "type '" + td.fName + "' is private");
         return nullptr;
     }
     if (isArray && result->isOpaque()) {
         this->errorReporter().error(type.fOffset,
                                     "opaque type '" + td.fName + "' may not be used in an array");
         return nullptr;
     }
     if (isArray) {
         auto iter = type.begin();
-        int arraySize = *iter ? iter->getInt() : Type::kUnsizedArray;
+        int arraySize = this->convertArraySize(type.fOffset, *iter);
+        if (!arraySize) {
+            return nullptr;
+        }
         result = fSymbolTable->addArrayDimension(result, arraySize);
     }
     return result;
 }
@@ -2610,76 +2603,70 @@ std::unique_ptr<Expression> IRGenerator::convertTypeField(int offset, const Type
 std::unique_ptr<Expression> IRGenerator::convertIndexExpression(const ASTNode& index) {
     SkASSERT(index.fKind == ASTNode::Kind::kIndex);
     auto iter = index.begin();
     std::unique_ptr<Expression> base = this->convertExpression(*(iter++));
     if (!base) {
         return nullptr;
     }
+    if (base->is<TypeReference>()) {
+        // Convert an index expression starting with a type name: `int[12]`
+        if (iter == index.end()) {
+            this->errorReporter().error(index.fOffset, "array must have a size");
+            return nullptr;
+        }
+        int arraySize = this->convertArraySize(index.fOffset, *iter);
+        if (!arraySize) {
+            return nullptr;
+        }
+        const Type* type = &base->as<TypeReference>().value();
+        type = fSymbolTable->addArrayDimension(type, arraySize);
+        return std::make_unique<TypeReference>(fContext, base->fOffset, type);
+    }
+
     if (iter == index.end()) {
-        return this->convertEmptyIndex(std::move(base));
+        this->errorReporter().error(base->fOffset, "missing index in '[]'");
+        return nullptr;
     }
     std::unique_ptr<Expression> converted = this->convertExpression(*(iter++));
     if (!converted) {
         return nullptr;
     }
     return this->convertIndex(std::move(base), std::move(converted));
 }
 
-std::unique_ptr<Expression> IRGenerator::convertEmptyIndex(std::unique_ptr<Expression> base) {
-    // Convert an index expression with nothing inside of it: `float[]`.
-    if (base->is<TypeReference>()) {
-        const Type* type = &base->as<TypeReference>().value();
-        type = fSymbolTable->addArrayDimension(type, Type::kUnsizedArray);
-        return std::make_unique<TypeReference>(fContext, base->fOffset, type);
-    }
-    this->errorReporter().error(base->fOffset, "'[]' must follow a type name");
-    return nullptr;
-}
-
 std::unique_ptr<Expression> IRGenerator::convertIndex(std::unique_ptr<Expression> base,
                                                       std::unique_ptr<Expression> index) {
-    // Convert an index expression with an expression inside of it: `int[12]` or `arr[a * 3]`.
-    if (base->is<TypeReference>()) {
-        if (index->is<IntLiteral>()) {
-            const Type* type = &base->as<TypeReference>().value();
-            type = fSymbolTable->addArrayDimension(type, index->as<IntLiteral>().value());
-            return std::make_unique<TypeReference>(fContext, base->fOffset, type);
-
-        } else {
-            this->errorReporter().error(base->fOffset, "array size must be a constant");
-            return nullptr;
-        }
-    }
+    // Convert an index expression with an expression inside of it: `arr[a * 3]`.
     const Type& baseType = base->type();
     if (!baseType.isArray() && !baseType.isMatrix() && !baseType.isVector()) {
         this->errorReporter().error(base->fOffset,
                                     "expected array, but found '" + baseType.displayName() + "'");
         return nullptr;
     }
     if (!index->type().isInteger()) {
         index = this->coerce(std::move(index), *fContext.fTypes.fInt);
         if (!index) {
             return nullptr;
         }
     }
     // Perform compile-time bounds checking on constant indices.
     if (index->is<IntLiteral>()) {
         SKSL_INT indexValue = index->as<IntLiteral>().value();
 
         const int upperBound = (baseType.isArray() && baseType.columns() == Type::kUnsizedArray)
                                        ? INT_MAX
                                        : baseType.columns();
         if (indexValue < 0 || indexValue >= upperBound) {
             this->errorReporter().error(base->fOffset, "index " + to_string(indexValue) +
                                                        " out of range for '" +
                                                        baseType.displayName() + "'");
             return nullptr;
         }
         // Constant array indexes on vectors can be converted to swizzles: `myHalf4.z`.
         // (Using a swizzle gives our optimizer a bit more to work with, compared to array indices.)
         if (baseType.isVector()) {
             return std::make_unique<Swizzle>(fContext, std::move(base),
                                              ComponentArray{(int8_t)indexValue});
         }
     }
     return std::make_unique<IndexExpression>(fContext, std::move(base), std::move(index));
 }
diff --git a/src/sksl/SkSLIRGenerator.h b/src/sksl/SkSLIRGenerator.h
index 9b5aa6a13f..27ecad99d8 100644
--- a/src/sksl/SkSLIRGenerator.h
+++ b/src/sksl/SkSLIRGenerator.h
@@ -149,143 +149,143 @@ public:
 private:
     /**
      * Relinquishes ownership of the Modifiers that have been collected so far and returns them.
      */
     std::unique_ptr<ModifiersPool> releaseModifiers();
 
     void checkModifiers(int offset, const Modifiers& modifiers, int permitted);
     StatementArray convertVarDeclarations(const ASTNode& decl, Variable::Storage storage);
     void convertFunction(const ASTNode& f);
     std::unique_ptr<Statement> convertSingleStatement(const ASTNode& statement);
     std::unique_ptr<Statement> convertStatement(const ASTNode& statement);
     std::unique_ptr<Expression> convertExpression(const ASTNode& expression);
     std::unique_ptr<ModifiersDeclaration> convertModifiersDeclaration(const ASTNode& m);
 
     const Type* convertType(const ASTNode& type, bool allowVoid = false);
     std::unique_ptr<Expression> call(int offset,
                                      std::unique_ptr<Expression> function,
                                      ExpressionArray arguments);
     std::unique_ptr<Expression> call(int offset,
                                      const FunctionDeclaration& function,
                                      ExpressionArray arguments);
     CoercionCost callCost(const FunctionDeclaration& function,
                           const ExpressionArray& arguments);
     std::unique_ptr<Expression> coerce(std::unique_ptr<Expression> expr, const Type& type);
     CoercionCost coercionCost(const Expression& expr, const Type& type);
+    int convertArraySize(int offset, const ASTNode& s);
     std::unique_ptr<Expression> convertBinaryExpression(std::unique_ptr<Expression> left,
                                                         Token::Kind op,
                                                         std::unique_ptr<Expression> right);
     std::unique_ptr<Block> convertBlock(const ASTNode& block);
     std::unique_ptr<Statement> convertBreak(const ASTNode& b);
     std::unique_ptr<Expression> convertScalarConstructor(int offset,
                                                          const Type& type,
                                                          ExpressionArray params);
     std::unique_ptr<Expression> convertCompoundConstructor(int offset,
                                                            const Type& type,
                                                            ExpressionArray params);
     std::unique_ptr<Expression> convertConstructor(int offset,
                                                    const Type& type,
                                                    ExpressionArray params);
     std::unique_ptr<Statement> convertContinue(const ASTNode& c);
     std::unique_ptr<Statement> convertDiscard(const ASTNode& d);
     std::unique_ptr<Statement> convertDo(const ASTNode& d);
     std::unique_ptr<Statement> convertSwitch(const ASTNode& s);
     std::unique_ptr<Expression> convertBinaryExpression(const ASTNode& expression);
     std::unique_ptr<Extension> convertExtension(int offset, StringFragment name);
     std::unique_ptr<Statement> convertExpressionStatement(const ASTNode& s);
     std::unique_ptr<Expression> convertField(std::unique_ptr<Expression> base,
                                              StringFragment field);
     std::unique_ptr<Statement> convertFor(const ASTNode& f);
     std::unique_ptr<Expression> convertIdentifier(int offset, StringFragment identifier);
     std::unique_ptr<Expression> convertIdentifier(const ASTNode& identifier);
     std::unique_ptr<Statement> convertIf(const ASTNode& s);
     std::unique_ptr<Statement> convertIf(int offset, bool isStatic,
                                          std::unique_ptr<Expression> test,
                                          std::unique_ptr<Statement> ifTrue,
                                          std::unique_ptr<Statement> ifFalse);
     std::unique_ptr<InterfaceBlock> convertInterfaceBlock(const ASTNode& s);
     Modifiers convertModifiers(const Modifiers& m);
     std::unique_ptr<Expression> convertPrefixExpression(const ASTNode& expression);
     std::unique_ptr<Statement> convertReturn(const ASTNode& r);
     std::unique_ptr<Section> convertSection(const ASTNode& e);
     std::unique_ptr<Expression> convertCallExpression(const ASTNode& expression);
     std::unique_ptr<Expression> convertFieldExpression(const ASTNode& expression);
     std::unique_ptr<Expression> convertIndexExpression(const ASTNode& expression);
     std::unique_ptr<Expression> convertIndex(std::unique_ptr<Expression> base,
                                              std::unique_ptr<Expression> index);
-    std::unique_ptr<Expression> convertEmptyIndex(std::unique_ptr<Expression> base);
     std::unique_ptr<Expression> convertPostfixExpression(std::unique_ptr<Expression> base,
                                                          Token::Kind op);
     std::unique_ptr<Expression> convertPostfixExpression(const ASTNode& expression);
     std::unique_ptr<Expression> convertPrefixExpression(Token::Kind op,
                                                         std::unique_ptr<Expression> base);
     std::unique_ptr<Expression> convertScopeExpression(const ASTNode& expression);
     std::unique_ptr<StructDefinition> convertStructDefinition(const ASTNode& expression);
     std::unique_ptr<Expression> convertTypeField(int offset, const Type& type,
                                                  StringFragment field);
     std::unique_ptr<Expression> convertSwizzle(std::unique_ptr<Expression> base, String fields);
     std::unique_ptr<Expression> convertTernaryExpression(std::unique_ptr<Expression> test,
                                                          std::unique_ptr<Expression> ifTrue,
                                                          std::unique_ptr<Expression> ifFalse);
     std::unique_ptr<Expression> convertTernaryExpression(const ASTNode& expression);
     std::unique_ptr<Statement> convertVarDeclarationStatement(const ASTNode& s);
     std::unique_ptr<Statement> convertWhile(int offset, std::unique_ptr<Expression> test,
                                             std::unique_ptr<Statement> statement);
     std::unique_ptr<Statement> convertWhile(const ASTNode& w);
     void convertGlobalVarDeclarations(const ASTNode& decl);
     void convertEnum(const ASTNode& e);
     std::unique_ptr<Block> applyInvocationIDWorkaround(std::unique_ptr<Block> main);
     // returns a statement which converts sk_Position from device to normalized coordinates
     std::unique_ptr<Statement> getNormalizeSkPositionCode();
 
     void checkValid(const Expression& expr);
     bool typeContainsPrivateFields(const Type& type);
     bool setRefKind(Expression& expr, VariableReference::RefKind kind);
     bool getConstantInt(const Expression& value, SKSL_INT* out);
     void copyIntrinsicIfNeeded(const FunctionDeclaration& function);
     void findAndDeclareBuiltinVariables();
 
     // Runtime effects (and the interpreter, which uses the same CPU runtime) require adherence to
     // the strict rules from The OpenGL ES Shading Language Version 1.00. (Including Appendix A).
     bool strictES2Mode() const {
         return fKind == Program::kRuntimeEffect_Kind || fKind == Program::kGeneric_Kind;
     }
 
     Program::Inputs fInputs;
     const Program::Settings* fSettings = nullptr;
     const ShaderCapsClass* fCaps = nullptr;
     Program::Kind fKind;
 
     std::unique_ptr<ASTFile> fFile;
     const FunctionDeclaration* fCurrentFunction = nullptr;
     std::unordered_map<String, Program::Settings::Value> fCapsMap;
     std::shared_ptr<SymbolTable> fSymbolTable = nullptr;
     // additional statements that need to be inserted before the one that convertStatement is
     // currently working on
     StatementArray fExtraStatements;
     // Symbols which have definitions in the include files.
     IRIntrinsicMap* fIntrinsics = nullptr;
     std::unordered_set<const FunctionDeclaration*> fReferencedIntrinsics;
     int fLoopLevel = 0;
     int fSwitchLevel = 0;
     int fInvocations;
     std::vector<std::unique_ptr<ProgramElement>>* fProgramElements = nullptr;
     std::vector<const ProgramElement*>*           fSharedElements = nullptr;
     const Variable* fRTAdjust = nullptr;
     const Variable* fRTAdjustInterfaceBlock = nullptr;
     int fRTAdjustFieldIndex;
     bool fCanInline = true;
     // true if we are currently processing one of the built-in SkSL include files
     bool fIsBuiltinCode = false;
     std::unique_ptr<ModifiersPool> fModifiers;
 
     friend class AutoSymbolTable;
     friend class AutoLoopLevel;
     friend class AutoSwitchLevel;
     friend class AutoDisableInline;
     friend class Compiler;
     friend class dsl::DSLWriter;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/tests/sksl/errors/ArrayIndexOutOfRange.sksl b/tests/sksl/errors/ArrayIndexOutOfRange.sksl
index ed03532603..66e96c9952 100644
--- a/tests/sksl/errors/ArrayIndexOutOfRange.sksl
+++ b/tests/sksl/errors/ArrayIndexOutOfRange.sksl
@@ -6,11 +6,13 @@ void array_122              () { bool2   a[123]; bool2   v = a[122]; }
 void array_123              () { half4x4 a[123]; half4x4 v = a[123]; }
 void array_huge             () { int4    a[123]; int4    v = a[1000000000]; }
 void array_overflow         () { half3   a[123]; half3   v = a[3000000000]; }
+void array_no_index         () { int     a[123]; int     v = a[]; }
 
 void unsized_array_neg1     () {                 int v = unsizedArray[-1].x; }
 void unsized_array_0        () {                 int v = unsizedArray[0].x; }
 void unsized_array_huge     () {                 int v = unsizedArray[1000000000].x; }
 void unsized_array_overflow () {                 int v = unsizedArray[3000000000].x; }
+void unsized_array_no_index () {                 int v = unsizedArray[].x; }
 
 void half4_neg1()              { half4 h;        half    v = h[-1]; }
 void half4_0()                 { half4 h;        half    v = h[0]; }
diff --git a/tests/sksl/errors/ArrayUnspecifiedDimensions.sksl b/tests/sksl/errors/ArrayUnspecifiedDimensions.sksl
index 7773e9b2e3..854c224aa9 100644
--- a/tests/sksl/errors/ArrayUnspecifiedDimensions.sksl
+++ b/tests/sksl/errors/ArrayUnspecifiedDimensions.sksl
@@ -1,3 +1,5 @@
 in int arrUnsized[];
 in int arrFloat[1.];
 in int arrBool[true];
+
+int unsized_in_expression() { return int[](0)[0]; }
diff --git a/tests/sksl/errors/FieldAfterRuntimeArray.sksl b/tests/sksl/errors/FieldAfterRuntimeArray.sksl
deleted file mode 100644
index e5fe6603f2..0000000000
--- a/tests/sksl/errors/FieldAfterRuntimeArray.sksl
+++ /dev/null
@@ -1,2 +0,0 @@
-buffer brokenA { float x[];              float y; };
-buffer brokenB { float x[] = float[](0); float y; };
diff --git a/tests/sksl/errors/golden/ArrayIndexOutOfRange.glsl b/tests/sksl/errors/golden/ArrayIndexOutOfRange.glsl
index 825b1706ec..238787b6aa 100644
--- a/tests/sksl/errors/golden/ArrayIndexOutOfRange.glsl
+++ b/tests/sksl/errors/golden/ArrayIndexOutOfRange.glsl
@@ -4,30 +4,32 @@ error: 3: index -1 out of range for 'int[123]'
 error: 6: index 123 out of range for 'half4x4[123]'
 error: 7: index 1000000000 out of range for 'int4[123]'
 error: 8: index 3000000000 out of range for 'half3[123]'
-error: 10: index -1 out of range for 'Block[]'
-error: 13: index 3000000000 out of range for 'Block[]'
-error: 15: index -1 out of range for 'half4'
-error: 20: index 4 out of range for 'half4'
-error: 21: index 1000000000 out of range for 'half4'
-error: 23: index -1 out of range for 'half3'
-error: 27: index 3 out of range for 'half3'
-error: 28: index 4 out of range for 'half3'
-error: 29: index 1000000000 out of range for 'half3'
-error: 31: index -1 out of range for 'half2'
-error: 34: index 2 out of range for 'half2'
-error: 35: index 3 out of range for 'half2'
-error: 36: index 4 out of range for 'half2'
-error: 37: index 1000000000 out of range for 'half2'
-error: 39: index -1 out of range for 'half2x4'
-error: 42: index 2 out of range for 'half2x4'
-error: 43: index 3 out of range for 'half2x4'
-error: 44: index 4 out of range for 'half2x4'
-error: 45: index 1000000000 out of range for 'half2x4'
-error: 47: index -1 out of range for 'half3x3'
-error: 51: index 3 out of range for 'half3x3'
-error: 52: index 4 out of range for 'half3x3'
-error: 53: index 1000000000 out of range for 'half3x3'
-error: 55: index -1 out of range for 'half4x2'
-error: 60: index 4 out of range for 'half4x2'
-error: 61: index 1000000000 out of range for 'half4x2'
-30 errors
+error: 9: missing index in '[]'
+error: 11: index -1 out of range for 'Block[]'
+error: 14: index 3000000000 out of range for 'Block[]'
+error: 15: missing index in '[]'
+error: 17: index -1 out of range for 'half4'
+error: 22: index 4 out of range for 'half4'
+error: 23: index 1000000000 out of range for 'half4'
+error: 25: index -1 out of range for 'half3'
+error: 29: index 3 out of range for 'half3'
+error: 30: index 4 out of range for 'half3'
+error: 31: index 1000000000 out of range for 'half3'
+error: 33: index -1 out of range for 'half2'
+error: 36: index 2 out of range for 'half2'
+error: 37: index 3 out of range for 'half2'
+error: 38: index 4 out of range for 'half2'
+error: 39: index 1000000000 out of range for 'half2'
+error: 41: index -1 out of range for 'half2x4'
+error: 44: index 2 out of range for 'half2x4'
+error: 45: index 3 out of range for 'half2x4'
+error: 46: index 4 out of range for 'half2x4'
+error: 47: index 1000000000 out of range for 'half2x4'
+error: 49: index -1 out of range for 'half3x3'
+error: 53: index 3 out of range for 'half3x3'
+error: 54: index 4 out of range for 'half3x3'
+error: 55: index 1000000000 out of range for 'half3x3'
+error: 57: index -1 out of range for 'half4x2'
+error: 62: index 4 out of range for 'half4x2'
+error: 63: index 1000000000 out of range for 'half4x2'
+32 errors
diff --git a/tests/sksl/errors/golden/ArrayUnspecifiedDimensions.glsl b/tests/sksl/errors/golden/ArrayUnspecifiedDimensions.glsl
index 45e32ca96f..f6d294e21e 100644
--- a/tests/sksl/errors/golden/ArrayUnspecifiedDimensions.glsl
+++ b/tests/sksl/errors/golden/ArrayUnspecifiedDimensions.glsl
@@ -1,6 +1,7 @@
 ### Compilation failed:
 
-error: 1: arrays without an explicit size must use an initializer expression
+error: 1: array must have a size
 error: 2: expected 'int', but found 'float'
 error: 3: expected 'int', but found 'bool'
-3 errors
+error: 5: array must have a size
+4 errors
diff --git a/tests/sksl/errors/golden/FieldAfterRuntimeArray.glsl b/tests/sksl/errors/golden/FieldAfterRuntimeArray.glsl
deleted file mode 100644
index 98f2ba7622..0000000000
--- a/tests/sksl/errors/golden/FieldAfterRuntimeArray.glsl
+++ /dev/null
@@ -1,6 +0,0 @@
-### Compilation failed:
-
-error: 1: arrays without an explicit size must use an initializer expression
-error: 2: initializers are not permitted on interface block fields
-error: 2: only the last entry in an interface block may be a runtime-sized array
-3 errors
diff --git a/tests/sksl/shared/ArrayConstructors.sksl b/tests/sksl/shared/ArrayConstructors.sksl
index 578786e03b..3891956139 100644
--- a/tests/sksl/shared/ArrayConstructors.sksl
+++ b/tests/sksl/shared/ArrayConstructors.sksl
@@ -1,6 +1,6 @@
-float test1[] = float[](1, 2, 3, 4);
-float2 test2[] = float2[](float2(1, 2), float2(3, 4));
-float4x4 test3[] = float4x4[]();
+float test1[4] = float[4](1, 2, 3, 4);
+float2 test2[2] = float2[2](float2(1, 2), float2(3, 4));
+float4x4 test3[1] = float4x4[1]();
 
 void main() {
     sk_FragColor.r = half(test1[0] + test2[0].x + test3[0][0][0]);
diff --git a/tests/sksl/shared/ConstArray.sksl b/tests/sksl/shared/ConstArray.sksl
index 67eab17646..bf95dab405 100644
--- a/tests/sksl/shared/ConstArray.sksl
+++ b/tests/sksl/shared/ConstArray.sksl
@@ -1,4 +1,4 @@
-const half test[] = half[](1, 2, 3, 4);
+const half test[4] = half[4](1, 2, 3, 4);
 
 void main() {
     sk_FragColor = half4(test[0], test[1], test[2], test[3]);
diff --git a/tests/sksl/shared/Ossfuzz28050.sksl b/tests/sksl/shared/Ossfuzz28050.sksl
index 4fc38b82ab..21d86a7a7c 100644
--- a/tests/sksl/shared/Ossfuzz28050.sksl
+++ b/tests/sksl/shared/Ossfuzz28050.sksl
@@ -1,4 +1,4 @@
 float an()  { return 2; }
-void wna()  { an(), float[](); }
+void wna()  { an(), float[1](); }
 void na()   { wna(); }
 void main() { na(), na(); }
diff --git a/tests/sksl/shared/golden/ArrayConstructors.asm.frag b/tests/sksl/shared/golden/ArrayConstructors.asm.frag
index beb9778b5d..0a74b39c70 100644
--- a/tests/sksl/shared/golden/ArrayConstructors.asm.frag
+++ b/tests/sksl/shared/golden/ArrayConstructors.asm.frag
@@ -1,6 +1,83 @@
 ### Compilation failed:
 
-error: runtime-sized arrays are not supported in SPIR-V
-error: runtime-sized arrays are not supported in SPIR-V
-error: runtime-sized arrays are not supported in SPIR-V
-3 errors
+error: SPIR-V validation error: Expected total number of Constituents to be equal to the number of elements of Result Type array
+  %33 = OpCompositeConstruct %_arr_mat4v4float_int_1
+
+OpCapability Shader
+%1 = OpExtInstImport "GLSL.std.450"
+OpMemoryModel Logical GLSL450
+OpEntryPoint Fragment %main "main" %sk_FragColor %sk_Clockwise
+OpExecutionMode %main OriginUpperLeft
+OpName %sk_FragColor "sk_FragColor"
+OpName %sk_Clockwise "sk_Clockwise"
+OpName %test1 "test1"
+OpName %test2 "test2"
+OpName %test3 "test3"
+OpName %main "main"
+OpDecorate %sk_FragColor RelaxedPrecision
+OpDecorate %sk_FragColor Location 0
+OpDecorate %sk_FragColor Index 0
+OpDecorate %sk_Clockwise RelaxedPrecision
+OpDecorate %sk_Clockwise BuiltIn FrontFacing
+OpDecorate %_arr_float_int_4 ArrayStride 16
+OpDecorate %_arr_v2float_int_2 ArrayStride 16
+OpDecorate %_arr_mat4v4float_int_1 ArrayStride 64
+%float = OpTypeFloat 32
+%v4float = OpTypeVector %float 4
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+%sk_FragColor = OpVariable %_ptr_Output_v4float Output
+%bool = OpTypeBool
+%_ptr_Input_bool = OpTypePointer Input %bool
+%sk_Clockwise = OpVariable %_ptr_Input_bool Input
+%int = OpTypeInt 32 1
+%int_4 = OpConstant %int 4
+%_arr_float_int_4 = OpTypeArray %float %int_4
+%_ptr_Private__arr_float_int_4 = OpTypePointer Private %_arr_float_int_4
+%test1 = OpVariable %_ptr_Private__arr_float_int_4 Private
+%float_1 = OpConstant %float 1
+%float_2 = OpConstant %float 2
+%float_3 = OpConstant %float 3
+%float_4 = OpConstant %float 4
+%v2float = OpTypeVector %float 2
+%int_2 = OpConstant %int 2
+%_arr_v2float_int_2 = OpTypeArray %v2float %int_2
+%_ptr_Private__arr_v2float_int_2 = OpTypePointer Private %_arr_v2float_int_2
+%test2 = OpVariable %_ptr_Private__arr_v2float_int_2 Private
+%25 = OpConstantComposite %v2float %float_1 %float_2
+%26 = OpConstantComposite %v2float %float_3 %float_4
+%mat4v4float = OpTypeMatrix %v4float 4
+%int_1 = OpConstant %int 1
+%_arr_mat4v4float_int_1 = OpTypeArray %mat4v4float %int_1
+%_ptr_Private__arr_mat4v4float_int_1 = OpTypePointer Private %_arr_mat4v4float_int_1
+%test3 = OpVariable %_ptr_Private__arr_mat4v4float_int_1 Private
+%void = OpTypeVoid
+%35 = OpTypeFunction %void
+%int_0 = OpConstant %int 0
+%_ptr_Private_float = OpTypePointer Private %float
+%_ptr_Private_v2float = OpTypePointer Private %v2float
+%_ptr_Private_v4float = OpTypePointer Private %v4float
+%_ptr_Output_float = OpTypePointer Output %float
+%main = OpFunction %void None %35
+%36 = OpLabel
+%19 = OpCompositeConstruct %_arr_float_int_4 %float_1 %float_2 %float_3 %float_4
+OpStore %test1 %19
+%27 = OpCompositeConstruct %_arr_v2float_int_2 %25 %26
+OpStore %test2 %27
+%33 = OpCompositeConstruct %_arr_mat4v4float_int_1
+OpStore %test3 %33
+%38 = OpAccessChain %_ptr_Private_float %test1 %int_0
+%40 = OpLoad %float %38
+%41 = OpAccessChain %_ptr_Private_v2float %test2 %int_0
+%43 = OpLoad %v2float %41
+%44 = OpCompositeExtract %float %43 0
+%45 = OpFAdd %float %40 %44
+%46 = OpAccessChain %_ptr_Private_v4float %test3 %int_0 %int_0
+%48 = OpLoad %v4float %46
+%49 = OpCompositeExtract %float %48 0
+%50 = OpFAdd %float %45 %49
+%51 = OpAccessChain %_ptr_Output_float %sk_FragColor %int_0
+OpStore %51 %50
+OpReturn
+OpFunctionEnd
+
+1 error
diff --git a/tests/sksl/shared/golden/ArrayConstructors.glsl b/tests/sksl/shared/golden/ArrayConstructors.glsl
index 24f1af21a3..5f68bb8944 100644
--- a/tests/sksl/shared/golden/ArrayConstructors.glsl
+++ b/tests/sksl/shared/golden/ArrayConstructors.glsl
@@ -1,8 +1,8 @@
 
 out vec4 sk_FragColor;
-float test1[] = float[](1.0, 2.0, 3.0, 4.0);
-vec2 test2[] = vec2[](vec2(1.0, 2.0), vec2(3.0, 4.0));
-mat4 test3[] = mat4[]();
+float test1[4] = float[4](1.0, 2.0, 3.0, 4.0);
+vec2 test2[2] = vec2[2](vec2(1.0, 2.0), vec2(3.0, 4.0));
+mat4 test3[1] = mat4[1]();
 void main() {
     sk_FragColor.x = (test1[0] + test2[0].x) + test3[0][0].x;
 }
diff --git a/tests/sksl/shared/golden/ConstArray.asm.frag b/tests/sksl/shared/golden/ConstArray.asm.frag
index 994061e70f..87b1b203de 100644
--- a/tests/sksl/shared/golden/ConstArray.asm.frag
+++ b/tests/sksl/shared/golden/ConstArray.asm.frag
@@ -1,4 +1,59 @@
-### Compilation failed:
-
-error: runtime-sized arrays are not supported in SPIR-V
-1 error
+OpCapability Shader
+%1 = OpExtInstImport "GLSL.std.450"
+OpMemoryModel Logical GLSL450
+OpEntryPoint Fragment %main "main" %sk_FragColor %sk_Clockwise
+OpExecutionMode %main OriginUpperLeft
+OpName %sk_FragColor "sk_FragColor"
+OpName %sk_Clockwise "sk_Clockwise"
+OpName %test "test"
+OpName %main "main"
+OpDecorate %sk_FragColor RelaxedPrecision
+OpDecorate %sk_FragColor Location 0
+OpDecorate %sk_FragColor Index 0
+OpDecorate %sk_Clockwise RelaxedPrecision
+OpDecorate %sk_Clockwise BuiltIn FrontFacing
+OpDecorate %_arr_float_int_4 ArrayStride 16
+OpDecorate %test RelaxedPrecision
+OpDecorate %26 RelaxedPrecision
+OpDecorate %29 RelaxedPrecision
+OpDecorate %32 RelaxedPrecision
+OpDecorate %35 RelaxedPrecision
+%float = OpTypeFloat 32
+%v4float = OpTypeVector %float 4
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+%sk_FragColor = OpVariable %_ptr_Output_v4float Output
+%bool = OpTypeBool
+%_ptr_Input_bool = OpTypePointer Input %bool
+%sk_Clockwise = OpVariable %_ptr_Input_bool Input
+%int = OpTypeInt 32 1
+%int_4 = OpConstant %int 4
+%_arr_float_int_4 = OpTypeArray %float %int_4
+%_ptr_Private__arr_float_int_4 = OpTypePointer Private %_arr_float_int_4
+%test = OpVariable %_ptr_Private__arr_float_int_4 Private
+%float_1 = OpConstant %float 1
+%float_2 = OpConstant %float 2
+%float_3 = OpConstant %float 3
+%float_4 = OpConstant %float 4
+%void = OpTypeVoid
+%21 = OpTypeFunction %void
+%int_0 = OpConstant %int 0
+%_ptr_Private_float = OpTypePointer Private %float
+%int_1 = OpConstant %int 1
+%int_2 = OpConstant %int 2
+%int_3 = OpConstant %int 3
+%main = OpFunction %void None %21
+%22 = OpLabel
+%19 = OpCompositeConstruct %_arr_float_int_4 %float_1 %float_2 %float_3 %float_4
+OpStore %test %19
+%24 = OpAccessChain %_ptr_Private_float %test %int_0
+%26 = OpLoad %float %24
+%28 = OpAccessChain %_ptr_Private_float %test %int_1
+%29 = OpLoad %float %28
+%31 = OpAccessChain %_ptr_Private_float %test %int_2
+%32 = OpLoad %float %31
+%34 = OpAccessChain %_ptr_Private_float %test %int_3
+%35 = OpLoad %float %34
+%36 = OpCompositeConstruct %v4float %26 %29 %32 %35
+OpStore %sk_FragColor %36
+OpReturn
+OpFunctionEnd
diff --git a/tests/sksl/shared/golden/ConstArray.glsl b/tests/sksl/shared/golden/ConstArray.glsl
index 085e91e271..af1f1c7193 100644
--- a/tests/sksl/shared/golden/ConstArray.glsl
+++ b/tests/sksl/shared/golden/ConstArray.glsl
@@ -1,6 +1,6 @@
 
 out vec4 sk_FragColor;
-const float test[] = float[](1.0, 2.0, 3.0, 4.0);
+const float test[4] = float[4](1.0, 2.0, 3.0, 4.0);
 void main() {
     sk_FragColor = vec4(test[0], test[1], test[2], test[3]);
 }
