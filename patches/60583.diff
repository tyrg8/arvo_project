commit 748614b73cadd3e9da94de7fc466598eca6667aa
Author: James Carter <jwcart2@gmail.com>
Date:   Tue Jul 25 11:14:36 2023 -0400

    Revert "checkpolicy,libsepol: add prefix/suffix support to kernel policy"
    
    This reverts commit 1174483d2924dc700673363b240fca2b9fe45786.
    
    Signed-off-by: James Carter <jwcart2@gmail.com>
    Acked-by: Petr Lautrbach <lautrbach@redhat.com>

diff --git a/checkpolicy/test/dispol.c b/checkpolicy/test/dispol.c
index 776bf54d..861fa903 100644
--- a/checkpolicy/test/dispol.c
+++ b/checkpolicy/test/dispol.c
@@ -128,41 +128,25 @@ static int render_key(avtab_key_t * key, policydb_t * p, FILE * fp)
 typedef struct {
 	avtab_key_t *key;
 	policydb_t *p;
 	FILE *fp;
-	name_trans_match_t match;
 } render_name_trans_args_t;
 
 static int render_name_trans_helper(hashtab_key_t k, hashtab_datum_t d, void *a)
 {
 	char *name = k;
 	uint32_t *otype = d;
 	render_name_trans_args_t *args = a;
 
 	fprintf(args->fp, "type_transition ");
 	render_key(args->key, args->p, args->fp);
 	render_type(*otype, args->p, args->fp);
-	const char *match_str = "";
-	switch (args->match) {
-	case NAME_TRANS_MATCH_EXACT:
-		match_str = "";
-		break;
-	case NAME_TRANS_MATCH_PREFIX:
-		match_str = " PREFIX";
-		break;
-	case NAME_TRANS_MATCH_SUFFIX:
-		match_str = " SUFFIX";
-		break;
-	default:
-		fprintf(args->fp, "     ERROR: no valid name match type specified\n");
-		return -1;
-	}
-	fprintf(args->fp, " \"%s\"%s;\n", name, match_str);
+	fprintf(args->fp, " \"%s\";\n", name);
 
 	return 0;
 }
 
 /* 'what' values for this function */
 #define	RENDER_UNCONDITIONAL	0x0001	/* render all regardless of enabled state */
 #define RENDER_ENABLED		0x0002
 #define RENDER_DISABLED		0x0004
 #define RENDER_CONDITIONAL	(RENDER_ENABLED|RENDER_DISABLED)
@@ -170,94 +154,87 @@ static int render_name_trans_helper(hashtab_key_t k, hashtab_datum_t d, void *a)
 static int render_av_rule(avtab_key_t * key, avtab_datum_t * datum, uint32_t what,
 		   policydb_t * p, FILE * fp)
 {
 	if (!(what & RENDER_UNCONDITIONAL)) {
 		if (what != RENDER_CONDITIONAL && (((what & RENDER_ENABLED)
 						    && !(key->
 							 specified &
 							 AVTAB_ENABLED))
 						   || ((what & RENDER_DISABLED)
 						       && (key->
 							   specified &
 							   AVTAB_ENABLED)))) {
 			return 0;	/* doesn't match selection criteria */
 		}
 	}
 
 	if (!(what & RENDER_UNCONDITIONAL)) {
 		if (key->specified & AVTAB_ENABLED)
 			fprintf(fp, "[enabled] ");
 		else if (!(key->specified & AVTAB_ENABLED))
 			fprintf(fp, "[disabled] ");
 	}
 
 	if (key->specified & AVTAB_AV) {
 		if (key->specified & AVTAB_ALLOWED) {
 			fprintf(fp, "allow ");
 			render_key(key, p, fp);
 			render_access_mask(datum->data, key, p, fp);
 			fprintf(fp, ";\n");
 		}
 		if (key->specified & AVTAB_AUDITALLOW) {
 			fprintf(fp, "auditallow ");
 			render_key(key, p, fp);
 			render_access_mask(datum->data, key, p, fp);
 			fprintf(fp, ";\n");
 		}
 		if (key->specified & AVTAB_AUDITDENY) {
 			fprintf(fp, "dontaudit ");
 			render_key(key, p, fp);
 			/* We inverse the mask for dontaudit since the mask is internally stored
 			 * as a auditdeny mask */
 			render_access_mask(~datum->data, key, p, fp);
 			fprintf(fp, ";\n");
 		}
 	} else if (key->specified & AVTAB_TYPE) {
 		if (key->specified & AVTAB_TRANSITION) {
 			if (datum->trans->otype) {
 				fprintf(fp, "type_transition ");
 				render_key(key, p, fp);
 				render_type(datum->trans->otype, p, fp);
 				fprintf(fp, ";\n");
 			}
 			render_name_trans_args_t args = {
 				.key = key,
 				.p = p,
 				.fp = fp,
-				.match = NAME_TRANS_MATCH_EXACT,
 			};
 			hashtab_map(datum->trans->name_trans.table,
 				    render_name_trans_helper, &args);
-			args.match = NAME_TRANS_MATCH_PREFIX;
-			hashtab_map(datum->trans->prefix_trans.table,
-				    render_name_trans_helper, &args);
-			args.match = NAME_TRANS_MATCH_SUFFIX;
-			hashtab_map(datum->trans->suffix_trans.table,
-				    render_name_trans_helper, &args);
 		}
 		if (key->specified & AVTAB_MEMBER) {
 			fprintf(fp, "type_member ");
 			render_key(key, p, fp);
 			render_type(datum->data, p, fp);
 			fprintf(fp, ";\n");
 		}
 		if (key->specified & AVTAB_CHANGE) {
 			fprintf(fp, "type_change ");
 			render_key(key, p, fp);
 			render_type(datum->data, p, fp);
 			fprintf(fp, ";\n");
 		}
 	} else if (key->specified & AVTAB_XPERMS) {
 		if (key->specified & AVTAB_XPERMS_ALLOWED)
 			fprintf(fp, "allowxperm ");
 		else if (key->specified & AVTAB_XPERMS_AUDITALLOW)
 			fprintf(fp, "auditallowxperm ");
 		else if (key->specified & AVTAB_XPERMS_DONTAUDIT)
 			fprintf(fp, "dontauditxperm ");
 		render_key(key, p, fp);
 		fprintf(fp, "%s;\n", sepol_extended_perms_to_string(datum->xperms));
 	} else {
 		fprintf(fp, "     ERROR: no valid rule type specified\n");
 		return -1;
 	}
 	return 0;
 }
diff --git a/libsepol/include/sepol/policydb/avtab.h b/libsepol/include/sepol/policydb/avtab.h
index 870fb08a..5dc720cc 100644
--- a/libsepol/include/sepol/policydb/avtab.h
+++ b/libsepol/include/sepol/policydb/avtab.h
@@ -74,8 +74,6 @@ typedef struct avtab_key {
 typedef struct avtab_trans {
 	uint32_t otype;		/* resulting type of the new object */
 	symtab_t name_trans;	/* filename transitions */
-	symtab_t prefix_trans;	/* prefix filename transitions */
-	symtab_t suffix_trans;	/* prefix filename transitions */
 } avtab_trans_t;
 
 typedef struct avtab_extended_perms {
diff --git a/libsepol/include/sepol/policydb/policydb.h b/libsepol/include/sepol/policydb/policydb.h
index a2df4a62..5efd0a47 100644
--- a/libsepol/include/sepol/policydb/policydb.h
+++ b/libsepol/include/sepol/policydb/policydb.h
@@ -252,12 +252,6 @@ typedef struct av_extended_perms {
 	uint32_t perms[EXTENDED_PERMS_LEN];
 } av_extended_perms_t;
 
-typedef enum name_trans_match {
-	NAME_TRANS_MATCH_EXACT,
-	NAME_TRANS_MATCH_PREFIX,
-	NAME_TRANS_MATCH_SUFFIX,
-} name_trans_match_t;
-
 typedef struct avrule {
 /* these typedefs are almost exactly the same as those in avtab.h - they are
  * here because of the need to include neverallow and dontaudit messages */
@@ -705,95 +699,94 @@ extern int policydb_write(struct policydb *p, struct policy_file *pf);
 extern int policydb_set_target_platform(policydb_t *p, int platform);
 
 #define PERM_SYMTAB_SIZE 32
 
 /* Identify specific policy version changes */
 #define POLICYDB_VERSION_BASE		15
 #define POLICYDB_VERSION_BOOL		16
 #define POLICYDB_VERSION_IPV6		17
 #define POLICYDB_VERSION_NLCLASS	18
 #define POLICYDB_VERSION_VALIDATETRANS	19
 #define POLICYDB_VERSION_MLS		19
 #define POLICYDB_VERSION_AVTAB		20
 #define POLICYDB_VERSION_RANGETRANS	21
 #define POLICYDB_VERSION_POLCAP		22
 #define POLICYDB_VERSION_PERMISSIVE	23
 #define POLICYDB_VERSION_BOUNDARY	24
 #define POLICYDB_VERSION_FILENAME_TRANS	25
 #define POLICYDB_VERSION_ROLETRANS	26
 #define POLICYDB_VERSION_NEW_OBJECT_DEFAULTS	27
 #define POLICYDB_VERSION_DEFAULT_TYPE	28
 #define POLICYDB_VERSION_CONSTRAINT_NAMES	29
 #define POLICYDB_VERSION_XEN_DEVICETREE		30 /* Xen-specific */
 #define POLICYDB_VERSION_XPERMS_IOCTL	30 /* Linux-specific */
 #define POLICYDB_VERSION_INFINIBAND		31 /* Linux-specific */
 #define POLICYDB_VERSION_GLBLUB		32
 #define POLICYDB_VERSION_COMP_FTRANS	33 /* compressed filename transitions */
 #define POLICYDB_VERSION_AVTAB_FTRANS	34 /* filename transitions moved to avtab */
-#define POLICYDB_VERSION_PREFIX_SUFFIX	35 /* prefix/suffix support for filename transitions */
 
 /* Range of policy versions we understand*/
 #define POLICYDB_VERSION_MIN	POLICYDB_VERSION_BASE
-#define POLICYDB_VERSION_MAX	POLICYDB_VERSION_PREFIX_SUFFIX
+#define POLICYDB_VERSION_MAX	POLICYDB_VERSION_AVTAB_FTRANS
 
 /* Module versions and specific changes*/
 #define MOD_POLICYDB_VERSION_BASE		4
 #define MOD_POLICYDB_VERSION_VALIDATETRANS	5
 #define MOD_POLICYDB_VERSION_MLS		5
 #define MOD_POLICYDB_VERSION_RANGETRANS 	6
 #define MOD_POLICYDB_VERSION_MLS_USERS		6
 #define MOD_POLICYDB_VERSION_POLCAP		7
 #define MOD_POLICYDB_VERSION_PERMISSIVE		8
 #define MOD_POLICYDB_VERSION_BOUNDARY		9
 #define MOD_POLICYDB_VERSION_BOUNDARY_ALIAS	10
 #define MOD_POLICYDB_VERSION_FILENAME_TRANS	11
 #define MOD_POLICYDB_VERSION_ROLETRANS		12
 #define MOD_POLICYDB_VERSION_ROLEATTRIB		13
 #define MOD_POLICYDB_VERSION_TUNABLE_SEP	14
 #define MOD_POLICYDB_VERSION_NEW_OBJECT_DEFAULTS	15
 #define MOD_POLICYDB_VERSION_DEFAULT_TYPE	16
 #define MOD_POLICYDB_VERSION_CONSTRAINT_NAMES  17
 #define MOD_POLICYDB_VERSION_XPERMS_IOCTL  18
 #define MOD_POLICYDB_VERSION_INFINIBAND		19
 #define MOD_POLICYDB_VERSION_GLBLUB		20
 #define MOD_POLICYDB_VERSION_SELF_TYPETRANS	21
 #define MOD_POLICYDB_VERSION_AVRULE_FTRANS	22
 
 #define MOD_POLICYDB_VERSION_MIN MOD_POLICYDB_VERSION_BASE
 #define MOD_POLICYDB_VERSION_MAX MOD_POLICYDB_VERSION_AVRULE_FTRANS
 
 #define POLICYDB_CONFIG_MLS    1
 
 /* macros to check policy feature */
 
 /* TODO: add other features here */
 
 #define policydb_has_boundary_feature(p)			\
 	(((p)->policy_type == POLICY_KERN			\
 	  && (p)->policyvers >= POLICYDB_VERSION_BOUNDARY) ||	\
 	 ((p)->policy_type != POLICY_KERN			\
 	  && (p)->policyvers >= MOD_POLICYDB_VERSION_BOUNDARY))
 
 /* the config flags related to unknown classes/perms are bits 2 and 3 */
 #define DENY_UNKNOWN	SEPOL_DENY_UNKNOWN
 #define REJECT_UNKNOWN	SEPOL_REJECT_UNKNOWN
 #define ALLOW_UNKNOWN 	SEPOL_ALLOW_UNKNOWN
 
 #define POLICYDB_CONFIG_UNKNOWN_MASK	(DENY_UNKNOWN | REJECT_UNKNOWN | ALLOW_UNKNOWN)
 
 #define OBJECT_R "object_r"
 #define OBJECT_R_VAL 1
 
 #define POLICYDB_MAGIC SELINUX_MAGIC
 #define POLICYDB_STRING "SE Linux"
 #define POLICYDB_XEN_STRING "XenFlask"
 #define POLICYDB_STRING_MAX_LENGTH 32
 #define POLICYDB_MOD_MAGIC SELINUX_MOD_MAGIC
 #define POLICYDB_MOD_STRING "SE Linux Module"
 
 #ifdef __cplusplus
 }
 #endif
 
 #endif				/* _POLICYDB_H_ */
 
 /* FLASK */
diff --git a/libsepol/src/avtab.c b/libsepol/src/avtab.c
index 90cfb90b..2a9564ba 100644
--- a/libsepol/src/avtab.c
+++ b/libsepol/src/avtab.c
@@ -326,11 +326,7 @@ static int avtab_trans_destroy_helper(hashtab_key_t k, hashtab_datum_t d,
 void avtab_trans_destroy(avtab_trans_t *trans)
 {
 	hashtab_map(trans->name_trans.table, avtab_trans_destroy_helper, NULL);
 	symtab_destroy(&trans->name_trans);
-	hashtab_map(trans->prefix_trans.table, avtab_trans_destroy_helper, NULL);
-	symtab_destroy(&trans->prefix_trans);
-	hashtab_map(trans->suffix_trans.table, avtab_trans_destroy_helper, NULL);
-	symtab_destroy(&trans->suffix_trans);
 }
 
 void avtab_destroy(avtab_t * h)
@@ -501,38 +497,29 @@ exit:
 static int avtab_trans_read(policy_file_t *fp, uint32_t vers,
 			    avtab_trans_t *trans)
 {
 	int rc;
 	uint32_t buf32[1];
 
 	if (vers < POLICYDB_VERSION_AVTAB_FTRANS) {
 		rc = next_entry(buf32, fp, sizeof(uint32_t));
 		if (rc < 0) {
 			ERR(fp->handle, "truncated entry");
 			return SEPOL_ERR;
 		}
 		trans->otype = le32_to_cpu(*buf32);
 		return SEPOL_OK;
 	}
 
 	/* read otype */
 	rc = next_entry(buf32, fp, sizeof(uint32_t) * 1);
 	if (rc < 0)
 		return rc;
 	trans->otype = le32_to_cpu(buf32[0]);
 
 	rc = avtab_read_name_trans(fp, &trans->name_trans);
 	if (rc < 0)
 		goto bad;
 
-	if (vers >= POLICYDB_VERSION_PREFIX_SUFFIX) {
-		rc = avtab_read_name_trans(fp, &trans->prefix_trans);
-		if (rc < 0)
-			goto bad;
-		rc = avtab_read_name_trans(fp, &trans->suffix_trans);
-		if (rc < 0)
-			goto bad;
-	}
-
 	return SEPOL_OK;
 
 bad:
diff --git a/libsepol/src/kernel_to_cil.c b/libsepol/src/kernel_to_cil.c
index 30a67017..8ed695f1 100644
--- a/libsepol/src/kernel_to_cil.c
+++ b/libsepol/src/kernel_to_cil.c
@@ -1703,132 +1703,106 @@ static char *xperms_to_str(avtab_extended_perms_t *xperms)
 static int name_trans_to_strs_helper(hashtab_key_t k, hashtab_datum_t d, void *a)
 {
 	char *name = k;
 	uint32_t *otype = d;
 	name_trans_to_strs_args_t *args = a;
-	const char *match_str = "";
-	switch (args->match) {
-	case NAME_TRANS_MATCH_EXACT:
-		match_str = "";
-		break;
-	case NAME_TRANS_MATCH_PREFIX:
-		match_str = " prefix";
-		break;
-	case NAME_TRANS_MATCH_SUFFIX:
-		match_str = " suffix";
-		break;
-	default:
-		ERR(NULL, "Unknown name match type: %" PRIu8, args->match);
-		return SEPOL_ERR;
-	}
-	return strs_create_and_add(args->strs, "(%s %s %s %s \"%s\"%s %s)", 7,
+	return strs_create_and_add(args->strs, "(%s %s %s %s \"%s\" %s)", 6,
 				   args->flavor, args->src, args->tgt,
-				   args->class, name, match_str,
+				   args->class, name,
 				   args->pdb->p_type_val_to_name[*otype - 1]);
 }
 
 static int avtab_node_to_strs(struct policydb *pdb, avtab_key_t *key, avtab_datum_t *datum, struct strs *strs)
 {
 	int rc = SEPOL_OK;
 	uint32_t data = datum->data;
 	type_datum_t *type;
 	const char *flavor, *tgt;
 	char *src, *class, *perms, *new;
 
 	switch (0xFFF & key->specified) {
 	case AVTAB_ALLOWED:
 		flavor = "allow";
 		break;
 	case AVTAB_AUDITALLOW:
 		flavor = "auditallow";
 		break;
 	case AVTAB_AUDITDENY:
 		flavor = "dontaudit";
 		data = ~data;
 		break;
 	case AVTAB_XPERMS_ALLOWED:
 		flavor = "allowx";
 		break;
 	case AVTAB_XPERMS_AUDITALLOW:
 		flavor = "auditallowx";
 		break;
 	case AVTAB_XPERMS_DONTAUDIT:
 		flavor = "dontauditx";
 		break;
 	case AVTAB_TRANSITION:
 		flavor = "typetransition";
 		break;
 	case AVTAB_MEMBER:
 		flavor = "typemember";
 		break;
 	case AVTAB_CHANGE:
 		flavor = "typechange";
 		break;
 	default:
 		ERR(NULL, "Unknown avtab type: %i", key->specified);
 		return SEPOL_ERR;
 	}
 
 	src = pdb->p_type_val_to_name[key->source_type - 1];
 	tgt = pdb->p_type_val_to_name[key->target_type - 1];
 	if (key->source_type == key->target_type && !(key->specified & AVTAB_TYPE)) {
 		type = pdb->type_val_to_struct[key->source_type - 1];
 		if (type->flavor != TYPE_ATTRIB) {
 			tgt = "self";
 		}
 	}
 	class = pdb->p_class_val_to_name[key->target_class - 1];
 
 	if (key->specified & AVTAB_AV) {
 		perms = sepol_av_to_string(pdb, key->target_class, data);
 		if (perms == NULL) {
 			ERR(NULL, "Failed to generate permission string");
 			return SEPOL_ERR;
 		}
 		rc = strs_create_and_add(strs, "(%s %s %s (%s (%s)))", 5,
 					 flavor, src, tgt, class, perms + 1);
 	} else if (key->specified & AVTAB_XPERMS) {
 		perms = xperms_to_str(datum->xperms);
 		if (perms == NULL) {
 			ERR(NULL, "Failed to generate extended permission string");
 			return SEPOL_ERR;
 		}
 
 		rc = strs_create_and_add(strs, "(%s %s %s (%s %s (%s)))", 6,
 					 flavor, src, tgt, "ioctl", class, perms);
 	} else if (key->specified & AVTAB_TRANSITION) {
 		if (datum->trans->otype) {
 			rc = strs_create_and_add(strs, "(%s %s %s %s %s)", 5,
 						 flavor, src, tgt, class,
 						 pdb->p_type_val_to_name[datum->trans->otype - 1]);
 			if (rc < 0)
 				return rc;
 		}
 		name_trans_to_strs_args_t args = {
 			.pdb = pdb,
 			.strs = strs,
 			.flavor = flavor,
 			.src = src,
 			.tgt = tgt,
 			.class = class,
-			.match = NAME_TRANS_MATCH_EXACT,
 		};
 		rc = hashtab_map(datum->trans->name_trans.table,
 				 name_trans_to_strs_helper, &args);
-		if (rc < 0)
-			return rc;
-		args.match = NAME_TRANS_MATCH_PREFIX;
-		rc = hashtab_map(datum->trans->prefix_trans.table,
-				 name_trans_to_strs_helper, &args);
-		if (rc < 0)
-			return rc;
-		args.match = NAME_TRANS_MATCH_SUFFIX;
-		rc = hashtab_map(datum->trans->suffix_trans.table,
-				 name_trans_to_strs_helper, &args);
 	} else {
 		new = pdb->p_type_val_to_name[data - 1];
 
 		rc = strs_create_and_add(strs, "(%s %s %s %s %s)", 5, flavor, src, tgt, class, new);
 	}
 
 	return rc;
 }
diff --git a/libsepol/src/kernel_to_common.h b/libsepol/src/kernel_to_common.h
index 07869e3d..b8ea237d 100644
--- a/libsepol/src/kernel_to_common.h
+++ b/libsepol/src/kernel_to_common.h
@@ -86,11 +86,10 @@ struct strs {
 typedef struct {
 	policydb_t *pdb;
 	struct strs *strs;
 	const char *flavor;
 	const char *src;
 	const char *tgt;
 	const char *class;
-	name_trans_match_t match;
 } name_trans_to_strs_args_t;
 
 void sepol_indent(FILE *out, int indent);
diff --git a/libsepol/src/kernel_to_conf.c b/libsepol/src/kernel_to_conf.c
index b1699b39..eb14ccf1 100644
--- a/libsepol/src/kernel_to_conf.c
+++ b/libsepol/src/kernel_to_conf.c
@@ -1681,130 +1681,104 @@ exit:
 static int name_trans_to_strs_helper(hashtab_key_t k, hashtab_datum_t d, void *a)
 {
 	char *name = k;
 	uint32_t *otype = d;
 	name_trans_to_strs_args_t *args = a;
-	const char *match_str = "";
-	switch (args->match) {
-	case NAME_TRANS_MATCH_EXACT:
-		match_str = "";
-		break;
-	case NAME_TRANS_MATCH_PREFIX:
-		match_str = " PREFIX";
-		break;
-	case NAME_TRANS_MATCH_SUFFIX:
-		match_str = " SUFFIX";
-		break;
-	default:
-		ERR(NULL, "Unknown name match type: %" PRIu8, args->match);
-		return SEPOL_ERR;
-	}
-	return strs_create_and_add(args->strs, "%s %s %s:%s %s \"%s\"%s;", 7,
+	return strs_create_and_add(args->strs, "%s %s %s:%s %s \"%s\";", 6,
 				   args->flavor, args->src, args->tgt,
 				   args->class,
 				   args->pdb->p_type_val_to_name[*otype - 1],
-				   name, match_str);
+				   name);
 }
 
 static int avtab_node_to_strs(struct policydb *pdb, avtab_key_t *key, avtab_datum_t *datum, struct strs *strs)
 {
 	int rc = SEPOL_OK;
 	uint32_t data = datum->data;
 	type_datum_t *type;
 	const char *flavor, *src, *tgt, *class, *perms, *new;
 
 	switch (0xFFF & key->specified) {
 	case AVTAB_ALLOWED:
 		flavor = "allow";
 		break;
 	case AVTAB_AUDITALLOW:
 		flavor = "auditallow";
 		break;
 	case AVTAB_AUDITDENY:
 		flavor = "dontaudit";
 		data = ~data;
 		break;
 	case AVTAB_XPERMS_ALLOWED:
 		flavor = "allowxperm";
 		break;
 	case AVTAB_XPERMS_AUDITALLOW:
 		flavor = "auditallowxperm";
 		break;
 	case AVTAB_XPERMS_DONTAUDIT:
 		flavor = "dontauditxperm";
 		break;
 	case AVTAB_TRANSITION:
 		flavor = "type_transition";
 		break;
 	case AVTAB_MEMBER:
 		flavor = "type_member";
 		break;
 	case AVTAB_CHANGE:
 		flavor = "type_change";
 		break;
 	default:
 		ERR(NULL, "Unknown avtab type: %i", key->specified);
 		return SEPOL_ERR;
 	}
 
 	src = pdb->p_type_val_to_name[key->source_type - 1];
 	tgt = pdb->p_type_val_to_name[key->target_type - 1];
 	if (key->source_type == key->target_type && !(key->specified & AVTAB_TYPE)) {
 		type = pdb->type_val_to_struct[key->source_type - 1];
 		if (type->flavor != TYPE_ATTRIB) {
 			tgt = "self";
 		}
 	}
 	class = pdb->p_class_val_to_name[key->target_class - 1];
 
 	if (key->specified & AVTAB_AV) {
 		perms = sepol_av_to_string(pdb, key->target_class, data);
 		if (perms == NULL) {
 			ERR(NULL, "Failed to generate permission string");
 			return SEPOL_ERR;
 		}
 		rc = strs_create_and_add(strs, "%s %s %s:%s { %s };", 5,
 					 flavor, src, tgt, class, perms + 1);
 	} else if (key->specified & AVTAB_XPERMS) {
 		perms = sepol_extended_perms_to_string(datum->xperms);
 		if (perms == NULL) {
 			ERR(NULL, "Failed to generate extended permission string");
 			return SEPOL_ERR;
 		}
 		rc = strs_create_and_add(strs, "%s %s %s:%s %s;", 5, flavor, src, tgt, class, perms);
 	} else if (key->specified & AVTAB_TRANSITION) {
 		if (datum->trans->otype) {
 			rc = strs_create_and_add(strs, "%s %s %s:%s %s;", 5,
 						 flavor, src, tgt, class,
 						 pdb->p_type_val_to_name[datum->trans->otype - 1]);
 			if (rc < 0)
 				return rc;
 		}
 		name_trans_to_strs_args_t args = {
 			.pdb = pdb,
 			.strs = strs,
 			.flavor = flavor,
 			.src = src,
 			.tgt = tgt,
 			.class = class,
-			.match = NAME_TRANS_MATCH_EXACT,
 		};
 		rc = hashtab_map(datum->trans->name_trans.table,
 				 name_trans_to_strs_helper, &args);
-		if (rc < 0)
-			return rc;
-		args.match = NAME_TRANS_MATCH_PREFIX;
-		rc = hashtab_map(datum->trans->prefix_trans.table,
-				 name_trans_to_strs_helper, &args);
-		if (rc < 0)
-			return rc;
-		args.match = NAME_TRANS_MATCH_SUFFIX;
-		rc = hashtab_map(datum->trans->suffix_trans.table,
-				 name_trans_to_strs_helper, &args);
 	} else {
 		new = pdb->p_type_val_to_name[data - 1];
 
 		rc = strs_create_and_add(strs, "%s %s %s:%s %s;", 5, flavor, src, tgt, class, new);
 	}
 
 	return rc;
 }
diff --git a/libsepol/src/policydb.c b/libsepol/src/policydb.c
index f1f6cec6..37bb97a1 100644
--- a/libsepol/src/policydb.c
+++ b/libsepol/src/policydb.c
@@ -62,432 +62,425 @@ const char * const policydb_target_strings[] = { POLICYDB_STRING, POLICYDB_XEN_S
 /* These need to be updated if SYM_NUM or OCON_NUM changes */
 static const struct policydb_compat_info policydb_compat[] = {
 	{
 	 .type = POLICY_KERN,
 	 .version = POLICYDB_VERSION_BOUNDARY,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_XEN_PCIDEVICE + 1,
 	 .target_platform = SEPOL_TARGET_XEN,
 	 },
 	{
 	 .type = POLICY_KERN,
 	 .version = POLICYDB_VERSION_XEN_DEVICETREE,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_XEN_DEVICETREE + 1,
 	 .target_platform = SEPOL_TARGET_XEN,
 	 },
 	{
 	 .type = POLICY_KERN,
 	 .version = POLICYDB_VERSION_BASE,
 	 .sym_num = SYM_NUM - 3,
 	 .ocon_num = OCON_FSUSE + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	 },
 	{
 	 .type = POLICY_KERN,
 	 .version = POLICYDB_VERSION_BOOL,
 	 .sym_num = SYM_NUM - 2,
 	 .ocon_num = OCON_FSUSE + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	 },
 	{
 	 .type = POLICY_KERN,
 	 .version = POLICYDB_VERSION_IPV6,
 	 .sym_num = SYM_NUM - 2,
 	 .ocon_num = OCON_NODE6 + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	 },
 	{
 	 .type = POLICY_KERN,
 	 .version = POLICYDB_VERSION_NLCLASS,
 	 .sym_num = SYM_NUM - 2,
 	 .ocon_num = OCON_NODE6 + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	 },
 	{
 	 .type = POLICY_KERN,
 	 .version = POLICYDB_VERSION_MLS,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_NODE6 + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	 },
 	{
 	 .type = POLICY_KERN,
 	 .version = POLICYDB_VERSION_AVTAB,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_NODE6 + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	 },
 	{
 	 .type = POLICY_KERN,
 	 .version = POLICYDB_VERSION_RANGETRANS,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_NODE6 + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	 },
 	{
 	 .type = POLICY_KERN,
 	 .version = POLICYDB_VERSION_POLCAP,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_NODE6 + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	 },
 	{
 	 .type = POLICY_KERN,
 	 .version = POLICYDB_VERSION_PERMISSIVE,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_NODE6 + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	 },
         {
 	 .type = POLICY_KERN,
 	 .version = POLICYDB_VERSION_BOUNDARY,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_NODE6 + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_KERN,
 	 .version = POLICYDB_VERSION_FILENAME_TRANS,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_NODE6 + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_KERN,
 	 .version = POLICYDB_VERSION_ROLETRANS,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_NODE6 + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_KERN,
 	 .version = POLICYDB_VERSION_NEW_OBJECT_DEFAULTS,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_NODE6 + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_KERN,
 	 .version = POLICYDB_VERSION_DEFAULT_TYPE,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_NODE6 + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_KERN,
 	 .version = POLICYDB_VERSION_CONSTRAINT_NAMES,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_NODE6 + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_KERN,
 	 .version = POLICYDB_VERSION_XPERMS_IOCTL,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_NODE6 + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_KERN,
 	 .version = POLICYDB_VERSION_INFINIBAND,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_IBENDPORT + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_KERN,
 	 .version = POLICYDB_VERSION_GLBLUB,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_IBENDPORT + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_KERN,
 	 .version = POLICYDB_VERSION_COMP_FTRANS,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_IBENDPORT + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_KERN,
 	 .version = POLICYDB_VERSION_AVTAB_FTRANS,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_IBENDPORT + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
-	{
-	 .type = POLICY_KERN,
-	 .version = POLICYDB_VERSION_PREFIX_SUFFIX,
-	 .sym_num = SYM_NUM,
-	 .ocon_num = OCON_IBENDPORT + 1,
-	 .target_platform = SEPOL_TARGET_SELINUX,
-	},
 	{
 	 .type = POLICY_BASE,
 	 .version = MOD_POLICYDB_VERSION_BASE,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_NODE6 + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	 },
 	{
 	 .type = POLICY_BASE,
 	 .version = MOD_POLICYDB_VERSION_MLS,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_NODE6 + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	 },
 	{
 	 .type = POLICY_BASE,
 	 .version = MOD_POLICYDB_VERSION_MLS_USERS,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_NODE6 + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	 },
 	{
 	 .type = POLICY_BASE,
 	 .version = MOD_POLICYDB_VERSION_POLCAP,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_NODE6 + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	 },
 	{
 	 .type = POLICY_BASE,
 	 .version = MOD_POLICYDB_VERSION_PERMISSIVE,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_NODE6 + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	 },
 	{
 	 .type = POLICY_BASE,
 	 .version = MOD_POLICYDB_VERSION_BOUNDARY,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_NODE6 + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_BASE,
 	 .version = MOD_POLICYDB_VERSION_BOUNDARY_ALIAS,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_NODE6 + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_BASE,
 	 .version = MOD_POLICYDB_VERSION_FILENAME_TRANS,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_NODE6 + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_BASE,
 	 .version = MOD_POLICYDB_VERSION_ROLETRANS,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_NODE6 + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_BASE,
 	 .version = MOD_POLICYDB_VERSION_ROLEATTRIB,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_NODE6 + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_BASE,
 	 .version = MOD_POLICYDB_VERSION_TUNABLE_SEP,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_NODE6 + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_BASE,
 	 .version = MOD_POLICYDB_VERSION_NEW_OBJECT_DEFAULTS,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_NODE6 + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_BASE,
 	 .version = MOD_POLICYDB_VERSION_DEFAULT_TYPE,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_NODE6 + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_BASE,
 	 .version = MOD_POLICYDB_VERSION_CONSTRAINT_NAMES,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_NODE6 + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_BASE,
 	 .version = MOD_POLICYDB_VERSION_XPERMS_IOCTL,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_NODE6 + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_BASE,
 	 .version = MOD_POLICYDB_VERSION_INFINIBAND,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_IBENDPORT + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_BASE,
 	 .version = MOD_POLICYDB_VERSION_GLBLUB,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_IBENDPORT + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_BASE,
 	 .version = MOD_POLICYDB_VERSION_SELF_TYPETRANS,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_IBENDPORT + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_BASE,
 	 .version = MOD_POLICYDB_VERSION_AVRULE_FTRANS,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = OCON_IBENDPORT + 1,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_MOD,
 	 .version = MOD_POLICYDB_VERSION_BASE,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = 0,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	 },
 	{
 	 .type = POLICY_MOD,
 	 .version = MOD_POLICYDB_VERSION_MLS,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = 0,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	 },
 	{
 	 .type = POLICY_MOD,
 	 .version = MOD_POLICYDB_VERSION_MLS_USERS,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = 0,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	 },
 	{
 	 .type = POLICY_MOD,
 	 .version = MOD_POLICYDB_VERSION_POLCAP,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = 0,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	 },
 	{
 	 .type = POLICY_MOD,
 	 .version = MOD_POLICYDB_VERSION_PERMISSIVE,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = 0,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	 },
 	{
 	 .type = POLICY_MOD,
 	 .version = MOD_POLICYDB_VERSION_BOUNDARY,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = 0,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_MOD,
 	 .version = MOD_POLICYDB_VERSION_BOUNDARY_ALIAS,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = 0,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_MOD,
 	 .version = MOD_POLICYDB_VERSION_FILENAME_TRANS,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = 0,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_MOD,
 	 .version = MOD_POLICYDB_VERSION_ROLETRANS,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = 0,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_MOD,
 	 .version = MOD_POLICYDB_VERSION_ROLEATTRIB,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = 0,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_MOD,
 	 .version = MOD_POLICYDB_VERSION_TUNABLE_SEP,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = 0,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_MOD,
 	 .version = MOD_POLICYDB_VERSION_NEW_OBJECT_DEFAULTS,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = 0,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_MOD,
 	 .version = MOD_POLICYDB_VERSION_DEFAULT_TYPE,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = 0,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_MOD,
 	 .version = MOD_POLICYDB_VERSION_CONSTRAINT_NAMES,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = 0,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_MOD,
 	 .version = MOD_POLICYDB_VERSION_XPERMS_IOCTL,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = 0,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_MOD,
 	 .version = MOD_POLICYDB_VERSION_INFINIBAND,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = 0,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_MOD,
 	 .version = MOD_POLICYDB_VERSION_GLBLUB,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = 0,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_MOD,
 	 .version = MOD_POLICYDB_VERSION_SELF_TYPETRANS,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = 0,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 	{
 	 .type = POLICY_MOD,
 	 .version = MOD_POLICYDB_VERSION_AVRULE_FTRANS,
 	 .sym_num = SYM_NUM,
 	 .ocon_num = 0,
 	 .target_platform = SEPOL_TARGET_SELINUX,
 	},
 };
 
 #if 0
diff --git a/libsepol/src/policydb_validate.c b/libsepol/src/policydb_validate.c
index 08b4a477..0b8e8eee 100644
--- a/libsepol/src/policydb_validate.c
+++ b/libsepol/src/policydb_validate.c
@@ -844,37 +844,30 @@ static int validate_name_trans_helper(hashtab_key_t k __attribute__ ((unused)),
 static int validate_avtab_key_and_datum(avtab_key_t *k, avtab_datum_t *d, void *args)
 {
 	map_arg_t *margs = args;
 
 	if (validate_avtab_key(k, 0, margs->policy, margs->flavors))
 		return -1;
 
 	if (k->specified & AVTAB_TRANSITION) {
 		/* if otype is set (non-zero), it must by a valid simple type */
 		if (d->trans->otype && validate_simpletype(d->trans->otype, margs->policy, margs->flavors))
 			return -1;
 
 		/* also each transition must be non empty */
 		if (!d->trans->otype &&
-		    !hashtab_nel(d->trans->name_trans.table) &&
-		    !hashtab_nel(d->trans->name_trans.table) &&
-		    !hashtab_nel(d->trans->prefix_trans.table) &&
-		    !hashtab_nel(d->trans->suffix_trans.table))
+		    !hashtab_nel(d->trans->name_trans.table))
 			return -1;
 
-		/* and each name transition must be also valid */
+		/* and each filename transition must be also valid */
 		if (hashtab_map(d->trans->name_trans.table,
-				validate_name_trans_helper, margs) ||
-		    hashtab_map(d->trans->prefix_trans.table,
-				validate_name_trans_helper, margs) ||
-		    hashtab_map(d->trans->suffix_trans.table,
 				validate_name_trans_helper, margs))
 			return -1;
 	} else if ((k->specified & AVTAB_TYPE) && validate_simpletype(d->data, margs->policy, margs->flavors)) {
 		return -1;
 	}
 
 	if ((k->specified & AVTAB_XPERMS) && validate_xperms(d->xperms))
 		return -1;
 
 	return 0;
 }
diff --git a/libsepol/src/write.c b/libsepol/src/write.c
index df47197c..d7f47c8d 100644
--- a/libsepol/src/write.c
+++ b/libsepol/src/write.c
@@ -129,52 +129,25 @@ static int avtab_trans_write_helper(hashtab_key_t hkey, hashtab_datum_t hdatum,
 static int avtab_trans_write(policydb_t *p, const avtab_trans_t *cur,
 			     policy_file_t *fp)
 {
 	size_t items;
 	uint32_t buf32[2];
 
 	if (p->policyvers >= POLICYDB_VERSION_AVTAB_FTRANS) {
-		/* write otype and number of name transitions */
+		/* write otype and number of filename transitions */
 		buf32[0] = cpu_to_le32(cur->otype);
 		buf32[1] = cpu_to_le32(hashtab_nel(cur->name_trans.table));
 		items = put_entry(buf32, sizeof(uint32_t), 2, fp);
 		if (items != 2)
 			return -1;
 
-		/* write name transitions */
-		if (hashtab_map(cur->name_trans.table,
-				avtab_trans_write_helper, fp))
-			return -1;
-
-		if (p->policyvers >= POLICYDB_VERSION_PREFIX_SUFFIX) {
-			/* write number of prefix transitions */
-			buf32[0] = cpu_to_le32(hashtab_nel(
-					cur->prefix_trans.table));
-			items = put_entry(buf32, sizeof(uint32_t), 1, fp);
-			if (items != 1)
-				return -1;
-
-			/* write prefix transitions */
-			if (hashtab_map(cur->prefix_trans.table,
-					avtab_trans_write_helper, fp))
-				return -1;
-
-			/* write number of suffix transitions */
-			buf32[0] = cpu_to_le32(hashtab_nel(
-					cur->suffix_trans.table));
-			items = put_entry(buf32, sizeof(uint32_t), 1, fp);
-			if (items != 1)
-				return -1;
-
-			/* write suffix transitions */
-			if (hashtab_map(cur->suffix_trans.table,
-					avtab_trans_write_helper, fp))
-				return -1;
-		}
+		/* write filename transitions */
+		return hashtab_map(cur->name_trans.table,
+				   avtab_trans_write_helper, fp);
 	} else if (cur->otype) {
 		buf32[0] = cpu_to_le32(cur->otype);
 		items = put_entry(buf32, sizeof(uint32_t), 1, fp);
 		if (items != 1)
 			return -1;
 	}
 	return 0;
 }
@@ -182,196 +155,184 @@ static int avtab_trans_write(policydb_t *p, const avtab_trans_t *cur,
 static int avtab_write_item(policydb_t * p,
 			    avtab_ptr_t cur, struct policy_file *fp,
 			    unsigned merge, unsigned commit, uint32_t * nel)
 {
 	avtab_ptr_t node;
 	uint8_t buf8;
 	uint16_t buf16[4];
 	uint32_t buf32[10], lookup, val;
 	size_t items, items2;
 	unsigned set;
 	unsigned int oldvers = (p->policy_type == POLICY_KERN
 				&& p->policyvers < POLICYDB_VERSION_AVTAB);
 	unsigned int i;
 
 	/*
 	 * skip entries which only contain filename transitions in versions
-	 * before filename transitions were moved to avtab,
-	 * skip entries which only contain prefix/suffix transitions in versions
-	 * before prefix/suffix filename transitions
+	 * before filename transitions were moved to avtab
 	 */
-	if (cur->key.specified & AVTAB_TRANSITION) {
-		if (p->policyvers < POLICYDB_VERSION_AVTAB_FTRANS &&
-		    cur->key.specified & AVTAB_TRANSITION &&
-		    !cur->datum.trans->otype) {
-                        /*
-                         * if oldvers, reduce nel, because this node will be
-                         * skipped
-			 */
-                        if (oldvers && nel)
-				(*nel)--;
-			return 0;
-		}
-		if (p->policyvers < POLICYDB_VERSION_PREFIX_SUFFIX &&
-		    !cur->datum.trans->otype &&
-		    !hashtab_nel(cur->datum.trans->name_trans.table))
-			return 0;
+	if (p->policyvers < POLICYDB_VERSION_AVTAB_FTRANS &&
+	    cur->key.specified & AVTAB_TRANSITION && !cur->datum.trans->otype) {
+		/* if oldvers, reduce nel, because this node will be skipped */
+		if (oldvers && nel)
+			(*nel)--;
+		return 0;
 	}
 
 	if (oldvers) {
 		/* Generate the old avtab format.
 		   Requires merging similar entries if uncond avtab. */
 		if (merge) {
 			if (cur->merged)
 				return POLICYDB_SUCCESS;	/* already merged by prior merge */
 		}
 
 		items = 1;	/* item 0 is used for the item count */
 		val = cur->key.source_type;
 		buf32[items++] = cpu_to_le32(val);
 		val = cur->key.target_type;
 		buf32[items++] = cpu_to_le32(val);
 		val = cur->key.target_class;
 		buf32[items++] = cpu_to_le32(val);
 
 		val = cur->key.specified & ~AVTAB_ENABLED;
 		if (cur->key.specified & AVTAB_ENABLED)
 			val |= AVTAB_ENABLED_OLD;
 		set = 1;
 
 		if (merge) {
 			/* Merge specifier values for all similar (av or type)
 			   entries that have the same key. */
 			if (val & AVTAB_AV)
 				lookup = AVTAB_AV;
 			else if (val & AVTAB_TYPE)
 				lookup = AVTAB_TYPE;
 			else
 				return POLICYDB_ERROR;
 			for (node = avtab_search_node_next(cur, lookup);
 			     node;
 			     node = avtab_search_node_next(node, lookup)) {
 				val |= (node->key.specified & ~AVTAB_ENABLED);
 				set++;
 				if (node->key.specified & AVTAB_ENABLED)
 					val |= AVTAB_ENABLED_OLD;
 			}
 		}
 
 		if (!(val & (AVTAB_AV | AVTAB_TYPE))) {
 			ERR(fp->handle, "null entry");
 			return POLICYDB_ERROR;
 		}
 		if ((val & AVTAB_AV) && (val & AVTAB_TYPE)) {
 			ERR(fp->handle, "entry has both access "
 			    "vectors and types");
 			return POLICYDB_ERROR;
 		}
 
 		buf32[items++] = cpu_to_le32(val);
 
 		if (merge) {
 			/* Include datums for all similar (av or type)
 			   entries that have the same key. */
 			for (i = 0;
 			     i < (sizeof(spec_order) / sizeof(spec_order[0]));
 			     i++) {
 				if (val & spec_order[i]) {
 					if (cur->key.specified & spec_order[i])
 						node = cur;
 					else {
 						node =
 						    avtab_search_node_next(cur,
 									   spec_order
 									   [i]);
 						if (nel)
 							(*nel)--;	/* one less node */
 					}
 
 					if (!node) {
 						ERR(fp->handle, "missing node");
 						return POLICYDB_ERROR;
 					}
 					uint32_t data =
 						node->key.specified & AVTAB_TRANSITION
 						? node->datum.trans->otype
 						: node->datum.data;
 					buf32[items++] = cpu_to_le32(data);
 					set--;
 					node->merged = 1;
 				}
 			}
 		} else {
 			uint32_t data = cur->key.specified & AVTAB_TRANSITION
 				? cur->datum.trans->otype
 				: cur->datum.data;
 			buf32[items++] = cpu_to_le32(data);
 			cur->merged = 1;
 			set--;
 		}
 
 		if (set) {
 			ERR(fp->handle, "data count wrong");
 			return POLICYDB_ERROR;
 		}
 
 		buf32[0] = cpu_to_le32(items - 1);
 
 		if (commit) {
 			/* Commit this item to the policy file. */
 			items2 = put_entry(buf32, sizeof(uint32_t), items, fp);
 			if (items != items2)
 				return POLICYDB_ERROR;
 		}
 
 		return POLICYDB_SUCCESS;
 	}
 
 	/* Generate the new avtab format. */
 	buf16[0] = cpu_to_le16(cur->key.source_type);
 	buf16[1] = cpu_to_le16(cur->key.target_type);
 	buf16[2] = cpu_to_le16(cur->key.target_class);
 	buf16[3] = cpu_to_le16(cur->key.specified);
 	items = put_entry(buf16, sizeof(uint16_t), 4, fp);
 	if (items != 4)
 		return POLICYDB_ERROR;
 	if ((p->policyvers < POLICYDB_VERSION_XPERMS_IOCTL) &&
 			(cur->key.specified & AVTAB_XPERMS)) {
 		ERR(fp->handle, "policy version %u does not support ioctl extended"
 				"permissions rules and one was specified", p->policyvers);
 		return POLICYDB_ERROR;
 	}
 
 	if (p->target_platform != SEPOL_TARGET_SELINUX &&
 			(cur->key.specified & AVTAB_XPERMS)) {
 		ERR(fp->handle, "Target platform %s does not support ioctl "
 				"extended permissions rules and one was specified",
 				policydb_target_strings[p->target_platform]);
 		return POLICYDB_ERROR;
 	}
 
 	if (cur->key.specified & AVTAB_XPERMS) {
 		buf8 = cur->datum.xperms->specified;
 		items = put_entry(&buf8, sizeof(uint8_t),1,fp);
 		if (items != 1)
 			return POLICYDB_ERROR;
 		buf8 = cur->datum.xperms->driver;
 		items = put_entry(&buf8, sizeof(uint8_t),1,fp);
 		if (items != 1)
 			return POLICYDB_ERROR;
 		for (i = 0; i < ARRAY_SIZE(cur->datum.xperms->perms); i++)
 			buf32[i] = cpu_to_le32(cur->datum.xperms->perms[i]);
 		items = put_entry(buf32, sizeof(uint32_t),8,fp);
 		if (items != 8)
 			return POLICYDB_ERROR;
 	} else if (cur->key.specified & AVTAB_TRANSITION) {
 		if (avtab_trans_write(p, cur->datum.trans, fp) < 0)
 			return POLICYDB_ERROR;
 	} else {
 		buf32[0] = cpu_to_le32(cur->datum.data);
 		items = put_entry(buf32, sizeof(uint32_t), 1, fp);
 		if (items != 1)
 			return POLICYDB_ERROR;
 	}
 
 	return POLICYDB_SUCCESS;
 }
@@ -389,100 +350,90 @@ static inline void avtab_reset_merged(avtab_t * a)
 static int avtab_write(struct policydb *p, avtab_t * a, struct policy_file *fp)
 {
 	unsigned int i;
 	int rc;
 	avtab_t expa;
 	avtab_ptr_t cur;
 	uint32_t nel;
 	size_t items;
 	unsigned int oldvers = (p->policy_type == POLICY_KERN
 				&& p->policyvers < POLICYDB_VERSION_AVTAB);
 
 	if (oldvers) {
 		/* Old avtab format.
 		   First, we need to expand attributes.  Then, we need to
 		   merge similar entries, so we need to track merged nodes 
 		   and compute the final nel. */
 		if (avtab_init(&expa))
 			return POLICYDB_ERROR;
 		if (expand_avtab(p, a, &expa)) {
 			rc = -1;
 			goto out;
 		}
 		a = &expa;
 		avtab_reset_merged(a);
 		nel = a->nel;
 	} else {
 		/*
 		 * New avtab format.  nel is good to go unless we need to skip
 		 * filename transitions.
 		 */
 		nel = a->nel;
-		for (i = 0; i < a->nslot; i++) {
-			for (cur = a->htable[i]; cur; cur = cur->next) {
-				if (!(cur->key.specified & AVTAB_TRANSITION))
-					continue;
-                                if (p->policyvers < POLICYDB_VERSION_AVTAB_FTRANS &&
-				    !cur->datum.trans->otype) {
-                                        /*
-                                         * entries containing only filename
-                                         * transitions are skipped and written
-                                         * out later
-                                         */
-                                        nel--;
-				} else if (p->policyvers < POLICYDB_VERSION_PREFIX_SUFFIX &&
-					   !cur->datum.trans->otype &&
-					   !hashtab_nel(cur->datum.trans->name_trans.table)) {
-					/*
-					 * entries containing only prefix/suffix
-					 * transitions are not supported in
-					 * previous versions
-					 */
-					nel--;
+		if (p->policyvers < POLICYDB_VERSION_AVTAB_FTRANS) {
+			/*
+			 * entries containing only filename transitions are
+			 * skipped and written out later
+			 */
+			for (i = 0; i < a->nslot; i++) {
+				for (cur = a->htable[i]; cur; cur = cur->next) {
+					if ((cur->key.specified
+					     & AVTAB_TRANSITION) &&
+					    !cur->datum.trans->otype)
+						nel--;
 				}
 			}
 		}
 		nel = cpu_to_le32(nel);
 		items = put_entry(&nel, sizeof(uint32_t), 1, fp);
 		if (items != 1)
 			return POLICYDB_ERROR;
 	}
 
 	for (i = 0; i < a->nslot; i++) {
 		for (cur = a->htable[i]; cur; cur = cur->next) {
 			/* If old format, compute final nel.
 			   If new format, write out the items. */
 			if (avtab_write_item(p, cur, fp, 1, !oldvers, &nel)) {
 				rc = -1;
 				goto out;
 			}
 		}
 	}
 
 	if (oldvers) {
 		/* Old avtab format.
 		   Write the computed nel value, then write the items. */
 		nel = cpu_to_le32(nel);
 		items = put_entry(&nel, sizeof(uint32_t), 1, fp);
 		if (items != 1) {
 			rc = -1;
 			goto out;
 		}
 		avtab_reset_merged(a);
 		for (i = 0; i < a->nslot; i++) {
 			for (cur = a->htable[i]; cur; cur = cur->next) {
 				if (avtab_write_item(p, cur, fp, 1, 1, NULL)) {
 					rc = -1;
 					goto out;
 				}
 			}
 		}
 	}
 
 	rc = 0;
       out:
 	if (oldvers)
 		avtab_destroy(&expa);
 	return rc;
 }
 
 /* policydb filename transition compatibility */
@@ -2569,248 +2520,228 @@ static int avtab_has_filename_transitions(avtab_t *a)
 	return 0;
 }
 
-static int avtab_has_prefix_suffix_filename_transitions(avtab_t *a)
-{
-	uint32_t i;
-	struct avtab_node *cur;
-	for (i = 0; i < a->nslot; i++) {
-		for (cur = a->htable[i]; cur; cur = cur->next) {
-			if (cur->key.specified & AVTAB_TRANSITION) {
-				if (hashtab_nel(cur->datum.trans->prefix_trans.table)
-				    || hashtab_nel(cur->datum.trans->suffix_trans.table))
-					return 1;
-			}
-		}
-	}
-	return 0;
-}
-
 /*
  * Write the configuration data in a policy database
  * structure to a policy database binary representation
  * file.
  */
 int policydb_write(policydb_t * p, struct policy_file *fp)
 {
 	unsigned int i, num_syms;
 	uint32_t buf[32], config;
 	size_t items, items2, len;
 	const struct policydb_compat_info *info;
 	struct policy_data pd;
 	const char *policydb_str;
 
 	if (p->unsupported_format)
 		return POLICYDB_UNSUPPORTED;
 
 	pd.fp = fp;
 	pd.p = p;
 
 	config = 0;
 	if (p->mls) {
 		if ((p->policyvers < POLICYDB_VERSION_MLS &&
 		    p->policy_type == POLICY_KERN) ||
 		    (p->policyvers < MOD_POLICYDB_VERSION_MLS &&
 		    p->policy_type == POLICY_BASE) ||
 		    (p->policyvers < MOD_POLICYDB_VERSION_MLS &&
 		    p->policy_type == POLICY_MOD)) {
 			ERR(fp->handle, "policy version %d cannot support MLS",
 			    p->policyvers);
 			return POLICYDB_ERROR;
 		}
 		config |= POLICYDB_CONFIG_MLS;
 	}
 
 	config |= (POLICYDB_CONFIG_UNKNOWN_MASK & p->handle_unknown);
 
 	/* Write the magic number and string identifiers. */
 	items = 0;
 	if (p->policy_type == POLICY_KERN) {
 		buf[items++] = cpu_to_le32(POLICYDB_MAGIC);
 		len = strlen(policydb_target_strings[p->target_platform]);
 		policydb_str = policydb_target_strings[p->target_platform];
 	} else {
 		buf[items++] = cpu_to_le32(POLICYDB_MOD_MAGIC);
 		len = strlen(POLICYDB_MOD_STRING);
 		policydb_str = POLICYDB_MOD_STRING;
 	}
 	buf[items++] = cpu_to_le32(len);
 	items2 = put_entry(buf, sizeof(uint32_t), items, fp);
 	if (items != items2)
 		return POLICYDB_ERROR;
 	items = put_entry(policydb_str, 1, len, fp);
 	if (items != len)
 		return POLICYDB_ERROR;
 
 	/* Write the version, config, and table sizes. */
 	items = 0;
 	info = policydb_lookup_compat(p->policyvers, p->policy_type,
 					p->target_platform);
 	if (!info) {
 		ERR(fp->handle, "compatibility lookup failed for policy "
 		    "version %d", p->policyvers);
 		return POLICYDB_ERROR;
 	}
 
 	if (p->policy_type != POLICY_KERN) {
 		buf[items++] = cpu_to_le32(p->policy_type);
 	}
 	buf[items++] = cpu_to_le32(p->policyvers);
 	buf[items++] = cpu_to_le32(config);
 	buf[items++] = cpu_to_le32(info->sym_num);
 	buf[items++] = cpu_to_le32(info->ocon_num);
 
 	items2 = put_entry(buf, sizeof(uint32_t), items, fp);
 	if (items != items2)
 		return POLICYDB_ERROR;
 
 	if (p->policy_type == POLICY_MOD) {
 		/* Write module name and version */
 		len = strlen(p->name);
 		buf[0] = cpu_to_le32(len);
 		items = put_entry(buf, sizeof(uint32_t), 1, fp);
 		if (items != 1)
 			return POLICYDB_ERROR;
 		items = put_entry(p->name, 1, len, fp);
 		if (items != len)
 			return POLICYDB_ERROR;
 		len = strlen(p->version);
 		buf[0] = cpu_to_le32(len);
 		items = put_entry(buf, sizeof(uint32_t), 1, fp);
 		if (items != 1)
 			return POLICYDB_ERROR;
 		items = put_entry(p->version, 1, len, fp);
 		if (items != len)
 			return POLICYDB_ERROR;
 	}
 
 	if ((p->policyvers >= POLICYDB_VERSION_POLCAP &&
 	     p->policy_type == POLICY_KERN) ||
 	    (p->policyvers >= MOD_POLICYDB_VERSION_POLCAP &&
 	     p->policy_type == POLICY_BASE) ||
 	    (p->policyvers >= MOD_POLICYDB_VERSION_POLCAP &&
 	     p->policy_type == POLICY_MOD)) {
 		if (ebitmap_write(&p->policycaps, fp) == -1)
 			return POLICYDB_ERROR;
 	}
 
 	if (p->policyvers < POLICYDB_VERSION_PERMISSIVE &&
 	    p->policy_type == POLICY_KERN) {
 		ebitmap_node_t *tnode;
 
 		ebitmap_for_each_positive_bit(&p->permissive_map, tnode, i) {
 			WARN(fp->handle, "Warning! Policy version %d cannot "
 			     "support permissive types, but some were defined",
 			     p->policyvers);
 			break;
 		}
 	}
 
 	if (p->policyvers >= POLICYDB_VERSION_PERMISSIVE &&
 	    p->policy_type == POLICY_KERN) {
 		if (ebitmap_write(&p->permissive_map, fp) == -1)
 			return POLICYDB_ERROR;
 	}
 
 	num_syms = info->sym_num;
 	for (i = 0; i < num_syms; i++) {
 		buf[0] = cpu_to_le32(p->symtab[i].nprim);
 		buf[1] = p->symtab[i].table->nel;
 
 		/*
 		 * A special case when writing type/attribute symbol table.
 		 * The kernel policy version less than 24 does not support
 		 * to load entries of attribute, so we have to re-calculate
 		 * the actual number of types except for attributes.
 		 */
 		if (i == SYM_TYPES &&
 		    p->policyvers < POLICYDB_VERSION_BOUNDARY &&
 		    p->policy_type == POLICY_KERN) {
 			hashtab_map(p->symtab[i].table, type_attr_uncount, &buf[1]);
 		}
 
 		/*
 		 * Another special case when writing role/attribute symbol
 		 * table, role attributes are redundant for policy.X, or
 		 * when the pp's version is not big enough. So deduct
 		 * their numbers from p_roles.table->nel.
 		 */
 		if ((i == SYM_ROLES) &&
 		    ((p->policy_type == POLICY_KERN) ||
 		     (p->policy_type != POLICY_KERN &&
 		      p->policyvers < MOD_POLICYDB_VERSION_ROLEATTRIB)))
 			(void)hashtab_map(p->symtab[i].table, role_attr_uncount, &buf[1]);
 
 		buf[1] = cpu_to_le32(buf[1]);
 		items = put_entry(buf, sizeof(uint32_t), 2, fp);
 		if (items != 2)
 			return POLICYDB_ERROR;
 		if (hashtab_map(p->symtab[i].table, write_f[i], &pd))
 			return POLICYDB_ERROR;
 	}
 
 	if (p->policy_type == POLICY_KERN) {
 		if (avtab_write(p, &p->te_avtab, fp))
 			return POLICYDB_ERROR;
-		if (avtab_has_prefix_suffix_filename_transitions(&p->te_avtab)) {
-			WARN(fp->handle,
-			     "Discarding filename prefix/suffix type transition rules");
-		}
 		if (p->policyvers < POLICYDB_VERSION_BOOL) {
 			if (p->p_bools.nprim)
 				WARN(fp->handle, "Discarding "
 				     "booleans and conditional rules");
 		} else {
 			if (cond_write_list(p, p->cond_list, fp))
 				return POLICYDB_ERROR;
 		}
 		if (role_trans_write(p, fp))
 			return POLICYDB_ERROR;
 		if (role_allow_write(p->role_allow, fp))
 			return POLICYDB_ERROR;
 		if (p->policyvers >= POLICYDB_VERSION_FILENAME_TRANS) {
 			if (p->policyvers < POLICYDB_VERSION_AVTAB_FTRANS &&
 			    avtab_filename_trans_write(p, &p->te_avtab, fp))
 				return POLICYDB_ERROR;
 		} else if (avtab_has_filename_transitions(&p->te_avtab)) {
 			WARN(fp->handle,
 			     "Discarding filename type transition rules");
 		}
 	} else {
 		if (avrule_block_write(p->global, num_syms, p, fp) == -1) {
 			return POLICYDB_ERROR;
 		}
 
 		for (i = 0; i < num_syms; i++) {
 			buf[0] = cpu_to_le32(p->scope[i].table->nel);
 			if (put_entry(buf, sizeof(uint32_t), 1, fp) != 1) {
 				return POLICYDB_ERROR;
 			}
 			if (hashtab_map(p->scope[i].table, scope_write, &pd))
 				return POLICYDB_ERROR;
 		}
 	}
 
 	if (ocontext_write(info, p, fp) == -1 || genfs_write(p, fp) == -1) {
 		return POLICYDB_ERROR;
 	}
 
 	if ((p->policyvers >= POLICYDB_VERSION_MLS
 	     && p->policy_type == POLICY_KERN)
 	    || (p->policyvers >= MOD_POLICYDB_VERSION_MLS
 		&& p->policyvers < MOD_POLICYDB_VERSION_RANGETRANS
 		&& p->policy_type == POLICY_BASE)) {
 		if (range_write(p, fp)) {
 			return POLICYDB_ERROR;
 		}
 	}
 
 	if (p->policy_type == POLICY_KERN
 	    && p->policyvers >= POLICYDB_VERSION_AVTAB) {
 		for (i = 0; i < p->p_types.nprim; i++) {
 			if (ebitmap_write(&p->type_attr_map[i], fp) == -1)
 				return POLICYDB_ERROR;
 		}
 	}
 
 	return POLICYDB_SUCCESS;
 }
