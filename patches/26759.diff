commit 9615bcf71f2a06900309062b6c218f5bf7ce795c
Author: John Stiles <johnstiles@google.com>
Date:   Fri Oct 30 13:21:30 2020 +0000

    Revert "Moved SkSL data back into node classes"
    
    This reverts commit f71e0be970978f04b4670b41c12ad0baffbb7fcd.
    
    Reason for revert: breaking Build-Debian10-EMCC-wasm-Release-WasmGMTests
    
    Original change's description:
    > Moved SkSL data back into node classes
    >
    > The original goal of this rearchitecture had been to move all of the
    > data into IRNode so that we could manage IRNode objects directly rather
    > than std::unique_ptr<IRNode>. Other changes have rendered that original
    > goal obsolete, so this is undoing most of the work that was done during
    > this rearchitecture.
    >
    > Change-Id: Ic56ffb17bb013c8b4884d710215f5345a481468a
    > Reviewed-on: https://skia-review.googlesource.com/c/skia/+/330297
    > Commit-Queue: Ethan Nicholas <ethannicholas@google.com>
    > Commit-Queue: John Stiles <johnstiles@google.com>
    > Reviewed-by: John Stiles <johnstiles@google.com>
    
    TBR=brianosman@google.com,ethannicholas@google.com,johnstiles@google.com
    
    Change-Id: I7a043c8e3e5c711164303cf160846d7cf20ddfbe
    No-Presubmit: true
    No-Tree-Checks: true
    No-Try: true
    Reviewed-on: https://skia-review.googlesource.com/c/skia/+/330736
    Reviewed-by: John Stiles <johnstiles@google.com>
    Commit-Queue: John Stiles <johnstiles@google.com>

diff --git a/gn/sksl.gni b/gn/sksl.gni
index 8e2a331d3c..e47593e14e 100644
--- a/gn/sksl.gni
+++ b/gn/sksl.gni
@@ -10,106 +10,107 @@ _include = get_path_info("../include", "abspath")
 skia_sksl_sources = [
   "$_include/private/SkSLSampleUsage.h",
   "$_src/sksl/SkSLASTFile.h",
   "$_src/sksl/SkSLASTNode.cpp",
   "$_src/sksl/SkSLASTNode.h",
   "$_src/sksl/SkSLAnalysis.cpp",
   "$_src/sksl/SkSLAnalysis.h",
   "$_src/sksl/SkSLByteCode.cpp",
   "$_src/sksl/SkSLByteCode.h",
   "$_src/sksl/SkSLByteCodeGenerator.cpp",
   "$_src/sksl/SkSLByteCodeGenerator.h",
   "$_src/sksl/SkSLCFGGenerator.cpp",
   "$_src/sksl/SkSLCFGGenerator.h",
   "$_src/sksl/SkSLCompiler.cpp",
   "$_src/sksl/SkSLCompiler.h",
   "$_src/sksl/SkSLContext.h",
   "$_src/sksl/SkSLDefines.h",
   "$_src/sksl/SkSLDehydrator.cpp",
   "$_src/sksl/SkSLDehydrator.h",
   "$_src/sksl/SkSLErrorReporter.h",
   "$_src/sksl/SkSLExternalValue.h",
   "$_src/sksl/SkSLFileOutputStream.h",
   "$_src/sksl/SkSLIRGenerator.cpp",
   "$_src/sksl/SkSLIRGenerator.h",
   "$_src/sksl/SkSLInliner.cpp",
   "$_src/sksl/SkSLInliner.h",
   "$_src/sksl/SkSLLexer.cpp",
   "$_src/sksl/SkSLLexer.h",
   "$_src/sksl/SkSLMemoryLayout.h",
   "$_src/sksl/SkSLMemoryPool.h",
   "$_src/sksl/SkSLParser.cpp",
   "$_src/sksl/SkSLParser.h",
   "$_src/sksl/SkSLPool.cpp",
   "$_src/sksl/SkSLPool.h",
   "$_src/sksl/SkSLPosition.h",
   "$_src/sksl/SkSLRehydrator.cpp",
   "$_src/sksl/SkSLRehydrator.h",
   "$_src/sksl/SkSLSampleUsage.cpp",
   "$_src/sksl/SkSLSectionAndParameterHelper.cpp",
   "$_src/sksl/SkSLSectionAndParameterHelper.h",
   "$_src/sksl/SkSLString.cpp",
   "$_src/sksl/SkSLString.h",
   "$_src/sksl/SkSLStringStream.h",
   "$_src/sksl/SkSLUtil.cpp",
   "$_src/sksl/SkSLUtil.h",
   "$_src/sksl/ir/SkSLBinaryExpression.h",
   "$_src/sksl/ir/SkSLBlock.h",
   "$_src/sksl/ir/SkSLBoolLiteral.h",
   "$_src/sksl/ir/SkSLBreakStatement.h",
   "$_src/sksl/ir/SkSLConstructor.cpp",
   "$_src/sksl/ir/SkSLConstructor.h",
   "$_src/sksl/ir/SkSLContinueStatement.h",
   "$_src/sksl/ir/SkSLDiscardStatement.h",
   "$_src/sksl/ir/SkSLDoStatement.h",
   "$_src/sksl/ir/SkSLEnum.h",
   "$_src/sksl/ir/SkSLExpression.h",
   "$_src/sksl/ir/SkSLExpressionStatement.h",
   "$_src/sksl/ir/SkSLExtension.h",
   "$_src/sksl/ir/SkSLExternalFunctionCall.h",
   "$_src/sksl/ir/SkSLExternalValueReference.h",
   "$_src/sksl/ir/SkSLField.h",
   "$_src/sksl/ir/SkSLFieldAccess.h",
   "$_src/sksl/ir/SkSLFloatLiteral.h",
   "$_src/sksl/ir/SkSLForStatement.h",
   "$_src/sksl/ir/SkSLFunctionCall.h",
   "$_src/sksl/ir/SkSLFunctionDeclaration.h",
   "$_src/sksl/ir/SkSLFunctionDefinition.h",
   "$_src/sksl/ir/SkSLFunctionReference.h",
+  "$_src/sksl/ir/SkSLIRNode.cpp",
   "$_src/sksl/ir/SkSLIRNode.h",
   "$_src/sksl/ir/SkSLIfStatement.h",
   "$_src/sksl/ir/SkSLIndexExpression.h",
   "$_src/sksl/ir/SkSLInlineMarker.h",
   "$_src/sksl/ir/SkSLIntLiteral.h",
   "$_src/sksl/ir/SkSLInterfaceBlock.h",
   "$_src/sksl/ir/SkSLLayout.h",
   "$_src/sksl/ir/SkSLModifiers.h",
   "$_src/sksl/ir/SkSLModifiersDeclaration.h",
   "$_src/sksl/ir/SkSLNop.h",
   "$_src/sksl/ir/SkSLNullLiteral.h",
   "$_src/sksl/ir/SkSLPostfixExpression.h",
   "$_src/sksl/ir/SkSLPrefixExpression.h",
   "$_src/sksl/ir/SkSLProgram.h",
   "$_src/sksl/ir/SkSLProgramElement.h",
   "$_src/sksl/ir/SkSLReturnStatement.h",
   "$_src/sksl/ir/SkSLSection.h",
   "$_src/sksl/ir/SkSLSetting.cpp",
   "$_src/sksl/ir/SkSLSetting.h",
   "$_src/sksl/ir/SkSLStatement.h",
   "$_src/sksl/ir/SkSLSwitchCase.h",
   "$_src/sksl/ir/SkSLSwitchStatement.h",
   "$_src/sksl/ir/SkSLSwizzle.h",
   "$_src/sksl/ir/SkSLSymbol.h",
   "$_src/sksl/ir/SkSLSymbolAlias.h",
   "$_src/sksl/ir/SkSLSymbolTable.cpp",
   "$_src/sksl/ir/SkSLSymbolTable.h",
   "$_src/sksl/ir/SkSLTernaryExpression.h",
   "$_src/sksl/ir/SkSLType.cpp",
   "$_src/sksl/ir/SkSLType.h",
   "$_src/sksl/ir/SkSLTypeReference.h",
   "$_src/sksl/ir/SkSLUnresolvedFunction.h",
   "$_src/sksl/ir/SkSLVarDeclarations.h",
   "$_src/sksl/ir/SkSLVariable.h",
   "$_src/sksl/ir/SkSLVariableReference.cpp",
   "$_src/sksl/ir/SkSLVariableReference.h",
   "$_src/sksl/ir/SkSLWhileStatement.h",
 ]
diff --git a/src/sksl/SkSLAnalysis.cpp b/src/sksl/SkSLAnalysis.cpp
index 468db172ea..0fe64b83f7 100644
--- a/src/sksl/SkSLAnalysis.cpp
+++ b/src/sksl/SkSLAnalysis.cpp
@@ -456,69 +456,69 @@ template <typename PROG, typename EXPR, typename STMT, typename ELEM>
 bool TProgramVisitor<PROG, EXPR, STMT, ELEM>::visitExpression(EXPR e) {
     switch (e.kind()) {
         case Expression::Kind::kBoolLiteral:
         case Expression::Kind::kDefined:
         case Expression::Kind::kExternalValue:
         case Expression::Kind::kFloatLiteral:
         case Expression::Kind::kFunctionReference:
         case Expression::Kind::kIntLiteral:
         case Expression::Kind::kNullLiteral:
         case Expression::Kind::kSetting:
         case Expression::Kind::kTypeReference:
         case Expression::Kind::kVariableReference:
             // Leaf expressions return false
             return false;
 
         case Expression::Kind::kBinary: {
             auto& b = e.template as<BinaryExpression>();
-            return (b.left() && this->visitExpression(*b.left())) ||
-                   (b.right() && this->visitExpression(*b.right()));
+            return (b.leftPointer() && this->visitExpression(b.left())) ||
+                   (b.rightPointer() && this->visitExpression(b.right()));
         }
         case Expression::Kind::kConstructor: {
             auto& c = e.template as<Constructor>();
             for (auto& arg : c.arguments()) {
                 if (this->visitExpression(*arg)) { return true; }
             }
             return false;
         }
         case Expression::Kind::kExternalFunctionCall: {
             auto& c = e.template as<ExternalFunctionCall>();
             for (auto& arg : c.arguments()) {
                 if (this->visitExpression(*arg)) { return true; }
             }
             return false;
         }
         case Expression::Kind::kFieldAccess:
             return this->visitExpression(*e.template as<FieldAccess>().base());
 
         case Expression::Kind::kFunctionCall: {
             auto& c = e.template as<FunctionCall>();
             for (auto& arg : c.arguments()) {
                 if (arg && this->visitExpression(*arg)) { return true; }
             }
             return false;
         }
         case Expression::Kind::kIndex: {
             auto& i = e.template as<IndexExpression>();
             return this->visitExpression(*i.base()) || this->visitExpression(*i.index());
         }
         case Expression::Kind::kPostfix:
             return this->visitExpression(*e.template as<PostfixExpression>().operand());
 
         case Expression::Kind::kPrefix:
             return this->visitExpression(*e.template as<PrefixExpression>().operand());
 
         case Expression::Kind::kSwizzle: {
             auto& s = e.template as<Swizzle>();
             return s.base() && this->visitExpression(*s.base());
         }
 
         case Expression::Kind::kTernary: {
             auto& t = e.template as<TernaryExpression>();
             return this->visitExpression(*t.test()) ||
                    (t.ifTrue() && this->visitExpression(*t.ifTrue())) ||
                    (t.ifFalse() && this->visitExpression(*t.ifFalse()));
         }
         default:
             SkUNREACHABLE;
     }
 }
@@ -527,76 +527,76 @@ template <typename PROG, typename EXPR, typename STMT, typename ELEM>
 bool TProgramVisitor<PROG, EXPR, STMT, ELEM>::visitStatement(STMT s) {
     switch (s.kind()) {
         case Statement::Kind::kBreak:
         case Statement::Kind::kContinue:
         case Statement::Kind::kDiscard:
         case Statement::Kind::kInlineMarker:
         case Statement::Kind::kNop:
             // Leaf statements just return false
             return false;
 
         case Statement::Kind::kBlock:
             for (auto& stmt : s.template as<Block>().children()) {
                 if (stmt && this->visitStatement(*stmt)) {
                     return true;
                 }
             }
             return false;
 
         case Statement::Kind::kDo: {
             auto& d = s.template as<DoStatement>();
             return this->visitExpression(*d.test()) || this->visitStatement(*d.statement());
         }
         case Statement::Kind::kExpression:
             return this->visitExpression(*s.template as<ExpressionStatement>().expression());
 
         case Statement::Kind::kFor: {
             auto& f = s.template as<ForStatement>();
             return (f.initializer() && this->visitStatement(*f.initializer())) ||
                    (f.test() && this->visitExpression(*f.test())) ||
                    (f.next() && this->visitExpression(*f.next())) ||
                    this->visitStatement(*f.statement());
         }
         case Statement::Kind::kIf: {
             auto& i = s.template as<IfStatement>();
             return (i.test() && this->visitExpression(*i.test())) ||
                    (i.ifTrue() && this->visitStatement(*i.ifTrue())) ||
                    (i.ifFalse() && this->visitStatement(*i.ifFalse()));
         }
         case Statement::Kind::kReturn: {
             auto& r = s.template as<ReturnStatement>();
             return r.expression() && this->visitExpression(*r.expression());
         }
         case Statement::Kind::kSwitch: {
             auto& sw = s.template as<SwitchStatement>();
             if (this->visitExpression(*sw.value())) {
                 return true;
             }
             for (const auto& c : sw.cases()) {
-                if (c->value() && this->visitExpression(*c->value())) {
+                if (c.value() && this->visitExpression(*c.value())) {
                     return true;
                 }
-                for (auto& st : c->statements()) {
+                for (auto& st : c.statements()) {
                     if (st && this->visitStatement(*st)) {
                         return true;
                     }
                 }
             }
             return false;
         }
         case Statement::Kind::kVarDeclaration: {
             auto& v = s.template as<VarDeclaration>();
-            for (const std::unique_ptr<Expression>& size : v.sizes()) {
-                if (size && this->visitExpression(*size)) {
+            for (int i = 0; i < v.sizeCount(); ++i) {
+                if (v.size(i) && this->visitExpression(*v.size(i))) {
                     return true;
                 }
             }
             return v.value() && this->visitExpression(*v.value());
         }
         case Statement::Kind::kWhile: {
             auto& w = s.template as<WhileStatement>();
             return this->visitExpression(*w.test()) || this->visitStatement(*w.statement());
         }
         default:
             SkUNREACHABLE;
     }
 }
diff --git a/src/sksl/SkSLByteCodeGenerator.cpp b/src/sksl/SkSLByteCodeGenerator.cpp
index f24f0a5167..649c9db493 100644
--- a/src/sksl/SkSLByteCodeGenerator.cpp
+++ b/src/sksl/SkSLByteCodeGenerator.cpp
@@ -680,220 +680,220 @@ void ByteCodeGenerator::writeTypedInstruction(const Type& type,
 }
 
 bool ByteCodeGenerator::writeBinaryExpression(const BinaryExpression& b, bool discard) {
-    const Expression& left = *b.left();
-    const Expression& right = *b.right();
+    const Expression& left = b.left();
+    const Expression& right = b.right();
     Token::Kind op = b.getOperator();
     if (op == Token::Kind::TK_EQ) {
         std::unique_ptr<LValue> lvalue = this->getLValue(left);
         this->writeExpression(right);
         lvalue->store(discard);
         discard = false;
         return discard;
     }
     const Type& lType = left.type();
     const Type& rType = right.type();
     bool lVecOrMtx = (lType.typeKind() == Type::TypeKind::kVector ||
                       lType.typeKind() == Type::TypeKind::kMatrix);
     bool rVecOrMtx = (rType.typeKind() == Type::TypeKind::kVector ||
                       rType.typeKind() == Type::TypeKind::kMatrix);
     std::unique_ptr<LValue> lvalue;
     if (Compiler::IsAssignment(op)) {
         lvalue = this->getLValue(left);
         lvalue->load();
         op = Compiler::RemoveAssignment(op);
     } else {
         this->writeExpression(left);
         if (!lVecOrMtx && rVecOrMtx) {
             for (int i = SlotCount(rType); i > 1; --i) {
                 this->write(ByteCodeInstruction::kDup, 1);
             }
         }
     }
     int count = std::max(SlotCount(lType), SlotCount(rType));
     SkDEBUGCODE(TypeCategory tc = type_category(lType));
     switch (op) {
         case Token::Kind::TK_LOGICALAND: {
             SkASSERT(tc == SkSL::TypeCategory::kBool && count == 1);
             this->write(ByteCodeInstruction::kDup, 1);
             this->write(ByteCodeInstruction::kMaskPush);
             this->write(ByteCodeInstruction::kBranchIfAllFalse);
             DeferredLocation falseLocation(this);
             this->writeExpression(right);
             this->write(ByteCodeInstruction::kAndB, 1);
             falseLocation.set();
             this->write(ByteCodeInstruction::kMaskPop);
             return false;
         }
         case Token::Kind::TK_LOGICALOR: {
             SkASSERT(tc == SkSL::TypeCategory::kBool && count == 1);
             this->write(ByteCodeInstruction::kDup, 1);
             this->write(ByteCodeInstruction::kNotB, 1);
             this->write(ByteCodeInstruction::kMaskPush);
             this->write(ByteCodeInstruction::kBranchIfAllFalse);
             DeferredLocation falseLocation(this);
             this->writeExpression(right);
             this->write(ByteCodeInstruction::kOrB, 1);
             falseLocation.set();
             this->write(ByteCodeInstruction::kMaskPop);
             return false;
         }
         case Token::Kind::TK_SHL:
         case Token::Kind::TK_SHR: {
             SkASSERT(count == 1 && (tc == SkSL::TypeCategory::kSigned ||
                                     tc == SkSL::TypeCategory::kUnsigned));
             if (!right.isCompileTimeConstant()) {
                 fErrors.error(right.fOffset, "Shift amounts must be constant");
                 return false;
             }
             int64_t shift = right.getConstantInt();
             if (shift < 0 || shift > 31) {
                 fErrors.error(right.fOffset, "Shift amount out of range");
                 return false;
             }
 
             if (op == Token::Kind::TK_SHL) {
                 this->write(ByteCodeInstruction::kShiftLeft);
             } else {
                 this->write(type_category(lType) == TypeCategory::kSigned
                                 ? ByteCodeInstruction::kShiftRightS
                                 : ByteCodeInstruction::kShiftRightU);
             }
             this->write8(shift);
             return false;
         }
 
         default:
             break;
     }
     this->writeExpression(right);
     if (lVecOrMtx && !rVecOrMtx) {
         for (int i = SlotCount(lType); i > 1; --i) {
             this->write(ByteCodeInstruction::kDup, 1);
         }
     }
     // Special case for M*V, V*M, M*M (but not V*V!)
     if (op == Token::Kind::TK_STAR && lVecOrMtx && rVecOrMtx &&
         !(lType.typeKind() == Type::TypeKind::kVector &&
           rType.typeKind() == Type::TypeKind::kVector)) {
         this->write(ByteCodeInstruction::kMatrixMultiply,
                     SlotCount(b.type()) - (SlotCount(lType) + SlotCount(rType)));
         int rCols = rType.columns(),
             rRows = rType.rows(),
             lCols = lType.columns(),
             lRows = lType.rows();
         // M*V treats the vector as a column
         if (rType.typeKind() == Type::TypeKind::kVector) {
             std::swap(rCols, rRows);
         }
         SkASSERT(lCols == rRows);
         SkASSERT(SlotCount(b.type()) == lRows * rCols);
         this->write8(lCols);
         this->write8(lRows);
         this->write8(rCols);
     } else {
         switch (op) {
             case Token::Kind::TK_EQEQ:
                 this->writeTypedInstruction(lType, ByteCodeInstruction::kCompareIEQ,
                                             ByteCodeInstruction::kCompareIEQ,
                                             ByteCodeInstruction::kCompareFEQ,
                                             count);
                 // Collapse to a single bool
                 for (int i = count; i > 1; --i) {
                     this->write(ByteCodeInstruction::kAndB, 1);
                 }
                 break;
             case Token::Kind::TK_GT:
                 this->writeTypedInstruction(lType, ByteCodeInstruction::kCompareSGT,
                                             ByteCodeInstruction::kCompareUGT,
                                             ByteCodeInstruction::kCompareFGT,
                                             count);
                 break;
             case Token::Kind::TK_GTEQ:
                 this->writeTypedInstruction(lType, ByteCodeInstruction::kCompareSGTEQ,
                                             ByteCodeInstruction::kCompareUGTEQ,
                                             ByteCodeInstruction::kCompareFGTEQ,
                                             count);
                 break;
             case Token::Kind::TK_LT:
                 this->writeTypedInstruction(lType, ByteCodeInstruction::kCompareSLT,
                                             ByteCodeInstruction::kCompareULT,
                                             ByteCodeInstruction::kCompareFLT,
                                             count);
                 break;
             case Token::Kind::TK_LTEQ:
                 this->writeTypedInstruction(lType, ByteCodeInstruction::kCompareSLTEQ,
                                             ByteCodeInstruction::kCompareULTEQ,
                                             ByteCodeInstruction::kCompareFLTEQ,
                                             count);
                 break;
             case Token::Kind::TK_MINUS:
                 this->writeTypedInstruction(lType, ByteCodeInstruction::kSubtractI,
                                             ByteCodeInstruction::kSubtractI,
                                             ByteCodeInstruction::kSubtractF,
                                             count);
                 break;
             case Token::Kind::TK_NEQ:
                 this->writeTypedInstruction(lType, ByteCodeInstruction::kCompareINEQ,
                                             ByteCodeInstruction::kCompareINEQ,
                                             ByteCodeInstruction::kCompareFNEQ,
                                             count);
                 // Collapse to a single bool
                 for (int i = count; i > 1; --i) {
                     this->write(ByteCodeInstruction::kOrB, 1);
                 }
                 break;
             case Token::Kind::TK_PERCENT:
                 this->writeTypedInstruction(lType, ByteCodeInstruction::kRemainderS,
                                             ByteCodeInstruction::kRemainderU,
                                             ByteCodeInstruction::kRemainderF,
                                             count);
                 break;
             case Token::Kind::TK_PLUS:
                 this->writeTypedInstruction(lType, ByteCodeInstruction::kAddI,
                                             ByteCodeInstruction::kAddI,
                                             ByteCodeInstruction::kAddF,
                                             count);
                 break;
             case Token::Kind::TK_SLASH:
                 this->writeTypedInstruction(lType, ByteCodeInstruction::kDivideS,
                                             ByteCodeInstruction::kDivideU,
                                             ByteCodeInstruction::kDivideF,
                                             count);
                 break;
             case Token::Kind::TK_STAR:
                 this->writeTypedInstruction(lType, ByteCodeInstruction::kMultiplyI,
                                             ByteCodeInstruction::kMultiplyI,
                                             ByteCodeInstruction::kMultiplyF,
                                             count);
                 break;
 
             case Token::Kind::TK_LOGICALXOR:
                 SkASSERT(tc == SkSL::TypeCategory::kBool);
                 this->write(ByteCodeInstruction::kXorB, count);
                 break;
 
             case Token::Kind::TK_BITWISEAND:
                 SkASSERT(tc == SkSL::TypeCategory::kSigned || tc == SkSL::TypeCategory::kUnsigned);
                 this->write(ByteCodeInstruction::kAndB, count);
                 break;
             case Token::Kind::TK_BITWISEOR:
                 SkASSERT(tc == SkSL::TypeCategory::kSigned || tc == SkSL::TypeCategory::kUnsigned);
                 this->write(ByteCodeInstruction::kOrB, count);
                 break;
             case Token::Kind::TK_BITWISEXOR:
                 SkASSERT(tc == SkSL::TypeCategory::kSigned || tc == SkSL::TypeCategory::kUnsigned);
                 this->write(ByteCodeInstruction::kXorB, count);
                 break;
 
             default:
                 fErrors.error(b.fOffset, SkSL::String::printf("Unsupported binary operator '%s'",
                                                               Compiler::OperatorName(op)));
                 break;
         }
     }
     if (lvalue) {
         lvalue->store(discard);
         discard = false;
     }
     return discard;
 }
diff --git a/src/sksl/SkSLCFGGenerator.cpp b/src/sksl/SkSLCFGGenerator.cpp
index 0b1e49373b..540490da2d 100644
--- a/src/sksl/SkSLCFGGenerator.cpp
+++ b/src/sksl/SkSLCFGGenerator.cpp
@@ -178,100 +178,100 @@ bool BasicBlock::tryRemoveLValueBefore(std::vector<BasicBlock::Node>::iterator*
 bool BasicBlock::tryRemoveExpression(std::vector<BasicBlock::Node>::iterator* iter) {
     Expression* expr = (*iter)->expression()->get();
     switch (expr->kind()) {
         case Expression::Kind::kBinary: {
             BinaryExpression& b = expr->as<BinaryExpression>();
             if (b.getOperator() == Token::Kind::TK_EQ) {
-                if (!this->tryRemoveLValueBefore(iter, b.left().get())) {
+                if (!this->tryRemoveLValueBefore(iter, &b.left())) {
                     return false;
                 }
-            } else if (!this->tryRemoveExpressionBefore(iter, b.left().get())) {
+            } else if (!this->tryRemoveExpressionBefore(iter, &b.left())) {
                 return false;
             }
-            if (!this->tryRemoveExpressionBefore(iter, b.right().get())) {
+            if (!this->tryRemoveExpressionBefore(iter, &b.right())) {
                 return false;
             }
             SkASSERT((*iter)->expression()->get() == expr);
             *iter = fNodes.erase(*iter);
             return true;
         }
         case Expression::Kind::kTernary: {
             // ternaries cross basic block boundaries, must regenerate the CFG to remove it
             return false;
         }
         case Expression::Kind::kFieldAccess: {
             FieldAccess& f = expr->as<FieldAccess>();
             if (!this->tryRemoveExpressionBefore(iter, f.base().get())) {
                 return false;
             }
             *iter = fNodes.erase(*iter);
             return true;
         }
         case Expression::Kind::kSwizzle: {
             Swizzle& s = expr->as<Swizzle>();
             if (s.base() && !this->tryRemoveExpressionBefore(iter, s.base().get())) {
                 return false;
             }
             *iter = fNodes.erase(*iter);
             return true;
         }
         case Expression::Kind::kIndex: {
             IndexExpression& idx = expr->as<IndexExpression>();
             if (!this->tryRemoveExpressionBefore(iter, idx.base().get())) {
                 return false;
             }
             if (!this->tryRemoveExpressionBefore(iter, idx.index().get())) {
                 return false;
             }
             *iter = fNodes.erase(*iter);
             return true;
         }
         case Expression::Kind::kConstructor: {
             Constructor& c = expr->as<Constructor>();
             for (auto& arg : c.arguments()) {
                 if (!this->tryRemoveExpressionBefore(iter, arg.get())) {
                     return false;
                 }
                 SkASSERT((*iter)->expression()->get() == expr);
             }
             *iter = fNodes.erase(*iter);
             return true;
         }
         case Expression::Kind::kFunctionCall: {
             FunctionCall& f = expr->as<FunctionCall>();
             for (auto& arg : f.arguments()) {
                 if (!this->tryRemoveExpressionBefore(iter, arg.get())) {
                     return false;
                 }
                 SkASSERT((*iter)->expression()->get() == expr);
             }
             *iter = fNodes.erase(*iter);
             return true;
         }
         case Expression::Kind::kPrefix:
             if (!this->tryRemoveExpressionBefore(iter,
                                                  expr->as<PrefixExpression>().operand().get())) {
                 return false;
             }
             *iter = fNodes.erase(*iter);
             return true;
         case Expression::Kind::kPostfix:
             if (!this->tryRemoveExpressionBefore(iter,
                                                  expr->as<PrefixExpression>().operand().get())) {
                 return false;
             }
             *iter = fNodes.erase(*iter);
             return true;
         case Expression::Kind::kBoolLiteral:  // fall through
         case Expression::Kind::kFloatLiteral: // fall through
         case Expression::Kind::kIntLiteral:   // fall through
         case Expression::Kind::kSetting:      // fall through
         case Expression::Kind::kVariableReference:
             *iter = fNodes.erase(*iter);
             return true;
         default:
 #ifdef SK_DEBUG
             ABORT("unhandled expression: %s\n", expr->description().c_str());
 #endif
             return false;
     }
 }
@@ -279,52 +279,52 @@ bool BasicBlock::tryRemoveExpression(std::vector<BasicBlock::Node>::iterator* it
 bool BasicBlock::tryInsertExpression(std::vector<BasicBlock::Node>::iterator* iter,
                                      std::unique_ptr<Expression>* expr) {
     switch ((*expr)->kind()) {
         case Expression::Kind::kBinary: {
             BinaryExpression& b = expr->get()->as<BinaryExpression>();
-            if (!this->tryInsertExpression(iter, &b.right())) {
+            if (!this->tryInsertExpression(iter, &b.rightPointer())) {
                 return false;
             }
 
             ++(*iter);
-            if (!this->tryInsertExpression(iter, &b.left())) {
+            if (!this->tryInsertExpression(iter, &b.leftPointer())) {
                 return false;
             }
             ++(*iter);
             *iter = fNodes.insert(*iter,
                                   BasicBlock::MakeExpression(expr, /*constantPropagation=*/true));
             return true;
         }
         case Expression::Kind::kBoolLiteral:  // fall through
         case Expression::Kind::kFloatLiteral: // fall through
         case Expression::Kind::kIntLiteral:   // fall through
         case Expression::Kind::kVariableReference: {
             *iter = fNodes.insert(*iter,
                                   BasicBlock::MakeExpression(expr, /*constantPropagation=*/true));
             return true;
         }
         case Expression::Kind::kConstructor: {
             Constructor& c = expr->get()->as<Constructor>();
             for (auto& arg : c.arguments()) {
                 if (!this->tryInsertExpression(iter, &arg)) {
                     return false;
                 }
                 ++(*iter);
             }
             *iter = fNodes.insert(*iter,
                                   BasicBlock::MakeExpression(expr, /*constantPropagation=*/true));
             return true;
         }
         case Expression::Kind::kSwizzle: {
             Swizzle& s = expr->get()->as<Swizzle>();
             if (!this->tryInsertExpression(iter, &s.base())) {
                 return false;
             }
             ++(*iter);
             *iter = fNodes.insert(*iter,
                                   BasicBlock::MakeExpression(expr, /*constantPropagation=*/true));
             return true;
         }
         default:
             return false;
     }
 }
@@ -332,124 +332,124 @@ bool BasicBlock::tryInsertExpression(std::vector<BasicBlock::Node>::iterator* it
 void CFGGenerator::addExpression(CFG& cfg, std::unique_ptr<Expression>* e, bool constantPropagate) {
     SkASSERT(e);
     switch ((*e)->kind()) {
         case Expression::Kind::kBinary: {
             BinaryExpression& b = e->get()->as<BinaryExpression>();
             Token::Kind op = b.getOperator();
             switch (op) {
                 case Token::Kind::TK_LOGICALAND: // fall through
                 case Token::Kind::TK_LOGICALOR: {
                     // this isn't as precise as it could be -- we don't bother to track that if we
                     // early exit from a logical and/or, we know which branch of an 'if' we're going
                     // to hit -- but it won't make much difference in practice.
-                    this->addExpression(cfg, &b.left(), constantPropagate);
+                    this->addExpression(cfg, &b.leftPointer(), constantPropagate);
                     BlockId start = cfg.fCurrent;
                     cfg.newBlock();
-                    this->addExpression(cfg, &b.right(), constantPropagate);
+                    this->addExpression(cfg, &b.rightPointer(), constantPropagate);
                     cfg.newBlock();
                     cfg.addExit(start, cfg.fCurrent);
                     cfg.currentBlock().fNodes.push_back(
                             BasicBlock::MakeExpression(e, constantPropagate));
                     break;
                 }
                 case Token::Kind::TK_EQ: {
-                    this->addExpression(cfg, &b.right(), constantPropagate);
-                    this->addLValue(cfg, &b.left());
+                    this->addExpression(cfg, &b.rightPointer(), constantPropagate);
+                    this->addLValue(cfg, &b.leftPointer());
                     cfg.currentBlock().fNodes.push_back(
                             BasicBlock::MakeExpression(e, constantPropagate));
                     break;
                 }
                 default:
-                    this->addExpression(cfg, &b.left(),
+                    this->addExpression(cfg, &b.leftPointer(),
                                         !Compiler::IsAssignment(b.getOperator()));
-                    this->addExpression(cfg, &b.right(), constantPropagate);
+                    this->addExpression(cfg, &b.rightPointer(), constantPropagate);
                     cfg.currentBlock().fNodes.push_back(
                             BasicBlock::MakeExpression(e, constantPropagate));
             }
             break;
         }
         case Expression::Kind::kConstructor: {
             Constructor& c = e->get()->as<Constructor>();
             for (auto& arg : c.arguments()) {
                 this->addExpression(cfg, &arg, constantPropagate);
             }
             cfg.currentBlock().fNodes.push_back(BasicBlock::MakeExpression(e, constantPropagate));
             break;
         }
         case Expression::Kind::kExternalFunctionCall: {
             ExternalFunctionCall& c = e->get()->as<ExternalFunctionCall>();
             for (auto& arg : c.arguments()) {
                 this->addExpression(cfg, &arg, constantPropagate);
             }
             cfg.currentBlock().fNodes.push_back(BasicBlock::MakeExpression(e, constantPropagate));
             break;
         }
         case Expression::Kind::kFunctionCall: {
             FunctionCall& c = e->get()->as<FunctionCall>();
             for (auto& arg : c.arguments()) {
                 this->addExpression(cfg, &arg, constantPropagate);
             }
             cfg.currentBlock().fNodes.push_back(BasicBlock::MakeExpression(e, constantPropagate));
             break;
         }
         case Expression::Kind::kFieldAccess: {
             this->addExpression(cfg, &e->get()->as<FieldAccess>().base(), constantPropagate);
             cfg.currentBlock().fNodes.push_back(BasicBlock::MakeExpression(e, constantPropagate));
             break;
         }
         case Expression::Kind::kIndex: {
             IndexExpression& indexExpr = e->get()->as<IndexExpression>();
 
             this->addExpression(cfg, &indexExpr.base(), constantPropagate);
             this->addExpression(cfg, &indexExpr.index(), constantPropagate);
             cfg.currentBlock().fNodes.push_back(BasicBlock::MakeExpression(e, constantPropagate));
             break;
         }
         case Expression::Kind::kPrefix: {
             PrefixExpression& p = e->get()->as<PrefixExpression>();
             this->addExpression(cfg, &p.operand(), constantPropagate &&
                                                   p.getOperator() != Token::Kind::TK_PLUSPLUS &&
                                                   p.getOperator() != Token::Kind::TK_MINUSMINUS);
             cfg.currentBlock().fNodes.push_back(BasicBlock::MakeExpression(e, constantPropagate));
             break;
         }
         case Expression::Kind::kPostfix:
             this->addExpression(cfg, &e->get()->as<PostfixExpression>().operand(), false);
             cfg.currentBlock().fNodes.push_back(BasicBlock::MakeExpression(e, constantPropagate));
             break;
         case Expression::Kind::kSwizzle:
             this->addExpression(cfg, &e->get()->as<Swizzle>().base(), constantPropagate);
             cfg.currentBlock().fNodes.push_back(BasicBlock::MakeExpression(e, constantPropagate));
             break;
         case Expression::Kind::kBoolLiteral:   // fall through
         case Expression::Kind::kExternalValue: // fall through
         case Expression::Kind::kFloatLiteral:  // fall through
         case Expression::Kind::kIntLiteral:    // fall through
         case Expression::Kind::kNullLiteral:   // fall through
         case Expression::Kind::kSetting:       // fall through
         case Expression::Kind::kVariableReference:
             cfg.currentBlock().fNodes.push_back(BasicBlock::MakeExpression(e, constantPropagate));
             break;
         case Expression::Kind::kTernary: {
             TernaryExpression& t = e->get()->as<TernaryExpression>();
             this->addExpression(cfg, &t.test(), constantPropagate);
             cfg.currentBlock().fNodes.push_back(BasicBlock::MakeExpression(e, constantPropagate));
             BlockId start = cfg.fCurrent;
             cfg.newBlock();
             this->addExpression(cfg, &t.ifTrue(), constantPropagate);
             BlockId next = cfg.newBlock();
             cfg.fCurrent = start;
             cfg.newBlock();
             this->addExpression(cfg, &t.ifFalse(), constantPropagate);
             cfg.addExit(cfg.fCurrent, next);
             cfg.fCurrent = next;
             break;
         }
         case Expression::Kind::kFunctionReference: // fall through
         case Expression::Kind::kTypeReference:     // fall through
         case Expression::Kind::kDefined:
             SkASSERT(false);
             break;
     }
 }
 
 // adds expressions that are evaluated as part of resolving an lvalue
@@ -494,172 +494,172 @@ static bool is_true(Expression& expr) {
 void CFGGenerator::addStatement(CFG& cfg, std::unique_ptr<Statement>* s) {
     switch ((*s)->kind()) {
         case Statement::Kind::kBlock: {
             Block& block = (*s)->as<Block>();
             for (std::unique_ptr<Statement>& child : block.children()) {
                 addStatement(cfg, &child);
             }
             break;
         }
         case Statement::Kind::kIf: {
             IfStatement& ifs = (*s)->as<IfStatement>();
             this->addExpression(cfg, &ifs.test(), /*constantPropagate=*/true);
             cfg.currentBlock().fNodes.push_back(BasicBlock::MakeStatement(s));
             BlockId start = cfg.fCurrent;
             cfg.newBlock();
             this->addStatement(cfg, &ifs.ifTrue());
             BlockId next = cfg.newBlock();
             if (ifs.ifFalse()) {
                 cfg.fCurrent = start;
                 cfg.newBlock();
                 this->addStatement(cfg, &ifs.ifFalse());
                 cfg.addExit(cfg.fCurrent, next);
                 cfg.fCurrent = next;
             } else {
                 cfg.addExit(start, next);
             }
             break;
         }
         case Statement::Kind::kExpression: {
             this->addExpression(cfg, &(*s)->as<ExpressionStatement>().expression(),
                                 /*constantPropagate=*/true);
             cfg.currentBlock().fNodes.push_back(BasicBlock::MakeStatement(s));
             break;
         }
         case Statement::Kind::kVarDeclaration: {
             VarDeclaration& vd = (*s)->as<VarDeclaration>();
             if (vd.value()) {
                 this->addExpression(cfg, &vd.value(), /*constantPropagate=*/true);
             }
             cfg.currentBlock().fNodes.push_back(BasicBlock::MakeStatement(s));
             break;
         }
         case Statement::Kind::kDiscard:
             cfg.currentBlock().fNodes.push_back(BasicBlock::MakeStatement(s));
             cfg.fCurrent = cfg.newIsolatedBlock();
             break;
         case Statement::Kind::kReturn: {
             ReturnStatement& r = (*s)->as<ReturnStatement>();
             if (r.expression()) {
                 this->addExpression(cfg, &r.expression(), /*constantPropagate=*/true);
             }
             cfg.currentBlock().fNodes.push_back(BasicBlock::MakeStatement(s));
             cfg.fCurrent = cfg.newIsolatedBlock();
             break;
         }
         case Statement::Kind::kBreak:
             cfg.currentBlock().fNodes.push_back(BasicBlock::MakeStatement(s));
             cfg.addExit(cfg.fCurrent, fLoopExits.top());
             cfg.fCurrent = cfg.newIsolatedBlock();
             break;
         case Statement::Kind::kContinue:
             cfg.currentBlock().fNodes.push_back(BasicBlock::MakeStatement(s));
             cfg.addExit(cfg.fCurrent, fLoopContinues.top());
             cfg.fCurrent = cfg.newIsolatedBlock();
             break;
         case Statement::Kind::kWhile: {
             WhileStatement& w = (*s)->as<WhileStatement>();
             BlockId loopStart = cfg.newBlock();
             fLoopContinues.push(loopStart);
             BlockId loopExit = cfg.newIsolatedBlock();
             fLoopExits.push(loopExit);
             this->addExpression(cfg, &w.test(), /*constantPropagate=*/true);
             BlockId test = cfg.fCurrent;
             if (!is_true(*w.test())) {
                 cfg.addExit(test, loopExit);
             }
             cfg.newBlock();
             this->addStatement(cfg, &w.statement());
             cfg.addExit(cfg.fCurrent, loopStart);
             fLoopContinues.pop();
             fLoopExits.pop();
             cfg.fCurrent = loopExit;
             break;
         }
         case Statement::Kind::kDo: {
             DoStatement& d = (*s)->as<DoStatement>();
             BlockId loopStart = cfg.newBlock();
             fLoopContinues.push(loopStart);
             BlockId loopExit = cfg.newIsolatedBlock();
             fLoopExits.push(loopExit);
             this->addStatement(cfg, &d.statement());
             this->addExpression(cfg, &d.test(), /*constantPropagate=*/true);
             cfg.addExit(cfg.fCurrent, loopExit);
             cfg.addExit(cfg.fCurrent, loopStart);
             fLoopContinues.pop();
             fLoopExits.pop();
             cfg.fCurrent = loopExit;
             break;
         }
         case Statement::Kind::kFor: {
             ForStatement& f = (*s)->as<ForStatement>();
             if (f.initializer()) {
                 this->addStatement(cfg, &f.initializer());
             }
             BlockId loopStart = cfg.newBlock();
             BlockId next = cfg.newIsolatedBlock();
             fLoopContinues.push(next);
             BlockId loopExit = cfg.newIsolatedBlock();
             fLoopExits.push(loopExit);
             if (f.test()) {
                 this->addExpression(cfg, &f.test(), /*constantPropagate=*/true);
                 // this isn't quite right; we should have an exit from here to the loop exit, and
                 // remove the exit from the loop body to the loop exit. Structuring it like this
                 // forces the optimizer to believe that the loop body is always executed at least
                 // once. While not strictly correct, this avoids incorrect "variable not assigned"
                 // errors on variables which are assigned within the loop. The correct solution to
                 // this is to analyze the loop to see whether or not at least one iteration is
                 // guaranteed to happen, but for the time being we take the easy way out.
             }
             cfg.newBlock();
             this->addStatement(cfg, &f.statement());
             cfg.addExit(cfg.fCurrent, next);
             cfg.fCurrent = next;
             if (f.next()) {
                 this->addExpression(cfg, &f.next(), /*constantPropagate=*/true);
             }
             cfg.addExit(cfg.fCurrent, loopStart);
             cfg.addExit(cfg.fCurrent, loopExit);
             fLoopContinues.pop();
             fLoopExits.pop();
             cfg.fCurrent = loopExit;
             break;
         }
         case Statement::Kind::kSwitch: {
             SwitchStatement& ss = (*s)->as<SwitchStatement>();
             this->addExpression(cfg, &ss.value(), /*constantPropagate=*/true);
             cfg.currentBlock().fNodes.push_back(BasicBlock::MakeStatement(s));
             BlockId start = cfg.fCurrent;
             BlockId switchExit = cfg.newIsolatedBlock();
             fLoopExits.push(switchExit);
             for (auto& c : ss.cases()) {
                 cfg.newBlock();
                 cfg.addExit(start, cfg.fCurrent);
-                if (c->value()) {
+                if (c.value()) {
                     // technically this should go in the start block, but it doesn't actually matter
                     // because it must be constant. Not worth running two loops for.
-                    this->addExpression(cfg, &c->value(), /*constantPropagate=*/true);
+                    this->addExpression(cfg, &c.value(), /*constantPropagate=*/true);
                 }
-                for (auto& caseStatement : c->statements()) {
+                for (auto& caseStatement : c.statements()) {
                     this->addStatement(cfg, &caseStatement);
                 }
             }
             cfg.addExit(cfg.fCurrent, switchExit);
             // note that unlike GLSL, our grammar requires the default case to be last
-            if (ss.cases().empty() || ss.cases().back()->value()) {
+            if (ss.cases().empty() || ss.cases().back().value()) {
                 // switch does not have a default clause, mark that it can skip straight to the end
                 cfg.addExit(start, switchExit);
             }
             fLoopExits.pop();
             cfg.fCurrent = switchExit;
             break;
         }
         case Statement::Kind::kInlineMarker:
         case Statement::Kind::kNop:
             break;
         default:
 #ifdef SK_DEBUG
             ABORT("unsupported statement: %s\n", (*s)->description().c_str());
 #endif
             break;
     }
 }
diff --git a/src/sksl/SkSLCPPCodeGenerator.cpp b/src/sksl/SkSLCPPCodeGenerator.cpp
index f122a5c690..d13870cd84 100644
--- a/src/sksl/SkSLCPPCodeGenerator.cpp
+++ b/src/sksl/SkSLCPPCodeGenerator.cpp
@@ -70,47 +70,47 @@ String CPPCodeGenerator::getTypeName(const Type& type) {
 
 void CPPCodeGenerator::writeBinaryExpression(const BinaryExpression& b,
                                              Precedence parentPrecedence) {
-    const Expression& left = *b.left();
-    const Expression& right = *b.right();
+    const Expression& left = b.left();
+    const Expression& right = b.right();
     Token::Kind op = b.getOperator();
     if (op == Token::Kind::TK_PERCENT) {
         // need to use "%%" instead of "%" b/c the code will be inside of a printf
         Precedence precedence = GetBinaryPrecedence(op);
         if (precedence >= parentPrecedence) {
             this->write("(");
         }
         this->writeExpression(left, precedence);
         this->write(" %% ");
         this->writeExpression(right, precedence);
         if (precedence >= parentPrecedence) {
             this->write(")");
         }
     } else if (left.kind() == Expression::Kind::kNullLiteral ||
                right.kind() == Expression::Kind::kNullLiteral) {
         const Variable* var;
         if (left.kind() != Expression::Kind::kNullLiteral) {
             var = left.as<VariableReference>().variable();
         } else {
             var = right.as<VariableReference>().variable();
         }
         SkASSERT(var->type().typeKind() == Type::TypeKind::kNullable &&
                  var->type().componentType() == *fContext.fFragmentProcessor_Type);
         this->write("%s");
         const char* prefix = "";
         switch (op) {
             case Token::Kind::TK_EQEQ:
                 prefix = "!";
                 break;
             case Token::Kind::TK_NEQ:
                 prefix = "";
                 break;
             default:
                 SkASSERT(false);
         }
         int childIndex = this->getChildFPIndex(*var);
         fFormatArgs.push_back(String(prefix) + "_outer.childProcessor(" + to_string(childIndex) +
                               ") ? \"true\" : \"false\"");
     } else {
         INHERITED::writeBinaryExpression(b, parentPrecedence);
     }
 }
diff --git a/src/sksl/SkSLCompiler.cpp b/src/sksl/SkSLCompiler.cpp
index de0e5b5db5..331b086462 100644
--- a/src/sksl/SkSLCompiler.cpp
+++ b/src/sksl/SkSLCompiler.cpp
@@ -449,76 +449,76 @@ void Compiler::addDefinition(const Expression* lvalue, std::unique_ptr<Expressio
 // add local variables defined by this node to the set
 void Compiler::addDefinitions(const BasicBlock::Node& node, DefinitionMap* definitions) {
     if (node.isExpression()) {
         Expression* expr = node.expression()->get();
         switch (expr->kind()) {
             case Expression::Kind::kBinary: {
                 BinaryExpression* b = &expr->as<BinaryExpression>();
                 if (b->getOperator() == Token::Kind::TK_EQ) {
-                    this->addDefinition(b->left().get(), &b->right(), definitions);
+                    this->addDefinition(&b->left(), &b->rightPointer(), definitions);
                 } else if (Compiler::IsAssignment(b->getOperator())) {
                     this->addDefinition(
-                                  b->left().get(),
+                                  &b->left(),
                                   (std::unique_ptr<Expression>*) &fContext->fDefined_Expression,
                                   definitions);
 
                 }
                 break;
             }
             case Expression::Kind::kFunctionCall: {
                 const FunctionCall& c = expr->as<FunctionCall>();
                 const std::vector<const Variable*>& parameters = c.function().parameters();
                 for (size_t i = 0; i < parameters.size(); ++i) {
                     if (parameters[i]->modifiers().fFlags & Modifiers::kOut_Flag) {
                         this->addDefinition(
                                   c.arguments()[i].get(),
                                   (std::unique_ptr<Expression>*) &fContext->fDefined_Expression,
                                   definitions);
                     }
                 }
                 break;
             }
             case Expression::Kind::kPrefix: {
                 const PrefixExpression* p = &expr->as<PrefixExpression>();
                 if (p->getOperator() == Token::Kind::TK_MINUSMINUS ||
                     p->getOperator() == Token::Kind::TK_PLUSPLUS) {
                     this->addDefinition(
                                   p->operand().get(),
                                   (std::unique_ptr<Expression>*) &fContext->fDefined_Expression,
                                   definitions);
                 }
                 break;
             }
             case Expression::Kind::kPostfix: {
                 const PostfixExpression* p = &expr->as<PostfixExpression>();
                 if (p->getOperator() == Token::Kind::TK_MINUSMINUS ||
                     p->getOperator() == Token::Kind::TK_PLUSPLUS) {
                     this->addDefinition(
                                   p->operand().get(),
                                   (std::unique_ptr<Expression>*) &fContext->fDefined_Expression,
                                   definitions);
                 }
                 break;
             }
             case Expression::Kind::kVariableReference: {
                 const VariableReference* v = &expr->as<VariableReference>();
                 if (v->refKind() != VariableReference::RefKind::kRead) {
                     this->addDefinition(
                                   v,
                                   (std::unique_ptr<Expression>*) &fContext->fDefined_Expression,
                                   definitions);
                 }
                 break;
             }
             default:
                 break;
         }
     } else if (node.isStatement()) {
         Statement* stmt = node.statement()->get();
         if (stmt->is<VarDeclaration>()) {
             VarDeclaration& vd = stmt->as<VarDeclaration>();
             if (vd.value()) {
                 definitions->set(&vd.var(), &vd.value());
             }
         }
     }
 }
@@ -614,12 +614,12 @@ static bool is_dead(const Expression& lvalue, ProgramUsage* usage) {
 /**
  * Returns true if this is an assignment which can be collapsed down to just the right hand side due
  * to a dead target and lack of side effects on the left hand side.
  */
 static bool dead_assignment(const BinaryExpression& b, ProgramUsage* usage) {
     if (!Compiler::IsAssignment(b.getOperator())) {
         return false;
     }
-    return is_dead(*b.left(), usage);
+    return is_dead(b.left(), usage);
 }
 
 void Compiler::computeDataFlow(CFG* cfg) {
@@ -704,76 +704,76 @@ static bool is_constant(const Expression& expr, T value) {
 /**
  * Collapses the binary expression pointed to by iter down to just the right side (in both the IR
  * and CFG structures).
  */
 static void delete_left(BasicBlock* b,
                         std::vector<BasicBlock::Node>::iterator* iter,
                         Compiler::OptimizationContext* optimizationContext) {
     optimizationContext->fUpdated = true;
     std::unique_ptr<Expression>* target = (*iter)->expression();
     BinaryExpression& bin = (*target)->as<BinaryExpression>();
-    Expression& left = *bin.left();
-    std::unique_ptr<Expression>& rightPointer = bin.right();
+    Expression& left = bin.left();
+    std::unique_ptr<Expression>& rightPointer = bin.rightPointer();
     SkASSERT(!left.hasSideEffects());
     bool result;
     if (bin.getOperator() == Token::Kind::TK_EQ) {
         result = b->tryRemoveLValueBefore(iter, &left);
     } else {
         result = b->tryRemoveExpressionBefore(iter, &left);
     }
     // Remove references within LHS.
     optimizationContext->fUsage->remove(&left);
     *target = std::move(rightPointer);
     if (!result) {
         optimizationContext->fNeedsRescan = true;
         return;
     }
     if (*iter == b->fNodes.begin()) {
         optimizationContext->fNeedsRescan = true;
         return;
     }
     --(*iter);
     if (!(*iter)->isExpression() || (*iter)->expression() != &rightPointer) {
         optimizationContext->fNeedsRescan = true;
         return;
     }
     *iter = b->fNodes.erase(*iter);
     SkASSERT((*iter)->expression() == target);
 }
 
 /**
  * Collapses the binary expression pointed to by iter down to just the left side (in both the IR and
  * CFG structures).
  */
 static void delete_right(BasicBlock* b,
                          std::vector<BasicBlock::Node>::iterator* iter,
                          Compiler::OptimizationContext* optimizationContext) {
     optimizationContext->fUpdated = true;
     std::unique_ptr<Expression>* target = (*iter)->expression();
     BinaryExpression& bin = (*target)->as<BinaryExpression>();
-    std::unique_ptr<Expression>& leftPointer = bin.left();
-    Expression& right = *bin.right();
+    std::unique_ptr<Expression>& leftPointer = bin.leftPointer();
+    Expression& right = bin.right();
     SkASSERT(!right.hasSideEffects());
     // Remove references within RHS.
     optimizationContext->fUsage->remove(&right);
     if (!b->tryRemoveExpressionBefore(iter, &right)) {
         *target = std::move(leftPointer);
         optimizationContext->fNeedsRescan = true;
         return;
     }
     *target = std::move(leftPointer);
     if (*iter == b->fNodes.begin()) {
         optimizationContext->fNeedsRescan = true;
         return;
     }
     --(*iter);
     if ((!(*iter)->isExpression() || (*iter)->expression() != &leftPointer)) {
         optimizationContext->fNeedsRescan = true;
         return;
     }
     *iter = b->fNodes.erase(*iter);
     SkASSERT((*iter)->expression() == target);
 }
 
 /**
  * Constructs the specified type using a single argument.
  */
@@ -812,27 +812,27 @@ static void vectorize(BasicBlock* b,
 /**
  * Given a binary expression of the form x <op> vec<n>(y), deletes the right side and vectorizes the
  * left to yield vec<n>(x).
  */
 static void vectorize_left(BasicBlock* b,
                            std::vector<BasicBlock::Node>::iterator* iter,
                            Compiler::OptimizationContext* optimizationContext) {
     BinaryExpression& bin = (*(*iter)->expression())->as<BinaryExpression>();
     // Remove references within RHS. Vectorization of LHS doesn't change reference counts.
-    optimizationContext->fUsage->remove(bin.right().get());
-    vectorize(b, iter, bin.right()->type(), &bin.left(), optimizationContext);
+    optimizationContext->fUsage->remove(bin.rightPointer().get());
+    vectorize(b, iter, bin.right().type(), &bin.leftPointer(), optimizationContext);
 }
 
 /**
  * Given a binary expression of the form vec<n>(x) <op> y, deletes the left side and vectorizes the
  * right to yield vec<n>(y).
  */
 static void vectorize_right(BasicBlock* b,
                             std::vector<BasicBlock::Node>::iterator* iter,
                             Compiler::OptimizationContext* optimizationContext) {
     BinaryExpression& bin = (*(*iter)->expression())->as<BinaryExpression>();
     // Remove references within LHS. Vectorization of RHS doesn't change reference counts.
-    optimizationContext->fUsage->remove(bin.left().get());
-    vectorize(b, iter, bin.left()->type(), &bin.right(), optimizationContext);
+    optimizationContext->fUsage->remove(bin.leftPointer().get());
+    vectorize(b, iter, bin.left().type(), &bin.rightPointer(), optimizationContext);
 }
 
 // Mark that an expression which we were writing to is no longer being written to
@@ -860,270 +860,270 @@ static void clear_write(Expression& expr) {
 void Compiler::simplifyExpression(DefinitionMap& definitions,
                                   BasicBlock& b,
                                   std::vector<BasicBlock::Node>::iterator* iter,
                                   OptimizationContext* optimizationContext) {
     Expression* expr = (*iter)->expression()->get();
     SkASSERT(expr);
     if ((*iter)->fConstantPropagation) {
         std::unique_ptr<Expression> optimized = expr->constantPropagate(*fIRGenerator,
                                                                         definitions);
         if (optimized) {
             optimizationContext->fUpdated = true;
             optimized = fIRGenerator->coerce(std::move(optimized), expr->type());
             SkASSERT(optimized);
             // Remove references within 'expr', add references within 'optimized'
             optimizationContext->fUsage->replace(expr, optimized.get());
             if (!try_replace_expression(&b, iter, &optimized)) {
                 optimizationContext->fNeedsRescan = true;
                 return;
             }
             SkASSERT((*iter)->isExpression());
             expr = (*iter)->expression()->get();
         }
     }
     switch (expr->kind()) {
         case Expression::Kind::kVariableReference: {
             const VariableReference& ref = expr->as<VariableReference>();
             const Variable* var = ref.variable();
             if (ref.refKind() != VariableReference::RefKind::kWrite &&
                 ref.refKind() != VariableReference::RefKind::kPointer &&
                 var->storage() == Variable::Storage::kLocal && !definitions[var] &&
                 optimizationContext->fSilences.find(var) == optimizationContext->fSilences.end()) {
                 optimizationContext->fSilences.insert(var);
                 this->error(expr->fOffset,
                             "'" + var->name() + "' has not been assigned");
             }
             break;
         }
         case Expression::Kind::kTernary: {
             TernaryExpression* t = &expr->as<TernaryExpression>();
             if (t->test()->is<BoolLiteral>()) {
                 // ternary has a constant test, replace it with either the true or
                 // false branch
                 if (t->test()->as<BoolLiteral>().value()) {
                     (*iter)->setExpression(std::move(t->ifTrue()), optimizationContext->fUsage);
                 } else {
                     (*iter)->setExpression(std::move(t->ifFalse()), optimizationContext->fUsage);
                 }
                 optimizationContext->fUpdated = true;
                 optimizationContext->fNeedsRescan = true;
             }
             break;
         }
         case Expression::Kind::kBinary: {
             BinaryExpression* bin = &expr->as<BinaryExpression>();
             if (dead_assignment(*bin, optimizationContext->fUsage)) {
                 delete_left(&b, iter, optimizationContext);
                 break;
             }
-            Expression& left = *bin->left();
-            Expression& right = *bin->right();
+            Expression& left = bin->left();
+            Expression& right = bin->right();
             const Type& leftType = left.type();
             const Type& rightType = right.type();
             // collapse useless expressions like x * 1 or x + 0
             if (((leftType.typeKind() != Type::TypeKind::kScalar) &&
                  (leftType.typeKind() != Type::TypeKind::kVector)) ||
                 ((rightType.typeKind() != Type::TypeKind::kScalar) &&
                  (rightType.typeKind() != Type::TypeKind::kVector))) {
                 break;
             }
             switch (bin->getOperator()) {
                 case Token::Kind::TK_STAR:
                     if (is_constant(left, 1)) {
                         if (leftType.typeKind() == Type::TypeKind::kVector &&
                             rightType.typeKind() == Type::TypeKind::kScalar) {
                             // float4(1) * x -> float4(x)
                             vectorize_right(&b, iter, optimizationContext);
                         } else {
                             // 1 * x -> x
                             // 1 * float4(x) -> float4(x)
                             // float4(1) * float4(x) -> float4(x)
                             delete_left(&b, iter, optimizationContext);
                         }
                     }
                     else if (is_constant(left, 0)) {
                         if (leftType.typeKind() == Type::TypeKind::kScalar &&
                             rightType.typeKind() == Type::TypeKind::kVector &&
                             !right.hasSideEffects()) {
                             // 0 * float4(x) -> float4(0)
                             vectorize_left(&b, iter, optimizationContext);
                         } else {
                             // 0 * x -> 0
                             // float4(0) * x -> float4(0)
                             // float4(0) * float4(x) -> float4(0)
                             if (!right.hasSideEffects()) {
                                 delete_right(&b, iter, optimizationContext);
                             }
                         }
                     }
                     else if (is_constant(right, 1)) {
                         if (leftType.typeKind() == Type::TypeKind::kScalar &&
                             rightType.typeKind() == Type::TypeKind::kVector) {
                             // x * float4(1) -> float4(x)
                             vectorize_left(&b, iter, optimizationContext);
                         } else {
                             // x * 1 -> x
                             // float4(x) * 1 -> float4(x)
                             // float4(x) * float4(1) -> float4(x)
                             delete_right(&b, iter, optimizationContext);
                         }
                     }
                     else if (is_constant(right, 0)) {
                         if (leftType.typeKind() == Type::TypeKind::kVector &&
                             rightType.typeKind() == Type::TypeKind::kScalar &&
                             !left.hasSideEffects()) {
                             // float4(x) * 0 -> float4(0)
                             vectorize_right(&b, iter, optimizationContext);
                         } else {
                             // x * 0 -> 0
                             // x * float4(0) -> float4(0)
                             // float4(x) * float4(0) -> float4(0)
                             if (!left.hasSideEffects()) {
                                 delete_left(&b, iter, optimizationContext);
                             }
                         }
                     }
                     break;
                 case Token::Kind::TK_PLUS:
                     if (is_constant(left, 0)) {
                         if (leftType.typeKind() == Type::TypeKind::kVector &&
                             rightType.typeKind() == Type::TypeKind::kScalar) {
                             // float4(0) + x -> float4(x)
                             vectorize_right(&b, iter, optimizationContext);
                         } else {
                             // 0 + x -> x
                             // 0 + float4(x) -> float4(x)
                             // float4(0) + float4(x) -> float4(x)
                             delete_left(&b, iter, optimizationContext);
                         }
                     } else if (is_constant(right, 0)) {
                         if (leftType.typeKind() == Type::TypeKind::kScalar &&
                             rightType.typeKind() == Type::TypeKind::kVector) {
                             // x + float4(0) -> float4(x)
                             vectorize_left(&b, iter, optimizationContext);
                         } else {
                             // x + 0 -> x
                             // float4(x) + 0 -> float4(x)
                             // float4(x) + float4(0) -> float4(x)
                             delete_right(&b, iter, optimizationContext);
                         }
                     }
                     break;
                 case Token::Kind::TK_MINUS:
                     if (is_constant(right, 0)) {
                         if (leftType.typeKind() == Type::TypeKind::kScalar &&
                             rightType.typeKind() == Type::TypeKind::kVector) {
                             // x - float4(0) -> float4(x)
                             vectorize_left(&b, iter, optimizationContext);
                         } else {
                             // x - 0 -> x
                             // float4(x) - 0 -> float4(x)
                             // float4(x) - float4(0) -> float4(x)
                             delete_right(&b, iter, optimizationContext);
                         }
                     }
                     break;
                 case Token::Kind::TK_SLASH:
                     if (is_constant(right, 1)) {
                         if (leftType.typeKind() == Type::TypeKind::kScalar &&
                             rightType.typeKind() == Type::TypeKind::kVector) {
                             // x / float4(1) -> float4(x)
                             vectorize_left(&b, iter, optimizationContext);
                         } else {
                             // x / 1 -> x
                             // float4(x) / 1 -> float4(x)
                             // float4(x) / float4(1) -> float4(x)
                             delete_right(&b, iter, optimizationContext);
                         }
                     } else if (is_constant(left, 0)) {
                         if (leftType.typeKind() == Type::TypeKind::kScalar &&
                             rightType.typeKind() == Type::TypeKind::kVector &&
                             !right.hasSideEffects()) {
                             // 0 / float4(x) -> float4(0)
                             vectorize_left(&b, iter, optimizationContext);
                         } else {
                             // 0 / x -> 0
                             // float4(0) / x -> float4(0)
                             // float4(0) / float4(x) -> float4(0)
                             if (!right.hasSideEffects()) {
                                 delete_right(&b, iter, optimizationContext);
                             }
                         }
                     }
                     break;
                 case Token::Kind::TK_PLUSEQ:
                     if (is_constant(right, 0)) {
                         clear_write(left);
                         delete_right(&b, iter, optimizationContext);
                     }
                     break;
                 case Token::Kind::TK_MINUSEQ:
                     if (is_constant(right, 0)) {
                         clear_write(left);
                         delete_right(&b, iter, optimizationContext);
                     }
                     break;
                 case Token::Kind::TK_STAREQ:
                     if (is_constant(right, 1)) {
                         clear_write(left);
                         delete_right(&b, iter, optimizationContext);
                     }
                     break;
                 case Token::Kind::TK_SLASHEQ:
                     if (is_constant(right, 1)) {
                         clear_write(left);
                         delete_right(&b, iter, optimizationContext);
                     }
                     break;
                 default:
                     break;
             }
             break;
         }
         case Expression::Kind::kSwizzle: {
             Swizzle& s = expr->as<Swizzle>();
             // detect identity swizzles like foo.rgba
             if ((int) s.components().size() == s.base()->type().columns()) {
                 bool identity = true;
                 for (int i = 0; i < (int) s.components().size(); ++i) {
                     if (s.components()[i] != i) {
                         identity = false;
                         break;
                     }
                 }
                 if (identity) {
                     optimizationContext->fUpdated = true;
                     // No fUsage change: foo.rgba and foo have equivalent reference counts
                     if (!try_replace_expression(&b, iter, &s.base())) {
                         optimizationContext->fNeedsRescan = true;
                         return;
                     }
                     SkASSERT((*iter)->isExpression());
                     break;
                 }
             }
             // detect swizzles of swizzles, e.g. replace foo.argb.r000 with foo.a000
             if (s.base()->kind() == Expression::Kind::kSwizzle) {
                 Swizzle& base = s.base()->as<Swizzle>();
                 std::vector<int> final;
                 for (int c : s.components()) {
                     final.push_back(base.components()[c]);
                 }
                 optimizationContext->fUpdated = true;
                 std::unique_ptr<Expression> replacement(new Swizzle(*fContext, base.base()->clone(),
                                                                     std::move(final)));
                 // No fUsage change: foo.gbr.gbr and foo.brg have equivalent reference counts
                 if (!try_replace_expression(&b, iter, &replacement)) {
                     optimizationContext->fNeedsRescan = true;
                     return;
                 }
                 SkASSERT((*iter)->isExpression());
             }
             break;
         }
         default:
             break;
     }
 }
 
 // Returns true if this statement could potentially execute a break at the current level. We ignore
 // nested loops and switches, since any breaks inside of them will merely break the loop / switch.
@@ -1212,73 +1212,73 @@ static void move_all_but_break(std::unique_ptr<Statement>& stmt, StatementArray*
 // Returns a block containing all of the statements that will be run if the given case matches
 // (which, owing to the statements being owned by unique_ptrs, means the switch itself will be
 // broken by this call and must then be discarded).
 // Returns null (and leaves the switch unmodified) if no such simple reduction is possible, such as
 // when break statements appear inside conditionals.
 static std::unique_ptr<Statement> block_for_case(SwitchStatement* switchStatement,
                                                  SwitchCase* caseToCapture) {
     // We have to be careful to not move any of the pointers until after we're sure we're going to
     // succeed, so before we make any changes at all, we check the switch-cases to decide on a plan
     // of action. First, find the switch-case we are interested in.
     auto iter = switchStatement->cases().begin();
     for (; iter != switchStatement->cases().end(); ++iter) {
-        if (iter->get() == caseToCapture) {
+        if (&*iter == caseToCapture) {
             break;
         }
     }
 
     // Next, walk forward through the rest of the switch. If we find a conditional break, we're
     // stuck and can't simplify at all. If we find an unconditional break, we have a range of
     // statements that we can use for simplification.
     auto startIter = iter;
     Statement* unconditionalBreakStmt = nullptr;
     for (; iter != switchStatement->cases().end(); ++iter) {
-        for (std::unique_ptr<Statement>& stmt : (*iter)->statements()) {
+        for (std::unique_ptr<Statement>& stmt : iter->statements()) {
             if (contains_conditional_break(*stmt)) {
                 // We can't reduce switch-cases to a block when they have conditional breaks.
                 return nullptr;
             }
 
             if (contains_unconditional_break(*stmt)) {
                 // We found an unconditional break. We can use this block, but we need to strip
                 // out the break statement.
                 unconditionalBreakStmt = stmt.get();
                 break;
             }
         }
 
         if (unconditionalBreakStmt != nullptr) {
             break;
         }
     }
 
     // We fell off the bottom of the switch or encountered a break. We know the range of statements
     // that we need to move over, and we know it's safe to do so.
     StatementArray caseStmts;
 
     // We can move over most of the statements as-is.
     while (startIter != iter) {
-        for (std::unique_ptr<Statement>& stmt : (*startIter)->statements()) {
+        for (std::unique_ptr<Statement>& stmt : startIter->statements()) {
             caseStmts.push_back(std::move(stmt));
         }
         ++startIter;
     }
 
     // If we found an unconditional break at the end, we need to move what we can while avoiding
     // that break.
     if (unconditionalBreakStmt != nullptr) {
-        for (std::unique_ptr<Statement>& stmt : (*startIter)->statements()) {
+        for (std::unique_ptr<Statement>& stmt : startIter->statements()) {
             if (stmt.get() == unconditionalBreakStmt) {
                 move_all_but_break(stmt, &caseStmts);
                 unconditionalBreakStmt = nullptr;
                 break;
             }
 
             caseStmts.push_back(std::move(stmt));
         }
     }
 
     SkASSERT(unconditionalBreakStmt == nullptr);  // Verify that we fixed the unconditional break.
 
     // Return our newly-synthesized block.
     return std::make_unique<Block>(/*offset=*/-1, std::move(caseStmts), switchStatement->symbols());
 }
@@ -1286,138 +1286,138 @@ static std::unique_ptr<Statement> block_for_case(SwitchStatement* switchStatemen
 void Compiler::simplifyStatement(DefinitionMap& definitions,
                                  BasicBlock& b,
                                  std::vector<BasicBlock::Node>::iterator* iter,
                                  OptimizationContext* optimizationContext) {
     ProgramUsage* usage = optimizationContext->fUsage;
     Statement* stmt = (*iter)->statement()->get();
     switch (stmt->kind()) {
         case Statement::Kind::kVarDeclaration: {
             const auto& varDecl = stmt->as<VarDeclaration>();
             if (usage->isDead(varDecl.var()) &&
                 (!varDecl.value() ||
                  !varDecl.value()->hasSideEffects())) {
                 if (varDecl.value()) {
                     SkASSERT((*iter)->statement()->get() == stmt);
                     if (!b.tryRemoveExpressionBefore(iter, varDecl.value().get())) {
                         optimizationContext->fNeedsRescan = true;
                     }
                 }
                 (*iter)->setStatement(std::make_unique<Nop>(), usage);
                 optimizationContext->fUpdated = true;
             }
             break;
         }
         case Statement::Kind::kIf: {
             IfStatement& i = stmt->as<IfStatement>();
             if (i.test()->kind() == Expression::Kind::kBoolLiteral) {
                 // constant if, collapse down to a single branch
                 if (i.test()->as<BoolLiteral>().value()) {
                     SkASSERT(i.ifTrue());
                     (*iter)->setStatement(std::move(i.ifTrue()), usage);
                 } else {
                     if (i.ifFalse()) {
                         (*iter)->setStatement(std::move(i.ifFalse()), usage);
                     } else {
                         (*iter)->setStatement(std::make_unique<Nop>(), usage);
                     }
                 }
                 optimizationContext->fUpdated = true;
                 optimizationContext->fNeedsRescan = true;
                 break;
             }
             if (i.ifFalse() && i.ifFalse()->isEmpty()) {
                 // else block doesn't do anything, remove it
                 i.ifFalse().reset();
                 optimizationContext->fUpdated = true;
                 optimizationContext->fNeedsRescan = true;
             }
             if (!i.ifFalse() && i.ifTrue()->isEmpty()) {
                 // if block doesn't do anything, no else block
                 if (i.test()->hasSideEffects()) {
                     // test has side effects, keep it
                     (*iter)->setStatement(
                             std::make_unique<ExpressionStatement>(std::move(i.test())), usage);
                 } else {
                     // no if, no else, no test side effects, kill the whole if
                     // statement
                     (*iter)->setStatement(std::make_unique<Nop>(), usage);
                 }
                 optimizationContext->fUpdated = true;
                 optimizationContext->fNeedsRescan = true;
             }
             break;
         }
         case Statement::Kind::kSwitch: {
             SwitchStatement& s = stmt->as<SwitchStatement>();
             int64_t switchValue;
             if (fIRGenerator->getConstantInt(*s.value(), &switchValue)) {
                 // switch is constant, replace it with the case that matches
                 bool found = false;
                 SwitchCase* defaultCase = nullptr;
-                for (const std::unique_ptr<SwitchCase>& c : s.cases()) {
-                    if (!c->value()) {
-                        defaultCase = c.get();
+                for (SwitchCase& c : s.cases()) {
+                    if (!c.value()) {
+                        defaultCase = &c;
                         continue;
                     }
                     int64_t caseValue;
-                    SkAssertResult(fIRGenerator->getConstantInt(*c->value(), &caseValue));
+                    SkAssertResult(fIRGenerator->getConstantInt(*c.value(), &caseValue));
                     if (caseValue == switchValue) {
-                        std::unique_ptr<Statement> newBlock = block_for_case(&s, c.get());
+                        std::unique_ptr<Statement> newBlock = block_for_case(&s, &c);
                         if (newBlock) {
                             (*iter)->setStatement(std::move(newBlock), usage);
                             found = true;
                             break;
                         } else {
                             if (s.isStatic() && !(fFlags & kPermitInvalidStaticTests_Flag) &&
                                 optimizationContext->fSilences.find(&s) ==
                                 optimizationContext->fSilences.end()) {
                                 this->error(s.fOffset,
                                             "static switch contains non-static conditional break");
                                 optimizationContext->fSilences.insert(&s);
                             }
                             return; // can't simplify
                         }
                     }
                 }
                 if (!found) {
                     // no matching case. use default if it exists, or kill the whole thing
                     if (defaultCase) {
                         std::unique_ptr<Statement> newBlock = block_for_case(&s, defaultCase);
                         if (newBlock) {
                             (*iter)->setStatement(std::move(newBlock), usage);
                         } else {
                             if (s.isStatic() && !(fFlags & kPermitInvalidStaticTests_Flag) &&
                                 optimizationContext->fSilences.find(&s) ==
                                 optimizationContext->fSilences.end()) {
                                 this->error(s.fOffset,
                                             "static switch contains non-static conditional break");
                                 optimizationContext->fSilences.insert(&s);
                             }
                             return; // can't simplify
                         }
                     } else {
                         (*iter)->setStatement(std::make_unique<Nop>(), usage);
                     }
                 }
                 optimizationContext->fUpdated = true;
                 optimizationContext->fNeedsRescan = true;
             }
             break;
         }
         case Statement::Kind::kExpression: {
             ExpressionStatement& e = stmt->as<ExpressionStatement>();
             SkASSERT((*iter)->statement()->get() == &e);
             if (!e.expression()->hasSideEffects()) {
                 // Expression statement with no side effects, kill it
                 if (!b.tryRemoveExpressionBefore(iter, e.expression().get())) {
                     optimizationContext->fNeedsRescan = true;
                 }
                 SkASSERT((*iter)->statement()->get() == stmt);
                 (*iter)->setStatement(std::make_unique<Nop>(), usage);
                 optimizationContext->fUpdated = true;
             }
             break;
         }
         default:
             break;
     }
 }
diff --git a/src/sksl/SkSLDehydrator.cpp b/src/sksl/SkSLDehydrator.cpp
index 728429e5aa..663b57bdf2 100644
--- a/src/sksl/SkSLDehydrator.cpp
+++ b/src/sksl/SkSLDehydrator.cpp
@@ -264,131 +264,131 @@ void Dehydrator::write(const SymbolTable& symbols) {
 void Dehydrator::write(const Expression* e) {
     if (e) {
         switch (e->kind()) {
             case Expression::Kind::kBinary: {
                 const BinaryExpression& b = e->as<BinaryExpression>();
                 this->writeCommand(Rehydrator::kBinary_Command);
-                this->write(b.left().get());
+                this->write(&b.left());
                 this->writeU8((int) b.getOperator());
-                this->write(b.right().get());
+                this->write(&b.right());
                 this->write(b.type());
                 break;
             }
             case Expression::Kind::kBoolLiteral: {
                 const BoolLiteral& b = e->as<BoolLiteral>();
                 this->writeCommand(Rehydrator::kBoolLiteral_Command);
                 this->writeU8(b.value());
                 break;
             }
             case Expression::Kind::kConstructor: {
                 const Constructor& c = e->as<Constructor>();
                 this->writeCommand(Rehydrator::kConstructor_Command);
                 this->write(c.type());
                 this->writeU8(c.arguments().size());
                 for (const auto& a : c.arguments()) {
                     this->write(a.get());
                 }
                 break;
             }
             case Expression::Kind::kExternalFunctionCall:
             case Expression::Kind::kExternalValue:
                 SkDEBUGFAIL("unimplemented--not expected to be used from within an include file");
                 break;
             case Expression::Kind::kFieldAccess: {
                 const FieldAccess& f = e->as<FieldAccess>();
                 this->writeCommand(Rehydrator::kFieldAccess_Command);
                 this->write(f.base().get());
                 this->writeU8(f.fieldIndex());
                 this->writeU8((int8_t) f.ownerKind());
                 break;
             }
             case Expression::Kind::kFloatLiteral: {
                 const FloatLiteral& f = e->as<FloatLiteral>();
                 this->writeCommand(Rehydrator::kFloatLiteral_Command);
                 FloatIntUnion u;
                 u.fFloat = f.value();
                 this->writeS32(u.fInt);
                 break;
             }
             case Expression::Kind::kFunctionCall: {
                 const FunctionCall& f = e->as<FunctionCall>();
                 this->writeCommand(Rehydrator::kFunctionCall_Command);
                 this->write(f.type());
                 this->writeId(&f.function());
                 this->writeU8(f.arguments().size());
                 for (const auto& a : f.arguments()) {
                     this->write(a.get());
                 }
                 break;
             }
             case Expression::Kind::kIndex: {
                 const IndexExpression& i = e->as<IndexExpression>();
                 this->writeCommand(Rehydrator::kIndex_Command);
                 this->write(i.base().get());
                 this->write(i.index().get());
                 break;
             }
             case Expression::Kind::kIntLiteral: {
                 const IntLiteral& i = e->as<IntLiteral>();
                 this->writeCommand(Rehydrator::kIntLiteral_Command);
                 this->writeS32(i.value());
                 break;
             }
             case Expression::Kind::kNullLiteral:
                 this->writeCommand(Rehydrator::kNullLiteral_Command);
                 break;
             case Expression::Kind::kPostfix: {
                 const PostfixExpression& p = e->as<PostfixExpression>();
                 this->writeCommand(Rehydrator::kPostfix_Command);
                 this->writeU8((int) p.getOperator());
                 this->write(p.operand().get());
                 break;
             }
             case Expression::Kind::kPrefix: {
                 const PrefixExpression& p = e->as<PrefixExpression>();
                 this->writeCommand(Rehydrator::kPrefix_Command);
                 this->writeU8((int) p.getOperator());
                 this->write(p.operand().get());
                 break;
             }
             case Expression::Kind::kSetting: {
                 const Setting& s = e->as<Setting>();
                 this->writeCommand(Rehydrator::kSetting_Command);
                 this->write(s.name());
                 this->write(s.type());
                 break;
             }
             case Expression::Kind::kSwizzle: {
                 const Swizzle& s = e->as<Swizzle>();
                 this->writeCommand(Rehydrator::kSwizzle_Command);
                 this->write(s.base().get());
                 this->writeU8(s.components().size());
                 for (int c : s.components()) {
                     this->writeU8(c);
                 }
                 break;
             }
             case Expression::Kind::kTernary: {
                 const TernaryExpression& t = e->as<TernaryExpression>();
                 this->writeCommand(Rehydrator::kTernary_Command);
                 this->write(t.test().get());
                 this->write(t.ifTrue().get());
                 this->write(t.ifFalse().get());
                 break;
             }
             case Expression::Kind::kVariableReference: {
                 const VariableReference& v = e->as<VariableReference>();
                 this->writeCommand(Rehydrator::kVariableReference_Command);
                 this->writeId(v.variable());
                 this->writeU8((int8_t) v.refKind());
                 break;
             }
             case Expression::Kind::kFunctionReference:
             case Expression::Kind::kTypeReference:
             case Expression::Kind::kDefined:
                 SkDEBUGFAIL("this expression shouldn't appear in finished code");
                 break;
         }
     } else {
         this->writeCommand(Rehydrator::kVoid_Command);
     }
 }
@@ -396,113 +396,113 @@ void Dehydrator::write(const Expression* e) {
 void Dehydrator::write(const Statement* s) {
     if (s) {
         switch (s->kind()) {
             case Statement::Kind::kBlock: {
                 const Block& b = s->as<Block>();
                 this->writeCommand(Rehydrator::kBlock_Command);
                 AutoDehydratorSymbolTable symbols(this, b.symbolTable());
                 this->writeU8(b.children().size());
                 for (const std::unique_ptr<Statement>& blockStmt : b.children()) {
                     this->write(blockStmt.get());
                 }
                 this->writeU8(b.isScope());
                 break;
             }
             case Statement::Kind::kBreak:
                 this->writeCommand(Rehydrator::kBreak_Command);
                 break;
             case Statement::Kind::kContinue:
                 this->writeCommand(Rehydrator::kContinue_Command);
                 break;
             case Statement::Kind::kDiscard:
                 this->writeCommand(Rehydrator::kDiscard_Command);
                 break;
             case Statement::Kind::kDo: {
                 const DoStatement& d = s->as<DoStatement>();
                 this->writeCommand(Rehydrator::kDo_Command);
                 this->write(d.statement().get());
                 this->write(d.test().get());
                 break;
             }
             case Statement::Kind::kExpression: {
                 const ExpressionStatement& e = s->as<ExpressionStatement>();
                 this->writeCommand(Rehydrator::kExpressionStatement_Command);
                 this->write(e.expression().get());
                 break;
             }
             case Statement::Kind::kFor: {
                 const ForStatement& f = s->as<ForStatement>();
                 this->writeCommand(Rehydrator::kFor_Command);
                 this->write(f.initializer().get());
                 this->write(f.test().get());
                 this->write(f.next().get());
                 this->write(f.statement().get());
                 this->write(*f.symbols());
                 break;
             }
             case Statement::Kind::kIf: {
                 const IfStatement& i = s->as<IfStatement>();
                 this->writeCommand(Rehydrator::kIf_Command);
                 this->writeU8(i.isStatic());
                 this->write(i.test().get());
                 this->write(i.ifTrue().get());
                 this->write(i.ifFalse().get());
                 break;
             }
             case Statement::Kind::kInlineMarker: {
                 const InlineMarker& i = s->as<InlineMarker>();
                 this->writeCommand(Rehydrator::kInlineMarker_Command);
                 this->writeId(&i.function());
                 break;
             }
             case Statement::Kind::kNop:
                 SkDEBUGFAIL("unexpected--nop statement in finished code");
                 break;
             case Statement::Kind::kReturn: {
                 const ReturnStatement& r = s->as<ReturnStatement>();
                 this->writeCommand(Rehydrator::kReturn_Command);
                 this->write(r.expression().get());
                 break;
             }
             case Statement::Kind::kSwitch: {
                 const SwitchStatement& ss = s->as<SwitchStatement>();
                 this->writeCommand(Rehydrator::kSwitch_Command);
                 this->writeU8(ss.isStatic());
                 AutoDehydratorSymbolTable symbols(this, ss.symbols());
                 this->write(ss.value().get());
-                this->writeU8(ss.cases().size());
-                for (const std::unique_ptr<SwitchCase>& sc : ss.cases()) {
-                    this->write(sc->value().get());
-                    this->writeU8(sc->statements().size());
-                    for (const std::unique_ptr<Statement>& stmt : sc->statements()) {
+                this->writeU8(ss.cases().count());
+                for (const SwitchCase& sc : ss.cases()) {
+                    this->write(sc.value().get());
+                    this->writeU8(sc.statements().size());
+                    for (const std::unique_ptr<Statement>& stmt : sc.statements()) {
                         this->write(stmt.get());
                     }
                 }
                 break;
             }
             case Statement::Kind::kSwitchCase:
                 SkDEBUGFAIL("SwitchCase statements shouldn't appear here");
                 break;
             case Statement::Kind::kVarDeclaration: {
                 const VarDeclaration& v = s->as<VarDeclaration>();
                 this->writeCommand(Rehydrator::kVarDeclaration_Command);
                 this->writeU16(this->symbolId(&v.var()));
                 this->write(v.baseType());
-                this->writeU8(v.sizes().count());
-                for (const std::unique_ptr<Expression>& size : v.sizes()) {
-                    this->write(size.get());
+                this->writeU8(v.sizeCount());
+                for (int i = 0; i < v.sizeCount(); ++i) {
+                    this->write(v.size(i).get());
                 }
                 this->write(v.value().get());
                 break;
             }
             case Statement::Kind::kWhile: {
                 const WhileStatement& w = s->as<WhileStatement>();
                 this->writeCommand(Rehydrator::kWhile_Command);
                 this->write(w.test().get());
                 this->write(w.statement().get());
                 break;
             }
         }
     } else {
         this->writeCommand(Rehydrator::kVoid_Command);
     }
 }
diff --git a/src/sksl/SkSLExternalValue.h b/src/sksl/SkSLExternalValue.h
index 4e9be24ce8..aac27ca38c 100644
--- a/src/sksl/SkSLExternalValue.h
+++ b/src/sksl/SkSLExternalValue.h
@@ -19,99 +19,109 @@ class ExternalValue : public Symbol {
 public:
     static constexpr Kind kSymbolKind = Kind::kExternal;
 
     ExternalValue(const char* name, const Type& type)
-        : INHERITED(-1, kSymbolKind, name, &type) {}
+        : INHERITED(-1, kSymbolKind, name)
+        , fType(type) {}
 
     virtual bool canRead() const {
         return false;
     }
 
     virtual bool canWrite() const {
         return false;
     }
 
     virtual bool canCall() const {
         return false;
     }
 
+    /**
+     * Returns the type for purposes of read and write operations.
+     */
+    const Type& type() const override {
+        return fType;
+    }
+
     virtual int callParameterCount() const {
         return -1;
     }
 
     /**
      * Fills in the outTypes array with pointers to the parameter types. outTypes must be able to
      * hold callParameterCount() pointers.
      */
     virtual void getCallParameterTypes(const Type** outTypes) const {
         SkASSERT(false);
     }
 
     /**
      * Returns the return type resulting from a call operation.
      */
     virtual const Type& callReturnType() const {
-        return this->type();
+        return fType;
     }
 
     /**
      * Reads the external value and stores the resulting data in target. The caller must ensure
      * that target is a valid pointer to a region of sufficient size to hold the data contained
      * in this external value.
      * 'index' is the element index ([0 .. N-1]) within a call to ByteCode::run()
      */
     virtual void read(int index, float* target) const {
         SkASSERT(false);
     }
 
     /**
      * Copies the value in src into this external value. The caller must ensure that src is a
      * pointer to the type of data expected by this external value.
      * 'index' is the element index ([0 .. N-1]) within a call to ByteCode::run()
      */
     virtual void write(int index, float* src) const {
         SkASSERT(false);
     }
 
     /**
      * Calls the value as a function with the specified parameters. arguments must be a pointer to
      * a structure containing the arguments expected by the external value in source order, and
      * outResult must be a pointer to a region of sufficient size to hold the function's return
      * value.
      * 'index' is the element index ([0 .. N-1]) within a call to ByteCode::run()
      */
     virtual void call(int index, float* arguments, float* outResult) const {
         SkASSERT(false);
     }
 
     /**
      * Resolves 'name' within this context and returns an ExternalValue which represents it, or
      * null if no such child exists.
      *
      * The 'name' string may not persist after this call; do not store this pointer.
      */
     virtual ExternalValue* getChild(const char* name) const {
         return nullptr;
     }
 
     String description() const override {
         return String("external<") + this->name() + ">";
     }
 
     // Disable IRNode pooling on external value nodes. ExternalValue node lifetimes are controlled
     // by the calling code; we can't guarantee that they will be destroyed before a Program is
     // freed. (In fact, it's very unlikely that they would be.)
     static void* operator new(const size_t size) {
         return ::operator new(size);
     }
 
     static void operator delete(void* ptr) {
         ::operator delete(ptr);
     }
 
 private:
     using INHERITED = Symbol;
+
+    const Type& fType;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/SkSLGLSLCodeGenerator.cpp b/src/sksl/SkSLGLSLCodeGenerator.cpp
index 3e0e9bd574..f6d4d61e5d 100644
--- a/src/sksl/SkSLGLSLCodeGenerator.cpp
+++ b/src/sksl/SkSLGLSLCodeGenerator.cpp
@@ -908,37 +908,37 @@ GLSLCodeGenerator::Precedence GLSLCodeGenerator::GetBinaryPrecedence(Token::Kind
 
 void GLSLCodeGenerator::writeBinaryExpression(const BinaryExpression& b,
                                               Precedence parentPrecedence) {
-    const Expression& left = *b.left();
-    const Expression& right = *b.right();
+    const Expression& left = b.left();
+    const Expression& right = b.right();
     Token::Kind op = b.getOperator();
     if (fProgram.fSettings.fCaps->unfoldShortCircuitAsTernary() &&
             (op == Token::Kind::TK_LOGICALAND || op == Token::Kind::TK_LOGICALOR)) {
         this->writeShortCircuitWorkaroundExpression(b, parentPrecedence);
         return;
     }
 
     Precedence precedence = GetBinaryPrecedence(op);
     if (precedence >= parentPrecedence) {
         this->write("(");
     }
     bool positionWorkaround = fProgramKind == Program::Kind::kVertex_Kind &&
                               Compiler::IsAssignment(op) &&
                               left.kind() == Expression::Kind::kFieldAccess &&
                               is_sk_position((FieldAccess&) left) &&
                               !right.containsRTAdjust() &&
                               !fProgram.fSettings.fCaps->canUseFragCoord();
     if (positionWorkaround) {
         this->write("sk_FragCoord_Workaround = (");
     }
     this->writeExpression(left, precedence);
     this->write(" ");
     this->write(Compiler::OperatorName(op));
     this->write(" ");
     this->writeExpression(right, precedence);
     if (positionWorkaround) {
         this->write(")");
     }
     if (precedence >= parentPrecedence) {
         this->write(")");
     }
 }
@@ -946,28 +946,28 @@ void GLSLCodeGenerator::writeBinaryExpression(const BinaryExpression& b,
 void GLSLCodeGenerator::writeShortCircuitWorkaroundExpression(const BinaryExpression& b,
                                                               Precedence parentPrecedence) {
     if (kTernary_Precedence >= parentPrecedence) {
         this->write("(");
     }
 
     // Transform:
     // a && b  =>   a ? b : false
     // a || b  =>   a ? true : b
-    this->writeExpression(*b.left(), kTernary_Precedence);
+    this->writeExpression(b.left(), kTernary_Precedence);
     this->write(" ? ");
     if (b.getOperator() == Token::Kind::TK_LOGICALAND) {
-        this->writeExpression(*b.right(), kTernary_Precedence);
+        this->writeExpression(b.right(), kTernary_Precedence);
     } else {
         BoolLiteral boolTrue(fContext, -1, true);
         this->writeBoolLiteral(boolTrue);
     }
     this->write(" : ");
     if (b.getOperator() == Token::Kind::TK_LOGICALAND) {
         BoolLiteral boolFalse(fContext, -1, false);
         this->writeBoolLiteral(boolFalse);
     } else {
-        this->writeExpression(*b.right(), kTernary_Precedence);
+        this->writeExpression(b.right(), kTernary_Precedence);
     }
     if (kTernary_Precedence >= parentPrecedence) {
         this->write(")");
     }
 }
@@ -1248,31 +1248,31 @@ void GLSLCodeGenerator::writeTypePrecision(const Type& type) {
 void GLSLCodeGenerator::writeVarDeclaration(const VarDeclaration& var, bool global) {
     this->writeModifiers(var.var().modifiers(), global);
     this->writeTypePrecision(var.baseType());
     this->writeType(var.baseType());
     this->write(" ");
     this->write(var.var().name());
-    for (const std::unique_ptr<Expression>& size : var.sizes()) {
+    for (int i = 0; i < var.sizeCount(); ++i) {
         this->write("[");
-        if (size) {
-            this->writeExpression(*size, kTopLevel_Precedence);
+        if (var.size(i)) {
+            this->writeExpression(*var.size(i), kTopLevel_Precedence);
         }
         this->write("]");
     }
     if (var.value()) {
         this->write(" = ");
         this->writeVarInitializer(var.var(), *var.value());
     }
     if (!fFoundExternalSamplerDecl && var.var().type() == *fContext.fSamplerExternalOES_Type) {
         if (fProgram.fSettings.fCaps->externalTextureExtensionString()) {
             this->writeExtension(fProgram.fSettings.fCaps->externalTextureExtensionString());
         }
         if (fProgram.fSettings.fCaps->secondExternalTextureExtensionString()) {
             this->writeExtension(fProgram.fSettings.fCaps->secondExternalTextureExtensionString());
         }
         fFoundExternalSamplerDecl = true;
     }
     if (!fFoundRectSamplerDecl && var.var().type() == *fContext.fSampler2DRect_Type) {
         fFoundRectSamplerDecl = true;
     }
     this->write(";");
 }
@@ -1446,23 +1446,23 @@ void GLSLCodeGenerator::writeDoStatement(const DoStatement& d) {
 void GLSLCodeGenerator::writeSwitchStatement(const SwitchStatement& s) {
     this->write("switch (");
     this->writeExpression(*s.value(), kTopLevel_Precedence);
     this->writeLine(") {");
     fIndentation++;
-    for (const std::unique_ptr<SwitchCase>& c : s.cases()) {
-        if (c->value()) {
+    for (const SwitchCase& c : s.cases()) {
+        if (c.value()) {
             this->write("case ");
-            this->writeExpression(*c->value(), kTopLevel_Precedence);
+            this->writeExpression(*c.value(), kTopLevel_Precedence);
             this->writeLine(":");
         } else {
             this->writeLine("default:");
         }
         fIndentation++;
-        for (const auto& stmt : c->statements()) {
+        for (const auto& stmt : c.statements()) {
             this->writeStatement(*stmt);
             this->writeLine();
         }
         fIndentation--;
     }
     fIndentation--;
     this->write("}");
 }
diff --git a/src/sksl/SkSLIRGenerator.h b/src/sksl/SkSLIRGenerator.h
index 38e254afb6..3964773e84 100644
--- a/src/sksl/SkSLIRGenerator.h
+++ b/src/sksl/SkSLIRGenerator.h
@@ -33,7 +33,6 @@
 
 namespace SkSL {
 
-class ExternalValue;
 class FunctionCall;
 struct ParsedModule;
 struct Swizzle;
diff --git a/src/sksl/SkSLInliner.cpp b/src/sksl/SkSLInliner.cpp
index 6f80c20d23..3b013b611a 100644
--- a/src/sksl/SkSLInliner.cpp
+++ b/src/sksl/SkSLInliner.cpp
@@ -336,94 +336,94 @@ String Inliner::uniqueNameForInlineVar(const String& baseName, SymbolTable* symb
 std::unique_ptr<Expression> Inliner::inlineExpression(int offset,
                                                       VariableRewriteMap* varMap,
                                                       const Expression& expression) {
     auto expr = [&](const std::unique_ptr<Expression>& e) -> std::unique_ptr<Expression> {
         if (e) {
             return this->inlineExpression(offset, varMap, *e);
         }
         return nullptr;
     };
     auto argList = [&](const ExpressionArray& originalArgs) -> ExpressionArray {
         ExpressionArray args;
         args.reserve_back(originalArgs.size());
         for (const std::unique_ptr<Expression>& arg : originalArgs) {
             args.push_back(expr(arg));
         }
         return args;
     };
 
     switch (expression.kind()) {
         case Expression::Kind::kBinary: {
             const BinaryExpression& b = expression.as<BinaryExpression>();
             return std::make_unique<BinaryExpression>(offset,
-                                                      expr(b.left()),
+                                                      expr(b.leftPointer()),
                                                       b.getOperator(),
-                                                      expr(b.right()),
+                                                      expr(b.rightPointer()),
                                                       &b.type());
         }
         case Expression::Kind::kBoolLiteral:
         case Expression::Kind::kIntLiteral:
         case Expression::Kind::kFloatLiteral:
         case Expression::Kind::kNullLiteral:
             return expression.clone();
         case Expression::Kind::kConstructor: {
             const Constructor& constructor = expression.as<Constructor>();
             return std::make_unique<Constructor>(offset, &constructor.type(),
                                                  argList(constructor.arguments()));
         }
         case Expression::Kind::kExternalFunctionCall: {
             const ExternalFunctionCall& externalCall = expression.as<ExternalFunctionCall>();
             return std::make_unique<ExternalFunctionCall>(offset, &externalCall.function(),
                                                           argList(externalCall.arguments()));
         }
         case Expression::Kind::kExternalValue:
             return expression.clone();
         case Expression::Kind::kFieldAccess: {
             const FieldAccess& f = expression.as<FieldAccess>();
             return std::make_unique<FieldAccess>(expr(f.base()), f.fieldIndex(), f.ownerKind());
         }
         case Expression::Kind::kFunctionCall: {
             const FunctionCall& funcCall = expression.as<FunctionCall>();
             return std::make_unique<FunctionCall>(offset, &funcCall.type(), &funcCall.function(),
                                                   argList(funcCall.arguments()));
         }
         case Expression::Kind::kFunctionReference:
             return expression.clone();
         case Expression::Kind::kIndex: {
             const IndexExpression& idx = expression.as<IndexExpression>();
             return std::make_unique<IndexExpression>(*fContext, expr(idx.base()),
                                                      expr(idx.index()));
         }
         case Expression::Kind::kPrefix: {
             const PrefixExpression& p = expression.as<PrefixExpression>();
             return std::make_unique<PrefixExpression>(p.getOperator(), expr(p.operand()));
         }
         case Expression::Kind::kPostfix: {
             const PostfixExpression& p = expression.as<PostfixExpression>();
             return std::make_unique<PostfixExpression>(expr(p.operand()), p.getOperator());
         }
         case Expression::Kind::kSetting:
             return expression.clone();
         case Expression::Kind::kSwizzle: {
             const Swizzle& s = expression.as<Swizzle>();
             return std::make_unique<Swizzle>(*fContext, expr(s.base()), s.components());
         }
         case Expression::Kind::kTernary: {
             const TernaryExpression& t = expression.as<TernaryExpression>();
             return std::make_unique<TernaryExpression>(offset, expr(t.test()),
                                                        expr(t.ifTrue()), expr(t.ifFalse()));
         }
         case Expression::Kind::kTypeReference:
             return expression.clone();
         case Expression::Kind::kVariableReference: {
             const VariableReference& v = expression.as<VariableReference>();
             auto varMapIter = varMap->find(v.variable());
             if (varMapIter != varMap->end()) {
                 return clone_with_ref_kind(*varMapIter->second, v.refKind());
             }
             return v.clone();
         }
         default:
             SkASSERT(false);
             return nullptr;
     }
 }
@@ -431,154 +431,154 @@ std::unique_ptr<Expression> Inliner::inlineExpression(int offset,
 std::unique_ptr<Statement> Inliner::inlineStatement(int offset,
                                                     VariableRewriteMap* varMap,
                                                     SymbolTable* symbolTableForStatement,
                                                     const Expression* resultExpr,
                                                     bool haveEarlyReturns,
                                                     const Statement& statement,
                                                     bool isBuiltinCode) {
     auto stmt = [&](const std::unique_ptr<Statement>& s) -> std::unique_ptr<Statement> {
         if (s) {
             return this->inlineStatement(offset, varMap, symbolTableForStatement, resultExpr,
                                          haveEarlyReturns, *s, isBuiltinCode);
         }
         return nullptr;
     };
     auto blockStmts = [&](const Block& block) {
         StatementArray result;
         result.reserve_back(block.children().size());
         for (const std::unique_ptr<Statement>& child : block.children()) {
             result.push_back(stmt(child));
         }
         return result;
     };
     auto stmts = [&](const StatementArray& ss) {
         StatementArray result;
         result.reserve_back(ss.size());
         for (const auto& s : ss) {
             result.push_back(stmt(s));
         }
         return result;
     };
     auto expr = [&](const std::unique_ptr<Expression>& e) -> std::unique_ptr<Expression> {
         if (e) {
             return this->inlineExpression(offset, varMap, *e);
         }
         return nullptr;
     };
     switch (statement.kind()) {
         case Statement::Kind::kBlock: {
             const Block& b = statement.as<Block>();
             return std::make_unique<Block>(offset, blockStmts(b),
                                            SymbolTable::WrapIfBuiltin(b.symbolTable()),
                                            b.isScope());
         }
 
         case Statement::Kind::kBreak:
         case Statement::Kind::kContinue:
         case Statement::Kind::kDiscard:
             return statement.clone();
 
         case Statement::Kind::kDo: {
             const DoStatement& d = statement.as<DoStatement>();
             return std::make_unique<DoStatement>(offset, stmt(d.statement()), expr(d.test()));
         }
         case Statement::Kind::kExpression: {
             const ExpressionStatement& e = statement.as<ExpressionStatement>();
             return std::make_unique<ExpressionStatement>(expr(e.expression()));
         }
         case Statement::Kind::kFor: {
             const ForStatement& f = statement.as<ForStatement>();
             // need to ensure initializer is evaluated first so that we've already remapped its
             // declarations by the time we evaluate test & next
             std::unique_ptr<Statement> initializer = stmt(f.initializer());
             return std::make_unique<ForStatement>(offset, std::move(initializer), expr(f.test()),
                                                   expr(f.next()), stmt(f.statement()),
                                                   SymbolTable::WrapIfBuiltin(f.symbols()));
         }
         case Statement::Kind::kIf: {
             const IfStatement& i = statement.as<IfStatement>();
             return std::make_unique<IfStatement>(offset, i.isStatic(), expr(i.test()),
                                                  stmt(i.ifTrue()), stmt(i.ifFalse()));
         }
         case Statement::Kind::kInlineMarker:
         case Statement::Kind::kNop:
             return statement.clone();
         case Statement::Kind::kReturn: {
             const ReturnStatement& r = statement.as<ReturnStatement>();
             if (r.expression()) {
                 SkASSERT(resultExpr);
                 auto assignment =
                         std::make_unique<ExpressionStatement>(std::make_unique<BinaryExpression>(
                                 offset,
                                 clone_with_ref_kind(*resultExpr,
                                                     VariableReference::RefKind::kWrite),
                                 Token::Kind::TK_EQ,
                                 expr(r.expression()),
                                 &resultExpr->type()));
                 if (haveEarlyReturns) {
                     StatementArray block;
                     block.reserve_back(2);
                     block.push_back(std::move(assignment));
                     block.push_back(std::make_unique<BreakStatement>(offset));
                     return std::make_unique<Block>(offset, std::move(block), /*symbols=*/nullptr,
                                                    /*isScope=*/true);
                 } else {
                     return std::move(assignment);
                 }
             } else {
                 if (haveEarlyReturns) {
                     return std::make_unique<BreakStatement>(offset);
                 } else {
                     return std::make_unique<Nop>();
                 }
             }
         }
         case Statement::Kind::kSwitch: {
             const SwitchStatement& ss = statement.as<SwitchStatement>();
             std::vector<std::unique_ptr<SwitchCase>> cases;
-            cases.reserve(ss.cases().size());
-            for (const std::unique_ptr<SwitchCase>& sc : ss.cases()) {
-                cases.push_back(std::make_unique<SwitchCase>(offset, expr(sc->value()),
-                                                             stmts(sc->statements())));
+            cases.reserve(ss.cases().count());
+            for (const SwitchCase& sc : ss.cases()) {
+                cases.push_back(std::make_unique<SwitchCase>(offset, expr(sc.value()),
+                                                             stmts(sc.statements())));
             }
             return std::make_unique<SwitchStatement>(offset, ss.isStatic(), expr(ss.value()),
                                                      std::move(cases),
                                                      SymbolTable::WrapIfBuiltin(ss.symbols()));
         }
         case Statement::Kind::kVarDeclaration: {
             const VarDeclaration& decl = statement.as<VarDeclaration>();
             ExpressionArray sizes;
-            sizes.reserve_back(decl.sizes().count());
-            for (const std::unique_ptr<Expression>& size : decl.sizes()) {
-                sizes.push_back(expr(size));
+            sizes.reserve_back(decl.sizeCount());
+            for (int i = 0; i < decl.sizeCount(); ++i) {
+                sizes.push_back(expr(decl.size(i)));
             }
             std::unique_ptr<Expression> initialValue = expr(decl.value());
             const Variable& old = decl.var();
             // We assign unique names to inlined variables--scopes hide most of the problems in this
             // regard, but see `InlinerAvoidsVariableNameOverlap` for a counterexample where unique
             // names are important.
             auto name = std::make_unique<String>(
                     this->uniqueNameForInlineVar(String(old.name()), symbolTableForStatement));
             const String* namePtr = symbolTableForStatement->takeOwnershipOfString(std::move(name));
             const Type* baseTypePtr = copy_if_needed(&decl.baseType(), *symbolTableForStatement);
             const Type* typePtr = copy_if_needed(&old.type(), *symbolTableForStatement);
             const Variable* clone = symbolTableForStatement->takeOwnershipOfSymbol(
                     std::make_unique<Variable>(offset,
                                                old.modifiersHandle(),
                                                namePtr->c_str(),
                                                typePtr,
                                                isBuiltinCode,
                                                old.storage(),
                                                initialValue.get()));
             (*varMap)[&old] = std::make_unique<VariableReference>(offset, clone);
             return std::make_unique<VarDeclaration>(clone, baseTypePtr, std::move(sizes),
                                                     std::move(initialValue));
         }
         case Statement::Kind::kWhile: {
             const WhileStatement& w = statement.as<WhileStatement>();
             return std::make_unique<WhileStatement>(offset, expr(w.test()), stmt(w.statement()));
         }
         default:
             SkASSERT(false);
             return nullptr;
     }
 }
@@ -801,285 +801,285 @@ class InlineCandidateAnalyzer {
 public:
     // A list of all the inlining candidates we found during analysis.
     InlineCandidateList* fCandidateList;
 
     // A stack of the symbol tables; since most nodes don't have one, expected to be shallower than
     // the enclosing-statement stack.
     std::vector<SymbolTable*> fSymbolTableStack;
     // A stack of "enclosing" statements--these would be suitable for the inliner to use for adding
     // new instructions. Not all statements are suitable (e.g. a for-loop's initializer). The
     // inliner might replace a statement with a block containing the statement.
     std::vector<std::unique_ptr<Statement>*> fEnclosingStmtStack;
     // The function that we're currently processing (i.e. inlining into).
     FunctionDefinition* fEnclosingFunction = nullptr;
 
     void visit(Program& program, InlineCandidateList* candidateList) {
         fCandidateList = candidateList;
         fSymbolTableStack.push_back(program.fSymbols.get());
 
         for (const auto& pe : program.elements()) {
             this->visitProgramElement(pe.get());
         }
 
         fSymbolTableStack.pop_back();
         fCandidateList = nullptr;
     }
 
     void visitProgramElement(ProgramElement* pe) {
         switch (pe->kind()) {
             case ProgramElement::Kind::kFunction: {
                 FunctionDefinition& funcDef = pe->as<FunctionDefinition>();
                 // Don't attempt to mutate any builtin functions. (If we stop cloning builtins into
                 // the program, this check can become an assertion.)
                 if (!funcDef.isBuiltin()) {
                     fEnclosingFunction = &funcDef;
                     this->visitStatement(&funcDef.body());
                 }
                 break;
             }
             default:
                 // The inliner can't operate outside of a function's scope.
                 break;
         }
     }
 
     void visitStatement(std::unique_ptr<Statement>* stmt,
                         bool isViableAsEnclosingStatement = true) {
         if (!*stmt) {
             return;
         }
 
         size_t oldEnclosingStmtStackSize = fEnclosingStmtStack.size();
         size_t oldSymbolStackSize = fSymbolTableStack.size();
 
         if (isViableAsEnclosingStatement) {
             fEnclosingStmtStack.push_back(stmt);
         }
 
         switch ((*stmt)->kind()) {
             case Statement::Kind::kBreak:
             case Statement::Kind::kContinue:
             case Statement::Kind::kDiscard:
             case Statement::Kind::kInlineMarker:
             case Statement::Kind::kNop:
                 break;
 
             case Statement::Kind::kBlock: {
                 Block& block = (*stmt)->as<Block>();
                 if (block.symbolTable()) {
                     fSymbolTableStack.push_back(block.symbolTable().get());
                 }
 
                 for (std::unique_ptr<Statement>& stmt : block.children()) {
                     this->visitStatement(&stmt);
                 }
                 break;
             }
             case Statement::Kind::kDo: {
                 DoStatement& doStmt = (*stmt)->as<DoStatement>();
                 // The loop body is a candidate for inlining.
                 this->visitStatement(&doStmt.statement());
                 // The inliner isn't smart enough to inline the test-expression for a do-while
                 // loop at this time. There are two limitations:
                 // - We would need to insert the inlined-body block at the very end of the do-
                 //   statement's inner fStatement. We don't support that today, but it's doable.
                 // - We cannot inline the test expression if the loop uses `continue` anywhere; that
                 //   would skip over the inlined block that evaluates the test expression. There
                 //   isn't a good fix for this--any workaround would be more complex than the cost
                 //   of a function call. However, loops that don't use `continue` would still be
                 //   viable candidates for inlining.
                 break;
             }
             case Statement::Kind::kExpression: {
                 ExpressionStatement& expr = (*stmt)->as<ExpressionStatement>();
                 this->visitExpression(&expr.expression());
                 break;
             }
             case Statement::Kind::kFor: {
                 ForStatement& forStmt = (*stmt)->as<ForStatement>();
                 if (forStmt.symbols()) {
                     fSymbolTableStack.push_back(forStmt.symbols().get());
                 }
 
                 // The initializer and loop body are candidates for inlining.
                 this->visitStatement(&forStmt.initializer(),
                                      /*isViableAsEnclosingStatement=*/false);
                 this->visitStatement(&forStmt.statement());
 
                 // The inliner isn't smart enough to inline the test- or increment-expressions
                 // of a for loop loop at this time. There are a handful of limitations:
                 // - We would need to insert the test-expression block at the very beginning of the
                 //   for-loop's inner fStatement, and the increment-expression block at the very
                 //   end. We don't support that today, but it's doable.
                 // - The for-loop's built-in test-expression would need to be dropped entirely,
                 //   and the loop would be halted via a break statement at the end of the inlined
                 //   test-expression. This is again something we don't support today, but it could
                 //   be implemented.
                 // - We cannot inline the increment-expression if the loop uses `continue` anywhere;
                 //   that would skip over the inlined block that evaluates the increment expression.
                 //   There isn't a good fix for this--any workaround would be more complex than the
                 //   cost of a function call. However, loops that don't use `continue` would still
                 //   be viable candidates for increment-expression inlining.
                 break;
             }
             case Statement::Kind::kIf: {
                 IfStatement& ifStmt = (*stmt)->as<IfStatement>();
                 this->visitExpression(&ifStmt.test());
                 this->visitStatement(&ifStmt.ifTrue());
                 this->visitStatement(&ifStmt.ifFalse());
                 break;
             }
             case Statement::Kind::kReturn: {
                 ReturnStatement& returnStmt = (*stmt)->as<ReturnStatement>();
                 this->visitExpression(&returnStmt.expression());
                 break;
             }
             case Statement::Kind::kSwitch: {
                 SwitchStatement& switchStmt = (*stmt)->as<SwitchStatement>();
                 if (switchStmt.symbols()) {
                     fSymbolTableStack.push_back(switchStmt.symbols().get());
                 }
 
                 this->visitExpression(&switchStmt.value());
-                for (const std::unique_ptr<SwitchCase>& switchCase : switchStmt.cases()) {
+                for (SwitchCase& switchCase : switchStmt.cases()) {
                     // The switch-case's fValue cannot be a FunctionCall; skip it.
-                    for (std::unique_ptr<Statement>& caseBlock : switchCase->statements()) {
+                    for (std::unique_ptr<Statement>& caseBlock : switchCase.statements()) {
                         this->visitStatement(&caseBlock);
                     }
                 }
                 break;
             }
             case Statement::Kind::kVarDeclaration: {
                 VarDeclaration& varDeclStmt = (*stmt)->as<VarDeclaration>();
                 // Don't need to scan the declaration's sizes; those are always IntLiterals.
                 this->visitExpression(&varDeclStmt.value());
                 break;
             }
             case Statement::Kind::kWhile: {
                 WhileStatement& whileStmt = (*stmt)->as<WhileStatement>();
                 // The loop body is a candidate for inlining.
                 this->visitStatement(&whileStmt.statement());
                 // The inliner isn't smart enough to inline the test-expression for a while loop at
                 // this time. There are two limitations:
                 // - We would need to insert the inlined-body block at the very beginning of the
                 //   while loop's inner fStatement. We don't support that today, but it's doable.
                 // - The while-loop's built-in test-expression would need to be replaced with a
                 //   `true` BoolLiteral, and the loop would be halted via a break statement at the
                 //   end of the inlined test-expression. This is again something we don't support
                 //   today, but it could be implemented.
                 break;
             }
             default:
                 SkUNREACHABLE;
         }
 
         // Pop our symbol and enclosing-statement stacks.
         fSymbolTableStack.resize(oldSymbolStackSize);
         fEnclosingStmtStack.resize(oldEnclosingStmtStackSize);
     }
 
     void visitExpression(std::unique_ptr<Expression>* expr) {
         if (!*expr) {
             return;
         }
 
         switch ((*expr)->kind()) {
             case Expression::Kind::kBoolLiteral:
             case Expression::Kind::kDefined:
             case Expression::Kind::kExternalValue:
             case Expression::Kind::kFieldAccess:
             case Expression::Kind::kFloatLiteral:
             case Expression::Kind::kFunctionReference:
             case Expression::Kind::kIntLiteral:
             case Expression::Kind::kNullLiteral:
             case Expression::Kind::kSetting:
             case Expression::Kind::kTypeReference:
             case Expression::Kind::kVariableReference:
                 // Nothing to scan here.
                 break;
 
             case Expression::Kind::kBinary: {
                 BinaryExpression& binaryExpr = (*expr)->as<BinaryExpression>();
-                this->visitExpression(&binaryExpr.left());
+                this->visitExpression(&binaryExpr.leftPointer());
 
                 // Logical-and and logical-or binary expressions do not inline the right side,
                 // because that would invalidate short-circuiting. That is, when evaluating
                 // expressions like these:
                 //    (false && x())   // always false
                 //    (true || y())    // always true
                 // It is illegal for side-effects from x() or y() to occur. The simplest way to
                 // enforce that rule is to avoid inlining the right side entirely. However, it is
                 // safe for other types of binary expression to inline both sides.
                 Token::Kind op = binaryExpr.getOperator();
                 bool shortCircuitable = (op == Token::Kind::TK_LOGICALAND ||
                                          op == Token::Kind::TK_LOGICALOR);
                 if (!shortCircuitable) {
-                    this->visitExpression(&binaryExpr.right());
+                    this->visitExpression(&binaryExpr.rightPointer());
                 }
                 break;
             }
             case Expression::Kind::kConstructor: {
                 Constructor& constructorExpr = (*expr)->as<Constructor>();
                 for (std::unique_ptr<Expression>& arg : constructorExpr.arguments()) {
                     this->visitExpression(&arg);
                 }
                 break;
             }
             case Expression::Kind::kExternalFunctionCall: {
                 ExternalFunctionCall& funcCallExpr = (*expr)->as<ExternalFunctionCall>();
                 for (std::unique_ptr<Expression>& arg : funcCallExpr.arguments()) {
                     this->visitExpression(&arg);
                 }
                 break;
             }
             case Expression::Kind::kFunctionCall: {
                 FunctionCall& funcCallExpr = (*expr)->as<FunctionCall>();
                 for (std::unique_ptr<Expression>& arg : funcCallExpr.arguments()) {
                     this->visitExpression(&arg);
                 }
                 this->addInlineCandidate(expr);
                 break;
             }
             case Expression::Kind::kIndex:{
                 IndexExpression& indexExpr = (*expr)->as<IndexExpression>();
                 this->visitExpression(&indexExpr.base());
                 this->visitExpression(&indexExpr.index());
                 break;
             }
             case Expression::Kind::kPostfix: {
                 PostfixExpression& postfixExpr = (*expr)->as<PostfixExpression>();
                 this->visitExpression(&postfixExpr.operand());
                 break;
             }
             case Expression::Kind::kPrefix: {
                 PrefixExpression& prefixExpr = (*expr)->as<PrefixExpression>();
                 this->visitExpression(&prefixExpr.operand());
                 break;
             }
             case Expression::Kind::kSwizzle: {
                 Swizzle& swizzleExpr = (*expr)->as<Swizzle>();
                 this->visitExpression(&swizzleExpr.base());
                 break;
             }
             case Expression::Kind::kTernary: {
                 TernaryExpression& ternaryExpr = (*expr)->as<TernaryExpression>();
                 // The test expression is a candidate for inlining.
                 this->visitExpression(&ternaryExpr.test());
                 // The true- and false-expressions cannot be inlined, because we are only allowed to
                 // evaluate one side.
                 break;
             }
             default:
                 SkUNREACHABLE;
         }
     }
 
     void addInlineCandidate(std::unique_ptr<Expression>* candidate) {
         fCandidateList->fCandidates.push_back(
                 InlineCandidate{fSymbolTableStack.back(),
                                 find_parent_statement(fEnclosingStmtStack),
                                 fEnclosingStmtStack.back(),
                                 candidate,
                                 fEnclosingFunction,
                                 /*isLargeFunction=*/false});
     }
 };
diff --git a/src/sksl/SkSLMetalCodeGenerator.cpp b/src/sksl/SkSLMetalCodeGenerator.cpp
index 22a9cab33f..c8ef96a015 100644
--- a/src/sksl/SkSLMetalCodeGenerator.cpp
+++ b/src/sksl/SkSLMetalCodeGenerator.cpp
@@ -823,64 +823,64 @@ void MetalCodeGenerator::writeMatrixTimesEqualHelper(const Type& left, const Typ
 
 void MetalCodeGenerator::writeBinaryExpression(const BinaryExpression& b,
                                                Precedence parentPrecedence) {
-    const Expression& left = *b.left();
-    const Expression& right = *b.right();
+    const Expression& left = b.left();
+    const Expression& right = b.right();
     const Type& leftType = left.type();
     const Type& rightType = right.type();
     Token::Kind op = b.getOperator();
     Precedence precedence = GetBinaryPrecedence(b.getOperator());
     bool needParens = precedence >= parentPrecedence;
     switch (op) {
         case Token::Kind::TK_EQEQ:
             if (leftType.typeKind() == Type::TypeKind::kVector) {
                 this->write("all");
                 needParens = true;
             }
             break;
         case Token::Kind::TK_NEQ:
             if (leftType.typeKind() == Type::TypeKind::kVector) {
                 this->write("any");
                 needParens = true;
             }
             break;
         default:
             break;
     }
     if (needParens) {
         this->write("(");
     }
     if (Compiler::IsAssignment(op) && left.is<VariableReference>() &&
         left.as<VariableReference>().variable()->storage() == Variable::Storage::kParameter &&
         left.as<VariableReference>().variable()->modifiers().fFlags & Modifiers::kOut_Flag) {
         // writing to an out parameter. Since we have to turn those into pointers, we have to
         // dereference it here.
         this->write("*");
     }
     if (op == Token::Kind::TK_STAREQ && leftType.typeKind() == Type::TypeKind::kMatrix &&
         rightType.typeKind() == Type::TypeKind::kMatrix) {
         this->writeMatrixTimesEqualHelper(leftType, rightType, b.type());
     }
     this->writeExpression(left, precedence);
     if (op != Token::Kind::TK_EQ && Compiler::IsAssignment(op) &&
         left.kind() == Expression::Kind::kSwizzle && !left.hasSideEffects()) {
         // This doesn't compile in Metal:
         // float4 x = float4(1);
         // x.xy *= float2x2(...);
         // with the error message "non-const reference cannot bind to vector element",
         // but switching it to x.xy = x.xy * float2x2(...) fixes it. We perform this tranformation
         // as long as the LHS has no side effects, and hope for the best otherwise.
         this->write(" = ");
         this->writeExpression(left, kAssignment_Precedence);
         this->write(" ");
         String opName = Compiler::OperatorName(op);
         SkASSERT(opName.endsWith("="));
         this->write(opName.substr(0, opName.size() - 1).c_str());
         this->write(" ");
     } else {
         this->write(String(" ") + Compiler::OperatorName(op) + " ");
     }
     this->writeExpression(right, precedence);
     if (needParens) {
         this->write(")");
     }
 }
@@ -1231,21 +1231,21 @@ void MetalCodeGenerator::writeName(const String& name) {
 void MetalCodeGenerator::writeVarDeclaration(const VarDeclaration& var, bool global) {
     if (global && !(var.var().modifiers().fFlags & Modifiers::kConst_Flag)) {
         return;
     }
     this->writeModifiers(var.var().modifiers(), global);
     this->writeType(var.baseType());
     this->write(" ");
     this->writeName(var.var().name());
-    for (const std::unique_ptr<Expression>& size : var.sizes()) {
+    for (int i = 0; i < var.sizeCount(); ++i) {
         this->write("[");
-        if (size) {
-            this->writeExpression(*size, kTopLevel_Precedence);
+        if (var.size(i)) {
+            this->writeExpression(*var.size(i), kTopLevel_Precedence);
         }
         this->write("]");
     }
     if (var.value()) {
         this->write(" = ");
         this->writeVarInitializer(var.var(), *var.value());
     }
     this->write(";");
 }
@@ -1366,23 +1366,23 @@ void MetalCodeGenerator::writeDoStatement(const DoStatement& d) {
 void MetalCodeGenerator::writeSwitchStatement(const SwitchStatement& s) {
     this->write("switch (");
     this->writeExpression(*s.value(), kTopLevel_Precedence);
     this->writeLine(") {");
     fIndentation++;
-    for (const std::unique_ptr<SwitchCase>& c : s.cases()) {
-        if (c->value()) {
+    for (const SwitchCase& c : s.cases()) {
+        if (c.value()) {
             this->write("case ");
-            this->writeExpression(*c->value(), kTopLevel_Precedence);
+            this->writeExpression(*c.value(), kTopLevel_Precedence);
             this->writeLine(":");
         } else {
             this->writeLine("default:");
         }
         fIndentation++;
-        for (const auto& stmt : c->statements()) {
+        for (const auto& stmt : c.statements()) {
             this->writeStatement(*stmt);
             this->writeLine();
         }
         fIndentation--;
     }
     fIndentation--;
     this->write("}");
 }
@@ -1684,72 +1684,72 @@ void MetalCodeGenerator::writeProgramElement(const ProgramElement& e) {
 MetalCodeGenerator::Requirements MetalCodeGenerator::requirements(const Expression* e) {
     if (!e) {
         return kNo_Requirements;
     }
     switch (e->kind()) {
         case Expression::Kind::kFunctionCall: {
             const FunctionCall& f = e->as<FunctionCall>();
             Requirements result = this->requirements(f.function());
             for (const auto& arg : f.arguments()) {
                 result |= this->requirements(arg.get());
             }
             return result;
         }
         case Expression::Kind::kConstructor: {
             const Constructor& c = e->as<Constructor>();
             Requirements result = kNo_Requirements;
             for (const auto& arg : c.arguments()) {
                 result |= this->requirements(arg.get());
             }
             return result;
         }
         case Expression::Kind::kFieldAccess: {
             const FieldAccess& f = e->as<FieldAccess>();
             if (FieldAccess::OwnerKind::kAnonymousInterfaceBlock == f.ownerKind()) {
                 return kGlobals_Requirement;
             }
             return this->requirements(f.base().get());
         }
         case Expression::Kind::kSwizzle:
             return this->requirements(e->as<Swizzle>().base().get());
         case Expression::Kind::kBinary: {
             const BinaryExpression& bin = e->as<BinaryExpression>();
-            return this->requirements(bin.left().get()) |
-                   this->requirements(bin.right().get());
+            return this->requirements(&bin.left()) |
+                   this->requirements(&bin.right());
         }
         case Expression::Kind::kIndex: {
             const IndexExpression& idx = e->as<IndexExpression>();
             return this->requirements(idx.base().get()) | this->requirements(idx.index().get());
         }
         case Expression::Kind::kPrefix:
             return this->requirements(e->as<PrefixExpression>().operand().get());
         case Expression::Kind::kPostfix:
             return this->requirements(e->as<PostfixExpression>().operand().get());
         case Expression::Kind::kTernary: {
             const TernaryExpression& t = e->as<TernaryExpression>();
             return this->requirements(t.test().get()) | this->requirements(t.ifTrue().get()) |
                    this->requirements(t.ifFalse().get());
         }
         case Expression::Kind::kVariableReference: {
             const VariableReference& v = e->as<VariableReference>();
             const Modifiers& modifiers = v.variable()->modifiers();
             Requirements result = kNo_Requirements;
             if (modifiers.fLayout.fBuiltin == SK_FRAGCOORD_BUILTIN) {
                 result = kGlobals_Requirement | kFragCoord_Requirement;
             } else if (Variable::Storage::kGlobal == v.variable()->storage()) {
                 if (modifiers.fFlags & Modifiers::kIn_Flag) {
                     result = kInputs_Requirement;
                 } else if (modifiers.fFlags & Modifiers::kOut_Flag) {
                     result = kOutputs_Requirement;
                 } else if (modifiers.fFlags & Modifiers::kUniform_Flag &&
                            v.variable()->type().typeKind() != Type::TypeKind::kSampler) {
                     result = kUniforms_Requirement;
                 } else {
                     result = kGlobals_Requirement;
                 }
             }
             return result;
         }
         default:
             return kNo_Requirements;
     }
 }
@@ -1757,59 +1757,59 @@ MetalCodeGenerator::Requirements MetalCodeGenerator::requirements(const Expressi
 MetalCodeGenerator::Requirements MetalCodeGenerator::requirements(const Statement* s) {
     if (!s) {
         return kNo_Requirements;
     }
     switch (s->kind()) {
         case Statement::Kind::kBlock: {
             Requirements result = kNo_Requirements;
             for (const std::unique_ptr<Statement>& child : s->as<Block>().children()) {
                 result |= this->requirements(child.get());
             }
             return result;
         }
         case Statement::Kind::kVarDeclaration: {
             const VarDeclaration& var = s->as<VarDeclaration>();
             return this->requirements(var.value().get());
         }
         case Statement::Kind::kExpression:
             return this->requirements(s->as<ExpressionStatement>().expression().get());
         case Statement::Kind::kReturn: {
             const ReturnStatement& r = s->as<ReturnStatement>();
             return this->requirements(r.expression().get());
         }
         case Statement::Kind::kIf: {
             const IfStatement& i = s->as<IfStatement>();
             return this->requirements(i.test().get()) |
                    this->requirements(i.ifTrue().get()) |
                    this->requirements(i.ifFalse().get());
         }
         case Statement::Kind::kFor: {
             const ForStatement& f = s->as<ForStatement>();
             return this->requirements(f.initializer().get()) |
                    this->requirements(f.test().get()) |
                    this->requirements(f.next().get()) |
                    this->requirements(f.statement().get());
         }
         case Statement::Kind::kWhile: {
             const WhileStatement& w = s->as<WhileStatement>();
             return this->requirements(w.test().get()) |
                    this->requirements(w.statement().get());
         }
         case Statement::Kind::kDo: {
             const DoStatement& d = s->as<DoStatement>();
             return this->requirements(d.test().get()) |
                    this->requirements(d.statement().get());
         }
         case Statement::Kind::kSwitch: {
             const SwitchStatement& sw = s->as<SwitchStatement>();
             Requirements result = this->requirements(sw.value().get());
-            for (const std::unique_ptr<SwitchCase>& sc : sw.cases()) {
-                for (const auto& st : sc->statements()) {
+            for (const SwitchCase& sc : sw.cases()) {
+                for (const auto& st : sc.statements()) {
                     result |= this->requirements(st.get());
                 }
             }
             return result;
         }
         default:
             return kNo_Requirements;
     }
 }
diff --git a/src/sksl/SkSLSPIRVCodeGenerator.cpp b/src/sksl/SkSLSPIRVCodeGenerator.cpp
index 52d647b18f..5e5ddb64af 100644
--- a/src/sksl/SkSLSPIRVCodeGenerator.cpp
+++ b/src/sksl/SkSLSPIRVCodeGenerator.cpp
@@ -2317,38 +2317,38 @@ SpvId SPIRVCodeGenerator::writeBinaryExpression(const Type& leftType, SpvId lhs,
 }
 
 SpvId SPIRVCodeGenerator::writeBinaryExpression(const BinaryExpression& b, OutputStream& out) {
-    const Expression& left = *b.left();
-    const Expression& right = *b.right();
+    const Expression& left = b.left();
+    const Expression& right = b.right();
     Token::Kind op = b.getOperator();
     // handle cases where we don't necessarily evaluate both LHS and RHS
     switch (op) {
         case Token::Kind::TK_EQ: {
             SpvId rhs = this->writeExpression(right, out);
             this->getLValue(left, out)->store(rhs, out);
             return rhs;
         }
         case Token::Kind::TK_LOGICALAND:
             return this->writeLogicalAnd(b, out);
         case Token::Kind::TK_LOGICALOR:
             return this->writeLogicalOr(b, out);
         default:
             break;
     }
 
     std::unique_ptr<LValue> lvalue;
     SpvId lhs;
     if (Compiler::IsAssignment(op)) {
         lvalue = this->getLValue(left, out);
         lhs = lvalue->load(out);
     } else {
         lvalue = nullptr;
         lhs = this->writeExpression(left, out);
     }
     SpvId rhs = this->writeExpression(right, out);
     SpvId result = this->writeBinaryExpression(left.type(), lhs, Compiler::RemoveAssignment(op),
                                                right.type(), rhs, b.type(), out);
     if (lvalue) {
         lvalue->store(result, out);
     }
     return result;
 }
@@ -2356,20 +2356,20 @@ SpvId SPIRVCodeGenerator::writeBinaryExpression(const BinaryExpression& b, Outpu
 SpvId SPIRVCodeGenerator::writeLogicalAnd(const BinaryExpression& a, OutputStream& out) {
     SkASSERT(a.getOperator() == Token::Kind::TK_LOGICALAND);
     BoolLiteral falseLiteral(fContext, -1, false);
     SpvId falseConstant = this->writeBoolLiteral(falseLiteral);
-    SpvId lhs = this->writeExpression(*a.left(), out);
+    SpvId lhs = this->writeExpression(a.left(), out);
     SpvId rhsLabel = this->nextId();
     SpvId end = this->nextId();
     SpvId lhsBlock = fCurrentBlock;
     this->writeInstruction(SpvOpSelectionMerge, end, SpvSelectionControlMaskNone, out);
     this->writeInstruction(SpvOpBranchConditional, lhs, rhsLabel, end, out);
     this->writeLabel(rhsLabel, out);
-    SpvId rhs = this->writeExpression(*a.right(), out);
+    SpvId rhs = this->writeExpression(a.right(), out);
     SpvId rhsBlock = fCurrentBlock;
     this->writeInstruction(SpvOpBranch, end, out);
     this->writeLabel(end, out);
     SpvId result = this->nextId();
     this->writeInstruction(SpvOpPhi, this->getType(*fContext.fBool_Type), result, falseConstant,
                            lhsBlock, rhs, rhsBlock, out);
     return result;
 }
@@ -2377,20 +2377,20 @@ SpvId SPIRVCodeGenerator::writeLogicalAnd(const BinaryExpression& a, OutputStrea
 SpvId SPIRVCodeGenerator::writeLogicalOr(const BinaryExpression& o, OutputStream& out) {
     SkASSERT(o.getOperator() == Token::Kind::TK_LOGICALOR);
     BoolLiteral trueLiteral(fContext, -1, true);
     SpvId trueConstant = this->writeBoolLiteral(trueLiteral);
-    SpvId lhs = this->writeExpression(*o.left(), out);
+    SpvId lhs = this->writeExpression(o.left(), out);
     SpvId rhsLabel = this->nextId();
     SpvId end = this->nextId();
     SpvId lhsBlock = fCurrentBlock;
     this->writeInstruction(SpvOpSelectionMerge, end, SpvSelectionControlMaskNone, out);
     this->writeInstruction(SpvOpBranchConditional, lhs, end, rhsLabel, out);
     this->writeLabel(rhsLabel, out);
-    SpvId rhs = this->writeExpression(*o.right(), out);
+    SpvId rhs = this->writeExpression(o.right(), out);
     SpvId rhsBlock = fCurrentBlock;
     this->writeInstruction(SpvOpBranch, end, out);
     this->writeLabel(end, out);
     SpvId result = this->nextId();
     this->writeInstruction(SpvOpPhi, this->getType(*fContext.fBool_Type), result, trueConstant,
                            lhsBlock, rhs, rhsBlock, out);
     return result;
 }
@@ -3051,41 +3051,41 @@ void SPIRVCodeGenerator::writeDoStatement(const DoStatement& d, OutputStream& ou
 void SPIRVCodeGenerator::writeSwitchStatement(const SwitchStatement& s, OutputStream& out) {
     SpvId value = this->writeExpression(*s.value(), out);
     std::vector<SpvId> labels;
     SpvId end = this->nextId();
     SpvId defaultLabel = end;
     fBreakTarget.push(end);
     int size = 3;
-    auto& cases = s.cases();
-    for (const std::unique_ptr<SwitchCase>& c : cases) {
+    auto cases = s.cases();
+    for (const SwitchCase& c : cases) {
         SpvId label = this->nextId();
         labels.push_back(label);
-        if (c->value()) {
+        if (c.value()) {
             size += 2;
         } else {
             defaultLabel = label;
         }
     }
     labels.push_back(end);
     this->writeInstruction(SpvOpSelectionMerge, end, SpvSelectionControlMaskNone, out);
     this->writeOpCode(SpvOpSwitch, size, out);
     this->writeWord(value, out);
     this->writeWord(defaultLabel, out);
-    for (size_t i = 0; i < cases.size(); ++i) {
-        if (!cases[i]->value()) {
+    for (int i = 0; i < cases.count(); ++i) {
+        if (!cases[i].value()) {
             continue;
         }
-        this->writeWord(cases[i]->value()->as<IntLiteral>().value(), out);
+        this->writeWord(cases[i].value()->as<IntLiteral>().value(), out);
         this->writeWord(labels[i], out);
     }
-    for (size_t i = 0; i < cases.size(); ++i) {
+    for (int i = 0; i < cases.count(); ++i) {
         this->writeLabel(labels[i], out);
-        for (const auto& stmt : cases[i]->statements()) {
+        for (const auto& stmt : cases[i].statements()) {
             this->writeStatement(*stmt, out);
         }
         if (fCurrentBlock) {
             this->writeInstruction(SpvOpBranch, labels[i + 1], out);
         }
     }
     this->writeLabel(end, out);
     fBreakTarget.pop();
 }
diff --git a/src/sksl/ir/SkSLBinaryExpression.h b/src/sksl/ir/SkSLBinaryExpression.h
index bf59cf9e82..c393fdd3bf 100644
--- a/src/sksl/ir/SkSLBinaryExpression.h
+++ b/src/sksl/ir/SkSLBinaryExpression.h
@@ -50,76 +50,84 @@ class BinaryExpression final : public Expression {
 public:
     static constexpr Kind kExpressionKind = Kind::kBinary;
 
     BinaryExpression(int offset, std::unique_ptr<Expression> left, Token::Kind op,
                      std::unique_ptr<Expression> right, const Type* type)
-    : INHERITED(offset, kExpressionKind, type)
-    , fLeft(std::move(left))
-    , fOperator(op)
-    , fRight(std::move(right)) {
+    : INHERITED(offset, kExpressionKind, TypeTokenData{type, op}) {
+        fExpressionChildren.reserve_back(2);
+        fExpressionChildren.push_back(std::move(left));
+        fExpressionChildren.push_back(std::move(right));
         // If we are assigning to a VariableReference, ensure that it is set to Write or ReadWrite
-        SkASSERT(!Compiler::IsAssignment(op) || check_ref(*this->left()));
+        SkASSERT(!Compiler::IsAssignment(op) || check_ref(this->left()));
     }
 
-    std::unique_ptr<Expression>& left() {
-        return fLeft;
+    const Type& type() const override {
+        return *this->typeTokenData().fType;
     }
 
-    const std::unique_ptr<Expression>& left() const {
-        return fLeft;
+    Expression& left() const {
+        return this->expressionChild(0);
     }
 
-    std::unique_ptr<Expression>& right() {
-        return fRight;
+    std::unique_ptr<Expression>& leftPointer() {
+        return this->expressionPointer(0);
     }
 
-    const std::unique_ptr<Expression>& right() const {
-        return fRight;
+    const std::unique_ptr<Expression>& leftPointer() const {
+        return this->expressionPointer(0);
+    }
+
+    Expression& right() const {
+        return this->expressionChild(1);
+    }
+
+    std::unique_ptr<Expression>& rightPointer() {
+        return this->expressionPointer(1);
+    }
+
+    const std::unique_ptr<Expression>& rightPointer() const {
+        return this->expressionPointer(1);
     }
 
     Token::Kind getOperator() const {
-        return fOperator;
+        return this->typeTokenData().fToken;
     }
 
     bool isConstantOrUniform() const override {
-        return this->left()->isConstantOrUniform() && this->right()->isConstantOrUniform();
+        return this->left().isConstantOrUniform() && this->right().isConstantOrUniform();
     }
 
     std::unique_ptr<Expression> constantPropagate(const IRGenerator& irGenerator,
                                                   const DefinitionMap& definitions) override {
-        return irGenerator.constantFold(*this->left(),
+        return irGenerator.constantFold(this->left(),
                                         this->getOperator(),
-                                        *this->right());
+                                        this->right());
     }
 
     bool hasProperty(Property property) const override {
         if (property == Property::kSideEffects && Compiler::IsAssignment(this->getOperator())) {
             return true;
         }
-        return this->left()->hasProperty(property) || this->right()->hasProperty(property);
+        return this->left().hasProperty(property) || this->right().hasProperty(property);
     }
 
     std::unique_ptr<Expression> clone() const override {
         return std::unique_ptr<Expression>(new BinaryExpression(fOffset,
-                                                                this->left()->clone(),
+                                                                this->left().clone(),
                                                                 this->getOperator(),
-                                                                this->right()->clone(),
+                                                                this->right().clone(),
                                                                 &this->type()));
     }
 
     String description() const override {
-        return "(" + this->left()->description() + " " +
-               Compiler::OperatorName(this->getOperator()) + " " + this->right()->description() +
+        return "(" + this->left().description() + " " +
+               Compiler::OperatorName(this->getOperator()) + " " + this->right().description() +
                ")";
     }
 
 private:
-    std::unique_ptr<Expression> fLeft;
-    Token::Kind fOperator;
-    std::unique_ptr<Expression> fRight;
-
     using INHERITED = Expression;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLBlock.h b/src/sksl/ir/SkSLBlock.h
index b916a5b9bb..faefd7eae1 100644
--- a/src/sksl/ir/SkSLBlock.h
+++ b/src/sksl/ir/SkSLBlock.h
@@ -20,74 +20,65 @@ class Block final : public Statement {
 public:
     static constexpr Kind kStatementKind = Kind::kBlock;
 
     Block(int offset, StatementArray statements,
           const std::shared_ptr<SymbolTable> symbols = nullptr, bool isScope = true)
-    : INHERITED(offset, kStatementKind)
-    , fChildren(std::move(statements))
-    , fSymbolTable(std::move(symbols))
-    , fIsScope(isScope) {}
+    : INHERITED(offset, kStatementKind, BlockData{std::move(symbols), isScope},
+                std::move(statements)) {}
 
     const StatementArray& children() const {
-        return fChildren;
+        return fStatementChildren;
     }
 
     StatementArray& children() {
-        return fChildren;
+        return fStatementChildren;
     }
 
     bool isScope() const {
-        return fIsScope;
+        return this->blockData().fIsScope;
     }
 
     void setIsScope(bool isScope) {
-        fIsScope = isScope;
+        this->blockData().fIsScope = isScope;
     }
 
     std::shared_ptr<SymbolTable> symbolTable() const {
-        return fSymbolTable;
+        return this->blockData().fSymbolTable;
     }
 
     bool isEmpty() const override {
         for (const std::unique_ptr<Statement>& stmt : this->children()) {
             if (!stmt->isEmpty()) {
                 return false;
             }
         }
         return true;
     }
 
     std::unique_ptr<Statement> clone() const override {
         StatementArray cloned;
         cloned.reserve_back(this->children().size());
         for (const std::unique_ptr<Statement>& stmt : this->children()) {
             cloned.push_back(stmt->clone());
         }
         return std::make_unique<Block>(fOffset, std::move(cloned),
                                        SymbolTable::WrapIfBuiltin(this->symbolTable()),
                                        this->isScope());
     }
 
     String description() const override {
         String result("{");
         for (const std::unique_ptr<Statement>& stmt : this->children()) {
             result += "\n";
             result += stmt->description();
         }
         result += "\n}\n";
         return result;
     }
 
 private:
-    StatementArray fChildren;
-    std::shared_ptr<SymbolTable> fSymbolTable;
-    // if isScope is false, this is just a group of statements rather than an actual
-    // language-level block. This allows us to pass around multiple statements as if they were a
-    // single unit, with no semantic impact.
-    bool fIsScope;
-
     using INHERITED = Statement;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLBoolLiteral.h b/src/sksl/ir/SkSLBoolLiteral.h
index 38c51c7423..0bb660ce8d 100644
--- a/src/sksl/ir/SkSLBoolLiteral.h
+++ b/src/sksl/ir/SkSLBoolLiteral.h
@@ -20,45 +20,45 @@ class BoolLiteral final : public Expression {
 public:
     static constexpr Kind kExpressionKind = Kind::kBoolLiteral;
 
     BoolLiteral(const Context& context, int offset, bool value)
-        : INHERITED(offset, kExpressionKind, context.fBool_Type.get())
-        , fValue(value) {}
+    : INHERITED(offset, BoolLiteralData{context.fBool_Type.get(), value}) {}
+
+    const Type& type() const override {
+        return *this->boolLiteralData().fType;
+    }
 
     bool value() const {
-        return fValue;
+        return this->boolLiteralData().fValue;
     }
 
     String description() const override {
         return String(this->value() ? "true" : "false");
     }
 
     bool hasProperty(Property property) const override {
         return false;
     }
 
     bool isCompileTimeConstant() const override {
         return true;
     }
 
     bool compareConstant(const Context& context, const Expression& other) const override {
         const BoolLiteral& b = other.as<BoolLiteral>();
         return this->value() == b.value();
     }
 
     std::unique_ptr<Expression> clone() const override {
         return std::unique_ptr<Expression>(new BoolLiteral(fOffset, this->value(), &this->type()));
     }
 
 private:
     BoolLiteral(int offset, bool value, const Type* type)
-        : INHERITED(offset, kExpressionKind, type)
-        , fValue(value) {}
-
-    bool fValue;
+    : INHERITED(offset, BoolLiteralData{type, value}) {}
 
     using INHERITED = Expression;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLConstructor.h b/src/sksl/ir/SkSLConstructor.h
index 25240b770b..103e4d637f 100644
--- a/src/sksl/ir/SkSLConstructor.h
+++ b/src/sksl/ir/SkSLConstructor.h
@@ -30,94 +30,93 @@ class Constructor final : public Expression {
 public:
     static constexpr Kind kExpressionKind = Kind::kConstructor;
 
     Constructor(int offset, const Type* type, ExpressionArray arguments)
-        : INHERITED(offset, kExpressionKind, type)
-        , fArguments(std::move(arguments)) {}
+            : INHERITED(offset, kExpressionKind, type) {
+        fExpressionChildren = std::move(arguments);
+    }
 
     ExpressionArray& arguments() {
-        return fArguments;
+        return fExpressionChildren;
     }
 
     const ExpressionArray& arguments() const {
-        return fArguments;
+        return fExpressionChildren;
     }
 
     std::unique_ptr<Expression> constantPropagate(const IRGenerator& irGenerator,
                                                   const DefinitionMap& definitions) override;
 
     bool hasProperty(Property property) const override {
         for (const std::unique_ptr<Expression>& arg: this->arguments()) {
             if (arg->hasProperty(property)) {
                 return true;
             }
         }
         return false;
     }
 
     std::unique_ptr<Expression> clone() const override {
         ExpressionArray cloned;
         cloned.reserve_back(this->arguments().size());
         for (const std::unique_ptr<Expression>& arg: this->arguments()) {
             cloned.push_back(arg->clone());
         }
         return std::make_unique<Constructor>(fOffset, &this->type(), std::move(cloned));
     }
 
     String description() const override {
         String result = this->type().description() + "(";
         const char* separator = "";
         for (const std::unique_ptr<Expression>& arg: this->arguments()) {
             result += separator;
             result += arg->description();
             separator = ", ";
         }
         result += ")";
         return result;
     }
 
     bool isCompileTimeConstant() const override {
         for (const std::unique_ptr<Expression>& arg: this->arguments()) {
             if (!arg->isCompileTimeConstant()) {
                 return false;
             }
         }
         return true;
     }
 
     bool isConstantOrUniform() const override {
         for (const std::unique_ptr<Expression>& arg: this->arguments()) {
             if (!arg->isConstantOrUniform()) {
                 return false;
             }
         }
         return true;
     }
 
     bool compareConstant(const Context& context, const Expression& other) const override;
 
     template <typename resultType>
     resultType getVecComponent(int index) const;
 
     SKSL_FLOAT getFVecComponent(int n) const override {
         return this->getVecComponent<SKSL_FLOAT>(n);
     }
 
     /**
      * For a literal vector expression, return the integer value of the n'th vector component. It is
      * an error to call this method on an expression which is not a literal vector.
      */
     SKSL_INT getIVecComponent(int n) const override {
         return this->getVecComponent<SKSL_INT>(n);
     }
 
     SKSL_FLOAT getMatComponent(int col, int row) const override;
 
 private:
-    ExpressionArray fArguments;
-
     using INHERITED = Expression;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLDoStatement.h b/src/sksl/ir/SkSLDoStatement.h
index 231abbac02..39636d7167 100644
--- a/src/sksl/ir/SkSLDoStatement.h
+++ b/src/sksl/ir/SkSLDoStatement.h
@@ -20,45 +20,43 @@ class DoStatement final : public Statement {
 public:
     static constexpr Kind kStatementKind = Kind::kDo;
 
     DoStatement(int offset, std::unique_ptr<Statement> statement,
                 std::unique_ptr<Expression> test)
-        : INHERITED(offset, kStatementKind)
-        , fStatement(std::move(statement))
-        , fTest(std::move(test)) {}
+    : INHERITED(offset, kStatementKind) {
+        fStatementChildren.push_back(std::move(statement));
+        fExpressionChildren.push_back(std::move(test));
+    }
 
     std::unique_ptr<Statement>& statement() {
-        return fStatement;
+        return fStatementChildren[0];
     }
 
     const std::unique_ptr<Statement>& statement() const {
-        return fStatement;
+        return fStatementChildren[0];
     }
 
     std::unique_ptr<Expression>& test() {
-        return fTest;
+        return fExpressionChildren[0];
     }
 
     const std::unique_ptr<Expression>& test() const {
-        return fTest;
+        return fExpressionChildren[0];
     }
 
     std::unique_ptr<Statement> clone() const override {
         return std::unique_ptr<Statement>(new DoStatement(fOffset, this->statement()->clone(),
                                                           this->test()->clone()));
     }
 
     String description() const override {
         return "do " + this->statement()->description() + " while (" + this->test()->description() +
                ");";
     }
 
 private:
-    std::unique_ptr<Statement> fStatement;
-    std::unique_ptr<Expression> fTest;
-
     using INHERITED = Statement;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLExpression.h b/src/sksl/ir/SkSLExpression.h
index 6a69e2f2d5..a0614b1a0d 100644
--- a/src/sksl/ir/SkSLExpression.h
+++ b/src/sksl/ir/SkSLExpression.h
@@ -29,177 +29,220 @@ class Expression : public IRNode {
 public:
     enum class Kind {
         kBinary = (int) Statement::Kind::kLast + 1,
         kBoolLiteral,
         kConstructor,
         kDefined,
         kExternalFunctionCall,
         kExternalValue,
         kIntLiteral,
         kFieldAccess,
         kFloatLiteral,
         kFunctionReference,
         kFunctionCall,
         kIndex,
         kNullLiteral,
         kPrefix,
         kPostfix,
         kSetting,
         kSwizzle,
         kTernary,
         kTypeReference,
         kVariableReference,
 
         kFirst = kBinary,
         kLast = kVariableReference
     };
 
     enum class Property {
         kSideEffects,
         kContainsRTAdjust
     };
 
+    Expression(int offset, const BoolLiteralData& data)
+        : INHERITED(offset, (int) Kind::kBoolLiteral, data) {
+    }
+
+    Expression(int offset, Kind kind, const ExternalValueData& data)
+        : INHERITED(offset, (int) kind, data) {
+        SkASSERT(kind >= Kind::kFirst && kind <= Kind::kLast);
+    }
+
+    Expression(int offset, const FieldAccessData& data)
+        : INHERITED(offset, (int) Kind::kFieldAccess, data) {}
+
+    Expression(int offset, const FloatLiteralData& data)
+        : INHERITED(offset, (int) Kind::kFloatLiteral, data) {}
+
+    Expression(int offset, const FunctionCallData& data)
+        : INHERITED(offset, (int) Kind::kFunctionCall, data) {}
+
+    Expression(int offset, const FunctionReferenceData& data)
+        : INHERITED(offset, (int) Kind::kFunctionReference, data) {}
+
+    Expression(int offset, const IntLiteralData& data)
+        : INHERITED(offset, (int) Kind::kIntLiteral, data) {
+    }
+
+    Expression(int offset, const SettingData& data)
+        : INHERITED(offset, (int) Kind::kSetting, data) {
+    }
+
+    Expression(int offset, const SwizzleData& data)
+        : INHERITED(offset, (int) Kind::kSwizzle, data) {
+    }
+
     Expression(int offset, Kind kind, const Type* type)
-        : INHERITED(offset, (int) kind)
-        , fType(type) {
+        : INHERITED(offset, (int) kind, type) {
         SkASSERT(kind >= Kind::kFirst && kind <= Kind::kLast);
     }
 
+    Expression(int offset, const TypeReferenceData& data)
+        : INHERITED(offset, (int) Kind::kTypeReference, data) {
+    }
+
+    Expression(int offset, Kind kind, const TypeTokenData& data)
+        : INHERITED(offset, (int) kind, data) {
+        SkASSERT(kind >= Kind::kFirst && kind <= Kind::kLast);
+    }
+
+    Expression(int offset, const VariableReferenceData& data)
+        : INHERITED(offset, (int) Kind::kVariableReference, data) {
+    }
+
     Kind kind() const {
         return (Kind) fKind;
     }
 
     virtual const Type& type() const {
-        return *fType;
+        return *this->typeData();
     }
 
     /**
      *  Use is<T> to check the type of an expression.
      *  e.g. replace `e.kind() == Expression::Kind::kIntLiteral` with `e.is<IntLiteral>()`.
      */
     template <typename T>
     bool is() const {
         return this->kind() == T::kExpressionKind;
     }
 
     /**
      *  Use as<T> to downcast expressions: e.g. replace `(IntLiteral&) i` with `i.as<IntLiteral>()`.
      */
     template <typename T>
     const T& as() const {
         SkASSERT(this->is<T>());
         return static_cast<const T&>(*this);
     }
 
     template <typename T>
     T& as() {
         SkASSERT(this->is<T>());
         return static_cast<T&>(*this);
     }
 
     /**
      * Returns true if this expression is constant. compareConstant must be implemented for all
      * constants!
      */
     virtual bool isCompileTimeConstant() const {
         return false;
     }
 
     /**
      * Compares this constant expression against another constant expression of the same type. It is
      * an error to call this on non-constant expressions, or if the types of the expressions do not
      * match.
      */
     virtual bool compareConstant(const Context& context, const Expression& other) const {
         ABORT("cannot call compareConstant on this type");
     }
 
     /**
      * For an expression which evaluates to a constant int, returns the value. Otherwise calls
      * ABORT.
      */
     virtual int64_t getConstantInt() const {
         ABORT("not a constant int");
     }
 
     /**
      * For an expression which evaluates to a constant float, returns the value. Otherwise calls
      * ABORT.
      */
     virtual SKSL_FLOAT getConstantFloat() const {
         ABORT("not a constant float");
     }
 
     /**
      * Returns true if, given fixed values for uniforms, this expression always evaluates to the
      * same result with no side effects.
      */
     virtual bool isConstantOrUniform() const {
         SkASSERT(!this->isCompileTimeConstant() || !this->hasSideEffects());
         return this->isCompileTimeConstant();
     }
 
     virtual bool hasProperty(Property property) const = 0;
 
     bool hasSideEffects() const {
         return this->hasProperty(Property::kSideEffects);
     }
 
     bool containsRTAdjust() const {
         return this->hasProperty(Property::kContainsRTAdjust);
     }
 
     /**
      * Given a map of known constant variable values, substitute them in for references to those
      * variables occurring in this expression and its subexpressions.  Similar simplifications, such
      * as folding a constant binary expression down to a single value, may also be performed.
      * Returns a new expression which replaces this expression, or null if no replacements were
      * made. If a new expression is returned, this expression is no longer valid.
      */
     virtual std::unique_ptr<Expression> constantPropagate(const IRGenerator& irGenerator,
                                                           const DefinitionMap& definitions) {
         return nullptr;
     }
 
     virtual CoercionCost coercionCost(const Type& target) const {
         return this->type().coercionCost(target);
     }
 
     /**
      * For a literal vector expression, return the floating point value of the n'th vector
      * component. It is an error to call this method on an expression which is not a literal vector.
      */
     virtual SKSL_FLOAT getFVecComponent(int n) const {
         SkASSERT(false);
         return 0;
     }
 
     /**
      * For a literal vector expression, return the integer value of the n'th vector component. It is
      * an error to call this method on an expression which is not a literal vector.
      */
     virtual SKSL_INT getIVecComponent(int n) const {
         SkASSERT(false);
         return 0;
     }
 
     /**
      * For a literal matrix expression, return the floating point value of the component at
      * [col][row]. It is an error to call this method on an expression which is not a literal
      * matrix.
      */
     virtual SKSL_FLOAT getMatComponent(int col, int row) const {
         SkASSERT(false);
         return 0;
     }
 
     virtual std::unique_ptr<Expression> clone() const = 0;
 
 private:
-    const Type* fType;
-
     using INHERITED = IRNode;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLExpressionStatement.h b/src/sksl/ir/SkSLExpressionStatement.h
index b14964f78a..8b98ccb612 100644
--- a/src/sksl/ir/SkSLExpressionStatement.h
+++ b/src/sksl/ir/SkSLExpressionStatement.h
@@ -20,32 +20,31 @@ class ExpressionStatement final : public Statement {
 public:
     static constexpr Kind kStatementKind = Kind::kExpression;
 
     ExpressionStatement(std::unique_ptr<Expression> expression)
-        : INHERITED(expression->fOffset, kStatementKind)
-        , fExpression(std::move(expression)) {}
+    : INHERITED(expression->fOffset, kStatementKind) {
+        fExpressionChildren.push_back(std::move(expression));
+    }
 
     const std::unique_ptr<Expression>& expression() const {
-        return fExpression;
+        return fExpressionChildren[0];
     }
 
     std::unique_ptr<Expression>& expression() {
-        return fExpression;
+        return fExpressionChildren[0];
     }
 
     std::unique_ptr<Statement> clone() const override {
         return std::unique_ptr<Statement>(new ExpressionStatement(this->expression()->clone()));
     }
 
     String description() const override {
         return this->expression()->description() + ";";
     }
 
 private:
-    std::unique_ptr<Expression> fExpression;
-
     using INHERITED = Statement;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLExtension.h b/src/sksl/ir/SkSLExtension.h
index d0293d2b4d..f06b4216d2 100644
--- a/src/sksl/ir/SkSLExtension.h
+++ b/src/sksl/ir/SkSLExtension.h
@@ -19,28 +19,25 @@ class Extension final : public ProgramElement {
 public:
     static constexpr Kind kProgramElementKind = Kind::kExtension;
 
     Extension(int offset, String name)
-        : INHERITED(offset, kProgramElementKind)
-        , fName(std::move(name)) {}
+    : INHERITED(offset, kProgramElementKind, name) {}
 
     const String& name() const {
-        return fName;
+        return this->stringData();
     }
 
     std::unique_ptr<ProgramElement> clone() const override {
         return std::unique_ptr<ProgramElement>(new Extension(fOffset, this->name()));
     }
 
     String description() const override {
         return "#extension " + this->name() + " : enable";
     }
 
 private:
-    String fName;
-
     using INHERITED = ProgramElement;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLExternalFunctionCall.h b/src/sksl/ir/SkSLExternalFunctionCall.h
index 05eede241c..bb54ae5b3a 100644
--- a/src/sksl/ir/SkSLExternalFunctionCall.h
+++ b/src/sksl/ir/SkSLExternalFunctionCall.h
@@ -22,64 +22,64 @@ class ExternalFunctionCall final : public Expression {
 public:
     static constexpr Kind kExpressionKind = Kind::kExternalFunctionCall;
 
     ExternalFunctionCall(int offset, const ExternalValue* function, ExpressionArray arguments)
-        : INHERITED(offset, kExpressionKind, &function->callReturnType())
-        , fFunction(*function)
-        , fArguments(std::move(arguments)) {}
+    : INHERITED(offset, kExpressionKind, ExternalValueData{&function->callReturnType(), function}) {
+        fExpressionChildren = std::move(arguments);
+    }
+
+    const Type& type() const override {
+        return *this->externalValueData().fType;
+    }
 
     ExpressionArray& arguments() {
-        return fArguments;
+        return fExpressionChildren;
     }
 
     const ExpressionArray& arguments() const {
-        return fArguments;
+        return fExpressionChildren;
     }
 
     const ExternalValue& function() const {
-        return fFunction;
+        return *this->externalValueData().fValue;
     }
 
     bool hasProperty(Property property) const override {
         if (property == Property::kSideEffects) {
             return true;
         }
         for (const auto& arg : this->arguments()) {
             if (arg->hasProperty(property)) {
                 return true;
             }
         }
         return false;
     }
 
     std::unique_ptr<Expression> clone() const override {
         ExpressionArray cloned;
         cloned.reserve_back(this->arguments().size());
         for (const auto& arg : this->arguments()) {
             cloned.push_back(arg->clone());
         }
         return std::make_unique<ExternalFunctionCall>(fOffset, &this->function(),
                                                       std::move(cloned));
     }
 
     String description() const override {
         String result = String(this->function().name()) + "(";
         String separator;
         for (const std::unique_ptr<Expression>& arg : this->arguments()) {
             result += separator;
             result += arg->description();
             separator = ", ";
         }
         result += ")";
         return result;
     }
 
-private:
-    const ExternalValue& fFunction;
-    ExpressionArray fArguments;
-
     using INHERITED = Expression;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLExternalValueReference.h b/src/sksl/ir/SkSLExternalValueReference.h
index 5c42c6a6fc..ace35ff230 100644
--- a/src/sksl/ir/SkSLExternalValueReference.h
+++ b/src/sksl/ir/SkSLExternalValueReference.h
@@ -20,32 +20,33 @@ class ExternalValueReference final : public Expression {
 public:
     static constexpr Kind kExpressionKind = Kind::kExternalValue;
 
     ExternalValueReference(int offset, const ExternalValue* ev)
-        : INHERITED(offset, kExpressionKind, &ev->type())
-        , fValue(*ev) {}
+    : INHERITED(offset, kExpressionKind, ExternalValueData{&ev->type(), ev}) {}
+
+    const Type& type() const override {
+        return *this->externalValueData().fType;
+    }
 
     const ExternalValue& value() const {
-        return fValue;
+        return *this->externalValueData().fValue;
     }
 
     bool hasProperty(Property property) const override {
         return property == Property::kSideEffects;
     }
 
     String description() const override {
         return String(this->value().name());
     }
 
     std::unique_ptr<Expression> clone() const override {
         return std::unique_ptr<Expression>(new ExternalValueReference(fOffset, &this->value()));
     }
 
 private:
-    const ExternalValue& fValue;
-
     using INHERITED = Expression;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLFieldAccess.h b/src/sksl/ir/SkSLFieldAccess.h
index 3291c1107a..f1dde076fc 100644
--- a/src/sksl/ir/SkSLFieldAccess.h
+++ b/src/sksl/ir/SkSLFieldAccess.h
@@ -27,54 +27,54 @@ class FieldAccess final : public Expression {
 public:
     using OwnerKind = FieldAccessOwnerKind;
 
     static constexpr Kind kExpressionKind = Kind::kFieldAccess;
 
     FieldAccess(std::unique_ptr<Expression> base, int fieldIndex,
                 OwnerKind ownerKind = OwnerKind::kDefault)
-    : INHERITED(base->fOffset, kExpressionKind, base->type().fields()[fieldIndex].fType)
-    , fFieldIndex(fieldIndex)
-    , fOwnerKind(ownerKind)
-    , fBase(std::move(base)) {}
+    : INHERITED(base->fOffset, FieldAccessData{base->type().fields()[fieldIndex].fType,
+                                               fieldIndex, ownerKind}) {
+        fExpressionChildren.push_back(std::move(base));
+    }
+
+    const Type& type() const override {
+        return *this->fieldAccessData().fType;
+    }
 
     std::unique_ptr<Expression>& base() {
-        return fBase;
+        return fExpressionChildren[0];
     }
 
     const std::unique_ptr<Expression>& base() const {
-        return fBase;
+        return fExpressionChildren[0];
     }
 
     int fieldIndex() const {
-        return fFieldIndex;
+        return this->fieldAccessData().fFieldIndex;
     }
 
     OwnerKind ownerKind() const {
-        return fOwnerKind;
+        return this->fieldAccessData().fOwnerKind;
     }
 
     bool hasProperty(Property property) const override {
         return this->base()->hasProperty(property);
     }
 
     std::unique_ptr<Expression> clone() const override {
         return std::unique_ptr<Expression>(new FieldAccess(this->base()->clone(),
                                                            this->fieldIndex(),
                                                            this->ownerKind()));
     }
 
     String description() const override {
         return this->base()->description() + "." +
                this->base()->type().fields()[this->fieldIndex()].fName;
     }
 
 private:
-    int fFieldIndex;
-    FieldAccessOwnerKind fOwnerKind;
-    std::unique_ptr<Expression> fBase;
-
     using INHERITED = Expression;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLFloatLiteral.h b/src/sksl/ir/SkSLFloatLiteral.h
index 87329b1367..81f85ef39b 100644
--- a/src/sksl/ir/SkSLFloatLiteral.h
+++ b/src/sksl/ir/SkSLFloatLiteral.h
@@ -20,55 +20,55 @@ class FloatLiteral final : public Expression {
 public:
     static constexpr Kind kExpressionKind = Kind::kFloatLiteral;
 
     FloatLiteral(const Context& context, int offset, float value)
-        : INHERITED(offset, kExpressionKind, context.fFloatLiteral_Type.get())
-        , fValue(value) {}
+    : INHERITED(offset, FloatLiteralData{context.fFloatLiteral_Type.get(), value}) {}
 
     FloatLiteral(int offset, float value, const Type* type)
-        : INHERITED(offset, kExpressionKind, type)
-        , fValue(value) {}
+    : INHERITED(offset, FloatLiteralData{type, value}) {}
+
+    const Type& type() const override {
+        return *this->floatLiteralData().fType;
+    }
 
     float value() const {
-        return fValue;
+        return this->floatLiteralData().fValue;
     }
 
     String description() const override {
         return to_string(this->value());
     }
 
     bool hasProperty(Property property) const override {
         return false;
     }
 
     bool isCompileTimeConstant() const override {
         return true;
     }
 
     CoercionCost coercionCost(const Type& target) const override {
         if (target.isFloat()) {
             return CoercionCost::Free();
         }
         return INHERITED::coercionCost(target);
     }
 
     bool compareConstant(const Context& context, const Expression& other) const override {
         return this->value() == other.as<FloatLiteral>().value();
     }
 
     SKSL_FLOAT getConstantFloat() const override {
         return this->value();
     }
 
     std::unique_ptr<Expression> clone() const override {
         return std::unique_ptr<Expression>(new FloatLiteral(fOffset, this->value(), &this->type()));
     }
 
 private:
-    float fValue;
-
     using INHERITED = Expression;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLForStatement.h b/src/sksl/ir/SkSLForStatement.h
index 8aaafec450..8afd092edd 100644
--- a/src/sksl/ir/SkSLForStatement.h
+++ b/src/sksl/ir/SkSLForStatement.h
@@ -21,91 +21,87 @@ class ForStatement final : public Statement {
 public:
     static constexpr Kind kStatementKind = Kind::kFor;
 
     ForStatement(int offset, std::unique_ptr<Statement> initializer,
                  std::unique_ptr<Expression> test, std::unique_ptr<Expression> next,
                  std::unique_ptr<Statement> statement, std::shared_ptr<SymbolTable> symbols)
-    : INHERITED(offset, kStatementKind)
-    , fSymbolTable(std::move(symbols))
-    , fInitializer(std::move(initializer))
-    , fTest(std::move(test))
-    , fNext(std::move(next))
-    , fStatement(std::move(statement)) {}
+    : INHERITED(offset, ForStatementData{std::move(symbols)}) {
+        fStatementChildren.reserve_back(2);
+        fStatementChildren.push_back(std::move(initializer));
+        fStatementChildren.push_back(std::move(statement));
+        fExpressionChildren.reserve_back(2);
+        fExpressionChildren.push_back(std::move(test));
+        fExpressionChildren.push_back(std::move(next));
+    }
 
     std::unique_ptr<Statement>& initializer() {
-        return fInitializer;
+        return fStatementChildren[0];
     }
 
     const std::unique_ptr<Statement>& initializer() const {
-        return fInitializer;
+        return fStatementChildren[0];
     }
 
     std::unique_ptr<Expression>& test() {
-        return fTest;
+        return fExpressionChildren[0];
     }
 
     const std::unique_ptr<Expression>& test() const {
-        return fTest;
+        return fExpressionChildren[0];
     }
 
     std::unique_ptr<Expression>& next() {
-        return fNext;
+        return fExpressionChildren[1];
     }
 
     const std::unique_ptr<Expression>& next() const {
-        return fNext;
+        return fExpressionChildren[1];
     }
 
     std::unique_ptr<Statement>& statement() {
-        return fStatement;
+        return fStatementChildren[1];
     }
 
     const std::unique_ptr<Statement>& statement() const {
-        return fStatement;
+        return fStatementChildren[1];
     }
 
-    const std::shared_ptr<SymbolTable>& symbols() const {
-        return fSymbolTable;
+    std::shared_ptr<SymbolTable> symbols() const {
+        return this->forStatementData().fSymbolTable;
     }
 
     std::unique_ptr<Statement> clone() const override {
         return std::make_unique<ForStatement>(
                 fOffset,
                 this->initializer() ? this->initializer()->clone() : nullptr,
                 this->test() ? this->test()->clone() : nullptr,
                 this->next() ? this->next()->clone() : nullptr,
                 this->statement()->clone(),
                 SymbolTable::WrapIfBuiltin(this->symbols()));
     }
 
     String description() const override {
         String result("for (");
         if (this->initializer()) {
             result += this->initializer()->description();
         } else {
             result += ";";
         }
         result += " ";
         if (this->test()) {
             result += this->test()->description();
         }
         result += "; ";
         if (this->next()) {
             result += this->next()->description();
         }
         result += ") " + this->statement()->description();
         return result;
     }
 
 private:
-    std::shared_ptr<SymbolTable> fSymbolTable;
-    std::unique_ptr<Statement> fInitializer;
-    std::unique_ptr<Expression> fTest;
-    std::unique_ptr<Expression> fNext;
-    std::unique_ptr<Statement> fStatement;
-
     using INHERITED = Statement;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLFunctionCall.h b/src/sksl/ir/SkSLFunctionCall.h
index 08ece8fe91..f8d83aa8a6 100644
--- a/src/sksl/ir/SkSLFunctionCall.h
+++ b/src/sksl/ir/SkSLFunctionCall.h
@@ -21,68 +21,69 @@ class FunctionCall final : public Expression {
 public:
     static constexpr Kind kExpressionKind = Kind::kFunctionCall;
 
     FunctionCall(int offset, const Type* type, const FunctionDeclaration* function,
                  ExpressionArray arguments)
-        : INHERITED(offset, kExpressionKind, type)
-        , fFunction(*function)
-        , fArguments(std::move(arguments)) {}
+    : INHERITED(offset, FunctionCallData{type, function}) {
+        fExpressionChildren = std::move(arguments);
+    }
 
     ~FunctionCall() override {}
 
+    const Type& type() const override {
+        return *this->functionCallData().fType;
+    }
+
     const FunctionDeclaration& function() const {
-        return fFunction;
+        return *this->functionCallData().fFunction;
     }
 
     ExpressionArray& arguments() {
-        return fArguments;
+        return fExpressionChildren;
     }
 
     const ExpressionArray& arguments() const {
-        return fArguments;
+        return fExpressionChildren;
     }
 
     bool hasProperty(Property property) const override {
         if (property == Property::kSideEffects && (this->function().modifiers().fFlags &
                                                    Modifiers::kHasSideEffects_Flag)) {
             return true;
         }
         for (const auto& arg : this->arguments()) {
             if (arg->hasProperty(property)) {
                 return true;
             }
         }
         return false;
     }
 
     std::unique_ptr<Expression> clone() const override {
         ExpressionArray cloned;
         cloned.reserve_back(this->arguments().size());
         for (const auto& arg : this->arguments()) {
             cloned.push_back(arg->clone());
         }
         return std::make_unique<FunctionCall>(fOffset, &this->type(), &this->function(),
                                               std::move(cloned));
     }
 
     String description() const override {
         String result = String(this->function().name()) + "(";
         String separator;
         for (size_t i = 0; i < this->arguments().size(); i++) {
             result += separator;
             result += this->arguments()[i]->description();
             separator = ", ";
         }
         result += ")";
         return result;
     }
 
 private:
-    const FunctionDeclaration& fFunction;
-    ExpressionArray fArguments;
-
     using INHERITED = Expression;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLFunctionDefinition.h b/src/sksl/ir/SkSLFunctionDefinition.h
index 419d5cff94..2638e36341 100644
--- a/src/sksl/ir/SkSLFunctionDefinition.h
+++ b/src/sksl/ir/SkSLFunctionDefinition.h
@@ -23,51 +23,52 @@ class FunctionDefinition final : public ProgramElement {
 public:
     static constexpr Kind kProgramElementKind = Kind::kFunction;
 
     FunctionDefinition(int offset,
                        const FunctionDeclaration* declaration, bool builtin,
                        std::unique_ptr<Statement> body,
                        std::unordered_set<const FunctionDeclaration*> referencedIntrinsics = {})
         : INHERITED(offset, kProgramElementKind)
         , fDeclaration(declaration)
         , fBuiltin(builtin)
-        , fBody(std::move(body))
         , fReferencedIntrinsics(std::move(referencedIntrinsics))
-        , fSource(nullptr) {}
+        , fSource(nullptr) {
+        fStatementChildren.push_back(std::move(body));
+    }
 
     const FunctionDeclaration& declaration() const {
         return *fDeclaration;
     }
 
     bool isBuiltin() const {
         return fBuiltin;
     }
 
     std::unique_ptr<Statement>& body() {
-        return fBody;
+        return this->fStatementChildren[0];
     }
 
     const std::unique_ptr<Statement>& body() const {
-        return fBody;
+        return this->fStatementChildren[0];
     }
 
     const std::unordered_set<const FunctionDeclaration*>& referencedIntrinsics() const {
         return fReferencedIntrinsics;
     }
 
     const ASTNode* source() const {
         return fSource;
     }
 
     void setSource(const ASTNode* source) {
         fSource = source;
     }
 
     std::unique_ptr<ProgramElement> clone() const override {
         return std::make_unique<FunctionDefinition>(fOffset, &this->declaration(),
                                                     /*builtin=*/false, this->body()->clone(),
                                                     this->referencedIntrinsics());
     }
 
     String description() const override {
         return this->declaration().description() + " " + this->body()->description();
     }
@@ -75,19 +76,18 @@ public:
 private:
     const FunctionDeclaration* fDeclaration;
     bool fBuiltin;
-    std::unique_ptr<Statement> fBody;
     // We track intrinsic functions we reference so that we can ensure that all of them end up
     // copied into the final output.
     std::unordered_set<const FunctionDeclaration*> fReferencedIntrinsics;
     // This pointer may be null, and even when non-null is not guaranteed to remain valid for
     // the entire lifespan of this object. The parse tree's lifespan is normally controlled by
     // IRGenerator, so the IRGenerator being destroyed or being used to compile another file
     // will invalidate this pointer.
     const ASTNode* fSource;
 
     using INHERITED = ProgramElement;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLFunctionReference.h b/src/sksl/ir/SkSLFunctionReference.h
index c9f7c1b037..e26c5170ca 100644
--- a/src/sksl/ir/SkSLFunctionReference.h
+++ b/src/sksl/ir/SkSLFunctionReference.h
@@ -22,24 +22,27 @@ class FunctionReference final : public Expression {
 public:
     static constexpr Kind kExpressionKind = Kind::kFunctionReference;
 
     FunctionReference(const Context& context, int offset,
                       std::vector<const FunctionDeclaration*> functions)
-        : INHERITED(offset, kExpressionKind, context.fInvalid_Type.get())
-        , fFunctions(std::move(functions)) {}
+    : INHERITED(offset, FunctionReferenceData{context.fInvalid_Type.get(), std::move(functions)}) {}
+
+    const Type& type() const override {
+        return *this->functionReferenceData().fType;
+    }
 
     const std::vector<const FunctionDeclaration*>& functions() const {
-        return fFunctions;
+        return this->functionReferenceData().fFunctions;
     }
 
     bool hasProperty(Property property) const override {
         return false;
     }
 
     std::unique_ptr<Expression> clone() const override {
         return std::unique_ptr<Expression>(new FunctionReference(fOffset, this->functions(),
                                                                  &this->type()));
     }
 
     String description() const override {
         return String("<function>");
     }
@@ -47,14 +50,11 @@ public:
 private:
     FunctionReference(int offset, std::vector<const FunctionDeclaration*> functions,
                       const Type* type)
-        : INHERITED(offset, kExpressionKind, type)
-        , fFunctions(std::move(functions)) {}
-
-    std::vector<const FunctionDeclaration*> fFunctions;
+    : INHERITED(offset, FunctionReferenceData{type, std::move(functions)}) {}
 
     using INHERITED = Expression;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLIRNode.cpp b/src/sksl/ir/SkSLIRNode.cpp
new file mode 100644
index 0000000000..9b1817da41
--- /dev/null
+++ b/src/sksl/ir/SkSLIRNode.cpp
@@ -0,0 +1,137 @@
+/*
+ * Copyright 2020 Google LLC.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "src/sksl/ir/SkSLIRNode.h"
+
+#include "src/sksl/ir/SkSLExpression.h"
+
+namespace SkSL {
+
+IRNode::IRNode(int offset, int kind, const BlockData& data, StatementArray stmts)
+: fOffset(offset)
+, fKind(kind)
+, fData(data)
+, fStatementChildren(std::move(stmts)) {}
+
+IRNode::IRNode(int offset, int kind, const BoolLiteralData& data)
+: fOffset(offset)
+, fKind(kind)
+, fData(data) {}
+
+IRNode::IRNode(int offset, int kind, const ExternalValueData& data)
+: fOffset(offset)
+, fKind(kind)
+, fData(data) {}
+
+IRNode::IRNode(int offset, int kind, const FieldAccessData& data)
+: fOffset(offset)
+, fKind(kind)
+, fData(data) {}
+
+IRNode::IRNode(int offset, int kind, const FloatLiteralData& data)
+: fOffset(offset)
+, fKind(kind)
+, fData(data) {}
+
+IRNode::IRNode(int offset, int kind, const ForStatementData& data)
+: fOffset(offset)
+, fKind(kind)
+, fData(data) {}
+
+IRNode::IRNode(int offset, int kind, const FunctionCallData& data)
+: fOffset(offset)
+, fKind(kind)
+, fData(data) {}
+
+IRNode::IRNode(int offset, int kind, const FunctionReferenceData& data)
+: fOffset(offset)
+, fKind(kind)
+, fData(data) {}
+
+IRNode::IRNode(int offset, int kind, const IfStatementData& data)
+: fOffset(offset)
+, fKind(kind)
+, fData(data) {}
+
+IRNode::IRNode(int offset, int kind, const InlineMarkerData& data)
+: fOffset(offset)
+, fKind(kind)
+, fData(data) {}
+
+IRNode::IRNode(int offset, int kind, const IntLiteralData& data)
+: fOffset(offset)
+, fKind(kind)
+, fData(data) {}
+
+IRNode::IRNode(int offset, int kind, const ModifiersDeclarationData& data)
+: fOffset(offset)
+, fKind(kind)
+, fData(data) {}
+
+IRNode::IRNode(int offset, int kind, const SettingData& data)
+: fOffset(offset)
+, fKind(kind)
+, fData(data) {}
+
+IRNode::IRNode(int offset, int kind, const String& data)
+: fOffset(offset)
+, fKind(kind)
+, fData(data) {}
+
+IRNode::IRNode(int offset, int kind, const SwitchStatementData& data)
+: fOffset(offset)
+, fKind(kind)
+, fData(data) {}
+
+IRNode::IRNode(int offset, int kind, const SwizzleData& data)
+: fOffset(offset)
+, fKind(kind)
+, fData(data) {}
+
+IRNode::IRNode(int offset, int kind, const SymbolData& data)
+: fOffset(offset)
+, fKind(kind)
+, fData(data) {}
+
+IRNode::IRNode(int offset, int kind, const SymbolAliasData& data)
+: fOffset(offset)
+, fKind(kind)
+, fData(data) {}
+
+IRNode::IRNode(int offset, int kind, const Type* data)
+: fOffset(offset)
+, fKind(kind)
+, fData(data) {}
+
+IRNode::IRNode(int offset, int kind, const TypeReferenceData& data)
+: fOffset(offset)
+, fKind(kind)
+, fData(data) {}
+
+IRNode::IRNode(int offset, int kind, const TypeTokenData& data)
+: fOffset(offset)
+, fKind(kind)
+, fData(data) {}
+
+IRNode::IRNode(int offset, int kind, const UnresolvedFunctionData& data)
+: fOffset(offset)
+, fKind(kind)
+, fData(data) {}
+
+IRNode::IRNode(int offset, int kind, const VarDeclarationData& data)
+: fOffset(offset)
+, fKind(kind)
+, fData(data) {}
+
+IRNode::IRNode(int offset, int kind, const VariableReferenceData& data)
+: fOffset(offset)
+, fKind(kind)
+, fData(data) {}
+
+IRNode::~IRNode() {}
+
+} // namespace SkSL
diff --git a/src/sksl/ir/SkSLIRNode.h b/src/sksl/ir/SkSLIRNode.h
index 1883eb12b3..c94bcd513a 100644
--- a/src/sksl/ir/SkSLIRNode.h
+++ b/src/sksl/ir/SkSLIRNode.h
@@ -23,6 +23,7 @@
 namespace SkSL {
 
 class Expression;
+class ExternalValue;
 class FunctionDeclaration;
 class FunctionDefinition;
 class Statement;
@@ -31,6 +32,7 @@ class SymbolTable;
 class Type;
 class Variable;
 class VariableReference;
+enum class FieldAccessOwnerKind : int8_t;
 enum class VariableRefKind : int8_t;
 enum class VariableStorage : int8_t;
 
@@ -43,31 +45,748 @@ using StatementArray = SkSTArray<2, std::unique_ptr<Statement>>;
  */
 class IRNode {
 public:
-    virtual ~IRNode() {}
+    virtual ~IRNode();
+
+    IRNode& operator=(const IRNode& other) {
+        // Need to have a copy assignment operator because Type requires it, but can't use the
+        // default version until we finish migrating away from std::unique_ptr children. For now,
+        // just assert that there are no children (we could theoretically clone them, but we never
+        // actually copy nodes containing children).
+        SkASSERT(other.fExpressionChildren.empty());
+        fKind = other.fKind;
+        fOffset = other.fOffset;
+        fData = other.fData;
+        return *this;
+    }
 
     virtual String description() const = 0;
 
     // character offset of this element within the program being compiled, for error reporting
     // purposes
     int fOffset;
 
     // Override operator new and delete to allow us to use a memory pool.
     static void* operator new(const size_t size) {
         return Pool::AllocIRNode(size);
     }
 
     static void operator delete(void* ptr) {
         Pool::FreeIRNode(ptr);
     }
 
 protected:
-    IRNode(int offset, int kind)
-        : fOffset(offset)
-        , fKind(kind) {}
+    struct BlockData {
+        std::shared_ptr<SymbolTable> fSymbolTable;
+        // if isScope is false, this is just a group of statements rather than an actual
+        // language-level block. This allows us to pass around multiple statements as if they were a
+        // single unit, with no semantic impact.
+        bool fIsScope;
+    };
+
+    struct BoolLiteralData {
+        const Type* fType;
+        bool fValue;
+    };
+
+    struct ExternalValueData {
+        const Type* fType;
+        const ExternalValue* fValue;
+    };
+
+    struct FieldAccessData {
+        const Type* fType;
+        int fFieldIndex;
+        FieldAccessOwnerKind fOwnerKind;
+    };
+
+    struct FloatLiteralData {
+        const Type* fType;
+        float fValue;
+    };
+
+    struct ForStatementData {
+        std::shared_ptr<SymbolTable> fSymbolTable;
+    };
+
+    struct FunctionCallData {
+        const Type* fType;
+        const FunctionDeclaration* fFunction;
+    };
+
+    struct FunctionReferenceData {
+        const Type* fType;
+        std::vector<const FunctionDeclaration*> fFunctions;
+     };
+
+    struct IfStatementData {
+        bool fIsStatic;
+    };
+
+    struct IntLiteralData {
+        const Type* fType;
+        int64_t fValue;
+    };
+
+    struct InlineMarkerData {
+        const FunctionDeclaration* fFunction;
+    };
+
+    struct ModifiersDeclarationData {
+        ModifiersPool::Handle fModifiersHandle;
+    };
+
+    struct SettingData {
+        String fName;
+        const Type* fType;
+    };
+
+    struct SwitchStatementData {
+        bool fIsStatic;
+        std::shared_ptr<SymbolTable> fSymbols;
+    };
+
+    struct SwizzleData {
+        const Type* fType;
+        std::vector<int> fComponents;
+    };
+
+    struct SymbolData {
+        StringFragment fName;
+        const Type* fType;
+    };
+
+    struct SymbolAliasData {
+        StringFragment fName;
+        const Symbol* fOrigSymbol;
+    };
+
+    struct TypeReferenceData {
+        const Type* fType;
+        const Type* fValue;
+     };
+
+    struct TypeTokenData {
+        const Type* fType;
+        Token::Kind fToken;
+    };
+
+    struct UnresolvedFunctionData {
+        // FIXME move this into the child vector after killing fExpressionChildren /
+        // fStatementChildren
+        std::vector<const FunctionDeclaration*> fFunctions;
+    };
+
+    struct VarDeclarationData {
+        const Type* fBaseType;
+        const Variable* fVar;
+    };
+
+    struct VariableReferenceData {
+        const Variable* fVariable;
+        VariableRefKind fRefKind;
+    };
+
+    struct NodeData {
+        enum class Kind {
+            kBlock,
+            kBoolLiteral,
+            kExternalValue,
+            kFieldAccess,
+            kFloatLiteral,
+            kForStatement,
+            kFunctionCall,
+            kFunctionReference,
+            kIfStatement,
+            kInlineMarker,
+            kIntLiteral,
+            kModifiersDeclaration,
+            kSetting,
+            kString,
+            kSwitchStatement,
+            kSwizzle,
+            kSymbol,
+            kSymbolAlias,
+            kType,
+            kTypeReference,
+            kTypeToken,
+            kUnresolvedFunction,
+            kVarDeclaration,
+            kVariableReference,
+        } fKind = Kind::kType;
+        // it doesn't really matter what kind we default to, as long as it's a POD type
+
+        union Contents {
+            BlockData fBlock;
+            BoolLiteralData fBoolLiteral;
+            ExternalValueData fExternalValue;
+            FieldAccessData fFieldAccess;
+            FloatLiteralData fFloatLiteral;
+            ForStatementData fForStatement;
+            FunctionCallData fFunctionCall;
+            FunctionReferenceData fFunctionReference;
+            IfStatementData fIfStatement;
+            InlineMarkerData fInlineMarker;
+            IntLiteralData fIntLiteral;
+            ModifiersDeclarationData fModifiersDeclaration;
+            SettingData fSetting;
+            String fString;
+            SwitchStatementData fSwitchStatement;
+            SwizzleData fSwizzle;
+            SymbolData fSymbol;
+            SymbolAliasData fSymbolAlias;
+            const Type* fType;
+            TypeReferenceData fTypeReference;
+            TypeTokenData fTypeToken;
+            UnresolvedFunctionData fUnresolvedFunction;
+            VarDeclarationData fVarDeclaration;
+            VariableReferenceData fVariableReference;
+
+            Contents() {}
+
+            ~Contents() {}
+        } fContents;
+
+        NodeData(const BlockData& data)
+            : fKind(Kind::kBlock) {
+            *(new(&fContents) BlockData) = data;
+        }
+
+        NodeData(const BoolLiteralData& data)
+            : fKind(Kind::kBoolLiteral) {
+            *(new(&fContents) BoolLiteralData) = data;
+        }
+
+        NodeData(const ExternalValueData& data)
+            : fKind(Kind::kExternalValue) {
+            *(new(&fContents) ExternalValueData) = data;
+        }
+
+        NodeData(const FieldAccessData& data)
+            : fKind(Kind::kFieldAccess) {
+            *(new(&fContents) FieldAccessData) = data;
+        }
+
+        NodeData(const FloatLiteralData& data)
+            : fKind(Kind::kFloatLiteral) {
+            *(new(&fContents) FloatLiteralData) = data;
+        }
+
+        NodeData(const ForStatementData& data)
+            : fKind(Kind::kForStatement) {
+            *(new(&fContents) ForStatementData) = data;
+        }
+
+        NodeData(const FunctionCallData& data)
+            : fKind(Kind::kFunctionCall) {
+            *(new(&fContents) FunctionCallData) = data;
+        }
+
+        NodeData(const FunctionReferenceData& data)
+            : fKind(Kind::kFunctionReference) {
+            *(new(&fContents) FunctionReferenceData) = data;
+        }
+
+        NodeData(IfStatementData data)
+            : fKind(Kind::kIfStatement) {
+            *(new(&fContents) IfStatementData) = data;
+        }
+
+        NodeData(InlineMarkerData data)
+            : fKind(Kind::kInlineMarker) {
+            *(new(&fContents) InlineMarkerData) = data;
+        }
+
+        NodeData(IntLiteralData data)
+            : fKind(Kind::kIntLiteral) {
+            *(new(&fContents) IntLiteralData) = data;
+        }
+
+        NodeData(ModifiersDeclarationData data)
+            : fKind(Kind::kModifiersDeclaration) {
+            *(new(&fContents) ModifiersDeclarationData) = data;
+        }
+
+        NodeData(const SettingData& data)
+            : fKind(Kind::kSetting) {
+            *(new(&fContents) SettingData) = data;
+        }
+
+        NodeData(const String& data)
+            : fKind(Kind::kString) {
+            *(new(&fContents) String) = data;
+        }
+
+        NodeData(const SwitchStatementData& data)
+            : fKind(Kind::kSwitchStatement) {
+            *(new(&fContents) SwitchStatementData) = data;
+        }
+
+        NodeData(const SwizzleData& data)
+            : fKind(Kind::kSwizzle) {
+            *(new(&fContents) SwizzleData) = data;
+        }
+
+        NodeData(const SymbolData& data)
+            : fKind(Kind::kSymbol) {
+            *(new(&fContents) SymbolData) = data;
+        }
+
+        NodeData(const SymbolAliasData& data)
+            : fKind(Kind::kSymbolAlias) {
+            *(new(&fContents) SymbolAliasData) = data;
+        }
+
+        NodeData(const Type* data)
+            : fKind(Kind::kType) {
+            *(new(&fContents) const Type*) = data;
+        }
+
+        NodeData(const TypeReferenceData& data)
+            : fKind(Kind::kTypeReference) {
+            *(new(&fContents) TypeReferenceData) = data;
+        }
+
+        NodeData(const TypeTokenData& data)
+            : fKind(Kind::kTypeToken) {
+            *(new(&fContents) TypeTokenData) = data;
+        }
+
+        NodeData(const UnresolvedFunctionData& data)
+            : fKind(Kind::kUnresolvedFunction) {
+            *(new(&fContents) UnresolvedFunctionData) = data;
+        }
+
+        NodeData(const VarDeclarationData& data)
+            : fKind(Kind::kVarDeclaration) {
+            *(new(&fContents) VarDeclarationData) = data;
+        }
+
+        NodeData(const VariableReferenceData& data)
+            : fKind(Kind::kVariableReference) {
+            *(new(&fContents) VariableReferenceData) = data;
+        }
+
+        NodeData(const NodeData& other) {
+            *this = other;
+        }
+
+        NodeData& operator=(const NodeData& other) {
+            this->cleanup();
+            fKind = other.fKind;
+            switch (fKind) {
+                case Kind::kBlock:
+                    *(new(&fContents) BlockData) = other.fContents.fBlock;
+                    break;
+                case Kind::kBoolLiteral:
+                    *(new(&fContents) BoolLiteralData) = other.fContents.fBoolLiteral;
+                    break;
+                case Kind::kExternalValue:
+                    *(new(&fContents) ExternalValueData) = other.fContents.fExternalValue;
+                    break;
+                case Kind::kFieldAccess:
+                    *(new(&fContents) FieldAccessData) = other.fContents.fFieldAccess;
+                    break;
+                case Kind::kFloatLiteral:
+                    *(new(&fContents) FloatLiteralData) = other.fContents.fFloatLiteral;
+                    break;
+                case Kind::kForStatement:
+                    *(new(&fContents) ForStatementData) = other.fContents.fForStatement;
+                    break;
+                case Kind::kFunctionCall:
+                    *(new(&fContents) FunctionCallData) = other.fContents.fFunctionCall;
+                    break;
+                case Kind::kFunctionReference:
+                    *(new(&fContents) FunctionReferenceData) = other.fContents.fFunctionReference;
+                    break;
+                case Kind::kIfStatement:
+                    *(new(&fContents) IfStatementData) = other.fContents.fIfStatement;
+                    break;
+                case Kind::kInlineMarker:
+                    *(new(&fContents) InlineMarkerData) = other.fContents.fInlineMarker;
+                    break;
+                case Kind::kIntLiteral:
+                    *(new(&fContents) IntLiteralData) = other.fContents.fIntLiteral;
+                    break;
+                case Kind::kModifiersDeclaration:
+                    *(new(&fContents) ModifiersDeclarationData) =
+                                                              other.fContents.fModifiersDeclaration;
+                    break;
+                case Kind::kSetting:
+                    *(new(&fContents) SettingData) = other.fContents.fSetting;
+                    break;
+                case Kind::kString:
+                    *(new(&fContents) String) = other.fContents.fString;
+                    break;
+                case Kind::kSwitchStatement:
+                    *(new(&fContents) SwitchStatementData) = other.fContents.fSwitchStatement;
+                    break;
+                case Kind::kSwizzle:
+                    *(new(&fContents) SwizzleData) = other.fContents.fSwizzle;
+                    break;
+                case Kind::kSymbol:
+                    *(new(&fContents) SymbolData) = other.fContents.fSymbol;
+                    break;
+                case Kind::kSymbolAlias:
+                    *(new(&fContents) SymbolAliasData) = other.fContents.fSymbolAlias;
+                    break;
+                case Kind::kType:
+                    *(new(&fContents) const Type*) = other.fContents.fType;
+                    break;
+                case Kind::kTypeReference:
+                    *(new(&fContents) TypeReferenceData) = other.fContents.fTypeReference;
+                    break;
+                case Kind::kTypeToken:
+                    *(new(&fContents) TypeTokenData) = other.fContents.fTypeToken;
+                    break;
+                case Kind::kUnresolvedFunction:
+                    *(new(&fContents) UnresolvedFunctionData) = other.fContents.fUnresolvedFunction;
+                    break;
+                case Kind::kVarDeclaration:
+                    *(new(&fContents) VarDeclarationData) = other.fContents.fVarDeclaration;
+                    break;
+                case Kind::kVariableReference:
+                    *(new(&fContents) VariableReferenceData) = other.fContents.fVariableReference;
+                    break;
+            }
+            return *this;
+        }
+
+        ~NodeData() {
+            this->cleanup();
+        }
+
+    private:
+        void cleanup() {
+            switch (fKind) {
+                case Kind::kBlock:
+                    fContents.fBlock.~BlockData();
+                    break;
+                case Kind::kBoolLiteral:
+                    fContents.fBoolLiteral.~BoolLiteralData();
+                    break;
+                case Kind::kExternalValue:
+                    fContents.fExternalValue.~ExternalValueData();
+                    break;
+                case Kind::kFieldAccess:
+                    fContents.fFieldAccess.~FieldAccessData();
+                    break;
+                case Kind::kFloatLiteral:
+                    fContents.fFloatLiteral.~FloatLiteralData();
+                    break;
+                case Kind::kForStatement:
+                    fContents.fForStatement.~ForStatementData();
+                    break;
+                case Kind::kFunctionCall:
+                    fContents.fFunctionCall.~FunctionCallData();
+                    break;
+                case Kind::kFunctionReference:
+                    fContents.fFunctionReference.~FunctionReferenceData();
+                    break;
+                case Kind::kIfStatement:
+                    fContents.fIfStatement.~IfStatementData();
+                    break;
+                case Kind::kInlineMarker:
+                    fContents.fInlineMarker.~InlineMarkerData();
+                    break;
+                case Kind::kIntLiteral:
+                    fContents.fIntLiteral.~IntLiteralData();
+                    break;
+                case Kind::kModifiersDeclaration:
+                    fContents.fModifiersDeclaration.~ModifiersDeclarationData();
+                    break;
+                case Kind::kSetting:
+                    fContents.fSetting.~SettingData();
+                    break;
+                case Kind::kString:
+                    fContents.fString.~String();
+                    break;
+                case Kind::kSwitchStatement:
+                    fContents.fSwitchStatement.~SwitchStatementData();
+                    break;
+                case Kind::kSwizzle:
+                    fContents.fSwizzle.~SwizzleData();
+                    break;
+                case Kind::kSymbol:
+                    fContents.fSymbol.~SymbolData();
+                    break;
+                case Kind::kSymbolAlias:
+                    fContents.fSymbolAlias.~SymbolAliasData();
+                    break;
+                case Kind::kType:
+                    break;
+                case Kind::kTypeReference:
+                    fContents.fTypeReference.~TypeReferenceData();
+                    break;
+                case Kind::kTypeToken:
+                    fContents.fTypeToken.~TypeTokenData();
+                    break;
+                case Kind::kUnresolvedFunction:
+                    fContents.fUnresolvedFunction.~UnresolvedFunctionData();
+                    break;
+                case Kind::kVarDeclaration:
+                    fContents.fVarDeclaration.~VarDeclarationData();
+                    break;
+                case Kind::kVariableReference:
+                    fContents.fVariableReference.~VariableReferenceData();
+                    break;
+            }
+        }
+    };
+
+    IRNode(int offset, int kind, const BlockData& data, StatementArray stmts);
+
+    IRNode(int offset, int kind, const BoolLiteralData& data);
+
+    IRNode(int offset, int kind, const ExternalValueData& data);
+
+    IRNode(int offset, int kind, const FieldAccessData& data);
+
+    IRNode(int offset, int kind, const FloatLiteralData& data);
+
+    IRNode(int offset, int kind, const ForStatementData& data);
+
+    IRNode(int offset, int kind, const FunctionCallData& data);
+
+    IRNode(int offset, int kind, const FunctionReferenceData& data);
+
+    IRNode(int offset, int kind, const IfStatementData& data);
+
+    IRNode(int offset, int kind, const InlineMarkerData& data);
+
+    IRNode(int offset, int kind, const IntLiteralData& data);
+
+    IRNode(int offset, int kind, const ModifiersDeclarationData& data);
+
+    IRNode(int offset, int kind, const SettingData& data);
+
+    IRNode(int offset, int kind, const String& data);
+
+    IRNode(int offset, int kind, const SwitchStatementData& data);
+
+    IRNode(int offset, int kind, const SwizzleData& data);
+
+    IRNode(int offset, int kind, const SymbolData& data);
+
+    IRNode(int offset, int kind, const SymbolAliasData& data);
+
+    IRNode(int offset, int kind, const Type* data = nullptr);
+
+    IRNode(int offset, int kind, const TypeReferenceData& data);
+
+    IRNode(int offset, int kind, const TypeTokenData& data);
+
+    IRNode(int offset, int kind, const UnresolvedFunctionData& data);
+
+    IRNode(int offset, int kind, const VarDeclarationData& data);
+
+    IRNode(int offset, int kind, const VariableReferenceData& data);
+
+    Expression& expressionChild(int index) const {
+        SkASSERT(index >= 0 && index < (int) fExpressionChildren.size());
+        return *fExpressionChildren[index];
+    }
+
+    std::unique_ptr<Expression>& expressionPointer(int index) {
+        SkASSERT(index >= 0 && index < (int) fExpressionChildren.size());
+        return fExpressionChildren[index];
+    }
+
+    const std::unique_ptr<Expression>& expressionPointer(int index) const {
+        SkASSERT(index >= 0 && index < (int) fExpressionChildren.size());
+        return fExpressionChildren[index];
+    }
+
+    int expressionChildCount() const {
+        return fExpressionChildren.size();
+    }
+
+
+    Statement& statementChild(int index) const {
+        SkASSERT(index >= 0 && index < (int) fStatementChildren.size());
+        return *fStatementChildren[index];
+    }
+
+    std::unique_ptr<Statement>& statementPointer(int index) {
+        SkASSERT(index >= 0 && index < (int) fStatementChildren.size());
+        return fStatementChildren[index];
+    }
+
+    const std::unique_ptr<Statement>& statementPointer(int index) const {
+        SkASSERT(index >= 0 && index < (int) fStatementChildren.size());
+        return fStatementChildren[index];
+    }
+
+    int statementChildCount() const {
+        return fStatementChildren.size();
+    }
+
+    BlockData& blockData() {
+        SkASSERT(fData.fKind == NodeData::Kind::kBlock);
+        return fData.fContents.fBlock;
+    }
+
+    const BlockData& blockData() const {
+        SkASSERT(fData.fKind == NodeData::Kind::kBlock);
+        return fData.fContents.fBlock;
+    }
+
+    const BoolLiteralData& boolLiteralData() const {
+        SkASSERT(fData.fKind == NodeData::Kind::kBoolLiteral);
+        return fData.fContents.fBoolLiteral;
+    }
+
+    const ExternalValueData& externalValueData() const {
+        SkASSERT(fData.fKind == NodeData::Kind::kExternalValue);
+        return fData.fContents.fExternalValue;
+    }
+
+    const FieldAccessData& fieldAccessData() const {
+        SkASSERT(fData.fKind == NodeData::Kind::kFieldAccess);
+        return fData.fContents.fFieldAccess;
+    }
+
+    const FloatLiteralData& floatLiteralData() const {
+        SkASSERT(fData.fKind == NodeData::Kind::kFloatLiteral);
+        return fData.fContents.fFloatLiteral;
+    }
+
+    const ForStatementData& forStatementData() const {
+        SkASSERT(fData.fKind == NodeData::Kind::kForStatement);
+        return fData.fContents.fForStatement;
+    }
+
+    const FunctionCallData& functionCallData() const {
+        SkASSERT(fData.fKind == NodeData::Kind::kFunctionCall);
+        return fData.fContents.fFunctionCall;
+    }
+
+    const FunctionReferenceData& functionReferenceData() const {
+        SkASSERT(fData.fKind == NodeData::Kind::kFunctionReference);
+        return fData.fContents.fFunctionReference;
+    }
+
+    const IfStatementData& ifStatementData() const {
+        SkASSERT(fData.fKind == NodeData::Kind::kIfStatement);
+        return fData.fContents.fIfStatement;
+    }
+
+    const InlineMarkerData& inlineMarkerData() const {
+        SkASSERT(fData.fKind == NodeData::Kind::kInlineMarker);
+        return fData.fContents.fInlineMarker;
+    }
+
+    const IntLiteralData& intLiteralData() const {
+        SkASSERT(fData.fKind == NodeData::Kind::kIntLiteral);
+        return fData.fContents.fIntLiteral;
+    }
+
+    const ModifiersDeclarationData& modifiersDeclarationData() const {
+        SkASSERT(fData.fKind == NodeData::Kind::kModifiersDeclaration);
+        return fData.fContents.fModifiersDeclaration;
+    }
+
+    const SettingData& settingData() const {
+        SkASSERT(fData.fKind == NodeData::Kind::kSetting);
+        return fData.fContents.fSetting;
+    }
+
+    const String& stringData() const {
+        SkASSERT(fData.fKind == NodeData::Kind::kString);
+        return fData.fContents.fString;
+    }
+
+    SwitchStatementData& switchStatementData() {
+        SkASSERT(fData.fKind == NodeData::Kind::kSwitchStatement);
+        return fData.fContents.fSwitchStatement;
+    }
+
+    const SwitchStatementData& switchStatementData() const {
+        SkASSERT(fData.fKind == NodeData::Kind::kSwitchStatement);
+        return fData.fContents.fSwitchStatement;
+    }
+
+    SwizzleData& swizzleData() {
+        SkASSERT(fData.fKind == NodeData::Kind::kSwizzle);
+        return fData.fContents.fSwizzle;
+    }
+
+    const SwizzleData& swizzleData() const {
+        SkASSERT(fData.fKind == NodeData::Kind::kSwizzle);
+        return fData.fContents.fSwizzle;
+    }
+
+    SymbolData& symbolData() {
+        SkASSERT(fData.fKind == NodeData::Kind::kSymbol);
+        return fData.fContents.fSymbol;
+    }
+
+    const SymbolData& symbolData() const {
+        SkASSERT(fData.fKind == NodeData::Kind::kSymbol);
+        return fData.fContents.fSymbol;
+    }
+
+    const SymbolAliasData& symbolAliasData() const {
+        SkASSERT(fData.fKind == NodeData::Kind::kSymbolAlias);
+        return fData.fContents.fSymbolAlias;
+    }
+
+    const Type* typeData() const {
+        SkASSERT(fData.fKind == NodeData::Kind::kType);
+        return fData.fContents.fType;
+    }
+
+    const TypeReferenceData& typeReferenceData() const {
+        SkASSERT(fData.fKind == NodeData::Kind::kTypeReference);
+        return fData.fContents.fTypeReference;
+    }
+
+    const TypeTokenData& typeTokenData() const {
+        SkASSERT(fData.fKind == NodeData::Kind::kTypeToken);
+        return fData.fContents.fTypeToken;
+    }
+
+    const UnresolvedFunctionData& unresolvedFunctionData() const {
+        SkASSERT(fData.fKind == NodeData::Kind::kUnresolvedFunction);
+        return fData.fContents.fUnresolvedFunction;
+    }
+
+    VarDeclarationData& varDeclarationData() {
+        SkASSERT(fData.fKind == NodeData::Kind::kVarDeclaration);
+        return fData.fContents.fVarDeclaration;
+    }
+
+    const VarDeclarationData& varDeclarationData() const {
+        SkASSERT(fData.fKind == NodeData::Kind::kVarDeclaration);
+        return fData.fContents.fVarDeclaration;
+    }
+
+    VariableReferenceData& variableReferenceData() {
+        SkASSERT(fData.fKind == NodeData::Kind::kVariableReference);
+        return fData.fContents.fVariableReference;
+    }
+
+    const VariableReferenceData& variableReferenceData() const {
+        SkASSERT(fData.fKind == NodeData::Kind::kVariableReference);
+        return fData.fContents.fVariableReference;
+    }
 
     int fKind;
+
+    NodeData fData;
+
+    // Needing two separate vectors is a temporary issue. Ideally, we'd just be able to use a single
+    // vector of nodes, but there are various spots where we take pointers to std::unique_ptr<>,
+    // and it isn't safe to pun std::unique_ptr<IRNode> to std::unique_ptr<Statement / Expression>.
+    // And we can't update the call sites to expect std::unique_ptr<IRNode> while there are still
+    // old-style nodes around.
+    // When the transition is finished, we'll be able to drop the unique_ptrs and just handle
+    // <IRNode> directly.
+    ExpressionArray fExpressionChildren;
+    // it's important to keep the statement array defined after (and thus destroyed before) fData,
+    // because destroying statements can modify reference counts in a SymbolTable contained in fData
+    StatementArray fStatementChildren;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLIfStatement.h b/src/sksl/ir/SkSLIfStatement.h
index 56aaab99c0..15145ed296 100644
--- a/src/sksl/ir/SkSLIfStatement.h
+++ b/src/sksl/ir/SkSLIfStatement.h
@@ -16,75 +16,69 @@ namespace SkSL {
 /**
  * An 'if' statement.
  */
-class IfStatement final : public Statement {
-public:
+struct IfStatement final : public Statement {
     static constexpr Kind kStatementKind = Kind::kIf;
 
     IfStatement(int offset, bool isStatic, std::unique_ptr<Expression> test,
                 std::unique_ptr<Statement> ifTrue, std::unique_ptr<Statement> ifFalse)
-        : INHERITED(offset, kStatementKind)
-        , fTest(std::move(test))
-        , fIfTrue(std::move(ifTrue))
-        , fIfFalse(std::move(ifFalse))
-        , fIsStatic(isStatic) {}
+    : INHERITED(offset, IfStatementData{isStatic}) {
+        fExpressionChildren.push_back(std::move(test));
+        fStatementChildren.reserve_back(2);
+        fStatementChildren.push_back(std::move(ifTrue));
+        fStatementChildren.push_back(std::move(ifFalse));
+    }
 
     bool isStatic() const {
-        return fIsStatic;
+        return this->ifStatementData().fIsStatic;
     }
 
     std::unique_ptr<Expression>& test() {
-        return fTest;
+        return this->fExpressionChildren[0];
     }
 
     const std::unique_ptr<Expression>& test() const {
-        return fTest;
+        return this->fExpressionChildren[0];
     }
 
     std::unique_ptr<Statement>& ifTrue() {
-        return fIfTrue;
+        return this->fStatementChildren[0];
     }
 
     const std::unique_ptr<Statement>& ifTrue() const {
-        return fIfTrue;
+        return this->fStatementChildren[0];
     }
 
     std::unique_ptr<Statement>& ifFalse() {
-        return fIfFalse;
+        return this->fStatementChildren[1];
     }
 
     const std::unique_ptr<Statement>& ifFalse() const {
-        return fIfFalse;
+        return this->fStatementChildren[1];
     }
 
     std::unique_ptr<Statement> clone() const override {
         return std::unique_ptr<Statement>(new IfStatement(fOffset, this->isStatic(),
                                                           this->test()->clone(),
                                                           this->ifTrue()->clone(),
                                                           this->ifFalse() ? this->ifFalse()->clone()
                                                                           : nullptr));
     }
 
     String description() const override {
         String result;
         if (this->isStatic()) {
             result += "@";
         }
         result += "if (" + this->test()->description() + ") " + this->ifTrue()->description();
         if (this->ifFalse()) {
             result += " else " + this->ifFalse()->description();
         }
         return result;
     }
 
-private:
-    std::unique_ptr<Expression> fTest;
-    std::unique_ptr<Statement> fIfTrue;
-    std::unique_ptr<Statement> fIfFalse;
-    bool fIsStatic;
-
     using INHERITED = Statement;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLIndexExpression.h b/src/sksl/ir/SkSLIndexExpression.h
index 4151173f84..0816975b64 100644
--- a/src/sksl/ir/SkSLIndexExpression.h
+++ b/src/sksl/ir/SkSLIndexExpression.h
@@ -41,43 +41,46 @@ static const Type& index_type(const Context& context, const Type& type) {
 /**
  * An expression which extracts a value from an array or matrix, as in 'm[2]'.
  */
 struct IndexExpression final : public Expression {
     static constexpr Kind kExpressionKind = Kind::kIndex;
 
     IndexExpression(const Context& context, std::unique_ptr<Expression> base,
                     std::unique_ptr<Expression> index)
-        : INHERITED(base->fOffset, kExpressionKind, &index_type(context, base->type()))
-        , fBase(std::move(base))
-        , fIndex(std::move(index)) {}
+    : INHERITED(base->fOffset, kExpressionKind, &index_type(context, base->type())) {
+        SkASSERT(index->type() == *context.fInt_Type || index->type() == *context.fUInt_Type);
+        fExpressionChildren.reserve_back(2);
+        fExpressionChildren.push_back(std::move(base));
+        fExpressionChildren.push_back(std::move(index));
+    }
 
     std::unique_ptr<Expression>& base() {
-        return fBase;
+        return fExpressionChildren[0];
     }
 
     const std::unique_ptr<Expression>& base() const {
-        return fBase;
+        return fExpressionChildren[0];
     }
 
     std::unique_ptr<Expression>& index() {
-        return fIndex;
+        return fExpressionChildren[1];
     }
 
     const std::unique_ptr<Expression>& index() const {
-        return fIndex;
+        return fExpressionChildren[1];
     }
 
     bool hasProperty(Property property) const override {
         return this->base()->hasProperty(property) || this->index()->hasProperty(property);
     }
 
     std::unique_ptr<Expression> clone() const override {
         return std::unique_ptr<Expression>(new IndexExpression(this->base()->clone(),
                                                                this->index()->clone(),
                                                                &this->type()));
     }
 
     String description() const override {
         return this->base()->description() + "[" + this->index()->description() + "]";
     }
 
     using INHERITED = Expression;
@@ -85,15 +88,13 @@ struct IndexExpression final : public Expression {
 private:
     IndexExpression(std::unique_ptr<Expression> base, std::unique_ptr<Expression> index,
                     const Type* type)
-        : INHERITED(base->fOffset, Kind::kIndex, type)
-        , fBase(std::move(base))
-        , fIndex(std::move(index)) {}
-
-
-    std::unique_ptr<Expression> fBase;
-    std::unique_ptr<Expression> fIndex;
+    : INHERITED(base->fOffset, Kind::kIndex, type) {
+        fExpressionChildren.reserve_back(2);
+        fExpressionChildren.push_back(std::move(base));
+        fExpressionChildren.push_back(std::move(index));
+    }
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLInlineMarker.h b/src/sksl/ir/SkSLInlineMarker.h
index 45f4680004..bce27d7a80 100644
--- a/src/sksl/ir/SkSLInlineMarker.h
+++ b/src/sksl/ir/SkSLInlineMarker.h
@@ -22,32 +22,29 @@ class InlineMarker final : public Statement {
 public:
     static constexpr Kind kStatementKind = Kind::kInlineMarker;
 
     InlineMarker(const FunctionDeclaration* function)
-            : INHERITED(-1, kStatementKind)
-            , fFunction(*function) {}
+            : INHERITED(-1, InlineMarkerData{function}) {}
 
     const FunctionDeclaration& function() const {
-        return fFunction;
+        return *this->inlineMarkerData().fFunction;
     }
 
     bool isEmpty() const override {
         return true;
     }
 
     String description() const override {
         return String("/* inlined: ") + this->function().name() + String(" */");
     }
 
     std::unique_ptr<Statement> clone() const override {
         return std::make_unique<InlineMarker>(&this->function());
     }
 
 private:
-    const FunctionDeclaration& fFunction;
-
     using INHERITED = Statement;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLIntLiteral.h b/src/sksl/ir/SkSLIntLiteral.h
index 74d45912f3..9554e967f0 100644
--- a/src/sksl/ir/SkSLIntLiteral.h
+++ b/src/sksl/ir/SkSLIntLiteral.h
@@ -20,58 +20,58 @@ class IntLiteral final : public Expression {
 public:
     static constexpr Kind kExpressionKind = Kind::kIntLiteral;
 
     // FIXME: we will need to revisit this if/when we add full support for both signed and unsigned
     // 64-bit integers, but for right now an int64_t will hold every value we care about
     IntLiteral(const Context& context, int offset, int64_t value)
-        : INHERITED(offset, kExpressionKind, context.fInt_Type.get())
-        , fValue(value) {}
+    : INHERITED(offset, IntLiteralData{context.fInt_Type.get(), value}) {}
 
     IntLiteral(int offset, int64_t value, const Type* type = nullptr)
-        : INHERITED(offset, kExpressionKind, type)
-        , fValue(value) {}
+    : INHERITED(offset, IntLiteralData{type, value}) {}
+
+    const Type& type() const override {
+        return *this->intLiteralData().fType;
+    }
 
     int64_t value() const {
-        return fValue;
+        return this->intLiteralData().fValue;
     }
 
     String description() const override {
         return to_string(this->value());
     }
 
     bool hasProperty(Property property) const override {
         return false;
     }
 
     bool isCompileTimeConstant() const override {
         return true;
     }
 
     bool compareConstant(const Context& context, const Expression& other) const override {
         return this->value() == other.as<IntLiteral>().value();
     }
 
     CoercionCost coercionCost(const Type& target) const override {
         if (target.isSigned() || target.isUnsigned() || target.isFloat() ||
             target.typeKind() == Type::TypeKind::kEnum) {
             return CoercionCost::Free();
         }
         return INHERITED::coercionCost(target);
     }
 
     int64_t getConstantInt() const override {
         return this->value();
     }
 
     std::unique_ptr<Expression> clone() const override {
         return std::unique_ptr<Expression>(new IntLiteral(fOffset, this->value(), &this->type()));
     }
 
 private:
-    int64_t fValue;
-
     using INHERITED = Expression;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLInterfaceBlock.h b/src/sksl/ir/SkSLInterfaceBlock.h
index 6353d7f7cf..60b4ff738d 100644
--- a/src/sksl/ir/SkSLInterfaceBlock.h
+++ b/src/sksl/ir/SkSLInterfaceBlock.h
@@ -28,73 +28,74 @@ class InterfaceBlock final : public ProgramElement {
 public:
     static constexpr Kind kProgramElementKind = Kind::kInterfaceBlock;
 
     InterfaceBlock(int offset, const Variable* var, String typeName, String instanceName,
                    ExpressionArray sizes, std::shared_ptr<SymbolTable> typeOwner)
     : INHERITED(offset, kProgramElementKind)
     , fVariable(var)
     , fTypeName(std::move(typeName))
     , fInstanceName(std::move(instanceName))
-    , fSizes(std::move(sizes))
-    , fTypeOwner(std::move(typeOwner)) {}
+    , fTypeOwner(std::move(typeOwner)) {
+        fExpressionChildren.move_back_n(sizes.size(), sizes.data());
+    }
 
     const Variable& variable() const {
         return *fVariable;
     }
 
     void setVariable(const Variable* var) {
         fVariable = var;
     }
 
     const String& typeName() const {
         return fTypeName;
     }
 
     const String& instanceName() const {
         return fInstanceName;
     }
 
     const std::shared_ptr<SymbolTable>& typeOwner() const {
         return fTypeOwner;
     }
 
     ExpressionArray& sizes() {
-        return fSizes;
+        return fExpressionChildren;
     }
 
     const ExpressionArray& sizes() const {
-        return fSizes;
+        return fExpressionChildren;
     }
 
     std::unique_ptr<ProgramElement> clone() const override {
         ExpressionArray sizesClone;
         sizesClone.reserve_back(this->sizes().size());
         for (const auto& size : this->sizes()) {
             sizesClone.push_back(size ? size->clone() : nullptr);
         }
         return std::make_unique<InterfaceBlock>(fOffset, &this->variable(), this->typeName(),
                                                 this->instanceName(), std::move(sizesClone),
                                                 SymbolTable::WrapIfBuiltin(this->typeOwner()));
     }
 
     String description() const override {
         String result = this->variable().modifiers().description() + this->typeName() + " {\n";
         const Type* structType = &this->variable().type();
         while (structType->typeKind() == Type::TypeKind::kArray) {
             structType = &structType->componentType();
         }
         for (const auto& f : structType->fields()) {
             result += f.description() + "\n";
         }
         result += "}";
         if (this->instanceName().size()) {
             result += " " + this->instanceName();
             for (const auto& size : this->sizes()) {
                 result += "[";
                 if (size) {
                     result += size->description();
                 }
                 result += "]";
             }
         }
         return result + ";";
     }
@@ -102,13 +103,12 @@ public:
 private:
     const Variable* fVariable;
     String fTypeName;
     String fInstanceName;
-    ExpressionArray fSizes;
     std::shared_ptr<SymbolTable> fTypeOwner;
 
     using INHERITED = ProgramElement;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLModifiersDeclaration.h b/src/sksl/ir/SkSLModifiersDeclaration.h
index 25433ffe15..a9ef296c21 100644
--- a/src/sksl/ir/SkSLModifiersDeclaration.h
+++ b/src/sksl/ir/SkSLModifiersDeclaration.h
@@ -22,32 +22,29 @@ class ModifiersDeclaration final : public ProgramElement {
 public:
     static constexpr Kind kProgramElementKind = Kind::kModifiers;
 
     ModifiersDeclaration(ModifiersPool::Handle modifiers)
-        : INHERITED(-1, kProgramElementKind)
-        , fModifiersHandle(modifiers) {}
+    : INHERITED(-1, ModifiersDeclarationData{modifiers}) {}
 
     const Modifiers& modifiers() const {
-        return *fModifiersHandle;
+        return *this->modifiersDeclarationData().fModifiersHandle;
     }
 
     const ModifiersPool::Handle& modifiersHandle() const {
-        return fModifiersHandle;
+        return this->modifiersDeclarationData().fModifiersHandle;
     }
 
     std::unique_ptr<ProgramElement> clone() const override {
         return std::unique_ptr<ProgramElement>(new ModifiersDeclaration(this->modifiersHandle()));
     }
 
     String description() const override {
         return this->modifiers().description() + ";";
     }
 
 private:
-    ModifiersPool::Handle fModifiersHandle;
-
     using INHERITED = ProgramElement;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLPostfixExpression.h b/src/sksl/ir/SkSLPostfixExpression.h
index 6b61f75832..a9b7fbfce5 100644
--- a/src/sksl/ir/SkSLPostfixExpression.h
+++ b/src/sksl/ir/SkSLPostfixExpression.h
@@ -21,46 +21,47 @@ class PostfixExpression final : public Expression {
 public:
     static constexpr Kind kExpressionKind = Kind::kPostfix;
 
     PostfixExpression(std::unique_ptr<Expression> operand, Token::Kind op)
-        : INHERITED(operand->fOffset, kExpressionKind, &operand->type())
-        , fOperand(std::move(operand))
-        , fOperator(op) {}
+    : INHERITED(operand->fOffset, kExpressionKind, TypeTokenData{&operand->type(), op}) {
+        fExpressionChildren.push_back(std::move(operand));
+    }
+
+    const Type& type() const override {
+        return *this->typeTokenData().fType;
+    }
 
     Token::Kind getOperator() const {
-        return fOperator;
+        return this->typeTokenData().fToken;
     }
 
     std::unique_ptr<Expression>& operand() {
-        return fOperand;
+        return fExpressionChildren[0];
     }
 
     const std::unique_ptr<Expression>& operand() const {
-        return fOperand;
+        return fExpressionChildren[0];
     }
 
     bool hasProperty(Property property) const override {
         if (property == Property::kSideEffects) {
             return true;
         }
         return this->operand()->hasProperty(property);
     }
 
     std::unique_ptr<Expression> clone() const override {
         return std::unique_ptr<Expression>(new PostfixExpression(this->operand()->clone(),
                                                                  this->getOperator()));
     }
 
     String description() const override {
         return this->operand()->description() + Compiler::OperatorName(this->getOperator());
     }
 
 private:
-    std::unique_ptr<Expression> fOperand;
-    Token::Kind fOperator;
-
     using INHERITED = Expression;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLPrefixExpression.h b/src/sksl/ir/SkSLPrefixExpression.h
index 11d64eec25..2db1c9420d 100644
--- a/src/sksl/ir/SkSLPrefixExpression.h
+++ b/src/sksl/ir/SkSLPrefixExpression.h
@@ -23,80 +23,81 @@ class PrefixExpression final : public Expression {
 public:
     static constexpr Kind kExpressionKind = Kind::kPrefix;
 
     PrefixExpression(Token::Kind op, std::unique_ptr<Expression> operand)
-        : INHERITED(operand->fOffset, kExpressionKind, &operand->type())
-        , fOperator(op)
-        , fOperand(std::move(operand)) {}
+    : INHERITED(operand->fOffset, kExpressionKind, TypeTokenData{&operand->type(), op}) {
+        fExpressionChildren.push_back(std::move(operand));
+    }
+
+    const Type& type() const override {
+        return *this->typeTokenData().fType;
+    }
 
     Token::Kind getOperator() const {
-        return fOperator;
+        return this->typeTokenData().fToken;
     }
 
     std::unique_ptr<Expression>& operand() {
-        return fOperand;
+        return fExpressionChildren[0];
     }
 
     const std::unique_ptr<Expression>& operand() const {
-        return fOperand;
+        return fExpressionChildren[0];
     }
 
     bool isCompileTimeConstant() const override {
         return this->getOperator() == Token::Kind::TK_MINUS &&
                this->operand()->isCompileTimeConstant();
     }
 
     bool hasProperty(Property property) const override {
         if (property == Property::kSideEffects &&
             (this->getOperator() == Token::Kind::TK_PLUSPLUS ||
              this->getOperator() == Token::Kind::TK_MINUSMINUS)) {
             return true;
         }
         return this->operand()->hasProperty(property);
     }
 
     std::unique_ptr<Expression> constantPropagate(const IRGenerator& irGenerator,
                                                   const DefinitionMap& definitions) override {
         if (this->operand()->kind() == Expression::Kind::kFloatLiteral) {
             return std::unique_ptr<Expression>(new FloatLiteral(
                                                      irGenerator.fContext,
                                                      fOffset,
                                                      -this->operand()->as<FloatLiteral>().value()));
 
         }
         return nullptr;
     }
 
     SKSL_FLOAT getFVecComponent(int index) const override {
         SkASSERT(this->getOperator() == Token::Kind::TK_MINUS);
         return -this->operand()->getFVecComponent(index);
     }
 
     SKSL_INT getIVecComponent(int index) const override {
         SkASSERT(this->getOperator() == Token::Kind::TK_MINUS);
         return -this->operand()->getIVecComponent(index);
     }
 
     SKSL_FLOAT getMatComponent(int col, int row) const override {
         SkASSERT(this->getOperator() == Token::Kind::TK_MINUS);
         return -this->operand()->getMatComponent(col, row);
     }
 
     std::unique_ptr<Expression> clone() const override {
         return std::unique_ptr<Expression>(new PrefixExpression(this->getOperator(),
                                                                 this->operand()->clone()));
     }
 
     String description() const override {
         return Compiler::OperatorName(this->getOperator()) + this->operand()->description();
     }
 
 private:
-    Token::Kind fOperator;
-    std::unique_ptr<Expression> fOperand;
-
     using INHERITED = Expression;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLProgramElement.h b/src/sksl/ir/SkSLProgramElement.h
index e14415a729..27997a2950 100644
--- a/src/sksl/ir/SkSLProgramElement.h
+++ b/src/sksl/ir/SkSLProgramElement.h
@@ -21,48 +21,56 @@ class ProgramElement : public IRNode {
 public:
     enum class Kind {
         kEnum = 0,
         kExtension,
         kFunction,
         kInterfaceBlock,
         kModifiers,
         kSection,
         kGlobalVar,
 
         kFirst = kEnum,
         kLast = kGlobalVar
     };
 
     ProgramElement(int offset, Kind kind)
-        : INHERITED(offset, (int) kind) {
+    : INHERITED(offset, (int) kind) {
+        SkASSERT(kind >= Kind::kFirst && kind <= Kind::kLast);
+    }
+
+    ProgramElement(int offset, const ModifiersDeclarationData& data)
+    : INHERITED(offset, (int) Kind::kModifiers, data) {}
+
+    ProgramElement(int offset, Kind kind, const String& data)
+    : INHERITED(offset, (int) kind, data) {
         SkASSERT(kind >= Kind::kFirst && kind <= Kind::kLast);
     }
 
     Kind kind() const {
         return (Kind) fKind;
     }
 
     /**
      *  Use is<T> to check the type of a program element.
      *  e.g. replace `el.kind() == ProgramElement::Kind::kEnum` with `el.is<Enum>()`.
      */
     template <typename T>
     bool is() const {
         return this->kind() == T::kProgramElementKind;
     }
 
     /**
      *  Use as<T> to downcast program elements. e.g. replace `(Enum&) el` with `el.as<Enum>()`.
      */
     template <typename T>
     const T& as() const {
         SkASSERT(this->is<T>());
         return static_cast<const T&>(*this);
     }
 
     template <typename T>
     T& as() {
         SkASSERT(this->is<T>());
         return static_cast<T&>(*this);
     }
 
     virtual std::unique_ptr<ProgramElement> clone() const = 0;
diff --git a/src/sksl/ir/SkSLReturnStatement.h b/src/sksl/ir/SkSLReturnStatement.h
index d44f0490b4..9b40e513ca 100644
--- a/src/sksl/ir/SkSLReturnStatement.h
+++ b/src/sksl/ir/SkSLReturnStatement.h
@@ -20,42 +20,43 @@ class ReturnStatement final : public Statement {
 public:
     static constexpr Kind kStatementKind = Kind::kReturn;
 
     ReturnStatement(int offset)
-        : INHERITED(offset, kStatementKind) {}
+    : INHERITED(offset, kStatementKind) {
+        fExpressionChildren.push_back(nullptr);
+    }
 
     ReturnStatement(std::unique_ptr<Expression> expression)
-        : INHERITED(expression->fOffset, kStatementKind)
-        , fExpression(std::move(expression)) {}
+    : INHERITED(expression->fOffset, kStatementKind) {
+        fExpressionChildren.push_back(std::move(expression));
+    }
 
     std::unique_ptr<Expression>& expression() {
-        return fExpression;
+        return fExpressionChildren[0];
     }
 
     const std::unique_ptr<Expression>& expression() const {
-        return fExpression;
+        return fExpressionChildren[0];
     }
 
     std::unique_ptr<Statement> clone() const override {
         if (this->expression()) {
             return std::unique_ptr<Statement>(new ReturnStatement(this->expression()->clone()));
         }
         return std::unique_ptr<Statement>(new ReturnStatement(fOffset));
     }
 
     String description() const override {
         if (this->expression()) {
             return "return " + this->expression()->description() + ";";
         } else {
             return String("return;");
         }
     }
 
 private:
-    std::unique_ptr<Expression> fExpression;
-
     using INHERITED = Statement;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLSetting.h b/src/sksl/ir/SkSLSetting.h
index f4bcee5519..76f0af0a4f 100644
--- a/src/sksl/ir/SkSLSetting.h
+++ b/src/sksl/ir/SkSLSetting.h
@@ -21,39 +21,40 @@ class Setting final : public Expression {
 public:
     static constexpr Kind kExpressionKind = Kind::kSetting;
 
     Setting(int offset, String name, const Type* type)
-        : INHERITED(offset, kExpressionKind, type)
-        , fName(std::move(name)) {}
+    : INHERITED(offset, SettingData{std::move(name), type}) {}
 
     std::unique_ptr<Expression> constantPropagate(const IRGenerator& irGenerator,
                                                   const DefinitionMap& definitions) override;
 
     std::unique_ptr<Expression> clone() const override {
         return std::unique_ptr<Expression>(new Setting(fOffset, this->name(), &this->type()));
     }
 
     const String& name() const {
-        return fName;
+        return this->settingData().fName;
+    }
+
+    const Type& type() const override {
+        return *this->settingData().fType;
     }
 
     String description() const override {
         return this->name();
     }
 
     bool hasProperty(Property property) const override {
         return false;
     }
 
     bool isCompileTimeConstant() const override {
         return true;
     }
 
 private:
-    String fName;
-
     using INHERITED = Expression;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLStatement.h b/src/sksl/ir/SkSLStatement.h
index 6ffb4e52da..b4d26a1b90 100644
--- a/src/sksl/ir/SkSLStatement.h
+++ b/src/sksl/ir/SkSLStatement.h
@@ -20,61 +20,81 @@ class Statement : public IRNode {
 public:
     enum Kind {
         kBlock = (int) Symbol::Kind::kLast + 1,
         kBreak,
         kContinue,
         kDiscard,
         kDo,
         kExpression,
         kFor,
         kIf,
         kInlineMarker,
         kNop,
         kReturn,
         kSwitch,
         kSwitchCase,
         kVarDeclaration,
         kWhile,
 
         kFirst = kBlock,
         kLast = kWhile
     };
 
     Statement(int offset, Kind kind)
     : INHERITED(offset, (int) kind) {
         SkASSERT(kind >= Kind::kFirst && kind <= Kind::kLast);
     }
 
+    Statement(int offset, Kind kind, BlockData data, StatementArray stmts)
+    : INHERITED(offset, (int) kind, data, std::move(stmts)) {
+        SkASSERT(kind >= Kind::kFirst && kind <= Kind::kLast);
+    }
+
+    Statement(int offset, const ForStatementData& data)
+    : INHERITED(offset, (int) Kind::kFor, data) {}
+
+    Statement(int offset, const IfStatementData& data)
+    : INHERITED(offset, (int) Kind::kIf, data) {}
+
+    Statement(int offset, const InlineMarkerData& data)
+    : INHERITED(offset, (int) Kind::kInlineMarker, data) {}
+
+    Statement(int offset, const SwitchStatementData& data)
+    : INHERITED(offset, (int) Kind::kSwitch, data) {}
+
+    Statement(int offset, const VarDeclarationData& data)
+    : INHERITED(offset, (int) Kind::kVarDeclaration, data) {}
+
     Kind kind() const {
         return (Kind) fKind;
     }
 
     /**
      *  Use is<T> to check the type of a statement.
      *  e.g. replace `s.kind() == Statement::Kind::kReturn` with `s.is<ReturnStatement>()`.
      */
     template <typename T>
     bool is() const {
         return this->fKind == T::kStatementKind;
     }
 
     /**
      *  Use as<T> to downcast statements.
      *  e.g. replace `(ReturnStatement&) s` with `s.as<ReturnStatement>()`.
      */
     template <typename T>
     const T& as() const {
         SkASSERT(this->is<T>());
         return static_cast<const T&>(*this);
     }
 
     template <typename T>
     T& as() {
         SkASSERT(this->is<T>());
         return static_cast<T&>(*this);
     }
 
     virtual bool isEmpty() const {
         return false;
     }
 
     virtual std::unique_ptr<Statement> clone() const = 0;
diff --git a/src/sksl/ir/SkSLSwitchCase.h b/src/sksl/ir/SkSLSwitchCase.h
index 3d5ac7098f..841af529f0 100644
--- a/src/sksl/ir/SkSLSwitchCase.h
+++ b/src/sksl/ir/SkSLSwitchCase.h
@@ -20,59 +20,57 @@ class SwitchCase final : public Statement {
 public:
     static constexpr Kind kStatementKind = Kind::kSwitchCase;
 
     // null value implies "default" case
     SwitchCase(int offset, std::unique_ptr<Expression> value, StatementArray statements)
-        : INHERITED(offset, kStatementKind)
-        , fValue(std::move(value))
-        , fStatements(std::move(statements)) {}
+            : INHERITED(offset, kStatementKind) {
+        fExpressionChildren.push_back(std::move(value));
+        fStatementChildren = std::move(statements);
+    }
 
     std::unique_ptr<Expression>& value() {
-        return fValue;
+        return fExpressionChildren[0];
     }
 
     const std::unique_ptr<Expression>& value() const {
-        return fValue;
+        return fExpressionChildren[0];
     }
 
     StatementArray& statements() {
-        return fStatements;
+        return fStatementChildren;
     }
 
     const StatementArray& statements() const {
-        return fStatements;
+        return fStatementChildren;
     }
 
     std::unique_ptr<Statement> clone() const override {
         StatementArray cloned;
         cloned.reserve_back(this->statements().size());
         for (const auto& s : this->statements()) {
             cloned.push_back(s->clone());
         }
         return std::make_unique<SwitchCase>(fOffset,
                                             this->value() ? this->value()->clone() : nullptr,
                                             std::move(cloned));
     }
 
     String description() const override {
         String result;
         if (this->value()) {
             result.appendf("case %s:\n", this->value()->description().c_str());
         } else {
             result += "default:\n";
         }
         for (const auto& s : this->statements()) {
             result += s->description() + "\n";
         }
         return result;
     }
 
 private:
-    std::unique_ptr<Expression> fValue;
-    StatementArray fStatements;
-
     using INHERITED = Statement;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLSwitchStatement.h b/src/sksl/ir/SkSLSwitchStatement.h
index 916a8d59cf..0ca17ddeee 100644
--- a/src/sksl/ir/SkSLSwitchStatement.h
+++ b/src/sksl/ir/SkSLSwitchStatement.h
@@ -23,74 +23,75 @@ class SwitchStatement final : public Statement {
 public:
     static constexpr Kind kStatementKind = Kind::kSwitch;
 
+    using CaseArray = NodeArrayWrapper<SwitchCase, Statement>;
+
+    using ConstCaseArray = ConstNodeArrayWrapper<SwitchCase, Statement>;
+
     SwitchStatement(int offset, bool isStatic, std::unique_ptr<Expression> value,
                     std::vector<std::unique_ptr<SwitchCase>> cases,
                     const std::shared_ptr<SymbolTable> symbols)
-        : INHERITED(offset, kStatementKind)
-        , fIsStatic(isStatic)
-        , fValue(std::move(value))
-        , fCases(std::move(cases))
-        , fSymbols(std::move(symbols)) {}
+    : INHERITED(offset, SwitchStatementData{isStatic, std::move(symbols)}) {
+        fExpressionChildren.push_back(std::move(value));
+        fStatementChildren.reserve_back(cases.size());
+        for (std::unique_ptr<SwitchCase>& c : cases) {
+            fStatementChildren.push_back(std::move(c));
+        }
+    }
 
     std::unique_ptr<Expression>& value() {
-        return fValue;
+        return fExpressionChildren[0];
     }
 
     const std::unique_ptr<Expression>& value() const {
-        return fValue;
+        return fExpressionChildren[0];
     }
 
-    std::vector<std::unique_ptr<SwitchCase>>& cases() {
-        return fCases;
+    CaseArray cases() {
+        return CaseArray(&fStatementChildren);
     }
 
-    const std::vector<std::unique_ptr<SwitchCase>>& cases() const {
-        return fCases;
+    ConstCaseArray cases() const {
+        return ConstCaseArray(&fStatementChildren);
     }
 
     bool isStatic() const {
-        return fIsStatic;
+        return this->switchStatementData().fIsStatic;
     }
 
     const std::shared_ptr<SymbolTable>& symbols() const {
-        return fSymbols;
+        return this->switchStatementData().fSymbols;
     }
 
     std::unique_ptr<Statement> clone() const override {
         std::vector<std::unique_ptr<SwitchCase>> cloned;
-        for (const std::unique_ptr<SwitchCase>& sc : this->cases()) {
-            cloned.emplace_back(&sc->clone().release()->as<SwitchCase>());
+        for (const std::unique_ptr<Statement>& s : fStatementChildren) {
+            cloned.emplace_back((SwitchCase*) s->as<SwitchCase>().clone().release());
         }
         return std::unique_ptr<Statement>(new SwitchStatement(
                                                       fOffset,
                                                       this->isStatic(),
                                                       this->value()->clone(),
                                                       std::move(cloned),
                                                       SymbolTable::WrapIfBuiltin(this->symbols())));
     }
 
     String description() const override {
         String result;
         if (this->isStatic()) {
             result += "@";
         }
         result += String::printf("switch (%s) {\n", this->value()->description().c_str());
         for (const auto& c : this->cases()) {
-            result += c->description();
+            result += c.description();
         }
         result += "}";
         return result;
     }
 
 private:
-    bool fIsStatic;
-    std::unique_ptr<Expression> fValue;
-    std::vector<std::unique_ptr<SwitchCase>> fCases;
-    std::shared_ptr<SymbolTable> fSymbols;
-
     using INHERITED = Statement;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLSwizzle.h b/src/sksl/ir/SkSLSwizzle.h
index 30ac5a5592..aea1e7a0cc 100644
--- a/src/sksl/ir/SkSLSwizzle.h
+++ b/src/sksl/ir/SkSLSwizzle.h
@@ -19,83 +19,89 @@ namespace SkSL {
 /**
  * Represents a vector swizzle operation such as 'float2(1, 2, 3).zyx'.
  */
 struct Swizzle final : public Expression {
     static constexpr Kind kExpressionKind = Kind::kSwizzle;
 
     Swizzle(const Context& context, std::unique_ptr<Expression> base, std::vector<int> components)
-            : INHERITED(base->fOffset, kExpressionKind,
-                        &base->type().componentType().toCompound(context, components.size(), 1))
-            , fBase(std::move(base))
-            , fComponents(std::move(components)) {
+            : INHERITED(base->fOffset, swizzle_data(context, *base, std::move(components))) {
         SkASSERT(this->components().size() >= 1 && this->components().size() <= 4);
+        fExpressionChildren.push_back(std::move(base));
+    }
+
+    const Type& type() const override {
+        return *this->swizzleData().fType;
     }
 
     std::unique_ptr<Expression>& base() {
-        return fBase;
+        return fExpressionChildren[0];
     }
 
     const std::unique_ptr<Expression>& base() const {
-        return fBase;
+        return fExpressionChildren[0];
     }
 
     const std::vector<int>& components() const {
-        return fComponents;
+        return this->swizzleData().fComponents;
     }
 
     std::unique_ptr<Expression> constantPropagate(const IRGenerator& irGenerator,
                                                   const DefinitionMap& definitions) override {
         if (this->base()->kind() == Expression::Kind::kConstructor) {
             Constructor& constructor = static_cast<Constructor&>(*this->base());
             if (constructor.isCompileTimeConstant()) {
                 // we're swizzling a constant vector, e.g. float4(1).x. Simplify it.
                 const Type& type = this->type();
                 if (type.isInteger()) {
                     SkASSERT(this->components().size() == 1);
                     int64_t value = constructor.getIVecComponent(this->components()[0]);
                     return std::make_unique<IntLiteral>(irGenerator.fContext, constructor.fOffset,
                                                         value);
                 } else if (type.isFloat()) {
                     SkASSERT(this->components().size() == 1);
                     SKSL_FLOAT value = constructor.getFVecComponent(this->components()[0]);
                     return std::make_unique<FloatLiteral>(irGenerator.fContext, constructor.fOffset,
                                                           value);
                 }
             }
         }
         return nullptr;
     }
 
     bool hasProperty(Property property) const override {
         return this->base()->hasProperty(property);
     }
 
     std::unique_ptr<Expression> clone() const override {
         return std::unique_ptr<Expression>(new Swizzle(&this->type(), this->base()->clone(),
                                                        this->components()));
     }
 
     String description() const override {
         String result = this->base()->description() + ".";
         for (int x : this->components()) {
             result += "xyzw"[x];
         }
         return result;
     }
 
 private:
     Swizzle(const Type* type, std::unique_ptr<Expression> base, std::vector<int> components)
-        : INHERITED(base->fOffset, kExpressionKind, type)
-        , fBase(std::move(base))
-        , fComponents(std::move(components)) {
+    : INHERITED(base->fOffset, SwizzleData{type, std::move(components)}) {
         SkASSERT(this->components().size() >= 1 && this->components().size() <= 4);
+        fExpressionChildren.push_back(std::move(base));
     }
 
-    std::unique_ptr<Expression> fBase;
-    std::vector<int> fComponents;
+    static SwizzleData swizzle_data(const Context& context, Expression& base,
+                                    std::vector<int> components) {
+        SwizzleData result;
+        result.fType = &base.type().componentType().toCompound(context, components.size(), 1);
+        result.fComponents = std::move(components);
+        return result;
+    }
 
     using INHERITED = Expression;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLSymbol.h b/src/sksl/ir/SkSLSymbol.h
index ebf885a3b4..8ca599bbe1 100644
--- a/src/sksl/ir/SkSLSymbol.h
+++ b/src/sksl/ir/SkSLSymbol.h
@@ -20,74 +20,72 @@ class Symbol : public IRNode {
 public:
     enum class Kind {
         kExternal = (int) ProgramElement::Kind::kLast + 1,
         kField,
         kFunctionDeclaration,
         kSymbolAlias,
         kType,
         kUnresolvedFunction,
         kVariable,
 
         kFirst = kExternal,
         kLast = kVariable
     };
 
     Symbol(int offset, Kind kind, StringFragment name, const Type* type = nullptr)
-        : INHERITED(offset, (int) kind)
-        , fName(name)
-        , fType(type) {
+    : INHERITED(offset, (int) kind, SymbolData{name, type}) {
         SkASSERT(kind >= Kind::kFirst && kind <= Kind::kLast);
     }
 
+    Symbol(int offset, const SymbolAliasData& data)
+    : INHERITED(offset, (int) Kind::kSymbolAlias, data) {}
+
+    Symbol(int offset, const UnresolvedFunctionData& data)
+    : INHERITED(offset, (int) Kind::kUnresolvedFunction, data) {}
+
     Symbol& operator=(const Symbol&) = default;
 
     ~Symbol() override {}
 
-    const Type& type() const {
-        SkASSERT(fType);
-        return *fType;
+    virtual const Type& type() const {
+        return *this->symbolData().fType;
     }
 
     Kind kind() const {
         return (Kind) fKind;
     }
 
-    StringFragment name() const {
-        return fName;
+    virtual StringFragment name() const {
+        return this->symbolData().fName;
     }
 
     /**
      *  Use is<T> to check the type of a symbol.
      *  e.g. replace `sym.kind() == Symbol::Kind::kVariable` with `sym.is<Variable>()`.
      */
     template <typename T>
     bool is() const {
         return this->kind() == T::kSymbolKind;
     }
 
     /**
      *  Use as<T> to downcast symbols. e.g. replace `(Variable&) sym` with `sym.as<Variable>()`.
      */
     template <typename T>
     const T& as() const {
         SkASSERT(this->is<T>());
         return static_cast<const T&>(*this);
     }
 
     template <typename T>
     T& as() {
         SkASSERT(this->is<T>());
         return static_cast<T&>(*this);
     }
 
 private:
-    StringFragment fName;
-    const Type* fType;
-
     using INHERITED = IRNode;
-
-    friend class Type;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLSymbolAlias.h b/src/sksl/ir/SkSLSymbolAlias.h
index 310856af88..6651d39e08 100644
--- a/src/sksl/ir/SkSLSymbolAlias.h
+++ b/src/sksl/ir/SkSLSymbolAlias.h
@@ -19,24 +19,25 @@ class SymbolAlias final : public Symbol {
 public:
     static constexpr Kind kSymbolKind = Kind::kSymbolAlias;
 
     SymbolAlias(int offset, StringFragment name, const Symbol* origSymbol)
-        : INHERITED(offset, kSymbolKind, name)
-        , fOrigSymbol(origSymbol) {}
+    : INHERITED(offset, SymbolAliasData{name, origSymbol}) {}
+
+    StringFragment name() const override {
+        return this->symbolAliasData().fName;
+    }
 
     const Symbol* origSymbol() const {
-        return fOrigSymbol;
+        return this->symbolAliasData().fOrigSymbol;
     }
 
     String description() const override {
         return this->name();
     }
 
 private:
-    const Symbol* fOrigSymbol;
-
     using INHERITED = Symbol;
 };
 
 } // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLTernaryExpression.h b/src/sksl/ir/SkSLTernaryExpression.h
index 25006cf45a..ab73c4fe21 100644
--- a/src/sksl/ir/SkSLTernaryExpression.h
+++ b/src/sksl/ir/SkSLTernaryExpression.h
@@ -20,68 +20,65 @@ class TernaryExpression final : public Expression {
 public:
     static constexpr Kind kExpressionKind = Kind::kTernary;
 
     TernaryExpression(int offset, std::unique_ptr<Expression> test,
                       std::unique_ptr<Expression> ifTrue, std::unique_ptr<Expression> ifFalse)
-        : INHERITED(offset, kExpressionKind, &ifTrue->type())
-        , fTest(std::move(test))
-        , fIfTrue(std::move(ifTrue))
-        , fIfFalse(std::move(ifFalse)) {
-        SkASSERT(this->ifTrue()->type() == this->ifFalse()->type());
+    : INHERITED(offset, kExpressionKind, &ifTrue->type()) {
+        SkASSERT(ifTrue->type() == ifFalse->type());
+        fExpressionChildren.reserve_back(3);
+        fExpressionChildren.push_back(std::move(test));
+        fExpressionChildren.push_back(std::move(ifTrue));
+        fExpressionChildren.push_back(std::move(ifFalse));
     }
 
     std::unique_ptr<Expression>& test() {
-        return fTest;
+        return fExpressionChildren[0];
     }
 
     const std::unique_ptr<Expression>& test() const {
-        return fTest;
+        return fExpressionChildren[0];
     }
 
     std::unique_ptr<Expression>& ifTrue() {
-        return fIfTrue;
+        return fExpressionChildren[1];
     }
 
     const std::unique_ptr<Expression>& ifTrue() const {
-        return fIfTrue;
+        return fExpressionChildren[1];
     }
 
     std::unique_ptr<Expression>& ifFalse() {
-        return fIfFalse;
+        return fExpressionChildren[2];
     }
 
     const std::unique_ptr<Expression>& ifFalse() const {
-        return fIfFalse;
+        return fExpressionChildren[2];
     }
 
     bool hasProperty(Property property) const override {
         return this->test()->hasProperty(property) || this->ifTrue()->hasProperty(property) ||
                this->ifFalse()->hasProperty(property);
     }
 
     bool isConstantOrUniform() const override {
         return this->test()->isConstantOrUniform() && this->ifTrue()->isConstantOrUniform() &&
                this->ifFalse()->isConstantOrUniform();
     }
 
     std::unique_ptr<Expression> clone() const override {
         return std::unique_ptr<Expression>(new TernaryExpression(fOffset, this->test()->clone(),
                                                                  this->ifTrue()->clone(),
                                                                  this->ifFalse()->clone()));
     }
 
     String description() const override {
         return "(" + this->test()->description() + " ? " + this->ifTrue()->description() + " : " +
                this->ifFalse()->description() + ")";
     }
 
 private:
-    std::unique_ptr<Expression> fTest;
-    std::unique_ptr<Expression> fIfTrue;
-    std::unique_ptr<Expression> fIfFalse;
-
     using INHERITED = Expression;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLType.h b/src/sksl/ir/SkSLType.h
index 59b7ef0841..0ba682f407 100644
--- a/src/sksl/ir/SkSLType.h
+++ b/src/sksl/ir/SkSLType.h
@@ -57,359 +57,359 @@ class Type final : public Symbol {
 public:
     static constexpr Kind kSymbolKind = Kind::kType;
 
     struct Field {
         Field(Modifiers modifiers, StringFragment name, const Type* type)
         : fModifiers(modifiers)
         , fName(name)
         , fType(std::move(type)) {}
 
         String description() const {
             return fType->displayName() + " " + fName + ";";
         }
 
         Modifiers fModifiers;
         StringFragment fName;
         const Type* fType;
     };
 
     enum class TypeKind {
         kArray,
         kEnum,
         kGeneric,
         kNullable,
         kMatrix,
         kOther,
         kSampler,
         kSeparateSampler,
         kScalar,
         kStruct,
         kTexture,
         kVector
     };
 
     enum class NumberKind {
         kFloat,
         kSigned,
         kUnsigned,
         kNonnumeric
     };
 
     Type(const Type& other) = delete;
 
     // Create an "other" (special) type with the given name. These types cannot be directly
     // referenced from user code.
     Type(const char* name)
     : INHERITED(-1, kSymbolKind, name)
     , fTypeKind(TypeKind::kOther)
     , fNumberKind(NumberKind::kNonnumeric) {}
 
     // Create an "other" (special) type that supports field access.
     Type(const char* name, std::vector<Field> fields)
     : INHERITED(-1, kSymbolKind, name)
     , fTypeKind(TypeKind::kOther)
     , fNumberKind(NumberKind::kNonnumeric)
     , fFields(std::move(fields)) {}
 
     // Create a simple type.
     Type(String name, TypeKind kind)
     : INHERITED(-1, kSymbolKind, "")
     , fNameString(std::move(name))
     , fTypeKind(kind)
     , fNumberKind(NumberKind::kNonnumeric) {
-        fName = StringFragment(fNameString.c_str(), fNameString.length());
+        this->symbolData().fName = StringFragment(fNameString.c_str(), fNameString.length());
     }
 
     // Create a generic type which maps to the listed types.
     Type(const char* name, std::vector<const Type*> types)
     : INHERITED(-1, kSymbolKind, name)
     , fTypeKind(TypeKind::kGeneric)
     , fNumberKind(NumberKind::kNonnumeric)
     , fCoercibleTypes(std::move(types)) {}
 
     // Create a struct type with the given fields.
     Type(int offset, String name, std::vector<Field> fields)
     : INHERITED(offset, kSymbolKind, "")
     , fNameString(std::move(name))
     , fTypeKind(TypeKind::kStruct)
     , fNumberKind(NumberKind::kNonnumeric)
     , fFields(std::move(fields)) {
-        fName = StringFragment(fNameString.c_str(), fNameString.length());
+        this->symbolData().fName = StringFragment(fNameString.c_str(), fNameString.length());
     }
 
     // Create a scalar type.
     Type(const char* name, NumberKind numberKind, int priority, bool highPrecision = false)
     : INHERITED(-1, kSymbolKind, name)
     , fTypeKind(TypeKind::kScalar)
     , fNumberKind(numberKind)
     , fPriority(priority)
     , fColumns(1)
     , fRows(1)
     , fHighPrecision(highPrecision) {}
 
     // Create a scalar type which can be coerced to the listed types.
     Type(const char* name,
          NumberKind numberKind,
          int priority,
          std::vector<const Type*> coercibleTypes)
     : INHERITED(-1, kSymbolKind, name)
     , fTypeKind(TypeKind::kScalar)
     , fNumberKind(numberKind)
     , fPriority(priority)
     , fCoercibleTypes(std::move(coercibleTypes))
     , fColumns(1)
     , fRows(1) {}
 
     // Create a nullable type.
     Type(String name, TypeKind kind, const Type& componentType)
     : INHERITED(-1, kSymbolKind, "")
     , fNameString(std::move(name))
     , fTypeKind(kind)
     , fNumberKind(NumberKind::kNonnumeric)
     , fComponentType(&componentType)
     , fColumns(1)
     , fRows(1)
     , fDimensions(SpvDim1D) {
-        fName = StringFragment(fNameString.c_str(), fNameString.length());
+        this->symbolData().fName = StringFragment(fNameString.c_str(), fNameString.length());
     }
 
     // Create a vector type.
     Type(const char* name, const Type& componentType, int columns)
     : Type(name, TypeKind::kVector, componentType, columns) {}
 
     static constexpr int kUnsizedArray = -1;
 
     // Create a vector or array type.
     Type(String name, TypeKind kind, const Type& componentType, int columns)
     : INHERITED(-1, kSymbolKind, "")
     , fNameString(std::move(name))
     , fTypeKind(kind)
     , fNumberKind(NumberKind::kNonnumeric)
     , fComponentType(&componentType)
     , fColumns(columns)
     , fRows(1)
     , fDimensions(SpvDim1D) {
         SkASSERT(fColumns > 0 || (fTypeKind == TypeKind::kArray && fColumns == kUnsizedArray));
-        fName = StringFragment(fNameString.c_str(), fNameString.length());
+        this->symbolData().fName = StringFragment(fNameString.c_str(), fNameString.length());
     }
 
     // Create a matrix type.
     Type(const char* name, const Type& componentType, int columns, int rows)
     : INHERITED(-1, kSymbolKind, name)
     , fTypeKind(TypeKind::kMatrix)
     , fNumberKind(NumberKind::kNonnumeric)
     , fComponentType(&componentType)
     , fColumns(columns)
     , fRows(rows)
     , fDimensions(SpvDim1D) {}
 
     // Create a texture type.
     Type(const char* name, SpvDim_ dimensions, bool isDepth, bool isArrayed, bool isMultisampled,
          bool isSampled)
     : INHERITED(-1, kSymbolKind, name)
     , fTypeKind(TypeKind::kTexture)
     , fNumberKind(NumberKind::kNonnumeric)
     , fDimensions(dimensions)
     , fIsDepth(isDepth)
     , fIsArrayed(isArrayed)
     , fIsMultisampled(isMultisampled)
     , fIsSampled(isSampled) {}
 
     // Create a sampler type.
     Type(const char* name, const Type& textureType)
     : INHERITED(-1, kSymbolKind, name)
     , fTypeKind(TypeKind::kSampler)
     , fNumberKind(NumberKind::kNonnumeric)
     , fDimensions(textureType.dimensions())
     , fIsDepth(textureType.isDepth())
     , fIsArrayed(textureType.isArrayed())
     , fIsMultisampled(textureType.isMultisampled())
     , fIsSampled(textureType.isSampled())
     , fTextureType(&textureType) {}
 
     String displayName() const {
         StringFragment name = this->name();
         if (name == "$floatLiteral") {
             return "float";
         }
         if (name == "$intLiteral") {
             return "int";
         }
         return name;
     }
 
     String description() const override {
         return this->displayName();
     }
 
     bool operator==(const Type& other) const {
         return this->name() == other.name();
     }
 
     bool operator!=(const Type& other) const {
         return this->name() != other.name();
     }
 
     /**
      * Returns the category (scalar, vector, matrix, etc.) of this type.
      */
     TypeKind typeKind() const {
         return fTypeKind;
     }
 
     /**
      * Returns true if this is a numeric scalar type.
      */
     bool isNumber() const {
         return fNumberKind != NumberKind::kNonnumeric;
     }
 
     /**
      * Returns true if this is a floating-point scalar type (float or half).
      */
     bool isFloat() const {
         return fNumberKind == NumberKind::kFloat;
     }
 
     /**
      * Returns true if this is a signed scalar type (int or short).
      */
     bool isSigned() const {
         return fNumberKind == NumberKind::kSigned;
     }
 
     /**
      * Returns true if this is an unsigned scalar type (uint or ushort).
      */
     bool isUnsigned() const {
         return fNumberKind == NumberKind::kUnsigned;
     }
 
     /**
      * Returns true if this is a signed or unsigned integer.
      */
     bool isInteger() const {
         return isSigned() || isUnsigned();
     }
 
     /**
      * Returns the "priority" of a number type, in order of float > half > int > short.
      * When operating on two number types, the result is the higher-priority type.
      */
     int priority() const {
         return fPriority;
     }
 
     /**
      * Returns true if an instance of this type can be freely coerced (implicitly converted) to
      * another type.
      */
     bool canCoerceTo(const Type& other, bool allowNarrowing) const {
         return this->coercionCost(other).isPossible(allowNarrowing);
     }
 
     /**
      * Determines the "cost" of coercing (implicitly converting) this type to another type. The cost
      * is a number with no particular meaning other than that lower costs are preferable to higher
      * costs. Returns INT_MAX if the coercion is not possible.
      */
     CoercionCost coercionCost(const Type& other) const;
 
     /**
      * For matrices and vectors, returns the type of individual cells (e.g. mat2 has a component
      * type of kFloat_Type). For all other types, causes an SkASSERTion failure.
      */
     const Type& componentType() const {
         SkASSERT(fComponentType);
         return *fComponentType;
     }
 
     /**
      * For texturesamplers, returns the type of texture it samples (e.g., sampler2D has
      * a texture type of texture2D).
      */
     const Type& textureType() const {
         SkASSERT(fTextureType);
         return *fTextureType;
     }
 
     /**
      * For nullable types, returns the base type, otherwise returns the type itself.
      */
     const Type& nonnullable() const {
         if (fTypeKind == TypeKind::kNullable) {
             return this->componentType();
         }
         return *this;
     }
 
     /**
      * For matrices and vectors, returns the number of columns (e.g. both mat3 and float3return 3).
      * For scalars, returns 1. For arrays, returns either the size of the array (if known) or -1.
      * For all other types, causes an SkASSERTion failure.
      */
     int columns() const {
         SkASSERT(fTypeKind == TypeKind::kScalar || fTypeKind == TypeKind::kVector ||
                  fTypeKind == TypeKind::kMatrix || fTypeKind == TypeKind::kArray);
         return fColumns;
     }
 
     /**
      * For matrices, returns the number of rows (e.g. mat2x4 returns 4). For vectors and scalars,
      * returns 1. For all other types, causes an SkASSERTion failure.
      */
     int rows() const {
         SkASSERT(fRows > 0);
         return fRows;
     }
 
     const std::vector<Field>& fields() const {
         SkASSERT(fTypeKind == TypeKind::kStruct || fTypeKind == TypeKind::kOther);
         return fFields;
     }
 
     /**
      * For generic types, returns the types that this generic type can substitute for. For other
      * types, returns a list of other types that this type can be coerced into.
      */
     const std::vector<const Type*>& coercibleTypes() const {
         SkASSERT(fCoercibleTypes.size() > 0);
         return fCoercibleTypes;
     }
 
     SpvDim_ dimensions() const {
         SkASSERT(TypeKind::kSampler == fTypeKind || TypeKind::kTexture == fTypeKind);
         return fDimensions;
     }
 
     bool isDepth() const {
         SkASSERT(TypeKind::kSampler == fTypeKind || TypeKind::kTexture == fTypeKind);
         return fIsDepth;
     }
 
     bool isArrayed() const {
         SkASSERT(TypeKind::kSampler == fTypeKind || TypeKind::kTexture == fTypeKind);
         return fIsArrayed;
     }
 
     bool isMultisampled() const {
         SkASSERT(TypeKind::kSampler == fTypeKind || TypeKind::kTexture == fTypeKind);
         return fIsMultisampled;
     }
 
     bool isSampled() const {
         SkASSERT(TypeKind::kSampler == fTypeKind || TypeKind::kTexture == fTypeKind);
         return fIsSampled;
     }
 
     bool highPrecision() const {
         if (fComponentType) {
             return fComponentType->highPrecision();
         }
         return fHighPrecision;
     }
 
     /**
      * Returns the corresponding vector or matrix type with the specified number of columns and
      * rows.
      */
     const Type& toCompound(const Context& context, int columns, int rows) const;
diff --git a/src/sksl/ir/SkSLTypeReference.h b/src/sksl/ir/SkSLTypeReference.h
index 9fc5baef23..5d37621f28 100644
--- a/src/sksl/ir/SkSLTypeReference.h
+++ b/src/sksl/ir/SkSLTypeReference.h
@@ -21,37 +21,37 @@ class TypeReference final : public Expression {
 public:
     static constexpr Kind kExpressionKind = Kind::kTypeReference;
 
     TypeReference(const Context& context, int offset, const Type* value)
-        : INHERITED(offset, kExpressionKind, context.fInvalid_Type.get())
-        , fValue(*value) {}
+    : INHERITED(offset, TypeReferenceData{context.fInvalid_Type.get(), value}) {}
+
+    const Type& type() const override {
+        return *this->typeReferenceData().fType;
+    }
 
     const Type& value() const {
-        return fValue;
+        return *this->typeReferenceData().fValue;
     }
 
     bool hasProperty(Property property) const override {
         return false;
     }
 
     String description() const override {
         return String(this->value().name());
     }
 
     std::unique_ptr<Expression> clone() const override {
         return std::unique_ptr<Expression>(new TypeReference(fOffset, &this->value(),
                                                              &this->type()));
     }
 
 private:
     TypeReference(int offset, const Type* value, const Type* type)
-        : INHERITED(offset, kExpressionKind, type)
-        , fValue(*value) {}
-
-    const Type& fValue;
+    : INHERITED(offset, TypeReferenceData{type, value}) {}
 
     using INHERITED = Expression;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLUnresolvedFunction.h b/src/sksl/ir/SkSLUnresolvedFunction.h
index f1aad74203..a4d44d763c 100644
--- a/src/sksl/ir/SkSLUnresolvedFunction.h
+++ b/src/sksl/ir/SkSLUnresolvedFunction.h
@@ -19,31 +19,32 @@ class UnresolvedFunction final : public Symbol {
 public:
     static constexpr Kind kSymbolKind = Kind::kUnresolvedFunction;
 
     UnresolvedFunction(std::vector<const FunctionDeclaration*> funcs)
-    : INHERITED(-1, kSymbolKind, funcs[0]->name())
-    , fFunctions(std::move(funcs)) {
+    : INHERITED(-1, UnresolvedFunctionData{std::move(funcs)}) {
 #ifdef SK_DEBUG
         SkASSERT(!this->functions().empty());
         for (auto func : this->functions()) {
             SkASSERT(func->name() == name());
         }
 #endif
     }
 
+    StringFragment name() const override {
+        return this->functions()[0]->name();
+    }
+
     const std::vector<const FunctionDeclaration*>& functions() const {
-        return fFunctions;
+        return this->unresolvedFunctionData().fFunctions;
     }
 
     String description() const override {
         return this->name();
     }
 
 private:
-    std::vector<const FunctionDeclaration*> fFunctions;
-
     using INHERITED = Symbol;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLVarDeclarations.h b/src/sksl/ir/SkSLVarDeclarations.h
index c82dd5fdef..0ba7dc2953 100644
--- a/src/sksl/ir/SkSLVarDeclarations.h
+++ b/src/sksl/ir/SkSLVarDeclarations.h
@@ -24,83 +24,82 @@ class VarDeclaration final : public Statement {
 public:
     static constexpr Kind kStatementKind = Kind::kVarDeclaration;
 
     VarDeclaration(const Variable* var,
                    const Type* baseType,
                    ExpressionArray sizes,
                    std::unique_ptr<Expression> value)
-            : INHERITED(var->fOffset, kStatementKind)
-            , fVar(var)
-            , fBaseType(*baseType)
-            , fSizes(std::move(sizes))
-            , fValue(std::move(value)) {}
+            : INHERITED(var->fOffset, VarDeclarationData{baseType, var}) {
+        fExpressionChildren.reserve_back(sizes.size() + 1);
+        fExpressionChildren.move_back_n(sizes.size(), sizes.data());
+        fExpressionChildren.push_back(std::move(value));
+    }
 
     const Type& baseType() const {
-        return fBaseType;
+        return *this->varDeclarationData().fBaseType;
     }
 
     const Variable& var() const {
-        return *fVar;
+        return *this->varDeclarationData().fVar;
     }
 
     void setVar(const Variable* var) {
-        fVar = var;
+        this->varDeclarationData().fVar = var;
+    }
+
+    int sizeCount() const {
+        return fExpressionChildren.size() - 1;
     }
 
-    const ExpressionArray& sizes() const {
-        return fSizes;
+    const std::unique_ptr<Expression>& size(int index) const {
+        SkASSERT(index >= 0 && index < this->sizeCount());
+        return fExpressionChildren[index];
     }
 
     std::unique_ptr<Expression>& value() {
-        return fValue;
+        return fExpressionChildren.back();
     }
 
     const std::unique_ptr<Expression>& value() const {
-        return fValue;
+        return fExpressionChildren.back();
     }
 
     std::unique_ptr<Statement> clone() const override {
         ExpressionArray sizesClone;
-        sizesClone.reserve_back(this->sizes().count());
-        for (const std::unique_ptr<Expression>& size : this->sizes()) {
-            if (size) {
-                sizesClone.push_back(size->clone());
+        sizesClone.reserve_back(this->sizeCount());
+        for (int i = 0; i < this->sizeCount(); ++i) {
+            if (this->size(i)) {
+                sizesClone.push_back(this->size(i)->clone());
             } else {
                 sizesClone.push_back(nullptr);
             }
         }
         return std::make_unique<VarDeclaration>(&this->var(),
                                                 &this->baseType(),
                                                 std::move(sizesClone),
                                                 this->value() ? this->value()->clone() : nullptr);
     }
 
     String description() const override {
         String result = this->var().modifiers().description() + this->baseType().description() +
                         " " + this->var().name();
-        for (const std::unique_ptr<Expression>& size : this->sizes()) {
-            if (size) {
-                result += "[" + size->description() + "]";
+        for (int i = 0; i < this->sizeCount(); ++i) {
+            if (this->size(i)) {
+                result += "[" + this->size(i)->description() + "]";
             } else {
                 result += "[]";
             }
         }
         if (this->value()) {
             result += " = " + this->value()->description();
         }
         result += ";";
         return result;
     }
 
-private:
-    const Variable* fVar;
-    const Type& fBaseType;
-    ExpressionArray fSizes;
-    std::unique_ptr<Expression> fValue;
-
     using INHERITED = Statement;
 };
 
 /**
  * A variable declaration appearing at global scope. A global declaration like 'int x, y;' produces
  * two GlobalVarDeclaration elements, each containing the declaration of one variable.
  */
@@ -108,34 +107,32 @@ class GlobalVarDeclaration final : public ProgramElement {
 public:
     static constexpr Kind kProgramElementKind = Kind::kGlobalVar;
 
     GlobalVarDeclaration(int offset, std::unique_ptr<Statement> decl)
-            : INHERITED(offset, kProgramElementKind)
-            , fDeclaration(std::move(decl)) {
-        SkASSERT(this->declaration()->is<VarDeclaration>());
+            : INHERITED(offset, kProgramElementKind) {
+        SkASSERT(decl->is<VarDeclaration>());
+        fStatementChildren.push_back(std::move(decl));
     }
 
     std::unique_ptr<Statement>& declaration() {
-        return fDeclaration;
+        return fStatementChildren[0];
     }
 
     const std::unique_ptr<Statement>& declaration() const {
-        return fDeclaration;
+        return fStatementChildren[0];
     }
 
     std::unique_ptr<ProgramElement> clone() const override {
         return std::make_unique<GlobalVarDeclaration>(fOffset, this->declaration()->clone());
     }
 
     String description() const override {
         return this->declaration()->description();
     }
 
 private:
-    std::unique_ptr<Statement> fDeclaration;
-
     using INHERITED = ProgramElement;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLVariableReference.cpp b/src/sksl/ir/SkSLVariableReference.cpp
index 8e7686aabc..b9610f0a9c 100644
--- a/src/sksl/ir/SkSLVariableReference.cpp
+++ b/src/sksl/ir/SkSLVariableReference.cpp
@@ -15,12 +15,14 @@
 namespace SkSL {
 
 VariableReference::VariableReference(int offset, const Variable* variable, RefKind refKind)
-    : INHERITED(offset, kExpressionKind, &variable->type())
-    , fVariable(variable)
-    , fRefKind(refKind) {
+        : INHERITED(offset, VariableReferenceData{variable, refKind}) {
     SkASSERT(this->variable());
 }
 
+const Type& VariableReference::type() const {
+    return this->variableReferenceData().fVariable->type();
+}
+
 bool VariableReference::hasProperty(Property property) const {
     switch (property) {
         case Property::kSideEffects:      return false;
@@ -40,11 +42,11 @@ String VariableReference::description() const {
 }
 
 void VariableReference::setRefKind(RefKind refKind) {
-    fRefKind = refKind;
+    this->variableReferenceData().fRefKind = refKind;
 }
 
 void VariableReference::setVariable(const Variable* variable) {
-    fVariable = variable;
+    this->variableReferenceData().fVariable = variable;
 }
 
 std::unique_ptr<Expression> VariableReference::constantPropagate(const IRGenerator& irGenerator,
diff --git a/src/sksl/ir/SkSLVariableReference.h b/src/sksl/ir/SkSLVariableReference.h
index 87a180b2f9..48b13a4d02 100644
--- a/src/sksl/ir/SkSLVariableReference.h
+++ b/src/sksl/ir/SkSLVariableReference.h
@@ -35,45 +35,44 @@ class VariableReference final : public Expression {
 public:
     using RefKind = VariableRefKind;
 
     static constexpr Kind kExpressionKind = Kind::kVariableReference;
 
     VariableReference(int offset, const Variable* variable, RefKind refKind = RefKind::kRead);
 
     VariableReference(const VariableReference&) = delete;
     VariableReference& operator=(const VariableReference&) = delete;
 
+    const Type& type() const override;
+
     const Variable* variable() const {
-        return fVariable;
+        return this->variableReferenceData().fVariable;
     }
 
     RefKind refKind() const {
-        return fRefKind;
+        return (RefKind) this->variableReferenceData().fRefKind;
     }
 
     void setRefKind(RefKind refKind);
     void setVariable(const Variable* variable);
 
     bool hasProperty(Property property) const override;
 
     bool isConstantOrUniform() const override;
 
     std::unique_ptr<Expression> clone() const override {
         return std::unique_ptr<Expression>(new VariableReference(fOffset, this->variable(),
                                                                  this->refKind()));
     }
 
     String description() const override;
 
     std::unique_ptr<Expression> constantPropagate(const IRGenerator& irGenerator,
                                                   const DefinitionMap& definitions) override;
 
 private:
-    const Variable* fVariable;
-    VariableRefKind fRefKind;
-
     using INHERITED = Expression;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLWhileStatement.h b/src/sksl/ir/SkSLWhileStatement.h
index 7fd1bf40bf..59146db608 100644
--- a/src/sksl/ir/SkSLWhileStatement.h
+++ b/src/sksl/ir/SkSLWhileStatement.h
@@ -16,47 +16,44 @@ namespace SkSL {
 /**
  * A 'while' loop.
  */
 struct WhileStatement final : public Statement {
     static constexpr Kind kStatementKind = Kind::kWhile;
 
     WhileStatement(int offset, std::unique_ptr<Expression> test,
                    std::unique_ptr<Statement> statement)
-        : INHERITED(offset, kStatementKind)
-        , fTest(std::move(test))
-        , fStatement(std::move(statement)) {}
+    : INHERITED(offset, kStatementKind) {
+        fExpressionChildren.push_back(std::move(test));
+        fStatementChildren.push_back(std::move(statement));
+    }
 
     std::unique_ptr<Expression>& test() {
-        return fTest;
+        return fExpressionChildren[0];
     }
 
     const std::unique_ptr<Expression>& test() const {
-        return fTest;
+        return fExpressionChildren[0];
     }
 
     std::unique_ptr<Statement>& statement() {
-        return fStatement;
+        return fStatementChildren[0];
     }
 
     const std::unique_ptr<Statement>& statement() const {
-        return fStatement;
+        return fStatementChildren[0];
     }
 
     std::unique_ptr<Statement> clone() const override {
         return std::unique_ptr<Statement>(new WhileStatement(fOffset, this->test()->clone(),
                                                              this->statement()->clone()));
     }
 
     String description() const override {
         return "while (" + this->test()->description() + ") " + this->statement()->description();
     }
 
-private:
-    std::unique_ptr<Expression> fTest;
-    std::unique_ptr<Statement> fStatement;
-
     using INHERITED = Statement;
 };
 
 }  // namespace SkSL
 
 #endif
