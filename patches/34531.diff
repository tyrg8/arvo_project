commit 45123b7d05fe7aee73321f5d3f731b32465acb25
Author: Alexander Timin <altimin@google.com>
Date:   Fri May 21 14:53:52 2021 +0000

    Support writing untyped annotations into typed contexts.
    
    Allow typed contexts (TracedProto<Message>) to leverage untyped
    infrastucture (TracedValue) by adding repeated DebugAnnnotations
    debug_annotations field and using TracedValue API to fill it.
    
    R=eseckler@google.com,skyostil@chromium.org,lalitm@google.com
    
    Bug: b/184558843
    Change-Id: I31c25bdcbbdd2a599feca5e6880339293d404a54

diff --git a/include/perfetto/tracing/traced_proto.h b/include/perfetto/tracing/traced_proto.h
index 44e4fb2d3..a52972b21 100644
--- a/include/perfetto/tracing/traced_proto.h
+++ b/include/perfetto/tracing/traced_proto.h
@@ -1,72 +1,98 @@
 /*
  * Copyright (C) 2021 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 #ifndef INCLUDE_PERFETTO_TRACING_TRACED_PROTO_H_
 #define INCLUDE_PERFETTO_TRACING_TRACED_PROTO_H_
 
 #include "perfetto/base/template_util.h"
 #include "perfetto/protozero/field_writer.h"
 #include "perfetto/protozero/proto_utils.h"
+#include "perfetto/tracing/traced_value.h"
 
 namespace perfetto {
 class EventContext;
 
 // A Wrapper around a protozero message to allow C++ classes to specify how it
 // should be serialised into the trace:
 //
 // class Foo {
 //  public:
 //   void WriteIntoTrace(perfetto::TracedProto<pbzero::Foo> message) {
 //     message->set_int_field(int_field_);
 //   }
 // };
 //
 // This class also exposes EventContext, e.g. to enable data interning.
 //
 // NOTE: the functionality below is not ready yet.
 // TODO(altimin): Make the interop below possible.
 // TracedProto also provides a seamless integration with writing untyped
 // values via TracedValue / TracedDictionary / TracedArray:
 //
 // - TracedValue can be converted to a TracedProto, either by calling
 //   TracedValue::WriteProto<T>() or implicitly.
 // - If a proto message has a repeating DebugAnnotation debug_annotations
 //   field, it can be filled using the TracedDictionary obtained from
-//   TracedProto::WriteDebugAnnotations.
+//   TracedProto::AddDebugAnnotations.
 template <typename MessageType>
 class TracedProto {
  public:
   TracedProto(const TracedProto&) = delete;
   TracedProto& operator=(const TracedProto&) = delete;
   TracedProto& operator=(TracedProto&&) = delete;
   TracedProto(TracedProto&&) = default;
   ~TracedProto() = default;
 
   MessageType* operator->() const { return message_; }
 
   MessageType* message() { return message_; }
 
   EventContext& context() const { return context_; }
 
+  // Write additional untyped values into the same context, which is useful
+  // when a given C++ class has a typed representation, but also either has
+  // members which can only be written into an untyped context (e.g. they are
+  // autogenerated) or it's desirable to have a way to quickly extend the
+  // trace representation of this class (e.g. for debugging).
+  //
+  // The usage of the returned TracedDictionary should not be interleaved with
+  // writing into |message| as this results in an inefficient proto layout. To
+  // enforce this, AddDebugAnnotations should be called on TracedProto&&, i.e.
+  // std::move(message).AddDebugAnnotations().
+  //
+  // This requires a 'repeated DebugAnnotations debug_annotations' field in
+  // MessageType.
+  template <typename Check = void>
+  TracedDictionary AddDebugAnnotations() && {
+    static_assert(
+        std::is_base_of<
+            protozero::proto_utils::FieldMetadataBase,
+            typename MessageType::FieldMetadata_DebugAnnotations>::value,
+        "This message does not have a |debug_annotations| field. Please add a"
+        "'repeated perfetto.protos.DebugAnnotation debug_annnotations = N;' "
+        "field to your message.");
+    return TracedDictionary(message_, MessageType::kDebugAnnotations, nullptr);
+  }
+
  private:
   friend class EventContext;
 
   TracedProto(MessageType* message, EventContext& context)
       : message_(message), context_(context) {}
 
   MessageType* const message_;
   EventContext& context_;
 };
diff --git a/include/perfetto/tracing/traced_value.h b/include/perfetto/tracing/traced_value.h
index b1a14d31e..53f1cb68d 100644
--- a/include/perfetto/tracing/traced_value.h
+++ b/include/perfetto/tracing/traced_value.h
@@ -1,29 +1,31 @@
 /*
  * Copyright (C) 2021 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 #ifndef INCLUDE_PERFETTO_TRACING_TRACED_VALUE_H_
 #define INCLUDE_PERFETTO_TRACING_TRACED_VALUE_H_
 
 #include "perfetto/base/compiler.h"
 #include "perfetto/base/export.h"
 #include "perfetto/base/template_util.h"
+#include "perfetto/protozero/message.h"
+#include "perfetto/protozero/proto_utils.h"
 #include "perfetto/tracing/internal/checked_scope.h"
 #include "perfetto/tracing/string_helpers.h"
 #include "perfetto/tracing/traced_value_forward.h"
 
 #include <memory>
 #include <type_traits>
 #include <utility>
@@ -213,45 +215,72 @@ class PERFETTO_EXPORT TracedArray {
 class PERFETTO_EXPORT TracedDictionary {
  public:
   TracedDictionary(const TracedDictionary&) = delete;
   TracedDictionary& operator=(const TracedDictionary&) = delete;
   TracedDictionary& operator=(TracedDictionary&&) = delete;
   TracedDictionary(TracedDictionary&&) = default;
   ~TracedDictionary() = default;
 
   // There are two paths for writing dictionary keys: fast path for writing
   // compile-time const, whose pointer is remains valid during the entire
   // runtime of the program and the slow path for dynamic strings, which need to
   // be copied.
   // In the most common case, a string literal can be passed to `Add`/`AddItem`.
   // In other cases, either StaticString or DynamicString declarations are
   // needed.
 
   TracedValue AddItem(StaticString key);
   TracedValue AddItem(DynamicString key);
 
   template <typename T>
   void Add(StaticString key, T&& value) {
     WriteIntoTracedValue(AddItem(key), std::forward<T>(value));
   }
 
   template <typename T>
   void Add(DynamicString key, T&& value) {
     WriteIntoTracedValue(AddItem(key), std::forward<T>(value));
   }
 
   TracedDictionary AddDictionary(StaticString key);
   TracedDictionary AddDictionary(DynamicString key);
   TracedArray AddArray(StaticString key);
   TracedArray AddArray(DynamicString key);
 
  private:
   friend class TracedValue;
+  template <typename T>
+  friend class TracedProto;
+
+  // Create a |TracedDictionary| which will populate the given field of the
+  // given |message|.
+  template <typename MessageType, typename FieldMetadata>
+  inline explicit TracedDictionary(
+      MessageType* message,
+      protozero::proto_utils::internal::FieldMetadataHelper<FieldMetadata>,
+      internal::CheckedScope* parent_scope)
+      : message_(message),
+        field_id_(FieldMetadata::kFieldId),
+        checked_scope_(parent_scope) {
+    static_assert(std::is_base_of<protozero::Message, MessageType>::value,
+                  "Message should be a subclass of protozero::Message");
+    static_assert(std::is_base_of<protozero::proto_utils::FieldMetadataBase,
+                                  FieldMetadata>::value,
+                  "FieldMetadata should be a subclass of FieldMetadataBase");
+    static_assert(
+        std::is_same<typename FieldMetadata::message_type, MessageType>::value,
+        "Field does not belong to this message");
+    static_assert(
+        std::is_same<typename FieldMetadata::cpp_field_type,
+                     ::perfetto::protos::pbzero::DebugAnnotation>::value,
+        "Field should be of DebugAnnotation type");
+    static_assert(
+        FieldMetadata::kRepetitionType ==
+            protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
+        "Field should be non-packed repeated");
+  }
 
-  inline explicit TracedDictionary(protos::pbzero::DebugAnnotation* context,
-                                   internal::CheckedScope* parent_scope)
-      : context_(context), checked_scope_(parent_scope) {}
-
-  protos::pbzero::DebugAnnotation* context_;
+  protozero::Message* const message_;
+  const uint32_t field_id_;
 
   internal::CheckedScope checked_scope_;
 };
diff --git a/protos/perfetto/trace/perfetto_trace.proto b/protos/perfetto/trace/perfetto_trace.proto
index 57f945cb0..043b6826b 100644
--- a/protos/perfetto/trace/perfetto_trace.proto
+++ b/protos/perfetto/trace/perfetto_trace.proto
@@ -8357,40 +8357,42 @@ message CpuInfo {
 // Event used by testing code.
 message TestEvent {
   // Arbitrary string used in tests.
   optional string str = 1;
 
   // The current value of the random number sequence used in tests.
   optional uint32 seq_value = 2;
 
   // Monotonically increased on each packet.
   optional uint64 counter = 3;
 
   // No more packets should follow (from the current sequence).
   optional bool is_last = 4;
 
   message TestPayload {
     repeated string str = 1;
     repeated TestPayload nested = 2;
 
     optional string single_string = 4;
 
     optional int32 single_int = 5;
     repeated int32 repeated_ints = 6;
 
     // When 0 this is the bottom-most nested message.
     optional uint32 remaining_nesting_depth = 3;
+
+    repeated DebugAnnotation debug_annotations = 7;
   }
   optional TestPayload payload = 5;
 }
 
 // End of protos/perfetto/trace/test_event.proto
 
 // Begin of protos/perfetto/trace/trace_packet_defaults.proto
 
 // Default values for TracePacket fields that hold for a particular TraceWriter
 // packet sequence. This message contains a subset of the TracePacket fields
 // with matching IDs. When provided, these fields define the default values
 // that should be applied, at import time, to all TracePacket(s) with the same
 // |trusted_packet_sequence_id|, unless otherwise specified in each packet.
 //
 // Should be reemitted whenever incremental state is cleared on the sequence.
diff --git a/protos/perfetto/trace/test_event.proto b/protos/perfetto/trace/test_event.proto
index 67a8f60f7..023343e19 100644
--- a/protos/perfetto/trace/test_event.proto
+++ b/protos/perfetto/trace/test_event.proto
@@ -16,33 +16,37 @@
 
 syntax = "proto2";
 
+import "protos/perfetto/trace/track_event/debug_annotation.proto";
+
 package perfetto.protos;
 
 // Event used by testing code.
 message TestEvent {
   // Arbitrary string used in tests.
   optional string str = 1;
 
   // The current value of the random number sequence used in tests.
   optional uint32 seq_value = 2;
 
   // Monotonically increased on each packet.
   optional uint64 counter = 3;
 
   // No more packets should follow (from the current sequence).
   optional bool is_last = 4;
 
   message TestPayload {
     repeated string str = 1;
     repeated TestPayload nested = 2;
 
     optional string single_string = 4;
 
     optional int32 single_int = 5;
     repeated int32 repeated_ints = 6;
 
     // When 0 this is the bottom-most nested message.
     optional uint32 remaining_nesting_depth = 3;
+
+    repeated DebugAnnotation debug_annotations = 7;
   }
   optional TestPayload payload = 5;
 }
diff --git a/protos/perfetto/trace/test_extensions.proto b/protos/perfetto/trace/test_extensions.proto
index 94118dce4..dca2db627 100644
--- a/protos/perfetto/trace/test_extensions.proto
+++ b/protos/perfetto/trace/test_extensions.proto
@@ -17,6 +17,7 @@
 syntax = "proto2";
 
 import public "protos/perfetto/trace/track_event/track_event.proto";
+import "protos/perfetto/trace/track_event/debug_annotation.proto";
 
 package perfetto.protos;
 
@@ -35,4 +36,6 @@ message TestExtension {
 
 message TestExtensionChild {
   optional string child_field_for_testing = 1;
+
+  repeated DebugAnnotation debug_annotations = 99;
 }
diff --git a/src/trace_processor/importers/proto/track_event_parser.cc b/src/trace_processor/importers/proto/track_event_parser.cc
index 8b93efd8a..7926bd30c 100644
--- a/src/trace_processor/importers/proto/track_event_parser.cc
+++ b/src/trace_processor/importers/proto/track_event_parser.cc
@@ -1284,113 +1284,125 @@ class TrackEventParser::EventImporter {
 TrackEventParser::TrackEventParser(TraceProcessorContext* context,
                                    TrackEventTracker* track_event_tracker)
     : args_parser_(*context->descriptor_pool_.get()),
       context_(context),
       track_event_tracker_(track_event_tracker),
       counter_name_thread_time_id_(
           context->storage->InternString("thread_time")),
       counter_name_thread_instruction_count_id_(
           context->storage->InternString("thread_instruction_count")),
       task_file_name_args_key_id_(
           context->storage->InternString("task.posted_from.file_name")),
       task_function_name_args_key_id_(
           context->storage->InternString("task.posted_from.function_name")),
       task_line_number_args_key_id_(
           context->storage->InternString("task.posted_from.line_number")),
       log_message_body_key_id_(
           context->storage->InternString("track_event.log_message")),
       source_location_function_name_key_id_(
           context->storage->InternString("source.function_name")),
       source_location_file_name_key_id_(
           context->storage->InternString("source.file_name")),
       source_location_line_number_key_id_(
           context->storage->InternString("source.line_number")),
       raw_legacy_event_id_(
           context->storage->InternString("track_event.legacy_event")),
       legacy_event_passthrough_utid_id_(
           context->storage->InternString("legacy_event.passthrough_utid")),
       legacy_event_category_key_id_(
           context->storage->InternString("legacy_event.category")),
       legacy_event_name_key_id_(
           context->storage->InternString("legacy_event.name")),
       legacy_event_phase_key_id_(
           context->storage->InternString("legacy_event.phase")),
       legacy_event_duration_ns_key_id_(
           context->storage->InternString("legacy_event.duration_ns")),
       legacy_event_thread_timestamp_ns_key_id_(
           context->storage->InternString("legacy_event.thread_timestamp_ns")),
       legacy_event_thread_duration_ns_key_id_(
           context->storage->InternString("legacy_event.thread_duration_ns")),
       legacy_event_thread_instruction_count_key_id_(
           context->storage->InternString(
               "legacy_event.thread_instruction_count")),
       legacy_event_thread_instruction_delta_key_id_(
           context->storage->InternString(
               "legacy_event.thread_instruction_delta")),
       legacy_event_use_async_tts_key_id_(
           context->storage->InternString("legacy_event.use_async_tts")),
       legacy_event_unscoped_id_key_id_(
           context->storage->InternString("legacy_event.unscoped_id")),
       legacy_event_global_id_key_id_(
           context->storage->InternString("legacy_event.global_id")),
       legacy_event_local_id_key_id_(
           context->storage->InternString("legacy_event.local_id")),
       legacy_event_id_scope_key_id_(
           context->storage->InternString("legacy_event.id_scope")),
       legacy_event_bind_id_key_id_(
           context->storage->InternString("legacy_event.bind_id")),
       legacy_event_bind_to_enclosing_key_id_(
           context->storage->InternString("legacy_event.bind_to_enclosing")),
       legacy_event_flow_direction_key_id_(
           context->storage->InternString("legacy_event.flow_direction")),
       histogram_name_key_id_(
           context->storage->InternString("chrome_histogram_sample.name")),
       flow_direction_value_in_id_(context->storage->InternString("in")),
       flow_direction_value_out_id_(context->storage->InternString("out")),
       flow_direction_value_inout_id_(context->storage->InternString("inout")),
       chrome_legacy_ipc_class_args_key_id_(
           context->storage->InternString("legacy_ipc.class")),
       chrome_legacy_ipc_line_args_key_id_(
           context->storage->InternString("legacy_ipc.line")),
       chrome_host_app_package_name_id_(
           context->storage->InternString("chrome.host_app_package_name")),
       chrome_crash_trace_id_name_id_(
           context->storage->InternString("chrome.crash_trace_id")),
       chrome_string_lookup_(context->storage.get()),
       counter_unit_ids_{{kNullStringId, context_->storage->InternString("ns"),
                          context_->storage->InternString("count"),
                          context_->storage->InternString("bytes")}} {
   // Switch |source_location_iid| into its interned data variant.
-  args_parser_.AddParsingOverride(
+  args_parser_.AddParsingOverrideForField(
       "begin_impl_frame_args.current_args.source_location_iid",
       [](const protozero::Field& field,
          util::ProtoToArgsParser::Delegate& delegate) {
         return MaybeParseSourceLocation("begin_impl_frame_args.current_args",
                                         field, delegate);
       });
-  args_parser_.AddParsingOverride(
+  args_parser_.AddParsingOverrideForField(
       "begin_impl_frame_args.last_args.source_location_iid",
       [](const protozero::Field& field,
          util::ProtoToArgsParser::Delegate& delegate) {
         return MaybeParseSourceLocation("begin_impl_frame_args.last_args",
                                         field, delegate);
       });
-  args_parser_.AddParsingOverride(
+  args_parser_.AddParsingOverrideForField(
       "begin_frame_observer_state.last_begin_frame_args.source_location_iid",
       [](const protozero::Field& field,
          util::ProtoToArgsParser::Delegate& delegate) {
         return MaybeParseSourceLocation(
             "begin_frame_observer_state.last_begin_frame_args", field,
             delegate);
       });
-  args_parser_.AddParsingOverride(
+  args_parser_.AddParsingOverrideForField(
       "chrome_memory_pressure_notification.creation_location_iid",
       [](const protozero::Field& field,
          util::ProtoToArgsParser::Delegate& delegate) {
         return MaybeParseSourceLocation("chrome_memory_pressure_notification",
                                         field, delegate);
       });
 
+  // Parse DebugAnnotations.
+  args_parser_.AddParsingOverrideForType(
+      ".perfetto.protos.DebugAnnotation",
+      [&](util::ProtoToArgsParser::ScopedNestedKeyContext& key,
+          const protozero::ConstBytes& data,
+          util::ProtoToArgsParser::Delegate& delegate) {
+        // Do not add "debug_annotations" to the final key.
+        key.RemoveFieldSuffix();
+        util::DebugAnnotationParser annotation_parser(args_parser_);
+        return annotation_parser.Parse(data, delegate);
+      });
+
   for (uint16_t index : kReflectFields) {
     reflect_fields_.push_back(index);
   }
 }
diff --git a/src/trace_processor/util/debug_annotation_parser.cc b/src/trace_processor/util/debug_annotation_parser.cc
index eeaf39fe2..7fa359e41 100644
--- a/src/trace_processor/util/debug_annotation_parser.cc
+++ b/src/trace_processor/util/debug_annotation_parser.cc
@@ -70,74 +70,71 @@ DebugAnnotationParser::ParseResult
 DebugAnnotationParser::ParseDebugAnnotationValue(
     protos::pbzero::DebugAnnotation::Decoder& annotation,
     ProtoToArgsParser::Delegate& delegate,
     const ProtoToArgsParser::Key& context_name) {
   if (annotation.has_bool_value()) {
     delegate.AddBoolean(context_name, annotation.bool_value());
   } else if (annotation.has_uint_value()) {
     delegate.AddUnsignedInteger(context_name, annotation.uint_value());
   } else if (annotation.has_int_value()) {
     delegate.AddInteger(context_name, annotation.int_value());
   } else if (annotation.has_double_value()) {
     delegate.AddDouble(context_name, annotation.double_value());
   } else if (annotation.has_string_value()) {
     delegate.AddString(context_name, annotation.string_value());
   } else if (annotation.has_pointer_value()) {
     delegate.AddPointer(context_name, reinterpret_cast<const void*>(
                                           annotation.pointer_value()));
   } else if (annotation.has_dict_entries()) {
     bool added_entry = false;
     for (auto it = annotation.dict_entries(); it; ++it) {
       protos::pbzero::DebugAnnotation::Decoder key_value(*it);
       std::string key;
       base::Status key_parse_result =
           ParseDebugAnnotationName(key_value, delegate, key);
       if (!key_parse_result.ok())
         return {key_parse_result, added_entry};
 
       auto nested_key = proto_to_args_parser_.EnterDictionary(key);
       ParseResult value_parse_result =
           ParseDebugAnnotationValue(key_value, delegate, nested_key.key());
       added_entry |= value_parse_result.added_entry;
       if (!value_parse_result.status.ok())
         return {value_parse_result.status, added_entry};
     }
   } else if (annotation.has_array_values()) {
     size_t index = delegate.GetArrayEntryIndex(context_name.key);
     bool added_entry = false;
     for (auto it = annotation.array_values(); it; ++it) {
+      std::string array_key = context_name.key;
       protos::pbzero::DebugAnnotation::Decoder value(*it);
 
       auto nested_key = proto_to_args_parser_.EnterArray(index);
       ParseResult value_parse_result =
           ParseDebugAnnotationValue(value, delegate, nested_key.key());
 
-      // Reset the key here to ensure that we have the correct array key to
-      // increment.
-      nested_key.Reset();
-
       if (value_parse_result.added_entry) {
-        index = delegate.IncrementArrayEntryIndex(context_name.key);
+        index = delegate.IncrementArrayEntryIndex(array_key);
         added_entry = true;
       }
       if (!value_parse_result.status.ok())
         return {value_parse_result.status, added_entry};
     }
   } else if (annotation.has_legacy_json_value()) {
     if (!IsJsonSupported())
       return {base::ErrStatus("Ignoring legacy_json_value (no json support)"),
               false};
 
     bool added_entry =
         delegate.AddJson(context_name, annotation.legacy_json_value());
     return {base::OkStatus(), added_entry};
   } else if (annotation.has_nested_value()) {
     return ParseNestedValueArgs(annotation.nested_value(), context_name,
                                 delegate);
   } else {
     return {base::OkStatus(), /*added_entry=*/false};
   }
 
   return {base::OkStatus(), /*added_entry=*/true};
 }
 
 // static
diff --git a/src/trace_processor/util/proto_to_args_parser.cc b/src/trace_processor/util/proto_to_args_parser.cc
index 8e4eb2286..96e066da4 100644
--- a/src/trace_processor/util/proto_to_args_parser.cc
+++ b/src/trace_processor/util/proto_to_args_parser.cc
@@ -26,34 +26,11 @@ namespace util {
 
 namespace {
 
-// ScopedStringAppender will add |append| to |dest| when constructed and
-// erases the appended suffix from |dest| when it goes out of scope. Thus
-// |dest| must be valid for the entire lifetime of ScopedStringAppender.
-//
-// This is useful as we descend into a proto since the column names just
-// appended with ".field_name" as we go lower.
-//
-// I.E. message1.message2.field_name1 is a column, but we'll then need to
-// append message1.message2.field_name2 afterwards so we only need to append
-// "field_name1" within some scope.
-class ScopedStringAppender {
- public:
-  ScopedStringAppender(const std::string& append, std::string* dest)
-      : old_size_(dest->size()), dest_(dest) {
-    if (dest->empty()) {
-      dest_->reserve(append.size());
-    } else {
-      dest_->reserve(old_size_ + 1 + append.size());
-      dest_->append(".");
-    }
-    dest_->append(append);
-  }
-  ~ScopedStringAppender() { dest_->erase(old_size_); }
-
- private:
-  size_t old_size_;
-  std::string* dest_;
-};
+void AppendProtoType(std::string& target, const std::string& value) {
+  if (!target.empty())
+    target += '.';
+  target += value;
+}
 
 }  // namespace
 
@@ -78,14 +55,14 @@ ProtoToArgsParser::ScopedNestedKeyContext::ScopedNestedKeyContext(
 }
 
 ProtoToArgsParser::ScopedNestedKeyContext::~ScopedNestedKeyContext() {
-  Reset();
+  RemoveFieldSuffix();
 }
 
-void ProtoToArgsParser::ScopedNestedKeyContext::Reset() {
+void ProtoToArgsParser::ScopedNestedKeyContext::RemoveFieldSuffix() {
   if (old_flat_key_length_)
     key_.flat_key.resize(old_flat_key_length_.value());
   if (old_key_length_)
     key_.key.resize(old_key_length_.value());
   old_flat_key_length_ = base::nullopt;
   old_key_length_ = base::nullopt;
 }
@@ -101,43 +78,58 @@ ProtoToArgsParser::ProtoToArgsParser(const DescriptorPool& pool) : pool_(pool) {
 base::Status ProtoToArgsParser::ParseMessage(
     const protozero::ConstBytes& cb,
     const std::string& type,
     const std::vector<uint16_t>* allowed_fields,
     Delegate& delegate) {
+  ScopedNestedKeyContext key_context(key_prefix_);
+  return ParseMessageInternal(key_context, cb, type, allowed_fields, delegate);
+}
+
+base::Status ProtoToArgsParser::ParseMessageInternal(
+    ScopedNestedKeyContext& key_context,
+    const protozero::ConstBytes& cb,
+    const std::string& type,
+    const std::vector<uint16_t>* allowed_fields,
+    Delegate& delegate) {
+  if (auto override_result =
+          MaybeApplyOverrideForType(type, key_context, cb, delegate)) {
+    return override_result.value();
+  }
+
   auto idx = pool_.FindDescriptorIdx(type);
   if (!idx) {
     return base::Status("Failed to find proto descriptor");
   }
 
   auto& descriptor = pool_.descriptors()[*idx];
 
   std::unordered_map<size_t, int> repeated_field_index;
 
   protozero::ProtoDecoder decoder(cb);
   for (protozero::Field f = decoder.ReadField(); f.valid();
        f = decoder.ReadField()) {
     auto field = descriptor.FindFieldByTag(f.id());
     if (!field) {
       // Unknown field, possibly an unknown extension.
       continue;
     }
 
     // If allowlist is not provided, reflect all fields. Otherwise, check if the
     // current field either an extension or is in allowlist.
     bool is_allowed = field->is_extension() || !allowed_fields ||
                       std::find(allowed_fields->begin(), allowed_fields->end(),
                                 f.id()) != allowed_fields->end();
 
     if (!is_allowed) {
       // Field is neither an extension, nor is allowed to be
       // reflected.
       continue;
     }
     RETURN_IF_ERROR(
         ParseField(*field, repeated_field_index[f.id()], f, delegate));
     if (field->is_repeated()) {
       repeated_field_index[f.id()]++;
     }
   }
 
   return base::OkStatus();
 }
@@ -145,57 +137,75 @@ base::Status ProtoToArgsParser::ParseMessage(
 base::Status ProtoToArgsParser::ParseField(
     const FieldDescriptor& field_descriptor,
     int repeated_field_number,
     protozero::Field field,
     Delegate& delegate) {
   std::string prefix_part = field_descriptor.name();
   if (field_descriptor.is_repeated()) {
     std::string number = std::to_string(repeated_field_number);
     prefix_part.reserve(prefix_part.length() + number.length() + 2);
     prefix_part.append("[");
     prefix_part.append(number);
     prefix_part.append("]");
   }
 
   // In the args table we build up message1.message2.field1 as the column
   // name. This will append the ".field1" suffix to |key_prefix| and then
   // remove it when it goes out of scope.
-  ScopedStringAppender scoped_prefix(prefix_part, &key_prefix_.key);
-  ScopedStringAppender scoped_flat_key_prefix(field_descriptor.name(),
-                                              &key_prefix_.flat_key);
+  ScopedNestedKeyContext key_context(key_prefix_);
+  AppendProtoType(key_prefix_.flat_key, field_descriptor.name());
+  AppendProtoType(key_prefix_.key, prefix_part);
 
   // If we have an override parser then use that instead and move onto the
   // next loop.
   if (base::Optional<base::Status> status =
-          MaybeApplyOverride(field, delegate)) {
+          MaybeApplyOverrideForField(field, delegate)) {
     return *status;
   }
 
   // If this is not a message we can just immediately add the column name and
   // get the value out of |field|. However if it is a message we need to
   // recurse into it.
   if (field_descriptor.type() ==
       protos::pbzero::FieldDescriptorProto::TYPE_MESSAGE) {
-    return ParseMessage(field.as_bytes(), field_descriptor.resolved_type_name(),
-                        nullptr, delegate);
+    return ParseMessageInternal(key_context, field.as_bytes(),
+                                field_descriptor.resolved_type_name(), nullptr,
+                                delegate);
   }
 
   return ParseSimpleField(field_descriptor, field, delegate);
 }
 
-void ProtoToArgsParser::AddParsingOverride(std::string field,
-                                           ParsingOverride func) {
-  overrides_[std::move(field)] = std::move(func);
+void ProtoToArgsParser::AddParsingOverrideForField(
+    const std::string& field,
+    ParsingOverrideForField func) {
+  field_overrides_[field] = std::move(func);
+}
+
+void ProtoToArgsParser::AddParsingOverrideForType(const std::string& type,
+                                                  ParsingOverrideForType func) {
+  type_overrides_[type] = std::move(func);
 }
 
-base::Optional<base::Status> ProtoToArgsParser::MaybeApplyOverride(
+base::Optional<base::Status> ProtoToArgsParser::MaybeApplyOverrideForField(
     const protozero::Field& field,
     Delegate& delegate) {
-  auto it = overrides_.find(key_prefix_.flat_key);
-  if (it == overrides_.end())
+  auto it = field_overrides_.find(key_prefix_.flat_key);
+  if (it == field_overrides_.end())
     return base::nullopt;
   return it->second(field, delegate);
 }
 
+base::Optional<base::Status> ProtoToArgsParser::MaybeApplyOverrideForType(
+    const std::string& message_type,
+    ScopedNestedKeyContext& key,
+    const protozero::ConstBytes& data,
+    Delegate& delegate) {
+  auto it = type_overrides_.find(message_type);
+  if (it == type_overrides_.end())
+    return base::nullopt;
+  return it->second(key, data, delegate);
+}
+
 base::Status ProtoToArgsParser::ParseSimpleField(
     const FieldDescriptor& descriptor,
     const protozero::Field& field,
@@ -275,15 +285,11 @@ ProtoToArgsParser::ScopedNestedKeyContext ProtoToArgsParser::EnterArray(
 ProtoToArgsParser::ScopedNestedKeyContext ProtoToArgsParser::EnterDictionary(
     const std::string& name) {
   auto context = ScopedNestedKeyContext(key_prefix_);
-  if (!key_prefix_.key.empty())
-    key_prefix_.key += '.';
-  key_prefix_.key += name;
-  if (!key_prefix_.flat_key.empty())
-    key_prefix_.flat_key += '.';
-  key_prefix_.flat_key += name;
+  AppendProtoType(key_prefix_.key, name);
+  AppendProtoType(key_prefix_.flat_key, name);
   return context;
 }
 
 }  // namespace util
 }  // namespace trace_processor
 }  // namespace perfetto
diff --git a/src/trace_processor/util/proto_to_args_parser.h b/src/trace_processor/util/proto_to_args_parser.h
index 9110e916b..e6934a6b4 100644
--- a/src/trace_processor/util/proto_to_args_parser.h
+++ b/src/trace_processor/util/proto_to_args_parser.h
@@ -33,187 +33,238 @@ namespace util {
 // ProtoToArgsParser encapsulates the process of taking an arbitrary proto and
 // parsing it into key-value arg pairs. This is done by traversing
 // the proto using reflection (with descriptors from |descriptor_pool|)
 // and passing the parsed data to |Delegate| callbacks.
 //
 // E.g. given a proto like
 //
 // package perfetto.protos;
 // message SubMessage {
 //   optional int32 field = 1;
 // }
 // message MainMessage {
 //   optional int32 field1 = 1;
 //   optional string field2 = 2;
 //   optional SubMessage field3 = 3;
 // }
 //
 // We will get the args set columns "field1", "field2", "field3.field" and will
 // store the values found inside as the result.
 //
 // Usage of this is as follows:
 //
 // DescriptorPool pool;
 // ProtoToArgsParser parser(&pool);
 // pool.AddProtoFileDescriptor(
 //     /* provide descriptor generated by tools/gen_binary_descriptors */);
 // parser.ParseMessage(const_bytes, ".perfetto.protos.MainMessage",
 //     /* fields */, /* delegate */);
 class ProtoToArgsParser {
  public:
   explicit ProtoToArgsParser(const DescriptorPool& descriptor_pool);
 
   struct Key {
     Key(const std::string& flat_key, const std::string& key);
     Key(const std::string& key);
     Key();
     ~Key();
 
     std::string flat_key;
     std::string key;
   };
 
   class Delegate {
    public:
     virtual ~Delegate();
 
     virtual void AddInteger(const Key& key, int64_t value) = 0;
     virtual void AddUnsignedInteger(const Key& key, uint64_t value) = 0;
     virtual void AddString(const Key& key,
                            const protozero::ConstChars& value) = 0;
     virtual void AddDouble(const Key& key, double value) = 0;
     virtual void AddPointer(const Key& key, const void* value) = 0;
     virtual void AddBoolean(const Key& key, bool value) = 0;
     // Returns whether an entry was added or not.
     virtual bool AddJson(const Key& key,
                          const protozero::ConstChars& value) = 0;
 
     virtual size_t GetArrayEntryIndex(const std::string& array_key) = 0;
     virtual size_t IncrementArrayEntryIndex(const std::string& array_key) = 0;
 
     template <typename FieldMetadata>
     typename FieldMetadata::cpp_field_type::Decoder* GetInternedMessage(
         protozero::proto_utils::internal::FieldMetadataHelper<FieldMetadata>,
         uint64_t iid) {
       static_assert(std::is_base_of<protozero::proto_utils::FieldMetadataBase,
                                     FieldMetadata>::value,
                     "Field metadata should be a subclass of FieldMetadataBase");
       static_assert(std::is_same<typename FieldMetadata::message_type,
                                  protos::pbzero::InternedData>::value,
                     "Field should belong to InternedData proto");
       return GetInternedMessageView(FieldMetadata::kFieldId, iid)
           ->template GetOrCreateDecoder<
               typename FieldMetadata::cpp_field_type>();
     }
 
    protected:
     virtual InternedMessageView* GetInternedMessageView(uint32_t field_id,
                                                         uint64_t iid) = 0;
   };
 
-  using ParsingOverride =
-      std::function<base::Optional<base::Status>(const protozero::Field&,
-                                                 Delegate& delegate)>;
-
-  // Installs an override for the field at the specified path. We will invoke
-  // |parsing_override| when the field is encountered.
-  //
-  // The return value of |parsing_override| indicates whether the override
-  // parsed the sub-message and ProtoToArgsParser should skip it (base::nullopt)
-  // or the sub-message should continue to be parsed by ProtoToArgsParser using
-  // the descriptor (base::Status).
-  //
-  // Note |field_path| must be the full path separated by periods. I.E. in the
-  // proto
-  //
-  // message SubMessage {
-  //   optional int32 field = 1;
-  // }
-  // message MainMessage {
-  //   optional SubMessage field1 = 1;
-  //   optional SubMessage field2 = 2;
-  // }
-  //
-  // To override the handling of both SubMessage fields you must add two parsing
-  // overrides. One with a |field_path| == "field1.field" and another with
-  // "field2.field".
-  void AddParsingOverride(std::string field_path,
-                          ParsingOverride parsing_override);
-
   // Given a view of bytes that represent a serialized protozero message of
   // |type| we will parse each field.
   //
   // Returns on any error with a status describing the problem. However any
   // added values before encountering the error will be parsed and forwarded to
   // the delegate.
   //
   // Fields with ids given in |fields| are parsed using reflection, as well
   // as known (previously registered) extension fields. If |allowed_fields| is a
   // nullptr, all fields are going to be parsed.
   //
   // Note:
   // |type| must be the fully qualified name, but with a '.' added to the
   // beginning. I.E. ".perfetto.protos.TrackEvent". And must match one of the
   // descriptors already added through |AddProtoFileDescriptor|.
   //
   // IMPORTANT: currently bytes fields are not supported.
   //
   // TODO(b/145578432): Add support for byte fields.
   base::Status ParseMessage(const protozero::ConstBytes& cb,
                             const std::string& type,
                             const std::vector<uint16_t>* allowed_fields,
                             Delegate& delegate);
 
+  // This class is responsible for resetting the current key prefix to the old
+  // value when deleted or reset.
   struct ScopedNestedKeyContext {
    public:
     ~ScopedNestedKeyContext();
     ScopedNestedKeyContext(ScopedNestedKeyContext&&);
     ScopedNestedKeyContext(const ScopedNestedKeyContext&) = delete;
     ScopedNestedKeyContext& operator=(const ScopedNestedKeyContext&) = delete;
 
     const Key& key() const { return key_; }
 
-    // Reset this context, which sets |key_| to the state before the nested
-    // context was created.
-    void Reset();
+    // Clear this context, which strips the latest suffix from |key_| and sets
+    // it to the state before the nested context was created.
+    void RemoveFieldSuffix();
 
    private:
     friend class ProtoToArgsParser;
 
     ScopedNestedKeyContext(Key& old_value);
 
     struct ScopedStringAppender;
 
     Key& key_;
     base::Optional<size_t> old_flat_key_length_ = base::nullopt;
     base::Optional<size_t> old_key_length_ = base::nullopt;
   };
 
   // These methods can be called from parsing overrides to enter nested
   // contexts. The contexts are left when the returned scope is destroyed or
-  // reset.
+  // RemoveFieldSuffix() is called.
   ScopedNestedKeyContext EnterDictionary(const std::string& key);
   ScopedNestedKeyContext EnterArray(size_t index);
 
+  using ParsingOverrideForField =
+      std::function<base::Optional<base::Status>(const protozero::Field&,
+                                                 Delegate& delegate)>;
+
+  // Installs an override for the field at the specified path. We will invoke
+  // |parsing_override| when the field is encountered.
+  //
+  // The return value of |parsing_override| indicates whether the override
+  // parsed the sub-message and ProtoToArgsParser should skip it (base::nullopt)
+  // or the sub-message should continue to be parsed by ProtoToArgsParser using
+  // the descriptor (base::Status).
+  //
+  // Note |field_path| must be the full path separated by periods. I.E. in the
+  // proto
+  //
+  // message SubMessage {
+  //   optional int32 field = 1;
+  // }
+  // message MainMessage {
+  //   optional SubMessage field1 = 1;
+  //   optional SubMessage field2 = 2;
+  // }
+  //
+  // To override the handling of both SubMessage fields you must add two parsing
+  // overrides. One with a |field_path| == "field1.field" and another with
+  // "field2.field".
+  void AddParsingOverrideForField(const std::string& field_path,
+                                  ParsingOverrideForField parsing_override);
+
+  using ParsingOverrideForType = std::function<base::Optional<base::Status>(
+      ScopedNestedKeyContext& key,
+      const protozero::ConstBytes& data,
+      Delegate& delegate)>;
+
+  // Installs an override for all fields with the given type. We will invoke
+  // |parsing_override| when a field with the given message type is encountered.
+  // Note that the path-based overrides take precedence over type overrides.
+  //
+  // The return value of |parsing_override| indicates whether the override
+  // parsed the sub-message and ProtoToArgsParser should skip it (base::nullopt)
+  // or the sub-message should continue to be parsed by ProtoToArgsParser using
+  // the descriptor (base::Status).
+  //
+  //
+  // For example, given the following protos and a type override for SubMessage,
+  // all three fields will be parsed using this override.
+  //
+  // message SubMessage {
+  //   optional int32 value = 1;
+  // }
+  //
+  // message MainMessage1 {
+  //   optional SubMessage field1 = 1;
+  //   optional SubMessage field2 = 2;
+  // }
+  //
+  // message MainMessage2 {
+  //   optional SubMessage field3 = 1;
+  // }
+  void AddParsingOverrideForType(const std::string& message_type,
+                                 ParsingOverrideForType parsing_override);
+
  private:
   base::Status ParseField(const FieldDescriptor& field_descriptor,
                           int repeated_field_number,
                           protozero::Field field,
                           Delegate& delegate);
 
-  base::Optional<base::Status> MaybeApplyOverride(const protozero::Field&,
-                                                  Delegate& delegate);
+  base::Optional<base::Status> MaybeApplyOverrideForField(
+      const protozero::Field&,
+      Delegate& delegate);
+
+  base::Optional<base::Status> MaybeApplyOverrideForType(
+      const std::string& message_type,
+      ScopedNestedKeyContext& key,
+      const protozero::ConstBytes& data,
+      Delegate& delegate);
+
+  // A type override can call |key.RemoveFieldSuffix()| if it wants to exclude
+  // the overriden field's name from the parsed args' keys.
+  base::Status ParseMessageInternal(ScopedNestedKeyContext& key,
+                                    const protozero::ConstBytes& cb,
+                                    const std::string& type,
+                                    const std::vector<uint16_t>* fields,
+                                    Delegate& delegate);
 
   base::Status ParseSimpleField(const FieldDescriptor& desciptor,
                                 const protozero::Field& field,
                                 Delegate& delegate);
 
-  std::unordered_map<std::string, ParsingOverride> overrides_;
+  std::unordered_map<std::string, ParsingOverrideForField> field_overrides_;
+  std::unordered_map<std::string, ParsingOverrideForType> type_overrides_;
   const DescriptorPool& pool_;
   Key key_prefix_;
 };
 
 }  // namespace util
 }  // namespace trace_processor
 }  // namespace perfetto
 
 #endif  // SRC_TRACE_PROCESSOR_UTIL_PROTO_TO_ARGS_PARSER_H_
diff --git a/src/trace_processor/util/proto_to_args_parser_unittest.cc b/src/trace_processor/util/proto_to_args_parser_unittest.cc
index a8d17f620..817174238 100644
--- a/src/trace_processor/util/proto_to_args_parser_unittest.cc
+++ b/src/trace_processor/util/proto_to_args_parser_unittest.cc
@@ -35,10 +35,9 @@ namespace {
 
 constexpr size_t kChunkSize = 42;
 
-using ::testing::_;
-using ::testing::Eq;
-using ::testing::Invoke;
-using ::testing::NiceMock;
+protozero::ConstChars ToChars(const char* str) {
+  return protozero::ConstChars{str, strlen(str)};
+}
 
 class ProtoToArgsParserTest : public ::testing::Test,
                               public ProtoToArgsParser::Delegate {
@@ -243,35 +242,35 @@ TEST_F(ProtoToArgsParserTest, CamelCaseFieldsProto) {
 TEST_F(ProtoToArgsParserTest, NestedProtoParsingOverrideHandled) {
   using namespace protozero::test::protos::pbzero;
   protozero::HeapBuffered<NestedA> msg{kChunkSize, kChunkSize};
   msg->set_super_nested()->set_value_c(3);
 
   auto binary_proto = msg.SerializeAsArray();
 
   DescriptorPool pool;
   auto status = pool.AddFromFileDescriptorSet(kTestMessagesDescriptor.data(),
                                               kTestMessagesDescriptor.size());
   ProtoToArgsParser parser(pool);
   ASSERT_TRUE(status.ok()) << "Failed to parse kTestMessagesDescriptor: "
                            << status.message();
 
-  parser.AddParsingOverride(
+  parser.AddParsingOverrideForField(
       "super_nested.value_c",
       [](const protozero::Field& field, ProtoToArgsParser::Delegate& writer) {
         EXPECT_EQ(field.type(), protozero::proto_utils::ProtoWireType::kVarInt);
         std::string key = "super_nested.value_b.replaced";
         writer.AddInteger({key, key}, field.as_int32());
         // We've handled this field by adding the desired args.
         return base::OkStatus();
       });
 
   status = parser.ParseMessage(
       protozero::ConstBytes{binary_proto.data(), binary_proto.size()},
       ".protozero.test.protos.NestedA", nullptr, *this);
   EXPECT_TRUE(status.ok())
       << "InternProtoFieldsIntoArgsTable failed with error: "
       << status.message();
   EXPECT_THAT(
       args(),
       testing::ElementsAre(
           "super_nested.value_b.replaced super_nested.value_b.replaced 3"));
 }
@@ -279,33 +278,33 @@ TEST_F(ProtoToArgsParserTest, NestedProtoParsingOverrideHandled) {
 TEST_F(ProtoToArgsParserTest, NestedProtoParsingOverrideSkipped) {
   using namespace protozero::test::protos::pbzero;
   protozero::HeapBuffered<NestedA> msg{kChunkSize, kChunkSize};
   msg->set_super_nested()->set_value_c(3);
 
   auto binary_proto = msg.SerializeAsArray();
 
   DescriptorPool pool;
   auto status = pool.AddFromFileDescriptorSet(kTestMessagesDescriptor.data(),
                                               kTestMessagesDescriptor.size());
   ProtoToArgsParser parser(pool);
   ASSERT_TRUE(status.ok()) << "Failed to parse kTestMessagesDescriptor: "
                            << status.message();
 
-  parser.AddParsingOverride(
+  parser.AddParsingOverrideForField(
       "super_nested.value_c",
       [](const protozero::Field& field, ProtoToArgsParser::Delegate&) {
         static int val = 0;
         ++val;
         EXPECT_EQ(1, val);
         EXPECT_EQ(field.type(), protozero::proto_utils::ProtoWireType::kVarInt);
         return base::nullopt;
       });
 
   status = parser.ParseMessage(
       protozero::ConstBytes{binary_proto.data(), binary_proto.size()},
       ".protozero.test.protos.NestedA", nullptr, *this);
   EXPECT_TRUE(status.ok())
       << "InternProtoFieldsIntoArgsTable failed with error: "
       << status.message();
   EXPECT_THAT(args(), testing::ElementsAre(
                           "super_nested.value_c super_nested.value_c 3"));
 }
@@ -313,61 +312,134 @@ TEST_F(ProtoToArgsParserTest, NestedProtoParsingOverrideSkipped) {
 TEST_F(ProtoToArgsParserTest, LookingUpInternedStateParsingOverride) {
   using namespace protozero::test::protos::pbzero;
   // The test proto, we will use |value_c| as the source_location iid.
   protozero::HeapBuffered<NestedA> msg{kChunkSize, kChunkSize};
   msg->set_super_nested()->set_value_c(3);
   auto binary_proto = msg.SerializeAsArray();
 
   // The interned source location.
   protozero::HeapBuffered<protos::pbzero::SourceLocation> src_loc{kChunkSize,
                                                                   kChunkSize};
   const uint64_t kIid = 3;
   src_loc->set_iid(kIid);
   src_loc->set_file_name("test_file_name");
   // We need to update sequence_state to point to it.
   auto binary_data = src_loc.SerializeAsArray();
   std::unique_ptr<uint8_t[]> buffer(new uint8_t[binary_data.size()]);
   for (size_t i = 0; i < binary_data.size(); ++i) {
     buffer.get()[i] = binary_data[i];
   }
   TraceBlobView blob(std::move(buffer), 0, binary_data.size());
   AddInternedSourceLocation(kIid, std::move(blob));
 
   DescriptorPool pool;
   auto status = pool.AddFromFileDescriptorSet(kTestMessagesDescriptor.data(),
                                               kTestMessagesDescriptor.size());
   ASSERT_TRUE(status.ok()) << "Failed to parse kTestMessagesDescriptor: "
                            << status.message();
 
   ProtoToArgsParser parser(pool);
   // Now we override the behaviour of |value_c| so we can expand the iid into
   // multiple args rows.
-  parser.AddParsingOverride(
+  parser.AddParsingOverrideForField(
       "super_nested.value_c",
       [](const protozero::Field& field, ProtoToArgsParser::Delegate& delegate)
           -> base::Optional<base::Status> {
         auto* decoder = delegate.GetInternedMessage(
             protos::pbzero::InternedData::kSourceLocations, field.as_uint64());
         if (!decoder) {
           // Lookup failed fall back on default behaviour.
           return base::nullopt;
         }
         delegate.AddString(ProtoToArgsParser::Key("file_name"),
                            protozero::ConstChars{"file", 4});
         delegate.AddInteger(ProtoToArgsParser::Key("line_number"), 2);
         return base::OkStatus();
       });
 
   status = parser.ParseMessage(
       protozero::ConstBytes{binary_proto.data(), binary_proto.size()},
       ".protozero.test.protos.NestedA", nullptr, *this);
   EXPECT_TRUE(status.ok())
       << "InternProtoFieldsIntoArgsTable failed with error: "
       << status.message();
   EXPECT_THAT(args(), testing::ElementsAre("file_name file_name file",
                                            "line_number line_number 2"));
 }
 
+TEST_F(ProtoToArgsParserTest, OverrideForType) {
+  using namespace protozero::test::protos::pbzero;
+  protozero::HeapBuffered<NestedA> msg{kChunkSize, kChunkSize};
+  msg->set_super_nested()->set_value_c(3);
+
+  auto binary_proto = msg.SerializeAsArray();
+
+  DescriptorPool pool;
+  auto status = pool.AddFromFileDescriptorSet(kTestMessagesDescriptor.data(),
+                                              kTestMessagesDescriptor.size());
+  ASSERT_TRUE(status.ok()) << "Failed to parse kTestMessagesDescriptor: "
+                           << status.message();
+
+  ProtoToArgsParser parser(pool);
+
+  parser.AddParsingOverrideForType(
+      ".protozero.test.protos.NestedA.NestedB.NestedC",
+      [](ProtoToArgsParser::ScopedNestedKeyContext&,
+         const protozero::ConstBytes&, Delegate& delegate) {
+        delegate.AddInteger(ProtoToArgsParser::Key("arg"), 42);
+        return base::OkStatus();
+      });
+
+  status = parser.ParseMessage(
+      protozero::ConstBytes{binary_proto.data(), binary_proto.size()},
+      ".protozero.test.protos.NestedA", nullptr, *this);
+  EXPECT_TRUE(status.ok())
+      << "InternProtoFieldsIntoArgsTable failed with error: "
+      << status.message();
+  EXPECT_THAT(args(), testing::ElementsAre("arg arg 42"));
+}
+
+TEST_F(ProtoToArgsParserTest, FieldOverrideTakesPrecedence) {
+  using namespace protozero::test::protos::pbzero;
+  protozero::HeapBuffered<NestedA> msg{kChunkSize, kChunkSize};
+  msg->set_super_nested()->set_value_c(3);
+
+  auto binary_proto = msg.SerializeAsArray();
+
+  DescriptorPool pool;
+  auto status = pool.AddFromFileDescriptorSet(kTestMessagesDescriptor.data(),
+                                              kTestMessagesDescriptor.size());
+  ASSERT_TRUE(status.ok()) << "Failed to parse kTestMessagesDescriptor: "
+                           << status.message();
+
+  ProtoToArgsParser parser(pool);
+
+  parser.AddParsingOverrideForField(
+      "super_nested",
+      [](const protozero::Field&, ProtoToArgsParser::Delegate& writer) {
+        writer.AddString(ProtoToArgsParser::Key("arg"),
+                         ToChars("override-for-field"));
+        return base::OkStatus();
+      });
+
+  parser.AddParsingOverrideForType(
+      ".protozero.test.protos.NestedA.NestedB.NestedC",
+      [](ProtoToArgsParser::ScopedNestedKeyContext&,
+         const protozero::ConstBytes&, Delegate& delegate) {
+        delegate.AddString(ProtoToArgsParser::Key("arg"),
+                           ToChars("override-for-type"));
+        return base::OkStatus();
+      });
+
+  status = parser.ParseMessage(
+      protozero::ConstBytes{binary_proto.data(), binary_proto.size()},
+      ".protozero.test.protos.NestedA", nullptr, *this);
+  EXPECT_TRUE(status.ok())
+      << "InternProtoFieldsIntoArgsTable failed with error: "
+      << status.message();
+  EXPECT_THAT(args(), testing::ElementsAre("arg arg override-for-field"));
+}
+
 }  // namespace
 }  // namespace util
 }  // namespace trace_processor
 }  // namespace perfetto
diff --git a/src/tracing/traced_proto_unittest.cc b/src/tracing/traced_proto_unittest.cc
index e5c84f10b..ac5540092 100644
--- a/src/tracing/traced_proto_unittest.cc
+++ b/src/tracing/traced_proto_unittest.cc
@@ -1,25 +1,26 @@
 /*
  * Copyright (C) 2021 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 #include "perfetto/tracing/traced_proto.h"
 
+#include "perfetto/test/traced_value_test_support.h"
 #include "perfetto/tracing/track_event.h"
 #include "protos/perfetto/trace/test_event.gen.h"
 #include "protos/perfetto/trace/test_event.pb.h"
 #include "protos/perfetto/trace/test_event.pbzero.h"
 #include "protos/perfetto/trace/track_event/track_event.gen.h"
 #include "protos/perfetto/trace/track_event/track_event.pb.h"
 #include "test/gtest_and_gmock.h"
@@ -87,7 +88,10 @@ namespace {
 struct Foo {
   void WriteIntoTrace(TracedProto<TestPayload> message) const {
     message->set_single_int(42);
+
+    auto dict = std::move(message).AddDebugAnnotations();
+    dict.Add("arg", "value");
   }
 };
 
 }  // namespace
@@ -105,13 +109,30 @@ TEST_F(TracedProtoTest, SingleNestedMessage) {
 TEST_F(TracedProtoTest, RepeatedNestedMessage) {
   protozero::HeapBuffered<TestPayload> event;
   WriteIntoTracedProto(context().Wrap(event.get()), TestPayload::kNested,
                        std::vector<Foo>{Foo(), Foo()});
 
   protos::TestEvent::TestPayload result;
   result.ParseFromString(event.SerializeAsString());
   EXPECT_EQ(result.nested_size(), 2);
   EXPECT_EQ(result.nested(0).single_int(), 42);
   EXPECT_EQ(result.nested(1).single_int(), 42);
 }
 
+TEST_F(TracedProtoTest, WriteDebugAnnotations) {
+  protozero::HeapBuffered<protos::pbzero::TestEvent> event;
+  WriteIntoTracedProto(context().Wrap(event.get()),
+                       protos::pbzero::TestEvent::kPayload, Foo());
+
+  protos::TestEvent result;
+  result.ParseFromString(event.SerializeAsString());
+
+  protos::DebugAnnotation dict;
+  for (const auto& annotation : result.payload().debug_annotations()) {
+    *dict.add_dict_entries() = annotation;
+  }
+
+  EXPECT_EQ(internal::DebugAnnotationToString(dict.SerializeAsString()),
+            "{arg:value}");
+}
+
 }  // namespace perfetto
diff --git a/src/tracing/traced_value.cc b/src/tracing/traced_value.cc
index 9ac3fd241..bd8b1ade9 100644
--- a/src/tracing/traced_value.cc
+++ b/src/tracing/traced_value.cc
@@ -80,11 +80,13 @@ void TracedValue::WritePointer(const void* value) && {
 TracedDictionary TracedValue::WriteDictionary() && {
   // Note: this passes |checked_scope_.is_active_| bit to the parent to be
   // picked up later by the new TracedDictionary.
   PERFETTO_DCHECK(checked_scope_.is_active());
   checked_scope_.Reset();
 
   PERFETTO_DCHECK(!context_->is_finalized());
-  return TracedDictionary(context_, checked_scope_.parent_scope());
+  return TracedDictionary(context_,
+                          protos::pbzero::DebugAnnotation::kDictEntries,
+                          checked_scope_.parent_scope());
 }
 
 TracedArray TracedValue::WriteArray() && {
@@ -114,14 +116,16 @@ TracedArray TracedArray::AppendArray() {
 
 TracedValue TracedDictionary::AddItem(StaticString key) {
   PERFETTO_DCHECK(checked_scope_.is_active());
-  protos::pbzero::DebugAnnotation* item = context_->add_dict_entries();
+  protos::pbzero::DebugAnnotation* item =
+      message_->BeginNestedMessage<protos::pbzero::DebugAnnotation>(field_id_);
   item->set_name(key.value);
   return TracedValue(item, &checked_scope_);
 }
 
 TracedValue TracedDictionary::AddItem(DynamicString key) {
   PERFETTO_DCHECK(checked_scope_.is_active());
-  protos::pbzero::DebugAnnotation* item = context_->add_dict_entries();
+  protos::pbzero::DebugAnnotation* item =
+      message_->BeginNestedMessage<protos::pbzero::DebugAnnotation>(field_id_);
   item->set_name(key.value);
   return TracedValue(item, &checked_scope_);
 }
diff --git a/test/trace_processor/track_event/track_event_typed_args.textproto b/test/trace_processor/track_event/track_event_typed_args.textproto
index 6ff29b14b..b2d9208bb 100644
--- a/test/trace_processor/track_event/track_event_typed_args.textproto
+++ b/test/trace_processor/track_event/track_event_typed_args.textproto
@@ -42,86 +42,104 @@ packet {
   trusted_packet_sequence_id: 1
   timestamp: 3000
   track_event {
     track_uuid: 1
     categories: "cat"
     name: "name3"
     type: 3
     chrome_keyed_service {
       name: "MediaRouter"
     }
   }
 }
 packet {
   trusted_packet_sequence_id: 1
   timestamp: 4000
   track_event {
     track_uuid: 1
     categories: "cat"
     name: "name4"
     type: 3
     chrome_latency_info {
       trace_id: 7
       component_info {
         component_type: 3
         time_us: 1201
       }
       component_info {
         time_us: 928310
       }
       is_coalesced: true
     }
     [perfetto.protos.TestExtension.string_extension_for_testing]:
         "an extension string!"
     [perfetto.protos.TestExtension.int_extension_for_testing]: 42
     [perfetto.protos.TestExtension.int_extension_for_testing]: 1337
     [perfetto.protos.TestExtension.omitted_extension_for_testing]:
         "should be absent from result"
     [perfetto.protos.TestExtension.nested_message_extension_for_testing] {
       child_field_for_testing: "nesting test"
+      debug_annotations {
+        name: "arg1"
+        string_value: "value"
+      }
+      debug_annotations {
+        name: "arg2"
+        dict_entries {
+          name: "key"
+          string_value: "value"
+        }
+      }
     }
   }
 }
 packet {
   trusted_packet_sequence_id: 1
   timestamp: 5000
   extension_descriptor {
     extension_set {
       file {
         package: "perfetto.protos"
         message_type {
           extension {
             name: "string_extension_for_testing"
             extendee: ".perfetto.protos.TrackEvent"
             number: 9900
             type: TYPE_STRING
             label: LABEL_OPTIONAL
           }
           extension {
             name: "int_extension_for_testing"
             extendee: ".perfetto.protos.TrackEvent"
             number: 9901
             type: TYPE_INT32
             label: LABEL_REPEATED
           }
           extension {
             name: "nested_message_extension_for_testing"
             extendee: ".perfetto.protos.TrackEvent"
             number: 9903
             type: TYPE_MESSAGE
             label: LABEL_OPTIONAL
             type_name: ".perfetto.protos.TestExtensionChild"
           }
         }
         message_type {
           name: "TestExtensionChild"
           field {
             name: "child_field_for_testing"
             number: 1
             type: TYPE_STRING
             label: LABEL_OPTIONAL
           }
+          field {
+            name: "debug_annotations"
+            number: 99
+            type: TYPE_MESSAGE
+            label: LABEL_REPEATED
+            type_name: ".perfetto.protos.DebugAnnotation"
+          }
         }
       }
     }
   }
 }
diff --git a/test/trace_processor/track_event/track_event_typed_args_args.out b/test/trace_processor/track_event/track_event_typed_args_args.out
index ac7d60868..fae18d723 100644
--- a/test/trace_processor/track_event/track_event_typed_args_args.out
+++ b/test/trace_processor/track_event/track_event_typed_args_args.out
@@ -1,25 +1,27 @@
 "flat_key","key","int_value","string_value"
 "is_root_in_scope","is_root_in_scope",1,"[NULL]"
 "source","source","[NULL]","descriptor"
 "source_id","source_id",1,"[NULL]"
 "chrome_user_event.action","chrome_user_event.action","[NULL]","NewTab"
 "chrome_legacy_ipc.message_class","chrome_legacy_ipc.message_class","[NULL]","CLASS_AUTOMATION"
 "chrome_legacy_ipc.message_line","chrome_legacy_ipc.message_line",10,"[NULL]"
 "chrome_keyed_service.name","chrome_keyed_service.name","[NULL]","MediaRouter"
 "chrome_latency_info.component_info.component_type","chrome_latency_info.component_info[0].component_type","[NULL]","COMPONENT_INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL"
 "chrome_latency_info.component_info.time_us","chrome_latency_info.component_info[0].time_us",1201,"[NULL]"
 "chrome_latency_info.component_info.time_us","chrome_latency_info.component_info[1].time_us",928310,"[NULL]"
 "chrome_latency_info.is_coalesced","chrome_latency_info.is_coalesced",1,"[NULL]"
 "chrome_latency_info.trace_id","chrome_latency_info.trace_id",7,"[NULL]"
 "int_extension_for_testing","int_extension_for_testing[0]",42,"[NULL]"
 "int_extension_for_testing","int_extension_for_testing[1]",1337,"[NULL]"
+"nested_message_extension_for_testing.arg1","nested_message_extension_for_testing.arg1","[NULL]","value"
+"nested_message_extension_for_testing.arg2.key","nested_message_extension_for_testing.arg2.key","[NULL]","value"
 "nested_message_extension_for_testing.child_field_for_testing","nested_message_extension_for_testing.child_field_for_testing","[NULL]","nesting test"
 "string_extension_for_testing","string_extension_for_testing","[NULL]","an extension string!"
 "chrome_app_state","chrome_app_state","[NULL]","APP_STATE_FOREGROUND"
 "chrome_memory_pressure_notification.file_name","chrome_memory_pressure_notification.file_name","[NULL]","another_source.cc"
 "chrome_memory_pressure_notification.function_name","chrome_memory_pressure_notification.function_name","[NULL]","AnotherSourceFunction"
 "chrome_memory_pressure_notification.line_number","chrome_memory_pressure_notification.line_number",1337,"[NULL]"
 "source.file_name","source.file_name","[NULL]","source.cc"
 "source.function_name","source.function_name","[NULL]","SourceFunction"
 "source.line_number","source.line_number",0,"[NULL]"
 "source_location_iid","source_location_iid",1,"[NULL]"
