commit 65ac14b51a226903deb4c90779121385cb9eff30
Author: lutianxiong <lutianxiong@huawei.com>
Date:   Wed Nov 18 09:23:45 2020 +0800

    btle: Initialise acl_data to avoid wild pointer dereference
    
    Close oss-fuzz issue 25007.

diff --git a/epan/dissectors/packet-btle.c b/epan/dissectors/packet-btle.c
index afe6cbb992..30d77cc7b9 100644
--- a/epan/dissectors/packet-btle.c
+++ b/epan/dissectors/packet-btle.c
@@ -685,1301 +685,1305 @@ static gint
 dissect_btle(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)
 {
     proto_item           *btle_item;
     proto_tree           *btle_tree;
     proto_item           *sub_item;
     proto_tree           *sub_tree;
     gint                  offset = 0;
     guint32               access_address, length;
     tvbuff_t              *next_tvb;
     guint8                *dst_bd_addr;
     guint8                *src_bd_addr;
     static const guint8    broadcast_addr[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
     connection_info_t     *connection_info = NULL;
     wmem_tree_t           *wmem_tree;
     wmem_tree_key_t        key[5], ae_had_key[4];
     guint32                interface_id;
     guint32                adapter_id;
     guint32                connection_access_address;
     guint32                frame_number;
     enum {CRC_INDETERMINATE,
           CRC_CAN_BE_CALCULATED,
           CRC_INCORRECT,
           CRC_CORRECT} crc_status = CRC_INDETERMINATE;
     guint32      crc_init = 0x555555; /* default to advertising channel's value */
     guint32      packet_crc;
     const btle_context_t  *btle_context   = NULL;
     bluetooth_data_t      *bluetooth_data = NULL;
     ubertooth_data_t      *ubertooth_data = NULL;
     gint                   previous_proto;
     wmem_list_frame_t     *list_data;
     proto_item            *item;
     guint                  window_size;
     guint                  window_offset;
     guint                  data_interval;
     guint                  data_timeout;
     guint8                 btle_pdu_type = BTLE_PDU_TYPE_UNKNOWN;
 
     list_data = wmem_list_frame_prev(wmem_list_tail(pinfo->layers));
     if (list_data) {
         previous_proto = GPOINTER_TO_INT(wmem_list_frame_data(list_data));
 
         if ((previous_proto == proto_btle_rf)||(previous_proto == proto_nordic_ble)) {
             btle_context = (const btle_context_t *) data;
             bluetooth_data = btle_context->previous_protocol_data.bluetooth_data;
         } else if (previous_proto == proto_bluetooth) {
             bluetooth_data = (bluetooth_data_t *) data;
         }
 
         if (bluetooth_data && bluetooth_data->previous_protocol_data_type == BT_PD_UBERTOOTH_DATA) {
             ubertooth_data = bluetooth_data->previous_protocol_data.ubertooth_data;
         }
     }
 
     src_bd_addr = (guint8 *) wmem_alloc(pinfo->pool, 6);
     dst_bd_addr = (guint8 *) wmem_alloc(pinfo->pool, 6);
 
     if (btle_context && btle_context->crc_checked_at_capture) {
         crc_status = btle_context->crc_valid_at_capture ? CRC_CORRECT : CRC_INCORRECT;
     }
 
     col_set_str(pinfo->cinfo, COL_PROTOCOL, "LE LL");
 
     btle_item = proto_tree_add_item(tree, proto_btle, tvb, offset, -1, ENC_NA);
     btle_tree = proto_item_add_subtree(btle_item, ett_btle);
 
     sub_item = proto_tree_add_item(btle_tree, hf_access_address, tvb, offset, 4, ENC_LITTLE_ENDIAN);
     access_address = tvb_get_letohl(tvb, offset);
     if (btle_context) {
         switch(btle_context->aa_category) {
         case E_AA_MATCHED:
             expert_add_info(pinfo, sub_item, &ei_access_address_matched);
             break;
         case E_AA_ILLEGAL:
             expert_add_info(pinfo, sub_item, &ei_access_address_illegal);
             break;
         case E_AA_BIT_ERRORS:
             expert_add_info(pinfo, sub_item, &ei_access_address_bit_errors);
             break;
         default:
             break;
         }
     }
     offset += 4;
 
     if (btle_context && btle_context->phy == LE_CODED_PHY) {
         proto_tree_add_item(btle_tree, hf_coding_indicator, tvb, offset, 1, ENC_LITTLE_ENDIAN);
         offset += 1;
     }
 
     if (bluetooth_data)
         interface_id = bluetooth_data->interface_id;
     else if (pinfo->rec->presence_flags & WTAP_HAS_INTERFACE_ID)
         interface_id = pinfo->rec->rec_header.packet_header.interface_id;
     else
         interface_id = HCI_INTERFACE_DEFAULT;
 
     if (ubertooth_data)
         adapter_id = ubertooth_data->bus_id << 8 | ubertooth_data->device_address;
     else if (bluetooth_data)
         adapter_id = bluetooth_data->adapter_id;
     else
         adapter_id = HCI_ADAPTER_DEFAULT;
 
     frame_number = pinfo->num;
 
     if (btle_context) {
         btle_pdu_type = btle_context->pdu_type;
     }
 
     if (btle_pdu_type == BTLE_PDU_TYPE_UNKNOWN) {
         /* No context to provide us with physical channel pdu type, make an assumption from the access address */
         btle_pdu_type = access_address == ACCESS_ADDRESS_ADVERTISING ? BTLE_PDU_TYPE_ADVERTISING : BTLE_PDU_TYPE_DATA;
     }
 
     if (btle_pdu_type == BTLE_PDU_TYPE_ADVERTISING) {
         proto_item  *advertising_header_item;
         proto_tree  *advertising_header_tree;
         proto_item  *link_layer_data_item;
         proto_tree  *link_layer_data_tree;
         guint8       header, pdu_type;
         gboolean     ch_sel_valid = FALSE, tx_add_valid = FALSE, rx_add_valid = FALSE;
 
         if (crc_status == CRC_INDETERMINATE) {
             /* Advertising channel CRCs can aways be calculated, because CRCInit is always known. */
             crc_status = CRC_CAN_BE_CALCULATED;
         }
 
         advertising_header_item = proto_tree_add_item(btle_tree, hf_advertising_header, tvb, offset, 2, ENC_LITTLE_ENDIAN);
         advertising_header_tree = proto_item_add_subtree(advertising_header_item, ett_advertising_header);
 
         header = tvb_get_guint8(tvb, offset);
         pdu_type = header & 0x0F;
 
         switch (pdu_type) {
         case 0x00: /* ADV_IND */
             ch_sel_valid = TRUE;
             /* Fallthrough */
         case 0x02: /* ADV_NONCONN_IND */
         case 0x06: /* ADV_SCAN_IND */
         case 0x04: /* SCAN_RSP */
             tx_add_valid = TRUE;
             break;
         case 0x07: /* ADV_EXT_IND / AUX_ADV_IND / AUX_SYNC_IND / AUX_CHAIN_IND / AUX_SCAN_RSP */
         case 0x08: /* AUX_CONNECT_RSP */
         {
             /* 0 + header, 1 = len, 2 = ext_len/adv-mode, 3 = flags */
             guint8 ext_header_flags = tvb_get_guint8(tvb, offset + 3);
 
             ch_sel_valid = FALSE;
             tx_add_valid = (ext_header_flags & 0x01) != 0;
             rx_add_valid = (ext_header_flags & 0x02) != 0;
             break;
         }
         case 0x01: /* ADV_DIRECT_IND */
         case 0x05: /* CONNECT_IND or AUX_CONNECT_REQ */
             if (btle_context && btle_context->channel >= 37) {
                 /* CONNECT_IND */
                 ch_sel_valid = TRUE;
             }
             /* Fallthrough */
         case 0x03: /* SCAN_REQ or AUX_SCAN_REQ */
             tx_add_valid = TRUE;
             rx_add_valid = TRUE;
             break;
         }
 
         proto_item_append_text(advertising_header_item, " (PDU Type: %s", adv_pdu_type_str_get(btle_context, pdu_type));
         item = proto_tree_add_item(advertising_header_tree, hf_advertising_header_pdu_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
         proto_item_append_text(item, " %s", adv_pdu_type_str_get(btle_context, pdu_type));
         proto_tree_add_item(advertising_header_tree, hf_advertising_header_rfu_1, tvb, offset, 1, ENC_LITTLE_ENDIAN);
 
         if (ch_sel_valid) {
             proto_item_append_text(advertising_header_item, ", ChSel: %s",
                                    tfs_get_string(header & 0x20, &tfs_ch_sel));
             proto_tree_add_item(advertising_header_tree, hf_advertising_header_ch_sel, tvb, offset, 1, ENC_LITTLE_ENDIAN);
         } else {
             proto_tree_add_item(advertising_header_tree, hf_advertising_header_rfu_2, tvb, offset, 1, ENC_LITTLE_ENDIAN);
         }
 
         if (tx_add_valid) {
             proto_item_append_text(advertising_header_item, ", TxAdd: %s",
                                    tfs_get_string(header & 0x40, &tfs_random_public));
             proto_tree_add_item(advertising_header_tree, hf_advertising_header_randomized_tx, tvb, offset, 1, ENC_LITTLE_ENDIAN);
         } else {
             proto_tree_add_item(advertising_header_tree, hf_advertising_header_rfu_3, tvb, offset, 1, ENC_LITTLE_ENDIAN);
         }
 
         if (rx_add_valid) {
             proto_item_append_text(advertising_header_item, ", RxAdd: %s",
                                    tfs_get_string(header & 0x80, &tfs_random_public));
             proto_tree_add_item(advertising_header_tree, hf_advertising_header_randomized_rx, tvb, offset, 1, ENC_LITTLE_ENDIAN);
         } else {
             proto_tree_add_item(advertising_header_tree, hf_advertising_header_rfu_4, tvb, offset, 1, ENC_LITTLE_ENDIAN);
         }
 
         proto_item_append_text(advertising_header_item, ")");
 
         col_set_str(pinfo->cinfo, COL_INFO, adv_pdu_type_str_get(btle_context, pdu_type));
 
         offset += 1;
 
         proto_tree_add_item(advertising_header_tree, hf_advertising_header_length, tvb, offset, 1, ENC_LITTLE_ENDIAN);
         item = proto_tree_add_item_ret_uint(btle_tree, hf_length, tvb, offset, 1, ENC_LITTLE_ENDIAN, &length);
         proto_item_set_hidden(item);
         offset += 1;
 
         switch (pdu_type) {
         case 0x00: /* ADV_IND */
         case 0x02: /* ADV_NONCONN_IND */
         case 0x06: /* ADV_SCAN_IND */
             offset = dissect_bd_addr(hf_advertising_address, pinfo, btle_tree, tvb, offset, TRUE, interface_id, adapter_id, src_bd_addr);
 
             set_address(&pinfo->net_src, AT_ETHER, 6, src_bd_addr);
             copy_address_shallow(&pinfo->dl_src, &pinfo->net_src);
             copy_address_shallow(&pinfo->src, &pinfo->net_src);
 
             set_address(&pinfo->net_dst, AT_ETHER, 6, broadcast_addr);
             copy_address_shallow(&pinfo->dl_dst, &pinfo->net_dst);
             copy_address_shallow(&pinfo->dst, &pinfo->net_dst);
 
             if (!pinfo->fd->visited) {
                 address *addr;
 
                 addr = (address *) wmem_memdup(wmem_file_scope(), &pinfo->dl_src, sizeof(address));
                 addr->data =  wmem_memdup(wmem_file_scope(), pinfo->dl_src.data, pinfo->dl_src.len);
                 p_add_proto_data(wmem_file_scope(), pinfo, proto_bluetooth, BLUETOOTH_DATA_SRC, addr);
 
                 addr = (address *) wmem_memdup(wmem_file_scope(), &pinfo->dl_dst, sizeof(address));
                 addr->data =  wmem_memdup(wmem_file_scope(), pinfo->dl_dst.data, pinfo->dl_dst.len);
                 p_add_proto_data(wmem_file_scope(), pinfo, proto_bluetooth, BLUETOOTH_DATA_DST, addr);
             }
 
             if (tvb_reported_length_remaining(tvb, offset) > 3) {
                 bluetooth_eir_ad_data_t *ad_data = wmem_new0(wmem_packet_scope(), bluetooth_eir_ad_data_t);
                 ad_data->interface_id = interface_id;
                 ad_data->adapter_id = adapter_id;
                 next_tvb = tvb_new_subset_length(tvb, offset, tvb_reported_length_remaining(tvb, offset) - 3);
                 call_dissector_with_data(btcommon_ad_handle, next_tvb, pinfo, btle_tree, ad_data);
             }
 
             offset += tvb_reported_length_remaining(tvb, offset) - 3;
 
             break;
         case 0x01: /* ADV_DIRECT_IND */
             offset = dissect_bd_addr(hf_advertising_address, pinfo, btle_tree, tvb, offset, TRUE, interface_id, adapter_id, src_bd_addr);
             offset = dissect_bd_addr(hf_target_addresss, pinfo, btle_tree, tvb, offset, FALSE, interface_id, adapter_id, dst_bd_addr);
 
             set_address(&pinfo->net_src, AT_ETHER, 6, src_bd_addr);
             copy_address_shallow(&pinfo->dl_src, &pinfo->net_src);
             copy_address_shallow(&pinfo->src, &pinfo->net_src);
 
             set_address(&pinfo->net_dst, AT_ETHER, 6, dst_bd_addr);
             copy_address_shallow(&pinfo->dl_dst, &pinfo->net_dst);
             copy_address_shallow(&pinfo->dst, &pinfo->net_dst);
 
             if (!pinfo->fd->visited) {
                 address *addr;
 
                 addr = (address *) wmem_memdup(wmem_file_scope(), &pinfo->dl_src, sizeof(address));
                 addr->data =  wmem_memdup(wmem_file_scope(), pinfo->dl_src.data, pinfo->dl_src.len);
                 p_add_proto_data(wmem_file_scope(), pinfo, proto_bluetooth, BLUETOOTH_DATA_SRC, addr);
 
                 addr = (address *) wmem_memdup(wmem_file_scope(), &pinfo->dl_dst, sizeof(address));
                 addr->data =  wmem_memdup(wmem_file_scope(), pinfo->dl_dst.data, pinfo->dl_dst.len);
                 p_add_proto_data(wmem_file_scope(), pinfo, proto_bluetooth, BLUETOOTH_DATA_DST, addr);
             }
 
             break;
         case 0x03: /* SCAN_REQ */
             offset = dissect_bd_addr(hf_scanning_address, pinfo, btle_tree, tvb, offset, TRUE, interface_id, adapter_id, src_bd_addr);
             offset = dissect_bd_addr(hf_advertising_address, pinfo, btle_tree, tvb, offset, FALSE, interface_id, adapter_id, dst_bd_addr);
 
             set_address(&pinfo->net_src, AT_ETHER, 6, src_bd_addr);
             copy_address_shallow(&pinfo->dl_src, &pinfo->net_src);
             copy_address_shallow(&pinfo->src, &pinfo->net_src);
 
             set_address(&pinfo->net_dst, AT_ETHER, 6, dst_bd_addr);
             copy_address_shallow(&pinfo->dl_dst, &pinfo->net_dst);
             copy_address_shallow(&pinfo->dst, &pinfo->net_dst);
 
             if (!pinfo->fd->visited) {
                 address *addr;
 
                 addr = (address *) wmem_memdup(wmem_file_scope(), &pinfo->dl_src, sizeof(address));
                 addr->data =  wmem_memdup(wmem_file_scope(), pinfo->dl_src.data, pinfo->dl_src.len);
                 p_add_proto_data(wmem_file_scope(), pinfo, proto_bluetooth, BLUETOOTH_DATA_SRC, addr);
 
                 addr = (address *) wmem_memdup(wmem_file_scope(), &pinfo->dl_dst, sizeof(address));
                 addr->data =  wmem_memdup(wmem_file_scope(), pinfo->dl_dst.data, pinfo->dl_dst.len);
                 p_add_proto_data(wmem_file_scope(), pinfo, proto_bluetooth, BLUETOOTH_DATA_DST, addr);
             }
 
             break;
         case 0x04: /* SCAN_RSP */
             offset = dissect_bd_addr(hf_advertising_address, pinfo, btle_tree, tvb, offset, TRUE, interface_id, adapter_id, src_bd_addr);
 
             set_address(&pinfo->net_src, AT_ETHER, 6, src_bd_addr);
             copy_address_shallow(&pinfo->dl_src, &pinfo->net_src);
             copy_address_shallow(&pinfo->src, &pinfo->net_src);
 
             set_address(&pinfo->net_dst, AT_ETHER, 6, broadcast_addr);
             copy_address_shallow(&pinfo->dl_dst, &pinfo->net_dst);
             copy_address_shallow(&pinfo->dst, &pinfo->net_dst);
 
             if (!pinfo->fd->visited) {
                 address *addr;
 
                 addr = (address *) wmem_memdup(wmem_file_scope(), &pinfo->dl_src, sizeof(address));
                 addr->data =  wmem_memdup(wmem_file_scope(), pinfo->dl_src.data, pinfo->dl_src.len);
                 p_add_proto_data(wmem_file_scope(), pinfo, proto_bluetooth, BLUETOOTH_DATA_SRC, addr);
 
                 addr = (address *) wmem_memdup(wmem_file_scope(), &pinfo->dl_dst, sizeof(address));
                 addr->data =  wmem_memdup(wmem_file_scope(), pinfo->dl_dst.data, pinfo->dl_dst.len);
                 p_add_proto_data(wmem_file_scope(), pinfo, proto_bluetooth, BLUETOOTH_DATA_DST, addr);
             }
 
             sub_item = proto_tree_add_item(btle_tree, hf_scan_response_data, tvb, offset, tvb_reported_length_remaining(tvb, offset) - 3, ENC_NA);
             sub_tree = proto_item_add_subtree(sub_item, ett_scan_response_data);
 
             if (tvb_reported_length_remaining(tvb, offset) > 3) {
                 bluetooth_eir_ad_data_t *ad_data = wmem_new0(wmem_packet_scope(), bluetooth_eir_ad_data_t);
                 ad_data->interface_id = interface_id;
                 ad_data->adapter_id = adapter_id;
                 next_tvb = tvb_new_subset_length(tvb, offset, tvb_reported_length_remaining(tvb, offset) - 3);
                 call_dissector_with_data(btcommon_ad_handle, next_tvb, pinfo, sub_tree, ad_data);
             }
 
             offset += tvb_reported_length_remaining(tvb, offset) - 3;
 
             break;
         case 0x05: /* CONNECT_IND */
             offset = dissect_bd_addr(hf_initiator_addresss, pinfo, btle_tree, tvb, offset, FALSE, interface_id, adapter_id, src_bd_addr);
             offset = dissect_bd_addr(hf_advertising_address, pinfo, btle_tree, tvb, offset, TRUE, interface_id, adapter_id, dst_bd_addr);
 
             set_address(&pinfo->net_src, AT_ETHER, 6, src_bd_addr);
             copy_address_shallow(&pinfo->dl_src, &pinfo->net_src);
             copy_address_shallow(&pinfo->src, &pinfo->net_src);
 
             set_address(&pinfo->net_dst, AT_ETHER, 6, dst_bd_addr);
             copy_address_shallow(&pinfo->dl_dst, &pinfo->net_dst);
             copy_address_shallow(&pinfo->dst, &pinfo->net_dst);
 
             if (!pinfo->fd->visited) {
                 address *addr;
 
                 addr = (address *) wmem_memdup(wmem_file_scope(), &pinfo->dl_src, sizeof(address));
                 addr->data =  wmem_memdup(wmem_file_scope(), pinfo->dl_src.data, pinfo->dl_src.len);
                 p_add_proto_data(wmem_file_scope(), pinfo, proto_bluetooth, BLUETOOTH_DATA_SRC, addr);
 
                 addr = (address *) wmem_memdup(wmem_file_scope(), &pinfo->dl_dst, sizeof(address));
                 addr->data =  wmem_memdup(wmem_file_scope(), pinfo->dl_dst.data, pinfo->dl_dst.len);
                 p_add_proto_data(wmem_file_scope(), pinfo, proto_bluetooth, BLUETOOTH_DATA_DST, addr);
             }
 
             link_layer_data_item = proto_tree_add_item(btle_tree, hf_link_layer_data, tvb, offset, 22, ENC_NA);
             link_layer_data_tree = proto_item_add_subtree(link_layer_data_item, ett_link_layer_data);
 
             proto_tree_add_item(link_layer_data_tree, hf_link_layer_data_access_address, tvb, offset, 4, ENC_LITTLE_ENDIAN);
             connection_access_address = tvb_get_letohl(tvb, offset);
             offset += 4;
 
             proto_tree_add_item(link_layer_data_tree, hf_link_layer_data_crc_init, tvb, offset, 3, ENC_LITTLE_ENDIAN);
             offset += 3;
 
             item = proto_tree_add_item_ret_uint(link_layer_data_tree, hf_link_layer_data_window_size, tvb, offset, 1, ENC_LITTLE_ENDIAN, &window_size);
             proto_item_append_text(item, " (%g msec)", window_size*1.25);
             offset += 1;
 
             item = proto_tree_add_item_ret_uint(link_layer_data_tree, hf_link_layer_data_window_offset, tvb, offset, 2, ENC_LITTLE_ENDIAN, &window_offset);
             proto_item_append_text(item, " (%g msec)", window_offset*1.25);
             offset += 2;
 
             item = proto_tree_add_item_ret_uint(link_layer_data_tree, hf_link_layer_data_interval, tvb, offset, 2, ENC_LITTLE_ENDIAN, &data_interval);
             proto_item_append_text(item, " (%g msec)", data_interval*1.25);
             offset += 2;
 
             proto_tree_add_item(link_layer_data_tree, hf_link_layer_data_latency, tvb, offset, 2, ENC_LITTLE_ENDIAN);
             offset += 2;
 
             item = proto_tree_add_item_ret_uint(link_layer_data_tree, hf_link_layer_data_timeout, tvb, offset, 2, ENC_LITTLE_ENDIAN, &data_timeout);
             proto_item_append_text(item, " (%u msec)", data_timeout*10);
             offset += 2;
 
             sub_item = proto_tree_add_item(link_layer_data_tree, hf_link_layer_data_channel_map, tvb, offset, 5, ENC_NA);
             sub_tree = proto_item_add_subtree(sub_item, ett_channel_map);
 
             call_dissector(btcommon_le_channel_map_handle, tvb_new_subset_length(tvb, offset, 5), pinfo, sub_tree);
             offset += 5;
 
             proto_tree_add_item(link_layer_data_tree, hf_link_layer_data_hop, tvb, offset, 1, ENC_LITTLE_ENDIAN);
             proto_tree_add_item(link_layer_data_tree, hf_link_layer_data_sleep_clock_accuracy, tvb, offset, 1, ENC_LITTLE_ENDIAN);
             offset += 1;
 
             if (!pinfo->fd->visited) {
                 key[0].length = 1;
                 key[0].key = &interface_id;
                 key[1].length = 1;
                 key[1].key = &adapter_id;
                 key[2].length = 1;
                 key[2].key = &connection_access_address;
                 key[3].length = 1;
                 key[3].key = &frame_number;
                 key[4].length = 0;
                 key[4].key = NULL;
 
                 connection_info = wmem_new0(wmem_file_scope(), connection_info_t);
                 connection_info->interface_id   = interface_id;
                 connection_info->adapter_id     = adapter_id;
                 connection_info->access_address = connection_access_address;
 
                 memcpy(connection_info->master_bd_addr, src_bd_addr, 6);
                 memcpy(connection_info->slave_bd_addr,  dst_bd_addr, 6);
 
                 wmem_tree_insert32_array(connection_info_tree, key, connection_info);
             }
 
             break;
         case 0x07: /* ADV_EXT_IND / AUX_ADV_IND / AUX_SYNC_IND / AUX_CHAIN_IND / AUX_SCAN_RSP */
         case 0x08: /* AUX_CONNNECT_RSP */
         {
             guint8 tmp, ext_header_len, flags, acad_len;
             proto_item  *ext_header_item, *ext_flags_item;
             proto_tree  *ext_header_tree, *ext_flags_tree;
             guint32 adi;
             gboolean adi_present = FALSE;
             gboolean aux_pointer_present = FALSE;
 
             tmp = tvb_get_guint8(tvb, offset);
             ext_header_len = acad_len = tmp & 0x3F;
 
             ext_header_item = proto_tree_add_item(btle_tree, hf_extended_advertising_header, tvb, offset, ext_header_len + 1, ENC_NA);
             ext_header_tree = proto_item_add_subtree(ext_header_item, ett_extended_advertising_header);
 
             proto_tree_add_item(ext_header_tree, hf_extended_advertising_header_length, tvb, offset, 1, ENC_LITTLE_ENDIAN);
             proto_tree_add_item(ext_header_tree, hf_extended_advertising_mode, tvb, offset, 1, ENC_LITTLE_ENDIAN);
             offset += 1;
 
             ext_flags_item = proto_tree_add_item(ext_header_tree, hf_extended_advertising_flags, tvb, offset, 1, ENC_NA);
             ext_flags_tree = proto_item_add_subtree(ext_flags_item, ett_extended_advertising_flags);
 
             proto_tree_add_bitmask_list(ext_flags_tree, tvb, offset, 1, hfx_extended_advertising_flags, ENC_NA);
             flags = tvb_get_guint8(tvb, offset);
             offset += 1;
 
             acad_len -= 1;
 
             if (flags & 0x01) {
                 /* Advertiser Address */
                 offset = dissect_bd_addr(hf_advertising_address, pinfo, ext_header_tree, tvb, offset, TRUE, interface_id, adapter_id, src_bd_addr);
                 set_address(&pinfo->net_src, AT_ETHER, 6, src_bd_addr);
                 copy_address_shallow(&pinfo->dl_src, &pinfo->net_src);
                 copy_address_shallow(&pinfo->src, &pinfo->net_src);
 
                 acad_len -= 6;
             } else {
                 const char * anon_str = "Anonymous";
                 clear_address(&pinfo->dl_src);
                 set_address(&pinfo->net_src, AT_STRINGZ, sizeof(*anon_str), anon_str);
                 copy_address_shallow(&pinfo->src, &pinfo->net_src);
             }
 
             if (flags & 0x02) {
                 /* Target Address */
                 offset = dissect_bd_addr(hf_target_addresss, pinfo, ext_header_tree, tvb, offset, FALSE, interface_id, adapter_id, dst_bd_addr);
                 set_address(&pinfo->net_dst, AT_ETHER, 6, dst_bd_addr);
                 copy_address_shallow(&pinfo->dl_dst, &pinfo->net_dst);
                 copy_address_shallow(&pinfo->dst, &pinfo->net_dst);
 
                 acad_len -= 6;
             } else {
                 set_address(&pinfo->net_dst, AT_ETHER, 6, broadcast_addr);
                 copy_address_shallow(&pinfo->dl_dst, &pinfo->net_dst);
                 copy_address_shallow(&pinfo->dst, &pinfo->net_dst);
             }
 
             if (flags & 0x04) {
                 guint32 cte_time;
 
                 /* CTE Info */
                 sub_item = proto_tree_add_item(ext_header_tree, hf_extended_advertising_cte_info, tvb, offset, 1, ENC_NA);
                 sub_tree = proto_item_add_subtree(sub_item, ett_extended_advertising_cte_info);
 
                 proto_tree_add_item(sub_tree, hf_extended_advertising_cte_info_time, tvb, offset, 1, ENC_LITTLE_ENDIAN);
                 proto_tree_add_item(sub_tree, hf_extended_advertising_cte_info_rfu, tvb, offset, 1, ENC_LITTLE_ENDIAN);
                 proto_tree_add_item(sub_tree, hf_extended_advertising_cte_info_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
                 item = proto_tree_add_item_ret_uint(sub_tree, hf_extended_advertising_cte_info_time, tvb, offset, 1, ENC_LITTLE_ENDIAN, &cte_time);
                 proto_item_append_text(item, " (%u usec)", cte_time * 8);
                 offset += 1;
 
                 acad_len -= 1;
             }
 
             if (flags & 0x08) {
                 /* AdvDataInfo */
                 sub_item = proto_tree_add_item_ret_uint(ext_header_tree, hf_extended_advertising_data_info, tvb, offset, 2, ENC_LITTLE_ENDIAN, &adi);
                 sub_tree = proto_item_add_subtree(sub_item, ett_extended_advertising_data_info);
 
                 proto_tree_add_item(sub_tree, hf_extended_advertising_data_info_did, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 proto_tree_add_item(sub_tree, hf_extended_advertising_data_info_sid, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 offset += 2;
                 adi_present = TRUE;
 
                 acad_len -= 2;
             }
 
             if (flags & 0x10) {
                 guint32 aux_offset;
 
                 /* Aux Pointer */
                 sub_item = proto_tree_add_item(ext_header_tree, hf_extended_advertising_aux_ptr, tvb, offset, 3, ENC_NA);
                 sub_tree = proto_item_add_subtree(sub_item, ett_extended_advertising_aux_pointer);
 
                 proto_tree_add_item(sub_tree, hf_extended_advertising_aux_ptr_channel, tvb, offset, 1, ENC_LITTLE_ENDIAN);
                 proto_tree_add_item(sub_tree, hf_extended_advertising_aux_ptr_ca, tvb, offset, 1, ENC_LITTLE_ENDIAN);
                 proto_tree_add_item(sub_tree, hf_extended_advertising_aux_ptr_offset_units, tvb, offset, 1, ENC_LITTLE_ENDIAN);
                 tmp = tvb_get_guint8(tvb, offset);
                 offset += 1;
 
                 item = proto_tree_add_item_ret_uint(sub_tree, hf_extended_advertising_aux_ptr_aux_offset, tvb, offset, 2, ENC_LITTLE_ENDIAN, &aux_offset);
                 proto_tree_add_item(sub_tree, hf_extended_advertising_aux_ptr_aux_phy, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 proto_item_append_text(item, " (%u usec)", aux_offset * ((tmp & 0x80) != 0 ? 300 : 30));
                 offset += 2;
                 aux_pointer_present = TRUE;
 
                 acad_len -= 3;
             }
 
             if (flags & 0x20) {
                 guint32 sync_offset, interval;
                 proto_item  *sync_info_item;
                 proto_tree  *sync_info_tree;
                 gint reserved_offset;
                 guint16 sf;
 
                 /* Sync Info */
                 sync_info_item = proto_tree_add_item(ext_header_tree, hf_extended_advertising_sync_info, tvb, offset, 1, ENC_NA);
                 sync_info_tree = proto_item_add_subtree(sync_info_item, ett_extended_advertising_sync_info);
 
                 sf = tvb_get_guint16(tvb, offset, ENC_LITTLE_ENDIAN);
 
                 item = proto_tree_add_item_ret_uint(sync_info_tree, hf_extended_advertising_sync_info_offset, tvb, offset, 2, ENC_LITTLE_ENDIAN, &sync_offset);
                 proto_tree_add_item(sync_info_tree, hf_extended_advertising_sync_info_offset_units, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 proto_tree_add_item(sync_info_tree, hf_extended_advertising_sync_info_offset_adjust, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 proto_tree_add_item(sync_info_tree, hf_extended_advertising_sync_info_reserved, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 if (sync_offset > 0) {
                     proto_item_append_text(item, " (%u usec)", sync_offset * ((sf & 0x2000) != 0 ? 300 : 30) + ((sf & 0x4000) != 0 ? 2457600 : 0));
                 } else {
                     proto_item_append_text(item, " Cannot be represented");
                 }
                 offset += 2;
 
                 item = proto_tree_add_item_ret_uint(sync_info_tree, hf_extended_advertising_sync_info_interval, tvb, offset, 2, ENC_LITTLE_ENDIAN, &interval);
                 proto_item_append_text(item, " (%g msec)", interval * 1.25);
                 offset += 2;
 
                 sub_item = proto_tree_add_item(sync_info_tree, hf_extended_advertising_sync_info_channel_map, tvb, offset, 5, ENC_NA);
                 sub_tree = proto_item_add_subtree(sub_item, ett_channel_map);
 
                 call_dissector_with_data(btcommon_le_channel_map_handle, tvb_new_subset_length(tvb, offset, 5), pinfo, sub_tree, &reserved_offset);
                 proto_tree_add_item(sync_info_tree, hf_extended_advertising_sync_info_sleep_clock_accuracy, tvb, reserved_offset, 1, ENC_LITTLE_ENDIAN);
                 offset += 5;
 
                 proto_tree_add_item(sync_info_tree, hf_extended_advertising_sync_info_access_address, tvb, offset, 4, ENC_LITTLE_ENDIAN);
                 offset += 4;
 
                 proto_tree_add_item(sync_info_tree, hf_extended_advertising_sync_info_crc_init, tvb, offset, 3, ENC_LITTLE_ENDIAN);
                 offset += 3;
 
                 proto_tree_add_item(sync_info_tree, hf_extended_advertising_sync_info_event_counter, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 offset += 2;
 
                 acad_len -= 18;
             }
 
             if (flags & 0x40) {
                 /* Tx Power */
                 proto_tree_add_item(ext_header_tree, hf_extended_advertising_tx_power, tvb, offset, 1, ENC_LITTLE_ENDIAN);
                 offset += 1;
 
                 acad_len -= 1;
             }
 
             if (acad_len > 0) {
                 sub_item = proto_tree_add_item(ext_header_tree, hf_extended_advertising_header_acad, tvb, offset, acad_len, ENC_NA);
                 sub_tree = proto_item_add_subtree(sub_item, ett_extended_advertising_acad);
 
                 /* Additional Controller Advertising Data */
                 bluetooth_eir_ad_data_t *ad_data = wmem_new0(wmem_packet_scope(), bluetooth_eir_ad_data_t);
                 ad_data->interface_id = interface_id;
                 ad_data->adapter_id = adapter_id;
                 next_tvb = tvb_new_subset_length(tvb, offset, acad_len);
                 call_dissector_with_data(btcommon_ad_handle, next_tvb, pinfo, sub_tree, ad_data);
 
                 offset += acad_len;
             }
             if (tvb_reported_length_remaining(tvb, offset) > 3) {
                 gboolean ad_processed = FALSE;
                 if (btle_context && pdu_type == 0x07 && btle_context->aux_pdu_type_valid) {
                     gboolean ad_reassembled = FALSE;
                     ae_had_info_t *ae_had_info = NULL;
 
                     switch (btle_context->aux_pdu_type) {
                         case 0x00:  /* AUX_ADV_IND */
                         case 0x02:  /* AUX_SYNC_IND */
                         case 0x03:  /* AUX_SCAN_RSP */
                             if (aux_pointer_present) {
                                 /* Begining of new sequence of fragments */
                                 if (!pinfo->fd->visited && adi_present) {
                                     ae_had_info = wmem_new0(wmem_file_scope(), ae_had_info_t);
                                     ae_had_info->first_frame_num=pinfo->num;
 
                                     ae_had_key[0].length = 1;
                                     ae_had_key[0].key = &interface_id;
                                     ae_had_key[1].length = 1;
                                     ae_had_key[1].key = &adapter_id;
                                     ae_had_key[2].length = 1;
                                     ae_had_key[2].key = &adi;
                                     ae_had_key[3].length = 0;
                                     ae_had_key[3].key = NULL;
 
                                     wmem_tree_insert32_array(adi_to_first_frame_tree, ae_had_key, ae_had_info);
 
                                     fragment_add_seq(&btle_ea_host_advertising_data_reassembly_table,
                                         tvb, offset, pinfo,
                                         ae_had_info->first_frame_num, NULL,
                                         ae_had_info->fragment_counter,
                                         tvb_captured_length_remaining(tvb, offset) - 3,
                                         !ad_reassembled, 0);
 
                                     ae_had_info->fragment_counter++;
                                 }
                                 ad_processed = TRUE;
                             }
                             break;
                         case 0x01:  /* AUX_CHAIN_IND */
                             if (!aux_pointer_present) {
                                 /* Final fragment */
                                 ad_reassembled = TRUE;
                             }
                             if (!pinfo->fd->visited && adi_present) {
 
                                 ae_had_key[0].length = 1;
                                 ae_had_key[0].key = &interface_id;
                                 ae_had_key[1].length = 1;
                                 ae_had_key[1].key = &adapter_id;
                                 ae_had_key[2].length = 1;
                                 ae_had_key[2].key = &adi;
                                 ae_had_key[3].length = 0;
                                 ae_had_key[3].key = NULL;
 
                                 ae_had_info = (ae_had_info_t *) wmem_tree_lookup32_array(adi_to_first_frame_tree, ae_had_key);
 
                                 if (ae_had_info != NULL) {
                                     fragment_add_seq(&btle_ea_host_advertising_data_reassembly_table,
                                         tvb, offset, pinfo,
                                         ae_had_info->first_frame_num, NULL,
                                         ae_had_info->fragment_counter,
                                         tvb_captured_length_remaining(tvb, offset) - 3,
                                         !ad_reassembled, 0);
 
                                     ae_had_info->fragment_counter++;
                                     if (ad_reassembled == TRUE) {
                                         p_add_proto_data(wmem_file_scope(), pinfo, proto_btle, (guint32)(pinfo->curr_layer_num) << 8, ae_had_info);
                                     }
                                 }
                             }
                             ad_processed = TRUE;
                             break;
                         default:
                             /* This field is 2 bits long, no special action needed */
                             break;
                     }
                     if (ad_processed) {
                         if (pinfo->fd->visited) {
                             /* Host Advertising Data fragment */
                             proto_tree_add_item(btle_tree, hf_extended_advertising_had_fragment, tvb, offset, tvb_captured_length_remaining(tvb, offset) - 3, ENC_NA);
                             if (ad_reassembled) {
                                 fragment_head *fd_head = NULL;
                                 tvbuff_t *assembled_tvb = NULL;
 
                                 ae_had_info = (ae_had_info_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_btle, (guint32)(pinfo->curr_layer_num) << 8);
                                 if (ae_had_info != NULL) {
                                     col_append_str(pinfo->cinfo, COL_INFO, " (EA HAD Reassembled)");
 
                                     fd_head = fragment_get(&btle_ea_host_advertising_data_reassembly_table, pinfo, ae_had_info->first_frame_num, NULL);
                                     assembled_tvb = process_reassembled_data(
                                         tvb, offset, pinfo,
                                         "Reassembled Host Advertising Data", fd_head,
                                         &btle_ea_host_advertising_data_frag_items,
                                         NULL, btle_tree);
                                     bluetooth_eir_ad_data_t *ad_data = wmem_new0(wmem_packet_scope(), bluetooth_eir_ad_data_t);
                                     ad_data->interface_id = interface_id;
                                     ad_data->adapter_id = adapter_id;
                                     call_dissector_with_data(btcommon_ad_handle, assembled_tvb, pinfo, btle_tree, ad_data);
                                 }
                             }
                             else {
                                 col_append_str(pinfo->cinfo, COL_INFO, " (EA HAD Fragment)");
                             }
                             offset += tvb_captured_length_remaining(tvb, offset) - 3;
                         }
                     }
                 }
 
                 if (tvb_reported_length_remaining(tvb, offset) > 3) {
                     /* Host Advertising Data */
                     bluetooth_eir_ad_data_t *ad_data = wmem_new0(wmem_packet_scope(), bluetooth_eir_ad_data_t);
                     ad_data->interface_id = interface_id;
                     ad_data->adapter_id = adapter_id;
                     next_tvb = tvb_new_subset_length(tvb, offset, tvb_reported_length_remaining(tvb, offset) - 3);
 
                     if (btle_context && btle_context->aux_pdu_type_valid && btle_context->aux_pdu_type == 3) {
                         /* AUX_SCAN_RSP */
                         sub_item = proto_tree_add_item(btle_tree, hf_scan_response_data, tvb, offset, tvb_reported_length_remaining(tvb, offset) - 3, ENC_NA);
                         sub_tree = proto_item_add_subtree(sub_item, ett_scan_response_data);
 
                         call_dissector_with_data(btcommon_ad_handle, next_tvb, pinfo, sub_tree, ad_data);
                     }
                     else {
                         call_dissector_with_data(btcommon_ad_handle, next_tvb, pinfo, btle_tree, ad_data);
                     }
 
                     offset += tvb_reported_length_remaining(tvb, offset) - 3;
                 }
             }
             break;
         }
         default:
             if (tvb_reported_length_remaining(tvb, offset) > 3) {
                 proto_tree_add_expert(btle_tree, pinfo, &ei_unknown_data, tvb, offset, tvb_reported_length_remaining(tvb, offset) - 3);
                 offset += tvb_reported_length_remaining(tvb, offset) - 3;
             }
         }
     } else if (btle_pdu_type == BTLE_PDU_TYPE_DATA) {
         proto_item  *data_header_item, *seq_item;
         proto_tree  *data_header_tree;
         guint8       oct;
         guint8       llid;
         guint8       control_opcode;
         guint32      direction = BTLE_DIR_UNKNOWN;
         gboolean     add_l2cap_index = FALSE;
         gboolean     retransmit = FALSE;
 
         if (btle_context) {
             direction = btle_context->direction;
         }
 
         btle_frame_info_t *btle_frame_info = NULL;
         fragment_head *frag_btl2cap_msg = NULL;
         btle_frame_info_t empty_btle_frame_info = {0, 0, 0, 0};
 
         key[0].length = 1;
         key[0].key = &interface_id;
         key[1].length = 1;
         key[1].key = &adapter_id;
         key[2].length = 1;
         key[2].key = &access_address;
         key[3].length = 0;
         key[3].key = NULL;
 
         oct = tvb_get_guint8(tvb, offset);
         wmem_tree = (wmem_tree_t *) wmem_tree_lookup32_array(connection_info_tree, key);
         if (wmem_tree) {
             connection_info = (connection_info_t *) wmem_tree_lookup32_le(wmem_tree, pinfo->num);
             if (connection_info) {
                 gchar  *str_addr_src, *str_addr_dst;
                 /* Holds "unknown" + access_address + NULL, which is the longest string */
                 int     str_addr_len = 18 + 1;
 
                 str_addr_src = (gchar *) wmem_alloc(pinfo->pool, str_addr_len);
                 str_addr_dst = (gchar *) wmem_alloc(pinfo->pool, str_addr_len);
 
                 sub_item = proto_tree_add_ether(btle_tree, hf_master_bd_addr, tvb, 0, 0, connection_info->master_bd_addr);
                 proto_item_set_generated(sub_item);
 
                 sub_item = proto_tree_add_ether(btle_tree, hf_slave_bd_addr, tvb, 0, 0, connection_info->slave_bd_addr);
                 proto_item_set_generated(sub_item);
 
                 switch (direction) {
                 case BTLE_DIR_MASTER_SLAVE:
                     g_snprintf(str_addr_src, str_addr_len, "Master_0x%08x", connection_info->access_address);
                     g_snprintf(str_addr_dst, str_addr_len, "Slave_0x%08x", connection_info->access_address);
                     set_address(&pinfo->dl_src, AT_ETHER, sizeof(connection_info->master_bd_addr), connection_info->master_bd_addr);
                     set_address(&pinfo->dl_dst, AT_ETHER, sizeof(connection_info->slave_bd_addr), connection_info->slave_bd_addr);
                     break;
                 case BTLE_DIR_SLAVE_MASTER:
                     g_snprintf(str_addr_src, str_addr_len, "Slave_0x%08x", connection_info->access_address);
                     g_snprintf(str_addr_dst, str_addr_len, "Master_0x%08x", connection_info->access_address);
                     set_address(&pinfo->dl_src, AT_ETHER, sizeof(connection_info->slave_bd_addr), connection_info->slave_bd_addr);
                     set_address(&pinfo->dl_dst, AT_ETHER, sizeof(connection_info->master_bd_addr), connection_info->master_bd_addr);
                     break;
                 default:
                     /* BTLE_DIR_UNKNOWN */
                     g_snprintf(str_addr_src, str_addr_len, "Unknown_0x%08x", connection_info->access_address);
                     g_snprintf(str_addr_dst, str_addr_len, "Unknown_0x%08x", connection_info->access_address);
                     clear_address(&pinfo->dl_src);
                     clear_address(&pinfo->dl_dst);
                     break;
                 }
 
                 set_address(&pinfo->net_src, AT_STRINGZ, (int)strlen(str_addr_src)+1, str_addr_src);
                 copy_address_shallow(&pinfo->src, &pinfo->net_src);
 
                 set_address(&pinfo->net_dst, AT_STRINGZ, (int)strlen(str_addr_dst)+1, str_addr_dst);
                 copy_address_shallow(&pinfo->dst, &pinfo->net_dst);
 
                 if (!pinfo->fd->visited) {
                     address *addr;
 
                     btle_frame_info = wmem_new0(wmem_file_scope(), btle_frame_info_t);
                     btle_frame_info->l2cap_index = connection_info->direction_info[direction].l2cap_index;
 
                     addr = (address *) wmem_memdup(wmem_file_scope(), &pinfo->dl_src, sizeof(address));
                     addr->data =  wmem_memdup(wmem_file_scope(), pinfo->dl_src.data, pinfo->dl_src.len);
                     p_add_proto_data(wmem_file_scope(), pinfo, proto_bluetooth, BLUETOOTH_DATA_SRC, addr);
 
                     addr = (address *) wmem_memdup(wmem_file_scope(), &pinfo->dl_dst, sizeof(address));
                     addr->data =  wmem_memdup(wmem_file_scope(), pinfo->dl_dst.data, pinfo->dl_dst.len);
                     p_add_proto_data(wmem_file_scope(), pinfo, proto_bluetooth, BLUETOOTH_DATA_DST, addr);
 
                     if (!connection_info->first_data_frame_seen) {
                         connection_info->first_data_frame_seen = 1;
                         btle_frame_info->retransmit = 0;
                         connection_info->direction_info[BTLE_DIR_MASTER_SLAVE].prev_seq_num = 0;
                         connection_info->direction_info[BTLE_DIR_SLAVE_MASTER].prev_seq_num = 1;
                     }
                     else {
                         guint8 seq_num = !!(oct & 0x8);
 
                         if (seq_num != connection_info->direction_info[direction].prev_seq_num) {
                             /* SN is not equal to previous packet (in same direction) SN */
                             btle_frame_info->retransmit = 0;
                         }
                         else {
                             btle_frame_info->retransmit = 1;
                         }
                         connection_info->direction_info[direction].prev_seq_num = seq_num;
                     }
                     p_add_proto_data(wmem_file_scope(), pinfo, proto_btle, pinfo->curr_layer_num, btle_frame_info);
                 }
                 else {
                     /* Not the first pass */
                     btle_frame_info = (btle_frame_info_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_btle, pinfo->curr_layer_num);
                 }
             }
         }
 
         if (btle_frame_info == NULL) {
             btle_frame_info = &empty_btle_frame_info;
         }
         data_header_item = proto_tree_add_item(btle_tree, hf_data_header, tvb, offset, 2, ENC_LITTLE_ENDIAN);
         data_header_tree = proto_item_add_subtree(data_header_item, ett_data_header);
 
         proto_tree_add_item(data_header_tree, hf_data_header_llid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
         proto_tree_add_item(data_header_tree, hf_data_header_next_expected_sequence_number, tvb, offset, 1, ENC_LITTLE_ENDIAN);
         seq_item = proto_tree_add_item(data_header_tree, hf_data_header_sequence_number, tvb, offset, 1, ENC_LITTLE_ENDIAN);
 
         if (direction != BTLE_DIR_UNKNOWN) {
             /* Unable to check valid SN or retransmission without direction */
             if (btle_frame_info->retransmit == 0) {
                 proto_item_append_text(seq_item, " [OK]");
             }
             else {
                 proto_item_append_text(seq_item, " [Wrong]");
                 if (btle_detect_retransmit) {
                     expert_add_info(pinfo, seq_item, &ei_retransmit);
                     retransmit = TRUE;
                 }
             }
         }
 
         proto_tree_add_item(data_header_tree, hf_data_header_more_data, tvb, offset, 1, ENC_LITTLE_ENDIAN);
         proto_tree_add_item(data_header_tree, hf_data_header_rfu, tvb, offset, 1, ENC_LITTLE_ENDIAN);
         llid = tvb_get_guint8(tvb, offset) & 0x03;
         offset += 1;
 
         proto_tree_add_item(data_header_tree, hf_data_header_length, tvb, offset, 1, ENC_LITTLE_ENDIAN);
         item = proto_tree_add_item_ret_uint(btle_tree, hf_length, tvb, offset, 1, ENC_LITTLE_ENDIAN, &length);
         proto_item_set_hidden(item);
         offset += 1;
 
         switch (llid) {
         case 0x01: /* Continuation fragment of an L2CAP message, or an Empty PDU */
             if (length > 0) {
                 tvbuff_t *new_tvb = NULL;
 
                 pinfo->fragmented = TRUE;
                 if (connection_info && !retransmit) {
                     if (!pinfo->fd->visited) {
                         if (connection_info->direction_info[direction].segmentation_started == 1) {
                             if (connection_info->direction_info[direction].segment_len_rem >= length) {
                                 connection_info->direction_info[direction].segment_len_rem = connection_info->direction_info[direction].segment_len_rem - length;
                             } else {
                                 /*
                                  * Missing fragment for previous L2CAP and fragment start for this.
                                  * Increase l2cap_index.
                                  */
                                 btle_frame_info->missing_start = 1;
                                 btle_frame_info->l2cap_index = l2cap_index;
                                 l2cap_index++;
                             }
                             if (connection_info->direction_info[direction].segment_len_rem > 0) {
                                 btle_frame_info->more_fragments = 1;
                             }
                             else {
                                 btle_frame_info->more_fragments = 0;
                                 connection_info->direction_info[direction].segmentation_started = 0;
                                 connection_info->direction_info[direction].segment_len_rem = 0;
                             }
                         } else {
                             /*
                              * Missing fragment start.
                              * Set more_fragments and increase l2cap_index to avoid reassembly.
                              */
                             btle_frame_info->more_fragments = 1;
                             btle_frame_info->missing_start = 1;
                             btle_frame_info->l2cap_index = l2cap_index;
                             l2cap_index++;
                         }
                     }
 
                     add_l2cap_index = TRUE;
 
                     frag_btl2cap_msg = fragment_add_seq_next(&btle_l2cap_msg_reassembly_table,
                         tvb, offset,
                         pinfo,
                         btle_frame_info->l2cap_index,      /* guint32 ID for fragments belonging together */
                         NULL,                              /* data* */
                         length,                            /* Fragment length */
                         btle_frame_info->more_fragments);  /* More fragments */
 
                     new_tvb = process_reassembled_data(tvb, offset, pinfo,
                         "Reassembled L2CAP",
                         frag_btl2cap_msg,
                         &btle_l2cap_msg_frag_items,
                         NULL,
                         btle_tree);
                 }
 
                 if (new_tvb) {
                     bthci_acl_data_t  *acl_data;
 
                     col_set_str(pinfo->cinfo, COL_INFO, "L2CAP Data");
 
                     acl_data = wmem_new(wmem_packet_scope(), bthci_acl_data_t);
                     acl_data->interface_id = interface_id;
                     acl_data->adapter_id = adapter_id;
                     acl_data->chandle = 0; /* No connection handle at this layer */
                     acl_data->remote_bd_addr_oui = 0;
                     acl_data->remote_bd_addr_id = 0;
                     acl_data->is_btle = TRUE;
                     acl_data->is_btle_retransmit = retransmit;
+                    acl_data->adapter_disconnect_in_frame = &max_disconnect_in_frame;
+                    acl_data->disconnect_in_frame = &max_disconnect_in_frame;
 
                     next_tvb = tvb_new_subset_length(tvb, offset, length);
                     if (next_tvb) {
                         call_dissector_with_data(btl2cap_handle, new_tvb, pinfo, tree, acl_data);
                     }
                     offset += length;
                 }
                 else {
                     col_set_str(pinfo->cinfo, COL_INFO, "L2CAP Fragment");
                     item = proto_tree_add_item(btle_tree, hf_l2cap_fragment, tvb, offset, length, ENC_NA);
                     if (btle_frame_info->missing_start) {
                         expert_add_info(pinfo, item, &ei_missing_fragment_start);
                     }
                     offset += length;
                 }
             } else {
                 col_set_str(pinfo->cinfo, COL_INFO, "Empty PDU");
             }
 
             break;
         case 0x02: /* Start of an L2CAP message or a complete L2CAP message with no fragmentation */
             if (length > 0) {
                 guint l2cap_len = tvb_get_letohs(tvb, offset);
                 if (l2cap_len + 4 > length) { /* L2CAP PDU Length excludes the 4 octets header */
                     pinfo->fragmented = TRUE;
                     if (connection_info && !retransmit) {
                         if (!pinfo->fd->visited) {
                             connection_info->direction_info[direction].segmentation_started = 1;
                             /* The first two octets in the L2CAP PDU contain the length of the entire
                              * L2CAP PDU in octets, excluding the Length and CID fields(4 octets).
                              */
                             connection_info->direction_info[direction].segment_len_rem = l2cap_len + 4 - length;
                             connection_info->direction_info[direction].l2cap_index = l2cap_index;
                             btle_frame_info->more_fragments = 1;
                             btle_frame_info->l2cap_index = l2cap_index;
                             l2cap_index++;
                         }
 
                         add_l2cap_index = TRUE;
 
                         frag_btl2cap_msg = fragment_add_seq_next(&btle_l2cap_msg_reassembly_table,
                             tvb, offset,
                             pinfo,
                             btle_frame_info->l2cap_index,      /* guint32 ID for fragments belonging together */
                             NULL,                              /* data* */
                             length,                            /* Fragment length */
                             btle_frame_info->more_fragments);  /* More fragments */
 
                         process_reassembled_data(tvb, offset, pinfo,
                             "Reassembled L2CAP",
                             frag_btl2cap_msg,
                             &btle_l2cap_msg_frag_items,
                             NULL,
                             btle_tree);
                     }
 
                     col_set_str(pinfo->cinfo, COL_INFO, "L2CAP Fragment Start");
                     proto_tree_add_item(btle_tree, hf_l2cap_fragment, tvb, offset, length, ENC_NA);
                     offset += length;
                 } else {
                     bthci_acl_data_t  *acl_data;
                     if (connection_info) {
                         /* Add a L2CAP index for completeness */
                         if (!pinfo->fd->visited) {
                             btle_frame_info->l2cap_index = l2cap_index;
                             l2cap_index++;
                         }
 
                         add_l2cap_index = TRUE;
                     }
 
                     col_set_str(pinfo->cinfo, COL_INFO, "L2CAP Data");
 
                     acl_data = wmem_new(wmem_packet_scope(), bthci_acl_data_t);
                     acl_data->interface_id = interface_id;
                     acl_data->adapter_id   = adapter_id;
                     acl_data->chandle      = 0; /* No connection handle at this layer */
                     acl_data->remote_bd_addr_oui = 0;
                     acl_data->remote_bd_addr_id  = 0;
                     acl_data->is_btle = TRUE;
                     acl_data->is_btle_retransmit = retransmit;
+                    acl_data->adapter_disconnect_in_frame = &max_disconnect_in_frame;
+                    acl_data->disconnect_in_frame = &max_disconnect_in_frame;
 
                     next_tvb = tvb_new_subset_length(tvb, offset, length);
                     call_dissector_with_data(btl2cap_handle, next_tvb, pinfo, tree, acl_data);
                     offset += length;
                 }
             }
             break;
         case 0x03: /* Control PDU */
             proto_tree_add_item(btle_tree, hf_control_opcode, tvb, offset, 1, ENC_LITTLE_ENDIAN);
             control_opcode = tvb_get_guint8(tvb, offset);
             offset += 1;
 
             col_add_fstr(pinfo->cinfo, COL_INFO, "Control Opcode: %s",
                     val_to_str_ext_const(control_opcode, &control_opcode_vals_ext, "Unknown"));
 
             switch (control_opcode) {
             case 0x05: /* LL_START_ENC_REQ */
             case 0x06: /* LL_START_ENC_RSP */
             case 0x0A: /* LL_PAUSE_ENC_REQ */
             case 0x0B: /* LL_PAUSE_ENC_RSP */
             case 0x12: /* LL_PING_REQ */
             case 0x13: /* LL_PING_RSP */
                 if (tvb_reported_length_remaining(tvb, offset) > 3) {
                     proto_tree_add_expert(btle_tree, pinfo, &ei_unknown_data, tvb, offset, tvb_reported_length_remaining(tvb, offset) - 3);
                     offset += tvb_reported_length_remaining(tvb, offset) - 3;
                 }
 
                 break;
             case 0x00: /* LL_CONNECTION_UPDATE_REQ */
                 proto_tree_add_item(btle_tree, hf_control_window_size, tvb, offset, 1, ENC_LITTLE_ENDIAN);
                 offset += 1;
 
                 proto_tree_add_item(btle_tree, hf_control_window_offset, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 offset += 2;
 
                 proto_tree_add_item(btle_tree, hf_control_interval, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 offset += 2;
 
                 proto_tree_add_item(btle_tree, hf_control_latency, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 offset += 2;
 
                 proto_tree_add_item(btle_tree, hf_control_timeout, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 offset += 2;
 
                 proto_tree_add_item(btle_tree, hf_control_instant, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 offset += 2;
 
                 break;
             case 0x01: /* LL_CHANNEL_MAP_REQ */
                 sub_item = proto_tree_add_item(btle_tree, hf_control_channel_map, tvb, offset, 5, ENC_NA);
                 sub_tree = proto_item_add_subtree(sub_item, ett_channel_map);
 
                 call_dissector(btcommon_le_channel_map_handle, tvb_new_subset_length(tvb, offset, 5), pinfo, sub_tree);
                 offset += 5;
 
                 proto_tree_add_item(btle_tree, hf_control_instant, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 offset += 2;
 
                 break;
             case 0x02: /* LL_TERMINATE_IND */
             case 0x0D: /* LL_REJECT_IND */
                 proto_tree_add_item(btle_tree, hf_control_error_code, tvb, offset, 1, ENC_LITTLE_ENDIAN);
                 offset += 1;
 
                 break;
             case 0x03: /* LL_ENC_REQ */
                 proto_tree_add_item(btle_tree, hf_control_random_number, tvb, offset, 8, ENC_LITTLE_ENDIAN);
                 offset += 8;
 
                 proto_tree_add_item(btle_tree, hf_control_encrypted_diversifier, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 offset += 2;
 
                 proto_tree_add_item(btle_tree, hf_control_master_session_key_diversifier, tvb, offset, 8, ENC_LITTLE_ENDIAN);
                 offset += 8;
 
                 proto_tree_add_item(btle_tree, hf_control_master_session_initialization_vector, tvb, offset, 4, ENC_LITTLE_ENDIAN);
                 offset += 4;
 
                 break;
             case 0x04: /* LL_ENC_RSP */
                 proto_tree_add_item(btle_tree, hf_control_slave_session_key_diversifier, tvb, offset, 8, ENC_LITTLE_ENDIAN);
                 offset += 8;
 
                 proto_tree_add_item(btle_tree, hf_control_slave_session_initialization_vector, tvb, offset, 4, ENC_LITTLE_ENDIAN);
                 offset += 4;
 
                 break;
             case 0x07: /* LL_UNKNOWN_RSP */
                 proto_tree_add_item(btle_tree, hf_control_unknown_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
                 offset += 1;
 
                 break;
             case 0x08: /* LL_FEATURE_REQ */
             case 0x09: /* LL_FEATURE_RSP */
             case 0x0E: /* LL_SLAVE_FEATURE_REQ */
                 sub_item = proto_tree_add_item(btle_tree, hf_control_feature_set, tvb, offset, 8, ENC_LITTLE_ENDIAN);
                 sub_tree = proto_item_add_subtree(sub_item, ett_features);
 
                 proto_tree_add_bitmask_list(sub_tree, tvb, offset, 1, hfx_control_feature_set_1, ENC_NA);
                 offset += 1;
 
                 proto_tree_add_bitmask_list(sub_tree, tvb, offset, 1, hfx_control_feature_set_2, ENC_NA);
                 offset += 1;
 
                 proto_tree_add_bitmask_list(sub_tree, tvb, offset, 1, hfx_control_feature_set_3, ENC_NA);
                 offset += 1;
 
                 proto_tree_add_item(sub_tree, hf_control_feature_set_reserved, tvb, offset, 5, ENC_NA);
                 offset += 5;
 
                 break;
             case 0x0C: /* LL_VERSION_IND */
                 proto_tree_add_item(btle_tree, hf_control_version_number, tvb, offset, 1, ENC_LITTLE_ENDIAN);
                 offset += 1;
 
                 proto_tree_add_item(btle_tree, hf_control_company_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 offset += 2;
 
                 proto_tree_add_item(btle_tree, hf_control_subversion_number, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 offset += 2;
 
                 break;
             case 0x0F: /* LL_CONNECTION_PARAM_REQ */
             case 0x10: /* LL_CONNECTION_PARAM_RSP */
                 proto_tree_add_item(btle_tree, hf_control_interval_min, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 offset += 2;
 
                 proto_tree_add_item(btle_tree, hf_control_interval_max, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 offset += 2;
 
                 proto_tree_add_item(btle_tree, hf_control_latency, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 offset += 2;
 
                 proto_tree_add_item(btle_tree, hf_control_timeout, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 offset += 2;
 
                 proto_tree_add_item(btle_tree, hf_control_preferred_periodicity, tvb, offset, 1, ENC_LITTLE_ENDIAN);
                 offset += 1;
 
                 proto_tree_add_item(btle_tree, hf_control_reference_connection_event_count, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 offset += 2;
 
                 proto_tree_add_item(btle_tree, hf_control_offset_0, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 offset += 2;
 
                 proto_tree_add_item(btle_tree, hf_control_offset_1, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 offset += 2;
 
                 proto_tree_add_item(btle_tree, hf_control_offset_2, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 offset += 2;
 
                 proto_tree_add_item(btle_tree, hf_control_offset_3, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 offset += 2;
 
                 proto_tree_add_item(btle_tree, hf_control_offset_4, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 offset += 2;
 
                 proto_tree_add_item(btle_tree, hf_control_offset_5, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 offset += 2;
 
                 break;
             case 0x11: /* LL_REJECT_IND_EXT */
                 proto_tree_add_item(btle_tree, hf_control_reject_opcode, tvb, offset, 1, ENC_LITTLE_ENDIAN);
                 offset += 1;
 
                 proto_tree_add_item(btle_tree, hf_control_error_code, tvb, offset, 1, ENC_LITTLE_ENDIAN);
                 offset += 1;
 
                 break;
             case 0x14: /* LL_LENGTH_REQ */
             case 0x15: /* LL_LENGTH_RSP */
                 proto_tree_add_item(btle_tree, hf_control_max_rx_octets, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 offset += 2;
 
                 proto_tree_add_item(btle_tree, hf_control_max_rx_time, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 offset += 2;
 
                 proto_tree_add_item(btle_tree, hf_control_max_tx_octets, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 offset += 2;
 
                 proto_tree_add_item(btle_tree, hf_control_max_tx_time, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 offset += 2;
 
                 break;
             case 0x16: /* LL_PHY_REQ */
             case 0x17: /* LL_PHY_RSP */
                 proto_tree_add_bitmask(btle_tree, tvb, offset, hf_control_tx_phys, ett_tx_phys, hfx_control_phys_sender, ENC_NA);
                 offset += 1;
 
                 proto_tree_add_bitmask(btle_tree, tvb, offset, hf_control_rx_phys, ett_rx_phys, hfx_control_phys_sender, ENC_NA);
                 offset += 1;
 
                 break;
             case 0x18: /* LL_PHY_UPDATE_IND */
                 proto_tree_add_bitmask(btle_tree, tvb, offset, hf_control_m_to_s_phy, ett_m_to_s_phy, hfx_control_phys_update, ENC_NA);
                 offset += 1;
 
                 proto_tree_add_bitmask(btle_tree, tvb, offset, hf_control_s_to_m_phy, ett_s_to_m_phy, hfx_control_phys_update, ENC_NA);
                 offset += 1;
 
                 proto_tree_add_item(btle_tree, hf_control_instant, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 offset += 2;
 
                 break;
             case 0x19: /* LL_MIN_USED_CHANNELS_IND */
                 proto_tree_add_bitmask(btle_tree, tvb, offset, hf_control_phys, ett_phys, hfx_control_phys, ENC_NA);
                 offset += 1;
 
                 proto_tree_add_item(btle_tree, hf_control_min_used_channels, tvb, offset, 1, ENC_LITTLE_ENDIAN);
                 offset += 1;
 
                 break;
             default:
                 if (tvb_reported_length_remaining(tvb, offset) > 3) {
                     proto_tree_add_expert(btle_tree, pinfo, &ei_unknown_data, tvb, offset, tvb_reported_length_remaining(tvb, offset) - 3);
                     offset += tvb_reported_length_remaining(tvb, offset) - 3;
                 }
             }
 
             break;
         default:
             if (tvb_reported_length_remaining(tvb, offset) > 3) {
                 proto_tree_add_expert(btle_tree, pinfo, &ei_unknown_data, tvb, offset, tvb_reported_length_remaining(tvb, offset) - 3);
                 offset += tvb_reported_length_remaining(tvb, offset) - 3;
             }
         }
 
         if (add_l2cap_index) {
             item = proto_tree_add_uint(btle_tree, hf_l2cap_index, tvb, 0, 0, btle_frame_info->l2cap_index);
             proto_item_set_generated(item);
         }
 
         if ((crc_status == CRC_INDETERMINATE) &&
             btle_context && btle_context->connection_info_valid) {
             /* the surrounding context has provided CRCInit */
             crc_init = btle_context->connection_info.CRCInit;
             crc_status = CRC_CAN_BE_CALCULATED;
         }
     } else {
         /* Unknown physical channel PDU type */
         if (tvb_reported_length_remaining(tvb, offset) > 3) {
                 proto_tree_add_expert(btle_tree, pinfo, &ei_unknown_data, tvb, offset, tvb_reported_length_remaining(tvb, offset) - 3);
                 offset += tvb_reported_length_remaining(tvb, offset) - 3;
         }
     }
 
     /* BT spec Vol 6, Part B, Section 1.2: CRC is big endian and bits in byte are flipped */
     packet_crc = reverse_bits_per_byte(tvb_get_ntoh24(tvb, offset));
     sub_item = proto_tree_add_uint(btle_tree, hf_crc, tvb, offset, 3, packet_crc);
     offset += 3;
     if (crc_status == CRC_CAN_BE_CALCULATED) {
         guint32 crc = btle_crc(tvb, length, crc_init);
         crc_status = (packet_crc == crc) ? CRC_CORRECT : CRC_INCORRECT;
     }
     switch(crc_status) {
     case CRC_INDETERMINATE:
         expert_add_info(pinfo, sub_item, &ei_crc_cannot_be_determined);
         break;
     case CRC_INCORRECT:
         expert_add_info(pinfo, sub_item, &ei_crc_incorrect);
         break;
     case CRC_CORRECT:
     default:
         break;
     }
 
     return offset;
 }
