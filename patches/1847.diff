commit 96715d6a1f926acb37123ae4abfee03dc449d258
Merge: c7717225af b1332047d0
Author: Craig Tiller <ctiller@google.com>
Date:   Tue Jun 6 14:49:55 2017 +0000

    Merge github.com:grpc/grpc into ALL-the-things

diff --git a/src/csharp/Grpc.Auth/Grpc.Auth.csproj b/src/csharp/Grpc.Auth/Grpc.Auth.csproj
index 188ddb95b9..6030c70783 100755
--- a/src/csharp/Grpc.Auth/Grpc.Auth.csproj
+++ b/src/csharp/Grpc.Auth/Grpc.Auth.csproj
@@ -1,42 +1,43 @@
 ﻿<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Grpc.Core\Version.csproj.include" />
   <Import Project="..\Grpc.Core\Common.csproj.include" />
 
   <PropertyGroup>
     <Copyright>Copyright 2015, Google Inc.</Copyright>
     <AssemblyTitle>gRPC C# Auth</AssemblyTitle>
     <VersionPrefix>$(GrpcCsharpVersion)</VersionPrefix>
     <Authors>Google Inc.</Authors>
     <TargetFrameworks>net45;netstandard1.5</TargetFrameworks>
     <DefineConstants>$(DefineConstants);SIGNED</DefineConstants>
     <AssemblyName>Grpc.Auth</AssemblyName>
     <PackageId>Grpc.Auth</PackageId>
     <PackageTags>gRPC RPC Protocol HTTP/2 Auth OAuth2</PackageTags>
     <PackageProjectUrl>https://github.com/grpc/grpc</PackageProjectUrl>
     <PackageLicenseUrl>https://github.com/grpc/grpc/blob/master/LICENSE</PackageLicenseUrl>
     <NetStandardImplicitPackageVersion Condition=" '$(TargetFramework)' == 'netstandard1.5' ">1.6.0</NetStandardImplicitPackageVersion>
     <IncludeSymbols>true</IncludeSymbols>
     <IncludeSource>true</IncludeSource>
+    <GenerateDocumentationFile>true</GenerateDocumentationFile>
   </PropertyGroup>
 
   <ItemGroup>
     <Compile Include="..\Grpc.Core\Version.cs" />
   </ItemGroup>
 
   <ItemGroup>
     <ProjectReference Include="../Grpc.Core/Grpc.Core.csproj">
       <PrivateAssets>None</PrivateAssets>
     </ProjectReference>
   </ItemGroup>
 
   <ItemGroup>
     <PackageReference Include="Google.Apis.Auth" Version="1.21.0" />
   </ItemGroup>
 
   <ItemGroup Condition=" '$(TargetFramework)' == 'net45' ">
     <Reference Include="System" />
     <Reference Include="Microsoft.CSharp" />
   </ItemGroup>
 
 </Project>
diff --git a/src/csharp/Grpc.Core.Testing/Grpc.Core.Testing.csproj b/src/csharp/Grpc.Core.Testing/Grpc.Core.Testing.csproj
index 45ec874322..4e186d14dc 100755
--- a/src/csharp/Grpc.Core.Testing/Grpc.Core.Testing.csproj
+++ b/src/csharp/Grpc.Core.Testing/Grpc.Core.Testing.csproj
@@ -1,40 +1,39 @@
 ﻿<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Grpc.Core\Version.csproj.include" />
   <Import Project="..\Grpc.Core\Common.csproj.include" />
 
   <PropertyGroup>
     <Copyright>Copyright 2017, Google Inc.</Copyright>
     <AssemblyTitle>gRPC C# Core Testing</AssemblyTitle>
     <VersionPrefix>$(GrpcCsharpVersion)</VersionPrefix>
     <Authors>Google Inc.</Authors>
     <TargetFrameworks>net45;netstandard1.5</TargetFrameworks>
     <GenerateDocumentationFile>true</GenerateDocumentationFile>
     <AssemblyName>Grpc.Core.Testing</AssemblyName>
     <PackageId>Grpc.Core.Testing</PackageId>
     <PackageTags>gRPC test testing</PackageTags>
     <PackageProjectUrl>https://github.com/grpc/grpc</PackageProjectUrl>
     <PackageLicenseUrl>https://github.com/grpc/grpc/blob/master/LICENSE</PackageLicenseUrl>
     <NetStandardImplicitPackageVersion Condition=" '$(TargetFramework)' == 'netstandard1.5' ">1.6.0</NetStandardImplicitPackageVersion>
     <IncludeSymbols>true</IncludeSymbols>
     <IncludeSource>true</IncludeSource>
+    <GenerateDocumentationFile>true</GenerateDocumentationFile>
   </PropertyGroup>
 
   <ItemGroup>
     <Compile Include="..\Grpc.Core\Version.cs" />
   </ItemGroup>
 
   <ItemGroup>
     <ProjectReference Include="../Grpc.Core/Grpc.Core.csproj">
       <PrivateAssets>None</PrivateAssets>
     </ProjectReference>
   </ItemGroup>
 
   <ItemGroup Condition=" '$(TargetFramework)' == 'net45' ">
-    <Reference Include="System.Runtime" />
-    <Reference Include="System.IO" />
     <Reference Include="System" />
     <Reference Include="Microsoft.CSharp" />
   </ItemGroup>
 
 </Project>
diff --git a/src/csharp/Grpc.Core/Common.csproj.include b/src/csharp/Grpc.Core/Common.csproj.include
index 2cb990ba49..3b1bec2d55 100755
--- a/src/csharp/Grpc.Core/Common.csproj.include
+++ b/src/csharp/Grpc.Core/Common.csproj.include
@@ -1,32 +1,28 @@
 <!-- Common definitions shared by all .csproj files -->
 <Project>
   <PropertyGroup>
     <GenerateAssemblyVersionAttribute>false</GenerateAssemblyVersionAttribute>
     <GenerateAssemblyFileVersionAttribute>false</GenerateAssemblyFileVersionAttribute>
     <GenerateAssemblyInformationalVersionAttribute>false</GenerateAssemblyInformationalVersionAttribute>
     <GenerateAssemblyTitleAttribute>false</GenerateAssemblyTitleAttribute>
     <GenerateAssemblyDescriptionAttribute>false</GenerateAssemblyDescriptionAttribute>
     <GenerateAssemblyConfigurationAttribute>false</GenerateAssemblyConfigurationAttribute>
     <GenerateAssemblyCompanyAttribute>false</GenerateAssemblyCompanyAttribute>
     <GenerateAssemblyProductAttribute>false</GenerateAssemblyProductAttribute>
     <GenerateAssemblyCopyrightAttribute>false</GenerateAssemblyCopyrightAttribute>
   </PropertyGroup>
 
-  <PropertyGroup>
-    <GenerateDocumentationFile>true</GenerateDocumentationFile>
-  </PropertyGroup>
-
   <PropertyGroup>
     <DefineConstants>$(DefineConstants);SIGNED</DefineConstants>
     <AssemblyOriginatorKeyFile>../keys/Grpc.snk</AssemblyOriginatorKeyFile>
     <SignAssembly>true</SignAssembly>
     <PublicSign Condition=" '$(OS)' != 'Windows_NT' ">true</PublicSign>
   </PropertyGroup>
 
   <PropertyGroup Condition="'$(OS)' != 'Windows_NT'">
     <!-- Workaround for https://github.com/dotnet/sdk/issues/335 -->
     <FrameworkPathOverride Condition="Exists('/usr/lib/mono/4.5-api')">/usr/lib/mono/4.5-api</FrameworkPathOverride>
     <FrameworkPathOverride Condition="Exists('/usr/local/lib/mono/4.5-api')">/usr/local/lib/mono/4.5-api</FrameworkPathOverride>
     <FrameworkPathOverride Condition="Exists('/Library/Frameworks/Mono.framework/Versions/Current/lib/mono/4.5-api')">/Library/Frameworks/Mono.framework/Versions/Current/lib/mono/4.5-api</FrameworkPathOverride>
   </PropertyGroup>
 </Project>
diff --git a/src/csharp/Grpc.Core/Grpc.Core.csproj b/src/csharp/Grpc.Core/Grpc.Core.csproj
index ae0d8b2c8d..50358298f4 100755
--- a/src/csharp/Grpc.Core/Grpc.Core.csproj
+++ b/src/csharp/Grpc.Core/Grpc.Core.csproj
@@ -1,70 +1,71 @@
 ﻿<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="Version.csproj.include" />
   <Import Project="Common.csproj.include" />
 
   <PropertyGroup>
     <Copyright>Copyright 2015, Google Inc.</Copyright>
     <AssemblyTitle>gRPC C# Core</AssemblyTitle>
     <VersionPrefix>$(GrpcCsharpVersion)</VersionPrefix>
     <Authors>Google Inc.</Authors>
     <TargetFrameworks>net45;netstandard1.5</TargetFrameworks>
     <AssemblyName>Grpc.Core</AssemblyName>
     <PackageId>Grpc.Core</PackageId>
     <PackageTags>gRPC RPC Protocol HTTP/2</PackageTags>
     <PackageProjectUrl>https://github.com/grpc/grpc</PackageProjectUrl>
     <PackageLicenseUrl>https://github.com/grpc/grpc/blob/master/LICENSE</PackageLicenseUrl>
     <NetStandardImplicitPackageVersion Condition=" '$(TargetFramework)' == 'netstandard1.5' ">1.6.0</NetStandardImplicitPackageVersion>
     <IncludeSymbols>true</IncludeSymbols>
     <IncludeSource>true</IncludeSource>
+    <GenerateDocumentationFile>true</GenerateDocumentationFile>
   </PropertyGroup>
 
   <ItemGroup>
     <EmbeddedResource Include="..\..\..\etc\roots.pem" />
     <Content Include="..\nativelibs\csharp_ext_macos_x64\libgrpc_csharp_ext.dylib">
       <PackagePath>runtimes/osx/native/libgrpc_csharp_ext.x64.dylib</PackagePath>
       <Pack>true</Pack>
     </Content>
     <Content Include="..\nativelibs\csharp_ext_macos_x86\libgrpc_csharp_ext.dylib">
       <PackagePath>runtimes/osx/native/libgrpc_csharp_ext.x86.dylib</PackagePath>
       <Pack>true</Pack>
     </Content>
     <Content Include="..\nativelibs\csharp_ext_linux_x64\libgrpc_csharp_ext.so">
       <PackagePath>runtimes/linux/native/libgrpc_csharp_ext.x64.so</PackagePath>
       <Pack>true</Pack>
     </Content>
     <Content Include="..\nativelibs\csharp_ext_linux_x86\libgrpc_csharp_ext.so">
       <PackagePath>runtimes/linux/native/libgrpc_csharp_ext.x86.so</PackagePath>
       <Pack>true</Pack>
     </Content>
     <Content Include="..\nativelibs\csharp_ext_windows_x64\grpc_csharp_ext.dll">
       <PackagePath>runtimes/win/native/grpc_csharp_ext.x64.dll</PackagePath>
       <Pack>true</Pack>
     </Content>
     <Content Include="..\nativelibs\csharp_ext_windows_x86\grpc_csharp_ext.dll">
       <PackagePath>runtimes/win/native/grpc_csharp_ext.x86.dll</PackagePath>
       <Pack>true</Pack>
     </Content>
     <Content Include="Grpc.Core.targets">
       <PackagePath>build/net45/</PackagePath>
       <Pack>true</Pack>
     </Content>
   </ItemGroup>
 
   <ItemGroup>
     <PackageReference Include="System.Interactive.Async" Version="3.1.1" />
   </ItemGroup>
 
   <ItemGroup Condition=" '$(TargetFramework)' == 'net45' ">
     <Reference Include="System" />
     <Reference Include="Microsoft.CSharp" />
   </ItemGroup>
 
   <ItemGroup Condition=" '$(TargetFramework)' == 'netstandard1.5' ">
     <PackageReference Include="System.Runtime.Loader" Version="4.0.0" />
     <PackageReference Include="System.Threading.Thread" Version="4.0.0" />
   </ItemGroup>
 
   <Import Project="NativeDeps.csproj.include" />
 
 </Project>
diff --git a/src/csharp/Grpc.HealthCheck/Grpc.HealthCheck.csproj b/src/csharp/Grpc.HealthCheck/Grpc.HealthCheck.csproj
index c3791a4e6b..b54311bbd5 100755
--- a/src/csharp/Grpc.HealthCheck/Grpc.HealthCheck.csproj
+++ b/src/csharp/Grpc.HealthCheck/Grpc.HealthCheck.csproj
@@ -1,41 +1,42 @@
 ﻿<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Grpc.Core\Version.csproj.include" />
   <Import Project="..\Grpc.Core\Common.csproj.include" />
 
   <PropertyGroup>
     <Copyright>Copyright 2015, Google Inc.</Copyright>
     <AssemblyTitle>gRPC C# Healthchecking</AssemblyTitle>
     <VersionPrefix>$(GrpcCsharpVersion)</VersionPrefix>
     <Authors>Google Inc.</Authors>
     <TargetFrameworks>net45;netstandard1.5</TargetFrameworks>
     <AssemblyName>Grpc.HealthCheck</AssemblyName>
     <PackageId>Grpc.HealthCheck</PackageId>
     <PackageTags>gRPC health check</PackageTags>
     <PackageProjectUrl>https://github.com/grpc/grpc</PackageProjectUrl>
     <PackageLicenseUrl>https://github.com/grpc/grpc/blob/master/LICENSE</PackageLicenseUrl>
     <NetStandardImplicitPackageVersion Condition=" '$(TargetFramework)' == 'netstandard1.5' ">1.6.0</NetStandardImplicitPackageVersion>
     <IncludeSymbols>true</IncludeSymbols>
     <IncludeSource>true</IncludeSource>
+    <GenerateDocumentationFile>true</GenerateDocumentationFile>
   </PropertyGroup>
 
   <ItemGroup>
     <Compile Include="..\Grpc.Core\Version.cs" />
   </ItemGroup>
 
   <ItemGroup>
     <ProjectReference Include="../Grpc.Core/Grpc.Core.csproj">
       <PrivateAssets>None</PrivateAssets>
     </ProjectReference>
   </ItemGroup>
 
   <ItemGroup>
     <PackageReference Include="Google.Protobuf" Version="$(GoogleProtobufVersion)" />
   </ItemGroup>
 
   <ItemGroup Condition=" '$(TargetFramework)' == 'net45' ">
     <Reference Include="System" />
     <Reference Include="Microsoft.CSharp" />
   </ItemGroup>
 
 </Project>
diff --git a/src/csharp/Grpc.IntegrationTesting/ClientRunners.cs b/src/csharp/Grpc.IntegrationTesting/ClientRunners.cs
index 8a44f8d68f..a0eb468c5b 100644
--- a/src/csharp/Grpc.IntegrationTesting/ClientRunners.cs
+++ b/src/csharp/Grpc.IntegrationTesting/ClientRunners.cs
@@ -52,328 +52,328 @@ using Grpc.Testing;
 namespace Grpc.IntegrationTesting
 {
     /// <summary>
     /// Helper methods to start client runners for performance testing.
     /// </summary>
     public class ClientRunners
     {
         static readonly ILogger Logger = GrpcEnvironment.Logger.ForType<ClientRunners>();
 
         // Profilers to use for clients.
         static readonly BlockingCollection<BasicProfiler> profilers = new BlockingCollection<BasicProfiler>();
 
         internal static void AddProfiler(BasicProfiler profiler)
         {
             GrpcPreconditions.CheckNotNull(profiler);
             profilers.Add(profiler);
         }
 
         /// <summary>
         /// Creates a started client runner.
         /// </summary>
         public static IClientRunner CreateStarted(ClientConfig config)
         {
             Logger.Debug("ClientConfig: {0}", config);
 
             if (config.AsyncClientThreads != 0)
             {
                 Logger.Warning("ClientConfig.AsyncClientThreads is not supported for C#. Ignoring the value");
             }
             if (config.CoreLimit != 0)
             {
                 Logger.Warning("ClientConfig.CoreLimit is not supported for C#. Ignoring the value");
             }
             if (config.CoreList.Count > 0)
             {
                 Logger.Warning("ClientConfig.CoreList is not supported for C#. Ignoring the value");
             }
 
             var channels = CreateChannels(config.ClientChannels, config.ServerTargets, config.SecurityParams);
 
             return new ClientRunnerImpl(channels,
                 config.ClientType,
                 config.RpcType,
                 config.OutstandingRpcsPerChannel,
                 config.LoadParams,
                 config.PayloadConfig,
                 config.HistogramParams,
                 () => GetNextProfiler());
         }
 
         private static List<Channel> CreateChannels(int clientChannels, IEnumerable<string> serverTargets, SecurityParams securityParams)
         {
             GrpcPreconditions.CheckArgument(clientChannels > 0, "clientChannels needs to be at least 1.");
             GrpcPreconditions.CheckArgument(serverTargets.Count() > 0, "at least one serverTarget needs to be specified.");
 
             var credentials = securityParams != null ? TestCredentials.CreateSslCredentials() : ChannelCredentials.Insecure;
             List<ChannelOption> channelOptions = null;
             if (securityParams != null && securityParams.ServerHostOverride != "")
             {
                 channelOptions = new List<ChannelOption>
                 {
                     new ChannelOption(ChannelOptions.SslTargetNameOverride, securityParams.ServerHostOverride)
                 };
             }
 
             var result = new List<Channel>();
             for (int i = 0; i < clientChannels; i++)
             {
                 var target = serverTargets.ElementAt(i % serverTargets.Count());
                 var channel = new Channel(target, credentials, channelOptions);
                 result.Add(channel);
             }
             return result;
         }
 
         private static BasicProfiler GetNextProfiler()
         {
             BasicProfiler result = null;
             profilers.TryTake(out result);
             return result;
         }
     }
 
     internal class ClientRunnerImpl : IClientRunner
     {
         const double SecondsToNanos = 1e9;
 
         readonly List<Channel> channels;
         readonly ClientType clientType;
         readonly RpcType rpcType;
         readonly PayloadConfig payloadConfig;
         readonly Lazy<byte[]> cachedByteBufferRequest;
         readonly ThreadLocal<Histogram> threadLocalHistogram;
 
         readonly List<Task> runnerTasks;
         readonly CancellationTokenSource stoppedCts = new CancellationTokenSource();
         readonly WallClockStopwatch wallClockStopwatch = new WallClockStopwatch();
         readonly AtomicCounter statsResetCount = new AtomicCounter();
         
         public ClientRunnerImpl(List<Channel> channels, ClientType clientType, RpcType rpcType, int outstandingRpcsPerChannel, LoadParams loadParams, PayloadConfig payloadConfig, HistogramParams histogramParams, Func<BasicProfiler> profilerFactory)
         {
             GrpcPreconditions.CheckArgument(outstandingRpcsPerChannel > 0, "outstandingRpcsPerChannel");
             GrpcPreconditions.CheckNotNull(histogramParams, "histogramParams");
             this.channels = new List<Channel>(channels);
             this.clientType = clientType;
             this.rpcType = rpcType;
             this.payloadConfig = payloadConfig;
             this.cachedByteBufferRequest = new Lazy<byte[]>(() => new byte[payloadConfig.BytebufParams.ReqSize]);
             this.threadLocalHistogram = new ThreadLocal<Histogram>(() => new Histogram(histogramParams.Resolution, histogramParams.MaxPossible), true);
 
             this.runnerTasks = new List<Task>();
             foreach (var channel in this.channels)
             {
                 for (int i = 0; i < outstandingRpcsPerChannel; i++)
                 {
                     var timer = CreateTimer(loadParams, 1.0 / this.channels.Count / outstandingRpcsPerChannel);
                     var optionalProfiler = profilerFactory();
                     this.runnerTasks.Add(RunClientAsync(channel, timer, optionalProfiler));
                 }
             }
         }
 
         public ClientStats GetStats(bool reset)
         {
             var histogramData = new HistogramData();
             foreach (var hist in threadLocalHistogram.Values)
             {
                 hist.GetSnapshot(histogramData, reset);
             }
 
             var secondsElapsed = wallClockStopwatch.GetElapsedSnapshot(reset).TotalSeconds;
 
             if (reset)
             {
                 statsResetCount.Increment();
             }
 
-            GrpcEnvironment.Logger.Info("[ClientRunnerImpl.GetStats] GC collection counts: gen0 {0}, gen1 {1}, gen2 {2}, gen3 {3} (histogram reset count:{4}, seconds since reset: {5})",
-                GC.CollectionCount(0), GC.CollectionCount(1), GC.CollectionCount(2), GC.CollectionCount(3), statsResetCount.Count, secondsElapsed);
+            GrpcEnvironment.Logger.Info("[ClientRunnerImpl.GetStats] GC collection counts: gen0 {0}, gen1 {1}, gen2 {2}, (histogram reset count:{3}, seconds since reset: {4})",
+                GC.CollectionCount(0), GC.CollectionCount(1), GC.CollectionCount(2), statsResetCount.Count, secondsElapsed);
 
             // TODO: populate user time and system time
             return new ClientStats
             {
                 Latencies = histogramData,
                 TimeElapsed = secondsElapsed,
                 TimeUser = 0,
                 TimeSystem = 0
             };
         }
 
         public async Task StopAsync()
         {
             stoppedCts.Cancel();
             foreach (var runnerTask in runnerTasks)
             {
                 await runnerTask;
             }
             foreach (var channel in channels)
             {
                 await channel.ShutdownAsync();
             }
         }
 
         private void RunUnary(Channel channel, IInterarrivalTimer timer, BasicProfiler optionalProfiler)
         {
             if (optionalProfiler != null)
             {
                 Profilers.SetForCurrentThread(optionalProfiler);
             }
 
             bool profilerReset = false;
 
             var client = new BenchmarkService.BenchmarkServiceClient(channel);
             var request = CreateSimpleRequest();
             var stopwatch = new Stopwatch();
 
             while (!stoppedCts.Token.IsCancellationRequested)
             {
                 // after the first stats reset, also reset the profiler.
                 if (optionalProfiler != null && !profilerReset && statsResetCount.Count > 0)
                 {
                     optionalProfiler.Reset();
                     profilerReset = true;
                 }
 
                 stopwatch.Restart();
                 client.UnaryCall(request);
                 stopwatch.Stop();
 
                 // spec requires data point in nanoseconds.
                 threadLocalHistogram.Value.AddObservation(stopwatch.Elapsed.TotalSeconds * SecondsToNanos);
 
                 timer.WaitForNext();
             }
         }
 
         private async Task RunUnaryAsync(Channel channel, IInterarrivalTimer timer)
         {
             var client = new BenchmarkService.BenchmarkServiceClient(channel);
             var request = CreateSimpleRequest();
             var stopwatch = new Stopwatch();
 
             while (!stoppedCts.Token.IsCancellationRequested)
             {
                 stopwatch.Restart();
                 await client.UnaryCallAsync(request);
                 stopwatch.Stop();
 
                 // spec requires data point in nanoseconds.
                 threadLocalHistogram.Value.AddObservation(stopwatch.Elapsed.TotalSeconds * SecondsToNanos);
 
                 await timer.WaitForNextAsync();
             }
         }
 
         private async Task RunStreamingPingPongAsync(Channel channel, IInterarrivalTimer timer)
         {
             var client = new BenchmarkService.BenchmarkServiceClient(channel);
             var request = CreateSimpleRequest();
             var stopwatch = new Stopwatch();
 
             using (var call = client.StreamingCall())
             {
                 while (!stoppedCts.Token.IsCancellationRequested)
                 {
                     stopwatch.Restart();
                     await call.RequestStream.WriteAsync(request);
                     await call.ResponseStream.MoveNext();
                     stopwatch.Stop();
 
                     // spec requires data point in nanoseconds.
                     threadLocalHistogram.Value.AddObservation(stopwatch.Elapsed.TotalSeconds * SecondsToNanos);
 
                     await timer.WaitForNextAsync();
                 }
 
                 // finish the streaming call
                 await call.RequestStream.CompleteAsync();
                 Assert.IsFalse(await call.ResponseStream.MoveNext());
             }
         }
 
         private async Task RunGenericStreamingAsync(Channel channel, IInterarrivalTimer timer)
         {
             var request = cachedByteBufferRequest.Value;
             var stopwatch = new Stopwatch();
 
             var callDetails = new CallInvocationDetails<byte[], byte[]>(channel, GenericService.StreamingCallMethod, new CallOptions());
 
             using (var call = Calls.AsyncDuplexStreamingCall(callDetails))
             {
                 while (!stoppedCts.Token.IsCancellationRequested)
                 {
                     stopwatch.Restart();
                     await call.RequestStream.WriteAsync(request);
                     await call.ResponseStream.MoveNext();
                     stopwatch.Stop();
 
                     // spec requires data point in nanoseconds.
                     threadLocalHistogram.Value.AddObservation(stopwatch.Elapsed.TotalSeconds * SecondsToNanos);
 
                     await timer.WaitForNextAsync();
                 }
 
                 // finish the streaming call
                 await call.RequestStream.CompleteAsync();
                 Assert.IsFalse(await call.ResponseStream.MoveNext());
             }
         }
 
         private Task RunClientAsync(Channel channel, IInterarrivalTimer timer, BasicProfiler optionalProfiler)
         {
             if (payloadConfig.PayloadCase == PayloadConfig.PayloadOneofCase.BytebufParams)
             {
                 GrpcPreconditions.CheckArgument(clientType == ClientType.AsyncClient, "Generic client only supports async API");
                 GrpcPreconditions.CheckArgument(rpcType == RpcType.Streaming, "Generic client only supports streaming calls");
                 return RunGenericStreamingAsync(channel, timer);
             }
 
             GrpcPreconditions.CheckNotNull(payloadConfig.SimpleParams);
             if (clientType == ClientType.SyncClient)
             {
                 GrpcPreconditions.CheckArgument(rpcType == RpcType.Unary, "Sync client can only be used for Unary calls in C#");
                 // create a dedicated thread for the synchronous client
                 return Task.Factory.StartNew(() => RunUnary(channel, timer, optionalProfiler), TaskCreationOptions.LongRunning);
             }
             else if (clientType == ClientType.AsyncClient)
             {
                 switch (rpcType)
                 {
                     case RpcType.Unary:
                         return RunUnaryAsync(channel, timer);
                     case RpcType.Streaming:
                         return RunStreamingPingPongAsync(channel, timer);
                 }
             }
             throw new ArgumentException("Unsupported configuration.");
         }
 
         private SimpleRequest CreateSimpleRequest()
         {
             GrpcPreconditions.CheckNotNull(payloadConfig.SimpleParams);
             return new SimpleRequest
             {
                 Payload = CreateZerosPayload(payloadConfig.SimpleParams.ReqSize),
                 ResponseSize = payloadConfig.SimpleParams.RespSize
             };
         }
 
         private static Payload CreateZerosPayload(int size)
         {
             return new Payload { Body = ByteString.CopyFrom(new byte[size]) };
         }
 
         private static IInterarrivalTimer CreateTimer(LoadParams loadParams, double loadMultiplier)
         {
             switch (loadParams.LoadCase)
             {
                 case LoadParams.LoadOneofCase.ClosedLoop:
                     return new ClosedLoopInterarrivalTimer();
                 case LoadParams.LoadOneofCase.Poisson:
                     return new PoissonInterarrivalTimer(loadParams.Poisson.OfferedLoad * loadMultiplier);
                 default:
                     throw new ArgumentException("Unknown load type");
             }
         }
     }
 }
diff --git a/src/csharp/Grpc.IntegrationTesting/QpsWorker.cs b/src/csharp/Grpc.IntegrationTesting/QpsWorker.cs
index 486befe964..fbdb8fa3d6 100644
--- a/src/csharp/Grpc.IntegrationTesting/QpsWorker.cs
+++ b/src/csharp/Grpc.IntegrationTesting/QpsWorker.cs
@@ -50,58 +50,58 @@ using NUnit.Framework;
 namespace Grpc.IntegrationTesting
 {
     public class QpsWorker
     {
         private class ServerOptions
         {
             [Option("driver_port", Default = 0)]
             public int DriverPort { get; set; }
         }
 
         ServerOptions options;
 
         private QpsWorker(ServerOptions options)
         {
             this.options = options;
         }
 
         public static void Run(string[] args)
         {
             GrpcEnvironment.SetLogger(new ConsoleLogger());
             var parserResult = Parser.Default.ParseArguments<ServerOptions>(args)
                 .WithNotParsed((x) => Environment.Exit(1))
                 .WithParsed(options =>
                 {
                     var workerServer = new QpsWorker(options);
                     workerServer.RunAsync().Wait();
                 });
         }
 
         private async Task RunAsync()
         {
             // (ThreadPoolSize == ProcessorCount) gives best throughput in benchmarks
             // and doesn't seem to harm performance even when server and client
             // are running on the same machine.
             GrpcEnvironment.SetThreadPoolSize(Environment.ProcessorCount);
 
             string host = "0.0.0.0";
             int port = options.DriverPort;
 
             var tcs = new TaskCompletionSource<object>();
             var workerServiceImpl = new WorkerServiceImpl(() => { Task.Run(() => tcs.SetResult(null)); });
                 
             var server = new Server
             {
                 Services = { WorkerService.BindService(workerServiceImpl) },
                 Ports = { new ServerPort(host, options.DriverPort, ServerCredentials.Insecure )}
             };
             int boundPort = server.Ports.Single().BoundPort;
             GrpcEnvironment.Logger.Info("Running qps worker server on {0}:{1}", host, boundPort);
             server.Start();
             await tcs.Task;
             await server.ShutdownAsync();
 
-            GrpcEnvironment.Logger.Info("GC collection counts (after shutdown): gen0 {0}, gen1 {1}, gen2 {2}, gen3 {3}",
-                GC.CollectionCount(0), GC.CollectionCount(1), GC.CollectionCount(2), GC.CollectionCount(3));
+            GrpcEnvironment.Logger.Info("GC collection counts (after shutdown): gen0 {0}, gen1 {1}, gen2 {2}",
+                GC.CollectionCount(0), GC.CollectionCount(1), GC.CollectionCount(2));
         }
     }
 }
diff --git a/src/csharp/Grpc.IntegrationTesting/ServerRunners.cs b/src/csharp/Grpc.IntegrationTesting/ServerRunners.cs
index 7ab7734700..5acfce19c3 100644
--- a/src/csharp/Grpc.IntegrationTesting/ServerRunners.cs
+++ b/src/csharp/Grpc.IntegrationTesting/ServerRunners.cs
@@ -49,130 +49,130 @@ using Grpc.Testing;
 namespace Grpc.IntegrationTesting
 {
     /// <summary>
     /// Helper methods to start server runners for performance testing.
     /// </summary>
     public class ServerRunners
     {
         static readonly ILogger Logger = GrpcEnvironment.Logger.ForType<ServerRunners>();
 
         /// <summary>
         /// Creates a started server runner.
         /// </summary>
         public static IServerRunner CreateStarted(ServerConfig config)
         {
             Logger.Debug("ServerConfig: {0}", config);
             var credentials = config.SecurityParams != null ? TestCredentials.CreateSslServerCredentials() : ServerCredentials.Insecure;
 
             if (config.AsyncServerThreads != 0)
             {
                 Logger.Warning("ServerConfig.AsyncServerThreads is not supported for C#. Ignoring the value");
             }
             if (config.CoreLimit != 0)
             {
                 Logger.Warning("ServerConfig.CoreLimit is not supported for C#. Ignoring the value");
             }
             if (config.CoreList.Count > 0)
             {
                 Logger.Warning("ServerConfig.CoreList is not supported for C#. Ignoring the value");
             }
 
             ServerServiceDefinition service = null;
             if (config.ServerType == ServerType.AsyncServer)
             {
                 GrpcPreconditions.CheckArgument(config.PayloadConfig == null,
                     "ServerConfig.PayloadConfig shouldn't be set for BenchmarkService based server.");    
                 service = BenchmarkService.BindService(new BenchmarkServiceImpl());
             }
             else if (config.ServerType == ServerType.AsyncGenericServer)
             {
                 var genericService = new GenericServiceImpl(config.PayloadConfig.BytebufParams.RespSize);
                 service = GenericService.BindHandler(genericService.StreamingCall);
             }
             else
             {
                 throw new ArgumentException("Unsupported ServerType");
             }
 
             var server = new Server
             {
                 Services = { service },
                 Ports = { new ServerPort("[::]", config.Port, credentials) }
             };
 
             server.Start();
             return new ServerRunnerImpl(server);
         }
 
         private class GenericServiceImpl
         {
             readonly byte[] response;
 
             public GenericServiceImpl(int responseSize)
             {
                 this.response = new byte[responseSize];
             }
 
             /// <summary>
             /// Generic streaming call handler.
             /// </summary>
             public async Task StreamingCall(IAsyncStreamReader<byte[]> requestStream, IServerStreamWriter<byte[]> responseStream, ServerCallContext context)
             {
                 await requestStream.ForEachAsync(async request =>
                 {
                     await responseStream.WriteAsync(response);
                 });
             }
         }
     }
 
     /// <summary>
     /// Server runner.
     /// </summary>
     public class ServerRunnerImpl : IServerRunner
     {
         readonly Server server;
         readonly WallClockStopwatch wallClockStopwatch = new WallClockStopwatch();
 
         public ServerRunnerImpl(Server server)
         {
             this.server = GrpcPreconditions.CheckNotNull(server);
         }
 
         public int BoundPort
         {
             get
             {
                 return server.Ports.Single().BoundPort;
             }
         }
 
         /// <summary>
         /// Gets server stats.
         /// </summary>
         /// <returns>The stats.</returns>
         public ServerStats GetStats(bool reset)
         {
             var secondsElapsed = wallClockStopwatch.GetElapsedSnapshot(reset).TotalSeconds;
 
-            GrpcEnvironment.Logger.Info("[ServerRunner.GetStats] GC collection counts: gen0 {0}, gen1 {1}, gen2 {2}, gen3 {3} (seconds since last reset {4})",
-                GC.CollectionCount(0), GC.CollectionCount(1), GC.CollectionCount(2), GC.CollectionCount(3), secondsElapsed);
+            GrpcEnvironment.Logger.Info("[ServerRunner.GetStats] GC collection counts: gen0 {0}, gen1 {1}, gen2 {2}, (seconds since last reset {3})",
+                GC.CollectionCount(0), GC.CollectionCount(1), GC.CollectionCount(2), secondsElapsed);
 
             // TODO: populate user time and system time
             return new ServerStats
             {
                 TimeElapsed = secondsElapsed,
                 TimeUser = 0,
                 TimeSystem = 0
             };
         }
 
         /// <summary>
         /// Asynchronously stops the server.
         /// </summary>
         /// <returns>Task that finishes when server has shutdown.</returns>
         public Task StopAsync()
         {
             return server.ShutdownAsync();
         }
     }        
 }
diff --git a/src/csharp/Grpc.Reflection/Grpc.Reflection.csproj b/src/csharp/Grpc.Reflection/Grpc.Reflection.csproj
index 3a07555248..929a78edcb 100755
--- a/src/csharp/Grpc.Reflection/Grpc.Reflection.csproj
+++ b/src/csharp/Grpc.Reflection/Grpc.Reflection.csproj
@@ -1,41 +1,42 @@
 ﻿<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Grpc.Core\Version.csproj.include" />
   <Import Project="..\Grpc.Core\Common.csproj.include" />
 
   <PropertyGroup>
     <Copyright>Copyright 2016, Google Inc.</Copyright>
     <AssemblyTitle>gRPC C# Reflection</AssemblyTitle>
     <VersionPrefix>$(GrpcCsharpVersion)</VersionPrefix>
     <Authors>Google Inc.</Authors>
     <TargetFrameworks>net45;netstandard1.5</TargetFrameworks>
     <AssemblyName>Grpc.Reflection</AssemblyName>
     <PackageId>Grpc.Reflection</PackageId>
     <PackageTags>gRPC reflection</PackageTags>
     <PackageProjectUrl>https://github.com/grpc/grpc</PackageProjectUrl>
     <PackageLicenseUrl>https://github.com/grpc/grpc/blob/master/LICENSE</PackageLicenseUrl>
     <NetStandardImplicitPackageVersion Condition=" '$(TargetFramework)' == 'netstandard1.5' ">1.6.0</NetStandardImplicitPackageVersion>
     <IncludeSymbols>true</IncludeSymbols>
     <IncludeSource>true</IncludeSource>
+    <GenerateDocumentationFile>true</GenerateDocumentationFile>
   </PropertyGroup>
 
   <ItemGroup>
     <Compile Include="..\Grpc.Core\Version.cs" />
   </ItemGroup>
 
   <ItemGroup>
     <ProjectReference Include="../Grpc.Core/Grpc.Core.csproj">
       <PrivateAssets>None</PrivateAssets>
     </ProjectReference>
   </ItemGroup>
 
   <ItemGroup>
     <PackageReference Include="Google.Protobuf" Version="$(GoogleProtobufVersion)" />
   </ItemGroup>
 
   <ItemGroup Condition=" '$(TargetFramework)' == 'net45' ">
     <Reference Include="System" />
     <Reference Include="Microsoft.CSharp" />
   </ItemGroup>
 
 </Project>
diff --git a/tools/dockerfile/test/python_jessie_x64/Dockerfile b/tools/dockerfile/test/python_jessie_x64/Dockerfile
index f470bc2487..cc69f4b5cd 100644
--- a/tools/dockerfile/test/python_jessie_x64/Dockerfile
+++ b/tools/dockerfile/test/python_jessie_x64/Dockerfile
@@ -75,8 +75,7 @@ RUN pip install --upgrade google-api-python-client
 RUN apt-get update && apt-get install -y \
     python-all-dev \
     python3-all-dev \
-    python-pip \
-    python3-pip
+    python-pip
 
 # Install Python packages from PyPI
 RUN pip install pip --upgrade
diff --git a/tools/internal_ci/helper_scripts/prepare_build_macos_rc b/tools/internal_ci/helper_scripts/prepare_build_macos_rc
index 3eccff80b4..44d1fcbb3a 100644
--- a/tools/internal_ci/helper_scripts/prepare_build_macos_rc
+++ b/tools/internal_ci/helper_scripts/prepare_build_macos_rc
@@ -40,33 +40,27 @@ brew install autoconf automake libtool ccache cmake gflags gpg wget
 # TODO(jtattermusch): install cocoapods 
 
 # python
-wget https://bootstrap.pypa.io/get-pip.py
+wget -q https://bootstrap.pypa.io/get-pip.py
 sudo python get-pip.py
 sudo pip install virtualenv
 
 # TODO(jtattermusch): install python3
 
 # mono
-wget https://download.mono-project.com/archive/5.0.1/macos-10-universal/MonoFramework-MDK-5.0.1.1.macos10.xamarin.universal.pkg 
+wget -q https://download.mono-project.com/archive/5.0.1/macos-10-universal/MonoFramework-MDK-5.0.1.1.macos10.xamarin.universal.pkg
 sudo installer -pkg MonoFramework-MDK-5.0.1.1.macos10.xamarin.universal.pkg -target /
+ln -s /Library/Frameworks/Mono.framework/Versions/Current/bin/mono /usr/local/bin/mono
  
 # dotnet SDK
-wget https://go.microsoft.com/fwlink/?linkid=843444 -O dotnet-dev-osx-x64.1.0.1.pkg
+brew install openssl
+wget -q https://go.microsoft.com/fwlink/?linkid=843444 -O dotnet-dev-osx-x64.1.0.1.pkg
 sudo installer -pkg dotnet-dev-osx-x64.1.0.1.pkg -target /
 ln -s /usr/local/share/dotnet/dotnet /usr/local/bin/dotnet
 dotnet --version  # bootstrap dotnet SDK
 
 # nvm
 wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.30.2/install.sh | bash
-# bootstrap nvm silently & without terminating this script
-set +ex
-source ~/.nvm/nvm.sh
-set -ex
 
-# node
-nvm install 4
-nvm alias default 4
-npm update npm -g
-npm install -g node-pre-gyp
+# TODO(jtattermusch): install node if needed
 
 git submodule update --init
diff --git a/tools/run_tests/helper_scripts/build_python.sh b/tools/run_tests/helper_scripts/build_python.sh
index bd4b40b508..6ad285cdb9 100755
--- a/tools/run_tests/helper_scripts/build_python.sh
+++ b/tools/run_tests/helper_scripts/build_python.sh
@@ -146,13 +146,12 @@ fi
 ############################
 # Perform build operations #
 ############################
-$PYTHON -m pip install virtualenv
 
 # Instnatiate the virtualenv, preferring to do so from the relevant python
 # version. Even if these commands fail (e.g. on Windows due to name conflicts)
 # it's possible that the virtualenv is still usable and we trust the tester to
 # be able to 'figure it out' instead of us e.g. doing potentially expensive and
 # unnecessary error recovery by `rm -rf`ing the virtualenv.
 ($PYTHON -m virtualenv $VENV ||
  $HOST_PYTHON -m virtualenv -p $PYTHON $VENV ||
  true)
diff --git a/tools/run_tests/run_tests_matrix.py b/tools/run_tests/run_tests_matrix.py
index 84551d9394..c6f49174a9 100755
--- a/tools/run_tests/run_tests_matrix.py
+++ b/tools/run_tests/run_tests_matrix.py
@@ -187,126 +187,117 @@ def _create_test_jobs(extra_args=[], inner_jobs=_DEFAULT_INNER_JOBS):
 def _create_portability_test_jobs(extra_args=[], inner_jobs=_DEFAULT_INNER_JOBS):
   test_jobs = []
   # portability C x86
   test_jobs += _generate_jobs(languages=['c'],
                               configs=['dbg'],
                               platforms=['linux'],
                               arch='x86',
                               compiler='default',
                               labels=['portability'],
                               extra_args=extra_args,
                               inner_jobs=inner_jobs)
 
   # portability C and C++ on x64
   for compiler in ['gcc4.8', 'gcc5.3', 'gcc_musl',
                    'clang3.5', 'clang3.6', 'clang3.7']:
     test_jobs += _generate_jobs(languages=['c', 'c++'],
                                 configs=['dbg'],
                                 platforms=['linux'],
                                 arch='x64',
                                 compiler=compiler,
                                 labels=['portability'],
                                 extra_args=extra_args,
                                 inner_jobs=inner_jobs)
 
   # portability C on Windows
   for arch in ['x86', 'x64']:
     for compiler in ['vs2013', 'vs2015']:
       test_jobs += _generate_jobs(languages=['c'],
                                   configs=['dbg'],
                                   platforms=['windows'],
                                   arch=arch,
                                   compiler=compiler,
                                   labels=['portability'],
                                   extra_args=extra_args,
                                   inner_jobs=inner_jobs)
 
   # C and C++ with the c-ares DNS resolver on Linux
   test_jobs += _generate_jobs(languages=['c', 'c++'],
                               configs=['dbg'], platforms=['linux'],
                               labels=['portability'],
                               extra_args=extra_args,
                               extra_envs={'GRPC_DNS_RESOLVER': 'ares'})
 
   # TODO(zyc): Turn on this test after adding c-ares support on windows.
   # C with the c-ares DNS resolver on Windonws
   # test_jobs += _generate_jobs(languages=['c'],
   #                             configs=['dbg'], platforms=['windows'],
   #                             labels=['portability'],
   #                             extra_args=extra_args,
   #                             extra_envs={'GRPC_DNS_RESOLVER': 'ares'})
 
   # cmake build for C and C++
   # TODO(jtattermusch): some of the tests are failing, so we force --build_only
   # to make sure it's buildable at least.
   test_jobs += _generate_jobs(languages=['c', 'c++'],
                               configs=['dbg'],
                               platforms=['linux', 'windows'],
                               arch='default',
                               compiler='cmake',
                               labels=['portability'],
                               extra_args=extra_args + ['--build_only'],
                               inner_jobs=inner_jobs)
 
-  test_jobs += _generate_jobs(languages=['python'],
-                              configs=['dbg'],
-                              platforms=['linux'],
-                              arch='default',
-                              compiler='python3.4',
-                              labels=['portability'],
-                              extra_args=extra_args,
-                              inner_jobs=inner_jobs)
-
   test_jobs += _generate_jobs(languages=['python'],
                               configs=['dbg'],
                               platforms=['linux'],
                               arch='default',
                               compiler='python_alpine',
                               labels=['portability'],
                               extra_args=extra_args,
                               inner_jobs=inner_jobs)
 
   test_jobs += _generate_jobs(languages=['csharp'],
                               configs=['dbg'],
                               platforms=['linux'],
                               arch='default',
                               compiler='coreclr',
                               labels=['portability'],
                               extra_args=extra_args,
                               inner_jobs=inner_jobs)
 
   test_jobs += _generate_jobs(languages=['c'],
                               configs=['dbg'],
                               platforms=['linux'],
                               iomgr_platform='uv',
                               labels=['portability'],
                               extra_args=extra_args,
                               inner_jobs=inner_jobs)
 
   test_jobs += _generate_jobs(languages=['node'],
                               configs=['dbg'],
                               platforms=['linux'],
                               arch='default',
                               compiler='electron1.6',
                               labels=['portability'],
                               extra_args=extra_args,
                               inner_jobs=inner_jobs)
 
   test_jobs += _generate_jobs(languages=['node'],
                               configs=['dbg'],
                               platforms=['linux'],
                               arch='default',
                               compiler='node4',
                               labels=['portability'],
                               extra_args=extra_args,
                               inner_jobs=inner_jobs)
 
   test_jobs += _generate_jobs(languages=['node'],
                               configs=['dbg'],
                               platforms=['linux'],
                               arch='default',
                               compiler='node6',
                               labels=['portability'],
                               extra_args=extra_args,
                               inner_jobs=inner_jobs)
 
   return test_jobs
