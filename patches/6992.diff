commit 6d6ad2a8172966e9a0b1f4c3831db41f640c6296
Author: Even Rouault <even.rouault@mines-paris.org>
Date:   Sat Mar 17 15:20:21 2018 +0000

    Shapelib: simplify/factor code relative to filename extension stripping
    
    git-svn-id: https://svn.osgeo.org/gdal/trunk@41851 f0d54148-0727-0410-94bb-9a71ac55c965

diff --git a/gdal/ogr/ogrsf_frmts/shape/dbfopen.c b/gdal/ogr/ogrsf_frmts/shape/dbfopen.c
index 3300abaffb..fba0331dd8 100644
--- a/gdal/ogr/ogrsf_frmts/shape/dbfopen.c
+++ b/gdal/ogr/ogrsf_frmts/shape/dbfopen.c
@@ -458,15 +458,35 @@ DBFHandle SHPAPI_CALL
 DBFOpen( const char * pszFilename, const char * pszAccess )
 
 {
     SAHooks sHooks;
 
     SASetupDefaultHooks( &sHooks );
 
     return DBFOpenLL( pszFilename, pszAccess, &sHooks );
 }
 
+/************************************************************************/
+/*                      DBFGetLenWithoutExtension()                     */
+/************************************************************************/
+
+static int DBFGetLenWithoutExtension(const char* pszBasename)
+{
+    int i;
+    int nLen = (int)strlen(pszBasename);
+    for( i = nLen-1;
+         i > 0 && pszBasename[i] != '/' && pszBasename[i] != '\\';
+         i-- )
+    {
+        if( pszBasename[i] == '.' )
+        {
+            return i;
+        }
+    }
+    return nLen;
+}
+
 /************************************************************************/
 /*                              DBFOpen()                               */
 /*                                                                      */
 /*      Open a .dbf file.                                               */
 /************************************************************************/
@@ -475,220 +495,207 @@ DBFHandle SHPAPI_CALL
 DBFOpenLL( const char * pszFilename, const char * pszAccess, SAHooks *psHooks )
 
 {
     DBFHandle		psDBF;
     SAFile		pfCPG;
     unsigned char	*pabyBuf;
-    int			nFields, nHeadLen, iField, i;
-    char		*pszBasename, *pszFullname;
+    int			nFields, nHeadLen, iField;
+    char		*pszFullname;
     int                 nBufSize = 500;
-    size_t              nFullnameLen;
+    int                 nLenWithoutExtension;
 
 /* -------------------------------------------------------------------- */
 /*      We only allow the access strings "rb" and "r+".                  */
 /* -------------------------------------------------------------------- */
     if( strcmp(pszAccess,"r") != 0 && strcmp(pszAccess,"r+") != 0
         && strcmp(pszAccess,"rb") != 0 && strcmp(pszAccess,"rb+") != 0
         && strcmp(pszAccess,"r+b") != 0 )
         return( NULL );
 
     if( strcmp(pszAccess,"r") == 0 )
         pszAccess = "rb";
 
     if( strcmp(pszAccess,"r+") == 0 )
         pszAccess = "rb+";
 
 /* -------------------------------------------------------------------- */
 /*	Compute the base (layer) name.  If there is any extension	*/
 /*	on the passed in filename we will strip it off.			*/
 /* -------------------------------------------------------------------- */
-    pszBasename = (char *) malloc(strlen(pszFilename)+5);
-    strcpy( pszBasename, pszFilename );
-    for( i = (int)strlen(pszBasename)-1;
-         i > 0 && pszBasename[i] != '/' && pszBasename[i] != '\\';
-         i-- )
-    {
-        if( pszBasename[i] == '.' )
-        {
-            pszBasename[i] = '\0';
-            break;
-        }
-    }
-
-    nFullnameLen = strlen(pszBasename) + 5;
-    pszFullname = (char *) malloc(nFullnameLen);
-    snprintf( pszFullname, nFullnameLen, "%s.dbf", pszBasename );
+    nLenWithoutExtension = DBFGetLenWithoutExtension(pszFilename);
+    pszFullname = (char *) malloc(nLenWithoutExtension + 5);
+    memcpy(pszFullname, pszFilename, nLenWithoutExtension);
+    memcpy(pszFullname + nLenWithoutExtension, ".dbf", 5);
 
     psDBF = (DBFHandle) calloc( 1, sizeof(DBFInfo) );
     psDBF->fp = psHooks->FOpen( pszFullname, pszAccess );
     memcpy( &(psDBF->sHooks), psHooks, sizeof(SAHooks) );
 
     if( psDBF->fp == NULL )
     {
-        snprintf( pszFullname, nFullnameLen, "%s.DBF", pszBasename );
+        memcpy(pszFullname + nLenWithoutExtension, ".DBF", 5);
         psDBF->fp = psDBF->sHooks.FOpen(pszFullname, pszAccess );
     }
 
-    snprintf( pszFullname, nFullnameLen, "%s.cpg", pszBasename );
+    memcpy(pszFullname + nLenWithoutExtension, ".cpg", 5);
     pfCPG = psHooks->FOpen( pszFullname, "r" );
     if( pfCPG == NULL )
     {
-        snprintf( pszFullname, nFullnameLen, "%s.CPG", pszBasename );
+        memcpy(pszFullname + nLenWithoutExtension, ".CPG", 5);
         pfCPG = psHooks->FOpen( pszFullname, "r" );
     }
 
-    free( pszBasename );
     free( pszFullname );
 
     if( psDBF->fp == NULL )
     {
         free( psDBF );
         if( pfCPG ) psHooks->FClose( pfCPG );
         return( NULL );
     }
 
     psDBF->bNoHeader = FALSE;
     psDBF->nCurrentRecord = -1;
     psDBF->bCurrentRecordModified = FALSE;
 
 /* -------------------------------------------------------------------- */
 /*  Read Table Header info                                              */
 /* -------------------------------------------------------------------- */
     pabyBuf = (unsigned char *) malloc(nBufSize);
     if( psDBF->sHooks.FRead( pabyBuf, XBASE_FILEHDR_SZ, 1, psDBF->fp ) != 1 )
     {
         psDBF->sHooks.FClose( psDBF->fp );
         if( pfCPG ) psDBF->sHooks.FClose( pfCPG );
         free( pabyBuf );
         free( psDBF );
         return NULL;
     }
 
     DBFSetLastModifiedDate(psDBF, pabyBuf[1], pabyBuf[2], pabyBuf[3]);
 
     psDBF->nRecords =
      pabyBuf[4]|(pabyBuf[5]<<8)|(pabyBuf[6]<<16)|((pabyBuf[7]&0x7f)<<24);
 
     psDBF->nHeaderLength = nHeadLen = pabyBuf[8]|(pabyBuf[9]<<8);
     psDBF->nRecordLength = pabyBuf[10]|(pabyBuf[11]<<8);
     psDBF->iLanguageDriver = pabyBuf[29];
 
     if (psDBF->nRecordLength == 0 || nHeadLen < XBASE_FILEHDR_SZ)
     {
         psDBF->sHooks.FClose( psDBF->fp );
         if( pfCPG ) psDBF->sHooks.FClose( pfCPG );
         free( pabyBuf );
         free( psDBF );
         return NULL;
     }
 
     psDBF->nFields = nFields = (nHeadLen - XBASE_FILEHDR_SZ) / XBASE_FLDHDR_SZ;
 
     /* coverity[tainted_data] */
     psDBF->pszCurrentRecord = (char *) malloc(psDBF->nRecordLength);
 
 /* -------------------------------------------------------------------- */
 /*  Figure out the code page from the LDID and CPG                      */
 /* -------------------------------------------------------------------- */
 
     psDBF->pszCodePage = NULL;
     if( pfCPG )
     {
         size_t n;
         memset( pabyBuf, 0, nBufSize);
         psDBF->sHooks.FRead( pabyBuf, nBufSize - 1, 1, pfCPG );
         n = strcspn( (char *) pabyBuf, "\n\r" );
         if( n > 0 )
         {
             pabyBuf[n] = '\0';
             psDBF->pszCodePage = (char *) malloc(n + 1);
             memcpy( psDBF->pszCodePage, pabyBuf, n + 1 );
         }
 		psDBF->sHooks.FClose( pfCPG );
     }
     if( psDBF->pszCodePage == NULL && pabyBuf[29] != 0 )
     {
         snprintf( (char *) pabyBuf, nBufSize, "LDID/%d", psDBF->iLanguageDriver );
         psDBF->pszCodePage = (char *) malloc(strlen((char*)pabyBuf) + 1);
         strcpy( psDBF->pszCodePage, (char *) pabyBuf );
     }
 
 /* -------------------------------------------------------------------- */
 /*  Read in Field Definitions                                           */
 /* -------------------------------------------------------------------- */
 
     pabyBuf = (unsigned char *) SfRealloc(pabyBuf,nHeadLen);
     psDBF->pszHeader = (char *) pabyBuf;
 
     psDBF->sHooks.FSeek( psDBF->fp, XBASE_FILEHDR_SZ, 0 );
     if( psDBF->sHooks.FRead( pabyBuf, nHeadLen-XBASE_FILEHDR_SZ, 1,
                              psDBF->fp ) != 1 )
     {
         psDBF->sHooks.FClose( psDBF->fp );
         free( pabyBuf );
         free( psDBF->pszCurrentRecord );
         free( psDBF->pszCodePage );
         free( psDBF );
         return NULL;
     }
 
     psDBF->panFieldOffset = (int *) malloc(sizeof(int) * nFields);
     psDBF->panFieldSize = (int *) malloc(sizeof(int) * nFields);
     psDBF->panFieldDecimals = (int *) malloc(sizeof(int) * nFields);
     psDBF->pachFieldType = (char *) malloc(sizeof(char) * nFields);
 
     for( iField = 0; iField < nFields; iField++ )
     {
 	unsigned char		*pabyFInfo;
 
 	pabyFInfo = pabyBuf+iField*XBASE_FLDHDR_SZ;
         if( pabyFInfo[0] == HEADER_RECORD_TERMINATOR )
         {
             psDBF->nFields = iField;
             break;
         }
 
 	if( pabyFInfo[11] == 'N' || pabyFInfo[11] == 'F' )
 	{
 	    psDBF->panFieldSize[iField] = pabyFInfo[16];
 	    psDBF->panFieldDecimals[iField] = pabyFInfo[17];
 	}
 	else
 	{
 	    psDBF->panFieldSize[iField] = pabyFInfo[16];
 	    psDBF->panFieldDecimals[iField] = 0;
 
 /*
 ** The following seemed to be used sometimes to handle files with long
 ** string fields, but in other cases (such as bug 1202) the decimals field
 ** just seems to indicate some sort of preferred formatting, not very
 ** wide fields.  So I have disabled this code.  FrankW.
 	    psDBF->panFieldSize[iField] = pabyFInfo[16] + pabyFInfo[17]*256;
 	    psDBF->panFieldDecimals[iField] = 0;
 */
 	}
 
 	psDBF->pachFieldType[iField] = (char) pabyFInfo[11];
 	if( iField == 0 )
 	    psDBF->panFieldOffset[iField] = 1;
 	else
 	    psDBF->panFieldOffset[iField] =
 	      psDBF->panFieldOffset[iField-1] + psDBF->panFieldSize[iField-1];
     }
 
     /* Check that the total width of fields does not exceed the record width */
     if( psDBF->nFields > 0 &&
         psDBF->panFieldOffset[psDBF->nFields-1] +
             psDBF->panFieldSize[psDBF->nFields-1] > psDBF->nRecordLength )
     {
         DBFClose( psDBF );
         return NULL;
     }
 
     DBFSetWriteEndOfFileChar( psDBF, TRUE );
 
     return( psDBF );
 }
 
 /************************************************************************/
 /*                              DBFClose()                              */
 /************************************************************************/
@@ -777,120 +784,105 @@ DBFHandle SHPAPI_CALL
 DBFCreateLL( const char * pszFilename, const char * pszCodePage, SAHooks *psHooks )
 
 {
     DBFHandle	psDBF;
     SAFile	fp;
-    char	*pszFullname, *pszBasename;
-    int		i, ldid = -1;
+    char	*pszFullname;
+    int		ldid = -1;
     char chZero = '\0';
-    size_t      nFullnameLen;
+    int         nLenWithoutExtension;
 
 /* -------------------------------------------------------------------- */
 /*	Compute the base (layer) name.  If there is any extension	*/
 /*	on the passed in filename we will strip it off.			*/
 /* -------------------------------------------------------------------- */
-    pszBasename = (char *) malloc(strlen(pszFilename)+5);
-    strcpy( pszBasename, pszFilename );
-    for( i = (int)strlen(pszBasename)-1;
-         i > 0 && pszBasename[i] != '/' && pszBasename[i] != '\\';
-         i-- )
-    {
-        if( pszBasename[i] == '.' )
-        {
-            pszBasename[i] = '\0';
-            break;
-        }
-    }
-
-    nFullnameLen = strlen(pszBasename) + 5;
-    pszFullname = (char *) malloc(nFullnameLen);
-    snprintf( pszFullname, nFullnameLen, "%s.dbf", pszBasename );
+    nLenWithoutExtension = DBFGetLenWithoutExtension(pszFilename);
+    pszFullname = (char *) malloc(nLenWithoutExtension + 5);
+    memcpy(pszFullname, pszFilename, nLenWithoutExtension);
+    memcpy(pszFullname + nLenWithoutExtension, ".dbf", 5);
 
 /* -------------------------------------------------------------------- */
 /*      Create the file.                                                */
 /* -------------------------------------------------------------------- */
     fp = psHooks->FOpen( pszFullname, "wb" );
     if( fp == NULL )
     {
-        free( pszBasename );
         free( pszFullname );
         return( NULL );
     }
 
     psHooks->FWrite( &chZero, 1, 1, fp );
     psHooks->FClose( fp );
 
     fp = psHooks->FOpen( pszFullname, "rb+" );
     if( fp == NULL )
     {
-        free( pszBasename );
         free( pszFullname );
         return( NULL );
     }
 
-    snprintf( pszFullname, nFullnameLen, "%s.cpg", pszBasename );
+    memcpy(pszFullname + nLenWithoutExtension, ".cpg", 5);
     if( pszCodePage != NULL )
     {
         if( strncmp( pszCodePage, "LDID/", 5 ) == 0 )
         {
             ldid = atoi( pszCodePage + 5 );
             if( ldid > 255 )
                 ldid = -1; // don't use 0 to indicate out of range as LDID/0 is a valid one
         }
         if( ldid < 0 )
         {
             SAFile fpCPG = psHooks->FOpen( pszFullname, "w" );
             psHooks->FWrite( (char*) pszCodePage, strlen(pszCodePage), 1, fpCPG );
             psHooks->FClose( fpCPG );
         }
     }
     if( pszCodePage == NULL || ldid >= 0 )
     {
         psHooks->Remove( pszFullname );
     }
 
-    free( pszBasename );
     free( pszFullname );
 
 /* -------------------------------------------------------------------- */
 /*	Create the info structure.					*/
 /* -------------------------------------------------------------------- */
     psDBF = (DBFHandle) calloc(1,sizeof(DBFInfo));
 
     memcpy( &(psDBF->sHooks), psHooks, sizeof(SAHooks) );
     psDBF->fp = fp;
     psDBF->nRecords = 0;
     psDBF->nFields = 0;
     psDBF->nRecordLength = 1;
     psDBF->nHeaderLength = XBASE_FILEHDR_SZ + 1; /* + 1 for HEADER_RECORD_TERMINATOR */
 
     psDBF->panFieldOffset = NULL;
     psDBF->panFieldSize = NULL;
     psDBF->panFieldDecimals = NULL;
     psDBF->pachFieldType = NULL;
     psDBF->pszHeader = NULL;
 
     psDBF->nCurrentRecord = -1;
     psDBF->bCurrentRecordModified = FALSE;
     psDBF->pszCurrentRecord = NULL;
 
     psDBF->bNoHeader = TRUE;
 
     psDBF->iLanguageDriver = ldid > 0 ? ldid : 0;
     psDBF->pszCodePage = NULL;
     if( pszCodePage )
     {
         psDBF->pszCodePage = (char * ) malloc( strlen(pszCodePage) + 1 );
         strcpy( psDBF->pszCodePage, pszCodePage );
     }
     DBFSetLastModifiedDate(psDBF, 95, 7, 26); /* dummy date */
 
     DBFSetWriteEndOfFileChar(psDBF, TRUE);
 
     return( psDBF );
 }
 
 /************************************************************************/
 /*                            DBFAddField()                             */
 /*                                                                      */
 /*      Add a field to a newly created .dbf or to an existing one       */
 /************************************************************************/
diff --git a/gdal/ogr/ogrsf_frmts/shape/shpopen.c b/gdal/ogr/ogrsf_frmts/shape/shpopen.c
index 3b936dc5dd..1ed70c71d6 100644
--- a/gdal/ogr/ogrsf_frmts/shape/shpopen.c
+++ b/gdal/ogr/ogrsf_frmts/shape/shpopen.c
@@ -536,16 +536,36 @@ SHPHandle SHPAPI_CALL
 SHPOpen( const char * pszLayer, const char * pszAccess )
 
 {
     SAHooks sHooks;
 
     SASetupDefaultHooks( &sHooks );
 
     return SHPOpenLL( pszLayer, pszAccess, &sHooks );
 }
 
+/************************************************************************/
+/*                      SHPGetLenWithoutExtension()                     */
+/************************************************************************/
+
+static int SHPGetLenWithoutExtension(const char* pszBasename)
+{
+    int i;
+    int nLen = (int)strlen(pszBasename);
+    for( i = nLen-1;
+         i > 0 && pszBasename[i] != '/' && pszBasename[i] != '\\';
+         i-- )
+    {
+        if( pszBasename[i] == '.' )
+        {
+            return i;
+        }
+    }
+    return nLen;
+}
+
 /************************************************************************/
 /*                              SHPOpen()                               */
 /*                                                                      */
 /*      Open the .shp and .shx files based on the basename of the       */
 /*      files or either file name.                                      */
 /************************************************************************/
@@ -554,357 +574,340 @@ SHPHandle SHPAPI_CALL
 SHPOpenLL( const char * pszLayer, const char * pszAccess, SAHooks *psHooks )
 
 {
-    char        *pszFullname, *pszBasename;
+    char        *pszFullname;
     SHPHandle       psSHP;
 
     uchar       *pabyBuf;
     int         i;
     double      dValue;
     int         bLazySHXLoading = FALSE;
-    size_t nFullnameLen;
+    int         nLenWithoutExtension;
 
 /* -------------------------------------------------------------------- */
 /*      Ensure the access string is one of the legal ones.  We          */
 /*      ensure the result string indicates binary to avoid common       */
 /*      problems on Windows.                                            */
 /* -------------------------------------------------------------------- */
     if( strcmp(pszAccess,"rb+") == 0 || strcmp(pszAccess,"r+b") == 0
         || strcmp(pszAccess,"r+") == 0 )
         pszAccess = "r+b";
     else
     {
         bLazySHXLoading = strchr(pszAccess, 'l') != NULL;
         pszAccess = "rb";
     }
 
 /* -------------------------------------------------------------------- */
 /*  Establish the byte order on this machine.           */
 /* -------------------------------------------------------------------- */
 #if !defined(bBigEndian)
     i = 1;
     if( *((uchar *) &i) == 1 )
         bBigEndian = FALSE;
     else
         bBigEndian = TRUE;
 #endif
 
 /* -------------------------------------------------------------------- */
 /*  Initialize the info structure.                  */
 /* -------------------------------------------------------------------- */
     psSHP = (SHPHandle) calloc(sizeof(SHPInfo),1);
 
     psSHP->bUpdated = FALSE;
     memcpy( &(psSHP->sHooks), psHooks, sizeof(SAHooks) );
 
-/* -------------------------------------------------------------------- */
-/*  Compute the base (layer) name.  If there is any extension   */
-/*  on the passed in filename we will strip it off.         */
-/* -------------------------------------------------------------------- */
-    pszBasename = (char *) malloc(strlen(pszLayer)+5);
-    strcpy( pszBasename, pszLayer );
-    for( i = (int)strlen(pszBasename)-1;
-         i > 0 && pszBasename[i] != '/' && pszBasename[i] != '\\';
-         i-- )
-    {
-        if( pszBasename[i] == '.' )
-        {
-            pszBasename[i] = '\0';
-            break;
-        }
-    }
-
 /* -------------------------------------------------------------------- */
 /*  Open the .shp and .shx files.  Note that files pulled from  */
 /*  a PC to Unix with upper case filenames won't work!      */
 /* -------------------------------------------------------------------- */
-    nFullnameLen = strlen(pszBasename) + 5;
-    pszFullname = (char *) malloc(nFullnameLen);
-    snprintf( pszFullname, nFullnameLen, "%s.shp", pszBasename ) ;
+    nLenWithoutExtension = SHPGetLenWithoutExtension(pszLayer);
+    pszFullname = (char *) malloc(nLenWithoutExtension + 5);
+    memcpy(pszFullname, pszLayer, nLenWithoutExtension);
+    memcpy(pszFullname + nLenWithoutExtension, ".shp", 5);
     psSHP->fpSHP = psSHP->sHooks.FOpen(pszFullname, pszAccess );
     if( psSHP->fpSHP == NULL )
     {
-        snprintf( pszFullname, nFullnameLen, "%s.SHP", pszBasename );
+        memcpy(pszFullname + nLenWithoutExtension, ".SHP", 5);
         psSHP->fpSHP = psSHP->sHooks.FOpen(pszFullname, pszAccess );
     }
 
     if( psSHP->fpSHP == NULL )
     {
-        size_t nMessageLen = strlen(pszBasename)*2+256;
+        size_t nMessageLen = strlen(pszFullname)*2+256;
         char *pszMessage = (char *) malloc(nMessageLen);
+        pszFullname[nLenWithoutExtension] = 0;
         snprintf( pszMessage, nMessageLen, "Unable to open %s.shp or %s.SHP.",
-                  pszBasename, pszBasename );
+                  pszFullname, pszFullname );
         psHooks->Error( pszMessage );
         free( pszMessage );
 
         free( psSHP );
-        free( pszBasename );
         free( pszFullname );
 
         return NULL;
     }
 
-    snprintf( pszFullname, nFullnameLen, "%s.shx", pszBasename );
+    memcpy(pszFullname + nLenWithoutExtension, ".shx", 5);
     psSHP->fpSHX =  psSHP->sHooks.FOpen(pszFullname, pszAccess );
     if( psSHP->fpSHX == NULL )
     {
-        snprintf( pszFullname, nFullnameLen, "%s.SHX", pszBasename );
+        memcpy(pszFullname + nLenWithoutExtension, ".SHX", 5);
         psSHP->fpSHX = psSHP->sHooks.FOpen(pszFullname, pszAccess );
     }
 
     if( psSHP->fpSHX == NULL )
     {
-        size_t nMessageLen = strlen(pszBasename)*2+256;
+        size_t nMessageLen = strlen(pszFullname)*2+256;
         char *pszMessage = (char *) malloc(nMessageLen);
+        pszFullname[nLenWithoutExtension] = 0;
         snprintf( pszMessage, nMessageLen, "Unable to open %s.shx or %s.SHX. "
                   "Set SHAPE_RESTORE_SHX config option to YES to restore or "
-                  "create it.", pszBasename, pszBasename );
+                  "create it.", pszFullname, pszFullname );
         psHooks->Error( pszMessage );
         free( pszMessage );
 
         psSHP->sHooks.FClose( psSHP->fpSHP );
         free( psSHP );
-        free( pszBasename );
         free( pszFullname );
         return( NULL );
     }
 
     free( pszFullname );
-    free( pszBasename );
 
 /* -------------------------------------------------------------------- */
 /*  Read the file size from the SHP file.               */
 /* -------------------------------------------------------------------- */
     pabyBuf = (uchar *) malloc(100);
     if( psSHP->sHooks.FRead( pabyBuf, 100, 1, psSHP->fpSHP ) != 1 )
     {
         psSHP->sHooks.Error( ".shp file is unreadable, or corrupt." );
         psSHP->sHooks.FClose( psSHP->fpSHP );
         psSHP->sHooks.FClose( psSHP->fpSHX );
         free( pabyBuf );
         free( psSHP );
 
         return( NULL );
     }
 
     psSHP->nFileSize = ((unsigned int)pabyBuf[24]<<24)|(pabyBuf[25]<<16)|
                         (pabyBuf[26]<<8)|pabyBuf[27];
     if( psSHP->nFileSize < UINT_MAX / 2 )
         psSHP->nFileSize *= 2;
     else
         psSHP->nFileSize = (UINT_MAX / 2) * 2;
 
 /* -------------------------------------------------------------------- */
 /*  Read SHX file Header info                                           */
 /* -------------------------------------------------------------------- */
     if( psSHP->sHooks.FRead( pabyBuf, 100, 1, psSHP->fpSHX ) != 1
         || pabyBuf[0] != 0
         || pabyBuf[1] != 0
         || pabyBuf[2] != 0x27
         || (pabyBuf[3] != 0x0a && pabyBuf[3] != 0x0d) )
     {
         psSHP->sHooks.Error( ".shx file is unreadable, or corrupt." );
         psSHP->sHooks.FClose( psSHP->fpSHP );
         psSHP->sHooks.FClose( psSHP->fpSHX );
         free( pabyBuf );
         free( psSHP );
 
         return( NULL );
     }
 
     psSHP->nRecords = pabyBuf[27]|(pabyBuf[26]<<8)|(pabyBuf[25]<<16)|
                       ((pabyBuf[24] & 0x7F)<<24);
     psSHP->nRecords = (psSHP->nRecords - 50) / 4;
 
     psSHP->nShapeType = pabyBuf[32];
 
     if( psSHP->nRecords < 0 || psSHP->nRecords > 256000000 )
     {
         char szErrorMsg[200];
 
         snprintf( szErrorMsg, sizeof(szErrorMsg),
                  "Record count in .shp header is %d, which seems\n"
                  "unreasonable.  Assuming header is corrupt.",
                  psSHP->nRecords );
         szErrorMsg[sizeof(szErrorMsg)-1] = '\0';
         psSHP->sHooks.Error( szErrorMsg );
         psSHP->sHooks.FClose( psSHP->fpSHP );
         psSHP->sHooks.FClose( psSHP->fpSHX );
         free( psSHP );
         free(pabyBuf);
 
         return( NULL );
     }
 
     /* If a lot of records are advertized, check that the file is big enough */
     /* to hold them */
     if( psSHP->nRecords >= 1024 * 1024 )
     {
         SAOffset nFileSize;
         psSHP->sHooks.FSeek( psSHP->fpSHX, 0, 2 );
         nFileSize = psSHP->sHooks.FTell( psSHP->fpSHX );
         if( nFileSize > 100 &&
             nFileSize/2 < (SAOffset)(psSHP->nRecords * 4 + 50) )
         {
             psSHP->nRecords = (int)((nFileSize - 100) / 8);
         }
         psSHP->sHooks.FSeek( psSHP->fpSHX, 100, 0 );
     }
 
 /* -------------------------------------------------------------------- */
 /*      Read the bounds.                                                */
 /* -------------------------------------------------------------------- */
     if( bBigEndian ) SwapWord( 8, pabyBuf+36 );
     memcpy( &dValue, pabyBuf+36, 8 );
     psSHP->adBoundsMin[0] = dValue;
 
     if( bBigEndian ) SwapWord( 8, pabyBuf+44 );
     memcpy( &dValue, pabyBuf+44, 8 );
     psSHP->adBoundsMin[1] = dValue;
 
     if( bBigEndian ) SwapWord( 8, pabyBuf+52 );
     memcpy( &dValue, pabyBuf+52, 8 );
     psSHP->adBoundsMax[0] = dValue;
 
     if( bBigEndian ) SwapWord( 8, pabyBuf+60 );
     memcpy( &dValue, pabyBuf+60, 8 );
     psSHP->adBoundsMax[1] = dValue;
 
     if( bBigEndian ) SwapWord( 8, pabyBuf+68 );     /* z */
     memcpy( &dValue, pabyBuf+68, 8 );
     psSHP->adBoundsMin[2] = dValue;
 
     if( bBigEndian ) SwapWord( 8, pabyBuf+76 );
     memcpy( &dValue, pabyBuf+76, 8 );
     psSHP->adBoundsMax[2] = dValue;
 
     if( bBigEndian ) SwapWord( 8, pabyBuf+84 );     /* z */
     memcpy( &dValue, pabyBuf+84, 8 );
     psSHP->adBoundsMin[3] = dValue;
 
     if( bBigEndian ) SwapWord( 8, pabyBuf+92 );
     memcpy( &dValue, pabyBuf+92, 8 );
     psSHP->adBoundsMax[3] = dValue;
 
     free( pabyBuf );
 
 /* -------------------------------------------------------------------- */
 /*  Read the .shx file to get the offsets to each record in     */
 /*  the .shp file.                          */
 /* -------------------------------------------------------------------- */
     psSHP->nMaxRecords = psSHP->nRecords;
 
     psSHP->panRecOffset = (unsigned int *)
         malloc(sizeof(unsigned int) * MAX(1,psSHP->nMaxRecords) );
     psSHP->panRecSize = (unsigned int *)
         malloc(sizeof(unsigned int) * MAX(1,psSHP->nMaxRecords) );
     if( bLazySHXLoading )
         pabyBuf = NULL;
     else
         pabyBuf = (uchar *) malloc(8 * MAX(1,psSHP->nRecords) );
 
     if (psSHP->panRecOffset == NULL ||
         psSHP->panRecSize == NULL ||
         (!bLazySHXLoading && pabyBuf == NULL))
     {
         char szErrorMsg[200];
 
         snprintf( szErrorMsg, sizeof(szErrorMsg),
                 "Not enough memory to allocate requested memory (nRecords=%d).\n"
                 "Probably broken SHP file",
                 psSHP->nRecords );
         szErrorMsg[sizeof(szErrorMsg)-1] = '\0';
         psSHP->sHooks.Error( szErrorMsg );
         psSHP->sHooks.FClose( psSHP->fpSHP );
         psSHP->sHooks.FClose( psSHP->fpSHX );
         if (psSHP->panRecOffset) free( psSHP->panRecOffset );
         if (psSHP->panRecSize) free( psSHP->panRecSize );
         if (pabyBuf) free( pabyBuf );
         free( psSHP );
         return( NULL );
     }
 
     if( bLazySHXLoading )
     {
         memset(psSHP->panRecOffset, 0, sizeof(unsigned int) * MAX(1,psSHP->nMaxRecords) );
         memset(psSHP->panRecSize, 0, sizeof(unsigned int) * MAX(1,psSHP->nMaxRecords) );
         return( psSHP );
     }
 
     if( (int) psSHP->sHooks.FRead( pabyBuf, 8, psSHP->nRecords, psSHP->fpSHX )
         != psSHP->nRecords )
     {
         char szErrorMsg[200];
 
         snprintf( szErrorMsg, sizeof(szErrorMsg),
                  "Failed to read all values for %d records in .shx file: %s.",
                  psSHP->nRecords, strerror(errno) );
         szErrorMsg[sizeof(szErrorMsg)-1] = '\0';
         psSHP->sHooks.Error( szErrorMsg );
 
         /* SHX is short or unreadable for some reason. */
         psSHP->sHooks.FClose( psSHP->fpSHP );
         psSHP->sHooks.FClose( psSHP->fpSHX );
         free( psSHP->panRecOffset );
         free( psSHP->panRecSize );
         free( pabyBuf );
         free( psSHP );
 
         return( NULL );
     }
 
     /* In read-only mode, we can close the SHX now */
     if (strcmp(pszAccess, "rb") == 0)
     {
         psSHP->sHooks.FClose( psSHP->fpSHX );
         psSHP->fpSHX = NULL;
     }
 
     for( i = 0; i < psSHP->nRecords; i++ )
     {
         unsigned int        nOffset, nLength;
 
         memcpy( &nOffset, pabyBuf + i * 8, 4 );
         if( !bBigEndian ) SwapWord( 4, &nOffset );
 
         memcpy( &nLength, pabyBuf + i * 8 + 4, 4 );
         if( !bBigEndian ) SwapWord( 4, &nLength );
 
         if( nOffset > (unsigned int)INT_MAX )
         {
             char str[128];
             snprintf( str, sizeof(str),
                     "Invalid offset for entity %d", i);
             str[sizeof(str)-1] = '\0';
 
             psSHP->sHooks.Error( str );
             SHPClose(psSHP);
             free( pabyBuf );
             return NULL;
         }
         if( nLength > (unsigned int)(INT_MAX / 2 - 4) )
         {
             char str[128];
             snprintf( str, sizeof(str),
                     "Invalid length for entity %d", i);
             str[sizeof(str)-1] = '\0';
 
             psSHP->sHooks.Error( str );
             SHPClose(psSHP);
             free( pabyBuf );
             return NULL;
         }
         psSHP->panRecOffset[i] = nOffset*2;
         psSHP->panRecSize[i] = nLength*2;
     }
     free( pabyBuf );
 
     return( psSHP );
 }
 
 /************************************************************************/
 /*                              SHPOpenLLEx()                           */
 /*                                                                      */
 /*      Open the .shp and .shx files based on the basename of the       */
 /*      files or either file name. It generally invokes SHPRestoreSHX() */
 /*      in case when bRestoreSHX equals true.                           */
 /************************************************************************/
@@ -937,194 +940,179 @@ int       SHPAPI_CALL
 SHPRestoreSHX ( const char * pszLayer, const char * pszAccess, SAHooks *psHooks )
 
 {
-    char            *pszFullname, *pszBasename;
+    char            *pszFullname;
     SAFile          fpSHP, fpSHX;
 
 
     uchar           *pabyBuf;
-    int             i;
-    size_t          nFullnameLen;
+    int             nLenWithoutExtension;
     unsigned int    nSHPFilesize;
 
-    size_t          nMessageLen;
-    char            *pszMessage;
-
     unsigned int    nCurrentRecordOffset = 0;
     unsigned int    nCurrentSHPOffset = 100;
     size_t          nRealSHXContentSize = 100;
 
     const char      pszSHXAccess[] = "w+b";
     char            *pabySHXHeader;
     char            abyReadedRecord[8];
     unsigned int    niRecord = 0;
     unsigned int    nRecordLength = 0;
     unsigned int    nRecordOffset = 50;
 
 /* -------------------------------------------------------------------- */
 /*      Ensure the access string is one of the legal ones.  We          */
 /*      ensure the result string indicates binary to avoid common       */
 /*      problems on Windows.                                            */
 /* -------------------------------------------------------------------- */
     if( strcmp(pszAccess,"rb+") == 0 || strcmp(pszAccess,"r+b") == 0
         || strcmp(pszAccess,"r+") == 0 )
         pszAccess = "r+b";
     else
     {
         pszAccess = "rb";
     }
 
 /* -------------------------------------------------------------------- */
 /*  Establish the byte order on this machine.                           */
 /* -------------------------------------------------------------------- */
 #if !defined(bBigEndian)
     i = 1;
     if( *((uchar *) &i) == 1 )
         bBigEndian = FALSE;
     else
         bBigEndian = TRUE;
 #endif
 
-/* -------------------------------------------------------------------- */
-/*  Compute the base (layer) name.  If there is any extension           */
-/*  on the passed in filename we will strip it off.                     */
-/* -------------------------------------------------------------------- */
-    pszBasename = (char *) malloc(strlen(pszLayer)+5);
-    strcpy( pszBasename, pszLayer );
-    for( i = (int)strlen(pszBasename)-1;
-         i > 0 && pszBasename[i] != '/' && pszBasename[i] != '\\';
-         i-- )
-    {
-        if( pszBasename[i] == '.' )
-        {
-            pszBasename[i] = '\0';
-            break;
-        }
-    }
-
 /* -------------------------------------------------------------------- */
 /*  Open the .shp file.  Note that files pulled from                    */
 /*  a PC to Unix with upper case filenames won't work!                  */
 /* -------------------------------------------------------------------- */
-    nFullnameLen = strlen(pszBasename) + 5;
-    pszFullname = (char *) malloc(nFullnameLen);
-    snprintf( pszFullname, nFullnameLen, "%s.shp", pszBasename ) ;
+    nLenWithoutExtension = SHPGetLenWithoutExtension(pszLayer);
+    pszFullname = (char *) malloc(nLenWithoutExtension + 5);
+    memcpy(pszFullname, pszLayer, nLenWithoutExtension);
+    memcpy(pszFullname + nLenWithoutExtension, ".shp", 5);
     fpSHP = psHooks->FOpen(pszFullname, pszAccess );
     if( fpSHP == NULL )
     {
-        snprintf( pszFullname, nFullnameLen, "%s.SHP", pszBasename );
+        memcpy(pszFullname + nLenWithoutExtension, ".SHP", 5);
         fpSHP = psHooks->FOpen(pszFullname, pszAccess );
     }
 
     if( fpSHP == NULL )
     {
-        nMessageLen = strlen(pszBasename)*2+256;
-        pszMessage = (char *) malloc(nMessageLen);
+        size_t nMessageLen = strlen( pszFullname ) * 2 + 256;
+        char* pszMessage = (char *) malloc( nMessageLen );
+
+        pszFullname[nLenWithoutExtension] = 0;
         snprintf( pszMessage, nMessageLen, "Unable to open %s.shp or %s.SHP.",
-                  pszBasename, pszBasename );
+                  pszFullname, pszFullname );
         psHooks->Error( pszMessage );
         free( pszMessage );
 
-        free( pszBasename );
         free( pszFullname );
 
         return( 0 );
     }
 
 /* -------------------------------------------------------------------- */
 /*  Read the file size from the SHP file.                               */
 /* -------------------------------------------------------------------- */
     pabyBuf = (uchar *) malloc(100);
     psHooks->FRead( pabyBuf, 100, 1, fpSHP );
 
     nSHPFilesize = ((unsigned int)pabyBuf[24]<<24)|(pabyBuf[25]<<16)|
                    (pabyBuf[26]<<8)|pabyBuf[27];
     if( nSHPFilesize < UINT_MAX / 2 )
         nSHPFilesize *= 2;
     else
         nSHPFilesize = (UINT_MAX / 2) * 2;
 
-    snprintf( pszFullname, nFullnameLen, "%s.shx", pszBasename );
+    memcpy(pszFullname + nLenWithoutExtension, ".shx", 5);
     fpSHX = psHooks->FOpen( pszFullname, pszSHXAccess );
+    if( fpSHX == NULL )
+    {
+        memcpy(pszFullname + nLenWithoutExtension, ".SHX", 5);
+        fpSHP = psHooks->FOpen(pszFullname, pszAccess );
+    }
 
     if( fpSHX == NULL )
     {
-        nMessageLen = strlen( pszBasename ) * 2 + 256;
-        pszMessage = (char *) malloc( nMessageLen );
-        snprintf( pszMessage, nMessageLen, "Error opening file %s.shx for writing",
-                 pszBasename );
+        size_t nMessageLen = strlen( pszFullname ) * 2 + 256;
+        char* pszMessage = (char *) malloc( nMessageLen );
+        pszFullname[nLenWithoutExtension] = 0;
+        snprintf( pszMessage, nMessageLen,
+                  "Error opening file %s.shx or %s.SHX for writing",
+                  pszFullname, pszFullname );
         psHooks->Error( pszMessage );
         free( pszMessage );
 
         psHooks->FClose( fpSHX );
 
         free( pabyBuf );
-        free( pszBasename );
         free( pszFullname );
 
         return( 0 );
     }
 
 /* -------------------------------------------------------------------- */
 /*  Open SHX and create it using SHP file content.                      */
 /* -------------------------------------------------------------------- */
     psHooks->FSeek( fpSHP, 100, 0 );
     pabySHXHeader = (char *) malloc ( 100 );
     memcpy( pabySHXHeader, pabyBuf, 100 );
     psHooks->FWrite( pabySHXHeader, 100, 1, fpSHX );
 
     while( nCurrentSHPOffset < nSHPFilesize )
     {
         if( psHooks->FRead( &niRecord, 4, 1, fpSHP ) == 1 &&
             psHooks->FRead( &nRecordLength, 4, 1, fpSHP ) == 1)
         {
             if( !bBigEndian ) SwapWord( 4, &nRecordOffset );
             memcpy( abyReadedRecord, &nRecordOffset, 4 );
             memcpy( abyReadedRecord + 4, &nRecordLength, 4 );
 
             psHooks->FWrite( abyReadedRecord, 8, 1, fpSHX );
 
             if ( !bBigEndian ) SwapWord( 4, &nRecordOffset );
             if ( !bBigEndian ) SwapWord( 4, &nRecordLength );
             nRecordOffset += nRecordLength + 4;
             nCurrentRecordOffset += 8;
             nCurrentSHPOffset += 8 + nRecordLength * 2;
 
             psHooks->FSeek( fpSHP, nCurrentSHPOffset, 0 );
             nRealSHXContentSize += 8;
         }
         else
         {
             psHooks->Error( "Error parsing .shp to restore .shx"  );
 
             psHooks->FClose( fpSHX );
             psHooks->FClose( fpSHP );
 
             free( pabySHXHeader );
-            free( pszBasename );
             free( pszFullname );
 
             return( 0 );
         }
     }
 
     nRealSHXContentSize /= 2; // Bytes counted -> WORDs
     if( !bBigEndian ) SwapWord( 4, &nRealSHXContentSize );
     psHooks->FSeek( fpSHX, 24, 0 );
     psHooks->FWrite( &nRealSHXContentSize, 4, 1, fpSHX );
 
     psHooks->FClose( fpSHP );
     psHooks->FClose( fpSHX );
 
     free ( pabyBuf );
     free ( pszFullname );
-    free ( pszBasename );
     free ( pabySHXHeader );
 
     return( 1 );
 }
 
 /************************************************************************/
 /*                              SHPClose()                              */
 /*								       	*/
 /*	Close the .shp and .shx files.					*/
 /************************************************************************/
@@ -1251,151 +1239,135 @@ SHPHandle SHPAPI_CALL
 SHPCreateLL( const char * pszLayer, int nShapeType, SAHooks *psHooks )
 
 {
-    char	*pszBasename = NULL, *pszFullname = NULL;
-    int		i;
+    char	*pszFullname = NULL;
     SAFile	fpSHP = NULL, fpSHX = NULL;
     uchar     	abyHeader[100];
     int32	i32;
     double	dValue;
-    size_t      nFullnameLen;
+    int         nLenWithoutExtension;
 
 /* -------------------------------------------------------------------- */
 /*      Establish the byte order on this system.                        */
 /* -------------------------------------------------------------------- */
 #if !defined(bBigEndian)
     i = 1;
     if( *((uchar *) &i) == 1 )
         bBigEndian = FALSE;
     else
         bBigEndian = TRUE;
 #endif
 
-/* -------------------------------------------------------------------- */
-/*	Compute the base (layer) name.  If there is any extension	*/
-/*	on the passed in filename we will strip it off.			*/
-/* -------------------------------------------------------------------- */
-    pszBasename = (char *) malloc(strlen(pszLayer)+5);
-    strcpy( pszBasename, pszLayer );
-    for( i = (int)strlen(pszBasename)-1;
-         i > 0 && pszBasename[i] != '.' && pszBasename[i] != '/'
-             && pszBasename[i] != '\\';
-         i-- ) {}
-
-    if( pszBasename[i] == '.' )
-        pszBasename[i] = '\0';
-
 /* -------------------------------------------------------------------- */
 /*      Open the two files so we can write their headers.               */
 /* -------------------------------------------------------------------- */
-    nFullnameLen = strlen(pszBasename) + 5;
-    pszFullname = (char *) malloc(nFullnameLen);
-    snprintf( pszFullname, nFullnameLen, "%s.shp", pszBasename );
+    nLenWithoutExtension = SHPGetLenWithoutExtension(pszLayer);
+    pszFullname = (char *) malloc(nLenWithoutExtension + 5);
+    memcpy(pszFullname, pszLayer, nLenWithoutExtension);
+    memcpy(pszFullname + nLenWithoutExtension, ".shp", 5);
     fpSHP = psHooks->FOpen(pszFullname, "wb" );
     if( fpSHP == NULL )
     {
         char szErrorMsg[200];
         snprintf( szErrorMsg, sizeof(szErrorMsg),
                  "Failed to create file %s: %s",
                   pszFullname, strerror(errno) );
         psHooks->Error( szErrorMsg );
 
         goto error;
     }
 
-    snprintf( pszFullname, nFullnameLen, "%s.shx", pszBasename );
+    memcpy(pszFullname + nLenWithoutExtension, ".shx", 5);
     fpSHX = psHooks->FOpen(pszFullname, "wb" );
     if( fpSHX == NULL )
     {
         char szErrorMsg[200];
         snprintf( szErrorMsg, sizeof(szErrorMsg),
                  "Failed to create file %s: %s",
                   pszFullname, strerror(errno) );
         psHooks->Error( szErrorMsg );
         goto error;
     }
 
     free( pszFullname ); pszFullname = NULL;
-    free( pszBasename ); pszBasename = NULL;
 
 /* -------------------------------------------------------------------- */
 /*      Prepare header block for .shp file.                             */
 /* -------------------------------------------------------------------- */
     memset( abyHeader, 0, sizeof(abyHeader) );
 
     abyHeader[2] = 0x27;				/* magic cookie */
     abyHeader[3] = 0x0a;
 
     i32 = 50;						/* file size */
     ByteCopy( &i32, abyHeader+24, 4 );
     if( !bBigEndian ) SwapWord( 4, abyHeader+24 );
 
     i32 = 1000;						/* version */
     ByteCopy( &i32, abyHeader+28, 4 );
     if( bBigEndian ) SwapWord( 4, abyHeader+28 );
 
     i32 = nShapeType;					/* shape type */
     ByteCopy( &i32, abyHeader+32, 4 );
     if( bBigEndian ) SwapWord( 4, abyHeader+32 );
 
     dValue = 0.0;					/* set bounds */
     ByteCopy( &dValue, abyHeader+36, 8 );
     ByteCopy( &dValue, abyHeader+44, 8 );
     ByteCopy( &dValue, abyHeader+52, 8 );
     ByteCopy( &dValue, abyHeader+60, 8 );
 
 /* -------------------------------------------------------------------- */
 /*      Write .shp file header.                                         */
 /* -------------------------------------------------------------------- */
     if( psHooks->FWrite( abyHeader, 100, 1, fpSHP ) != 1 )
     {
         char szErrorMsg[200];
 
         snprintf( szErrorMsg, sizeof(szErrorMsg),
                  "Failed to write .shp header: %s", strerror(errno) );
         szErrorMsg[sizeof(szErrorMsg)-1] = '\0';
         psHooks->Error( szErrorMsg );
 
         goto error;
     }
 
 /* -------------------------------------------------------------------- */
 /*      Prepare, and write .shx file header.                            */
 /* -------------------------------------------------------------------- */
     i32 = 50;						/* file size */
     ByteCopy( &i32, abyHeader+24, 4 );
     if( !bBigEndian ) SwapWord( 4, abyHeader+24 );
 
     if( psHooks->FWrite( abyHeader, 100, 1, fpSHX ) != 1 )
     {
         char szErrorMsg[200];
 
         snprintf( szErrorMsg, sizeof(szErrorMsg),
                  "Failure writing .shx header: %s", strerror(errno) );
         szErrorMsg[sizeof(szErrorMsg)-1] = '\0';
         psHooks->Error( szErrorMsg );
 
         goto error;
     }
 
 /* -------------------------------------------------------------------- */
 /*      Close the files, and then open them as regular existing files.  */
 /* -------------------------------------------------------------------- */
     psHooks->FClose( fpSHP );
     psHooks->FClose( fpSHX );
 
     return( SHPOpenLL( pszLayer, "r+b", psHooks ) );
 
 error:
     if (pszFullname) free(pszFullname);
-    if (pszBasename) free(pszBasename);
     if (fpSHP) psHooks->FClose( fpSHP );
     if (fpSHX) psHooks->FClose( fpSHX );
     return NULL;
 }
 
 /************************************************************************/
 /*                           _SHPSetBounds()                            */
 /*                                                                      */
 /*      Compute a bounds rectangle for a shape, and set it into the     */
 /*      indicated location in the record.                               */
 /************************************************************************/
