commit 11c89c386c8862f834097cdc5d9ed79634cf00f3
Author: Edward Thomson <ethomson@edwardthomson.com>
Date:   Fri May 12 20:48:30 2023 +0100

    net: move `gitno` buffer to `staticstr`
    
    The `gitno` buffer interface is another layer on top of socket reads.
    Abstract it a bit into a "static string" that has `git_str` like
    semantics but without heap allocation which moves the actual reading
    logic into the socket / stream code, and allows for easier future usage
    of a static / stack-allocated `git_str`-like interface.

diff --git a/src/libgit2/fetch.c b/src/libgit2/fetch.c
index 5bbef87f4..d74abb4a8 100644
--- a/src/libgit2/fetch.c
+++ b/src/libgit2/fetch.c
@@ -1,23 +1,22 @@
 /*
  * Copyright (C) the libgit2 contributors. All rights reserved.
  *
  * This file is part of libgit2, distributed under the GNU GPL v2 with
  * a Linking Exception. For full terms see the included COPYING file.
  */
 
 #include "fetch.h"
 
 #include "git2/oid.h"
 #include "git2/refs.h"
 #include "git2/revwalk.h"
 #include "git2/transport.h"
 #include "git2/sys/remote.h"
 
 #include "oid.h"
 #include "remote.h"
 #include "refspec.h"
 #include "pack.h"
-#include "netops.h"
 #include "repository.h"
 #include "refs.h"
 #include "transports/smart.h"
diff --git a/src/libgit2/fetch.h b/src/libgit2/fetch.h
index 10b6731f0..493366ded 100644
--- a/src/libgit2/fetch.h
+++ b/src/libgit2/fetch.h
@@ -1,18 +1,16 @@
 /*
  * Copyright (C) the libgit2 contributors. All rights reserved.
  *
  * This file is part of libgit2, distributed under the GNU GPL v2 with
  * a Linking Exception. For full terms see the included COPYING file.
  */
 #ifndef INCLUDE_fetch_h__
 #define INCLUDE_fetch_h__
 
 #include "common.h"
 
 #include "git2/remote.h"
 
-#include "netops.h"
-
 int git_fetch_negotiate(git_remote *remote, const git_fetch_options *opts);
 
 int git_fetch_download_pack(git_remote *remote);
diff --git a/src/libgit2/netops.c b/src/libgit2/netops.c
deleted file mode 100644
index 5cae374ad..000000000
--- a/src/libgit2/netops.c
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright (C) the libgit2 contributors. All rights reserved.
- *
- * This file is part of libgit2, distributed under the GNU GPL v2 with
- * a Linking Exception. For full terms see the included COPYING file.
- */
-
-#include "netops.h"
-
-#include <ctype.h>
-#include "git2/errors.h"
-
-#include "posix.h"
-#include "str.h"
-#include "runtime.h"
-
-int gitno_recv(gitno_buffer *buf)
-{
-	return buf->recv(buf);
-}
-
-void gitno_buffer_setup_callback(
-	gitno_buffer *buf,
-	char *data,
-	size_t len,
-	int (*recv)(gitno_buffer *buf), void *cb_data)
-{
-	memset(data, 0x0, len);
-	buf->data = data;
-	buf->len = len;
-	buf->offset = 0;
-	buf->recv = recv;
-	buf->cb_data = cb_data;
-}
-
-static int recv_stream(gitno_buffer *buf)
-{
-	git_stream *io = (git_stream *) buf->cb_data;
-	size_t readlen = buf->len - buf->offset;
-	ssize_t ret;
-
-	readlen = min(readlen, INT_MAX);
-
-	ret = git_stream_read(io, buf->data + buf->offset, (int)readlen);
-	if (ret < 0)
-		return -1;
-
-	buf->offset += ret;
-	return (int)ret;
-}
-
-void gitno_buffer_setup_fromstream(git_stream *st, gitno_buffer *buf, char *data, size_t len)
-{
-	memset(data, 0x0, len);
-	buf->data = data;
-	buf->len = len;
-	buf->offset = 0;
-	buf->recv = recv_stream;
-	buf->cb_data = st;
-}
-
-/* Consume up to ptr and move the rest of the buffer to the beginning */
-int gitno_consume(gitno_buffer *buf, const char *ptr)
-{
-	size_t consumed;
-
-	GIT_ASSERT(ptr - buf->data >= 0);
-	GIT_ASSERT(ptr - buf->data <= (int) buf->len);
-
-	consumed = ptr - buf->data;
-
-	memmove(buf->data, ptr, buf->offset - consumed);
-	memset(buf->data + buf->offset, 0x0, buf->len - buf->offset);
-	buf->offset -= consumed;
-
-	return 0;
-}
-
-/* Consume const bytes and move the rest of the buffer to the beginning */
-void gitno_consume_n(gitno_buffer *buf, size_t cons)
-{
-	memmove(buf->data, buf->data + cons, buf->len - buf->offset);
-	memset(buf->data + cons, 0x0, buf->len - buf->offset);
-	buf->offset -= cons;
-}
diff --git a/src/libgit2/netops.h b/src/libgit2/netops.h
deleted file mode 100644
index a3f4a0f95..000000000
--- a/src/libgit2/netops.h
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) the libgit2 contributors. All rights reserved.
- *
- * This file is part of libgit2, distributed under the GNU GPL v2 with
- * a Linking Exception. For full terms see the included COPYING file.
- */
-#ifndef INCLUDE_netops_h__
-#define INCLUDE_netops_h__
-
-#include "common.h"
-
-#include "posix.h"
-#include "stream.h"
-#include "net.h"
-
-#ifdef GIT_OPENSSL
-# include "streams/openssl.h"
-#endif
-
-typedef struct gitno_ssl {
-#ifdef GIT_OPENSSL
-	SSL *ssl;
-#else
-	size_t dummy;
-#endif
-} gitno_ssl;
-
-/* Represents a socket that may or may not be using SSL */
-typedef struct gitno_socket {
-	GIT_SOCKET socket;
-	gitno_ssl ssl;
-} gitno_socket;
-
-typedef struct gitno_buffer {
-	char *data;
-	size_t len;
-	size_t offset;
-	int (*recv)(struct gitno_buffer *buffer);
-	void *cb_data;
-} gitno_buffer;
-
-/* Flags to gitno_connect */
-enum {
-	/* Attempt to create an SSL connection. */
-	GITNO_CONNECT_SSL = 1
-};
-
-void gitno_buffer_setup_fromstream(git_stream *st, gitno_buffer *buf, char *data, size_t len);
-void gitno_buffer_setup_callback(gitno_buffer *buf, char *data, size_t len, int (*recv)(gitno_buffer *buf), void *cb_data);
-int gitno_recv(gitno_buffer *buf);
-
-int gitno_consume(gitno_buffer *buf, const char *ptr);
-void gitno_consume_n(gitno_buffer *buf, size_t cons);
-
-#endif
diff --git a/src/libgit2/pack-objects.c b/src/libgit2/pack-objects.c
index fc8efc65f..b2d80cba9 100644
--- a/src/libgit2/pack-objects.c
+++ b/src/libgit2/pack-objects.c
@@ -1,26 +1,25 @@
 /*
  * Copyright (C) the libgit2 contributors. All rights reserved.
  *
  * This file is part of libgit2, distributed under the GNU GPL v2 with
  * a Linking Exception. For full terms see the included COPYING file.
  */
 
 #include "pack-objects.h"
 
 #include "buf.h"
 #include "zstream.h"
 #include "delta.h"
 #include "iterator.h"
-#include "netops.h"
 #include "pack.h"
 #include "thread.h"
 #include "tree.h"
 #include "util.h"
 #include "revwalk.h"
 #include "commit_list.h"
 
 #include "git2/pack.h"
 #include "git2/commit.h"
 #include "git2/tag.h"
 #include "git2/indexer.h"
 #include "git2/config.h"
diff --git a/src/libgit2/pack-objects.h b/src/libgit2/pack-objects.h
index 0ceebc23c..bbc8b9430 100644
--- a/src/libgit2/pack-objects.h
+++ b/src/libgit2/pack-objects.h
@@ -1,28 +1,27 @@
 /*
  * Copyright (C) the libgit2 contributors. All rights reserved.
  *
  * This file is part of libgit2, distributed under the GNU GPL v2 with
  * a Linking Exception. For full terms see the included COPYING file.
  */
 
 #ifndef INCLUDE_pack_objects_h__
 #define INCLUDE_pack_objects_h__
 
 #include "common.h"
 
 #include "str.h"
 #include "hash.h"
 #include "oidmap.h"
-#include "netops.h"
 #include "zstream.h"
 #include "pool.h"
 #include "indexer.h"
 
 #include "git2/oid.h"
 #include "git2/pack.h"
 
 #define GIT_PACK_WINDOW 10 /* number of objects to possibly delta against */
 #define GIT_PACK_DEPTH 50 /* max delta depth */
 #define GIT_PACK_DELTA_CACHE_SIZE (256 * 1024 * 1024)
 #define GIT_PACK_DELTA_CACHE_LIMIT 1000
 #define GIT_PACK_BIG_FILE_THRESHOLD (512 * 1024 * 1024)
diff --git a/src/libgit2/streams/mbedtls.c b/src/libgit2/streams/mbedtls.c
index 0cf5c8af1..49aa76c3e 100644
--- a/src/libgit2/streams/mbedtls.c
+++ b/src/libgit2/streams/mbedtls.c
@@ -1,45 +1,44 @@
 /*
  * Copyright (C) the libgit2 contributors. All rights reserved.
  *
  * This file is part of libgit2, distributed under the GNU GPL v2 with
  * a Linking Exception. For full terms see the included COPYING file.
  */
 
 #include "streams/mbedtls.h"
 
 #ifdef GIT_MBEDTLS
 
 #include <ctype.h>
 
 #include "runtime.h"
 #include "stream.h"
 #include "streams/socket.h"
-#include "netops.h"
 #include "git2/transport.h"
 #include "util.h"
 
 #ifndef GIT_DEFAULT_CERT_LOCATION
 #define GIT_DEFAULT_CERT_LOCATION NULL
 #endif
 
 /* Work around C90-conformance issues */
 #if !defined(__STDC_VERSION__) || (__STDC_VERSION__ < 199901L)
 # if defined(_MSC_VER)
 #  define inline __inline
 # elif defined(__GNUC__)
 #  define inline __inline__
 # else
 #  define inline
 # endif
 #endif
 
 #include <mbedtls/config.h>
 #include <mbedtls/ssl.h>
 #include <mbedtls/error.h>
 #include <mbedtls/entropy.h>
 #include <mbedtls/ctr_drbg.h>
 
 #undef inline
 
 #define GIT_SSL_DEFAULT_CIPHERS "TLS-ECDHE-ECDSA-WITH-AES-128-GCM-SHA256:TLS-ECDHE-RSA-WITH-AES-128-GCM-SHA256:TLS-ECDHE-ECDSA-WITH-AES-256-GCM-SHA384:TLS-ECDHE-RSA-WITH-AES-256-GCM-SHA384:TLS-DHE-RSA-WITH-AES-128-GCM-SHA256:TLS-DHE-DSS-WITH-AES-128-GCM-SHA256:TLS-DHE-RSA-WITH-AES-256-GCM-SHA384:TLS-DHE-DSS-WITH-AES-256-GCM-SHA384:TLS-ECDHE-ECDSA-WITH-AES-128-CBC-SHA256:TLS-ECDHE-RSA-WITH-AES-128-CBC-SHA256:TLS-ECDHE-ECDSA-WITH-AES-128-CBC-SHA:TLS-ECDHE-RSA-WITH-AES-128-CBC-SHA:TLS-ECDHE-ECDSA-WITH-AES-256-CBC-SHA384:TLS-ECDHE-RSA-WITH-AES-256-CBC-SHA384:TLS-ECDHE-ECDSA-WITH-AES-256-CBC-SHA:TLS-ECDHE-RSA-WITH-AES-256-CBC-SHA:TLS-DHE-RSA-WITH-AES-128-CBC-SHA256:TLS-DHE-RSA-WITH-AES-256-CBC-SHA256:TLS-DHE-RSA-WITH-AES-128-CBC-SHA:TLS-DHE-RSA-WITH-AES-256-CBC-SHA:TLS-DHE-DSS-WITH-AES-128-CBC-SHA256:TLS-DHE-DSS-WITH-AES-256-CBC-SHA256:TLS-DHE-DSS-WITH-AES-128-CBC-SHA:TLS-DHE-DSS-WITH-AES-256-CBC-SHA:TLS-RSA-WITH-AES-128-GCM-SHA256:TLS-RSA-WITH-AES-256-GCM-SHA384:TLS-RSA-WITH-AES-128-CBC-SHA256:TLS-RSA-WITH-AES-256-CBC-SHA256:TLS-RSA-WITH-AES-128-CBC-SHA:TLS-RSA-WITH-AES-256-CBC-SHA"
 #define GIT_SSL_DEFAULT_CIPHERS_COUNT 30
diff --git a/src/libgit2/streams/openssl.c b/src/libgit2/streams/openssl.c
index 58b2d1b23..9db911e39 100644
--- a/src/libgit2/streams/openssl.c
+++ b/src/libgit2/streams/openssl.c
@@ -1,38 +1,37 @@
 /*
  * Copyright (C) the libgit2 contributors. All rights reserved.
  *
  * This file is part of libgit2, distributed under the GNU GPL v2 with
  * a Linking Exception. For full terms see the included COPYING file.
  */
 
 #include "streams/openssl.h"
 #include "streams/openssl_legacy.h"
 #include "streams/openssl_dynamic.h"
 
 #ifdef GIT_OPENSSL
 
 #include <ctype.h>
 
 #include "common.h"
 #include "runtime.h"
 #include "settings.h"
 #include "posix.h"
 #include "stream.h"
 #include "net.h"
 #include "streams/socket.h"
-#include "netops.h"
 #include "git2/transport.h"
 #include "git2/sys/openssl.h"
 
 #ifndef GIT_WIN32
 # include <sys/types.h>
 # include <sys/socket.h>
 # include <netinet/in.h>
 #endif
 
 #ifndef GIT_OPENSSL_DYNAMIC
 # include <openssl/ssl.h>
 # include <openssl/err.h>
 # include <openssl/x509v3.h>
 # include <openssl/bio.h>
 #endif
@@ -68,17 +67,17 @@ static void shutdown_ssl(void)
 static void *git_openssl_malloc(size_t bytes, const char *file, int line)
 {
 	GIT_UNUSED(file);
 	GIT_UNUSED(line);
 	return git__calloc(1, bytes);
 }
- 
+
 static void *git_openssl_realloc(void *mem, size_t size, const char *file, int line)
 {
 	GIT_UNUSED(file);
 	GIT_UNUSED(line);
 	return git__realloc(mem, size);
 }
- 
+
 static void git_openssl_free(void *mem, const char *file, int line)
 {
 	GIT_UNUSED(file);
diff --git a/src/libgit2/streams/socket.c b/src/libgit2/streams/socket.c
index 8f23e746e..6994d58f2 100644
--- a/src/libgit2/streams/socket.c
+++ b/src/libgit2/streams/socket.c
@@ -1,32 +1,31 @@
 /*
  * Copyright (C) the libgit2 contributors. All rights reserved.
  *
  * This file is part of libgit2, distributed under the GNU GPL v2 with
  * a Linking Exception. For full terms see the included COPYING file.
  */
 
 #include "streams/socket.h"
 
 #include "posix.h"
-#include "netops.h"
 #include "registry.h"
 #include "runtime.h"
 #include "stream.h"
 
 #ifndef _WIN32
 # include <sys/types.h>
 # include <sys/socket.h>
 # include <sys/select.h>
 # include <sys/time.h>
 # include <netdb.h>
 # include <netinet/in.h>
 # include <arpa/inet.h>
 #else
 # include <winsock2.h>
 # include <ws2tcpip.h>
 # ifdef _MSC_VER
 #  pragma comment(lib, "ws2_32")
 # endif
 #endif
 
 #ifdef GIT_WIN32
diff --git a/src/libgit2/streams/socket.h b/src/libgit2/streams/socket.h
index 300e70893..73e8de099 100644
--- a/src/libgit2/streams/socket.h
+++ b/src/libgit2/streams/socket.h
@@ -1,15 +1,15 @@
 /*
  * Copyright (C) the libgit2 contributors. All rights reserved.
  *
  * This file is part of libgit2, distributed under the GNU GPL v2 with
  * a Linking Exception. For full terms see the included COPYING file.
  */
 #ifndef INCLUDE_streams_socket_h__
 #define INCLUDE_streams_socket_h__
 
 #include "common.h"
 
-#include "netops.h"
+#include "stream.h"
 
 typedef struct {
 	git_stream parent;
diff --git a/src/libgit2/transports/auth.h b/src/libgit2/transports/auth.h
index 64680cc53..9f6f8fd3b 100644
--- a/src/libgit2/transports/auth.h
+++ b/src/libgit2/transports/auth.h
@@ -1,16 +1,15 @@
 /*
  * Copyright (C) the libgit2 contributors. All rights reserved.
  *
  * This file is part of libgit2, distributed under the GNU GPL v2 with
  * a Linking Exception. For full terms see the included COPYING file.
  */
 
 #ifndef INCLUDE_transports_auth_h__
 #define INCLUDE_transports_auth_h__
 
 #include "common.h"
-
-#include "netops.h"
+#include "net.h"
 
 typedef enum {
 	GIT_HTTP_AUTH_BASIC = 1,
diff --git a/src/libgit2/transports/git.c b/src/libgit2/transports/git.c
index 591e2ab03..53611f2a7 100644
--- a/src/libgit2/transports/git.c
+++ b/src/libgit2/transports/git.c
@@ -1,15 +1,15 @@
 /*
  * Copyright (C) the libgit2 contributors. All rights reserved.
  *
  * This file is part of libgit2, distributed under the GNU GPL v2 with
  * a Linking Exception. For full terms see the included COPYING file.
  */
 
 #include "common.h"
 
-#include "netops.h"
+#include "net.h"
 #include "stream.h"
 #include "streams/socket.h"
 #include "git2/sys/transport.h"
 
 #define OWNING_SUBTRANSPORT(s) ((git_subtransport *)(s)->parent.subtransport)
@@ -92,25 +92,24 @@ cleanup:
 static int git_proto_stream_read(
 	git_smart_subtransport_stream *stream,
 	char *buffer,
 	size_t buf_size,
 	size_t *bytes_read)
 {
-	int error;
 	git_proto_stream *s = (git_proto_stream *)stream;
-	gitno_buffer buf;
+	ssize_t ret;
+	int error;
 
 	*bytes_read = 0;
 
 	if (!s->sent_command && (error = send_command(s)) < 0)
 		return error;
 
-	gitno_buffer_setup_fromstream(s->io, &buf, buffer, buf_size);
+	ret = git_stream_read(s->io, buffer, min(buf_size, INT_MAX));
 
-	if ((error = gitno_recv(&buf)) < 0)
-		return error;
-
-	*bytes_read = buf.offset;
+	if (ret < 0)
+		return -1;
 
+	*bytes_read = (size_t)ret;
 	return 0;
 }
 
diff --git a/src/libgit2/transports/http.c b/src/libgit2/transports/http.c
index cda76ae61..0534503bf 100644
--- a/src/libgit2/transports/http.c
+++ b/src/libgit2/transports/http.c
@@ -1,25 +1,24 @@
 /*
  * Copyright (C) the libgit2 contributors. All rights reserved.
  *
  * This file is part of libgit2, distributed under the GNU GPL v2 with
  * a Linking Exception. For full terms see the included COPYING file.
  */
 
 #include "common.h"
 
 #ifndef GIT_WINHTTP
 
 #include "http_parser.h"
 #include "net.h"
-#include "netops.h"
 #include "remote.h"
 #include "smart.h"
 #include "auth.h"
 #include "http.h"
 #include "auth_negotiate.h"
 #include "auth_ntlm.h"
 #include "trace.h"
 #include "streams/tls.h"
 #include "streams/socket.h"
 #include "httpclient.h"
 #include "git2/sys/credential.h"
diff --git a/src/libgit2/transports/smart.c b/src/libgit2/transports/smart.c
index a56524bff..537272828 100644
--- a/src/libgit2/transports/smart.c
+++ b/src/libgit2/transports/smart.c
@@ -13,30 +13,42 @@
 #include "refspec.h"
 #include "proxy.h"
 
-static int git_smart__recv_cb(gitno_buffer *buf)
+int git_smart__recv(transport_smart *t)
 {
-	transport_smart *t = (transport_smart *) buf->cb_data;
-	size_t old_len, bytes_read;
-	int error;
+	size_t bytes_read;
+	int ret;
 
+	GIT_ASSERT_ARG(t);
 	GIT_ASSERT(t->current_stream);
 
-	old_len = buf->offset;
+	if (git_staticstr_remain(&t->buffer) == 0) {
+		git_error_set(GIT_ERROR_NET, "out of buffer space");
+		return -1;
+	}
 
-	if ((error = t->current_stream->read(t->current_stream, buf->data + buf->offset, buf->len - buf->offset, &bytes_read)) < 0)
-		return error;
+	ret = t->current_stream->read(t->current_stream,
+		git_staticstr_offset(&t->buffer),
+		git_staticstr_remain(&t->buffer),
+		&bytes_read);
 
-	buf->offset += bytes_read;
+	if (ret < 0)
+		return ret;
+
+	GIT_ASSERT(bytes_read <= INT_MAX);
+	GIT_ASSERT(bytes_read <= git_staticstr_remain(&t->buffer));
+
+	git_staticstr_increase(&t->buffer, bytes_read);
 
 	if (t->packetsize_cb && !t->cancelled.val) {
-		error = t->packetsize_cb(bytes_read, t->packetsize_payload);
-		if (error) {
+		ret = t->packetsize_cb(bytes_read, t->packetsize_payload);
+
+		if (ret) {
 			git_atomic32_set(&t->cancelled, 1);
 			return GIT_EUSER;
 		}
 	}
 
-	return (int)(buf->offset - old_len);
+	return (int)bytes_read;
 }
 
 GIT_INLINE(int) git_smart__reset_stream(transport_smart *t, bool close_subtransport)
@@ -118,97 +130,95 @@ static void free_symrefs(git_vector *symrefs)
 static int git_smart__connect(
 	git_transport *transport,
 	const char *url,
 	int direction,
 	const git_remote_connect_options *connect_opts)
 {
 	transport_smart *t = GIT_CONTAINER_OF(transport, transport_smart, parent);
 	git_smart_subtransport_stream *stream;
 	int error;
 	git_pkt *pkt;
 	git_pkt_ref *first;
 	git_vector symrefs;
 	git_smart_service_t service;
 
 	if (git_smart__reset_stream(t, true) < 0)
 		return -1;
 
 	if (git_remote_connect_options_normalize(&t->connect_opts, t->owner->repo, connect_opts) < 0)
 		return -1;
 
 	t->url = git__strdup(url);
 	GIT_ERROR_CHECK_ALLOC(t->url);
 
 	t->direction = direction;
 
 	if (GIT_DIRECTION_FETCH == t->direction) {
 		service = GIT_SERVICE_UPLOADPACK_LS;
 	} else if (GIT_DIRECTION_PUSH == t->direction) {
 		service = GIT_SERVICE_RECEIVEPACK_LS;
 	} else {
 		git_error_set(GIT_ERROR_NET, "invalid direction");
 		return -1;
 	}
 
 	if ((error = t->wrapped->action(&stream, t->wrapped, t->url, service)) < 0)
 		return error;
 
 	/* Save off the current stream (i.e. socket) that we are working with */
 	t->current_stream = stream;
 
-	gitno_buffer_setup_callback(&t->buffer, t->buffer_data, sizeof(t->buffer_data), git_smart__recv_cb, t);
-
 	/* 2 flushes for RPC; 1 for stateful */
 	if ((error = git_smart__store_refs(t, t->rpc ? 2 : 1)) < 0)
 		return error;
 
 	/* Strip the comment packet for RPC */
 	if (t->rpc) {
 		pkt = (git_pkt *)git_vector_get(&t->refs, 0);
 
 		if (!pkt || GIT_PKT_COMMENT != pkt->type) {
 			git_error_set(GIT_ERROR_NET, "invalid response");
 			return -1;
 		} else {
 			/* Remove the comment pkt from the list */
 			git_vector_remove(&t->refs, 0);
 			git__free(pkt);
 		}
 	}
 
 	/* We now have loaded the refs. */
 	t->have_refs = 1;
 
 	pkt = (git_pkt *)git_vector_get(&t->refs, 0);
 	if (pkt && GIT_PKT_REF != pkt->type) {
 		git_error_set(GIT_ERROR_NET, "invalid response");
 		return -1;
 	}
 	first = (git_pkt_ref *)pkt;
 
 	if ((error = git_vector_init(&symrefs, 1, NULL)) < 0)
 		return error;
 
 	/* Detect capabilities */
 	if ((error = git_smart__detect_caps(first, &t->caps, &symrefs)) == 0) {
 		/* If the only ref in the list is capabilities^{} with OID_ZERO, remove it */
 		if (1 == t->refs.length && !strcmp(first->head.name, "capabilities^{}") &&
 			git_oid_is_zero(&first->head.oid)) {
 			git_vector_clear(&t->refs);
 			git_pkt_free((git_pkt *)first);
 		}
 
 		/* Keep a list of heads for _ls */
 		git_smart__update_heads(t, &symrefs);
 	} else if (error == GIT_ENOTFOUND) {
 		/* There was no ref packet received, or the cap list was empty */
 		error = 0;
 	} else {
 		git_error_set(GIT_ERROR_NET, "invalid response");
 		goto cleanup;
 	}
 
 	if (t->rpc && (error = git_smart__reset_stream(t, false)) < 0)
 		goto cleanup;
 
 	/* We're now logically connected. */
 	t->connected = 1;
@@ -290,57 +300,53 @@ static int git_smart__ls(const git_remote_head ***out, size_t *size, git_transpo
 int git_smart__negotiation_step(git_transport *transport, void *data, size_t len)
 {
 	transport_smart *t = GIT_CONTAINER_OF(transport, transport_smart, parent);
 	git_smart_subtransport_stream *stream;
 	int error;
 
 	if (t->rpc && git_smart__reset_stream(t, false) < 0)
 		return -1;
 
 	if (GIT_DIRECTION_FETCH != t->direction) {
 		git_error_set(GIT_ERROR_NET, "this operation is only valid for fetch");
 		return -1;
 	}
 
 	if ((error = t->wrapped->action(&stream, t->wrapped, t->url, GIT_SERVICE_UPLOADPACK)) < 0)
 		return error;
 
 	/* If this is a stateful implementation, the stream we get back should be the same */
 	GIT_ASSERT(t->rpc || t->current_stream == stream);
 
 	/* Save off the current stream (i.e. socket) that we are working with */
 	t->current_stream = stream;
 
 	if ((error = stream->write(stream, (const char *)data, len)) < 0)
 		return error;
 
-	gitno_buffer_setup_callback(&t->buffer, t->buffer_data, sizeof(t->buffer_data), git_smart__recv_cb, t);
-
 	return 0;
 }
 
 int git_smart__get_push_stream(transport_smart *t, git_smart_subtransport_stream **stream)
 {
 	int error;
 
 	if (t->rpc && git_smart__reset_stream(t, false) < 0)
 		return -1;
 
 	if (GIT_DIRECTION_PUSH != t->direction) {
 		git_error_set(GIT_ERROR_NET, "this operation is only valid for push");
 		return -1;
 	}
 
 	if ((error = t->wrapped->action(stream, t->wrapped, t->url, GIT_SERVICE_RECEIVEPACK)) < 0)
 		return error;
 
 	/* If this is a stateful implementation, the stream we get back should be the same */
 	GIT_ASSERT(t->rpc || t->current_stream == *stream);
 
 	/* Save off the current stream (i.e. socket) that we are working with */
 	t->current_stream = *stream;
 
-	gitno_buffer_setup_callback(&t->buffer, t->buffer_data, sizeof(t->buffer_data), git_smart__recv_cb, t);
-
 	return 0;
 }
 
@@ -474,49 +480,46 @@ int git_transport_remote_connect_options(
 int git_transport_smart(git_transport **out, git_remote *owner, void *param)
 {
 	transport_smart *t;
 	git_smart_subtransport_definition *definition = (git_smart_subtransport_definition *)param;
 
 	if (!param)
 		return -1;
 
 	t = git__calloc(1, sizeof(transport_smart));
 	GIT_ERROR_CHECK_ALLOC(t);
 
 	t->parent.version = GIT_TRANSPORT_VERSION;
 	t->parent.connect = git_smart__connect;
 	t->parent.set_connect_opts = git_smart__set_connect_opts;
 	t->parent.capabilities = git_smart__capabilities;
 #ifdef GIT_EXPERIMENTAL_SHA256
 	t->parent.oid_type = git_smart__oid_type;
 #endif
 	t->parent.close = git_smart__close;
 	t->parent.free = git_smart__free;
 	t->parent.negotiate_fetch = git_smart__negotiate_fetch;
 	t->parent.shallow_roots = git_smart__shallow_roots;
 	t->parent.download_pack = git_smart__download_pack;
 	t->parent.push = git_smart__push;
 	t->parent.ls = git_smart__ls;
 	t->parent.is_connected = git_smart__is_connected;
 	t->parent.cancel = git_smart__cancel;
 
 	t->owner = owner;
 	t->rpc = definition->rpc;
 
-	if (git_vector_init(&t->refs, 16, ref_name_cmp) < 0) {
+	if (git_vector_init(&t->refs, 16, ref_name_cmp) < 0 ||
+	    git_vector_init(&t->heads, 16, ref_name_cmp) < 0 ||
+	    definition->callback(&t->wrapped, &t->parent, definition->param) < 0) {
+		git_vector_free(&t->refs);
+		git_vector_free(&t->heads);
+		t->wrapped->free(t->wrapped);
 		git__free(t);
 		return -1;
 	}
 
-	if (git_vector_init(&t->heads, 16, ref_name_cmp) < 0) {
-		git__free(t);
-		return -1;
-	}
-
-	if (definition->callback(&t->wrapped, &t->parent, definition->param) < 0) {
-		git__free(t);
-		return -1;
-	}
+	git_staticstr_init(&t->buffer, GIT_SMART_BUFFER_SIZE);
 
 	*out = (git_transport *) t;
 	return 0;
 }
diff --git a/src/libgit2/transports/smart.h b/src/libgit2/transports/smart.h
index 34e27ea8e..52c7553a1 100644
--- a/src/libgit2/transports/smart.h
+++ b/src/libgit2/transports/smart.h
@@ -1,38 +1,40 @@
 /*
  * Copyright (C) the libgit2 contributors. All rights reserved.
  *
  * This file is part of libgit2, distributed under the GNU GPL v2 with
  * a Linking Exception. For full terms see the included COPYING file.
  */
 #ifndef INCLUDE_transports_smart_h__
 #define INCLUDE_transports_smart_h__
 
 #include "common.h"
 
 #include "git2.h"
 #include "vector.h"
-#include "netops.h"
 #include "push.h"
 #include "str.h"
 #include "oidarray.h"
+#include "staticstr.h"
 #include "git2/sys/transport.h"
 
+#define GIT_SMART_BUFFER_SIZE  65536
+
 #define GIT_SIDE_BAND_DATA     1
 #define GIT_SIDE_BAND_PROGRESS 2
 #define GIT_SIDE_BAND_ERROR    3
 
 #define GIT_CAP_OFS_DELTA "ofs-delta"
 #define GIT_CAP_MULTI_ACK "multi_ack"
 #define GIT_CAP_MULTI_ACK_DETAILED "multi_ack_detailed"
 #define GIT_CAP_SIDE_BAND "side-band"
 #define GIT_CAP_SIDE_BAND_64K "side-band-64k"
 #define GIT_CAP_INCLUDE_TAG "include-tag"
 #define GIT_CAP_DELETE_REFS "delete-refs"
 #define GIT_CAP_REPORT_STATUS "report-status"
 #define GIT_CAP_THIN_PACK "thin-pack"
 #define GIT_CAP_SYMREF "symref"
 #define GIT_CAP_WANT_TIP_SHA1 "allow-tip-sha1-in-want"
 #define GIT_CAP_WANT_REACHABLE_SHA1 "allow-reachable-sha1-in-want"
 #define GIT_CAP_SHALLOW "shallow"
 #define GIT_CAP_OBJECT_FORMAT "object-format="
 #define GIT_CAP_AGENT "agent="
@@ -154,24 +156,23 @@ typedef int (*packetsize_cb)(size_t received, void *payload);
 typedef struct {
 	git_transport parent;
 	git_remote *owner;
 	char *url;
 	git_remote_connect_options connect_opts;
 	int direction;
 	git_smart_subtransport *wrapped;
 	git_smart_subtransport_stream *current_stream;
 	transport_smart_caps caps;
 	git_vector refs;
 	git_vector heads;
 	git_vector common;
 	git_array_oid_t shallow_roots;
 	git_atomic32 cancelled;
 	packetsize_cb packetsize_cb;
 	void *packetsize_payload;
 	unsigned rpc : 1,
 	         have_refs : 1,
 	         connected : 1;
-	gitno_buffer buffer;
-	char buffer_data[65536];
+	git_staticstr_with_size(GIT_SMART_BUFFER_SIZE) buffer;
 } transport_smart;
 
 /* smart_protocol.c */
@@ -192,6 +193,8 @@ int git_smart__download_pack(
 	git_indexer_progress *stats);
 
 /* smart.c */
+int git_smart__recv(transport_smart *t);
+
 int git_smart__negotiation_step(git_transport *transport, void *data, size_t len);
 int git_smart__get_push_stream(transport_smart *t, git_smart_subtransport_stream **out);
 
diff --git a/src/libgit2/transports/smart_pkt.c b/src/libgit2/transports/smart_pkt.c
index 9127ad5fe..7805f3323 100644
--- a/src/libgit2/transports/smart_pkt.c
+++ b/src/libgit2/transports/smart_pkt.c
@@ -1,31 +1,30 @@
 /*
  * Copyright (C) the libgit2 contributors. All rights reserved.
  *
  * This file is part of libgit2, distributed under the GNU GPL v2 with
  * a Linking Exception. For full terms see the included COPYING file.
  */
 
 #include "common.h"
 
 #include "smart.h"
 #include "util.h"
-#include "netops.h"
 #include "posix.h"
 #include "str.h"
 #include "oid.h"
 
 #include "git2/types.h"
 #include "git2/errors.h"
 #include "git2/refs.h"
 #include "git2/revwalk.h"
 
 #include <ctype.h>
 
 #define PKT_DONE_STR    "0009done\n"
 #define PKT_FLUSH_STR   "0000"
 #define PKT_HAVE_PREFIX "have "
 #define PKT_WANT_PREFIX "want "
 
 #define PKT_LEN_SIZE    4
 #define PKT_MAX_SIZE    0xffff
 #define PKT_MAX_WANTLEN (PKT_LEN_SIZE + CONST_STRLEN(PKT_WANT_PREFIX) + GIT_OID_MAX_HEXSIZE + 1)
diff --git a/src/libgit2/transports/smart_protocol.c b/src/libgit2/transports/smart_protocol.c
index f7a567829..c9c422d4c 100644
--- a/src/libgit2/transports/smart_protocol.c
+++ b/src/libgit2/transports/smart_protocol.c
@@ -27,61 +27,61 @@ bool git_smart__ofs_delta_enabled = true;
 
 int git_smart__store_refs(transport_smart *t, int flushes)
 {
-	gitno_buffer *buf = &t->buffer;
 	git_vector *refs = &t->refs;
 	int error, flush = 0, recvd;
 	const char *line_end = NULL;
 	git_pkt *pkt = NULL;
 	git_pkt_parse_data pkt_parse_data = { 0 };
 	size_t i;
 
 	/* Clear existing refs in case git_remote_connect() is called again
 	 * after git_remote_disconnect().
 	 */
 	git_vector_foreach(refs, i, pkt) {
 		git_pkt_free(pkt);
 	}
 	git_vector_clear(refs);
 	pkt = NULL;
 
 	do {
-		if (buf->offset > 0)
-			error = git_pkt_parse_line(&pkt, &line_end, buf->data, buf->offset, &pkt_parse_data);
+		if (t->buffer.len > 0)
+			error = git_pkt_parse_line(&pkt, &line_end,
+				t->buffer.data, t->buffer.len,
+				&pkt_parse_data);
 		else
 			error = GIT_EBUFS;
 
 		if (error < 0 && error != GIT_EBUFS)
 			return error;
 
 		if (error == GIT_EBUFS) {
-			if ((recvd = gitno_recv(buf)) < 0)
+			if ((recvd = git_smart__recv(t)) < 0)
 				return recvd;
 
 			if (recvd == 0) {
 				git_error_set(GIT_ERROR_NET, "early EOF");
 				return GIT_EEOF;
 			}
 
 			continue;
 		}
 
-		if (gitno_consume(buf, line_end) < 0)
-			return -1;
+		git_staticstr_consume(&t->buffer, line_end);
 
 		if (pkt->type == GIT_PKT_ERR) {
 			git_error_set(GIT_ERROR_NET, "remote error: %s", ((git_pkt_err *)pkt)->error);
 			git__free(pkt);
 			return -1;
 		}
 
 		if (pkt->type != GIT_PKT_FLUSH && git_vector_insert(refs, pkt) < 0)
 			return -1;
 
 		if (pkt->type == GIT_PKT_FLUSH) {
 			flush++;
 			git_pkt_free(pkt);
 		}
 	} while (flush < flushes);
 
 	return flush;
 }
@@ -259,46 +259,45 @@ int git_smart__detect_caps(
 static int recv_pkt(
 	git_pkt **out_pkt,
 	git_pkt_type *out_type,
-	transport_smart *t,
-	gitno_buffer *buf)
+	transport_smart *t)
 {
-	const char *ptr = buf->data, *line_end = ptr;
+	const char *ptr = t->buffer.data, *line_end = ptr;
 	git_pkt *pkt = NULL;
 	git_pkt_parse_data pkt_parse_data = { 0 };
 	int error = 0, ret;
 
 	pkt_parse_data.oid_type = t->owner->repo->oid_type;
 	pkt_parse_data.seen_capabilities = 1;
 
 	do {
-		if (buf->offset > 0)
-			error = git_pkt_parse_line(&pkt, &line_end, ptr, buf->offset, &pkt_parse_data);
+		if (t->buffer.len > 0)
+			error = git_pkt_parse_line(&pkt, &line_end, ptr,
+				t->buffer.len, &pkt_parse_data);
 		else
 			error = GIT_EBUFS;
 
 		if (error == 0)
 			break; /* return the pkt */
 
 		if (error < 0 && error != GIT_EBUFS)
 			return error;
 
-		if ((ret = gitno_recv(buf)) < 0) {
+		if ((ret = git_smart__recv(t)) < 0) {
 			return ret;
 		} else if (ret == 0) {
 			git_error_set(GIT_ERROR_NET, "early EOF");
 			return GIT_EEOF;
 		}
 	} while (error);
 
-	if (gitno_consume(buf, line_end) < 0)
-		return -1;
+	git_staticstr_consume(&t->buffer, line_end);
 
 	if (out_type != NULL)
 		*out_type = pkt->type;
 	if (out_pkt != NULL)
 		*out_pkt = pkt;
 	else
 		git__free(pkt);
 
 	return error;
 }
@@ -306,53 +305,52 @@ static int recv_pkt(
 static int store_common(transport_smart *t)
 {
 	git_pkt *pkt = NULL;
-	gitno_buffer *buf = &t->buffer;
 	int error;
 
 	do {
-		if ((error = recv_pkt(&pkt, NULL, t, buf)) < 0)
+		if ((error = recv_pkt(&pkt, NULL, t)) < 0)
 			return error;
 
 		if (pkt->type != GIT_PKT_ACK) {
 			git__free(pkt);
 			return 0;
 		}
 
 		if (git_vector_insert(&t->common, pkt) < 0) {
 			git__free(pkt);
 			return -1;
 		}
 	} while (1);
 
 	return 0;
 }
 
-static int wait_while_ack(transport_smart *t, gitno_buffer *buf)
+static int wait_while_ack(transport_smart *t)
 {
 	int error;
 	git_pkt *pkt = NULL;
 	git_pkt_ack *ack = NULL;
 
 	while (1) {
 		git_pkt_free(pkt);
 
-		if ((error = recv_pkt(&pkt, NULL, t, buf)) < 0)
+		if ((error = recv_pkt(&pkt, NULL, t)) < 0)
 			return error;
 
 		if (pkt->type == GIT_PKT_NAK)
 			break;
 		if (pkt->type != GIT_PKT_ACK)
 			continue;
 
 		ack = (git_pkt_ack*)pkt;
 
 		if (ack->status != GIT_ACK_CONTINUE &&
 		    ack->status != GIT_ACK_COMMON &&
 		    ack->status != GIT_ACK_READY) {
 			break;
 		}
 	}
 
 	git_pkt_free(pkt);
 	return 0;
 }
@@ -398,185 +396,184 @@ static int setup_shallow_roots(
 int git_smart__negotiate_fetch(
 	git_transport *transport,
 	git_repository *repo,
 	const git_fetch_negotiation *wants)
 {
 	transport_smart *t = (transport_smart *)transport;
 	git_revwalk__push_options opts = GIT_REVWALK__PUSH_OPTIONS_INIT;
-	gitno_buffer *buf = &t->buffer;
 	git_str data = GIT_STR_INIT;
 	git_revwalk *walk = NULL;
 	int error = -1;
 	git_pkt_type pkt_type;
 	unsigned int i;
 	git_oid oid;
 
 	if ((error = setup_caps(&t->caps, wants)) < 0 ||
 	    (error = setup_shallow_roots(&t->shallow_roots, wants)) < 0)
 		return error;
 
 	if ((error = git_pkt_buffer_wants(wants, &t->caps, &data)) < 0)
 		return error;
 
 	if ((error = git_revwalk_new(&walk, repo)) < 0)
 		goto on_error;
 
 	opts.insert_by_date = 1;
 	if ((error = git_revwalk__push_glob(walk, "refs/*", &opts)) < 0)
 		goto on_error;
 
 	if (wants->depth > 0) {
 		git_pkt_shallow *pkt;
 
 		if ((error = git_smart__negotiation_step(&t->parent, data.ptr, data.size)) < 0)
 			goto on_error;
 
-		while ((error = recv_pkt((git_pkt **)&pkt, NULL, t, buf)) == 0) {
+		while ((error = recv_pkt((git_pkt **)&pkt, NULL, t)) == 0) {
 			bool complete = false;
 
 			if (pkt->type == GIT_PKT_SHALLOW) {
 				error = git_oidarray__add(&t->shallow_roots, &pkt->oid);
 			} else if (pkt->type == GIT_PKT_UNSHALLOW) {
 				git_oidarray__remove(&t->shallow_roots, &pkt->oid);
 			} else if (pkt->type == GIT_PKT_FLUSH) {
 				/* Server is done, stop processing shallow oids */
 				complete = true;
 			} else {
 				git_error_set(GIT_ERROR_NET, "unexpected packet type");
 				error = -1;
 			}
 
 			git_pkt_free((git_pkt *) pkt);
 
 			if (complete || error < 0)
 				break;
 		}
 
 		if (error < 0)
 			goto on_error;
 	}
 
 	/*
 	 * Our support for ACK extensions is simply to parse them. On
 	 * the first ACK we will accept that as enough common
 	 * objects. We give up if we haven't found an answer in the
 	 * first 256 we send.
 	 */
 	i = 0;
 	while (i < 256) {
 		error = git_revwalk_next(&oid, walk);
 
 		if (error < 0) {
 			if (GIT_ITEROVER == error)
 				break;
 
 			goto on_error;
 		}
 
 		git_pkt_buffer_have(&oid, &data);
 		i++;
 		if (i % 20 == 0) {
 			if (t->cancelled.val) {
 				git_error_set(GIT_ERROR_NET, "The fetch was cancelled by the user");
 				error = GIT_EUSER;
 				goto on_error;
 			}
 
 			git_pkt_buffer_flush(&data);
 			if (git_str_oom(&data)) {
 				error = -1;
 				goto on_error;
 			}
 
 			if ((error = git_smart__negotiation_step(&t->parent, data.ptr, data.size)) < 0)
 				goto on_error;
 
 			git_str_clear(&data);
 			if (t->caps.multi_ack || t->caps.multi_ack_detailed) {
 				if ((error = store_common(t)) < 0)
 					goto on_error;
 			} else {
-				if ((error = recv_pkt(NULL, &pkt_type, t, buf)) < 0)
+				if ((error = recv_pkt(NULL, &pkt_type, t)) < 0)
 					goto on_error;
 
 				if (pkt_type == GIT_PKT_ACK) {
 					break;
 				} else if (pkt_type == GIT_PKT_NAK) {
 					continue;
 				} else {
 					git_error_set(GIT_ERROR_NET, "unexpected pkt type");
 					error = -1;
 					goto on_error;
 				}
 			}
 		}
 
 		if (t->common.length > 0)
 			break;
 
 		if (i % 20 == 0 && t->rpc) {
 			git_pkt_ack *pkt;
 			unsigned int j;
 
 			if ((error = git_pkt_buffer_wants(wants, &t->caps, &data)) < 0)
 				goto on_error;
 
 			git_vector_foreach(&t->common, j, pkt) {
 				if ((error = git_pkt_buffer_have(&pkt->oid, &data)) < 0)
 					goto on_error;
 			}
 
 			if (git_str_oom(&data)) {
 				error = -1;
 				goto on_error;
 			}
 		}
 	}
 
 	/* Tell the other end that we're done negotiating */
 	if (t->rpc && t->common.length > 0) {
 		git_pkt_ack *pkt;
 		unsigned int j;
 
 		if ((error = git_pkt_buffer_wants(wants, &t->caps, &data)) < 0)
 			goto on_error;
 
 		git_vector_foreach(&t->common, j, pkt) {
 			if ((error = git_pkt_buffer_have(&pkt->oid, &data)) < 0)
 				goto on_error;
 		}
 
 		if (git_str_oom(&data)) {
 			error = -1;
 			goto on_error;
 		}
 	}
 
 	if ((error = git_pkt_buffer_done(&data)) < 0)
 		goto on_error;
 
 	if (t->cancelled.val) {
 		git_error_set(GIT_ERROR_NET, "the fetch was cancelled");
 		error = GIT_EUSER;
 		goto on_error;
 	}
 
 	if ((error = git_smart__negotiation_step(&t->parent, data.ptr, data.size)) < 0)
 		goto on_error;
 
 	git_str_dispose(&data);
 	git_revwalk_free(walk);
 
 	/* Now let's eat up whatever the server gives us */
 	if (!t->caps.multi_ack && !t->caps.multi_ack_detailed) {
-		if ((error = recv_pkt(NULL, &pkt_type, t, buf)) < 0)
+		if ((error = recv_pkt(NULL, &pkt_type, t)) < 0)
 			return error;
 
 		if (pkt_type != GIT_PKT_ACK && pkt_type != GIT_PKT_NAK) {
 			git_error_set(GIT_ERROR_NET, "unexpected pkt type");
 			return -1;
 		}
 	} else {
-		error = wait_while_ack(t, buf);
+		error = wait_while_ack(t);
 	}
 
 	return error;
@@ -606,27 +603,30 @@ int git_smart__shallow_roots(git_oidarray *out, git_transport *transport)
 	return 0;
 }
 
-static int no_sideband(transport_smart *t, struct git_odb_writepack *writepack, gitno_buffer *buf, git_indexer_progress *stats)
+static int no_sideband(
+	transport_smart *t,
+	struct git_odb_writepack *writepack,
+	git_indexer_progress *stats)
 {
 	int recvd;
 
 	do {
 		if (t->cancelled.val) {
 			git_error_set(GIT_ERROR_NET, "the fetch was cancelled by the user");
 			return GIT_EUSER;
 		}
 
-		if (writepack->append(writepack, buf->data, buf->offset, stats) < 0)
+		if (writepack->append(writepack, t->buffer.data, t->buffer.len, stats) < 0)
 			return -1;
 
-		gitno_consume_n(buf, buf->offset);
+		git_staticstr_clear(&t->buffer);
 
-		if ((recvd = gitno_recv(buf)) < 0)
+		if ((recvd = git_smart__recv(t)) < 0)
 			return recvd;
 	} while(recvd > 0);
 
 	if (writepack->commit(writepack, stats) < 0)
 		return -1;
 
 	return 0;
 }
@@ -660,106 +660,106 @@ static int network_packetsize(size_t received, void *payload)
 int git_smart__download_pack(
 	git_transport *transport,
 	git_repository *repo,
 	git_indexer_progress *stats)
 {
 	transport_smart *t = (transport_smart *)transport;
-	gitno_buffer *buf = &t->buffer;
 	git_odb *odb;
 	struct git_odb_writepack *writepack = NULL;
 	int error = 0;
 	struct network_packetsize_payload npp = {0};
 
 	git_indexer_progress_cb progress_cb = t->connect_opts.callbacks.transfer_progress;
 	void *progress_payload = t->connect_opts.callbacks.payload;
 
 	memset(stats, 0, sizeof(git_indexer_progress));
 
 	if (progress_cb) {
 		npp.callback = progress_cb;
 		npp.payload = progress_payload;
 		npp.stats = stats;
 		t->packetsize_cb = &network_packetsize;
 		t->packetsize_payload = &npp;
 
 		/* We might have something in the buffer already from negotiate_fetch */
-		if (t->buffer.offset > 0 && !t->cancelled.val)
-			if (t->packetsize_cb(t->buffer.offset, t->packetsize_payload))
+		if (t->buffer.len > 0 && !t->cancelled.val) {
+			if (t->packetsize_cb(t->buffer.len, t->packetsize_payload))
 				git_atomic32_set(&t->cancelled, 1);
+		}
 	}
 
 	if ((error = git_repository_odb__weakptr(&odb, repo)) < 0 ||
 		((error = git_odb_write_pack(&writepack, odb, progress_cb, progress_payload)) != 0))
 		goto done;
 
 	/*
 	 * If the remote doesn't support the side-band, we can feed
 	 * the data directly to the pack writer. Otherwise, we need to
 	 * check which one belongs there.
 	 */
 	if (!t->caps.side_band && !t->caps.side_band_64k) {
-		error = no_sideband(t, writepack, buf, stats);
+		error = no_sideband(t, writepack, stats);
 		goto done;
 	}
 
 	do {
 		git_pkt *pkt = NULL;
 
 		/* Check cancellation before network call */
 		if (t->cancelled.val) {
 			git_error_clear();
 			error = GIT_EUSER;
 			goto done;
 		}
 
-		if ((error = recv_pkt(&pkt, NULL, t, buf)) >= 0) {
+		if ((error = recv_pkt(&pkt, NULL, t)) >= 0) {
 			/* Check cancellation after network call */
 			if (t->cancelled.val) {
 				git_error_clear();
 				error = GIT_EUSER;
 			} else if (pkt->type == GIT_PKT_PROGRESS) {
 				if (t->connect_opts.callbacks.sideband_progress) {
 					git_pkt_progress *p = (git_pkt_progress *) pkt;
 
 					if (p->len > INT_MAX) {
 						git_error_set(GIT_ERROR_NET, "oversized progress message");
 						error = GIT_ERROR;
 						goto done;
 					}
 
 					error = t->connect_opts.callbacks.sideband_progress(p->data, (int)p->len, t->connect_opts.callbacks.payload);
 				}
 			} else if (pkt->type == GIT_PKT_DATA) {
 				git_pkt_data *p = (git_pkt_data *) pkt;
 
 				if (p->len)
 					error = writepack->append(writepack, p->data, p->len, stats);
 			} else if (pkt->type == GIT_PKT_FLUSH) {
 				/* A flush indicates the end of the packfile */
 				git__free(pkt);
 				break;
 			}
 		}
 
 		git_pkt_free(pkt);
 
 		if (error < 0)
 			goto done;
 
 	} while (1);
 
 	/*
 	 * Trailing execution of progress_cb, if necessary...
 	 * Only the callback through the npp datastructure currently
 	 * updates the last_fired_bytes value. It is possible that
 	 * progress has already been reported with the correct
 	 * "received_bytes" value, but until (if?) this is unified
 	 * then we will report progress again to be sure that the
 	 * correct last received_bytes value is reported.
 	 */
 	if (npp.callback && npp.stats->received_bytes > npp.last_fired_bytes) {
 		error = npp.callback(npp.stats, npp.payload);
 		if (error != 0)
 			goto done;
 	}
 
 	error = writepack->commit(writepack, stats);
@@ -914,87 +914,85 @@ done:
 static int parse_report(transport_smart *transport, git_push *push)
 {
 	git_pkt *pkt = NULL;
 	git_pkt_parse_data pkt_parse_data = { 0 };
 	const char *line_end = NULL;
-	gitno_buffer *buf = &transport->buffer;
 	int error, recvd;
 	git_str data_pkt_buf = GIT_STR_INIT;
 
 	for (;;) {
-		if (buf->offset > 0)
+		if (transport->buffer.len > 0)
 			error = git_pkt_parse_line(&pkt, &line_end,
-						   buf->data, buf->offset,
-						   &pkt_parse_data);
+				   transport->buffer.data,
+				   transport->buffer.len,
+				   &pkt_parse_data);
 		else
 			error = GIT_EBUFS;
 
 		if (error < 0 && error != GIT_EBUFS) {
 			error = -1;
 			goto done;
 		}
 
 		if (error == GIT_EBUFS) {
-			if ((recvd = gitno_recv(buf)) < 0) {
+			if ((recvd = git_smart__recv(transport)) < 0) {
 				error = recvd;
 				goto done;
 			}
 
 			if (recvd == 0) {
 				git_error_set(GIT_ERROR_NET, "early EOF");
 				error = GIT_EEOF;
 				goto done;
 			}
 			continue;
 		}
 
-		if (gitno_consume(buf, line_end) < 0)
-			return -1;
-
+		git_staticstr_consume(&transport->buffer, line_end);
 		error = 0;
 
 		switch (pkt->type) {
 			case GIT_PKT_DATA:
 				/* This is a sideband packet which contains other packets */
 				error = add_push_report_sideband_pkt(push, (git_pkt_data *)pkt, &data_pkt_buf);
 				break;
 			case GIT_PKT_ERR:
 				git_error_set(GIT_ERROR_NET, "report-status: Error reported: %s",
 					((git_pkt_err *)pkt)->error);
 				error = -1;
 				break;
 			case GIT_PKT_PROGRESS:
 				if (transport->connect_opts.callbacks.sideband_progress) {
 					git_pkt_progress *p = (git_pkt_progress *) pkt;
 
 					if (p->len > INT_MAX) {
 						git_error_set(GIT_ERROR_NET, "oversized progress message");
 						error = GIT_ERROR;
 						goto done;
 					}
 
 					error = transport->connect_opts.callbacks.sideband_progress(p->data, (int)p->len, transport->connect_opts.callbacks.payload);
 				}
 				break;
 			default:
 				error = add_push_report_pkt(push, pkt);
 				break;
 		}
 
 		git_pkt_free(pkt);
 
 		/* add_push_report_pkt returns GIT_ITEROVER when it receives a flush */
 		if (error == GIT_ITEROVER) {
 			error = 0;
 			if (data_pkt_buf.size > 0) {
 				/* If there was data remaining in the pack data buffer,
 				 * then the server sent a partial pkt-line */
 				git_error_set(GIT_ERROR_NET, "incomplete pack data pkt-line");
 				error = GIT_ERROR;
 			}
 			goto done;
 		}
 
 		if (error < 0) {
 			goto done;
 		}
 	}
diff --git a/src/libgit2/transports/ssh.c b/src/libgit2/transports/ssh.c
index 5500ea100..af618e1a6 100644
--- a/src/libgit2/transports/ssh.c
+++ b/src/libgit2/transports/ssh.c
@@ -1,26 +1,25 @@
 /*
  * Copyright (C) the libgit2 contributors. All rights reserved.
  *
  * This file is part of libgit2, distributed under the GNU GPL v2 with
  * a Linking Exception. For full terms see the included COPYING file.
  */
 
 #include "ssh.h"
 
 #ifdef GIT_SSH
 #include <libssh2.h>
 #endif
 
 #include "runtime.h"
 #include "net.h"
-#include "netops.h"
 #include "smart.h"
 #include "streams/socket.h"
 #include "sysdir.h"
 
 #include "git2/credential.h"
 #include "git2/sys/credential.h"
 
 #ifdef GIT_SSH
 
 #define OWNING_SUBTRANSPORT(s) ((ssh_subtransport *)(s)->parent.subtransport)
diff --git a/src/libgit2/transports/winhttp.c b/src/libgit2/transports/winhttp.c
index de24a2a41..27e0fb6f7 100644
--- a/src/libgit2/transports/winhttp.c
+++ b/src/libgit2/transports/winhttp.c
@@ -1,65 +1,64 @@
 /*
  * Copyright (C) the libgit2 contributors. All rights reserved.
  *
  * This file is part of libgit2, distributed under the GNU GPL v2 with
  * a Linking Exception. For full terms see the included COPYING file.
  */
 
 #include "common.h"
 
 #ifdef GIT_WINHTTP
 
 #include "git2.h"
 #include "git2/transport.h"
 #include "posix.h"
 #include "str.h"
-#include "netops.h"
 #include "smart.h"
 #include "remote.h"
 #include "repository.h"
 #include "http.h"
 #include "git2/sys/credential.h"
 
 #include <wincrypt.h>
 #include <winhttp.h>
 
 /* For IInternetSecurityManager zone check */
 #include <objbase.h>
 #include <urlmon.h>
 
 #define WIDEN2(s) L ## s
 #define WIDEN(s) WIDEN2(s)
 
 #define MAX_CONTENT_TYPE_LEN	100
 #define WINHTTP_OPTION_PEERDIST_EXTENSION_STATE	109
 #define CACHED_POST_BODY_BUF_SIZE	4096
 #define UUID_LENGTH_CCH	32
 #define TIMEOUT_INFINITE -1
 #define DEFAULT_CONNECT_TIMEOUT 60000
 #ifndef WINHTTP_IGNORE_REQUEST_TOTAL_LENGTH
 #define WINHTTP_IGNORE_REQUEST_TOTAL_LENGTH 0
 #endif
 
 #ifndef WINHTTP_FLAG_SECURE_PROTOCOL_TLS1_1
 # define WINHTTP_FLAG_SECURE_PROTOCOL_TLS1_1 0x00000200
 #endif
 
 #ifndef WINHTTP_FLAG_SECURE_PROTOCOL_TLS1_2
 # define WINHTTP_FLAG_SECURE_PROTOCOL_TLS1_2 0x00000800
 #endif
 
 #ifndef WINHTTP_FLAG_SECURE_PROTOCOL_TLS1_3
 # define WINHTTP_FLAG_SECURE_PROTOCOL_TLS1_3 0x00002000
 #endif
 
 #ifndef WINHTTP_NO_CLIENT_CERT_CONTEXT
 # define WINHTTP_NO_CLIENT_CERT_CONTEXT NULL
 #endif
 
 #ifndef HTTP_STATUS_PERMANENT_REDIRECT
 # define HTTP_STATUS_PERMANENT_REDIRECT 308
 #endif
 
 #ifndef DWORD_MAX
 # define DWORD_MAX 0xffffffff
 #endif
diff --git a/src/util/staticstr.h b/src/util/staticstr.h
new file mode 100644
index 000000000..b7d0790c4
--- /dev/null
+++ b/src/util/staticstr.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) the libgit2 contributors. All rights reserved.
+ *
+ * This file is part of libgit2, distributed under the GNU GPL v2 with
+ * a Linking Exception. For full terms see the included COPYING file.
+ */
+#ifndef INCLUDE_stackstr_h__
+#define INCLUDE_stackstr_h__
+
+#include "git2_util.h"
+
+typedef struct {
+	/* Length of / number of bytes used by `data`. */
+	size_t len;
+
+	/* Size of the allocated `data` buffer. */
+	size_t size;
+
+	/* The actual string buffer data. */
+	char data[GIT_FLEX_ARRAY];
+} git_staticstr;
+
+#define git_staticstr_with_size(__size) \
+	struct { \
+		size_t len; \
+		size_t size; \
+		char data[__size]; \
+	}
+
+#define git_staticstr_init(__str, __size) \
+	do { \
+		(__str)->len = 0; \
+		(__str)->size = __size; \
+		(__str)->data[0] = '\0'; \
+	} while(0)
+
+#define git_staticstr_offset(__str) \
+	((__str)->data + (__str)->len)
+
+#define git_staticstr_remain(__str) \
+	((__str)->len > (__str)->size ? 0 : ((__str)->size - (__str)->len))
+
+#define git_staticstr_increase(__str, __len) \
+	do { ((__str)->len += __len); } while(0)
+
+#define git_staticstr_consume_bytes(__str, __len) \
+	do { git_staticstr_consume(__str, (__str)->data + __len); } while(0)
+
+#define git_staticstr_consume(__str, __end) \
+	do { \
+		if (__end > (__str)->data && \
+		    __end <= (__str)->data + (__str)->len) { \
+			size_t __consumed = __end - (__str)->data; \
+			memmove((__str)->data, __end, (__str)->len - __consumed); \
+			(__str)->len -= __consumed; \
+			(__str)->data[(__str)->len] = '\0'; \
+		} \
+	} while(0)
+
+#define git_staticstr_clear(__str) \
+	do { \
+		(__str)->len = 0; \
+		(__str)->data[0] = 0; \
+	} while(0)
+
+#endif
diff --git a/tests/util/url/joinpath.c b/tests/util/url/joinpath.c
index 9fc02cde4..6027093e4 100644
--- a/tests/util/url/joinpath.c
+++ b/tests/util/url/joinpath.c
@@ -1,6 +1,5 @@
 #include "clar_libgit2.h"
 #include "net.h"
-#include "netops.h"
 
 static git_net_url source, target;
 
diff --git a/tests/util/url/redirect.c b/tests/util/url/redirect.c
index 540177861..a6f99dcdf 100644
--- a/tests/util/url/redirect.c
+++ b/tests/util/url/redirect.c
@@ -1,6 +1,5 @@
 #include "clar_libgit2.h"
 #include "net.h"
-#include "netops.h"
 
 static git_net_url conndata;
 
