commit b48695bb940e55c0baa0a3d5740cf48e03643b58
Author: Volodymyr Shymanskyy <vshymanskyi@gmail.com>
Date:   Sat Apr 17 21:10:17 2021 +0300

    Detect stack overflow in EvaluateExpression

diff --git a/source/m3_api_defs.h b/source/m3_api_defs.h
index 9d52bac..221d962 100644
--- a/source/m3_api_defs.h
+++ b/source/m3_api_defs.h
@@ -1,50 +1,54 @@
 //
 //  m3_api_defs.h
 //
 //  Created by Volodymyr Shymanskyy on 12/20/19.
 //  Copyright Â© 2019 Volodymyr Shymanskyy. All rights reserved.
 //
 
 #ifndef m3_api_defs_h
 #define m3_api_defs_h
 
 #include "m3_core.h"
 
 // TODO: perform bounds checks
 #define m3ApiOffsetToPtr(offset)   (void*)((u8*)_mem + (u32)(offset))
 #define m3ApiPtrToOffset(ptr)      (u32)((u8*)ptr - (u8*)_mem)
 
 #define m3ApiReturnType(TYPE)      TYPE* raw_return = ((TYPE*) (_sp++));
 #define m3ApiGetArg(TYPE, NAME)    TYPE NAME = * ((TYPE *) (_sp++));
 #define m3ApiGetArgMem(TYPE, NAME) TYPE NAME = (TYPE)m3ApiOffsetToPtr(* ((u32 *) (_sp++)));
 
 # define m3ApiIsNullPtr(addr)      ((void*)(addr) <= _mem)
 
 #if d_m3SkipMemoryBoundsCheck
 # define m3ApiCheckMem(off, len)
 #else
 # define m3ApiCheckMem(addr, len)  { if (UNLIKELY(m3ApiIsNullPtr(addr) || ((u64)(addr) + (len)) > ((u64)(_mem)+runtime->memory.mallocated->length))) m3ApiTrap(m3Err_trapOutOfBoundsMemoryAccess); }
 #endif
 
 #define m3ApiRawFunction(NAME)     const void * NAME (IM3Runtime runtime, IM3ImportContext _ctx, uint64_t * _sp, void * _mem)
 #define m3ApiReturn(VALUE)         { *raw_return = (VALUE); return m3Err_none; }
 #define m3ApiTrap(VALUE)           { return VALUE; }
 #define m3ApiSuccess()             { return m3Err_none; }
 
 # if defined(M3_BIG_ENDIAN)
+#  define m3ApiReadMem8(ptr)         (* (u8 *)(ptr))
 #  define m3ApiReadMem16(ptr)        __builtin_bswap16((* (u16 *)(ptr)))
 #  define m3ApiReadMem32(ptr)        __builtin_bswap32((* (u32 *)(ptr)))
 #  define m3ApiReadMem64(ptr)        __builtin_bswap64((* (u64 *)(ptr)))
+#  define m3ApiWriteMem8(ptr, val)   { * (u8  *)(ptr)  = (val); }
 #  define m3ApiWriteMem16(ptr, val)  { * (u16 *)(ptr) = __builtin_bswap16((val)); }
 #  define m3ApiWriteMem32(ptr, val)  { * (u32 *)(ptr) = __builtin_bswap32((val)); }
 #  define m3ApiWriteMem64(ptr, val)  { * (u64 *)(ptr) = __builtin_bswap64((val)); }
 # else
+#  define m3ApiReadMem8(ptr)         (* (u8 *)(ptr))
 #  define m3ApiReadMem16(ptr)        (* (u16 *)(ptr))
 #  define m3ApiReadMem32(ptr)        (* (u32 *)(ptr))
 #  define m3ApiReadMem64(ptr)        (* (u64 *)(ptr))
+#  define m3ApiWriteMem8(ptr, val)   { * (u8  *)(ptr) = (val); }
 #  define m3ApiWriteMem16(ptr, val)  { * (u16 *)(ptr) = (val); }
 #  define m3ApiWriteMem32(ptr, val)  { * (u32 *)(ptr) = (val); }
 #  define m3ApiWriteMem64(ptr, val)  { * (u64 *)(ptr) = (val); }
 # endif
 
 #endif // m3_api_defs_h
diff --git a/source/m3_compile.c b/source/m3_compile.c
index e057719..0ebf47c 100644
--- a/source/m3_compile.c
+++ b/source/m3_compile.c
@@ -327,21 +327,21 @@ u16  GetRegisterStackIndex  (IM3Compilation o, u32 i_register)
 u16  GetMaxUsedSlotPlusOne  (IM3Compilation o)
 {
     while (o->slotMaxAllocatedIndexPlusOne > o->slotFirstDynamicIndex)
     {
         if (IsSlotAllocated (o, o->slotMaxAllocatedIndexPlusOne - 1))
             break;
 
         o->slotMaxAllocatedIndexPlusOne--;
     }
-    
+
 #   ifdef DEBUG
         u16 maxSlot = o->slotMaxAllocatedIndexPlusOne;
         while (maxSlot < d_m3MaxFunctionSlots)
         {
             d_m3Assert (o->m3Slots [maxSlot] == 0);
             maxSlot++;
         }
 #   endif
 
     return o->slotMaxAllocatedIndexPlusOne;
 }
@@ -417,37 +417,34 @@ _               (PreserveRegisterIfOccupied (o, c_m3Type_f64));
 M3Result  Push  (IM3Compilation o, u8 i_type, u16 i_slot)
 {
     M3Result result = m3Err_none;
 
 #if !d_m3HasFloat
     if (i_type == c_m3Type_f32 || i_type == c_m3Type_f64) {
         return m3Err_unknownOpcode;
     }
 #endif
 
     u16 stackIndex = o->stackIndex++;                                       // printf ("push: %d\n", (i32) i);
 
     if (stackIndex < d_m3MaxFunctionStackHeight)
     {
         o->wasmStack        [stackIndex] = i_slot;
         o->typeStack        [stackIndex] = i_type;
 
         if (IsRegisterSlotAlias (i_slot))
         {
             u32 regSelect = IsFpRegisterSlotAlias (i_slot);
             AllocateRegister (o, regSelect, stackIndex);
         }
         else
         {
-            if (o->function)
-            {
-                // op_Entry uses this value to track and detect stack overflow
-                o->function->maxStackSlots = M3_MAX (o->function->maxStackSlots, i_slot + 1);
-            }
+            // op_Entry and EvaluateExpression use this value to track and detect stack overflow
+            o->maxStackSlots = M3_MAX (o->maxStackSlots, i_slot + 1);
         }
 
         if (d_m3LogWasmStack) dump_type_stack (o);
     }
     else result = m3Err_functionStackOverflow;
 
     return result;
 }
@@ -696,19 +693,19 @@ void  SetStackPolymorphic  (IM3Compilation o)
 bool  PatchBranches  (IM3Compilation o)
 {
     pc_t pc = GetPC (o);
 
     IM3BranchPatch patches = o->block.patches;
     o->block.patches = NULL;
-    
+
     bool didPatch = patches;
-    
+
     while (patches)
     {                                                           m3log (compile, "patching location: %p to pc: %p", patches, pc);
         patches->location = pc;
         patches = patches->next;
     }
 
     return didPatch;
 }
 
 //-------------------------------------------------------------------------------------------------------------------------
@@ -906,7 +903,7 @@ M3Result  MoveStackTopToSlot  (IM3Compilation o, u16 i_slot, bool i_doPushPop)
         u8 type = GetStackTopType (o);
 
 _       (CopyStackTopToSlot (o, i_slot));
-        
+
         if (i_doPushPop)
         {
 _           (Pop (o));
@@ -935,9 +932,9 @@ _           (CopyStackTopToRegister (o, i_doPushPop))
         else
 _           (MoveStackTopToSlot (o, i_targetBlock->topSlot, i_doPushPop))
     }
-    
+
     _catch: return result;
 }
 
 
 //-------------------------------------------------------------------------------------------------------------------------
@@ -1042,24 +1039,24 @@ _   (EmitOp (o, op_Return));
 M3Result  ValidateBlockEnd  (IM3Compilation o)
 {
     M3Result result = m3Err_none;
 
     u8 stackType = GetSingleRetType (o->block.type);
 
     if (stackType != c_m3Type_none)
     {
         if (IsStackPolymorphic (o))
         {
             /*
              according to reference implementations: the type stack should still be validated
              here, which is totally senseless in practice.
-            
+
              the spec behavior which I had to deduce from the ocaml and wat2wasm tools is:
              a polymorphic stack can pop any type requested, but if values have been pushed
              since going polymorphic, those type are not polymorphic.
             */
-            
+
 _           (UnwindBlockStack (o));
-            
+
             if (IsFpType (stackType))
 _               (PushRegister (o, stackType))
             else
@@ -1089,26 +1086,26 @@ _       (UnwindBlockStack (o));
 M3Result  Compile_End  (IM3Compilation o, m3opcode_t i_opcode)
 {
     M3Result result = m3Err_none;
 
     // function end:
     if (o->block.depth == 0)
     {
         ValidateBlockEnd (o);
-        
+
         u8 type = GetSingleRetType (o->block.type);
 
         u32 numReturns = GetFuncTypeNumReturns (o->block.type);
 
         if (numReturns)
         {
             if (not o->block.isPolymorphic and type != GetStackTopType (o))
                 _throw (m3Err_typeMismatch);
 
             if (not o->block.isPolymorphic)
                 ResolveBlockResults (o, & o->block, true);
-        
+
             // if there are branches to the function end, then their values are in a register
             // if the block happens to have its top in a register too, then we can patch the branch
             // to here. Otherwise, an ReturnStackTop is appended to the end of the function (at B) and
             // branches patched there.
             PatchBranches (o);
@@ -1246,15 +1243,15 @@ M3Result  EmitPatchingBranch  (IM3Compilation o, IM3CompilationScope i_scope)
     M3Result result ;
 
 _try {
-    
+
 _   (EmitOp (o, op_Branch));
-    
+
     // IM3BranchPatch is two word struct; reserve two words
     IM3BranchPatch patch = (IM3BranchPatch) ReservePointer (o);                     m3log (compile, "branch patch required at: %p", patch);
                                             ReservePointer (o);
     patch->next = i_scope->patches;
     i_scope->patches = patch;
 
 }   _catch:
     return result;
 }
@@ -1291,35 +1288,35 @@ _           (PopType (o, c_m3Type_i32));
 _       (EmitOp (o, op));
         EmitPointer (o, scope->pc);
     }
     else // forward branch
     {
         pc_t * jumpTo = NULL;
-        
+
         if (i_opcode == c_waOp_branchIf)
         {
             // OPTZ: need a flipped BranchIf without ResolveBlockResults prologue
             // when no stack results
-            
+
             IM3Operation op = IsStackTopInRegister (o) ? op_BranchIfPrologue_r : op_BranchIfPrologue_s;
 
     _       (EmitOp (o, op));
             EmitSlotNumOfStackTopAndPop (o); // condition
-            
+
             // this is continuation point, if the branch isn't taken
             jumpTo = (pc_t *) ReservePointer (o);
         }
 
         if (not IsStackPolymorphic (o))
 _           (ResolveBlockResults (o, scope, false));
-        
+
 _       (EmitPatchingBranch (o, scope));
-        
+
         if (jumpTo)
         {
             * jumpTo = GetPC (o);
         }
         else SetStackPolymorphic (o);
     }
 
     _catch: return result;
 }
@@ -1361,10 +1358,10 @@ _       (GetBlockScope (o, & scope, target));
 
         // create a ContinueLoop operation on a fresh page
 _       (AcquireCompilationCodePage (o, & continueOpPage));
-        
+
         pc_t startPC = GetPagePC (continueOpPage);
         IM3CodePage savedPage = o->page;
         o->page = continueOpPage;
 
         if (scope->opcode == c_waOp_loop)
         {
@@ -1378,16 +1375,16 @@ _           (ResolveBlockResults (o, scope, false));
 
 _           (EmitPatchingBranch (o, scope));
         }
-        
+
         ReleaseCompilationCodePage (o);     // FIX: continueOpPage can get lost if thrown
         o->page = savedPage;
 
         EmitPointer (o, startPC);
     }
 
     SetStackPolymorphic (o);
 
     }
 
     _catch: return result;
 }
@@ -1954,257 +1951,257 @@ _   (Compile_Operator (o, i_opcode));
 const M3OpInfo c_operations [] =
 {
     M3OP( "unreachable",         0, none,   d_logOp (Unreachable),              Compile_Unreachable ),  // 0x00
     M3OP( "nop",                 0, none,   d_emptyOpList,                      Compile_Nop ),          // 0x01 .
     M3OP( "block",               0, none,   d_emptyOpList,                      Compile_LoopOrBlock ),  // 0x02
     M3OP( "loop",                0, none,   d_logOp (Loop),                     Compile_LoopOrBlock ),  // 0x03
     M3OP( "if",                 -1, none,   d_emptyOpList,                      Compile_If ),           // 0x04
     M3OP( "else",                0, none,   d_emptyOpList,                      Compile_Nop ),          // 0x05
 
     M3OP_RESERVED, M3OP_RESERVED, M3OP_RESERVED, M3OP_RESERVED, M3OP_RESERVED,                          // 0x06 - 0x0a
 
     M3OP( "end",                 0, none,   d_emptyOpList,                      Compile_End ),          // 0x0b
     M3OP( "br",                  0, none,   d_logOp (Branch),                   Compile_Branch ),       // 0x0c
     M3OP( "br_if",              -1, none,   d_logOp2 (BranchIf_r, BranchIf_s),  Compile_Branch ),       // 0x0d
     M3OP( "br_table",           -1, none,   d_logOp (BranchTable),              Compile_BranchTable ),  // 0x0e
     M3OP( "return",              0, any,    d_logOp (Return),                   Compile_Return ),       // 0x0f
     M3OP( "call",                0, any,    d_logOp (Call),                     Compile_Call ),         // 0x10
     M3OP( "call_indirect",       0, any,    d_logOp (CallIndirect),             Compile_CallIndirect ), // 0x11
     M3OP( "return_call",         0, any,    d_emptyOpList,                      Compile_Call ),         // 0x12 TODO: Optimize
     M3OP( "return_call_indirect",0, any,    d_emptyOpList,                      Compile_CallIndirect ), // 0x13
 
     M3OP_RESERVED,  M3OP_RESERVED,                                                                      // 0x14 - 0x15
     M3OP_RESERVED,  M3OP_RESERVED, M3OP_RESERVED, M3OP_RESERVED,                                        // 0x16 - 0x19
 
     M3OP( "drop",               -1, none,   d_emptyOpList,                      Compile_Drop ),         // 0x1a
     M3OP( "select",             -2, any,    d_emptyOpList,                      Compile_Select  ),      // 0x1b
 
     M3OP_RESERVED,  M3OP_RESERVED, M3OP_RESERVED, M3OP_RESERVED,                                        // 0x1c - 0x1f
 
     M3OP( "local.get",          1,  any,    d_emptyOpList,                      Compile_GetLocal ),     // 0x20
     M3OP( "local.set",          1,  none,   d_emptyOpList,                      Compile_SetLocal ),     // 0x21
     M3OP( "local.tee",          0,  any,    d_emptyOpList,                      Compile_SetLocal ),     // 0x22
     M3OP( "global.get",         1,  none,   d_emptyOpList,                      Compile_GetSetGlobal ), // 0x23
     M3OP( "global.set",         1,  none,   d_emptyOpList,                      Compile_GetSetGlobal ), // 0x24
 
     M3OP_RESERVED,  M3OP_RESERVED, M3OP_RESERVED,                                                       // 0x25 - 0x27
 
     M3OP( "i32.load",           0,  i_32,   d_unaryOpList (i32, Load_i32),      Compile_Load_Store ),   // 0x28
     M3OP( "i64.load",           0,  i_64,   d_unaryOpList (i64, Load_i64),      Compile_Load_Store ),   // 0x29
     M3OP_F( "f32.load",         0,  f_32,   d_unaryOpList (f32, Load_f32),      Compile_Load_Store ),   // 0x2a
     M3OP_F( "f64.load",         0,  f_64,   d_unaryOpList (f64, Load_f64),      Compile_Load_Store ),   // 0x2b
 
     M3OP( "i32.load8_s",        0,  i_32,   d_unaryOpList (i32, Load_i8),       Compile_Load_Store ),   // 0x2c
     M3OP( "i32.load8_u",        0,  i_32,   d_unaryOpList (i32, Load_u8),       Compile_Load_Store ),   // 0x2d
     M3OP( "i32.load16_s",       0,  i_32,   d_unaryOpList (i32, Load_i16),      Compile_Load_Store ),   // 0x2e
     M3OP( "i32.load16_u",       0,  i_32,   d_unaryOpList (i32, Load_u16),      Compile_Load_Store ),   // 0x2f
 
     M3OP( "i64.load8_s",        0,  i_64,   d_unaryOpList (i64, Load_i8),       Compile_Load_Store ),   // 0x30
     M3OP( "i64.load8_u",        0,  i_64,   d_unaryOpList (i64, Load_u8),       Compile_Load_Store ),   // 0x31
     M3OP( "i64.load16_s",       0,  i_64,   d_unaryOpList (i64, Load_i16),      Compile_Load_Store ),   // 0x32
     M3OP( "i64.load16_u",       0,  i_64,   d_unaryOpList (i64, Load_u16),      Compile_Load_Store ),   // 0x33
     M3OP( "i64.load32_s",       0,  i_64,   d_unaryOpList (i64, Load_i32),      Compile_Load_Store ),   // 0x34
     M3OP( "i64.load32_u",       0,  i_64,   d_unaryOpList (i64, Load_u32),      Compile_Load_Store ),   // 0x35
 
     M3OP( "i32.store",          -2, none,   d_binOpList (i32, Store_i32),       Compile_Load_Store ),   // 0x36
     M3OP( "i64.store",          -2, none,   d_binOpList (i64, Store_i64),       Compile_Load_Store ),   // 0x37
     M3OP_F( "f32.store",        -2, none,   d_storeFpOpList (f32, Store_f32),   Compile_Load_Store ),   // 0x38
     M3OP_F( "f64.store",        -2, none,   d_storeFpOpList (f64, Store_f64),   Compile_Load_Store ),   // 0x39
 
     M3OP( "i32.store8",         -2, none,   d_binOpList (i32, Store_u8),        Compile_Load_Store ),   // 0x3a
     M3OP( "i32.store16",        -2, none,   d_binOpList (i32, Store_i16),       Compile_Load_Store ),   // 0x3b
 
     M3OP( "i64.store8",         -2, none,   d_binOpList (i64, Store_u8),        Compile_Load_Store ),   // 0x3c
     M3OP( "i64.store16",        -2, none,   d_binOpList (i64, Store_i16),       Compile_Load_Store ),   // 0x3d
     M3OP( "i64.store32",        -2, none,   d_binOpList (i64, Store_i32),       Compile_Load_Store ),   // 0x3e
 
     M3OP( "memory.size",        1,  i_32,   d_logOp (MemSize),                  Compile_Memory_Size ),  // 0x3f
     M3OP( "memory.grow",        1,  i_32,   d_logOp (MemGrow),                  Compile_Memory_Grow ),  // 0x40
 
     M3OP( "i32.const",          1,  i_32,   d_logOp (Const32),                  Compile_Const_i32 ),    // 0x41
     M3OP( "i64.const",          1,  i_64,   d_logOp (Const64),                  Compile_Const_i64 ),    // 0x42
     M3OP_F( "f32.const",        1,  f_32,   d_emptyOpList,                      Compile_Const_f32 ),    // 0x43
     M3OP_F( "f64.const",        1,  f_64,   d_emptyOpList,                      Compile_Const_f64 ),    // 0x44
 
     M3OP( "i32.eqz",            0,  i_32,   d_unaryOpList (i32, EqualToZero)        , NULL  ),          // 0x45
     M3OP( "i32.eq",             -1, i_32,   d_commutativeBinOpList (i32, Equal)     , NULL  ),          // 0x46
     M3OP( "i32.ne",             -1, i_32,   d_commutativeBinOpList (i32, NotEqual)  , NULL  ),          // 0x47
     M3OP( "i32.lt_s",           -1, i_32,   d_binOpList (i32, LessThan)             , NULL  ),          // 0x48
     M3OP( "i32.lt_u",           -1, i_32,   d_binOpList (u32, LessThan)             , NULL  ),          // 0x49
     M3OP( "i32.gt_s",           -1, i_32,   d_binOpList (i32, GreaterThan)          , NULL  ),          // 0x4a
     M3OP( "i32.gt_u",           -1, i_32,   d_binOpList (u32, GreaterThan)          , NULL  ),          // 0x4b
     M3OP( "i32.le_s",           -1, i_32,   d_binOpList (i32, LessThanOrEqual)      , NULL  ),          // 0x4c
     M3OP( "i32.le_u",           -1, i_32,   d_binOpList (u32, LessThanOrEqual)      , NULL  ),          // 0x4d
     M3OP( "i32.ge_s",           -1, i_32,   d_binOpList (i32, GreaterThanOrEqual)   , NULL  ),          // 0x4e
     M3OP( "i32.ge_u",           -1, i_32,   d_binOpList (u32, GreaterThanOrEqual)   , NULL  ),          // 0x4f
 
     M3OP( "i64.eqz",            0,  i_32,   d_unaryOpList (i64, EqualToZero)        , NULL  ),          // 0x50
     M3OP( "i64.eq",             -1, i_32,   d_commutativeBinOpList (i64, Equal)     , NULL  ),          // 0x51
     M3OP( "i64.ne",             -1, i_32,   d_commutativeBinOpList (i64, NotEqual)  , NULL  ),          // 0x52
     M3OP( "i64.lt_s",           -1, i_32,   d_binOpList (i64, LessThan)             , NULL  ),          // 0x53
     M3OP( "i64.lt_u",           -1, i_32,   d_binOpList (u64, LessThan)             , NULL  ),          // 0x54
     M3OP( "i64.gt_s",           -1, i_32,   d_binOpList (i64, GreaterThan)          , NULL  ),          // 0x55
     M3OP( "i64.gt_u",           -1, i_32,   d_binOpList (u64, GreaterThan)          , NULL  ),          // 0x56
     M3OP( "i64.le_s",           -1, i_32,   d_binOpList (i64, LessThanOrEqual)      , NULL  ),          // 0x57
     M3OP( "i64.le_u",           -1, i_32,   d_binOpList (u64, LessThanOrEqual)      , NULL  ),          // 0x58
     M3OP( "i64.ge_s",           -1, i_32,   d_binOpList (i64, GreaterThanOrEqual)   , NULL  ),          // 0x59
     M3OP( "i64.ge_u",           -1, i_32,   d_binOpList (u64, GreaterThanOrEqual)   , NULL  ),          // 0x5a
 
     M3OP_F( "f32.eq",           -1, i_32,   d_commutativeBinOpList (f32, Equal)     , NULL  ),          // 0x5b
     M3OP_F( "f32.ne",           -1, i_32,   d_commutativeBinOpList (f32, NotEqual)  , NULL  ),          // 0x5c
     M3OP_F( "f32.lt",           -1, i_32,   d_binOpList (f32, LessThan)             , NULL  ),          // 0x5d
     M3OP_F( "f32.gt",           -1, i_32,   d_binOpList (f32, GreaterThan)          , NULL  ),          // 0x5e
     M3OP_F( "f32.le",           -1, i_32,   d_binOpList (f32, LessThanOrEqual)      , NULL  ),          // 0x5f
     M3OP_F( "f32.ge",           -1, i_32,   d_binOpList (f32, GreaterThanOrEqual)   , NULL  ),          // 0x60
 
     M3OP_F( "f64.eq",           -1, i_32,   d_commutativeBinOpList (f64, Equal)     , NULL  ),          // 0x61
     M3OP_F( "f64.ne",           -1, i_32,   d_commutativeBinOpList (f64, NotEqual)  , NULL  ),          // 0x62
     M3OP_F( "f64.lt",           -1, i_32,   d_binOpList (f64, LessThan)             , NULL  ),          // 0x63
     M3OP_F( "f64.gt",           -1, i_32,   d_binOpList (f64, GreaterThan)          , NULL  ),          // 0x64
     M3OP_F( "f64.le",           -1, i_32,   d_binOpList (f64, LessThanOrEqual)      , NULL  ),          // 0x65
     M3OP_F( "f64.ge",           -1, i_32,   d_binOpList (f64, GreaterThanOrEqual)   , NULL  ),          // 0x66
 
     M3OP( "i32.clz",            0,  i_32,   d_unaryOpList (u32, Clz)                , NULL  ),          // 0x67
     M3OP( "i32.ctz",            0,  i_32,   d_unaryOpList (u32, Ctz)                , NULL  ),          // 0x68
     M3OP( "i32.popcnt",         0,  i_32,   d_unaryOpList (u32, Popcnt)             , NULL  ),          // 0x69
 
     M3OP( "i32.add",            -1, i_32,   d_commutativeBinOpList (i32, Add)       , NULL  ),          // 0x6a
     M3OP( "i32.sub",            -1, i_32,   d_binOpList (i32, Subtract)             , NULL  ),          // 0x6b
     M3OP( "i32.mul",            -1, i_32,   d_commutativeBinOpList (i32, Multiply)  , NULL  ),          // 0x6c
     M3OP( "i32.div_s",          -1, i_32,   d_binOpList (i32, Divide)               , NULL  ),          // 0x6d
     M3OP( "i32.div_u",          -1, i_32,   d_binOpList (u32, Divide)               , NULL  ),          // 0x6e
     M3OP( "i32.rem_s",          -1, i_32,   d_binOpList (i32, Remainder)            , NULL  ),          // 0x6f
     M3OP( "i32.rem_u",          -1, i_32,   d_binOpList (u32, Remainder)            , NULL  ),          // 0x70
     M3OP( "i32.and",            -1, i_32,   d_commutativeBinOpList (u32, And)       , NULL  ),          // 0x71
     M3OP( "i32.or",             -1, i_32,   d_commutativeBinOpList (u32, Or)        , NULL  ),          // 0x72
     M3OP( "i32.xor",            -1, i_32,   d_commutativeBinOpList (u32, Xor)       , NULL  ),          // 0x73
     M3OP( "i32.shl",            -1, i_32,   d_binOpList (u32, ShiftLeft)            , NULL  ),          // 0x74
     M3OP( "i32.shr_s",          -1, i_32,   d_binOpList (i32, ShiftRight)           , NULL  ),          // 0x75
     M3OP( "i32.shr_u",          -1, i_32,   d_binOpList (u32, ShiftRight)           , NULL  ),          // 0x76
     M3OP( "i32.rotl",           -1, i_32,   d_binOpList (u32, Rotl)                 , NULL  ),          // 0x77
     M3OP( "i32.rotr",           -1, i_32,   d_binOpList (u32, Rotr)                 , NULL  ),          // 0x78
 
     M3OP( "i64.clz",            0,  i_64,   d_unaryOpList (u64, Clz)                , NULL  ),          // 0x79
     M3OP( "i64.ctz",            0,  i_64,   d_unaryOpList (u64, Ctz)                , NULL  ),          // 0x7a
     M3OP( "i64.popcnt",         0,  i_64,   d_unaryOpList (u64, Popcnt)             , NULL  ),          // 0x7b
 
     M3OP( "i64.add",            -1, i_64,   d_commutativeBinOpList (i64, Add)       , NULL  ),          // 0x7c
     M3OP( "i64.sub",            -1, i_64,   d_binOpList (i64, Subtract)             , NULL  ),          // 0x7d
     M3OP( "i64.mul",            -1, i_64,   d_commutativeBinOpList (i64, Multiply)  , NULL  ),          // 0x7e
     M3OP( "i64.div_s",          -1, i_64,   d_binOpList (i64, Divide)               , NULL  ),          // 0x7f
     M3OP( "i64.div_u",          -1, i_64,   d_binOpList (u64, Divide)               , NULL  ),          // 0x80
     M3OP( "i64.rem_s",          -1, i_64,   d_binOpList (i64, Remainder)            , NULL  ),          // 0x81
     M3OP( "i64.rem_u",          -1, i_64,   d_binOpList (u64, Remainder)            , NULL  ),          // 0x82
     M3OP( "i64.and",            -1, i_64,   d_commutativeBinOpList (u64, And)       , NULL  ),          // 0x83
     M3OP( "i64.or",             -1, i_64,   d_commutativeBinOpList (u64, Or)        , NULL  ),          // 0x84
     M3OP( "i64.xor",            -1, i_64,   d_commutativeBinOpList (u64, Xor)       , NULL  ),          // 0x85
     M3OP( "i64.shl",            -1, i_64,   d_binOpList (u64, ShiftLeft)            , NULL  ),          // 0x86
     M3OP( "i64.shr_s",          -1, i_64,   d_binOpList (i64, ShiftRight)           , NULL  ),          // 0x87
     M3OP( "i64.shr_u",          -1, i_64,   d_binOpList (u64, ShiftRight)           , NULL  ),          // 0x88
     M3OP( "i64.rotl",           -1, i_64,   d_binOpList (u64, Rotl)                 , NULL  ),          // 0x89
     M3OP( "i64.rotr",           -1, i_64,   d_binOpList (u64, Rotr)                 , NULL  ),          // 0x8a
 
     M3OP_F( "f32.abs",          0,  f_32,   d_unaryOpList(f32, Abs)                 , NULL  ),          // 0x8b
     M3OP_F( "f32.neg",          0,  f_32,   d_unaryOpList(f32, Negate)              , NULL  ),          // 0x8c
     M3OP_F( "f32.ceil",         0,  f_32,   d_unaryOpList(f32, Ceil)                , NULL  ),          // 0x8d
     M3OP_F( "f32.floor",        0,  f_32,   d_unaryOpList(f32, Floor)               , NULL  ),          // 0x8e
     M3OP_F( "f32.trunc",        0,  f_32,   d_unaryOpList(f32, Trunc)               , NULL  ),          // 0x8f
     M3OP_F( "f32.nearest",      0,  f_32,   d_unaryOpList(f32, Nearest)             , NULL  ),          // 0x90
     M3OP_F( "f32.sqrt",         0,  f_32,   d_unaryOpList(f32, Sqrt)                , NULL  ),          // 0x91
 
     M3OP_F( "f32.add",          -1, f_32,   d_commutativeBinOpList (f32, Add)       , NULL  ),          // 0x92
     M3OP_F( "f32.sub",          -1, f_32,   d_binOpList (f32, Subtract)             , NULL  ),          // 0x93
     M3OP_F( "f32.mul",          -1, f_32,   d_commutativeBinOpList (f32, Multiply)  , NULL  ),          // 0x94
     M3OP_F( "f32.div",          -1, f_32,   d_binOpList (f32, Divide)               , NULL  ),          // 0x95
     M3OP_F( "f32.min",          -1, f_32,   d_commutativeBinOpList (f32, Min)       , NULL  ),          // 0x96
     M3OP_F( "f32.max",          -1, f_32,   d_commutativeBinOpList (f32, Max)       , NULL  ),          // 0x97
     M3OP_F( "f32.copysign",     -1, f_32,   d_binOpList (f32, CopySign)             , NULL  ),          // 0x98
 
     M3OP_F( "f64.abs",          0,  f_64,   d_unaryOpList(f64, Abs)                 , NULL  ),          // 0x99
     M3OP_F( "f64.neg",          0,  f_64,   d_unaryOpList(f64, Negate)              , NULL  ),          // 0x9a
     M3OP_F( "f64.ceil",         0,  f_64,   d_unaryOpList(f64, Ceil)                , NULL  ),          // 0x9b
     M3OP_F( "f64.floor",        0,  f_64,   d_unaryOpList(f64, Floor)               , NULL  ),          // 0x9c
     M3OP_F( "f64.trunc",        0,  f_64,   d_unaryOpList(f64, Trunc)               , NULL  ),          // 0x9d
     M3OP_F( "f64.nearest",      0,  f_64,   d_unaryOpList(f64, Nearest)             , NULL  ),          // 0x9e
     M3OP_F( "f64.sqrt",         0,  f_64,   d_unaryOpList(f64, Sqrt)                , NULL  ),          // 0x9f
 
     M3OP_F( "f64.add",          -1, f_64,   d_commutativeBinOpList (f64, Add)       , NULL  ),          // 0xa0
     M3OP_F( "f64.sub",          -1, f_64,   d_binOpList (f64, Subtract)             , NULL  ),          // 0xa1
     M3OP_F( "f64.mul",          -1, f_64,   d_commutativeBinOpList (f64, Multiply)  , NULL  ),          // 0xa2
     M3OP_F( "f64.div",          -1, f_64,   d_binOpList (f64, Divide)               , NULL  ),          // 0xa3
     M3OP_F( "f64.min",          -1, f_64,   d_commutativeBinOpList (f64, Min)       , NULL  ),          // 0xa4
     M3OP_F( "f64.max",          -1, f_64,   d_commutativeBinOpList (f64, Max)       , NULL  ),          // 0xa5
     M3OP_F( "f64.copysign",     -1, f_64,   d_binOpList (f64, CopySign)             , NULL  ),          // 0xa6
 
     M3OP( "i32.wrap/i64",       0,  i_32,   d_unaryOpList (i32, Wrap_i64),          NULL    ),          // 0xa7
     M3OP_F( "i32.trunc_s/f32",  0,  i_32,   d_convertOpList (i32_Trunc_f32),        Compile_Convert ),  // 0xa8
     M3OP_F( "i32.trunc_u/f32",  0,  i_32,   d_convertOpList (u32_Trunc_f32),        Compile_Convert ),  // 0xa9
     M3OP_F( "i32.trunc_s/f64",  0,  i_32,   d_convertOpList (i32_Trunc_f64),        Compile_Convert ),  // 0xaa
     M3OP_F( "i32.trunc_u/f64",  0,  i_32,   d_convertOpList (u32_Trunc_f64),        Compile_Convert ),  // 0xab
 
     M3OP( "i64.extend_s/i32",   0,  i_64,   d_unaryOpList (i64, Extend_i32),        NULL    ),          // 0xac
     M3OP( "i64.extend_u/i32",   0,  i_64,   d_unaryOpList (i64, Extend_u32),        NULL    ),          // 0xad
 
     M3OP_F( "i64.trunc_s/f32",  0,  i_64,   d_convertOpList (i64_Trunc_f32),        Compile_Convert ),  // 0xae
     M3OP_F( "i64.trunc_u/f32",  0,  i_64,   d_convertOpList (u64_Trunc_f32),        Compile_Convert ),  // 0xaf
     M3OP_F( "i64.trunc_s/f64",  0,  i_64,   d_convertOpList (i64_Trunc_f64),        Compile_Convert ),  // 0xb0
     M3OP_F( "i64.trunc_u/f64",  0,  i_64,   d_convertOpList (u64_Trunc_f64),        Compile_Convert ),  // 0xb1
 
     M3OP_F( "f32.convert_s/i32",0,  f_32,   d_convertOpList (f32_Convert_i32),      Compile_Convert ),  // 0xb2
     M3OP_F( "f32.convert_u/i32",0,  f_32,   d_convertOpList (f32_Convert_u32),      Compile_Convert ),  // 0xb3
     M3OP_F( "f32.convert_s/i64",0,  f_32,   d_convertOpList (f32_Convert_i64),      Compile_Convert ),  // 0xb4
     M3OP_F( "f32.convert_u/i64",0,  f_32,   d_convertOpList (f32_Convert_u64),      Compile_Convert ),  // 0xb5
 
     M3OP_F( "f32.demote/f64",   0,  f_32,   d_unaryOpList (f32, Demote_f64),        NULL    ),          // 0xb6
 
     M3OP_F( "f64.convert_s/i32",0,  f_64,   d_convertOpList (f64_Convert_i32),      Compile_Convert ),  // 0xb7
     M3OP_F( "f64.convert_u/i32",0,  f_64,   d_convertOpList (f64_Convert_u32),      Compile_Convert ),  // 0xb8
     M3OP_F( "f64.convert_s/i64",0,  f_64,   d_convertOpList (f64_Convert_i64),      Compile_Convert ),  // 0xb9
     M3OP_F( "f64.convert_u/i64",0,  f_64,   d_convertOpList (f64_Convert_u64),      Compile_Convert ),  // 0xba
 
     M3OP_F( "f64.promote/f32",  0,  f_64,   d_unaryOpList (f64, Promote_f32),       NULL    ),          // 0xbb
 
     M3OP_F( "i32.reinterpret/f32",0,i_32,   d_convertOpList (i32_Reinterpret_f32),  Compile_Convert ),  // 0xbc
     M3OP_F( "i64.reinterpret/f64",0,i_64,   d_convertOpList (i64_Reinterpret_f64),  Compile_Convert ),  // 0xbd
     M3OP_F( "f32.reinterpret/i32",0,f_32,   d_convertOpList (f32_Reinterpret_i32),  Compile_Convert ),  // 0xbe
     M3OP_F( "f64.reinterpret/i64",0,f_64,   d_convertOpList (f64_Reinterpret_i64),  Compile_Convert ),  // 0xbf
 
     M3OP( "i32.extend8_s",       0,  i_32,   d_unaryOpList (i32, Extend8_s),        NULL    ),          // 0xc0
     M3OP( "i32.extend16_s",      0,  i_32,   d_unaryOpList (i32, Extend16_s),       NULL    ),          // 0xc1
     M3OP( "i64.extend8_s",       0,  i_64,   d_unaryOpList (i64, Extend8_s),        NULL    ),          // 0xc2
     M3OP( "i64.extend16_s",      0,  i_64,   d_unaryOpList (i64, Extend16_s),       NULL    ),          // 0xc3
     M3OP( "i64.extend32_s",      0,  i_64,   d_unaryOpList (i64, Extend32_s),       NULL    ),          // 0xc4
 
 # ifdef DEBUG // for codepage logging. the order doesn't matter:
 #   define d_m3DebugOp(OP) M3OP (#OP, 0, none, { op_##OP })
 #   define d_m3DebugTypedOp(OP) M3OP (#OP, 0, none, { op_##OP##_i32, op_##OP##_i64, op_##OP##_f32, op_##OP##_f64, })
 
     d_m3DebugOp (Compile),          d_m3DebugOp (Entry),            d_m3DebugOp (End),
     d_m3DebugOp (Unsupported),      d_m3DebugOp (CallRawFunction),
 
     d_m3DebugOp (GetGlobal_s32),    d_m3DebugOp (GetGlobal_s64),    d_m3DebugOp (ContinueLoop),     d_m3DebugOp (ContinueLoopIf),
 
     d_m3DebugOp (CopySlot_32),      d_m3DebugOp (PreserveCopySlot_32), d_m3DebugOp (If_s),          d_m3DebugOp (BranchIfPrologue_s),
     d_m3DebugOp (CopySlot_64),      d_m3DebugOp (PreserveCopySlot_64), d_m3DebugOp (If_r),          d_m3DebugOp (BranchIfPrologue_r),
-    
+
     d_m3DebugOp (Select_i32_rss),   d_m3DebugOp (Select_i32_srs),   d_m3DebugOp (Select_i32_ssr),   d_m3DebugOp (Select_i32_sss),
     d_m3DebugOp (Select_i64_rss),   d_m3DebugOp (Select_i64_srs),   d_m3DebugOp (Select_i64_ssr),   d_m3DebugOp (Select_i64_sss),
 
     d_m3DebugOp (Select_f32_sss),   d_m3DebugOp (Select_f32_srs),   d_m3DebugOp (Select_f32_ssr),
     d_m3DebugOp (Select_f32_rss),   d_m3DebugOp (Select_f32_rrs),   d_m3DebugOp (Select_f32_rsr),
 
     d_m3DebugOp (Select_f64_sss),   d_m3DebugOp (Select_f64_srs),   d_m3DebugOp (Select_f64_ssr),
     d_m3DebugOp (Select_f64_rss),   d_m3DebugOp (Select_f64_rrs),   d_m3DebugOp (Select_f64_rsr),
 
     d_m3DebugTypedOp (SetGlobal),   d_m3DebugOp (SetGlobal_s32),    d_m3DebugOp (SetGlobal_s64),
 
     d_m3DebugTypedOp (SetRegister), d_m3DebugTypedOp (SetSlot),     d_m3DebugTypedOp (PreserveSetSlot),
 # endif
 
 # ifdef d_m3CompileExtendedOpcode
     [0xFC] = M3OP( "0xFC", 0, c_m3Type_unknown,   d_emptyOpList,  Compile_ExtendedOpcode ),
 # endif
 
 # ifdef DEBUG
     M3OP( "termination", 0, c_m3Type_unknown ) // for find_operation_info
 # endif
 };
@@ -2449,35 +2446,36 @@ _   (CompileLocals (o));
     // ReserveConstants initializes o->firstDynamicSlotNumber
 _   (Compile_ReserveConstants (o));
 
     // start tracking the max stack used (Push() also updates this value) so that op_Entry can precisely detect stack overflow
-    o->function->maxStackSlots = o->slotMaxAllocatedIndexPlusOne = o->slotFirstDynamicIndex;
+    o->maxStackSlots = o->slotMaxAllocatedIndexPlusOne = o->slotFirstDynamicIndex;
 
     o->block.topSlot = o->slotFirstDynamicIndex;
     o->block.initStackIndex = o->stackFirstDynamicIndex = o->stackIndex;                           m3log (compile, "start stack index: %d;  top slot num: %d", (u32) o->stackFirstDynamicIndex, (u32) o->block.topSlot);
-    
+
 _   (EmitOp (o, op_Entry));
     EmitPointer (o, io_function);
 
 _   (CompileBlockStatements (o));
 
     // TODO: validate opcode sequences
     _throwif(m3Err_wasmMalformed, o->previousOpcode != c_waOp_end);
 
     io_function->compiled = pc;
+    io_function->maxStackSlots = o->maxStackSlots;
 
     u16 numConstantSlots = o->slotMaxConstIndex - o->slotFirstConstIndex;       m3log (compile, "unique constant slots: %d; unused slots: %d", numConstantSlots, o->slotFirstDynamicIndex - o->slotMaxConstIndex);
 
     io_function->numConstantBytes = numConstantSlots * sizeof (m3slot_t);
 
     if (numConstantSlots)
     {
         io_function->constants = m3_CopyMem (o->constants, io_function->numConstantBytes);
         _throwifnull(io_function->constants);
     }
 
 } _catch:
 
     ReleaseCompilationCodePage (o);
 
     return result;
 }
diff --git a/source/m3_compile.h b/source/m3_compile.h
index 9acec94..e7ed9a9 100644
--- a/source/m3_compile.h
+++ b/source/m3_compile.h
@@ -77,44 +77,46 @@ typedef M3CompilationScope *        IM3CompilationScope;
 typedef struct
 {
     IM3Runtime          runtime;
     IM3Module           module;
 
     bytes_t             wasm;
     bytes_t             wasmEnd;
     bytes_t             lastOpcodeStart;
 
     M3CompilationScope  block;
 
     IM3Function         function;
 
     IM3CodePage         page;
 
 #ifdef DEBUG
     u32                 numEmits;
     u32                 numOpcodes;
 #endif
 
     u16                 stackFirstDynamicIndex;
     u16                 stackIndex;                 // current stack index
 
     u16                 slotFirstConstIndex;
     u16                 slotMaxConstIndex;          // as const's are encountered during compilation this tracks their location in the "real" stack
 
     u16                 slotFirstLocalIndex;
     u16                 slotFirstDynamicIndex;      // numArgs + numLocals + numReservedConstants. the first mutable slot available to the compiler.
 
+    u16                 maxStackSlots;
+
     m3slot_t            constants                   [d_m3MaxConstantTableSize];
 
     // 'wasmStack' holds slot locations
     u16                 wasmStack                   [d_m3MaxFunctionStackHeight];
     u8                  typeStack                   [d_m3MaxFunctionStackHeight];
 
     // 'm3Slots' contains allocation usage counts
     u8                  m3Slots                     [d_m3MaxFunctionSlots];
 
     u16                 slotMaxAllocatedIndexPlusOne;
 
     u16                 regStackIndexPlusOne        [2];
 
     m3opcode_t          previousOpcode;
 }
diff --git a/source/m3_core.c b/source/m3_core.c
index b1e3cea..0d9ffed 100644
--- a/source/m3_core.c
+++ b/source/m3_core.c
@@ -117,7 +117,7 @@ void *  m3_Malloc  (size_t i_size)
 void  m3_FreeImpl  (void * io_ptr)
 {
 //    if (io_ptr) printf("== free %p\n", io_ptr);
-    free ((void*)io_ptr);
+    free (io_ptr);
 }
 
 void *  m3_Realloc  (void * i_ptr, size_t i_newSize, size_t i_oldSize)
diff --git a/source/m3_env.c b/source/m3_env.c
index e47751f..9a3e233 100644
--- a/source/m3_env.c
+++ b/source/m3_env.c
@@ -247,72 +247,76 @@ void  m3_FreeRuntime  (IM3Runtime i_runtime)
 M3Result  EvaluateExpression  (IM3Module i_module, void * o_expressed, u8 i_type, bytes_t * io_bytes, cbytes_t i_end)
 {
     M3Result result = m3Err_none;
 
     // OPTZ: use a simplified interpreter for expressions
 
     // create a temporary runtime context
 #if defined(d_m3PreferStaticAlloc)
     static M3Runtime runtime;
 #else
     M3Runtime runtime;
 #endif
     M3_INIT (runtime);
 
     runtime.environment = i_module->runtime->environment;
     runtime.numStackSlots = i_module->runtime->numStackSlots;
     runtime.stack = i_module->runtime->stack;
 
     m3stack_t stack = (m3stack_t)runtime.stack;
 
     IM3Runtime savedRuntime = i_module->runtime;
     i_module->runtime = & runtime;
 
     IM3Compilation o = & runtime.compilation;
     o->runtime = & runtime;
     o->module =  i_module;
     o->wasm =    * io_bytes;
     o->wasmEnd = i_end;
     o->lastOpcodeStart = o->wasm;
 
     o->block.depth = -1;  // so that root compilation depth = 0
 
     //  OPTZ: this code page could be erased after use.  maybe have 'empty' list in addition to full and open?
     o->page = AcquireCodePage (& runtime);  // AcquireUnusedCodePage (...)
 
     if (o->page)
     {
         IM3FuncType ftype = runtime.environment->retFuncTypes[i_type];
 
         pc_t m3code = GetPagePC (o->page);
         result = CompileBlock (o, ftype, c_waOp_block);
 
+        if (not result && o->maxStackSlots >= runtime.numStackSlots) {
+            result = m3Err_trapStackOverflow;
+        }
+
         if (not result)
         {
             m3ret_t r = Call (m3code, stack, NULL, d_m3OpDefaultArgs);
 
             if (r == 0)
             {                                                                               m3log (runtime, "expression result: %s", SPrintValue (stack, i_type));
                 if (SizeOfType (i_type) == sizeof (u32))
                 {
                     * (u32 *) o_expressed = * ((u32 *) stack);
                 }
                 else
                 {
                     * (u64 *) o_expressed = * ((u64 *) stack);
                 }
             }
         }
 
         // TODO: EraseCodePage (...) see OPTZ above
         ReleaseCodePage (& runtime, o->page);
     }
     else result = m3Err_mallocFailedCodePage;
 
     runtime.stack = NULL;        // prevent free(stack) in ReleaseRuntime
     Runtime_Release (& runtime);
     i_module->runtime = savedRuntime;
 
     * io_bytes = o->wasm;
 
     return result;
 }
@@ -540,30 +544,30 @@ _       ((M3Result) Call (function->compiled, (m3stack_t) runtime->stack, runtim
 // TODO: deal with main + side-modules loading efforcement
 M3Result  m3_LoadModule  (IM3Runtime io_runtime, IM3Module io_module)
 {
     M3Result result = m3Err_none;
 
-    if (not io_module->runtime)
-    {
-        io_module->runtime = io_runtime;
-        M3Memory * memory = & io_runtime->memory;
+    if (UNLIKELY(io_module->runtime)) {
+        return m3Err_moduleAlreadyLinked;
+    }
 
-_       (InitMemory (io_runtime, io_module));
-_       (InitGlobals (io_module));
-_       (InitDataSegments (memory, io_module));
-_       (InitElements (io_module));
+    io_module->runtime = io_runtime;
+    M3Memory * memory = & io_runtime->memory;
 
-        io_module->next = io_runtime->modules;
-        io_runtime->modules = io_module;
+_   (InitMemory (io_runtime, io_module));
+_   (InitGlobals (io_module));
+_   (InitDataSegments (memory, io_module));
+_   (InitElements (io_module));
 
-        // Start func might use imported functions, which are not liked here yet,
-        // so it will be called before a function call is attempted (in m3_FindFuSnction)
-    }
-    else result = m3Err_moduleAlreadyLinked;
+    // Start func might use imported functions, which are not liked here yet,
+    // so it will be called before a function call is attempted (in m3_FindFunction)
 
-    if (result)
-        io_module->runtime = NULL;
+    io_module->next = io_runtime->modules;
+    io_runtime->modules = io_module;
+    return result; // ok
 
-    _catch: return result;
+_catch:
+    io_module->runtime = NULL;
+    return result;
 }
 
 IM3Global  m3_FindGlobal  (IM3Module               io_module,
diff --git a/source/m3_info.c b/source/m3_info.c
index 0174f4e..e36605b 100644
--- a/source/m3_info.c
+++ b/source/m3_info.c
@@ -328,88 +328,88 @@ void  dump_code_page  (IM3CodePage i_codePage, pc_t i_startPC)
 void  dump_type_stack  (IM3Compilation o)
 {
     /* Reminders about how the stack works! :)
      -- args & locals remain on the type stack for duration of the function. Denoted with a constant 'A' and 'L' in this dump.
      -- the initial stack dumps originate from the CompileLocals () function, so these identifiers won't/can't be
      applied until this compilation stage is finished
      -- constants are not statically represented in the type stack (like args & constants) since they don't have/need
      write counts
 
      -- the number shown for static args and locals (value in wasmStack [i]) represents the write count for the variable
 
      -- (does Wasm ever write to an arg? I dunno/don't remember.)
      -- the number for the dynamic stack values represents the slot number.
      -- if the slot index points to arg, local or constant it's denoted with a lowercase 'a', 'l' or 'c'
 
      */
 
     // for the assert at end of dump:
     i32 regAllocated [2] = { (i32) IsRegisterAllocated (o, 0), (i32) IsRegisterAllocated (o, 1) };
 
     // display whether r0 or fp0 is allocated. these should then also be reflected somewhere in the stack too.
     d_m3Log(stack, "\n");
     d_m3Log(stack, "        ");
     printf ("%s %s    ", regAllocated [0] ? "(r0)" : "    ", regAllocated [1] ? "(fp0)" : "     ");
 
 //  printf ("%d", o->stackIndex -)
     for (u32 i = o->stackFirstDynamicIndex; i < o->stackIndex; ++i)
     {
         printf (" %s", c_waCompactTypes [o->typeStack [i]]);
 
         u16 slot = o->wasmStack [i];
 
         if (IsRegisterSlotAlias (slot))
         {
             bool isFp = IsFpRegisterSlotAlias (slot);
             printf ("%s", isFp ? "f0" : "r0");
 
             regAllocated [isFp]--;
         }
         else
         {
             if (slot < o->slotFirstDynamicIndex)
             {
                 if (slot >= o->slotFirstConstIndex)
                     printf ("c");
                 else if (slot >= o->function->numRetAndArgSlots)
                     printf ("L");
                 else
                     printf ("a");
             }
 
             printf ("%d", (i32) slot);  // slot
         }
 
         printf (" ");
     }
     printf ("\n");
 
     for (u32 r = 0; r < 2; ++r)
         d_m3Assert (regAllocated [r] == 0);         // reg allocation & stack out of sync
-    
+
     u16 maxSlot = GetMaxUsedSlotPlusOne (o);
-    
+
     if (maxSlot > o->slotFirstDynamicIndex)
     {
         d_m3Log (stack, "                      -");
 
         for (u16 i = o->slotFirstDynamicIndex; i < maxSlot; ++i)
             printf ("----");
 
         printf ("\n");
 
         d_m3Log (stack, "                 slot |");
         for (u16 i = o->slotFirstDynamicIndex; i < maxSlot; ++i)
             printf ("%3d|", i);
 
         printf ("\n");
         d_m3Log (stack, "                alloc |");
 
         for (u16 i = o->slotFirstDynamicIndex; i < maxSlot; ++i)
         {
             printf ("%3d|", o->m3Slots [i]);
         }
-        
+
         printf ("\n");
     }
     d_m3Log(stack, "\n");
 }
diff --git a/source/m3_module.c b/source/m3_module.c
index 1566fb0..eeb6fdb 100644
--- a/source/m3_module.c
+++ b/source/m3_module.c
@@ -22,28 +22,25 @@ void Module_FreeFunctions (IM3Module i_module)
 void  m3_FreeModule  (IM3Module i_module)
 {
     if (i_module)
     {
         m3log (module, "freeing module: %s (funcs: %d; segments: %d)",
                i_module->name, i_module->numFunctions, i_module->numDataSegments);
 
         Module_FreeFunctions (i_module);
 
         m3_Free (i_module->functions);
         //m3_Free (i_module->imports);
         m3_Free (i_module->funcTypes);
         m3_Free (i_module->dataSegments);
         m3_Free (i_module->table0);
 
         for (u32 i = 0; i < i_module->numGlobals; ++i)
         {
             m3_Free (i_module->globals[i].name);
-        }
-        for (u32 i = 0; i < i_module->numGlobals; ++i)
-        {
             FreeImportInfo(&(i_module->globals[i].import));
         }
         m3_Free (i_module->globals);
 
         m3_Free (i_module);
     }
 }
@@ -119,11 +116,16 @@ IM3Function  Module_GetFunction  (IM3Module i_module, u32 i_functionIndex)
 const char*  m3_GetModuleName  (IM3Module i_module)
 {
     if (!i_module || !i_module->name)
-        return "<unknown>";
+        return ".unnamed";
 
     return i_module->name;
 }
 
+void  m3_SetModuleName  (IM3Module i_module, const char* name)
+{
+    if (i_module) i_module->name = name;
+}
+
 IM3Runtime  m3_GetModuleRuntime  (IM3Module i_module)
 {
     return i_module ? i_module->runtime : NULL;
diff --git a/source/wasm3.h b/source/wasm3.h
index caf7cbd..32fb3e1 100644
--- a/source/wasm3.h
+++ b/source/wasm3.h
@@ -177,135 +177,136 @@ d_m3ErrorConst  (trapUnreachable,               "[trap] unreachable executed")
 d_m3ErrorConst  (trapStackOverflow,             "[trap] stack overflow")
 
 
 //-------------------------------------------------------------------------------------------------------------------------------
 //  configuration, can be found in m3_config.h, m3_config_platforms.h, m3_core.h)
 //-------------------------------------------------------------------------------------------------------------------------------
 
 //-------------------------------------------------------------------------------------------------------------------------------
 //  global environment than can host multiple runtimes
 //-------------------------------------------------------------------------------------------------------------------------------
     IM3Environment      m3_NewEnvironment           (void);
 
     void                m3_FreeEnvironment          (IM3Environment i_environment);
 
 //-------------------------------------------------------------------------------------------------------------------------------
 //  execution context
 //-------------------------------------------------------------------------------------------------------------------------------
 
     IM3Runtime          m3_NewRuntime               (IM3Environment         io_environment,
                                                      uint32_t               i_stackSizeInBytes,
                                                      void *                 i_userdata);
 
     void                m3_FreeRuntime              (IM3Runtime             i_runtime);
 
     // Wasm currently only supports one memory region. i_memoryIndex should be zero.
     uint8_t *           m3_GetMemory                (IM3Runtime             i_runtime,
                                                      uint32_t *             o_memorySizeInBytes,
                                                      uint32_t               i_memoryIndex);
 
     void *              m3_GetUserData              (IM3Runtime             i_runtime);
 
 
 //-------------------------------------------------------------------------------------------------------------------------------
 //  modules
 //-------------------------------------------------------------------------------------------------------------------------------
 
     // i_wasmBytes data must be persistent during the lifetime of the module
     M3Result            m3_ParseModule              (IM3Environment         i_environment,
                                                      IM3Module *            o_module,
                                                      const uint8_t * const  i_wasmBytes,
                                                      uint32_t               i_numWasmBytes);
 
     // Only modules not loaded into a M3Runtime need to be freed. A module is considered unloaded if
     // a. m3_LoadModule has not yet been called on that module. Or,
     // b. m3_LoadModule returned a result.
     void                m3_FreeModule               (IM3Module i_module);
 
     //  LoadModule transfers ownership of a module to the runtime. Do not free modules once successfully loaded into the runtime
     M3Result            m3_LoadModule               (IM3Runtime io_runtime,  IM3Module io_module);
 
     // Calling m3_RunStart is optional
     M3Result            m3_RunStart                 (IM3Module i_module);
 
     // Arguments and return values are passed in and out through the stack pointer _sp.
     // Placeholder return value slots are first and arguments after. So, the first argument is at _sp [numReturns]
     // Return values should be written into _sp [0] to _sp [num_returns - 1]
     typedef const void * (* M3RawCall) (IM3Runtime runtime, IM3ImportContext _ctx, uint64_t * _sp, void * _mem);
 
     M3Result            m3_LinkRawFunction          (IM3Module              io_module,
                                                      const char * const     i_moduleName,
                                                      const char * const     i_functionName,
                                                      const char * const     i_signature,
                                                      M3RawCall              i_function);
 
     M3Result            m3_LinkRawFunctionEx        (IM3Module              io_module,
                                                      const char * const     i_moduleName,
                                                      const char * const     i_functionName,
                                                      const char * const     i_signature,
                                                      M3RawCall              i_function,
                                                      const void *           i_userdata);
 
     const char*         m3_GetModuleName            (IM3Module i_module);
+    void                m3_SetModuleName            (IM3Module i_module, const char* name);
     IM3Runtime          m3_GetModuleRuntime         (IM3Module i_module);
 
 //-------------------------------------------------------------------------------------------------------------------------------
 //  globals
 //-------------------------------------------------------------------------------------------------------------------------------
     IM3Global           m3_FindGlobal               (IM3Module              io_module,
                                                      const char * const     i_globalName);
 
     M3Result            m3_GetGlobal                (IM3Global              i_global,
                                                      IM3TaggedValue         o_value);
 
     M3Result            m3_SetGlobal                (IM3Global              i_global,
                                                      const IM3TaggedValue   i_value);
 
     M3ValueType         m3_GetGlobalType            (IM3Global              i_global);
 
 //-------------------------------------------------------------------------------------------------------------------------------
 //  functions
 //-------------------------------------------------------------------------------------------------------------------------------
     M3Result            m3_Yield                    (void);
 
     // o_function is valid during the lifetime of the originating runtime
     M3Result            m3_FindFunction             (IM3Function *          o_function,
                                                      IM3Runtime             i_runtime,
                                                      const char * const     i_functionName);
 
     uint32_t            m3_GetArgCount              (IM3Function i_function);
     uint32_t            m3_GetRetCount              (IM3Function i_function);
     M3ValueType         m3_GetArgType               (IM3Function i_function, uint32_t i_index);
     M3ValueType         m3_GetRetType               (IM3Function i_function, uint32_t i_index);
 
     M3Result            m3_CallV                    (IM3Function i_function, ...);
     M3Result            m3_CallVL                   (IM3Function i_function, va_list i_args);
     M3Result            m3_Call                     (IM3Function i_function, uint32_t i_argc, const void * i_argptrs[]);
     M3Result            m3_CallArgv                 (IM3Function i_function, uint32_t i_argc, const char * i_argv[]);
 
     M3Result            m3_GetResultsV              (IM3Function i_function, ...);
     M3Result            m3_GetResultsVL             (IM3Function i_function, va_list o_rets);
     M3Result            m3_GetResults               (IM3Function i_function, uint32_t i_retc, const void * o_retptrs[]);
 
 
     void                m3_GetErrorInfo             (IM3Runtime i_runtime, M3ErrorInfo* o_info);
     void                m3_ResetErrorInfo           (IM3Runtime i_runtime);
 
     const char*         m3_GetFunctionName          (IM3Function i_function);
     IM3Module           m3_GetFunctionModule        (IM3Function i_function);
 
 //-------------------------------------------------------------------------------------------------------------------------------
 //  debug info
 //-------------------------------------------------------------------------------------------------------------------------------
 
     void                m3_PrintRuntimeInfo         (IM3Runtime i_runtime);
     void                m3_PrintM3Info              (void);
     void                m3_PrintProfilerInfo        (void);
 
     // The runtime owns the backtrace, do not free the backtrace you obtain. Returns NULL if there's no backtrace.
     IM3BacktraceInfo    m3_GetBacktrace             (IM3Runtime i_runtime);
 
 #if defined(__cplusplus)
 }
 #endif
 
 #endif // wasm3_h
