commit e283d7543073d4a02df644fc8673260f4dd88777
Author: Even Rouault <even.rouault@mines-paris.org>
Date:   Tue May 30 11:06:00 2017 +0000

    OSM: reduce memory usage on big node ids in OSM_USE_CUSTOM_INDEXING=YES default mode. Fixes https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=1918. Credit to OSS Fuzz
    
    git-svn-id: https://svn.osgeo.org/gdal/trunk@38685 f0d54148-0727-0410-94bb-9a71ac55c965

diff --git a/gdal/ogr/ogrsf_frmts/osm/ogr_osm.h b/gdal/ogr/ogrsf_frmts/osm/ogr_osm.h
index 103e2dd63d..a3d5c0bbb6 100644
--- a/gdal/ogr/ogrsf_frmts/osm/ogr_osm.h
+++ b/gdal/ogr/ogrsf_frmts/osm/ogr_osm.h
@@ -283,228 +283,227 @@ typedef struct
 class OGROSMDataSource : public OGRDataSource
 {
     friend class OGROSMLayer;
 
     int                 nLayers;
     OGROSMLayer**       papoLayers;
     char*               pszName;
 
     OGREnvelope         sExtent;
     bool                bExtentValid;
 
     // Starts off at -1 to indicate that we do not know.
     int                 bInterleavedReading;
     OGROSMLayer        *poCurrentLayer;
 
     OSMContext         *psParser;
     bool                bHasParsedFirstChunk;
     bool                bStopParsing;
 
     sqlite3_vfs*        pMyVFS;
 
     sqlite3            *hDB;
     sqlite3_stmt       *hInsertNodeStmt;
     sqlite3_stmt       *hInsertWayStmt;
     sqlite3_stmt       *hSelectNodeBetweenStmt;
     sqlite3_stmt      **pahSelectNodeStmt;
     sqlite3_stmt      **pahSelectWayStmt;
     sqlite3_stmt       *hInsertPolygonsStandaloneStmt;
     sqlite3_stmt       *hDeletePolygonsStandaloneStmt;
     sqlite3_stmt       *hSelectPolygonsStandaloneStmt;
     bool                bHasRowInPolygonsStandalone;
 
     sqlite3            *hDBForComputedAttributes;
 
     int                 nMaxSizeForInMemoryDBInMB;
     bool                bInMemoryTmpDB;
     bool                bMustUnlink;
     CPLString           osTmpDBName;
 
     int                 nNodesInTransaction;
 
     std::set<std::string> aoSetClosedWaysArePolygons;
 
     LonLat             *pasLonLatCache;
 
     bool                bReportAllNodes;
     bool                bReportAllWays;
 
     bool                bFeatureAdded;
 
     bool                bInTransaction;
 
     bool                bIndexPoints;
     bool                bUsePointsIndex;
     bool                bIndexWays;
     bool                bUseWaysIndex;
 
     std::vector<bool>   abSavedDeclaredInterest;
     OGRLayer*           poResultSetLayer;
     bool                bIndexPointsBackup;
     bool                bUsePointsIndexBackup;
     bool                bIndexWaysBackup;
     bool                bUseWaysIndexBackup;
 
     bool                bIsFeatureCountEnabled;
 
     bool                bAttributeNameLaundering;
 
     GByte              *pabyWayBuffer;
 
     int                 nWaysProcessed;
     int                 nRelationsProcessed;
 
     bool                bCustomIndexing;
     bool                bCompressNodes;
 
     unsigned int        nUnsortedReqIds;
     GIntBig            *panUnsortedReqIds;
 
     unsigned int        nReqIds;
     GIntBig            *panReqIds;
 
 #ifdef ENABLE_NODE_LOOKUP_BY_HASHING
     bool                bEnableHashedIndex;
     /* values >= 0 are indexes of panReqIds. */
     /*        == -1 for unoccupied */
     /*        < -1 are expressed as -nIndexToCollisonBuckets-2 where nIndexToCollisonBuckets point to psCollisionBuckets */
     int                *panHashedIndexes;
     CollisionBucket    *psCollisionBuckets;
     bool                bHashedIndexValid;
 #endif
 
     LonLat             *pasLonLatArray;
 
     IndexedKVP         *pasAccumulatedTags; /* points to content of pabyNonRedundantValues or aoMapIndexedKeys */
     int                 nAccumulatedTags;
     GByte              *pabyNonRedundantValues;
     int                 nNonRedundantValuesLen;
     WayFeaturePair     *pasWayFeaturePairs;
     int                 nWayFeaturePairs;
 
     int                          nNextKeyIndex;
     std::vector<KeyDesc*>         asKeys;
     std::map<const char*, KeyDesc*, ConstCharComp> aoMapIndexedKeys; /* map that is the reverse of asKeys */
 
     CPLString           osNodesFilename;
     bool                bInMemoryNodesFile;
     bool                bMustUnlinkNodesFile;
     GIntBig             nNodesFileSize;
     VSILFILE           *fpNodes;
 
     GIntBig             nPrevNodeId;
     int                 nBucketOld;
     int                 nOffInBucketReducedOld;
     GByte              *pabySector;
-    Bucket             *papsBuckets;
-    int                 nBuckets;
+    std::map<int, Bucket> oMapBuckets;
+    Bucket*             GetBucket(int nBucketId);
 
     bool                bNeedsToSaveWayInfo;
 
     static const GIntBig FILESIZE_NOT_INIT = -2;
     static const GIntBig FILESIZE_INVALID = -1;
     GIntBig             m_nFileSize;
 
     int                 CompressWay (bool bIsArea, unsigned int nTags, IndexedKVP* pasTags,
                                      int nPoints, LonLat* pasLonLatPairs,
                                      OSMInfo* psInfo,
                                      GByte* pabyCompressedWay);
     int                 UncompressWay( int nBytes, GByte* pabyCompressedWay,
                                        bool *pbIsArea, LonLat* pasCoords,
                                        unsigned int* pnTags, OSMTag* pasTags,
                                        OSMInfo* psInfo );
 
     bool                ParseConf(char** papszOpenOptions);
     bool                CreateTempDB();
     bool                SetDBOptions();
     bool                SetCacheSize();
     bool                CreatePreparedStatements();
     void                CloseDB();
 
     bool                IndexPoint( OSMNode* psNode );
     bool                IndexPointSQLite( OSMNode* psNode );
     bool                FlushCurrentSector();
     bool                FlushCurrentSectorCompressedCase();
     bool                FlushCurrentSectorNonCompressedCase();
     bool                IndexPointCustom( OSMNode* psNode );
 
     void                IndexWay(GIntBig nWayID, bool bIsArea,
                                  unsigned int nTags, IndexedKVP* pasTags,
                                  LonLat* pasLonLatPairs, int nPairs,
                                  OSMInfo* psInfo);
 
     bool                StartTransactionCacheDB();
     bool                CommitTransactionCacheDB();
 
     int                 FindNode(GIntBig nID);
     void                ProcessWaysBatch();
 
     void                ProcessPolygonsStandalone();
 
     void                LookupNodes();
     void                LookupNodesSQLite();
     void                LookupNodesCustom();
     void                LookupNodesCustomCompressedCase();
     void                LookupNodesCustomNonCompressedCase();
 
     unsigned int        LookupWays( std::map< GIntBig, std::pair<int,void*> >& aoMapWays,
                                     OSMRelation* psRelation );
 
     OGRGeometry*        BuildMultiPolygon(OSMRelation* psRelation,
                                           unsigned int* pnTags,
                                           OSMTag* pasTags);
     OGRGeometry*        BuildGeometryCollection(OSMRelation* psRelation, int bMultiLineString);
 
     bool                TransferToDiskIfNecesserary();
 
-    bool                AllocBucket(int iBucket);
-    bool                AllocMoreBuckets( int nNewBucketIdx );
+    Bucket*             AllocBucket(int iBucket);
 
     void                AddComputedAttributes(int iCurLayer,
                                              const std::vector<OGROSMComputedAttribute>& oAttributes);
     bool                IsClosedWayTaggedAsPolygon( unsigned int nTags, const OSMTag* pasTags );
 
   public:
                         OGROSMDataSource();
                         virtual ~OGROSMDataSource();
 
     virtual const char *GetName() override { return pszName; }
     virtual int         GetLayerCount() override { return nLayers; }
     virtual OGRLayer   *GetLayer( int ) override;
 
     virtual int         TestCapability( const char * ) override;
 
     virtual OGRLayer *  ExecuteSQL( const char *pszSQLCommand,
                                     OGRGeometry *poSpatialFilter,
                                     const char *pszDialect ) override;
     virtual void        ReleaseResultSet( OGRLayer * poLayer ) override;
 
     virtual void        ResetReading() override;
     virtual OGRFeature* GetNextFeature( OGRLayer** ppoBelongingLayer,
                                         double* pdfProgressPct,
                                        GDALProgressFunc pfnProgress,
                                         void* pProgressData ) override;
 
     int                 Open ( const char* pszFilename, char** papszOpenOptions );
 
     int                 MyResetReading();
     bool                ParseNextChunk(int nIdxLayer,
                                        GDALProgressFunc pfnProgress,
                                        void* pProgressData);
     OGRErr              GetExtent( OGREnvelope *psExtent );
     int                 IsInterleavedReading();
 
     void                NotifyNodes(unsigned int nNodes, OSMNode* pasNodes);
     void                NotifyWay (OSMWay* psWay);
     void                NotifyRelation (OSMRelation* psRelation);
     void                NotifyBounds (double dfXMin, double dfYMin,
                                       double dfXMax, double dfYMax);
 
     OGROSMLayer*        GetCurrentLayer() { return poCurrentLayer; }
     void                SetCurrentLayer(OGROSMLayer* poLyr) { poCurrentLayer = poLyr; }
 
     bool                IsFeatureCountEnabled() const { return bIsFeatureCountEnabled; }
 
     bool                DoesAttributeNameLaundering() const { return bAttributeNameLaundering; }
 };
 
 #endif /* ndef OGR_OSM_H_INCLUDED */
diff --git a/gdal/ogr/ogrsf_frmts/osm/ogrosmdatasource.cpp b/gdal/ogr/ogrsf_frmts/osm/ogrosmdatasource.cpp
index 58d5e6ee6a..3a6a9f09ee 100644
--- a/gdal/ogr/ogrsf_frmts/osm/ogrosmdatasource.cpp
+++ b/gdal/ogr/ogrsf_frmts/osm/ogrosmdatasource.cpp
@@ -69,9 +69,6 @@ static const int WAY_BUFFER_SIZE =
 
 static const int NODE_PER_BUCKET = 65536;
 
-// Initial Maximum count of buckets.
-static const int INIT_BUCKET_COUNT = 65536;
-
 static bool VALID_ID_FOR_CUSTOM_INDEXING( GIntBig _id )
 {
     return
@@ -206,82 +203,80 @@ static CPLString GetInterestLayersForDSName( const CPLString& osDSName )
 OGROSMDataSource::OGROSMDataSource() :
     nLayers(0),
     papoLayers(NULL),
     pszName(NULL),
     bExtentValid(false),
     bInterleavedReading(-1),
     poCurrentLayer(NULL),
     psParser(NULL),
     bHasParsedFirstChunk(false),
     bStopParsing(false),
     pMyVFS(NULL),
     hDB(NULL),
     hInsertNodeStmt(NULL),
     hInsertWayStmt(NULL),
     hSelectNodeBetweenStmt(NULL),
     pahSelectNodeStmt(NULL),
     pahSelectWayStmt(NULL),
     hInsertPolygonsStandaloneStmt(NULL),
     hDeletePolygonsStandaloneStmt(NULL),
     hSelectPolygonsStandaloneStmt(NULL),
     bHasRowInPolygonsStandalone(false),
     hDBForComputedAttributes(NULL),
     nMaxSizeForInMemoryDBInMB(0),
     bInMemoryTmpDB(false),
     bMustUnlink(true),
     nNodesInTransaction(0),
     pasLonLatCache(NULL),
     bReportAllNodes(false),
     bReportAllWays(false),
     bFeatureAdded(false),
     bInTransaction(false),
     bIndexPoints(true),
     bUsePointsIndex(true),
     bIndexWays(true),
     bUseWaysIndex(true),
     poResultSetLayer(NULL),
     bIndexPointsBackup(false),
     bUsePointsIndexBackup(false),
     bIndexWaysBackup(false),
     bUseWaysIndexBackup(false),
     bIsFeatureCountEnabled(false),
     bAttributeNameLaundering(true),
     pabyWayBuffer(NULL),
     nWaysProcessed(0),
     nRelationsProcessed(0),
     bCustomIndexing(true),
     bCompressNodes(false),
     nUnsortedReqIds(0),
     panUnsortedReqIds(NULL),
     nReqIds(0),
     panReqIds(NULL),
 #ifdef ENABLE_NODE_LOOKUP_BY_HASHING
     bEnableHashedIndex(true),
     panHashedIndexes(NULL),
     psCollisionBuckets(NULL),
     bHashedIndexValid(false),
 #endif
     pasLonLatArray(NULL),
     pasAccumulatedTags(NULL),
     nAccumulatedTags(0),
     pabyNonRedundantValues(NULL),
     nNonRedundantValuesLen(0),
     pasWayFeaturePairs(NULL),
     nWayFeaturePairs(0),
     nNextKeyIndex(0),
     bInMemoryNodesFile(false),
     bMustUnlinkNodesFile(true),
     nNodesFileSize(0),
     fpNodes(NULL),
     nPrevNodeId(-INT_MAX),
     nBucketOld(-1),
     nOffInBucketReducedOld(-1),
     pabySector(NULL),
-    papsBuckets(NULL),
-    nBuckets(0),
     bNeedsToSaveWayInfo(false),
     m_nFileSize(FILESIZE_NOT_INIT)
 {}
 
 /************************************************************************/
 /*                          ~OGROSMDataSource()                         */
 /************************************************************************/
@@ -289,110 +284,107 @@ OGROSMDataSource::OGROSMDataSource() :
 OGROSMDataSource::~OGROSMDataSource()
 
 {
     for( int i=0; i<nLayers; i++ )
         delete papoLayers[i];
     CPLFree(papoLayers);
 
     CPLFree(pszName);
 
     if( psParser != NULL )
         CPLDebug( "OSM",
                   "Number of bytes read in file : " CPL_FRMT_GUIB,
                   OSM_GetBytesRead(psParser) );
     OSM_Close(psParser);
 
     CPLFree(pasLonLatCache);
     CPLFree(pabyWayBuffer);
 
     if( hDB != NULL )
         CloseDB();
 
     if( hDBForComputedAttributes != NULL )
         sqlite3_close(hDBForComputedAttributes);
 
     if( pMyVFS )
     {
         sqlite3_vfs_unregister(pMyVFS);
         CPLFree(pMyVFS->pAppData);
         CPLFree(pMyVFS);
     }
 
     if( !osTmpDBName.empty() && bMustUnlink )
     {
         const char* pszVal = CPLGetConfigOption("OSM_UNLINK_TMPFILE", "YES");
         if( !EQUAL(pszVal, "NOT_EVEN_AT_END") )
             VSIUnlink(osTmpDBName);
     }
 
     CPLFree(panReqIds);
 #ifdef ENABLE_NODE_LOOKUP_BY_HASHING
     CPLFree(panHashedIndexes);
     CPLFree(psCollisionBuckets);
 #endif
     CPLFree(pasLonLatArray);
     CPLFree(panUnsortedReqIds);
 
     for( int i = 0; i < nWayFeaturePairs; i++)
     {
         delete pasWayFeaturePairs[i].poFeature;
     }
     CPLFree(pasWayFeaturePairs);
     CPLFree(pasAccumulatedTags);
     CPLFree(pabyNonRedundantValues);
 
 #ifdef OSM_DEBUG
     FILE* f = fopen("keys.txt", "wt");
     for( int i=0; i<startic_cast<int>(asKeys.size()); i++ )
     {
         KeyDesc* psKD = asKeys[i];
         fprintf(f, "%08d idx=%d %s\n",
                 psKD->nOccurrences,
                 psKD->nKeyIndex,
                 psKD->pszK);
     }
     fclose(f);
 #endif
 
     for( int i=0; i<static_cast<int>(asKeys.size()); i++ )
     {
         KeyDesc* psKD = asKeys[i];
         CPLFree(psKD->pszK);
         for( int j=0; j<static_cast<int>(psKD->asValues.size());j++)
             CPLFree(psKD->asValues[j]);
         delete psKD;
     }
 
     if( fpNodes )
         VSIFCloseL(fpNodes);
     if( !osNodesFilename.empty() && bMustUnlinkNodesFile )
     {
         const char* pszVal = CPLGetConfigOption("OSM_UNLINK_TMPFILE", "YES");
         if( !EQUAL(pszVal, "NOT_EVEN_AT_END") )
             VSIUnlink(osNodesFilename);
     }
 
     CPLFree(pabySector);
-    if( papsBuckets )
+    std::map<int, Bucket>::iterator oIter = oMapBuckets.begin();
+    for( ; oIter != oMapBuckets.end(); ++oIter )
     {
-        for( int i = 0; i < nBuckets; i++)
+        if( bCompressNodes )
         {
-            if( bCompressNodes )
-            {
-                int nRem = i % (knPAGE_SIZE / BUCKET_SECTOR_SIZE_ARRAY_SIZE);
-                if( nRem == 0 )
-                    CPLFree(papsBuckets[i].u.panSectorSize);
-            }
-            else
-            {
-                int nRem = i % (knPAGE_SIZE / BUCKET_BITMAP_SIZE);
-                if( nRem == 0 )
-                    CPLFree(papsBuckets[i].u.pabyBitmap);
-            }
+            int nRem = oIter->first % (knPAGE_SIZE / BUCKET_SECTOR_SIZE_ARRAY_SIZE);
+            if( nRem == 0 )
+                CPLFree(oIter->second.u.panSectorSize);
+        }
+        else
+        {
+            int nRem = oIter->first % (knPAGE_SIZE / BUCKET_BITMAP_SIZE);
+            if( nRem == 0 )
+                CPLFree(oIter->second.u.pabyBitmap);
         }
-        CPLFree(papsBuckets);
     }
 }
 
 /************************************************************************/
 /*                             CloseDB()                               */
 /************************************************************************/
@@ -529,87 +521,72 @@ bool OGROSMDataSource::FlushCurrentSector()
 /*                            AllocBucket()                             */
 /************************************************************************/
 
-bool OGROSMDataSource::AllocBucket( int iBucket )
+Bucket* OGROSMDataSource::AllocBucket( int iBucket )
 {
     if( bCompressNodes )
     {
         const int nRem = iBucket % (knPAGE_SIZE / BUCKET_SECTOR_SIZE_ARRAY_SIZE);
-        if( papsBuckets[iBucket - nRem].u.panSectorSize == NULL )
-            papsBuckets[iBucket - nRem].u.panSectorSize =
+        Bucket* psPrevBucket = GetBucket(iBucket - nRem);
+        if( psPrevBucket->u.panSectorSize == NULL )
+            psPrevBucket->u.panSectorSize =
                 static_cast<GByte*>(VSI_CALLOC_VERBOSE(1, knPAGE_SIZE));
-        if( papsBuckets[iBucket - nRem].u.panSectorSize != NULL )
+        GByte* panSectorSize = psPrevBucket->u.panSectorSize;
+        Bucket* psBucket = GetBucket( iBucket );
+        if( panSectorSize != NULL )
         {
-            papsBuckets[iBucket].u.panSectorSize =
-                papsBuckets[iBucket - nRem].u.panSectorSize +
+            psBucket->u.panSectorSize =
+                panSectorSize +
                 nRem * BUCKET_SECTOR_SIZE_ARRAY_SIZE;
-            return true;
+            return psBucket;
         }
-        papsBuckets[iBucket].u.panSectorSize = NULL;
+        psBucket->u.panSectorSize = NULL;
     }
     else
     {
         const int nRem = iBucket % (knPAGE_SIZE / BUCKET_BITMAP_SIZE);
-        if( papsBuckets[iBucket - nRem].u.pabyBitmap == NULL )
-            papsBuckets[iBucket - nRem].u.pabyBitmap =
+        Bucket* psPrevBucket = GetBucket(iBucket - nRem);
+        if( psPrevBucket->u.pabyBitmap == NULL )
+            psPrevBucket->u.pabyBitmap =
                 reinterpret_cast<GByte *>(VSI_CALLOC_VERBOSE(1, knPAGE_SIZE));
-        if( papsBuckets[iBucket - nRem].u.pabyBitmap != NULL )
+        GByte* pabyBitmap = psPrevBucket->u.pabyBitmap; 
+        Bucket* psBucket = GetBucket( iBucket );
+        if( pabyBitmap != NULL )
         {
-            papsBuckets[iBucket].u.pabyBitmap =
-                papsBuckets[iBucket - nRem].u.pabyBitmap +
+            psBucket->u.pabyBitmap =
+                pabyBitmap +
                 nRem * BUCKET_BITMAP_SIZE;
-            return true;
+            return psBucket;
         }
-        papsBuckets[iBucket].u.pabyBitmap = NULL;
+        psBucket->u.pabyBitmap = NULL;
     }
 
     // Out of memory.
     CPLError( CE_Failure, CPLE_AppDefined,
               "AllocBucket() failed. Use OSM_USE_CUSTOM_INDEXING=NO" );
     bStopParsing = true;
-    return false;
+    return NULL;
 }
 
 /************************************************************************/
-/*                         AllocMoreBuckets()                           */
+/*                             GetBucket()                              */
 /************************************************************************/
 
-bool OGROSMDataSource::AllocMoreBuckets( int nNewBucketIdx )
+Bucket* OGROSMDataSource::GetBucket(int nBucketId)
 {
-    CPLAssert(nNewBucketIdx >= nBuckets);
-
-    const int nNewBuckets = std::max(nBuckets + nBuckets / 2, nNewBucketIdx);
-
-    size_t nNewSize = sizeof(Bucket) * nNewBuckets;
-    if( static_cast<GUIntBig>(nNewSize) !=
-        sizeof(Bucket) * static_cast<GUIntBig>(nNewBuckets) )
-    {
-        CPLError(CE_Failure, CPLE_AppDefined, "AllocMoreBuckets() failed. Use OSM_USE_CUSTOM_INDEXING=NO");
-        bStopParsing = true;
-        return false;
-    }
-
-    Bucket* papsNewBuckets = (Bucket*) VSI_REALLOC_VERBOSE(papsBuckets, nNewSize);
-    if( papsNewBuckets == NULL )
+    std::map<int, Bucket>::iterator oIter = oMapBuckets.find(nBucketId);
+    if( oIter == oMapBuckets.end() )
     {
-        CPLError(CE_Failure, CPLE_AppDefined, "AllocMoreBuckets() failed. Use OSM_USE_CUSTOM_INDEXING=NO");
-        bStopParsing = true;
-        return false;
-    }
-    papsBuckets = papsNewBuckets;
-
-    for(int i = nBuckets; i < nNewBuckets; i++)
-    {
-        papsBuckets[i].nOff = -1;
+        Bucket* psBucket = &oMapBuckets[nBucketId];
+        psBucket->nOff = -1;
         if( bCompressNodes )
-            papsBuckets[i].u.panSectorSize = NULL;
+            psBucket->u.panSectorSize = NULL;
         else
-            papsBuckets[i].u.pabyBitmap = NULL;
+            psBucket->u.pabyBitmap = NULL;
+        return psBucket;
     }
-    nBuckets = nNewBuckets;
-
-    return true;
+    return &(oIter->second);
 }
 
 /************************************************************************/
 /*                     FlushCurrentSectorCompressedCase()               */
 /************************************************************************/
@@ -617,82 +594,81 @@ bool OGROSMDataSource::AllocMoreBuckets( int nNewBucketIdx )
 bool OGROSMDataSource::FlushCurrentSectorCompressedCase()
 {
     GByte abyOutBuffer[2 * SECTOR_SIZE];
     GByte* pabyOut = abyOutBuffer;
     LonLat* pasLonLatIn = (LonLat*)pabySector;
     int nLastLon = 0;
     int nLastLat = 0;
     bool bLastValid = false;
 
     CPLAssert((NODE_PER_SECTOR % 8) == 0);
     memset(abyOutBuffer, 0, NODE_PER_SECTOR / 8);
     pabyOut += NODE_PER_SECTOR / 8;
     for( int i = 0; i < NODE_PER_SECTOR; i++)
     {
         if( pasLonLatIn[i].nLon || pasLonLatIn[i].nLat )
         {
             abyOutBuffer[i >> 3] |= (1 << (i % 8));
             if( bLastValid )
             {
                 const GIntBig nDiff64Lon =
                   static_cast<GIntBig>(pasLonLatIn[i].nLon) -
                   static_cast<GIntBig>(nLastLon);
                 const GIntBig nDiff64Lat = pasLonLatIn[i].nLat - nLastLat;
                 WriteVarSInt64(nDiff64Lon, &pabyOut);
                 WriteVarSInt64(nDiff64Lat, &pabyOut);
             }
             else
             {
                 memcpy(pabyOut, &pasLonLatIn[i], sizeof(LonLat));
                 pabyOut += sizeof(LonLat);
             }
             bLastValid = true;
 
             nLastLon = pasLonLatIn[i].nLon;
             nLastLat = pasLonLatIn[i].nLat;
         }
     }
 
     size_t nCompressSize = static_cast<size_t>(pabyOut - abyOutBuffer);
     CPLAssert(nCompressSize < sizeof(abyOutBuffer) - 1);
     abyOutBuffer[nCompressSize] = 0;
 
     nCompressSize = ROUND_COMPRESS_SIZE(nCompressSize);
     GByte* pabyToWrite = NULL;
     if( nCompressSize >= static_cast<size_t>(SECTOR_SIZE) )
     {
         nCompressSize = SECTOR_SIZE;
         pabyToWrite = pabySector;
     }
     else
         pabyToWrite = abyOutBuffer;
 
     if( VSIFWriteL(pabyToWrite, 1, nCompressSize, fpNodes) == nCompressSize )
     {
         memset(pabySector, 0, SECTOR_SIZE);
         nNodesFileSize += nCompressSize;
 
-        if( nBucketOld >= nBuckets )
+        Bucket* psBucket = GetBucket(nBucketOld);
+        if( psBucket->u.panSectorSize == NULL )
         {
-            if( !AllocMoreBuckets(nBucketOld + 1) )
+            psBucket = AllocBucket(nBucketOld);
+            if( psBucket == NULL )
                 return false;
         }
-        Bucket* psBucket = &papsBuckets[nBucketOld];
-        if( psBucket->u.panSectorSize == NULL && !AllocBucket(nBucketOld) )
-            return false;
         CPLAssert( psBucket->u.panSectorSize != NULL );
         psBucket->u.panSectorSize[nOffInBucketReducedOld] =
                                     COMPRESS_SIZE_TO_BYTE(nCompressSize);
 
         return true;
     }
 
     CPLError( CE_Failure, CPLE_AppDefined,
               "Cannot write in temporary node file %s : %s",
               osNodesFilename.c_str(), VSIStrerror(errno));
 
     return false;
 }
 
 /************************************************************************/
 /*                   FlushCurrentSectorNonCompressedCase()              */
 /************************************************************************/
@@ -721,82 +697,81 @@ bool OGROSMDataSource::FlushCurrentSectorNonCompressedCase()
 bool OGROSMDataSource::IndexPointCustom(OSMNode* psNode)
 {
     if( psNode->nID <= nPrevNodeId)
     {
         CPLError(CE_Failure, CPLE_AppDefined,
                  "Non increasing node id. Use OSM_USE_CUSTOM_INDEXING=NO");
         bStopParsing = true;
         return false;
     }
     if( !VALID_ID_FOR_CUSTOM_INDEXING(psNode->nID) )
     {
         CPLError( CE_Failure, CPLE_AppDefined,
                   "Unsupported node id value (" CPL_FRMT_GIB
                   "). Use OSM_USE_CUSTOM_INDEXING=NO",
                   psNode->nID);
         bStopParsing = true;
         return false;
     }
 
     const int nBucket = static_cast<int>(psNode->nID / NODE_PER_BUCKET);
     const int nOffInBucket = static_cast<int>(psNode->nID % NODE_PER_BUCKET);
     const int nOffInBucketReduced = nOffInBucket >> NODE_PER_SECTOR_SHIFT;
     const int nOffInBucketReducedRemainer =
         nOffInBucket & ((1 << NODE_PER_SECTOR_SHIFT) - 1);
 
-    if( nBucket >= nBuckets )
-    {
-        if( !AllocMoreBuckets(nBucket + 1) )
-            return false;
-    }
-    Bucket* psBucket = &papsBuckets[nBucket];
+    Bucket* psBucket = GetBucket(nBucket);
 
     if( !bCompressNodes )
     {
         const int nBitmapIndex = nOffInBucketReduced / 8;
         const int nBitmapRemainer = nOffInBucketReduced % 8;
-        if( psBucket->u.pabyBitmap == NULL && !AllocBucket(nBucket) )
-            return false;
+        if( psBucket->u.pabyBitmap == NULL )
+        {
+            psBucket = AllocBucket(nBucket);
+            if( psBucket == NULL )
+                return false;
+        }
         CPLAssert( psBucket->u.pabyBitmap != NULL );
         psBucket->u.pabyBitmap[nBitmapIndex] |= (1 << nBitmapRemainer);
     }
 
     if( nBucket != nBucketOld )
     {
         CPLAssert(nBucket > nBucketOld);
         if( nBucketOld >= 0 )
         {
             if( !FlushCurrentSector() )
             {
                 bStopParsing = true;
                 return false;
             }
         }
         nBucketOld = nBucket;
         nOffInBucketReducedOld = nOffInBucketReduced;
         CPLAssert(psBucket->nOff == -1);
         psBucket->nOff = VSIFTellL(fpNodes);
     }
     else if( nOffInBucketReduced != nOffInBucketReducedOld )
     {
         CPLAssert(nOffInBucketReduced > nOffInBucketReducedOld);
         if( !FlushCurrentSector() )
         {
             bStopParsing = true;
             return false;
         }
         nOffInBucketReducedOld = nOffInBucketReduced;
     }
 
     LonLat* psLonLat = reinterpret_cast<LonLat*>(
         pabySector + sizeof(LonLat) * nOffInBucketReducedRemainer);
     psLonLat->nLon = DBL_TO_INT(psNode->dfLon);
     psLonLat->nLat = DBL_TO_INT(psNode->dfLat);
 
     nPrevNodeId = psNode->nID;
 
     return true;
 }
 
 /************************************************************************/
 /*                             NotifyNodes()                            */
 /************************************************************************/
@@ -1084,79 +1059,80 @@ static bool DecompressSector( GByte* pabyIn, int nSectorSize, GByte* pabyOut )
 void OGROSMDataSource::LookupNodesCustom( )
 {
     nReqIds = 0;
 
     if( nBucketOld >= 0 )
     {
         if( !FlushCurrentSector() )
         {
             bStopParsing = true;
             return;
         }
 
         nBucketOld = -1;
     }
 
     CPLAssert(
         nUnsortedReqIds <= static_cast<unsigned int>(MAX_ACCUMULATED_NODES));
 
     for( unsigned int i = 0; i < nUnsortedReqIds; i++ )
     {
         GIntBig id = panUnsortedReqIds[i];
 
         if( !VALID_ID_FOR_CUSTOM_INDEXING(id) )
             continue;
 
         int nBucket = static_cast<int>(id / NODE_PER_BUCKET);
         int nOffInBucket = static_cast<int>(id % NODE_PER_BUCKET);
         int nOffInBucketReduced = nOffInBucket >> NODE_PER_SECTOR_SHIFT;
 
-        if( nBucket >= nBuckets )
+        std::map<int, Bucket>::const_iterator oIter = oMapBuckets.find(nBucket);
+        if( oIter == oMapBuckets.end() )
             continue;
-        Bucket* psBucket = &papsBuckets[nBucket];
+        const Bucket* psBucket = &(oIter->second);
 
         if( bCompressNodes )
         {
             if( psBucket->u.panSectorSize == NULL ||
                 !(psBucket->u.panSectorSize[nOffInBucketReduced]) )
                 continue;
         }
         else
         {
             int nBitmapIndex = nOffInBucketReduced / 8;
             int nBitmapRemainer = nOffInBucketReduced % 8;
             if( psBucket->u.pabyBitmap == NULL ||
                 !(psBucket->u.pabyBitmap[nBitmapIndex] & (1 << nBitmapRemainer)) )
                 continue;
         }
 
         panReqIds[nReqIds++] = id;
     }
 
     std::sort(panReqIds, panReqIds + nReqIds);
 
     /* Remove duplicates */
     unsigned int j = 0;  // Used after for.
     for( unsigned int i = 0; i < nReqIds; i++)
     {
         if( !(i > 0 && panReqIds[i] == panReqIds[i-1]) )
             panReqIds[j++] = panReqIds[i];
     }
     nReqIds = j;
 
 #ifdef FAKE_LOOKUP_NODES
     for( unsigned int i = 0; i < nReqIds; i++)
     {
         pasLonLatArray[i].nLon = 0;
         pasLonLatArray[i].nLat = 0;
     }
 #else
     if( bCompressNodes )
         LookupNodesCustomCompressedCase();
     else
         LookupNodesCustomNonCompressedCase();
 #endif
 }
 
 /************************************************************************/
 /*                      LookupNodesCustomCompressedCase()               */
 /************************************************************************/
@@ -1164,111 +1140,112 @@ void OGROSMDataSource::LookupNodesCustom( )
 void OGROSMDataSource::LookupNodesCustomCompressedCase()
 {
     static const int SECURITY_MARGIN = 8 + 8 + 2 * NODE_PER_SECTOR;
     GByte abyRawSector[SECTOR_SIZE + SECURITY_MARGIN];
     memset(abyRawSector + SECTOR_SIZE, 0, SECURITY_MARGIN);
 
     int l_nBucketOld = -1;
     int l_nOffInBucketReducedOld = -1;
     int k = 0;
     int nOffFromBucketStart = 0;
 
     unsigned int j = 0;  // Used after for.
     for( unsigned int i = 0; i < nReqIds; i++ )
     {
         const GIntBig id = panReqIds[i];
         const int nBucket = static_cast<int>(id / NODE_PER_BUCKET);
         const int nOffInBucket = static_cast<int>(id % NODE_PER_BUCKET);
         const int nOffInBucketReduced = nOffInBucket >> NODE_PER_SECTOR_SHIFT;
         const int nOffInBucketReducedRemainer =
             nOffInBucket & ((1 << NODE_PER_SECTOR_SHIFT) - 1);
 
         if( nBucket != l_nBucketOld )
         {
             l_nOffInBucketReducedOld = -1;
             k = 0;
             nOffFromBucketStart = 0;
         }
 
         if( nOffInBucketReduced != l_nOffInBucketReducedOld )
         {
-            if( nBucket >= nBuckets )
+            std::map<int, Bucket>::const_iterator oIter = oMapBuckets.find(nBucket);
+            if( oIter == oMapBuckets.end() )
             {
                 CPLError(CE_Failure,  CPLE_AppDefined,
                         "Cannot read node " CPL_FRMT_GIB, id);
                 continue;
                 // FIXME ?
             }
-            Bucket* psBucket = &papsBuckets[nBucket];
+            const Bucket* psBucket = &(oIter->second);
             if( psBucket->u.panSectorSize == NULL )
             {
                 CPLError(CE_Failure,  CPLE_AppDefined,
                         "Cannot read node " CPL_FRMT_GIB, id);
                 continue;
                 // FIXME ?
             }
             const int nSectorSize =
                 COMPRESS_SIZE_FROM_BYTE(
                     psBucket->u.panSectorSize[nOffInBucketReduced]);
 
             /* If we stay in the same bucket, we can reuse the previously */
             /* computed offset, instead of starting from bucket start */
             for( ; k < nOffInBucketReduced; k++ )
             {
                 if( psBucket->u.panSectorSize[k] )
                     nOffFromBucketStart +=
                         COMPRESS_SIZE_FROM_BYTE(psBucket->u.panSectorSize[k]);
             }
 
             VSIFSeekL(fpNodes, psBucket->nOff + nOffFromBucketStart, SEEK_SET);
             if( nSectorSize == SECTOR_SIZE )
             {
                 if( VSIFReadL(pabySector, 1,
                               static_cast<size_t>(SECTOR_SIZE),
                               fpNodes) != static_cast<size_t>(SECTOR_SIZE) )
                 {
                     CPLError(CE_Failure,  CPLE_AppDefined,
                             "Cannot read node " CPL_FRMT_GIB, id);
                     continue;
                     // FIXME ?
                 }
             }
             else
             {
                 if( static_cast<int>(VSIFReadL(abyRawSector, 1, nSectorSize,
                                                fpNodes)) != nSectorSize )
                 {
                     CPLError(CE_Failure,  CPLE_AppDefined,
                             "Cannot read sector for node " CPL_FRMT_GIB, id);
                     continue;
                     // FIXME ?
                 }
                 abyRawSector[nSectorSize] = 0;
 
                 if( !DecompressSector(abyRawSector, nSectorSize, pabySector) )
                 {
                     CPLError( CE_Failure,  CPLE_AppDefined,
                               "Error while uncompressing sector for node "
                               CPL_FRMT_GIB, id );
                     continue;
                     // FIXME ?
                 }
             }
 
             l_nBucketOld = nBucket;
             l_nOffInBucketReducedOld = nOffInBucketReduced;
         }
 
         panReqIds[j] = id;
         memcpy(pasLonLatArray + j,
                pabySector + nOffInBucketReducedRemainer * sizeof(LonLat),
                sizeof(LonLat));
 
         if( pasLonLatArray[j].nLon || pasLonLatArray[j].nLat )
             j++;
     }
     nReqIds = j;
 }
 
 /************************************************************************/
 /*                    LookupNodesCustomNonCompressedCase()              */
 /************************************************************************/
@@ -1276,65 +1253,66 @@ void OGROSMDataSource::LookupNodesCustomCompressedCase()
 void OGROSMDataSource::LookupNodesCustomNonCompressedCase()
 {
     unsigned int j = 0;  // Used after for.
 
     for( unsigned int i = 0; i < nReqIds; i++ )
     {
         const GIntBig id = panReqIds[i];
         const int nBucket = static_cast<int>(id / NODE_PER_BUCKET);
         const int nOffInBucket = static_cast<int>(id % NODE_PER_BUCKET);
         const int nOffInBucketReduced = nOffInBucket >> NODE_PER_SECTOR_SHIFT;
         const int nOffInBucketReducedRemainer =
             nOffInBucket & ((1 << NODE_PER_SECTOR_SHIFT) - 1);
 
         const int nBitmapIndex = nOffInBucketReduced / 8;
         const int nBitmapRemainer = nOffInBucketReduced % 8;
 
-        if( nBucket >= nBuckets )
+        std::map<int, Bucket>::const_iterator oIter = oMapBuckets.find(nBucket);
+        if( oIter == oMapBuckets.end() )
         {
             CPLError(CE_Failure,  CPLE_AppDefined,
                     "Cannot read node " CPL_FRMT_GIB, id);
             continue;
             // FIXME ?
         }
-        Bucket* psBucket = &papsBuckets[nBucket];
+        const Bucket* psBucket = &(oIter->second);
         if( psBucket->u.pabyBitmap == NULL )
         {
             CPLError(CE_Failure,  CPLE_AppDefined,
                     "Cannot read node " CPL_FRMT_GIB, id);
             continue;
             // FIXME ?
         }
 
         int nSector = 0;
         for( int k = 0; k < nBitmapIndex; k++ )
             nSector += abyBitsCount[psBucket->u.pabyBitmap[k]];
         if( nBitmapRemainer )
             nSector +=
                 abyBitsCount[psBucket->u.pabyBitmap[nBitmapIndex] &
                              ((1 << nBitmapRemainer) - 1)];
 
         VSIFSeekL(
             fpNodes,
             psBucket->nOff + nSector * SECTOR_SIZE +
             nOffInBucketReducedRemainer * sizeof(LonLat),
             SEEK_SET);
         if( VSIFReadL(pasLonLatArray + j, 1,
                       sizeof(LonLat), fpNodes) != sizeof(LonLat) )
         {
             CPLError(CE_Failure,  CPLE_AppDefined,
                      "Cannot read node " CPL_FRMT_GIB, id);
             // FIXME ?
         }
         else
         {
             panReqIds[j] = id;
             if( pasLonLatArray[j].nLon || pasLonLatArray[j].nLat )
                 j++;
         }
     }
     nReqIds = j;
 }
 
 /************************************************************************/
 /*                            WriteVarInt()                             */
 /************************************************************************/
@@ -2732,200 +2710,200 @@ static void OGROSMNotifyBounds( double dfXMin, double dfYMin,
 int OGROSMDataSource::Open( const char * pszFilename,
                             char** papszOpenOptionsIn )
 
 {
     pszName = CPLStrdup( pszFilename );
 
     psParser = OSM_Open( pszName,
                          OGROSMNotifyNodes,
                          OGROSMNotifyWay,
                          OGROSMNotifyRelation,
                          OGROSMNotifyBounds,
                          this );
     if( psParser == NULL )
         return FALSE;
 
     if( CPLFetchBool(papszOpenOptionsIn, "INTERLEAVED_READING", false) )
         bInterleavedReading = TRUE;
 
     /* The following 4 config options are only useful for debugging */
     bIndexPoints = CPLTestBool(CPLGetConfigOption("OSM_INDEX_POINTS", "YES"));
     bUsePointsIndex = CPLTestBool(
         CPLGetConfigOption("OSM_USE_POINTS_INDEX", "YES"));
     bIndexWays = CPLTestBool(CPLGetConfigOption("OSM_INDEX_WAYS", "YES"));
     bUseWaysIndex = CPLTestBool(
         CPLGetConfigOption("OSM_USE_WAYS_INDEX", "YES"));
 
     bCustomIndexing = CPLTestBool(CSLFetchNameValueDef(
             papszOpenOptionsIn, "USE_CUSTOM_INDEXING",
                         CPLGetConfigOption("OSM_USE_CUSTOM_INDEXING", "YES")));
     if( !bCustomIndexing )
         CPLDebug("OSM", "Using SQLite indexing for points");
     bCompressNodes = CPLTestBool(CSLFetchNameValueDef(
             papszOpenOptionsIn, "COMPRESS_NODES",
                         CPLGetConfigOption("OSM_COMPRESS_NODES", "NO")));
     if( bCompressNodes )
         CPLDebug("OSM", "Using compression for nodes DB");
 
     nLayers = 5;
     papoLayers = static_cast<OGROSMLayer **>(
         CPLMalloc(nLayers * sizeof(OGROSMLayer*)) );
 
     papoLayers[IDX_LYR_POINTS] =
         new OGROSMLayer(this, IDX_LYR_POINTS, "points");
     papoLayers[IDX_LYR_POINTS]->GetLayerDefn()->SetGeomType(wkbPoint);
 
     papoLayers[IDX_LYR_LINES] = new OGROSMLayer(this, IDX_LYR_LINES, "lines");
     papoLayers[IDX_LYR_LINES]->GetLayerDefn()->SetGeomType(wkbLineString);
 
     papoLayers[IDX_LYR_MULTILINESTRINGS] =
         new OGROSMLayer(this, IDX_LYR_MULTILINESTRINGS, "multilinestrings");
     papoLayers[IDX_LYR_MULTILINESTRINGS]->GetLayerDefn()->
         SetGeomType(wkbMultiLineString);
 
     papoLayers[IDX_LYR_MULTIPOLYGONS] =
         new OGROSMLayer(this, IDX_LYR_MULTIPOLYGONS, "multipolygons");
     papoLayers[IDX_LYR_MULTIPOLYGONS]->GetLayerDefn()->
         SetGeomType(wkbMultiPolygon);
 
     papoLayers[IDX_LYR_OTHER_RELATIONS] =
         new OGROSMLayer(this, IDX_LYR_OTHER_RELATIONS, "other_relations");
     papoLayers[IDX_LYR_OTHER_RELATIONS]->GetLayerDefn()->
         SetGeomType(wkbGeometryCollection);
 
     if( !ParseConf(papszOpenOptionsIn) )
     {
         CPLError( CE_Failure, CPLE_AppDefined,
                   "Could not parse configuration file for OSM import");
         return FALSE;
     }
 
     bNeedsToSaveWayInfo =
         ( papoLayers[IDX_LYR_MULTIPOLYGONS]->HasTimestamp() ||
           papoLayers[IDX_LYR_MULTIPOLYGONS]->HasChangeset() ||
           papoLayers[IDX_LYR_MULTIPOLYGONS]->HasVersion() ||
           papoLayers[IDX_LYR_MULTIPOLYGONS]->HasUID() ||
           papoLayers[IDX_LYR_MULTIPOLYGONS]->HasUser() );
 
     pasLonLatCache = static_cast<LonLat*>(
         VSI_MALLOC_VERBOSE(MAX_NODES_PER_WAY * sizeof(LonLat)));
     pabyWayBuffer = static_cast<GByte*>(VSI_MALLOC_VERBOSE(WAY_BUFFER_SIZE));
 
     panReqIds = static_cast<GIntBig*>(
         VSI_MALLOC_VERBOSE(MAX_ACCUMULATED_NODES * sizeof(GIntBig)));
 #ifdef ENABLE_NODE_LOOKUP_BY_HASHING
     panHashedIndexes = static_cast<int*>(
         VSI_MALLOC_VERBOSE(HASHED_INDEXES_ARRAY_SIZE * sizeof(int)));
     psCollisionBuckets = static_cast<CollisionBucket*>(
         VSI_MALLOC_VERBOSE(COLLISION_BUCKET_ARRAY_SIZE *
                            sizeof(CollisionBucket)));
 #endif
     pasLonLatArray = static_cast<LonLat*>(
         VSI_MALLOC_VERBOSE(MAX_ACCUMULATED_NODES * sizeof(LonLat)));
     panUnsortedReqIds = static_cast<GIntBig*>(
         VSI_MALLOC_VERBOSE(MAX_ACCUMULATED_NODES * sizeof(GIntBig)));
     pasWayFeaturePairs = static_cast<WayFeaturePair*>(
         VSI_MALLOC_VERBOSE(MAX_DELAYED_FEATURES * sizeof(WayFeaturePair)));
     pasAccumulatedTags = static_cast<IndexedKVP*>(
         VSI_MALLOC_VERBOSE(MAX_ACCUMULATED_TAGS * sizeof(IndexedKVP)) );
     pabyNonRedundantValues = static_cast<GByte*>(
         VSI_MALLOC_VERBOSE(MAX_NON_REDUNDANT_VALUES) );
 
     if( pasLonLatCache == NULL ||
         pabyWayBuffer == NULL ||
         panReqIds == NULL ||
         pasLonLatArray == NULL ||
         panUnsortedReqIds == NULL ||
         pasWayFeaturePairs == NULL ||
         pasAccumulatedTags == NULL ||
         pabyNonRedundantValues == NULL )
     {
         return FALSE;
     }
 
     nMaxSizeForInMemoryDBInMB = atoi(CSLFetchNameValueDef(papszOpenOptionsIn,
         "MAX_TMPFILE_SIZE", CPLGetConfigOption("OSM_MAX_TMPFILE_SIZE", "100")));
     GIntBig nSize =
         static_cast<GIntBig>(nMaxSizeForInMemoryDBInMB) * 1024 * 1024;
     if( nSize < 0 || (GIntBig)(size_t)nSize != nSize )
     {
         CPLError( CE_Failure, CPLE_AppDefined,
                   "Invalid value for OSM_MAX_TMPFILE_SIZE. Using 100 instead." );
         nMaxSizeForInMemoryDBInMB = 100;
         nSize = static_cast<GIntBig>(nMaxSizeForInMemoryDBInMB) * 1024 * 1024;
     }
 
     if( bCustomIndexing )
     {
         pabySector = static_cast<GByte *>(VSI_CALLOC_VERBOSE(1, SECTOR_SIZE));
 
-        if( pabySector == NULL || !AllocMoreBuckets(INIT_BUCKET_COUNT) )
+        if( pabySector == NULL )
         {
             return FALSE;
         }
 
         bInMemoryNodesFile = true;
         osNodesFilename.Printf("/vsimem/osm_importer/osm_temp_nodes_%p", this);
         fpNodes = VSIFOpenL(osNodesFilename, "wb+");
         if( fpNodes == NULL )
         {
             return FALSE;
         }
 
         CPLPushErrorHandler(CPLQuietErrorHandler);
         bool bSuccess =
             VSIFSeekL(fpNodes, (vsi_l_offset) (nSize * 3 / 4), SEEK_SET) == 0;
         CPLPopErrorHandler();
 
         if( bSuccess )
         {
             VSIFSeekL(fpNodes, 0, SEEK_SET);
             VSIFTruncateL(fpNodes, 0);
         }
         else
         {
             CPLDebug( "OSM",
                       "Not enough memory for in-memory file. "
                       "Using disk temporary file instead." );
 
             VSIFCloseL(fpNodes);
             fpNodes = NULL;
             VSIUnlink(osNodesFilename);
 
             bInMemoryNodesFile = false;
             osNodesFilename = CPLGenerateTempFilename("osm_tmp_nodes");
 
             fpNodes = VSIFOpenL(osNodesFilename, "wb+");
             if( fpNodes == NULL )
             {
                 return FALSE;
             }
 
             /* On Unix filesystems, you can remove a file even if it */
             /* opened */
             const char* pszVal = CPLGetConfigOption("OSM_UNLINK_TMPFILE", "YES");
             if( EQUAL(pszVal, "YES") )
             {
                 CPLPushErrorHandler(CPLQuietErrorHandler);
                 bMustUnlinkNodesFile = VSIUnlink( osNodesFilename ) != 0;
                 CPLPopErrorHandler();
             }
 
             return FALSE;
         }
     }
 
     const bool bRet = CreateTempDB();
     if( bRet )
     {
         CPLString osInterestLayers = GetInterestLayersForDSName(GetName());
         if( !osInterestLayers.empty() )
         {
             delete ExecuteSQL( osInterestLayers, NULL, NULL );
         }
     }
     return bRet;
 }
 
 /************************************************************************/
 /*                             CreateTempDB()                           */
 /************************************************************************/
@@ -3711,107 +3689,110 @@ bool OGROSMDataSource::ParseConf( char** papszOpenOptionsIn )
 int OGROSMDataSource::MyResetReading()
 {
     if( hDB == NULL )
         return FALSE;
     if( bCustomIndexing && fpNodes == NULL )
         return FALSE;
 
     OSM_ResetReading(psParser);
 
     char* pszErrMsg = NULL;
     int rc = sqlite3_exec( hDB, "DELETE FROM nodes", NULL, NULL, &pszErrMsg );
     if( rc != SQLITE_OK )
     {
         CPLError( CE_Failure, CPLE_AppDefined,
                   "Unable to DELETE FROM nodes : %s", pszErrMsg );
         sqlite3_free( pszErrMsg );
         return FALSE;
     }
 
     rc = sqlite3_exec( hDB, "DELETE FROM ways", NULL, NULL, &pszErrMsg );
     if( rc != SQLITE_OK )
     {
         CPLError( CE_Failure, CPLE_AppDefined,
                   "Unable to DELETE FROM ways : %s", pszErrMsg );
         sqlite3_free( pszErrMsg );
         return FALSE;
     }
 
     rc = sqlite3_exec( hDB, "DELETE FROM polygons_standalone", NULL, NULL,
                        &pszErrMsg );
     if( rc != SQLITE_OK )
     {
         CPLError( CE_Failure, CPLE_AppDefined,
                   "Unable to DELETE FROM polygons_standalone : %s", pszErrMsg );
         sqlite3_free( pszErrMsg );
         return FALSE;
     }
     bHasRowInPolygonsStandalone = false;
 
     if( hSelectPolygonsStandaloneStmt != NULL )
         sqlite3_reset( hSelectPolygonsStandaloneStmt );
 
     {
         for( int i = 0; i < nWayFeaturePairs; i++)
         {
             delete pasWayFeaturePairs[i].poFeature;
         }
         nWayFeaturePairs = 0;
         nUnsortedReqIds = 0;
         nReqIds = 0;
         nAccumulatedTags = 0;
         nNonRedundantValuesLen = 0;
 
         for( int i=0;i<static_cast<int>(asKeys.size()); i++ )
         {
             KeyDesc* psKD = asKeys[i];
             CPLFree(psKD->pszK);
             for(int j=0;j<(int)psKD->asValues.size();j++)
                 CPLFree(psKD->asValues[j]);
             delete psKD;
         }
         asKeys.resize(0);
         aoMapIndexedKeys.clear();
         nNextKeyIndex = 0;
     }
 
     if( bCustomIndexing )
     {
         nPrevNodeId = -1;
         nBucketOld = -1;
         nOffInBucketReducedOld = -1;
 
         VSIFSeekL(fpNodes, 0, SEEK_SET);
         VSIFTruncateL(fpNodes, 0);
         nNodesFileSize = 0;
 
         memset(pabySector, 0, SECTOR_SIZE);
-        for(int i = 0; i < nBuckets; i++)
+
+        std::map<int, Bucket>::iterator oIter = oMapBuckets.begin();
+        for( ; oIter != oMapBuckets.end(); ++oIter )
         {
-            papsBuckets[i].nOff = -1;
+            Bucket* psBucket = &(oIter->second);
+            psBucket->nOff = -1;
             if( bCompressNodes )
             {
-                if( papsBuckets[i].u.panSectorSize )
-                    memset(papsBuckets[i].u.panSectorSize, 0, BUCKET_SECTOR_SIZE_ARRAY_SIZE);
+                if( psBucket->u.panSectorSize )
+                    memset(psBucket->u.panSectorSize, 0, BUCKET_SECTOR_SIZE_ARRAY_SIZE);
             }
             else
             {
-                if( papsBuckets[i].u.pabyBitmap )
-                    memset(papsBuckets[i].u.pabyBitmap, 0, BUCKET_BITMAP_SIZE);
+                if( psBucket->u.pabyBitmap )
+                    memset(psBucket->u.pabyBitmap, 0, BUCKET_BITMAP_SIZE);
             }
         }
     }
 
     for(int i=0;i<nLayers;i++)
     {
         papoLayers[i]->ForceResetReading();
     }
 
     bStopParsing = false;
     poCurrentLayer = NULL;
 
     return TRUE;
 }
 
 /************************************************************************/
 /*                             ResetReading()                           */
 /************************************************************************/
