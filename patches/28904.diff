commit e64855fbfaf4a629f7eaa10ab9216690b5fc715f
Author: John Stiles <johnstiles@google.com>
Date:   Wed Dec 23 12:56:14 2020 -0500

    Fix fuzzer-discovered crash with negated swizzles.
    
    This CL updates `compareConstant` to fail gracefully instead of
    aborting if the passed-in types don't match. This lets us call
    `compareConstant` without checking types first.
    
    Change-Id: Id2acdbdf700e64bcb24825cdad2c0e000992e8cb
    Bug: oss-fuzz:28904
    Reviewed-on: https://skia-review.googlesource.com/c/skia/+/347038
    Commit-Queue: John Stiles <johnstiles@google.com>
    Reviewed-by: Brian Osman <brianosman@google.com>

diff --git a/gn/sksl_tests.gni b/gn/sksl_tests.gni
index b7d5a280a5..74856b4709 100644
--- a/gn/sksl_tests.gni
+++ b/gn/sksl_tests.gni
@@ -202,180 +202,181 @@ sksl_spirv_tests = [
 sksl_shared_tests = [
   "$_tests/sksl/intrinsics/Abs.sksl",
   "$_tests/sksl/intrinsics/Acos.sksl",
   "$_tests/sksl/intrinsics/Acosh.sksl",
   "$_tests/sksl/intrinsics/All.sksl",
   "$_tests/sksl/intrinsics/Any.sksl",
   "$_tests/sksl/intrinsics/Asin.sksl",
   "$_tests/sksl/intrinsics/Asinh.sksl",
   "$_tests/sksl/intrinsics/Atan.sksl",
   "$_tests/sksl/intrinsics/Atanh.sksl",
   "$_tests/sksl/intrinsics/BitCount.sksl",
   "$_tests/sksl/intrinsics/Ceil.sksl",
   "$_tests/sksl/intrinsics/Clamp.sksl",
   "$_tests/sksl/intrinsics/Cos.sksl",
   "$_tests/sksl/intrinsics/Cosh.sksl",
   "$_tests/sksl/intrinsics/Cross.sksl",
   "$_tests/sksl/intrinsics/Degrees.sksl",
   "$_tests/sksl/intrinsics/Determinant.sksl",
   "$_tests/sksl/intrinsics/DFdx.sksl",
   "$_tests/sksl/intrinsics/DFdy.sksl",
   "$_tests/sksl/intrinsics/Distance.sksl",
   "$_tests/sksl/intrinsics/Dot.sksl",
   "$_tests/sksl/intrinsics/Equal.sksl",
   "$_tests/sksl/intrinsics/Exp.sksl",
   "$_tests/sksl/intrinsics/Exp2.sksl",
   "$_tests/sksl/intrinsics/FaceForward.sksl",
   "$_tests/sksl/intrinsics/FindLSB.sksl",
   "$_tests/sksl/intrinsics/FindMSB.sksl",
   "$_tests/sksl/intrinsics/FloatBitsToInt.sksl",
   "$_tests/sksl/intrinsics/FloatBitsToUint.sksl",
   "$_tests/sksl/intrinsics/Floor.sksl",
   "$_tests/sksl/intrinsics/Fma.sksl",
   "$_tests/sksl/intrinsics/Fract.sksl",
   "$_tests/sksl/intrinsics/Frexp.sksl",
   "$_tests/sksl/intrinsics/Fwidth.sksl",
   "$_tests/sksl/intrinsics/GreaterThan.sksl",
   "$_tests/sksl/intrinsics/GreaterThanEqual.sksl",
   "$_tests/sksl/intrinsics/IntBitsToFloat.sksl",
   "$_tests/sksl/intrinsics/Inverse.sksl",
   "$_tests/sksl/intrinsics/Inversesqrt.sksl",
   "$_tests/sksl/intrinsics/IsInf.sksl",
   "$_tests/sksl/intrinsics/IsNan.sksl",
   "$_tests/sksl/intrinsics/Ldexp.sksl",
   "$_tests/sksl/intrinsics/Length.sksl",
   "$_tests/sksl/intrinsics/LessThan.sksl",
   "$_tests/sksl/intrinsics/LessThanEqual.sksl",
   "$_tests/sksl/intrinsics/Log.sksl",
   "$_tests/sksl/intrinsics/Log2.sksl",
   "$_tests/sksl/intrinsics/MatrixCompMult.sksl",
   "$_tests/sksl/intrinsics/Max.sksl",
   "$_tests/sksl/intrinsics/Min.sksl",
   "$_tests/sksl/intrinsics/Mix.sksl",
   "$_tests/sksl/intrinsics/Mod.sksl",
   "$_tests/sksl/intrinsics/Modf.sksl",
   "$_tests/sksl/intrinsics/Normalize.sksl",
   "$_tests/sksl/intrinsics/Not.sksl",
   "$_tests/sksl/intrinsics/NotEqual.sksl",
   "$_tests/sksl/intrinsics/OuterProduct.sksl",
   "$_tests/sksl/intrinsics/Pack.sksl",
   "$_tests/sksl/intrinsics/Pow.sksl",
   "$_tests/sksl/intrinsics/Radians.sksl",
   "$_tests/sksl/intrinsics/Reflect.sksl",
   "$_tests/sksl/intrinsics/Refract.sksl",
   "$_tests/sksl/intrinsics/Round.sksl",
   "$_tests/sksl/intrinsics/RoundEven.sksl",
   "$_tests/sksl/intrinsics/Saturate.sksl",
   "$_tests/sksl/intrinsics/Sign.sksl",
   "$_tests/sksl/intrinsics/Sin.sksl",
   "$_tests/sksl/intrinsics/Sinh.sksl",
   "$_tests/sksl/intrinsics/Smoothstep.sksl",
   "$_tests/sksl/intrinsics/Sqrt.sksl",
   "$_tests/sksl/intrinsics/Step.sksl",
   "$_tests/sksl/intrinsics/Tan.sksl",
   "$_tests/sksl/intrinsics/Tanh.sksl",
   "$_tests/sksl/intrinsics/Transpose.sksl",
   "$_tests/sksl/intrinsics/Trunc.sksl",
   "$_tests/sksl/intrinsics/UintBitsToFloat.sksl",
   "$_tests/sksl/intrinsics/Unpack.sksl",
   "$_tests/sksl/shared/ArrayConstructors.sksl",
   "$_tests/sksl/shared/ArrayIndexTypes.sksl",
   "$_tests/sksl/shared/ArrayTypes.sksl",
   "$_tests/sksl/shared/Assignment.sksl",
   "$_tests/sksl/shared/BoolFolding.sksl",
   "$_tests/sksl/shared/Caps.sksl",
   "$_tests/sksl/shared/CastsRoundTowardZero.sksl",
   "$_tests/sksl/shared/Clockwise.sksl",
   "$_tests/sksl/shared/ComplexDelete.sksl",
   "$_tests/sksl/shared/ConstArray.sksl",
   "$_tests/sksl/shared/ConstVariableComparison.sksl",
   "$_tests/sksl/shared/ConstantIf.sksl",
   "$_tests/sksl/shared/Control.sksl",
   "$_tests/sksl/shared/DeadDoWhileLoop.sksl",
   "$_tests/sksl/shared/DeadIfStatement.sksl",
   "$_tests/sksl/shared/DeadLoopVariable.sksl",
   "$_tests/sksl/shared/DeadStripFunctions.sksl",
   "$_tests/sksl/shared/DependentInitializers.sksl",
   "$_tests/sksl/shared/DerivativesUnused.sksl",
   "$_tests/sksl/shared/Discard.sksl",
   "$_tests/sksl/shared/Enum.sksl",
   "$_tests/sksl/shared/FloatFolding.sksl",
   "$_tests/sksl/shared/FragCoordsFlipY.sksl",
   "$_tests/sksl/shared/FragCoordsNew.sksl",
   "$_tests/sksl/shared/FragCoordsOld.sksl",
   "$_tests/sksl/shared/FunctionArgumentMatch.sksl",
   "$_tests/sksl/shared/FunctionPrototype.sksl",
   "$_tests/sksl/shared/Functions.sksl",
   "$_tests/sksl/shared/GaussianBlur.sksl",
   "$_tests/sksl/shared/GeometricIntrinsics.sksl",
   "$_tests/sksl/shared/Geometry.geom",
   "$_tests/sksl/shared/GeometryExtension.geom",
   "$_tests/sksl/shared/GeometryGSInvocations.geom",
   "$_tests/sksl/shared/GeometryNoGSInvocations.geom",
   "$_tests/sksl/shared/GeometryNoGSInvocationsReorder.geom",
   "$_tests/sksl/shared/Height.sksl",
   "$_tests/sksl/shared/HelloWorld.sksl",
   "$_tests/sksl/shared/Hex.sksl",
   "$_tests/sksl/shared/InstanceID.vert",
   "$_tests/sksl/shared/IntFolding.sksl",
   "$_tests/sksl/shared/InterfaceBlockAnonymous.sksl",
   "$_tests/sksl/shared/InterfaceBlockArray.sksl",
   "$_tests/sksl/shared/InterfaceBlockNamed.sksl",
   "$_tests/sksl/shared/Matrices.sksl",
   "$_tests/sksl/shared/MatrixFolding.sksl",
   "$_tests/sksl/shared/MixedTypeCommaOperator.sksl",
   "$_tests/sksl/shared/MultipleAssignments.sksl",
   "$_tests/sksl/shared/NegatedVectorLiteral.sksl",
   "$_tests/sksl/shared/NoFragCoordsPos.vert",
   "$_tests/sksl/shared/NoFragCoordsPosRT.vert",
   "$_tests/sksl/shared/NormalizationGeo.geom",
   "$_tests/sksl/shared/NormalizationVert.vert",
   "$_tests/sksl/shared/NumberConversions.sksl",
   "$_tests/sksl/shared/Offset.sksl",
   "$_tests/sksl/shared/Operators.sksl",
   "$_tests/sksl/shared/Ossfuzz26167.sksl",
   "$_tests/sksl/shared/Ossfuzz27614.sksl",
   "$_tests/sksl/shared/Ossfuzz28050.sksl",
   "$_tests/sksl/shared/Ossfuzz28794.sksl",
+  "$_tests/sksl/shared/Ossfuzz28904.sksl",
   "$_tests/sksl/shared/OutParams.sksl",
   "$_tests/sksl/shared/OutParamsTricky.sksl",
   "$_tests/sksl/shared/RectangleTexture.sksl",
   "$_tests/sksl/shared/ResizeMatrix.sksl",
   "$_tests/sksl/shared/SampleMask.sksl",
   "$_tests/sksl/shared/ScopedSymbol.sksl",
   "$_tests/sksl/shared/ShortCircuitBoolFolding.sksl",
   "$_tests/sksl/shared/StackingVectorCasts.sksl",
   "$_tests/sksl/shared/StaticIf.sksl",
   "$_tests/sksl/shared/StaticSwitch.sksl",
   "$_tests/sksl/shared/StaticSwitchWithBreak.sksl",
   "$_tests/sksl/shared/StaticSwitchWithBreakInsideBlock.sksl",
   "$_tests/sksl/shared/StaticSwitchWithConditionalBreak.sksl",
   "$_tests/sksl/shared/StaticSwitchWithConditionalBreakInsideBlock.sksl",
   "$_tests/sksl/shared/StaticSwitchWithFallthroughA.sksl",
   "$_tests/sksl/shared/StaticSwitchWithFallthroughB.sksl",
   "$_tests/sksl/shared/StaticSwitchWithStaticConditionalBreak.sksl",
   "$_tests/sksl/shared/StaticSwitchWithStaticConditionalBreakInsideBlock.sksl",
   "$_tests/sksl/shared/Structs.sksl",
   "$_tests/sksl/shared/StructMaxDepth.sksl",
   "$_tests/sksl/shared/Switch.sksl",
   "$_tests/sksl/shared/SwitchContainingDeadCode.sksl",
   "$_tests/sksl/shared/SwitchWithFallthrough.sksl",
   "$_tests/sksl/shared/SwizzleBoolConstants.sksl",
   "$_tests/sksl/shared/SwizzleByIndex.sksl",
   "$_tests/sksl/shared/SwizzleConstants.sksl",
   "$_tests/sksl/shared/SwizzleLTRB.sksl",
   "$_tests/sksl/shared/SwizzleOpt.sksl",
   "$_tests/sksl/shared/SwizzleScalar.sksl",
   "$_tests/sksl/shared/TernaryAsLValueEntirelyFoldable.sksl",
   "$_tests/sksl/shared/TernaryAsLValueFoldableTest.sksl",
   "$_tests/sksl/shared/Texture1D.sksl",
   "$_tests/sksl/shared/Texture2D.sksl",
   "$_tests/sksl/shared/TextureSharpen.sksl",
   "$_tests/sksl/shared/UnaryPositiveNegative.sksl",
   "$_tests/sksl/shared/UniformArray.sksl",
   "$_tests/sksl/shared/UnusedVariables.sksl",
   "$_tests/sksl/shared/VectorConstructors.sksl",
   "$_tests/sksl/shared/VectorFolding.sksl",
   "$_tests/sksl/shared/VertexEarlyReturn.vert",
   "$_tests/sksl/shared/VertexID.vert",
   "$_tests/sksl/shared/Width.sksl",
 ]
diff --git a/src/sksl/SkSLIRGenerator.cpp b/src/sksl/SkSLIRGenerator.cpp
index a8badcea58..f7289b4ba7 100644
--- a/src/sksl/SkSLIRGenerator.cpp
+++ b/src/sksl/SkSLIRGenerator.cpp
@@ -1786,49 +1786,57 @@ template <typename T>
 std::unique_ptr<Expression> IRGenerator::constantFoldVector(const Expression& left,
                                                             Token::Kind op,
                                                             const Expression& right) const {
     SkASSERT(left.type() == right.type());
     const Type& type = left.type();
 
     // Handle boolean operations: == !=
     if (op == Token::Kind::TK_EQEQ || op == Token::Kind::TK_NEQ) {
-        if (left.kind() == right.kind()) {
-            bool result = left.compareConstant(fContext, right) ^ (op == Token::Kind::TK_NEQ);
-            return std::make_unique<BoolLiteral>(fContext, left.fOffset, result);
+        bool equality = (op == Token::Kind::TK_EQEQ);
+
+        switch (left.compareConstant(fContext, right)) {
+            case Expression::ComparisonResult::kNotEqual:
+                equality = !equality;
+                [[fallthrough]];
+
+            case Expression::ComparisonResult::kEqual:
+                return std::make_unique<BoolLiteral>(fContext, left.fOffset, equality);
+
+            case Expression::ComparisonResult::kUnknown:
+                return nullptr;
         }
-        return nullptr;
     }
 
     // Handle floating-point arithmetic: + - * /
     const auto vectorComponentwiseFold = [&](auto foldFn) -> std::unique_ptr<Constructor> {
         ExpressionArray args;
         for (int i = 0; i < type.columns(); i++) {
             T value = foldFn(left.getVecComponent<T>(i), right.getVecComponent<T>(i));
             args.push_back(std::make_unique<Literal<T>>(fContext, left.fOffset, value));
         }
         return std::make_unique<Constructor>(left.fOffset, &type, std::move(args));
     };
 
     const auto isVectorDivisionByZero = [&]() -> bool {
         for (int i = 0; i < type.columns(); i++) {
             if (right.getVecComponent<T>(i) == 0) {
                 return true;
             }
         }
         return false;
     };
 
     switch (op) {
         case Token::Kind::TK_PLUS:  return vectorComponentwiseFold([](T a, T b) { return a + b; });
         case Token::Kind::TK_MINUS: return vectorComponentwiseFold([](T a, T b) { return a - b; });
         case Token::Kind::TK_STAR:  return vectorComponentwiseFold([](T a, T b) { return a * b; });
         case Token::Kind::TK_SLASH: {
             if (isVectorDivisionByZero()) {
                 fErrors.error(right.fOffset, "division by zero");
                 return nullptr;
             }
             return vectorComponentwiseFold([](T a, T b) { return a / b; });
         }
         default:
             return nullptr;
     }
 }
@@ -1836,137 +1844,150 @@ std::unique_ptr<Expression> IRGenerator::constantFoldVector(const Expression& le
 std::unique_ptr<Expression> IRGenerator::constantFold(const Expression& left,
                                                       Token::Kind op,
                                                       const Expression& right) const {
     // If the left side is a constant boolean literal, the right side does not need to be constant
     // for short circuit optimizations to allow the constant to be folded.
     if (left.is<BoolLiteral>() && !right.isCompileTimeConstant()) {
         return short_circuit_boolean(fContext, left, op, right);
     } else if (right.is<BoolLiteral>() && !left.isCompileTimeConstant()) {
         // There aren't side effects in SKSL within expressions, so (left OP right) is equivalent to
         // (right OP left) for short-circuit optimizations
         return short_circuit_boolean(fContext, right, op, left);
     }
 
     // Other than the short-circuit cases above, constant folding requires both sides to be constant
     if (!left.isCompileTimeConstant() || !right.isCompileTimeConstant()) {
         return nullptr;
     }
     // Note that we expressly do not worry about precision and overflow here -- we use the maximum
     // precision to calculate the results and hope the result makes sense. The plan is to move the
     // Skia caps into SkSL, so we have access to all of them including the precisions of the various
     // types, which will let us be more intelligent about this.
     if (left.is<BoolLiteral>() && right.is<BoolLiteral>()) {
         bool leftVal  = left.as<BoolLiteral>().value();
         bool rightVal = right.as<BoolLiteral>().value();
         bool result;
         switch (op) {
             case Token::Kind::TK_LOGICALAND: result = leftVal && rightVal; break;
             case Token::Kind::TK_LOGICALOR:  result = leftVal || rightVal; break;
             case Token::Kind::TK_LOGICALXOR: result = leftVal ^  rightVal; break;
             default: return nullptr;
         }
         return std::make_unique<BoolLiteral>(fContext, left.fOffset, result);
     }
     #define RESULT(t, op) std::make_unique<t ## Literal>(fContext, left.fOffset, \
                                                          leftVal op rightVal)
     #define URESULT(t, op) std::make_unique<t ## Literal>(fContext, left.fOffset, \
                                                           (uint32_t) leftVal op   \
                                                           (uint32_t) rightVal)
     if (left.is<IntLiteral>() && right.is<IntLiteral>()) {
         int64_t leftVal  = left.as<IntLiteral>().value();
         int64_t rightVal = right.as<IntLiteral>().value();
         switch (op) {
             case Token::Kind::TK_PLUS:       return URESULT(Int, +);
             case Token::Kind::TK_MINUS:      return URESULT(Int, -);
             case Token::Kind::TK_STAR:       return URESULT(Int, *);
             case Token::Kind::TK_SLASH:
                 if (leftVal == std::numeric_limits<int64_t>::min() && rightVal == -1) {
                     fErrors.error(right.fOffset, "arithmetic overflow");
                     return nullptr;
                 }
                 if (!rightVal) {
                     fErrors.error(right.fOffset, "division by zero");
                     return nullptr;
                 }
                 return RESULT(Int, /);
             case Token::Kind::TK_PERCENT:
                 if (leftVal == std::numeric_limits<int64_t>::min() && rightVal == -1) {
                     fErrors.error(right.fOffset, "arithmetic overflow");
                     return nullptr;
                 }
                 if (!rightVal) {
                     fErrors.error(right.fOffset, "division by zero");
                     return nullptr;
                 }
                 return RESULT(Int, %);
             case Token::Kind::TK_BITWISEAND: return RESULT(Int,  &);
             case Token::Kind::TK_BITWISEOR:  return RESULT(Int,  |);
             case Token::Kind::TK_BITWISEXOR: return RESULT(Int,  ^);
             case Token::Kind::TK_EQEQ:       return RESULT(Bool, ==);
             case Token::Kind::TK_NEQ:        return RESULT(Bool, !=);
             case Token::Kind::TK_GT:         return RESULT(Bool, >);
             case Token::Kind::TK_GTEQ:       return RESULT(Bool, >=);
             case Token::Kind::TK_LT:         return RESULT(Bool, <);
             case Token::Kind::TK_LTEQ:       return RESULT(Bool, <=);
             case Token::Kind::TK_SHL:
                 if (rightVal >= 0 && rightVal <= 31) {
                     return URESULT(Int,  <<);
                 }
                 fErrors.error(right.fOffset, "shift value out of range");
                 return nullptr;
             case Token::Kind::TK_SHR:
                 if (rightVal >= 0 && rightVal <= 31) {
                     return URESULT(Int,  >>);
                 }
                 fErrors.error(right.fOffset, "shift value out of range");
                 return nullptr;
 
             default:
                 return nullptr;
         }
     }
     if (left.is<FloatLiteral>() && right.is<FloatLiteral>()) {
         SKSL_FLOAT leftVal  = left.as<FloatLiteral>().value();
         SKSL_FLOAT rightVal = right.as<FloatLiteral>().value();
         switch (op) {
             case Token::Kind::TK_PLUS:  return RESULT(Float, +);
             case Token::Kind::TK_MINUS: return RESULT(Float, -);
             case Token::Kind::TK_STAR:  return RESULT(Float, *);
             case Token::Kind::TK_SLASH:
                 if (rightVal) {
                     return RESULT(Float, /);
                 }
                 fErrors.error(right.fOffset, "division by zero");
                 return nullptr;
             case Token::Kind::TK_EQEQ: return RESULT(Bool, ==);
             case Token::Kind::TK_NEQ:  return RESULT(Bool, !=);
             case Token::Kind::TK_GT:   return RESULT(Bool, >);
             case Token::Kind::TK_GTEQ: return RESULT(Bool, >=);
             case Token::Kind::TK_LT:   return RESULT(Bool, <);
             case Token::Kind::TK_LTEQ: return RESULT(Bool, <=);
             default:                   return nullptr;
         }
     }
     const Type& leftType = left.type();
     const Type& rightType = right.type();
     if (leftType.isVector() && leftType == rightType) {
         if (leftType.componentType().isFloat()) {
             return constantFoldVector<SKSL_FLOAT>(left, op, right);
         } else if (leftType.componentType().isInteger()) {
             return constantFoldVector<SKSL_INT>(left, op, right);
         }
     }
-    if (leftType.isMatrix() && rightType.isMatrix() && left.kind() == right.kind()) {
+    if (leftType.isMatrix() && rightType.isMatrix()) {
+        bool equality;
         switch (op) {
             case Token::Kind::TK_EQEQ:
-                return std::make_unique<BoolLiteral>(fContext, left.fOffset,
-                                                     left.compareConstant(fContext, right));
+                equality = true;
+                break;
             case Token::Kind::TK_NEQ:
-                return std::make_unique<BoolLiteral>(fContext, left.fOffset,
-                                                     !left.compareConstant(fContext, right));
+                equality = false;
+                break;
             default:
                 return nullptr;
         }
+
+        switch (left.compareConstant(fContext, right)) {
+            case Expression::ComparisonResult::kNotEqual:
+                equality = !equality;
+                [[fallthrough]];
+
+            case Expression::ComparisonResult::kEqual:
+                return std::make_unique<BoolLiteral>(fContext, left.fOffset, equality);
+
+            case Expression::ComparisonResult::kUnknown:
+                return nullptr;
+        }
     }
     #undef RESULT
     return nullptr;
 }
diff --git a/src/sksl/ir/SkSLBoolLiteral.h b/src/sksl/ir/SkSLBoolLiteral.h
index 939f4bee35..76f8adeadc 100644
--- a/src/sksl/ir/SkSLBoolLiteral.h
+++ b/src/sksl/ir/SkSLBoolLiteral.h
@@ -25,31 +25,35 @@ class Literal<bool> final : public Expression {
 public:
     static constexpr Kind kExpressionKind = Kind::kBoolLiteral;
 
     Literal(const Context& context, int offset, bool value)
         : INHERITED(offset, kExpressionKind, context.fBool_Type.get())
         , fValue(value) {}
 
     bool value() const {
         return fValue;
     }
 
     String description() const override {
         return String(this->value() ? "true" : "false");
     }
 
     bool hasProperty(Property property) const override {
         return false;
     }
 
     bool isCompileTimeConstant() const override {
         return true;
     }
 
-    bool compareConstant(const Context& context, const Expression& other) const override {
-        const BoolLiteral& b = other.as<BoolLiteral>();
-        return this->value() == b.value();
+    ComparisonResult compareConstant(const Context& context,
+                                     const Expression& other) const override {
+        if (!other.is<BoolLiteral>()) {
+            return ComparisonResult::kUnknown;
+        }
+        return this->value() == other.as<BoolLiteral>().value() ? ComparisonResult::kEqual
+                                                                : ComparisonResult::kNotEqual;
     }
 
     std::unique_ptr<Expression> clone() const override {
         return std::unique_ptr<BoolLiteral>(new BoolLiteral(fOffset, this->value(), &this->type()));
     }
diff --git a/src/sksl/ir/SkSLConstructor.cpp b/src/sksl/ir/SkSLConstructor.cpp
index 2dbc0fc32a..9a5e21996c 100644
--- a/src/sksl/ir/SkSLConstructor.cpp
+++ b/src/sksl/ir/SkSLConstructor.cpp
@@ -30,37 +30,41 @@ std::unique_ptr<Expression> Constructor::constantPropagate(const IRGenerator& ir
     return nullptr;
 }
 
-bool Constructor::compareConstant(const Context& context, const Expression& other) const {
+Expression::ComparisonResult Constructor::compareConstant(const Context& context,
+                                                          const Expression& other) const {
+    if (!other.is<Constructor>()) {
+        return ComparisonResult::kUnknown;
+    }
     const Constructor& c = other.as<Constructor>();
     const Type& myType = this->type();
     const Type& otherType = c.type();
     SkASSERT(myType == otherType);
     if (otherType.isVector()) {
         bool isFloat = otherType.columns() > 1 ? otherType.componentType().isFloat()
                                              : otherType.isFloat();
         for (int i = 0; i < myType.columns(); i++) {
             if (isFloat) {
                 if (this->getFVecComponent(i) != c.getFVecComponent(i)) {
-                    return false;
+                    return ComparisonResult::kNotEqual;
                 }
             } else if (this->getIVecComponent(i) != c.getIVecComponent(i)) {
-                return false;
+                return ComparisonResult::kNotEqual;
             }
         }
-        return true;
+        return ComparisonResult::kEqual;
     }
     // shouldn't be possible to have a constant constructor that isn't a vector or matrix;
     // a constant scalar constructor should have been collapsed down to the appropriate
     // literal
     SkASSERT(myType.isMatrix());
     for (int col = 0; col < myType.columns(); col++) {
         for (int row = 0; row < myType.rows(); row++) {
             if (getMatComponent(col, row) != c.getMatComponent(col, row)) {
-                return false;
+                return ComparisonResult::kNotEqual;
             }
         }
     }
-    return true;
+    return ComparisonResult::kEqual;
 }
 
 template <typename ResultType>
diff --git a/src/sksl/ir/SkSLConstructor.h b/src/sksl/ir/SkSLConstructor.h
index d062e28a06..27a4687216 100644
--- a/src/sksl/ir/SkSLConstructor.h
+++ b/src/sksl/ir/SkSLConstructor.h
@@ -30,98 +30,99 @@ class Constructor final : public Expression {
 public:
     static constexpr Kind kExpressionKind = Kind::kConstructor;
 
     Constructor(int offset, const Type* type, ExpressionArray arguments)
         : INHERITED(offset, kExpressionKind, type)
         , fArguments(std::move(arguments)) {}
 
     ExpressionArray& arguments() {
         return fArguments;
     }
 
     const ExpressionArray& arguments() const {
         return fArguments;
     }
 
     std::unique_ptr<Expression> constantPropagate(const IRGenerator& irGenerator,
                                                   const DefinitionMap& definitions) override;
 
     bool hasProperty(Property property) const override {
         for (const std::unique_ptr<Expression>& arg: this->arguments()) {
             if (arg->hasProperty(property)) {
                 return true;
             }
         }
         return false;
     }
 
     std::unique_ptr<Expression> clone() const override {
         ExpressionArray cloned;
         cloned.reserve_back(this->arguments().size());
         for (const std::unique_ptr<Expression>& arg: this->arguments()) {
             cloned.push_back(arg->clone());
         }
         return std::make_unique<Constructor>(fOffset, &this->type(), std::move(cloned));
     }
 
     String description() const override {
         String result = this->type().description() + "(";
         const char* separator = "";
         for (const std::unique_ptr<Expression>& arg: this->arguments()) {
             result += separator;
             result += arg->description();
             separator = ", ";
         }
         result += ")";
         return result;
     }
 
     const Type& componentType() const {
         // Returns `float` for constructors of type `float(...)` or `floatN(...)`.
         const Type& type = this->type();
         return type.columns() == 1 ? type : type.componentType();
     }
 
     bool isCompileTimeConstant() const override {
         for (const std::unique_ptr<Expression>& arg: this->arguments()) {
             if (!arg->isCompileTimeConstant()) {
                 return false;
             }
         }
         return true;
     }
 
     bool isConstantOrUniform() const override {
         for (const std::unique_ptr<Expression>& arg: this->arguments()) {
             if (!arg->isConstantOrUniform()) {
                 return false;
             }
         }
         return true;
     }
 
-    bool compareConstant(const Context& context, const Expression& other) const override;
+    ComparisonResult compareConstant(const Context& context,
+                                     const Expression& other) const override;
 
     template <typename resultType>
     resultType getVecComponent(int index) const;
 
     /**
      * For a literal vector expression, return the float value of the n'th vector component. It is
      * an error to call this method on an expression which is not a vector of FloatLiterals.
      */
     SKSL_FLOAT getFVecComponent(int n) const override {
         return this->getVecComponent<SKSL_FLOAT>(n);
     }
 
     /**
      * For a literal vector expression, return the integer value of the n'th vector component. It is
      * an error to call this method on an expression which is not a vector of IntLiterals.
      */
     SKSL_INT getIVecComponent(int n) const override {
         return this->getVecComponent<SKSL_INT>(n);
     }
 
     SKSL_FLOAT getMatComponent(int col, int row) const override;
 
     int64_t getConstantInt() const override;
 
     SKSL_FLOAT getConstantFloat() const override;
diff --git a/src/sksl/ir/SkSLExpression.h b/src/sksl/ir/SkSLExpression.h
index 15dbb8f159..72d81de47a 100644
--- a/src/sksl/ir/SkSLExpression.h
+++ b/src/sksl/ir/SkSLExpression.h
@@ -29,172 +29,178 @@ class Expression : public IRNode {
 public:
     enum class Kind {
         kBinary = (int) Statement::Kind::kLast + 1,
         kBoolLiteral,
         kConstructor,
         kDefined,
         kExternalFunctionCall,
         kExternalValue,
         kIntLiteral,
         kFieldAccess,
         kFloatLiteral,
         kFunctionReference,
         kFunctionCall,
         kIndex,
         kPrefix,
         kPostfix,
         kSetting,
         kSwizzle,
         kTernary,
         kTypeReference,
         kVariableReference,
 
         kFirst = kBinary,
         kLast = kVariableReference
     };
 
     enum class Property {
         kSideEffects,
         kContainsRTAdjust
     };
 
     Expression(int offset, Kind kind, const Type* type)
         : INHERITED(offset, (int) kind)
         , fType(type) {
         SkASSERT(kind >= Kind::kFirst && kind <= Kind::kLast);
     }
 
     Kind kind() const {
         return (Kind) fKind;
     }
 
     virtual const Type& type() const {
         return *fType;
     }
 
     /**
      *  Use is<T> to check the type of an expression.
      *  e.g. replace `e.kind() == Expression::Kind::kIntLiteral` with `e.is<IntLiteral>()`.
      */
     template <typename T>
     bool is() const {
         return this->kind() == T::kExpressionKind;
     }
 
     /**
      *  Use as<T> to downcast expressions: e.g. replace `(IntLiteral&) i` with `i.as<IntLiteral>()`.
      */
     template <typename T>
     const T& as() const {
         SkASSERT(this->is<T>());
         return static_cast<const T&>(*this);
     }
 
     template <typename T>
     T& as() {
         SkASSERT(this->is<T>());
         return static_cast<T&>(*this);
     }
 
     /**
      * Returns true if this expression is constant. compareConstant must be implemented for all
      * constants!
      */
     virtual bool isCompileTimeConstant() const {
         return false;
     }
 
     /**
-     * Compares this constant expression against another constant expression of the same kind. (i.e.
-     * both sides must be IntLiterals, or BoolLiterals, or Constructors, etc.) It is an error to
-     * call this on non-constant expressions, or if the kinds of the expressions do not match.
+     * Compares this constant expression against another constant expression. Returns kUnknown if
+     * we aren't able to deduce a result (an expression isn't actually constant, the types are
+     * mismatched, etc).
      */
-    virtual bool compareConstant(const Context& context, const Expression& other) const {
-        ABORT("cannot call compareConstant on this type");
+    enum class ComparisonResult {
+        kUnknown = -1,
+        kNotEqual,
+        kEqual
+    };
+    virtual ComparisonResult compareConstant(const Context& context,
+                                             const Expression& other) const {
+        return ComparisonResult::kUnknown;
     }
 
     /**
      * For an expression which evaluates to a constant int, returns the value. Otherwise calls
      * ABORT.
      */
     virtual int64_t getConstantInt() const {
         ABORT("not a constant int");
     }
 
     /**
      * For an expression which evaluates to a constant float, returns the value. Otherwise calls
      * ABORT.
      */
     virtual SKSL_FLOAT getConstantFloat() const {
         ABORT("not a constant float");
     }
 
     /**
      * Returns true if, given fixed values for uniforms, this expression always evaluates to the
      * same result with no side effects.
      */
     virtual bool isConstantOrUniform() const {
         SkASSERT(!this->isCompileTimeConstant() || !this->hasSideEffects());
         return this->isCompileTimeConstant();
     }
 
     virtual bool hasProperty(Property property) const = 0;
 
     bool hasSideEffects() const {
         return this->hasProperty(Property::kSideEffects);
     }
 
     bool containsRTAdjust() const {
         return this->hasProperty(Property::kContainsRTAdjust);
     }
 
     /**
      * Given a map of known constant variable values, substitute them in for references to those
      * variables occurring in this expression and its subexpressions.  Similar simplifications, such
      * as folding a constant binary expression down to a single value, may also be performed.
      * Returns a new expression which replaces this expression, or null if no replacements were
      * made. If a new expression is returned, this expression is no longer valid.
      */
     virtual std::unique_ptr<Expression> constantPropagate(const IRGenerator& irGenerator,
                                                           const DefinitionMap& definitions) {
         return nullptr;
     }
 
     virtual CoercionCost coercionCost(const Type& target) const {
         return this->type().coercionCost(target);
     }
 
     /**
      * For a vector of floating point values, return the value of the n'th vector component. It is
      * an error to call this method on an expression which is not a vector of FloatLiterals.
      */
     virtual SKSL_FLOAT getFVecComponent(int n) const {
         SkASSERT(false);
         return 0;
     }
 
     /**
      * For a vector of integer values, return the value of the n'th vector component. It is an error
      * to call this method on an expression which is not a vector of IntLiterals.
      */
     virtual SKSL_INT getIVecComponent(int n) const {
         SkASSERT(false);
         return 0;
     }
 
     /**
      * For a vector of literals, return the value of the n'th vector component. It is an error to
      * call this method on an expression which is not a vector of Literal<T>.
      */
     template <typename T> T getVecComponent(int index) const;
 
     /**
      * For a literal matrix expression, return the floating point value of the component at
      * [col][row]. It is an error to call this method on an expression which is not a literal
      * matrix.
      */
     virtual SKSL_FLOAT getMatComponent(int col, int row) const {
         SkASSERT(false);
         return 0;
     }
 
     virtual std::unique_ptr<Expression> clone() const = 0;
diff --git a/src/sksl/ir/SkSLFloatLiteral.h b/src/sksl/ir/SkSLFloatLiteral.h
index 2957853eed..6cecb675e6 100644
--- a/src/sksl/ir/SkSLFloatLiteral.h
+++ b/src/sksl/ir/SkSLFloatLiteral.h
@@ -25,45 +25,50 @@ class Literal<SKSL_FLOAT> final : public Expression {
 public:
     static constexpr Kind kExpressionKind = Kind::kFloatLiteral;
 
     Literal(const Context& context, int offset, float value)
         : INHERITED(offset, kExpressionKind, context.fFloatLiteral_Type.get())
         , fValue(value) {}
 
     Literal(int offset, float value, const Type* type)
         : INHERITED(offset, kExpressionKind, type)
         , fValue(value) {}
 
     float value() const {
         return fValue;
     }
 
     String description() const override {
         return to_string(this->value());
     }
 
     bool hasProperty(Property property) const override {
         return false;
     }
 
     bool isCompileTimeConstant() const override {
         return true;
     }
 
     CoercionCost coercionCost(const Type& target) const override {
         if (target.isFloat()) {
             return CoercionCost::Free();
         }
         return INHERITED::coercionCost(target);
     }
 
-    bool compareConstant(const Context& context, const Expression& other) const override {
-        return this->value() == other.as<FloatLiteral>().value();
+    ComparisonResult compareConstant(const Context& context,
+                                     const Expression& other) const override {
+        if (!other.is<FloatLiteral>()) {
+            return ComparisonResult::kUnknown;
+        }
+        return this->value() == other.as<FloatLiteral>().value() ? ComparisonResult::kEqual
+                                                                 : ComparisonResult::kNotEqual;
     }
 
     SKSL_FLOAT getConstantFloat() const override {
         return this->value();
     }
 
     std::unique_ptr<Expression> clone() const override {
         return std::make_unique<FloatLiteral>(fOffset, this->value(), &this->type());
     }
diff --git a/src/sksl/ir/SkSLIntLiteral.h b/src/sksl/ir/SkSLIntLiteral.h
index c5523aeb94..b7863ffd9a 100644
--- a/src/sksl/ir/SkSLIntLiteral.h
+++ b/src/sksl/ir/SkSLIntLiteral.h
@@ -25,48 +25,53 @@ class Literal<SKSL_INT> final : public Expression {
 public:
     static constexpr Kind kExpressionKind = Kind::kIntLiteral;
 
     // FIXME: we will need to revisit this if/when we add full support for both signed and unsigned
     // 64-bit integers, but for right now an int64_t will hold every value we care about
     Literal(const Context& context, int offset, int64_t value)
         : INHERITED(offset, kExpressionKind, context.fInt_Type.get())
         , fValue(value) {}
 
     Literal(int offset, int64_t value, const Type* type)
         : INHERITED(offset, kExpressionKind, type)
         , fValue(value) {}
 
     int64_t value() const {
         return fValue;
     }
 
     String description() const override {
         return to_string(this->value());
     }
 
     bool hasProperty(Property property) const override {
         return false;
     }
 
     bool isCompileTimeConstant() const override {
         return true;
     }
 
-    bool compareConstant(const Context& context, const Expression& other) const override {
-        return this->value() == other.as<IntLiteral>().value();
+    ComparisonResult compareConstant(const Context& context,
+                                     const Expression& other) const override {
+        if (!other.is<IntLiteral>()) {
+            return ComparisonResult::kUnknown;
+        }
+        return this->value() == other.as<IntLiteral>().value() ? ComparisonResult::kEqual
+                                                               : ComparisonResult::kNotEqual;
     }
 
     CoercionCost coercionCost(const Type& target) const override {
         if (target.isSigned() || target.isUnsigned() || target.isFloat() ||
             target.typeKind() == Type::TypeKind::kEnum) {
             return CoercionCost::Free();
         }
         return INHERITED::coercionCost(target);
     }
 
     int64_t getConstantInt() const override {
         return this->value();
     }
 
     std::unique_ptr<Expression> clone() const override {
         return std::make_unique<IntLiteral>(fOffset, this->value(), &this->type());
     }
diff --git a/src/sksl/ir/SkSLPrefixExpression.h b/src/sksl/ir/SkSLPrefixExpression.h
index 119a21b5d2..362de089de 100644
--- a/src/sksl/ir/SkSLPrefixExpression.h
+++ b/src/sksl/ir/SkSLPrefixExpression.h
@@ -23,85 +23,88 @@ class PrefixExpression final : public Expression {
 public:
     static constexpr Kind kExpressionKind = Kind::kPrefix;
 
     PrefixExpression(Token::Kind op, std::unique_ptr<Expression> operand)
         : INHERITED(operand->fOffset, kExpressionKind, &operand->type())
         , fOperator(op)
         , fOperand(std::move(operand)) {}
 
     Token::Kind getOperator() const {
         return fOperator;
     }
 
     std::unique_ptr<Expression>& operand() {
         return fOperand;
     }
 
     const std::unique_ptr<Expression>& operand() const {
         return fOperand;
     }
 
     bool isNegationOfCompileTimeConstant() const {
         return this->getOperator() == Token::Kind::TK_MINUS &&
                this->operand()->isCompileTimeConstant();
     }
 
     bool isCompileTimeConstant() const override {
         return this->isNegationOfCompileTimeConstant();
     }
 
     bool hasProperty(Property property) const override {
         if (property == Property::kSideEffects &&
             (this->getOperator() == Token::Kind::TK_PLUSPLUS ||
              this->getOperator() == Token::Kind::TK_MINUSMINUS)) {
             return true;
         }
         return this->operand()->hasProperty(property);
     }
 
     std::unique_ptr<Expression> constantPropagate(const IRGenerator& irGenerator,
                                                   const DefinitionMap& definitions) override;
 
     SKSL_FLOAT getFVecComponent(int index) const override {
         SkASSERT(this->getOperator() == Token::Kind::TK_MINUS);
         return -this->operand()->getFVecComponent(index);
     }
 
     SKSL_INT getIVecComponent(int index) const override {
         SkASSERT(this->getOperator() == Token::Kind::TK_MINUS);
         return -this->operand()->getIVecComponent(index);
     }
 
     SKSL_FLOAT getMatComponent(int col, int row) const override {
         SkASSERT(this->getOperator() == Token::Kind::TK_MINUS);
         return -this->operand()->getMatComponent(col, row);
     }
 
     std::unique_ptr<Expression> clone() const override {
         return std::unique_ptr<Expression>(new PrefixExpression(this->getOperator(),
                                                                 this->operand()->clone()));
     }
 
     String description() const override {
         return Compiler::OperatorName(this->getOperator()) + this->operand()->description();
     }
 
     int64_t getConstantInt() const override {
         SkASSERT(this->isNegationOfCompileTimeConstant());
         return -this->operand()->getConstantInt();
     }
 
     SKSL_FLOAT getConstantFloat() const override {
         SkASSERT(this->isNegationOfCompileTimeConstant());
         return -this->operand()->getConstantFloat();
     }
 
-    bool compareConstant(const Context& context, const Expression& other) const override {
-        // This expression and the other expression must be of the same kind. Since the only
-        // compile-time PrefixExpression we optimize for is negation, that means we're comparing
-        // -X == -Y. The negatives should cancel out, so we can just constant-compare the inner
-        // expressions.
+    ComparisonResult compareConstant(const Context& context,
+                                     const Expression& other) const override {
+        if (!other.is<PrefixExpression>()) {
+            return ComparisonResult::kUnknown;
+        }
+        // The only compile-time PrefixExpression we optimize for is negation, so we're comparing
+        // `-X == -Y`.
         SkASSERT(this->isNegationOfCompileTimeConstant());
         SkASSERT(other.as<PrefixExpression>().isNegationOfCompileTimeConstant());
+        // The negatives cancel out; constant-compare the inner expressions.
         return this->operand()->compareConstant(context, *other.as<PrefixExpression>().operand());
     }
 
diff --git a/tests/sksl/shared/Ossfuzz28904.sksl b/tests/sksl/shared/Ossfuzz28904.sksl
new file mode 100644
index 0000000000..8c5969d483
--- /dev/null
+++ b/tests/sksl/shared/Ossfuzz28904.sksl
@@ -0,0 +1,2 @@
+void n()    { -2 .L1==- -2 .L1; }
+void main() { n(); sk_FragColor = half4(0); }
diff --git a/tests/sksl/shared/golden/Ossfuzz28904.asm.frag b/tests/sksl/shared/golden/Ossfuzz28904.asm.frag
new file mode 100644
index 0000000000..c8352c68c7
--- /dev/null
+++ b/tests/sksl/shared/golden/Ossfuzz28904.asm.frag
@@ -0,0 +1,29 @@
+OpCapability Shader
+%1 = OpExtInstImport "GLSL.std.450"
+OpMemoryModel Logical GLSL450
+OpEntryPoint Fragment %main "main" %sk_FragColor %sk_Clockwise
+OpExecutionMode %main OriginUpperLeft
+OpName %sk_FragColor "sk_FragColor"
+OpName %sk_Clockwise "sk_Clockwise"
+OpName %main "main"
+OpDecorate %sk_FragColor RelaxedPrecision
+OpDecorate %sk_FragColor Location 0
+OpDecorate %sk_FragColor Index 0
+OpDecorate %sk_Clockwise RelaxedPrecision
+OpDecorate %sk_Clockwise BuiltIn FrontFacing
+%float = OpTypeFloat 32
+%v4float = OpTypeVector %float 4
+%_ptr_Output_v4float = OpTypePointer Output %v4float
+%sk_FragColor = OpVariable %_ptr_Output_v4float Output
+%bool = OpTypeBool
+%_ptr_Input_bool = OpTypePointer Input %bool
+%sk_Clockwise = OpVariable %_ptr_Input_bool Input
+%void = OpTypeVoid
+%11 = OpTypeFunction %void
+%float_0 = OpConstant %float 0
+%13 = OpConstantComposite %v4float %float_0 %float_0 %float_0 %float_0
+%main = OpFunction %void None %11
+%12 = OpLabel
+OpStore %sk_FragColor %13
+OpReturn
+OpFunctionEnd
diff --git a/tests/sksl/shared/golden/Ossfuzz28904.glsl b/tests/sksl/shared/golden/Ossfuzz28904.glsl
new file mode 100644
index 0000000000..604f63cb78
--- /dev/null
+++ b/tests/sksl/shared/golden/Ossfuzz28904.glsl
@@ -0,0 +1,5 @@
+
+out vec4 sk_FragColor;
+void main() {
+    sk_FragColor = vec4(0.0);
+}
diff --git a/tests/sksl/shared/golden/Ossfuzz28904.metal b/tests/sksl/shared/golden/Ossfuzz28904.metal
new file mode 100644
index 0000000000..51c66d94d1
--- /dev/null
+++ b/tests/sksl/shared/golden/Ossfuzz28904.metal
@@ -0,0 +1,14 @@
+#include <metal_stdlib>
+#include <simd/simd.h>
+using namespace metal;
+struct Inputs {
+};
+struct Outputs {
+    float4 sk_FragColor [[color(0)]];
+};
+fragment Outputs fragmentMain(Inputs _in [[stage_in]], bool _frontFacing [[front_facing]], float4 _fragCoord [[position]]) {
+    Outputs _outputStruct;
+    thread Outputs* _out = &_outputStruct;
+    _out->sk_FragColor = float4(0.0);
+    return *_out;
+}
