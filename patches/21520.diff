commit f59c3864fe692c0191b40712e1b7a6a05a126c44
Merge: 66aae99 3fe5adf
Author: Xin Li <delphij@google.com>
Date:   Mon Nov 23 13:14:11 2020 -0800

    Merge rvc-qpr-dev-plus-aosp-without-vendor@6881855
    
    Bug: 172690556
    Merged-In: I829eb4215ea9aa15adf66e8bbdb37ec88a9bb6a4
    Change-Id: I2e739d3606ba9f0938ebc2363cb9443ec3dec912

diff --git a/decoder/ih264d_bitstrm.h b/decoder/ih264d_bitstrm.h
index 49cd5e7..8bb06fb 100644
--- a/decoder/ih264d_bitstrm.h
+++ b/decoder/ih264d_bitstrm.h
@@ -55,10 +55,10 @@
 /* Structure for the ps_bitstrm */
 typedef struct
 {
     UWORD32 u4_ofst; /* Offset in the buffer for the current bit */
     UWORD32 *pu4_buffer; /* Bitstream Buffer  */
-    UWORD32 u4_max_ofst; /* Position of the last bit read in the current buffer */
+    UWORD32 u4_max_ofst; /* points to first bit beyond the buffer */
     void * pv_codec_handle; /* For Error Handling */
 } dec_bit_stream_t;
 
 /* To read the next bit */
@@ -73,25 +73,28 @@ UWORD32 ih264d_next_bits_h264(dec_bit_stream_t *, UWORD32);
 /* To flush a specified number of bits*/
 WORD32 ih264d_flush_bits_h264(dec_bit_stream_t *, WORD32);
 
 /*!
  **************************************************************************
  * \if Function name : MoreRbspData \endif
  *
  * \brief
  *    Determines whether there is more data in RBSP or not.
  *
  * \param ps_bitstrm : Pointer to bitstream
  *
  * \return
  *    Returns 1 if there is more data in RBSP before rbsp_trailing_bits().
  *    Otherwise it returns FALSE.
  **************************************************************************
  */
 
-#define MORE_RBSP_DATA(ps_bitstrm) \
-  (ps_bitstrm->u4_ofst < ps_bitstrm->u4_max_ofst)
+
 #define EXCEED_OFFSET(ps_bitstrm) \
   (ps_bitstrm->u4_ofst > ps_bitstrm->u4_max_ofst)
+#define CHECK_BITS_SUFFICIENT(ps_bitstrm, bits_to_read) \
+  (ps_bitstrm->u4_ofst + bits_to_read <= ps_bitstrm->u4_max_ofst)
+#define MORE_RBSP_DATA(ps_bitstrm) \
+    CHECK_BITS_SUFFICIENT(ps_bitstrm, 1)
 
 void GoToByteBoundary(dec_bit_stream_t * ps_bitstrm);
 UWORD8 ih264d_check_byte_aligned(dec_bit_stream_t * ps_bitstrm);
diff --git a/decoder/ih264d_cabac.c b/decoder/ih264d_cabac.c
index 38028ae..ef1fafc 100644
--- a/decoder/ih264d_cabac.c
+++ b/decoder/ih264d_cabac.c
@@ -49,48 +49,48 @@
 /*!
  **************************************************************************
  * \if Function name : ih264d_init_cabac_dec_envirnoment \endif
  *
  * \brief
  *    This function initializes CABAC decoding envirnoment. This function
  *    implements 9.3.3.2.3.1 of ISO/IEC14496-10.
  *
  * \return
  *    None
  *
  **************************************************************************
  */
 WORD32 ih264d_init_cabac_dec_envirnoment(decoding_envirnoment_t * ps_cab_env,
                                        dec_bit_stream_t *ps_bitstrm)
 {
     UWORD32 u4_code_int_val_ofst;
 
     ps_cab_env->u4_code_int_range = (HALF - 2) << 23;
     NEXTBITS(u4_code_int_val_ofst, ps_bitstrm->u4_ofst, ps_bitstrm->pu4_buffer,
              32);
     FLUSHBITS(ps_bitstrm->u4_ofst, 9)
 
-    if(ps_bitstrm->u4_ofst > ps_bitstrm->u4_max_ofst)
+    if(EXCEED_OFFSET(ps_bitstrm))
         return ERROR_EOB_FLUSHBITS_T;
 
     ps_cab_env->u4_code_int_val_ofst = u4_code_int_val_ofst;
 
     /*brief description of the design adopted for CABAC*/
     /*according to the standard the u4_code_int_range needs to be initialized 0x 1FE(10 bits) and
      9 bits from the bit stream need to be read and into the u4_code_int_val_ofst.As and when the
      u4_code_int_range becomes less than 10 bits we need to renormalize and read from the bitstream*
 
      In the implemented design
      initially
 
      range_new = range <<23
      valOffset_new = valOffset << 23 + 23 bits(read from the bit stream)
 
      Thus we have read 23 more bits ahead of time.
 
      It can be mathematical proved that even with the modified range and u4_ofst the operations
      like comparison and subtraction needed for a bin decode are still valid(both in the regular case and the bypass case)
 
      As bins are decoded..we consume the bits that we have already read into the valOffset.The clz of Range
      gives us the number of bits we consumed of the 23 bits that we have read ahead of time.
 
      when the number bits we have consumed exceeds 23 ,we renormalize..and  we read from the bitstream again*/
diff --git a/decoder/ih264d_parse_headers.c b/decoder/ih264d_parse_headers.c
index d0f375d..8f0cb40 100644
--- a/decoder/ih264d_parse_headers.c
+++ b/decoder/ih264d_parse_headers.c
@@ -259,228 +259,228 @@ void ih264d_parse_end_of_stream(dec_struct_t * ps_dec)
 /*!
  **************************************************************************
  * \if Function name : ih264d_parse_pps \endif
  *
  * \brief
  *    Decodes Picture Parameter set
  *
  * \return
  *    0 on Success and Error code otherwise
  **************************************************************************
  */
 WORD32 ih264d_parse_pps(dec_struct_t * ps_dec, dec_bit_stream_t * ps_bitstrm)
 {
     UWORD8 uc_temp;
     dec_seq_params_t * ps_sps = NULL;
     dec_pic_params_t * ps_pps = NULL;
     UWORD32 *pu4_bitstrm_buf = ps_dec->ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_dec->ps_bitstrm->u4_ofst;
 
     /* Variables used for error resilience checks */
     UWORD64 u8_temp;
     UWORD32 u4_temp;
     WORD32 i_temp;
 
     /* For High profile related syntax elements */
     UWORD8 u1_more_data_flag;
     WORD32 i4_i;
 
     if(!(ps_dec->i4_header_decoded & 1))
         return ERROR_INV_SPS_PPS_T;
 
     /*--------------------------------------------------------------------*/
     /* Decode pic_parameter_set_id and find corresponding pic params      */
     /*--------------------------------------------------------------------*/
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u4_temp & MASK_ERR_PIC_SET_ID)
         return ERROR_INV_SPS_PPS_T;
     ps_pps = ps_dec->pv_scratch_sps_pps;
     *ps_pps = ps_dec->ps_pps[u4_temp];
     ps_pps->u1_pic_parameter_set_id = (WORD8)u4_temp;
     COPYTHECONTEXT("PPS: pic_parameter_set_id",ps_pps->u1_pic_parameter_set_id);
 
     /************************************************/
     /* initilization of High profile syntax element */
     /************************************************/
     ps_pps->i4_transform_8x8_mode_flag = 0;
     ps_pps->i4_pic_scaling_matrix_present_flag = 0;
 
     /*--------------------------------------------------------------------*/
     /* Decode seq_parameter_set_id and map it to a seq_parameter_set      */
     /*--------------------------------------------------------------------*/
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u4_temp & MASK_ERR_SEQ_SET_ID)
         return ERROR_INV_SPS_PPS_T;
     COPYTHECONTEXT("PPS: seq_parameter_set_id",u4_temp);
     ps_sps = &ps_dec->ps_sps[u4_temp];
 
     if(FALSE == ps_sps->u1_is_valid)
         return ERROR_INV_SPS_PPS_T;
     ps_pps->ps_sps = ps_sps;
 
     /*--------------------------------------------------------------------*/
     /* Decode entropy_coding_mode                                         */
     /*--------------------------------------------------------------------*/
     ps_pps->u1_entropy_coding_mode = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("PPS: entropy_coding_mode_flag",ps_pps->u1_entropy_coding_mode);
 
     ps_pps->u1_pic_order_present_flag = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("PPS: pic_order_present_flag",ps_pps->u1_pic_order_present_flag);
 
     /*--------------------------------------------------------------------*/
     /* Decode num_slice_groups_minus1                                     */
     /*--------------------------------------------------------------------*/
     u8_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf) + (UWORD64)1;
     if(u8_temp != 1)
     {
         return ERROR_FEATURE_UNAVAIL;
     }
     ps_pps->u1_num_slice_groups = u8_temp;
     COPYTHECONTEXT("PPS: num_slice_groups_minus1",ps_pps->u1_num_slice_groups -1);
 
     /*--------------------------------------------------------------------*/
     /* Other parameter set values                                         */
     /*--------------------------------------------------------------------*/
     u8_temp = (UWORD64)1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u8_temp > H264_MAX_REF_IDX)
         return ERROR_REF_IDX;
     ps_pps->u1_num_ref_idx_lx_active[0] = u8_temp;
     COPYTHECONTEXT("PPS: num_ref_idx_l0_active_minus1",
                     ps_pps->u1_num_ref_idx_lx_active[0] - 1);
 
     u8_temp = (UWORD64)1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u8_temp > H264_MAX_REF_IDX)
         return ERROR_REF_IDX;
     ps_pps->u1_num_ref_idx_lx_active[1] = u8_temp;
     COPYTHECONTEXT("PPS: num_ref_idx_l1_active_minus1",
                     ps_pps->u1_num_ref_idx_lx_active[1] - 1);
 
     ps_pps->u1_wted_pred_flag = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("PPS: weighted prediction u4_flag",ps_pps->u1_wted_pred_flag);
     uc_temp = ih264d_get_bits_h264(ps_bitstrm, 2);
     COPYTHECONTEXT("PPS: weighted_bipred_idc",uc_temp);
     ps_pps->u1_wted_bipred_idc = uc_temp;
 
     if(ps_pps->u1_wted_bipred_idc > MAX_WEIGHT_BIPRED_IDC)
         return ERROR_INV_SPS_PPS_T;
 
     WORD64 i8_temp = (WORD64)26
                         + ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
     if((i8_temp < MIN_H264_QP) || (i8_temp > MAX_H264_QP))
         return ERROR_INV_RANGE_QP_T;
 
     ps_pps->u1_pic_init_qp = i8_temp;
     COPYTHECONTEXT("PPS: pic_init_qp_minus26",ps_pps->u1_pic_init_qp - 26);
 
     i8_temp = (WORD64)26 + ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
     if((i8_temp < MIN_H264_QP) || (i8_temp > MAX_H264_QP))
         return ERROR_INV_RANGE_QP_T;
 
     ps_pps->u1_pic_init_qs = i8_temp;
     COPYTHECONTEXT("PPS: pic_init_qs_minus26",ps_pps->u1_pic_init_qs - 26);
 
     i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if((i_temp < -12) || (i_temp > 12))
         return ERROR_INV_RANGE_QP_T;
     ps_pps->i1_chroma_qp_index_offset = i_temp;
     COPYTHECONTEXT("PPS: chroma_qp_index_offset",ps_pps->i1_chroma_qp_index_offset);
 
     /***************************************************************************/
     /* initialize second_chroma_qp_index_offset to i1_chroma_qp_index_offset if */
     /* second_chroma_qp_index_offset is not present in bit-ps_bitstrm              */
     /***************************************************************************/
     ps_pps->i1_second_chroma_qp_index_offset =
                     ps_pps->i1_chroma_qp_index_offset;
 
     ps_pps->u1_deblocking_filter_parameters_present_flag = ih264d_get_bit_h264(
                     ps_bitstrm);
     COPYTHECONTEXT("PPS: deblocking_filter_control_present_flag",
                     ps_pps->u1_deblocking_filter_parameters_present_flag);
     ps_pps->u1_constrained_intra_pred_flag = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("PPS: constrained_intra_pred_flag",
                     ps_pps->u1_constrained_intra_pred_flag);
     ps_pps->u1_redundant_pic_cnt_present_flag = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("PPS: redundant_pic_cnt_present_flag",
                     ps_pps->u1_redundant_pic_cnt_present_flag);
 
     /* High profile related syntax elements */
     u1_more_data_flag = MORE_RBSP_DATA(ps_bitstrm);
     if(u1_more_data_flag && (ps_pps->ps_sps->u1_profile_idc == HIGH_PROFILE_IDC))
     {
         /* read transform_8x8_mode_flag  */
         ps_pps->i4_transform_8x8_mode_flag = (WORD32)ih264d_get_bit_h264(
                         ps_bitstrm);
 
         /* read pic_scaling_matrix_present_flag */
         ps_pps->i4_pic_scaling_matrix_present_flag =
                         (WORD32)ih264d_get_bit_h264(ps_bitstrm);
 
         if(ps_pps->i4_pic_scaling_matrix_present_flag)
         {
             /* read the scaling matrices */
             for(i4_i = 0; i4_i < (6 + (ps_pps->i4_transform_8x8_mode_flag << 1)); i4_i++)
             {
                 ps_pps->u1_pic_scaling_list_present_flag[i4_i] =
                                 ih264d_get_bit_h264(ps_bitstrm);
 
                 if(ps_pps->u1_pic_scaling_list_present_flag[i4_i])
                 {
                     WORD32 ret;
                     if(i4_i < 6)
                     {
                         ret = ih264d_scaling_list(
                                         ps_pps->i2_pic_scalinglist4x4[i4_i],
                                         16,
                                         &ps_pps->u1_pic_use_default_scaling_matrix_flag[i4_i],
                                         ps_bitstrm);
                     }
                     else
                     {
                         ret = ih264d_scaling_list(
                                         ps_pps->i2_pic_scalinglist8x8[i4_i - 6],
                                         64,
                                         &ps_pps->u1_pic_use_default_scaling_matrix_flag[i4_i],
                                         ps_bitstrm);
                     }
 
                     if(ret != OK)
                     {
                         return ret;
                     }
                 }
             }
         }
 
         /* read second_chroma_qp_index_offset syntax element */
         i_temp = ih264d_sev(
                         pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
         if((i_temp < -12) || (i_temp > 12))
             return ERROR_INV_RANGE_QP_T;
 
         ps_pps->i1_second_chroma_qp_index_offset = i_temp;
     }
 
     /* In case bitstream read has exceeded the filled size, then
        return an error */
-    if(ps_bitstrm->u4_ofst > ps_bitstrm->u4_max_ofst + 8)
+    if(EXCEED_OFFSET(ps_bitstrm))
     {
         return ERROR_INV_SPS_PPS_T;
     }
     ps_pps->u1_is_valid = TRUE;
     ps_dec->ps_pps[ps_pps->u1_pic_parameter_set_id] = *ps_pps;
     return OK;
 }
 
 /*!
  **************************************************************************
  * \if Function name : ih264d_parse_sps \endif
  *
  * \brief
  *    Decodes Sequence parameter set from the bitstream
  *
  * \return
  *    0 on Success and Error code otherwise
  **************************************************************************
  */
@@ -569,598 +569,598 @@ UWORD32 ih264d_correct_level_idc(UWORD32 u4_level_idc, UWORD32 u4_total_mbs)
 }
 WORD32 ih264d_parse_sps(dec_struct_t *ps_dec, dec_bit_stream_t *ps_bitstrm)
 {
     UWORD8 i;
     dec_seq_params_t *ps_seq = NULL;
     UWORD8 u1_profile_idc, u1_level_idc, u1_seq_parameter_set_id, u1_mb_aff_flag = 0;
     UWORD16 i2_max_frm_num;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
     UWORD8 u1_frm, uc_constraint_set0_flag, uc_constraint_set1_flag;
     WORD32 i4_cropped_ht, i4_cropped_wd;
     UWORD32 u4_temp;
     UWORD64 u8_temp;
     UWORD32 u4_pic_height_in_map_units, u4_pic_width_in_mbs;
     UWORD32 u2_pic_wd = 0;
     UWORD32 u2_pic_ht = 0;
     UWORD32 u2_frm_wd_y = 0;
     UWORD32 u2_frm_ht_y = 0;
     UWORD32 u2_frm_wd_uv = 0;
     UWORD32 u2_frm_ht_uv = 0;
     UWORD32 u2_crop_offset_y = 0;
     UWORD32 u2_crop_offset_uv = 0;
     WORD32 ret;
     WORD32 num_reorder_frames;
     /* High profile related syntax element */
     WORD32 i4_i;
     /* G050 */
     UWORD8 u1_frame_cropping_flag, u1_frame_cropping_rect_left_ofst,
                     u1_frame_cropping_rect_right_ofst,
                     u1_frame_cropping_rect_top_ofst,
                     u1_frame_cropping_rect_bottom_ofst;
     /* G050 */
     /*--------------------------------------------------------------------*/
     /* Decode seq_parameter_set_id and profile and level values           */
     /*--------------------------------------------------------------------*/
     SWITCHONTRACE;
     u1_profile_idc = ih264d_get_bits_h264(ps_bitstrm, 8);
     COPYTHECONTEXT("SPS: profile_idc",u1_profile_idc);
 
     /* G050 */
     uc_constraint_set0_flag = ih264d_get_bit_h264(ps_bitstrm);
     uc_constraint_set1_flag = ih264d_get_bit_h264(ps_bitstrm);
     ih264d_get_bit_h264(ps_bitstrm);
 
     /*****************************************************/
     /* Read 5 bits for uc_constraint_set3_flag (1 bit)   */
     /* and reserved_zero_4bits (4 bits) - Sushant        */
     /*****************************************************/
     ih264d_get_bits_h264(ps_bitstrm, 5);
     /* G050 */
 
     /* Check whether particular profile is suported or not */
     /* Check whether particular profile is suported or not */
     if((u1_profile_idc != MAIN_PROFILE_IDC) &&
 
     (u1_profile_idc != BASE_PROFILE_IDC) &&
 
     (u1_profile_idc != HIGH_PROFILE_IDC)
 
     )
     {
 
         /* Apart from Baseline, main and high profile,
          * only extended profile is supported provided
          * uc_constraint_set0_flag or uc_constraint_set1_flag are set to 1
          */
         if((u1_profile_idc != EXTENDED_PROFILE_IDC) ||
            ((uc_constraint_set1_flag != 1) && (uc_constraint_set0_flag != 1)))
         {
             return (ERROR_FEATURE_UNAVAIL);
         }
     }
 
     u1_level_idc = ih264d_get_bits_h264(ps_bitstrm, 8);
 
 
 
     COPYTHECONTEXT("SPS: u4_level_idc",u1_level_idc);
 
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u4_temp & MASK_ERR_SEQ_SET_ID)
         return ERROR_INV_SPS_PPS_T;
     u1_seq_parameter_set_id = u4_temp;
     COPYTHECONTEXT("SPS: seq_parameter_set_id",
                     u1_seq_parameter_set_id);
 
     /*--------------------------------------------------------------------*/
     /* Find an seq param entry in seqparam array of decStruct             */
     /*--------------------------------------------------------------------*/
 
     ps_seq = ps_dec->pv_scratch_sps_pps;
     memset(ps_seq, 0, sizeof(dec_seq_params_t));
 
     if(ps_dec->i4_header_decoded & 1)
     {
         *ps_seq = *ps_dec->ps_cur_sps;
     }
 
 
     if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_profile_idc != u1_profile_idc))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
 
     if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_level_idc != u1_level_idc))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
 
     ps_seq->u1_profile_idc = u1_profile_idc;
     ps_seq->u1_level_idc = u1_level_idc;
     ps_seq->u1_seq_parameter_set_id = u1_seq_parameter_set_id;
 
     /*******************************************************************/
     /* Initializations for high profile - Sushant                      */
     /*******************************************************************/
     ps_seq->i4_chroma_format_idc = 1;
     ps_seq->i4_bit_depth_luma_minus8 = 0;
     ps_seq->i4_bit_depth_chroma_minus8 = 0;
     ps_seq->i4_qpprime_y_zero_transform_bypass_flag = 0;
     ps_seq->i4_seq_scaling_matrix_present_flag = 0;
     if(u1_profile_idc == HIGH_PROFILE_IDC)
     {
 
         /* reading chroma_format_idc   */
         ps_seq->i4_chroma_format_idc = ih264d_uev(pu4_bitstrm_ofst,
                                                   pu4_bitstrm_buf);
 
         /* Monochrome is not supported */
         if(ps_seq->i4_chroma_format_idc != 1)
         {
             return ERROR_FEATURE_UNAVAIL;
         }
 
         /* reading bit_depth_luma_minus8   */
         ps_seq->i4_bit_depth_luma_minus8 = ih264d_uev(pu4_bitstrm_ofst,
                                                       pu4_bitstrm_buf);
 
         if(ps_seq->i4_bit_depth_luma_minus8 != 0)
         {
             return ERROR_FEATURE_UNAVAIL;
         }
 
         /* reading bit_depth_chroma_minus8   */
         ps_seq->i4_bit_depth_chroma_minus8 = ih264d_uev(pu4_bitstrm_ofst,
                                                         pu4_bitstrm_buf);
 
         if(ps_seq->i4_bit_depth_chroma_minus8 != 0)
         {
             return ERROR_FEATURE_UNAVAIL;
         }
 
         /* reading qpprime_y_zero_transform_bypass_flag   */
         ps_seq->i4_qpprime_y_zero_transform_bypass_flag =
                         (WORD32)ih264d_get_bit_h264(ps_bitstrm);
 
         if(ps_seq->i4_qpprime_y_zero_transform_bypass_flag != 0)
         {
             return ERROR_INV_SPS_PPS_T;
         }
 
         /* reading seq_scaling_matrix_present_flag   */
         ps_seq->i4_seq_scaling_matrix_present_flag =
                         (WORD32)ih264d_get_bit_h264(ps_bitstrm);
 
         if(ps_seq->i4_seq_scaling_matrix_present_flag)
         {
             for(i4_i = 0; i4_i < 8; i4_i++)
             {
                 ps_seq->u1_seq_scaling_list_present_flag[i4_i] =
                                 ih264d_get_bit_h264(ps_bitstrm);
 
                 /* initialize u1_use_default_scaling_matrix_flag[i4_i] to zero */
                 /* before calling scaling list                             */
                 ps_seq->u1_use_default_scaling_matrix_flag[i4_i] = 0;
 
                 if(ps_seq->u1_seq_scaling_list_present_flag[i4_i])
                 {
                     if(i4_i < 6)
                     {
                         ret = ih264d_scaling_list(
                                         ps_seq->i2_scalinglist4x4[i4_i],
                                         16,
                                         &ps_seq->u1_use_default_scaling_matrix_flag[i4_i],
                                         ps_bitstrm);
                     }
                     else
                     {
                         ret = ih264d_scaling_list(
                                         ps_seq->i2_scalinglist8x8[i4_i - 6],
                                         64,
                                         &ps_seq->u1_use_default_scaling_matrix_flag[i4_i],
                                         ps_bitstrm);
                     }
                     if(ret != OK)
                     {
                         return ret;
                     }
                 }
             }
         }
     }
     /*--------------------------------------------------------------------*/
     /* Decode MaxFrameNum                                                 */
     /*--------------------------------------------------------------------*/
     u8_temp = (UWORD64)4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u8_temp > MAX_BITS_IN_FRAME_NUM)
     {
         return ERROR_INV_SPS_PPS_T;
     }
     ps_seq->u1_bits_in_frm_num = u8_temp;
     COPYTHECONTEXT("SPS: log2_max_frame_num_minus4",
                     (ps_seq->u1_bits_in_frm_num - 4));
 
     i2_max_frm_num = (1 << (ps_seq->u1_bits_in_frm_num));
     ps_seq->u2_u4_max_pic_num_minus1 = i2_max_frm_num - 1;
     /*--------------------------------------------------------------------*/
     /* Decode picture order count and related values                      */
     /*--------------------------------------------------------------------*/
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
     if(u4_temp > MAX_PIC_ORDER_CNT_TYPE)
     {
         return ERROR_INV_POC_TYPE_T;
     }
     ps_seq->u1_pic_order_cnt_type = u4_temp;
     COPYTHECONTEXT("SPS: pic_order_cnt_type",ps_seq->u1_pic_order_cnt_type);
 
     ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = 1;
     if(ps_seq->u1_pic_order_cnt_type == 0)
     {
         u8_temp = (UWORD64)4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         if(u8_temp > MAX_BITS_IN_POC_LSB)
         {
             return ERROR_INV_SPS_PPS_T;
         }
         ps_seq->u1_log2_max_pic_order_cnt_lsb_minus = u8_temp;
         ps_seq->i4_max_pic_order_cntLsb = (1 << u8_temp);
         COPYTHECONTEXT("SPS: log2_max_pic_order_cnt_lsb_minus4",(u8_temp - 4));
     }
     else if(ps_seq->u1_pic_order_cnt_type == 1)
     {
         ps_seq->u1_delta_pic_order_always_zero_flag = ih264d_get_bit_h264(
                         ps_bitstrm);
         COPYTHECONTEXT("SPS: delta_pic_order_always_zero_flag",
                         ps_seq->u1_delta_pic_order_always_zero_flag);
 
         ps_seq->i4_ofst_for_non_ref_pic = ih264d_sev(pu4_bitstrm_ofst,
                                                      pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: offset_for_non_ref_pic",
                         ps_seq->i4_ofst_for_non_ref_pic);
 
         ps_seq->i4_ofst_for_top_to_bottom_field = ih264d_sev(
                         pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: offset_for_top_to_bottom_field",
                         ps_seq->i4_ofst_for_top_to_bottom_field);
 
         u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         if(u4_temp > 255)
             return ERROR_INV_SPS_PPS_T;
         ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = u4_temp;
         COPYTHECONTEXT("SPS: num_ref_frames_in_pic_order_cnt_cycle",
                         ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle);
 
         for(i = 0; i < ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle; i++)
         {
             ps_seq->i4_ofst_for_ref_frame[i] = ih264d_sev(
                             pu4_bitstrm_ofst, pu4_bitstrm_buf);
             COPYTHECONTEXT("SPS: offset_for_ref_frame",
                             ps_seq->i4_ofst_for_ref_frame[i]);
         }
     }
 
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
     if((u4_temp > H264_MAX_REF_PICS))
     {
         return ERROR_NUM_REF;
     }
 
     /* Compare with older num_ref_frames is header is already once */
     if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_num_ref_frames != u4_temp))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
 
     ps_seq->u1_num_ref_frames = u4_temp;
     COPYTHECONTEXT("SPS: num_ref_frames",ps_seq->u1_num_ref_frames);
 
     ps_seq->u1_gaps_in_frame_num_value_allowed_flag = ih264d_get_bit_h264(
                     ps_bitstrm);
     COPYTHECONTEXT("SPS: gaps_in_frame_num_value_allowed_flag",
                     ps_seq->u1_gaps_in_frame_num_value_allowed_flag);
 
     /*--------------------------------------------------------------------*/
     /* Decode FrameWidth and FrameHeight and related values               */
     /*--------------------------------------------------------------------*/
     u8_temp = (UWORD64)1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     /* Check  for unsupported resolutions*/
     if(u8_temp > (H264_MAX_FRAME_WIDTH >> 4))
     {
         return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
     }
     u4_pic_width_in_mbs = u8_temp;
     COPYTHECONTEXT("SPS: pic_width_in_mbs_minus1",
                    u4_pic_width_in_mbs - 1);
 
     u8_temp = (UWORD64)1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if (u8_temp > (H264_MAX_FRAME_HEIGHT >> 4))
     {
         return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
     }
     u4_pic_height_in_map_units = u8_temp;
 
     ps_seq->u2_frm_wd_in_mbs = u4_pic_width_in_mbs;
     ps_seq->u2_frm_ht_in_mbs = u4_pic_height_in_map_units;
 
     u2_pic_wd = (u4_pic_width_in_mbs << 4);
     u2_pic_ht = (u4_pic_height_in_map_units << 4);
     /*--------------------------------------------------------------------*/
     /* Get the value of MaxMbAddress and Number of bits needed for it     */
     /*--------------------------------------------------------------------*/
     ps_seq->u2_max_mb_addr = (ps_seq->u2_frm_wd_in_mbs
                     * ps_seq->u2_frm_ht_in_mbs) - 1;
 
     ps_seq->u2_total_num_of_mbs = ps_seq->u2_max_mb_addr + 1;
 
     ps_seq->u1_level_idc = ih264d_correct_level_idc(
                     u1_level_idc, ps_seq->u2_total_num_of_mbs);
 
     u1_frm = ih264d_get_bit_h264(ps_bitstrm);
     if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_frame_mbs_only_flag != u1_frm))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
 
     ps_seq->u1_frame_mbs_only_flag = u1_frm;
 
     COPYTHECONTEXT("SPS: frame_mbs_only_flag", u1_frm);
 
     if(!u1_frm)
         u1_mb_aff_flag = ih264d_get_bit_h264(ps_bitstrm);
 
     if((ps_dec->i4_header_decoded & 1)
                     && (ps_seq->u1_mb_aff_flag != u1_mb_aff_flag))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
 
     if(!u1_frm)
     {
         u2_pic_ht <<= 1;
         ps_seq->u1_mb_aff_flag = u1_mb_aff_flag;
         COPYTHECONTEXT("SPS: mb_adaptive_frame_field_flag",
                         ps_seq->u1_mb_aff_flag);
 
     }
     else
         ps_seq->u1_mb_aff_flag = 0;
 
     ps_seq->u1_direct_8x8_inference_flag = ih264d_get_bit_h264(ps_bitstrm);
 
     COPYTHECONTEXT("SPS: direct_8x8_inference_flag",
                     ps_seq->u1_direct_8x8_inference_flag);
 
     /* G050 */
     u1_frame_cropping_flag = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("SPS: frame_cropping_flag",u1_frame_cropping_flag);
 
     if(u1_frame_cropping_flag)
     {
         u1_frame_cropping_rect_left_ofst = ih264d_uev(pu4_bitstrm_ofst,
                                                       pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: frame_cropping_rect_left_offset",
                         u1_frame_cropping_rect_left_ofst);
         u1_frame_cropping_rect_right_ofst = ih264d_uev(pu4_bitstrm_ofst,
                                                        pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: frame_cropping_rect_right_offset",
                         u1_frame_cropping_rect_right_ofst);
         u1_frame_cropping_rect_top_ofst = ih264d_uev(pu4_bitstrm_ofst,
                                                      pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: frame_cropping_rect_top_offset",
                         u1_frame_cropping_rect_top_ofst);
         u1_frame_cropping_rect_bottom_ofst = ih264d_uev(pu4_bitstrm_ofst,
                                                         pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: frame_cropping_rect_bottom_offset",
                         u1_frame_cropping_rect_bottom_ofst);
     }
     /* G050 */
 
     ps_seq->u1_vui_parameters_present_flag = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("SPS: vui_parameters_present_flag",
                     ps_seq->u1_vui_parameters_present_flag);
 
     u2_frm_wd_y = u2_pic_wd + (UWORD8)(PAD_LEN_Y_H << 1);
     if(1 == ps_dec->u4_share_disp_buf)
     {
         if(ps_dec->u4_app_disp_width > u2_frm_wd_y)
             u2_frm_wd_y = ps_dec->u4_app_disp_width;
     }
 
     u2_frm_ht_y = u2_pic_ht + (UWORD8)(PAD_LEN_Y_V << 2);
     u2_frm_wd_uv = u2_pic_wd + (UWORD8)(PAD_LEN_UV_H << 2);
     u2_frm_wd_uv = MAX(u2_frm_wd_uv, u2_frm_wd_y);
 
     u2_frm_ht_uv = (u2_pic_ht >> 1) + (UWORD8)(PAD_LEN_UV_V << 2);
     u2_frm_ht_uv = MAX(u2_frm_ht_uv, (u2_frm_ht_y >> 1));
 
 
     /* Calculate display picture width, height and start u4_ofst from YUV420 */
     /* pictute buffers as per cropping information parsed above             */
     {
         UWORD16 u2_rgt_ofst = 0;
         UWORD16 u2_lft_ofst = 0;
         UWORD16 u2_top_ofst = 0;
         UWORD16 u2_btm_ofst = 0;
         UWORD8 u1_frm_mbs_flag;
         UWORD8 u1_vert_mult_factor;
 
         if(u1_frame_cropping_flag)
         {
             /* Calculate right and left u4_ofst for cropped picture           */
             u2_rgt_ofst = u1_frame_cropping_rect_right_ofst << 1;
             u2_lft_ofst = u1_frame_cropping_rect_left_ofst << 1;
 
             /* Know frame MBs only u4_flag                                      */
             u1_frm_mbs_flag = (1 == ps_seq->u1_frame_mbs_only_flag);
 
             /* Simplify the vertical u4_ofst calculation from field/frame     */
             u1_vert_mult_factor = (2 - u1_frm_mbs_flag);
 
             /* Calculate bottom and top u4_ofst for cropped  picture          */
             u2_btm_ofst = (u1_frame_cropping_rect_bottom_ofst
                             << u1_vert_mult_factor);
             u2_top_ofst = (u1_frame_cropping_rect_top_ofst
                             << u1_vert_mult_factor);
         }
 
         /* Calculate u4_ofst from start of YUV 420 picture buffer to start of*/
         /* cropped picture buffer                                           */
         u2_crop_offset_y = (u2_frm_wd_y * u2_top_ofst) + (u2_lft_ofst);
         u2_crop_offset_uv = (u2_frm_wd_uv * (u2_top_ofst >> 1))
                         + (u2_lft_ofst >> 1) * YUV420SP_FACTOR;
         /* Calculate the display picture width and height based on crop      */
         /* information                                                       */
         i4_cropped_ht = (WORD32)u2_pic_ht - (WORD32)(u2_btm_ofst + u2_top_ofst);
         i4_cropped_wd = (WORD32)u2_pic_wd - (WORD32)(u2_rgt_ofst + u2_lft_ofst);
 
         if((i4_cropped_ht < MB_SIZE) || (i4_cropped_wd < MB_SIZE))
         {
             return ERROR_INV_SPS_PPS_T;
         }
 
         if((ps_dec->i4_header_decoded & 1) && (ps_dec->u2_pic_wd != u2_pic_wd))
         {
             ps_dec->u1_res_changed = 1;
             return IVD_RES_CHANGED;
         }
 
         if((ps_dec->i4_header_decoded & 1) && (ps_dec->u2_disp_width != i4_cropped_wd))
         {
             ps_dec->u1_res_changed = 1;
             return IVD_RES_CHANGED;
         }
 
         if((ps_dec->i4_header_decoded & 1) && (ps_dec->u2_pic_ht != u2_pic_ht))
         {
             ps_dec->u1_res_changed = 1;
             return IVD_RES_CHANGED;
         }
 
         if((ps_dec->i4_header_decoded & 1) && (ps_dec->u2_disp_height != i4_cropped_ht))
         {
             ps_dec->u1_res_changed = 1;
             return IVD_RES_CHANGED;
         }
 
         /* Check again for unsupported resolutions with updated values*/
         if((u2_pic_wd > H264_MAX_FRAME_WIDTH) || (u2_pic_ht > H264_MAX_FRAME_HEIGHT)
                 || (u2_pic_wd < H264_MIN_FRAME_WIDTH) || (u2_pic_ht < H264_MIN_FRAME_HEIGHT)
                 || (u2_pic_wd * (UWORD32)u2_pic_ht > H264_MAX_FRAME_SIZE))
         {
             return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
         }
 
         /* If MBAff is enabled, decoder support is limited to streams with
          * width less than half of H264_MAX_FRAME_WIDTH.
          * In case of MBAff decoder processes two rows at a time
          */
         if((u2_pic_wd << ps_seq->u1_mb_aff_flag) > H264_MAX_FRAME_WIDTH)
         {
             return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
         }
 
     }
 
     /* Backup num_reorder_frames if header is already decoded */
     if((ps_dec->i4_header_decoded & 1) &&
                     (1 == ps_seq->u1_vui_parameters_present_flag) &&
                     (1 == ps_seq->s_vui.u1_bitstream_restriction_flag))
     {
         num_reorder_frames =  (WORD32)ps_seq->s_vui.u4_num_reorder_frames;
     }
     else
     {
         num_reorder_frames = -1;
     }
     if(1 == ps_seq->u1_vui_parameters_present_flag)
     {
         ret = ih264d_parse_vui_parametres(&ps_seq->s_vui, ps_bitstrm);
         if(ret != OK)
             return ret;
     }
 
     /* Compare older num_reorder_frames with the new one if header is already decoded */
     if((ps_dec->i4_header_decoded & 1) &&
                     (-1 != num_reorder_frames) &&
                     (1 == ps_seq->u1_vui_parameters_present_flag) &&
                     (1 == ps_seq->s_vui.u1_bitstream_restriction_flag) &&
                     ((WORD32)ps_seq->s_vui.u4_num_reorder_frames != num_reorder_frames))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
 
     /* In case bitstream read has exceeded the filled size, then
      return an error */
-    if (ps_bitstrm->u4_ofst > ps_bitstrm->u4_max_ofst)
+    if (EXCEED_OFFSET(ps_bitstrm))
     {
         return ERROR_INV_SPS_PPS_T;
     }
 
     /*--------------------------------------------------------------------*/
     /* All initializations to ps_dec are beyond this point                */
     /*--------------------------------------------------------------------*/
     {
         WORD32 reorder_depth = ih264d_get_dpb_size(ps_seq);
         if((1 == ps_seq->u1_vui_parameters_present_flag) &&
            (1 == ps_seq->s_vui.u1_bitstream_restriction_flag))
         {
             reorder_depth = ps_seq->s_vui.u4_num_reorder_frames + 1;
         }
 
         if (reorder_depth > H264_MAX_REF_PICS)
         {
             return ERROR_INV_SPS_PPS_T;
         }
 
         if(ps_seq->u1_frame_mbs_only_flag != 1)
             reorder_depth *= 2;
         ps_dec->i4_reorder_depth = reorder_depth + DISPLAY_LATENCY;
     }
     ps_dec->u2_disp_height = i4_cropped_ht;
     ps_dec->u2_disp_width = i4_cropped_wd;
 
     ps_dec->u2_pic_wd = u2_pic_wd;
     ps_dec->u2_pic_ht = u2_pic_ht;
 
     /* Determining the Width and Height of Frame from that of Picture */
     ps_dec->u2_frm_wd_y = u2_frm_wd_y;
     ps_dec->u2_frm_ht_y = u2_frm_ht_y;
 
     ps_dec->u2_frm_wd_uv = u2_frm_wd_uv;
     ps_dec->u2_frm_ht_uv = u2_frm_ht_uv;
     ps_dec->s_pad_mgr.u1_pad_len_y_v = (UWORD8)(PAD_LEN_Y_V << (1 - u1_frm));
     ps_dec->s_pad_mgr.u1_pad_len_cr_v = (UWORD8)(PAD_LEN_UV_V << (1 - u1_frm));
 
     ps_dec->u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs;
     ps_dec->u2_frm_ht_in_mbs = ps_seq->u2_frm_ht_in_mbs;
 
     ps_dec->u2_crop_offset_y = u2_crop_offset_y;
     ps_dec->u2_crop_offset_uv = u2_crop_offset_uv;
 
     ps_seq->u1_is_valid = TRUE;
     ps_dec->ps_sps[u1_seq_parameter_set_id] = *ps_seq;
     ps_dec->ps_cur_sps = &ps_dec->ps_sps[u1_seq_parameter_set_id];
 
     return OK;
 }
 
 /*!
  **************************************************************************
  * \if Function name : ih264d_parse_end_of_sequence \endif
  *
  * \brief
  *    Decodes End of Sequence.
  *
  * \param ps_bitstrm   : Pointer to bit ps_bitstrm containing the NAL unit
  *
  * \return
  *    0 on Success and error code otherwise
  **************************************************************************
  */
diff --git a/decoder/ih264d_sei.c b/decoder/ih264d_sei.c
index 4375671..ac4d056 100644
--- a/decoder/ih264d_sei.c
+++ b/decoder/ih264d_sei.c
@@ -751,74 +751,86 @@ WORD32 ih264d_parse_sei_payload(dec_bit_stream_t *ps_bitstrm,
 WORD32 ih264d_parse_sei_message(dec_struct_t *ps_dec,
                                 dec_bit_stream_t *ps_bitstrm)
 {
     UWORD32 ui4_payload_type, ui4_payload_size;
     UWORD32 u4_bits;
     WORD32 i4_status = 0;
 
     do
     {
         ui4_payload_type = 0;
 
+        if(!CHECK_BITS_SUFFICIENT(ps_bitstrm, 8))
+        {
+            return ERROR_EOB_GETBITS_T;
+        }
         u4_bits = ih264d_get_bits_h264(ps_bitstrm, 8);
-        while(0xff == u4_bits && !EXCEED_OFFSET(ps_bitstrm))
+        while(0xff == u4_bits && CHECK_BITS_SUFFICIENT(ps_bitstrm, 8))
         {
             u4_bits = ih264d_get_bits_h264(ps_bitstrm, 8);
             ui4_payload_type += 255;
         }
         ui4_payload_type += u4_bits;
 
         ui4_payload_size = 0;
+        if(!CHECK_BITS_SUFFICIENT(ps_bitstrm, 8))
+        {
+            return ERROR_EOB_GETBITS_T;
+        }
         u4_bits = ih264d_get_bits_h264(ps_bitstrm, 8);
-        while(0xff == u4_bits && !EXCEED_OFFSET(ps_bitstrm))
+        while(0xff == u4_bits && CHECK_BITS_SUFFICIENT(ps_bitstrm, 8))
         {
             u4_bits = ih264d_get_bits_h264(ps_bitstrm, 8);
             ui4_payload_size += 255;
         }
         ui4_payload_size += u4_bits;
 
+        if(!CHECK_BITS_SUFFICIENT(ps_bitstrm, (ui4_payload_size << 3)))
+        {
+            return ERROR_EOB_GETBITS_T;
+        }
         i4_status = ih264d_parse_sei_payload(ps_bitstrm, ui4_payload_type,
                                              ui4_payload_size, ps_dec);
         if(i4_status != OK)
             return i4_status;
 
         if(ih264d_check_byte_aligned(ps_bitstrm) == 0)
         {
             u4_bits = ih264d_get_bit_h264(ps_bitstrm);
             if(0 == u4_bits)
             {
                 H264_DEC_DEBUG_PRINT("\nError in parsing SEI message");
             }
             while(0 == ih264d_check_byte_aligned(ps_bitstrm)
-                            && !EXCEED_OFFSET(ps_bitstrm))
+                            && CHECK_BITS_SUFFICIENT(ps_bitstrm, 1))
             {
                 u4_bits = ih264d_get_bit_h264(ps_bitstrm);
                 if(u4_bits)
                 {
                     H264_DEC_DEBUG_PRINT("\nError in parsing SEI message");
                 }
             }
         }
     }
-    while(ps_bitstrm->u4_ofst < ps_bitstrm->u4_max_ofst);
+    while(MORE_RBSP_DATA(ps_bitstrm));
     return (i4_status);
 }
 
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : ih264d_export_sei_mdcv_params                            */
 /*                                                                           */
 /*  Description   : This function populates SEI mdcv message in              */
 /*                     output structure                                      */
 /*  Inputs        : ps_sei_mdcv_op pointer to sei mdcv o\p struct            */
 /*                : ps_sei pointer to decoded sei params                     */
 /*  Outputs       :                                                          */
 /*  Returns       : returns 0 for success; -1 for failure                    */
 /*                                                                           */
 /*  Issues        : none                                                     */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*                                                                           */
 /*                                                                           */
 /*****************************************************************************/
