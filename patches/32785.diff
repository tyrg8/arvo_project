commit e5be5a65d8473d490333bc6124e0879147f13609
Author: Reini Urban <rurban@cpan.org>
Date:   Thu Apr 1 15:39:11 2021 +0200

    indxf: reset j on non-vector fields
    
    we have several special cases for vectors or pts, where we
    need a global j counter. but when we set a single field, such as a
    num_clip_verts 91 or such. then we need to reset j, otherwise
    we could run into vector or pts overflows.
    As in oss-fuzz issue 32755 and 32785

diff --git a/src/in_dxf.c b/src/in_dxf.c
index 8e463c5d..a8e394c8 100644
--- a/src/in_dxf.c
+++ b/src/in_dxf.c
@@ -8765,3085 +8765,3086 @@ static Dxf_Pair *
 new_object (char *restrict name, char *restrict dxfname,
             Bit_Chain *restrict dat, Dwg_Data *restrict dwg,
             BITCODE_BL ctrl_id, BITCODE_BL *i_p)
 {
   const int is_tu = 1;
   Dwg_Object *obj;
   Dxf_Pair *pair = dxf_read_pair (dat);
   Dwg_Object_APPID *_obj = NULL; // the smallest
   // we'd really need a Dwg_Object_TABLE or Dwg_Object_Generic type
   char ctrlname[80];
   char subclass[80];
   char text[256]; // FIXME
   int in_xdict = 0;
   int in_reactors = 0;
   int in_blkrefs = 0;
   int in_embedobj = 0;
   int is_entity = is_dwg_entity (name) || strEQc (name, "DIMENSION");
   // BITCODE_BL rcount1, rcount2, rcount3, vcount;
   // Bit_Chain *hdl_dat, *str_dat;
   int j = 0, k = 0, l = 0, error = 0;
   BITCODE_BL i = i_p ? *i_p : 0;
   int cur_cell = -1;
   unsigned written = 0;
   BITCODE_RL curr_inserts = 0;
   BITCODE_RS flag = 0;
   BITCODE_BB scale_flag;
   BITCODE_3BD pt;
   Dwg_Object *ctrl;
   const Dwg_DYNAPI_field *prev_vstyle = NULL;
   subclass[0] = '\0';
 
   if (ctrl_id || i)
     {
       LOG_TRACE ("add %s [%d]\n", name, i)
     }
   else
     {
       if (strcmp (name, dxfname) != 0)
         LOG_TRACE ("add %s (%s)\n", name, dxfname)
       else
         LOG_TRACE ("add %s\n", name)
     }
 
   if (is_entity)
     {
       NEW_ENTITY (dwg, obj);
 
       obj->tio.entity->is_xdic_missing = 1;
       obj->tio.entity->color.index = 256; // ByLayer
       obj->tio.entity->ltype_scale = 1.0;
       if (strEQc (name, "SEQEND") || memBEGINc (name, "VERTEX"))
         obj->tio.entity->linewt = 0x1c;
       else
         obj->tio.entity->linewt = 0x1d;
 
       if (*name == '3')
         {
           // Looks dangerous but name[80] is big enough
           memmove (&name[1], &name[0], strlen (name) + 1);
           *name = '_';
         }
       if (strEQc (name, "DIMENSION"))
         { // the biggest
           ADD_ENTITY (DIMENSION_ANG2LN);
         }
       // broken (causes acad to hang on audit redraw)
       /*
       else if (is_class_unstable (name)
                && strEQc (name, "WIPEOUT"))
         {
           LOG_ERROR ("Unhandled DXF entity %s", name);
           name = (char*)"UNKNOWN_ENT";
           ADD_ENTITY (UNKNOWN_ENT);
           return pair;
         }
       */
       else
         {
           // clang-format off
           // ADD_ENTITY by name
           // check all objects
           #undef DWG_ENTITY
           #define DWG_ENTITY(token)             \
           if (strEQc (name, #token))            \
             {                                   \
               ADD_ENTITY (token);               \
               goto found_ent;                   \
             }                                   \
           else
 
           #include "objects.inc"
           //final else
           LOG_WARN ("Unknown object %s", name);
 
           #undef DWG_ENTITY
           #define DWG_ENTITY(token)
           // clang-format on
         found_ent:;
         }
     }
   else
     {
       NEW_OBJECT (dwg, obj);
 
       obj->tio.object->is_xdic_missing = 1;
       if (!ctrl_id) // no table
         {
           // clang-format off
           // ADD_OBJECT by name
           // check all objects
           #undef DWG_OBJECT
           #define DWG_OBJECT(token)         \
               if (strEQc (name, #token))    \
                 {                           \
                   ADD_OBJECT (token);       \
                   goto found_obj;           \
                 }
 
           #include "objects.inc"
 
           #undef DWG_OBJECT
           #define DWG_OBJECT(token)
 
         found_obj:
           ;
           // clang-format on
         }
       else // a table
         {
           if (strEQc (name, "BLOCK_RECORD"))
             {
               // strcpy (name, "BLOCK_HEADER");
               strcpy (ctrlname, "BLOCK_CONTROL");
             }
           else
             {
               strncpy (ctrlname, name, 70);
               ctrlname[69] = '\0';
               strcat (ctrlname, "_CONTROL");
             }
 
           // clang-format off
           ADD_TABLE_IF (LTYPE, LTYPE)
           else
           ADD_TABLE_IF (VPORT, VPORT)
           else
           ADD_TABLE_IF (APPID, APPID)
           else
           ADD_TABLE_IF (DIMSTYLE, DIMSTYLE)
           else
           ADD_TABLE_IF (LAYER, LAYER)
           else
           ADD_TABLE_IF (STYLE, STYLE)
           else
           ADD_TABLE_IF (UCS, UCS)
           else
           ADD_TABLE_IF (VIEW, VIEW)
           else
           ADD_TABLE_IF (BLOCK_RECORD, BLOCK_HEADER)
           else
           ADD_TABLE_IF (VX_TABLE_RECORD, VX_TABLE_RECORD)
           else
           // clang-format on
           {
             dwg->num_objects--;
             LOG_ERROR ("Unknown DXF AcDbSymbolTableRecord %s, skipping", name);
             return pair;
           }
         }
     }
 
   if (!_obj)
     {
       dwg->num_objects--;
       LOG_ERROR ("Empty _obj at DXF AcDbSymbolTableRecord %s, skipping", name);
       return pair;
     }
   ctrl = &dwg->object[ctrl_id];
 
   {
     const Dwg_DYNAPI_field *f1;
     BITCODE_B is_xref_ref = 1;
     // set defaults not in dxf:
     if (dwg_dynapi_entity_field (obj->name, "is_xref_ref"))
       dwg_dynapi_entity_set_value (_obj, obj->name, "is_xref_ref",
                                    &is_xref_ref, 0);
     if ((f1 = dwg_dynapi_entity_field (obj->name, "scale_flag"))
         && (memBEGINc(f1->type, "BB")))
       {
         scale_flag = 3;
         dwg_dynapi_entity_set_value (_obj, obj->name, "scale_flag",
                                      &scale_flag, 0);
         LOG_TRACE ("%s.scale_flag = 3 (default)\n", obj->name);
       }
     if ((f1 = dwg_dynapi_entity_field (obj->name, "width_factor"))
         && (memBEGINc(f1->type, "RD") || memBEGINc(f1->type, "BD")))
       {
         BITCODE_BD width_factor = 1.0;
         dwg_dynapi_entity_set_value (_obj, obj->name, "width_factor",
                                      &width_factor, 0);
         LOG_TRACE ("%s.width_factor = 1.0 (default)\n", obj->name);
       }
     if ((f1 = dwg_dynapi_entity_field (obj->name, "scale"))
         && (memBEGINc(f1->type, "3BD")))
       {
         pt.x = pt.y = pt.z = 1.0;
         dwg_dynapi_entity_set_value (_obj, obj->name, "scale", &pt, 0);
         LOG_TRACE ("%s.scale = (1,1,1) (default)\n", obj->name);
         pt.x = pt.y = pt.z = 0.0;
       }
     if ((f1 = dwg_dynapi_entity_field (obj->name, "extrusion"))
         && (memBEGINc(f1->type, "BE") || memBEGINc(f1->type, "3BD")))
       {
         pt.x = pt.y = 0.0;
         pt.z = 1.0;
         dwg_dynapi_entity_set_value (_obj, obj->name, "extrusion", &pt, 0);
         LOG_TRACE ("%s.extrusion = (0,0,1) (default)\n", obj->name);
         pt.z = 0.0;
       }
   }
   // more DXF defaults
   if (obj->fixedtype == DWG_TYPE_LAYOUT)
     {
       Dwg_Object_LAYOUT *o = obj->tio.object->tio.LAYOUT;
       o->plotsettings.paper_units = 1.0; // default
     }
   else if (obj->fixedtype == DWG_TYPE_PLOTSETTINGS)
     {
       Dwg_Object_PLOTSETTINGS *o = obj->tio.object->tio.PLOTSETTINGS;
       o->paper_units = 1.0; // default
     }
   else if (obj->fixedtype == DWG_TYPE_DIMSTYLE)
     {
       Dwg_Object_DIMSTYLE *o = obj->tio.object->tio.DIMSTYLE;
       o->DIMSCALE = o->DIMLFAC = o->DIMTFAC = 1.0; // default
       o->DIMALTU = o->DIMLUNIT = 2;                // default
       o->DIMFIT = 3;
       o->DIMLWD = o->DIMLWE = -2;
     }
   else if (obj->fixedtype == DWG_TYPE_TABLESTYLE)
     {
       Dwg_Object_TABLESTYLE *o = obj->tio.object->tio.TABLESTYLE;
       o->num_rowstyles = 3;
       o->rowstyles = (Dwg_TABLESTYLE_rowstyles *)xcalloc (
           3, sizeof (Dwg_TABLESTYLE_rowstyles));
       if (!o->rowstyles)
         {
           o->num_rowstyles = 0;
           goto invalid_dxf;
         }
       for (j = 0; j < 3; j++)
         {
           o->rowstyles[j].borders = (Dwg_TABLESTYLE_border *)xcalloc (
               6, sizeof (Dwg_TABLESTYLE_border));
           o->rowstyles[j].num_borders = 6;
           for (k = 0; k < 3; k++) // defaults: ByLayer
             {
               o->rowstyles[j].borders[k].visible = 1;
               o->rowstyles[j].borders[k].linewt = 29;
               o->rowstyles[j].borders[k].color.index = 256;
             }
         }
       k = 0;
       j = 0;
     }
   /*
   else if (is_textlike (obj))
     {
       BITCODE_RC dataflags = 0x2 + 0x4 + 0x8;
       dwg_dynapi_entity_set_value (_obj, obj->name, "dataflags",
                                    &dataflags, 0);
     }
   */
   else if (obj->fixedtype == DWG_TYPE_MTEXT)
     {
       BITCODE_H style;
       Dwg_Entity_MTEXT *o = obj->tio.entity->tio.MTEXT;
       o->x_axis_dir.x = 1.0;
       // set style to Standard (5.1.11)
       style = dwg_find_tablehandle_silent (dwg, "Standard", "STYLE");
       if (style)
         {
           if (style->handleref.code != 5)
             style = dwg_add_handleref (dwg, 5, style->absolute_ref, NULL);
           o->style = style;
         }
     }
   // Some objects have various subtypes under one name, like DIMENSION.
   // TODO OBJECTCONTEXTDATA, ...
 
   // read table fields until next 0 table or 0 ENDTAB
   while (pair != NULL && pair->code != 0)
     {
     start_loop:
       if (pair == NULL)
         {
           pair = dxf_read_pair (dat);
           DXF_RETURN_EOF (pair);
         }
 #if 0
       // don't set defaults. TODO but needed to reset counters j, k, l
       if ((pair->type == DWG_VT_INT8 || pair->type == DWG_VT_INT16 || pair->type == DWG_VT_BOOL) &&
           pair->value.i == 0)
         goto next_pair;
       else if (pair->type == DWG_VT_REAL && pair->value.d == 0.0)
         goto next_pair;
       else if ((pair->type == DWG_VT_INT32 || pair->type == DWG_VT_INT64) &&
                pair->value.l == 0L)
         goto next_pair;
 #endif
       // start_switch:
       switch (pair->code)
         { // common flags: name, xref
         case 0:
           if (strEQc (name, "SEQEND"))
             dxf_postprocess_SEQEND (obj);
           return pair;
         case 105: /* DIMSTYLE only for 5 */
           if (strNE (name, "DIMSTYLE"))
             goto object_default;
           // fall through
         case 5:
           {
             obj->handle.value = pair->value.u;
             // check for existing BLOCK_HEADER.*Model_Space
             if (obj->fixedtype == DWG_TYPE_BLOCK_HEADER
                 && dwg->object[0].handle.value == pair->value.u
                 && obj->tio.object->tio.BLOCK_HEADER
                        != dwg->object[0].tio.object->tio.BLOCK_HEADER
                 && dwg->num_objects)
               {
                 dwg->num_objects--;
                 free (obj->tio.object->tio.BLOCK_HEADER);
                 obj = &dwg->object[0];
                 _obj = obj->tio.object->tio.APPID;
                 LOG_TRACE ("Reuse existing BLOCK_HEADER.*Model_Space %X [0]\n",
                            pair->value.u)
               }
             dwg_add_handle (&obj->handle, 0, pair->value.u, obj);
             LOG_TRACE ("%s.handle = " FORMAT_H " [H 5]\n", name,
                        ARGS_H (obj->handle));
             if (ctrl_id)
               {
                 // add to ctrl "entries" HANDLE_VECTOR
                 Dwg_Object_BLOCK_CONTROL *_ctrl
                     = dwg->object[ctrl_id].tio.object->tio.BLOCK_CONTROL;
                 BITCODE_H *hdls = NULL;
                 BITCODE_BL num_entries = 0;
 
                 if ((int)i < 0)
                   i = 0;
                 dwg_dynapi_entity_value (_ctrl, ctrlname, "num_entries",
                                          &num_entries, NULL);
                 if (i >= num_entries)
                   {
                     // DXF often lies about num_entries, skipping defaults
                     // e.g. BLOCK_CONTROL contains mspace+pspace in DXF, but in
                     // the DWG they are extra. But this is fixed at case 2, not
                     // here.
                     LOG_TRACE ("Misleading %s.num_entries %d for %dth entry\n",
                                ctrlname, num_entries, i);
                     i = num_entries;
                     num_entries++;
                     dwg_dynapi_entity_set_value (
                         _ctrl, ctrlname, "num_entries", &num_entries, 0);
                     LOG_TRACE ("%s.num_entries = %d [BL 70]\n", ctrlname,
                                num_entries);
                   }
                 dwg_dynapi_entity_value (_ctrl, ctrlname, "entries", &hdls,
                                          NULL);
                 if (!hdls)
                   hdls = (BITCODE_H *)xcalloc (num_entries,
                                                sizeof (Dwg_Object_Ref *));
                 else
                   hdls = (BITCODE_H *)realloc (
                       hdls, num_entries * sizeof (Dwg_Object_Ref *));
                 if (pair->value.u && !hdls)
                   goto invalid_dxf;
                 hdls[i] = dwg_add_handleref (dwg, 2, pair->value.u, obj);
                 dwg_dynapi_entity_set_value (_ctrl, ctrlname, "entries", &hdls,
                                              0);
                 LOG_TRACE ("%s.%s[%d] = " FORMAT_REF " [H* 0]\n", ctrlname,
                            "entries", i, ARGS_REF (hdls[i]));
               }
           }
           break;
         case 8:
           if (is_entity && pair->value.s)
             {
               BITCODE_H handle = find_tablehandle (dwg, pair);
               if (!handle)
                 {
                   obj_hdls = array_push (obj_hdls, "layer", pair->value.s,
                                          obj->tio.object->objid);
                   LOG_TRACE ("%s.layer: name %s -> H later\n", obj->name,
                              pair->value.s)
                 }
               else
                 {
                   dwg_dynapi_common_set_value (_obj, "layer", &handle, 1);
                   LOG_TRACE ("%s.layer = %s " FORMAT_REF " [H 8]\n", name,
                              pair->value.s, ARGS_REF (handle));
                 }
               break;
             }
           // fall through
         case 100: // for nested structs
           if (pair->code == 100 && pair->value.s)
             {
               strncpy (subclass, pair->value.s, 79);
               subclass[79] = '\0';
               // set the real objname
               if (strEQc (obj->name, "DIMENSION_ANG2LN")
                   || strEQc (obj->name, "DIMENSION"))
                 {
                   // we rather checked the flag before
                   if (strEQc (subclass, "AcDbRotatedDimension"))
                     {
                       obj->type = obj->fixedtype = DWG_TYPE_DIMENSION_LINEAR;
                       obj->name = (char *)"DIMENSION_LINEAR";
                       obj->dxfname = strdup (obj->name);
                       strcpy (name, obj->name);
                       LOG_TRACE ("change type to %s\n", name);
                     }
                   else if (strEQc (subclass, "AcDbAlignedDimension"))
                     {
                       // could be DIMENSION_LINEAR also. changed later on those
                       // new pairs
                       obj->type = obj->fixedtype = DWG_TYPE_DIMENSION_ALIGNED;
                       obj->name = (char *)"DIMENSION_ALIGNED";
                       obj->dxfname = strdup (obj->name);
                       strcpy (name, obj->name);
                       LOG_TRACE ("change type to %s\n", name);
                     }
                   else if (strEQc (subclass, "AcDbOrdinateDimension"))
                     {
                       obj->type = obj->fixedtype = DWG_TYPE_DIMENSION_ORDINATE;
                       obj->name = (char *)"DIMENSION_ORDINATE";
                       obj->dxfname = strdup (obj->name);
                       strcpy (name, obj->name);
                       LOG_TRACE ("change type to %s\n", name);
                     }
                   else if (strEQc (subclass, "AcDbDiametricDimension"))
                     {
                       obj->type = obj->fixedtype = DWG_TYPE_DIMENSION_DIAMETER;
                       obj->name = (char *)"DIMENSION_DIAMETER";
                       obj->dxfname = strdup (obj->name);
                       strcpy (name, obj->name);
                       LOG_TRACE ("change type to %s\n", name);
                     }
                   else if (strEQc (subclass, "AcDbRadialDimension"))
                     {
                       UPGRADE_ENTITY (DIMENSION_ANG2LN, DIMENSION_RADIUS)
                     }
                   else if (strEQc (subclass, "AcDb3PointAngularDimension"))
                     {
                       UPGRADE_ENTITY (DIMENSION_ANG2LN, DIMENSION_ANG3PT)
                     }
                 }
               if (strEQc (obj->name, "DIMENSION_ALIGNED")
                   && strEQc (subclass, "AcDbRotatedDimension"))
                 {
                   UPGRADE_ENTITY (DIMENSION_ALIGNED, DIMENSION_LINEAR)
                 }
               // set the real objname
               else if (strEQc (obj->name, "POLYLINE_2D"))
                 {
                   if (strEQc (subclass, "AcDb3dPolyline"))
                     {
                       UPGRADE_ENTITY (POLYLINE_2D, POLYLINE_3D)
                     }
                   else if (strEQc (subclass, "AcDbPolyFaceMesh"))
                     {
                       UPGRADE_ENTITY (POLYLINE_2D, POLYLINE_PFACE)
                     }
                   else if (strEQc (subclass, "AcDbPolygonMesh"))
                     {
                       UPGRADE_ENTITY (POLYLINE_2D, POLYLINE_MESH)
                     }
                 }
               else if (strEQc (obj->name, "VERTEX_2D"))
                 {
                   if (strEQc (subclass, "AcDb3dPolylineVertex"))
                     {
                       UPGRADE_ENTITY (VERTEX_2D, VERTEX_3D)
                     }
                   else if (strEQc (subclass, "AcDbPolyFaceMeshVertex"))
                     { // _MESH or _PFACE:
                       Dwg_Object_Ref *owner = obj->tio.entity->ownerhandle;
                       Dwg_Object *parent = dwg_ref_object (dwg, owner);
                       if (parent
                           && parent->fixedtype == DWG_TYPE_POLYLINE_PFACE)
                         {
                           UPGRADE_ENTITY (VERTEX_2D, VERTEX_PFACE)
                         }
                       else
                         { // AcDbPolygonMesh
                           UPGRADE_ENTITY (VERTEX_2D, VERTEX_MESH)
                         }
                     }
                   else if (strEQc (subclass, "AcDbFaceRecord"))
                     {
                       UPGRADE_ENTITY (VERTEX_2D, VERTEX_PFACE_FACE)
                     }
                 }
               else if (strEQc (obj->name, "INSERT")
                   && strEQc (subclass, "AcDbMInsertBlock"))
                 {
                   UPGRADE_ENTITY (INSERT, MINSERT)
                 }
 
               // When we have all proper types, check proper subclasses.
               // If the subclass is allowed in this object.
               if (!dwg_has_subclass (obj->name, subclass))
                 {
                   if (is_type_stable (obj->fixedtype))
                     {
                       LOG_ERROR ("FIXME Unknown subclass %s in object %s", subclass, obj->name);
                       return NULL;
                     }
                   else
                     {
                       LOG_WARN ("TODO Unknown subclass %s in object %s", subclass, obj->name);
                     }
                 }
               if (strEQc (subclass, "AcDbDetailViewStyle")
                   && obj->fixedtype != DWG_TYPE_DETAILVIEWSTYLE)
                 {
                   LOG_ERROR ("Invalid subclass %s in object %s", subclass, obj->name);
                   return NULL;
                 }
 
               // with PERSUBENTMGR
               if (obj->fixedtype == DWG_TYPE_PERSUBENTMGR
                   && strEQc (subclass, "AcDbPersSubentManager"))
                 {
                   dxf_free_pair (pair);
                   pair = dxf_read_pair (dat);
                   pair = add_PERSUBENTMGR (obj, dat, pair); // NULL for success
                   if (!pair)
                     goto next_pair;
                   else
                     goto start_loop; /* failure */
                 }
               // with ASSOCDEPENDENCY or ACDBASSOCGEOMDEPENDENCY
               else if (strstr (obj->name, "ASSOC")
                        && strstr (obj->name, "DEPENDENCY")
                        && strEQc (subclass, "AcDbAssocDependency"))
                 {
                   dxf_free_pair (pair);
                   pair = add_ASSOCDEPENDENCY (obj, dat); // NULL for success
                   if (!pair)
                     goto next_pair;
                   else
                     goto start_loop; /* failure */
                 }
               // with ASSOC2DCONSTRAINTGROUP, ASSOCNETWORK, ASSOCACTION
               else if (strstr (obj->name, "ASSOC")
                        && strEQc (subclass, "AcDbAssocAction"))
                 {
                   dxf_free_pair (pair);
                   pair = dxf_read_pair (dat);
                   pair = add_ASSOCACTION (obj, dat, pair); // NULL for success
                   if (!pair)
                     {
                       // TODO: yet unsupported
                       if (strEQc (name, "ASSOC2DCONSTRAINTGROUP"))
                         return dxf_read_pair (dat);
                       else
                         goto next_pair;
                     }
                   else
                     goto start_loop; /* failure */
                 }
               else if (strstr (obj->name, "ASSOC")
                        && strEQc (subclass, "AcDbAssocNetwork"))
                 {
                   dxf_free_pair (pair);
                   pair = dxf_read_pair (dat);
                   LOG_TRACE ("add_ASSOCNETWORK\n")
                   pair = add_ASSOCNETWORK (obj, dat, pair); // NULL for success
                   if (!pair)
                     goto next_pair;
                   else
                     goto start_loop; /* failure */
                 }
               // strict subclasses (functable?)
 #define CHK_SUBCLASS(cppname, addmethod)                                \
   if (strEQc (subclass, #cppname))                                      \
     {                                                                   \
       dxf_free_pair (pair);                                             \
       LOG_TRACE ("add_" #addmethod "\n")                                \
       pair = add_##addmethod (obj, dat); /* NULL for success */         \
       if (!pair)                                                        \
         goto next_pair;                                                 \
       else                                                              \
         goto start_loop; /* failure */                                  \
     }
               else CHK_SUBCLASS (AcDbBlockParameter, AcDbBlockParameter)
               else CHK_SUBCLASS (AcDbBlockGripExpr, AcDbBlockGripExpr)
               else CHK_SUBCLASS (AcDbBlockAlignmentGrip, BLOCKALIGNMENTGRIP)
               else CHK_SUBCLASS (AcDbBlockLinearGrip, BLOCKALIGNMENTGRIP)
               else CHK_SUBCLASS (AcDbBlockFlipGrip, BLOCKFLIPGRIP)
               else CHK_SUBCLASS (AcDbRenderEnvironment, RENDERENVIRONMENT)
               else CHK_SUBCLASS (AcDbRenderGlobal, RENDERGLOBAL)
               else CHK_SUBCLASS (AcDbRenderEntry, RENDERENTRY)
               else CHK_SUBCLASS (AcDbRenderSettings, RENDERSETTINGS)
               // more DYNBLOCKs
 #define else_do_strict_subclass(SUBCLASS)                                     \
   else if (strEQc (subclass, #SUBCLASS))                                      \
   {                                                                           \
     dxf_free_pair (pair);                                                     \
     LOG_TRACE ("add_" #SUBCLASS "\n")                                         \
     pair = add_##SUBCLASS (obj, dat);                                         \
     if (!pair) /* NULL for success */                                         \
       goto next_pair;                                                         \
     else                                                                      \
       goto start_loop; /* failure */                                          \
   }
 
               else_do_strict_subclass (AcDbBlock1PtParameter)
               else_do_strict_subclass (AcDbBlock2PtParameter)
               else_do_strict_subclass (AcDbBlockAction)
               else_do_strict_subclass (AcDbBlockActionWithBasePt)
               else_do_strict_subclass (AcDbBlockFlipAction)
               else_do_strict_subclass (AcDbBlockMoveAction)
               else_do_strict_subclass (AcDbBlockRotationAction)
               else_do_strict_subclass (AcDbBlockScaleAction)
               else_do_strict_subclass (AcDbBlockStretchAction)
               else_do_strict_subclass (AcDbBlockRotationParameter)
             }
           break;
         case 101:
           if (pair->value.s && strEQc (pair->value.s, "Embedded Object"))
             in_embedobj = 1;
           break;
         case 102:
           if (pair->value.s && strEQc (pair->value.s, "{ACAD_XDICTIONARY"))
             in_xdict = 1;
           else if (pair->value.s && strEQc (pair->value.s, "{ACAD_REACTORS"))
             in_reactors = 1;
           else if (ctrl_id && pair->value.s
                    && strEQc (pair->value.s, "{BLKREFS"))
             in_blkrefs = 1; // unique handle 331
           else if (pair->value.s && strEQc (pair->value.s, "}"))
             in_reactors = in_xdict = in_blkrefs = 0;
           else if (pair->value.s && strEQc (name, "XRECORD"))
             pair = add_xdata (dat, obj, pair);
           else
             LOG_WARN ("Unknown DXF code 102 %s in %s", pair->value.s, name)
           break;
         case 331:
           if (ctrl_id && in_blkrefs) // BLKREFS TODO
             {
               BITCODE_H *inserts = NULL;
               BITCODE_H hdl;
               BITCODE_RL num_inserts;
               dwg_dynapi_entity_value (_obj, obj->name, "num_inserts",
                                        &num_inserts, 0);
               if (curr_inserts)
                 dwg_dynapi_entity_value (_obj, obj->name, "inserts", &inserts,
                                          0);
               if (curr_inserts + 1 > num_inserts)
                 {
                   LOG_HANDLE ("  extending %s.num_inserts %d < %d\n",
                               obj->name, num_inserts, curr_inserts + 1);
                   num_inserts = curr_inserts + 1;
                   dwg_dynapi_entity_set_value (_obj, obj->name, "num_inserts",
                                                &num_inserts, 0);
                 }
               if (inserts)
                 inserts = (BITCODE_H *)realloc (
                     inserts, num_inserts * sizeof (BITCODE_H));
               else
                 inserts
                     = (BITCODE_H *)xcalloc (num_inserts, sizeof (BITCODE_H));
               if (num_inserts && !inserts)
                 goto invalid_dxf;
               dwg_dynapi_entity_set_value (_obj, obj->name, "inserts",
                                            &inserts, 0);
               hdl = dwg_add_handleref (dwg, 4, pair->value.u, NULL); // absolute
               LOG_TRACE ("%s.inserts[%d] = " FORMAT_REF " [H* 331]\n",
                          obj->name, curr_inserts, ARGS_REF (hdl));
               inserts[curr_inserts++] = hdl;
               break;
             }
           else if (pair->code == 331 && obj->fixedtype == DWG_TYPE_LAYOUT)
             {
               Dwg_Object_LAYOUT *o = obj->tio.object->tio.LAYOUT;
               o->active_viewport
                   = dwg_add_handleref (dwg, 4, pair->value.u, NULL);
               LOG_TRACE ("%s.active_viewport = " FORMAT_REF " [H 331]\n",
                          obj->name, ARGS_REF (o->active_viewport));
               break;
             }
           // fall through
         case 330:
           if (in_reactors)
             {
               BITCODE_BL num = is_entity ? obj->tio.entity->num_reactors
                                          : obj->tio.object->num_reactors;
               BITCODE_H reactor = dwg_add_handleref (dwg, 4, pair->value.u,
                                                      NULL); // always abs
               LOG_TRACE ("%s.reactors[%d] = " FORMAT_REF " [H* 330]\n", name,
                          num, ARGS_REF (reactor));
               if (is_entity)
                 {
                   obj->tio.entity->reactors
                       = (BITCODE_H *)realloc (obj->tio.entity->reactors,
                                               (num + 1) * sizeof (BITCODE_H));
                   obj->tio.entity->reactors[num] = reactor;
                   obj->tio.entity->num_reactors++;
                 }
               else
                 {
                   obj->tio.object->reactors
                       = (BITCODE_H *)realloc (obj->tio.object->reactors,
                                               (num + 1) * sizeof (BITCODE_H));
                   obj->tio.object->reactors[num] = reactor;
                   obj->tio.object->num_reactors++;
                 }
             }
           else if (pair->code == 330 && obj->fixedtype == DWG_TYPE_LAYOUT
                    && obj->tio.object->ownerhandle)
             {
               Dwg_Object_LAYOUT *o = obj->tio.object->tio.LAYOUT;
               o->block_header
                   = dwg_add_handleref (dwg, 4, pair->value.u, NULL);
               LOG_TRACE ("%s.block_header = " FORMAT_REF " [H 330]\n",
                          obj->name, ARGS_REF (o->block_header));
             }
           // valid ownerhandle, if not XRECORD with an ownerhandle already
           else if (pair->code == 330
                    && (obj->fixedtype != DWG_TYPE_XRECORD
                        || !obj->tio.object->ownerhandle))
             {
               BITCODE_H owh;
               if (is_obj_absowner (obj))
                 owh = dwg_add_handleref (dwg, 4, pair->value.u, NULL);
               else // relative
                 owh = dwg_add_handleref (dwg, 4, pair->value.u, obj);
               if (is_entity)
                 obj->tio.entity->ownerhandle = owh;
               else
                 obj->tio.object->ownerhandle = owh;
               LOG_TRACE ("%s.ownerhandle = " FORMAT_REF " [H 330]\n", name,
                          ARGS_REF (owh));
             }
           break;
         case 350: // DICTIONARY softhandle
         case 360: // {ACAD_XDICTIONARY or some hardowner
           if (pair->code == 360 && in_xdict)
             {
               BITCODE_H xdic = dwg_add_handleref (dwg, 3, pair->value.u, obj);
               if (is_entity)
                 {
                   obj->tio.entity->xdicobjhandle = xdic;
                   obj->tio.entity->is_xdic_missing = 0;
                 }
               else
                 {
                   obj->tio.object->xdicobjhandle = xdic;
                   obj->tio.object->is_xdic_missing = 0;
                 }
               LOG_TRACE ("%s.xdicobjhandle = " FORMAT_REF " [H 360]\n", name,
                          ARGS_REF (xdic));
               break;
             }
           // // DICTIONARY or DICTIONARYWDFLT, but not DICTIONARYVAR
           else if (memBEGINc (name, "DICTIONARY")
                    && strNE (name, "DICTIONARYVAR"))
             {
               add_dictionary_itemhandles (obj, pair, text);
               break;
             }
           else if (pair->code == 360 && // hardowner, not soft
                    (obj->fixedtype == DWG_TYPE_IMAGE
                     || obj->fixedtype == DWG_TYPE_WIPEOUT))
             {
               BITCODE_H ref = dwg_add_handleref (dwg, 3, pair->value.u, obj);
               dwg_dynapi_entity_set_value (_obj, obj->name, "imagedefreactor",
                                            ref, 0);
               LOG_TRACE ("%s.imagedefreactor = " FORMAT_REF " [H %d]\n", name,
                          ARGS_REF (ref), pair->code);
               break;
             }
           // fall through
         case 340:
           if (pair->code == 340 && strEQc (name, "GROUP"))
             {
               Dwg_Object_GROUP *o = obj->tio.object->tio.GROUP;
               BITCODE_H hdl = dwg_add_handleref (dwg, 5, pair->value.u, obj);
               LOG_TRACE ("GROUP.groups[%d] = " FORMAT_REF " [H* 340]\n",
                          o->num_groups, ARGS_REF (hdl));
               o->groups = (BITCODE_H *)realloc (
                   o->groups, (o->num_groups + 1) * sizeof (BITCODE_H));
               o->groups[o->num_groups] = hdl;
               o->num_groups++;
               break;
             }
           // fall through
         case 341:
           if (pair->code == 341 && strEQc (name, "VIEWPORT"))
             {
               Dwg_Entity_VIEWPORT *o = obj->tio.entity->tio.VIEWPORT;
               int code = dwg->header.version >= R_2004 ? 4 : 5;
               BITCODE_H hdl
                   = dwg_add_handleref (dwg, code, pair->value.u, obj);
               LOG_TRACE ("VIEWPORT.frozen_layers[%d] = " FORMAT_REF
                          " [H* 341]\n",
                          o->num_frozen_layers, ARGS_REF (hdl));
               o->frozen_layers = (BITCODE_H *)realloc (
                   o->frozen_layers,
                   (o->num_frozen_layers + 1) * sizeof (BITCODE_H));
               o->frozen_layers[o->num_frozen_layers] = hdl;
               o->num_frozen_layers++;
               break;
             }
           // fall through
         case 2:
           if (ctrl_id && pair->code == 2)
             {
               dwg_dynapi_entity_set_value (_obj, obj->name, "name",
                                            &pair->value, 1);
               LOG_TRACE ("%s.name = %s [T 2]\n", name, pair->value.s);
               if (!pair->value.s)
                 break;
               assert (i_p); // needs ctrl_id
               *i_p = i + 1;
               if (strEQc (name, "BLOCK_RECORD"))
                 {
                   // seperate mspace and pspace into its own fields
                   Dwg_Object_BLOCK_CONTROL *_ctrl
                       = ctrl->tio.object->tio.BLOCK_CONTROL;
                   if (!strcasecmp (pair->value.s, "*Paper_Space"))
                     {
                       const char *f = "paper_space";
                       _ctrl->paper_space
                           = dwg_add_handleref (dwg, 3, obj->handle.value, obj);
                       LOG_TRACE ("%s.%s = " FORMAT_REF " [H 0]\n", ctrlname, f,
                                  ARGS_REF (_ctrl->paper_space));
                       dwg->header_vars.BLOCK_RECORD_PSPACE
                           = dwg_add_handleref (dwg, 5, obj->handle.value, obj);
                       // move out of entries
                       if (move_out_BLOCK_CONTROL (obj, _ctrl, f))
                         *i_p = i;
                     }
                   else if (!strcasecmp (pair->value.s, "*Model_Space"))
                     {
                       const char *f = "model_space";
                       _ctrl->model_space
                           = dwg_add_handleref (dwg, 3, obj->handle.value, obj);
                       LOG_TRACE ("%s.%s = " FORMAT_REF " [H 0]\n", ctrlname, f,
                                  ARGS_REF (_ctrl->model_space));
                       dwg->header_vars.BLOCK_RECORD_MSPACE
                           = dwg_add_handleref (dwg, 5, obj->handle.value, obj);
                       // move out of entries
                       if (move_out_BLOCK_CONTROL (obj, _ctrl, f))
                         *i_p = i;
                     }
                 }
               else if (strEQc (name, "LTYPE"))
                 {
                   // seperate bylayer and byblock into its own fields
                   Dwg_Object_LTYPE_CONTROL *_ctrl
                       = ctrl->tio.object->tio.LTYPE_CONTROL;
                   if (!strcasecmp (pair->value.s, "ByLayer"))
                     {
                       const char *f = "bylayer";
                       _ctrl->bylayer
                           = dwg_add_handleref (dwg, 3, obj->handle.value, obj);
                       LOG_TRACE ("%s.%s = " FORMAT_REF " [H 0]\n", ctrlname, f,
                                  ARGS_REF (_ctrl->bylayer));
                       dwg->header_vars.LTYPE_BYLAYER
                           = dwg_add_handleref (dwg, 5, obj->handle.value, obj);
                       // move out of entries
                       if (move_out_LTYPE_CONTROL (obj, _ctrl, f))
                         *i_p = i;
                     }
                   else if (!strcasecmp (pair->value.s, "ByBlock"))
                     {
                       const char *f = "byblock";
                       _ctrl->byblock
                           = dwg_add_handleref (dwg, 3, obj->handle.value, obj);
                       LOG_TRACE ("%s.%s = " FORMAT_REF " [H 0]\n", ctrlname, f,
                                  ARGS_REF (_ctrl->byblock));
                       dwg->header_vars.LTYPE_BYBLOCK
                           = dwg_add_handleref (dwg, 5, obj->handle.value, obj);
                       // move out of entries
                       if (move_out_LTYPE_CONTROL (obj, _ctrl, f))
                         *i_p = i;
                     }
                 }
               break;
             }
           if (pair->code == 2 && strEQc (name, "MLINE"))
             {
               // ignore name of mlinestyle, already set by ->mlinestyle
               break;
             }
           if (pair->code == 2 && dwg_obj_is_3dsolid (obj))
             {
               BITCODE_BL revision_major;
               BITCODE_BS revision_minor1;
               BITCODE_BS revision_minor2;
               BITCODE_RC revision_bytes[9];
               // no malloc, it is copied into the dwg. but it needs to be large
               // enough, pair->value.s might be smaller on corrupt DXF's. Also
               // we null-terminate it.
               char revision_guid[39];
               char *p = &revision_guid[0];
               unsigned u[3];
               if (!pair->value.s)
                 {
                   LOG_ERROR ("Invalid %s.revision_guid %s", obj->name,
                              revision_guid);
                   break;
                 }
               // "{00000100-0100-00CA-D300-80010A7B10C3}"
               strncpy (revision_guid, pair->value.s, 38);
               revision_guid[38] = '\0';
               if (!dwg_dynapi_entity_set_value (
                       _obj, obj->name, "revision_guid[39]", revision_guid, 0))
                 break;
               if (revision_guid[0] != '{' ||  /* 8 */
                   revision_guid[9] != '-' ||  /* 4 */
                   revision_guid[14] != '-' || /* 4 */
                   revision_guid[19] != '-' || /* 4 */
                   revision_guid[24] != '-' || /* 12 */
                   revision_guid[37] != '}')
                 {
                   LOG_ERROR ("Invalid %s.revision_guid %s", obj->name,
                              revision_guid);
                   break;
                 }
               sscanf (p, "{%8" PRIx32 "-%4X-%4X-%4X-", &revision_major, &u[0],
                       &u[1], &u[2]);
               revision_minor1 = (BITCODE_BS)u[0];
               revision_minor2 = (BITCODE_BS)u[1];
               p += 20;
               sscanf (p, SCANF_2X, &revision_bytes[0]);
               p += 2;
               sscanf (p, SCANF_2X, &revision_bytes[1]);
               p += 3;
               for (int _i = 2; _i < 8; _i++)
                 {
                   sscanf (p, SCANF_2X, &revision_bytes[_i]);
                   p += 2;
                 }
               revision_bytes[8]
                   = '\0'; // insist on an ending 0 byte, even if never used.
               dwg_dynapi_entity_set_value (_obj, obj->name, "revision_major",
                                            &revision_major, 0);
               dwg_dynapi_entity_set_value (_obj, obj->name, "revision_minor1",
                                            &revision_minor1, 0);
               dwg_dynapi_entity_set_value (_obj, obj->name, "revision_minor2",
                                            &revision_minor2, 0);
               dwg_dynapi_entity_set_value (
                   _obj, obj->name, "revision_bytes[9]", revision_bytes, 0);
               break;
             }
           // fall through
         case 70:
           if (ctrl_id && pair->code == 70)
             {
               BITCODE_B bit;
               ;
               flag = pair->value.i | 64;
               dwg_dynapi_entity_set_value (_obj, obj->name, "flag", &flag, 1);
               LOG_TRACE ("%s.flag = %d [RC 70]\n", name, pair->value.i);
               if (obj->fixedtype == DWG_TYPE_STYLE)
                 {
 
 #define SET_CTRL_BIT(b, bnam)                                                 \
   bit = flag & b ? 1 : 0;                                                     \
   if (bit)                                                                    \
     {                                                                         \
       dwg_dynapi_entity_set_value (_obj, obj->name, #bnam, &bit, 1);          \
       LOG_TRACE ("%s.%s = %d [B]\n", name, #bnam, bit);                       \
     }
 
                   SET_CTRL_BIT (1, is_vertical);
                   SET_CTRL_BIT (4, is_shape);
                 }
               else if (obj->fixedtype == DWG_TYPE_LAYER)
                 {
                   SINCE (R_2000)
                   {
                     SET_CTRL_BIT (1, frozen);
                     bit = flag & 2 ? 0 : 1; // reverse
                     if (bit)
                       {
                         dwg_dynapi_entity_set_value (_obj, obj->name, "on",
                                                      &bit, 1);
                         LOG_TRACE ("%s.%s = %d [B]\n", name, "on", bit);
                       }
                     SET_CTRL_BIT (4, frozen_in_new);
                     SET_CTRL_BIT (8, locked);
                     SET_CTRL_BIT (32768, plotflag);
                   }
                   else
                   {
                     SET_CTRL_BIT (1, frozen);
                     SET_CTRL_BIT (2, frozen_in_new);
                     SET_CTRL_BIT (4, locked);
                   }
                 }
               else if (obj->fixedtype == DWG_TYPE_BLOCK_HEADER)
                 {
                   SET_CTRL_BIT (1, anonymous);
                   SET_CTRL_BIT (2, hasattrs);
                   SET_CTRL_BIT (4, blkisxref);
                   SET_CTRL_BIT (8, xrefoverlaid);
                   SET_CTRL_BIT (32, loaded_bit);
                 }
               else if (obj->fixedtype == DWG_TYPE_VIEW)
                 {
                   SET_CTRL_BIT (1, is_pspace);
                 }
               else if (obj->fixedtype == DWG_TYPE_DIMSTYLE)
                 {
                   SET_CTRL_BIT (1, flag0);
                 }
               else if (obj->fixedtype == DWG_TYPE_VX_TABLE_RECORD)
                 {
                   // also set via 290
                   SET_CTRL_BIT (2, is_on);
                 }
               break;
             }
           else if (pair->code == 70 && obj->fixedtype == DWG_TYPE_LAYOUT)
             {
               Dwg_Object_LAYOUT *o = obj->tio.object->tio.LAYOUT;
               if (strEQc (subclass,
                           "AcDbPlotSettings")) // todo: embedded struct
                 {
                   o->plotsettings.plot_flags = pair->value.i;
                   LOG_TRACE ("LAYOUT.plotsettings.plot_flags = 0x%x [BSx 70]",
                              pair->value.i);
                 }
               else if (strEQc (subclass, "AcDbLayout"))
                 {
                   o->layout_flags = pair->value.u;
                   LOG_TRACE ("LAYOUT.layout_flags = 0x%x [BSx 70]",
                              pair->value.u);
                 }
               else
                 {
                   LOG_WARN ("Unhandled LAYOUT.70 in subclass %s", subclass);
                   o->layout_flags = pair->value.u;
                   LOG_TRACE ("LAYOUT.layout_flags = 0x%x [BSx 70]",
                              pair->value.u);
                 }
               break;
             }
           else if (pair->code == 70 && obj->fixedtype == DWG_TYPE_LWPOLYLINE)
             {
               Dwg_Entity_LWPOLYLINE *o = obj->tio.entity->tio.LWPOLYLINE;
               o->flag = pair->value.i;
               // 1 => 512 closed
               // 128: plinegen
               if (o->flag & 1)
                 o->flag = (o->flag - 1) + 512;
               LOG_TRACE ("LWPOLYLINE.flag => %d [BS 70]\n", flag);
               break;
             }
           else if (pair->code == 70
                    && strEQc (subclass, "AcDbModelDocViewStyle"))
             {
               BITCODE_BS ver = pair->value.i;
               LOG_TRACE ("%s.mdoc_class_version = %d [BS %d]\n", name,
                          pair->value.i, pair->code);
               dwg_dynapi_entity_set_value (_obj, obj->name,
                                            "mdoc_class_version", &ver, is_tu);
               break;
             }
           else if (pair->code == 70
                    && (strEQc (subclass, "AcDbSectionViewStyle")
                        || strEQc (subclass, "AcDbDetailViewStyle")))
             {
               BITCODE_BS ver = pair->value.i;
               LOG_TRACE ("%s.class_version = %d [BS %d]\n", name,
                          pair->value.i, pair->code);
               dwg_dynapi_entity_set_value (_obj, obj->name, "class_version",
                                            &ver, is_tu);
               break;
             }
           else if (pair->code == 70
                    && obj->fixedtype == DWG_TYPE_DIMENSION_ANG2LN)
             {
               Dwg_Entity_DIMENSION_ANG2LN *o
                   = obj->tio.entity->tio.DIMENSION_ANG2LN;
               o->flag = o->flag1 = pair->value.i;
               LOG_TRACE ("DIMENSION.flag = %d [RC 70]\n", pair->value.i);
               o->flag1 &= 0xE0; /* clear the upper flag bits, and fix them: */
               o->flag1 = (o->flag1 & 0x80) ? o->flag1 & 0x7F : o->flag1 | 1;
               o->flag1 = (o->flag1 & 0x20) ? o->flag1 | 2 : o->flag1 & 0xDF;
               LOG_TRACE ("DIMENSION.flag1 => %d [RC]\n", o->flag1);
               // Skip this flag logic, it is unreliable. Detecting subclasses
               // is far better.
               switch (o->flag & 31)
                 {
                 case 0: // rotated, horizontal or vertical
                   LOG_TRACE ("Looks like %s\n", "DIMENSION_LINEAR");
                   // UPGRADE_ENTITY (DIMENSION_ANG2LN, DIMENSION_LINEAR);
                   break;
                 case 1:
                   LOG_TRACE ("Looks like %s\n", "DIMENSION_ALIGNED");
                   // UPGRADE_ENTITY (DIMENSION_ANG2LN, DIMENSION_ALIGNED);
                   break;
                 case 2: // already?
                   LOG_TRACE ("Looks like %s\n", "DIMENSION_ANG2LN");
                   // UPGRADE_ENTITY (DIMENSION_ANG2LN, DIMENSION_ANG2LN);
                   break;
                 case 3:
                   LOG_TRACE ("Looks like %s\n", "DIMENSION_DIAMETER");
                   // UPGRADE_ENTITY (DIMENSION_ANG2LN, DIMENSION_DIAMETER);
                   break;
                 case 4:
                   LOG_TRACE ("Looks like %s\n", "DIMENSION_RADIUS");
                   // UPGRADE_ENTITY (DIMENSION_ANG2LN, DIMENSION_RADIUS);
                   break;
                 case 5:
                   LOG_TRACE ("Looks like %s\n", "DIMENSION_ANG3PT");
                   // UPGRADE_ENTITY (DIMENSION_ANG2LN, DIMENSION_ANG3PT);
                   break;
                 case 6:
                   LOG_TRACE ("Looks like DIMENSION_LINEAR\n");
                   // UPGRADE_ENTITY (DIMENSION_ANG2LN, DIMENSION_ORDINATE);
                   break;
                 default:
                   LOG_ERROR ("Invalid DIMENSION.flag %d", o->flag & 31);
                   error |= DWG_ERR_INVALIDTYPE;
                   break;
                 }
               break;
             }
           // fall through
         case 420: // color.rgb's
         case 421:
         case 422:
         case 423:
         case 424:
         case 425:
         case 426:
         case 427:
         case 428:
           // note that there is a DIMSTYLE.DIMTFILL with rgb 428. so far I only
           // found index 70, not rgb 428
           if (pair->code >= 420 && pair->code <= 428)
             {
               const char *fname = NULL;
               if (pair->code == 420 && strEQc (name, "LAYER"))
                 fname = "color";
               else if (pair->code == 421 && strEQc (name, "LIGHT"))
                 fname = "color";
               else if (pair->code == 421
                        && (strEQc (name, "VPORT") || strEQc (name, "VIEWPORT")
                            || strEQc (name, "VIEW")))
                 fname = "ambient_color";
               else if (pair->code == 421 && strEQc (name, "MTEXT"))
                 fname = "bg_fill_color";
               else if (pair->code == 420 && strEQc (name, "MLINESTYLE"))
                 // TODO or lines[].color
                 fname = "fill_color";
               else if (pair->code == 420 && strEQc (name, "VISUALSTYLE"))
                 break; // ignore. always index 5
               else if (pair->code == 421 && strEQc (name, "VISUALSTYLE"))
                 fname = "face_mono_color";
               else if (pair->code == 422 && strEQc (name, "VISUALSTYLE"))
                 fname = "edge_intersection_color";
               else if (pair->code == 423 && strEQc (name, "VISUALSTYLE"))
                 fname = "edge_obscured_color";
               else if (pair->code == 424 && strEQc (name, "VISUALSTYLE"))
                 fname = "edge_color";
               else if (pair->code == 425 && strEQc (name, "VISUALSTYLE"))
                 fname = "edge_silhouette_color";
               else if (pair->code == 428 && strEQc (name, "DIMSTYLE"))
                 fname = "DIMTFILL";
               else if (strEQc (name, "TABLE"))
                 {
                   BITCODE_BL table_flag
                       = obj->tio.entity->tio.TABLE->table_flag_override;
                   BITCODE_BL border_color = obj->tio.entity->tio.TABLE
                                                 ->border_color_overrides_flag;
                   if (pair->code == 421)
                     {
                       if (table_flag & 0x0800)
                         fname = "title_row_fill_color";
                       else if (table_flag & 0x01000)
                         fname = "header_row_fill_color";
                       else if (table_flag & 0x02000)
                         fname = "data_row_fill_color";
                       else if (border_color & 0x0008)
                         fname = "title_vert_left_color";
                       else if (border_color & 0x0200)
                         fname = "header_vert_left_color";
                       else if (border_color & 0x8000)
                         fname = "data_vert_left_color";
                     }
                   else if (pair->code == 422)
                     {
                       if (table_flag & 0x0020)
                         fname = "title_row_color";
                       else if (table_flag & 0x0040)
                         fname = "header_row_color";
                       else if (table_flag & 0x0080)
                         fname = "data_row_color";
                       else if (border_color & 0x0001)
                         fname = "title_horiz_top_color";
                       else if (border_color & 0x0040)
                         fname = "header_horiz_top_color";
                       else if (border_color & 0x1000)
                         fname = "data_horiz_top_color";
                     }
                   else if (pair->code == 423)
                     {
                       if (border_color & 0x0002)
                         fname = "title_horiz_ins_color";
                       else if (border_color & 0x0080)
                         fname = "header_horiz_ins_color";
                       else if (border_color & 0x2000)
                         fname = "data_horiz_ins_color";
                     }
                   else if (pair->code == 424)
                     {
                       if (border_color & 0x0004)
                         fname = "title_horiz_bottom_color";
                       else if (border_color & 0x0100)
                         fname = "header_horiz_bottom_color";
                       else if (border_color & 0x4000)
                         fname = "data_horiz_bottom_color";
                     }
                   else if (pair->code == 426)
                     {
                       if (border_color & 0x0010)
                         fname = "title_vert_ins_color";
                       else if (border_color & 0x0400)
                         fname = "header_vert_ins_color";
                       else if (border_color & 0x10000)
                         fname = "data_vert_ins_color";
                     }
                   else if (pair->code == 427)
                     {
                       if (border_color & 0x0020)
                         fname = "title_vert_right_color";
                       else if (border_color & 0x0800)
                         fname = "header_vert_right_color";
                       else if (border_color & 0x20000)
                         fname = "data_vert_right_color";
                     }
                 }
 
               if (fname)
                 {
                   BITCODE_CMC color;
                   dwg_dynapi_entity_value (_obj, obj->name, fname, &color,
                                            NULL);
                   color.method = 0xc2;
                   color.rgb = pair->value.l;
                   color.rgb |= 0xc2000000;
                   LOG_TRACE ("%s.%s.rgb = %08X [CMC %d]\n", name, fname,
                              color.rgb, pair->code);
                   dwg_dynapi_entity_set_value (_obj, obj->name, fname, &color,
                                                is_tu);
                   break;
                 }
             }
           // fall through
         default:
         object_default:
           if (pair->code >= 1000 && pair->code < 1999)
             add_eed (obj, obj->name, pair);
           else if (pair->code != 280 && strEQc (name, "XRECORD"))
             pair = add_xdata (dat, obj, pair);
           else if (pair->code == 310 && strEQc (obj->name, "BLOCK_HEADER"))
             {
               pair = add_block_preview (obj, dat, pair);
               goto start_loop;
             }
           else if (pair->code == 90 && obj->fixedtype == DWG_TYPE_OLE2FRAME)
             {
               Dwg_Entity_OLE2FRAME *o = obj->tio.entity->tio.OLE2FRAME;
               o->data_size = pair->value.l;
               o->data = (BITCODE_RC *)xcalloc (pair->value.l, 1);
               if (!o->data)
                 {
                   o->data_size = 0;
                   goto invalid_dxf;
                 }
               LOG_TRACE ("OLE2FRAME.data_size = %ld [BL 90]\n", pair->value.l);
             }
           else if (pair->code == 90 && obj->fixedtype == DWG_TYPE_PERSUBENTMGR)
             {
               pair = add_PERSUBENTMGR (obj, dat, pair); // NULL for success
               if (!pair)
                 goto next_pair;
               else
                 goto start_loop; /* failure */
             }
           else if ((pair->code == 71 || pair->code == 75 || pair->code == 1)
                    && obj->fixedtype == DWG_TYPE_DIMASSOC)
             {
               pair = add_DIMASSOC (obj, dat, pair);
               // returns with 0
               if (pair != NULL && pair->code == 0)
                 goto start_loop;
               else
                 goto search_field;
             }
           else if ((pair->code == 8 || pair->code == 90)
                    && obj->fixedtype == DWG_TYPE_LAYER_INDEX)
             {
               pair = add_LAYER_entry (obj, dat, pair);
               // returns with 0
               if (pair != NULL && pair->code == 0)
                 goto start_loop;
               else
                 goto search_field;
             }
           else if (pair->code == 91 && obj->fixedtype == DWG_TYPE_EVALUATION_GRAPH)
             {
               pair = add_EVAL_Node (obj, dat, pair);
               // returns with 0
               if (pair != NULL && pair->code == 0)
                 goto start_loop;
               else
                 goto search_field;
             }
           else if (pair->code == 310 && obj->fixedtype == DWG_TYPE_OLE2FRAME)
             {
               Dwg_Entity_OLE2FRAME *o = obj->tio.entity->tio.OLE2FRAME;
               unsigned len = strlen (pair->value.s);
               unsigned blen = len / 2;
               unsigned read;
               //const char *pos = pair->value.s;
               unsigned char *s = (unsigned char *)&o->data[written];
               assert (o->data);
               if (blen + written > o->data_size)
                 {
                   LOG_ERROR ("OLE2FRAME.data overflow: %u + written %u > "
                              "data_size: %u",
                              blen, written, o->data_size);
                   goto invalid_dxf;
                 }
               if ((read = in_hex2bin (s, pair->value.s, blen) != blen))
                 LOG_ERROR ("in_hex2bin read only %u of %u", read, blen);
               written += read;
               LOG_TRACE ("OLE2FRAME.data += %u (%u/%u) [TF 310]\n", blen,
                          written, o->data_size);
             }
           else if (pair->code == 1
                    && ((strEQc (name, "_3DSOLID") || strEQc (name, "BODY")
                         || strEQc (name, "REGION"))
                        || strEQc (subclass, "AcDbModelerGeometry")))
             {
               j = 0;
               k = 0;
               // check if the object is valid
               if (!dwg_obj_is_3dsolid (obj))
                 {
                   LOG_ERROR ("%s not a 3DSOLID", name);
                   goto invalid_dxf;
                 }
               pair = add_3DSOLID_encr (obj, dat, pair);
               goto start_loop;
             }
           else if (pair->code == 1 && obj->fixedtype == DWG_TYPE_LAYOUT)
             {
               Dwg_Object_LAYOUT *o = obj->tio.object->tio.LAYOUT;
               if (strEQc (subclass, "AcDbPlotSettings"))
                 {
                   const Dwg_DYNAPI_field *f = dwg_dynapi_entity_field (
                       "PLOTSETTINGS", "printer_cfg_file");
                   dwg_dynapi_field_set_value (dwg, &o->plotsettings, f,
                                               &pair->value, 1);
                   LOG_TRACE ("%s.plotsettings.printer_cfg_file = %s [T 1]\n",
                              obj->name, pair->value.s);
                 }
               else if (strEQc (subclass, "AcDbLayout"))
                 {
                   dwg_dynapi_entity_set_value (_obj, obj->name, "layout_name",
                                                &pair->value, 1);
                   LOG_TRACE ("%s.layout_name = %s [T 1]\n", obj->name,
                              pair->value.s);
                 }
               else
                 LOG_WARN ("Unhandled LAYOUT.1 in subclass %s", subclass);
               goto next_pair;
             }
           else if (pair->code == 3 && obj->fixedtype == DWG_TYPE_MTEXT)
             {
               Dwg_Entity_MTEXT *o = obj->tio.entity->tio.MTEXT;
               unsigned len = strlen (pair->value.s);
               if (!o->text)
                 {
                   o->text = strdup (pair->value.s);
                   written = len;
                   LOG_TRACE ("MTEXT.text = %s (%u) [TV 3]\n", pair->value.s, len);
                 }
               else
                 {
                   assert (o->text);
                   if (strlen (o->text) < len)
                     o->text = realloc (o->text, len + 1);
                   strcpy (o->text, pair->value.s);
                   written += len;
                   LOG_TRACE ("MTEXT.text += %u/%u [TV 3]\n", len, written);
                 }
             }
           /*
           else if (pair->code == 2 && obj->fixedtype == DWG_TYPE_LAYOUT)
             {
               Dwg_Object_LAYOUT *o = obj->tio.object->tio.LAYOUT;
               const Dwg_DYNAPI_field *f = dwg_dynapi_entity_field
           ("PLOTSETTINGS", "paper_size"); dwg_dynapi_field_set_value (dwg,
           &o->plotsettings, f, &pair->value, 1); LOG_TRACE
           ("%s.plotsettings.paper_size = %s [T 2]\n", obj->name,
           pair->value.s); goto next_pair;
             }
           */
           else if (pair->code == 370 && obj->fixedtype == DWG_TYPE_LAYER)
             {
               Dwg_Object_LAYER *layer = obj->tio.object->tio.LAYER;
               layer->linewt = dxf_find_lweight (pair->value.i);
               LOG_TRACE ("LAYER.linewt = %d\n", layer->linewt);
               layer->flag |= layer->linewt << 5;
               LOG_TRACE ("LAYER.flag = 0x%x [BS 70]\n", layer->flag);
               goto next_pair;
             }
           else if (pair->code == 370 && obj->supertype == DWG_SUPERTYPE_ENTITY
                    && strEQc (subclass, "AcDbEntity"))
             {
               BITCODE_RC linewt = dxf_find_lweight (pair->value.i);
               dwg_dynapi_common_set_value (_obj, "linewt", &linewt, 0);
               LOG_TRACE ("COMMON.linewt => %d [RC 370]\n", linewt);
               goto next_pair;
             }
           else if (pair->code == 48 && obj->supertype == DWG_SUPERTYPE_ENTITY
                    && strEQc (subclass, "AcDbEntity"))
             {
               dwg_dynapi_common_set_value (_obj, "ltype_scale", &pair->value.d, 0);
               LOG_TRACE ("COMMON.ltype_scale = %f [BD 48]\n", pair->value.d);
               goto next_pair;
             }
           else if (pair->code == 49 && obj->fixedtype == DWG_TYPE_LTYPE)
             {
               pair = add_LTYPE_dashes (obj, dat, pair);
               if (pair != NULL && pair->code == 0)
                 return pair;
               goto next_pair;
             }
           else if (pair->code == 71 && obj->fixedtype == DWG_TYPE_MLINESTYLE
                    && pair->value.i != 0)
             {
               pair = add_MLINESTYLE_lines (obj, dat, pair);
               if (pair != NULL && pair->code == 0)
                 return pair;
               goto next_pair;
             }
           else if (pair->code == 65 && obj->fixedtype == DWG_TYPE_VPORT)
             {
               Dwg_Object_VPORT *o = obj->tio.object->tio.VPORT;
               o->UCSVP = pair->value.i;
               o->UCSFOLLOW = o->VIEWMODE & 4 ? 1 : 0;
               o->VIEWMODE |= o->UCSVP;
               LOG_TRACE ("VPORT.UCSVP = %d [B 65]\n", o->UCSVP)
               LOG_TRACE ("VPORT.UCSFOLLOW => %d [B 0] (calc)\n", o->UCSFOLLOW)
               LOG_TRACE ("VPORT.VIEWMODE => %d [4BITS 71] (calc)\n",
                          o->VIEWMODE)
               goto next_pair;
             }
           else if (pair->code == 90 && obj->fixedtype == DWG_TYPE_LWPOLYLINE)
             {
               pair = new_LWPOLYLINE (obj, dat, pair);
               if (pair != NULL && pair->code == 0)
                 return pair;
               goto next_pair;
             }
           else if (pair->code == 350 && strEQc (subclass, "AcDb3dSolid")
                    && dwg_obj_is_3dsolid (obj))
             {
               Dwg_Entity__3DSOLID *o = obj->tio.entity->tio._3DSOLID;
               BITCODE_H hdl = dwg_add_handleref (dwg, 5, pair->value.u, obj);
               LOG_TRACE ("%s.history_id = " FORMAT_REF " [H 350]\n", obj->name,
                          ARGS_REF (hdl));
               o->history_id = hdl;
             }
           else if (obj->fixedtype == DWG_TYPE_MLINE)
             {
               int status = add_MLINE (obj, dat, pair, &j, &k, &l);
               if (status == 0)
                 goto search_field;
               else if (status == 2)
                 break;
             }
           else if (strEQc (name, "VERTEX_PFACE_FACE") && pair->code >= 71
                    && pair->code <= 74)
             {
               Dwg_Entity_VERTEX_PFACE_FACE *o
                   = (Dwg_Entity_VERTEX_PFACE_FACE *)_obj;
               j = pair->code - 71;
               o->vertind[j] = pair->value.i;
               LOG_TRACE ("VERTEX_PFACE_FACE.vertind[%d] = %d [BS %d]\n", j,
                          pair->value.i, pair->code);
             }
           else if (obj->fixedtype == DWG_TYPE_SPLINE)
             {
               if (pair->code == 210 || pair->code == 220 || pair->code == 230)
                 break; // ignore extrusion in the dwg (planar only)
               if (add_SPLINE (obj->tio.entity->tio.SPLINE, dat, pair, &j,
                               &flag))
                 goto next_pair;
               else
                 goto search_field;
             }
           else if (obj->fixedtype == DWG_TYPE_HATCH)
             {
               if ((pair->code == 10 || pair->code == 20) && pair->value.d == 0.0)
                 break; // elevation
               else if (pair->code == 91 || pair->code == 78
                        || pair->code == 453)
                 {
                   pair = add_HATCH (obj, dat, pair);
                   if (!pair || pair->code == 0) // end or unknown
                     return pair;
                   goto search_field;
                 }
               else
                 goto search_field;
             }
           else if (is_textlike (obj))
             {
               BITCODE_RC dataflags;
               if (pair->code == 10 || pair->code == 20)
                 goto search_field;
               else if (pair->code == 30 && pair->value.d == 0.0)
                 {
                   dwg_dynapi_entity_value (_obj, obj->name, "dataflags",
                                            &dataflags, NULL);
                   dataflags |= 1;
                   LOG_TRACE ("%s.elevation 0.0 => dataflags = 0x%x\n",
                              obj->name, dataflags);
                   dwg_dynapi_entity_set_value (_obj, obj->name, "dataflags",
                                                &dataflags, 0);
                 }
               else
                 goto search_field;
             }
           else if (obj->fixedtype == DWG_TYPE_MESH)
             {
               if (pair->code == 91)
                 {
                   pair = add_MESH (obj, dat, pair);
                   if (!pair || pair->code == 0) // end or unknown
                     return pair;
                   goto search_field;
                 }
               else
                 goto search_field;
             }
           else if (obj->fixedtype == DWG_TYPE_MLEADERSTYLE)
             {
               Dwg_Object_MLEADERSTYLE *o = obj->tio.object->tio.MLEADERSTYLE;
               if (pair->code == 47)
                 o->block_scale.x = pair->value.d;
               else if (pair->code == 49)
                 o->block_scale.y = pair->value.d;
               else if (pair->code == 140)
                 {
                   o->block_scale.z = pair->value.d;
                   LOG_TRACE (
                       "MLEADERSTYLE.block_scale = (%f, %f, %f) [3BD 47]\n",
                       o->block_scale.x, o->block_scale.y, o->block_scale.z);
                 }
               else if (pair->code == 297 && o->class_version < 2)
                 {
                   LOG_TRACE ("MLEADERSTYLE.text_always_left = %d [B 297] => "
                              "class_version 2\n",
                              pair->value.i);
                   o->text_always_left = pair->value.i;
                   o->class_version = 2;
                 }
               else
                 goto search_field;
             }
           else if (obj->fixedtype == DWG_TYPE_MTEXT && pair->code == 46)
             {
               Dwg_Entity_MTEXT *o = obj->tio.entity->tio.MTEXT;
               if (!o->num_column_heights)
                 o->num_column_heights = 1;
               if (!j)
                 {
                   o->column_heights = (BITCODE_BD *)xcalloc (
                       o->num_column_heights, sizeof (BITCODE_BD));
                   if (!o->column_heights)
                     {
                       o->num_column_heights = 0;
                       goto invalid_dxf;
                     }
                 }
               if (j < 0 || j >= (int)o->num_column_heights
                   || !o->column_heights)
                 goto invalid_dxf;
               assert (j < (int)o->num_column_heights);
               o->column_heights[j] = pair->value.d;
               LOG_TRACE ("MTEXT.column_heights[%d] = %f [BD* 46]\n", j,
                          pair->value.d);
             }
           else if (obj->fixedtype == DWG_TYPE_GEODATA)
             {
               pair = add_GEODATA (obj, dat, pair);
               if (pair && pair->code != 0)
                 goto search_field;
               else
                 return pair;
             }
           else if (pair->code == 300 && obj->fixedtype == DWG_TYPE_CELLSTYLEMAP
                    && strEQc (pair->value.s, "CELLSTYLE"))
             {
               Dwg_Object_CELLSTYLEMAP *o = obj->tio.object->tio.CELLSTYLEMAP;
               cur_cell++;
               if (cur_cell < 0 || cur_cell >= (int)o->num_cells)
                 goto invalid_dxf;
             }
           else if (pair->code == 1 && pair->value.s
                    && strEQc (pair->value.s, "TABLEFORMAT_BEGIN")
                    && (obj->fixedtype == DWG_TYPE_CELLSTYLEMAP
                        || obj->fixedtype == DWG_TYPE_TABLE
                        || obj->fixedtype == DWG_TYPE_TABLESTYLE
                        || obj->fixedtype == DWG_TYPE_TABLECONTENT))
             {
               Dwg_CellStyle *csty = NULL;
               Dwg_TABLESTYLE_CellStyle *tbl_sty = NULL;
               char key[80];
               if (obj->fixedtype == DWG_TYPE_CELLSTYLEMAP)
                 {
                   Dwg_Object_CELLSTYLEMAP *o
                       = obj->tio.object->tio.CELLSTYLEMAP;
                   if (cur_cell < 0 || cur_cell >= (int)o->num_cells)
                     goto invalid_dxf;
                   if (cur_cell == 0 && !o->cells)
                     o->cells = (Dwg_TABLESTYLE_CellStyle *)xcalloc (
                         o->num_cells, sizeof (Dwg_TABLESTYLE_CellStyle));
                   tbl_sty = &o->cells[cur_cell];
                   sprintf (key, "cells[%d]", cur_cell);
                   csty = &tbl_sty->cellstyle;
                 }
               else if (obj->fixedtype == DWG_TYPE_TABLESTYLE)
                 {
                   // TODO ovr
                   Dwg_Object_TABLESTYLE *o = obj->tio.object->tio.TABLESTYLE;
                   tbl_sty = &o->sty;
                   csty = &o->sty.cellstyle;
                 }
               if (csty)
                 pair = add_CellStyle (obj, csty, &key[0], dat, pair);
               if (pair && pair->code != 0)
                 {
                   if (tbl_sty && pair->code == 90)
                     {
                       tbl_sty->id = pair->value.u;
                       LOG_TRACE ("%s.%s.id = " FORMAT_BL " [BL %d]\n",
                                  obj->name, key, pair->value.u, pair->code);
                       dxf_free_pair (pair);
                       pair = dxf_read_pair (dat);
                     }
                   if (tbl_sty && pair && pair->code == 91)
                     {
                       tbl_sty->type = pair->value.u;
                       LOG_TRACE ("%s.%s.type = " FORMAT_BL " [BL %d]\n",
                                  obj->name, key, pair->value.u, pair->code);
                       dxf_free_pair (pair);
                       pair = dxf_read_pair (dat);
                     }
                   if (tbl_sty && pair && pair->code == 300)
                     {
                       tbl_sty->name = dwg_add_u8_input (dwg, pair->value.s);
                       LOG_TRACE ("%s.%s.name = \"%s\" [BL %d]\n", obj->name,
                                  key, pair->value.s, pair->code);
                       dxf_free_pair (pair);
                       pair = dxf_read_pair (dat);
                     }
                   if (tbl_sty && pair && pair->code == 309
                       && strEQc (pair->value.s, "CELLSTYLE_END"))
                     goto next_pair;
                   else
                     goto search_field;
                 }
               else
                 return pair;
             }
           else if (obj->fixedtype == DWG_TYPE_VPORT && pair->code == 41)
             {
               Dwg_Object_VPORT *o = obj->tio.object->tio.VPORT;
               o->aspect_ratio = pair->value.d;
               o->view_width = o->aspect_ratio * o->VIEWSIZE;
               LOG_TRACE ("VPORT.aspect_ratio = %f [BD 41]\n", o->aspect_ratio);
               LOG_TRACE ("VPORT.view_width = %f [BD 0]\n", o->view_width);
             }
           else if (strEQc (subclass, "AcDbShHistoryNode"))
             {
               // add_AcDbShHistoryNode (obj, _obj)
               Dwg_ACSH_HistoryNode *hn;
               const Dwg_DYNAPI_field *f1
                   = dwg_dynapi_entity_field (obj->name, "history_node");
               if (!f1)
                 goto search_field;
               hn = (Dwg_ACSH_HistoryNode *)&((char *)_obj)[f1->offset];
               if (pair->code == 90)
                 {
                   hn->major = pair->value.u;
                   LOG_TRACE ("%s.%s.%s = %u [BL %d]\n", name, "history_node",
                              "major", pair->value.u, pair->code);
                 }
               else if (pair->code == 91)
                 {
                   hn->minor = pair->value.u;
                   LOG_TRACE ("%s.%s.%s = %u [BL %d]\n", name, "history_node",
                              "minor", pair->value.u, pair->code);
                 }
               else if (pair->code == 92)
                 {
                   hn->step_id = pair->value.u;
                   LOG_TRACE ("%s.%s.%s = %u [BL %d]\n", name, "history_node",
                              "step_id", pair->value.u, pair->code);
                 }
               else if (pair->code == 62)
                 {
                 hn_color:
                   hn->color.index = pair->value.l;
                   LOG_TRACE ("%s.%s.%s.index = %u [CMC %d]\n", name,
                              "history_node", "color", pair->value.u,
                              pair->code);
                 }
               else if (pair->code == 347)
                 {
                   hn->material
                       = dwg_add_handleref (dwg, 5, pair->value.u, obj);
                   LOG_TRACE ("%s.%s.%s = " FORMAT_REF " [H %d]\n", name,
                              "history_node", "material",
                              ARGS_REF (hn->material), pair->code);
                 }
               else if (hn && pair->code == 40) // VECTOR_N1
                 {
                   hn->trans = (BITCODE_BD *)xcalloc (16, sizeof (BITCODE_BD));
                   if (!hn->trans)
                     return NULL;
                   // BD* starting at 40-55
                   for (j = 0; j < 16; j++)
                     {
                       hn->trans[j] = pair->value.d;
                       LOG_TRACE ("%s.history_node.trans[%d] = %f [BD %d]\n",
                                  obj->name, j, pair->value.d, j + 40);
                       dxf_free_pair (pair);
                       pair = dxf_read_pair (dat);
                       if (!pair || pair->code == 0)
                         return pair;
                       if (pair->code == 62)
                         goto hn_color;
                       if (pair->code != j + 41)
                         goto search_field;
                     }
                 }
             }
           else if (dwg_obj_is_acsh (obj) && memBEGINc (subclass, "AcDbSh")
                    && (pair->code == 90 || pair->code == 91))
             {
               const char *_key = pair->code == 90 ? "major" : "minor";
               const Dwg_DYNAPI_field *f1
                   = dwg_dynapi_entity_field (obj->name, _key);
               if (!f1)
                 goto search_field;
               dwg_dynapi_field_set_value (dwg, _obj, f1, &pair->value, 0);
               LOG_TRACE ("%s.%s = %u [BL %d]\n", name, _key, pair->value.u,
                          pair->code);
             }
           else if (strEQc (subclass, "AcDbEvalExpr"))
             {
               pair = add_AcDbEvalExpr (obj, (char *)_obj, dat, pair);
               if (pair && pair->code == 100) // success
                 goto start_loop;
               else
                 goto search_field;
             }
           else if (obj->fixedtype == DWG_TYPE_LEADER
                    && (pair->code == 10 || pair->code == 20
                        || pair->code == 30))
             {
               Dwg_Entity_LEADER *o = obj->tio.entity->tio.LEADER;
               if (!j && pair->code == 10)
                 {
                   o->points = (BITCODE_3BD *)xcalloc (o->num_points,
                                                       sizeof (BITCODE_3BD));
                   if (!o->points)
                     {
                       o->num_points = 0;
                       goto invalid_dxf;
                     }
                 }
               if (j < 0 || j >= (int)o->num_points || !o->points)
                 goto invalid_dxf;
               assert (j >= 0);
               assert (j < (int)o->num_points);
               assert (o->points);
 
               if (pair->code == 10)
                 o->points[j].x = pair->value.d;
               else if (pair->code == 20)
                 o->points[j].y = pair->value.d;
               else if (pair->code == 30)
                 {
                   o->points[j].z = pair->value.d;
                   LOG_TRACE ("LEADER.points[%d] = (%f, %f, %f) [3BD* 10]\n", j,
                              o->points[j].x, o->points[j].y, o->points[j].z);
                   j++;
                 }
             }
           else if (pair->code == 71
                    && strEQc (subclass, "AcDbSectionViewStyle"))
             {
               pair = add_AcDbSectionViewStyle (obj, dat);
               if (!pair) // success
                 goto start_loop;
               else
                 goto search_field;
             }
           else if (pair->code == 71
                    && strEQc (subclass, "AcDbDetailViewStyle")
                    && obj->fixedtype == DWG_TYPE_DETAILVIEWSTYLE)
             {
               pair = add_AcDbDetailViewStyle (obj, dat);
               if (pair && pair->code == 100) // success
                 goto start_loop;
               else
                 goto search_field;
             }
           else if (pair->code == 300 && strEQc (subclass, "AcDbBlockElement"))
             {
               pair = add_AcDbBlockElement (obj, (char *)_obj, dat, pair);
               if (!pair) // success
                 goto start_loop;
               else
                 goto search_field;
             }
           else if (pair->code == 91 && strEQc (subclass, "AcDbBlockgrip"))
             {
               pair = add_AcDbBlockGrip (obj, (char *)_obj, dat, pair);
               if (!pair) // success
                 goto start_loop;
               else
                 goto search_field;
             }
           else if (pair->code == 93 && strEQc (subclass, "AcDbBlockVisibilityParameter"))
             {
               pair = add_AcDbBlockVisibilityParameter (
                   obj, (Dwg_Object_BLOCKVISIBILITYPARAMETER *)_obj, dat, pair);
               if (!pair) // success
                 goto start_loop;
               else
                 goto search_field;
             }
           else if (pair->code == 307
                    && strEQc (subclass, "AcDbBlockLinearConstraintParameter"))
             {
               Dwg_BLOCKPARAMVALUESET *value_set
                   = &((Dwg_Object_BLOCKALIGNEDCONSTRAINTPARAMETER *)_obj)
                          ->value_set;
               pair = add_AcDbBlockParamValueSet (obj, value_set, dat, pair);
               if (!pair) // success
                 goto start_loop;
               else
                 goto search_field;
             }
           else if (pair->code == 307 && strEQc (obj->name, "BLOCKLINEARPARAMETER"))
             {
               Dwg_BLOCKPARAMVALUESET *value_set
                   = &((Dwg_Object_BLOCKLINEARPARAMETER *)_obj)
                          ->value_set;
               pair = add_AcDbBlockParamValueSet (obj, value_set, dat, pair);
               if (!pair) // success
                 goto start_loop;
               else
                 goto search_field;
             }
           else if (pair->code == 307 && strEQc (obj->name, "BLOCKROTATIONPARAMETER"))
             {
               Dwg_BLOCKPARAMVALUESET *value_set
                   = &((Dwg_Object_BLOCKROTATIONPARAMETER *)_obj)
                          ->angle_value_set;
               pair = add_AcDbBlockParamValueSet (obj, value_set, dat, pair);
               if (!pair) // success
                 goto start_loop;
               else
                 goto search_field;
             }
           else if (pair->code == 307 && strEQc (obj->name, "BLOCKANGULARCONSTRAINTPARAMETER"))
             {
               Dwg_BLOCKPARAMVALUESET *value_set
                   = &((Dwg_Object_BLOCKANGULARCONSTRAINTPARAMETER *)_obj)
                          ->value_set;
               pair = add_AcDbBlockParamValueSet (obj, value_set, dat, pair);
               if (!pair) // success
                 goto start_loop;
               else
                 goto search_field;
             }
           else if (pair->code == 307 && strEQc (obj->name, "BLOCKDIAMETRICCONSTRAINTPARAMETER"))
             {
               Dwg_BLOCKPARAMVALUESET *value_set
                   = &((Dwg_Object_BLOCKDIAMETRICCONSTRAINTPARAMETER *)_obj)
                          ->value_set;
               pair = add_AcDbBlockParamValueSet (obj, value_set, dat, pair);
               if (!pair) // success
                 goto start_loop;
               else
                 goto search_field;
             }
           else if (pair->code == 307 && strEQc (obj->name, "BLOCKRADIALCONSTRAINTPARAMETER"))
             {
               Dwg_BLOCKPARAMVALUESET *value_set
                   = &((Dwg_Object_BLOCKRADIALCONSTRAINTPARAMETER *)_obj)
                          ->value_set;
               pair = add_AcDbBlockParamValueSet (obj, value_set, dat, pair);
               if (!pair) // success
                 goto start_loop;
               else
                 goto search_field;
             }
           else if (pair->code == 309 && strEQc (obj->name, "BLOCKXYPARAMETER"))
             {
               Dwg_BLOCKPARAMVALUESET *value_set
                   = &((Dwg_Object_BLOCKXYPARAMETER *)_obj)
                          ->y_value_set;
               pair = add_AcDbBlockParamValueSet (obj, value_set, dat, pair);
               if (!pair) // success
                 goto start_loop;
               else
                 goto search_field;
             }
           else if (pair->code == 309 && strEQc (obj->name, "BLOCKPOLARPARAMETER"))
             {
               Dwg_BLOCKPARAMVALUESET *value_set
                   = &((Dwg_Object_BLOCKPOLARPARAMETER *)_obj)
                          ->distance_value_set;
               pair = add_AcDbBlockParamValueSet (obj, value_set, dat, pair);
               if (!pair) // success
                 goto start_loop;
               else
                 goto search_field;
             }
           else if (pair->code == 410 && strEQc (obj->name, "BLOCKXYPARAMETER"))
             {
               Dwg_BLOCKPARAMVALUESET *value_set
                   = &((Dwg_Object_BLOCKXYPARAMETER *)_obj)
                          ->x_value_set;
               pair = add_AcDbBlockParamValueSet (obj, value_set, dat, pair);
               if (!pair) // success
                 goto start_loop;
               else
                 goto search_field;
             }
           else if (pair->code == 410 && strEQc (obj->name, "BLOCKPOLARPARAMETER"))
             {
               Dwg_BLOCKPARAMVALUESET *value_set
                   = &((Dwg_Object_BLOCKPOLARPARAMETER *)_obj)
                          ->angle_value_set;
               pair = add_AcDbBlockParamValueSet (obj, value_set, dat, pair);
               if (!pair) // success
                 goto start_loop;
               else
                 goto search_field;
             }
           else if (pair->code == 8 && obj->fixedtype == DWG_TYPE_LAYERFILTER
                    && strEQc (subclass, "AcDbLayerFilter"))
             {
               // num_names
               Dwg_Object_LAYERFILTER *o = obj->tio.object->tio.LAYERFILTER;
               if (!o->names)
                 {
                   o->names = (BITCODE_T *)xcalloc (1, sizeof (BITCODE_T));
                   j = 0;
                 }
               else
                 o->names = (BITCODE_T *)realloc (
                     o->names, (o->num_names + 1) * sizeof (BITCODE_T));
               if (!o->names || j < 0 || j >= (int)o->num_names)
                 goto invalid_dxf;
               assert (j >= 0 && j < (int)o->num_names && o->names);
               o->names[j] = dwg_add_u8_input (dwg, pair->value.s);
               LOG_TRACE ("%s.%s[%d] = %s [%s %d]\n", name, "names", j,
                          pair->value.s, "T", pair->code);
               j++;
               o->num_names = j;
               goto next_pair;
             }
           else
           search_field:
             { // search all specific fields and common fields for the DXF
               const Dwg_DYNAPI_field *f;
               const Dwg_DYNAPI_field *fields
                   = dwg_dynapi_entity_fields (obj->name);
               if (!pair || pair->code == 0)
                 break;
               if (!fields)
                 {
                   LOG_ERROR ("Illegal object name %s, no dynapi fields",
                              obj->name);
                   break;
                 }
               for (f = &fields[0]; f->name; f++)
                 {
                   LOG_INSANE ("-%s.%s [%d %s] vs %d\n", obj->name, f->name,
                               f->dxf, f->type, pair->code)
                   // VECTORs. need to be malloced, and treated specially
                   if (pair->code != 3 && f->is_malloc && !f->is_string
                       && strNE (f->name, "parent")) // parent set in NEW_OBJECT
                     {
                       const Dwg_DYNAPI_field *num_f;
                       // FIELD_2RD_VECTOR (clip_verts, num_clip_verts, 11|14);
                       if (pair->code >= 10 && pair->code <= 24
                           && strEQc (f->name, "clip_verts")) // 11 or 14
                         {
                           BITCODE_BL num_clip_verts = 0;
                           BITCODE_2RD *clip_verts;
                           // 11 has no num_clip_verts: realloc. clip_inverts
                           // has.
                           if (pair->code == 14 || pair->code == 24)
                             {
                               dwg_dynapi_entity_value (_obj, obj->name,
                                                        "num_clip_verts",
                                                        &num_clip_verts, NULL);
                               LOG_INSANE ("%s.num_clip_verts = %d, j = %d\n",
                                           name, num_clip_verts, j);
                             }
                           dwg_dynapi_entity_value (_obj, obj->name,
                                                    "clip_verts", &clip_verts,
                                                    NULL);
                           // assert (j == 0 || j < (int)num_clip_verts);
                           if (pair->code < 20)
                             {
                               // no need to realloc
                               if (!j && pair->code == 14)
                                 {
                                   clip_verts = (BITCODE_2RD *)xcalloc (
                                       num_clip_verts, sizeof (BITCODE_2RD));
                                   dwg_dynapi_entity_set_value (_obj, obj->name,
                                                                f->name,
                                                                &clip_verts, 0);
                                 }
                               else if (pair->code == 11)
                                 {
                                   clip_verts = (BITCODE_2RD *)realloc (
                                       clip_verts,
                                       (j + 1) * sizeof (BITCODE_2RD));
                                   memset (&clip_verts[j], 0,
                                           sizeof (BITCODE_2RD));
                                   dwg_dynapi_entity_set_value (_obj, obj->name,
                                                                f->name,
                                                                &clip_verts, 0);
                                 }
                               if (j >= 0 && j < (int)num_clip_verts
                                   && clip_verts)
                                 clip_verts[j].x = pair->value.d;
                             }
                           else if (pair->code < 30)
                             {
                               if (j >= 0 && j < (int)num_clip_verts
                                   && clip_verts)
                                 {
                                   clip_verts[j].y = pair->value.d;
                                   LOG_TRACE (
                                       "%s.%s[%d] = (%f, %f) [2RD* %d]\n", name,
                                       "clip_verts", j, clip_verts[j].x,
                                       clip_verts[j].y, pair->code - 10);
                                   j++;
                                 }
                               if (pair->code == 21)
                                 {
                                   dwg_dynapi_entity_set_value (
                                       _obj, obj->name, "num_clip_verts", &j,
                                       0);
                                   LOG_TRACE ("%s.num_clip_verts = %d\n", name,
                                              j);
                                 }
                             }
                           goto next_pair;
                         }
                       // point vectors with known num_field
                       else if ((*f->type == '2' || *f->type == '3')
                                && (f->type[2] == 'D'
                                    || strEQc (&f->type[1], "DPOINT*"))
                                && (num_f = find_numfield (fields, f->name)))
                         {
-                          long size = get_numfield_value (
-                              _obj, num_f); // how many points
+                          // how many points
+                          long size = get_numfield_value (_obj, num_f);
                           double *pts;
                           int is2d = *f->type == '2';
                           if (!size)
                             {
                               LOG_TRACE ("Ignore empty %s.%s VECTOR [%s %d]\n",
                                          name, f->name, f->type, pair->code);
                               goto next_pair;
                             }
                           else if (j == 0 && pair->code < 20)
                             {
                               pts = (double *)xcalloc (size, is2d ? 16 : 24);
                               if (!pts)
                                 return NULL;
                               LOG_TRACE ("%s.%s size: %ld\n", name, f->name,
                                          size);
                               pts[0] = pair->value.d;
                               dwg_dynapi_entity_set_value (_obj, obj->name,
                                                            f->name, &pts, 0);
                             }
-                          else if (j < size)
+                          else if (j > 0 && j < size)
                             {
                               int _i = is2d ? j * 2 : j * 3;
                               dwg_dynapi_entity_value (_obj, obj->name,
                                                        f->name, &pts, NULL);
-                              if (pair->code < 20 && pts)
+                              if (pair->code < 20 && pts != NULL)
                                 {
                                   pts[_i] = pair->value.d;
                                 }
-                              else if (pair->code < 30 && pts)
+                              else if (pair->code < 30 && pts != NULL)
                                 {
                                   if (is2d)
                                     LOG_TRACE (
                                         "%s.%s[%d] = (%f, %f) [%s %d]\n", name,
                                         f->name, j, pts[_i], pair->value.d,
                                         f->type, pair->code);
                                   pts[_i + 1] = pair->value.d;
                                 }
                               else if (*f->type == '3' && pts)
                                 {
                                   LOG_TRACE (
                                       "%s.%s[%d] = (%f, %f, %f) [%s %d]\n",
                                       name, f->name, j, pts[_i], pts[_i + 1],
                                       pair->value.d, f->type, pair->code);
                                   pts[_i + 2] = pair->value.d;
                                   if (j == size - 1)
                                     j = 0; // restart
                                 }
                             }
                           else if (j > size)
                             LOG_ERROR ("%s.%s overflow %d > %ld", name,
                                        num_f->name, j, size)
                         }
                       else if (f->dxf == pair->code)
                         {
                           LOG_WARN ("Ignore %s.%s VECTOR [%s %d]", name,
                                     f->name, f->type, pair->code);
                           goto next_pair;
                         }
                     }
                   else if (obj->fixedtype == DWG_TYPE_VISUALSTYLE
                            && dwg->header.from_version >= R_2010 && pair->code == 176
                            && prev_vstyle)
                     {
                       // which 176 of the many? the one after the previous
                       // field
                       char fieldname[40];
                       strcpy (fieldname, prev_vstyle->name);
                       strcat (fieldname, "_int");
                       f = prev_vstyle + 1;
                       if (strEQc (fieldname, "display_brightness_bl_int"))
                         {
                           strcpy (fieldname, "display_brightness_int");
                           f++;
                         }
                       if (strEQ (fieldname, f->name))
                         {
                           LOG_HANDLE ("found %s.%s:\n", name, fieldname);
                           if (strEQc (f->name, "display_shadow_type_int")
                               && dwg->header.from_version >= R_2013)
                             {
                               Dwg_Object_VISUALSTYLE *o = obj->tio.object->tio.VISUALSTYLE;
                               o->display_shadow_type_int = pair->value.i;
                               pair = add_VISUALSTYLE_props (obj, dat);
                               if (!pair) // success
                                 goto start_loop;
                               else // or better advance to the next 0
                                 goto search_field;
                             }
                           else
                             goto matching_pair;
                         }
                       else
                         LOG_WARN ("%s.%s [BS 176] not found in dynapi", name,
                                   fieldname);
                     }
                   else if (f->dxf == pair->code) // matching DXF code
                     {
                     matching_pair:
                       if (obj->fixedtype == DWG_TYPE_VISUALSTYLE
                           && dwg->header.from_version >= R_2010 && pair->code != 176)
                         {
                           prev_vstyle = f;
                         }
                       // exceptions, where there's another field 92:
                       if (pair->code == 92 && is_entity
                           && dwg->header.from_version < R_2010
                           && strEQc (subclass, "AcDbEntity"))
                         // not MULTILEADER.text_color, nor MESH.num_vertex
                         {
                           pair = add_ent_preview (obj, dat, pair);
                           goto start_loop;
                         }
                       else if (pair->code == 3 && pair->value.s
                                && memBEGINc (obj->name, "DICTIONARY")
                                && strNE (obj->name, "DICTIONARYVAR"))
                         {
                           strncpy (text, pair->value.s, 254);
                           text[255] = '\0';
                           goto next_pair; // skip setting texts TV*
                         }
                       // convert angle to radians
                       else if (pair->code >= 50 && pair->code <= 55)
                         {
                           BITCODE_BD ang;
                           if (pair->value.d == 0.0)
                             goto next_pair;
                           ang = deg2rad (pair->value.d);
                           dwg_dynapi_entity_set_value (_obj, obj->name,
                                                        f->name, &ang, 0);
                           LOG_TRACE ("%s.%s = %f (from DEG %f°) [%s %d]\n",
                                      name, f->name, ang, pair->value.d,
                                      f->type, pair->code);
                           goto next_pair; // found
                         }
                       // convert double to text (e.g. ATEXT)
                       else if (strEQc (f->type, "D2T")
                                && pair->type == DWG_VT_REAL)
                         {
                           // TODO: for now we need to do double-conversion
                           // (str->dbl->str), because we don't have the initial
                           // dat->byte position.
                           char *d2t = (char *)xcalloc (36, 1);
                           sprintf (d2t, "%f", pair->value.d);
                           dwg_dynapi_entity_set_value (_obj, obj->name,
                                                        f->name, &d2t, 1);
                           LOG_TRACE ("%s.%s = %s (from %f°) [%s %d]\n", name,
                                      f->name, d2t, pair->value.d, f->type,
                                      pair->code);
                           free (d2t);
                           goto next_pair; // found
                         }
                       // resolve handle, by name or ref
                       else if (strEQc (f->type, "H"))
                         {
                           BITCODE_H ref = find_tablehandle (dwg, pair);
                           if (!ref)
                             {
                               if (pair->code > 300)
                                 {
                                   int code = 5; // default: soft pointer
                                   if (obj->fixedtype == DWG_TYPE_VIEWPORT)
                                     {
                                       switch (pair->code)
                                         {
                                         case 340:
                                         case 332:
                                         case 333:
                                           code = 4;
                                           break;
                                         case 361:
                                           code = 3;
                                           break;
                                         default:
                                           break;
                                         }
                                     }
                                   else if (strEQc (f->name, "history_id"))
                                     code = 4;
                                   else if (strEQc (f->name, "background"))
                                     code = 4;
                                   else if (strEQc (f->name, "dimensionobj"))
                                     code = 4;
                                   else if (strEQc (f->name, "active_viewport")
                                            || strEQc (f->name, "host_block"))
                                     code = 4;
                                   else if (strEQc (f->name, "writedep")
                                            || strEQc (f->name, "readdep"))
                                     code = 4;
                                   else if (strEQc (f->name, "imagedefreactor"))
                                     code = 3;
                                   else if (strEQc (f->name, "table_style"))
                                     code = 3;
                                   ref = dwg_add_handleref (dwg, code,
                                                            pair->value.u, obj);
                                   LOG_TRACE ("%s.%s = " FORMAT_REF " [H %d]\n",
                                              name, f->name, ARGS_REF (ref),
                                              pair->code);
                                 }
                               else if (pair->type == DWG_VT_INT32 && pair->value.u)
                                 {
                                   ref = dwg_add_handleref (dwg, 5,
                                                            pair->value.u, obj);
                                   LOG_TRACE ("%s.%s = " FORMAT_REF " [H %d]\n",
                                              name, f->name, ARGS_REF (ref),
                                              pair->code);
                                 }
                               else if ((pair->type == DWG_VT_STRING
                                         || pair->type == DWG_VT_HANDLE)
                                        && pair->value.s)
                                 {
                                   obj_hdls = array_push (
                                       obj_hdls, f->name, pair->value.s,
                                       obj->tio.object->objid);
                                   LOG_TRACE ("%s.%s: name %s -> H for code "
                                              "%d later\n",
                                              name, f->name, pair->value.s,
                                              pair->code);
                                 }
                             }
                           else
                             {
                               dwg_dynapi_entity_set_value (_obj, obj->name,
                                                            f->name, &ref, 1);
                               LOG_TRACE ("%s.%s = " FORMAT_REF " [H %d]\n",
                                          name, f->name, ARGS_REF (ref),
                                          pair->code);
                             }
                           goto next_pair; // found
                         }
                       // only 2D or 3D points .x
                       else if (f->size > 8
                                && (strchr (f->type, '2')
                                    || strchr (f->type, '3')
                                    || strEQc (f->type, "BE")))
                         {
                           // pt.x = 0.0;
                           // if (pair->value.d == 0.0) // ignore defaults
                           //  goto next_pair;
                           pt.x = pair->value.d;
                           dwg_dynapi_entity_set_value (_obj, obj->name,
                                                        f->name, &pt, 1);
                           LOG_TRACE ("%s.%s.x = %f [%s %d]\n", name, f->name,
                                      pair->value.d, f->type, pair->code);
                           goto next_pair; // found
                         }
                       else if (pair->type == DWG_VT_REAL
                                && strEQc (f->type, "TIMEBLL"))
                         {
                           static BITCODE_TIMEBLL date = { 0, 0, 0 };
                           date.value = pair->value.d;
                           date.days = (BITCODE_BL)trunc (pair->value.d);
                           date.ms = (BITCODE_BL) (86400000.0
                                                   * (date.value - date.days));
                           LOG_TRACE ("%s.%s %.09f (" FORMAT_BL ", " FORMAT_BL
                                      ") [TIMEBLL %d]\n",
                                      name, f->name, date.value, date.days,
                                      date.ms, pair->code);
                           dwg_dynapi_entity_set_value (_obj, obj->name,
                                                        f->name, &date, 1);
                           goto next_pair;
                         }
                       else if (f->size > 8 && strEQc (f->type, "CMC"))
                         {
                           BITCODE_CMC color;
                           dwg_dynapi_entity_value (_obj, obj->name, f->name,
                                                    &color, NULL);
                           if (pair->code < 90)
                             {
                               color.index = pair->value.i;
                               if (pair->value.i == 256)
                                 color.method = 0xc2;
                               else if (pair->value.i == 257)
                                 color.method = 0xc8;
                               else if (pair->value.i < 256 && dat->from_version >= R_2004)
                                 {
                                   color.method = 0xc3;
                                   color.rgb = 0xc3000000 | color.index;
                                   color.index = 256;
                                 }
                               LOG_TRACE ("%s.%s.index = %d [%s %d]\n", name,
                                          f->name, color.index, "CMC",
                                          pair->code);
                               if (color.rgb)
                                 LOG_TRACE ("%s.%s.rgb = 0x%08x [%s %d]\n", name,
                                            f->name, color.rgb, "CMC",
                                            pair->code);
                             }
                           else if (pair->code < 430)
                             {
                               color.rgb = pair->value.l;
                               color.method = pair->value.l >> 0x18;
                               if (pair->value.l == 257)
                                 {
                                   color.method = 0xc8;
                                   color.rgb = 0xc8000000;
                                 }
                               // color.alpha = (pair->value.l & 0xFF000000) >>
                               // 24; if (color.alpha)
                               //  color.alpha_type = 3;
                               LOG_TRACE ("%s.%s.rgb = %08X [%s %d]\n", name,
                                          f->name, pair->value.u, "CMC",
                                          pair->code);
                             }
                           else if (pair->code < 440)
                             {
                               color.flag |= 0x10;
                               color.name = dwg_add_u8_input (dwg, pair->value.s);
                               LOG_TRACE ("%s.%s.name = %s [%s %d]\n", name,
                                          f->name, pair->value.s, "CMC",
                                          pair->code);
                             }
                           else if (pair->code < 450)
                             {
                               color.alpha = (pair->value.l & 0xFF000000) >> 24;
                               if (color.alpha)
                                 color.alpha_type = 3;
                               LOG_TRACE ("%s.%s.alpha = %08X [%s %d]\n", name,
                                          f->name, pair->value.u, "CMC",
                                          pair->code);
                             }
                           dwg_dynapi_entity_set_value (_obj, obj->name,
                                                        f->name, &color, 1);
                           goto next_pair; // found, early exit
                         }
                       else
                         dwg_dynapi_entity_set_value (_obj, obj->name, f->name,
                                                      &pair->value, 1);
                       if (f->is_string)
                         {
                           LOG_TRACE ("%s.%s = %s [%s %d]\n", name, f->name,
                                      pair->value.s, f->type, pair->code);
                         }
                       else if (strchr (&f->type[1], 'D'))
                         {
                           LOG_TRACE ("%s.%s = %f [%s %d]\n", name, f->name,
                                      pair->value.d, f->type, pair->code);
                         }
                       else
                         {
                           LOG_TRACE ("%s.%s = %ld [%s %d]\n", name, f->name,
                                      pair->value.l, f->type, pair->code);
                         }
+                      j = 0; // not a point nor vector member, so reset
                       goto next_pair; // found, early exit
                     }
                   // wrong code, maybe a point .y or .z
                   else if ((*f->type == '3' || *f->type == '2'
                             || strEQc (f->type, "BE"))
                            && (strstr (f->type, "_1")
                                    ? f->dxf + 1 == pair->code // 2BD_1
                                    : f->dxf + 10 == pair->code))
                     {
                       // pt.y = 0.0;
                       // if (pair->value.d == 0.0) // ignore defaults
                       //  goto next_pair;
                       dwg_dynapi_entity_value (_obj, obj->name, f->name, &pt,
                                                NULL);
                       pt.y = pair->value.d;
                       dwg_dynapi_entity_set_value (_obj, obj->name, f->name,
                                                    &pt, 1);
                       LOG_TRACE ("%s.%s.y = %f [%s %d]\n", name, f->name,
                                  pair->value.d, f->type, pair->code);
                       goto next_pair; // found, early exit
                     }
                   else if ((*f->type == '3' || *f->type == '2'
                             || strEQc (f->type, "BE"))
                            && (strstr (f->type, "_1")
                                    ? f->dxf + 2 == pair->code // 2BD_1
                                    : f->dxf + 20 == pair->code))
                     {
                       pt.z = 0.0;
                       // can ignore z or 0.0? e.g. no VPORT.view_target
                       if (strNE (name, "_3DFACE") && strNE (f->name, "scale")
                           && *f->type == '2')
                         goto next_pair;
                       dwg_dynapi_entity_value (_obj, obj->name, f->name, &pt,
                                                NULL);
                       pt.z = pair->value.d;
                       dwg_dynapi_entity_set_value (_obj, obj->name, f->name,
                                                    &pt, 0);
                       LOG_TRACE ("%s.%s.z = %f [%s %d]\n", name, f->name,
                                  pair->value.d, f->type, pair->code);
 
                       // 3DD scale
                       if (strEQc (f->name, "scale")
                           && dwg->header.version >= R_2000
                           && dwg_dynapi_entity_field (obj->name, "scale_flag")
                           && dwg_dynapi_entity_value (_obj, obj->name,
                                                       "scale_flag",
                                                       &scale_flag, NULL))
                         { // set scale_flag
                           scale_flag = 0;
                           if (pt.x == 1.0 && pt.y == 1.0 && pt.z == 1.0)
                             scale_flag = 3;
                           else if (pt.x == 1.0)
                             scale_flag = 1;
                           else if (pt.x == pt.y && pt.x == pt.z)
                             scale_flag = 2;
                           dwg_dynapi_entity_set_value (
                               _obj, obj->name, "scale_flag", &scale_flag, 0);
                           LOG_TRACE ("%s.scale_flag = %d [BB 0]\n", name,
                                      scale_flag);
                         }
                       // 3DFACE.z_is_zero
                       else if (strEQc (name, "_3DFACE")
                                && strEQc (f->name, "corner1")
                                && dwg->header.version >= R_2000 && pt.z == 0.0)
                         {
                           BITCODE_B z_is_zero = 1;
                           dwg_dynapi_entity_set_value (
                               _obj, obj->name, "z_is_zero", &z_is_zero, 0);
                           LOG_TRACE ("%s.z_is_zero = 1 [B 0]\n", name);
                         }
 
                       goto next_pair; // found, early exit
                     }
                   // FIELD_VECTOR_N BITCODE_BD transmatrix[16]:
                   else if (strEQc (f->type, "BD*")
                            && (strEQc (name, "EXTRUDEDSURFACE")
                                || strEQc (name, "LOFTEDSURFACE")
                                || strEQc (name, "SWEPTSURFACE")
                                || strEQc (name, "REVOLVEDSURFACE")
                                || strEQc (name, "MATERIAL")
                                || strEQc (name, "SPATIAL_FILTER")
                                || /* max 12 */
                                strEQc (name, "ACSH_SWEEP_CLASS"))
                            && ((pair->code >= 40 && pair->code <= 49)
                                || (pair->code <= 142 && pair->code <= 147)))
                     {
                       // 16x BD, via j
                       BITCODE_BD *matrix;
                       dwg_dynapi_entity_value (_obj, obj->name, f->name,
                                                &matrix, NULL);
                       if (!matrix)
                         {
                           matrix = (BITCODE_BD *)xcalloc (16,
                                                           sizeof (BITCODE_BD));
                           if (!matrix)
                             goto invalid_dxf;
                           j = 0;
                         }
                       if (j < 0 || j >= 16 || !matrix)
                         goto invalid_dxf;
                       assert (j >= 0 && j < 16 && matrix);
                       matrix[j] = pair->value.d;
                       dwg_dynapi_entity_set_value (_obj, obj->name, f->name,
                                                    &matrix, 0);
                       LOG_TRACE ("%s.%s[%d] = %f [%s %d]\n", name, f->name, j,
                                  pair->value.d, f->type, pair->code);
                       j++;
                       goto next_pair;
                     }
                 }
               LOG_INSANE ("----\n");
               if (*subclass) // embedded subclasses/objects
                 {
                   if (obj->fixedtype == DWG_TYPE_LAYOUT
                       && strEQc (subclass, "AcDbPlotSettings"))
                     {
                       Dwg_Object_LAYOUT *o = obj->tio.object->tio.LAYOUT;
                       int unique;
                       static double pt_x;
                       static const Dwg_DYNAPI_field *pt_f = NULL;
                       if (pair->code == 6 && *pair->value.s)
                         {
                           if (dwg->header.version < R_2004)
                             {
                               f = dwg_dynapi_entity_field ("PLOTSETTINGS",
                                                            "plotview_name");
                               dwg_dynapi_field_set_value (
                                   dwg, &o->plotsettings, f, &pair->value, 1);
                             }
                           else
                             {
                               BITCODE_H ref = find_tablehandle (dwg, pair);
                               f = dwg_dynapi_entity_field ("PLOTSETTINGS",
                                                            "plotview");
                               dwg_dynapi_field_set_value (
                                   dwg, &o->plotsettings, f, &ref, 1);
                             }
                           goto next_pair;
                         }
                       fields = dwg_dynapi_entity_fields ("PLOTSETTINGS");
                       f = dwg_dynapi_field_dxf (fields, pair->code, &unique);
                       if (f && unique)
                         {
                           if (*f->type == '2') // 2D points
                             {
                               pt_f = f;
                               pt_x = pair->value.d;
                               goto next_pair;
                             }
                           else if (strEQc (f->type, "H"))
                             {
                               BITCODE_H ref = find_tablehandle (dwg, pair);
                               if (!ref)
                                 {
                                   if (pair->code > 300)
                                     {
                                       int code = 4;
                                       ref = dwg_add_handleref (
                                           dwg, code, pair->value.u, obj);
                                       LOG_TRACE (
                                           "%s.plotsettings.%s = " FORMAT_REF
                                           " [H %d]\n",
                                           name, f->name, ARGS_REF (ref),
                                           pair->code);
                                     }
                                   goto next_pair; // found
                                 }
                               else
                                 {
                                   dwg_dynapi_field_set_value (
                                       dwg, &o->plotsettings, f, &ref, 1);
                                   LOG_TRACE (
                                       "set %s.plotsettings.%s " FORMAT_REF
                                       " [H %d]\n",
                                       obj->name, f->name, ARGS_REF (ref),
                                       pair->code);
                                   goto next_pair; // found
                                 }
                             }
                           else
                             {
                               LOG_TRACE ("set %s.plotsettings.%s [%s %d]\n",
                                          obj->name, f->name, f->type,
                                          pair->code);
                               dwg_dynapi_field_set_value (
                                   dwg, &o->plotsettings, f, &pair->value, 1);
                               goto next_pair;
                             }
                         }
                       else if (pt_f
                                && (pair->code == 47 || pair->code == 49
                                    || pair->code == 141 || pair->code == 149))
                         {
                           BITCODE_2BD pt2;
                           pt2.x = pt_x;
                           pt2.y = pair->value.d;
                           LOG_TRACE ("set %s.plotsettings.%s [%s %d]\n",
                                      obj->name, pt_f->name, pt_f->type,
                                      pt_f->dxf);
                           dwg_dynapi_field_set_value (dwg, &o->plotsettings,
                                                       pt_f, &pt2, 1);
                           goto next_pair;
                         }
                       else
                         LOG_WARN ("Unknown DXF code %d for %s", pair->code,
                                   subclass);
                     }
                 }
               fields = is_entity ? dwg_dynapi_common_entity_fields ()
                                  : dwg_dynapi_common_object_fields ();
               for (f = &fields[0]; f->name; f++)
                 {
                   LOG_INSANE ("-%s.%s [%d %s] vs %d\n",
                               is_entity ? "ENTITY" : "OBJECT", f->name, f->dxf,
                               f->type, pair->code)
                   if ((pair->code == 62 || pair->code == 420
                        || pair->code == 430 || pair->code == 440)
                       && (f->size > 8
                           && strEQc (f->type, "CMC"))) // alt. color fields
                     {
                       BITCODE_CMC color;
                       dwg_dynapi_common_value (_obj, f->name, &color, NULL);
                       if (pair->code == 62)
                         {
                           color.index = pair->value.i;
                           LOG_TRACE ("COMMON.%s.index = %d [%s %d]\n", f->name,
                                      pair->value.i, "CMC", pair->code);
                         }
                       else if (pair->code == 420)
                         {
                           color.rgb = pair->value.l;
                           color.method = pair->value.l >> 0x18;
                           if (pair->value.l == 257)
                             {
                               color.method = 0xc8;
                               color.rgb = 0xc8000000;
                             }
                           // color.alpha = (pair->value.l & 0xFF000000) >> 24;
                           // if (color.alpha)
                           //  color.alpha_type = 3;
                           LOG_TRACE ("COMMON.%s.rgb = %08X [%s %d]\n", f->name,
                                      pair->value.u, "CMC", pair->code);
                         }
                       else if (pair->code == 440)
                         {
                           color.flag |= 0x20;
                           color.alpha = (pair->value.l & 0xFF000000) >> 24;
                           color.alpha_type = pair->value.u >> 8;
                           if (color.alpha && !color.alpha_type)
                             color.alpha_type = 3;
                           LOG_TRACE ("COMMON.%s.alpha = %08X [%s %d]\n",
                                      f->name, pair->value.u, "CMC",
                                      pair->code);
                         }
                       else if (pair->code == 430)
                         {
                           color.flag |= 0x10;
                           color.name = dwg_add_u8_input (dwg, pair->value.s);
                           // TODO: book_name or name?
                           LOG_TRACE ("COMMON.%s.name = %s [%s %d]\n", f->name,
                                      pair->value.s, "CMC", pair->code);
                         }
                       dwg_dynapi_common_set_value (_obj, f->name, &color,
                                                    is_tu);
                       goto next_pair; // found, early exit
                     }
                   else if (f->dxf == pair->code)
                     {
                       /// resolve handle (table entry) given by name or ref
                       if (strEQc (f->type, "H"))
                         {
                           BITCODE_H handle = find_tablehandle (dwg, pair);
                           if (!handle)
                             {
                               if (pair->code > 300)
                                 {
                                   handle = dwg_add_handleref (
                                       dwg, 5, pair->value.u, obj);
                                   dwg_dynapi_common_set_value (_obj, f->name,
                                                                &handle, 0);
                                   LOG_TRACE ("COMMON.%s = %X [H %d]\n",
                                              f->name, pair->value.u,
                                              pair->code)
                                 }
                               else
                                 {
                                   LOG_WARN ("TODO resolve common handle "
                                             "name %s %s",
                                             f->name, pair->value.s)
                                 }
                             }
                           else
                             {
                               if (pair->code > 300)
                                 LOG_TRACE ("COMMON.%s = %lX [H %d]\n", f->name,
                                            pair->value.l, pair->code)
                               else
                                 LOG_TRACE ("COMMON.%s = %s [H %d]\n", f->name,
                                            pair->value.s, pair->code)
                               dwg_dynapi_common_set_value (_obj, f->name,
                                                            &handle, 0);
                             }
                           if (is_entity && pair->code == 6 && pair->value.s
                               && dwg->header.version >= R_2000)
                             {
                               BITCODE_BB flags = 3;
                               if (!strcasecmp (pair->value.s, "BYLAYER"))
                                 flags = 0;
                               if (!strcasecmp (pair->value.s, "BYBLOCK"))
                                 flags = 1;
                               if (!strcasecmp (pair->value.s, "CONTINUOUS"))
                                 flags = 2;
                               dwg_dynapi_common_set_value (_obj, "ltype_flags",
                                                            &flags, 0);
                               LOG_TRACE ("COMMON.%s = %d [BB 0]\n",
                                          "ltype_flags", flags);
                             }
                           if (is_entity && pair->code == 390
                               && dwg->header.version >= R_2000)
                             {
                               BITCODE_BB flags = 3;
                               /*
                               if (!strcasecmp (pair->value.s, "BYLAYER"))
                                 flags = 0;
                               if (!strcasecmp (pair->value.s, "BYBLOCK"))
                                 flags = 1;
                               */
                               dwg_dynapi_common_set_value (
                                   _obj, "plotstyle_flags", &flags, 0);
                               LOG_TRACE ("COMMON.%s = %d [BB 0]\n",
                                          "plotstyle_flags", flags);
                             }
                           if (is_entity && pair->code == 347
                               && dwg->header.version >= R_2007)
                             {
                               BITCODE_BB flags = 3;
                               /*
                               if (!strcasecmp (pair->value.s, "BYLAYER"))
                                 flags = 0;
                               if (!strcasecmp (pair->value.s, "BYBLOCK"))
                                 flags = 1;
                               */
                               dwg_dynapi_common_set_value (
                                   _obj, "material_flags", &flags, 0);
                               LOG_TRACE ("COMMON.%s = %d [BB 0]\n",
                                          "material_flags", flags);
                             }
                           goto next_pair; // found, early exit
                         }
                       else if (pair->code == 310 && is_entity
                                && !obj->tio.entity->preview_size
                                && obj->fixedtype > DWG_TYPE_LAYOUT
                                && strEQc (subclass, "AcDbEntity"))
                         {
                           pair = add_ent_preview (obj, dat, pair);
                           goto start_loop;
                         }
                       else if (pair->code == 310 && is_entity
                                && obj->tio.entity->preview_size
                                && obj->fixedtype > DWG_TYPE_LAYOUT
                                && strEQc (subclass, "AcDbEntity"))
                         {
                           // This would corrupt the previous preview chain,
                           // don't append
                           LOG_ERROR ("Skip duplicate/interrupted %s.preview",
                                      obj->name)
                           goto next_pair;
                         }
                       else
                         {
                           // Don't write a ptr twice. This will fuckup the
                           // num_ counter. Just add to 310 preview, when
                           // prefixed by 92
                           if (f->is_malloc || f->is_string)
                             {
                               char *ptr = NULL;
                               if (dwg_dynapi_common_value (_obj, f->name, &ptr,
                                                            NULL)
                                   && ptr != NULL)
                                 {
                                   LOG_ERROR ("Skip duplicate %s.%s [%s %d]",
                                              obj->name, f->name, f->type,
                                              pair->code)
                                   goto next_pair;
                                 }
                             }
                           dwg_dynapi_common_set_value (_obj, f->name,
                                                        &pair->value, 1);
                           if (f->is_string)
                             {
                               LOG_TRACE ("COMMON.%s = %s [%s %d]\n", f->name,
                                          pair->value.s, f->type, pair->code)
                             }
                           else
                             {
                               if (is_entity && pair->code == 160
                                   && dwg->header.from_version >= R_2010)
                                 {
                                   pair = add_ent_preview (obj, dat, pair);
                                   goto start_loop; // already fresh pair
                                 }
                               if (strchr (f->type, 'D'))
                                 LOG_TRACE ("COMMON.%s = %f [%s %d]\n", f->name,
                                            pair->value.d, f->type, pair->code)
                               else
                                 LOG_TRACE ("COMMON.%s = %ld [%s %d]\n",
                                            f->name, pair->value.l, f->type,
                                            pair->code)
                             }
                           goto next_pair; // found, early exit
                         }
                     }
                 }
               LOG_INSANE ("----\n")
               // still needed? already handled above
               // not in dynapi: 92 as 310 size prefix for PROXY vector preview
               // FIXME 92 is just for pre-r2010 entities. r2010+ is 160
               if (pair->code == 92 && is_entity && dwg->header.from_version < R_2010
                   && (strEQc (subclass, "AcDbEntity")
                       || strEQc (subclass, "AcDbProxyEntity")
                       || strstr (subclass, "Surface")))
                 {
                   pair = add_ent_preview (obj, dat, pair);
                   goto start_loop;
                 }
               else if (strEQc (name, "MULTILEADER"))
                 {
                   // for the unknown subfields: 300, 140, 145, 302, 304, ...
                   pair = add_MULTILEADER (obj, dat, pair);
                   // returns with 0 or 301
                   if (pair && pair->code == 301)
                     goto next_pair;
                 }
               else if (obj->fixedtype == DWG_TYPE_TABLESTYLE)
                 {
                   // for the unknown subfields: 7, 140, ...
                   pair = add_TABLESTYLE (obj, dat, pair);
                   // returns with 0
                   if (pair && pair->code == 0)
                     goto start_loop;
                 }
               else if (obj->fixedtype == DWG_TYPE_TABLEGEOMETRY)
                 {
                   // for the unknown subfields: 93, 40, ...
                   pair = add_TABLEGEOMETRY_Cell (obj, dat, pair);
                   // returns with 0
                   if (pair && pair->code == 0)
                     goto start_loop;
                 }
               else if (strEQc (name, "BLOCK")
                        && (pair->code == 70 || pair->code == 10
                            || pair->code == 20 || pair->code == 30
                            || pair->code == 3 || pair->code == 1
                            || pair->code == 4))
                 ; // ignore those BLOCK fields. DXF artifacts
               else if (strEQc (name, "DIMENSION")
                        && (pair->code == 2 || pair->code == 210
                            || pair->code == 220 || pair->code == 230))
                 ; // ignore the POLYLINE elevation.x,y. DXF artifacts
               else if (strEQc (name, "HATCH")
                        && (pair->code == 10 || pair->code == 20))
                 ; // ignore the whole PLINE and VERTEX_PFACE_FACE 3BD 10
               else if ((strEQc (name, "VERTEX_PFACE_FACE")
                         || strEQc (name, "POLYLINE_3D")
                         || strEQc (name, "POLYLINE_2D")
                         || strEQc (name, "POLYLINE_MESH")
                         || strEQc (name, "POLYLINE_PFACE"))
                        && (pair->code == 10 || pair->code == 20
                            || pair->code == 30))
                 ; // ignore the POLYLINE_PFACE flag 70
               else if (pair->code == 70 && strEQc (name, "POLYLINE_PFACE"))
                 ;
               // always OLE
               else if (pair->code == 1 && strEQc (name, "OLE2FRAME")
                        && strEQc (pair->value.s, "OLE"))
                 ;
               // the STYLE name, which is already defined by code 7
               else if (pair->code == 2 && strEQc (name, "SHAPE"))
                 ;
               else if ((pair->code == 290 || pair->code == 2)
                        && ((obj->fixedtype == DWG_TYPE_REGION)
                            || (obj->fixedtype == DWG_TYPE_BODY)
                            || (obj->fixedtype == DWG_TYPE__3DSOLID)))
                 LOG_TRACE ("Unknown DXF code %d for %s\n", pair->code, name)
               else if (obj->fixedtype == DWG_TYPE_PROXY_ENTITY
                        && pair->code == 92)
                 {
                   pair = add_ent_preview (obj, dat, pair);
                   goto start_loop;
                 }
               else if (obj->fixedtype == DWG_TYPE_PROXY_ENTITY
                        && (pair->code == 90 || pair->code == 91
                            || pair->code == 71
                            || pair->code == 94)) // unknown r14
                 {
                   Dwg_Entity_PROXY_ENTITY *o
                       = obj->tio.entity->tio.PROXY_ENTITY;
                   if (dwg->header.version <= R_14)
                     {
                       if (pair->code == 90)
                         o->class_id = pair->value.i;
                       else if (pair->code == 91)
                         o->version = pair->value.i;
                     }
                   else if (pair->code == 91)
                     o->class_id = pair->value.i;
                   else if (pair->code == 71) // r2018+
                     o->version = pair->value.i;
                 }
               else if (obj->fixedtype == DWG_TYPE_LAYER
                        && ((pair->code == 348) || (pair->code == 420)
                            || (pair->code == 430) | (pair->code == 440)))
                 {
                   Dwg_Object_LAYER *o = obj->tio.object->tio.LAYER;
                   if (pair->code == 420)
                     {
                       o->color.rgb = pair->value.l;
                       o->color.method = pair->value.l >> 0x18;
                       if (pair->value.l == 257)
                         {
                           o->color.method = 0xc8;
                           o->color.rgb = 0xc8000000;
                         }
                       // o->color.alpha = (pair->value.l & 0xFF000000) >> 24;
                       // if (o->color.alpha)
                       //  o->color.alpha_type = 3;
                       LOG_TRACE ("%s.color.rgb = %08X [%s %d]\n", name,
                                  pair->value.u, "CMC", pair->code);
                     }
                   else if (pair->code == 440)
                     {
                       o->color.flag |= 0x20; // ???
                       o->color.alpha = (pair->value.l & 0xFF000000) >> 24;
                       o->color.alpha_type = pair->value.u >> 8;
                       if (o->color.alpha && !o->color.alpha_type)
                         o->color.alpha_type = 3;
                       LOG_TRACE ("%s.color.alpha = %08X [%s %d]\n", name,
                                  pair->value.u, "CMC", pair->code);
                     }
                   else if (pair->code == 430)
                     {
                       char *x;
                       o->color.book_name = strdup (pair->value.s);
                       x = strchr (o->color.book_name, '$');
                       if (!x) // name only
                         {
                           o->color.name = o->color.book_name;
                           o->color.flag = 1;
                           LOG_TRACE ("%s.color.name = %s [%s %d]\n", name,
                                      pair->value.s, "CMC", pair->code);
                           if (dwg->header.version >= R_2007)
                             {
                               char *tmp = o->color.name;
                               o->color.name
                                 = (BITCODE_T)bit_utf8_to_TU (o->color.name, 0);
                               free (tmp);
                             }
                         }
                       else
                         { // book with name
                           o->color.flag = 3;
                           o->color.name = strdup (x + 1);
                           x[0] = '\0';
                           if (dwg->header.version >= R_2007)
                             {
                               char *tmp = o->color.book_name;
                               o->color.book_name = (BITCODE_T)bit_utf8_to_TU (
                                   o->color.book_name, 0);
                               free (tmp);
                               tmp = o->color.name;
                               o->color.name
                                 = (BITCODE_T)bit_utf8_to_TU (o->color.name, 0);
                               free (tmp);
                             }
                           LOG_TRACE ("%s.color.book+name = %s [%s %d]\n", name,
                                      pair->value.s, "CMC", pair->code);
                         }
                     }
                   else if (pair->code == 348)
                     LOG_TRACE ("Unknown DXF code %d for %s\n", pair->code,
                                name);
                   goto next_pair;
                 }
               else if (obj->fixedtype == DWG_TYPE_DIMSTYLE
                        && pair->code == 287)
                 {
                   // <= r14
                   Dwg_Object_DIMSTYLE *o = obj->tio.object->tio.DIMSTYLE;
                   o->DIMFIT = pair->value.i;
                   LOG_TRACE ("%s.DIMFIT = %d [%s %d]\n", name, pair->value.i,
                              "RC", pair->code);
                 }
               else if (obj->fixedtype == DWG_TYPE_DIMENSION_ALIGNED
                        && pair->code == 52)
                 {
                   BITCODE_BD ang = deg2rad (pair->value.d);
                   free (obj->dxfname);
                   UPGRADE_ENTITY (DIMENSION_ALIGNED, DIMENSION_LINEAR)
                   dwg_dynapi_entity_set_value (_obj, "DIMENSION_LINEAR",
                                                "ext_line_rotation", &ang, 1);
                   LOG_TRACE ("%s.%s = %f (from DEG %f°) [%s %d]\n", name,
                              "ext_line_rotation", ang, pair->value.d, "BD",
                              52);
                 }
               else if (obj->fixedtype == DWG_TYPE_DIMENSION_ALIGNED
                        && pair->code == 50)
                 {
                   BITCODE_BD ang = deg2rad (pair->value.d);
                   free (obj->dxfname);
                   UPGRADE_ENTITY (DIMENSION_ALIGNED, DIMENSION_LINEAR)
                   dwg_dynapi_entity_set_value (_obj, "DIMENSION_LINEAR",
                                                "dim_rotation", &ang, 1);
                   LOG_TRACE ("%s.%s = %f (from DEG %f°) [%s %d]\n", name,
                              "dim_rotation", ang, pair->value.d, "BD", 50);
                 }
               // accept wrong colors
               else if (is_class_stable (obj->name) && (pair->code < 60 || pair->code > 68))
                 {
                   goto invalid_dxf;
                 }
               else
                 LOG_WARN ("Unknown DXF code %d for %s", pair->code, name);
             }
         }
     next_pair:
       dxf_free_pair (pair);
       pair = dxf_read_pair (dat);
       DXF_RETURN_EOF (pair);
     }
 
   if (obj->type == DWG_TYPE_SEQEND)
     dxf_postprocess_SEQEND (obj);
   else if (obj->type == DWG_TYPE_LAYOUT)
     dxf_postprocess_LAYOUT (obj);
   else if (obj->type == DWG_TYPE_PLOTSETTINGS)
     dxf_postprocess_PLOTSETTINGS (obj);
   // set defaults not in dxf:
   else if (obj->type == DWG_TYPE__3DFACE && dwg->header.version >= R_2000)
     {
       Dwg_Entity__3DFACE *o = obj->tio.entity->tio._3DFACE;
       o->has_no_flags = 1;
       LOG_TRACE ("_3DFACE.has_no_flags = 1 [B]\n");
     }
   else if (is_textlike (obj))
     postprocess_TEXTlike (obj);
 
   return pair;
