commit 580e8bbebf18579b97e2c20b032368b9079624ca
Author: Reini Urban <rurban@cpan.org>
Date:   Thu May 26 11:34:45 2022 +0200

    preR13: en/decode the 5 new r10-r11 table headers
    
    which are embedded in the header section.
    also add the CONTROL objects with add_Document.
    header.numsections is wrong. should be header.numoldtables or such.

diff --git a/include/dwg.h b/include/dwg.h
index 730fac01..2e50d9f4 100644
--- a/include/dwg.h
+++ b/include/dwg.h
@@ -8619,15 +8619,16 @@ typedef enum DWG_SECTION_TYPE_R13
 typedef enum DWG_SECTION_TYPE_R11 /* tables */
 {
   SECTION_HEADER_R11 = 0,
   SECTION_BLOCK = 1,
   SECTION_LAYER = 2,
   SECTION_STYLE = 3,
   SECTION_LTYPE = 5,
   SECTION_VIEW  = 6,
-  // since r11:
+  // since r10:
   SECTION_UCS   = 7,
   SECTION_VPORT = 8,
   SECTION_APPID = 9,
+  // since r11:
   SECTION_DIMSTYLE = 10,
   SECTION_VX = 11,
 } Dwg_Section_Type_r11;
diff --git a/src/decode_r11.c b/src/decode_r11.c
index f7fc4d53..987476bb 100644
--- a/src/decode_r11.c
+++ b/src/decode_r11.c
@@ -127,94 +127,70 @@ static int
 decode_preR13_section_hdr (const char *restrict name, Dwg_Section_Type_r11 id,
 		           Bit_Chain *restrict dat, Dwg_Data *restrict dwg)
 {
   int error = 0;
   Dwg_Section *tbl = &dwg->header.section[id];
   //Dwg_Object_BLOCK_CONTROL *block_control = dwg_block_control (dwg);
   //Dwg_Object_BLOCK_HEADER *mspace;
   //Dwg_Object *mspaceobj;
 
   tbl->size = bit_read_RS (dat);
   tbl->number = bit_read_RS (dat);
   tbl->flags = bit_read_RS (dat);
   tbl->address = bit_read_RL (dat);
   strncpy (tbl->name, name, 63);
   tbl->name[63] = '\0';
   LOG_TRACE ("ptr table %-8s [%2d]: size:%-4u num:%-2d (0x%lx-0x%lx) flags:0x%x\n",
              tbl->name, id, tbl->size, tbl->number, (unsigned long)tbl->address,
              (unsigned long)(tbl->address + (tbl->number * tbl->size)),
 	     tbl->flags)
 
   switch (id)
     {
     case SECTION_BLOCK:
       {
         Dwg_Object *obj = dwg_get_first_object (dwg, DWG_TYPE_BLOCK_CONTROL);
         if (obj)
           {
             Dwg_Object_BLOCK_CONTROL *_obj = obj->tio.object->tio.BLOCK_CONTROL;
             obj->size = tbl->size;
             obj->address = tbl->address;
             //obj->flag_r11 = tbl->flags;
             // we cannot set _obj->num_entries, as we add BLOCK's via add_BLOCK_HEADER
             dwg->block_control = *_obj;
           }
       }
       break;
-    case SECTION_LAYER:
-      {
-        Dwg_Object *obj = dwg_get_first_object (dwg, DWG_TYPE_LAYER_CONTROL);
-        if (obj)
-          {
-            Dwg_Object_LAYER_CONTROL *_obj = obj->tio.object->tio.LAYER_CONTROL;
-            obj->size = tbl->size;
-            obj->address = tbl->address;
-          }
-        //dwg_add_LAYER (dwg, NULL);
-      }
-      break;
-    case SECTION_STYLE:
-      {
-        Dwg_Object *obj = dwg_get_first_object (dwg, DWG_TYPE_STYLE_CONTROL);
-        if (obj)
-          {
-            Dwg_Object_STYLE_CONTROL *_obj = obj->tio.object->tio.STYLE_CONTROL;
-            obj->size = tbl->size;
-            obj->address = tbl->address;
-          }
-        //dwg_add_STYLE (dwg, NULL);
-      }
-      break;
-    case SECTION_LTYPE:
-      {
-        Dwg_Object *obj = dwg_get_first_object (dwg, DWG_TYPE_LTYPE_CONTROL);
-        if (obj)
-          {
-            Dwg_Object_LTYPE_CONTROL *_obj = obj->tio.object->tio.LTYPE_CONTROL;
-            obj->size = tbl->size;
-            obj->address = tbl->address;
-          }
-        //dwg_add_LTYPE (dwg, NULL);
-      }
-      break;
-    case SECTION_VIEW:
-      {
-        Dwg_Object *obj = dwg_get_first_object (dwg, DWG_TYPE_VIEW_CONTROL);
-        if (obj)
-          {
-            Dwg_Object_VIEW_CONTROL *_obj = obj->tio.object->tio.VIEW_CONTROL;
-            obj->size = tbl->size;
-            obj->address = tbl->address;
-          }
-      }
-      break;
-    // TODO: more only with r11
+
+#define CASE_TBL(TBL)                                                         \
+  case SECTION_##TBL:                                                         \
+    {                                                                         \
+      Dwg_Object *obj = dwg_get_first_object (dwg, DWG_TYPE_##TBL##_CONTROL); \
+      if (obj)                                                                \
+        {                                                                     \
+          Dwg_Object_##TBL##_CONTROL *_obj                                    \
+              = obj->tio.object->tio.TBL##_CONTROL;                           \
+          obj->size = tbl->size;                                              \
+          obj->address = tbl->address;                                        \
+        }                                                                     \
+    }                                                                         \
+    break
+
+    CASE_TBL (LAYER);
+    CASE_TBL (STYLE);
+    CASE_TBL (LTYPE);
+    CASE_TBL (VIEW);
+    CASE_TBL (UCS);   // since r10
+    CASE_TBL (VPORT);
+    CASE_TBL (DIMSTYLE);
+    CASE_TBL (APPID); // since r11
+    CASE_TBL (VX);
     default:
       LOG_ERROR ("Yet unhandled section id %d", id);
     }
   if (tbl->number && (tbl->address + (tbl->number * tbl->size) > dat->size))
     {
       LOG_ERROR ("%s.size overflow", tbl->name)
       return DWG_ERR_INVALIDDWG;
     }
   return 0;
 }
@@ -636,284 +612,295 @@ EXPORT int
 decode_preR13 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)
 {
   BITCODE_RL entities_start = 0, entities_end = 0;
   BITCODE_RL blocks_start = 0, blocks_size = 0, blocks_end = 0;
   BITCODE_RL rl1, rl2, blocks_max = 0xFFFFFFFF, num_entities;
   BITCODE_RS rs2;
   Dwg_Object *obj = NULL;
   int tbl_id;
   int error = 0;
+  int num_sections = 5;
 
   loglevel = dat->opts & DWG_OPTS_LOGLEVEL;
   {
     int i;
     Dwg_Header *_obj = (Dwg_Header *)&dwg->header;
     Bit_Chain *hdl_dat = dat;
     dat->byte = 0x06;
     // clang-format off
     #include "header.spec"
     // clang-format on
   }
   LOG_TRACE ("@0x%lx\n", dat->byte); // 0x14
 
   // setup all the new control objects
   error |= dwg_add_Document (dwg, 0);
 
   // 5 tables + header + block. VIEW = 6
+  SINCE (R_10)
+    num_sections += 3;
+  SINCE (R_10)
+    num_sections += 2;
   dwg->header.section = (Dwg_Section *)calloc (sizeof (Dwg_Section),
-                                               dwg->header.numsections + 2);
+                                               num_sections + 2);
   if (!dwg->header.section)
     {
       LOG_ERROR ("Out of memory");
       return DWG_ERR_OUTOFMEM;
     }
   PRE (R_2_0b) {
     bit_read_RC (dat); // the 6th zero
     LOG_TRACE ("zero[6]: 0 [RC 0]\n");
   }
   SINCE (R_2_0b) {
     entities_start = bit_read_RL (dat);
     LOG_TRACE ("entities_start: " FORMAT_RL " (" FORMAT_RLx ") [RL]\n", entities_start, entities_start);
     entities_end = bit_read_RL (dat);
     LOG_TRACE ("entities_end: " FORMAT_RL " (" FORMAT_RLx ") [RL]\n", entities_end, entities_end);
     blocks_start = bit_read_RL (dat);
     LOG_TRACE ("blocks_start: " FORMAT_RL " (" FORMAT_RLx ") [RL]\n", blocks_start, blocks_start);
     blocks_size = bit_read_RL (dat);
     if (blocks_size >= 0x40000000) {
       LOG_TRACE ("blocks_size: 0x40000000 | " FORMAT_RL " [RLx]\n", blocks_size & 0x3fffffff);
     }
     else {
       LOG_TRACE ("blocks_size: " FORMAT_RL " [RL]\n", blocks_size);
     }
     blocks_end = bit_read_RL (dat);
     LOG_TRACE ("blocks_end: " FORMAT_RL " (" FORMAT_RLx ") [RL]\n", blocks_end, blocks_end);
     blocks_max = bit_read_RL (dat); // 0x80000000
     LOG_TRACE ("blocks_max: " FORMAT_RLx " [RLx]\n", blocks_max);
     tbl_id = 0;
     dwg->header.section[0].number = 0;
     dwg->header.section[0].type = (Dwg_Section_Type)SECTION_HEADER_R11;
     strcpy (dwg->header.section[0].name, "HEADER");
 
     // The 5 tables (num_sections always 5): 3 RS + 1 RL address
     LOG_INFO ("==========================================\n")
     if (decode_preR13_section_hdr ("BLOCK", SECTION_BLOCK, dat, dwg)
         || decode_preR13_section_hdr ("LAYER", SECTION_LAYER, dat, dwg)
         || decode_preR13_section_hdr ("STYLE", SECTION_STYLE, dat, dwg)
         || decode_preR13_section_hdr ("LTYPE", SECTION_LTYPE, dat, dwg)
         || decode_preR13_section_hdr ("VIEW", SECTION_VIEW, dat, dwg))
       return DWG_ERR_INVALIDDWG;
   }
   LOG_TRACE ("@0x%lx\n", dat->byte); // 0x5e
   if (dat->size < 0x1f0) // AC1.50 0x1f9 74 vars
     {
       LOG_ERROR ("DWG too small %zu", (size_t)dat->size)
       return DWG_ERR_INVALIDDWG;
     }
 
   LOG_INFO ("==========================================\n")
   error |= decode_preR13_header_variables (dat, dwg);
   LOG_TRACE ("@0x%lx\n", dat->byte);
   if (error >= DWG_ERR_CRITICAL)
     return error;
   SINCE (R_11)
     {
       // crc16 + DWG_SENTINEL_R11_HEADER_END
       BITCODE_RS crc, crcc;
       BITCODE_TF r11_sentinel;
       crcc = bit_calc_CRC (0xC0C1, &dat->chain[0], dat->byte); // from 0 to now
       crc = bit_read_RS (dat);
       LOG_TRACE ("crc: %04X [RSx] from 0-0x%lx\n", crc, dat->byte - 2);
       if (crc != crcc)
         {
           LOG_ERROR ("Header CRC mismatch %04X <=> %04X", crc, crcc);
           error |= DWG_ERR_WRONGCRC;
         }
       r11_sentinel = bit_read_TF (dat, 16);
       LOG_TRACE ("r11_sentinel: ");
       LOG_TRACE_TF (r11_sentinel, 16) // == C46E6854F86E3330633EC1852ADC9401
       if (memcmp (r11_sentinel, dwg_sentinel (DWG_SENTINEL_R11_HEADER_END), 16))
         {
           LOG_ERROR ("DWG_SENTINEL_R11_HEADER_END mismatch");
           error |= DWG_ERR_WRONGCRC;
         }
       free (r11_sentinel);
     }
 
   PRE (R_10)
     num_entities = dwg->header_vars.numentities;
   else
     num_entities = 0;
   PRE (R_2_0b) {
     entities_start = dat->byte;
     entities_end = dwg->header_vars.dwg_size;
   }
-#if 0
-  if (dwg->header.numsections > 5) // dead code? r11 only?
+
+  // additional tables mixed-in since r10
+  if (dwg->header.numheader_vars > 158) // r10
     {
+      dat->byte = 0x3ef;
+      LOG_TRACE ("@0x%lx\n", dat->byte);
       decode_preR13_section_hdr ("UCS", SECTION_UCS, dat, dwg);
-      // skip: 0x500 - dat->bytes
       dat->byte = 0x500;
-      LOG_TRACE ("@0x%lx\n", dat->byte); // 0x23a
+      LOG_TRACE ("@0x%lx\n", dat->byte);
       decode_preR13_section_hdr ("VPORT", SECTION_VPORT, dat, dwg);
-      rl1 = bit_read_RL (dat);
-      rl2 = bit_read_RL (dat);
-      LOG_TRACE ("?2 long: 0x%x 0x%x\n", rl1, rl2);
+      dat->byte = 0x512;
+      LOG_TRACE ("@0x%lx\n", dat->byte);
       decode_preR13_section_hdr ("APPID", SECTION_APPID, dat, dwg);
-      rl1 = bit_read_RL (dat);
-      rs2 = bit_read_RS (dat);
-      LOG_TRACE ("?long+short: 0x%x 0x%x\n", rl1, (unsigned)rs2);
+      dat->byte = entities_start;
+    }
+  if (dwg->header.numheader_vars > 160) // r11
+    {
+      dat->byte = 0x522;
+      LOG_TRACE ("@0x%lx\n", dat->byte);
       decode_preR13_section_hdr ("DIMSTYLE", SECTION_DIMSTYLE, dat, dwg);
-      // skip: 0x69f - dat->bytes
       dat->byte = 0x69f;
+      LOG_TRACE ("@0x%lx\n", dat->byte);
       decode_preR13_section_hdr ("VX", SECTION_VX, dat, dwg);
+      dat->byte = entities_start;
     }
-#endif
 
   // entities
   if (dat->byte != entities_start)
     {
       LOG_WARN ("@0x%lx => entities_start 0x%x", dat->byte, entities_start);
       if (dat->byte < entities_start)
         {
           _DEBUG_HERE (dat->byte - entities_start)
         }
       dat->byte = entities_start;
     }
   error |= decode_preR13_entities (entities_start, entities_end, num_entities,
                                    entities_end - entities_start, 0, dat, dwg);
   if (error >= DWG_ERR_CRITICAL)
     return error;
   if (dat->byte != entities_end)
     {
       LOG_WARN ("@0x%lx => entities_end 0x%x", dat->byte, entities_end);
       dat->byte = entities_end;
     }
   PRE (R_2_0b) {
     // this has usually some slack at the end.
     return error;
   }
   LOG_INFO ("==========================================\n")
   //dat->byte += 20; /* crc + sentinel? 20 byte */
   error |= decode_preR13_section (SECTION_BLOCK, dat, dwg);
   error |= decode_preR13_section (SECTION_LAYER, dat, dwg);
   error |= decode_preR13_section (SECTION_STYLE, dat, dwg);
   error |= decode_preR13_section (SECTION_LTYPE, dat, dwg);
   error |= decode_preR13_section (SECTION_VIEW, dat, dwg);
-
-#if 0
-  if (dwg->header.numsections > 5) // dead code?
+#if 1
+  if (num_sections > 5) // r10
     {
       error |= decode_preR13_section (SECTION_UCS, dat, dwg);
       error |= decode_preR13_section (SECTION_VPORT, dat, dwg);
       error |= decode_preR13_section (SECTION_APPID, dat, dwg);
+    }
+  if (num_sections > 8) // r11
+    {
       error |= decode_preR13_section (SECTION_DIMSTYLE, dat, dwg);
       error |= decode_preR13_section (SECTION_VX, dat, dwg);
     }
 #endif
   if (error >= DWG_ERR_CRITICAL)
     return error;
 
   // block entities
   if (dat->byte != blocks_start)
     {
       BITCODE_TF unknown;
       int len = blocks_start - dat->byte;
       LOG_WARN ("\n@0x%lx => blocks_start 0x%x", dat->byte, blocks_start);
       if (dat->byte < blocks_start)
         {
           unknown = bit_read_TF (dat, len);
           LOG_TRACE ("unknown (%d):", len);
           LOG_TRACE_TF (unknown, len);
           free (unknown);
         }
       dat->byte = blocks_start;
     }
   num_entities = 0;
   VERSION (R_11)
     blocks_end -= 32; // ??
   error |= decode_preR13_entities (blocks_start, blocks_end,
                                    num_entities, blocks_size & 0x3FFFFFFF,
                                    blocks_max, dat, dwg);
   if (error >= DWG_ERR_CRITICAL)
     return error;
 
   PRE (R_11) {
     return error;
   }
   // only since r11 (AC1009)
   LOG_TRACE ("AUXHEADER: @0x%lx\n", dat->byte);
   // 36 byte: 9x long
   rl1 = bit_read_RL (dat);
   rl2 = bit_read_RL (dat);
   LOG_TRACE ("?2long: 0x%x 0x%x %f\n", rl1, rl2,
              (double)dat->chain[dat->byte - 8]);
   rl1 = bit_read_RL (dat);
   rl2 = bit_read_RL (dat);
   LOG_TRACE ("?2long: 0x%x 0x%x %f\n", rl1, rl2,
              (double)dat->chain[dat->byte - 8]);
   rl1 = bit_read_RL (dat);
   rl2 = bit_read_RL (dat);
   LOG_TRACE ("?2long: 0x%x 0x%x %f\n", rl1, rl2,
              (double)dat->chain[dat->byte - 8]);
   rl1 = bit_read_RL (dat);
   rl2 = bit_read_RL (dat);
   LOG_TRACE ("?2long: 0x%x 0x%x %f\n", rl1, rl2,
              (double)dat->chain[dat->byte - 8]);
   rl1 = bit_read_RL (dat);
   LOG_TRACE ("?1long: 0x%x\n", rl1);
 
   LOG_TRACE ("@0x%lx: 4 block ptrs chk\n", dat->byte);
   if ((rl1 = bit_read_RL (dat)) != entities_start)
     {
       LOG_WARN ("entities_start %x/%x", rl1, entities_start);
     }
   if ((rl1 = bit_read_RL (dat)) != entities_end)
     {
       LOG_WARN ("entities_end %x/%x", rl1, entities_end);
     }
   if ((rl1 = bit_read_RL (dat)) != blocks_start)
     {
       LOG_WARN ("blocks_start %x/%x", rl1, blocks_start);
     }
   if ((rl1 = bit_read_RL (dat)) != blocks_end)
     {
       LOG_WARN ("blocks_end %x/%x", rl1, blocks_end);
     }
   // 12 byte
   LOG_TRACE ("@0x%lx\n", dat->byte);
   rl1 = bit_read_RL (dat);
   rl2 = bit_read_RL (dat);
   LOG_TRACE ("?2long: 0x%x 0x%x\n", rl1, rl2);
   rl1 = bit_read_RL (dat);
   LOG_TRACE ("?1long: 0x%x\n", rl1);
 
-  rl1 = blocks_end + 36 + 4 * 4 + 12;
+  rl1 = blocks_end + 36 + 4 * 4 + 12; // ??
   DEBUG_HERE
   UNKNOWN_UNTIL (rl1);
   LOG_TRACE ("@0x%lx\n", dat->byte);
   decode_preR13_section_chk (SECTION_BLOCK, dat, dwg);
   decode_preR13_section_chk (SECTION_LAYER, dat, dwg);
   decode_preR13_section_chk (SECTION_STYLE, dat, dwg);
   decode_preR13_section_chk (SECTION_LTYPE, dat, dwg);
   decode_preR13_section_chk (SECTION_VIEW, dat, dwg);
-  if (dwg->header.numsections > 5) // dead code?
+  if (num_sections > 5) // dead code?
     {
       decode_preR13_section_chk (SECTION_UCS, dat, dwg);
       decode_preR13_section_chk (SECTION_VPORT, dat, dwg);
       decode_preR13_section_chk (SECTION_APPID, dat, dwg);
       decode_preR13_section_chk (SECTION_DIMSTYLE, dat, dwg);
       decode_preR13_section_chk (SECTION_VX, dat, dwg);
     }
   rl1 = bit_read_RL (dat);
   LOG_TRACE ("long 0x%x\n", rl1); // address
   if (dat->byte < dat->size)
     {
       int len = dat->size - dat->byte;
       BITCODE_TF unknown = bit_read_TF (dat, len);
       LOG_TRACE ("unknown (%d):", len);
       LOG_TRACE_TF (unknown, len);
       free (unknown);
     }
   if (dwg->dirty_refs)
     dwg_resolve_objectrefs_silent (dwg);
   return 0;
 }
diff --git a/src/dwg_api.c b/src/dwg_api.c
index 73881a05..9c4ec8be 100644
--- a/src/dwg_api.c
+++ b/src/dwg_api.c
@@ -22232,409 +22232,415 @@ dwg_add_u8_input (Dwg_Data *restrict dwg, const char *restrict u8str)
 /* The internal driver, which takes an existing dwg */
 EXPORT int dwg_add_Document (Dwg_Data *restrict dwg, const int imperial)
 {
   int error;
   Dwg_Object_BLOCK_CONTROL *block_control;
   Dwg_Object_BLOCK_HEADER *mspace, *pspace = NULL;
   Dwg_Object_STYLE *style;
   Dwg_Object_LAYER *layer;
   Dwg_Object_LTYPE *ltype;
   Dwg_Object_LTYPE_CONTROL *ltype_ctrl;
   Dwg_Object_DICTIONARY *nod, *dict, *layoutdict;
   Dwg_Object_MLINESTYLE *mlstyle;
   Dwg_Object_LAYOUT *layout;
   Dwg_Object_VPORT *vport_active;
   Dwg_Entity_VIEWPORT *pviewport;
   dwg_point_3d pt0 = { 0.0, 1.0, 0.0 };
   Dwg_Object *obj, *ctrl, *mspaceobj;
   time_t now;
   const char *canonical_media_name;
   struct dwg_versions *dwg_ver_struct;
   Dwg_Version_Type version = dwg->header.version;
 
   loglevel = dwg->opts & DWG_OPTS_LOGLEVEL;
   /* Set the import flag, so we don't encode to TU, just TV */
   dwg->opts |= DWG_OPTS_IN;
   dwg->dirty_refs = 0;
 
   if (!dwg->object_map)
     dwg->object_map = hash_new (200);
 
   if (version)
     dwg->header.from_version = version;
   else
     {
       version = dwg->header.version = dwg->header.from_version;
     }
   //dwg->header.is_maint = 0xf;
   //dwg->header.zero_one_or_three = 1;
   //dwg->header.dwg_version = 0x17; // prefer encode if dwg_version is 0
   dwg_ver_struct = (struct dwg_versions *)dwg_version_struct (version);
   dwg->header.dwg_version = dwg_ver_struct->dwg_version;
   //dwg->header.maint_version = 29;
   dwg->header.codepage = 30; // FIXME: local codepage if <r2007
   //dwg->header.num_sections = 5;
   //dwg->header.section = (Dwg_Section *)calloc (
   //    dwg->header.num_sections, sizeof (Dwg_Section));
 
   dwg->header_vars.unknown_0 = 412148564080.0; // unit1_ration
   dwg->header_vars.unknown_1 = 1.0;
   dwg->header_vars.unknown_2 = 1.0;
   dwg->header_vars.unknown_3 = 1.0;
   if (version > R_11) // also meter sometimes. unit1_text
     dwg->header_vars.unknown_text1 = dwg_add_u8_input (dwg, "m");
   dwg->header_vars.DIMASO = 1;
   dwg->header_vars.DIMSHO = 1; // Obsolete
   dwg->header_vars.REGENMODE = 1;
   dwg->header_vars.FILLMODE = 1;
   dwg->header_vars.PSLTSCALE = 1;
   dwg->header_vars.BLIPMODE = 1;
   dwg->header_vars.USRTIMER = 1;
   //dwg->header_vars.SKPOLY = 0;
   dwg->header_vars.TILEMODE = 1;
   dwg->header_vars.VISRETAIN = 1;
   dwg->header_vars.ATTREQ = 1;
   dwg->header_vars.MIRRTEXT = 1;
   dwg->header_vars.WORLDVIEW = 1;
   dwg->header_vars.TILEMODE = 1;
   dwg->header_vars.DELOBJ = 1;
   dwg->header_vars.PROXYGRAPHICS = 1;
   dwg->header_vars.DRAGMODE = 2;
   dwg->header_vars.TREEDEPTH = 3020;
   dwg->header_vars.LUNITS = 2;
   dwg->header_vars.LUPREC = 4;
   dwg->header_vars.ATTMODE = 1;
   dwg->header_vars.COORDS = 1;
   dwg->header_vars.PICKSTYLE = 1;
   dwg->header_vars.SPLINESEGS = 8;
   dwg->header_vars.SURFU = 6;
   dwg->header_vars.SURFV = 6;
   dwg->header_vars.SURFTYPE = 6;
   dwg->header_vars.SURFTAB1 = 6;
   dwg->header_vars.SURFTAB2 = 6;
   dwg->header_vars.SPLINETYPE = 6;
   dwg->header_vars.SHADEDGE = 3;
   dwg->header_vars.SHADEDIF = 70;
   dwg->header_vars.MAXACTVP = 48;
   dwg->header_vars.ISOLINES = 4;
   dwg->header_vars.TEXTQLTY = 50;
   dwg->header_vars.LTSCALE = 1.0;
   dwg->header_vars.TEXTSIZE = 0.2;
   dwg->header_vars.TRACEWID = 0.05;
   dwg->header_vars.SKETCHINC = 0.1;
   dwg->header_vars.FACETRES = 0.5;
   dwg->header_vars.CMLSCALE = imperial ? 1.0 : 20.0;
   dwg->header_vars.CELTSCALE = 1.0;
   dwg->header_vars.INSUNITS = imperial ? 1 : 4;
   if (!dwg->header_vars.MENU)
     dwg->header_vars.MENU = dwg_add_u8_input (dwg, "acad");
 
   dwg->header_vars.FLAGS = 0x2a1d; // or 0x281d
   dwg->header_vars.CELWEIGHT = -1; // => FLAGS & 0x1f + lweight lookup
   now = time(NULL);
   dwg->header_vars.TDCREATE = (BITCODE_TIMEBLL){ now / 3600, now / 86400 };
   // CECOLOR.index: 256 [CMC.BS 62]
   dwg->header_vars.CECOLOR = (BITCODE_CMC){ 256, 0 }; // ByLayer
   if (version > R_11)
     {
       // HANDSEED: 0.1.49 [H 0] // FIXME needs to be updated on encode
       dwg->header_vars.HANDSEED = dwg_add_handleref (dwg, 0, 0x25, NULL);
       dwg->header_vars.PEXTMIN
         = (BITCODE_3BD){ 100000000000000000000.0, 100000000000000000000.0,
                          100000000000000000000.0 };
       dwg->header_vars.PEXTMAX
         = (BITCODE_3BD){ -100000000000000000000.0, -100000000000000000000.0,
                          -100000000000000000000.0 };
       // dwg->header_vars.PUCSORG = { 0.0, 0.0, 0.0 };
       dwg->header_vars.PUCSXDIR = (BITCODE_3BD){ 1.0, 0.0, 0.0 };
       dwg->header_vars.PUCSYDIR = (BITCODE_3BD){ 0.0, 1.0, 0.0 };
       // PUCSNAME: (5.0.0) abs:0 [H 2]
     }
   else
     {
       dwg->header_vars.oldCECOLOR_lo = 15;
     }
   dwg->header_vars.EXTMIN
       = (BITCODE_3BD){ 100000000000000000000.0, 100000000000000000000.0,
                        100000000000000000000.0 };
   dwg->header_vars.EXTMAX
       = (BITCODE_3BD){ -100000000000000000000.0, -100000000000000000000.0,
                        -100000000000000000000.0 };
   if (imperial)
     {
       dwg->header_vars.PLIMMAX = (BITCODE_2DPOINT){ 12.0, 9.0 };
       dwg->header_vars.LIMMAX = (BITCODE_2DPOINT){ 12.0, 9.0 };
     }
   else
     {
       dwg->header_vars.PLIMMAX = (BITCODE_2DPOINT){ 420.0, 297.0 };
       dwg->header_vars.LIMMAX = (BITCODE_2DPOINT){ 420.0, 297.0 };
     }
   // UCSORG: (0.0, 0.0, 0.0) [3BD 10]
   // UCSXDIR: (1.0, 0.0, 0.0) [3BD 10]
   // UCSYDIR: (0.0, 1.0, 0.0) [3BD 10]
   dwg->header_vars.UCSXDIR = (BITCODE_3BD){ 1.0, 0.0, 0.0 };
   dwg->header_vars.UCSYDIR = (BITCODE_3BD){ 0.0, 1.0, 0.0 };
   // UCSNAME: (5.0.0) abs:0 [H 2]
   dwg->header_vars.DIMTIH = 1;
   dwg->header_vars.DIMTOH = 1;
   dwg->header_vars.DIMALTD = 2;
   dwg->header_vars.DIMTOLJ = 1;
   dwg->header_vars.DIMFIT = 3;
   dwg->header_vars.DIMUNIT = 2;
   dwg->header_vars.DIMDEC = 4;
   dwg->header_vars.DIMTDEC = 4;
   dwg->header_vars.DIMALTU = 2;
   dwg->header_vars.DIMALTTD = 2;
   dwg->header_vars.DIMSCALE = 1.0;
   dwg->header_vars.DIMASZ = 0.18;
   dwg->header_vars.DIMEXO = 0.0625;
   dwg->header_vars.DIMDLI = 0.38;
   dwg->header_vars.DIMEXE = 0.18;
   dwg->header_vars.DIMTXT = 0.18;
   dwg->header_vars.DIMCEN = 0.09;
   dwg->header_vars.DIMALTF = 25.4;
   dwg->header_vars.DIMLFAC = 1.0;
   dwg->header_vars.DIMTFAC = 1.0;
   dwg->header_vars.DIMGAP = 0.09;
   //dwg->header_vars.DIMPOST = dwg_add_u8_input (dwg, "");
   //dwg->header_vars.DIMAPOST = dwg_add_u8_input (dwg, "");
   //dwg->header_vars.DIMBLK_T = dwg_add_u8_input (dwg, "");
   //dwg->header_vars.DIMBLK1_T = dwg_add_u8_input (dwg, "");
   //dwg->header_vars.DIMBLK2_T = dwg_add_u8_input (dwg, "");
   if (version > R_2_21 && version < R_13)
     dwg->header_vars.circle_zoom_percent = 100;
 
   dwg->header_vars.DIMCLRD = (BITCODE_CMC){ 0 };
   dwg->header_vars.DIMCLRE = (BITCODE_CMC){ 0 };
   dwg->header_vars.DIMCLRT = (BITCODE_CMC){ 0 };
 
   dwg->header_vars.MEASUREMENT = imperial ? 0 : 256;
   canonical_media_name = imperial ? "ANSI_A_(8.50_x_11.00_Inches)"
                                   : "ISO_A1_(841.00_x_594.00_MM)";
 
   // BLOCK_CONTROL_OBJECT: (3.1.1) abs:1 [H 0]
   block_control = dwg_add_BLOCK_CONTROL (dwg,
       0x1F, // model space
       version >= R_13 ? 0x20 : 0); // paper space
   // LAYER_CONTROL_OBJECT: (3.1.2) abs:2 [H 0]
   dwg_add_LAYER (dwg, NULL);
   // STYLE_CONTROL_OBJECT: (3.1.3) abs:3 [H 0]
   dwg_add_STYLE (dwg, NULL);
   // hole at 4
   dwg_set_next_hdl (dwg, 0x5);
   // LTYPE_CONTROL_OBJECT: (3.1.5) abs:5 [H 0]
   dwg_add_LTYPE (dwg, NULL);
   // VIEW_CONTROL_OBJECT: (3.1.6) abs:6 [H 0]
   dwg_add_VIEW (dwg, NULL);
   //dwg->view_control = *dwg->object[4].tio.object->tio.VIEW_CONTROL;
-  if (version > R_11)
+  if (version >= R_10)
     {
       // UCS_CONTROL_OBJECT: (3.1.7) abs:7 [H 0]
       dwg_add_UCS (dwg, &pt0, NULL, NULL, NULL);
       //dwg->ucs_control = *dwg->object[5].tio.object->tio.UCS_CONTROL;
       // VPORT_CONTROL_OBJECT: (3.1.8) abs:8 [H 0]
       dwg_add_VPORT (dwg, NULL);
       //dwg->vport_control = *dwg->object[6].tio.object->tio.VPORT_CONTROL;
       // APPID_CONTROL_OBJECT: (3.1.9) abs:9 [H 0]
       dwg_add_APPID (dwg, NULL);
+    }
+  if (version >= R_11)
+    {
       // DIMSTYLE_CONTROL_OBJECT: (3.1.A) abs:A [H 0]
       // We don't create DIMSTYLE Standard upfront, only on demand.
       dwg_add_DIMSTYLE (dwg, NULL);
       // VX_CONTROL_OBJECT: (3.1.B) abs:B [H 0]
       dwg_add_VX (dwg, NULL); // TODO only <r2000
+    }
+  if (version > R_11)
+    {
       // DICTIONARY_NAMED_OBJECT: (3.1.C) abs:C [H 0]
       nod = dwg_add_DICTIONARY (dwg, NULL, (const BITCODE_T) "NAMED_OBJECT", 0UL);
       dwg->header_vars.DICTIONARY_NAMED_OBJECT
         = dwg_add_handleref (dwg, 3, 0xC, NULL);
       // DICTIONARY_ACAD_GROUP: (5.1.D) abs:D [H 0]
       dwg_add_DICTIONARY (dwg, (const BITCODE_T) "ACAD_GROUP", NULL, 0UL);
       dwg->header_vars.DICTIONARY_ACAD_GROUP = dwg_add_handleref (dwg, 5, 0xD, NULL);
       dwg_add_DICTIONARY_item (nod, (const BITCODE_T) "ACAD_GROUP", 0xD);
     }
   if (version >= R_2000)
     {
       Dwg_Object_PLACEHOLDER *plh;
       // DICTIONARY (5.1.E) //FIXME
       dwg_add_DICTIONARYWDFLT (dwg, (const BITCODE_T) "ACAD_PLOTSTYLENAME",
                                (const BITCODE_T) "Normal", 0xF);
       dwg->header_vars.DICTIONARY_PLOTSTYLENAME
           = dwg_add_handleref (dwg, 5, 0xE, NULL);
       // PLOTSTYLE (2.1.F)
       plh = dwg_add_PLACEHOLDER (dwg); // PLOTSTYLE
       obj = dwg_obj_generic_to_object (plh, &error);
       obj->tio.object->ownerhandle = dwg_add_handleref (dwg, 4, 0xE, obj);
       add_obj_reactor (obj->tio.object, 0xE);
     }
   else
     {
       dwg_set_next_hdl (dwg, 0x10);
     }
   if (version > R_11)
     {
       // LAYER: (0.1.10)
       layer = dwg_add_LAYER (dwg, (const BITCODE_T) "0");
       layer->color = (BITCODE_CMC){ 7 };
       layer->ltype = dwg_add_handleref (dwg, 5, 0x16, NULL); // Continuous
       layer->plotstyle = dwg_add_handleref (dwg, 5, 0xF, NULL);
       // CLAYER: (5.1.F) abs:F [H 8]
       dwg->header_vars.CLAYER = dwg_add_handleref (dwg, 5, 0x10, NULL);
       //ctrl = dwg_get_first_object (dwg, DWG_TYPE_LAYER_CONTROL);
       //if (ctrl)
       //  dwg->layer_control = ctrl->tio.object->tio.LAYER_CONTROL;
       //  STYLE: (0.1.11)
       style = dwg_add_STYLE (dwg, "Standard");
       style->font_file = dwg_add_u8_input (dwg, "txt");
       style->last_height = 0.2;
       // TEXTSTYLE: (5.1.11) [H 7]
       dwg->header_vars.TEXTSTYLE = dwg_add_handleref (dwg, 5, 0x11, NULL);
       dwg->header_vars.DIMTXSTY = dwg->header_vars.TEXTSTYLE;
       //ctrl = dwg_get_first_object (dwg, DWG_TYPE_STYLE_CONTROL);
       //if (ctrl)
       //  dwg->style_control = ctrl->tio.object->tio.STYLE_CONTROL;
       //  APPID "ACAD": (0.1.12)
       dwg_add_APPID (dwg, "ACAD");
       //  hole at 13. already in r13
       dwg_set_next_hdl (dwg, 0x14);
       ctrl = dwg_get_first_object (dwg, DWG_TYPE_LTYPE_CONTROL);
       ltype_ctrl = ctrl->tio.object->tio.LTYPE_CONTROL;
       // LTYPE->byblock: (3.1.14)
       ltype = dwg_add_LTYPE (dwg, "BYBLOCK");
       ltype_ctrl->num_entries--;
       ltype_ctrl->byblock = dwg_add_handleref (dwg, 3, 0x14, NULL);
       dwg->header_vars.LTYPE_BYBLOCK = dwg_add_handleref (dwg, 5, 0x14, NULL);
       // LTYPE->bylayer: (3.1.15)
       dwg_add_LTYPE (dwg, "BYLAYER");
       ltype_ctrl->num_entries--;
       ltype_ctrl->bylayer = dwg_add_handleref (dwg, 3, 0x15, NULL);
       dwg->header_vars.LTYPE_BYLAYER = dwg_add_handleref (dwg, 5, 0x15, NULL);
       // CELTYPE: (5.1.14) abs:14 [H 6]
       dwg->header_vars.CELTYPE = dwg_add_handleref (dwg, 5, 0x15, NULL);
       // LTYPE_CONTINUOUS: (5.1.16)
       ltype = dwg_add_LTYPE (dwg, "CONTINUOUS");
       ltype->description = dwg_add_u8_input (dwg, "Solid line");
       dwg->header_vars.LTYPE_CONTINUOUS
           = dwg_add_handleref (dwg, 5, 0x16, NULL);
     }
 
   if (version >= R_13)
     {
       // DICTIONARY ACAD_MLINESTYLE: (5.1.17) abs:E [H 0]
       dwg_add_DICTIONARY (dwg, "ACAD_MLINESTYLE", "Standard", 0x18);
       dwg->header_vars.DICTIONARY_ACAD_MLINESTYLE
         = dwg_add_handleref (dwg, 5, 0x17, NULL);
       // MLINESTYLE: (0.1.18)
       mlstyle = dwg_add_MLINESTYLE (dwg, "Standard");
       obj = dwg_obj_generic_to_object (mlstyle, &error);
       dwg->header_vars.CMLSTYLE
         = dwg_add_handleref (dwg, 5, obj->handle.value, NULL);
 
       // DICTIONARY ACAD_PLOTSETTINGS: (5.1.19)
       dwg_add_DICTIONARY (dwg, "ACAD_PLOTSETTINGS", NULL, 0);
       dwg->header_vars.DICTIONARY_PLOTSETTINGS
         = dwg_add_handleref (dwg, 5, 0x19, NULL);
     }
   if (version >= R_2000)
     {
       // DICTIONARY_LAYOUT: (5.1.1A)
       layoutdict = dwg_add_DICTIONARY (dwg, "ACAD_LAYOUT", NULL, 0);
       obj = dwg_obj_generic_to_object (layoutdict, &error);
       dwg->header_vars.DICTIONARY_LAYOUT
           = dwg_add_handleref (dwg, 5, obj->handle.value, NULL);
     }
   // DIMSTYLE: (5.1.1D) abs:1D [H 2]
 
   // hole until 1F
   dwg_set_next_hdl (dwg, 0x1F);
   // BLOCK_RECORD_MSPACE: (5.1.1F)
   mspace = dwg_add_BLOCK_HEADER (dwg, "*MODEL_SPACE");
   mspaceobj = dwg_obj_generic_to_object (mspace, &error);
   block_control->num_entries--;
   dwg->header_vars.BLOCK_RECORD_MSPACE
       = dwg_add_handleref (dwg, 5, mspaceobj->handle.value, NULL);
   dwg->header_vars.BLOCK_RECORD_MSPACE->obj = mspaceobj;
   block_control->model_space
       = dwg_add_handleref (dwg, 3, mspaceobj->handle.value, NULL);
   if (version >= R_13)
     {
       // BLOCK_RECORD_PSPACE: (5.1.20)
       pspace = dwg_add_BLOCK_HEADER (dwg, "*PAPER_SPACE");
       obj = dwg_obj_generic_to_object (pspace, &error);
       block_control->num_entries--;
       if (!block_control->num_entries)
         {
           free (block_control->entries);
           block_control->entries = NULL;
         }
       dwg->header_vars.BLOCK_RECORD_PSPACE
         = dwg_add_handleref (dwg, 5, obj->handle.value, NULL);
       dwg->header_vars.BLOCK_RECORD_PSPACE->obj = obj;
       block_control->paper_space
         = dwg_add_handleref (dwg, 3, obj->handle.value, NULL);
       dwg->block_control = *block_control;
       // BLOCK: (5.1.21)
       dwg_add_BLOCK (pspace, "*PAPER_SPACE");
       // ENDBLK: (5.1.22)
       dwg_add_ENDBLK (pspace);
     }
   // LAYOUT (0.1.23)
   //layout = dwg_add_LAYOUT (layoutdict);
   //pspace->layout = dwg_add_handleref (dwg, 5, 0x23, NULL);
 
   {
     // BLOCK: (5.1.24)
     Dwg_Entity_BLOCK *block = dwg_add_BLOCK (mspace, "*MODEL_SPACE");
     if (dwg->header.version < R_13) // fixup the type
       {
         obj = dwg_obj_generic_to_object (block, &error);
         obj->type = DWG_TYPE_UNUSED; // dont encode it
       }
   }
   {
     // ENDBLK: (5.1.25)
     Dwg_Entity_ENDBLK *endblk = dwg_add_ENDBLK (mspace);
     if (dwg->header.version < R_13) // fixup the type
       {
         obj = dwg_obj_generic_to_object (endblk, &error);
         obj->type = DWG_TYPE_UNUSED; // dont encode it
       }
   }
   if (dwg->header.version >= R_2000)
     {
 #ifdef NEED_VPORT_FOR_MODEL_LAYOUT
       // VPORT (0.1.26)
       vport_active = dwg_add_VPORT (dwg, "*Active");
       // LAYOUT (0.1.27)
       obj = dwg_obj_generic_to_object (vport_active, &error);
       layout = dwg_add_LAYOUT (obj, "Model", canonical_media_name);
 #else
       layout = dwg_add_LAYOUT (mspaceobj, "Model", canonical_media_name);
 #endif
       obj = dwg_obj_generic_to_object (layout, &error);
       mspace->layout = dwg_add_handleref (dwg, 5, obj->handle.value, NULL);
 
 #ifdef NEED_VPORT_FOR_MODEL_LAYOUT
       // VIEWPORT (0.1.28)
       pviewport = dwg_add_VIEWPORT (pspace, "");
       // LAYOUT (0.1.29)
       obj = dwg_obj_generic_to_object (pviewport, &error);
 #else
       obj = dwg_obj_generic_to_object (pspace, &error);
 #endif
       layout = dwg_add_LAYOUT (obj, "Layout1", canonical_media_name);
       obj = dwg_obj_generic_to_object (layout, &error);
       pspace->layout = dwg_add_handleref (dwg, 5, obj->handle.value, NULL);
     }
 
   // a non-invasive variant of resolve_objectref_vector()
   for (unsigned i = 0; i < dwg->num_object_refs; i++)
     {
       Dwg_Object_Ref *ref = dwg->object_ref[i];
       // possibly update the obj if realloced
       if ((obj = dwg_resolve_handle (dwg, ref->absolute_ref)))
         ref->obj = obj;
     }
   dwg->dirty_refs = 0;
   return 0;
 }
 
 /* Initialize a new dwg. Which template, imperial or metric */
diff --git a/src/encode.c b/src/encode.c
index b2762452..fe9344be 100644
--- a/src/encode.c
+++ b/src/encode.c
@@ -2133,1615 +2133,1633 @@ EXPORT int
 dwg_encode (Dwg_Data *restrict dwg, Bit_Chain *restrict dat)
 {
   int ckr_missing = 1;
   int error = 0;
   BITCODE_BL i, j;
   long unsigned int section_address;
   long unsigned int pvzadr;
   unsigned int ckr;
   unsigned int sec_size = 0;
   long unsigned int last_offset;
   BITCODE_BL last_handle;
   Object_Map *omap;
   Bit_Chain *old_dat = NULL, *str_dat, *hdl_dat;
   int sec_id;
   Dwg_Version_Type orig_from_version = dwg->header.from_version;
   Bit_Chain sec_dat[SECTION_SYSTEM_MAP + 1]; // to encode each r2004 section
   // preR13 vars:
   BITCODE_RL entities_start, entities_end;
   BITCODE_RL blocks_start, blocks_end;
   BITCODE_RL blocks_offset = 0x40000000;
   BITCODE_RL blocks_max = 0x80000000;
 
   dwg->cur_index = 0;
   if (dwg->opts)
     loglevel = dwg->opts & DWG_OPTS_LOGLEVEL;
 #ifdef USE_TRACING
   /* Before starting, set the logging level, but only do so once.  */
   if (!env_var_checked_p)
     {
       char *probe = getenv ("LIBREDWG_TRACE");
       if (probe)
         loglevel = atoi (probe);
       env_var_checked_p = true;
     }
 #endif /* USE_TRACING */
 
   if (dwg->header.version != dwg->header.from_version)
     LOG_TRACE ("Encode version %s (%s) from version %s (%s)\n",
                dwg_version_codes (dwg->header.version),
                dwg_version_type (dwg->header.version),
                dwg_version_codes (dwg->header.from_version),
                dwg_version_type (dwg->header.from_version))
   else
       LOG_TRACE ("Encode version %s (%s)\n",
 		 dwg_version_codes (dwg->header.version),
 		 dwg_version_type (dwg->header.version))
 
 #ifdef ENCODE_UNKNOWN_AS_DUMMY
   // We cannot write unknown_bits into another version, or when it's coming
   // from DXF. Write a PLACEHOLDER/DUMMY or POINT instead. Later maybe PROXY.
   // This is controversial and breaks roundtrip tests, but helps
   // ACAD imports.
   if (dwg->header.version != dwg->header.from_version
       || (dwg->opts & DWG_OPTS_IN))
     {
       int fixup = 0;
       // Scan for invalid/unstable/unsupported objects and entities
       // and eliminate or replace them with placeholders.
       LOG_TRACE ("Scan for unsupported objects\n");
       for (i = 0; i < dwg->num_objects; i++)
         {
           Dwg_Object *obj = &dwg->object[i];
           if (obj->fixedtype == DWG_TYPE_UNKNOWN_OBJ
               || obj->fixedtype == DWG_TYPE_UNKNOWN_ENT
               // WIPEOUT causes hang, TABLEGEOMETRY crash
               || (dwg->opts & DWG_OPTS_IN &&
                   (obj->fixedtype == DWG_TYPE_WIPEOUT ||
                    obj->fixedtype == DWG_TYPE_TABLEGEOMETRY)))
             {
               fixup++;
               break;
             }
         }
       if (fixup)
         {
           unsigned long new_appid;
           BITCODE_BS placeholder_type = 0;
           LOG_TRACE ("Found unsupported objects, add APPID LibreDWG\n");
           new_appid = add_LibreDWG_APPID (dwg);
           if (new_appid)
             {
               fixup = 0;
               // if not found leaves placeholder_type at 0 to use DUMMY
               dwg_find_class (dwg, "ACDBPLACEHOLDER", &placeholder_type);
               if (placeholder_type < 500)
                 {
                   LOG_ERROR ("Invalid class_id %d for ACDBPLACEHOLDER",
                              (int)placeholder_type);
                   placeholder_type = 0;
                 }
               for (i = 0; i < dwg->num_objects; i++)
                 {
                   Dwg_Object *obj = &dwg->object[i];
                   if (obj->fixedtype == DWG_TYPE_UNKNOWN_OBJ
                       || obj->fixedtype == DWG_TYPE_UNKNOWN_ENT
                       || (dwg->opts & DWG_OPTS_IN &&
                           (obj->fixedtype == DWG_TYPE_WIPEOUT ||
                            obj->fixedtype == DWG_TYPE_TABLEGEOMETRY)))
                     {
                       fixup++;
                       // replace entities with points, objects with
                       // placeholders
                       encode_unknown_as_dummy (dat, obj, placeholder_type);
                     }
                   // what to do with links to MATERIAL/...
                   if (obj->handle.value == 0xC
                       && obj->fixedtype == DWG_TYPE_DICTIONARY)
                     fixup_NOD (dwg, obj); // named object dict
                 }
               LOG_TRACE ("Fixed %d unsupported objects\n\n", fixup);
             }
         }
     }
 #endif
 
   bit_chain_alloc (dat);
   hdl_dat = dat; // splitted later in objects/entities
   if (!dat->version)
     {
       dat->version = dwg->header.version;
       dat->from_version = dwg->header.from_version;
       dat->opts = dwg->opts;
     }
 
   /*------------------------------------------------------------
    * Header
    */
   strcpy ((char *)dat->chain,
           dwg_version_codes (dwg->header.version)); // Chain version
   dat->byte += 6;
 
   {
     // set dwg_version from release
     const struct dwg_versions *_verp = dwg_version_struct (dwg->header.version);
     Dwg_Header *_obj = &dwg->header;
     Dwg_Object *obj = NULL;
     if (!_obj->dwg_version) // ie from DXF
       {
         _obj->zero_one_or_three = 1;
         if (_verp)
           _obj->dwg_version = _verp->dwg_version;
         if (dwg->header.version > R_13)
           {
             // can be improved with r2004 by another lookup table
             _obj->is_maint = 0xf;
             _obj->maint_version = 29;
           }
         /*
         switch (dwg->header.version)
           {
           case R_9:
             _obj->dwg_version = 0x0b;
             break;
           case R_10:
             _obj->dwg_version = 0x0d;
             break;
           case R_11:
             _obj->dwg_version = 0x10;
             break;
           case R_13:
             _obj->dwg_version = 0x13;
             break;
           case R_13c3:
             _obj->dwg_version = 0x14;
             break;
           case R_14:
             _obj->dwg_version = 0x15;
             break;
           case R_2000:
             _obj->dwg_version = 0x17;
             _obj->is_maint = 0xf;
             break;
           case R_2004:
             _obj->dwg_version = 0x19; // or 0x18/0x1a
             _obj->is_maint = 0x68;
             break;
           case R_2007:
             _obj->dwg_version = 0x1b;
             _obj->is_maint = 0x32;
             break;
           case R_2010:
             _obj->dwg_version = 0x1d;
             _obj->is_maint = 0x6d;
             break;
           case R_2013:
             _obj->dwg_version = 0x1f;
             _obj->is_maint = 0x7d;
             break;
           case R_2018:
             _obj->dwg_version = 0x21;
             _obj->is_maint = 0x1d;
             break;
           case R_INVALID:
           case R_AFTER:
           case R_1_1:
           case R_1_2:
           case R_1_3:
           case R_1_4:
           case R_2_0:
           case R_2_1:
           case R_2_21:
           case R_2_22:
           case R_2_4:
           case R_2_5:
           case R_2_6:
           case R_9c1:
           case R_11b1:
           case R_11b2:
           case R_12:
           default:
             break;
           }
           */
         if (!_obj->app_dwg_version)
           _obj->app_dwg_version = _obj->dwg_version;
       }
     if (!_obj->codepage)
       _obj->codepage = 30;
 
     // clang-format off
     #include "header.spec"
     // clang-format on
   }
   PRE (R_2_0b) {
     bit_write_RC (dat, 0); // the 6th zero
     LOG_TRACE ("zero[6]: 0 [RC 0]\n");
   }
   section_address = dat->byte;
 
 #define WE_CAN                                                                \
   "This version of LibreDWG is only capable of encoding "                     \
   "versions r1.4-r2000 (code: AC1.40-AC1015) DWG files.\n"
 
   PRE (R_13)
   {
     BITCODE_RS num_entities;
-    BITCODE_RL hdr_offset;
+    BITCODE_RL hdr_offset, hdr_end;
     PRE (R_1_4)
       LOG_WARN (WE_CAN "We cannot encode pre-r1.4 DWG's yet");
     entities_start = entities_end = blocks_start = blocks_end = 0xFFFF;
 
     SINCE (R_2_0b)
     { // start with dummies, patched later
       bit_write_RL (dat, entities_start);
       bit_write_RL (dat, entities_end);
       bit_write_RL (dat, blocks_start);
       bit_write_RL (dat, blocks_offset);
       bit_write_RL (dat, blocks_end);
       //blocks_size = blocks_end - blocks_start;
       bit_write_RL (dat, blocks_max);
 
       // get the tables from the CONTROL objects
       encode_preR13_section_hdr ("BLOCK", SECTION_BLOCK, dat, dwg);
       encode_preR13_section_hdr ("LAYER", SECTION_LAYER, dat, dwg);
       encode_preR13_section_hdr ("STYLE", SECTION_STYLE, dat, dwg);
       encode_preR13_section_hdr ("LTYPE", SECTION_LTYPE, dat, dwg);
       encode_preR13_section_hdr ("VIEW", SECTION_VIEW, dat, dwg);
     }
 
     hdr_offset = dat->byte;
 
     encode_preR13_header_variables (dat, dwg);
+    hdr_end = dat->byte;
+
+    SINCE (R_10)
+    {
+      dat->byte = 0x3ef;
+      encode_preR13_section_hdr ("UCS", SECTION_UCS, dat, dwg);
+      dat->byte = 0x500;
+      encode_preR13_section_hdr ("VPORT", SECTION_VPORT, dat, dwg);
+      dat->byte = 0x512;
+      encode_preR13_section_hdr ("APPID", SECTION_APPID, dat, dwg);
+      dat->byte = hdr_end;
+    }
     SINCE (R_11)
     {
-      // crc16 + DWG_SENTINEL_R11_HEADER_END
-      BITCODE_TF r11_sentinel = dwg_sentinel (DWG_SENTINEL_R11_HEADER_END);
-      bit_write_RS (dat, 0); // patch the crc later
+      BITCODE_TF r11_sentinel;
+      dat->byte = 0x522;
+      encode_preR13_section_hdr ("DIMSTYLE", SECTION_DIMSTYLE, dat, dwg);
+      dat->byte = 0x69f;
+      encode_preR13_section_hdr ("VX", SECTION_VX, dat, dwg);
+
+      dat->byte = hdr_end;
+      bit_write_RS (dat, 0); // patch the crc16 later
+      r11_sentinel = dwg_sentinel (DWG_SENTINEL_R11_HEADER_END);
       bit_write_TF (dat, r11_sentinel, 16);
       LOG_TRACE ("r11_sentinel: ");
       LOG_TRACE_TF (r11_sentinel, 16)
     }
     entities_start = dat->byte;
     LOG_TRACE ("\nentities 0x%x:\n", entities_start);
     dwg->cur_index = 0;
     num_entities = encode_preR13_entities (0, dat, dwg);
     dwg->cur_index += num_entities;
     entities_end = dat->byte;
     LOG_TRACE ("\nentities %u 0x%x - 0x%x\n", num_entities, entities_start,
                entities_end);
     //pvzadr = dat->byte;
 
     PRE (R_2_0b)
     {
       // patch these numbers into the header
       BITCODE_RL num_bytes = dat->byte;
       dat->byte = 0x0c + 24;
       if (num_bytes != dwg->header_vars.dwg_size)
         LOG_TRACE ("0x%x: num_bytes: %u [RL]\n", (unsigned)dat->byte, num_bytes);
       bit_write_RL (dat, num_bytes);
       if (num_entities != dwg->header_vars.numentities)
         LOG_TRACE ("0x%x: num_entities: %u [RS]\n", (unsigned)dat->byte, num_entities);
       bit_write_RS (dat, num_entities);
       dat->byte = num_bytes;
       LOG_TRACE ("Wrote %u bytes\n", num_bytes);
       return error;
     }
     SINCE (R_2_0b)
     {
       BITCODE_RL num_blocks;
       encode_preR13_section (SECTION_BLOCK, dat, dwg);
       encode_preR13_section (SECTION_LAYER, dat, dwg);
       encode_preR13_section (SECTION_STYLE, dat, dwg);
       encode_preR13_section (SECTION_LTYPE, dat, dwg);
       encode_preR13_section (SECTION_VIEW, dat, dwg);
       blocks_start = dat->byte;
       num_blocks = encode_preR13_entities (blocks_start, dat, dwg);
       blocks_end = dat->byte;
 
       // patch these numbers into the header
       dat->byte = 0x14; // section_address
       bit_write_RL (dat, entities_start);
       bit_write_RL (dat, entities_end);
       bit_write_RL (dat, blocks_start);
       bit_write_RL (dat, blocks_offset);
       bit_write_RL (dat, blocks_end);
       bit_write_RL (dat, blocks_max);
       LOG_TRACE ("blocks   0x%x (%d) - 0x%x (0x%x, 0x%x)\n", blocks_start,
                  blocks_end - blocks_start, blocks_end, blocks_offset, blocks_max);
       SINCE (R_11)
       {
         BITCODE_RS crc;
         dat->byte = entities_start - 18;
         crc = bit_calc_CRC (0xC0C1, &dat->chain[0], dat->byte);
         LOG_TRACE ("crc: %04X [RSx] from 0-0x%lx\n", crc, dat->byte);
         bit_write_RS (dat, crc);
       }
       dat->byte = blocks_end;
     }
     VERSIONS (R_2_0b, R_9c1) {
       dat->byte = hdr_offset + (3 * 8);
       bit_write_RS (dat, num_entities);
       dat->byte = blocks_end;
     }
     LOG_TRACE ("Wrote %lu bytes\n", dat->byte);
     return error;
   }
   VERSIONS (R_13, R_2004)
   {
     /* section 0: header vars
      *         1: class section
      *         2: object map
      *         3: (R13 c3 and later): 2nd header (special table no sentinels)
      *         4: optional: MEASUREMENT
      *         5: optional: AuxHeader
      */
     /* Usually 3-5, max 6 */
     if (!dwg->header.numsections
         || (dat->from_version >= R_2004 && dwg->header.numsections > 6))
       {
         dwg->header.numsections = dwg->header.version < R_2000 ? 5 : 6;
         // minimal DXF:
         if (!dwg->header_vars.HANDSEED || !dwg->header_vars.TDCREATE.days)
           {
             dwg->header.numsections = 5;
             // hack to trigger IF_ENCODE_FROM_EARLIER defaults. undone after
             // HEADER
             dat->from_version = R_11;
             if (dat->version <= dat->from_version)
               dat->from_version = (Dwg_Version_Type)((int)dat->version - 1);
           }
       }
     LOG_TRACE ("numsections: " FORMAT_RL " [RL]\n", dwg->header.numsections);
     bit_write_RL (dat, dwg->header.numsections);
     if (!dwg->header.section)
       dwg->header.section = (Dwg_Section*)calloc (dwg->header.numsections,
                                                   sizeof (Dwg_Section));
     if (!dwg->header.section)
       {
         LOG_ERROR ("Out of memory");
         return DWG_ERR_OUTOFMEM;
       }
     section_address = dat->byte;                 // save section address
     dat->byte += (dwg->header.numsections * 9); /* RC + 2*RL */
     bit_write_CRC (dat, 0, 0xC0C1);
     bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_HEADER_END));
 
     /*------------------------------------------------------------
      * AuxHeader section 5
      * R2000+, mostly redundant file header information
      */
     if (dwg->header.numsections > 5)
       {
         Dwg_AuxHeader *_obj = &dwg->auxheader;
         Dwg_Object *obj = NULL;
         BITCODE_BL vcount;
         assert (!dat->bit);
         LOG_INFO ("\n=======> AuxHeader: %8u\n",
                   (unsigned)dat->byte); // size: 123
 
         dwg->header.section[SECTION_AUXHEADER_R2000].number = 5;
         dwg->header.section[SECTION_AUXHEADER_R2000].address = dat->byte;
 
         if (!_obj->dwg_version) // todo: needed?
           {
             BITCODE_RS def_unknown_6rs[] = { 4, 0x565, 0, 0, 2, 1 };
             LOG_TRACE ("Use AuxHeader defaults...\n");
             FIELD_VALUE (aux_intro[0]) = 0xff;
             FIELD_VALUE (aux_intro[1]) = 0x77;
             FIELD_VALUE (aux_intro[2]) = 0x01;
             FIELD_VALUE (minus_1) = -1;
             FIELD_VALUE (dwg_version) = dwg->header.dwg_version;
             FIELD_VALUE (maint_version) = dwg->header.maint_version;
             FIELD_VALUE (dwg_version_1) = dwg->header.dwg_version;
             FIELD_VALUE (dwg_version_2) = dwg->header.dwg_version;
             FIELD_VALUE (maint_version_1) = dwg->header.maint_version;
             FIELD_VALUE (maint_version_2) = dwg->header.maint_version;
             memcpy (FIELD_VALUE (unknown_6rs), def_unknown_6rs,
                     sizeof (def_unknown_6rs));
             FIELD_VALUE (TDCREATE) = dwg->header_vars.TDCREATE.value;
             FIELD_VALUE (TDUPDATE) = dwg->header_vars.TDUPDATE.value;
             if (dwg->header_vars.HANDSEED)
               FIELD_VALUE (HANDSEED) = dwg->header_vars.HANDSEED->absolute_ref;
           }
 
           // clang-format off
         #include "auxheader.spec"
         // clang-format on
 
         assert (!dat->bit);
         dwg->header.section[SECTION_AUXHEADER_R2000].size
             = dat->byte - dwg->header.section[SECTION_AUXHEADER_R2000].address;
       }
   }
 
   VERSION (R_2007)
   {
     LOG_ERROR (WE_CAN "We don't encode R2007 sections yet");
     dat->version = dwg->header.version = R_2010; // rather do 2010
     // return DWG_ERR_NOTYETSUPPORTED;
   }
 
   /* r2004 file header (compressed + encrypted) */
   SINCE (R_2004)
   {
     LOG_INFO ("\n");
     LOG_ERROR (WE_CAN "Writing R2004 sections not yet finished");
 
     memset (&sec_dat, 0, (SECTION_SYSTEM_MAP + 1) * sizeof (Bit_Chain));
     if (dwg->header.section_infohdr.num_desc && !dwg->header.section_info)
       dwg->header.section_info = (Dwg_Section_Info *)calloc (
           dwg->header.section_infohdr.num_desc, sizeof (Dwg_Section_Info));
     LOG_TRACE ("\n#### r2004 File Header ####\n");
     if (dat->byte + 0x80 >= dat->size - 1)
       {
         dwg->header.numsections = 28; // room for some object pages
         dwg->header.section = calloc (28, sizeof (Dwg_Section));
       }
     if (!dwg->header.section_info)
       {
         dwg->header.section_infohdr.num_desc = SECTION_SYSTEM_MAP + 1;
         dwg->header.section_info
             = calloc (SECTION_SYSTEM_MAP + 1, sizeof (Dwg_Section_Info));
       }
   }
 
   /*------------------------------------------------------------
    * THUMBNAIL preview pictures
    */
   old_dat = dat;
   SINCE (R_2004)
   {
     bit_chain_init_dat (&sec_dat[SECTION_PREVIEW], dwg->thumbnail.size + 64, dat);
     str_dat = hdl_dat = dat = &sec_dat[SECTION_PREVIEW];
   }
   else
   {
     if (!dwg->header.thumbnail_address)
       dwg->header.thumbnail_address = dat->byte;
   }
   dat->bit = 0;
   LOG_TRACE ("\n=======> Thumbnail:       %4u\n", (unsigned)dat->byte);
   // dwg->thumbnail.size = 0; // to disable
   bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_THUMBNAIL_BEGIN));
   if (dwg->thumbnail.size == 0)
     {
       bit_write_RL (dat, 5); // overall size
       LOG_TRACE ("Thumbnail size: 5 [RL]\n");
       bit_write_RC (dat, 0); // num_pictures
       LOG_TRACE ("Thumbnail num_pictures: 0 [RC]\n");
     }
   else
     {
       bit_write_TF (dat, dwg->thumbnail.chain, dwg->thumbnail.size);
     }
   bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_THUMBNAIL_END));
 
   {
     BITCODE_RL bmpsize;
     dwg_bmp (dwg, &bmpsize);
     if (bmpsize > dwg->thumbnail.size)
       LOG_ERROR ("BMP size overflow: %i > %lu\n", bmpsize,
                  dwg->thumbnail.size);
   }
   LOG_TRACE ("         Thumbnail (end): %4u\n", (unsigned)dat->byte);
 
   /*------------------------------------------------------------
    * Header Variables
    */
   SINCE (R_2004)
   {
     sec_id = SECTION_HEADER;
     bit_chain_init_dat (&sec_dat[sec_id], sizeof (Dwg_Header) + 64, dat);
     str_dat = hdl_dat = dat = &sec_dat[sec_id];
   }
   assert (!dat->bit);
   LOG_INFO ("\n=======> Header Variables:   %4u\n", (unsigned)dat->byte);
   if (!dwg->header.section)
     {
       LOG_ERROR ("Empty header.section");
       return DWG_ERR_OUTOFMEM;
     }
   dwg->header.section[0].number = 0;
   dwg->header.section[0].address = dat->byte;
   bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_VARIABLE_BEGIN));
 
   pvzadr = dat->byte;      // Size position
   {
     bit_write_RL (dat, 540); // Size placeholder
     // if (dat->version >= R_2007)
     //  str_dat = dat;
     dwg_encode_header_variables (dat, hdl_dat, dat, dwg);
     // undo minimal HEADER hack
     if (dat->from_version != orig_from_version)
       dat->from_version = orig_from_version;
     encode_patch_RLsize (dat, pvzadr);
     bit_write_CRC (dat, pvzadr, 0xC0C1);
 
     // XXX trying to fix CRC 2-byte overflow. Must find actual reason.
     // dat->byte -= 2;
     bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_VARIABLE_END));
     assert ((long)dat->byte > (long)dwg->header.section[0].address);
     dwg->header.section[0].size
       = (BITCODE_RL) ((long)dat->byte - (long)dwg->header.section[0].address);
     LOG_TRACE ("         Header Variables (end): %4u\n", (unsigned)dat->byte);
 
     /*------------------------------------------------------------
      * Classes
      */
     SINCE (R_2004)
     {
       sec_id = SECTION_CLASSES;
       bit_chain_init_dat (&sec_dat[sec_id],
                     (sizeof (Dwg_Class) * dwg->num_classes) + 32, dat);
       str_dat = hdl_dat = dat = &sec_dat[sec_id];
     }
     else sec_id = SECTION_CLASSES_R13;
     LOG_INFO ("\n=======> Classes: %4u (%d)\n", (unsigned)dat->byte,
               dwg->num_classes);
     if (dwg->num_classes > 5000)
     {
       LOG_ERROR ("Invalid dwg->num_classes %d", dwg->num_classes)
       dwg->num_classes = 0;
       error |= DWG_ERR_VALUEOUTOFBOUNDS | DWG_ERR_CLASSESNOTFOUND;
     }
     dwg->header.section[sec_id].number = 1;
     dwg->header.section[sec_id].address = dat->byte; // FIXME
     bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_CLASS_BEGIN));
     pvzadr = dat->byte;    // Size position
     bit_write_RL (dat, 0); // Size placeholder
 
     for (j = 0; j < dwg->num_classes; j++)
       {
         Dwg_Class *klass;
         klass = &dwg->dwg_class[j];
         bit_write_BS (dat, klass->number);
         bit_write_BS (dat, klass->proxyflag);
         SINCE (R_2007) {
           bit_write_T (dat, klass->appname);
           bit_write_T (dat, klass->cppname);
         } else {
           bit_write_TV (dat, klass->appname);
           bit_write_TV (dat, klass->cppname);
         }
         SINCE (R_2007) // only when we have it. like not for 2004 => 2007
                      // conversions
           {
             if (klass->dxfname_u)
               bit_write_TU (dat, klass->dxfname_u);
             else
               bit_write_T (dat, klass->dxfname);
           }
         else // we always have this one
           bit_write_TV (dat, klass->dxfname);
         bit_write_B (dat, klass->is_zombie);
         bit_write_BS (dat, klass->item_class_id);
         LOG_TRACE ("Class %d 0x%x %s\n"
                    " %s \"%s\" %d 0x%x\n",
                    klass->number, klass->proxyflag, klass->dxfname,
                    klass->cppname, klass->appname, klass->is_zombie,
                    klass->item_class_id)
 
       SINCE (R_2007)
       {
         if (dat->from_version < R_2007 && !klass->dwg_version) {
           // defaults
           klass->dwg_version = (BITCODE_BL)dwg->header.dwg_version;
           klass->maint_version = (BITCODE_BL)dwg->header.maint_version;
           // TODO num_instances
         }
         bit_write_BL (dat, klass->num_instances);
         bit_write_BL (dat, klass->dwg_version);
         bit_write_BL (dat, klass->maint_version);
         bit_write_BL (dat, klass->unknown_1);
         bit_write_BL (dat, klass->unknown_2);
         LOG_TRACE (" %d %d\n", (int)klass->num_instances,
                    (int)klass->dwg_version);
       }
     }
 
     /* Write the size of the section at its beginning
      */
     assert (pvzadr);
     encode_patch_RLsize (dat, pvzadr);
     bit_write_CRC (dat, pvzadr, 0xC0C1);
     bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_CLASS_END));
     dwg->header.section[SECTION_CLASSES_R13].size
       = dat->byte - dwg->header.section[SECTION_CLASSES_R13].address;
     LOG_TRACE ("       Classes (end): %4u\n", (unsigned)dat->byte);
 
     bit_write_RL (dat, 0x0DCA); // 0xDCA Unknown bitlong inter class and objects
     LOG_TRACE ("unknown: %04X [RL]\n", 0x0DCA);
   }
 
   /*------------------------------------------------------------
    * Objects
    */
 
   SINCE (R_2004)
   {
     sec_id = SECTION_OBJECTS;
     bit_chain_alloc (&sec_dat[sec_id]);
     str_dat = hdl_dat = dat = &sec_dat[sec_id];
     bit_chain_set_version (dat, old_dat);
   }
   LOG_INFO ("\n=======> Objects: %4u\n", (unsigned)dat->byte);
   pvzadr = dat->byte;
 
   /* Sort object-map by ascending handles
    */
   LOG_TRACE ("num_objects: %i\n", dwg->num_objects);
   LOG_TRACE ("num_object_refs: %i\n", dwg->num_object_refs);
   omap = (Object_Map *)calloc (dwg->num_objects, sizeof (Object_Map));
   if (!omap)
     {
       LOG_ERROR ("Out of memory");
       return DWG_ERR_OUTOFMEM;
     }
   if (DWG_LOGLEVEL >= DWG_LOGLEVEL_HANDLE)
     {
       LOG_HANDLE ("\nSorting objects...\n");
       for (i = 0; i < dwg->num_objects; i++)
         fprintf (OUTPUT, "Object(%3i): %4lX / idx: %u\n", i,
                  dwg->object[i].handle.value, dwg->object[i].index);
     }
   // init unsorted
   for (i = 0; i < dwg->num_objects; i++)
     {
       omap[i].index = i; // i.e. dwg->object[j].index
       omap[i].handle = dwg->object[i].handle.value;
     }
   // insertion sort
   for (i = 0; i < dwg->num_objects; i++)
     {
       Object_Map tmap;
       j = i;
       tmap = omap[i];
       while (j > 0 && omap[j - 1].handle > tmap.handle)
         {
           omap[j] = omap[j - 1];
           j--;
         }
       omap[j] = tmap;
     }
   if (DWG_LOGLEVEL >= DWG_LOGLEVEL_HANDLE)
     {
       LOG_HANDLE ("\nSorted handles:\n");
       for (i = 0; i < dwg->num_objects; i++)
         fprintf (OUTPUT, "Handle(%3i): %4lX / idx: %u\n", i, omap[i].handle,
                  omap[i].index);
     }
 
   /* Write the sorted objects
    */
   for (i = 0; i < dwg->num_objects; i++)
     {
       Dwg_Object *obj;
       BITCODE_BL index = omap[i].index;
       unsigned long hdloff = omap[i].handle - (i ? omap[i - 1].handle : 0);
       int off = dat->byte - (i ? omap[i - 1].address : 0);
       unsigned long end_address;
       LOG_TRACE ("\n> Next object: " FORMAT_BL
                  " Handleoff: %lX [UMC] Offset: %d [MC] @%lu\n"
                  "==========================================\n",
                  i, hdloff, off, dat->byte);
       omap[i].address = dat->byte;
       if (index > dwg->num_objects)
         {
           LOG_ERROR ("Invalid object map index " FORMAT_BL ", max " FORMAT_BL
                      ". Skipping",
                      index, dwg->num_objects)
           error |= DWG_ERR_VALUEOUTOFBOUNDS;
           continue;
         }
       obj = &dwg->object[index];
       // change the address to the linearly sorted one
 #ifndef NDEBUG
       PRE (R_2004)
         assert (dat->byte);
 #endif
       if (!obj->parent)
         obj->parent = dwg;
       error |= dwg_encode_add_object (obj, dat, dat->byte);
 
 #ifndef NDEBUG
       // check if this object overwrote at address 0. but with r2004 it starts
       // fresh.
       if (dwg->header.version >= R_1_2 && dwg->header.version < R_2004)
         {
           if (dat->size < 6 || dat->chain[0] != 'A' || dat->chain[1] != 'C')
             {
               LOG_ERROR ("Encode overwrite pos 0, invalid DWG magic");
               return DWG_ERR_INVALIDDWG;
             }
           assert (dat->size > 6);
           assert (dat->chain[0] == 'A');
           assert (dat->chain[1] == 'C');
         }
 #endif
       end_address = omap[i].address + (unsigned long)obj->size; // from RL
       if (end_address > dat->size)
         {
           assert(obj->size < DWG_MAX_OBJSIZE);
           dat->size = end_address;
           bit_chain_alloc (dat);
         }
     }
 
   if (DWG_LOGLEVEL >= DWG_LOGLEVEL_HANDLE)
     {
       LOG_HANDLE ("\nSorted objects:\n");
       for (i = 0; i < dwg->num_objects; i++)
         LOG_HANDLE ("Object(%d): %lX / Address: %ld / Idx: %d\n", i,
                     omap[i].handle, omap[i].address, omap[i].index);
     }
 
   /* Unknown CRC between objects and object map
    */
   bit_write_RS (dat, 0);
   LOG_TRACE ("unknown crc?: %04X [RS]\n", 0);
 
   /*------------------------------------------------------------
    * Object-map
    * split into chunks of max. 2030
    */
   LOG_INFO ("\n=======> Object Map: %4u\n", (unsigned)dat->byte);
   SINCE (R_2004)
   {
     sec_id = SECTION_HANDLES;
     bit_chain_init_dat (&sec_dat[sec_id], (8 * dwg->num_objects) + 32, dat);
     str_dat = hdl_dat = dat = &sec_dat[sec_id];
   }
   else
   {
     sec_id = SECTION_HANDLES_R13;
     dwg->header.section[sec_id].number = 2;
     dwg->header.section[sec_id].address = dat->byte;
     pvzadr = dat->byte; // Correct value of section size must be written later
     dat->byte += 2;
   }
 
   last_offset = 0;
   last_handle = 0;
   for (i = 0; i < dwg->num_objects; i++)
     {
       BITCODE_BL index;
       BITCODE_UMC handleoff;
       BITCODE_MC offset;
 
       index = omap[i].index;
       handleoff = omap[i].handle - last_handle;
       bit_write_UMC (dat, handleoff);
       LOG_HANDLE ("Handleoff(%3i): %4lX [UMC] (%4lX), ", index, handleoff,
                   omap[i].handle)
       last_handle = omap[i].handle;
 
       offset = omap[i].address - last_offset;
       bit_write_MC (dat, offset);
       last_offset = omap[i].address;
       LOG_HANDLE ("Offset: %8d [MC] @%lu\n", (int)offset, last_offset);
 
       ckr_missing = 1;
       if (dat->byte - pvzadr > 2030) // 2029
         {
           ckr_missing = 0;
           sec_size = dat->byte - pvzadr;
           assert (pvzadr);
           // i.e. encode_patch_RS_LE_size
           dat->chain[pvzadr] = sec_size >> 8;
           dat->chain[pvzadr + 1] = sec_size & 0xFF;
           LOG_TRACE ("Handles page size: %u [RS_LE] @%lu\n", sec_size, pvzadr);
           bit_write_CRC_LE (dat, pvzadr, 0xC0C1);
 
           pvzadr = dat->byte;
           dat->byte += 2;
           last_offset = 0;
           last_handle = 0;
         }
     }
   // printf ("Obj size: %u\n", i);
   if (ckr_missing)
     {
       sec_size = dat->byte - pvzadr;
 #ifndef NDEBUG
       PRE (R_2004)
         assert (pvzadr);
 #endif
       if (pvzadr + 1 >= dat->size)
         bit_chain_alloc(dat);
       // i.e. encode_patch_RS_LE_size
       dat->chain[pvzadr] = sec_size >> 8;
       dat->chain[pvzadr + 1] = sec_size & 0xFF;
       LOG_TRACE ("Handles page size: %u [RS_LE] @%lu\n", sec_size, pvzadr);
       bit_write_CRC_LE (dat, pvzadr, 0xC0C1);
     }
 #ifndef NDEBUG
   if (dwg->header.version >= R_1_2 && dwg->header.version < R_2004)
     {
       if (dat->size < 4 || dat->chain[0] != 'A' || dat->chain[1] != 'C')
         {
           LOG_ERROR ("Encode overwrite pos 0");
           return DWG_ERR_INVALIDDWG;
         }
       assert (dat->chain[0] == 'A');
       assert (dat->chain[1] == 'C');
     }
   PRE (R_2004)
     assert (dat->byte);
 #endif
   pvzadr = dat->byte;
   bit_write_RS_LE (dat, 2); // last section_size 2
   LOG_TRACE ("Handles page size: %u [RS_LE] @%lu\n", 2, pvzadr);
   bit_write_CRC_LE (dat, pvzadr, 0xC0C1);
 
   /* Calculate and write the size of the object map
    */
   dwg->header.section[sec_id].size
       = dat->byte - dwg->header.section[sec_id].address;
   free (omap);
 
   /*------------------------------------------------------------
    * Second header, section 3. R13-R2000 only.
    * But partially also since r2004. (TODO: under which name? AuxHeader?)
    */
   if (dwg->header.version >= R_13 && dwg->header.version < R_2004 // TODO
       && dwg->second_header.num_sections > 3)
     {
       struct _dwg_second_header *_obj = &dwg->second_header;
       Dwg_Object *obj = NULL;
       BITCODE_BL vcount;
 
       assert (dat->byte);
       if (!_obj->address)
         _obj->address = dat->byte;
       dwg->header.section[SECTION_2NDHEADER_R13].number = 3;
       dwg->header.section[SECTION_2NDHEADER_R13].address = _obj->address;
       dwg->header.section[SECTION_2NDHEADER_R13].size = _obj->size;
       LOG_INFO ("\n=======> Second Header: %4u\n", (unsigned)dat->byte);
       bit_write_sentinel (dat,
                           dwg_sentinel (DWG_SENTINEL_SECOND_HEADER_BEGIN));
 
       pvzadr = dat->byte; // Keep the first address of the section to write its
                           // size later
       LOG_TRACE ("pvzadr: %u\n", (unsigned)pvzadr);
       if (!_obj->size && !_obj->num_sections)
         {
 	  const char *code = dwg_version_codes (dwg->header.version);
           LOG_TRACE ("Use second_header defaults...\n");
           strcpy ((char *)&_obj->version[0], &code[0]);
           memset (&_obj->version[7], 0, 4);
           _obj->version[11] = '\n';
           _obj->unknown_10 = 0x10;
           _obj->unknown_rc4[0] = 0x84;
           _obj->unknown_rc4[1] = 0x74;
           _obj->unknown_rc4[2] = 0x78;
           _obj->unknown_rc4[3] = 0x1;
           _obj->junk_r14_1 = 1957593121; //?
           _obj->junk_r14_2 = 2559919056; //?
           // TODO handlers defaults
         }
       // always recomputed, even with dwgrewrite
       if (dwg->header.version <= R_2000)
         {
           _obj->num_sections = dwg->header.numsections;
           for (i = 0; i < _obj->num_sections; i++)
             {
               _obj->section[i].nr = dwg->header.section[i].number;
               _obj->section[i].address = dwg->header.section[i].address;
               _obj->section[i].size = dwg->header.section[i].size;
             }
         }
       FIELD_RL (size, 0);
       if (FIELD_VALUE (address) != (BITCODE_RL) (pvzadr - 16))
         {
           LOG_WARN ("second_header->address %u != %u", FIELD_VALUE (address),
                     (unsigned)(pvzadr - 16));
           FIELD_VALUE (address) = pvzadr - 16;
           dwg->header.section[SECTION_2NDHEADER_R13].address = _obj->address;
           dwg->header.section[SECTION_2NDHEADER_R13].size = _obj->size;
         }
       FIELD_BL (address, 0);
 
       // AC1012, AC1014 or AC1015. This is a char[11], zero padded.
       // with \n at 12.
       bit_write_TF (dat, (BITCODE_TF)_obj->version, 12);
       LOG_TRACE ("version: %s [TFF 12]\n", _obj->version)
 
       for (i = 0; i < 4; i++)
         FIELD_B (null_b[i], 0);
       FIELD_RC (unknown_10, 0); // 0x10
       for (i = 0; i < 4; i++)
         FIELD_RC (unknown_rc4[i], 0);
 
       UNTIL (R_2000)
       {
         FIELD_RC (num_sections, 0); // r14: 5, r2000: 6 (auxheader)
         for (i = 0; i < FIELD_VALUE (num_sections); i++)
           {
             FIELD_RC (section[i].nr, 0);
             FIELD_BL (section[i].address, 0);
             FIELD_BLd (section[i].size, 0);
           }
 
         FIELD_BS (num_handlers, 0); // 14, resp. 16 in r14
         if (FIELD_VALUE (num_handlers) > 16)
           {
             LOG_ERROR ("Second header num_handlers > 16: %d\n",
                        FIELD_VALUE (num_handlers));
             FIELD_VALUE (num_handlers) = 14;
           }
         for (i = 0; i < FIELD_VALUE (num_handlers); i++)
           {
             FIELD_RC (handlers[i].size, 0);
             FIELD_RC (handlers[i].nr, 0);
             FIELD_VECTOR (handlers[i].data, RC, handlers[i].size, 0);
           }
 
         _obj->size = encode_patch_RLsize (dat, pvzadr);
         bit_write_CRC (dat, pvzadr, 0xC0C1);
 
         VERSION (R_14)
         {
           FIELD_RL (junk_r14_1, 0);
           FIELD_RL (junk_r14_2, 0);
         }
       }
       bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_SECOND_HEADER_END));
       dwg->header.section[SECTION_2NDHEADER_R13].size
           = dat->byte - _obj->address;
     }
   else if (dwg->header.numsections > SECTION_2NDHEADER_R13
            && dwg->header.version < R_2004) // TODO
     {
       dwg->header.section[SECTION_2NDHEADER_R13].number = 3;
       dwg->header.section[SECTION_2NDHEADER_R13].address = 0;
       dwg->header.section[SECTION_2NDHEADER_R13].size = 0;
     }
 
   /*------------------------------------------------------------
    * MEASUREMENT/Template Section 4
    * In a DXF under header_vars
    */
   SINCE (R_2004)
   {
     sec_id = SECTION_TEMPLATE;
     bit_chain_init_dat (&sec_dat[sec_id], 16, dat);
     str_dat = hdl_dat = dat = &sec_dat[sec_id];
   }
   else sec_id = SECTION_MEASUREMENT_R13;
 
   if (dwg->header.version >= R_2004 || (int)dwg->header.numsections > sec_id)
     {
       LOG_INFO ("\n=======> MEASUREMENT: %4u\n", (unsigned)dat->byte);
       dwg->header.section[sec_id].number = 4;
       dwg->header.section[sec_id].address = dat->byte;
       dwg->header.section[sec_id].size = 4;
       // 0 - English, 1- Metric
       bit_write_RL_LE (dat, (BITCODE_RL)dwg->header_vars.MEASUREMENT ? 256 : 0);
       LOG_TRACE ("HEADER.MEASUREMENT: %d [RL_LE]\n",
                  dwg->header_vars.MEASUREMENT);
     }
 
   /* End of the file
    */
   dat->size = dat->byte;
   SINCE (R_2004)
   {
     Dwg_Section_Type type;
     Dwg_Object *obj = NULL;
     BITCODE_BL vcount, rcount3;
     size_t size;
     unsigned total_size = 0;
 
     // write remaining section data
     for (type = SECTION_OBJFREESPACE; type < SECTION_SYSTEM_MAP; type++)
       {
         if (type != SECTION_OBJECTS && type != SECTION_PREVIEW)
           LOG_TRACE ("\n=== Section %s ===\n", dwg_section_name (dwg, type))
         switch (type)
           {
           case SECTION_HEADER: // ignore, already done
           case SECTION_AUXHEADER:
           case SECTION_CLASSES:
           case SECTION_HANDLES:
           case SECTION_TEMPLATE:
           case SECTION_PREVIEW:
           case SECTION_OBJECTS:
           case SECTION_UNKNOWN: // deferred
           case SECTION_INFO:
           case SECTION_SYSTEM_MAP:
             break;
           case SECTION_OBJFREESPACE:
             {
               Dwg_ObjFreeSpace *_obj = &dwg->objfreespace;
               bit_chain_alloc (&sec_dat[type]);
               str_dat = hdl_dat = dat = &sec_dat[type];
               bit_chain_set_version (dat, old_dat);
 #include "objfreespace.spec"
               LOG_TRACE ("-size: %lu\n", dat->byte)
             }
             break;
           case SECTION_REVHISTORY:
             {
               Dwg_RevHistory *_obj = &dwg->revhistory;
               bit_chain_alloc (&sec_dat[type]);
               str_dat = hdl_dat = dat = &sec_dat[type];
               bit_chain_set_version (dat, old_dat);
 #include "revhistory.spec"
               LOG_TRACE ("-size: %lu\n", dat->byte)
             }
             break;
           case SECTION_SUMMARYINFO:
             {
               Dwg_SummaryInfo *_obj = &dwg->summaryinfo;
               bit_chain_alloc (&sec_dat[type]);
               str_dat = hdl_dat = dat = &sec_dat[type];
               bit_chain_set_version (dat, old_dat);
 #include "summaryinfo.spec"
               LOG_TRACE ("-size: %lu\n", dat->byte)
             }
             break;
           case SECTION_APPINFO:
             {
               Dwg_AppInfo *_obj = &dwg->appinfo;
               bit_chain_alloc (&sec_dat[type]);
               str_dat = hdl_dat = dat = &sec_dat[type];
               bit_chain_set_version (dat, old_dat);
 #include "appinfo.spec"
               LOG_TRACE ("-size: %lu\n", dat->byte)
             }
             break;
           case SECTION_APPINFOHISTORY:
             {
 #if 0
               Dwg_AppInfoHistory *_obj = &dwg->appinfohistory;
               bit_chain_alloc (&sec_dat[type]);
               str_dat = hdl_dat = dat = &sec_dat[type];
               bit_chain_set_version (dat, old_dat);
 #  include "appinfohistory.spec"
               LOG_TRACE ("-size: %lu\n", dat->byte)
 #endif
             }
             break;
           case SECTION_FILEDEPLIST:
             {
               Dwg_FileDepList *_obj = &dwg->filedeplist;
               bit_chain_alloc (&sec_dat[type]);
               str_dat = hdl_dat = dat = &sec_dat[type];
               bit_chain_set_version (dat, old_dat);
 #include "filedeplist.spec"
               LOG_TRACE ("-size: %lu\n", dat->byte)
             }
             break;
           case SECTION_SECURITY:
             {
               Dwg_Security *_obj = &dwg->security;
               bit_chain_alloc (&sec_dat[type]);
               str_dat = hdl_dat = dat = &sec_dat[type];
               bit_chain_set_version (dat, old_dat);
 #include "security.spec"
               LOG_TRACE ("-size: %lu\n", dat->byte)
             }
             break;
           case SECTION_SIGNATURE:
             {
 #if 0
               Dwg_Signature *_obj = &dwg->signature;
               bit_chain_alloc (&sec_dat[type]);
               str_dat = hdl_dat = dat = &sec_dat[type];
               bit_chain_set_version (dat, old_dat);
               {
 #  include "signature.spec"
               }
               LOG_TRACE ("-size: %lu\n", dat->byte)
 #endif
             }
             break;
           case SECTION_ACDS:
             {
 #if 0
               Dwg_AcDs *_obj = &dwg->acds;
               bit_chain_alloc (&sec_dat[type]);
               str_dat = hdl_dat = dat = &sec_dat[type];
               bit_chain_set_version (dat, old_dat);
               {
 #  include "acds.spec"
               }
               LOG_TRACE ("-size: %lu\n", dat->byte)
 #endif
             }
             break;
           case SECTION_VBAPROJECT: // nyi
           default:
             break;
           }
       }
     // and write system and data section maps.
     dat = old_dat;
 
     /*-------------------------------------------------------------------------
      * Section map and info
      */
     // no gaps, so header->numsections == r2004_header->numsections
     // get together all the section sizes, and set the addresses
     {
       int ssize;
       int si, info_id;
       unsigned address;
 
       const Dwg_Section_Type section_map_order[] = {
         // R2004_Header
         SECTION_UNKNOWN, // the empty section 128-256
         SECTION_SECURITY,       SECTION_FILEDEPLIST, SECTION_ACDS,
         SECTION_VBAPROJECT,
         SECTION_APPINFOHISTORY, //? at least before AppInfo
         SECTION_APPINFO,        SECTION_PREVIEW,
         SECTION_SUMMARYINFO, // sometimes this is before Preview
         SECTION_REVHISTORY,     SECTION_OBJECTS,     SECTION_OBJFREESPACE,
         SECTION_TEMPLATE,       SECTION_HANDLES,     SECTION_CLASSES,
         SECTION_AUXHEADER,      SECTION_HEADER,      SECTION_SIGNATURE,
 
         SECTION_INFO,           SECTION_SYSTEM_MAP
       };
 
       // not the order in the system map, but the order in the dat stream.
       const Dwg_Section_Type stream_order[]
           = {                  // R2004_Header
               SECTION_UNKNOWN, // the empty section 128-256
               SECTION_SUMMARYINFO, SECTION_PREVIEW,        SECTION_VBAPROJECT,
               SECTION_APPINFO,     SECTION_APPINFOHISTORY, SECTION_FILEDEPLIST,
               SECTION_ACDS,        SECTION_REVHISTORY,     SECTION_SECURITY,
               SECTION_OBJECTS,     SECTION_OBJFREESPACE,   SECTION_TEMPLATE,
               SECTION_HANDLES,     SECTION_CLASSES,        SECTION_AUXHEADER,
               SECTION_HEADER,
 
               SECTION_SIGNATURE, //?
 
               SECTION_INFO,        SECTION_SYSTEM_MAP
             };
 
       dwg->r2004_header.numsections = 0;
       dwg->r2004_header.numgaps = 0;
 
       //sec_dat[SECTION_UNKNOWN].byte = 0;
       sec_dat[SECTION_INFO].byte = 10
                                    + (dwg->header.section_infohdr.num_desc
                                       * sizeof (Dwg_Section_Info));
       // only a guess, reserve at least one page
       sec_dat[SECTION_SYSTEM_MAP].byte = (4 * 20 * sizeof (Dwg_Section));
 
       section_address = 0x100;
       // first all the data pages, than a number gap of 1, and last the two
       // system page maps, info and system_map the data_pages (system_map
       // sections) can include multiple pages of the same type.
       LOG_TRACE ("\n=== Section map and info page sizes ===\n");
       for (si = 0, info_id = 0, type = 0; type <= SECTION_SYSTEM_MAP;
            type++, i++)
         {
           if (sec_dat[type].byte)
             {
               const unsigned int max_decomp_size
                   = section_max_decomp_size (dwg, type);
               const char *name = dwg_section_name (dwg, type);
               Dwg_Section_Info *info;
               if (sec_dat[type].bit)
                 {
                   LOG_WARN ("Unpadded section %d", type);
                   sec_dat[type].byte++;
                 }
               ssize = (int)sec_dat[type].byte;
               sec_dat[type].size = ssize;
               if (info_id >= (int)dwg->header.section_infohdr.num_desc)
                 {
                   dwg->header.section_infohdr.num_desc = info_id + 1;
                   dwg->header.section_info
                       = realloc (dwg->header.section_info,
                                  (info_id + 1) * sizeof (Dwg_Section));
                 }
               info = &dwg->header.section_info[info_id];
               info->fixedtype = type;
               info->type = type;
               info->unknown = 1;
               if (name && si && type < SECTION_INFO) // not UNKNOWN and the last two
                 strcpy (info->name, name);
               else
                 memset (info->name, 0, 64);
               info->size = ssize;
               info->max_decomp_size = max_decomp_size;
               info->encrypted = section_encrypted (dwg, type);
               info->compressed = 1 + section_compressed (dwg, type);
 #ifndef HAVE_COMPRESS_R2004_SECTION
               info->compressed = 1;
 #endif
               // pre-calc numsections for both
               if ((unsigned)ssize <= max_decomp_size)
                 info->num_sections = 1;
               else
                 {
                   info->num_sections = (unsigned)ssize / max_decomp_size;
                   if ((unsigned)ssize % max_decomp_size)
                     info->num_sections++;
                 }
               info->sections
                   = calloc (info->num_sections, sizeof (Dwg_Section*));
               // enough sections?
               if (si + info->num_sections > dwg->header.numsections)
                 {
                   Dwg_Section *oldsecs = dwg->header.section;
                   dwg->header.numsections = si + info->num_sections;
                   dwg->header.section = realloc (dwg->header.section,
                                                  dwg->header.numsections
                                                      * sizeof (Dwg_Section));
                   if (dwg->header.section != oldsecs)
                     // need to rebuild all info->sections
                     section_info_rebuild (dwg, type);
                 }
               {
                 int ssi = 0;
                 do
                   {
                     Dwg_Section *sec = &dwg->header.section[si];
                     total_size += ssize;
                     sec->number = si + 1; // index starting at 1
                     sec->size = MIN (max_decomp_size, (unsigned)ssize);
                     sec->decomp_data_size = sec->size;
                     sec->type = type;
                     sec->compression_type = info->compressed;
                     info->sections[ssi] = sec;
                     LOG_TRACE ("section[%d] %s[%d].sections[%d]: number=%d "
                                "size=%d\n", si,
                                dwg_section_name (dwg, type), info_id, ssi,
                                sec->number, (int)sec->size);
                     ssize -= max_decomp_size;
                     ssi++; // info->sections index
                     si++;  // section index
                   }
                 while (ssize > (int)max_decomp_size); // keep same type
               }
               info_id++;
             }
           else
             LOG_TRACE ("section_info %s is empty, skipped. size=0\n",
                        dwg_section_name (dwg, type));
         }
       dwg->r2004_header.numsections = si;
       // section_info [27] and section_map [28] as two last already added.
       if ((unsigned)si > dwg->header.numsections) // needed?
         {
           Dwg_Section *oldsecs = dwg->header.section;
           dwg->header.numsections = si;
           dwg->header.section = realloc (dwg->header.section, si * sizeof (Dwg_Section));
           if (dwg->header.section != oldsecs)
             section_info_rebuild (dwg, SECTION_SYSTEM_MAP);
         }
       dwg->r2004_header.section_info_id = dwg->r2004_header.numsections + 1; // a gap of 3
       dwg->r2004_header.section_map_id = dwg->r2004_header.numsections + 2;
       dwg->r2004_header.section_array_size = dwg->r2004_header.numsections + 2;
       dwg->r2004_header.last_section_id = dwg->r2004_header.section_map_id;
       dwg->header.section[si - 2].number = dwg->r2004_header.section_info_id;
       dwg->header.section[si - 1].number = dwg->r2004_header.section_map_id;
 
       LOG_TRACE ("\n=== Section Info %d in map order ===\n",
                  dwg->r2004_header.section_info_id);
       // write into sec_dat[type] first, then compress
       sec_id = SECTION_INFO;
       sec_dat[sec_id].size = sec_dat[sec_id].byte;
       bit_chain_alloc (&sec_dat[sec_id]);
       dat = &sec_dat[sec_id];
       bit_chain_set_version (dat, old_dat);
       bit_set_position (dat, 0); // so far we faked the content. now write it
 
       {
         Dwg_Section_InfoHdr *_obj = &dwg->header.section_infohdr;
         Dwg_Section *sec = &dwg->header.section[si - 2];
         Dwg_Section_Info *info = find_section_info_type (dwg, sec_id);
         // index starting at 1
         sec->number = dwg->r2004_header.section_info_id;
         sec->size = MIN (0x7400, sec->size);
         sec->decomp_data_size = sec->size;
         sec->type = type;
         if (info)
           {
             sec->compression_type = info->compressed;
             // very unlikely, more than 1 page
             info->sections[0] = sec;
           }
         if (_obj->compressed == 2 && sec->size <= MIN_COMPRESSED_SECTION)
           _obj->compressed = 1;
 #ifndef HAVE_COMPRESS_R2004_SECTION
         _obj->compressed = 1;
 #endif
         LOG_HANDLE ("InfoHdr @%lu.0\n", dat->byte);
         FIELD_RL (num_desc, 0);
         FIELD_RL (compressed, 0);
         FIELD_RL (max_size, 0);
         FIELD_RL (encrypted, 0);
         FIELD_RL (num_desc2, 0);
       }
       for (i = 0; i < ARRAY_SIZE (section_map_order); i++)
         {
           Dwg_Section_Info *_obj;
           type = section_map_order[i];
           _obj = find_section_info_type (dwg, type);
           if (_obj)
             {
               assert (type == _obj->fixedtype);
               LOG_TRACE ("\nSection_Info %s [%d]\n",
                          dwg_section_name (dwg, type), i);
               FIELD_RLLu (size, 0);
               FIELD_RL (num_sections, 0);
               FIELD_RL (max_decomp_size, 0);
               FIELD_RL (unknown, 0);
               FIELD_RL (compressed, 0);
               FIELD_RL (type, 0);
               FIELD_RL (encrypted, 0);
               bit_write_TF (dat, (unsigned char *)_obj->name, 64);
               LOG_TRACE ("name: %s\n", *_obj->name ? _obj->name : "");
             }
         }
 
       LOG_TRACE ("\n=== Section System Map %d in map order ===\n",
                  dwg->r2004_header.section_map_id);
       sec_id = type = SECTION_SYSTEM_MAP;
       {
         //Dwg_Section_InfoHdr *_obj = &dwg->header.section_infohdr;
         Dwg_Section *sec = &dwg->header.section[si - 1];
         Dwg_Section_Info *info = find_section_info_type (dwg, type);
         if (!info || !info->sections)
           {
             LOG_ERROR ("SECTION_SYSTEM_MAP not found");
             return DWG_ERR_SECTIONNOTFOUND;
           }
 
         sec_dat[sec_id].size = sec_dat[sec_id].byte;
         bit_chain_alloc (&sec_dat[sec_id]);
         str_dat = hdl_dat = dat = &sec_dat[sec_id];
         bit_chain_set_version (dat, old_dat);
         bit_set_position (dat, 0); // so far we faked the content. now write it
 
         // index starting at 1
         sec->number = dwg->r2004_header.section_map_id;
         sec->size = MIN (0x7400, sec->size);
         sec->decomp_data_size = sec->size;
         sec->type = type;
         sec->compression_type = info->compressed;
         // very unlikely, more than 1 page
         info->sections[0] = sec;
       }
 
       address = 0x100;
       for (i = 0; i < dwg->header.numsections; i++)
         {
           Dwg_Section *_obj = &dwg->header.section[i];
 
           FIELD_RL (number, 0);
           FIELD_RL (size, 0);
           _obj->address = address;
           FIELD_RLL (address, 0);
           address += _obj->size;
           if (_obj->number < 0) // gap. unused. we deleted all gaps
             {
               FIELD_RL (parent, 0);
               FIELD_RL (left, 0);
               FIELD_RL (right, 0);
               FIELD_RL (x00, 0);
             }
         }
       dwg->r2004_header.decomp_data_size = dat->byte; // system_map_size
       LOG_TRACE ("-size: %lu\n", dat->byte);
 
       dat = old_dat;
 #ifndef NDEBUG
       if (dwg->header.version >= R_1_2)
         {
           if (dat->size < 4 || dat->chain[0] != 'A' || dat->chain[1] != 'C')
             {
               LOG_ERROR ("Encode overwrite pos 0");
               return DWG_ERR_INVALIDDWG;
             }
           assert (dat->chain[0] == 'A');
           assert (dat->chain[1] == 'C');
           assert (dat->byte <= 0x100);
         }
 #endif
 
       // now write all the sections in the stream order
       LOG_TRACE ("\n=== Write sections in stream order ===\n");
       size = total_size
              + (8 * ((dwg->r2004_header.numsections + 2) * 24)); // no gaps
       dat->byte = section_address;
       if (dat->byte + size >= dat->size)
         {
           dat->size = dat->byte + size;
           bit_chain_alloc (dat);
         }
       LOG_HANDLE ("@%lu.0\n", dat->byte);
       for (i = 0; i < ARRAY_SIZE (stream_order); i++)
         {
           Dwg_Section_Info *info;
           type = stream_order[i];
           info = find_section_info_type (dwg, type);
           if (info)
             {
               LOG_TRACE ("Write %s pages @%lu (%u/%lu)\n",
                          dwg_section_name (dwg, type), dat->byte,
                          info->num_sections, sec_dat[type].size);
               for (unsigned k = 0; k < info->num_sections; k++)
                 {
                   Dwg_Section *sec = info->sections[k];
                   if (!sec)
                     {
                       LOG_ERROR ("empty info->sections[%u]", k);
                       continue;
                     }
                   if (!sec_dat[type].chain)
                     {
                       LOG_ERROR ("empty %s.chain", dwg_section_name (dwg, type));
                       continue;
                     }
 #ifndef NDEBUG
                   if (info->fixedtype < SECTION_INFO)
                     assert (info->fixedtype == sec->type);
 #endif
                   if (info->fixedtype == SECTION_SUMMARYINFO)
                     dwg->header.summaryinfo_address = dat->byte;
                   else if (info->fixedtype == SECTION_PREVIEW)
                     dwg->header.thumbnail_address = dat->byte;
                   else if (info->fixedtype == SECTION_VBAPROJECT)
                     dwg->header.vbaproj_address = dat->byte;
                   else if (info->fixedtype == SECTION_SYSTEM_MAP)
                     {
                       dwg->r2004_header.section_map_address = dat->byte - 0x100;
                       dwg->r2004_header.last_section_address = dat->byte + sec->size - 0x100;
                       dwg->r2004_header.second_header_address = 0; // TODO
                     }
                   sec->address = dat->byte;
 
                   if (info->encrypted)
                     {
                       BITCODE_RC *decr = calloc (sec->size, 1);
                       LOG_HANDLE ("Encrypt %s (%u/%d)\n", info->name, k,
                                   sec->size);
                       decrypt_R2004_header (decr, sec_dat[type].chain,
                                             sec->size);
                       free (sec_dat[type].chain);
                       sec_dat[type].chain = decr;
                     }
                   assert (sec->size <= MIN_COMPRESSED_SECTION ? info->compressed == 1 : 1);
                   if (info->compressed == 2)
                     {
                       LOG_HANDLE ("Compress %s (%u/%d)\n", info->name, k,
                                   sec->size);
                       compress_R2004_section (dat, sec_dat[type].chain,
                                               sec->size, &sec->comp_data_size);
                       LOG_TRACE ("sec->comp_data_size: " FORMAT_RL "\n", sec->comp_data_size);
                     }
                   else
                     {
                       LOG_HANDLE ("Copy uncompressed %s (%u/%d)\n", info->name,
                                   k, sec->size);
                       copy_R2004_section (dat, sec_dat[type].chain, sec->size,
                                           &sec->comp_data_size);
                     }
                 }
               bit_chain_free (&sec_dat[type]);
             }
         }
     }
 
     {
       Dwg_R2004_Header *_obj = &dwg->r2004_header;
       Bit_Chain file_dat = { NULL, sizeof (Dwg_R2004_Header), 0UL, 0, 0, 0, 0, NULL };
       Bit_Chain *orig_dat = dat;
       /* "AcFssFcAJMB" encrypted: 6840F8F7922AB5EF18DD0BF1 */
       const unsigned char enc_file_ID_string[]
           = { '\x68', '\x40', '\xF8', '\xF7', '\x92', '\x2A',
               '\xB5', '\xEF', '\x18', '\xDD', '\x0B', '\xF1' };
       uint32_t checksum;
 
       file_dat.chain = calloc (1, sizeof (Dwg_R2004_Header));
       dat = &file_dat;
       LOG_TRACE ("\nSection R2004_Header @0x100\n");
 
       checksum = _obj->crc32;
       LOG_HANDLE ("old crc32: 0x%x\n", _obj->crc32);
       _obj->crc32 = 0;
       // recalc the CRC32, without the padding, but the crc32 as 0
       _obj->crc32
           = bit_calc_CRC32 (0, (unsigned char *)&dwg->r2004_header, 0x6c);
       LOG_HANDLE ("calc crc32: 0x%x\n", _obj->crc32);
 
       // clang-format off
       #include "r2004_file_header.spec"
       // clang-format on
 
       // go back and encrypt it
       dat = orig_dat;
       decrypt_R2004_header (&dat->chain[0x80], file_dat.chain,
                             sizeof (Dwg_R2004_Header));
       bit_chain_free (&file_dat);
       LOG_HANDLE ("encrypted R2004_Header:\n");
       LOG_TF (HANDLE, &dat->chain[0x80], (int)sizeof (Dwg_R2004_Header));
       if (memcmp (&dat->chain[0x80], enc_file_ID_string,
                   sizeof (enc_file_ID_string)))
         {
           LOG_ERROR ("r2004_file_header encryption error");
           return error | DWG_ERR_INVALIDDWG;
         }
     } // R2004_Header
   } // R_2004
 
   assert (!dat->bit);
   dat->size = dat->byte;
   LOG_INFO ("\nFinal DWG size: %u\n", (unsigned)dat->size);
 
   UNTIL (R_2000)
   {
     /* Patch section addresses
      */
     assert (section_address);
     dat->byte = section_address;
     dat->bit = 0;
     LOG_INFO ("\n=======> section addresses: %4u\n", (unsigned)dat->byte);
     for (j = 0; j < dwg->header.numsections; j++)
       {
         LOG_TRACE ("section[%u].number: %4d [RC] %s\n", j,
                    (int)dwg->header.section[j].number,
                    j < 6 ? dwg_section_name (dwg, j) : "");
         LOG_TRACE ("section[%u].offset: %4u [RL]\n", j,
                    (unsigned)dwg->header.section[j].address);
         LOG_TRACE ("section[%u].size:   %4u [RL]\n", j,
                    (int)dwg->header.section[j].size);
         if ((unsigned long)dwg->header.section[j].address
                 + dwg->header.section[j].size
             > dat->size)
           {
             if (is_section_r13_critical (j))
               {
                 LOG_ERROR ("section[%u] %s address or size overflow", j,
                            j < 6 ? dwg_section_name (dwg, j) : "");
                 return DWG_ERR_INVALIDDWG;
               }
             else
               {
                 LOG_WARN ("section[%u] %s address or size overflow, skipped",
                           j, j < 6 ? dwg_section_name (dwg, j) : "");
                 dwg->header.section[j].address = 0;
                 dwg->header.section[j].size = 0;
               }
           }
         bit_write_RC (dat, dwg->header.section[j].number);
         bit_write_RL (dat, dwg->header.section[j].address);
         bit_write_RL (dat, dwg->header.section[j].size);
       }
 
     /* Write CRC's
      */
     bit_write_CRC (dat, 0, 0);
     dat->byte -= 2;
     ckr = bit_read_CRC (dat);
     dat->byte -= 2;
     // FIXME: r13-2000 only
     switch (dwg->header.numsections)
       {
       case 3:
         ckr ^= 0xA598;
         break;
       case 4:
         ckr ^= 0x8101;
         break;
       case 5:
         ckr ^= 0x3CC4;
         break;
       case 6:
         ckr ^= 0x8461;
         break;
       default:
         break;
       }
     bit_write_RS (dat, ckr);
     LOG_TRACE ("crc: %04X (from 0)\n", ckr);
   }
 
   return 0;
 }
 // clang-format off
diff --git a/src/header_variables_r11.spec b/src/header_variables_r11.spec
index a54856cf..c1e86a82 100644
--- a/src/header_variables_r11.spec
+++ b/src/header_variables_r11.spec
@@ -1,318 +1,314 @@
 /* -*- c -*- */
 /*****************************************************************************/
 /*  LibreDWG - free implementation of the DWG file format                    */
 /*                                                                           */
 /*  Copyright (C) 2018-2022 Free Software Foundation, Inc.                   */
 /*                                                                           */
 /*  This library is free software, licensed under the terms of the GNU       */
 /*  General Public License as published by the Free Software Foundation,     */
 /*  either version 3 of the License, or (at your option) any later version.  */
 /*  You should have received a copy of the GNU General Public License        */
 /*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */
 /*****************************************************************************/
 
 /*
  * header_variables_r11.spec: DWG pre-R13 header variables specification
  * written by Reini Urban
  * improved by Michal Josef Špaček
  */
 
   #include "spec.h"
 
   FIELD_3RD (INSBASE, 10); //ok 0x5e
   VERSIONS (R_10, R_11) {
     FIELD_CAST (PLINEGEN, RS, B, 70); //ok
   } else {
     PRE (R_2_0)
       FIELD_RL (dwg_size, 0);
     PRE (R_10)
       FIELD_RS (numentities, 0);
   }
   FIELD_3RD (EXTMIN, 10);
   FIELD_3RD (EXTMAX, 10);
   FIELD_2RD (LIMMIN, 10);
   FIELD_2RD (LIMMAX, 10);
   FIELD_3RD (VIEWCTR, 10);
   FIELD_RD (VIEWSIZE, 40);
   FIELD_RS (SNAPMODE, 70);    //unhandled by ODA
   PRE (R_2_0) {
     FIELD_RD (SNAPUNIT.x, 10);
   }
   LATER_VERSIONS {
     FIELD_2RD (SNAPUNIT, 14);   //??
     FIELD_2RD (SNAPBASE, 13);   //??
     FIELD_RD (SNAPANG, 50);     //??
     FIELD_RS (SNAPSTYLE, 70);   //77 ??
     FIELD_RS (SNAPISOPAIR, 70); //78 ??
   }
   FIELD_RS (GRIDMODE, 70);    //76 ??
   PRE (R_2_0) {
     FIELD_RD (GRIDUNIT.x, 10);
   }
   LATER_VERSIONS {
     FIELD_2RD (GRIDUNIT, 10);
   }
   FIELD_CAST (ORTHOMODE, RS, B, 70); //ok
   FIELD_CAST (REGENMODE, RS, B, 70); //ok
   FIELD_CAST (FILLMODE, RS, B, 70);  //ok
   SINCE (R_2_0) {
     FIELD_CAST (QTEXTMODE, RS, B, 70); //ok
     FIELD_RS (DRAGMODE, 70); // 2 ineffective with r12
     FIELD_RD (LTSCALE, 40);  // 16.0 confirmed
   }
   FIELD_RD (TEXTSIZE, 40); //ok ineffective with r12
   FIELD_RD (TRACEWID, 40); //ok
   FIELD_HANDLE (CLAYER, 2, 8);
   PRE (R_2_0) {
     FIELD_RS (CECOLOR.index, 62);
   } else {
     FIELD_RL (oldCECOLOR_lo, 0); // CECOLOR converted from older DWG file
     FIELD_RL (oldCECOLOR_hi, 0); //            -"-
   }
   VERSIONS (R_1_2, R_1_4) {
     BITCODE_BL vcount;
     FIELD_VECTOR_INL (layer_colors, RS, 128, 0); // color of each layer
     FIELD_RD (DIMASZ, 40); //ok
     FIELD_RD (unknown_7, 40); //?
     VERSION (R_1_2) {
       dwg->header.dwg_version = 1;
       return error;
     }
   } else {
     FIELD_RS (unknown_5, 0);
     FIELD_CAST (PSLTSCALE, RS, B, 70);
     FIELD_RS (TREEDEPTH, 70);
     FIELD_RS (unknown_6, 0);
     FIELD_RD (unknown_7, 0); // converted from older DWG file (0x01d0)
   }
   FIELD_RS (LUNITS, 70); //ok
   FIELD_RS (LUPREC, 70); //ok
   VERSION (R_1_4) {
     FIELD_RS (DIMTOL, 70); // dim_text_within_dimension
     FIELD_RS (DIMLIM, 70); // dim_text_outside_of_dimension
   }
   FIELD_RS (AXISMODE, 70);
   FIELD_2RD (AXISUNIT, 10);
   FIELD_RD (SKETCHINC, 40); //ok default 0.1
   FIELD_RD (FILLETRAD, 40); //ok
   VERSION (R_1_4) {
     dwg->header.dwg_version = 2;
     return error;
   }
   FIELD_RS (AUNITS, 70);    //ok
   FIELD_RS (AUPREC, 70);    //ok
   FIELD_HANDLE (TEXTSTYLE, 2, 7);
   FIELD_CAST (OSMODE, RS, BL, 70);
   FIELD_RS (ATTMODE, 70);
   DECODER {
     if (FIELD_VALUE (MENU)) // already created by add_Document
       free (FIELD_VALUE (MENU));
   }
   FIELD_TFv (MENU, 15, 1);
   FIELD_RD (DIMSCALE, 40); //ok 0x1a3
   FIELD_RD (DIMASZ, 40); //ok
   FIELD_RD (DIMEXO, 40); //ok
   FIELD_RD (DIMDLI, 40); //ok
   FIELD_RD (DIMEXE, 40); //ok
   FIELD_RD (DIMTP, 40);  //ok
   FIELD_RD (DIMTM, 40);  //ok
   FIELD_RD (DIMTXT, 40); //ok
   FIELD_RD (DIMCEN, 40); //ok
   FIELD_RD (DIMTSZ, 40); //ok
   PRE (R_2_0) // AC1.2 definitely
     return 0;
   FIELD_RC (DIMTOL, 70); //ok 1f3
   FIELD_RC (DIMLIM, 70); //ok 1f4
   FIELD_RC (DIMTIH, 70); //ok 1f5
   FIELD_RC (DIMTOH, 70); //ok 1f6
   FIELD_RC (DIMSE1, 70); //ok
   FIELD_RC (DIMSE2, 70); //ok
   FIELD_CAST (DIMTAD, RC, RS, 70); //ok
   if (dwg->header.numheader_vars <= 74)
     return 0;
   FIELD_RC (LIMCHECK, 70); //ok 1fa
 
   /* TODO Unknown structure (0x01fc-0x0228) */
   // PLATFORM was until r11
   DEBUG_HERE //1fb
   UNKNOWN_UNTIL (0x229);
   FIELD_RD (ELEVATION, 40); //ok
   FIELD_RD (THICKNESS, 40); //ok
   FIELD_3RD (VIEWDIR, 10);
 
   /* TODO Unknown repeating variable - 18 floats, probably 6x 3d point */
   // probably RD sysvars: LASTANGLE, LASTPOINT, LASTPT3D. until r11
   // also there is VPOINTX/VPOINTY/VPOINTZ (replaced by VIEWDIR with r11)
   DEBUG_HERE //252
   UNKNOWN_UNTIL (0x2e1);
   FIELD_RS (unknown_18, 0);
   FIELD_CAST (BLIPMODE, RS, B, 70);
   if (dwg->header.numheader_vars <= 83) // PRE(R_2_21)
      return 0;
   FIELD_CAST (DIMZIN, RC, B, 70); //ok
   FIELD_RD (DIMRND, 40);
   FIELD_RD (DIMDLE, 40);
   FIELD_TFv (DIMBLK_T, 33, 1);
   FIELD_RS (circle_zoom_percent, 0);
   FIELD_RS (COORDS, 0);
   FIELD_RS (CECOLOR.index, 62);
   FIELD_HANDLE (CELTYPE, 2, 6); // ff for BYLAYER, fe for BYBLOCK
   FIELD_TIMERLL (TDCREATE, 40);
   FIELD_TIMERLL (TDUPDATE, 40);
   FIELD_TIMERLL (TDINDWG, 40);
   FIELD_TIMERLL (TDUSRTIMER, 40);
   FIELD_CAST (USRTIMER, RS, B, 70);
   FIELD_CAST (FASTZOOM, RS, B, 70);
   FIELD_RS (unknown_10, 0);
   FIELD_CAST (SKPOLY, RS, B, 70);
 
   /* TODO Unknown date structure (month, day, year, hour, minute, second, ms - all RS) */
   DEBUG_HERE //345
   UNKNOWN_UNTIL (0x353);
   FIELD_RD (ANGBASE, 50);
   FIELD_CAST (ANGDIR, RS, B, 70);
   if (dwg->header.numheader_vars <= 101)
     return 0;
   FIELD_RS (PDMODE, 70);
   FIELD_RD (PDSIZE, 40);
   FIELD_RD (PLINEWID, 40);
   if (dwg->header.numheader_vars <= 104)
     return 0;
 
   /* TODO Signed */
   FIELD_RS (USERI1, 70);
   FIELD_RS (USERI2, 70);
   FIELD_RS (USERI3, 70);
   FIELD_RS (USERI4, 70);
   FIELD_RS (USERI5, 70);
 
   FIELD_RD (USERR1, 40);
   FIELD_RD (USERR2, 40);
   FIELD_RD (USERR3, 40);
   FIELD_RD (USERR4, 40);
   FIELD_RD (USERR5, 40);
   if (dwg->header.numheader_vars <= 114)
     return 0;
   FIELD_RC (DIMALT, 70); //ok
   FIELD_CAST (DIMALTD, RC, RS, 70); //ok
   FIELD_RC (DIMASO, 70); //ok
   FIELD_RC (DIMSHO, 70); //ok
   FIELD_TFv (DIMPOST, 16, 1);
   FIELD_TFv (DIMAPOST, 16, 1);
   if (dwg->header.numheader_vars <= 120)
     return 0;
   FIELD_RD (DIMALTF, 40);
   FIELD_RD (DIMLFAC, 40);
   if (dwg->header.numheader_vars <= 122)
     return 0;
   FIELD_RS (SPLINESEGS, 70);
   FIELD_CAST (SPLFRAME, RS, B, 70);
   FIELD_RS (ATTREQ, 70);
   FIELD_RS (ATTDIA, 70);
   FIELD_RD (CHAMFERA, 40);
   FIELD_RD (CHAMFERB, 40);
   FIELD_CAST (MIRRTEXT, RS, B, 70);
   if (dwg->header.numheader_vars <= 129)
     return 0;
   /* Skip table UCS (0x3ef-0x3f9) */
   UNKNOWN_UNTIL (0x3fa);
   FIELD_RC (unknown_58, 0);
   FIELD_3RD (UCSORG, 10); //ok
   FIELD_3RD (UCSXDIR, 11); //ok
   FIELD_3RD (UCSYDIR, 12); //ok
   FIELD_3RD (TARGET, 0);
   FIELD_RD (LENSLENGTH, 0);
   FIELD_RD (VIEWTWIST, 0);
   FIELD_RD (FRONTZ, 0);
   FIELD_RD (BACKZ, 0);
   FIELD_CAST (VIEWMODE, RS, B, 70);
   FIELD_RC (DIMTOFL, 70); //ok
   FIELD_TFv (DIMBLK1_T, 33, 1);
   FIELD_TFv (DIMBLK2_T, 33, 1);
   FIELD_RC (DIMSAH, 70); //ok
   FIELD_RC (DIMTIX, 70); //ok
   FIELD_RC (DIMSOXD, 70); //ok
   FIELD_RD (DIMTVP, 40); //ok
   FIELD_TFv (unknown_string, 33, 1);
   FIELD_RS (HANDLING, 70); // use new HEX handles (should be RC)
   UNKNOWN_UNTIL (0x4ee);
   /* TODO fix HANDSEED - 00 00 00 00 00 00 12 35 mean 0x1235 */
   DECODER {
     _obj->HANDSEED = (BITCODE_H)calloc(1, sizeof(Dwg_Object_Ref));
     _obj->HANDSEED->absolute_ref = (BITCODE_RL)bit_read_RS (dat);
     LOG_TRACE ("HANDSEED: %lX [RS 5]\n", _obj->HANDSEED->absolute_ref)
   }
   FREE {
     free (_obj->HANDSEED);
   }
   DEBUG_HERE
   UNKNOWN_UNTIL (0x4f6);
   FIELD_RS (SURFU, 70); //ok
   FIELD_RS (SURFV, 70); //ok
   FIELD_RS (SURFTYPE, 70); //ok
   FIELD_RS (SURFTAB1, 70); //ok
   FIELD_RS (SURFTAB2, 70); //ok
   /* Skip table VPORT (0x500-0x509 )*/
-  DEBUG_HERE
   UNKNOWN_UNTIL (0x50a);
   FIELD_CAST (FLATLAND, RS, B, 70);
   FIELD_RS (SPLINETYPE, 70);
   FIELD_RS (UCSICON, 0);
   FIELD_RS (unknown_59, 0); // ff ff
   if (dwg->header.numheader_vars <= 158) // r10
     return 0;
 
   /* Skip table APPID (0x512-0x51b) */
-  DEBUG_HERE
   UNKNOWN_UNTIL (0x51c);
   FIELD_CAST (WORLDVIEW, RS, B, 70);
   if (dwg->header.numheader_vars <= 160) // r10
     return 0;
   FIELD_RS (unknown_51e, 0);
   FIELD_RS (unknown_520, 0);
   // TILEMODE came with r11
 
   /* Skip table DIMSTYLE (0x522-0x52b) */
-  DEBUG_HERE
   UNKNOWN_UNTIL (0x52c);
   /* TODO Unknown 5 bytes. (first two bytes sometimes ff ff) */
   DEBUG_HERE
   UNKNOWN_UNTIL (0x531);
   FIELD_RS (DIMCLRD_C, 70); //ok
   FIELD_RS (DIMCLRE_C, 70); //ok
   FIELD_RS (DIMCLRT_C, 70); //ok
   FIELD_RS (SHADEDGE, 70); //ok
   FIELD_RS (SHADEDIF, 70); //ok
   FIELD_RS (UNITMODE, 70); //ok, new with r11
 
   /* TODO Unknown 34 bytes */
   DEBUG_HERE //53d
   UNKNOWN_UNTIL (0x55f);
   FIELD_TFv (unknown_unit1, 32, 1);
   FIELD_TFv (unknown_unit2, 32, 1);
   FIELD_TFv (unknown_unit3, 32, 1);
   FIELD_TFv (unknown_unit4, 32, 1);
   FIELD_RD (DIMTFAC, 40); //ok
   FIELD_3RD (PUCSORG, 10); //ok
   FIELD_3RD (PUCSXDIR, 11); //ok
   FIELD_3RD (PUCSYDIR, 12); //ok
   FIELD_RS (unknown_10, 70); //ff ff/-1
   FIELD_RC (TILEMODE, 70); //ok
   FIELD_CAST (PLIMCHECK, RS, B, 70); //ok
   FIELD_RS (unknown_10, 70); //0
   FIELD_RC (unknown_11, 70); //0
   FIELD_3RD (PEXTMIN, 10); //ok 637
   FIELD_3RD (PEXTMAX, 10); //
   FIELD_2RD (PLIMMIN, 10); //
   FIELD_2RD (PLIMMAX, 10); //
   FIELD_3RD (PINSBASE, 10);
 
   /* Skip table VX (0x69f-0x6a8) */
-  DEBUG_HERE
   UNKNOWN_UNTIL (0x6a9);
   FIELD_RS (MAXACTVP, 70); //ok
   FIELD_RD (DIMGAP, 40);   //ok
   FIELD_RD (PELEVATION, 40); //ok
   if (dwg->header.numheader_vars <= 204)
     return 0;
   FIELD_CAST (VISRETAIN, RS, B, 70); //ok
