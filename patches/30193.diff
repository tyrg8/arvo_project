commit 57fca38a4f51687d71e451ae29df6b353764fb72
Author: Nathan Moinvaziri <nathan@nathanm.com>
Date:   Wed Feb 3 17:54:32 2021 -0800

    Cleanup blosc header reading and writing.

diff --git a/blosc/blosc-private.h b/blosc/blosc-private.h
index d8969503..83d20a74 100644
--- a/blosc/blosc-private.h
+++ b/blosc/blosc-private.h
@@ -62,28 +62,43 @@ static inline int32_t sw32_(const void* pa) {
 /* Copy 4 bytes from int32_t to @p *dest, changing endianness if necessary. */
 static inline void _sw32(void* dest, int32_t a) {
   uint8_t* dest_ = (uint8_t*)dest;
   uint8_t* pa = (uint8_t*)&a;
 
   bool little_endian = is_little_endian();
   if (little_endian) {
     *(int32_t *)dest_ = a;
   }
   else {
 #if defined (__GNUC__)
     *(int32_t *)dest_ = __builtin_bswap32(*(unsigned int *)pa);
 #elif defined (_MSC_VER) /* Visual Studio */
     *(int32_t *)dest_ = _byteswap_ulong(*(unsigned int *)pa);
 #else
     dest_[0] = pa[3];
     dest_[1] = pa[2];
     dest_[2] = pa[1];
     dest_[3] = pa[0];
 #endif
   }
 }
 
+/* Reverse swap bits in a 32-bit integer */
+static inline int32_t bswap32_(int32_t a) {
+#if defined (__GNUC__)
+  return __builtin_bswap32(a);
+#elif defined (_MSC_VER) /* Visual Studio */
+  return _byteswap_ulong(a);
+#else
+  a = ((a & 0x000000FF) << 24) |
+      ((a & 0x0000FF00) <<  8) |
+      ((a & 0x00FF0000) >>  8) |
+      ((a & 0xFF000000) >> 24);
+  return a;
+#endif
+}
+
 #ifdef __cplusplus
 }
 #endif
 
 #endif //IARRAY_BLOSC_PRIVATE_H
diff --git a/blosc/blosc2.c b/blosc/blosc2.c
index ecfaa064..6a986e49 100644
--- a/blosc/blosc2.c
+++ b/blosc/blosc2.c
@@ -277,38 +277,93 @@ int blosc_compcode_to_compname(int compcode, const char** compname) {
 /* Get the compressor code for the compressor name. -1 if it is not available */
 int blosc_compname_to_compcode(const char* compname) {
   int code = -1;  /* -1 means non-existent compressor code */
 
   if (strcmp(compname, BLOSC_BLOSCLZ_COMPNAME) == 0) {
     code = BLOSC_BLOSCLZ;
   }
 #if defined(HAVE_LZ4)
   else if (strcmp(compname, BLOSC_LZ4_COMPNAME) == 0) {
     code = BLOSC_LZ4;
   }
   else if (strcmp(compname, BLOSC_LZ4HC_COMPNAME) == 0) {
     code = BLOSC_LZ4HC;
   }
 #endif /*  HAVE_LZ4 */
 #if defined(HAVE_SNAPPY)
   else if (strcmp(compname, BLOSC_SNAPPY_COMPNAME) == 0) {
     code = BLOSC_SNAPPY;
   }
 #endif /*  HAVE_SNAPPY */
 #if defined(HAVE_ZLIB)
   else if (strcmp(compname, BLOSC_ZLIB_COMPNAME) == 0) {
     code = BLOSC_ZLIB;
   }
 #endif /*  HAVE_ZLIB */
 #if defined(HAVE_ZSTD)
   else if (strcmp(compname, BLOSC_ZSTD_COMPNAME) == 0) {
     code = BLOSC_ZSTD;
   }
 #endif /*  HAVE_ZSTD */
 
   return code;
 }
 
 
+/* Convert compressor code to blosc compressor format code */
+static int compcode_to_compformat(int compcode) {
+  switch (compcode) {
+    case BLOSC_BLOSCLZ: return BLOSC_BLOSCLZ_FORMAT;
+#if defined(HAVE_LZ4)
+    case BLOSC_LZ4:     return BLOSC_LZ4_FORMAT;
+    case BLOSC_LZ4HC:   return BLOSC_LZ4HC_FORMAT;
+#endif /*  HAVE_LZ4 */
+
+#if defined(HAVE_SNAPPY)
+    case BLOSC_SNAPPY:  return BLOSC_SNAPPY_FORMAT;
+#endif /*  HAVE_SNAPPY */
+
+#if defined(HAVE_ZLIB)
+    case BLOSC_ZLIB:    return BLOSC_ZLIB_FORMAT;
+#endif /*  HAVE_ZLIB */
+
+#if defined(HAVE_ZSTD)
+    case BLOSC_ZSTD:    return BLOSC_ZSTD_FORMAT;
+      break;
+#endif /*  HAVE_ZSTD */
+  }
+  return -1;
+}
+
+
+/* Convert compressor code to blosc compressor format version */
+static int compcode_to_compversion(int compcode) {
+  /* Write compressor format */
+  switch (compcode) {
+    case BLOSC_BLOSCLZ: return BLOSC_BLOSCLZ_VERSION_FORMAT;
+
+#if defined(HAVE_LZ4)
+    case BLOSC_LZ4:     return BLOSC_LZ4_VERSION_FORMAT;
+    case BLOSC_LZ4HC:   return BLOSC_LZ4HC_VERSION_FORMAT;
+#endif /*  HAVE_LZ4 */
+
+#if defined(HAVE_SNAPPY)
+    case BLOSC_SNAPPY:  return BLOSC_SNAPPY_VERSION_FORMAT;
+#endif /*  HAVE_SNAPPY */
+
+#if defined(HAVE_ZLIB)
+    case BLOSC_ZLIB:    return BLOSC_ZLIB_VERSION_FORMAT;
+      break;
+#endif /*  HAVE_ZLIB */
+
+#if defined(HAVE_ZSTD)
+    case BLOSC_ZSTD:    return BLOSC_ZSTD_VERSION_FORMAT;
+      break;
+#endif /*  HAVE_ZSTD */
+  }
+  return -1;
+}
+
+
 #if defined(HAVE_LZ4)
 static int lz4_wrap_compress(const char* input, size_t input_length,
                              char* output, size_t maxout, int accel, void* hash_table) {
@@ -534,6 +589,237 @@ int last_filter(const uint8_t* filters, char cmode) {
 }
 
 
+/* Convert filter pipeline to filter flags */
+static uint8_t filters_to_flags(const uint8_t* filters) {
+  uint8_t flags = 0;
+
+  for (int i = 0; i < BLOSC2_MAX_FILTERS; i++) {
+    switch (filters[i]) {
+      case BLOSC_SHUFFLE:
+        flags |= BLOSC_DOSHUFFLE;
+        break;
+      case BLOSC_BITSHUFFLE:
+        flags |= BLOSC_DOBITSHUFFLE;
+        break;
+      case BLOSC_DELTA:
+        flags |= BLOSC_DODELTA;
+        break;
+      default :
+        break;
+    }
+  }
+  return flags;
+}
+
+
+/* Convert filter flags to filter pipeline */
+static void flags_to_filters(const uint8_t flags, uint8_t* filters) {
+  /* Initialize the filter pipeline */
+  memset(filters, 0, BLOSC2_MAX_FILTERS);
+  /* Fill the filter pipeline */
+  if (flags & BLOSC_DOSHUFFLE)
+    filters[BLOSC2_MAX_FILTERS - 1] = BLOSC_SHUFFLE;
+  if (flags & BLOSC_DOBITSHUFFLE)
+    filters[BLOSC2_MAX_FILTERS - 1] = BLOSC_BITSHUFFLE;
+  if (flags & BLOSC_DODELTA)
+    filters[BLOSC2_MAX_FILTERS - 2] = BLOSC_DELTA;
+}
+
+
+/* Get filter flags from header flags */
+static uint8_t get_filter_flags(const uint8_t header_flags,
+                                const int32_t typesize) {
+  uint8_t flags = 0;
+
+  if ((header_flags & BLOSC_DOSHUFFLE) && (typesize > 1)) {
+    flags |= BLOSC_DOSHUFFLE;
+  }
+  if (header_flags & BLOSC_DOBITSHUFFLE) {
+    flags |= BLOSC_DOBITSHUFFLE;
+  }
+  if (header_flags & BLOSC_DODELTA) {
+    flags |= BLOSC_DODELTA;
+  }
+  if (header_flags & BLOSC_MEMCPYED) {
+    flags |= BLOSC_MEMCPYED;
+  }
+  return flags;
+}
+
+typedef struct blosc_header_s {
+  uint8_t version;
+  uint8_t versionlz;
+  uint8_t flags;
+  uint8_t typesize;
+  int32_t nbytes;
+  int32_t blocksize;
+  int32_t cbytes;
+  // Extended Blosc2 header
+  uint8_t filter_codes[BLOSC2_MAX_FILTERS];
+  int16_t reserved1;
+  uint8_t filter_meta[BLOSC2_MAX_FILTERS];
+  uint8_t reserved2;
+  uint8_t blosc2_flags;
+} blosc_header;
+
+
+int blosc_read_header(const uint8_t* src, int32_t srcsize, bool extended_header, blosc_header* header)
+{
+  memset(header, 0, sizeof(blosc_header));
+
+  if (srcsize < BLOSC_MIN_HEADER_LENGTH) {
+    BLOSC_TRACE_ERROR("Not enough space to read Blosc header.");
+    return BLOSC2_ERROR_READ_BUFFER;
+  }
+
+  memcpy(header, src, BLOSC_MIN_HEADER_LENGTH);
+
+  bool little_endian = is_little_endian();
+
+  if (!little_endian) {
+    header->nbytes = bswap32_(header->nbytes);
+    header->blocksize = bswap32_(header->blocksize);
+    header->cbytes = bswap32_(header->cbytes);
+  }
+
+  if (header->version > BLOSC_VERSION_FORMAT) {
+    /* Version from future */
+    return BLOSC2_ERROR_VERSION_SUPPORT;
+  }
+  if (header->cbytes < BLOSC_MIN_HEADER_LENGTH) {
+    BLOSC_TRACE_ERROR("`cbytes` is too small to read min header.");
+    return BLOSC2_ERROR_INVALID_HEADER;
+  }
+  if (header->blocksize <= 0 || header->blocksize > header->nbytes) {
+    BLOSC_TRACE_ERROR("`blocksize` is zero or greater than uncompressed size");
+    return BLOSC2_ERROR_INVALID_HEADER;
+  }
+  if (header->typesize <= 0 || header->typesize > BLOSC_MAX_TYPESIZE) {
+    BLOSC_TRACE_ERROR("`typesize` is zero or greater than max allowed.");
+    return BLOSC2_ERROR_INVALID_HEADER;
+  }
+
+  /* Read extended header if it is wanted */
+  if ((extended_header) && (header->flags & BLOSC_DOSHUFFLE) && (header->flags & BLOSC_DOBITSHUFFLE)) {
+    if (header->cbytes < BLOSC_EXTENDED_HEADER_LENGTH) {
+      BLOSC_TRACE_ERROR("`cbytes` is too small to read extended header.");
+      return BLOSC2_ERROR_INVALID_HEADER;
+    }
+    if (srcsize < BLOSC_EXTENDED_HEADER_LENGTH) {
+      BLOSC_TRACE_ERROR("Not enough space to read Blosc extended header.");
+      return BLOSC2_ERROR_READ_BUFFER;
+    }
+
+    memcpy((uint8_t *)header + BLOSC_MIN_HEADER_LENGTH, src + BLOSC_MIN_HEADER_LENGTH,
+      BLOSC_EXTENDED_HEADER_LENGTH - BLOSC_MIN_HEADER_LENGTH);
+
+    int32_t runlen_type = (header->blosc2_flags >> 4) & BLOSC2_RUNLEN_MASK;
+    if (runlen_type != 0) {
+      if (header->nbytes % header->typesize != 0) {
+        BLOSC_TRACE_ERROR("`nbytes` is not a multiple of typesize");
+        return BLOSC2_ERROR_INVALID_HEADER;
+      }
+      if (runlen_type == BLOSC2_VALUE_RUNLEN) {
+        if (header->cbytes < BLOSC_EXTENDED_HEADER_LENGTH + header->typesize) {
+          BLOSC_TRACE_ERROR("`cbytes` is too small for run length encoding");
+          return BLOSC2_ERROR_READ_BUFFER;
+        }
+      }
+    }
+    // The number of filters depends on the version of the header. Blosc2 alpha series
+    // did not initialize filters to zero beyond the max supported.
+    if (header->version == BLOSC2_VERSION_FORMAT_ALPHA) {
+      header->filter_codes[5] = 0;
+      header->filter_meta[5] = 0;
+    }
+  }
+  else {
+    flags_to_filters(header->flags, header->filter_codes);
+  }
+  return 0;
+}
+
+static inline void blosc2_calculate_blocks(blosc2_context* context) {
+  /* Compute number of blocks in buffer */
+  context->nblocks = context->sourcesize / context->blocksize;
+  context->leftover = context->sourcesize % context->blocksize;
+  context->nblocks = (context->leftover > 0) ?
+                     (context->nblocks + 1) : context->nblocks;
+}
+
+static int blosc2_initialize_context_from_header(blosc2_context* context, blosc_header* header) {
+  context->header_flags = header->flags;
+  context->typesize = header->typesize;
+  context->sourcesize = header->nbytes;
+  context->blocksize = header->blocksize;
+  context->blosc2_flags = header->blosc2_flags;
+
+  blosc2_calculate_blocks(context);
+
+  bool is_lazy = false;
+  if ((context->header_flags & BLOSC_DOSHUFFLE) &&
+      (context->header_flags & BLOSC_DOBITSHUFFLE)) {
+    /* Extended header */
+    context->header_overhead = BLOSC_EXTENDED_HEADER_LENGTH;
+
+    memcpy(context->filters, header->filter_codes, BLOSC2_MAX_FILTERS);
+    memcpy(context->filters_meta, header->filter_meta, BLOSC2_MAX_FILTERS);
+
+    context->filter_flags = filters_to_flags(header->filter_codes);
+
+    is_lazy = (context->blosc2_flags & 0x08u);
+  }
+  else {
+    context->header_overhead = BLOSC_MIN_HEADER_LENGTH;
+    context->filter_flags = get_filter_flags(context->header_flags, context->typesize);
+    flags_to_filters(context->header_flags, context->filters);
+  }
+
+  // Some checks for malformed headers
+  if (!is_lazy && header->cbytes > context->srcsize) {
+    return BLOSC2_ERROR_INVALID_HEADER;
+  }
+
+  return 0;
+}
+
+
+static int blosc2_intialize_header_from_context(blosc2_context* context, blosc_header* header, bool extended_header) {
+  memset(header, 0, sizeof(blosc_header));
+
+  header->version = BLOSC_VERSION_FORMAT;
+  header->versionlz = compcode_to_compversion(context->compcode);
+  header->flags = context->header_flags;
+  header->typesize = (uint8_t)context->typesize;
+  header->nbytes = (int32_t)context->sourcesize;
+  header->blocksize = (int32_t)context->blocksize;
+
+  int little_endian = is_little_endian();
+  if (!little_endian) {
+    header->nbytes = bswap32_(header->nbytes);
+    header->blocksize = bswap32_(header->blocksize);
+    // cbytes written after compression
+  }
+
+  if (extended_header) {
+    /* Store filter pipeline info at the end of the header */
+    for (int i = 0; i < BLOSC2_MAX_FILTERS; i++) {
+      header->filter_codes[i] = context->filters[i];
+      header->filter_meta[i] = context->filters_meta[i];
+    }
+
+    if (!little_endian) {
+      header->blosc2_flags |= BLOSC2_BIGENDIAN;
+    }
+    if (context->use_dict) {
+      header->blosc2_flags |= BLOSC2_USEDICT;
+    }
+  }
+
+  return 0;
+}
+
+
 uint8_t* pipeline_c(struct thread_context* thread_context, const int32_t bsize,
                     const uint8_t* src, const int32_t offset,
                     uint8_t* dest, uint8_t* tmp, uint8_t* tmp2) {
@@ -1347,456 +1633,260 @@ int check_nthreads(blosc2_context* context) {
 /* Do the compression or decompression of the buffer depending on the
    global params. */
 static int do_job(blosc2_context* context) {
   int32_t ntbytes;
 
   /* Set sentinels */
   context->dref_not_init = 1;
 
   /* Check whether we need to restart threads */
   check_nthreads(context);
 
   /* Run the serial version when nthreads is 1 or when the buffers are
      not larger than blocksize */
   if (context->nthreads == 1 || (context->sourcesize / context->blocksize) <= 1) {
     /* The context for this 'thread' has no been initialized yet */
     if (context->serial_context == NULL) {
       context->serial_context = create_thread_context(context, 0);
     }
     else if (context->blocksize != context->serial_context->tmp_blocksize) {
       free_thread_context(context->serial_context);
       context->serial_context = create_thread_context(context, 0);
     }
     ntbytes = serial_blosc(context->serial_context);
   }
   else {
     ntbytes = parallel_blosc(context);
   }
 
   return ntbytes;
 }
 
 
-/* Convert filter pipeline to filter flags */
-static uint8_t filters_to_flags(const uint8_t* filters) {
-  uint8_t flags = 0;
-
-  for (int i = 0; i < BLOSC2_MAX_FILTERS; i++) {
-    switch (filters[i]) {
-      case BLOSC_SHUFFLE:
-        flags |= BLOSC_DOSHUFFLE;
-        break;
-      case BLOSC_BITSHUFFLE:
-        flags |= BLOSC_DOBITSHUFFLE;
-        break;
-      case BLOSC_DELTA:
-        flags |= BLOSC_DODELTA;
-        break;
-      default :
-        break;
-    }
-  }
-  return flags;
-}
-
-
-/* Convert filter flags to filter pipeline */
-static void flags_to_filters(const uint8_t flags, uint8_t* filters) {
-  /* Initialize the filter pipeline */
-  memset(filters, 0, BLOSC2_MAX_FILTERS);
-  /* Fill the filter pipeline */
-  if (flags & BLOSC_DOSHUFFLE)
-    filters[BLOSC2_MAX_FILTERS - 1] = BLOSC_SHUFFLE;
-  if (flags & BLOSC_DOBITSHUFFLE)
-    filters[BLOSC2_MAX_FILTERS - 1] = BLOSC_BITSHUFFLE;
-  if (flags & BLOSC_DODELTA)
-    filters[BLOSC2_MAX_FILTERS - 2] = BLOSC_DELTA;
-}
-
-
 static int initialize_context_compression(
   blosc2_context* context, const void* src, int32_t srcsize, void* dest,
   int32_t destsize, int clevel, uint8_t const *filters,
   uint8_t const *filters_meta, int32_t typesize, int compressor,
   int32_t blocksize, int new_nthreads, int nthreads, blosc2_schunk* schunk) {
 
   /* Set parameters */
   context->do_compress = 1;
   context->src = (const uint8_t*)src;
   context->srcsize = srcsize;
   context->dest = (uint8_t*)dest;
   context->output_bytes = 0;
   context->destsize = destsize;
   context->sourcesize = srcsize;
   context->typesize = (int32_t)typesize;
   context->filter_flags = filters_to_flags(filters);
   for (int i = 0; i < BLOSC2_MAX_FILTERS; i++) {
     context->filters[i] = filters[i];
     context->filters_meta[i] = filters_meta[i];
   }
   context->compcode = compressor;
   context->nthreads = nthreads;
   context->new_nthreads = new_nthreads;
   context->end_threads = 0;
   context->clevel = clevel;
   context->schunk = schunk;
 
   /* Tune some compression parameters */
   context->blocksize = (int32_t)blocksize;
   if (context->btune != NULL) {
     btune_next_cparams(context);
   } else {
     btune_next_blocksize(context);
   }
 
   char* envvar = getenv("BLOSC_WARN");
   int warnlvl = 0;
   if (envvar != NULL) {
     warnlvl = strtol(envvar, NULL, 10);
   }
 
   /* Check buffer size limits */
   if (srcsize > BLOSC_MAX_BUFFERSIZE) {
     if (warnlvl > 0) {
       BLOSC_TRACE_ERROR("Input buffer size cannot exceed %d bytes.",
                         BLOSC_MAX_BUFFERSIZE);
     }
     return 0;
   }
 
   if (destsize < BLOSC_MAX_OVERHEAD) {
     if (warnlvl > 0) {
       BLOSC_TRACE_ERROR("Output buffer size should be larger than %d bytes.",
                         BLOSC_MAX_OVERHEAD);
     }
     return 0;
   }
 
   /* Compression level */
   if (clevel < 0 || clevel > 9) {
     /* If clevel not in 0..9, print an error */
     BLOSC_TRACE_ERROR("`clevel` parameter must be between 0 and 9!.");
     return BLOSC2_ERROR_CODEC_PARAM;
   }
 
   /* Check typesize limits */
-  if (context->typesize <= 0) {
-    BLOSC_TRACE_ERROR("`typesize` is less than or equal to zero.");
-    return -1;
-  }
   if (context->typesize > BLOSC_MAX_TYPESIZE) {
     /* If typesize is too large, treat buffer as an 1-byte stream. */
     context->typesize = 1;
   }
-  /* Check blocksize limits */
-  if (context->blocksize <= 0) {
-    BLOSC_TRACE_ERROR("`blocksize` is less than or equal to zero.");
-    return -1;
-  }
 
-  /* Compute number of blocks in buffer */
-  context->nblocks = context->sourcesize / context->blocksize;
-  context->leftover = context->sourcesize % context->blocksize;
-  context->nblocks = (context->leftover > 0) ?
-                     (context->nblocks + 1) : context->nblocks;
+  blosc2_calculate_blocks(context);
 
   return 1;
 }
 
 
-/* Get filter flags from header flags */
-static uint8_t get_filter_flags(const uint8_t header_flags,
-                                const int32_t typesize) {
-  uint8_t flags = 0;
-
-  if ((header_flags & BLOSC_DOSHUFFLE) && (typesize > 1)) {
-    flags |= BLOSC_DOSHUFFLE;
-  }
-  if (header_flags & BLOSC_DOBITSHUFFLE) {
-    flags |= BLOSC_DOBITSHUFFLE;
-  }
-  if (header_flags & BLOSC_DODELTA) {
-    flags |= BLOSC_DODELTA;
-  }
-  if (header_flags & BLOSC_MEMCPYED) {
-    flags |= BLOSC_MEMCPYED;
-  }
-  return flags;
-}
-
-static int initialize_context_decompression(blosc2_context* context, const void* src, int32_t srcsize,
-                                            void* dest, int32_t destsize) {
-  int32_t cbytes;
+static int initialize_context_decompression(blosc2_context* context, blosc_header* header, const void* src,
+                                            int32_t srcsize, void* dest, int32_t destsize) {
   int32_t bstarts_end;
 
   context->do_compress = 0;
   context->src = (const uint8_t*)src;
   context->srcsize = srcsize;
   context->dest = (uint8_t*)dest;
   context->destsize = destsize;
   context->output_bytes = 0;
   context->end_threads = 0;
 
-  if (context->srcsize < BLOSC_MIN_HEADER_LENGTH) {
-    /* Not enough input to read minimum header */
-    return BLOSC2_ERROR_READ_BUFFER;
+  int rc = blosc2_initialize_context_from_header(context, header);
+  if (rc < 0) {
+    return rc;
   }
 
-  context->header_flags = context->src[BLOSC2_CHUNK_FLAGS];
-  context->typesize = context->src[BLOSC2_CHUNK_TYPESIZE];
-  context->sourcesize = sw32_(context->src + BLOSC2_CHUNK_NBYTES);
-  context->blocksize = sw32_(context->src + BLOSC2_CHUNK_BLOCKSIZE);
-  cbytes = sw32_(context->src + BLOSC2_CHUNK_CBYTES);
-
   /* Check that we have enough space to decompress */
-  if (context->sourcesize > (int32_t)destsize) {
+  if (context->sourcesize > (int32_t)context->destsize) {
     return BLOSC2_ERROR_WRITE_BUFFER;
   }
-  /* Some checks for malformed headers */
-  if (context->blocksize <= 0 || context->blocksize > destsize ||
-      context->typesize <= 0 || context->typesize > BLOSC_MAX_TYPESIZE) {
-    return -1;
-  }
-
-  /* Total blocks */
-  context->nblocks = context->sourcesize / context->blocksize;
-  context->leftover = context->sourcesize % context->blocksize;
-  context->nblocks = (context->leftover > 0) ?
-                      context->nblocks + 1 : context->nblocks;
 
   if (context->block_maskout != NULL && context->block_maskout_nitems != context->nblocks) {
     BLOSC_TRACE_ERROR("The number of items in block_maskout (%d) must match the number"
                       " of blocks in chunk (%d).",
                       context->block_maskout_nitems, context->nblocks);
     return BLOSC2_ERROR_DATA;
   }
 
-  bool is_lazy = false;
-  if ((context->header_flags & BLOSC_DOSHUFFLE) &&
-      (context->header_flags & BLOSC_DOBITSHUFFLE)) {
-    /* Extended header */
-    if (context->srcsize < BLOSC_EXTENDED_HEADER_LENGTH) {
-      /* Not enough input to read extended header */
-      return BLOSC2_ERROR_READ_BUFFER;
-    }
-    context->header_overhead = BLOSC_EXTENDED_HEADER_LENGTH;
-    uint8_t* filters = (uint8_t*)(context->src + BLOSC_MIN_HEADER_LENGTH);
-    uint8_t* filters_meta = filters + 8;
-    uint8_t header_version = context->src[BLOSC2_CHUNK_VERSION];
-    // The number of filters depends on the version of the header
-    // (we need to read less because filters where not initialized to zero in blosc2 alpha series)
-    int max_filters = (header_version == BLOSC2_VERSION_FORMAT_ALPHA) ? 5 : BLOSC2_MAX_FILTERS;
-    for (int i = 0; i < max_filters; i++) {
-      context->filters[i] = filters[i];
-      context->filters_meta[i] = filters_meta[i];
-    }
-    context->filter_flags = filters_to_flags(filters);
-    context->blosc2_flags = context->src[BLOSC2_CHUNK_BLOSC2_FLAGS];
-    is_lazy = (context->blosc2_flags & 0x08u);
-  } else {
-    /* Regular (Blosc1) header */
-    context->header_overhead = BLOSC_MIN_HEADER_LENGTH;
-    context->filter_flags = get_filter_flags(context->header_flags,
-                                             context->typesize);
-    flags_to_filters(context->header_flags, context->filters);
-  }
-
-  // Some checks for malformed headers
-  if (context->blocksize <= 0 || context->blocksize > destsize ||
-      context->typesize <= 0 || context->typesize > BLOSC_MAX_TYPESIZE ||
-      (!is_lazy && cbytes > srcsize)) {
-    return BLOSC2_ERROR_INVALID_HEADER;
-  }
-
   context->bstarts = (int32_t*)(context->src + context->header_overhead);
   if (context->header_flags & (uint8_t)BLOSC_MEMCPYED) {
     /* If chunk is a memcpy, bstarts does not exist */
     bstarts_end = context->header_overhead;
   } else {
     bstarts_end = context->header_overhead + (context->nblocks * sizeof(int32_t));
   }
 
   if (srcsize < bstarts_end) {
     BLOSC_TRACE_ERROR("`bstarts` exceeds length of source buffer.");
     return BLOSC2_ERROR_READ_BUFFER;
   }
   srcsize -= bstarts_end;
 
   /* Read optional dictionary if flag set */
   if (context->blosc2_flags & BLOSC2_USEDICT) {
 #if defined(HAVE_ZSTD)
     context->use_dict = 1;
     if (context->dict_ddict != NULL) {
       // Free the existing dictionary (probably from another chunk)
       ZSTD_freeDDict(context->dict_ddict);
     }
     // The trained dictionary is after the bstarts block
     if (srcsize < (signed)sizeof(int32_t)) {
       BLOSC_TRACE_ERROR("Not enough space to read size of dictionary.");
       return BLOSC2_ERROR_READ_BUFFER;
     }
     srcsize -= sizeof(int32_t);
+    // Read dictionary size
     context->dict_size = (size_t)sw32_(context->src + bstarts_end);
     if (context->dict_size <= 0 || context->dict_size > BLOSC2_MAXDICTSIZE) {
       BLOSC_TRACE_ERROR("Dictionary size is smaller than minimum or larger than maximum allowed.");
       return BLOSC2_ERROR_CODEC_DICT;
     }
     if (srcsize < (int32_t)context->dict_size) {
       BLOSC_TRACE_ERROR("Not enough space to read entire dictionary.");
       return BLOSC2_ERROR_READ_BUFFER;
     }
     srcsize -= context->dict_size;
+    // Read dictionary
     context->dict_buffer = (void*)(context->src + bstarts_end + sizeof(int32_t));
     context->dict_ddict = ZSTD_createDDict(context->dict_buffer, context->dict_size);
 #endif   // HAVE_ZSTD
   }
 
   return 0;
 }
 
-
 static int write_compression_header(blosc2_context* context, bool extended_header) {
-  int32_t compformat;
+  blosc_header header;
   int dont_split;
   int dict_training = context->use_dict && (context->dict_cdict == NULL);
 
-  // Set the whole header to zeros so that the reserved values are zeroed
-  if (extended_header) {
-    memset(context->dest, 0, BLOSC_EXTENDED_HEADER_LENGTH);
-    context->header_overhead = BLOSC_EXTENDED_HEADER_LENGTH;
-  }
-  else {
-    memset(context->dest, 0, BLOSC_MIN_HEADER_LENGTH);
-    context->header_overhead = BLOSC_MIN_HEADER_LENGTH;
-  }
-
-  /* Write version header for this block */
-  context->dest[BLOSC2_CHUNK_VERSION] = BLOSC_VERSION_FORMAT;
-
-  /* Write compressor format */
-  compformat = -1;
-  switch (context->compcode) {
-    case BLOSC_BLOSCLZ:
-      compformat = BLOSC_BLOSCLZ_FORMAT;
-      context->dest[BLOSC2_CHUNK_VERSIONLZ] = BLOSC_BLOSCLZ_VERSION_FORMAT;
-      break;
-
-#if defined(HAVE_LZ4)
-    case BLOSC_LZ4:
-      compformat = BLOSC_LZ4_FORMAT;
-      context->dest[BLOSC2_CHUNK_VERSIONLZ] = BLOSC_LZ4_VERSION_FORMAT;
-      break;
-    case BLOSC_LZ4HC:
-      compformat = BLOSC_LZ4HC_FORMAT;
-      context->dest[BLOSC2_CHUNK_VERSIONLZ] = BLOSC_LZ4HC_VERSION_FORMAT;
-      break;
-#endif /*  HAVE_LZ4 */
-
-#if defined(HAVE_SNAPPY)
-    case BLOSC_SNAPPY:
-      compformat = BLOSC_SNAPPY_FORMAT;
-      context->dest[BLOSC2_CHUNK_VERSIONLZ] = BLOSC_SNAPPY_VERSION_FORMAT;
-      break;
-#endif /*  HAVE_SNAPPY */
-
-#if defined(HAVE_ZLIB)
-    case BLOSC_ZLIB:
-      compformat = BLOSC_ZLIB_FORMAT;
-      context->dest[BLOSC2_CHUNK_VERSIONLZ] = BLOSC_ZLIB_VERSION_FORMAT;
-      break;
-#endif /*  HAVE_ZLIB */
-
-#if defined(HAVE_ZSTD)
-    case BLOSC_ZSTD:
-      compformat = BLOSC_ZSTD_FORMAT;
-      context->dest[BLOSC2_CHUNK_VERSIONLZ] = BLOSC_ZSTD_VERSION_FORMAT;
-      break;
-#endif /*  HAVE_ZSTD */
-
-    default: {
-      const char* compname;
-      compname = clibcode_to_clibname(compformat);
-      BLOSC_TRACE_ERROR("Blosc has not been compiled with '%s' "
-                        "compression support.  Please use one having it.",
-                        compname);
-      return BLOSC2_ERROR_CODEC_SUPPORT;
-      break;
-    }
-  }
 
   if (context->clevel == 0) {
     /* Compression level 0 means buffer to be memcpy'ed */
     context->header_flags |= (uint8_t)BLOSC_MEMCPYED;
   }
-
   if (context->sourcesize < BLOSC_MIN_BUFFERSIZE) {
     /* Buffer is too small.  Try memcpy'ing. */
     context->header_flags |= (uint8_t)BLOSC_MEMCPYED;
   }
-  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;
 
-  context->dest[BLOSC2_CHUNK_FLAGS] = 0;                               /* zeroes flags */
-  context->dest[BLOSC2_CHUNK_TYPESIZE] = (uint8_t)context->typesize;
-  _sw32(context->dest + BLOSC2_CHUNK_NBYTES, (int32_t)context->sourcesize);
-  _sw32(context->dest + BLOSC2_CHUNK_BLOCKSIZE, (int32_t)context->blocksize);
+  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;
   if (extended_header) {
     /* Indicate that we are building an extended header */
+    context->header_overhead = BLOSC_EXTENDED_HEADER_LENGTH;
     context->header_flags |= (BLOSC_DOSHUFFLE | BLOSC_DOBITSHUFFLE);
     /* Store filter pipeline info at the end of the header */
-    uint8_t *filters = context->dest + BLOSC_MIN_HEADER_LENGTH;
-    uint8_t *filters_meta = filters + 8;
-    for (int i = 0; i < BLOSC2_MAX_FILTERS; i++) {
-      filters[i] = context->filters[i];
-      filters_meta[i] = context->filters_meta[i];
-    }
-    uint8_t* blosc2_flags = context->dest + BLOSC2_CHUNK_BLOSC2_FLAGS;
-    *blosc2_flags = 0;    // zeroes flags
-    *blosc2_flags |= is_little_endian() ? 0 : BLOSC2_BIGENDIAN;  // endianness
     if (dict_training || memcpyed) {
       context->bstarts = NULL;
       context->output_bytes = context->header_overhead;
     } else {
       context->bstarts = (int32_t*)(context->dest + context->header_overhead);
       context->output_bytes = context->header_overhead + sizeof(int32_t) * context->nblocks;
     }
-    if (context->use_dict) {
-      *blosc2_flags |= BLOSC2_USEDICT;
-    }
   } else {
     // Regular header
+    context->header_overhead = BLOSC_MIN_HEADER_LENGTH;
     if (memcpyed) {
       context->bstarts = NULL;
       context->output_bytes = context->header_overhead;
     } else {
       context->bstarts = (int32_t *) (context->dest + context->header_overhead);
       context->output_bytes = context->header_overhead + sizeof(int32_t) * context->nblocks;
     }
   }
 
   // when memcpyed bit is set, there is no point in dealing with others
   if (!memcpyed) {
     if (context->filter_flags & BLOSC_DOSHUFFLE) {
       /* Byte-shuffle is active */
       context->header_flags |= BLOSC_DOSHUFFLE;
     }
 
     if (context->filter_flags & BLOSC_DOBITSHUFFLE) {
       /* Bit-shuffle is active */
       context->header_flags |= BLOSC_DOBITSHUFFLE;
     }
 
     if (context->filter_flags & BLOSC_DODELTA) {
       /* Delta is active */
       context->header_flags |= BLOSC_DODELTA;
     }
 
     dont_split = !split_block(context, context->typesize,
                               context->blocksize, extended_header);
-    context->header_flags |= dont_split << 4;  /* dont_split is in bit 4 */
-    context->header_flags |= compformat << 5;  /* codec starts at bit 5 */
+
+    /* dont_split is in bit 4 */
+    context->header_flags |= dont_split << 4;
+    /* codec starts at bit 5 */
+    context->header_flags |= compcode_to_compformat(context->compcode) << 5;
   }
 
-  // store header flags in dest
-  context->dest[BLOSC2_CHUNK_FLAGS] = context->header_flags;
+  // Create blosc header and store to dest
+  blosc2_intialize_header_from_context(context, &header, extended_header);
+
+  memcpy(context->dest, &header, (extended_header) ?
+    BLOSC_EXTENDED_HEADER_LENGTH : BLOSC_MIN_HEADER_LENGTH);
 
   return 1;
 }
@@ -2148,166 +2238,126 @@ int blosc_compress(int clevel, int doshuffle, size_t typesize, size_t nbytes,
 }
 
 
-int set_nans(uint8_t* src, int32_t nitems, uint8_t* dest, int32_t destsize) {
-  int32_t typesize = src[BLOSC2_CHUNK_TYPESIZE];
-  int32_t nbytes_chunk = sw32_(src + BLOSC2_CHUNK_NBYTES);
-  int32_t nbytes = nitems * typesize;
-  int32_t cbytes_chunk = sw32_(src + BLOSC2_CHUNK_CBYTES);
-
-  if (nbytes_chunk % typesize != 0) {
-    BLOSC_TRACE_ERROR("nbytes is not a multiple of typesize");
-    return BLOSC2_ERROR_DATA;
-  }
-  if (cbytes_chunk < BLOSC_EXTENDED_HEADER_LENGTH) {
-    BLOSC_TRACE_ERROR("Not enough space in src");
-    return BLOSC2_ERROR_READ_BUFFER;
+int set_nans(blosc_header* header, uint8_t* src, uint8_t* dest, int32_t destsize) {
+  int32_t nitems = header->nbytes / header->typesize;
+  if (nitems > destsize / header->typesize) {
+    nitems = destsize / header->typesize;
   }
-  if (nbytes > destsize) {
+
+  if (header->typesize > destsize) {
     BLOSC_TRACE_ERROR("Not enough space in dest");
     return BLOSC2_ERROR_WRITE_BUFFER;
   }
 
-  if (typesize == 4) {
+  if (header->typesize == 4) {
     float* dest_ = (float*)dest;
     for (int i = 0; i < nitems; i++) {
       dest_[i] = nanf("");
     }
-    return nbytes;
+    return header->nbytes;
   }
-  else if (typesize == 8) {
+  else if (header->typesize == 8) {
     double* dest_ = (double*)dest;
     for (int i = 0; i < nitems; i++) {
       dest_[i] = nan("");
     }
-    return nbytes;
+    return header->nbytes;
   }
 
   BLOSC_TRACE_ERROR("Unsupported typesize for NaN");
   return BLOSC2_ERROR_DATA;
 }
 
 
-int set_values(uint8_t* src, int32_t nitems, uint8_t* dest, int32_t destsize) {
-  int32_t typesize = src[BLOSC2_CHUNK_TYPESIZE];
-  int32_t nbytes_chunk = sw32_(src + BLOSC2_CHUNK_NBYTES);;
-  int32_t nbytes = nitems * typesize;
-  int32_t cbytes_chunk = sw32_(src + BLOSC2_CHUNK_CBYTES);;
-
-  if (nbytes_chunk % typesize != 0) {
-    BLOSC_TRACE_ERROR("nbytes is not a multiple of typesize");
-    return BLOSC2_ERROR_DATA;
+int set_values(blosc_header* header, uint8_t* src, uint8_t* dest, int32_t destsize) {
+  int32_t nitems = header->nbytes / header->typesize;
+  if (nitems > destsize / header->typesize) {
+    nitems = destsize / header->typesize;
   }
-  if (cbytes_chunk < BLOSC_EXTENDED_HEADER_LENGTH + typesize) {
-    BLOSC_TRACE_ERROR("Not enough space in src");
-    return BLOSC2_ERROR_READ_BUFFER;
-  }
-  if (nbytes > destsize) {
+
+  if (header->typesize > destsize) {
     BLOSC_TRACE_ERROR("Not enough space in dest");
     return BLOSC2_ERROR_WRITE_BUFFER;
   }
-
   // Get the value at the end of the header
-  void* value = malloc(typesize);
-  memcpy(value, src + BLOSC_EXTENDED_HEADER_LENGTH, typesize);
+  void* value = malloc(header->typesize);
+  memcpy(value, src + BLOSC_EXTENDED_HEADER_LENGTH, header->typesize);
   // And copy it to dest
   for (int i = 0; i < nitems; i++) {
-    memcpy(dest + i * typesize, value, typesize);
+    memcpy(dest + i * header->typesize, value, header->typesize);
   }
   free(value);
 
-  return nbytes_chunk;
+  return header->nbytes;
 }
 
 
 // Return > 0 if runlen.  0 if not a runlen.
-int handle_runlen(blosc2_context* context, uint8_t* src, uint32_t nbytes, uint8_t* dest, int32_t destsize) {
-  bool doshuffle_flag = src[BLOSC2_CHUNK_FLAGS] & BLOSC_DOSHUFFLE;
-  bool dobitshuffle_flag = src[BLOSC2_CHUNK_FLAGS] & BLOSC_DOBITSHUFFLE;
-  if (!(doshuffle_flag & dobitshuffle_flag)) {
-    // Not a Blosc2 chunk.  It cannot have a runlen.
-    return 0;
-  }
-  context->header_overhead = BLOSC_EXTENDED_HEADER_LENGTH;  // a Blosc2 chunk
-  int32_t cbytes_chunk = src[BLOSC2_CHUNK_CBYTES];
-  int32_t typesize = src[BLOSC2_CHUNK_TYPESIZE];
-  // Some checks for malformed headers
-  if (typesize <= 0 || typesize > BLOSC_MAX_TYPESIZE) {
-    return BLOSC2_ERROR_DATA;
-  }
-  bool all_zeros = src[BLOSC2_CHUNK_BLOSC2_FLAGS] & (BLOSC2_ZERO_RUNLEN << 4);
-  bool all_nans = src[BLOSC2_CHUNK_BLOSC2_FLAGS] & (BLOSC2_NAN_RUNLEN << 4);
-  if ((cbytes_chunk != context->header_overhead + typesize) && (cbytes_chunk != context->header_overhead)) {
-    return 0;
-  }
-  // all_values need to be checked first!
-  if (all_zeros && all_nans) {
-    // All repeated values
-    int32_t nitems = nbytes / typesize;
-    int rc = set_values(src, nitems, dest, destsize);
-    return rc;
-  }
-  else if (all_nans) {
-    int32_t nitems = nbytes / typesize;
-    int rc = set_nans(src, nitems, dest, destsize);
-    return rc;
-  }
-  else if (all_zeros) {
-    memset(dest, 0, nbytes);
-    return nbytes;
+int handle_runlen(blosc_header *header, uint8_t* src, uint8_t* dest, int32_t destsize) {
+  bool doshuffle_flag = header->flags & BLOSC_DOSHUFFLE;
+  bool dobitshuffle_flag = header->flags & BLOSC_DOBITSHUFFLE;
+  int rc = 0;
+
+  if (doshuffle_flag & dobitshuffle_flag) {
+    int32_t runlen_type = (header->blosc2_flags >> 4) & BLOSC2_RUNLEN_MASK;
+    if (runlen_type == BLOSC2_VALUE_RUNLEN) {
+      // All repeated values
+      rc = set_values(header, src, dest, destsize);
+    }
+    else if (runlen_type == BLOSC2_NAN_RUNLEN) {
+      rc = set_nans(header, src, dest, destsize);
+    }
+    else if (runlen_type == BLOSC2_ZERO_RUNLEN) {
+      memset(dest, 0, destsize);
+      rc = header->nbytes;
+    }
   }
 
-  // 0 means no special value
-  return 0;
+  return rc;
 }
 
 
 int blosc_run_decompression_with_context(blosc2_context* context, const void* src, int32_t srcsize,
                                          void* dest, int32_t destsize) {
+  blosc_header header;
   int32_t ntbytes;
   uint8_t* _src = (uint8_t*)src;
-  uint8_t version;
-  int error;
+  int rc;
 
-  if (srcsize <= 0) {
-    /* Invalid argument */
-    return BLOSC2_ERROR_INVALID_PARAM;
-  }
-  version = _src[BLOSC2_CHUNK_VERSION];                        /* blosc format version */
-  if (version > BLOSC_VERSION_FORMAT) {
-    /* Version from future */
-    return BLOSC2_ERROR_VERSION_SUPPORT;
+  rc = blosc_read_header(src, srcsize, true, &header);
+  if (rc < 0) {
+    return rc;
   }
 
-  ntbytes = sw32_(_src + BLOSC2_CHUNK_NBYTES);
-  if (ntbytes > destsize) {
+  if (header.nbytes > destsize) {
     // Not enough space for writing into the destination
     return BLOSC2_ERROR_WRITE_BUFFER;
   }
 
   // Is that a chunk with a special value (runlen)?
-  int rc = handle_runlen(context, _src, ntbytes, dest, destsize);
+  rc = handle_runlen(&header, _src, dest, destsize);
   if (rc < 0) {
     return rc;
   }
   if (rc > 0) {
     // This means that we have found a special value and we are done.
     return rc;
   }
 
-  error = initialize_context_decompression(context, src, srcsize, dest, destsize);
-  if (error < 0) {
-    return error;
+  rc = initialize_context_decompression(context, &header, src, srcsize, dest, destsize);
+  if (rc < 0) {
+    return rc;
   }
 
   /* Do the actual decompression */
   ntbytes = do_job(context);
   if (ntbytes < 0) {
     return ntbytes;
   }
 
   assert(ntbytes <= (int32_t)destsize);
   return ntbytes;
 }
 
 
 /* The public secure routine for decompression with context. */
@@ -2386,239 +2436,174 @@ int blosc_decompress(const void* src, void* dest, size_t destsize) {
 /* Specific routine optimized for decompression a small number of
    items out of a compressed chunk.  This does not use threads because
    it would affect negatively to performance. */
-int _blosc_getitem(blosc2_context* context, const void* src, int32_t srcsize,
-                   int start, int nitems, void* dest) {
-  uint8_t* _src = NULL;             /* current pos for source buffer */
-  uint8_t flags;                    /* flags for header */
+int _blosc_getitem(blosc2_context* context, blosc_header* header, const void* src, int32_t srcsize,
+                   int start, int nitems, void* dest, int32_t destsize) {
+  uint8_t* _src = (uint8_t*)(src);  /* current pos for source buffer */
   int32_t ntbytes = 0;              /* the number of uncompressed bytes */
-  int32_t nblocks;                   /* number of total blocks in buffer */
-  int32_t leftover;                  /* extra bytes at end of buffer */
-  int32_t* bstarts;                /* start pointers for each block */
-  int32_t typesize, blocksize, nbytes;
   int32_t bsize, bsize2, ebsize, leftoverblock;
   int32_t cbytes;
   int32_t startb, stopb;
   int32_t stop = start + nitems;
-  int j;
+  int j, rc;
 
   if (nitems == 0) {
     // We have nothing to do
     return 0;
   }
-
-  if (srcsize < BLOSC_MIN_HEADER_LENGTH) {
-    BLOSC_TRACE_ERROR("Not enough space to read Blosc1 header.");
-    return BLOSC2_ERROR_READ_BUFFER;
+  if (nitems * header->typesize > destsize) {
+    BLOSC_TRACE_ERROR("`nitems`*`typesize` out of dest bounds.");
+    return BLOSC2_ERROR_WRITE_BUFFER;
   }
-  _src = (uint8_t*)(src);
-
-  /* Read the header block */
-  flags = _src[BLOSC2_CHUNK_FLAGS];                  /* flags */
-  bool memcpyed = flags & (uint8_t)BLOSC_MEMCPYED;
-  typesize = (int32_t)_src[BLOSC2_CHUNK_TYPESIZE];      /* typesize */
-  nbytes = sw32_(_src + BLOSC2_CHUNK_NBYTES);         /* buffer size */
-  blocksize = sw32_(_src + BLOSC2_CHUNK_BLOCKSIZE);      /* block size */
-  cbytes = sw32_(_src + BLOSC2_CHUNK_CBYTES);    /* compressed buffer size */
-  ebsize = blocksize + typesize * (signed)sizeof(int32_t);
 
   // Is that a chunk with a special value (runlen)?
-  int rc = handle_runlen(context, _src, nitems * typesize, dest, nitems * typesize);
+  rc = handle_runlen(header, _src, dest, nitems * header->typesize);
   if (rc < 0) {
     return rc;
   }
   if (rc > 0) {
     // This means that we have found a special value and we are done.
     return rc;
   }
 
-  if (blocksize <= 0) {
-    /* Invalid block size */
-    return BLOSC2_ERROR_DATA;
-  }
-
-  /* Total blocks */
-  nblocks = nbytes / blocksize;
-  leftover = nbytes % blocksize;
-  nblocks = (leftover > 0) ? nblocks + 1 : nblocks;
-
-  if (srcsize < context->header_overhead) {
-    /* Not enough input to parse header */
-    return BLOSC2_ERROR_READ_BUFFER;
-  }
-
-  if (context->header_overhead == BLOSC_EXTENDED_HEADER_LENGTH) {
-    /* Extended header */
-    uint8_t* filters = _src + BLOSC_MIN_HEADER_LENGTH;
-    uint8_t* filters_meta = filters + 8;
-    for (int i = 0; i < BLOSC2_MAX_FILTERS; i++) {
-      context->filters[i] = filters[i];
-      context->filters_meta[i] = filters_meta[i];
-    }
-    bstarts = (int32_t*)(_src + context->header_overhead);
-    // The next is needed for lazy chunks
-    context->nblocks = nblocks;
-    context->blosc2_flags = _src[BLOSC2_CHUNK_BLOSC2_FLAGS];
-  } else {
-    /* Minimal header */
-    flags_to_filters(flags, context->filters);
-    bstarts = (int32_t*)(_src + context->header_overhead);
-  }
-
-  // Some checks for malformed buffers
-  if (blocksize <= 0 || blocksize > nbytes || typesize <= 0 || typesize > BLOSC_MAX_TYPESIZE) {
-    return BLOSC2_ERROR_INVALID_HEADER;
-  }
+  context->bstarts = (int32_t*)(_src + context->header_overhead);
 
   /* Check region boundaries */
-  if ((start < 0) || (start * typesize > nbytes)) {
+  if ((start < 0) || (start * header->typesize > header->nbytes)) {
     BLOSC_TRACE_ERROR("`start` out of bounds.");
-    return BLOSC2_ERROR_DATA;
+    return BLOSC2_ERROR_INVALID_PARAM;
   }
 
-  if ((stop < 0) || (stop * typesize > nbytes)) {
+  if ((stop < 0) || (stop * header->typesize > header->nbytes)) {
     BLOSC_TRACE_ERROR("`start`+`nitems` out of bounds.");
-    return BLOSC2_ERROR_DATA;
+    return BLOSC2_ERROR_INVALID_PARAM;
   }
 
-  if (_src + srcsize < (uint8_t *)(bstarts + nblocks)) {
+  if (_src + srcsize < (uint8_t *)(context->bstarts + context->nblocks)) {
     BLOSC_TRACE_ERROR("`bstarts` out of bounds.");
-    return BLOSC2_ERROR_DATA;
+    return BLOSC2_ERROR_READ_BUFFER;
   }
 
-  for (j = 0; j < nblocks; j++) {
-    bsize = blocksize;
+  ebsize = header->blocksize + header->typesize * (signed)sizeof(int32_t);
+
+  for (j = 0; j < context->nblocks; j++) {
+    bsize = header->blocksize;
     leftoverblock = 0;
-    if ((j == nblocks - 1) && (leftover > 0)) {
-      bsize = leftover;
+    if ((j == context->nblocks - 1) && (context->leftover > 0)) {
+      bsize = context->leftover;
       leftoverblock = 1;
     }
 
     /* Compute start & stop for each block */
-    startb = start * typesize - j * blocksize;
-    stopb = stop * typesize - j * blocksize;
+    startb = start * header->typesize - j * header->blocksize;
+    stopb = stop * header->typesize - j * header->blocksize;
     if (stopb <= 0) {
       // We can exit as soon as this block is beyond stop
       break;
     }
-    if (startb >= blocksize) {
+    if (startb >= header->blocksize) {
       continue;
     }
     if (startb < 0) {
       startb = 0;
     }
-    if (stopb > blocksize) {
-      stopb = blocksize;
+    if (stopb > header->blocksize) {
+      stopb = header->blocksize;
     }
     bsize2 = stopb - startb;
 
     /* Do the actual data copy */
     struct thread_context* scontext = context->serial_context;
 
     /* Resize the temporaries in serial context if needed */
-    if (blocksize > scontext->tmp_blocksize) {
+    if (header->blocksize > scontext->tmp_blocksize) {
       my_free(scontext->tmp);
       scontext->tmp_nbytes = (size_t)4 * ebsize;
       scontext->tmp = my_malloc(scontext->tmp_nbytes);
       scontext->tmp2 = scontext->tmp + ebsize;
       scontext->tmp3 = scontext->tmp2 + ebsize;
       scontext->tmp4 = scontext->tmp3 + ebsize;
-      scontext->tmp_blocksize = (int32_t)blocksize;
+      scontext->tmp_blocksize = (int32_t)header->blocksize;
     }
 
     // Regular decompression.  Put results in tmp2.
     // If the block is aligned and the worst case fits in destination, let's avoid a copy
-    bool get_single_block = ((startb == 0) && (bsize == nitems * typesize));
+    bool get_single_block = ((startb == 0) && (bsize == nitems * header->typesize));
     uint8_t* tmp2 = get_single_block ? dest : scontext->tmp2;
+    bool memcpyed = header->flags & (uint8_t)BLOSC_MEMCPYED;
     // If memcpyed we don't have a bstarts section (because it is not needed)
-    int32_t src_offset = memcpyed ? context->header_overhead + j * bsize : sw32_(bstarts + j);
+    int32_t src_offset = memcpyed ?
+      context->header_overhead + j * bsize : sw32_(context->bstarts + j);
+
     cbytes = blosc_d(context->serial_context, bsize, leftoverblock,
                      src, srcsize, src_offset, j,
                      tmp2, 0, scontext->tmp, scontext->tmp3);
     if (cbytes < 0) {
       ntbytes = cbytes;
       break;
     }
     if (!get_single_block) {
       /* Copy to destination */
       memcpy((uint8_t *) dest + ntbytes, tmp2 + startb, (unsigned int) bsize2);
     }
     cbytes = (int)bsize2;
     ntbytes += cbytes;
   }
 
   return ntbytes;
 }
 
 
 /* Specific routine optimized for decompression a small number of
    items out of a compressed chunk.  Public non-contextual API. */
 int blosc_getitem(const void* src, int start, int nitems, void* dest) {
-  uint8_t* _src = (uint8_t*)(src);
   blosc2_context context;
   int result;
 
-  uint8_t version = _src[BLOSC2_CHUNK_VERSION];                        /* blosc format version */
-  if (version > BLOSC_VERSION_FORMAT) {
-    /* Version from future */
-    return BLOSC2_ERROR_VERSION_SUPPORT;
-  }
-
   /* Minimally populate the context */
   memset(&context, 0, sizeof(blosc2_context));
-  context.src = src;
-  context.dest = dest;
-  context.typesize = (uint8_t)_src[BLOSC2_CHUNK_TYPESIZE];
-  context.blocksize = sw32_(_src + BLOSC2_CHUNK_BLOCKSIZE);
-  context.header_flags = *(_src + 2);
-  context.filter_flags = get_filter_flags(context.header_flags, context.typesize);
+
   context.schunk = g_schunk;
   context.nthreads = 1;  // force a serial decompression; fixes #95
-  context.serial_context = create_thread_context(&context, 0);
-  if ((context.header_flags & BLOSC_DOSHUFFLE) &&
-      (context.header_flags & BLOSC_DOBITSHUFFLE)) {
-    // Support for lazy chunks exists only for Blosc2, and needs the context.
-    context.blosc2_flags = _src[BLOSC2_CHUNK_BLOSC2_FLAGS];
-    context.header_overhead = BLOSC_EXTENDED_HEADER_LENGTH;
-    if (context.blosc2_flags & 0x08) {
-      BLOSC_TRACE_ERROR("blosc_getitem does not support lazy chunks.  Use blosc2_getitem_ctx instead.");
-      return BLOSC2_ERROR_INVALID_PARAM;
-    }
-  }
-  else {
-    context.header_overhead = BLOSC_MIN_HEADER_LENGTH;
-  }
 
   /* Call the actual getitem function */
-  result = _blosc_getitem(&context, src, INT32_MAX, start, nitems, dest);
+  result = blosc2_getitem_ctx(&context, src, INT32_MAX, start, nitems, dest, INT32_MAX);
 
   /* Release resources */
-  free_thread_context(context.serial_context);
+  if (context.serial_context != NULL) {
+    free_thread_context(context.serial_context);
+  }
   return result;
 }
 
 int blosc2_getitem_ctx(blosc2_context* context, const void* src, int32_t srcsize,
-    int start, int nitems, void* dest) {
-  uint8_t* _src = (uint8_t*)(src);
+    int start, int nitems, void* dest, int32_t destsize) {
+  blosc_header header;
   int result;
 
-  if (srcsize < BLOSC_MIN_HEADER_LENGTH) {
-    BLOSC_TRACE_ERROR("Not enough space to read Blosc1 header.");
-    return BLOSC2_ERROR_READ_BUFFER;
+  /* Minimally populate the context */
+  result = blosc_read_header((uint8_t *)src, srcsize, true, &header);
+  if (result < 0) {
+    return result;
+  }
+
+  context->src = src;
+  context->srcsize = srcsize;
+  context->dest = dest;
+  context->destsize = destsize;
+
+  result = blosc2_initialize_context_from_header(context, &header);
+  if (result < 0) {
+    return result;
   }
 
-  /* Minimally populate the context */
-  context->typesize = _src[BLOSC2_CHUNK_TYPESIZE];
-  context->blocksize = sw32_(_src + BLOSC2_CHUNK_BLOCKSIZE);
-  context->header_flags = *(_src + 2);
-  context->filter_flags = get_filter_flags(*(_src + 2), context->typesize);
   if (context->serial_context == NULL) {
     context->serial_context = create_thread_context(context, 0);
   }
 
   /* Call the actual getitem function */
-  result = _blosc_getitem(context, src, srcsize, start, nitems, dest);
+  result = _blosc_getitem(context, &header, src, srcsize, start, nitems, dest, destsize);
 
   return result;
 }
 
 /* execute single compression/decompression job for a single thread_context */
@@ -3048,80 +3033,87 @@ int blosc_get_complib_info(const char* compname, char** complib, char** version)
 /* Return `nbytes`, `cbytes` and `blocksize` from a compressed buffer. */
 void blosc_cbuffer_sizes(const void* cbuffer, size_t* nbytes,
                          size_t* cbytes, size_t* blocksize) {
-  uint8_t* _src = (uint8_t*)(cbuffer);    /* current pos for source buffer */
-  uint8_t version = _src[BLOSC2_CHUNK_VERSION];     /* blosc format version */
-  if (version > BLOSC_VERSION_FORMAT) {
-    /* Version from future */
+  blosc_header header;
+  int rc = blosc_read_header((uint8_t*)cbuffer, BLOSC_MIN_HEADER_LENGTH, false, &header);
+  if (rc < 0) {
     *nbytes = *blocksize = *cbytes = 0;
     return;
   }
 
   /* Read the interesting values */
-  *nbytes = (size_t)sw32_(_src + BLOSC2_CHUNK_NBYTES);       /* uncompressed buffer size */
-  *blocksize = (size_t)sw32_(_src + BLOSC2_CHUNK_BLOCKSIZE);    /* block size */
-  *cbytes = (size_t)sw32_(_src + BLOSC2_CHUNK_CBYTES);      /* compressed buffer size */
+  *nbytes = header.nbytes;
+  *blocksize = header.blocksize;
+  *cbytes = header.cbytes;
 }
 
 int blosc_cbuffer_validate(const void* cbuffer, size_t cbytes, size_t* nbytes) {
   size_t header_cbytes, header_blocksize;
   if (cbytes < BLOSC_MIN_HEADER_LENGTH) {
     /* Compressed data should contain enough space for header */
     *nbytes = 0;
     return BLOSC2_ERROR_WRITE_BUFFER;
   }
   blosc_cbuffer_sizes(cbuffer, nbytes, &header_cbytes, &header_blocksize);
   if (header_cbytes != cbytes) {
     /* Compressed size from header does not match `cbytes` */
     *nbytes = 0;
     return BLOSC2_ERROR_INVALID_HEADER;
   }
   if (*nbytes > BLOSC_MAX_BUFFERSIZE) {
     /* Uncompressed size is larger than allowed */
+    *nbytes = 0;
     return BLOSC2_ERROR_MEMORY_ALLOC;
   }
   return 0;
 }
 
 /* Return `typesize` and `flags` from a compressed buffer. */
 void blosc_cbuffer_metainfo(const void* cbuffer, size_t* typesize, int* flags) {
-  uint8_t* _src = (uint8_t*)(cbuffer);  /* current pos for source buffer */
-  uint8_t version = _src[BLOSC2_CHUNK_VERSION];                        /* blosc format version */
-  if (version > BLOSC_VERSION_FORMAT) {
-    /* Version from future */
-    *flags = 0;
-    *typesize = 0;
+  blosc_header header;
+  int rc = blosc_read_header((uint8_t*)cbuffer, BLOSC_MIN_HEADER_LENGTH, false, &header);
+  if (rc < 0) {
+    *typesize = *flags = 0;
     return;
   }
 
   /* Read the interesting values */
-  *flags = (int)_src[BLOSC2_CHUNK_FLAGS];                 /* flags */
-  *typesize = (size_t)_src[BLOSC2_CHUNK_TYPESIZE];           /* typesize */
+  *flags = header.flags;
+  *typesize = header.typesize;
 }
 
 
 /* Return version information from a compressed buffer. */
 void blosc_cbuffer_versions(const void* cbuffer, int* version,
                             int* versionlz) {
-  uint8_t* _src = (uint8_t*)(cbuffer);  /* current pos for source buffer */
+  blosc_header header;
+  int rc = blosc_read_header((uint8_t*)cbuffer, BLOSC_MIN_HEADER_LENGTH, false, &header);
+  if (rc < 0) {
+    *version = *versionlz = 0;
+    return;
+  }
 
   /* Read the version info */
-  *version = (int)_src[BLOSC2_CHUNK_VERSION];         /* blosc format version */
-  *versionlz = (int)_src[BLOSC2_CHUNK_VERSIONLZ];       /* Lempel-Ziv compressor format version */
+  *version = header.version;
+  *versionlz = header.versionlz;
 }
 
 
 /* Return the compressor library/format used in a compressed buffer. */
 const char* blosc_cbuffer_complib(const void* cbuffer) {
-  uint8_t* _src = (uint8_t*)(cbuffer);  /* current pos for source buffer */
+  blosc_header header;
   int clibcode;
   const char* complib;
+  int rc = blosc_read_header((uint8_t*)cbuffer, BLOSC_MIN_HEADER_LENGTH, false, &header);
+  if (rc < 0) {
+    return NULL;
+  }
 
   /* Read the compressor format/library info */
-  clibcode = (_src[BLOSC2_CHUNK_FLAGS] & 0xe0) >> 5;
+  clibcode = (header.flags & 0xe0) >> 5;
   complib = clibcode_to_clibname(clibcode);
   return complib;
 }
 
 
 /* Get the internal blocksize to be used during compression.  0 means
    that an automatic blocksize is computed internally. */
@@ -3338,105 +3330,106 @@ int blosc2_set_maskout(blosc2_context *ctx, bool *maskout, int nblocks) {
 
 /* Create a chunk made of zeros */
 int blosc2_chunk_zeros(const size_t nbytes, const size_t typesize, void* dest, size_t destsize) {
-  uint8_t* dest_ = dest;
-  int32_t nbytes_ = (int32_t)nbytes;
+  blosc_header header;
 
   if (typesize == 0 || typesize > BLOSC_MAX_TYPESIZE) {
     BLOSC_TRACE_ERROR("typesize cannot be larger than %d bytes", BLOSC_MAX_TYPESIZE);
     return BLOSC2_ERROR_DATA;
   }
 
   if (nbytes % typesize != 0) {
     BLOSC_TRACE_ERROR("nbytes is not a multiple of typesize");
     return BLOSC2_ERROR_DATA;
   }
 
   if (destsize < BLOSC_EXTENDED_HEADER_LENGTH) {
     BLOSC_TRACE_ERROR("dest buffer is not long enough");
     return BLOSC2_ERROR_DATA;
   }
 
-  memset(dest, 0, BLOSC_EXTENDED_HEADER_LENGTH);
-  dest_[BLOSC2_CHUNK_VERSION] = BLOSC_VERSION_FORMAT;
-  dest_[BLOSC2_CHUNK_VERSIONLZ] = BLOSC_BLOSCLZ_VERSION_FORMAT;
-  dest_[BLOSC2_CHUNK_FLAGS] = (BLOSC_DOSHUFFLE | BLOSC_DOBITSHUFFLE);  // extended header
-  dest_[BLOSC2_CHUNK_TYPESIZE] = (uint8_t)typesize;
-  _sw32(dest_ + BLOSC2_CHUNK_NBYTES, nbytes_);
-  _sw32(dest_ + BLOSC2_CHUNK_BLOCKSIZE, nbytes_);
-  _sw32(dest_ + BLOSC2_CHUNK_CBYTES, BLOSC_EXTENDED_HEADER_LENGTH);
-  dest_[BLOSC2_CHUNK_BLOSC2_FLAGS] = BLOSC2_ZERO_RUNLEN << 4;  // mark chunk as all zeros
+  memset(&header, 0, sizeof(header));
+  header.version = BLOSC_VERSION_FORMAT;
+  header.versionlz = BLOSC_BLOSCLZ_VERSION_FORMAT;
+  header.flags = BLOSC_DOSHUFFLE | BLOSC_DOBITSHUFFLE;  // extended header
+  header.typesize = (uint8_t)typesize;
+  header.nbytes = (int32_t)nbytes;
+  header.blocksize = (int32_t)nbytes;
+  header.cbytes = BLOSC_EXTENDED_HEADER_LENGTH;
+  header.blosc2_flags = BLOSC2_ZERO_RUNLEN << 4;  // mark chunk as all zeros
+
+  memcpy((uint8_t *)dest, &header, sizeof(header));
 
   return BLOSC_EXTENDED_HEADER_LENGTH;
 }
 
 
 /* Create a chunk made of nans */
 int blosc2_chunk_nans(const size_t nbytes, const size_t typesize, void* dest, size_t destsize) {
-  uint8_t* dest_ = dest;
-  int32_t nbytes_ = (int32_t)nbytes;
+  blosc_header header;
 
   if (typesize == 0 || typesize > BLOSC_MAX_TYPESIZE) {
     BLOSC_TRACE_ERROR("typesize cannot be larger than %d bytes", BLOSC_MAX_TYPESIZE);
     return BLOSC2_ERROR_DATA;
   }
 
   if (nbytes % typesize != 0) {
     BLOSC_TRACE_ERROR("nbytes is not a multiple of typesize");
     return BLOSC2_ERROR_DATA;
   }
 
   if (destsize < BLOSC_EXTENDED_HEADER_LENGTH) {
     BLOSC_TRACE_ERROR("dest buffer is not long enough");
     return BLOSC2_ERROR_DATA;
   }
 
-  memset(dest, 0, BLOSC_EXTENDED_HEADER_LENGTH);
-  dest_[BLOSC2_CHUNK_VERSION] = BLOSC_VERSION_FORMAT;
-  dest_[BLOSC2_CHUNK_VERSIONLZ] = BLOSC_BLOSCLZ_VERSION_FORMAT;
-  dest_[BLOSC2_CHUNK_FLAGS] = (BLOSC_DOSHUFFLE | BLOSC_DOBITSHUFFLE);  // extended header
-  dest_[BLOSC2_CHUNK_TYPESIZE] = (uint8_t)typesize;
-  _sw32(dest_ + BLOSC2_CHUNK_NBYTES, nbytes_);
-  _sw32(dest_ + BLOSC2_CHUNK_BLOCKSIZE, nbytes_);
-  _sw32(dest_ + BLOSC2_CHUNK_CBYTES, BLOSC_EXTENDED_HEADER_LENGTH);
-  dest_[BLOSC2_CHUNK_BLOSC2_FLAGS] = BLOSC2_NAN_RUNLEN << 4;  // mark chunk as all NaNs
+  memset(&header, 0, sizeof(header));
+  header.version = BLOSC_VERSION_FORMAT;
+  header.versionlz = BLOSC_BLOSCLZ_VERSION_FORMAT;
+  header.flags = BLOSC_DOSHUFFLE | BLOSC_DOBITSHUFFLE;  // extended header
+  header.typesize = (uint8_t)typesize;
+  header.nbytes = (int32_t)nbytes;
+  header.blocksize = (int32_t)nbytes;
+  header.cbytes = BLOSC_EXTENDED_HEADER_LENGTH;
+  header.blosc2_flags = BLOSC2_NAN_RUNLEN << 4;  // mark chunk as all NaNs
+
+  memcpy((uint8_t *)dest, &header, sizeof(header));
 
   return BLOSC_EXTENDED_HEADER_LENGTH;
 }
 
 
 /* Create a chunk made of repeated values */
 int blosc2_chunk_repeatval(const size_t nbytes, const size_t typesize, void* dest,
                            size_t destsize, void* repeatval) {
-  uint8_t* dest_ = dest;
-  int32_t nbytes_ = (int32_t)nbytes;
+  blosc_header header;
 
   if (typesize == 0 || typesize > BLOSC_MAX_TYPESIZE) {
     BLOSC_TRACE_ERROR("typesize cannot be larger than %d bytes", BLOSC_MAX_TYPESIZE);
     return BLOSC2_ERROR_DATA;
   }
 
   if (nbytes % typesize != 0) {
     BLOSC_TRACE_ERROR("nbytes is not a multiple of typesize");
     return BLOSC2_ERROR_DATA;
   }
 
   if (destsize < BLOSC_EXTENDED_HEADER_LENGTH + typesize) {
     BLOSC_TRACE_ERROR("dest buffer is not long enough");
     return BLOSC2_ERROR_DATA;
   }
 
-  memset(dest, 0, BLOSC_EXTENDED_HEADER_LENGTH);
-  dest_[BLOSC2_CHUNK_VERSION] = BLOSC_VERSION_FORMAT;
-  dest_[BLOSC2_CHUNK_VERSIONLZ] = BLOSC_BLOSCLZ_VERSION_FORMAT;
-  dest_[BLOSC2_CHUNK_FLAGS] = (BLOSC_DOSHUFFLE | BLOSC_DOBITSHUFFLE);  // extended header
-  dest_[BLOSC2_CHUNK_TYPESIZE] = (uint8_t)typesize;
-  _sw32(dest_ + BLOSC2_CHUNK_NBYTES, nbytes_);
-  _sw32(dest_ + BLOSC2_CHUNK_BLOCKSIZE, nbytes_);
-  _sw32(dest_ + BLOSC2_CHUNK_CBYTES, BLOSC_EXTENDED_HEADER_LENGTH + (int32_t)typesize);
-  dest_[BLOSC2_CHUNK_BLOSC2_FLAGS] = BLOSC2_VALUE_RUNLEN << 4;  // mark chunk as all repeated value
+  memset(&header, 0, sizeof(header));
+  header.version = BLOSC_VERSION_FORMAT;
+  header.versionlz = BLOSC_BLOSCLZ_VERSION_FORMAT;
+  header.flags = BLOSC_DOSHUFFLE | BLOSC_DOBITSHUFFLE;  // extended header
+  header.typesize = (uint8_t)typesize;
+  header.nbytes = (int32_t)nbytes;
+  header.blocksize = (int32_t)nbytes;
+  header.cbytes = BLOSC_EXTENDED_HEADER_LENGTH + (int32_t)typesize;
+  header.blosc2_flags = BLOSC2_VALUE_RUNLEN << 4;  // mark chunk as all repeated value
 
-  // The repeated value comes after the header
-  memcpy(dest_ + BLOSC_EXTENDED_HEADER_LENGTH, repeatval, typesize);
+  memcpy((uint8_t *)dest, &header, sizeof(header));
+  memcpy((uint8_t *)dest + sizeof(header), repeatval, typesize);
 
   return BLOSC_EXTENDED_HEADER_LENGTH + (uint8_t)typesize;
 }
diff --git a/blosc/blosc2.h b/blosc/blosc2.h
index 567a5c09..ede8c15f 100644
--- a/blosc/blosc2.h
+++ b/blosc/blosc2.h
@@ -237,13 +237,14 @@ enum {
 /**
  * @brief Run lengths for special values for chunks/frames
  */
 enum {
     BLOSC2_NO_RUNLEN = 0x0,       //!< no run-length
     BLOSC2_ZERO_RUNLEN = 0x1,     //!< zero run-length
     BLOSC2_NAN_RUNLEN = 0x2,      //!< NaN run-length
     BLOSC2_VALUE_RUNLEN = 0x3,    //!< generic value run-length
+    BLOSC2_RUNLEN_MASK = 0x3      //!< run-length value mask
 };
 
 /**
  * @brief Error codes
  */
@@ -959,60 +960,65 @@ BLOSC_EXPORT int blosc2_compress_ctx(
 /**
  * @brief Context interface to Blosc decompression. This does not require a
  * call to #blosc_init and can be called from multithreaded
  * applications without the global lock being used, so allowing Blosc
  * be executed simultaneously in those scenarios.
  *
  * @param context The blosc2_context struct with the different compression params.
  * @param src The buffer of compressed data.
  * @param srcsize The length of buffer of compressed data.
  * @param dest The buffer where the decompressed data will be put.
  * @param destsize The size in bytes of the @p dest buffer.
  *
  * @warning The @p src buffer and the @p dest buffer can not overlap.
  *
  * @remark Decompression is memory safe and guaranteed not to write the @p dest
  * buffer more than what is specified in @p destsize.
  *
  * @remark In case you want to keep under control the number of bytes read from
  * source, you can call #blosc_cbuffer_sizes first to check the @p nbytes
  * (i.e. the number of bytes to be read from @p src buffer by this function)
  * in the compressed buffer.
  *
  * @remark If #blosc2_set_maskout is called prior to this function, its
  * @p block_maskout parameter will be honored for just *one single* shot;
  * i.e. the maskout in context will be automatically reset to NULL, so
  * mask won't be used next time (unless #blosc2_set_maskout is called again).
  *
  * @return The number of bytes decompressed (i.e. the maskout blocks are not
  * counted). If an error occurs, e.g. the compressed data is corrupted,
  * @p destsize is not large enough or context is not meant for decompression,
  * then 0 (zero) or a negative value will be returned instead.
  */
 BLOSC_EXPORT int blosc2_decompress_ctx(blosc2_context* context, const void* src,
                                        int32_t srcsize, void* dest, int32_t destsize);
 
 /**
  * @brief Context interface counterpart for #blosc_getitem.
  *
- * It uses similar parameters than the blosc_getitem() function plus a
- * @p context parameter and @srcsize compressed buffer length parameter.
+ * It uses many of the same parameters as blosc_getitem() function with
+ * a few additions.
+ *
+ * @param context Context pointer.
+ * @param srcsize Compressed buffer length.
+ * @param destsize Output buffer length.
  *
  * @return The number of bytes copied to @p dest or a negative value if
  * some error happens.
  */
 BLOSC_EXPORT int blosc2_getitem_ctx(blosc2_context* context, const void* src,
-                                    int32_t srcsize, int start, int nitems, void* dest);
+                                    int32_t srcsize, int start, int nitems, void* dest,
+                                    int32_t destsize);
 
 
 /*********************************************************************
   Super-chunk related structures and functions.
 *********************************************************************/
 
 #define BLOSC2_MAX_METALAYERS 16
 #define BLOSC2_METALAYER_NAME_MAXLEN 31
 
 /**
  * @brief This struct is meant for holding storage parameters for a
  * for a blosc2 container, allowing to specify, for example, how to interpret
  * the contents included in the schunk.
  */
diff --git a/examples/contexts.c b/examples/contexts.c
index 4f203738..1b9b4d68 100644
--- a/examples/contexts.c
+++ b/examples/contexts.c
@@ -30,84 +30,84 @@
 int main(void) {
   static float data[SIZE];
   static float data_out[SIZE];
   static float data_dest[SIZE];
   float data_subset[5];
   float data_subset_ref[5] = {5, 6, 7, 8, 9};
   int isize = SIZE * sizeof(float), osize = SIZE * sizeof(float);
   int dsize = SIZE * sizeof(float), csize;
   int i, ret;
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_context *cctx, *dctx;
 
   /* Initialize dataset */
   for (i = 0; i < SIZE; i++) {
     data[i] = (float)i;
   }
 
   printf("Blosc version info: %s (%s)\n",
          BLOSC_VERSION_STRING, BLOSC_VERSION_DATE);
 
   /* Create a context for compression */
   cparams.typesize = sizeof(float);
   cparams.compcode = BLOSC_BLOSCLZ;
   cparams.filters[BLOSC2_MAX_FILTERS - 1] = BLOSC_SHUFFLE;
   cparams.clevel = 5;
   cparams.nthreads = NTHREADS;
   cctx = blosc2_create_cctx(cparams);
 
   /* Do the actual compression */
   csize = blosc2_compress_ctx(cctx, data, isize, data_out, osize);
   blosc2_free_ctx(cctx);
   if (csize == 0) {
     printf("Buffer is uncompressible.  Giving up.\n");
     return 1;
   }
   else if (csize < 0) {
     printf("Compression error.  Error code: %d\n", csize);
     return csize;
   }
 
   printf("Compression: %d -> %d (%.1fx)\n", isize, csize, (1. * isize) / csize);
 
   /* Create a context for decompression */
   dparams.nthreads = NTHREADS;
   dctx = blosc2_create_dctx(dparams);
 
-  ret = blosc2_getitem_ctx(dctx, data_out, csize, 5, 5, data_subset);
+  ret = blosc2_getitem_ctx(dctx, data_out, csize, 5, 5, data_subset, sizeof(data_subset));
   if (ret < 0) {
     printf("Error in blosc2_getitem_ctx().  Giving up.\n");
     blosc2_free_ctx(dctx);
     return 1;
   }
 
   for (i = 0; i < 5; i++) {
     if (data_subset[i] != data_subset_ref[i]) {
       printf("blosc2_getitem_ctx() fetched data differs from original!\n");
       blosc2_free_ctx(dctx);
       return -1;
     }
   }
   printf("Correctly extracted 5 elements from compressed chunk!\n");
 
   /* Decompress  */
   dsize = blosc2_decompress_ctx(dctx, data_out, csize, data_dest, dsize);
   blosc2_free_ctx(dctx);
 
   if (dsize < 0) {
     printf("Decompression error.  Error code: %d\n", dsize);
     return dsize;
   }
 
   printf("Decompression succesful!\n");
 
   for (i = 0; i < SIZE; i++) {
     if (data[i] != data_dest[i]) {
       printf("Decompressed data differs from original!\n");
       return -1;
     }
   }
   printf("Succesful roundtrip!\n");
 
   return 0;
 }
diff --git a/tests/test_contexts.c b/tests/test_contexts.c
index d012299c..aa8ce524 100644
--- a/tests/test_contexts.c
+++ b/tests/test_contexts.c
@@ -15,79 +15,79 @@
 int main(void) {
   static int32_t data[SIZE];
   static int32_t data_out[SIZE];
   static int32_t data_dest[SIZE];
   int32_t data_subset[5];
   int32_t data_subset_ref[5] = {5, 6, 7, 8, 9};
   int32_t isize = SIZE * sizeof(int32_t), osize = SIZE * sizeof(int32_t);
   int dsize = SIZE * sizeof(int32_t), csize;
   int i, ret;
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_context *cctx, *dctx;
 
   /* Initialize dataset */
   for (i = 0; i < SIZE; i++) {
     data[i] = i;
   }
 
   printf("Blosc version info: %s (%s)\n",
          BLOSC_VERSION_STRING, BLOSC_VERSION_DATE);
 
   install_blosc_callback_test(); /* optionally install callback test */
 
   /* Create a context for compression */
   cparams.typesize = sizeof(int32_t);
   cparams.compcode = BLOSC_BLOSCLZ;
   cparams.filters[BLOSC2_MAX_FILTERS - 1] = BLOSC_SHUFFLE;
   cparams.clevel = 5;
   cparams.nthreads = NTHREADS;
   cctx = blosc2_create_cctx(cparams);
 
   /* Compress with clevel=5 and shuffle active  */
   csize = blosc2_compress_ctx(cctx, data, isize, data_out, osize);
   blosc2_free_ctx(cctx);
   if (csize == 0) {
     printf("Buffer is uncompressible.  Giving up.\n");
     return EXIT_FAILURE;
   }
   if (csize < 0) {
     printf("Compression error.  Error code: %d\n", csize);
     return EXIT_FAILURE;
   }
 
   /* Create a context for decompression */
   dparams.nthreads = NTHREADS;
   dctx = blosc2_create_dctx(dparams);
 
-  ret = blosc2_getitem_ctx(dctx, data_out, csize, 5, 5, data_subset);
+  ret = blosc2_getitem_ctx(dctx, data_out, csize, 5, 5, data_subset, sizeof(data_subset));
   if (ret < 0) {
     printf("Error in blosc2_getitem_ctx().  Giving up.\n");
     blosc2_free_ctx(dctx);
     return EXIT_FAILURE;
   }
 
   for (i = 0; i < 5; i++) {
     if (data_subset[i] != data_subset_ref[i]) {
       printf("blosc2_getitem_ctx() fetched data differs from original!\n");
       blosc2_free_ctx(dctx);
       return EXIT_FAILURE;
     }
   }
 
   /* Decompress  */
   dsize = blosc2_decompress_ctx(dctx, data_out, csize, data_dest, (size_t)dsize);
   blosc2_free_ctx(dctx);
   if (dsize < 0) {
     printf("Decompression error.  Error code: %d\n", dsize);
     return EXIT_FAILURE;
   }
 
   for (i = 0; i < SIZE; i++) {
     if (data[i] != data_dest[i]) {
       printf("Decompressed data differs from original!\n");
       return EXIT_FAILURE;
     }
   }
 
   return EXIT_SUCCESS;
 }
diff --git a/tests/test_eframe_lazychunk.c b/tests/test_eframe_lazychunk.c
index 0ab0a66e..741bbf99 100644
--- a/tests/test_eframe_lazychunk.c
+++ b/tests/test_eframe_lazychunk.c
@@ -27,81 +27,81 @@ char* directory;
 static char* test_lazy_chunk(void) {
   static int32_t data[CHUNKSIZE];
   static int32_t data_dest[CHUNKSIZE];
   size_t isize = CHUNKSIZE * sizeof(int32_t);
   int dsize;
   int cbytes;
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_schunk* schunk;
 
   /* Initialize the Blosc compressor */
   blosc_init();
 
   /* Create a super-chunk container, backed by a frame */
   cparams.typesize = sizeof(int32_t);
   cparams.clevel = clevel;
   cparams.nthreads = nthreads;
   cparams.blocksize = BLOCKSIZE * cparams.typesize;
   dparams.nthreads = nthreads;
   blosc2_storage storage = {.sequential=false, .urlpath=directory, .cparams=&cparams, .dparams=&dparams};
   schunk = blosc2_schunk_new(storage);
 
   // Feed it with data
   for (int nchunk = 0; nchunk < nchunks; nchunk++) {
     for (int i = 0; i < NBLOCKS; i++) {
       for (int j = 0; j < BLOCKSIZE; j++) {
         data[j + i * BLOCKSIZE] = j + i * BLOCKSIZE + nchunk * CHUNKSIZE;
       }
     }
     int nchunks_ = blosc2_schunk_append_buffer(schunk, data, isize);
     mu_assert("ERROR: bad append in frame", nchunks_ > 0);
   }
 
   /* Gather some info */
   if (nchunks > 0 && clevel > 0) {
     mu_assert("ERROR: bad compression ratio in frame", schunk->nbytes > 10 * schunk->cbytes);
   }
 
   // Check that blosc2_getitem_ctx works correctly with lazy chunks
   bool needs_free;
   uint8_t* lazy_chunk;
   for (int nchunk = 0; nchunk < nchunks; nchunk++) {
     cbytes = blosc2_schunk_get_lazychunk(schunk, nchunk, &lazy_chunk, &needs_free);
     for (int i = 0; i < NBLOCKS - 1; i++) {
       memset(data_dest, 0, isize);
-      dsize = blosc2_getitem_ctx(schunk->dctx, lazy_chunk, cbytes, i * BLOCKSIZE, BLOCKSIZE * 2, data_dest);
+      dsize = blosc2_getitem_ctx(schunk->dctx, lazy_chunk, cbytes, i * BLOCKSIZE, BLOCKSIZE * 2, data_dest, isize);
       mu_assert("ERROR: blosc2_getitem_ctx does not work correctly.", dsize >= 0);
       for (int j = 0; j < BLOCKSIZE * 2; j++) {
         mu_assert("ERROR: bad roundtrip (blosc2_getitem_ctx)",
                   data_dest[j] == j + i * BLOCKSIZE + nchunk * CHUNKSIZE);
       }
     }
     if (needs_free) {
       free(lazy_chunk);
     }
   }
 
   // Check that lazy chunks can be decompressed correctly
   for (int nchunk = 0; nchunk < nchunks; nchunk++) {
     memset(data_dest, 0, isize);
     cbytes = blosc2_schunk_get_lazychunk(schunk, nchunk, &lazy_chunk, &needs_free);
     dsize = blosc2_decompress_ctx(schunk->dctx, lazy_chunk, cbytes, data_dest, isize);
     mu_assert("ERROR: chunk cannot be decompressed correctly.", dsize >= 0);
     for (int i = 0; i < NBLOCKS; i++) {
       for (int j = 0; j < BLOCKSIZE; j++) {
         mu_assert("ERROR: bad roundtrip (blosc2_decompress_ctx)",
                   data_dest[j + i * BLOCKSIZE] == j + i * BLOCKSIZE + nchunk * CHUNKSIZE);
       }
     }
   }
 
   /* Remove directory */
   blosc2_remove_dir(storage.urlpath);
   /* Free resources */
   blosc2_schunk_free(schunk);
 
   /* Destroy the Blosc environment */
   blosc_destroy();
 
   return EXIT_SUCCESS;
 }
diff --git a/tests/test_lazychunk.c b/tests/test_lazychunk.c
index b4246a87..a11e167c 100644
--- a/tests/test_lazychunk.c
+++ b/tests/test_lazychunk.c
@@ -26,79 +26,79 @@ uint8_t filter;
 static char* test_lazy_chunk(void) {
   static int32_t data[CHUNKSIZE];
   static int32_t data_dest[CHUNKSIZE];
   int32_t isize = CHUNKSIZE * sizeof(int32_t);
   int dsize;
   int cbytes;
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   cparams.filters[5] = filter;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_schunk* schunk;
 
   /* Initialize the Blosc compressor */
   blosc_init();
 
   /* Create a super-chunk container, backed by a frame */
   cparams.typesize = sizeof(int32_t);
   cparams.clevel = clevel;
   cparams.nthreads = nthreads;
   cparams.blocksize = BLOCKSIZE * cparams.typesize;
   dparams.nthreads = nthreads;
   blosc2_storage storage = {.sequential=true, .urlpath="test_lazy_chunk.b2frame", .cparams=&cparams, .dparams=&dparams};
   schunk = blosc2_schunk_new(storage);
 
   // Feed it with data
   for (int nchunk = 0; nchunk < nchunks; nchunk++) {
     for (int i = 0; i < NBLOCKS; i++) {
       for (int j = 0; j < BLOCKSIZE; j++) {
         data[j + i * BLOCKSIZE] = j + i * BLOCKSIZE + nchunk * CHUNKSIZE;
       }
     }
     int nchunks_ = blosc2_schunk_append_buffer(schunk, data, isize);
     mu_assert("ERROR: bad append in frame", nchunks_ > 0);
   }
 
   /* Gather some info */
   if (nchunks > 0 && clevel > 0) {
     mu_assert("ERROR: bad compression ratio in frame", schunk->nbytes > 10 * schunk->cbytes);
   }
 
   // Check that blosc2_getitem_ctx works correctly with lazy chunks
   bool needs_free;
   uint8_t* lazy_chunk;
   for (int nchunk = 0; nchunk < nchunks; nchunk++) {
     cbytes = blosc2_schunk_get_lazychunk(schunk, nchunk, &lazy_chunk, &needs_free);
     for (int i = 0; i < NBLOCKS - 1; i++) {
       memset(data_dest, 0, isize);
-      dsize = blosc2_getitem_ctx(schunk->dctx, lazy_chunk, cbytes, i * BLOCKSIZE, BLOCKSIZE * 2, data_dest);
+      dsize = blosc2_getitem_ctx(schunk->dctx, lazy_chunk, cbytes, i * BLOCKSIZE, BLOCKSIZE * 2, data_dest, isize);
       mu_assert("ERROR: blosc2_getitem_ctx does not work correctly.", dsize >= 0);
       for (int j = 0; j < BLOCKSIZE * 2; j++) {
         mu_assert("ERROR: bad roundtrip (blosc2_getitem_ctx)",
                   data_dest[j] == j + i * BLOCKSIZE + nchunk * CHUNKSIZE);
       }
     }
     if (needs_free) {
       free(lazy_chunk);
     }
   }
 
   // Check that lazy chunks can be decompressed correctly
   for (int nchunk = 0; nchunk < nchunks; nchunk++) {
     memset(data_dest, 0, isize);
     cbytes = blosc2_schunk_get_lazychunk(schunk, nchunk, &lazy_chunk, &needs_free);
     dsize = blosc2_decompress_ctx(schunk->dctx, lazy_chunk, cbytes, data_dest, isize);
     mu_assert("ERROR: chunk cannot be decompressed correctly.", dsize >= 0);
     for (int i = 0; i < NBLOCKS; i++) {
       for (int j = 0; j < BLOCKSIZE; j++) {
         mu_assert("ERROR: bad roundtrip (blosc2_decompress_ctx)",
                   data_dest[j + i * BLOCKSIZE] == j + i * BLOCKSIZE + nchunk * CHUNKSIZE);
       }
     }
   }
 
   /* Free resources */
   blosc2_schunk_free(schunk);
   /* Destroy the Blosc environment */
   blosc_destroy();
 
   return EXIT_SUCCESS;
 }
