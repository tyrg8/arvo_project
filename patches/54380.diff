commit 76baf858da4cdc14bb4f0d8c994f0aa859232cae
Author: Reini Urban <rurban@cpan.org>
Date:   Mon Oct 2 14:47:59 2023 +0200

    refactor injson dynapi for inline arrays
    
    maybe the reason for the GH #851 readDWG crash.
    simplifies a lot.

diff --git a/doc/dynapi.texi b/doc/dynapi.texi
index 481f264f..09e0fa69 100644
--- a/doc/dynapi.texi
+++ b/doc/dynapi.texi
@@ -415,7 +415,7 @@ BS,	DXF 70
 BS,	DXF 70
 @item MENU
 TV,	DXF 1
-@item MENUEXT[46]
+@item MENUEXT
 RC
 @item MIRRTEXT
 B,	DXF 70
@@ -707,7 +707,7 @@ RS
 RL
 @item flag_3d
 RS
-@item layer_colors[128]
+@item layer_colors
 RS
 @item numentities
 RS
@@ -923,7 +923,7 @@ struct _dwg_entity_3DSOLID*
 BL
 @item materials
 Dwg_3DSOLID_material*
-@item revision_guid[39]
+@item revision_guid
 RC,	DXF 2
 @item revision_major
 BL
@@ -931,7 +931,7 @@ BL
 BS
 @item revision_minor2
 BS
-@item revision_bytes[9]
+@item revision_bytes
 RC
 @item end_marker
 BL
@@ -1939,7 +1939,7 @@ struct _dwg_entity_3DSOLID*
 BL
 @item materials
 Dwg_3DSOLID_material*
-@item revision_guid[39]
+@item revision_guid
 RC,	DXF 2
 @item revision_major
 BL
@@ -1947,7 +1947,7 @@ BL
 BS
 @item revision_minor2
 BS
-@item revision_bytes[9]
+@item revision_bytes
 RC
 @item end_marker
 BL
@@ -2675,7 +2675,7 @@ struct _dwg_entity_3DSOLID*
 BL
 @item materials
 Dwg_3DSOLID_material*
-@item revision_guid[39]
+@item revision_guid
 RC,	DXF 2
 @item revision_major
 BL
@@ -2683,7 +2683,7 @@ BL
 BS
 @item revision_minor2
 BS
-@item revision_bytes[9]
+@item revision_bytes
 RC
 @item end_marker
 BL
@@ -3200,7 +3200,7 @@ struct _dwg_entity_3DSOLID*
 BL
 @item materials
 Dwg_3DSOLID_material*
-@item revision_guid[39]
+@item revision_guid
 RC,	DXF 2
 @item revision_major
 BL
@@ -3208,7 +3208,7 @@ BL
 BS
 @item revision_minor2
 BS
-@item revision_bytes[9]
+@item revision_bytes
 RC
 @item end_marker
 BL
@@ -3351,7 +3351,7 @@ struct _dwg_entity_3DSOLID*
 BL
 @item materials
 Dwg_3DSOLID_material*
-@item revision_guid[39]
+@item revision_guid
 RC,	DXF 2
 @item revision_major
 BL
@@ -3359,7 +3359,7 @@ BL
 BS
 @item revision_minor2
 BS
-@item revision_bytes[9]
+@item revision_bytes
 RC
 @item end_marker
 BL
@@ -3832,7 +3832,7 @@ struct _dwg_entity_3DSOLID*
 BL
 @item materials
 Dwg_3DSOLID_material*
-@item revision_guid[39]
+@item revision_guid
 RC,	DXF 2
 @item revision_major
 BL
@@ -3840,7 +3840,7 @@ BL
 BS
 @item revision_minor2
 BS
-@item revision_bytes[9]
+@item revision_bytes
 RC
 @item end_marker
 BL
@@ -4157,7 +4157,7 @@ struct _dwg_entity_3DSOLID*
 BL
 @item materials
 Dwg_3DSOLID_material*
-@item revision_guid[39]
+@item revision_guid
 RC,	DXF 2
 @item revision_major
 BL
@@ -4165,7 +4165,7 @@ BL
 BS
 @item revision_minor2
 BS
-@item revision_bytes[9]
+@item revision_bytes
 RC
 @item end_marker
 BL
@@ -4691,17 +4691,17 @@ RC,	DXF 70
 struct _dwg_object_entity*
 @item flag
 RC,	DXF 70
-@item vertind[4]
-BS
+@item vertind
+BS,	DXF 71
 
 @end vtable
 @end indentedblock
 
 @strong{VIEWPORT} @anchor{VIEWPORT}
 @cindex entity, VIEWPORT
 @vindex VIEWPORT
 
 @indentedblock
 @vtable @code
 
 @item parent
@@ -5064,7 +5064,7 @@ struct _dwg_entity_3DSOLID*
 BL
 @item materials
 Dwg_3DSOLID_material*
-@item revision_guid[39]
+@item revision_guid
 RC,	DXF 2
 @item revision_major
 BL
@@ -5072,7 +5072,7 @@ BL
 BS
 @item revision_minor2
 BS
-@item revision_bytes[9]
+@item revision_bytes
 RC
 @item end_marker
 BL
@@ -5721,7 +5721,7 @@ struct _dwg_VALUEPARAM*
 BL,	DXF 90
 @item b1
 B,	DXF 70
-@item workplane[3]
+@item workplane
 3BD
 @item h1
 H,	DXF 360
@@ -5970,7 +5970,7 @@ struct _dwg_entity_3DSOLID*
 BL
 @item materials
 Dwg_3DSOLID_material*
-@item revision_guid[39]
+@item revision_guid
 RC
 @item revision_major
 BL
@@ -5978,7 +5978,7 @@ BL
 BS
 @item revision_minor2
 BS
-@item revision_bytes[9]
+@item revision_bytes
 RC
 @item end_marker
 BL
@@ -10344,8 +10344,8 @@ RC,	DXF 72
 RC,	DXF 73
 @item dashes
 Dwg_LTYPE_dash*
-@item dashes_r11[12]
-RD
+@item dashes_r11
+RD,	DXF 49
 @item has_strings_area
 B
 @item strings_area
@@ -13064,7 +13064,7 @@ BL
 
 @item parent
 struct _dwg_object_ASSOCARRAYMODIFYACTIONBODY*
-@item itemloc[3]
+@item itemloc
 BL
 
 @end vtable
@@ -13112,7 +13112,7 @@ H
 struct _dwg_abstractobject_ASSOCARRAYPARAMETERS*
 @item class_version
 BL,	DXF 90
-@item itemloc[3]
+@item itemloc
 BL
 @item flags
 BL
@@ -13600,7 +13600,7 @@ Dwg_AcDs_Search_IdIdx*
 
 @item signature
 RS
-@item name[7]
+@item name
 RC
 @item type
 RCd
@@ -13620,7 +13620,7 @@ RL
 RL
 @item objdata_algn_offset
 RL
-@item padding[9]
+@item padding
 RC
 
 @end vtable
@@ -14104,7 +14104,7 @@ BLd,	DXF 94
 BLd,	DXF 91
 @item e3
 BLd,	DXF 91
-@item out_edge[5]
+@item out_edge
 BLd
 
 @end vtable
@@ -14126,7 +14126,7 @@ BL,	DXF 93
 BLd,	DXF 95
 @item evalexpr
 H,	DXF 360
-@item node[4]
+@item node
 BLd
 @item active_cycles
 B
@@ -15193,16 +15193,16 @@ RC
 @item unknown_3
 RC
 
 @end vtable
 @end indentedblock
 
 @strong{Dwg_R2004_Header} @anchor{Dwg_R2004_Header}
 @vindex Dwg_R2004_Header
 
 @indentedblock
 @vtable @code
 
-@item file_ID_string[12]
+@item file_ID_string
 RC
 @item header_address
 RLx
@@ -15246,7 +15246,7 @@ RLd
 RL
 @item crc32
 RLx
-@item padding[12]
+@item padding
 RC
 @item section_type
 RL
diff --git a/src/dwg.spec b/src/dwg.spec
index e9ecb31d..8ca138b1 100644
--- a/src/dwg.spec
+++ b/src/dwg.spec
@@ -1206,50 +1206,53 @@ DWG_ENTITY_END
 /* (14/20) */
 DWG_ENTITY (VERTEX_PFACE_FACE)
 
   SUBCLASS (AcDbFaceRecord)
 #ifdef IS_DXF
   {
     BITCODE_3RD pt = { 0.0, 0.0, 0.0 };
     UNTIL (R_9) {
       VALUE_2RD (pt, 10)
     }
     LATER_VERSIONS {
       VALUE_3BD (pt, 10)
     }
     VALUE_RC ((BITCODE_RC)128, 70);
     FIELD_BS (vertind[0], 71);
     FIELD_BS (vertind[1], 72);
     FIELD_BS (vertind[2], 73);
     FIELD_BS0 (vertind[3], 74);
   }
+#elif defined IS_JSON
+  FIELD_RC (flag, 0);
+  FIELD_VECTOR_INL (vertind, BS, 4, 71);
 #else
   //FIELD_VALUE (pt) = { 0.0, 0.0, 0.0 };
   PRE (R_13b1)
   {
     if (R11OPTS (OPTS_R11_VERTEX_HAS_FLAG)) {
       FIELD_RC (flag, 0);
       LOG_FLAG_VERTEX
     }
     if (R11OPTS (OPTS_R11_VERTEX_HAS_INDEX1)) {
       FIELD_RS (vertind[0], 71);
     }
     if (R11OPTS (OPTS_R11_VERTEX_HAS_INDEX2)) {
       FIELD_RS (vertind[1], 72);
     }
     if (R11OPTS (OPTS_R11_VERTEX_HAS_INDEX3)) {
       FIELD_RS (vertind[2], 73);
     }
     if (R11OPTS (OPTS_R11_VERTEX_HAS_INDEX4)) {
       FIELD_RS (vertind[3], 74);
     }
   }
   LATER_VERSIONS {
     FIELD_VALUE (flag) = 128;
     FIELD_BS (vertind[0], 71);
     FIELD_BS (vertind[1], 72);
     FIELD_BS (vertind[2], 73);
     FIELD_BS (vertind[3], 74);
   }
 #endif
   //TODO R13 has color_r11 and ltype_r11 for all vertices, not in DXF
   COMMON_ENTITY_HANDLE_DATA;
diff --git a/src/dynapi.c b/src/dynapi.c
index 3627b09a..2f66a4c3 100644
--- a/src/dynapi.c
+++ b/src/dynapi.c
@@ -38,806 +38,806 @@ Dwg_Object *dwg_obj_generic_to_object (const void *restrict obj,
 /* from typedef struct _dwg_header_variables: (sorted by name) */
 static const Dwg_DYNAPI_field _dwg_header_variables_fields[] = {
   { "ACADMAINTVER",	"RC", sizeof (BITCODE_RC),  OFF (struct _dwg_header_variables, ACADMAINTVER),
     0,0,0, 90 },
   { "ANGBASE",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, ANGBASE),
     0,0,0, 50 },
   { "ANGDIR",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, ANGDIR),
     0,0,0, 70 },
   { "APPID_CONTROL_OBJECT",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, APPID_CONTROL_OBJECT),
     1,0,0, 0 },
   { "ATTDIA",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, ATTDIA),
     0,0,0, 70 },
   { "ATTMODE",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, ATTMODE),
     0,0,0, 70 },
   { "ATTREQ",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, ATTREQ),
     0,0,0, 70 },
   { "AUNITS",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, AUNITS),
     0,0,0, 70 },
   { "AUPREC",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, AUPREC),
     0,0,0, 70 },
   { "AXISMODE",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, AXISMODE),
     0,0,0, 70 },
   { "AXISUNIT",	"2RD", sizeof (BITCODE_2RD),  OFF (struct _dwg_header_variables, AXISUNIT),
     1,0,0, 20 },
   { "BACKZ",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, BACKZ),
     0,0,0, 0 },
   { "BLIPMODE",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, BLIPMODE),
     0,0,0, 70 },
   { "BLOCK_CONTROL_OBJECT",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, BLOCK_CONTROL_OBJECT),
     1,0,0, 0 },
   { "BLOCK_RECORD_MSPACE",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, BLOCK_RECORD_MSPACE),
     1,0,0, 0 },
   { "BLOCK_RECORD_PSPACE",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, BLOCK_RECORD_PSPACE),
     1,0,0, 0 },
   { "CAMERADISPLAY",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, CAMERADISPLAY),
     0,0,0, 290 },
   { "CAMERAHEIGHT",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, CAMERAHEIGHT),
     0,0,0, 40 },
   { "CECOLOR",	"CMC", sizeof (BITCODE_CMC),  OFF (struct _dwg_header_variables, CECOLOR),
     0,0,0, 62 },
   { "CELTSCALE",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, CELTSCALE),
     0,0,0, 40 },
   { "CELTYPE",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, CELTYPE),
     1,0,0, 6 },
   { "CELWEIGHT",	"BSd", sizeof (BITCODE_BSd),  OFF (struct _dwg_header_variables, CELWEIGHT),
     0,0,0, 370 },
   { "CEPSNTYPE",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, CEPSNTYPE),
     0,0,0, 380 },
   { "CHAMFERA",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, CHAMFERA),
     0,0,0, 40 },
   { "CHAMFERB",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, CHAMFERB),
     0,0,0, 40 },
   { "CHAMFERC",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, CHAMFERC),
     0,0,0, 40 },
   { "CHAMFERD",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, CHAMFERD),
     0,0,0, 40 },
   { "CLAYER",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, CLAYER),
     1,0,0, 8 },
   { "CMATERIAL",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, CMATERIAL),
     1,0,0, 347 },
   { "CMLJUST",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, CMLJUST),
     0,0,0, 70 },
   { "CMLSCALE",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, CMLSCALE),
     0,0,0, 40 },
   { "CMLSTYLE",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, CMLSTYLE),
     1,0,0, 2 },
   { "COORDS",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, COORDS),
     0,0,0, 70 },
   { "CPSNID",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, CPSNID),
     1,0,0, 390 },
   { "CSHADOW",	"RC", sizeof (BITCODE_RC),  OFF (struct _dwg_header_variables, CSHADOW),
     0,0,0, 280 },
   { "DELOBJ",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, DELOBJ),
     0,0,0, 70 },
   { "DGNFRAME",	"RC", sizeof (BITCODE_RC),  OFF (struct _dwg_header_variables, DGNFRAME),
     0,0,0, 280 },
   { "DICTIONARY_ACAD_GROUP",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, DICTIONARY_ACAD_GROUP),
     1,0,0, 0 },
   { "DICTIONARY_ACAD_MLINESTYLE",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, DICTIONARY_ACAD_MLINESTYLE),
     1,0,0, 0 },
   { "DICTIONARY_COLOR",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, DICTIONARY_COLOR),
     1,0,0, 0 },
   { "DICTIONARY_LAYOUT",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, DICTIONARY_LAYOUT),
     1,0,0, 0 },
   { "DICTIONARY_LIGHTLIST",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, DICTIONARY_LIGHTLIST),
     1,0,0, 0 },
   { "DICTIONARY_MATERIAL",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, DICTIONARY_MATERIAL),
     1,0,0, 0 },
   { "DICTIONARY_NAMED_OBJECT",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, DICTIONARY_NAMED_OBJECT),
     1,0,0, 0 },
   { "DICTIONARY_PLOTSETTINGS",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, DICTIONARY_PLOTSETTINGS),
     1,0,0, 0 },
   { "DICTIONARY_PLOTSTYLENAME",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, DICTIONARY_PLOTSTYLENAME),
     1,0,0, 0 },
   { "DICTIONARY_VISUALSTYLE",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, DICTIONARY_VISUALSTYLE),
     1,0,0, 0 },
   { "DIMADEC",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, DIMADEC),
     0,0,0, 70 },
   { "DIMALT",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, DIMALT),
     0,0,0, 70 },
   { "DIMALTD",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, DIMALTD),
     0,0,0, 70 },
   { "DIMALTF",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, DIMALTF),
     0,0,0, 40 },
   { "DIMALTMZF",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, DIMALTMZF),
     0,0,0, 0 },
   { "DIMALTMZS",	"T", sizeof (BITCODE_T),  OFF (struct _dwg_header_variables, DIMALTMZS),
     1,1,1, 1 },
   { "DIMALTRND",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, DIMALTRND),
     0,0,0, 40 },
   { "DIMALTTD",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, DIMALTTD),
     0,0,0, 70 },
   { "DIMALTTZ",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, DIMALTTZ),
     0,0,0, 70 },
   { "DIMALTU",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, DIMALTU),
     0,0,0, 70 },
   { "DIMALTZ",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, DIMALTZ),
     0,0,0, 70 },
   { "DIMAPOST",	"TV", sizeof (BITCODE_TV),  OFF (struct _dwg_header_variables, DIMAPOST),
     1,1,1, 1 },
   { "DIMAPOST_T",	"T", sizeof (BITCODE_T),  OFF (struct _dwg_header_variables, DIMAPOST_T),
     1,1,1, 0 },
   { "DIMARCSYM",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, DIMARCSYM),
     0,0,0, 70 },
   { "DIMARROW",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, DIMARROW),
     0,0,0, 0 },
   { "DIMASO",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, DIMASO),
     0,0,0, 70 },
   { "DIMASSOC",	"RC", sizeof (BITCODE_RC),  OFF (struct _dwg_header_variables, DIMASSOC),
     0,0,0, 280 },
   { "DIMASZ",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, DIMASZ),
     0,0,0, 40 },
   { "DIMATFIT",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, DIMATFIT),
     0,0,0, 70 },
   { "DIMAUNIT",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, DIMAUNIT),
     0,0,0, 70 },
   { "DIMAZIN",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, DIMAZIN),
     0,0,0, 70 },
   { "DIMBLK",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, DIMBLK),
     1,0,0, 1 },
   { "DIMBLK1",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, DIMBLK1),
     1,0,0, 1 },
   { "DIMBLK1_T",	"T", sizeof (BITCODE_T),  OFF (struct _dwg_header_variables, DIMBLK1_T),
     1,1,1, 0 },
   { "DIMBLK2",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, DIMBLK2),
     1,0,0, 1 },
   { "DIMBLK2_T",	"T", sizeof (BITCODE_T),  OFF (struct _dwg_header_variables, DIMBLK2_T),
     1,1,1, 0 },
   { "DIMBLK_T",	"T", sizeof (BITCODE_T),  OFF (struct _dwg_header_variables, DIMBLK_T),
     1,1,1, 0 },
   { "DIMCEN",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, DIMCEN),
     0,0,0, 40 },
   { "DIMCLRD",	"CMC", sizeof (BITCODE_CMC),  OFF (struct _dwg_header_variables, DIMCLRD),
     0,0,0, 70 },
   { "DIMCLRD_C",	"RS", sizeof (BITCODE_RS),  OFF (struct _dwg_header_variables, DIMCLRD_C),
     0,0,0, 0 },
   { "DIMCLRE",	"CMC", sizeof (BITCODE_CMC),  OFF (struct _dwg_header_variables, DIMCLRE),
     0,0,0, 70 },
   { "DIMCLRE_C",	"RS", sizeof (BITCODE_RS),  OFF (struct _dwg_header_variables, DIMCLRE_C),
     0,0,0, 0 },
   { "DIMCLRT",	"CMC", sizeof (BITCODE_CMC),  OFF (struct _dwg_header_variables, DIMCLRT),
     0,0,0, 70 },
   { "DIMCLRT_C",	"RS", sizeof (BITCODE_RS),  OFF (struct _dwg_header_variables, DIMCLRT_C),
     0,0,0, 0 },
   { "DIMDEC",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, DIMDEC),
     0,0,0, 70 },
   { "DIMDLE",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, DIMDLE),
     0,0,0, 40 },
   { "DIMDLI",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, DIMDLI),
     0,0,0, 40 },
   { "DIMDSEP",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, DIMDSEP),
     0,0,0, 70 },
   { "DIMEXE",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, DIMEXE),
     0,0,0, 40 },
   { "DIMEXO",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, DIMEXO),
     0,0,0, 40 },
   { "DIMFIT",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, DIMFIT),
     0,0,0, 70 },
   { "DIMFRAC",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, DIMFRAC),
     0,0,0, 70 },
   { "DIMFXL",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, DIMFXL),
     0,0,0, 40 },
   { "DIMFXLON",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, DIMFXLON),
     0,0,0, 70 },
   { "DIMGAP",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, DIMGAP),
     0,0,0, 40 },
   { "DIMJOGANG",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, DIMJOGANG),
     0,0,0, 40 },
   { "DIMJUST",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, DIMJUST),
     0,0,0, 70 },
   { "DIMLDRBLK",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, DIMLDRBLK),
     1,0,0, 1 },
   { "DIMLFAC",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, DIMLFAC),
     0,0,0, 40 },
   { "DIMLIM",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, DIMLIM),
     0,0,0, 70 },
   { "DIMLTEX1",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, DIMLTEX1),
     1,0,0, 6 },
   { "DIMLTEX2",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, DIMLTEX2),
     1,0,0, 6 },
   { "DIMLTYPE",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, DIMLTYPE),
     1,0,0, 6 },
   { "DIMLUNIT",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, DIMLUNIT),
     0,0,0, 70 },
   { "DIMLWD",	"BSd", sizeof (BITCODE_BSd),  OFF (struct _dwg_header_variables, DIMLWD),
     0,0,0, 70 },
   { "DIMLWE",	"BSd", sizeof (BITCODE_BSd),  OFF (struct _dwg_header_variables, DIMLWE),
     0,0,0, 70 },
   { "DIMMZF",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, DIMMZF),
     0,0,0, 0 },
   { "DIMMZS",	"T", sizeof (BITCODE_T),  OFF (struct _dwg_header_variables, DIMMZS),
     1,1,1, 1 },
   { "DIMPOST",	"TV", sizeof (BITCODE_TV),  OFF (struct _dwg_header_variables, DIMPOST),
     1,1,1, 1 },
   { "DIMPOST_T",	"T", sizeof (BITCODE_T),  OFF (struct _dwg_header_variables, DIMPOST_T),
     1,1,1, 0 },
   { "DIMRND",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, DIMRND),
     0,0,0, 40 },
   { "DIMSAH",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, DIMSAH),
     0,0,0, 70 },
   { "DIMSAV",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, DIMSAV),
     0,0,0, 0 },
   { "DIMSCALE",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, DIMSCALE),
     0,0,0, 40 },
   { "DIMSD1",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, DIMSD1),
     0,0,0, 70 },
   { "DIMSD2",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, DIMSD2),
     0,0,0, 70 },
   { "DIMSE1",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, DIMSE1),
     0,0,0, 70 },
   { "DIMSE2",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, DIMSE2),
     0,0,0, 70 },
   { "DIMSHO",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, DIMSHO),
     0,0,0, 70 },
   { "DIMSOXD",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, DIMSOXD),
     0,0,0, 70 },
   { "DIMSTYLE",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, DIMSTYLE),
     1,0,0, 2 },
   { "DIMSTYLE_CONTROL_OBJECT",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, DIMSTYLE_CONTROL_OBJECT),
     1,0,0, 0 },
   { "DIMTAD",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, DIMTAD),
     0,0,0, 70 },
   { "DIMTDEC",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, DIMTDEC),
     0,0,0, 70 },
   { "DIMTFAC",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, DIMTFAC),
     0,0,0, 40 },
   { "DIMTFILL",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, DIMTFILL),
     0,0,0, 70 },
   { "DIMTFILLCLR",	"CMC", sizeof (BITCODE_CMC),  OFF (struct _dwg_header_variables, DIMTFILLCLR),
     0,0,0, 70 },
   { "DIMTIH",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, DIMTIH),
     0,0,0, 70 },
   { "DIMTIX",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, DIMTIX),
     0,0,0, 70 },
   { "DIMTM",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, DIMTM),
     0,0,0, 40 },
   { "DIMTMOVE",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, DIMTMOVE),
     0,0,0, 70 },
   { "DIMTOFL",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, DIMTOFL),
     0,0,0, 70 },
   { "DIMTOH",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, DIMTOH),
     0,0,0, 70 },
   { "DIMTOL",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, DIMTOL),
     0,0,0, 70 },
   { "DIMTOLJ",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, DIMTOLJ),
     0,0,0, 70 },
   { "DIMTP",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, DIMTP),
     0,0,0, 40 },
   { "DIMTSZ",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, DIMTSZ),
     0,0,0, 40 },
   { "DIMTVP",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, DIMTVP),
     0,0,0, 40 },
   { "DIMTXSTY",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, DIMTXSTY),
     1,0,0, 7 },
   { "DIMTXT",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, DIMTXT),
     0,0,0, 40 },
   { "DIMTXTDIRECTION",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, DIMTXTDIRECTION),
     0,0,0, 70 },
   { "DIMTZIN",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, DIMTZIN),
     0,0,0, 70 },
   { "DIMUNIT",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, DIMUNIT),
     0,0,0, 70 },
   { "DIMUPT",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, DIMUPT),
     0,0,0, 70 },
   { "DIMZIN",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, DIMZIN),
     0,0,0, 70 },
   { "DISPSILH",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, DISPSILH),
     0,0,0, 70 },
   { "DRAGMODE",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, DRAGMODE),
     0,0,0, 70 },
   { "DRAGVS",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, DRAGVS),
     1,0,0, 349 },
   { "DWFFRAME",	"RC", sizeof (BITCODE_RC),  OFF (struct _dwg_header_variables, DWFFRAME),
     0,0,0, 280 },
   { "DWGCODEPAGE",	"TV", sizeof (BITCODE_TV),  OFF (struct _dwg_header_variables, DWGCODEPAGE),
     1,1,1, 3 },
   { "ELEVATION",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, ELEVATION),
     0,0,0, 40 },
   { "ENDCAPS",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, ENDCAPS),
     0,0,0, 280 },
   { "EXTMAX",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_header_variables, EXTMAX),
     1,0,0, 30 },
   { "EXTMIN",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_header_variables, EXTMIN),
     1,0,0, 30 },
   { "EXTNAMES",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, EXTNAMES),
     0,0,0, 290 },
   { "FACETRES",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, FACETRES),
     0,0,0, 0 },
   { "FASTZOOM",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, FASTZOOM),
     0,0,0, 70 },
   { "FILLETRAD",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, FILLETRAD),
     0,0,0, 40 },
   { "FILLMODE",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, FILLMODE),
     0,0,0, 70 },
   { "FINGERPRINTGUID",	"TV", sizeof (BITCODE_TV),  OFF (struct _dwg_header_variables, FINGERPRINTGUID),
     1,1,1, 2 },
   { "FLAGS",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_header_variables, FLAGS),
     0,0,0, 0 },
   { "FLATLAND",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, FLATLAND),
     0,0,0, 70 },
   { "FRONTZ",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, FRONTZ),
     0,0,0, 0 },
   { "GRIDMODE",	"RS", sizeof (BITCODE_RS),  OFF (struct _dwg_header_variables, GRIDMODE),
     0,0,0, 70 },
   { "GRIDUNIT",	"2RD", sizeof (BITCODE_2RD),  OFF (struct _dwg_header_variables, GRIDUNIT),
     1,0,0, 20 },
   { "HALOGAP",	"RC", sizeof (BITCODE_RC),  OFF (struct _dwg_header_variables, HALOGAP),
     0,0,0, 280 },
   { "HANDLING",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, HANDLING),
     0,0,0, 70 },
   { "HANDSEED",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, HANDSEED),
     1,0,0, 5 },
   { "HIDETEXT",	"RC", sizeof (BITCODE_RC),  OFF (struct _dwg_header_variables, HIDETEXT),
     0,0,0, 280 },
   { "HYPERLINKBASE",	"T", sizeof (BITCODE_T),  OFF (struct _dwg_header_variables, HYPERLINKBASE),
     1,1,1, 1 },
   { "INDEXCTL",	"RC", sizeof (BITCODE_RC),  OFF (struct _dwg_header_variables, INDEXCTL),
     0,0,0, 280 },
   { "INSBASE",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_header_variables, INSBASE),
     1,0,0, 30 },
   { "INSUNITS",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, INSUNITS),
     0,0,0, 70 },
   { "INTERFERECOLOR",	"CMC", sizeof (BITCODE_CMC),  OFF (struct _dwg_header_variables, INTERFERECOLOR),
     0,0,0, 62 },
   { "INTERFEREOBJVS",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, INTERFEREOBJVS),
     1,0,0, 345 },
   { "INTERFEREVPVS",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, INTERFEREVPVS),
     1,0,0, 346 },
   { "INTERSECTIONCOLOR",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, INTERSECTIONCOLOR),
     0,0,0, 70 },
   { "INTERSECTIONDISPLAY",	"RC", sizeof (BITCODE_RC),  OFF (struct _dwg_header_variables, INTERSECTIONDISPLAY),
     0,0,0, 280 },
   { "ISOLINES",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, ISOLINES),
     0,0,0, 0 },
   { "JOINSTYLE",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, JOINSTYLE),
     0,0,0, 280 },
   { "LATITUDE",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, LATITUDE),
     0,0,0, 40 },
   { "LAYER_CONTROL_OBJECT",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, LAYER_CONTROL_OBJECT),
     1,0,0, 0 },
   { "LENSLENGTH",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, LENSLENGTH),
     0,0,0, 40 },
   { "LIGHTGLYPHDISPLAY",	"RC", sizeof (BITCODE_RC),  OFF (struct _dwg_header_variables, LIGHTGLYPHDISPLAY),
     0,0,0, 280 },
   { "LIMCHECK",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, LIMCHECK),
     0,0,0, 70 },
   { "LIMMAX",	"2DPOINT", sizeof (BITCODE_2DPOINT),  OFF (struct _dwg_header_variables, LIMMAX),
     1,0,0, 20 },
   { "LIMMIN",	"2DPOINT", sizeof (BITCODE_2DPOINT),  OFF (struct _dwg_header_variables, LIMMIN),
     1,0,0, 20 },
   { "LOFTANG1",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, LOFTANG1),
     0,0,0, 40 },
   { "LOFTANG2",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, LOFTANG2),
     0,0,0, 40 },
   { "LOFTMAG1",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, LOFTMAG1),
     0,0,0, 40 },
   { "LOFTMAG2",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, LOFTMAG2),
     0,0,0, 40 },
   { "LOFTNORMALS",	"RC", sizeof (BITCODE_RC),  OFF (struct _dwg_header_variables, LOFTNORMALS),
     0,0,0, 280 },
   { "LOFTPARAM",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, LOFTPARAM),
     0,0,0, 70 },
   { "LONGITUDE",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, LONGITUDE),
     0,0,0, 40 },
   { "LTSCALE",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, LTSCALE),
     0,0,0, 40 },
   { "LTYPE_BYBLOCK",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, LTYPE_BYBLOCK),
     1,0,0, 0 },
   { "LTYPE_BYLAYER",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, LTYPE_BYLAYER),
     1,0,0, 0 },
   { "LTYPE_CONTINUOUS",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, LTYPE_CONTINUOUS),
     1,0,0, 0 },
   { "LTYPE_CONTROL_OBJECT",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, LTYPE_CONTROL_OBJECT),
     1,0,0, 0 },
   { "LUNITS",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, LUNITS),
     0,0,0, 70 },
   { "LUPREC",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, LUPREC),
     0,0,0, 70 },
   { "LWDISPLAY",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, LWDISPLAY),
     0,0,0, 290 },
   { "MAXACTVP",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, MAXACTVP),
     0,0,0, 70 },
   { "MEASUREMENT",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, MEASUREMENT),
     0,0,0, 70 },
   { "MENU",	"TV", sizeof (BITCODE_TV),  OFF (struct _dwg_header_variables, MENU),
     1,1,1, 1 },
-  { "MENUEXT[46]",	"RC", 46 * sizeof (BITCODE_RC),  OFF (struct _dwg_header_variables, MENUEXT),
+  { "MENUEXT",	"RC", 46 * sizeof (BITCODE_RC),  OFF (struct _dwg_header_variables, MENUEXT),
     0,0,0, 0 },
   { "MIRRTEXT",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, MIRRTEXT),
     0,0,0, 70 },
   { "NORTHDIRECTION",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, NORTHDIRECTION),
     0,0,0, 40 },
   { "OBSCOLOR",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, OBSCOLOR),
     0,0,0, 70 },
   { "OBSLTYPE",	"RC", sizeof (BITCODE_RC),  OFF (struct _dwg_header_variables, OBSLTYPE),
     0,0,0, 280 },
   { "OLESTARTUP",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, OLESTARTUP),
     0,0,0, 290 },
   { "ORTHOMODE",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, ORTHOMODE),
     0,0,0, 70 },
   { "OSMODE",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_header_variables, OSMODE),
     0,0,0, 70 },
   { "PDMODE",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, PDMODE),
     0,0,0, 70 },
   { "PDSIZE",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, PDSIZE),
     0,0,0, 40 },
   { "PELEVATION",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, PELEVATION),
     0,0,0, 40 },
   { "PELLIPSE",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, PELLIPSE),
     0,0,0, 0 },
   { "PEXTMAX",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_header_variables, PEXTMAX),
     1,0,0, 30 },
   { "PEXTMIN",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_header_variables, PEXTMIN),
     1,0,0, 30 },
   { "PICKSTYLE",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, PICKSTYLE),
     0,0,0, 70 },
   { "PINSBASE",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_header_variables, PINSBASE),
     1,0,0, 30 },
   { "PLIMCHECK",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, PLIMCHECK),
     0,0,0, 70 },
   { "PLIMMAX",	"2DPOINT", sizeof (BITCODE_2DPOINT),  OFF (struct _dwg_header_variables, PLIMMAX),
     1,0,0, 20 },
   { "PLIMMIN",	"2DPOINT", sizeof (BITCODE_2DPOINT),  OFF (struct _dwg_header_variables, PLIMMIN),
     1,0,0, 20 },
   { "PLINEGEN",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, PLINEGEN),
     0,0,0, 70 },
   { "PLINEWID",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, PLINEWID),
     0,0,0, 40 },
   { "PROJECTNAME",	"TV", sizeof (BITCODE_TV),  OFF (struct _dwg_header_variables, PROJECTNAME),
     1,1,1, 1 },
   { "PROXYGRAPHICS",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, PROXYGRAPHICS),
     0,0,0, 70 },
   { "PSLTSCALE",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, PSLTSCALE),
     0,0,0, 70 },
   { "PSOLHEIGHT",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, PSOLHEIGHT),
     0,0,0, 40 },
   { "PSOLWIDTH",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, PSOLWIDTH),
     0,0,0, 40 },
   { "PSTYLEMODE",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, PSTYLEMODE),
     0,0,0, 290 },
   { "PSVPSCALE",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, PSVPSCALE),
     0,0,0, 40 },
   { "PUCSBASE",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, PUCSBASE),
     1,0,0, 2 },
   { "PUCSNAME",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, PUCSNAME),
     1,0,0, 2 },
   { "PUCSORG",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_header_variables, PUCSORG),
     1,0,0, 30 },
   { "PUCSORGBACK",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_header_variables, PUCSORGBACK),
     1,0,0, 30 },
   { "PUCSORGBOTTOM",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_header_variables, PUCSORGBOTTOM),
     1,0,0, 30 },
   { "PUCSORGFRONT",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_header_variables, PUCSORGFRONT),
     1,0,0, 30 },
   { "PUCSORGLEFT",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_header_variables, PUCSORGLEFT),
     1,0,0, 30 },
   { "PUCSORGRIGHT",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_header_variables, PUCSORGRIGHT),
     1,0,0, 30 },
   { "PUCSORGTOP",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_header_variables, PUCSORGTOP),
     1,0,0, 30 },
   { "PUCSORTHOREF",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, PUCSORTHOREF),
     1,0,0, 2 },
   { "PUCSORTHOVIEW",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, PUCSORTHOVIEW),
     0,0,0, 70 },
   { "PUCSXDIR",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_header_variables, PUCSXDIR),
     1,0,0, 30 },
   { "PUCSYDIR",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_header_variables, PUCSYDIR),
     1,0,0, 30 },
   { "QTEXTMODE",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, QTEXTMODE),
     0,0,0, 70 },
   { "REALWORLDSCALE",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, REALWORLDSCALE),
     0,0,0, 290 },
   { "REGENMODE",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, REGENMODE),
     0,0,0, 70 },
   { "REQUIREDVERSIONS",	"BLL", sizeof (BITCODE_BLL),  OFF (struct _dwg_header_variables, REQUIREDVERSIONS),
     0,0,0, 160 },
   { "SAVEIMAGES",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, SAVEIMAGES),
     0,0,0, 0 },
   { "SHADEDGE",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, SHADEDGE),
     0,0,0, 70 },
   { "SHADEDIF",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, SHADEDIF),
     0,0,0, 70 },
   { "SHADOWPLANELOCATION",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, SHADOWPLANELOCATION),
     0,0,0, 40 },
   { "SHOWHIST",	"RC", sizeof (BITCODE_RC),  OFF (struct _dwg_header_variables, SHOWHIST),
     0,0,0, 280 },
   { "SKETCHINC",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, SKETCHINC),
     0,0,0, 40 },
   { "SKPOLY",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, SKPOLY),
     0,0,0, 70 },
   { "SNAPANG",	"RD", sizeof (BITCODE_RD),  OFF (struct _dwg_header_variables, SNAPANG),
     0,0,0, 50 },
   { "SNAPBASE",	"2RD", sizeof (BITCODE_2RD),  OFF (struct _dwg_header_variables, SNAPBASE),
     1,0,0, 20 },
   { "SNAPISOPAIR",	"RS", sizeof (BITCODE_RS),  OFF (struct _dwg_header_variables, SNAPISOPAIR),
     0,0,0, 70 },
   { "SNAPMODE",	"RS", sizeof (BITCODE_RS),  OFF (struct _dwg_header_variables, SNAPMODE),
     0,0,0, 70 },
   { "SNAPSTYLE",	"RS", sizeof (BITCODE_RS),  OFF (struct _dwg_header_variables, SNAPSTYLE),
     0,0,0, 70 },
   { "SNAPUNIT",	"2RD", sizeof (BITCODE_2RD),  OFF (struct _dwg_header_variables, SNAPUNIT),
     1,0,0, 20 },
   { "SOLIDHIST",	"RC", sizeof (BITCODE_RC),  OFF (struct _dwg_header_variables, SOLIDHIST),
     0,0,0, 280 },
   { "SORTENTS",	"RC", sizeof (BITCODE_RC),  OFF (struct _dwg_header_variables, SORTENTS),
     0,0,0, 280 },
   { "SPLFRAME",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, SPLFRAME),
     0,0,0, 70 },
   { "SPLINESEGS",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, SPLINESEGS),
     0,0,0, 70 },
   { "SPLINETYPE",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, SPLINETYPE),
     0,0,0, 70 },
   { "STEPSIZE",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, STEPSIZE),
     0,0,0, 40 },
   { "STEPSPERSEC",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, STEPSPERSEC),
     0,0,0, 40 },
   { "STYLESHEET",	"TV", sizeof (BITCODE_TV),  OFF (struct _dwg_header_variables, STYLESHEET),
     1,1,1, 1 },
   { "STYLE_CONTROL_OBJECT",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, STYLE_CONTROL_OBJECT),
     1,0,0, 0 },
   { "SURFTAB1",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, SURFTAB1),
     0,0,0, 70 },
   { "SURFTAB2",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, SURFTAB2),
     0,0,0, 70 },
   { "SURFTYPE",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, SURFTYPE),
     0,0,0, 70 },
   { "SURFU",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, SURFU),
     0,0,0, 70 },
   { "SURFV",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, SURFV),
     0,0,0, 70 },
   { "TARGET",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_header_variables, TARGET),
     1,0,0, 0 },
   { "TDCREATE",	"TIMEBLL", sizeof (BITCODE_TIMEBLL),  OFF (struct _dwg_header_variables, TDCREATE),
     1,0,0, 40 },
   { "TDINDWG",	"TIMEBLL", sizeof (BITCODE_TIMEBLL),  OFF (struct _dwg_header_variables, TDINDWG),
     1,0,0, 40 },
   { "TDUCREATE",	"TIMEBLL", sizeof (BITCODE_TIMEBLL),  OFF (struct _dwg_header_variables, TDUCREATE),
     1,0,0, 40 },
   { "TDUPDATE",	"TIMEBLL", sizeof (BITCODE_TIMEBLL),  OFF (struct _dwg_header_variables, TDUPDATE),
     1,0,0, 40 },
   { "TDUSRTIMER",	"TIMEBLL", sizeof (BITCODE_TIMEBLL),  OFF (struct _dwg_header_variables, TDUSRTIMER),
     1,0,0, 40 },
   { "TDUUPDATE",	"TIMEBLL", sizeof (BITCODE_TIMEBLL),  OFF (struct _dwg_header_variables, TDUUPDATE),
     1,0,0, 40 },
   { "TEXTQLTY",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, TEXTQLTY),
     0,0,0, 0 },
   { "TEXTSIZE",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, TEXTSIZE),
     0,0,0, 40 },
   { "TEXTSTYLE",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, TEXTSTYLE),
     1,0,0, 7 },
   { "THICKNESS",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, THICKNESS),
     0,0,0, 40 },
   { "TILEMODE",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, TILEMODE),
     0,0,0, 70 },
   { "TILEMODELIGHTSYNCH",	"RC", sizeof (BITCODE_RC),  OFF (struct _dwg_header_variables, TILEMODELIGHTSYNCH),
     0,0,0, 280 },
   { "TIMEZONE",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_header_variables, TIMEZONE),
     0,0,0, 70 },
   { "TRACEWID",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, TRACEWID),
     0,0,0, 40 },
   { "TREEDEPTH",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, TREEDEPTH),
     0,0,0, 70 },
   { "TSTACKALIGN",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, TSTACKALIGN),
     0,0,0, 0 },
   { "TSTACKSIZE",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, TSTACKSIZE),
     0,0,0, 0 },
   { "UCSBASE",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, UCSBASE),
     1,0,0, 2 },
   { "UCSICON",	"RC", sizeof (BITCODE_RC),  OFF (struct _dwg_header_variables, UCSICON),
     0,0,0, 0 },
   { "UCSNAME",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, UCSNAME),
     1,0,0, 2 },
   { "UCSORG",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_header_variables, UCSORG),
     1,0,0, 30 },
   { "UCSORGBACK",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_header_variables, UCSORGBACK),
     1,0,0, 30 },
   { "UCSORGBOTTOM",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_header_variables, UCSORGBOTTOM),
     1,0,0, 30 },
   { "UCSORGFRONT",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_header_variables, UCSORGFRONT),
     1,0,0, 30 },
   { "UCSORGLEFT",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_header_variables, UCSORGLEFT),
     1,0,0, 30 },
   { "UCSORGRIGHT",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_header_variables, UCSORGRIGHT),
     1,0,0, 30 },
   { "UCSORGTOP",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_header_variables, UCSORGTOP),
     1,0,0, 30 },
   { "UCSORTHOREF",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, UCSORTHOREF),
     1,0,0, 2 },
   { "UCSORTHOVIEW",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, UCSORTHOVIEW),
     0,0,0, 70 },
   { "UCSXDIR",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_header_variables, UCSXDIR),
     1,0,0, 30 },
   { "UCSYDIR",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_header_variables, UCSYDIR),
     1,0,0, 30 },
   { "UCS_CONTROL_OBJECT",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, UCS_CONTROL_OBJECT),
     1,0,0, 0 },
   { "UNITMODE",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, UNITMODE),
     0,0,0, 70 },
   { "USERI1",	"BSd", sizeof (BITCODE_BSd),  OFF (struct _dwg_header_variables, USERI1),
     0,0,0, 70 },
   { "USERI2",	"BSd", sizeof (BITCODE_BSd),  OFF (struct _dwg_header_variables, USERI2),
     0,0,0, 70 },
   { "USERI3",	"BSd", sizeof (BITCODE_BSd),  OFF (struct _dwg_header_variables, USERI3),
     0,0,0, 70 },
   { "USERI4",	"BSd", sizeof (BITCODE_BSd),  OFF (struct _dwg_header_variables, USERI4),
     0,0,0, 70 },
   { "USERI5",	"BSd", sizeof (BITCODE_BSd),  OFF (struct _dwg_header_variables, USERI5),
     0,0,0, 70 },
   { "USERR1",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, USERR1),
     0,0,0, 40 },
   { "USERR2",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, USERR2),
     0,0,0, 40 },
   { "USERR3",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, USERR3),
     0,0,0, 40 },
   { "USERR4",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, USERR4),
     0,0,0, 40 },
   { "USERR5",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, USERR5),
     0,0,0, 40 },
   { "USRTIMER",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, USRTIMER),
     0,0,0, 70 },
   { "VERSIONGUID",	"TV", sizeof (BITCODE_TV),  OFF (struct _dwg_header_variables, VERSIONGUID),
     1,1,1, 2 },
   { "VIEWCTR",	"3RD", sizeof (BITCODE_3RD),  OFF (struct _dwg_header_variables, VIEWCTR),
     1,0,0, 20 },
   { "VIEWDIR",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_header_variables, VIEWDIR),
     1,0,0, 30 },
   { "VIEWMODE",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, VIEWMODE),
     0,0,0, 0 },
   { "VIEWSIZE",	"RD", sizeof (BITCODE_RD),  OFF (struct _dwg_header_variables, VIEWSIZE),
     0,0,0, 40 },
   { "VIEWTWIST",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, VIEWTWIST),
     0,0,0, 0 },
   { "VIEW_CONTROL_OBJECT",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, VIEW_CONTROL_OBJECT),
     1,0,0, 0 },
   { "VISRETAIN",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, VISRETAIN),
     0,0,0, 70 },
   { "VPOINTX",	"3RD", sizeof (BITCODE_3RD),  OFF (struct _dwg_header_variables, VPOINTX),
     1,0,0, 0 },
   { "VPOINTXALT",	"3RD", sizeof (BITCODE_3RD),  OFF (struct _dwg_header_variables, VPOINTXALT),
     1,0,0, 0 },
   { "VPOINTY",	"3RD", sizeof (BITCODE_3RD),  OFF (struct _dwg_header_variables, VPOINTY),
     1,0,0, 0 },
   { "VPOINTYALT",	"3RD", sizeof (BITCODE_3RD),  OFF (struct _dwg_header_variables, VPOINTYALT),
     1,0,0, 0 },
   { "VPOINTZ",	"3RD", sizeof (BITCODE_3RD),  OFF (struct _dwg_header_variables, VPOINTZ),
     1,0,0, 0 },
   { "VPOINTZALT",	"3RD", sizeof (BITCODE_3RD),  OFF (struct _dwg_header_variables, VPOINTZALT),
     1,0,0, 0 },
   { "VPORT_CONTROL_OBJECT",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, VPORT_CONTROL_OBJECT),
     1,0,0, 0 },
   { "VX_CONTROL_OBJECT",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, VX_CONTROL_OBJECT),
     1,0,0, 0 },
   { "VX_TABLE_RECORD",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, VX_TABLE_RECORD),
     1,0,0, 0 },
   { "WIREFRAME",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, WIREFRAME),
     0,0,0, 0 },
   { "WORLDVIEW",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, WORLDVIEW),
     0,0,0, 70 },
   { "XCLIPFRAME",	"RC", sizeof (BITCODE_RC),  OFF (struct _dwg_header_variables, XCLIPFRAME),
     0,0,0, 290 },
   { "XEDIT",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, XEDIT),
     0,0,0, 290 },
   { "_3DDWFPREC",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, _3DDWFPREC),
     0,0,0, 40 },
   { "aspect_ratio",	"RD", sizeof (BITCODE_RD),  OFF (struct _dwg_header_variables, aspect_ratio),
     0,0,0, 0 },
   { "bitsize",	"RL", sizeof (BITCODE_RL),  OFF (struct _dwg_header_variables, bitsize),
     0,0,0, 0 },
   { "bitsize_hi",	"RL", sizeof (BITCODE_RL),  OFF (struct _dwg_header_variables, bitsize_hi),
     0,0,0, 0 },
   { "circle_zoom_percent",	"RS", sizeof (BITCODE_RS),  OFF (struct _dwg_header_variables, circle_zoom_percent),
     0,0,0, 0 },
   { "codepage",	"RS", sizeof (BITCODE_RS),  OFF (struct _dwg_header_variables, codepage),
     0,0,0, 0 },
   { "dwg_size",	"RL", sizeof (BITCODE_RL),  OFF (struct _dwg_header_variables, dwg_size),
     0,0,0, 0 },
   { "flag_3d",	"RS", sizeof (BITCODE_RS),  OFF (struct _dwg_header_variables, flag_3d),
     0,0,0, 0 },
-  { "layer_colors[128]",	"RS", 128 * sizeof (BITCODE_RS),  OFF (struct _dwg_header_variables, layer_colors),
+  { "layer_colors",	"RS", 128 * sizeof (BITCODE_RS),  OFF (struct _dwg_header_variables, layer_colors),
     0,0,0, 0 },
   { "numentities",	"RS", sizeof (BITCODE_RS),  OFF (struct _dwg_header_variables, numentities),
     0,0,0, 0 },
   { "oldCECOLOR_hi",	"RL", sizeof (BITCODE_RL),  OFF (struct _dwg_header_variables, oldCECOLOR_hi),
     0,0,0, 0 },
   { "oldCECOLOR_lo",	"RL", sizeof (BITCODE_RL),  OFF (struct _dwg_header_variables, oldCECOLOR_lo),
     0,0,0, 0 },
   { "size",	"RL", sizeof (BITCODE_RL),  OFF (struct _dwg_header_variables, size),
     0,0,0, 0 },
   { "unit1_name",	"TV", sizeof (BITCODE_TV),  OFF (struct _dwg_header_variables, unit1_name),
     1,1,1, 0 },
   { "unit1_ratio",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, unit1_ratio),
     0,0,0, 0 },
   { "unit2_name",	"TV", sizeof (BITCODE_TV),  OFF (struct _dwg_header_variables, unit2_name),
     1,1,1, 0 },
   { "unit2_ratio",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, unit2_ratio),
     0,0,0, 0 },
   { "unit3_name",	"TV", sizeof (BITCODE_TV),  OFF (struct _dwg_header_variables, unit3_name),
     1,1,1, 0 },
   { "unit3_ratio",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, unit3_ratio),
     0,0,0, 0 },
   { "unit4_name",	"TV", sizeof (BITCODE_TV),  OFF (struct _dwg_header_variables, unit4_name),
     1,1,1, 0 },
   { "unit4_ratio",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, unit4_ratio),
     0,0,0, 0 },
   { "unknown_10",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, unknown_10),
     0,0,0, 0 },
   { "unknown_11",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_header_variables, unknown_11),
     0,0,0, 0 },
   { "unknown_12",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_header_variables, unknown_12),
     0,0,0, 0 },
   { "unknown_13",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_header_variables, unknown_13),
     0,0,0, 0 },
   { "unknown_14",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_header_variables, unknown_14),
     0,0,0, 0 },
   { "unknown_14b",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_header_variables, unknown_14b),
     0,0,0, 0 },
   { "unknown_15",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_header_variables, unknown_15),
     0,0,0, 0 },
   { "unknown_16",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_header_variables, unknown_16),
     0,0,0, 0 },
   { "unknown_17",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_header_variables, unknown_17),
     0,0,0, 0 },
   { "unknown_20",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_header_variables, unknown_20),
     1,0,0, 0 },
   { "unknown_21",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_header_variables, unknown_21),
     0,0,0, 0 },
   { "unknown_22",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_header_variables, unknown_22),
     0,0,0, 0 },
   { "unknown_23",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_header_variables, unknown_23),
     0,0,0, 0 },
   { "unknown_4f2",	"RL", sizeof (BITCODE_RL),  OFF (struct _dwg_header_variables, unknown_4f2),
     0,0,0, 0 },
   { "unknown_5",	"RS", sizeof (BITCODE_RS),  OFF (struct _dwg_header_variables, unknown_5),
     0,0,0, 0 },
   { "unknown_51e",	"RS", sizeof (BITCODE_RS),  OFF (struct _dwg_header_variables, unknown_51e),
     0,0,0, 0 },
   { "unknown_520",	"RS", sizeof (BITCODE_RS),  OFF (struct _dwg_header_variables, unknown_520),
     0,0,0, 0 },
   { "unknown_52c",	"RSd", sizeof (BITCODE_RSd),  OFF (struct _dwg_header_variables, unknown_52c),
     0,0,0, 0 },
   { "unknown_52e",	"RS", sizeof (BITCODE_RS),  OFF (struct _dwg_header_variables, unknown_52e),
     0,0,0, 0 },
   { "unknown_530",	"RC", sizeof (BITCODE_RC),  OFF (struct _dwg_header_variables, unknown_530),
     0,0,0, 0 },
   { "unknown_54",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, unknown_54),
     0,0,0, 0 },
   { "unknown_55",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, unknown_55),
     0,0,0, 0 },
   { "unknown_56",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, unknown_56),
     0,0,0, 0 },
   { "unknown_57",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_header_variables, unknown_57),
     0,0,0, 0 },
   { "unknown_59",	"RS", sizeof (BITCODE_RS),  OFF (struct _dwg_header_variables, unknown_59),
     0,0,0, 0 },
   { "unknown_6",	"RS", sizeof (BITCODE_RS),  OFF (struct _dwg_header_variables, unknown_6),
     0,0,0, 0 },
   { "unknown_6a",	"RS", sizeof (BITCODE_RS),  OFF (struct _dwg_header_variables, unknown_6a),
     0,0,0, 0 },
   { "unknown_6b",	"RS", sizeof (BITCODE_RS),  OFF (struct _dwg_header_variables, unknown_6b),
     0,0,0, 0 },
   { "unknown_6c",	"RS", sizeof (BITCODE_RS),  OFF (struct _dwg_header_variables, unknown_6c),
     0,0,0, 0 },
   { "unknown_8",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_header_variables, unknown_8),
     0,0,0, 0 },
   { "unknown_9",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_header_variables, unknown_9),
     0,0,0, 0 },
   { "unknown_day",	"RS", sizeof (BITCODE_RS),  OFF (struct _dwg_header_variables, unknown_day),
     0,0,0, 0 },
   { "unknown_hour",	"RS", sizeof (BITCODE_RS),  OFF (struct _dwg_header_variables, unknown_hour),
     0,0,0, 0 },
   { "unknown_min",	"RS", sizeof (BITCODE_RS),  OFF (struct _dwg_header_variables, unknown_min),
     0,0,0, 0 },
   { "unknown_mon",	"RS", sizeof (BITCODE_RS),  OFF (struct _dwg_header_variables, unknown_mon),
     0,0,0, 0 },
   { "unknown_ms",	"RS", sizeof (BITCODE_RS),  OFF (struct _dwg_header_variables, unknown_ms),
     0,0,0, 0 },
   { "unknown_sec",	"RS", sizeof (BITCODE_RS),  OFF (struct _dwg_header_variables, unknown_sec),
     0,0,0, 0 },
   { "unknown_string",	"T", sizeof (BITCODE_T),  OFF (struct _dwg_header_variables, unknown_string),
     1,1,1, 0 },
   { "unknown_year",	"RS", sizeof (BITCODE_RS),  OFF (struct _dwg_header_variables, unknown_year),
     0,0,0, 0 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 
 /* from typedef struct _dwg_entity_3DFACE: (sorted by offset) */
@@ -865,81 +865,81 @@ static const Dwg_DYNAPI_field _dwg_3DLINE_fields[] = {
   { "parent",	"struct _dwg_object_entity*", sizeof (void *),  OFF (struct _dwg_entity_3DLINE, parent),
     1,1,0, 0 },
   { "start",	"3RD", sizeof (BITCODE_3RD),  OFF (struct _dwg_entity_3DLINE, start),
     1,0,0, 10 },
   { "end",	"3RD", sizeof (BITCODE_3RD),  OFF (struct _dwg_entity_3DLINE, end),
     1,0,0, 11 },
   { "extrusion",	"3RD", sizeof (BITCODE_3RD),  OFF (struct _dwg_entity_3DLINE, extrusion),
     1,0,0, 210 },
   { "thickness",	"RD", sizeof (BITCODE_RD),  OFF (struct _dwg_entity_3DLINE, thickness),
     0,0,0, 39 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_entity_3DSOLID: (sorted by offset) */
 static const Dwg_DYNAPI_field _dwg_3DSOLID_fields[] = {
   { "parent",	"struct _dwg_object_entity*", sizeof (void *),  OFF (struct _dwg_entity_3DSOLID, parent),
     1,1,0, 0 },
   { "acis_empty",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_3DSOLID, acis_empty),
     0,0,0, 290 },
   { "unknown",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_3DSOLID, unknown),
     0,0,0, 0 },
   { "version",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_3DSOLID, version),
     0,0,0, 70 },
   { "num_blocks",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_3DSOLID, num_blocks),
     0,0,0, 0 },
   { "block_size",	"BL*", sizeof (BITCODE_BL*),  OFF (struct _dwg_entity_3DSOLID, block_size),
     1,1,0, 0 },
   { "encr_sat_data",	"char **", sizeof (char **),  OFF (struct _dwg_entity_3DSOLID, encr_sat_data),
     1,1,0, 1 },
   { "sab_size",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_3DSOLID, sab_size),
     0,0,0, 0 },
   { "acis_data",	"RC*", sizeof (BITCODE_RC*),  OFF (struct _dwg_entity_3DSOLID, acis_data),
     1,1,0, 0 },
   { "wireframe_data_present",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_3DSOLID, wireframe_data_present),
     0,0,0, 0 },
   { "point_present",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_3DSOLID, point_present),
     0,0,0, 0 },
   { "point",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_entity_3DSOLID, point),
     1,0,0, 0 },
   { "isolines",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_3DSOLID, isolines),
     0,0,0, 0 },
   { "isoline_present",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_3DSOLID, isoline_present),
     0,0,0, 0 },
   { "num_wires",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_3DSOLID, num_wires),
     0,0,0, 0 },
   { "wires",	"Dwg_3DSOLID_wire*", sizeof (Dwg_3DSOLID_wire*),  OFF (struct _dwg_entity_3DSOLID, wires),
     1,1,0, 0 },
   { "num_silhouettes",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_3DSOLID, num_silhouettes),
     0,0,0, 0 },
   { "silhouettes",	"Dwg_3DSOLID_silhouette*", sizeof (Dwg_3DSOLID_silhouette*),  OFF (struct _dwg_entity_3DSOLID, silhouettes),
     1,1,0, 0 },
   { "_dxf_sab_converted",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_3DSOLID, _dxf_sab_converted),
     0,0,0, 0 },
   { "acis_empty2",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_3DSOLID, acis_empty2),
     0,0,0, 0 },
   { "extra_acis_data",	"struct _dwg_entity_3DSOLID*", sizeof (void *),  OFF (struct _dwg_entity_3DSOLID, extra_acis_data),
     1,1,0, 0 },
   { "num_materials",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_3DSOLID, num_materials),
     0,0,0, 0 },
   { "materials",	"Dwg_3DSOLID_material*", sizeof (Dwg_3DSOLID_material*),  OFF (struct _dwg_entity_3DSOLID, materials),
     1,1,0, 0 },
-  { "revision_guid[39]",	"RC", 39 * sizeof (BITCODE_RC),  OFF (struct _dwg_entity_3DSOLID, revision_guid),
+  { "revision_guid",	"RC", 39 * sizeof (BITCODE_RC),  OFF (struct _dwg_entity_3DSOLID, revision_guid),
     0,0,0, 2 },
   { "revision_major",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_3DSOLID, revision_major),
     0,0,0, 0 },
   { "revision_minor1",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_3DSOLID, revision_minor1),
     0,0,0, 0 },
   { "revision_minor2",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_3DSOLID, revision_minor2),
     0,0,0, 0 },
-  { "revision_bytes[9]",	"RC", 9 * sizeof (BITCODE_RC),  OFF (struct _dwg_entity_3DSOLID, revision_bytes),
+  { "revision_bytes",	"RC", 9 * sizeof (BITCODE_RC),  OFF (struct _dwg_entity_3DSOLID, revision_bytes),
     0,0,0, 0 },
   { "end_marker",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_3DSOLID, end_marker),
     0,0,0, 0 },
   { "history_id",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_entity_3DSOLID, history_id),
     1,0,0, 350 },
   { "has_revision_guid",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_3DSOLID, has_revision_guid),
     0,0,0, 0 },
   { "acis_empty_bit",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_3DSOLID, acis_empty_bit),
     0,0,0, 0 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_entity_ALIGNMENTPARAMETERENTITY: (sorted by offset) */
@@ -1709,135 +1709,135 @@ static const Dwg_DYNAPI_field _dwg_ENDREP_fields[] = {
   { "parent",	"struct _dwg_object_entity*", sizeof (void *),  OFF (struct _dwg_entity_ENDREP, parent),
     1,1,0, 0 },
   { "numcols",	"RS", sizeof (BITCODE_RS),  OFF (struct _dwg_entity_ENDREP, numcols),
     0,0,0, 70 },
   { "numrows",	"RS", sizeof (BITCODE_RS),  OFF (struct _dwg_entity_ENDREP, numrows),
     0,0,0, 71 },
   { "colspacing",	"RD", sizeof (BITCODE_RD),  OFF (struct _dwg_entity_ENDREP, colspacing),
     0,0,0, 40 },
   { "rowspacing",	"RD", sizeof (BITCODE_RD),  OFF (struct _dwg_entity_ENDREP, rowspacing),
     0,0,0, 41 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_entity_EXTRUDEDSURFACE: (sorted by offset) */
 static const Dwg_DYNAPI_field _dwg_EXTRUDEDSURFACE_fields[] = {
   { "parent",	"struct _dwg_object_entity*", sizeof (void *),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, parent),
     1,1,0, 0 },
   { "acis_empty",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, acis_empty),
     0,0,0, 290 },
   { "unknown",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, unknown),
     0,0,0, 0 },
   { "version",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, version),
     0,0,0, 70 },
   { "num_blocks",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, num_blocks),
     0,0,0, 0 },
   { "block_size",	"BL*", sizeof (BITCODE_BL*),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, block_size),
     1,1,0, 0 },
   { "encr_sat_data",	"char **", sizeof (char **),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, encr_sat_data),
     1,1,0, 1 },
   { "sab_size",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, sab_size),
     0,0,0, 0 },
   { "acis_data",	"RC*", sizeof (BITCODE_RC*),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, acis_data),
     1,1,0, 0 },
   { "wireframe_data_present",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, wireframe_data_present),
     0,0,0, 0 },
   { "point_present",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, point_present),
     0,0,0, 0 },
   { "point",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, point),
     1,0,0, 0 },
   { "isolines",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, isolines),
     0,0,0, 0 },
   { "isoline_present",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, isoline_present),
     0,0,0, 0 },
   { "num_wires",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, num_wires),
     0,0,0, 0 },
   { "wires",	"Dwg_3DSOLID_wire*", sizeof (Dwg_3DSOLID_wire*),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, wires),
     1,1,0, 0 },
   { "num_silhouettes",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, num_silhouettes),
     0,0,0, 0 },
   { "silhouettes",	"Dwg_3DSOLID_silhouette*", sizeof (Dwg_3DSOLID_silhouette*),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, silhouettes),
     1,1,0, 0 },
   { "_dxf_sab_converted",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, _dxf_sab_converted),
     0,0,0, 0 },
   { "acis_empty2",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, acis_empty2),
     0,0,0, 0 },
   { "extra_acis_data",	"struct _dwg_entity_3DSOLID*", sizeof (void *),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, extra_acis_data),
     1,1,0, 0 },
   { "num_materials",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, num_materials),
     0,0,0, 0 },
   { "materials",	"Dwg_3DSOLID_material*", sizeof (Dwg_3DSOLID_material*),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, materials),
     1,1,0, 0 },
-  { "revision_guid[39]",	"RC", 39 * sizeof (BITCODE_RC),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, revision_guid),
+  { "revision_guid",	"RC", 39 * sizeof (BITCODE_RC),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, revision_guid),
     0,0,0, 2 },
   { "revision_major",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, revision_major),
     0,0,0, 0 },
   { "revision_minor1",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, revision_minor1),
     0,0,0, 0 },
   { "revision_minor2",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, revision_minor2),
     0,0,0, 0 },
-  { "revision_bytes[9]",	"RC", 9 * sizeof (BITCODE_RC),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, revision_bytes),
+  { "revision_bytes",	"RC", 9 * sizeof (BITCODE_RC),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, revision_bytes),
     0,0,0, 0 },
   { "end_marker",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, end_marker),
     0,0,0, 0 },
   { "history_id",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, history_id),
     1,0,0, 350 },
   { "has_revision_guid",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, has_revision_guid),
     0,0,0, 0 },
   { "acis_empty_bit",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, acis_empty_bit),
     0,0,0, 0 },
   { "modeler_format_version",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, modeler_format_version),
     0,0,0, 0 },
   { "bindata_size",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, bindata_size),
     0,0,0, 0 },
   { "bindata",	"TF", sizeof (BITCODE_TF),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, bindata),
     1,1,0, 0 },
   { "u_isolines",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, u_isolines),
     0,0,0, 71 },
   { "v_isolines",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, v_isolines),
     0,0,0, 72 },
   { "class_version",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, class_version),
     0,0,0, 0 },
   { "draft_angle",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, draft_angle),
     0,0,0, 42 },
   { "draft_start_distance",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, draft_start_distance),
     0,0,0, 43 },
   { "draft_end_distance",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, draft_end_distance),
     0,0,0, 44 },
   { "twist_angle",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, twist_angle),
     0,0,0, 45 },
   { "scale_factor",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, scale_factor),
     0,0,0, 48 },
   { "align_angle",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, align_angle),
     0,0,0, 49 },
   { "sweep_entity_transmatrix",	"BD*", sizeof (BITCODE_BD*),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, sweep_entity_transmatrix),
     1,1,0, 46 },
   { "path_entity_transmatrix",	"BD*", sizeof (BITCODE_BD*),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, path_entity_transmatrix),
     1,1,0, 47 },
   { "is_solid",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, is_solid),
     0,0,0, 290 },
   { "sweep_alignment_flags",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, sweep_alignment_flags),
     0,0,0, 70 },
   { "path_flags",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, path_flags),
     0,0,0, 71 },
   { "align_start",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, align_start),
     0,0,0, 292 },
   { "bank",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, bank),
     0,0,0, 293 },
   { "base_point_set",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, base_point_set),
     0,0,0, 294 },
   { "sweep_entity_transform_computed",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, sweep_entity_transform_computed),
     0,0,0, 295 },
   { "path_entity_transform_computed",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, path_entity_transform_computed),
     0,0,0, 296 },
   { "reference_vector_for_controlling_twist",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, reference_vector_for_controlling_twist),
     1,0,0, 11 },
   { "sweep_entity",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, sweep_entity),
     1,0,0, 0 },
   { "path_entity",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, path_entity),
     1,0,0, 0 },
   { "sweep_vector",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, sweep_vector),
     1,0,0, 10 },
   { "sweep_transmatrix",	"BD*", sizeof (BITCODE_BD*),  OFF (struct _dwg_entity_EXTRUDEDSURFACE, sweep_transmatrix),
     1,1,0, 40 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_entity_FLIPGRIPENTITY: (sorted by offset) */
@@ -2339,119 +2339,119 @@ static const Dwg_DYNAPI_field _dwg_LOAD_fields[] = {
   { "parent",	"struct _dwg_object_entity*", sizeof (void *),  OFF (struct _dwg_entity_LOAD, parent),
     1,1,0, 0 },
   { "file_name",	"TV", sizeof (BITCODE_TV),  OFF (struct _dwg_entity_LOAD, file_name),
     1,1,1, 1 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_entity_LOFTEDSURFACE: (sorted by offset) */
 static const Dwg_DYNAPI_field _dwg_LOFTEDSURFACE_fields[] = {
   { "parent",	"struct _dwg_object_entity*", sizeof (void *),  OFF (struct _dwg_entity_LOFTEDSURFACE, parent),
     1,1,0, 0 },
   { "acis_empty",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_LOFTEDSURFACE, acis_empty),
     0,0,0, 290 },
   { "unknown",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_LOFTEDSURFACE, unknown),
     0,0,0, 0 },
   { "version",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_LOFTEDSURFACE, version),
     0,0,0, 70 },
   { "num_blocks",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_LOFTEDSURFACE, num_blocks),
     0,0,0, 0 },
   { "block_size",	"BL*", sizeof (BITCODE_BL*),  OFF (struct _dwg_entity_LOFTEDSURFACE, block_size),
     1,1,0, 0 },
   { "encr_sat_data",	"char **", sizeof (char **),  OFF (struct _dwg_entity_LOFTEDSURFACE, encr_sat_data),
     1,1,0, 1 },
   { "sab_size",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_LOFTEDSURFACE, sab_size),
     0,0,0, 0 },
   { "acis_data",	"RC*", sizeof (BITCODE_RC*),  OFF (struct _dwg_entity_LOFTEDSURFACE, acis_data),
     1,1,0, 0 },
   { "wireframe_data_present",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_LOFTEDSURFACE, wireframe_data_present),
     0,0,0, 0 },
   { "point_present",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_LOFTEDSURFACE, point_present),
     0,0,0, 0 },
   { "point",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_entity_LOFTEDSURFACE, point),
     1,0,0, 0 },
   { "isolines",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_LOFTEDSURFACE, isolines),
     0,0,0, 0 },
   { "isoline_present",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_LOFTEDSURFACE, isoline_present),
     0,0,0, 0 },
   { "num_wires",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_LOFTEDSURFACE, num_wires),
     0,0,0, 0 },
   { "wires",	"Dwg_3DSOLID_wire*", sizeof (Dwg_3DSOLID_wire*),  OFF (struct _dwg_entity_LOFTEDSURFACE, wires),
     1,1,0, 0 },
   { "num_silhouettes",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_LOFTEDSURFACE, num_silhouettes),
     0,0,0, 0 },
   { "silhouettes",	"Dwg_3DSOLID_silhouette*", sizeof (Dwg_3DSOLID_silhouette*),  OFF (struct _dwg_entity_LOFTEDSURFACE, silhouettes),
     1,1,0, 0 },
   { "_dxf_sab_converted",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_LOFTEDSURFACE, _dxf_sab_converted),
     0,0,0, 0 },
   { "acis_empty2",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_LOFTEDSURFACE, acis_empty2),
     0,0,0, 0 },
   { "extra_acis_data",	"struct _dwg_entity_3DSOLID*", sizeof (void *),  OFF (struct _dwg_entity_LOFTEDSURFACE, extra_acis_data),
     1,1,0, 0 },
   { "num_materials",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_LOFTEDSURFACE, num_materials),
     0,0,0, 0 },
   { "materials",	"Dwg_3DSOLID_material*", sizeof (Dwg_3DSOLID_material*),  OFF (struct _dwg_entity_LOFTEDSURFACE, materials),
     1,1,0, 0 },
-  { "revision_guid[39]",	"RC", 39 * sizeof (BITCODE_RC),  OFF (struct _dwg_entity_LOFTEDSURFACE, revision_guid),
+  { "revision_guid",	"RC", 39 * sizeof (BITCODE_RC),  OFF (struct _dwg_entity_LOFTEDSURFACE, revision_guid),
     0,0,0, 2 },
   { "revision_major",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_LOFTEDSURFACE, revision_major),
     0,0,0, 0 },
   { "revision_minor1",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_LOFTEDSURFACE, revision_minor1),
     0,0,0, 0 },
   { "revision_minor2",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_LOFTEDSURFACE, revision_minor2),
     0,0,0, 0 },
-  { "revision_bytes[9]",	"RC", 9 * sizeof (BITCODE_RC),  OFF (struct _dwg_entity_LOFTEDSURFACE, revision_bytes),
+  { "revision_bytes",	"RC", 9 * sizeof (BITCODE_RC),  OFF (struct _dwg_entity_LOFTEDSURFACE, revision_bytes),
     0,0,0, 0 },
   { "end_marker",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_LOFTEDSURFACE, end_marker),
     0,0,0, 0 },
   { "history_id",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_entity_LOFTEDSURFACE, history_id),
     1,0,0, 350 },
   { "has_revision_guid",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_LOFTEDSURFACE, has_revision_guid),
     0,0,0, 0 },
   { "acis_empty_bit",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_LOFTEDSURFACE, acis_empty_bit),
     0,0,0, 0 },
   { "modeler_format_version",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_LOFTEDSURFACE, modeler_format_version),
     0,0,0, 70 },
   { "u_isolines",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_LOFTEDSURFACE, u_isolines),
     0,0,0, 71 },
   { "v_isolines",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_LOFTEDSURFACE, v_isolines),
     0,0,0, 72 },
   { "loft_entity_transmatrix",	"BD*", sizeof (BITCODE_BD*),  OFF (struct _dwg_entity_LOFTEDSURFACE, loft_entity_transmatrix),
     1,1,0, 40 },
   { "plane_normal_lofting_type",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_LOFTEDSURFACE, plane_normal_lofting_type),
     0,0,0, 70 },
   { "start_draft_angle",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_entity_LOFTEDSURFACE, start_draft_angle),
     0,0,0, 41 },
   { "end_draft_angle",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_entity_LOFTEDSURFACE, end_draft_angle),
     0,0,0, 42 },
   { "start_draft_magnitude",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_entity_LOFTEDSURFACE, start_draft_magnitude),
     0,0,0, 43 },
   { "end_draft_magnitude",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_entity_LOFTEDSURFACE, end_draft_magnitude),
     0,0,0, 44 },
   { "arc_length_parameterization",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_LOFTEDSURFACE, arc_length_parameterization),
     0,0,0, 290 },
   { "no_twist",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_LOFTEDSURFACE, no_twist),
     0,0,0, 291 },
   { "align_direction",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_LOFTEDSURFACE, align_direction),
     0,0,0, 292 },
   { "simple_surfaces",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_LOFTEDSURFACE, simple_surfaces),
     0,0,0, 293 },
   { "closed_surfaces",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_LOFTEDSURFACE, closed_surfaces),
     0,0,0, 294 },
   { "solid",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_LOFTEDSURFACE, solid),
     0,0,0, 295 },
   { "ruled_surface",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_LOFTEDSURFACE, ruled_surface),
     0,0,0, 296 },
   { "virtual_guide",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_LOFTEDSURFACE, virtual_guide),
     0,0,0, 297 },
   { "num_cross_sections",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_LOFTEDSURFACE, num_cross_sections),
     0,0,0, 0 },
   { "num_guide_curves",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_LOFTEDSURFACE, num_guide_curves),
     0,0,0, 0 },
   { "cross_sections",	"H*", sizeof (BITCODE_H*),  OFF (struct _dwg_entity_LOFTEDSURFACE, cross_sections),
     1,1,0, 310 },
   { "guide_curves",	"H*", sizeof (BITCODE_H*),  OFF (struct _dwg_entity_LOFTEDSURFACE, guide_curves),
     1,1,0, 310 },
   { "path_curve",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_entity_LOFTEDSURFACE, path_curve),
     1,0,0, 0 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_entity_LWPOLYLINE: (sorted by offset) */
@@ -2795,97 +2795,97 @@ static const Dwg_DYNAPI_field _dwg_NAVISWORKSMODEL_fields[] = {
   { "parent",	"struct _dwg_object_entity*", sizeof (void *),  OFF (struct _dwg_entity_NAVISWORKSMODEL, parent),
     1,1,0, 0 },
   { "flags",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_NAVISWORKSMODEL, flags),
     0,0,0, 70 },
   { "definition",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_entity_NAVISWORKSMODEL, definition),
     1,0,0, 340 },
   { "transmatrix",	"BD*", sizeof (BITCODE_BD*),  OFF (struct _dwg_entity_NAVISWORKSMODEL, transmatrix),
     1,1,0, 40 },
   { "unitfactor",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_entity_NAVISWORKSMODEL, unitfactor),
     0,0,0, 40 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_entity_NURBSURFACE: (sorted by offset) */
 static const Dwg_DYNAPI_field _dwg_NURBSURFACE_fields[] = {
   { "parent",	"struct _dwg_object_entity*", sizeof (void *),  OFF (struct _dwg_entity_NURBSURFACE, parent),
     1,1,0, 0 },
   { "acis_empty",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_NURBSURFACE, acis_empty),
     0,0,0, 290 },
   { "unknown",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_NURBSURFACE, unknown),
     0,0,0, 0 },
   { "version",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_NURBSURFACE, version),
     0,0,0, 70 },
   { "num_blocks",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_NURBSURFACE, num_blocks),
     0,0,0, 0 },
   { "block_size",	"BL*", sizeof (BITCODE_BL*),  OFF (struct _dwg_entity_NURBSURFACE, block_size),
     1,1,0, 0 },
   { "encr_sat_data",	"char **", sizeof (char **),  OFF (struct _dwg_entity_NURBSURFACE, encr_sat_data),
     1,1,0, 1 },
   { "sab_size",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_NURBSURFACE, sab_size),
     0,0,0, 0 },
   { "acis_data",	"RC*", sizeof (BITCODE_RC*),  OFF (struct _dwg_entity_NURBSURFACE, acis_data),
     1,1,0, 0 },
   { "wireframe_data_present",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_NURBSURFACE, wireframe_data_present),
     0,0,0, 0 },
   { "point_present",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_NURBSURFACE, point_present),
     0,0,0, 0 },
   { "point",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_entity_NURBSURFACE, point),
     1,0,0, 0 },
   { "isolines",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_NURBSURFACE, isolines),
     0,0,0, 0 },
   { "isoline_present",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_NURBSURFACE, isoline_present),
     0,0,0, 0 },
   { "num_wires",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_NURBSURFACE, num_wires),
     0,0,0, 0 },
   { "wires",	"Dwg_3DSOLID_wire*", sizeof (Dwg_3DSOLID_wire*),  OFF (struct _dwg_entity_NURBSURFACE, wires),
     1,1,0, 0 },
   { "num_silhouettes",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_NURBSURFACE, num_silhouettes),
     0,0,0, 0 },
   { "silhouettes",	"Dwg_3DSOLID_silhouette*", sizeof (Dwg_3DSOLID_silhouette*),  OFF (struct _dwg_entity_NURBSURFACE, silhouettes),
     1,1,0, 0 },
   { "_dxf_sab_converted",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_NURBSURFACE, _dxf_sab_converted),
     0,0,0, 0 },
   { "acis_empty2",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_NURBSURFACE, acis_empty2),
     0,0,0, 0 },
   { "extra_acis_data",	"struct _dwg_entity_3DSOLID*", sizeof (void *),  OFF (struct _dwg_entity_NURBSURFACE, extra_acis_data),
     1,1,0, 0 },
   { "num_materials",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_NURBSURFACE, num_materials),
     0,0,0, 0 },
   { "materials",	"Dwg_3DSOLID_material*", sizeof (Dwg_3DSOLID_material*),  OFF (struct _dwg_entity_NURBSURFACE, materials),
     1,1,0, 0 },
-  { "revision_guid[39]",	"RC", 39 * sizeof (BITCODE_RC),  OFF (struct _dwg_entity_NURBSURFACE, revision_guid),
+  { "revision_guid",	"RC", 39 * sizeof (BITCODE_RC),  OFF (struct _dwg_entity_NURBSURFACE, revision_guid),
     0,0,0, 2 },
   { "revision_major",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_NURBSURFACE, revision_major),
     0,0,0, 0 },
   { "revision_minor1",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_NURBSURFACE, revision_minor1),
     0,0,0, 0 },
   { "revision_minor2",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_NURBSURFACE, revision_minor2),
     0,0,0, 0 },
-  { "revision_bytes[9]",	"RC", 9 * sizeof (BITCODE_RC),  OFF (struct _dwg_entity_NURBSURFACE, revision_bytes),
+  { "revision_bytes",	"RC", 9 * sizeof (BITCODE_RC),  OFF (struct _dwg_entity_NURBSURFACE, revision_bytes),
     0,0,0, 0 },
   { "end_marker",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_NURBSURFACE, end_marker),
     0,0,0, 0 },
   { "history_id",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_entity_NURBSURFACE, history_id),
     1,0,0, 350 },
   { "has_revision_guid",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_NURBSURFACE, has_revision_guid),
     0,0,0, 0 },
   { "acis_empty_bit",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_NURBSURFACE, acis_empty_bit),
     0,0,0, 0 },
   { "u_isolines",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_NURBSURFACE, u_isolines),
     0,0,0, 71 },
   { "v_isolines",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_NURBSURFACE, v_isolines),
     0,0,0, 72 },
   { "short170",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_NURBSURFACE, short170),
     0,0,0, 170 },
   { "cv_hull_display",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_NURBSURFACE, cv_hull_display),
     0,0,0, 290 },
   { "uvec1",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_entity_NURBSURFACE, uvec1),
     1,0,0, 10 },
   { "vvec1",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_entity_NURBSURFACE, vvec1),
     1,0,0, 11 },
   { "uvec2",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_entity_NURBSURFACE, uvec2),
     1,0,0, 12 },
   { "vvec2",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_entity_NURBSURFACE, vvec2),
     1,0,0, 13 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_entity_OLE2FRAME: (sorted by offset) */
@@ -2917,89 +2917,89 @@ static const Dwg_DYNAPI_field _dwg_OLEFRAME_fields[] = {
   { "parent",	"struct _dwg_object_entity*", sizeof (void *),  OFF (struct _dwg_entity_OLEFRAME, parent),
     1,1,0, 0 },
   { "flag",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_OLEFRAME, flag),
     0,0,0, 70 },
   { "mode",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_OLEFRAME, mode),
     0,0,0, 0 },
   { "data_size",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_OLEFRAME, data_size),
     0,0,0, 90 },
   { "data",	"TF", sizeof (BITCODE_TF),  OFF (struct _dwg_entity_OLEFRAME, data),
     1,1,0, 310 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_entity_PLANESURFACE: (sorted by offset) */
 static const Dwg_DYNAPI_field _dwg_PLANESURFACE_fields[] = {
   { "parent",	"struct _dwg_object_entity*", sizeof (void *),  OFF (struct _dwg_entity_PLANESURFACE, parent),
     1,1,0, 0 },
   { "acis_empty",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_PLANESURFACE, acis_empty),
     0,0,0, 290 },
   { "unknown",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_PLANESURFACE, unknown),
     0,0,0, 0 },
   { "version",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_PLANESURFACE, version),
     0,0,0, 70 },
   { "num_blocks",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_PLANESURFACE, num_blocks),
     0,0,0, 0 },
   { "block_size",	"BL*", sizeof (BITCODE_BL*),  OFF (struct _dwg_entity_PLANESURFACE, block_size),
     1,1,0, 0 },
   { "encr_sat_data",	"char **", sizeof (char **),  OFF (struct _dwg_entity_PLANESURFACE, encr_sat_data),
     1,1,0, 1 },
   { "sab_size",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_PLANESURFACE, sab_size),
     0,0,0, 0 },
   { "acis_data",	"RC*", sizeof (BITCODE_RC*),  OFF (struct _dwg_entity_PLANESURFACE, acis_data),
     1,1,0, 0 },
   { "wireframe_data_present",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_PLANESURFACE, wireframe_data_present),
     0,0,0, 0 },
   { "point_present",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_PLANESURFACE, point_present),
     0,0,0, 0 },
   { "point",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_entity_PLANESURFACE, point),
     1,0,0, 0 },
   { "isolines",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_PLANESURFACE, isolines),
     0,0,0, 0 },
   { "isoline_present",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_PLANESURFACE, isoline_present),
     0,0,0, 0 },
   { "num_wires",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_PLANESURFACE, num_wires),
     0,0,0, 0 },
   { "wires",	"Dwg_3DSOLID_wire*", sizeof (Dwg_3DSOLID_wire*),  OFF (struct _dwg_entity_PLANESURFACE, wires),
     1,1,0, 0 },
   { "num_silhouettes",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_PLANESURFACE, num_silhouettes),
     0,0,0, 0 },
   { "silhouettes",	"Dwg_3DSOLID_silhouette*", sizeof (Dwg_3DSOLID_silhouette*),  OFF (struct _dwg_entity_PLANESURFACE, silhouettes),
     1,1,0, 0 },
   { "_dxf_sab_converted",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_PLANESURFACE, _dxf_sab_converted),
     0,0,0, 0 },
   { "acis_empty2",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_PLANESURFACE, acis_empty2),
     0,0,0, 0 },
   { "extra_acis_data",	"struct _dwg_entity_3DSOLID*", sizeof (void *),  OFF (struct _dwg_entity_PLANESURFACE, extra_acis_data),
     1,1,0, 0 },
   { "num_materials",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_PLANESURFACE, num_materials),
     0,0,0, 0 },
   { "materials",	"Dwg_3DSOLID_material*", sizeof (Dwg_3DSOLID_material*),  OFF (struct _dwg_entity_PLANESURFACE, materials),
     1,1,0, 0 },
-  { "revision_guid[39]",	"RC", 39 * sizeof (BITCODE_RC),  OFF (struct _dwg_entity_PLANESURFACE, revision_guid),
+  { "revision_guid",	"RC", 39 * sizeof (BITCODE_RC),  OFF (struct _dwg_entity_PLANESURFACE, revision_guid),
     0,0,0, 2 },
   { "revision_major",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_PLANESURFACE, revision_major),
     0,0,0, 0 },
   { "revision_minor1",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_PLANESURFACE, revision_minor1),
     0,0,0, 0 },
   { "revision_minor2",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_PLANESURFACE, revision_minor2),
     0,0,0, 0 },
-  { "revision_bytes[9]",	"RC", 9 * sizeof (BITCODE_RC),  OFF (struct _dwg_entity_PLANESURFACE, revision_bytes),
+  { "revision_bytes",	"RC", 9 * sizeof (BITCODE_RC),  OFF (struct _dwg_entity_PLANESURFACE, revision_bytes),
     0,0,0, 0 },
   { "end_marker",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_PLANESURFACE, end_marker),
     0,0,0, 0 },
   { "history_id",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_entity_PLANESURFACE, history_id),
     1,0,0, 350 },
   { "has_revision_guid",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_PLANESURFACE, has_revision_guid),
     0,0,0, 0 },
   { "acis_empty_bit",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_PLANESURFACE, acis_empty_bit),
     0,0,0, 0 },
   { "modeler_format_version",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_PLANESURFACE, modeler_format_version),
     0,0,0, 70 },
   { "u_isolines",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_PLANESURFACE, u_isolines),
     0,0,0, 71 },
   { "v_isolines",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_PLANESURFACE, v_isolines),
     0,0,0, 72 },
   { "class_version",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_PLANESURFACE, class_version),
     0,0,0, 0 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_entity_POINT: (sorted by offset) */
@@ -3307,105 +3307,105 @@ static const Dwg_DYNAPI_field _dwg_REPEAT_fields[] = {
   { "parent",	"struct _dwg_object_entity*", sizeof (void *),  OFF (struct _dwg_entity_REPEAT, parent),
     1,1,0, 0 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_entity_REVOLVEDSURFACE: (sorted by offset) */
 static const Dwg_DYNAPI_field _dwg_REVOLVEDSURFACE_fields[] = {
   { "parent",	"struct _dwg_object_entity*", sizeof (void *),  OFF (struct _dwg_entity_REVOLVEDSURFACE, parent),
     1,1,0, 0 },
   { "acis_empty",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_REVOLVEDSURFACE, acis_empty),
     0,0,0, 290 },
   { "unknown",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_REVOLVEDSURFACE, unknown),
     0,0,0, 0 },
   { "version",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_REVOLVEDSURFACE, version),
     0,0,0, 70 },
   { "num_blocks",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_REVOLVEDSURFACE, num_blocks),
     0,0,0, 0 },
   { "block_size",	"BL*", sizeof (BITCODE_BL*),  OFF (struct _dwg_entity_REVOLVEDSURFACE, block_size),
     1,1,0, 0 },
   { "encr_sat_data",	"char **", sizeof (char **),  OFF (struct _dwg_entity_REVOLVEDSURFACE, encr_sat_data),
     1,1,0, 1 },
   { "sab_size",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_REVOLVEDSURFACE, sab_size),
     0,0,0, 0 },
   { "acis_data",	"RC*", sizeof (BITCODE_RC*),  OFF (struct _dwg_entity_REVOLVEDSURFACE, acis_data),
     1,1,0, 0 },
   { "wireframe_data_present",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_REVOLVEDSURFACE, wireframe_data_present),
     0,0,0, 0 },
   { "point_present",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_REVOLVEDSURFACE, point_present),
     0,0,0, 0 },
   { "point",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_entity_REVOLVEDSURFACE, point),
     1,0,0, 0 },
   { "isolines",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_REVOLVEDSURFACE, isolines),
     0,0,0, 0 },
   { "isoline_present",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_REVOLVEDSURFACE, isoline_present),
     0,0,0, 0 },
   { "num_wires",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_REVOLVEDSURFACE, num_wires),
     0,0,0, 0 },
   { "wires",	"Dwg_3DSOLID_wire*", sizeof (Dwg_3DSOLID_wire*),  OFF (struct _dwg_entity_REVOLVEDSURFACE, wires),
     1,1,0, 0 },
   { "num_silhouettes",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_REVOLVEDSURFACE, num_silhouettes),
     0,0,0, 0 },
   { "silhouettes",	"Dwg_3DSOLID_silhouette*", sizeof (Dwg_3DSOLID_silhouette*),  OFF (struct _dwg_entity_REVOLVEDSURFACE, silhouettes),
     1,1,0, 0 },
   { "_dxf_sab_converted",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_REVOLVEDSURFACE, _dxf_sab_converted),
     0,0,0, 0 },
   { "acis_empty2",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_REVOLVEDSURFACE, acis_empty2),
     0,0,0, 0 },
   { "extra_acis_data",	"struct _dwg_entity_3DSOLID*", sizeof (void *),  OFF (struct _dwg_entity_REVOLVEDSURFACE, extra_acis_data),
     1,1,0, 0 },
   { "num_materials",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_REVOLVEDSURFACE, num_materials),
     0,0,0, 0 },
   { "materials",	"Dwg_3DSOLID_material*", sizeof (Dwg_3DSOLID_material*),  OFF (struct _dwg_entity_REVOLVEDSURFACE, materials),
     1,1,0, 0 },
-  { "revision_guid[39]",	"RC", 39 * sizeof (BITCODE_RC),  OFF (struct _dwg_entity_REVOLVEDSURFACE, revision_guid),
+  { "revision_guid",	"RC", 39 * sizeof (BITCODE_RC),  OFF (struct _dwg_entity_REVOLVEDSURFACE, revision_guid),
     0,0,0, 2 },
   { "revision_major",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_REVOLVEDSURFACE, revision_major),
     0,0,0, 0 },
   { "revision_minor1",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_REVOLVEDSURFACE, revision_minor1),
     0,0,0, 0 },
   { "revision_minor2",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_REVOLVEDSURFACE, revision_minor2),
     0,0,0, 0 },
-  { "revision_bytes[9]",	"RC", 9 * sizeof (BITCODE_RC),  OFF (struct _dwg_entity_REVOLVEDSURFACE, revision_bytes),
+  { "revision_bytes",	"RC", 9 * sizeof (BITCODE_RC),  OFF (struct _dwg_entity_REVOLVEDSURFACE, revision_bytes),
     0,0,0, 0 },
   { "end_marker",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_REVOLVEDSURFACE, end_marker),
     0,0,0, 0 },
   { "history_id",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_entity_REVOLVEDSURFACE, history_id),
     1,0,0, 350 },
   { "has_revision_guid",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_REVOLVEDSURFACE, has_revision_guid),
     0,0,0, 0 },
   { "acis_empty_bit",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_REVOLVEDSURFACE, acis_empty_bit),
     0,0,0, 0 },
   { "modeler_format_version",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_REVOLVEDSURFACE, modeler_format_version),
     0,0,0, 70 },
   { "u_isolines",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_REVOLVEDSURFACE, u_isolines),
     0,0,0, 71 },
   { "v_isolines",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_REVOLVEDSURFACE, v_isolines),
     0,0,0, 72 },
   { "class_version",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_REVOLVEDSURFACE, class_version),
     0,0,0, 90 },
   { "id",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_REVOLVEDSURFACE, id),
     0,0,0, 90 },
   { "axis_point",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_entity_REVOLVEDSURFACE, axis_point),
     1,0,0, 10 },
   { "axis_vector",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_entity_REVOLVEDSURFACE, axis_vector),
     1,0,0, 11 },
   { "revolve_angle",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_entity_REVOLVEDSURFACE, revolve_angle),
     0,0,0, 40 },
   { "start_angle",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_entity_REVOLVEDSURFACE, start_angle),
     0,0,0, 41 },
   { "revolved_entity_transmatrix",	"BD*", sizeof (BITCODE_BD*),  OFF (struct _dwg_entity_REVOLVEDSURFACE, revolved_entity_transmatrix),
     1,1,0, 42 },
   { "draft_angle",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_entity_REVOLVEDSURFACE, draft_angle),
     0,0,0, 43 },
   { "draft_start_distance",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_entity_REVOLVEDSURFACE, draft_start_distance),
     0,0,0, 44 },
   { "draft_end_distance",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_entity_REVOLVEDSURFACE, draft_end_distance),
     0,0,0, 45 },
   { "twist_angle",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_entity_REVOLVEDSURFACE, twist_angle),
     0,0,0, 46 },
   { "solid",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_REVOLVEDSURFACE, solid),
     0,0,0, 290 },
   { "close_to_axis",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_REVOLVEDSURFACE, close_to_axis),
     0,0,0, 291 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_entity_ROTATIONGRIPENTITY: (sorted by offset) */
@@ -3529,171 +3529,171 @@ static const Dwg_DYNAPI_field _dwg_SPLINE_fields[] = {
   { "parent",	"struct _dwg_object_entity*", sizeof (void *),  OFF (struct _dwg_entity_SPLINE, parent),
     1,1,0, 0 },
   { "flag",	"RS", sizeof (BITCODE_RS),  OFF (struct _dwg_entity_SPLINE, flag),
     0,0,0, 0 },
   { "scenario",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_SPLINE, scenario),
     0,0,0, 0 },
   { "degree",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_SPLINE, degree),
     0,0,0, 71 },
   { "splineflags",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_SPLINE, splineflags),
     0,0,0, 0 },
   { "knotparam",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_SPLINE, knotparam),
     0,0,0, 0 },
   { "fit_tol",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_entity_SPLINE, fit_tol),
     0,0,0, 44 },
   { "beg_tan_vec",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_entity_SPLINE, beg_tan_vec),
     1,0,0, 12 },
   { "end_tan_vec",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_entity_SPLINE, end_tan_vec),
     1,0,0, 13 },
   { "closed_b",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_SPLINE, closed_b),
     0,0,0, 0 },
   { "periodic",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_SPLINE, periodic),
     0,0,0, 0 },
   { "rational",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_SPLINE, rational),
     0,0,0, 0 },
   { "weighted",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_SPLINE, weighted),
     0,0,0, 0 },
   { "knot_tol",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_entity_SPLINE, knot_tol),
     0,0,0, 42 },
   { "ctrl_tol",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_entity_SPLINE, ctrl_tol),
     0,0,0, 43 },
   { "num_fit_pts",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_SPLINE, num_fit_pts),
     0,0,0, 74 },
   { "fit_pts",	"3DPOINT*", sizeof (BITCODE_3DPOINT*),  OFF (struct _dwg_entity_SPLINE, fit_pts),
     1,1,0, 11 },
   { "num_knots",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_SPLINE, num_knots),
     0,0,0, 72 },
   { "knots",	"BD*", sizeof (BITCODE_BD*),  OFF (struct _dwg_entity_SPLINE, knots),
     1,1,0, 40 },
   { "num_ctrl_pts",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_SPLINE, num_ctrl_pts),
     0,0,0, 73 },
   { "ctrl_pts",	"Dwg_SPLINE_control_point*", sizeof (Dwg_SPLINE_control_point*),  OFF (struct _dwg_entity_SPLINE, ctrl_pts),
     1,1,0, 0 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_entity_SWEPTSURFACE: (sorted by offset) */
 static const Dwg_DYNAPI_field _dwg_SWEPTSURFACE_fields[] = {
   { "parent",	"struct _dwg_object_entity*", sizeof (void *),  OFF (struct _dwg_entity_SWEPTSURFACE, parent),
     1,1,0, 0 },
   { "acis_empty",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_SWEPTSURFACE, acis_empty),
     0,0,0, 290 },
   { "unknown",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_SWEPTSURFACE, unknown),
     0,0,0, 0 },
   { "version",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_SWEPTSURFACE, version),
     0,0,0, 70 },
   { "num_blocks",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_SWEPTSURFACE, num_blocks),
     0,0,0, 0 },
   { "block_size",	"BL*", sizeof (BITCODE_BL*),  OFF (struct _dwg_entity_SWEPTSURFACE, block_size),
     1,1,0, 0 },
   { "encr_sat_data",	"char **", sizeof (char **),  OFF (struct _dwg_entity_SWEPTSURFACE, encr_sat_data),
     1,1,0, 1 },
   { "sab_size",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_SWEPTSURFACE, sab_size),
     0,0,0, 0 },
   { "acis_data",	"RC*", sizeof (BITCODE_RC*),  OFF (struct _dwg_entity_SWEPTSURFACE, acis_data),
     1,1,0, 0 },
   { "wireframe_data_present",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_SWEPTSURFACE, wireframe_data_present),
     0,0,0, 0 },
   { "point_present",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_SWEPTSURFACE, point_present),
     0,0,0, 0 },
   { "point",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_entity_SWEPTSURFACE, point),
     1,0,0, 0 },
   { "isolines",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_SWEPTSURFACE, isolines),
     0,0,0, 0 },
   { "isoline_present",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_SWEPTSURFACE, isoline_present),
     0,0,0, 0 },
   { "num_wires",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_SWEPTSURFACE, num_wires),
     0,0,0, 0 },
   { "wires",	"Dwg_3DSOLID_wire*", sizeof (Dwg_3DSOLID_wire*),  OFF (struct _dwg_entity_SWEPTSURFACE, wires),
     1,1,0, 0 },
   { "num_silhouettes",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_SWEPTSURFACE, num_silhouettes),
     0,0,0, 0 },
   { "silhouettes",	"Dwg_3DSOLID_silhouette*", sizeof (Dwg_3DSOLID_silhouette*),  OFF (struct _dwg_entity_SWEPTSURFACE, silhouettes),
     1,1,0, 0 },
   { "_dxf_sab_converted",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_SWEPTSURFACE, _dxf_sab_converted),
     0,0,0, 0 },
   { "acis_empty2",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_SWEPTSURFACE, acis_empty2),
     0,0,0, 0 },
   { "extra_acis_data",	"struct _dwg_entity_3DSOLID*", sizeof (void *),  OFF (struct _dwg_entity_SWEPTSURFACE, extra_acis_data),
     1,1,0, 0 },
   { "num_materials",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_SWEPTSURFACE, num_materials),
     0,0,0, 0 },
   { "materials",	"Dwg_3DSOLID_material*", sizeof (Dwg_3DSOLID_material*),  OFF (struct _dwg_entity_SWEPTSURFACE, materials),
     1,1,0, 0 },
-  { "revision_guid[39]",	"RC", 39 * sizeof (BITCODE_RC),  OFF (struct _dwg_entity_SWEPTSURFACE, revision_guid),
+  { "revision_guid",	"RC", 39 * sizeof (BITCODE_RC),  OFF (struct _dwg_entity_SWEPTSURFACE, revision_guid),
     0,0,0, 2 },
   { "revision_major",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_SWEPTSURFACE, revision_major),
     0,0,0, 0 },
   { "revision_minor1",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_SWEPTSURFACE, revision_minor1),
     0,0,0, 0 },
   { "revision_minor2",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_SWEPTSURFACE, revision_minor2),
     0,0,0, 0 },
-  { "revision_bytes[9]",	"RC", 9 * sizeof (BITCODE_RC),  OFF (struct _dwg_entity_SWEPTSURFACE, revision_bytes),
+  { "revision_bytes",	"RC", 9 * sizeof (BITCODE_RC),  OFF (struct _dwg_entity_SWEPTSURFACE, revision_bytes),
     0,0,0, 0 },
   { "end_marker",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_SWEPTSURFACE, end_marker),
     0,0,0, 0 },
   { "history_id",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_entity_SWEPTSURFACE, history_id),
     1,0,0, 350 },
   { "has_revision_guid",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_SWEPTSURFACE, has_revision_guid),
     0,0,0, 0 },
   { "acis_empty_bit",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_SWEPTSURFACE, acis_empty_bit),
     0,0,0, 0 },
   { "modeler_format_version",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_SWEPTSURFACE, modeler_format_version),
     0,0,0, 70 },
   { "u_isolines",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_SWEPTSURFACE, u_isolines),
     0,0,0, 71 },
   { "v_isolines",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_SWEPTSURFACE, v_isolines),
     0,0,0, 72 },
   { "class_version",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_SWEPTSURFACE, class_version),
     0,0,0, 90 },
   { "sweep_entity_id",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_SWEPTSURFACE, sweep_entity_id),
     0,0,0, 90 },
   { "sweepdata_size",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_SWEPTSURFACE, sweepdata_size),
     0,0,0, 90 },
   { "sweepdata",	"TF", sizeof (BITCODE_TF),  OFF (struct _dwg_entity_SWEPTSURFACE, sweepdata),
     1,1,0, 310 },
   { "path_entity_id",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_SWEPTSURFACE, path_entity_id),
     0,0,0, 90 },
   { "pathdata_size",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_entity_SWEPTSURFACE, pathdata_size),
     0,0,0, 90 },
   { "pathdata",	"TF", sizeof (BITCODE_TF),  OFF (struct _dwg_entity_SWEPTSURFACE, pathdata),
     1,1,0, 310 },
   { "draft_angle",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_entity_SWEPTSURFACE, draft_angle),
     0,0,0, 42 },
   { "draft_start_distance",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_entity_SWEPTSURFACE, draft_start_distance),
     0,0,0, 43 },
   { "draft_end_distance",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_entity_SWEPTSURFACE, draft_end_distance),
     0,0,0, 44 },
   { "twist_angle",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_entity_SWEPTSURFACE, twist_angle),
     0,0,0, 45 },
   { "scale_factor",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_entity_SWEPTSURFACE, scale_factor),
     0,0,0, 48 },
   { "align_angle",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_entity_SWEPTSURFACE, align_angle),
     0,0,0, 49 },
   { "sweep_entity_transmatrix",	"BD*", sizeof (BITCODE_BD*),  OFF (struct _dwg_entity_SWEPTSURFACE, sweep_entity_transmatrix),
     1,1,0, 46 },
   { "path_entity_transmatrix",	"BD*", sizeof (BITCODE_BD*),  OFF (struct _dwg_entity_SWEPTSURFACE, path_entity_transmatrix),
     1,1,0, 47 },
   { "is_solid",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_SWEPTSURFACE, is_solid),
     0,0,0, 290 },
   { "sweep_alignment_flags",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_SWEPTSURFACE, sweep_alignment_flags),
     0,0,0, 70 },
   { "path_flags",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_entity_SWEPTSURFACE, path_flags),
     0,0,0, 71 },
   { "align_start",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_SWEPTSURFACE, align_start),
     0,0,0, 292 },
   { "bank",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_SWEPTSURFACE, bank),
     0,0,0, 293 },
   { "base_point_set",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_SWEPTSURFACE, base_point_set),
     0,0,0, 294 },
   { "sweep_entity_transform_computed",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_SWEPTSURFACE, sweep_entity_transform_computed),
     0,0,0, 295 },
   { "path_entity_transform_computed",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_entity_SWEPTSURFACE, path_entity_transform_computed),
     0,0,0, 296 },
   { "reference_vector_for_controlling_twist",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_entity_SWEPTSURFACE, reference_vector_for_controlling_twist),
     1,0,0, 11 },
   { "sweep_entity",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_entity_SWEPTSURFACE, sweep_entity),
     1,0,0, 0 },
   { "path_entity",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_entity_SWEPTSURFACE, path_entity),
     1,0,0, 0 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_entity_TABLE: (sorted by offset) */
@@ -4069,19 +4069,19 @@ static const Dwg_DYNAPI_field _dwg_VERTEX_3D_fields[] = {
   { "parent",	"struct _dwg_object_entity*", sizeof (void *),  OFF (struct _dwg_entity_VERTEX_3D, parent),
     1,1,0, 0 },
   { "flag",	"RC", sizeof (BITCODE_RC),  OFF (struct _dwg_entity_VERTEX_3D, flag),
     0,0,0, 70 },
   { "point",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_entity_VERTEX_3D, point),
     1,0,0, 10 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_entity_VERTEX_PFACE_FACE: (sorted by offset) */
 static const Dwg_DYNAPI_field _dwg_VERTEX_PFACE_FACE_fields[] = {
   { "parent",	"struct _dwg_object_entity*", sizeof (void *),  OFF (struct _dwg_entity_VERTEX_PFACE_FACE, parent),
     1,1,0, 0 },
   { "flag",	"RC", sizeof (BITCODE_RC),  OFF (struct _dwg_entity_VERTEX_PFACE_FACE, flag),
     0,0,0, 70 },
-  { "vertind[4]",	"BS", 4 * sizeof (BITCODE_BS),  OFF (struct _dwg_entity_VERTEX_PFACE_FACE, vertind),
-    0,0,0, 0 },
+  { "vertind",	"BS", 4 * sizeof (BITCODE_BS),  OFF (struct _dwg_entity_VERTEX_PFACE_FACE, vertind),
+    0,0,0, 71 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_entity_VIEWPORT: (sorted by offset) */
@@ -4292,95 +4292,95 @@ static const Dwg_DYNAPI_field _dwg_ACSH_BOX_CLASS_fields[] = {
   { "parent",	"struct _dwg_object_object*", sizeof (void *),  OFF (struct _dwg_object_ACSH_BOX_CLASS, parent),
     1,1,0, 0 },
   { "evalexpr",	"Dwg_EvalExpr", sizeof (Dwg_EvalExpr),  OFF (struct _dwg_object_ACSH_BOX_CLASS, evalexpr),
     0,0,0, 0 },
   { "history_node",	"Dwg_ACSH_HistoryNode", sizeof (Dwg_ACSH_HistoryNode),  OFF (struct _dwg_object_ACSH_BOX_CLASS, history_node),
     0,0,0, 0 },
   { "major",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ACSH_BOX_CLASS, major),
     0,0,0, 90 },
   { "minor",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ACSH_BOX_CLASS, minor),
     0,0,0, 91 },
   { "length",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_object_ACSH_BOX_CLASS, length),
     0,0,0, 40 },
   { "width",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_object_ACSH_BOX_CLASS, width),
     0,0,0, 41 },
   { "height",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_object_ACSH_BOX_CLASS, height),
     0,0,0, 42 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_object_ACSH_BREP_CLASS: (sorted by offset) */
 static const Dwg_DYNAPI_field _dwg_ACSH_BREP_CLASS_fields[] = {
   { "parent",	"struct _dwg_object_object*", sizeof (void *),  OFF (struct _dwg_object_ACSH_BREP_CLASS, parent),
     1,1,0, 0 },
   { "acis_empty",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_object_ACSH_BREP_CLASS, acis_empty),
     0,0,0, 290 },
   { "unknown",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_object_ACSH_BREP_CLASS, unknown),
     0,0,0, 0 },
   { "version",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_object_ACSH_BREP_CLASS, version),
     0,0,0, 70 },
   { "num_blocks",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ACSH_BREP_CLASS, num_blocks),
     0,0,0, 0 },
   { "block_size",	"BL*", sizeof (BITCODE_BL*),  OFF (struct _dwg_object_ACSH_BREP_CLASS, block_size),
     1,1,0, 0 },
   { "encr_sat_data",	"char **", sizeof (char **),  OFF (struct _dwg_object_ACSH_BREP_CLASS, encr_sat_data),
     1,1,0, 1 },
   { "sab_size",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ACSH_BREP_CLASS, sab_size),
     0,0,0, 0 },
   { "acis_data",	"RC*", sizeof (BITCODE_RC*),  OFF (struct _dwg_object_ACSH_BREP_CLASS, acis_data),
     1,1,0, 0 },
   { "wireframe_data_present",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_object_ACSH_BREP_CLASS, wireframe_data_present),
     0,0,0, 0 },
   { "point_present",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_object_ACSH_BREP_CLASS, point_present),
     0,0,0, 0 },
   { "point",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_object_ACSH_BREP_CLASS, point),
     1,0,0, 0 },
   { "isolines",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ACSH_BREP_CLASS, isolines),
     0,0,0, 0 },
   { "isoline_present",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_object_ACSH_BREP_CLASS, isoline_present),
     0,0,0, 0 },
   { "num_wires",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ACSH_BREP_CLASS, num_wires),
     0,0,0, 0 },
   { "wires",	"Dwg_3DSOLID_wire*", sizeof (Dwg_3DSOLID_wire*),  OFF (struct _dwg_object_ACSH_BREP_CLASS, wires),
     1,1,0, 0 },
   { "num_silhouettes",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ACSH_BREP_CLASS, num_silhouettes),
     0,0,0, 0 },
   { "silhouettes",	"Dwg_3DSOLID_silhouette*", sizeof (Dwg_3DSOLID_silhouette*),  OFF (struct _dwg_object_ACSH_BREP_CLASS, silhouettes),
     1,1,0, 0 },
   { "_dxf_sab_converted",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_object_ACSH_BREP_CLASS, _dxf_sab_converted),
     0,0,0, 0 },
   { "acis_empty2",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_object_ACSH_BREP_CLASS, acis_empty2),
     0,0,0, 0 },
   { "extra_acis_data",	"struct _dwg_entity_3DSOLID*", sizeof (void *),  OFF (struct _dwg_object_ACSH_BREP_CLASS, extra_acis_data),
     1,1,0, 0 },
   { "num_materials",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ACSH_BREP_CLASS, num_materials),
     0,0,0, 0 },
   { "materials",	"Dwg_3DSOLID_material*", sizeof (Dwg_3DSOLID_material*),  OFF (struct _dwg_object_ACSH_BREP_CLASS, materials),
     1,1,0, 0 },
-  { "revision_guid[39]",	"RC", 39 * sizeof (BITCODE_RC),  OFF (struct _dwg_object_ACSH_BREP_CLASS, revision_guid),
+  { "revision_guid",	"RC", 39 * sizeof (BITCODE_RC),  OFF (struct _dwg_object_ACSH_BREP_CLASS, revision_guid),
     0,0,0, 2 },
   { "revision_major",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ACSH_BREP_CLASS, revision_major),
     0,0,0, 0 },
   { "revision_minor1",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_object_ACSH_BREP_CLASS, revision_minor1),
     0,0,0, 0 },
   { "revision_minor2",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_object_ACSH_BREP_CLASS, revision_minor2),
     0,0,0, 0 },
-  { "revision_bytes[9]",	"RC", 9 * sizeof (BITCODE_RC),  OFF (struct _dwg_object_ACSH_BREP_CLASS, revision_bytes),
+  { "revision_bytes",	"RC", 9 * sizeof (BITCODE_RC),  OFF (struct _dwg_object_ACSH_BREP_CLASS, revision_bytes),
     0,0,0, 0 },
   { "end_marker",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ACSH_BREP_CLASS, end_marker),
     0,0,0, 0 },
   { "history_id",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_object_ACSH_BREP_CLASS, history_id),
     1,0,0, 350 },
   { "has_revision_guid",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_object_ACSH_BREP_CLASS, has_revision_guid),
     0,0,0, 0 },
   { "acis_empty_bit",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_object_ACSH_BREP_CLASS, acis_empty_bit),
     0,0,0, 0 },
   { "evalexpr",	"Dwg_EvalExpr", sizeof (Dwg_EvalExpr),  OFF (struct _dwg_object_ACSH_BREP_CLASS, evalexpr),
     0,0,0, 0 },
   { "history_node",	"Dwg_ACSH_HistoryNode", sizeof (Dwg_ACSH_HistoryNode),  OFF (struct _dwg_object_ACSH_BREP_CLASS, history_node),
     0,0,0, 0 },
   { "major",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ACSH_BREP_CLASS, major),
     0,0,0, 90 },
   { "minor",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ACSH_BREP_CLASS, minor),
     0,0,0, 91 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_object_ACSH_CHAMFER_CLASS: (sorted by offset) */
@@ -4832,57 +4832,57 @@ static const Dwg_DYNAPI_field _dwg_APPID_CONTROL_fields[] = {
   { "parent",	"struct _dwg_object_object*", sizeof (void *),  OFF (struct _dwg_object_APPID_CONTROL, parent),
     1,1,0, 0 },
   { "num_entries",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_object_APPID_CONTROL, num_entries),
     0,0,0, 70 },
   { "entries",	"H*", sizeof (BITCODE_H*),  OFF (struct _dwg_object_APPID_CONTROL, entries),
     1,1,0, 0 },
   { "flags_r11",	"RS", sizeof (BITCODE_RS),  OFF (struct _dwg_object_APPID_CONTROL, flags_r11),
     0,0,0, 0 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_object_ASSOC2DCONSTRAINTGROUP: (sorted by offset) */
 static const Dwg_DYNAPI_field _dwg_ASSOC2DCONSTRAINTGROUP_fields[] = {
   { "parent",	"struct _dwg_object_object*", sizeof (void *),  OFF (struct _dwg_object_ASSOC2DCONSTRAINTGROUP, parent),
     1,1,0, 0 },
   { "class_version",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_object_ASSOC2DCONSTRAINTGROUP, class_version),
     0,0,0, 90 },
   { "geometry_status",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ASSOC2DCONSTRAINTGROUP, geometry_status),
     0,0,0, 90 },
   { "owningnetwork",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_object_ASSOC2DCONSTRAINTGROUP, owningnetwork),
     1,0,0, 330 },
   { "actionbody",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_object_ASSOC2DCONSTRAINTGROUP, actionbody),
     1,0,0, 360 },
   { "action_index",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ASSOC2DCONSTRAINTGROUP, action_index),
     0,0,0, 90 },
   { "max_assoc_dep_index",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ASSOC2DCONSTRAINTGROUP, max_assoc_dep_index),
     0,0,0, 90 },
   { "num_deps",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ASSOC2DCONSTRAINTGROUP, num_deps),
     0,0,0, 90 },
   { "deps",	"Dwg_ASSOCACTION_Deps*", sizeof (Dwg_ASSOCACTION_Deps*),  OFF (struct _dwg_object_ASSOC2DCONSTRAINTGROUP, deps),
     1,1,0, 0 },
   { "num_owned_params",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ASSOC2DCONSTRAINTGROUP, num_owned_params),
     0,0,0, 0 },
   { "owned_params",	"H*", sizeof (BITCODE_H*),  OFF (struct _dwg_object_ASSOC2DCONSTRAINTGROUP, owned_params),
     1,1,0, 0 },
   { "num_values",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ASSOC2DCONSTRAINTGROUP, num_values),
     0,0,0, 0 },
   { "values",	"struct _dwg_VALUEPARAM*", sizeof (void *),  OFF (struct _dwg_object_ASSOC2DCONSTRAINTGROUP, values),
     1,1,0, 0 },
   { "version",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ASSOC2DCONSTRAINTGROUP, version),
     0,0,0, 90 },
   { "b1",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_object_ASSOC2DCONSTRAINTGROUP, b1),
     0,0,0, 70 },
-  { "workplane[3]",	"3BD", 3 * sizeof (BITCODE_3BD),  OFF (struct _dwg_object_ASSOC2DCONSTRAINTGROUP, workplane),
+  { "workplane",	"3BD", 3 * sizeof (BITCODE_3BD),  OFF (struct _dwg_object_ASSOC2DCONSTRAINTGROUP, workplane),
     1,0,0, 0 },
   { "h1",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_object_ASSOC2DCONSTRAINTGROUP, h1),
     1,0,0, 360 },
   { "num_actions",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ASSOC2DCONSTRAINTGROUP, num_actions),
     0,0,0, 90 },
   { "actions",	"H*", sizeof (BITCODE_H*),  OFF (struct _dwg_object_ASSOC2DCONSTRAINTGROUP, actions),
     1,1,0, 360 },
   { "num_nodes",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ASSOC2DCONSTRAINTGROUP, num_nodes),
     0,0,0, 90 },
   { "nodes",	"Dwg_CONSTRAINTGROUPNODE*", sizeof (Dwg_CONSTRAINTGROUPNODE*),  OFF (struct _dwg_object_ASSOC2DCONSTRAINTGROUP, nodes),
     1,1,0, 0 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_object_ASSOC3POINTANGULARDIMACTIONBODY: (sorted by offset) */
@@ -4994,101 +4994,101 @@ static const Dwg_DYNAPI_field _dwg_ASSOCARRAYMODIFYACTIONBODY_fields[] = {
   { "parent",	"struct _dwg_object_object*", sizeof (void *),  OFF (struct _dwg_object_ASSOCARRAYMODIFYACTIONBODY, parent),
     1,1,0, 0 },
   { "aab_version",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ASSOCARRAYMODIFYACTIONBODY, aab_version),
     0,0,0, 90 },
   { "pab",	"Dwg_ASSOCPARAMBASEDACTIONBODY", sizeof (Dwg_ASSOCPARAMBASEDACTIONBODY),  OFF (struct _dwg_object_ASSOCARRAYMODIFYACTIONBODY, pab),
     0,0,0, 0 },
   { "aaab_version",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ASSOCARRAYMODIFYACTIONBODY, aaab_version),
     0,0,0, 90 },
   { "paramblock",	"T", sizeof (BITCODE_TV),  OFF (struct _dwg_object_ASSOCARRAYMODIFYACTIONBODY, paramblock),
     1,1,1, 1 },
   { "transmatrix",	"BD*", sizeof (BITCODE_BD*),  OFF (struct _dwg_object_ASSOCARRAYMODIFYACTIONBODY, transmatrix),
     1,1,0, 40 },
   { "status",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_object_ASSOCARRAYMODIFYACTIONBODY, status),
     0,0,0, 70 },
   { "num_items",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ASSOCARRAYMODIFYACTIONBODY, num_items),
     0,0,0, 90 },
   { "items",	"Dwg_ARRAYITEMLOCATOR*", sizeof (Dwg_ARRAYITEMLOCATOR*),  OFF (struct _dwg_object_ASSOCARRAYMODIFYACTIONBODY, items),
     1,1,0, 0 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_object_ASSOCASMBODYACTIONPARAM: (sorted by offset) */
 static const Dwg_DYNAPI_field _dwg_ASSOCASMBODYACTIONPARAM_fields[] = {
   { "parent",	"struct _dwg_object_object*", sizeof (void *),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, parent),
     1,1,0, 0 },
   { "is_r2013",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, is_r2013),
     0,0,0, 90 },
   { "aap_version",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, aap_version),
     0,0,0, 90 },
   { "name",	"T", sizeof (BITCODE_TV),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, name),
     1,1,1, 1 },
   { "asdap_class_version",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, asdap_class_version),
     0,0,0, 90 },
   { "dep",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, dep),
     1,0,0, 330 },
   { "class_version",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, class_version),
     0,0,0, 90 },
   { "acis_empty",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, acis_empty),
     0,0,0, 0 },
   { "unknown",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, unknown),
     0,0,0, 0 },
   { "version",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, version),
     0,0,0, 0 },
   { "num_blocks",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, num_blocks),
     0,0,0, 0 },
   { "block_size",	"BL*", sizeof (BITCODE_BL*),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, block_size),
     1,1,0, 0 },
   { "encr_sat_data",	"char **", sizeof (char **),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, encr_sat_data),
     1,1,0, 0 },
   { "sab_size",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, sab_size),
     0,0,0, 0 },
   { "acis_data",	"RC*", sizeof (BITCODE_RC*),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, acis_data),
     1,1,0, 0 },
   { "wireframe_data_present",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, wireframe_data_present),
     0,0,0, 0 },
   { "point_present",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, point_present),
     0,0,0, 0 },
   { "point",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, point),
     1,0,0, 0 },
   { "isolines",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, isolines),
     0,0,0, 0 },
   { "isoline_present",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, isoline_present),
     0,0,0, 0 },
   { "num_wires",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, num_wires),
     0,0,0, 0 },
   { "wires",	"Dwg_3DSOLID_wire*", sizeof (Dwg_3DSOLID_wire*),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, wires),
     1,1,0, 0 },
   { "num_silhouettes",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, num_silhouettes),
     0,0,0, 0 },
   { "silhouettes",	"Dwg_3DSOLID_silhouette*", sizeof (Dwg_3DSOLID_silhouette*),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, silhouettes),
     1,1,0, 0 },
   { "_dxf_sab_converted",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, _dxf_sab_converted),
     0,0,0, 0 },
   { "acis_empty2",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, acis_empty2),
     0,0,0, 0 },
   { "extra_acis_data",	"struct _dwg_entity_3DSOLID*", sizeof (void *),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, extra_acis_data),
     1,1,0, 0 },
   { "num_materials",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, num_materials),
     0,0,0, 0 },
   { "materials",	"Dwg_3DSOLID_material*", sizeof (Dwg_3DSOLID_material*),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, materials),
     1,1,0, 0 },
-  { "revision_guid[39]",	"RC", 39 * sizeof (BITCODE_RC),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, revision_guid),
+  { "revision_guid",	"RC", 39 * sizeof (BITCODE_RC),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, revision_guid),
     0,0,0, 0 },
   { "revision_major",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, revision_major),
     0,0,0, 0 },
   { "revision_minor1",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, revision_minor1),
     0,0,0, 0 },
   { "revision_minor2",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, revision_minor2),
     0,0,0, 0 },
-  { "revision_bytes[9]",	"RC", 9 * sizeof (BITCODE_RC),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, revision_bytes),
+  { "revision_bytes",	"RC", 9 * sizeof (BITCODE_RC),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, revision_bytes),
     0,0,0, 0 },
   { "end_marker",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, end_marker),
     0,0,0, 0 },
   { "history_id",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, history_id),
     1,0,0, 0 },
   { "has_revision_guid",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, has_revision_guid),
     0,0,0, 0 },
   { "acis_empty_bit",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_object_ASSOCASMBODYACTIONPARAM, acis_empty_bit),
     0,0,0, 0 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_object_ASSOCBLENDSURFACEACTIONBODY: (sorted by offset) */
@@ -8548,43 +8548,43 @@ static const Dwg_DYNAPI_field _dwg_LONG_TRANSACTION_fields[] = {
   { "parent",	"struct _dwg_object_object*", sizeof (void *),  OFF (struct _dwg_object_LONG_TRANSACTION, parent),
     1,1,0, 0 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_object_LTYPE: (sorted by offset) */
 static const Dwg_DYNAPI_field _dwg_LTYPE_fields[] = {
   { "parent",	"struct _dwg_object_object*", sizeof (void *),  OFF (struct _dwg_object_LTYPE, parent),
     1,1,0, 0 },
   { "flag",	"RC", sizeof (BITCODE_RC),  OFF (struct _dwg_object_LTYPE, flag),
     0,0,0, 0 },
   { "name",	"TV", sizeof (BITCODE_TV),  OFF (struct _dwg_object_LTYPE, name),
     1,1,1, 0 },
   { "used",	"RSd", sizeof (BITCODE_RSd),  OFF (struct _dwg_object_LTYPE, used),
     0,0,0, 0 },
   { "is_xref_ref",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_object_LTYPE, is_xref_ref),
     0,0,0, 0 },
   { "is_xref_resolved",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_object_LTYPE, is_xref_resolved),
     0,0,0, 0 },
   { "is_xref_dep",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_object_LTYPE, is_xref_dep),
     0,0,0, 0 },
   { "xref",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_object_LTYPE, xref),
     1,0,0, 0 },
   { "description",	"T", sizeof (BITCODE_TV),  OFF (struct _dwg_object_LTYPE, description),
     1,1,1, 3 },
   { "pattern_len",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_object_LTYPE, pattern_len),
     0,0,0, 40 },
   { "alignment",	"RC", sizeof (BITCODE_RC),  OFF (struct _dwg_object_LTYPE, alignment),
     0,0,0, 72 },
   { "numdashes",	"RC", sizeof (BITCODE_RC),  OFF (struct _dwg_object_LTYPE, numdashes),
     0,0,0, 73 },
   { "dashes",	"Dwg_LTYPE_dash*", sizeof (Dwg_LTYPE_dash*),  OFF (struct _dwg_object_LTYPE, dashes),
     1,1,0, 0 },
-  { "dashes_r11[12]",	"RD", 12 * sizeof (BITCODE_RD),  OFF (struct _dwg_object_LTYPE, dashes_r11),
-    0,0,0, 0 },
+  { "dashes_r11",	"RD", 12 * sizeof (BITCODE_RD),  OFF (struct _dwg_object_LTYPE, dashes_r11),
+    0,0,0, 49 },
   { "has_strings_area",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_object_LTYPE, has_strings_area),
     0,0,0, 0 },
   { "strings_area",	"TF", sizeof (BITCODE_TF),  OFF (struct _dwg_object_LTYPE, strings_area),
     1,1,0, 0 },
   { "unknown_r11",	"RC", sizeof (BITCODE_RC),  OFF (struct _dwg_object_LTYPE, unknown_r11),
     0,0,0, 0 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_object_LTYPE_CONTROL: (sorted by offset) */
@@ -10703,19 +10703,19 @@ static const Dwg_DYNAPI_field _dwg_ACTIONBODY_fields[] = {
   { "parent",	"struct _dwg_object_ASSOCNETWORK*", sizeof (void *),  OFF (struct _dwg_ACTIONBODY, parent),
     1,1,0, 0 },
   { "evaluatorid",	"T", sizeof (BITCODE_T),  OFF (struct _dwg_ACTIONBODY, evaluatorid),
     1,1,1, 0 },
   { "expression",	"T", sizeof (BITCODE_T),  OFF (struct _dwg_ACTIONBODY, expression),
     1,1,1, 0 },
   { "value",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_ACTIONBODY, value),
     0,0,0, 0 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_ARRAYITEMLOCATOR: (sorted by offset) */
 static const Dwg_DYNAPI_field _dwg_ARRAYITEMLOCATOR_fields[] = {
   { "parent",	"struct _dwg_object_ASSOCARRAYMODIFYACTIONBODY*", sizeof (void *),  OFF (struct _dwg_ARRAYITEMLOCATOR, parent),
     1,1,0, 0 },
-  { "itemloc[3]",	"BL", 3 * sizeof (BITCODE_BL),  OFF (struct _dwg_ARRAYITEMLOCATOR, itemloc),
+  { "itemloc",	"BL", 3 * sizeof (BITCODE_BL),  OFF (struct _dwg_ARRAYITEMLOCATOR, itemloc),
     0,0,0, 0 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_ASSOCACTIONBODY_action: (sorted by offset) */
@@ -10733,35 +10733,35 @@ static const Dwg_DYNAPI_field _dwg_ASSOCACTION_Deps_fields[] = {
   { "parent",	"struct _dwg_object_ASSOCACTION*", sizeof (void *),  OFF (struct _dwg_ASSOCACTION_Deps, parent),
     1,1,0, 0 },
   { "is_owned",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_ASSOCACTION_Deps, is_owned),
     0,0,0, 0 },
   { "dep",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_ASSOCACTION_Deps, dep),
     1,0,0, 0 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_ASSOCARRAYITEM: (sorted by offset) */
 static const Dwg_DYNAPI_field _dwg_ASSOCARRAYITEM_fields[] = {
   { "parent",	"struct _dwg_abstractobject_ASSOCARRAYPARAMETERS*", sizeof (void *),  OFF (struct _dwg_ASSOCARRAYITEM, parent),
     1,1,0, 0 },
   { "class_version",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_ASSOCARRAYITEM, class_version),
     0,0,0, 90 },
-  { "itemloc[3]",	"BL", 3 * sizeof (BITCODE_BL),  OFF (struct _dwg_ASSOCARRAYITEM, itemloc),
+  { "itemloc",	"BL", 3 * sizeof (BITCODE_BL),  OFF (struct _dwg_ASSOCARRAYITEM, itemloc),
     0,0,0, 0 },
   { "flags",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_ASSOCARRAYITEM, flags),
     0,0,0, 0 },
   { "is_default_transmatrix",	"int", sizeof (int),  OFF (struct _dwg_ASSOCARRAYITEM, is_default_transmatrix),
     0,0,0, 0 },
   { "x_dir",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_ASSOCARRAYITEM, x_dir),
     1,0,0, 0 },
   { "transmatrix",	"BD*", sizeof (BITCODE_BD*),  OFF (struct _dwg_ASSOCARRAYITEM, transmatrix),
     1,1,0, 0 },
   { "rel_transform",	"BD*", sizeof (BITCODE_BD*),  OFF (struct _dwg_ASSOCARRAYITEM, rel_transform),
     1,1,0, 0 },
   { "has_h1",	"int", sizeof (int),  OFF (struct _dwg_ASSOCARRAYITEM, has_h1),
     0,0,0, 0 },
   { "h1",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_ASSOCARRAYITEM, h1),
     1,0,0, 0 },
   { "h2",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_ASSOCARRAYITEM, h2),
     1,0,0, 0 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_ASSOCPARAMBASEDACTIONBODY: (sorted by offset) */
@@ -11087,35 +11087,35 @@ static const Dwg_DYNAPI_field _dwg_AcDs_Search_IdIdxs_fields[] = {
   { "num_ididx",	"RL", sizeof (BITCODE_RL),  OFF (struct _dwg_AcDs_Search_IdIdxs, num_ididx),
     0,0,0, 0 },
   { "ididx",	"Dwg_AcDs_Search_IdIdx*", sizeof (Dwg_AcDs_Search_IdIdx*),  OFF (struct _dwg_AcDs_Search_IdIdxs, ididx),
     1,1,0, 0 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_AcDs_Segment: (sorted by offset) */
 static const Dwg_DYNAPI_field _dwg_AcDs_Segment_fields[] = {
   { "signature",	"RS", sizeof (BITCODE_RS),  OFF (struct _dwg_AcDs_Segment, signature),
     0,0,0, 0 },
-  { "name[7]",	"RC", 7 * sizeof (BITCODE_RC),  OFF (struct _dwg_AcDs_Segment, name),
+  { "name",	"RC", 7 * sizeof (BITCODE_RC),  OFF (struct _dwg_AcDs_Segment, name),
     0,0,0, 0 },
   { "type",	"RCd", sizeof (BITCODE_RCd),  OFF (struct _dwg_AcDs_Segment, type),
     0,0,0, 0 },
   { "segment_idx",	"RL", sizeof (BITCODE_RL),  OFF (struct _dwg_AcDs_Segment, segment_idx),
     0,0,0, 0 },
   { "is_blob01",	"RL", sizeof (BITCODE_RL),  OFF (struct _dwg_AcDs_Segment, is_blob01),
     0,0,0, 0 },
   { "segsize",	"RL", sizeof (BITCODE_RL),  OFF (struct _dwg_AcDs_Segment, segsize),
     0,0,0, 0 },
   { "unknown_2",	"RL", sizeof (BITCODE_RL),  OFF (struct _dwg_AcDs_Segment, unknown_2),
     0,0,0, 0 },
   { "ds_version",	"RL", sizeof (BITCODE_RL),  OFF (struct _dwg_AcDs_Segment, ds_version),
     0,0,0, 0 },
   { "unknown_3",	"RL", sizeof (BITCODE_RL),  OFF (struct _dwg_AcDs_Segment, unknown_3),
     0,0,0, 0 },
   { "data_algn_offset",	"RL", sizeof (BITCODE_RL),  OFF (struct _dwg_AcDs_Segment, data_algn_offset),
     0,0,0, 0 },
   { "objdata_algn_offset",	"RL", sizeof (BITCODE_RL),  OFF (struct _dwg_AcDs_Segment, objdata_algn_offset),
     0,0,0, 0 },
-  { "padding[9]",	"RC", 9 * sizeof (BITCODE_RC),  OFF (struct _dwg_AcDs_Segment, padding),
+  { "padding",	"RC", 9 * sizeof (BITCODE_RC),  OFF (struct _dwg_AcDs_Segment, padding),
     0,0,0, 0 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_AcDs_SegmentIndex: (sorted by offset) */
@@ -11413,85 +11413,85 @@ static const Dwg_DYNAPI_field _dwg_DIMENSION_common_fields[] = {
   { "parent",	"struct _dwg_object_entity*", sizeof (void *),  OFF (struct _dwg_DIMENSION_common, parent),
     1,1,0, 0 },
   { "class_version",	"RC", sizeof (BITCODE_RC),  OFF (struct _dwg_DIMENSION_common, class_version),
     0,0,0, 280 },
   { "extrusion",	"BE", sizeof (BITCODE_BE),  OFF (struct _dwg_DIMENSION_common, extrusion),
     0,0,0, 210 },
   { "def_pt",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_DIMENSION_common, def_pt),
     1,0,0, 10 },
   { "text_midpt",	"2RD", sizeof (BITCODE_2RD),  OFF (struct _dwg_DIMENSION_common, text_midpt),
     1,0,0, 11 },
   { "elevation",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_DIMENSION_common, elevation),
     0,0,0, 31 },
   { "flag",	"RC", sizeof (BITCODE_RC),  OFF (struct _dwg_DIMENSION_common, flag),
     0,0,0, 70 },
   { "flag1",	"RC", sizeof (BITCODE_RC),  OFF (struct _dwg_DIMENSION_common, flag1),
     0,0,0, 0 },
   { "user_text",	"TV", sizeof (BITCODE_TV),  OFF (struct _dwg_DIMENSION_common, user_text),
     1,1,1, 1 },
   { "text_rotation",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_DIMENSION_common, text_rotation),
     0,0,0, 53 },
   { "horiz_dir",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_DIMENSION_common, horiz_dir),
     0,0,0, 51 },
   { "ins_scale",	"3BD", sizeof (BITCODE_3BD),  OFF (struct _dwg_DIMENSION_common, ins_scale),
     1,0,0, 0 },
   { "ins_rotation",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_DIMENSION_common, ins_rotation),
     0,0,0, 54 },
   { "attachment",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_DIMENSION_common, attachment),
     0,0,0, 71 },
   { "lspace_style",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_DIMENSION_common, lspace_style),
     0,0,0, 72 },
   { "lspace_factor",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_DIMENSION_common, lspace_factor),
     0,0,0, 41 },
   { "act_measurement",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_DIMENSION_common, act_measurement),
     0,0,0, 42 },
   { "unknown",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_DIMENSION_common, unknown),
     0,0,0, 73 },
   { "flip_arrow1",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_DIMENSION_common, flip_arrow1),
     0,0,0, 74 },
   { "flip_arrow2",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_DIMENSION_common, flip_arrow2),
     0,0,0, 75 },
   { "clone_ins_pt",	"2RD", sizeof (BITCODE_2RD),  OFF (struct _dwg_DIMENSION_common, clone_ins_pt),
     1,0,0, 12 },
   { "dimstyle",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_DIMENSION_common, dimstyle),
     1,0,0, 3 },
   { "block",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_DIMENSION_common, block),
     1,0,0, 2 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_EVAL_Edge: (sorted by offset) */
 static const Dwg_DYNAPI_field _dwg_EVAL_Edge_fields[] = {
   { "parent",	"struct _dwg_object_EVALUATION_GRAPH*", sizeof (void *),  OFF (struct _dwg_EVAL_Edge, parent),
     1,1,0, 0 },
   { "id",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_EVAL_Edge, id),
     0,0,0, 92 },
   { "nextid",	"BLd", sizeof (BITCODE_BLd),  OFF (struct _dwg_EVAL_Edge, nextid),
     0,0,0, 93 },
   { "e1",	"BLd", sizeof (BITCODE_BLd),  OFF (struct _dwg_EVAL_Edge, e1),
     0,0,0, 94 },
   { "e2",	"BLd", sizeof (BITCODE_BLd),  OFF (struct _dwg_EVAL_Edge, e2),
     0,0,0, 91 },
   { "e3",	"BLd", sizeof (BITCODE_BLd),  OFF (struct _dwg_EVAL_Edge, e3),
     0,0,0, 91 },
-  { "out_edge[5]",	"BLd", 5 * sizeof (BITCODE_BLd),  OFF (struct _dwg_EVAL_Edge, out_edge),
+  { "out_edge",	"BLd", 5 * sizeof (BITCODE_BLd),  OFF (struct _dwg_EVAL_Edge, out_edge),
     0,0,0, 0 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_EVAL_Node: (sorted by offset) */
 static const Dwg_DYNAPI_field _dwg_EVAL_Node_fields[] = {
   { "parent",	"struct _dwg_object_EVALUATION_GRAPH*", sizeof (void *),  OFF (struct _dwg_EVAL_Node, parent),
     1,1,0, 0 },
   { "id",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_EVAL_Node, id),
     0,0,0, 91 },
   { "edge_flags",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_EVAL_Node, edge_flags),
     0,0,0, 93 },
   { "nextid",	"BLd", sizeof (BITCODE_BLd),  OFF (struct _dwg_EVAL_Node, nextid),
     0,0,0, 95 },
   { "evalexpr",	"H", sizeof (BITCODE_H),  OFF (struct _dwg_EVAL_Node, evalexpr),
     1,0,0, 360 },
-  { "node[4]",	"BLd", 4 * sizeof (BITCODE_BLd),  OFF (struct _dwg_EVAL_Node, node),
+  { "node",	"BLd", 4 * sizeof (BITCODE_BLd),  OFF (struct _dwg_EVAL_Node, node),
     0,0,0, 0 },
   { "active_cycles",	"B", sizeof (BITCODE_B),  OFF (struct _dwg_EVAL_Node, active_cycles),
     0,0,0, 0 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_EvalExpr: (sorted by offset) */
@@ -12267,95 +12267,95 @@ static const Dwg_DYNAPI_field _dwg_PROXY_LWPOLYLINE_fields[] = {
   { "parent",	"struct _dwg_entity_PROXY_ENTITY*", sizeof (void *),  OFF (struct _dwg_PROXY_LWPOLYLINE, parent),
     1,1,0, 0 },
   { "size",	"RL", sizeof (BITCODE_RL),  OFF (struct _dwg_PROXY_LWPOLYLINE, size),
     0,0,0, 0 },
   { "flags",	"BS", sizeof (BITCODE_BS),  OFF (struct _dwg_PROXY_LWPOLYLINE, flags),
     0,0,0, 0 },
   { "const_width",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_PROXY_LWPOLYLINE, const_width),
     0,0,0, 0 },
   { "elevation",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_PROXY_LWPOLYLINE, elevation),
     0,0,0, 0 },
   { "thickness",	"BD", sizeof (BITCODE_BD),  OFF (struct _dwg_PROXY_LWPOLYLINE, thickness),
     0,0,0, 0 },
   { "extrusion",	"BE", sizeof (BITCODE_BE),  OFF (struct _dwg_PROXY_LWPOLYLINE, extrusion),
     0,0,0, 0 },
   { "num_points",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_PROXY_LWPOLYLINE, num_points),
     0,0,0, 0 },
   { "points",	"2RD*", sizeof (BITCODE_2RD*),  OFF (struct _dwg_PROXY_LWPOLYLINE, points),
     1,1,0, 0 },
   { "num_bulges",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_PROXY_LWPOLYLINE, num_bulges),
     0,0,0, 0 },
   { "bulges",	"BD*", sizeof (BITCODE_BD*),  OFF (struct _dwg_PROXY_LWPOLYLINE, bulges),
     1,1,0, 0 },
   { "num_widths",	"BL", sizeof (BITCODE_BL),  OFF (struct _dwg_PROXY_LWPOLYLINE, num_widths),
     0,0,0, 0 },
   { "widths",	"Dwg_LWPOLYLINE_width*", sizeof (Dwg_LWPOLYLINE_width*),  OFF (struct _dwg_PROXY_LWPOLYLINE, widths),
     1,1,0, 0 },
   { "unknown_1",	"RC", sizeof (BITCODE_RC),  OFF (struct _dwg_PROXY_LWPOLYLINE, unknown_1),
     0,0,0, 0 },
   { "unknown_2",	"RC", sizeof (BITCODE_RC),  OFF (struct _dwg_PROXY_LWPOLYLINE, unknown_2),
     0,0,0, 0 },
   { "unknown_3",	"RC", sizeof (BITCODE_RC),  OFF (struct _dwg_PROXY_LWPOLYLINE, unknown_3),
     0,0,0, 0 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_R2004_Header: (sorted by offset) */
 static const Dwg_DYNAPI_field _dwg_R2004_Header_fields[] = {
-  { "file_ID_string[12]",	"RC", 12 * sizeof (BITCODE_RC),  OFF (struct _dwg_R2004_Header, file_ID_string),
+  { "file_ID_string",	"RC", 12 * sizeof (BITCODE_RC),  OFF (struct _dwg_R2004_Header, file_ID_string),
     0,0,0, 0 },
   { "header_address",	"RLx", sizeof (BITCODE_RLx),  OFF (struct _dwg_R2004_Header, header_address),
     0,0,0, 0 },
   { "header_size",	"RL", sizeof (BITCODE_RL),  OFF (struct _dwg_R2004_Header, header_size),
     0,0,0, 0 },
   { "x04",	"RL", sizeof (BITCODE_RL),  OFF (struct _dwg_R2004_Header, x04),
     0,0,0, 0 },
   { "root_tree_node_gap",	"RLd", sizeof (BITCODE_RLd),  OFF (struct _dwg_R2004_Header, root_tree_node_gap),
     0,0,0, 0 },
   { "lowermost_left_tree_node_gap",	"RLd", sizeof (BITCODE_RLd),  OFF (struct _dwg_R2004_Header, lowermost_left_tree_node_gap),
     0,0,0, 0 },
   { "lowermost_right_tree_node_gap",	"RLd", sizeof (BITCODE_RLd),  OFF (struct _dwg_R2004_Header, lowermost_right_tree_node_gap),
     0,0,0, 0 },
   { "unknown_long",	"RL", sizeof (BITCODE_RL),  OFF (struct _dwg_R2004_Header, unknown_long),
     0,0,0, 0 },
   { "last_section_id",	"RL", sizeof (BITCODE_RL),  OFF (struct _dwg_R2004_Header, last_section_id),
     0,0,0, 0 },
   { "last_section_address",	"RLL", sizeof (BITCODE_RLL),  OFF (struct _dwg_R2004_Header, last_section_address),
     0,0,0, 0 },
   { "secondheader_address",	"RLL", sizeof (BITCODE_RLL),  OFF (struct _dwg_R2004_Header, secondheader_address),
     0,0,0, 0 },
   { "numgaps",	"RL", sizeof (BITCODE_RL),  OFF (struct _dwg_R2004_Header, numgaps),
     0,0,0, 0 },
   { "numsections",	"RL", sizeof (BITCODE_RL),  OFF (struct _dwg_R2004_Header, numsections),
     0,0,0, 0 },
   { "x20",	"RL", sizeof (BITCODE_RL),  OFF (struct _dwg_R2004_Header, x20),
     0,0,0, 0 },
   { "x80",	"RL", sizeof (BITCODE_RL),  OFF (struct _dwg_R2004_Header, x80),
     0,0,0, 0 },
   { "x40",	"RL", sizeof (BITCODE_RL),  OFF (struct _dwg_R2004_Header, x40),
     0,0,0, 0 },
   { "section_map_id",	"RL", sizeof (BITCODE_RL),  OFF (struct _dwg_R2004_Header, section_map_id),
     0,0,0, 0 },
   { "section_map_address",	"RLL", sizeof (BITCODE_RLL),  OFF (struct _dwg_R2004_Header, section_map_address),
     0,0,0, 0 },
   { "section_info_id",	"RLd", sizeof (BITCODE_RLd),  OFF (struct _dwg_R2004_Header, section_info_id),
     0,0,0, 0 },
   { "section_array_size",	"RLd", sizeof (BITCODE_RLd),  OFF (struct _dwg_R2004_Header, section_array_size),
     0,0,0, 0 },
   { "gap_array_size",	"RL", sizeof (BITCODE_RL),  OFF (struct _dwg_R2004_Header, gap_array_size),
     0,0,0, 0 },
   { "crc32",	"RLx", sizeof (BITCODE_RLx),  OFF (struct _dwg_R2004_Header, crc32),
     0,0,0, 0 },
-  { "padding[12]",	"RC", 12 * sizeof (BITCODE_RC),  OFF (struct _dwg_R2004_Header, padding),
+  { "padding",	"RC", 12 * sizeof (BITCODE_RC),  OFF (struct _dwg_R2004_Header, padding),
     0,0,0, 0 },
   { "section_type",	"RL", sizeof (BITCODE_RL),  OFF (struct _dwg_R2004_Header, section_type),
     0,0,0, 0 },
   { "decomp_data_size",	"RL", sizeof (BITCODE_RL),  OFF (struct _dwg_R2004_Header, decomp_data_size),
     0,0,0, 0 },
   { "comp_data_size",	"RL", sizeof (BITCODE_RL),  OFF (struct _dwg_R2004_Header, comp_data_size),
     0,0,0, 0 },
   { "compression_type",	"RL", sizeof (BITCODE_RL),  OFF (struct _dwg_R2004_Header, compression_type),
     0,0,0, 0 },
   { "checksum",	"RLx", sizeof (BITCODE_RLx),  OFF (struct _dwg_R2004_Header, checksum),
     0,0,0, 0 },
   {NULL,	NULL,	0,	0,	0,0,0, 0},
 };
 /* from typedef struct _dwg_SECTION_geometrysettings: (sorted by offset) */
diff --git a/src/gen-dynapi.pl b/src/gen-dynapi.pl
index 4f72c66f..d4aed3f9 100755
--- a/src/gen-dynapi.pl
+++ b/src/gen-dynapi.pl
@@ -532,7 +532,7 @@ $DXF{$_}->{'version'} = 70 for @solids;
 $DXF{$_}->{'encr_sat_data'} = 1 for @solids;
 $DXF{$_}->{'history_id'} = 350 for @solids;
 $DXF{$_}->{'acis_empty'} = 290 for @solids;
-$DXF{$_}->{'revision_guid[39]'} = 2 for @solids;
+$DXF{$_}->{'revision_guid'} = 2 for @solids;
 my @annotscale = qw (TEXTOBJECTCONTEXTDATA MTEXTOBJECTCONTEXTDATA ALDIMOBJECTCONTEXTDATA
                      MTEXTATTRIBUTEOBJECTCONTEXTDATA MLEADEROBJECTCONTEXTDATA LEADEROBJECTCONTEXTDATA
                      BLKREFOBJECTCONTEXTDATA);
@@ -757,129 +757,129 @@ sub is_table_control {
 sub out_declarator {
   my ($d,$tmpl,$key,$prefix) = @_;
   my $n = "_dwg_$key" unless $key =~ /^_dwg_/;
   my $ns = $tmpl;
   $ns =~ s/^struct //;
   my $type = $d->{type};
   my $decl = $d->{declarators}->[0];
   my $name = $decl->{declarator};
   while ($name =~ /^\*/) {
     $name =~ s/^\*//;
     $type .= '*';
   }
   if ($prefix) { # optional, for unions only
     $name = $prefix . "." . $name;
   }
   # unexpand BITCODE_ macros: e.g. unsigned int -> BITCODE_BL
   my $bc = exists $h{$ns} ? $h{$ns}{$name} : undef;
   if (!$bc && $ns =~ /_CONTROL$/) {
     $bc = $h{COMMON_TABLE_CONTROL_FIELDS}{$name};
   } elsif (!$bc && $ns =~ /_entity_POLYLINE_/) {
     $bc = $h{COMMON_ENTITY_POLYLINE}{$name};
   }
   $type = $bc if $bc;
   if ($name eq 'encr_sat_data') {
     $type = 'char **'; $bc = '';
   }
   $type =~ s/\s+$//;
   my $size = $bc ? "sizeof (BITCODE_$type)" : "sizeof ($type)";
   $type =~ s/BITCODE_//;
   # TODO: DIMENSION_COMMON, _3DSOLID_FIELDS macros
   if ($type eq 'unsigned char') {
     $type = 'RC';
   } elsif ($type eq 'unsigned char*') {
     $type = 'RC*';
   } elsif ($type eq 'double') {
     $type = 'BD';
   } elsif ($type eq 'double*') {
     $type = 'BD*';
   } elsif ($type =~ /^Dwg_Bitcode_(\w+)/) {
     $type = $1;
   } elsif ($type eq 'char*') {
     $type = 'TV';
   } elsif ($type eq 'unsigned short int') {
     $type = 'BS';
   } elsif ($type eq 'uint16_t') {
     $type = 'BS';
   } elsif ($type eq 'unsigned int') {
     $type = 'BL';
   } elsif ($type eq 'unsigned int*') {
     $type = 'BL*';
   } elsif ($type eq 'uint32_t') {
     $type = 'BL';
   } elsif ($type eq 'uint32_t*') {
     $type = 'BL*';
   #} elsif ($type eq 'TFv') {
   #  $type = 'TV';
   } elsif ($type eq 'Dwg_Object_Ref*') {
     $type = 'H';
   } elsif ($type eq 'Dwg_Object_Ref**') {
     $type = 'H*';
   } elsif ($type =~ /\b(unsigned|char|int|long|double)\b/) {
     warn "unexpanded $type $n.$name\n";
   } elsif ($type =~ /^struct/) {
     if ($type =~ /\*$/) {
       $size = "sizeof (void *)";
     } else {
       # e.g. MLEADER_Content.txt.
       warn "inline struct $key.$name\n";
       for (@{$c->struct($d->{type})->{declarations}}) {
         out_declarator ($_, $tmpl, $key, $name);
       }
       #next;
     }
   } elsif ($type =~ /^union/) {
     warn "inline union $key.$name\n";
     for (@{$c->union($d->{type})->{declarations}}) {
       out_declarator ($_, $tmpl, $key, $name);
     }
     #next;
   } elsif ($type =~ /^HASH\(/) { # inlined struct or union
     if ($type->{type} eq 'union' && $n !~ /^_dwg_object_/) {
       # take all declarators and add the "$name." prefix
       warn "note: union field $n.$name\n";
       for (@{$type->{declarations}}) {
         out_declarator ($_, $tmpl, $key, $name);
       }
       next;
     } else {
       warn "ignore inlined field $n.$name\n";
       next;
     }
   }
   if ($ENT{$key}->{$name}) {
     $type = $ENT{$key}->{$name};
   } else {
     $ENT{$key}->{$name} = $type;
   }
   my $is_malloc = ($type =~ /\*$/ or $type =~ /^(T$|T[UVF]|D2T)/) ? 1 : 0;
   my $is_indirect = ($is_malloc or $type =~ /^(struct|[23T]|H$)/) ? 1 : 0;
   my $is_string = ($is_malloc and $type =~ /^(T[UV]?|D2T)$/) ? 1 : 0; # not TF or TFF
   my $sname = $name;
   if ($name =~ /\[(\d+)\]$/) {
     $is_malloc = 0;
     $size = "$1 * $size";
     $sname =~ s/\[(\d+)\]$//;
-    $name = $sname if $sname eq 'conn_pts';
+      $name = $sname; # if $sname eq 'conn_pts';
   }
   if ($type =~ /^TF/ && exists $SIZE{$key}->{$name}) {
     $size = $SIZE{$key}->{$name};
   }
   my $dxf = $DXF{$key}->{$name};
   if (!$dxf && $key =~ /DIMENSION/) {
     $dxf = $DXF{COMMON_ENTITY_DIMENSION}->{$name};
   }
   if (!$dxf && $key =~ /ASSOC/) {
     $dxf = $DXF{ASSOCACTION}->{$name};
   }
   $dxf = 0 unless $dxf;
   warn "no dxf for $key: $name 0\n" unless $dxf or
     ($name eq 'parent') or
     ($key eq 'header_variables' and $name eq lc($name));
 
   printf $fh "  { \"%s\",\t\"%s\", %s,  OFF (%s, %s),\n    %d,%d,%d, %d },\n",
     $name, $type, $size, $tmpl, $sname, $is_indirect, $is_malloc, $is_string, $dxf;
 
   print $doc "\@item $name\n$type", $dxf ? ",\tDXF $dxf" : "", "\n";
 }
 
 # until the type is a struct or union
@@ -1337,76 +1337,76 @@ print $fh "/* ex: set ro ft=c: -*- mode: c; buffer-read-only: t -*- */\n";
 for (<$in>) {
   print $fh $_;
   if (m{/\* \@\@for test_HEADER\@@ \*/}) {
     my $s = $c->struct('_dwg_header_variables');
     for my $d (@{$s->{declarations}}) {
       my $type = $d->{type};
       my $decl = $d->{declarators}->[0];
       my $name = $decl->{declarator};
       while ($name =~ /^\*/) {
         $name =~ s/^\*//;
         $type .= '*';
       }
       $type =~ s/ $//g;
       my $xname = $name =~ /^3/ ? "_$name" : $name;
       my $lname = lc $xname;
       my $var = $lname;
       my $sname = $name;
       if (exists $ENT{header_variables}->{$name}) {
         $type = $ENT{header_variables}->{$name};
       }
       $type =~ s/D_1$/D/;
       my $fmt = exists $FMT{$type} ? $FMT{$type} : undef;
       if (!$fmt) {
         if ($type =~ /[ \*]/ or $type eq 'H') {
           $fmt = '%p';
         } else {
           $fmt = "\" FORMAT_$type \"";
         }
       }
       my $is_ptr = ($type =~ /^(struct|Dwg_)/ or
                     $type =~ /^[23HT]/ or
                     $type =~ /\*$/ or
                     $var  =~ /\[\d+\]$/ or
                     $type =~ /^(BE|CMC)$/)
         ? 1 : 0;
       if ($var  =~ /\[\d+\]$/) {
         $lname =~ s/\[\d+\]$//g;
         $sname =~ s/\[\d+\]$//g;
       }
       $var  =~ s/^timezone/timezn/; # global on darwin
       my $stype = $type;
       $type = 'BITCODE_'.$type unless ($type =~ /^(struct|Dwg_)/ or $type =~ /^[a-z]/);
       if (!$is_ptr) {
         print $fh <<"EOF";
   {
     $type $var;
-    if (dwg_dynapi_header_value (dwg, "$name", &$var, NULL)
+    if (dwg_dynapi_header_value (dwg, "$sname", &$var, NULL)
         && $var == dwg->header_vars.$name)
       pass ();
     else
       fail ("HEADER.$name [$stype] $fmt != $fmt", dwg->header_vars.$sname, $var);
 EOF
         if ($type =~ /(int|long|short|char ||double|_B\b|_B[BSLD]\b|_R[CSLD])/) {
           print $fh "    $var++;\n";
         }
         print $fh <<"EOF";
-    if (dwg_dynapi_header_set_value (dwg, "$name", &$var, 0)
+    if (dwg_dynapi_header_set_value (dwg, "$sname", &$var, 0)
         && $var == dwg->header_vars.$name)
       pass ();
     else
       fail ("HEADER.$name [$stype] set+1 $fmt != $fmt",
             dwg->header_vars.$sname, $var);
 EOF
         if ($type =~ /(int|long|short|char ||double|_B\b|_B[BSLD]\b|_R[CSLD])/) {
           print $fh "    $var--;\n";
-          print $fh "    dwg_dynapi_header_set_value (dwg, \"$name\", &$var, 0);\n";
+          print $fh "    dwg_dynapi_header_set_value (dwg, \"$sname\", &$var, 0);\n";
         }
         print $fh "\n  }\n";
       } else {
         print $fh <<"EOF";
   {
     $type $var;
-    if (dwg_dynapi_header_value (dwg, "$name", &$lname, NULL)
+    if (dwg_dynapi_header_value (dwg, "$sname", &$lname, NULL)
 EOF
         if ($type !~ /\*\*/) {
           print $fh <<"EOF";
@@ -1451,60 +1451,60 @@ static int test_$xname (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_$Entity *restrict obj_obj = obj->tio.$lentity;
   $struct *restrict $lname = obj->tio.$lentity->tio.$xname;
   failed = 0;
   if (!obj_obj || !$lname)
     {
       fail ("NULL $xname");
       return 1;
     }
 EOF
 
   for my $var (sort keys %{$ENT{$name}}) {
     my $type = $ENT{$name}->{$var};
     # if 0 ignored in .spec
     # next if $type eq 'T' and $name eq 'LIGHT' and $var eq 'web_file';
     # next if $type eq 'TF' and $name eq 'SUN' and $var eq 'bytes';
     # LAYER.flag is computed since r2000
     next if $name eq 'LAYER' and $var eq 'flag';
     my $fmt = exists $FMT{$type} ? $FMT{$type} : undef;
     if (!$fmt) {
       if ($type =~ /[ \*]/ or $type eq 'H') {
         $fmt = '%p';
       } else {
         $fmt = "\" FORMAT_$type \"";
       }
     }
     my $key = $var;
     my $svar = $var;
     my $skey = $var;
     my $is_ptr = ($type =~ /^(struct|Dwg_)/ or
                   $type =~ /^[TH23]/ or
                   $type =~ /\*$/ or
                   $var =~ /\[\d+\]$/ or
                   $type =~ /^(BE|CMC)$/)
       ? 1 : 0;
     if ($var  =~ /\./) { # embedded structs, like ovr.name. some have fields, some not
       next if $var =~ /^ovr\./;
       $svar =~ s/\./_/g;
       $var = $svar;
     }
     if ($var =~ /\[\d+\]$/) {
       $svar =~ s/\[\d+\]$//g;
       $skey =~ s/\[\d+\]$//g;
-      $var = $svar if $var =~ /^conn_pts\[\d\]$/;
+      $key = $skey;
     }
     next if $key eq 'evalexpr.value.text1'; # already handled by evalexpr memcmp
     my $stype = $type;
     $type =~ s/D_1$/D/;
     $type = 'BITCODE_'.$type unless ($type =~ /^(struct|Dwg_)/ or $type =~ /^[a-z]/);
     if (!$is_ptr) {
       # TODO DEBUGGING [BR]D can be nan
       print $fh <<"EOF";
   {
     $type $var;
     if (dwg_dynapi_entity_value ($lname, "$name", "$key", &$svar, NULL)
         && $var == $lname->$key)
       pass ();
     else
       fail ("$name.$key [$stype] $fmt != $fmt", $lname->$key, $svar);
diff --git a/src/in_dxf.c b/src/in_dxf.c
index ca00dab6..60c706a2 100644
--- a/src/in_dxf.c
+++ b/src/in_dxf.c
@@ -5688,68 +5688,68 @@ static Dxf_Pair *
 add_EVAL_Node (Dwg_Object *restrict obj, Bit_Chain *restrict dat,
                Dxf_Pair *restrict pair)
 {
   Dwg_Object_EVALUATION_GRAPH *o = obj->tio.object->tio.EVALUATION_GRAPH;
   Dwg_Data *dwg = obj->parent;
   int i = -1, j = 0;
   o->nodes = (Dwg_EVAL_Node *)xcalloc (1, sizeof (Dwg_EVAL_Node));
   o->num_nodes = 1;
   if (!o->nodes)
     {
       return NULL;
     }
   while (pair != NULL && pair->code != 0)
     {
       switch (pair->code)
         {
         case 91:
           i++;
           o->nodes = (Dwg_EVAL_Node *)realloc (
               o->nodes, (i + 1) * sizeof (Dwg_EVAL_Node));
           if (!o->nodes)
             break;
           o->num_nodes = i + 1;
           o->nodes[i].id = pair->value.i;
           LOG_TRACE ("%s.nodes[%d].id = %d [BL %d]\n", obj->name, i,
                      pair->value.i, pair->code);
           break;
         case 93: // must be 32
           o->nodes[i].edge_flags = pair->value.i;
           LOG_TRACE ("%s.nodes[%d].edge_flags = %d [BL %d]\n", obj->name, i,
                      pair->value.i, pair->code);
           break;
         case 95:
           o->nodes[i].edge_flags = pair->value.i;
           if (pair->value.i != 32)
-            LOG_WARN ("%s.nodes[%d].edge_flags = %d [BL %d] != 32\n",
+            LOG_WARN ("%s.nodes[%d].edge_flags = %d [BL %d] != 32",
                       obj->name, i, pair->value.i, pair->code)
           else
             LOG_TRACE ("%s.nodes[%d].edge_flags = %d [BL %d]\n", obj->name, i,
                        pair->value.i, pair->code)
           break;
         case 360:
           o->nodes[i].evalexpr
               = dwg_add_handleref (dwg, 5, pair->value.u, obj);
           LOG_TRACE ("%s.nodes[%d].evalexpr = " FORMAT_REF " [H %d]\n",
                      obj->name, i, ARGS_REF (o->nodes[i].evalexpr),
                      pair->code);
           break;
         case 92:
           if (j > 3) // 0 - 3
             {        // list of edges
               return add_EVAL_Edge (obj, dat, pair);
             }
           o->nodes[i].node[j] = pair->value.i;
           LOG_TRACE ("%s.nodes[%d].edge[%d] = %d [BL %d]\n", obj->name, i, j,
                      pair->value.i, pair->code);
           j++;
           break;
         default:
           LOG_ERROR ("Unknown DXF code %d for %s", pair->code, obj->name);
           return NULL;
         }
       dxf_free_pair (pair);
       pair = dxf_read_pair (dat);
     }
   LOG_TRACE ("%s.num_nodes = %d [BL]\n", obj->name, o->num_nodes);
   return pair;
 }
diff --git a/src/in_json.c b/src/in_json.c
index acbfbdf4..90f40f6e 100644
--- a/src/in_json.c
+++ b/src/in_json.c
@@ -1142,152 +1142,171 @@ static int
 json_HEADER (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,
              jsmntokens_t *restrict tokens)
 {
   const char *section = "HEADER";
   const char *name = section;
   jsmntok_t *t = &tokens->tokens[tokens->index];
   // Dwg_Header_Variables *_obj = &dwg->header_vars;
   Dwg_Object *obj = NULL;
   int size = t->size;
 
   if (t->type != JSMN_OBJECT)
     {
       LOG_ERROR ("Unexpected %s at %u of %ld tokens, expected %s OBJECT",
                  t_typename[t->type], tokens->index, tokens->num_tokens,
                  section);
       json_advance_unknown (dat, tokens, t->type, 0);
       return DWG_ERR_INVALIDTYPE;
     }
   LOG_TRACE ("\n%s pos:%d [%d keys]\n--------------------\n", section,
              tokens->index, t->size);
   tokens->index++;
   for (int i = 0; i < size; i++)
     {
       char key[80];
       Dwg_DYNAPI_field *f;
 
       json_fixed_key (key, dat, tokens);
       JSON_TOKENS_CHECK_OVERFLOW_ERR
       t = &tokens->tokens[tokens->index];
       f = (Dwg_DYNAPI_field *)dwg_dynapi_header_field (key);
       if (!f)
         {
           if (t->type == JSMN_ARRAY && strEQc (key, "layer_colors"))
             {
               tokens->index++;
               for (int index = 0; index < MAX (t->size, 128); index++)
                 {
                   dwg->header_vars.layer_colors[index]
                       = (BITCODE_RS)json_long (dat, tokens);
                   LOG_TRACE ("%s: " FORMAT_RS " [RS]\n", key,
                              dwg->header_vars.layer_colors[index]);
                 }
               JSON_TOKENS_CHECK_OVERFLOW_ERR;
             }
           else
             {
               LOG_WARN ("Unknown key HEADER.%s", key)
               json_advance_unknown (dat, tokens, t->type, 0);
               continue;
             }
         }
       else if (t->type == JSMN_PRIMITIVE
                && (strEQc (f->type, "BD") || strEQc (f->type, "RD")))
         {
           double num = json_float (dat, tokens);
           LOG_TRACE ("%s: " FORMAT_RD " [%s]\n", key, num, f->type)
           dwg_dynapi_header_set_value (dwg, key, &num, 0);
         }
       else if (t->type == JSMN_PRIMITIVE
                && (strEQc (f->type, "RC") || strEQc (f->type, "B")
                    || strEQc (f->type, "BB") || strEQc (f->type, "RS")
                    || strEQc (f->type, "BS") || strEQc (f->type, "RL")
                    || strEQc (f->type, "BL") || strEQc (f->type, "RSd")
                    || strEQc (f->type, "BLd") || strEQc (f->type, "BSd")))
         {
           long num = json_long (dat, tokens);
           LOG_TRACE ("%s: %ld [%s]\n", key, num, f->type)
           dwg_dynapi_header_set_value (dwg, key, &num, 0);
         }
       else if (t->type == JSMN_PRIMITIVE
                && (strEQc (f->type, "RLL") || strEQc (f->type, "BLL")))
         {
           uint64_t num = json_longlong (dat, tokens);
           LOG_TRACE ("%s: " FORMAT_RLL " [%s]\n", key, num, f->type)
           dwg_dynapi_header_set_value (dwg, key, &num, 0);
         }
       else if (t->type == JSMN_STRING
                && (strEQc (f->type, "TV") || strEQc (f->type, "T")))
         {
           size_t len;
           char *str = json_string (dat, tokens);
           LOG_TRACE ("%s: \"%s\" [%s]\n", key, str, f->type);
           if (dwg->header.version < R_13b1 && strEQc (key, "MENU")
               && (len = strlen (str) > 15))
             { // split into MENU + MENUEXT
               strncpy ((char *)dwg->header_vars.MENUEXT, &str[15], 45);
               str[15] = '\0';
               dwg->header_vars.MENU = strdup (str);
               dwg->header_vars.MENUEXT[45] = '\0';
             }
           else
             dwg_dynapi_header_set_value (dwg, key, &str, 1);
           free (str);
         }
       else if (t->type == JSMN_ARRAY
                && (strEQc (f->type, "3BD") || strEQc (f->type, "3RD")
                    || strEQc (f->type, "3DPOINT") || strEQc (f->type, "BE")
                    || strEQc (f->type, "3BD_1")))
         {
           BITCODE_3DPOINT pt;
           json_3DPOINT (dat, tokens, name, key, f->type, &pt);
           dwg_dynapi_header_set_value (dwg, key, &pt, 1);
         }
       else if (t->type == JSMN_ARRAY
                && (strEQc (f->type, "2BD") || strEQc (f->type, "2RD")
                    || strEQc (f->type, "2DPOINT")
                    || strEQc (f->type, "2BD_1")))
         {
           BITCODE_2DPOINT pt;
           json_2DPOINT (dat, tokens, name, key, f->type, &pt);
           dwg_dynapi_header_set_value (dwg, key, &pt, 1);
         }
+      else if (t->type == JSMN_ARRAY
+               && (strEQc (f->type, "BS") || strEQc (f->type, "RS")))
+        {
+          int size1 = t->size;
+          BITCODE_BS *nums = (BITCODE_BS *)calloc (f->size, 1);
+          tokens->index++;
+          for (int k = 0; k < size1; k++)
+            {
+              JSON_TOKENS_CHECK_OVERFLOW_ERR
+              nums[k] = (BITCODE_BS)json_long (dat, tokens);
+              LOG_TRACE ("%s.%s[%d]: " FORMAT_BS " [%s]\n", name, key, k,
+                             nums[k], f->type);
+            }
+          if (!size1)
+            LOG_TRACE ("%s.%s: [%s] empty\n", name, key, f->type);
+          dwg_dynapi_header_set_value (dwg, key, &nums, 1);
+          if (!f->is_malloc)
+            free (nums);
+        }
       else if (strEQc (f->type, "TIMEBLL") || strEQc (f->type, "TIMERLL"))
         {
           BITCODE_TIMEBLL date = { 0 };
           json_TIMEBLL (dat, tokens, key, &date);
           dwg_dynapi_header_set_value (dwg, key, &date, 0);
         }
       else if (strEQc (f->type, "CMC"))
         {
           BITCODE_CMC color = { 0 };
           json_CMC (dat, dwg, tokens, name, key, &color);
           dwg_dynapi_header_set_value (dwg, key, &color, 0);
         }
       else if (t->type == JSMN_ARRAY && strEQc (f->type, "H"))
         {
           BITCODE_H hdl
               = json_HANDLE (dat, dwg, tokens, section, key, NULL, -1);
           if (hdl)
             dwg_dynapi_header_set_value (dwg, key, &hdl, 0);
         }
       //...
       else if (t->type == JSMN_OBJECT && strEQc (key, "CLASSES"))
         {
           LOG_WARN ("Unexpected next section %s", key)
           tokens->index--;
           tokens->index--;
           return 0;
         }
       else
         {
           LOG_WARN ("Unhandled %s [%s] with %s", key, f->type,
                     t_typename[t->type])
           tokens->index++;
           continue;
         }
     }
   LOG_TRACE ("End of %s\n", section)
   // the key
   tokens->index--;
   return 0;
 }
@@ -2078,793 +2097,902 @@ static int
 _set_struct_field (Bit_Chain *restrict dat, const Dwg_Object *restrict obj,
                    jsmntokens_t *restrict tokens, void *restrict _obj,
                    const char *restrict name, const char *restrict key,
                    const Dwg_DYNAPI_field *restrict fields)
 {
   Dwg_Data *restrict dwg = obj->parent;
   const Dwg_DYNAPI_field *f = (Dwg_DYNAPI_field *)fields;
   const jsmntok_t *t = &tokens->tokens[tokens->index];
   int error = 0;
   LOG_INSANE ("-search %s key %s: %s %.*s\n", name, key, t_typename[t->type],
               t->end - t->start, &dat->chain[t->start]);
   JSON_TOKENS_CHECK_OVERFLOW_ERR;
   for (; f->name; f++)
     {
       if (strEQ (f->name, key))
         break;
     }
   // Found common, subclass or entity key, check types
   if (f && f->name)
     {
       LOG_INSANE ("-found %s [%s] %s\n", f->name, f->type,
                   t_typename[t->type]);
       if (t->type == JSMN_PRIMITIVE
           && (strEQc (f->type, "BD") || strEQc (f->type, "RD")
               || strEQc (f->type, "BT")))
         {
           double num = json_float (dat, tokens);
           JSON_TOKENS_CHECK_OVERFLOW_ERR;
           LOG_TRACE ("%s.%s: %f [%s]\n", name, key, num, f->type);
           dwg_dynapi_field_set_value (dwg, _obj, f, &num, 0);
         }
       // all numfields are calculated from actual array sizes
       // for easier adding or deleting entries.
       else if (t->type == JSMN_PRIMITIVE && memBEGINc (key, "num_"))
         {
           tokens->index++;
           JSON_TOKENS_CHECK_OVERFLOW_ERR;
           LOG_TRACE ("%s.%s: %.*s (ignored)\n", name, key, t->end - t->start,
                      &dat->chain[t->start]);
         }
       else if (t->type == JSMN_PRIMITIVE
                && (strEQc (f->type, "RC") || strEQc (f->type, "B")
                    || strEQc (f->type, "BB") || strEQc (f->type, "RS")
                    || strEQc (f->type, "BS") || strEQc (f->type, "RL")
                    || strEQc (f->type, "BL") || strEQc (f->type, "BLd")
                    || strEQc (f->type, "BSd") || strEQc (f->type, "RCd")
                    || strEQc (f->type, "RSd") || strEQc (f->type, "4BITS")))
         {
           long num = json_long (dat, tokens);
           JSON_TOKENS_CHECK_OVERFLOW_ERR
           LOG_TRACE ("%s.%s: %ld [%s]\n", name, key, num, f->type);
           dwg_dynapi_field_set_value (dwg, _obj, f, &num, 0);
           if (strEQc (name, "JUMP") && strEQc (key, "jump_address_raw"))
             {
               json_fixup_JUMP ((Dwg_Entity_JUMP *)_obj);
               LOG_TRACE ("%s.%s: 0x%lx [RLx]\n", name, key, num);
             }
         }
       else if (t->type == JSMN_PRIMITIVE
                && (strEQc (f->type, "RLL") || strEQc (f->type, "BLL")))
         {
           uint64_t num = json_long (dat, tokens);
           JSON_TOKENS_CHECK_OVERFLOW_ERR
           LOG_TRACE ("%s.%s: " FORMAT_RLL " [%s]\n", name, key, num, f->type);
           dwg_dynapi_field_set_value (dwg, _obj, f, &num, 0);
         }
       // TFF not yet in dynapi.c
       else if (t->type == JSMN_STRING
                && (strEQc (f->type, "TV") || strEQc (f->type, "T")
                    || strEQc (f->type, "TF") || strEQc (f->type, "TU")))
         {
           char *str = json_string (dat, tokens);
           size_t len = strlen (str);
           JSON_TOKENS_CHECK_OVERFLOW_ERR
           if (f->dxf == 310) // is BINARY. TODO: TABLE/FIELD *.data_date
             {
               // convert from hex
               size_t blen = len / 2;
               size_t read;
               unsigned char *buf
                   = len ? (unsigned char *)malloc (blen + 1) : NULL;
               char *pos = str;
               char *old;
               if (buf)
                 {
                   if ((read = in_hex2bin (buf, pos, blen) != blen))
                     LOG_ERROR ("in_hex2bin with key %s at pos %zu of %zu", key,
                                read, blen);
                   buf[blen] = '\0';
                   LOG_TRACE ("%s.%s: '%.*s'... [BINARY %zu]\n", name, key,
                              MIN ((int)len, 60), str, len);
                 }
               free (str);
               json_set_sizefield (_obj, fields, key, blen);
               // set the ptr directly, no alloc, no conversion.
               old = &((char *)_obj)[f->offset];
               memcpy (old, &buf, f->size);
             }
           // is r11 fixed size string? (tables and controls,
           // marked as TV, not TF)
           else if (dwg->header.from_version <= R_12
                    && (dwg_obj_is_table (obj) || dwg_obj_is_control (obj)))
             {
               char *old;
               // sizes:
               // 16: DIMSTYLE.DIM*
               // 32: *.name
               // 48: LTYPE.description
               // 64: STYLE.font_file, bigfont_file
               // 66: DIMSTYLE.DIMBLK2_T
               const int k = strEQc (key, "name")               ? 32
                             : obj->fixedtype == DWG_TYPE_LTYPE ? 48
                             : obj->fixedtype == DWG_TYPE_DIMSTYLE
                                     && strEQc (key, "DIMBLK2_T")
                                 ? 66
                             : obj->fixedtype == DWG_TYPE_DIMSTYLE ? 16
                                                                   : 64;
               tokens->index--;
               free (str);
               str = json_fixed_string (dat, k, tokens);
               LOG_TRACE ("%s.%s: \"%s\" [TF %d %d]\n", name, key, str, k,
                          f->dxf);
               old = &((char *)_obj)[f->offset];
               memcpy (old, &str, sizeof (char *));
             }
           else if (strEQc (f->type, "TF")) // oleclient, strings_area, ...
                                            // fixup size field
             {
               char *old;
               if (strEQc (key, "strings_area"))
                 {
                   const size_t k
                       = dwg->header.from_version > R_2004 ? 512 : 256;
                   const size_t blen = len / 2;
                   // binary hexstring
                   BITCODE_TF buf = (BITCODE_TF)malloc (blen);
                   len = in_hex2bin (buf, str, blen);
                   if (len != blen)
                     LOG_ERROR ("in_hex2bin with key %s at pos %zu of %zu", key,
                                len, blen);
                   memcpy (str, buf, len);
                   free (buf);
                   if (len > k)
                     {
                       LOG_ERROR ("Illegal %s.%s length %zu > %zu, stripped",
                                  name, key, len, k);
                       len = k;
                     }
                   else if (len != k)
                     {
                       str = (char *)realloc (str, k);
                       memset (&str[len + 1], 0, k - len - 1);
                     }
                 }
               else if (f->size > sizeof (char *))
                 {
                   str = (char *)realloc (str, f->size);
                   memset (&str[len + 1], 0, f->size - len - 1);
                 }
               LOG_TRACE ("%s.%s: \"%s\" [%s %d]\n", name, key, str, f->type,
                          f->size);
               if (strNE (key, "strings_area"))
                 json_set_sizefield (_obj, fields, key, len);
               old = &((char *)_obj)[f->offset];
               memcpy (old, &str, sizeof (char *));
               // dwg_dynapi_field_set_value (dwg, _obj, f, &str, 1);
             }
           else
             {
               LOG_TRACE ("%s.%s: \"%s\" [%s] len=%d\n", name, key, str,
                          f->type, (int)len);
               dwg_dynapi_field_set_value (dwg, _obj, f, &str, 1);
               free (str);
             }
         }
+      // arrays
       else if (t->type == JSMN_ARRAY
                && (strEQc (f->type, "3BD") || strEQc (f->type, "3RD")
                    || strEQc (f->type, "3DPOINT") || strEQc (f->type, "BE")
                    || strEQc (f->type, "3BD_1")))
         {
           BITCODE_3DPOINT pt;
           json_3DPOINT (dat, tokens, name, key, f->type, &pt);
           JSON_TOKENS_CHECK_OVERFLOW_ERR
           dwg_dynapi_field_set_value (dwg, _obj, f, &pt, 1);
         }
       else if (t->type == JSMN_ARRAY
                && (strEQc (f->type, "2BD") || strEQc (f->type, "2RD")
                    || strEQc (f->type, "2DPOINT")
                    || strEQc (f->type, "2BD_1")))
         {
           BITCODE_2DPOINT pt;
           json_2DPOINT (dat, tokens, name, key, f->type, &pt);
           JSON_TOKENS_CHECK_OVERFLOW_ERR
           dwg_dynapi_field_set_value (dwg, _obj, f, &pt, 1);
         }
       else if (strEQc (f->type, "TIMEBLL") || strEQc (f->type, "TIMERLL"))
         {
           static BITCODE_TIMEBLL date = { 0, 0, 0 };
           json_TIMEBLL (dat, tokens, key, &date);
           JSON_TOKENS_CHECK_OVERFLOW_ERR
           dwg_dynapi_field_set_value (dwg, _obj, f, &date, 1);
         }
       else if (strEQc (f->type, "CMC"))
         {
           BITCODE_CMC color = { 0, 0, 0, 0, 0, NULL, NULL, NULL, 0, 0, 0 };
           json_CMC (dat, dwg, tokens, name, key, &color);
           JSON_TOKENS_CHECK_OVERFLOW_ERR
           dwg_dynapi_field_set_value (dwg, _obj, f, &color, 1);
         }
       else if (t->type == JSMN_ARRAY && strEQc (f->type, "H"))
         {
           BITCODE_H hdl;
           hdl = json_HANDLE (dat, dwg, tokens, name, key, obj, -1);
           JSON_TOKENS_CHECK_OVERFLOW_ERR
           if (hdl)
             dwg_dynapi_field_set_value (dwg, _obj, f, &hdl, 1);
         }
       else if (t->type == JSMN_ARRAY && strEQc (f->type, "H*"))
         {
           BITCODE_BL size1 = t->size;
           BITCODE_H *hdls;
           if (memBEGINc (name, "DICTIONARY") && strEQc (key, "itemhandles"))
             {
               LOG_ERROR ("Illegal old json format");
               return DWG_ERR_INVALIDDWG;
             }
           hdls
               = size1 ? (BITCODE_H *)calloc (size1, sizeof (BITCODE_H)) : NULL;
           json_set_numfield (_obj, fields, key, (long)size1);
           tokens->index++;
           for (int k = 0; k < t->size; k++)
             {
               BITCODE_H hdl;
               JSON_TOKENS_CHECK_OVERFLOW_ERR
               hdl = json_HANDLE (dat, dwg, tokens, name, key, obj, k);
               if (k < (int)size1)
                 {
                   if (hdl)
                     hdls[k] = hdl;
                   else
                     hdls[k] = dwg_add_handleref (dwg, 0, 0, NULL);
                 }
               else
                 LOG_WARN ("ignored");
             }
           if (!size1)
             LOG_TRACE ("%s.%s: [%s] empty\n", name, key, f->type);
           // memcpy (&((char *)_obj)[f->offset], &hdls, sizeof (hdls));
           dwg_dynapi_field_set_value (dwg, _obj, f, &hdls, 1);
         }
       else if (t->type == JSMN_ARRAY
                && (strEQc (f->type, "T*") || strEQc (f->type, "TV*")))
         {
           int skip = 0;
           BITCODE_BL size1 = t->size;
           BITCODE_T *elems;
           if (memBEGINc (name, "DICTIONARY") && strEQc (key, "texts"))
             {
               LOG_ERROR ("Illegal old json format");
               return DWG_ERR_INVALIDDWG;
             }
           elems
               = size1 ? (BITCODE_T *)calloc (size1, sizeof (BITCODE_T)) : NULL;
           json_set_numfield (_obj, fields, key, (long)size1);
           tokens->index++;
           for (int k = 0; k < t->size; k++)
             {
               JSON_TOKENS_CHECK_OVERFLOW_ERR
               if (k < (int)size1)
                 {
                   elems[k] = json_string (dat, tokens);
                   LOG_TRACE ("%s.%s[%d]: \"%s\" [%s]\n", name, key, k,
                              elems[k], f->type);
                 }
               else
                 {
                   tokens->index++;
                   t = &tokens->tokens[tokens->index];
                   LOG_WARN ("%s.%s[%d]: \"%.*s\" [%s] ignored", name, key, k,
                             t->end - t->start, &dat->chain[t->start], f->type);
                 }
             }
           if (!t->size)
             LOG_TRACE ("%s.%s: [%s] empty\n", name, key, f->type);
           dwg_dynapi_field_set_value (dwg, _obj, f, &elems, 1);
         }
       else if (t->type == JSMN_ARRAY
                && (strEQc (f->type, "3DPOINT*") || strEQc (f->type, "3BD*")))
         {
           int size1 = t->size;
           BITCODE_3DPOINT *pts
               = size1 ? (BITCODE_3BD *)calloc (size1, sizeof (BITCODE_3BD))
                       : NULL;
           json_set_numfield (_obj, fields, key, size1);
           tokens->index++;
           for (int k = 0; k < size1; k++)
             {
               JSON_TOKENS_CHECK_OVERFLOW_ERR;
               json_3DPOINT (dat, tokens, name, key, f->type, &pts[k]);
             }
           if (!size1)
             LOG_TRACE ("%s.%s: [%s] empty\n", name, key, f->type);
           dwg_dynapi_field_set_value (dwg, _obj, f, &pts, 1);
         }
       else if (t->type == JSMN_ARRAY && strEQc (f->type, "2RD*"))
         {
-          int size1 = t->size;
+          const int size1 = t->size;
           BITCODE_2DPOINT *pts = size1 ? (BITCODE_2DPOINT *)calloc (
                                      size1, sizeof (BITCODE_2DPOINT))
                                        : NULL;
           json_set_numfield (_obj, fields, key, size1);
           tokens->index++;
           for (int k = 0; k < size1; k++)
             {
               JSON_TOKENS_CHECK_OVERFLOW_ERR;
               json_2DPOINT (dat, tokens, name, key, f->type, &pts[k]);
             }
           if (!size1)
             LOG_TRACE ("%s.%s: [%s] empty\n", name, key, f->type);
           dwg_dynapi_field_set_value (dwg, _obj, f, &pts, 1);
         }
-      else if (t->type == JSMN_ARRAY && strEQc (f->type, "BD*"))
+      else if (t->type == JSMN_ARRAY &&
+               (strEQc (f->type, "BD*") || strEQc (f->type, "RD")))
         {
-          int size1 = t->size;
-          BITCODE_BD *nums
-              = size1 ? (BITCODE_BD *)calloc (size1, sizeof (BITCODE_BD))
-                      : NULL;
-          json_set_numfield (_obj, fields, key, size1);
+          const int size1 = t->size;
+          const int max_k
+              = !f->is_malloc ? (int)(f->size / sizeof (BITCODE_BD)) : size1;
+          BITCODE_BD *nums;
+          if (f->is_malloc)
+            {
+              nums = size1 ? (BITCODE_BD *)calloc (size1, sizeof (BITCODE_BD))
+                : NULL;
+              json_set_numfield (_obj, fields, key, size1);
+            }
+          else
+            nums = (BITCODE_BD *)calloc (f->size, 1);
           tokens->index++;
           for (int k = 0; k < size1; k++)
             {
               JSON_TOKENS_CHECK_OVERFLOW_ERR
-              nums[k] = json_float (dat, tokens);
-              LOG_TRACE ("%s.%s[%d]: %f [%s]\n", name, key, k, nums[k],
-                         f->type);
+              if (k < max_k)
+                {
+                  nums[k] = json_float (dat, tokens);
+                  LOG_TRACE ("%s.%s[%d]: %f [%s]\n", name, key, k, nums[k],
+                             f->type);
+                }
             }
           if (!size1)
-            LOG_TRACE ("%s.%s: [%s] empty\n", name, key, f->type);
-          dwg_dynapi_field_set_value (dwg, _obj, f, &nums, 1);
+            {
+              LOG_TRACE ("%s.%s: [%s] empty\n", name, key, f->type);
+            }
+          else
+            {
+              if (f->is_malloc) // BD*, just copy the pointer
+                dwg_dynapi_field_set_value (dwg, _obj, f, &nums, 1);
+              else
+                { // copy all values
+                  dwg_dynapi_field_set_value (dwg, _obj, f, nums, 1);
+                  free (nums);
+                }
+            }
         }
-      else if (t->type == JSMN_ARRAY && strEQc (f->type, "BL*"))
+      else if (t->type == JSMN_ARRAY
+               && (strEQc (f->type, "BL*") || strEQc (f->type, "BLd")))
         {
-          int size1 = t->size;
-          BITCODE_BL *nums
-              = size1 ? (BITCODE_BL *)calloc (size1, sizeof (BITCODE_BL))
-                      : NULL;
-          json_set_numfield (_obj, fields, key, size1);
+          const int size1 = t->size;
+          const int max_k
+              = !f->is_malloc ? (int)(f->size / sizeof (BITCODE_BL)) : size1;
+          BITCODE_BL *nums;
+          if (f->is_malloc)
+            {
+              nums = size1
+                ? (BITCODE_BL *)calloc (size1, sizeof (BITCODE_BL))
+                : NULL;
+              json_set_numfield (_obj, fields, key, size1);
+            }
+          else
+            nums = (BITCODE_BL *)calloc (f->size, 1);            
           tokens->index++;
           for (int k = 0; k < size1; k++)
             {
               JSON_TOKENS_CHECK_OVERFLOW_ERR
-              nums[k] = (BITCODE_BL)json_long (dat, tokens);
-              LOG_TRACE ("%s.%s[%d]: " FORMAT_BL " [BL]\n", name, key, k,
-                         nums[k]);
+              if (k < max_k)
+                {
+                  nums[k] = (BITCODE_BL)json_long (dat, tokens);
+                  if (strEQc (f->type, "BL*"))
+                    {
+                      LOG_TRACE ("%s.%s[%d]: " FORMAT_BL " [%s]\n", name, key, k,
+                                 nums[k], f->type);
+                    }
+                  else
+                    {
+                      LOG_TRACE ("%s.%s[%d]: " FORMAT_BLd " [%s]\n", name, key, k,
+                                 nums[k], f->type);
+                    }
+                }
+              else
+                {
+                  tokens->index++;
+                  LOG_TRACE ("%s.%s[%d]: [%s] ignored\n", name, key, k, f->type);
+                }
             }
           if (!size1)
-            LOG_TRACE ("%s.%s: [%s] empty\n", name, key, f->type);
-          dwg_dynapi_field_set_value (dwg, _obj, f, &nums, 1);
+            {
+              LOG_TRACE ("%s.%s: [%s] empty\n", name, key, f->type);
+            }
+          else
+            {
+              if (f->is_malloc) // BL*
+                dwg_dynapi_field_set_value (dwg, _obj, f, &nums, 1);
+              else
+                {
+                  dwg_dynapi_field_set_value (dwg, _obj, f, nums, 1);
+                  free (nums);
+                }
+            }
+        }
+      else if (t->type == JSMN_ARRAY
+               && (strEQc (f->type, "BS")
+                   || strEQc (f->type, "BS*")
+                   || strEQc (f->type, "RS")))
+        {
+          const int size1 = t->size;
+          const int max_k
+              = !f->is_malloc ? (int)(f->size / sizeof (BITCODE_BS)) : size1;
+          BITCODE_BS *nums;
+          if (f->is_malloc)
+            {
+              nums = size1 ? (BITCODE_BS *)calloc (size1, sizeof (BITCODE_BS))
+                : NULL;
+              json_set_numfield (_obj, fields, key, size1);
+            }
+          else
+            nums = (BITCODE_BS *)calloc (f->size, 1);
+          tokens->index++;
+          for (int k = 0; k < size1; k++)
+            {
+              JSON_TOKENS_CHECK_OVERFLOW_ERR
+              if (k < max_k)
+                {
+                  nums[k] = (BITCODE_BS)json_long (dat, tokens);
+                  LOG_TRACE ("%s.%s[%d]: " FORMAT_BS " [%s]\n", name, key, k,
+                             nums[k], f->type);
+                }
+              else
+                {
+                  tokens->index++;
+                  LOG_TRACE ("%s.%s[%d]: [%s] ignored\n", name, key, k, f->type);
+                }
+            }
+          if (!size1)
+            {
+              LOG_TRACE ("%s.%s: [%s] empty\n", name, key, f->type);
+            }
+          else
+            {
+              if (f->is_malloc) // BS*
+                dwg_dynapi_field_set_value (dwg, _obj, f, &nums, 1);
+              else
+                {
+                  dwg_dynapi_field_set_value (dwg, _obj, f, nums, 1);
+                  free (nums);
+                }
+            }
         }
       else if (t->type == JSMN_ARRAY && strEQc (key, "xdata")
                && strEQc (name, "XRECORD"))
         {
           error |= json_xdata (dat, dwg, tokens, (Dwg_Object_XRECORD *)_obj);
           JSON_TOKENS_CHECK_OVERFLOW_ERR
         }
       else if (t->type == JSMN_ARRAY && strEQc (key, "acis_data")
                && strEQc (f->type, "RC*"))
         {
           error |= json_acis_data (dat, dwg, tokens, obj);
           JSON_TOKENS_CHECK_OVERFLOW_ERR;
         }
       else if (t->type == JSMN_ARRAY && strEQc (key, "encr_sat_data")
                && strEQc (f->type, "char **"))
         {
           BITCODE_BL num_blocks = t->size;
           BITCODE_BL *block_size
               = (BITCODE_BL *)calloc (num_blocks + 1, sizeof (BITCODE_BL));
           unsigned char **data = (unsigned char **)calloc (
               num_blocks + 1, sizeof (unsigned char *));
           tokens->index++;
           LOG_TRACE ("num_blocks: " FORMAT_BL " [BL]\n", num_blocks);
           for (BITCODE_BL k = 0; k < num_blocks; k++)
             {
               size_t len;
               JSON_TOKENS_CHECK_OVERFLOW_ERR
               data[k] = json_binary (dat, tokens, "encr_sat_data", &len);
               block_size[k] = (BITCODE_BL)len;
               LOG_TRACE ("block_size[%d]: %zu [BL]\n", k, len);
             }
           block_size[num_blocks] = 0;
           LOG_TRACE ("block_size[%d]: 0 [BL]\n", num_blocks);
           dwg_dynapi_entity_set_value (_obj, obj->name, "num_blocks",
                                        &num_blocks, true);
           dwg_dynapi_entity_set_value (_obj, obj->name, "block_size",
                                        &block_size, true);
           dwg_dynapi_field_set_value (dwg, _obj, f, &data, true);
         }
       // subclass arrays:
       else if (t->type == JSMN_ARRAY && memBEGINc (f->type, "Dwg_"))
         {
           int num_elems = t->size;
           int size_elem;
           char *elems;
           const Dwg_DYNAPI_field *sfields;
           // strip off Dwg_ and final *
           // e.g. 'Dwg_MLINESTYLE_line*' => 'MLINESTYLE_line'
           char *subclass = dwg_dynapi_subclass_name (f->type);
           if (!subclass)
             {
               LOG_ERROR ("Unknown subclass type %s", f->type);
               goto unknown_ent;
             }
           size_elem = dwg_dynapi_fields_size (subclass);
           sfields = dwg_dynapi_subclass_fields (subclass);
           if (!size_elem || !sfields)
             {
               LOG_ERROR ("Unknown subclass name %s", subclass);
               free (subclass);
               goto unknown_ent;
             }
           LOG_TRACE ("new subclass %s %s [%d elems with size %d]\n", name,
                      subclass, num_elems, size_elem);
           json_set_numfield (_obj, fields, key, num_elems);
           if (strEQc (subclass, "MLINE_line") && num_elems)
             {
               Dwg_Entity_MLINE *o = obj->tio.entity->tio.MLINE;
               o->num_lines = num_elems;
               LOG_TRACE ("MLINE.num_lines = %d\n", num_elems);
             }
           if (strEQc (subclass, "DIMASSOC_Ref") && num_elems != 4)
             {
               elems = (char *)calloc (MAX (4, num_elems), size_elem);
               LOG_TRACE ("DIMASSOC num_refs = 4\n");
             }
           else
             elems = num_elems ? (char *)calloc (num_elems, size_elem) : NULL;
           dwg_dynapi_field_set_value (dwg, _obj, f, &elems, 1);
           tokens->index++;
           // array of structs
           if (!num_elems)
             LOG_TRACE ("%s: [%s] empty\n", key, f->type);
           for (int k = 0; k < num_elems; k++)
             {
               int keys;
               JSON_TOKENS_CHECK_OVERFLOW_ERR
               t = &tokens->tokens[tokens->index];
               if (t->type != JSMN_OBJECT)
                 {
                   LOG_ERROR ("Unexpected %s at %u of %ld tokens, expected "
                              "%s OBJECT. %s:%d",
                              t_typename[t->type], tokens->index,
                              tokens->num_tokens, subclass, __FUNCTION__,
                              __LINE__);
                   free (subclass);
                   json_advance_unknown (dat, tokens, t->type, 0);
                   JSON_TOKENS_CHECK_OVERFLOW_ERR
                   return DWG_ERR_INVALIDTYPE;
                 }
               LOG_TRACE ("%s.%s[%d]:\n", name, key, k);
               keys = t->size;
               tokens->index++;
               for (int ki = 0; ki < keys; ki++)
                 {
                   // separate subclass type loop
                   const Dwg_DYNAPI_field *f1;
                   char key1[80];
                   char *rest;
                   JSON_TOKENS_CHECK_OVERFLOW_ERR
                   json_fixed_key (key1, dat, tokens);
                   LOG_INSANE ("-search %s key: %s\n", subclass, key1);
                   f1 = dwg_dynapi_subclass_field (subclass, key1);
                   if (f1)
                     {
                       LOG_INSANE ("-found %s [%s]\n", f1->name, f1->type);
                       if (!_set_struct_field (dat, obj, tokens,
                                               &elems[k * size_elem], subclass,
                                               key1, sfields))
                         ++tokens->index;
                     }
                   else if ((rest = strchr (key1, '.'))) // embedded struct
                     {
                       *rest = '\0';
                       rest++;
                       f1 = dwg_dynapi_subclass_field (subclass, key1);
                       if (f1 && *rest)
                         {
                           char *sb1 = dwg_dynapi_subclass_name (f1->type);
                           const Dwg_DYNAPI_field *sfields1
                               = sb1 ? dwg_dynapi_subclass_fields (sb1) : NULL;
                           if (!sfields1
                               || !_set_struct_field (
                                   dat, obj, tokens,
                                   &elems[(k * size_elem) + f1->offset], sb1,
                                   rest, sfields1))
                             ++tokens->index;
                           free (sb1);
                         }
                     }
                   if (!f1 || !f1->name) // not found
                     {
                       LOG_ERROR ("Unknown subclass field %s.%s", subclass,
                                  key1);
                       ++tokens->index;
                     }
                 }
             }
           if (dwg_dynapi_field_set_value (dwg, _obj, f, &elems, 1))
             LOG_TRACE ("subclass %s.%s done\n", name, key);
           free (subclass);
         }
       // subclass structs (embedded):
       else if (t->type == JSMN_OBJECT && memBEGINc (f->type, "Dwg_"))
         {
           int num_keys = t->size; // div by 2 really
           // int size_struct;
           const Dwg_DYNAPI_field *sfields;
           char *subclass = dwg_dynapi_subclass_name (f->type);
           if (!subclass)
             {
               LOG_ERROR ("Unknown subclass type %s", f->type);
               goto unknown_ent;
             }
           // size_struct = dwg_dynapi_fields_size (subclass);
           sfields = dwg_dynapi_subclass_fields (subclass);
           if (!sfields)
             {
               LOG_ERROR ("Unknown subclass name %s", subclass);
               free (subclass);
               goto unknown_ent;
             }
           LOG_TRACE ("embedded struct %s %s [%d keys]\n", subclass, key,
                      num_keys / 2);
           tokens->index++;
           // a single struct
           if (!num_keys)
             LOG_TRACE ("%s: [%s] empty\n", key, f->type);
           for (int k = 0; k < num_keys; k++)
             {
               const Dwg_DYNAPI_field *f1;
               char key1[80];
               char *rest;
               JSON_TOKENS_CHECK_OVERFLOW_ERR
               json_fixed_key (key1, dat, tokens);
               LOG_INSANE ("-search %s key %s\n", subclass, key1);
               f1 = dwg_dynapi_subclass_field (subclass, key1);
               if (f1)
                 {
                   // subclass offset for _obj
                   void *off = &((char *)_obj)[f->offset + f1->offset];
                   if (!_set_struct_field (dat, obj, tokens, off, subclass,
                                           key1, sfields))
                     ++tokens->index;
                 }
               else if ((rest = strchr (key1, '.'))) // embedded struct
                 {
                   *rest = '\0';
                   rest++;
                   f1 = dwg_dynapi_subclass_field (subclass, key1);
                   if (f1 && *rest)
                     {
                       void *off = &((char *)_obj)[f->offset + f1->offset];
                       char *subclass1 = dwg_dynapi_subclass_name (f1->type);
                       const Dwg_DYNAPI_field *sfields1
                           = subclass1 ? dwg_dynapi_subclass_fields (subclass1)
                                       : NULL;
                       if (!sfields1
                           || !_set_struct_field (dat, obj, tokens, off,
                                                  subclass1, rest, sfields1))
                         ++tokens->index;
                       free (subclass1);
                     }
                 }
               if (!f1 || !f1->name) // not found
                 {
                   LOG_ERROR ("Unknown subclass field %s.%s", subclass, key1);
                   ++tokens->index;
                 }
             }
           free (subclass);
         }
       else
         {
         unknown_ent:
           LOG_ERROR ("Unknown type for %s.%s %s with %s", name, key, f->type,
                      t_typename[t->type]);
           ++tokens->index;
           JSON_TOKENS_CHECK_OVERFLOW_ERR
         }
       return error | (f->name ? 1 : 0); // found or not
     }
   else // not found
     {  // maybe it's an embedded subclass. look for the dot(s)
       int found = 0;
       char *rest = strchr ((char *)key, '.');
       while (rest)
         {
           // Currently we have 3 known static arrays, and a few embedded
           // subclasses. Color e.g.
           const Dwg_DYNAPI_field *f1;
           const char *subclass = NULL;
           JSON_TOKENS_CHECK_OVERFLOW_ERR;
           *rest = '\0';
           rest++;
           f1 = dwg_dynapi_entity_field (name, key);
           if (f1 && *rest)
             {
               void *off = &((char *)_obj)[f1->offset];
               const char *subclass1 = dwg_dynapi_subclass_name (f1->type);
               const Dwg_DYNAPI_field *sfields1
                   = subclass1 ? dwg_dynapi_subclass_fields (subclass1) : NULL;
               if (!sfields1 && subclass1)
                 sfields1 = dwg_dynapi_entity_fields (subclass1);
               if (!sfields1
                   || !_set_struct_field (dat, obj, tokens, off, subclass1,
                                          rest, sfields1))
                 ++tokens->index;
               free ((char *)subclass1);
               return error | (f1->name ? 1 : 0); // found or not
             }
           f1 = dwg_dynapi_subclass_field (name, key);
           if (f1 && *rest)
             {
               void *off = &((char *)_obj)[f1->offset];
               const char *subclass1 = dwg_dynapi_subclass_name (f1->type);
               const Dwg_DYNAPI_field *sfields1
                   = subclass1 ? dwg_dynapi_subclass_fields (subclass1) : NULL;
               if (!sfields1 && subclass1)
                 sfields1 = dwg_dynapi_entity_fields (subclass1);
               if (!sfields1
                   || !_set_struct_field (dat, obj, tokens, off, subclass1,
                                          rest, sfields1))
                 ++tokens->index;
               free ((char *)subclass1);
               return error | (f1->name ? 1 : 0); // found or not
             }
           else
             {
               // failed_key.rest.nextfieldatteept
               *(rest - 1) = '.'; // unsuccessful search, set the dot back
               rest = strchr (rest, '.');
               if (rest)
                 {
                   LOG_HANDLE ("Try next embedded struct with %s.%s\n", key,
                               rest);
                 }
               else
                 {
                   LOG_HANDLE ("No embedded struct with %s\n", key);
                 }
             }
         }
       // TODO convert embedded array, vertind[0]: 0, vertind[1]: ... to
       // normal array in json: vertind: [0, ...], and apply it here. The
       // vertind dynapi type should know if it's a reference or embedded.
 
+      /*
       // f is NULL
       if (t->type == JSMN_PRIMITIVE && memBEGINc (key, "vertind["))
         {
           f = dwg_dynapi_entity_field (name, "vertind[4]");
           if (f)
             {
               BITCODE_BS arr[4];
               int index;
               sscanf (key, "vertind[%d]", &index);
               if (index >= 0 && index < 4)
                 {
                   dwg_dynapi_field_get_value (_obj, f, &arr);
                   arr[index] = json_long (dat, tokens);
                   LOG_TRACE ("%s: %d [%s]\n", key, (int)arr[index], f->type);
                   dwg_dynapi_field_set_value (dwg, _obj, f, &arr, 0);
                 }
               else
                 {
                   tokens->index++;
                 }
               JSON_TOKENS_CHECK_OVERFLOW_ERR;
             }
         }
       else if (t->type == JSMN_PRIMITIVE && memBEGINc (key, "edge[")
                && (f = dwg_dynapi_entity_field (name, "edge[4]")))
         {
           BITCODE_BL arr[4];
           int index;
           sscanf (key, "edge[%d]", &index);
           if (index >= 0 && index < 4)
             {
               dwg_dynapi_field_get_value (_obj, f, &arr);
               arr[index] = json_long (dat, tokens);
               LOG_TRACE ("%s: %d [%s]\n", key, (int)arr[index], f->type);
               dwg_dynapi_field_set_value (dwg, _obj, f, &arr, 0);
             }
           else
             {
               tokens->index++;
             }
           JSON_TOKENS_CHECK_OVERFLOW_ERR;
         }
       else if (t->type == JSMN_ARRAY && memBEGINc (key, "workplane[")
                && (f = dwg_dynapi_entity_field (name, "workplane[3]")))
         {
           BITCODE_3BD arr[3];
           int index;
           sscanf (key, "workplane[%d]", &index);
           if (index >= 0 && index < 3)
             {
               dwg_dynapi_field_get_value (_obj, f, &arr);
               json_3DPOINT (dat, tokens, name, key, f->type, &arr[index]);
               dwg_dynapi_field_set_value (dwg, _obj, f, &arr, 0);
             }
           else
             json_advance_unknown (dat, tokens, t->type, 0);
           JSON_TOKENS_CHECK_OVERFLOW_ERR;
         }
       else if (t->type == JSMN_ARRAY && strEQc (key, "itemloc") && t->size <= 3
                && (f = dwg_dynapi_entity_field (name, "itemloc[3]")))
         {
           BITCODE_BL arr[3] = { 0 };
           tokens->index++;
           dwg_dynapi_field_get_value (_obj, f, &arr);
           for (int index = 0; index < t->size; index++)
             {
               if (index < 3)
                 {
                   arr[index] = (BITCODE_BL)json_long (dat, tokens);
                   LOG_TRACE ("%s: %d [%s]\n", key, (int)arr[index], f->type);
                 }
               else
                 tokens->index++;
             }
           dwg_dynapi_field_set_value (dwg, _obj, f, &arr, 0);
           JSON_TOKENS_CHECK_OVERFLOW_ERR;
         }
       else if (t->type == JSMN_ARRAY && strEQc (key, "node") && t->size <= 4
                && (f = dwg_dynapi_entity_field (name, "node[4]")))
         {
           BITCODE_BLd arr[4] = { 0 };
           tokens->index++;
           dwg_dynapi_field_get_value (_obj, f, &arr);
           for (int index = 0; index < MIN (t->size, 4); index++)
             {
               if (index < 4)
                 {
                   arr[index] = (BITCODE_BLd)json_long (dat, tokens);
                   LOG_TRACE ("%s: %d [%s]\n", key, (int)arr[index], f->type);
                 }
               else
                 tokens->index++;
             }
           dwg_dynapi_field_set_value (dwg, _obj, f, &arr, 0);
           JSON_TOKENS_CHECK_OVERFLOW_ERR;
         }
       else if (t->type == JSMN_STRING && strEQc (key, "revision_bytes"))
         {
           size_t len;
           unsigned char *s = json_binary (dat, tokens, "revision_bytes", &len);
           JSON_TOKENS_CHECK_OVERFLOW_ERR
           f = dwg_dynapi_entity_field (name, "revision_bytes[9]");
           if (f && len == 8)
             {
               LOG_TRACE ("%s.%s: [%s]\n", name, key, s);
               dwg_dynapi_field_set_value (dwg, _obj, f, s, true);
             }
           free (s);
         }
       else if (t->type == JSMN_ARRAY && strEQc (key, "dashes_r11")
                && t->size <= 12
                && (f = dwg_dynapi_entity_field (name, "dashes_r11[12]")))
         {
           BITCODE_RD arr[12] = { 0.0 };
           tokens->index++;
           dwg_dynapi_field_get_value (_obj, f, &arr);
           for (int index = 0; index < t->size; index++)
             {
               if (index < 12)
                 {
                   arr[index] = json_float (dat, tokens);
                   LOG_TRACE ("%s: %f [%s]\n", key, arr[index], f->type);
                 }
               else
                 tokens->index++;
             }
           dwg_dynapi_field_set_value (dwg, _obj, f, &arr, 0);
           // f = dwg_dynapi_entity_field (name, "numdashes");
           // dwg_dynapi_field_set_value (dwg, _obj, f, &t->size, 0);
           JSON_TOKENS_CHECK_OVERFLOW_ERR;
         }
+      */
       return error | (f && f->name ? 1 : 0); // found or not
     }
   return error;
 }
 
 /*
 // check both texts[] and itemhandles[]
@@ -2933,602 +3061,597 @@ static int
 json_OBJECTS (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,
               jsmntokens_t *restrict tokens)
 {
   const char *section = "OBJECTS";
   const jsmntok_t *t = &tokens->tokens[tokens->index];
   int i, size;
   if (t->type != JSMN_ARRAY || dwg->num_objects)
     {
       LOG_ERROR ("Unexpected %s at %u of %ld tokens, expected %s ARRAY",
                  t_typename[t->type], tokens->index, tokens->num_tokens,
                  section);
       json_advance_unknown (dat, tokens, t->type, 0);
       return DWG_ERR_INVALIDTYPE;
     }
   size = t->size;
   LOG_TRACE ("\n%s pos:%d [%d members]\n--------------------\n", section,
              tokens->index, size);
   tokens->index++;
   JSON_TOKENS_CHECK_OVERFLOW_ERR
   if (dwg->num_objects == 0)
     {
       // faster version of dwg_add_object()
       // round up to next REFS_PER_REALLOC
       int rounded = size;
       if (rounded % REFS_PER_REALLOC)
         rounded += REFS_PER_REALLOC - (rounded % REFS_PER_REALLOC);
       dwg->object = (Dwg_Object *)calloc (rounded, sizeof (Dwg_Object));
     }
   else
     dwg_add_object (dwg);
   if (!dwg->object)
     {
       LOG_ERROR ("Out of memory");
       return DWG_ERR_OUTOFMEM;
     }
   if (dwg->header.from_version < R_13b1)
     {
       dwg->header.section
           = (Dwg_Section *)calloc (SECTION_VX + 1, sizeof (Dwg_Section));
     }
   dwg->num_objects += size;
   for (i = 0; i < size; i++)
     {
       char name[80];
       int keys;
       int is_entity = 0;
       Dwg_Object *obj = &dwg->object[i];
       Dwg_Object_APPID *_obj = NULL;
       const Dwg_DYNAPI_field *fields = NULL, *cfields;
       const Dwg_DYNAPI_field *f;
 
       memset (name, 0, sizeof (name));
       JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
       if (i > 0)
         {
           Dwg_Object *oldobj = &dwg->object[i - 1];
           if (dwg->header.from_version >= R_13b1 && !oldobj->handle.value)
             {
               LOG_ERROR ("Required %s.handle missing, skipped", oldobj->name)
               dwg_free_object (oldobj);
               obj = oldobj;
               i--;
             }
           else if (!oldobj->type)
             {
               if (dwg->header.from_version >= R_13b1
                   || (oldobj->fixedtype != DWG_TYPE_BLOCK
                       && oldobj->fixedtype != DWG_TYPE_ENDBLK))
                 LOG_ERROR ("Required %s.type missing, skipped", oldobj->name)
               if (!oldobj->parent)
                 oldobj->parent = dwg;
               dwg_free_object (oldobj);
               obj = oldobj;
               i--;
               size--;
             }
           else if (oldobj->fixedtype == DWG_TYPE_UNUSED)
             {
               LOG_ERROR ("Required %s.fixedtype missing, skipped",
                          oldobj->name);
               if (!oldobj->parent)
                 oldobj->parent = dwg;
               dwg_free_object (oldobj);
               obj = oldobj;
               i--;
             }
           if (oldobj->fixedtype == DWG_TYPE_SEQEND)
             {
               in_postprocess_SEQEND (oldobj, 0, NULL);
             }
           /*
           else if (oldobj->fixedtype == DWG_TYPE_DICTIONARY)
             {
               in_postprocess_DICTIONARY (oldobj);
             }
           else if (oldobj->fixedtype == DWG_TYPE_DICTIONARYWDFLT)
             {
               in_postprocess_DICTIONARYWDFLT (oldobj);
             }
           */
         }
 
       memset (obj, 0, sizeof (Dwg_Object));
       t = &tokens->tokens[tokens->index];
       if (t->type != JSMN_OBJECT)
         {
           LOG_ERROR (
               "Unexpected %s at %u of %ld tokens, expected %s OBJECT. %s:%d",
               t_typename[t->type], tokens->index, tokens->num_tokens, section,
               __FUNCTION__, __LINE__);
           json_advance_unknown (dat, tokens, t->type, 0);
           JSON_TOKENS_CHECK_OVERFLOW (goto typeerr)
         }
       keys = t->size;
       LOG_HANDLE ("\n-keys: %d, object %d of %d\n", keys, i, size);
 
       tokens->index++;
       for (int j = 0; j < keys; j++)
         {
           bool saw_dxfname = false;
           char key[80];
           memset (key, 0, sizeof (key));
           LOG_INSANE ("[%d] ", j);
           JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
           json_fixed_key (key, dat, tokens);
           JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
           t = &tokens->tokens[tokens->index];
           if (strEQc (key, "object") && t->type == JSMN_STRING
               && i < (int)dwg->num_objects && !dwg->object[i].type)
             {
               int len = t->end - t->start;
               int objsize = 16;
               obj->supertype = DWG_SUPERTYPE_OBJECT;
               obj->parent = dwg;
               obj->index = i;
 
               if (len >= 80)
                 {
                   LOG_ERROR ("Illegal %s name %.*s", key, len,
                              &dat->chain[t->start])
                   obj->type = obj->fixedtype = DWG_TYPE_DUMMY;
                   // exhaust the rest
                   for (; j < keys; j++)
                     {
                       json_advance_unknown (dat, tokens, t->type, 0); // value
                       tokens->index++; // next key
                       JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
                     }
                   tokens->index--;
                   break;
                 }
               memcpy (name, &dat->chain[t->start], len);
               name[len] = '\0';
               is_entity = 0;
               fields = dwg_dynapi_entity_fields (name);
               objsize = dwg_dynapi_fields_size (name);
               if (!fields || !objsize || !is_dwg_object (name))
                 {
                   LOG_ERROR ("Unknown object %s (no fields)", name);
                   // skip_object:
                   obj->type = obj->fixedtype = DWG_TYPE_DUMMY;
                   // exhaust the rest
                   for (; j < keys; j++)
                     {
                       json_advance_unknown (dat, tokens, t->type, 0); // value
                       tokens->index++; // next key
                       JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
                     }
                   tokens->index--;
                   break;
                 }
               // crashing acad import, but dxfin might be okay
               /*
               if (is_class_unstable (name) &&
                   (strEQc (name, "TABLEGEOMETRY") ||
                    strEQc (name, "WIPEOUT")))
                 {
                   LOG_ERROR ("Unhandled object %s", name);
                   goto skip_object;
                 }
               */
               LOG_TRACE ("\nnew object %s [%d] (size: %d)\n", name, i,
                          objsize);
               obj->tio.object = (Dwg_Object_Object *)calloc (
                   1, sizeof (Dwg_Object_Object));
               obj->tio.object->dwg = dwg;
               obj->tio.object->objid = i;
               // NEW_OBJECT (dwg, obj)
               // ADD_OBJECT loop?
               _obj = (Dwg_Object_APPID *)calloc (1, objsize);
               obj->tio.object->tio.APPID = _obj;
               obj->tio.object->tio.APPID->parent = obj->tio.object;
               free (obj->name);
               obj->name = strdup (name);
               // TODO alias
               free (obj->dxfname);
               obj->dxfname = strdup (name);
               tokens->index++;
               JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
             }
           else if (strEQc (key, "entity") && t->type == JSMN_STRING
                    && i < (int)dwg->num_objects && !dwg->object[i].type)
             {
               int len = t->end - t->start;
               int objsize;
               obj->supertype = DWG_SUPERTYPE_ENTITY;
               obj->parent = dwg;
               obj->index = i;
 
               if (len >= 80)
                 {
                   LOG_ERROR ("Illegal %s name %.*s", key, len,
                              &dat->chain[t->start])
                   obj->type = obj->fixedtype = DWG_TYPE_DUMMY;
                   // exhaust the rest
                   for (; j < keys; j++)
                     {
                       json_advance_unknown (dat, tokens, t->type, 0); // value
                       tokens->index++; // next key
                       JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
                     }
                   tokens->index--;
                   break;
                 }
               memcpy (name, &dat->chain[t->start], len);
               name[len] = '\0';
               is_entity = 1;
               fields = dwg_dynapi_entity_fields (name);
               objsize = dwg_dynapi_fields_size (name);
               if (!fields || !objsize || !is_dwg_entity (name))
                 {
                   LOG_ERROR ("Unknown entity %s (no fields)", name);
                   obj->type = obj->fixedtype = DWG_TYPE_DUMMY;
                   // exhaust the rest
                   for (; j < keys; j++)
                     {
                       json_advance_unknown (dat, tokens, t->type, 0); // value
                       tokens->index++; // next key
                       JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
                     }
                   tokens->index--;
                   break;
                 }
               LOG_TRACE ("\nnew entity %s [%d] (size: %d)\n", name, i,
                          objsize);
               obj->tio.entity = (Dwg_Object_Entity *)calloc (
                   1, sizeof (Dwg_Object_Entity));
               obj->tio.entity->dwg = dwg;
               obj->tio.entity->objid = i;
               // NEW_ENTITY (dwg, obj)
               // ADD_ENTITY loop?
               _obj = (Dwg_Object_APPID *)calloc (1, objsize);
               obj->tio.entity->tio.POINT = (Dwg_Entity_POINT *)_obj;
               obj->tio.entity->tio.POINT->parent = obj->tio.entity;
               free (obj->name);
               obj->name = strdup (name);
               // if different, the alias is done via extra dxfname key (below)
               free (obj->dxfname);
               obj->dxfname = strdup (name);
               tokens->index++;
               JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
             }
           else if (!obj || !fields)
             {
               LOG_ERROR ("Required object or entity key missing");
               json_advance_unknown (dat, tokens, t->type, 0);
               JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
             }
           else if (strEQc (key, "dxfname"))
             {
               free (obj->dxfname);
               saw_dxfname = true;
               obj->dxfname = json_string (dat, tokens);
               LOG_TRACE ("dxfname: %s\n", obj->dxfname)
               if (!obj->dxfname)
                 obj->dxfname = strdup (name);
 
               // Some objects have various subtypes under one name.
               // TODO OBJECTCONTEXTDATA, ...
             }
           else if (strEQc (key, "index")
                    && strNE (name, "TableCellContent_Attr"))
             {
               BITCODE_RL index = (BITCODE_RL)json_long (dat, tokens);
               if (dat->from_version < R_13b1)
                 {
                   if (index > 5)
                     index = obj->index; // we added 2 mspace blocks (type 0)
                                         // in-between
                 }
               if (obj->index != index)
                 LOG_WARN ("Ignore wrong %s.index %d, expected %d", name, index,
                           obj->index)
               LOG_TRACE ("index: %d\n", obj->index)
             }
           else if (strEQc (key, "type") && !obj->type)
             {
               int isent;
               const char *dxfname;
               obj->type = json_long (dat, tokens);
               JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
 
               if (!dwg_object_name (name, &dxfname, &obj->fixedtype, &isent,
                                     NULL))
                 {
                   LOG_ERROR ("Unknown object %s failed dwg_object_name()",
                              name);
                   // exhaust the rest
                   for (; j < keys; j++)
                     {
                       json_advance_unknown (dat, tokens, t->type, 0); // value
                       tokens->index++; // next key
                       JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
                     }
                   tokens->index--;
                   break;
                 }
               else
                 {
                   if (obj->dxfname && strNE (obj->dxfname, dxfname))
                     {
                       if (memBEGINc (dxfname, "UNKNOWN_") || !saw_dxfname)
                         LOG_TRACE ("Changed dxfname %s => %s\n", obj->dxfname,
                                    dxfname)
                       else
                         LOG_WARN ("Changed wrong dxfname %s => %s",
                                   obj->dxfname, dxfname)
                     }
                   free (obj->dxfname);
                   obj->dxfname = strdup (dxfname);
                   if (obj->type <= DWG_TYPE_LAYOUT
                       && obj->fixedtype != obj->type
                       && dwg->header.from_version >= R_13b1)
                     {
                       LOG_WARN ("Changed wrong type %d => %d", obj->type,
                                 obj->fixedtype)
                       obj->type = obj->fixedtype;
                     }
                   if ((obj->supertype == DWG_SUPERTYPE_ENTITY && !isent)
                       || (obj->supertype == DWG_SUPERTYPE_OBJECT && isent))
                     {
                       LOG_ERROR ("Illegal object supertype for %s", name);
                       // exhaust the rest
                       for (; j < keys; j++)
                         {
                           json_advance_unknown (dat, tokens, t->type,
                                                 0); // value
                           tokens->index++;          // next key
                           JSON_TOKENS_CHECK_OVERFLOW (goto harderr);
                         }
                       tokens->index--;
                       break;
                     }
                 }
               LOG_TRACE ("type: %d,\tfixedtype: %d\n", obj->type,
                          obj->fixedtype);
               if (dwg->header.from_version < R_13b1 && dwg_obj_is_table (obj))
                 {
                   Dwg_Section_Type_r11 id = SECTION_HEADER_R11;
                   switch (obj->fixedtype)
                     {
                     case DWG_TYPE_BLOCK_HEADER:
                       id = SECTION_BLOCK;
                       break;
                     case DWG_TYPE_LAYER:
                       id = SECTION_LAYER;
                       break;
                     case DWG_TYPE_STYLE:
                       id = SECTION_STYLE;
                       break;
                     case DWG_TYPE_LTYPE:
                       id = SECTION_LTYPE;
                       break;
                     case DWG_TYPE_VIEW:
                       id = SECTION_VIEW;
                       break;
                     case DWG_TYPE_VPORT:
                       id = SECTION_VPORT;
                       break;
                     case DWG_TYPE_APPID:
                       id = SECTION_APPID;
                       break;
                     case DWG_TYPE_DIMSTYLE:
                       id = SECTION_DIMSTYLE;
                       break;
                     case DWG_TYPE_VX_TABLE_RECORD:
                       id = SECTION_VX;
                       break;
                     default:
                       LOG_ERROR ("Invalid table type %s %u", obj->name,
                                  obj->fixedtype);
                       // assert (!obj->fixedtype);
                     }
                   if (id != SECTION_HEADER_R11)
                     {
                       // TODO: maybe add a missing CONTROL object here. GH #453
                       dwg->header.section[id].number++;
                     }
                 }
             }
           // Note: also _obj->size
           else if (strEQc (key, "size") && !obj->size
                    && t->type == JSMN_PRIMITIVE)
             {
               obj->size = json_long (dat, tokens);
               JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
               if (dwg->header.from_version >= R_13b1 && !obj->handle.value)
                 {
                   LOG_ERROR ("Required %s.handle missing", name);
                   goto harderr;
                 }
               LOG_TRACE ("%s.size: %d\n", obj->name, obj->size)
             }
           else if (strEQc (key, "bitsize") && !obj->bitsize)
             {
               obj->bitsize = json_long (dat, tokens);
               LOG_TRACE ("%s.bitsize: %d\n", obj->name, obj->bitsize)
               JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
             }
           else if (strEQc (key, "address") && !obj->address)
             {
               obj->address = json_long (dat, tokens);
               LOG_TRACE ("%s.address: 0x%zx\n", obj->name, obj->address)
               JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
             }
           else if (strEQc (key, "handle") && !obj->handle.value)
             {
               BITCODE_H hdl
                   = json_HANDLE (dat, dwg, tokens, name, key, obj, -1);
               JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
               if (hdl)
                 {
                   obj->handle.code = hdl->handleref.code;
                   obj->handle.size = hdl->handleref.size;
                   obj->handle.value = hdl->handleref.value;
                   if (!hdl->handleref.code)
                     {
                       hdl->obj = obj;
                       dwg_add_handle (&hdl->handleref, 0, hdl->handleref.value, obj);
                     }
                 }
               if (!obj->type) // TODO: We could eventually relax this
                 {
                   LOG_ERROR ("Required %s.type missing", name)
                   return DWG_ERR_INVALIDDWG;
                 }
             }
           // ignore subclass markers
           else if (t->type == JSMN_STRING && strEQc (key, "_subclass"))
             {
               LOG_TRACE ("_subclass: %.*s\n", t->end - t->start,
                          &dat->chain[t->start]);
               tokens->index++;
               JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
             }
-          else if (strEQc (key, "num_unknown_bits")
-                   && (memBEGINc (obj->name, "UNKNOWN_")
-                       || strEQc (obj->name, "STYLE")))
+          else if (strEQc (key, "num_unknown_bits"))
             {
               obj->num_unknown_bits = json_long (dat, tokens);
               JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
               LOG_TRACE ("num_unknown_bits: %d\n", (int)obj->num_unknown_bits);
             }
-          else if (strEQc (key, "unknown_bits")
-                   && (memBEGINc (obj->name, "UNKNOWN_")
-                       || strEQc (obj->name, "STYLE")
-                       || (dwg->header.version == dwg->header.from_version)))
+          else if (strEQc (key, "unknown_bits"))
             {
               const int len = t->end - t->start;
               char *hex = json_string (dat, tokens);
               const unsigned blen = len / 2;
               unsigned read;
               BITCODE_TF buf = (BITCODE_TF)malloc (blen + 1);
               if ((read = in_hex2bin (buf, hex, blen) != blen))
                 LOG_ERROR ("in_hex2bin with key %s at pos %u of %u", key, read,
                            blen);
               buf[blen] = '\0';
               free (hex);
               if (!obj->num_unknown_bits)
                 obj->num_unknown_bits = blen * 8; // minus some padding bits
               if (obj->unknown_bits)
                 free (obj->unknown_bits);
               obj->unknown_bits = buf;
               // LOG_TRACE ("%s: '%.*s' [%s] (binary)\n", key, blen, buf,
               //            f->type);
               LOG_TRACE ("unknown_bits: %.*s\n", t->end - t->start,
                          &dat->chain[t->start])
             }
           else if (strEQc (key, "eed") && !obj->tio.object->num_eed
                    && t->type == JSMN_ARRAY)
             {
               json_eed (dat, dwg, tokens, obj->tio.object);
               JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
             }
           else
             // search_field:
             {
               if (t->type == JSMN_STRING && is_entity && strEQc (key, "tag"))
                 {
                   int sz = t->end - t->start;
                   char *tag = (char *)malloc (sz + 1);
                   memcpy (tag, &dat->chain[t->start], sz);
                   tag[sz] = '\0';
                   if (sz <= 0 || !dwg_is_valid_tag (tag))
                     {
                       LOG_WARN ("Invalid %s.tag: %s\n", obj->name, tag);
                     }
                   free (tag);
                 }
               if (_set_struct_field (dat, obj, tokens, _obj, name, key,
                                      fields))
                 continue;
               if (is_entity)
                 {
                   if (_set_struct_field (dat, obj, tokens, obj->tio.entity,
                                          name, key,
                                          dwg_dynapi_common_entity_fields ()))
                     continue;
                 }
               else
                 {
                   if (_set_struct_field (dat, obj, tokens, obj->tio.object,
                                          name, key,
                                          dwg_dynapi_common_object_fields ()))
                     continue;
                 }
 
               // This should now be handled in _set_struct_field, recursively.
               // esp for TABLE's
               // first the MLEADER_AnnotContext union:
               if (strEQc (name, "MULTILEADER"))
                 {
                   // assert (0);
                   // embedded structs
                   if (memBEGINc (key, "ctx.content.txt."))
                     {
                       Dwg_Entity_MULTILEADER *_o
                           = (Dwg_Entity_MULTILEADER *)_obj;
                       Dwg_MLEADER_Content *cnt = &_o->ctx.content;
                       const Dwg_DYNAPI_field *sf = dwg_dynapi_subclass_fields (
                           "MLEADER_Content_MText");
                       if (sf
                           && _set_struct_field (
                               dat, obj, tokens, cnt, "MLEADER_Content",
                               &key[strlen ("ctx.content.")], sf))
                         continue;
                     }
                   // the rest
                   else if (memBEGINc (key, "ctx."))
                     {
                       Dwg_Entity_MULTILEADER *_o
                           = (Dwg_Entity_MULTILEADER *)_obj;
                       Dwg_MLEADER_AnnotContext *ctx = &_o->ctx;
                       const Dwg_DYNAPI_field *sf = dwg_dynapi_subclass_fields (
                           "MLEADER_AnnotContext");
                       if (sf
                           && _set_struct_field (dat, obj, tokens, ctx,
                                                 "MLEADER_AnnotContext",
                                                 &key[4], sf))
                         continue;
                     }
                 }
               else if (t->type == JSMN_OBJECT && memBEGINc (name, "DICTIONARY")
                        && strEQc (key, "items"))
                 {
                   Dwg_Object_DICTIONARY *o = obj->tio.object->tio.DICTIONARY;
                   o->numitems = t->size;
                   o->texts = o->numitems ? (BITCODE_T *)calloc (
                                  o->numitems, sizeof (BITCODE_T))
                                          : NULL;
                   o->itemhandles = o->numitems ? (BITCODE_H *)calloc (
                                        o->numitems, sizeof (BITCODE_H))
                                                : NULL;
                   tokens->index++;
                   for (int k = 0; k < (int)o->numitems; k++)
                     {
                       JSON_TOKENS_CHECK_OVERFLOW (goto harderr);
                       t = &tokens->tokens[tokens->index];
                       /*SINCE (R_2007)
                         o->texts[k] = (BITCODE_T)json_wstring (dat, tokens);
                       else*/
                       o->texts[k] = json_string (dat, tokens);
                       LOG_TRACE ("texts[%d]: %.*s\t => ", k, t->end - t->start,
                                  &dat->chain[t->start]);
                       JSON_TOKENS_CHECK_OVERFLOW (goto harderr);
                       o->itemhandles[k] = json_HANDLE (dat, dwg, tokens, name,
                                                        "itemhandles", obj, k);
                     }
                   if (!o->numitems)
                     LOG_TRACE ("%s.%s empty\n", name, key);
                   continue;
                 }
               LOG_ERROR ("Unknown %s.%s %.*s ignored", name, key,
                          t->end - t->start, &dat->chain[t->start]);
               json_advance_unknown (dat, tokens, t->type, 0);
               JSON_TOKENS_CHECK_OVERFLOW (goto harderr)
             }
         }
     }
   LOG_TRACE ("End of %s\n", section)
   tokens->index--;
   return 0;
diff --git a/test/unit-testing/dxf_test.c b/test/unit-testing/dxf_test.c
index 331f5924..01d3b301 100644
--- a/test/unit-testing/dxf_test.c
+++ b/test/unit-testing/dxf_test.c
@@ -395,400 +395,410 @@ static int
 test_object (const Dwg_Data *restrict dwg, const Dwg_Object *restrict obj,
              const struct _unknown_dxf *restrict dxf,
              const char *restrict name)
 {
   int isnew;
   const struct _unknown_field *f = dxf->fields;
   int sub_i = 0;
   char firstkey[80];
 
   *firstkey = '\0';
   g_counter++;
 
   // check all fields against dxf->fields
   for (; f->value; f++)
     {
       Dwg_DYNAPI_field field;
       const Dwg_DYNAPI_field *fp, *fp1;
       enum RESBUF_VALUE_TYPE vtype;
       if (!f->name || !*f->name)
         continue;
       // support subclass, as in in_json
       if (strchr (f->name, '.'))
         {
           char *subf = strdup (f->name);
           char *key = strchr (subf, '.');
           char *subclass;
           char *p;
           char *ptr;
 
           *key = '\0';
           key++;
           if (!*firstkey)
             {
               strcpy (firstkey, key);
               if (strEQc (name, "DIMASSOC"))
                 sub_i = DIMASSOC_index (obj, sub_i);
             }
           else if (strEQ (key, firstkey)) // next index, like ref[1]
             {
               if (strEQc (name, "DIMASSOC"))
                 {
                   sub_i = DIMASSOC_index (obj, sub_i + 1);
                   if (sub_i > 3)
                     break;
                 }
               else
                 sub_i++;
             }
           // unused
           if ((p = strchr (subf, '['))) // ref[0].osnap_type
             *p = '\0';
           // generalize. lookup type of subclass field
           if (!(fp1 = dwg_dynapi_entity_field (name, subf)))
             {
               free (subf);
               continue;
             }
           subclass = dwg_dynapi_subclass_name (fp1->type);
           if (!subclass)
             {
               free (subf);
               continue;
             }
           fp = dwg_dynapi_subclass_field (subclass, key);
           if (!fp)
             {
               free (subclass);
               free (subf);
               continue;
             }
           // embedded or reference?
           if (fp1->is_malloc) // vector
             {
               // ptr = ref[i].key
               int subsize = sub_i ? dwg_dynapi_subclass_size (subclass) : 0;
               ptr = *(char **)((char *)obj->tio.object->tio.APPID
                                + fp1->offset); // deref
               ptr += (sub_i * subsize);        // index offset
             }
           else
             { // embedded. no deref, and also no index offset. ptr = &ref.key
               ptr = &((char *)obj->tio.object->tio.APPID)[fp1->offset];
             }
           if (ptr)
             test_subclass (dwg, ptr, f, fp, subclass, subf, key, sub_i);
           free (subclass);
           free (subf);
           continue;
         }
       else if (!(fp = dwg_dynapi_entity_field (name, f->name)))
         continue;
       if (strEQc (fp->type, "CMC"))
         {
           BITCODE_CMC color;
           if (dwg_dynapi_entity_value (obj->tio.object->tio.APPID, name,
                                        f->name, &color, &field))
             {
               BITCODE_BS i = (BITCODE_BS)strtol (f->value, NULL, 10);
               if (i == color.index)
                 {
                   if (g_counter > g_max_count)
                     pass ();
                   else
                     ok ("%s.%s: %s", name, f->name, f->value);
                 }
               else if (field.type)
                 fail ("%s.%s: %d <=> \"%s\" [%s %d]", name, f->name,
                       (int)color.index, f->value, field.type, field.dxf);
               else
                 {
                   if (g_counter > g_max_count)
                     pass ();
                   else
                     ok ("%s.%s: %d <=> \"%s\" [CMC] (TODO)", name, f->name,
                         (int)color.index, f->value);
                 }
             }
           continue;
         }
+      // TODO: inlined array support, as with subfields
       vtype = dwg_resbuf_value_type (f->code);
       if (vtype == DWG_VT_REAL && fp->size >= 16)
         goto DWG_VT_POINT3D;
       if (vtype == DWG_VT_INT8 && fp->size == 1 && strEQc (fp->type, "B"))
         goto DWG_VT_BOOL;
       if (vtype == DWG_VT_INT16 && fp->size == 1 && strEQc (fp->type, "RC"))
         goto DWG_VT_INT8;
       if (vtype == DWG_VT_INT8 && fp->size == 2)
         goto DWG_VT_INT16;
       if (vtype == DWG_VT_INT16 && fp->size == 4)
         goto DWG_VT_INT32;
       if (vtype == DWG_VT_INT16 && fp->size == 1)
         goto DWG_VT_INT8;
       if (vtype == DWG_VT_INT32 && fp->size == 8)
         goto DWG_VT_INT64;
       switch (vtype)
         {
         case DWG_VT_STRING:
           {
-            char *value;
-            if (dwg_dynapi_entity_utf8text (obj->tio.object->tio.APPID, name,
+            char *value = NULL;
+            if (fp->is_malloc &&
+                dwg_dynapi_entity_utf8text (obj->tio.object->tio.APPID, name,
                                             f->name, &value, &isnew, &field))
               {
                 if (!value || strEQ (value, f->value))
                   {
                     if (g_counter > g_max_count)
                       pass ();
                     else
                       ok ("%s.%s: %s", name, f->name, value);
                   }
                 else
                   fail ("%s.%s: %s [%s %d] STRING", name, f->name, value,
                         field.type, field.dxf);
               }
-            if (isnew)
+            if (isnew && value)
               free (value);
           }
           break;
         case DWG_VT_POINT3D:
         DWG_VT_POINT3D:
           {
             BITCODE_3BD pt;
-            if (dwg_dynapi_entity_value (obj->tio.object->tio.APPID, name,
+            if (fp->is_malloc &&
+                dwg_dynapi_entity_value (obj->tio.object->tio.APPID, name,
                                          f->name, &pt, &field))
               {
                 double d = strtod (f->value, NULL);
                 double ptv;
                 int offset = f->code;
                 if (strstr (field.type, "_1"))
                   {
                     while (offset > 10) // 10,11,12
                       offset -= 10;
                     if (offset == 2 && field.size > 2 * sizeof (double))
                       ptv = pt.z;
                     else if (offset == 1)
                       ptv = pt.y;
                     else
                       ptv = pt.x;
                   }
                 else // 10/20/30
                   {
                     offset = offset % 100;
                     if (offset >= 30 && field.size > 2 * sizeof (double))
                       ptv = pt.z;
                     else if (offset >= 20)
                       ptv = pt.y;
                     else
                       ptv = pt.x;
                   }
                 if (fabs (ptv - d) < 1e-6)
                   {
                     if (g_counter > g_max_count)
                       pass ();
                     else
                       ok ("%s.%s: %f [%s %d]", name, f->name, ptv, field.type,
                           f->code);
                   }
                 else
                   fail ("%s.%s: %f <=> \"%s\" [%s %d]", name, f->name, ptv,
                         f->value, field.type, f->code);
               }
           }
           break;
         case DWG_VT_REAL:
           {
             double value;
-            if (dwg_dynapi_entity_value (obj->tio.object->tio.APPID, name,
+            if (fp->is_malloc &&
+                dwg_dynapi_entity_value (obj->tio.object->tio.APPID, name,
                                          f->name, &value, &field))
               {
                 double d = strtod (f->value, NULL);
                 if (f->code >= 50 && f->code < 59)
                   d = deg2rad (d);
                 if (fabs (value - d) < 1e-6)
                   {
                     if (g_counter > g_max_count)
                       pass ();
                     else
                       ok ("%s.%s: %f", name, f->name, value);
                   }
                 else
                   fail ("%s.%s: %f <=> \"%s\" [%s %d] REAL", name, f->name,
                         value, f->value, field.type, field.dxf);
               }
           }
           break;
         case DWG_VT_BOOL:
         DWG_VT_BOOL:
           {
             BITCODE_B value;
-            if (dwg_dynapi_entity_value (obj->tio.object->tio.APPID, name,
+            if (fp->is_malloc &&
+                dwg_dynapi_entity_value (obj->tio.object->tio.APPID, name,
                                          f->name, &value, &field))
               {
                 BITCODE_B i = (BITCODE_B)strtol (f->value, NULL, 10);
                 if (i == value)
                   {
                     if (g_counter > g_max_count)
                       pass ();
                     else
                       ok ("%s.%s: %d", name, f->name, value);
                   }
                 else
                   fail ("%s.%s: %d <=> \"%s\" [%s %d] BOOL", name, f->name,
                         value, f->value, field.type, field.dxf);
               }
           }
           break;
         case DWG_VT_INT8:
         DWG_VT_INT8:
           {
             BITCODE_RC value;
-            if (dwg_dynapi_entity_value (obj->tio.object->tio.APPID, name,
+            if (fp->is_malloc &&
+                dwg_dynapi_entity_value (obj->tio.object->tio.APPID, name,
                                          f->name, &value, &field))
               {
                 BITCODE_RC i = (BITCODE_RC)strtol (f->value, NULL, 10);
                 if (i == value)
                   {
                     if (g_counter > g_max_count)
                       pass ();
                     else
                       ok ("%s.%s: %d", name, f->name, value);
                   }
                 else if (field.type)
                   fail ("%s.%s: %d <=> \"%s\" [%s %d] INT8", name, f->name,
                         value, f->value, field.type, field.dxf);
                 else
                   {
                     if (g_counter > g_max_count)
                       pass ();
                     else
                       ok ("%s.%s: %d <=> \"%s\" INT8 (TODO)", name, f->name,
                           value, f->value);
                   }
               }
           }
           break;
         case DWG_VT_INT16:
         DWG_VT_INT16:
           {
             BITCODE_BS value;
-            if (dwg_dynapi_entity_value (obj->tio.object->tio.APPID, name,
+            if (fp->is_malloc &&
+                dwg_dynapi_entity_value (obj->tio.object->tio.APPID, name,
                                          f->name, &value, &field))
               {
                 BITCODE_BS i = (BITCODE_BS)strtol (f->value, NULL, 10);
                 if (i == value)
                   {
                     if (g_counter > g_max_count)
                       pass ();
                     else
                       ok ("%s.%s: %d", name, f->name, (int)value);
                   }
                 else if (field.type)
                   fail ("%s.%s: %d <=> \"%s\" [%s %d] INT16", name, f->name,
                         (int)value, f->value, field.type, field.dxf);
                 else
                   {
                     if (g_counter > g_max_count)
                       pass ();
                     else
                       ok ("%s.%s: %d <=> \"%s\" INT16 (TODO)", name, f->name,
                           (int)value, f->value);
                   }
               }
           }
           break;
         case DWG_VT_INT32:
         DWG_VT_INT32:
           {
             BITCODE_BL value;
-            if (dwg_dynapi_entity_value (obj->tio.object->tio.APPID, name,
+            if (fp->is_malloc &&
+                dwg_dynapi_entity_value (obj->tio.object->tio.APPID, name,
                                          f->name, &value, &field))
               {
                 long l = strtol (f->value, NULL, 10);
                 BITCODE_BL i = (BITCODE_BL)l;
                 if (strEQc (f->name, "rgb") && i == (value & 0xffffff))
                   {
                     if (g_counter > g_max_count)
                       pass ();
                     else
                       ok ("%s.%s: 0x%x", name, f->name, (unsigned)value);
                   }
                 else if (i == value)
                   {
                     if (g_counter > g_max_count)
                       pass ();
                     else
                       ok ("%s.%s: %u", name, f->name, (unsigned)value);
                   }
                 else if (field.type)
                   fail ("%s.%s: %u <=> \"%s\" [%s %d] INT32", name, f->name,
                         (unsigned)value, f->value, field.type, field.dxf);
                 else
                   {
                     if (g_counter > g_max_count)
                       pass ();
                     else
                       ok ("%s.%s: %u <=> \"%s\" INT32 (TODO)", name, f->name,
                           (unsigned)value, f->value);
                   }
               }
           }
           break;
         case DWG_VT_INT64:
         DWG_VT_INT64:
           {
             BITCODE_RLL value;
-            if (dwg_dynapi_entity_value (obj->tio.object->tio.APPID, name,
+            if (fp->is_malloc &&
+                dwg_dynapi_entity_value (obj->tio.object->tio.APPID, name,
                                          f->name, &value, &field))
               {
                 BITCODE_RLL i = (BITCODE_RLL)strtol (f->value, NULL, 10);
                 if (i == value)
                   {
                     if (g_counter > g_max_count)
                       pass ();
                     else
                       ok ("%s.%s: %ld", name, f->name, (long)value);
                   }
                 else if (field.type)
                   fail ("%s.%s: %ld <=> \"%s\" [%s %d] INT64", name, f->name,
                         (long)value, f->value, field.type, field.dxf);
                 else
                   {
                     if (g_counter > g_max_count)
                       pass ();
                     else
                       ok ("%s.%s: %ld <=> \"%s\" INT64 (TODO)", name, f->name,
                           (long)value, f->value);
                   }
               }
           }
           break;
         case DWG_VT_BINARY:
           break;
         case DWG_VT_HANDLE:
           {
             BITCODE_H value;
-            if (dwg_dynapi_entity_value (obj->tio.object->tio.APPID, name,
+            if (fp->is_malloc &&
+                dwg_dynapi_entity_value (obj->tio.object->tio.APPID, name,
                                          f->name, &value, &field))
               {
                 unsigned long l;
                 sscanf (f->value, "%lX", &l);
                 if (l == value->absolute_ref || l == value->handleref.value)
                   {
                     if (g_counter > g_max_count)
                       pass ();
                     else
                       ok ("%s.%s: %s", name, f->name, f->value);
                   }
                 else
                   fail ("%s.%s: %lX <=> \"%s\" [H %d]", name, f->name, l,
                         f->value, field.dxf);
               }
           }
           break;
         case DWG_VT_OBJECTID:
         case DWG_VT_INVALID:
         default:
           break;
         }
     }
   return failed;
 }
diff --git a/test/unit-testing/dynapi_test.c b/test/unit-testing/dynapi_test.c
index 125e0335..2e244252 100644
--- a/test/unit-testing/dynapi_test.c
+++ b/test/unit-testing/dynapi_test.c
@@ -39,6064 +39,6064 @@ static int
 test_header (Dwg_Data *dwg)
 {
   int error = 0;
   BITCODE_RL rl;
   BITCODE_RC rc;
   BITCODE_BLL bll;
   BITCODE_BD bd;
   BITCODE_TV tv;
 
 #line 46 "dynapi_test.c"
   /* @@for test_HEADER@@ */
   {
     BITCODE_RL size;
     if (dwg_dynapi_header_value (dwg, "size", &size, NULL)
         && size == dwg->header_vars.size)
       pass ();
     else
       fail ("HEADER.size [RL] %u != %u", dwg->header_vars.size, size);
     size++;
     if (dwg_dynapi_header_set_value (dwg, "size", &size, 0)
         && size == dwg->header_vars.size)
       pass ();
     else
       fail ("HEADER.size [RL] set+1 %u != %u",
             dwg->header_vars.size, size);
     size--;
     dwg_dynapi_header_set_value (dwg, "size", &size, 0);
 
   }
   {
     BITCODE_RL bitsize_hi;
     if (dwg_dynapi_header_value (dwg, "bitsize_hi", &bitsize_hi, NULL)
         && bitsize_hi == dwg->header_vars.bitsize_hi)
       pass ();
     else
       fail ("HEADER.bitsize_hi [RL] %u != %u", dwg->header_vars.bitsize_hi, bitsize_hi);
     bitsize_hi++;
     if (dwg_dynapi_header_set_value (dwg, "bitsize_hi", &bitsize_hi, 0)
         && bitsize_hi == dwg->header_vars.bitsize_hi)
       pass ();
     else
       fail ("HEADER.bitsize_hi [RL] set+1 %u != %u",
             dwg->header_vars.bitsize_hi, bitsize_hi);
     bitsize_hi--;
     dwg_dynapi_header_set_value (dwg, "bitsize_hi", &bitsize_hi, 0);
 
   }
   {
     BITCODE_RL bitsize;
     if (dwg_dynapi_header_value (dwg, "bitsize", &bitsize, NULL)
         && bitsize == dwg->header_vars.bitsize)
       pass ();
     else
       fail ("HEADER.bitsize [RL] %u != %u", dwg->header_vars.bitsize, bitsize);
     bitsize++;
     if (dwg_dynapi_header_set_value (dwg, "bitsize", &bitsize, 0)
         && bitsize == dwg->header_vars.bitsize)
       pass ();
     else
       fail ("HEADER.bitsize [RL] set+1 %u != %u",
             dwg->header_vars.bitsize, bitsize);
     bitsize--;
     dwg_dynapi_header_set_value (dwg, "bitsize", &bitsize, 0);
 
   }
   {
     BITCODE_RC acadmaintver;
     if (dwg_dynapi_header_value (dwg, "ACADMAINTVER", &acadmaintver, NULL)
         && acadmaintver == dwg->header_vars.ACADMAINTVER)
       pass ();
     else
       fail ("HEADER.ACADMAINTVER [RC] %u != %u", dwg->header_vars.ACADMAINTVER, acadmaintver);
     acadmaintver++;
     if (dwg_dynapi_header_set_value (dwg, "ACADMAINTVER", &acadmaintver, 0)
         && acadmaintver == dwg->header_vars.ACADMAINTVER)
       pass ();
     else
       fail ("HEADER.ACADMAINTVER [RC] set+1 %u != %u",
             dwg->header_vars.ACADMAINTVER, acadmaintver);
     acadmaintver--;
     dwg_dynapi_header_set_value (dwg, "ACADMAINTVER", &acadmaintver, 0);
 
   }
   {
     BITCODE_BLL requiredversions;
     if (dwg_dynapi_header_value (dwg, "REQUIREDVERSIONS", &requiredversions, NULL)
         && requiredversions == dwg->header_vars.REQUIREDVERSIONS)
       pass ();
     else
       fail ("HEADER.REQUIREDVERSIONS [BLL] " FORMAT_BLL " != " FORMAT_BLL "", dwg->header_vars.REQUIREDVERSIONS, requiredversions);
     requiredversions++;
     if (dwg_dynapi_header_set_value (dwg, "REQUIREDVERSIONS", &requiredversions, 0)
         && requiredversions == dwg->header_vars.REQUIREDVERSIONS)
       pass ();
     else
       fail ("HEADER.REQUIREDVERSIONS [BLL] set+1 " FORMAT_BLL " != " FORMAT_BLL "",
             dwg->header_vars.REQUIREDVERSIONS, requiredversions);
     requiredversions--;
     dwg_dynapi_header_set_value (dwg, "REQUIREDVERSIONS", &requiredversions, 0);
 
   }
   {
     BITCODE_TV dwgcodepage;
     if (dwg_dynapi_header_value (dwg, "DWGCODEPAGE", &dwgcodepage, NULL)
         && !memcmp (&dwgcodepage, &dwg->header_vars.DWGCODEPAGE, sizeof (dwg->header_vars.DWGCODEPAGE))
        )
       pass ();
     else
       fail ("HEADER.DWGCODEPAGE [TV]");
   }
   {
     BITCODE_RS codepage;
     if (dwg_dynapi_header_value (dwg, "codepage", &codepage, NULL)
         && codepage == dwg->header_vars.codepage)
       pass ();
     else
       fail ("HEADER.codepage [RS] %hu != %hu", dwg->header_vars.codepage, codepage);
     codepage++;
     if (dwg_dynapi_header_set_value (dwg, "codepage", &codepage, 0)
         && codepage == dwg->header_vars.codepage)
       pass ();
     else
       fail ("HEADER.codepage [RS] set+1 %hu != %hu",
             dwg->header_vars.codepage, codepage);
     codepage--;
     dwg_dynapi_header_set_value (dwg, "codepage", &codepage, 0);
 
   }
   {
     BITCODE_BD unit1_ratio;
     if (dwg_dynapi_header_value (dwg, "unit1_ratio", &unit1_ratio, NULL)
         && unit1_ratio == dwg->header_vars.unit1_ratio)
       pass ();
     else
       fail ("HEADER.unit1_ratio [BD] %g != %g", dwg->header_vars.unit1_ratio, unit1_ratio);
     unit1_ratio++;
     if (dwg_dynapi_header_set_value (dwg, "unit1_ratio", &unit1_ratio, 0)
         && unit1_ratio == dwg->header_vars.unit1_ratio)
       pass ();
     else
       fail ("HEADER.unit1_ratio [BD] set+1 %g != %g",
             dwg->header_vars.unit1_ratio, unit1_ratio);
     unit1_ratio--;
     dwg_dynapi_header_set_value (dwg, "unit1_ratio", &unit1_ratio, 0);
 
   }
   {
     BITCODE_BD unit2_ratio;
     if (dwg_dynapi_header_value (dwg, "unit2_ratio", &unit2_ratio, NULL)
         && unit2_ratio == dwg->header_vars.unit2_ratio)
       pass ();
     else
       fail ("HEADER.unit2_ratio [BD] %g != %g", dwg->header_vars.unit2_ratio, unit2_ratio);
     unit2_ratio++;
     if (dwg_dynapi_header_set_value (dwg, "unit2_ratio", &unit2_ratio, 0)
         && unit2_ratio == dwg->header_vars.unit2_ratio)
       pass ();
     else
       fail ("HEADER.unit2_ratio [BD] set+1 %g != %g",
             dwg->header_vars.unit2_ratio, unit2_ratio);
     unit2_ratio--;
     dwg_dynapi_header_set_value (dwg, "unit2_ratio", &unit2_ratio, 0);
 
   }
   {
     BITCODE_BD unit3_ratio;
     if (dwg_dynapi_header_value (dwg, "unit3_ratio", &unit3_ratio, NULL)
         && unit3_ratio == dwg->header_vars.unit3_ratio)
       pass ();
     else
       fail ("HEADER.unit3_ratio [BD] %g != %g", dwg->header_vars.unit3_ratio, unit3_ratio);
     unit3_ratio++;
     if (dwg_dynapi_header_set_value (dwg, "unit3_ratio", &unit3_ratio, 0)
         && unit3_ratio == dwg->header_vars.unit3_ratio)
       pass ();
     else
       fail ("HEADER.unit3_ratio [BD] set+1 %g != %g",
             dwg->header_vars.unit3_ratio, unit3_ratio);
     unit3_ratio--;
     dwg_dynapi_header_set_value (dwg, "unit3_ratio", &unit3_ratio, 0);
 
   }
   {
     BITCODE_BD unit4_ratio;
     if (dwg_dynapi_header_value (dwg, "unit4_ratio", &unit4_ratio, NULL)
         && unit4_ratio == dwg->header_vars.unit4_ratio)
       pass ();
     else
       fail ("HEADER.unit4_ratio [BD] %g != %g", dwg->header_vars.unit4_ratio, unit4_ratio);
     unit4_ratio++;
     if (dwg_dynapi_header_set_value (dwg, "unit4_ratio", &unit4_ratio, 0)
         && unit4_ratio == dwg->header_vars.unit4_ratio)
       pass ();
     else
       fail ("HEADER.unit4_ratio [BD] set+1 %g != %g",
             dwg->header_vars.unit4_ratio, unit4_ratio);
     unit4_ratio--;
     dwg_dynapi_header_set_value (dwg, "unit4_ratio", &unit4_ratio, 0);
 
   }
   {
     BITCODE_TV unit1_name;
     if (dwg_dynapi_header_value (dwg, "unit1_name", &unit1_name, NULL)
         && !memcmp (&unit1_name, &dwg->header_vars.unit1_name, sizeof (dwg->header_vars.unit1_name))
        )
       pass ();
     else
       fail ("HEADER.unit1_name [TV]");
   }
   {
     BITCODE_TV unit2_name;
     if (dwg_dynapi_header_value (dwg, "unit2_name", &unit2_name, NULL)
         && !memcmp (&unit2_name, &dwg->header_vars.unit2_name, sizeof (dwg->header_vars.unit2_name))
        )
       pass ();
     else
       fail ("HEADER.unit2_name [TV]");
   }
   {
     BITCODE_TV unit3_name;
     if (dwg_dynapi_header_value (dwg, "unit3_name", &unit3_name, NULL)
         && !memcmp (&unit3_name, &dwg->header_vars.unit3_name, sizeof (dwg->header_vars.unit3_name))
        )
       pass ();
     else
       fail ("HEADER.unit3_name [TV]");
   }
   {
     BITCODE_TV unit4_name;
     if (dwg_dynapi_header_value (dwg, "unit4_name", &unit4_name, NULL)
         && !memcmp (&unit4_name, &dwg->header_vars.unit4_name, sizeof (dwg->header_vars.unit4_name))
        )
       pass ();
     else
       fail ("HEADER.unit4_name [TV]");
   }
   {
     BITCODE_BL unknown_8;
     if (dwg_dynapi_header_value (dwg, "unknown_8", &unknown_8, NULL)
         && unknown_8 == dwg->header_vars.unknown_8)
       pass ();
     else
       fail ("HEADER.unknown_8 [BL] %u != %u", dwg->header_vars.unknown_8, unknown_8);
     unknown_8++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_8", &unknown_8, 0)
         && unknown_8 == dwg->header_vars.unknown_8)
       pass ();
     else
       fail ("HEADER.unknown_8 [BL] set+1 %u != %u",
             dwg->header_vars.unknown_8, unknown_8);
     unknown_8--;
     dwg_dynapi_header_set_value (dwg, "unknown_8", &unknown_8, 0);
 
   }
   {
     BITCODE_BL unknown_9;
     if (dwg_dynapi_header_value (dwg, "unknown_9", &unknown_9, NULL)
         && unknown_9 == dwg->header_vars.unknown_9)
       pass ();
     else
       fail ("HEADER.unknown_9 [BL] %u != %u", dwg->header_vars.unknown_9, unknown_9);
     unknown_9++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_9", &unknown_9, 0)
         && unknown_9 == dwg->header_vars.unknown_9)
       pass ();
     else
       fail ("HEADER.unknown_9 [BL] set+1 %u != %u",
             dwg->header_vars.unknown_9, unknown_9);
     unknown_9--;
     dwg_dynapi_header_set_value (dwg, "unknown_9", &unknown_9, 0);
 
   }
   {
     BITCODE_BS unknown_10;
     if (dwg_dynapi_header_value (dwg, "unknown_10", &unknown_10, NULL)
         && unknown_10 == dwg->header_vars.unknown_10)
       pass ();
     else
       fail ("HEADER.unknown_10 [BS] %hu != %hu", dwg->header_vars.unknown_10, unknown_10);
     unknown_10++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_10", &unknown_10, 0)
         && unknown_10 == dwg->header_vars.unknown_10)
       pass ();
     else
       fail ("HEADER.unknown_10 [BS] set+1 %hu != %hu",
             dwg->header_vars.unknown_10, unknown_10);
     unknown_10--;
     dwg_dynapi_header_set_value (dwg, "unknown_10", &unknown_10, 0);
 
   }
   {
     BITCODE_H vx_table_record;
     if (dwg_dynapi_header_value (dwg, "VX_TABLE_RECORD", &vx_table_record, NULL)
         && !memcmp (&vx_table_record, &dwg->header_vars.VX_TABLE_RECORD, sizeof (dwg->header_vars.VX_TABLE_RECORD))
        )
       pass ();
     else
       fail ("HEADER.VX_TABLE_RECORD [H]");
   }
   {
     BITCODE_B dimaso;
     if (dwg_dynapi_header_value (dwg, "DIMASO", &dimaso, NULL)
         && dimaso == dwg->header_vars.DIMASO)
       pass ();
     else
       fail ("HEADER.DIMASO [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMASO, dimaso);
     dimaso++;
     if (dwg_dynapi_header_set_value (dwg, "DIMASO", &dimaso, 0)
         && dimaso == dwg->header_vars.DIMASO)
       pass ();
     else
       fail ("HEADER.DIMASO [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.DIMASO, dimaso);
     dimaso--;
     dwg_dynapi_header_set_value (dwg, "DIMASO", &dimaso, 0);
 
   }
   {
     BITCODE_B dimsho;
     if (dwg_dynapi_header_value (dwg, "DIMSHO", &dimsho, NULL)
         && dimsho == dwg->header_vars.DIMSHO)
       pass ();
     else
       fail ("HEADER.DIMSHO [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSHO, dimsho);
     dimsho++;
     if (dwg_dynapi_header_set_value (dwg, "DIMSHO", &dimsho, 0)
         && dimsho == dwg->header_vars.DIMSHO)
       pass ();
     else
       fail ("HEADER.DIMSHO [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.DIMSHO, dimsho);
     dimsho--;
     dwg_dynapi_header_set_value (dwg, "DIMSHO", &dimsho, 0);
 
   }
   {
     BITCODE_B dimsav;
     if (dwg_dynapi_header_value (dwg, "DIMSAV", &dimsav, NULL)
         && dimsav == dwg->header_vars.DIMSAV)
       pass ();
     else
       fail ("HEADER.DIMSAV [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSAV, dimsav);
     dimsav++;
     if (dwg_dynapi_header_set_value (dwg, "DIMSAV", &dimsav, 0)
         && dimsav == dwg->header_vars.DIMSAV)
       pass ();
     else
       fail ("HEADER.DIMSAV [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.DIMSAV, dimsav);
     dimsav--;
     dwg_dynapi_header_set_value (dwg, "DIMSAV", &dimsav, 0);
 
   }
   {
     BITCODE_B plinegen;
     if (dwg_dynapi_header_value (dwg, "PLINEGEN", &plinegen, NULL)
         && plinegen == dwg->header_vars.PLINEGEN)
       pass ();
     else
       fail ("HEADER.PLINEGEN [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.PLINEGEN, plinegen);
     plinegen++;
     if (dwg_dynapi_header_set_value (dwg, "PLINEGEN", &plinegen, 0)
         && plinegen == dwg->header_vars.PLINEGEN)
       pass ();
     else
       fail ("HEADER.PLINEGEN [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.PLINEGEN, plinegen);
     plinegen--;
     dwg_dynapi_header_set_value (dwg, "PLINEGEN", &plinegen, 0);
 
   }
   {
     BITCODE_B orthomode;
     if (dwg_dynapi_header_value (dwg, "ORTHOMODE", &orthomode, NULL)
         && orthomode == dwg->header_vars.ORTHOMODE)
       pass ();
     else
       fail ("HEADER.ORTHOMODE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.ORTHOMODE, orthomode);
     orthomode++;
     if (dwg_dynapi_header_set_value (dwg, "ORTHOMODE", &orthomode, 0)
         && orthomode == dwg->header_vars.ORTHOMODE)
       pass ();
     else
       fail ("HEADER.ORTHOMODE [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.ORTHOMODE, orthomode);
     orthomode--;
     dwg_dynapi_header_set_value (dwg, "ORTHOMODE", &orthomode, 0);
 
   }
   {
     BITCODE_B regenmode;
     if (dwg_dynapi_header_value (dwg, "REGENMODE", &regenmode, NULL)
         && regenmode == dwg->header_vars.REGENMODE)
       pass ();
     else
       fail ("HEADER.REGENMODE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.REGENMODE, regenmode);
     regenmode++;
     if (dwg_dynapi_header_set_value (dwg, "REGENMODE", &regenmode, 0)
         && regenmode == dwg->header_vars.REGENMODE)
       pass ();
     else
       fail ("HEADER.REGENMODE [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.REGENMODE, regenmode);
     regenmode--;
     dwg_dynapi_header_set_value (dwg, "REGENMODE", &regenmode, 0);
 
   }
   {
     BITCODE_B fillmode;
     if (dwg_dynapi_header_value (dwg, "FILLMODE", &fillmode, NULL)
         && fillmode == dwg->header_vars.FILLMODE)
       pass ();
     else
       fail ("HEADER.FILLMODE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.FILLMODE, fillmode);
     fillmode++;
     if (dwg_dynapi_header_set_value (dwg, "FILLMODE", &fillmode, 0)
         && fillmode == dwg->header_vars.FILLMODE)
       pass ();
     else
       fail ("HEADER.FILLMODE [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.FILLMODE, fillmode);
     fillmode--;
     dwg_dynapi_header_set_value (dwg, "FILLMODE", &fillmode, 0);
 
   }
   {
     BITCODE_B qtextmode;
     if (dwg_dynapi_header_value (dwg, "QTEXTMODE", &qtextmode, NULL)
         && qtextmode == dwg->header_vars.QTEXTMODE)
       pass ();
     else
       fail ("HEADER.QTEXTMODE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.QTEXTMODE, qtextmode);
     qtextmode++;
     if (dwg_dynapi_header_set_value (dwg, "QTEXTMODE", &qtextmode, 0)
         && qtextmode == dwg->header_vars.QTEXTMODE)
       pass ();
     else
       fail ("HEADER.QTEXTMODE [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.QTEXTMODE, qtextmode);
     qtextmode--;
     dwg_dynapi_header_set_value (dwg, "QTEXTMODE", &qtextmode, 0);
 
   }
   {
     BITCODE_B psltscale;
     if (dwg_dynapi_header_value (dwg, "PSLTSCALE", &psltscale, NULL)
         && psltscale == dwg->header_vars.PSLTSCALE)
       pass ();
     else
       fail ("HEADER.PSLTSCALE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.PSLTSCALE, psltscale);
     psltscale++;
     if (dwg_dynapi_header_set_value (dwg, "PSLTSCALE", &psltscale, 0)
         && psltscale == dwg->header_vars.PSLTSCALE)
       pass ();
     else
       fail ("HEADER.PSLTSCALE [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.PSLTSCALE, psltscale);
     psltscale--;
     dwg_dynapi_header_set_value (dwg, "PSLTSCALE", &psltscale, 0);
 
   }
   {
     BITCODE_B limcheck;
     if (dwg_dynapi_header_value (dwg, "LIMCHECK", &limcheck, NULL)
         && limcheck == dwg->header_vars.LIMCHECK)
       pass ();
     else
       fail ("HEADER.LIMCHECK [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.LIMCHECK, limcheck);
     limcheck++;
     if (dwg_dynapi_header_set_value (dwg, "LIMCHECK", &limcheck, 0)
         && limcheck == dwg->header_vars.LIMCHECK)
       pass ();
     else
       fail ("HEADER.LIMCHECK [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.LIMCHECK, limcheck);
     limcheck--;
     dwg_dynapi_header_set_value (dwg, "LIMCHECK", &limcheck, 0);
 
   }
   {
     BITCODE_RC menuext[46];
-    if (dwg_dynapi_header_value (dwg, "MENUEXT[46]", &menuext, NULL)
+    if (dwg_dynapi_header_value (dwg, "MENUEXT", &menuext, NULL)
         && !memcmp (&menuext, &dwg->header_vars.MENUEXT, sizeof (dwg->header_vars.MENUEXT))
        )
       pass ();
     else
       fail ("HEADER.MENUEXT[46] [RC]");
   }
   {
     BITCODE_B blipmode;
     if (dwg_dynapi_header_value (dwg, "BLIPMODE", &blipmode, NULL)
         && blipmode == dwg->header_vars.BLIPMODE)
       pass ();
     else
       fail ("HEADER.BLIPMODE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.BLIPMODE, blipmode);
     blipmode++;
     if (dwg_dynapi_header_set_value (dwg, "BLIPMODE", &blipmode, 0)
         && blipmode == dwg->header_vars.BLIPMODE)
       pass ();
     else
       fail ("HEADER.BLIPMODE [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.BLIPMODE, blipmode);
     blipmode--;
     dwg_dynapi_header_set_value (dwg, "BLIPMODE", &blipmode, 0);
 
   }
   {
     BITCODE_B unknown_11;
     if (dwg_dynapi_header_value (dwg, "unknown_11", &unknown_11, NULL)
         && unknown_11 == dwg->header_vars.unknown_11)
       pass ();
     else
       fail ("HEADER.unknown_11 [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.unknown_11, unknown_11);
     unknown_11++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_11", &unknown_11, 0)
         && unknown_11 == dwg->header_vars.unknown_11)
       pass ();
     else
       fail ("HEADER.unknown_11 [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.unknown_11, unknown_11);
     unknown_11--;
     dwg_dynapi_header_set_value (dwg, "unknown_11", &unknown_11, 0);
 
   }
   {
     BITCODE_B usrtimer;
     if (dwg_dynapi_header_value (dwg, "USRTIMER", &usrtimer, NULL)
         && usrtimer == dwg->header_vars.USRTIMER)
       pass ();
     else
       fail ("HEADER.USRTIMER [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.USRTIMER, usrtimer);
     usrtimer++;
     if (dwg_dynapi_header_set_value (dwg, "USRTIMER", &usrtimer, 0)
         && usrtimer == dwg->header_vars.USRTIMER)
       pass ();
     else
       fail ("HEADER.USRTIMER [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.USRTIMER, usrtimer);
     usrtimer--;
     dwg_dynapi_header_set_value (dwg, "USRTIMER", &usrtimer, 0);
 
   }
   {
     BITCODE_B fastzoom;
     if (dwg_dynapi_header_value (dwg, "FASTZOOM", &fastzoom, NULL)
         && fastzoom == dwg->header_vars.FASTZOOM)
       pass ();
     else
       fail ("HEADER.FASTZOOM [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.FASTZOOM, fastzoom);
     fastzoom++;
     if (dwg_dynapi_header_set_value (dwg, "FASTZOOM", &fastzoom, 0)
         && fastzoom == dwg->header_vars.FASTZOOM)
       pass ();
     else
       fail ("HEADER.FASTZOOM [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.FASTZOOM, fastzoom);
     fastzoom--;
     dwg_dynapi_header_set_value (dwg, "FASTZOOM", &fastzoom, 0);
 
   }
   {
     BITCODE_B flatland;
     if (dwg_dynapi_header_value (dwg, "FLATLAND", &flatland, NULL)
         && flatland == dwg->header_vars.FLATLAND)
       pass ();
     else
       fail ("HEADER.FLATLAND [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.FLATLAND, flatland);
     flatland++;
     if (dwg_dynapi_header_set_value (dwg, "FLATLAND", &flatland, 0)
         && flatland == dwg->header_vars.FLATLAND)
       pass ();
     else
       fail ("HEADER.FLATLAND [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.FLATLAND, flatland);
     flatland--;
     dwg_dynapi_header_set_value (dwg, "FLATLAND", &flatland, 0);
 
   }
   {
     BITCODE_B viewmode;
     if (dwg_dynapi_header_value (dwg, "VIEWMODE", &viewmode, NULL)
         && viewmode == dwg->header_vars.VIEWMODE)
       pass ();
     else
       fail ("HEADER.VIEWMODE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.VIEWMODE, viewmode);
     viewmode++;
     if (dwg_dynapi_header_set_value (dwg, "VIEWMODE", &viewmode, 0)
         && viewmode == dwg->header_vars.VIEWMODE)
       pass ();
     else
       fail ("HEADER.VIEWMODE [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.VIEWMODE, viewmode);
     viewmode--;
     dwg_dynapi_header_set_value (dwg, "VIEWMODE", &viewmode, 0);
 
   }
   {
     BITCODE_B skpoly;
     if (dwg_dynapi_header_value (dwg, "SKPOLY", &skpoly, NULL)
         && skpoly == dwg->header_vars.SKPOLY)
       pass ();
     else
       fail ("HEADER.SKPOLY [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.SKPOLY, skpoly);
     skpoly++;
     if (dwg_dynapi_header_set_value (dwg, "SKPOLY", &skpoly, 0)
         && skpoly == dwg->header_vars.SKPOLY)
       pass ();
     else
       fail ("HEADER.SKPOLY [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.SKPOLY, skpoly);
     skpoly--;
     dwg_dynapi_header_set_value (dwg, "SKPOLY", &skpoly, 0);
 
   }
   {
     BITCODE_RS unknown_mon;
     if (dwg_dynapi_header_value (dwg, "unknown_mon", &unknown_mon, NULL)
         && unknown_mon == dwg->header_vars.unknown_mon)
       pass ();
     else
       fail ("HEADER.unknown_mon [RS] %hu != %hu", dwg->header_vars.unknown_mon, unknown_mon);
     unknown_mon++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_mon", &unknown_mon, 0)
         && unknown_mon == dwg->header_vars.unknown_mon)
       pass ();
     else
       fail ("HEADER.unknown_mon [RS] set+1 %hu != %hu",
             dwg->header_vars.unknown_mon, unknown_mon);
     unknown_mon--;
     dwg_dynapi_header_set_value (dwg, "unknown_mon", &unknown_mon, 0);
 
   }
   {
     BITCODE_RS unknown_day;
     if (dwg_dynapi_header_value (dwg, "unknown_day", &unknown_day, NULL)
         && unknown_day == dwg->header_vars.unknown_day)
       pass ();
     else
       fail ("HEADER.unknown_day [RS] %hu != %hu", dwg->header_vars.unknown_day, unknown_day);
     unknown_day++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_day", &unknown_day, 0)
         && unknown_day == dwg->header_vars.unknown_day)
       pass ();
     else
       fail ("HEADER.unknown_day [RS] set+1 %hu != %hu",
             dwg->header_vars.unknown_day, unknown_day);
     unknown_day--;
     dwg_dynapi_header_set_value (dwg, "unknown_day", &unknown_day, 0);
 
   }
   {
     BITCODE_RS unknown_year;
     if (dwg_dynapi_header_value (dwg, "unknown_year", &unknown_year, NULL)
         && unknown_year == dwg->header_vars.unknown_year)
       pass ();
     else
       fail ("HEADER.unknown_year [RS] %hu != %hu", dwg->header_vars.unknown_year, unknown_year);
     unknown_year++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_year", &unknown_year, 0)
         && unknown_year == dwg->header_vars.unknown_year)
       pass ();
     else
       fail ("HEADER.unknown_year [RS] set+1 %hu != %hu",
             dwg->header_vars.unknown_year, unknown_year);
     unknown_year--;
     dwg_dynapi_header_set_value (dwg, "unknown_year", &unknown_year, 0);
 
   }
   {
     BITCODE_RS unknown_hour;
     if (dwg_dynapi_header_value (dwg, "unknown_hour", &unknown_hour, NULL)
         && unknown_hour == dwg->header_vars.unknown_hour)
       pass ();
     else
       fail ("HEADER.unknown_hour [RS] %hu != %hu", dwg->header_vars.unknown_hour, unknown_hour);
     unknown_hour++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_hour", &unknown_hour, 0)
         && unknown_hour == dwg->header_vars.unknown_hour)
       pass ();
     else
       fail ("HEADER.unknown_hour [RS] set+1 %hu != %hu",
             dwg->header_vars.unknown_hour, unknown_hour);
     unknown_hour--;
     dwg_dynapi_header_set_value (dwg, "unknown_hour", &unknown_hour, 0);
 
   }
   {
     BITCODE_RS unknown_min;
     if (dwg_dynapi_header_value (dwg, "unknown_min", &unknown_min, NULL)
         && unknown_min == dwg->header_vars.unknown_min)
       pass ();
     else
       fail ("HEADER.unknown_min [RS] %hu != %hu", dwg->header_vars.unknown_min, unknown_min);
     unknown_min++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_min", &unknown_min, 0)
         && unknown_min == dwg->header_vars.unknown_min)
       pass ();
     else
       fail ("HEADER.unknown_min [RS] set+1 %hu != %hu",
             dwg->header_vars.unknown_min, unknown_min);
     unknown_min--;
     dwg_dynapi_header_set_value (dwg, "unknown_min", &unknown_min, 0);
 
   }
   {
     BITCODE_RS unknown_sec;
     if (dwg_dynapi_header_value (dwg, "unknown_sec", &unknown_sec, NULL)
         && unknown_sec == dwg->header_vars.unknown_sec)
       pass ();
     else
       fail ("HEADER.unknown_sec [RS] %hu != %hu", dwg->header_vars.unknown_sec, unknown_sec);
     unknown_sec++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_sec", &unknown_sec, 0)
         && unknown_sec == dwg->header_vars.unknown_sec)
       pass ();
     else
       fail ("HEADER.unknown_sec [RS] set+1 %hu != %hu",
             dwg->header_vars.unknown_sec, unknown_sec);
     unknown_sec--;
     dwg_dynapi_header_set_value (dwg, "unknown_sec", &unknown_sec, 0);
 
   }
   {
     BITCODE_RS unknown_ms;
     if (dwg_dynapi_header_value (dwg, "unknown_ms", &unknown_ms, NULL)
         && unknown_ms == dwg->header_vars.unknown_ms)
       pass ();
     else
       fail ("HEADER.unknown_ms [RS] %hu != %hu", dwg->header_vars.unknown_ms, unknown_ms);
     unknown_ms++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_ms", &unknown_ms, 0)
         && unknown_ms == dwg->header_vars.unknown_ms)
       pass ();
     else
       fail ("HEADER.unknown_ms [RS] set+1 %hu != %hu",
             dwg->header_vars.unknown_ms, unknown_ms);
     unknown_ms--;
     dwg_dynapi_header_set_value (dwg, "unknown_ms", &unknown_ms, 0);
 
   }
   {
     BITCODE_B angdir;
     if (dwg_dynapi_header_value (dwg, "ANGDIR", &angdir, NULL)
         && angdir == dwg->header_vars.ANGDIR)
       pass ();
     else
       fail ("HEADER.ANGDIR [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.ANGDIR, angdir);
     angdir++;
     if (dwg_dynapi_header_set_value (dwg, "ANGDIR", &angdir, 0)
         && angdir == dwg->header_vars.ANGDIR)
       pass ();
     else
       fail ("HEADER.ANGDIR [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.ANGDIR, angdir);
     angdir--;
     dwg_dynapi_header_set_value (dwg, "ANGDIR", &angdir, 0);
 
   }
   {
     BITCODE_B splframe;
     if (dwg_dynapi_header_value (dwg, "SPLFRAME", &splframe, NULL)
         && splframe == dwg->header_vars.SPLFRAME)
       pass ();
     else
       fail ("HEADER.SPLFRAME [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.SPLFRAME, splframe);
     splframe++;
     if (dwg_dynapi_header_set_value (dwg, "SPLFRAME", &splframe, 0)
         && splframe == dwg->header_vars.SPLFRAME)
       pass ();
     else
       fail ("HEADER.SPLFRAME [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.SPLFRAME, splframe);
     splframe--;
     dwg_dynapi_header_set_value (dwg, "SPLFRAME", &splframe, 0);
 
   }
   {
     BITCODE_B attreq;
     if (dwg_dynapi_header_value (dwg, "ATTREQ", &attreq, NULL)
         && attreq == dwg->header_vars.ATTREQ)
       pass ();
     else
       fail ("HEADER.ATTREQ [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.ATTREQ, attreq);
     attreq++;
     if (dwg_dynapi_header_set_value (dwg, "ATTREQ", &attreq, 0)
         && attreq == dwg->header_vars.ATTREQ)
       pass ();
     else
       fail ("HEADER.ATTREQ [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.ATTREQ, attreq);
     attreq--;
     dwg_dynapi_header_set_value (dwg, "ATTREQ", &attreq, 0);
 
   }
   {
     BITCODE_B attdia;
     if (dwg_dynapi_header_value (dwg, "ATTDIA", &attdia, NULL)
         && attdia == dwg->header_vars.ATTDIA)
       pass ();
     else
       fail ("HEADER.ATTDIA [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.ATTDIA, attdia);
     attdia++;
     if (dwg_dynapi_header_set_value (dwg, "ATTDIA", &attdia, 0)
         && attdia == dwg->header_vars.ATTDIA)
       pass ();
     else
       fail ("HEADER.ATTDIA [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.ATTDIA, attdia);
     attdia--;
     dwg_dynapi_header_set_value (dwg, "ATTDIA", &attdia, 0);
 
   }
   {
     BITCODE_B mirrtext;
     if (dwg_dynapi_header_value (dwg, "MIRRTEXT", &mirrtext, NULL)
         && mirrtext == dwg->header_vars.MIRRTEXT)
       pass ();
     else
       fail ("HEADER.MIRRTEXT [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.MIRRTEXT, mirrtext);
     mirrtext++;
     if (dwg_dynapi_header_set_value (dwg, "MIRRTEXT", &mirrtext, 0)
         && mirrtext == dwg->header_vars.MIRRTEXT)
       pass ();
     else
       fail ("HEADER.MIRRTEXT [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.MIRRTEXT, mirrtext);
     mirrtext--;
     dwg_dynapi_header_set_value (dwg, "MIRRTEXT", &mirrtext, 0);
 
   }
   {
     BITCODE_B worldview;
     if (dwg_dynapi_header_value (dwg, "WORLDVIEW", &worldview, NULL)
         && worldview == dwg->header_vars.WORLDVIEW)
       pass ();
     else
       fail ("HEADER.WORLDVIEW [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.WORLDVIEW, worldview);
     worldview++;
     if (dwg_dynapi_header_set_value (dwg, "WORLDVIEW", &worldview, 0)
         && worldview == dwg->header_vars.WORLDVIEW)
       pass ();
     else
       fail ("HEADER.WORLDVIEW [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.WORLDVIEW, worldview);
     worldview--;
     dwg_dynapi_header_set_value (dwg, "WORLDVIEW", &worldview, 0);
 
   }
   {
     BITCODE_B wireframe;
     if (dwg_dynapi_header_value (dwg, "WIREFRAME", &wireframe, NULL)
         && wireframe == dwg->header_vars.WIREFRAME)
       pass ();
     else
       fail ("HEADER.WIREFRAME [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.WIREFRAME, wireframe);
     wireframe++;
     if (dwg_dynapi_header_set_value (dwg, "WIREFRAME", &wireframe, 0)
         && wireframe == dwg->header_vars.WIREFRAME)
       pass ();
     else
       fail ("HEADER.WIREFRAME [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.WIREFRAME, wireframe);
     wireframe--;
     dwg_dynapi_header_set_value (dwg, "WIREFRAME", &wireframe, 0);
 
   }
   {
     BITCODE_B tilemode;
     if (dwg_dynapi_header_value (dwg, "TILEMODE", &tilemode, NULL)
         && tilemode == dwg->header_vars.TILEMODE)
       pass ();
     else
       fail ("HEADER.TILEMODE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.TILEMODE, tilemode);
     tilemode++;
     if (dwg_dynapi_header_set_value (dwg, "TILEMODE", &tilemode, 0)
         && tilemode == dwg->header_vars.TILEMODE)
       pass ();
     else
       fail ("HEADER.TILEMODE [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.TILEMODE, tilemode);
     tilemode--;
     dwg_dynapi_header_set_value (dwg, "TILEMODE", &tilemode, 0);
 
   }
   {
     BITCODE_B plimcheck;
     if (dwg_dynapi_header_value (dwg, "PLIMCHECK", &plimcheck, NULL)
         && plimcheck == dwg->header_vars.PLIMCHECK)
       pass ();
     else
       fail ("HEADER.PLIMCHECK [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.PLIMCHECK, plimcheck);
     plimcheck++;
     if (dwg_dynapi_header_set_value (dwg, "PLIMCHECK", &plimcheck, 0)
         && plimcheck == dwg->header_vars.PLIMCHECK)
       pass ();
     else
       fail ("HEADER.PLIMCHECK [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.PLIMCHECK, plimcheck);
     plimcheck--;
     dwg_dynapi_header_set_value (dwg, "PLIMCHECK", &plimcheck, 0);
 
   }
   {
     BITCODE_B visretain;
     if (dwg_dynapi_header_value (dwg, "VISRETAIN", &visretain, NULL)
         && visretain == dwg->header_vars.VISRETAIN)
       pass ();
     else
       fail ("HEADER.VISRETAIN [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.VISRETAIN, visretain);
     visretain++;
     if (dwg_dynapi_header_set_value (dwg, "VISRETAIN", &visretain, 0)
         && visretain == dwg->header_vars.VISRETAIN)
       pass ();
     else
       fail ("HEADER.VISRETAIN [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.VISRETAIN, visretain);
     visretain--;
     dwg_dynapi_header_set_value (dwg, "VISRETAIN", &visretain, 0);
 
   }
   {
     BITCODE_B delobj;
     if (dwg_dynapi_header_value (dwg, "DELOBJ", &delobj, NULL)
         && delobj == dwg->header_vars.DELOBJ)
       pass ();
     else
       fail ("HEADER.DELOBJ [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DELOBJ, delobj);
     delobj++;
     if (dwg_dynapi_header_set_value (dwg, "DELOBJ", &delobj, 0)
         && delobj == dwg->header_vars.DELOBJ)
       pass ();
     else
       fail ("HEADER.DELOBJ [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.DELOBJ, delobj);
     delobj--;
     dwg_dynapi_header_set_value (dwg, "DELOBJ", &delobj, 0);
 
   }
   {
     BITCODE_B dispsilh;
     if (dwg_dynapi_header_value (dwg, "DISPSILH", &dispsilh, NULL)
         && dispsilh == dwg->header_vars.DISPSILH)
       pass ();
     else
       fail ("HEADER.DISPSILH [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DISPSILH, dispsilh);
     dispsilh++;
     if (dwg_dynapi_header_set_value (dwg, "DISPSILH", &dispsilh, 0)
         && dispsilh == dwg->header_vars.DISPSILH)
       pass ();
     else
       fail ("HEADER.DISPSILH [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.DISPSILH, dispsilh);
     dispsilh--;
     dwg_dynapi_header_set_value (dwg, "DISPSILH", &dispsilh, 0);
 
   }
   {
     BITCODE_B pellipse;
     if (dwg_dynapi_header_value (dwg, "PELLIPSE", &pellipse, NULL)
         && pellipse == dwg->header_vars.PELLIPSE)
       pass ();
     else
       fail ("HEADER.PELLIPSE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.PELLIPSE, pellipse);
     pellipse++;
     if (dwg_dynapi_header_set_value (dwg, "PELLIPSE", &pellipse, 0)
         && pellipse == dwg->header_vars.PELLIPSE)
       pass ();
     else
       fail ("HEADER.PELLIPSE [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.PELLIPSE, pellipse);
     pellipse--;
     dwg_dynapi_header_set_value (dwg, "PELLIPSE", &pellipse, 0);
 
   }
   {
     BITCODE_BS saveimages;
     if (dwg_dynapi_header_value (dwg, "SAVEIMAGES", &saveimages, NULL)
         && saveimages == dwg->header_vars.SAVEIMAGES)
       pass ();
     else
       fail ("HEADER.SAVEIMAGES [BS] %hu != %hu", dwg->header_vars.SAVEIMAGES, saveimages);
     saveimages++;
     if (dwg_dynapi_header_set_value (dwg, "SAVEIMAGES", &saveimages, 0)
         && saveimages == dwg->header_vars.SAVEIMAGES)
       pass ();
     else
       fail ("HEADER.SAVEIMAGES [BS] set+1 %hu != %hu",
             dwg->header_vars.SAVEIMAGES, saveimages);
     saveimages--;
     dwg_dynapi_header_set_value (dwg, "SAVEIMAGES", &saveimages, 0);
 
   }
   {
     BITCODE_BS proxygraphics;
     if (dwg_dynapi_header_value (dwg, "PROXYGRAPHICS", &proxygraphics, NULL)
         && proxygraphics == dwg->header_vars.PROXYGRAPHICS)
       pass ();
     else
       fail ("HEADER.PROXYGRAPHICS [BS] %hu != %hu", dwg->header_vars.PROXYGRAPHICS, proxygraphics);
     proxygraphics++;
     if (dwg_dynapi_header_set_value (dwg, "PROXYGRAPHICS", &proxygraphics, 0)
         && proxygraphics == dwg->header_vars.PROXYGRAPHICS)
       pass ();
     else
       fail ("HEADER.PROXYGRAPHICS [BS] set+1 %hu != %hu",
             dwg->header_vars.PROXYGRAPHICS, proxygraphics);
     proxygraphics--;
     dwg_dynapi_header_set_value (dwg, "PROXYGRAPHICS", &proxygraphics, 0);
 
   }
   {
     BITCODE_BS measurement;
     if (dwg_dynapi_header_value (dwg, "MEASUREMENT", &measurement, NULL)
         && measurement == dwg->header_vars.MEASUREMENT)
       pass ();
     else
       fail ("HEADER.MEASUREMENT [BS] %hu != %hu", dwg->header_vars.MEASUREMENT, measurement);
     measurement++;
     if (dwg_dynapi_header_set_value (dwg, "MEASUREMENT", &measurement, 0)
         && measurement == dwg->header_vars.MEASUREMENT)
       pass ();
     else
       fail ("HEADER.MEASUREMENT [BS] set+1 %hu != %hu",
             dwg->header_vars.MEASUREMENT, measurement);
     measurement--;
     dwg_dynapi_header_set_value (dwg, "MEASUREMENT", &measurement, 0);
 
   }
   {
     BITCODE_BS dragmode;
     if (dwg_dynapi_header_value (dwg, "DRAGMODE", &dragmode, NULL)
         && dragmode == dwg->header_vars.DRAGMODE)
       pass ();
     else
       fail ("HEADER.DRAGMODE [BS] %hu != %hu", dwg->header_vars.DRAGMODE, dragmode);
     dragmode++;
     if (dwg_dynapi_header_set_value (dwg, "DRAGMODE", &dragmode, 0)
         && dragmode == dwg->header_vars.DRAGMODE)
       pass ();
     else
       fail ("HEADER.DRAGMODE [BS] set+1 %hu != %hu",
             dwg->header_vars.DRAGMODE, dragmode);
     dragmode--;
     dwg_dynapi_header_set_value (dwg, "DRAGMODE", &dragmode, 0);
 
   }
   {
     BITCODE_BS treedepth;
     if (dwg_dynapi_header_value (dwg, "TREEDEPTH", &treedepth, NULL)
         && treedepth == dwg->header_vars.TREEDEPTH)
       pass ();
     else
       fail ("HEADER.TREEDEPTH [BS] %hu != %hu", dwg->header_vars.TREEDEPTH, treedepth);
     treedepth++;
     if (dwg_dynapi_header_set_value (dwg, "TREEDEPTH", &treedepth, 0)
         && treedepth == dwg->header_vars.TREEDEPTH)
       pass ();
     else
       fail ("HEADER.TREEDEPTH [BS] set+1 %hu != %hu",
             dwg->header_vars.TREEDEPTH, treedepth);
     treedepth--;
     dwg_dynapi_header_set_value (dwg, "TREEDEPTH", &treedepth, 0);
 
   }
   {
     BITCODE_BS lunits;
     if (dwg_dynapi_header_value (dwg, "LUNITS", &lunits, NULL)
         && lunits == dwg->header_vars.LUNITS)
       pass ();
     else
       fail ("HEADER.LUNITS [BS] %hu != %hu", dwg->header_vars.LUNITS, lunits);
     lunits++;
     if (dwg_dynapi_header_set_value (dwg, "LUNITS", &lunits, 0)
         && lunits == dwg->header_vars.LUNITS)
       pass ();
     else
       fail ("HEADER.LUNITS [BS] set+1 %hu != %hu",
             dwg->header_vars.LUNITS, lunits);
     lunits--;
     dwg_dynapi_header_set_value (dwg, "LUNITS", &lunits, 0);
 
   }
   {
     BITCODE_BS luprec;
     if (dwg_dynapi_header_value (dwg, "LUPREC", &luprec, NULL)
         && luprec == dwg->header_vars.LUPREC)
       pass ();
     else
       fail ("HEADER.LUPREC [BS] %hu != %hu", dwg->header_vars.LUPREC, luprec);
     luprec++;
     if (dwg_dynapi_header_set_value (dwg, "LUPREC", &luprec, 0)
         && luprec == dwg->header_vars.LUPREC)
       pass ();
     else
       fail ("HEADER.LUPREC [BS] set+1 %hu != %hu",
             dwg->header_vars.LUPREC, luprec);
     luprec--;
     dwg_dynapi_header_set_value (dwg, "LUPREC", &luprec, 0);
 
   }
   {
     BITCODE_BS aunits;
     if (dwg_dynapi_header_value (dwg, "AUNITS", &aunits, NULL)
         && aunits == dwg->header_vars.AUNITS)
       pass ();
     else
       fail ("HEADER.AUNITS [BS] %hu != %hu", dwg->header_vars.AUNITS, aunits);
     aunits++;
     if (dwg_dynapi_header_set_value (dwg, "AUNITS", &aunits, 0)
         && aunits == dwg->header_vars.AUNITS)
       pass ();
     else
       fail ("HEADER.AUNITS [BS] set+1 %hu != %hu",
             dwg->header_vars.AUNITS, aunits);
     aunits--;
     dwg_dynapi_header_set_value (dwg, "AUNITS", &aunits, 0);
 
   }
   {
     BITCODE_BS auprec;
     if (dwg_dynapi_header_value (dwg, "AUPREC", &auprec, NULL)
         && auprec == dwg->header_vars.AUPREC)
       pass ();
     else
       fail ("HEADER.AUPREC [BS] %hu != %hu", dwg->header_vars.AUPREC, auprec);
     auprec++;
     if (dwg_dynapi_header_set_value (dwg, "AUPREC", &auprec, 0)
         && auprec == dwg->header_vars.AUPREC)
       pass ();
     else
       fail ("HEADER.AUPREC [BS] set+1 %hu != %hu",
             dwg->header_vars.AUPREC, auprec);
     auprec--;
     dwg_dynapi_header_set_value (dwg, "AUPREC", &auprec, 0);
 
   }
   {
     BITCODE_BS attmode;
     if (dwg_dynapi_header_value (dwg, "ATTMODE", &attmode, NULL)
         && attmode == dwg->header_vars.ATTMODE)
       pass ();
     else
       fail ("HEADER.ATTMODE [BS] %hu != %hu", dwg->header_vars.ATTMODE, attmode);
     attmode++;
     if (dwg_dynapi_header_set_value (dwg, "ATTMODE", &attmode, 0)
         && attmode == dwg->header_vars.ATTMODE)
       pass ();
     else
       fail ("HEADER.ATTMODE [BS] set+1 %hu != %hu",
             dwg->header_vars.ATTMODE, attmode);
     attmode--;
     dwg_dynapi_header_set_value (dwg, "ATTMODE", &attmode, 0);
 
   }
   {
     BITCODE_BS coords;
     if (dwg_dynapi_header_value (dwg, "COORDS", &coords, NULL)
         && coords == dwg->header_vars.COORDS)
       pass ();
     else
       fail ("HEADER.COORDS [BS] %hu != %hu", dwg->header_vars.COORDS, coords);
     coords++;
     if (dwg_dynapi_header_set_value (dwg, "COORDS", &coords, 0)
         && coords == dwg->header_vars.COORDS)
       pass ();
     else
       fail ("HEADER.COORDS [BS] set+1 %hu != %hu",
             dwg->header_vars.COORDS, coords);
     coords--;
     dwg_dynapi_header_set_value (dwg, "COORDS", &coords, 0);
 
   }
   {
     BITCODE_BS pdmode;
     if (dwg_dynapi_header_value (dwg, "PDMODE", &pdmode, NULL)
         && pdmode == dwg->header_vars.PDMODE)
       pass ();
     else
       fail ("HEADER.PDMODE [BS] %hu != %hu", dwg->header_vars.PDMODE, pdmode);
     pdmode++;
     if (dwg_dynapi_header_set_value (dwg, "PDMODE", &pdmode, 0)
         && pdmode == dwg->header_vars.PDMODE)
       pass ();
     else
       fail ("HEADER.PDMODE [BS] set+1 %hu != %hu",
             dwg->header_vars.PDMODE, pdmode);
     pdmode--;
     dwg_dynapi_header_set_value (dwg, "PDMODE", &pdmode, 0);
 
   }
   {
     BITCODE_BS pickstyle;
     if (dwg_dynapi_header_value (dwg, "PICKSTYLE", &pickstyle, NULL)
         && pickstyle == dwg->header_vars.PICKSTYLE)
       pass ();
     else
       fail ("HEADER.PICKSTYLE [BS] %hu != %hu", dwg->header_vars.PICKSTYLE, pickstyle);
     pickstyle++;
     if (dwg_dynapi_header_set_value (dwg, "PICKSTYLE", &pickstyle, 0)
         && pickstyle == dwg->header_vars.PICKSTYLE)
       pass ();
     else
       fail ("HEADER.PICKSTYLE [BS] set+1 %hu != %hu",
             dwg->header_vars.PICKSTYLE, pickstyle);
     pickstyle--;
     dwg_dynapi_header_set_value (dwg, "PICKSTYLE", &pickstyle, 0);
 
   }
   {
     BITCODE_BL osmode;
     if (dwg_dynapi_header_value (dwg, "OSMODE", &osmode, NULL)
         && osmode == dwg->header_vars.OSMODE)
       pass ();
     else
       fail ("HEADER.OSMODE [BL] %u != %u", dwg->header_vars.OSMODE, osmode);
     osmode++;
     if (dwg_dynapi_header_set_value (dwg, "OSMODE", &osmode, 0)
         && osmode == dwg->header_vars.OSMODE)
       pass ();
     else
       fail ("HEADER.OSMODE [BL] set+1 %u != %u",
             dwg->header_vars.OSMODE, osmode);
     osmode--;
     dwg_dynapi_header_set_value (dwg, "OSMODE", &osmode, 0);
 
   }
   {
     BITCODE_BL unknown_12;
     if (dwg_dynapi_header_value (dwg, "unknown_12", &unknown_12, NULL)
         && unknown_12 == dwg->header_vars.unknown_12)
       pass ();
     else
       fail ("HEADER.unknown_12 [BL] %u != %u", dwg->header_vars.unknown_12, unknown_12);
     unknown_12++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_12", &unknown_12, 0)
         && unknown_12 == dwg->header_vars.unknown_12)
       pass ();
     else
       fail ("HEADER.unknown_12 [BL] set+1 %u != %u",
             dwg->header_vars.unknown_12, unknown_12);
     unknown_12--;
     dwg_dynapi_header_set_value (dwg, "unknown_12", &unknown_12, 0);
 
   }
   {
     BITCODE_BL unknown_13;
     if (dwg_dynapi_header_value (dwg, "unknown_13", &unknown_13, NULL)
         && unknown_13 == dwg->header_vars.unknown_13)
       pass ();
     else
       fail ("HEADER.unknown_13 [BL] %u != %u", dwg->header_vars.unknown_13, unknown_13);
     unknown_13++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_13", &unknown_13, 0)
         && unknown_13 == dwg->header_vars.unknown_13)
       pass ();
     else
       fail ("HEADER.unknown_13 [BL] set+1 %u != %u",
             dwg->header_vars.unknown_13, unknown_13);
     unknown_13--;
     dwg_dynapi_header_set_value (dwg, "unknown_13", &unknown_13, 0);
 
   }
   {
     BITCODE_BL unknown_14;
     if (dwg_dynapi_header_value (dwg, "unknown_14", &unknown_14, NULL)
         && unknown_14 == dwg->header_vars.unknown_14)
       pass ();
     else
       fail ("HEADER.unknown_14 [BL] %u != %u", dwg->header_vars.unknown_14, unknown_14);
     unknown_14++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_14", &unknown_14, 0)
         && unknown_14 == dwg->header_vars.unknown_14)
       pass ();
     else
       fail ("HEADER.unknown_14 [BL] set+1 %u != %u",
             dwg->header_vars.unknown_14, unknown_14);
     unknown_14--;
     dwg_dynapi_header_set_value (dwg, "unknown_14", &unknown_14, 0);
 
   }
   {
     BITCODE_BSd useri1;
     if (dwg_dynapi_header_value (dwg, "USERI1", &useri1, NULL)
         && useri1 == dwg->header_vars.USERI1)
       pass ();
     else
       fail ("HEADER.USERI1 [BSd] " FORMAT_BSd " != " FORMAT_BSd "", dwg->header_vars.USERI1, useri1);
     useri1++;
     if (dwg_dynapi_header_set_value (dwg, "USERI1", &useri1, 0)
         && useri1 == dwg->header_vars.USERI1)
       pass ();
     else
       fail ("HEADER.USERI1 [BSd] set+1 " FORMAT_BSd " != " FORMAT_BSd "",
             dwg->header_vars.USERI1, useri1);
     useri1--;
     dwg_dynapi_header_set_value (dwg, "USERI1", &useri1, 0);
 
   }
   {
     BITCODE_BSd useri2;
     if (dwg_dynapi_header_value (dwg, "USERI2", &useri2, NULL)
         && useri2 == dwg->header_vars.USERI2)
       pass ();
     else
       fail ("HEADER.USERI2 [BSd] " FORMAT_BSd " != " FORMAT_BSd "", dwg->header_vars.USERI2, useri2);
     useri2++;
     if (dwg_dynapi_header_set_value (dwg, "USERI2", &useri2, 0)
         && useri2 == dwg->header_vars.USERI2)
       pass ();
     else
       fail ("HEADER.USERI2 [BSd] set+1 " FORMAT_BSd " != " FORMAT_BSd "",
             dwg->header_vars.USERI2, useri2);
     useri2--;
     dwg_dynapi_header_set_value (dwg, "USERI2", &useri2, 0);
 
   }
   {
     BITCODE_BSd useri3;
     if (dwg_dynapi_header_value (dwg, "USERI3", &useri3, NULL)
         && useri3 == dwg->header_vars.USERI3)
       pass ();
     else
       fail ("HEADER.USERI3 [BSd] " FORMAT_BSd " != " FORMAT_BSd "", dwg->header_vars.USERI3, useri3);
     useri3++;
     if (dwg_dynapi_header_set_value (dwg, "USERI3", &useri3, 0)
         && useri3 == dwg->header_vars.USERI3)
       pass ();
     else
       fail ("HEADER.USERI3 [BSd] set+1 " FORMAT_BSd " != " FORMAT_BSd "",
             dwg->header_vars.USERI3, useri3);
     useri3--;
     dwg_dynapi_header_set_value (dwg, "USERI3", &useri3, 0);
 
   }
   {
     BITCODE_BSd useri4;
     if (dwg_dynapi_header_value (dwg, "USERI4", &useri4, NULL)
         && useri4 == dwg->header_vars.USERI4)
       pass ();
     else
       fail ("HEADER.USERI4 [BSd] " FORMAT_BSd " != " FORMAT_BSd "", dwg->header_vars.USERI4, useri4);
     useri4++;
     if (dwg_dynapi_header_set_value (dwg, "USERI4", &useri4, 0)
         && useri4 == dwg->header_vars.USERI4)
       pass ();
     else
       fail ("HEADER.USERI4 [BSd] set+1 " FORMAT_BSd " != " FORMAT_BSd "",
             dwg->header_vars.USERI4, useri4);
     useri4--;
     dwg_dynapi_header_set_value (dwg, "USERI4", &useri4, 0);
 
   }
   {
     BITCODE_BSd useri5;
     if (dwg_dynapi_header_value (dwg, "USERI5", &useri5, NULL)
         && useri5 == dwg->header_vars.USERI5)
       pass ();
     else
       fail ("HEADER.USERI5 [BSd] " FORMAT_BSd " != " FORMAT_BSd "", dwg->header_vars.USERI5, useri5);
     useri5++;
     if (dwg_dynapi_header_set_value (dwg, "USERI5", &useri5, 0)
         && useri5 == dwg->header_vars.USERI5)
       pass ();
     else
       fail ("HEADER.USERI5 [BSd] set+1 " FORMAT_BSd " != " FORMAT_BSd "",
             dwg->header_vars.USERI5, useri5);
     useri5--;
     dwg_dynapi_header_set_value (dwg, "USERI5", &useri5, 0);
 
   }
   {
     BITCODE_BS splinesegs;
     if (dwg_dynapi_header_value (dwg, "SPLINESEGS", &splinesegs, NULL)
         && splinesegs == dwg->header_vars.SPLINESEGS)
       pass ();
     else
       fail ("HEADER.SPLINESEGS [BS] %hu != %hu", dwg->header_vars.SPLINESEGS, splinesegs);
     splinesegs++;
     if (dwg_dynapi_header_set_value (dwg, "SPLINESEGS", &splinesegs, 0)
         && splinesegs == dwg->header_vars.SPLINESEGS)
       pass ();
     else
       fail ("HEADER.SPLINESEGS [BS] set+1 %hu != %hu",
             dwg->header_vars.SPLINESEGS, splinesegs);
     splinesegs--;
     dwg_dynapi_header_set_value (dwg, "SPLINESEGS", &splinesegs, 0);
 
   }
   {
     BITCODE_BS surfu;
     if (dwg_dynapi_header_value (dwg, "SURFU", &surfu, NULL)
         && surfu == dwg->header_vars.SURFU)
       pass ();
     else
       fail ("HEADER.SURFU [BS] %hu != %hu", dwg->header_vars.SURFU, surfu);
     surfu++;
     if (dwg_dynapi_header_set_value (dwg, "SURFU", &surfu, 0)
         && surfu == dwg->header_vars.SURFU)
       pass ();
     else
       fail ("HEADER.SURFU [BS] set+1 %hu != %hu",
             dwg->header_vars.SURFU, surfu);
     surfu--;
     dwg_dynapi_header_set_value (dwg, "SURFU", &surfu, 0);
 
   }
   {
     BITCODE_BS surfv;
     if (dwg_dynapi_header_value (dwg, "SURFV", &surfv, NULL)
         && surfv == dwg->header_vars.SURFV)
       pass ();
     else
       fail ("HEADER.SURFV [BS] %hu != %hu", dwg->header_vars.SURFV, surfv);
     surfv++;
     if (dwg_dynapi_header_set_value (dwg, "SURFV", &surfv, 0)
         && surfv == dwg->header_vars.SURFV)
       pass ();
     else
       fail ("HEADER.SURFV [BS] set+1 %hu != %hu",
             dwg->header_vars.SURFV, surfv);
     surfv--;
     dwg_dynapi_header_set_value (dwg, "SURFV", &surfv, 0);
 
   }
   {
     BITCODE_BS surftype;
     if (dwg_dynapi_header_value (dwg, "SURFTYPE", &surftype, NULL)
         && surftype == dwg->header_vars.SURFTYPE)
       pass ();
     else
       fail ("HEADER.SURFTYPE [BS] %hu != %hu", dwg->header_vars.SURFTYPE, surftype);
     surftype++;
     if (dwg_dynapi_header_set_value (dwg, "SURFTYPE", &surftype, 0)
         && surftype == dwg->header_vars.SURFTYPE)
       pass ();
     else
       fail ("HEADER.SURFTYPE [BS] set+1 %hu != %hu",
             dwg->header_vars.SURFTYPE, surftype);
     surftype--;
     dwg_dynapi_header_set_value (dwg, "SURFTYPE", &surftype, 0);
 
   }
   {
     BITCODE_BS surftab1;
     if (dwg_dynapi_header_value (dwg, "SURFTAB1", &surftab1, NULL)
         && surftab1 == dwg->header_vars.SURFTAB1)
       pass ();
     else
       fail ("HEADER.SURFTAB1 [BS] %hu != %hu", dwg->header_vars.SURFTAB1, surftab1);
     surftab1++;
     if (dwg_dynapi_header_set_value (dwg, "SURFTAB1", &surftab1, 0)
         && surftab1 == dwg->header_vars.SURFTAB1)
       pass ();
     else
       fail ("HEADER.SURFTAB1 [BS] set+1 %hu != %hu",
             dwg->header_vars.SURFTAB1, surftab1);
     surftab1--;
     dwg_dynapi_header_set_value (dwg, "SURFTAB1", &surftab1, 0);
 
   }
   {
     BITCODE_BS surftab2;
     if (dwg_dynapi_header_value (dwg, "SURFTAB2", &surftab2, NULL)
         && surftab2 == dwg->header_vars.SURFTAB2)
       pass ();
     else
       fail ("HEADER.SURFTAB2 [BS] %hu != %hu", dwg->header_vars.SURFTAB2, surftab2);
     surftab2++;
     if (dwg_dynapi_header_set_value (dwg, "SURFTAB2", &surftab2, 0)
         && surftab2 == dwg->header_vars.SURFTAB2)
       pass ();
     else
       fail ("HEADER.SURFTAB2 [BS] set+1 %hu != %hu",
             dwg->header_vars.SURFTAB2, surftab2);
     surftab2--;
     dwg_dynapi_header_set_value (dwg, "SURFTAB2", &surftab2, 0);
 
   }
   {
     BITCODE_BS splinetype;
     if (dwg_dynapi_header_value (dwg, "SPLINETYPE", &splinetype, NULL)
         && splinetype == dwg->header_vars.SPLINETYPE)
       pass ();
     else
       fail ("HEADER.SPLINETYPE [BS] %hu != %hu", dwg->header_vars.SPLINETYPE, splinetype);
     splinetype++;
     if (dwg_dynapi_header_set_value (dwg, "SPLINETYPE", &splinetype, 0)
         && splinetype == dwg->header_vars.SPLINETYPE)
       pass ();
     else
       fail ("HEADER.SPLINETYPE [BS] set+1 %hu != %hu",
             dwg->header_vars.SPLINETYPE, splinetype);
     splinetype--;
     dwg_dynapi_header_set_value (dwg, "SPLINETYPE", &splinetype, 0);
 
   }
   {
     BITCODE_BS shadedge;
     if (dwg_dynapi_header_value (dwg, "SHADEDGE", &shadedge, NULL)
         && shadedge == dwg->header_vars.SHADEDGE)
       pass ();
     else
       fail ("HEADER.SHADEDGE [BS] %hu != %hu", dwg->header_vars.SHADEDGE, shadedge);
     shadedge++;
     if (dwg_dynapi_header_set_value (dwg, "SHADEDGE", &shadedge, 0)
         && shadedge == dwg->header_vars.SHADEDGE)
       pass ();
     else
       fail ("HEADER.SHADEDGE [BS] set+1 %hu != %hu",
             dwg->header_vars.SHADEDGE, shadedge);
     shadedge--;
     dwg_dynapi_header_set_value (dwg, "SHADEDGE", &shadedge, 0);
 
   }
   {
     BITCODE_BS shadedif;
     if (dwg_dynapi_header_value (dwg, "SHADEDIF", &shadedif, NULL)
         && shadedif == dwg->header_vars.SHADEDIF)
       pass ();
     else
       fail ("HEADER.SHADEDIF [BS] %hu != %hu", dwg->header_vars.SHADEDIF, shadedif);
     shadedif++;
     if (dwg_dynapi_header_set_value (dwg, "SHADEDIF", &shadedif, 0)
         && shadedif == dwg->header_vars.SHADEDIF)
       pass ();
     else
       fail ("HEADER.SHADEDIF [BS] set+1 %hu != %hu",
             dwg->header_vars.SHADEDIF, shadedif);
     shadedif--;
     dwg_dynapi_header_set_value (dwg, "SHADEDIF", &shadedif, 0);
 
   }
   {
     BITCODE_BS unitmode;
     if (dwg_dynapi_header_value (dwg, "UNITMODE", &unitmode, NULL)
         && unitmode == dwg->header_vars.UNITMODE)
       pass ();
     else
       fail ("HEADER.UNITMODE [BS] %hu != %hu", dwg->header_vars.UNITMODE, unitmode);
     unitmode++;
     if (dwg_dynapi_header_set_value (dwg, "UNITMODE", &unitmode, 0)
         && unitmode == dwg->header_vars.UNITMODE)
       pass ();
     else
       fail ("HEADER.UNITMODE [BS] set+1 %hu != %hu",
             dwg->header_vars.UNITMODE, unitmode);
     unitmode--;
     dwg_dynapi_header_set_value (dwg, "UNITMODE", &unitmode, 0);
 
   }
   {
     BITCODE_BS maxactvp;
     if (dwg_dynapi_header_value (dwg, "MAXACTVP", &maxactvp, NULL)
         && maxactvp == dwg->header_vars.MAXACTVP)
       pass ();
     else
       fail ("HEADER.MAXACTVP [BS] %hu != %hu", dwg->header_vars.MAXACTVP, maxactvp);
     maxactvp++;
     if (dwg_dynapi_header_set_value (dwg, "MAXACTVP", &maxactvp, 0)
         && maxactvp == dwg->header_vars.MAXACTVP)
       pass ();
     else
       fail ("HEADER.MAXACTVP [BS] set+1 %hu != %hu",
             dwg->header_vars.MAXACTVP, maxactvp);
     maxactvp--;
     dwg_dynapi_header_set_value (dwg, "MAXACTVP", &maxactvp, 0);
 
   }
   {
     BITCODE_BS isolines;
     if (dwg_dynapi_header_value (dwg, "ISOLINES", &isolines, NULL)
         && isolines == dwg->header_vars.ISOLINES)
       pass ();
     else
       fail ("HEADER.ISOLINES [BS] %hu != %hu", dwg->header_vars.ISOLINES, isolines);
     isolines++;
     if (dwg_dynapi_header_set_value (dwg, "ISOLINES", &isolines, 0)
         && isolines == dwg->header_vars.ISOLINES)
       pass ();
     else
       fail ("HEADER.ISOLINES [BS] set+1 %hu != %hu",
             dwg->header_vars.ISOLINES, isolines);
     isolines--;
     dwg_dynapi_header_set_value (dwg, "ISOLINES", &isolines, 0);
 
   }
   {
     BITCODE_BS cmljust;
     if (dwg_dynapi_header_value (dwg, "CMLJUST", &cmljust, NULL)
         && cmljust == dwg->header_vars.CMLJUST)
       pass ();
     else
       fail ("HEADER.CMLJUST [BS] %hu != %hu", dwg->header_vars.CMLJUST, cmljust);
     cmljust++;
     if (dwg_dynapi_header_set_value (dwg, "CMLJUST", &cmljust, 0)
         && cmljust == dwg->header_vars.CMLJUST)
       pass ();
     else
       fail ("HEADER.CMLJUST [BS] set+1 %hu != %hu",
             dwg->header_vars.CMLJUST, cmljust);
     cmljust--;
     dwg_dynapi_header_set_value (dwg, "CMLJUST", &cmljust, 0);
 
   }
   {
     BITCODE_BS textqlty;
     if (dwg_dynapi_header_value (dwg, "TEXTQLTY", &textqlty, NULL)
         && textqlty == dwg->header_vars.TEXTQLTY)
       pass ();
     else
       fail ("HEADER.TEXTQLTY [BS] %hu != %hu", dwg->header_vars.TEXTQLTY, textqlty);
     textqlty++;
     if (dwg_dynapi_header_set_value (dwg, "TEXTQLTY", &textqlty, 0)
         && textqlty == dwg->header_vars.TEXTQLTY)
       pass ();
     else
       fail ("HEADER.TEXTQLTY [BS] set+1 %hu != %hu",
             dwg->header_vars.TEXTQLTY, textqlty);
     textqlty--;
     dwg_dynapi_header_set_value (dwg, "TEXTQLTY", &textqlty, 0);
 
   }
   {
     BITCODE_BL unknown_14b;
     if (dwg_dynapi_header_value (dwg, "unknown_14b", &unknown_14b, NULL)
         && unknown_14b == dwg->header_vars.unknown_14b)
       pass ();
     else
       fail ("HEADER.unknown_14b [BL] %u != %u", dwg->header_vars.unknown_14b, unknown_14b);
     unknown_14b++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_14b", &unknown_14b, 0)
         && unknown_14b == dwg->header_vars.unknown_14b)
       pass ();
     else
       fail ("HEADER.unknown_14b [BL] set+1 %u != %u",
             dwg->header_vars.unknown_14b, unknown_14b);
     unknown_14b--;
     dwg_dynapi_header_set_value (dwg, "unknown_14b", &unknown_14b, 0);
 
   }
   {
     BITCODE_BD ltscale;
     if (dwg_dynapi_header_value (dwg, "LTSCALE", &ltscale, NULL)
         && ltscale == dwg->header_vars.LTSCALE)
       pass ();
     else
       fail ("HEADER.LTSCALE [BD] %g != %g", dwg->header_vars.LTSCALE, ltscale);
     ltscale++;
     if (dwg_dynapi_header_set_value (dwg, "LTSCALE", &ltscale, 0)
         && ltscale == dwg->header_vars.LTSCALE)
       pass ();
     else
       fail ("HEADER.LTSCALE [BD] set+1 %g != %g",
             dwg->header_vars.LTSCALE, ltscale);
     ltscale--;
     dwg_dynapi_header_set_value (dwg, "LTSCALE", &ltscale, 0);
 
   }
   {
     BITCODE_BD textsize;
     if (dwg_dynapi_header_value (dwg, "TEXTSIZE", &textsize, NULL)
         && textsize == dwg->header_vars.TEXTSIZE)
       pass ();
     else
       fail ("HEADER.TEXTSIZE [BD] %g != %g", dwg->header_vars.TEXTSIZE, textsize);
     textsize++;
     if (dwg_dynapi_header_set_value (dwg, "TEXTSIZE", &textsize, 0)
         && textsize == dwg->header_vars.TEXTSIZE)
       pass ();
     else
       fail ("HEADER.TEXTSIZE [BD] set+1 %g != %g",
             dwg->header_vars.TEXTSIZE, textsize);
     textsize--;
     dwg_dynapi_header_set_value (dwg, "TEXTSIZE", &textsize, 0);
 
   }
   {
     BITCODE_BD tracewid;
     if (dwg_dynapi_header_value (dwg, "TRACEWID", &tracewid, NULL)
         && tracewid == dwg->header_vars.TRACEWID)
       pass ();
     else
       fail ("HEADER.TRACEWID [BD] %g != %g", dwg->header_vars.TRACEWID, tracewid);
     tracewid++;
     if (dwg_dynapi_header_set_value (dwg, "TRACEWID", &tracewid, 0)
         && tracewid == dwg->header_vars.TRACEWID)
       pass ();
     else
       fail ("HEADER.TRACEWID [BD] set+1 %g != %g",
             dwg->header_vars.TRACEWID, tracewid);
     tracewid--;
     dwg_dynapi_header_set_value (dwg, "TRACEWID", &tracewid, 0);
 
   }
   {
     BITCODE_BD sketchinc;
     if (dwg_dynapi_header_value (dwg, "SKETCHINC", &sketchinc, NULL)
         && sketchinc == dwg->header_vars.SKETCHINC)
       pass ();
     else
       fail ("HEADER.SKETCHINC [BD] %g != %g", dwg->header_vars.SKETCHINC, sketchinc);
     sketchinc++;
     if (dwg_dynapi_header_set_value (dwg, "SKETCHINC", &sketchinc, 0)
         && sketchinc == dwg->header_vars.SKETCHINC)
       pass ();
     else
       fail ("HEADER.SKETCHINC [BD] set+1 %g != %g",
             dwg->header_vars.SKETCHINC, sketchinc);
     sketchinc--;
     dwg_dynapi_header_set_value (dwg, "SKETCHINC", &sketchinc, 0);
 
   }
   {
     BITCODE_BD filletrad;
     if (dwg_dynapi_header_value (dwg, "FILLETRAD", &filletrad, NULL)
         && filletrad == dwg->header_vars.FILLETRAD)
       pass ();
     else
       fail ("HEADER.FILLETRAD [BD] %g != %g", dwg->header_vars.FILLETRAD, filletrad);
     filletrad++;
     if (dwg_dynapi_header_set_value (dwg, "FILLETRAD", &filletrad, 0)
         && filletrad == dwg->header_vars.FILLETRAD)
       pass ();
     else
       fail ("HEADER.FILLETRAD [BD] set+1 %g != %g",
             dwg->header_vars.FILLETRAD, filletrad);
     filletrad--;
     dwg_dynapi_header_set_value (dwg, "FILLETRAD", &filletrad, 0);
 
   }
   {
     BITCODE_BD thickness;
     if (dwg_dynapi_header_value (dwg, "THICKNESS", &thickness, NULL)
         && thickness == dwg->header_vars.THICKNESS)
       pass ();
     else
       fail ("HEADER.THICKNESS [BD] %g != %g", dwg->header_vars.THICKNESS, thickness);
     thickness++;
     if (dwg_dynapi_header_set_value (dwg, "THICKNESS", &thickness, 0)
         && thickness == dwg->header_vars.THICKNESS)
       pass ();
     else
       fail ("HEADER.THICKNESS [BD] set+1 %g != %g",
             dwg->header_vars.THICKNESS, thickness);
     thickness--;
     dwg_dynapi_header_set_value (dwg, "THICKNESS", &thickness, 0);
 
   }
   {
     BITCODE_BD angbase;
     if (dwg_dynapi_header_value (dwg, "ANGBASE", &angbase, NULL)
         && angbase == dwg->header_vars.ANGBASE)
       pass ();
     else
       fail ("HEADER.ANGBASE [BD] %g != %g", dwg->header_vars.ANGBASE, angbase);
     angbase++;
     if (dwg_dynapi_header_set_value (dwg, "ANGBASE", &angbase, 0)
         && angbase == dwg->header_vars.ANGBASE)
       pass ();
     else
       fail ("HEADER.ANGBASE [BD] set+1 %g != %g",
             dwg->header_vars.ANGBASE, angbase);
     angbase--;
     dwg_dynapi_header_set_value (dwg, "ANGBASE", &angbase, 0);
 
   }
   {
     BITCODE_BD pdsize;
     if (dwg_dynapi_header_value (dwg, "PDSIZE", &pdsize, NULL)
         && pdsize == dwg->header_vars.PDSIZE)
       pass ();
     else
       fail ("HEADER.PDSIZE [BD] %g != %g", dwg->header_vars.PDSIZE, pdsize);
     pdsize++;
     if (dwg_dynapi_header_set_value (dwg, "PDSIZE", &pdsize, 0)
         && pdsize == dwg->header_vars.PDSIZE)
       pass ();
     else
       fail ("HEADER.PDSIZE [BD] set+1 %g != %g",
             dwg->header_vars.PDSIZE, pdsize);
     pdsize--;
     dwg_dynapi_header_set_value (dwg, "PDSIZE", &pdsize, 0);
 
   }
   {
     BITCODE_BD plinewid;
     if (dwg_dynapi_header_value (dwg, "PLINEWID", &plinewid, NULL)
         && plinewid == dwg->header_vars.PLINEWID)
       pass ();
     else
       fail ("HEADER.PLINEWID [BD] %g != %g", dwg->header_vars.PLINEWID, plinewid);
     plinewid++;
     if (dwg_dynapi_header_set_value (dwg, "PLINEWID", &plinewid, 0)
         && plinewid == dwg->header_vars.PLINEWID)
       pass ();
     else
       fail ("HEADER.PLINEWID [BD] set+1 %g != %g",
             dwg->header_vars.PLINEWID, plinewid);
     plinewid--;
     dwg_dynapi_header_set_value (dwg, "PLINEWID", &plinewid, 0);
 
   }
   {
     BITCODE_BD userr1;
     if (dwg_dynapi_header_value (dwg, "USERR1", &userr1, NULL)
         && userr1 == dwg->header_vars.USERR1)
       pass ();
     else
       fail ("HEADER.USERR1 [BD] %g != %g", dwg->header_vars.USERR1, userr1);
     userr1++;
     if (dwg_dynapi_header_set_value (dwg, "USERR1", &userr1, 0)
         && userr1 == dwg->header_vars.USERR1)
       pass ();
     else
       fail ("HEADER.USERR1 [BD] set+1 %g != %g",
             dwg->header_vars.USERR1, userr1);
     userr1--;
     dwg_dynapi_header_set_value (dwg, "USERR1", &userr1, 0);
 
   }
   {
     BITCODE_BD userr2;
     if (dwg_dynapi_header_value (dwg, "USERR2", &userr2, NULL)
         && userr2 == dwg->header_vars.USERR2)
       pass ();
     else
       fail ("HEADER.USERR2 [BD] %g != %g", dwg->header_vars.USERR2, userr2);
     userr2++;
     if (dwg_dynapi_header_set_value (dwg, "USERR2", &userr2, 0)
         && userr2 == dwg->header_vars.USERR2)
       pass ();
     else
       fail ("HEADER.USERR2 [BD] set+1 %g != %g",
             dwg->header_vars.USERR2, userr2);
     userr2--;
     dwg_dynapi_header_set_value (dwg, "USERR2", &userr2, 0);
 
   }
   {
     BITCODE_BD userr3;
     if (dwg_dynapi_header_value (dwg, "USERR3", &userr3, NULL)
         && userr3 == dwg->header_vars.USERR3)
       pass ();
     else
       fail ("HEADER.USERR3 [BD] %g != %g", dwg->header_vars.USERR3, userr3);
     userr3++;
     if (dwg_dynapi_header_set_value (dwg, "USERR3", &userr3, 0)
         && userr3 == dwg->header_vars.USERR3)
       pass ();
     else
       fail ("HEADER.USERR3 [BD] set+1 %g != %g",
             dwg->header_vars.USERR3, userr3);
     userr3--;
     dwg_dynapi_header_set_value (dwg, "USERR3", &userr3, 0);
 
   }
   {
     BITCODE_BD userr4;
     if (dwg_dynapi_header_value (dwg, "USERR4", &userr4, NULL)
         && userr4 == dwg->header_vars.USERR4)
       pass ();
     else
       fail ("HEADER.USERR4 [BD] %g != %g", dwg->header_vars.USERR4, userr4);
     userr4++;
     if (dwg_dynapi_header_set_value (dwg, "USERR4", &userr4, 0)
         && userr4 == dwg->header_vars.USERR4)
       pass ();
     else
       fail ("HEADER.USERR4 [BD] set+1 %g != %g",
             dwg->header_vars.USERR4, userr4);
     userr4--;
     dwg_dynapi_header_set_value (dwg, "USERR4", &userr4, 0);
 
   }
   {
     BITCODE_BD userr5;
     if (dwg_dynapi_header_value (dwg, "USERR5", &userr5, NULL)
         && userr5 == dwg->header_vars.USERR5)
       pass ();
     else
       fail ("HEADER.USERR5 [BD] %g != %g", dwg->header_vars.USERR5, userr5);
     userr5++;
     if (dwg_dynapi_header_set_value (dwg, "USERR5", &userr5, 0)
         && userr5 == dwg->header_vars.USERR5)
       pass ();
     else
       fail ("HEADER.USERR5 [BD] set+1 %g != %g",
             dwg->header_vars.USERR5, userr5);
     userr5--;
     dwg_dynapi_header_set_value (dwg, "USERR5", &userr5, 0);
 
   }
   {
     BITCODE_BD chamfera;
     if (dwg_dynapi_header_value (dwg, "CHAMFERA", &chamfera, NULL)
         && chamfera == dwg->header_vars.CHAMFERA)
       pass ();
     else
       fail ("HEADER.CHAMFERA [BD] %g != %g", dwg->header_vars.CHAMFERA, chamfera);
     chamfera++;
     if (dwg_dynapi_header_set_value (dwg, "CHAMFERA", &chamfera, 0)
         && chamfera == dwg->header_vars.CHAMFERA)
       pass ();
     else
       fail ("HEADER.CHAMFERA [BD] set+1 %g != %g",
             dwg->header_vars.CHAMFERA, chamfera);
     chamfera--;
     dwg_dynapi_header_set_value (dwg, "CHAMFERA", &chamfera, 0);
 
   }
   {
     BITCODE_BD chamferb;
     if (dwg_dynapi_header_value (dwg, "CHAMFERB", &chamferb, NULL)
         && chamferb == dwg->header_vars.CHAMFERB)
       pass ();
     else
       fail ("HEADER.CHAMFERB [BD] %g != %g", dwg->header_vars.CHAMFERB, chamferb);
     chamferb++;
     if (dwg_dynapi_header_set_value (dwg, "CHAMFERB", &chamferb, 0)
         && chamferb == dwg->header_vars.CHAMFERB)
       pass ();
     else
       fail ("HEADER.CHAMFERB [BD] set+1 %g != %g",
             dwg->header_vars.CHAMFERB, chamferb);
     chamferb--;
     dwg_dynapi_header_set_value (dwg, "CHAMFERB", &chamferb, 0);
 
   }
   {
     BITCODE_BD chamferc;
     if (dwg_dynapi_header_value (dwg, "CHAMFERC", &chamferc, NULL)
         && chamferc == dwg->header_vars.CHAMFERC)
       pass ();
     else
       fail ("HEADER.CHAMFERC [BD] %g != %g", dwg->header_vars.CHAMFERC, chamferc);
     chamferc++;
     if (dwg_dynapi_header_set_value (dwg, "CHAMFERC", &chamferc, 0)
         && chamferc == dwg->header_vars.CHAMFERC)
       pass ();
     else
       fail ("HEADER.CHAMFERC [BD] set+1 %g != %g",
             dwg->header_vars.CHAMFERC, chamferc);
     chamferc--;
     dwg_dynapi_header_set_value (dwg, "CHAMFERC", &chamferc, 0);
 
   }
   {
     BITCODE_BD chamferd;
     if (dwg_dynapi_header_value (dwg, "CHAMFERD", &chamferd, NULL)
         && chamferd == dwg->header_vars.CHAMFERD)
       pass ();
     else
       fail ("HEADER.CHAMFERD [BD] %g != %g", dwg->header_vars.CHAMFERD, chamferd);
     chamferd++;
     if (dwg_dynapi_header_set_value (dwg, "CHAMFERD", &chamferd, 0)
         && chamferd == dwg->header_vars.CHAMFERD)
       pass ();
     else
       fail ("HEADER.CHAMFERD [BD] set+1 %g != %g",
             dwg->header_vars.CHAMFERD, chamferd);
     chamferd--;
     dwg_dynapi_header_set_value (dwg, "CHAMFERD", &chamferd, 0);
 
   }
   {
     BITCODE_BD facetres;
     if (dwg_dynapi_header_value (dwg, "FACETRES", &facetres, NULL)
         && facetres == dwg->header_vars.FACETRES)
       pass ();
     else
       fail ("HEADER.FACETRES [BD] %g != %g", dwg->header_vars.FACETRES, facetres);
     facetres++;
     if (dwg_dynapi_header_set_value (dwg, "FACETRES", &facetres, 0)
         && facetres == dwg->header_vars.FACETRES)
       pass ();
     else
       fail ("HEADER.FACETRES [BD] set+1 %g != %g",
             dwg->header_vars.FACETRES, facetres);
     facetres--;
     dwg_dynapi_header_set_value (dwg, "FACETRES", &facetres, 0);
 
   }
   {
     BITCODE_BD cmlscale;
     if (dwg_dynapi_header_value (dwg, "CMLSCALE", &cmlscale, NULL)
         && cmlscale == dwg->header_vars.CMLSCALE)
       pass ();
     else
       fail ("HEADER.CMLSCALE [BD] %g != %g", dwg->header_vars.CMLSCALE, cmlscale);
     cmlscale++;
     if (dwg_dynapi_header_set_value (dwg, "CMLSCALE", &cmlscale, 0)
         && cmlscale == dwg->header_vars.CMLSCALE)
       pass ();
     else
       fail ("HEADER.CMLSCALE [BD] set+1 %g != %g",
             dwg->header_vars.CMLSCALE, cmlscale);
     cmlscale--;
     dwg_dynapi_header_set_value (dwg, "CMLSCALE", &cmlscale, 0);
 
   }
   {
     BITCODE_BD celtscale;
     if (dwg_dynapi_header_value (dwg, "CELTSCALE", &celtscale, NULL)
         && celtscale == dwg->header_vars.CELTSCALE)
       pass ();
     else
       fail ("HEADER.CELTSCALE [BD] %g != %g", dwg->header_vars.CELTSCALE, celtscale);
     celtscale++;
     if (dwg_dynapi_header_set_value (dwg, "CELTSCALE", &celtscale, 0)
         && celtscale == dwg->header_vars.CELTSCALE)
       pass ();
     else
       fail ("HEADER.CELTSCALE [BD] set+1 %g != %g",
             dwg->header_vars.CELTSCALE, celtscale);
     celtscale--;
     dwg_dynapi_header_set_value (dwg, "CELTSCALE", &celtscale, 0);
 
   }
   {
     BITCODE_BD viewtwist;
     if (dwg_dynapi_header_value (dwg, "VIEWTWIST", &viewtwist, NULL)
         && viewtwist == dwg->header_vars.VIEWTWIST)
       pass ();
     else
       fail ("HEADER.VIEWTWIST [BD] %g != %g", dwg->header_vars.VIEWTWIST, viewtwist);
     viewtwist++;
     if (dwg_dynapi_header_set_value (dwg, "VIEWTWIST", &viewtwist, 0)
         && viewtwist == dwg->header_vars.VIEWTWIST)
       pass ();
     else
       fail ("HEADER.VIEWTWIST [BD] set+1 %g != %g",
             dwg->header_vars.VIEWTWIST, viewtwist);
     viewtwist--;
     dwg_dynapi_header_set_value (dwg, "VIEWTWIST", &viewtwist, 0);
 
   }
   {
     BITCODE_TV menu;
     if (dwg_dynapi_header_value (dwg, "MENU", &menu, NULL)
         && !memcmp (&menu, &dwg->header_vars.MENU, sizeof (dwg->header_vars.MENU))
        )
       pass ();
     else
       fail ("HEADER.MENU [TV]");
   }
   {
     BITCODE_TIMEBLL tdcreate;
     if (dwg_dynapi_header_value (dwg, "TDCREATE", &tdcreate, NULL)
         && !memcmp (&tdcreate, &dwg->header_vars.TDCREATE, sizeof (dwg->header_vars.TDCREATE))
        )
       pass ();
     else
       fail ("HEADER.TDCREATE [TIMEBLL]");
   }
   {
     BITCODE_TIMEBLL tdupdate;
     if (dwg_dynapi_header_value (dwg, "TDUPDATE", &tdupdate, NULL)
         && !memcmp (&tdupdate, &dwg->header_vars.TDUPDATE, sizeof (dwg->header_vars.TDUPDATE))
        )
       pass ();
     else
       fail ("HEADER.TDUPDATE [TIMEBLL]");
   }
   {
     BITCODE_TIMEBLL tducreate;
     if (dwg_dynapi_header_value (dwg, "TDUCREATE", &tducreate, NULL)
         && !memcmp (&tducreate, &dwg->header_vars.TDUCREATE, sizeof (dwg->header_vars.TDUCREATE))
        )
       pass ();
     else
       fail ("HEADER.TDUCREATE [TIMEBLL]");
   }
   {
     BITCODE_TIMEBLL tduupdate;
     if (dwg_dynapi_header_value (dwg, "TDUUPDATE", &tduupdate, NULL)
         && !memcmp (&tduupdate, &dwg->header_vars.TDUUPDATE, sizeof (dwg->header_vars.TDUUPDATE))
        )
       pass ();
     else
       fail ("HEADER.TDUUPDATE [TIMEBLL]");
   }
   {
     BITCODE_BL unknown_15;
     if (dwg_dynapi_header_value (dwg, "unknown_15", &unknown_15, NULL)
         && unknown_15 == dwg->header_vars.unknown_15)
       pass ();
     else
       fail ("HEADER.unknown_15 [BL] %u != %u", dwg->header_vars.unknown_15, unknown_15);
     unknown_15++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_15", &unknown_15, 0)
         && unknown_15 == dwg->header_vars.unknown_15)
       pass ();
     else
       fail ("HEADER.unknown_15 [BL] set+1 %u != %u",
             dwg->header_vars.unknown_15, unknown_15);
     unknown_15--;
     dwg_dynapi_header_set_value (dwg, "unknown_15", &unknown_15, 0);
 
   }
   {
     BITCODE_BL unknown_16;
     if (dwg_dynapi_header_value (dwg, "unknown_16", &unknown_16, NULL)
         && unknown_16 == dwg->header_vars.unknown_16)
       pass ();
     else
       fail ("HEADER.unknown_16 [BL] %u != %u", dwg->header_vars.unknown_16, unknown_16);
     unknown_16++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_16", &unknown_16, 0)
         && unknown_16 == dwg->header_vars.unknown_16)
       pass ();
     else
       fail ("HEADER.unknown_16 [BL] set+1 %u != %u",
             dwg->header_vars.unknown_16, unknown_16);
     unknown_16--;
     dwg_dynapi_header_set_value (dwg, "unknown_16", &unknown_16, 0);
 
   }
   {
     BITCODE_BL unknown_17;
     if (dwg_dynapi_header_value (dwg, "unknown_17", &unknown_17, NULL)
         && unknown_17 == dwg->header_vars.unknown_17)
       pass ();
     else
       fail ("HEADER.unknown_17 [BL] %u != %u", dwg->header_vars.unknown_17, unknown_17);
     unknown_17++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_17", &unknown_17, 0)
         && unknown_17 == dwg->header_vars.unknown_17)
       pass ();
     else
       fail ("HEADER.unknown_17 [BL] set+1 %u != %u",
             dwg->header_vars.unknown_17, unknown_17);
     unknown_17--;
     dwg_dynapi_header_set_value (dwg, "unknown_17", &unknown_17, 0);
 
   }
   {
     BITCODE_TIMEBLL tdindwg;
     if (dwg_dynapi_header_value (dwg, "TDINDWG", &tdindwg, NULL)
         && !memcmp (&tdindwg, &dwg->header_vars.TDINDWG, sizeof (dwg->header_vars.TDINDWG))
        )
       pass ();
     else
       fail ("HEADER.TDINDWG [TIMEBLL]");
   }
   {
     BITCODE_TIMEBLL tdusrtimer;
     if (dwg_dynapi_header_value (dwg, "TDUSRTIMER", &tdusrtimer, NULL)
         && !memcmp (&tdusrtimer, &dwg->header_vars.TDUSRTIMER, sizeof (dwg->header_vars.TDUSRTIMER))
        )
       pass ();
     else
       fail ("HEADER.TDUSRTIMER [TIMEBLL]");
   }
   {
     BITCODE_CMC cecolor;
     if (dwg_dynapi_header_value (dwg, "CECOLOR", &cecolor, NULL)
         && !memcmp (&cecolor, &dwg->header_vars.CECOLOR, sizeof (dwg->header_vars.CECOLOR))
        )
       pass ();
     else
       fail ("HEADER.CECOLOR [CMC]");
   }
   {
     BITCODE_BS handling;
     if (dwg_dynapi_header_value (dwg, "HANDLING", &handling, NULL)
         && handling == dwg->header_vars.HANDLING)
       pass ();
     else
       fail ("HEADER.HANDLING [BS] %hu != %hu", dwg->header_vars.HANDLING, handling);
     handling++;
     if (dwg_dynapi_header_set_value (dwg, "HANDLING", &handling, 0)
         && handling == dwg->header_vars.HANDLING)
       pass ();
     else
       fail ("HEADER.HANDLING [BS] set+1 %hu != %hu",
             dwg->header_vars.HANDLING, handling);
     handling--;
     dwg_dynapi_header_set_value (dwg, "HANDLING", &handling, 0);
 
   }
   {
     BITCODE_H handseed;
     if (dwg_dynapi_header_value (dwg, "HANDSEED", &handseed, NULL)
         && !memcmp (&handseed, &dwg->header_vars.HANDSEED, sizeof (dwg->header_vars.HANDSEED))
        )
       pass ();
     else
       fail ("HEADER.HANDSEED [H]");
   }
   {
     BITCODE_RL unknown_4f2;
     if (dwg_dynapi_header_value (dwg, "unknown_4f2", &unknown_4f2, NULL)
         && unknown_4f2 == dwg->header_vars.unknown_4f2)
       pass ();
     else
       fail ("HEADER.unknown_4f2 [RL] %u != %u", dwg->header_vars.unknown_4f2, unknown_4f2);
     unknown_4f2++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_4f2", &unknown_4f2, 0)
         && unknown_4f2 == dwg->header_vars.unknown_4f2)
       pass ();
     else
       fail ("HEADER.unknown_4f2 [RL] set+1 %u != %u",
             dwg->header_vars.unknown_4f2, unknown_4f2);
     unknown_4f2--;
     dwg_dynapi_header_set_value (dwg, "unknown_4f2", &unknown_4f2, 0);
 
   }
   {
     BITCODE_RS unknown_5;
     if (dwg_dynapi_header_value (dwg, "unknown_5", &unknown_5, NULL)
         && unknown_5 == dwg->header_vars.unknown_5)
       pass ();
     else
       fail ("HEADER.unknown_5 [RS] %hu != %hu", dwg->header_vars.unknown_5, unknown_5);
     unknown_5++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_5", &unknown_5, 0)
         && unknown_5 == dwg->header_vars.unknown_5)
       pass ();
     else
       fail ("HEADER.unknown_5 [RS] set+1 %hu != %hu",
             dwg->header_vars.unknown_5, unknown_5);
     unknown_5--;
     dwg_dynapi_header_set_value (dwg, "unknown_5", &unknown_5, 0);
 
   }
   {
     BITCODE_RS unknown_6;
     if (dwg_dynapi_header_value (dwg, "unknown_6", &unknown_6, NULL)
         && unknown_6 == dwg->header_vars.unknown_6)
       pass ();
     else
       fail ("HEADER.unknown_6 [RS] %hu != %hu", dwg->header_vars.unknown_6, unknown_6);
     unknown_6++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_6", &unknown_6, 0)
         && unknown_6 == dwg->header_vars.unknown_6)
       pass ();
     else
       fail ("HEADER.unknown_6 [RS] set+1 %hu != %hu",
             dwg->header_vars.unknown_6, unknown_6);
     unknown_6--;
     dwg_dynapi_header_set_value (dwg, "unknown_6", &unknown_6, 0);
 
   }
   {
     BITCODE_RS unknown_6a;
     if (dwg_dynapi_header_value (dwg, "unknown_6a", &unknown_6a, NULL)
         && unknown_6a == dwg->header_vars.unknown_6a)
       pass ();
     else
       fail ("HEADER.unknown_6a [RS] %hu != %hu", dwg->header_vars.unknown_6a, unknown_6a);
     unknown_6a++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_6a", &unknown_6a, 0)
         && unknown_6a == dwg->header_vars.unknown_6a)
       pass ();
     else
       fail ("HEADER.unknown_6a [RS] set+1 %hu != %hu",
             dwg->header_vars.unknown_6a, unknown_6a);
     unknown_6a--;
     dwg_dynapi_header_set_value (dwg, "unknown_6a", &unknown_6a, 0);
 
   }
   {
     BITCODE_RS unknown_6b;
     if (dwg_dynapi_header_value (dwg, "unknown_6b", &unknown_6b, NULL)
         && unknown_6b == dwg->header_vars.unknown_6b)
       pass ();
     else
       fail ("HEADER.unknown_6b [RS] %hu != %hu", dwg->header_vars.unknown_6b, unknown_6b);
     unknown_6b++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_6b", &unknown_6b, 0)
         && unknown_6b == dwg->header_vars.unknown_6b)
       pass ();
     else
       fail ("HEADER.unknown_6b [RS] set+1 %hu != %hu",
             dwg->header_vars.unknown_6b, unknown_6b);
     unknown_6b--;
     dwg_dynapi_header_set_value (dwg, "unknown_6b", &unknown_6b, 0);
 
   }
   {
     BITCODE_RS unknown_6c;
     if (dwg_dynapi_header_value (dwg, "unknown_6c", &unknown_6c, NULL)
         && unknown_6c == dwg->header_vars.unknown_6c)
       pass ();
     else
       fail ("HEADER.unknown_6c [RS] %hu != %hu", dwg->header_vars.unknown_6c, unknown_6c);
     unknown_6c++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_6c", &unknown_6c, 0)
         && unknown_6c == dwg->header_vars.unknown_6c)
       pass ();
     else
       fail ("HEADER.unknown_6c [RS] set+1 %hu != %hu",
             dwg->header_vars.unknown_6c, unknown_6c);
     unknown_6c--;
     dwg_dynapi_header_set_value (dwg, "unknown_6c", &unknown_6c, 0);
 
   }
   {
     BITCODE_H clayer;
     if (dwg_dynapi_header_value (dwg, "CLAYER", &clayer, NULL)
         && !memcmp (&clayer, &dwg->header_vars.CLAYER, sizeof (dwg->header_vars.CLAYER))
        )
       pass ();
     else
       fail ("HEADER.CLAYER [H]");
   }
   {
     BITCODE_H textstyle;
     if (dwg_dynapi_header_value (dwg, "TEXTSTYLE", &textstyle, NULL)
         && !memcmp (&textstyle, &dwg->header_vars.TEXTSTYLE, sizeof (dwg->header_vars.TEXTSTYLE))
        )
       pass ();
     else
       fail ("HEADER.TEXTSTYLE [H]");
   }
   {
     BITCODE_H celtype;
     if (dwg_dynapi_header_value (dwg, "CELTYPE", &celtype, NULL)
         && !memcmp (&celtype, &dwg->header_vars.CELTYPE, sizeof (dwg->header_vars.CELTYPE))
        )
       pass ();
     else
       fail ("HEADER.CELTYPE [H]");
   }
   {
     BITCODE_H cmaterial;
     if (dwg_dynapi_header_value (dwg, "CMATERIAL", &cmaterial, NULL)
         && !memcmp (&cmaterial, &dwg->header_vars.CMATERIAL, sizeof (dwg->header_vars.CMATERIAL))
        )
       pass ();
     else
       fail ("HEADER.CMATERIAL [H]");
   }
   {
     BITCODE_H dimstyle;
     if (dwg_dynapi_header_value (dwg, "DIMSTYLE", &dimstyle, NULL)
         && !memcmp (&dimstyle, &dwg->header_vars.DIMSTYLE, sizeof (dwg->header_vars.DIMSTYLE))
        )
       pass ();
     else
       fail ("HEADER.DIMSTYLE [H]");
   }
   {
     BITCODE_H cmlstyle;
     if (dwg_dynapi_header_value (dwg, "CMLSTYLE", &cmlstyle, NULL)
         && !memcmp (&cmlstyle, &dwg->header_vars.CMLSTYLE, sizeof (dwg->header_vars.CMLSTYLE))
        )
       pass ();
     else
       fail ("HEADER.CMLSTYLE [H]");
   }
   {
     BITCODE_BD psvpscale;
     if (dwg_dynapi_header_value (dwg, "PSVPSCALE", &psvpscale, NULL)
         && psvpscale == dwg->header_vars.PSVPSCALE)
       pass ();
     else
       fail ("HEADER.PSVPSCALE [BD] %g != %g", dwg->header_vars.PSVPSCALE, psvpscale);
     psvpscale++;
     if (dwg_dynapi_header_set_value (dwg, "PSVPSCALE", &psvpscale, 0)
         && psvpscale == dwg->header_vars.PSVPSCALE)
       pass ();
     else
       fail ("HEADER.PSVPSCALE [BD] set+1 %g != %g",
             dwg->header_vars.PSVPSCALE, psvpscale);
     psvpscale--;
     dwg_dynapi_header_set_value (dwg, "PSVPSCALE", &psvpscale, 0);
 
   }
   {
     BITCODE_3BD pinsbase;
     if (dwg_dynapi_header_value (dwg, "PINSBASE", &pinsbase, NULL)
         && !memcmp (&pinsbase, &dwg->header_vars.PINSBASE, sizeof (dwg->header_vars.PINSBASE))
        )
       pass ();
     else
       fail ("HEADER.PINSBASE [3BD]");
   }
   {
     BITCODE_3BD pextmin;
     if (dwg_dynapi_header_value (dwg, "PEXTMIN", &pextmin, NULL)
         && !memcmp (&pextmin, &dwg->header_vars.PEXTMIN, sizeof (dwg->header_vars.PEXTMIN))
        )
       pass ();
     else
       fail ("HEADER.PEXTMIN [3BD]");
   }
   {
     BITCODE_3BD pextmax;
     if (dwg_dynapi_header_value (dwg, "PEXTMAX", &pextmax, NULL)
         && !memcmp (&pextmax, &dwg->header_vars.PEXTMAX, sizeof (dwg->header_vars.PEXTMAX))
        )
       pass ();
     else
       fail ("HEADER.PEXTMAX [3BD]");
   }
   {
     BITCODE_2DPOINT plimmin;
     if (dwg_dynapi_header_value (dwg, "PLIMMIN", &plimmin, NULL)
         && !memcmp (&plimmin, &dwg->header_vars.PLIMMIN, sizeof (dwg->header_vars.PLIMMIN))
        )
       pass ();
     else
       fail ("HEADER.PLIMMIN [2DPOINT]");
   }
   {
     BITCODE_2DPOINT plimmax;
     if (dwg_dynapi_header_value (dwg, "PLIMMAX", &plimmax, NULL)
         && !memcmp (&plimmax, &dwg->header_vars.PLIMMAX, sizeof (dwg->header_vars.PLIMMAX))
        )
       pass ();
     else
       fail ("HEADER.PLIMMAX [2DPOINT]");
   }
   {
     BITCODE_BD pelevation;
     if (dwg_dynapi_header_value (dwg, "PELEVATION", &pelevation, NULL)
         && pelevation == dwg->header_vars.PELEVATION)
       pass ();
     else
       fail ("HEADER.PELEVATION [BD] %g != %g", dwg->header_vars.PELEVATION, pelevation);
     pelevation++;
     if (dwg_dynapi_header_set_value (dwg, "PELEVATION", &pelevation, 0)
         && pelevation == dwg->header_vars.PELEVATION)
       pass ();
     else
       fail ("HEADER.PELEVATION [BD] set+1 %g != %g",
             dwg->header_vars.PELEVATION, pelevation);
     pelevation--;
     dwg_dynapi_header_set_value (dwg, "PELEVATION", &pelevation, 0);
 
   }
   {
     BITCODE_3BD pucsorg;
     if (dwg_dynapi_header_value (dwg, "PUCSORG", &pucsorg, NULL)
         && !memcmp (&pucsorg, &dwg->header_vars.PUCSORG, sizeof (dwg->header_vars.PUCSORG))
        )
       pass ();
     else
       fail ("HEADER.PUCSORG [3BD]");
   }
   {
     BITCODE_3BD pucsxdir;
     if (dwg_dynapi_header_value (dwg, "PUCSXDIR", &pucsxdir, NULL)
         && !memcmp (&pucsxdir, &dwg->header_vars.PUCSXDIR, sizeof (dwg->header_vars.PUCSXDIR))
        )
       pass ();
     else
       fail ("HEADER.PUCSXDIR [3BD]");
   }
   {
     BITCODE_3BD pucsydir;
     if (dwg_dynapi_header_value (dwg, "PUCSYDIR", &pucsydir, NULL)
         && !memcmp (&pucsydir, &dwg->header_vars.PUCSYDIR, sizeof (dwg->header_vars.PUCSYDIR))
        )
       pass ();
     else
       fail ("HEADER.PUCSYDIR [3BD]");
   }
   {
     BITCODE_H pucsname;
     if (dwg_dynapi_header_value (dwg, "PUCSNAME", &pucsname, NULL)
         && !memcmp (&pucsname, &dwg->header_vars.PUCSNAME, sizeof (dwg->header_vars.PUCSNAME))
        )
       pass ();
     else
       fail ("HEADER.PUCSNAME [H]");
   }
   {
     BITCODE_H pucsbase;
     if (dwg_dynapi_header_value (dwg, "PUCSBASE", &pucsbase, NULL)
         && !memcmp (&pucsbase, &dwg->header_vars.PUCSBASE, sizeof (dwg->header_vars.PUCSBASE))
        )
       pass ();
     else
       fail ("HEADER.PUCSBASE [H]");
   }
   {
     BITCODE_H pucsorthoref;
     if (dwg_dynapi_header_value (dwg, "PUCSORTHOREF", &pucsorthoref, NULL)
         && !memcmp (&pucsorthoref, &dwg->header_vars.PUCSORTHOREF, sizeof (dwg->header_vars.PUCSORTHOREF))
        )
       pass ();
     else
       fail ("HEADER.PUCSORTHOREF [H]");
   }
   {
     BITCODE_BS pucsorthoview;
     if (dwg_dynapi_header_value (dwg, "PUCSORTHOVIEW", &pucsorthoview, NULL)
         && pucsorthoview == dwg->header_vars.PUCSORTHOVIEW)
       pass ();
     else
       fail ("HEADER.PUCSORTHOVIEW [BS] %hu != %hu", dwg->header_vars.PUCSORTHOVIEW, pucsorthoview);
     pucsorthoview++;
     if (dwg_dynapi_header_set_value (dwg, "PUCSORTHOVIEW", &pucsorthoview, 0)
         && pucsorthoview == dwg->header_vars.PUCSORTHOVIEW)
       pass ();
     else
       fail ("HEADER.PUCSORTHOVIEW [BS] set+1 %hu != %hu",
             dwg->header_vars.PUCSORTHOVIEW, pucsorthoview);
     pucsorthoview--;
     dwg_dynapi_header_set_value (dwg, "PUCSORTHOVIEW", &pucsorthoview, 0);
 
   }
   {
     BITCODE_3BD pucsorgtop;
     if (dwg_dynapi_header_value (dwg, "PUCSORGTOP", &pucsorgtop, NULL)
         && !memcmp (&pucsorgtop, &dwg->header_vars.PUCSORGTOP, sizeof (dwg->header_vars.PUCSORGTOP))
        )
       pass ();
     else
       fail ("HEADER.PUCSORGTOP [3BD]");
   }
   {
     BITCODE_3BD pucsorgbottom;
     if (dwg_dynapi_header_value (dwg, "PUCSORGBOTTOM", &pucsorgbottom, NULL)
         && !memcmp (&pucsorgbottom, &dwg->header_vars.PUCSORGBOTTOM, sizeof (dwg->header_vars.PUCSORGBOTTOM))
        )
       pass ();
     else
       fail ("HEADER.PUCSORGBOTTOM [3BD]");
   }
   {
     BITCODE_3BD pucsorgleft;
     if (dwg_dynapi_header_value (dwg, "PUCSORGLEFT", &pucsorgleft, NULL)
         && !memcmp (&pucsorgleft, &dwg->header_vars.PUCSORGLEFT, sizeof (dwg->header_vars.PUCSORGLEFT))
        )
       pass ();
     else
       fail ("HEADER.PUCSORGLEFT [3BD]");
   }
   {
     BITCODE_3BD pucsorgright;
     if (dwg_dynapi_header_value (dwg, "PUCSORGRIGHT", &pucsorgright, NULL)
         && !memcmp (&pucsorgright, &dwg->header_vars.PUCSORGRIGHT, sizeof (dwg->header_vars.PUCSORGRIGHT))
        )
       pass ();
     else
       fail ("HEADER.PUCSORGRIGHT [3BD]");
   }
   {
     BITCODE_3BD pucsorgfront;
     if (dwg_dynapi_header_value (dwg, "PUCSORGFRONT", &pucsorgfront, NULL)
         && !memcmp (&pucsorgfront, &dwg->header_vars.PUCSORGFRONT, sizeof (dwg->header_vars.PUCSORGFRONT))
        )
       pass ();
     else
       fail ("HEADER.PUCSORGFRONT [3BD]");
   }
   {
     BITCODE_3BD pucsorgback;
     if (dwg_dynapi_header_value (dwg, "PUCSORGBACK", &pucsorgback, NULL)
         && !memcmp (&pucsorgback, &dwg->header_vars.PUCSORGBACK, sizeof (dwg->header_vars.PUCSORGBACK))
        )
       pass ();
     else
       fail ("HEADER.PUCSORGBACK [3BD]");
   }
   {
     BITCODE_3BD insbase;
     if (dwg_dynapi_header_value (dwg, "INSBASE", &insbase, NULL)
         && !memcmp (&insbase, &dwg->header_vars.INSBASE, sizeof (dwg->header_vars.INSBASE))
        )
       pass ();
     else
       fail ("HEADER.INSBASE [3BD]");
   }
   {
     BITCODE_3BD extmin;
     if (dwg_dynapi_header_value (dwg, "EXTMIN", &extmin, NULL)
         && !memcmp (&extmin, &dwg->header_vars.EXTMIN, sizeof (dwg->header_vars.EXTMIN))
        )
       pass ();
     else
       fail ("HEADER.EXTMIN [3BD]");
   }
   {
     BITCODE_3BD extmax;
     if (dwg_dynapi_header_value (dwg, "EXTMAX", &extmax, NULL)
         && !memcmp (&extmax, &dwg->header_vars.EXTMAX, sizeof (dwg->header_vars.EXTMAX))
        )
       pass ();
     else
       fail ("HEADER.EXTMAX [3BD]");
   }
   {
     BITCODE_3BD viewdir;
     if (dwg_dynapi_header_value (dwg, "VIEWDIR", &viewdir, NULL)
         && !memcmp (&viewdir, &dwg->header_vars.VIEWDIR, sizeof (dwg->header_vars.VIEWDIR))
        )
       pass ();
     else
       fail ("HEADER.VIEWDIR [3BD]");
   }
   {
     BITCODE_3BD target;
     if (dwg_dynapi_header_value (dwg, "TARGET", &target, NULL)
         && !memcmp (&target, &dwg->header_vars.TARGET, sizeof (dwg->header_vars.TARGET))
        )
       pass ();
     else
       fail ("HEADER.TARGET [3BD]");
   }
   {
     BITCODE_2DPOINT limmin;
     if (dwg_dynapi_header_value (dwg, "LIMMIN", &limmin, NULL)
         && !memcmp (&limmin, &dwg->header_vars.LIMMIN, sizeof (dwg->header_vars.LIMMIN))
        )
       pass ();
     else
       fail ("HEADER.LIMMIN [2DPOINT]");
   }
   {
     BITCODE_2DPOINT limmax;
     if (dwg_dynapi_header_value (dwg, "LIMMAX", &limmax, NULL)
         && !memcmp (&limmax, &dwg->header_vars.LIMMAX, sizeof (dwg->header_vars.LIMMAX))
        )
       pass ();
     else
       fail ("HEADER.LIMMAX [2DPOINT]");
   }
   {
     BITCODE_3RD viewctr;
     if (dwg_dynapi_header_value (dwg, "VIEWCTR", &viewctr, NULL)
         && !memcmp (&viewctr, &dwg->header_vars.VIEWCTR, sizeof (dwg->header_vars.VIEWCTR))
        )
       pass ();
     else
       fail ("HEADER.VIEWCTR [3RD]");
   }
   {
     BITCODE_BD elevation;
     if (dwg_dynapi_header_value (dwg, "ELEVATION", &elevation, NULL)
         && elevation == dwg->header_vars.ELEVATION)
       pass ();
     else
       fail ("HEADER.ELEVATION [BD] %g != %g", dwg->header_vars.ELEVATION, elevation);
     elevation++;
     if (dwg_dynapi_header_set_value (dwg, "ELEVATION", &elevation, 0)
         && elevation == dwg->header_vars.ELEVATION)
       pass ();
     else
       fail ("HEADER.ELEVATION [BD] set+1 %g != %g",
             dwg->header_vars.ELEVATION, elevation);
     elevation--;
     dwg_dynapi_header_set_value (dwg, "ELEVATION", &elevation, 0);
 
   }
   {
     BITCODE_RD viewsize;
     if (dwg_dynapi_header_value (dwg, "VIEWSIZE", &viewsize, NULL)
         && viewsize == dwg->header_vars.VIEWSIZE)
       pass ();
     else
       fail ("HEADER.VIEWSIZE [RD] %g != %g", dwg->header_vars.VIEWSIZE, viewsize);
     viewsize++;
     if (dwg_dynapi_header_set_value (dwg, "VIEWSIZE", &viewsize, 0)
         && viewsize == dwg->header_vars.VIEWSIZE)
       pass ();
     else
       fail ("HEADER.VIEWSIZE [RD] set+1 %g != %g",
             dwg->header_vars.VIEWSIZE, viewsize);
     viewsize--;
     dwg_dynapi_header_set_value (dwg, "VIEWSIZE", &viewsize, 0);
 
   }
   {
     BITCODE_RS snapmode;
     if (dwg_dynapi_header_value (dwg, "SNAPMODE", &snapmode, NULL)
         && snapmode == dwg->header_vars.SNAPMODE)
       pass ();
     else
       fail ("HEADER.SNAPMODE [RS] %hu != %hu", dwg->header_vars.SNAPMODE, snapmode);
     snapmode++;
     if (dwg_dynapi_header_set_value (dwg, "SNAPMODE", &snapmode, 0)
         && snapmode == dwg->header_vars.SNAPMODE)
       pass ();
     else
       fail ("HEADER.SNAPMODE [RS] set+1 %hu != %hu",
             dwg->header_vars.SNAPMODE, snapmode);
     snapmode--;
     dwg_dynapi_header_set_value (dwg, "SNAPMODE", &snapmode, 0);
 
   }
   {
     BITCODE_2RD snapunit;
     if (dwg_dynapi_header_value (dwg, "SNAPUNIT", &snapunit, NULL)
         && !memcmp (&snapunit, &dwg->header_vars.SNAPUNIT, sizeof (dwg->header_vars.SNAPUNIT))
        )
       pass ();
     else
       fail ("HEADER.SNAPUNIT [2RD]");
   }
   {
     BITCODE_2RD snapbase;
     if (dwg_dynapi_header_value (dwg, "SNAPBASE", &snapbase, NULL)
         && !memcmp (&snapbase, &dwg->header_vars.SNAPBASE, sizeof (dwg->header_vars.SNAPBASE))
        )
       pass ();
     else
       fail ("HEADER.SNAPBASE [2RD]");
   }
   {
     BITCODE_RD snapang;
     if (dwg_dynapi_header_value (dwg, "SNAPANG", &snapang, NULL)
         && snapang == dwg->header_vars.SNAPANG)
       pass ();
     else
       fail ("HEADER.SNAPANG [RD] %g != %g", dwg->header_vars.SNAPANG, snapang);
     snapang++;
     if (dwg_dynapi_header_set_value (dwg, "SNAPANG", &snapang, 0)
         && snapang == dwg->header_vars.SNAPANG)
       pass ();
     else
       fail ("HEADER.SNAPANG [RD] set+1 %g != %g",
             dwg->header_vars.SNAPANG, snapang);
     snapang--;
     dwg_dynapi_header_set_value (dwg, "SNAPANG", &snapang, 0);
 
   }
   {
     BITCODE_RS snapstyle;
     if (dwg_dynapi_header_value (dwg, "SNAPSTYLE", &snapstyle, NULL)
         && snapstyle == dwg->header_vars.SNAPSTYLE)
       pass ();
     else
       fail ("HEADER.SNAPSTYLE [RS] %hu != %hu", dwg->header_vars.SNAPSTYLE, snapstyle);
     snapstyle++;
     if (dwg_dynapi_header_set_value (dwg, "SNAPSTYLE", &snapstyle, 0)
         && snapstyle == dwg->header_vars.SNAPSTYLE)
       pass ();
     else
       fail ("HEADER.SNAPSTYLE [RS] set+1 %hu != %hu",
             dwg->header_vars.SNAPSTYLE, snapstyle);
     snapstyle--;
     dwg_dynapi_header_set_value (dwg, "SNAPSTYLE", &snapstyle, 0);
 
   }
   {
     BITCODE_RS snapisopair;
     if (dwg_dynapi_header_value (dwg, "SNAPISOPAIR", &snapisopair, NULL)
         && snapisopair == dwg->header_vars.SNAPISOPAIR)
       pass ();
     else
       fail ("HEADER.SNAPISOPAIR [RS] %hu != %hu", dwg->header_vars.SNAPISOPAIR, snapisopair);
     snapisopair++;
     if (dwg_dynapi_header_set_value (dwg, "SNAPISOPAIR", &snapisopair, 0)
         && snapisopair == dwg->header_vars.SNAPISOPAIR)
       pass ();
     else
       fail ("HEADER.SNAPISOPAIR [RS] set+1 %hu != %hu",
             dwg->header_vars.SNAPISOPAIR, snapisopair);
     snapisopair--;
     dwg_dynapi_header_set_value (dwg, "SNAPISOPAIR", &snapisopair, 0);
 
   }
   {
     BITCODE_RS gridmode;
     if (dwg_dynapi_header_value (dwg, "GRIDMODE", &gridmode, NULL)
         && gridmode == dwg->header_vars.GRIDMODE)
       pass ();
     else
       fail ("HEADER.GRIDMODE [RS] %hu != %hu", dwg->header_vars.GRIDMODE, gridmode);
     gridmode++;
     if (dwg_dynapi_header_set_value (dwg, "GRIDMODE", &gridmode, 0)
         && gridmode == dwg->header_vars.GRIDMODE)
       pass ();
     else
       fail ("HEADER.GRIDMODE [RS] set+1 %hu != %hu",
             dwg->header_vars.GRIDMODE, gridmode);
     gridmode--;
     dwg_dynapi_header_set_value (dwg, "GRIDMODE", &gridmode, 0);
 
   }
   {
     BITCODE_2RD gridunit;
     if (dwg_dynapi_header_value (dwg, "GRIDUNIT", &gridunit, NULL)
         && !memcmp (&gridunit, &dwg->header_vars.GRIDUNIT, sizeof (dwg->header_vars.GRIDUNIT))
        )
       pass ();
     else
       fail ("HEADER.GRIDUNIT [2RD]");
   }
   {
     BITCODE_BS axismode;
     if (dwg_dynapi_header_value (dwg, "AXISMODE", &axismode, NULL)
         && axismode == dwg->header_vars.AXISMODE)
       pass ();
     else
       fail ("HEADER.AXISMODE [BS] %hu != %hu", dwg->header_vars.AXISMODE, axismode);
     axismode++;
     if (dwg_dynapi_header_set_value (dwg, "AXISMODE", &axismode, 0)
         && axismode == dwg->header_vars.AXISMODE)
       pass ();
     else
       fail ("HEADER.AXISMODE [BS] set+1 %hu != %hu",
             dwg->header_vars.AXISMODE, axismode);
     axismode--;
     dwg_dynapi_header_set_value (dwg, "AXISMODE", &axismode, 0);
 
   }
   {
     BITCODE_2RD axisunit;
     if (dwg_dynapi_header_value (dwg, "AXISUNIT", &axisunit, NULL)
         && !memcmp (&axisunit, &dwg->header_vars.AXISUNIT, sizeof (dwg->header_vars.AXISUNIT))
        )
       pass ();
     else
       fail ("HEADER.AXISUNIT [2RD]");
   }
   {
     BITCODE_3RD vpointx;
     if (dwg_dynapi_header_value (dwg, "VPOINTX", &vpointx, NULL)
         && !memcmp (&vpointx, &dwg->header_vars.VPOINTX, sizeof (dwg->header_vars.VPOINTX))
        )
       pass ();
     else
       fail ("HEADER.VPOINTX [3RD]");
   }
   {
     BITCODE_3RD vpointy;
     if (dwg_dynapi_header_value (dwg, "VPOINTY", &vpointy, NULL)
         && !memcmp (&vpointy, &dwg->header_vars.VPOINTY, sizeof (dwg->header_vars.VPOINTY))
        )
       pass ();
     else
       fail ("HEADER.VPOINTY [3RD]");
   }
   {
     BITCODE_3RD vpointz;
     if (dwg_dynapi_header_value (dwg, "VPOINTZ", &vpointz, NULL)
         && !memcmp (&vpointz, &dwg->header_vars.VPOINTZ, sizeof (dwg->header_vars.VPOINTZ))
        )
       pass ();
     else
       fail ("HEADER.VPOINTZ [3RD]");
   }
   {
     BITCODE_3RD vpointxalt;
     if (dwg_dynapi_header_value (dwg, "VPOINTXALT", &vpointxalt, NULL)
         && !memcmp (&vpointxalt, &dwg->header_vars.VPOINTXALT, sizeof (dwg->header_vars.VPOINTXALT))
        )
       pass ();
     else
       fail ("HEADER.VPOINTXALT [3RD]");
   }
   {
     BITCODE_3RD vpointyalt;
     if (dwg_dynapi_header_value (dwg, "VPOINTYALT", &vpointyalt, NULL)
         && !memcmp (&vpointyalt, &dwg->header_vars.VPOINTYALT, sizeof (dwg->header_vars.VPOINTYALT))
        )
       pass ();
     else
       fail ("HEADER.VPOINTYALT [3RD]");
   }
   {
     BITCODE_3RD vpointzalt;
     if (dwg_dynapi_header_value (dwg, "VPOINTZALT", &vpointzalt, NULL)
         && !memcmp (&vpointzalt, &dwg->header_vars.VPOINTZALT, sizeof (dwg->header_vars.VPOINTZALT))
        )
       pass ();
     else
       fail ("HEADER.VPOINTZALT [3RD]");
   }
   {
     BITCODE_RS flag_3d;
     if (dwg_dynapi_header_value (dwg, "flag_3d", &flag_3d, NULL)
         && flag_3d == dwg->header_vars.flag_3d)
       pass ();
     else
       fail ("HEADER.flag_3d [RS] %hu != %hu", dwg->header_vars.flag_3d, flag_3d);
     flag_3d++;
     if (dwg_dynapi_header_set_value (dwg, "flag_3d", &flag_3d, 0)
         && flag_3d == dwg->header_vars.flag_3d)
       pass ();
     else
       fail ("HEADER.flag_3d [RS] set+1 %hu != %hu",
             dwg->header_vars.flag_3d, flag_3d);
     flag_3d--;
     dwg_dynapi_header_set_value (dwg, "flag_3d", &flag_3d, 0);
 
   }
   {
     BITCODE_3BD ucsorg;
     if (dwg_dynapi_header_value (dwg, "UCSORG", &ucsorg, NULL)
         && !memcmp (&ucsorg, &dwg->header_vars.UCSORG, sizeof (dwg->header_vars.UCSORG))
        )
       pass ();
     else
       fail ("HEADER.UCSORG [3BD]");
   }
   {
     BITCODE_3BD ucsxdir;
     if (dwg_dynapi_header_value (dwg, "UCSXDIR", &ucsxdir, NULL)
         && !memcmp (&ucsxdir, &dwg->header_vars.UCSXDIR, sizeof (dwg->header_vars.UCSXDIR))
        )
       pass ();
     else
       fail ("HEADER.UCSXDIR [3BD]");
   }
   {
     BITCODE_3BD ucsydir;
     if (dwg_dynapi_header_value (dwg, "UCSYDIR", &ucsydir, NULL)
         && !memcmp (&ucsydir, &dwg->header_vars.UCSYDIR, sizeof (dwg->header_vars.UCSYDIR))
        )
       pass ();
     else
       fail ("HEADER.UCSYDIR [3BD]");
   }
   {
     BITCODE_H ucsname;
     if (dwg_dynapi_header_value (dwg, "UCSNAME", &ucsname, NULL)
         && !memcmp (&ucsname, &dwg->header_vars.UCSNAME, sizeof (dwg->header_vars.UCSNAME))
        )
       pass ();
     else
       fail ("HEADER.UCSNAME [H]");
   }
   {
     BITCODE_H ucsbase;
     if (dwg_dynapi_header_value (dwg, "UCSBASE", &ucsbase, NULL)
         && !memcmp (&ucsbase, &dwg->header_vars.UCSBASE, sizeof (dwg->header_vars.UCSBASE))
        )
       pass ();
     else
       fail ("HEADER.UCSBASE [H]");
   }
   {
     BITCODE_BS ucsorthoview;
     if (dwg_dynapi_header_value (dwg, "UCSORTHOVIEW", &ucsorthoview, NULL)
         && ucsorthoview == dwg->header_vars.UCSORTHOVIEW)
       pass ();
     else
       fail ("HEADER.UCSORTHOVIEW [BS] %hu != %hu", dwg->header_vars.UCSORTHOVIEW, ucsorthoview);
     ucsorthoview++;
     if (dwg_dynapi_header_set_value (dwg, "UCSORTHOVIEW", &ucsorthoview, 0)
         && ucsorthoview == dwg->header_vars.UCSORTHOVIEW)
       pass ();
     else
       fail ("HEADER.UCSORTHOVIEW [BS] set+1 %hu != %hu",
             dwg->header_vars.UCSORTHOVIEW, ucsorthoview);
     ucsorthoview--;
     dwg_dynapi_header_set_value (dwg, "UCSORTHOVIEW", &ucsorthoview, 0);
 
   }
   {
     BITCODE_H ucsorthoref;
     if (dwg_dynapi_header_value (dwg, "UCSORTHOREF", &ucsorthoref, NULL)
         && !memcmp (&ucsorthoref, &dwg->header_vars.UCSORTHOREF, sizeof (dwg->header_vars.UCSORTHOREF))
        )
       pass ();
     else
       fail ("HEADER.UCSORTHOREF [H]");
   }
   {
     BITCODE_3BD ucsorgtop;
     if (dwg_dynapi_header_value (dwg, "UCSORGTOP", &ucsorgtop, NULL)
         && !memcmp (&ucsorgtop, &dwg->header_vars.UCSORGTOP, sizeof (dwg->header_vars.UCSORGTOP))
        )
       pass ();
     else
       fail ("HEADER.UCSORGTOP [3BD]");
   }
   {
     BITCODE_3BD ucsorgbottom;
     if (dwg_dynapi_header_value (dwg, "UCSORGBOTTOM", &ucsorgbottom, NULL)
         && !memcmp (&ucsorgbottom, &dwg->header_vars.UCSORGBOTTOM, sizeof (dwg->header_vars.UCSORGBOTTOM))
        )
       pass ();
     else
       fail ("HEADER.UCSORGBOTTOM [3BD]");
   }
   {
     BITCODE_3BD ucsorgleft;
     if (dwg_dynapi_header_value (dwg, "UCSORGLEFT", &ucsorgleft, NULL)
         && !memcmp (&ucsorgleft, &dwg->header_vars.UCSORGLEFT, sizeof (dwg->header_vars.UCSORGLEFT))
        )
       pass ();
     else
       fail ("HEADER.UCSORGLEFT [3BD]");
   }
   {
     BITCODE_3BD ucsorgright;
     if (dwg_dynapi_header_value (dwg, "UCSORGRIGHT", &ucsorgright, NULL)
         && !memcmp (&ucsorgright, &dwg->header_vars.UCSORGRIGHT, sizeof (dwg->header_vars.UCSORGRIGHT))
        )
       pass ();
     else
       fail ("HEADER.UCSORGRIGHT [3BD]");
   }
   {
     BITCODE_3BD ucsorgfront;
     if (dwg_dynapi_header_value (dwg, "UCSORGFRONT", &ucsorgfront, NULL)
         && !memcmp (&ucsorgfront, &dwg->header_vars.UCSORGFRONT, sizeof (dwg->header_vars.UCSORGFRONT))
        )
       pass ();
     else
       fail ("HEADER.UCSORGFRONT [3BD]");
   }
   {
     BITCODE_3BD ucsorgback;
     if (dwg_dynapi_header_value (dwg, "UCSORGBACK", &ucsorgback, NULL)
         && !memcmp (&ucsorgback, &dwg->header_vars.UCSORGBACK, sizeof (dwg->header_vars.UCSORGBACK))
        )
       pass ();
     else
       fail ("HEADER.UCSORGBACK [3BD]");
   }
   {
     BITCODE_TV dimpost;
     if (dwg_dynapi_header_value (dwg, "DIMPOST", &dimpost, NULL)
         && !memcmp (&dimpost, &dwg->header_vars.DIMPOST, sizeof (dwg->header_vars.DIMPOST))
        )
       pass ();
     else
       fail ("HEADER.DIMPOST [TV]");
   }
   {
     BITCODE_TV dimapost;
     if (dwg_dynapi_header_value (dwg, "DIMAPOST", &dimapost, NULL)
         && !memcmp (&dimapost, &dwg->header_vars.DIMAPOST, sizeof (dwg->header_vars.DIMAPOST))
        )
       pass ();
     else
       fail ("HEADER.DIMAPOST [TV]");
   }
   {
     BITCODE_B dimtol;
     if (dwg_dynapi_header_value (dwg, "DIMTOL", &dimtol, NULL)
         && dimtol == dwg->header_vars.DIMTOL)
       pass ();
     else
       fail ("HEADER.DIMTOL [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMTOL, dimtol);
     dimtol++;
     if (dwg_dynapi_header_set_value (dwg, "DIMTOL", &dimtol, 0)
         && dimtol == dwg->header_vars.DIMTOL)
       pass ();
     else
       fail ("HEADER.DIMTOL [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.DIMTOL, dimtol);
     dimtol--;
     dwg_dynapi_header_set_value (dwg, "DIMTOL", &dimtol, 0);
 
   }
   {
     BITCODE_B dimlim;
     if (dwg_dynapi_header_value (dwg, "DIMLIM", &dimlim, NULL)
         && dimlim == dwg->header_vars.DIMLIM)
       pass ();
     else
       fail ("HEADER.DIMLIM [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMLIM, dimlim);
     dimlim++;
     if (dwg_dynapi_header_set_value (dwg, "DIMLIM", &dimlim, 0)
         && dimlim == dwg->header_vars.DIMLIM)
       pass ();
     else
       fail ("HEADER.DIMLIM [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.DIMLIM, dimlim);
     dimlim--;
     dwg_dynapi_header_set_value (dwg, "DIMLIM", &dimlim, 0);
 
   }
   {
     BITCODE_B dimtih;
     if (dwg_dynapi_header_value (dwg, "DIMTIH", &dimtih, NULL)
         && dimtih == dwg->header_vars.DIMTIH)
       pass ();
     else
       fail ("HEADER.DIMTIH [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMTIH, dimtih);
     dimtih++;
     if (dwg_dynapi_header_set_value (dwg, "DIMTIH", &dimtih, 0)
         && dimtih == dwg->header_vars.DIMTIH)
       pass ();
     else
       fail ("HEADER.DIMTIH [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.DIMTIH, dimtih);
     dimtih--;
     dwg_dynapi_header_set_value (dwg, "DIMTIH", &dimtih, 0);
 
   }
   {
     BITCODE_B dimtoh;
     if (dwg_dynapi_header_value (dwg, "DIMTOH", &dimtoh, NULL)
         && dimtoh == dwg->header_vars.DIMTOH)
       pass ();
     else
       fail ("HEADER.DIMTOH [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMTOH, dimtoh);
     dimtoh++;
     if (dwg_dynapi_header_set_value (dwg, "DIMTOH", &dimtoh, 0)
         && dimtoh == dwg->header_vars.DIMTOH)
       pass ();
     else
       fail ("HEADER.DIMTOH [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.DIMTOH, dimtoh);
     dimtoh--;
     dwg_dynapi_header_set_value (dwg, "DIMTOH", &dimtoh, 0);
 
   }
   {
     BITCODE_B dimse1;
     if (dwg_dynapi_header_value (dwg, "DIMSE1", &dimse1, NULL)
         && dimse1 == dwg->header_vars.DIMSE1)
       pass ();
     else
       fail ("HEADER.DIMSE1 [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSE1, dimse1);
     dimse1++;
     if (dwg_dynapi_header_set_value (dwg, "DIMSE1", &dimse1, 0)
         && dimse1 == dwg->header_vars.DIMSE1)
       pass ();
     else
       fail ("HEADER.DIMSE1 [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.DIMSE1, dimse1);
     dimse1--;
     dwg_dynapi_header_set_value (dwg, "DIMSE1", &dimse1, 0);
 
   }
   {
     BITCODE_B dimse2;
     if (dwg_dynapi_header_value (dwg, "DIMSE2", &dimse2, NULL)
         && dimse2 == dwg->header_vars.DIMSE2)
       pass ();
     else
       fail ("HEADER.DIMSE2 [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSE2, dimse2);
     dimse2++;
     if (dwg_dynapi_header_set_value (dwg, "DIMSE2", &dimse2, 0)
         && dimse2 == dwg->header_vars.DIMSE2)
       pass ();
     else
       fail ("HEADER.DIMSE2 [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.DIMSE2, dimse2);
     dimse2--;
     dwg_dynapi_header_set_value (dwg, "DIMSE2", &dimse2, 0);
 
   }
   {
     BITCODE_B dimalt;
     if (dwg_dynapi_header_value (dwg, "DIMALT", &dimalt, NULL)
         && dimalt == dwg->header_vars.DIMALT)
       pass ();
     else
       fail ("HEADER.DIMALT [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMALT, dimalt);
     dimalt++;
     if (dwg_dynapi_header_set_value (dwg, "DIMALT", &dimalt, 0)
         && dimalt == dwg->header_vars.DIMALT)
       pass ();
     else
       fail ("HEADER.DIMALT [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.DIMALT, dimalt);
     dimalt--;
     dwg_dynapi_header_set_value (dwg, "DIMALT", &dimalt, 0);
 
   }
   {
     BITCODE_B dimtofl;
     if (dwg_dynapi_header_value (dwg, "DIMTOFL", &dimtofl, NULL)
         && dimtofl == dwg->header_vars.DIMTOFL)
       pass ();
     else
       fail ("HEADER.DIMTOFL [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMTOFL, dimtofl);
     dimtofl++;
     if (dwg_dynapi_header_set_value (dwg, "DIMTOFL", &dimtofl, 0)
         && dimtofl == dwg->header_vars.DIMTOFL)
       pass ();
     else
       fail ("HEADER.DIMTOFL [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.DIMTOFL, dimtofl);
     dimtofl--;
     dwg_dynapi_header_set_value (dwg, "DIMTOFL", &dimtofl, 0);
 
   }
   {
     BITCODE_B dimsah;
     if (dwg_dynapi_header_value (dwg, "DIMSAH", &dimsah, NULL)
         && dimsah == dwg->header_vars.DIMSAH)
       pass ();
     else
       fail ("HEADER.DIMSAH [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSAH, dimsah);
     dimsah++;
     if (dwg_dynapi_header_set_value (dwg, "DIMSAH", &dimsah, 0)
         && dimsah == dwg->header_vars.DIMSAH)
       pass ();
     else
       fail ("HEADER.DIMSAH [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.DIMSAH, dimsah);
     dimsah--;
     dwg_dynapi_header_set_value (dwg, "DIMSAH", &dimsah, 0);
 
   }
   {
     BITCODE_B dimtix;
     if (dwg_dynapi_header_value (dwg, "DIMTIX", &dimtix, NULL)
         && dimtix == dwg->header_vars.DIMTIX)
       pass ();
     else
       fail ("HEADER.DIMTIX [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMTIX, dimtix);
     dimtix++;
     if (dwg_dynapi_header_set_value (dwg, "DIMTIX", &dimtix, 0)
         && dimtix == dwg->header_vars.DIMTIX)
       pass ();
     else
       fail ("HEADER.DIMTIX [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.DIMTIX, dimtix);
     dimtix--;
     dwg_dynapi_header_set_value (dwg, "DIMTIX", &dimtix, 0);
 
   }
   {
     BITCODE_B dimsoxd;
     if (dwg_dynapi_header_value (dwg, "DIMSOXD", &dimsoxd, NULL)
         && dimsoxd == dwg->header_vars.DIMSOXD)
       pass ();
     else
       fail ("HEADER.DIMSOXD [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSOXD, dimsoxd);
     dimsoxd++;
     if (dwg_dynapi_header_set_value (dwg, "DIMSOXD", &dimsoxd, 0)
         && dimsoxd == dwg->header_vars.DIMSOXD)
       pass ();
     else
       fail ("HEADER.DIMSOXD [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.DIMSOXD, dimsoxd);
     dimsoxd--;
     dwg_dynapi_header_set_value (dwg, "DIMSOXD", &dimsoxd, 0);
 
   }
   {
     BITCODE_BS dimaltd;
     if (dwg_dynapi_header_value (dwg, "DIMALTD", &dimaltd, NULL)
         && dimaltd == dwg->header_vars.DIMALTD)
       pass ();
     else
       fail ("HEADER.DIMALTD [BS] %hu != %hu", dwg->header_vars.DIMALTD, dimaltd);
     dimaltd++;
     if (dwg_dynapi_header_set_value (dwg, "DIMALTD", &dimaltd, 0)
         && dimaltd == dwg->header_vars.DIMALTD)
       pass ();
     else
       fail ("HEADER.DIMALTD [BS] set+1 %hu != %hu",
             dwg->header_vars.DIMALTD, dimaltd);
     dimaltd--;
     dwg_dynapi_header_set_value (dwg, "DIMALTD", &dimaltd, 0);
 
   }
   {
     BITCODE_BS dimzin;
     if (dwg_dynapi_header_value (dwg, "DIMZIN", &dimzin, NULL)
         && dimzin == dwg->header_vars.DIMZIN)
       pass ();
     else
       fail ("HEADER.DIMZIN [BS] %hu != %hu", dwg->header_vars.DIMZIN, dimzin);
     dimzin++;
     if (dwg_dynapi_header_set_value (dwg, "DIMZIN", &dimzin, 0)
         && dimzin == dwg->header_vars.DIMZIN)
       pass ();
     else
       fail ("HEADER.DIMZIN [BS] set+1 %hu != %hu",
             dwg->header_vars.DIMZIN, dimzin);
     dimzin--;
     dwg_dynapi_header_set_value (dwg, "DIMZIN", &dimzin, 0);
 
   }
   {
     BITCODE_B dimsd1;
     if (dwg_dynapi_header_value (dwg, "DIMSD1", &dimsd1, NULL)
         && dimsd1 == dwg->header_vars.DIMSD1)
       pass ();
     else
       fail ("HEADER.DIMSD1 [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSD1, dimsd1);
     dimsd1++;
     if (dwg_dynapi_header_set_value (dwg, "DIMSD1", &dimsd1, 0)
         && dimsd1 == dwg->header_vars.DIMSD1)
       pass ();
     else
       fail ("HEADER.DIMSD1 [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.DIMSD1, dimsd1);
     dimsd1--;
     dwg_dynapi_header_set_value (dwg, "DIMSD1", &dimsd1, 0);
 
   }
   {
     BITCODE_B dimsd2;
     if (dwg_dynapi_header_value (dwg, "DIMSD2", &dimsd2, NULL)
         && dimsd2 == dwg->header_vars.DIMSD2)
       pass ();
     else
       fail ("HEADER.DIMSD2 [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMSD2, dimsd2);
     dimsd2++;
     if (dwg_dynapi_header_set_value (dwg, "DIMSD2", &dimsd2, 0)
         && dimsd2 == dwg->header_vars.DIMSD2)
       pass ();
     else
       fail ("HEADER.DIMSD2 [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.DIMSD2, dimsd2);
     dimsd2--;
     dwg_dynapi_header_set_value (dwg, "DIMSD2", &dimsd2, 0);
 
   }
   {
     BITCODE_BS dimtolj;
     if (dwg_dynapi_header_value (dwg, "DIMTOLJ", &dimtolj, NULL)
         && dimtolj == dwg->header_vars.DIMTOLJ)
       pass ();
     else
       fail ("HEADER.DIMTOLJ [BS] %hu != %hu", dwg->header_vars.DIMTOLJ, dimtolj);
     dimtolj++;
     if (dwg_dynapi_header_set_value (dwg, "DIMTOLJ", &dimtolj, 0)
         && dimtolj == dwg->header_vars.DIMTOLJ)
       pass ();
     else
       fail ("HEADER.DIMTOLJ [BS] set+1 %hu != %hu",
             dwg->header_vars.DIMTOLJ, dimtolj);
     dimtolj--;
     dwg_dynapi_header_set_value (dwg, "DIMTOLJ", &dimtolj, 0);
 
   }
   {
     BITCODE_BS dimjust;
     if (dwg_dynapi_header_value (dwg, "DIMJUST", &dimjust, NULL)
         && dimjust == dwg->header_vars.DIMJUST)
       pass ();
     else
       fail ("HEADER.DIMJUST [BS] %hu != %hu", dwg->header_vars.DIMJUST, dimjust);
     dimjust++;
     if (dwg_dynapi_header_set_value (dwg, "DIMJUST", &dimjust, 0)
         && dimjust == dwg->header_vars.DIMJUST)
       pass ();
     else
       fail ("HEADER.DIMJUST [BS] set+1 %hu != %hu",
             dwg->header_vars.DIMJUST, dimjust);
     dimjust--;
     dwg_dynapi_header_set_value (dwg, "DIMJUST", &dimjust, 0);
 
   }
   {
     BITCODE_BS dimfit;
     if (dwg_dynapi_header_value (dwg, "DIMFIT", &dimfit, NULL)
         && dimfit == dwg->header_vars.DIMFIT)
       pass ();
     else
       fail ("HEADER.DIMFIT [BS] %hu != %hu", dwg->header_vars.DIMFIT, dimfit);
     dimfit++;
     if (dwg_dynapi_header_set_value (dwg, "DIMFIT", &dimfit, 0)
         && dimfit == dwg->header_vars.DIMFIT)
       pass ();
     else
       fail ("HEADER.DIMFIT [BS] set+1 %hu != %hu",
             dwg->header_vars.DIMFIT, dimfit);
     dimfit--;
     dwg_dynapi_header_set_value (dwg, "DIMFIT", &dimfit, 0);
 
   }
   {
     BITCODE_B dimupt;
     if (dwg_dynapi_header_value (dwg, "DIMUPT", &dimupt, NULL)
         && dimupt == dwg->header_vars.DIMUPT)
       pass ();
     else
       fail ("HEADER.DIMUPT [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMUPT, dimupt);
     dimupt++;
     if (dwg_dynapi_header_set_value (dwg, "DIMUPT", &dimupt, 0)
         && dimupt == dwg->header_vars.DIMUPT)
       pass ();
     else
       fail ("HEADER.DIMUPT [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.DIMUPT, dimupt);
     dimupt--;
     dwg_dynapi_header_set_value (dwg, "DIMUPT", &dimupt, 0);
 
   }
   {
     BITCODE_BS dimtzin;
     if (dwg_dynapi_header_value (dwg, "DIMTZIN", &dimtzin, NULL)
         && dimtzin == dwg->header_vars.DIMTZIN)
       pass ();
     else
       fail ("HEADER.DIMTZIN [BS] %hu != %hu", dwg->header_vars.DIMTZIN, dimtzin);
     dimtzin++;
     if (dwg_dynapi_header_set_value (dwg, "DIMTZIN", &dimtzin, 0)
         && dimtzin == dwg->header_vars.DIMTZIN)
       pass ();
     else
       fail ("HEADER.DIMTZIN [BS] set+1 %hu != %hu",
             dwg->header_vars.DIMTZIN, dimtzin);
     dimtzin--;
     dwg_dynapi_header_set_value (dwg, "DIMTZIN", &dimtzin, 0);
 
   }
   {
     BITCODE_BS dimtad;
     if (dwg_dynapi_header_value (dwg, "DIMTAD", &dimtad, NULL)
         && dimtad == dwg->header_vars.DIMTAD)
       pass ();
     else
       fail ("HEADER.DIMTAD [BS] %hu != %hu", dwg->header_vars.DIMTAD, dimtad);
     dimtad++;
     if (dwg_dynapi_header_set_value (dwg, "DIMTAD", &dimtad, 0)
         && dimtad == dwg->header_vars.DIMTAD)
       pass ();
     else
       fail ("HEADER.DIMTAD [BS] set+1 %hu != %hu",
             dwg->header_vars.DIMTAD, dimtad);
     dimtad--;
     dwg_dynapi_header_set_value (dwg, "DIMTAD", &dimtad, 0);
 
   }
   {
     BITCODE_BS dimunit;
     if (dwg_dynapi_header_value (dwg, "DIMUNIT", &dimunit, NULL)
         && dimunit == dwg->header_vars.DIMUNIT)
       pass ();
     else
       fail ("HEADER.DIMUNIT [BS] %hu != %hu", dwg->header_vars.DIMUNIT, dimunit);
     dimunit++;
     if (dwg_dynapi_header_set_value (dwg, "DIMUNIT", &dimunit, 0)
         && dimunit == dwg->header_vars.DIMUNIT)
       pass ();
     else
       fail ("HEADER.DIMUNIT [BS] set+1 %hu != %hu",
             dwg->header_vars.DIMUNIT, dimunit);
     dimunit--;
     dwg_dynapi_header_set_value (dwg, "DIMUNIT", &dimunit, 0);
 
   }
   {
     BITCODE_BS dimaunit;
     if (dwg_dynapi_header_value (dwg, "DIMAUNIT", &dimaunit, NULL)
         && dimaunit == dwg->header_vars.DIMAUNIT)
       pass ();
     else
       fail ("HEADER.DIMAUNIT [BS] %hu != %hu", dwg->header_vars.DIMAUNIT, dimaunit);
     dimaunit++;
     if (dwg_dynapi_header_set_value (dwg, "DIMAUNIT", &dimaunit, 0)
         && dimaunit == dwg->header_vars.DIMAUNIT)
       pass ();
     else
       fail ("HEADER.DIMAUNIT [BS] set+1 %hu != %hu",
             dwg->header_vars.DIMAUNIT, dimaunit);
     dimaunit--;
     dwg_dynapi_header_set_value (dwg, "DIMAUNIT", &dimaunit, 0);
 
   }
   {
     BITCODE_BS dimdec;
     if (dwg_dynapi_header_value (dwg, "DIMDEC", &dimdec, NULL)
         && dimdec == dwg->header_vars.DIMDEC)
       pass ();
     else
       fail ("HEADER.DIMDEC [BS] %hu != %hu", dwg->header_vars.DIMDEC, dimdec);
     dimdec++;
     if (dwg_dynapi_header_set_value (dwg, "DIMDEC", &dimdec, 0)
         && dimdec == dwg->header_vars.DIMDEC)
       pass ();
     else
       fail ("HEADER.DIMDEC [BS] set+1 %hu != %hu",
             dwg->header_vars.DIMDEC, dimdec);
     dimdec--;
     dwg_dynapi_header_set_value (dwg, "DIMDEC", &dimdec, 0);
 
   }
   {
     BITCODE_BS dimtdec;
     if (dwg_dynapi_header_value (dwg, "DIMTDEC", &dimtdec, NULL)
         && dimtdec == dwg->header_vars.DIMTDEC)
       pass ();
     else
       fail ("HEADER.DIMTDEC [BS] %hu != %hu", dwg->header_vars.DIMTDEC, dimtdec);
     dimtdec++;
     if (dwg_dynapi_header_set_value (dwg, "DIMTDEC", &dimtdec, 0)
         && dimtdec == dwg->header_vars.DIMTDEC)
       pass ();
     else
       fail ("HEADER.DIMTDEC [BS] set+1 %hu != %hu",
             dwg->header_vars.DIMTDEC, dimtdec);
     dimtdec--;
     dwg_dynapi_header_set_value (dwg, "DIMTDEC", &dimtdec, 0);
 
   }
   {
     BITCODE_BS dimaltu;
     if (dwg_dynapi_header_value (dwg, "DIMALTU", &dimaltu, NULL)
         && dimaltu == dwg->header_vars.DIMALTU)
       pass ();
     else
       fail ("HEADER.DIMALTU [BS] %hu != %hu", dwg->header_vars.DIMALTU, dimaltu);
     dimaltu++;
     if (dwg_dynapi_header_set_value (dwg, "DIMALTU", &dimaltu, 0)
         && dimaltu == dwg->header_vars.DIMALTU)
       pass ();
     else
       fail ("HEADER.DIMALTU [BS] set+1 %hu != %hu",
             dwg->header_vars.DIMALTU, dimaltu);
     dimaltu--;
     dwg_dynapi_header_set_value (dwg, "DIMALTU", &dimaltu, 0);
 
   }
   {
     BITCODE_BS dimalttd;
     if (dwg_dynapi_header_value (dwg, "DIMALTTD", &dimalttd, NULL)
         && dimalttd == dwg->header_vars.DIMALTTD)
       pass ();
     else
       fail ("HEADER.DIMALTTD [BS] %hu != %hu", dwg->header_vars.DIMALTTD, dimalttd);
     dimalttd++;
     if (dwg_dynapi_header_set_value (dwg, "DIMALTTD", &dimalttd, 0)
         && dimalttd == dwg->header_vars.DIMALTTD)
       pass ();
     else
       fail ("HEADER.DIMALTTD [BS] set+1 %hu != %hu",
             dwg->header_vars.DIMALTTD, dimalttd);
     dimalttd--;
     dwg_dynapi_header_set_value (dwg, "DIMALTTD", &dimalttd, 0);
 
   }
   {
     BITCODE_H dimtxsty;
     if (dwg_dynapi_header_value (dwg, "DIMTXSTY", &dimtxsty, NULL)
         && !memcmp (&dimtxsty, &dwg->header_vars.DIMTXSTY, sizeof (dwg->header_vars.DIMTXSTY))
        )
       pass ();
     else
       fail ("HEADER.DIMTXSTY [H]");
   }
   {
     BITCODE_BD dimscale;
     if (dwg_dynapi_header_value (dwg, "DIMSCALE", &dimscale, NULL)
         && dimscale == dwg->header_vars.DIMSCALE)
       pass ();
     else
       fail ("HEADER.DIMSCALE [BD] %g != %g", dwg->header_vars.DIMSCALE, dimscale);
     dimscale++;
     if (dwg_dynapi_header_set_value (dwg, "DIMSCALE", &dimscale, 0)
         && dimscale == dwg->header_vars.DIMSCALE)
       pass ();
     else
       fail ("HEADER.DIMSCALE [BD] set+1 %g != %g",
             dwg->header_vars.DIMSCALE, dimscale);
     dimscale--;
     dwg_dynapi_header_set_value (dwg, "DIMSCALE", &dimscale, 0);
 
   }
   {
     BITCODE_BD dimarrow;
     if (dwg_dynapi_header_value (dwg, "DIMARROW", &dimarrow, NULL)
         && dimarrow == dwg->header_vars.DIMARROW)
       pass ();
     else
       fail ("HEADER.DIMARROW [BD] %g != %g", dwg->header_vars.DIMARROW, dimarrow);
     dimarrow++;
     if (dwg_dynapi_header_set_value (dwg, "DIMARROW", &dimarrow, 0)
         && dimarrow == dwg->header_vars.DIMARROW)
       pass ();
     else
       fail ("HEADER.DIMARROW [BD] set+1 %g != %g",
             dwg->header_vars.DIMARROW, dimarrow);
     dimarrow--;
     dwg_dynapi_header_set_value (dwg, "DIMARROW", &dimarrow, 0);
 
   }
   {
     BITCODE_BD dimasz;
     if (dwg_dynapi_header_value (dwg, "DIMASZ", &dimasz, NULL)
         && dimasz == dwg->header_vars.DIMASZ)
       pass ();
     else
       fail ("HEADER.DIMASZ [BD] %g != %g", dwg->header_vars.DIMASZ, dimasz);
     dimasz++;
     if (dwg_dynapi_header_set_value (dwg, "DIMASZ", &dimasz, 0)
         && dimasz == dwg->header_vars.DIMASZ)
       pass ();
     else
       fail ("HEADER.DIMASZ [BD] set+1 %g != %g",
             dwg->header_vars.DIMASZ, dimasz);
     dimasz--;
     dwg_dynapi_header_set_value (dwg, "DIMASZ", &dimasz, 0);
 
   }
   {
     BITCODE_BD dimexo;
     if (dwg_dynapi_header_value (dwg, "DIMEXO", &dimexo, NULL)
         && dimexo == dwg->header_vars.DIMEXO)
       pass ();
     else
       fail ("HEADER.DIMEXO [BD] %g != %g", dwg->header_vars.DIMEXO, dimexo);
     dimexo++;
     if (dwg_dynapi_header_set_value (dwg, "DIMEXO", &dimexo, 0)
         && dimexo == dwg->header_vars.DIMEXO)
       pass ();
     else
       fail ("HEADER.DIMEXO [BD] set+1 %g != %g",
             dwg->header_vars.DIMEXO, dimexo);
     dimexo--;
     dwg_dynapi_header_set_value (dwg, "DIMEXO", &dimexo, 0);
 
   }
   {
     BITCODE_BD dimdli;
     if (dwg_dynapi_header_value (dwg, "DIMDLI", &dimdli, NULL)
         && dimdli == dwg->header_vars.DIMDLI)
       pass ();
     else
       fail ("HEADER.DIMDLI [BD] %g != %g", dwg->header_vars.DIMDLI, dimdli);
     dimdli++;
     if (dwg_dynapi_header_set_value (dwg, "DIMDLI", &dimdli, 0)
         && dimdli == dwg->header_vars.DIMDLI)
       pass ();
     else
       fail ("HEADER.DIMDLI [BD] set+1 %g != %g",
             dwg->header_vars.DIMDLI, dimdli);
     dimdli--;
     dwg_dynapi_header_set_value (dwg, "DIMDLI", &dimdli, 0);
 
   }
   {
     BITCODE_BD dimexe;
     if (dwg_dynapi_header_value (dwg, "DIMEXE", &dimexe, NULL)
         && dimexe == dwg->header_vars.DIMEXE)
       pass ();
     else
       fail ("HEADER.DIMEXE [BD] %g != %g", dwg->header_vars.DIMEXE, dimexe);
     dimexe++;
     if (dwg_dynapi_header_set_value (dwg, "DIMEXE", &dimexe, 0)
         && dimexe == dwg->header_vars.DIMEXE)
       pass ();
     else
       fail ("HEADER.DIMEXE [BD] set+1 %g != %g",
             dwg->header_vars.DIMEXE, dimexe);
     dimexe--;
     dwg_dynapi_header_set_value (dwg, "DIMEXE", &dimexe, 0);
 
   }
   {
     BITCODE_BD dimrnd;
     if (dwg_dynapi_header_value (dwg, "DIMRND", &dimrnd, NULL)
         && dimrnd == dwg->header_vars.DIMRND)
       pass ();
     else
       fail ("HEADER.DIMRND [BD] %g != %g", dwg->header_vars.DIMRND, dimrnd);
     dimrnd++;
     if (dwg_dynapi_header_set_value (dwg, "DIMRND", &dimrnd, 0)
         && dimrnd == dwg->header_vars.DIMRND)
       pass ();
     else
       fail ("HEADER.DIMRND [BD] set+1 %g != %g",
             dwg->header_vars.DIMRND, dimrnd);
     dimrnd--;
     dwg_dynapi_header_set_value (dwg, "DIMRND", &dimrnd, 0);
 
   }
   {
     BITCODE_BD dimdle;
     if (dwg_dynapi_header_value (dwg, "DIMDLE", &dimdle, NULL)
         && dimdle == dwg->header_vars.DIMDLE)
       pass ();
     else
       fail ("HEADER.DIMDLE [BD] %g != %g", dwg->header_vars.DIMDLE, dimdle);
     dimdle++;
     if (dwg_dynapi_header_set_value (dwg, "DIMDLE", &dimdle, 0)
         && dimdle == dwg->header_vars.DIMDLE)
       pass ();
     else
       fail ("HEADER.DIMDLE [BD] set+1 %g != %g",
             dwg->header_vars.DIMDLE, dimdle);
     dimdle--;
     dwg_dynapi_header_set_value (dwg, "DIMDLE", &dimdle, 0);
 
   }
   {
     BITCODE_BD dimtp;
     if (dwg_dynapi_header_value (dwg, "DIMTP", &dimtp, NULL)
         && dimtp == dwg->header_vars.DIMTP)
       pass ();
     else
       fail ("HEADER.DIMTP [BD] %g != %g", dwg->header_vars.DIMTP, dimtp);
     dimtp++;
     if (dwg_dynapi_header_set_value (dwg, "DIMTP", &dimtp, 0)
         && dimtp == dwg->header_vars.DIMTP)
       pass ();
     else
       fail ("HEADER.DIMTP [BD] set+1 %g != %g",
             dwg->header_vars.DIMTP, dimtp);
     dimtp--;
     dwg_dynapi_header_set_value (dwg, "DIMTP", &dimtp, 0);
 
   }
   {
     BITCODE_BD dimtm;
     if (dwg_dynapi_header_value (dwg, "DIMTM", &dimtm, NULL)
         && dimtm == dwg->header_vars.DIMTM)
       pass ();
     else
       fail ("HEADER.DIMTM [BD] %g != %g", dwg->header_vars.DIMTM, dimtm);
     dimtm++;
     if (dwg_dynapi_header_set_value (dwg, "DIMTM", &dimtm, 0)
         && dimtm == dwg->header_vars.DIMTM)
       pass ();
     else
       fail ("HEADER.DIMTM [BD] set+1 %g != %g",
             dwg->header_vars.DIMTM, dimtm);
     dimtm--;
     dwg_dynapi_header_set_value (dwg, "DIMTM", &dimtm, 0);
 
   }
   {
     BITCODE_BD dimfxl;
     if (dwg_dynapi_header_value (dwg, "DIMFXL", &dimfxl, NULL)
         && dimfxl == dwg->header_vars.DIMFXL)
       pass ();
     else
       fail ("HEADER.DIMFXL [BD] %g != %g", dwg->header_vars.DIMFXL, dimfxl);
     dimfxl++;
     if (dwg_dynapi_header_set_value (dwg, "DIMFXL", &dimfxl, 0)
         && dimfxl == dwg->header_vars.DIMFXL)
       pass ();
     else
       fail ("HEADER.DIMFXL [BD] set+1 %g != %g",
             dwg->header_vars.DIMFXL, dimfxl);
     dimfxl--;
     dwg_dynapi_header_set_value (dwg, "DIMFXL", &dimfxl, 0);
 
   }
   {
     BITCODE_BD dimjogang;
     if (dwg_dynapi_header_value (dwg, "DIMJOGANG", &dimjogang, NULL)
         && dimjogang == dwg->header_vars.DIMJOGANG)
       pass ();
     else
       fail ("HEADER.DIMJOGANG [BD] %g != %g", dwg->header_vars.DIMJOGANG, dimjogang);
     dimjogang++;
     if (dwg_dynapi_header_set_value (dwg, "DIMJOGANG", &dimjogang, 0)
         && dimjogang == dwg->header_vars.DIMJOGANG)
       pass ();
     else
       fail ("HEADER.DIMJOGANG [BD] set+1 %g != %g",
             dwg->header_vars.DIMJOGANG, dimjogang);
     dimjogang--;
     dwg_dynapi_header_set_value (dwg, "DIMJOGANG", &dimjogang, 0);
 
   }
   {
     BITCODE_BS dimtfill;
     if (dwg_dynapi_header_value (dwg, "DIMTFILL", &dimtfill, NULL)
         && dimtfill == dwg->header_vars.DIMTFILL)
       pass ();
     else
       fail ("HEADER.DIMTFILL [BS] %hu != %hu", dwg->header_vars.DIMTFILL, dimtfill);
     dimtfill++;
     if (dwg_dynapi_header_set_value (dwg, "DIMTFILL", &dimtfill, 0)
         && dimtfill == dwg->header_vars.DIMTFILL)
       pass ();
     else
       fail ("HEADER.DIMTFILL [BS] set+1 %hu != %hu",
             dwg->header_vars.DIMTFILL, dimtfill);
     dimtfill--;
     dwg_dynapi_header_set_value (dwg, "DIMTFILL", &dimtfill, 0);
 
   }
   {
     BITCODE_CMC dimtfillclr;
     if (dwg_dynapi_header_value (dwg, "DIMTFILLCLR", &dimtfillclr, NULL)
         && !memcmp (&dimtfillclr, &dwg->header_vars.DIMTFILLCLR, sizeof (dwg->header_vars.DIMTFILLCLR))
        )
       pass ();
     else
       fail ("HEADER.DIMTFILLCLR [CMC]");
   }
   {
     BITCODE_BS dimazin;
     if (dwg_dynapi_header_value (dwg, "DIMAZIN", &dimazin, NULL)
         && dimazin == dwg->header_vars.DIMAZIN)
       pass ();
     else
       fail ("HEADER.DIMAZIN [BS] %hu != %hu", dwg->header_vars.DIMAZIN, dimazin);
     dimazin++;
     if (dwg_dynapi_header_set_value (dwg, "DIMAZIN", &dimazin, 0)
         && dimazin == dwg->header_vars.DIMAZIN)
       pass ();
     else
       fail ("HEADER.DIMAZIN [BS] set+1 %hu != %hu",
             dwg->header_vars.DIMAZIN, dimazin);
     dimazin--;
     dwg_dynapi_header_set_value (dwg, "DIMAZIN", &dimazin, 0);
 
   }
   {
     BITCODE_BS dimarcsym;
     if (dwg_dynapi_header_value (dwg, "DIMARCSYM", &dimarcsym, NULL)
         && dimarcsym == dwg->header_vars.DIMARCSYM)
       pass ();
     else
       fail ("HEADER.DIMARCSYM [BS] %hu != %hu", dwg->header_vars.DIMARCSYM, dimarcsym);
     dimarcsym++;
     if (dwg_dynapi_header_set_value (dwg, "DIMARCSYM", &dimarcsym, 0)
         && dimarcsym == dwg->header_vars.DIMARCSYM)
       pass ();
     else
       fail ("HEADER.DIMARCSYM [BS] set+1 %hu != %hu",
             dwg->header_vars.DIMARCSYM, dimarcsym);
     dimarcsym--;
     dwg_dynapi_header_set_value (dwg, "DIMARCSYM", &dimarcsym, 0);
 
   }
   {
     BITCODE_BD dimtxt;
     if (dwg_dynapi_header_value (dwg, "DIMTXT", &dimtxt, NULL)
         && dimtxt == dwg->header_vars.DIMTXT)
       pass ();
     else
       fail ("HEADER.DIMTXT [BD] %g != %g", dwg->header_vars.DIMTXT, dimtxt);
     dimtxt++;
     if (dwg_dynapi_header_set_value (dwg, "DIMTXT", &dimtxt, 0)
         && dimtxt == dwg->header_vars.DIMTXT)
       pass ();
     else
       fail ("HEADER.DIMTXT [BD] set+1 %g != %g",
             dwg->header_vars.DIMTXT, dimtxt);
     dimtxt--;
     dwg_dynapi_header_set_value (dwg, "DIMTXT", &dimtxt, 0);
 
   }
   {
     BITCODE_BD dimcen;
     if (dwg_dynapi_header_value (dwg, "DIMCEN", &dimcen, NULL)
         && dimcen == dwg->header_vars.DIMCEN)
       pass ();
     else
       fail ("HEADER.DIMCEN [BD] %g != %g", dwg->header_vars.DIMCEN, dimcen);
     dimcen++;
     if (dwg_dynapi_header_set_value (dwg, "DIMCEN", &dimcen, 0)
         && dimcen == dwg->header_vars.DIMCEN)
       pass ();
     else
       fail ("HEADER.DIMCEN [BD] set+1 %g != %g",
             dwg->header_vars.DIMCEN, dimcen);
     dimcen--;
     dwg_dynapi_header_set_value (dwg, "DIMCEN", &dimcen, 0);
 
   }
   {
     BITCODE_BD dimtsz;
     if (dwg_dynapi_header_value (dwg, "DIMTSZ", &dimtsz, NULL)
         && dimtsz == dwg->header_vars.DIMTSZ)
       pass ();
     else
       fail ("HEADER.DIMTSZ [BD] %g != %g", dwg->header_vars.DIMTSZ, dimtsz);
     dimtsz++;
     if (dwg_dynapi_header_set_value (dwg, "DIMTSZ", &dimtsz, 0)
         && dimtsz == dwg->header_vars.DIMTSZ)
       pass ();
     else
       fail ("HEADER.DIMTSZ [BD] set+1 %g != %g",
             dwg->header_vars.DIMTSZ, dimtsz);
     dimtsz--;
     dwg_dynapi_header_set_value (dwg, "DIMTSZ", &dimtsz, 0);
 
   }
   {
     BITCODE_BD dimaltf;
     if (dwg_dynapi_header_value (dwg, "DIMALTF", &dimaltf, NULL)
         && dimaltf == dwg->header_vars.DIMALTF)
       pass ();
     else
       fail ("HEADER.DIMALTF [BD] %g != %g", dwg->header_vars.DIMALTF, dimaltf);
     dimaltf++;
     if (dwg_dynapi_header_set_value (dwg, "DIMALTF", &dimaltf, 0)
         && dimaltf == dwg->header_vars.DIMALTF)
       pass ();
     else
       fail ("HEADER.DIMALTF [BD] set+1 %g != %g",
             dwg->header_vars.DIMALTF, dimaltf);
     dimaltf--;
     dwg_dynapi_header_set_value (dwg, "DIMALTF", &dimaltf, 0);
 
   }
   {
     BITCODE_BD dimlfac;
     if (dwg_dynapi_header_value (dwg, "DIMLFAC", &dimlfac, NULL)
         && dimlfac == dwg->header_vars.DIMLFAC)
       pass ();
     else
       fail ("HEADER.DIMLFAC [BD] %g != %g", dwg->header_vars.DIMLFAC, dimlfac);
     dimlfac++;
     if (dwg_dynapi_header_set_value (dwg, "DIMLFAC", &dimlfac, 0)
         && dimlfac == dwg->header_vars.DIMLFAC)
       pass ();
     else
       fail ("HEADER.DIMLFAC [BD] set+1 %g != %g",
             dwg->header_vars.DIMLFAC, dimlfac);
     dimlfac--;
     dwg_dynapi_header_set_value (dwg, "DIMLFAC", &dimlfac, 0);
 
   }
   {
     BITCODE_BD dimtvp;
     if (dwg_dynapi_header_value (dwg, "DIMTVP", &dimtvp, NULL)
         && dimtvp == dwg->header_vars.DIMTVP)
       pass ();
     else
       fail ("HEADER.DIMTVP [BD] %g != %g", dwg->header_vars.DIMTVP, dimtvp);
     dimtvp++;
     if (dwg_dynapi_header_set_value (dwg, "DIMTVP", &dimtvp, 0)
         && dimtvp == dwg->header_vars.DIMTVP)
       pass ();
     else
       fail ("HEADER.DIMTVP [BD] set+1 %g != %g",
             dwg->header_vars.DIMTVP, dimtvp);
     dimtvp--;
     dwg_dynapi_header_set_value (dwg, "DIMTVP", &dimtvp, 0);
 
   }
   {
     BITCODE_BD dimtfac;
     if (dwg_dynapi_header_value (dwg, "DIMTFAC", &dimtfac, NULL)
         && dimtfac == dwg->header_vars.DIMTFAC)
       pass ();
     else
       fail ("HEADER.DIMTFAC [BD] %g != %g", dwg->header_vars.DIMTFAC, dimtfac);
     dimtfac++;
     if (dwg_dynapi_header_set_value (dwg, "DIMTFAC", &dimtfac, 0)
         && dimtfac == dwg->header_vars.DIMTFAC)
       pass ();
     else
       fail ("HEADER.DIMTFAC [BD] set+1 %g != %g",
             dwg->header_vars.DIMTFAC, dimtfac);
     dimtfac--;
     dwg_dynapi_header_set_value (dwg, "DIMTFAC", &dimtfac, 0);
 
   }
   {
     BITCODE_BD dimgap;
     if (dwg_dynapi_header_value (dwg, "DIMGAP", &dimgap, NULL)
         && dimgap == dwg->header_vars.DIMGAP)
       pass ();
     else
       fail ("HEADER.DIMGAP [BD] %g != %g", dwg->header_vars.DIMGAP, dimgap);
     dimgap++;
     if (dwg_dynapi_header_set_value (dwg, "DIMGAP", &dimgap, 0)
         && dimgap == dwg->header_vars.DIMGAP)
       pass ();
     else
       fail ("HEADER.DIMGAP [BD] set+1 %g != %g",
             dwg->header_vars.DIMGAP, dimgap);
     dimgap--;
     dwg_dynapi_header_set_value (dwg, "DIMGAP", &dimgap, 0);
 
   }
   {
     BITCODE_T dimpost_t;
     if (dwg_dynapi_header_value (dwg, "DIMPOST_T", &dimpost_t, NULL)
         && !memcmp (&dimpost_t, &dwg->header_vars.DIMPOST_T, sizeof (dwg->header_vars.DIMPOST_T))
        )
       pass ();
     else
       fail ("HEADER.DIMPOST_T [T]");
   }
   {
     BITCODE_T dimapost_t;
     if (dwg_dynapi_header_value (dwg, "DIMAPOST_T", &dimapost_t, NULL)
         && !memcmp (&dimapost_t, &dwg->header_vars.DIMAPOST_T, sizeof (dwg->header_vars.DIMAPOST_T))
        )
       pass ();
     else
       fail ("HEADER.DIMAPOST_T [T]");
   }
   {
     BITCODE_T dimblk_t;
     if (dwg_dynapi_header_value (dwg, "DIMBLK_T", &dimblk_t, NULL)
         && !memcmp (&dimblk_t, &dwg->header_vars.DIMBLK_T, sizeof (dwg->header_vars.DIMBLK_T))
        )
       pass ();
     else
       fail ("HEADER.DIMBLK_T [T]");
   }
   {
     BITCODE_T dimblk1_t;
     if (dwg_dynapi_header_value (dwg, "DIMBLK1_T", &dimblk1_t, NULL)
         && !memcmp (&dimblk1_t, &dwg->header_vars.DIMBLK1_T, sizeof (dwg->header_vars.DIMBLK1_T))
        )
       pass ();
     else
       fail ("HEADER.DIMBLK1_T [T]");
   }
   {
     BITCODE_T dimblk2_t;
     if (dwg_dynapi_header_value (dwg, "DIMBLK2_T", &dimblk2_t, NULL)
         && !memcmp (&dimblk2_t, &dwg->header_vars.DIMBLK2_T, sizeof (dwg->header_vars.DIMBLK2_T))
        )
       pass ();
     else
       fail ("HEADER.DIMBLK2_T [T]");
   }
   {
     BITCODE_T unknown_string;
     if (dwg_dynapi_header_value (dwg, "unknown_string", &unknown_string, NULL)
         && !memcmp (&unknown_string, &dwg->header_vars.unknown_string, sizeof (dwg->header_vars.unknown_string))
        )
       pass ();
     else
       fail ("HEADER.unknown_string [T]");
   }
   {
     BITCODE_BD dimaltrnd;
     if (dwg_dynapi_header_value (dwg, "DIMALTRND", &dimaltrnd, NULL)
         && dimaltrnd == dwg->header_vars.DIMALTRND)
       pass ();
     else
       fail ("HEADER.DIMALTRND [BD] %g != %g", dwg->header_vars.DIMALTRND, dimaltrnd);
     dimaltrnd++;
     if (dwg_dynapi_header_set_value (dwg, "DIMALTRND", &dimaltrnd, 0)
         && dimaltrnd == dwg->header_vars.DIMALTRND)
       pass ();
     else
       fail ("HEADER.DIMALTRND [BD] set+1 %g != %g",
             dwg->header_vars.DIMALTRND, dimaltrnd);
     dimaltrnd--;
     dwg_dynapi_header_set_value (dwg, "DIMALTRND", &dimaltrnd, 0);
 
   }
   {
     BITCODE_RS dimclrd_c;
     if (dwg_dynapi_header_value (dwg, "DIMCLRD_C", &dimclrd_c, NULL)
         && dimclrd_c == dwg->header_vars.DIMCLRD_C)
       pass ();
     else
       fail ("HEADER.DIMCLRD_C [RS] %hu != %hu", dwg->header_vars.DIMCLRD_C, dimclrd_c);
     dimclrd_c++;
     if (dwg_dynapi_header_set_value (dwg, "DIMCLRD_C", &dimclrd_c, 0)
         && dimclrd_c == dwg->header_vars.DIMCLRD_C)
       pass ();
     else
       fail ("HEADER.DIMCLRD_C [RS] set+1 %hu != %hu",
             dwg->header_vars.DIMCLRD_C, dimclrd_c);
     dimclrd_c--;
     dwg_dynapi_header_set_value (dwg, "DIMCLRD_C", &dimclrd_c, 0);
 
   }
   {
     BITCODE_RS dimclre_c;
     if (dwg_dynapi_header_value (dwg, "DIMCLRE_C", &dimclre_c, NULL)
         && dimclre_c == dwg->header_vars.DIMCLRE_C)
       pass ();
     else
       fail ("HEADER.DIMCLRE_C [RS] %hu != %hu", dwg->header_vars.DIMCLRE_C, dimclre_c);
     dimclre_c++;
     if (dwg_dynapi_header_set_value (dwg, "DIMCLRE_C", &dimclre_c, 0)
         && dimclre_c == dwg->header_vars.DIMCLRE_C)
       pass ();
     else
       fail ("HEADER.DIMCLRE_C [RS] set+1 %hu != %hu",
             dwg->header_vars.DIMCLRE_C, dimclre_c);
     dimclre_c--;
     dwg_dynapi_header_set_value (dwg, "DIMCLRE_C", &dimclre_c, 0);
 
   }
   {
     BITCODE_RS dimclrt_c;
     if (dwg_dynapi_header_value (dwg, "DIMCLRT_C", &dimclrt_c, NULL)
         && dimclrt_c == dwg->header_vars.DIMCLRT_C)
       pass ();
     else
       fail ("HEADER.DIMCLRT_C [RS] %hu != %hu", dwg->header_vars.DIMCLRT_C, dimclrt_c);
     dimclrt_c++;
     if (dwg_dynapi_header_set_value (dwg, "DIMCLRT_C", &dimclrt_c, 0)
         && dimclrt_c == dwg->header_vars.DIMCLRT_C)
       pass ();
     else
       fail ("HEADER.DIMCLRT_C [RS] set+1 %hu != %hu",
             dwg->header_vars.DIMCLRT_C, dimclrt_c);
     dimclrt_c--;
     dwg_dynapi_header_set_value (dwg, "DIMCLRT_C", &dimclrt_c, 0);
 
   }
   {
     BITCODE_CMC dimclrd;
     if (dwg_dynapi_header_value (dwg, "DIMCLRD", &dimclrd, NULL)
         && !memcmp (&dimclrd, &dwg->header_vars.DIMCLRD, sizeof (dwg->header_vars.DIMCLRD))
        )
       pass ();
     else
       fail ("HEADER.DIMCLRD [CMC]");
   }
   {
     BITCODE_CMC dimclre;
     if (dwg_dynapi_header_value (dwg, "DIMCLRE", &dimclre, NULL)
         && !memcmp (&dimclre, &dwg->header_vars.DIMCLRE, sizeof (dwg->header_vars.DIMCLRE))
        )
       pass ();
     else
       fail ("HEADER.DIMCLRE [CMC]");
   }
   {
     BITCODE_CMC dimclrt;
     if (dwg_dynapi_header_value (dwg, "DIMCLRT", &dimclrt, NULL)
         && !memcmp (&dimclrt, &dwg->header_vars.DIMCLRT, sizeof (dwg->header_vars.DIMCLRT))
        )
       pass ();
     else
       fail ("HEADER.DIMCLRT [CMC]");
   }
   {
     BITCODE_BS dimadec;
     if (dwg_dynapi_header_value (dwg, "DIMADEC", &dimadec, NULL)
         && dimadec == dwg->header_vars.DIMADEC)
       pass ();
     else
       fail ("HEADER.DIMADEC [BS] %hu != %hu", dwg->header_vars.DIMADEC, dimadec);
     dimadec++;
     if (dwg_dynapi_header_set_value (dwg, "DIMADEC", &dimadec, 0)
         && dimadec == dwg->header_vars.DIMADEC)
       pass ();
     else
       fail ("HEADER.DIMADEC [BS] set+1 %hu != %hu",
             dwg->header_vars.DIMADEC, dimadec);
     dimadec--;
     dwg_dynapi_header_set_value (dwg, "DIMADEC", &dimadec, 0);
 
   }
   {
     BITCODE_BS dimfrac;
     if (dwg_dynapi_header_value (dwg, "DIMFRAC", &dimfrac, NULL)
         && dimfrac == dwg->header_vars.DIMFRAC)
       pass ();
     else
       fail ("HEADER.DIMFRAC [BS] %hu != %hu", dwg->header_vars.DIMFRAC, dimfrac);
     dimfrac++;
     if (dwg_dynapi_header_set_value (dwg, "DIMFRAC", &dimfrac, 0)
         && dimfrac == dwg->header_vars.DIMFRAC)
       pass ();
     else
       fail ("HEADER.DIMFRAC [BS] set+1 %hu != %hu",
             dwg->header_vars.DIMFRAC, dimfrac);
     dimfrac--;
     dwg_dynapi_header_set_value (dwg, "DIMFRAC", &dimfrac, 0);
 
   }
   {
     BITCODE_BS dimlunit;
     if (dwg_dynapi_header_value (dwg, "DIMLUNIT", &dimlunit, NULL)
         && dimlunit == dwg->header_vars.DIMLUNIT)
       pass ();
     else
       fail ("HEADER.DIMLUNIT [BS] %hu != %hu", dwg->header_vars.DIMLUNIT, dimlunit);
     dimlunit++;
     if (dwg_dynapi_header_set_value (dwg, "DIMLUNIT", &dimlunit, 0)
         && dimlunit == dwg->header_vars.DIMLUNIT)
       pass ();
     else
       fail ("HEADER.DIMLUNIT [BS] set+1 %hu != %hu",
             dwg->header_vars.DIMLUNIT, dimlunit);
     dimlunit--;
     dwg_dynapi_header_set_value (dwg, "DIMLUNIT", &dimlunit, 0);
 
   }
   {
     BITCODE_BS dimdsep;
     if (dwg_dynapi_header_value (dwg, "DIMDSEP", &dimdsep, NULL)
         && dimdsep == dwg->header_vars.DIMDSEP)
       pass ();
     else
       fail ("HEADER.DIMDSEP [BS] %hu != %hu", dwg->header_vars.DIMDSEP, dimdsep);
     dimdsep++;
     if (dwg_dynapi_header_set_value (dwg, "DIMDSEP", &dimdsep, 0)
         && dimdsep == dwg->header_vars.DIMDSEP)
       pass ();
     else
       fail ("HEADER.DIMDSEP [BS] set+1 %hu != %hu",
             dwg->header_vars.DIMDSEP, dimdsep);
     dimdsep--;
     dwg_dynapi_header_set_value (dwg, "DIMDSEP", &dimdsep, 0);
 
   }
   {
     BITCODE_BS dimtmove;
     if (dwg_dynapi_header_value (dwg, "DIMTMOVE", &dimtmove, NULL)
         && dimtmove == dwg->header_vars.DIMTMOVE)
       pass ();
     else
       fail ("HEADER.DIMTMOVE [BS] %hu != %hu", dwg->header_vars.DIMTMOVE, dimtmove);
     dimtmove++;
     if (dwg_dynapi_header_set_value (dwg, "DIMTMOVE", &dimtmove, 0)
         && dimtmove == dwg->header_vars.DIMTMOVE)
       pass ();
     else
       fail ("HEADER.DIMTMOVE [BS] set+1 %hu != %hu",
             dwg->header_vars.DIMTMOVE, dimtmove);
     dimtmove--;
     dwg_dynapi_header_set_value (dwg, "DIMTMOVE", &dimtmove, 0);
 
   }
   {
     BITCODE_BS dimaltz;
     if (dwg_dynapi_header_value (dwg, "DIMALTZ", &dimaltz, NULL)
         && dimaltz == dwg->header_vars.DIMALTZ)
       pass ();
     else
       fail ("HEADER.DIMALTZ [BS] %hu != %hu", dwg->header_vars.DIMALTZ, dimaltz);
     dimaltz++;
     if (dwg_dynapi_header_set_value (dwg, "DIMALTZ", &dimaltz, 0)
         && dimaltz == dwg->header_vars.DIMALTZ)
       pass ();
     else
       fail ("HEADER.DIMALTZ [BS] set+1 %hu != %hu",
             dwg->header_vars.DIMALTZ, dimaltz);
     dimaltz--;
     dwg_dynapi_header_set_value (dwg, "DIMALTZ", &dimaltz, 0);
 
   }
   {
     BITCODE_BS dimalttz;
     if (dwg_dynapi_header_value (dwg, "DIMALTTZ", &dimalttz, NULL)
         && dimalttz == dwg->header_vars.DIMALTTZ)
       pass ();
     else
       fail ("HEADER.DIMALTTZ [BS] %hu != %hu", dwg->header_vars.DIMALTTZ, dimalttz);
     dimalttz++;
     if (dwg_dynapi_header_set_value (dwg, "DIMALTTZ", &dimalttz, 0)
         && dimalttz == dwg->header_vars.DIMALTTZ)
       pass ();
     else
       fail ("HEADER.DIMALTTZ [BS] set+1 %hu != %hu",
             dwg->header_vars.DIMALTTZ, dimalttz);
     dimalttz--;
     dwg_dynapi_header_set_value (dwg, "DIMALTTZ", &dimalttz, 0);
 
   }
   {
     BITCODE_BS dimatfit;
     if (dwg_dynapi_header_value (dwg, "DIMATFIT", &dimatfit, NULL)
         && dimatfit == dwg->header_vars.DIMATFIT)
       pass ();
     else
       fail ("HEADER.DIMATFIT [BS] %hu != %hu", dwg->header_vars.DIMATFIT, dimatfit);
     dimatfit++;
     if (dwg_dynapi_header_set_value (dwg, "DIMATFIT", &dimatfit, 0)
         && dimatfit == dwg->header_vars.DIMATFIT)
       pass ();
     else
       fail ("HEADER.DIMATFIT [BS] set+1 %hu != %hu",
             dwg->header_vars.DIMATFIT, dimatfit);
     dimatfit--;
     dwg_dynapi_header_set_value (dwg, "DIMATFIT", &dimatfit, 0);
 
   }
   {
     BITCODE_B dimfxlon;
     if (dwg_dynapi_header_value (dwg, "DIMFXLON", &dimfxlon, NULL)
         && dimfxlon == dwg->header_vars.DIMFXLON)
       pass ();
     else
       fail ("HEADER.DIMFXLON [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMFXLON, dimfxlon);
     dimfxlon++;
     if (dwg_dynapi_header_set_value (dwg, "DIMFXLON", &dimfxlon, 0)
         && dimfxlon == dwg->header_vars.DIMFXLON)
       pass ();
     else
       fail ("HEADER.DIMFXLON [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.DIMFXLON, dimfxlon);
     dimfxlon--;
     dwg_dynapi_header_set_value (dwg, "DIMFXLON", &dimfxlon, 0);
 
   }
   {
     BITCODE_B dimtxtdirection;
     if (dwg_dynapi_header_value (dwg, "DIMTXTDIRECTION", &dimtxtdirection, NULL)
         && dimtxtdirection == dwg->header_vars.DIMTXTDIRECTION)
       pass ();
     else
       fail ("HEADER.DIMTXTDIRECTION [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.DIMTXTDIRECTION, dimtxtdirection);
     dimtxtdirection++;
     if (dwg_dynapi_header_set_value (dwg, "DIMTXTDIRECTION", &dimtxtdirection, 0)
         && dimtxtdirection == dwg->header_vars.DIMTXTDIRECTION)
       pass ();
     else
       fail ("HEADER.DIMTXTDIRECTION [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.DIMTXTDIRECTION, dimtxtdirection);
     dimtxtdirection--;
     dwg_dynapi_header_set_value (dwg, "DIMTXTDIRECTION", &dimtxtdirection, 0);
 
   }
   {
     BITCODE_BD dimaltmzf;
     if (dwg_dynapi_header_value (dwg, "DIMALTMZF", &dimaltmzf, NULL)
         && dimaltmzf == dwg->header_vars.DIMALTMZF)
       pass ();
     else
       fail ("HEADER.DIMALTMZF [BD] %g != %g", dwg->header_vars.DIMALTMZF, dimaltmzf);
     dimaltmzf++;
     if (dwg_dynapi_header_set_value (dwg, "DIMALTMZF", &dimaltmzf, 0)
         && dimaltmzf == dwg->header_vars.DIMALTMZF)
       pass ();
     else
       fail ("HEADER.DIMALTMZF [BD] set+1 %g != %g",
             dwg->header_vars.DIMALTMZF, dimaltmzf);
     dimaltmzf--;
     dwg_dynapi_header_set_value (dwg, "DIMALTMZF", &dimaltmzf, 0);
 
   }
   {
     BITCODE_T dimaltmzs;
     if (dwg_dynapi_header_value (dwg, "DIMALTMZS", &dimaltmzs, NULL)
         && !memcmp (&dimaltmzs, &dwg->header_vars.DIMALTMZS, sizeof (dwg->header_vars.DIMALTMZS))
        )
       pass ();
     else
       fail ("HEADER.DIMALTMZS [T]");
   }
   {
     BITCODE_BD dimmzf;
     if (dwg_dynapi_header_value (dwg, "DIMMZF", &dimmzf, NULL)
         && dimmzf == dwg->header_vars.DIMMZF)
       pass ();
     else
       fail ("HEADER.DIMMZF [BD] %g != %g", dwg->header_vars.DIMMZF, dimmzf);
     dimmzf++;
     if (dwg_dynapi_header_set_value (dwg, "DIMMZF", &dimmzf, 0)
         && dimmzf == dwg->header_vars.DIMMZF)
       pass ();
     else
       fail ("HEADER.DIMMZF [BD] set+1 %g != %g",
             dwg->header_vars.DIMMZF, dimmzf);
     dimmzf--;
     dwg_dynapi_header_set_value (dwg, "DIMMZF", &dimmzf, 0);
 
   }
   {
     BITCODE_T dimmzs;
     if (dwg_dynapi_header_value (dwg, "DIMMZS", &dimmzs, NULL)
         && !memcmp (&dimmzs, &dwg->header_vars.DIMMZS, sizeof (dwg->header_vars.DIMMZS))
        )
       pass ();
     else
       fail ("HEADER.DIMMZS [T]");
   }
   {
     BITCODE_H dimldrblk;
     if (dwg_dynapi_header_value (dwg, "DIMLDRBLK", &dimldrblk, NULL)
         && !memcmp (&dimldrblk, &dwg->header_vars.DIMLDRBLK, sizeof (dwg->header_vars.DIMLDRBLK))
        )
       pass ();
     else
       fail ("HEADER.DIMLDRBLK [H]");
   }
   {
     BITCODE_H dimblk;
     if (dwg_dynapi_header_value (dwg, "DIMBLK", &dimblk, NULL)
         && !memcmp (&dimblk, &dwg->header_vars.DIMBLK, sizeof (dwg->header_vars.DIMBLK))
        )
       pass ();
     else
       fail ("HEADER.DIMBLK [H]");
   }
   {
     BITCODE_H dimblk1;
     if (dwg_dynapi_header_value (dwg, "DIMBLK1", &dimblk1, NULL)
         && !memcmp (&dimblk1, &dwg->header_vars.DIMBLK1, sizeof (dwg->header_vars.DIMBLK1))
        )
       pass ();
     else
       fail ("HEADER.DIMBLK1 [H]");
   }
   {
     BITCODE_H dimblk2;
     if (dwg_dynapi_header_value (dwg, "DIMBLK2", &dimblk2, NULL)
         && !memcmp (&dimblk2, &dwg->header_vars.DIMBLK2, sizeof (dwg->header_vars.DIMBLK2))
        )
       pass ();
     else
       fail ("HEADER.DIMBLK2 [H]");
   }
   {
     BITCODE_H dimltype;
     if (dwg_dynapi_header_value (dwg, "DIMLTYPE", &dimltype, NULL)
         && !memcmp (&dimltype, &dwg->header_vars.DIMLTYPE, sizeof (dwg->header_vars.DIMLTYPE))
        )
       pass ();
     else
       fail ("HEADER.DIMLTYPE [H]");
   }
   {
     BITCODE_H dimltex1;
     if (dwg_dynapi_header_value (dwg, "DIMLTEX1", &dimltex1, NULL)
         && !memcmp (&dimltex1, &dwg->header_vars.DIMLTEX1, sizeof (dwg->header_vars.DIMLTEX1))
        )
       pass ();
     else
       fail ("HEADER.DIMLTEX1 [H]");
   }
   {
     BITCODE_H dimltex2;
     if (dwg_dynapi_header_value (dwg, "DIMLTEX2", &dimltex2, NULL)
         && !memcmp (&dimltex2, &dwg->header_vars.DIMLTEX2, sizeof (dwg->header_vars.DIMLTEX2))
        )
       pass ();
     else
       fail ("HEADER.DIMLTEX2 [H]");
   }
   {
     BITCODE_BSd dimlwd;
     if (dwg_dynapi_header_value (dwg, "DIMLWD", &dimlwd, NULL)
         && dimlwd == dwg->header_vars.DIMLWD)
       pass ();
     else
       fail ("HEADER.DIMLWD [BSd] " FORMAT_BSd " != " FORMAT_BSd "", dwg->header_vars.DIMLWD, dimlwd);
     dimlwd++;
     if (dwg_dynapi_header_set_value (dwg, "DIMLWD", &dimlwd, 0)
         && dimlwd == dwg->header_vars.DIMLWD)
       pass ();
     else
       fail ("HEADER.DIMLWD [BSd] set+1 " FORMAT_BSd " != " FORMAT_BSd "",
             dwg->header_vars.DIMLWD, dimlwd);
     dimlwd--;
     dwg_dynapi_header_set_value (dwg, "DIMLWD", &dimlwd, 0);
 
   }
   {
     BITCODE_BSd dimlwe;
     if (dwg_dynapi_header_value (dwg, "DIMLWE", &dimlwe, NULL)
         && dimlwe == dwg->header_vars.DIMLWE)
       pass ();
     else
       fail ("HEADER.DIMLWE [BSd] " FORMAT_BSd " != " FORMAT_BSd "", dwg->header_vars.DIMLWE, dimlwe);
     dimlwe++;
     if (dwg_dynapi_header_set_value (dwg, "DIMLWE", &dimlwe, 0)
         && dimlwe == dwg->header_vars.DIMLWE)
       pass ();
     else
       fail ("HEADER.DIMLWE [BSd] set+1 " FORMAT_BSd " != " FORMAT_BSd "",
             dwg->header_vars.DIMLWE, dimlwe);
     dimlwe--;
     dwg_dynapi_header_set_value (dwg, "DIMLWE", &dimlwe, 0);
 
   }
   {
     BITCODE_H block_control_object;
     if (dwg_dynapi_header_value (dwg, "BLOCK_CONTROL_OBJECT", &block_control_object, NULL)
         && !memcmp (&block_control_object, &dwg->header_vars.BLOCK_CONTROL_OBJECT, sizeof (dwg->header_vars.BLOCK_CONTROL_OBJECT))
        )
       pass ();
     else
       fail ("HEADER.BLOCK_CONTROL_OBJECT [H]");
   }
   {
     BITCODE_H layer_control_object;
     if (dwg_dynapi_header_value (dwg, "LAYER_CONTROL_OBJECT", &layer_control_object, NULL)
         && !memcmp (&layer_control_object, &dwg->header_vars.LAYER_CONTROL_OBJECT, sizeof (dwg->header_vars.LAYER_CONTROL_OBJECT))
        )
       pass ();
     else
       fail ("HEADER.LAYER_CONTROL_OBJECT [H]");
   }
   {
     BITCODE_H style_control_object;
     if (dwg_dynapi_header_value (dwg, "STYLE_CONTROL_OBJECT", &style_control_object, NULL)
         && !memcmp (&style_control_object, &dwg->header_vars.STYLE_CONTROL_OBJECT, sizeof (dwg->header_vars.STYLE_CONTROL_OBJECT))
        )
       pass ();
     else
       fail ("HEADER.STYLE_CONTROL_OBJECT [H]");
   }
   {
     BITCODE_H ltype_control_object;
     if (dwg_dynapi_header_value (dwg, "LTYPE_CONTROL_OBJECT", &ltype_control_object, NULL)
         && !memcmp (&ltype_control_object, &dwg->header_vars.LTYPE_CONTROL_OBJECT, sizeof (dwg->header_vars.LTYPE_CONTROL_OBJECT))
        )
       pass ();
     else
       fail ("HEADER.LTYPE_CONTROL_OBJECT [H]");
   }
   {
     BITCODE_H view_control_object;
     if (dwg_dynapi_header_value (dwg, "VIEW_CONTROL_OBJECT", &view_control_object, NULL)
         && !memcmp (&view_control_object, &dwg->header_vars.VIEW_CONTROL_OBJECT, sizeof (dwg->header_vars.VIEW_CONTROL_OBJECT))
        )
       pass ();
     else
       fail ("HEADER.VIEW_CONTROL_OBJECT [H]");
   }
   {
     BITCODE_H ucs_control_object;
     if (dwg_dynapi_header_value (dwg, "UCS_CONTROL_OBJECT", &ucs_control_object, NULL)
         && !memcmp (&ucs_control_object, &dwg->header_vars.UCS_CONTROL_OBJECT, sizeof (dwg->header_vars.UCS_CONTROL_OBJECT))
        )
       pass ();
     else
       fail ("HEADER.UCS_CONTROL_OBJECT [H]");
   }
   {
     BITCODE_H vport_control_object;
     if (dwg_dynapi_header_value (dwg, "VPORT_CONTROL_OBJECT", &vport_control_object, NULL)
         && !memcmp (&vport_control_object, &dwg->header_vars.VPORT_CONTROL_OBJECT, sizeof (dwg->header_vars.VPORT_CONTROL_OBJECT))
        )
       pass ();
     else
       fail ("HEADER.VPORT_CONTROL_OBJECT [H]");
   }
   {
     BITCODE_H appid_control_object;
     if (dwg_dynapi_header_value (dwg, "APPID_CONTROL_OBJECT", &appid_control_object, NULL)
         && !memcmp (&appid_control_object, &dwg->header_vars.APPID_CONTROL_OBJECT, sizeof (dwg->header_vars.APPID_CONTROL_OBJECT))
        )
       pass ();
     else
       fail ("HEADER.APPID_CONTROL_OBJECT [H]");
   }
   {
     BITCODE_H dimstyle_control_object;
     if (dwg_dynapi_header_value (dwg, "DIMSTYLE_CONTROL_OBJECT", &dimstyle_control_object, NULL)
         && !memcmp (&dimstyle_control_object, &dwg->header_vars.DIMSTYLE_CONTROL_OBJECT, sizeof (dwg->header_vars.DIMSTYLE_CONTROL_OBJECT))
        )
       pass ();
     else
       fail ("HEADER.DIMSTYLE_CONTROL_OBJECT [H]");
   }
   {
     BITCODE_H vx_control_object;
     if (dwg_dynapi_header_value (dwg, "VX_CONTROL_OBJECT", &vx_control_object, NULL)
         && !memcmp (&vx_control_object, &dwg->header_vars.VX_CONTROL_OBJECT, sizeof (dwg->header_vars.VX_CONTROL_OBJECT))
        )
       pass ();
     else
       fail ("HEADER.VX_CONTROL_OBJECT [H]");
   }
   {
     BITCODE_H dictionary_acad_group;
     if (dwg_dynapi_header_value (dwg, "DICTIONARY_ACAD_GROUP", &dictionary_acad_group, NULL)
         && !memcmp (&dictionary_acad_group, &dwg->header_vars.DICTIONARY_ACAD_GROUP, sizeof (dwg->header_vars.DICTIONARY_ACAD_GROUP))
        )
       pass ();
     else
       fail ("HEADER.DICTIONARY_ACAD_GROUP [H]");
   }
   {
     BITCODE_H dictionary_acad_mlinestyle;
     if (dwg_dynapi_header_value (dwg, "DICTIONARY_ACAD_MLINESTYLE", &dictionary_acad_mlinestyle, NULL)
         && !memcmp (&dictionary_acad_mlinestyle, &dwg->header_vars.DICTIONARY_ACAD_MLINESTYLE, sizeof (dwg->header_vars.DICTIONARY_ACAD_MLINESTYLE))
        )
       pass ();
     else
       fail ("HEADER.DICTIONARY_ACAD_MLINESTYLE [H]");
   }
   {
     BITCODE_H dictionary_named_object;
     if (dwg_dynapi_header_value (dwg, "DICTIONARY_NAMED_OBJECT", &dictionary_named_object, NULL)
         && !memcmp (&dictionary_named_object, &dwg->header_vars.DICTIONARY_NAMED_OBJECT, sizeof (dwg->header_vars.DICTIONARY_NAMED_OBJECT))
        )
       pass ();
     else
       fail ("HEADER.DICTIONARY_NAMED_OBJECT [H]");
   }
   {
     BITCODE_BS tstackalign;
     if (dwg_dynapi_header_value (dwg, "TSTACKALIGN", &tstackalign, NULL)
         && tstackalign == dwg->header_vars.TSTACKALIGN)
       pass ();
     else
       fail ("HEADER.TSTACKALIGN [BS] %hu != %hu", dwg->header_vars.TSTACKALIGN, tstackalign);
     tstackalign++;
     if (dwg_dynapi_header_set_value (dwg, "TSTACKALIGN", &tstackalign, 0)
         && tstackalign == dwg->header_vars.TSTACKALIGN)
       pass ();
     else
       fail ("HEADER.TSTACKALIGN [BS] set+1 %hu != %hu",
             dwg->header_vars.TSTACKALIGN, tstackalign);
     tstackalign--;
     dwg_dynapi_header_set_value (dwg, "TSTACKALIGN", &tstackalign, 0);
 
   }
   {
     BITCODE_BS tstacksize;
     if (dwg_dynapi_header_value (dwg, "TSTACKSIZE", &tstacksize, NULL)
         && tstacksize == dwg->header_vars.TSTACKSIZE)
       pass ();
     else
       fail ("HEADER.TSTACKSIZE [BS] %hu != %hu", dwg->header_vars.TSTACKSIZE, tstacksize);
     tstacksize++;
     if (dwg_dynapi_header_set_value (dwg, "TSTACKSIZE", &tstacksize, 0)
         && tstacksize == dwg->header_vars.TSTACKSIZE)
       pass ();
     else
       fail ("HEADER.TSTACKSIZE [BS] set+1 %hu != %hu",
             dwg->header_vars.TSTACKSIZE, tstacksize);
     tstacksize--;
     dwg_dynapi_header_set_value (dwg, "TSTACKSIZE", &tstacksize, 0);
 
   }
   {
     BITCODE_T hyperlinkbase;
     if (dwg_dynapi_header_value (dwg, "HYPERLINKBASE", &hyperlinkbase, NULL)
         && !memcmp (&hyperlinkbase, &dwg->header_vars.HYPERLINKBASE, sizeof (dwg->header_vars.HYPERLINKBASE))
        )
       pass ();
     else
       fail ("HEADER.HYPERLINKBASE [T]");
   }
   {
     BITCODE_TV stylesheet;
     if (dwg_dynapi_header_value (dwg, "STYLESHEET", &stylesheet, NULL)
         && !memcmp (&stylesheet, &dwg->header_vars.STYLESHEET, sizeof (dwg->header_vars.STYLESHEET))
        )
       pass ();
     else
       fail ("HEADER.STYLESHEET [TV]");
   }
   {
     BITCODE_H dictionary_layout;
     if (dwg_dynapi_header_value (dwg, "DICTIONARY_LAYOUT", &dictionary_layout, NULL)
         && !memcmp (&dictionary_layout, &dwg->header_vars.DICTIONARY_LAYOUT, sizeof (dwg->header_vars.DICTIONARY_LAYOUT))
        )
       pass ();
     else
       fail ("HEADER.DICTIONARY_LAYOUT [H]");
   }
   {
     BITCODE_H dictionary_plotsettings;
     if (dwg_dynapi_header_value (dwg, "DICTIONARY_PLOTSETTINGS", &dictionary_plotsettings, NULL)
         && !memcmp (&dictionary_plotsettings, &dwg->header_vars.DICTIONARY_PLOTSETTINGS, sizeof (dwg->header_vars.DICTIONARY_PLOTSETTINGS))
        )
       pass ();
     else
       fail ("HEADER.DICTIONARY_PLOTSETTINGS [H]");
   }
   {
     BITCODE_H dictionary_plotstylename;
     if (dwg_dynapi_header_value (dwg, "DICTIONARY_PLOTSTYLENAME", &dictionary_plotstylename, NULL)
         && !memcmp (&dictionary_plotstylename, &dwg->header_vars.DICTIONARY_PLOTSTYLENAME, sizeof (dwg->header_vars.DICTIONARY_PLOTSTYLENAME))
        )
       pass ();
     else
       fail ("HEADER.DICTIONARY_PLOTSTYLENAME [H]");
   }
   {
     BITCODE_H dictionary_material;
     if (dwg_dynapi_header_value (dwg, "DICTIONARY_MATERIAL", &dictionary_material, NULL)
         && !memcmp (&dictionary_material, &dwg->header_vars.DICTIONARY_MATERIAL, sizeof (dwg->header_vars.DICTIONARY_MATERIAL))
        )
       pass ();
     else
       fail ("HEADER.DICTIONARY_MATERIAL [H]");
   }
   {
     BITCODE_H dictionary_color;
     if (dwg_dynapi_header_value (dwg, "DICTIONARY_COLOR", &dictionary_color, NULL)
         && !memcmp (&dictionary_color, &dwg->header_vars.DICTIONARY_COLOR, sizeof (dwg->header_vars.DICTIONARY_COLOR))
        )
       pass ();
     else
       fail ("HEADER.DICTIONARY_COLOR [H]");
   }
   {
     BITCODE_H dictionary_visualstyle;
     if (dwg_dynapi_header_value (dwg, "DICTIONARY_VISUALSTYLE", &dictionary_visualstyle, NULL)
         && !memcmp (&dictionary_visualstyle, &dwg->header_vars.DICTIONARY_VISUALSTYLE, sizeof (dwg->header_vars.DICTIONARY_VISUALSTYLE))
        )
       pass ();
     else
       fail ("HEADER.DICTIONARY_VISUALSTYLE [H]");
   }
   {
     BITCODE_H dictionary_lightlist;
     if (dwg_dynapi_header_value (dwg, "DICTIONARY_LIGHTLIST", &dictionary_lightlist, NULL)
         && !memcmp (&dictionary_lightlist, &dwg->header_vars.DICTIONARY_LIGHTLIST, sizeof (dwg->header_vars.DICTIONARY_LIGHTLIST))
        )
       pass ();
     else
       fail ("HEADER.DICTIONARY_LIGHTLIST [H]");
   }
   {
     BITCODE_H unknown_20;
     if (dwg_dynapi_header_value (dwg, "unknown_20", &unknown_20, NULL)
         && !memcmp (&unknown_20, &dwg->header_vars.unknown_20, sizeof (dwg->header_vars.unknown_20))
        )
       pass ();
     else
       fail ("HEADER.unknown_20 [H]");
   }
   {
     BITCODE_BL flags;
     if (dwg_dynapi_header_value (dwg, "FLAGS", &flags, NULL)
         && flags == dwg->header_vars.FLAGS)
       pass ();
     else
       fail ("HEADER.FLAGS [BL] %u != %u", dwg->header_vars.FLAGS, flags);
     flags++;
     if (dwg_dynapi_header_set_value (dwg, "FLAGS", &flags, 0)
         && flags == dwg->header_vars.FLAGS)
       pass ();
     else
       fail ("HEADER.FLAGS [BL] set+1 %u != %u",
             dwg->header_vars.FLAGS, flags);
     flags--;
     dwg_dynapi_header_set_value (dwg, "FLAGS", &flags, 0);
 
   }
   {
     BITCODE_BSd celweight;
     if (dwg_dynapi_header_value (dwg, "CELWEIGHT", &celweight, NULL)
         && celweight == dwg->header_vars.CELWEIGHT)
       pass ();
     else
       fail ("HEADER.CELWEIGHT [BSd] " FORMAT_BSd " != " FORMAT_BSd "", dwg->header_vars.CELWEIGHT, celweight);
     celweight++;
     if (dwg_dynapi_header_set_value (dwg, "CELWEIGHT", &celweight, 0)
         && celweight == dwg->header_vars.CELWEIGHT)
       pass ();
     else
       fail ("HEADER.CELWEIGHT [BSd] set+1 " FORMAT_BSd " != " FORMAT_BSd "",
             dwg->header_vars.CELWEIGHT, celweight);
     celweight--;
     dwg_dynapi_header_set_value (dwg, "CELWEIGHT", &celweight, 0);
 
   }
   {
     BITCODE_B endcaps;
     if (dwg_dynapi_header_value (dwg, "ENDCAPS", &endcaps, NULL)
         && endcaps == dwg->header_vars.ENDCAPS)
       pass ();
     else
       fail ("HEADER.ENDCAPS [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.ENDCAPS, endcaps);
     endcaps++;
     if (dwg_dynapi_header_set_value (dwg, "ENDCAPS", &endcaps, 0)
         && endcaps == dwg->header_vars.ENDCAPS)
       pass ();
     else
       fail ("HEADER.ENDCAPS [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.ENDCAPS, endcaps);
     endcaps--;
     dwg_dynapi_header_set_value (dwg, "ENDCAPS", &endcaps, 0);
 
   }
   {
     BITCODE_B joinstyle;
     if (dwg_dynapi_header_value (dwg, "JOINSTYLE", &joinstyle, NULL)
         && joinstyle == dwg->header_vars.JOINSTYLE)
       pass ();
     else
       fail ("HEADER.JOINSTYLE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.JOINSTYLE, joinstyle);
     joinstyle++;
     if (dwg_dynapi_header_set_value (dwg, "JOINSTYLE", &joinstyle, 0)
         && joinstyle == dwg->header_vars.JOINSTYLE)
       pass ();
     else
       fail ("HEADER.JOINSTYLE [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.JOINSTYLE, joinstyle);
     joinstyle--;
     dwg_dynapi_header_set_value (dwg, "JOINSTYLE", &joinstyle, 0);
 
   }
   {
     BITCODE_B lwdisplay;
     if (dwg_dynapi_header_value (dwg, "LWDISPLAY", &lwdisplay, NULL)
         && lwdisplay == dwg->header_vars.LWDISPLAY)
       pass ();
     else
       fail ("HEADER.LWDISPLAY [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.LWDISPLAY, lwdisplay);
     lwdisplay++;
     if (dwg_dynapi_header_set_value (dwg, "LWDISPLAY", &lwdisplay, 0)
         && lwdisplay == dwg->header_vars.LWDISPLAY)
       pass ();
     else
       fail ("HEADER.LWDISPLAY [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.LWDISPLAY, lwdisplay);
     lwdisplay--;
     dwg_dynapi_header_set_value (dwg, "LWDISPLAY", &lwdisplay, 0);
 
   }
   {
     BITCODE_B xedit;
     if (dwg_dynapi_header_value (dwg, "XEDIT", &xedit, NULL)
         && xedit == dwg->header_vars.XEDIT)
       pass ();
     else
       fail ("HEADER.XEDIT [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.XEDIT, xedit);
     xedit++;
     if (dwg_dynapi_header_set_value (dwg, "XEDIT", &xedit, 0)
         && xedit == dwg->header_vars.XEDIT)
       pass ();
     else
       fail ("HEADER.XEDIT [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.XEDIT, xedit);
     xedit--;
     dwg_dynapi_header_set_value (dwg, "XEDIT", &xedit, 0);
 
   }
   {
     BITCODE_B extnames;
     if (dwg_dynapi_header_value (dwg, "EXTNAMES", &extnames, NULL)
         && extnames == dwg->header_vars.EXTNAMES)
       pass ();
     else
       fail ("HEADER.EXTNAMES [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.EXTNAMES, extnames);
     extnames++;
     if (dwg_dynapi_header_set_value (dwg, "EXTNAMES", &extnames, 0)
         && extnames == dwg->header_vars.EXTNAMES)
       pass ();
     else
       fail ("HEADER.EXTNAMES [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.EXTNAMES, extnames);
     extnames--;
     dwg_dynapi_header_set_value (dwg, "EXTNAMES", &extnames, 0);
 
   }
   {
     BITCODE_B pstylemode;
     if (dwg_dynapi_header_value (dwg, "PSTYLEMODE", &pstylemode, NULL)
         && pstylemode == dwg->header_vars.PSTYLEMODE)
       pass ();
     else
       fail ("HEADER.PSTYLEMODE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.PSTYLEMODE, pstylemode);
     pstylemode++;
     if (dwg_dynapi_header_set_value (dwg, "PSTYLEMODE", &pstylemode, 0)
         && pstylemode == dwg->header_vars.PSTYLEMODE)
       pass ();
     else
       fail ("HEADER.PSTYLEMODE [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.PSTYLEMODE, pstylemode);
     pstylemode--;
     dwg_dynapi_header_set_value (dwg, "PSTYLEMODE", &pstylemode, 0);
 
   }
   {
     BITCODE_B olestartup;
     if (dwg_dynapi_header_value (dwg, "OLESTARTUP", &olestartup, NULL)
         && olestartup == dwg->header_vars.OLESTARTUP)
       pass ();
     else
       fail ("HEADER.OLESTARTUP [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.OLESTARTUP, olestartup);
     olestartup++;
     if (dwg_dynapi_header_set_value (dwg, "OLESTARTUP", &olestartup, 0)
         && olestartup == dwg->header_vars.OLESTARTUP)
       pass ();
     else
       fail ("HEADER.OLESTARTUP [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.OLESTARTUP, olestartup);
     olestartup--;
     dwg_dynapi_header_set_value (dwg, "OLESTARTUP", &olestartup, 0);
 
   }
   {
     BITCODE_BS insunits;
     if (dwg_dynapi_header_value (dwg, "INSUNITS", &insunits, NULL)
         && insunits == dwg->header_vars.INSUNITS)
       pass ();
     else
       fail ("HEADER.INSUNITS [BS] %hu != %hu", dwg->header_vars.INSUNITS, insunits);
     insunits++;
     if (dwg_dynapi_header_set_value (dwg, "INSUNITS", &insunits, 0)
         && insunits == dwg->header_vars.INSUNITS)
       pass ();
     else
       fail ("HEADER.INSUNITS [BS] set+1 %hu != %hu",
             dwg->header_vars.INSUNITS, insunits);
     insunits--;
     dwg_dynapi_header_set_value (dwg, "INSUNITS", &insunits, 0);
 
   }
   {
     BITCODE_BS cepsntype;
     if (dwg_dynapi_header_value (dwg, "CEPSNTYPE", &cepsntype, NULL)
         && cepsntype == dwg->header_vars.CEPSNTYPE)
       pass ();
     else
       fail ("HEADER.CEPSNTYPE [BS] %hu != %hu", dwg->header_vars.CEPSNTYPE, cepsntype);
     cepsntype++;
     if (dwg_dynapi_header_set_value (dwg, "CEPSNTYPE", &cepsntype, 0)
         && cepsntype == dwg->header_vars.CEPSNTYPE)
       pass ();
     else
       fail ("HEADER.CEPSNTYPE [BS] set+1 %hu != %hu",
             dwg->header_vars.CEPSNTYPE, cepsntype);
     cepsntype--;
     dwg_dynapi_header_set_value (dwg, "CEPSNTYPE", &cepsntype, 0);
 
   }
   {
     BITCODE_H cpsnid;
     if (dwg_dynapi_header_value (dwg, "CPSNID", &cpsnid, NULL)
         && !memcmp (&cpsnid, &dwg->header_vars.CPSNID, sizeof (dwg->header_vars.CPSNID))
        )
       pass ();
     else
       fail ("HEADER.CPSNID [H]");
   }
   {
     BITCODE_TV fingerprintguid;
     if (dwg_dynapi_header_value (dwg, "FINGERPRINTGUID", &fingerprintguid, NULL)
         && !memcmp (&fingerprintguid, &dwg->header_vars.FINGERPRINTGUID, sizeof (dwg->header_vars.FINGERPRINTGUID))
        )
       pass ();
     else
       fail ("HEADER.FINGERPRINTGUID [TV]");
   }
   {
     BITCODE_TV versionguid;
     if (dwg_dynapi_header_value (dwg, "VERSIONGUID", &versionguid, NULL)
         && !memcmp (&versionguid, &dwg->header_vars.VERSIONGUID, sizeof (dwg->header_vars.VERSIONGUID))
        )
       pass ();
     else
       fail ("HEADER.VERSIONGUID [TV]");
   }
   {
     BITCODE_RC sortents;
     if (dwg_dynapi_header_value (dwg, "SORTENTS", &sortents, NULL)
         && sortents == dwg->header_vars.SORTENTS)
       pass ();
     else
       fail ("HEADER.SORTENTS [RC] %u != %u", dwg->header_vars.SORTENTS, sortents);
     sortents++;
     if (dwg_dynapi_header_set_value (dwg, "SORTENTS", &sortents, 0)
         && sortents == dwg->header_vars.SORTENTS)
       pass ();
     else
       fail ("HEADER.SORTENTS [RC] set+1 %u != %u",
             dwg->header_vars.SORTENTS, sortents);
     sortents--;
     dwg_dynapi_header_set_value (dwg, "SORTENTS", &sortents, 0);
 
   }
   {
     BITCODE_RC indexctl;
     if (dwg_dynapi_header_value (dwg, "INDEXCTL", &indexctl, NULL)
         && indexctl == dwg->header_vars.INDEXCTL)
       pass ();
     else
       fail ("HEADER.INDEXCTL [RC] %u != %u", dwg->header_vars.INDEXCTL, indexctl);
     indexctl++;
     if (dwg_dynapi_header_set_value (dwg, "INDEXCTL", &indexctl, 0)
         && indexctl == dwg->header_vars.INDEXCTL)
       pass ();
     else
       fail ("HEADER.INDEXCTL [RC] set+1 %u != %u",
             dwg->header_vars.INDEXCTL, indexctl);
     indexctl--;
     dwg_dynapi_header_set_value (dwg, "INDEXCTL", &indexctl, 0);
 
   }
   {
     BITCODE_RC hidetext;
     if (dwg_dynapi_header_value (dwg, "HIDETEXT", &hidetext, NULL)
         && hidetext == dwg->header_vars.HIDETEXT)
       pass ();
     else
       fail ("HEADER.HIDETEXT [RC] %u != %u", dwg->header_vars.HIDETEXT, hidetext);
     hidetext++;
     if (dwg_dynapi_header_set_value (dwg, "HIDETEXT", &hidetext, 0)
         && hidetext == dwg->header_vars.HIDETEXT)
       pass ();
     else
       fail ("HEADER.HIDETEXT [RC] set+1 %u != %u",
             dwg->header_vars.HIDETEXT, hidetext);
     hidetext--;
     dwg_dynapi_header_set_value (dwg, "HIDETEXT", &hidetext, 0);
 
   }
   {
     BITCODE_RC xclipframe;
     if (dwg_dynapi_header_value (dwg, "XCLIPFRAME", &xclipframe, NULL)
         && xclipframe == dwg->header_vars.XCLIPFRAME)
       pass ();
     else
       fail ("HEADER.XCLIPFRAME [RC] %u != %u", dwg->header_vars.XCLIPFRAME, xclipframe);
     xclipframe++;
     if (dwg_dynapi_header_set_value (dwg, "XCLIPFRAME", &xclipframe, 0)
         && xclipframe == dwg->header_vars.XCLIPFRAME)
       pass ();
     else
       fail ("HEADER.XCLIPFRAME [RC] set+1 %u != %u",
             dwg->header_vars.XCLIPFRAME, xclipframe);
     xclipframe--;
     dwg_dynapi_header_set_value (dwg, "XCLIPFRAME", &xclipframe, 0);
 
   }
   {
     BITCODE_RC dimassoc;
     if (dwg_dynapi_header_value (dwg, "DIMASSOC", &dimassoc, NULL)
         && dimassoc == dwg->header_vars.DIMASSOC)
       pass ();
     else
       fail ("HEADER.DIMASSOC [RC] %u != %u", dwg->header_vars.DIMASSOC, dimassoc);
     dimassoc++;
     if (dwg_dynapi_header_set_value (dwg, "DIMASSOC", &dimassoc, 0)
         && dimassoc == dwg->header_vars.DIMASSOC)
       pass ();
     else
       fail ("HEADER.DIMASSOC [RC] set+1 %u != %u",
             dwg->header_vars.DIMASSOC, dimassoc);
     dimassoc--;
     dwg_dynapi_header_set_value (dwg, "DIMASSOC", &dimassoc, 0);
 
   }
   {
     BITCODE_RC halogap;
     if (dwg_dynapi_header_value (dwg, "HALOGAP", &halogap, NULL)
         && halogap == dwg->header_vars.HALOGAP)
       pass ();
     else
       fail ("HEADER.HALOGAP [RC] %u != %u", dwg->header_vars.HALOGAP, halogap);
     halogap++;
     if (dwg_dynapi_header_set_value (dwg, "HALOGAP", &halogap, 0)
         && halogap == dwg->header_vars.HALOGAP)
       pass ();
     else
       fail ("HEADER.HALOGAP [RC] set+1 %u != %u",
             dwg->header_vars.HALOGAP, halogap);
     halogap--;
     dwg_dynapi_header_set_value (dwg, "HALOGAP", &halogap, 0);
 
   }
   {
     BITCODE_BS obscolor;
     if (dwg_dynapi_header_value (dwg, "OBSCOLOR", &obscolor, NULL)
         && obscolor == dwg->header_vars.OBSCOLOR)
       pass ();
     else
       fail ("HEADER.OBSCOLOR [BS] %hu != %hu", dwg->header_vars.OBSCOLOR, obscolor);
     obscolor++;
     if (dwg_dynapi_header_set_value (dwg, "OBSCOLOR", &obscolor, 0)
         && obscolor == dwg->header_vars.OBSCOLOR)
       pass ();
     else
       fail ("HEADER.OBSCOLOR [BS] set+1 %hu != %hu",
             dwg->header_vars.OBSCOLOR, obscolor);
     obscolor--;
     dwg_dynapi_header_set_value (dwg, "OBSCOLOR", &obscolor, 0);
 
   }
   {
     BITCODE_BS intersectioncolor;
     if (dwg_dynapi_header_value (dwg, "INTERSECTIONCOLOR", &intersectioncolor, NULL)
         && intersectioncolor == dwg->header_vars.INTERSECTIONCOLOR)
       pass ();
     else
       fail ("HEADER.INTERSECTIONCOLOR [BS] %hu != %hu", dwg->header_vars.INTERSECTIONCOLOR, intersectioncolor);
     intersectioncolor++;
     if (dwg_dynapi_header_set_value (dwg, "INTERSECTIONCOLOR", &intersectioncolor, 0)
         && intersectioncolor == dwg->header_vars.INTERSECTIONCOLOR)
       pass ();
     else
       fail ("HEADER.INTERSECTIONCOLOR [BS] set+1 %hu != %hu",
             dwg->header_vars.INTERSECTIONCOLOR, intersectioncolor);
     intersectioncolor--;
     dwg_dynapi_header_set_value (dwg, "INTERSECTIONCOLOR", &intersectioncolor, 0);
 
   }
   {
     BITCODE_RC obsltype;
     if (dwg_dynapi_header_value (dwg, "OBSLTYPE", &obsltype, NULL)
         && obsltype == dwg->header_vars.OBSLTYPE)
       pass ();
     else
       fail ("HEADER.OBSLTYPE [RC] %u != %u", dwg->header_vars.OBSLTYPE, obsltype);
     obsltype++;
     if (dwg_dynapi_header_set_value (dwg, "OBSLTYPE", &obsltype, 0)
         && obsltype == dwg->header_vars.OBSLTYPE)
       pass ();
     else
       fail ("HEADER.OBSLTYPE [RC] set+1 %u != %u",
             dwg->header_vars.OBSLTYPE, obsltype);
     obsltype--;
     dwg_dynapi_header_set_value (dwg, "OBSLTYPE", &obsltype, 0);
 
   }
   {
     BITCODE_RC intersectiondisplay;
     if (dwg_dynapi_header_value (dwg, "INTERSECTIONDISPLAY", &intersectiondisplay, NULL)
         && intersectiondisplay == dwg->header_vars.INTERSECTIONDISPLAY)
       pass ();
     else
       fail ("HEADER.INTERSECTIONDISPLAY [RC] %u != %u", dwg->header_vars.INTERSECTIONDISPLAY, intersectiondisplay);
     intersectiondisplay++;
     if (dwg_dynapi_header_set_value (dwg, "INTERSECTIONDISPLAY", &intersectiondisplay, 0)
         && intersectiondisplay == dwg->header_vars.INTERSECTIONDISPLAY)
       pass ();
     else
       fail ("HEADER.INTERSECTIONDISPLAY [RC] set+1 %u != %u",
             dwg->header_vars.INTERSECTIONDISPLAY, intersectiondisplay);
     intersectiondisplay--;
     dwg_dynapi_header_set_value (dwg, "INTERSECTIONDISPLAY", &intersectiondisplay, 0);
 
   }
   {
     BITCODE_TV projectname;
     if (dwg_dynapi_header_value (dwg, "PROJECTNAME", &projectname, NULL)
         && !memcmp (&projectname, &dwg->header_vars.PROJECTNAME, sizeof (dwg->header_vars.PROJECTNAME))
        )
       pass ();
     else
       fail ("HEADER.PROJECTNAME [TV]");
   }
   {
     BITCODE_H block_record_pspace;
     if (dwg_dynapi_header_value (dwg, "BLOCK_RECORD_PSPACE", &block_record_pspace, NULL)
         && !memcmp (&block_record_pspace, &dwg->header_vars.BLOCK_RECORD_PSPACE, sizeof (dwg->header_vars.BLOCK_RECORD_PSPACE))
        )
       pass ();
     else
       fail ("HEADER.BLOCK_RECORD_PSPACE [H]");
   }
   {
     BITCODE_H block_record_mspace;
     if (dwg_dynapi_header_value (dwg, "BLOCK_RECORD_MSPACE", &block_record_mspace, NULL)
         && !memcmp (&block_record_mspace, &dwg->header_vars.BLOCK_RECORD_MSPACE, sizeof (dwg->header_vars.BLOCK_RECORD_MSPACE))
        )
       pass ();
     else
       fail ("HEADER.BLOCK_RECORD_MSPACE [H]");
   }
   {
     BITCODE_H ltype_bylayer;
     if (dwg_dynapi_header_value (dwg, "LTYPE_BYLAYER", &ltype_bylayer, NULL)
         && !memcmp (&ltype_bylayer, &dwg->header_vars.LTYPE_BYLAYER, sizeof (dwg->header_vars.LTYPE_BYLAYER))
        )
       pass ();
     else
       fail ("HEADER.LTYPE_BYLAYER [H]");
   }
   {
     BITCODE_H ltype_byblock;
     if (dwg_dynapi_header_value (dwg, "LTYPE_BYBLOCK", &ltype_byblock, NULL)
         && !memcmp (&ltype_byblock, &dwg->header_vars.LTYPE_BYBLOCK, sizeof (dwg->header_vars.LTYPE_BYBLOCK))
        )
       pass ();
     else
       fail ("HEADER.LTYPE_BYBLOCK [H]");
   }
   {
     BITCODE_H ltype_continuous;
     if (dwg_dynapi_header_value (dwg, "LTYPE_CONTINUOUS", &ltype_continuous, NULL)
         && !memcmp (&ltype_continuous, &dwg->header_vars.LTYPE_CONTINUOUS, sizeof (dwg->header_vars.LTYPE_CONTINUOUS))
        )
       pass ();
     else
       fail ("HEADER.LTYPE_CONTINUOUS [H]");
   }
   {
     BITCODE_B cameradisplay;
     if (dwg_dynapi_header_value (dwg, "CAMERADISPLAY", &cameradisplay, NULL)
         && cameradisplay == dwg->header_vars.CAMERADISPLAY)
       pass ();
     else
       fail ("HEADER.CAMERADISPLAY [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.CAMERADISPLAY, cameradisplay);
     cameradisplay++;
     if (dwg_dynapi_header_set_value (dwg, "CAMERADISPLAY", &cameradisplay, 0)
         && cameradisplay == dwg->header_vars.CAMERADISPLAY)
       pass ();
     else
       fail ("HEADER.CAMERADISPLAY [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.CAMERADISPLAY, cameradisplay);
     cameradisplay--;
     dwg_dynapi_header_set_value (dwg, "CAMERADISPLAY", &cameradisplay, 0);
 
   }
   {
     BITCODE_BL unknown_21;
     if (dwg_dynapi_header_value (dwg, "unknown_21", &unknown_21, NULL)
         && unknown_21 == dwg->header_vars.unknown_21)
       pass ();
     else
       fail ("HEADER.unknown_21 [BL] %u != %u", dwg->header_vars.unknown_21, unknown_21);
     unknown_21++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_21", &unknown_21, 0)
         && unknown_21 == dwg->header_vars.unknown_21)
       pass ();
     else
       fail ("HEADER.unknown_21 [BL] set+1 %u != %u",
             dwg->header_vars.unknown_21, unknown_21);
     unknown_21--;
     dwg_dynapi_header_set_value (dwg, "unknown_21", &unknown_21, 0);
 
   }
   {
     BITCODE_BL unknown_22;
     if (dwg_dynapi_header_value (dwg, "unknown_22", &unknown_22, NULL)
         && unknown_22 == dwg->header_vars.unknown_22)
       pass ();
     else
       fail ("HEADER.unknown_22 [BL] %u != %u", dwg->header_vars.unknown_22, unknown_22);
     unknown_22++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_22", &unknown_22, 0)
         && unknown_22 == dwg->header_vars.unknown_22)
       pass ();
     else
       fail ("HEADER.unknown_22 [BL] set+1 %u != %u",
             dwg->header_vars.unknown_22, unknown_22);
     unknown_22--;
     dwg_dynapi_header_set_value (dwg, "unknown_22", &unknown_22, 0);
 
   }
   {
     BITCODE_BD unknown_23;
     if (dwg_dynapi_header_value (dwg, "unknown_23", &unknown_23, NULL)
         && unknown_23 == dwg->header_vars.unknown_23)
       pass ();
     else
       fail ("HEADER.unknown_23 [BD] %g != %g", dwg->header_vars.unknown_23, unknown_23);
     unknown_23++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_23", &unknown_23, 0)
         && unknown_23 == dwg->header_vars.unknown_23)
       pass ();
     else
       fail ("HEADER.unknown_23 [BD] set+1 %g != %g",
             dwg->header_vars.unknown_23, unknown_23);
     unknown_23--;
     dwg_dynapi_header_set_value (dwg, "unknown_23", &unknown_23, 0);
 
   }
   {
     BITCODE_BD stepspersec;
     if (dwg_dynapi_header_value (dwg, "STEPSPERSEC", &stepspersec, NULL)
         && stepspersec == dwg->header_vars.STEPSPERSEC)
       pass ();
     else
       fail ("HEADER.STEPSPERSEC [BD] %g != %g", dwg->header_vars.STEPSPERSEC, stepspersec);
     stepspersec++;
     if (dwg_dynapi_header_set_value (dwg, "STEPSPERSEC", &stepspersec, 0)
         && stepspersec == dwg->header_vars.STEPSPERSEC)
       pass ();
     else
       fail ("HEADER.STEPSPERSEC [BD] set+1 %g != %g",
             dwg->header_vars.STEPSPERSEC, stepspersec);
     stepspersec--;
     dwg_dynapi_header_set_value (dwg, "STEPSPERSEC", &stepspersec, 0);
 
   }
   {
     BITCODE_BD stepsize;
     if (dwg_dynapi_header_value (dwg, "STEPSIZE", &stepsize, NULL)
         && stepsize == dwg->header_vars.STEPSIZE)
       pass ();
     else
       fail ("HEADER.STEPSIZE [BD] %g != %g", dwg->header_vars.STEPSIZE, stepsize);
     stepsize++;
     if (dwg_dynapi_header_set_value (dwg, "STEPSIZE", &stepsize, 0)
         && stepsize == dwg->header_vars.STEPSIZE)
       pass ();
     else
       fail ("HEADER.STEPSIZE [BD] set+1 %g != %g",
             dwg->header_vars.STEPSIZE, stepsize);
     stepsize--;
     dwg_dynapi_header_set_value (dwg, "STEPSIZE", &stepsize, 0);
 
   }
   {
     BITCODE_BD _3ddwfprec;
     if (dwg_dynapi_header_value (dwg, "_3DDWFPREC", &_3ddwfprec, NULL)
         && _3ddwfprec == dwg->header_vars._3DDWFPREC)
       pass ();
     else
       fail ("HEADER._3DDWFPREC [BD] %g != %g", dwg->header_vars._3DDWFPREC, _3ddwfprec);
     _3ddwfprec++;
     if (dwg_dynapi_header_set_value (dwg, "_3DDWFPREC", &_3ddwfprec, 0)
         && _3ddwfprec == dwg->header_vars._3DDWFPREC)
       pass ();
     else
       fail ("HEADER._3DDWFPREC [BD] set+1 %g != %g",
             dwg->header_vars._3DDWFPREC, _3ddwfprec);
     _3ddwfprec--;
     dwg_dynapi_header_set_value (dwg, "_3DDWFPREC", &_3ddwfprec, 0);
 
   }
   {
     BITCODE_BD lenslength;
     if (dwg_dynapi_header_value (dwg, "LENSLENGTH", &lenslength, NULL)
         && lenslength == dwg->header_vars.LENSLENGTH)
       pass ();
     else
       fail ("HEADER.LENSLENGTH [BD] %g != %g", dwg->header_vars.LENSLENGTH, lenslength);
     lenslength++;
     if (dwg_dynapi_header_set_value (dwg, "LENSLENGTH", &lenslength, 0)
         && lenslength == dwg->header_vars.LENSLENGTH)
       pass ();
     else
       fail ("HEADER.LENSLENGTH [BD] set+1 %g != %g",
             dwg->header_vars.LENSLENGTH, lenslength);
     lenslength--;
     dwg_dynapi_header_set_value (dwg, "LENSLENGTH", &lenslength, 0);
 
   }
   {
     BITCODE_BD cameraheight;
     if (dwg_dynapi_header_value (dwg, "CAMERAHEIGHT", &cameraheight, NULL)
         && cameraheight == dwg->header_vars.CAMERAHEIGHT)
       pass ();
     else
       fail ("HEADER.CAMERAHEIGHT [BD] %g != %g", dwg->header_vars.CAMERAHEIGHT, cameraheight);
     cameraheight++;
     if (dwg_dynapi_header_set_value (dwg, "CAMERAHEIGHT", &cameraheight, 0)
         && cameraheight == dwg->header_vars.CAMERAHEIGHT)
       pass ();
     else
       fail ("HEADER.CAMERAHEIGHT [BD] set+1 %g != %g",
             dwg->header_vars.CAMERAHEIGHT, cameraheight);
     cameraheight--;
     dwg_dynapi_header_set_value (dwg, "CAMERAHEIGHT", &cameraheight, 0);
 
   }
   {
     BITCODE_RC solidhist;
     if (dwg_dynapi_header_value (dwg, "SOLIDHIST", &solidhist, NULL)
         && solidhist == dwg->header_vars.SOLIDHIST)
       pass ();
     else
       fail ("HEADER.SOLIDHIST [RC] %u != %u", dwg->header_vars.SOLIDHIST, solidhist);
     solidhist++;
     if (dwg_dynapi_header_set_value (dwg, "SOLIDHIST", &solidhist, 0)
         && solidhist == dwg->header_vars.SOLIDHIST)
       pass ();
     else
       fail ("HEADER.SOLIDHIST [RC] set+1 %u != %u",
             dwg->header_vars.SOLIDHIST, solidhist);
     solidhist--;
     dwg_dynapi_header_set_value (dwg, "SOLIDHIST", &solidhist, 0);
 
   }
   {
     BITCODE_RC showhist;
     if (dwg_dynapi_header_value (dwg, "SHOWHIST", &showhist, NULL)
         && showhist == dwg->header_vars.SHOWHIST)
       pass ();
     else
       fail ("HEADER.SHOWHIST [RC] %u != %u", dwg->header_vars.SHOWHIST, showhist);
     showhist++;
     if (dwg_dynapi_header_set_value (dwg, "SHOWHIST", &showhist, 0)
         && showhist == dwg->header_vars.SHOWHIST)
       pass ();
     else
       fail ("HEADER.SHOWHIST [RC] set+1 %u != %u",
             dwg->header_vars.SHOWHIST, showhist);
     showhist--;
     dwg_dynapi_header_set_value (dwg, "SHOWHIST", &showhist, 0);
 
   }
   {
     BITCODE_BD psolwidth;
     if (dwg_dynapi_header_value (dwg, "PSOLWIDTH", &psolwidth, NULL)
         && psolwidth == dwg->header_vars.PSOLWIDTH)
       pass ();
     else
       fail ("HEADER.PSOLWIDTH [BD] %g != %g", dwg->header_vars.PSOLWIDTH, psolwidth);
     psolwidth++;
     if (dwg_dynapi_header_set_value (dwg, "PSOLWIDTH", &psolwidth, 0)
         && psolwidth == dwg->header_vars.PSOLWIDTH)
       pass ();
     else
       fail ("HEADER.PSOLWIDTH [BD] set+1 %g != %g",
             dwg->header_vars.PSOLWIDTH, psolwidth);
     psolwidth--;
     dwg_dynapi_header_set_value (dwg, "PSOLWIDTH", &psolwidth, 0);
 
   }
   {
     BITCODE_BD psolheight;
     if (dwg_dynapi_header_value (dwg, "PSOLHEIGHT", &psolheight, NULL)
         && psolheight == dwg->header_vars.PSOLHEIGHT)
       pass ();
     else
       fail ("HEADER.PSOLHEIGHT [BD] %g != %g", dwg->header_vars.PSOLHEIGHT, psolheight);
     psolheight++;
     if (dwg_dynapi_header_set_value (dwg, "PSOLHEIGHT", &psolheight, 0)
         && psolheight == dwg->header_vars.PSOLHEIGHT)
       pass ();
     else
       fail ("HEADER.PSOLHEIGHT [BD] set+1 %g != %g",
             dwg->header_vars.PSOLHEIGHT, psolheight);
     psolheight--;
     dwg_dynapi_header_set_value (dwg, "PSOLHEIGHT", &psolheight, 0);
 
   }
   {
     BITCODE_BD loftang1;
     if (dwg_dynapi_header_value (dwg, "LOFTANG1", &loftang1, NULL)
         && loftang1 == dwg->header_vars.LOFTANG1)
       pass ();
     else
       fail ("HEADER.LOFTANG1 [BD] %g != %g", dwg->header_vars.LOFTANG1, loftang1);
     loftang1++;
     if (dwg_dynapi_header_set_value (dwg, "LOFTANG1", &loftang1, 0)
         && loftang1 == dwg->header_vars.LOFTANG1)
       pass ();
     else
       fail ("HEADER.LOFTANG1 [BD] set+1 %g != %g",
             dwg->header_vars.LOFTANG1, loftang1);
     loftang1--;
     dwg_dynapi_header_set_value (dwg, "LOFTANG1", &loftang1, 0);
 
   }
   {
     BITCODE_BD loftang2;
     if (dwg_dynapi_header_value (dwg, "LOFTANG2", &loftang2, NULL)
         && loftang2 == dwg->header_vars.LOFTANG2)
       pass ();
     else
       fail ("HEADER.LOFTANG2 [BD] %g != %g", dwg->header_vars.LOFTANG2, loftang2);
     loftang2++;
     if (dwg_dynapi_header_set_value (dwg, "LOFTANG2", &loftang2, 0)
         && loftang2 == dwg->header_vars.LOFTANG2)
       pass ();
     else
       fail ("HEADER.LOFTANG2 [BD] set+1 %g != %g",
             dwg->header_vars.LOFTANG2, loftang2);
     loftang2--;
     dwg_dynapi_header_set_value (dwg, "LOFTANG2", &loftang2, 0);
 
   }
   {
     BITCODE_BD loftmag1;
     if (dwg_dynapi_header_value (dwg, "LOFTMAG1", &loftmag1, NULL)
         && loftmag1 == dwg->header_vars.LOFTMAG1)
       pass ();
     else
       fail ("HEADER.LOFTMAG1 [BD] %g != %g", dwg->header_vars.LOFTMAG1, loftmag1);
     loftmag1++;
     if (dwg_dynapi_header_set_value (dwg, "LOFTMAG1", &loftmag1, 0)
         && loftmag1 == dwg->header_vars.LOFTMAG1)
       pass ();
     else
       fail ("HEADER.LOFTMAG1 [BD] set+1 %g != %g",
             dwg->header_vars.LOFTMAG1, loftmag1);
     loftmag1--;
     dwg_dynapi_header_set_value (dwg, "LOFTMAG1", &loftmag1, 0);
 
   }
   {
     BITCODE_BD loftmag2;
     if (dwg_dynapi_header_value (dwg, "LOFTMAG2", &loftmag2, NULL)
         && loftmag2 == dwg->header_vars.LOFTMAG2)
       pass ();
     else
       fail ("HEADER.LOFTMAG2 [BD] %g != %g", dwg->header_vars.LOFTMAG2, loftmag2);
     loftmag2++;
     if (dwg_dynapi_header_set_value (dwg, "LOFTMAG2", &loftmag2, 0)
         && loftmag2 == dwg->header_vars.LOFTMAG2)
       pass ();
     else
       fail ("HEADER.LOFTMAG2 [BD] set+1 %g != %g",
             dwg->header_vars.LOFTMAG2, loftmag2);
     loftmag2--;
     dwg_dynapi_header_set_value (dwg, "LOFTMAG2", &loftmag2, 0);
 
   }
   {
     BITCODE_BS loftparam;
     if (dwg_dynapi_header_value (dwg, "LOFTPARAM", &loftparam, NULL)
         && loftparam == dwg->header_vars.LOFTPARAM)
       pass ();
     else
       fail ("HEADER.LOFTPARAM [BS] %hu != %hu", dwg->header_vars.LOFTPARAM, loftparam);
     loftparam++;
     if (dwg_dynapi_header_set_value (dwg, "LOFTPARAM", &loftparam, 0)
         && loftparam == dwg->header_vars.LOFTPARAM)
       pass ();
     else
       fail ("HEADER.LOFTPARAM [BS] set+1 %hu != %hu",
             dwg->header_vars.LOFTPARAM, loftparam);
     loftparam--;
     dwg_dynapi_header_set_value (dwg, "LOFTPARAM", &loftparam, 0);
 
   }
   {
     BITCODE_RC loftnormals;
     if (dwg_dynapi_header_value (dwg, "LOFTNORMALS", &loftnormals, NULL)
         && loftnormals == dwg->header_vars.LOFTNORMALS)
       pass ();
     else
       fail ("HEADER.LOFTNORMALS [RC] %u != %u", dwg->header_vars.LOFTNORMALS, loftnormals);
     loftnormals++;
     if (dwg_dynapi_header_set_value (dwg, "LOFTNORMALS", &loftnormals, 0)
         && loftnormals == dwg->header_vars.LOFTNORMALS)
       pass ();
     else
       fail ("HEADER.LOFTNORMALS [RC] set+1 %u != %u",
             dwg->header_vars.LOFTNORMALS, loftnormals);
     loftnormals--;
     dwg_dynapi_header_set_value (dwg, "LOFTNORMALS", &loftnormals, 0);
 
   }
   {
     BITCODE_BD latitude;
     if (dwg_dynapi_header_value (dwg, "LATITUDE", &latitude, NULL)
         && latitude == dwg->header_vars.LATITUDE)
       pass ();
     else
       fail ("HEADER.LATITUDE [BD] %g != %g", dwg->header_vars.LATITUDE, latitude);
     latitude++;
     if (dwg_dynapi_header_set_value (dwg, "LATITUDE", &latitude, 0)
         && latitude == dwg->header_vars.LATITUDE)
       pass ();
     else
       fail ("HEADER.LATITUDE [BD] set+1 %g != %g",
             dwg->header_vars.LATITUDE, latitude);
     latitude--;
     dwg_dynapi_header_set_value (dwg, "LATITUDE", &latitude, 0);
 
   }
   {
     BITCODE_BD longitude;
     if (dwg_dynapi_header_value (dwg, "LONGITUDE", &longitude, NULL)
         && longitude == dwg->header_vars.LONGITUDE)
       pass ();
     else
       fail ("HEADER.LONGITUDE [BD] %g != %g", dwg->header_vars.LONGITUDE, longitude);
     longitude++;
     if (dwg_dynapi_header_set_value (dwg, "LONGITUDE", &longitude, 0)
         && longitude == dwg->header_vars.LONGITUDE)
       pass ();
     else
       fail ("HEADER.LONGITUDE [BD] set+1 %g != %g",
             dwg->header_vars.LONGITUDE, longitude);
     longitude--;
     dwg_dynapi_header_set_value (dwg, "LONGITUDE", &longitude, 0);
 
   }
   {
     BITCODE_BD northdirection;
     if (dwg_dynapi_header_value (dwg, "NORTHDIRECTION", &northdirection, NULL)
         && northdirection == dwg->header_vars.NORTHDIRECTION)
       pass ();
     else
       fail ("HEADER.NORTHDIRECTION [BD] %g != %g", dwg->header_vars.NORTHDIRECTION, northdirection);
     northdirection++;
     if (dwg_dynapi_header_set_value (dwg, "NORTHDIRECTION", &northdirection, 0)
         && northdirection == dwg->header_vars.NORTHDIRECTION)
       pass ();
     else
       fail ("HEADER.NORTHDIRECTION [BD] set+1 %g != %g",
             dwg->header_vars.NORTHDIRECTION, northdirection);
     northdirection--;
     dwg_dynapi_header_set_value (dwg, "NORTHDIRECTION", &northdirection, 0);
 
   }
   {
     BITCODE_BL timezn;
     if (dwg_dynapi_header_value (dwg, "TIMEZONE", &timezn, NULL)
         && timezn == dwg->header_vars.TIMEZONE)
       pass ();
     else
       fail ("HEADER.TIMEZONE [BL] %u != %u", dwg->header_vars.TIMEZONE, timezn);
     timezn++;
     if (dwg_dynapi_header_set_value (dwg, "TIMEZONE", &timezn, 0)
         && timezn == dwg->header_vars.TIMEZONE)
       pass ();
     else
       fail ("HEADER.TIMEZONE [BL] set+1 %u != %u",
             dwg->header_vars.TIMEZONE, timezn);
     timezn--;
     dwg_dynapi_header_set_value (dwg, "TIMEZONE", &timezn, 0);
 
   }
   {
     BITCODE_RC lightglyphdisplay;
     if (dwg_dynapi_header_value (dwg, "LIGHTGLYPHDISPLAY", &lightglyphdisplay, NULL)
         && lightglyphdisplay == dwg->header_vars.LIGHTGLYPHDISPLAY)
       pass ();
     else
       fail ("HEADER.LIGHTGLYPHDISPLAY [RC] %u != %u", dwg->header_vars.LIGHTGLYPHDISPLAY, lightglyphdisplay);
     lightglyphdisplay++;
     if (dwg_dynapi_header_set_value (dwg, "LIGHTGLYPHDISPLAY", &lightglyphdisplay, 0)
         && lightglyphdisplay == dwg->header_vars.LIGHTGLYPHDISPLAY)
       pass ();
     else
       fail ("HEADER.LIGHTGLYPHDISPLAY [RC] set+1 %u != %u",
             dwg->header_vars.LIGHTGLYPHDISPLAY, lightglyphdisplay);
     lightglyphdisplay--;
     dwg_dynapi_header_set_value (dwg, "LIGHTGLYPHDISPLAY", &lightglyphdisplay, 0);
 
   }
   {
     BITCODE_RC tilemodelightsynch;
     if (dwg_dynapi_header_value (dwg, "TILEMODELIGHTSYNCH", &tilemodelightsynch, NULL)
         && tilemodelightsynch == dwg->header_vars.TILEMODELIGHTSYNCH)
       pass ();
     else
       fail ("HEADER.TILEMODELIGHTSYNCH [RC] %u != %u", dwg->header_vars.TILEMODELIGHTSYNCH, tilemodelightsynch);
     tilemodelightsynch++;
     if (dwg_dynapi_header_set_value (dwg, "TILEMODELIGHTSYNCH", &tilemodelightsynch, 0)
         && tilemodelightsynch == dwg->header_vars.TILEMODELIGHTSYNCH)
       pass ();
     else
       fail ("HEADER.TILEMODELIGHTSYNCH [RC] set+1 %u != %u",
             dwg->header_vars.TILEMODELIGHTSYNCH, tilemodelightsynch);
     tilemodelightsynch--;
     dwg_dynapi_header_set_value (dwg, "TILEMODELIGHTSYNCH", &tilemodelightsynch, 0);
 
   }
   {
     BITCODE_RC dwfframe;
     if (dwg_dynapi_header_value (dwg, "DWFFRAME", &dwfframe, NULL)
         && dwfframe == dwg->header_vars.DWFFRAME)
       pass ();
     else
       fail ("HEADER.DWFFRAME [RC] %u != %u", dwg->header_vars.DWFFRAME, dwfframe);
     dwfframe++;
     if (dwg_dynapi_header_set_value (dwg, "DWFFRAME", &dwfframe, 0)
         && dwfframe == dwg->header_vars.DWFFRAME)
       pass ();
     else
       fail ("HEADER.DWFFRAME [RC] set+1 %u != %u",
             dwg->header_vars.DWFFRAME, dwfframe);
     dwfframe--;
     dwg_dynapi_header_set_value (dwg, "DWFFRAME", &dwfframe, 0);
 
   }
   {
     BITCODE_RC dgnframe;
     if (dwg_dynapi_header_value (dwg, "DGNFRAME", &dgnframe, NULL)
         && dgnframe == dwg->header_vars.DGNFRAME)
       pass ();
     else
       fail ("HEADER.DGNFRAME [RC] %u != %u", dwg->header_vars.DGNFRAME, dgnframe);
     dgnframe++;
     if (dwg_dynapi_header_set_value (dwg, "DGNFRAME", &dgnframe, 0)
         && dgnframe == dwg->header_vars.DGNFRAME)
       pass ();
     else
       fail ("HEADER.DGNFRAME [RC] set+1 %u != %u",
             dwg->header_vars.DGNFRAME, dgnframe);
     dgnframe--;
     dwg_dynapi_header_set_value (dwg, "DGNFRAME", &dgnframe, 0);
 
   }
   {
     BITCODE_B realworldscale;
     if (dwg_dynapi_header_value (dwg, "REALWORLDSCALE", &realworldscale, NULL)
         && realworldscale == dwg->header_vars.REALWORLDSCALE)
       pass ();
     else
       fail ("HEADER.REALWORLDSCALE [B] " FORMAT_B " != " FORMAT_B "", dwg->header_vars.REALWORLDSCALE, realworldscale);
     realworldscale++;
     if (dwg_dynapi_header_set_value (dwg, "REALWORLDSCALE", &realworldscale, 0)
         && realworldscale == dwg->header_vars.REALWORLDSCALE)
       pass ();
     else
       fail ("HEADER.REALWORLDSCALE [B] set+1 " FORMAT_B " != " FORMAT_B "",
             dwg->header_vars.REALWORLDSCALE, realworldscale);
     realworldscale--;
     dwg_dynapi_header_set_value (dwg, "REALWORLDSCALE", &realworldscale, 0);
 
   }
   {
     BITCODE_CMC interferecolor;
     if (dwg_dynapi_header_value (dwg, "INTERFERECOLOR", &interferecolor, NULL)
         && !memcmp (&interferecolor, &dwg->header_vars.INTERFERECOLOR, sizeof (dwg->header_vars.INTERFERECOLOR))
        )
       pass ();
     else
       fail ("HEADER.INTERFERECOLOR [CMC]");
   }
   {
     BITCODE_H interfereobjvs;
     if (dwg_dynapi_header_value (dwg, "INTERFEREOBJVS", &interfereobjvs, NULL)
         && !memcmp (&interfereobjvs, &dwg->header_vars.INTERFEREOBJVS, sizeof (dwg->header_vars.INTERFEREOBJVS))
        )
       pass ();
     else
       fail ("HEADER.INTERFEREOBJVS [H]");
   }
   {
     BITCODE_H interferevpvs;
     if (dwg_dynapi_header_value (dwg, "INTERFEREVPVS", &interferevpvs, NULL)
         && !memcmp (&interferevpvs, &dwg->header_vars.INTERFEREVPVS, sizeof (dwg->header_vars.INTERFEREVPVS))
        )
       pass ();
     else
       fail ("HEADER.INTERFEREVPVS [H]");
   }
   {
     BITCODE_H dragvs;
     if (dwg_dynapi_header_value (dwg, "DRAGVS", &dragvs, NULL)
         && !memcmp (&dragvs, &dwg->header_vars.DRAGVS, sizeof (dwg->header_vars.DRAGVS))
        )
       pass ();
     else
       fail ("HEADER.DRAGVS [H]");
   }
   {
     BITCODE_RC cshadow;
     if (dwg_dynapi_header_value (dwg, "CSHADOW", &cshadow, NULL)
         && cshadow == dwg->header_vars.CSHADOW)
       pass ();
     else
       fail ("HEADER.CSHADOW [RC] %u != %u", dwg->header_vars.CSHADOW, cshadow);
     cshadow++;
     if (dwg_dynapi_header_set_value (dwg, "CSHADOW", &cshadow, 0)
         && cshadow == dwg->header_vars.CSHADOW)
       pass ();
     else
       fail ("HEADER.CSHADOW [RC] set+1 %u != %u",
             dwg->header_vars.CSHADOW, cshadow);
     cshadow--;
     dwg_dynapi_header_set_value (dwg, "CSHADOW", &cshadow, 0);
 
   }
   {
     BITCODE_BD shadowplanelocation;
     if (dwg_dynapi_header_value (dwg, "SHADOWPLANELOCATION", &shadowplanelocation, NULL)
         && shadowplanelocation == dwg->header_vars.SHADOWPLANELOCATION)
       pass ();
     else
       fail ("HEADER.SHADOWPLANELOCATION [BD] %g != %g", dwg->header_vars.SHADOWPLANELOCATION, shadowplanelocation);
     shadowplanelocation++;
     if (dwg_dynapi_header_set_value (dwg, "SHADOWPLANELOCATION", &shadowplanelocation, 0)
         && shadowplanelocation == dwg->header_vars.SHADOWPLANELOCATION)
       pass ();
     else
       fail ("HEADER.SHADOWPLANELOCATION [BD] set+1 %g != %g",
             dwg->header_vars.SHADOWPLANELOCATION, shadowplanelocation);
     shadowplanelocation--;
     dwg_dynapi_header_set_value (dwg, "SHADOWPLANELOCATION", &shadowplanelocation, 0);
 
   }
   {
     BITCODE_BS unknown_54;
     if (dwg_dynapi_header_value (dwg, "unknown_54", &unknown_54, NULL)
         && unknown_54 == dwg->header_vars.unknown_54)
       pass ();
     else
       fail ("HEADER.unknown_54 [BS] %hu != %hu", dwg->header_vars.unknown_54, unknown_54);
     unknown_54++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_54", &unknown_54, 0)
         && unknown_54 == dwg->header_vars.unknown_54)
       pass ();
     else
       fail ("HEADER.unknown_54 [BS] set+1 %hu != %hu",
             dwg->header_vars.unknown_54, unknown_54);
     unknown_54--;
     dwg_dynapi_header_set_value (dwg, "unknown_54", &unknown_54, 0);
 
   }
   {
     BITCODE_BS unknown_55;
     if (dwg_dynapi_header_value (dwg, "unknown_55", &unknown_55, NULL)
         && unknown_55 == dwg->header_vars.unknown_55)
       pass ();
     else
       fail ("HEADER.unknown_55 [BS] %hu != %hu", dwg->header_vars.unknown_55, unknown_55);
     unknown_55++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_55", &unknown_55, 0)
         && unknown_55 == dwg->header_vars.unknown_55)
       pass ();
     else
       fail ("HEADER.unknown_55 [BS] set+1 %hu != %hu",
             dwg->header_vars.unknown_55, unknown_55);
     unknown_55--;
     dwg_dynapi_header_set_value (dwg, "unknown_55", &unknown_55, 0);
 
   }
   {
     BITCODE_BS unknown_56;
     if (dwg_dynapi_header_value (dwg, "unknown_56", &unknown_56, NULL)
         && unknown_56 == dwg->header_vars.unknown_56)
       pass ();
     else
       fail ("HEADER.unknown_56 [BS] %hu != %hu", dwg->header_vars.unknown_56, unknown_56);
     unknown_56++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_56", &unknown_56, 0)
         && unknown_56 == dwg->header_vars.unknown_56)
       pass ();
     else
       fail ("HEADER.unknown_56 [BS] set+1 %hu != %hu",
             dwg->header_vars.unknown_56, unknown_56);
     unknown_56--;
     dwg_dynapi_header_set_value (dwg, "unknown_56", &unknown_56, 0);
 
   }
   {
     BITCODE_BS unknown_57;
     if (dwg_dynapi_header_value (dwg, "unknown_57", &unknown_57, NULL)
         && unknown_57 == dwg->header_vars.unknown_57)
       pass ();
     else
       fail ("HEADER.unknown_57 [BS] %hu != %hu", dwg->header_vars.unknown_57, unknown_57);
     unknown_57++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_57", &unknown_57, 0)
         && unknown_57 == dwg->header_vars.unknown_57)
       pass ();
     else
       fail ("HEADER.unknown_57 [BS] set+1 %hu != %hu",
             dwg->header_vars.unknown_57, unknown_57);
     unknown_57--;
     dwg_dynapi_header_set_value (dwg, "unknown_57", &unknown_57, 0);
 
   }
   {
     BITCODE_RL dwg_size;
     if (dwg_dynapi_header_value (dwg, "dwg_size", &dwg_size, NULL)
         && dwg_size == dwg->header_vars.dwg_size)
       pass ();
     else
       fail ("HEADER.dwg_size [RL] %u != %u", dwg->header_vars.dwg_size, dwg_size);
     dwg_size++;
     if (dwg_dynapi_header_set_value (dwg, "dwg_size", &dwg_size, 0)
         && dwg_size == dwg->header_vars.dwg_size)
       pass ();
     else
       fail ("HEADER.dwg_size [RL] set+1 %u != %u",
             dwg->header_vars.dwg_size, dwg_size);
     dwg_size--;
     dwg_dynapi_header_set_value (dwg, "dwg_size", &dwg_size, 0);
 
   }
   {
     BITCODE_RS numentities;
     if (dwg_dynapi_header_value (dwg, "numentities", &numentities, NULL)
         && numentities == dwg->header_vars.numentities)
       pass ();
     else
       fail ("HEADER.numentities [RS] %hu != %hu", dwg->header_vars.numentities, numentities);
     numentities++;
     if (dwg_dynapi_header_set_value (dwg, "numentities", &numentities, 0)
         && numentities == dwg->header_vars.numentities)
       pass ();
     else
       fail ("HEADER.numentities [RS] set+1 %hu != %hu",
             dwg->header_vars.numentities, numentities);
     numentities--;
     dwg_dynapi_header_set_value (dwg, "numentities", &numentities, 0);
 
   }
   {
     BITCODE_RS circle_zoom_percent;
     if (dwg_dynapi_header_value (dwg, "circle_zoom_percent", &circle_zoom_percent, NULL)
         && circle_zoom_percent == dwg->header_vars.circle_zoom_percent)
       pass ();
     else
       fail ("HEADER.circle_zoom_percent [RS] %hu != %hu", dwg->header_vars.circle_zoom_percent, circle_zoom_percent);
     circle_zoom_percent++;
     if (dwg_dynapi_header_set_value (dwg, "circle_zoom_percent", &circle_zoom_percent, 0)
         && circle_zoom_percent == dwg->header_vars.circle_zoom_percent)
       pass ();
     else
       fail ("HEADER.circle_zoom_percent [RS] set+1 %hu != %hu",
             dwg->header_vars.circle_zoom_percent, circle_zoom_percent);
     circle_zoom_percent--;
     dwg_dynapi_header_set_value (dwg, "circle_zoom_percent", &circle_zoom_percent, 0);
 
   }
   {
     BITCODE_BD frontz;
     if (dwg_dynapi_header_value (dwg, "FRONTZ", &frontz, NULL)
         && frontz == dwg->header_vars.FRONTZ)
       pass ();
     else
       fail ("HEADER.FRONTZ [BD] %g != %g", dwg->header_vars.FRONTZ, frontz);
     frontz++;
     if (dwg_dynapi_header_set_value (dwg, "FRONTZ", &frontz, 0)
         && frontz == dwg->header_vars.FRONTZ)
       pass ();
     else
       fail ("HEADER.FRONTZ [BD] set+1 %g != %g",
             dwg->header_vars.FRONTZ, frontz);
     frontz--;
     dwg_dynapi_header_set_value (dwg, "FRONTZ", &frontz, 0);
 
   }
   {
     BITCODE_BD backz;
     if (dwg_dynapi_header_value (dwg, "BACKZ", &backz, NULL)
         && backz == dwg->header_vars.BACKZ)
       pass ();
     else
       fail ("HEADER.BACKZ [BD] %g != %g", dwg->header_vars.BACKZ, backz);
     backz++;
     if (dwg_dynapi_header_set_value (dwg, "BACKZ", &backz, 0)
         && backz == dwg->header_vars.BACKZ)
       pass ();
     else
       fail ("HEADER.BACKZ [BD] set+1 %g != %g",
             dwg->header_vars.BACKZ, backz);
     backz--;
     dwg_dynapi_header_set_value (dwg, "BACKZ", &backz, 0);
 
   }
   {
     BITCODE_RC ucsicon;
     if (dwg_dynapi_header_value (dwg, "UCSICON", &ucsicon, NULL)
         && ucsicon == dwg->header_vars.UCSICON)
       pass ();
     else
       fail ("HEADER.UCSICON [RC] %u != %u", dwg->header_vars.UCSICON, ucsicon);
     ucsicon++;
     if (dwg_dynapi_header_set_value (dwg, "UCSICON", &ucsicon, 0)
         && ucsicon == dwg->header_vars.UCSICON)
       pass ();
     else
       fail ("HEADER.UCSICON [RC] set+1 %u != %u",
             dwg->header_vars.UCSICON, ucsicon);
     ucsicon--;
     dwg_dynapi_header_set_value (dwg, "UCSICON", &ucsicon, 0);
 
   }
   {
     BITCODE_RL oldcecolor_hi;
     if (dwg_dynapi_header_value (dwg, "oldCECOLOR_hi", &oldcecolor_hi, NULL)
         && oldcecolor_hi == dwg->header_vars.oldCECOLOR_hi)
       pass ();
     else
       fail ("HEADER.oldCECOLOR_hi [RL] %u != %u", dwg->header_vars.oldCECOLOR_hi, oldcecolor_hi);
     oldcecolor_hi++;
     if (dwg_dynapi_header_set_value (dwg, "oldCECOLOR_hi", &oldcecolor_hi, 0)
         && oldcecolor_hi == dwg->header_vars.oldCECOLOR_hi)
       pass ();
     else
       fail ("HEADER.oldCECOLOR_hi [RL] set+1 %u != %u",
             dwg->header_vars.oldCECOLOR_hi, oldcecolor_hi);
     oldcecolor_hi--;
     dwg_dynapi_header_set_value (dwg, "oldCECOLOR_hi", &oldcecolor_hi, 0);
 
   }
   {
     BITCODE_RL oldcecolor_lo;
     if (dwg_dynapi_header_value (dwg, "oldCECOLOR_lo", &oldcecolor_lo, NULL)
         && oldcecolor_lo == dwg->header_vars.oldCECOLOR_lo)
       pass ();
     else
       fail ("HEADER.oldCECOLOR_lo [RL] %u != %u", dwg->header_vars.oldCECOLOR_lo, oldcecolor_lo);
     oldcecolor_lo++;
     if (dwg_dynapi_header_set_value (dwg, "oldCECOLOR_lo", &oldcecolor_lo, 0)
         && oldcecolor_lo == dwg->header_vars.oldCECOLOR_lo)
       pass ();
     else
       fail ("HEADER.oldCECOLOR_lo [RL] set+1 %u != %u",
             dwg->header_vars.oldCECOLOR_lo, oldcecolor_lo);
     oldcecolor_lo--;
     dwg_dynapi_header_set_value (dwg, "oldCECOLOR_lo", &oldcecolor_lo, 0);
 
   }
   {
     BITCODE_RS layer_colors[128];
-    if (dwg_dynapi_header_value (dwg, "layer_colors[128]", &layer_colors, NULL)
+    if (dwg_dynapi_header_value (dwg, "layer_colors", &layer_colors, NULL)
         && !memcmp (&layer_colors, &dwg->header_vars.layer_colors, sizeof (dwg->header_vars.layer_colors))
        )
       pass ();
     else
       fail ("HEADER.layer_colors[128] [RS]");
   }
   {
     BITCODE_RS unknown_51e;
     if (dwg_dynapi_header_value (dwg, "unknown_51e", &unknown_51e, NULL)
         && unknown_51e == dwg->header_vars.unknown_51e)
       pass ();
     else
       fail ("HEADER.unknown_51e [RS] %hu != %hu", dwg->header_vars.unknown_51e, unknown_51e);
     unknown_51e++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_51e", &unknown_51e, 0)
         && unknown_51e == dwg->header_vars.unknown_51e)
       pass ();
     else
       fail ("HEADER.unknown_51e [RS] set+1 %hu != %hu",
             dwg->header_vars.unknown_51e, unknown_51e);
     unknown_51e--;
     dwg_dynapi_header_set_value (dwg, "unknown_51e", &unknown_51e, 0);
 
   }
   {
     BITCODE_RS unknown_520;
     if (dwg_dynapi_header_value (dwg, "unknown_520", &unknown_520, NULL)
         && unknown_520 == dwg->header_vars.unknown_520)
       pass ();
     else
       fail ("HEADER.unknown_520 [RS] %hu != %hu", dwg->header_vars.unknown_520, unknown_520);
     unknown_520++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_520", &unknown_520, 0)
         && unknown_520 == dwg->header_vars.unknown_520)
       pass ();
     else
       fail ("HEADER.unknown_520 [RS] set+1 %hu != %hu",
             dwg->header_vars.unknown_520, unknown_520);
     unknown_520--;
     dwg_dynapi_header_set_value (dwg, "unknown_520", &unknown_520, 0);
 
   }
   {
     BITCODE_RSd unknown_52c;
     if (dwg_dynapi_header_value (dwg, "unknown_52c", &unknown_52c, NULL)
         && unknown_52c == dwg->header_vars.unknown_52c)
       pass ();
     else
       fail ("HEADER.unknown_52c [RSd] " FORMAT_RSd " != " FORMAT_RSd "", dwg->header_vars.unknown_52c, unknown_52c);
     unknown_52c++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_52c", &unknown_52c, 0)
         && unknown_52c == dwg->header_vars.unknown_52c)
       pass ();
     else
       fail ("HEADER.unknown_52c [RSd] set+1 " FORMAT_RSd " != " FORMAT_RSd "",
             dwg->header_vars.unknown_52c, unknown_52c);
     unknown_52c--;
     dwg_dynapi_header_set_value (dwg, "unknown_52c", &unknown_52c, 0);
 
   }
   {
     BITCODE_RS unknown_52e;
     if (dwg_dynapi_header_value (dwg, "unknown_52e", &unknown_52e, NULL)
         && unknown_52e == dwg->header_vars.unknown_52e)
       pass ();
     else
       fail ("HEADER.unknown_52e [RS] %hu != %hu", dwg->header_vars.unknown_52e, unknown_52e);
     unknown_52e++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_52e", &unknown_52e, 0)
         && unknown_52e == dwg->header_vars.unknown_52e)
       pass ();
     else
       fail ("HEADER.unknown_52e [RS] set+1 %hu != %hu",
             dwg->header_vars.unknown_52e, unknown_52e);
     unknown_52e--;
     dwg_dynapi_header_set_value (dwg, "unknown_52e", &unknown_52e, 0);
 
   }
   {
     BITCODE_RC unknown_530;
     if (dwg_dynapi_header_value (dwg, "unknown_530", &unknown_530, NULL)
         && unknown_530 == dwg->header_vars.unknown_530)
       pass ();
     else
       fail ("HEADER.unknown_530 [RC] %u != %u", dwg->header_vars.unknown_530, unknown_530);
     unknown_530++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_530", &unknown_530, 0)
         && unknown_530 == dwg->header_vars.unknown_530)
       pass ();
     else
       fail ("HEADER.unknown_530 [RC] set+1 %u != %u",
             dwg->header_vars.unknown_530, unknown_530);
     unknown_530--;
     dwg_dynapi_header_set_value (dwg, "unknown_530", &unknown_530, 0);
 
   }
   {
     BITCODE_RS unknown_59;
     if (dwg_dynapi_header_value (dwg, "unknown_59", &unknown_59, NULL)
         && unknown_59 == dwg->header_vars.unknown_59)
       pass ();
     else
       fail ("HEADER.unknown_59 [RS] %hu != %hu", dwg->header_vars.unknown_59, unknown_59);
     unknown_59++;
     if (dwg_dynapi_header_set_value (dwg, "unknown_59", &unknown_59, 0)
         && unknown_59 == dwg->header_vars.unknown_59)
       pass ();
     else
       fail ("HEADER.unknown_59 [RS] set+1 %hu != %hu",
             dwg->header_vars.unknown_59, unknown_59);
     unknown_59--;
     dwg_dynapi_header_set_value (dwg, "unknown_59", &unknown_59, 0);
 
   }
   {
     BITCODE_RD aspect_ratio;
     if (dwg_dynapi_header_value (dwg, "aspect_ratio", &aspect_ratio, NULL)
         && aspect_ratio == dwg->header_vars.aspect_ratio)
       pass ();
     else
       fail ("HEADER.aspect_ratio [RD] %g != %g", dwg->header_vars.aspect_ratio, aspect_ratio);
     aspect_ratio++;
     if (dwg_dynapi_header_set_value (dwg, "aspect_ratio", &aspect_ratio, 0)
         && aspect_ratio == dwg->header_vars.aspect_ratio)
       pass ();
     else
       fail ("HEADER.aspect_ratio [RD] set+1 %g != %g",
             dwg->header_vars.aspect_ratio, aspect_ratio);
     aspect_ratio--;
     dwg_dynapi_header_set_value (dwg, "aspect_ratio", &aspect_ratio, 0);
 
   }
 #line 47 "dynapi_test.c.in"
   return error;
 }
 #line 5379 "dynapi_test.c"
 /* @@for test_OBJECT@@ */
@@ -6207,486 +6207,486 @@ static int test__3DLINE (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
   Dwg_Entity__3DLINE *restrict _3dline = obj->tio.entity->tio._3DLINE;
   failed = 0;
   if (!obj_obj || !_3dline)
     {
       fail ("NULL _3DLINE");
       return 1;
     }
   {
     BITCODE_3RD end;
     if (dwg_dynapi_entity_value (_3dline, "3DLINE", "end", &end, NULL)
         && !memcmp (&end, &_3dline->end, sizeof (BITCODE_3RD)))
         pass ();
     else
         fail ("3DLINE.end [3RD]");
   }
   {
     BITCODE_3RD extrusion;
     if (dwg_dynapi_entity_value (_3dline, "3DLINE", "extrusion", &extrusion, NULL)
         && !memcmp (&extrusion, &_3dline->extrusion, sizeof (BITCODE_3RD)))
         pass ();
     else
         fail ("3DLINE.extrusion [3RD]");
   }
   {
     struct _dwg_object_entity* parent;
     if (dwg_dynapi_entity_value (_3dline, "3DLINE", "parent", &parent, NULL)
         && !memcmp (&parent, &_3dline->parent, sizeof (struct _dwg_object_entity*)))
         pass ();
     else
         fail ("3DLINE.parent [struct _dwg_object_entity*]");
   }
   {
     BITCODE_3RD start;
     if (dwg_dynapi_entity_value (_3dline, "3DLINE", "start", &start, NULL)
         && !memcmp (&start, &_3dline->start, sizeof (BITCODE_3RD)))
         pass ();
     else
         fail ("3DLINE.start [3RD]");
   }
   {
     BITCODE_RD thickness;
     if (dwg_dynapi_entity_value (_3dline, "3DLINE", "thickness", &thickness, NULL)
         && thickness == _3dline->thickness)
       pass ();
     else
       fail ("3DLINE.thickness [RD] %g != %g", _3dline->thickness, thickness);
     thickness++;
     if (dwg_dynapi_entity_set_value (_3dline, "3DLINE", "thickness", &thickness, 0)
         && thickness == _3dline->thickness)
       pass ();
     else
       fail ("3DLINE.thickness [RD] set+1 %g != %g", _3dline->thickness, thickness);
     _3dline->thickness--;
   }
   if (failed && (is_class_unstable ("3DLINE") || is_class_debugging ("3DLINE")))
     {
       ok ("%s failed %d tests (TODO unstable)", "3DLINE", failed);
       failed = 0;
     }
   return failed;
 }
 static int test__3DSOLID (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
   Dwg_Entity__3DSOLID *restrict _3dsolid = obj->tio.entity->tio._3DSOLID;
   failed = 0;
   if (!obj_obj || !_3dsolid)
     {
       fail ("NULL _3DSOLID");
       return 1;
     }
   {
     BITCODE_B _dxf_sab_converted;
     if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "_dxf_sab_converted", &_dxf_sab_converted, NULL)
         && _dxf_sab_converted == _3dsolid->_dxf_sab_converted)
       pass ();
     else
       fail ("3DSOLID._dxf_sab_converted [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->_dxf_sab_converted, _dxf_sab_converted);
     _dxf_sab_converted++;
     if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "_dxf_sab_converted", &_dxf_sab_converted, 0)
         && _dxf_sab_converted == _3dsolid->_dxf_sab_converted)
       pass ();
     else
       fail ("3DSOLID._dxf_sab_converted [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dsolid->_dxf_sab_converted, _dxf_sab_converted);
     _3dsolid->_dxf_sab_converted--;
   }
   {
     BITCODE_RC* acis_data;
     if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "acis_data", &acis_data, NULL)
         && acis_data
            ? strEQ ((char *)acis_data, (char *)_3dsolid->acis_data)
            : !_3dsolid->acis_data)
       pass ();
     else
       fail ("3DSOLID.acis_data [RC*] '%s' <> '%s'", acis_data, _3dsolid->acis_data);
   }
   {
     BITCODE_B acis_empty;
     if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "acis_empty", &acis_empty, NULL)
         && acis_empty == _3dsolid->acis_empty)
       pass ();
     else
       fail ("3DSOLID.acis_empty [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->acis_empty, acis_empty);
     acis_empty++;
     if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "acis_empty", &acis_empty, 0)
         && acis_empty == _3dsolid->acis_empty)
       pass ();
     else
       fail ("3DSOLID.acis_empty [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dsolid->acis_empty, acis_empty);
     _3dsolid->acis_empty--;
   }
   {
     BITCODE_B acis_empty2;
     if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "acis_empty2", &acis_empty2, NULL)
         && acis_empty2 == _3dsolid->acis_empty2)
       pass ();
     else
       fail ("3DSOLID.acis_empty2 [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->acis_empty2, acis_empty2);
     acis_empty2++;
     if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "acis_empty2", &acis_empty2, 0)
         && acis_empty2 == _3dsolid->acis_empty2)
       pass ();
     else
       fail ("3DSOLID.acis_empty2 [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dsolid->acis_empty2, acis_empty2);
     _3dsolid->acis_empty2--;
   }
   {
     BITCODE_B acis_empty_bit;
     if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "acis_empty_bit", &acis_empty_bit, NULL)
         && acis_empty_bit == _3dsolid->acis_empty_bit)
       pass ();
     else
       fail ("3DSOLID.acis_empty_bit [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->acis_empty_bit, acis_empty_bit);
     acis_empty_bit++;
     if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "acis_empty_bit", &acis_empty_bit, 0)
         && acis_empty_bit == _3dsolid->acis_empty_bit)
       pass ();
     else
       fail ("3DSOLID.acis_empty_bit [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dsolid->acis_empty_bit, acis_empty_bit);
     _3dsolid->acis_empty_bit--;
   }
   {
     BITCODE_BL* block_size;
     if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "block_size", &block_size, NULL)
         && !memcmp (&block_size, &_3dsolid->block_size, sizeof (BITCODE_BL*)))
         pass ();
     else
         fail ("3DSOLID.block_size [BL*]");
   }
   {
     char ** encr_sat_data;
     if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "encr_sat_data", &encr_sat_data, NULL)
         && !memcmp (&encr_sat_data, &_3dsolid->encr_sat_data, sizeof (_3dsolid->encr_sat_data)))
       pass ();
     else
       fail ("3DSOLID.encr_sat_data [char **]");
   }
   {
     BITCODE_BL end_marker;
     if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "end_marker", &end_marker, NULL)
         && end_marker == _3dsolid->end_marker)
       pass ();
     else
       fail ("3DSOLID.end_marker [BL] %u != %u", _3dsolid->end_marker, end_marker);
     end_marker++;
     if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "end_marker", &end_marker, 0)
         && end_marker == _3dsolid->end_marker)
       pass ();
     else
       fail ("3DSOLID.end_marker [BL] set+1 %u != %u", _3dsolid->end_marker, end_marker);
     _3dsolid->end_marker--;
   }
   {
     struct _dwg_entity_3DSOLID* extra_acis_data;
     if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "extra_acis_data", &extra_acis_data, NULL)
         && !memcmp (&extra_acis_data, &_3dsolid->extra_acis_data, sizeof (struct _dwg_entity_3DSOLID*)))
         pass ();
     else
         fail ("3DSOLID.extra_acis_data [struct _dwg_entity_3DSOLID*]");
   }
   {
     BITCODE_B has_revision_guid;
     if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "has_revision_guid", &has_revision_guid, NULL)
         && has_revision_guid == _3dsolid->has_revision_guid)
       pass ();
     else
       fail ("3DSOLID.has_revision_guid [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->has_revision_guid, has_revision_guid);
     has_revision_guid++;
     if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "has_revision_guid", &has_revision_guid, 0)
         && has_revision_guid == _3dsolid->has_revision_guid)
       pass ();
     else
       fail ("3DSOLID.has_revision_guid [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dsolid->has_revision_guid, has_revision_guid);
     _3dsolid->has_revision_guid--;
   }
   {
     BITCODE_H history_id;
     if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "history_id", &history_id, NULL)
         && !memcmp (&history_id, &_3dsolid->history_id, sizeof (BITCODE_H)))
         pass ();
     else
         fail ("3DSOLID.history_id [H]");
   }
   {
     BITCODE_B isoline_present;
     if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "isoline_present", &isoline_present, NULL)
         && isoline_present == _3dsolid->isoline_present)
       pass ();
     else
       fail ("3DSOLID.isoline_present [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->isoline_present, isoline_present);
     isoline_present++;
     if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "isoline_present", &isoline_present, 0)
         && isoline_present == _3dsolid->isoline_present)
       pass ();
     else
       fail ("3DSOLID.isoline_present [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dsolid->isoline_present, isoline_present);
     _3dsolid->isoline_present--;
   }
   {
     BITCODE_BL isolines;
     if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "isolines", &isolines, NULL)
         && isolines == _3dsolid->isolines)
       pass ();
     else
       fail ("3DSOLID.isolines [BL] %u != %u", _3dsolid->isolines, isolines);
     isolines++;
     if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "isolines", &isolines, 0)
         && isolines == _3dsolid->isolines)
       pass ();
     else
       fail ("3DSOLID.isolines [BL] set+1 %u != %u", _3dsolid->isolines, isolines);
     _3dsolid->isolines--;
   }
   {
     Dwg_3DSOLID_material* materials;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "num_materials", &count, NULL)
         && dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "materials", &materials, NULL)
         && materials == _3dsolid->materials)
       pass ();
     else
       fail ("3DSOLID.materials [Dwg_3DSOLID_material*] * %u num_materials", count);
   }
   {
     BITCODE_BL num_blocks;
     if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "num_blocks", &num_blocks, NULL)
         && num_blocks == _3dsolid->num_blocks)
       pass ();
     else
       fail ("3DSOLID.num_blocks [BL] %u != %u", _3dsolid->num_blocks, num_blocks);
     num_blocks++;
     if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "num_blocks", &num_blocks, 0)
         && num_blocks == _3dsolid->num_blocks)
       pass ();
     else
       fail ("3DSOLID.num_blocks [BL] set+1 %u != %u", _3dsolid->num_blocks, num_blocks);
     _3dsolid->num_blocks--;
   }
   {
     BITCODE_BL num_materials;
     if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "num_materials", &num_materials, NULL)
         && num_materials == _3dsolid->num_materials)
       pass ();
     else
       fail ("3DSOLID.num_materials [BL] %u != %u", _3dsolid->num_materials, num_materials);
     num_materials++;
     if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "num_materials", &num_materials, 0)
         && num_materials == _3dsolid->num_materials)
       pass ();
     else
       fail ("3DSOLID.num_materials [BL] set+1 %u != %u", _3dsolid->num_materials, num_materials);
     _3dsolid->num_materials--;
   }
   {
     BITCODE_BL num_silhouettes;
     if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "num_silhouettes", &num_silhouettes, NULL)
         && num_silhouettes == _3dsolid->num_silhouettes)
       pass ();
     else
       fail ("3DSOLID.num_silhouettes [BL] %u != %u", _3dsolid->num_silhouettes, num_silhouettes);
     num_silhouettes++;
     if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "num_silhouettes", &num_silhouettes, 0)
         && num_silhouettes == _3dsolid->num_silhouettes)
       pass ();
     else
       fail ("3DSOLID.num_silhouettes [BL] set+1 %u != %u", _3dsolid->num_silhouettes, num_silhouettes);
     _3dsolid->num_silhouettes--;
   }
   {
     BITCODE_BL num_wires;
     if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "num_wires", &num_wires, NULL)
         && num_wires == _3dsolid->num_wires)
       pass ();
     else
       fail ("3DSOLID.num_wires [BL] %u != %u", _3dsolid->num_wires, num_wires);
     num_wires++;
     if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "num_wires", &num_wires, 0)
         && num_wires == _3dsolid->num_wires)
       pass ();
     else
       fail ("3DSOLID.num_wires [BL] set+1 %u != %u", _3dsolid->num_wires, num_wires);
     _3dsolid->num_wires--;
   }
   {
     struct _dwg_object_entity* parent;
     if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "parent", &parent, NULL)
         && !memcmp (&parent, &_3dsolid->parent, sizeof (struct _dwg_object_entity*)))
         pass ();
     else
         fail ("3DSOLID.parent [struct _dwg_object_entity*]");
   }
   {
     BITCODE_3BD point;
     if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "point", &point, NULL)
         && !memcmp (&point, &_3dsolid->point, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("3DSOLID.point [3BD]");
   }
   {
     BITCODE_B point_present;
     if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "point_present", &point_present, NULL)
         && point_present == _3dsolid->point_present)
       pass ();
     else
       fail ("3DSOLID.point_present [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->point_present, point_present);
     point_present++;
     if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "point_present", &point_present, 0)
         && point_present == _3dsolid->point_present)
       pass ();
     else
       fail ("3DSOLID.point_present [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dsolid->point_present, point_present);
     _3dsolid->point_present--;
   }
   {
     BITCODE_RC revision_bytes[9];
-    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "revision_bytes[9]", &revision_bytes, NULL)
+    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "revision_bytes", &revision_bytes, NULL)
         && !memcmp (&revision_bytes, &_3dsolid->revision_bytes, sizeof (BITCODE_RC)))
         pass ();
     else
-        fail ("3DSOLID.revision_bytes[9] [RC]");
+        fail ("3DSOLID.revision_bytes [RC]");
   }
   {
     BITCODE_RC revision_guid[39];
-    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "revision_guid[39]", &revision_guid, NULL)
+    if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "revision_guid", &revision_guid, NULL)
         && !memcmp (&revision_guid, &_3dsolid->revision_guid, sizeof (BITCODE_RC)))
         pass ();
     else
-        fail ("3DSOLID.revision_guid[39] [RC]");
+        fail ("3DSOLID.revision_guid [RC]");
   }
   {
     BITCODE_BL revision_major;
     if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "revision_major", &revision_major, NULL)
         && revision_major == _3dsolid->revision_major)
       pass ();
     else
       fail ("3DSOLID.revision_major [BL] %u != %u", _3dsolid->revision_major, revision_major);
     revision_major++;
     if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "revision_major", &revision_major, 0)
         && revision_major == _3dsolid->revision_major)
       pass ();
     else
       fail ("3DSOLID.revision_major [BL] set+1 %u != %u", _3dsolid->revision_major, revision_major);
     _3dsolid->revision_major--;
   }
   {
     BITCODE_BS revision_minor1;
     if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "revision_minor1", &revision_minor1, NULL)
         && revision_minor1 == _3dsolid->revision_minor1)
       pass ();
     else
       fail ("3DSOLID.revision_minor1 [BS] %hu != %hu", _3dsolid->revision_minor1, revision_minor1);
     revision_minor1++;
     if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "revision_minor1", &revision_minor1, 0)
         && revision_minor1 == _3dsolid->revision_minor1)
       pass ();
     else
       fail ("3DSOLID.revision_minor1 [BS] set+1 %hu != %hu", _3dsolid->revision_minor1, revision_minor1);
     _3dsolid->revision_minor1--;
   }
   {
     BITCODE_BS revision_minor2;
     if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "revision_minor2", &revision_minor2, NULL)
         && revision_minor2 == _3dsolid->revision_minor2)
       pass ();
     else
       fail ("3DSOLID.revision_minor2 [BS] %hu != %hu", _3dsolid->revision_minor2, revision_minor2);
     revision_minor2++;
     if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "revision_minor2", &revision_minor2, 0)
         && revision_minor2 == _3dsolid->revision_minor2)
       pass ();
     else
       fail ("3DSOLID.revision_minor2 [BS] set+1 %hu != %hu", _3dsolid->revision_minor2, revision_minor2);
     _3dsolid->revision_minor2--;
   }
   {
     BITCODE_BL sab_size;
     if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "sab_size", &sab_size, NULL)
         && sab_size == _3dsolid->sab_size)
       pass ();
     else
       fail ("3DSOLID.sab_size [BL] %u != %u", _3dsolid->sab_size, sab_size);
     sab_size++;
     if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "sab_size", &sab_size, 0)
         && sab_size == _3dsolid->sab_size)
       pass ();
     else
       fail ("3DSOLID.sab_size [BL] set+1 %u != %u", _3dsolid->sab_size, sab_size);
     _3dsolid->sab_size--;
   }
   {
     Dwg_3DSOLID_silhouette* silhouettes;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "num_silhouettes", &count, NULL)
         && dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "silhouettes", &silhouettes, NULL)
         && silhouettes == _3dsolid->silhouettes)
       pass ();
     else
       fail ("3DSOLID.silhouettes [Dwg_3DSOLID_silhouette*] * %u num_silhouettes", count);
   }
   {
     BITCODE_B unknown;
     if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "unknown", &unknown, NULL)
         && unknown == _3dsolid->unknown)
       pass ();
     else
       fail ("3DSOLID.unknown [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->unknown, unknown);
     unknown++;
     if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "unknown", &unknown, 0)
         && unknown == _3dsolid->unknown)
       pass ();
     else
       fail ("3DSOLID.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dsolid->unknown, unknown);
     _3dsolid->unknown--;
   }
   {
     BITCODE_BS version;
     if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "version", &version, NULL)
         && version == _3dsolid->version)
       pass ();
     else
       fail ("3DSOLID.version [BS] %hu != %hu", _3dsolid->version, version);
     version++;
     if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "version", &version, 0)
         && version == _3dsolid->version)
       pass ();
     else
       fail ("3DSOLID.version [BS] set+1 %hu != %hu", _3dsolid->version, version);
     _3dsolid->version--;
   }
   {
     BITCODE_B wireframe_data_present;
     if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "wireframe_data_present", &wireframe_data_present, NULL)
         && wireframe_data_present == _3dsolid->wireframe_data_present)
       pass ();
     else
       fail ("3DSOLID.wireframe_data_present [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->wireframe_data_present, wireframe_data_present);
     wireframe_data_present++;
     if (dwg_dynapi_entity_set_value (_3dsolid, "3DSOLID", "wireframe_data_present", &wireframe_data_present, 0)
         && wireframe_data_present == _3dsolid->wireframe_data_present)
       pass ();
     else
       fail ("3DSOLID.wireframe_data_present [B] set+1 " FORMAT_B " != " FORMAT_B "", _3dsolid->wireframe_data_present, wireframe_data_present);
     _3dsolid->wireframe_data_present--;
   }
   {
     Dwg_3DSOLID_wire* wires;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "num_wires", &count, NULL)
         && dwg_dynapi_entity_value (_3dsolid, "3DSOLID", "wires", &wires, NULL)
         && wires == _3dsolid->wires)
       pass ();
     else
       fail ("3DSOLID.wires [Dwg_3DSOLID_wire*] * %u num_wires", count);
   }
   if (failed && (is_class_unstable ("3DSOLID") || is_class_debugging ("3DSOLID")))
     {
       ok ("%s failed %d tests (TODO unstable)", "3DSOLID", failed);
       failed = 0;
     }
   return failed;
 }
@@ -11067,856 +11067,856 @@ static int test_ENDREP (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
   Dwg_Entity_ENDREP *restrict endrep = obj->tio.entity->tio.ENDREP;
   failed = 0;
   if (!obj_obj || !endrep)
     {
       fail ("NULL ENDREP");
       return 1;
     }
   {
     BITCODE_RD colspacing;
     if (dwg_dynapi_entity_value (endrep, "ENDREP", "colspacing", &colspacing, NULL)
         && colspacing == endrep->colspacing)
       pass ();
     else
       fail ("ENDREP.colspacing [RD] %g != %g", endrep->colspacing, colspacing);
     colspacing++;
     if (dwg_dynapi_entity_set_value (endrep, "ENDREP", "colspacing", &colspacing, 0)
         && colspacing == endrep->colspacing)
       pass ();
     else
       fail ("ENDREP.colspacing [RD] set+1 %g != %g", endrep->colspacing, colspacing);
     endrep->colspacing--;
   }
   {
     BITCODE_RS numcols;
     if (dwg_dynapi_entity_value (endrep, "ENDREP", "numcols", &numcols, NULL)
         && numcols == endrep->numcols)
       pass ();
     else
       fail ("ENDREP.numcols [RS] %hu != %hu", endrep->numcols, numcols);
     numcols++;
     if (dwg_dynapi_entity_set_value (endrep, "ENDREP", "numcols", &numcols, 0)
         && numcols == endrep->numcols)
       pass ();
     else
       fail ("ENDREP.numcols [RS] set+1 %hu != %hu", endrep->numcols, numcols);
     endrep->numcols--;
   }
   {
     BITCODE_RS numrows;
     if (dwg_dynapi_entity_value (endrep, "ENDREP", "numrows", &numrows, NULL)
         && numrows == endrep->numrows)
       pass ();
     else
       fail ("ENDREP.numrows [RS] %hu != %hu", endrep->numrows, numrows);
     numrows++;
     if (dwg_dynapi_entity_set_value (endrep, "ENDREP", "numrows", &numrows, 0)
         && numrows == endrep->numrows)
       pass ();
     else
       fail ("ENDREP.numrows [RS] set+1 %hu != %hu", endrep->numrows, numrows);
     endrep->numrows--;
   }
   {
     struct _dwg_object_entity* parent;
     if (dwg_dynapi_entity_value (endrep, "ENDREP", "parent", &parent, NULL)
         && !memcmp (&parent, &endrep->parent, sizeof (struct _dwg_object_entity*)))
         pass ();
     else
         fail ("ENDREP.parent [struct _dwg_object_entity*]");
   }
   {
     BITCODE_RD rowspacing;
     if (dwg_dynapi_entity_value (endrep, "ENDREP", "rowspacing", &rowspacing, NULL)
         && rowspacing == endrep->rowspacing)
       pass ();
     else
       fail ("ENDREP.rowspacing [RD] %g != %g", endrep->rowspacing, rowspacing);
     rowspacing++;
     if (dwg_dynapi_entity_set_value (endrep, "ENDREP", "rowspacing", &rowspacing, 0)
         && rowspacing == endrep->rowspacing)
       pass ();
     else
       fail ("ENDREP.rowspacing [RD] set+1 %g != %g", endrep->rowspacing, rowspacing);
     endrep->rowspacing--;
   }
   if (failed && (is_class_unstable ("ENDREP") || is_class_debugging ("ENDREP")))
     {
       ok ("%s failed %d tests (TODO unstable)", "ENDREP", failed);
       failed = 0;
     }
   return failed;
 }
 static int test_EXTRUDEDSURFACE (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
   Dwg_Entity_EXTRUDEDSURFACE *restrict extrudedsurface = obj->tio.entity->tio.EXTRUDEDSURFACE;
   failed = 0;
   if (!obj_obj || !extrudedsurface)
     {
       fail ("NULL EXTRUDEDSURFACE");
       return 1;
     }
   {
     BITCODE_B _dxf_sab_converted;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "_dxf_sab_converted", &_dxf_sab_converted, NULL)
         && _dxf_sab_converted == extrudedsurface->_dxf_sab_converted)
       pass ();
     else
       fail ("EXTRUDEDSURFACE._dxf_sab_converted [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->_dxf_sab_converted, _dxf_sab_converted);
     _dxf_sab_converted++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "_dxf_sab_converted", &_dxf_sab_converted, 0)
         && _dxf_sab_converted == extrudedsurface->_dxf_sab_converted)
       pass ();
     else
       fail ("EXTRUDEDSURFACE._dxf_sab_converted [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->_dxf_sab_converted, _dxf_sab_converted);
     extrudedsurface->_dxf_sab_converted--;
   }
   {
     BITCODE_RC* acis_data;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "acis_data", &acis_data, NULL)
         && acis_data
            ? strEQ ((char *)acis_data, (char *)extrudedsurface->acis_data)
            : !extrudedsurface->acis_data)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.acis_data [RC*] '%s' <> '%s'", acis_data, extrudedsurface->acis_data);
   }
   {
     BITCODE_B acis_empty;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "acis_empty", &acis_empty, NULL)
         && acis_empty == extrudedsurface->acis_empty)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.acis_empty [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->acis_empty, acis_empty);
     acis_empty++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "acis_empty", &acis_empty, 0)
         && acis_empty == extrudedsurface->acis_empty)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.acis_empty [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->acis_empty, acis_empty);
     extrudedsurface->acis_empty--;
   }
   {
     BITCODE_B acis_empty2;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "acis_empty2", &acis_empty2, NULL)
         && acis_empty2 == extrudedsurface->acis_empty2)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.acis_empty2 [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->acis_empty2, acis_empty2);
     acis_empty2++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "acis_empty2", &acis_empty2, 0)
         && acis_empty2 == extrudedsurface->acis_empty2)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.acis_empty2 [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->acis_empty2, acis_empty2);
     extrudedsurface->acis_empty2--;
   }
   {
     BITCODE_B acis_empty_bit;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "acis_empty_bit", &acis_empty_bit, NULL)
         && acis_empty_bit == extrudedsurface->acis_empty_bit)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.acis_empty_bit [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->acis_empty_bit, acis_empty_bit);
     acis_empty_bit++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "acis_empty_bit", &acis_empty_bit, 0)
         && acis_empty_bit == extrudedsurface->acis_empty_bit)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.acis_empty_bit [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->acis_empty_bit, acis_empty_bit);
     extrudedsurface->acis_empty_bit--;
   }
   {
     BITCODE_BD align_angle;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "align_angle", &align_angle, NULL)
         && align_angle == extrudedsurface->align_angle)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.align_angle [BD] %g != %g", extrudedsurface->align_angle, align_angle);
     align_angle++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "align_angle", &align_angle, 0)
         && align_angle == extrudedsurface->align_angle)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.align_angle [BD] set+1 %g != %g", extrudedsurface->align_angle, align_angle);
     extrudedsurface->align_angle--;
   }
   {
     BITCODE_B align_start;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "align_start", &align_start, NULL)
         && align_start == extrudedsurface->align_start)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.align_start [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->align_start, align_start);
     align_start++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "align_start", &align_start, 0)
         && align_start == extrudedsurface->align_start)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.align_start [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->align_start, align_start);
     extrudedsurface->align_start--;
   }
   {
     BITCODE_B bank;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "bank", &bank, NULL)
         && bank == extrudedsurface->bank)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.bank [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->bank, bank);
     bank++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "bank", &bank, 0)
         && bank == extrudedsurface->bank)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.bank [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->bank, bank);
     extrudedsurface->bank--;
   }
   {
     BITCODE_B base_point_set;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "base_point_set", &base_point_set, NULL)
         && base_point_set == extrudedsurface->base_point_set)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.base_point_set [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->base_point_set, base_point_set);
     base_point_set++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "base_point_set", &base_point_set, 0)
         && base_point_set == extrudedsurface->base_point_set)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.base_point_set [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->base_point_set, base_point_set);
     extrudedsurface->base_point_set--;
   }
   {
     BITCODE_TF bindata;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "bindata", &bindata, NULL)
         && !memcmp (&bindata, &extrudedsurface->bindata, sizeof (BITCODE_TF)))
         pass ();
     else
         fail ("EXTRUDEDSURFACE.bindata [TF]");
   }
   {
     BITCODE_BL bindata_size;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "bindata_size", &bindata_size, NULL)
         && bindata_size == extrudedsurface->bindata_size)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.bindata_size [BL] %u != %u", extrudedsurface->bindata_size, bindata_size);
     bindata_size++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "bindata_size", &bindata_size, 0)
         && bindata_size == extrudedsurface->bindata_size)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.bindata_size [BL] set+1 %u != %u", extrudedsurface->bindata_size, bindata_size);
     extrudedsurface->bindata_size--;
   }
   {
     BITCODE_BL* block_size;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "block_size", &block_size, NULL)
         && !memcmp (&block_size, &extrudedsurface->block_size, sizeof (BITCODE_BL*)))
         pass ();
     else
         fail ("EXTRUDEDSURFACE.block_size [BL*]");
   }
   {
     BITCODE_BL class_version;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "class_version", &class_version, NULL)
         && class_version == extrudedsurface->class_version)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.class_version [BL] %u != %u", extrudedsurface->class_version, class_version);
     class_version++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "class_version", &class_version, 0)
         && class_version == extrudedsurface->class_version)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.class_version [BL] set+1 %u != %u", extrudedsurface->class_version, class_version);
     extrudedsurface->class_version--;
   }
   {
     BITCODE_BD draft_angle;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "draft_angle", &draft_angle, NULL)
         && draft_angle == extrudedsurface->draft_angle)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.draft_angle [BD] %g != %g", extrudedsurface->draft_angle, draft_angle);
     draft_angle++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "draft_angle", &draft_angle, 0)
         && draft_angle == extrudedsurface->draft_angle)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.draft_angle [BD] set+1 %g != %g", extrudedsurface->draft_angle, draft_angle);
     extrudedsurface->draft_angle--;
   }
   {
     BITCODE_BD draft_end_distance;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "draft_end_distance", &draft_end_distance, NULL)
         && draft_end_distance == extrudedsurface->draft_end_distance)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.draft_end_distance [BD] %g != %g", extrudedsurface->draft_end_distance, draft_end_distance);
     draft_end_distance++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "draft_end_distance", &draft_end_distance, 0)
         && draft_end_distance == extrudedsurface->draft_end_distance)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.draft_end_distance [BD] set+1 %g != %g", extrudedsurface->draft_end_distance, draft_end_distance);
     extrudedsurface->draft_end_distance--;
   }
   {
     BITCODE_BD draft_start_distance;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "draft_start_distance", &draft_start_distance, NULL)
         && draft_start_distance == extrudedsurface->draft_start_distance)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.draft_start_distance [BD] %g != %g", extrudedsurface->draft_start_distance, draft_start_distance);
     draft_start_distance++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "draft_start_distance", &draft_start_distance, 0)
         && draft_start_distance == extrudedsurface->draft_start_distance)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.draft_start_distance [BD] set+1 %g != %g", extrudedsurface->draft_start_distance, draft_start_distance);
     extrudedsurface->draft_start_distance--;
   }
   {
     char ** encr_sat_data;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "encr_sat_data", &encr_sat_data, NULL)
         && !memcmp (&encr_sat_data, &extrudedsurface->encr_sat_data, sizeof (extrudedsurface->encr_sat_data)))
       pass ();
     else
       fail ("EXTRUDEDSURFACE.encr_sat_data [char **]");
   }
   {
     BITCODE_BL end_marker;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "end_marker", &end_marker, NULL)
         && end_marker == extrudedsurface->end_marker)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.end_marker [BL] %u != %u", extrudedsurface->end_marker, end_marker);
     end_marker++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "end_marker", &end_marker, 0)
         && end_marker == extrudedsurface->end_marker)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.end_marker [BL] set+1 %u != %u", extrudedsurface->end_marker, end_marker);
     extrudedsurface->end_marker--;
   }
   {
     struct _dwg_entity_3DSOLID* extra_acis_data;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "extra_acis_data", &extra_acis_data, NULL)
         && !memcmp (&extra_acis_data, &extrudedsurface->extra_acis_data, sizeof (struct _dwg_entity_3DSOLID*)))
         pass ();
     else
         fail ("EXTRUDEDSURFACE.extra_acis_data [struct _dwg_entity_3DSOLID*]");
   }
   {
     BITCODE_B has_revision_guid;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "has_revision_guid", &has_revision_guid, NULL)
         && has_revision_guid == extrudedsurface->has_revision_guid)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.has_revision_guid [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->has_revision_guid, has_revision_guid);
     has_revision_guid++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "has_revision_guid", &has_revision_guid, 0)
         && has_revision_guid == extrudedsurface->has_revision_guid)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.has_revision_guid [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->has_revision_guid, has_revision_guid);
     extrudedsurface->has_revision_guid--;
   }
   {
     BITCODE_H history_id;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "history_id", &history_id, NULL)
         && !memcmp (&history_id, &extrudedsurface->history_id, sizeof (BITCODE_H)))
         pass ();
     else
         fail ("EXTRUDEDSURFACE.history_id [H]");
   }
   {
     BITCODE_B is_solid;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "is_solid", &is_solid, NULL)
         && is_solid == extrudedsurface->is_solid)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.is_solid [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->is_solid, is_solid);
     is_solid++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "is_solid", &is_solid, 0)
         && is_solid == extrudedsurface->is_solid)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.is_solid [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->is_solid, is_solid);
     extrudedsurface->is_solid--;
   }
   {
     BITCODE_B isoline_present;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "isoline_present", &isoline_present, NULL)
         && isoline_present == extrudedsurface->isoline_present)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.isoline_present [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->isoline_present, isoline_present);
     isoline_present++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "isoline_present", &isoline_present, 0)
         && isoline_present == extrudedsurface->isoline_present)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.isoline_present [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->isoline_present, isoline_present);
     extrudedsurface->isoline_present--;
   }
   {
     BITCODE_BL isolines;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "isolines", &isolines, NULL)
         && isolines == extrudedsurface->isolines)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.isolines [BL] %u != %u", extrudedsurface->isolines, isolines);
     isolines++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "isolines", &isolines, 0)
         && isolines == extrudedsurface->isolines)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.isolines [BL] set+1 %u != %u", extrudedsurface->isolines, isolines);
     extrudedsurface->isolines--;
   }
   {
     Dwg_3DSOLID_material* materials;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "num_materials", &count, NULL)
         && dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "materials", &materials, NULL)
         && materials == extrudedsurface->materials)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.materials [Dwg_3DSOLID_material*] * %u num_materials", count);
   }
   {
     BITCODE_BS modeler_format_version;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "modeler_format_version", &modeler_format_version, NULL)
         && modeler_format_version == extrudedsurface->modeler_format_version)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.modeler_format_version [BS] %hu != %hu", extrudedsurface->modeler_format_version, modeler_format_version);
     modeler_format_version++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "modeler_format_version", &modeler_format_version, 0)
         && modeler_format_version == extrudedsurface->modeler_format_version)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.modeler_format_version [BS] set+1 %hu != %hu", extrudedsurface->modeler_format_version, modeler_format_version);
     extrudedsurface->modeler_format_version--;
   }
   {
     BITCODE_BL num_blocks;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "num_blocks", &num_blocks, NULL)
         && num_blocks == extrudedsurface->num_blocks)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.num_blocks [BL] %u != %u", extrudedsurface->num_blocks, num_blocks);
     num_blocks++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "num_blocks", &num_blocks, 0)
         && num_blocks == extrudedsurface->num_blocks)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.num_blocks [BL] set+1 %u != %u", extrudedsurface->num_blocks, num_blocks);
     extrudedsurface->num_blocks--;
   }
   {
     BITCODE_BL num_materials;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "num_materials", &num_materials, NULL)
         && num_materials == extrudedsurface->num_materials)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.num_materials [BL] %u != %u", extrudedsurface->num_materials, num_materials);
     num_materials++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "num_materials", &num_materials, 0)
         && num_materials == extrudedsurface->num_materials)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.num_materials [BL] set+1 %u != %u", extrudedsurface->num_materials, num_materials);
     extrudedsurface->num_materials--;
   }
   {
     BITCODE_BL num_silhouettes;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "num_silhouettes", &num_silhouettes, NULL)
         && num_silhouettes == extrudedsurface->num_silhouettes)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.num_silhouettes [BL] %u != %u", extrudedsurface->num_silhouettes, num_silhouettes);
     num_silhouettes++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "num_silhouettes", &num_silhouettes, 0)
         && num_silhouettes == extrudedsurface->num_silhouettes)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.num_silhouettes [BL] set+1 %u != %u", extrudedsurface->num_silhouettes, num_silhouettes);
     extrudedsurface->num_silhouettes--;
   }
   {
     BITCODE_BL num_wires;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "num_wires", &num_wires, NULL)
         && num_wires == extrudedsurface->num_wires)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.num_wires [BL] %u != %u", extrudedsurface->num_wires, num_wires);
     num_wires++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "num_wires", &num_wires, 0)
         && num_wires == extrudedsurface->num_wires)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.num_wires [BL] set+1 %u != %u", extrudedsurface->num_wires, num_wires);
     extrudedsurface->num_wires--;
   }
   {
     struct _dwg_object_entity* parent;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "parent", &parent, NULL)
         && !memcmp (&parent, &extrudedsurface->parent, sizeof (struct _dwg_object_entity*)))
         pass ();
     else
         fail ("EXTRUDEDSURFACE.parent [struct _dwg_object_entity*]");
   }
   {
     BITCODE_H path_entity;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "path_entity", &path_entity, NULL)
         && !memcmp (&path_entity, &extrudedsurface->path_entity, sizeof (BITCODE_H)))
         pass ();
     else
         fail ("EXTRUDEDSURFACE.path_entity [H]");
   }
   {
     BITCODE_B path_entity_transform_computed;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "path_entity_transform_computed", &path_entity_transform_computed, NULL)
         && path_entity_transform_computed == extrudedsurface->path_entity_transform_computed)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.path_entity_transform_computed [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->path_entity_transform_computed, path_entity_transform_computed);
     path_entity_transform_computed++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "path_entity_transform_computed", &path_entity_transform_computed, 0)
         && path_entity_transform_computed == extrudedsurface->path_entity_transform_computed)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.path_entity_transform_computed [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->path_entity_transform_computed, path_entity_transform_computed);
     extrudedsurface->path_entity_transform_computed--;
   }
   {
     BITCODE_BD* path_entity_transmatrix;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "path_entity_transmatrix", &path_entity_transmatrix, NULL)
         && !memcmp (&path_entity_transmatrix, &extrudedsurface->path_entity_transmatrix, sizeof (BITCODE_BD*)))
         pass ();
     else
         fail ("EXTRUDEDSURFACE.path_entity_transmatrix [BD*]");
   }
   {
     BITCODE_BS path_flags;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "path_flags", &path_flags, NULL)
         && path_flags == extrudedsurface->path_flags)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.path_flags [BS] %hu != %hu", extrudedsurface->path_flags, path_flags);
     path_flags++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "path_flags", &path_flags, 0)
         && path_flags == extrudedsurface->path_flags)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.path_flags [BS] set+1 %hu != %hu", extrudedsurface->path_flags, path_flags);
     extrudedsurface->path_flags--;
   }
   {
     BITCODE_3BD point;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "point", &point, NULL)
         && !memcmp (&point, &extrudedsurface->point, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("EXTRUDEDSURFACE.point [3BD]");
   }
   {
     BITCODE_B point_present;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "point_present", &point_present, NULL)
         && point_present == extrudedsurface->point_present)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.point_present [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->point_present, point_present);
     point_present++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "point_present", &point_present, 0)
         && point_present == extrudedsurface->point_present)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.point_present [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->point_present, point_present);
     extrudedsurface->point_present--;
   }
   {
     BITCODE_3BD reference_vector_for_controlling_twist;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "reference_vector_for_controlling_twist", &reference_vector_for_controlling_twist, NULL)
         && !memcmp (&reference_vector_for_controlling_twist, &extrudedsurface->reference_vector_for_controlling_twist, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("EXTRUDEDSURFACE.reference_vector_for_controlling_twist [3BD]");
   }
   {
     BITCODE_RC revision_bytes[9];
-    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "revision_bytes[9]", &revision_bytes, NULL)
+    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "revision_bytes", &revision_bytes, NULL)
         && !memcmp (&revision_bytes, &extrudedsurface->revision_bytes, sizeof (BITCODE_RC)))
         pass ();
     else
-        fail ("EXTRUDEDSURFACE.revision_bytes[9] [RC]");
+        fail ("EXTRUDEDSURFACE.revision_bytes [RC]");
   }
   {
     BITCODE_RC revision_guid[39];
-    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "revision_guid[39]", &revision_guid, NULL)
+    if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "revision_guid", &revision_guid, NULL)
         && !memcmp (&revision_guid, &extrudedsurface->revision_guid, sizeof (BITCODE_RC)))
         pass ();
     else
-        fail ("EXTRUDEDSURFACE.revision_guid[39] [RC]");
+        fail ("EXTRUDEDSURFACE.revision_guid [RC]");
   }
   {
     BITCODE_BL revision_major;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "revision_major", &revision_major, NULL)
         && revision_major == extrudedsurface->revision_major)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.revision_major [BL] %u != %u", extrudedsurface->revision_major, revision_major);
     revision_major++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "revision_major", &revision_major, 0)
         && revision_major == extrudedsurface->revision_major)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.revision_major [BL] set+1 %u != %u", extrudedsurface->revision_major, revision_major);
     extrudedsurface->revision_major--;
   }
   {
     BITCODE_BS revision_minor1;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "revision_minor1", &revision_minor1, NULL)
         && revision_minor1 == extrudedsurface->revision_minor1)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.revision_minor1 [BS] %hu != %hu", extrudedsurface->revision_minor1, revision_minor1);
     revision_minor1++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "revision_minor1", &revision_minor1, 0)
         && revision_minor1 == extrudedsurface->revision_minor1)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.revision_minor1 [BS] set+1 %hu != %hu", extrudedsurface->revision_minor1, revision_minor1);
     extrudedsurface->revision_minor1--;
   }
   {
     BITCODE_BS revision_minor2;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "revision_minor2", &revision_minor2, NULL)
         && revision_minor2 == extrudedsurface->revision_minor2)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.revision_minor2 [BS] %hu != %hu", extrudedsurface->revision_minor2, revision_minor2);
     revision_minor2++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "revision_minor2", &revision_minor2, 0)
         && revision_minor2 == extrudedsurface->revision_minor2)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.revision_minor2 [BS] set+1 %hu != %hu", extrudedsurface->revision_minor2, revision_minor2);
     extrudedsurface->revision_minor2--;
   }
   {
     BITCODE_BL sab_size;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "sab_size", &sab_size, NULL)
         && sab_size == extrudedsurface->sab_size)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.sab_size [BL] %u != %u", extrudedsurface->sab_size, sab_size);
     sab_size++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "sab_size", &sab_size, 0)
         && sab_size == extrudedsurface->sab_size)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.sab_size [BL] set+1 %u != %u", extrudedsurface->sab_size, sab_size);
     extrudedsurface->sab_size--;
   }
   {
     BITCODE_BD scale_factor;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "scale_factor", &scale_factor, NULL)
         && scale_factor == extrudedsurface->scale_factor)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.scale_factor [BD] %g != %g", extrudedsurface->scale_factor, scale_factor);
     scale_factor++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "scale_factor", &scale_factor, 0)
         && scale_factor == extrudedsurface->scale_factor)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.scale_factor [BD] set+1 %g != %g", extrudedsurface->scale_factor, scale_factor);
     extrudedsurface->scale_factor--;
   }
   {
     Dwg_3DSOLID_silhouette* silhouettes;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "num_silhouettes", &count, NULL)
         && dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "silhouettes", &silhouettes, NULL)
         && silhouettes == extrudedsurface->silhouettes)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.silhouettes [Dwg_3DSOLID_silhouette*] * %u num_silhouettes", count);
   }
   {
     BITCODE_BS sweep_alignment_flags;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "sweep_alignment_flags", &sweep_alignment_flags, NULL)
         && sweep_alignment_flags == extrudedsurface->sweep_alignment_flags)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.sweep_alignment_flags [BS] %hu != %hu", extrudedsurface->sweep_alignment_flags, sweep_alignment_flags);
     sweep_alignment_flags++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "sweep_alignment_flags", &sweep_alignment_flags, 0)
         && sweep_alignment_flags == extrudedsurface->sweep_alignment_flags)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.sweep_alignment_flags [BS] set+1 %hu != %hu", extrudedsurface->sweep_alignment_flags, sweep_alignment_flags);
     extrudedsurface->sweep_alignment_flags--;
   }
   {
     BITCODE_H sweep_entity;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "sweep_entity", &sweep_entity, NULL)
         && !memcmp (&sweep_entity, &extrudedsurface->sweep_entity, sizeof (BITCODE_H)))
         pass ();
     else
         fail ("EXTRUDEDSURFACE.sweep_entity [H]");
   }
   {
     BITCODE_B sweep_entity_transform_computed;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "sweep_entity_transform_computed", &sweep_entity_transform_computed, NULL)
         && sweep_entity_transform_computed == extrudedsurface->sweep_entity_transform_computed)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.sweep_entity_transform_computed [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->sweep_entity_transform_computed, sweep_entity_transform_computed);
     sweep_entity_transform_computed++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "sweep_entity_transform_computed", &sweep_entity_transform_computed, 0)
         && sweep_entity_transform_computed == extrudedsurface->sweep_entity_transform_computed)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.sweep_entity_transform_computed [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->sweep_entity_transform_computed, sweep_entity_transform_computed);
     extrudedsurface->sweep_entity_transform_computed--;
   }
   {
     BITCODE_BD* sweep_entity_transmatrix;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "sweep_entity_transmatrix", &sweep_entity_transmatrix, NULL)
         && !memcmp (&sweep_entity_transmatrix, &extrudedsurface->sweep_entity_transmatrix, sizeof (BITCODE_BD*)))
         pass ();
     else
         fail ("EXTRUDEDSURFACE.sweep_entity_transmatrix [BD*]");
   }
   {
     BITCODE_BD* sweep_transmatrix;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "sweep_transmatrix", &sweep_transmatrix, NULL)
         && !memcmp (&sweep_transmatrix, &extrudedsurface->sweep_transmatrix, sizeof (BITCODE_BD*)))
         pass ();
     else
         fail ("EXTRUDEDSURFACE.sweep_transmatrix [BD*]");
   }
   {
     BITCODE_3BD sweep_vector;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "sweep_vector", &sweep_vector, NULL)
         && !memcmp (&sweep_vector, &extrudedsurface->sweep_vector, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("EXTRUDEDSURFACE.sweep_vector [3BD]");
   }
   {
     BITCODE_BD twist_angle;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "twist_angle", &twist_angle, NULL)
         && twist_angle == extrudedsurface->twist_angle)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.twist_angle [BD] %g != %g", extrudedsurface->twist_angle, twist_angle);
     twist_angle++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "twist_angle", &twist_angle, 0)
         && twist_angle == extrudedsurface->twist_angle)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.twist_angle [BD] set+1 %g != %g", extrudedsurface->twist_angle, twist_angle);
     extrudedsurface->twist_angle--;
   }
   {
     BITCODE_BS u_isolines;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "u_isolines", &u_isolines, NULL)
         && u_isolines == extrudedsurface->u_isolines)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.u_isolines [BS] %hu != %hu", extrudedsurface->u_isolines, u_isolines);
     u_isolines++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "u_isolines", &u_isolines, 0)
         && u_isolines == extrudedsurface->u_isolines)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.u_isolines [BS] set+1 %hu != %hu", extrudedsurface->u_isolines, u_isolines);
     extrudedsurface->u_isolines--;
   }
   {
     BITCODE_B unknown;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "unknown", &unknown, NULL)
         && unknown == extrudedsurface->unknown)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.unknown [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->unknown, unknown);
     unknown++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "unknown", &unknown, 0)
         && unknown == extrudedsurface->unknown)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->unknown, unknown);
     extrudedsurface->unknown--;
   }
   {
     BITCODE_BS v_isolines;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "v_isolines", &v_isolines, NULL)
         && v_isolines == extrudedsurface->v_isolines)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.v_isolines [BS] %hu != %hu", extrudedsurface->v_isolines, v_isolines);
     v_isolines++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "v_isolines", &v_isolines, 0)
         && v_isolines == extrudedsurface->v_isolines)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.v_isolines [BS] set+1 %hu != %hu", extrudedsurface->v_isolines, v_isolines);
     extrudedsurface->v_isolines--;
   }
   {
     BITCODE_BS version;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "version", &version, NULL)
         && version == extrudedsurface->version)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.version [BS] %hu != %hu", extrudedsurface->version, version);
     version++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "version", &version, 0)
         && version == extrudedsurface->version)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.version [BS] set+1 %hu != %hu", extrudedsurface->version, version);
     extrudedsurface->version--;
   }
   {
     BITCODE_B wireframe_data_present;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "wireframe_data_present", &wireframe_data_present, NULL)
         && wireframe_data_present == extrudedsurface->wireframe_data_present)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.wireframe_data_present [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->wireframe_data_present, wireframe_data_present);
     wireframe_data_present++;
     if (dwg_dynapi_entity_set_value (extrudedsurface, "EXTRUDEDSURFACE", "wireframe_data_present", &wireframe_data_present, 0)
         && wireframe_data_present == extrudedsurface->wireframe_data_present)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.wireframe_data_present [B] set+1 " FORMAT_B " != " FORMAT_B "", extrudedsurface->wireframe_data_present, wireframe_data_present);
     extrudedsurface->wireframe_data_present--;
   }
   {
     Dwg_3DSOLID_wire* wires;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "num_wires", &count, NULL)
         && dwg_dynapi_entity_value (extrudedsurface, "EXTRUDEDSURFACE", "wires", &wires, NULL)
         && wires == extrudedsurface->wires)
       pass ();
     else
       fail ("EXTRUDEDSURFACE.wires [Dwg_3DSOLID_wire*] * %u num_wires", count);
   }
   if (failed && (is_class_unstable ("EXTRUDEDSURFACE") || is_class_debugging ("EXTRUDEDSURFACE")))
     {
       ok ("%s failed %d tests (TODO unstable)", "EXTRUDEDSURFACE", failed);
       failed = 0;
     }
   return failed;
 }
@@ -14950,763 +14950,763 @@ static int test_LOAD (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
   Dwg_Entity_LOAD *restrict load = obj->tio.entity->tio.LOAD;
   failed = 0;
   if (!obj_obj || !load)
     {
       fail ("NULL LOAD");
       return 1;
     }
   {
     BITCODE_TV file_name;
     if (dwg_dynapi_entity_value (load, "LOAD", "file_name", &file_name, NULL)
         && file_name
            ? strEQ ((char *)file_name, (char *)load->file_name)
            : !load->file_name)
       pass ();
     else
       fail ("LOAD.file_name [TV] '%s' <> '%s'", file_name, load->file_name);
   }
   {
     struct _dwg_object_entity* parent;
     if (dwg_dynapi_entity_value (load, "LOAD", "parent", &parent, NULL)
         && !memcmp (&parent, &load->parent, sizeof (struct _dwg_object_entity*)))
         pass ();
     else
         fail ("LOAD.parent [struct _dwg_object_entity*]");
   }
   if (failed && (is_class_unstable ("LOAD") || is_class_debugging ("LOAD")))
     {
       ok ("%s failed %d tests (TODO unstable)", "LOAD", failed);
       failed = 0;
     }
   return failed;
 }
 static int test_LOFTEDSURFACE (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
   Dwg_Entity_LOFTEDSURFACE *restrict loftedsurface = obj->tio.entity->tio.LOFTEDSURFACE;
   failed = 0;
   if (!obj_obj || !loftedsurface)
     {
       fail ("NULL LOFTEDSURFACE");
       return 1;
     }
   {
     BITCODE_B _dxf_sab_converted;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "_dxf_sab_converted", &_dxf_sab_converted, NULL)
         && _dxf_sab_converted == loftedsurface->_dxf_sab_converted)
       pass ();
     else
       fail ("LOFTEDSURFACE._dxf_sab_converted [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->_dxf_sab_converted, _dxf_sab_converted);
     _dxf_sab_converted++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "_dxf_sab_converted", &_dxf_sab_converted, 0)
         && _dxf_sab_converted == loftedsurface->_dxf_sab_converted)
       pass ();
     else
       fail ("LOFTEDSURFACE._dxf_sab_converted [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->_dxf_sab_converted, _dxf_sab_converted);
     loftedsurface->_dxf_sab_converted--;
   }
   {
     BITCODE_RC* acis_data;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "acis_data", &acis_data, NULL)
         && acis_data
            ? strEQ ((char *)acis_data, (char *)loftedsurface->acis_data)
            : !loftedsurface->acis_data)
       pass ();
     else
       fail ("LOFTEDSURFACE.acis_data [RC*] '%s' <> '%s'", acis_data, loftedsurface->acis_data);
   }
   {
     BITCODE_B acis_empty;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "acis_empty", &acis_empty, NULL)
         && acis_empty == loftedsurface->acis_empty)
       pass ();
     else
       fail ("LOFTEDSURFACE.acis_empty [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->acis_empty, acis_empty);
     acis_empty++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "acis_empty", &acis_empty, 0)
         && acis_empty == loftedsurface->acis_empty)
       pass ();
     else
       fail ("LOFTEDSURFACE.acis_empty [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->acis_empty, acis_empty);
     loftedsurface->acis_empty--;
   }
   {
     BITCODE_B acis_empty2;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "acis_empty2", &acis_empty2, NULL)
         && acis_empty2 == loftedsurface->acis_empty2)
       pass ();
     else
       fail ("LOFTEDSURFACE.acis_empty2 [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->acis_empty2, acis_empty2);
     acis_empty2++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "acis_empty2", &acis_empty2, 0)
         && acis_empty2 == loftedsurface->acis_empty2)
       pass ();
     else
       fail ("LOFTEDSURFACE.acis_empty2 [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->acis_empty2, acis_empty2);
     loftedsurface->acis_empty2--;
   }
   {
     BITCODE_B acis_empty_bit;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "acis_empty_bit", &acis_empty_bit, NULL)
         && acis_empty_bit == loftedsurface->acis_empty_bit)
       pass ();
     else
       fail ("LOFTEDSURFACE.acis_empty_bit [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->acis_empty_bit, acis_empty_bit);
     acis_empty_bit++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "acis_empty_bit", &acis_empty_bit, 0)
         && acis_empty_bit == loftedsurface->acis_empty_bit)
       pass ();
     else
       fail ("LOFTEDSURFACE.acis_empty_bit [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->acis_empty_bit, acis_empty_bit);
     loftedsurface->acis_empty_bit--;
   }
   {
     BITCODE_B align_direction;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "align_direction", &align_direction, NULL)
         && align_direction == loftedsurface->align_direction)
       pass ();
     else
       fail ("LOFTEDSURFACE.align_direction [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->align_direction, align_direction);
     align_direction++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "align_direction", &align_direction, 0)
         && align_direction == loftedsurface->align_direction)
       pass ();
     else
       fail ("LOFTEDSURFACE.align_direction [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->align_direction, align_direction);
     loftedsurface->align_direction--;
   }
   {
     BITCODE_B arc_length_parameterization;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "arc_length_parameterization", &arc_length_parameterization, NULL)
         && arc_length_parameterization == loftedsurface->arc_length_parameterization)
       pass ();
     else
       fail ("LOFTEDSURFACE.arc_length_parameterization [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->arc_length_parameterization, arc_length_parameterization);
     arc_length_parameterization++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "arc_length_parameterization", &arc_length_parameterization, 0)
         && arc_length_parameterization == loftedsurface->arc_length_parameterization)
       pass ();
     else
       fail ("LOFTEDSURFACE.arc_length_parameterization [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->arc_length_parameterization, arc_length_parameterization);
     loftedsurface->arc_length_parameterization--;
   }
   {
     BITCODE_BL* block_size;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "block_size", &block_size, NULL)
         && !memcmp (&block_size, &loftedsurface->block_size, sizeof (BITCODE_BL*)))
         pass ();
     else
         fail ("LOFTEDSURFACE.block_size [BL*]");
   }
   {
     BITCODE_B closed_surfaces;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "closed_surfaces", &closed_surfaces, NULL)
         && closed_surfaces == loftedsurface->closed_surfaces)
       pass ();
     else
       fail ("LOFTEDSURFACE.closed_surfaces [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->closed_surfaces, closed_surfaces);
     closed_surfaces++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "closed_surfaces", &closed_surfaces, 0)
         && closed_surfaces == loftedsurface->closed_surfaces)
       pass ();
     else
       fail ("LOFTEDSURFACE.closed_surfaces [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->closed_surfaces, closed_surfaces);
     loftedsurface->closed_surfaces--;
   }
   {
     BITCODE_H* cross_sections;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "num_cross_sections", &count, NULL)
         && dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "cross_sections", &cross_sections, NULL)
         && cross_sections == loftedsurface->cross_sections)
       pass ();
     else
       fail ("LOFTEDSURFACE.cross_sections [H*] * %u num_cross_sections", count);
   }
   {
     char ** encr_sat_data;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "encr_sat_data", &encr_sat_data, NULL)
         && !memcmp (&encr_sat_data, &loftedsurface->encr_sat_data, sizeof (loftedsurface->encr_sat_data)))
       pass ();
     else
       fail ("LOFTEDSURFACE.encr_sat_data [char **]");
   }
   {
     BITCODE_BD end_draft_angle;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "end_draft_angle", &end_draft_angle, NULL)
         && end_draft_angle == loftedsurface->end_draft_angle)
       pass ();
     else
       fail ("LOFTEDSURFACE.end_draft_angle [BD] %g != %g", loftedsurface->end_draft_angle, end_draft_angle);
     end_draft_angle++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "end_draft_angle", &end_draft_angle, 0)
         && end_draft_angle == loftedsurface->end_draft_angle)
       pass ();
     else
       fail ("LOFTEDSURFACE.end_draft_angle [BD] set+1 %g != %g", loftedsurface->end_draft_angle, end_draft_angle);
     loftedsurface->end_draft_angle--;
   }
   {
     BITCODE_BD end_draft_magnitude;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "end_draft_magnitude", &end_draft_magnitude, NULL)
         && end_draft_magnitude == loftedsurface->end_draft_magnitude)
       pass ();
     else
       fail ("LOFTEDSURFACE.end_draft_magnitude [BD] %g != %g", loftedsurface->end_draft_magnitude, end_draft_magnitude);
     end_draft_magnitude++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "end_draft_magnitude", &end_draft_magnitude, 0)
         && end_draft_magnitude == loftedsurface->end_draft_magnitude)
       pass ();
     else
       fail ("LOFTEDSURFACE.end_draft_magnitude [BD] set+1 %g != %g", loftedsurface->end_draft_magnitude, end_draft_magnitude);
     loftedsurface->end_draft_magnitude--;
   }
   {
     BITCODE_BL end_marker;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "end_marker", &end_marker, NULL)
         && end_marker == loftedsurface->end_marker)
       pass ();
     else
       fail ("LOFTEDSURFACE.end_marker [BL] %u != %u", loftedsurface->end_marker, end_marker);
     end_marker++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "end_marker", &end_marker, 0)
         && end_marker == loftedsurface->end_marker)
       pass ();
     else
       fail ("LOFTEDSURFACE.end_marker [BL] set+1 %u != %u", loftedsurface->end_marker, end_marker);
     loftedsurface->end_marker--;
   }
   {
     struct _dwg_entity_3DSOLID* extra_acis_data;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "extra_acis_data", &extra_acis_data, NULL)
         && !memcmp (&extra_acis_data, &loftedsurface->extra_acis_data, sizeof (struct _dwg_entity_3DSOLID*)))
         pass ();
     else
         fail ("LOFTEDSURFACE.extra_acis_data [struct _dwg_entity_3DSOLID*]");
   }
   {
     BITCODE_H* guide_curves;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "num_guide_curves", &count, NULL)
         && dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "guide_curves", &guide_curves, NULL)
         && guide_curves == loftedsurface->guide_curves)
       pass ();
     else
       fail ("LOFTEDSURFACE.guide_curves [H*] * %u num_guide_curves", count);
   }
   {
     BITCODE_B has_revision_guid;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "has_revision_guid", &has_revision_guid, NULL)
         && has_revision_guid == loftedsurface->has_revision_guid)
       pass ();
     else
       fail ("LOFTEDSURFACE.has_revision_guid [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->has_revision_guid, has_revision_guid);
     has_revision_guid++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "has_revision_guid", &has_revision_guid, 0)
         && has_revision_guid == loftedsurface->has_revision_guid)
       pass ();
     else
       fail ("LOFTEDSURFACE.has_revision_guid [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->has_revision_guid, has_revision_guid);
     loftedsurface->has_revision_guid--;
   }
   {
     BITCODE_H history_id;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "history_id", &history_id, NULL)
         && !memcmp (&history_id, &loftedsurface->history_id, sizeof (BITCODE_H)))
         pass ();
     else
         fail ("LOFTEDSURFACE.history_id [H]");
   }
   {
     BITCODE_B isoline_present;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "isoline_present", &isoline_present, NULL)
         && isoline_present == loftedsurface->isoline_present)
       pass ();
     else
       fail ("LOFTEDSURFACE.isoline_present [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->isoline_present, isoline_present);
     isoline_present++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "isoline_present", &isoline_present, 0)
         && isoline_present == loftedsurface->isoline_present)
       pass ();
     else
       fail ("LOFTEDSURFACE.isoline_present [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->isoline_present, isoline_present);
     loftedsurface->isoline_present--;
   }
   {
     BITCODE_BL isolines;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "isolines", &isolines, NULL)
         && isolines == loftedsurface->isolines)
       pass ();
     else
       fail ("LOFTEDSURFACE.isolines [BL] %u != %u", loftedsurface->isolines, isolines);
     isolines++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "isolines", &isolines, 0)
         && isolines == loftedsurface->isolines)
       pass ();
     else
       fail ("LOFTEDSURFACE.isolines [BL] set+1 %u != %u", loftedsurface->isolines, isolines);
     loftedsurface->isolines--;
   }
   {
     BITCODE_BD* loft_entity_transmatrix;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "loft_entity_transmatrix", &loft_entity_transmatrix, NULL)
         && !memcmp (&loft_entity_transmatrix, &loftedsurface->loft_entity_transmatrix, sizeof (BITCODE_BD*)))
         pass ();
     else
         fail ("LOFTEDSURFACE.loft_entity_transmatrix [BD*]");
   }
   {
     Dwg_3DSOLID_material* materials;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "num_materials", &count, NULL)
         && dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "materials", &materials, NULL)
         && materials == loftedsurface->materials)
       pass ();
     else
       fail ("LOFTEDSURFACE.materials [Dwg_3DSOLID_material*] * %u num_materials", count);
   }
   {
     BITCODE_BS modeler_format_version;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "modeler_format_version", &modeler_format_version, NULL)
         && modeler_format_version == loftedsurface->modeler_format_version)
       pass ();
     else
       fail ("LOFTEDSURFACE.modeler_format_version [BS] %hu != %hu", loftedsurface->modeler_format_version, modeler_format_version);
     modeler_format_version++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "modeler_format_version", &modeler_format_version, 0)
         && modeler_format_version == loftedsurface->modeler_format_version)
       pass ();
     else
       fail ("LOFTEDSURFACE.modeler_format_version [BS] set+1 %hu != %hu", loftedsurface->modeler_format_version, modeler_format_version);
     loftedsurface->modeler_format_version--;
   }
   {
     BITCODE_B no_twist;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "no_twist", &no_twist, NULL)
         && no_twist == loftedsurface->no_twist)
       pass ();
     else
       fail ("LOFTEDSURFACE.no_twist [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->no_twist, no_twist);
     no_twist++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "no_twist", &no_twist, 0)
         && no_twist == loftedsurface->no_twist)
       pass ();
     else
       fail ("LOFTEDSURFACE.no_twist [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->no_twist, no_twist);
     loftedsurface->no_twist--;
   }
   {
     BITCODE_BL num_blocks;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "num_blocks", &num_blocks, NULL)
         && num_blocks == loftedsurface->num_blocks)
       pass ();
     else
       fail ("LOFTEDSURFACE.num_blocks [BL] %u != %u", loftedsurface->num_blocks, num_blocks);
     num_blocks++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "num_blocks", &num_blocks, 0)
         && num_blocks == loftedsurface->num_blocks)
       pass ();
     else
       fail ("LOFTEDSURFACE.num_blocks [BL] set+1 %u != %u", loftedsurface->num_blocks, num_blocks);
     loftedsurface->num_blocks--;
   }
   {
     BITCODE_BS num_cross_sections;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "num_cross_sections", &num_cross_sections, NULL)
         && num_cross_sections == loftedsurface->num_cross_sections)
       pass ();
     else
       fail ("LOFTEDSURFACE.num_cross_sections [BS] %hu != %hu", loftedsurface->num_cross_sections, num_cross_sections);
     num_cross_sections++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "num_cross_sections", &num_cross_sections, 0)
         && num_cross_sections == loftedsurface->num_cross_sections)
       pass ();
     else
       fail ("LOFTEDSURFACE.num_cross_sections [BS] set+1 %hu != %hu", loftedsurface->num_cross_sections, num_cross_sections);
     loftedsurface->num_cross_sections--;
   }
   {
     BITCODE_BS num_guide_curves;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "num_guide_curves", &num_guide_curves, NULL)
         && num_guide_curves == loftedsurface->num_guide_curves)
       pass ();
     else
       fail ("LOFTEDSURFACE.num_guide_curves [BS] %hu != %hu", loftedsurface->num_guide_curves, num_guide_curves);
     num_guide_curves++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "num_guide_curves", &num_guide_curves, 0)
         && num_guide_curves == loftedsurface->num_guide_curves)
       pass ();
     else
       fail ("LOFTEDSURFACE.num_guide_curves [BS] set+1 %hu != %hu", loftedsurface->num_guide_curves, num_guide_curves);
     loftedsurface->num_guide_curves--;
   }
   {
     BITCODE_BL num_materials;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "num_materials", &num_materials, NULL)
         && num_materials == loftedsurface->num_materials)
       pass ();
     else
       fail ("LOFTEDSURFACE.num_materials [BL] %u != %u", loftedsurface->num_materials, num_materials);
     num_materials++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "num_materials", &num_materials, 0)
         && num_materials == loftedsurface->num_materials)
       pass ();
     else
       fail ("LOFTEDSURFACE.num_materials [BL] set+1 %u != %u", loftedsurface->num_materials, num_materials);
     loftedsurface->num_materials--;
   }
   {
     BITCODE_BL num_silhouettes;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "num_silhouettes", &num_silhouettes, NULL)
         && num_silhouettes == loftedsurface->num_silhouettes)
       pass ();
     else
       fail ("LOFTEDSURFACE.num_silhouettes [BL] %u != %u", loftedsurface->num_silhouettes, num_silhouettes);
     num_silhouettes++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "num_silhouettes", &num_silhouettes, 0)
         && num_silhouettes == loftedsurface->num_silhouettes)
       pass ();
     else
       fail ("LOFTEDSURFACE.num_silhouettes [BL] set+1 %u != %u", loftedsurface->num_silhouettes, num_silhouettes);
     loftedsurface->num_silhouettes--;
   }
   {
     BITCODE_BL num_wires;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "num_wires", &num_wires, NULL)
         && num_wires == loftedsurface->num_wires)
       pass ();
     else
       fail ("LOFTEDSURFACE.num_wires [BL] %u != %u", loftedsurface->num_wires, num_wires);
     num_wires++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "num_wires", &num_wires, 0)
         && num_wires == loftedsurface->num_wires)
       pass ();
     else
       fail ("LOFTEDSURFACE.num_wires [BL] set+1 %u != %u", loftedsurface->num_wires, num_wires);
     loftedsurface->num_wires--;
   }
   {
     struct _dwg_object_entity* parent;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "parent", &parent, NULL)
         && !memcmp (&parent, &loftedsurface->parent, sizeof (struct _dwg_object_entity*)))
         pass ();
     else
         fail ("LOFTEDSURFACE.parent [struct _dwg_object_entity*]");
   }
   {
     BITCODE_H path_curve;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "path_curve", &path_curve, NULL)
         && !memcmp (&path_curve, &loftedsurface->path_curve, sizeof (BITCODE_H)))
         pass ();
     else
         fail ("LOFTEDSURFACE.path_curve [H]");
   }
   {
     BITCODE_BL plane_normal_lofting_type;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "plane_normal_lofting_type", &plane_normal_lofting_type, NULL)
         && plane_normal_lofting_type == loftedsurface->plane_normal_lofting_type)
       pass ();
     else
       fail ("LOFTEDSURFACE.plane_normal_lofting_type [BL] %u != %u", loftedsurface->plane_normal_lofting_type, plane_normal_lofting_type);
     plane_normal_lofting_type++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "plane_normal_lofting_type", &plane_normal_lofting_type, 0)
         && plane_normal_lofting_type == loftedsurface->plane_normal_lofting_type)
       pass ();
     else
       fail ("LOFTEDSURFACE.plane_normal_lofting_type [BL] set+1 %u != %u", loftedsurface->plane_normal_lofting_type, plane_normal_lofting_type);
     loftedsurface->plane_normal_lofting_type--;
   }
   {
     BITCODE_3BD point;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "point", &point, NULL)
         && !memcmp (&point, &loftedsurface->point, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("LOFTEDSURFACE.point [3BD]");
   }
   {
     BITCODE_B point_present;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "point_present", &point_present, NULL)
         && point_present == loftedsurface->point_present)
       pass ();
     else
       fail ("LOFTEDSURFACE.point_present [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->point_present, point_present);
     point_present++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "point_present", &point_present, 0)
         && point_present == loftedsurface->point_present)
       pass ();
     else
       fail ("LOFTEDSURFACE.point_present [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->point_present, point_present);
     loftedsurface->point_present--;
   }
   {
     BITCODE_RC revision_bytes[9];
-    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "revision_bytes[9]", &revision_bytes, NULL)
+    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "revision_bytes", &revision_bytes, NULL)
         && !memcmp (&revision_bytes, &loftedsurface->revision_bytes, sizeof (BITCODE_RC)))
         pass ();
     else
-        fail ("LOFTEDSURFACE.revision_bytes[9] [RC]");
+        fail ("LOFTEDSURFACE.revision_bytes [RC]");
   }
   {
     BITCODE_RC revision_guid[39];
-    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "revision_guid[39]", &revision_guid, NULL)
+    if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "revision_guid", &revision_guid, NULL)
         && !memcmp (&revision_guid, &loftedsurface->revision_guid, sizeof (BITCODE_RC)))
         pass ();
     else
-        fail ("LOFTEDSURFACE.revision_guid[39] [RC]");
+        fail ("LOFTEDSURFACE.revision_guid [RC]");
   }
   {
     BITCODE_BL revision_major;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "revision_major", &revision_major, NULL)
         && revision_major == loftedsurface->revision_major)
       pass ();
     else
       fail ("LOFTEDSURFACE.revision_major [BL] %u != %u", loftedsurface->revision_major, revision_major);
     revision_major++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "revision_major", &revision_major, 0)
         && revision_major == loftedsurface->revision_major)
       pass ();
     else
       fail ("LOFTEDSURFACE.revision_major [BL] set+1 %u != %u", loftedsurface->revision_major, revision_major);
     loftedsurface->revision_major--;
   }
   {
     BITCODE_BS revision_minor1;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "revision_minor1", &revision_minor1, NULL)
         && revision_minor1 == loftedsurface->revision_minor1)
       pass ();
     else
       fail ("LOFTEDSURFACE.revision_minor1 [BS] %hu != %hu", loftedsurface->revision_minor1, revision_minor1);
     revision_minor1++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "revision_minor1", &revision_minor1, 0)
         && revision_minor1 == loftedsurface->revision_minor1)
       pass ();
     else
       fail ("LOFTEDSURFACE.revision_minor1 [BS] set+1 %hu != %hu", loftedsurface->revision_minor1, revision_minor1);
     loftedsurface->revision_minor1--;
   }
   {
     BITCODE_BS revision_minor2;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "revision_minor2", &revision_minor2, NULL)
         && revision_minor2 == loftedsurface->revision_minor2)
       pass ();
     else
       fail ("LOFTEDSURFACE.revision_minor2 [BS] %hu != %hu", loftedsurface->revision_minor2, revision_minor2);
     revision_minor2++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "revision_minor2", &revision_minor2, 0)
         && revision_minor2 == loftedsurface->revision_minor2)
       pass ();
     else
       fail ("LOFTEDSURFACE.revision_minor2 [BS] set+1 %hu != %hu", loftedsurface->revision_minor2, revision_minor2);
     loftedsurface->revision_minor2--;
   }
   {
     BITCODE_B ruled_surface;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "ruled_surface", &ruled_surface, NULL)
         && ruled_surface == loftedsurface->ruled_surface)
       pass ();
     else
       fail ("LOFTEDSURFACE.ruled_surface [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->ruled_surface, ruled_surface);
     ruled_surface++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "ruled_surface", &ruled_surface, 0)
         && ruled_surface == loftedsurface->ruled_surface)
       pass ();
     else
       fail ("LOFTEDSURFACE.ruled_surface [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->ruled_surface, ruled_surface);
     loftedsurface->ruled_surface--;
   }
   {
     BITCODE_BL sab_size;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "sab_size", &sab_size, NULL)
         && sab_size == loftedsurface->sab_size)
       pass ();
     else
       fail ("LOFTEDSURFACE.sab_size [BL] %u != %u", loftedsurface->sab_size, sab_size);
     sab_size++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "sab_size", &sab_size, 0)
         && sab_size == loftedsurface->sab_size)
       pass ();
     else
       fail ("LOFTEDSURFACE.sab_size [BL] set+1 %u != %u", loftedsurface->sab_size, sab_size);
     loftedsurface->sab_size--;
   }
   {
     Dwg_3DSOLID_silhouette* silhouettes;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "num_silhouettes", &count, NULL)
         && dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "silhouettes", &silhouettes, NULL)
         && silhouettes == loftedsurface->silhouettes)
       pass ();
     else
       fail ("LOFTEDSURFACE.silhouettes [Dwg_3DSOLID_silhouette*] * %u num_silhouettes", count);
   }
   {
     BITCODE_B simple_surfaces;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "simple_surfaces", &simple_surfaces, NULL)
         && simple_surfaces == loftedsurface->simple_surfaces)
       pass ();
     else
       fail ("LOFTEDSURFACE.simple_surfaces [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->simple_surfaces, simple_surfaces);
     simple_surfaces++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "simple_surfaces", &simple_surfaces, 0)
         && simple_surfaces == loftedsurface->simple_surfaces)
       pass ();
     else
       fail ("LOFTEDSURFACE.simple_surfaces [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->simple_surfaces, simple_surfaces);
     loftedsurface->simple_surfaces--;
   }
   {
     BITCODE_B solid;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "solid", &solid, NULL)
         && solid == loftedsurface->solid)
       pass ();
     else
       fail ("LOFTEDSURFACE.solid [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->solid, solid);
     solid++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "solid", &solid, 0)
         && solid == loftedsurface->solid)
       pass ();
     else
       fail ("LOFTEDSURFACE.solid [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->solid, solid);
     loftedsurface->solid--;
   }
   {
     BITCODE_BD start_draft_angle;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "start_draft_angle", &start_draft_angle, NULL)
         && start_draft_angle == loftedsurface->start_draft_angle)
       pass ();
     else
       fail ("LOFTEDSURFACE.start_draft_angle [BD] %g != %g", loftedsurface->start_draft_angle, start_draft_angle);
     start_draft_angle++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "start_draft_angle", &start_draft_angle, 0)
         && start_draft_angle == loftedsurface->start_draft_angle)
       pass ();
     else
       fail ("LOFTEDSURFACE.start_draft_angle [BD] set+1 %g != %g", loftedsurface->start_draft_angle, start_draft_angle);
     loftedsurface->start_draft_angle--;
   }
   {
     BITCODE_BD start_draft_magnitude;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "start_draft_magnitude", &start_draft_magnitude, NULL)
         && start_draft_magnitude == loftedsurface->start_draft_magnitude)
       pass ();
     else
       fail ("LOFTEDSURFACE.start_draft_magnitude [BD] %g != %g", loftedsurface->start_draft_magnitude, start_draft_magnitude);
     start_draft_magnitude++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "start_draft_magnitude", &start_draft_magnitude, 0)
         && start_draft_magnitude == loftedsurface->start_draft_magnitude)
       pass ();
     else
       fail ("LOFTEDSURFACE.start_draft_magnitude [BD] set+1 %g != %g", loftedsurface->start_draft_magnitude, start_draft_magnitude);
     loftedsurface->start_draft_magnitude--;
   }
   {
     BITCODE_BS u_isolines;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "u_isolines", &u_isolines, NULL)
         && u_isolines == loftedsurface->u_isolines)
       pass ();
     else
       fail ("LOFTEDSURFACE.u_isolines [BS] %hu != %hu", loftedsurface->u_isolines, u_isolines);
     u_isolines++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "u_isolines", &u_isolines, 0)
         && u_isolines == loftedsurface->u_isolines)
       pass ();
     else
       fail ("LOFTEDSURFACE.u_isolines [BS] set+1 %hu != %hu", loftedsurface->u_isolines, u_isolines);
     loftedsurface->u_isolines--;
   }
   {
     BITCODE_B unknown;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "unknown", &unknown, NULL)
         && unknown == loftedsurface->unknown)
       pass ();
     else
       fail ("LOFTEDSURFACE.unknown [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->unknown, unknown);
     unknown++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "unknown", &unknown, 0)
         && unknown == loftedsurface->unknown)
       pass ();
     else
       fail ("LOFTEDSURFACE.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->unknown, unknown);
     loftedsurface->unknown--;
   }
   {
     BITCODE_BS v_isolines;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "v_isolines", &v_isolines, NULL)
         && v_isolines == loftedsurface->v_isolines)
       pass ();
     else
       fail ("LOFTEDSURFACE.v_isolines [BS] %hu != %hu", loftedsurface->v_isolines, v_isolines);
     v_isolines++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "v_isolines", &v_isolines, 0)
         && v_isolines == loftedsurface->v_isolines)
       pass ();
     else
       fail ("LOFTEDSURFACE.v_isolines [BS] set+1 %hu != %hu", loftedsurface->v_isolines, v_isolines);
     loftedsurface->v_isolines--;
   }
   {
     BITCODE_BS version;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "version", &version, NULL)
         && version == loftedsurface->version)
       pass ();
     else
       fail ("LOFTEDSURFACE.version [BS] %hu != %hu", loftedsurface->version, version);
     version++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "version", &version, 0)
         && version == loftedsurface->version)
       pass ();
     else
       fail ("LOFTEDSURFACE.version [BS] set+1 %hu != %hu", loftedsurface->version, version);
     loftedsurface->version--;
   }
   {
     BITCODE_B virtual_guide;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "virtual_guide", &virtual_guide, NULL)
         && virtual_guide == loftedsurface->virtual_guide)
       pass ();
     else
       fail ("LOFTEDSURFACE.virtual_guide [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->virtual_guide, virtual_guide);
     virtual_guide++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "virtual_guide", &virtual_guide, 0)
         && virtual_guide == loftedsurface->virtual_guide)
       pass ();
     else
       fail ("LOFTEDSURFACE.virtual_guide [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->virtual_guide, virtual_guide);
     loftedsurface->virtual_guide--;
   }
   {
     BITCODE_B wireframe_data_present;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "wireframe_data_present", &wireframe_data_present, NULL)
         && wireframe_data_present == loftedsurface->wireframe_data_present)
       pass ();
     else
       fail ("LOFTEDSURFACE.wireframe_data_present [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->wireframe_data_present, wireframe_data_present);
     wireframe_data_present++;
     if (dwg_dynapi_entity_set_value (loftedsurface, "LOFTEDSURFACE", "wireframe_data_present", &wireframe_data_present, 0)
         && wireframe_data_present == loftedsurface->wireframe_data_present)
       pass ();
     else
       fail ("LOFTEDSURFACE.wireframe_data_present [B] set+1 " FORMAT_B " != " FORMAT_B "", loftedsurface->wireframe_data_present, wireframe_data_present);
     loftedsurface->wireframe_data_present--;
   }
   {
     Dwg_3DSOLID_wire* wires;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "num_wires", &count, NULL)
         && dwg_dynapi_entity_value (loftedsurface, "LOFTEDSURFACE", "wires", &wires, NULL)
         && wires == loftedsurface->wires)
       pass ();
     else
       fail ("LOFTEDSURFACE.wires [Dwg_3DSOLID_wire*] * %u num_wires", count);
   }
   if (failed && (is_class_unstable ("LOFTEDSURFACE") || is_class_debugging ("LOFTEDSURFACE")))
     {
       ok ("%s failed %d tests (TODO unstable)", "LOFTEDSURFACE", failed);
       failed = 0;
     }
   return failed;
 }
@@ -17790,587 +17790,587 @@ static int test_NAVISWORKSMODEL (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
   Dwg_Entity_NAVISWORKSMODEL *restrict navisworksmodel = obj->tio.entity->tio.NAVISWORKSMODEL;
   failed = 0;
   if (!obj_obj || !navisworksmodel)
     {
       fail ("NULL NAVISWORKSMODEL");
       return 1;
     }
   {
     BITCODE_H definition;
     if (dwg_dynapi_entity_value (navisworksmodel, "NAVISWORKSMODEL", "definition", &definition, NULL)
         && !memcmp (&definition, &navisworksmodel->definition, sizeof (BITCODE_H)))
         pass ();
     else
         fail ("NAVISWORKSMODEL.definition [H]");
   }
   {
     BITCODE_BS flags;
     if (dwg_dynapi_entity_value (navisworksmodel, "NAVISWORKSMODEL", "flags", &flags, NULL)
         && flags == navisworksmodel->flags)
       pass ();
     else
       fail ("NAVISWORKSMODEL.flags [BS] %hu != %hu", navisworksmodel->flags, flags);
     flags++;
     if (dwg_dynapi_entity_set_value (navisworksmodel, "NAVISWORKSMODEL", "flags", &flags, 0)
         && flags == navisworksmodel->flags)
       pass ();
     else
       fail ("NAVISWORKSMODEL.flags [BS] set+1 %hu != %hu", navisworksmodel->flags, flags);
     navisworksmodel->flags--;
   }
   {
     struct _dwg_object_entity* parent;
     if (dwg_dynapi_entity_value (navisworksmodel, "NAVISWORKSMODEL", "parent", &parent, NULL)
         && !memcmp (&parent, &navisworksmodel->parent, sizeof (struct _dwg_object_entity*)))
         pass ();
     else
         fail ("NAVISWORKSMODEL.parent [struct _dwg_object_entity*]");
   }
   {
     BITCODE_BD* transmatrix;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (navisworksmodel, "NAVISWORKSMODEL", "num_transmatrix", &count, NULL)
         && dwg_dynapi_entity_value (navisworksmodel, "NAVISWORKSMODEL", "transmatrix", &transmatrix, NULL)
         && transmatrix == navisworksmodel->transmatrix)
       pass ();
     else
       fail ("NAVISWORKSMODEL.transmatrix [BD*] * %u num_transmatrix", count);
   }
   {
     BITCODE_BD unitfactor;
     if (dwg_dynapi_entity_value (navisworksmodel, "NAVISWORKSMODEL", "unitfactor", &unitfactor, NULL)
         && unitfactor == navisworksmodel->unitfactor)
       pass ();
     else
       fail ("NAVISWORKSMODEL.unitfactor [BD] %g != %g", navisworksmodel->unitfactor, unitfactor);
     unitfactor++;
     if (dwg_dynapi_entity_set_value (navisworksmodel, "NAVISWORKSMODEL", "unitfactor", &unitfactor, 0)
         && unitfactor == navisworksmodel->unitfactor)
       pass ();
     else
       fail ("NAVISWORKSMODEL.unitfactor [BD] set+1 %g != %g", navisworksmodel->unitfactor, unitfactor);
     navisworksmodel->unitfactor--;
   }
   if (failed && (is_class_unstable ("NAVISWORKSMODEL") || is_class_debugging ("NAVISWORKSMODEL")))
     {
       ok ("%s failed %d tests (TODO unstable)", "NAVISWORKSMODEL", failed);
       failed = 0;
     }
   return failed;
 }
 static int test_NURBSURFACE (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
   Dwg_Entity_NURBSURFACE *restrict nurbsurface = obj->tio.entity->tio.NURBSURFACE;
   failed = 0;
   if (!obj_obj || !nurbsurface)
     {
       fail ("NULL NURBSURFACE");
       return 1;
     }
   {
     BITCODE_B _dxf_sab_converted;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "_dxf_sab_converted", &_dxf_sab_converted, NULL)
         && _dxf_sab_converted == nurbsurface->_dxf_sab_converted)
       pass ();
     else
       fail ("NURBSURFACE._dxf_sab_converted [B] " FORMAT_B " != " FORMAT_B "", nurbsurface->_dxf_sab_converted, _dxf_sab_converted);
     _dxf_sab_converted++;
     if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "_dxf_sab_converted", &_dxf_sab_converted, 0)
         && _dxf_sab_converted == nurbsurface->_dxf_sab_converted)
       pass ();
     else
       fail ("NURBSURFACE._dxf_sab_converted [B] set+1 " FORMAT_B " != " FORMAT_B "", nurbsurface->_dxf_sab_converted, _dxf_sab_converted);
     nurbsurface->_dxf_sab_converted--;
   }
   {
     BITCODE_RC* acis_data;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "acis_data", &acis_data, NULL)
         && acis_data
            ? strEQ ((char *)acis_data, (char *)nurbsurface->acis_data)
            : !nurbsurface->acis_data)
       pass ();
     else
       fail ("NURBSURFACE.acis_data [RC*] '%s' <> '%s'", acis_data, nurbsurface->acis_data);
   }
   {
     BITCODE_B acis_empty;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "acis_empty", &acis_empty, NULL)
         && acis_empty == nurbsurface->acis_empty)
       pass ();
     else
       fail ("NURBSURFACE.acis_empty [B] " FORMAT_B " != " FORMAT_B "", nurbsurface->acis_empty, acis_empty);
     acis_empty++;
     if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "acis_empty", &acis_empty, 0)
         && acis_empty == nurbsurface->acis_empty)
       pass ();
     else
       fail ("NURBSURFACE.acis_empty [B] set+1 " FORMAT_B " != " FORMAT_B "", nurbsurface->acis_empty, acis_empty);
     nurbsurface->acis_empty--;
   }
   {
     BITCODE_B acis_empty2;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "acis_empty2", &acis_empty2, NULL)
         && acis_empty2 == nurbsurface->acis_empty2)
       pass ();
     else
       fail ("NURBSURFACE.acis_empty2 [B] " FORMAT_B " != " FORMAT_B "", nurbsurface->acis_empty2, acis_empty2);
     acis_empty2++;
     if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "acis_empty2", &acis_empty2, 0)
         && acis_empty2 == nurbsurface->acis_empty2)
       pass ();
     else
       fail ("NURBSURFACE.acis_empty2 [B] set+1 " FORMAT_B " != " FORMAT_B "", nurbsurface->acis_empty2, acis_empty2);
     nurbsurface->acis_empty2--;
   }
   {
     BITCODE_B acis_empty_bit;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "acis_empty_bit", &acis_empty_bit, NULL)
         && acis_empty_bit == nurbsurface->acis_empty_bit)
       pass ();
     else
       fail ("NURBSURFACE.acis_empty_bit [B] " FORMAT_B " != " FORMAT_B "", nurbsurface->acis_empty_bit, acis_empty_bit);
     acis_empty_bit++;
     if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "acis_empty_bit", &acis_empty_bit, 0)
         && acis_empty_bit == nurbsurface->acis_empty_bit)
       pass ();
     else
       fail ("NURBSURFACE.acis_empty_bit [B] set+1 " FORMAT_B " != " FORMAT_B "", nurbsurface->acis_empty_bit, acis_empty_bit);
     nurbsurface->acis_empty_bit--;
   }
   {
     BITCODE_BL* block_size;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "block_size", &block_size, NULL)
         && !memcmp (&block_size, &nurbsurface->block_size, sizeof (BITCODE_BL*)))
         pass ();
     else
         fail ("NURBSURFACE.block_size [BL*]");
   }
   {
     BITCODE_B cv_hull_display;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "cv_hull_display", &cv_hull_display, NULL)
         && cv_hull_display == nurbsurface->cv_hull_display)
       pass ();
     else
       fail ("NURBSURFACE.cv_hull_display [B] " FORMAT_B " != " FORMAT_B "", nurbsurface->cv_hull_display, cv_hull_display);
     cv_hull_display++;
     if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "cv_hull_display", &cv_hull_display, 0)
         && cv_hull_display == nurbsurface->cv_hull_display)
       pass ();
     else
       fail ("NURBSURFACE.cv_hull_display [B] set+1 " FORMAT_B " != " FORMAT_B "", nurbsurface->cv_hull_display, cv_hull_display);
     nurbsurface->cv_hull_display--;
   }
   {
     char ** encr_sat_data;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "encr_sat_data", &encr_sat_data, NULL)
         && !memcmp (&encr_sat_data, &nurbsurface->encr_sat_data, sizeof (nurbsurface->encr_sat_data)))
       pass ();
     else
       fail ("NURBSURFACE.encr_sat_data [char **]");
   }
   {
     BITCODE_BL end_marker;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "end_marker", &end_marker, NULL)
         && end_marker == nurbsurface->end_marker)
       pass ();
     else
       fail ("NURBSURFACE.end_marker [BL] %u != %u", nurbsurface->end_marker, end_marker);
     end_marker++;
     if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "end_marker", &end_marker, 0)
         && end_marker == nurbsurface->end_marker)
       pass ();
     else
       fail ("NURBSURFACE.end_marker [BL] set+1 %u != %u", nurbsurface->end_marker, end_marker);
     nurbsurface->end_marker--;
   }
   {
     struct _dwg_entity_3DSOLID* extra_acis_data;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "extra_acis_data", &extra_acis_data, NULL)
         && !memcmp (&extra_acis_data, &nurbsurface->extra_acis_data, sizeof (struct _dwg_entity_3DSOLID*)))
         pass ();
     else
         fail ("NURBSURFACE.extra_acis_data [struct _dwg_entity_3DSOLID*]");
   }
   {
     BITCODE_B has_revision_guid;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "has_revision_guid", &has_revision_guid, NULL)
         && has_revision_guid == nurbsurface->has_revision_guid)
       pass ();
     else
       fail ("NURBSURFACE.has_revision_guid [B] " FORMAT_B " != " FORMAT_B "", nurbsurface->has_revision_guid, has_revision_guid);
     has_revision_guid++;
     if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "has_revision_guid", &has_revision_guid, 0)
         && has_revision_guid == nurbsurface->has_revision_guid)
       pass ();
     else
       fail ("NURBSURFACE.has_revision_guid [B] set+1 " FORMAT_B " != " FORMAT_B "", nurbsurface->has_revision_guid, has_revision_guid);
     nurbsurface->has_revision_guid--;
   }
   {
     BITCODE_H history_id;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "history_id", &history_id, NULL)
         && !memcmp (&history_id, &nurbsurface->history_id, sizeof (BITCODE_H)))
         pass ();
     else
         fail ("NURBSURFACE.history_id [H]");
   }
   {
     BITCODE_B isoline_present;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "isoline_present", &isoline_present, NULL)
         && isoline_present == nurbsurface->isoline_present)
       pass ();
     else
       fail ("NURBSURFACE.isoline_present [B] " FORMAT_B " != " FORMAT_B "", nurbsurface->isoline_present, isoline_present);
     isoline_present++;
     if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "isoline_present", &isoline_present, 0)
         && isoline_present == nurbsurface->isoline_present)
       pass ();
     else
       fail ("NURBSURFACE.isoline_present [B] set+1 " FORMAT_B " != " FORMAT_B "", nurbsurface->isoline_present, isoline_present);
     nurbsurface->isoline_present--;
   }
   {
     BITCODE_BL isolines;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "isolines", &isolines, NULL)
         && isolines == nurbsurface->isolines)
       pass ();
     else
       fail ("NURBSURFACE.isolines [BL] %u != %u", nurbsurface->isolines, isolines);
     isolines++;
     if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "isolines", &isolines, 0)
         && isolines == nurbsurface->isolines)
       pass ();
     else
       fail ("NURBSURFACE.isolines [BL] set+1 %u != %u", nurbsurface->isolines, isolines);
     nurbsurface->isolines--;
   }
   {
     Dwg_3DSOLID_material* materials;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "num_materials", &count, NULL)
         && dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "materials", &materials, NULL)
         && materials == nurbsurface->materials)
       pass ();
     else
       fail ("NURBSURFACE.materials [Dwg_3DSOLID_material*] * %u num_materials", count);
   }
   {
     BITCODE_BL num_blocks;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "num_blocks", &num_blocks, NULL)
         && num_blocks == nurbsurface->num_blocks)
       pass ();
     else
       fail ("NURBSURFACE.num_blocks [BL] %u != %u", nurbsurface->num_blocks, num_blocks);
     num_blocks++;
     if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "num_blocks", &num_blocks, 0)
         && num_blocks == nurbsurface->num_blocks)
       pass ();
     else
       fail ("NURBSURFACE.num_blocks [BL] set+1 %u != %u", nurbsurface->num_blocks, num_blocks);
     nurbsurface->num_blocks--;
   }
   {
     BITCODE_BL num_materials;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "num_materials", &num_materials, NULL)
         && num_materials == nurbsurface->num_materials)
       pass ();
     else
       fail ("NURBSURFACE.num_materials [BL] %u != %u", nurbsurface->num_materials, num_materials);
     num_materials++;
     if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "num_materials", &num_materials, 0)
         && num_materials == nurbsurface->num_materials)
       pass ();
     else
       fail ("NURBSURFACE.num_materials [BL] set+1 %u != %u", nurbsurface->num_materials, num_materials);
     nurbsurface->num_materials--;
   }
   {
     BITCODE_BL num_silhouettes;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "num_silhouettes", &num_silhouettes, NULL)
         && num_silhouettes == nurbsurface->num_silhouettes)
       pass ();
     else
       fail ("NURBSURFACE.num_silhouettes [BL] %u != %u", nurbsurface->num_silhouettes, num_silhouettes);
     num_silhouettes++;
     if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "num_silhouettes", &num_silhouettes, 0)
         && num_silhouettes == nurbsurface->num_silhouettes)
       pass ();
     else
       fail ("NURBSURFACE.num_silhouettes [BL] set+1 %u != %u", nurbsurface->num_silhouettes, num_silhouettes);
     nurbsurface->num_silhouettes--;
   }
   {
     BITCODE_BL num_wires;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "num_wires", &num_wires, NULL)
         && num_wires == nurbsurface->num_wires)
       pass ();
     else
       fail ("NURBSURFACE.num_wires [BL] %u != %u", nurbsurface->num_wires, num_wires);
     num_wires++;
     if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "num_wires", &num_wires, 0)
         && num_wires == nurbsurface->num_wires)
       pass ();
     else
       fail ("NURBSURFACE.num_wires [BL] set+1 %u != %u", nurbsurface->num_wires, num_wires);
     nurbsurface->num_wires--;
   }
   {
     struct _dwg_object_entity* parent;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "parent", &parent, NULL)
         && !memcmp (&parent, &nurbsurface->parent, sizeof (struct _dwg_object_entity*)))
         pass ();
     else
         fail ("NURBSURFACE.parent [struct _dwg_object_entity*]");
   }
   {
     BITCODE_3BD point;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "point", &point, NULL)
         && !memcmp (&point, &nurbsurface->point, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("NURBSURFACE.point [3BD]");
   }
   {
     BITCODE_B point_present;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "point_present", &point_present, NULL)
         && point_present == nurbsurface->point_present)
       pass ();
     else
       fail ("NURBSURFACE.point_present [B] " FORMAT_B " != " FORMAT_B "", nurbsurface->point_present, point_present);
     point_present++;
     if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "point_present", &point_present, 0)
         && point_present == nurbsurface->point_present)
       pass ();
     else
       fail ("NURBSURFACE.point_present [B] set+1 " FORMAT_B " != " FORMAT_B "", nurbsurface->point_present, point_present);
     nurbsurface->point_present--;
   }
   {
     BITCODE_RC revision_bytes[9];
-    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "revision_bytes[9]", &revision_bytes, NULL)
+    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "revision_bytes", &revision_bytes, NULL)
         && !memcmp (&revision_bytes, &nurbsurface->revision_bytes, sizeof (BITCODE_RC)))
         pass ();
     else
-        fail ("NURBSURFACE.revision_bytes[9] [RC]");
+        fail ("NURBSURFACE.revision_bytes [RC]");
   }
   {
     BITCODE_RC revision_guid[39];
-    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "revision_guid[39]", &revision_guid, NULL)
+    if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "revision_guid", &revision_guid, NULL)
         && !memcmp (&revision_guid, &nurbsurface->revision_guid, sizeof (BITCODE_RC)))
         pass ();
     else
-        fail ("NURBSURFACE.revision_guid[39] [RC]");
+        fail ("NURBSURFACE.revision_guid [RC]");
   }
   {
     BITCODE_BL revision_major;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "revision_major", &revision_major, NULL)
         && revision_major == nurbsurface->revision_major)
       pass ();
     else
       fail ("NURBSURFACE.revision_major [BL] %u != %u", nurbsurface->revision_major, revision_major);
     revision_major++;
     if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "revision_major", &revision_major, 0)
         && revision_major == nurbsurface->revision_major)
       pass ();
     else
       fail ("NURBSURFACE.revision_major [BL] set+1 %u != %u", nurbsurface->revision_major, revision_major);
     nurbsurface->revision_major--;
   }
   {
     BITCODE_BS revision_minor1;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "revision_minor1", &revision_minor1, NULL)
         && revision_minor1 == nurbsurface->revision_minor1)
       pass ();
     else
       fail ("NURBSURFACE.revision_minor1 [BS] %hu != %hu", nurbsurface->revision_minor1, revision_minor1);
     revision_minor1++;
     if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "revision_minor1", &revision_minor1, 0)
         && revision_minor1 == nurbsurface->revision_minor1)
       pass ();
     else
       fail ("NURBSURFACE.revision_minor1 [BS] set+1 %hu != %hu", nurbsurface->revision_minor1, revision_minor1);
     nurbsurface->revision_minor1--;
   }
   {
     BITCODE_BS revision_minor2;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "revision_minor2", &revision_minor2, NULL)
         && revision_minor2 == nurbsurface->revision_minor2)
       pass ();
     else
       fail ("NURBSURFACE.revision_minor2 [BS] %hu != %hu", nurbsurface->revision_minor2, revision_minor2);
     revision_minor2++;
     if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "revision_minor2", &revision_minor2, 0)
         && revision_minor2 == nurbsurface->revision_minor2)
       pass ();
     else
       fail ("NURBSURFACE.revision_minor2 [BS] set+1 %hu != %hu", nurbsurface->revision_minor2, revision_minor2);
     nurbsurface->revision_minor2--;
   }
   {
     BITCODE_BL sab_size;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "sab_size", &sab_size, NULL)
         && sab_size == nurbsurface->sab_size)
       pass ();
     else
       fail ("NURBSURFACE.sab_size [BL] %u != %u", nurbsurface->sab_size, sab_size);
     sab_size++;
     if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "sab_size", &sab_size, 0)
         && sab_size == nurbsurface->sab_size)
       pass ();
     else
       fail ("NURBSURFACE.sab_size [BL] set+1 %u != %u", nurbsurface->sab_size, sab_size);
     nurbsurface->sab_size--;
   }
   {
     BITCODE_BS short170;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "short170", &short170, NULL)
         && short170 == nurbsurface->short170)
       pass ();
     else
       fail ("NURBSURFACE.short170 [BS] %hu != %hu", nurbsurface->short170, short170);
     short170++;
     if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "short170", &short170, 0)
         && short170 == nurbsurface->short170)
       pass ();
     else
       fail ("NURBSURFACE.short170 [BS] set+1 %hu != %hu", nurbsurface->short170, short170);
     nurbsurface->short170--;
   }
   {
     Dwg_3DSOLID_silhouette* silhouettes;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "num_silhouettes", &count, NULL)
         && dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "silhouettes", &silhouettes, NULL)
         && silhouettes == nurbsurface->silhouettes)
       pass ();
     else
       fail ("NURBSURFACE.silhouettes [Dwg_3DSOLID_silhouette*] * %u num_silhouettes", count);
   }
   {
     BITCODE_BS u_isolines;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "u_isolines", &u_isolines, NULL)
         && u_isolines == nurbsurface->u_isolines)
       pass ();
     else
       fail ("NURBSURFACE.u_isolines [BS] %hu != %hu", nurbsurface->u_isolines, u_isolines);
     u_isolines++;
     if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "u_isolines", &u_isolines, 0)
         && u_isolines == nurbsurface->u_isolines)
       pass ();
     else
       fail ("NURBSURFACE.u_isolines [BS] set+1 %hu != %hu", nurbsurface->u_isolines, u_isolines);
     nurbsurface->u_isolines--;
   }
   {
     BITCODE_B unknown;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "unknown", &unknown, NULL)
         && unknown == nurbsurface->unknown)
       pass ();
     else
       fail ("NURBSURFACE.unknown [B] " FORMAT_B " != " FORMAT_B "", nurbsurface->unknown, unknown);
     unknown++;
     if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "unknown", &unknown, 0)
         && unknown == nurbsurface->unknown)
       pass ();
     else
       fail ("NURBSURFACE.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", nurbsurface->unknown, unknown);
     nurbsurface->unknown--;
   }
   {
     BITCODE_3BD uvec1;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "uvec1", &uvec1, NULL)
         && !memcmp (&uvec1, &nurbsurface->uvec1, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("NURBSURFACE.uvec1 [3BD]");
   }
   {
     BITCODE_3BD uvec2;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "uvec2", &uvec2, NULL)
         && !memcmp (&uvec2, &nurbsurface->uvec2, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("NURBSURFACE.uvec2 [3BD]");
   }
   {
     BITCODE_BS v_isolines;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "v_isolines", &v_isolines, NULL)
         && v_isolines == nurbsurface->v_isolines)
       pass ();
     else
       fail ("NURBSURFACE.v_isolines [BS] %hu != %hu", nurbsurface->v_isolines, v_isolines);
     v_isolines++;
     if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "v_isolines", &v_isolines, 0)
         && v_isolines == nurbsurface->v_isolines)
       pass ();
     else
       fail ("NURBSURFACE.v_isolines [BS] set+1 %hu != %hu", nurbsurface->v_isolines, v_isolines);
     nurbsurface->v_isolines--;
   }
   {
     BITCODE_BS version;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "version", &version, NULL)
         && version == nurbsurface->version)
       pass ();
     else
       fail ("NURBSURFACE.version [BS] %hu != %hu", nurbsurface->version, version);
     version++;
     if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "version", &version, 0)
         && version == nurbsurface->version)
       pass ();
     else
       fail ("NURBSURFACE.version [BS] set+1 %hu != %hu", nurbsurface->version, version);
     nurbsurface->version--;
   }
   {
     BITCODE_3BD vvec1;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "vvec1", &vvec1, NULL)
         && !memcmp (&vvec1, &nurbsurface->vvec1, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("NURBSURFACE.vvec1 [3BD]");
   }
   {
     BITCODE_3BD vvec2;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "vvec2", &vvec2, NULL)
         && !memcmp (&vvec2, &nurbsurface->vvec2, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("NURBSURFACE.vvec2 [3BD]");
   }
   {
     BITCODE_B wireframe_data_present;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "wireframe_data_present", &wireframe_data_present, NULL)
         && wireframe_data_present == nurbsurface->wireframe_data_present)
       pass ();
     else
       fail ("NURBSURFACE.wireframe_data_present [B] " FORMAT_B " != " FORMAT_B "", nurbsurface->wireframe_data_present, wireframe_data_present);
     wireframe_data_present++;
     if (dwg_dynapi_entity_set_value (nurbsurface, "NURBSURFACE", "wireframe_data_present", &wireframe_data_present, 0)
         && wireframe_data_present == nurbsurface->wireframe_data_present)
       pass ();
     else
       fail ("NURBSURFACE.wireframe_data_present [B] set+1 " FORMAT_B " != " FORMAT_B "", nurbsurface->wireframe_data_present, wireframe_data_present);
     nurbsurface->wireframe_data_present--;
   }
   {
     Dwg_3DSOLID_wire* wires;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "num_wires", &count, NULL)
         && dwg_dynapi_entity_value (nurbsurface, "NURBSURFACE", "wires", &wires, NULL)
         && wires == nurbsurface->wires)
       pass ();
     else
       fail ("NURBSURFACE.wires [Dwg_3DSOLID_wire*] * %u num_wires", count);
   }
   if (failed && (is_class_unstable ("NURBSURFACE") || is_class_debugging ("NURBSURFACE")))
     {
       ok ("%s failed %d tests (TODO unstable)", "NURBSURFACE", failed);
       failed = 0;
     }
   return failed;
 }
@@ -18590,499 +18590,499 @@ static int test_PDFUNDERLAY (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
   Dwg_Entity_PDFUNDERLAY *restrict pdfunderlay = obj->tio.entity->tio.PDFUNDERLAY;
   failed = 0;
   if (!obj_obj || !pdfunderlay)
     {
       fail ("NULL PDFUNDERLAY");
       return 1;
     }
   if (failed && (is_class_unstable ("PDFUNDERLAY") || is_class_debugging ("PDFUNDERLAY")))
     {
       ok ("%s failed %d tests (TODO unstable)", "PDFUNDERLAY", failed);
       failed = 0;
     }
   return failed;
 }
 static int test_PLANESURFACE (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
   Dwg_Entity_PLANESURFACE *restrict planesurface = obj->tio.entity->tio.PLANESURFACE;
   failed = 0;
   if (!obj_obj || !planesurface)
     {
       fail ("NULL PLANESURFACE");
       return 1;
     }
   {
     BITCODE_B _dxf_sab_converted;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "_dxf_sab_converted", &_dxf_sab_converted, NULL)
         && _dxf_sab_converted == planesurface->_dxf_sab_converted)
       pass ();
     else
       fail ("PLANESURFACE._dxf_sab_converted [B] " FORMAT_B " != " FORMAT_B "", planesurface->_dxf_sab_converted, _dxf_sab_converted);
     _dxf_sab_converted++;
     if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "_dxf_sab_converted", &_dxf_sab_converted, 0)
         && _dxf_sab_converted == planesurface->_dxf_sab_converted)
       pass ();
     else
       fail ("PLANESURFACE._dxf_sab_converted [B] set+1 " FORMAT_B " != " FORMAT_B "", planesurface->_dxf_sab_converted, _dxf_sab_converted);
     planesurface->_dxf_sab_converted--;
   }
   {
     BITCODE_RC* acis_data;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "acis_data", &acis_data, NULL)
         && acis_data
            ? strEQ ((char *)acis_data, (char *)planesurface->acis_data)
            : !planesurface->acis_data)
       pass ();
     else
       fail ("PLANESURFACE.acis_data [RC*] '%s' <> '%s'", acis_data, planesurface->acis_data);
   }
   {
     BITCODE_B acis_empty;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "acis_empty", &acis_empty, NULL)
         && acis_empty == planesurface->acis_empty)
       pass ();
     else
       fail ("PLANESURFACE.acis_empty [B] " FORMAT_B " != " FORMAT_B "", planesurface->acis_empty, acis_empty);
     acis_empty++;
     if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "acis_empty", &acis_empty, 0)
         && acis_empty == planesurface->acis_empty)
       pass ();
     else
       fail ("PLANESURFACE.acis_empty [B] set+1 " FORMAT_B " != " FORMAT_B "", planesurface->acis_empty, acis_empty);
     planesurface->acis_empty--;
   }
   {
     BITCODE_B acis_empty2;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "acis_empty2", &acis_empty2, NULL)
         && acis_empty2 == planesurface->acis_empty2)
       pass ();
     else
       fail ("PLANESURFACE.acis_empty2 [B] " FORMAT_B " != " FORMAT_B "", planesurface->acis_empty2, acis_empty2);
     acis_empty2++;
     if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "acis_empty2", &acis_empty2, 0)
         && acis_empty2 == planesurface->acis_empty2)
       pass ();
     else
       fail ("PLANESURFACE.acis_empty2 [B] set+1 " FORMAT_B " != " FORMAT_B "", planesurface->acis_empty2, acis_empty2);
     planesurface->acis_empty2--;
   }
   {
     BITCODE_B acis_empty_bit;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "acis_empty_bit", &acis_empty_bit, NULL)
         && acis_empty_bit == planesurface->acis_empty_bit)
       pass ();
     else
       fail ("PLANESURFACE.acis_empty_bit [B] " FORMAT_B " != " FORMAT_B "", planesurface->acis_empty_bit, acis_empty_bit);
     acis_empty_bit++;
     if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "acis_empty_bit", &acis_empty_bit, 0)
         && acis_empty_bit == planesurface->acis_empty_bit)
       pass ();
     else
       fail ("PLANESURFACE.acis_empty_bit [B] set+1 " FORMAT_B " != " FORMAT_B "", planesurface->acis_empty_bit, acis_empty_bit);
     planesurface->acis_empty_bit--;
   }
   {
     BITCODE_BL* block_size;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "block_size", &block_size, NULL)
         && !memcmp (&block_size, &planesurface->block_size, sizeof (BITCODE_BL*)))
         pass ();
     else
         fail ("PLANESURFACE.block_size [BL*]");
   }
   {
     BITCODE_BL class_version;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "class_version", &class_version, NULL)
         && class_version == planesurface->class_version)
       pass ();
     else
       fail ("PLANESURFACE.class_version [BL] %u != %u", planesurface->class_version, class_version);
     class_version++;
     if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "class_version", &class_version, 0)
         && class_version == planesurface->class_version)
       pass ();
     else
       fail ("PLANESURFACE.class_version [BL] set+1 %u != %u", planesurface->class_version, class_version);
     planesurface->class_version--;
   }
   {
     char ** encr_sat_data;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "encr_sat_data", &encr_sat_data, NULL)
         && !memcmp (&encr_sat_data, &planesurface->encr_sat_data, sizeof (planesurface->encr_sat_data)))
       pass ();
     else
       fail ("PLANESURFACE.encr_sat_data [char **]");
   }
   {
     BITCODE_BL end_marker;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "end_marker", &end_marker, NULL)
         && end_marker == planesurface->end_marker)
       pass ();
     else
       fail ("PLANESURFACE.end_marker [BL] %u != %u", planesurface->end_marker, end_marker);
     end_marker++;
     if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "end_marker", &end_marker, 0)
         && end_marker == planesurface->end_marker)
       pass ();
     else
       fail ("PLANESURFACE.end_marker [BL] set+1 %u != %u", planesurface->end_marker, end_marker);
     planesurface->end_marker--;
   }
   {
     struct _dwg_entity_3DSOLID* extra_acis_data;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "extra_acis_data", &extra_acis_data, NULL)
         && !memcmp (&extra_acis_data, &planesurface->extra_acis_data, sizeof (struct _dwg_entity_3DSOLID*)))
         pass ();
     else
         fail ("PLANESURFACE.extra_acis_data [struct _dwg_entity_3DSOLID*]");
   }
   {
     BITCODE_B has_revision_guid;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "has_revision_guid", &has_revision_guid, NULL)
         && has_revision_guid == planesurface->has_revision_guid)
       pass ();
     else
       fail ("PLANESURFACE.has_revision_guid [B] " FORMAT_B " != " FORMAT_B "", planesurface->has_revision_guid, has_revision_guid);
     has_revision_guid++;
     if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "has_revision_guid", &has_revision_guid, 0)
         && has_revision_guid == planesurface->has_revision_guid)
       pass ();
     else
       fail ("PLANESURFACE.has_revision_guid [B] set+1 " FORMAT_B " != " FORMAT_B "", planesurface->has_revision_guid, has_revision_guid);
     planesurface->has_revision_guid--;
   }
   {
     BITCODE_H history_id;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "history_id", &history_id, NULL)
         && !memcmp (&history_id, &planesurface->history_id, sizeof (BITCODE_H)))
         pass ();
     else
         fail ("PLANESURFACE.history_id [H]");
   }
   {
     BITCODE_B isoline_present;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "isoline_present", &isoline_present, NULL)
         && isoline_present == planesurface->isoline_present)
       pass ();
     else
       fail ("PLANESURFACE.isoline_present [B] " FORMAT_B " != " FORMAT_B "", planesurface->isoline_present, isoline_present);
     isoline_present++;
     if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "isoline_present", &isoline_present, 0)
         && isoline_present == planesurface->isoline_present)
       pass ();
     else
       fail ("PLANESURFACE.isoline_present [B] set+1 " FORMAT_B " != " FORMAT_B "", planesurface->isoline_present, isoline_present);
     planesurface->isoline_present--;
   }
   {
     BITCODE_BL isolines;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "isolines", &isolines, NULL)
         && isolines == planesurface->isolines)
       pass ();
     else
       fail ("PLANESURFACE.isolines [BL] %u != %u", planesurface->isolines, isolines);
     isolines++;
     if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "isolines", &isolines, 0)
         && isolines == planesurface->isolines)
       pass ();
     else
       fail ("PLANESURFACE.isolines [BL] set+1 %u != %u", planesurface->isolines, isolines);
     planesurface->isolines--;
   }
   {
     Dwg_3DSOLID_material* materials;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "num_materials", &count, NULL)
         && dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "materials", &materials, NULL)
         && materials == planesurface->materials)
       pass ();
     else
       fail ("PLANESURFACE.materials [Dwg_3DSOLID_material*] * %u num_materials", count);
   }
   {
     BITCODE_BS modeler_format_version;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "modeler_format_version", &modeler_format_version, NULL)
         && modeler_format_version == planesurface->modeler_format_version)
       pass ();
     else
       fail ("PLANESURFACE.modeler_format_version [BS] %hu != %hu", planesurface->modeler_format_version, modeler_format_version);
     modeler_format_version++;
     if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "modeler_format_version", &modeler_format_version, 0)
         && modeler_format_version == planesurface->modeler_format_version)
       pass ();
     else
       fail ("PLANESURFACE.modeler_format_version [BS] set+1 %hu != %hu", planesurface->modeler_format_version, modeler_format_version);
     planesurface->modeler_format_version--;
   }
   {
     BITCODE_BL num_blocks;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "num_blocks", &num_blocks, NULL)
         && num_blocks == planesurface->num_blocks)
       pass ();
     else
       fail ("PLANESURFACE.num_blocks [BL] %u != %u", planesurface->num_blocks, num_blocks);
     num_blocks++;
     if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "num_blocks", &num_blocks, 0)
         && num_blocks == planesurface->num_blocks)
       pass ();
     else
       fail ("PLANESURFACE.num_blocks [BL] set+1 %u != %u", planesurface->num_blocks, num_blocks);
     planesurface->num_blocks--;
   }
   {
     BITCODE_BL num_materials;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "num_materials", &num_materials, NULL)
         && num_materials == planesurface->num_materials)
       pass ();
     else
       fail ("PLANESURFACE.num_materials [BL] %u != %u", planesurface->num_materials, num_materials);
     num_materials++;
     if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "num_materials", &num_materials, 0)
         && num_materials == planesurface->num_materials)
       pass ();
     else
       fail ("PLANESURFACE.num_materials [BL] set+1 %u != %u", planesurface->num_materials, num_materials);
     planesurface->num_materials--;
   }
   {
     BITCODE_BL num_silhouettes;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "num_silhouettes", &num_silhouettes, NULL)
         && num_silhouettes == planesurface->num_silhouettes)
       pass ();
     else
       fail ("PLANESURFACE.num_silhouettes [BL] %u != %u", planesurface->num_silhouettes, num_silhouettes);
     num_silhouettes++;
     if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "num_silhouettes", &num_silhouettes, 0)
         && num_silhouettes == planesurface->num_silhouettes)
       pass ();
     else
       fail ("PLANESURFACE.num_silhouettes [BL] set+1 %u != %u", planesurface->num_silhouettes, num_silhouettes);
     planesurface->num_silhouettes--;
   }
   {
     BITCODE_BL num_wires;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "num_wires", &num_wires, NULL)
         && num_wires == planesurface->num_wires)
       pass ();
     else
       fail ("PLANESURFACE.num_wires [BL] %u != %u", planesurface->num_wires, num_wires);
     num_wires++;
     if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "num_wires", &num_wires, 0)
         && num_wires == planesurface->num_wires)
       pass ();
     else
       fail ("PLANESURFACE.num_wires [BL] set+1 %u != %u", planesurface->num_wires, num_wires);
     planesurface->num_wires--;
   }
   {
     struct _dwg_object_entity* parent;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "parent", &parent, NULL)
         && !memcmp (&parent, &planesurface->parent, sizeof (struct _dwg_object_entity*)))
         pass ();
     else
         fail ("PLANESURFACE.parent [struct _dwg_object_entity*]");
   }
   {
     BITCODE_3BD point;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "point", &point, NULL)
         && !memcmp (&point, &planesurface->point, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("PLANESURFACE.point [3BD]");
   }
   {
     BITCODE_B point_present;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "point_present", &point_present, NULL)
         && point_present == planesurface->point_present)
       pass ();
     else
       fail ("PLANESURFACE.point_present [B] " FORMAT_B " != " FORMAT_B "", planesurface->point_present, point_present);
     point_present++;
     if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "point_present", &point_present, 0)
         && point_present == planesurface->point_present)
       pass ();
     else
       fail ("PLANESURFACE.point_present [B] set+1 " FORMAT_B " != " FORMAT_B "", planesurface->point_present, point_present);
     planesurface->point_present--;
   }
   {
     BITCODE_RC revision_bytes[9];
-    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "revision_bytes[9]", &revision_bytes, NULL)
+    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "revision_bytes", &revision_bytes, NULL)
         && !memcmp (&revision_bytes, &planesurface->revision_bytes, sizeof (BITCODE_RC)))
         pass ();
     else
-        fail ("PLANESURFACE.revision_bytes[9] [RC]");
+        fail ("PLANESURFACE.revision_bytes [RC]");
   }
   {
     BITCODE_RC revision_guid[39];
-    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "revision_guid[39]", &revision_guid, NULL)
+    if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "revision_guid", &revision_guid, NULL)
         && !memcmp (&revision_guid, &planesurface->revision_guid, sizeof (BITCODE_RC)))
         pass ();
     else
-        fail ("PLANESURFACE.revision_guid[39] [RC]");
+        fail ("PLANESURFACE.revision_guid [RC]");
   }
   {
     BITCODE_BL revision_major;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "revision_major", &revision_major, NULL)
         && revision_major == planesurface->revision_major)
       pass ();
     else
       fail ("PLANESURFACE.revision_major [BL] %u != %u", planesurface->revision_major, revision_major);
     revision_major++;
     if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "revision_major", &revision_major, 0)
         && revision_major == planesurface->revision_major)
       pass ();
     else
       fail ("PLANESURFACE.revision_major [BL] set+1 %u != %u", planesurface->revision_major, revision_major);
     planesurface->revision_major--;
   }
   {
     BITCODE_BS revision_minor1;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "revision_minor1", &revision_minor1, NULL)
         && revision_minor1 == planesurface->revision_minor1)
       pass ();
     else
       fail ("PLANESURFACE.revision_minor1 [BS] %hu != %hu", planesurface->revision_minor1, revision_minor1);
     revision_minor1++;
     if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "revision_minor1", &revision_minor1, 0)
         && revision_minor1 == planesurface->revision_minor1)
       pass ();
     else
       fail ("PLANESURFACE.revision_minor1 [BS] set+1 %hu != %hu", planesurface->revision_minor1, revision_minor1);
     planesurface->revision_minor1--;
   }
   {
     BITCODE_BS revision_minor2;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "revision_minor2", &revision_minor2, NULL)
         && revision_minor2 == planesurface->revision_minor2)
       pass ();
     else
       fail ("PLANESURFACE.revision_minor2 [BS] %hu != %hu", planesurface->revision_minor2, revision_minor2);
     revision_minor2++;
     if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "revision_minor2", &revision_minor2, 0)
         && revision_minor2 == planesurface->revision_minor2)
       pass ();
     else
       fail ("PLANESURFACE.revision_minor2 [BS] set+1 %hu != %hu", planesurface->revision_minor2, revision_minor2);
     planesurface->revision_minor2--;
   }
   {
     BITCODE_BL sab_size;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "sab_size", &sab_size, NULL)
         && sab_size == planesurface->sab_size)
       pass ();
     else
       fail ("PLANESURFACE.sab_size [BL] %u != %u", planesurface->sab_size, sab_size);
     sab_size++;
     if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "sab_size", &sab_size, 0)
         && sab_size == planesurface->sab_size)
       pass ();
     else
       fail ("PLANESURFACE.sab_size [BL] set+1 %u != %u", planesurface->sab_size, sab_size);
     planesurface->sab_size--;
   }
   {
     Dwg_3DSOLID_silhouette* silhouettes;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "num_silhouettes", &count, NULL)
         && dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "silhouettes", &silhouettes, NULL)
         && silhouettes == planesurface->silhouettes)
       pass ();
     else
       fail ("PLANESURFACE.silhouettes [Dwg_3DSOLID_silhouette*] * %u num_silhouettes", count);
   }
   {
     BITCODE_BS u_isolines;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "u_isolines", &u_isolines, NULL)
         && u_isolines == planesurface->u_isolines)
       pass ();
     else
       fail ("PLANESURFACE.u_isolines [BS] %hu != %hu", planesurface->u_isolines, u_isolines);
     u_isolines++;
     if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "u_isolines", &u_isolines, 0)
         && u_isolines == planesurface->u_isolines)
       pass ();
     else
       fail ("PLANESURFACE.u_isolines [BS] set+1 %hu != %hu", planesurface->u_isolines, u_isolines);
     planesurface->u_isolines--;
   }
   {
     BITCODE_B unknown;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "unknown", &unknown, NULL)
         && unknown == planesurface->unknown)
       pass ();
     else
       fail ("PLANESURFACE.unknown [B] " FORMAT_B " != " FORMAT_B "", planesurface->unknown, unknown);
     unknown++;
     if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "unknown", &unknown, 0)
         && unknown == planesurface->unknown)
       pass ();
     else
       fail ("PLANESURFACE.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", planesurface->unknown, unknown);
     planesurface->unknown--;
   }
   {
     BITCODE_BS v_isolines;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "v_isolines", &v_isolines, NULL)
         && v_isolines == planesurface->v_isolines)
       pass ();
     else
       fail ("PLANESURFACE.v_isolines [BS] %hu != %hu", planesurface->v_isolines, v_isolines);
     v_isolines++;
     if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "v_isolines", &v_isolines, 0)
         && v_isolines == planesurface->v_isolines)
       pass ();
     else
       fail ("PLANESURFACE.v_isolines [BS] set+1 %hu != %hu", planesurface->v_isolines, v_isolines);
     planesurface->v_isolines--;
   }
   {
     BITCODE_BS version;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "version", &version, NULL)
         && version == planesurface->version)
       pass ();
     else
       fail ("PLANESURFACE.version [BS] %hu != %hu", planesurface->version, version);
     version++;
     if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "version", &version, 0)
         && version == planesurface->version)
       pass ();
     else
       fail ("PLANESURFACE.version [BS] set+1 %hu != %hu", planesurface->version, version);
     planesurface->version--;
   }
   {
     BITCODE_B wireframe_data_present;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "wireframe_data_present", &wireframe_data_present, NULL)
         && wireframe_data_present == planesurface->wireframe_data_present)
       pass ();
     else
       fail ("PLANESURFACE.wireframe_data_present [B] " FORMAT_B " != " FORMAT_B "", planesurface->wireframe_data_present, wireframe_data_present);
     wireframe_data_present++;
     if (dwg_dynapi_entity_set_value (planesurface, "PLANESURFACE", "wireframe_data_present", &wireframe_data_present, 0)
         && wireframe_data_present == planesurface->wireframe_data_present)
       pass ();
     else
       fail ("PLANESURFACE.wireframe_data_present [B] set+1 " FORMAT_B " != " FORMAT_B "", planesurface->wireframe_data_present, wireframe_data_present);
     planesurface->wireframe_data_present--;
   }
   {
     Dwg_3DSOLID_wire* wires;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "num_wires", &count, NULL)
         && dwg_dynapi_entity_value (planesurface, "PLANESURFACE", "wires", &wires, NULL)
         && wires == planesurface->wires)
       pass ();
     else
       fail ("PLANESURFACE.wires [Dwg_3DSOLID_wire*] * %u num_wires", count);
   }
   if (failed && (is_class_unstable ("PLANESURFACE") || is_class_debugging ("PLANESURFACE")))
     {
       ok ("%s failed %d tests (TODO unstable)", "PLANESURFACE", failed);
       failed = 0;
     }
   return failed;
 }
@@ -20820,666 +20820,666 @@ static int test_REPEAT (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
   Dwg_Entity_REPEAT *restrict repeat = obj->tio.entity->tio.REPEAT;
   failed = 0;
   if (!obj_obj || !repeat)
     {
       fail ("NULL REPEAT");
       return 1;
     }
   {
     struct _dwg_object_entity* parent;
     if (dwg_dynapi_entity_value (repeat, "REPEAT", "parent", &parent, NULL)
         && !memcmp (&parent, &repeat->parent, sizeof (struct _dwg_object_entity*)))
         pass ();
     else
         fail ("REPEAT.parent [struct _dwg_object_entity*]");
   }
   if (failed && (is_class_unstable ("REPEAT") || is_class_debugging ("REPEAT")))
     {
       ok ("%s failed %d tests (TODO unstable)", "REPEAT", failed);
       failed = 0;
     }
   return failed;
 }
 static int test_REVOLVEDSURFACE (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
   Dwg_Entity_REVOLVEDSURFACE *restrict revolvedsurface = obj->tio.entity->tio.REVOLVEDSURFACE;
   failed = 0;
   if (!obj_obj || !revolvedsurface)
     {
       fail ("NULL REVOLVEDSURFACE");
       return 1;
     }
   {
     BITCODE_B _dxf_sab_converted;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "_dxf_sab_converted", &_dxf_sab_converted, NULL)
         && _dxf_sab_converted == revolvedsurface->_dxf_sab_converted)
       pass ();
     else
       fail ("REVOLVEDSURFACE._dxf_sab_converted [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->_dxf_sab_converted, _dxf_sab_converted);
     _dxf_sab_converted++;
     if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "_dxf_sab_converted", &_dxf_sab_converted, 0)
         && _dxf_sab_converted == revolvedsurface->_dxf_sab_converted)
       pass ();
     else
       fail ("REVOLVEDSURFACE._dxf_sab_converted [B] set+1 " FORMAT_B " != " FORMAT_B "", revolvedsurface->_dxf_sab_converted, _dxf_sab_converted);
     revolvedsurface->_dxf_sab_converted--;
   }
   {
     BITCODE_RC* acis_data;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "acis_data", &acis_data, NULL)
         && acis_data
            ? strEQ ((char *)acis_data, (char *)revolvedsurface->acis_data)
            : !revolvedsurface->acis_data)
       pass ();
     else
       fail ("REVOLVEDSURFACE.acis_data [RC*] '%s' <> '%s'", acis_data, revolvedsurface->acis_data);
   }
   {
     BITCODE_B acis_empty;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "acis_empty", &acis_empty, NULL)
         && acis_empty == revolvedsurface->acis_empty)
       pass ();
     else
       fail ("REVOLVEDSURFACE.acis_empty [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->acis_empty, acis_empty);
     acis_empty++;
     if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "acis_empty", &acis_empty, 0)
         && acis_empty == revolvedsurface->acis_empty)
       pass ();
     else
       fail ("REVOLVEDSURFACE.acis_empty [B] set+1 " FORMAT_B " != " FORMAT_B "", revolvedsurface->acis_empty, acis_empty);
     revolvedsurface->acis_empty--;
   }
   {
     BITCODE_B acis_empty2;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "acis_empty2", &acis_empty2, NULL)
         && acis_empty2 == revolvedsurface->acis_empty2)
       pass ();
     else
       fail ("REVOLVEDSURFACE.acis_empty2 [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->acis_empty2, acis_empty2);
     acis_empty2++;
     if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "acis_empty2", &acis_empty2, 0)
         && acis_empty2 == revolvedsurface->acis_empty2)
       pass ();
     else
       fail ("REVOLVEDSURFACE.acis_empty2 [B] set+1 " FORMAT_B " != " FORMAT_B "", revolvedsurface->acis_empty2, acis_empty2);
     revolvedsurface->acis_empty2--;
   }
   {
     BITCODE_B acis_empty_bit;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "acis_empty_bit", &acis_empty_bit, NULL)
         && acis_empty_bit == revolvedsurface->acis_empty_bit)
       pass ();
     else
       fail ("REVOLVEDSURFACE.acis_empty_bit [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->acis_empty_bit, acis_empty_bit);
     acis_empty_bit++;
     if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "acis_empty_bit", &acis_empty_bit, 0)
         && acis_empty_bit == revolvedsurface->acis_empty_bit)
       pass ();
     else
       fail ("REVOLVEDSURFACE.acis_empty_bit [B] set+1 " FORMAT_B " != " FORMAT_B "", revolvedsurface->acis_empty_bit, acis_empty_bit);
     revolvedsurface->acis_empty_bit--;
   }
   {
     BITCODE_3BD axis_point;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "axis_point", &axis_point, NULL)
         && !memcmp (&axis_point, &revolvedsurface->axis_point, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("REVOLVEDSURFACE.axis_point [3BD]");
   }
   {
     BITCODE_3BD axis_vector;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "axis_vector", &axis_vector, NULL)
         && !memcmp (&axis_vector, &revolvedsurface->axis_vector, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("REVOLVEDSURFACE.axis_vector [3BD]");
   }
   {
     BITCODE_BL* block_size;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "block_size", &block_size, NULL)
         && !memcmp (&block_size, &revolvedsurface->block_size, sizeof (BITCODE_BL*)))
         pass ();
     else
         fail ("REVOLVEDSURFACE.block_size [BL*]");
   }
   {
     BITCODE_BL class_version;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "class_version", &class_version, NULL)
         && class_version == revolvedsurface->class_version)
       pass ();
     else
       fail ("REVOLVEDSURFACE.class_version [BL] %u != %u", revolvedsurface->class_version, class_version);
     class_version++;
     if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "class_version", &class_version, 0)
         && class_version == revolvedsurface->class_version)
       pass ();
     else
       fail ("REVOLVEDSURFACE.class_version [BL] set+1 %u != %u", revolvedsurface->class_version, class_version);
     revolvedsurface->class_version--;
   }
   {
     BITCODE_B close_to_axis;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "close_to_axis", &close_to_axis, NULL)
         && close_to_axis == revolvedsurface->close_to_axis)
       pass ();
     else
       fail ("REVOLVEDSURFACE.close_to_axis [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->close_to_axis, close_to_axis);
     close_to_axis++;
     if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "close_to_axis", &close_to_axis, 0)
         && close_to_axis == revolvedsurface->close_to_axis)
       pass ();
     else
       fail ("REVOLVEDSURFACE.close_to_axis [B] set+1 " FORMAT_B " != " FORMAT_B "", revolvedsurface->close_to_axis, close_to_axis);
     revolvedsurface->close_to_axis--;
   }
   {
     BITCODE_BD draft_angle;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "draft_angle", &draft_angle, NULL)
         && draft_angle == revolvedsurface->draft_angle)
       pass ();
     else
       fail ("REVOLVEDSURFACE.draft_angle [BD] %g != %g", revolvedsurface->draft_angle, draft_angle);
     draft_angle++;
     if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "draft_angle", &draft_angle, 0)
         && draft_angle == revolvedsurface->draft_angle)
       pass ();
     else
       fail ("REVOLVEDSURFACE.draft_angle [BD] set+1 %g != %g", revolvedsurface->draft_angle, draft_angle);
     revolvedsurface->draft_angle--;
   }
   {
     BITCODE_BD draft_end_distance;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "draft_end_distance", &draft_end_distance, NULL)
         && draft_end_distance == revolvedsurface->draft_end_distance)
       pass ();
     else
       fail ("REVOLVEDSURFACE.draft_end_distance [BD] %g != %g", revolvedsurface->draft_end_distance, draft_end_distance);
     draft_end_distance++;
     if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "draft_end_distance", &draft_end_distance, 0)
         && draft_end_distance == revolvedsurface->draft_end_distance)
       pass ();
     else
       fail ("REVOLVEDSURFACE.draft_end_distance [BD] set+1 %g != %g", revolvedsurface->draft_end_distance, draft_end_distance);
     revolvedsurface->draft_end_distance--;
   }
   {
     BITCODE_BD draft_start_distance;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "draft_start_distance", &draft_start_distance, NULL)
         && draft_start_distance == revolvedsurface->draft_start_distance)
       pass ();
     else
       fail ("REVOLVEDSURFACE.draft_start_distance [BD] %g != %g", revolvedsurface->draft_start_distance, draft_start_distance);
     draft_start_distance++;
     if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "draft_start_distance", &draft_start_distance, 0)
         && draft_start_distance == revolvedsurface->draft_start_distance)
       pass ();
     else
       fail ("REVOLVEDSURFACE.draft_start_distance [BD] set+1 %g != %g", revolvedsurface->draft_start_distance, draft_start_distance);
     revolvedsurface->draft_start_distance--;
   }
   {
     char ** encr_sat_data;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "encr_sat_data", &encr_sat_data, NULL)
         && !memcmp (&encr_sat_data, &revolvedsurface->encr_sat_data, sizeof (revolvedsurface->encr_sat_data)))
       pass ();
     else
       fail ("REVOLVEDSURFACE.encr_sat_data [char **]");
   }
   {
     BITCODE_BL end_marker;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "end_marker", &end_marker, NULL)
         && end_marker == revolvedsurface->end_marker)
       pass ();
     else
       fail ("REVOLVEDSURFACE.end_marker [BL] %u != %u", revolvedsurface->end_marker, end_marker);
     end_marker++;
     if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "end_marker", &end_marker, 0)
         && end_marker == revolvedsurface->end_marker)
       pass ();
     else
       fail ("REVOLVEDSURFACE.end_marker [BL] set+1 %u != %u", revolvedsurface->end_marker, end_marker);
     revolvedsurface->end_marker--;
   }
   {
     struct _dwg_entity_3DSOLID* extra_acis_data;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "extra_acis_data", &extra_acis_data, NULL)
         && !memcmp (&extra_acis_data, &revolvedsurface->extra_acis_data, sizeof (struct _dwg_entity_3DSOLID*)))
         pass ();
     else
         fail ("REVOLVEDSURFACE.extra_acis_data [struct _dwg_entity_3DSOLID*]");
   }
   {
     BITCODE_B has_revision_guid;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "has_revision_guid", &has_revision_guid, NULL)
         && has_revision_guid == revolvedsurface->has_revision_guid)
       pass ();
     else
       fail ("REVOLVEDSURFACE.has_revision_guid [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->has_revision_guid, has_revision_guid);
     has_revision_guid++;
     if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "has_revision_guid", &has_revision_guid, 0)
         && has_revision_guid == revolvedsurface->has_revision_guid)
       pass ();
     else
       fail ("REVOLVEDSURFACE.has_revision_guid [B] set+1 " FORMAT_B " != " FORMAT_B "", revolvedsurface->has_revision_guid, has_revision_guid);
     revolvedsurface->has_revision_guid--;
   }
   {
     BITCODE_H history_id;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "history_id", &history_id, NULL)
         && !memcmp (&history_id, &revolvedsurface->history_id, sizeof (BITCODE_H)))
         pass ();
     else
         fail ("REVOLVEDSURFACE.history_id [H]");
   }
   {
     BITCODE_BL id;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "id", &id, NULL)
         && id == revolvedsurface->id)
       pass ();
     else
       fail ("REVOLVEDSURFACE.id [BL] %u != %u", revolvedsurface->id, id);
     id++;
     if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "id", &id, 0)
         && id == revolvedsurface->id)
       pass ();
     else
       fail ("REVOLVEDSURFACE.id [BL] set+1 %u != %u", revolvedsurface->id, id);
     revolvedsurface->id--;
   }
   {
     BITCODE_B isoline_present;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "isoline_present", &isoline_present, NULL)
         && isoline_present == revolvedsurface->isoline_present)
       pass ();
     else
       fail ("REVOLVEDSURFACE.isoline_present [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->isoline_present, isoline_present);
     isoline_present++;
     if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "isoline_present", &isoline_present, 0)
         && isoline_present == revolvedsurface->isoline_present)
       pass ();
     else
       fail ("REVOLVEDSURFACE.isoline_present [B] set+1 " FORMAT_B " != " FORMAT_B "", revolvedsurface->isoline_present, isoline_present);
     revolvedsurface->isoline_present--;
   }
   {
     BITCODE_BL isolines;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "isolines", &isolines, NULL)
         && isolines == revolvedsurface->isolines)
       pass ();
     else
       fail ("REVOLVEDSURFACE.isolines [BL] %u != %u", revolvedsurface->isolines, isolines);
     isolines++;
     if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "isolines", &isolines, 0)
         && isolines == revolvedsurface->isolines)
       pass ();
     else
       fail ("REVOLVEDSURFACE.isolines [BL] set+1 %u != %u", revolvedsurface->isolines, isolines);
     revolvedsurface->isolines--;
   }
   {
     Dwg_3DSOLID_material* materials;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "num_materials", &count, NULL)
         && dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "materials", &materials, NULL)
         && materials == revolvedsurface->materials)
       pass ();
     else
       fail ("REVOLVEDSURFACE.materials [Dwg_3DSOLID_material*] * %u num_materials", count);
   }
   {
     BITCODE_BS modeler_format_version;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "modeler_format_version", &modeler_format_version, NULL)
         && modeler_format_version == revolvedsurface->modeler_format_version)
       pass ();
     else
       fail ("REVOLVEDSURFACE.modeler_format_version [BS] %hu != %hu", revolvedsurface->modeler_format_version, modeler_format_version);
     modeler_format_version++;
     if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "modeler_format_version", &modeler_format_version, 0)
         && modeler_format_version == revolvedsurface->modeler_format_version)
       pass ();
     else
       fail ("REVOLVEDSURFACE.modeler_format_version [BS] set+1 %hu != %hu", revolvedsurface->modeler_format_version, modeler_format_version);
     revolvedsurface->modeler_format_version--;
   }
   {
     BITCODE_BL num_blocks;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "num_blocks", &num_blocks, NULL)
         && num_blocks == revolvedsurface->num_blocks)
       pass ();
     else
       fail ("REVOLVEDSURFACE.num_blocks [BL] %u != %u", revolvedsurface->num_blocks, num_blocks);
     num_blocks++;
     if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "num_blocks", &num_blocks, 0)
         && num_blocks == revolvedsurface->num_blocks)
       pass ();
     else
       fail ("REVOLVEDSURFACE.num_blocks [BL] set+1 %u != %u", revolvedsurface->num_blocks, num_blocks);
     revolvedsurface->num_blocks--;
   }
   {
     BITCODE_BL num_materials;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "num_materials", &num_materials, NULL)
         && num_materials == revolvedsurface->num_materials)
       pass ();
     else
       fail ("REVOLVEDSURFACE.num_materials [BL] %u != %u", revolvedsurface->num_materials, num_materials);
     num_materials++;
     if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "num_materials", &num_materials, 0)
         && num_materials == revolvedsurface->num_materials)
       pass ();
     else
       fail ("REVOLVEDSURFACE.num_materials [BL] set+1 %u != %u", revolvedsurface->num_materials, num_materials);
     revolvedsurface->num_materials--;
   }
   {
     BITCODE_BL num_silhouettes;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "num_silhouettes", &num_silhouettes, NULL)
         && num_silhouettes == revolvedsurface->num_silhouettes)
       pass ();
     else
       fail ("REVOLVEDSURFACE.num_silhouettes [BL] %u != %u", revolvedsurface->num_silhouettes, num_silhouettes);
     num_silhouettes++;
     if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "num_silhouettes", &num_silhouettes, 0)
         && num_silhouettes == revolvedsurface->num_silhouettes)
       pass ();
     else
       fail ("REVOLVEDSURFACE.num_silhouettes [BL] set+1 %u != %u", revolvedsurface->num_silhouettes, num_silhouettes);
     revolvedsurface->num_silhouettes--;
   }
   {
     BITCODE_BL num_wires;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "num_wires", &num_wires, NULL)
         && num_wires == revolvedsurface->num_wires)
       pass ();
     else
       fail ("REVOLVEDSURFACE.num_wires [BL] %u != %u", revolvedsurface->num_wires, num_wires);
     num_wires++;
     if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "num_wires", &num_wires, 0)
         && num_wires == revolvedsurface->num_wires)
       pass ();
     else
       fail ("REVOLVEDSURFACE.num_wires [BL] set+1 %u != %u", revolvedsurface->num_wires, num_wires);
     revolvedsurface->num_wires--;
   }
   {
     struct _dwg_object_entity* parent;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "parent", &parent, NULL)
         && !memcmp (&parent, &revolvedsurface->parent, sizeof (struct _dwg_object_entity*)))
         pass ();
     else
         fail ("REVOLVEDSURFACE.parent [struct _dwg_object_entity*]");
   }
   {
     BITCODE_3BD point;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "point", &point, NULL)
         && !memcmp (&point, &revolvedsurface->point, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("REVOLVEDSURFACE.point [3BD]");
   }
   {
     BITCODE_B point_present;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "point_present", &point_present, NULL)
         && point_present == revolvedsurface->point_present)
       pass ();
     else
       fail ("REVOLVEDSURFACE.point_present [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->point_present, point_present);
     point_present++;
     if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "point_present", &point_present, 0)
         && point_present == revolvedsurface->point_present)
       pass ();
     else
       fail ("REVOLVEDSURFACE.point_present [B] set+1 " FORMAT_B " != " FORMAT_B "", revolvedsurface->point_present, point_present);
     revolvedsurface->point_present--;
   }
   {
     BITCODE_RC revision_bytes[9];
-    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "revision_bytes[9]", &revision_bytes, NULL)
+    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "revision_bytes", &revision_bytes, NULL)
         && !memcmp (&revision_bytes, &revolvedsurface->revision_bytes, sizeof (BITCODE_RC)))
         pass ();
     else
-        fail ("REVOLVEDSURFACE.revision_bytes[9] [RC]");
+        fail ("REVOLVEDSURFACE.revision_bytes [RC]");
   }
   {
     BITCODE_RC revision_guid[39];
-    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "revision_guid[39]", &revision_guid, NULL)
+    if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "revision_guid", &revision_guid, NULL)
         && !memcmp (&revision_guid, &revolvedsurface->revision_guid, sizeof (BITCODE_RC)))
         pass ();
     else
-        fail ("REVOLVEDSURFACE.revision_guid[39] [RC]");
+        fail ("REVOLVEDSURFACE.revision_guid [RC]");
   }
   {
     BITCODE_BL revision_major;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "revision_major", &revision_major, NULL)
         && revision_major == revolvedsurface->revision_major)
       pass ();
     else
       fail ("REVOLVEDSURFACE.revision_major [BL] %u != %u", revolvedsurface->revision_major, revision_major);
     revision_major++;
     if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "revision_major", &revision_major, 0)
         && revision_major == revolvedsurface->revision_major)
       pass ();
     else
       fail ("REVOLVEDSURFACE.revision_major [BL] set+1 %u != %u", revolvedsurface->revision_major, revision_major);
     revolvedsurface->revision_major--;
   }
   {
     BITCODE_BS revision_minor1;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "revision_minor1", &revision_minor1, NULL)
         && revision_minor1 == revolvedsurface->revision_minor1)
       pass ();
     else
       fail ("REVOLVEDSURFACE.revision_minor1 [BS] %hu != %hu", revolvedsurface->revision_minor1, revision_minor1);
     revision_minor1++;
     if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "revision_minor1", &revision_minor1, 0)
         && revision_minor1 == revolvedsurface->revision_minor1)
       pass ();
     else
       fail ("REVOLVEDSURFACE.revision_minor1 [BS] set+1 %hu != %hu", revolvedsurface->revision_minor1, revision_minor1);
     revolvedsurface->revision_minor1--;
   }
   {
     BITCODE_BS revision_minor2;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "revision_minor2", &revision_minor2, NULL)
         && revision_minor2 == revolvedsurface->revision_minor2)
       pass ();
     else
       fail ("REVOLVEDSURFACE.revision_minor2 [BS] %hu != %hu", revolvedsurface->revision_minor2, revision_minor2);
     revision_minor2++;
     if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "revision_minor2", &revision_minor2, 0)
         && revision_minor2 == revolvedsurface->revision_minor2)
       pass ();
     else
       fail ("REVOLVEDSURFACE.revision_minor2 [BS] set+1 %hu != %hu", revolvedsurface->revision_minor2, revision_minor2);
     revolvedsurface->revision_minor2--;
   }
   {
     BITCODE_BD revolve_angle;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "revolve_angle", &revolve_angle, NULL)
         && revolve_angle == revolvedsurface->revolve_angle)
       pass ();
     else
       fail ("REVOLVEDSURFACE.revolve_angle [BD] %g != %g", revolvedsurface->revolve_angle, revolve_angle);
     revolve_angle++;
     if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "revolve_angle", &revolve_angle, 0)
         && revolve_angle == revolvedsurface->revolve_angle)
       pass ();
     else
       fail ("REVOLVEDSURFACE.revolve_angle [BD] set+1 %g != %g", revolvedsurface->revolve_angle, revolve_angle);
     revolvedsurface->revolve_angle--;
   }
   {
     BITCODE_BD* revolved_entity_transmatrix;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "revolved_entity_transmatrix", &revolved_entity_transmatrix, NULL)
         && !memcmp (&revolved_entity_transmatrix, &revolvedsurface->revolved_entity_transmatrix, sizeof (BITCODE_BD*)))
         pass ();
     else
         fail ("REVOLVEDSURFACE.revolved_entity_transmatrix [BD*]");
   }
   {
     BITCODE_BL sab_size;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "sab_size", &sab_size, NULL)
         && sab_size == revolvedsurface->sab_size)
       pass ();
     else
       fail ("REVOLVEDSURFACE.sab_size [BL] %u != %u", revolvedsurface->sab_size, sab_size);
     sab_size++;
     if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "sab_size", &sab_size, 0)
         && sab_size == revolvedsurface->sab_size)
       pass ();
     else
       fail ("REVOLVEDSURFACE.sab_size [BL] set+1 %u != %u", revolvedsurface->sab_size, sab_size);
     revolvedsurface->sab_size--;
   }
   {
     Dwg_3DSOLID_silhouette* silhouettes;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "num_silhouettes", &count, NULL)
         && dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "silhouettes", &silhouettes, NULL)
         && silhouettes == revolvedsurface->silhouettes)
       pass ();
     else
       fail ("REVOLVEDSURFACE.silhouettes [Dwg_3DSOLID_silhouette*] * %u num_silhouettes", count);
   }
   {
     BITCODE_B solid;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "solid", &solid, NULL)
         && solid == revolvedsurface->solid)
       pass ();
     else
       fail ("REVOLVEDSURFACE.solid [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->solid, solid);
     solid++;
     if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "solid", &solid, 0)
         && solid == revolvedsurface->solid)
       pass ();
     else
       fail ("REVOLVEDSURFACE.solid [B] set+1 " FORMAT_B " != " FORMAT_B "", revolvedsurface->solid, solid);
     revolvedsurface->solid--;
   }
   {
     BITCODE_BD start_angle;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "start_angle", &start_angle, NULL)
         && start_angle == revolvedsurface->start_angle)
       pass ();
     else
       fail ("REVOLVEDSURFACE.start_angle [BD] %g != %g", revolvedsurface->start_angle, start_angle);
     start_angle++;
     if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "start_angle", &start_angle, 0)
         && start_angle == revolvedsurface->start_angle)
       pass ();
     else
       fail ("REVOLVEDSURFACE.start_angle [BD] set+1 %g != %g", revolvedsurface->start_angle, start_angle);
     revolvedsurface->start_angle--;
   }
   {
     BITCODE_BD twist_angle;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "twist_angle", &twist_angle, NULL)
         && twist_angle == revolvedsurface->twist_angle)
       pass ();
     else
       fail ("REVOLVEDSURFACE.twist_angle [BD] %g != %g", revolvedsurface->twist_angle, twist_angle);
     twist_angle++;
     if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "twist_angle", &twist_angle, 0)
         && twist_angle == revolvedsurface->twist_angle)
       pass ();
     else
       fail ("REVOLVEDSURFACE.twist_angle [BD] set+1 %g != %g", revolvedsurface->twist_angle, twist_angle);
     revolvedsurface->twist_angle--;
   }
   {
     BITCODE_BS u_isolines;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "u_isolines", &u_isolines, NULL)
         && u_isolines == revolvedsurface->u_isolines)
       pass ();
     else
       fail ("REVOLVEDSURFACE.u_isolines [BS] %hu != %hu", revolvedsurface->u_isolines, u_isolines);
     u_isolines++;
     if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "u_isolines", &u_isolines, 0)
         && u_isolines == revolvedsurface->u_isolines)
       pass ();
     else
       fail ("REVOLVEDSURFACE.u_isolines [BS] set+1 %hu != %hu", revolvedsurface->u_isolines, u_isolines);
     revolvedsurface->u_isolines--;
   }
   {
     BITCODE_B unknown;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "unknown", &unknown, NULL)
         && unknown == revolvedsurface->unknown)
       pass ();
     else
       fail ("REVOLVEDSURFACE.unknown [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->unknown, unknown);
     unknown++;
     if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "unknown", &unknown, 0)
         && unknown == revolvedsurface->unknown)
       pass ();
     else
       fail ("REVOLVEDSURFACE.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", revolvedsurface->unknown, unknown);
     revolvedsurface->unknown--;
   }
   {
     BITCODE_BS v_isolines;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "v_isolines", &v_isolines, NULL)
         && v_isolines == revolvedsurface->v_isolines)
       pass ();
     else
       fail ("REVOLVEDSURFACE.v_isolines [BS] %hu != %hu", revolvedsurface->v_isolines, v_isolines);
     v_isolines++;
     if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "v_isolines", &v_isolines, 0)
         && v_isolines == revolvedsurface->v_isolines)
       pass ();
     else
       fail ("REVOLVEDSURFACE.v_isolines [BS] set+1 %hu != %hu", revolvedsurface->v_isolines, v_isolines);
     revolvedsurface->v_isolines--;
   }
   {
     BITCODE_BS version;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "version", &version, NULL)
         && version == revolvedsurface->version)
       pass ();
     else
       fail ("REVOLVEDSURFACE.version [BS] %hu != %hu", revolvedsurface->version, version);
     version++;
     if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "version", &version, 0)
         && version == revolvedsurface->version)
       pass ();
     else
       fail ("REVOLVEDSURFACE.version [BS] set+1 %hu != %hu", revolvedsurface->version, version);
     revolvedsurface->version--;
   }
   {
     BITCODE_B wireframe_data_present;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "wireframe_data_present", &wireframe_data_present, NULL)
         && wireframe_data_present == revolvedsurface->wireframe_data_present)
       pass ();
     else
       fail ("REVOLVEDSURFACE.wireframe_data_present [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->wireframe_data_present, wireframe_data_present);
     wireframe_data_present++;
     if (dwg_dynapi_entity_set_value (revolvedsurface, "REVOLVEDSURFACE", "wireframe_data_present", &wireframe_data_present, 0)
         && wireframe_data_present == revolvedsurface->wireframe_data_present)
       pass ();
     else
       fail ("REVOLVEDSURFACE.wireframe_data_present [B] set+1 " FORMAT_B " != " FORMAT_B "", revolvedsurface->wireframe_data_present, wireframe_data_present);
     revolvedsurface->wireframe_data_present--;
   }
   {
     Dwg_3DSOLID_wire* wires;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "num_wires", &count, NULL)
         && dwg_dynapi_entity_value (revolvedsurface, "REVOLVEDSURFACE", "wires", &wires, NULL)
         && wires == revolvedsurface->wires)
       pass ();
     else
       fail ("REVOLVEDSURFACE.wires [Dwg_3DSOLID_wire*] * %u num_wires", count);
   }
   if (failed && (is_class_unstable ("REVOLVEDSURFACE") || is_class_debugging ("REVOLVEDSURFACE")))
     {
       ok ("%s failed %d tests (TODO unstable)", "REVOLVEDSURFACE", failed);
       failed = 0;
     }
   return failed;
 }
@@ -22105,1104 +22105,1104 @@ static int test_SPLINE (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
   Dwg_Entity_SPLINE *restrict spline = obj->tio.entity->tio.SPLINE;
   failed = 0;
   if (!obj_obj || !spline)
     {
       fail ("NULL SPLINE");
       return 1;
     }
   {
     BITCODE_3BD beg_tan_vec;
     if (dwg_dynapi_entity_value (spline, "SPLINE", "beg_tan_vec", &beg_tan_vec, NULL)
         && !memcmp (&beg_tan_vec, &spline->beg_tan_vec, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("SPLINE.beg_tan_vec [3BD]");
   }
   {
     BITCODE_B closed_b;
     if (dwg_dynapi_entity_value (spline, "SPLINE", "closed_b", &closed_b, NULL)
         && closed_b == spline->closed_b)
       pass ();
     else
       fail ("SPLINE.closed_b [B] " FORMAT_B " != " FORMAT_B "", spline->closed_b, closed_b);
     closed_b++;
     if (dwg_dynapi_entity_set_value (spline, "SPLINE", "closed_b", &closed_b, 0)
         && closed_b == spline->closed_b)
       pass ();
     else
       fail ("SPLINE.closed_b [B] set+1 " FORMAT_B " != " FORMAT_B "", spline->closed_b, closed_b);
     spline->closed_b--;
   }
   {
     Dwg_SPLINE_control_point* ctrl_pts;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (spline, "SPLINE", "num_ctrl_pts", &count, NULL)
         && dwg_dynapi_entity_value (spline, "SPLINE", "ctrl_pts", &ctrl_pts, NULL)
         && ctrl_pts == spline->ctrl_pts)
       pass ();
     else
       fail ("SPLINE.ctrl_pts [Dwg_SPLINE_control_point*] * %u num_ctrl_pts", count);
   }
   {
     BITCODE_BD ctrl_tol;
     if (dwg_dynapi_entity_value (spline, "SPLINE", "ctrl_tol", &ctrl_tol, NULL)
         && ctrl_tol == spline->ctrl_tol)
       pass ();
     else
       fail ("SPLINE.ctrl_tol [BD] %g != %g", spline->ctrl_tol, ctrl_tol);
     ctrl_tol++;
     if (dwg_dynapi_entity_set_value (spline, "SPLINE", "ctrl_tol", &ctrl_tol, 0)
         && ctrl_tol == spline->ctrl_tol)
       pass ();
     else
       fail ("SPLINE.ctrl_tol [BD] set+1 %g != %g", spline->ctrl_tol, ctrl_tol);
     spline->ctrl_tol--;
   }
   {
     BITCODE_BS degree;
     if (dwg_dynapi_entity_value (spline, "SPLINE", "degree", &degree, NULL)
         && degree == spline->degree)
       pass ();
     else
       fail ("SPLINE.degree [BS] %hu != %hu", spline->degree, degree);
     degree++;
     if (dwg_dynapi_entity_set_value (spline, "SPLINE", "degree", &degree, 0)
         && degree == spline->degree)
       pass ();
     else
       fail ("SPLINE.degree [BS] set+1 %hu != %hu", spline->degree, degree);
     spline->degree--;
   }
   {
     BITCODE_3BD end_tan_vec;
     if (dwg_dynapi_entity_value (spline, "SPLINE", "end_tan_vec", &end_tan_vec, NULL)
         && !memcmp (&end_tan_vec, &spline->end_tan_vec, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("SPLINE.end_tan_vec [3BD]");
   }
   {
     BITCODE_3DPOINT* fit_pts;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (spline, "SPLINE", "num_fit_pts", &count, NULL)
         && dwg_dynapi_entity_value (spline, "SPLINE", "fit_pts", &fit_pts, NULL)
         && fit_pts == spline->fit_pts)
       pass ();
     else
       fail ("SPLINE.fit_pts [3DPOINT*] * %u num_fit_pts", count);
   }
   {
     BITCODE_BD fit_tol;
     if (dwg_dynapi_entity_value (spline, "SPLINE", "fit_tol", &fit_tol, NULL)
         && fit_tol == spline->fit_tol)
       pass ();
     else
       fail ("SPLINE.fit_tol [BD] %g != %g", spline->fit_tol, fit_tol);
     fit_tol++;
     if (dwg_dynapi_entity_set_value (spline, "SPLINE", "fit_tol", &fit_tol, 0)
         && fit_tol == spline->fit_tol)
       pass ();
     else
       fail ("SPLINE.fit_tol [BD] set+1 %g != %g", spline->fit_tol, fit_tol);
     spline->fit_tol--;
   }
   {
     BITCODE_RS flag;
     if (dwg_dynapi_entity_value (spline, "SPLINE", "flag", &flag, NULL)
         && flag == spline->flag)
       pass ();
     else
       fail ("SPLINE.flag [RS] %hu != %hu", spline->flag, flag);
     flag++;
     if (dwg_dynapi_entity_set_value (spline, "SPLINE", "flag", &flag, 0)
         && flag == spline->flag)
       pass ();
     else
       fail ("SPLINE.flag [RS] set+1 %hu != %hu", spline->flag, flag);
     spline->flag--;
   }
   {
     BITCODE_BD knot_tol;
     if (dwg_dynapi_entity_value (spline, "SPLINE", "knot_tol", &knot_tol, NULL)
         && knot_tol == spline->knot_tol)
       pass ();
     else
       fail ("SPLINE.knot_tol [BD] %g != %g", spline->knot_tol, knot_tol);
     knot_tol++;
     if (dwg_dynapi_entity_set_value (spline, "SPLINE", "knot_tol", &knot_tol, 0)
         && knot_tol == spline->knot_tol)
       pass ();
     else
       fail ("SPLINE.knot_tol [BD] set+1 %g != %g", spline->knot_tol, knot_tol);
     spline->knot_tol--;
   }
   {
     BITCODE_BL knotparam;
     if (dwg_dynapi_entity_value (spline, "SPLINE", "knotparam", &knotparam, NULL)
         && knotparam == spline->knotparam)
       pass ();
     else
       fail ("SPLINE.knotparam [BL] %u != %u", spline->knotparam, knotparam);
     knotparam++;
     if (dwg_dynapi_entity_set_value (spline, "SPLINE", "knotparam", &knotparam, 0)
         && knotparam == spline->knotparam)
       pass ();
     else
       fail ("SPLINE.knotparam [BL] set+1 %u != %u", spline->knotparam, knotparam);
     spline->knotparam--;
   }
   {
     BITCODE_BD* knots;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (spline, "SPLINE", "num_knots", &count, NULL)
         && dwg_dynapi_entity_value (spline, "SPLINE", "knots", &knots, NULL)
         && knots == spline->knots)
       pass ();
     else
       fail ("SPLINE.knots [BD*] * %u num_knots", count);
   }
   {
     BITCODE_BL num_ctrl_pts;
     if (dwg_dynapi_entity_value (spline, "SPLINE", "num_ctrl_pts", &num_ctrl_pts, NULL)
         && num_ctrl_pts == spline->num_ctrl_pts)
       pass ();
     else
       fail ("SPLINE.num_ctrl_pts [BL] %u != %u", spline->num_ctrl_pts, num_ctrl_pts);
     num_ctrl_pts++;
     if (dwg_dynapi_entity_set_value (spline, "SPLINE", "num_ctrl_pts", &num_ctrl_pts, 0)
         && num_ctrl_pts == spline->num_ctrl_pts)
       pass ();
     else
       fail ("SPLINE.num_ctrl_pts [BL] set+1 %u != %u", spline->num_ctrl_pts, num_ctrl_pts);
     spline->num_ctrl_pts--;
   }
   {
     BITCODE_BS num_fit_pts;
     if (dwg_dynapi_entity_value (spline, "SPLINE", "num_fit_pts", &num_fit_pts, NULL)
         && num_fit_pts == spline->num_fit_pts)
       pass ();
     else
       fail ("SPLINE.num_fit_pts [BS] %hu != %hu", spline->num_fit_pts, num_fit_pts);
     num_fit_pts++;
     if (dwg_dynapi_entity_set_value (spline, "SPLINE", "num_fit_pts", &num_fit_pts, 0)
         && num_fit_pts == spline->num_fit_pts)
       pass ();
     else
       fail ("SPLINE.num_fit_pts [BS] set+1 %hu != %hu", spline->num_fit_pts, num_fit_pts);
     spline->num_fit_pts--;
   }
   {
     BITCODE_BL num_knots;
     if (dwg_dynapi_entity_value (spline, "SPLINE", "num_knots", &num_knots, NULL)
         && num_knots == spline->num_knots)
       pass ();
     else
       fail ("SPLINE.num_knots [BL] %u != %u", spline->num_knots, num_knots);
     num_knots++;
     if (dwg_dynapi_entity_set_value (spline, "SPLINE", "num_knots", &num_knots, 0)
         && num_knots == spline->num_knots)
       pass ();
     else
       fail ("SPLINE.num_knots [BL] set+1 %u != %u", spline->num_knots, num_knots);
     spline->num_knots--;
   }
   {
     struct _dwg_object_entity* parent;
     if (dwg_dynapi_entity_value (spline, "SPLINE", "parent", &parent, NULL)
         && !memcmp (&parent, &spline->parent, sizeof (struct _dwg_object_entity*)))
         pass ();
     else
         fail ("SPLINE.parent [struct _dwg_object_entity*]");
   }
   {
     BITCODE_B periodic;
     if (dwg_dynapi_entity_value (spline, "SPLINE", "periodic", &periodic, NULL)
         && periodic == spline->periodic)
       pass ();
     else
       fail ("SPLINE.periodic [B] " FORMAT_B " != " FORMAT_B "", spline->periodic, periodic);
     periodic++;
     if (dwg_dynapi_entity_set_value (spline, "SPLINE", "periodic", &periodic, 0)
         && periodic == spline->periodic)
       pass ();
     else
       fail ("SPLINE.periodic [B] set+1 " FORMAT_B " != " FORMAT_B "", spline->periodic, periodic);
     spline->periodic--;
   }
   {
     BITCODE_B rational;
     if (dwg_dynapi_entity_value (spline, "SPLINE", "rational", &rational, NULL)
         && rational == spline->rational)
       pass ();
     else
       fail ("SPLINE.rational [B] " FORMAT_B " != " FORMAT_B "", spline->rational, rational);
     rational++;
     if (dwg_dynapi_entity_set_value (spline, "SPLINE", "rational", &rational, 0)
         && rational == spline->rational)
       pass ();
     else
       fail ("SPLINE.rational [B] set+1 " FORMAT_B " != " FORMAT_B "", spline->rational, rational);
     spline->rational--;
   }
   {
     BITCODE_BS scenario;
     if (dwg_dynapi_entity_value (spline, "SPLINE", "scenario", &scenario, NULL)
         && scenario == spline->scenario)
       pass ();
     else
       fail ("SPLINE.scenario [BS] %hu != %hu", spline->scenario, scenario);
     scenario++;
     if (dwg_dynapi_entity_set_value (spline, "SPLINE", "scenario", &scenario, 0)
         && scenario == spline->scenario)
       pass ();
     else
       fail ("SPLINE.scenario [BS] set+1 %hu != %hu", spline->scenario, scenario);
     spline->scenario--;
   }
   {
     BITCODE_BL splineflags;
     if (dwg_dynapi_entity_value (spline, "SPLINE", "splineflags", &splineflags, NULL)
         && splineflags == spline->splineflags)
       pass ();
     else
       fail ("SPLINE.splineflags [BL] %u != %u", spline->splineflags, splineflags);
     splineflags++;
     if (dwg_dynapi_entity_set_value (spline, "SPLINE", "splineflags", &splineflags, 0)
         && splineflags == spline->splineflags)
       pass ();
     else
       fail ("SPLINE.splineflags [BL] set+1 %u != %u", spline->splineflags, splineflags);
     spline->splineflags--;
   }
   {
     BITCODE_B weighted;
     if (dwg_dynapi_entity_value (spline, "SPLINE", "weighted", &weighted, NULL)
         && weighted == spline->weighted)
       pass ();
     else
       fail ("SPLINE.weighted [B] " FORMAT_B " != " FORMAT_B "", spline->weighted, weighted);
     weighted++;
     if (dwg_dynapi_entity_set_value (spline, "SPLINE", "weighted", &weighted, 0)
         && weighted == spline->weighted)
       pass ();
     else
       fail ("SPLINE.weighted [B] set+1 " FORMAT_B " != " FORMAT_B "", spline->weighted, weighted);
     spline->weighted--;
   }
   if (failed && (is_class_unstable ("SPLINE") || is_class_debugging ("SPLINE")))
     {
       ok ("%s failed %d tests (TODO unstable)", "SPLINE", failed);
       failed = 0;
     }
   return failed;
 }
 static int test_SWEPTSURFACE (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
   Dwg_Entity_SWEPTSURFACE *restrict sweptsurface = obj->tio.entity->tio.SWEPTSURFACE;
   failed = 0;
   if (!obj_obj || !sweptsurface)
     {
       fail ("NULL SWEPTSURFACE");
       return 1;
     }
   {
     BITCODE_B _dxf_sab_converted;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "_dxf_sab_converted", &_dxf_sab_converted, NULL)
         && _dxf_sab_converted == sweptsurface->_dxf_sab_converted)
       pass ();
     else
       fail ("SWEPTSURFACE._dxf_sab_converted [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->_dxf_sab_converted, _dxf_sab_converted);
     _dxf_sab_converted++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "_dxf_sab_converted", &_dxf_sab_converted, 0)
         && _dxf_sab_converted == sweptsurface->_dxf_sab_converted)
       pass ();
     else
       fail ("SWEPTSURFACE._dxf_sab_converted [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->_dxf_sab_converted, _dxf_sab_converted);
     sweptsurface->_dxf_sab_converted--;
   }
   {
     BITCODE_RC* acis_data;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "acis_data", &acis_data, NULL)
         && acis_data
            ? strEQ ((char *)acis_data, (char *)sweptsurface->acis_data)
            : !sweptsurface->acis_data)
       pass ();
     else
       fail ("SWEPTSURFACE.acis_data [RC*] '%s' <> '%s'", acis_data, sweptsurface->acis_data);
   }
   {
     BITCODE_B acis_empty;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "acis_empty", &acis_empty, NULL)
         && acis_empty == sweptsurface->acis_empty)
       pass ();
     else
       fail ("SWEPTSURFACE.acis_empty [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->acis_empty, acis_empty);
     acis_empty++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "acis_empty", &acis_empty, 0)
         && acis_empty == sweptsurface->acis_empty)
       pass ();
     else
       fail ("SWEPTSURFACE.acis_empty [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->acis_empty, acis_empty);
     sweptsurface->acis_empty--;
   }
   {
     BITCODE_B acis_empty2;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "acis_empty2", &acis_empty2, NULL)
         && acis_empty2 == sweptsurface->acis_empty2)
       pass ();
     else
       fail ("SWEPTSURFACE.acis_empty2 [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->acis_empty2, acis_empty2);
     acis_empty2++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "acis_empty2", &acis_empty2, 0)
         && acis_empty2 == sweptsurface->acis_empty2)
       pass ();
     else
       fail ("SWEPTSURFACE.acis_empty2 [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->acis_empty2, acis_empty2);
     sweptsurface->acis_empty2--;
   }
   {
     BITCODE_B acis_empty_bit;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "acis_empty_bit", &acis_empty_bit, NULL)
         && acis_empty_bit == sweptsurface->acis_empty_bit)
       pass ();
     else
       fail ("SWEPTSURFACE.acis_empty_bit [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->acis_empty_bit, acis_empty_bit);
     acis_empty_bit++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "acis_empty_bit", &acis_empty_bit, 0)
         && acis_empty_bit == sweptsurface->acis_empty_bit)
       pass ();
     else
       fail ("SWEPTSURFACE.acis_empty_bit [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->acis_empty_bit, acis_empty_bit);
     sweptsurface->acis_empty_bit--;
   }
   {
     BITCODE_BD align_angle;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "align_angle", &align_angle, NULL)
         && align_angle == sweptsurface->align_angle)
       pass ();
     else
       fail ("SWEPTSURFACE.align_angle [BD] %g != %g", sweptsurface->align_angle, align_angle);
     align_angle++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "align_angle", &align_angle, 0)
         && align_angle == sweptsurface->align_angle)
       pass ();
     else
       fail ("SWEPTSURFACE.align_angle [BD] set+1 %g != %g", sweptsurface->align_angle, align_angle);
     sweptsurface->align_angle--;
   }
   {
     BITCODE_B align_start;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "align_start", &align_start, NULL)
         && align_start == sweptsurface->align_start)
       pass ();
     else
       fail ("SWEPTSURFACE.align_start [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->align_start, align_start);
     align_start++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "align_start", &align_start, 0)
         && align_start == sweptsurface->align_start)
       pass ();
     else
       fail ("SWEPTSURFACE.align_start [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->align_start, align_start);
     sweptsurface->align_start--;
   }
   {
     BITCODE_B bank;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "bank", &bank, NULL)
         && bank == sweptsurface->bank)
       pass ();
     else
       fail ("SWEPTSURFACE.bank [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->bank, bank);
     bank++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "bank", &bank, 0)
         && bank == sweptsurface->bank)
       pass ();
     else
       fail ("SWEPTSURFACE.bank [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->bank, bank);
     sweptsurface->bank--;
   }
   {
     BITCODE_B base_point_set;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "base_point_set", &base_point_set, NULL)
         && base_point_set == sweptsurface->base_point_set)
       pass ();
     else
       fail ("SWEPTSURFACE.base_point_set [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->base_point_set, base_point_set);
     base_point_set++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "base_point_set", &base_point_set, 0)
         && base_point_set == sweptsurface->base_point_set)
       pass ();
     else
       fail ("SWEPTSURFACE.base_point_set [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->base_point_set, base_point_set);
     sweptsurface->base_point_set--;
   }
   {
     BITCODE_BL* block_size;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "block_size", &block_size, NULL)
         && !memcmp (&block_size, &sweptsurface->block_size, sizeof (BITCODE_BL*)))
         pass ();
     else
         fail ("SWEPTSURFACE.block_size [BL*]");
   }
   {
     BITCODE_BL class_version;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "class_version", &class_version, NULL)
         && class_version == sweptsurface->class_version)
       pass ();
     else
       fail ("SWEPTSURFACE.class_version [BL] %u != %u", sweptsurface->class_version, class_version);
     class_version++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "class_version", &class_version, 0)
         && class_version == sweptsurface->class_version)
       pass ();
     else
       fail ("SWEPTSURFACE.class_version [BL] set+1 %u != %u", sweptsurface->class_version, class_version);
     sweptsurface->class_version--;
   }
   {
     BITCODE_BD draft_angle;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "draft_angle", &draft_angle, NULL)
         && draft_angle == sweptsurface->draft_angle)
       pass ();
     else
       fail ("SWEPTSURFACE.draft_angle [BD] %g != %g", sweptsurface->draft_angle, draft_angle);
     draft_angle++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "draft_angle", &draft_angle, 0)
         && draft_angle == sweptsurface->draft_angle)
       pass ();
     else
       fail ("SWEPTSURFACE.draft_angle [BD] set+1 %g != %g", sweptsurface->draft_angle, draft_angle);
     sweptsurface->draft_angle--;
   }
   {
     BITCODE_BD draft_end_distance;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "draft_end_distance", &draft_end_distance, NULL)
         && draft_end_distance == sweptsurface->draft_end_distance)
       pass ();
     else
       fail ("SWEPTSURFACE.draft_end_distance [BD] %g != %g", sweptsurface->draft_end_distance, draft_end_distance);
     draft_end_distance++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "draft_end_distance", &draft_end_distance, 0)
         && draft_end_distance == sweptsurface->draft_end_distance)
       pass ();
     else
       fail ("SWEPTSURFACE.draft_end_distance [BD] set+1 %g != %g", sweptsurface->draft_end_distance, draft_end_distance);
     sweptsurface->draft_end_distance--;
   }
   {
     BITCODE_BD draft_start_distance;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "draft_start_distance", &draft_start_distance, NULL)
         && draft_start_distance == sweptsurface->draft_start_distance)
       pass ();
     else
       fail ("SWEPTSURFACE.draft_start_distance [BD] %g != %g", sweptsurface->draft_start_distance, draft_start_distance);
     draft_start_distance++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "draft_start_distance", &draft_start_distance, 0)
         && draft_start_distance == sweptsurface->draft_start_distance)
       pass ();
     else
       fail ("SWEPTSURFACE.draft_start_distance [BD] set+1 %g != %g", sweptsurface->draft_start_distance, draft_start_distance);
     sweptsurface->draft_start_distance--;
   }
   {
     char ** encr_sat_data;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "encr_sat_data", &encr_sat_data, NULL)
         && !memcmp (&encr_sat_data, &sweptsurface->encr_sat_data, sizeof (sweptsurface->encr_sat_data)))
       pass ();
     else
       fail ("SWEPTSURFACE.encr_sat_data [char **]");
   }
   {
     BITCODE_BL end_marker;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "end_marker", &end_marker, NULL)
         && end_marker == sweptsurface->end_marker)
       pass ();
     else
       fail ("SWEPTSURFACE.end_marker [BL] %u != %u", sweptsurface->end_marker, end_marker);
     end_marker++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "end_marker", &end_marker, 0)
         && end_marker == sweptsurface->end_marker)
       pass ();
     else
       fail ("SWEPTSURFACE.end_marker [BL] set+1 %u != %u", sweptsurface->end_marker, end_marker);
     sweptsurface->end_marker--;
   }
   {
     struct _dwg_entity_3DSOLID* extra_acis_data;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "extra_acis_data", &extra_acis_data, NULL)
         && !memcmp (&extra_acis_data, &sweptsurface->extra_acis_data, sizeof (struct _dwg_entity_3DSOLID*)))
         pass ();
     else
         fail ("SWEPTSURFACE.extra_acis_data [struct _dwg_entity_3DSOLID*]");
   }
   {
     BITCODE_B has_revision_guid;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "has_revision_guid", &has_revision_guid, NULL)
         && has_revision_guid == sweptsurface->has_revision_guid)
       pass ();
     else
       fail ("SWEPTSURFACE.has_revision_guid [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->has_revision_guid, has_revision_guid);
     has_revision_guid++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "has_revision_guid", &has_revision_guid, 0)
         && has_revision_guid == sweptsurface->has_revision_guid)
       pass ();
     else
       fail ("SWEPTSURFACE.has_revision_guid [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->has_revision_guid, has_revision_guid);
     sweptsurface->has_revision_guid--;
   }
   {
     BITCODE_H history_id;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "history_id", &history_id, NULL)
         && !memcmp (&history_id, &sweptsurface->history_id, sizeof (BITCODE_H)))
         pass ();
     else
         fail ("SWEPTSURFACE.history_id [H]");
   }
   {
     BITCODE_B is_solid;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "is_solid", &is_solid, NULL)
         && is_solid == sweptsurface->is_solid)
       pass ();
     else
       fail ("SWEPTSURFACE.is_solid [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->is_solid, is_solid);
     is_solid++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "is_solid", &is_solid, 0)
         && is_solid == sweptsurface->is_solid)
       pass ();
     else
       fail ("SWEPTSURFACE.is_solid [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->is_solid, is_solid);
     sweptsurface->is_solid--;
   }
   {
     BITCODE_B isoline_present;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "isoline_present", &isoline_present, NULL)
         && isoline_present == sweptsurface->isoline_present)
       pass ();
     else
       fail ("SWEPTSURFACE.isoline_present [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->isoline_present, isoline_present);
     isoline_present++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "isoline_present", &isoline_present, 0)
         && isoline_present == sweptsurface->isoline_present)
       pass ();
     else
       fail ("SWEPTSURFACE.isoline_present [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->isoline_present, isoline_present);
     sweptsurface->isoline_present--;
   }
   {
     BITCODE_BL isolines;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "isolines", &isolines, NULL)
         && isolines == sweptsurface->isolines)
       pass ();
     else
       fail ("SWEPTSURFACE.isolines [BL] %u != %u", sweptsurface->isolines, isolines);
     isolines++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "isolines", &isolines, 0)
         && isolines == sweptsurface->isolines)
       pass ();
     else
       fail ("SWEPTSURFACE.isolines [BL] set+1 %u != %u", sweptsurface->isolines, isolines);
     sweptsurface->isolines--;
   }
   {
     Dwg_3DSOLID_material* materials;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "num_materials", &count, NULL)
         && dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "materials", &materials, NULL)
         && materials == sweptsurface->materials)
       pass ();
     else
       fail ("SWEPTSURFACE.materials [Dwg_3DSOLID_material*] * %u num_materials", count);
   }
   {
     BITCODE_BS modeler_format_version;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "modeler_format_version", &modeler_format_version, NULL)
         && modeler_format_version == sweptsurface->modeler_format_version)
       pass ();
     else
       fail ("SWEPTSURFACE.modeler_format_version [BS] %hu != %hu", sweptsurface->modeler_format_version, modeler_format_version);
     modeler_format_version++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "modeler_format_version", &modeler_format_version, 0)
         && modeler_format_version == sweptsurface->modeler_format_version)
       pass ();
     else
       fail ("SWEPTSURFACE.modeler_format_version [BS] set+1 %hu != %hu", sweptsurface->modeler_format_version, modeler_format_version);
     sweptsurface->modeler_format_version--;
   }
   {
     BITCODE_BL num_blocks;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "num_blocks", &num_blocks, NULL)
         && num_blocks == sweptsurface->num_blocks)
       pass ();
     else
       fail ("SWEPTSURFACE.num_blocks [BL] %u != %u", sweptsurface->num_blocks, num_blocks);
     num_blocks++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "num_blocks", &num_blocks, 0)
         && num_blocks == sweptsurface->num_blocks)
       pass ();
     else
       fail ("SWEPTSURFACE.num_blocks [BL] set+1 %u != %u", sweptsurface->num_blocks, num_blocks);
     sweptsurface->num_blocks--;
   }
   {
     BITCODE_BL num_materials;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "num_materials", &num_materials, NULL)
         && num_materials == sweptsurface->num_materials)
       pass ();
     else
       fail ("SWEPTSURFACE.num_materials [BL] %u != %u", sweptsurface->num_materials, num_materials);
     num_materials++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "num_materials", &num_materials, 0)
         && num_materials == sweptsurface->num_materials)
       pass ();
     else
       fail ("SWEPTSURFACE.num_materials [BL] set+1 %u != %u", sweptsurface->num_materials, num_materials);
     sweptsurface->num_materials--;
   }
   {
     BITCODE_BL num_silhouettes;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "num_silhouettes", &num_silhouettes, NULL)
         && num_silhouettes == sweptsurface->num_silhouettes)
       pass ();
     else
       fail ("SWEPTSURFACE.num_silhouettes [BL] %u != %u", sweptsurface->num_silhouettes, num_silhouettes);
     num_silhouettes++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "num_silhouettes", &num_silhouettes, 0)
         && num_silhouettes == sweptsurface->num_silhouettes)
       pass ();
     else
       fail ("SWEPTSURFACE.num_silhouettes [BL] set+1 %u != %u", sweptsurface->num_silhouettes, num_silhouettes);
     sweptsurface->num_silhouettes--;
   }
   {
     BITCODE_BL num_wires;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "num_wires", &num_wires, NULL)
         && num_wires == sweptsurface->num_wires)
       pass ();
     else
       fail ("SWEPTSURFACE.num_wires [BL] %u != %u", sweptsurface->num_wires, num_wires);
     num_wires++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "num_wires", &num_wires, 0)
         && num_wires == sweptsurface->num_wires)
       pass ();
     else
       fail ("SWEPTSURFACE.num_wires [BL] set+1 %u != %u", sweptsurface->num_wires, num_wires);
     sweptsurface->num_wires--;
   }
   {
     struct _dwg_object_entity* parent;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "parent", &parent, NULL)
         && !memcmp (&parent, &sweptsurface->parent, sizeof (struct _dwg_object_entity*)))
         pass ();
     else
         fail ("SWEPTSURFACE.parent [struct _dwg_object_entity*]");
   }
   {
     BITCODE_H path_entity;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "path_entity", &path_entity, NULL)
         && !memcmp (&path_entity, &sweptsurface->path_entity, sizeof (BITCODE_H)))
         pass ();
     else
         fail ("SWEPTSURFACE.path_entity [H]");
   }
   {
     BITCODE_BL path_entity_id;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "path_entity_id", &path_entity_id, NULL)
         && path_entity_id == sweptsurface->path_entity_id)
       pass ();
     else
       fail ("SWEPTSURFACE.path_entity_id [BL] %u != %u", sweptsurface->path_entity_id, path_entity_id);
     path_entity_id++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "path_entity_id", &path_entity_id, 0)
         && path_entity_id == sweptsurface->path_entity_id)
       pass ();
     else
       fail ("SWEPTSURFACE.path_entity_id [BL] set+1 %u != %u", sweptsurface->path_entity_id, path_entity_id);
     sweptsurface->path_entity_id--;
   }
   {
     BITCODE_B path_entity_transform_computed;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "path_entity_transform_computed", &path_entity_transform_computed, NULL)
         && path_entity_transform_computed == sweptsurface->path_entity_transform_computed)
       pass ();
     else
       fail ("SWEPTSURFACE.path_entity_transform_computed [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->path_entity_transform_computed, path_entity_transform_computed);
     path_entity_transform_computed++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "path_entity_transform_computed", &path_entity_transform_computed, 0)
         && path_entity_transform_computed == sweptsurface->path_entity_transform_computed)
       pass ();
     else
       fail ("SWEPTSURFACE.path_entity_transform_computed [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->path_entity_transform_computed, path_entity_transform_computed);
     sweptsurface->path_entity_transform_computed--;
   }
   {
     BITCODE_BD* path_entity_transmatrix;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "path_entity_transmatrix", &path_entity_transmatrix, NULL)
         && !memcmp (&path_entity_transmatrix, &sweptsurface->path_entity_transmatrix, sizeof (BITCODE_BD*)))
         pass ();
     else
         fail ("SWEPTSURFACE.path_entity_transmatrix [BD*]");
   }
   {
     BITCODE_BS path_flags;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "path_flags", &path_flags, NULL)
         && path_flags == sweptsurface->path_flags)
       pass ();
     else
       fail ("SWEPTSURFACE.path_flags [BS] %hu != %hu", sweptsurface->path_flags, path_flags);
     path_flags++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "path_flags", &path_flags, 0)
         && path_flags == sweptsurface->path_flags)
       pass ();
     else
       fail ("SWEPTSURFACE.path_flags [BS] set+1 %hu != %hu", sweptsurface->path_flags, path_flags);
     sweptsurface->path_flags--;
   }
   {
     BITCODE_TF pathdata;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "pathdata", &pathdata, NULL)
         && !memcmp (&pathdata, &sweptsurface->pathdata, sizeof (BITCODE_TF)))
         pass ();
     else
         fail ("SWEPTSURFACE.pathdata [TF]");
   }
   {
     BITCODE_BL pathdata_size;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "pathdata_size", &pathdata_size, NULL)
         && pathdata_size == sweptsurface->pathdata_size)
       pass ();
     else
       fail ("SWEPTSURFACE.pathdata_size [BL] %u != %u", sweptsurface->pathdata_size, pathdata_size);
     pathdata_size++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "pathdata_size", &pathdata_size, 0)
         && pathdata_size == sweptsurface->pathdata_size)
       pass ();
     else
       fail ("SWEPTSURFACE.pathdata_size [BL] set+1 %u != %u", sweptsurface->pathdata_size, pathdata_size);
     sweptsurface->pathdata_size--;
   }
   {
     BITCODE_3BD point;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "point", &point, NULL)
         && !memcmp (&point, &sweptsurface->point, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("SWEPTSURFACE.point [3BD]");
   }
   {
     BITCODE_B point_present;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "point_present", &point_present, NULL)
         && point_present == sweptsurface->point_present)
       pass ();
     else
       fail ("SWEPTSURFACE.point_present [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->point_present, point_present);
     point_present++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "point_present", &point_present, 0)
         && point_present == sweptsurface->point_present)
       pass ();
     else
       fail ("SWEPTSURFACE.point_present [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->point_present, point_present);
     sweptsurface->point_present--;
   }
   {
     BITCODE_3BD reference_vector_for_controlling_twist;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "reference_vector_for_controlling_twist", &reference_vector_for_controlling_twist, NULL)
         && !memcmp (&reference_vector_for_controlling_twist, &sweptsurface->reference_vector_for_controlling_twist, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("SWEPTSURFACE.reference_vector_for_controlling_twist [3BD]");
   }
   {
     BITCODE_RC revision_bytes[9];
-    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "revision_bytes[9]", &revision_bytes, NULL)
+    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "revision_bytes", &revision_bytes, NULL)
         && !memcmp (&revision_bytes, &sweptsurface->revision_bytes, sizeof (BITCODE_RC)))
         pass ();
     else
-        fail ("SWEPTSURFACE.revision_bytes[9] [RC]");
+        fail ("SWEPTSURFACE.revision_bytes [RC]");
   }
   {
     BITCODE_RC revision_guid[39];
-    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "revision_guid[39]", &revision_guid, NULL)
+    if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "revision_guid", &revision_guid, NULL)
         && !memcmp (&revision_guid, &sweptsurface->revision_guid, sizeof (BITCODE_RC)))
         pass ();
     else
-        fail ("SWEPTSURFACE.revision_guid[39] [RC]");
+        fail ("SWEPTSURFACE.revision_guid [RC]");
   }
   {
     BITCODE_BL revision_major;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "revision_major", &revision_major, NULL)
         && revision_major == sweptsurface->revision_major)
       pass ();
     else
       fail ("SWEPTSURFACE.revision_major [BL] %u != %u", sweptsurface->revision_major, revision_major);
     revision_major++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "revision_major", &revision_major, 0)
         && revision_major == sweptsurface->revision_major)
       pass ();
     else
       fail ("SWEPTSURFACE.revision_major [BL] set+1 %u != %u", sweptsurface->revision_major, revision_major);
     sweptsurface->revision_major--;
   }
   {
     BITCODE_BS revision_minor1;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "revision_minor1", &revision_minor1, NULL)
         && revision_minor1 == sweptsurface->revision_minor1)
       pass ();
     else
       fail ("SWEPTSURFACE.revision_minor1 [BS] %hu != %hu", sweptsurface->revision_minor1, revision_minor1);
     revision_minor1++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "revision_minor1", &revision_minor1, 0)
         && revision_minor1 == sweptsurface->revision_minor1)
       pass ();
     else
       fail ("SWEPTSURFACE.revision_minor1 [BS] set+1 %hu != %hu", sweptsurface->revision_minor1, revision_minor1);
     sweptsurface->revision_minor1--;
   }
   {
     BITCODE_BS revision_minor2;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "revision_minor2", &revision_minor2, NULL)
         && revision_minor2 == sweptsurface->revision_minor2)
       pass ();
     else
       fail ("SWEPTSURFACE.revision_minor2 [BS] %hu != %hu", sweptsurface->revision_minor2, revision_minor2);
     revision_minor2++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "revision_minor2", &revision_minor2, 0)
         && revision_minor2 == sweptsurface->revision_minor2)
       pass ();
     else
       fail ("SWEPTSURFACE.revision_minor2 [BS] set+1 %hu != %hu", sweptsurface->revision_minor2, revision_minor2);
     sweptsurface->revision_minor2--;
   }
   {
     BITCODE_BL sab_size;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "sab_size", &sab_size, NULL)
         && sab_size == sweptsurface->sab_size)
       pass ();
     else
       fail ("SWEPTSURFACE.sab_size [BL] %u != %u", sweptsurface->sab_size, sab_size);
     sab_size++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "sab_size", &sab_size, 0)
         && sab_size == sweptsurface->sab_size)
       pass ();
     else
       fail ("SWEPTSURFACE.sab_size [BL] set+1 %u != %u", sweptsurface->sab_size, sab_size);
     sweptsurface->sab_size--;
   }
   {
     BITCODE_BD scale_factor;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "scale_factor", &scale_factor, NULL)
         && scale_factor == sweptsurface->scale_factor)
       pass ();
     else
       fail ("SWEPTSURFACE.scale_factor [BD] %g != %g", sweptsurface->scale_factor, scale_factor);
     scale_factor++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "scale_factor", &scale_factor, 0)
         && scale_factor == sweptsurface->scale_factor)
       pass ();
     else
       fail ("SWEPTSURFACE.scale_factor [BD] set+1 %g != %g", sweptsurface->scale_factor, scale_factor);
     sweptsurface->scale_factor--;
   }
   {
     Dwg_3DSOLID_silhouette* silhouettes;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "num_silhouettes", &count, NULL)
         && dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "silhouettes", &silhouettes, NULL)
         && silhouettes == sweptsurface->silhouettes)
       pass ();
     else
       fail ("SWEPTSURFACE.silhouettes [Dwg_3DSOLID_silhouette*] * %u num_silhouettes", count);
   }
   {
     BITCODE_BS sweep_alignment_flags;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "sweep_alignment_flags", &sweep_alignment_flags, NULL)
         && sweep_alignment_flags == sweptsurface->sweep_alignment_flags)
       pass ();
     else
       fail ("SWEPTSURFACE.sweep_alignment_flags [BS] %hu != %hu", sweptsurface->sweep_alignment_flags, sweep_alignment_flags);
     sweep_alignment_flags++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "sweep_alignment_flags", &sweep_alignment_flags, 0)
         && sweep_alignment_flags == sweptsurface->sweep_alignment_flags)
       pass ();
     else
       fail ("SWEPTSURFACE.sweep_alignment_flags [BS] set+1 %hu != %hu", sweptsurface->sweep_alignment_flags, sweep_alignment_flags);
     sweptsurface->sweep_alignment_flags--;
   }
   {
     BITCODE_H sweep_entity;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "sweep_entity", &sweep_entity, NULL)
         && !memcmp (&sweep_entity, &sweptsurface->sweep_entity, sizeof (BITCODE_H)))
         pass ();
     else
         fail ("SWEPTSURFACE.sweep_entity [H]");
   }
   {
     BITCODE_BL sweep_entity_id;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "sweep_entity_id", &sweep_entity_id, NULL)
         && sweep_entity_id == sweptsurface->sweep_entity_id)
       pass ();
     else
       fail ("SWEPTSURFACE.sweep_entity_id [BL] %u != %u", sweptsurface->sweep_entity_id, sweep_entity_id);
     sweep_entity_id++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "sweep_entity_id", &sweep_entity_id, 0)
         && sweep_entity_id == sweptsurface->sweep_entity_id)
       pass ();
     else
       fail ("SWEPTSURFACE.sweep_entity_id [BL] set+1 %u != %u", sweptsurface->sweep_entity_id, sweep_entity_id);
     sweptsurface->sweep_entity_id--;
   }
   {
     BITCODE_B sweep_entity_transform_computed;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "sweep_entity_transform_computed", &sweep_entity_transform_computed, NULL)
         && sweep_entity_transform_computed == sweptsurface->sweep_entity_transform_computed)
       pass ();
     else
       fail ("SWEPTSURFACE.sweep_entity_transform_computed [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->sweep_entity_transform_computed, sweep_entity_transform_computed);
     sweep_entity_transform_computed++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "sweep_entity_transform_computed", &sweep_entity_transform_computed, 0)
         && sweep_entity_transform_computed == sweptsurface->sweep_entity_transform_computed)
       pass ();
     else
       fail ("SWEPTSURFACE.sweep_entity_transform_computed [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->sweep_entity_transform_computed, sweep_entity_transform_computed);
     sweptsurface->sweep_entity_transform_computed--;
   }
   {
     BITCODE_BD* sweep_entity_transmatrix;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "sweep_entity_transmatrix", &sweep_entity_transmatrix, NULL)
         && !memcmp (&sweep_entity_transmatrix, &sweptsurface->sweep_entity_transmatrix, sizeof (BITCODE_BD*)))
         pass ();
     else
         fail ("SWEPTSURFACE.sweep_entity_transmatrix [BD*]");
   }
   {
     BITCODE_TF sweepdata;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "sweepdata", &sweepdata, NULL)
         && !memcmp (&sweepdata, &sweptsurface->sweepdata, sizeof (BITCODE_TF)))
         pass ();
     else
         fail ("SWEPTSURFACE.sweepdata [TF]");
   }
   {
     BITCODE_BL sweepdata_size;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "sweepdata_size", &sweepdata_size, NULL)
         && sweepdata_size == sweptsurface->sweepdata_size)
       pass ();
     else
       fail ("SWEPTSURFACE.sweepdata_size [BL] %u != %u", sweptsurface->sweepdata_size, sweepdata_size);
     sweepdata_size++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "sweepdata_size", &sweepdata_size, 0)
         && sweepdata_size == sweptsurface->sweepdata_size)
       pass ();
     else
       fail ("SWEPTSURFACE.sweepdata_size [BL] set+1 %u != %u", sweptsurface->sweepdata_size, sweepdata_size);
     sweptsurface->sweepdata_size--;
   }
   {
     BITCODE_BD twist_angle;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "twist_angle", &twist_angle, NULL)
         && twist_angle == sweptsurface->twist_angle)
       pass ();
     else
       fail ("SWEPTSURFACE.twist_angle [BD] %g != %g", sweptsurface->twist_angle, twist_angle);
     twist_angle++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "twist_angle", &twist_angle, 0)
         && twist_angle == sweptsurface->twist_angle)
       pass ();
     else
       fail ("SWEPTSURFACE.twist_angle [BD] set+1 %g != %g", sweptsurface->twist_angle, twist_angle);
     sweptsurface->twist_angle--;
   }
   {
     BITCODE_BS u_isolines;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "u_isolines", &u_isolines, NULL)
         && u_isolines == sweptsurface->u_isolines)
       pass ();
     else
       fail ("SWEPTSURFACE.u_isolines [BS] %hu != %hu", sweptsurface->u_isolines, u_isolines);
     u_isolines++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "u_isolines", &u_isolines, 0)
         && u_isolines == sweptsurface->u_isolines)
       pass ();
     else
       fail ("SWEPTSURFACE.u_isolines [BS] set+1 %hu != %hu", sweptsurface->u_isolines, u_isolines);
     sweptsurface->u_isolines--;
   }
   {
     BITCODE_B unknown;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "unknown", &unknown, NULL)
         && unknown == sweptsurface->unknown)
       pass ();
     else
       fail ("SWEPTSURFACE.unknown [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->unknown, unknown);
     unknown++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "unknown", &unknown, 0)
         && unknown == sweptsurface->unknown)
       pass ();
     else
       fail ("SWEPTSURFACE.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->unknown, unknown);
     sweptsurface->unknown--;
   }
   {
     BITCODE_BS v_isolines;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "v_isolines", &v_isolines, NULL)
         && v_isolines == sweptsurface->v_isolines)
       pass ();
     else
       fail ("SWEPTSURFACE.v_isolines [BS] %hu != %hu", sweptsurface->v_isolines, v_isolines);
     v_isolines++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "v_isolines", &v_isolines, 0)
         && v_isolines == sweptsurface->v_isolines)
       pass ();
     else
       fail ("SWEPTSURFACE.v_isolines [BS] set+1 %hu != %hu", sweptsurface->v_isolines, v_isolines);
     sweptsurface->v_isolines--;
   }
   {
     BITCODE_BS version;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "version", &version, NULL)
         && version == sweptsurface->version)
       pass ();
     else
       fail ("SWEPTSURFACE.version [BS] %hu != %hu", sweptsurface->version, version);
     version++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "version", &version, 0)
         && version == sweptsurface->version)
       pass ();
     else
       fail ("SWEPTSURFACE.version [BS] set+1 %hu != %hu", sweptsurface->version, version);
     sweptsurface->version--;
   }
   {
     BITCODE_B wireframe_data_present;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "wireframe_data_present", &wireframe_data_present, NULL)
         && wireframe_data_present == sweptsurface->wireframe_data_present)
       pass ();
     else
       fail ("SWEPTSURFACE.wireframe_data_present [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->wireframe_data_present, wireframe_data_present);
     wireframe_data_present++;
     if (dwg_dynapi_entity_set_value (sweptsurface, "SWEPTSURFACE", "wireframe_data_present", &wireframe_data_present, 0)
         && wireframe_data_present == sweptsurface->wireframe_data_present)
       pass ();
     else
       fail ("SWEPTSURFACE.wireframe_data_present [B] set+1 " FORMAT_B " != " FORMAT_B "", sweptsurface->wireframe_data_present, wireframe_data_present);
     sweptsurface->wireframe_data_present--;
   }
   {
     Dwg_3DSOLID_wire* wires;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "num_wires", &count, NULL)
         && dwg_dynapi_entity_value (sweptsurface, "SWEPTSURFACE", "wires", &wires, NULL)
         && wires == sweptsurface->wires)
       pass ();
     else
       fail ("SWEPTSURFACE.wires [Dwg_3DSOLID_wire*] * %u num_wires", count);
   }
   if (failed && (is_class_unstable ("SWEPTSURFACE") || is_class_debugging ("SWEPTSURFACE")))
     {
       ok ("%s failed %d tests (TODO unstable)", "SWEPTSURFACE", failed);
       failed = 0;
     }
   return failed;
 }
@@ -25450,66 +25450,66 @@ static int test_VERTEX_PFACE (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
   Dwg_Entity_VERTEX_PFACE *restrict vertex_pface = obj->tio.entity->tio.VERTEX_PFACE;
   failed = 0;
   if (!obj_obj || !vertex_pface)
     {
       fail ("NULL VERTEX_PFACE");
       return 1;
     }
   if (failed && (is_class_unstable ("VERTEX_PFACE") || is_class_debugging ("VERTEX_PFACE")))
     {
       ok ("%s failed %d tests (TODO unstable)", "VERTEX_PFACE", failed);
       failed = 0;
     }
   return failed;
 }
 static int test_VERTEX_PFACE_FACE (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Entity *restrict obj_obj = obj->tio.entity;
   Dwg_Entity_VERTEX_PFACE_FACE *restrict vertex_pface_face = obj->tio.entity->tio.VERTEX_PFACE_FACE;
   failed = 0;
   if (!obj_obj || !vertex_pface_face)
     {
       fail ("NULL VERTEX_PFACE_FACE");
       return 1;
     }
   {
     BITCODE_RC flag;
     if (dwg_dynapi_entity_value (vertex_pface_face, "VERTEX_PFACE_FACE", "flag", &flag, NULL)
         && flag == vertex_pface_face->flag)
       pass ();
     else
       fail ("VERTEX_PFACE_FACE.flag [RC] %u != %u", vertex_pface_face->flag, flag);
     flag++;
     if (dwg_dynapi_entity_set_value (vertex_pface_face, "VERTEX_PFACE_FACE", "flag", &flag, 0)
         && flag == vertex_pface_face->flag)
       pass ();
     else
       fail ("VERTEX_PFACE_FACE.flag [RC] set+1 %u != %u", vertex_pface_face->flag, flag);
     vertex_pface_face->flag--;
   }
   {
     struct _dwg_object_entity* parent;
     if (dwg_dynapi_entity_value (vertex_pface_face, "VERTEX_PFACE_FACE", "parent", &parent, NULL)
         && !memcmp (&parent, &vertex_pface_face->parent, sizeof (struct _dwg_object_entity*)))
         pass ();
     else
         fail ("VERTEX_PFACE_FACE.parent [struct _dwg_object_entity*]");
   }
   {
     BITCODE_BS vertind[4];
-    if (dwg_dynapi_entity_value (vertex_pface_face, "VERTEX_PFACE_FACE", "vertind[4]", &vertind, NULL)
+    if (dwg_dynapi_entity_value (vertex_pface_face, "VERTEX_PFACE_FACE", "vertind", &vertind, NULL)
         && !memcmp (&vertind, &vertex_pface_face->vertind, sizeof (BITCODE_BS)))
         pass ();
     else
-        fail ("VERTEX_PFACE_FACE.vertind[4] [BS]");
+        fail ("VERTEX_PFACE_FACE.vertind [BS]");
   }
   if (failed && (is_class_unstable ("VERTEX_PFACE_FACE") || is_class_debugging ("VERTEX_PFACE_FACE")))
     {
       ok ("%s failed %d tests (TODO unstable)", "VERTEX_PFACE_FACE", failed);
       failed = 0;
     }
   return failed;
 }
@@ -26656,584 +26656,584 @@ static int test_ACSH_BOX_CLASS (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
   Dwg_Object_ACSH_BOX_CLASS *restrict acsh_box_class = obj->tio.object->tio.ACSH_BOX_CLASS;
   failed = 0;
   if (!obj_obj || !acsh_box_class)
     {
       fail ("NULL ACSH_BOX_CLASS");
       return 1;
     }
   {
     Dwg_EvalExpr evalexpr;
     if (dwg_dynapi_entity_value (acsh_box_class, "ACSH_BOX_CLASS", "evalexpr", &evalexpr, NULL)
         && !memcmp (&evalexpr, &acsh_box_class->evalexpr, sizeof (Dwg_EvalExpr)))
         pass ();
     else
         fail ("ACSH_BOX_CLASS.evalexpr [Dwg_EvalExpr]");
   }
   {
     BITCODE_BD height;
     if (dwg_dynapi_entity_value (acsh_box_class, "ACSH_BOX_CLASS", "height", &height, NULL)
         && height == acsh_box_class->height)
       pass ();
     else
       fail ("ACSH_BOX_CLASS.height [BD] %g != %g", acsh_box_class->height, height);
     height++;
     if (dwg_dynapi_entity_set_value (acsh_box_class, "ACSH_BOX_CLASS", "height", &height, 0)
         && height == acsh_box_class->height)
       pass ();
     else
       fail ("ACSH_BOX_CLASS.height [BD] set+1 %g != %g", acsh_box_class->height, height);
     acsh_box_class->height--;
   }
   {
     Dwg_ACSH_HistoryNode history_node;
     if (dwg_dynapi_entity_value (acsh_box_class, "ACSH_BOX_CLASS", "history_node", &history_node, NULL)
         && !memcmp (&history_node, &acsh_box_class->history_node, sizeof (Dwg_ACSH_HistoryNode)))
         pass ();
     else
         fail ("ACSH_BOX_CLASS.history_node [Dwg_ACSH_HistoryNode]");
   }
   {
     BITCODE_BD length;
     if (dwg_dynapi_entity_value (acsh_box_class, "ACSH_BOX_CLASS", "length", &length, NULL)
         && length == acsh_box_class->length)
       pass ();
     else
       fail ("ACSH_BOX_CLASS.length [BD] %g != %g", acsh_box_class->length, length);
     length++;
     if (dwg_dynapi_entity_set_value (acsh_box_class, "ACSH_BOX_CLASS", "length", &length, 0)
         && length == acsh_box_class->length)
       pass ();
     else
       fail ("ACSH_BOX_CLASS.length [BD] set+1 %g != %g", acsh_box_class->length, length);
     acsh_box_class->length--;
   }
   {
     BITCODE_BL major;
     if (dwg_dynapi_entity_value (acsh_box_class, "ACSH_BOX_CLASS", "major", &major, NULL)
         && major == acsh_box_class->major)
       pass ();
     else
       fail ("ACSH_BOX_CLASS.major [BL] %u != %u", acsh_box_class->major, major);
     major++;
     if (dwg_dynapi_entity_set_value (acsh_box_class, "ACSH_BOX_CLASS", "major", &major, 0)
         && major == acsh_box_class->major)
       pass ();
     else
       fail ("ACSH_BOX_CLASS.major [BL] set+1 %u != %u", acsh_box_class->major, major);
     acsh_box_class->major--;
   }
   {
     BITCODE_BL minor;
     if (dwg_dynapi_entity_value (acsh_box_class, "ACSH_BOX_CLASS", "minor", &minor, NULL)
         && minor == acsh_box_class->minor)
       pass ();
     else
       fail ("ACSH_BOX_CLASS.minor [BL] %u != %u", acsh_box_class->minor, minor);
     minor++;
     if (dwg_dynapi_entity_set_value (acsh_box_class, "ACSH_BOX_CLASS", "minor", &minor, 0)
         && minor == acsh_box_class->minor)
       pass ();
     else
       fail ("ACSH_BOX_CLASS.minor [BL] set+1 %u != %u", acsh_box_class->minor, minor);
     acsh_box_class->minor--;
   }
   {
     struct _dwg_object_object* parent;
     if (dwg_dynapi_entity_value (acsh_box_class, "ACSH_BOX_CLASS", "parent", &parent, NULL)
         && !memcmp (&parent, &acsh_box_class->parent, sizeof (struct _dwg_object_object*)))
         pass ();
     else
         fail ("ACSH_BOX_CLASS.parent [struct _dwg_object_object*]");
   }
   {
     BITCODE_BD width;
     if (dwg_dynapi_entity_value (acsh_box_class, "ACSH_BOX_CLASS", "width", &width, NULL)
         && width == acsh_box_class->width)
       pass ();
     else
       fail ("ACSH_BOX_CLASS.width [BD] %g != %g", acsh_box_class->width, width);
     width++;
     if (dwg_dynapi_entity_set_value (acsh_box_class, "ACSH_BOX_CLASS", "width", &width, 0)
         && width == acsh_box_class->width)
       pass ();
     else
       fail ("ACSH_BOX_CLASS.width [BD] set+1 %g != %g", acsh_box_class->width, width);
     acsh_box_class->width--;
   }
   if (failed && (is_class_unstable ("ACSH_BOX_CLASS") || is_class_debugging ("ACSH_BOX_CLASS")))
     {
       ok ("%s failed %d tests (TODO unstable)", "ACSH_BOX_CLASS", failed);
       failed = 0;
     }
   return failed;
 }
 static int test_ACSH_BREP_CLASS (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
   Dwg_Object_ACSH_BREP_CLASS *restrict acsh_brep_class = obj->tio.object->tio.ACSH_BREP_CLASS;
   failed = 0;
   if (!obj_obj || !acsh_brep_class)
     {
       fail ("NULL ACSH_BREP_CLASS");
       return 1;
     }
   {
     BITCODE_B _dxf_sab_converted;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "_dxf_sab_converted", &_dxf_sab_converted, NULL)
         && _dxf_sab_converted == acsh_brep_class->_dxf_sab_converted)
       pass ();
     else
       fail ("ACSH_BREP_CLASS._dxf_sab_converted [B] " FORMAT_B " != " FORMAT_B "", acsh_brep_class->_dxf_sab_converted, _dxf_sab_converted);
     _dxf_sab_converted++;
     if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "_dxf_sab_converted", &_dxf_sab_converted, 0)
         && _dxf_sab_converted == acsh_brep_class->_dxf_sab_converted)
       pass ();
     else
       fail ("ACSH_BREP_CLASS._dxf_sab_converted [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_brep_class->_dxf_sab_converted, _dxf_sab_converted);
     acsh_brep_class->_dxf_sab_converted--;
   }
   {
     BITCODE_RC* acis_data;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "acis_data", &acis_data, NULL)
         && acis_data
            ? strEQ ((char *)acis_data, (char *)acsh_brep_class->acis_data)
            : !acsh_brep_class->acis_data)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.acis_data [RC*] '%s' <> '%s'", acis_data, acsh_brep_class->acis_data);
   }
   {
     BITCODE_B acis_empty;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "acis_empty", &acis_empty, NULL)
         && acis_empty == acsh_brep_class->acis_empty)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.acis_empty [B] " FORMAT_B " != " FORMAT_B "", acsh_brep_class->acis_empty, acis_empty);
     acis_empty++;
     if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "acis_empty", &acis_empty, 0)
         && acis_empty == acsh_brep_class->acis_empty)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.acis_empty [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_brep_class->acis_empty, acis_empty);
     acsh_brep_class->acis_empty--;
   }
   {
     BITCODE_B acis_empty2;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "acis_empty2", &acis_empty2, NULL)
         && acis_empty2 == acsh_brep_class->acis_empty2)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.acis_empty2 [B] " FORMAT_B " != " FORMAT_B "", acsh_brep_class->acis_empty2, acis_empty2);
     acis_empty2++;
     if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "acis_empty2", &acis_empty2, 0)
         && acis_empty2 == acsh_brep_class->acis_empty2)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.acis_empty2 [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_brep_class->acis_empty2, acis_empty2);
     acsh_brep_class->acis_empty2--;
   }
   {
     BITCODE_B acis_empty_bit;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "acis_empty_bit", &acis_empty_bit, NULL)
         && acis_empty_bit == acsh_brep_class->acis_empty_bit)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.acis_empty_bit [B] " FORMAT_B " != " FORMAT_B "", acsh_brep_class->acis_empty_bit, acis_empty_bit);
     acis_empty_bit++;
     if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "acis_empty_bit", &acis_empty_bit, 0)
         && acis_empty_bit == acsh_brep_class->acis_empty_bit)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.acis_empty_bit [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_brep_class->acis_empty_bit, acis_empty_bit);
     acsh_brep_class->acis_empty_bit--;
   }
   {
     BITCODE_BL* block_size;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "block_size", &block_size, NULL)
         && !memcmp (&block_size, &acsh_brep_class->block_size, sizeof (BITCODE_BL*)))
         pass ();
     else
         fail ("ACSH_BREP_CLASS.block_size [BL*]");
   }
   {
     char ** encr_sat_data;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "encr_sat_data", &encr_sat_data, NULL)
         && !memcmp (&encr_sat_data, &acsh_brep_class->encr_sat_data, sizeof (acsh_brep_class->encr_sat_data)))
       pass ();
     else
       fail ("ACSH_BREP_CLASS.encr_sat_data [char **]");
   }
   {
     BITCODE_BL end_marker;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "end_marker", &end_marker, NULL)
         && end_marker == acsh_brep_class->end_marker)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.end_marker [BL] %u != %u", acsh_brep_class->end_marker, end_marker);
     end_marker++;
     if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "end_marker", &end_marker, 0)
         && end_marker == acsh_brep_class->end_marker)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.end_marker [BL] set+1 %u != %u", acsh_brep_class->end_marker, end_marker);
     acsh_brep_class->end_marker--;
   }
   {
     Dwg_EvalExpr evalexpr;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "evalexpr", &evalexpr, NULL)
         && !memcmp (&evalexpr, &acsh_brep_class->evalexpr, sizeof (Dwg_EvalExpr)))
         pass ();
     else
         fail ("ACSH_BREP_CLASS.evalexpr [Dwg_EvalExpr]");
   }
   {
     struct _dwg_entity_3DSOLID* extra_acis_data;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "extra_acis_data", &extra_acis_data, NULL)
         && !memcmp (&extra_acis_data, &acsh_brep_class->extra_acis_data, sizeof (struct _dwg_entity_3DSOLID*)))
         pass ();
     else
         fail ("ACSH_BREP_CLASS.extra_acis_data [struct _dwg_entity_3DSOLID*]");
   }
   {
     BITCODE_B has_revision_guid;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "has_revision_guid", &has_revision_guid, NULL)
         && has_revision_guid == acsh_brep_class->has_revision_guid)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.has_revision_guid [B] " FORMAT_B " != " FORMAT_B "", acsh_brep_class->has_revision_guid, has_revision_guid);
     has_revision_guid++;
     if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "has_revision_guid", &has_revision_guid, 0)
         && has_revision_guid == acsh_brep_class->has_revision_guid)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.has_revision_guid [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_brep_class->has_revision_guid, has_revision_guid);
     acsh_brep_class->has_revision_guid--;
   }
   {
     BITCODE_H history_id;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "history_id", &history_id, NULL)
         && !memcmp (&history_id, &acsh_brep_class->history_id, sizeof (BITCODE_H)))
         pass ();
     else
         fail ("ACSH_BREP_CLASS.history_id [H]");
   }
   {
     Dwg_ACSH_HistoryNode history_node;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "history_node", &history_node, NULL)
         && !memcmp (&history_node, &acsh_brep_class->history_node, sizeof (Dwg_ACSH_HistoryNode)))
         pass ();
     else
         fail ("ACSH_BREP_CLASS.history_node [Dwg_ACSH_HistoryNode]");
   }
   {
     BITCODE_B isoline_present;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "isoline_present", &isoline_present, NULL)
         && isoline_present == acsh_brep_class->isoline_present)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.isoline_present [B] " FORMAT_B " != " FORMAT_B "", acsh_brep_class->isoline_present, isoline_present);
     isoline_present++;
     if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "isoline_present", &isoline_present, 0)
         && isoline_present == acsh_brep_class->isoline_present)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.isoline_present [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_brep_class->isoline_present, isoline_present);
     acsh_brep_class->isoline_present--;
   }
   {
     BITCODE_BL isolines;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "isolines", &isolines, NULL)
         && isolines == acsh_brep_class->isolines)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.isolines [BL] %u != %u", acsh_brep_class->isolines, isolines);
     isolines++;
     if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "isolines", &isolines, 0)
         && isolines == acsh_brep_class->isolines)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.isolines [BL] set+1 %u != %u", acsh_brep_class->isolines, isolines);
     acsh_brep_class->isolines--;
   }
   {
     BITCODE_BL major;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "major", &major, NULL)
         && major == acsh_brep_class->major)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.major [BL] %u != %u", acsh_brep_class->major, major);
     major++;
     if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "major", &major, 0)
         && major == acsh_brep_class->major)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.major [BL] set+1 %u != %u", acsh_brep_class->major, major);
     acsh_brep_class->major--;
   }
   {
     Dwg_3DSOLID_material* materials;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "num_materials", &count, NULL)
         && dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "materials", &materials, NULL)
         && materials == acsh_brep_class->materials)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.materials [Dwg_3DSOLID_material*] * %u num_materials", count);
   }
   {
     BITCODE_BL minor;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "minor", &minor, NULL)
         && minor == acsh_brep_class->minor)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.minor [BL] %u != %u", acsh_brep_class->minor, minor);
     minor++;
     if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "minor", &minor, 0)
         && minor == acsh_brep_class->minor)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.minor [BL] set+1 %u != %u", acsh_brep_class->minor, minor);
     acsh_brep_class->minor--;
   }
   {
     BITCODE_BL num_blocks;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "num_blocks", &num_blocks, NULL)
         && num_blocks == acsh_brep_class->num_blocks)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.num_blocks [BL] %u != %u", acsh_brep_class->num_blocks, num_blocks);
     num_blocks++;
     if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "num_blocks", &num_blocks, 0)
         && num_blocks == acsh_brep_class->num_blocks)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.num_blocks [BL] set+1 %u != %u", acsh_brep_class->num_blocks, num_blocks);
     acsh_brep_class->num_blocks--;
   }
   {
     BITCODE_BL num_materials;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "num_materials", &num_materials, NULL)
         && num_materials == acsh_brep_class->num_materials)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.num_materials [BL] %u != %u", acsh_brep_class->num_materials, num_materials);
     num_materials++;
     if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "num_materials", &num_materials, 0)
         && num_materials == acsh_brep_class->num_materials)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.num_materials [BL] set+1 %u != %u", acsh_brep_class->num_materials, num_materials);
     acsh_brep_class->num_materials--;
   }
   {
     BITCODE_BL num_silhouettes;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "num_silhouettes", &num_silhouettes, NULL)
         && num_silhouettes == acsh_brep_class->num_silhouettes)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.num_silhouettes [BL] %u != %u", acsh_brep_class->num_silhouettes, num_silhouettes);
     num_silhouettes++;
     if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "num_silhouettes", &num_silhouettes, 0)
         && num_silhouettes == acsh_brep_class->num_silhouettes)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.num_silhouettes [BL] set+1 %u != %u", acsh_brep_class->num_silhouettes, num_silhouettes);
     acsh_brep_class->num_silhouettes--;
   }
   {
     BITCODE_BL num_wires;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "num_wires", &num_wires, NULL)
         && num_wires == acsh_brep_class->num_wires)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.num_wires [BL] %u != %u", acsh_brep_class->num_wires, num_wires);
     num_wires++;
     if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "num_wires", &num_wires, 0)
         && num_wires == acsh_brep_class->num_wires)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.num_wires [BL] set+1 %u != %u", acsh_brep_class->num_wires, num_wires);
     acsh_brep_class->num_wires--;
   }
   {
     struct _dwg_object_object* parent;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "parent", &parent, NULL)
         && !memcmp (&parent, &acsh_brep_class->parent, sizeof (struct _dwg_object_object*)))
         pass ();
     else
         fail ("ACSH_BREP_CLASS.parent [struct _dwg_object_object*]");
   }
   {
     BITCODE_3BD point;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "point", &point, NULL)
         && !memcmp (&point, &acsh_brep_class->point, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("ACSH_BREP_CLASS.point [3BD]");
   }
   {
     BITCODE_B point_present;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "point_present", &point_present, NULL)
         && point_present == acsh_brep_class->point_present)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.point_present [B] " FORMAT_B " != " FORMAT_B "", acsh_brep_class->point_present, point_present);
     point_present++;
     if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "point_present", &point_present, 0)
         && point_present == acsh_brep_class->point_present)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.point_present [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_brep_class->point_present, point_present);
     acsh_brep_class->point_present--;
   }
   {
     BITCODE_RC revision_bytes[9];
-    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "revision_bytes[9]", &revision_bytes, NULL)
+    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "revision_bytes", &revision_bytes, NULL)
         && !memcmp (&revision_bytes, &acsh_brep_class->revision_bytes, sizeof (BITCODE_RC)))
         pass ();
     else
-        fail ("ACSH_BREP_CLASS.revision_bytes[9] [RC]");
+        fail ("ACSH_BREP_CLASS.revision_bytes [RC]");
   }
   {
     BITCODE_RC revision_guid[39];
-    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "revision_guid[39]", &revision_guid, NULL)
+    if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "revision_guid", &revision_guid, NULL)
         && !memcmp (&revision_guid, &acsh_brep_class->revision_guid, sizeof (BITCODE_RC)))
         pass ();
     else
-        fail ("ACSH_BREP_CLASS.revision_guid[39] [RC]");
+        fail ("ACSH_BREP_CLASS.revision_guid [RC]");
   }
   {
     BITCODE_BL revision_major;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "revision_major", &revision_major, NULL)
         && revision_major == acsh_brep_class->revision_major)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.revision_major [BL] %u != %u", acsh_brep_class->revision_major, revision_major);
     revision_major++;
     if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "revision_major", &revision_major, 0)
         && revision_major == acsh_brep_class->revision_major)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.revision_major [BL] set+1 %u != %u", acsh_brep_class->revision_major, revision_major);
     acsh_brep_class->revision_major--;
   }
   {
     BITCODE_BS revision_minor1;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "revision_minor1", &revision_minor1, NULL)
         && revision_minor1 == acsh_brep_class->revision_minor1)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.revision_minor1 [BS] %hu != %hu", acsh_brep_class->revision_minor1, revision_minor1);
     revision_minor1++;
     if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "revision_minor1", &revision_minor1, 0)
         && revision_minor1 == acsh_brep_class->revision_minor1)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.revision_minor1 [BS] set+1 %hu != %hu", acsh_brep_class->revision_minor1, revision_minor1);
     acsh_brep_class->revision_minor1--;
   }
   {
     BITCODE_BS revision_minor2;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "revision_minor2", &revision_minor2, NULL)
         && revision_minor2 == acsh_brep_class->revision_minor2)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.revision_minor2 [BS] %hu != %hu", acsh_brep_class->revision_minor2, revision_minor2);
     revision_minor2++;
     if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "revision_minor2", &revision_minor2, 0)
         && revision_minor2 == acsh_brep_class->revision_minor2)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.revision_minor2 [BS] set+1 %hu != %hu", acsh_brep_class->revision_minor2, revision_minor2);
     acsh_brep_class->revision_minor2--;
   }
   {
     BITCODE_BL sab_size;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "sab_size", &sab_size, NULL)
         && sab_size == acsh_brep_class->sab_size)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.sab_size [BL] %u != %u", acsh_brep_class->sab_size, sab_size);
     sab_size++;
     if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "sab_size", &sab_size, 0)
         && sab_size == acsh_brep_class->sab_size)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.sab_size [BL] set+1 %u != %u", acsh_brep_class->sab_size, sab_size);
     acsh_brep_class->sab_size--;
   }
   {
     Dwg_3DSOLID_silhouette* silhouettes;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "num_silhouettes", &count, NULL)
         && dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "silhouettes", &silhouettes, NULL)
         && silhouettes == acsh_brep_class->silhouettes)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.silhouettes [Dwg_3DSOLID_silhouette*] * %u num_silhouettes", count);
   }
   {
     BITCODE_B unknown;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "unknown", &unknown, NULL)
         && unknown == acsh_brep_class->unknown)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.unknown [B] " FORMAT_B " != " FORMAT_B "", acsh_brep_class->unknown, unknown);
     unknown++;
     if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "unknown", &unknown, 0)
         && unknown == acsh_brep_class->unknown)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_brep_class->unknown, unknown);
     acsh_brep_class->unknown--;
   }
   {
     BITCODE_BS version;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "version", &version, NULL)
         && version == acsh_brep_class->version)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.version [BS] %hu != %hu", acsh_brep_class->version, version);
     version++;
     if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "version", &version, 0)
         && version == acsh_brep_class->version)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.version [BS] set+1 %hu != %hu", acsh_brep_class->version, version);
     acsh_brep_class->version--;
   }
   {
     BITCODE_B wireframe_data_present;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "wireframe_data_present", &wireframe_data_present, NULL)
         && wireframe_data_present == acsh_brep_class->wireframe_data_present)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.wireframe_data_present [B] " FORMAT_B " != " FORMAT_B "", acsh_brep_class->wireframe_data_present, wireframe_data_present);
     wireframe_data_present++;
     if (dwg_dynapi_entity_set_value (acsh_brep_class, "ACSH_BREP_CLASS", "wireframe_data_present", &wireframe_data_present, 0)
         && wireframe_data_present == acsh_brep_class->wireframe_data_present)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.wireframe_data_present [B] set+1 " FORMAT_B " != " FORMAT_B "", acsh_brep_class->wireframe_data_present, wireframe_data_present);
     acsh_brep_class->wireframe_data_present--;
   }
   {
     Dwg_3DSOLID_wire* wires;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "num_wires", &count, NULL)
         && dwg_dynapi_entity_value (acsh_brep_class, "ACSH_BREP_CLASS", "wires", &wires, NULL)
         && wires == acsh_brep_class->wires)
       pass ();
     else
       fail ("ACSH_BREP_CLASS.wires [Dwg_3DSOLID_wire*] * %u num_wires", count);
   }
   if (failed && (is_class_unstable ("ACSH_BREP_CLASS") || is_class_debugging ("ACSH_BREP_CLASS")))
     {
       ok ("%s failed %d tests (TODO unstable)", "ACSH_BREP_CLASS", failed);
       failed = 0;
     }
   return failed;
 }
@@ -29872,338 +29872,338 @@ static int test_APPID_CONTROL (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
   Dwg_Object_APPID_CONTROL *restrict appid_control = obj->tio.object->tio.APPID_CONTROL;
   failed = 0;
   if (!obj_obj || !appid_control)
     {
       fail ("NULL APPID_CONTROL");
       return 1;
     }
   {
     BITCODE_H* entries;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (appid_control, "APPID_CONTROL", "num_entries", &count, NULL)
         && dwg_dynapi_entity_value (appid_control, "APPID_CONTROL", "entries", &entries, NULL)
         && entries == appid_control->entries)
       pass ();
     else
       fail ("APPID_CONTROL.entries [H*] * %u num_entries", count);
   }
   {
     BITCODE_RS flags_r11;
     if (dwg_dynapi_entity_value (appid_control, "APPID_CONTROL", "flags_r11", &flags_r11, NULL)
         && flags_r11 == appid_control->flags_r11)
       pass ();
     else
       fail ("APPID_CONTROL.flags_r11 [RS] %hu != %hu", appid_control->flags_r11, flags_r11);
     flags_r11++;
     if (dwg_dynapi_entity_set_value (appid_control, "APPID_CONTROL", "flags_r11", &flags_r11, 0)
         && flags_r11 == appid_control->flags_r11)
       pass ();
     else
       fail ("APPID_CONTROL.flags_r11 [RS] set+1 %hu != %hu", appid_control->flags_r11, flags_r11);
     appid_control->flags_r11--;
   }
   {
     BITCODE_BS num_entries;
     if (dwg_dynapi_entity_value (appid_control, "APPID_CONTROL", "num_entries", &num_entries, NULL)
         && num_entries == appid_control->num_entries)
       pass ();
     else
       fail ("APPID_CONTROL.num_entries [BS] %hu != %hu", appid_control->num_entries, num_entries);
     num_entries++;
     if (dwg_dynapi_entity_set_value (appid_control, "APPID_CONTROL", "num_entries", &num_entries, 0)
         && num_entries == appid_control->num_entries)
       pass ();
     else
       fail ("APPID_CONTROL.num_entries [BS] set+1 %hu != %hu", appid_control->num_entries, num_entries);
     appid_control->num_entries--;
   }
   {
     struct _dwg_object_object* parent;
     if (dwg_dynapi_entity_value (appid_control, "APPID_CONTROL", "parent", &parent, NULL)
         && !memcmp (&parent, &appid_control->parent, sizeof (struct _dwg_object_object*)))
         pass ();
     else
         fail ("APPID_CONTROL.parent [struct _dwg_object_object*]");
   }
   if (failed && (is_class_unstable ("APPID_CONTROL") || is_class_debugging ("APPID_CONTROL")))
     {
       ok ("%s failed %d tests (TODO unstable)", "APPID_CONTROL", failed);
       failed = 0;
     }
   return failed;
 }
 static int test_ASSOC2DCONSTRAINTGROUP (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
   Dwg_Object_ASSOC2DCONSTRAINTGROUP *restrict assoc2dconstraintgroup = obj->tio.object->tio.ASSOC2DCONSTRAINTGROUP;
   failed = 0;
   if (!obj_obj || !assoc2dconstraintgroup)
     {
       fail ("NULL ASSOC2DCONSTRAINTGROUP");
       return 1;
     }
   {
     BITCODE_BL action_index;
     if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "action_index", &action_index, NULL)
         && action_index == assoc2dconstraintgroup->action_index)
       pass ();
     else
       fail ("ASSOC2DCONSTRAINTGROUP.action_index [BL] %u != %u", assoc2dconstraintgroup->action_index, action_index);
     action_index++;
     if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "action_index", &action_index, 0)
         && action_index == assoc2dconstraintgroup->action_index)
       pass ();
     else
       fail ("ASSOC2DCONSTRAINTGROUP.action_index [BL] set+1 %u != %u", assoc2dconstraintgroup->action_index, action_index);
     assoc2dconstraintgroup->action_index--;
   }
   {
     BITCODE_H actionbody;
     if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "actionbody", &actionbody, NULL)
         && !memcmp (&actionbody, &assoc2dconstraintgroup->actionbody, sizeof (BITCODE_H)))
         pass ();
     else
         fail ("ASSOC2DCONSTRAINTGROUP.actionbody [H]");
   }
   {
     BITCODE_H* actions;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "num_actions", &count, NULL)
         && dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "actions", &actions, NULL)
         && actions == assoc2dconstraintgroup->actions)
       pass ();
     else
       fail ("ASSOC2DCONSTRAINTGROUP.actions [H*] * %u num_actions", count);
   }
   {
     BITCODE_B b1;
     if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "b1", &b1, NULL)
         && b1 == assoc2dconstraintgroup->b1)
       pass ();
     else
       fail ("ASSOC2DCONSTRAINTGROUP.b1 [B] " FORMAT_B " != " FORMAT_B "", assoc2dconstraintgroup->b1, b1);
     b1++;
     if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "b1", &b1, 0)
         && b1 == assoc2dconstraintgroup->b1)
       pass ();
     else
       fail ("ASSOC2DCONSTRAINTGROUP.b1 [B] set+1 " FORMAT_B " != " FORMAT_B "", assoc2dconstraintgroup->b1, b1);
     assoc2dconstraintgroup->b1--;
   }
   {
     BITCODE_BS class_version;
     if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "class_version", &class_version, NULL)
         && class_version == assoc2dconstraintgroup->class_version)
       pass ();
     else
       fail ("ASSOC2DCONSTRAINTGROUP.class_version [BS] %hu != %hu", assoc2dconstraintgroup->class_version, class_version);
     class_version++;
     if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "class_version", &class_version, 0)
         && class_version == assoc2dconstraintgroup->class_version)
       pass ();
     else
       fail ("ASSOC2DCONSTRAINTGROUP.class_version [BS] set+1 %hu != %hu", assoc2dconstraintgroup->class_version, class_version);
     assoc2dconstraintgroup->class_version--;
   }
   {
     Dwg_ASSOCACTION_Deps* deps;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "num_deps", &count, NULL)
         && dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "deps", &deps, NULL)
         && deps == assoc2dconstraintgroup->deps)
       pass ();
     else
       fail ("ASSOC2DCONSTRAINTGROUP.deps [Dwg_ASSOCACTION_Deps*] * %u num_deps", count);
   }
   {
     BITCODE_BL geometry_status;
     if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "geometry_status", &geometry_status, NULL)
         && geometry_status == assoc2dconstraintgroup->geometry_status)
       pass ();
     else
       fail ("ASSOC2DCONSTRAINTGROUP.geometry_status [BL] %u != %u", assoc2dconstraintgroup->geometry_status, geometry_status);
     geometry_status++;
     if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "geometry_status", &geometry_status, 0)
         && geometry_status == assoc2dconstraintgroup->geometry_status)
       pass ();
     else
       fail ("ASSOC2DCONSTRAINTGROUP.geometry_status [BL] set+1 %u != %u", assoc2dconstraintgroup->geometry_status, geometry_status);
     assoc2dconstraintgroup->geometry_status--;
   }
   {
     BITCODE_H h1;
     if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "h1", &h1, NULL)
         && !memcmp (&h1, &assoc2dconstraintgroup->h1, sizeof (BITCODE_H)))
         pass ();
     else
         fail ("ASSOC2DCONSTRAINTGROUP.h1 [H]");
   }
   {
     BITCODE_BL max_assoc_dep_index;
     if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "max_assoc_dep_index", &max_assoc_dep_index, NULL)
         && max_assoc_dep_index == assoc2dconstraintgroup->max_assoc_dep_index)
       pass ();
     else
       fail ("ASSOC2DCONSTRAINTGROUP.max_assoc_dep_index [BL] %u != %u", assoc2dconstraintgroup->max_assoc_dep_index, max_assoc_dep_index);
     max_assoc_dep_index++;
     if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "max_assoc_dep_index", &max_assoc_dep_index, 0)
         && max_assoc_dep_index == assoc2dconstraintgroup->max_assoc_dep_index)
       pass ();
     else
       fail ("ASSOC2DCONSTRAINTGROUP.max_assoc_dep_index [BL] set+1 %u != %u", assoc2dconstraintgroup->max_assoc_dep_index, max_assoc_dep_index);
     assoc2dconstraintgroup->max_assoc_dep_index--;
   }
   {
     Dwg_CONSTRAINTGROUPNODE* nodes;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "num_nodes", &count, NULL)
         && dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "nodes", &nodes, NULL)
         && nodes == assoc2dconstraintgroup->nodes)
       pass ();
     else
       fail ("ASSOC2DCONSTRAINTGROUP.nodes [Dwg_CONSTRAINTGROUPNODE*] * %u num_nodes", count);
   }
   {
     BITCODE_BL num_actions;
     if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "num_actions", &num_actions, NULL)
         && num_actions == assoc2dconstraintgroup->num_actions)
       pass ();
     else
       fail ("ASSOC2DCONSTRAINTGROUP.num_actions [BL] %u != %u", assoc2dconstraintgroup->num_actions, num_actions);
     num_actions++;
     if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "num_actions", &num_actions, 0)
         && num_actions == assoc2dconstraintgroup->num_actions)
       pass ();
     else
       fail ("ASSOC2DCONSTRAINTGROUP.num_actions [BL] set+1 %u != %u", assoc2dconstraintgroup->num_actions, num_actions);
     assoc2dconstraintgroup->num_actions--;
   }
   {
     BITCODE_BL num_deps;
     if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "num_deps", &num_deps, NULL)
         && num_deps == assoc2dconstraintgroup->num_deps)
       pass ();
     else
       fail ("ASSOC2DCONSTRAINTGROUP.num_deps [BL] %u != %u", assoc2dconstraintgroup->num_deps, num_deps);
     num_deps++;
     if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "num_deps", &num_deps, 0)
         && num_deps == assoc2dconstraintgroup->num_deps)
       pass ();
     else
       fail ("ASSOC2DCONSTRAINTGROUP.num_deps [BL] set+1 %u != %u", assoc2dconstraintgroup->num_deps, num_deps);
     assoc2dconstraintgroup->num_deps--;
   }
   {
     BITCODE_BL num_nodes;
     if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "num_nodes", &num_nodes, NULL)
         && num_nodes == assoc2dconstraintgroup->num_nodes)
       pass ();
     else
       fail ("ASSOC2DCONSTRAINTGROUP.num_nodes [BL] %u != %u", assoc2dconstraintgroup->num_nodes, num_nodes);
     num_nodes++;
     if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "num_nodes", &num_nodes, 0)
         && num_nodes == assoc2dconstraintgroup->num_nodes)
       pass ();
     else
       fail ("ASSOC2DCONSTRAINTGROUP.num_nodes [BL] set+1 %u != %u", assoc2dconstraintgroup->num_nodes, num_nodes);
     assoc2dconstraintgroup->num_nodes--;
   }
   {
     BITCODE_BL num_owned_params;
     if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "num_owned_params", &num_owned_params, NULL)
         && num_owned_params == assoc2dconstraintgroup->num_owned_params)
       pass ();
     else
       fail ("ASSOC2DCONSTRAINTGROUP.num_owned_params [BL] %u != %u", assoc2dconstraintgroup->num_owned_params, num_owned_params);
     num_owned_params++;
     if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "num_owned_params", &num_owned_params, 0)
         && num_owned_params == assoc2dconstraintgroup->num_owned_params)
       pass ();
     else
       fail ("ASSOC2DCONSTRAINTGROUP.num_owned_params [BL] set+1 %u != %u", assoc2dconstraintgroup->num_owned_params, num_owned_params);
     assoc2dconstraintgroup->num_owned_params--;
   }
   {
     BITCODE_BL num_values;
     if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "num_values", &num_values, NULL)
         && num_values == assoc2dconstraintgroup->num_values)
       pass ();
     else
       fail ("ASSOC2DCONSTRAINTGROUP.num_values [BL] %u != %u", assoc2dconstraintgroup->num_values, num_values);
     num_values++;
     if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "num_values", &num_values, 0)
         && num_values == assoc2dconstraintgroup->num_values)
       pass ();
     else
       fail ("ASSOC2DCONSTRAINTGROUP.num_values [BL] set+1 %u != %u", assoc2dconstraintgroup->num_values, num_values);
     assoc2dconstraintgroup->num_values--;
   }
   {
     BITCODE_H* owned_params;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "num_owned_params", &count, NULL)
         && dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "owned_params", &owned_params, NULL)
         && owned_params == assoc2dconstraintgroup->owned_params)
       pass ();
     else
       fail ("ASSOC2DCONSTRAINTGROUP.owned_params [H*] * %u num_owned_params", count);
   }
   {
     BITCODE_H owningnetwork;
     if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "owningnetwork", &owningnetwork, NULL)
         && !memcmp (&owningnetwork, &assoc2dconstraintgroup->owningnetwork, sizeof (BITCODE_H)))
         pass ();
     else
         fail ("ASSOC2DCONSTRAINTGROUP.owningnetwork [H]");
   }
   {
     struct _dwg_object_object* parent;
     if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "parent", &parent, NULL)
         && !memcmp (&parent, &assoc2dconstraintgroup->parent, sizeof (struct _dwg_object_object*)))
         pass ();
     else
         fail ("ASSOC2DCONSTRAINTGROUP.parent [struct _dwg_object_object*]");
   }
   {
     struct _dwg_VALUEPARAM* values;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "num_values", &count, NULL)
         && dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "values", &values, NULL)
         && values == assoc2dconstraintgroup->values)
       pass ();
     else
       fail ("ASSOC2DCONSTRAINTGROUP.values [struct _dwg_VALUEPARAM*] * %u num_values", count);
   }
   {
     BITCODE_BL version;
     if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "version", &version, NULL)
         && version == assoc2dconstraintgroup->version)
       pass ();
     else
       fail ("ASSOC2DCONSTRAINTGROUP.version [BL] %u != %u", assoc2dconstraintgroup->version, version);
     version++;
     if (dwg_dynapi_entity_set_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "version", &version, 0)
         && version == assoc2dconstraintgroup->version)
       pass ();
     else
       fail ("ASSOC2DCONSTRAINTGROUP.version [BL] set+1 %u != %u", assoc2dconstraintgroup->version, version);
     assoc2dconstraintgroup->version--;
   }
   {
     BITCODE_3BD workplane[3];
-    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "workplane[3]", &workplane, NULL)
+    if (dwg_dynapi_entity_value (assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "workplane", &workplane, NULL)
         && !memcmp (&workplane, &assoc2dconstraintgroup->workplane, sizeof (BITCODE_3BD)))
         pass ();
     else
-        fail ("ASSOC2DCONSTRAINTGROUP.workplane[3] [3BD]");
+        fail ("ASSOC2DCONSTRAINTGROUP.workplane [3BD]");
   }
   if (failed && (is_class_unstable ("ASSOC2DCONSTRAINTGROUP") || is_class_debugging ("ASSOC2DCONSTRAINTGROUP")))
     {
       ok ("%s failed %d tests (TODO unstable)", "ASSOC2DCONSTRAINTGROUP", failed);
       failed = 0;
     }
   return failed;
 }
@@ -30768,623 +30768,623 @@ static int test_ASSOCARRAYMODIFYACTIONBODY (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
   Dwg_Object_ASSOCARRAYMODIFYACTIONBODY *restrict assocarraymodifyactionbody = obj->tio.object->tio.ASSOCARRAYMODIFYACTIONBODY;
   failed = 0;
   if (!obj_obj || !assocarraymodifyactionbody)
     {
       fail ("NULL ASSOCARRAYMODIFYACTIONBODY");
       return 1;
     }
   {
     BITCODE_BL aaab_version;
     if (dwg_dynapi_entity_value (assocarraymodifyactionbody, "ASSOCARRAYMODIFYACTIONBODY", "aaab_version", &aaab_version, NULL)
         && aaab_version == assocarraymodifyactionbody->aaab_version)
       pass ();
     else
       fail ("ASSOCARRAYMODIFYACTIONBODY.aaab_version [BL] %u != %u", assocarraymodifyactionbody->aaab_version, aaab_version);
     aaab_version++;
     if (dwg_dynapi_entity_set_value (assocarraymodifyactionbody, "ASSOCARRAYMODIFYACTIONBODY", "aaab_version", &aaab_version, 0)
         && aaab_version == assocarraymodifyactionbody->aaab_version)
       pass ();
     else
       fail ("ASSOCARRAYMODIFYACTIONBODY.aaab_version [BL] set+1 %u != %u", assocarraymodifyactionbody->aaab_version, aaab_version);
     assocarraymodifyactionbody->aaab_version--;
   }
   {
     BITCODE_BL aab_version;
     if (dwg_dynapi_entity_value (assocarraymodifyactionbody, "ASSOCARRAYMODIFYACTIONBODY", "aab_version", &aab_version, NULL)
         && aab_version == assocarraymodifyactionbody->aab_version)
       pass ();
     else
       fail ("ASSOCARRAYMODIFYACTIONBODY.aab_version [BL] %u != %u", assocarraymodifyactionbody->aab_version, aab_version);
     aab_version++;
     if (dwg_dynapi_entity_set_value (assocarraymodifyactionbody, "ASSOCARRAYMODIFYACTIONBODY", "aab_version", &aab_version, 0)
         && aab_version == assocarraymodifyactionbody->aab_version)
       pass ();
     else
       fail ("ASSOCARRAYMODIFYACTIONBODY.aab_version [BL] set+1 %u != %u", assocarraymodifyactionbody->aab_version, aab_version);
     assocarraymodifyactionbody->aab_version--;
   }
   {
     Dwg_ARRAYITEMLOCATOR* items;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (assocarraymodifyactionbody, "ASSOCARRAYMODIFYACTIONBODY", "num_items", &count, NULL)
         && dwg_dynapi_entity_value (assocarraymodifyactionbody, "ASSOCARRAYMODIFYACTIONBODY", "items", &items, NULL)
         && items == assocarraymodifyactionbody->items)
       pass ();
     else
       fail ("ASSOCARRAYMODIFYACTIONBODY.items [Dwg_ARRAYITEMLOCATOR*] * %u num_items", count);
   }
   {
     BITCODE_BL num_items;
     if (dwg_dynapi_entity_value (assocarraymodifyactionbody, "ASSOCARRAYMODIFYACTIONBODY", "num_items", &num_items, NULL)
         && num_items == assocarraymodifyactionbody->num_items)
       pass ();
     else
       fail ("ASSOCARRAYMODIFYACTIONBODY.num_items [BL] %u != %u", assocarraymodifyactionbody->num_items, num_items);
     num_items++;
     if (dwg_dynapi_entity_set_value (assocarraymodifyactionbody, "ASSOCARRAYMODIFYACTIONBODY", "num_items", &num_items, 0)
         && num_items == assocarraymodifyactionbody->num_items)
       pass ();
     else
       fail ("ASSOCARRAYMODIFYACTIONBODY.num_items [BL] set+1 %u != %u", assocarraymodifyactionbody->num_items, num_items);
     assocarraymodifyactionbody->num_items--;
   }
   {
     Dwg_ASSOCPARAMBASEDACTIONBODY pab;
     if (dwg_dynapi_entity_value (assocarraymodifyactionbody, "ASSOCARRAYMODIFYACTIONBODY", "pab", &pab, NULL)
         && !memcmp (&pab, &assocarraymodifyactionbody->pab, sizeof (Dwg_ASSOCPARAMBASEDACTIONBODY)))
         pass ();
     else
         fail ("ASSOCARRAYMODIFYACTIONBODY.pab [Dwg_ASSOCPARAMBASEDACTIONBODY]");
   }
   {
     BITCODE_T paramblock;
     if (dwg_dynapi_entity_value (assocarraymodifyactionbody, "ASSOCARRAYMODIFYACTIONBODY", "paramblock", &paramblock, NULL)
         && paramblock
            ? strEQ ((char *)paramblock, (char *)assocarraymodifyactionbody->paramblock)
            : !assocarraymodifyactionbody->paramblock)
       pass ();
     else
       fail ("ASSOCARRAYMODIFYACTIONBODY.paramblock [T] '%s' <> '%s'", paramblock, assocarraymodifyactionbody->paramblock);
   }
   {
     struct _dwg_object_object* parent;
     if (dwg_dynapi_entity_value (assocarraymodifyactionbody, "ASSOCARRAYMODIFYACTIONBODY", "parent", &parent, NULL)
         && !memcmp (&parent, &assocarraymodifyactionbody->parent, sizeof (struct _dwg_object_object*)))
         pass ();
     else
         fail ("ASSOCARRAYMODIFYACTIONBODY.parent [struct _dwg_object_object*]");
   }
   {
     BITCODE_BS status;
     if (dwg_dynapi_entity_value (assocarraymodifyactionbody, "ASSOCARRAYMODIFYACTIONBODY", "status", &status, NULL)
         && status == assocarraymodifyactionbody->status)
       pass ();
     else
       fail ("ASSOCARRAYMODIFYACTIONBODY.status [BS] %hu != %hu", assocarraymodifyactionbody->status, status);
     status++;
     if (dwg_dynapi_entity_set_value (assocarraymodifyactionbody, "ASSOCARRAYMODIFYACTIONBODY", "status", &status, 0)
         && status == assocarraymodifyactionbody->status)
       pass ();
     else
       fail ("ASSOCARRAYMODIFYACTIONBODY.status [BS] set+1 %hu != %hu", assocarraymodifyactionbody->status, status);
     assocarraymodifyactionbody->status--;
   }
   {
     BITCODE_BD* transmatrix;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (assocarraymodifyactionbody, "ASSOCARRAYMODIFYACTIONBODY", "num_transmatrix", &count, NULL)
         && dwg_dynapi_entity_value (assocarraymodifyactionbody, "ASSOCARRAYMODIFYACTIONBODY", "transmatrix", &transmatrix, NULL)
         && transmatrix == assocarraymodifyactionbody->transmatrix)
       pass ();
     else
       fail ("ASSOCARRAYMODIFYACTIONBODY.transmatrix [BD*] * %u num_transmatrix", count);
   }
   if (failed && (is_class_unstable ("ASSOCARRAYMODIFYACTIONBODY") || is_class_debugging ("ASSOCARRAYMODIFYACTIONBODY")))
     {
       ok ("%s failed %d tests (TODO unstable)", "ASSOCARRAYMODIFYACTIONBODY", failed);
       failed = 0;
     }
   return failed;
 }
 static int test_ASSOCASMBODYACTIONPARAM (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
   Dwg_Object_ASSOCASMBODYACTIONPARAM *restrict assocasmbodyactionparam = obj->tio.object->tio.ASSOCASMBODYACTIONPARAM;
   failed = 0;
   if (!obj_obj || !assocasmbodyactionparam)
     {
       fail ("NULL ASSOCASMBODYACTIONPARAM");
       return 1;
     }
   {
     BITCODE_B _dxf_sab_converted;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "_dxf_sab_converted", &_dxf_sab_converted, NULL)
         && _dxf_sab_converted == assocasmbodyactionparam->_dxf_sab_converted)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM._dxf_sab_converted [B] " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->_dxf_sab_converted, _dxf_sab_converted);
     _dxf_sab_converted++;
     if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "_dxf_sab_converted", &_dxf_sab_converted, 0)
         && _dxf_sab_converted == assocasmbodyactionparam->_dxf_sab_converted)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM._dxf_sab_converted [B] set+1 " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->_dxf_sab_converted, _dxf_sab_converted);
     assocasmbodyactionparam->_dxf_sab_converted--;
   }
   {
     BITCODE_BL aap_version;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "aap_version", &aap_version, NULL)
         && aap_version == assocasmbodyactionparam->aap_version)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.aap_version [BL] %u != %u", assocasmbodyactionparam->aap_version, aap_version);
     aap_version++;
     if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "aap_version", &aap_version, 0)
         && aap_version == assocasmbodyactionparam->aap_version)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.aap_version [BL] set+1 %u != %u", assocasmbodyactionparam->aap_version, aap_version);
     assocasmbodyactionparam->aap_version--;
   }
   {
     BITCODE_RC* acis_data;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "acis_data", &acis_data, NULL)
         && acis_data
            ? strEQ ((char *)acis_data, (char *)assocasmbodyactionparam->acis_data)
            : !assocasmbodyactionparam->acis_data)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.acis_data [RC*] '%s' <> '%s'", acis_data, assocasmbodyactionparam->acis_data);
   }
   {
     BITCODE_B acis_empty;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "acis_empty", &acis_empty, NULL)
         && acis_empty == assocasmbodyactionparam->acis_empty)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.acis_empty [B] " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->acis_empty, acis_empty);
     acis_empty++;
     if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "acis_empty", &acis_empty, 0)
         && acis_empty == assocasmbodyactionparam->acis_empty)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.acis_empty [B] set+1 " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->acis_empty, acis_empty);
     assocasmbodyactionparam->acis_empty--;
   }
   {
     BITCODE_B acis_empty2;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "acis_empty2", &acis_empty2, NULL)
         && acis_empty2 == assocasmbodyactionparam->acis_empty2)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.acis_empty2 [B] " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->acis_empty2, acis_empty2);
     acis_empty2++;
     if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "acis_empty2", &acis_empty2, 0)
         && acis_empty2 == assocasmbodyactionparam->acis_empty2)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.acis_empty2 [B] set+1 " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->acis_empty2, acis_empty2);
     assocasmbodyactionparam->acis_empty2--;
   }
   {
     BITCODE_B acis_empty_bit;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "acis_empty_bit", &acis_empty_bit, NULL)
         && acis_empty_bit == assocasmbodyactionparam->acis_empty_bit)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.acis_empty_bit [B] " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->acis_empty_bit, acis_empty_bit);
     acis_empty_bit++;
     if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "acis_empty_bit", &acis_empty_bit, 0)
         && acis_empty_bit == assocasmbodyactionparam->acis_empty_bit)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.acis_empty_bit [B] set+1 " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->acis_empty_bit, acis_empty_bit);
     assocasmbodyactionparam->acis_empty_bit--;
   }
   {
     BITCODE_BL asdap_class_version;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "asdap_class_version", &asdap_class_version, NULL)
         && asdap_class_version == assocasmbodyactionparam->asdap_class_version)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.asdap_class_version [BL] %u != %u", assocasmbodyactionparam->asdap_class_version, asdap_class_version);
     asdap_class_version++;
     if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "asdap_class_version", &asdap_class_version, 0)
         && asdap_class_version == assocasmbodyactionparam->asdap_class_version)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.asdap_class_version [BL] set+1 %u != %u", assocasmbodyactionparam->asdap_class_version, asdap_class_version);
     assocasmbodyactionparam->asdap_class_version--;
   }
   {
     BITCODE_BL* block_size;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "block_size", &block_size, NULL)
         && !memcmp (&block_size, &assocasmbodyactionparam->block_size, sizeof (BITCODE_BL*)))
         pass ();
     else
         fail ("ASSOCASMBODYACTIONPARAM.block_size [BL*]");
   }
   {
     BITCODE_BL class_version;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "class_version", &class_version, NULL)
         && class_version == assocasmbodyactionparam->class_version)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.class_version [BL] %u != %u", assocasmbodyactionparam->class_version, class_version);
     class_version++;
     if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "class_version", &class_version, 0)
         && class_version == assocasmbodyactionparam->class_version)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.class_version [BL] set+1 %u != %u", assocasmbodyactionparam->class_version, class_version);
     assocasmbodyactionparam->class_version--;
   }
   {
     BITCODE_H dep;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "dep", &dep, NULL)
         && !memcmp (&dep, &assocasmbodyactionparam->dep, sizeof (BITCODE_H)))
         pass ();
     else
         fail ("ASSOCASMBODYACTIONPARAM.dep [H]");
   }
   {
     char ** encr_sat_data;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "encr_sat_data", &encr_sat_data, NULL)
         && !memcmp (&encr_sat_data, &assocasmbodyactionparam->encr_sat_data, sizeof (assocasmbodyactionparam->encr_sat_data)))
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.encr_sat_data [char **]");
   }
   {
     BITCODE_BL end_marker;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "end_marker", &end_marker, NULL)
         && end_marker == assocasmbodyactionparam->end_marker)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.end_marker [BL] %u != %u", assocasmbodyactionparam->end_marker, end_marker);
     end_marker++;
     if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "end_marker", &end_marker, 0)
         && end_marker == assocasmbodyactionparam->end_marker)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.end_marker [BL] set+1 %u != %u", assocasmbodyactionparam->end_marker, end_marker);
     assocasmbodyactionparam->end_marker--;
   }
   {
     struct _dwg_entity_3DSOLID* extra_acis_data;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "extra_acis_data", &extra_acis_data, NULL)
         && !memcmp (&extra_acis_data, &assocasmbodyactionparam->extra_acis_data, sizeof (struct _dwg_entity_3DSOLID*)))
         pass ();
     else
         fail ("ASSOCASMBODYACTIONPARAM.extra_acis_data [struct _dwg_entity_3DSOLID*]");
   }
   {
     BITCODE_B has_revision_guid;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "has_revision_guid", &has_revision_guid, NULL)
         && has_revision_guid == assocasmbodyactionparam->has_revision_guid)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.has_revision_guid [B] " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->has_revision_guid, has_revision_guid);
     has_revision_guid++;
     if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "has_revision_guid", &has_revision_guid, 0)
         && has_revision_guid == assocasmbodyactionparam->has_revision_guid)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.has_revision_guid [B] set+1 " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->has_revision_guid, has_revision_guid);
     assocasmbodyactionparam->has_revision_guid--;
   }
   {
     BITCODE_H history_id;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "history_id", &history_id, NULL)
         && !memcmp (&history_id, &assocasmbodyactionparam->history_id, sizeof (BITCODE_H)))
         pass ();
     else
         fail ("ASSOCASMBODYACTIONPARAM.history_id [H]");
   }
   {
     BITCODE_BS is_r2013;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "is_r2013", &is_r2013, NULL)
         && is_r2013 == assocasmbodyactionparam->is_r2013)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.is_r2013 [BS] %hu != %hu", assocasmbodyactionparam->is_r2013, is_r2013);
     is_r2013++;
     if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "is_r2013", &is_r2013, 0)
         && is_r2013 == assocasmbodyactionparam->is_r2013)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.is_r2013 [BS] set+1 %hu != %hu", assocasmbodyactionparam->is_r2013, is_r2013);
     assocasmbodyactionparam->is_r2013--;
   }
   {
     BITCODE_B isoline_present;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "isoline_present", &isoline_present, NULL)
         && isoline_present == assocasmbodyactionparam->isoline_present)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.isoline_present [B] " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->isoline_present, isoline_present);
     isoline_present++;
     if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "isoline_present", &isoline_present, 0)
         && isoline_present == assocasmbodyactionparam->isoline_present)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.isoline_present [B] set+1 " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->isoline_present, isoline_present);
     assocasmbodyactionparam->isoline_present--;
   }
   {
     BITCODE_BL isolines;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "isolines", &isolines, NULL)
         && isolines == assocasmbodyactionparam->isolines)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.isolines [BL] %u != %u", assocasmbodyactionparam->isolines, isolines);
     isolines++;
     if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "isolines", &isolines, 0)
         && isolines == assocasmbodyactionparam->isolines)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.isolines [BL] set+1 %u != %u", assocasmbodyactionparam->isolines, isolines);
     assocasmbodyactionparam->isolines--;
   }
   {
     Dwg_3DSOLID_material* materials;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "num_materials", &count, NULL)
         && dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "materials", &materials, NULL)
         && materials == assocasmbodyactionparam->materials)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.materials [Dwg_3DSOLID_material*] * %u num_materials", count);
   }
   {
     BITCODE_T name;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "name", &name, NULL)
         && name
            ? strEQ ((char *)name, (char *)assocasmbodyactionparam->name)
            : !assocasmbodyactionparam->name)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.name [T] '%s' <> '%s'", name, assocasmbodyactionparam->name);
   }
   {
     BITCODE_BL num_blocks;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "num_blocks", &num_blocks, NULL)
         && num_blocks == assocasmbodyactionparam->num_blocks)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.num_blocks [BL] %u != %u", assocasmbodyactionparam->num_blocks, num_blocks);
     num_blocks++;
     if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "num_blocks", &num_blocks, 0)
         && num_blocks == assocasmbodyactionparam->num_blocks)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.num_blocks [BL] set+1 %u != %u", assocasmbodyactionparam->num_blocks, num_blocks);
     assocasmbodyactionparam->num_blocks--;
   }
   {
     BITCODE_BL num_materials;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "num_materials", &num_materials, NULL)
         && num_materials == assocasmbodyactionparam->num_materials)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.num_materials [BL] %u != %u", assocasmbodyactionparam->num_materials, num_materials);
     num_materials++;
     if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "num_materials", &num_materials, 0)
         && num_materials == assocasmbodyactionparam->num_materials)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.num_materials [BL] set+1 %u != %u", assocasmbodyactionparam->num_materials, num_materials);
     assocasmbodyactionparam->num_materials--;
   }
   {
     BITCODE_BL num_silhouettes;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "num_silhouettes", &num_silhouettes, NULL)
         && num_silhouettes == assocasmbodyactionparam->num_silhouettes)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.num_silhouettes [BL] %u != %u", assocasmbodyactionparam->num_silhouettes, num_silhouettes);
     num_silhouettes++;
     if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "num_silhouettes", &num_silhouettes, 0)
         && num_silhouettes == assocasmbodyactionparam->num_silhouettes)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.num_silhouettes [BL] set+1 %u != %u", assocasmbodyactionparam->num_silhouettes, num_silhouettes);
     assocasmbodyactionparam->num_silhouettes--;
   }
   {
     BITCODE_BL num_wires;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "num_wires", &num_wires, NULL)
         && num_wires == assocasmbodyactionparam->num_wires)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.num_wires [BL] %u != %u", assocasmbodyactionparam->num_wires, num_wires);
     num_wires++;
     if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "num_wires", &num_wires, 0)
         && num_wires == assocasmbodyactionparam->num_wires)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.num_wires [BL] set+1 %u != %u", assocasmbodyactionparam->num_wires, num_wires);
     assocasmbodyactionparam->num_wires--;
   }
   {
     struct _dwg_object_object* parent;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "parent", &parent, NULL)
         && !memcmp (&parent, &assocasmbodyactionparam->parent, sizeof (struct _dwg_object_object*)))
         pass ();
     else
         fail ("ASSOCASMBODYACTIONPARAM.parent [struct _dwg_object_object*]");
   }
   {
     BITCODE_3BD point;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "point", &point, NULL)
         && !memcmp (&point, &assocasmbodyactionparam->point, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("ASSOCASMBODYACTIONPARAM.point [3BD]");
   }
   {
     BITCODE_B point_present;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "point_present", &point_present, NULL)
         && point_present == assocasmbodyactionparam->point_present)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.point_present [B] " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->point_present, point_present);
     point_present++;
     if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "point_present", &point_present, 0)
         && point_present == assocasmbodyactionparam->point_present)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.point_present [B] set+1 " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->point_present, point_present);
     assocasmbodyactionparam->point_present--;
   }
   {
     BITCODE_RC revision_bytes[9];
-    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "revision_bytes[9]", &revision_bytes, NULL)
+    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "revision_bytes", &revision_bytes, NULL)
         && !memcmp (&revision_bytes, &assocasmbodyactionparam->revision_bytes, sizeof (BITCODE_RC)))
         pass ();
     else
-        fail ("ASSOCASMBODYACTIONPARAM.revision_bytes[9] [RC]");
+        fail ("ASSOCASMBODYACTIONPARAM.revision_bytes [RC]");
   }
   {
     BITCODE_RC revision_guid[39];
-    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "revision_guid[39]", &revision_guid, NULL)
+    if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "revision_guid", &revision_guid, NULL)
         && !memcmp (&revision_guid, &assocasmbodyactionparam->revision_guid, sizeof (BITCODE_RC)))
         pass ();
     else
-        fail ("ASSOCASMBODYACTIONPARAM.revision_guid[39] [RC]");
+        fail ("ASSOCASMBODYACTIONPARAM.revision_guid [RC]");
   }
   {
     BITCODE_BL revision_major;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "revision_major", &revision_major, NULL)
         && revision_major == assocasmbodyactionparam->revision_major)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.revision_major [BL] %u != %u", assocasmbodyactionparam->revision_major, revision_major);
     revision_major++;
     if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "revision_major", &revision_major, 0)
         && revision_major == assocasmbodyactionparam->revision_major)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.revision_major [BL] set+1 %u != %u", assocasmbodyactionparam->revision_major, revision_major);
     assocasmbodyactionparam->revision_major--;
   }
   {
     BITCODE_BS revision_minor1;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "revision_minor1", &revision_minor1, NULL)
         && revision_minor1 == assocasmbodyactionparam->revision_minor1)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.revision_minor1 [BS] %hu != %hu", assocasmbodyactionparam->revision_minor1, revision_minor1);
     revision_minor1++;
     if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "revision_minor1", &revision_minor1, 0)
         && revision_minor1 == assocasmbodyactionparam->revision_minor1)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.revision_minor1 [BS] set+1 %hu != %hu", assocasmbodyactionparam->revision_minor1, revision_minor1);
     assocasmbodyactionparam->revision_minor1--;
   }
   {
     BITCODE_BS revision_minor2;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "revision_minor2", &revision_minor2, NULL)
         && revision_minor2 == assocasmbodyactionparam->revision_minor2)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.revision_minor2 [BS] %hu != %hu", assocasmbodyactionparam->revision_minor2, revision_minor2);
     revision_minor2++;
     if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "revision_minor2", &revision_minor2, 0)
         && revision_minor2 == assocasmbodyactionparam->revision_minor2)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.revision_minor2 [BS] set+1 %hu != %hu", assocasmbodyactionparam->revision_minor2, revision_minor2);
     assocasmbodyactionparam->revision_minor2--;
   }
   {
     BITCODE_BL sab_size;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "sab_size", &sab_size, NULL)
         && sab_size == assocasmbodyactionparam->sab_size)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.sab_size [BL] %u != %u", assocasmbodyactionparam->sab_size, sab_size);
     sab_size++;
     if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "sab_size", &sab_size, 0)
         && sab_size == assocasmbodyactionparam->sab_size)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.sab_size [BL] set+1 %u != %u", assocasmbodyactionparam->sab_size, sab_size);
     assocasmbodyactionparam->sab_size--;
   }
   {
     Dwg_3DSOLID_silhouette* silhouettes;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "num_silhouettes", &count, NULL)
         && dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "silhouettes", &silhouettes, NULL)
         && silhouettes == assocasmbodyactionparam->silhouettes)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.silhouettes [Dwg_3DSOLID_silhouette*] * %u num_silhouettes", count);
   }
   {
     BITCODE_B unknown;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "unknown", &unknown, NULL)
         && unknown == assocasmbodyactionparam->unknown)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.unknown [B] " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->unknown, unknown);
     unknown++;
     if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "unknown", &unknown, 0)
         && unknown == assocasmbodyactionparam->unknown)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.unknown [B] set+1 " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->unknown, unknown);
     assocasmbodyactionparam->unknown--;
   }
   {
     BITCODE_BS version;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "version", &version, NULL)
         && version == assocasmbodyactionparam->version)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.version [BS] %hu != %hu", assocasmbodyactionparam->version, version);
     version++;
     if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "version", &version, 0)
         && version == assocasmbodyactionparam->version)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.version [BS] set+1 %hu != %hu", assocasmbodyactionparam->version, version);
     assocasmbodyactionparam->version--;
   }
   {
     BITCODE_B wireframe_data_present;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "wireframe_data_present", &wireframe_data_present, NULL)
         && wireframe_data_present == assocasmbodyactionparam->wireframe_data_present)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.wireframe_data_present [B] " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->wireframe_data_present, wireframe_data_present);
     wireframe_data_present++;
     if (dwg_dynapi_entity_set_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "wireframe_data_present", &wireframe_data_present, 0)
         && wireframe_data_present == assocasmbodyactionparam->wireframe_data_present)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.wireframe_data_present [B] set+1 " FORMAT_B " != " FORMAT_B "", assocasmbodyactionparam->wireframe_data_present, wireframe_data_present);
     assocasmbodyactionparam->wireframe_data_present--;
   }
   {
     Dwg_3DSOLID_wire* wires;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "num_wires", &count, NULL)
         && dwg_dynapi_entity_value (assocasmbodyactionparam, "ASSOCASMBODYACTIONPARAM", "wires", &wires, NULL)
         && wires == assocasmbodyactionparam->wires)
       pass ();
     else
       fail ("ASSOCASMBODYACTIONPARAM.wires [Dwg_3DSOLID_wire*] * %u num_wires", count);
   }
   if (failed && (is_class_unstable ("ASSOCASMBODYACTIONPARAM") || is_class_debugging ("ASSOCASMBODYACTIONPARAM")))
     {
       ok ("%s failed %d tests (TODO unstable)", "ASSOCASMBODYACTIONPARAM", failed);
       failed = 0;
     }
   return failed;
 }
@@ -36943,490 +36943,490 @@ static int test_BLOCKANGULARCONSTRAINTPARAMETER (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
   Dwg_Object_BLOCKANGULARCONSTRAINTPARAMETER *restrict blockangularconstraintparameter = obj->tio.object->tio.BLOCKANGULARCONSTRAINTPARAMETER;
   failed = 0;
   if (!obj_obj || !blockangularconstraintparameter)
     {
       fail ("NULL BLOCKANGULARCONSTRAINTPARAMETER");
       return 1;
     }
   {
     BITCODE_BD angle;
     if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "angle", &angle, NULL)
         && angle == blockangularconstraintparameter->angle)
       pass ();
     else
       fail ("BLOCKANGULARCONSTRAINTPARAMETER.angle [BD] %g != %g", blockangularconstraintparameter->angle, angle);
     angle++;
     if (dwg_dynapi_entity_set_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "angle", &angle, 0)
         && angle == blockangularconstraintparameter->angle)
       pass ();
     else
       fail ("BLOCKANGULARCONSTRAINTPARAMETER.angle [BD] set+1 %g != %g", blockangularconstraintparameter->angle, angle);
     blockangularconstraintparameter->angle--;
   }
   {
     BITCODE_3BD basept;
     if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "basept", &basept, NULL)
         && !memcmp (&basept, &blockangularconstraintparameter->basept, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKANGULARCONSTRAINTPARAMETER.basept [3BD]");
   }
   {
     BITCODE_BL be_major;
     if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "be_major", &be_major, NULL)
         && be_major == blockangularconstraintparameter->be_major)
       pass ();
     else
       fail ("BLOCKANGULARCONSTRAINTPARAMETER.be_major [BL] %u != %u", blockangularconstraintparameter->be_major, be_major);
     be_major++;
     if (dwg_dynapi_entity_set_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "be_major", &be_major, 0)
         && be_major == blockangularconstraintparameter->be_major)
       pass ();
     else
       fail ("BLOCKANGULARCONSTRAINTPARAMETER.be_major [BL] set+1 %u != %u", blockangularconstraintparameter->be_major, be_major);
     blockangularconstraintparameter->be_major--;
   }
   {
     BITCODE_BL be_minor;
     if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "be_minor", &be_minor, NULL)
         && be_minor == blockangularconstraintparameter->be_minor)
       pass ();
     else
       fail ("BLOCKANGULARCONSTRAINTPARAMETER.be_minor [BL] %u != %u", blockangularconstraintparameter->be_minor, be_minor);
     be_minor++;
     if (dwg_dynapi_entity_set_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "be_minor", &be_minor, 0)
         && be_minor == blockangularconstraintparameter->be_minor)
       pass ();
     else
       fail ("BLOCKANGULARCONSTRAINTPARAMETER.be_minor [BL] set+1 %u != %u", blockangularconstraintparameter->be_minor, be_minor);
     blockangularconstraintparameter->be_minor--;
   }
   {
     BITCODE_3BD center_pt;
     if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "center_pt", &center_pt, NULL)
         && !memcmp (&center_pt, &blockangularconstraintparameter->center_pt, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKANGULARCONSTRAINTPARAMETER.center_pt [3BD]");
   }
   {
     BITCODE_B chain_actions;
     if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "chain_actions", &chain_actions, NULL)
         && chain_actions == blockangularconstraintparameter->chain_actions)
       pass ();
     else
       fail ("BLOCKANGULARCONSTRAINTPARAMETER.chain_actions [B] " FORMAT_B " != " FORMAT_B "", blockangularconstraintparameter->chain_actions, chain_actions);
     chain_actions++;
     if (dwg_dynapi_entity_set_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "chain_actions", &chain_actions, 0)
         && chain_actions == blockangularconstraintparameter->chain_actions)
       pass ();
     else
       fail ("BLOCKANGULARCONSTRAINTPARAMETER.chain_actions [B] set+1 " FORMAT_B " != " FORMAT_B "", blockangularconstraintparameter->chain_actions, chain_actions);
     blockangularconstraintparameter->chain_actions--;
   }
   {
     BITCODE_3BD def_basept;
     if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "def_basept", &def_basept, NULL)
         && !memcmp (&def_basept, &blockangularconstraintparameter->def_basept, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKANGULARCONSTRAINTPARAMETER.def_basept [3BD]");
   }
   {
     BITCODE_3BD def_endpt;
     if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "def_endpt", &def_endpt, NULL)
         && !memcmp (&def_endpt, &blockangularconstraintparameter->def_endpt, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKANGULARCONSTRAINTPARAMETER.def_endpt [3BD]");
   }
   {
     BITCODE_H dependency;
     if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "dependency", &dependency, NULL)
         && !memcmp (&dependency, &blockangularconstraintparameter->dependency, sizeof (BITCODE_H)))
         pass ();
     else
         fail ("BLOCKANGULARCONSTRAINTPARAMETER.dependency [H]");
   }
   {
     BITCODE_BL eed1071;
     if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "eed1071", &eed1071, NULL)
         && eed1071 == blockangularconstraintparameter->eed1071)
       pass ();
     else
       fail ("BLOCKANGULARCONSTRAINTPARAMETER.eed1071 [BL] %u != %u", blockangularconstraintparameter->eed1071, eed1071);
     eed1071++;
     if (dwg_dynapi_entity_set_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "eed1071", &eed1071, 0)
         && eed1071 == blockangularconstraintparameter->eed1071)
       pass ();
     else
       fail ("BLOCKANGULARCONSTRAINTPARAMETER.eed1071 [BL] set+1 %u != %u", blockangularconstraintparameter->eed1071, eed1071);
     blockangularconstraintparameter->eed1071--;
   }
   {
     BITCODE_3BD end_pt;
     if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "end_pt", &end_pt, NULL)
         && !memcmp (&end_pt, &blockangularconstraintparameter->end_pt, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKANGULARCONSTRAINTPARAMETER.end_pt [3BD]");
   }
   {
     BITCODE_3BD endpt;
     if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "endpt", &endpt, NULL)
         && !memcmp (&endpt, &blockangularconstraintparameter->endpt, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKANGULARCONSTRAINTPARAMETER.endpt [3BD]");
   }
   {
     Dwg_EvalExpr evalexpr;
     if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "evalexpr", &evalexpr, NULL)
         && !memcmp (&evalexpr, &blockangularconstraintparameter->evalexpr, sizeof (Dwg_EvalExpr)))
         pass ();
     else
         fail ("BLOCKANGULARCONSTRAINTPARAMETER.evalexpr [Dwg_EvalExpr]");
   }
   {
     BITCODE_T expr_description;
     if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "expr_description", &expr_description, NULL)
         && expr_description
            ? strEQ ((char *)expr_description, (char *)blockangularconstraintparameter->expr_description)
            : !blockangularconstraintparameter->expr_description)
       pass ();
     else
       fail ("BLOCKANGULARCONSTRAINTPARAMETER.expr_description [T] '%s' <> '%s'", expr_description, blockangularconstraintparameter->expr_description);
   }
   {
     BITCODE_T expr_name;
     if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "expr_name", &expr_name, NULL)
         && expr_name
            ? strEQ ((char *)expr_name, (char *)blockangularconstraintparameter->expr_name)
            : !blockangularconstraintparameter->expr_name)
       pass ();
     else
       fail ("BLOCKANGULARCONSTRAINTPARAMETER.expr_name [T] '%s' <> '%s'", expr_name, blockangularconstraintparameter->expr_name);
   }
   {
     BITCODE_T name;
     if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "name", &name, NULL)
         && name
            ? strEQ ((char *)name, (char *)blockangularconstraintparameter->name)
            : !blockangularconstraintparameter->name)
       pass ();
     else
       fail ("BLOCKANGULARCONSTRAINTPARAMETER.name [T] '%s' <> '%s'", name, blockangularconstraintparameter->name);
   }
   {
     BITCODE_B orientation_on_both_grips;
     if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "orientation_on_both_grips", &orientation_on_both_grips, NULL)
         && orientation_on_both_grips == blockangularconstraintparameter->orientation_on_both_grips)
       pass ();
     else
       fail ("BLOCKANGULARCONSTRAINTPARAMETER.orientation_on_both_grips [B] " FORMAT_B " != " FORMAT_B "", blockangularconstraintparameter->orientation_on_both_grips, orientation_on_both_grips);
     orientation_on_both_grips++;
     if (dwg_dynapi_entity_set_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "orientation_on_both_grips", &orientation_on_both_grips, 0)
         && orientation_on_both_grips == blockangularconstraintparameter->orientation_on_both_grips)
       pass ();
     else
       fail ("BLOCKANGULARCONSTRAINTPARAMETER.orientation_on_both_grips [B] set+1 " FORMAT_B " != " FORMAT_B "", blockangularconstraintparameter->orientation_on_both_grips, orientation_on_both_grips);
     blockangularconstraintparameter->orientation_on_both_grips--;
   }
   {
     BITCODE_BS parameter_base_location;
     if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "parameter_base_location", &parameter_base_location, NULL)
         && parameter_base_location == blockangularconstraintparameter->parameter_base_location)
       pass ();
     else
       fail ("BLOCKANGULARCONSTRAINTPARAMETER.parameter_base_location [BS] %hu != %hu", blockangularconstraintparameter->parameter_base_location, parameter_base_location);
     parameter_base_location++;
     if (dwg_dynapi_entity_set_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "parameter_base_location", &parameter_base_location, 0)
         && parameter_base_location == blockangularconstraintparameter->parameter_base_location)
       pass ();
     else
       fail ("BLOCKANGULARCONSTRAINTPARAMETER.parameter_base_location [BS] set+1 %hu != %hu", blockangularconstraintparameter->parameter_base_location, parameter_base_location);
     blockangularconstraintparameter->parameter_base_location--;
   }
   {
     struct _dwg_object_object* parent;
     if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "parent", &parent, NULL)
         && !memcmp (&parent, &blockangularconstraintparameter->parent, sizeof (struct _dwg_object_object*)))
         pass ();
     else
         fail ("BLOCKANGULARCONSTRAINTPARAMETER.parent [struct _dwg_object_object*]");
   }
   {
     Dwg_BLOCKPARAMETER_PropInfo prop1;
     if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "prop1", &prop1, NULL)
         && !memcmp (&prop1, &blockangularconstraintparameter->prop1, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
         pass ();
     else
         fail ("BLOCKANGULARCONSTRAINTPARAMETER.prop1 [Dwg_BLOCKPARAMETER_PropInfo]");
   }
   {
     Dwg_BLOCKPARAMETER_PropInfo prop2;
     if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "prop2", &prop2, NULL)
         && !memcmp (&prop2, &blockangularconstraintparameter->prop2, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
         pass ();
     else
         fail ("BLOCKANGULARCONSTRAINTPARAMETER.prop2 [Dwg_BLOCKPARAMETER_PropInfo]");
   }
   {
     Dwg_BLOCKPARAMETER_PropInfo prop3;
     if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "prop3", &prop3, NULL)
         && !memcmp (&prop3, &blockangularconstraintparameter->prop3, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
         pass ();
     else
         fail ("BLOCKANGULARCONSTRAINTPARAMETER.prop3 [Dwg_BLOCKPARAMETER_PropInfo]");
   }
   {
     Dwg_BLOCKPARAMETER_PropInfo prop4;
     if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "prop4", &prop4, NULL)
         && !memcmp (&prop4, &blockangularconstraintparameter->prop4, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
         pass ();
     else
         fail ("BLOCKANGULARCONSTRAINTPARAMETER.prop4 [Dwg_BLOCKPARAMETER_PropInfo]");
   }
   {
     BITCODE_BL* prop_states;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "num_prop_states", &count, NULL)
         && dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "prop_states", &prop_states, NULL)
         && prop_states == blockangularconstraintparameter->prop_states)
       pass ();
     else
       fail ("BLOCKANGULARCONSTRAINTPARAMETER.prop_states [BL*] * %u num_prop_states", count);
   }
   {
     BITCODE_B show_properties;
     if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "show_properties", &show_properties, NULL)
         && show_properties == blockangularconstraintparameter->show_properties)
       pass ();
     else
       fail ("BLOCKANGULARCONSTRAINTPARAMETER.show_properties [B] " FORMAT_B " != " FORMAT_B "", blockangularconstraintparameter->show_properties, show_properties);
     show_properties++;
     if (dwg_dynapi_entity_set_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "show_properties", &show_properties, 0)
         && show_properties == blockangularconstraintparameter->show_properties)
       pass ();
     else
       fail ("BLOCKANGULARCONSTRAINTPARAMETER.show_properties [B] set+1 " FORMAT_B " != " FORMAT_B "", blockangularconstraintparameter->show_properties, show_properties);
     blockangularconstraintparameter->show_properties--;
   }
   {
     BITCODE_3BD upd_basept;
     if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "upd_basept", &upd_basept, NULL)
         && !memcmp (&upd_basept, &blockangularconstraintparameter->upd_basept, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKANGULARCONSTRAINTPARAMETER.upd_basept [3BD]");
   }
   {
     BITCODE_3BD upd_endpt;
     if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "upd_endpt", &upd_endpt, NULL)
         && !memcmp (&upd_endpt, &blockangularconstraintparameter->upd_endpt, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKANGULARCONSTRAINTPARAMETER.upd_endpt [3BD]");
   }
   {
     Dwg_BLOCKPARAMVALUESET value_set;
     if (dwg_dynapi_entity_value (blockangularconstraintparameter, "BLOCKANGULARCONSTRAINTPARAMETER", "value_set", &value_set, NULL)
         && !memcmp (&value_set, &blockangularconstraintparameter->value_set, sizeof (Dwg_BLOCKPARAMVALUESET)))
         pass ();
     else
         fail ("BLOCKANGULARCONSTRAINTPARAMETER.value_set [Dwg_BLOCKPARAMVALUESET]");
   }
   if (failed && (is_class_unstable ("BLOCKANGULARCONSTRAINTPARAMETER") || is_class_debugging ("BLOCKANGULARCONSTRAINTPARAMETER")))
     {
       ok ("%s failed %d tests (TODO unstable)", "BLOCKANGULARCONSTRAINTPARAMETER", failed);
       failed = 0;
     }
   return failed;
 }
 static int test_BLOCKARRAYACTION (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
   Dwg_Object_BLOCKARRAYACTION *restrict blockarrayaction = obj->tio.object->tio.BLOCKARRAYACTION;
   failed = 0;
   if (!obj_obj || !blockarrayaction)
     {
       fail ("NULL BLOCKARRAYACTION");
       return 1;
     }
   {
     BITCODE_BL* actions;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (blockarrayaction, "BLOCKARRAYACTION", "num_actions", &count, NULL)
         && dwg_dynapi_entity_value (blockarrayaction, "BLOCKARRAYACTION", "actions", &actions, NULL)
         && actions == blockarrayaction->actions)
       pass ();
     else
       fail ("BLOCKARRAYACTION.actions [BL*] * %u num_actions", count);
   }
   {
     BITCODE_BL be_major;
     if (dwg_dynapi_entity_value (blockarrayaction, "BLOCKARRAYACTION", "be_major", &be_major, NULL)
         && be_major == blockarrayaction->be_major)
       pass ();
     else
       fail ("BLOCKARRAYACTION.be_major [BL] %u != %u", blockarrayaction->be_major, be_major);
     be_major++;
     if (dwg_dynapi_entity_set_value (blockarrayaction, "BLOCKARRAYACTION", "be_major", &be_major, 0)
         && be_major == blockarrayaction->be_major)
       pass ();
     else
       fail ("BLOCKARRAYACTION.be_major [BL] set+1 %u != %u", blockarrayaction->be_major, be_major);
     blockarrayaction->be_major--;
   }
   {
     BITCODE_BL be_minor;
     if (dwg_dynapi_entity_value (blockarrayaction, "BLOCKARRAYACTION", "be_minor", &be_minor, NULL)
         && be_minor == blockarrayaction->be_minor)
       pass ();
     else
       fail ("BLOCKARRAYACTION.be_minor [BL] %u != %u", blockarrayaction->be_minor, be_minor);
     be_minor++;
     if (dwg_dynapi_entity_set_value (blockarrayaction, "BLOCKARRAYACTION", "be_minor", &be_minor, 0)
         && be_minor == blockarrayaction->be_minor)
       pass ();
     else
       fail ("BLOCKARRAYACTION.be_minor [BL] set+1 %u != %u", blockarrayaction->be_minor, be_minor);
     blockarrayaction->be_minor--;
   }
   {
     BITCODE_BD column_offset;
     if (dwg_dynapi_entity_value (blockarrayaction, "BLOCKARRAYACTION", "column_offset", &column_offset, NULL)
         && column_offset == blockarrayaction->column_offset)
       pass ();
     else
       fail ("BLOCKARRAYACTION.column_offset [BD] %g != %g", blockarrayaction->column_offset, column_offset);
     column_offset++;
     if (dwg_dynapi_entity_set_value (blockarrayaction, "BLOCKARRAYACTION", "column_offset", &column_offset, 0)
         && column_offset == blockarrayaction->column_offset)
       pass ();
     else
       fail ("BLOCKARRAYACTION.column_offset [BD] set+1 %g != %g", blockarrayaction->column_offset, column_offset);
     blockarrayaction->column_offset--;
   }
   {
-    Dwg_BLOCKACTION_connectionpts conn_pts;
-    if (dwg_dynapi_entity_value (blockarrayaction, "BLOCKARRAYACTION", "conn_pts[4]", &conn_pts, NULL)
+    Dwg_BLOCKACTION_connectionpts conn_pts[4];
+    if (dwg_dynapi_entity_value (blockarrayaction, "BLOCKARRAYACTION", "conn_pts", &conn_pts, NULL)
         && !memcmp (&conn_pts, &blockarrayaction->conn_pts, sizeof (Dwg_BLOCKACTION_connectionpts)))
         pass ();
     else
-        fail ("BLOCKARRAYACTION.conn_pts[4] [Dwg_BLOCKACTION_connectionpts]");
+        fail ("BLOCKARRAYACTION.conn_pts [Dwg_BLOCKACTION_connectionpts]");
   }
   {
     BITCODE_H* deps;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (blockarrayaction, "BLOCKARRAYACTION", "num_deps", &count, NULL)
         && dwg_dynapi_entity_value (blockarrayaction, "BLOCKARRAYACTION", "deps", &deps, NULL)
         && deps == blockarrayaction->deps)
       pass ();
     else
       fail ("BLOCKARRAYACTION.deps [H*] * %u num_deps", count);
   }
   {
     BITCODE_3BD display_location;
     if (dwg_dynapi_entity_value (blockarrayaction, "BLOCKARRAYACTION", "display_location", &display_location, NULL)
         && !memcmp (&display_location, &blockarrayaction->display_location, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKARRAYACTION.display_location [3BD]");
   }
   {
     BITCODE_BL eed1071;
     if (dwg_dynapi_entity_value (blockarrayaction, "BLOCKARRAYACTION", "eed1071", &eed1071, NULL)
         && eed1071 == blockarrayaction->eed1071)
       pass ();
     else
       fail ("BLOCKARRAYACTION.eed1071 [BL] %u != %u", blockarrayaction->eed1071, eed1071);
     eed1071++;
     if (dwg_dynapi_entity_set_value (blockarrayaction, "BLOCKARRAYACTION", "eed1071", &eed1071, 0)
         && eed1071 == blockarrayaction->eed1071)
       pass ();
     else
       fail ("BLOCKARRAYACTION.eed1071 [BL] set+1 %u != %u", blockarrayaction->eed1071, eed1071);
     blockarrayaction->eed1071--;
   }
   {
     Dwg_EvalExpr evalexpr;
     if (dwg_dynapi_entity_value (blockarrayaction, "BLOCKARRAYACTION", "evalexpr", &evalexpr, NULL)
         && !memcmp (&evalexpr, &blockarrayaction->evalexpr, sizeof (Dwg_EvalExpr)))
         pass ();
     else
         fail ("BLOCKARRAYACTION.evalexpr [Dwg_EvalExpr]");
   }
   {
     BITCODE_T name;
     if (dwg_dynapi_entity_value (blockarrayaction, "BLOCKARRAYACTION", "name", &name, NULL)
         && name
            ? strEQ ((char *)name, (char *)blockarrayaction->name)
            : !blockarrayaction->name)
       pass ();
     else
       fail ("BLOCKARRAYACTION.name [T] '%s' <> '%s'", name, blockarrayaction->name);
   }
   {
     BITCODE_BL num_actions;
     if (dwg_dynapi_entity_value (blockarrayaction, "BLOCKARRAYACTION", "num_actions", &num_actions, NULL)
         && num_actions == blockarrayaction->num_actions)
       pass ();
     else
       fail ("BLOCKARRAYACTION.num_actions [BL] %u != %u", blockarrayaction->num_actions, num_actions);
     num_actions++;
     if (dwg_dynapi_entity_set_value (blockarrayaction, "BLOCKARRAYACTION", "num_actions", &num_actions, 0)
         && num_actions == blockarrayaction->num_actions)
       pass ();
     else
       fail ("BLOCKARRAYACTION.num_actions [BL] set+1 %u != %u", blockarrayaction->num_actions, num_actions);
     blockarrayaction->num_actions--;
   }
   {
     BITCODE_BL num_deps;
     if (dwg_dynapi_entity_value (blockarrayaction, "BLOCKARRAYACTION", "num_deps", &num_deps, NULL)
         && num_deps == blockarrayaction->num_deps)
       pass ();
     else
       fail ("BLOCKARRAYACTION.num_deps [BL] %u != %u", blockarrayaction->num_deps, num_deps);
     num_deps++;
     if (dwg_dynapi_entity_set_value (blockarrayaction, "BLOCKARRAYACTION", "num_deps", &num_deps, 0)
         && num_deps == blockarrayaction->num_deps)
       pass ();
     else
       fail ("BLOCKARRAYACTION.num_deps [BL] set+1 %u != %u", blockarrayaction->num_deps, num_deps);
     blockarrayaction->num_deps--;
   }
   {
     struct _dwg_object_object* parent;
     if (dwg_dynapi_entity_value (blockarrayaction, "BLOCKARRAYACTION", "parent", &parent, NULL)
         && !memcmp (&parent, &blockarrayaction->parent, sizeof (struct _dwg_object_object*)))
         pass ();
     else
         fail ("BLOCKARRAYACTION.parent [struct _dwg_object_object*]");
   }
   {
     BITCODE_BD row_offset;
     if (dwg_dynapi_entity_value (blockarrayaction, "BLOCKARRAYACTION", "row_offset", &row_offset, NULL)
         && row_offset == blockarrayaction->row_offset)
       pass ();
     else
       fail ("BLOCKARRAYACTION.row_offset [BD] %g != %g", blockarrayaction->row_offset, row_offset);
     row_offset++;
     if (dwg_dynapi_entity_set_value (blockarrayaction, "BLOCKARRAYACTION", "row_offset", &row_offset, 0)
         && row_offset == blockarrayaction->row_offset)
       pass ();
     else
       fail ("BLOCKARRAYACTION.row_offset [BD] set+1 %g != %g", blockarrayaction->row_offset, row_offset);
     blockarrayaction->row_offset--;
   }
   if (failed && (is_class_unstable ("BLOCKARRAYACTION") || is_class_debugging ("BLOCKARRAYACTION")))
     {
       ok ("%s failed %d tests (TODO unstable)", "BLOCKARRAYACTION", failed);
       failed = 0;
     }
   return failed;
 }
@@ -37608,489 +37608,489 @@ static int test_BLOCKDIAMETRICCONSTRAINTPARAMETER (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
   Dwg_Object_BLOCKDIAMETRICCONSTRAINTPARAMETER *restrict blockdiametricconstraintparameter = obj->tio.object->tio.BLOCKDIAMETRICCONSTRAINTPARAMETER;
   failed = 0;
   if (!obj_obj || !blockdiametricconstraintparameter)
     {
       fail ("NULL BLOCKDIAMETRICCONSTRAINTPARAMETER");
       return 1;
     }
   {
     BITCODE_3BD basept;
     if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "basept", &basept, NULL)
         && !memcmp (&basept, &blockdiametricconstraintparameter->basept, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.basept [3BD]");
   }
   {
     BITCODE_BL be_major;
     if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "be_major", &be_major, NULL)
         && be_major == blockdiametricconstraintparameter->be_major)
       pass ();
     else
       fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.be_major [BL] %u != %u", blockdiametricconstraintparameter->be_major, be_major);
     be_major++;
     if (dwg_dynapi_entity_set_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "be_major", &be_major, 0)
         && be_major == blockdiametricconstraintparameter->be_major)
       pass ();
     else
       fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.be_major [BL] set+1 %u != %u", blockdiametricconstraintparameter->be_major, be_major);
     blockdiametricconstraintparameter->be_major--;
   }
   {
     BITCODE_BL be_minor;
     if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "be_minor", &be_minor, NULL)
         && be_minor == blockdiametricconstraintparameter->be_minor)
       pass ();
     else
       fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.be_minor [BL] %u != %u", blockdiametricconstraintparameter->be_minor, be_minor);
     be_minor++;
     if (dwg_dynapi_entity_set_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "be_minor", &be_minor, 0)
         && be_minor == blockdiametricconstraintparameter->be_minor)
       pass ();
     else
       fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.be_minor [BL] set+1 %u != %u", blockdiametricconstraintparameter->be_minor, be_minor);
     blockdiametricconstraintparameter->be_minor--;
   }
   {
     BITCODE_B chain_actions;
     if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "chain_actions", &chain_actions, NULL)
         && chain_actions == blockdiametricconstraintparameter->chain_actions)
       pass ();
     else
       fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.chain_actions [B] " FORMAT_B " != " FORMAT_B "", blockdiametricconstraintparameter->chain_actions, chain_actions);
     chain_actions++;
     if (dwg_dynapi_entity_set_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "chain_actions", &chain_actions, 0)
         && chain_actions == blockdiametricconstraintparameter->chain_actions)
       pass ();
     else
       fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.chain_actions [B] set+1 " FORMAT_B " != " FORMAT_B "", blockdiametricconstraintparameter->chain_actions, chain_actions);
     blockdiametricconstraintparameter->chain_actions--;
   }
   {
     BITCODE_3BD def_basept;
     if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "def_basept", &def_basept, NULL)
         && !memcmp (&def_basept, &blockdiametricconstraintparameter->def_basept, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.def_basept [3BD]");
   }
   {
     BITCODE_3BD def_endpt;
     if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "def_endpt", &def_endpt, NULL)
         && !memcmp (&def_endpt, &blockdiametricconstraintparameter->def_endpt, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.def_endpt [3BD]");
   }
   {
     BITCODE_H dependency;
     if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "dependency", &dependency, NULL)
         && !memcmp (&dependency, &blockdiametricconstraintparameter->dependency, sizeof (BITCODE_H)))
         pass ();
     else
         fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.dependency [H]");
   }
   {
     BITCODE_BD distance;
     if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "distance", &distance, NULL)
         && distance == blockdiametricconstraintparameter->distance)
       pass ();
     else
       fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.distance [BD] %g != %g", blockdiametricconstraintparameter->distance, distance);
     distance++;
     if (dwg_dynapi_entity_set_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "distance", &distance, 0)
         && distance == blockdiametricconstraintparameter->distance)
       pass ();
     else
       fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.distance [BD] set+1 %g != %g", blockdiametricconstraintparameter->distance, distance);
     blockdiametricconstraintparameter->distance--;
   }
   {
     BITCODE_BL eed1071;
     if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "eed1071", &eed1071, NULL)
         && eed1071 == blockdiametricconstraintparameter->eed1071)
       pass ();
     else
       fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.eed1071 [BL] %u != %u", blockdiametricconstraintparameter->eed1071, eed1071);
     eed1071++;
     if (dwg_dynapi_entity_set_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "eed1071", &eed1071, 0)
         && eed1071 == blockdiametricconstraintparameter->eed1071)
       pass ();
     else
       fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.eed1071 [BL] set+1 %u != %u", blockdiametricconstraintparameter->eed1071, eed1071);
     blockdiametricconstraintparameter->eed1071--;
   }
   {
     BITCODE_3BD endpt;
     if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "endpt", &endpt, NULL)
         && !memcmp (&endpt, &blockdiametricconstraintparameter->endpt, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.endpt [3BD]");
   }
   {
     Dwg_EvalExpr evalexpr;
     if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "evalexpr", &evalexpr, NULL)
         && !memcmp (&evalexpr, &blockdiametricconstraintparameter->evalexpr, sizeof (Dwg_EvalExpr)))
         pass ();
     else
         fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.evalexpr [Dwg_EvalExpr]");
   }
   {
     BITCODE_T expr_description;
     if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "expr_description", &expr_description, NULL)
         && expr_description
            ? strEQ ((char *)expr_description, (char *)blockdiametricconstraintparameter->expr_description)
            : !blockdiametricconstraintparameter->expr_description)
       pass ();
     else
       fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.expr_description [T] '%s' <> '%s'", expr_description, blockdiametricconstraintparameter->expr_description);
   }
   {
     BITCODE_T expr_name;
     if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "expr_name", &expr_name, NULL)
         && expr_name
            ? strEQ ((char *)expr_name, (char *)blockdiametricconstraintparameter->expr_name)
            : !blockdiametricconstraintparameter->expr_name)
       pass ();
     else
       fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.expr_name [T] '%s' <> '%s'", expr_name, blockdiametricconstraintparameter->expr_name);
   }
   {
     BITCODE_T name;
     if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "name", &name, NULL)
         && name
            ? strEQ ((char *)name, (char *)blockdiametricconstraintparameter->name)
            : !blockdiametricconstraintparameter->name)
       pass ();
     else
       fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.name [T] '%s' <> '%s'", name, blockdiametricconstraintparameter->name);
   }
   {
     BITCODE_B orientation_on_both_grips;
     if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "orientation_on_both_grips", &orientation_on_both_grips, NULL)
         && orientation_on_both_grips == blockdiametricconstraintparameter->orientation_on_both_grips)
       pass ();
     else
       fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.orientation_on_both_grips [B] " FORMAT_B " != " FORMAT_B "", blockdiametricconstraintparameter->orientation_on_both_grips, orientation_on_both_grips);
     orientation_on_both_grips++;
     if (dwg_dynapi_entity_set_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "orientation_on_both_grips", &orientation_on_both_grips, 0)
         && orientation_on_both_grips == blockdiametricconstraintparameter->orientation_on_both_grips)
       pass ();
     else
       fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.orientation_on_both_grips [B] set+1 " FORMAT_B " != " FORMAT_B "", blockdiametricconstraintparameter->orientation_on_both_grips, orientation_on_both_grips);
     blockdiametricconstraintparameter->orientation_on_both_grips--;
   }
   {
     BITCODE_BS parameter_base_location;
     if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "parameter_base_location", &parameter_base_location, NULL)
         && parameter_base_location == blockdiametricconstraintparameter->parameter_base_location)
       pass ();
     else
       fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.parameter_base_location [BS] %hu != %hu", blockdiametricconstraintparameter->parameter_base_location, parameter_base_location);
     parameter_base_location++;
     if (dwg_dynapi_entity_set_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "parameter_base_location", &parameter_base_location, 0)
         && parameter_base_location == blockdiametricconstraintparameter->parameter_base_location)
       pass ();
     else
       fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.parameter_base_location [BS] set+1 %hu != %hu", blockdiametricconstraintparameter->parameter_base_location, parameter_base_location);
     blockdiametricconstraintparameter->parameter_base_location--;
   }
   {
     struct _dwg_object_object* parent;
     if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "parent", &parent, NULL)
         && !memcmp (&parent, &blockdiametricconstraintparameter->parent, sizeof (struct _dwg_object_object*)))
         pass ();
     else
         fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.parent [struct _dwg_object_object*]");
   }
   {
     Dwg_BLOCKPARAMETER_PropInfo prop1;
     if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "prop1", &prop1, NULL)
         && !memcmp (&prop1, &blockdiametricconstraintparameter->prop1, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
         pass ();
     else
         fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.prop1 [Dwg_BLOCKPARAMETER_PropInfo]");
   }
   {
     Dwg_BLOCKPARAMETER_PropInfo prop2;
     if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "prop2", &prop2, NULL)
         && !memcmp (&prop2, &blockdiametricconstraintparameter->prop2, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
         pass ();
     else
         fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.prop2 [Dwg_BLOCKPARAMETER_PropInfo]");
   }
   {
     Dwg_BLOCKPARAMETER_PropInfo prop3;
     if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "prop3", &prop3, NULL)
         && !memcmp (&prop3, &blockdiametricconstraintparameter->prop3, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
         pass ();
     else
         fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.prop3 [Dwg_BLOCKPARAMETER_PropInfo]");
   }
   {
     Dwg_BLOCKPARAMETER_PropInfo prop4;
     if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "prop4", &prop4, NULL)
         && !memcmp (&prop4, &blockdiametricconstraintparameter->prop4, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
         pass ();
     else
         fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.prop4 [Dwg_BLOCKPARAMETER_PropInfo]");
   }
   {
     BITCODE_BL* prop_states;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "num_prop_states", &count, NULL)
         && dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "prop_states", &prop_states, NULL)
         && prop_states == blockdiametricconstraintparameter->prop_states)
       pass ();
     else
       fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.prop_states [BL*] * %u num_prop_states", count);
   }
   {
     BITCODE_B show_properties;
     if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "show_properties", &show_properties, NULL)
         && show_properties == blockdiametricconstraintparameter->show_properties)
       pass ();
     else
       fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.show_properties [B] " FORMAT_B " != " FORMAT_B "", blockdiametricconstraintparameter->show_properties, show_properties);
     show_properties++;
     if (dwg_dynapi_entity_set_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "show_properties", &show_properties, 0)
         && show_properties == blockdiametricconstraintparameter->show_properties)
       pass ();
     else
       fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.show_properties [B] set+1 " FORMAT_B " != " FORMAT_B "", blockdiametricconstraintparameter->show_properties, show_properties);
     blockdiametricconstraintparameter->show_properties--;
   }
   {
     BITCODE_3BD upd_basept;
     if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "upd_basept", &upd_basept, NULL)
         && !memcmp (&upd_basept, &blockdiametricconstraintparameter->upd_basept, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.upd_basept [3BD]");
   }
   {
     BITCODE_3BD upd_endpt;
     if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "upd_endpt", &upd_endpt, NULL)
         && !memcmp (&upd_endpt, &blockdiametricconstraintparameter->upd_endpt, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.upd_endpt [3BD]");
   }
   {
     Dwg_BLOCKPARAMVALUESET value_set;
     if (dwg_dynapi_entity_value (blockdiametricconstraintparameter, "BLOCKDIAMETRICCONSTRAINTPARAMETER", "value_set", &value_set, NULL)
         && !memcmp (&value_set, &blockdiametricconstraintparameter->value_set, sizeof (Dwg_BLOCKPARAMVALUESET)))
         pass ();
     else
         fail ("BLOCKDIAMETRICCONSTRAINTPARAMETER.value_set [Dwg_BLOCKPARAMVALUESET]");
   }
   if (failed && (is_class_unstable ("BLOCKDIAMETRICCONSTRAINTPARAMETER") || is_class_debugging ("BLOCKDIAMETRICCONSTRAINTPARAMETER")))
     {
       ok ("%s failed %d tests (TODO unstable)", "BLOCKDIAMETRICCONSTRAINTPARAMETER", failed);
       failed = 0;
     }
   return failed;
 }
 static int test_BLOCKFLIPACTION (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
   Dwg_Object_BLOCKFLIPACTION *restrict blockflipaction = obj->tio.object->tio.BLOCKFLIPACTION;
   failed = 0;
   if (!obj_obj || !blockflipaction)
     {
       fail ("NULL BLOCKFLIPACTION");
       return 1;
     }
   {
     BITCODE_BD action_offset_x;
     if (dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "action_offset_x", &action_offset_x, NULL)
         && action_offset_x == blockflipaction->action_offset_x)
       pass ();
     else
       fail ("BLOCKFLIPACTION.action_offset_x [BD] %g != %g", blockflipaction->action_offset_x, action_offset_x);
     action_offset_x++;
     if (dwg_dynapi_entity_set_value (blockflipaction, "BLOCKFLIPACTION", "action_offset_x", &action_offset_x, 0)
         && action_offset_x == blockflipaction->action_offset_x)
       pass ();
     else
       fail ("BLOCKFLIPACTION.action_offset_x [BD] set+1 %g != %g", blockflipaction->action_offset_x, action_offset_x);
     blockflipaction->action_offset_x--;
   }
   {
     BITCODE_BD action_offset_y;
     if (dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "action_offset_y", &action_offset_y, NULL)
         && action_offset_y == blockflipaction->action_offset_y)
       pass ();
     else
       fail ("BLOCKFLIPACTION.action_offset_y [BD] %g != %g", blockflipaction->action_offset_y, action_offset_y);
     action_offset_y++;
     if (dwg_dynapi_entity_set_value (blockflipaction, "BLOCKFLIPACTION", "action_offset_y", &action_offset_y, 0)
         && action_offset_y == blockflipaction->action_offset_y)
       pass ();
     else
       fail ("BLOCKFLIPACTION.action_offset_y [BD] set+1 %g != %g", blockflipaction->action_offset_y, action_offset_y);
     blockflipaction->action_offset_y--;
   }
   {
     BITCODE_BL* actions;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "num_actions", &count, NULL)
         && dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "actions", &actions, NULL)
         && actions == blockflipaction->actions)
       pass ();
     else
       fail ("BLOCKFLIPACTION.actions [BL*] * %u num_actions", count);
   }
   {
     BITCODE_BD angle_offset;
     if (dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "angle_offset", &angle_offset, NULL)
         && angle_offset == blockflipaction->angle_offset)
       pass ();
     else
       fail ("BLOCKFLIPACTION.angle_offset [BD] %g != %g", blockflipaction->angle_offset, angle_offset);
     angle_offset++;
     if (dwg_dynapi_entity_set_value (blockflipaction, "BLOCKFLIPACTION", "angle_offset", &angle_offset, 0)
         && angle_offset == blockflipaction->angle_offset)
       pass ();
     else
       fail ("BLOCKFLIPACTION.angle_offset [BD] set+1 %g != %g", blockflipaction->angle_offset, angle_offset);
     blockflipaction->angle_offset--;
   }
   {
     BITCODE_BL be_major;
     if (dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "be_major", &be_major, NULL)
         && be_major == blockflipaction->be_major)
       pass ();
     else
       fail ("BLOCKFLIPACTION.be_major [BL] %u != %u", blockflipaction->be_major, be_major);
     be_major++;
     if (dwg_dynapi_entity_set_value (blockflipaction, "BLOCKFLIPACTION", "be_major", &be_major, 0)
         && be_major == blockflipaction->be_major)
       pass ();
     else
       fail ("BLOCKFLIPACTION.be_major [BL] set+1 %u != %u", blockflipaction->be_major, be_major);
     blockflipaction->be_major--;
   }
   {
     BITCODE_BL be_minor;
     if (dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "be_minor", &be_minor, NULL)
         && be_minor == blockflipaction->be_minor)
       pass ();
     else
       fail ("BLOCKFLIPACTION.be_minor [BL] %u != %u", blockflipaction->be_minor, be_minor);
     be_minor++;
     if (dwg_dynapi_entity_set_value (blockflipaction, "BLOCKFLIPACTION", "be_minor", &be_minor, 0)
         && be_minor == blockflipaction->be_minor)
       pass ();
     else
       fail ("BLOCKFLIPACTION.be_minor [BL] set+1 %u != %u", blockflipaction->be_minor, be_minor);
     blockflipaction->be_minor--;
   }
   {
-    Dwg_BLOCKACTION_connectionpts conn_pts;
-    if (dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "conn_pts[4]", &conn_pts, NULL)
+    Dwg_BLOCKACTION_connectionpts conn_pts[4];
+    if (dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "conn_pts", &conn_pts, NULL)
         && !memcmp (&conn_pts, &blockflipaction->conn_pts, sizeof (Dwg_BLOCKACTION_connectionpts)))
         pass ();
     else
-        fail ("BLOCKFLIPACTION.conn_pts[4] [Dwg_BLOCKACTION_connectionpts]");
+        fail ("BLOCKFLIPACTION.conn_pts [Dwg_BLOCKACTION_connectionpts]");
   }
   {
     BITCODE_H* deps;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "num_deps", &count, NULL)
         && dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "deps", &deps, NULL)
         && deps == blockflipaction->deps)
       pass ();
     else
       fail ("BLOCKFLIPACTION.deps [H*] * %u num_deps", count);
   }
   {
     BITCODE_3BD display_location;
     if (dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "display_location", &display_location, NULL)
         && !memcmp (&display_location, &blockflipaction->display_location, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKFLIPACTION.display_location [3BD]");
   }
   {
     BITCODE_BL eed1071;
     if (dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "eed1071", &eed1071, NULL)
         && eed1071 == blockflipaction->eed1071)
       pass ();
     else
       fail ("BLOCKFLIPACTION.eed1071 [BL] %u != %u", blockflipaction->eed1071, eed1071);
     eed1071++;
     if (dwg_dynapi_entity_set_value (blockflipaction, "BLOCKFLIPACTION", "eed1071", &eed1071, 0)
         && eed1071 == blockflipaction->eed1071)
       pass ();
     else
       fail ("BLOCKFLIPACTION.eed1071 [BL] set+1 %u != %u", blockflipaction->eed1071, eed1071);
     blockflipaction->eed1071--;
   }
   {
     Dwg_EvalExpr evalexpr;
     if (dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "evalexpr", &evalexpr, NULL)
         && !memcmp (&evalexpr, &blockflipaction->evalexpr, sizeof (Dwg_EvalExpr)))
         pass ();
     else
         fail ("BLOCKFLIPACTION.evalexpr [Dwg_EvalExpr]");
   }
   {
     BITCODE_T name;
     if (dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "name", &name, NULL)
         && name
            ? strEQ ((char *)name, (char *)blockflipaction->name)
            : !blockflipaction->name)
       pass ();
     else
       fail ("BLOCKFLIPACTION.name [T] '%s' <> '%s'", name, blockflipaction->name);
   }
   {
     BITCODE_BL num_actions;
     if (dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "num_actions", &num_actions, NULL)
         && num_actions == blockflipaction->num_actions)
       pass ();
     else
       fail ("BLOCKFLIPACTION.num_actions [BL] %u != %u", blockflipaction->num_actions, num_actions);
     num_actions++;
     if (dwg_dynapi_entity_set_value (blockflipaction, "BLOCKFLIPACTION", "num_actions", &num_actions, 0)
         && num_actions == blockflipaction->num_actions)
       pass ();
     else
       fail ("BLOCKFLIPACTION.num_actions [BL] set+1 %u != %u", blockflipaction->num_actions, num_actions);
     blockflipaction->num_actions--;
   }
   {
     BITCODE_BL num_deps;
     if (dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "num_deps", &num_deps, NULL)
         && num_deps == blockflipaction->num_deps)
       pass ();
     else
       fail ("BLOCKFLIPACTION.num_deps [BL] %u != %u", blockflipaction->num_deps, num_deps);
     num_deps++;
     if (dwg_dynapi_entity_set_value (blockflipaction, "BLOCKFLIPACTION", "num_deps", &num_deps, 0)
         && num_deps == blockflipaction->num_deps)
       pass ();
     else
       fail ("BLOCKFLIPACTION.num_deps [BL] set+1 %u != %u", blockflipaction->num_deps, num_deps);
     blockflipaction->num_deps--;
   }
   {
     struct _dwg_object_object* parent;
     if (dwg_dynapi_entity_value (blockflipaction, "BLOCKFLIPACTION", "parent", &parent, NULL)
         && !memcmp (&parent, &blockflipaction->parent, sizeof (struct _dwg_object_object*)))
         pass ();
     else
         fail ("BLOCKFLIPACTION.parent [struct _dwg_object_object*]");
   }
   if (failed && (is_class_unstable ("BLOCKFLIPACTION") || is_class_debugging ("BLOCKFLIPACTION")))
     {
       ok ("%s failed %d tests (TODO unstable)", "BLOCKFLIPACTION", failed);
       failed = 0;
     }
   return failed;
 }
@@ -40027,402 +40027,402 @@ static int test_BLOCKLOOKUPPARAMETER (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
   Dwg_Object_BLOCKLOOKUPPARAMETER *restrict blocklookupparameter = obj->tio.object->tio.BLOCKLOOKUPPARAMETER;
   failed = 0;
   if (!obj_obj || !blocklookupparameter)
     {
       fail ("NULL BLOCKLOOKUPPARAMETER");
       return 1;
     }
   {
     BITCODE_BL be_major;
     if (dwg_dynapi_entity_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "be_major", &be_major, NULL)
         && be_major == blocklookupparameter->be_major)
       pass ();
     else
       fail ("BLOCKLOOKUPPARAMETER.be_major [BL] %u != %u", blocklookupparameter->be_major, be_major);
     be_major++;
     if (dwg_dynapi_entity_set_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "be_major", &be_major, 0)
         && be_major == blocklookupparameter->be_major)
       pass ();
     else
       fail ("BLOCKLOOKUPPARAMETER.be_major [BL] set+1 %u != %u", blocklookupparameter->be_major, be_major);
     blocklookupparameter->be_major--;
   }
   {
     BITCODE_BL be_minor;
     if (dwg_dynapi_entity_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "be_minor", &be_minor, NULL)
         && be_minor == blocklookupparameter->be_minor)
       pass ();
     else
       fail ("BLOCKLOOKUPPARAMETER.be_minor [BL] %u != %u", blocklookupparameter->be_minor, be_minor);
     be_minor++;
     if (dwg_dynapi_entity_set_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "be_minor", &be_minor, 0)
         && be_minor == blocklookupparameter->be_minor)
       pass ();
     else
       fail ("BLOCKLOOKUPPARAMETER.be_minor [BL] set+1 %u != %u", blocklookupparameter->be_minor, be_minor);
     blocklookupparameter->be_minor--;
   }
   {
     BITCODE_B chain_actions;
     if (dwg_dynapi_entity_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "chain_actions", &chain_actions, NULL)
         && chain_actions == blocklookupparameter->chain_actions)
       pass ();
     else
       fail ("BLOCKLOOKUPPARAMETER.chain_actions [B] " FORMAT_B " != " FORMAT_B "", blocklookupparameter->chain_actions, chain_actions);
     chain_actions++;
     if (dwg_dynapi_entity_set_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "chain_actions", &chain_actions, 0)
         && chain_actions == blocklookupparameter->chain_actions)
       pass ();
     else
       fail ("BLOCKLOOKUPPARAMETER.chain_actions [B] set+1 " FORMAT_B " != " FORMAT_B "", blocklookupparameter->chain_actions, chain_actions);
     blocklookupparameter->chain_actions--;
   }
   {
     BITCODE_3BD def_pt;
     if (dwg_dynapi_entity_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "def_pt", &def_pt, NULL)
         && !memcmp (&def_pt, &blocklookupparameter->def_pt, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKLOOKUPPARAMETER.def_pt [3BD]");
   }
   {
     BITCODE_BL eed1071;
     if (dwg_dynapi_entity_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "eed1071", &eed1071, NULL)
         && eed1071 == blocklookupparameter->eed1071)
       pass ();
     else
       fail ("BLOCKLOOKUPPARAMETER.eed1071 [BL] %u != %u", blocklookupparameter->eed1071, eed1071);
     eed1071++;
     if (dwg_dynapi_entity_set_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "eed1071", &eed1071, 0)
         && eed1071 == blocklookupparameter->eed1071)
       pass ();
     else
       fail ("BLOCKLOOKUPPARAMETER.eed1071 [BL] set+1 %u != %u", blocklookupparameter->eed1071, eed1071);
     blocklookupparameter->eed1071--;
   }
   {
     Dwg_EvalExpr evalexpr;
     if (dwg_dynapi_entity_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "evalexpr", &evalexpr, NULL)
         && !memcmp (&evalexpr, &blocklookupparameter->evalexpr, sizeof (Dwg_EvalExpr)))
         pass ();
     else
         fail ("BLOCKLOOKUPPARAMETER.evalexpr [Dwg_EvalExpr]");
   }
   {
     BITCODE_BL index;
     if (dwg_dynapi_entity_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "index", &index, NULL)
         && index == blocklookupparameter->index)
       pass ();
     else
       fail ("BLOCKLOOKUPPARAMETER.index [BL] %u != %u", blocklookupparameter->index, index);
     index++;
     if (dwg_dynapi_entity_set_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "index", &index, 0)
         && index == blocklookupparameter->index)
       pass ();
     else
       fail ("BLOCKLOOKUPPARAMETER.index [BL] set+1 %u != %u", blocklookupparameter->index, index);
     blocklookupparameter->index--;
   }
   {
     BITCODE_T lookup_desc;
     if (dwg_dynapi_entity_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "lookup_desc", &lookup_desc, NULL)
         && lookup_desc
            ? strEQ ((char *)lookup_desc, (char *)blocklookupparameter->lookup_desc)
            : !blocklookupparameter->lookup_desc)
       pass ();
     else
       fail ("BLOCKLOOKUPPARAMETER.lookup_desc [T] '%s' <> '%s'", lookup_desc, blocklookupparameter->lookup_desc);
   }
   {
     BITCODE_T lookup_name;
     if (dwg_dynapi_entity_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "lookup_name", &lookup_name, NULL)
         && lookup_name
            ? strEQ ((char *)lookup_name, (char *)blocklookupparameter->lookup_name)
            : !blocklookupparameter->lookup_name)
       pass ();
     else
       fail ("BLOCKLOOKUPPARAMETER.lookup_name [T] '%s' <> '%s'", lookup_name, blocklookupparameter->lookup_name);
   }
   {
     BITCODE_T name;
     if (dwg_dynapi_entity_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "name", &name, NULL)
         && name
            ? strEQ ((char *)name, (char *)blocklookupparameter->name)
            : !blocklookupparameter->name)
       pass ();
     else
       fail ("BLOCKLOOKUPPARAMETER.name [T] '%s' <> '%s'", name, blocklookupparameter->name);
   }
   {
     BITCODE_BL num_propinfos;
     if (dwg_dynapi_entity_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "num_propinfos", &num_propinfos, NULL)
         && num_propinfos == blocklookupparameter->num_propinfos)
       pass ();
     else
       fail ("BLOCKLOOKUPPARAMETER.num_propinfos [BL] %u != %u", blocklookupparameter->num_propinfos, num_propinfos);
     num_propinfos++;
     if (dwg_dynapi_entity_set_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "num_propinfos", &num_propinfos, 0)
         && num_propinfos == blocklookupparameter->num_propinfos)
       pass ();
     else
       fail ("BLOCKLOOKUPPARAMETER.num_propinfos [BL] set+1 %u != %u", blocklookupparameter->num_propinfos, num_propinfos);
     blocklookupparameter->num_propinfos--;
   }
   {
     struct _dwg_object_object* parent;
     if (dwg_dynapi_entity_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "parent", &parent, NULL)
         && !memcmp (&parent, &blocklookupparameter->parent, sizeof (struct _dwg_object_object*)))
         pass ();
     else
         fail ("BLOCKLOOKUPPARAMETER.parent [struct _dwg_object_object*]");
   }
   {
     Dwg_BLOCKPARAMETER_PropInfo prop1;
     if (dwg_dynapi_entity_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "prop1", &prop1, NULL)
         && !memcmp (&prop1, &blocklookupparameter->prop1, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
         pass ();
     else
         fail ("BLOCKLOOKUPPARAMETER.prop1 [Dwg_BLOCKPARAMETER_PropInfo]");
   }
   {
     Dwg_BLOCKPARAMETER_PropInfo prop2;
     if (dwg_dynapi_entity_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "prop2", &prop2, NULL)
         && !memcmp (&prop2, &blocklookupparameter->prop2, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
         pass ();
     else
         fail ("BLOCKLOOKUPPARAMETER.prop2 [Dwg_BLOCKPARAMETER_PropInfo]");
   }
   {
     BITCODE_B show_properties;
     if (dwg_dynapi_entity_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "show_properties", &show_properties, NULL)
         && show_properties == blocklookupparameter->show_properties)
       pass ();
     else
       fail ("BLOCKLOOKUPPARAMETER.show_properties [B] " FORMAT_B " != " FORMAT_B "", blocklookupparameter->show_properties, show_properties);
     show_properties++;
     if (dwg_dynapi_entity_set_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "show_properties", &show_properties, 0)
         && show_properties == blocklookupparameter->show_properties)
       pass ();
     else
       fail ("BLOCKLOOKUPPARAMETER.show_properties [B] set+1 " FORMAT_B " != " FORMAT_B "", blocklookupparameter->show_properties, show_properties);
     blocklookupparameter->show_properties--;
   }
   {
     BITCODE_T unknown_t;
     if (dwg_dynapi_entity_value (blocklookupparameter, "BLOCKLOOKUPPARAMETER", "unknown_t", &unknown_t, NULL)
         && unknown_t
            ? strEQ ((char *)unknown_t, (char *)blocklookupparameter->unknown_t)
            : !blocklookupparameter->unknown_t)
       pass ();
     else
       fail ("BLOCKLOOKUPPARAMETER.unknown_t [T] '%s' <> '%s'", unknown_t, blocklookupparameter->unknown_t);
   }
   if (failed && (is_class_unstable ("BLOCKLOOKUPPARAMETER") || is_class_debugging ("BLOCKLOOKUPPARAMETER")))
     {
       ok ("%s failed %d tests (TODO unstable)", "BLOCKLOOKUPPARAMETER", failed);
       failed = 0;
     }
   return failed;
 }
 static int test_BLOCKMOVEACTION (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
   Dwg_Object_BLOCKMOVEACTION *restrict blockmoveaction = obj->tio.object->tio.BLOCKMOVEACTION;
   failed = 0;
   if (!obj_obj || !blockmoveaction)
     {
       fail ("NULL BLOCKMOVEACTION");
       return 1;
     }
   {
     BITCODE_BD action_offset_x;
     if (dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "action_offset_x", &action_offset_x, NULL)
         && action_offset_x == blockmoveaction->action_offset_x)
       pass ();
     else
       fail ("BLOCKMOVEACTION.action_offset_x [BD] %g != %g", blockmoveaction->action_offset_x, action_offset_x);
     action_offset_x++;
     if (dwg_dynapi_entity_set_value (blockmoveaction, "BLOCKMOVEACTION", "action_offset_x", &action_offset_x, 0)
         && action_offset_x == blockmoveaction->action_offset_x)
       pass ();
     else
       fail ("BLOCKMOVEACTION.action_offset_x [BD] set+1 %g != %g", blockmoveaction->action_offset_x, action_offset_x);
     blockmoveaction->action_offset_x--;
   }
   {
     BITCODE_BD action_offset_y;
     if (dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "action_offset_y", &action_offset_y, NULL)
         && action_offset_y == blockmoveaction->action_offset_y)
       pass ();
     else
       fail ("BLOCKMOVEACTION.action_offset_y [BD] %g != %g", blockmoveaction->action_offset_y, action_offset_y);
     action_offset_y++;
     if (dwg_dynapi_entity_set_value (blockmoveaction, "BLOCKMOVEACTION", "action_offset_y", &action_offset_y, 0)
         && action_offset_y == blockmoveaction->action_offset_y)
       pass ();
     else
       fail ("BLOCKMOVEACTION.action_offset_y [BD] set+1 %g != %g", blockmoveaction->action_offset_y, action_offset_y);
     blockmoveaction->action_offset_y--;
   }
   {
     BITCODE_BL* actions;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "num_actions", &count, NULL)
         && dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "actions", &actions, NULL)
         && actions == blockmoveaction->actions)
       pass ();
     else
       fail ("BLOCKMOVEACTION.actions [BL*] * %u num_actions", count);
   }
   {
     BITCODE_BD angle_offset;
     if (dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "angle_offset", &angle_offset, NULL)
         && angle_offset == blockmoveaction->angle_offset)
       pass ();
     else
       fail ("BLOCKMOVEACTION.angle_offset [BD] %g != %g", blockmoveaction->angle_offset, angle_offset);
     angle_offset++;
     if (dwg_dynapi_entity_set_value (blockmoveaction, "BLOCKMOVEACTION", "angle_offset", &angle_offset, 0)
         && angle_offset == blockmoveaction->angle_offset)
       pass ();
     else
       fail ("BLOCKMOVEACTION.angle_offset [BD] set+1 %g != %g", blockmoveaction->angle_offset, angle_offset);
     blockmoveaction->angle_offset--;
   }
   {
     BITCODE_BL be_major;
     if (dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "be_major", &be_major, NULL)
         && be_major == blockmoveaction->be_major)
       pass ();
     else
       fail ("BLOCKMOVEACTION.be_major [BL] %u != %u", blockmoveaction->be_major, be_major);
     be_major++;
     if (dwg_dynapi_entity_set_value (blockmoveaction, "BLOCKMOVEACTION", "be_major", &be_major, 0)
         && be_major == blockmoveaction->be_major)
       pass ();
     else
       fail ("BLOCKMOVEACTION.be_major [BL] set+1 %u != %u", blockmoveaction->be_major, be_major);
     blockmoveaction->be_major--;
   }
   {
     BITCODE_BL be_minor;
     if (dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "be_minor", &be_minor, NULL)
         && be_minor == blockmoveaction->be_minor)
       pass ();
     else
       fail ("BLOCKMOVEACTION.be_minor [BL] %u != %u", blockmoveaction->be_minor, be_minor);
     be_minor++;
     if (dwg_dynapi_entity_set_value (blockmoveaction, "BLOCKMOVEACTION", "be_minor", &be_minor, 0)
         && be_minor == blockmoveaction->be_minor)
       pass ();
     else
       fail ("BLOCKMOVEACTION.be_minor [BL] set+1 %u != %u", blockmoveaction->be_minor, be_minor);
     blockmoveaction->be_minor--;
   }
   {
-    Dwg_BLOCKACTION_connectionpts conn_pts;
-    if (dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "conn_pts[2]", &conn_pts, NULL)
+    Dwg_BLOCKACTION_connectionpts conn_pts[2];
+    if (dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "conn_pts", &conn_pts, NULL)
         && !memcmp (&conn_pts, &blockmoveaction->conn_pts, sizeof (Dwg_BLOCKACTION_connectionpts)))
         pass ();
     else
-        fail ("BLOCKMOVEACTION.conn_pts[2] [Dwg_BLOCKACTION_connectionpts]");
+        fail ("BLOCKMOVEACTION.conn_pts [Dwg_BLOCKACTION_connectionpts]");
   }
   {
     BITCODE_H* deps;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "num_deps", &count, NULL)
         && dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "deps", &deps, NULL)
         && deps == blockmoveaction->deps)
       pass ();
     else
       fail ("BLOCKMOVEACTION.deps [H*] * %u num_deps", count);
   }
   {
     BITCODE_3BD display_location;
     if (dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "display_location", &display_location, NULL)
         && !memcmp (&display_location, &blockmoveaction->display_location, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKMOVEACTION.display_location [3BD]");
   }
   {
     BITCODE_BL eed1071;
     if (dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "eed1071", &eed1071, NULL)
         && eed1071 == blockmoveaction->eed1071)
       pass ();
     else
       fail ("BLOCKMOVEACTION.eed1071 [BL] %u != %u", blockmoveaction->eed1071, eed1071);
     eed1071++;
     if (dwg_dynapi_entity_set_value (blockmoveaction, "BLOCKMOVEACTION", "eed1071", &eed1071, 0)
         && eed1071 == blockmoveaction->eed1071)
       pass ();
     else
       fail ("BLOCKMOVEACTION.eed1071 [BL] set+1 %u != %u", blockmoveaction->eed1071, eed1071);
     blockmoveaction->eed1071--;
   }
   {
     Dwg_EvalExpr evalexpr;
     if (dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "evalexpr", &evalexpr, NULL)
         && !memcmp (&evalexpr, &blockmoveaction->evalexpr, sizeof (Dwg_EvalExpr)))
         pass ();
     else
         fail ("BLOCKMOVEACTION.evalexpr [Dwg_EvalExpr]");
   }
   {
     BITCODE_T name;
     if (dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "name", &name, NULL)
         && name
            ? strEQ ((char *)name, (char *)blockmoveaction->name)
            : !blockmoveaction->name)
       pass ();
     else
       fail ("BLOCKMOVEACTION.name [T] '%s' <> '%s'", name, blockmoveaction->name);
   }
   {
     BITCODE_BL num_actions;
     if (dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "num_actions", &num_actions, NULL)
         && num_actions == blockmoveaction->num_actions)
       pass ();
     else
       fail ("BLOCKMOVEACTION.num_actions [BL] %u != %u", blockmoveaction->num_actions, num_actions);
     num_actions++;
     if (dwg_dynapi_entity_set_value (blockmoveaction, "BLOCKMOVEACTION", "num_actions", &num_actions, 0)
         && num_actions == blockmoveaction->num_actions)
       pass ();
     else
       fail ("BLOCKMOVEACTION.num_actions [BL] set+1 %u != %u", blockmoveaction->num_actions, num_actions);
     blockmoveaction->num_actions--;
   }
   {
     BITCODE_BL num_deps;
     if (dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "num_deps", &num_deps, NULL)
         && num_deps == blockmoveaction->num_deps)
       pass ();
     else
       fail ("BLOCKMOVEACTION.num_deps [BL] %u != %u", blockmoveaction->num_deps, num_deps);
     num_deps++;
     if (dwg_dynapi_entity_set_value (blockmoveaction, "BLOCKMOVEACTION", "num_deps", &num_deps, 0)
         && num_deps == blockmoveaction->num_deps)
       pass ();
     else
       fail ("BLOCKMOVEACTION.num_deps [BL] set+1 %u != %u", blockmoveaction->num_deps, num_deps);
     blockmoveaction->num_deps--;
   }
   {
     struct _dwg_object_object* parent;
     if (dwg_dynapi_entity_value (blockmoveaction, "BLOCKMOVEACTION", "parent", &parent, NULL)
         && !memcmp (&parent, &blockmoveaction->parent, sizeof (struct _dwg_object_object*)))
         pass ();
     else
         fail ("BLOCKMOVEACTION.parent [struct _dwg_object_object*]");
   }
   if (failed && (is_class_unstable ("BLOCKMOVEACTION") || is_class_debugging ("BLOCKMOVEACTION")))
     {
       ok ("%s failed %d tests (TODO unstable)", "BLOCKMOVEACTION", failed);
       failed = 0;
     }
   return failed;
 }
@@ -40853,534 +40853,534 @@ static int test_BLOCKPOLARPARAMETER (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
   Dwg_Object_BLOCKPOLARPARAMETER *restrict blockpolarparameter = obj->tio.object->tio.BLOCKPOLARPARAMETER;
   failed = 0;
   if (!obj_obj || !blockpolarparameter)
     {
       fail ("NULL BLOCKPOLARPARAMETER");
       return 1;
     }
   {
     BITCODE_T angle_desc;
     if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "angle_desc", &angle_desc, NULL)
         && angle_desc
            ? strEQ ((char *)angle_desc, (char *)blockpolarparameter->angle_desc)
            : !blockpolarparameter->angle_desc)
       pass ();
     else
       fail ("BLOCKPOLARPARAMETER.angle_desc [T] '%s' <> '%s'", angle_desc, blockpolarparameter->angle_desc);
   }
   {
     BITCODE_T angle_name;
     if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "angle_name", &angle_name, NULL)
         && angle_name
            ? strEQ ((char *)angle_name, (char *)blockpolarparameter->angle_name)
            : !blockpolarparameter->angle_name)
       pass ();
     else
       fail ("BLOCKPOLARPARAMETER.angle_name [T] '%s' <> '%s'", angle_name, blockpolarparameter->angle_name);
   }
   {
     Dwg_BLOCKPARAMVALUESET angle_value_set;
     if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "angle_value_set", &angle_value_set, NULL)
         && !memcmp (&angle_value_set, &blockpolarparameter->angle_value_set, sizeof (Dwg_BLOCKPARAMVALUESET)))
         pass ();
     else
         fail ("BLOCKPOLARPARAMETER.angle_value_set [Dwg_BLOCKPARAMVALUESET]");
   }
   {
     BITCODE_3BD basept;
     if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "basept", &basept, NULL)
         && !memcmp (&basept, &blockpolarparameter->basept, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKPOLARPARAMETER.basept [3BD]");
   }
   {
     BITCODE_BL be_major;
     if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "be_major", &be_major, NULL)
         && be_major == blockpolarparameter->be_major)
       pass ();
     else
       fail ("BLOCKPOLARPARAMETER.be_major [BL] %u != %u", blockpolarparameter->be_major, be_major);
     be_major++;
     if (dwg_dynapi_entity_set_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "be_major", &be_major, 0)
         && be_major == blockpolarparameter->be_major)
       pass ();
     else
       fail ("BLOCKPOLARPARAMETER.be_major [BL] set+1 %u != %u", blockpolarparameter->be_major, be_major);
     blockpolarparameter->be_major--;
   }
   {
     BITCODE_BL be_minor;
     if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "be_minor", &be_minor, NULL)
         && be_minor == blockpolarparameter->be_minor)
       pass ();
     else
       fail ("BLOCKPOLARPARAMETER.be_minor [BL] %u != %u", blockpolarparameter->be_minor, be_minor);
     be_minor++;
     if (dwg_dynapi_entity_set_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "be_minor", &be_minor, 0)
         && be_minor == blockpolarparameter->be_minor)
       pass ();
     else
       fail ("BLOCKPOLARPARAMETER.be_minor [BL] set+1 %u != %u", blockpolarparameter->be_minor, be_minor);
     blockpolarparameter->be_minor--;
   }
   {
     BITCODE_B chain_actions;
     if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "chain_actions", &chain_actions, NULL)
         && chain_actions == blockpolarparameter->chain_actions)
       pass ();
     else
       fail ("BLOCKPOLARPARAMETER.chain_actions [B] " FORMAT_B " != " FORMAT_B "", blockpolarparameter->chain_actions, chain_actions);
     chain_actions++;
     if (dwg_dynapi_entity_set_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "chain_actions", &chain_actions, 0)
         && chain_actions == blockpolarparameter->chain_actions)
       pass ();
     else
       fail ("BLOCKPOLARPARAMETER.chain_actions [B] set+1 " FORMAT_B " != " FORMAT_B "", blockpolarparameter->chain_actions, chain_actions);
     blockpolarparameter->chain_actions--;
   }
   {
     BITCODE_3BD def_basept;
     if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "def_basept", &def_basept, NULL)
         && !memcmp (&def_basept, &blockpolarparameter->def_basept, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKPOLARPARAMETER.def_basept [3BD]");
   }
   {
     BITCODE_3BD def_endpt;
     if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "def_endpt", &def_endpt, NULL)
         && !memcmp (&def_endpt, &blockpolarparameter->def_endpt, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKPOLARPARAMETER.def_endpt [3BD]");
   }
   {
     BITCODE_T distance_desc;
     if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "distance_desc", &distance_desc, NULL)
         && distance_desc
            ? strEQ ((char *)distance_desc, (char *)blockpolarparameter->distance_desc)
            : !blockpolarparameter->distance_desc)
       pass ();
     else
       fail ("BLOCKPOLARPARAMETER.distance_desc [T] '%s' <> '%s'", distance_desc, blockpolarparameter->distance_desc);
   }
   {
     BITCODE_T distance_name;
     if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "distance_name", &distance_name, NULL)
         && distance_name
            ? strEQ ((char *)distance_name, (char *)blockpolarparameter->distance_name)
            : !blockpolarparameter->distance_name)
       pass ();
     else
       fail ("BLOCKPOLARPARAMETER.distance_name [T] '%s' <> '%s'", distance_name, blockpolarparameter->distance_name);
   }
   {
     Dwg_BLOCKPARAMVALUESET distance_value_set;
     if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "distance_value_set", &distance_value_set, NULL)
         && !memcmp (&distance_value_set, &blockpolarparameter->distance_value_set, sizeof (Dwg_BLOCKPARAMVALUESET)))
         pass ();
     else
         fail ("BLOCKPOLARPARAMETER.distance_value_set [Dwg_BLOCKPARAMVALUESET]");
   }
   {
     BITCODE_BL eed1071;
     if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "eed1071", &eed1071, NULL)
         && eed1071 == blockpolarparameter->eed1071)
       pass ();
     else
       fail ("BLOCKPOLARPARAMETER.eed1071 [BL] %u != %u", blockpolarparameter->eed1071, eed1071);
     eed1071++;
     if (dwg_dynapi_entity_set_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "eed1071", &eed1071, 0)
         && eed1071 == blockpolarparameter->eed1071)
       pass ();
     else
       fail ("BLOCKPOLARPARAMETER.eed1071 [BL] set+1 %u != %u", blockpolarparameter->eed1071, eed1071);
     blockpolarparameter->eed1071--;
   }
   {
     BITCODE_3BD endpt;
     if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "endpt", &endpt, NULL)
         && !memcmp (&endpt, &blockpolarparameter->endpt, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKPOLARPARAMETER.endpt [3BD]");
   }
   {
     Dwg_EvalExpr evalexpr;
     if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "evalexpr", &evalexpr, NULL)
         && !memcmp (&evalexpr, &blockpolarparameter->evalexpr, sizeof (Dwg_EvalExpr)))
         pass ();
     else
         fail ("BLOCKPOLARPARAMETER.evalexpr [Dwg_EvalExpr]");
   }
   {
     BITCODE_T name;
     if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "name", &name, NULL)
         && name
            ? strEQ ((char *)name, (char *)blockpolarparameter->name)
            : !blockpolarparameter->name)
       pass ();
     else
       fail ("BLOCKPOLARPARAMETER.name [T] '%s' <> '%s'", name, blockpolarparameter->name);
   }
   {
     BITCODE_BD offset;
     if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "offset", &offset, NULL)
         && offset == blockpolarparameter->offset)
       pass ();
     else
       fail ("BLOCKPOLARPARAMETER.offset [BD] %g != %g", blockpolarparameter->offset, offset);
     offset++;
     if (dwg_dynapi_entity_set_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "offset", &offset, 0)
         && offset == blockpolarparameter->offset)
       pass ();
     else
       fail ("BLOCKPOLARPARAMETER.offset [BD] set+1 %g != %g", blockpolarparameter->offset, offset);
     blockpolarparameter->offset--;
   }
   {
     BITCODE_BS parameter_base_location;
     if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "parameter_base_location", &parameter_base_location, NULL)
         && parameter_base_location == blockpolarparameter->parameter_base_location)
       pass ();
     else
       fail ("BLOCKPOLARPARAMETER.parameter_base_location [BS] %hu != %hu", blockpolarparameter->parameter_base_location, parameter_base_location);
     parameter_base_location++;
     if (dwg_dynapi_entity_set_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "parameter_base_location", &parameter_base_location, 0)
         && parameter_base_location == blockpolarparameter->parameter_base_location)
       pass ();
     else
       fail ("BLOCKPOLARPARAMETER.parameter_base_location [BS] set+1 %hu != %hu", blockpolarparameter->parameter_base_location, parameter_base_location);
     blockpolarparameter->parameter_base_location--;
   }
   {
     struct _dwg_object_object* parent;
     if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "parent", &parent, NULL)
         && !memcmp (&parent, &blockpolarparameter->parent, sizeof (struct _dwg_object_object*)))
         pass ();
     else
         fail ("BLOCKPOLARPARAMETER.parent [struct _dwg_object_object*]");
   }
   {
     Dwg_BLOCKPARAMETER_PropInfo prop1;
     if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "prop1", &prop1, NULL)
         && !memcmp (&prop1, &blockpolarparameter->prop1, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
         pass ();
     else
         fail ("BLOCKPOLARPARAMETER.prop1 [Dwg_BLOCKPARAMETER_PropInfo]");
   }
   {
     Dwg_BLOCKPARAMETER_PropInfo prop2;
     if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "prop2", &prop2, NULL)
         && !memcmp (&prop2, &blockpolarparameter->prop2, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
         pass ();
     else
         fail ("BLOCKPOLARPARAMETER.prop2 [Dwg_BLOCKPARAMETER_PropInfo]");
   }
   {
     Dwg_BLOCKPARAMETER_PropInfo prop3;
     if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "prop3", &prop3, NULL)
         && !memcmp (&prop3, &blockpolarparameter->prop3, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
         pass ();
     else
         fail ("BLOCKPOLARPARAMETER.prop3 [Dwg_BLOCKPARAMETER_PropInfo]");
   }
   {
     Dwg_BLOCKPARAMETER_PropInfo prop4;
     if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "prop4", &prop4, NULL)
         && !memcmp (&prop4, &blockpolarparameter->prop4, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
         pass ();
     else
         fail ("BLOCKPOLARPARAMETER.prop4 [Dwg_BLOCKPARAMETER_PropInfo]");
   }
   {
     BITCODE_BL* prop_states;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "num_prop_states", &count, NULL)
         && dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "prop_states", &prop_states, NULL)
         && prop_states == blockpolarparameter->prop_states)
       pass ();
     else
       fail ("BLOCKPOLARPARAMETER.prop_states [BL*] * %u num_prop_states", count);
   }
   {
     BITCODE_B show_properties;
     if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "show_properties", &show_properties, NULL)
         && show_properties == blockpolarparameter->show_properties)
       pass ();
     else
       fail ("BLOCKPOLARPARAMETER.show_properties [B] " FORMAT_B " != " FORMAT_B "", blockpolarparameter->show_properties, show_properties);
     show_properties++;
     if (dwg_dynapi_entity_set_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "show_properties", &show_properties, 0)
         && show_properties == blockpolarparameter->show_properties)
       pass ();
     else
       fail ("BLOCKPOLARPARAMETER.show_properties [B] set+1 " FORMAT_B " != " FORMAT_B "", blockpolarparameter->show_properties, show_properties);
     blockpolarparameter->show_properties--;
   }
   {
     BITCODE_3BD upd_basept;
     if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "upd_basept", &upd_basept, NULL)
         && !memcmp (&upd_basept, &blockpolarparameter->upd_basept, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKPOLARPARAMETER.upd_basept [3BD]");
   }
   {
     BITCODE_3BD upd_endpt;
     if (dwg_dynapi_entity_value (blockpolarparameter, "BLOCKPOLARPARAMETER", "upd_endpt", &upd_endpt, NULL)
         && !memcmp (&upd_endpt, &blockpolarparameter->upd_endpt, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKPOLARPARAMETER.upd_endpt [3BD]");
   }
   if (failed && (is_class_unstable ("BLOCKPOLARPARAMETER") || is_class_debugging ("BLOCKPOLARPARAMETER")))
     {
       ok ("%s failed %d tests (TODO unstable)", "BLOCKPOLARPARAMETER", failed);
       failed = 0;
     }
   return failed;
 }
 static int test_BLOCKPOLARSTRETCHACTION (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
   Dwg_Object_BLOCKPOLARSTRETCHACTION *restrict blockpolarstretchaction = obj->tio.object->tio.BLOCKPOLARSTRETCHACTION;
   failed = 0;
   if (!obj_obj || !blockpolarstretchaction)
     {
       fail ("NULL BLOCKPOLARSTRETCHACTION");
       return 1;
     }
   {
     BITCODE_BL* actions;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "num_actions", &count, NULL)
         && dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "actions", &actions, NULL)
         && actions == blockpolarstretchaction->actions)
       pass ();
     else
       fail ("BLOCKPOLARSTRETCHACTION.actions [BL*] * %u num_actions", count);
   }
   {
     BITCODE_BL be_major;
     if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "be_major", &be_major, NULL)
         && be_major == blockpolarstretchaction->be_major)
       pass ();
     else
       fail ("BLOCKPOLARSTRETCHACTION.be_major [BL] %u != %u", blockpolarstretchaction->be_major, be_major);
     be_major++;
     if (dwg_dynapi_entity_set_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "be_major", &be_major, 0)
         && be_major == blockpolarstretchaction->be_major)
       pass ();
     else
       fail ("BLOCKPOLARSTRETCHACTION.be_major [BL] set+1 %u != %u", blockpolarstretchaction->be_major, be_major);
     blockpolarstretchaction->be_major--;
   }
   {
     BITCODE_BL be_minor;
     if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "be_minor", &be_minor, NULL)
         && be_minor == blockpolarstretchaction->be_minor)
       pass ();
     else
       fail ("BLOCKPOLARSTRETCHACTION.be_minor [BL] %u != %u", blockpolarstretchaction->be_minor, be_minor);
     be_minor++;
     if (dwg_dynapi_entity_set_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "be_minor", &be_minor, 0)
         && be_minor == blockpolarstretchaction->be_minor)
       pass ();
     else
       fail ("BLOCKPOLARSTRETCHACTION.be_minor [BL] set+1 %u != %u", blockpolarstretchaction->be_minor, be_minor);
     blockpolarstretchaction->be_minor--;
   }
   {
     BITCODE_BL* codes;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "num_codes", &count, NULL)
         && dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "codes", &codes, NULL)
         && codes == blockpolarstretchaction->codes)
       pass ();
     else
       fail ("BLOCKPOLARSTRETCHACTION.codes [BL*] * %u num_codes", count);
   }
   {
-    Dwg_BLOCKACTION_connectionpts conn_pts;
-    if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "conn_pts[6]", &conn_pts, NULL)
+    Dwg_BLOCKACTION_connectionpts conn_pts[6];
+    if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "conn_pts", &conn_pts, NULL)
         && !memcmp (&conn_pts, &blockpolarstretchaction->conn_pts, sizeof (Dwg_BLOCKACTION_connectionpts)))
         pass ();
     else
-        fail ("BLOCKPOLARSTRETCHACTION.conn_pts[6] [Dwg_BLOCKACTION_connectionpts]");
+        fail ("BLOCKPOLARSTRETCHACTION.conn_pts [Dwg_BLOCKACTION_connectionpts]");
   }
   {
     BITCODE_H* deps;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "num_deps", &count, NULL)
         && dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "deps", &deps, NULL)
         && deps == blockpolarstretchaction->deps)
       pass ();
     else
       fail ("BLOCKPOLARSTRETCHACTION.deps [H*] * %u num_deps", count);
   }
   {
     BITCODE_3BD display_location;
     if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "display_location", &display_location, NULL)
         && !memcmp (&display_location, &blockpolarstretchaction->display_location, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKPOLARSTRETCHACTION.display_location [3BD]");
   }
   {
     BITCODE_BL eed1071;
     if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "eed1071", &eed1071, NULL)
         && eed1071 == blockpolarstretchaction->eed1071)
       pass ();
     else
       fail ("BLOCKPOLARSTRETCHACTION.eed1071 [BL] %u != %u", blockpolarstretchaction->eed1071, eed1071);
     eed1071++;
     if (dwg_dynapi_entity_set_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "eed1071", &eed1071, 0)
         && eed1071 == blockpolarstretchaction->eed1071)
       pass ();
     else
       fail ("BLOCKPOLARSTRETCHACTION.eed1071 [BL] set+1 %u != %u", blockpolarstretchaction->eed1071, eed1071);
     blockpolarstretchaction->eed1071--;
   }
   {
     Dwg_EvalExpr evalexpr;
     if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "evalexpr", &evalexpr, NULL)
         && !memcmp (&evalexpr, &blockpolarstretchaction->evalexpr, sizeof (Dwg_EvalExpr)))
         pass ();
     else
         fail ("BLOCKPOLARSTRETCHACTION.evalexpr [Dwg_EvalExpr]");
   }
   {
     BITCODE_H* hdls;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "num_hdls", &count, NULL)
         && dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "hdls", &hdls, NULL)
         && hdls == blockpolarstretchaction->hdls)
       pass ();
     else
       fail ("BLOCKPOLARSTRETCHACTION.hdls [H*] * %u num_hdls", count);
   }
   {
     BITCODE_T name;
     if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "name", &name, NULL)
         && name
            ? strEQ ((char *)name, (char *)blockpolarstretchaction->name)
            : !blockpolarstretchaction->name)
       pass ();
     else
       fail ("BLOCKPOLARSTRETCHACTION.name [T] '%s' <> '%s'", name, blockpolarstretchaction->name);
   }
   {
     BITCODE_BL num_actions;
     if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "num_actions", &num_actions, NULL)
         && num_actions == blockpolarstretchaction->num_actions)
       pass ();
     else
       fail ("BLOCKPOLARSTRETCHACTION.num_actions [BL] %u != %u", blockpolarstretchaction->num_actions, num_actions);
     num_actions++;
     if (dwg_dynapi_entity_set_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "num_actions", &num_actions, 0)
         && num_actions == blockpolarstretchaction->num_actions)
       pass ();
     else
       fail ("BLOCKPOLARSTRETCHACTION.num_actions [BL] set+1 %u != %u", blockpolarstretchaction->num_actions, num_actions);
     blockpolarstretchaction->num_actions--;
   }
   {
     BITCODE_BL num_codes;
     if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "num_codes", &num_codes, NULL)
         && num_codes == blockpolarstretchaction->num_codes)
       pass ();
     else
       fail ("BLOCKPOLARSTRETCHACTION.num_codes [BL] %u != %u", blockpolarstretchaction->num_codes, num_codes);
     num_codes++;
     if (dwg_dynapi_entity_set_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "num_codes", &num_codes, 0)
         && num_codes == blockpolarstretchaction->num_codes)
       pass ();
     else
       fail ("BLOCKPOLARSTRETCHACTION.num_codes [BL] set+1 %u != %u", blockpolarstretchaction->num_codes, num_codes);
     blockpolarstretchaction->num_codes--;
   }
   {
     BITCODE_BL num_deps;
     if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "num_deps", &num_deps, NULL)
         && num_deps == blockpolarstretchaction->num_deps)
       pass ();
     else
       fail ("BLOCKPOLARSTRETCHACTION.num_deps [BL] %u != %u", blockpolarstretchaction->num_deps, num_deps);
     num_deps++;
     if (dwg_dynapi_entity_set_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "num_deps", &num_deps, 0)
         && num_deps == blockpolarstretchaction->num_deps)
       pass ();
     else
       fail ("BLOCKPOLARSTRETCHACTION.num_deps [BL] set+1 %u != %u", blockpolarstretchaction->num_deps, num_deps);
     blockpolarstretchaction->num_deps--;
   }
   {
     BITCODE_BL num_hdls;
     if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "num_hdls", &num_hdls, NULL)
         && num_hdls == blockpolarstretchaction->num_hdls)
       pass ();
     else
       fail ("BLOCKPOLARSTRETCHACTION.num_hdls [BL] %u != %u", blockpolarstretchaction->num_hdls, num_hdls);
     num_hdls++;
     if (dwg_dynapi_entity_set_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "num_hdls", &num_hdls, 0)
         && num_hdls == blockpolarstretchaction->num_hdls)
       pass ();
     else
       fail ("BLOCKPOLARSTRETCHACTION.num_hdls [BL] set+1 %u != %u", blockpolarstretchaction->num_hdls, num_hdls);
     blockpolarstretchaction->num_hdls--;
   }
   {
     BITCODE_BL num_pts;
     if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "num_pts", &num_pts, NULL)
         && num_pts == blockpolarstretchaction->num_pts)
       pass ();
     else
       fail ("BLOCKPOLARSTRETCHACTION.num_pts [BL] %u != %u", blockpolarstretchaction->num_pts, num_pts);
     num_pts++;
     if (dwg_dynapi_entity_set_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "num_pts", &num_pts, 0)
         && num_pts == blockpolarstretchaction->num_pts)
       pass ();
     else
       fail ("BLOCKPOLARSTRETCHACTION.num_pts [BL] set+1 %u != %u", blockpolarstretchaction->num_pts, num_pts);
     blockpolarstretchaction->num_pts--;
   }
   {
     struct _dwg_object_object* parent;
     if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "parent", &parent, NULL)
         && !memcmp (&parent, &blockpolarstretchaction->parent, sizeof (struct _dwg_object_object*)))
         pass ();
     else
         fail ("BLOCKPOLARSTRETCHACTION.parent [struct _dwg_object_object*]");
   }
   {
     BITCODE_2RD* pts;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "num_pts", &count, NULL)
         && dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "pts", &pts, NULL)
         && pts == blockpolarstretchaction->pts)
       pass ();
     else
       fail ("BLOCKPOLARSTRETCHACTION.pts [2RD*] * %u num_pts", count);
   }
   {
     BITCODE_BS* shorts;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "num_shorts", &count, NULL)
         && dwg_dynapi_entity_value (blockpolarstretchaction, "BLOCKPOLARSTRETCHACTION", "shorts", &shorts, NULL)
         && shorts == blockpolarstretchaction->shorts)
       pass ();
     else
       fail ("BLOCKPOLARSTRETCHACTION.shorts [BS*] * %u num_shorts", count);
   }
   if (failed && (is_class_unstable ("BLOCKPOLARSTRETCHACTION") || is_class_debugging ("BLOCKPOLARSTRETCHACTION")))
     {
       ok ("%s failed %d tests (TODO unstable)", "BLOCKPOLARSTRETCHACTION", failed);
       failed = 0;
     }
   return failed;
 }
@@ -41845,234 +41845,234 @@ static int test_BLOCKREPRESENTATION (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
   Dwg_Object_BLOCKREPRESENTATION *restrict blockrepresentation = obj->tio.object->tio.BLOCKREPRESENTATION;
   failed = 0;
   if (!obj_obj || !blockrepresentation)
     {
       fail ("NULL BLOCKREPRESENTATION");
       return 1;
     }
   {
     BITCODE_H block;
     if (dwg_dynapi_entity_value (blockrepresentation, "BLOCKREPRESENTATION", "block", &block, NULL)
         && !memcmp (&block, &blockrepresentation->block, sizeof (BITCODE_H)))
         pass ();
     else
         fail ("BLOCKREPRESENTATION.block [H]");
   }
   {
     BITCODE_BS flag;
     if (dwg_dynapi_entity_value (blockrepresentation, "BLOCKREPRESENTATION", "flag", &flag, NULL)
         && flag == blockrepresentation->flag)
       pass ();
     else
       fail ("BLOCKREPRESENTATION.flag [BS] %hu != %hu", blockrepresentation->flag, flag);
     flag++;
     if (dwg_dynapi_entity_set_value (blockrepresentation, "BLOCKREPRESENTATION", "flag", &flag, 0)
         && flag == blockrepresentation->flag)
       pass ();
     else
       fail ("BLOCKREPRESENTATION.flag [BS] set+1 %hu != %hu", blockrepresentation->flag, flag);
     blockrepresentation->flag--;
   }
   {
     struct _dwg_object_object* parent;
     if (dwg_dynapi_entity_value (blockrepresentation, "BLOCKREPRESENTATION", "parent", &parent, NULL)
         && !memcmp (&parent, &blockrepresentation->parent, sizeof (struct _dwg_object_object*)))
         pass ();
     else
         fail ("BLOCKREPRESENTATION.parent [struct _dwg_object_object*]");
   }
   if (failed && (is_class_unstable ("BLOCKREPRESENTATION") || is_class_debugging ("BLOCKREPRESENTATION")))
     {
       ok ("%s failed %d tests (TODO unstable)", "BLOCKREPRESENTATION", failed);
       failed = 0;
     }
   return failed;
 }
 static int test_BLOCKROTATEACTION (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
   Dwg_Object_BLOCKROTATEACTION *restrict blockrotateaction = obj->tio.object->tio.BLOCKROTATEACTION;
   failed = 0;
   if (!obj_obj || !blockrotateaction)
     {
       fail ("NULL BLOCKROTATEACTION");
       return 1;
     }
   {
     BITCODE_BL* actions;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "num_actions", &count, NULL)
         && dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "actions", &actions, NULL)
         && actions == blockrotateaction->actions)
       pass ();
     else
       fail ("BLOCKROTATEACTION.actions [BL*] * %u num_actions", count);
   }
   {
     BITCODE_3BD base_pt;
     if (dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "base_pt", &base_pt, NULL)
         && !memcmp (&base_pt, &blockrotateaction->base_pt, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKROTATEACTION.base_pt [3BD]");
   }
   {
     BITCODE_BL be_major;
     if (dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "be_major", &be_major, NULL)
         && be_major == blockrotateaction->be_major)
       pass ();
     else
       fail ("BLOCKROTATEACTION.be_major [BL] %u != %u", blockrotateaction->be_major, be_major);
     be_major++;
     if (dwg_dynapi_entity_set_value (blockrotateaction, "BLOCKROTATEACTION", "be_major", &be_major, 0)
         && be_major == blockrotateaction->be_major)
       pass ();
     else
       fail ("BLOCKROTATEACTION.be_major [BL] set+1 %u != %u", blockrotateaction->be_major, be_major);
     blockrotateaction->be_major--;
   }
   {
     BITCODE_BL be_minor;
     if (dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "be_minor", &be_minor, NULL)
         && be_minor == blockrotateaction->be_minor)
       pass ();
     else
       fail ("BLOCKROTATEACTION.be_minor [BL] %u != %u", blockrotateaction->be_minor, be_minor);
     be_minor++;
     if (dwg_dynapi_entity_set_value (blockrotateaction, "BLOCKROTATEACTION", "be_minor", &be_minor, 0)
         && be_minor == blockrotateaction->be_minor)
       pass ();
     else
       fail ("BLOCKROTATEACTION.be_minor [BL] set+1 %u != %u", blockrotateaction->be_minor, be_minor);
     blockrotateaction->be_minor--;
   }
   {
-    Dwg_BLOCKACTION_connectionpts conn_pts;
-    if (dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "conn_pts[3]", &conn_pts, NULL)
+    Dwg_BLOCKACTION_connectionpts conn_pts[3];
+    if (dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "conn_pts", &conn_pts, NULL)
         && !memcmp (&conn_pts, &blockrotateaction->conn_pts, sizeof (Dwg_BLOCKACTION_connectionpts)))
         pass ();
     else
-        fail ("BLOCKROTATEACTION.conn_pts[3] [Dwg_BLOCKACTION_connectionpts]");
+        fail ("BLOCKROTATEACTION.conn_pts [Dwg_BLOCKACTION_connectionpts]");
   }
   {
     BITCODE_B dependent;
     if (dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "dependent", &dependent, NULL)
         && dependent == blockrotateaction->dependent)
       pass ();
     else
       fail ("BLOCKROTATEACTION.dependent [B] " FORMAT_B " != " FORMAT_B "", blockrotateaction->dependent, dependent);
     dependent++;
     if (dwg_dynapi_entity_set_value (blockrotateaction, "BLOCKROTATEACTION", "dependent", &dependent, 0)
         && dependent == blockrotateaction->dependent)
       pass ();
     else
       fail ("BLOCKROTATEACTION.dependent [B] set+1 " FORMAT_B " != " FORMAT_B "", blockrotateaction->dependent, dependent);
     blockrotateaction->dependent--;
   }
   {
     BITCODE_H* deps;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "num_deps", &count, NULL)
         && dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "deps", &deps, NULL)
         && deps == blockrotateaction->deps)
       pass ();
     else
       fail ("BLOCKROTATEACTION.deps [H*] * %u num_deps", count);
   }
   {
     BITCODE_3BD display_location;
     if (dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "display_location", &display_location, NULL)
         && !memcmp (&display_location, &blockrotateaction->display_location, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKROTATEACTION.display_location [3BD]");
   }
   {
     BITCODE_BL eed1071;
     if (dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "eed1071", &eed1071, NULL)
         && eed1071 == blockrotateaction->eed1071)
       pass ();
     else
       fail ("BLOCKROTATEACTION.eed1071 [BL] %u != %u", blockrotateaction->eed1071, eed1071);
     eed1071++;
     if (dwg_dynapi_entity_set_value (blockrotateaction, "BLOCKROTATEACTION", "eed1071", &eed1071, 0)
         && eed1071 == blockrotateaction->eed1071)
       pass ();
     else
       fail ("BLOCKROTATEACTION.eed1071 [BL] set+1 %u != %u", blockrotateaction->eed1071, eed1071);
     blockrotateaction->eed1071--;
   }
   {
     Dwg_EvalExpr evalexpr;
     if (dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "evalexpr", &evalexpr, NULL)
         && !memcmp (&evalexpr, &blockrotateaction->evalexpr, sizeof (Dwg_EvalExpr)))
         pass ();
     else
         fail ("BLOCKROTATEACTION.evalexpr [Dwg_EvalExpr]");
   }
   {
     BITCODE_T name;
     if (dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "name", &name, NULL)
         && name
            ? strEQ ((char *)name, (char *)blockrotateaction->name)
            : !blockrotateaction->name)
       pass ();
     else
       fail ("BLOCKROTATEACTION.name [T] '%s' <> '%s'", name, blockrotateaction->name);
   }
   {
     BITCODE_BL num_actions;
     if (dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "num_actions", &num_actions, NULL)
         && num_actions == blockrotateaction->num_actions)
       pass ();
     else
       fail ("BLOCKROTATEACTION.num_actions [BL] %u != %u", blockrotateaction->num_actions, num_actions);
     num_actions++;
     if (dwg_dynapi_entity_set_value (blockrotateaction, "BLOCKROTATEACTION", "num_actions", &num_actions, 0)
         && num_actions == blockrotateaction->num_actions)
       pass ();
     else
       fail ("BLOCKROTATEACTION.num_actions [BL] set+1 %u != %u", blockrotateaction->num_actions, num_actions);
     blockrotateaction->num_actions--;
   }
   {
     BITCODE_BL num_deps;
     if (dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "num_deps", &num_deps, NULL)
         && num_deps == blockrotateaction->num_deps)
       pass ();
     else
       fail ("BLOCKROTATEACTION.num_deps [BL] %u != %u", blockrotateaction->num_deps, num_deps);
     num_deps++;
     if (dwg_dynapi_entity_set_value (blockrotateaction, "BLOCKROTATEACTION", "num_deps", &num_deps, 0)
         && num_deps == blockrotateaction->num_deps)
       pass ();
     else
       fail ("BLOCKROTATEACTION.num_deps [BL] set+1 %u != %u", blockrotateaction->num_deps, num_deps);
     blockrotateaction->num_deps--;
   }
   {
     BITCODE_3BD offset;
     if (dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "offset", &offset, NULL)
         && !memcmp (&offset, &blockrotateaction->offset, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKROTATEACTION.offset [3BD]");
   }
   {
     struct _dwg_object_object* parent;
     if (dwg_dynapi_entity_value (blockrotateaction, "BLOCKROTATEACTION", "parent", &parent, NULL)
         && !memcmp (&parent, &blockrotateaction->parent, sizeof (struct _dwg_object_object*)))
         pass ();
     else
         fail ("BLOCKROTATEACTION.parent [struct _dwg_object_object*]");
   }
   if (failed && (is_class_unstable ("BLOCKROTATEACTION") || is_class_debugging ("BLOCKROTATEACTION")))
     {
       ok ("%s failed %d tests (TODO unstable)", "BLOCKROTATEACTION", failed);
       failed = 0;
     }
   return failed;
 }
@@ -42236,745 +42236,745 @@ static int test_BLOCKROTATIONPARAMETER (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
   Dwg_Object_BLOCKROTATIONPARAMETER *restrict blockrotationparameter = obj->tio.object->tio.BLOCKROTATIONPARAMETER;
   failed = 0;
   if (!obj_obj || !blockrotationparameter)
     {
       fail ("NULL BLOCKROTATIONPARAMETER");
       return 1;
     }
   {
     BITCODE_BD angle;
     if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "angle", &angle, NULL)
         && angle == blockrotationparameter->angle)
       pass ();
     else
       fail ("BLOCKROTATIONPARAMETER.angle [BD] %g != %g", blockrotationparameter->angle, angle);
     angle++;
     if (dwg_dynapi_entity_set_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "angle", &angle, 0)
         && angle == blockrotationparameter->angle)
       pass ();
     else
       fail ("BLOCKROTATIONPARAMETER.angle [BD] set+1 %g != %g", blockrotationparameter->angle, angle);
     blockrotationparameter->angle--;
   }
   {
     BITCODE_T angle_desc;
     if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "angle_desc", &angle_desc, NULL)
         && angle_desc
            ? strEQ ((char *)angle_desc, (char *)blockrotationparameter->angle_desc)
            : !blockrotationparameter->angle_desc)
       pass ();
     else
       fail ("BLOCKROTATIONPARAMETER.angle_desc [T] '%s' <> '%s'", angle_desc, blockrotationparameter->angle_desc);
   }
   {
     BITCODE_T angle_name;
     if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "angle_name", &angle_name, NULL)
         && angle_name
            ? strEQ ((char *)angle_name, (char *)blockrotationparameter->angle_name)
            : !blockrotationparameter->angle_name)
       pass ();
     else
       fail ("BLOCKROTATIONPARAMETER.angle_name [T] '%s' <> '%s'", angle_name, blockrotationparameter->angle_name);
   }
   {
     Dwg_BLOCKPARAMVALUESET angle_value_set;
     if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "angle_value_set", &angle_value_set, NULL)
         && !memcmp (&angle_value_set, &blockrotationparameter->angle_value_set, sizeof (Dwg_BLOCKPARAMVALUESET)))
         pass ();
     else
         fail ("BLOCKROTATIONPARAMETER.angle_value_set [Dwg_BLOCKPARAMVALUESET]");
   }
   {
     BITCODE_3BD basept;
     if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "basept", &basept, NULL)
         && !memcmp (&basept, &blockrotationparameter->basept, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKROTATIONPARAMETER.basept [3BD]");
   }
   {
     BITCODE_BL be_major;
     if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "be_major", &be_major, NULL)
         && be_major == blockrotationparameter->be_major)
       pass ();
     else
       fail ("BLOCKROTATIONPARAMETER.be_major [BL] %u != %u", blockrotationparameter->be_major, be_major);
     be_major++;
     if (dwg_dynapi_entity_set_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "be_major", &be_major, 0)
         && be_major == blockrotationparameter->be_major)
       pass ();
     else
       fail ("BLOCKROTATIONPARAMETER.be_major [BL] set+1 %u != %u", blockrotationparameter->be_major, be_major);
     blockrotationparameter->be_major--;
   }
   {
     BITCODE_BL be_minor;
     if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "be_minor", &be_minor, NULL)
         && be_minor == blockrotationparameter->be_minor)
       pass ();
     else
       fail ("BLOCKROTATIONPARAMETER.be_minor [BL] %u != %u", blockrotationparameter->be_minor, be_minor);
     be_minor++;
     if (dwg_dynapi_entity_set_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "be_minor", &be_minor, 0)
         && be_minor == blockrotationparameter->be_minor)
       pass ();
     else
       fail ("BLOCKROTATIONPARAMETER.be_minor [BL] set+1 %u != %u", blockrotationparameter->be_minor, be_minor);
     blockrotationparameter->be_minor--;
   }
   {
     BITCODE_B chain_actions;
     if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "chain_actions", &chain_actions, NULL)
         && chain_actions == blockrotationparameter->chain_actions)
       pass ();
     else
       fail ("BLOCKROTATIONPARAMETER.chain_actions [B] " FORMAT_B " != " FORMAT_B "", blockrotationparameter->chain_actions, chain_actions);
     chain_actions++;
     if (dwg_dynapi_entity_set_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "chain_actions", &chain_actions, 0)
         && chain_actions == blockrotationparameter->chain_actions)
       pass ();
     else
       fail ("BLOCKROTATIONPARAMETER.chain_actions [B] set+1 " FORMAT_B " != " FORMAT_B "", blockrotationparameter->chain_actions, chain_actions);
     blockrotationparameter->chain_actions--;
   }
   {
     BITCODE_3BD def_base_angle_pt;
     if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "def_base_angle_pt", &def_base_angle_pt, NULL)
         && !memcmp (&def_base_angle_pt, &blockrotationparameter->def_base_angle_pt, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKROTATIONPARAMETER.def_base_angle_pt [3BD]");
   }
   {
     BITCODE_3BD def_basept;
     if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "def_basept", &def_basept, NULL)
         && !memcmp (&def_basept, &blockrotationparameter->def_basept, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKROTATIONPARAMETER.def_basept [3BD]");
   }
   {
     BITCODE_3BD def_endpt;
     if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "def_endpt", &def_endpt, NULL)
         && !memcmp (&def_endpt, &blockrotationparameter->def_endpt, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKROTATIONPARAMETER.def_endpt [3BD]");
   }
   {
     BITCODE_BL eed1071;
     if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "eed1071", &eed1071, NULL)
         && eed1071 == blockrotationparameter->eed1071)
       pass ();
     else
       fail ("BLOCKROTATIONPARAMETER.eed1071 [BL] %u != %u", blockrotationparameter->eed1071, eed1071);
     eed1071++;
     if (dwg_dynapi_entity_set_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "eed1071", &eed1071, 0)
         && eed1071 == blockrotationparameter->eed1071)
       pass ();
     else
       fail ("BLOCKROTATIONPARAMETER.eed1071 [BL] set+1 %u != %u", blockrotationparameter->eed1071, eed1071);
     blockrotationparameter->eed1071--;
   }
   {
     BITCODE_3BD endpt;
     if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "endpt", &endpt, NULL)
         && !memcmp (&endpt, &blockrotationparameter->endpt, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKROTATIONPARAMETER.endpt [3BD]");
   }
   {
     Dwg_EvalExpr evalexpr;
     if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "evalexpr", &evalexpr, NULL)
         && !memcmp (&evalexpr, &blockrotationparameter->evalexpr, sizeof (Dwg_EvalExpr)))
         pass ();
     else
         fail ("BLOCKROTATIONPARAMETER.evalexpr [Dwg_EvalExpr]");
   }
   {
     BITCODE_T name;
     if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "name", &name, NULL)
         && name
            ? strEQ ((char *)name, (char *)blockrotationparameter->name)
            : !blockrotationparameter->name)
       pass ();
     else
       fail ("BLOCKROTATIONPARAMETER.name [T] '%s' <> '%s'", name, blockrotationparameter->name);
   }
   {
     BITCODE_BS parameter_base_location;
     if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "parameter_base_location", &parameter_base_location, NULL)
         && parameter_base_location == blockrotationparameter->parameter_base_location)
       pass ();
     else
       fail ("BLOCKROTATIONPARAMETER.parameter_base_location [BS] %hu != %hu", blockrotationparameter->parameter_base_location, parameter_base_location);
     parameter_base_location++;
     if (dwg_dynapi_entity_set_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "parameter_base_location", &parameter_base_location, 0)
         && parameter_base_location == blockrotationparameter->parameter_base_location)
       pass ();
     else
       fail ("BLOCKROTATIONPARAMETER.parameter_base_location [BS] set+1 %hu != %hu", blockrotationparameter->parameter_base_location, parameter_base_location);
     blockrotationparameter->parameter_base_location--;
   }
   {
     struct _dwg_object_object* parent;
     if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "parent", &parent, NULL)
         && !memcmp (&parent, &blockrotationparameter->parent, sizeof (struct _dwg_object_object*)))
         pass ();
     else
         fail ("BLOCKROTATIONPARAMETER.parent [struct _dwg_object_object*]");
   }
   {
     Dwg_BLOCKPARAMETER_PropInfo prop1;
     if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "prop1", &prop1, NULL)
         && !memcmp (&prop1, &blockrotationparameter->prop1, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
         pass ();
     else
         fail ("BLOCKROTATIONPARAMETER.prop1 [Dwg_BLOCKPARAMETER_PropInfo]");
   }
   {
     Dwg_BLOCKPARAMETER_PropInfo prop2;
     if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "prop2", &prop2, NULL)
         && !memcmp (&prop2, &blockrotationparameter->prop2, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
         pass ();
     else
         fail ("BLOCKROTATIONPARAMETER.prop2 [Dwg_BLOCKPARAMETER_PropInfo]");
   }
   {
     Dwg_BLOCKPARAMETER_PropInfo prop3;
     if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "prop3", &prop3, NULL)
         && !memcmp (&prop3, &blockrotationparameter->prop3, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
         pass ();
     else
         fail ("BLOCKROTATIONPARAMETER.prop3 [Dwg_BLOCKPARAMETER_PropInfo]");
   }
   {
     Dwg_BLOCKPARAMETER_PropInfo prop4;
     if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "prop4", &prop4, NULL)
         && !memcmp (&prop4, &blockrotationparameter->prop4, sizeof (Dwg_BLOCKPARAMETER_PropInfo)))
         pass ();
     else
         fail ("BLOCKROTATIONPARAMETER.prop4 [Dwg_BLOCKPARAMETER_PropInfo]");
   }
   {
     BITCODE_BL* prop_states;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "num_prop_states", &count, NULL)
         && dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "prop_states", &prop_states, NULL)
         && prop_states == blockrotationparameter->prop_states)
       pass ();
     else
       fail ("BLOCKROTATIONPARAMETER.prop_states [BL*] * %u num_prop_states", count);
   }
   {
     BITCODE_B show_properties;
     if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "show_properties", &show_properties, NULL)
         && show_properties == blockrotationparameter->show_properties)
       pass ();
     else
       fail ("BLOCKROTATIONPARAMETER.show_properties [B] " FORMAT_B " != " FORMAT_B "", blockrotationparameter->show_properties, show_properties);
     show_properties++;
     if (dwg_dynapi_entity_set_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "show_properties", &show_properties, 0)
         && show_properties == blockrotationparameter->show_properties)
       pass ();
     else
       fail ("BLOCKROTATIONPARAMETER.show_properties [B] set+1 " FORMAT_B " != " FORMAT_B "", blockrotationparameter->show_properties, show_properties);
     blockrotationparameter->show_properties--;
   }
   {
     BITCODE_3BD upd_basept;
     if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "upd_basept", &upd_basept, NULL)
         && !memcmp (&upd_basept, &blockrotationparameter->upd_basept, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKROTATIONPARAMETER.upd_basept [3BD]");
   }
   {
     BITCODE_3BD upd_endpt;
     if (dwg_dynapi_entity_value (blockrotationparameter, "BLOCKROTATIONPARAMETER", "upd_endpt", &upd_endpt, NULL)
         && !memcmp (&upd_endpt, &blockrotationparameter->upd_endpt, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKROTATIONPARAMETER.upd_endpt [3BD]");
   }
   if (failed && (is_class_unstable ("BLOCKROTATIONPARAMETER") || is_class_debugging ("BLOCKROTATIONPARAMETER")))
     {
       ok ("%s failed %d tests (TODO unstable)", "BLOCKROTATIONPARAMETER", failed);
       failed = 0;
     }
   return failed;
 }
 static int test_BLOCKSCALEACTION (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
   Dwg_Object_BLOCKSCALEACTION *restrict blockscaleaction = obj->tio.object->tio.BLOCKSCALEACTION;
   failed = 0;
   if (!obj_obj || !blockscaleaction)
     {
       fail ("NULL BLOCKSCALEACTION");
       return 1;
     }
   {
     BITCODE_BL* actions;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "num_actions", &count, NULL)
         && dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "actions", &actions, NULL)
         && actions == blockscaleaction->actions)
       pass ();
     else
       fail ("BLOCKSCALEACTION.actions [BL*] * %u num_actions", count);
   }
   {
     BITCODE_3BD base_pt;
     if (dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "base_pt", &base_pt, NULL)
         && !memcmp (&base_pt, &blockscaleaction->base_pt, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKSCALEACTION.base_pt [3BD]");
   }
   {
     BITCODE_BL be_major;
     if (dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "be_major", &be_major, NULL)
         && be_major == blockscaleaction->be_major)
       pass ();
     else
       fail ("BLOCKSCALEACTION.be_major [BL] %u != %u", blockscaleaction->be_major, be_major);
     be_major++;
     if (dwg_dynapi_entity_set_value (blockscaleaction, "BLOCKSCALEACTION", "be_major", &be_major, 0)
         && be_major == blockscaleaction->be_major)
       pass ();
     else
       fail ("BLOCKSCALEACTION.be_major [BL] set+1 %u != %u", blockscaleaction->be_major, be_major);
     blockscaleaction->be_major--;
   }
   {
     BITCODE_BL be_minor;
     if (dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "be_minor", &be_minor, NULL)
         && be_minor == blockscaleaction->be_minor)
       pass ();
     else
       fail ("BLOCKSCALEACTION.be_minor [BL] %u != %u", blockscaleaction->be_minor, be_minor);
     be_minor++;
     if (dwg_dynapi_entity_set_value (blockscaleaction, "BLOCKSCALEACTION", "be_minor", &be_minor, 0)
         && be_minor == blockscaleaction->be_minor)
       pass ();
     else
       fail ("BLOCKSCALEACTION.be_minor [BL] set+1 %u != %u", blockscaleaction->be_minor, be_minor);
     blockscaleaction->be_minor--;
   }
   {
-    Dwg_BLOCKACTION_connectionpts conn_pts;
-    if (dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "conn_pts[5]", &conn_pts, NULL)
+    Dwg_BLOCKACTION_connectionpts conn_pts[5];
+    if (dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "conn_pts", &conn_pts, NULL)
         && !memcmp (&conn_pts, &blockscaleaction->conn_pts, sizeof (Dwg_BLOCKACTION_connectionpts)))
         pass ();
     else
-        fail ("BLOCKSCALEACTION.conn_pts[5] [Dwg_BLOCKACTION_connectionpts]");
+        fail ("BLOCKSCALEACTION.conn_pts [Dwg_BLOCKACTION_connectionpts]");
   }
   {
     BITCODE_B dependent;
     if (dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "dependent", &dependent, NULL)
         && dependent == blockscaleaction->dependent)
       pass ();
     else
       fail ("BLOCKSCALEACTION.dependent [B] " FORMAT_B " != " FORMAT_B "", blockscaleaction->dependent, dependent);
     dependent++;
     if (dwg_dynapi_entity_set_value (blockscaleaction, "BLOCKSCALEACTION", "dependent", &dependent, 0)
         && dependent == blockscaleaction->dependent)
       pass ();
     else
       fail ("BLOCKSCALEACTION.dependent [B] set+1 " FORMAT_B " != " FORMAT_B "", blockscaleaction->dependent, dependent);
     blockscaleaction->dependent--;
   }
   {
     BITCODE_H* deps;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "num_deps", &count, NULL)
         && dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "deps", &deps, NULL)
         && deps == blockscaleaction->deps)
       pass ();
     else
       fail ("BLOCKSCALEACTION.deps [H*] * %u num_deps", count);
   }
   {
     BITCODE_3BD display_location;
     if (dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "display_location", &display_location, NULL)
         && !memcmp (&display_location, &blockscaleaction->display_location, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKSCALEACTION.display_location [3BD]");
   }
   {
     BITCODE_BL eed1071;
     if (dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "eed1071", &eed1071, NULL)
         && eed1071 == blockscaleaction->eed1071)
       pass ();
     else
       fail ("BLOCKSCALEACTION.eed1071 [BL] %u != %u", blockscaleaction->eed1071, eed1071);
     eed1071++;
     if (dwg_dynapi_entity_set_value (blockscaleaction, "BLOCKSCALEACTION", "eed1071", &eed1071, 0)
         && eed1071 == blockscaleaction->eed1071)
       pass ();
     else
       fail ("BLOCKSCALEACTION.eed1071 [BL] set+1 %u != %u", blockscaleaction->eed1071, eed1071);
     blockscaleaction->eed1071--;
   }
   {
     Dwg_EvalExpr evalexpr;
     if (dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "evalexpr", &evalexpr, NULL)
         && !memcmp (&evalexpr, &blockscaleaction->evalexpr, sizeof (Dwg_EvalExpr)))
         pass ();
     else
         fail ("BLOCKSCALEACTION.evalexpr [Dwg_EvalExpr]");
   }
   {
     BITCODE_T name;
     if (dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "name", &name, NULL)
         && name
            ? strEQ ((char *)name, (char *)blockscaleaction->name)
            : !blockscaleaction->name)
       pass ();
     else
       fail ("BLOCKSCALEACTION.name [T] '%s' <> '%s'", name, blockscaleaction->name);
   }
   {
     BITCODE_BL num_actions;
     if (dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "num_actions", &num_actions, NULL)
         && num_actions == blockscaleaction->num_actions)
       pass ();
     else
       fail ("BLOCKSCALEACTION.num_actions [BL] %u != %u", blockscaleaction->num_actions, num_actions);
     num_actions++;
     if (dwg_dynapi_entity_set_value (blockscaleaction, "BLOCKSCALEACTION", "num_actions", &num_actions, 0)
         && num_actions == blockscaleaction->num_actions)
       pass ();
     else
       fail ("BLOCKSCALEACTION.num_actions [BL] set+1 %u != %u", blockscaleaction->num_actions, num_actions);
     blockscaleaction->num_actions--;
   }
   {
     BITCODE_BL num_deps;
     if (dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "num_deps", &num_deps, NULL)
         && num_deps == blockscaleaction->num_deps)
       pass ();
     else
       fail ("BLOCKSCALEACTION.num_deps [BL] %u != %u", blockscaleaction->num_deps, num_deps);
     num_deps++;
     if (dwg_dynapi_entity_set_value (blockscaleaction, "BLOCKSCALEACTION", "num_deps", &num_deps, 0)
         && num_deps == blockscaleaction->num_deps)
       pass ();
     else
       fail ("BLOCKSCALEACTION.num_deps [BL] set+1 %u != %u", blockscaleaction->num_deps, num_deps);
     blockscaleaction->num_deps--;
   }
   {
     BITCODE_3BD offset;
     if (dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "offset", &offset, NULL)
         && !memcmp (&offset, &blockscaleaction->offset, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKSCALEACTION.offset [3BD]");
   }
   {
     struct _dwg_object_object* parent;
     if (dwg_dynapi_entity_value (blockscaleaction, "BLOCKSCALEACTION", "parent", &parent, NULL)
         && !memcmp (&parent, &blockscaleaction->parent, sizeof (struct _dwg_object_object*)))
         pass ();
     else
         fail ("BLOCKSCALEACTION.parent [struct _dwg_object_object*]");
   }
   if (failed && (is_class_unstable ("BLOCKSCALEACTION") || is_class_debugging ("BLOCKSCALEACTION")))
     {
       ok ("%s failed %d tests (TODO unstable)", "BLOCKSCALEACTION", failed);
       failed = 0;
     }
   return failed;
 }
 static int test_BLOCKSTRETCHACTION (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
   Dwg_Object_BLOCKSTRETCHACTION *restrict blockstretchaction = obj->tio.object->tio.BLOCKSTRETCHACTION;
   failed = 0;
   if (!obj_obj || !blockstretchaction)
     {
       fail ("NULL BLOCKSTRETCHACTION");
       return 1;
     }
   {
     BITCODE_BD action_offset_x;
     if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "action_offset_x", &action_offset_x, NULL)
         && action_offset_x == blockstretchaction->action_offset_x)
       pass ();
     else
       fail ("BLOCKSTRETCHACTION.action_offset_x [BD] %g != %g", blockstretchaction->action_offset_x, action_offset_x);
     action_offset_x++;
     if (dwg_dynapi_entity_set_value (blockstretchaction, "BLOCKSTRETCHACTION", "action_offset_x", &action_offset_x, 0)
         && action_offset_x == blockstretchaction->action_offset_x)
       pass ();
     else
       fail ("BLOCKSTRETCHACTION.action_offset_x [BD] set+1 %g != %g", blockstretchaction->action_offset_x, action_offset_x);
     blockstretchaction->action_offset_x--;
   }
   {
     BITCODE_BD action_offset_y;
     if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "action_offset_y", &action_offset_y, NULL)
         && action_offset_y == blockstretchaction->action_offset_y)
       pass ();
     else
       fail ("BLOCKSTRETCHACTION.action_offset_y [BD] %g != %g", blockstretchaction->action_offset_y, action_offset_y);
     action_offset_y++;
     if (dwg_dynapi_entity_set_value (blockstretchaction, "BLOCKSTRETCHACTION", "action_offset_y", &action_offset_y, 0)
         && action_offset_y == blockstretchaction->action_offset_y)
       pass ();
     else
       fail ("BLOCKSTRETCHACTION.action_offset_y [BD] set+1 %g != %g", blockstretchaction->action_offset_y, action_offset_y);
     blockstretchaction->action_offset_y--;
   }
   {
     BITCODE_BL* actions;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "num_actions", &count, NULL)
         && dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "actions", &actions, NULL)
         && actions == blockstretchaction->actions)
       pass ();
     else
       fail ("BLOCKSTRETCHACTION.actions [BL*] * %u num_actions", count);
   }
   {
     BITCODE_BD angle_offset;
     if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "angle_offset", &angle_offset, NULL)
         && angle_offset == blockstretchaction->angle_offset)
       pass ();
     else
       fail ("BLOCKSTRETCHACTION.angle_offset [BD] %g != %g", blockstretchaction->angle_offset, angle_offset);
     angle_offset++;
     if (dwg_dynapi_entity_set_value (blockstretchaction, "BLOCKSTRETCHACTION", "angle_offset", &angle_offset, 0)
         && angle_offset == blockstretchaction->angle_offset)
       pass ();
     else
       fail ("BLOCKSTRETCHACTION.angle_offset [BD] set+1 %g != %g", blockstretchaction->angle_offset, angle_offset);
     blockstretchaction->angle_offset--;
   }
   {
     BITCODE_BL be_major;
     if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "be_major", &be_major, NULL)
         && be_major == blockstretchaction->be_major)
       pass ();
     else
       fail ("BLOCKSTRETCHACTION.be_major [BL] %u != %u", blockstretchaction->be_major, be_major);
     be_major++;
     if (dwg_dynapi_entity_set_value (blockstretchaction, "BLOCKSTRETCHACTION", "be_major", &be_major, 0)
         && be_major == blockstretchaction->be_major)
       pass ();
     else
       fail ("BLOCKSTRETCHACTION.be_major [BL] set+1 %u != %u", blockstretchaction->be_major, be_major);
     blockstretchaction->be_major--;
   }
   {
     BITCODE_BL be_minor;
     if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "be_minor", &be_minor, NULL)
         && be_minor == blockstretchaction->be_minor)
       pass ();
     else
       fail ("BLOCKSTRETCHACTION.be_minor [BL] %u != %u", blockstretchaction->be_minor, be_minor);
     be_minor++;
     if (dwg_dynapi_entity_set_value (blockstretchaction, "BLOCKSTRETCHACTION", "be_minor", &be_minor, 0)
         && be_minor == blockstretchaction->be_minor)
       pass ();
     else
       fail ("BLOCKSTRETCHACTION.be_minor [BL] set+1 %u != %u", blockstretchaction->be_minor, be_minor);
     blockstretchaction->be_minor--;
   }
   {
     BITCODE_BL* codes;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "num_codes", &count, NULL)
         && dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "codes", &codes, NULL)
         && codes == blockstretchaction->codes)
       pass ();
     else
       fail ("BLOCKSTRETCHACTION.codes [BL*] * %u num_codes", count);
   }
   {
-    Dwg_BLOCKACTION_connectionpts conn_pts;
-    if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "conn_pts[2]", &conn_pts, NULL)
+    Dwg_BLOCKACTION_connectionpts conn_pts[2];
+    if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "conn_pts", &conn_pts, NULL)
         && !memcmp (&conn_pts, &blockstretchaction->conn_pts, sizeof (Dwg_BLOCKACTION_connectionpts)))
         pass ();
     else
-        fail ("BLOCKSTRETCHACTION.conn_pts[2] [Dwg_BLOCKACTION_connectionpts]");
+        fail ("BLOCKSTRETCHACTION.conn_pts [Dwg_BLOCKACTION_connectionpts]");
   }
   {
     BITCODE_H* deps;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "num_deps", &count, NULL)
         && dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "deps", &deps, NULL)
         && deps == blockstretchaction->deps)
       pass ();
     else
       fail ("BLOCKSTRETCHACTION.deps [H*] * %u num_deps", count);
   }
   {
     BITCODE_3BD display_location;
     if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "display_location", &display_location, NULL)
         && !memcmp (&display_location, &blockstretchaction->display_location, sizeof (BITCODE_3BD)))
         pass ();
     else
         fail ("BLOCKSTRETCHACTION.display_location [3BD]");
   }
   {
     BITCODE_BL eed1071;
     if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "eed1071", &eed1071, NULL)
         && eed1071 == blockstretchaction->eed1071)
       pass ();
     else
       fail ("BLOCKSTRETCHACTION.eed1071 [BL] %u != %u", blockstretchaction->eed1071, eed1071);
     eed1071++;
     if (dwg_dynapi_entity_set_value (blockstretchaction, "BLOCKSTRETCHACTION", "eed1071", &eed1071, 0)
         && eed1071 == blockstretchaction->eed1071)
       pass ();
     else
       fail ("BLOCKSTRETCHACTION.eed1071 [BL] set+1 %u != %u", blockstretchaction->eed1071, eed1071);
     blockstretchaction->eed1071--;
   }
   {
     Dwg_EvalExpr evalexpr;
     if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "evalexpr", &evalexpr, NULL)
         && !memcmp (&evalexpr, &blockstretchaction->evalexpr, sizeof (Dwg_EvalExpr)))
         pass ();
     else
         fail ("BLOCKSTRETCHACTION.evalexpr [Dwg_EvalExpr]");
   }
   {
     BITCODE_H* hdls;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "num_hdls", &count, NULL)
         && dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "hdls", &hdls, NULL)
         && hdls == blockstretchaction->hdls)
       pass ();
     else
       fail ("BLOCKSTRETCHACTION.hdls [H*] * %u num_hdls", count);
   }
   {
     BITCODE_T name;
     if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "name", &name, NULL)
         && name
            ? strEQ ((char *)name, (char *)blockstretchaction->name)
            : !blockstretchaction->name)
       pass ();
     else
       fail ("BLOCKSTRETCHACTION.name [T] '%s' <> '%s'", name, blockstretchaction->name);
   }
   {
     BITCODE_BL num_actions;
     if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "num_actions", &num_actions, NULL)
         && num_actions == blockstretchaction->num_actions)
       pass ();
     else
       fail ("BLOCKSTRETCHACTION.num_actions [BL] %u != %u", blockstretchaction->num_actions, num_actions);
     num_actions++;
     if (dwg_dynapi_entity_set_value (blockstretchaction, "BLOCKSTRETCHACTION", "num_actions", &num_actions, 0)
         && num_actions == blockstretchaction->num_actions)
       pass ();
     else
       fail ("BLOCKSTRETCHACTION.num_actions [BL] set+1 %u != %u", blockstretchaction->num_actions, num_actions);
     blockstretchaction->num_actions--;
   }
   {
     BITCODE_BL num_codes;
     if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "num_codes", &num_codes, NULL)
         && num_codes == blockstretchaction->num_codes)
       pass ();
     else
       fail ("BLOCKSTRETCHACTION.num_codes [BL] %u != %u", blockstretchaction->num_codes, num_codes);
     num_codes++;
     if (dwg_dynapi_entity_set_value (blockstretchaction, "BLOCKSTRETCHACTION", "num_codes", &num_codes, 0)
         && num_codes == blockstretchaction->num_codes)
       pass ();
     else
       fail ("BLOCKSTRETCHACTION.num_codes [BL] set+1 %u != %u", blockstretchaction->num_codes, num_codes);
     blockstretchaction->num_codes--;
   }
   {
     BITCODE_BL num_deps;
     if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "num_deps", &num_deps, NULL)
         && num_deps == blockstretchaction->num_deps)
       pass ();
     else
       fail ("BLOCKSTRETCHACTION.num_deps [BL] %u != %u", blockstretchaction->num_deps, num_deps);
     num_deps++;
     if (dwg_dynapi_entity_set_value (blockstretchaction, "BLOCKSTRETCHACTION", "num_deps", &num_deps, 0)
         && num_deps == blockstretchaction->num_deps)
       pass ();
     else
       fail ("BLOCKSTRETCHACTION.num_deps [BL] set+1 %u != %u", blockstretchaction->num_deps, num_deps);
     blockstretchaction->num_deps--;
   }
   {
     BITCODE_BL num_hdls;
     if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "num_hdls", &num_hdls, NULL)
         && num_hdls == blockstretchaction->num_hdls)
       pass ();
     else
       fail ("BLOCKSTRETCHACTION.num_hdls [BL] %u != %u", blockstretchaction->num_hdls, num_hdls);
     num_hdls++;
     if (dwg_dynapi_entity_set_value (blockstretchaction, "BLOCKSTRETCHACTION", "num_hdls", &num_hdls, 0)
         && num_hdls == blockstretchaction->num_hdls)
       pass ();
     else
       fail ("BLOCKSTRETCHACTION.num_hdls [BL] set+1 %u != %u", blockstretchaction->num_hdls, num_hdls);
     blockstretchaction->num_hdls--;
   }
   {
     BITCODE_BL num_pts;
     if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "num_pts", &num_pts, NULL)
         && num_pts == blockstretchaction->num_pts)
       pass ();
     else
       fail ("BLOCKSTRETCHACTION.num_pts [BL] %u != %u", blockstretchaction->num_pts, num_pts);
     num_pts++;
     if (dwg_dynapi_entity_set_value (blockstretchaction, "BLOCKSTRETCHACTION", "num_pts", &num_pts, 0)
         && num_pts == blockstretchaction->num_pts)
       pass ();
     else
       fail ("BLOCKSTRETCHACTION.num_pts [BL] set+1 %u != %u", blockstretchaction->num_pts, num_pts);
     blockstretchaction->num_pts--;
   }
   {
     struct _dwg_object_object* parent;
     if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "parent", &parent, NULL)
         && !memcmp (&parent, &blockstretchaction->parent, sizeof (struct _dwg_object_object*)))
         pass ();
     else
         fail ("BLOCKSTRETCHACTION.parent [struct _dwg_object_object*]");
   }
   {
     BITCODE_2RD* pts;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "num_pts", &count, NULL)
         && dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "pts", &pts, NULL)
         && pts == blockstretchaction->pts)
       pass ();
     else
       fail ("BLOCKSTRETCHACTION.pts [2RD*] * %u num_pts", count);
   }
   {
     BITCODE_BS* shorts;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "num_shorts", &count, NULL)
         && dwg_dynapi_entity_value (blockstretchaction, "BLOCKSTRETCHACTION", "shorts", &shorts, NULL)
         && shorts == blockstretchaction->shorts)
       pass ();
     else
       fail ("BLOCKSTRETCHACTION.shorts [BS*] * %u num_shorts", count);
   }
   if (failed && (is_class_unstable ("BLOCKSTRETCHACTION") || is_class_debugging ("BLOCKSTRETCHACTION")))
     {
       ok ("%s failed %d tests (TODO unstable)", "BLOCKSTRETCHACTION", failed);
       failed = 0;
     }
   return failed;
 }
@@ -51032,255 +51032,255 @@ static int test_LONG_TRANSACTION (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
   Dwg_Object_LONG_TRANSACTION *restrict long_transaction = obj->tio.object->tio.LONG_TRANSACTION;
   failed = 0;
   if (!obj_obj || !long_transaction)
     {
       fail ("NULL LONG_TRANSACTION");
       return 1;
     }
   {
     struct _dwg_object_object* parent;
     if (dwg_dynapi_entity_value (long_transaction, "LONG_TRANSACTION", "parent", &parent, NULL)
         && !memcmp (&parent, &long_transaction->parent, sizeof (struct _dwg_object_object*)))
         pass ();
     else
         fail ("LONG_TRANSACTION.parent [struct _dwg_object_object*]");
   }
   if (failed && (is_class_unstable ("LONG_TRANSACTION") || is_class_debugging ("LONG_TRANSACTION")))
     {
       ok ("%s failed %d tests (TODO unstable)", "LONG_TRANSACTION", failed);
       failed = 0;
     }
   return failed;
 }
 static int test_LTYPE (const Dwg_Object *obj)
 {
   int error = 0;
   const Dwg_Object_Object *restrict obj_obj = obj->tio.object;
   Dwg_Object_LTYPE *restrict ltype = obj->tio.object->tio.LTYPE;
   failed = 0;
   if (!obj_obj || !ltype)
     {
       fail ("NULL LTYPE");
       return 1;
     }
   {
     BITCODE_RC alignment;
     if (dwg_dynapi_entity_value (ltype, "LTYPE", "alignment", &alignment, NULL)
         && alignment == ltype->alignment)
       pass ();
     else
       fail ("LTYPE.alignment [RC] %u != %u", ltype->alignment, alignment);
     alignment++;
     if (dwg_dynapi_entity_set_value (ltype, "LTYPE", "alignment", &alignment, 0)
         && alignment == ltype->alignment)
       pass ();
     else
       fail ("LTYPE.alignment [RC] set+1 %u != %u", ltype->alignment, alignment);
     ltype->alignment--;
   }
   {
     Dwg_LTYPE_dash* dashes;
     BITCODE_BL count = 0;
     if (dwg_dynapi_entity_value (ltype, "LTYPE", "numdashes", &count, NULL)
         && dwg_dynapi_entity_value (ltype, "LTYPE", "dashes", &dashes, NULL)
         && dashes == ltype->dashes)
       pass ();
     else
       fail ("LTYPE.dashes [Dwg_LTYPE_dash*] * %u numdashes", count);
   }
   {
     BITCODE_RD dashes_r11[12];
-    if (dwg_dynapi_entity_value (ltype, "LTYPE", "dashes_r11[12]", &dashes_r11, NULL)
+    if (dwg_dynapi_entity_value (ltype, "LTYPE", "dashes_r11", &dashes_r11, NULL)
         && !memcmp (&dashes_r11, &ltype->dashes_r11, sizeof (BITCODE_RD)))
         pass ();
     else
-        fail ("LTYPE.dashes_r11[12] [RD]");
+        fail ("LTYPE.dashes_r11 [RD]");
   }
   {
     BITCODE_T description;
     if (dwg_dynapi_entity_value (ltype, "LTYPE", "description", &description, NULL)
         && description
            ? strEQ ((char *)description, (char *)ltype->description)
            : !ltype->description)
       pass ();
     else
       fail ("LTYPE.description [T] '%s' <> '%s'", description, ltype->description);
   }
   {
     BITCODE_RC flag;
     if (dwg_dynapi_entity_value (ltype, "LTYPE", "flag", &flag, NULL)
         && flag == ltype->flag)
       pass ();
     else
       fail ("LTYPE.flag [RC] %u != %u", ltype->flag, flag);
     flag++;
     if (dwg_dynapi_entity_set_value (ltype, "LTYPE", "flag", &flag, 0)
         && flag == ltype->flag)
       pass ();
     else
       fail ("LTYPE.flag [RC] set+1 %u != %u", ltype->flag, flag);
     ltype->flag--;
   }
   {
     BITCODE_B has_strings_area;
     if (dwg_dynapi_entity_value (ltype, "LTYPE", "has_strings_area", &has_strings_area, NULL)
         && has_strings_area == ltype->has_strings_area)
       pass ();
     else
       fail ("LTYPE.has_strings_area [B] " FORMAT_B " != " FORMAT_B "", ltype->has_strings_area, has_strings_area);
     has_strings_area++;
     if (dwg_dynapi_entity_set_value (ltype, "LTYPE", "has_strings_area", &has_strings_area, 0)
         && has_strings_area == ltype->has_strings_area)
       pass ();
     else
       fail ("LTYPE.has_strings_area [B] set+1 " FORMAT_B " != " FORMAT_B "", ltype->has_strings_area, has_strings_area);
     ltype->has_strings_area--;
   }
   {
     BITCODE_B is_xref_dep;
     if (dwg_dynapi_entity_value (ltype, "LTYPE", "is_xref_dep", &is_xref_dep, NULL)
         && is_xref_dep == ltype->is_xref_dep)
       pass ();
     else
       fail ("LTYPE.is_xref_dep [B] " FORMAT_B " != " FORMAT_B "", ltype->is_xref_dep, is_xref_dep);
     is_xref_dep++;
     if (dwg_dynapi_entity_set_value (ltype, "LTYPE", "is_xref_dep", &is_xref_dep, 0)
         && is_xref_dep == ltype->is_xref_dep)
       pass ();
     else
       fail ("LTYPE.is_xref_dep [B] set+1 " FORMAT_B " != " FORMAT_B "", ltype->is_xref_dep, is_xref_dep);
     ltype->is_xref_dep--;
   }
   {
     BITCODE_B is_xref_ref;
     if (dwg_dynapi_entity_value (ltype, "LTYPE", "is_xref_ref", &is_xref_ref, NULL)
         && is_xref_ref == ltype->is_xref_ref)
       pass ();
     else
       fail ("LTYPE.is_xref_ref [B] " FORMAT_B " != " FORMAT_B "", ltype->is_xref_ref, is_xref_ref);
     is_xref_ref++;
     if (dwg_dynapi_entity_set_value (ltype, "LTYPE", "is_xref_ref", &is_xref_ref, 0)
         && is_xref_ref == ltype->is_xref_ref)
       pass ();
     else
       fail ("LTYPE.is_xref_ref [B] set+1 " FORMAT_B " != " FORMAT_B "", ltype->is_xref_ref, is_xref_ref);
     ltype->is_xref_ref--;
   }
   {
     BITCODE_BS is_xref_resolved;
     if (dwg_dynapi_entity_value (ltype, "LTYPE", "is_xref_resolved", &is_xref_resolved, NULL)
         && is_xref_resolved == ltype->is_xref_resolved)
       pass ();
     else
       fail ("LTYPE.is_xref_resolved [BS] %hu != %hu", ltype->is_xref_resolved, is_xref_resolved);
     is_xref_resolved++;
     if (dwg_dynapi_entity_set_value (ltype, "LTYPE", "is_xref_resolved", &is_xref_resolved, 0)
         && is_xref_resolved == ltype->is_xref_resolved)
       pass ();
     else
       fail ("LTYPE.is_xref_resolved [BS] set+1 %hu != %hu", ltype->is_xref_resolved, is_xref_resolved);
     ltype->is_xref_resolved--;
   }
   {
     BITCODE_TV name;
     if (dwg_dynapi_entity_value (ltype, "LTYPE", "name", &name, NULL)
         && name
            ? strEQ ((char *)name, (char *)ltype->name)
            : !ltype->name)
       pass ();
     else
       fail ("LTYPE.name [TV] '%s' <> '%s'", name, ltype->name);
   }
   {
     BITCODE_RC numdashes;
     if (dwg_dynapi_entity_value (ltype, "LTYPE", "numdashes", &numdashes, NULL)
         && numdashes == ltype->numdashes)
       pass ();
     else
       fail ("LTYPE.numdashes [RC] %u != %u", ltype->numdashes, numdashes);
     numdashes++;
     if (dwg_dynapi_entity_set_value (ltype, "LTYPE", "numdashes", &numdashes, 0)
         && numdashes == ltype->numdashes)
       pass ();
     else
       fail ("LTYPE.numdashes [RC] set+1 %u != %u", ltype->numdashes, numdashes);
     ltype->numdashes--;
   }
   {
     struct _dwg_object_object* parent;
     if (dwg_dynapi_entity_value (ltype, "LTYPE", "parent", &parent, NULL)
         && !memcmp (&parent, &ltype->parent, sizeof (struct _dwg_object_object*)))
         pass ();
     else
         fail ("LTYPE.parent [struct _dwg_object_object*]");
   }
   {
     BITCODE_BD pattern_len;
     if (dwg_dynapi_entity_value (ltype, "LTYPE", "pattern_len", &pattern_len, NULL)
         && pattern_len == ltype->pattern_len)
       pass ();
     else
       fail ("LTYPE.pattern_len [BD] %g != %g", ltype->pattern_len, pattern_len);
     pattern_len++;
     if (dwg_dynapi_entity_set_value (ltype, "LTYPE", "pattern_len", &pattern_len, 0)
         && pattern_len == ltype->pattern_len)
       pass ();
     else
       fail ("LTYPE.pattern_len [BD] set+1 %g != %g", ltype->pattern_len, pattern_len);
     ltype->pattern_len--;
   }
   {
     BITCODE_TF strings_area;
     if (dwg_dynapi_entity_value (ltype, "LTYPE", "strings_area", &strings_area, NULL)
         && !memcmp (&strings_area, &ltype->strings_area, sizeof (BITCODE_TF)))
         pass ();
     else
         fail ("LTYPE.strings_area [TF]");
   }
   {
     BITCODE_RC unknown_r11;
     if (dwg_dynapi_entity_value (ltype, "LTYPE", "unknown_r11", &unknown_r11, NULL)
         && unknown_r11 == ltype->unknown_r11)
       pass ();
     else
       fail ("LTYPE.unknown_r11 [RC] %u != %u", ltype->unknown_r11, unknown_r11);
     unknown_r11++;
     if (dwg_dynapi_entity_set_value (ltype, "LTYPE", "unknown_r11", &unknown_r11, 0)
         && unknown_r11 == ltype->unknown_r11)
       pass ();
     else
       fail ("LTYPE.unknown_r11 [RC] set+1 %u != %u", ltype->unknown_r11, unknown_r11);
     ltype->unknown_r11--;
   }
   {
     BITCODE_RSd used;
     if (dwg_dynapi_entity_value (ltype, "LTYPE", "used", &used, NULL)
         && used == ltype->used)
       pass ();
     else
       fail ("LTYPE.used [RSd] " FORMAT_RSd " != " FORMAT_RSd "", ltype->used, used);
     used++;
     if (dwg_dynapi_entity_set_value (ltype, "LTYPE", "used", &used, 0)
         && used == ltype->used)
       pass ();
     else
       fail ("LTYPE.used [RSd] set+1 " FORMAT_RSd " != " FORMAT_RSd "", ltype->used, used);
     ltype->used--;
   }
   {
     BITCODE_H xref;
     if (dwg_dynapi_entity_value (ltype, "LTYPE", "xref", &xref, NULL)
         && !memcmp (&xref, &ltype->xref, sizeof (BITCODE_H)))
         pass ();
     else
         fail ("LTYPE.xref [H]");
   }
   if (failed && (is_class_unstable ("LTYPE") || is_class_debugging ("LTYPE")))
     {
       ok ("%s failed %d tests (TODO unstable)", "LTYPE", failed);
       failed = 0;
     }
   return failed;
 }
diff --git a/test/unit-testing/evaluation_graph.c b/test/unit-testing/evaluation_graph.c
index 960a4d61..f4938fe7 100644
--- a/test/unit-testing/evaluation_graph.c
+++ b/test/unit-testing/evaluation_graph.c
@@ -7,68 +7,68 @@ void
 api_process (dwg_object *obj)
 {
   int error;
   BITCODE_BLd first_nodeid, first_nodeid_copy;
   BITCODE_BL num_nodes, i;
   Dwg_EVAL_Node *nodes;
   BITCODE_B has_graph;
   BITCODE_BL num_edges;
   Dwg_EVAL_Edge *edges;
 
   Dwg_Version_Type dwg_version = obj->parent->header.version;
   dwg_obj_evaluation_graph *_obj = dwg_object_to_EVALUATION_GRAPH (obj);
 
   CHK_ENTITY_TYPE (_obj, EVALUATION_GRAPH, first_nodeid, BLd);
   CHK_ENTITY_TYPE (_obj, EVALUATION_GRAPH, first_nodeid_copy, BLd);
   CHK_ENTITY_TYPE (_obj, EVALUATION_GRAPH, num_nodes, BL);
   if (!dwg_dynapi_entity_value (_obj, "EVALUATION_GRAPH", "nodes", &nodes,
                                 NULL))
     fail ("EVAL_Node.nodes");
   else
     for (i = 0; i < _obj->num_nodes; i++)
       {
         BITCODE_BLd node[4];
         CHK_SUBCLASS_TYPE (_obj->nodes[i], EVAL_Node, id, BL);
         CHK_SUBCLASS_TYPE (_obj->nodes[i], EVAL_Node, edge_flags, BL);
         CHK_SUBCLASS_TYPE (_obj->nodes[i], EVAL_Node, nextid, BLd);
         CHK_SUBCLASS_H (_obj->nodes[i], EVAL_Node, evalexpr);
         // CHK_SUBCLASS_VECTOR_TYPE (_obj->nodes[i], EVAL_Node, node, 4, BLd);
-        if (dwg_dynapi_subclass_value (&_obj->nodes[i], "EVAL_Node", "node[4]",
+        if (dwg_dynapi_subclass_value (&_obj->nodes[i], "EVAL_Node", "node",
                                        &node, NULL))
           {
             for (int j = 0; j < 4; j++)
               {
                 ok ("EVAL_Node.node[%d]: " FORMAT_BLd, j, node[j]);
               }
           }
         else
           fail ("EVAL_Node.node[4]");
         CHK_SUBCLASS_TYPE (_obj->nodes[i], EVAL_Node, active_cycles, B);
       }
   CHK_ENTITY_TYPE (_obj, EVALUATION_GRAPH, has_graph, B);
 
   CHK_ENTITY_TYPE (_obj, EVALUATION_GRAPH, num_edges, BL);
   if (!dwg_dynapi_entity_value (_obj, "EVALUATION_GRAPH", "edges", &edges,
                                 NULL))
     fail ("EVAL_Edge.edges");
   else
     for (i = 0; i < _obj->num_edges; i++)
       {
         BITCODE_BLd edge[5];
         CHK_SUBCLASS_TYPE (_obj->edges[i], EVAL_Edge, id, BL);
         CHK_SUBCLASS_TYPE (_obj->edges[i], EVAL_Edge, nextid, BLd);
         CHK_SUBCLASS_TYPE (_obj->edges[i], EVAL_Edge, e1, BLd);
         CHK_SUBCLASS_TYPE (_obj->edges[i], EVAL_Edge, e2, BLd);
         CHK_SUBCLASS_TYPE (_obj->edges[i], EVAL_Edge, e3, BLd);
         // CHK_SUBCLASS_VECTOR_TYPE (edges, EVAL_Edge, edge, 5, BLd);
         if (dwg_dynapi_subclass_value (&_obj->edges[i], "EVAL_Edge",
-                                       "out_edge[5]", &edge, NULL))
+                                       "out_edge", &edge, NULL))
           {
             for (int j = 0; j < 5; j++)
               {
                 ok ("EVAL_Edge.out_edge[%d]: " FORMAT_BLd, j, edge[j]);
               }
           }
         else
           fail ("EVAL_Edge.out_edge[5]");
       }
 }
diff --git a/test/unit-testing/vertex_pface_face.c b/test/unit-testing/vertex_pface_face.c
index 37578c77..90eaca9b 100644
--- a/test/unit-testing/vertex_pface_face.c
+++ b/test/unit-testing/vertex_pface_face.c
@@ -5,21 +5,21 @@ void
 api_process (dwg_object *obj)
 {
   int error;
   BITCODE_BS vertind[4];
   dwg_point_3d pt;
 
   dwg_ent_vert_pface_face *ent = dwg_object_to_VERTEX_PFACE_FACE (obj);
 
-  if (!dwg_dynapi_entity_value (ent, "VERTEX_PFACE_FACE", "vertind[4]",
+  if (!dwg_dynapi_entity_value (ent, "VERTEX_PFACE_FACE", "vertind",
                                 &vertind, NULL))
     fail ("dwg_dynapi_entity_value");
   else
     for (int i = 0; i < 4; i++)
       {
         if (vertind[i] == ent->vertind[i])
           ok ("vertind[%d]: " FORMAT_BS, i, vertind[i]);
         else
           fail ("vertind[%d] " FORMAT_BS " != ent->vertind[i] " FORMAT_BS, i,
                 vertind[i], ent->vertind[i]);
       }
 }
