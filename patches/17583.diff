commit 60ce52512cb170eb0fa88f3847074e472fc80d76
Author: John Cupitt <jcupitt@gmail.com>
Date:   Tue Oct 22 17:37:05 2019 +0100

    builds
    
    now needs testing

diff --git a/libvips/include/vips/stream.h b/libvips/include/vips/stream.h
index 4534ed9d5..8c6767f16 100644
--- a/libvips/include/vips/stream.h
+++ b/libvips/include/vips/stream.h
@@ -86,6 +86,8 @@ typedef struct _VipsStreamClass {
 
 GType vips_stream_get_type( void );
 
+int vips_stream_open( VipsStream *stream );
+int vips_stream_close( VipsStream *stream );
 const char *vips_stream_name( VipsStream *stream );
 
 #define VIPS_TYPE_STREAMI (vips_streami_get_type())
@@ -168,39 +170,48 @@ typedef struct _VipsStreami {
 typedef struct _VipsStreamiClass {
 	VipsStreamClass parent_class;
 
 	/* Subclasses can define these to implement other streami methods.
 	 */
 
 	/* Read up to N bytes from the stream into the supplied buffer,
 	 * returning the number of bytes actually read. 
 	 *
 	 * -1 on error, 0 on EOF.
 	 */
 	ssize_t (*read)( VipsStreami *, void *, size_t );
 
 	/* Map the entire stream into memory, for example with mmap(). Return
 	 * the base and size of the mapped area.
 	 *
 	 * If this is not defined, the file will be read in with repeated
 	 * calls to ->read(). 
 	 *
 	 * NULL on error.
 	 */
 	const void *(*map)( VipsStreami *, size_t * );
 
 	/* Seek to a certain position, args exactly as lseek(2).
 	 */
 	gint64 (*seek)( VipsStreami *, gint64 offset, int );
 
 	/* Shut down anything that can safely restarted. For example, if
 	 * there's a fd that supports lseek(), it can be closed, since later 
 	 * (if neccessary) it can be reopened and lseek()ed back to the 
 	 * correct point.
 	 *
 	 * Non-restartable shutdown shuld be in _finalize().
 	 */
 	void (*minimise)( VipsStreami * );
 
+	/* The opposite of minimise: restart anything that minimise shut down.
+	 */
+	int (*unminimise)( VipsStreami * );
+
+	/* Length of object in bytes. If this is a pipe, it will force the
+	 * whole object to be read into memory, so use cautiously.
+	 */
+	gint64 (*size)( VipsStreami * );
+
 } VipsStreamiClass;
 
 GType vips_streami_get_type( void );
@@ -216,6 +227,7 @@ const void *vips_streami_map( VipsStreami *streami, size_t *length );
 gint64 vips_streami_seek( VipsStreami *streami, gint64 offset, int whence );
 int vips_streami_rewind( VipsStreami *streami );
 void vips_streami_minimise( VipsStreami *streami );
+int vips_streami_unminimise( VipsStreami *streami );
 int vips_streami_decode( VipsStreami *streami );
 unsigned char *vips_streami_sniff( VipsStreami *streami, size_t length );
 gint64 vips_streami_size( VipsStreami *streami ); 
diff --git a/libvips/iofuncs/image.c b/libvips/iofuncs/image.c
index 4b75c23d2..119ea4083 100644
--- a/libvips/iofuncs/image.c
+++ b/libvips/iofuncs/image.c
@@ -2185,43 +2185,42 @@ vips_image_new_from_buffer( const void *buf, size_t len,
  * Returns: (transfer full): the new #VipsImage, or %NULL on error.
  */
 VipsImage *
-vips_image_new_from_stream( VipsStreamInput *input, 
-	const char *option_string, ... )
+vips_image_new_from_stream( VipsStreami *input, const char *option_string, ... )
 {
 	const char *operation_name;
 	va_list ap;
 	int result;
 	VipsImage *out;
 
 	vips_check_init();
 
         if( !(operation_name = vips_foreign_find_load_stream( input )) )
                 return( NULL );
 
         va_start( ap, option_string );
         result = vips_call_split_option_string( operation_name,
                 option_string, ap, input, &out );
         va_end( ap );
 
         if( result )
                 return( NULL );
 
         return( out );
 }
 
 /**
  * vips_image_new_matrix: (constructor)
  * @width: image width
  * @height: image height
  *
  * This convenience function makes an image which is a matrix: a one-band
  * #VIPS_FORMAT_DOUBLE image held in memory.
  *
  * Use VIPS_IMAGE_ADDR(), or VIPS_MATRIX() to address pixels in the image.
  *
  * Use vips_image_set_double() to set "scale" and "offset", if required. 
  *
  * See also: vips_image_new_matrixv()
  * 
  * Returns: (transfer full): the new #VipsImage, or %NULL on error.
  */
@@ -2726,39 +2725,39 @@ vips_image_write_to_buffer( VipsImage *in,
  */
 int
 vips_image_write_to_stream( VipsImage *in, 
-	const char *suffix, VipsStreamOutput *output, ... )
+	const char *suffix, VipsStreamo *output, ... )
 {
 	char filename[VIPS_PATH_MAX];
 	char option_string[VIPS_PATH_MAX];
 	const char *operation_name;
 	va_list ap;
 	int result;
 
 	vips__filename_split8( suffix, filename, option_string );
 	if( !(operation_name = vips_foreign_find_save_stream( filename )) )
 		return( -1 );
 
 	va_start( ap, output );
 	result = vips_call_split_option_string( operation_name, option_string, 
 		ap, in, output );
 	va_end( ap );
 
 	if( result )
 		return( -1 );
 
 	return( 0 );
 }
 
 /**
  * vips_image_write_to_memory: (method)
  * @in: image to write
  * @size: return buffer length here
  *
  * Writes @in to memory as a simple, unformatted C-style array. 
  *
  * The caller is responsible for freeing this memory with g_free(). 
  *
  * See also: vips_image_write_to_buffer().
  *
  * Returns: (array length=size) (element-type guint8) (transfer full): return buffer start here
  */
diff --git a/libvips/iofuncs/init.c b/libvips/iofuncs/init.c
index 27939b0fa..b3ec8ecf0 100644
--- a/libvips/iofuncs/init.c
+++ b/libvips/iofuncs/init.c
@@ -327,224 +327,224 @@ int
 vips_init( const char *argv0 )
 {
 	extern GType vips_system_get_type( void );
 	extern GType write_thread_state_get_type( void );
 	extern GType sink_memory_thread_state_get_type( void ); 
 	extern GType render_thread_state_get_type( void ); 
-	extern GType vips_stream_input_get_type( void ); 
-	extern GType vips_stream_output_get_type( void ); 
+	extern GType vips_streami_get_type( void ); 
+	extern GType vips_streamo_get_type( void ); 
 
 	static gboolean started = FALSE;
 	static gboolean done = FALSE;
 	const char *vips_min_stack_size;
 	const char *prefix;
 	const char *libdir;
 	char *locale;
 
 	/* Two stage done handling: 'done' means we've completed, 'started'
 	 * means we're currently initialising. Use this to prevent recursive
 	 * invocation.
 	 */
 	if( done )
 		/* Called more than once, we succeeded, just return OK.
 		 */
 		return( 0 );
 	if( started ) 
 		/* Recursive invocation, something has broken horribly.
 		 * Hopefully the first init will handle it.
 		 */
 		return( 0 );
 	started = TRUE;
 
 #ifdef OS_WIN32
 	/* Windows has a limit of 512 files open at once for the fopen() family
 	 * of functions, and 2048 for the _open() family. This raises the limit
 	 * of fopen() to the same level as _open().
 	 *
 	 * It will not go any higher than this, unfortunately.  
 	 */
 	(void) _setmaxstdio( 2048 );
 #endif /*OS_WIN32*/
 
 #ifdef HAVE_TYPE_INIT
 	/* Before glib 2.36 you have to call this on startup.
 	 */
 	g_type_init();
 #endif /*HAVE_TYPE_INIT*/
 
 	/* Older glibs need this.
 	 */
 #ifndef HAVE_THREAD_NEW
 	if( !g_thread_supported() ) 
 		g_thread_init( NULL );
 #endif /*HAVE_THREAD_NEW*/
 
 	vips__threadpool_init();
 	vips__buffer_init();
 
 	/* This does an unsynchronised static hash table init on first call --
 	 * we have to make sure we do this single-threaded. See: 
 	 * https://github.com/openslide/openslide/issues/161
 	 */
 	(void) g_get_language_names(); 
 
 	if( !vips__global_lock )
 		vips__global_lock = vips_g_mutex_new();
 
 	if( !vips__global_timer )
 		vips__global_timer = g_timer_new();
 
 	VIPS_SETSTR( vips__argv0, argv0 );
 
 	if( argv0 ) {
 		char *prgname;
 
 		prgname = g_path_get_basename( argv0 );
 		g_set_prgname( prgname );
 		g_free( prgname );
 	}
 
 	vips__thread_profile_attach( "main" );
 
 	/* We can't do VIPS_GATE_START() until command-line processing
 	 * happens, since vips__thread_profile may not be set yet. Call
 	 * directly. 
 	 */
 	vips__thread_gate_start( "init: main" ); 
 	vips__thread_gate_start( "init: startup" ); 
 
 	/* Try to discover our prefix. 
 	 */
 	if( !(prefix = vips_guess_prefix( argv0, "VIPSHOME" )) || 
 		!(libdir = vips_guess_libdir( argv0, "VIPSHOME" )) ) 
 		return( -1 );
 
 	/* Get i18n .mo files from $VIPSHOME/share/locale/.
 	 */
 	locale = g_build_filename( prefix, "share", "locale", NULL );
 	bindtextdomain( GETTEXT_PACKAGE, locale );
 	g_free( locale );
 	bind_textdomain_codeset( GETTEXT_PACKAGE, "UTF-8" );
 
 	/* Deprecated, this is just for compat.
 	 */
 	if( g_getenv( "VIPS_INFO" ) || 
 		g_getenv( "IM_INFO" ) ) 
 		vips_info_set( TRUE );
 
 	if( g_getenv( "VIPS_PROFILE" ) )
 		vips_profile_set( TRUE );
 
 	/* Default various settings from env.
 	 */
 	if( g_getenv( "VIPS_TRACE" ) )
 		vips_cache_set_trace( TRUE );
 
 	/* Register base vips types.
 	 */
 	(void) vips_image_get_type();
 	(void) vips_region_get_type();
 	(void) write_thread_state_get_type();
 	(void) sink_memory_thread_state_get_type(); 
 	(void) render_thread_state_get_type(); 
-	(void) vips_stream_input_get_type(); 
-	(void) vips_stream_output_get_type(); 
+	(void) vips_streami_get_type(); 
+	(void) vips_streamo_get_type(); 
 	vips__meta_init_types();
 	vips__interpolate_init();
 	im__format_init();
 
 	/* Start up operator cache.
 	 */
 	vips__cache_init();
 
 	/* Recomp reordering system.
 	 */
 	vips__reorder_init();
 
 	/* Start up packages.
 	 */
 	(void) vips_system_get_type();
 	vips_arithmetic_operation_init();
 	vips_conversion_operation_init();
 	vips_create_operation_init();
 	vips_foreign_operation_init();
 	vips_resample_operation_init();
 	vips_colour_operation_init();
 	vips_histogram_operation_init();
 	vips_convolution_operation_init();
 	vips_freqfilt_operation_init();
 	vips_morphology_operation_init();
 	vips_draw_operation_init();
 	vips_mosaicing_operation_init();
 
 	/* Load any vips8 plugins from the vips libdir. Keep going, even if
 	 * some plugins fail to load. 
 	 */
 	(void) vips_load_plugins( "%s/vips-plugins-%d.%d", 
 		libdir, VIPS_MAJOR_VERSION, VIPS_MINOR_VERSION );
 
 	/* Load up any vips7 plugins in the vips libdir. We don't error on 
 	 * failure, it's too annoying to have VIPS refuse to start because of 
 	 * a broken plugin.
 	 */
 	if( im_load_plugins( "%s/vips-%d.%d", 
 		libdir, VIPS_MAJOR_VERSION, VIPS_MINOR_VERSION ) ) {
 		g_warning( "%s", vips_error_buffer() );
 		vips_error_clear();
 	}
 
 	/* Also load from libdir. This is old and slightly broken behaviour
 	 * :-( kept for back compat convenience.
 	 */
 	if( im_load_plugins( "%s", libdir ) ) {
 		g_warning( "%s", vips_error_buffer() );
 		vips_error_clear();
 	}
 
 	/* Get the run-time compiler going.
 	 */
 	vips_vector_init();
 
 #ifdef HAVE_GSF
 	/* Use this for structured file write.
 	 */
 	gsf_init();
 #endif /*HAVE_GSF*/
 
 	/* Register vips_shutdown(). This may well not get called and many
 	 * platforms don't support it anyway.
 	 */
 #ifdef HAVE_ATEXIT
 	atexit( vips_shutdown );
 #endif /*HAVE_ATEXIT*/
 
 #ifdef DEBUG_LEAK
 	vips__image_pixels_quark = 
 		g_quark_from_static_string( "vips-image-pixels" ); 
 #endif /*DEBUG_LEAK*/
 
 	done = TRUE;
 
 	/* If VIPS_WARNING is defined, suppress all warning messages from vips.
 	 *
 	 * Libraries should not call g_log_set_handler(), it is
 	 * supposed to be for the application layer, but this can be awkward to
 	 * set up if you are using libvips from something like Ruby. Allow this
 	 * env var hack as a workaround. 
 	 */
 	if( g_getenv( "VIPS_WARNING" ) ||
 		g_getenv( "IM_WARNING" ) ) 
 		g_log_set_handler( "VIPS", G_LOG_LEVEL_WARNING, 
 			empty_log_handler, NULL );
 
 	/* Set a minimum stacksize, if we can.
 	 */
         if( (vips_min_stack_size = g_getenv( "VIPS_MIN_STACK_SIZE" )) )
 		(void) set_stacksize( vips__parse_size( vips_min_stack_size ) );
 
 	vips__thread_gate_stop( "init: startup" ); 
 
 	return( 0 );
 }
 
 /* Call this before vips stuff that uses stuff we need to have inited.
  */
diff --git a/libvips/iofuncs/object.c b/libvips/iofuncs/object.c
index 07534240a..d4dbe116a 100644
--- a/libvips/iofuncs/object.c
+++ b/libvips/iofuncs/object.c
@@ -1861,284 +1861,284 @@ int
 vips_object_set_argument_from_string( VipsObject *object, 
 	const char *name, const char *value )
 {
 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( object );
 
 	GParamSpec *pspec;
 	VipsArgumentClass *argument_class;
 	VipsArgumentInstance *argument_instance;
 	VipsObjectClass *oclass;
 	GType otype;
 
 	GValue gvalue = { 0 };
 
 	VIPS_DEBUG_MSG( "vips_object_set_argument_from_string: %s = %s\n", 
 		name, value );
 
 	if( vips_object_get_argument( object, name,
 		&pspec, &argument_class, &argument_instance ) )
 		return( -1 );
 
 	otype = G_PARAM_SPEC_VALUE_TYPE( pspec );
 
 	g_assert( argument_class->flags & VIPS_ARGUMENT_INPUT );
 
 	if( g_type_is_a( otype, VIPS_TYPE_IMAGE ) ) { 
 		VipsImage *out;
 		VipsOperationFlags flags;
 		VipsAccess access;
 		char filename[VIPS_PATH_MAX];
 		char option_string[VIPS_PATH_MAX];
 
 		flags = 0;
 		if( VIPS_IS_OPERATION( object ) )
 			flags = vips_operation_get_flags( 
 				VIPS_OPERATION( object ) );
 
 		if( flags & 
 			(VIPS_OPERATION_SEQUENTIAL_UNBUFFERED | 
 			 VIPS_OPERATION_SEQUENTIAL) ) 
 			access = VIPS_ACCESS_SEQUENTIAL;
 		else
 			access = VIPS_ACCESS_RANDOM; 
 
 		if( !value ) {
 			vips_object_no_value( object, name );
 			return( -1 );
 		}
 		vips__filename_split8( value, filename, option_string );
 
 		if( strcmp( "stdin", filename ) == 0 ) {
-			VipsStreamInput *input;
+			VipsStreami *input;
 
 			if( !(input = 
-				vips_stream_input_new_from_descriptor( 0 )) )
+				vips_streami_new_from_descriptor( 0 )) )
 				return( -1 );
 			if( !(out = vips_image_new_from_stream( input, 
 				option_string, 
 				"access", access,
 				NULL )) ) {
 				VIPS_UNREF( input );
 				return( -1 );
 			}
 			VIPS_UNREF( input );
 		}
 		else {
 			if( !(out = vips_image_new_from_file( value, 
 				"access", access,
 				NULL )) )
 				return( -1 );
 		}
 
 		g_value_init( &gvalue, VIPS_TYPE_IMAGE );
 		g_value_set_object( &gvalue, out );
 
 		/* Setting gvalue will have upped @out's count again,
 		 * go back to 1 so that gvalue has the only ref.
 		 */
 		g_object_unref( out );
 	}
-	else if( g_type_is_a( otype, VIPS_TYPE_STREAM_INPUT ) ) { 
-		VipsStreamInput *input;
+	else if( g_type_is_a( otype, VIPS_TYPE_STREAMI ) ) { 
+		VipsStreami *input;
 
 		if( !value ) {
 			vips_object_no_value( object, name );
 			return( -1 );
 		}
 
-		if( !(input = vips_stream_input_new_from_options( value )) )
+		if( !(input = vips_streami_new_from_options( value )) )
 			return( -1 );
 	
-		g_value_init( &gvalue, VIPS_TYPE_STREAM_INPUT );
+		g_value_init( &gvalue, VIPS_TYPE_STREAMI );
 		g_value_set_object( &gvalue, input );
 
 		/* Setting gvalue will have upped @out's count again,
 		 * go back to 1 so that gvalue has the only ref.
 		 */
 		g_object_unref( input );
 	}
 	else if( g_type_is_a( otype, VIPS_TYPE_ARRAY_IMAGE ) ) { 
 		/* We have to have a special case for this, we can't just rely
 		 * on transform_g_string_array_image(), since we need to be
 		 * able to set the access hint on the image.
 		 */
 		VipsArrayImage *array_image;
 		VipsOperationFlags flags;
 		VipsAccess access;
 
 		if( !value ) {
 			vips_object_no_value( object, name );
 			return( -1 );
 		}
 
 		flags = 0;
 		if( VIPS_IS_OPERATION( object ) )
 			flags = vips_operation_get_flags( 
 				VIPS_OPERATION( object ) );
 
 		if( flags & (VIPS_OPERATION_SEQUENTIAL_UNBUFFERED |
 			     VIPS_OPERATION_SEQUENTIAL) ) 
 			access = VIPS_ACCESS_SEQUENTIAL;
 		else
 			access = VIPS_ACCESS_RANDOM; 
 
 		if( !(array_image = 
 			vips_array_image_new_from_string( value, access )) )
 			return( -1 ); 
 
 		g_value_init( &gvalue, VIPS_TYPE_ARRAY_IMAGE );
 		g_value_set_boxed( &gvalue, array_image );
 
 		/* Setting gvalue will have upped @array_image's count again,
 		 * go back to 1 so that gvalue has the only ref.
 		 */
 		vips_area_unref( VIPS_AREA( array_image ) );
 	}
 	else if( g_type_is_a( otype, VIPS_TYPE_OBJECT ) &&
 		(oclass = g_type_class_ref( otype )) ) { 
 		VipsObject *new_object;
 
 		if( !value ) {
 			vips_object_no_value( object, name );
 			return( -1 );
 		}
 
 		if( !(new_object = 
 			vips_object_new_from_string( oclass, value )) )
 			return( -1 );
 
 		/* Not necessarily a VipsOperation subclass so we don't use
 		 * the cache. We could have a separate case for this.
 		 */
 		if( vips_object_build( new_object ) ) {
 			g_object_unref( new_object );
 			return( -1 );
 		}
 
 		g_value_init( &gvalue, G_TYPE_OBJECT );
 		g_value_set_object( &gvalue, new_object );
 
 		/* The GValue now has a ref, we can drop ours.
 		 */
 		g_object_unref( new_object );
 	}
 	else if( G_IS_PARAM_SPEC_BOOLEAN( pspec ) ) {
 		gboolean b;
 
 		b = TRUE;
 		if( value &&
 			(g_ascii_strcasecmp( value, "false" ) == 0 ||
 			g_ascii_strcasecmp( value, "no" ) == 0 ||
 			strcmp( value, "0" ) == 0) )
 			b = FALSE;
 
 		g_value_init( &gvalue, G_TYPE_BOOLEAN );
 		g_value_set_boolean( &gvalue, b );
 	}
 	else if( G_IS_PARAM_SPEC_INT( pspec ) ) {
 		int i;
 
 		if( !value ) {
 			vips_object_no_value( object, name );
 			return( -1 );
 		}
 
 		if( sscanf( value, "%d", &i ) != 1 ) {
 			vips_error( class->nickname,
 				_( "'%s' is not an integer" ), value );
 			return( -1 );
 		}
 
 		g_value_init( &gvalue, G_TYPE_INT );
 		g_value_set_int( &gvalue, i );
 	}
 	else if( G_IS_PARAM_SPEC_UINT64( pspec ) ) {
 		/* Not allways the same as guint64 :-( argh.
 		 */
 		long long l;
 
 		if( !value ) {
 			vips_object_no_value( object, name );
 			return( -1 );
 		}
 
 		if( sscanf( value, "%lld", &l ) != 1 ) {
 			vips_error( class->nickname,
 				_( "'%s' is not an integer" ), value );
 			return( -1 );
 		}
 
 		g_value_init( &gvalue, G_TYPE_UINT64 );
 		g_value_set_uint64( &gvalue, l );
 	}
 	else if( G_IS_PARAM_SPEC_DOUBLE( pspec ) ) {
 		double d;
 
 		if( !value ) {
 			vips_object_no_value( object, name );
 			return( -1 );
 		}
 
 		if( sscanf( value, "%lg", &d ) != 1 ) {
 			vips_error( class->nickname,
 				_( "'%s' is not a double" ), value );
 			return( -1 );
 		}
 
 		g_value_init( &gvalue, G_TYPE_DOUBLE );
 		g_value_set_double( &gvalue, d );
 	}
 	else if( G_IS_PARAM_SPEC_ENUM( pspec ) ) {
 		int i;
 
 		if( !value ) {
 			vips_object_no_value( object, name );
 			return( -1 );
 		}
 
 		if( (i = vips_enum_from_nick( class->nickname, 
 			otype, value )) < 0 ) 
 			return( -1 );
 
 		g_value_init( &gvalue, otype );
 		g_value_set_enum( &gvalue, i );
 	}
 	else if( G_IS_PARAM_SPEC_FLAGS( pspec ) ) {
 		/* Allow a symbolic name, or an int. 
 		 */
 		int i;
 
 		if( !value ) {
 			vips_object_no_value( object, name );
 			return( -1 );
 		}
 
 		if( sscanf( value, "%d", &i ) != 1 &&
 			(i = vips_flags_from_nick( class->nickname, 
 			otype, value )) < 0 ) {
 			vips_error( class->nickname,
 				_( "'%s' is not an integer" ), value );
 			return( -1 );
 		}
 
 		g_value_init( &gvalue, otype );
 		g_value_set_flags( &gvalue, i );
 	}
 	else {
 		if( !value ) {
 			vips_object_no_value( object, name );
 			return( -1 );
 		}
 
 		g_value_init( &gvalue, G_TYPE_STRING );
 		g_value_set_string( &gvalue, value );
 	}
 
 	g_object_set_property( G_OBJECT( object ), name, &gvalue );
 	g_value_unset( &gvalue );
 
 	return( 0 );
 }
 
 /* Does an vipsargument need an argument to write to? For example, an image
  * output needs a filename, a double output just prints.
  */
@@ -2183,78 +2183,77 @@ int
 vips_object_get_argument_to_string( VipsObject *object, 
 	const char *name, const char *arg )
 {
 	GParamSpec *pspec;
 	GType otype;
 	VipsArgumentClass *argument_class;
 	VipsArgumentInstance *argument_instance;
 	VipsObjectClass *oclass;
 
 #ifdef DEBUG
 	printf( "vips_object_get_argument_to_string: %s -> %s\n", 
 		name, arg );
 #endif /*DEBUG*/
 
 	if( vips_object_get_argument( object, name,
 		&pspec, &argument_class, &argument_instance ) )
 		return( -1 );
 
 	otype = G_PARAM_SPEC_VALUE_TYPE( pspec );
 
 	g_assert( argument_class->flags & VIPS_ARGUMENT_OUTPUT );
 
 	if( g_type_is_a( otype, VIPS_TYPE_IMAGE ) ) { 
 		VipsImage *in;
 		char filename[VIPS_PATH_MAX];
 		char option_string[VIPS_PATH_MAX];
 
 		vips__filename_split8( arg, filename, option_string );
 
 		if( vips_isprefix( ".", filename ) ) {
-			VipsStreamOutput *output;
+			VipsStreamo *output;
 
-			if( !(output = 
-				vips_stream_output_new_from_descriptor( 1 )) )
+			if( !(output = vips_streamo_new_from_descriptor( 1 )) )
 				return( -1 );
 			g_object_get( object, name, &in, NULL );
 			if( vips_image_write_to_stream( in, 
 				arg, output, NULL ) ) {
 				VIPS_UNREF( in );
 				VIPS_UNREF( output );
 				return( -1 );
 			}
 			VIPS_UNREF( in );
 			VIPS_UNREF( output );
 		}
 		else {
 			/* Pull out the image and write it.
 			 */
 			g_object_get( object, name, &in, NULL );
 			if( vips_image_write_to_file( in, arg, NULL ) ) {
 				VIPS_UNREF( in );
 				return( -1 );
 			}
 			VIPS_UNREF( in );
 		}
 	}
 	else if( g_type_is_a( otype, VIPS_TYPE_OBJECT ) &&
 		(oclass = g_type_class_ref( otype )) &&
 		oclass->output_to_arg ) {
 		VipsObject *value;
 
 		g_object_get( object, name, &value, NULL );
 		if( oclass->output_to_arg( value, arg ) ) {
 			g_object_unref( value );
 			return( -1 );
 		}
 		g_object_unref( value );
 	}
 	else {
 		char str[1000];
 		VipsBuf buf = VIPS_BUF_STATIC( str );
 
 		vips_object_print_arg( object, pspec, &buf );
 		printf( "%s\n", vips_buf_all( &buf ) );
 	}
 
 	return( 0 );
 }
diff --git a/libvips/iofuncs/stream.c b/libvips/iofuncs/stream.c
index 2c589da13..3c847ba51 100644
--- a/libvips/iofuncs/stream.c
+++ b/libvips/iofuncs/stream.c
@@ -79,39 +79,32 @@
 
 G_DEFINE_ABSTRACT_TYPE( VipsStream, vips_stream, VIPS_TYPE_OBJECT );
 
-static void
-vips_stream_close( VipsStream *stream )
-{
-	VIPS_DEBUG_MSG( "vips_stream_close:\n" );
-
-	if( stream->close_descriptor >= 0 ) {
-		VIPS_DEBUG_MSG( "    close()\n" );
-		close( stream->close_descriptor );
-		stream->close_descriptor = -1;
-	}
-
-	if( stream->tracked_descriptor >= 0 ) {
-		VIPS_DEBUG_MSG( "    vips_tracked_close()\n" );
-		vips_tracked_close( stream->tracked_descriptor );
-		stream->tracked_descriptor = -1;
-	}
-
-	stream->descriptor = -1;
-}
-
 static void
 vips_stream_finalize( GObject *gobject )
 {
 	VipsStream *stream = (VipsStream *) gobject;
 
 #ifdef VIPS_DEBUG
 	VIPS_DEBUG_MSG( "vips_stream_finalize: " );
 	vips_object_print_name( VIPS_OBJECT( gobject ) );
 	VIPS_DEBUG_MSG( "\n" );
 #endif /*VIPS_DEBUG*/
 
-	vips_stream_close( stream );
+	if( stream->tracked_descriptor >= 0 ) {
+		VIPS_DEBUG_MSG( "    tracked_close()\n" );
+		vips_tracked_close( stream->tracked_descriptor );
+		stream->tracked_descriptor = -1;
+		stream->descriptor = -1;
+	}
+
+	if( stream->close_descriptor >= 0 ) {
+		VIPS_DEBUG_MSG( "    close()\n" );
+		close( stream->close_descriptor );
+		stream->close_descriptor = -1;
+		stream->descriptor = -1;
+	}
+
 	VIPS_FREE( stream->filename ); 
 
 	G_OBJECT_CLASS( vips_stream_parent_class )->finalize( gobject );
 }
@@ -153,6 +146,7 @@ const char *
 vips_stream_name( VipsStream *stream )
 {
 	return( stream->filename ?
 		stream->filename :
 		VIPS_OBJECT( stream )->nickname );
 }
+
diff --git a/libvips/iofuncs/streami.c b/libvips/iofuncs/streami.c
index 5cd8ef51d..235b4aaa6 100644
--- a/libvips/iofuncs/streami.c
+++ b/libvips/iofuncs/streami.c
@@ -1,95 +1,89 @@
 /* A byte source/sink .. it can be a pipe, file descriptor, memory area, 
  * socket, node.js stream, etc.
  * 
  * J.Cupitt, 19/6/14
  */
 
 /*
 
     This file is part of VIPS.
     
     VIPS is free software; you can redistribute it and/or modify
     it under the terms of the GNU Lesser General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
 
     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU Lesser General Public License for more details.
 
     You should have received a copy of the GNU Lesser General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
     02110-1301  USA
 
  */
 
 /*
 
     These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk
 
  */
 
 /* TODO
  *
  * - filename encoding
  * - are we detecting EOF correctly? what about interrupted reads? perhaps 
  *   we should check errno as well
- * - _size() needs to be a vfunc too (libtiff needs it)
- * - _miminize() is a vfunc, so _open() must be as well 
- *   + perhaps minimise should not be a vfunc? is it really useful for 
- *     subclasses? 
- *   + perhaps make _open() / _close() into vfuncs on stream (not streami) and 
- *     don't expose minimise
  * - need to be able to set is_pipe via constructor
  * - test we can really change all behaviour in the subclass ... add callbacks
  *   as well to make it simpler for language bindings
  */
 
 /*
  */
 #define VIPS_DEBUG
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif /*HAVE_CONFIG_H*/
 #include <vips/intl.h>
 
 #include <stdio.h>
 #include <stdlib.h>
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif /*HAVE_UNISTD_H*/
 #include <string.h>
 #include <errno.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <unistd.h>
 
 #include <vips/vips.h>
 #include <vips/internal.h>
 #include <vips/debug.h>
 
 /* Try to make an O_BINARY ... sometimes need the leading '_'.
  */
 #ifdef BINARY_OPEN
 #ifndef O_BINARY
 #ifdef _O_BINARY
 #define O_BINARY _O_BINARY
 #endif /*_O_BINARY*/
 #endif /*!O_BINARY*/
 #endif /*BINARY_OPEN*/
 
 /* If we have O_BINARY, add it to a mode flags set.
  */
 #ifdef O_BINARY
 #define BINARYIZE(M) ((M) | O_BINARY)
 #else /*!O_BINARY*/
 #define BINARYIZE(M) (M)
 #endif /*O_BINARY*/
 
 #define MODE_READ BINARYIZE (O_RDONLY)
 #define MODE_READWRITE BINARYIZE (O_RDWR)
 #define MODE_WRITE BINARYIZE (O_WRONLY | O_CREAT | O_TRUNC)
@@ -200,89 +194,52 @@ vips_streami_finalize( GObject *gobject )
 	G_OBJECT_CLASS( vips_streami_parent_class )->finalize( gobject );
 }
 
-static int
-vips_streami_open( VipsStreami *streami )
-{
-	VipsStream *stream = VIPS_STREAM( streami );
-
-	vips_streami_sanity( streami );
-
-	if( stream->descriptor == -1 &&
-		stream->tracked_descriptor == -1 &&
-		stream->filename ) {
-		int fd;
-
-		if( (fd = vips_tracked_open( stream->filename, 
-			MODE_READ )) == -1 ) {
-			vips_error_system( errno, vips_stream_name( stream ), 
-				"%s", _( "unable to open for read" ) ); 
-			return( -1 ); 
-		}
-
-		stream->tracked_descriptor = fd;
-		stream->descriptor = fd;
-
-		if( streami->length == -1 &&
-			(streami->length = vips_file_length( fd )) == -1 )
-			return( -1 );
-
-		VIPS_DEBUG_MSG( "vips_streami_open: "
-			"restoring read position %zd\n", 
-			streami->read_position );
-		if( vips__seek( stream->descriptor, 
-			streami->read_position, SEEK_SET ) == -1 )
-			return( -1 );
-	}
-
-	return( 0 );
-}
-
 static int
 vips_streami_build( VipsObject *object )
 {
 	VipsStream *stream = VIPS_STREAM( object );
 	VipsStreami *streami = VIPS_STREAMI( object );
 
 	VIPS_DEBUG_MSG( "vips_streami_build: %p\n", streami );
 
 	if( VIPS_OBJECT_CLASS( vips_streami_parent_class )->
 		build( object ) )
 		return( -1 );
 
 	if( vips_object_argument_isset( object, "filename" ) &&
 		vips_object_argument_isset( object, "descriptor" ) ) { 
 		vips_error( vips_stream_name( stream ), 
 			"%s", _( "don't set 'filename' and 'descriptor'" ) ); 
 		return( -1 ); 
 	}
 
 	if( vips_object_argument_isset( object, "filename" ) &&
-		vips_streami_open( streami ) )
+		vips_streami_unminimise( streami ) )
 		return( -1 );
 
 	if( vips_object_argument_isset( object, "descriptor" ) ) {
 		stream->descriptor = dup( stream->descriptor );
 		stream->close_descriptor = stream->descriptor;
 	}
 
 	/* If there's a descriptor for streami, test its properties.
 	 */
 	if( stream->descriptor != -1 ) {
 		/* Do +=0 on the current position. This fails for pipes, at
 		 * least on linux. 
 		 */
 		if( vips__seek( stream->descriptor, 0, SEEK_CUR ) != -1 )
 			streami->is_pipe = TRUE;
 	}
 
 	/* Need to save the header for pipe-style sources.
 	 */
 	if( streami->is_pipe )
 		streami->header_bytes = g_byte_array_new();
 
 	/* We always want a sniff buffer.
 	 */
 	streami->sniff = g_byte_array_new();
 
 	return( 0 );
 }
@@ -355,40 +312,162 @@ static void
 vips_streami_minimise_real( VipsStreami *streami )
 {
 	VipsStream *stream = VIPS_STREAM( streami );
 
 	VIPS_DEBUG_MSG( "vips_streami_minimise_real:\n" );
 
 	if( stream->filename &&
 		stream->descriptor != -1 &&
-		!streami->is_pipe ) 
-		vips_stream_close( stream );
+		stream->tracked_descriptor != -1 &&
+		!streami->is_pipe ) {
+		VIPS_DEBUG_MSG( "    tracked_close()\n" );
+		vips_tracked_close( stream->tracked_descriptor );
+		stream->tracked_descriptor = -1;
+		stream->descriptor = -1;
+	}
+}
+
+static int
+vips_streami_unminimise_real( VipsStreami *streami )
+{
+	VipsStream *stream = VIPS_STREAM( streami );
+
+	if( stream->descriptor == -1 &&
+		stream->tracked_descriptor == -1 &&
+		stream->filename ) {
+		int fd;
+
+		if( (fd = vips_tracked_open( stream->filename, 
+			MODE_READ )) == -1 ) 
+			return( -1 ); 
+
+		stream->tracked_descriptor = fd;
+		stream->descriptor = fd;
+
+		if( streami->length == -1 &&
+			(streami->length = vips_file_length( fd )) == -1 )
+			return( -1 );
+
+		VIPS_DEBUG_MSG( "vips_streami_unminimise_real: "
+			"restoring read position %zd\n", 
+			streami->read_position );
+		if( vips__seek( stream->descriptor, 
+			streami->read_position, SEEK_SET ) == -1 )
+			return( -1 );
+	}
+
+	return( 0 );
+}
+
+/* Read a pipe to at least a position. -1 means read to end of stream. Does
+ * not chenge read_position.
+ */
+static int
+vips_streami_pipe_read_to_position( VipsStreami *streami, gint64 target )
+{
+	gint64 old_read_position;
+	unsigned char buffer[4096];
+
+	VIPS_DEBUG_MSG( "vips_streami_pipe_read_position:\n" );
+
+	vips_streami_sanity( streami );
+
+	if( streami->decode ) {
+		vips_error( vips_stream_name( VIPS_STREAM( streami ) ),
+			"%s", _( "can't seek pipe after "
+				"pixel decode begins" ) );
+		return( -1 );
+	}
+
+	old_read_position = streami->read_position;
+
+	/* TODO ... add something to prevent unbounded streams filling memory.
+	 */
+	while( target == -1 ||
+		streami->read_position < target ) {
+		ssize_t read;
+
+		read = vips_streami_read( streami, buffer, 4096 );
+		if( read == -1 )
+			return( -1 );
+		if( read == 0 )
+			break;
+	}
+
+	streami->read_position = old_read_position;
+
+	vips_streami_sanity( streami );
+
+	return( 0 );
+}
+
+/* Read the entire pipe into memory and turn this into a memory source stream.
+ */
+static int
+vips_streami_pipe_to_memory( VipsStreami *streami )
+{
+	unsigned char *data;
+
+	VIPS_DEBUG_MSG( "vips_streami_pipe_to_memory:\n" );
+
+	vips_streami_sanity( streami );
+
+	if( vips_streami_pipe_read_to_position( streami, -1 ) )
+		return( -1 );
+
+	/* Move header_bytes into the memory blob and set up as a memory
+	 * source.
+	 */
+	streami->length = streami->header_bytes->len;
+	data = g_byte_array_free( streami->header_bytes, FALSE );
+	streami->header_bytes = NULL;
+	vips_blob_set( streami->blob,
+		(VipsCallbackFn) g_free, data, streami->length );
+	vips_streami_minimise( streami );
+	streami->is_pipe = FALSE;
+
+	vips_streami_sanity( streami );
+
+	return( 0 );
+}
+
+static gint64
+vips_streami_size_real( VipsStreami *streami )
+{
+	if( streami->length == -1 &&
+		streami->is_pipe &&
+		vips_streami_pipe_to_memory( streami ) )
+		return( -1 );
+
+	return( streami->length );
 }
 
 static void
 vips_streami_class_init( VipsStreamiClass *class )
 {
 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
 	VipsObjectClass *object_class = VIPS_OBJECT_CLASS( class );
 
 	gobject_class->finalize = vips_streami_finalize;
 	gobject_class->set_property = vips_object_set_property;
 	gobject_class->get_property = vips_object_get_property;
 
 	object_class->nickname = "streami";
 	object_class->description = _( "streami stream" );
 
 	object_class->build = vips_streami_build;
 
 	class->read = vips_streami_read_real;
 	class->map = vips_streami_map_real;
 	class->seek = vips_streami_seek_real;
 	class->minimise = vips_streami_minimise_real;
+	class->unminimise = vips_streami_unminimise_real;
+	class->size = vips_streami_size_real;
 
 	VIPS_ARG_BOXED( class, "blob", 3, 
 		_( "Blob" ),
 		_( "blob to load from" ),
 		VIPS_ARGUMENT_OPTIONAL_INPUT, 
 		G_STRUCT_OFFSET( VipsStreami, blob ),
 		VIPS_TYPE_BLOB );
 
 }
@@ -558,184 +637,118 @@ ssize_t
 vips_streami_read( VipsStreami *streami, void *buffer, size_t length )
 {
 	VipsStreamiClass *class = VIPS_STREAMI_GET_CLASS( streami );
 
 	ssize_t bytes_read;
 
 	VIPS_DEBUG_MSG( "vips_streami_read:\n" );
 
 	vips_streami_sanity( streami );
 
 	bytes_read = 0;
 
 	/* Are we serving from header_bytes? Get what we can from there.
 	 */
 	if( streami->header_bytes &&
 		streami->read_position < streami->header_bytes->len ) {
 		ssize_t available;
 
 		available = VIPS_MIN( length, 
 			streami->header_bytes->len - streami->read_position );
 		memcpy( buffer, 
 			streami->header_bytes->data + streami->read_position, 
 			available );
 		streami->read_position += available;
 		buffer += available;
 		length -= available;
 		bytes_read += available;
 
 		VIPS_DEBUG_MSG( "    %zd bytes from cache\n", available );
 	}
 
 	/* Any more bytes requested? Call the read() vfunc.
 	 */
 	if( length > 0 ) {
 		ssize_t n;
 
 		if( (n = class->read( streami, buffer, length )) == -1 ) {
 			vips_error_system( errno, 
 				vips_stream_name( VIPS_STREAM( streami ) ), 
 				"%s", _( "read error" ) ); 
 			return( -1 );
 		}
 
 		/* We need to save bytes if we're in header mode and we can't
 		 * seek or map.
 		 */
 		if( streami->header_bytes &&
 			streami->is_pipe &&
 			!streami->decode &&
 			n > 0 ) 
 			g_byte_array_append( streami->header_bytes, 
 				buffer, n );
 
 		streami->read_position += n;
 		bytes_read += n;
 
 		VIPS_DEBUG_MSG( "    %zd bytes from read()\n", n );
 	}
 
 	VIPS_DEBUG_MSG( "    %zd bytes total\n", bytes_read );
 
 	vips_streami_sanity( streami );
 
 	return( bytes_read );
 }
 
-/* Read a pipe to at least a position. -1 means read to end of stream. Does
- * not chenge read_position.
- */
-static int
-vips_streami_pipe_read_to_position( VipsStreami *streami, gint64 target )
-{
-	gint64 old_read_position;
-	unsigned char buffer[4096];
-	unsigned char *data;
-
-	VIPS_DEBUG_MSG( "vips_streami_pipe_read_position:\n" );
-
-	vips_streami_sanity( streami );
-
-	if( streami->decode ) {
-		vips_error( vips_stream_name( VIPS_STREAM( streami ) ),
-			"%s", _( "can't seek pipe after "
-				"pixel decode begins" ) );
-		return( -1 );
-	}
-
-	old_read_position = streami->read_position;
-
-	/* TODO ... add something to prevent unbounded streams filling memory.
-	 */
-	while( target == -1 ||
-		streami->read_position < target ) {
-		ssize_t read;
-
-		read = vips_streami_read( streami, buffer, 4096 );
-		if( read == -1 )
-			return( -1 );
-		if( read == 0 )
-			break;
-	}
-
-	streami->read_position = old_read_position;
-
-	vips_streami_sanity( streami );
-
-	return( 0 );
-}
-
-/* Read the entire pipe into memory and turn this into a memory source stream.
- */
-static int
-vips_streami_pipe_to_memory( VipsStreami *streami )
-{
-	unsigned char *data;
-
-	VIPS_DEBUG_MSG( "vips_streami_pipe_to_memory:\n" );
-
-	vips_streami_sanity( streami );
-
-	if( vips_streami_pipe_read_to_position( streami, -1 ) )
-		return( -1 );
-
-	/* Move header_bytes into the memory blob and set up as a memory
-	 * source.
-	 */
-	streami->length = streami->header_bytes->len;
-	data = g_byte_array_free( streami->header_bytes, FALSE );
-	streami->header_bytes = NULL;
-	vips_blob_set( streami->blob,
-		(VipsCallbackFn) g_free, data, streami->length );
-	vips_stream_close( stream );
-	streami->is_pipe = FALSE;
-
-	vips_streami_sanity( streami );
-
-	return( 0 );
-}
-
 const void *
 vips_streami_map( VipsStreami *streami, size_t *length_out )
 {
 	VipsStreamiClass *class = VIPS_STREAMI_GET_CLASS( streami );
 
-	void *data;
+	const void *data;
 	ssize_t length;
 
 	VIPS_DEBUG_MSG( "vips_streami_map:\n" );
 
 	vips_streami_sanity( streami );
 
 	/* Pipes need to be converted to memory streams.
 	 */
 	if( streami->is_pipe &&
 		vips_streami_pipe_to_memory( streami ) )
 		return( NULL );
 
 	/* Memory source ... easy!
 	 */
 	if( streami->blob ) {
-		VIPS_DEBUG_MSG( "    memory source\n" );
+		size_t unsigned_length;
 
-		data = vips_blob_get( streami->blob, &length );
+		/* Argh blobs are unsigned sizes.
+		 */
+		VIPS_DEBUG_MSG( "    memory source\n" );
+		data = vips_blob_get( streami->blob, &unsigned_length );
+		length = VIPS_MIN( unsigned_length, G_MAXSSIZE );
 	}
 	else {
+		size_t unsigned_length;
+
 		/* A streami that supports mmap.
 		 */
 		VIPS_DEBUG_MSG( "    mmaping source\n" );
 		if( !streami->baseaddr &&
 			!(streami->baseaddr = 
-				class->map( streami, &streami->length )) )
+				class->map( streami, &unsigned_length )) )
 			return( NULL );
 
-		length = streami->length;
+		length = VIPS_MIN( unsigned_length, G_MAXSSIZE );
+		streami->length = length;
 		data = streami->baseaddr;
 	}
 
 	if( length_out )
 		*length_out = length;
 
 	vips_streami_sanity( streami );
 
 	return( data );
 }
@@ -828,36 +841,68 @@ vips_streami_minimise( VipsStreami *streami )
 	vips_streami_sanity( streami );
 }
 
+int
+vips_streami_unminimise( VipsStreami *streami )
+{
+	int result;
+
+	VipsStreamiClass *class = VIPS_STREAMI_GET_CLASS( streami );
+
+	vips_streami_sanity( streami );
+
+	result = class->unminimise( streami );
+
+	vips_streami_sanity( streami );
+
+	return( result );
+}
+
+gint64
+vips_streami_size( VipsStreami *streami )
+{
+	VipsStreamiClass *class = VIPS_STREAMI_GET_CLASS( streami );
+
+	gint64 size;
+
+	vips_streami_sanity( streami );
+
+	size = class->size( streami );
+
+	vips_streami_sanity( streami );
+
+	return( size );
+}
+
 int 
 vips_streami_decode( VipsStreami *streami )
 {
 	VIPS_DEBUG_MSG( "vips_streami_decode:\n" );
 
 	vips_streami_sanity( streami );
 
 	/* We have finished reading the header. We can discard the bytes we
 	 * saved.
 	 */
 	if( !streami->decode ) {
 		streami->decode = TRUE;
 		VIPS_FREEF( g_byte_array_unref, streami->header_bytes ); 
 		VIPS_FREEF( g_byte_array_unref, streami->sniff ); 
 	}
 
 	/* Make sure we are open, in case we've been minimised.
 	 */
-	if( vips_streami_open( streami ) )
+	if( vips_streami_unminimise( streami ) )
 		return( -1 );
 
 	vips_streami_sanity( streami );
 
 	return( 0 );
 }
 
 /**
  * vips_streami_sniff: 
  * @streami: sniff this stream
  * @length: number of bytes to sniff
  *
  * Return a pointer to the first few bytes of the file.
  */
@@ -865,42 +910,23 @@ unsigned char *
 vips_streami_sniff( VipsStreami *streami, size_t length )
 {
 	ssize_t n;
 	unsigned char *q;
 
 	VIPS_DEBUG_MSG( "vips_streami_sniff: %zd bytes\n", length );
 
 	vips_streami_sanity( streami );
 
 	if( vips_streami_rewind( streami ) )
 		return( NULL );
 
 	g_byte_array_set_size( streami->sniff, length );
 
 	for( q = streami->sniff->data; length > 0; length -= n, q += n )
 		if( (n = vips_streami_read( streami, q, length )) == -1 ||
 			n == 0 )
 			return( NULL );
 
 	vips_streami_sanity( streami );
 
 	return( streami->sniff->data );
 }
-
-gint64
-vips_streami_size( VipsStreami *streami )
-{
-	VipsStream *stream = VIPS_STREAM( streami );
-
-	gint64 size;
-
-	vips_streami_sanity( streami );
-
-	if( streami->length == -1 &&
-		streami->is_pipe &&
-		vips_streami_pipe_to_memory( streami ) )
-		return( -1 );
-
-	vips_streami_sanity( streami );
-
-	return( streami->length );
-}
diff --git a/libvips/iofuncs/streamo.c b/libvips/iofuncs/streamo.c
index a6a685492..d1c7f7356 100644
--- a/libvips/iofuncs/streamo.c
+++ b/libvips/iofuncs/streamo.c
@@ -316,28 +316,28 @@ vips_streamo_new_memory( void )
 int
 vips_streamo_write( VipsStreamo *streamo, const void *data, size_t length )
 {
-	VipsStreamoClass *class = VIPS_STREAMO_GET_CLASS( stream );
+	VipsStreamoClass *class = VIPS_STREAMO_GET_CLASS( streamo );
 
 	VIPS_DEBUG_MSG( "vips_streamo_write: %zd bytes\n", length );
 
 	while( length > 0 ) { 
 		ssize_t n;
 
 		n = class->write( streamo, data, length );
 
 		/* n == 0 isn't strictly an error, but we treat it as one to
 		 * make sure we don't get stuck in this loop.
 		 */
 		if( n <= 0 ) {
 			vips_error_system( errno, 
 				vips_stream_name( VIPS_STREAM( streamo ) ),
 				"%s", _( "write error" ) ); 
 			return( -1 ); 
 		}
 
 		length -= n;
 		data += n;
 	}
 
 	return( 0 );
 }
