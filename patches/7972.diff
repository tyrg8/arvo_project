commit 3b2ed44d6a5d1c33a8add4ccf5cc2deb46cf50cd
Author: Cristy <urban-warrior@imagemagick.org>
Date:   Thu May 3 08:10:59 2018 -0400

    Remove artifact when drawing certain paths

diff --git a/MagickCore/draw.c b/MagickCore/draw.c
index d76af91d2..2ca6605eb 100644
--- a/MagickCore/draw.c
+++ b/MagickCore/draw.c
@@ -175,7 +175,7 @@ static MagickBooleanType
     ExceptionInfo *);
 
 static PrimitiveInfo
-  *TraceStrokePolygon(const DrawInfo *,const PrimitiveInfo *);
+  *TraceStrokePolygon(const Image *,const DrawInfo *,const PrimitiveInfo *);
 
 static size_t
   TracePath(PrimitiveInfo *,const char *,ExceptionInfo *);
@@ -719,117 +719,123 @@ static void LogPathInfo(const PathInfo *path_info)
 
 static PathInfo *ConvertPrimitiveToPath(const PrimitiveInfo *primitive_info)
 {
+  MagickBooleanType
+    closed_subpath;
+
   PathInfo
     *path_info;
 
   PathInfoCode
     code;
 
   PointInfo
     p,
     q;
 
   register ssize_t
     i,
     n;
 
   ssize_t
     coordinates,
     start;
 
   /*
     Converts a PrimitiveInfo structure into a vector path structure.
   */
   switch (primitive_info->primitive)
   {
     case AlphaPrimitive:
     case ColorPrimitive:
     case ImagePrimitive:
     case PointPrimitive:
     case TextPrimitive:
       return((PathInfo *) NULL);
     default:
       break;
   }
   for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++) ;
   path_info=(PathInfo *) AcquireQuantumMemory((size_t) (2UL*i+4UL),
     sizeof(*path_info));
   if (path_info == (PathInfo *) NULL)
     return((PathInfo *) NULL);
   coordinates=0;
   n=0;
   p.x=(-1.0);
   p.y=(-1.0);
   q.x=(-1.0);
   q.y=(-1.0);
   start=0;
   for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++)
   {
     code=LineToCode;
     if (coordinates <= 0)
       {
         coordinates=(ssize_t) primitive_info[i].coordinates;
         p=primitive_info[i].point;
         start=n;
         code=MoveToCode;
+        closed_subpath=primitive_info[i].closed_subpath;
       }
     coordinates--;
-    /*
-      Eliminate duplicate points.
-    */
-    if ((code == MoveToCode) ||
+    if ((code == MoveToCode) || (coordinates <= 0) ||
         (fabs(q.x-primitive_info[i].point.x) >= DrawEpsilon) ||
         (fabs(q.y-primitive_info[i].point.y) >= DrawEpsilon))
       {
+        /*
+          Eliminate duplicate points.
+        */
         path_info[n].code=code;
         path_info[n].point=primitive_info[i].point;
         q=primitive_info[i].point;
         n++;
       }
     if (coordinates > 0)
       continue;
-    if ((fabs(p.x-primitive_info[i].point.x) < DrawEpsilon) &&
-        (fabs(p.y-primitive_info[i].point.y) < DrawEpsilon))
-      continue;
+    if (closed_subpath != MagickFalse)
+      {
+        closed_subpath=MagickFalse;
+        continue;
+      }
     /*
-      Mark the p point as open if it does not match the q.
+      Mark the p point as open if the subpath is not closed.
     */
     path_info[start].code=OpenCode;
     path_info[n].code=GhostlineCode;
     path_info[n].point=primitive_info[i].point;
     n++;
     path_info[n].code=LineToCode;
     path_info[n].point=p;
     n++;
   }
   path_info[n].code=EndCode;
   path_info[n].point.x=0.0;
   path_info[n].point.y=0.0;
   if (IsEventLogging() != MagickFalse)
     LogPathInfo(path_info);
   return(path_info);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   D e s t r o y D r a w I n f o                                             %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  DestroyDrawInfo() deallocates memory associated with an DrawInfo
 %  structure.
 %
 %  The format of the DestroyDrawInfo method is:
 %
 %      DrawInfo *DestroyDrawInfo(DrawInfo *draw_info)
 %
 %  A description of each parameter follows:
 %
 %    o draw_info: the draw info.
 %
 */
@@ -1202,207 +1208,216 @@ MagickExport MagickBooleanType DrawAffineImage(Image *image,
     inverse_edge=AffineEdge(source,&inverse_affine,(double) y,&edge);
     if (inverse_edge.x2 < inverse_edge.x1)
       continue;
     q=GetCacheViewAuthenticPixels(image_view,(ssize_t) ceil(inverse_edge.x1-
       0.5),y,(size_t) (floor(inverse_edge.x2+0.5)-ceil(inverse_edge.x1-0.5)+1),
       1,exception);
     if (q == (Quantum *) NULL)
       continue;
     pixel=zero;
     composite=zero;
     x_offset=0;
     for (x=(ssize_t) ceil(inverse_edge.x1-0.5); x <= (ssize_t) floor(inverse_edge.x2+0.5); x++)
     {
       point.x=(double) x*inverse_affine.sx+y*inverse_affine.ry+
         inverse_affine.tx;
       point.y=(double) x*inverse_affine.rx+y*inverse_affine.sy+
         inverse_affine.ty;
       status=InterpolatePixelInfo(source,source_view,UndefinedInterpolatePixel,
         point.x,point.y,&pixel,exception);
       if (status == MagickFalse)
         break;
       GetPixelInfoPixel(image,q,&composite);
       CompositePixelInfoOver(&pixel,pixel.alpha,&composite,composite.alpha,
         &composite);
       SetPixelViaPixelInfo(image,&composite,q);
       x_offset++;
       q+=GetPixelChannels(image);
     }
     if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)
       status=MagickFalse;
   }
   source_view=DestroyCacheView(source_view);
   image_view=DestroyCacheView(image_view);
   return(status);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 +   D r a w B o u n d i n g R e c t a n g l e s                               %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  DrawBoundingRectangles() draws the bounding rectangles on the image.  This
 %  is only useful for developers debugging the rendering algorithm.
 %
 %  The format of the DrawBoundingRectangles method is:
 %
 %      void DrawBoundingRectangles(Image *image,const DrawInfo *draw_info,
 %        PolygonInfo *polygon_info,ExceptionInfo *exception)
 %
 %  A description of each parameter follows:
 %
 %    o image: the image.
 %
 %    o draw_info: the draw info.
 %
 %    o polygon_info: Specifies a pointer to a PolygonInfo structure.
 %
 %    o exception: return any errors or warnings in this structure.
 %
 */
+
+static inline double SaneStrokeWidth(const Image *image,
+  const DrawInfo *draw_info)
+{
+  return((double) MagickMin(draw_info->stroke_width,
+    (2.0*sqrt(2.0)+DrawEpsilon)*MagickMax(image->columns,image->rows)));
+}
+
 static void DrawBoundingRectangles(Image *image,const DrawInfo *draw_info,
   const PolygonInfo *polygon_info,ExceptionInfo *exception)
 {
   DrawInfo
     *clone_info;
 
   double
     mid;
 
   PointInfo
     end,
     resolution,
     start;
 
   PrimitiveInfo
     primitive_info[6];
 
   register ssize_t
     i;
 
   SegmentInfo
     bounds;
 
   ssize_t
     coordinates;
 
+  (void) memset(primitive_info,0,sizeof(primitive_info));
   clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
   (void) QueryColorCompliance("#000F",AllCompliance,&clone_info->fill,
     exception);
   resolution.x=96.0;
   resolution.y=96.0;
   if (clone_info->density != (char *) NULL)
     {
       GeometryInfo
         geometry_info;
 
       MagickStatusType
         flags;
 
       flags=ParseGeometry(clone_info->density,&geometry_info);
       resolution.x=geometry_info.rho;
       resolution.y=geometry_info.sigma;
       if ((flags & SigmaValue) == MagickFalse)
         resolution.y=resolution.x;
     }
   mid=(resolution.x/96.0)*ExpandAffine(&clone_info->affine)*
-    clone_info->stroke_width/2.0;
+    SaneStrokeWidth(image,clone_info)/2.0;
   bounds.x1=0.0;
   bounds.y1=0.0;
   bounds.x2=0.0;
   bounds.y2=0.0;
   if (polygon_info != (PolygonInfo *) NULL)
     {
       bounds=polygon_info->edges[0].bounds;
       for (i=1; i < (ssize_t) polygon_info->number_edges; i++)
       {
         if (polygon_info->edges[i].bounds.x1 < (double) bounds.x1)
           bounds.x1=polygon_info->edges[i].bounds.x1;
         if (polygon_info->edges[i].bounds.y1 < (double) bounds.y1)
           bounds.y1=polygon_info->edges[i].bounds.y1;
         if (polygon_info->edges[i].bounds.x2 > (double) bounds.x2)
           bounds.x2=polygon_info->edges[i].bounds.x2;
         if (polygon_info->edges[i].bounds.y2 > (double) bounds.y2)
           bounds.y2=polygon_info->edges[i].bounds.y2;
       }
       bounds.x1-=mid;
       bounds.x1=bounds.x1 < 0.0 ? 0.0 : bounds.x1 >= (double)
         image->columns ? (double) image->columns-1 : bounds.x1;
       bounds.y1-=mid;
       bounds.y1=bounds.y1 < 0.0 ? 0.0 : bounds.y1 >= (double)
         image->rows ? (double) image->rows-1 : bounds.y1;
       bounds.x2+=mid;
       bounds.x2=bounds.x2 < 0.0 ? 0.0 : bounds.x2 >= (double)
         image->columns ? (double) image->columns-1 : bounds.x2;
       bounds.y2+=mid;
       bounds.y2=bounds.y2 < 0.0 ? 0.0 : bounds.y2 >= (double)
         image->rows ? (double) image->rows-1 : bounds.y2;
       for (i=0; i < (ssize_t) polygon_info->number_edges; i++)
       {
         if (polygon_info->edges[i].direction != 0)
           (void) QueryColorCompliance("red",AllCompliance,&clone_info->stroke,
             exception);
         else
           (void) QueryColorCompliance("green",AllCompliance,&clone_info->stroke,
             exception);
         start.x=(double) (polygon_info->edges[i].bounds.x1-mid);
         start.y=(double) (polygon_info->edges[i].bounds.y1-mid);
         end.x=(double) (polygon_info->edges[i].bounds.x2+mid);
         end.y=(double) (polygon_info->edges[i].bounds.y2+mid);
         primitive_info[0].primitive=RectanglePrimitive;
         TraceRectangle(primitive_info,start,end);
         primitive_info[0].method=ReplaceMethod;
         coordinates=(ssize_t) primitive_info[0].coordinates;
         primitive_info[coordinates].primitive=UndefinedPrimitive;
         (void) DrawPrimitive(image,clone_info,primitive_info,exception);
       }
     }
   (void) QueryColorCompliance("blue",AllCompliance,&clone_info->stroke,
     exception);
   start.x=(double) (bounds.x1-mid);
   start.y=(double) (bounds.y1-mid);
   end.x=(double) (bounds.x2+mid);
   end.y=(double) (bounds.y2+mid);
   primitive_info[0].primitive=RectanglePrimitive;
   TraceRectangle(primitive_info,start,end);
   primitive_info[0].method=ReplaceMethod;
   coordinates=(ssize_t) primitive_info[0].coordinates;
   primitive_info[coordinates].primitive=UndefinedPrimitive;
   (void) DrawPrimitive(image,clone_info,primitive_info,exception);
   clone_info=DestroyDrawInfo(clone_info);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   D r a w C l i p P a t h                                                   %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  DrawClipPath() draws the clip path on the image mask.
 %
 %  The format of the DrawClipPath method is:
 %
 %      MagickBooleanType DrawClipPath(Image *image,const DrawInfo *draw_info,
 %        const char *clip_path,ExceptionInfo *exception)
 %
 %  A description of each parameter follows:
 %
 %    o image: the image.
 %
 %    o draw_info: the draw info.
 %
 %    o clip_path: the clip path.
 %
 %    o exception: return any errors or warnings in this structure.
 %
 */
@@ -1811,27 +1826,27 @@ static inline MagickBooleanType IsPoint(const char *point)
 static size_t ReckonEllipseCoordinates(const PointInfo radii,
   const PointInfo arc)
 {
   double
     delta,
     step,
     y;
 
   PointInfo
     angle;
 
   /*
     Ellipses are just short segmented polys.
   */
-  if ((fabs(radii.x) < MagickEpsilon) || (fabs(radii.y) < MagickEpsilon))
+  if ((fabs(radii.x) < DrawEpsilon) || (fabs(radii.y) < DrawEpsilon))
     return(0);
   delta=2.0*PerceptibleReciprocal(MagickMax(radii.x,radii.y));
   step=MagickPI/8.0;
   if ((delta >= 0.0) && (delta < (MagickPI/8.0)))
     step=MagickPI/(4.0*(MagickPI*PerceptibleReciprocal(delta)/2.0));
   angle.x=DegreesToRadians(arc.x);
   y=arc.y;
   while (y < arc.x)
     y+=360.0;
   angle.y=DegreesToRadians(y);
   return((size_t) floor((angle.y-angle.x)/step+0.5)+3);
 }
@@ -1873,1807 +1888,1817 @@ static size_t ReckonRoundRectangleCoordinates(const PointInfo start,
 static inline void TracePoint(PrimitiveInfo *primitive_info,
   const PointInfo point)
 {
   primitive_info->coordinates=1;
+  primitive_info->closed_subpath=MagickFalse;
   primitive_info->point=point;
 }
 
 MagickExport MagickBooleanType DrawImage(Image *image,const DrawInfo *draw_info,
   ExceptionInfo *exception)
 {
 #define RenderImageTag  "Render/Image"
 
   AffineMatrix
     affine,
     current;
 
   char
     keyword[MagickPathExtent],
     geometry[MagickPathExtent],
     *next_token,
     pattern[MagickPathExtent],
     *primitive,
     *token;
 
   const char
     *q;
 
   double
     angle,
     factor,
     primitive_extent;
 
   DrawInfo
     **graphic_context;
 
   MagickBooleanType
     proceed;
 
   MagickSizeType
     number_points;
 
   MagickStatusType
     status;
 
   PointInfo
     point;
 
   PrimitiveInfo
     *primitive_info;
 
   PrimitiveType
     primitive_type;
 
   register const char
     *p;
 
   register ssize_t
     i,
     x;
 
   SegmentInfo
     bounds;
 
   size_t
     coordinates,
     extent,
     number_stops;
 
   ssize_t
     defsDepth,
     j,
     k,
     n,
     symbolDepth;
 
   StopInfo
     *stops;
 
   assert(image != (Image *) NULL);
   assert(image->signature == MagickCoreSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
   assert(draw_info != (DrawInfo *) NULL);
   assert(draw_info->signature == MagickCoreSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"...");
   if ((draw_info->primitive == (char *) NULL) ||
       (*draw_info->primitive == '\0'))
     return(MagickFalse);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(DrawEvent,GetMagickModule(),"begin draw-image");
   primitive=(char *) NULL;
   if (*draw_info->primitive != '@')
     primitive=AcquireString(draw_info->primitive);
   else
     if ((strlen(draw_info->primitive) > 1) &&
         (*(draw_info->primitive+1) != '-'))
       primitive=FileToString(draw_info->primitive+1,~0UL,exception);
   if (primitive == (char *) NULL)
     return(MagickFalse);
   primitive_extent=(double) strlen(primitive);
   (void) SetImageArtifact(image,"MVG",primitive);
   n=0;
   number_stops=0;
   stops=(StopInfo *) NULL;
   /*
     Allocate primitive info memory.
   */
   graphic_context=(DrawInfo **) AcquireMagickMemory(sizeof(*graphic_context));
   if (graphic_context == (DrawInfo **) NULL)
     {
       primitive=DestroyString(primitive);
       ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
         image->filename);
     }
   number_points=65536;
   primitive_info=(PrimitiveInfo *) AcquireQuantumMemory((size_t) number_points,
     sizeof(*primitive_info));
   if (primitive_info == (PrimitiveInfo *) NULL)
     {
       primitive=DestroyString(primitive);
       for ( ; n >= 0; n--)
         graphic_context[n]=DestroyDrawInfo(graphic_context[n]);
       graphic_context=(DrawInfo **) RelinquishMagickMemory(graphic_context);
       ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
         image->filename);
     }
   (void) memset(primitive_info,0,(size_t) number_points*
     sizeof(*primitive_info));
   graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,draw_info);
   graphic_context[n]->viewbox=image->page;
   if ((image->page.width == 0) || (image->page.height == 0))
     {
       graphic_context[n]->viewbox.width=image->columns;
       graphic_context[n]->viewbox.height=image->rows;
     }
   token=AcquireString(primitive);
   extent=strlen(token)+MagickPathExtent;
   if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)
     return(MagickFalse);
   defsDepth=0;
   symbolDepth=0;
   status=MagickTrue;
   for (q=primitive; *q != '\0'; )
   {
     /*
       Interpret graphic primitive.
     */
     GetNextToken(q,&q,MagickPathExtent,keyword);
     if (*keyword == '\0')
       break;
     if (*keyword == '#')
       {
         /*
           Comment.
         */
         while ((*q != '\n') && (*q != '\0'))
           q++;
         continue;
       }
     p=q-strlen(keyword)-1;
     primitive_type=UndefinedPrimitive;
     current=graphic_context[n]->affine;
     GetAffineMatrix(&affine);
     switch (*keyword)
     {
       case ';':
         break;
       case 'a':
       case 'A':
       {
         if (LocaleCompare("affine",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             affine.sx=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             affine.rx=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             affine.ry=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             affine.sy=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             affine.tx=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             affine.ty=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             break;
           }
         if (LocaleCompare("alpha",keyword) == 0)
           {
             primitive_type=AlphaPrimitive;
             break;
           }
         if (LocaleCompare("arc",keyword) == 0)
           {
             primitive_type=ArcPrimitive;
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'b':
       case 'B':
       {
         if (LocaleCompare("bezier",keyword) == 0)
           {
             primitive_type=BezierPrimitive;
             break;
           }
         if (LocaleCompare("border-color",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             status&=QueryColorCompliance(token,AllCompliance,
               &graphic_context[n]->border_color,exception);
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'c':
       case 'C':
       {
         if (LocaleCompare("clip-path",keyword) == 0)
           {
             char
               *clip_path;
 
             /*
               Take a node from within the MVG document, and duplicate it here.
             */
             GetNextToken(q,&q,extent,token);
             clip_path=GetNodeByURL(primitive,token);
             if (clip_path != (char *) NULL)
               {
                 if (graphic_context[n]->clipping_mask != (Image *) NULL)
                   graphic_context[n]->clipping_mask=
                     DestroyImage(graphic_context[n]->clipping_mask);
                 graphic_context[n]->clipping_mask=DrawClippingMask(image,
                   graphic_context[n],clip_path,exception);
                 clip_path=DestroyString(clip_path);
                 if (draw_info->compliance != SVGCompliance)
                   status=SetImageMask(image,WritePixelMask,
                     graphic_context[n]->clipping_mask,exception);
               }
             break;
           }
         if (LocaleCompare("clip-rule",keyword) == 0)
           {
             ssize_t
               fill_rule;
 
             GetNextToken(q,&q,extent,token);
             fill_rule=ParseCommandOption(MagickFillRuleOptions,MagickFalse,
               token);
             if (fill_rule == -1)
               status=MagickFalse;
             else
               graphic_context[n]->fill_rule=(FillRule) fill_rule;
             break;
           }
         if (LocaleCompare("clip-units",keyword) == 0)
           {
             ssize_t
               clip_units;
 
             GetNextToken(q,&q,extent,token);
             clip_units=ParseCommandOption(MagickClipPathOptions,MagickFalse,
               token);
             if (clip_units == -1)
               {
                 status=MagickFalse;
                 break;
               }
             graphic_context[n]->clip_units=(ClipPathUnits) clip_units;
             if (clip_units == ObjectBoundingBox)
               {
                 GetAffineMatrix(&current);
                 affine.sx=draw_info->bounds.x2;
                 affine.sy=draw_info->bounds.y2;
                 affine.tx=draw_info->bounds.x1;
                 affine.ty=draw_info->bounds.y1;
                 break;
               }
             break;
           }
         if (LocaleCompare("circle",keyword) == 0)
           {
             primitive_type=CirclePrimitive;
             break;
           }
         if (LocaleCompare("color",keyword) == 0)
           {
             primitive_type=ColorPrimitive;
             break;
           }
         if (LocaleCompare("compliance",keyword) == 0)
           {
             /*
               MVG compliance associates a clipping mask with an image; SVG
               compliance associates a clipping mask with a graphics context.
             */
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->compliance=(ComplianceType) ParseCommandOption(
               MagickComplianceOptions,MagickFalse,token);
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'd':
       case 'D':
       {
         if (LocaleCompare("decorate",keyword) == 0)
           {
             ssize_t
               decorate;
 
             GetNextToken(q,&q,extent,token);
             decorate=ParseCommandOption(MagickDecorateOptions,MagickFalse,
               token);
             if (decorate == -1)
               status=MagickFalse;
             else
               graphic_context[n]->decorate=(DecorationType) decorate;
             break;
           }
         if (LocaleCompare("density",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             (void) CloneString(&graphic_context[n]->density,token);
             break;
           }
         if (LocaleCompare("direction",keyword) == 0)
           {
             ssize_t
               direction;
 
             GetNextToken(q,&q,extent,token);
             direction=ParseCommandOption(MagickDirectionOptions,MagickFalse,
               token);
             if (direction == -1)
               status=MagickFalse;
             else
               graphic_context[n]->direction=(DirectionType) direction;
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'e':
       case 'E':
       {
         if (LocaleCompare("ellipse",keyword) == 0)
           {
             primitive_type=EllipsePrimitive;
             break;
           }
         if (LocaleCompare("encoding",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             (void) CloneString(&graphic_context[n]->encoding,token);
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'f':
       case 'F':
       {
         if (LocaleCompare("fill",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             if (graphic_context[n]->clip_path != MagickFalse)
               break;
             (void) FormatLocaleString(pattern,MagickPathExtent,"%s",token);
             if (GetImageArtifact(image,pattern) != (const char *) NULL)
               (void) DrawPatternPath(image,draw_info,token,
                 &graphic_context[n]->fill_pattern,exception);
             else
               {
                 status&=QueryColorCompliance(token,AllCompliance,
                   &graphic_context[n]->fill,exception);
                 if (graphic_context[n]->fill_alpha != OpaqueAlpha)
                   graphic_context[n]->fill.alpha=graphic_context[n]->fill_alpha;
               }
             break;
           }
         if (LocaleCompare("fill-opacity",keyword) == 0)
           {
             double
               opacity;
 
             GetNextToken(q,&q,extent,token);
             if (graphic_context[n]->clip_path != MagickFalse)
               break;
             factor=strchr(token,'%') != (char *) NULL ? 0.01 : 1.0;
             opacity=MagickMin(MagickMax(factor*
               StringToDouble(token,&next_token),0.0),1.0);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             graphic_context[n]->fill_alpha=(MagickRealType) (QuantumRange-
               QuantumRange*(1.0-opacity));
             break;
           }
         if (LocaleCompare("fill-rule",keyword) == 0)
           {
             ssize_t
               fill_rule;
 
             GetNextToken(q,&q,extent,token);
             fill_rule=ParseCommandOption(MagickFillRuleOptions,MagickFalse,
               token);
             if (fill_rule == -1)
               status=MagickFalse;
             else
               graphic_context[n]->fill_rule=(FillRule) fill_rule;
             break;
           }
         if (LocaleCompare("font",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             (void) CloneString(&graphic_context[n]->font,token);
             if (LocaleCompare("none",token) == 0)
               graphic_context[n]->font=(char *) RelinquishMagickMemory(
                 graphic_context[n]->font);
             break;
           }
         if (LocaleCompare("font-family",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             (void) CloneString(&graphic_context[n]->family,token);
             break;
           }
         if (LocaleCompare("font-size",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->pointsize=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             break;
           }
         if (LocaleCompare("font-stretch",keyword) == 0)
           {
             ssize_t
               stretch;
 
             GetNextToken(q,&q,extent,token);
             stretch=ParseCommandOption(MagickStretchOptions,MagickFalse,token);
             if (stretch == -1)
               status=MagickFalse;
             else
               graphic_context[n]->stretch=(StretchType) stretch;
             break;
           }
         if (LocaleCompare("font-style",keyword) == 0)
           {
             ssize_t
               style;
 
             GetNextToken(q,&q,extent,token);
             style=ParseCommandOption(MagickStyleOptions,MagickFalse,token);
             if (style == -1)
               status=MagickFalse;
             else
               graphic_context[n]->style=(StyleType) style;
             break;
           }
         if (LocaleCompare("font-weight",keyword) == 0)
           {
             ssize_t
               weight;
 
             GetNextToken(q,&q,extent,token);
             weight=ParseCommandOption(MagickWeightOptions,MagickFalse,token);
             if (weight == -1)
               weight=(ssize_t) StringToUnsignedLong(token);
             graphic_context[n]->weight=(size_t) weight;
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'g':
       case 'G':
       {
         if (LocaleCompare("gradient-units",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             break;
           }
         if (LocaleCompare("gravity",keyword) == 0)
           {
             ssize_t
               gravity;
 
             GetNextToken(q,&q,extent,token);
             gravity=ParseCommandOption(MagickGravityOptions,MagickFalse,token);
             if (gravity == -1)
               status=MagickFalse;
             else
               graphic_context[n]->gravity=(GravityType) gravity;
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'i':
       case 'I':
       {
         if (LocaleCompare("image",keyword) == 0)
           {
             ssize_t
               compose;
 
             primitive_type=ImagePrimitive;
             GetNextToken(q,&q,extent,token);
             compose=ParseCommandOption(MagickComposeOptions,MagickFalse,token);
             if (compose == -1)
               status=MagickFalse;
             else
               graphic_context[n]->compose=(CompositeOperator) compose;
             break;
           }
         if (LocaleCompare("interline-spacing",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->interline_spacing=StringToDouble(token,
               &next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             break;
           }
         if (LocaleCompare("interword-spacing",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->interword_spacing=StringToDouble(token,
               &next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'k':
       case 'K':
       {
         if (LocaleCompare("kerning",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->kerning=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'l':
       case 'L':
       {
         if (LocaleCompare("line",keyword) == 0)
           primitive_type=LinePrimitive;
         else
           status=MagickFalse;
         break;
       }
       case 'm':
       case 'M':
       {
         if (LocaleCompare("mask",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             break;
           }
         break;
       }
       case 'o':
       case 'O':
       {
         if (LocaleCompare("offset",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             break;
           }
         if (LocaleCompare("opacity",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             if (graphic_context[n]->clip_path != MagickFalse)
               break;
             factor=strchr(token,'%') != (char *) NULL ? 0.01 : 1.0;
             graphic_context[n]->alpha=(Quantum) (QuantumRange*(1.0-
               (QuantumScale*graphic_context[n]->alpha*(1.0-factor*
               StringToDouble(token,&next_token)))));
             graphic_context[n]->fill_alpha=QuantumRange*(1.0-(QuantumScale*
               graphic_context[n]->fill_alpha*(1.0-factor*StringToDouble(token,
               &next_token))));
             graphic_context[n]->stroke_alpha=QuantumRange*(1.0-(QuantumScale*
               graphic_context[n]->stroke_alpha*(1.0-factor*StringToDouble(token,
               &next_token))));
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'p':
       case 'P':
       {
         if (LocaleCompare("path",keyword) == 0)
           {
             primitive_type=PathPrimitive;
             break;
           }
         if (LocaleCompare("point",keyword) == 0)
           {
             primitive_type=PointPrimitive;
             break;
           }
         if (LocaleCompare("polyline",keyword) == 0)
           {
             primitive_type=PolylinePrimitive;
             break;
           }
         if (LocaleCompare("polygon",keyword) == 0)
           {
             primitive_type=PolygonPrimitive;
             break;
           }
         if (LocaleCompare("pop",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             if (LocaleCompare("clip-path",token) == 0)
               break;
             if (LocaleCompare("defs",token) == 0)
               {
                 defsDepth--;
                 graphic_context[n]->render=defsDepth > 0 ? MagickFalse :
                   MagickTrue;
                 break;
               }
             if (LocaleCompare("gradient",token) == 0)
               break;
             if (LocaleCompare("graphic-context",token) == 0)
               {
                 if (n <= 0)
                   {
                     (void) ThrowMagickException(exception,GetMagickModule(),
                       DrawError,"UnbalancedGraphicContextPushPop","`%s'",token);
                     status=MagickFalse;
                     n=0;
                     break;
                   }
                 graphic_context[n]=DestroyDrawInfo(graphic_context[n]);
                 n--;
                 break;
               }
             if (LocaleCompare("mask",token) == 0)
               break;
             if (LocaleCompare("pattern",token) == 0)
               break;
             if (LocaleCompare("symbol",token) == 0)
               {
                 symbolDepth--;
                 graphic_context[n]->render=symbolDepth > 0 ? MagickFalse :
                   MagickTrue;
                 break;
               }
             status=MagickFalse;
             break;
           }
         if (LocaleCompare("push",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             if (LocaleCompare("clip-path",token) == 0)
               {
                 GetNextToken(q,&q,extent,token);
                 break;
               }
             if (LocaleCompare("defs",token) == 0)
               {
                 defsDepth++;
                 graphic_context[n]->render=defsDepth > 0 ? MagickFalse :
                   MagickTrue;
                 break;
               }
             if (LocaleCompare("gradient",token) == 0)
               {
                 char
                   key[2*MagickPathExtent],
                   name[MagickPathExtent],
                   type[MagickPathExtent];
 
                 SegmentInfo
                   segment;
 
                 GetNextToken(q,&q,extent,token);
                 (void) CopyMagickString(name,token,MagickPathExtent);
                 GetNextToken(q,&q,extent,token);
                 (void) CopyMagickString(type,token,MagickPathExtent);
                 GetNextToken(q,&q,extent,token);
                 segment.x1=StringToDouble(token,&next_token);
                 if (token == next_token)
                   ThrowPointExpectedException(token,exception);
                 GetNextToken(q,&q,extent,token);
                 if (*token == ',')
                   GetNextToken(q,&q,extent,token);
                 segment.y1=StringToDouble(token,&next_token);
                 if (token == next_token)
                   ThrowPointExpectedException(token,exception);
                 GetNextToken(q,&q,extent,token);
                 if (*token == ',')
                   GetNextToken(q,&q,extent,token);
                 segment.x2=StringToDouble(token,&next_token);
                 if (token == next_token)
                   ThrowPointExpectedException(token,exception);
                 GetNextToken(q,&q,extent,token);
                 if (*token == ',')
                   GetNextToken(q,&q,extent,token);
                 segment.y2=StringToDouble(token,&next_token);
                 if (token == next_token)
                   ThrowPointExpectedException(token,exception);
                 if (LocaleCompare(type,"radial") == 0)
                   {
                     GetNextToken(q,&q,extent,token);
                     if (*token == ',')
                       GetNextToken(q,&q,extent,token);
                   }
                 for (p=q; *q != '\0'; )
                 {
                   GetNextToken(q,&q,extent,token);
                   if (LocaleCompare(token,"pop") != 0)
                     continue;
                   GetNextToken(q,(const char **) NULL,extent,token);
                   if (LocaleCompare(token,"gradient") != 0)
                     continue;
                   break;
                 }
-                if ((size_t) (q-p-4+1) > 0)
+                if ((size_t) (q-p-4+1) <= 0)
                   {
-                    (void) CopyMagickString(token,p,(size_t) (q-p-4+1));
-                    bounds.x1=graphic_context[n]->affine.sx*segment.x1+
-                      graphic_context[n]->affine.ry*segment.y1+
-                      graphic_context[n]->affine.tx;
-                    bounds.y1=graphic_context[n]->affine.rx*segment.x1+
-                      graphic_context[n]->affine.sy*segment.y1+
-                      graphic_context[n]->affine.ty;
-                    bounds.x2=graphic_context[n]->affine.sx*segment.x2+
-                      graphic_context[n]->affine.ry*segment.y2+
-                      graphic_context[n]->affine.tx;
-                    bounds.y2=graphic_context[n]->affine.rx*segment.x2+
-                      graphic_context[n]->affine.sy*segment.y2+
-                      graphic_context[n]->affine.ty;
-                    (void) FormatLocaleString(key,MagickPathExtent,"%s",name);
-                    (void) SetImageArtifact(image,key,token);
-                    (void) FormatLocaleString(key,MagickPathExtent,"%s-type",
-                      name);
-                    (void) SetImageArtifact(image,key,type);
-                    (void) FormatLocaleString(key,MagickPathExtent,
-                      "%s-geometry",name);
-                    (void) FormatLocaleString(geometry,MagickPathExtent,
-                      "%gx%g%+.15g%+.15g",
-                      MagickMax(fabs(bounds.x2-bounds.x1+1.0),1.0),
-                      MagickMax(fabs(bounds.y2-bounds.y1+1.0),1.0),
-                      bounds.x1,bounds.y1);
-                    (void) SetImageArtifact(image,key,geometry);
+                    status=MagickFalse;
+                    break;
                   }
+                (void) CopyMagickString(token,p,(size_t) (q-p-4+1));
+                bounds.x1=graphic_context[n]->affine.sx*segment.x1+
+                  graphic_context[n]->affine.ry*segment.y1+
+                  graphic_context[n]->affine.tx;
+                bounds.y1=graphic_context[n]->affine.rx*segment.x1+
+                  graphic_context[n]->affine.sy*segment.y1+
+                  graphic_context[n]->affine.ty;
+                bounds.x2=graphic_context[n]->affine.sx*segment.x2+
+                  graphic_context[n]->affine.ry*segment.y2+
+                  graphic_context[n]->affine.tx;
+                bounds.y2=graphic_context[n]->affine.rx*segment.x2+
+                  graphic_context[n]->affine.sy*segment.y2+
+                  graphic_context[n]->affine.ty;
+                (void) FormatLocaleString(key,MagickPathExtent,"%s",name);
+                (void) SetImageArtifact(image,key,token);
+                (void) FormatLocaleString(key,MagickPathExtent,"%s-type",name);
+                (void) SetImageArtifact(image,key,type);
+                (void) FormatLocaleString(key,MagickPathExtent,"%s-geometry",
+                  name);
+                (void) FormatLocaleString(geometry,MagickPathExtent,
+                  "%gx%g%+.15g%+.15g",
+                  MagickMax(fabs(bounds.x2-bounds.x1+1.0),1.0),
+                  MagickMax(fabs(bounds.y2-bounds.y1+1.0),1.0),
+                  bounds.x1,bounds.y1);
+                (void) SetImageArtifact(image,key,geometry);
                 GetNextToken(q,&q,extent,token);
                 break;
               }
             if (LocaleCompare("graphic-context",token) == 0)
               {
                 n++;
                 graphic_context=(DrawInfo **) ResizeQuantumMemory(
                   graphic_context,(size_t) (n+1),sizeof(*graphic_context));
                 if (graphic_context == (DrawInfo **) NULL)
                   {
                     (void) ThrowMagickException(exception,GetMagickModule(),
                       ResourceLimitError,"MemoryAllocationFailed","`%s'",
                       image->filename);
                     break;
                   }
                 graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,
                   graphic_context[n-1]);
                 if (*q == '"')
                   GetNextToken(q,&q,extent,token);
                 break;
               }
             if (LocaleCompare("mask",token) == 0)
               {
                 GetNextToken(q,&q,extent,token);
                 break;
               }
             if (LocaleCompare("pattern",token) == 0)
               {
                 char
                   key[2*MagickPathExtent],
                   name[MagickPathExtent];
 
                 RectangleInfo
                   pattern_bounds;
 
                 GetNextToken(q,&q,extent,token);
                 (void) CopyMagickString(name,token,MagickPathExtent);
                 GetNextToken(q,&q,extent,token);
                 pattern_bounds.x=(ssize_t) ceil(StringToDouble(token,
                   &next_token)-0.5);
                 if (token == next_token)
                   ThrowPointExpectedException(token,exception);
                 GetNextToken(q,&q,extent,token);
                 if (*token == ',')
                   GetNextToken(q,&q,extent,token);
                 pattern_bounds.y=(ssize_t) ceil(StringToDouble(token,
                   &next_token)-0.5);
                 if (token == next_token)
                   ThrowPointExpectedException(token,exception);
                 GetNextToken(q,&q,extent,token);
                 if (*token == ',')
                   GetNextToken(q,&q,extent,token);
                 pattern_bounds.width=(size_t) floor(StringToDouble(token,
                   &next_token)+0.5);
                 if (token == next_token)
                   ThrowPointExpectedException(token,exception);
                 GetNextToken(q,&q,extent,token);
                 if (*token == ',')
                   GetNextToken(q,&q,extent,token);
                 pattern_bounds.height=(size_t) floor(StringToDouble(token,
                   &next_token)+0.5);
                 if (token == next_token)
                   ThrowPointExpectedException(token,exception);
                 for (p=q; *q != '\0'; )
                 {
                   GetNextToken(q,&q,extent,token);
                   if (LocaleCompare(token,"pop") != 0)
                     continue;
                   GetNextToken(q,(const char **) NULL,extent,token);
                   if (LocaleCompare(token,"pattern") != 0)
                     continue;
                   break;
                 }
-                if ((size_t) (q-p-4+1) > 0)
+                if ((size_t) (q-p-4+1) <= 0)
                   {
-                    (void) CopyMagickString(token,p,(size_t) (q-p-4+1));
-                    (void) FormatLocaleString(key,MagickPathExtent,"%s",name);
-                    (void) SetImageArtifact(image,key,token);
-                    (void) FormatLocaleString(key,MagickPathExtent,
-                      "%s-geometry",name);
-                    (void) FormatLocaleString(geometry,MagickPathExtent,
-                      "%.20gx%.20g%+.20g%+.20g",(double)pattern_bounds.width,
-                      (double)pattern_bounds.height,(double)pattern_bounds.x,
-                      (double)pattern_bounds.y);
-                    (void) SetImageArtifact(image,key,geometry);
+                    status=MagickFalse;
+                    break;
                   }
+                (void) CopyMagickString(token,p,(size_t) (q-p-4+1));
+                (void) FormatLocaleString(key,MagickPathExtent,"%s",name);
+                (void) SetImageArtifact(image,key,token);
+                (void) FormatLocaleString(key,MagickPathExtent,"%s-geometry",
+                  name);
+                (void) FormatLocaleString(geometry,MagickPathExtent,
+                  "%.20gx%.20g%+.20g%+.20g",(double)pattern_bounds.width,
+                  (double)pattern_bounds.height,(double)pattern_bounds.x,
+                  (double)pattern_bounds.y);
+                (void) SetImageArtifact(image,key,geometry);
                 GetNextToken(q,&q,extent,token);
                 break;
               }
             if (LocaleCompare("symbol",token) == 0)
               {
                 symbolDepth++;
                 graphic_context[n]->render=symbolDepth > 0 ? MagickFalse :
                   MagickTrue;
                 break;
               }
             status=MagickFalse;
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'r':
       case 'R':
       {
         if (LocaleCompare("rectangle",keyword) == 0)
           {
             primitive_type=RectanglePrimitive;
             break;
           }
         if (LocaleCompare("rotate",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             angle=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             affine.sx=cos(DegreesToRadians(fmod((double) angle,360.0)));
             affine.rx=sin(DegreesToRadians(fmod((double) angle,360.0)));
             affine.ry=(-sin(DegreesToRadians(fmod((double) angle,360.0))));
             affine.sy=cos(DegreesToRadians(fmod((double) angle,360.0)));
             break;
           }
         if (LocaleCompare("roundRectangle",keyword) == 0)
           {
             primitive_type=RoundRectanglePrimitive;
             break;
           }
         status=MagickFalse;
         break;
       }
       case 's':
       case 'S':
       {
         if (LocaleCompare("scale",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             affine.sx=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             affine.sy=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             break;
           }
         if (LocaleCompare("skewX",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             angle=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             affine.ry=sin(DegreesToRadians(angle));
             break;
           }
         if (LocaleCompare("skewY",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             angle=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             affine.rx=(-tan(DegreesToRadians(angle)/2.0));
             break;
           }
         if (LocaleCompare("stop-color",keyword) == 0)
           {
             PixelInfo
               stop_color;
 
             number_stops++;
             if (number_stops == 1)
               stops=(StopInfo *) AcquireQuantumMemory(2,sizeof(*stops));
             else if (number_stops > 2)
               stops=(StopInfo *) ResizeQuantumMemory(stops,number_stops,
                 sizeof(*stops));
             if (stops == (StopInfo *) NULL)
               {
                 (void) ThrowMagickException(exception,GetMagickModule(),
                   ResourceLimitError,"MemoryAllocationFailed","`%s'",
                   image->filename);
                 break;
               }
             GetNextToken(q,&q,extent,token);
             status&=QueryColorCompliance(token,AllCompliance,&stop_color,
               exception);
             stops[number_stops-1].color=stop_color;
             GetNextToken(q,&q,extent,token);
             stops[number_stops-1].offset=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             break;
           }
         if (LocaleCompare("stroke",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             if (graphic_context[n]->clip_path != MagickFalse)
               break;
             (void) FormatLocaleString(pattern,MagickPathExtent,"%s",token);
             if (GetImageArtifact(image,pattern) != (const char *) NULL)
               (void) DrawPatternPath(image,draw_info,token,
                 &graphic_context[n]->stroke_pattern,exception);
             else
               {
                 status&=QueryColorCompliance(token,AllCompliance,
                   &graphic_context[n]->stroke,exception);
                 if (graphic_context[n]->stroke_alpha != OpaqueAlpha)
                   graphic_context[n]->stroke.alpha=
                     graphic_context[n]->stroke_alpha;
               }
             break;
           }
         if (LocaleCompare("stroke-antialias",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->stroke_antialias=
               StringToLong(token) != 0 ? MagickTrue : MagickFalse;
             break;
           }
         if (LocaleCompare("stroke-dasharray",keyword) == 0)
           {
             if (graphic_context[n]->dash_pattern != (double *) NULL)
               graphic_context[n]->dash_pattern=(double *)
                 RelinquishMagickMemory(graphic_context[n]->dash_pattern);
             if (IsPoint(q) != MagickFalse)
               {
                 const char
                   *r;
 
                 r=q;
                 GetNextToken(r,&r,extent,token);
                 if (*token == ',')
                   GetNextToken(r,&r,extent,token);
                 for (x=0; IsPoint(token) != MagickFalse; x++)
                 {
                   GetNextToken(r,&r,extent,token);
                   if (*token == ',')
                     GetNextToken(r,&r,extent,token);
                 }
                 graphic_context[n]->dash_pattern=(double *)
                   AcquireQuantumMemory((size_t) (2UL*x+2UL),
                   sizeof(*graphic_context[n]->dash_pattern));
                 if (graphic_context[n]->dash_pattern == (double *) NULL)
                   {
                     (void) ThrowMagickException(exception,GetMagickModule(),
                       ResourceLimitError,"MemoryAllocationFailed","`%s'",
                       image->filename);
                     status=MagickFalse;
                     break;
                   }
                 (void) memset(graphic_context[n]->dash_pattern,0,(size_t)
                   (2UL*x+2UL)*sizeof(*graphic_context[n]->dash_pattern));
                 for (j=0; j < x; j++)
                 {
                   GetNextToken(q,&q,extent,token);
                   if (*token == ',')
                     GetNextToken(q,&q,extent,token);
                   graphic_context[n]->dash_pattern[j]=StringToDouble(token,
                     &next_token);
                   if (token == next_token)
                     ThrowPointExpectedException(token,exception);
                   if (graphic_context[n]->dash_pattern[j] < 0.0)
                     status=MagickFalse;
                 }
                 if ((x & 0x01) != 0)
                   for ( ; j < (2*x); j++)
                     graphic_context[n]->dash_pattern[j]=
                       graphic_context[n]->dash_pattern[j-x];
                 graphic_context[n]->dash_pattern[j]=0.0;
                 break;
               }
             GetNextToken(q,&q,extent,token);
             break;
           }
         if (LocaleCompare("stroke-dashoffset",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->dash_offset=StringToDouble(token,
               &next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             break;
           }
         if (LocaleCompare("stroke-linecap",keyword) == 0)
           {
             ssize_t
               linecap;
 
             GetNextToken(q,&q,extent,token);
             linecap=ParseCommandOption(MagickLineCapOptions,MagickFalse,token);
             if (linecap == -1)
               status=MagickFalse;
             else
               graphic_context[n]->linecap=(LineCap) linecap;
             break;
           }
         if (LocaleCompare("stroke-linejoin",keyword) == 0)
           {
             ssize_t
               linejoin;
 
             GetNextToken(q,&q,extent,token);
             linejoin=ParseCommandOption(MagickLineJoinOptions,MagickFalse,
               token);
             if (linejoin == -1)
               status=MagickFalse;
             else
               graphic_context[n]->linejoin=(LineJoin) linejoin;
             break;
           }
         if (LocaleCompare("stroke-miterlimit",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->miterlimit=StringToUnsignedLong(token);
             break;
           }
         if (LocaleCompare("stroke-opacity",keyword) == 0)
           {
             double
               opacity;
 
             GetNextToken(q,&q,extent,token);
             if (graphic_context[n]->clip_path != MagickFalse)
               break;
             factor=strchr(token,'%') != (char *) NULL ? 0.01 : 1.0;
             opacity=MagickMin(MagickMax(factor*
               StringToDouble(token,&next_token),0.0),1.0);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             graphic_context[n]->stroke_alpha=(MagickRealType) (QuantumRange-
               QuantumRange*(1.0-opacity));
             break;
           }
         if (LocaleCompare("stroke-width",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             if (graphic_context[n]->clip_path != MagickFalse)
               break;
             graphic_context[n]->stroke_width=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             break;
           }
         status=MagickFalse;
         break;
       }
       case 't':
       case 'T':
       {
         if (LocaleCompare("text",keyword) == 0)
           {
             primitive_type=TextPrimitive;
             break;
           }
         if (LocaleCompare("text-align",keyword) == 0)
           {
             ssize_t
               align;
 
             GetNextToken(q,&q,extent,token);
             align=ParseCommandOption(MagickAlignOptions,MagickFalse,token);
             if (align == -1)
               status=MagickFalse;
             else
               graphic_context[n]->align=(AlignType) align;
             break;
           }
         if (LocaleCompare("text-anchor",keyword) == 0)
           {
             ssize_t
               align;
 
             GetNextToken(q,&q,extent,token);
             align=ParseCommandOption(MagickAlignOptions,MagickFalse,token);
             if (align == -1)
               status=MagickFalse;
             else
               graphic_context[n]->align=(AlignType) align;
             break;
           }
         if (LocaleCompare("text-antialias",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->text_antialias=StringToLong(token) != 0 ?
               MagickTrue : MagickFalse;
             break;
           }
         if (LocaleCompare("text-undercolor",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             status&=QueryColorCompliance(token,AllCompliance,
               &graphic_context[n]->undercolor,exception);
             break;
           }
         if (LocaleCompare("translate",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             affine.tx=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             affine.ty=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'u':
       case 'U':
       {
         if (LocaleCompare("use",keyword) == 0)
           {
             char
               *node;
 
             /*
               Take a node from within the MVG document, and duplicate it here.
             */
             GetNextToken(q,&q,extent,token);
             node=GetNodeByURL(primitive,token);
             if (node != (char *) NULL)
               {
                 DrawInfo
                   *clone_info;
 
                 clone_info=CloneDrawInfo((ImageInfo *) NULL,graphic_context[n]);
                 (void) CloneString(&clone_info->primitive,node);
                 node=DestroyString(node);
                 status=DrawImage(image,clone_info,exception);
                 clone_info=DestroyDrawInfo(clone_info);
               }
             break;
           }
         break;
       }
       case 'v':
       case 'V':
       {
         if (LocaleCompare("viewbox",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->viewbox.x=(ssize_t) ceil(StringToDouble(token,
               &next_token)-0.5);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             graphic_context[n]->viewbox.y=(ssize_t) ceil(StringToDouble(token,
               &next_token)-0.5);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             graphic_context[n]->viewbox.width=(size_t) floor(StringToDouble(
               token,&next_token)+0.5);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             graphic_context[n]->viewbox.height=(size_t) floor(StringToDouble(
               token,&next_token)+0.5);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             break;
           }
         status=MagickFalse;
         break;
       }
       default:
       {
         status=MagickFalse;
         break;
       }
     }
     if (status == MagickFalse)
       break;
     if ((fabs(affine.sx-1.0) >= DrawEpsilon) ||
         (fabs(affine.rx) >= DrawEpsilon) || (fabs(affine.ry) >= DrawEpsilon) ||
         (fabs(affine.sy-1.0) >= DrawEpsilon) ||
         (fabs(affine.tx) >= DrawEpsilon) || (fabs(affine.ty) >= DrawEpsilon))
       {
         graphic_context[n]->affine.sx=current.sx*affine.sx+current.ry*affine.rx;
         graphic_context[n]->affine.rx=current.rx*affine.sx+current.sy*affine.rx;
         graphic_context[n]->affine.ry=current.sx*affine.ry+current.ry*affine.sy;
         graphic_context[n]->affine.sy=current.rx*affine.ry+current.sy*affine.sy;
         graphic_context[n]->affine.tx=current.sx*affine.tx+current.ry*affine.ty+
           current.tx;
         graphic_context[n]->affine.ty=current.rx*affine.tx+current.sy*affine.ty+
           current.ty;
       }
     if (primitive_type == UndefinedPrimitive)
       {
         if (*q == '\0')
           {
             if (number_stops > 1)
               {
                 GradientType
                   type;
 
               type=LinearGradient;
               if (draw_info->gradient.type == RadialGradient)
                 type=RadialGradient;
               (void) GradientImage(image,type,PadSpread,stops,number_stops,
                 exception);
              }
            if (number_stops > 0)
              stops=(StopInfo *) RelinquishMagickMemory(stops);
           }
         if (image->debug != MagickFalse)
           (void) LogMagickEvent(DrawEvent,GetMagickModule(),"  %.*s",(int)
             (q-p),p);
         continue;
       }
     /*
       Parse the primitive attributes.
     */
     i=0;
     j=0;
     primitive_info[0].point.x=0.0;
     primitive_info[0].point.y=0.0;
+    primitive_info[0].coordinates=0;
+    primitive_info[0].method=FloodfillMethod;
+    primitive_info[0].closed_subpath=MagickFalse;
     for (x=0; *q != '\0'; x++)
     {
       /*
         Define points.
       */
       if (IsPoint(q) == MagickFalse)
         break;
       GetNextToken(q,&q,extent,token);
       point.x=StringToDouble(token,&next_token);
       if (token == next_token)
         ThrowPointExpectedException(token,exception);
       GetNextToken(q,&q,extent,token);
       if (*token == ',')
         GetNextToken(q,&q,extent,token);
       point.y=StringToDouble(token,&next_token);
       if (token == next_token)
         ThrowPointExpectedException(token,exception);
       GetNextToken(q,(const char **) NULL,extent,token);
       if (*token == ',')
         GetNextToken(q,&q,extent,token);
       primitive_info[i].primitive=primitive_type;
       primitive_info[i].point=point;
       primitive_info[i].coordinates=0;
       primitive_info[i].method=FloodfillMethod;
+      primitive_info[i].closed_subpath=MagickFalse;
       i++;
       if (i < (ssize_t) number_points)
         continue;
       number_points<<=1;
       primitive_info=(PrimitiveInfo *) ResizeQuantumMemory(primitive_info,
         (size_t) number_points,sizeof(*primitive_info));
       if ((primitive_info == (PrimitiveInfo *) NULL) ||
           (number_points != (MagickSizeType) ((size_t) number_points)))
         ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
           image->filename);
     }
     if (status == MagickFalse)
       break;
     primitive_info[j].primitive=primitive_type;
     primitive_info[j].coordinates=(size_t) x;
     primitive_info[j].method=FloodfillMethod;
+    primitive_info[j].closed_subpath=MagickFalse;
     primitive_info[j].text=(char *) NULL;
     /*
       Circumscribe primitive within a circle.
     */
     bounds.x1=primitive_info[j].point.x;
     bounds.y1=primitive_info[j].point.y;
     bounds.x2=primitive_info[j].point.x;
     bounds.y2=primitive_info[j].point.y;
     for (k=1; k < (ssize_t) primitive_info[j].coordinates; k++)
     {
       point=primitive_info[j+k].point;
       if (point.x < bounds.x1)
         bounds.x1=point.x;
       if (point.y < bounds.y1)
         bounds.y1=point.y;
       if (point.x > bounds.x2)
         bounds.x2=point.x;
       if (point.y > bounds.y2)
         bounds.y2=point.y;
     }
     /*
       Speculate how many points our primitive might consume.
     */
     coordinates=primitive_info[j].coordinates;
     switch (primitive_type)
     {
       case RectanglePrimitive:
       {
         coordinates*=5;
         break;
       }
       case RoundRectanglePrimitive:
       {
         coordinates=ReckonRoundRectangleCoordinates(primitive_info[j].point,
           primitive_info[j+1].point,primitive_info[j+2].point);
         break;
       }
       case BezierPrimitive:
       {
         if (primitive_info[j].coordinates > 107)
           {
             (void) ThrowMagickException(exception,GetMagickModule(),DrawError,
               "TooManyBezierCoordinates","`%s'",token);
             status=MagickFalse;
             break;
           }
         coordinates=BezierQuantum*primitive_info[j].coordinates;
         break;
       }
       case PathPrimitive:
       {
         char
           *s,
           *t;
 
         GetNextToken(q,&q,extent,token);
         coordinates=1;
         t=token;
         for (s=token; *s != '\0'; s=t)
         {
           double
             value;
 
           value=StringToDouble(s,&t);
           (void) value;
           if (s == t)
             {
               t++;
               continue;
             }
           coordinates++;
         }
         coordinates*=(6*BezierQuantum)+360;
         break;
       }
       case CirclePrimitive:
       {
         double
           alpha,
           beta,
           radius;
 
         PointInfo
           offset,
           degrees;
 
         alpha=primitive_info[j+1].point.x-primitive_info[j].point.x;
         beta=primitive_info[j+1].point.y-primitive_info[j].point.y;
         radius=hypot((double) alpha,(double) beta);
         offset.x=(double) radius;
         offset.y=(double) radius;
         degrees.x=0.0;
         degrees.y=360.0;
         coordinates=ReckonEllipseCoordinates(offset,degrees);
         break;
       }
       case ArcPrimitive:
       {
         PointInfo
           center,
           radii;
 
         if ((primitive_info[j+2].point.x < -360.0) ||
             (primitive_info[j+2].point.x > 360.0) ||
             (primitive_info[j+2].point.y < -360.0) ||
             (primitive_info[j+2].point.y > 360.0))
           ThrowPointExpectedException(token,exception);
         center.x=0.5*(primitive_info[j+1].point.x+primitive_info[j].point.x);
         center.y=0.5*(primitive_info[j+1].point.y+primitive_info[j].point.y);
         radii.x=fabs(center.x-primitive_info[j].point.x);
         radii.y=fabs(center.y-primitive_info[j].point.y);
         coordinates=ReckonEllipseCoordinates(radii,primitive_info[j+2].point);
         break;
       }
       case EllipsePrimitive:
       {
         if ((primitive_info[j+2].point.x < -360.0) ||
             (primitive_info[j+2].point.x > 360.0) ||
             (primitive_info[j+2].point.y < -360.0) ||
             (primitive_info[j+2].point.y > 360.0))
           ThrowPointExpectedException(token,exception);
         coordinates=ReckonEllipseCoordinates(primitive_info[j+1].point,
           primitive_info[j+2].point);
         break;
       }
       default:
         break;
     }
     if (coordinates > MaxBezierCoordinates)
       {
         (void) ThrowMagickException(exception,GetMagickModule(),DrawError,
           "TooManyBezierCoordinates","`%s'",token);
         status=MagickFalse;
       }
     if (status == MagickFalse)
       break;
     if (((MagickSizeType) (i+coordinates)) >= number_points)
       {
         /*
           Resize based on speculative points required by primitive.
         */
         number_points+=coordinates+1;
         primitive_info=(PrimitiveInfo *) ResizeQuantumMemory(primitive_info,
           (size_t) number_points,sizeof(*primitive_info));
         if ((primitive_info == (PrimitiveInfo *) NULL) ||
             (number_points != (MagickSizeType) ((size_t) number_points)))
           {
             (void) ThrowMagickException(exception,GetMagickModule(),
               ResourceLimitError,"MemoryAllocationFailed","`%s'",
               image->filename);
             break;
           }
       }
     switch (primitive_type)
     {
       case PointPrimitive:
       default:
       {
         if (primitive_info[j].coordinates != 1)
           {
             status=MagickFalse;
             break;
           }
         TracePoint(primitive_info+j,primitive_info[j].point);
         i=(ssize_t) (j+primitive_info[j].coordinates);
         break;
       }
       case LinePrimitive:
       {
         if (primitive_info[j].coordinates != 2)
           {
             status=MagickFalse;
             break;
           }
         TraceLine(primitive_info+j,primitive_info[j].point,
           primitive_info[j+1].point);
         i=(ssize_t) (j+primitive_info[j].coordinates);
         break;
       }
       case RectanglePrimitive:
       {
         if (primitive_info[j].coordinates != 2)
           {
             status=MagickFalse;
             break;
           }
         if ((primitive_info[j+1].point.x-primitive_info[j].point.x) < 0.0)
           {
             status=MagickFalse;
             break;
           }
         if ((primitive_info[j+1].point.y-primitive_info[j].point.y) < 0.0)
           {
             status=MagickFalse;
             break;
           }
         TraceRectangle(primitive_info+j,primitive_info[j].point,
           primitive_info[j+1].point);
         i=(ssize_t) (j+primitive_info[j].coordinates);
         break;
       }
       case RoundRectanglePrimitive:
       {
         if (primitive_info[j].coordinates != 3)
           {
             status=MagickFalse;
             break;
           }
-        if ((primitive_info[j+2].point.x < 0.0) || 
+        if ((primitive_info[j+2].point.x < 0.0) ||
             (primitive_info[j+2].point.y < 0.0))
           {
             status=MagickFalse;
             break;
           }
         if ((primitive_info[j+1].point.x-primitive_info[j].point.x) < 0.0)
           {
             status=MagickFalse;
             break;
           }
         if ((primitive_info[j+1].point.y-primitive_info[j].point.y) < 0.0)
           {
             status=MagickFalse;
             break;
           }
         TraceRoundRectangle(primitive_info+j,primitive_info[j].point,
           primitive_info[j+1].point,primitive_info[j+2].point);
         i=(ssize_t) (j+primitive_info[j].coordinates);
         break;
       }
       case ArcPrimitive:
       {
         if (primitive_info[j].coordinates != 3)
           {
             primitive_type=UndefinedPrimitive;
             break;
           }
         TraceArc(primitive_info+j,primitive_info[j].point,
           primitive_info[j+1].point,primitive_info[j+2].point);
         i=(ssize_t) (j+primitive_info[j].coordinates);
         break;
       }
       case EllipsePrimitive:
       {
         if (primitive_info[j].coordinates != 3)
           {
             status=MagickFalse;
             break;
           }
         if ((primitive_info[j+1].point.x < 0.0) ||
             (primitive_info[j+1].point.y < 0.0))
           {
             status=MagickFalse;
             break;
           }
         TraceEllipse(primitive_info+j,primitive_info[j].point,
           primitive_info[j+1].point,primitive_info[j+2].point);
         i=(ssize_t) (j+primitive_info[j].coordinates);
         break;
       }
       case CirclePrimitive:
       {
         if (primitive_info[j].coordinates != 2)
           {
             status=MagickFalse;
             break;
           }
         TraceCircle(primitive_info+j,primitive_info[j].point,
           primitive_info[j+1].point);
         i=(ssize_t) (j+primitive_info[j].coordinates);
         break;
       }
       case PolylinePrimitive:
       {
         if (primitive_info[j].coordinates < 1)
           {
             status=MagickFalse;
             break;
           }
         break;
       }
       case PolygonPrimitive:
       {
         if (primitive_info[j].coordinates < 3)
           {
             status=MagickFalse;
             break;
           }
         primitive_info[i]=primitive_info[j];
         primitive_info[i].coordinates=0;
         primitive_info[j].coordinates++;
+        primitive_info[j].closed_subpath=MagickTrue;
         i++;
         break;
       }
       case BezierPrimitive:
       {
         if (primitive_info[j].coordinates < 3)
           {
             status=MagickFalse;
             break;
           }
         TraceBezier(primitive_info+j,primitive_info[j].coordinates);
         i=(ssize_t) (j+primitive_info[j].coordinates);
         break;
       }
       case PathPrimitive:
       {
         coordinates=TracePath(primitive_info+j,token,exception);
         if (coordinates == 0)
           {
             status=MagickFalse;
             break;
           }
         i=(ssize_t) (j+coordinates);
         break;
       }
       case AlphaPrimitive:
       case ColorPrimitive:
       {
         ssize_t
           method;
 
         if (primitive_info[j].coordinates != 1)
           {
             status=MagickFalse;
             break;
           }
         GetNextToken(q,&q,extent,token);
         method=ParseCommandOption(MagickMethodOptions,MagickFalse,token);
         if (method == -1)
           status=MagickFalse;
         else
           primitive_info[j].method=(PaintMethod) method;
         break;
       }
       case TextPrimitive:
       {
         if (primitive_info[j].coordinates != 1)
           {
             status=MagickFalse;
             break;
           }
         if (*token != ',')
           GetNextToken(q,&q,extent,token);
         primitive_info[j].text=AcquireString(token);
         break;
       }
       case ImagePrimitive:
       {
         if (primitive_info[j].coordinates != 2)
           {
             status=MagickFalse;
             break;
           }
         GetNextToken(q,&q,extent,token);
         primitive_info[j].text=AcquireString(token);
         break;
       }
     }
     if (primitive_info == (PrimitiveInfo *) NULL)
       break;
     if (image->debug != MagickFalse)
       (void) LogMagickEvent(DrawEvent,GetMagickModule(),"  %.*s",(int) (q-p),p);
     if (status == MagickFalse)
       break;
     primitive_info[i].primitive=UndefinedPrimitive;
     if (i == 0)
       continue;
     /*
       Transform points.
     */
     for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++)
     {
       point=primitive_info[i].point;
       primitive_info[i].point.x=graphic_context[n]->affine.sx*point.x+
         graphic_context[n]->affine.ry*point.y+graphic_context[n]->affine.tx;
       primitive_info[i].point.y=graphic_context[n]->affine.rx*point.x+
         graphic_context[n]->affine.sy*point.y+graphic_context[n]->affine.ty;
       point=primitive_info[i].point;
       if (point.x < graphic_context[n]->bounds.x1)
         graphic_context[n]->bounds.x1=point.x;
       if (point.y < graphic_context[n]->bounds.y1)
         graphic_context[n]->bounds.y1=point.y;
       if (point.x > graphic_context[n]->bounds.x2)
         graphic_context[n]->bounds.x2=point.x;
       if (point.y > graphic_context[n]->bounds.y2)
         graphic_context[n]->bounds.y2=point.y;
       if (primitive_info[i].primitive == ImagePrimitive)
         break;
       if (i >= (ssize_t) number_points)
         ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
     }
     if (graphic_context[n]->render != MagickFalse)
       status&=DrawPrimitive(image,graphic_context[n],primitive_info,
         exception);
     if (primitive_info->text != (char *) NULL)
       primitive_info->text=(char *) RelinquishMagickMemory(
         primitive_info->text);
     proceed=SetImageProgress(image,RenderImageTag,q-primitive,(MagickSizeType)
       primitive_extent);
     if (proceed == MagickFalse)
       break;
     if (status == 0)
       break;
   }
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(DrawEvent,GetMagickModule(),"end draw-image");
   /*
     Relinquish resources.
   */
   token=DestroyString(token);
   if (primitive_info != (PrimitiveInfo *) NULL)
     primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(primitive_info);
   primitive=DestroyString(primitive);
   if (stops != (StopInfo *) NULL)
     stops=(StopInfo *) RelinquishMagickMemory(stops);
   for ( ; n >= 0; n--)
     graphic_context[n]=DestroyDrawInfo(graphic_context[n]);
   graphic_context=(DrawInfo **) RelinquishMagickMemory(graphic_context);
   if (status == MagickFalse)
     ThrowBinaryException(DrawError,"NonconformingDrawingPrimitiveDefinition",
       keyword);
   return(status != 0 ? MagickTrue : MagickFalse);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %     D r a w G r a d i e n t I m a g e                                       %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  DrawGradientImage() draws a linear gradient on the image.
 %
 %  The format of the DrawGradientImage method is:
 %
 %      MagickBooleanType DrawGradientImage(Image *image,
 %        const DrawInfo *draw_info,ExceptionInfo *exception)
 %
 %  A description of each parameter follows:
 %
 %    o image: the image.
 %
 %    o draw_info: the draw info.
 %
 %    o exception: return any errors or warnings in this structure.
 %
 */
@@ -4161,170 +4186,170 @@ static PolygonInfo **AcquirePolygonThreadSet(
 static double GetFillAlpha(PolygonInfo *polygon_info,const double mid,
   const MagickBooleanType fill,const FillRule fill_rule,const ssize_t x,
   const ssize_t y,double *stroke_alpha)
 {
   double
     alpha,
     beta,
     distance,
     subpath_alpha;
 
   PointInfo
     delta;
 
   register const PointInfo
     *q;
 
   register EdgeInfo
     *p;
 
   register ssize_t
     i;
 
   ssize_t
     j,
     winding_number;
 
   /*
     Compute fill & stroke opacity for this (x,y) point.
   */
   *stroke_alpha=0.0;
   subpath_alpha=0.0;
   p=polygon_info->edges;
   for (j=0; j < (ssize_t) polygon_info->number_edges; j++, p++)
   {
     if ((double) y <= (p->bounds.y1-mid-0.5))
       break;
     if ((double) y > (p->bounds.y2+mid+0.5))
       {
         (void) DestroyEdge(polygon_info,(size_t) j);
         continue;
       }
     if (((double) x <= (p->bounds.x1-mid-0.5)) ||
         ((double) x > (p->bounds.x2+mid+0.5)))
       continue;
     i=(ssize_t) MagickMax((double) p->highwater,1.0);
     for ( ; i < (ssize_t) p->number_points; i++)
     {
       if ((double) y <= (p->points[i-1].y-mid-0.5))
         break;
       if ((double) y > (p->points[i].y+mid+0.5))
         continue;
       if (p->scanline != (double) y)
         {
           p->scanline=(double) y;
           p->highwater=(size_t) i;
         }
       /*
         Compute distance between a point and an edge.
       */
       q=p->points+i-1;
       delta.x=(q+1)->x-q->x;
       delta.y=(q+1)->y-q->y;
       beta=delta.x*(x-q->x)+delta.y*(y-q->y);
-      if (beta < 0.0)
+      if (beta <= 0.0)
         {
           delta.x=(double) x-q->x;
           delta.y=(double) y-q->y;
           distance=delta.x*delta.x+delta.y*delta.y;
         }
       else
         {
           alpha=delta.x*delta.x+delta.y*delta.y;
-          if (beta > alpha)
+          if (beta >= alpha)
             {
               delta.x=(double) x-(q+1)->x;
               delta.y=(double) y-(q+1)->y;
               distance=delta.x*delta.x+delta.y*delta.y;
             }
           else
             {
               alpha=PerceptibleReciprocal(alpha);
               beta=delta.x*(y-q->y)-delta.y*(x-q->x);
               distance=alpha*beta*beta;
             }
         }
       /*
         Compute stroke & subpath opacity.
       */
       beta=0.0;
       if (p->ghostline == MagickFalse)
         {
           alpha=mid+0.5;
           if ((*stroke_alpha < 1.0) &&
               (distance <= ((alpha+0.25)*(alpha+0.25))))
             {
               alpha=mid-0.5;
               if (distance <= ((alpha+0.25)*(alpha+0.25)))
                 *stroke_alpha=1.0;
               else
                 {
                   beta=1.0;
                   if (fabs(distance-1.0) >= DrawEpsilon)
                     beta=sqrt((double) distance);
                   alpha=beta-mid-0.5;
                   if (*stroke_alpha < ((alpha-0.25)*(alpha-0.25)))
                     *stroke_alpha=(alpha-0.25)*(alpha-0.25);
                 }
             }
         }
       if ((fill == MagickFalse) || (distance > 1.0) || (subpath_alpha >= 1.0))
         continue;
       if (distance <= 0.0)
         {
           subpath_alpha=1.0;
           continue;
         }
       if (distance > 1.0)
         continue;
       if (fabs(beta) < DrawEpsilon)
         {
           beta=1.0;
           if (fabs(distance-1.0) >= DrawEpsilon)
             beta=sqrt(distance);
         }
       alpha=beta-1.0;
       if (subpath_alpha < (alpha*alpha))
         subpath_alpha=alpha*alpha;
     }
   }
   /*
     Compute fill opacity.
   */
   if (fill == MagickFalse)
     return(0.0);
   if (subpath_alpha >= 1.0)
     return(1.0);
   /*
     Determine winding number.
   */
   winding_number=0;
   p=polygon_info->edges;
   for (j=0; j < (ssize_t) polygon_info->number_edges; j++, p++)
   {
     if ((double) y <= p->bounds.y1)
       break;
     if (((double) y > p->bounds.y2) || ((double) x <= p->bounds.x1))
       continue;
     if ((double) x > p->bounds.x2)
       {
         winding_number+=p->direction ? 1 : -1;
         continue;
       }
     i=(ssize_t) MagickMax((double) p->highwater,1.0);
     for ( ; i < (ssize_t) (p->number_points-1); i++)
       if ((double) y <= p->points[i].y)
         break;
     q=p->points+i-1;
     if ((((q+1)->x-q->x)*(y-q->y)) <= (((q+1)->y-q->y)*(x-q->x)))
       winding_number+=p->direction ? 1 : -1;
   }
   if (fill_rule != NonZeroRule)
     {
       if ((MagickAbsoluteValue(winding_number) & 0x01) != 0)
         return(1.0);
     }
   else
     if (MagickAbsoluteValue(winding_number) != 0)
       return(1.0);
   return(subpath_alpha);
 }
@@ -4332,46 +4357,46 @@ static double GetFillAlpha(PolygonInfo *polygon_info,const double mid,
 static MagickBooleanType DrawPolygonPrimitive(Image *image,
   const DrawInfo *draw_info,const PrimitiveInfo *primitive_info,
   ExceptionInfo *exception)
 {
   CacheView
     *image_view;
 
   MagickBooleanType
     fill,
     status;
 
   double
     mid;
 
   PolygonInfo
     **magick_restrict polygon_info;
 
   register EdgeInfo
     *p;
 
   register ssize_t
     i;
 
   SegmentInfo
     bounds;
 
   ssize_t
     start_y,
     stop_y,
     y;
 
-  /*
-    Compute bounding box.
-  */
   assert(image != (Image *) NULL);
   assert(image->signature == MagickCoreSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
   assert(draw_info != (DrawInfo *) NULL);
   assert(draw_info->signature == MagickCoreSignature);
   assert(primitive_info != (PrimitiveInfo *) NULL);
-  if (primitive_info->coordinates == 0)
+  if (primitive_info->coordinates <= 1)
     return(MagickTrue);
+  /*
+    Compute bounding box.
+  */
   polygon_info=AcquirePolygonThreadSet(primitive_info);
   if (polygon_info == (PolygonInfo **) NULL)
     return(MagickFalse);
@@ -4379,213 +4404,214 @@ DisableMSCWarning(4127)
   if (0)
     DrawBoundingRectangles(image,draw_info,polygon_info[0],exception);
 RestoreMSCWarning
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(DrawEvent,GetMagickModule(),"    begin draw-polygon");
   fill=(primitive_info->method == FillToBorderMethod) ||
     (primitive_info->method == FloodfillMethod) ? MagickTrue : MagickFalse;
-  mid=ExpandAffine(&draw_info->affine)*draw_info->stroke_width/2.0;
+  mid=ExpandAffine(&draw_info->affine)*SaneStrokeWidth(image,draw_info)/2.0;
   bounds=polygon_info[0]->edges[0].bounds;
   for (i=1; i < (ssize_t) polygon_info[0]->number_edges; i++)
   {
     p=polygon_info[0]->edges+i;
     if (p->bounds.x1 < bounds.x1)
       bounds.x1=p->bounds.x1;
     if (p->bounds.y1 < bounds.y1)
       bounds.y1=p->bounds.y1;
     if (p->bounds.x2 > bounds.x2)
       bounds.x2=p->bounds.x2;
     if (p->bounds.y2 > bounds.y2)
       bounds.y2=p->bounds.y2;
   }
   bounds.x1-=(mid+1.0);
   bounds.y1-=(mid+1.0);
   bounds.x2+=(mid+1.0);
   bounds.y2+=(mid+1.0);
-  if ((bounds.x1 >= image->columns) || (bounds.y1 >= image->rows) ||
+  if ((bounds.x1 >= (double) image->columns) ||
+      (bounds.y1 >= (double) image->rows) ||
       (bounds.x2 <= 0.0) || (bounds.y2 <= 0.0))
     return(MagickTrue);
   bounds.x1=bounds.x1 < 0.0 ? 0.0 : bounds.x1 >= (double) image->columns-1.0 ?
     (double) image->columns-1.0 : bounds.x1;
   bounds.y1=bounds.y1 < 0.0 ? 0.0 : bounds.y1 >= (double) image->rows-1.0 ?
     (double) image->rows-1.0 : bounds.y1;
   bounds.x2=bounds.x2 < 0.0 ? 0.0 : bounds.x2 >= (double) image->columns-1.0 ?
     (double) image->columns-1.0 : bounds.x2;
   bounds.y2=bounds.y2 < 0.0 ? 0.0 : bounds.y2 >= (double) image->rows-1.0 ?
     (double) image->rows-1.0 : bounds.y2;
   status=MagickTrue;
   image_view=AcquireAuthenticCacheView(image,exception);
   if ((primitive_info->coordinates == 1) ||
       (polygon_info[0]->number_edges == 0))
     {
       /*
         Draw point.
       */
       start_y=(ssize_t) ceil(bounds.y1-0.5);
       stop_y=(ssize_t) floor(bounds.y2+0.5);
 #if defined(MAGICKCORE_OPENMP_SUPPORT)
       #pragma omp parallel for schedule(static) shared(status) \
         magick_number_threads(image,image,stop_y-start_y+1,1)
 #endif
       for (y=start_y; y <= stop_y; y++)
       {
         MagickBooleanType
           sync;
 
         PixelInfo
           pixel;
 
         register ssize_t
           x;
 
         register Quantum
           *magick_restrict q;
 
         ssize_t
           start_x,
           stop_x;
 
         if (status == MagickFalse)
           continue;
         start_x=(ssize_t) ceil(bounds.x1-0.5);
         stop_x=(ssize_t) floor(bounds.x2+0.5);
         x=start_x;
         q=GetCacheViewAuthenticPixels(image_view,x,y,(size_t) (stop_x-x+1),1,
           exception);
         if (q == (Quantum *) NULL)
           {
             status=MagickFalse;
             continue;
           }
         GetPixelInfo(image,&pixel);
         for ( ; x <= stop_x; x++)
         {
           if ((x == (ssize_t) ceil(primitive_info->point.x-0.5)) &&
               (y == (ssize_t) ceil(primitive_info->point.y-0.5)))
             {
               GetFillColor(draw_info,x-start_x,y-start_y,&pixel,exception);
               SetPixelViaPixelInfo(image,&pixel,q);
             }
           q+=GetPixelChannels(image);
         }
         sync=SyncCacheViewAuthenticPixels(image_view,exception);
         if (sync == MagickFalse)
           status=MagickFalse;
       }
       image_view=DestroyCacheView(image_view);
       polygon_info=DestroyPolygonThreadSet(polygon_info);
       if (image->debug != MagickFalse)
         (void) LogMagickEvent(DrawEvent,GetMagickModule(),
           "    end draw-polygon");
       return(status);
     }
   /*
     Draw polygon or line.
   */
   if (image->alpha_trait == UndefinedPixelTrait)
     (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);
   start_y=(ssize_t) ceil(bounds.y1-0.5);
   stop_y=(ssize_t) floor(bounds.y2+0.5);
 #if defined(MAGICKCORE_OPENMP_SUPPORT)
   #pragma omp parallel for schedule(static) shared(status) \
     magick_number_threads(image,image,stop_y-start_y+1,1)
 #endif
   for (y=start_y; y <= stop_y; y++)
   {
     const int
       id = GetOpenMPThreadId();
 
     double
       fill_alpha,
       stroke_alpha;
 
     PixelInfo
       fill_color,
       stroke_color;
 
     register Quantum
       *magick_restrict q;
 
     register ssize_t
       x;
 
     ssize_t
       start_x,
       stop_x;
 
     if (status == MagickFalse)
       continue;
     start_x=(ssize_t) ceil(bounds.x1-0.5);
     stop_x=(ssize_t) floor(bounds.x2+0.5);
     q=GetCacheViewAuthenticPixels(image_view,start_x,y,(size_t) (stop_x-start_x+
       1),1,exception);
     if (q == (Quantum *) NULL)
       {
         status=MagickFalse;
         continue;
       }
     for (x=start_x; x <= stop_x; x++)
     {
       /*
         Fill and/or stroke.
       */
       if (GetPixelWriteMask(image,q) <= (QuantumRange/2))
         {
           q+=GetPixelChannels(image);
           continue;
         }
       fill_alpha=GetFillAlpha(polygon_info[id],mid,fill,draw_info->fill_rule,
         x,y,&stroke_alpha);
       if (draw_info->stroke_antialias == MagickFalse)
         {
           fill_alpha=fill_alpha > 0.25 ? 1.0 : 0.0;
           stroke_alpha=stroke_alpha > 0.25 ? 1.0 : 0.0;
         }
       GetFillColor(draw_info,x-start_x,y-start_y,&fill_color,exception);
       fill_alpha=fill_alpha*fill_color.alpha;
       CompositePixelOver(image,&fill_color,fill_alpha,q,(double)
         GetPixelAlpha(image,q),q);
       GetStrokeColor(draw_info,x-start_x,y-start_y,&stroke_color,exception);
       stroke_alpha=stroke_alpha*stroke_color.alpha;
       CompositePixelOver(image,&stroke_color,stroke_alpha,q,(double)
         GetPixelAlpha(image,q),q);
       q+=GetPixelChannels(image);
     }
     if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)
       status=MagickFalse;
   }
   image_view=DestroyCacheView(image_view);
   polygon_info=DestroyPolygonThreadSet(polygon_info);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(DrawEvent,GetMagickModule(),"    end draw-polygon");
   return(status);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   D r a w P r i m i t i v e                                                 %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  DrawPrimitive() draws a primitive (line, rectangle, ellipse) on the image.
 %
 %  The format of the DrawPrimitive method is:
 %
 %      MagickBooleanType DrawPrimitive(Image *image,const DrawInfo *draw_info,
 %        PrimitiveInfo *primitive_info,ExceptionInfo *exception)
 %
 %  A description of each parameter follows:
 %
 %    o image: the image.
 %
 %    o draw_info: the draw info.
 %
 %    o primitive_info: Specifies a pointer to a PrimitiveInfo structure.
 %
 %    o exception: return any errors or warnings in this structure.
 %
 */
@@ -4695,507 +4721,504 @@ static void LogPrimitiveInfo(const PrimitiveInfo *primitive_info)
 MagickExport MagickBooleanType DrawPrimitive(Image *image,
   const DrawInfo *draw_info,const PrimitiveInfo *primitive_info,
   ExceptionInfo *exception)
 {
   CacheView
     *image_view;
 
   MagickStatusType
     status;
 
   register ssize_t
     i,
     x;
 
   ssize_t
     y;
 
   if (image->debug != MagickFalse)
     {
       (void) LogMagickEvent(DrawEvent,GetMagickModule(),
         "  begin draw-primitive");
       (void) LogMagickEvent(DrawEvent,GetMagickModule(),
         "    affine: %g,%g,%g,%g,%g,%g",draw_info->affine.sx,
         draw_info->affine.rx,draw_info->affine.ry,draw_info->affine.sy,
         draw_info->affine.tx,draw_info->affine.ty);
     }
   if ((IsGrayColorspace(image->colorspace) != MagickFalse) &&
       ((IsPixelInfoGray(&draw_info->fill) == MagickFalse) ||
        (IsPixelInfoGray(&draw_info->stroke) == MagickFalse)))
     (void) SetImageColorspace(image,sRGBColorspace,exception);
   status=MagickTrue;
   if (draw_info->compliance == SVGCompliance)
     status=SetImageMask(image,WritePixelMask,draw_info->clipping_mask,
       exception);
   x=(ssize_t) ceil(primitive_info->point.x-0.5);
   y=(ssize_t) ceil(primitive_info->point.y-0.5);
   image_view=AcquireAuthenticCacheView(image,exception);
   switch (primitive_info->primitive)
   {
     case AlphaPrimitive:
     {
       if (image->alpha_trait == UndefinedPixelTrait)
         (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);
       switch (primitive_info->method)
       {
         case PointMethod:
         default:
         {
           PixelInfo
             pixel;
 
           register Quantum
             *q;
 
           q=GetCacheViewAuthenticPixels(image_view,x,y,1,1,exception);
           if (q == (Quantum *) NULL)
             break;
           GetFillColor(draw_info,x,y,&pixel,exception);
           SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);
           (void) SyncCacheViewAuthenticPixels(image_view,exception);
           break;
         }
         case ReplaceMethod:
         {
           MagickBooleanType
             sync;
 
           PixelInfo
             pixel,
             target;
 
           (void) GetOneCacheViewVirtualPixelInfo(image_view,x,y,&target,
             exception);
           GetPixelInfo(image,&pixel);
           for (y=0; y < (ssize_t) image->rows; y++)
           {
             register Quantum
               *magick_restrict q;
 
             q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,
               exception);
             if (q == (Quantum *) NULL)
               break;
             for (x=0; x < (ssize_t) image->columns; x++)
             {
               if (GetPixelWriteMask(image,q) <= (QuantumRange/2))
                 {
                   q+=GetPixelChannels(image);
                   continue;
                 }
               GetPixelInfoPixel(image,q,&pixel);
               if (IsFuzzyEquivalencePixelInfo(&pixel,&target) == MagickFalse)
                 {
                   q+=GetPixelChannels(image);
                   continue;
                 }
               GetFillColor(draw_info,x,y,&pixel,exception);
               SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);
               q+=GetPixelChannels(image);
             }
             sync=SyncCacheViewAuthenticPixels(image_view,exception);
             if (sync == MagickFalse)
               break;
           }
           break;
         }
         case FloodfillMethod:
         case FillToBorderMethod:
         {
           ChannelType
             channel_mask;
 
           PixelInfo
             target;
 
           (void) GetOneVirtualPixelInfo(image,TileVirtualPixelMethod,x,y,
             &target,exception);
           if (primitive_info->method == FillToBorderMethod)
             {
               target.red=(double) draw_info->border_color.red;
               target.green=(double) draw_info->border_color.green;
               target.blue=(double) draw_info->border_color.blue;
             }
           channel_mask=SetImageChannelMask(image,AlphaChannel);
           status&=FloodfillPaintImage(image,draw_info,&target,x,y,
             primitive_info->method == FloodfillMethod ? MagickFalse :
             MagickTrue,exception);
           (void) SetImageChannelMask(image,channel_mask);
           break;
         }
         case ResetMethod:
         {
           MagickBooleanType
             sync;
 
           PixelInfo
             pixel;
 
           for (y=0; y < (ssize_t) image->rows; y++)
           {
             register Quantum
               *magick_restrict q;
 
             q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,
               exception);
             if (q == (Quantum *) NULL)
               break;
             for (x=0; x < (ssize_t) image->columns; x++)
             {
               if (GetPixelWriteMask(image,q) <= (QuantumRange/2))
                 {
                   q+=GetPixelChannels(image);
                   continue;
                 }
               GetFillColor(draw_info,x,y,&pixel,exception);
               SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);
               q+=GetPixelChannels(image);
             }
             sync=SyncCacheViewAuthenticPixels(image_view,exception);
             if (sync == MagickFalse)
               break;
           }
           break;
         }
       }
       break;
     }
     case ColorPrimitive:
     {
       switch (primitive_info->method)
       {
         case PointMethod:
         default:
         {
           PixelInfo
             pixel;
 
           register Quantum
             *q;
 
           q=GetCacheViewAuthenticPixels(image_view,x,y,1,1,exception);
           if (q == (Quantum *) NULL)
             break;
           GetPixelInfo(image,&pixel);
           GetFillColor(draw_info,x,y,&pixel,exception);
           SetPixelViaPixelInfo(image,&pixel,q);
           (void) SyncCacheViewAuthenticPixels(image_view,exception);
           break;
         }
         case ReplaceMethod:
         {
           MagickBooleanType
             sync;
 
           PixelInfo
             pixel,
             target;
 
           (void) GetOneCacheViewVirtualPixelInfo(image_view,x,y,&target,
             exception);
           for (y=0; y < (ssize_t) image->rows; y++)
           {
             register Quantum
               *magick_restrict q;
 
             q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,
               exception);
             if (q == (Quantum *) NULL)
               break;
             for (x=0; x < (ssize_t) image->columns; x++)
             {
               if (GetPixelWriteMask(image,q) <= (QuantumRange/2))
                 {
                   q+=GetPixelChannels(image);
                   continue;
                 }
               GetPixelInfoPixel(image,q,&pixel);
               if (IsFuzzyEquivalencePixelInfo(&pixel,&target) == MagickFalse)
                 {
                   q+=GetPixelChannels(image);
                   continue;
                 }
               GetFillColor(draw_info,x,y,&pixel,exception);
               SetPixelViaPixelInfo(image,&pixel,q);
               q+=GetPixelChannels(image);
             }
             sync=SyncCacheViewAuthenticPixels(image_view,exception);
             if (sync == MagickFalse)
               break;
           }
           break;
         }
         case FloodfillMethod:
         case FillToBorderMethod:
         {
           PixelInfo
             target;
 
           (void) GetOneVirtualPixelInfo(image,TileVirtualPixelMethod,x,y,
             &target,exception);
           if (primitive_info->method == FillToBorderMethod)
             {
               target.red=(double) draw_info->border_color.red;
               target.green=(double) draw_info->border_color.green;
               target.blue=(double) draw_info->border_color.blue;
             }
           status&=FloodfillPaintImage(image,draw_info,&target,x,y,
             primitive_info->method == FloodfillMethod ? MagickFalse :
             MagickTrue,exception);
           break;
         }
         case ResetMethod:
         {
           MagickBooleanType
             sync;
 
           PixelInfo
             pixel;
 
           GetPixelInfo(image,&pixel);
           for (y=0; y < (ssize_t) image->rows; y++)
           {
             register Quantum
               *magick_restrict q;
 
             q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,
               exception);
             if (q == (Quantum *) NULL)
               break;
             for (x=0; x < (ssize_t) image->columns; x++)
             {
               if (GetPixelWriteMask(image,q) <= (QuantumRange/2))
                 {
                   q+=GetPixelChannels(image);
                   continue;
                 }
               GetFillColor(draw_info,x,y,&pixel,exception);
               SetPixelViaPixelInfo(image,&pixel,q);
               q+=GetPixelChannels(image);
             }
             sync=SyncCacheViewAuthenticPixels(image_view,exception);
             if (sync == MagickFalse)
               break;
           }
           break;
         }
       }
       break;
     }
     case ImagePrimitive:
     {
       AffineMatrix
         affine;
 
       char
         composite_geometry[MagickPathExtent];
 
       Image
         *composite_image;
 
       ImageInfo
         *clone_info;
 
       RectangleInfo
         geometry;
 
       ssize_t
         x1,
         y1;
 
       if (primitive_info->text == (char *) NULL)
         break;
       clone_info=AcquireImageInfo();
       if (LocaleNCompare(primitive_info->text,"data:",5) == 0)
         composite_image=ReadInlineImage(clone_info,primitive_info->text,
           exception);
       else
         {
           (void) CopyMagickString(clone_info->filename,primitive_info->text,
             MagickPathExtent);
           composite_image=ReadImage(clone_info,exception);
         }
       clone_info=DestroyImageInfo(clone_info);
       if (composite_image == (Image *) NULL)
         break;
       (void) SetImageProgressMonitor(composite_image,(MagickProgressMonitor)
         NULL,(void *) NULL);
       x1=(ssize_t) ceil(primitive_info[1].point.x-0.5);
       y1=(ssize_t) ceil(primitive_info[1].point.y-0.5);
       if (((x1 != 0L) && (x1 != (ssize_t) composite_image->columns)) ||
           ((y1 != 0L) && (y1 != (ssize_t) composite_image->rows)))
         {
           /*
             Resize image.
           */
           (void) FormatLocaleString(composite_geometry,MagickPathExtent,
             "%gx%g!",primitive_info[1].point.x,primitive_info[1].point.y);
           composite_image->filter=image->filter;
           (void) TransformImage(&composite_image,(char *) NULL,
             composite_geometry,exception);
         }
       if (composite_image->alpha_trait == UndefinedPixelTrait)
         (void) SetImageAlphaChannel(composite_image,OpaqueAlphaChannel,
           exception);
       if (draw_info->alpha != OpaqueAlpha)
         (void) SetImageAlpha(composite_image,draw_info->alpha,exception);
       SetGeometry(image,&geometry);
       image->gravity=draw_info->gravity;
       geometry.x=x;
       geometry.y=y;
       (void) FormatLocaleString(composite_geometry,MagickPathExtent,
         "%.20gx%.20g%+.20g%+.20g",(double) composite_image->columns,(double)
         composite_image->rows,(double) geometry.x,(double) geometry.y);
       (void) ParseGravityGeometry(image,composite_geometry,&geometry,exception);
       affine=draw_info->affine;
       affine.tx=(double) geometry.x;
       affine.ty=(double) geometry.y;
       composite_image->interpolate=image->interpolate;
       status&=DrawAffineImage(image,composite_image,&affine,exception);
       composite_image=DestroyImage(composite_image);
       break;
     }
     case PointPrimitive:
     {
       PixelInfo
         fill_color;
 
       register Quantum
         *q;
 
       if ((y < 0) || (y >= (ssize_t) image->rows))
         break;
       if ((x < 0) || (x >= (ssize_t) image->columns))
         break;
       q=GetCacheViewAuthenticPixels(image_view,x,y,1,1,exception);
       if (q == (Quantum *) NULL)
         break;
       GetFillColor(draw_info,x,y,&fill_color,exception);
       CompositePixelOver(image,&fill_color,(double) fill_color.alpha,q,
         (double) GetPixelAlpha(image,q),q);
       (void) SyncCacheViewAuthenticPixels(image_view,exception);
       break;
     }
     case TextPrimitive:
     {
       char
         geometry[MagickPathExtent];
 
       DrawInfo
         *clone_info;
 
       if (primitive_info->text == (char *) NULL)
         break;
       clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
       (void) CloneString(&clone_info->text,primitive_info->text);
       (void) FormatLocaleString(geometry,MagickPathExtent,"%+f%+f",
         primitive_info->point.x,primitive_info->point.y);
       (void) CloneString(&clone_info->geometry,geometry);
       status&=AnnotateImage(image,clone_info,exception);
       clone_info=DestroyDrawInfo(clone_info);
       break;
     }
     default:
     {
       double
         mid,
         scale;
 
       DrawInfo
         *clone_info;
 
       if (IsEventLogging() != MagickFalse)
         LogPrimitiveInfo(primitive_info);
       scale=ExpandAffine(&draw_info->affine);
       if ((draw_info->dash_pattern != (double *) NULL) &&
           (fabs(draw_info->dash_pattern[0]) >= DrawEpsilon) &&
           (fabs(scale*draw_info->stroke_width) >= DrawEpsilon) &&
           (draw_info->stroke.alpha != (Quantum) TransparentAlpha))
         {
           /*
             Draw dash polygon.
           */
           clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
           clone_info->stroke_width=0.0;
           clone_info->stroke.alpha=(MagickRealType) TransparentAlpha;
           status&=DrawPolygonPrimitive(image,clone_info,primitive_info,
             exception);
           clone_info=DestroyDrawInfo(clone_info);
           (void) DrawDashPolygon(draw_info,primitive_info,image,exception);
           break;
         }
-      mid=ExpandAffine(&draw_info->affine)*draw_info->stroke_width/2.0;
+      mid=ExpandAffine(&draw_info->affine)*SaneStrokeWidth(image,draw_info)/2.0;
       if ((mid > 1.0) &&
           ((draw_info->stroke.alpha != (Quantum) TransparentAlpha) ||
            (draw_info->stroke_pattern != (Image *) NULL)))
         {
           MagickBooleanType
             closed_path;
 
           /*
             Draw strokes while respecting line cap/join attributes.
           */
           for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++) ;
-          closed_path=
-            (fabs(primitive_info[i-1].point.x-primitive_info[0].point.x) < DrawEpsilon) &&
-            (fabs(primitive_info[i-1].point.y-primitive_info[0].point.y) < DrawEpsilon) ?
-            MagickTrue : MagickFalse;
+          closed_path=primitive_info[0].closed_subpath;
           i=(ssize_t) primitive_info[0].coordinates;
           if ((((draw_info->linecap == RoundCap) ||
                 (closed_path != MagickFalse)) &&
                (draw_info->linejoin == RoundJoin)) ||
                (primitive_info[i].primitive != UndefinedPrimitive))
             {
               (void) DrawPolygonPrimitive(image,draw_info,primitive_info,
                 exception);
               break;
             }
           clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
           clone_info->stroke_width=0.0;
           clone_info->stroke.alpha=(MagickRealType) TransparentAlpha;
           status&=DrawPolygonPrimitive(image,clone_info,primitive_info,
             exception);
           clone_info=DestroyDrawInfo(clone_info);
           status&=DrawStrokePolygon(image,draw_info,primitive_info,exception);
           break;
         }
       status&=DrawPolygonPrimitive(image,draw_info,primitive_info,exception);
       break;
     }
   }
   image_view=DestroyCacheView(image_view);
   if (draw_info->compliance == SVGCompliance)
     status&=SetImageMask(image,WritePixelMask,(Image *) NULL,exception);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(DrawEvent,GetMagickModule(),"  end draw-primitive");
   return(status != 0 ? MagickTrue : MagickFalse);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 +   D r a w S t r o k e P o l y g o n                                         %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  DrawStrokePolygon() draws a stroked polygon (line, rectangle, ellipse) on
 %  the image while respecting the line cap and join attributes.
 %
 %  The format of the DrawStrokePolygon method is:
 %
 %      MagickBooleanType DrawStrokePolygon(Image *image,
 %        const DrawInfo *draw_info,const PrimitiveInfo *primitive_info)
 %
 %  A description of each parameter follows:
 %
 %    o image: the image.
 %
 %    o draw_info: the draw info.
 %
 %    o primitive_info: Specifies a pointer to a PrimitiveInfo structure.
 %
 %
 */
@@ -5223,89 +5246,90 @@ static void DrawRoundLinecap(Image *image,const DrawInfo *draw_info,
 static MagickBooleanType DrawStrokePolygon(Image *image,
   const DrawInfo *draw_info,const PrimitiveInfo *primitive_info,
   ExceptionInfo *exception)
 {
   DrawInfo
     *clone_info;
 
   MagickBooleanType
     closed_path;
 
   MagickStatusType
     status;
 
   PrimitiveInfo
     *stroke_polygon;
 
   register const PrimitiveInfo
     *p,
     *q;
 
   /*
     Draw stroked polygon.
   */
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(DrawEvent,GetMagickModule(),
       "    begin draw-stroke-polygon");
   clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
   clone_info->fill=draw_info->stroke;
   if (clone_info->fill_pattern != (Image *) NULL)
     clone_info->fill_pattern=DestroyImage(clone_info->fill_pattern);
   if (clone_info->stroke_pattern != (Image *) NULL)
     clone_info->fill_pattern=CloneImage(clone_info->stroke_pattern,0,0,
       MagickTrue,exception);
   clone_info->stroke.alpha=(MagickRealType) TransparentAlpha;
   clone_info->stroke_width=0.0;
   clone_info->fill_rule=NonZeroRule;
   status=MagickTrue;
   for (p=primitive_info; p->primitive != UndefinedPrimitive; p+=p->coordinates)
   {
-    stroke_polygon=TraceStrokePolygon(draw_info,p);
+    if (p->coordinates == 1)
+      continue;
+    stroke_polygon=TraceStrokePolygon(image,draw_info,p);
     if (stroke_polygon == (PrimitiveInfo *) NULL)
       {
         status=0;
         stroke_polygon=(PrimitiveInfo *) RelinquishMagickMemory(stroke_polygon);
         break;
       }
     status&=DrawPolygonPrimitive(image,clone_info,stroke_polygon,exception);
     stroke_polygon=(PrimitiveInfo *) RelinquishMagickMemory(stroke_polygon);
     if (status == 0)
       break;
     q=p+p->coordinates-1;
-    closed_path=(fabs(q->point.x-p->point.x) < DrawEpsilon) &&
-      (fabs(q->point.y-p->point.y) < DrawEpsilon) ? MagickTrue : MagickFalse;
+    closed_path=p->closed_subpath;
     if ((draw_info->linecap == RoundCap) && (closed_path == MagickFalse))
       {
         DrawRoundLinecap(image,draw_info,p,exception);
         DrawRoundLinecap(image,draw_info,q,exception);
       }
   }
   clone_info=DestroyDrawInfo(clone_info);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(DrawEvent,GetMagickModule(),
       "    end draw-stroke-polygon");
   return(status != 0 ? MagickTrue : MagickFalse);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   G e t A f f i n e M a t r i x                                             %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  GetAffineMatrix() returns an AffineMatrix initialized to the identity
 %  matrix.
 %
 %  The format of the GetAffineMatrix method is:
 %
 %      void GetAffineMatrix(AffineMatrix *affine_matrix)
 %
 %  A description of each parameter follows:
 %
 %    o affine_matrix: the affine matrix.
 %
 */
@@ -5529,131 +5553,132 @@ static void TraceArc(PrimitiveInfo *primitive_info,const PointInfo start,
 static void TraceArcPath(PrimitiveInfo *primitive_info,const PointInfo start,
   const PointInfo end,const PointInfo arc,const double angle,
   const MagickBooleanType large_arc,const MagickBooleanType sweep)
 {
   double
     alpha,
     beta,
     delta,
     factor,
     gamma,
     theta;
 
   PointInfo
     center,
     points[3],
     radii;
 
   register double
     cosine,
     sine;
 
   register PrimitiveInfo
     *p;
 
   register ssize_t
     i;
 
   size_t
     arc_segments;
 
   if ((fabs(start.x-end.x) < DrawEpsilon) &&
       (fabs(start.y-end.y) < DrawEpsilon))
     {
       TracePoint(primitive_info,end);
       return;
     }
   radii.x=fabs(arc.x);
   radii.y=fabs(arc.y);
   if ((fabs(radii.x) < DrawEpsilon) || (fabs(radii.y) < DrawEpsilon))
     {
       TraceLine(primitive_info,start,end);
       return;
     }
   cosine=cos(DegreesToRadians(fmod((double) angle,360.0)));
   sine=sin(DegreesToRadians(fmod((double) angle,360.0)));
   center.x=(double) (cosine*(end.x-start.x)/2+sine*(end.y-start.y)/2);
   center.y=(double) (cosine*(end.y-start.y)/2-sine*(end.x-start.x)/2);
   delta=(center.x*center.x)/(radii.x*radii.x)+(center.y*center.y)/
     (radii.y*radii.y);
   if (delta < DrawEpsilon)
     {
       TraceLine(primitive_info,start,end);
       return;
     }
   if (delta > 1.0)
     {
       radii.x*=sqrt((double) delta);
       radii.y*=sqrt((double) delta);
     }
   points[0].x=(double) (cosine*start.x/radii.x+sine*start.y/radii.x);
   points[0].y=(double) (cosine*start.y/radii.y-sine*start.x/radii.y);
   points[1].x=(double) (cosine*end.x/radii.x+sine*end.y/radii.x);
   points[1].y=(double) (cosine*end.y/radii.y-sine*end.x/radii.y);
   alpha=points[1].x-points[0].x;
   beta=points[1].y-points[0].y;
   factor=PerceptibleReciprocal(alpha*alpha+beta*beta)-0.25;
   if (factor <= 0.0)
     factor=0.0;
   else
     {
       factor=sqrt((double) factor);
       if (sweep == large_arc)
         factor=(-factor);
     }
   center.x=(double) ((points[0].x+points[1].x)/2-factor*beta);
   center.y=(double) ((points[0].y+points[1].y)/2+factor*alpha);
   alpha=atan2(points[0].y-center.y,points[0].x-center.x);
   theta=atan2(points[1].y-center.y,points[1].x-center.x)-alpha;
   if ((theta < 0.0) && (sweep != MagickFalse))
     theta+=2.0*MagickPI;
   else
     if ((theta > 0.0) && (sweep == MagickFalse))
       theta-=2.0*MagickPI;
   arc_segments=(size_t) ceil(fabs((double) (theta/(0.5*MagickPI+DrawEpsilon))));
   p=primitive_info;
   for (i=0; i < (ssize_t) arc_segments; i++)
   {
     beta=0.5*((alpha+(i+1)*theta/arc_segments)-(alpha+i*theta/arc_segments));
     gamma=(8.0/3.0)*sin(fmod((double) (0.5*beta),DegreesToRadians(360.0)))*
       sin(fmod((double) (0.5*beta),DegreesToRadians(360.0)))/
       sin(fmod((double) beta,DegreesToRadians(360.0)));
     points[0].x=(double) (center.x+cos(fmod((double) (alpha+(double) i*theta/
       arc_segments),DegreesToRadians(360.0)))-gamma*sin(fmod((double) (alpha+
       (double) i*theta/arc_segments),DegreesToRadians(360.0))));
     points[0].y=(double) (center.y+sin(fmod((double) (alpha+(double) i*theta/
       arc_segments),DegreesToRadians(360.0)))+gamma*cos(fmod((double) (alpha+
       (double) i*theta/arc_segments),DegreesToRadians(360.0))));
     points[2].x=(double) (center.x+cos(fmod((double) (alpha+(double) (i+1)*
       theta/arc_segments),DegreesToRadians(360.0))));
     points[2].y=(double) (center.y+sin(fmod((double) (alpha+(double) (i+1)*
       theta/arc_segments),DegreesToRadians(360.0))));
     points[1].x=(double) (points[2].x+gamma*sin(fmod((double) (alpha+(double)
       (i+1)*theta/arc_segments),DegreesToRadians(360.0))));
     points[1].y=(double) (points[2].y-gamma*cos(fmod((double) (alpha+(double)
       (i+1)*theta/arc_segments),DegreesToRadians(360.0))));
     p->point.x=(p == primitive_info) ? start.x : (p-1)->point.x;
     p->point.y=(p == primitive_info) ? start.y : (p-1)->point.y;
     (p+1)->point.x=(double) (cosine*radii.x*points[0].x-sine*radii.y*
       points[0].y);
     (p+1)->point.y=(double) (sine*radii.x*points[0].x+cosine*radii.y*
       points[0].y);
     (p+2)->point.x=(double) (cosine*radii.x*points[1].x-sine*radii.y*
       points[1].y);
     (p+2)->point.y=(double) (sine*radii.x*points[1].x+cosine*radii.y*
       points[1].y);
     (p+3)->point.x=(double) (cosine*radii.x*points[2].x-sine*radii.y*
       points[2].y);
     (p+3)->point.y=(double) (sine*radii.x*points[2].x+cosine*radii.y*
       points[2].y);
     if (i == (ssize_t) (arc_segments-1))
       (p+3)->point=end;
     TraceBezier(p,4);
     p+=p->coordinates;
   }
   primitive_info->coordinates=(size_t) (p-primitive_info);
+  primitive_info->closed_subpath=MagickFalse;
   for (i=0; i < (ssize_t) primitive_info->coordinates; i++)
   {
     p->primitive=primitive_info->primitive;
     p--;
   }
 }
@@ -5661,92 +5686,93 @@ static void TraceArcPath(PrimitiveInfo *primitive_info,const PointInfo start,
 static void TraceBezier(PrimitiveInfo *primitive_info,
   const size_t number_coordinates)
 {
   double
     alpha,
     *coefficients,
     weight;
 
   PointInfo
     end,
     point,
     *points;
 
   register PrimitiveInfo
     *p;
 
   register ssize_t
     i,
     j;
 
   size_t
     control_points,
     quantum;
 
   /*
     Allocate coeficients.
   */
   quantum=number_coordinates;
   for (i=0; i < (ssize_t) number_coordinates; i++)
   {
     for (j=i+1; j < (ssize_t) number_coordinates; j++)
     {
       alpha=fabs(primitive_info[j].point.x-primitive_info[i].point.x);
       if (alpha > (double) quantum)
         quantum=(size_t) alpha;
       alpha=fabs(primitive_info[j].point.y-primitive_info[i].point.y);
       if (alpha > (double) quantum)
         quantum=(size_t) alpha;
     }
   }
   quantum=(size_t) MagickMin((double) quantum/number_coordinates,
     (double) BezierQuantum);
   control_points=quantum*number_coordinates;
   coefficients=(double *) AcquireQuantumMemory((size_t)
     number_coordinates,sizeof(*coefficients));
   points=(PointInfo *) AcquireQuantumMemory((size_t) control_points,
     sizeof(*points));
   if ((coefficients == (double *) NULL) || (points == (PointInfo *) NULL))
     ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
   /*
     Compute bezier points.
   */
   end=primitive_info[number_coordinates-1].point;
   for (i=0; i < (ssize_t) number_coordinates; i++)
     coefficients[i]=Permutate((ssize_t) number_coordinates-1,i);
   weight=0.0;
   for (i=0; i < (ssize_t) control_points; i++)
   {
     p=primitive_info;
     point.x=0.0;
     point.y=0.0;
     alpha=pow((double) (1.0-weight),(double) number_coordinates-1.0);
     for (j=0; j < (ssize_t) number_coordinates; j++)
     {
       point.x+=alpha*coefficients[j]*p->point.x;
       point.y+=alpha*coefficients[j]*p->point.y;
       alpha*=weight/(1.0-weight);
       p++;
     }
     points[i]=point;
     weight+=1.0/control_points;
   }
   /*
     Bezier curves are just short segmented polys.
   */
   p=primitive_info;
   for (i=0; i < (ssize_t) control_points; i++)
   {
     TracePoint(p,points[i]);
     p+=p->coordinates;
   }
   TracePoint(p,end);
   p+=p->coordinates;
   primitive_info->coordinates=(size_t) (p-primitive_info);
+  primitive_info->closed_subpath=MagickFalse;
   for (i=0; i < (ssize_t) primitive_info->coordinates; i++)
   {
     p->primitive=primitive_info->primitive;
     p--;
   }
   points=(PointInfo *) RelinquishMagickMemory(points);
   coefficients=(double *) RelinquishMagickMemory(coefficients);
 }
@@ -5776,51 +5802,59 @@ static void TraceCircle(PrimitiveInfo *primitive_info,const PointInfo start,
 static void TraceEllipse(PrimitiveInfo *primitive_info,const PointInfo center,
   const PointInfo radii,const PointInfo arc)
 {
   double
     delta,
     step,
+    x,
     y;
 
   PointInfo
     angle,
     point;
 
   register PrimitiveInfo
     *p;
 
   register ssize_t
     i;
 
   /*
     Ellipses are just short segmented polys.
   */
   primitive_info->coordinates=0;
-  if ((fabs(radii.x) < MagickEpsilon) || (fabs(radii.y) < MagickEpsilon))
+  if ((fabs(radii.x) < DrawEpsilon) || (fabs(radii.y) < DrawEpsilon))
     return;
   delta=2.0*PerceptibleReciprocal(MagickMax(radii.x,radii.y));
   step=MagickPI/8.0;
   if ((delta >= 0.0) && (delta < (MagickPI/8.0)))
     step=MagickPI/(4.0*(MagickPI*PerceptibleReciprocal(delta)/2.0));
   angle.x=DegreesToRadians(arc.x);
   y=arc.y;
   while (y < arc.x)
     y+=360.0;
   angle.y=DegreesToRadians(y);
   for (p=primitive_info; angle.x < angle.y; angle.x+=step)
   {
     point.x=cos(fmod(angle.x,DegreesToRadians(360.0)))*radii.x+center.x;
     point.y=sin(fmod(angle.x,DegreesToRadians(360.0)))*radii.y+center.y;
     TracePoint(p,point);
     p+=p->coordinates;
   }
   point.x=cos(fmod(angle.y,DegreesToRadians(360.0)))*radii.x+center.x;
   point.y=sin(fmod(angle.y,DegreesToRadians(360.0)))*radii.y+center.y;
   TracePoint(p,point);
   p+=p->coordinates;
   primitive_info->coordinates=(size_t) (p-primitive_info);
+  primitive_info->closed_subpath=MagickFalse;
+  x=fabs(primitive_info[0].point.x-
+    primitive_info[primitive_info->coordinates-1].point.x);
+  y=fabs(primitive_info[0].point.y-
+    primitive_info[primitive_info->coordinates-1].point.y);
+  if ((x <= DrawEpsilon) && (y <= DrawEpsilon))
+    primitive_info->closed_subpath=MagickTrue;
   for (i=0; i < (ssize_t) primitive_info->coordinates; i++)
   {
     p->primitive=primitive_info->primitive;
     p--;
   }
 }
@@ -5828,479 +5862,480 @@ static void TraceEllipse(PrimitiveInfo *primitive_info,const PointInfo center,
 static void TraceLine(PrimitiveInfo *primitive_info,const PointInfo start,
   const PointInfo end)
 {
   TracePoint(primitive_info,start);
   if ((fabs(start.x-end.x) < DrawEpsilon) &&
       (fabs(start.y-end.y) < DrawEpsilon))
     {
       primitive_info->primitive=PointPrimitive;
       primitive_info->coordinates=1;
       return;
     }
   TracePoint(primitive_info+1,end);
   (primitive_info+1)->primitive=primitive_info->primitive;
   primitive_info->coordinates=2;
+  primitive_info->closed_subpath=MagickFalse;
 }
 
 static size_t TracePath(PrimitiveInfo *primitive_info,const char *path,
   ExceptionInfo *exception)
 {
   char
     *next_token,
     token[MagickPathExtent];
 
   const char
     *p;
 
   double
     x,
     y;
 
   int
     attribute,
     last_attribute;
 
   MagickBooleanType
     status;
 
   PointInfo
     end = {0.0, 0.0},
     points[4] = { {0.0,0.0}, {0.0,0.0}, {0.0,0.0}, {0.0,0.0} },
     point = {0.0, 0.0},
     start = {0.0, 0.0};
 
   PrimitiveType
     primitive_type;
 
   register PrimitiveInfo
     *q;
 
   register ssize_t
     i;
 
   size_t
     number_coordinates,
     z_count;
 
   status=MagickTrue;
   attribute=0;
   number_coordinates=0;
   z_count=0;
   primitive_type=primitive_info->primitive;
   q=primitive_info;
   for (p=path; *p != '\0'; )
   {
     if (status == MagickFalse)
       break;
     while (isspace((int) ((unsigned char) *p)) != 0)
       p++;
     if (*p == '\0')
       break;
     last_attribute=attribute;
     attribute=(int) (*p++);
     switch (attribute)
     {
       case 'a':
       case 'A':
       {
         double
           angle;
 
         MagickBooleanType
           large_arc,
           sweep;
 
         PointInfo
           arc;
 
         /*
           Elliptical arc.
         */
         do
         {
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           arc.x=StringToDouble(token,&next_token);
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           arc.y=StringToDouble(token,&next_token);
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           angle=StringToDouble(token,&next_token);
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           large_arc=StringToLong(token) != 0 ? MagickTrue : MagickFalse;
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           sweep=StringToLong(token) != 0 ? MagickTrue : MagickFalse;
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           x=StringToDouble(token,&next_token);
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           y=StringToDouble(token,&next_token);
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           end.x=(double) (attribute == (int) 'A' ? x : point.x+x);
           end.y=(double) (attribute == (int) 'A' ? y : point.y+y);
-          TraceArcPath(q,point,end,arc,angle,large_arc,sweep);
+          if ((fabs(end.x-point.x) >= DrawEpsilon) ||
+              (fabs(end.y-point.y) >= DrawEpsilon))
+            TraceArcPath(q,point,end,arc,angle,large_arc,sweep);
+          else
+            TracePoint(q,end);
           q+=q->coordinates;
           point=end;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 'c':
       case 'C':
       {
         /*
           Cubic Bézier curve.
         */
         do
         {
           points[0]=point;
           for (i=1; i < 4; i++)
           {
             GetNextToken(p,&p,MagickPathExtent,token);
             if (*token == ',')
               GetNextToken(p,&p,MagickPathExtent,token);
             x=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(p,&p,MagickPathExtent,token);
             if (*token == ',')
               GetNextToken(p,&p,MagickPathExtent,token);
             y=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             end.x=(double) (attribute == (int) 'C' ? x : point.x+x);
             end.y=(double) (attribute == (int) 'C' ? y : point.y+y);
             points[i]=end;
           }
           for (i=0; i < 4; i++)
             (q+i)->point=points[i];
           TraceBezier(q,4);
           q+=q->coordinates;
           point=end;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 'H':
       case 'h':
       {
         do
         {
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           x=StringToDouble(token,&next_token);
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           point.x=(double) (attribute == (int) 'H' ? x: point.x+x);
           TracePoint(q,point);
           q+=q->coordinates;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 'l':
       case 'L':
       {
         /*
           Line to.
         */
         do
         {
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           x=StringToDouble(token,&next_token);
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           y=StringToDouble(token,&next_token);
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           point.x=(double) (attribute == (int) 'L' ? x : point.x+x);
           point.y=(double) (attribute == (int) 'L' ? y : point.y+y);
           TracePoint(q,point);
           q+=q->coordinates;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 'M':
       case 'm':
       {
         /*
           Move to;
         */
         if (q != primitive_info)
           {
             primitive_info->coordinates=(size_t) (q-primitive_info);
             number_coordinates+=primitive_info->coordinates;
             primitive_info=q;
           }
         i=0;
         do
         {
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           x=StringToDouble(token,&next_token);
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           y=StringToDouble(token,&next_token);
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           point.x=(double) (attribute == (int) 'M' ? x : point.x+x);
           point.y=(double) (attribute == (int) 'M' ? y : point.y+y);
           if (i == 0)
             start=point;
           i++;
           TracePoint(q,point);
           q+=q->coordinates;
-          if ((i != 0) && (attribute == (int) 'M'))
-            {
-              TracePoint(q,point);
-              q+=q->coordinates;
-            }
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 'q':
       case 'Q':
       {
         /*
           Quadratic Bézier curve.
         */
         do
         {
           points[0]=point;
           for (i=1; i < 3; i++)
           {
             GetNextToken(p,&p,MagickPathExtent,token);
             if (*token == ',')
               GetNextToken(p,&p,MagickPathExtent,token);
             x=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(p,&p,MagickPathExtent,token);
             if (*token == ',')
               GetNextToken(p,&p,MagickPathExtent,token);
             y=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             if (*p == ',')
               p++;
             end.x=(double) (attribute == (int) 'Q' ? x : point.x+x);
             end.y=(double) (attribute == (int) 'Q' ? y : point.y+y);
             points[i]=end;
           }
           for (i=0; i < 3; i++)
             (q+i)->point=points[i];
           TraceBezier(q,3);
           q+=q->coordinates;
           point=end;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 's':
       case 'S':
       {
         /*
           Cubic Bézier curve.
         */
         do
         {
           points[0]=points[3];
           points[1].x=2.0*points[3].x-points[2].x;
           points[1].y=2.0*points[3].y-points[2].y;
           for (i=2; i < 4; i++)
           {
             GetNextToken(p,&p,MagickPathExtent,token);
             if (*token == ',')
               GetNextToken(p,&p,MagickPathExtent,token);
             x=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(p,&p,MagickPathExtent,token);
             if (*token == ',')
               GetNextToken(p,&p,MagickPathExtent,token);
             y=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             if (*p == ',')
               p++;
             end.x=(double) (attribute == (int) 'S' ? x : point.x+x);
             end.y=(double) (attribute == (int) 'S' ? y : point.y+y);
             points[i]=end;
           }
           if (strchr("CcSs",last_attribute) == (char *) NULL)
             {
               points[0]=point;
               points[1]=point;
             }
           for (i=0; i < 4; i++)
             (q+i)->point=points[i];
           TraceBezier(q,4);
           q+=q->coordinates;
           point=end;
           last_attribute=attribute;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 't':
       case 'T':
       {
         /*
           Quadratic Bézier curve.
         */
         do
         {
           points[0]=points[2];
           points[1].x=2.0*points[2].x-points[1].x;
           points[1].y=2.0*points[2].y-points[1].y;
           for (i=2; i < 3; i++)
           {
             GetNextToken(p,&p,MagickPathExtent,token);
             if (*token == ',')
               GetNextToken(p,&p,MagickPathExtent,token);
             x=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(p,&p,MagickPathExtent,token);
             if (*token == ',')
               GetNextToken(p,&p,MagickPathExtent,token);
             y=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             end.x=(double) (attribute == (int) 'T' ? x : point.x+x);
             end.y=(double) (attribute == (int) 'T' ? y : point.y+y);
             points[i]=end;
           }
           if (status == MagickFalse)
             break;
           if (strchr("QqTt",last_attribute) == (char *) NULL)
             {
               points[0]=point;
               points[1]=point;
             }
           for (i=0; i < 3; i++)
             (q+i)->point=points[i];
           TraceBezier(q,3);
           q+=q->coordinates;
           point=end;
           last_attribute=attribute;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 'v':
       case 'V':
       {
         /*
           Line to.
         */
         do
         {
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           y=StringToDouble(token,&next_token);
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           point.y=(double) (attribute == (int) 'V' ? y : point.y+y);
           TracePoint(q,point);
           q+=q->coordinates;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 'z':
       case 'Z':
       {
         /*
           Close path.
         */
         point=start;
         TracePoint(q,point);
         q+=q->coordinates;
         primitive_info->coordinates=(size_t) (q-primitive_info);
+        primitive_info->closed_subpath=MagickTrue;
         number_coordinates+=primitive_info->coordinates;
         primitive_info=q;
         z_count++;
         break;
       }
       default:
       {
         if (isalpha((int) ((unsigned char) attribute)) != 0)
           ThrowPointExpectedException(token,exception);
         break;
       }
     }
   }
   if (status == MagickFalse)
     return(0);
   primitive_info->coordinates=(size_t) (q-primitive_info);
   number_coordinates+=primitive_info->coordinates;
   for (i=0; i < (ssize_t) number_coordinates; i++)
   {
     q--;
     q->primitive=primitive_type;
     if (z_count > 1)
       q->method=FillToBorderMethod;
   }
   q=primitive_info;
   return(number_coordinates);
 }
@@ -6308,40 +6343,41 @@ static size_t TracePath(PrimitiveInfo *primitive_info,const char *path,
 static void TraceRectangle(PrimitiveInfo *primitive_info,const PointInfo start,
   const PointInfo end)
 {
   PointInfo
     point;
 
   register PrimitiveInfo
     *p;
 
   register ssize_t
     i;
 
   if ((fabs(start.x-end.x) < DrawEpsilon) ||
       (fabs(start.y-end.y) < DrawEpsilon))
     {
       primitive_info->coordinates=0;
       return;
     }
   p=primitive_info;
   TracePoint(p,start);
   p+=p->coordinates;
   point.x=start.x;
   point.y=end.y;
   TracePoint(p,point);
   p+=p->coordinates;
   TracePoint(p,end);
   p+=p->coordinates;
   point.x=end.x;
   point.y=start.y;
   TracePoint(p,point);
   p+=p->coordinates;
   TracePoint(p,start);
   p+=p->coordinates;
   primitive_info->coordinates=(size_t) (p-primitive_info);
+  primitive_info->closed_subpath=MagickTrue;
   for (i=0; i < (ssize_t) primitive_info->coordinates; i++)
   {
     p->primitive=primitive_info->primitive;
     p--;
   }
 }
@@ -6349,59 +6385,60 @@ static void TraceRectangle(PrimitiveInfo *primitive_info,const PointInfo start,
 static void TraceRoundRectangle(PrimitiveInfo *primitive_info,
   const PointInfo start,const PointInfo end,PointInfo arc)
 {
   PointInfo
     degrees,
     offset,
     point;
 
   register PrimitiveInfo
     *p;
 
   register ssize_t
     i;
 
   offset.x=fabs(end.x-start.x);
   offset.y=fabs(end.y-start.y);
   if ((offset.x < DrawEpsilon) || (offset.y < DrawEpsilon))
     {
       primitive_info->coordinates=0;
       return;
     }
   p=primitive_info;
   if (arc.x > (0.5*offset.x))
     arc.x=0.5*offset.x;
   if (arc.y > (0.5*offset.y))
     arc.y=0.5*offset.y;
   point.x=start.x+offset.x-arc.x;
   point.y=start.y+arc.y;
   degrees.x=270.0;
   degrees.y=360.0;
   TraceEllipse(p,point,arc,degrees);
   p+=p->coordinates;
   point.x=start.x+offset.x-arc.x;
   point.y=start.y+offset.y-arc.y;
   degrees.x=0.0;
   degrees.y=90.0;
   TraceEllipse(p,point,arc,degrees);
   p+=p->coordinates;
   point.x=start.x+arc.x;
   point.y=start.y+offset.y-arc.y;
   degrees.x=90.0;
   degrees.y=180.0;
   TraceEllipse(p,point,arc,degrees);
   p+=p->coordinates;
   point.x=start.x+arc.x;
   point.y=start.y+arc.y;
   degrees.x=180.0;
   degrees.y=270.0;
   TraceEllipse(p,point,arc,degrees);
   p+=p->coordinates;
   TracePoint(p,primitive_info->point);
   p+=p->coordinates;
   primitive_info->coordinates=(size_t) (p-primitive_info);
+  primitive_info->closed_subpath=MagickTrue;
   for (i=0; i < (ssize_t) primitive_info->coordinates; i++)
   {
     p->primitive=primitive_info->primitive;
     p--;
   }
 }
@@ -6454,454 +6491,469 @@ static void TraceSquareLinecap(PrimitiveInfo *primitive_info,
     dy*(distance+offset)/distance);
 }
 
-static PrimitiveInfo *TraceStrokePolygon(const DrawInfo *draw_info,
-  const PrimitiveInfo *primitive_info)
+static PrimitiveInfo *TraceStrokePolygon(const Image *image,
+  const DrawInfo *draw_info,const PrimitiveInfo *primitive_info)
 {
   typedef struct _LineSegment
   {
     double
       p,
       q;
   } LineSegment;
 
   double
     delta_theta,
     dot_product,
     mid,
     miterlimit;
 
   LineSegment
-    dx,
-    dy,
-    inverse_slope,
-    slope,
-    theta;
+    dx = {0,0},
+    dy = {0,0},
+    inverse_slope = {0,0},
+    slope = {0,0},
+    theta = {0,0};
 
   MagickBooleanType
     closed_path;
 
   PointInfo
     box_p[5],
     box_q[5],
     center,
     offset,
     *path_p,
     *path_q;
 
   PrimitiveInfo
     *polygon_primitive,
     *stroke_polygon;
 
   register ssize_t
     i;
 
   size_t
     arc_segments,
     max_strokes,
     number_vertices;
 
   ssize_t
     j,
     n,
     p,
     q;
 
   /*
     Allocate paths.
   */
   number_vertices=primitive_info->coordinates;
   max_strokes=2*number_vertices+6*BezierQuantum+360;
-  path_p=(PointInfo *) AcquireQuantumMemory((size_t) max_strokes,
-    sizeof(*path_p));
-  path_q=(PointInfo *) AcquireQuantumMemory((size_t) max_strokes,
-    sizeof(*path_q));
   polygon_primitive=(PrimitiveInfo *) AcquireQuantumMemory((size_t)
     number_vertices+2UL,sizeof(*polygon_primitive));
-  if ((path_p == (PointInfo *) NULL) || (path_q == (PointInfo *) NULL) ||
-      (polygon_primitive == (PrimitiveInfo *) NULL))
-    {
-      if (path_p != (PointInfo *) NULL)
-        path_p=(PointInfo *) RelinquishMagickMemory(path_p);
-      if (path_q != (PointInfo *) NULL)
-        path_q=(PointInfo *) RelinquishMagickMemory(path_q);
-      if (polygon_primitive != (PrimitiveInfo *) NULL)
-        polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(
-          polygon_primitive);
-      return((PrimitiveInfo *) NULL);
-    }
+  if (polygon_primitive == (PrimitiveInfo *) NULL)
+    return((PrimitiveInfo *) NULL);
   (void) memcpy(polygon_primitive,primitive_info,(size_t)
     number_vertices*sizeof(*polygon_primitive));
-  closed_path=
-    (fabs(primitive_info[number_vertices-1].point.x-primitive_info[0].point.x) < DrawEpsilon) &&
-    (fabs(primitive_info[number_vertices-1].point.y-primitive_info[0].point.y) < DrawEpsilon) ?
-    MagickTrue : MagickFalse;
+  closed_path=primitive_info[0].closed_subpath;
   if (((draw_info->linejoin == RoundJoin) ||
        (draw_info->linejoin == MiterJoin)) && (closed_path != MagickFalse))
     {
       polygon_primitive[number_vertices]=primitive_info[1];
       number_vertices++;
     }
   polygon_primitive[number_vertices].primitive=UndefinedPrimitive;
   /*
     Compute the slope for the first line segment, p.
   */
   dx.p=0.0;
   dy.p=0.0;
   for (n=1; n < (ssize_t) number_vertices; n++)
   {
     dx.p=polygon_primitive[n].point.x-polygon_primitive[0].point.x;
     dy.p=polygon_primitive[n].point.y-polygon_primitive[0].point.y;
     if ((fabs(dx.p) >= DrawEpsilon) || (fabs(dy.p) >= DrawEpsilon))
       break;
   }
   if (n == (ssize_t) number_vertices)
-    n=(ssize_t) number_vertices-1L;
+    {
+      if ((draw_info->linecap != RoundCap) || (closed_path != MagickFalse))
+        {
+          /*
+            Zero length subpath.
+          */
+          stroke_polygon=(PrimitiveInfo *) AcquireCriticalMemory(
+            sizeof(*stroke_polygon));
+          stroke_polygon[0]=polygon_primitive[0];
+          stroke_polygon[0].coordinates=0;
+          polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(
+            polygon_primitive);
+          return(stroke_polygon);
+        }
+      n=(ssize_t) number_vertices-1L;
+    }
+  path_p=(PointInfo *) AcquireQuantumMemory((size_t) max_strokes,
+    sizeof(*path_p));
+  if (path_p == (PointInfo *) NULL)
+    {
+      polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(
+        polygon_primitive);
+      return((PrimitiveInfo *) NULL);
+    }
+  path_q=(PointInfo *) AcquireQuantumMemory((size_t) max_strokes,
+    sizeof(*path_q));
+  if (path_q == (PointInfo *) NULL)
+    {
+      path_p=(PointInfo *) RelinquishMagickMemory(path_p);
+      polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(
+        polygon_primitive);
+      return((PrimitiveInfo *) NULL);
+    }
   slope.p=0.0;
   inverse_slope.p=0.0;
   if (fabs(dx.p) < DrawEpsilon)
     {
       if (dx.p >= 0.0)
         slope.p=dy.p < 0.0 ? -1.0/DrawEpsilon : 1.0/DrawEpsilon;
       else
         slope.p=dy.p < 0.0 ? 1.0/DrawEpsilon : -1.0/DrawEpsilon;
     }
   else
     if (fabs(dy.p) < DrawEpsilon)
       {
         if (dy.p >= 0.0)
           inverse_slope.p=dx.p < 0.0 ? -1.0/DrawEpsilon : 1.0/DrawEpsilon;
         else
           inverse_slope.p=dx.p < 0.0 ? 1.0/DrawEpsilon : -1.0/DrawEpsilon;
       }
     else
       {
         slope.p=dy.p/dx.p;
         inverse_slope.p=(-1.0/slope.p);
       }
-  mid=ExpandAffine(&draw_info->affine)*draw_info->stroke_width/2.0;
+  mid=ExpandAffine(&draw_info->affine)*SaneStrokeWidth(image,draw_info)/2.0;
   miterlimit=(double) (draw_info->miterlimit*draw_info->miterlimit*mid*mid);
   if ((draw_info->linecap == SquareCap) && (closed_path == MagickFalse))
     TraceSquareLinecap(polygon_primitive,number_vertices,mid);
   offset.x=sqrt((double) (mid*mid/(inverse_slope.p*inverse_slope.p+1.0)));
   offset.y=(double) (offset.x*inverse_slope.p);
   if ((dy.p*offset.x-dx.p*offset.y) > 0.0)
     {
       box_p[0].x=polygon_primitive[0].point.x-offset.x;
       box_p[0].y=polygon_primitive[0].point.y-offset.x*inverse_slope.p;
       box_p[1].x=polygon_primitive[n].point.x-offset.x;
       box_p[1].y=polygon_primitive[n].point.y-offset.x*inverse_slope.p;
       box_q[0].x=polygon_primitive[0].point.x+offset.x;
       box_q[0].y=polygon_primitive[0].point.y+offset.x*inverse_slope.p;
       box_q[1].x=polygon_primitive[n].point.x+offset.x;
       box_q[1].y=polygon_primitive[n].point.y+offset.x*inverse_slope.p;
     }
   else
     {
       box_p[0].x=polygon_primitive[0].point.x+offset.x;
       box_p[0].y=polygon_primitive[0].point.y+offset.y;
       box_p[1].x=polygon_primitive[n].point.x+offset.x;
       box_p[1].y=polygon_primitive[n].point.y+offset.y;
       box_q[0].x=polygon_primitive[0].point.x-offset.x;
       box_q[0].y=polygon_primitive[0].point.y-offset.y;
       box_q[1].x=polygon_primitive[n].point.x-offset.x;
       box_q[1].y=polygon_primitive[n].point.y-offset.y;
     }
   /*
     Create strokes for the line join attribute: bevel, miter, round.
   */
   p=0;
   q=0;
   path_q[p++]=box_q[0];
   path_p[q++]=box_p[0];
   for (i=(ssize_t) n+1; i < (ssize_t) number_vertices; i++)
   {
     /*
       Compute the slope for this line segment, q.
     */
     dx.q=polygon_primitive[i].point.x-polygon_primitive[n].point.x;
     dy.q=polygon_primitive[i].point.y-polygon_primitive[n].point.y;
     dot_product=dx.q*dx.q+dy.q*dy.q;
     if (dot_product < 0.25)
       continue;
     slope.q=0.0;
     inverse_slope.q=0.0;
     if (fabs(dx.q) < DrawEpsilon)
       {
         if (dx.q >= 0.0)
           slope.q=dy.q < 0.0 ? -1.0/DrawEpsilon : 1.0/DrawEpsilon;
         else
           slope.q=dy.q < 0.0 ? 1.0/DrawEpsilon : -1.0/DrawEpsilon;
       }
     else
       if (fabs(dy.q) < DrawEpsilon)
         {
           if (dy.q >= 0.0)
             inverse_slope.q=dx.q < 0.0 ? -1.0/DrawEpsilon : 1.0/DrawEpsilon;
           else
             inverse_slope.q=dx.q < 0.0 ? 1.0/DrawEpsilon : -1.0/DrawEpsilon;
         }
       else
         {
           slope.q=dy.q/dx.q;
           inverse_slope.q=(-1.0/slope.q);
         }
     offset.x=sqrt((double) (mid*mid/(inverse_slope.q*inverse_slope.q+1.0)));
     offset.y=(double) (offset.x*inverse_slope.q);
     dot_product=dy.q*offset.x-dx.q*offset.y;
     if (dot_product > 0.0)
       {
         box_p[2].x=polygon_primitive[n].point.x-offset.x;
         box_p[2].y=polygon_primitive[n].point.y-offset.y;
         box_p[3].x=polygon_primitive[i].point.x-offset.x;
         box_p[3].y=polygon_primitive[i].point.y-offset.y;
         box_q[2].x=polygon_primitive[n].point.x+offset.x;
         box_q[2].y=polygon_primitive[n].point.y+offset.y;
         box_q[3].x=polygon_primitive[i].point.x+offset.x;
         box_q[3].y=polygon_primitive[i].point.y+offset.y;
       }
     else
       {
         box_p[2].x=polygon_primitive[n].point.x+offset.x;
         box_p[2].y=polygon_primitive[n].point.y+offset.y;
         box_p[3].x=polygon_primitive[i].point.x+offset.x;
         box_p[3].y=polygon_primitive[i].point.y+offset.y;
         box_q[2].x=polygon_primitive[n].point.x-offset.x;
         box_q[2].y=polygon_primitive[n].point.y-offset.y;
         box_q[3].x=polygon_primitive[i].point.x-offset.x;
         box_q[3].y=polygon_primitive[i].point.y-offset.y;
       }
     if (fabs((double) (slope.p-slope.q)) < DrawEpsilon)
       {
         box_p[4]=box_p[1];
         box_q[4]=box_q[1];
       }
     else
       {
         box_p[4].x=(double) ((slope.p*box_p[0].x-box_p[0].y-slope.q*box_p[3].x+
           box_p[3].y)/(slope.p-slope.q));
         box_p[4].y=(double) (slope.p*(box_p[4].x-box_p[0].x)+box_p[0].y);
         box_q[4].x=(double) ((slope.p*box_q[0].x-box_q[0].y-slope.q*box_q[3].x+
           box_q[3].y)/(slope.p-slope.q));
         box_q[4].y=(double) (slope.p*(box_q[4].x-box_q[0].x)+box_q[0].y);
       }
     if (q >= (ssize_t) (max_strokes-6*BezierQuantum-360))
       {
         if (~max_strokes < (6*BezierQuantum+360))
           {
             path_p=(PointInfo *) RelinquishMagickMemory(path_p);
             path_q=(PointInfo *) RelinquishMagickMemory(path_q);
           }
         else
           {
             max_strokes+=6*BezierQuantum+360;
             path_p=(PointInfo *) ResizeQuantumMemory(path_p,max_strokes,
               sizeof(*path_p));
             path_q=(PointInfo *) ResizeQuantumMemory(path_q,max_strokes,
               sizeof(*path_q));
           }
         if ((path_p == (PointInfo *) NULL) || (path_q == (PointInfo *) NULL))
           {
             if (path_p != (PointInfo *) NULL)
               path_p=(PointInfo *) RelinquishMagickMemory(path_p);
             if (path_q != (PointInfo *) NULL)
               path_q=(PointInfo *) RelinquishMagickMemory(path_q);
             polygon_primitive=(PrimitiveInfo *)
               RelinquishMagickMemory(polygon_primitive);
             return((PrimitiveInfo *) NULL);
           }
       }
     dot_product=dx.q*dy.p-dx.p*dy.q;
     if (dot_product <= 0.0)
       switch (draw_info->linejoin)
       {
         case BevelJoin:
         {
           path_q[q++]=box_q[1];
           path_q[q++]=box_q[2];
           dot_product=(box_q[4].x-box_p[4].x)*(box_q[4].x-box_p[4].x)+
             (box_q[4].y-box_p[4].y)*(box_q[4].y-box_p[4].y);
           if (dot_product <= miterlimit)
             path_p[p++]=box_p[4];
           else
             {
               path_p[p++]=box_p[1];
               path_p[p++]=box_p[2];
             }
           break;
         }
         case MiterJoin:
         {
           dot_product=(box_q[4].x-box_p[4].x)*(box_q[4].x-box_p[4].x)+
             (box_q[4].y-box_p[4].y)*(box_q[4].y-box_p[4].y);
           if (dot_product <= miterlimit)
             {
               path_q[q++]=box_q[4];
               path_p[p++]=box_p[4];
             }
           else
             {
               path_q[q++]=box_q[1];
               path_q[q++]=box_q[2];
               path_p[p++]=box_p[1];
               path_p[p++]=box_p[2];
             }
           break;
         }
         case RoundJoin:
         {
           dot_product=(box_q[4].x-box_p[4].x)*(box_q[4].x-box_p[4].x)+
             (box_q[4].y-box_p[4].y)*(box_q[4].y-box_p[4].y);
           if (dot_product <= miterlimit)
             path_p[p++]=box_p[4];
           else
             {
               path_p[p++]=box_p[1];
               path_p[p++]=box_p[2];
             }
           center=polygon_primitive[n].point;
           theta.p=atan2(box_q[1].y-center.y,box_q[1].x-center.x);
           theta.q=atan2(box_q[2].y-center.y,box_q[2].x-center.x);
           if (theta.q < theta.p)
             theta.q+=2.0*MagickPI;
           arc_segments=(size_t) ceil((double) ((theta.q-theta.p)/
             (2.0*sqrt((double) (1.0/mid)))));
           path_q[q].x=box_q[1].x;
           path_q[q].y=box_q[1].y;
           q++;
           for (j=1; j < (ssize_t) arc_segments; j++)
           {
             delta_theta=(double) (j*(theta.q-theta.p)/arc_segments);
             path_q[q].x=(double) (center.x+mid*cos(fmod((double)
               (theta.p+delta_theta),DegreesToRadians(360.0))));
             path_q[q].y=(double) (center.y+mid*sin(fmod((double)
               (theta.p+delta_theta),DegreesToRadians(360.0))));
             q++;
           }
           path_q[q++]=box_q[2];
           break;
         }
         default:
           break;
       }
     else
       switch (draw_info->linejoin)
       {
         case BevelJoin:
         {
           path_p[p++]=box_p[1];
           path_p[p++]=box_p[2];
           dot_product=(box_q[4].x-box_p[4].x)*(box_q[4].x-box_p[4].x)+
             (box_q[4].y-box_p[4].y)*(box_q[4].y-box_p[4].y);
           if (dot_product <= miterlimit)
             path_q[q++]=box_q[4];
           else
             {
               path_q[q++]=box_q[1];
               path_q[q++]=box_q[2];
             }
           break;
         }
         case MiterJoin:
         {
           dot_product=(box_q[4].x-box_p[4].x)*(box_q[4].x-box_p[4].x)+
             (box_q[4].y-box_p[4].y)*(box_q[4].y-box_p[4].y);
           if (dot_product <= miterlimit)
             {
               path_q[q++]=box_q[4];
               path_p[p++]=box_p[4];
             }
           else
             {
               path_q[q++]=box_q[1];
               path_q[q++]=box_q[2];
               path_p[p++]=box_p[1];
               path_p[p++]=box_p[2];
             }
           break;
         }
         case RoundJoin:
         {
           dot_product=(box_q[4].x-box_p[4].x)*(box_q[4].x-box_p[4].x)+
             (box_q[4].y-box_p[4].y)*(box_q[4].y-box_p[4].y);
           if (dot_product <= miterlimit)
             path_q[q++]=box_q[4];
           else
             {
               path_q[q++]=box_q[1];
               path_q[q++]=box_q[2];
             }
           center=polygon_primitive[n].point;
           theta.p=atan2(box_p[1].y-center.y,box_p[1].x-center.x);
           theta.q=atan2(box_p[2].y-center.y,box_p[2].x-center.x);
           if (theta.p < theta.q)
             theta.p+=2.0*MagickPI;
           arc_segments=(size_t) ceil((double) ((theta.p-theta.q)/
             (2.0*sqrt((double) (1.0/mid)))));
           path_p[p++]=box_p[1];
           for (j=1; j < (ssize_t) arc_segments; j++)
           {
             delta_theta=(double) (j*(theta.q-theta.p)/arc_segments);
             path_p[p].x=(double) (center.x+mid*cos(fmod((double)
               (theta.p+delta_theta),DegreesToRadians(360.0))));
             path_p[p].y=(double) (center.y+mid*sin(fmod((double)
               (theta.p+delta_theta),DegreesToRadians(360.0))));
             p++;
           }
           path_p[p++]=box_p[2];
           break;
         }
         default:
           break;
       }
     slope.p=slope.q;
     inverse_slope.p=inverse_slope.q;
     box_p[0]=box_p[2];
     box_p[1]=box_p[3];
     box_q[0]=box_q[2];
     box_q[1]=box_q[3];
     dx.p=dx.q;
     dy.p=dy.q;
     n=i;
   }
   path_p[p++]=box_p[1];
   path_q[q++]=box_q[1];
   /*
     Trace stroked polygon.
   */
   stroke_polygon=(PrimitiveInfo *) AcquireQuantumMemory((size_t)
     (p+q+2UL*closed_path+2UL),sizeof(*stroke_polygon));
   if (stroke_polygon != (PrimitiveInfo *) NULL)
     {
       for (i=0; i < (ssize_t) p; i++)
       {
         stroke_polygon[i]=polygon_primitive[0];
         stroke_polygon[i].point=path_p[i];
       }
       if (closed_path != MagickFalse)
         {
           stroke_polygon[i]=polygon_primitive[0];
           stroke_polygon[i].point=stroke_polygon[0].point;
           i++;
         }
       for ( ; i < (ssize_t) (p+q+closed_path); i++)
       {
         stroke_polygon[i]=polygon_primitive[0];
         stroke_polygon[i].point=path_q[p+q+closed_path-(i+1)];
       }
       if (closed_path != MagickFalse)
         {
           stroke_polygon[i]=polygon_primitive[0];
           stroke_polygon[i].point=stroke_polygon[p+closed_path].point;
           i++;
         }
       stroke_polygon[i]=polygon_primitive[0];
       stroke_polygon[i].point=stroke_polygon[0].point;
       i++;
       stroke_polygon[i].primitive=UndefinedPrimitive;
       stroke_polygon[0].coordinates=(size_t) (p+q+2*closed_path+1);
     }
   path_p=(PointInfo *) RelinquishMagickMemory(path_p);
   path_q=(PointInfo *) RelinquishMagickMemory(path_q);
   polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(polygon_primitive);
   return(stroke_polygon);
 }
diff --git a/MagickCore/draw.h b/MagickCore/draw.h
index 09707a6e9..8a484ef11 100644
--- a/MagickCore/draw.h
+++ b/MagickCore/draw.h
@@ -339,19 +339,22 @@ typedef struct _DrawInfo
 typedef struct _PrimitiveInfo
 {
   PointInfo
     point;
 
   size_t
     coordinates;
 
   PrimitiveType
     primitive;
 
   PaintMethod
     method;
 
   char
     *text;
+
+  MagickBooleanType
+    closed_subpath;
 } PrimitiveInfo;
 
 typedef struct _TypeMetric
