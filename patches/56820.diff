commit 9a63e4cf79052a7897db2f8f239b7a5249155f7e
Author: Gerald Combs <gerald@wireshark.org>
Date:   Wed Mar 8 15:44:17 2023 -0800

    ORAN FH CUS: Add an array length check
    
    Fixes #18895.

diff --git a/epan/dissectors/packet-oran.c b/epan/dissectors/packet-oran.c
index d78790b7e7..0a75ecb898 100644
--- a/epan/dissectors/packet-oran.c
+++ b/epan/dissectors/packet-oran.c
@@ -1095,1128 +1095,1128 @@ static guint32 dissect_bfw_bundle(tvbuff_t *tvb, proto_tree *tree, packet_info *
 /* Section 7.
  * N.B. these are the green parts of the tables showing Section Types, differing by section Type */
 static int dissect_oran_c_section(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo,
                                   guint32 sectionType, proto_item *protocol_item)
 {
     guint offset = 0;
     proto_tree *oran_tree = NULL;
     proto_item *sectionHeading = NULL;
 
     oran_tree = proto_tree_add_subtree(tree, tvb, offset, 8, ett_oran_section, &sectionHeading, "Section");
     guint32 sectionId = 0;
 
     guint32 startPrbc;
     guint32 numPrbc;
     guint32 ueId = 0;
     guint32 beamId = 0;
     proto_item *beamId_ti = NULL;
     gboolean beamId_ignored = FALSE;
 
     /* Config affecting ext11 bundles (initially unset) */
     ext11_settings_t ext11_settings;
     memset(&ext11_settings, 0, sizeof(ext11_settings));
 
     gboolean extension_flag = FALSE;
 
     /* These sections are similar, so handle as common with per-type differences */
     if (sectionType <= SEC_C_UE_SCHED) {
         /* sectionID */
         proto_tree_add_item_ret_uint(oran_tree, hf_oran_section_id, tvb, offset, 2, ENC_BIG_ENDIAN, &sectionId);
         offset++;
 
         /* rb */
         proto_tree_add_item(oran_tree, hf_oran_rb, tvb, offset, 1, ENC_NA);
         /* symInc */
         proto_tree_add_item(oran_tree, hf_oran_symInc, tvb, offset, 1, ENC_NA);
         /* startPrbc */
         proto_tree_add_item_ret_uint(oran_tree, hf_oran_startPrbc, tvb, offset, 2, ENC_BIG_ENDIAN, &startPrbc);
         offset += 2;
         /* numPrbc */
         proto_item *numprbc_ti = proto_tree_add_item_ret_uint(oran_tree, hf_oran_numPrbc, tvb, offset, 1, ENC_NA, &numPrbc);
         if (numPrbc == 0) {
             proto_item_append_text(numprbc_ti, " (all PRBs - configured as %u)", pref_data_plane_section_total_rbs);
         }
         offset += 1;
         /* reMask */
         proto_tree_add_item(oran_tree, hf_oran_reMask, tvb, offset, 2, ENC_BIG_ENDIAN);
         offset++;
         /* numSymbol */
         guint32 numSymbol;
         proto_tree_add_item_ret_uint(oran_tree, hf_oran_numSymbol, tvb, offset, 1, ENC_NA, &numSymbol);
         offset++;
 
         /* [ef] (extension flag) */
         switch (sectionType) {
             case SEC_C_NORMAL:            /* Section Type "1" */
             case SEC_C_PRACH:             /* Section Type "3" */
             case SEC_C_UE_SCHED:          /* Section Type "5" */
                 proto_tree_add_item_ret_boolean(oran_tree, hf_oran_ef, tvb, offset, 1, ENC_BIG_ENDIAN, &extension_flag);
                 break;
             default:
                 break;
         }
 
         write_section_info(sectionHeading, pinfo, protocol_item, sectionId, startPrbc, numPrbc);
         proto_item_append_text(sectionHeading, ", Symbols: %d", numSymbol);
 
         if (numPrbc == 0) {
             /* Special case for all PRBs */
             numPrbc = pref_data_plane_section_total_rbs;
             startPrbc = 0;  /* may already be 0... */
         }
 
         /* Section type specific fields (after 'numSymbol') */
         switch (sectionType) {
             case SEC_C_UNUSED_RB:    /* Section Type "0" - Table 5.4 */
                 /* reserved */
                 proto_tree_add_item(oran_tree, hf_oran_rsvd16, tvb, offset, 2, ENC_NA);
                 offset += 2;
                 break;
 
             case SEC_C_NORMAL:       /* Section Type "1" - Table 5.5 */
                 /* beamId */
                 beamId_ti = proto_tree_add_item_ret_uint(oran_tree, hf_oran_beamId, tvb, offset, 2, ENC_BIG_ENDIAN, &beamId);
                 offset += 2;
 
                 proto_item_append_text(sectionHeading, ", BeamId: %d", beamId);
                 break;
 
             case SEC_C_PRACH:       /* Section Type "3" - Table 5.6 */
             {
                 /* beamId */
                 beamId_ti = proto_tree_add_item_ret_uint(oran_tree, hf_oran_beamId, tvb, offset, 2, ENC_BIG_ENDIAN, &beamId);
                 offset += 2;
 
                 /* freqOffset */
                 gint32 freqOffset;          /* Yes, this is signed, so the implicit cast is intentional. */
                 proto_item *freq_offset_item = proto_tree_add_item_ret_uint(oran_tree, hf_oran_freqOffset, tvb, offset, 3, ENC_BIG_ENDIAN, &freqOffset);
                 freqOffset |= 0xff000000;   /* Must sign-extend */
                 proto_item_set_text(freq_offset_item, "Frequency offset: %d \u0394f", freqOffset);
                 offset += 3;
 
                 /* reserved */
                 proto_tree_add_item(oran_tree, hf_oran_rsvd8, tvb, offset, 1, ENC_NA);
                 offset += 1;
 
                 proto_item_append_text(sectionHeading, ", BeamId: %d, FreqOffset: %d \u0394f", beamId, freqOffset);
                 break;
             }
 
             case SEC_C_UE_SCHED:   /* Section Type "5" - Table 5.7 */
                 /* ueId */
                 proto_tree_add_item_ret_uint(oran_tree, hf_oran_ueId, tvb, offset, 2, ENC_NA, &ueId);
                 offset += 2;
 
                 proto_item_append_text(sectionHeading, ", UEId: %d", ueId);
                 break;
 
             default:
                 break;
         }
     }
     else if (sectionType == SEC_C_CH_INFO) {  /* Section Type "6" */
         /* ef */
         proto_tree_add_item_ret_boolean(oran_tree, hf_oran_ef, tvb, offset, 1, ENC_BIG_ENDIAN, &extension_flag);
         /* ueId */
         proto_tree_add_item_ret_uint(oran_tree, hf_oran_ueId, tvb, offset, 2, ENC_NA, &ueId);
         offset += 2;
         /* regularizationFactor */
         proto_tree_add_item(oran_tree, hf_oran_regularizationFactor, tvb, offset, 2, ENC_NA);
         offset += 2;
         /* reserved */
         proto_tree_add_item(oran_tree, hf_oran_reserved_4bits, tvb, offset, 1, ENC_NA);
         /* rb */
         proto_tree_add_item(oran_tree, hf_oran_rb, tvb, offset, 1, ENC_NA);
         /* symInc */
         proto_tree_add_item(oran_tree, hf_oran_symInc, tvb, offset, 1, ENC_NA);
         /* startPrbc */
         proto_tree_add_item_ret_uint(oran_tree, hf_oran_startPrbc, tvb, offset, 2, ENC_BIG_ENDIAN, &startPrbc);
         offset += 2;
         /* numPrbc */
         proto_tree_add_item_ret_uint(oran_tree, hf_oran_numPrbc, tvb, offset, 1, ENC_NA, &numPrbc);
         offset += 1;
 
         /* ciIsample,ciQsample pairs */
         guint m;
         guint prb;
         guint32 bit_offset = offset*8;
 
         /* Antenna count from preference */
         guint num_trx = pref_num_bf_antennas;
         if (numPrbc > 1) {
             proto_item_append_text(sectionHeading, " (UEId=%u  PRBs %u-%u, %u antennas", ueId, startPrbc, startPrbc+numPrbc-1, num_trx);
         }
         else {
             proto_item_append_text(sectionHeading, " (UEId=%u  PRB %u, %u antennas", ueId, startPrbc, num_trx);
         }
 
         for (prb=startPrbc; prb < startPrbc+numPrbc; prb++) {
 
             /* PRB subtree */
             guint prb_start_offset = bit_offset;
             proto_item *prb_ti = proto_tree_add_string_format(oran_tree, hf_oran_samples_prb,
                                                                  tvb, bit_offset/8, 0,
                                                                  "", "PRB=%u", prb);
             proto_tree *prb_tree = proto_item_add_subtree(prb_ti, ett_oran_prb_cisamples);
 
             /* Antennas */
             for (m=0; m < num_trx; m++) {
 
                 guint sample_offset = bit_offset / 8;
                 guint8 sample_extent = ((bit_offset + (16*2)) / 8) - sample_offset;
 
                 /* Create subtree for antenna */
                 proto_item *sample_ti = proto_tree_add_string_format(prb_tree, hf_oran_ciSample,
                                                                      tvb, sample_offset, sample_extent,
                                                                      "", "TRX=%u:  ", m);
                 proto_tree *sample_tree = proto_item_add_subtree(sample_ti, ett_oran_cisample);
 
                 /* I */
                 /* Get bits, and convert to float. */
                 guint32 bits = tvb_get_bits(tvb, bit_offset, 16, ENC_BIG_ENDIAN);
                 gfloat value = uncompressed_to_float(bits);
 
                 /* Add to tree. */
                 proto_tree_add_float_format_value(sample_tree, hf_oran_ciIsample, tvb, bit_offset/8, (16+7)/8, value, "#%u=%f", m, value);
                 bit_offset += 16;
                 proto_item_append_text(sample_ti, "I%u=%f ", m, value);
 
                 /* Q */
                 /* Get bits, and convert to float. */
                 bits = tvb_get_bits(tvb, bit_offset, 16, ENC_BIG_ENDIAN);
                 value = uncompressed_to_float(bits);
 
                 /* Add to tree. */
                 proto_tree_add_float_format_value(sample_tree, hf_oran_ciQsample, tvb, bit_offset/8, (16+7)/8, value, "#%u=%f", m, value);
                 bit_offset += 16;
                 proto_item_append_text(sample_ti, "Q%u=%f ", m, value);
             }
             proto_item_set_len(prb_ti, (bit_offset-prb_start_offset)/8);
         }
         offset = (bit_offset/8);
     }
     else if (sectionType == SEC_C_LAA) {   /* Section Type "7" */
         /* 7.2.5 Table 6.4-6 */
 
         /* laaMsgType */
         guint32 laa_msg_type;
         proto_tree_add_item_ret_uint(oran_tree, hf_oran_laaMsgType, tvb, offset, 1, ENC_NA, &laa_msg_type);
         /* laaMsgLen */
         guint32 laa_msg_len;
         proto_item *len_ti = proto_tree_add_item_ret_uint(oran_tree, hf_oran_laaMsgLen, tvb, offset, 1, ENC_NA, &laa_msg_len);
         proto_item_append_text(len_ti, " (%u bytes)", 4*(laa_msg_len+1));
         offset += 1;
 
         /* payload */
         switch (laa_msg_type) {
             case 0:
                 /* TODO: LBT_PDSCH_REQ */
                 break;
             case 1:
                 /* TODO: LBT_DRS_REQ */
                 break;
             case 2:
                 /* TODO: LBT_PDSCH_RSP */
                 break;
             case 3:
                 /* TODO: LBT_DRS_RSP */
                 break;
             case 4:
                 /* TODO: LBT_Buffer_Error */
                 break;
             case 5:
                 /* TODO: LBT_CWCONFIG_REQ */
                 break;
             case 6:
                 /* TODO: LBT_CWCONFIG_RSP */
                 break;
             default:
                 /* Unhandled! */
                 break;
         }
         /* For now just skip indicated length of bytes */
         offset += 4*(laa_msg_len+1);
     }
 
     /* Section extension commands */
     while (extension_flag) {
 
         gint extension_start_offset = offset;
 
         /* Create subtree for each extension (with summary) */
         proto_item *extension_ti = proto_tree_add_string_format(oran_tree, hf_oran_extension,
                                                                 tvb, offset, 0, "", "Extension");
         proto_tree *extension_tree = proto_item_add_subtree(extension_ti, ett_oran_c_section_extension);
 
         /* ef (i.e. another extension after this one?) */
         proto_tree_add_item_ret_boolean(extension_tree, hf_oran_ef, tvb, offset, 1, ENC_BIG_ENDIAN, &extension_flag);
 
         /* extType */
         guint32 exttype;
         proto_tree_add_item_ret_uint(extension_tree, hf_oran_exttype, tvb, offset, 1, ENC_BIG_ENDIAN, &exttype);
         offset++;
         proto_item_append_text(sectionHeading, " (ext-%u)", exttype);
 
         proto_item_append_text(extension_ti, " (ext-%u: %s)", exttype, val_to_str_const(exttype, exttype_vals, "Unknown"));
 
         /* extLen (number of 32-bit words) */
         guint32 extlen_len = ((exttype==11)||(exttype==19)||(exttype==20)) ? 2 : 1;  /* Extensions 11/19/20 are special */
         guint32 extlen;
         proto_item *extlen_ti = proto_tree_add_item_ret_uint(extension_tree, hf_oran_extlen, tvb,
                                                              offset, extlen_len, ENC_BIG_ENDIAN, &extlen);
         proto_item_append_text(extlen_ti, " (%u bytes)", extlen*4);
         offset += extlen_len;
         if (extlen == 0) {
             expert_add_info_format(pinfo, extlen_ti, &ei_oran_extlen_zero,
                                    "extlen value of 0 is reserved");
             /* Break out to avoid infinitely looping! */
             break;
         }
 
         switch (exttype) {
 
             case 1:  /* Beamforming Weights Extension type */
             {
                 guint32 bfwcomphdr_iq_width, bfwcomphdr_comp_meth;
                 proto_item *comp_meth_ti = NULL;
 
                 /* bfwCompHdr (2 subheaders - bfwIqWidth and bfwCompMeth)*/
                 offset = dissect_bfwCompHdr(tvb, extension_tree, offset,
                                             &bfwcomphdr_iq_width, &bfwcomphdr_comp_meth, &comp_meth_ti);
 
                 /* Look up width of samples. */
                 guint8 iq_width = !bfwcomphdr_iq_width ? 16 : bfwcomphdr_iq_width;
 
                 /* bfwCompParam */
                 guint32 exponent = 0;
                 gboolean compression_method_supported = FALSE;
                 offset = dissect_bfwCompParam(tvb, extension_tree, pinfo, offset, comp_meth_ti,
                                               bfwcomphdr_comp_meth, &exponent, &compression_method_supported);
 
                 /* Can't show details of unsupported compression method */
                 if (!compression_method_supported) {
                     break;
                 }
 
                 /* We know:
                    - iq_width (above)
                    - numBfWeights (taken from preference)
                    - remaining bytes in extension
                    We can therefore derive TRX (number of antennas).
                  */
 
                 /* I & Q samples
                    Don't know how many there will be, so just fill available bytes...
                  */
                 guint weights_bytes = (extlen*4)-3;
                 guint num_weights_pairs = (weights_bytes*8) / (iq_width*2);
                 guint num_trx = num_weights_pairs;
                 gint bit_offset = offset*8;
 
                 for (guint n=0; n < num_trx; n++) {
                     /* Create antenna subtree */
                     gint bfw_offset = bit_offset / 8;
                     proto_item *bfw_ti = proto_tree_add_string_format(extension_tree, hf_oran_bfw,
                                                                       tvb, bfw_offset, 0, "", "TRX %2u: (", n);
                     proto_tree *bfw_tree = proto_item_add_subtree(bfw_ti, ett_oran_bfw);
 
                     /* I value */
                     /* Get bits, and convert to float. */
                     guint32 bits = tvb_get_bits(tvb, bit_offset, iq_width, ENC_BIG_ENDIAN);
                     gfloat value = decompress_value(bits, COMP_BLOCK_FP, iq_width, exponent);
                     /* Add to tree. */
                     proto_tree_add_float_format_value(bfw_tree, hf_oran_bfw_i, tvb, bit_offset/8, (iq_width+7)/8, value, "%f", value);
                     bit_offset += iq_width;
                     proto_item_append_text(bfw_ti, "I=%f ", value);
 
                     /* Leave a gap between I and Q values */
                     proto_item_append_text(bfw_ti, "  ");
 
                     /* Q value */
                     /* Get bits, and convert to float. */
                     bits = tvb_get_bits(tvb, bit_offset, iq_width, ENC_BIG_ENDIAN);
                     value = decompress_value(bits, COMP_BLOCK_FP, iq_width, exponent);
                     /* Add to tree. */
                     proto_tree_add_float_format_value(bfw_tree, hf_oran_bfw_q, tvb, bit_offset/8, (iq_width+7)/8, value, "%f", value);
                     bit_offset += iq_width;
                     proto_item_append_text(bfw_ti, "Q=%f", value);
 
                     proto_item_append_text(bfw_ti, ")");
                     proto_item_set_len(bfw_ti, (bit_offset+7)/8  - bfw_offset);
                 }
                 /* Need to round to next byte */
                 offset = (bit_offset+7)/8;
 
                 break;
             }
 
             case 2: /* Beamforming attributes */
             {
                 /* bfaCompHdr (get widths of fields to follow) */
                 guint32 bfAzPtWidth, bfZePtWidth, bfAz3ddWidth, bfZe3ddWidth;
                 /* subtree */
                 proto_item *bfa_ti = proto_tree_add_string_format(extension_tree, hf_oran_bfaCompHdr,
                                                                   tvb, offset, 2, "", "bfaCompHdr");
                 proto_tree *bfa_tree = proto_item_add_subtree(bfa_ti, ett_oran_bfacomphdr);
 
                 /* reserved (2 bits) */
                 proto_tree_add_item(bfa_tree, hf_oran_reserved_2bits, tvb, offset, 1, ENC_BIG_ENDIAN);
                 /* bfAzPtWidth (3 bits) */
                 proto_tree_add_item_ret_uint(bfa_tree, hf_oran_bfAzPtWidth, tvb, offset, 1, ENC_BIG_ENDIAN, &bfAzPtWidth);
                 /* bfZePtWidth (3 bits) */
                 proto_tree_add_item_ret_uint(bfa_tree, hf_oran_bfZePtWidth, tvb, offset, 1, ENC_BIG_ENDIAN, &bfZePtWidth);
                 offset += 1;
 
                 /* reserved (2 bits) */
                 proto_tree_add_item(bfa_tree, hf_oran_reserved_2bits, tvb, offset, 1, ENC_BIG_ENDIAN);
                 /* bfAz3ddWidth (3 bits) */
                 proto_tree_add_item_ret_uint(bfa_tree, hf_oran_bfAz3ddWidth, tvb, offset, 1, ENC_BIG_ENDIAN, &bfAz3ddWidth);
                 /* bfZe3ddWidth (3 bits) */
                 proto_tree_add_item_ret_uint(bfa_tree, hf_oran_bfZe3ddWidth, tvb, offset, 1, ENC_BIG_ENDIAN, &bfZe3ddWidth);
                 offset += 1;
 
                 guint bit_offset = offset*8;
 
                 /* bfAzPt */
                 if (bfAzPtWidth > 0) {
                     proto_tree_add_bits_item(extension_tree, hf_oran_bfAzPt, tvb, bit_offset, bfAzPtWidth+1, ENC_BIG_ENDIAN);
                     bit_offset += (bfAzPtWidth+1);
                 }
                 /* bfZePt */
                 if (bfZePtWidth > 0) {
                     proto_tree_add_bits_item(extension_tree, hf_oran_bfZePt, tvb, bit_offset, bfZePtWidth+1, ENC_BIG_ENDIAN);
                     bit_offset += (bfZePtWidth+1);
                 }
                 /* bfAz3dd */
                 if (bfAz3ddWidth > 0) {
                     proto_tree_add_bits_item(extension_tree, hf_oran_bfAz3dd, tvb, bit_offset, bfAz3ddWidth+1, ENC_BIG_ENDIAN);
                     bit_offset += (bfAz3ddWidth+1);
                 }
                 /* bfZe3dd */
                 if (bfZe3ddWidth > 0) {
                     proto_tree_add_bits_item(extension_tree, hf_oran_bfZe3dd, tvb, bit_offset, bfZe3ddWidth+1, ENC_BIG_ENDIAN);
                     bit_offset += (bfZe3ddWidth+1);
                 }
 
                 /* go to next byte (zero-padding.. - a little confusing..) */
                 offset = (bit_offset+7) / 8;
 
                 /* 2 reserved/padding bits */
                 /* bfAzSl (3 bits) */
                 proto_tree_add_item(extension_tree, hf_oran_bfAzSl, tvb, offset, 1, ENC_BIG_ENDIAN);
                 /* bfZeSl (3 bits) */
                 proto_tree_add_item(extension_tree, hf_oran_bfZeSl, tvb, offset, 1, ENC_BIG_ENDIAN);
                 break;
             }
 
             case 4: /* Modulation compression params (5.4.7.4) */
             {
                 /* csf */
                 proto_tree_add_bits_item(extension_tree, hf_oran_csf, tvb, offset*8, 1, ENC_BIG_ENDIAN);
                 /* modCompScaler */
                 guint32 modCompScaler;
                 proto_item *ti = proto_tree_add_item_ret_uint(extension_tree, hf_oran_modcompscaler,
                                                               tvb, offset, 2, ENC_BIG_ENDIAN, &modCompScaler);
                 /* Work out and show floating point value too. */
                 guint16 exponent = (modCompScaler >> 11) & 0x000f; /* m.s. 4 bits */
                 guint16 mantissa = modCompScaler & 0x07ff;         /* l.s. 11 bits */
                 double value = (double)mantissa * (1.0 / (1 << exponent));
                 proto_item_append_text(ti, " (%f)", value);
 
                 offset += 2;
                 break;
             }
 
             case 5: /* Modulation Compression Additional Parameters Extension Type (5.4.7.5) */
             {
                 /* Applies only to section types 1,3 and 5 */
 
                 /* There may be one or 2 entries, depending upon extlen */
                 gint sets = 1, reserved_bits = 0;
                 switch (extlen) {
                     case 2:
                         sets = 1;
                         reserved_bits = 20;
                         break;
                     case 3:
                         sets = 2;
                         reserved_bits = 24;
                         break;
                     default:
                         /* Malformed error!!! */
                         expert_add_info_format(pinfo, extlen_ti, &ei_oran_extlen_wrong,
                                                "For section 5, extlen must be 2 or 3, but %u was dissected",
                                                extlen);
                         break;
                 }
 
                 guint bit_offset = offset*8;
 
                 for (gint n=0; n < sets; n++) {
                     /* mcScaleReMask (12 bits) */
                     proto_tree_add_bits_item(extension_tree, hf_oran_mc_scale_re_mask, tvb, bit_offset, 12, ENC_BIG_ENDIAN);
                     bit_offset += 12;
                     /* csf (1 bit) */
                     proto_tree_add_bits_item(extension_tree, hf_oran_csf, tvb, bit_offset, 1, ENC_BIG_ENDIAN);
                     bit_offset += 1;
                     /* mcScaleOffset (15 bits) */
                     proto_tree_add_bits_item(extension_tree, hf_oran_mc_scale_offset, tvb, bit_offset, 15, ENC_BIG_ENDIAN);
                     bit_offset += 15;
                 }
 
                 /* Reserved */
                 proto_tree_add_bits_item(extension_tree, hf_oran_reserved, tvb, bit_offset, reserved_bits, ENC_BIG_ENDIAN);
                 bit_offset += reserved_bits;
 
                 offset = bit_offset/8;
                 break;
             }
 
             case 6: /* Non-contiguous PRB allocation in time and frequency domain */
             {
                 /* TODO: Field startSymbolId in the message header and the fields rb, symInc, and numSymbol in the section
                    description shall not be used for identification of symbols and PRBs referred by the section description */
 
                 /* repetition */
                 proto_tree_add_bits_item(extension_tree, hf_oran_repetition, tvb, offset*8, 1, ENC_BIG_ENDIAN);
                 /* rbgSize */
                 guint32 rbgSize;
                 proto_tree_add_item_ret_uint(extension_tree, hf_oran_rbgSize, tvb, offset, 1, ENC_BIG_ENDIAN, &rbgSize);
                 if (rbgSize == 0) {
                     expert_add_info_format(pinfo, extlen_ti, &ei_oran_rbg_size_reserved,
                                            "rbgSize value of 0 is reserved");
                 }
                 /* rbgMask */
                 guint32 rbgMask;
                 proto_tree_add_item_ret_uint(extension_tree, hf_oran_rbgMask, tvb, offset, 4, ENC_BIG_ENDIAN, &rbgMask);
                 offset += 4;
                 /* priority */
                 proto_tree_add_item(extension_tree, hf_oran_noncontig_priority, tvb, offset, 1, ENC_BIG_ENDIAN);
                 /* symbolMask */
                 proto_tree_add_item(extension_tree, hf_oran_symbolMask, tvb, offset, 2, ENC_BIG_ENDIAN);
                 offset += 2;
 
                 /* Update ext6 recorded info */
                 ext11_settings.ext6_set = TRUE;
                 switch (rbgSize) {
                     case 0:
                         /* N.B. reserved, but covered above with expert info (would remain 0) */
                         break;
                     case 1:
                         ext11_settings.ext6_rbg_size = 1; break;
                     case 2:
                         ext11_settings.ext6_rbg_size = 2; break;
                     case 3:
                         ext11_settings.ext6_rbg_size = 3; break;
                     case 4:
                         ext11_settings.ext6_rbg_size = 4; break;
                     case 5:
                         ext11_settings.ext6_rbg_size = 6; break;
                     case 6:
                         ext11_settings.ext6_rbg_size = 8; break;
                     case 7:
                         ext11_settings.ext6_rbg_size = 16; break;
                     /* N.B., encoded in 3 bits, so no other values are possible */
                 }
-                for (guint n=0; n < 28; n++) {
+                for (guint n=0; n < 28 && ext11_settings.ext6_num_bits_set < 28; n++) {
                     if ((rbgMask >> n) & 0x01) {
                         ext11_settings.ext6_bits_set[ext11_settings.ext6_num_bits_set++] = n;
                     }
                 }
                 break;
             }
 
             case 7: /* eAxC mask */
                 proto_tree_add_item(extension_tree, hf_oran_eAxC_mask, tvb, offset, 2, ENC_BIG_ENDIAN);
                 offset += 2;
                 break;
 
             case 8: /* Regularization factor */
                 proto_tree_add_item(extension_tree, hf_oran_regularizationFactor, tvb, offset, 2, ENC_BIG_ENDIAN);
                 offset += 2;
                 break;
 
             case 9: /* Dynamic Spectrum Sharing parameters */
                 proto_tree_add_item(extension_tree, hf_oran_technology, tvb, offset, 1, ENC_BIG_ENDIAN);
                 offset += 1;
                 proto_tree_add_bits_item(extension_tree, hf_oran_reserved, tvb, offset*8, 8, ENC_BIG_ENDIAN);
                 offset += 1;
                 break;
 
             case 10: /* Section description for group configuration of multiple ports */
             {
                 /* beamGroupType */
                 guint32 beam_group_type = 0;
                 proto_tree_add_item_ret_uint(extension_tree, hf_oran_beamGroupType,
                                              tvb, offset, 1, ENC_BIG_ENDIAN, &beam_group_type);
                 proto_item_append_text(extension_ti, " (%s)", val_to_str_const(beam_group_type, beam_group_type_vals, "Unknown"));
 
                 /* numPortc */
                 guint32 numPortc;
                 proto_tree_add_item_ret_uint(extension_tree, hf_oran_numPortc,
                                              tvb, offset, 1, ENC_BIG_ENDIAN, &numPortc);
                 offset++;
 
                 /* TODO: any generated fields or expert info should be added, due to enties in table 5-35 ? */
 
                 /* Will append all beamId values to extension_ti, regardless of beamGroupType */
                 proto_item_append_text(extension_ti, "(");
                 guint n;
 
                 switch (beam_group_type) {
                     case 0x0: /* common beam */
                         /* Reserved byte */
                         proto_tree_add_item(oran_tree, hf_oran_rsvd8, tvb, offset, 1, ENC_NA);
                         offset++;
 
                         /* All entries are beamId... */
                         for (n=0; n < numPortc; n++) {
                             proto_item_append_text(extension_ti, "%u ", beamId);
                         }
                         break;
 
                     case 0x1: /* beam matrix indication */
                         /* Reserved byte */
                         proto_tree_add_item(oran_tree, hf_oran_rsvd8, tvb, offset, 1, ENC_NA);
                         offset++;
 
                         /* Entries inc from beamId... */
                         for (n=0; n < numPortc; n++) {
                             proto_item_append_text(extension_ti, "%u ", beamId+n);
                         }
                         break;
 
                     case 0x2: /* beam vector listing */
                     {
                         /* Beam listing vector case */
                         /* Work out how many port beam entries there is room for */
                         /* Using numPortC as visible in issue 18116 */
                         proto_item_append_text(extension_ti, " (%u entries) ", numPortc);
                         for (n=0; n < numPortc; n++) {
                             /* TODO: Single reserved bit */
 
                             /* port beam ID (or UEID) */
                             guint32 id;
                             proto_item *beamid_or_ueid_ti = proto_tree_add_item_ret_uint(oran_tree, hf_oran_beamId,
                                                                                          tvb, offset, 2, ENC_BIG_ENDIAN, &id);
                             proto_item_append_text(beamid_or_ueid_ti, " port #%u beam ID (or UEId) %u", n, id);
                             offset += 2;
 
                             proto_item_append_text(extension_ti, "%u ", id);
                         }
                         break;
                     }
 
                     default:
                         /* TODO: warning for unsupported/reserved value */
                         break;
                 }
                 proto_item_append_text(extension_ti, ")");
                 break;
             }
 
             case 11: /* Flexible Weights Extension Type */
             {
                 gboolean disableBFWs;
                 guint32  numBundPrb;
 
                 /* disableBFWs */
                 proto_tree_add_item_ret_boolean(extension_tree, hf_oran_disable_bfws,
                                                 tvb, offset, 1, ENC_BIG_ENDIAN, &disableBFWs);
                 if (disableBFWs) {
                     proto_item_append_text(extension_ti, " (disableBFWs)");
                 }
                 /* RAD */
                 proto_tree_add_item(extension_tree, hf_oran_rad,
                                     tvb, offset, 1, ENC_BIG_ENDIAN);
                 /* 6 reserved bits */
                 proto_tree_add_item(extension_tree, hf_oran_ext11_reserved, tvb,
                                     offset, 1, ENC_BIG_ENDIAN);
                 offset++;
 
                 /* numBundPrb (number of prbs in each bundle) */
                 proto_item *num_bund_prb_ti = proto_tree_add_item_ret_uint(extension_tree, hf_oran_num_bund_prbs,
                                                                            tvb, offset, 1, ENC_BIG_ENDIAN, &numBundPrb);
                 offset++;
                 /* value zero is reserved.. */
                 if (numBundPrb == 0) {
                     expert_add_info_format(pinfo, num_bund_prb_ti, &ei_oran_reserved_numBundPrb,
                                            "Reserved value 0 for numBundPrb seen - not valid");
                 }
 
                 guint32 num_bundles;
                 gboolean orphaned_prbs = FALSE;
 
                 if (!disableBFWs) {
                     /********************************************/
                     /* Table 7.7.1.1-1 */
                     /********************************************/
 
                     guint32 bfwcomphdr_iq_width, bfwcomphdr_comp_meth;
                     proto_item *comp_meth_ti = NULL;
 
                     /* bfwCompHdr (2 subheaders - bfwIqWidth and bfwCompMeth)*/
                     offset = dissect_bfwCompHdr(tvb, extension_tree, offset,
                                                 &bfwcomphdr_iq_width, &bfwcomphdr_comp_meth, &comp_meth_ti);
 
                     /* Look up width of samples. */
                     guint8 iq_width = !bfwcomphdr_iq_width ? 16 : bfwcomphdr_iq_width;
 
 
                     /* Work out number of bundles, but take care not to divide by zero. */
                     if (numBundPrb == 0) {
                         break;
                     }
 
                     /* Work out bundles! */
                     ext11_work_out_bundles(startPrbc, numPrbc, numBundPrb, &ext11_settings);
                     num_bundles = ext11_settings.num_bundles;
 
                     /* Add (complete) bundles */
                     for (guint b=0; b < num_bundles; b++) {
 
                         offset = dissect_bfw_bundle(tvb, extension_tree, pinfo, offset,
                                                     comp_meth_ti, bfwcomphdr_comp_meth,
                                                     iq_width,
                                                     b,                                 /* bundle number */
                                                     ext11_settings.bundles[b].start,
                                                     ext11_settings.bundles[b].end,
                                                     ext11_settings.bundles[b].is_orphan);
                         if (!offset) {
                             break;
                         }
                     }
                     /* Set flag from last bundle entry */
                     orphaned_prbs = ext11_settings.bundles[num_bundles-1].is_orphan;
                 }
                 else {
                     /********************************************/
                     /* Table 7.7.1.1-2 */
                     /* No weights in this case */
                     /********************************************/
 
                     /* Work out number of bundles, but take care not to divide by zero. */
                     if (numBundPrb == 0) {
                         break;
                     }
 
                     ext11_work_out_bundles(startPrbc, numPrbc, numBundPrb, &ext11_settings);
                     num_bundles = ext11_settings.num_bundles;
 
                     for (guint n=0; n < num_bundles; n++) {
                         /* beamId */
                         proto_item *ti = proto_tree_add_item(extension_tree, hf_oran_beam_id,
                                                              tvb, offset, 2, ENC_BIG_ENDIAN);
                         if (!ext11_settings.bundles[n].is_orphan) {
                             proto_item_append_text(ti, " (Bundle %u)", n);
                         }
                         else {
                             orphaned_prbs = TRUE;
                             proto_item_append_text(ti, " (Orphaned PRBs)");
                         }
                         offset += 2;
                     }
                 }
 
                 /* Add summary to extension root */
                 if (orphaned_prbs) {
                     proto_item_append_text(extension_ti, " (%u bundles + orphaned)", num_bundles);
                 }
                 else {
                     proto_item_append_text(extension_ti, " (%u bundles)", num_bundles);
                 }
             }
 
                 break;
 
             case 12: /* Non-Contiguous PRB Allocation with Frequency Ranges */
             {
                 /* priority */
                 proto_tree_add_item(extension_tree, hf_oran_noncontig_priority, tvb, offset, 1, ENC_BIG_ENDIAN);
 
                 /* symbolMask */
                 proto_tree_add_item(extension_tree, hf_oran_symbolMask, tvb, offset, 2, ENC_BIG_ENDIAN);
                 offset += 2;
 
                 /* There are now 'R' pairs of (offStartPrb, numPrb) values. Fill extlen bytes with values.  If last one is not set,
                    should be populated with 0s. */
                 guint32 extlen_remaining_bytes = (extlen*4) - 4;
                 guint8 prb_index;
 
                 ext11_settings.ext12_set = TRUE;
                 for (prb_index = 1; extlen_remaining_bytes > 0; prb_index++)
                 {
                     /* Create a subtree for each pair */
                     proto_item *pair_ti = proto_tree_add_string(extension_tree, hf_oran_off_start_prb_num_prb_pair,
                                                                 tvb, offset, 2, "");
                     proto_tree *pair_tree = proto_item_add_subtree(pair_ti, ett_oran_offset_start_prb_num_prb);
 
                     /* offStartPrb */
                     guint32 off_start_prb;
                     proto_tree_add_item_ret_uint(pair_tree, hf_oran_off_start_prb, tvb, offset, 1, ENC_BIG_ENDIAN, &off_start_prb);
                     offset++;
 
                     /* numPrb */
                     guint32 num_prb;
                     proto_tree_add_item_ret_uint(pair_tree, hf_oran_num_prb, tvb, offset, 1, ENC_BIG_ENDIAN, &num_prb);
                     offset++;
 
                     extlen_remaining_bytes -= 2;
 
                     /* Last pair may be 0,0 if not used. Check for this */
                     if ((extlen_remaining_bytes == 0) && (off_start_prb == 0) && (num_prb == 0)) {
                         proto_item_append_text(pair_ti, " (not used)");
                     }
                     /* Add summary to pair root item, and configure details in ext11_settings */
                     else {
                         proto_item_append_text(pair_ti, "(%u) offStartPrb=%3u, numPrb=%u",
                                               prb_index, off_start_prb, num_prb);
                         if (ext11_settings.ext12_num_pairs < MAX_BFW_EXT12_PAIRS) {
                             ext11_settings.ext12_pairs[ext11_settings.ext12_num_pairs].off_start_prb = off_start_prb;
                             ext11_settings.ext12_pairs[ext11_settings.ext12_num_pairs++].num_prb = num_prb;
                         }
                     }
                 }
                 break;
             }
 
             case 13:  /* PRB Allocation with Frequency Hopping */
             {
                 guint32 extlen_remaining_bytes = (extlen*4) - 2;
                 guint8 allocation_index;
 
                 /* Will update settings for ext11 */
                 ext11_settings.ext13_set = TRUE;
 
                 guint prev_next_symbol_id = 0, prev_next_start_prbc = 0;
 
                 for (allocation_index = 1; extlen_remaining_bytes > 0; allocation_index++)
                 {
                     /* Subtree for allocation */
                     proto_item *allocation_ti = proto_tree_add_string(extension_tree, hf_oran_prb_allocation,
                                                                 tvb, offset, 2, "");
                     proto_tree *allocation_tree = proto_item_add_subtree(allocation_ti, ett_oran_prb_allocation);
 
                     /* Reserved (2 bits) */
                     proto_tree_add_item(allocation_tree, hf_oran_reserved_2bits, tvb, offset, 1, ENC_BIG_ENDIAN);
 
                     /* nextSymbolId (4 bits) */
                     guint32 next_symbol_id;
                     proto_tree_add_item_ret_uint(allocation_tree, hf_oran_nextSymbolId, tvb, offset, 1, ENC_BIG_ENDIAN, &next_symbol_id);
 
                     /* nextStartPrbc (10 bits) */
                     guint32 next_start_prbc;
                     proto_tree_add_item_ret_uint(allocation_tree, hf_oran_nextStartPrbc, tvb, offset, 2, ENC_BIG_ENDIAN, &next_start_prbc);
                     offset += 2;
 
                     /* Add summary to allocation root item */
                     proto_item_append_text(allocation_ti, "(%u) nextSymbolId=%3u, nextStartPrbc=%u",
                                            allocation_index, next_symbol_id, next_start_prbc);
 
                     /* Checking for duplicates (expected if e.g. had only 2 entries but extlen bytes still to fill */
                     if ((allocation_index > 1) && (next_symbol_id == prev_next_symbol_id) && (next_start_prbc == prev_next_start_prbc)) {
                         proto_item_append_text(allocation_ti, " (repeated - to fill up extlen)");
                     }
                     else {
                         /* Add entry for configuring ext11. don't store out of range */
                         if (ext11_settings.ext13_num_start_prbs < MAX_BFW_EXT13_ALLOCATIONS) {
                             ext11_settings.ext13_start_prbs[ext11_settings.ext13_num_start_prbs++] = next_start_prbc;
                         }
                     }
                     prev_next_symbol_id = next_symbol_id;
                     prev_next_start_prbc = next_start_prbc;
 
                     extlen_remaining_bytes -= 2;
                 }
                 break;
             }
 
             case 14:  /* Nulling-layer Info. for ueId-based beamforming */
                 proto_tree_add_item(extension_tree, hf_oran_nullLayerInd, tvb, offset, 1, ENC_BIG_ENDIAN);
                 offset += 1;
                 proto_tree_add_bits_item(extension_tree, hf_oran_reserved, tvb, offset*8, 8, ENC_BIG_ENDIAN);
                 offset += 1;
                 break;
 
             case 15:  /* Mixed-numerology Info. for ueId-based beamforming */
                 /* frameStructure */
                 proto_tree_add_item(extension_tree, hf_oran_frameStructure_fft, tvb, offset, 1, ENC_BIG_ENDIAN);
                 proto_tree_add_item(extension_tree, hf_oran_frameStructure_subcarrier_spacing, tvb, offset, 1, ENC_NA);
                 offset += 1;
                 /* freqOffset */
                 proto_tree_add_item(extension_tree, hf_oran_freqOffset, tvb, offset, 3, ENC_BIG_ENDIAN);
                 offset += 3;
                 /* cpLength */
                 proto_tree_add_item(extension_tree, hf_oran_cpLength, tvb, offset, 2, ENC_BIG_ENDIAN);
                 offset += 2;
                 break;
 
             case 16:  /* Section description for antenna mapping in UE channel information based UL beamforming */
             {
                 guint32 extlen_remaining_bytes = (extlen*4) - 2;
                 guint num_ant_masks = extlen_remaining_bytes / 8;
                 for (guint n=0; n < num_ant_masks; n++) {
                     proto_item *ti = proto_tree_add_item(extension_tree, hf_oran_antMask, tvb, offset, 8, ENC_BIG_ENDIAN);
                     proto_item_append_text(ti, " (RX eAxC #%u)", n+1);
                     offset += 8;
                 }
                 break;
             }
 
             case 17:  /* Section description for indication of user port group */
             {
                 guint32 extlen_remaining_bytes = (extlen*4) - 2;
                 guint32 end_bit = (offset+extlen_remaining_bytes) * 8;
                 guint32 ueid_index = 1;
                 /* TODO: just filling up all available bytes - some may actually be padding.. */
                 for (guint32 bit_offset=offset*8; bit_offset < end_bit; bit_offset+=4, ueid_index++) {
                     proto_item *ti = proto_tree_add_bits_item(extension_tree, hf_oran_num_ueid, tvb, bit_offset, 4, ENC_BIG_ENDIAN);
                     proto_item_append_text(ti, " (user #%u)", ueid_index);
                 }
                 break;
             }
 
             case 18:  /* Section description for Uplink Transmission Management */
                 /* transmissionWindowOffset */
                 proto_tree_add_item(extension_tree, hf_oran_transmissionWindowOffset, tvb, offset, 2, ENC_BIG_ENDIAN);
                 offset += 2;
                 /* reserved (2 bits) */
                 proto_tree_add_item(extension_tree, hf_oran_reserved_2bits, tvb, offset, 1, ENC_BIG_ENDIAN);
                 /* transmissionWindowSize (14 bits) */
                 proto_tree_add_item(extension_tree, hf_oran_transmissionWindowSize, tvb, offset, 2, ENC_BIG_ENDIAN);
                 offset += 2;
 
                 /* reserved (6 bits) */
                 proto_tree_add_item(extension_tree, hf_oran_reserved_6bits, tvb, offset, 1, ENC_BIG_ENDIAN);
                 /* toT (2 bits) */
                 proto_tree_add_item(extension_tree, hf_oran_toT, tvb, offset, 1, ENC_BIG_ENDIAN);
                 offset += 1;
                 break;
 
             case 19:  /* Compact beamforming information for multiple port */
             {
                 /* beamId in section header should be ignored */
                 if (beamId_ti && !beamId_ignored) {
                     proto_item_append_text(beamId_ti, " (ignored)");
                     beamId_ignored = TRUE;
                 }
 
                 /* disableBFWs */
                 gboolean disableBFWs;
                 proto_tree_add_item_ret_boolean(extension_tree, hf_oran_disable_bfws,
                                                 tvb, offset, 1, ENC_BIG_ENDIAN, &disableBFWs);
                 if (disableBFWs) {
                     proto_item_append_text(extension_ti, " (disableBFWs)");
                 }
                 /* Repetition */
                 proto_tree_add_bits_item(extension_tree, hf_oran_repetition, tvb, (offset*8)+1, 1, ENC_BIG_ENDIAN);
                 /* numPortc */
                 guint32 numPortc;
                 proto_tree_add_item_ret_uint(extension_tree, hf_oran_numPortc,
                                              tvb, offset, 1, ENC_BIG_ENDIAN, &numPortc);
                 offset++;
 
                 /* priority */
                 proto_tree_add_item(extension_tree, hf_oran_noncontig_priority, tvb, offset, 1, ENC_BIG_ENDIAN);
                 /* symbolMask */
                 proto_tree_add_item(extension_tree, hf_oran_symbolMask, tvb, offset, 2, ENC_BIG_ENDIAN);
                 offset += 2;
 
                 /* bfwCompHdr */
                 guint32 bfwcomphdr_iq_width, bfwcomphdr_comp_meth;
                 proto_item *comp_meth_ti = NULL;
                 offset = dissect_bfwCompHdr(tvb, extension_tree, offset,
                                             &bfwcomphdr_iq_width, &bfwcomphdr_comp_meth, &comp_meth_ti);
 
                 /* Add entries for each port */
                 for (guint port=0; port < numPortc; port++) {
 
                     /* Create subtree for port entry*/
                     gint port_start_offset = offset;
                     proto_item *port_ti = proto_tree_add_string_format(extension_tree, hf_oran_ext19_port,
                                                                        tvb, offset, 0,
                                                                       "", "Port %u: ", port);
                     proto_tree *port_tree = proto_item_add_subtree(port_ti, ett_oran_ext19_port);
 
 
 
                     /* Reserved (4 bits) */
                     proto_tree_add_item(port_tree, hf_oran_reserved_4bits, tvb, offset, 1, ENC_BIG_ENDIAN);
                     /* portReMask (12 bits) */
                     proto_tree_add_item(port_tree, hf_oran_portReMask, tvb, offset, 2, ENC_BIG_ENDIAN);
                     offset += 2;
 
                     /* Reserved (2 bits) */
                     proto_tree_add_item(port_tree, hf_oran_reserved_2bits, tvb, offset, 1, ENC_BIG_ENDIAN);
                     /* portSymbolMask (14 bits) */
                     proto_tree_add_item(port_tree, hf_oran_portSymbolMask, tvb, offset, 2, ENC_BIG_ENDIAN);
                     offset += 2;
 
                     /* Reserved (1 bit) */
                     proto_tree_add_item(port_tree, hf_oran_reserved_1bit, tvb, offset, 1, ENC_BIG_ENDIAN);
                     /* beamID (15 bits) */
                     proto_tree_add_item_ret_uint(port_tree, hf_oran_beamId, tvb, offset, 2, ENC_BIG_ENDIAN, &beamId);
                     proto_item_append_text(port_ti, " (beamId=%u)", beamId);
                     offset += 2;
 
                     /* bfwCompParam (TODO: present in disableBFWs case?) */
                     gboolean compression_method_supported = FALSE;
                     guint32  exponent = 0;
                     offset = dissect_bfwCompParam(tvb, port_tree, pinfo, offset, comp_meth_ti,
                                                   bfwcomphdr_comp_meth, &exponent, &compression_method_supported);
 
 
                     if (!disableBFWs) {
                         /*****************************************************************/
                         /* Table 7.7.19.1-1 (there is no part 2 for disableBFWs case...) */
                         /*****************************************************************/
 
                         /* Look up width of samples. */
                         guint8 iq_width = !bfwcomphdr_iq_width ? 16 : bfwcomphdr_iq_width;
 
                         gint bit_offset = offset*8;
                         gint bfw_offset;
 
                         /* Add weights for each TRX */
                         for (guint b=0; b < pref_num_bf_antennas; b++) {
 
                             /* Create BFW subtree */
                             bfw_offset = bit_offset / 8;
                             guint8 bfw_extent = ((bit_offset + (iq_width*2)) / 8) - bfw_offset;
                             proto_item *bfw_ti = proto_tree_add_string_format(port_tree, hf_oran_bfw,
                                                                               tvb, bfw_offset, bfw_extent,
                                                                               "", "TRX %u: (", b);
                             proto_tree *bfw_tree = proto_item_add_subtree(bfw_ti, ett_oran_bfw);
 
                             /* I */
                             /* Get bits, and convert to float. */
                             guint32 bits = tvb_get_bits(tvb, bit_offset, iq_width, ENC_BIG_ENDIAN);
                             gfloat value = decompress_value(bits, bfwcomphdr_comp_meth, iq_width, exponent);
                             /* Add to tree. */
                             proto_tree_add_float_format_value(bfw_tree, hf_oran_bfw_i, tvb, bit_offset/8, (iq_width+7)/8, value, "#%u=%f", b, value);
                             bit_offset += iq_width;
                             proto_item_append_text(bfw_ti, "I%u=%f ", b, value);
 
                             /* Q */
                             /* Get bits, and convert to float. */
                             bits = tvb_get_bits(tvb, bit_offset, iq_width, ENC_BIG_ENDIAN);
                             value = decompress_value(bits, bfwcomphdr_comp_meth, iq_width, exponent);
                             /* Add to tree. */
                             proto_tree_add_float_format_value(bfw_tree, hf_oran_bfw_q, tvb, bit_offset/8, (iq_width+7)/8, value, "#%u=%f", b, value);
                             bit_offset += iq_width;
                             proto_item_append_text(bfw_ti, "Q%u=%f)", b, value);
                         }
 
                         offset = (bit_offset+7)/8;
                     }
                     else {
                         /* No weights... */
 
                         /* Reserved (1 bit) */
                         proto_tree_add_bits_item(extension_tree, hf_oran_reserved, tvb, offset*8, 1, ENC_BIG_ENDIAN);
                         /* beamID (15 bits) */
                         proto_tree_add_item_ret_uint(extension_tree, hf_oran_beamId, tvb, offset, 2, ENC_BIG_ENDIAN, &beamId);
                         proto_item_append_text(port_ti, " (beamId=%u)", beamId);
                         offset += 2;
                     }
 
                     /* Set length of this port entry */
                     proto_item_set_len(port_ti, offset-port_start_offset);
                 }
                 break;
             }
 
             case 20:  /* Puncturing extension */
             {
                 /* numPuncPatterns */
                 guint32 numPuncPatterns;
                 proto_tree_add_item_ret_uint(extension_tree, hf_oran_numPuncPatterns, tvb, offset, 1, ENC_BIG_ENDIAN, &numPuncPatterns);
                 offset += 1;
 
                 /* Add each puncturing pattern */
                 for (guint32 n=0; n < numPuncPatterns; n++) {
                     guint pattern_start_offset = offset;
 
                     /* Subtree for this puncturing pattern */
                     proto_item *pattern_ti = proto_tree_add_string_format(extension_tree, hf_oran_puncPattern,
                                                                          tvb, offset, 0,
                                                                          "", "Puncturing Pattern: %u/%u", n+1, hf_oran_numPuncPatterns);
                     proto_tree *pattern_tree = proto_item_add_subtree(pattern_ti, ett_oran_punc_pattern);
 
                     /* SymbolMask (14 bits) */
                     proto_tree_add_item(pattern_tree, hf_oran_symbolMask_ext20, tvb, offset, 2, ENC_BIG_ENDIAN);
                     offset += 1;
                     /* startPuncPrb (10 bits) */
                     proto_tree_add_item(pattern_tree, hf_oran_startPuncPrb, tvb, offset, 1, ENC_BIG_ENDIAN);
                     offset += 2;
                     /* numPuncPrb (8 bits) */
                     proto_tree_add_item(pattern_tree, hf_oran_numPuncPrb, tvb, offset, 1, ENC_BIG_ENDIAN);
                     offset += 1;
                     /* puncReMask (12 bits) */
                     proto_tree_add_item(pattern_tree, hf_oran_puncReMask, tvb, offset, 2, ENC_BIG_ENDIAN);
                     offset += 1;
                     /* rb (1 bit) */
                     proto_tree_add_item(pattern_tree, hf_oran_rb, tvb, offset, 1, ENC_BIG_ENDIAN);
                     /* reserved (2 bits? - spec says 1) */
                     proto_tree_add_bits_item(pattern_tree, hf_oran_reserved, tvb, offset*8, 2, ENC_BIG_ENDIAN);
                     /* rbgIncl */
                     gboolean rbgIncl;
                     proto_tree_add_item_ret_boolean(pattern_tree, hf_oran_RbgIncl, tvb, offset, 1, ENC_BIG_ENDIAN, &rbgIncl);
                     offset += 1;
 
                     if (rbgIncl) {
                         /* reserved (1 bit) */
                         proto_tree_add_item(pattern_tree, hf_oran_reserved_1bit, tvb, offset, 1, ENC_BIG_ENDIAN);
                         /* rbgSize(3 bits) */
                         proto_tree_add_item(pattern_tree, hf_oran_rbgSize, tvb, offset, 1, ENC_BIG_ENDIAN);
                         /* rbgMask (28 bits) */
                         proto_tree_add_item(pattern_tree, hf_oran_rbgMask, tvb, offset, 4, ENC_BIG_ENDIAN);
                         offset += 4;
                     }
 
                     proto_item_set_len(pattern_ti, offset-pattern_start_offset);
                 }
 
                 break;
             }
             case 21:  /* Variable PRB group size for channel information */
                 /* ciPrbGroupSize */
                 proto_tree_add_item(extension_tree, hf_oran_ci_prb_group_size, tvb, offset, 1, ENC_BIG_ENDIAN);
                 offset += 1;
                 /* reserved (8 bits) */
                 proto_tree_add_bits_item(extension_tree, hf_oran_reserved, tvb, offset*8, 8, ENC_BIG_ENDIAN);
                 offset += 1;
                 break;
 
             case 22:  /* ACK/NACK request */
                 proto_tree_add_item(extension_tree, hf_oran_ack_nack_req_id, tvb, offset, 2, ENC_BIG_ENDIAN);
                 offset += 2;
                 break;
 
             default:
                 /* Other/unexpected extension types. */
                 break;
         }
 
         /* Check offset compared with extlen.  There should be 0-3 bytes of padding */
         gint num_padding_bytes = (extension_start_offset + (extlen*4) - offset);
         if ((num_padding_bytes<0) || (num_padding_bytes>3)) {
             expert_add_info_format(pinfo, extlen_ti, &ei_oran_extlen_wrong,
                                    "extlen signalled %u bytes (+ 0-3 bytes padding), but %u were dissected",
                                    extlen*4, offset-extension_start_offset);
         }
 
         /* Move offset to beyond signalled length of extension */
         offset = extension_start_offset + (extlen*4);
 
         /* Set length of extension header. */
         proto_item_set_len(extension_ti, extlen*4);
     }
 
     /* Set extent of overall section */
     proto_item_set_len(sectionHeading, offset);
 
     return offset;
 }
 
 /* Dissect udCompHdr (user data compression header, 7.5.2.10) */
 /* bit_width and comp_meth are out params */
