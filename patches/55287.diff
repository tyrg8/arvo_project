commit b63159e8bf579345a6f56d04ad1b2c28eee66bac
Author: Behdad Esfahbod <behdad@behdad.org>
Date:   Sat Jan 21 15:50:48 2023 -0700

    [PairPosFormat1] Fix stride
    
    Fixes https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=55287
    and generally the lookup with MediumTypes.

diff --git a/src/OT/Layout/GPOS/PairPosFormat1.hh b/src/OT/Layout/GPOS/PairPosFormat1.hh
index 9c9b26888..6ae8c88b9 100644
--- a/src/OT/Layout/GPOS/PairPosFormat1.hh
+++ b/src/OT/Layout/GPOS/PairPosFormat1.hh
@@ -12,208 +12,208 @@ template <typename Types>
 struct PairPosFormat1_3
 {
   using PairSet = GPOS_impl::PairSet<Types>;
   using PairValueRecord = GPOS_impl::PairValueRecord<Types>;
 
   protected:
   HBUINT16      format;                 /* Format identifier--format = 1 */
   typename Types::template OffsetTo<Coverage>
                 coverage;               /* Offset to Coverage table--from
                                          * beginning of subtable */
   ValueFormat   valueFormat[2];         /* [0] Defines the types of data in
                                          * ValueRecord1--for the first glyph
                                          * in the pair--may be zero (0) */
                                         /* [1] Defines the types of data in
                                          * ValueRecord2--for the second glyph
                                          * in the pair--may be zero (0) */
   Array16Of<typename Types::template OffsetTo<PairSet>>
                 pairSet;                /* Array of PairSet tables
                                          * ordered by Coverage Index */
   public:
   DEFINE_SIZE_ARRAY (8 + Types::size, pairSet);
 
   bool sanitize (hb_sanitize_context_t *c) const
   {
     TRACE_SANITIZE (this);
 
     if (!c->check_struct (this)) return_trace (false);
 
     unsigned int len1 = valueFormat[0].get_len ();
     unsigned int len2 = valueFormat[1].get_len ();
     typename PairSet::sanitize_closure_t closure =
     {
       valueFormat,
       len1,
-      1 + len1 + len2
+      Types::HBGlyphID::static_size + HBUINT16::static_size * (len1 + len2)
     };
 
     return_trace (coverage.sanitize (c, this) && pairSet.sanitize (c, this, &closure));
   }
 
   bool intersects (const hb_set_t *glyphs) const
   {
     auto &cov = this+coverage;
 
     if (pairSet.len > glyphs->get_population () * hb_bit_storage ((unsigned) pairSet.len) / 4)
     {
       for (hb_codepoint_t g = HB_SET_VALUE_INVALID; glyphs->next (&g);)
       {
 	unsigned i = cov.get_coverage (g);
 	if ((this+pairSet[i]).intersects (glyphs, valueFormat))
 	  return true;
       }
       return false;
     }
 
     return
     + hb_zip (cov, pairSet)
     | hb_filter (*glyphs, hb_first)
     | hb_map (hb_second)
     | hb_map ([glyphs, this] (const typename Types::template OffsetTo<PairSet> &_)
               { return (this+_).intersects (glyphs, valueFormat); })
     | hb_any
     ;
   }
 
   void closure_lookups (hb_closure_lookups_context_t *c) const {}
   void collect_variation_indices (hb_collect_variation_indices_context_t *c) const
   {
     if ((!valueFormat[0].has_device ()) && (!valueFormat[1].has_device ())) return;
 
     auto it =
     + hb_zip (this+coverage, pairSet)
     | hb_filter (c->glyph_set, hb_first)
     | hb_map (hb_second)
     ;
 
     if (!it) return;
     + it
     | hb_map (hb_add (this))
     | hb_apply ([&] (const PairSet& _) { _.collect_variation_indices (c, valueFormat); })
     ;
   }
 
   void collect_glyphs (hb_collect_glyphs_context_t *c) const
   {
     if (unlikely (!(this+coverage).collect_coverage (c->input))) return;
     unsigned int count = pairSet.len;
     for (unsigned int i = 0; i < count; i++)
       (this+pairSet[i]).collect_glyphs (c, valueFormat);
   }
 
   const Coverage &get_coverage () const { return this+coverage; }
 
   bool apply (hb_ot_apply_context_t *c) const
   {
     TRACE_APPLY (this);
     hb_buffer_t *buffer = c->buffer;
     unsigned int index = (this+coverage).get_coverage  (buffer->cur().codepoint);
     if (likely (index == NOT_COVERED)) return_trace (false);
 
     hb_ot_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;
     skippy_iter.reset (buffer->idx, 1);
     unsigned unsafe_to;
     if (!skippy_iter.next (&unsafe_to))
     {
       buffer->unsafe_to_concat (buffer->idx, unsafe_to);
       return_trace (false);
     }
 
     return_trace ((this+pairSet[index]).apply (c, valueFormat, skippy_iter.idx));
   }
 
   bool subset (hb_subset_context_t *c) const
   {
     TRACE_SUBSET (this);
 
     const hb_set_t &glyphset = *c->plan->glyphset_gsub ();
     const hb_map_t &glyph_map = *c->plan->glyph_map;
 
     auto *out = c->serializer->start_embed (*this);
     if (unlikely (!c->serializer->extend_min (out))) return_trace (false);
     out->format = format;
     out->valueFormat[0] = valueFormat[0];
     out->valueFormat[1] = valueFormat[1];
     if (c->plan->flags & HB_SUBSET_FLAGS_NO_HINTING)
     {
       hb_pair_t<unsigned, unsigned> newFormats = compute_effective_value_formats (glyphset);
       out->valueFormat[0] = newFormats.first;
       out->valueFormat[1] = newFormats.second;
     }
 
     if (c->plan->all_axes_pinned)
     {
       out->valueFormat[0] = out->valueFormat[0].drop_device_table_flags ();
       out->valueFormat[1] = out->valueFormat[1].drop_device_table_flags ();
     }
 
     hb_sorted_vector_t<hb_codepoint_t> new_coverage;
 
     + hb_zip (this+coverage, pairSet)
     | hb_filter (glyphset, hb_first)
     | hb_filter ([this, c, out] (const typename Types::template OffsetTo<PairSet>& _)
                  {
                    auto snap = c->serializer->snapshot ();
                    auto *o = out->pairSet.serialize_append (c->serializer);
                    if (unlikely (!o)) return false;
                    bool ret = o->serialize_subset (c, _, this, valueFormat, out->valueFormat);
                    if (!ret)
                    {
                      out->pairSet.pop ();
                      c->serializer->revert (snap);
                    }
                    return ret;
                  },
                  hb_second)
     | hb_map (hb_first)
     | hb_map (glyph_map)
     | hb_sink (new_coverage)
     ;
 
     out->coverage.serialize_serialize (c->serializer, new_coverage.iter ());
 
     return_trace (bool (new_coverage));
   }
 
 
   hb_pair_t<unsigned, unsigned> compute_effective_value_formats (const hb_set_t& glyphset) const
   {
     unsigned len1 = valueFormat[0].get_len ();
     unsigned len2 = valueFormat[1].get_len ();
-    unsigned record_size = HBUINT16::static_size + Value::static_size * (len1 + len2);
+    unsigned record_size = Types::HBGlyphID::static_size + Value::static_size * (len1 + len2);
 
     unsigned format1 = 0;
     unsigned format2 = 0;
     for (const auto & _ :
 	  + hb_zip (this+coverage, pairSet)
 	  | hb_filter (glyphset, hb_first)
 	  | hb_map (hb_second)
 	)
     {
       const PairSet& set = (this + _);
       const PairValueRecord *record = &set.firstPairValueRecord;
 
       unsigned count = set.len;
       for (unsigned i = 0; i < count; i++)
       {
         if (record->intersects (glyphset))
         {
           format1 = format1 | valueFormat[0].get_effective_format (record->get_values_1 ());
           format2 = format2 | valueFormat[1].get_effective_format (record->get_values_2 (valueFormat[0]));
         }
         record = &StructAtOffset<const PairValueRecord> (record, record_size);
       }
 
       if (format1 == valueFormat[0] && format2 == valueFormat[1])
         break;
     }
 
     return hb_pair (format1, format2);
   }
 };
 
 
 }
 }
 }
 
 #endif  // OT_LAYOUT_GPOS_PAIRPOSFORMAT1_HH
diff --git a/src/OT/Layout/GPOS/PairPosFormat2.hh b/src/OT/Layout/GPOS/PairPosFormat2.hh
index 4a1bf1337..de15a29e3 100644
--- a/src/OT/Layout/GPOS/PairPosFormat2.hh
+++ b/src/OT/Layout/GPOS/PairPosFormat2.hh
@@ -11,341 +11,341 @@ template <typename Types>
 struct PairPosFormat2_4
 {
   protected:
   HBUINT16      format;                 /* Format identifier--format = 2 */
   typename Types::template OffsetTo<Coverage>
                 coverage;               /* Offset to Coverage table--from
                                          * beginning of subtable */
   ValueFormat   valueFormat1;           /* ValueRecord definition--for the
                                          * first glyph of the pair--may be zero
                                          * (0) */
   ValueFormat   valueFormat2;           /* ValueRecord definition--for the
                                          * second glyph of the pair--may be
                                          * zero (0) */
   typename Types::template OffsetTo<ClassDef>
                 classDef1;              /* Offset to ClassDef table--from
                                          * beginning of PairPos subtable--for
                                          * the first glyph of the pair */
   typename Types::template OffsetTo<ClassDef>
                 classDef2;              /* Offset to ClassDef table--from
                                          * beginning of PairPos subtable--for
                                          * the second glyph of the pair */
   HBUINT16      class1Count;            /* Number of classes in ClassDef1
                                          * table--includes Class0 */
   HBUINT16      class2Count;            /* Number of classes in ClassDef2
                                          * table--includes Class0 */
   ValueRecord   values;                 /* Matrix of value pairs:
                                          * class1-major, class2-minor,
                                          * Each entry has value1 and value2 */
   public:
   DEFINE_SIZE_ARRAY (10 + 3 * Types::size, values);
 
   bool sanitize (hb_sanitize_context_t *c) const
   {
     TRACE_SANITIZE (this);
     if (!(c->check_struct (this)
        && coverage.sanitize (c, this)
        && classDef1.sanitize (c, this)
        && classDef2.sanitize (c, this))) return_trace (false);
 
     unsigned int len1 = valueFormat1.get_len ();
     unsigned int len2 = valueFormat2.get_len ();
-    unsigned int stride = len1 + len2;
+    unsigned int stride = HBUINT16::static_size * (len1 + len2);
     unsigned int record_size = valueFormat1.get_size () + valueFormat2.get_size ();
     unsigned int count = (unsigned int) class1Count * (unsigned int) class2Count;
     return_trace (c->check_range ((const void *) values,
                                   count,
                                   record_size) &&
                   valueFormat1.sanitize_values_stride_unsafe (c, this, &values[0], count, stride) &&
                   valueFormat2.sanitize_values_stride_unsafe (c, this, &values[len1], count, stride));
   }
 
   bool intersects (const hb_set_t *glyphs) const
   {
     return (this+coverage).intersects (glyphs) &&
            (this+classDef2).intersects (glyphs);
   }
 
   void closure_lookups (hb_closure_lookups_context_t *c) const {}
   void collect_variation_indices (hb_collect_variation_indices_context_t *c) const
   {
     if (!intersects (c->glyph_set)) return;
     if ((!valueFormat1.has_device ()) && (!valueFormat2.has_device ())) return;
 
     hb_set_t klass1_glyphs, klass2_glyphs;
     if (!(this+classDef1).collect_coverage (&klass1_glyphs)) return;
     if (!(this+classDef2).collect_coverage (&klass2_glyphs)) return;
 
     hb_set_t class1_set, class2_set;
     for (const unsigned cp : + c->glyph_set->iter () | hb_filter (this + coverage))
     {
       if (!klass1_glyphs.has (cp)) class1_set.add (0);
       else
       {
         unsigned klass1 = (this+classDef1).get (cp);
         class1_set.add (klass1);
       }
     }
 
     class2_set.add (0);
     for (const unsigned cp : + c->glyph_set->iter () | hb_filter (klass2_glyphs))
     {
       unsigned klass2 = (this+classDef2).get (cp);
       class2_set.add (klass2);
     }
 
     if (class1_set.is_empty ()
         || class2_set.is_empty ()
         || (class2_set.get_population() == 1 && class2_set.has(0)))
       return;
 
     unsigned len1 = valueFormat1.get_len ();
     unsigned len2 = valueFormat2.get_len ();
     const hb_array_t<const Value> values_array = values.as_array ((unsigned)class1Count * (unsigned) class2Count * (len1 + len2));
     for (const unsigned class1_idx : class1_set.iter ())
     {
       for (const unsigned class2_idx : class2_set.iter ())
       {
         unsigned start_offset = (class1_idx * (unsigned) class2Count + class2_idx) * (len1 + len2);
         if (valueFormat1.has_device ())
           valueFormat1.collect_variation_indices (c, this, values_array.sub_array (start_offset, len1));
 
         if (valueFormat2.has_device ())
           valueFormat2.collect_variation_indices (c, this, values_array.sub_array (start_offset+len1, len2));
       }
     }
   }
 
   void collect_glyphs (hb_collect_glyphs_context_t *c) const
   {
     if (unlikely (!(this+coverage).collect_coverage (c->input))) return;
     if (unlikely (!(this+classDef2).collect_coverage (c->input))) return;
   }
 
   const Coverage &get_coverage () const { return this+coverage; }
 
   bool apply (hb_ot_apply_context_t *c) const
   {
     TRACE_APPLY (this);
     hb_buffer_t *buffer = c->buffer;
     unsigned int index = (this+coverage).get_coverage  (buffer->cur().codepoint);
     if (likely (index == NOT_COVERED)) return_trace (false);
 
     hb_ot_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;
     skippy_iter.reset (buffer->idx, 1);
     unsigned unsafe_to;
     if (!skippy_iter.next (&unsafe_to))
     {
       buffer->unsafe_to_concat (buffer->idx, unsafe_to);
       return_trace (false);
     }
 
     unsigned int len1 = valueFormat1.get_len ();
     unsigned int len2 = valueFormat2.get_len ();
     unsigned int record_len = len1 + len2;
 
     unsigned int klass1 = (this+classDef1).get_class (buffer->cur().codepoint);
     unsigned int klass2 = (this+classDef2).get_class (buffer->info[skippy_iter.idx].codepoint);
     if (unlikely (klass1 >= class1Count || klass2 >= class2Count))
     {
       buffer->unsafe_to_concat (buffer->idx, skippy_iter.idx + 1);
       return_trace (false);
     }
 
     const Value *v = &values[record_len * (klass1 * class2Count + klass2)];
 
     bool applied_first = false, applied_second = false;
 
 
     /* Isolate simple kerning and apply it half to each side.
      * Results in better cursor positinoing / underline drawing.
      *
      * Disabled, because causes issues... :-(
      * https://github.com/harfbuzz/harfbuzz/issues/3408
      * https://github.com/harfbuzz/harfbuzz/pull/3235#issuecomment-1029814978
      */
 #ifndef HB_SPLIT_KERN
     if (0)
 #endif
     {
       if (!len2)
       {
         const hb_direction_t dir = buffer->props.direction;
         const bool horizontal = HB_DIRECTION_IS_HORIZONTAL (dir);
         const bool backward = HB_DIRECTION_IS_BACKWARD (dir);
         unsigned mask = horizontal ? ValueFormat::xAdvance : ValueFormat::yAdvance;
         if (backward)
           mask |= mask >> 2; /* Add eg. xPlacement in RTL. */
         /* Add Devices. */
         mask |= mask << 4;
 
         if (valueFormat1 & ~mask)
           goto bail;
 
         /* Is simple kern. Apply value on an empty position slot,
          * then split it between sides. */
 
         hb_glyph_position_t pos{};
         if (valueFormat1.apply_value (c, this, v, pos))
         {
           hb_position_t *src  = &pos.x_advance;
           hb_position_t *dst1 = &buffer->cur_pos().x_advance;
           hb_position_t *dst2 = &buffer->pos[skippy_iter.idx].x_advance;
           unsigned i = horizontal ? 0 : 1;
 
           hb_position_t kern  = src[i];
           hb_position_t kern1 = kern >> 1;
           hb_position_t kern2 = kern - kern1;
 
           if (!backward)
           {
             dst1[i] += kern1;
             dst2[i] += kern2;
             dst2[i + 2] += kern2;
           }
           else
           {
             dst1[i] += kern1;
             dst1[i + 2] += src[i + 2] - kern2;
             dst2[i] += kern2;
           }
 
           applied_first = applied_second = kern != 0;
           goto success;
         }
         goto boring;
       }
     }
     bail:
 
     if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())
     {
       c->buffer->message (c->font,
 			  "try kerning glyphs at %u,%u",
 			  c->buffer->idx, skippy_iter.idx);
     }
 
     applied_first = valueFormat1.apply_value (c, this, v, buffer->cur_pos());
     applied_second = valueFormat2.apply_value (c, this, v + len1, buffer->pos[skippy_iter.idx]);
 
     if (applied_first || applied_second)
       if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())
       {
 	c->buffer->message (c->font,
 			    "kerned glyphs at %u,%u",
 			    c->buffer->idx, skippy_iter.idx);
       }
 
     if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())
     {
       c->buffer->message (c->font,
 			  "tried kerning glyphs at %u,%u",
 			  c->buffer->idx, skippy_iter.idx);
     }
 
     success:
     if (applied_first || applied_second)
       buffer->unsafe_to_break (buffer->idx, skippy_iter.idx + 1);
     else
     boring:
       buffer->unsafe_to_concat (buffer->idx, skippy_iter.idx + 1);
 
     if (len2)
     {
       skippy_iter.idx++;
       // https://github.com/harfbuzz/harfbuzz/issues/3824
       // https://github.com/harfbuzz/harfbuzz/issues/3888#issuecomment-1326781116
       buffer->unsafe_to_break (buffer->idx, skippy_iter.idx + 1);
     }
 
     buffer->idx = skippy_iter.idx;
 
     return_trace (true);
   }
 
   bool subset (hb_subset_context_t *c) const
   {
     TRACE_SUBSET (this);
     auto *out = c->serializer->start_embed (*this);
     if (unlikely (!c->serializer->extend_min (out))) return_trace (false);
     out->format = format;
 
     hb_map_t klass1_map;
     out->classDef1.serialize_subset (c, classDef1, this, &klass1_map, true, true, &(this + coverage));
     out->class1Count = klass1_map.get_population ();
 
     hb_map_t klass2_map;
     out->classDef2.serialize_subset (c, classDef2, this, &klass2_map, true, false);
     out->class2Count = klass2_map.get_population ();
 
     unsigned len1 = valueFormat1.get_len ();
     unsigned len2 = valueFormat2.get_len ();
 
     hb_pair_t<unsigned, unsigned> newFormats = hb_pair (valueFormat1, valueFormat2);
     if (c->plan->flags & HB_SUBSET_FLAGS_NO_HINTING)
       newFormats = compute_effective_value_formats (klass1_map, klass2_map);
 
     out->valueFormat1 = newFormats.first;
     out->valueFormat2 = newFormats.second;
 
     if (c->plan->all_axes_pinned)
     {
       out->valueFormat1 = out->valueFormat1.drop_device_table_flags ();
       out->valueFormat2 = out->valueFormat2.drop_device_table_flags ();
     }
 
     for (unsigned class1_idx : + hb_range ((unsigned) class1Count) | hb_filter (klass1_map))
     {
       for (unsigned class2_idx : + hb_range ((unsigned) class2Count) | hb_filter (klass2_map))
       {
         unsigned idx = (class1_idx * (unsigned) class2Count + class2_idx) * (len1 + len2);
         valueFormat1.copy_values (c->serializer, out->valueFormat1, this, &values[idx], &c->plan->layout_variation_idx_delta_map);
         valueFormat2.copy_values (c->serializer, out->valueFormat2, this, &values[idx + len1], &c->plan->layout_variation_idx_delta_map);
       }
     }
 
     const hb_set_t &glyphset = *c->plan->glyphset_gsub ();
     const hb_map_t &glyph_map = *c->plan->glyph_map;
 
     auto it =
     + hb_iter (this+coverage)
     | hb_filter (glyphset)
     | hb_map_retains_sorting (glyph_map)
     ;
 
     out->coverage.serialize_serialize (c->serializer, it);
     return_trace (out->class1Count && out->class2Count && bool (it));
   }
 
 
   hb_pair_t<unsigned, unsigned> compute_effective_value_formats (const hb_map_t& klass1_map,
                                                                  const hb_map_t& klass2_map) const
   {
     unsigned len1 = valueFormat1.get_len ();
     unsigned len2 = valueFormat2.get_len ();
     unsigned record_size = len1 + len2;
 
     unsigned format1 = 0;
     unsigned format2 = 0;
 
     for (unsigned class1_idx : + hb_range ((unsigned) class1Count) | hb_filter (klass1_map))
     {
       for (unsigned class2_idx : + hb_range ((unsigned) class2Count) | hb_filter (klass2_map))
       {
         unsigned idx = (class1_idx * (unsigned) class2Count + class2_idx) * record_size;
         format1 = format1 | valueFormat1.get_effective_format (&values[idx]);
         format2 = format2 | valueFormat2.get_effective_format (&values[idx + len1]);
       }
 
       if (format1 == valueFormat1 && format2 == valueFormat2)
         break;
     }
 
     return hb_pair (format1, format2);
   }
 };
 
 }
 }
 }
 
 #endif  // OT_LAYOUT_GPOS_PAIRPOSFORMAT2_HH
diff --git a/src/OT/Layout/GPOS/PairSet.hh b/src/OT/Layout/GPOS/PairSet.hh
index 3befcc379..2bf36d604 100644
--- a/src/OT/Layout/GPOS/PairSet.hh
+++ b/src/OT/Layout/GPOS/PairSet.hh
@@ -12,192 +12,191 @@ template <typename Types>
 struct PairSet
 {
   template <typename Types2>
   friend struct PairPosFormat1_3;
 
   using PairValueRecord = GPOS_impl::PairValueRecord<Types>;
 
   protected:
   HBUINT16              len;    /* Number of PairValueRecords */
   PairValueRecord       firstPairValueRecord;
                                 /* Array of PairValueRecords--ordered
                                  * by GlyphID of the second glyph */
   public:
   DEFINE_SIZE_MIN (2);
 
   struct sanitize_closure_t
   {
     const ValueFormat *valueFormats;
     unsigned int len1; /* valueFormats[0].get_len() */
-    unsigned int stride; /* 1 + len1 + len2 */
+    unsigned int stride; /* bytes */
   };
 
   bool sanitize (hb_sanitize_context_t *c, const sanitize_closure_t *closure) const
   {
     TRACE_SANITIZE (this);
     if (!(c->check_struct (this)
        && c->check_range (&firstPairValueRecord,
                           len,
-                          HBUINT16::static_size,
                           closure->stride))) return_trace (false);
 
     unsigned int count = len;
     const PairValueRecord *record = &firstPairValueRecord;
     return_trace (closure->valueFormats[0].sanitize_values_stride_unsafe (c, this, &record->values[0], count, closure->stride) &&
                   closure->valueFormats[1].sanitize_values_stride_unsafe (c, this, &record->values[closure->len1], count, closure->stride));
   }
 
   bool intersects (const hb_set_t *glyphs,
                    const ValueFormat *valueFormats) const
   {
     unsigned int len1 = valueFormats[0].get_len ();
     unsigned int len2 = valueFormats[1].get_len ();
-    unsigned int record_size = HBUINT16::static_size * (1 + len1 + len2);
+    unsigned int record_size = Types::HBGlyphID::static_size + Value::static_size * (len1 + len2);
 
     const PairValueRecord *record = &firstPairValueRecord;
     unsigned int count = len;
     for (unsigned int i = 0; i < count; i++)
     {
       if (glyphs->has (record->secondGlyph))
         return true;
       record = &StructAtOffset<const PairValueRecord> (record, record_size);
     }
     return false;
   }
 
   void collect_glyphs (hb_collect_glyphs_context_t *c,
                        const ValueFormat *valueFormats) const
   {
     unsigned int len1 = valueFormats[0].get_len ();
     unsigned int len2 = valueFormats[1].get_len ();
-    unsigned int record_size = HBUINT16::static_size * (1 + len1 + len2);
+    unsigned int record_size = Types::HBGlyphID::static_size + Value::static_size * (len1 + len2);
 
     const PairValueRecord *record = &firstPairValueRecord;
     c->input->add_array (&record->secondGlyph, len, record_size);
   }
 
   void collect_variation_indices (hb_collect_variation_indices_context_t *c,
                                   const ValueFormat *valueFormats) const
   {
     unsigned len1 = valueFormats[0].get_len ();
     unsigned len2 = valueFormats[1].get_len ();
-    unsigned record_size = HBUINT16::static_size * (1 + len1 + len2);
+    unsigned int record_size = Types::HBGlyphID::static_size + Value::static_size * (len1 + len2);
 
     const PairValueRecord *record = &firstPairValueRecord;
     unsigned count = len;
     for (unsigned i = 0; i < count; i++)
     {
       if (c->glyph_set->has (record->secondGlyph))
       { record->collect_variation_indices (c, valueFormats, this); }
 
       record = &StructAtOffset<const PairValueRecord> (record, record_size);
     }
   }
 
   bool apply (hb_ot_apply_context_t *c,
               const ValueFormat *valueFormats,
               unsigned int pos) const
   {
     TRACE_APPLY (this);
     hb_buffer_t *buffer = c->buffer;
     unsigned int len1 = valueFormats[0].get_len ();
     unsigned int len2 = valueFormats[1].get_len ();
-    unsigned int record_size = HBUINT16::static_size * (1 + len1 + len2);
+    unsigned int record_size = Types::HBGlyphID::static_size + Value::static_size * (len1 + len2);
 
     const PairValueRecord *record = hb_bsearch (buffer->info[pos].codepoint,
                                                 &firstPairValueRecord,
                                                 len,
                                                 record_size);
     if (record)
     {
       if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())
       {
 	c->buffer->message (c->font,
 			    "try kerning glyphs at %u,%u",
 			    c->buffer->idx, pos);
       }
 
       bool applied_first = valueFormats[0].apply_value (c, this, &record->values[0], buffer->cur_pos());
       bool applied_second = valueFormats[1].apply_value (c, this, &record->values[len1], buffer->pos[pos]);
 
       if (applied_first || applied_second)
 	if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())
 	{
 	  c->buffer->message (c->font,
 			      "kerned glyphs at %u,%u",
 			      c->buffer->idx, pos);
 	}
 
       if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())
       {
 	c->buffer->message (c->font,
 			    "tried kerning glyphs at %u,%u",
 			    c->buffer->idx, pos);
       }
 
       if (applied_first || applied_second)
         buffer->unsafe_to_break (buffer->idx, pos + 1);
 
       if (len2)
       {
 	pos++;
       // https://github.com/harfbuzz/harfbuzz/issues/3824
       // https://github.com/harfbuzz/harfbuzz/issues/3888#issuecomment-1326781116
       buffer->unsafe_to_break (buffer->idx, pos + 1);
       }
 
       buffer->idx = pos;
       return_trace (true);
     }
     buffer->unsafe_to_concat (buffer->idx, pos + 1);
     return_trace (false);
   }
 
   bool subset (hb_subset_context_t *c,
                const ValueFormat valueFormats[2],
                const ValueFormat newFormats[2]) const
   {
     TRACE_SUBSET (this);
     auto snap = c->serializer->snapshot ();
 
     auto *out = c->serializer->start_embed (*this);
     if (unlikely (!c->serializer->extend_min (out))) return_trace (false);
     out->len = 0;
 
     const hb_set_t &glyphset = *c->plan->glyphset_gsub ();
     const hb_map_t &glyph_map = *c->plan->glyph_map;
 
     unsigned len1 = valueFormats[0].get_len ();
     unsigned len2 = valueFormats[1].get_len ();
-    unsigned record_size = HBUINT16::static_size + Value::static_size * (len1 + len2);
+    unsigned int record_size = Types::HBGlyphID::static_size + Value::static_size * (len1 + len2);
 
     typename PairValueRecord::context_t context =
     {
       this,
       valueFormats,
       newFormats,
       len1,
       &glyph_map,
       &c->plan->layout_variation_idx_delta_map
     };
 
     const PairValueRecord *record = &firstPairValueRecord;
     unsigned count = len, num = 0;
     for (unsigned i = 0; i < count; i++)
     {
       if (glyphset.has (record->secondGlyph)
          && record->subset (c, &context)) num++;
       record = &StructAtOffset<const PairValueRecord> (record, record_size);
     }
 
     out->len = num;
     if (!num) c->serializer->revert (snap);
     return_trace (num);
   }
 };
 
 
 }
 }
 }
 
 #endif  // OT_LAYOUT_GPOS_PAIRSET_HH
diff --git a/src/OT/Layout/GPOS/ValueFormat.hh b/src/OT/Layout/GPOS/ValueFormat.hh
index 26a40f01a..1aa451abc 100644
--- a/src/OT/Layout/GPOS/ValueFormat.hh
+++ b/src/OT/Layout/GPOS/ValueFormat.hh
@@ -14,381 +14,381 @@ typedef UnsizedArrayOf<Value> ValueRecord;
 struct ValueFormat : HBUINT16
 {
   enum Flags {
     xPlacement  = 0x0001u,      /* Includes horizontal adjustment for placement */
     yPlacement  = 0x0002u,      /* Includes vertical adjustment for placement */
     xAdvance    = 0x0004u,      /* Includes horizontal adjustment for advance */
     yAdvance    = 0x0008u,      /* Includes vertical adjustment for advance */
     xPlaDevice  = 0x0010u,      /* Includes horizontal Device table for placement */
     yPlaDevice  = 0x0020u,      /* Includes vertical Device table for placement */
     xAdvDevice  = 0x0040u,      /* Includes horizontal Device table for advance */
     yAdvDevice  = 0x0080u,      /* Includes vertical Device table for advance */
     ignored     = 0x0F00u,      /* Was used in TrueType Open for MM fonts */
     reserved    = 0xF000u,      /* For future use */
 
     devices     = 0x00F0u       /* Mask for having any Device table */
   };
 
 /* All fields are options.  Only those available advance the value pointer. */
 #if 0
   HBINT16               xPlacement;     /* Horizontal adjustment for
                                          * placement--in design units */
   HBINT16               yPlacement;     /* Vertical adjustment for
                                          * placement--in design units */
   HBINT16               xAdvance;       /* Horizontal adjustment for
                                          * advance--in design units (only used
                                          * for horizontal writing) */
   HBINT16               yAdvance;       /* Vertical adjustment for advance--in
                                          * design units (only used for vertical
                                          * writing) */
   Offset16To<Device>    xPlaDevice;     /* Offset to Device table for
                                          * horizontal placement--measured from
                                          * beginning of PosTable (may be NULL) */
   Offset16To<Device>    yPlaDevice;     /* Offset to Device table for vertical
                                          * placement--measured from beginning
                                          * of PosTable (may be NULL) */
   Offset16To<Device>    xAdvDevice;     /* Offset to Device table for
                                          * horizontal advance--measured from
                                          * beginning of PosTable (may be NULL) */
   Offset16To<Device>    yAdvDevice;     /* Offset to Device table for vertical
                                          * advance--measured from beginning of
                                          * PosTable (may be NULL) */
 #endif
 
   IntType& operator = (uint16_t i) { v = i; return *this; }
 
   unsigned int get_len () const  { return hb_popcount ((unsigned int) *this); }
   unsigned int get_size () const { return get_len () * Value::static_size; }
 
   hb_vector_t<unsigned> get_device_table_indices () const {
     unsigned i = 0;
     hb_vector_t<unsigned> result;
     unsigned format = *this;
 
     if (format & xPlacement) i++;
     if (format & yPlacement) i++;
     if (format & xAdvance)   i++;
     if (format & yAdvance)   i++;
 
     if (format & xPlaDevice) result.push (i++);
     if (format & yPlaDevice) result.push (i++);
     if (format & xAdvDevice) result.push (i++);
     if (format & yAdvDevice) result.push (i++);
 
     return result;
   }
 
   bool apply_value (hb_ot_apply_context_t *c,
                     const void            *base,
                     const Value           *values,
                     hb_glyph_position_t   &glyph_pos) const
   {
     bool ret = false;
     unsigned int format = *this;
     if (!format) return ret;
 
     hb_font_t *font = c->font;
     bool horizontal =
 #ifndef HB_NO_VERTICAL
       HB_DIRECTION_IS_HORIZONTAL (c->direction)
 #else
       true
 #endif
       ;
 
     if (format & xPlacement) glyph_pos.x_offset  += font->em_scale_x (get_short (values++, &ret));
     if (format & yPlacement) glyph_pos.y_offset  += font->em_scale_y (get_short (values++, &ret));
     if (format & xAdvance) {
       if (likely (horizontal)) glyph_pos.x_advance += font->em_scale_x (get_short (values, &ret));
       values++;
     }
     /* y_advance values grow downward but font-space grows upward, hence negation */
     if (format & yAdvance) {
       if (unlikely (!horizontal)) glyph_pos.y_advance -= font->em_scale_y (get_short (values, &ret));
       values++;
     }
 
     if (!has_device ()) return ret;
 
     bool use_x_device = font->x_ppem || font->num_coords;
     bool use_y_device = font->y_ppem || font->num_coords;
 
     if (!use_x_device && !use_y_device) return ret;
 
     const VariationStore &store = c->var_store;
     auto *cache = c->var_store_cache;
 
     /* pixel -> fractional pixel */
     if (format & xPlaDevice) {
       if (use_x_device) glyph_pos.x_offset  += (base + get_device (values, &ret)).get_x_delta (font, store, cache);
       values++;
     }
     if (format & yPlaDevice) {
       if (use_y_device) glyph_pos.y_offset  += (base + get_device (values, &ret)).get_y_delta (font, store, cache);
       values++;
     }
     if (format & xAdvDevice) {
       if (horizontal && use_x_device) glyph_pos.x_advance += (base + get_device (values, &ret)).get_x_delta (font, store, cache);
       values++;
     }
     if (format & yAdvDevice) {
       /* y_advance values grow downward but font-space grows upward, hence negation */
       if (!horizontal && use_y_device) glyph_pos.y_advance -= (base + get_device (values, &ret)).get_y_delta (font, store, cache);
       values++;
     }
     return ret;
   }
 
   unsigned int get_effective_format (const Value *values) const
   {
     unsigned int format = *this;
     for (unsigned flag = xPlacement; flag <= yAdvDevice; flag = flag << 1) {
       if (format & flag) should_drop (*values++, (Flags) flag, &format);
     }
 
     return format;
   }
 
   template<typename Iterator,
       hb_requires (hb_is_iterator (Iterator))>
   unsigned int get_effective_format (Iterator it) const {
     unsigned int new_format = 0;
 
     for (const hb_array_t<const Value>& values : it)
       new_format = new_format | get_effective_format (&values);
 
     return new_format;
   }
 
   void copy_values (hb_serialize_context_t *c,
                     unsigned int new_format,
                     const void *base,
                     const Value *values,
                     const hb_hashmap_t<unsigned, hb_pair_t<unsigned, int>> *layout_variation_idx_delta_map) const
   {
     unsigned int format = *this;
     if (!format) return;
 
     HBINT16 *x_placement = nullptr, *y_placement = nullptr, *x_adv = nullptr, *y_adv = nullptr;
     if (format & xPlacement) x_placement = copy_value (c, new_format, xPlacement, *values++);
     if (format & yPlacement) y_placement = copy_value (c, new_format, yPlacement, *values++);
     if (format & xAdvance)   x_adv = copy_value (c, new_format, xAdvance, *values++);
     if (format & yAdvance)   y_adv = copy_value (c, new_format, yAdvance, *values++);
 
     if (format & xPlaDevice)
     {
       add_delta_to_value (x_placement, base, values, layout_variation_idx_delta_map);
       copy_device (c, base, values++, layout_variation_idx_delta_map, new_format, xPlaDevice);
     }
 
     if (format & yPlaDevice)
     {
       add_delta_to_value (y_placement, base, values, layout_variation_idx_delta_map);
       copy_device (c, base, values++, layout_variation_idx_delta_map, new_format, yPlaDevice);
     }
 
     if (format & xAdvDevice)
     {
       add_delta_to_value (x_adv, base, values, layout_variation_idx_delta_map);
       copy_device (c, base, values++, layout_variation_idx_delta_map, new_format, xAdvDevice);
     }
 
     if (format & yAdvDevice)
     {
       add_delta_to_value (y_adv, base, values, layout_variation_idx_delta_map);
       copy_device (c, base, values++, layout_variation_idx_delta_map, new_format, yAdvDevice);
     }
   }
 
   HBINT16* copy_value (hb_serialize_context_t *c,
                        unsigned int new_format,
                        Flags flag,
                        Value value) const
   {
     // Filter by new format.
     if (!(new_format & flag)) return nullptr;
     return reinterpret_cast<HBINT16 *> (c->copy (value));
   }
 
   void collect_variation_indices (hb_collect_variation_indices_context_t *c,
                                   const void *base,
                                   const hb_array_t<const Value>& values) const
   {
     unsigned format = *this;
     unsigned i = 0;
     if (format & xPlacement) i++;
     if (format & yPlacement) i++;
     if (format & xAdvance) i++;
     if (format & yAdvance) i++;
     if (format & xPlaDevice)
     {
       (base + get_device (&(values[i]))).collect_variation_indices (c);
       i++;
     }
 
     if (format & ValueFormat::yPlaDevice)
     {
       (base + get_device (&(values[i]))).collect_variation_indices (c);
       i++;
     }
 
     if (format & ValueFormat::xAdvDevice)
     {
 
       (base + get_device (&(values[i]))).collect_variation_indices (c);
       i++;
     }
 
     if (format & ValueFormat::yAdvDevice)
     {
 
       (base + get_device (&(values[i]))).collect_variation_indices (c);
       i++;
     }
   }
 
   unsigned drop_device_table_flags () const
   {
     unsigned format = *this;
     for (unsigned flag = xPlaDevice; flag <= yAdvDevice; flag = flag << 1)
       format = format & ~flag;
 
     return format;
   }
 
   private:
   bool sanitize_value_devices (hb_sanitize_context_t *c, const void *base, const Value *values) const
   {
     unsigned int format = *this;
 
     if (format & xPlacement) values++;
     if (format & yPlacement) values++;
     if (format & xAdvance)   values++;
     if (format & yAdvance)   values++;
 
     if ((format & xPlaDevice) && !get_device (values++).sanitize (c, base)) return false;
     if ((format & yPlaDevice) && !get_device (values++).sanitize (c, base)) return false;
     if ((format & xAdvDevice) && !get_device (values++).sanitize (c, base)) return false;
     if ((format & yAdvDevice) && !get_device (values++).sanitize (c, base)) return false;
 
     return true;
   }
 
   static inline Offset16To<Device>& get_device (Value* value)
   {
     return *static_cast<Offset16To<Device> *> (value);
   }
   static inline const Offset16To<Device>& get_device (const Value* value, bool *worked=nullptr)
   {
     if (worked) *worked |= bool (*value);
     return *static_cast<const Offset16To<Device> *> (value);
   }
 
   void add_delta_to_value (HBINT16 *value,
                            const void *base,
                            const Value *src_value,
                            const hb_hashmap_t<unsigned, hb_pair_t<unsigned, int>> *layout_variation_idx_delta_map) const
   {
     if (!value) return;
     unsigned varidx = (base + get_device (src_value)).get_variation_index ();
     hb_pair_t<unsigned, int> *varidx_delta;
     if (!layout_variation_idx_delta_map->has (varidx, &varidx_delta)) return;
 
     *value += hb_second (*varidx_delta);
   }
 
   bool copy_device (hb_serialize_context_t *c, const void *base,
                     const Value *src_value,
                     const hb_hashmap_t<unsigned, hb_pair_t<unsigned, int>> *layout_variation_idx_delta_map,
                     unsigned int new_format, Flags flag) const
   {
     // Filter by new format.
     if (!(new_format & flag)) return true;
 
     Value       *dst_value = c->copy (*src_value);
 
     if (!dst_value) return false;
     if (*dst_value == 0) return true;
 
     *dst_value = 0;
     c->push ();
     if ((base + get_device (src_value)).copy (c, layout_variation_idx_delta_map))
     {
       c->add_link (*dst_value, c->pop_pack ());
       return true;
     }
     else
     {
       c->pop_discard ();
       return false;
     }
   }
 
   static inline const HBINT16& get_short (const Value* value, bool *worked=nullptr)
   {
     if (worked) *worked |= bool (*value);
     return *reinterpret_cast<const HBINT16 *> (value);
   }
 
   public:
 
   bool has_device () const
   {
     unsigned int format = *this;
     return (format & devices) != 0;
   }
 
   bool sanitize_value (hb_sanitize_context_t *c, const void *base, const Value *values) const
   {
     TRACE_SANITIZE (this);
     return_trace (c->check_range (values, get_size ()) && (!has_device () || sanitize_value_devices (c, base, values)));
   }
 
   bool sanitize_values (hb_sanitize_context_t *c, const void *base, const Value *values, unsigned int count) const
   {
     TRACE_SANITIZE (this);
     unsigned int len = get_len ();
 
     if (!c->check_range (values, count, get_size ())) return_trace (false);
 
     if (!has_device ()) return_trace (true);
 
     for (unsigned int i = 0; i < count; i++) {
       if (!sanitize_value_devices (c, base, values))
         return_trace (false);
       values += len;
     }
 
     return_trace (true);
   }
 
   /* Just sanitize referenced Device tables.  Doesn't check the values themselves. */
   bool sanitize_values_stride_unsafe (hb_sanitize_context_t *c, const void *base, const Value *values, unsigned int count, unsigned int stride) const
   {
     TRACE_SANITIZE (this);
 
     if (!has_device ()) return_trace (true);
 
     for (unsigned int i = 0; i < count; i++) {
       if (!sanitize_value_devices (c, base, values))
         return_trace (false);
-      values += stride;
+      values = &StructAtOffset<const Value> (values, stride);
     }
 
     return_trace (true);
   }
 
  private:
 
   void should_drop (Value value, Flags flag, unsigned int* format) const
   {
     if (value) return;
     *format = *format & ~flag;
   }
 
 };
 
 }
 }
 }
 
 #endif  // #ifndef OT_LAYOUT_GPOS_VALUEFORMAT_HH
diff --git a/test/fuzzing/fonts/clusterfuzz-testcase-minimized-hb-shape-fuzzer-5965759719538688 b/test/fuzzing/fonts/clusterfuzz-testcase-minimized-hb-shape-fuzzer-5965759719538688
new file mode 100644
index 000000000..a3e1a1025
Binary files /dev/null and b/test/fuzzing/fonts/clusterfuzz-testcase-minimized-hb-shape-fuzzer-5965759719538688 differ
