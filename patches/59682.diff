commit 89bbed83db22b8d63b3e6354963d8d595199304e
Author: akallabeth <akallabeth@posteo.net>
Date:   Mon Jun 12 12:06:38 2023 +0200

    [common,assistance] clean up assistance file parser

diff --git a/libfreerdp/common/assistance.c b/libfreerdp/common/assistance.c
index 73abee8e9..66286e692 100644
--- a/libfreerdp/common/assistance.c
+++ b/libfreerdp/common/assistance.c
@@ -1,38 +1,40 @@
 /**
  * FreeRDP: A Remote Desktop Protocol Implementation
  * Remote Assistance
  *
  * Copyright 2014 Marc-Andre Moreau <marcandre.moreau@gmail.com>
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 #include <freerdp/config.h>
 
 #include <errno.h>
 
 #include <winpr/wtypes.h>
+#include <winpr/collections.h>
+#include <winpr/string.h>
 #include <winpr/crt.h>
 #include <winpr/crypto.h>
 #include <winpr/print.h>
 #include <winpr/windows.h>
 #include <winpr/ssl.h>
 #include <winpr/file.h>
 
 #include <freerdp/log.h>
 #include <freerdp/client/file.h>
 #include <freerdp/client/cmdline.h>
 
 #include <freerdp/assistance.h>
 
 #define TAG FREERDP_TAG("common")
@@ -40,68 +42,172 @@
 struct rdp_assistance_file
 {
 	UINT32 Type;
 
 	char* Username;
 	char* LHTicket;
 	char* RCTicket;
 	char* PassStub;
 	UINT32 DtStart;
 	UINT32 DtLength;
 	BOOL LowSpeed;
 	BOOL RCTicketEncrypted;
 
 	char* ConnectionString1;
 	char* ConnectionString2;
 
 	BYTE* EncryptedPassStub;
 	size_t EncryptedPassStubLength;
 
 	BYTE* EncryptedLHTicket;
 	size_t EncryptedLHTicketLength;
 
-	UINT32 MachineCount;
-	char** MachineAddresses;
-	UINT32* MachinePorts;
+	wArrayList* MachineAddresses;
+	wArrayList* MachinePorts;
+	wArrayList* MachineUris;
 
 	char* RASessionId;
 	char* RASpecificParams;
+	char* RASpecificParams2;
 
 	char* filename;
 	char* password;
 };
 
+static char* strrstr(const char* haystack, size_t len, const char* needle)
+{
+	if (*needle == '\0')
+		return (char*)haystack;
+
+	char* result = NULL;
+	for (;;)
+	{
+		char* p = strstr(haystack, needle);
+		if (p == NULL)
+			break;
+		if (p > haystack + len)
+			return NULL;
+
+		result = p;
+		haystack = p + 1;
+	}
+
+	return result;
+}
+
+static BOOL update_option(char** opt, const char* val, size_t len)
+{
+	WINPR_ASSERT(opt);
+	free(*opt);
+	*opt = NULL;
+
+	if (!val && (len != 0))
+		return FALSE;
+	else if (!val && (len == 0))
+		return TRUE;
+	*opt = strndup(val, len);
+	return *opt != NULL;
+}
+
+static BOOL update_name(rdpAssistanceFile* file, const char* name)
+{
+	WINPR_ASSERT(file);
+
+	if (!name)
+	{
+		WLog_ERR(TAG, "ASSISTANCE file %s invalid name", name);
+		return FALSE;
+	}
+
+	free(file->filename);
+	file->filename = _strdup(name);
+	return file->filename != NULL;
+}
+
+static BOOL update_password(rdpAssistanceFile* file, const char* password)
+{
+	WINPR_ASSERT(file);
+	free(file->password);
+	file->password = NULL;
+	if (!password)
+		return TRUE;
+	file->password = _strdup(password);
+	return file->password != NULL;
+}
+
+static BOOL update_connectionstring2_nocopy(rdpAssistanceFile* file, char* str)
+{
+	WINPR_ASSERT(file);
+	free(file->ConnectionString2);
+	file->ConnectionString2 = NULL;
+	if (!str)
+		return TRUE;
+	file->ConnectionString2 = str;
+	return file->ConnectionString2 != NULL;
+}
+
+static BOOL update_connectionstring2(rdpAssistanceFile* file, const char* str, size_t len)
+{
+	char* strc = NULL;
+	if (!str && (len != 0))
+		return FALSE;
+
+	if (str && (len > 0))
+	{
+		strc = strndup(str, len);
+		if (!strc)
+			return FALSE;
+	}
+	return update_connectionstring2_nocopy(file, strc);
+}
+
+static BOOL update_connectionstring2_wchar(rdpAssistanceFile* file, const WCHAR* str, size_t len)
+{
+	char* strc = NULL;
+
+	if (!str && (len != 0))
+		return FALSE;
+
+	if (str && (len > 0))
+	{
+		strc = ConvertWCharNToUtf8Alloc(str, len, NULL);
+		if (!strc)
+			return FALSE;
+	}
+	return update_connectionstring2_nocopy(file, strc);
+}
+
 /**
  * Password encryption in establishing a remote assistance session of type 1:
  * http://blogs.msdn.com/b/openspecification/archive/2011/10/31/password-encryption-in-establishing-a-remote-assistance-session-of-type-1.aspx
  *
  * Creation of PassStub for the Remote Assistance Ticket:
  * http://social.msdn.microsoft.com/Forums/en-US/6316c3f4-ea09-4343-a4a1-9cca46d70d28/creation-of-passstub-for-the-remote-assistance-ticket?forum=os_windowsprotocols
  */
 
 /**
  * CryptDeriveKey Function:
  * http://msdn.microsoft.com/en-us/library/windows/desktop/aa379916/
  *
  * Let n be the required derived key length, in bytes.
  * The derived key is the first n bytes of the hash value after the hash computation
  * has been completed by CryptDeriveKey. If the hash is not a member of the SHA-2
  * family and the required key is for either 3DES or AES, the key is derived as follows:
  *
  * Form a 64-byte buffer by repeating the constant 0x36 64 times.
  * Let k be the length of the hash value that is represented by the input parameter hBaseData.
  * Set the first k bytes of the buffer to the result of an XOR operation of the first k bytes
  * of the buffer with the hash value that is represented by the input parameter hBaseData.
  *
  * Form a 64-byte buffer by repeating the constant 0x5C 64 times.
  * Set the first k bytes of the buffer to the result of an XOR operation of the first k bytes
  * of the buffer with the hash value that is represented by the input parameter hBaseData.
  *
  * Hash the result of step 1 by using the same hash algorithm as that used to compute the hash
  * value that is represented by the hBaseData parameter.
  *
  * Hash the result of step 2 by using the same hash algorithm as that used to compute the hash
  * value that is represented by the hBaseData parameter.
  *
  * Concatenate the result of step 3 with the result of step 4.
  * Use the first n bytes of the result of step 5 as the derived key.
  */
@@ -109,30 +215,29 @@ struct rdp_assistance_file
 static BOOL freerdp_assistance_crypt_derive_key_sha1(BYTE* hash, size_t hashLength, BYTE* key,
                                                      size_t keyLength)
 {
 	BOOL rc = FALSE;
-	size_t i;
-	BYTE* buffer;
-	BYTE pad1[64];
-	BYTE pad2[64];
-	memset(pad1, 0x36, 64);
-	memset(pad2, 0x5C, 64);
+	BYTE pad1[64] = { 0 };
+	BYTE pad2[64] = { 0 };
+
+	memset(pad1, 0x36, sizeof(pad1));
+	memset(pad2, 0x5C, sizeof(pad2));
 
-	for (i = 0; i < hashLength; i++)
+	for (size_t i = 0; i < hashLength; i++)
 	{
 		pad1[i] ^= hash[i];
 		pad2[i] ^= hash[i];
 	}
 
-	buffer = (BYTE*)calloc(hashLength, 2);
+	BYTE* buffer = (BYTE*)calloc(hashLength, 2);
 
 	if (!buffer)
 		goto fail;
 
 	if (!winpr_Digest(WINPR_MD_SHA1, pad1, 64, buffer, hashLength))
 		goto fail;
 
 	if (!winpr_Digest(WINPR_MD_SHA1, pad2, 64, &buffer[hashLength], hashLength))
 		goto fail;
 
 	CopyMemory(key, buffer, keyLength);
 	rc = TRUE;
@@ -141,69 +246,52 @@ fail:
 	return rc;
 }
 
-static BOOL reallocate(rdpAssistanceFile* file, const char* host, UINT32 port)
-{
-	void *tmp1, *tmp2;
-	file->MachineCount++;
-	tmp1 = realloc(file->MachinePorts, sizeof(UINT32) * file->MachineCount);
-	tmp2 = realloc(file->MachineAddresses, sizeof(char*) * file->MachineCount);
-
-	if (!tmp1 || !tmp2)
-	{
-		free(tmp1);
-		free(tmp2);
-		return FALSE;
-	}
-
-	file->MachinePorts = tmp1;
-	file->MachineAddresses = tmp2;
-	file->MachinePorts[file->MachineCount - 1] = port;
-	file->MachineAddresses[file->MachineCount - 1] = _strdup(host);
-	return TRUE;
-}
-
 static BOOL append_address(rdpAssistanceFile* file, const char* host, const char* port)
 {
-	unsigned long p;
+	WINPR_ASSERT(file);
+
 	errno = 0;
-	p = strtoul(port, NULL, 0);
+	unsigned long p = strtoul(port, NULL, 0);
 
 	if ((errno != 0) || (p == 0) || (p > UINT16_MAX))
 	{
 		WLog_ERR(TAG, "Failed to parse ASSISTANCE file: ConnectionString2 invalid port value %s",
 		         port);
 		return FALSE;
 	}
 
-	return reallocate(file, host, (UINT16)p);
+	if (!ArrayList_Append(file->MachineAddresses, _strdup(host)))
+		return FALSE;
+	return ArrayList_Append(file->MachinePorts, p);
 }
 
 static BOOL freerdp_assistance_parse_address_list(rdpAssistanceFile* file, char* list)
 {
+	WINPR_ASSERT(file);
+
 	WLog_DBG(TAG, "freerdp_assistance_parse_address_list list=%s", list);
 
 	BOOL rc = FALSE;
 
-	if (!file || !list)
+	if (!list)
 		return FALSE;
 
 	char* strp = list;
 	char* s = ";";
-	char* token;
 
 	// get the first token
-	token = strtok(strp, s);
+	char* token = strtok(strp, s);
 
 	// walk through other tokens
 	while (token != NULL)
 	{
 		char* port = strchr(token, ':');
 		*port = '\0';
 		port++;
 
 		if (!append_address(file, token, port))
 			goto out;
 
 		token = strtok(NULL, s);
 	}
 	rc = TRUE;
@@ -213,75 +301,73 @@ out:
 
 static BOOL freerdp_assistance_parse_connection_string1(rdpAssistanceFile* file)
 {
-	size_t i;
-	char* str;
-	int count;
-	size_t length;
-	char* tokens[8];
+	char* tokens[8] = { 0 };
 	BOOL rc = FALSE;
 
-	if (!file || !file->RCTicket)
+	WINPR_ASSERT(file);
+
+	if (!file->RCTicket)
 		return FALSE;
 
 	/**
 	 * <ProtocolVersion>,<protocolType>,<machineAddressList>,<assistantAccountPwd>,
 	 * <RASessionID>,<RASessionName>,<RASessionPwd>,<protocolSpecificParms>
 	 */
-	count = 1;
-	str = _strdup(file->RCTicket);
+	char* str = _strdup(file->RCTicket);
 
 	if (!str)
 		goto error;
 
-	length = strlen(str);
+	const size_t length = strlen(str);
 
-	for (i = 0; i < length; i++)
+	int count = 1;
+	for (size_t i = 0; i < length; i++)
 	{
 		if (str[i] == ',')
 			count++;
 	}
 
 	if (count != 8)
 		goto error;
 
 	count = 0;
 	tokens[count++] = str;
 
-	for (i = 0; i < length; i++)
+	for (size_t i = 0; i < length; i++)
 	{
 		if (str[i] == ',')
 		{
 			str[i] = '\0';
 			tokens[count++] = &str[i + 1];
 		}
 	}
 
 	if (strcmp(tokens[0], "65538") != 0)
 		goto error;
 
 	if (strcmp(tokens[1], "1") != 0)
 		goto error;
 
 	if (strcmp(tokens[3], "*") != 0)
 		goto error;
 
 	if (strcmp(tokens[5], "*") != 0)
 		goto error;
 
 	if (strcmp(tokens[6], "*") != 0)
 		goto error;
 
 	file->RASessionId = _strdup(tokens[4]);
 
 	if (!file->RASessionId)
 		goto error;
 
 	file->RASpecificParams = _strdup(tokens[7]);
 
 	if (!file->RASpecificParams)
 		goto error;
 
 	if (!freerdp_assistance_parse_address_list(file, tokens[2]))
 		goto error;
 
 	rc = TRUE;
@@ -303,170 +389,339 @@ error:
  * </E>
  */
 
-static BOOL freerdp_assistance_parse_connection_string2(rdpAssistanceFile* file)
+static BOOL freerdp_assistance_parse_attr(const char** opt, size_t* plength, const char* key,
+                                          const char* tag)
 {
-	char* str;
-	char* tag;
-	char* end;
-	char* p;
-	BOOL rc = FALSE;
+	WINPR_ASSERT(opt);
+	WINPR_ASSERT(plength);
+	WINPR_ASSERT(key);
 
-	if (!file || !file->ConnectionString2)
+	*opt = NULL;
+	*plength = 0;
+	if (!tag)
 		return FALSE;
 
-	str = file->ConnectionString2;
+	char bkey[128] = { 0 };
+	const int rc = _snprintf(bkey, sizeof(bkey), "%s=\"", key);
+	WINPR_ASSERT(rc > 0);
+	WINPR_ASSERT(rc < sizeof(bkey));
+
+	char* p = strstr(tag, bkey);
+	if (!p)
+		return TRUE;
 
-	if (!strstr(str, "<E>"))
+	p += strlen(bkey);
+	char* q = strchr(p, '"');
+
+	if (!q)
 	{
-		WLog_ERR(TAG, "Failed to parse ASSISTANCE file: ConnectionString2 missing field <E>");
+		WLog_ERR(TAG, "Failed to parse ASSISTANCE file: ConnectionString2 invalid field '%s=%s'",
+		         key, p);
 		return FALSE;
 	}
 
-	if (!strstr(str, "<C>"))
+	if (p > q)
 	{
-		WLog_ERR(TAG, "Failed to parse ASSISTANCE file: ConnectionString2 missing field <C>");
+		WLog_ERR(TAG,
+		         "Failed to parse ASSISTANCE file: ConnectionString2 invalid field "
+		         "order for '%s'",
+		         key);
 		return FALSE;
 	}
+	const size_t length = q - p;
+	*opt = p;
+	*plength = length;
+
+	return TRUE;
+}
+
+static BOOL freerdp_assistance_parse_attr_str(char** opt, const char* key, const char* tag)
+{
+	const char* copt = NULL;
+	size_t size = 0;
+	if (!freerdp_assistance_parse_attr(&copt, &size, key, tag))
+		return FALSE;
+	return update_option(opt, copt, size);
+}
 
-	str = _strdup(file->ConnectionString2);
+static BOOL freerdp_assistance_parse_attr_bool(BOOL* opt, const char* key, const char* tag)
+{
+	const char* copt = NULL;
+	size_t size = 0;
 
-	if (!str)
-		goto out_fail;
+	WINPR_ASSERT(opt);
+	*opt = FALSE;
 
-	if (!(tag = strstr(str, "<A")))
+	if (!freerdp_assistance_parse_attr(&copt, &size, key, tag))
+		return FALSE;
+	if (size != 1)
+		return TRUE;
+
+	*opt = (copt[0] == '1');
+	return TRUE;
+}
+
+static BOOL freerdp_assistance_parse_attr_uint32(UINT32* opt, const char* key, const char* tag)
+{
+	const char* copt = NULL;
+	size_t size = 0;
+
+	WINPR_ASSERT(opt);
+	*opt = 0;
+
+	if (!freerdp_assistance_parse_attr(&copt, &size, key, tag))
+		return FALSE;
+
+	char buffer[64] = { 0 };
+	if (size >= sizeof(buffer))
 	{
-		WLog_ERR(TAG, "Failed to parse ASSISTANCE file: ConnectionString2 missing field <A");
-		goto out_fail;
+		WLog_WARN(TAG, "Invalid UINT32 string '%s' [%" PRIuz "]", copt, size);
+		return FALSE;
 	}
 
-	/* Parse Auth String Node (<A>) */
-	end = strstr(tag, "/>");
+	strncpy(buffer, copt, size);
+	errno = 0;
+	unsigned long val = strtoul(buffer, NULL, 0);
 
-	if (!end)
-		goto out_fail;
+	if ((errno != 0) || (val > UINT32_MAX))
+	{
+		WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Invalid value %s", buffer);
+		return FALSE;
+	}
 
-	*end = '\0';
-	p = strstr(tag, "KH=\"");
+	*opt = val;
 
-	if (p)
-	{
-		char* q;
-		size_t length;
-		p += sizeof("KH=\"") - 1;
-		q = strchr(p, '"');
+	return TRUE;
+}
 
-		if (!q)
-		{
-			WLog_ERR(TAG, "Failed to parse ASSISTANCE file: ConnectionString2 invalid field KH=%s",
-			         q);
-			goto out_fail;
-		}
+static char* freerdp_assistance_contains_element(char* input, size_t ilen, const char* key,
+                                                 size_t* plen, char** pdata, size_t* pdlen)
+{
+	WINPR_ASSERT(input);
+	WINPR_ASSERT(key);
+	WINPR_ASSERT(plen);
 
-		if (p > q)
-		{
-			WLog_ERR(
-			    TAG,
-			    "Failed to parse ASSISTANCE file: ConnectionString2 invalid field order for KH");
-			goto out_fail;
-		}
+	char bkey[128] = { 0 };
+	const int rc = _snprintf(bkey, sizeof(bkey), "<%s", key);
+	WINPR_ASSERT(rc > 0);
+	WINPR_ASSERT(rc < sizeof(bkey));
 
-		length = q - p;
-		free(file->RASpecificParams);
-		file->RASpecificParams = (char*)malloc(length + 1);
+	char* tag = strstr(input, bkey);
+	if (!tag || (tag > input + ilen))
+		return NULL;
 
-		if (!file->RASpecificParams)
-			goto out_fail;
+	char* data = tag + strnlen(bkey, sizeof(bkey));
+	char* start = strstr(tag, ">");
 
-		CopyMemory(file->RASpecificParams, p, length);
-		file->RASpecificParams[length] = '\0';
+	if (!start || (start > input + ilen))
+	{
+		WLog_ERR(TAG, "Failed to parse ASSISTANCE file: ConnectionString2 missing field %s", bkey);
+		return NULL;
 	}
 
-	p = strstr(tag, "ID=\"");
+	char* end = start;
+	char* dend = start - 1;
+	if (*dend != '/')
+	{
+		char ekey[128] = { 0 };
+		const int erc = _snprintf(ekey, sizeof(ekey), "</%s>", key);
+		WINPR_ASSERT(erc > 0);
+		WINPR_ASSERT(erc < sizeof(ekey));
+		const size_t offset = start - tag;
+		dend = end = strrstr(start, ilen - offset, ekey);
+		if (end)
+			end += strnlen(ekey, sizeof(ekey));
+	}
 
-	if (p)
+	if (!end)
 	{
-		char* q;
-		size_t length;
-		p += sizeof("ID=\"") - 1;
-		q = strchr(p, '"');
+		WLog_ERR(TAG,
+		         "Failed to parse ASSISTANCE file: ConnectionString2 missing end tag for field %s",
+		         key);
+		return NULL;
+	}
+	if (plen)
+		*plen = end - tag;
+
+	if (pdata)
+		*pdata = data;
+	if (pdlen)
+		*pdlen = dend - data;
+	return tag;
+}
 
-		if (!q)
-		{
-			WLog_ERR(TAG, "Failed to parse ASSISTANCE file: ConnectionString2 invalid field ID=%s",
-			         q);
-			goto out_fail;
-		}
+/**! \brief this function returns a XML element identified by \b key
+ * The input string will be manipulated, so that the element found is '\0' terminated.
+ *
+ * This function can not find multiple elements on the same level as the input string is changed!
+ */
+static BOOL freerdp_assistance_consume_input_and_get_element(char* input, const char* key,
+                                                             char** element, size_t* elen)
+{
+	WINPR_ASSERT(input);
+	WINPR_ASSERT(key);
+	WINPR_ASSERT(element);
+	WINPR_ASSERT(elen);
+
+	size_t len = 0;
+	size_t dlen = 0;
+	char* data = NULL;
+	char* tag = freerdp_assistance_contains_element(input, strlen(input), key, &len, &data, &dlen);
+	if (!tag)
+		return FALSE;
 
-		if (p > q)
-		{
-			WLog_ERR(TAG, "Failed to parse ASSISTANCE file: ConnectionString2 invalid field "
-			              "order for ID");
-			goto out_fail;
-		}
-		length = q - p;
-		free(file->RASessionId);
-		file->RASessionId = (char*)malloc(length + 1);
+	char* end = data + dlen;
+	*tag = '\0';
+	*end = '\0';
+	*element = data;
+	*elen = dlen + 1;
+	return TRUE;
+}
 
-		if (!file->RASessionId)
-			goto out_fail;
+static BOOL freerdp_assistance_get_element(char* input, size_t ilen, const char* key,
+                                           char** element, size_t* elen)
+{
+	WINPR_ASSERT(input);
+	WINPR_ASSERT(key);
+	WINPR_ASSERT(element);
+	WINPR_ASSERT(elen);
+
+	size_t len = 0;
+	size_t dlen = 0;
+	char* data = NULL;
+	char* tag = freerdp_assistance_contains_element(input, ilen, key, &len, &data, &dlen);
+	if (!tag)
+		return FALSE;
 
-		CopyMemory(file->RASessionId, p, length);
-		file->RASessionId[length] = '\0';
-	}
+	if (tag + len > input + ilen)
+		return FALSE;
 
-	*end = '/';
-	/* Parse <L  last address is used */
-	p = strstr(str, "<L P=\"");
+	char* end = tag + len;
+	*element = data;
+	*elen = end - data + 1;
+	return TRUE;
+}
 
-	while (p)
-	{
-		char* port;
-		char* q;
-		size_t length;
-		p += sizeof("<L P=\"") - 1;
-		q = strchr(p, '"');
+static BOOL freerdp_assistance_parse_all_elements_of(rdpAssistanceFile* file, char* data,
+                                                     size_t len, const char* key,
+                                                     BOOL (*fkt)(rdpAssistanceFile* file,
+                                                                 char* data, size_t len))
+{
+	char* val = NULL;
+	size_t vlen = 0;
 
-		if (!q)
+	while (freerdp_assistance_get_element(data, len, key, &val, &vlen))
+	{
+		data = val + vlen;
+		len = strnlen(data, len);
+		if (vlen > 0)
 		{
-			WLog_ERR(TAG,
-			         "Failed to parse ASSISTANCE file: ConnectionString2 invalid field <L P=%s", q);
-			goto out_fail;
+			val[vlen - 1] = '\0';
+
+			if (!fkt(file, val, vlen))
+				return FALSE;
 		}
+	}
 
-		q[0] = '\0';
-		q++;
-		port = p;
-		p = strstr(q, " N=\"");
+	return TRUE;
+}
 
-		if (!p)
-		{
-			WLog_ERR(TAG, "Failed to parse ASSISTANCE file: ConnectionString2 invalid field N=%s",
-			         p);
-			goto out_fail;
-		}
+static BOOL freerdp_assistance_parse_all_elements_of_l(rdpAssistanceFile* file, char* data,
+                                                       size_t len)
+{
+	UINT32 p = 0;
+	const char* n = NULL;
+	const char* u = NULL;
+	size_t nlen = 0;
+	size_t ulen = 0;
+	if (!freerdp_assistance_parse_attr_uint32(&p, "P", data))
+		return FALSE;
+	if (!freerdp_assistance_parse_attr(&n, &nlen, "N", data))
+		return FALSE;
+	if (!freerdp_assistance_parse_attr(&u, &ulen, "U", data))
+		return FALSE;
 
-		p += sizeof(" N=\"") - 1;
-		q = strchr(p, '"');
+	if (!ArrayList_Append(file->MachineAddresses, strndup(n, nlen)))
+		return FALSE;
+	if (!ArrayList_Append(file->MachineAddresses, strndup(u, ulen)))
+		return FALSE;
+	if (!ArrayList_Append(file->MachinePorts, (void*)(uintptr_t)p))
+		return FALSE;
+	return TRUE;
+}
 
-		if (!q)
-		{
-			WLog_ERR(TAG, "Failed to parse ASSISTANCE file: ConnectionString2 invalid field N=%s",
-			         q);
-			goto out_fail;
-		}
+static BOOL freerdp_assistance_parse_all_elements_of_t(rdpAssistanceFile* file, char* data,
+                                                       size_t len)
+{
+	UINT32 id = 0;
+	UINT32 sid = 0;
+	if (!freerdp_assistance_parse_attr_uint32(&id, "ID", data))
+		return FALSE;
+	if (!freerdp_assistance_parse_attr_uint32(&sid, "SID", data))
+		return FALSE;
+	WLog_DBG(TAG, "transport id=%" PRIu32 ", sid=%" PRIu32, id, sid);
+	return freerdp_assistance_parse_all_elements_of(file, data, len, "L",
+	                                                freerdp_assistance_parse_all_elements_of_l);
+}
 
-		q[0] = '\0';
-		q++;
-		length = strlen(p);
+static BOOL freerdp_assistance_parse_all_elements_of_c(rdpAssistanceFile* file, char* data,
+                                                       size_t len)
+{
+	return freerdp_assistance_parse_all_elements_of(file, data, len, "T",
+	                                                freerdp_assistance_parse_all_elements_of_t);
+}
 
-		if (length > 6)
-		{
-			if (!append_address(file, p, port))
-				goto out_fail;
-		}
+static BOOL freerdp_assistance_parse_find_elements_of_c(rdpAssistanceFile* file, char* data,
+                                                        size_t len)
+{
+	return freerdp_assistance_parse_all_elements_of(file, data, len, "C",
+	                                                freerdp_assistance_parse_all_elements_of_c);
+}
 
-		p = strstr(q, "<L P=\"");
-	}
+static BOOL freerdp_assistance_parse_connection_string2(rdpAssistanceFile* file)
+{
+	BOOL rc = FALSE;
+
+	WINPR_ASSERT(file);
+
+	if (!file->ConnectionString2)
+		return FALSE;
+
+	char* str = _strdup(file->ConnectionString2);
+	if (!str)
+		goto out_fail;
+
+	char* e = NULL;
+	size_t elen = 0;
+	if (!freerdp_assistance_consume_input_and_get_element(str, "E", &e, &elen))
+		goto out_fail;
+
+	if (!e || (elen == 0))
+		goto out_fail;
+
+	char* a = NULL;
+	size_t alen = 0;
+	if (!freerdp_assistance_get_element(e, elen, "A", &a, &alen))
+		goto out_fail;
+
+	if (!a || (alen == 0))
+		goto out_fail;
+
+	if (!freerdp_assistance_parse_find_elements_of_c(file, e, elen))
+		goto out_fail;
+
+	/* '\0' terminate the detected XML elements so
+	 * the parser can continue with terminated strings
+	 */
+	a[alen] = '\0';
+	if (!freerdp_assistance_parse_attr_str(&file->RASpecificParams, "KH", a))
+		goto out_fail;
+
+	if (!freerdp_assistance_parse_attr_str(&file->RASpecificParams2, "KH2", a))
+		goto out_fail;
+
+	if (!freerdp_assistance_parse_attr_str(&file->RASessionId, "ID", a))
+		goto out_fail;
 
 	rc = TRUE;
 out_fail:
@@ -613,83 +868,85 @@ fail:
 	return NULL;
 }
 
-static BOOL freerdp_assistance_decrypt2(rdpAssistanceFile* file, const char* password)
+static BOOL freerdp_assistance_decrypt2(rdpAssistanceFile* file)
 {
 	BOOL rc = FALSE;
 	int status = 0;
 	size_t cbPasswordW;
 	size_t cchOutW = 0;
 	WINPR_CIPHER_CTX* aesDec = NULL;
 	WCHAR* PasswordW = NULL;
 	BYTE* pbIn = NULL;
 	BYTE* pbOut = NULL;
 	size_t cbOut, cbIn, cbFinal;
 	BYTE DerivedKey[WINPR_AES_BLOCK_SIZE] = { 0 };
 	BYTE InitializationVector[WINPR_AES_BLOCK_SIZE] = { 0 };
 	BYTE PasswordHash[WINPR_SHA1_DIGEST_LENGTH] = { 0 };
 
-	if (!file || !password)
+	WINPR_ASSERT(file);
+
+	if (!file->password)
 		return FALSE;
 
-	PasswordW = ConvertUtf8ToWCharAlloc(password, &cbPasswordW);
+	PasswordW = ConvertUtf8ToWCharAlloc(file->password, &cbPasswordW);
 	if (!PasswordW)
 	{
 		WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Conversion from UCS2 to UTF8 failed");
 		return FALSE;
 	}
 
 	cbPasswordW = (cbPasswordW) * sizeof(WCHAR);
 
 	if (!winpr_Digest(WINPR_MD_SHA1, (BYTE*)PasswordW, cbPasswordW, PasswordHash,
 	                  sizeof(PasswordHash)))
 		goto fail;
 
 	if (!freerdp_assistance_crypt_derive_key_sha1(PasswordHash, sizeof(PasswordHash), DerivedKey,
 	                                              sizeof(DerivedKey)))
 		goto fail;
 
 	aesDec =
 	    winpr_Cipher_New(WINPR_CIPHER_AES_128_CBC, WINPR_DECRYPT, DerivedKey, InitializationVector);
 
 	if (!aesDec)
 		goto fail;
 
 	cbOut = cbFinal = 0;
 	cbIn = (size_t)file->EncryptedLHTicketLength;
 	pbIn = (BYTE*)file->EncryptedLHTicket;
 	pbOut = (BYTE*)calloc(1, cbIn + WINPR_AES_BLOCK_SIZE + 2);
 
 	if (!pbOut)
 		goto fail;
 
 	if (!winpr_Cipher_Update(aesDec, pbIn, cbIn, pbOut, &cbOut))
 		goto fail;
 
 	if (!winpr_Cipher_Final(aesDec, pbOut + cbOut, &cbFinal))
 	{
 		WLog_ERR(TAG, "winpr_Cipher_Final failure");
 		goto fail;
 	}
 
 	cbOut += cbFinal;
 	cbFinal = 0;
 
 	union
 	{
 		const WCHAR* wc;
 		const BYTE* b;
 	} cnv;
 
 	cnv.b = pbOut;
 	cchOutW = cbOut / sizeof(WCHAR);
-	file->ConnectionString2 = ConvertWCharNToUtf8Alloc(cnv.wc, cchOutW, NULL);
-	if (!file->ConnectionString2)
+
+	if (!update_connectionstring2_wchar(file, cnv.wc, cchOutW))
 	{
 		WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Conversion from UCS2 to UTF8 failed");
 		goto fail;
 	}
 
 	if (!freerdp_assistance_parse_connection_string2(file))
 		goto fail;
 
 	rc = TRUE;
@@ -726,476 +983,248 @@ char* freerdp_assistance_bin_to_hex_string(const void* raw, size_t size)
 	return winpr_BinToHexString(raw, size, FALSE);
 }
 
-int freerdp_assistance_parse_file_buffer(rdpAssistanceFile* file, const char* buffer, size_t size,
-                                         const char* password)
+static int freerdp_assistance_parse_uploadinfo(rdpAssistanceFile* file, char* uploadinfo,
+                                               size_t uploadinfosize)
 {
-	char* p;
-	char* q;
-	char* r;
-	char* amp;
-	int status;
-	size_t length;
-
-	free(file->password);
-	file->password = _strdup(password);
+	const char escalated[9] = "Escalated";
+	const size_t esclen = sizeof(escalated);
+	const char* typestr = NULL;
+	size_t typelen = 0;
 
-	p = strstr(buffer, "UPLOADINFO");
+	if (!uploadinfo || (uploadinfosize == 0))
+		return -1;
 
-	if (p)
+	if (strnlen(uploadinfo, uploadinfosize) == uploadinfosize)
 	{
-		p = strstr(p + sizeof("UPLOADINFO") - 1, "TYPE=\"");
-
-		if (!p)
-		{
-			WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Missing UPLOADINFO TYPE");
-			return -1;
-		}
+		WLog_WARN(TAG, "UPLOADINFOR string is not '\0' terminated");
+		return -1;
+	}
 
-		p = strstr(buffer, "UPLOADDATA");
+	if (!freerdp_assistance_parse_attr(&typestr, &typelen, "TYPE", uploadinfo))
+		return -1;
 
-		if (!p)
-		{
-			WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Missing UPLOADDATA");
-			return -1;
-		}
+	if ((typelen != esclen) || (strncmp(typestr, escalated, esclen) != 0))
+	{
+		WLog_ERR(TAG,
+		         "Failed to parse ASSISTANCE file: Missing or invalid UPLOADINFO TYPE '%s' [%" PRIuz
+		         "]",
+		         typestr, typelen);
+		return -1;
+	}
 
-		/* Parse USERNAME */
-		p = strstr(buffer, "USERNAME=\"");
+	char* uploaddata = NULL;
+	size_t uploaddatasize = 0;
+	if (!freerdp_assistance_consume_input_and_get_element(uploadinfo, "UPLOADDATA", &uploaddata,
+	                                                      &uploaddatasize))
+		return -1;
 
-		if (p)
-		{
-			p += sizeof("USERNAME=\"") - 1;
-			q = strchr(p, '"');
-
-			if (!q)
-			{
-				WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Invalid USERNAME=%s", p);
-				return -1;
-			}
-
-			if (p > q)
-			{
-				WLog_ERR(TAG, "Failed to parse ASSISTANCE file: invalid field "
-				              "order for USERNAME");
-				return -1;
-			}
-
-			length = q - p;
-			file->Username = (char*)malloc(length + 1);
-
-			if (!file->Username)
-				return -1;
-
-			CopyMemory(file->Username, p, length);
-			file->Username[length] = '\0';
-		}
+	/* Parse USERNAME */
+	if (!freerdp_assistance_parse_attr_str(&file->Username, "USERNAME", uploaddata))
+		return -1;
 
-		/* Parse LHTICKET */
-		p = strstr(buffer, "LHTICKET=\"");
+	/* Parse LHTICKET */
+	if (!freerdp_assistance_parse_attr_str(&file->LHTicket, "LHTICKET", uploaddata))
+		return -1;
 
-		if (p)
-		{
-			p += sizeof("LHTICKET=\"") - 1;
-			q = strchr(p, '"');
-
-			if (!q)
-			{
-				WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Invalid LHTICKET=%s", p);
-				return -1;
-			}
-
-			if (p > q)
-			{
-				WLog_ERR(TAG, "Failed to parse ASSISTANCE file: invalid field "
-				              "order for LHTICKET");
-				return -1;
-			}
-
-			length = q - p;
-			file->LHTicket = (char*)malloc(length + 1);
-
-			if (!file->LHTicket)
-				return -1;
-
-			CopyMemory(file->LHTicket, p, length);
-			file->LHTicket[length] = '\0';
-		}
+	/* Parse RCTICKET */
+	if (!freerdp_assistance_parse_attr_str(&file->RCTicket, "RCTICKET", uploaddata))
+		return -1;
 
-		/* Parse RCTICKET */
-		p = strstr(buffer, "RCTICKET=\"");
+	/* Parse RCTICKETENCRYPTED */
+	if (!freerdp_assistance_parse_attr_bool(&file->RCTicketEncrypted, "RCTICKETENCRYPTED",
+	                                        uploaddata))
+		return -1;
 
-		if (p)
-		{
-			p += sizeof("RCTICKET=\"") - 1;
-			q = strchr(p, '"');
-
-			if (!q)
-			{
-				WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Invalid RCTICKET=%s", p);
-				return -1;
-			}
-
-			if (p > q)
-			{
-				WLog_ERR(TAG, "Failed to parse ASSISTANCE file: invalid field "
-				              "order for RCTICKET");
-				return -1;
-			}
-
-			length = q - p;
-			file->RCTicket = (char*)malloc(length + 1);
-
-			if (!file->RCTicket)
-				return -1;
-
-			CopyMemory(file->RCTicket, p, length);
-			file->RCTicket[length] = '\0';
-		}
+	/* Parse PassStub */
+	if (!freerdp_assistance_parse_attr_str(&file->PassStub, "PassStub", uploaddata))
+		return -1;
 
-		/* Parse RCTICKETENCRYPTED */
-		p = strstr(buffer, "RCTICKETENCRYPTED=\"");
+	const char* amp = "&amp;";
+	char* passtub = strstr(file->PassStub, amp);
+	while (passtub)
+	{
+		const char* end = passtub + 5;
+		const size_t len = strlen(end);
+		memmove(&passtub[1], end, len + 1);
+		passtub = strstr(passtub, amp);
+	}
 
-		if (p)
-		{
-			p += sizeof("RCTICKETENCRYPTED=\"") - 1;
-			q = strchr(p, '"');
-
-			if (!q)
-			{
-				WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Invalid RCTICKETENCRYPTED=%s", p);
-				return -1;
-			}
-
-			if (p > q)
-			{
-				WLog_ERR(TAG, "Failed to parse ASSISTANCE file: invalid field "
-				              "order for RCTICKETENCRYPTED");
-				return -1;
-			}
-
-			length = q - p;
-
-			if ((length == 1) && (p[0] == '1'))
-				file->RCTicketEncrypted = TRUE;
-		}
+	/* Parse DtStart */
+	if (!freerdp_assistance_parse_attr_uint32(&file->DtStart, "DtStart", uploaddata))
+		return -1;
 
-		/* Parse PassStub */
-		p = strstr(buffer, "PassStub=\"");
+	/* Parse DtLength */
+	if (!freerdp_assistance_parse_attr_uint32(&file->DtLength, "DtLength", uploaddata))
+		return -1;
 
-		if (p)
-		{
-			p += sizeof("PassStub=\"") - 1;
-
-			// needs to be unescaped (&amp; => &)
-			amp = strstr(p, "&amp;");
-
-			q = strchr(p, '"');
-
-			if (!q)
-			{
-				WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Invalid PassStub=%s", p);
-				return -1;
-			}
-
-			if (p > q)
-			{
-				WLog_ERR(TAG, "Failed to parse ASSISTANCE file: invalid field "
-				              "order for PassStub");
-				return -1;
-			}
-
-			if (amp)
-			{
-				length = q - p - 4;
-			}
-			else
-			{
-				length = q - p;
-			}
-
-			file->PassStub = (char*)malloc(length + 1);
-
-			if (!file->PassStub)
-				return -1;
-
-			if (amp)
-			{
-				// just skip over "amp;" leaving "&"
-				CopyMemory(file->PassStub, p, amp - p + 1);
-				CopyMemory(file->PassStub + (amp - p + 1), amp + 5, q - amp + 5);
-			}
-			else
-			{
-				CopyMemory(file->PassStub, p, length);
-			}
-
-			file->PassStub[length] = '\0';
-		}
+	/* Parse L (LowSpeed) */
+	if (!freerdp_assistance_parse_attr_bool(&file->LowSpeed, "L", uploaddata))
+		return -1;
 
-		/* Parse DtStart */
-		p = strstr(buffer, "DtStart=\"");
+	file->Type = (file->LHTicket) ? 2 : 1;
+	int status = 0;
 
-		if (p)
+	switch (file->Type)
+	{
+		case 2:
 		{
-			p += sizeof("DtStart=\"") - 1;
-			q = strchr(p, '"');
-
-			if (!q)
-			{
-				WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Invalid DtStart=%s", p);
-				return -1;
-			}
-
-			if (p > q)
-			{
-				WLog_ERR(TAG, "Failed to parse ASSISTANCE file: invalid field "
-				              "order for DtStart");
-				return -1;
-			}
-
-			length = q - p;
-			r = (char*)malloc(length + 1);
-
-			if (!r)
-				return -1;
-
-			CopyMemory(r, p, length);
-			r[length] = '\0';
-			errno = 0;
-			{
-				unsigned long val = strtoul(r, NULL, 0);
-
-				if ((errno != 0) || (val > UINT32_MAX))
-				{
-					WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Invalid DtStart value %s", r);
-					free(r);
-					return -1;
-				}
-
-				free(r);
-				file->DtStart = val;
-			}
-		}
-
-		/* Parse DtLength */
-		p = strstr(buffer, "DtLength=\"");
+			file->EncryptedLHTicket = freerdp_assistance_hex_string_to_bin(
+			    file->LHTicket, &file->EncryptedLHTicketLength);
 
-		if (p)
-		{
-			p += sizeof("DtLength=\"") - 1;
-			q = strchr(p, '"');
-
-			if (!q)
-			{
-				WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Invalid DtLength=%s", p);
-				return -1;
-			}
-
-			if (p > q)
-			{
-				WLog_ERR(TAG, "Failed to parse ASSISTANCE file: invalid field "
-				              "order for DtLength");
-				return -1;
-			}
-
-			length = q - p;
-			r = (char*)malloc(length + 1);
-
-			if (!r)
-				return -1;
-
-			CopyMemory(r, p, length);
-			r[length] = '\0';
-			errno = 0;
-			{
-				unsigned long val = strtoul(r, NULL, 0);
-
-				if ((errno != 0) || (val > UINT32_MAX))
-				{
-					WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Invalid DtLength value %s", r);
-					free(r);
-					return -1;
-				}
-
-				free(r);
-				file->DtLength = val;
-			}
+			if (!freerdp_assistance_decrypt2(file))
+				status = -1;
 		}
+		break;
 
-		/* Parse L (LowSpeed) */
-		p = strstr(buffer, " L=\"");
-
-		if (p)
+		case 1:
 		{
-			p += sizeof(" L=\"") - 1;
-			q = strchr(p, '"');
-
-			if (!q)
-			{
-				WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Invalid L=%s", p);
-				return -1;
-			}
-
-			if (p > q)
-			{
-				WLog_ERR(TAG, "Failed to parse ASSISTANCE file: invalid field "
-				              "order for L");
-				return -1;
-			}
-
-			length = q - p;
-
-			if ((length == 1) && (p[0] == '1'))
-				file->LowSpeed = TRUE;
+			if (!freerdp_assistance_parse_connection_string1(file))
+				status = -1;
 		}
+		break;
 
-		file->Type = (file->LHTicket) ? 2 : 1;
-		status = 0;
-
-		switch (file->Type)
-		{
-			case 2:
-			{
-				file->EncryptedLHTicket = freerdp_assistance_hex_string_to_bin(
-				    file->LHTicket, &file->EncryptedLHTicketLength);
-
-				if (!freerdp_assistance_decrypt2(file, password))
-					status = -1;
-			}
-			break;
+		default:
+			return -1;
+	}
 
-			case 1:
-			{
-				if (!freerdp_assistance_parse_connection_string1(file))
-					status = -1;
-			}
-			break;
+	if (status < 0)
+	{
+		WLog_ERR(TAG, "freerdp_assistance_parse_connection_string1 failure: %d", status);
+		return -1;
+	}
 
-			default:
-				return -1;
-		}
+	file->EncryptedPassStub = freerdp_assistance_encrypt_pass_stub(file->password, file->PassStub,
+	                                                               &file->EncryptedPassStubLength);
 
-		if (status < 0)
-		{
-			WLog_ERR(TAG, "freerdp_assistance_parse_connection_string1 failure: %d", status);
-			return -1;
-		}
+	if (!file->EncryptedPassStub)
+		return -1;
 
-		file->EncryptedPassStub = freerdp_assistance_encrypt_pass_stub(
-		    password, file->PassStub, &file->EncryptedPassStubLength);
+	return 1;
+}
 
-		if (!file->EncryptedPassStub)
-			return -1;
+static int freerdp_assistance_parse_file_buffer_int(rdpAssistanceFile* file, char* buffer,
+                                                    size_t size, const char* password)
+{
+	WINPR_ASSERT(file);
+	WINPR_ASSERT(buffer);
+	WINPR_ASSERT(size > 0);
 
-		return 1;
-	}
+	if (!update_password(file, password))
+		return -1;
 
-	p = strstr(buffer, "<E>");
+	char* uploadinfo = NULL;
+	size_t uploadinfosize = 0;
+	if (freerdp_assistance_consume_input_and_get_element(buffer, "UPLOADINFO", &uploadinfo,
+	                                                     &uploadinfosize))
+		return freerdp_assistance_parse_uploadinfo(file, uploadinfo, uploadinfosize);
 
-	if (p)
+	size_t elen = 0;
+	const char* estr = freerdp_assistance_contains_element(buffer, size, "E", &elen, NULL, NULL);
+	if (!estr || (elen == 0))
 	{
-		q = strstr(buffer, "</E>");
-
-		if (!q)
-		{
-			WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Missing </E> tag");
-			return -1;
-		}
+		WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Neither UPLOADINFO nor <E> found");
+		return -1;
+	}
+	if (!update_connectionstring2(file, estr, elen))
+		return -1;
 
-		if (p > q)
-		{
-			WLog_ERR(TAG, "Failed to parse ASSISTANCE file: invalid field order for <E>");
-			return -1;
-		}
+	if (!freerdp_assistance_parse_connection_string2(file))
+		return -1;
 
-		q += sizeof("</E>") - 1;
-		length = q - p;
-		file->ConnectionString2 = (char*)malloc(length + 1);
+	return 1;
+}
 
-		if (!file->ConnectionString2)
-			return -1;
+int freerdp_assistance_parse_file_buffer(rdpAssistanceFile* file, const char* cbuffer, size_t size,
+                                         const char* password)
+{
+	WINPR_ASSERT(file);
+	if (!password)
+	{
+		WLog_WARN(TAG, "empty password supplied");
+	}
 
-		CopyMemory(file->ConnectionString2, p, length);
-		file->ConnectionString2[length] = '\0';
+	if (!cbuffer || (size == 0))
+	{
+		WLog_WARN(TAG, "no data supplied [%p, %" PRIuz "]", cbuffer, size);
+		return -1;
+	}
 
-		if (!freerdp_assistance_parse_connection_string2(file))
-			return -1;
+	char* abuffer = strndup(cbuffer, size);
+	const size_t len = strnlen(cbuffer, size);
+	if (len == size)
+		WLog_WARN(TAG, "Input data not '\0' terminated");
 
-		return 1;
-	}
+	if (!abuffer)
+		return -1;
 
-	WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Neither UPLOADINFO nor <E> found");
-	return -1;
+	const int rc = freerdp_assistance_parse_file_buffer_int(file, abuffer, len + 1, password);
+	free(abuffer);
+	return rc;
 }
 
 int freerdp_assistance_parse_file(rdpAssistanceFile* file, const char* name, const char* password)
 {
 	int status;
 	BYTE* buffer;
 	FILE* fp = NULL;
 	size_t readSize;
 	union
 	{
 		INT64 i64;
 		size_t s;
 	} fileSize;
 
-	if (!name)
-	{
-		WLog_ERR(TAG, "ASSISTANCE file %s invalid name", name);
+	if (!update_name(file, name))
 		return -1;
-	}
 
-	free(file->filename);
-	file->filename = _strdup(name);
 	fp = winpr_fopen(name, "r");
 
 	if (!fp)
 	{
 		WLog_ERR(TAG, "Failed to open ASSISTANCE file %s ", name);
 		return -1;
 	}
 
 	_fseeki64(fp, 0, SEEK_END);
 	fileSize.i64 = _ftelli64(fp);
 	_fseeki64(fp, 0, SEEK_SET);
 
 	if (fileSize.i64 < 1)
 	{
 		WLog_ERR(TAG, "Failed to read ASSISTANCE file %s ", name);
 		fclose(fp);
 		return -1;
 	}
 
 	buffer = (BYTE*)malloc(fileSize.s + 2);
 
 	if (!buffer)
 	{
 		fclose(fp);
 		return -1;
 	}
 
 	readSize = fread(buffer, fileSize.s, 1, fp);
 
 	if (!readSize)
 	{
 		if (!ferror(fp))
 			readSize = fileSize.s;
 	}
 
 	fclose(fp);
 
 	if (readSize < 1)
 	{
 		WLog_ERR(TAG, "Failed to read ASSISTANCE file %s ", name);
 		free(buffer);
 		buffer = NULL;
 		return -1;
 	}
 
 	buffer[fileSize.s] = '\0';
 	buffer[fileSize.s + 1] = '\0';
 	status = freerdp_assistance_parse_file_buffer(file, (char*)buffer, fileSize.s, password);
 	free(buffer);
 	return status;
 }
@@ -1203,130 +1232,172 @@ int freerdp_assistance_parse_file(rdpAssistanceFile* file, const char* name, con
 BOOL freerdp_assistance_populate_settings_from_assistance_file(rdpAssistanceFile* file,
                                                                rdpSettings* settings)
 {
-	UINT32 i;
-
 	if (!freerdp_settings_set_bool(settings, FreeRDP_RemoteAssistanceMode, TRUE))
 		return FALSE;
 
 	if (!file->RASessionId || !file->MachineAddresses)
 		return FALSE;
 
 	if (!freerdp_settings_set_string(settings, FreeRDP_RemoteAssistanceSessionId,
 	                                 file->RASessionId))
 		return FALSE;
 
 	if (file->RCTicket)
 	{
 		if (!freerdp_settings_set_string(settings, FreeRDP_RemoteAssistanceRCTicket,
 		                                 file->RCTicket))
 			return FALSE;
 	}
 	else
 	{
 		if (!freerdp_settings_set_string(settings, FreeRDP_RemoteAssistanceRCTicket,
 		                                 file->ConnectionString2))
 			return FALSE;
 	}
 
 	if (file->PassStub)
 	{
 		if (!freerdp_settings_set_string(settings, FreeRDP_RemoteAssistancePassStub,
 		                                 file->PassStub))
 			return FALSE;
 	}
 
-	if (!freerdp_settings_set_string(settings, FreeRDP_ServerHostname, file->MachineAddresses[0]))
+	if (ArrayList_Count(file->MachineAddresses) < 1)
+		return FALSE;
+
+	const char* addr = ArrayList_GetItem(file->MachineAddresses, 0);
+	if (!freerdp_settings_set_string(settings, FreeRDP_ServerHostname, addr))
 		return FALSE;
 
 	if (!freerdp_settings_set_string(settings, FreeRDP_AssistanceFile, file->filename))
 		return FALSE;
 
 	if (!freerdp_settings_set_string(settings, FreeRDP_RemoteAssistancePassword, file->password))
 		return FALSE;
 
 	if (file->Username)
 	{
 		if (!freerdp_settings_set_string(settings, FreeRDP_Username, file->Username))
 			return FALSE;
 	}
 
 	if (!freerdp_settings_set_bool(settings, FreeRDP_RemoteAssistanceMode, TRUE))
 		return FALSE;
 
-	if (!freerdp_settings_set_uint32(settings, FreeRDP_ServerPort, file->MachinePorts[0]))
+	size_t ports = ArrayList_Count(file->MachinePorts);
+	if (ports < 1)
+		return FALSE;
+
+	const UINT32 port = (UINT32)ArrayList_GetItem(file->MachinePorts, 0);
+	if (!freerdp_settings_set_uint32(settings, FreeRDP_ServerPort, port))
 		return FALSE;
 
-	if (!freerdp_settings_set_pointer_len(settings, FreeRDP_TargetNetAddresses, NULL,
-	                                      file->MachineCount))
+	if (!freerdp_settings_set_pointer_len(settings, FreeRDP_TargetNetAddresses, NULL, ports))
 		return FALSE;
 	if (!freerdp_settings_set_pointer_len(settings, FreeRDP_TargetNetPorts, file->MachinePorts,
-	                                      file->MachineCount))
+	                                      ports))
 		return FALSE;
 
-	for (i = 0; i < file->MachineCount; i++)
+	for (size_t i = 0; i < ArrayList_Count(file->MachineAddresses); i++)
 	{
-		if (!freerdp_settings_set_pointer_array(settings, FreeRDP_TargetNetAddresses, i,
-		                                        file->MachineAddresses[i]))
+		const char* addr = ArrayList_GetItem(file->MachineAddresses, i);
+		if (!freerdp_settings_set_pointer_array(settings, FreeRDP_TargetNetAddresses, i, addr))
 			return FALSE;
 	}
 
 	return TRUE;
 }
 
+static BOOL setup_string(wArrayList* list)
+{
+	WINPR_ASSERT(list);
+
+	wObject* obj = ArrayList_Object(list);
+	if (!obj)
+		return FALSE;
+	obj->fnObjectFree = free;
+	// obj->fnObjectNew = _strdup;
+	return TRUE;
+}
+
 rdpAssistanceFile* freerdp_assistance_file_new(void)
 {
 	winpr_InitializeSSL(WINPR_SSL_INIT_DEFAULT);
-	return (rdpAssistanceFile*)calloc(1, sizeof(rdpAssistanceFile));
+	rdpAssistanceFile* file = calloc(1, sizeof(rdpAssistanceFile));
+	if (!file)
+		return NULL;
+
+	file->MachineAddresses = ArrayList_New(FALSE);
+	file->MachinePorts = ArrayList_New(FALSE);
+	file->MachineUris = ArrayList_New(FALSE);
+
+	if (!file->MachineAddresses || !file->MachinePorts || !file->MachineUris)
+		goto fail;
+
+	if (!setup_string(file->MachineAddresses) || !setup_string(file->MachineUris))
+		goto fail;
+
+	return file;
+
+fail:
+	freerdp_assistance_file_free(file);
+	return NULL;
 }
 
 void freerdp_assistance_file_free(rdpAssistanceFile* file)
 {
-	UINT32 i;
-
 	if (!file)
 		return;
 
+	update_password(file, NULL);
+	update_connectionstring2(file, NULL, 0);
 	free(file->filename);
-	free(file->password);
 	free(file->Username);
 	free(file->LHTicket);
 	free(file->RCTicket);
 	free(file->PassStub);
 	free(file->ConnectionString1);
-	free(file->ConnectionString2);
 	free(file->EncryptedLHTicket);
 	free(file->RASessionId);
 	free(file->RASpecificParams);
+	free(file->RASpecificParams2);
 	free(file->EncryptedPassStub);
 
-	for (i = 0; i < file->MachineCount; i++)
-	{
-		free(file->MachineAddresses[i]);
-	}
-
-	free(file->MachineAddresses);
-	free(file->MachinePorts);
+	ArrayList_Free(file->MachineAddresses);
+	ArrayList_Free(file->MachinePorts);
+	ArrayList_Free(file->MachineUris);
 	free(file);
 }
 
 void freerdp_assistance_print_file(rdpAssistanceFile* file, wLog* log, DWORD level)
 {
-	size_t x;
+	WINPR_ASSERT(file);
+
 	WLog_Print(log, level, "Username: %s", file->Username);
 	WLog_Print(log, level, "LHTicket: %s", file->LHTicket);
 	WLog_Print(log, level, "RCTicket: %s", file->RCTicket);
 	WLog_Print(log, level, "RCTicketEncrypted: %" PRId32, file->RCTicketEncrypted);
 	WLog_Print(log, level, "PassStub: %s", file->PassStub);
 	WLog_Print(log, level, "DtStart: %" PRIu32, file->DtStart);
 	WLog_Print(log, level, "DtLength: %" PRIu32, file->DtLength);
 	WLog_Print(log, level, "LowSpeed: %" PRId32, file->LowSpeed);
 	WLog_Print(log, level, "RASessionId: %s", file->RASessionId);
 	WLog_Print(log, level, "RASpecificParams: %s", file->RASpecificParams);
+	WLog_Print(log, level, "RASpecificParams2: %s", file->RASpecificParams2);
 
-	for (x = 0; x < file->MachineCount; x++)
+	for (size_t x = 0; x < ArrayList_Count(file->MachineAddresses); x++)
 	{
-		WLog_Print(log, level, "MachineAddress [%" PRIdz ": %s", x, file->MachineAddresses[x]);
-		WLog_Print(log, level, "MachinePort    [%" PRIdz ": %" PRIu32, x, file->MachinePorts[x]);
+		UINT32 port = 0;
+		const char* uri = NULL;
+		const char* addr = ArrayList_GetItem(file->MachineAddresses, x);
+		if (x < ArrayList_Count(file->MachinePorts))
+			port = (UINT32)ArrayList_GetItem(file->MachinePorts, x);
+		if (x < ArrayList_Count(file->MachineUris))
+			uri = ArrayList_GetItem(file->MachineUris, x);
+
+		WLog_Print(log, level, "MachineAddress [%" PRIdz ": %s", x, addr);
+		WLog_Print(log, level, "MachinePort    [%" PRIdz ": %" PRIu32, x, port);
+		WLog_Print(log, level, "MachineURI     [%" PRIdz ": %s", x, uri);
 	}
 }
 
@@ -1344,12 +1415,16 @@ BOOL freerdp_assistance_get_encrypted_pass_stub(rdpAssistanceFile* file, const c
 int freerdp_assistance_set_connection_string2(rdpAssistanceFile* file, const char* string,
                                               const char* password)
 {
 	if (!file || !string || !password)
 		return -1;
 
-	free(file->ConnectionString2);
-	free(file->password);
-	file->ConnectionString2 = _strdup(string);
-	file->password = _strdup(password);
+	char* str = _strdup(string);
+	if (!str)
+		return -1;
+
+	if (!update_connectionstring2_nocopy(file, str))
+		return -1;
+	if (!update_password(file, password))
+		return -1;
 	return freerdp_assistance_parse_connection_string2(file);
 }
diff --git a/libfreerdp/common/test/TestCommonAssistance.c b/libfreerdp/common/test/TestCommonAssistance.c
index 51d8390ce..aa5d87876 100644
--- a/libfreerdp/common/test/TestCommonAssistance.c
+++ b/libfreerdp/common/test/TestCommonAssistance.c
@@ -37,49 +37,61 @@ static const char TEST_MSRC_INCIDENT_PASSWORD_TYPE2[] = "48BJQ853X3B4";
 static const char TEST_MSRC_INCIDENT_FILE_TYPE2[] =
     "<?xml version=\"1.0\"?>"
     "<UPLOADINFO TYPE=\"Escalated\">"
     "<UPLOADDATA USERNAME=\"awake\" "
     "LHTICKET=\""
     "20FCC407AA53E95F8505AB56D485D26835064B03AF86CDA326248FD304626AD4"
     "DBDBDFFE0C473228EFFF7A1E6CEB445BBEC429294BB6616BBB600854438DDFB5"
     "82FC377CF65A2060EB3221647643C9B29BF5EC320856180B34D1BE9827A528C7"
     "E8F0DCD53C8D38F974160FEE317458FAC9DBDBA7B972D21DF3BC5B1AF0E01878"
     "65F07A3B915618C03E6EAF843FC1185770A1208C29C836DBCA5A040CB276D3C4"
     "1DDE2FA8CA9627E5E74FA750A92C0E01AD6C3D1000A5B1479DEB899BF5BCD402"
     "CE3BB3BF104CE0286C3F985AA711943C88C5EEEEE86F35B63F68883A90ADBCFD"
     "CBBAE3EAB993EFD9148E1A21D092CE9498695943946236D65D20B4A38D724C61"
     "72319E38E19C04E98EBC03F56A4A190E971F8EAEBFE6B415A3A2D8F35F7BF785"
     "26B9BFAAB48D11BDD6C905EFE503D2265678E1EAD2F2F124E570667F04103180"
     "2F63587276C14E6A5AB436CE234F722CE7C9B5D244508F14C012E84A49FE6992"
     "3F30320ABB3641F1EFA66205F3EA709E7E1C3E6874BB9642486FB96D2730CDF4"
     "514AA738167F00FC13B2978AED1D6678413FDF62008B03DD729E36173BE02742"
     "B69CAD44938512D0F56335394759338AF6ADBCF39CE829116D97435085D05BB5"
     "9320A134698050DCDBE01305A6B4712FD6BD48958BD2DC497498FF35CAECC9A8"
     "2C97FD1A5B5EC4BAF5FFB75A1471B765C465B35A7C950019066BB219B391C6E9"
     "8AE8FD2038E774F36F226D9FB9A38BCC313785612165D1EF69D19E2B9CF6E0F7"
     "FE1ECCF00AB81F9E8B626363CA82FAC719A3B7D243325C9D6042B2488EC95B80"
     "A31273FF9B72FBBB86F946E6D3DF8816BE4533F0B547C8BC028309EA9784C1E6\" "
     "RCTICKET=\"65538,1,192.168.1.200:49230;169.254.6.170:49231,*,"
     "+ULZ6ifjoCa6cGPMLQiGHRPwkg6VyJqGwxMnO6GcelwUh9a6/FBq3It5ADSndmLL,"
     "*,*,BNRjdu97DyczQSRuMRrDWoue+HA=\" "
     "PassStub=\"WB^6HsrIaFmEpi\" "
     "RCTICKETENCRYPTED=\"1\" "
     "DtStart=\"1403972263\" "
     "DtLength=\"14400\" "
     "L=\"0\"/>"
     "</UPLOADINFO>";
 
 /**
  * Decrypted Connection String 2:
  *
  * <E>
  * <A KH="BNRjdu97DyczQSRuMRrDWoue+HA="
  * ID="+ULZ6ifjoCa6cGPMLQiGHRPwkg6VyJqGwxMnO6GcelwUh9a6/FBq3It5ADSndmLL"/> <C> <T ID="1" SID="0"> <L
  * P="49228" N="fe80::1032:53d9:5a01:909b%3"/> <L P="49229" N="fe80::3d8f:9b2d:6b4e:6aa%6"/> <L
  * P="49230" N="192.168.1.200"/> <L P="49231" N="169.254.6.170"/>
  * </T>
  * </C>
  * </E>
  */
+static const char connectionstr2[] =
+    "<E>\n"
+    "<A KH=\"YiKwWUY8Ioq5NB3wAQHSbs5kwrM=\"\n"
+    "KH2=\"sha256:wKSAkAV3sBfa9WpuRFJcP9q1twJc6wOBuoJ9tsyXwpk=\"\n"
+    "ID=\"8rYm30RBW8/4dAWoUsWbFCF5jno/7jr5tNpHQc2goLbw4uuBBJvLsU02YYLlBMg5\"/>\n"
+    "<C>\n"
+    "<T ID=\"1\" SID=\"1440550163\">\n"
+    "<L P=\"49749\" N=\"2001:4898:1a:5:79e2:3356:9b22:3470\"/>\n"
+    "<L P=\"49751\" N=\"172.31.250.64\"/>\n"
+    "</T>\n"
+    "</C>\n"
+    "</E>";
 
 static BOOL test_msrsc_incident_file_type1(wLog* log)
 {
@@ -128,36 +140,43 @@ fail:
 static BOOL test_msrsc_incident_file_type2(wLog* log)
 {
 	int status = -1;
 	char* pass = NULL;
 	char* expertBlob = NULL;
 	const char* EncryptedPassStub = NULL;
 	size_t EncryptedPassStubLength;
 	rdpAssistanceFile* file = freerdp_assistance_file_new();
 
 	if (!file)
 		return -1;
 
+	status = freerdp_assistance_parse_file_buffer(file, connectionstr2, sizeof(connectionstr2),
+	                                              TEST_MSRC_INCIDENT_PASSWORD_TYPE2);
+	printf("freerdp_assistance_parse_file_buffer: %d\n", status);
+
+	if (status < 0)
+		goto fail;
+
 	status = freerdp_assistance_parse_file_buffer(file, TEST_MSRC_INCIDENT_FILE_TYPE2,
 	                                              sizeof(TEST_MSRC_INCIDENT_FILE_TYPE2),
 	                                              TEST_MSRC_INCIDENT_PASSWORD_TYPE2);
 	printf("freerdp_assistance_parse_file_buffer: %d\n", status);
 
 	if (status < 0)
 		goto fail;
 
 	freerdp_assistance_print_file(file, log, WLOG_INFO);
 	status = freerdp_assistance_get_encrypted_pass_stub(file, &EncryptedPassStub,
 	                                                    &EncryptedPassStubLength);
 	pass = freerdp_assistance_bin_to_hex_string(EncryptedPassStub, EncryptedPassStubLength);
 
 	if (!pass)
 		goto fail;
 
 	WLog_Print(log, WLOG_INFO, "freerdp_assistance_decrypt: %d %s [%" PRIdz "]", status, pass,
 	           EncryptedPassStubLength);
 
 	if (status < 0)
 		goto fail;
 
 	expertBlob = freerdp_assistance_construct_expert_blob("Edgar Olougouna", pass);
 	WLog_Print(log, WLOG_INFO, "expertBlob='%s'", expertBlob);
