commit 28727baf58aa7c8983769aff1ceecb3121a26ee6
Author: Mallikarjun Kamble <mallikarjun.kamble@ittiam.com>
Date:   Tue Jan 9 18:36:07 2024 +0530

    svcdec: oss-fuzz bug fixes
    
    ID#
    65031
    65035
    65057
    65059
    65060
    65132
    65172
    65482

diff --git a/decoder/svc/isvcd_api.c b/decoder/svc/isvcd_api.c
index 38d876d..c789785 100644
--- a/decoder/svc/isvcd_api.c
+++ b/decoder/svc/isvcd_api.c
@@ -4355,151 +4355,169 @@ WORD32 isvcd_refine_dep_list(void *pv_out_vcl_ctxt, dec_seq_params_t *ps_sps,
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : isvcd_dec_non_vcl                                        */
 /*                                                                           */
 /*  Description   : this function decodes the NON VCL NAL units              */
 /*                                                                           */
 /*                                                                           */
 /*  Inputs        : pv_out_non_vcl : pointer to the structure containing     */
 /*                                  NON VCL NAL units                        */
 /*                  ps_seq_params : pointer to array of SPS structures       */
 /*                  ps_pic_params : pointer to array of PPS structures       */
 /*                  ps_sei_ctxt : pointer to array of SEI structures         */
 /*  Globals       : none                                                     */
 /*  Processing    : it decodes the units unitl all the units are             */
 /*                  decoded                                                  */
 /*  Outputs       : decoded parameters in appropriate structures             */
 /*  Returns       : Success or Faliure                                       */
 /*                                                                           */
 /*  Issues        :                                                          */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         06 09 2021   vijayakumar          creation                        */
 /*                                                                           */
 /*****************************************************************************/
 WORD32 isvcd_dec_non_vcl(void *pv_out_non_vcl, void *pv_seq_params, void *pv_pic_params,
                          svc_dec_ctxt_t *ps_svcd_ctxt)
 {
     /* local varibles */
     non_vcl_nal_t *ps_non_vcl;
     WORD32 i4_unit_indx;
     non_vcl_buf_hdr_t *ps_non_vcl_buf;
     WORD32 i_status = OK;
     dec_struct_t *ps_dec;
     svc_dec_lyr_struct_t *ps_svc_lyr_dec;
     dec_bit_stream_t *ps_bitstrm;
 
     if((NULL == pv_out_non_vcl) || (NULL == pv_seq_params) || (NULL == pv_pic_params))
     {
         return NOT_OK;
     }
     UNUSED(pv_seq_params);
     UNUSED(pv_pic_params);
 
     /* currently SEI decoding is not supported */
     /* derive the local variables */
     ps_non_vcl = (non_vcl_nal_t *) pv_out_non_vcl;
     ps_non_vcl_buf = ps_non_vcl->ps_first_non_vcl_nal;
     if(NULL == ps_non_vcl_buf) return (NOT_OK);
 
     /* loop until all NON VCL NAL are decoded */
     for(i4_unit_indx = 0; i4_unit_indx < ps_non_vcl->i4_num_non_vcl_nals; i4_unit_indx++)
     {
         UWORD32 u4_nal_unit_type;
         ps_svc_lyr_dec = ps_svcd_ctxt->ps_svc_dec_lyr;
         ps_dec = &ps_svc_lyr_dec->s_dec;
         if(NULL == ps_non_vcl_buf) return (NOT_OK);
         /* get the current NAL unit type */
         u4_nal_unit_type = (UWORD32) ps_non_vcl_buf->i4_nal_unit_type;
         if(u4_nal_unit_type > MAX_SVC_NAL_UNIT_TYPE) return (NOT_OK);
         ps_dec->u1_nal_unit_type = u4_nal_unit_type;
 
         ps_dec->ps_bitstrm->pu4_buffer =
             (UWORD32 *) ((UWORD8 *) ps_non_vcl_buf + ps_non_vcl_buf->i4_buf_offset);
         ps_dec->ps_bitstrm->u4_ofst = 0;
         ps_dec->ps_bitstrm->u4_max_ofst = isvcd_nal_rbsp_to_sodb(
             (UWORD8 *) ps_dec->ps_bitstrm->pu4_buffer, ps_non_vcl_buf->i4_buf_size, 0);
         if(ps_dec->ps_bitstrm->u4_max_ofst <= 0) return (NOT_OK);
 
         ps_bitstrm = ps_dec->ps_bitstrm;
 
         /* call the processing module based on nal unit type */
         switch(u4_nal_unit_type)
         {
             case SEQ_PARAM_NAL:
 
                 i_status = isvcd_parse_sps(ps_svc_lyr_dec, ps_bitstrm);
 
                 if(!i_status)
                 {
                     ps_dec->i4_header_decoded |= 0x1;
                     ps_svcd_ctxt->u4_num_sps_ctr++;
+
+                    if(ps_svcd_ctxt->pic_width < ps_svc_lyr_dec->pic_width)
+                    {
+                        ps_svcd_ctxt->pic_width = ps_svc_lyr_dec->pic_width;
+                    }
+                    if(ps_svcd_ctxt->pic_height < ps_svc_lyr_dec->pic_height)
+                    {
+                        ps_svcd_ctxt->pic_height = ps_svc_lyr_dec->pic_height;
+                    }
                 }
 
                 if(i_status) return i_status;
 
                 break;
             case SUBSET_SPS_NAL:
 
                 i_status = isvcd_parse_subset_sps(ps_svc_lyr_dec, ps_bitstrm);
 
                 if(!i_status)
                 {
                     ps_svcd_ctxt->u4_num_sps_ctr++;
                     ps_dec->i4_header_decoded |= 0x1;
+
+                    if(ps_svcd_ctxt->pic_width < ps_svc_lyr_dec->pic_width)
+                    {
+                        ps_svcd_ctxt->pic_width = ps_svc_lyr_dec->pic_width;
+                    }
+                    if(ps_svcd_ctxt->pic_height < ps_svc_lyr_dec->pic_height)
+                    {
+                        ps_svcd_ctxt->pic_height = ps_svc_lyr_dec->pic_height;
+                    }
                 }
                 if(i_status) return i_status;
 
                 break;
 
             case PIC_PARAM_NAL:
 
                 i_status = isvcd_parse_pps(ps_svc_lyr_dec, ps_bitstrm);
                 if(i_status == ERROR_INV_SPS_PPS_T) return i_status;
                 if(!i_status)
                 {
                     ps_dec->i4_header_decoded |= 0x2;
                     ps_svcd_ctxt->u4_num_pps_ctr++;
                 }
                 break;
             case SEI_NAL:
             {
                 i_status = ih264d_parse_sei_message(ps_dec, ps_bitstrm);
                 ih264d_parse_sei(ps_dec, ps_bitstrm);
             }
             break;
             default:
                 /* no other NON VCL UNIT is supported */
                 break;
         }
 
         /* get the next non vcl bufffer */
         ps_non_vcl_buf = ps_non_vcl_buf->ps_next;
 
     } /* end of loop over all NAL units */
 
     return (OK);
 }
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : isvcd_seq_hdr_dec                                        */
 /*                                                                           */
 /*  Description   : This function decodes sequence header, which includes    */
 /*                  non VCL NAL before the first VCL unit                    */
 /*  Inputs        : Decoder context, inbufs, place holder for number of bytes*/
 /*                  consumed and number of packets consumed                  */
 /*  Globals       : None                                                     */
 /*  Processing    : 1. Parse non VCL units before first VCL unit             */
 /*                  2. Decode parsed non VCL units                           */
 /*  Outputs       : Decoded header                                           */
 /*  Returns       : OK or NOT_OK                                             */
 /*                                                                           */
 /*  Issues        : no known issues                                          */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         06 09 2021   Kishore         Creation                             */
 /*                                                                           */
 /*****************************************************************************/
@@ -6044,125 +6062,117 @@ WORD32 isvcd_get_status(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name :    isvcd_get_buf_info                                    */
 /*                                                                           */
 /*  Description   :                                                          */
 /*                                                                           */
 /*  Inputs        :iv_obj_t decoder handle                                   */
 /*                :pv_api_ip pointer to input structure                      */
 /*                :pv_api_op pointer to output structure                     */
 /*  Globals       : <Does it use any global variables?>                      */
 /*  Outputs       :                                                          */
 /*  Returns       : void                                                     */
 /*                                                                           */
 /*  Issues        : none                                                     */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         06 09 2021   Kishore         Draft                                */
 /*                                                                           */
 /*****************************************************************************/
 WORD32 isvcd_get_buf_info(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)
 {
     dec_struct_t *ps_dec;
     svc_dec_lyr_struct_t *ps_svc_lyr_dec;
     UWORD8 i = 0;  // Default for 420P format
     UWORD16 pic_wd, pic_ht;
     ivd_ctl_getbufinfo_op_t *ps_ctl_op = (ivd_ctl_getbufinfo_op_t *) pv_api_op;
     UWORD32 au4_min_out_buf_size[IVD_VIDDEC_MAX_IO_BUFFERS] = {0};
     svc_dec_ctxt_t *ps_svcd_ctxt;
     ps_svcd_ctxt = (svc_dec_ctxt_t *) dec_hdl->pv_codec_handle;
 
     UNUSED(pv_api_ip);
 
     ps_svc_lyr_dec = &ps_svcd_ctxt->ps_svc_dec_lyr[ps_svcd_ctxt->u1_target_layer_id];
     ps_dec = &ps_svc_lyr_dec->s_dec;
     ps_ctl_op->u4_error_code = 0;
 
     ps_ctl_op->u4_min_num_in_bufs = MIN_IN_BUFS;
     ps_ctl_op->u4_num_disp_bufs = 1;
     pic_wd = 0;
     pic_ht = 0;
 
     if(ps_dec->i4_header_decoded == 3)
     {
-        if(0 == ps_dec->u4_share_disp_buf)
-        {
-            pic_wd = ps_dec->u2_disp_width;
-            pic_ht = ps_dec->u2_disp_height;
-        }
-        else
-        {
-            pic_wd = ps_dec->u2_frm_wd_y;
-            pic_ht = ps_dec->u2_frm_ht_y;
-        }
+        pic_wd = ps_svcd_ctxt->pic_width;
+        pic_ht = ps_svcd_ctxt->pic_height;
     }
 
     for(i = 0; i < ps_ctl_op->u4_min_num_in_bufs; i++)
     {
         ps_ctl_op->u4_min_in_buf_size[i] = MAX(256000, pic_wd * pic_ht * 3 / 2);
     }
     if((WORD32) ps_dec->u4_app_disp_width > pic_wd) pic_wd = ps_dec->u4_app_disp_width;
 
     if(0 == ps_dec->u4_share_disp_buf)
         ps_ctl_op->u4_num_disp_bufs = 1;
     else
     {
         if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))
         {
             if((ps_dec->ps_cur_sps->u1_vui_parameters_present_flag == 1) &&
                (1 == ps_dec->ps_cur_sps->s_vui.u1_bitstream_restriction_flag))
             {
                 ps_ctl_op->u4_num_disp_bufs = ps_dec->ps_cur_sps->s_vui.u4_num_reorder_frames + 1;
             }
             else
             {
                 /*if VUI is not present assume maximum possible refrence frames for the
                  * level, as max reorder frames*/
                 ps_ctl_op->u4_num_disp_bufs = ih264d_get_dpb_size(ps_dec->ps_cur_sps);
             }
 
             ps_ctl_op->u4_num_disp_bufs += ps_dec->ps_cur_sps->u1_num_ref_frames + 1;
         }
         else
         {
             ps_ctl_op->u4_num_disp_bufs = 32;
         }
 
         ps_ctl_op->u4_num_disp_bufs = MAX(ps_ctl_op->u4_num_disp_bufs, 6);
         ps_ctl_op->u4_num_disp_bufs = MIN(ps_ctl_op->u4_num_disp_bufs, 32);
     }
 
     ps_ctl_op->u4_min_num_out_bufs =
         ih264d_get_outbuf_size(pic_wd, pic_ht, ps_dec->u1_chroma_format, &au4_min_out_buf_size[0]);
 
     for(i = 0; i < ps_ctl_op->u4_min_num_out_bufs; i++)
     {
         ps_ctl_op->u4_min_out_buf_size[i] = au4_min_out_buf_size[i];
     }
 
     ps_dec->u4_num_disp_bufs_requested = ps_ctl_op->u4_num_disp_bufs;
 
     return IV_SUCCESS;
 }
 
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : isvcd_set_params                                         */
 /*                                                                           */
 /*  Description   :                                                          */
 /*                                                                           */
 /*  Inputs        :iv_obj_t decoder handle                                   */
 /*                :pv_api_ip pointer to input structure                      */
 /*                :pv_api_op pointer to output structure                     */
 /*  Outputs       :                                                          */
 /*  Returns       : void                                                     */
 /*                                                                           */
 /*  Issues        : none                                                     */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         06 09 2021   Kishore         Draft                                */
 /*                                                                           */
 /*****************************************************************************/
diff --git a/decoder/svc/isvcd_parse_headers.c b/decoder/svc/isvcd_parse_headers.c
index abf4a1b..d137040 100644
--- a/decoder/svc/isvcd_parse_headers.c
+++ b/decoder/svc/isvcd_parse_headers.c
@@ -118,788 +118,759 @@ dif
 *
 * \brief
 *    Decodes Sequence parameter set from the SVC bitstream
 *
 * \return
 *    0 on Success and Error code otherwise
 **************************************************************************
 */
 WORD32 isvcd_parse_subset_sps(svc_dec_lyr_struct_t *ps_svc_lyr_dec, dec_bit_stream_t *ps_bitstrm)
 {
     dec_struct_t *ps_dec = &ps_svc_lyr_dec->s_dec;
     UWORD8 i;
     dec_seq_params_t *ps_seq = NULL;
     dec_svc_seq_params_t *ps_subset_seq = NULL;
     dec_subset_seq_params_t *ps_seq_svc_ext;
     UWORD8 u1_profile_idc, u1_level_idc, u1_seq_parameter_set_id, u1_mb_aff_flag = 0;
     UWORD16 i2_max_frm_num;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
     UWORD8 u1_frm, uc_constraint_set0_flag, uc_constraint_set1_flag, uc_constraint_set2_flag;
     WORD32 i4_cropped_ht, i4_cropped_wd;
     UWORD32 u4_temp;
     UWORD64 u8_temp;
     UWORD32 u4_pic_height_in_map_units, u4_pic_width_in_mbs;
     UWORD32 u2_pic_wd = 0;
     UWORD32 u2_pic_ht = 0;
     UWORD32 u2_frm_wd_y = 0;
     UWORD32 u2_frm_ht_y = 0;
     UWORD32 u2_frm_wd_uv = 0;
     UWORD32 u2_frm_ht_uv = 0;
     UWORD32 u2_crop_offset_y = 0;
     UWORD32 u2_crop_offset_uv = 0;
     WORD32 ret;
     /* High profile related syntax element */
     WORD32 i4_i;
     /* G050 */
     UWORD8 u1_frame_cropping_flag,
         u1_frame_cropping_rect_left_ofst = 0, u1_frame_cropping_rect_right_ofst = 0,
         u1_frame_cropping_rect_top_ofst = 0, u1_frame_cropping_rect_bottom_ofst = 0;
     /* G050 */
     /*--------------------------------------------------------------------*/
     /* Decode seq_parameter_set_id and profile and level values           */
     /*--------------------------------------------------------------------*/
     SWITCHONTRACE;
     u1_profile_idc = ih264d_get_bits_h264(ps_bitstrm, 8);
     COPYTHECONTEXT("SPS: profile_idc", u1_profile_idc);
 
     /* G050 */
     uc_constraint_set0_flag = ih264d_get_bit_h264(ps_bitstrm);
     uc_constraint_set1_flag = ih264d_get_bit_h264(ps_bitstrm);
     uc_constraint_set2_flag = ih264d_get_bit_h264(ps_bitstrm);
     UNUSED(uc_constraint_set1_flag);
     UNUSED(uc_constraint_set2_flag);
 
     /*****************************************************/
     /* Read 5 bits for uc_constraint_set3_flag (1 bit)   */
     /* and reserved_zero_4bits (4 bits) - Sushant        */
     /*****************************************************/
     ih264d_get_bits_h264(ps_bitstrm, 5);
     /* G050 */
     u1_level_idc = (UWORD8) ih264d_get_bits_h264(ps_bitstrm, 8);
     COPYTHECONTEXT("SPS: u4_level_idc", u1_level_idc);
 
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u4_temp & MASK_ERR_SEQ_SET_ID) return ERROR_INV_SPS_PPS_T;
     u1_seq_parameter_set_id = u4_temp;
     COPYTHECONTEXT("SPS: seq_parameter_set_id", u1_seq_parameter_set_id);
 
     if(u1_seq_parameter_set_id >= MAX_NUM_SEQ_PARAMS) return ERROR_INV_SPS_PPS_T;
 
     /*--------------------------------------------------------------------*/
     /* Find an seq param entry in seqparam array of decStruct             */
     /*--------------------------------------------------------------------*/
     ps_subset_seq = ps_svc_lyr_dec->pv_scratch_subset_sps;
     memset(ps_subset_seq, 0, sizeof(dec_svc_seq_params_t));
     ps_seq = ps_dec->pv_scratch_sps_pps;
     memset(ps_seq, 0, sizeof(dec_seq_params_t));
 
-    if(ps_dec->i4_header_decoded & 1)
-    {
-        if(NULL != ps_dec->ps_cur_sps)
-            *ps_seq = *ps_dec->ps_cur_sps;
-        else
-            return ERROR_INV_SPS_PPS_T;
-    }
-
     ps_seq->u1_profile_idc = u1_profile_idc;
     ps_seq->u1_level_idc = u1_level_idc;
     ps_seq->u1_seq_parameter_set_id = u1_seq_parameter_set_id;
 
     /* subset_seq_sps_will be stored from location 32 : MAX_NUM_SEQ_PARAMS*/
     u1_seq_parameter_set_id += MAX_NUM_SEQ_PARAMS;
     ps_subset_seq->ps_seq = &ps_dec->ps_sps[u1_seq_parameter_set_id];
 
     if((ps_dec->i4_header_decoded & 1) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
        (ps_dec->ps_sps[u1_seq_parameter_set_id].u1_profile_idc != u1_profile_idc))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
 
     if((ps_dec->i4_header_decoded & 1) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
        (ps_dec->ps_sps[u1_seq_parameter_set_id].u1_level_idc != u1_level_idc))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
     /*******************************************************************/
     /* Initializations for high profile - Sushant                      */
     /*******************************************************************/
     ps_seq->i4_chroma_format_idc = 1;
     ps_seq->i4_bit_depth_luma_minus8 = 0;
     ps_seq->i4_bit_depth_chroma_minus8 = 0;
     ps_seq->i4_qpprime_y_zero_transform_bypass_flag = 0;
     ps_seq->i4_seq_scaling_matrix_present_flag = 0;
     if(u1_profile_idc == HIGH_PROFILE_IDC || u1_profile_idc == SCALABLE_BASELINE_PROFILE_IDC ||
        u1_profile_idc == SCALABLE_HIGH_PROFILE_IDC)
     {
         /* reading chroma_format_idc   */
         ps_seq->i4_chroma_format_idc = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
         /* Monochrome is not supported */
         if(ps_seq->i4_chroma_format_idc != 1)
         {
             return ERROR_FEATURE_UNAVAIL;
         }
 
         /* reading bit_depth_luma_minus8   */
         ps_seq->i4_bit_depth_luma_minus8 = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
         if(ps_seq->i4_bit_depth_luma_minus8 != 0)
         {
             return ERROR_FEATURE_UNAVAIL;
         }
 
         /* reading bit_depth_chroma_minus8   */
         ps_seq->i4_bit_depth_chroma_minus8 = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
         if(ps_seq->i4_bit_depth_chroma_minus8 != 0)
         {
             return ERROR_FEATURE_UNAVAIL;
         }
 
         /* reading qpprime_y_zero_transform_bypass_flag   */
         ps_seq->i4_qpprime_y_zero_transform_bypass_flag = (WORD32) ih264d_get_bit_h264(ps_bitstrm);
 
         if(ps_seq->i4_qpprime_y_zero_transform_bypass_flag != 0)
         {
             return ERROR_INV_SPS_PPS_T;
         }
 
         /* reading seq_scaling_matrix_present_flag   */
         ps_seq->i4_seq_scaling_matrix_present_flag = (WORD32) ih264d_get_bit_h264(ps_bitstrm);
 
         if(ps_seq->i4_seq_scaling_matrix_present_flag)
         {
             for(i4_i = 0; i4_i < 8; i4_i++)
             {
                 ps_seq->u1_seq_scaling_list_present_flag[i4_i] = ih264d_get_bit_h264(ps_bitstrm);
 
                 /* initialize u1_use_default_scaling_matrix_flag[i4_i] to zero */
                 /* before calling scaling list                             */
                 ps_seq->u1_use_default_scaling_matrix_flag[i4_i] = 0;
 
                 if(ps_seq->u1_seq_scaling_list_present_flag[i4_i])
                 {
                     if(i4_i < 6)
                     {
                         ret = ih264d_scaling_list(ps_seq->i2_scalinglist4x4[i4_i], 16,
                                                   &ps_seq->u1_use_default_scaling_matrix_flag[i4_i],
                                                   ps_bitstrm);
                     }
                     else
                     {
                         ret = ih264d_scaling_list(ps_seq->i2_scalinglist8x8[i4_i - 6], 64,
                                                   &ps_seq->u1_use_default_scaling_matrix_flag[i4_i],
                                                   ps_bitstrm);
                     }
                     if(ret != OK)
                     {
                         return ret;
                     }
                 }
             }
         }
     }
     /*--------------------------------------------------------------------*/
     /* Decode MaxFrameNum                                                 */
     /*--------------------------------------------------------------------*/
     u8_temp = (UWORD64) 4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u8_temp > MAX_BITS_IN_FRAME_NUM)
     {
         return ERROR_INV_SPS_PPS_T;
     }
     ps_seq->u1_bits_in_frm_num = (UWORD8) u8_temp;
     COPYTHECONTEXT("SPS: log2_max_frame_num_minus4", (ps_seq->u1_bits_in_frm_num - 4));
 
     i2_max_frm_num = (1 << (ps_seq->u1_bits_in_frm_num));
     ps_seq->u2_u4_max_pic_num_minus1 = i2_max_frm_num - 1;
     /*--------------------------------------------------------------------*/
     /* Decode picture order count and related values                      */
     /*--------------------------------------------------------------------*/
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
     if(u4_temp > MAX_PIC_ORDER_CNT_TYPE)
     {
         return ERROR_INV_POC_TYPE_T;
     }
     ps_seq->u1_pic_order_cnt_type = u4_temp;
     COPYTHECONTEXT("SPS: pic_order_cnt_type", ps_seq->u1_pic_order_cnt_type);
 
     ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = 1;
     if(ps_seq->u1_pic_order_cnt_type == 0)
     {
         u8_temp = (UWORD64) 4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         if(u8_temp > MAX_BITS_IN_POC_LSB)
         {
             return ERROR_INV_SPS_PPS_T;
         }
         ps_seq->u1_log2_max_pic_order_cnt_lsb_minus = (UWORD8) u8_temp;
         ps_seq->i4_max_pic_order_cntLsb = (1 << u8_temp);
         COPYTHECONTEXT("SPS: log2_max_pic_order_cnt_lsb_minus4", (u8_temp - 4));
     }
     else if(ps_seq->u1_pic_order_cnt_type == 1)
     {
         ps_seq->u1_delta_pic_order_always_zero_flag = ih264d_get_bit_h264(ps_bitstrm);
         COPYTHECONTEXT("SPS: delta_pic_order_always_zero_flag",
                        ps_seq->u1_delta_pic_order_always_zero_flag);
 
         ps_seq->i4_ofst_for_non_ref_pic = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: offset_for_non_ref_pic", ps_seq->i4_ofst_for_non_ref_pic);
 
         ps_seq->i4_ofst_for_top_to_bottom_field = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: offset_for_top_to_bottom_field",
                        ps_seq->i4_ofst_for_top_to_bottom_field);
 
         u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         if(u4_temp > 255) return ERROR_INV_SPS_PPS_T;
         ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = u4_temp;
         COPYTHECONTEXT("SPS: num_ref_frames_in_pic_order_cnt_cycle",
                        ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle);
 
         for(i = 0; i < ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle; i++)
         {
             ps_seq->i4_ofst_for_ref_frame[i] = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
             COPYTHECONTEXT("SPS: offset_for_ref_frame", ps_seq->i4_ofst_for_ref_frame[i]);
         }
     }
 
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
     if((u4_temp > H264_MAX_REF_PICS))
     {
         return ERROR_NUM_REF;
     }
 
     /* Compare with older num_ref_frames is header is already once */
     if((ps_dec->i4_header_decoded & 1) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
        (ps_dec->ps_sps[u1_seq_parameter_set_id].u1_num_ref_frames != u4_temp))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
     ps_seq->u1_num_ref_frames = u4_temp;
     COPYTHECONTEXT("SPS: num_ref_frames", ps_seq->u1_num_ref_frames);
 
     ps_seq->u1_gaps_in_frame_num_value_allowed_flag = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("SPS: gaps_in_frame_num_value_allowed_flag",
                    ps_seq->u1_gaps_in_frame_num_value_allowed_flag);
     /* SVC_DEC_REVIEW */
     ps_seq->u1_gaps_in_frame_num_value_allowed_flag = 0;
 
     /*--------------------------------------------------------------------*/
     /* Decode FrameWidth and FrameHeight and related values               */
     /*--------------------------------------------------------------------*/
     u8_temp = (UWORD64) 1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     /* Check  for unsupported resolutions*/
     if(u8_temp > (H264_MAX_FRAME_WIDTH >> 4))
     {
         return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
     }
     u4_pic_width_in_mbs = (UWORD32) u8_temp;
     COPYTHECONTEXT("SPS: pic_width_in_mbs_minus1", u4_pic_width_in_mbs - 1);
 
     u8_temp = (UWORD64) 1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u8_temp > (H264_MAX_FRAME_HEIGHT >> 4))
     {
         return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
     }
     u4_pic_height_in_map_units = (UWORD32) u8_temp;
 
     ps_seq->u2_frm_wd_in_mbs = u4_pic_width_in_mbs;
     ps_seq->u2_frm_ht_in_mbs = u4_pic_height_in_map_units;
 
     u2_pic_wd = (u4_pic_width_in_mbs << 4);
     u2_pic_ht = (u4_pic_height_in_map_units << 4);
+    if(ps_svc_lyr_dec->pic_width < u2_pic_wd)
+    {
+        ps_svc_lyr_dec->pic_width = u2_pic_wd;
+    }
+    if(ps_svc_lyr_dec->pic_height < u2_pic_ht)
+    {
+        ps_svc_lyr_dec->pic_height = u2_pic_ht;
+    }
+
     /*--------------------------------------------------------------------*/
     /* Get the value of MaxMbAddress and Number of bits needed for it     */
     /*--------------------------------------------------------------------*/
     ps_seq->u2_max_mb_addr = (ps_seq->u2_frm_wd_in_mbs * ps_seq->u2_frm_ht_in_mbs) - 1;
 
     ps_seq->u2_total_num_of_mbs = ps_seq->u2_max_mb_addr + 1;
 
     ps_seq->u1_level_idc = ih264d_correct_level_idc(u1_level_idc, ps_seq->u2_total_num_of_mbs);
 
     u1_frm = ih264d_get_bit_h264(ps_bitstrm);
 
     if((ps_dec->i4_header_decoded & 1) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
        (ps_dec->ps_sps[u1_seq_parameter_set_id].u1_frame_mbs_only_flag != u1_frm))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
     ps_seq->u1_frame_mbs_only_flag = u1_frm;
 
     COPYTHECONTEXT("SPS: frame_mbs_only_flag", u1_frm);
 
     if(!u1_frm) u1_mb_aff_flag = ih264d_get_bit_h264(ps_bitstrm);
     if((ps_dec->i4_header_decoded & 1) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
        (ps_dec->ps_sps[u1_seq_parameter_set_id].u1_mb_aff_flag != u1_mb_aff_flag))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
     if(!u1_frm)
     {
         u2_pic_ht <<= 1;
         ps_seq->u1_mb_aff_flag = u1_mb_aff_flag;
         COPYTHECONTEXT("SPS: mb_adaptive_frame_field_flag", ps_seq->u1_mb_aff_flag);
     }
     else
         ps_seq->u1_mb_aff_flag = 0;
 
     ps_seq->u1_direct_8x8_inference_flag = ih264d_get_bit_h264(ps_bitstrm);
 
     COPYTHECONTEXT("SPS: direct_8x8_inference_flag", ps_seq->u1_direct_8x8_inference_flag);
 
     /* G050 */
     u1_frame_cropping_flag = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("SPS: frame_cropping_flag", u1_frame_cropping_flag);
 
     if(u1_frame_cropping_flag)
     {
         u1_frame_cropping_rect_left_ofst = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: frame_cropping_rect_left_offset", u1_frame_cropping_rect_left_ofst);
         u1_frame_cropping_rect_right_ofst = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: frame_cropping_rect_right_offset", u1_frame_cropping_rect_right_ofst);
         u1_frame_cropping_rect_top_ofst = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: frame_cropping_rect_top_offset", u1_frame_cropping_rect_top_ofst);
         u1_frame_cropping_rect_bottom_ofst = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: frame_cropping_rect_bottom_offset",
                        u1_frame_cropping_rect_bottom_ofst);
     }
     /* G050 */
     ps_seq->u1_vui_parameters_present_flag = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("SPS: vui_parameters_present_flag", ps_seq->u1_vui_parameters_present_flag);
 
     u2_frm_wd_y = u2_pic_wd + (UWORD8) (PAD_LEN_Y_H << 1);
     if(1 == ps_dec->u4_share_disp_buf)
     {
         if(ps_dec->u4_app_disp_width > u2_frm_wd_y) u2_frm_wd_y = ps_dec->u4_app_disp_width;
     }
 
     u2_frm_ht_y = u2_pic_ht + (UWORD8) (PAD_LEN_Y_V << 2);
     u2_frm_wd_uv = u2_pic_wd + (UWORD8) (PAD_LEN_UV_H << 2);
     u2_frm_wd_uv = MAX(u2_frm_wd_uv, u2_frm_wd_y);
 
     u2_frm_ht_uv = (u2_pic_ht >> 1) + (UWORD8) (PAD_LEN_UV_V << 2);
     u2_frm_ht_uv = MAX(u2_frm_ht_uv, (u2_frm_ht_y >> 1));
 
     /* Calculate display picture width, height and start u4_ofst from YUV420 */
     /* pictute buffers as per cropping information parsed above             */
     {
         UWORD16 u2_rgt_ofst = 0;
         UWORD16 u2_lft_ofst = 0;
         UWORD16 u2_top_ofst = 0;
         UWORD16 u2_btm_ofst = 0;
         UWORD8 u1_frm_mbs_flag;
         UWORD8 u1_vert_mult_factor;
 
         if(u1_frame_cropping_flag)
         {
             /* Calculate right and left u4_ofst for cropped picture           */
             u2_rgt_ofst = u1_frame_cropping_rect_right_ofst << 1;
             u2_lft_ofst = u1_frame_cropping_rect_left_ofst << 1;
 
             /* Know frame MBs only u4_flag                                      */
             u1_frm_mbs_flag = (1 == ps_seq->u1_frame_mbs_only_flag);
 
             /* Simplify the vertical u4_ofst calculation from field/frame     */
             u1_vert_mult_factor = (2 - u1_frm_mbs_flag);
 
             /* Calculate bottom and top u4_ofst for cropped  picture          */
             u2_btm_ofst = (u1_frame_cropping_rect_bottom_ofst << u1_vert_mult_factor);
             u2_top_ofst = (u1_frame_cropping_rect_top_ofst << u1_vert_mult_factor);
         }
 
         /* Calculate u4_ofst from start of YUV 420 picture buffer to start of*/
         /* cropped picture buffer                                           */
         u2_crop_offset_y = (u2_frm_wd_y * u2_top_ofst) + (u2_lft_ofst);
         u2_crop_offset_uv =
             (u2_frm_wd_uv * (u2_top_ofst >> 1)) + (u2_lft_ofst >> 1) * YUV420SP_FACTOR;
         /* Calculate the display picture width and height based on crop      */
         /* information                                                       */
         i4_cropped_ht = (WORD32) u2_pic_ht - (WORD32) (u2_btm_ofst + u2_top_ofst);
         i4_cropped_wd = (WORD32) u2_pic_wd - (WORD32) (u2_rgt_ofst + u2_lft_ofst);
 
         if((i4_cropped_ht < MB_SIZE) || (i4_cropped_wd < MB_SIZE))
         {
             return ERROR_INV_SPS_PPS_T;
         }
 
         if((ps_dec->i4_header_decoded & 1) &&
            (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
            (ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id].u2_pic_wd != u2_pic_wd))
         {
             ps_dec->u1_res_changed = 1;
             return IVD_RES_CHANGED;
         }
 
         if((ps_dec->i4_header_decoded & 1) &&
            (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
            (ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id].u2_disp_width != i4_cropped_wd))
         {
             ps_dec->u1_res_changed = 1;
             return IVD_RES_CHANGED;
         }
 
         if((ps_dec->i4_header_decoded & 1) &&
            (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
            (ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id].u2_pic_ht != u2_pic_ht))
         {
             ps_dec->u1_res_changed = 1;
             return IVD_RES_CHANGED;
         }
 
         if((ps_dec->i4_header_decoded & 1) &&
            (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
            (ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id].u2_disp_height != i4_cropped_ht))
         {
             ps_dec->u1_res_changed = 1;
             return IVD_RES_CHANGED;
         }
         /* Check again for unsupported resolutions with updated values*/
         if((u2_pic_wd > SVCD_MAX_FRAME_WIDTH) || (u2_pic_ht > SVCD_MAX_FRAME_HEIGHT) ||
            (u2_pic_wd < SVCD_MIN_FRAME_WIDTH) || (u2_pic_ht < SVCD_MIN_FRAME_HEIGHT) ||
            (u2_pic_wd * (UWORD32) u2_pic_ht > SVCD_MAX_FRAME_SIZE))
         {
             return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
         }
 
         /* If MBAff is enabled, decoder support is limited to streams with
          * width less than half of H264_MAX_FRAME_WIDTH.
          * In case of MBAff decoder processes two rows at a time
          */
         if((u2_pic_wd << ps_seq->u1_mb_aff_flag) > H264_MAX_FRAME_WIDTH)
         {
             return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
         }
     }
 
     if(1 == ps_seq->u1_vui_parameters_present_flag)
     {
         ret = ih264d_parse_vui_parametres(&ps_seq->s_vui, ps_bitstrm);
         if(ret != OK) return ret;
     }
     ps_seq_svc_ext = &ps_subset_seq->s_sps_svc_ext;
 
     isvcd_set_default_seq_svc_ext(ps_seq_svc_ext);
 
     if(SCALABLE_BASELINE_PROFILE_IDC == ps_seq->u1_profile_idc ||
        SCALABLE_HIGH_PROFILE_IDC == ps_seq->u1_profile_idc)
     {
         SWITCHONTRACE;
         ps_seq_svc_ext->u1_inter_layer_deblocking_filter_control_present_flag =
             ih264d_get_bit_h264(ps_bitstrm);
         COPYTHECONTEXT("SPS_EXt: u1_inter_layer_deblocking_filter_control_present_flag",
                        ps_seq_svc_ext->u1_inter_layer_deblocking_filter_control_present_flag);
 
         ps_seq_svc_ext->u1_extended_spatial_scalability_idc = ih264d_get_bits_h264(ps_bitstrm, 2);
         COPYTHECONTEXT("SPS_EXt: u1_extended_spatial_scalability_idc",
                        ps_seq_svc_ext->u1_extended_spatial_scalability_idc);
 
         /* u1_extended_spatial_scalability_idc value 0, 1 and 2 are supported */
         if(ps_seq_svc_ext->u1_extended_spatial_scalability_idc > 2)
         {
             return ERROR_SVC_INV_SUBSET_SPS;
         }
 
         /* ChromaArrayType = i4_chroma_format_idc  if  separate_colour_plane_flag =
          * 0 for all chroma format except 4:4:4 */
         if(1 == ps_seq->i4_chroma_format_idc || 2 == ps_seq->i4_chroma_format_idc)
         {
             ps_seq_svc_ext->u1_chroma_phase_x_plus1_flag = ih264d_get_bit_h264(ps_bitstrm);
             COPYTHECONTEXT("SPS_EXt: u1_chroma_phase_x_plus1_flag",
                            ps_seq_svc_ext->u1_chroma_phase_x_plus1_flag);
         }
 
         if(1 == ps_seq->i4_chroma_format_idc)
         {
             ps_seq_svc_ext->u1_chroma_phase_y_plus1 = ih264d_get_bits_h264(ps_bitstrm, 2);
             COPYTHECONTEXT("SPS_EXt: u1_chroma_phase_y_plus1",
                            ps_seq_svc_ext->u1_chroma_phase_y_plus1);
 
             if(ps_seq_svc_ext->u1_chroma_phase_y_plus1 >= 3)
             {
                 return ERROR_SVC_INV_SUBSET_SPS;
             }
         }
 
         /* inferred values not covered in isvcd_set_default_seq_svc_ext*/
         ps_seq_svc_ext->u1_seq_ref_layer_chroma_phase_x_plus1_flag =
             ps_seq_svc_ext->u1_chroma_phase_x_plus1_flag;
         ps_seq_svc_ext->u1_seq_ref_layer_chroma_phase_y_plus1 =
             ps_seq_svc_ext->u1_chroma_phase_y_plus1;
 
         if(1 == ps_seq_svc_ext->u1_extended_spatial_scalability_idc)
         {
             if(ps_seq->i4_chroma_format_idc > 0)
             {
                 ps_seq_svc_ext->u1_seq_ref_layer_chroma_phase_x_plus1_flag =
                     ih264d_get_bit_h264(ps_bitstrm);
                 COPYTHECONTEXT("SPS_EXt: u1_seq_ref_layer_chroma_phase_x_plus1_flag",
                                ps_seq_svc_ext->u1_seq_ref_layer_chroma_phase_x_plus1_flag);
 
                 ps_seq_svc_ext->u1_seq_ref_layer_chroma_phase_y_plus1 =
                     ih264d_get_bits_h264(ps_bitstrm, 2);
                 COPYTHECONTEXT("SPS_EXt: u1_seq_ref_layer_chroma_phase_y_plus1",
                                ps_seq_svc_ext->u1_seq_ref_layer_chroma_phase_y_plus1);
 
                 if(ps_seq_svc_ext->u1_seq_ref_layer_chroma_phase_y_plus1 >= 3)
                 {
                     return ERROR_SVC_INV_SUBSET_SPS;
                 }
             }
 
             ps_seq_svc_ext->i4_seq_scaled_ref_layer_left_offset =
                 ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
             COPYTHECONTEXT("SPS_EXt: i4_seq_scaled_ref_layer_left_offset",
                            ps_seq_svc_ext->i4_seq_scaled_ref_layer_left_offset);
 
             if(ps_seq_svc_ext->i4_seq_scaled_ref_layer_left_offset != 0)
             {
                 return ERROR_SVC_INV_SUBSET_SPS;
             }
 
             if(ps_seq_svc_ext->i4_seq_scaled_ref_layer_left_offset >= MAX_SCLD_REF_LAYER_OFFSET ||
                ps_seq_svc_ext->i4_seq_scaled_ref_layer_left_offset < MIN_SCLD_REF_LAYER_OFFSET)
             {
                 return ERROR_SVC_INV_SUBSET_SPS;
             }
 
             ps_seq_svc_ext->i4_seq_scaled_ref_layer_top_offset =
                 ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
             COPYTHECONTEXT("SPS_EXt: i4_seq_scaled_ref_layer_top_offset",
                            ps_seq_svc_ext->i4_seq_scaled_ref_layer_top_offset);
 
             if(ps_seq_svc_ext->i4_seq_scaled_ref_layer_top_offset != 0)
             {
                 return ERROR_SVC_INV_SUBSET_SPS;
             }
 
             if(ps_seq_svc_ext->i4_seq_scaled_ref_layer_top_offset >= MAX_SCLD_REF_LAYER_OFFSET ||
                ps_seq_svc_ext->i4_seq_scaled_ref_layer_top_offset < MIN_SCLD_REF_LAYER_OFFSET)
             {
                 return ERROR_SVC_INV_SUBSET_SPS;
             }
 
             ps_seq_svc_ext->i4_seq_scaled_ref_layer_right_offset =
                 ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
             COPYTHECONTEXT("SPS_EXt: i4_seq_scaled_ref_layer_right_offset",
                            ps_seq_svc_ext->i4_seq_scaled_ref_layer_right_offset);
 
             if(ps_seq_svc_ext->i4_seq_scaled_ref_layer_right_offset >= MAX_SCLD_REF_LAYER_OFFSET ||
                ps_seq_svc_ext->i4_seq_scaled_ref_layer_right_offset < MIN_SCLD_REF_LAYER_OFFSET)
             {
                 return ERROR_SVC_INV_SUBSET_SPS;
             }
 
             ps_seq_svc_ext->i4_seq_scaled_ref_layer_bottom_offset =
                 ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
             COPYTHECONTEXT("SPS_EXt: i4_seq_scaled_ref_layer_bottom_offset",
                            ps_seq_svc_ext->i4_seq_scaled_ref_layer_bottom_offset);
 
             if(ps_seq_svc_ext->i4_seq_scaled_ref_layer_bottom_offset >= MAX_SCLD_REF_LAYER_OFFSET ||
                ps_seq_svc_ext->i4_seq_scaled_ref_layer_bottom_offset < MIN_SCLD_REF_LAYER_OFFSET)
             {
                 return ERROR_INV_SLICE_HDR_T;
             }
         }
 
         ps_seq_svc_ext->u1_seq_tcoeff_level_prediction_flag = ih264d_get_bit_h264(ps_bitstrm);
         COPYTHECONTEXT("SPS_EXt: u1_seq_tcoeff_level_prediction_flag",
                        ps_seq_svc_ext->u1_seq_tcoeff_level_prediction_flag);
 
         if(1 == ps_seq_svc_ext->u1_seq_tcoeff_level_prediction_flag)
         {
             ps_seq_svc_ext->u1_adaptive_tcoeff_level_prediction_flag =
                 ih264d_get_bit_h264(ps_bitstrm);
             COPYTHECONTEXT("SPS_EXt: u1_adaptive_tcoeff_level_prediction_flag",
                            ps_seq_svc_ext->u1_adaptive_tcoeff_level_prediction_flag);
         }
 
         ps_seq_svc_ext->u1_slice_header_restriction_flag = ih264d_get_bit_h264(ps_bitstrm);
         COPYTHECONTEXT("SPS_EXt: u1_slice_header_restriction_flag",
                        ps_seq_svc_ext->u1_slice_header_restriction_flag);
 
         ps_seq_svc_ext->u1_svc_vui_parameters_present_flag = ih264d_get_bit_h264(ps_bitstrm);
         COPYTHECONTEXT("SPS_EXt: u1_svc_vui_parameters_present_flag",
                        ps_seq_svc_ext->u1_svc_vui_parameters_present_flag);
 
         if(1 == ps_seq_svc_ext->u1_svc_vui_parameters_present_flag)
         {
             if(NULL ==
                ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id].s_sps_svc_ext.ps_svc_vui_ext)
             {
                 void *pv_buf;
                 UWORD32 size;
                 /* Memory allocation only if VUI is enabled in a particular subset SPS*/
                 size = sizeof(svc_vui_ext_t);
                 pv_buf = ps_dec->pf_aligned_alloc(ps_dec->pv_mem_ctxt, 128, size);
                 RETURN_IF((NULL == pv_buf), IV_FAIL);
                 memset(pv_buf, 0, size);
                 ps_seq_svc_ext->ps_svc_vui_ext = pv_buf;
                 ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id]
                     .s_sps_svc_ext.ps_svc_vui_ext = pv_buf;
             }
             else
             {
                 ps_seq_svc_ext->ps_svc_vui_ext =
                     ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id]
                         .s_sps_svc_ext.ps_svc_vui_ext;
             }
             ret = isvcd_parse_vui_ext_parametres(ps_seq_svc_ext->ps_svc_vui_ext, ps_bitstrm);
             if(ret != OK) return ret;
         }
     }
     /* Add conditions for SCALABLE BASELINE PROFILE */
     if(SCALABLE_BASELINE_PROFILE_IDC == ps_seq->u1_profile_idc ||
        ((SCALABLE_HIGH_PROFILE_IDC == ps_seq->u1_profile_idc) && (1 == uc_constraint_set0_flag)))
     {
         if(ps_seq->i4_chroma_format_idc != 1)
         {
             return ERROR_FEATURE_UNAVAIL;
         }
 
         if(ps_seq->i4_bit_depth_luma_minus8 != 0)
         {
             return ERROR_FEATURE_UNAVAIL;
         }
 
         if(ps_seq->i4_bit_depth_chroma_minus8 != 0)
         {
             return ERROR_FEATURE_UNAVAIL;
         }
 
         if(ps_seq->i4_qpprime_y_zero_transform_bypass_flag != 0)
         {
             return ERROR_FEATURE_UNAVAIL;
         }
 
         if(ps_seq->u1_frame_mbs_only_flag != 1)
         {
             return ERROR_FEATURE_UNAVAIL;
         }
 
         if((0 != ps_seq_svc_ext->i4_seq_scaled_ref_layer_left_offset % 16) &&
            (0 != ps_seq_svc_ext->i4_seq_scaled_ref_layer_top_offset % 16))
         {
             return ERROR_FEATURE_UNAVAIL;
         }
     }
     /* Compare older num_reorder_frames with the new one if header is already
      * decoded */
     if((ps_dec->i4_header_decoded & 1) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_vui_parameters_present_flag) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].s_vui.u1_bitstream_restriction_flag))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
     /* In case bitstream read has exceeded the filled size, then return an error */
     if(EXCEED_OFFSET(ps_bitstrm))
     {
         return ERROR_INV_SPS_PPS_T;
     }
 
     /*--------------------------------------------------------------------*/
     /* All initializations to ps_dec are beyond this point                */
     /*--------------------------------------------------------------------*/
     {
         WORD32 reorder_depth = ih264d_get_dpb_size(ps_seq);
         if((1 == ps_seq->u1_vui_parameters_present_flag) &&
            (1 == ps_seq->s_vui.u1_bitstream_restriction_flag))
         {
             reorder_depth = ps_seq->s_vui.u4_num_reorder_frames + 1;
         }
 
         if(reorder_depth > H264_MAX_REF_PICS)
         {
             return ERROR_INV_SPS_PPS_T;
         }
 
         if(ps_seq->u1_frame_mbs_only_flag != 1) reorder_depth *= 2;
         ps_subset_seq->i4_reorder_depth = reorder_depth + DISPLAY_LATENCY;
     }
     ps_subset_seq->u2_disp_height = i4_cropped_ht;
     ps_subset_seq->u2_disp_width = i4_cropped_wd;
     ps_subset_seq->u2_pic_wd = u2_pic_wd;
     ps_subset_seq->u2_pic_ht = u2_pic_ht;
 
     /* Assuming 8k is the maximum resolution svc dec supports*/
     if(u2_frm_wd_y > H264_MAX_FRAME_WIDTH) return (NOT_OK);
     if(u2_frm_ht_y > H264_MAX_FRAME_HEIGHT) return (NOT_OK);
     if(u2_frm_wd_uv > H264_MAX_FRAME_WIDTH) return (NOT_OK);
     if(u2_frm_ht_uv > H264_MAX_FRAME_HEIGHT) return (NOT_OK);
 
     /* Determining the Width and Height of Frame from that of Picture */
     ps_subset_seq->u2_frm_wd_y = u2_frm_wd_y;
     ps_subset_seq->u2_frm_ht_y = u2_frm_ht_y;
     ps_subset_seq->u2_frm_wd_uv = u2_frm_wd_uv;
     ps_subset_seq->u2_frm_ht_uv = u2_frm_ht_uv;
 
     ps_subset_seq->u1_pad_len_y_v = (UWORD8) (PAD_LEN_Y_V << (1 - u1_frm));
     ps_subset_seq->u1_pad_len_cr_v = (UWORD8) (PAD_LEN_UV_V << (1 - u1_frm));
 
     ps_subset_seq->u2_crop_offset_y = u2_crop_offset_y;
     ps_subset_seq->u2_crop_offset_uv = u2_crop_offset_uv;
 
-    if(((ps_dec->u2_pic_wd * ps_dec->u2_pic_ht) <
-        (ps_subset_seq->u2_pic_wd * ps_subset_seq->u2_pic_ht)) ||
-       (ps_dec->i4_reorder_depth < ps_subset_seq->i4_reorder_depth))
-    {
-        ps_dec->i4_reorder_depth = ps_subset_seq->i4_reorder_depth;
-
-        ps_dec->u2_disp_height = ps_subset_seq->u2_disp_height;
-        ps_dec->u2_disp_width = ps_subset_seq->u2_disp_width;
-
-        ps_dec->u2_pic_wd = ps_subset_seq->u2_pic_wd;
-        ps_dec->u2_pic_ht = ps_subset_seq->u2_pic_ht;
-        ps_dec->u4_total_mbs = ps_seq->u2_total_num_of_mbs << (1 - ps_seq->u1_frame_mbs_only_flag);
-
-        /* Determining the Width and Height of Frame from that of Picture */
-        ps_dec->u2_frm_wd_y = ps_subset_seq->u2_frm_wd_y;
-        ps_dec->u2_frm_ht_y = ps_subset_seq->u2_frm_ht_y;
-        ps_dec->u2_frm_wd_uv = ps_subset_seq->u2_frm_wd_uv;
-        ps_dec->u2_frm_ht_uv = ps_subset_seq->u2_frm_ht_uv;
-
-        ps_dec->s_pad_mgr.u1_pad_len_y_v = ps_subset_seq->u1_pad_len_y_v;
-        ps_dec->s_pad_mgr.u1_pad_len_cr_v = ps_subset_seq->u1_pad_len_cr_v;
-
-        ps_dec->u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs;
-        ps_dec->u2_frm_ht_in_mbs = ps_seq->u2_frm_ht_in_mbs;
-
-        ps_dec->u2_crop_offset_y = ps_subset_seq->u2_crop_offset_y;
-        ps_dec->u2_crop_offset_uv = ps_subset_seq->u2_crop_offset_uv;
-    }
-
     ps_seq->u1_is_valid = TRUE;
     ps_dec->ps_sps[u1_seq_parameter_set_id] = *ps_seq;
     if(NULL != ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id].s_sps_svc_ext.ps_svc_vui_ext)
     {
         ps_seq_svc_ext->ps_svc_vui_ext =
             ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id].s_sps_svc_ext.ps_svc_vui_ext;
     }
     ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id] = *ps_subset_seq;
-    ps_dec->ps_cur_sps = &ps_dec->ps_sps[u1_seq_parameter_set_id];
     ps_svc_lyr_dec->ps_cur_subset_sps = &ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id];
 
     return OK;
 }
 /*!
  **************************************************************************
  * \if Function name : isvcd_dec_ref_base_pic_marking \endif
  *
  * \brief
  *    Decodes reference base pic marking params
  *
  * \return
  *    0 on Success and error code otherwise
  **************************************************************************
  */
@@ -1096,593 +1067,566 @@ WORD32 isvcd_parse_nal_unit(svc_dec_lyr_struct_t *dec_svc_hdl, UWORD8 u1_nal_ref
 /*!
 **************************************************************************
 * \if Function name : isvcd_parse_sps \endif
 *
 * \brief
 *    Decodes Picture Parameter set
 *
 * \return
 *    0 on Success and Error code otherwise
 **************************************************************************
 */
 WORD32 isvcd_parse_sps(svc_dec_lyr_struct_t *ps_svc_lyr_dec, dec_bit_stream_t *ps_bitstrm)
 {
     dec_struct_t *ps_dec = &ps_svc_lyr_dec->s_dec;
     UWORD8 i;
     dec_seq_params_t *ps_seq = NULL;
     dec_svc_seq_params_t *ps_subset_seq = NULL;
     UWORD8 u1_profile_idc, u1_level_idc, u1_seq_parameter_set_id, u1_mb_aff_flag = 0;
     UWORD16 i2_max_frm_num;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
     UWORD8 u1_frm, uc_constraint_set0_flag, uc_constraint_set1_flag, uc_constraint_set2_flag;
     WORD32 i4_cropped_ht, i4_cropped_wd;
     UWORD32 u4_temp;
     UWORD64 u8_temp;
     UWORD32 u4_pic_height_in_map_units, u4_pic_width_in_mbs;
     UWORD32 u2_pic_wd = 0;
     UWORD32 u2_pic_ht = 0;
     UWORD32 u2_frm_wd_y = 0;
     UWORD32 u2_frm_ht_y = 0;
     UWORD32 u2_frm_wd_uv = 0;
     UWORD32 u2_frm_ht_uv = 0;
     UWORD32 u2_crop_offset_y = 0;
     UWORD32 u2_crop_offset_uv = 0;
     WORD32 ret;
     WORD32 num_reorder_frames;
     /* High profile related syntax element */
     WORD32 i4_i;
     /* G050 */
     UWORD8 u1_frame_cropping_flag,
         u1_frame_cropping_rect_left_ofst = 0, u1_frame_cropping_rect_right_ofst = 0,
         u1_frame_cropping_rect_top_ofst = 0, u1_frame_cropping_rect_bottom_ofst = 0;
     /* G050 */
     /*--------------------------------------------------------------------*/
     /* Decode seq_parameter_set_id and profile and level values           */
     /*--------------------------------------------------------------------*/
     SWITCHONTRACE;
     u1_profile_idc = ih264d_get_bits_h264(ps_bitstrm, 8);
     COPYTHECONTEXT("SPS: profile_idc", u1_profile_idc);
 
     /* G050 */
     uc_constraint_set0_flag = ih264d_get_bit_h264(ps_bitstrm);
     uc_constraint_set1_flag = ih264d_get_bit_h264(ps_bitstrm);
     uc_constraint_set2_flag = ih264d_get_bit_h264(ps_bitstrm);
     UNUSED(uc_constraint_set2_flag);
     /*****************************************************/
     /* Read 5 bits for uc_constraint_set3_flag (1 bit)   */
     /* and reserved_zero_4bits (4 bits) - Sushant        */
     /*****************************************************/
     ih264d_get_bits_h264(ps_bitstrm, 5);
     /* G050 */
     /* Check whether particular profile is suported or not */
     /* Check whether particular profile is suported or not */
     if((u1_profile_idc != MAIN_PROFILE_IDC) && (u1_profile_idc != BASE_PROFILE_IDC) &&
        (u1_profile_idc != HIGH_PROFILE_IDC))
     {
         /* Apart from Baseline, main and high profile,
          * only extended profile is supported provided
          * uc_constraint_set0_flag or uc_constraint_set1_flag are set to 1
          */
         if((u1_profile_idc != EXTENDED_PROFILE_IDC) ||
            ((uc_constraint_set1_flag != 1) && (uc_constraint_set0_flag != 1)))
         {
             return (ERROR_FEATURE_UNAVAIL);
         }
     }
 
     u1_level_idc = ih264d_get_bits_h264(ps_bitstrm, 8);
     COPYTHECONTEXT("SPS: u4_level_idc", u1_level_idc);
 
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u4_temp & MASK_ERR_SEQ_SET_ID) return ERROR_INV_SPS_PPS_T;
     u1_seq_parameter_set_id = u4_temp;
     COPYTHECONTEXT("SPS: seq_parameter_set_id", u1_seq_parameter_set_id);
 
     /*--------------------------------------------------------------------*/
     /* Find an seq param entry in seqparam array of decStruct             */
     /*--------------------------------------------------------------------*/
     ps_subset_seq = ps_svc_lyr_dec->pv_scratch_subset_sps;
     memset(ps_subset_seq, 0, sizeof(dec_svc_seq_params_t));
     ps_seq = ps_dec->pv_scratch_sps_pps;
     memset(ps_seq, 0, sizeof(dec_seq_params_t));
 
-    if(ps_dec->i4_header_decoded & 1)
-    {
-        if(ps_dec->ps_cur_sps != NULL)
-            *ps_seq = *ps_dec->ps_cur_sps;
-        else
-            return ERROR_INV_SPS_PPS_T;
-    }
-
     if((ps_dec->i4_header_decoded & 1) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
        (ps_dec->ps_sps[u1_seq_parameter_set_id].u1_profile_idc != u1_profile_idc))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
 
     if((ps_dec->i4_header_decoded & 1) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
        (ps_dec->ps_sps[u1_seq_parameter_set_id].u1_level_idc != u1_level_idc))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
 
     ps_seq->u1_profile_idc = u1_profile_idc;
     ps_seq->u1_level_idc = u1_level_idc;
     ps_seq->u1_seq_parameter_set_id = u1_seq_parameter_set_id;
     ps_subset_seq->ps_seq = &ps_dec->ps_sps[u1_seq_parameter_set_id];
 
     /*******************************************************************/
     /* Initializations for high profile - Sushant                      */
     /*******************************************************************/
     ps_seq->i4_chroma_format_idc = 1;
     ps_seq->i4_bit_depth_luma_minus8 = 0;
     ps_seq->i4_bit_depth_chroma_minus8 = 0;
     ps_seq->i4_qpprime_y_zero_transform_bypass_flag = 0;
     ps_seq->i4_seq_scaling_matrix_present_flag = 0;
     if(u1_profile_idc == HIGH_PROFILE_IDC || u1_profile_idc == SCALABLE_BASELINE_PROFILE_IDC ||
        u1_profile_idc == SCALABLE_HIGH_PROFILE_IDC)
     {
         /* reading chroma_format_idc   */
         ps_seq->i4_chroma_format_idc = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
         /* Monochrome is not supported */
         if(ps_seq->i4_chroma_format_idc != 1)
         {
             return ERROR_FEATURE_UNAVAIL;
         }
 
         /* reading bit_depth_luma_minus8   */
         ps_seq->i4_bit_depth_luma_minus8 = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
         if(ps_seq->i4_bit_depth_luma_minus8 != 0)
         {
             return ERROR_FEATURE_UNAVAIL;
         }
 
         /* reading bit_depth_chroma_minus8   */
         ps_seq->i4_bit_depth_chroma_minus8 = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
         if(ps_seq->i4_bit_depth_chroma_minus8 != 0)
         {
             return ERROR_FEATURE_UNAVAIL;
         }
 
         /* reading qpprime_y_zero_transform_bypass_flag   */
         ps_seq->i4_qpprime_y_zero_transform_bypass_flag = (WORD32) ih264d_get_bit_h264(ps_bitstrm);
 
         if(ps_seq->i4_qpprime_y_zero_transform_bypass_flag != 0)
         {
             return ERROR_INV_SPS_PPS_T;
         }
 
         /* reading seq_scaling_matrix_present_flag   */
         ps_seq->i4_seq_scaling_matrix_present_flag = (WORD32) ih264d_get_bit_h264(ps_bitstrm);
 
         if(ps_seq->i4_seq_scaling_matrix_present_flag)
         {
             for(i4_i = 0; i4_i < 8; i4_i++)
             {
                 ps_seq->u1_seq_scaling_list_present_flag[i4_i] = ih264d_get_bit_h264(ps_bitstrm);
 
                 /* initialize u1_use_default_scaling_matrix_flag[i4_i] to zero */
                 /* before calling scaling list                             */
                 ps_seq->u1_use_default_scaling_matrix_flag[i4_i] = 0;
 
                 if(ps_seq->u1_seq_scaling_list_present_flag[i4_i])
                 {
                     if(i4_i < 6)
                     {
                         ret = ih264d_scaling_list(ps_seq->i2_scalinglist4x4[i4_i], 16,
                                                   &ps_seq->u1_use_default_scaling_matrix_flag[i4_i],
                                                   ps_bitstrm);
                     }
                     else
                     {
                         ret = ih264d_scaling_list(ps_seq->i2_scalinglist8x8[i4_i - 6], 64,
                                                   &ps_seq->u1_use_default_scaling_matrix_flag[i4_i],
                                                   ps_bitstrm);
                     }
                     if(ret != OK)
                     {
                         return ret;
                     }
                 }
             }
         }
     }
     /*--------------------------------------------------------------------*/
     /* Decode MaxFrameNum                                                 */
     /*--------------------------------------------------------------------*/
     u8_temp = (UWORD64) 4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u8_temp > MAX_BITS_IN_FRAME_NUM)
     {
         return ERROR_INV_SPS_PPS_T;
     }
     ps_seq->u1_bits_in_frm_num = (UWORD8) u8_temp;
     COPYTHECONTEXT("SPS: log2_max_frame_num_minus4", (ps_seq->u1_bits_in_frm_num - 4));
 
     i2_max_frm_num = (1 << (ps_seq->u1_bits_in_frm_num));
     ps_seq->u2_u4_max_pic_num_minus1 = i2_max_frm_num - 1;
     /*--------------------------------------------------------------------*/
     /* Decode picture order count and related values                      */
     /*--------------------------------------------------------------------*/
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u4_temp > MAX_PIC_ORDER_CNT_TYPE)
     {
         return ERROR_INV_POC_TYPE_T;
     }
     ps_seq->u1_pic_order_cnt_type = u4_temp;
     COPYTHECONTEXT("SPS: pic_order_cnt_type", ps_seq->u1_pic_order_cnt_type);
 
     ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = 1;
     if(ps_seq->u1_pic_order_cnt_type == 0)
     {
         u8_temp = (UWORD64) 4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         if(u8_temp > MAX_BITS_IN_POC_LSB)
         {
             return ERROR_INV_SPS_PPS_T;
         }
         ps_seq->u1_log2_max_pic_order_cnt_lsb_minus = (UWORD8) u8_temp;
         ps_seq->i4_max_pic_order_cntLsb = (1 << u8_temp);
         COPYTHECONTEXT("SPS: log2_max_pic_order_cnt_lsb_minus4", (u8_temp - 4));
     }
     else if(ps_seq->u1_pic_order_cnt_type == 1)
     {
         ps_seq->u1_delta_pic_order_always_zero_flag = ih264d_get_bit_h264(ps_bitstrm);
         COPYTHECONTEXT("SPS: delta_pic_order_always_zero_flag",
                        ps_seq->u1_delta_pic_order_always_zero_flag);
 
         ps_seq->i4_ofst_for_non_ref_pic = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: offset_for_non_ref_pic", ps_seq->i4_ofst_for_non_ref_pic);
 
         ps_seq->i4_ofst_for_top_to_bottom_field = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: offset_for_top_to_bottom_field",
                        ps_seq->i4_ofst_for_top_to_bottom_field);
 
         u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         if(u4_temp > 255) return ERROR_INV_SPS_PPS_T;
         ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = u4_temp;
         COPYTHECONTEXT("SPS: num_ref_frames_in_pic_order_cnt_cycle",
                        ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle);
 
         for(i = 0; i < ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle; i++)
         {
             ps_seq->i4_ofst_for_ref_frame[i] = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
             COPYTHECONTEXT("SPS: offset_for_ref_frame", ps_seq->i4_ofst_for_ref_frame[i]);
         }
     }
 
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
     if((u4_temp > H264_MAX_REF_PICS))
     {
         return ERROR_NUM_REF;
     }
 
     /* Compare with older num_ref_frames is header is already once */
     if((ps_dec->i4_header_decoded & 1) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
        (ps_dec->ps_sps[u1_seq_parameter_set_id].u1_num_ref_frames != u4_temp))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
 
     ps_seq->u1_num_ref_frames = u4_temp;
     COPYTHECONTEXT("SPS: num_ref_frames", ps_seq->u1_num_ref_frames);
 
     ps_seq->u1_gaps_in_frame_num_value_allowed_flag = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("SPS: gaps_in_frame_num_value_allowed_flag",
                    ps_seq->u1_gaps_in_frame_num_value_allowed_flag);
 
     ps_seq->u1_gaps_in_frame_num_value_allowed_flag = 0;
 
     /*--------------------------------------------------------------------*/
     /* Decode FrameWidth and FrameHeight and related values               */
     /*--------------------------------------------------------------------*/
     u8_temp = (UWORD64) 1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     /* Check  for unsupported resolutions*/
     if(u8_temp > (H264_MAX_FRAME_WIDTH >> 4))
     {
         return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
     }
     u4_pic_width_in_mbs = (UWORD32) u8_temp;
     COPYTHECONTEXT("SPS: pic_width_in_mbs_minus1", u4_pic_width_in_mbs - 1);
 
     u8_temp = (UWORD64) 1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u8_temp > (H264_MAX_FRAME_HEIGHT >> 4))
     {
         return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
     }
     u4_pic_height_in_map_units = (UWORD32) u8_temp;
 
     ps_seq->u2_frm_wd_in_mbs = u4_pic_width_in_mbs;
     ps_seq->u2_frm_ht_in_mbs = u4_pic_height_in_map_units;
     u2_pic_wd = (u4_pic_width_in_mbs << 4);
     u2_pic_ht = (u4_pic_height_in_map_units << 4);
+    if(ps_svc_lyr_dec->pic_width < u2_pic_wd)
+    {
+        ps_svc_lyr_dec->pic_width = u2_pic_wd;
+    }
+    if(ps_svc_lyr_dec->pic_height < u2_pic_ht)
+    {
+        ps_svc_lyr_dec->pic_height = u2_pic_ht;
+    }
+
     /*--------------------------------------------------------------------*/
     /* Get the value of MaxMbAddress and Number of bits needed for it     */
     /*--------------------------------------------------------------------*/
     ps_seq->u2_max_mb_addr = (ps_seq->u2_frm_wd_in_mbs * ps_seq->u2_frm_ht_in_mbs) - 1;
     ps_seq->u2_total_num_of_mbs = ps_seq->u2_max_mb_addr + 1;
     ps_seq->u1_level_idc = ih264d_correct_level_idc(u1_level_idc, ps_seq->u2_total_num_of_mbs);
 
     u1_frm = ih264d_get_bit_h264(ps_bitstrm);
     if((ps_dec->i4_header_decoded & 1) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
        (ps_dec->ps_sps[u1_seq_parameter_set_id].u1_frame_mbs_only_flag != u1_frm))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
     ps_seq->u1_frame_mbs_only_flag = u1_frm;
     COPYTHECONTEXT("SPS: frame_mbs_only_flag", u1_frm);
 
     if(!u1_frm) u1_mb_aff_flag = ih264d_get_bit_h264(ps_bitstrm);
 
     if((ps_dec->i4_header_decoded & 1) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
        (ps_dec->ps_sps[u1_seq_parameter_set_id].u1_mb_aff_flag != u1_mb_aff_flag))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
 
     if(!u1_frm)
     {
         u2_pic_ht <<= 1;
         ps_seq->u1_mb_aff_flag = u1_mb_aff_flag;
         COPYTHECONTEXT("SPS: mb_adaptive_frame_field_flag", ps_seq->u1_mb_aff_flag);
     }
     else
         ps_seq->u1_mb_aff_flag = 0;
 
     ps_seq->u1_direct_8x8_inference_flag = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("SPS: direct_8x8_inference_flag", ps_seq->u1_direct_8x8_inference_flag);
 
     /* G050 */
     u1_frame_cropping_flag = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("SPS: frame_cropping_flag", u1_frame_cropping_flag);
 
     if(u1_frame_cropping_flag)
     {
         u1_frame_cropping_rect_left_ofst = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: frame_cropping_rect_left_offset", u1_frame_cropping_rect_left_ofst);
         u1_frame_cropping_rect_right_ofst = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: frame_cropping_rect_right_offset", u1_frame_cropping_rect_right_ofst);
         u1_frame_cropping_rect_top_ofst = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: frame_cropping_rect_top_offset", u1_frame_cropping_rect_top_ofst);
         u1_frame_cropping_rect_bottom_ofst = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: frame_cropping_rect_bottom_offset",
                        u1_frame_cropping_rect_bottom_ofst);
     }
     /* G050 */
     ps_seq->u1_vui_parameters_present_flag = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("SPS: vui_parameters_present_flag", ps_seq->u1_vui_parameters_present_flag);
 
     u2_frm_wd_y = u2_pic_wd + (UWORD8) (PAD_LEN_Y_H << 1);
 
     if(1 == ps_dec->u4_share_disp_buf)
     {
         if(ps_dec->u4_app_disp_width > u2_frm_wd_y) u2_frm_wd_y = ps_dec->u4_app_disp_width;
     }
 
     u2_frm_ht_y = u2_pic_ht + (UWORD8) (PAD_LEN_Y_V << 2);
     u2_frm_wd_uv = u2_pic_wd + (UWORD8) (PAD_LEN_UV_H << 2);
     u2_frm_wd_uv = MAX(u2_frm_wd_uv, u2_frm_wd_y);
     u2_frm_ht_uv = (u2_pic_ht >> 1) + (UWORD8) (PAD_LEN_UV_V << 2);
     u2_frm_ht_uv = MAX(u2_frm_ht_uv, (u2_frm_ht_y >> 1));
 
     /* Calculate display picture width, height and start u4_ofst from YUV420 */
     /* pictute buffers as per cropping information parsed above             */
     {
         UWORD16 u2_rgt_ofst = 0;
         UWORD16 u2_lft_ofst = 0;
         UWORD16 u2_top_ofst = 0;
         UWORD16 u2_btm_ofst = 0;
         UWORD8 u1_frm_mbs_flag;
         UWORD8 u1_vert_mult_factor;
 
         if(u1_frame_cropping_flag)
         {
             /* Calculate right and left u4_ofst for cropped picture           */
             u2_rgt_ofst = u1_frame_cropping_rect_right_ofst << 1;
             u2_lft_ofst = u1_frame_cropping_rect_left_ofst << 1;
 
             /* Know frame MBs only u4_flag                                      */
             u1_frm_mbs_flag = (1 == ps_seq->u1_frame_mbs_only_flag);
 
             /* Simplify the vertical u4_ofst calculation from field/frame     */
             u1_vert_mult_factor = (2 - u1_frm_mbs_flag);
 
             /* Calculate bottom and top u4_ofst for cropped  picture          */
             u2_btm_ofst = (u1_frame_cropping_rect_bottom_ofst << u1_vert_mult_factor);
             u2_top_ofst = (u1_frame_cropping_rect_top_ofst << u1_vert_mult_factor);
         }
 
         /* Calculate u4_ofst from start of YUV 420 picture buffer to start of*/
         /* cropped picture buffer                                           */
         u2_crop_offset_y = (u2_frm_wd_y * u2_top_ofst) + (u2_lft_ofst);
         u2_crop_offset_uv =
             (u2_frm_wd_uv * (u2_top_ofst >> 1)) + (u2_lft_ofst >> 1) * YUV420SP_FACTOR;
         /* Calculate the display picture width and height based on crop      */
         /* information                                                       */
         i4_cropped_ht = (WORD32) u2_pic_ht - (WORD32) (u2_btm_ofst + u2_top_ofst);
         i4_cropped_wd = (WORD32) u2_pic_wd - (WORD32) (u2_rgt_ofst + u2_lft_ofst);
 
         if((i4_cropped_ht < MB_SIZE) || (i4_cropped_wd < MB_SIZE))
         {
             return ERROR_INV_SPS_PPS_T;
         }
 
         if((ps_dec->i4_header_decoded & 1) &&
            (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
            (ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id].u2_pic_wd != u2_pic_wd))
         {
             ps_dec->u1_res_changed = 1;
             return IVD_RES_CHANGED;
         }
 
         if((ps_dec->i4_header_decoded & 1) &&
            (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
            (ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id].u2_disp_width != i4_cropped_wd))
         {
             ps_dec->u1_res_changed = 1;
             return IVD_RES_CHANGED;
         }
 
         if((ps_dec->i4_header_decoded & 1) &&
            (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
            (ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id].u2_pic_ht != u2_pic_ht))
         {
             ps_dec->u1_res_changed = 1;
             return IVD_RES_CHANGED;
         }
 
         if((ps_dec->i4_header_decoded & 1) &&
            (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
            (ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id].u2_disp_height != i4_cropped_ht))
         {
             ps_dec->u1_res_changed = 1;
             return IVD_RES_CHANGED;
         }
         /* Check again for unsupported resolutions with updated values*/
         if((u2_pic_wd > SVCD_MAX_FRAME_WIDTH) || (u2_pic_ht > SVCD_MAX_FRAME_HEIGHT) ||
            (u2_pic_wd < SVCD_MIN_FRAME_WIDTH) || (u2_pic_ht < SVCD_MIN_FRAME_HEIGHT) ||
            (u2_pic_wd * (UWORD32) u2_pic_ht > SVCD_MAX_FRAME_SIZE))
         {
             return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
         }
 
         /* If MBAff is enabled, decoder support is limited to streams with
          * width less than half of H264_MAX_FRAME_WIDTH.
          * In case of MBAff decoder processes two rows at a time
          */
         if((u2_pic_wd << ps_seq->u1_mb_aff_flag) > H264_MAX_FRAME_WIDTH)
         {
             return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
         }
     }
 
     /* Backup num_reorder_frames if header is already decoded */
     if((ps_dec->i4_header_decoded & 1) && (1 == ps_seq->u1_vui_parameters_present_flag) &&
        (1 == ps_seq->s_vui.u1_bitstream_restriction_flag))
     {
         num_reorder_frames = (WORD32) ps_seq->s_vui.u4_num_reorder_frames;
     }
     else
     {
         num_reorder_frames = -1;
     }
     if(1 == ps_seq->u1_vui_parameters_present_flag)
     {
         ret = ih264d_parse_vui_parametres(&ps_seq->s_vui, ps_bitstrm);
         if(ret != OK) return ret;
     }
 
     /* Compare older num_reorder_frames with the new one if header is already
      * decoded */
     if((ps_dec->i4_header_decoded & 1) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) && (-1 != num_reorder_frames) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_vui_parameters_present_flag) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].s_vui.u1_bitstream_restriction_flag) &&
        ((WORD32) ps_dec->ps_sps[u1_seq_parameter_set_id].s_vui.u4_num_reorder_frames !=
         num_reorder_frames))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
 
     /* In case bitstream read has exceeded the filled size, then return an error */
     if(EXCEED_OFFSET(ps_bitstrm))
     {
         return ERROR_INV_SPS_PPS_T;
     }
 
     /*--------------------------------------------------------------------*/
     /* All initializations to ps_dec are beyond this point                */
     /*--------------------------------------------------------------------*/
     {
         WORD32 reorder_depth = ih264d_get_dpb_size(ps_seq);
         if((1 == ps_seq->u1_vui_parameters_present_flag) &&
            (1 == ps_seq->s_vui.u1_bitstream_restriction_flag))
         {
             reorder_depth = ps_seq->s_vui.u4_num_reorder_frames + 1;
         }
 
         if(reorder_depth > H264_MAX_REF_PICS)
         {
             return ERROR_INV_SPS_PPS_T;
         }
 
         if(ps_seq->u1_frame_mbs_only_flag != 1) reorder_depth *= 2;
         ps_subset_seq->i4_reorder_depth = reorder_depth + DISPLAY_LATENCY;
     }
     ps_subset_seq->u2_disp_height = i4_cropped_ht;
     ps_subset_seq->u2_disp_width = i4_cropped_wd;
     ps_subset_seq->u2_pic_wd = u2_pic_wd;
     ps_subset_seq->u2_pic_ht = u2_pic_ht;
 
     /* Determining the Width and Height of Frame from that of Picture */
     ps_subset_seq->u2_frm_wd_y = u2_frm_wd_y;
     ps_subset_seq->u2_frm_ht_y = u2_frm_ht_y;
     ps_subset_seq->u2_frm_wd_uv = u2_frm_wd_uv;
     ps_subset_seq->u2_frm_ht_uv = u2_frm_ht_uv;
 
     ps_subset_seq->u1_pad_len_y_v = (UWORD8) (PAD_LEN_Y_V << (1 - u1_frm));
     ps_subset_seq->u1_pad_len_cr_v = (UWORD8) (PAD_LEN_UV_V << (1 - u1_frm));
 
     ps_subset_seq->u2_crop_offset_y = u2_crop_offset_y;
     ps_subset_seq->u2_crop_offset_uv = u2_crop_offset_uv;
 
-    if(((ps_dec->u2_pic_wd * ps_dec->u2_pic_ht) <
-        (ps_subset_seq->u2_pic_wd * ps_subset_seq->u2_pic_ht)) ||
-       (ps_dec->i4_reorder_depth < ps_subset_seq->i4_reorder_depth))
-    {
-        ps_dec->i4_reorder_depth = ps_subset_seq->i4_reorder_depth;
-
-        ps_dec->u2_disp_height = ps_subset_seq->u2_disp_height;
-        ps_dec->u2_disp_width = ps_subset_seq->u2_disp_width;
-        ps_dec->u2_pic_wd = ps_subset_seq->u2_pic_wd;
-        ps_dec->u2_pic_ht = ps_subset_seq->u2_pic_ht;
-        ps_dec->u4_total_mbs = ps_seq->u2_total_num_of_mbs << (1 - ps_seq->u1_frame_mbs_only_flag);
-
-        /* Determining the Width and Height of Frame from that of Picture */
-        ps_dec->u2_frm_wd_y = ps_subset_seq->u2_frm_wd_y;
-        ps_dec->u2_frm_ht_y = ps_subset_seq->u2_frm_ht_y;
-        ps_dec->u2_frm_wd_uv = ps_subset_seq->u2_frm_wd_uv;
-        ps_dec->u2_frm_ht_uv = ps_subset_seq->u2_frm_ht_uv;
-
-        ps_dec->s_pad_mgr.u1_pad_len_y_v = ps_subset_seq->u1_pad_len_y_v;
-        ps_dec->s_pad_mgr.u1_pad_len_cr_v = ps_subset_seq->u1_pad_len_cr_v;
-
-        ps_dec->u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs;
-        ps_dec->u2_frm_ht_in_mbs = ps_seq->u2_frm_ht_in_mbs;
-        ps_dec->u2_crop_offset_y = ps_subset_seq->u2_crop_offset_y;
-        ps_dec->u2_crop_offset_uv = ps_subset_seq->u2_crop_offset_uv;
-    }
-
     ps_seq->u1_is_valid = TRUE;
     ps_dec->ps_sps[u1_seq_parameter_set_id] = *ps_seq;
     ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id] = *ps_subset_seq;
-    ps_dec->ps_cur_sps = &ps_dec->ps_sps[u1_seq_parameter_set_id];
     ps_svc_lyr_dec->ps_cur_subset_sps = &ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id];
 
     return OK;
 }
 
 /*!
 **************************************************************************
 * \if Function name : isvcd_parse_pps \endif
 *
 * \brief
 *    Decodes Picture Parameter set
 *
 * \return
 *    0 on Success and Error code otherwise
 **************************************************************************
 */
diff --git a/decoder/svc/isvcd_structs.h b/decoder/svc/isvcd_structs.h
index fefd32d..85f1295 100644
--- a/decoder/svc/isvcd_structs.h
+++ b/decoder/svc/isvcd_structs.h
@@ -438,288 +438,292 @@ typedef struct
 typedef struct _SvcDecLyrStruct
 {
     dec_struct_t s_dec;
 
     /*Pred + Res = Target when csbp is zero*/
     ih264_pred_residual_recon_ft *pf_pred_residual_recon_luma_4x4;
 
     ih264_pred_residual_recon_ft *pf_pred_residual_recon_luma_8x8;
 
     ih264_pred_residual_recon_ft *pf_pred_residual_recon_luma_16x16;
 
     ih264_pred_residual_recon_chroma_ft *pf_pred_residual_recon_chroma_4x4;
 
     ih264_pred_residual_recon_chroma_ft *pf_pred_residual_recon_chroma_8x8;
 
     /* IT + Res + Recon*/
     ih264_iquant_itrans_residual_recon_ft *pf_iquant_itrans_residual_recon_luma_4x4;
 
     ih264_iquant_itrans_residual_recon_ft *pf_iquant_itrans_residual_recon_luma_4x4_dc;
 
     ih264_iquant_itrans_residual_recon_ft *pf_iquant_itrans_residual_recon_luma_8x8;
 
     ih264_iquant_itrans_residual_recon_ft *pf_iquant_itrans_residual_recon_luma_8x8_dc;
 
     ih264_iquant_itrans_residual_recon_chroma_ft *pf_iquant_itrans_residual_recon_chroma_4x4;
 
     ih264_iquant_itrans_residual_recon_chroma_ft *pf_iquant_itrans_residual_recon_chroma_4x4_dc;
 
     /* Res nnz*/
     ih264_residual_ft *pf_residual_luma_4x4;
     ih264_residual_ft *pf_residual_luma_8x8;
     ih264_residual_ft *pf_residual_luma_16x16;
 
     ih264_residual_chroma_ft *pf_residual_chroma_cb_cr_8x8;
 
     /*IT + residual */
     ih264_iquant_itrans_residual_ft *pf_iquant_itrans_residual_luma_4x4;
 
     ih264_iquant_itrans_residual_ft *pf_iquant_itrans_residual_luma_4x4_dc;
 
     ih264_iquant_itrans_residual_ft *pf_iquant_itrans_residual_luma_8x8;
 
     ih264_iquant_itrans_residual_ft *pf_iquant_itrans_residual_luma_8x8_dc;
 
     ih264_iquant_itrans_residual_chroma_ft *pf_iquant_itrans_residual_chroma_4x4;
 
     ih264_iquant_itrans_residual_chroma_ft *pf_iquant_itrans_residual_chroma_4x4_dc;
 
     /* IT */
     ih264_iquant_itrans_ft *pf_iquant_itrans_luma_4x4;
 
     ih264_iquant_itrans_ft *pf_iquant_itrans_luma_4x4_dc;
 
     ih264_iquant_itrans_ft *pf_iquant_itrans_luma_8x8;
 
     ih264_iquant_itrans_ft *pf_iquant_itrans_luma_8x8_dc;
 
     ih264_iquant_itrans_chroma_ft *pf_iquant_itrans_chroma_4x4;
 
     ih264_iquant_itrans_chroma_ft *pf_iquant_itrans_chroma_4x4_dc;
 
     /**
      *SVC extension parsing strcture place holders
      */
     dec_nal_unit_svc_ext_params_t *ps_nal_svc_ext;
     dec_prefix_nal_unit_svc_ext_params_t s_pre_nal_unit_svc_ext;
     dec_svc_crop_wnd_offset_t *ps_crop_wnd_offset;
     UWORD8 *apu1_crop_wnd_flag[MAX_DEP_LYRS_IN_RES];
 
     /**
      *contexts for the CABAC related parsing
      */
     bin_ctxt_model_t *ps_base_mode_flag;
     bin_ctxt_model_t *ps_motion_prediction_flag_l0;
     bin_ctxt_model_t *ps_motion_prediction_flag_l1;
     bin_ctxt_model_t *ps_residual_prediction_flag;
 
     /**
      * Function pointers to read Params common to CAVLC and CABAC
      */
     WORD32(*pf_parse_inter_mb_svc_ext)
     (struct _SvcDecLyrStruct *ps_dec, dec_mb_info_t *ps_cur_mb_info,
      dec_svc_mb_info_t *ps_svc_cur_mb_info, UWORD8 u1_mb_num, UWORD8 u1_num_mbsNby2);
 
     WORD32(*pf_parse_inter_slice_svc_ext)
     (struct _SvcDecLyrStruct *ps_dec, dec_slice_params_t *ps_slice, UWORD16 u2_first_mb_in_slice);
 
     /**
      * Function pointers to parse inter slice data
      */
 
     WORD32(*pf_parse_svc_inter_slice)
     (struct _SvcDecLyrStruct *ps_dec, dec_slice_params_t *ps_slice, UWORD16 u2_first_mb_in_slice);
 
     /* inter layer precition buffers */
 
     /* 4x4 level */
     mv_pred_t *ps_il_pred_mv_bank_buf_base;
 
     /* 16x16 level */
     inter_lyr_mb_prms_t *ps_inter_lyr_mb_prms_base;
     inter_lyr_mb_prms_t *ps_inter_lyr_mb_prms_frm_start;
     inter_lyr_mb_prms_t *ps_inter_lyr_mb_prms_cur_mb;
     UWORD16 u2_inter_lyr_mb_prms_stride;
     UWORD32 u4_inter_lyr_mb_prms_size; /* in Bytes */
 
     /* full frame size : -255 -255 */
     WORD16 *pi2_il_residual_resample_luma_base;
     WORD16 *pi2_il_residual_resample_chroma_base;
     WORD16 *pi2_il_residual_resample_mb_luma_frm_start;
     WORD16 *pi2_il_residual_resample_mb_chroma_frm_start;
 
     UWORD16 u2_residual_resample_luma_stride;
     UWORD16 u2_residual_resample_chroma_stride;
     UWORD32 u4_residual_resample_luma_size;   /* in Bytes */
     UWORD32 u4_residual_resample_chroma_size; /* in Bytes */
 
     mv_pred_t *ps_il_pred_mv_bank_buf_cur_mb;
 
     UWORD8 *pu1_crop_wnd_flag;
     /*
      * Layer info flag - Base layer; Intermediate Enhancement Layers; Target
      * Enhacement Layer.
      */
     UWORD8 u1_layer_identifier;
     /* layer id of the current layer */
     UWORD8 u1_layer_id;
     /* flag to indicate if spatial layers are dyadic */
     UWORD8 u1_dyadic_flag;
     /* flag to indicate if current layer is base layer */
     UWORD8 u1_base_res_flag;
     /* reference layer for inter layer prediction, no quality layers */
     UWORD8 u1_ref_layer_id;
 
     UWORD8 u1_restricted_res_change_flag;
 
     res_prms_t s_res_prms;
 
     void *pv_ref_lyr_offset;
     void *pv_mode_mv_sample_ctxt;
     void *pv_ii_pred_ctxt;
     void *pv_residual_sample_ctxt;
 
     void *pv_intra_sample_ctxt;
     /*!< projected locations buffer pointer exported by Intra Upsampling module
     for luma this buffer contains the projected offsets and window width in
     reference layer for each MB (in horizontal direction) of current resolution
     layer.*/
     ref_mb_map_t *ps_intsam_luma_map_horz;
 
     /*!< projected locations buffer pointer exported by Intra Upsampling module
       for chroma this buffer contains the projected offsets and window width in
       reference layer
       for each MB (in horizontal direction) of current resolution layer.*/
     ref_mb_map_t *ps_intsam_chroma_map_horz;
 
     /*!< projected locations  buffer pointer exported by Intra Upsampling module
        for luma this buffer contains the projected offsets and window width in
        reference layer for each MB (in vertical direction) of current resolution
        layer. */
     ref_mb_map_t *ps_intsam_luma_map_vert;
 
     /*!<  projected locations buffer pointer exported by Intra Upsampling module
        for chroma this buffer contains the projected offsets and window width in
        reference layer for each MB (in vertical direction) of current resolution
        layer.  */
     ref_mb_map_t *ps_intsam_chroma_map_vert;
 
     /*!< projected locations buffer pointer exported by Residual Upsampling module
     for luma. this buffer contains the projected offsets and window width in
     reference layer for each MB (in horizontal direction) of current resolution
     layer. */
     ref_mb_map_t *ps_ressam_luma_map_horz;
 
     /*!< projected locations buffer pointer exported by Residual Upsampling module
         for chroma. this buffer contains the projected offsets and window width in
        reference layer
         for each MB (in horizontal direction) of current resolution layer. */
     ref_mb_map_t *ps_ressam_chroma_map_horz;
 
     /*!< projected locationscbuffer pointercexported by Residual Upsampling
     modulec for chroma. this buffer contains the projected offsets and window
     width in reference layer for each MB (in vertical direction) ofv    current
     resolution layer. */
     ref_mb_map_t *ps_ressam_luma_map_vert;
 
     /*!< projected locationscbuffer pointerccexported by Residual Upsampling
     module for chroma.cthis buffer contains the projected offsets and window width
     in reference layer for each MB (in vertical direction) of current resolution
     layer.*/
     ref_mb_map_t *ps_ressam_chroma_map_vert;
 
     /* pointer to decoder layer referered by current layer */
     void *ps_dec_svc_ref_layer;
     /* pointer to master context */
     void *ps_svcd_ctxt;
 
     UWORD8 u1_inter_lyr_disable_dblk_filter_idc;
     WORD8 i1_inter_lyr_slice_alpha_c0_offset;
     WORD8 i1_inter_lyr_slice_beta_offset;
 
     UWORD8 *pu1_ii_resamp_buffer_luma;
     UWORD8 *pu1_ii_resamp_buffer_chroma;
 
     dec_slice_svc_ext_params_t s_svc_slice_params;
     dec_svc_seq_params_t *ps_subset_sps;
     dec_svc_seq_params_t *ps_cur_subset_sps;
     void *pv_scratch_subset_sps;
 
     /* Variables Required for N MB design */
     dec_svc_mb_info_t *ps_svc_nmb_info;
 
     dec_svc_mb_info_t *ps_svc_frm_mb_info;
 
     void (*pf_svc_compute_bs)(struct _SvcDecLyrStruct *ps_svc_lyr_dec,
                               struct _DecMbInfo *ps_cur_mb_info, const UWORD16 u2_mbxn_mb);
 
     UWORD16 *pu2_frm_res_luma_csbp;
     WORD32 i4_frm_res_luma_csbp_stride;
 
     UWORD8 *pu1_svc_base_mode_flag;
     WORD32 i4_frm_svc_base_mode_cabac_stride;
     WORD32 i4_frm_svc_base_mode_cabac_size;
     UWORD32 u4_pps_id_for_layer;
     UWORD8 u1_error_in_cur_frame;
     UWORD8 u1_res_init_done;
+    WORD32 pic_width;
+    WORD32 pic_height;
 } svc_dec_lyr_struct_t;
 
 typedef struct
 {
     /* common parameters for all layers in SVC */
     UWORD32 u4_num_cores;
     IVD_ARCH_T e_processor_arch;
     IVD_SOC_T e_processor_soc;
     UWORD8 u1_target_layer_id;
     UWORD8 u1_cur_layer_id;
 
     /* dcode context for all layers in SVC */
     svc_dec_lyr_struct_t *ps_svc_dec_lyr;
 
     dec_pic_params_t *ps_pps;
     dec_seq_params_t *ps_sps;
     dec_svc_seq_params_t *ps_subset_sps;
     struct _sei *ps_sei;
     struct _sei *ps_sei_parse;
 
     /* attributes related to set tgt layer api func */
     WORD32 u1_tgt_dep_id;
     WORD32 u1_tgt_quality_id;
     WORD32 u1_tgt_temp_id;
     WORD32 u1_tgt_priority_id;
 
     ref_lyr_scaled_offset_t as_ref_lyr_offsets[MAX_NUM_RES_LYRS];
 
     void *pv_ref_lyr_offset;
     void *pv_mode_mv_sample_ctxt;
     void *pv_ii_pred_ctxt;
     void *pv_residual_sample_ctxt;
     void *pv_intra_sample_ctxt;
 
     void *pv_nal_parse_ctxt;
     non_vcl_nal_t s_non_vcl_nal; /*!< NON VCL nal structure */
     vcl_nal_t s_vcl_nal;         /*!< VCL nal structure */
 
     /*!< array to store the Did of bottom most layer in each resolution */
     WORD32 ai4_dq_id_map[MAX_NUM_RES_LYRS];
     WORD32 i4_error_code;
     void *pv_vcl_nal_buff;
     void *pv_non_vcl_nal_buff;
 
     /*!< array of structure to store the reference layer DQID,
     poc syntax and frame num, for each depedency id
     present in an access unit this will be used as reference
     for the next access unit */
     prev_au_prms_t as_au_prms_dep[MAX_DEPENDENCY_LYRS];
     /*!< array to store the pps id for each layer in a resolution */
     prev_au_sps_pps_t as_pps_sps_prev_au[MAX_TOTAL_LYRS];
 
     WORD32 i4_eos_flag;
     UWORD8 u1_prev_num_res_layers;
     UWORD32 u4_num_sps_ctr;
     UWORD32 u4_num_pps_ctr;
     UWORD8 u1_parse_nal_unit_error;
     UWORD8 u1_exit_till_next_IDR;
     UWORD8 u1_pre_parse_in_flush;
+    WORD32 pic_width;
+    WORD32 pic_height;
 } svc_dec_ctxt_t;
 
 #endif /*_ISVCD_STRUCTS_H_*/
\ No newline at end of file
