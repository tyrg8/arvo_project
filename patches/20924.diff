commit 61208401f41f5d41f32d436cee500c630706f6be
Author: Ebrahim Byagowi <ebrahim@gnu.org>
Date:   Fri Feb 28 21:09:07 2020 +0330

    [gvar] Use hb_bytes_t.check_range instead having in house one
    
    And use TupleVarHeader calculated size for validity check.
    
    Fixes https://crbug.com/oss-fuzz/20919 and possibly other gvar related issues

diff --git a/src/hb-ot-var-gvar-table.hh b/src/hb-ot-var-gvar-table.hh
index 35dbc5faf..e8f24a135 100644
--- a/src/hb-ot-var-gvar-table.hh
+++ b/src/hb-ot-var-gvar-table.hh
@@ -199,183 +199,176 @@ struct TupleVarCount : HBUINT16
 struct GlyphVarData
 {
   const TupleVarHeader &get_tuple_var_header (void) const
   { return StructAfter<TupleVarHeader> (data); }
 
   struct tuple_iterator_t
   {
-    void init (const GlyphVarData *var_data_, unsigned int length_, unsigned int axis_count_)
+    void init (hb_bytes_t var_data_bytes_, unsigned int axis_count_)
     {
-      var_data = var_data_;
-      length = length_;
+      var_data_bytes = var_data_bytes_;
+      var_data = var_data_bytes_.as<GlyphVarData> ();
       index = 0;
       axis_count = axis_count_;
       current_tuple = &var_data->get_tuple_var_header ();
       data_offset = 0;
     }
 
     bool get_shared_indices (hb_vector_t<unsigned int> &shared_indices /* OUT */)
     {
       if (var_data->has_shared_point_numbers ())
       {
-	hb_bytes_t bytes ((const char *) var_data, length);
 	const HBUINT8 *base = &(var_data+var_data->data);
 	const HBUINT8 *p = base;
-	if (!unpack_points (p, shared_indices, bytes)) return false;
+	if (!unpack_points (p, shared_indices, var_data_bytes)) return false;
 	data_offset = p - base;
       }
       return true;
     }
 
     bool is_valid () const
     {
       return (index < var_data->tupleVarCount.get_count ()) &&
-	     in_range (current_tuple) &&
+	     var_data_bytes.check_range (current_tuple, TupleVarHeader::min_size) &&
+	     var_data_bytes.check_range (current_tuple, current_tuple->get_data_size ()) &&
 	     current_tuple->get_size (axis_count);
     }
 
     bool move_to_next ()
     {
       data_offset += current_tuple->get_data_size ();
       current_tuple = &current_tuple->get_next (axis_count);
       index++;
       return is_valid ();
     }
 
-    bool in_range (const void *p, unsigned int l) const
-    { return (const char*) p >= (const char*) var_data && (const char*) p+l <= (const char*) var_data + length; }
-
-    template <typename T> bool in_range (const T *p) const { return in_range (p, sizeof (*p)); }
-
     const HBUINT8 *get_serialized_data () const
     { return &(var_data+var_data->data) + data_offset; }
 
     private:
     const GlyphVarData *var_data;
-    unsigned int length;
     unsigned int index;
     unsigned int axis_count;
     unsigned int data_offset;
 
     public:
+    hb_bytes_t var_data_bytes;
     const TupleVarHeader *current_tuple;
   };
 
-  static bool get_tuple_iterator (const GlyphVarData *var_data,
-				  unsigned int length,
-				  unsigned int axis_count,
+  static bool get_tuple_iterator (hb_bytes_t var_data_bytes, unsigned axis_count,
 				  hb_vector_t<unsigned int> &shared_indices /* OUT */,
 				  tuple_iterator_t *iterator /* OUT */)
   {
-    iterator->init (var_data, length, axis_count);
+    iterator->init (var_data_bytes, axis_count);
     if (!iterator->get_shared_indices (shared_indices))
       return false;
     return iterator->is_valid ();
   }
 
   bool has_shared_point_numbers () const { return tupleVarCount.has_shared_point_numbers (); }
 
   static bool unpack_points (const HBUINT8 *&p /* IN/OUT */,
 			     hb_vector_t<unsigned int> &points /* OUT */,
 			     const hb_bytes_t &bytes)
   {
     enum packed_point_flag_t
     {
       POINTS_ARE_WORDS     = 0x80,
       POINT_RUN_COUNT_MASK = 0x7F
     };
 
     if (unlikely (!bytes.check_range (p))) return false;
 
     uint16_t count = *p++;
     if (count & POINTS_ARE_WORDS)
     {
       if (unlikely (!bytes.check_range (p))) return false;
       count = ((count & POINT_RUN_COUNT_MASK) << 8) | *p++;
     }
     points.resize (count);
 
     unsigned int n = 0;
     uint16_t i = 0;
     while (i < count)
     {
       if (unlikely (!bytes.check_range (p))) return false;
       uint16_t j;
       uint8_t control = *p++;
       uint16_t run_count = (control & POINT_RUN_COUNT_MASK) + 1;
       if (control & POINTS_ARE_WORDS)
       {
 	for (j = 0; j < run_count && i < count; j++, i++)
 	{
 	  if (unlikely (!bytes.check_range ((const HBUINT16 *) p)))
 	    return false;
 	  n += *(const HBUINT16 *)p;
 	  points[i] = n;
 	  p += HBUINT16::static_size;
 	}
       }
       else
       {
 	for (j = 0; j < run_count && i < count; j++, i++)
 	{
 	  if (unlikely (!bytes.check_range (p))) return false;
 	  n += *p++;
 	  points[i] = n;
 	}
       }
       if (j < run_count) return false;
     }
     return true;
   }
 
   static bool unpack_deltas (const HBUINT8 *&p /* IN/OUT */,
 			     hb_vector_t<int> &deltas /* IN/OUT */,
 			     const hb_bytes_t &bytes)
   {
     enum packed_delta_flag_t
     {
       DELTAS_ARE_ZERO      = 0x80,
       DELTAS_ARE_WORDS     = 0x40,
       DELTA_RUN_COUNT_MASK = 0x3F
     };
 
     unsigned int i = 0;
     unsigned int count = deltas.length;
     while (i < count)
     {
       if (unlikely (!bytes.check_range (p))) return false;
       uint8_t control = *p++;
       unsigned int run_count = (control & DELTA_RUN_COUNT_MASK) + 1;
       unsigned int j;
       if (control & DELTAS_ARE_ZERO)
 	for (j = 0; j < run_count && i < count; j++, i++)
 	  deltas[i] = 0;
       else if (control & DELTAS_ARE_WORDS)
 	for (j = 0; j < run_count && i < count; j++, i++)
 	{
 	  if (unlikely (!bytes.check_range ((const HBUINT16 *) p)))
 	    return false;
 	  deltas[i] = *(const HBINT16 *) p;
 	  p += HBUINT16::static_size;
 	}
       else
 	for (j = 0; j < run_count && i < count; j++, i++)
 	{
 	  if (unlikely (!bytes.check_range (p)))
 	    return false;
 	  deltas[i] = *(const HBINT8 *) p++;
 	}
       if (j < run_count)
 	return false;
     }
     return true;
   }
 
   bool has_data () const { return tupleVarCount; }
 
   protected:
   TupleVarCount		tupleVarCount;
   OffsetTo<HBUINT8>	data;
   /* TupleVarHeader tupleVarHeaders[] */
   public:
   DEFINE_SIZE_MIN (4);
 };
@@ -383,307 +376,304 @@ struct GlyphVarData
 struct gvar
 {
   static constexpr hb_tag_t tableTag = HB_OT_TAG_gvar;
 
   bool sanitize_shallow (hb_sanitize_context_t *c) const
   {
     TRACE_SANITIZE (this);
     return_trace (c->check_struct (this) && (version.major == 1) &&
 		  (glyphCount == c->get_num_glyphs ()) &&
 		  c->check_array (&(this+sharedTuples), axisCount * sharedTupleCount) &&
 		  (is_long_offset () ?
 		     c->check_array (get_long_offset_array (), glyphCount+1) :
 		     c->check_array (get_short_offset_array (), glyphCount+1)) &&
 		  c->check_array (((const HBUINT8*)&(this+dataZ)) + get_offset (0),
 				  get_offset (glyphCount) - get_offset (0)));
   }
 
   /* GlyphVarData not sanitized here; must be checked while accessing each glyph varation data */
   bool sanitize (hb_sanitize_context_t *c) const
   { return sanitize_shallow (c); }
 
   bool subset (hb_subset_context_t *c) const
   {
     TRACE_SUBSET (this);
 
     gvar *out = c->serializer->allocate_min<gvar> ();
     if (unlikely (!out)) return_trace (false);
 
     out->version.major = 1;
     out->version.minor = 0;
     out->axisCount = axisCount;
     out->sharedTupleCount = sharedTupleCount;
 
     unsigned int num_glyphs = c->plan->num_output_glyphs ();
     out->glyphCount = num_glyphs;
 
     hb_blob_ptr_t<gvar> table = hb_sanitize_context_t ().reference_table<gvar> (c->plan->source);
 
     unsigned int subset_data_size = 0;
     for (hb_codepoint_t gid = 0; gid < num_glyphs; gid++)
     {
       hb_codepoint_t old_gid;
       if (!c->plan->old_gid_for_new_gid (gid, &old_gid)) continue;
       subset_data_size += get_glyph_var_data_bytes (table.get_blob (), old_gid).length;
     }
 
     bool long_offset = subset_data_size & ~0xFFFFu;
     out->flags = long_offset ? 1 : 0;
 
     HBUINT8 *subset_offsets = c->serializer->allocate_size<HBUINT8> ((long_offset ? 4 : 2) * (num_glyphs + 1));
     if (!subset_offsets)
     {
       table.destroy ();
       return_trace (false);
     }
 
     /* shared tuples */
     if (!sharedTupleCount || !sharedTuples)
       out->sharedTuples = 0;
     else
     {
       unsigned int shared_tuple_size = F2DOT14::static_size * axisCount * sharedTupleCount;
       F2DOT14 *tuples = c->serializer->allocate_size<F2DOT14> (shared_tuple_size);
       if (!tuples)
       {
 	table.destroy ();
 	return_trace (false);
       }
       out->sharedTuples = (char *) tuples - (char *) out;
       memcpy (tuples, &(this+sharedTuples), shared_tuple_size);
     }
 
     char *subset_data = c->serializer->allocate_size<char> (subset_data_size);
     if (!subset_data)
     {
       table.destroy ();
       return_trace (false);
     }
     out->dataZ = subset_data - (char *)out;
 
     unsigned int glyph_offset = 0;
     for (hb_codepoint_t gid = 0; gid < num_glyphs; gid++)
     {
       hb_codepoint_t old_gid;
       hb_bytes_t var_data_bytes = c->plan->old_gid_for_new_gid (gid, &old_gid)
 				? get_glyph_var_data_bytes (table.get_blob (), old_gid)
 				: hb_bytes_t ();
 
       if (long_offset)
 	((HBUINT32 *) subset_offsets)[gid] = glyph_offset;
       else
 	((HBUINT16 *) subset_offsets)[gid] = glyph_offset / 2;
 
       if (var_data_bytes.length > 0)
 	memcpy (subset_data, var_data_bytes.arrayZ, var_data_bytes.length);
       subset_data += var_data_bytes.length;
       glyph_offset += var_data_bytes.length;
     }
     if (long_offset)
       ((HBUINT32 *) subset_offsets)[num_glyphs] = glyph_offset;
     else
       ((HBUINT16 *) subset_offsets)[num_glyphs] = glyph_offset / 2;
 
     table.destroy ();
     return_trace (true);
   }
 
   protected:
   const hb_bytes_t get_glyph_var_data_bytes (hb_blob_t *blob, hb_codepoint_t glyph) const
   {
     unsigned start_offset = get_offset (glyph);
     unsigned length = get_offset (glyph+1) - start_offset;
     hb_bytes_t var_data = blob->as_bytes ().sub_array (((unsigned) dataZ) + start_offset, length);
     return likely (var_data.length >= GlyphVarData::min_size) ? var_data : hb_bytes_t ();
   }
 
   bool is_long_offset () const { return (flags & 1) != 0; }
 
   unsigned int get_offset (unsigned int i) const
   {
     if (is_long_offset ())
       return get_long_offset_array ()[i];
     else
       return get_short_offset_array ()[i] * 2;
   }
 
   const HBUINT32 * get_long_offset_array () const { return (const HBUINT32 *) &offsetZ; }
   const HBUINT16 *get_short_offset_array () const { return (const HBUINT16 *) &offsetZ; }
 
   public:
   struct accelerator_t
   {
     void init (hb_face_t *face)
     {
       gvar_table = hb_sanitize_context_t ().reference_table<gvar> (face);
       hb_blob_ptr_t<fvar> fvar_table = hb_sanitize_context_t ().reference_table<fvar> (face);
       unsigned int axis_count = fvar_table->get_axis_count ();
       fvar_table.destroy ();
 
       if (unlikely ((gvar_table->glyphCount != face->get_num_glyphs ()) ||
 		    (gvar_table->axisCount != axis_count)))
 	fini ();
 
       unsigned int num_shared_coord = gvar_table->sharedTupleCount * gvar_table->axisCount;
       shared_tuples.resize (num_shared_coord);
       for (unsigned int i = 0; i < num_shared_coord; i++)
 	shared_tuples[i] = (&(gvar_table + gvar_table->sharedTuples))[i];
     }
 
     void fini ()
     {
       gvar_table.destroy ();
       shared_tuples.fini ();
     }
 
     private:
     struct x_getter { static float get (const contour_point_t &p) { return p.x; } };
     struct y_getter { static float get (const contour_point_t &p) { return p.y; } };
 
     template <typename T>
     static float infer_delta (const hb_array_t<contour_point_t> points,
 			      const hb_array_t<contour_point_t> deltas,
 			      unsigned int target, unsigned int prev, unsigned int next)
     {
       float target_val = T::get (points[target]);
       float prev_val = T::get (points[prev]);
       float next_val = T::get (points[next]);
       float prev_delta = T::get (deltas[prev]);
       float next_delta = T::get (deltas[next]);
 
       if (prev_val == next_val)
 	return (prev_delta == next_delta) ? prev_delta : 0.f;
       else if (target_val <= hb_min (prev_val, next_val))
 	return (prev_val < next_val) ? prev_delta : next_delta;
       else if (target_val >= hb_max (prev_val, next_val))
 	return (prev_val > next_val) ? prev_delta : next_delta;
 
       /* linear interpolation */
       float r = (target_val - prev_val) / (next_val - prev_val);
       return (1.f - r) * prev_delta + r * next_delta;
     }
 
     static unsigned int next_index (unsigned int i, unsigned int start, unsigned int end)
     { return (i >= end) ? start : (i + 1); }
 
     public:
     bool apply_deltas_to_points (hb_codepoint_t glyph,
 				 const int *coords, unsigned int coord_count,
 				 const hb_array_t<contour_point_t> points) const
     {
       coord_count = hb_min (coord_count, gvar_table->axisCount);
       if (!coord_count || coord_count != gvar_table->axisCount) return true;
 
       hb_bytes_t var_data_bytes = gvar_table->get_glyph_var_data_bytes (gvar_table.get_blob (), glyph);
-      const GlyphVarData *var_data = var_data_bytes.as<GlyphVarData> ();
-      if (!var_data->has_data ()) return true;
+      if (!var_data_bytes.as<GlyphVarData> ()->has_data ()) return true;
       hb_vector_t<unsigned int> shared_indices;
       GlyphVarData::tuple_iterator_t iterator;
-      if (!GlyphVarData::get_tuple_iterator (var_data, var_data_bytes.length,
-					     gvar_table->axisCount,
-					     shared_indices,
-					     &iterator))
+      if (!GlyphVarData::get_tuple_iterator (var_data_bytes, gvar_table->axisCount,
+					     shared_indices, &iterator))
 	return true; /* so isn't applied at all */
 
       /* Save original points for inferred delta calculation */
       contour_point_vector_t orig_points;
       orig_points.resize (points.length);
       for (unsigned int i = 0; i < orig_points.length; i++)
 	orig_points[i] = points[i];
 
       contour_point_vector_t deltas; /* flag is used to indicate referenced point */
       deltas.resize (points.length);
 
       do
       {
 	float scalar = iterator.current_tuple->calculate_scalar (coords, coord_count, shared_tuples.as_array ());
 	if (scalar == 0.f) continue;
 	const HBUINT8 *p = iterator.get_serialized_data ();
 	unsigned int length = iterator.current_tuple->get_data_size ();
-	if (unlikely (!iterator.in_range (p, length)))
+	if (unlikely (!iterator.var_data_bytes.check_range (p, length)))
 	  return false;
 
 	hb_bytes_t bytes ((const char *) p, length);
 	hb_vector_t<unsigned int> private_indices;
 	if (iterator.current_tuple->has_private_points () &&
 	    !GlyphVarData::unpack_points (p, private_indices, bytes))
 	  return false;
 	const hb_array_t<unsigned int> &indices = private_indices.length ? private_indices : shared_indices;
 
 	bool apply_to_all = (indices.length == 0);
 	unsigned int num_deltas = apply_to_all ? points.length : indices.length;
 	hb_vector_t<int> x_deltas;
 	x_deltas.resize (num_deltas);
 	if (!GlyphVarData::unpack_deltas (p, x_deltas, bytes))
 	  return false;
 	hb_vector_t<int> y_deltas;
 	y_deltas.resize (num_deltas);
 	if (!GlyphVarData::unpack_deltas (p, y_deltas, bytes))
 	  return false;
 
 	for (unsigned int i = 0; i < deltas.length; i++)
 	  deltas[i].init ();
 	for (unsigned int i = 0; i < num_deltas; i++)
 	{
 	  unsigned int pt_index = apply_to_all ? i : indices[i];
 	  deltas[pt_index].flag = 1;	/* this point is referenced, i.e., explicit deltas specified */
 	  deltas[pt_index].x += x_deltas[i] * scalar;
 	  deltas[pt_index].y += y_deltas[i] * scalar;
 	}
 
 	/* find point before phantoms start which is an end point */
 	unsigned all_contours_end = points.length ? points.length - 1 : 0;
 	while (all_contours_end > 0)
 	{
 	  if (points[all_contours_end].is_end_point) break;
 	  --all_contours_end;
 	}
 
 	/* infer deltas for unreferenced points */
 	for (unsigned start_point = 0; start_point < all_contours_end; ++start_point)
 	{
 	  /* Check the number of unreferenced points in a contour. If no unref points or no ref points, nothing to do. */
 	  unsigned end_point = start_point;
 	  unsigned unref_count = 0;
 	  for (; end_point <= all_contours_end; ++end_point)
 	  {
 	    if (!deltas[end_point].flag)
 	      unref_count++;
 	    if (points[end_point].is_end_point)
 	      break;
 	  }
 
 	  unsigned j = start_point;
 	  if (unref_count == 0 || unref_count > end_point - start_point)
 	    goto no_more_gaps;
 
 	  for (;;)
 	  {
 	    /* Locate the next gap of unreferenced points between two referenced points prev and next.
 	     * Note that a gap may wrap around at left (start_point) and/or at right (end_point).
 	     */
 	    unsigned int prev, next, i;
 	    for (;;)
 	    {
 	      i = j;
 	      j = next_index (i, start_point, end_point);
 	      if (deltas[i].flag && !deltas[j].flag) break;
 	    }
 	    prev = j = i;
 	    for (;;)
 	    {
 	      i = j;
 	      j = next_index (i, start_point, end_point);
 	      if (!deltas[i].flag && deltas[j].flag) break;
 	    }
 	    next = j;
 	    /* Infer deltas for all unref points in the gap between prev and next */
 	    i = prev;
 	    for (;;)
 	    {
 	      i = next_index (i, start_point, end_point);
 	      if (i == next) break;
 	      deltas[i].x = infer_delta<x_getter> (orig_points.as_array (), deltas.as_array (), i, prev, next);
 	      deltas[i].y = infer_delta<y_getter> (orig_points.as_array (), deltas.as_array (), i, prev, next);
 	      if (--unref_count == 0) goto no_more_gaps;
 	    }
 	  }
diff --git a/test/fuzzing/fonts/clusterfuzz-testcase-minimized-hb-draw-fuzzer-5686960406659072 b/test/fuzzing/fonts/clusterfuzz-testcase-minimized-hb-draw-fuzzer-5686960406659072
new file mode 100644
index 000000000..f6e1461cb
Binary files /dev/null and b/test/fuzzing/fonts/clusterfuzz-testcase-minimized-hb-draw-fuzzer-5686960406659072 differ
