commit 226a9abf2235fd9e87353ffe727babad71fb7274
Author: emanuele-f <faranda@ntop.org>
Date:   Wed Dec 4 18:34:08 2019 +0100

    Additional memory bounds checks

diff --git a/src/lib/ndpi_main.c b/src/lib/ndpi_main.c
index 40bf9ae2..18173d55 100644
--- a/src/lib/ndpi_main.c
+++ b/src/lib/ndpi_main.c
@@ -4189,122 +4189,124 @@ u_int16_t ndpi_guess_host_protocol_id(struct ndpi_detection_module_struct *ndpi_
 ndpi_protocol ndpi_detection_giveup(struct ndpi_detection_module_struct *ndpi_str,
 				    struct ndpi_flow_struct *flow,
 				    u_int8_t enable_guess,
 				    u_int8_t *protocol_was_guessed) {
   ndpi_protocol ret = { NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED };
 
   *protocol_was_guessed = 0;
 
   if(flow == NULL)
     return(ret);
 
   /* Init defaults */
   ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];
   ret.category = flow->category;
 
   /* Ensure that we don't change our mind if detection is already complete */
   if((ret.master_protocol != NDPI_PROTOCOL_UNKNOWN) && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN))
     return(ret);
 
   /* TODO: add the remaining stage_XXXX protocols */
   if(flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {
     u_int16_t guessed_protocol_id = NDPI_PROTOCOL_UNKNOWN,
       guessed_host_protocol_id = NDPI_PROTOCOL_UNKNOWN;
 
     if(flow->guessed_protocol_id == NDPI_PROTOCOL_STUN)
       goto check_stun_export;
     else if((flow->guessed_protocol_id == NDPI_PROTOCOL_HANGOUT_DUO)
 	    || (flow->guessed_protocol_id == NDPI_PROTOCOL_MESSENGER)
 	    || (flow->guessed_protocol_id == NDPI_PROTOCOL_WHATSAPP_CALL))
       ndpi_set_detected_protocol(ndpi_str, flow, flow->guessed_protocol_id, NDPI_PROTOCOL_UNKNOWN);
     else if((flow->l4.tcp.tls_seen_client_cert == 1)
 	    && (flow->protos.stun_ssl.ssl.client_certificate[0] != '\0')) {
       ndpi_set_detected_protocol(ndpi_str, flow, NDPI_PROTOCOL_TLS, NDPI_PROTOCOL_UNKNOWN);
     } else {
       if((flow->guessed_protocol_id == NDPI_PROTOCOL_UNKNOWN)
 	 && (flow->packet.l4_protocol == IPPROTO_TCP)
 	 && (flow->l4.tcp.tls_stage > 1))
 	flow->guessed_protocol_id = NDPI_PROTOCOL_TLS;
 
       guessed_protocol_id = flow->guessed_protocol_id, guessed_host_protocol_id = flow->guessed_host_protocol_id;
 
       if((guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN)
 	 && ((flow->packet.l4_protocol == IPPROTO_UDP)
 	     && NDPI_ISSET(&flow->excluded_protocol_bitmask, guessed_host_protocol_id)
 	     && is_udp_guessable_protocol(guessed_host_protocol_id)
 	     ))
 	flow->guessed_host_protocol_id = guessed_host_protocol_id = NDPI_PROTOCOL_UNKNOWN;
 
       /* Ignore guessed protocol if they have been discarded */
       if((guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN)
 	 // && (guessed_host_protocol_id == NDPI_PROTOCOL_UNKNOWN)
 	 && (flow->packet.l4_protocol == IPPROTO_UDP)
 	 && NDPI_ISSET(&flow->excluded_protocol_bitmask, guessed_protocol_id)
 	 && is_udp_guessable_protocol(guessed_protocol_id))
 	flow->guessed_protocol_id = guessed_protocol_id = NDPI_PROTOCOL_UNKNOWN;
 
       if((guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN)
 	 || (guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN)) {
 	if((guessed_protocol_id == 0)
 	   && (flow->protos.stun_ssl.stun.num_binding_requests > 0)
 	   && (flow->protos.stun_ssl.stun.num_processed_pkts > 0))
 	  guessed_protocol_id = NDPI_PROTOCOL_STUN;
 
 	if(flow->host_server_name[0] != '\0') {
 	  ndpi_protocol_match_result ret_match;
 
+	  memset(&ret_match, 0, sizeof(ret_match));
+
 	  ndpi_match_host_subprotocol(ndpi_str, flow,
 				      (char *)flow->host_server_name,
 				      strlen((const char*)flow->host_server_name),
 				      &ret_match,
 				      NDPI_PROTOCOL_DNS);
 
 	  if(ret_match.protocol_id != NDPI_PROTOCOL_UNKNOWN)
 	    guessed_host_protocol_id = ret_match.protocol_id;
 	}
 
 	ndpi_int_change_protocol(ndpi_str, flow,
 				 guessed_host_protocol_id,
 				 guessed_protocol_id);
       }
     }
   } else {
     flow->detected_protocol_stack[1] = flow->guessed_protocol_id,
       flow->detected_protocol_stack[0] = flow->guessed_host_protocol_id;
 
     if(flow->detected_protocol_stack[1] == flow->detected_protocol_stack[0])
       flow->detected_protocol_stack[1] = flow->guessed_host_protocol_id;
   }
 
   if((flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN)
      && (flow->guessed_protocol_id == NDPI_PROTOCOL_STUN)) {
   check_stun_export:
     if(flow->protos.stun_ssl.stun.num_processed_pkts || flow->protos.stun_ssl.stun.num_udp_pkts) {
       // if(/* (flow->protos.stun_ssl.stun.num_processed_pkts >= NDPI_MIN_NUM_STUN_DETECTION) */
       ndpi_set_detected_protocol(ndpi_str, flow,
 				 flow->guessed_host_protocol_id,
 				 NDPI_PROTOCOL_STUN);
     }
   }
 
   ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];
 
   if(ret.master_protocol == NDPI_PROTOCOL_STUN) {
     if(ret.app_protocol == NDPI_PROTOCOL_FACEBOOK)
       ret.app_protocol = NDPI_PROTOCOL_MESSENGER;
     else if(ret.app_protocol == NDPI_PROTOCOL_GOOGLE) {
       /*
 	As Google has recently introduced Duo,
 	we need to distinguish between it and hangout
 	thing that should be handled by the STUN dissector
       */
       ret.app_protocol = NDPI_PROTOCOL_HANGOUT_DUO;
     }
   }
 
   if(ret.app_protocol != NDPI_PROTOCOL_UNKNOWN)
     ndpi_fill_protocol_category(ndpi_str, flow, &ret);
 
   return(ret);
 }
 
 /* ********************************************************************************* */
@@ -5077,242 +5079,242 @@ u_int32_t ndpi_bytestream_to_ipv4(const u_int8_t * str, u_int16_t max_chars_to_r
 /* internal function for every detection to parse one packet and to increase the info buffer */
 void ndpi_parse_packet_line_info(struct ndpi_detection_module_struct *ndpi_str,
 				 struct ndpi_flow_struct *flow)
 {
   u_int32_t a;
   struct ndpi_packet_struct *packet = &flow->packet;
 
   if(packet->packet_lines_parsed_complete != 0)
     return;
 
   packet->packet_lines_parsed_complete = 1;
   ndpi_reset_packet_line_info(packet);
 
   if((packet->payload_packet_len < 3)
      || (packet->payload == NULL))
     return;
 
   packet->line[packet->parsed_lines].ptr = packet->payload;
   packet->line[packet->parsed_lines].len = 0;
 
   for(a = 0; (a < packet->payload_packet_len)
 	&& (packet->parsed_lines < NDPI_MAX_PARSE_LINES_PER_PACKET); a++) {
-    if((a + 1) == packet->payload_packet_len)
+    if((a + 1) >= packet->payload_packet_len)
       return; /* Return if only one byte remains (prevent invalid reads past end-of-buffer) */
 
     if(get_u_int16_t(packet->payload, a) == ntohs(0x0d0a)) { /* If end of line char sequence CR+NL "\r\n", process line */
       packet->line[packet->parsed_lines].len = (u_int16_t)(((unsigned long) &packet->payload[a]) - ((unsigned long) packet->line[packet->parsed_lines].ptr));
 
       /* First line of a HTTP response parsing. Expected a "HTTP/1.? ???" */
       if(packet->parsed_lines == 0 && packet->line[0].len >= NDPI_STATICSTRING_LEN("HTTP/1.X 200 ") &&
 	 strncasecmp((const char *)packet->line[0].ptr, "HTTP/1.", NDPI_STATICSTRING_LEN("HTTP/1.")) == 0 &&
 	 packet->line[0].ptr[NDPI_STATICSTRING_LEN("HTTP/1.X ")] > '0' && /* response code between 000 and 699 */
 	 packet->line[0].ptr[NDPI_STATICSTRING_LEN("HTTP/1.X ")] < '6') {
 	packet->http_response.ptr = &packet->line[0].ptr[NDPI_STATICSTRING_LEN("HTTP/1.1 ")];
 	packet->http_response.len = packet->line[0].len - NDPI_STATICSTRING_LEN("HTTP/1.1 ");
 	packet->http_num_headers++;
 
 	/* Set server HTTP response code */
 	if(packet->payload_packet_len >= 12) {
 	  char buf[4];
 
 	  /* Set server HTTP response code */
 	  strncpy(buf, (char*)&packet->payload[9], 3);
 	  buf[3] = '\0';
 
 	  flow->http.response_status_code = atoi(buf);
 	  /* https://en.wikipedia.org/wiki/List_of_HTTP_status_codes */
 	  if((flow->http.response_status_code < 100) || (flow->http.response_status_code > 509))
 	    flow->http.response_status_code = 0; /* Out of range */
 	}
       }
 
       /* "Server:" header line in HTTP response */
       if(packet->line[packet->parsed_lines].len > NDPI_STATICSTRING_LEN("Server:") + 1
 	 && strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, "Server:", NDPI_STATICSTRING_LEN("Server:")) == 0) {
 	// some stupid clients omit a space and place the servername directly after the colon
         if(packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN("Server:")] == ' ') {
           packet->server_line.ptr =
             &packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN("Server:") + 1];
           packet->server_line.len =
             packet->line[packet->parsed_lines].len - (NDPI_STATICSTRING_LEN("Server:") + 1);
         } else {
           packet->server_line.ptr = &packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN("Server:")];
           packet->server_line.len = packet->line[packet->parsed_lines].len - NDPI_STATICSTRING_LEN("Server:");
         }
         packet->http_num_headers++;
       }
       /* "Host:" header line in HTTP request */
       if(packet->line[packet->parsed_lines].len > 6
 	 && strncasecmp((const char *)packet->line[packet->parsed_lines].ptr,
 			"Host:", 5) == 0) {
         // some stupid clients omit a space and place the hostname directly after the colon
         if(packet->line[packet->parsed_lines].ptr[5] == ' ') {
           packet->host_line.ptr = &packet->line[packet->parsed_lines].ptr[6];
           packet->host_line.len = packet->line[packet->parsed_lines].len - 6;
         } else {
           packet->host_line.ptr = &packet->line[packet->parsed_lines].ptr[5];
           packet->host_line.len = packet->line[packet->parsed_lines].len - 5;
         }
         packet->http_num_headers++;
       }
       /* "X-Forwarded-For:" header line in HTTP request. Commonly used for HTTP proxies. */
       if(packet->line[packet->parsed_lines].len > 17
 	 && strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, "X-Forwarded-For:", 16) == 0) {
         // some stupid clients omit a space and place the hostname directly after the colon
         if(packet->line[packet->parsed_lines].ptr[16] == ' ') {
           packet->forwarded_line.ptr = &packet->line[packet->parsed_lines].ptr[17];
           packet->forwarded_line.len = packet->line[packet->parsed_lines].len - 17;
         } else {
           packet->forwarded_line.ptr = &packet->line[packet->parsed_lines].ptr[16];
           packet->forwarded_line.len = packet->line[packet->parsed_lines].len - 16;
         }
         packet->http_num_headers++;
       }
       /* "Content-Type:" header line in HTTP. */
       if(packet->line[packet->parsed_lines].len > 14
 	 && (strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, "Content-Type: ", 14) == 0
 	     || strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, "Content-type: ", 14) == 0)) {
         packet->content_line.ptr = &packet->line[packet->parsed_lines].ptr[14];
         packet->content_line.len = packet->line[packet->parsed_lines].len - 14;
 
 	while((packet->content_line.len > 0) && (packet->content_line.ptr[0] == ' '))
 	  packet->content_line.len--, packet->content_line.ptr++;
 
         packet->http_num_headers++;
       }
       /* "Content-Type:" header line in HTTP AGAIN. Probably a bogus response without space after ":" */
       if((packet->content_line.len == 0)
 	 && (packet->line[packet->parsed_lines].len > 13)
 	 && (strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, "Content-type:", 13) == 0)) {
         packet->content_line.ptr = &packet->line[packet->parsed_lines].ptr[13];
         packet->content_line.len = packet->line[packet->parsed_lines].len - 13;
         packet->http_num_headers++;
       }
 
       if(packet->content_line.len > 0) {
 	/* application/json; charset=utf-8 */
 	char separator[] = { ';', '\r', '\0' };
 	int i;
 
 	for(i=0; separator[i] != '\0'; i++) {
 	  char *c = memchr((char*)packet->content_line.ptr, separator[i], packet->content_line.len);
 
 	  if(c != NULL)
 	    packet->content_line.len = c - (char*)packet->content_line.ptr;
 	}
       }
 
       /* "Accept:" header line in HTTP request. */
       if(packet->line[packet->parsed_lines].len > 8
 	 && strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, "Accept: ", 8) == 0) {
         packet->accept_line.ptr = &packet->line[packet->parsed_lines].ptr[8];
         packet->accept_line.len = packet->line[packet->parsed_lines].len - 8;
         packet->http_num_headers++;
       }
       /* "Referer:" header line in HTTP request. */
       if(packet->line[packet->parsed_lines].len > 9
 	 && strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, "Referer: ", 9) == 0) {
         packet->referer_line.ptr = &packet->line[packet->parsed_lines].ptr[9];
         packet->referer_line.len = packet->line[packet->parsed_lines].len - 9;
         packet->http_num_headers++;
       }
       /* "User-Agent:" header line in HTTP request. */
       if(packet->line[packet->parsed_lines].len > 12
 	 && (strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, "User-Agent: ", 12) == 0
 	     || strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, "User-agent: ", 12) == 0)) {
         packet->user_agent_line.ptr = &packet->line[packet->parsed_lines].ptr[12];
         packet->user_agent_line.len = packet->line[packet->parsed_lines].len - 12;
         packet->http_num_headers++;
       }
       /* "Content-Encoding:" header line in HTTP response (and request?). */
       if(packet->line[packet->parsed_lines].len > 18
 	 && strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, "Content-Encoding: ", 18) == 0) {
         packet->http_encoding.ptr = &packet->line[packet->parsed_lines].ptr[18];
         packet->http_encoding.len = packet->line[packet->parsed_lines].len - 18;
         packet->http_num_headers++;
       }
       /* "Transfer-Encoding:" header line in HTTP. */
       if(packet->line[packet->parsed_lines].len > 19
 	 && strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, "Transfer-Encoding: ", 19) == 0) {
         packet->http_transfer_encoding.ptr = &packet->line[packet->parsed_lines].ptr[19];
         packet->http_transfer_encoding.len = packet->line[packet->parsed_lines].len - 19;
         packet->http_num_headers++;
       }
       /* "Content-Length:" header line in HTTP. */
       if(packet->line[packet->parsed_lines].len > 16
 	 && ((strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, "Content-Length: ", 16) == 0)
 	     || (strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, "content-length: ", 16) == 0))) {
         packet->http_contentlen.ptr = &packet->line[packet->parsed_lines].ptr[16];
         packet->http_contentlen.len = packet->line[packet->parsed_lines].len - 16;
         packet->http_num_headers++;
       }
       /* "Cookie:" header line in HTTP. */
       if(packet->line[packet->parsed_lines].len > 8
 	 && strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, "Cookie: ", 8) == 0) {
         packet->http_cookie.ptr = &packet->line[packet->parsed_lines].ptr[8];
         packet->http_cookie.len = packet->line[packet->parsed_lines].len - 8;
         packet->http_num_headers++;
       }
       /* "Origin:" header line in HTTP. */
       if(packet->line[packet->parsed_lines].len > 8
 	 && strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, "Origin: ", 8) == 0) {
         packet->http_origin.ptr = &packet->line[packet->parsed_lines].ptr[8];
         packet->http_origin.len = packet->line[packet->parsed_lines].len - 8;
         packet->http_num_headers++;
       }
       /* "X-Session-Type:" header line in HTTP. */
       if(packet->line[packet->parsed_lines].len > 16
 	 && strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, "X-Session-Type: ", 16) == 0) {
         packet->http_x_session_type.ptr = &packet->line[packet->parsed_lines].ptr[16];
         packet->http_x_session_type.len = packet->line[packet->parsed_lines].len - 16;
         packet->http_num_headers++;
       }
       /* Identification and counting of other HTTP headers.
        * We consider the most common headers, but there are many others,
        * which can be seen at references below:
        * - https://tools.ietf.org/html/rfc7230
        * - https://en.wikipedia.org/wiki/List_of_HTTP_header_fields
        */
       if((packet->line[packet->parsed_lines].len >  6 && ( strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, "Date: ", 6) == 0 ||
                                                            strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, "Vary: ", 6) == 0 ||
                                                            strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, "ETag: ", 6) == 0 )) ||
          (packet->line[packet->parsed_lines].len >  8 && strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, "Pragma: ", 8) == 0) ||
          (packet->line[packet->parsed_lines].len >  9 && strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, "Expires: ", 9) == 0) ||
          (packet->line[packet->parsed_lines].len > 12 && ( strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, "Set-Cookie: ", 12) == 0 ||
                                                            strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, "Keep-Alive: ", 12) == 0 ||
                                                            strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, "Connection: ", 12) == 0)) ||
          (packet->line[packet->parsed_lines].len > 15 && ( strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, "Last-Modified: ", 15) == 0 ||
                                                            strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, "Accept-Ranges: ", 15) == 0)) ||
          (packet->line[packet->parsed_lines].len > 17 && ( strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, "Accept-Language: ", 17) == 0 ||
                                                            strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, "Accept-Encoding: ", 17) == 0)) ||
          (packet->line[packet->parsed_lines].len > 27 && strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, "Upgrade-Insecure-Requests: ", 27) == 0)) {
         /* Just count. In the future, if needed, this if can be splited to parse these headers */
         packet->http_num_headers++;
       }
 
 
       if(packet->line[packet->parsed_lines].len == 0) {
         packet->empty_line_position = a;
         packet->empty_line_position_set = 1;
       }
 
       if(packet->parsed_lines >= (NDPI_MAX_PARSE_LINES_PER_PACKET - 1))
         return;
 
       packet->parsed_lines++;
       packet->line[packet->parsed_lines].ptr = &packet->payload[a + 2];
       packet->line[packet->parsed_lines].len = 0;
 
       a++; /* next char in the payload */
     }
   }
 
   if(packet->parsed_lines >= 1) {
     packet->line[packet->parsed_lines].len
       = (u_int16_t)(((unsigned long) &packet->payload[packet->payload_packet_len]) -
 		    ((unsigned long) packet->line[packet->parsed_lines].ptr));
     packet->parsed_lines++;
   }
 }
 
 /* ********************************************************************************* */
diff --git a/src/lib/protocols/irc.c b/src/lib/protocols/irc.c
index 5ae0e34f..37cfbe1e 100644
--- a/src/lib/protocols/irc.c
+++ b/src/lib/protocols/irc.c
@@ -368,411 +368,411 @@ u_int8_t ndpi_search_irc_ssl_detect_ninety_percent_but_very_fast(struct ndpi_det
 void ndpi_search_irc_tcp(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow)
 {
   struct ndpi_packet_struct *packet = &flow->packet;
 	
   struct ndpi_id_struct *src = flow->src;
   struct ndpi_id_struct *dst = flow->dst;
   int less;
   u_int16_t c = 0;
   u_int16_t c1 = 0;
   u_int16_t port = 0;
   u_int16_t sport = 0;
   u_int16_t dport = 0;
   u_int16_t counter = 0;
   u_int16_t i = 0;
   u_int16_t j = 0;
   u_int16_t k = 0;
   u_int16_t h;
   u_int16_t http_content_ptr_len = 0;
   u_int8_t space = 0;
 
   NDPI_LOG_DBG(ndpi_struct, "search irc\n");
   if (flow->detected_protocol_stack[0] != NDPI_PROTOCOL_IRC && flow->packet_counter > 70) {
     NDPI_LOG_DBG(ndpi_struct, "exclude irc, packet_counter > 70\n");
     NDPI_ADD_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, NDPI_PROTOCOL_IRC);
     return;
   }
   if (flow->detected_protocol_stack[0] != NDPI_PROTOCOL_IRC && flow->packet_counter > 30 &&
       flow->l4.tcp.irc_stage2 == 0) {
     NDPI_LOG_DBG(ndpi_struct, "exclude irc, packet_counter > 30\n");
     NDPI_ADD_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, NDPI_PROTOCOL_IRC);
     return;
   }
   if (packet->detected_protocol_stack[0] == NDPI_PROTOCOL_IRC) {
     if (src != NULL && ((u_int32_t)
 			(packet->tick_timestamp - src->irc_ts) < ndpi_struct->irc_timeout)) {
       NDPI_LOG_DBG2(ndpi_struct, "irc : save src connection packet detected\n");
       src->irc_ts = packet->tick_timestamp;
     } else if (dst != NULL && ((u_int32_t)
 			       (packet->tick_timestamp - dst->irc_ts) < ndpi_struct->irc_timeout)) {
       NDPI_LOG_DBG2(ndpi_struct, "irc : save dst connection packet detected\n");
       dst->irc_ts = packet->tick_timestamp;
     }
   }
 
   if (((dst != NULL && NDPI_COMPARE_PROTOCOL_TO_BITMASK(dst->detected_protocol_bitmask, NDPI_PROTOCOL_IRC)
 	&& ((u_int32_t)
 	    (packet->tick_timestamp - dst->irc_ts)) <
 	ndpi_struct->irc_timeout)) || (src != NULL
 				       &&
 				       NDPI_COMPARE_PROTOCOL_TO_BITMASK
 				       (src->detected_protocol_bitmask, NDPI_PROTOCOL_IRC)
 				       && ((u_int32_t)
 					   (packet->tick_timestamp - src->irc_ts)) < ndpi_struct->irc_timeout)) {
     if (packet->tcp != NULL) {
       sport = packet->tcp->source;
       dport = packet->tcp->dest;
     }
     if (dst != NULL) {
       for (counter = 0; counter < dst->irc_number_of_port; counter++) {
 	if (dst->irc_port[counter] == sport || dst->irc_port[counter] == dport) {
 	  dst->last_time_port_used[counter] = packet->tick_timestamp;
 	  NDPI_LOG_INFO(ndpi_struct, "found IRC: dest port matched with the DCC port");
 	  ndpi_int_irc_add_connection(ndpi_struct, flow);
 	  return;
 	}
       }
     }
     if (src != NULL) {
       for (counter = 0; counter < src->irc_number_of_port; counter++) {
 	if (src->irc_port[counter] == sport || src->irc_port[counter] == dport) {
 	  src->last_time_port_used[counter] = packet->tick_timestamp;
 	  NDPI_LOG_INFO(ndpi_struct, "found  IRC: Source port matched with the DCC port");
 	  ndpi_int_irc_add_connection(ndpi_struct, flow);
 	  return;
 	}
       }
     }
   }
 
 
 
   if (flow->detected_protocol_stack[0] != NDPI_PROTOCOL_IRC
       && flow->packet_counter == 2 && (packet->payload_packet_len > 400 && packet->payload_packet_len < 1381)) {
     for (c1 = 50; c1 < packet->payload_packet_len - 23; c1++) {
       if (packet->payload[c1] == 'i' || packet->payload[c1] == 'd') {
 	if ((memcmp(&packet->payload[c1], "irc.hackthissite.org0", 21)
 	     == 0)
 	    || (memcmp(&packet->payload[c1], "irc.gamepad.ca1", 15) == 0)
 	    || (memcmp(&packet->payload[c1], "dungeon.axenet.org0", 19)
 		== 0)
 	    || (memcmp(&packet->payload[c1], "dazed.nuggethaus.net", 20)
 		== 0)
 	    || (memcmp(&packet->payload[c1], "irc.indymedia.org", 17)
 		== 0)
 	    || (memcmp(&packet->payload[c1], "irc.cccp-project.net", 20)
 		== 0)
 	    || (memcmp(&packet->payload[c1], "dirc.followell.net0", 19)
 		== 0)
 	    || (memcmp(&packet->payload[c1], "irc.discostars.de1", 18)
 		== 0)
 	    || (memcmp(&packet->payload[c1], "irc.rizon.net", 13) == 0)) {
 	  NDPI_LOG_INFO(ndpi_struct,
 		   "found IRC SSL: - irc.hackthissite.org0 | irc.gamepad.ca1 | dungeon.axenet.org0 "
 		   "| dazed.nuggethaus.net | irc.indymedia.org | irc.discostars.de1 ");
 	  ndpi_int_irc_add_connection(ndpi_struct, flow);
 	  break;
 	}
       }
     }
   }
   if (flow->detected_protocol_stack[0] != NDPI_PROTOCOL_IRC &&
       ndpi_search_irc_ssl_detect_ninety_percent_but_very_fast(ndpi_struct, flow) != 0) {
     return;
   }
 
   if (flow->detected_protocol_stack[0] != NDPI_PROTOCOL_IRC && flow->packet_counter < 20
       && packet->payload_packet_len >= 8) {
     if (get_u_int8_t(packet->payload, packet->payload_packet_len - 1) == 0x0a
 	|| (ntohs(get_u_int16_t(packet->payload, packet->payload_packet_len - 2)) == 0x0a00)) {
       if (memcmp(packet->payload, ":", 1) == 0) {
 	if (packet->payload[packet->payload_packet_len - 2] != 0x0d
 	    && packet->payload[packet->payload_packet_len - 1] == 0x0a) {
 	  ndpi_parse_packet_line_info_any(ndpi_struct, flow);
 	} else if (packet->payload[packet->payload_packet_len - 2] == 0x0d) {
 	  ndpi_parse_packet_line_info(ndpi_struct, flow);
 	} else {
 	  flow->l4.tcp.irc_3a_counter++;
 	  packet->parsed_lines = 0;
 	}
 	for (i = 0; i < packet->parsed_lines; i++) {
-	  if (packet->line[i].ptr[0] == ':') {
+	  if ((packet->line[i].len > 0) && packet->line[i].ptr[0] == ':') {
 	    flow->l4.tcp.irc_3a_counter++;
 	    if (flow->l4.tcp.irc_3a_counter == 7) {	/* ':' == 0x3a */
 	      NDPI_LOG_INFO(ndpi_struct, "found irc. 0x3a. seven times.");
 	      ndpi_int_irc_add_connection(ndpi_struct, flow);
 	      goto detected_irc;
 	    }
 	  }
 	}
 	if (flow->l4.tcp.irc_3a_counter == 7) {	/* ':' == 0x3a */
 	  NDPI_LOG_INFO(ndpi_struct, "found irc. 0x3a. seven times.");
 	  ndpi_int_irc_add_connection(ndpi_struct, flow);
 	  goto detected_irc;
 	}
       }
       if ((memcmp(packet->payload, "USER ", 5) == 0)
 	  || (memcmp(packet->payload, "NICK ", 5) == 0)
 	  || (memcmp(packet->payload, "PASS ", 5) == 0)
 	  || (memcmp(packet->payload, ":", 1) == 0 && ndpi_check_for_NOTICE_or_PRIVMSG(ndpi_struct, flow) != 0)
 	  || (memcmp(packet->payload, "PONG ", 5) == 0)
 	  || (memcmp(packet->payload, "PING ", 5) == 0)
 	  || (memcmp(packet->payload, "JOIN ", 5) == 0)
 	  || (memcmp(packet->payload, "NOTICE ", 7) == 0)
 	  || (memcmp(packet->payload, "PRIVMSG ", 8) == 0)
 	  || (memcmp(packet->payload, "VERSION ", 8) == 0)) {
 	NDPI_LOG_DBG2(ndpi_struct,
 		 "USER, NICK, PASS, NOTICE, PRIVMSG one time");
 	if (flow->l4.tcp.irc_stage == 2) {
 	  NDPI_LOG_INFO(ndpi_struct, "found irc");
 	  ndpi_int_irc_add_connection(ndpi_struct, flow);
 	  flow->l4.tcp.irc_stage = 3;
 	}
 	if (flow->l4.tcp.irc_stage == 1) {
 	  NDPI_LOG_DBG2(ndpi_struct, "second time, stage=2");
 	  flow->l4.tcp.irc_stage = 2;
 	}
 	if (flow->l4.tcp.irc_stage == 0) {
 	  NDPI_LOG_DBG2(ndpi_struct, "first time, stage=1");
 	  flow->l4.tcp.irc_stage = 1;
 	}
 	/* irc packets can have either windows line breaks (0d0a) or unix line breaks (0a) */
 	if (packet->payload[packet->payload_packet_len - 2] == 0x0d
 	    && packet->payload[packet->payload_packet_len - 1] == 0x0a) {
 	  ndpi_parse_packet_line_info(ndpi_struct, flow);
 	  if (packet->parsed_lines > 1) {
 	    NDPI_LOG_DBG2(ndpi_struct, "packet contains more than one line");
 	    for (c = 1; c < packet->parsed_lines; c++) {
 	      if (packet->line[c].len > 4 && (memcmp(packet->line[c].ptr, "NICK ", 5) == 0
 					      || memcmp(packet->line[c].ptr, "USER ", 5) == 0)) {
 		NDPI_LOG_INFO(ndpi_struct, "found IRC: two icq signal words in the same packet");
 		ndpi_int_irc_add_connection(ndpi_struct, flow);
 		flow->l4.tcp.irc_stage = 3;
 		return;
 	      }
 	    }
 	  }
 
 	} else if (packet->payload[packet->payload_packet_len - 1] == 0x0a) {
 	  ndpi_parse_packet_line_info_any(ndpi_struct, flow);
 	  if (packet->parsed_lines > 1) {
 	    NDPI_LOG_DBG2(ndpi_struct, "packet contains more than one line");
 	    for (c = 1; c < packet->parsed_lines; c++) {
 	      if (packet->line[c].len > 4 && (memcmp(packet->line[c].ptr, "NICK ", 5) == 0
 						   || memcmp(packet->line[c].ptr, "USER ",
 							     5) == 0)) {
 		NDPI_LOG_INFO(ndpi_struct, "found IRC: two icq signal words in the same packet");
 		ndpi_int_irc_add_connection(ndpi_struct, flow);
 		flow->l4.tcp.irc_stage = 3;
 		return;
 	      }
 	    }
 	  }
 	}
       }
     }
   }
 
   /**
    * Trying to primarily detect the HTTP Web based IRC chat patterns based on the HTTP headers
    * during the User login time.When the HTTP data gets posted using the POST method ,patterns
    * will be searched in the HTTP content.
    */
   if ((flow->detected_protocol_stack[0] != NDPI_PROTOCOL_IRC) && (flow->l4.tcp.irc_stage == 0)
       && (packet->payload_packet_len > 5)) {
     //HTTP POST Method being employed
     if (memcmp(packet->payload, "POST ", 5) == 0) {
       ndpi_parse_packet_line_info(ndpi_struct, flow);
       if (packet->parsed_lines) {
 		  u_int16_t http_header_len = (u_int16_t)((packet->line[packet->parsed_lines - 1].ptr - packet->payload) + 2);
 	if (packet->payload_packet_len > http_header_len) {
 	  http_content_ptr_len = packet->payload_packet_len - http_header_len;
 	}
 	if ((ndpi_check_for_IRC_traces(packet->line[0].ptr, packet->line[0].len))
 	    || ((packet->http_url_name.ptr)
 		&& (ndpi_check_for_IRC_traces(packet->http_url_name.ptr, packet->http_url_name.len)))
 	    || ((packet->referer_line.ptr)
 		&& (ndpi_check_for_IRC_traces(packet->referer_line.ptr, packet->referer_line.len)))) {
 	  NDPI_LOG_DBG2(ndpi_struct,
 		   "IRC detected from the Http URL/ Referer header ");
 	  flow->l4.tcp.irc_stage = 1;
 	  // HTTP POST Request body is not in the same packet.
 	  if (!http_content_ptr_len) {
 	    return;
 	  }
 	}
       }
     }
   }
 
   if ((flow->detected_protocol_stack[0] != NDPI_PROTOCOL_IRC) && (flow->l4.tcp.irc_stage == 1)) {
     if ((((packet->payload_packet_len - http_content_ptr_len) > 10)
 	 && (memcmp(packet->payload + http_content_ptr_len, "interface=", 10) == 0)
 	 && (ndpi_check_for_Nickname(ndpi_struct, flow) != 0))
 	|| (((packet->payload_packet_len - http_content_ptr_len) > 5)
 	    && (memcmp(packet->payload + http_content_ptr_len, "item=", 5) == 0)
 	    && (ndpi_check_for_cmd(ndpi_struct, flow) != 0))) {
       NDPI_LOG_INFO(ndpi_struct, "found IRC: Nickname, cmd,  one time");
       ndpi_int_irc_add_connection(ndpi_struct, flow);
       return;
     }
   }
 
  detected_irc:
   NDPI_LOG_DBG2(ndpi_struct, "detected_irc:");
 
   if (flow->detected_protocol_stack[0] == NDPI_PROTOCOL_IRC) {
     /* maybe this can be deleted at the end */
 
     if (packet->payload[packet->payload_packet_len - 2] != 0x0d
 	&& packet->payload[packet->payload_packet_len - 1] == 0x0a) {
       NDPI_LOG_DBG2(ndpi_struct, "ndpi_parse_packet_line_info_any(ndpi_struct, flow);");
       ndpi_parse_packet_line_info_any(ndpi_struct, flow);
     } else if (packet->payload[packet->payload_packet_len - 2] == 0x0d) {
       ndpi_parse_packet_line_info(ndpi_struct, flow);
     } else {
       return;
     }
     for (i = 0; i < packet->parsed_lines; i++) {
       if (packet->line[i].len > 6 && memcmp(packet->line[i].ptr, "NOTICE ", 7) == 0) {
 	NDPI_LOG_DBG2(ndpi_struct, "NOTICE");
 	for (j = 7; j < packet->line[i].len - 8; j++) {
 	  if (packet->line[i].ptr[j] == ':') {
 	    if (memcmp(&packet->line[i].ptr[j + 1], "DCC SEND ", 9) == 0
 		|| memcmp(&packet->line[i].ptr[j + 1], "DCC CHAT ", 9) == 0) {
 	      NDPI_LOG_INFO(ndpi_struct,
 		       "found NOTICE and DCC CHAT or DCC SEND.");
 	    }
 	  }
 	}
       }
       if (packet->payload_packet_len > 0 && packet->payload[0] == 0x3a /* 0x3a = ':' */ ) {
 	NDPI_LOG_DBG2(ndpi_struct, "3a");
 	for (j = 1; j < packet->line[i].len - 9; j++) {
 	  if (packet->line[i].ptr[j] == ' ') {
 	    j++;
 	    if (packet->line[i].ptr[j] == 'P') {
 	      NDPI_LOG_DBG2(ndpi_struct, "P");
 	      j++;
 	      if (memcmp(&packet->line[i].ptr[j], "RIVMSG ", 7) == 0)
 		NDPI_LOG_DBG2(ndpi_struct, "RIVMSG");
 	      h = j + 7;
 	      goto read_privmsg;
 	    }
 	  }
 	}
       }
       if (packet->line[i].len > 7 && (memcmp(packet->line[i].ptr, "PRIVMSG ", 8) == 0)) {
 	NDPI_LOG_DBG2(ndpi_struct, "PRIVMSG	");
 	h = 7;
       read_privmsg:
 	for (j = h; j < packet->line[i].len - 9; j++) {
 	  if (packet->line[i].ptr[j] == ':') {
 	    if (memcmp(&packet->line[i].ptr[j + 1], "xdcc ", 5) == 0) {
 	      NDPI_LOG_DBG2(ndpi_struct, "xdcc should match.");
 	    }
 	    j += 2;
 	    if (memcmp(&packet->line[i].ptr[j], "DCC ", 4) == 0) {
 	      j += 4;
 	      NDPI_LOG_DBG2(ndpi_struct, "found DCC.");
 	      if (memcmp(&packet->line[i].ptr[j], "SEND ", 5) == 0
 		  || (memcmp(&packet->line[i].ptr[j], "CHAT", 4) == 0)
 		  || (memcmp(&packet->line[i].ptr[j], "chat", 4) == 0)
 		  || (memcmp(&packet->line[i].ptr[j], "sslchat", 7) == 0)
 		  || (memcmp(&packet->line[i].ptr[j], "TSEND", 5) == 0)) {
 		NDPI_LOG_DBG2(ndpi_struct, "found CHAT,chat,sslchat,TSEND.");
 		j += 4;
 
 		while (packet->line[i].len > j &&
 		       ((packet->line[i].ptr[j] >= 'a' && packet->line[i].ptr[j] <= 'z')
 			|| (packet->line[i].ptr[j] >= 'A' && packet->line[i].ptr[j] <= 'Z')
 			|| (packet->line[i].ptr[j] >= '0' && packet->line[i].ptr[j] <= '9')
 			|| (packet->line[i].ptr[j] >= ' ')
 			|| (packet->line[i].ptr[j] >= '.')
 			|| (packet->line[i].ptr[j] >= '-'))) {
 
 		  if (packet->line[i].ptr[j] == ' ') {
 		    space++;
 		    NDPI_LOG_DBG2(ndpi_struct, "space %u.", space);
 		  }
 		  if (space == 3) {
 		    j++;
 		    NDPI_LOG_DBG2(ndpi_struct, "read port.");
 		    if (src != NULL) {
 		      k = j;
 		      port =
 			ntohs_ndpi_bytestream_to_number
 			(&packet->line[i].ptr[j], packet->payload_packet_len - j, &j);
 		      NDPI_LOG_DBG2(ndpi_struct, "port %u.",
 			       port);
 		      j = k;
 		      // hier jetzt überlegen, wie die ports abgespeichert werden sollen
 		      if (src->irc_number_of_port < NDPI_PROTOCOL_IRC_MAXPORT)
 			NDPI_LOG_DBG2(ndpi_struct, "src->irc_number_of_port < NDPI_PROTOCOL_IRC_MAXPORT.");
 		      if (src->irc_number_of_port < NDPI_PROTOCOL_IRC_MAXPORT && port != 0) {
 			if (!ndpi_is_duplicate(src, port)) {
 			  src->irc_port[src->irc_number_of_port]
 			    = port;
 			  src->irc_number_of_port++;
 			  NDPI_LOG_DBG2(ndpi_struct, "found port=%d jjeeeeeeeeeeeeeeeeeeeeeeeee",
 			     ntohs(get_u_int16_t(src->irc_port, 0)));
 			}
 			src->irc_ts = packet->tick_timestamp;
 		      } else if (port != 0 && src->irc_number_of_port == NDPI_PROTOCOL_IRC_MAXPORT) {
 			if (!ndpi_is_duplicate(src, port)) {
 			  less = 0;
 			  NDPI_IRC_FIND_LESS(src->last_time_port_used, less);
 			  src->irc_port[less] = port;
 			  NDPI_LOG_DBG2(ndpi_struct, "found port=%d", ntohs(get_u_int16_t(src->irc_port, 0)));
 			}
 			src->irc_ts = packet->tick_timestamp;
 		      }
 		      if (dst == NULL) {
 			break;
 		      }
 		    }
 		    if (dst != NULL) {
 		      port = ntohs_ndpi_bytestream_to_number
 			(&packet->line[i].ptr[j], packet->payload_packet_len - j, &j);
 		      NDPI_LOG_DBG2(ndpi_struct, "port %u.", port);
 		      // hier das gleiche wie oben.
 		      /* hier werden NDPI_PROTOCOL_IRC_MAXPORT ports pro irc flows mitgespeichert. könnte man denn nicht ein-
 		       * fach an die dst oder src einen flag setzten, dass dieser port für eine bestimmte
 		       * zeit ein irc-port bleibt?
 		       */
 		      if (dst->irc_number_of_port < NDPI_PROTOCOL_IRC_MAXPORT && port != 0) {
 			if (!ndpi_is_duplicate(dst, port)) {
 			  dst->irc_port[dst->irc_number_of_port]
 			    = port;
 			  dst->irc_number_of_port++;
 			  NDPI_LOG_DBG2(ndpi_struct, "found port=%d", ntohs(get_u_int16_t(dst->irc_port, 0)));
 			  NDPI_LOG_DBG2(ndpi_struct, "juuuuuuuuuuuuuuuu");
 			}
 			dst->irc_ts = packet->tick_timestamp;
 		      } else if (port != 0 && dst->irc_number_of_port == NDPI_PROTOCOL_IRC_MAXPORT) {
 			if (!ndpi_is_duplicate(dst, port)) {
 			  less = 0;
 			  NDPI_IRC_FIND_LESS(dst->last_time_port_used, less);
 			  dst->irc_port[less] = port;
 
 			  NDPI_LOG_DBG2(ndpi_struct, "found port=%d", ntohs(get_u_int16_t(dst->irc_port, 0)));
 			}
 			dst->irc_ts = packet->tick_timestamp;
 		      }
 
 		      break;
 		    }
 		  }
 
 
 		  j++;
 		}
 
 	      }
 	    }
 	  }
 	}
 
       }
     }
   }
 }
diff --git a/src/lib/protocols/tls.c b/src/lib/protocols/tls.c
index 2f4959b8..ed92814d 100644
--- a/src/lib/protocols/tls.c
+++ b/src/lib/protocols/tls.c
@@ -750,163 +750,163 @@ int getTLScertificate(struct ndpi_detection_module_struct *ndpi_struct,
 /* See https://blog.catchpoint.com/2017/05/12/dissecting-tls-using-wireshark/ */
 int getSSCertificateFingerprint(struct ndpi_detection_module_struct *ndpi_struct,
 				struct ndpi_flow_struct *flow) {
   struct ndpi_packet_struct *packet = &flow->packet;
   u_int8_t multiple_messages;
 
   if(flow->l4.tcp.tls_srv_cert_fingerprint_processed)
     return(0); /* We're good */
   
 #ifdef DEBUG_TLS
   printf("=>> [TLS] %s() [tls_record_offset=%d][payload_packet_len=%u][direction: %u][%02X %02X %02X...]\n",
 	 __FUNCTION__, flow->l4.tcp.tls_record_offset, packet->payload_packet_len,
 	 packet->packet_direction,
 	 packet->payload[0], packet->payload[1], packet->payload[2]);
 #endif
   
   if((packet->packet_direction == 0) /* Client -> Server */
      || (packet->payload_packet_len == 0))
     return(1); /* More packets please */
   else if(flow->l4.tcp.tls_srv_cert_fingerprint_processed)
     return(0); /* We're good */
 
   if(packet->payload_packet_len <= flow->l4.tcp.tls_record_offset) {
     /* Avoid invalid memory accesses */
     return(1);
   }
 
   if(flow->l4.tcp.tls_fingerprint_len > 0) {
     unsigned int avail = packet->payload_packet_len - flow->l4.tcp.tls_record_offset;
 
     if(avail > flow->l4.tcp.tls_fingerprint_len)
       avail = flow->l4.tcp.tls_fingerprint_len;
 
 #ifdef DEBUG_TLS
     printf("=>> [TLS] Certificate record [%02X %02X %02X...][missing: %u][offset: %u][avail: %u] (B)\n",
 	   packet->payload[flow->l4.tcp.tls_record_offset],
 	   packet->payload[flow->l4.tcp.tls_record_offset+1],
 	   packet->payload[flow->l4.tcp.tls_record_offset+2],
 	   flow->l4.tcp.tls_fingerprint_len, flow->l4.tcp.tls_record_offset, avail
 	   );
 #endif
     
 #ifdef DEBUG_CERTIFICATE_HASH
     for(i=0;i<avail;i++)
       printf("%02X ", packet->payload[flow->l4.tcp.tls_record_offset+i]);
     printf("\n");
 #endif
     
     SHA1Update(flow->l4.tcp.tls_srv_cert_fingerprint_ctx,
 	       &packet->payload[flow->l4.tcp.tls_record_offset],
 	       avail);
       
     flow->l4.tcp.tls_fingerprint_len -= avail;
       
     if(flow->l4.tcp.tls_fingerprint_len == 0) {
       SHA1Final(flow->l4.tcp.tls_sha1_certificate_fingerprint, flow->l4.tcp.tls_srv_cert_fingerprint_ctx);
 
 #ifdef DEBUG_TLS
       {
 	int i;
 	
 	printf("=>> [TLS] SHA-1: ");
 	for(i=0;i<20;i++)
 	  printf("%s%02X", (i > 0) ? ":" : "", flow->l4.tcp.tls_sha1_certificate_fingerprint[i]);
 	printf("\n");
       }
 #endif
       
       flow->l4.tcp.tls_srv_cert_fingerprint_processed = 1;
       return(0); /* We're good */
     } else {
       flow->l4.tcp.tls_record_offset = 0;
 #ifdef DEBUG_TLS
       printf("=>> [TLS] Certificate record: still missing %u bytes\n", flow->l4.tcp.tls_fingerprint_len);
 #endif
       return(1); /* More packets please */
     }
   }
 
   if(packet->payload[flow->l4.tcp.tls_record_offset] == 0x15 /* Alert */) {
     u_int len = ntohs(*(u_int16_t*)&packet->payload[flow->l4.tcp.tls_record_offset+3]) + 5 /* SSL header len */;
 
     if(len < 10 /* Sanity check */) {
       if((flow->l4.tcp.tls_record_offset+len) < packet->payload_packet_len)
 	flow->l4.tcp.tls_record_offset += len;
     } else
       goto invalid_len;
   }
   
   multiple_messages = (packet->payload[flow->l4.tcp.tls_record_offset] == 0x16 /* Handshake */) ? 0 : 1;
 
 #ifdef DEBUG_TLS
   printf("=>> [TLS] [multiple_messages: %d]\n", multiple_messages);
 #endif
 
   if((!multiple_messages) && (packet->payload[flow->l4.tcp.tls_record_offset] != 0x16 /* Handshake */))
     return(1);
   else if(((!multiple_messages) && (packet->payload[flow->l4.tcp.tls_record_offset+5] == 0xb) /* Certificate */)
 	  || (packet->payload[flow->l4.tcp.tls_record_offset] == 0xb) /* Certificate */) {
     /* TODO: Do not take into account all certificates but only the first one */
 #ifdef DEBUG_TLS
     printf("=>> [TLS] Certificate found\n");
 #endif
 
     if(flow->l4.tcp.tls_srv_cert_fingerprint_ctx == NULL)
       flow->l4.tcp.tls_srv_cert_fingerprint_ctx = (void*)ndpi_malloc(sizeof(SHA1_CTX));
     else {
 #ifdef DEBUG_TLS
       printf("[TLS] Internal error: double allocation\n:");
 #endif
     }
     
     if(flow->l4.tcp.tls_srv_cert_fingerprint_ctx) {
       SHA1Init(flow->l4.tcp.tls_srv_cert_fingerprint_ctx);
       flow->l4.tcp.tls_srv_cert_fingerprint_found = 1;
       flow->l4.tcp.tls_record_offset += (!multiple_messages) ? 13 : 8;
       flow->l4.tcp.tls_fingerprint_len = ntohs(*(u_int16_t*)&packet->payload[flow->l4.tcp.tls_record_offset]);
       flow->l4.tcp.tls_record_offset = flow->l4.tcp.tls_record_offset+2;
 #ifdef DEBUG_TLS
       printf("=>> [TLS] Certificate [total certificate len: %u][certificate initial offset: %u]\n",
 	     flow->l4.tcp.tls_fingerprint_len, flow->l4.tcp.tls_record_offset);
 #endif
       return(getSSCertificateFingerprint(ndpi_struct, flow));        
     } else
       return(0); /* That's all */
   } else if(flow->l4.tcp.tls_seen_certificate)
     return(0); /* That's all */  
-  else if(packet->payload_packet_len > flow->l4.tcp.tls_record_offset+7) {
+  else if(packet->payload_packet_len > flow->l4.tcp.tls_record_offset+7+1/* +1 because we are going to read 2 bytes */) {
     /* This is a handshake but not a certificate record */
     u_int16_t len = ntohs(*(u_int16_t*)&packet->payload[flow->l4.tcp.tls_record_offset+7]);
 
 #ifdef DEBUG_TLS
     printf("=>> [TLS] Found record %02X [len: %u]\n",
 	   packet->payload[flow->l4.tcp.tls_record_offset+5], len);
 #endif
 
     if(len > 4096) {
     invalid_len:
       /* This looks an invalid len: we giveup */
       flow->l4.tcp.tls_record_offset = 0, flow->l4.tcp.tls_srv_cert_fingerprint_processed = 1;
 #ifdef DEBUG_TLS
       printf("=>> [TLS] Invalid fingerprint processing %u <-> %u\n",
 	     ntohs(packet->tcp->source), ntohs(packet->tcp->dest));
 #endif
       return(0);
     } else {
       flow->l4.tcp.tls_record_offset += len + 9;
       
       if(flow->l4.tcp.tls_record_offset < packet->payload_packet_len)
 	return(getSSCertificateFingerprint(ndpi_struct, flow));
       else {
 	flow->l4.tcp.tls_record_offset -= packet->payload_packet_len;      
       }
     }
   }
 
   flow->extra_packets_func = NULL; /* We're good now */
   return(1);
 }
 
 /* **************************************** */
 
 /* See https://blog.catchpoint.com/2017/05/12/dissecting-tls-using-wireshark/ */
