commit 20490786224f4a8256fb395deb9c05084db91708
Author: Andy Ragusa (aragusa) <aragusa@cisco.com>
Date:   Mon Jul 13 19:31:27 2020 -0700

    fuzz-22348 null deref in egg utf8 conversion
    Corrected memory leaks and a null dereference in the egg utf8 conversion.

diff --git a/libclamav/blob.c b/libclamav/blob.c
index 2f438033b..2abc0db26 100644
--- a/libclamav/blob.c
+++ b/libclamav/blob.c
@@ -173,88 +173,99 @@ blobGetFilename(const blob *b)
 /*
  * Returns <0 for failure
  */
 int blobAddData(blob *b, const unsigned char *data, size_t len)
 {
 #if HAVE_CLI_GETPAGESIZE
-    static int pagesize;
+    static int pagesize = 0;
     int growth;
 #endif
 
     assert(b != NULL);
 #ifdef CL_DEBUG
     assert(b->magic == BLOBCLASS);
 #endif
     assert(data != NULL);
 
     if (len == 0)
         return 0;
 
     if (b->isClosed) {
         /*
 		 * Should be cli_dbgmsg, but I want to see them for now,
 		 * and cli_dbgmsg doesn't support debug levels
 		 */
         cli_warnmsg("Reopening closed blob\n");
         b->isClosed = 0;
     }
     /*
 	 * The payoff here is between reducing the number of calls to
 	 * malloc/realloc and not overallocating memory. A lot of machines
 	 * are more tight with memory than one may imagine which is why
 	 * we don't just allocate a *huge* amount and be done with it. Closing
 	 * the blob helps because that reclaims memory. If you know the maximum
 	 * size of a blob before you start adding data, use blobGrow() that's
 	 * the most optimum
 	 */
 #if HAVE_CLI_GETPAGESIZE
     if (pagesize == 0) {
         pagesize = cli_getpagesize();
         if (pagesize == 0)
             pagesize = 4096;
     }
     growth = pagesize;
     if (len >= (size_t)pagesize)
         growth = ((len / pagesize) + 1) * pagesize;
 
     /*cli_dbgmsg("blobGrow: b->size %lu, b->len %lu, len %lu, growth = %u\n",
 		b->size, b->len, len, growth);*/
 
     if (b->data == NULL) {
         assert(b->len == 0);
         assert(b->size == 0);
 
         b->size = growth;
         b->data = cli_malloc(growth);
+        if (NULL == b->data){
+            b->size = 0;
+            return -1;
+        }
     } else if (b->size < b->len + (off_t)len) {
         unsigned char *p = cli_realloc(b->data, b->size + growth);
 
         if (p == NULL)
             return -1;
 
         b->size += growth;
         b->data = p;
     }
 #else
     if (b->data == NULL) {
         assert(b->len == 0);
         assert(b->size == 0);
 
         b->size = (off_t)len * 4;
         b->data = cli_malloc(b->size);
+        if (NULL == b->data){
+            b->size = 0;
+            return -1;
+        }
     } else if (b->size < b->len + (off_t)len) {
         unsigned char *p = cli_realloc(b->data, b->size + (len * 4));
 
         if (p == NULL)
             return -1;
 
         b->size += (off_t)len * 4;
         b->data = p;
     }
 #endif
 
     if (b->data) {
         memcpy(&b->data[b->len], data, len);
         b->len += (off_t)len;
+    } else {
+        b->size = 0;
+        return -1;
     }
     return 0;
 }
@@ -286,42 +297,43 @@ blobGetDataSize(const blob *b)
 void blobClose(blob *b)
 {
     assert(b != NULL);
 #ifdef CL_DEBUG
     assert(b->magic == BLOBCLASS);
 #endif
 
     if (b->isClosed) {
         cli_warnmsg("Attempt to close a previously closed blob\n");
         return;
     }
 
     /*
 	 * Nothing more is going to be added to this blob. If it'll save more
 	 * than a trivial amount (say 64 bytes) of memory, shrink the allocation
 	 */
     if ((b->size - b->len) >= 64) {
         if (b->len == 0) { /* Not likely */
             free(b->data);
             b->data = NULL;
             cli_dbgmsg("blobClose: recovered all %lu bytes\n",
                        (unsigned long)b->size);
             b->size = 0;
         } else {
             unsigned char *ptr = cli_realloc(b->data, b->len);
 
-            if (ptr == NULL)
+            if (ptr == NULL) {
                 return;
+            }
 
             cli_dbgmsg("blobClose: recovered %lu bytes from %lu\n",
                        (unsigned long)(b->size - b->len),
                        (unsigned long)b->size);
             b->size = b->len;
             b->data = ptr;
         }
     }
     b->isClosed = 1;
 }
 
 /*
  * Returns 0 if the blobs are the same
  */
diff --git a/libclamav/entconv.c b/libclamav/entconv.c
index fb217fc36..689aa305b 100644
--- a/libclamav/entconv.c
+++ b/libclamav/entconv.c
@@ -774,243 +774,256 @@ int encoding_normalize_toascii(const m_area_t* in_m_area, const char* initial_en
 cl_error_t cli_codepage_to_utf8(char* in, size_t in_size, uint16_t codepage, char** out, size_t* out_size)
 
 {
     cl_error_t status = CL_BREAK;
 
     char* out_utf8       = NULL;
     size_t out_utf8_size = 0;
 
 #if defined(HAVE_ICONV)
     iconv_t conv = (iconv_t) -1;
 #elif defined(WIN32)
     LPWSTR lpWideCharStr = NULL;
     int cchWideChar      = 0;
 #endif
 
     if (NULL == in || in_size == 0 || NULL == out || NULL == out_size) {
-        cli_dbgmsg("egg_filename_to_utf8: Invalid args.\n");
+        cli_dbgmsg("cli_codepage_to_utf8: Invalid args.\n");
         status = CL_EARG;
         goto done;
     }
 
     *out      = NULL;
     *out_size = 0;
 
     switch (codepage) {
         case 20127:   /* US-ASCII (7-bit) */
         case 65001: { /* Unicode (UTF-8) */
             char* track;
             int byte_count, sigbit_count;
 
             out_utf8_size = in_size;
             out_utf8      = cli_calloc(1, out_utf8_size + 1);
             if (NULL == out_utf8) {
-                cli_errmsg("egg_filename_to_utf8: Failure allocating buffer for utf8 filename.\n");
+                cli_errmsg("cli_codepage_to_utf8: Failure allocating buffer for utf8 filename.\n");
                 status = CL_EMEM;
                 goto done;
             }
             memcpy(out_utf8, in, in_size);
 
             track = out_utf8 + in_size - 1;
             if ((codepage == 65001) && (*track & 0x80)) {
                 /*
                  * UTF-8 with a most significant bit.
                  */
 
                 /* locate the start of the last character */
                 for (byte_count = 1; (track != out_utf8); track--, byte_count++) {
                     if (((uint8_t)*track & 0xC0) != 0x80)
                         break;
                 }
 
                 /* count number of set (1) significant bits */
                 for (sigbit_count = 0; sigbit_count < (int)(sizeof(uint8_t) * 8); sigbit_count++) {
                     if (((uint8_t)*track & (0x80 >> sigbit_count)) == 0)
                         break;
                 }
 
                 if (byte_count != sigbit_count) {
-                    cli_dbgmsg("egg_filename_to_utf8: cleaning out %d bytes from incomplete "
+                    cli_dbgmsg("cli_codepage_to_utf8: cleaning out %d bytes from incomplete "
                                "utf-8 character length %d\n",
                                byte_count, sigbit_count);
                     for (; byte_count > 0; byte_count--, track++) {
                         *track = '\0';
                     }
                 }
             }
             break;
         }
         default: {
 
 #if defined(WIN32) && !defined(HAVE_ICONV)
 
             /*
              * Do conversion using native Win32 APIs.
              */
 
             if (1200 != codepage) { /* not already UTF16-LE (Windows Unicode) */
                 /*
                  * First, Convert from codepage -> UCS-2 LE with MultiByteToWideChar(codepage)
                  */
                 cchWideChar = MultiByteToWideChar(
                     codepage,
                     0,
                     in,
                     in_size,
                     NULL,
                     0);
                 if (0 == cchWideChar) {
-                    cli_dbgmsg("egg_filename_to_utf8: failed to determine string size needed for ansi to widechar conversion.\n");
+                    cli_dbgmsg("cli_codepage_to_utf8: failed to determine string size needed for ansi to widechar conversion.\n");
                     status = CL_EPARSE;
                     goto done;
                 }
 
-                lpWideCharStr = malloc((cchWideChar + 1) * sizeof(WCHAR));
+                lpWideCharStr = cli_malloc((cchWideChar + 1) * sizeof(WCHAR));
                 if (NULL == lpWideCharStr) {
-                    cli_dbgmsg("egg_filename_to_utf8: failed to allocate memory for wide char string.\n");
+                    cli_dbgmsg("cli_codepage_to_utf8: failed to allocate memory for wide char string.\n");
                     status = CL_EMEM;
                     goto done;
                 }
 
                 cchWideChar = MultiByteToWideChar(
                     codepage,
                     0,
                     in,
                     in_size,
                     lpWideCharStr,
                     cchWideChar + 1);
                 if (0 == cchWideChar) {
-                    cli_dbgmsg("egg_filename_to_utf8: failed to convert multibyte string to widechars.\n");
+                    cli_dbgmsg("cli_codepage_to_utf8: failed to convert multibyte string to widechars.\n");
                     status = CL_EPARSE;
                     goto done;
                 }
 
                 in      = (char*)lpWideCharStr;
                 in_size = cchWideChar;
             }
 
             /*
              * Convert from UCS-2 LE -> UTF8 with WideCharToMultiByte(CP_UTF8)
              */
             out_utf8_size = WideCharToMultiByte(
                 CP_UTF8,
                 0,
                 (LPCWCH)in,
                 in_size / sizeof(WCHAR),
                 NULL,
                 0,
                 NULL,
                 NULL);
             if (0 == out_utf8_size) {
-                cli_dbgmsg("egg_filename_to_utf8: failed to determine string size needed for widechar conversion.\n");
+                cli_dbgmsg("cli_codepage_to_utf8: failed to determine string size needed for widechar conversion.\n");
                 status = CL_EPARSE;
                 goto done;
             }
 
-            out_utf8 = malloc(out_utf8_size + 1);
+            out_utf8 = cli_malloc(out_utf8_size + 1);
             if (NULL == lpWideCharStr) {
-                cli_dbgmsg("egg_filename_to_utf8: failed to allocate memory for wide char to utf-8 string.\n");
+                cli_dbgmsg("cli_codepage_to_utf8: failed to allocate memory for wide char to utf-8 string.\n");
                 status = CL_EMEM;
                 goto done;
             }
 
             out_utf8_size = WideCharToMultiByte(
                 CP_UTF8,
                 0,
                 (LPCWCH)in,
                 in_size / sizeof(WCHAR),
                 out_utf8,
                 out_utf8_size,
                 NULL,
                 NULL);
             if (0 == out_utf8_size) {
-                cli_dbgmsg("egg_filename_to_utf8: failed to convert widechar string to utf-8.\n");
+                cli_dbgmsg("cli_codepage_to_utf8: failed to convert widechar string to utf-8.\n");
                 status = CL_EPARSE;
                 goto done;
             }
 
 #elif defined(HAVE_ICONV)
 
             uint32_t attempt, i;
             size_t inbytesleft, outbytesleft;
             const char* encoding = NULL;
 
             for (i = 0; i < NUMCODEPAGES; ++i) {
                 if (codepage == codepage_entries[i].codepage) {
                     encoding = codepage_entries[i].encoding;
                     break;
                 } else if (codepage < codepage_entries[i].codepage) {
                     break; /* fail-out early, requires sorted array */
                 }
             }
 
+            if (NULL == encoding){
+                cli_dbgmsg("cli_codepage_to_utf8: Invalid codepage parameter passed in.\n");
+                goto done;
+            }
+
             for (attempt = 1; attempt <= 3; attempt++) {
-                char* out_utf8_tmp;
-                char* out_utf8_index;
+                char * inbuf = in;
+                size_t inbufsize = inbytesleft;
+                size_t iconvRet = -1;
+
+                char* out_utf8_tmp = NULL;
+                char* out_utf8_index = NULL;
 
                 /* Charset to UTF-8 should never exceed in_size * 6;
                  * We can shrink final buffer after the conversion, if needed. */
                 out_utf8_size = (in_size * 2) * attempt;
 
                 inbytesleft  = in_size;
                 outbytesleft = out_utf8_size;
 
                 out_utf8 = cli_calloc(1, out_utf8_size + 1);
                 if (NULL == out_utf8) {
-                    cli_errmsg("egg_filename_to_utf8: Failure allocating buffer for utf8 data.\n");
+                    cli_errmsg("cli_codepage_to_utf8: Failure allocating buffer for utf8 data.\n");
                     status = CL_EMEM;
+                    goto done;
                 }
                 out_utf8_index = out_utf8;
 
                 conv = iconv_open("UTF-8//TRANSLIT", encoding);
                 if (conv == (iconv_t)-1) {
-                    cli_warnmsg("egg_filename_to_utf8: Failed to open iconv.\n");
+                    cli_warnmsg("cli_codepage_to_utf8: Failed to open iconv.\n");
                     goto done;
                 }
 
-                if ((size_t)-1 == iconv(conv, &in, &inbytesleft, &out_utf8_index, &outbytesleft)) {
+                iconvRet = iconv(conv, &inbuf, &inbufsize, &out_utf8_index, &outbytesleft);
+                iconv_close(conv);
+                conv = (iconv_t) -1;
+                if ((size_t)-1 == iconvRet){
                     switch (errno) {
                         case E2BIG:
-                            cli_warnmsg("egg_filename_to_utf8: iconv error: There is not sufficient room at *outbuf.\n");
+                            cli_warnmsg("cli_codepage_to_utf8: iconv error: There is not sufficient room at *outbuf.\n");
                             free(out_utf8);
                             out_utf8 = NULL;
                             continue; /* Try again, with a larger buffer. */
                         case EILSEQ:
-                            cli_warnmsg("egg_filename_to_utf8: iconv error: An invalid multibyte sequence has been encountered in the input.\n");
+                            cli_warnmsg("cli_codepage_to_utf8: iconv error: An invalid multibyte sequence has been encountered in the input.\n");
                             break;
                         case EINVAL:
-                            cli_warnmsg("egg_filename_to_utf8: iconv error: An incomplete multibyte sequence has been encountered in the input.\n");
+                            cli_warnmsg("cli_codepage_to_utf8: iconv error: An incomplete multibyte sequence has been encountered in the input.\n");
                             break;
                         default:
-                            cli_warnmsg("egg_filename_to_utf8: iconv error: Unexpected error code %d.\n", errno);
+                            cli_warnmsg("cli_codepage_to_utf8: iconv error: Unexpected error code %d.\n", errno);
                     }
                     status = CL_EPARSE;
                     goto done;
                 }
 
                 /* iconv succeeded, but probably didn't use the whole buffer. Free up the extra memory. */
                 out_utf8_tmp = cli_realloc(out_utf8, out_utf8_size - outbytesleft + 1);
                 if (NULL == out_utf8_tmp) {
-                    cli_errmsg("egg_filename_to_utf8: failure cli_realloc'ing converted filename.\n");
+                    cli_errmsg("cli_codepage_to_utf8: failure cli_realloc'ing converted filename.\n");
                     status = CL_EMEM;
                     goto done;
                 }
                 out_utf8      = out_utf8_tmp;
                 out_utf8_size = out_utf8_size - outbytesleft;
                 break;
             }
 
 #else
 
             /*
              * No way to do the conversion.
              */
             goto done;
 
 #endif
         }
     }
 
     *out      = out_utf8;
     *out_size = out_utf8_size;
 
     status = CL_SUCCESS;
diff --git a/libclamav/vba_extract.c b/libclamav/vba_extract.c
index 352a69129..199631473 100644
--- a/libclamav/vba_extract.c
+++ b/libclamav/vba_extract.c
@@ -360,850 +360,867 @@ static size_t vba_normalize(unsigned char *buffer, size_t size) {
 /**
  * Read a VBA project in an OLE directory.
  * Contrary to cli_vba_readdir, this function uses the dir file to locate VBA modules.
  */
 cl_error_t
  cli_vba_readdir_new(cli_ctx* ctx, const char *dir, struct uniq *U, const char *hash, uint32_t which, int *tempfd)
 {
     cl_error_t ret = CL_SUCCESS;
     char fullname[1024];
     int fd = -1;
     unsigned char *data = NULL;
     size_t data_len;
     size_t data_offset;
     const char *stream_name = NULL;
     char *tempfile = NULL;
     uint16_t codepage = CODEPAGE_ISO8859_1;
     unsigned i;
+    char *mbcs_name = NULL, *utf16_name = NULL;
+    size_t mbcs_name_size = 0, utf16_name_size = 0;
+    unsigned char *module_data = NULL, *module_data_utf8 = NULL;
+    size_t module_data_size = 0, module_data_utf8_size = 0;
 
     if (dir == NULL || hash == NULL || tempfd == NULL) {
         return CL_EARG;
     }
 
     cli_dbgmsg("vba_readdir_new: Scanning directory %s for VBA project\n", dir);
 
     snprintf(fullname, sizeof(fullname), "%s" PATHSEP "%s_%u", dir, hash, which);
     fullname[sizeof(fullname) - 1] = '\0';
     fd                             = open(fullname, O_RDONLY | O_BINARY);
 
     if (fd == -1) {
         ret = CL_EOPEN;
         goto done;
     }
 
     if ((data = cli_vba_inflate(fd, 0, &data_len)) == NULL) {
         cli_dbgmsg("vba_readdir_new: Failed to decompress 'dir'\n");
         ret = CL_EARG;
         goto done;
     }
 
     if ((ret = cli_gentempfd(ctx->engine->tmpdir, &tempfile, tempfd)) != CL_SUCCESS) {
          cli_warnmsg("vba_readdir_new: VBA project cannot be dumped to file\n");
          goto done;
     }
 
     cli_dbgmsg("Dumping VBA project from dir %s to file %s\n", fullname, tempfile);
 
 #define CLI_WRITEN(msg, size) \
     do { \
         if (cli_writen(*tempfd, msg, size) != size) { \
             cli_warnmsg("vba_readdir_new: Failed to write to output file\n"); \
             ret = CL_EWRITE; \
             goto done; \
         } \
     } while (0)
 
 #define CLI_WRITENHEX(msg, size) \
     do { \
         unsigned i; \
         for (i = 0; i < size; ++i) { \
             char buf[4]; \
             if (snprintf(buf, sizeof(buf), "%02x", (msg)[i]) != 2) { \
                 cli_warnmsg("vba_readdir_new: Failed to write nex data to output file\n"); \
                 ret = CL_EWRITE; \
                 goto done; \
             } \
             CLI_WRITEN(buf, 2); \
         } \
     } while (0)
 
 #define CLI_WRITEN_MBCS(msg, size) \
     do { \
         char *utf8 = NULL; \
         size_t utf8_size; \
         if (size > 0) { \
             if (CL_SUCCESS == cli_codepage_to_utf8((char *) &data[data_offset], size, codepage, &utf8, &utf8_size)) { \
                 CLI_WRITEN(utf8, utf8_size); \
                 free(utf8); \
                 utf8 = NULL; \
             } else { \
                 cli_errmsg("cli_vba_readdir_new: failed to convert codepage %" PRIu16 " to UTF-8\n", codepage); \
                 CLI_WRITEN("<error decoding string>", 23); \
             } \
         } \
     } while (0)
 
 #define CLI_WRITEN_UTF16LE(msg, size) \
     do { \
         char *utf8 = NULL; \
         size_t utf8_size; \
         if (size > 0) { \
             if (CL_SUCCESS == cli_codepage_to_utf8((char *) &data[data_offset], size, CODEPAGE_UTF16_LE, &utf8, &utf8_size)) { \
                 CLI_WRITEN(utf8, utf8_size); \
                 free(utf8); \
                 utf8 = NULL; \
             } else { \
                 cli_errmsg("cli_vba_readdir_new: failed to convert UTF16LE to UTF-8\n"); \
                 CLI_WRITEN("<error decoding string>", 23); \
             } \
         } \
     } while (0)
 
     CLI_WRITEN("REM VBA project extracted from Microsoft Office document\n\n", 58);
 
     for (data_offset = 0; data_offset < data_len;) {
         uint16_t id;
         uint32_t size;
 
         if (data_offset + 2 > data_len) {
             cli_warnmsg("vba_readdir_new: Failed to read record type from dir\n");
             ret = CL_EREAD;
             goto done;
         }
         id = le16_to_host(*(uint16_t *) &data[data_offset]);
         data_offset += 2;
 
         if (data_offset + 4 > data_len) {
             cli_warnmsg("vba_readdir_new: Failed to read record size from dir\n");
             ret = CL_EREAD;
             goto done;
         }
         size = le32_to_host(*(uint32_t *) &data[data_offset]);
         data_offset += 4;
 
         if (size > data_len - data_offset) {
             cli_warnmsg("vba_readdir_new: Record stretches past the end of the file\n");
             ret = CL_EREAD;
             goto done;
         }
 
 
         switch (id) {
             //MS-OVBA 2.3.4.2.1.1 PROJECTSYSKIND
             case 0x0001: {
                 if (size != 4) {
                     cli_dbgmsg("cli_vba_readdir_new: Expected PROJECTSYSKIND record size (%" PRIu32 " != 4)\n", size);
                     ret = CL_EREAD;
                     goto done;
                 }
                 uint32_t sys_kind = le32_to_host(*(uint32_t *) &data[data_offset]);
                 data_offset += 4;
                 CLI_WRITEN("REM PROJECTSYSKIND: ", 20);
                 switch (sys_kind) {
                     case 0x0:
                         CLI_WRITEN("Windows 16 bit", 14);
                         break;
                     case 0x1:
                         CLI_WRITEN("Windows 32 bit", 14);
                         break;
                     case 0x2:
                         CLI_WRITEN("Macintosh", 9);
                         break;
                     case 0x3:
                         CLI_WRITEN("Windows 64 bit", 14);
                         break;
                     default: {
                         char str_sys_kind[22];
                         int len = snprintf(str_sys_kind, sizeof(str_sys_kind), "Unknown (0x%x)", sys_kind);
                         str_sys_kind[sizeof(str_sys_kind) - 1] = '\0';
                         if (len > 0) {
                             CLI_WRITEN(str_sys_kind, (size_t) len);
                         }
                         break;
                     }
                 }
                 CLI_WRITEN("\n", 1);
                 break;
             }
             //MS-OVBA 2.3.4.2.1.2 PROJECTLCID
             case 0x0002: {
                 if (size != 4) {
                     cli_dbgmsg("cli_vba_readdir_new: Expected PROJECTLCID record size (%" PRIu32 " != 4)\n", size);
                     ret = CL_EREAD;
                     goto done;
                 }
                 uint32_t lcid = le32_to_host(*(uint32_t *) &data[data_offset]);
                 char buf[64];
                 data_offset += 4;
                 int buf_length = snprintf(buf, sizeof(buf), "REM PROJECTLCID: 0x%08x\n", lcid);
                 buf[sizeof(buf) - 1] = '\0';
                 if (buf_length > 0) {
                     CLI_WRITEN(buf, (size_t) buf_length);
                 }
                 break;
             }
             //MS-OVBA 2.3.4.2.1.3 PROJECTLCIDINVOKE
             case 0x0014: {
                 if (size != 4) {
                     cli_dbgmsg("cli_vba_readdir_new: Expected PROJECTLCIDINVOKE record size (%" PRIu32 " != 4)\n", size);
                     ret = CL_EREAD;
                     goto done;
                 }
                 uint32_t lcid_invoke = le32_to_host(*(uint32_t *) &data[data_offset]);
                 char buf[64];
                 data_offset += 4;
                 int buf_length = snprintf(buf, sizeof(buf), "REM PROJECTLCIDINVOKE: 0x%08x\n", lcid_invoke);
                 buf[sizeof(buf) - 1] = '\0';
                 if (buf_length > 0) {
                     CLI_WRITEN(buf, (size_t) buf_length);
                 }
                 break;
             }
             //MS-OVBA 2.3.4.2.1.4 PROJECTCODEPAGE
             case 0x0003: {
                 if (size != 2) {
                     cli_dbgmsg("cli_vba_readdir_new: Expected PROJECTCODEPAGE record size (%" PRIu32 " != 2)\n", size);
                     ret = CL_EREAD;
                     goto done;
                 }
                 codepage = le16_to_host(*(uint16_t *) &data[data_offset]);
                 char buf[64];
                 data_offset += 2;
                 int buf_length = snprintf(buf, sizeof(buf), "REM PROJECTCODEPAGE: 0x%04x\n", codepage);
                 buf[sizeof(buf) - 1] = '\0';
                 if (buf_length > 0) {
                     CLI_WRITEN(buf, (size_t) buf_length);
                 }
                 break;
             }
             //MS-OVBA 2.3.4.2.1.5 PROJECTNAME
             case 0x0004: {
                 if (size < 1 || size > 128) {
                     cli_dbgmsg("cli_vba_readdir_new: Expected PROJECTNAME record size (1 <= %" PRIu32 " <= 128)\n", size);
                     ret = CL_EREAD;
                     goto done;
                 }
 
                 CLI_WRITEN("REM PROJECTNAME: ", 17);
                 CLI_WRITEN_MBCS(&data[data_offset], size);
                 data_offset += size;
                 CLI_WRITEN("\n", 1);
                 break;
             }
             //MS-OVBA 2.3.4.2.1.6 PROJECTDOCSTRING
             case 0x0005: {
                 if (size > 2000) {
                     cli_dbgmsg("cli_vba_readdir_new: Expected PROJECTDOCSTRING record size (%" PRIu32 " <= 2000)\n", size);
                     ret = CL_EREAD;
                     goto done;
                 }
 
                 CLI_WRITEN("REM PROJECTDOCSTRING: ", 22);
                 CLI_WRITEN_MBCS(&data[data_offset], size);
                 data_offset += size;
                 CLI_WRITEN("\n", 1);
                 break;
             }
             //MS-OVBA 2.3.4.2.1.6 PROJECTDOCSTRING Unicode
             case 0x0040: {
                 if (size % 2 != 0) {
                     cli_dbgmsg("cli_vba_readdir_new: Expected PROJECTDOCSTRINGUNICODE record size (%" PRIu32 " but should be even)\n", size);
                     ret = CL_EREAD;
                     goto done;
                 }
                 CLI_WRITEN("REM PROJECTDOCSTRINGUNICODE: ", 29);
                 CLI_WRITEN_UTF16LE(&data[data_offset], size);
                 data_offset += size;
                 CLI_WRITEN("\n", 1);
                 break;
             }
             //MS-OVBA 2.3.4.2.1.7 PROJECTHELPFILEPATH
             case 0x0006: {
                 if (size > 260) {
                     cli_dbgmsg("cli_vba_readdir_new: Expected PROJECTHELPFILEPATH record size (%" PRIu32 " <= 260)\n", size);
                     ret = CL_EREAD;
                     goto done;
                 }
                 const size_t projecthelpfilepath_offset = data_offset;
                 CLI_WRITEN("REM PROJECTHELPFILEPATH: ", 25);
                 CLI_WRITEN_MBCS(&data[data_offset], size);
                 data_offset += size;
                 CLI_WRITEN("\n", 1);
 
                 if (data_offset + 2 > data_len) {
                     cli_warnmsg("vba_readdir_new: Failed to read record type from dir\n");
                     ret = CL_EREAD;
                     goto done;
                 }
                 id = le16_to_host(*(uint16_t *) &data[data_offset]);
                 if (id != 0x003d) {
                     cli_warnmsg("vba_readdir_new: PROJECTHELPFILEPATH is not followed by PROJECTHELPFILEPATH2\n");
                     CLI_WRITEN("REM WARNING: PROJECTHELPFILEPATH is not followed by PROJECTHELPFILEPATH2\n", 73);
                     continue;
                 }
                 data_offset += 2;
 
                 if (data_offset + 4 > data_len) {
                     cli_warnmsg("vba_readdir_new: Failed to read record size of PROJECTHELPFILEPATH2 record from dir\n");
                     ret = CL_EREAD;
                     goto done;
                 }
                 uint32_t size2;
                 size2 = le32_to_host(*(uint32_t *) &data[data_offset]);
                 data_offset += 4;
 
                 if (data_offset + size > data_len) {
                     cli_warnmsg("vba_readdir_new: PROJECTHELPFILEPATH2 record stretches past the end of the file\n");
                     ret = CL_EREAD;
                     goto done;
                 }
 
                 if (size2 > 260) {
                     cli_dbgmsg("cli_vba_readdir_new: Expected PROJECTHELPFILEPATH2 record size (%" PRIu32 " <= 260)\n", size);
                     ret = CL_EREAD;
                     goto done;
                 }
 
                 if (size != size2) {
                     CLI_WRITEN("REM WARNING: PROJECTHELPFILEPATH and PROJECTHELPFILEPATH2 record sizes differ\n", 78);
                 }
                 else {
                     if (memcmp(&data[projecthelpfilepath_offset], &data[data_offset], size) != 0) {
                         CLI_WRITEN("REM WARNING: PROJECTHELPFILEPATH and PROJECTHELPFILEPATH2 contents differ\n", 74);
                     }
                 }
 
                 CLI_WRITEN("REM PROJECTHELPFILEPATH2: ", 26);
                 CLI_WRITEN_UTF16LE(&data[data_offset], size2);
                 data_offset += size2;
                 CLI_WRITEN("\n", 1);
                 break;
             }
             //MS-OVBA 2.3.4.2.1.8 PROJECTHELPCONTEXT
             case 0x0007: {
                 if (size != 4) {
                     cli_dbgmsg("cli_vba_readdir_new: Expected PROJECTHELPCONTEXT record size (%" PRIu32 " != 4)\n", size);
                     ret = CL_EREAD;
                     goto done;
                 }
                 uint32_t context = le32_to_host(*(uint32_t *) &data[data_offset]);
                 char buf[64];
                 data_offset += 4;
                 int buf_length = snprintf(buf, sizeof(buf), "REM PROJECTHELPCONTEXT: 0x%04x\n", context);
                 buf[sizeof(buf) - 1] = '\0';
                 if (buf_length > 0) {
                     CLI_WRITEN(buf, (size_t) buf_length);
                 }
                 break;
             }
             //MS-OVBA 2.3.4.2.1.9 PROJECTLIBFLAGS
             case 0x0008: {
                 if (size != 4) {
                     cli_dbgmsg("cli_vba_readdir_new: Expected PROJECTLIBFLAGS record size (%" PRIu32 " != 4)\n", size);
                     ret = CL_EREAD;
                     goto done;
                 }
                 uint32_t libflags = le32_to_host(*(uint32_t *) &data[data_offset]);
                 char buf[64];
                 data_offset += 4;
                 int buf_length = snprintf(buf, sizeof(buf), "REM PROJECTLIBFLAGS: 0x%04x\n", libflags);
                 buf[sizeof(buf) - 1] = '\0';
                 if (buf_length > 0) {
                     CLI_WRITEN(buf, (size_t) buf_length);
                 }
                 break;
             }
             //MS-OVBA 2.3.4.2.1.10 PROJECTVERSION
             case 0x0009: {
                 //The PROJECTVERSION record size is expected to be 4, even though the record size is 6.
                 if (size != 4) {
                     cli_dbgmsg("cli_vba_readdir_new: Expected PROJECTVERSION record size (%" PRIu32 " != 4)\n", size);
                     ret = CL_EREAD;
                     goto done;
                 }
                 uint32_t major = le32_to_host(*(uint32_t *) &data[data_offset]);
                 data_offset += 4;
                 if (data_offset + 2 > data_len) {
                     cli_warnmsg("vba_readdir_new: PROJECTVERSION record stretches past the end of the file\n");
                     ret = CL_EREAD;
                     goto done;
                 }
                 uint16_t minor = le16_to_host(*(uint16_t *) &data[data_offset]);
                 data_offset += 2;
                 char buf[64];
                 int buf_length = snprintf(buf, sizeof(buf), "REM PROJECTVERSION: %u.%u\n", major, minor);
                 buf[sizeof(buf) - 1] = '\0';
                 if (buf_length > 0) {
                     CLI_WRITEN(buf, (size_t) buf_length);
                 }
                 break;
             }
             //MS-OVBA 2.3.4.2.3 PROJECTMODULES
             case 0x000f: {
                 if (size != 2) {
                     cli_dbgmsg("cli_vba_readdir_new: Expected PROJECTMODULES record size\n");
                     ret = CL_EREAD;
                     goto done;
                 }
                 uint16_t modules = le16_to_host(*(uint16_t *) &data[data_offset]);
                 data_offset += 2;
                 char buf[64];
                 int buf_length = snprintf(buf, sizeof(buf), "REM PROJECTMODULES: %u\n", modules);
                 buf[sizeof(buf) - 1] = '\0';
                 if (buf_length > 0) {
                     CLI_WRITEN(buf, (size_t) buf_length);
                 }
                 break;
             }
             //MS-OVBA 2.3.4.2.3.1 PROJECTCOOKIE
             case 0x0013: {
                 if (size != 2) {
                     cli_dbgmsg("cli_vba_readdir_new: Expected PROJECTCOOKIE record size\n");
                     ret = CL_EREAD;
                     goto done;
                 }
                 uint16_t cookie = le16_to_host(*(uint16_t *) &data[data_offset]);
                 data_offset += 2;
                 char buf[64];
                 int buf_length = snprintf(buf, sizeof(buf), "REM PROJECTCOOKIE: 0x%04x\n", cookie);
                 buf[sizeof(buf) - 1] = '\0';
                 if (buf_length > 0) {
                     CLI_WRITEN(buf, (size_t) buf_length);
                 }
                 break;
             }
             //MS-OVBA 2.3.4.2.3.2 MODULE record
             case 0x0019: {
-                char *mbcs_name = NULL, *utf16_name = NULL;
-                size_t mbcs_name_size, utf16_name_size;
 
                 //MS-OVBA 2.3.4.2.3.2.1 MODULENAME
                 CLI_WRITEN("\n\nREM MODULENAME: ", 18);
                 if (size > 0) {
                     if (CL_SUCCESS == cli_codepage_to_utf8((char *) &data[data_offset], size, codepage, &mbcs_name, &mbcs_name_size)) {
                         CLI_WRITEN(mbcs_name, mbcs_name_size);
                     } else { \
                         cli_errmsg("cli_vba_readdir_new: failed to convert codepage %" PRIu16 " to UTF-8\n", codepage);
                         CLI_WRITEN("<error decoding string>", 23);
                     }
                 }
                 data_offset += size;
 
                 //MS-OVBA 2.3.4.2.3.2.2 MODULENAMEUNICODE
                 if ((id = le16_to_host(*(uint16_t *) &data[data_offset])) != 0x0047) {
                     cli_dbgmsg("cli_vba_readdir_new: Expected MODULENAMEUNICODE (0x47) record, but got 0x%04x\n", id);
                     ret = CL_EREAD;
                     if (mbcs_name) {
                         free(mbcs_name);
                         mbcs_name = NULL;
                     }
                     goto done;
                 }
                 cli_dbgmsg("Reading MODULENAMEUNICODE record\n");
                 data_offset += 2;
                 CLI_WRITEN("\nREM MODULENAMEUNICODE: ", 24);
                 size = le32_to_host(*(uint32_t *) &data[data_offset]);
                 data_offset += 4;
 
                 if (size > data_len - data_offset) {
                     cli_dbgmsg("vba_readdir_new: MODULENAMEUNICODE stretches past the end of the file\n");
                     ret = CL_EREAD;
                     goto done;
                 }
 
                 if (size > 0) {
                     if (CL_SUCCESS == cli_codepage_to_utf8((char *) &data[data_offset], size, CODEPAGE_UTF16_LE, &utf16_name, &utf16_name_size)) {
                         CLI_WRITEN(utf16_name, utf16_name_size);
                     } else {
                         cli_errmsg("cli_vba_readdir_new: failed to convert UTF16LE to UTF-8\n");
                         CLI_WRITEN("<error decoding string>", 23);
                     }
                 }
                 data_offset += size;
 
                 if (mbcs_name && utf16_name &&
                     (mbcs_name_size != utf16_name_size ||
                      memcmp(mbcs_name, utf16_name, mbcs_name_size) != 0))
                 {
                     CLI_WRITEN("\nREM WARNING: MODULENAME and MODULENAMEUNICODE differ", 53);
                 }
 
                 if (mbcs_name) {
                     free(mbcs_name);
                     mbcs_name = NULL;
                 }
                 if (utf16_name) {
                     free(utf16_name);
                     utf16_name = NULL;
                 }
 
                 //MS-OVBA 2.3.4.2.3.2.3 MODULESTREAMNAME
                 if ((id = le16_to_host(*(uint16_t *) &data[data_offset])) != 0x001a) {
                     cli_dbgmsg("cli_vba_readdir_new: Expected MODULESTREAMNAME (0x1a) record, but got 0x%04x\n", id);
                     ret = CL_EREAD;
                     goto done;
                 }
                 cli_dbgmsg("Reading MODULESTREAMNAME record\n");
                 data_offset += 2;
                 CLI_WRITEN("\nREM MODULESTREAMNAME: ", 23);
                 size = le32_to_host(*(uint32_t *) &data[data_offset]);
                 data_offset += 4;
 
                 if (size > data_len - data_offset) {
                     cli_dbgmsg("vba_readdir_new: MODULESTREAMNAME stretches past the end of the file\n");
                     ret = CL_EREAD;
                     goto done;
                 }
 
                 if (size > 0) {
                     if (CL_SUCCESS == cli_codepage_to_utf8((char *) &data[data_offset], size, codepage, &mbcs_name, &mbcs_name_size)) {
                         CLI_WRITEN(mbcs_name, mbcs_name_size);
                     } else { \
                         cli_errmsg("cli_vba_readdir_new: failed to convert codepage %" PRIu16 " to UTF-8\n", codepage);
                         CLI_WRITEN("<error decoding string>", 23);
                     }
                 }
                 data_offset += size;
                 if ((id = le16_to_host(*(uint16_t *) &data[data_offset])) != 0x0032) {
                     cli_dbgmsg("cli_vba_readdir_new: Expected MODULESTREAMNAMEUNICODE (0x32) record, but got 0x%04x\n", id);
                     ret = CL_EREAD;
                     if (mbcs_name) {
                         free(mbcs_name);
                         mbcs_name = NULL;
                     }
                     goto done;
                 }
                 cli_dbgmsg("Reading MODULESTREAMNAMEUNICODE record\n");
                 data_offset += 2;
                 CLI_WRITEN("\nREM MODULESTREAMNAMEUNICODE: ", 30);
                 uint32_t module_stream_name_size = le32_to_host(*(uint32_t *) &data[data_offset]);
                 data_offset += 4;
                 const unsigned char* module_stream_name = &data[data_offset];
                 if (size > 0) {
                     if (CL_SUCCESS == cli_codepage_to_utf8((char *) &data[data_offset], module_stream_name_size, CODEPAGE_UTF16_LE, &utf16_name, &utf16_name_size)) {
                         CLI_WRITEN(utf16_name, utf16_name_size);
                     } else {
                         cli_errmsg("cli_vba_readdir_new: failed to convert UTF16LE to UTF-8\n");
                         CLI_WRITEN("<error decoding string>", 23);
                     }
                 }
                 data_offset += module_stream_name_size;
 
                 if (mbcs_name && utf16_name &&
                     (mbcs_name_size != utf16_name_size ||
                      memcmp(mbcs_name, utf16_name, mbcs_name_size) != 0))
                 {
                     CLI_WRITEN("\nREM WARNING: MODULESTREAMNAME and MODULESTREAMNAMEUNICODE differ", 65);
 
                 }
 
                 if (mbcs_name) {
                     free(mbcs_name);
                     mbcs_name = NULL;
                 }
                 if (utf16_name) {
                     free(utf16_name);
                     utf16_name = NULL;
                 }
 
                 //MS-OVBA 2.3.4.2.3.2.4 MODULEDOCSTRING
                 if ((id = le16_to_host(*(uint16_t *) &data[data_offset])) != 0x001c) {
                     cli_dbgmsg("cli_vba_readdir_new: Expected MODULEDOCSTRING (0x1c) record, but got 0x%04x\n", id);
                     ret = CL_EREAD;
                     goto done;
                 }
                 cli_dbgmsg("Reading MODULEDOCSTRING record\n");
                 data_offset += 2;
                 CLI_WRITEN("\nREM MODULEDOCSTRING: ", 22);
                 size = le32_to_host(*(uint32_t *) &data[data_offset]);
                 data_offset += 4;
 
                 if (size > data_len - data_offset) {
                     cli_dbgmsg("vba_readdir_new: MODULEDOCSTRING stretches past the end of the file\n");
                     ret = CL_EREAD;
                     goto done;
                 }
 
                 if (size > 0) {
                     if (CL_SUCCESS == cli_codepage_to_utf8((char *) &data[data_offset], size, codepage, &mbcs_name, &mbcs_name_size)) {
                         CLI_WRITEN(mbcs_name, mbcs_name_size);
                     } else { \
                         cli_errmsg("cli_vba_readdir_new: failed to convert codepage %" PRIu16 " to UTF-8\n", codepage);
                         CLI_WRITEN("<error decoding string>", 23);
                     }
                 }
                 data_offset += size;
                 if ((id = le16_to_host(*(uint16_t *) &data[data_offset])) != 0x0048) {
                     cli_dbgmsg("cli_vba_readdir_new: Expected MODULEDOCSTRINGUNICODE (0x32) record, but got 0x%04x\n", id);
                     ret = CL_EREAD;
                     if (mbcs_name) {
                         free(mbcs_name);
                         mbcs_name = NULL;
                     }
                     goto done;
                 }
                 cli_dbgmsg("Reading MODULEDOCSTRINGUNICODE record\n");
                 data_offset += 2;
                 CLI_WRITEN("\nREM MODULEDOCSTRINGUNICODE: ", 29);
                 size = le32_to_host(*(uint32_t *) &data[data_offset]);
                 data_offset += 4;
 
                 if (size > data_len - data_offset) {
                     cli_dbgmsg("vba_readdir_new: MODULEDOCSTRINGUNICODE stretches past the end of the file\n");
                     ret = CL_EREAD;
                     goto done;
                 }
 
                 if (size > 0) {
                     if (CL_SUCCESS == cli_codepage_to_utf8((char *) &data[data_offset], size, CODEPAGE_UTF16_LE, &utf16_name, &utf16_name_size)) {
                         CLI_WRITEN(utf16_name, utf16_name_size);
                     } else {
                         cli_errmsg("cli_vba_readdir_new: failed to convert UTF16LE to UTF-8\n");
                         CLI_WRITEN("<error decoding string>", 23);
                     }
                 }
                 data_offset += size;
 
                 if (mbcs_name && utf16_name &&
                     (mbcs_name_size != utf16_name_size ||
                      memcmp(mbcs_name, utf16_name, mbcs_name_size) != 0))
                 {
                     CLI_WRITEN("\nREM WARNING: MODULEDOCSTRING and MODULEDOCSTRINGUNICODE differ", 63);
 
                 }
 
                 if (mbcs_name) {
                     free(mbcs_name);
                     mbcs_name = NULL;
                 }
                 if (utf16_name) {
                     free(utf16_name);
                     utf16_name = NULL;
                 }
 
                 //MS-OVBA 2.3.4.2.3.2.5 MODULEOFFSET
                 if ((id = le16_to_host(*(uint16_t *) &data[data_offset])) != 0x0031) {
                     cli_dbgmsg("cli_vba_readdir_new: Expected MODULEOFFSET (0x31) record, but got 0x%04x\n", id);
                     ret = CL_EREAD;
                     goto done;
                 }
                 cli_dbgmsg("Reading MODULEOFFSET record\n");
                 data_offset += 2;
                 size = le32_to_host(*(uint32_t *) &data[data_offset]);
                 data_offset += 4;
                 if (size != 4) {
                     cli_dbgmsg("cli_vba_readdir_new: Expected MODULEOFFSET record size");
                     ret = CL_EREAD;
                     goto done;
                 }
                 uint32_t module_offset = le32_to_host(*(uint32_t *) &data[data_offset]);
                 data_offset += 4;
                 char buffer[64];
                 int buffer_size = snprintf(buffer, sizeof(buffer), "\nREM MODULEOFFSET: 0x%08x", module_offset);
                 if (buffer_size > 0) {
                     CLI_WRITEN(buffer, (size_t) buffer_size);
                 }
 
                 //MS-OVBA 2.3.4.2.3.2.6 MODULEHELPCONTEXT
                 if ((id = le16_to_host(*(uint16_t *) &data[data_offset])) != 0x001e) {
                     cli_dbgmsg("cli_vba_readdir_new: Expected MODULEHELPCONTEXT (0x1e) record, but got 0x%04x\n", id);
                     ret = CL_EREAD;
                     goto done;
                 }
                 cli_dbgmsg("Reading MODULEHELPCONTEXT record\n");
                 data_offset += 2;
                 size = le32_to_host(*(uint32_t *) &data[data_offset]);
                 data_offset += 4;
                 if (size != 4) {
                     cli_dbgmsg("cli_vba_readdir_new: Expected MODULEHELPCONTEXT record size");
                     ret = CL_EREAD;
                     goto done;
                 }
                 uint32_t help_context = le32_to_host(*(uint32_t *) &data[data_offset]);
                 data_offset += 4;
                 buffer_size = snprintf(buffer, sizeof(buffer), "\nREM MODULEHELPCONTEXT: 0x%08x", help_context);
                 if (buffer_size > 0) {
                     CLI_WRITEN(buffer, (size_t) buffer_size);
                 }
 
                 //MS-OVBA 2.3.4.2.3.2.7 MODULECOOKIE
                 if ((id = le16_to_host(*(uint16_t *) &data[data_offset])) != 0x002c) {
                     cli_dbgmsg("cli_vba_readdir_new: Expected MODULECOOKIE (0x2c) record, but got 0x%04x\n", id);
                     ret = CL_EREAD;
                     goto done;
                 }
                 cli_dbgmsg("Reading MODULECOOKIE record\n");
                 data_offset += 2;
                 size = le32_to_host(*(uint32_t *) &data[data_offset]);
                 data_offset += 4;
                 if (size != 2) {
                     cli_dbgmsg("cli_vba_readdir_new: Expected MODULECOOKIE record size");
                     ret = CL_EREAD;
                     goto done;
                 }
                 uint16_t cookie = le32_to_host(*(uint16_t *) &data[data_offset]);
                 data_offset += 2;
                 buffer_size = snprintf(buffer, sizeof(buffer), "\nREM MODULECOOKIE: 0x%04x", cookie);
                 if (buffer_size > 0) {
                     CLI_WRITEN(buffer, (size_t) buffer_size);
                 }
 
                 //MS-OVBA 2.3.4.2.3.2.8 MODULETYPE
                 id = le16_to_host(*(uint16_t *) &data[data_offset]);
                 if (id != 0x0021 && id != 0x0022) {
                     cli_dbgmsg("cli_vba_readdir_new: Expected MODULETYPE (0x21/0x22) record, but got 0x%04x\n", id);
                     ret = CL_EREAD;
                     goto done;
                 }
                 data_offset += 2;
                 size = le32_to_host(*(uint32_t *) &data[data_offset]);
                 data_offset += 4;
                 if (size != 0) {
                     cli_dbgmsg("cli_vba_readdir_new: Expected MODULETYPE record size");
                     ret = CL_EREAD;
                     goto done;
                 }
                 if (id == 0x21) {
                     CLI_WRITEN("\nREM MODULETYPE: Procedural", 27);
                 }
                 else {
                     CLI_WRITEN("\nREM MODULETYPE: Class", 22);
                 }
 
                 //MS-OVBA 2.3.4.2.3.2.9 MODULEREADONLY
                 id = le16_to_host(*(uint16_t *) &data[data_offset]);
                 if (id == 0x0025) {
                     data_offset += 2;
                     size = le16_to_host(*(uint16_t *) &data[data_offset]);
                     data_offset += 4;
                     if (size != 0) {
                         cli_dbgmsg("cli_vba_readdir_new: Expected MODULEREADONLY record size");
                         ret = CL_EREAD;
                         goto done;
                     }
                     CLI_WRITEN("\nREM MODULEREADONLY", 19);
                     id = le16_to_host(*(uint16_t *) &data[data_offset]);
                 }
 
                 //MS-OVBA 2.3.4.2.3.2.10 MODULEPRIVATE
                 if (id == 0x0028) {
                     data_offset += 2;
                     size = le32_to_host(*(uint32_t *) &data[data_offset]);
                     data_offset += 4;
                     if (size != 0) {
                         cli_dbgmsg("cli_vba_readdir_new: Expected MODULEPRIVATE record size");
                         ret = CL_EREAD;
                         goto done;
                     }
                     CLI_WRITEN("\nREM MODULEPRIVATE", 18);
                     id = le16_to_host(*(uint16_t *) &data[data_offset]);
                 }
 
                 //Terminator
                 if (id != 0x002b) {
                     size = le32_to_host(*(uint32_t *) &data[data_offset]);
                     data_offset += 4;
                     if (size != 0) {
                         cli_dbgmsg("cli_vba_readdir_new: Expected MODULETERMINATOR record size");
                         ret = CL_EREAD;
                         goto done;
                     }
                 }
 
                 CLI_WRITEN("\nREM ##################################################\n", 56);
 
                 stream_name = cli_ole2_get_property_name2((const char *) module_stream_name, (int) (module_stream_name_size + 2));
                 char *module_hash;
                 uint32_t module_hashcnt;
                 if (stream_name == NULL) {
                     ret = CL_EMEM;
                     goto done;
                 }
                 if (uniq_get(U, stream_name, (uint32_t) strlen(stream_name), &module_hash, &module_hashcnt) != CL_SUCCESS) {
                     cli_dbgmsg("cli_vba_readdir_new: Cannot find module stream %s\n", stream_name);
                     ret = CL_EOPEN;
                     goto done;
                 }
 
                 int module_stream_found = 0;
 
                 for (i = 1; i <= module_hashcnt; ++i) {
                     char module_filename[PATH_MAX];
                     snprintf(module_filename, sizeof(module_filename), "%s" PATHSEP "%s_%u", dir, module_hash, i);
                     module_filename[sizeof(module_filename) - 1] = '\0';
 
                     int module_fd = open(module_filename, O_RDONLY | O_BINARY);
                     if (module_fd == -1) {
                         continue;
                     }
 
-                    unsigned char *module_data, *module_data_utf8 = NULL;
-                    size_t module_data_size = 0, module_data_utf8_size;
-
                     module_data = cli_vba_inflate(module_fd, module_offset, &module_data_size);
                     if (!module_data) {
                         cli_dbgmsg("cli_vba_readdir_new: Failed to extract module data\n");
                         close(module_fd);
                         continue;
                     }
 
                     close(module_fd);
 
                     if (CL_SUCCESS == cli_codepage_to_utf8((char *) module_data, module_data_size, codepage, (char **) &module_data_utf8, &module_data_utf8_size)) {
                         module_data_utf8_size = vba_normalize(module_data_utf8, module_data_utf8_size);
 
                         CLI_WRITEN(module_data_utf8, module_data_utf8_size);
                         module_stream_found = 1;
                         free(module_data_utf8);
                         module_data_utf8 = NULL;
                     }
                     else {
                         CLI_WRITEN("\n<Error decoding module data>\n", 30);
                         cli_dbgmsg("cli_vba_readdir_new: Failed to decode VBA module content from codepage %" PRIu16 " to UTF8\n", codepage);
                     }
 
                     free(module_data);
                     module_data = NULL;
                     break;
                 }
 
                 if (!module_stream_found) {
                     cli_dbgmsg("cli_vba_readdir_new: Cannot find module stream %s\n", stream_name);
                 }
                 free((void *) stream_name);
                 stream_name = NULL;
 
                 break;
             }
             case 0x0010: { //Terminator
                 ret = CL_SUCCESS;
                 goto done;
             }
             default: {
                 data_offset += size;
             }
         }
     }
 
 #undef CLI_WRITEN
 #undef CLI_WRITENHEX
+#undef CLI_WRITEN_MBCS
+#undef CLI_WRITEN_UTF16LE
 
 done:
     if (fd >= 0) {
         close(fd);
     }
     if (data) {
         free((void *) data);
     }
     if (stream_name) {
         free((void *) stream_name);
     }
     if (tempfile) {
         free(tempfile);
     }
     if (ret != CL_SUCCESS && *tempfd >= 0) {
         close(*tempfd);
         *tempfd = -1;
     }
+    if (utf16_name) {
+        free(utf16_name);
+        utf16_name = NULL;
+    }
+    if (mbcs_name) {
+        free(mbcs_name);
+        mbcs_name = NULL;
+    }
+    if (module_data){
+        free(module_data);
+        module_data = NULL;
+    }
+    if (module_data_utf8){
+        free(module_data_utf8);
+        module_data_utf8 = NULL;
+    }
 
     return ret;
 }
