commit 6072c461c12be6f947492aaf7d6d77f31341df7c
Author: Yermalayeu Ihar <ermig@tut.by>
Date:   Wed Jan 19 11:23:34 2022 +0300

    *fix bug: Error in SSE4.1, AVX2, AVX-512BW optimizations of function BgraToRgba.

diff --git a/docs/2022.html b/docs/2022.html
index 0c7b7ed2..a4e0e84a 100644
--- a/docs/2022.html
+++ b/docs/2022.html
@@ -1,96 +1,100 @@
 <html>
 <head>
 <meta http-equiv="Content-Type" content="text/html" />
 <title>Simd Library Release Notes (2022)</title>
 </head>
 <body> <center><table width=1024><tr><td>
 <a id="HOME"><a>
 <center>
 <img width="200" height="100" src="logo.png">
 <h1>Simd Library Release Notes (2022).</h1>
 <a href="index.html">Home</a> |
 <a href="2021.html">Release Notes</a> | 
 <a href="download.html">Download</a> | 
 <a href="help/index.html">Documentation</a> | 
 <a href="http://github.com/ermig1979/Simd/issues">Issues</a> | 
 <a href="http://github.com/ermig1979/Simd" target="_top">GitHub</a> 
 </center>
 <hr/> 
 </td></tr><tr><td>
 
 <center>
  <a href="2022.html">2022</a> |
  <a href="2021.html">2021</a> |
  <a href="2020.html">2020</a> |
  <a href="2019.html">2019</a> |
  <a href="2018.html">2018</a> |
  <a href="2017.html">2017</a> |
  <a href="2016.html">2016</a> |
  <a href="2015.html">2015</a> |
  <a href="2014.html">2014</a> |
  <a href="2013.html">2013</a>
 </center>
 
 <hr/>
 
 <h3 id="R110">February X, 2022 (future version X.X.110)</h3> 
 <h4>Algorithms</h4>
 <h5>New features</h5>
 <ul>
  <li>Base implementation of ResizerByteBicubic class.</li>
 </ul>
+<h5>Bug fixing</h5>
+<ul>
+ <li>Error in SSE4.1, AVX2, AVX-512BW optimizations of function BgraToRgba.</li>
+</ul>
 
 <a href="#HOME">Home</a> 
 <hr/>
 <h3 id="R109">January 3, 2022 (future version 4.9.109)</h3> 
 <h4>Algorithms</h4>
 <h5>New features</h5>
 <ul>
  <li>Parameter Uyvy422ToBgr to function.</li>
  <li>SSE4.1, AVX2 optimizations of function Uyvy422ToBgr.</li>
  <li>Base implementation, SSE4.1, AVX2 optimizations of function Uyvy422ToYuv420p.</li>
  <li>Base implementation, SSE4.1, AVX2, AVX-512BW optimizations of function Base64Encode.</li>
  <li>Base implementation of function Base64Decode.</li>
 </ul>
 <h5>Improving</h5>
 <ul>
  <li>AVX2 optimizations of class ResizerNearest for Bgr24, Uv16.</li>
 </ul>
 <h5>Renaming</h5>
 <ul>
  <li>Function UyvyToBgr to Uyvy422ToBgr.</li>
 </ul>
 
 <h4>Test framework</h4>
 <h5>New features</h5>
 <ul>
  <li>Tests for verifying functionality of function Uyvy422ToYuv420p.</li>
  <li>Tests for verifying functionality of function Base64Encode.</li>
  <li>Tests for verifying functionality of function Base64Decode.</li>
 </ul>
 
 <h4>Documentation</h4>
 <h5>Changes</h5>
 <ul>
  <li>Update developers list.</li>
 </ul>
 
 <a href="#HOME">Home</a> 
 <hr/> 
 
 <center>
  <a href="2022.html">2022</a> |
  <a href="2021.html">2021</a> |
  <a href="2020.html">2020</a> |
  <a href="2019.html">2019</a> |
  <a href="2018.html">2018</a> |
  <a href="2017.html">2017</a> |
  <a href="2016.html">2016</a> |
  <a href="2015.html">2015</a> |
  <a href="2014.html">2014</a> |
  <a href="2013.html">2013</a>
 </center>
 
 <hr/> 
 
 </td> </tr> </table> </center> </body> </html>
diff --git a/src/Simd/SimdAvx2BgraToBgr.cpp b/src/Simd/SimdAvx2BgraToBgr.cpp
index aac574d7..1b16e6fe 100644
--- a/src/Simd/SimdAvx2BgraToBgr.cpp
+++ b/src/Simd/SimdAvx2BgraToBgr.cpp
@@ -28,122 +28,122 @@
 namespace Simd
 {
 #ifdef SIMD_AVX2_ENABLE  
     namespace Avx2
     {
         template <bool align> SIMD_INLINE __m256i BgraToBgr(const uint8_t* bgra)
         {
             __m256i _bgra = Load<align>((__m256i*)bgra);
             return _mm256_permutevar8x32_epi32(_mm256_shuffle_epi8(_bgra, K8_SHUFFLE_BGRA_TO_BGR), K32_PERMUTE_BGRA_TO_BGR);
         }
 
         template <bool align> void BgraToBgr(const uint8_t * bgra, size_t width, size_t height, size_t bgraStride, uint8_t * bgr, size_t bgrStride)
         {
             assert(width >= F);
             if (align)
                 assert(Aligned(bgra) && Aligned(bgraStride) && Aligned(bgr) && Aligned(bgrStride));
 
             size_t widthF = AlignLo(width, F);
             if (width == widthF)
                 widthF -= F;
 
             for (size_t row = 0; row < height; ++row)
             {
                 for (size_t col = 0; col < widthF; col += F)
                     Store<false>((__m256i*)(bgr + 3 * col), BgraToBgr<align>(bgra + 4 * col));
                 if (width != widthF)
                     Store24<false>(bgr + 3 * (width - F), BgraToBgr<false>(bgra + 4 * (width - F)));
                 bgra += bgraStride;
                 bgr += bgrStride;
             }
         }
 
         void BgraToBgr(const uint8_t * bgra, size_t width, size_t height, size_t bgraStride, uint8_t * bgr, size_t bgrStride)
         {
             if (Aligned(bgra) && Aligned(bgraStride) && Aligned(bgr) && Aligned(bgrStride))
                 BgraToBgr<true>(bgra, width, height, bgraStride, bgr, bgrStride);
             else
                 BgraToBgr<false>(bgra, width, height, bgraStride, bgr, bgrStride);
         }
 
         //---------------------------------------------------------------------
 
         const __m256i K8_SHUFFLE_BGRA_TO_RGB = SIMD_MM256_SETR_EPI8(
             0x2, 0x1, 0x0, 0x6, 0x5, 0x4, 0xA, 0x9, 0x8, 0xE, 0xD, 0xC, -1, -1, -1, -1,
             0x2, 0x1, 0x0, 0x6, 0x5, 0x4, 0xA, 0x9, 0x8, 0xE, 0xD, 0xC, -1, -1, -1, -1);
 
         template <bool align> SIMD_INLINE __m256i BgraToRgb(const uint8_t* bgra)
         {
             __m256i _bgra = Load<align>((__m256i*)bgra);
             return _mm256_permutevar8x32_epi32(_mm256_shuffle_epi8(_bgra, K8_SHUFFLE_BGRA_TO_RGB), K32_PERMUTE_BGRA_TO_BGR);
         }
 
         template <bool align> void BgraToRgb(const uint8_t* bgra, size_t width, size_t height, size_t bgraStride, uint8_t* rgb, size_t rgbStride)
         {
             assert(width >= F);
             if (align)
                 assert(Aligned(bgra) && Aligned(bgraStride) && Aligned(rgb) && Aligned(rgbStride));
 
             size_t widthF = AlignLo(width, F);
             if (width == widthF)
                 widthF -= F;
 
             for (size_t row = 0; row < height; ++row)
             {
                 for (size_t col = 0; col < widthF; col += F)
                     Store<false>((__m256i*)(rgb + 3 * col), BgraToRgb<align>(bgra + 4 * col));
                 if (width != widthF)
                     Store24<false>(rgb + 3 * (width - F), BgraToRgb<false>(bgra + 4 * (width - F)));
                 bgra += bgraStride;
                 rgb += rgbStride;
             }
         }
 
         void BgraToRgb(const uint8_t* bgra, size_t width, size_t height, size_t bgraStride, uint8_t* rgb, size_t rgbStride)
         {
             if (Aligned(bgra) && Aligned(bgraStride) && Aligned(rgb) && Aligned(rgbStride))
                 BgraToRgb<true>(bgra, width, height, bgraStride, rgb, rgbStride);
             else
                 BgraToRgb<false>(bgra, width, height, bgraStride, rgb, rgbStride);
         }
 
         //---------------------------------------------------------------------
 
         const __m256i K8_BGRA_TO_RGBA = SIMD_MM256_SETR_EPI8(
             0x2, 0x1, 0x0, 0x3, 0x6, 0x5, 0x4, 0x7, 0xA, 0x9, 0x8, 0xB, 0xE, 0xD, 0xC, 0xF,
             0x2, 0x1, 0x0, 0x3, 0x6, 0x5, 0x4, 0x7, 0xA, 0x9, 0x8, 0xB, 0xE, 0xD, 0xC, 0xF);
 
         template <bool align> SIMD_INLINE void BgraToRgba(const uint8_t* bgra, uint8_t* rgba)
         {
             Store<align>((__m256i*)rgba, _mm256_shuffle_epi8(Load<align>((__m256i*)bgra), K8_BGRA_TO_RGBA));
         }
 
         template <bool align> void BgraToRgba(const uint8_t* bgra, size_t width, size_t height, size_t bgraStride, uint8_t* rgba, size_t rgbaStride)
         {
             assert(width >= A);
             if (align)
                 assert(Aligned(bgra) && Aligned(bgraStride) && Aligned(rgba) && Aligned(rgbaStride));
 
             size_t size = width * 4;
             size_t sizeA = AlignLo(size, A);
 
             for (size_t row = 0; row < height; ++row)
             {
-                for (size_t i = 0; i < size; i += A)
+                for (size_t i = 0; i < sizeA; i += A)
                     BgraToRgba<align>(bgra + i, rgba + i);
                 if (size != sizeA)
-                    BgraToRgba<false>(bgra + size - sizeA, rgba + size - sizeA);
+                    BgraToRgba<false>(bgra + size - A, rgba + size - A);
                 bgra += bgraStride;
                 rgba += rgbaStride;
             }
         }
 
         void BgraToRgba(const uint8_t* bgra, size_t width, size_t height, size_t bgraStride, uint8_t* rgba, size_t rgbaStride)
         {
             if (Aligned(bgra) && Aligned(bgraStride) && Aligned(rgba) && Aligned(rgbaStride))
                 BgraToRgba<true>(bgra, width, height, bgraStride, rgba, rgbaStride);
             else
                 BgraToRgba<false>(bgra, width, height, bgraStride, rgba, rgbaStride);
         }
     }
 #endif// SIMD_AVX2_ENABLE
 }
diff --git a/src/Simd/SimdAvx512bwBgraToBgr.cpp b/src/Simd/SimdAvx512bwBgraToBgr.cpp
index 335af425..467a852b 100644
--- a/src/Simd/SimdAvx512bwBgraToBgr.cpp
+++ b/src/Simd/SimdAvx512bwBgraToBgr.cpp
@@ -27,168 +27,168 @@
 namespace Simd
 {
 #ifdef SIMD_AVX512BW_ENABLE  
     namespace Avx512bw
     {
         const __m512i K8_SUFFLE_BGRA_TO_BGR = SIMD_MM512_SETR_EPI8(
             0x0, 0x1, 0x2, 0x4, 0x5, 0x6, 0x8, 0x9, 0xA, 0xC, 0xD, 0xE, -1, -1, -1, -1,
             0x0, 0x1, 0x2, 0x4, 0x5, 0x6, 0x8, 0x9, 0xA, 0xC, 0xD, 0xE, -1, -1, -1, -1,
             0x0, 0x1, 0x2, 0x4, 0x5, 0x6, 0x8, 0x9, 0xA, 0xC, 0xD, 0xE, -1, -1, -1, -1,
             0x0, 0x1, 0x2, 0x4, 0x5, 0x6, 0x8, 0x9, 0xA, 0xC, 0xD, 0xE, -1, -1, -1, -1);
 
         const __m512i K32_PERMUTE_BGRA_TO_BGR = SIMD_MM512_SETR_EPI32(0x0, 0x1, 0x2, 0x4, 0x5, 0x6, 0x8, 0x9, 0xA, 0xC, 0xD, 0xE, -1, -1, -1, -1);
 
         const __m512i K32_PERMUTE_BGRA_TO_BGR_0 = SIMD_MM512_SETR_EPI32(0x00, 0x01, 0x02, 0x04, 0x05, 0x06, 0x08, 0x09, 0x0A, 0x0C, 0x0D, 0x0E, 0x10, 0x11, 0x12, 0x14);
         const __m512i K32_PERMUTE_BGRA_TO_BGR_1 = SIMD_MM512_SETR_EPI32(0x05, 0x06, 0x08, 0x09, 0x0A, 0x0C, 0x0D, 0x0E, 0x10, 0x11, 0x12, 0x14, 0x15, 0x16, 0x18, 0x19);
         const __m512i K32_PERMUTE_BGRA_TO_BGR_2 = SIMD_MM512_SETR_EPI32(0x0A, 0x0C, 0x0D, 0x0E, 0x10, 0x11, 0x12, 0x14, 0x15, 0x16, 0x18, 0x19, 0x1A, 0x1C, 0x1D, 0x1E);
 
         template <bool align, bool mask> SIMD_INLINE void BgraToBgr(const uint8_t * bgra, uint8_t * bgr, __mmask64 bgraMask = -1, __mmask64 bgrMask = 0x0000ffffffffffff)
         {
             __m512i _bgra = Load<align, mask>(bgra, bgraMask);
             __m512i _bgr = _mm512_permutexvar_epi32(K32_PERMUTE_BGRA_TO_BGR, _mm512_shuffle_epi8(_bgra, K8_SUFFLE_BGRA_TO_BGR));
             Store<false, true>(bgr, _bgr, bgrMask);
         }
 
         template <bool align> SIMD_INLINE void BgraToBgr(const uint8_t * bgra, uint8_t * bgr)
         {
             __m512i bgr0 = _mm512_shuffle_epi8(Load<align>(bgra + 0 * A), K8_SUFFLE_BGRA_TO_BGR);
             __m512i bgr1 = _mm512_shuffle_epi8(Load<align>(bgra + 1 * A), K8_SUFFLE_BGRA_TO_BGR);
             __m512i bgr2 = _mm512_shuffle_epi8(Load<align>(bgra + 2 * A), K8_SUFFLE_BGRA_TO_BGR);
             __m512i bgr3 = _mm512_shuffle_epi8(Load<align>(bgra + 3 * A), K8_SUFFLE_BGRA_TO_BGR);
             Store<align>(bgr + 0 * A, _mm512_permutex2var_epi32(bgr0, K32_PERMUTE_BGRA_TO_BGR_0, bgr1));
             Store<align>(bgr + 1 * A, _mm512_permutex2var_epi32(bgr1, K32_PERMUTE_BGRA_TO_BGR_1, bgr2));
             Store<align>(bgr + 2 * A, _mm512_permutex2var_epi32(bgr2, K32_PERMUTE_BGRA_TO_BGR_2, bgr3));
         }
 
         template <bool align> void BgraToBgr(const uint8_t * bgra, size_t width, size_t height, size_t bgraStride, uint8_t * bgr, size_t bgrStride)
         {
             if (align)
                 assert(Aligned(bgra) && Aligned(bgraStride) && Aligned(bgr) && Aligned(bgrStride));
 
             size_t fullAlignedWidth = AlignLo(width, A);
             size_t alignedWidth = AlignLo(width, F);
             __mmask64 bgraTailMask = TailMask64((width - alignedWidth) * 4);
             __mmask64 bgrTailMask = TailMask64((width - alignedWidth) * 3);
             for (size_t row = 0; row < height; ++row)
             {
                 size_t col = 0;
                 for (; col < fullAlignedWidth; col += A)
                     BgraToBgr<align>(bgra + 4 * col, bgr + 3 * col);
                 for (; col < alignedWidth; col += F)
                     BgraToBgr<align, false>(bgra + 4 * col, bgr + 3 * col);
                 if (col < width)
                     BgraToBgr<align, true>(bgra + 4 * col, bgr + 3 * col, bgraTailMask, bgrTailMask);
                 bgra += bgraStride;
                 bgr += bgrStride;
             }
         }
 
         void BgraToBgr(const uint8_t * bgra, size_t width, size_t height, size_t bgraStride, uint8_t * bgr, size_t bgrStride)
         {
             if (Aligned(bgra) && Aligned(bgraStride) && Aligned(bgr) && Aligned(bgrStride))
                 BgraToBgr<true>(bgra, width, height, bgraStride, bgr, bgrStride);
             else
                 BgraToBgr<false>(bgra, width, height, bgraStride, bgr, bgrStride);
         }
 
         //---------------------------------------------------------------------
 
         const __m512i K8_SUFFLE_BGRA_TO_RGB = SIMD_MM512_SETR_EPI8(
             0x2, 0x1, 0x0, 0x6, 0x5, 0x4, 0xA, 0x9, 0x8, 0xE, 0xD, 0xC, -1, -1, -1, -1,
             0x2, 0x1, 0x0, 0x6, 0x5, 0x4, 0xA, 0x9, 0x8, 0xE, 0xD, 0xC, -1, -1, -1, -1,
             0x2, 0x1, 0x0, 0x6, 0x5, 0x4, 0xA, 0x9, 0x8, 0xE, 0xD, 0xC, -1, -1, -1, -1,
             0x2, 0x1, 0x0, 0x6, 0x5, 0x4, 0xA, 0x9, 0x8, 0xE, 0xD, 0xC, -1, -1, -1, -1);
 
         template <bool align, bool mask> SIMD_INLINE void BgraToRgb(const uint8_t* bgra, uint8_t* rgb, __mmask64 bgraMask = -1, __mmask64 rgbMask = 0x0000ffffffffffff)
         {
             __m512i _bgra = Load<align, mask>(bgra, bgraMask);
             __m512i _rgb = _mm512_permutexvar_epi32(K32_PERMUTE_BGRA_TO_BGR, _mm512_shuffle_epi8(_bgra, K8_SUFFLE_BGRA_TO_RGB));
             Store<false, true>(rgb, _rgb, rgbMask);
         }
 
         template <bool align> SIMD_INLINE void BgraToRgb(const uint8_t* bgra, uint8_t* rgb)
         {
             __m512i rgb0 = _mm512_shuffle_epi8(Load<align>(bgra + 0 * A), K8_SUFFLE_BGRA_TO_RGB);
             __m512i rgb1 = _mm512_shuffle_epi8(Load<align>(bgra + 1 * A), K8_SUFFLE_BGRA_TO_RGB);
             __m512i rgb2 = _mm512_shuffle_epi8(Load<align>(bgra + 2 * A), K8_SUFFLE_BGRA_TO_RGB);
             __m512i rgb3 = _mm512_shuffle_epi8(Load<align>(bgra + 3 * A), K8_SUFFLE_BGRA_TO_RGB);
             Store<align>(rgb + 0 * A, _mm512_permutex2var_epi32(rgb0, K32_PERMUTE_BGRA_TO_BGR_0, rgb1));
             Store<align>(rgb + 1 * A, _mm512_permutex2var_epi32(rgb1, K32_PERMUTE_BGRA_TO_BGR_1, rgb2));
             Store<align>(rgb + 2 * A, _mm512_permutex2var_epi32(rgb2, K32_PERMUTE_BGRA_TO_BGR_2, rgb3));
         }
 
         template <bool align> void BgraToRgb(const uint8_t* bgra, size_t width, size_t height, size_t bgraStride, uint8_t* rgb, size_t rgbStride)
         {
             if (align)
                 assert(Aligned(bgra) && Aligned(bgraStride) && Aligned(rgb) && Aligned(rgbStride));
 
             size_t fullAlignedWidth = AlignLo(width, A);
             size_t alignedWidth = AlignLo(width, F);
             __mmask64 bgraTailMask = TailMask64((width - alignedWidth) * 4);
             __mmask64 rgbTailMask = TailMask64((width - alignedWidth) * 3);
             for (size_t row = 0; row < height; ++row)
             {
                 size_t col = 0;
                 for (; col < fullAlignedWidth; col += A)
                     BgraToRgb<align>(bgra + 4 * col, rgb + 3 * col);
                 for (; col < alignedWidth; col += F)
                     BgraToRgb<align, false>(bgra + 4 * col, rgb + 3 * col);
                 if (col < width)
                     BgraToRgb<align, true>(bgra + 4 * col, rgb + 3 * col, bgraTailMask, rgbTailMask);
                 bgra += bgraStride;
                 rgb += rgbStride;
             }
         }
 
         void BgraToRgb(const uint8_t* bgra, size_t width, size_t height, size_t bgraStride, uint8_t* bgr, size_t bgrStride)
         {
             if (Aligned(bgra) && Aligned(bgraStride) && Aligned(bgr) && Aligned(bgrStride))
                 BgraToRgb<true>(bgra, width, height, bgraStride, bgr, bgrStride);
             else
                 BgraToRgb<false>(bgra, width, height, bgraStride, bgr, bgrStride);
         }
 
         //---------------------------------------------------------------------
 
         const __m512i K8_BGRA_TO_RGBA = SIMD_MM512_SETR_EPI8(
             0x2, 0x1, 0x0, 0x3, 0x6, 0x5, 0x4, 0x7, 0xA, 0x9, 0x8, 0xB, 0xE, 0xD, 0xC, 0xF,
             0x2, 0x1, 0x0, 0x3, 0x6, 0x5, 0x4, 0x7, 0xA, 0x9, 0x8, 0xB, 0xE, 0xD, 0xC, 0xF,
             0x2, 0x1, 0x0, 0x3, 0x6, 0x5, 0x4, 0x7, 0xA, 0x9, 0x8, 0xB, 0xE, 0xD, 0xC, 0xF,
             0x2, 0x1, 0x0, 0x3, 0x6, 0x5, 0x4, 0x7, 0xA, 0x9, 0x8, 0xB, 0xE, 0xD, 0xC, 0xF);
 
         template <bool align, bool mask> SIMD_INLINE void BgraToRgba(const uint8_t* bgra, uint8_t* rgba, __mmask64 tail = -1)
         {
             Store<align, mask>(rgba, _mm512_shuffle_epi8((Load<align, mask>(bgra, tail)), K8_BGRA_TO_RGBA), tail);
         }
 
         template <bool align> void BgraToRgba(const uint8_t* bgra, size_t width, size_t height, size_t bgraStride, uint8_t* rgba, size_t rgbaStride)
         {
             assert(width >= A);
             if (align)
                 assert(Aligned(bgra) && Aligned(bgraStride) && Aligned(rgba) && Aligned(rgbaStride));
 
             size_t size = width * 4;
             size_t sizeA = AlignLo(size, A);
             __mmask64 tail = TailMask64(size - sizeA);
 
             for (size_t row = 0; row < height; ++row)
             {
                 size_t i = 0;
-                for (; i < size; i += A)
+                for (; i < sizeA; i += A)
                     BgraToRgba<align, false>(bgra + i, rgba + i);
                 if (i < size)
                     BgraToRgba<align, true>(bgra + i, rgba + i, tail);
                 bgra += bgraStride;
                 rgba += rgbaStride;
             }
         }
 
         void BgraToRgba(const uint8_t* bgra, size_t width, size_t height, size_t bgraStride, uint8_t* rgba, size_t rgbaStride)
         {
             if (Aligned(bgra) && Aligned(bgraStride) && Aligned(rgba) && Aligned(rgbaStride))
                 BgraToRgba<true>(bgra, width, height, bgraStride, rgba, rgbaStride);
             else
                 BgraToRgba<false>(bgra, width, height, bgraStride, rgba, rgbaStride);
         }
     }
 #endif// SIMD_AVX512BW_ENABLE
 }
diff --git a/src/Simd/SimdSse41BgraToBgr.cpp b/src/Simd/SimdSse41BgraToBgr.cpp
index a3000972..1e0820d8 100644
--- a/src/Simd/SimdSse41BgraToBgr.cpp
+++ b/src/Simd/SimdSse41BgraToBgr.cpp
@@ -27,139 +27,139 @@
 namespace Simd
 {
 #ifdef SIMD_SSE41_ENABLE  
     namespace Sse41
     {
         template <bool align> SIMD_INLINE void BgraToBgrBody(const uint8_t * bgra, uint8_t * bgr, __m128i k[3][2])
         {
             Store<align>((__m128i*)(bgr + 0), _mm_shuffle_epi8(Load<align>((__m128i*)bgra + 0), k[0][0]));
             Store<false>((__m128i*)(bgr + 12), _mm_shuffle_epi8(Load<align>((__m128i*)bgra + 1), k[0][0]));
             Store<false>((__m128i*)(bgr + 24), _mm_shuffle_epi8(Load<align>((__m128i*)bgra + 2), k[0][0]));
             Store<false>((__m128i*)(bgr + 36), _mm_shuffle_epi8(Load<align>((__m128i*)bgra + 3), k[0][0]));
         }
 
         template <bool align> SIMD_INLINE void BgraToBgr(const uint8_t * bgra, uint8_t * bgr, __m128i k[3][2])
         {
             __m128i bgra0 = Load<align>((__m128i*)bgra + 0);
             __m128i bgra1 = Load<align>((__m128i*)bgra + 1);
             __m128i bgra2 = Load<align>((__m128i*)bgra + 2);
             __m128i bgra3 = Load<align>((__m128i*)bgra + 3);
             Store<align>((__m128i*)bgr + 0, _mm_or_si128(_mm_shuffle_epi8(bgra0, k[0][0]), _mm_shuffle_epi8(bgra1, k[0][1])));
             Store<align>((__m128i*)bgr + 1, _mm_or_si128(_mm_shuffle_epi8(bgra1, k[1][0]), _mm_shuffle_epi8(bgra2, k[1][1])));
             Store<align>((__m128i*)bgr + 2, _mm_or_si128(_mm_shuffle_epi8(bgra2, k[2][0]), _mm_shuffle_epi8(bgra3, k[2][1])));
         }
 
         template <bool align> void BgraToBgr(const uint8_t * bgra, size_t width, size_t height, size_t bgraStride, uint8_t * bgr, size_t bgrStride)
         {
             assert(width >= A);
             if (align)
                 assert(Aligned(bgra) && Aligned(bgraStride) && Aligned(bgr) && Aligned(bgrStride));
 
             size_t alignedWidth = AlignLo(width, A);
             if (width == alignedWidth)
                 alignedWidth -= A;
 
             __m128i k[3][2];
             k[0][0] = _mm_setr_epi8(0x0, 0x1, 0x2, 0x4, 0x5, 0x6, 0x8, 0x9, 0xA, 0xC, 0xD, 0xE, -1, -1, -1, -1);
             k[0][1] = _mm_setr_epi8(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0x0, 0x1, 0x2, 0x4);
             k[1][0] = _mm_setr_epi8(0x5, 0x6, 0x8, 0x9, 0xA, 0xC, 0xD, 0xE, -1, -1, -1, -1, -1, -1, -1, -1);
             k[1][1] = _mm_setr_epi8(-1, -1, -1, -1, -1, -1, -1, -1, 0x0, 0x1, 0x2, 0x4, 0x5, 0x6, 0x8, 0x9);
             k[2][0] = _mm_setr_epi8(0xA, 0xC, 0xD, 0xE, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1);
             k[2][1] = _mm_setr_epi8(-1, -1, -1, -1, 0x0, 0x1, 0x2, 0x4, 0x5, 0x6, 0x8, 0x9, 0xA, 0xC, 0xD, 0xE);
 
             for (size_t row = 0; row < height; ++row)
             {
                 for (size_t col = 0; col < alignedWidth; col += A)
                     BgraToBgrBody<align>(bgra + 4 * col, bgr + 3 * col, k);
                 if (width != alignedWidth)
                     BgraToBgr<false>(bgra + 4 * (width - A), bgr + 3 * (width - A), k);
                 bgra += bgraStride;
                 bgr += bgrStride;
             }
         }
 
         void BgraToBgr(const uint8_t * bgra, size_t width, size_t height, size_t bgraStride, uint8_t * bgr, size_t bgrStride)
         {
             if (Aligned(bgra) && Aligned(bgraStride) && Aligned(bgr) && Aligned(bgrStride))
                 BgraToBgr<true>(bgra, width, height, bgraStride, bgr, bgrStride);
             else
                 BgraToBgr<false>(bgra, width, height, bgraStride, bgr, bgrStride);
         }
 
         //---------------------------------------------------------------------
 
         template <bool align> void BgraToRgb(const uint8_t* bgra, size_t width, size_t height, size_t bgraStride, uint8_t* rgb, size_t rgbStride)
         {
             assert(width >= A);
             if (align)
                 assert(Aligned(bgra) && Aligned(bgraStride) && Aligned(rgb) && Aligned(rgbStride));
 
             size_t alignedWidth = AlignLo(width, A);
             if (width == alignedWidth)
                 alignedWidth -= A;
 
             __m128i k[3][2];
             k[0][0] = _mm_setr_epi8(0x2, 0x1, 0x0, 0x6, 0x5, 0x4, 0xA, 0x9, 0x8, 0xE, 0xD, 0xC, -1, -1, -1, -1);
             k[0][1] = _mm_setr_epi8(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0x2, 0x1, 0x0, 0x6);
             k[1][0] = _mm_setr_epi8(0x5, 0x4, 0xA, 0x9, 0x8, 0xE, 0xD, 0xC, -1, -1, -1, -1, -1, -1, -1, -1);
             k[1][1] = _mm_setr_epi8(-1, -1, -1, -1, -1, -1, -1, -1, 0x2, 0x1, 0x0, 0x6, 0x5, 0x4, 0xA, 0x9);
             k[2][0] = _mm_setr_epi8(0x8, 0xE, 0xD, 0xC, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1);
             k[2][1] = _mm_setr_epi8(-1, -1, -1, -1, 0x2, 0x1, 0x0, 0x6, 0x5, 0x4, 0xA, 0x9, 0x8, 0xE, 0xD, 0xC);
 
             for (size_t row = 0; row < height; ++row)
             {
                 for (size_t col = 0; col < alignedWidth; col += A)
                     BgraToBgrBody<align>(bgra + 4 * col, rgb + 3 * col, k);
                 if (width != alignedWidth)
                     BgraToBgr<false>(bgra + 4 * (width - A), rgb + 3 * (width - A), k);
                 bgra += bgraStride;
                 rgb += rgbStride;
             }
         }
 
         void BgraToRgb(const uint8_t* bgra, size_t width, size_t height, size_t bgraStride, uint8_t* rgb, size_t rgbStride)
         {
             if (Aligned(bgra) && Aligned(bgraStride) && Aligned(rgb) && Aligned(rgbStride))
                 BgraToRgb<true>(bgra, width, height, bgraStride, rgb, rgbStride);
             else
                 BgraToRgb<false>(bgra, width, height, bgraStride, rgb, rgbStride);
         }
 
         //---------------------------------------------------------------------
 
         const __m128i K8_BGRA_TO_RGBA = SIMD_MM_SETR_EPI8(0x2, 0x1, 0x0, 0x3, 0x6, 0x5, 0x4, 0x7, 0xA, 0x9, 0x8, 0xB, 0xE, 0xD, 0xC, 0xF);
 
         template <bool align> SIMD_INLINE void BgraToRgba(const uint8_t* bgra, uint8_t* rgba)
         {
             Store<align>((__m128i*)rgba, _mm_shuffle_epi8(Load<align>((__m128i*)bgra), K8_BGRA_TO_RGBA));
         }
 
         template <bool align> void BgraToRgba(const uint8_t* bgra, size_t width, size_t height, size_t bgraStride, uint8_t* rgba, size_t rgbaStride)
         {
             assert(width >= A);
             if (align)
                 assert(Aligned(bgra) && Aligned(bgraStride) && Aligned(rgba) && Aligned(rgbaStride));
 
             size_t size = width * 4;
             size_t sizeA = AlignLo(size, A);
 
             for (size_t row = 0; row < height; ++row)
             {
-                for (size_t i = 0; i < size; i += A)
+                for (size_t i = 0; i < sizeA; i += A)
                     BgraToRgba<align>(bgra + i, rgba + i);
                 if (size != sizeA)
-                    BgraToRgba<false>(bgra + size - sizeA, rgba + size - sizeA);
+                    BgraToRgba<false>(bgra + size - A, rgba + size - A);
                 bgra += bgraStride;
                 rgba += rgbaStride;
             }
         }
 
         void BgraToRgba(const uint8_t* bgra, size_t width, size_t height, size_t bgraStride, uint8_t* rgba, size_t rgbaStride)
         {
             if (Aligned(bgra) && Aligned(bgraStride) && Aligned(rgba) && Aligned(rgbaStride))
                 BgraToRgba<true>(bgra, width, height, bgraStride, rgba, rgbaStride);
             else
                 BgraToRgba<false>(bgra, width, height, bgraStride, rgba, rgbaStride);
         }
     }
 #endif
 }
diff --git a/src/Test/TestResize.cpp b/src/Test/TestResize.cpp
index 785ccdb0..507615d2 100644
--- a/src/Test/TestResize.cpp
+++ b/src/Test/TestResize.cpp
@@ -31,491 +31,491 @@
 namespace Test
 {
     namespace
     {
         struct FuncRB
         {
             typedef void(*FuncPtr)(
                 const uint8_t *src, size_t srcWidth, size_t srcHeight, size_t srcStride,
                 uint8_t *dst, size_t dstWidth, size_t dstHeight, size_t dstStride, size_t channelCount);
 
             FuncPtr func;
             String description;
 
             FuncRB(const FuncPtr & f, const String & d) : func(f), description(d) {}
 
             void Call(const View & src, View & dst) const
             {
                 TEST_PERFORMANCE_TEST(description);
                 func(src.data, src.width, src.height, src.stride,
                     dst.data, dst.width, dst.height, dst.stride, View::PixelSize(src.format));
             }
         };
     }
 
 #define ARGS_RB1(format, width, height, k, function1, function2) \
     format, width, height, k, \
     FuncRB(function1.func, function1.description + ColorDescription(format)), \
     FuncRB(function2.func, function2.description + ColorDescription(format))
 
 #define ARGS_RB2(format, src, dst, function1, function2) \
     format, src, dst, \
     FuncRB(function1.func, function1.description + ColorDescription(format)), \
     FuncRB(function2.func, function2.description + ColorDescription(format))
 
 #define FUNC_RB(function) \
     FuncRB(function, std::string(#function))
 
     bool ResizeAutoTest(View::Format format, int width, int height, double k, const FuncRB & f1, const FuncRB & f2)
     {
         bool result = true;
 
         TEST_LOG_SS(Info, "Test " << f1.description << " & " << f2.description
             << " [" << size_t(width*k) << ", " << size_t(height*k) << "] -> [" << width << ", " << height << "].");
 
         View s(size_t(width*k), size_t(height*k), format, NULL, TEST_ALIGN(size_t(k*width)));
         FillRandom(s);
 
         View d1(width, height, format, NULL, TEST_ALIGN(width));
         View d2(width, height, format, NULL, TEST_ALIGN(width));
 
         TEST_EXECUTE_AT_LEAST_MIN_TIME(f1.Call(s, d1));
 
         TEST_EXECUTE_AT_LEAST_MIN_TIME(f2.Call(s, d2));
 
         result = result && Compare(d1, d2, 0, true, 64);
 
         return result;
     }
 
     bool ResizeAutoTest(const FuncRB & f1, const FuncRB & f2)
     {
         bool result = true;
 
         for (View::Format format = View::Gray8; format <= View::Bgra32; format = View::Format(format + 1))
         {
             result = result && ResizeAutoTest(ARGS_RB1(format, W/3, H/3, 3.3, f1, f2));
             //result = result && ResizeAutoTest(ARGS_RB1(format, W, H, 0.9, f1, f2));
             //result = result && ResizeAutoTest(ARGS_RB1(format, W + O, H - O, 1.3, f1, f2));
             //result = result && ResizeAutoTest(ARGS_RB1(format, W - O, H + O, 0.7, f1, f2));
         }
 
         return result;
     }
 
     bool ResizeBilinearAutoTest()
     {
         bool result = true;
 
         result = result && ResizeAutoTest(FUNC_RB(Simd::Base::ResizeBilinear), FUNC_RB(SimdResizeBilinear));
 
 #ifdef SIMD_SSE2_ENABLE
         if (Simd::Sse2::Enable)
             result = result && ResizeAutoTest(FUNC_RB(Simd::Sse2::ResizeBilinear), FUNC_RB(SimdResizeBilinear));
 #endif 
 
 #ifdef SIMD_SSE41_ENABLE
         if (Simd::Sse41::Enable)
             result = result && ResizeAutoTest(FUNC_RB(Simd::Sse41::ResizeBilinear), FUNC_RB(SimdResizeBilinear));
 #endif 
 
 #ifdef SIMD_AVX2_ENABLE
         if (Simd::Avx2::Enable)
             result = result && ResizeAutoTest(FUNC_RB(Simd::Avx2::ResizeBilinear), FUNC_RB(SimdResizeBilinear));
 #endif 
 
 #ifdef SIMD_AVX512BW_ENABLE
         if (Simd::Avx512bw::Enable)
             result = result && ResizeAutoTest(FUNC_RB(Simd::Avx512bw::ResizeBilinear), FUNC_RB(SimdResizeBilinear));
 #endif 
 
 #ifdef SIMD_VMX_ENABLE
         if (Simd::Vmx::Enable)
             result = result && ResizeAutoTest(FUNC_RB(Simd::Vmx::ResizeBilinear), FUNC_RB(SimdResizeBilinear));
 #endif 
 
 #ifdef SIMD_NEON_ENABLE
         if (Simd::Neon::Enable)
             result = result && ResizeAutoTest(FUNC_RB(Simd::Neon::ResizeBilinear), FUNC_RB(SimdResizeBilinear));
 #endif
 
         return result;
     }
 
     String ToString(SimdResizeMethodType method)
     {
         switch (method)
         {
         case SimdResizeMethodNearest: return "NrO";
         case SimdResizeMethodNearestPytorch: return "NrP";
         case SimdResizeMethodBilinear: return "BlO";
         case SimdResizeMethodBilinearCaffe: return "BlC";
         case SimdResizeMethodBilinearPytorch: return "BlP";
         case SimdResizeMethodBicubic: return "BcO";
         case SimdResizeMethodArea: return "ArO";
         default: assert(0); return "";
         }
     }
 
     String ToString(SimdResizeChannelType type)
     {
         switch (type)
         {
         case SimdResizeChannelByte:  return "b";
         case SimdResizeChannelShort:  return "s";
         case SimdResizeChannelFloat:  return "f";
         default: assert(0); return "";
         }
     }
 
     namespace
     {
         struct FuncRS
         {
             typedef void*(*FuncPtr)(size_t srcX, size_t srcY, size_t dstX, size_t dstY, size_t channels, SimdResizeChannelType type, SimdResizeMethodType method);
 
             FuncPtr func;
             String description;
 
             FuncRS(const FuncPtr & f, const String & d) : func(f), description(d) {}
 
             void Update(SimdResizeMethodType method, SimdResizeChannelType type, size_t channels, size_t srcW, size_t srcH, size_t dstW, size_t dstH)
             {
                 std::stringstream ss;
                 ss << description <<  "[" << ToString(method) << "-" << ToString(type) << "-" << channels;
                 ss << ":" << srcW << "x" << srcH << "->" << dstW << "x" << dstH << "]";
                 description = ss.str();
             }
 
             void Call(const View & src, View & dst, size_t channels, SimdResizeChannelType type, SimdResizeMethodType method) const
             {
                 void * resizer = NULL;
                 if(src.format == View::Float || src.format == View::Int16)
                     resizer = func(src.width / channels, src.height, dst.width / channels, dst.height, channels, type, method);
                 else
                     resizer = func(src.width, src.height, dst.width, dst.height, channels, type, method);
                 if (resizer)
                 {
                     {
                         TEST_PERFORMANCE_TEST(description);
                         SimdResizerRun(resizer, src.data, src.stride, dst.data, dst.stride);
                     }
                     SimdRelease(resizer);
                 }
             }
         };
     }
 
 #define FUNC_RS(function) \
     FuncRS(function, std::string(#function))
 
 #define TEST_RESIZE_REAL_IMAGE
 
     bool ResizerAutoTest(SimdResizeMethodType method, SimdResizeChannelType type, size_t channels, size_t srcW, size_t srcH, size_t dstW, size_t dstH, FuncRS f1, FuncRS f2)
     {
         bool result = true;
 
         f1.Update(method, type, channels, srcW, srcH, dstW, dstH);
         f2.Update(method, type, channels, srcW, srcH, dstW, dstH);
 
         TEST_LOG_SS(Info, "Test " << f1.description << " & " << f2.description << " [" << srcW << ", " << srcH << "] -> [" << dstW << ", " << dstH << "].");
 
         View::Format format;
         if (type == SimdResizeChannelFloat)
         {
             format = View::Float;
             srcW *= channels;
             dstW *= channels;
         }
         else if (type == SimdResizeChannelShort)
         {
             format = View::Int16;
             srcW *= channels;
             dstW *= channels;
         }
         else if (type == SimdResizeChannelByte)
         {
             switch (channels)
             {
             case 1: format = View::Gray8; break;
             case 2: format = View::Uv16; break;
             case 3: format = View::Bgr24; break;
             case 4: format = View::Bgra32; break;
             default:
                 assert(0);
             }
         }
         else
             assert(0);
 
         View src(srcW, srcH, format, NULL, TEST_ALIGN(srcW));
         if (format == View::Float)
             FillRandom32f(src);
         else if (format == View::Int16)
             FillRandom16u(src);
         else
         {
 #ifdef TEST_RESIZE_REAL_IMAGE
             ::srand(0);
             FillPicture(src);
 #else
             FillRandom(src);
 #endif
         }
 
         View dst1(dstW, dstH, format, NULL, TEST_ALIGN(dstW));
         View dst2(dstW, dstH, format, NULL, TEST_ALIGN(dstW));
         if (format == View::Int16)
         {
             Simd::Fill(dst1, 0);
             Simd::Fill(dst2, 0);
         }
 
         TEST_ALIGN(SIMD_ALIGN);
 
         TEST_EXECUTE_AT_LEAST_MIN_TIME(f1.Call(src, dst1, channels, type, method));
 
         TEST_EXECUTE_AT_LEAST_MIN_TIME(f2.Call(src, dst2, channels, type, method));
 
         if (format == View::Float)
             result = result && Compare(dst1, dst2, EPS, true, 64, DifferenceAbsolute);
         else if(format == View::Int16)
             result = result && Compare(dst1, dst2, 1, true, 64);
         else
             result = result && Compare(dst1, dst2, 0, true, 64);
 
 #if defined(TEST_RESIZE_REAL_IMAGE) && 0
         String suffix = ToString(method) + "_" + ToString(method == SimdResizeMethodBicubic ? SIMD_RESIZER_BICUBIC_BITS : 4);
         if (format == View::Bgr24)
         {
             src.Save(String("src_") + suffix + ".ppm");
             dst1.Save(String("dst_") + suffix + ".ppm");
         }
         if (format == View::Gray8)
         {
             src.Save(String("src_") + suffix + ".pgm", SimdImageFilePgmTxt);
             dst1.Save(String("dst_") + suffix + ".pgm", SimdImageFilePgmTxt);
         }
 #endif
 
         return result;
     }
 
     bool ResizerAutoTest(SimdResizeMethodType method, SimdResizeChannelType type, int channels, int width, int height, double k, FuncRS f1, FuncRS f2)
     {
         return ResizerAutoTest(method, type, channels, int(width*k), int(height*k), width, height, f1, f2);
     }
 
     bool ResizerAutoTest(SimdResizeMethodType method, SimdResizeChannelType type, int channels, const FuncRS & f1, const FuncRS & f2)
     {
         bool result = true;
 
         result = result && ResizerAutoTest(method, type, channels, 124, 93, 319, 239, f1, f2);
         result = result && ResizerAutoTest(method, type, channels, 249, 187, 319, 239, f1, f2);
         result = result && ResizerAutoTest(method, type, channels, 499, 374, 319, 239, f1, f2);
         result = result && ResizerAutoTest(method, type, channels, 999, 749, 319, 239, f1, f2);
         result = result && ResizerAutoTest(method, type, channels, 1999, 1499, 319, 239, f1, f2);
 
         return result;
     }
 
     bool ResizerAutoTest(const FuncRS & f1, const FuncRS & f2)
     {
         bool result = true;
 
 #if !defined(__aarch64__) || 1  
-        std::vector<SimdResizeMethodType> methods = { /*SimdResizeMethodNearest, SimdResizeMethodBilinear, */SimdResizeMethodBicubic/*, SimdResizeMethodArea*/};
+        std::vector<SimdResizeMethodType> methods = { /*SimdResizeMethodNearest, */SimdResizeMethodBilinear, SimdResizeMethodBicubic/*, SimdResizeMethodArea*/};
         for (size_t m = 0; m < methods.size(); ++m)
         {
             result = result && ResizerAutoTest(methods[m], SimdResizeChannelByte, 1, f1, f2);
             result = result && ResizerAutoTest(methods[m], SimdResizeChannelByte, 2, f1, f2);
             result = result && ResizerAutoTest(methods[m], SimdResizeChannelByte, 3, f1, f2);
             result = result && ResizerAutoTest(methods[m], SimdResizeChannelByte, 4, f1, f2);
             if (methods[m] == SimdResizeMethodArea || 1)
                 continue;
             result = result && ResizerAutoTest(methods[m], SimdResizeChannelShort, 1, f1, f2);
             result = result && ResizerAutoTest(methods[m], SimdResizeChannelShort, 2, f1, f2);
             result = result && ResizerAutoTest(methods[m], SimdResizeChannelShort, 3, f1, f2);
             result = result && ResizerAutoTest(methods[m], SimdResizeChannelShort, 4, f1, f2);
             result = result && ResizerAutoTest(methods[m], SimdResizeChannelFloat, 1, f1, f2);
             result = result && ResizerAutoTest(methods[m], SimdResizeChannelFloat, 3, f1, f2);
         }
 #endif
 
         return result;
     }
 
     bool ResizerAutoTest()
     {
         bool result = true;
 
         result = result && ResizerAutoTest(FUNC_RS(Simd::Base::ResizerInit), FUNC_RS(SimdResizerInit));
 
 #ifdef SIMD_SSE2_ENABLE
         if (Simd::Sse2::Enable)
             result = result && ResizerAutoTest(FUNC_RS(Simd::Sse2::ResizerInit), FUNC_RS(SimdResizerInit));
 #endif 
 
 #ifdef SIMD_SSE41_ENABLE
         if (Simd::Sse41::Enable)
             result = result && ResizerAutoTest(FUNC_RS(Simd::Sse41::ResizerInit), FUNC_RS(SimdResizerInit));
 #endif
 
 #ifdef SIMD_AVX_ENABLE
         if (Simd::Avx::Enable)
             result = result && ResizerAutoTest(FUNC_RS(Simd::Avx::ResizerInit), FUNC_RS(SimdResizerInit));
 #endif 
 
 #ifdef SIMD_AVX2_ENABLE
         if (Simd::Avx2::Enable)
             result = result && ResizerAutoTest(FUNC_RS(Simd::Avx2::ResizerInit), FUNC_RS(SimdResizerInit));
 #endif
 
 #ifdef SIMD_AVX512F_ENABLE
         if (Simd::Avx512f::Enable)
             result = result && ResizerAutoTest(FUNC_RS(Simd::Avx512f::ResizerInit), FUNC_RS(SimdResizerInit));
 #endif
 
 #ifdef SIMD_AVX512BW_ENABLE
         if (Simd::Avx512bw::Enable)
             result = result && ResizerAutoTest(FUNC_RS(Simd::Avx512bw::ResizerInit), FUNC_RS(SimdResizerInit));
 #endif
 
 #ifdef SIMD_NEON_ENABLE
         if (Simd::Neon::Enable)
             result = result && ResizerAutoTest(FUNC_RS(Simd::Neon::ResizerInit), FUNC_RS(SimdResizerInit));
 #endif 
 
         return result;
     }
 
     //-----------------------------------------------------------------------
 
     bool ResizeDataTest(bool create, int width, int height, View::Format format, const FuncRB & f)
     {
         bool result = true;
 
         Data data(f.description);
 
         TEST_LOG_SS(Info, (create ? "Create" : "Verify") << " test " << f.description << " [" << width << ", " << height << "].");
 
         const double k = 0.7;
 
         View s(size_t(width*k), size_t(height*k), format, NULL, TEST_ALIGN(size_t(k*width)));
 
         View d1(width, height, format, NULL, TEST_ALIGN(width));
         View d2(width, height, format, NULL, TEST_ALIGN(width));
 
         if (create)
         {
             FillRandom(s);
             TEST_SAVE(s);
 
             f.Call(s, d1);
 
             TEST_SAVE(d1);
         }
         else
         {
             TEST_LOAD(s);
 
             TEST_LOAD(d1);
 
             f.Call(s, d2);
 
             TEST_SAVE(d2);
 
             result = result && Compare(d1, d2, 0, true, 64);
         }
 
         return result;
     }
 
     bool ResizeBilinearDataTest(bool create)
     {
         bool result = true;
 
         FuncRB f = FUNC_RB(SimdResizeBilinear);
         for (View::Format format = View::Gray8; format <= View::Bgra32; format = View::Format(format + 1))
         {
             result = result && ResizeDataTest(create, DW, DH, format, FuncRB(f.func, f.description + Data::Description(format)));
         }
 
         return result;
     }
 
     //-----------------------------------------------------------------------
 
     bool ResizeSpecialTest(View::Format format, const Size & src, const Size & dst, const FuncRB & f1, const FuncRB & f2)
     {
         bool result = true;
 
         TEST_LOG_SS(Info, "Test " << f1.description << " & " << f2.description << " [" << src.x << ", " << src.y << "] -> [" << dst.x << ", " << dst.y << "].");
 
         View s(src.x, src.y, format, NULL, TEST_ALIGN(src.x));
         FillRandom(s);
 
         View d1(dst.x, dst.y, format, NULL, TEST_ALIGN(dst.x));
         View d2(dst.x, dst.y, format, NULL, TEST_ALIGN(dst.x));
 
         f1.Call(s, d1);
 
         f2.Call(s, d2);
 
         result = result && Compare(d1, d2, 0, true, 64);
 
         return result;
     }
 
     bool ResizeSpecialTest(const FuncRB & f1, const FuncRB & f2)
     {
         bool result = true;
 
         result = result && ResizeSpecialTest(ARGS_RB2(View::Bgr24, Size(1920, 1080), Size(224, 224), f1, f2));
         result = result && ResizeSpecialTest(ARGS_RB2(View::Gray8, Size(352, 240), Size(174, 94), f1, f2));
 
         for (Size dst(128, 8); dst.x < 144; ++dst.x)
             for (Size src(32, 12); src.x < 512; ++src.x)
                 result = result && ResizeSpecialTest(ARGS_RB2(View::Gray8, src, dst, f1, f2));
 
         return result;
     }
 
     bool ResizeBilinearSpecialTest()
     {
         bool result = true;
 
         result = result && ResizeSpecialTest(FUNC_RB(Simd::Base::ResizeBilinear), FUNC_RB(SimdResizeBilinear));
 
 #ifdef SIMD_SSE2_ENABLE
         if (Simd::Sse2::Enable)
             result = result && ResizeSpecialTest(FUNC_RB(Simd::Sse2::ResizeBilinear), FUNC_RB(SimdResizeBilinear));
 #endif
 
 #ifdef SIMD_SSE41_ENABLE
         if (Simd::Sse41::Enable)
             result = result && ResizeSpecialTest(FUNC_RB(Simd::Sse41::ResizeBilinear), FUNC_RB(SimdResizeBilinear));
 #endif 
 
 #ifdef SIMD_AVX2_ENABLE
         if (Simd::Avx2::Enable)
             result = result && ResizeSpecialTest(FUNC_RB(Simd::Avx2::ResizeBilinear), FUNC_RB(SimdResizeBilinear));
 #endif 
 
 #ifdef SIMD_AVX512BW_ENABLE
         if (Simd::Avx512bw::Enable)
             result = result && ResizeSpecialTest(FUNC_RB(Simd::Avx512bw::ResizeBilinear), FUNC_RB(SimdResizeBilinear));
 #endif 
 
 #ifdef SIMD_VMX_ENABLE
         if (Simd::Vmx::Enable)
             result = result && ResizeSpecialTest(FUNC_RB(Simd::Vmx::ResizeBilinear), FUNC_RB(SimdResizeBilinear));
 #endif
 
 #ifdef SIMD_NEON_ENABLE
         if (Simd::Neon::Enable)
             result = result && ResizeSpecialTest(FUNC_RB(Simd::Neon::ResizeBilinear), FUNC_RB(SimdResizeBilinear));
 #endif
 
         return result;
     }
 }
