commit 9c74581c7827a6e1aea0f0a6f787ae22b4331a12
Author: jeanlf <jeanlf@gpac.io>
Date:   Thu Jan 27 10:03:52 2022 +0100

    fixed #2064

diff --git a/include/gpac/bitstream.h b/include/gpac/bitstream.h
index a1d439a71..ee7436b4c 100644
--- a/include/gpac/bitstream.h
+++ b/include/gpac/bitstream.h
@@ -622,14 +622,34 @@ Gets the current cookie on the bitstream
 \param bs the target bitstream
 \return the current cookie value
  */
 u64 gf_bs_get_cookie(GF_BitStream *bs);
 
+
+/*!
+\brief Marks overflow access
+
+Marks the bitstream as overflown (reading outside of buffer range). Marking is done automatically when reading but can be forced using this function.
+
+\param bs the target bitstream
+\param reset if GF_TRUE, reset overflown state, otherwise mark as overflown
+ */
+void gf_bs_mark_overflow(GF_BitStream *bs, Bool reset);
+
+/*!
+\brief Gets overflow state
+
+Gets overflow state of the bitstream
+\param bs the target bitstream
+\return 2 if an overflow was marked by user using \ref gf_bs_mark_overflow, 1 if an overflow occured, 0 otherwise
+ */
+u32 gf_bs_is_overflow(GF_BitStream *bs);
+
 /*! @} */
 
 #ifdef __cplusplus
 }
 #endif
 
 
 #endif		/*_GF_BITSTREAM_H_*/
 
diff --git a/include/gpac/internal/media_dev.h b/include/gpac/internal/media_dev.h
index c1e20b011..c2c2833db 100644
--- a/include/gpac/internal/media_dev.h
+++ b/include/gpac/internal/media_dev.h
@@ -889,90 +889,90 @@ typedef struct
 typedef struct
 {
 	/*importing options*/
 	Bool keep_temporal_delim;
 	/*parser config*/
 	//if set only header frames are stored
 	Bool skip_frames;
 	//if set, frame OBUs are not pushed to the frame_obus OBU list but are written in the below bitstream
 	Bool mem_mode;
 	/*bitstream object for mem mode - this bitstream is NOT destroyed by gf_av1_reset_state(state, GF_TRUE) */
 	GF_BitStream *bs;
-	Bool bs_overread, unframed;
+	Bool unframed;
 	u8 *frame_obus;
 	u32 frame_obus_alloc;
 
 	/*general sequence information*/
 	Bool frame_id_numbers_present_flag;
 	Bool reduced_still_picture_header;
 	Bool decoder_model_info_present_flag;
 	u16 OperatingPointIdc;
 	u32 width, height, UpscaledWidth;
 	u32 sequence_width, sequence_height;
 	u32 tb_num, tb_den;
 
 	Bool use_128x128_superblock;
 	u8 frame_width_bits_minus_1, frame_height_bits_minus_1;
 	u8 equal_picture_interval;
 	u8 delta_frame_id_length_minus_2;
 	u8 additional_frame_id_length_minus_1;
 	u8 seq_force_integer_mv;
 	u8 seq_force_screen_content_tools;
 	Bool enable_superres;
 	Bool enable_order_hint;
 	Bool enable_cdef;
 	Bool enable_restoration;
 	Bool enable_warped_motion;
 	u8 OrderHintBits;
 	Bool enable_ref_frame_mvs;
 	Bool film_grain_params_present;
 	u8 buffer_delay_length;
 	u8 frame_presentation_time_length;
 	u32 buffer_removal_time_length;
 	u8 operating_points_count;
 	u8 decoder_model_present_for_this_op[32];
 	u8 operating_point_idc[32];
 
 	u32 tileRows, tileCols, tileRowsLog2, tileColsLog2;
 	u8 tile_size_bytes; /*coding tile header size*/
 	Bool separate_uv_delta_q;
 
 	/*Needed for RFC6381*/
 	Bool still_picture;
 	u8 bit_depth;
 	Bool color_description_present_flag;
 	u8 color_primaries, transfer_characteristics, matrix_coefficients;
 	Bool color_range;
 
 	/*AV1 config record - shall not be null when parsing - this is NOT destroyed by gf_av1_reset_state(state, GF_TRUE) */
 	GF_AV1Config *config;
 
 	/*OBU parsing state, reset at each obu*/
 	Bool obu_has_size_field, obu_extension_flag;
 	u8 temporal_id, spatial_id;
 	ObuType obu_type;
 
 	/*inter-frames state */
 	u8 RefOrderHint[AV1_NUM_REF_FRAMES];
 	u8 RefValid[AV1_NUM_REF_FRAMES];
 	u8 OrderHints[AV1_NUM_REF_FRAMES];
 
 	AV1GMParams GmParams;
 	AV1GMParams PrevGmParams;
 	AV1GMParams SavedGmParams[AV1_NUM_REF_FRAMES];
 	u8 RefFrameType[AV1_NUM_REF_FRAMES];
 
 	u32 RefUpscaledWidth[AV1_NUM_REF_FRAMES];
 	u32 RefFrameHeight[AV1_NUM_REF_FRAMES];
 
 	/*frame parsing state*/
 	AV1StateFrame frame_state;
 
 	/*layer sizes for AVIF a1lx*/
 	u32 layer_size[4];
 
 
 	u8 clli_data[4];
 	u8 mdcv_data[24];
 	u8 clli_valid, mdcv_valid;
 
 } AV1State;
diff --git a/src/filters/bs_agg.c b/src/filters/bs_agg.c
index 13edde450..e29077169 100644
--- a/src/filters/bs_agg.c
+++ b/src/filters/bs_agg.c
@@ -439,248 +439,260 @@ static GF_Err none_process(BSAggCtx *ctx, BSAggOut *c_opid)
 static GF_Err nalu_process(BSAggCtx *ctx, BSAggOut *pctx, u32 codec_type)
 {
 	u32 size, pck_size, i, count, tot_size=0, nb_done=0;
 	u64 min_dts = GF_FILTER_NO_TS;
-	u32 min_timescale;
+	u32 min_timescale, min_nal_size;
 	GF_Err process_error = GF_OK;
 	Bool has_svc_prefix = GF_FALSE;
 
+	min_nal_size = codec_type ? 2 : 1;
+
 	count = gf_list_count(pctx->ipids);
 	for (i=0; i<count; i++) {
 		u64 ts;
 		u32 timescale;
 		GF_FilterPid *pid = gf_list_get(pctx->ipids, i);
 		GF_FilterPacket *pck = gf_filter_pid_get_packet(pid);
 		if (!pck) {
 			if (gf_filter_pid_is_eos(pid)) {
 				nb_done++;
 				continue;
 			}
 			return GF_OK;
 		}
 		ts = gf_filter_pck_get_dts(pck);
 		if (ts==GF_FILTER_NO_TS)
 			ts = gf_filter_pck_get_cts(pck);
 		if (ts==GF_FILTER_NO_TS) {
 			ts = 0;
 		}
 		timescale = gf_filter_pck_get_timescale(pck);
 		if (min_dts==GF_FILTER_NO_TS) {
 			min_dts = ts;
 			min_timescale = timescale;
 		} else if (gf_timestamp_less(ts, timescale, min_dts, min_timescale)) {
 			min_dts = ts;
 			min_timescale = timescale;
 		}
 	}
 	if (nb_done==count) {
 		gf_filter_pid_set_eos(pctx->opid);
 		return GF_EOS;
 	}
 
 	for (i=0; i<count; i++) {
 		GF_Err e = GF_OK;
 		u64 ts;
 		u32 timescale;
 		u32 svc_layer_id=0, svc_temporal_id=0;
 		GF_FilterPid *pid = gf_list_get(pctx->ipids, i);
 		GF_FilterPacket *pck = gf_filter_pid_get_packet(pid);
 		if (!pck) continue;
 
 		ts = gf_filter_pck_get_dts(pck);
 		if (ts==GF_FILTER_NO_TS) ts = gf_filter_pck_get_cts(pck);
 		if (ts==GF_FILTER_NO_TS) ts = 0;
 
 		timescale = gf_filter_pck_get_timescale(pck);
 		if (! gf_timestamp_less_or_equal(ts, timescale, min_dts, min_timescale)) continue;
 
 		const u8 *data = gf_filter_pck_get_data(pck, &pck_size);
 		if (!data) continue;
 
 		u32 nalu_size_length = gf_filter_pid_get_udta_flags(pid);
 
 		size=0;
 		while (size<pck_size) {
 			u32 nal_type=0;
 			u32 layer_id = 0;
 			u32 temporal_id = 0;
 			u32 nal_hdr = nalu_size_length;
 			u32 nal_size = 0;
 			while (nal_hdr) {
 				nal_size |= data[size];
 				size++;
 				nal_hdr--;
 				if (!nal_hdr) break;
 				nal_size<<=8;
 			}
 			if (size + nal_size > pck_size) {
 				GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, ("[BSAgg] Invalid NAL size %d but remain %d\n", nal_size, pck_size-size));
 				e = GF_NON_COMPLIANT_BITSTREAM;
 				break;
 			}
+			if (nal_size < min_nal_size) {
+				GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, ("[BSAgg] Invalid NAL size %d but mn size %d\n", nal_size, min_nal_size));
+				e = GF_NON_COMPLIANT_BITSTREAM;
+				break;
+			}
 
 			//AVC
 			if (codec_type==0) {
 				nal_type = data[size] & 0x1F;
 				if ((nal_type == GF_AVC_NALU_SVC_PREFIX_NALU) || (nal_type==GF_AVC_NALU_SVC_SLICE)) {
+					if (nal_size < 4) {
+						GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, ("[BSAgg] Invalid NAL size %d but mn size 4\n", nal_size));
+						e = GF_NON_COMPLIANT_BITSTREAM;
+						break;
+					}
 					has_svc_prefix = GF_TRUE;
 					//quick parse svc nal header (right after 1-byte nal header)
 					//u32 prio_id = (data[size+1]) & 0x3F;
 					u32 dep_id = (data[size+2] >> 4) & 0x7;
 					u32 qual_id = (data[size+2]) & 0xF;
 					u32 temporal_id = (data[size+3]>>5) & 0x7;
 
 					svc_temporal_id = temporal_id;
 					svc_layer_id = ctx->svcqid ? qual_id : dep_id;
 				}
 				if (has_svc_prefix) {
 					layer_id = svc_layer_id;
 					temporal_id = svc_temporal_id;
 				}
 
 				//force layerID 100 for DV
 				if ((nal_type == GF_AVC_NALU_DV_RPU) || (nal_type == GF_AVC_NALU_DV_EL)) {
 					layer_id = 100;
 				}
 				//don't forward extractors
 				//todo, find a way to differentiate DV EL from naluff aggregator
 				else if ((nal_type == GF_AVC_NALU_FF_EXTRACTOR)
 					|| (nal_type == GF_AVC_NALU_ACCESS_UNIT)
 				) {
 					size += nal_size;
 					continue;
 				}
 			}
 			//HEVC
 			else if (codec_type==1) {
 				nal_type = (data[size] & 0x7E) >> 1;
 
 				layer_id = data[size] & 1;
 				layer_id <<= 5;
 				layer_id |= (data[size+1] >> 3) & 0x1F;
 				temporal_id = (data[size+1] & 0x7);
 
 				if (nal_type == GF_HEVC_NALU_ACCESS_UNIT) {
 					size += nal_size;
 					continue;
 				}
 
 				//force layerID 100 for DV
 				if ((nal_type == GF_HEVC_NALU_DV_RPU) || (nal_type == GF_HEVC_NALU_DV_EL)) {
 					layer_id = 100;
 				}
 				//don't forward extractors nor aggregators
 				else if ((nal_type == GF_HEVC_NALU_FF_EXTRACTOR)
 					|| (nal_type == GF_HEVC_NALU_FF_AGGREGATOR)
 					|| (nal_type == GF_AVC_NALU_ACCESS_UNIT)
 				) {
 					size += nal_size;
 					continue;
 				}
 			}
 			//VVC
 			else if (codec_type==2) {
 				layer_id = data[size] & 0x3F;
 				temporal_id = data[size+1] & 0x7;
 				nal_type = data[size+1] >> 3;
 
 				if (nal_type == GF_VVC_NALU_ACCESS_UNIT) {
 					size += nal_size;
 					continue;
 				}
 			}
 			//push nal
 			NALStore *ns = NULL;
 			s32 next_ns_idx = -1;
 			u32 nal_count = gf_list_count(pctx->nal_stores);
 			for (u32 j=0; j<nal_count; j++) {
 				ns = gf_list_get(pctx->nal_stores, j);
 				if ((ns->lid == layer_id) && (ns->tid == temporal_id))
 					break;
 
 				//same layer, tid greater than ours: insert nal
 				if (ns->lid==layer_id) {
 					if (ns->tid > temporal_id) {
 						next_ns_idx = j;
 						ns = NULL;
 						break;
 					}
 				}
 				if (ns->lid>layer_id) {
 					next_ns_idx = j;
 					ns = NULL;
 					break;
 				}
 				ns = NULL;
 			}
 
 			if (!ns) {
 				GF_SAFEALLOC(ns, NALStore)
 				if (!ns) {
 					e = GF_OUT_OF_MEM;
 					break;
 				}
 				ns->lid = layer_id;
 				ns->tid = temporal_id;
 				if (next_ns_idx>=0) {
 					gf_list_insert(pctx->nal_stores, ns, next_ns_idx);
 				} else {
 					gf_list_add(pctx->nal_stores, ns);
 				}
 			}
 			if (ns->alloc_size < ns->size+nal_size+4) {
 				ns->alloc_size = ns->size+nal_size+4;
 				ns->data = gf_realloc(ns->data, ns->alloc_size);
 				if (!ns->data) {
 					e = GF_OUT_OF_MEM;
 					break;
 				}
 			}
 			u8 *dst = ns->data + ns->size;
 			//write nal header
 			nal_hdr=4;
 			while (nal_hdr) {
 				nal_hdr--;
 				*dst = (nal_size>>(8*nal_hdr)) & 0xFF;
 				dst++;
 			}
 			//write nal
 			memcpy(dst, data + size, nal_size);
 			ns->size+= nal_size + 4;
 			tot_size += nal_size + 4;
 
 			size += nal_size;
 		}
 		//if not created, alloc output packet with 4 bytes and copy packet props
 		if (size && !pctx->pck) {
 			pctx->pck = gf_filter_pck_new_alloc(pctx->opid, 4, NULL);
 			if (!pctx->pck) {
 				e = GF_OUT_OF_MEM;
 				break;
 			}
 			gf_filter_pck_merge_properties(pck, pctx->pck);
 		}
 		//drop packet
 		gf_filter_pid_drop_packet(pid);
 
 		if (e) process_error = e;
 	}
 
 	if (!tot_size) return process_error;
 
 	//realloc packet to total size
 	u8 *output=NULL;
 	gf_filter_pck_expand(pctx->pck, tot_size-4, &output, NULL, NULL);
 	u32 nal_count = gf_list_count(pctx->nal_stores);
 	for (u32 j=0; j<nal_count; j++) {
 		NALStore *ns = gf_list_get(pctx->nal_stores, j);
 		if (!ns->size) continue;
 
 		memcpy(output, ns->data, ns->size);
 		output+= ns->size;
 		ns->size = 0;
 	}
 
 	gf_filter_pck_send(pctx->pck);
 	pctx->pck = NULL;
 	return GF_OK;
 }
diff --git a/src/filters/bs_split.c b/src/filters/bs_split.c
index d8713ceeb..7dba22b84 100644
--- a/src/filters/bs_split.c
+++ b/src/filters/bs_split.c
@@ -1014,216 +1014,222 @@ static GF_Err none_split_packet(BSSplitCtx *ctx, BSSplitIn *pctx, GF_FilterPacke
 
 static GF_Err nalu_split_packet(BSSplitCtx *ctx, BSSplitIn *pctx, GF_FilterPacket *pck, u32 codec_type)
 {
-	u32 size, pck_size;
+	u32 size, pck_size, min_nal_size;
 	GF_Err e;
 	u64 pck_ts;
 	Bool has_svc_prefix = GF_FALSE;
 	const u8 *data = gf_filter_pck_get_data(pck, &pck_size);
 	if (!data) {
 		BSSplitOut *c_opid = gf_list_get(pctx->opids, 0);
 		if (c_opid)
 			return gf_filter_pck_forward(pck, c_opid->opid);
 		return GF_OK;
 	}
 
 	pck_ts = gf_filter_pck_get_dts(pck);
 	if (pck_ts == GF_FILTER_NO_TS)
 		pck_ts = gf_filter_pck_get_cts(pck);
 	if (pck_ts == GF_FILTER_NO_TS)
 		pck_ts = 0;
 	if (!pctx->first_ts_plus_one) {
 		pctx->first_ts_plus_one = pck_ts+1;
 	}
+	min_nal_size = codec_type ? 2 : 1;
 
 	size=0;
 	while (size<pck_size) {
 		Bool force_dv = GF_FALSE;
 		u32 nal_type=0;
 		u32 layer_id = 0;
 		u32 temporal_id = 0;
 		u32 nal_hdr = pctx->nalu_size_length;
 		u32 nal_size = 0;
 		while (nal_hdr) {
 			nal_size |= data[size];
 			size++;
 			nal_hdr--;
 			if (!nal_hdr) break;
 			nal_size<<=8;
 		}
 		if (size + nal_size > pck_size) {
 			GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, ("[BSSplit] Invalid NAL size %d but remain %d\n", nal_size, pck_size-size));
 			e = GF_NON_COMPLIANT_BITSTREAM;
 			break;
 		}
+		if (nal_size < min_nal_size) {
+			GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, ("[BSSplit] Invalid NAL size %d but mn size %d\n", nal_size, min_nal_size));
+			e = GF_NON_COMPLIANT_BITSTREAM;
+			break;
+		}
 
 		//AVC
 		if (codec_type==0) {
 			Bool get_dqid=GF_FALSE;
 			gf_bs_reassign_buffer(pctx->r_bs, data+size, nal_size);
 			gf_avc_parse_nalu(pctx->r_bs, pctx->avc_state);
 			nal_type = pctx->avc_state->last_nal_type_parsed;
 			temporal_id = 1;
 			//remember we had an svc prefix
 			if (nal_type == GF_AVC_NALU_SVC_PREFIX_NALU) {
 				has_svc_prefix = GF_TRUE;
 			}
 			//if slice is scalable extension, get dqid
 			else if ((nal_type == GF_AVC_NALU_SVC_SLICE) && pctx->avc_state->s_info.pps) {
 				//svc prefix is no longer valid
 				has_svc_prefix = GF_FALSE;
 				get_dqid = GF_TRUE;
 			}
 			//don't forward extractors
 			else if (nal_type == GF_AVC_NALU_FF_EXTRACTOR) {
 				size += nal_size;
 				continue;
 			}
 			//todo, find a way to differentiate between FF AVC aggregator and DV EL ...
 
 
 			//if we had an svc prefix, get dqid
 			if (has_svc_prefix) {
 				get_dqid = GF_TRUE;
 			}
 
 			if (get_dqid) {
 				if (ctx->svcqid)
 					layer_id = pctx->avc_state->s_info.svc_nalhdr.quality_id;
 				else
 					layer_id = pctx->avc_state->s_info.svc_nalhdr.dependency_id;
 
 				temporal_id = 1+pctx->avc_state->s_info.svc_nalhdr.temporal_id;
 			}
 
 			//force layerID 100 for DV
 			if ((nal_type == GF_AVC_NALU_DV_RPU) || (nal_type == GF_AVC_NALU_DV_EL)) {
 				layer_id = 100;
 				force_dv = GF_TRUE;
 			}
 
 		}
 		//HEVC
 		else if (codec_type==1) {
 			nal_type = (data[size] & 0x7E) >> 1;
 
 			layer_id = data[size] & 1;
 			layer_id <<= 5;
 			layer_id |= (data[size+1] >> 3) & 0x1F;
 			temporal_id = (data[size+1] & 0x7);
 
 			//force layerID 100 for DV
 			if ((nal_type == GF_HEVC_NALU_DV_RPU) || (nal_type == GF_HEVC_NALU_DV_EL)) {
 				layer_id = 100;
 				force_dv = GF_TRUE;
 			}
 			//don't forward extractors nor aggregators
 			else if ((nal_type == GF_HEVC_NALU_FF_EXTRACTOR) || (nal_type == GF_HEVC_NALU_FF_AGGREGATOR)) {
 				size += nal_size;
 				continue;
 			}
 		}
 		//VVC
 		else if (codec_type==2) {
 			layer_id = data[size] & 0x3F;
 			temporal_id = data[size+1] & 0x7;
 			nal_type = data[size+1] >> 3;
 		}
 
 		BSSplitOut *c_opid = bs_split_get_out_stream(ctx, pctx, GF_FALSE, layer_id, temporal_id, force_dv);
 		if (!c_opid) {
 			e = GF_OUT_OF_MEM;
 			break;
 		}
 
 		u8 *out_data;
 
 		if (!c_opid->is_init) {
 			u64 ts_diff = pck_ts - (pctx->first_ts_plus_one-1);
 			c_opid->is_init = GF_TRUE;
 
 			//tsdiff not 0, we are starting a new split stream on a temporal sublayer, inject empty AU with a single NALU AU delim
 			//we do so because we need to make sure the muxer will not screw up timing:
 			//for mp4 not fragmented, not injecting will result in this sample (being the first) having dts=0 plus edit
 			//which will unalign the tracks in terms of dts/ctts, which is what implicit reconstruction uses....
 			if (ts_diff) {
 				u32 isize;
 				u8 *idata;
 
 				if (codec_type==1) isize=3;
 				else if (codec_type==2) isize=3;
 				else isize=2;
 				GF_FilterPacket *inject_pck = gf_filter_pck_new_alloc(c_opid->opid, isize+pctx->nalu_size_length, &idata);
 				if (!inject_pck) {
 					e = GF_OUT_OF_MEM;
 					break;
 				}
 				GF_BitStream *aud_bs = gf_bs_new(idata, isize+pctx->nalu_size_length, GF_BITSTREAM_WRITE);
 				if (!aud_bs) {
 					e = GF_OUT_OF_MEM;
 					break;
 				}
 
 				gf_bs_write_int(aud_bs, isize, 8*pctx->nalu_size_length);
 				if (codec_type==1) {
 					gf_bs_write_int(aud_bs, 0, 1);
 					gf_bs_write_int(aud_bs, GF_HEVC_NALU_ACCESS_UNIT, 6);
 					gf_bs_write_int(aud_bs, layer_id, 6);
 					gf_bs_write_int(aud_bs, temporal_id, 3);
 					/*pic-type - by default we signal all slice types possible*/
 					gf_bs_write_int(aud_bs, 2, 3);
 					gf_bs_write_int(aud_bs, 1, 1); //stop bit
 					gf_bs_write_int(aud_bs, 0, 4); //4 bits to 0
 				} else if (codec_type==2) {
 					gf_bs_write_int(aud_bs, 0, 1);
 					gf_bs_write_int(aud_bs, 0, 1);
 					gf_bs_write_int(aud_bs, layer_id, 6);
 					gf_bs_write_int(aud_bs, GF_VVC_NALU_ACCESS_UNIT, 5);
 					gf_bs_write_int(aud_bs, temporal_id, 3);
 					gf_bs_write_int(aud_bs, 0, 1);
 					/*pic-type - by default we signal all slice types possible*/
 					gf_bs_write_int(aud_bs, 2, 3);
 					gf_bs_write_int(aud_bs, 1, 1); //stop bit
 					gf_bs_write_int(aud_bs, 0, 3); //3 bits to 0
 				} else {
 					gf_bs_write_int(aud_bs, (data[size] & 0x60) | GF_AVC_NALU_ACCESS_UNIT, 8);
 					gf_bs_write_int(aud_bs, 0xF0 , 8); /*7 "all supported NALUs" (=111) + rbsp trailing (10000)*/;
 				}
 				gf_bs_del(aud_bs);
 
 				gf_filter_pck_set_dts(inject_pck, pctx->first_ts_plus_one-1);
 				gf_filter_pck_set_cts(inject_pck, pctx->first_ts_plus_one-1);
 				gf_filter_pck_set_duration(inject_pck, ts_diff);
 				gf_filter_pck_set_framing(inject_pck, GF_TRUE, GF_TRUE);
 				gf_filter_pck_send(inject_pck);
 			}
 		}
 
 		if (!c_opid->pck) {
 			c_opid->pck = gf_filter_pck_new_alloc(c_opid->opid, nal_size+pctx->nalu_size_length, &out_data);
 			if (!c_opid->pck) {
 				e = GF_OUT_OF_MEM;
 				break;
 			}
 			gf_filter_pck_merge_properties(pck, c_opid->pck);
 
 			if (!c_opid->is_base)
 				gf_filter_pck_set_sap(c_opid->pck, GF_FILTER_SAP_NONE);
 		} else {
 			e = gf_filter_pck_expand(c_opid->pck, nal_size+pctx->nalu_size_length, NULL, &out_data, NULL);
 			if (e) break;
 		}
 		memcpy(out_data, data + size - pctx->nalu_size_length, nal_size+pctx->nalu_size_length);
 
 		size += nal_size;
 	}
 
 	u32 i, count = gf_list_count(pctx->opids);
 	for (i=0; i<count; i++) {
 		BSSplitOut *c_opid = gf_list_get(pctx->opids, i);
 		if (c_opid->pck) {
 			gf_filter_pck_send(c_opid->pck);
 			c_opid->pck = NULL;
 		}
 	}
 	return e;
 }
diff --git a/src/filters/inspect.c b/src/filters/inspect.c
index 6512a6a66..6e106fd45 100644
--- a/src/filters/inspect.c
+++ b/src/filters/inspect.c
@@ -548,645 +548,654 @@ static void dump_sei(FILE *dump, GF_BitStream *bs, Bool is_hevc)
 static void gf_inspect_dump_nalu_internal(FILE *dump, u8 *ptr, u32 ptr_size, Bool is_svc, HEVCState *hevc, AVCState *avc, VVCState *vvc, u32 nalh_size, Bool dump_crc, Bool is_encrypted, u32 full_bs_dump, PidCtx *pctx)
 {
 	s32 res = 0;
 	u8 type, nal_ref_idc;
 	u8 dependency_id, quality_id, temporal_id;
 	u8 track_ref_index;
 	s8 sample_offset;
 	u32 data_offset, data_size;
 	s32 idx;
 	InspectLogCbk lcbk;
 	GF_BitStream *bs = NULL;
 	const char *nal_name;
 
 	if (full_bs_dump<INSPECT_ANALYZE_BS)
 		full_bs_dump = 0;
 	else {
 		lcbk.dump = dump;
 		lcbk.dump_bits = full_bs_dump==INSPECT_ANALYZE_BS_BITS ? GF_TRUE : GF_FALSE;
 	}
 
 	if (!ptr_size) {
 		gf_fprintf(dump, "error=\"invalid nal size 0\"/>\n");
 		return;
 	}
 
 	if (dump_crc) gf_fprintf(dump, "crc=\"%u\" ", gf_crc_32(ptr, ptr_size) );
 
 	if (hevc) {
 #ifndef GPAC_DISABLE_HEVC
 
-		if (ptr_size==1) {
+		if (ptr_size<=1) {
 			gf_fprintf(dump, "error=\"invalid nal size 1\"/>\n");
 			return;
 		}
 
 		if (full_bs_dump) {
 			if (pctx) {
 				if (!pctx->bs)
 					pctx->bs = gf_bs_new(ptr, ptr_size, GF_BITSTREAM_READ);
 				else
 					gf_bs_reassign_buffer(pctx->bs, ptr, ptr_size);
 				bs = pctx->bs;
 			} else {
 				bs = gf_bs_new(ptr, ptr_size, GF_BITSTREAM_READ);
 			}
 			gf_bs_set_logger(bs, regular_bs_log, &lcbk);
 			res = gf_hevc_parse_nalu_bs(bs, hevc, &type, &temporal_id, &quality_id);
 		} else {
 			bs = NULL;
 			res = gf_hevc_parse_nalu(ptr, ptr_size, hevc, &type, &temporal_id, &quality_id);
 			gf_fprintf(dump, "code=\"%d\"", type);
 		}
 
 		if (res==-1) {
 			gf_fprintf(dump, " status=\"error parsing\"", type);
 		}
 		gf_fprintf(dump, " type=\"", type);
 		nal_name = get_hevc_nal_name(type);
 		if (nal_name)
 			gf_fputs(nal_name, dump);
 		else
 			gf_fprintf(dump, "UNKNOWN (parsing return %d)", res);
 
 		//specific dump
 		switch (type) {
 		case GF_HEVC_NALU_VID_PARAM:
 			if (full_bs_dump) break;
 			idx = gf_hevc_read_vps(ptr, ptr_size, hevc);
 			if (idx<0) gf_fprintf(dump, "\" vps_id=\"PARSING FAILURE");
 			else gf_fprintf(dump, "\" vps_id=\"%d", idx);
 			break;
 		case GF_HEVC_NALU_SEQ_PARAM:
 			if (full_bs_dump) break;
 			idx = gf_hevc_read_sps(ptr, ptr_size, hevc);
 			if (idx<0) {
 				gf_fprintf(dump, "\" sps_id=\"PARSING FAILURE");
 				break;
 			}
 			{
 			HEVC_SPS *sps= &hevc->sps[idx];
 			gf_fprintf(dump, "\" sps_id=\"%d", idx);
 
 			gf_fprintf(dump, "\" aspect_ratio_info_present_flag=\"%d", sps->aspect_ratio_info_present_flag);
 			gf_fprintf(dump, "\" bit_depth_chroma=\"%d", sps->bit_depth_chroma);
 			gf_fprintf(dump, "\" bit_depth_luma=\"%d", sps->bit_depth_luma);
 			gf_fprintf(dump, "\" chroma_format_idc=\"%d", sps->chroma_format_idc);
 			gf_fprintf(dump, "\" colour_description_present_flag=\"%d", sps->colour_description_present_flag);
 			gf_fprintf(dump, "\" colour_primaries=\"%d", sps->colour_primaries);
 			gf_fprintf(dump, "\" cw_flag=\"%d", sps->cw_flag);
 			if (sps->cw_flag) {
 				gf_fprintf(dump, "\" cw_bottom=\"%d", sps->cw_bottom);
 				gf_fprintf(dump, "\" cw_top=\"%d", sps->cw_top);
 				gf_fprintf(dump, "\" cw_left=\"%d", sps->cw_left);
 				gf_fprintf(dump, "\" cw_right=\"%d", sps->cw_right);
 			}
 			gf_fprintf(dump, "\" height=\"%d", sps->height);
 			gf_fprintf(dump, "\" width=\"%d", sps->width);
 			gf_fprintf(dump, "\" log2_max_pic_order_cnt_lsb=\"%d", sps->log2_max_pic_order_cnt_lsb);
 			gf_fprintf(dump, "\" long_term_ref_pics_present_flag=\"%d", sps->long_term_ref_pics_present_flag);
 			gf_fprintf(dump, "\" matrix_coeffs=\"%d", sps->matrix_coeffs);
 			gf_fprintf(dump, "\" max_CU_depth=\"%d", sps->max_CU_depth);
 			gf_fprintf(dump, "\" max_CU_width=\"%d", sps->max_CU_width);
 			gf_fprintf(dump, "\" max_CU_height=\"%d", sps->max_CU_height);
 			gf_fprintf(dump, "\" num_long_term_ref_pic_sps=\"%d", sps->num_long_term_ref_pic_sps);
 			gf_fprintf(dump, "\" num_short_term_ref_pic_sets=\"%d", sps->num_short_term_ref_pic_sets);
 			gf_fprintf(dump, "\" has_timing_info=\"%d", sps->has_timing_info);
 			if (sps->has_timing_info) {
 				gf_fprintf(dump, "\" time_scale=\"%d", sps->time_scale);
 				gf_fprintf(dump, "\" num_ticks_poc_diff_one_minus1=\"%d", sps->num_ticks_poc_diff_one_minus1);
 				gf_fprintf(dump, "\" num_units_in_tick=\"%d", sps->num_units_in_tick);
 				gf_fprintf(dump, "\" poc_proportional_to_timing_flag=\"%d", sps->poc_proportional_to_timing_flag);
 			}
 			gf_fprintf(dump, "\" rep_format_idx=\"%d", sps->rep_format_idx);
 			gf_fprintf(dump, "\" sample_adaptive_offset_enabled_flag=\"%d", sps->sample_adaptive_offset_enabled_flag);
 			gf_fprintf(dump, "\" sar_idc=\"%d", sps->sar_idc);
 			gf_fprintf(dump, "\" separate_colour_plane_flag=\"%d", sps->separate_colour_plane_flag);
 			gf_fprintf(dump, "\" temporal_mvp_enable_flag=\"%d", sps->temporal_mvp_enable_flag);
 			gf_fprintf(dump, "\" transfer_characteristic=\"%d", sps->transfer_characteristic);
 			gf_fprintf(dump, "\" video_full_range_flag=\"%d", sps->video_full_range_flag);
 			gf_fprintf(dump, "\" sps_ext_or_max_sub_layers_minus1=\"%d", sps->sps_ext_or_max_sub_layers_minus1);
 			gf_fprintf(dump, "\" max_sub_layers_minus1=\"%d", sps->max_sub_layers_minus1);
 			gf_fprintf(dump, "\" update_rep_format_flag=\"%d", sps->update_rep_format_flag);
 			gf_fprintf(dump, "\" sub_layer_ordering_info_present_flag=\"%d", sps->sub_layer_ordering_info_present_flag);
 			gf_fprintf(dump, "\" scaling_list_enable_flag=\"%d", sps->scaling_list_enable_flag);
 			gf_fprintf(dump, "\" infer_scaling_list_flag=\"%d", sps->infer_scaling_list_flag);
 			gf_fprintf(dump, "\" scaling_list_ref_layer_id=\"%d", sps->scaling_list_ref_layer_id);
 			gf_fprintf(dump, "\" scaling_list_data_present_flag=\"%d", sps->scaling_list_data_present_flag);
 			gf_fprintf(dump, "\" asymmetric_motion_partitions_enabled_flag=\"%d", sps->asymmetric_motion_partitions_enabled_flag);
 			gf_fprintf(dump, "\" pcm_enabled_flag=\"%d", sps->pcm_enabled_flag);
 			gf_fprintf(dump, "\" strong_intra_smoothing_enable_flag=\"%d", sps->strong_intra_smoothing_enable_flag);
 			gf_fprintf(dump, "\" vui_parameters_present_flag=\"%d", sps->vui_parameters_present_flag);
 			gf_fprintf(dump, "\" log2_diff_max_min_luma_coding_block_size=\"%d", sps->log2_diff_max_min_luma_coding_block_size);
 			gf_fprintf(dump, "\" log2_min_transform_block_size=\"%d", sps->log2_min_transform_block_size);
 			gf_fprintf(dump, "\" log2_min_luma_coding_block_size=\"%d", sps->log2_min_luma_coding_block_size);
 			gf_fprintf(dump, "\" log2_max_transform_block_size=\"%d", sps->log2_max_transform_block_size);
 			gf_fprintf(dump, "\" max_transform_hierarchy_depth_inter=\"%d", sps->max_transform_hierarchy_depth_inter);
 			gf_fprintf(dump, "\" max_transform_hierarchy_depth_intra=\"%d", sps->max_transform_hierarchy_depth_intra);
 			gf_fprintf(dump, "\" pcm_sample_bit_depth_luma_minus1=\"%d", sps->pcm_sample_bit_depth_luma_minus1);
 			gf_fprintf(dump, "\" pcm_sample_bit_depth_chroma_minus1=\"%d", sps->pcm_sample_bit_depth_chroma_minus1);
 			gf_fprintf(dump, "\" pcm_loop_filter_disable_flag=\"%d", sps->pcm_loop_filter_disable_flag);
 			gf_fprintf(dump, "\" log2_min_pcm_luma_coding_block_size_minus3=\"%d", sps->log2_min_pcm_luma_coding_block_size_minus3);
 			gf_fprintf(dump, "\" log2_diff_max_min_pcm_luma_coding_block_size=\"%d", sps->log2_diff_max_min_pcm_luma_coding_block_size);
 			gf_fprintf(dump, "\" overscan_info_present=\"%d", sps->overscan_info_present);
 			gf_fprintf(dump, "\" overscan_appropriate=\"%d", sps->overscan_appropriate);
 			gf_fprintf(dump, "\" video_signal_type_present_flag=\"%d", sps->video_signal_type_present_flag);
 			gf_fprintf(dump, "\" video_format=\"%d", sps->video_format);
 			gf_fprintf(dump, "\" chroma_loc_info_present_flag=\"%d", sps->chroma_loc_info_present_flag);
 			gf_fprintf(dump, "\" chroma_sample_loc_type_top_field=\"%d", sps->chroma_sample_loc_type_top_field);
 			gf_fprintf(dump, "\" chroma_sample_loc_type_bottom_field=\"%d", sps->chroma_sample_loc_type_bottom_field);
 			gf_fprintf(dump, "\" neutra_chroma_indication_flag=\"%d", sps->neutra_chroma_indication_flag);
 			gf_fprintf(dump, "\" field_seq_flag=\"%d", sps->field_seq_flag);
 			gf_fprintf(dump, "\" frame_field_info_present_flag=\"%d", sps->frame_field_info_present_flag);
 			gf_fprintf(dump, "\" default_display_window_flag=\"%d", sps->default_display_window_flag);
 			gf_fprintf(dump, "\" left_offset=\"%d", sps->left_offset);
 			gf_fprintf(dump, "\" right_offset=\"%d", sps->right_offset);
 			gf_fprintf(dump, "\" top_offset=\"%d", sps->top_offset);
 			gf_fprintf(dump, "\" bottom_offset=\"%d", sps->bottom_offset);
 			gf_fprintf(dump, "\" hrd_parameters_present_flag=\"%d", sps->hrd_parameters_present_flag);
 			}
 			break;
 		case GF_HEVC_NALU_PIC_PARAM:
 			if (full_bs_dump) break;
 			idx = gf_hevc_read_pps(ptr, ptr_size, hevc);
 			if (idx<0) {
 				gf_fprintf(dump, "\" pps_id=\"PARSING FAILURE");
 				break;
 			}
 			{
 			HEVC_PPS *pps= &hevc->pps[idx];
 			gf_fprintf(dump, "\" pps_id=\"%d", idx);
 
 			gf_fprintf(dump, "\" cabac_init_present_flag=\"%d", pps->cabac_init_present_flag);
 			gf_fprintf(dump, "\" dependent_slice_segments_enabled_flag=\"%d", pps->dependent_slice_segments_enabled_flag);
 			gf_fprintf(dump, "\" entropy_coding_sync_enabled_flag=\"%d", pps->entropy_coding_sync_enabled_flag);
 			gf_fprintf(dump, "\" lists_modification_present_flag=\"%d", pps->lists_modification_present_flag);
 			gf_fprintf(dump, "\" loop_filter_across_slices_enabled_flag=\"%d", pps->loop_filter_across_slices_enabled_flag);
 			gf_fprintf(dump, "\" loop_filter_across_tiles_enabled_flag=\"%d", pps->loop_filter_across_tiles_enabled_flag);
 			gf_fprintf(dump, "\" num_extra_slice_header_bits=\"%d", pps->num_extra_slice_header_bits);
 			gf_fprintf(dump, "\" num_ref_idx_l0_default_active=\"%d", pps->num_ref_idx_l0_default_active);
 			gf_fprintf(dump, "\" num_ref_idx_l1_default_active=\"%d", pps->num_ref_idx_l1_default_active);
 			gf_fprintf(dump, "\" tiles_enabled_flag=\"%d", pps->tiles_enabled_flag);
 			if (pps->tiles_enabled_flag) {
 				gf_fprintf(dump, "\" uniform_spacing_flag=\"%d", pps->uniform_spacing_flag);
 				if (!pps->uniform_spacing_flag) {
 					u32 k;
 					gf_fprintf(dump, "\" num_tile_columns=\"%d", pps->num_tile_columns);
 					gf_fprintf(dump, "\" num_tile_rows=\"%d", pps->num_tile_rows);
 					gf_fprintf(dump, "\" colomns_width=\"");
 					for (k=0; k<pps->num_tile_columns-1; k++)
 						gf_fprintf(dump, "%d ", pps->column_width[k]);
 					gf_fprintf(dump, "\" rows_height=\"");
 					for (k=0; k<pps->num_tile_rows-1; k++)
 						gf_fprintf(dump, "%d ", pps->row_height[k]);
 				}
 			}
 			gf_fprintf(dump, "\" output_flag_present_flag=\"%d", pps->output_flag_present_flag);
 			gf_fprintf(dump, "\" pic_init_qp_minus26=\"%d", pps->pic_init_qp_minus26);
 			gf_fprintf(dump, "\" slice_chroma_qp_offsets_present_flag=\"%d", pps->slice_chroma_qp_offsets_present_flag);
 			gf_fprintf(dump, "\" slice_segment_header_extension_present_flag=\"%d", pps->slice_segment_header_extension_present_flag);
 			gf_fprintf(dump, "\" weighted_pred_flag=\"%d", pps->weighted_pred_flag);
 			gf_fprintf(dump, "\" weighted_bipred_flag=\"%d", pps->weighted_bipred_flag);
 
 			gf_fprintf(dump, "\" sign_data_hiding_flag=\"%d", pps->sign_data_hiding_flag);
 			gf_fprintf(dump, "\" constrained_intra_pred_flag=\"%d", pps->constrained_intra_pred_flag);
 			gf_fprintf(dump, "\" transform_skip_enabled_flag=\"%d", pps->transform_skip_enabled_flag);
 			gf_fprintf(dump, "\" cu_qp_delta_enabled_flag=\"%d", pps->cu_qp_delta_enabled_flag);
 			if (pps->cu_qp_delta_enabled_flag)
 				gf_fprintf(dump, "\" diff_cu_qp_delta_depth=\"%d", pps->diff_cu_qp_delta_depth);
 			gf_fprintf(dump, "\" transquant_bypass_enable_flag=\"%d", pps->transquant_bypass_enable_flag);
 			gf_fprintf(dump, "\" pic_cb_qp_offset=\"%d", pps->pic_cb_qp_offset);
 			gf_fprintf(dump, "\" pic_cr_qp_offset=\"%d", pps->pic_cr_qp_offset);
 
 			gf_fprintf(dump, "\" deblocking_filter_control_present_flag=\"%d", pps->deblocking_filter_control_present_flag);
 			if (pps->deblocking_filter_control_present_flag) {
 				gf_fprintf(dump, "\" deblocking_filter_override_enabled_flag=\"%d", pps->deblocking_filter_override_enabled_flag);
 				gf_fprintf(dump, "\" pic_disable_deblocking_filter_flag=\"%d", pps->pic_disable_deblocking_filter_flag);
 				gf_fprintf(dump, "\" beta_offset_div2=\"%d", pps->beta_offset_div2);
 				gf_fprintf(dump, "\" tc_offset_div2=\"%d", pps->tc_offset_div2);
 			}
 			gf_fprintf(dump, "\" pic_scaling_list_data_present_flag=\"%d", pps->pic_scaling_list_data_present_flag);
 			gf_fprintf(dump, "\" log2_parallel_merge_level_minus2=\"%d", pps->log2_parallel_merge_level_minus2);
 			}
 			break;
 		case GF_HEVC_NALU_ACCESS_UNIT:
 			gf_fprintf(dump, "\" primary_pic_type=\"%d", ptr[2] >> 5);
 			break;
 		//extractor
 		case GF_HEVC_NALU_FF_EXTRACTOR:
 		{
 			u32 remain = ptr_size-2;
 			char *s = ptr+2;
 
 			gf_fputs(" ", dump);
 
 			while (remain) {
 				u32 mode = s[0];
 				remain -= 1;
 				s += 1;
 				if (mode) {
 					u32 len = s[0];
 					if (len+1>remain) {
 						gf_fprintf(dump, "error=\"invalid inband data extractor size: %d vs %d remaining\"/>\n", len, remain);
 						return;
 					}
 					remain -= len+1;
 					s += len+1;
 					gf_fprintf(dump, "\" inband_size=\"%d", len);
 				} else {
 					if (remain < 2 + 2*nalh_size) {
 						gf_fprintf(dump, "error=\"invalid ref data extractor size: %d vs %d remaining\"/>\n", 2 + 2*nalh_size, remain);
 						return;
 					}
 					track_ref_index = (u8) s[0];
 					sample_offset = (s8) s[1];
 					data_offset = inspect_get_nal_size(&s[2], nalh_size);
 					data_size = inspect_get_nal_size(&s[2+nalh_size], nalh_size);
 					gf_fprintf(dump, "\" track_ref_index=\"%d\" sample_offset=\"%d\" data_offset=\"%d\" data_size=\"%d", track_ref_index, sample_offset, data_offset, data_size);
 
 					remain -= 2 + 2*nalh_size;
 					s += 2 + 2*nalh_size;
 				}
 			}
 		}
 			break;
 		default:
 			break;
 		}
 		gf_fputs("\"", dump);
 
 		if (!full_bs_dump && (type < GF_HEVC_NALU_VID_PARAM)) {
 			gf_fprintf(dump, " slice=\"%s\" poc=\"%d\"", (hevc->s_info.slice_type==GF_HEVC_SLICE_TYPE_I) ? "I" : (hevc->s_info.slice_type==GF_HEVC_SLICE_TYPE_P) ? "P" : (hevc->s_info.slice_type==GF_HEVC_SLICE_TYPE_B) ? "B" : "Unknown", hevc->s_info.poc);
 			gf_fprintf(dump, " first_slice_in_pic=\"%d\"", hevc->s_info.first_slice_segment_in_pic_flag);
 			gf_fprintf(dump, " dependent_slice_segment=\"%d\"", hevc->s_info.dependent_slice_segment_flag);
 
 			if (!gf_sys_is_test_mode()) {
 				gf_fprintf(dump, " redundant_pic_cnt=\"%d\"", hevc->s_info.redundant_pic_cnt);
 				gf_fprintf(dump, " slice_qp_delta=\"%d\"", hevc->s_info.slice_qp_delta);
 				gf_fprintf(dump, " slice_segment_address=\"%d\"", hevc->s_info.slice_segment_address);
 				gf_fprintf(dump, " slice_type=\"%d\"", hevc->s_info.slice_type);
 			}
 		}
 		if (!full_bs_dump)
 			gf_fprintf(dump, " layer_id=\"%d\" temporal_id=\"%d\"", quality_id, temporal_id);
 
 		if (bs) {
 			if (!pctx)
 				gf_bs_del(bs);
 			else
 				gf_bs_set_logger(bs, NULL, NULL);
 		}
 
 		if ((type == GF_HEVC_NALU_SEI_PREFIX) || (type == GF_HEVC_NALU_SEI_SUFFIX)) {
 			gf_fprintf(dump, ">\n");
 			if (pctx) {
 				if (!pctx->bs)
 					pctx->bs = gf_bs_new(ptr, ptr_size, GF_BITSTREAM_READ);
 				else
 					gf_bs_reassign_buffer(pctx->bs, ptr, ptr_size);
 				bs = pctx->bs;
 			} else {
 				bs = gf_bs_new(ptr, ptr_size, GF_BITSTREAM_READ);
 			}
 			dump_sei(dump, bs, GF_TRUE);
 			if (!pctx) gf_bs_del(bs);
 			gf_fprintf(dump, "   </NALU>\n");
 		} else {
 			gf_fprintf(dump, "/>\n");
 		}
 
 #else
 		gf_fprintf(dump, "/>\n");
 #endif //GPAC_DISABLE_HEVC
 		return;
 	}
 
 	if (vvc) {
 		u8 lid, tid;
 
+		if (ptr_size<=1) {
+			gf_fprintf(dump, "error=\"invalid nal size 1\"/>\n");
+			return;
+		}
+
 		if (full_bs_dump) {
 			vvc->parse_mode = 2;
 			if (pctx) {
 				if (!pctx->bs)
 					pctx->bs = gf_bs_new(ptr, ptr_size, GF_BITSTREAM_READ);
 				else
 					gf_bs_reassign_buffer(pctx->bs, ptr, ptr_size);
 				bs = pctx->bs;
 			} else {
 				bs = gf_bs_new(ptr, ptr_size, GF_BITSTREAM_READ);
 			}
 			gf_bs_set_logger(bs, regular_bs_log, &lcbk);
 			res = gf_vvc_parse_nalu_bs(bs, vvc, &type, &lid, &tid);
 		} else {
 			vvc->parse_mode = 0;
 			bs = NULL;
 			u32 forb_zero = (ptr[0] & 0x80) ? 1 : 0;
 			u32 res_zero = (ptr[0] & 0x40) ? 1 : 0;
 			lid = (ptr[0] & 0x3F);
 			tid = (ptr[1] & 0x7);
 			if (forb_zero || res_zero || !tid) {
 				gf_fprintf(dump, "error=\"invalid header (forb %d res_zero %d tid %d)\"/>\n", forb_zero, res_zero, tid);
 				return;
 			}
 			tid -= 1;
 			type = ptr[1]>>3;
 
 			res = gf_vvc_parse_nalu(ptr, ptr_size, vvc, &type, &lid, &tid);
 			gf_fprintf(dump, "code=\"%d\" temporalid=\"%d\" layerid=\"%d\"", type, tid, lid);
 		}
 		if (res==-1) {
 			gf_fprintf(dump, " status=\"error parsing\"", type);
 		}
 
 		gf_fprintf(dump, " type=\"");
 		nal_name = get_vvc_nal_name(type);
 		if (nal_name)
 			gf_fprintf(dump, nal_name);
 		else {
 			gf_fprintf(dump, "Unknwon");
 			res = -2;
 		}
 		//specific dump
 		switch (type) {
 		case GF_VVC_NALU_VID_PARAM:
 			if ((res>=0) && !full_bs_dump) {
 				u32 j;
 				VVC_VPS *vps = &vvc->vps[vvc->last_parsed_vps_id];
 				gf_fprintf(dump, "\" id=\"%d\" num_ptl=\"%d\" max_layers=\"%d\" max_sublayers=\"%d", vps->id, vps->num_ptl, vps->max_layers, vps->max_sub_layers);
 				if (vps->max_layers>1) {
 					gf_fprintf(dump, "\" max_layer_id=\"%d\" all_layers_independent=\"%d\" each_layer_is_ols=\"%d", vps->max_layer_id, vps->all_layers_independent, vps->each_layer_is_ols);
 				}
 				for (j=0; j<vps->num_ptl; j++) {
 					VVC_ProfileTierLevel *ptl = &vps->ptl[j];
 					gf_fprintf(dump, "\" general_level_idc=\"%d\" frame_only_constraint=\"%d\" multilayer_enabled=\"%d\" max_tid=\"%d", ptl->general_level_idc, ptl->frame_only_constraint, ptl->multilayer_enabled, ptl->ptl_max_tid);
 
 					if (ptl->pt_present) {
 						gf_fprintf(dump, "\" general_profile_idc=\"%d\" general_tier_flag=\"%d\" gci_present=\"%d", ptl->general_profile_idc, ptl->general_tier_flag, ptl->gci_present);
 					}
 				}
 			}
 			res = -2;
 			break;
 		case GF_VVC_NALU_SEQ_PARAM:
 			if ((res>=0) && !full_bs_dump) {
 				VVC_SPS *sps = &vvc->sps[vvc->last_parsed_sps_id];
 
 				gf_fprintf(dump, "\" id=\"%d\" vps_id=\"%d\" max_sublayers=\"%d\" chroma_idc=\"%d\" bit_depth=\"%d\" CTBsizeY=\"%d\" gdr_enabled=\"%d\" ref_pic_sampling=\"%d\" subpic_info_present=\"%d\" poc_msb_cycle_flag=\"%d", sps->id, sps->vps_id, sps->max_sublayers, sps->chroma_format_idc, sps->bitdepth, 1<<sps->log2_ctu_size, sps->gdr_enabled, sps->ref_pic_resampling, sps->subpic_info_present, sps->poc_msb_cycle_flag);
 				if (sps->ref_pic_resampling) {
 					gf_fprintf(dump, "\" res_change_in_clvs=\"%d", sps->res_change_in_clvs);
 				}
 				gf_fprintf(dump, "\" width=\"%d\" height=\"%d", sps->width, sps->height);
 				if (!sps->vps_id) {
 					VVC_ProfileTierLevel *ptl = &vvc->vps[0].ptl[0];
 					gf_fprintf(dump, "\" general_level_idc=\"%d\" frame_only_constraint=\"%d\" multilayer_enabled=\"%d\" max_tid=\"%d", ptl->general_level_idc, ptl->frame_only_constraint, ptl->multilayer_enabled, ptl->ptl_max_tid);
 
 					if (ptl->pt_present) {
 						gf_fprintf(dump, "\" general_profile_idc=\"%d\" general_tier_flag=\"%d\" gci_present=\"%d", ptl->general_profile_idc, ptl->general_tier_flag, ptl->gci_present);
 					}
 				}
 				gf_fprintf(dump, "\" conf_window=\"%d", sps->conf_window);
 				if (sps->conf_window) {
 					gf_fprintf(dump, "\" cw_left=\"%d\" cw_right=\"%d\" cw_top=\"%d\" cw_bottom=\"%d", sps->cw_left, sps->cw_right, sps->cw_top, sps->cw_bottom);
 				}
 			}
 			res=-2;
 			break;
 		case GF_VVC_NALU_PIC_PARAM:
 			if ((res>=0) && !full_bs_dump) {
 				VVC_PPS *pps = &vvc->pps[vvc->last_parsed_pps_id];
 				gf_fprintf(dump, "\" id=\"%d\" sps_id=\"%d\" width=\"%d\" height=\"%d\" mixed_nal_types=\"%d\" conf_window=\"%d", pps->id, pps->sps_id, pps->width, pps->height, pps->mixed_nal_types, pps->conf_window);
 
 				if (pps->conf_window) {
 					gf_fprintf(dump, "\" cw_left=\"%d\" cw_right=\"%d\" cw_top=\"%d\" cw_bottom=\"%d", pps->cw_left, pps->cw_right, pps->cw_top, pps->cw_bottom);
 				}
 				gf_fprintf(dump, "\" output_flag_present_flag=\"%d\" no_pic_partition_flag=\"%d\" subpic_id_mapping_present_flag=\"%d", pps->output_flag_present_flag, pps->no_pic_partition_flag, pps->subpic_id_mapping_present_flag);
 			}
 			res=-2;
 			break;
 		default:
 			break;
 		}
 		gf_fprintf(dump, "\"");
 
 		//picture header or slice
 		if ((type!=GF_VVC_NALU_PIC_HEADER) && (type>GF_VVC_NALU_SLICE_GDR))
 			res = -2;
 		if ((res>=0) && !full_bs_dump) {
 			if (type!=GF_VVC_NALU_PIC_HEADER)
 				gf_fprintf(dump, " picture_header_in_slice_header_flag=\"%d\"", vvc->s_info.picture_header_in_slice_header_flag);
 
 			if ((type==GF_VVC_NALU_PIC_HEADER) || vvc->s_info.picture_header_in_slice_header_flag) {
 				gf_fprintf(dump, " pps_id=\"%d\" poc=\"%d\" irap_or_gdr_pic=\"%d\" non_ref_pic=\"%d\" inter_slice_allowed_flag=\"%d\" poc_lsb=\"%d\"", vvc->s_info.pps->id, vvc->s_info.poc, vvc->s_info.irap_or_gdr_pic, vvc->s_info.non_ref_pic, vvc->s_info.inter_slice_allowed_flag, vvc->s_info.poc_lsb);
 				if (vvc->s_info.irap_or_gdr_pic)
 					gf_fprintf(dump, " gdr_pic=\"%d\" gdr_recovery_count=\"%d\"", vvc->s_info.gdr_pic, vvc->s_info.gdr_recovery_count);
 				if (vvc->s_info.inter_slice_allowed_flag)
 					gf_fprintf(dump, " intra_slice_allowed_flag=\"%d\"", vvc->s_info.intra_slice_allowed_flag);
 				if (vvc->s_info.sps->poc_msb_cycle_flag && vvc->s_info.poc_msb_cycle_present_flag)
 					gf_fprintf(dump, " poc_msb_cycle=\"%d\"", vvc->s_info.poc_msb_cycle);
 			}
 			if (type!=GF_VVC_NALU_PIC_HEADER)
 				gf_fprintf(dump, " slice_type=\"%d\"", vvc->s_info.slice_type);
 		}
 
 		if (bs) {
 			if (!pctx)
 				gf_bs_del(bs);
 			else
 				gf_bs_set_logger(bs, NULL, NULL);
 		}
 
 		if ((type == GF_VVC_NALU_SEI_PREFIX) || (type == GF_VVC_NALU_SEI_SUFFIX)) {
 			gf_fprintf(dump, ">\n");
 			if (pctx) {
 				if (!pctx->bs)
 					pctx->bs = gf_bs_new(ptr, ptr_size, GF_BITSTREAM_READ);
 				else
 					gf_bs_reassign_buffer(pctx->bs, ptr, ptr_size);
 				bs = pctx->bs;
 			} else {
 				bs = gf_bs_new(ptr, ptr_size, GF_BITSTREAM_READ);
 			}
 			dump_sei(dump, bs, GF_TRUE);
 			if (!pctx) gf_bs_del(bs);
 			gf_fprintf(dump, "   </NALU>\n");
 		} else {
 			gf_fprintf(dump, "/>\n");
 		}
 		return;
 	}
 
 	//avc
+	if (!ptr_size) {
+		gf_fprintf(dump, "error=\"invalid nal size 1\"/>\n");
+		return;
+	}
 	type = ptr[0] & 0x1F;
 	nal_ref_idc = ptr[0] & 0x60;
 	nal_ref_idc>>=5;
 	if (! full_bs_dump)
 		gf_fprintf(dump, "code=\"%d\" ", type);
 
 	gf_fprintf(dump, "type=\"");
 	res = -2;
 	nal_name = get_avc_nal_name(type);
 	if (type == GF_AVC_NALU_SVC_SLICE) nal_name = is_svc ? "SVCSlice" : "CodedSliceExtension";
 	if (nal_name) {
 		gf_fputs(nal_name, dump);
 	} else {
 		gf_fputs("UNKNWON", dump);
 	}
 
 	if (pctx) {
 		if (!pctx->bs)
 			pctx->bs = gf_bs_new(ptr, ptr_size, GF_BITSTREAM_READ);
 		else
 			gf_bs_reassign_buffer(pctx->bs, ptr, ptr_size);
 		bs = pctx->bs;
 	} else {
 		bs = gf_bs_new(ptr, ptr_size, GF_BITSTREAM_READ);
 	}
 
 	if (full_bs_dump)
 		gf_bs_set_logger(bs, shifted_bs_log, &lcbk);
 
 	//specific dump
 	switch (type) {
 	case GF_AVC_NALU_NON_IDR_SLICE:
 	case GF_AVC_NALU_DP_A_SLICE:
 	case GF_AVC_NALU_DP_B_SLICE:
 	case GF_AVC_NALU_DP_C_SLICE:
 	case GF_AVC_NALU_IDR_SLICE:
 		if (is_encrypted) break;
 		res = gf_avc_parse_nalu(bs, avc);
 		break;
 	case GF_AVC_NALU_SEQ_PARAM:
 		if (is_encrypted) break;
 		idx = gf_avc_read_sps_bs(bs, avc, 0, NULL);
 		if (idx<0) {
 			gf_fprintf(dump, "\" sps_id=\"PARSING FAILURE");
 			break;
 		}
 		if (full_bs_dump) break;
 		gf_fprintf(dump, "\" sps_id=\"%d", idx);
 		gf_fprintf(dump, "\" frame_mbs_only_flag=\"%d", avc->sps->frame_mbs_only_flag);
 		gf_fprintf(dump, "\" mb_adaptive_frame_field_flag=\"%d", avc->sps->mb_adaptive_frame_field_flag);
 		gf_fprintf(dump, "\" vui_parameters_present_flag=\"%d", avc->sps->vui_parameters_present_flag);
 		gf_fprintf(dump, "\" max_num_ref_frames=\"%d", avc->sps->max_num_ref_frames);
 		gf_fprintf(dump, "\" gaps_in_frame_num_value_allowed_flag=\"%d", avc->sps->gaps_in_frame_num_value_allowed_flag);
 		gf_fprintf(dump, "\" chroma_format_idc=\"%d", avc->sps->chroma_format);
 		gf_fprintf(dump, "\" bit_depth_luma_minus8=\"%d", avc->sps->luma_bit_depth_m8);
 		gf_fprintf(dump, "\" bit_depth_chroma_minus8=\"%d", avc->sps->chroma_bit_depth_m8);
 		gf_fprintf(dump, "\" width=\"%d", avc->sps->width);
 		gf_fprintf(dump, "\" height=\"%d", avc->sps->height);
 		gf_fprintf(dump, "\" crop_top=\"%d", avc->sps->crop.top);
 		gf_fprintf(dump, "\" crop_left=\"%d", avc->sps->crop.left);
 		gf_fprintf(dump, "\" crop_bottom=\"%d", avc->sps->crop.bottom);
 		gf_fprintf(dump, "\" crop_right=\"%d", avc->sps->crop.right);
 		if (avc->sps->vui_parameters_present_flag) {
 			gf_fprintf(dump, "\" vui_video_full_range_flag=\"%d", avc->sps->vui.video_full_range_flag);
 			gf_fprintf(dump, "\" vui_video_signal_type_present_flag=\"%d", avc->sps->vui.video_signal_type_present_flag);
 			gf_fprintf(dump, "\" vui_aspect_ratio_info_present_flag=\"%d", avc->sps->vui.aspect_ratio_info_present_flag);
 			gf_fprintf(dump, "\" vui_aspect_ratio_num=\"%d", avc->sps->vui.par_num);
 			gf_fprintf(dump, "\" vui_aspect_ratio_den=\"%d", avc->sps->vui.par_den);
 			gf_fprintf(dump, "\" vui_overscan_info_present_flag=\"%d", avc->sps->vui.overscan_info_present_flag);
 			gf_fprintf(dump, "\" vui_colour_description_present_flag=\"%d", avc->sps->vui.colour_description_present_flag);
 			gf_fprintf(dump, "\" vui_colour_primaries=\"%d", avc->sps->vui.colour_primaries);
 			gf_fprintf(dump, "\" vui_transfer_characteristics=\"%d", avc->sps->vui.transfer_characteristics);
 			gf_fprintf(dump, "\" vui_matrix_coefficients=\"%d", avc->sps->vui.matrix_coefficients);
 			gf_fprintf(dump, "\" vui_low_delay_hrd_flag=\"%d", avc->sps->vui.low_delay_hrd_flag);
 		}
 		gf_fprintf(dump, "\" log2_max_poc_lsb=\"%d", avc->sps->log2_max_poc_lsb);
 		gf_fprintf(dump, "\" log2_max_frame_num=\"%d", avc->sps->log2_max_frame_num);
 		gf_fprintf(dump, "\" delta_pic_order_always_zero_flag=\"%d", avc->sps->delta_pic_order_always_zero_flag);
 		gf_fprintf(dump, "\" offset_for_non_ref_pic=\"%d", avc->sps->offset_for_non_ref_pic);
 
 		break;
 	case GF_AVC_NALU_PIC_PARAM:
 		if (is_encrypted) break;
 		idx = gf_avc_read_pps_bs(bs, avc);
 		if (idx<0) {
 			gf_fprintf(dump, "\" pps_id=\"PARSING FAILURE");
 			break;
 		}
 		if (full_bs_dump) break;
 		gf_fprintf(dump, "\" pps_id=\"%d\" sps_id=\"%d", idx, avc->pps[idx].sps_id);
 		gf_fprintf(dump, "\" entropy_coding_mode_flag=\"%d", avc->pps[idx].entropy_coding_mode_flag);
 		gf_fprintf(dump, "\" deblocking_filter_control_present_flag=\"%d", avc->pps[idx].deblocking_filter_control_present_flag);
 		gf_fprintf(dump, "\" mb_slice_group_map_type=\"%d", avc->pps[idx].mb_slice_group_map_type);
 		gf_fprintf(dump, "\" num_ref_idx_l0_default_active_minus1=\"%d", avc->pps[idx].num_ref_idx_l0_default_active_minus1);
 		gf_fprintf(dump, "\" num_ref_idx_l1_default_active_minus1=\"%d", avc->pps[idx].num_ref_idx_l1_default_active_minus1);
 		gf_fprintf(dump, "\" pic_order_present=\"%d", avc->pps[idx].pic_order_present);
 		gf_fprintf(dump, "\" pic_size_in_map_units_minus1=\"%d", avc->pps[idx].pic_size_in_map_units_minus1);
 		gf_fprintf(dump, "\" redundant_pic_cnt_present=\"%d", avc->pps[idx].redundant_pic_cnt_present);
 		gf_fprintf(dump, "\" slice_group_change_rate_minus1=\"%d", avc->pps[idx].slice_group_change_rate_minus1);
 		gf_fprintf(dump, "\" slice_group_count=\"%d", avc->pps[idx].slice_group_count);
 		gf_fprintf(dump, "\" weighted_pred_flag=\"%d", avc->pps[idx].weighted_pred_flag);
 		gf_fprintf(dump, "\" weighted_bipred_idc=\"%d", avc->pps[idx].weighted_bipred_idc);
 		break;
 	case GF_AVC_NALU_ACCESS_UNIT:
 		if (is_encrypted) break;
 		if (full_bs_dump) break;
 		gf_fprintf(dump, "\" primary_pic_type=\"%d", gf_bs_read_u8(bs) >> 5);
 		break;
 	case GF_AVC_NALU_SVC_SUBSEQ_PARAM:
 		if (is_encrypted) break;
 		idx = gf_avc_read_sps_bs(bs, avc, 1, NULL);
 		assert (idx >= 0);
 		if (full_bs_dump) break;
 		gf_fprintf(dump, "\" sps_id=\"%d", idx - GF_SVC_SSPS_ID_SHIFT);
 		break;
 	case GF_AVC_NALU_SVC_SLICE:
 		if (is_encrypted) break;
 		gf_avc_parse_nalu(bs, avc);
 		if (full_bs_dump) break;
 		dependency_id = (ptr[2] & 0x70) >> 4;
 		quality_id = (ptr[2] & 0x0F);
 		temporal_id = (ptr[3] & 0xE0) >> 5;
 		gf_fprintf(dump, "\" dependency_id=\"%d\" quality_id=\"%d\" temporal_id=\"%d", dependency_id, quality_id, temporal_id);
 		gf_fprintf(dump, "\" poc=\"%d", avc->s_info.poc);
 		break;
 	case GF_AVC_NALU_SVC_PREFIX_NALU:
 		if (is_encrypted) break;
 		if (full_bs_dump) break;
 		dependency_id = (ptr[2] & 0x70) >> 4;
 		quality_id = (ptr[2] & 0x0F);
 		temporal_id = (ptr[3] & 0xE0) >> 5;
 		gf_fprintf(dump, "\" dependency_id=\"%d\" quality_id=\"%d\" temporal_id=\"%d", dependency_id, quality_id, temporal_id);
 		break;
 	//extractor
 	case GF_AVC_NALU_FF_EXTRACTOR:
 		if (is_encrypted) break;
 		track_ref_index = (u8) ptr[4];
 		sample_offset = (s8) ptr[5];
 		data_offset = inspect_get_nal_size(&ptr[6], nalh_size);
 		data_size = inspect_get_nal_size(&ptr[6+nalh_size], nalh_size);
 		gf_fprintf(dump, "\" track_ref_index=\"%d\" sample_offset=\"%d\" data_offset=\"%d\" data_size=\"%d\"", track_ref_index, sample_offset, data_offset, data_size);
 		break;
 	default:
 		break;
 	}
 	gf_fputs("\"", dump);
 
 	if (!full_bs_dump) {
 		if (nal_ref_idc) {
 			gf_fprintf(dump, " nal_ref_idc=\"%d\"", nal_ref_idc);
 		}
 		if (res>=0) {
 			gf_fprintf(dump, " poc=\"%d\" pps_id=\"%d\" field_pic_flag=\"%d\"", avc->s_info.poc, avc->s_info.pps->id, (int)avc->s_info.field_pic_flag);
 		}
 	}
 
 	if (res == -1)
 		gf_fprintf(dump, " status=\"error decoding slice\"");
 
 	if (!is_encrypted && (type == GF_AVC_NALU_SEI)) {
 		gf_fprintf(dump, ">\n");
 		gf_bs_set_logger(bs, NULL, NULL);
 		dump_sei(dump, bs, GF_FALSE);
 		gf_fprintf(dump, "   </NALU>\n");
 	} else {
 		gf_fprintf(dump, "/>\n");
 	}
 
 	if (bs) {
 		if (!pctx)
 			gf_bs_del(bs);
 		else
 			gf_bs_set_logger(bs, NULL, NULL);
 	}
 }
diff --git a/src/filters/reframe_nalu.c b/src/filters/reframe_nalu.c
index 5354c19a0..f5e050f72 100644
--- a/src/filters/reframe_nalu.c
+++ b/src/filters/reframe_nalu.c
@@ -2152,175 +2152,177 @@ static void naludmx_push_prefix(GF_NALUDmxCtx *ctx, u8 *data, u32 size, Bool avc
 static s32 naludmx_parse_nal_hevc(GF_NALUDmxCtx *ctx, char *data, u32 size, Bool *skip_nal, Bool *is_slice, Bool *is_islice)
 {
 #ifdef GPAC_DISABLE_HEVC
 	return -1;
 #else
 	s32 ps_idx = 0;
 	s32 res;
 	u8 nal_unit_type, temporal_id, layer_id;
 	*skip_nal = GF_FALSE;
 
+	if (size<2) return -1;
+
 	gf_bs_reassign_buffer(ctx->bs_r, data, size);
 	res = gf_hevc_parse_nalu_bs(ctx->bs_r, ctx->hevc_state, &nal_unit_type, &temporal_id, &layer_id);
 	ctx->nb_nalus++;
 
 	if (res < 0) {
 		if (res == -1) {
 			GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[%s] Warning: Error parsing NAL unit\n", ctx->log_name));
 		}
 		*skip_nal = GF_TRUE;
 	}
 
 	if (layer_id && ctx->nosvc) {
 		*skip_nal = GF_TRUE;
 		return 0;
 	}
 
 	switch (nal_unit_type) {
 	case GF_HEVC_NALU_VID_PARAM:
 		if (ctx->novpsext) {
 			//this may modify nal_size, but we don't use it for bitstream reading
 			ps_idx = gf_hevc_read_vps_ex(data, &size, ctx->hevc_state, GF_TRUE);
 		} else {
 			ps_idx = ctx->hevc_state->last_parsed_vps_id;
 		}
 		if (ps_idx<0) {
 			GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[%s] Error parsing Video Param Set\n", ctx->log_name));
 		} else {
 			naludmx_queue_param_set(ctx, data, size, GF_HEVC_NALU_VID_PARAM, ps_idx);
 		}
 		*skip_nal = GF_TRUE;
 		break;
 	case GF_HEVC_NALU_SEQ_PARAM:
 		ps_idx = ctx->hevc_state->last_parsed_sps_id;
 		if (ps_idx<0) {
 			GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[%s] Error parsing Sequence Param Set\n", ctx->log_name));
 		} else {
 			naludmx_queue_param_set(ctx, data, size, GF_HEVC_NALU_SEQ_PARAM, ps_idx);
 		}
 		*skip_nal = GF_TRUE;
 		break;
 	case GF_HEVC_NALU_PIC_PARAM:
 		ps_idx = ctx->hevc_state->last_parsed_pps_id;
 		if (ps_idx<0) {
 			GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[%s] Error parsing Picture Param Set\n", ctx->log_name));
 		} else {
 			naludmx_queue_param_set(ctx, data, size, GF_HEVC_NALU_PIC_PARAM, ps_idx);
 		}
 		*skip_nal = GF_TRUE;
 		break;
 	case GF_HEVC_NALU_SEI_PREFIX:
 		gf_hevc_parse_sei(data, size, ctx->hevc_state);
 		if (!ctx->nosei) {
 			ctx->nb_sei++;
 			naludmx_push_prefix(ctx, data, size, GF_FALSE);
 		} else {
 			ctx->nb_nalus--;
 		}
 		*skip_nal = GF_TRUE;
 		break;
 	case GF_HEVC_NALU_SEI_SUFFIX:
 		if (! ctx->is_playing) return 0;
 		if (ctx->nosei) {
 			*skip_nal = GF_TRUE;
 			ctx->nb_nalus--;
 		} else {
 			ctx->nb_sei++;
 		}
 		break;
 
 	/*slice_segment_layer_rbsp*/
 	case GF_HEVC_NALU_SLICE_STSA_N:
 	case GF_HEVC_NALU_SLICE_STSA_R:
 	case GF_HEVC_NALU_SLICE_RADL_R:
 	case GF_HEVC_NALU_SLICE_RASL_R:
 	case GF_HEVC_NALU_SLICE_RADL_N:
 	case GF_HEVC_NALU_SLICE_RASL_N:
 	case GF_HEVC_NALU_SLICE_TRAIL_N:
 	case GF_HEVC_NALU_SLICE_TRAIL_R:
 	case GF_HEVC_NALU_SLICE_TSA_N:
 	case GF_HEVC_NALU_SLICE_TSA_R:
 	case GF_HEVC_NALU_SLICE_BLA_W_LP:
 	case GF_HEVC_NALU_SLICE_BLA_W_DLP:
 	case GF_HEVC_NALU_SLICE_BLA_N_LP:
 	case GF_HEVC_NALU_SLICE_IDR_W_DLP:
 	case GF_HEVC_NALU_SLICE_IDR_N_LP:
 	case GF_HEVC_NALU_SLICE_CRA:
 		if (! ctx->is_playing) return 0;
 		*is_slice = GF_TRUE;
 		ctx->last_layer_id = layer_id;
 		ctx->last_temporal_id = temporal_id;
 		if (! *skip_nal) {
 			switch (ctx->hevc_state->s_info.slice_type) {
 			case GF_HEVC_SLICE_TYPE_P:
 				if (layer_id) ctx->nb_e_p++;
 				else ctx->nb_p++;
 				break;
 			case GF_HEVC_SLICE_TYPE_I:
 				if (layer_id) ctx->nb_e_i++;
 				else ctx->nb_i++;
 				*is_islice = GF_TRUE;
 				break;
 			case GF_HEVC_SLICE_TYPE_B:
 				if (layer_id) ctx->nb_e_b++;
 				else ctx->nb_b++;
 				break;
 			}
 		}
 		break;
 
 	case GF_HEVC_NALU_ACCESS_UNIT:
 		ctx->nb_aud++;
 		if (!ctx->audelim) {
 			*skip_nal = GF_TRUE;
 		} else if (!ctx->opid) {
 			ctx->has_initial_aud = GF_TRUE;
 			memcpy(ctx->init_aud, data, 3);
 		}
 		break;
 	/*remove*/
 	case GF_HEVC_NALU_FILLER_DATA:
 	case GF_HEVC_NALU_END_OF_SEQ:
 	case GF_HEVC_NALU_END_OF_STREAM:
 		*skip_nal = GF_TRUE;
 		break;
 
 	//parsing is partial, see https://github.com/DolbyLaboratories/dlb_mp4base/blob/70a2e1d4d99a8439b7b8087bf50dd503eeea2291/src/esparser/parser_hevc.c#L1233
 	case GF_HEVC_NALU_DV_RPU:
 		if (ctx->dv_mode==DVMODE_CLEAN) {
 			*skip_nal = GF_TRUE;
 		} else {
 			ctx->nb_dv_rpu ++;
 			if (ctx->nb_dv_rpu==1)
 				naludmx_set_dolby_vision(ctx);
 		}
 		break;
 	case GF_HEVC_NALU_DV_EL:
 		if ((ctx->dv_mode==DVMODE_CLEAN) || (ctx->dv_mode==DVMODE_SINGLE)) {
 			*skip_nal = GF_TRUE;
 		} else {
 			ctx->nb_dv_el ++;
 			if (ctx->nb_dv_el==1)
 				naludmx_set_dolby_vision(ctx);
 		}
 		break;
 
 	default:
 		if (! ctx->is_playing) return 0;
 		GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[%s] NAL Unit type %d not handled - adding\n", ctx->log_name, nal_unit_type));
 		break;
 	}
 	if (*skip_nal) return res;
 
 	ctx->linf[layer_id].layer_id_plus_one = layer_id + 1;
 	if (! ctx->linf[layer_id].max_temporal_id ) ctx->linf[layer_id].max_temporal_id = temporal_id;
 	else if (ctx->linf[layer_id].max_temporal_id < temporal_id) ctx->linf[layer_id].max_temporal_id = temporal_id;
 
 	if (! ctx->linf[layer_id].min_temporal_id ) ctx->linf[layer_id].min_temporal_id = temporal_id;
 	else if (ctx->linf[layer_id].min_temporal_id > temporal_id) ctx->linf[layer_id].min_temporal_id = temporal_id;
 
 	if (ctx->max_temporal_id[layer_id] < temporal_id)
 		ctx->max_temporal_id[layer_id] = temporal_id;
 	if (ctx->min_layer_id > layer_id) ctx->min_layer_id = layer_id;
 	return res;
 #endif // GPAC_DISABLE_HEVC
 }
@@ -2329,178 +2331,179 @@ static s32 naludmx_parse_nal_hevc(GF_NALUDmxCtx *ctx, char *data, u32 size, Bool
 static s32 naludmx_parse_nal_vvc(GF_NALUDmxCtx *ctx, char *data, u32 size, Bool *skip_nal, Bool *is_slice, Bool *is_islice)
 {
 	s32 ps_idx = 0;
 	s32 res;
 	u8 nal_unit_type, temporal_id, layer_id;
 	*skip_nal = GF_FALSE;
 
+	if (size<2) return -1;
 	gf_bs_reassign_buffer(ctx->bs_r, data, size);
 	res = gf_vvc_parse_nalu_bs(ctx->bs_r, ctx->vvc_state, &nal_unit_type, &temporal_id, &layer_id);
 	ctx->nb_nalus++;
 
 	if (res < 0) {
 		if (res == -1) {
 			GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[%s] Warning: Error parsing NAL unit\n", ctx->log_name));
 		}
 		*skip_nal = GF_TRUE;
 	}
 
 	if (layer_id && ctx->nosvc) {
 		*skip_nal = GF_TRUE;
 		return 0;
 	}
 
 	switch (nal_unit_type) {
 	case GF_VVC_NALU_VID_PARAM:
 		if (ctx->novpsext) {
 			//this may modify nal_size, but we don't use it for bitstream reading
 //			ps_idx = gf_hevc_read_vps_ex(data, &size, ctx->hevc_state, GF_TRUE);
 			ps_idx = ctx->vvc_state->last_parsed_vps_id;
 		} else {
 			ps_idx = ctx->vvc_state->last_parsed_vps_id;
 		}
 		if (ps_idx<0) {
 			GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[%s] Error parsing Video Param Set\n", ctx->log_name));
 		} else {
 			naludmx_queue_param_set(ctx, data, size, GF_VVC_NALU_VID_PARAM, ps_idx);
 		}
 		*skip_nal = GF_TRUE;
 		break;
 	case GF_VVC_NALU_SEQ_PARAM:
 		ps_idx = ctx->vvc_state->last_parsed_sps_id;
 		if (ps_idx<0) {
 			GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[%s] Error parsing Sequence Param Set\n", ctx->log_name));
 		} else {
 			naludmx_queue_param_set(ctx, data, size, GF_VVC_NALU_SEQ_PARAM, ps_idx);
 		}
 		*skip_nal = GF_TRUE;
 		break;
 	case GF_VVC_NALU_PIC_PARAM:
 		ps_idx = ctx->vvc_state->last_parsed_pps_id;
 		if (ps_idx<0) {
 			GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[%s] Error parsing Picture Param Set\n", ctx->log_name));
 		} else {
 			naludmx_queue_param_set(ctx, data, size, GF_VVC_NALU_PIC_PARAM, ps_idx);
 		}
 		*skip_nal = GF_TRUE;
 		break;
 	case GF_VVC_NALU_DEC_PARAM:
 		ps_idx = 0;
 		naludmx_queue_param_set(ctx, data, size, GF_VVC_NALU_DEC_PARAM, ps_idx);
 		*skip_nal = GF_TRUE;
 		break;
 	case GF_VVC_NALU_APS_PREFIX:
 		//for now we keep APS in the stream
 #if 0
 		ps_idx = ctx->vvc_state->last_parsed_aps_id;
 		if (ps_idx<0) {
 			GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[%s] Error parsing Decoder Param Set\n", ctx->log_name));
 		} else {
 			naludmx_queue_param_set(ctx, data, size, GF_VVC_NALU_APS_PREFIX, ps_idx);
 		}
 		*skip_nal = GF_TRUE;
 #else
 		//same logic as SEI
 		naludmx_push_prefix(ctx, data, size, GF_FALSE);
 		*skip_nal = GF_TRUE;
 #endif
 		break;
 	case GF_VVC_NALU_SEI_PREFIX:
 		gf_vvc_parse_sei(data, size, ctx->vvc_state);
 		if (!ctx->nosei) {
 			ctx->nb_sei++;
 
 			naludmx_push_prefix(ctx, data, size, GF_FALSE);
 		} else {
 			ctx->nb_nalus--;
 		}
 		*skip_nal = GF_TRUE;
 		break;
 	case GF_VVC_NALU_SEI_SUFFIX:
 		if (! ctx->is_playing) return 0;
 		gf_vvc_parse_sei(data, size, ctx->vvc_state);
 		if (ctx->nosei) {
 			*skip_nal = GF_TRUE;
 			ctx->nb_nalus--;
 		} else {
 			ctx->nb_sei++;
 		}
 		break;
 
 	case GF_VVC_NALU_PIC_HEADER:
 		if (! ctx->is_playing) return 0;
 		break;
 
 	/*slice_segment_layer_rbsp*/
 	case GF_VVC_NALU_SLICE_TRAIL:
 	case GF_VVC_NALU_SLICE_STSA:
 	case GF_VVC_NALU_SLICE_RADL:
 	case GF_VVC_NALU_SLICE_RASL:
 	case GF_VVC_NALU_SLICE_IDR_W_RADL:
 	case GF_VVC_NALU_SLICE_IDR_N_LP:
 	case GF_VVC_NALU_SLICE_CRA:
 	case GF_VVC_NALU_SLICE_GDR:
 		if (! ctx->is_playing) return 0;
 		*is_slice = GF_TRUE;
 		ctx->last_layer_id = layer_id;
 		ctx->last_temporal_id = temporal_id;
 		if (! *skip_nal) {
 			switch (ctx->vvc_state->s_info.slice_type) {
 			case GF_VVC_SLICE_TYPE_P:
 				if (layer_id) ctx->nb_e_p++;
 				else ctx->nb_p++;
 				break;
 			case GF_VVC_SLICE_TYPE_I:
 				if (layer_id) ctx->nb_e_i++;
 				else ctx->nb_i++;
 				*is_islice = GF_TRUE;
 				break;
 			case GF_VVC_SLICE_TYPE_B:
 				if (layer_id) ctx->nb_e_b++;
 				else ctx->nb_b++;
 				break;
 			case GF_VVC_SLICE_TYPE_UNKNOWN:
 				ctx->vvc_no_stats = GF_TRUE;
 				break;
 			}
 		}
 		break;
 
 	case GF_VVC_NALU_ACCESS_UNIT:
 		ctx->nb_aud++;
 		//no skip AUD in VVC
 
 		if (!ctx->opid) {
 			ctx->has_initial_aud = GF_TRUE;
 			memcpy(ctx->init_aud, data, 3);
 		}
 		break;
 	/*remove*/
 	case GF_VVC_NALU_FILLER_DATA:
 	case GF_VVC_NALU_END_OF_SEQ:
 	case GF_VVC_NALU_END_OF_STREAM:
 		*skip_nal = GF_TRUE;
 		break;
 
 	case GF_VVC_NALU_OPI:
 		if (! ctx->is_playing) return 0;
 		break;
 
 	default:
 		if (! ctx->is_playing) return 0;
 		GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[%s] NAL Unit type %d not handled - adding\n", ctx->log_name, nal_unit_type));
 		break;
 	}
 	if (*skip_nal) return res;
 
 	ctx->linf[layer_id].layer_id_plus_one = layer_id + 1;
 	if (! ctx->linf[layer_id].max_temporal_id ) ctx->linf[layer_id].max_temporal_id = temporal_id;
 	else if (ctx->linf[layer_id].max_temporal_id < temporal_id) ctx->linf[layer_id].max_temporal_id = temporal_id;
 
 	if (! ctx->linf[layer_id].min_temporal_id ) ctx->linf[layer_id].min_temporal_id = temporal_id;
 	else if (ctx->linf[layer_id].min_temporal_id > temporal_id) ctx->linf[layer_id].min_temporal_id = temporal_id;
 
 	if (ctx->max_temporal_id[layer_id] < temporal_id)
 		ctx->max_temporal_id[layer_id] = temporal_id;
 	if (ctx->min_layer_id > layer_id) ctx->min_layer_id = layer_id;
 	return res;
 }
@@ -2508,175 +2511,176 @@ static s32 naludmx_parse_nal_vvc(GF_NALUDmxCtx *ctx, char *data, u32 size, Bool
 static s32 naludmx_parse_nal_avc(GF_NALUDmxCtx *ctx, char *data, u32 size, u32 nal_type, Bool *skip_nal, Bool *is_slice, Bool *is_islice)
 {
 	s32 ps_idx = 0;
 	s32 res = 0;
 
+	if (!size) return -1;
 	gf_bs_reassign_buffer(ctx->bs_r, data, size);
 	*skip_nal = GF_FALSE;
 	res = gf_avc_parse_nalu(ctx->bs_r, ctx->avc_state);
 	if (res < 0) {
 		if (res == -1) {
 			GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[%s] Warning: Error parsing NAL unit\n", ctx->log_name));
 		}
 		*skip_nal = GF_TRUE;
 	}
 	ctx->nb_nalus++;
 
 	switch (nal_type) {
 	case GF_AVC_NALU_SVC_SUBSEQ_PARAM:
 	case GF_AVC_NALU_SEQ_PARAM:
 		ps_idx = ctx->avc_state->last_ps_idx;
 		if (ps_idx<0) {
 			if (ctx->avc_state->sps[0].profile_idc) {
 				GF_LOG(ctx->avc_state->sps[0].profile_idc ? GF_LOG_WARNING : GF_LOG_ERROR, GF_LOG_PARSER, ("[%s] Error parsing Sequence Param Set\n", ctx->log_name));
 			}
 		} else {
 			naludmx_queue_param_set(ctx, data, size, GF_AVC_NALU_SEQ_PARAM, ps_idx);
 		}
 		*skip_nal = GF_TRUE;
 		return 0;
 
 	case GF_AVC_NALU_PIC_PARAM:
 		ps_idx = ctx->avc_state->last_ps_idx;
 		if (ps_idx<0) {
 			GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[%s] Error parsing Picture Param Set\n", ctx->log_name));
 		} else {
 			naludmx_queue_param_set(ctx, data, size, GF_AVC_NALU_PIC_PARAM, ps_idx);
 		}
 		*skip_nal = GF_TRUE;
 		return 0;
 
 	case GF_AVC_NALU_SEQ_PARAM_EXT:
 		ps_idx = ctx->avc_state->last_ps_idx;
 		if (ps_idx<0) {
 			GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[%s] Error parsing Sequence Param Set Extension\n", ctx->log_name));
 		} else {
 			naludmx_queue_param_set(ctx, data, size, GF_AVC_NALU_SEQ_PARAM_EXT, ps_idx);
 		}
 		*skip_nal = GF_TRUE;
 		return 0;
 
 	case GF_AVC_NALU_SEI:
 		if (ctx->avc_state->sps_active_idx != -1) {
 			naludmx_push_prefix(ctx, data, size, GF_TRUE);
 
 			*skip_nal = GF_TRUE;
 
 			if (ctx->nosei) {
 				ctx->sei_buffer_size = 0;
 			} else {
 				ctx->nb_sei++;
 			}
 		}
 		return 0;
 
 	case GF_AVC_NALU_ACCESS_UNIT:
 		ctx->nb_aud++;
 		if (!ctx->audelim) {
 			*skip_nal = GF_TRUE;
 		} else if (!ctx->opid) {
 			ctx->has_initial_aud = GF_TRUE;
 			memcpy(ctx->init_aud, data, 2);
 		}
 		return 1;
 	/*remove*/
 	case GF_AVC_NALU_FILLER_DATA:
 	case GF_AVC_NALU_END_OF_SEQ:
 	case GF_AVC_NALU_END_OF_STREAM:
 		*skip_nal = GF_TRUE;
 		return 0;
 
 	//update stats
 	case GF_AVC_NALU_NON_IDR_SLICE:
 	case GF_AVC_NALU_DP_A_SLICE:
 	case GF_AVC_NALU_DP_B_SLICE:
 	case GF_AVC_NALU_DP_C_SLICE:
 	case GF_AVC_NALU_IDR_SLICE:
 		*is_slice = GF_TRUE;
 		switch (ctx->avc_state->s_info.slice_type) {
 		case GF_AVC_TYPE_P:
 		case GF_AVC_TYPE2_P:
 			ctx->nb_p++;
 			break;
 		case GF_AVC_TYPE_I:
 		case GF_AVC_TYPE2_I:
 			ctx->nb_i++;
 			*is_islice = GF_TRUE;
 			break;
 		case GF_AVC_TYPE_B:
 		case GF_AVC_TYPE2_B:
 			ctx->nb_b++;
 			break;
 		case GF_AVC_TYPE_SP:
 		case GF_AVC_TYPE2_SP:
 			ctx->nb_sp++;
 			break;
 		case GF_AVC_TYPE_SI:
 		case GF_AVC_TYPE2_SI:
 			ctx->nb_si++;
 			break;
 		}
 		break;
 
 	case GF_AVC_NALU_SVC_SLICE:
 		if (!ctx->explicit) {
 			u32 i;
 			for (i = 0; i < gf_list_count(ctx->pps); i ++) {
 				GF_NALUFFParam *slc = (GF_NALUFFParam*)gf_list_get(ctx->pps, i);
 				if (ctx->avc_state->s_info.pps && ctx->avc_state->s_info.pps->id == slc->id) {
 					/* This PPS is used by an SVC NAL unit, it should be moved to the SVC Config Record) */
 					gf_list_rem(ctx->pps, i);
 					i--;
 					if (!ctx->pps_svc) ctx->pps_svc = gf_list_new(ctx->pps_svc);
 					gf_list_add(ctx->pps_svc, slc);
 					ctx->ps_modified = GF_TRUE;
 				}
 			}
 		}
 		*is_slice = GF_TRUE;
 		//we disable temporal scalability when parsing mvc - never used and many encoders screw up POC in enhancemen
 		if (ctx->is_mvc && (res>=0)) {
 			res=0;
 			ctx->avc_state->s_info.poc = ctx->last_poc;
 		}
         if (ctx->avc_state->s_info.sps) {
             switch (ctx->avc_state->s_info.slice_type) {
             case GF_AVC_TYPE_P:
             case GF_AVC_TYPE2_P:
                 ctx->avc_state->s_info.sps->nb_ep++;
                 break;
             case GF_AVC_TYPE_I:
             case GF_AVC_TYPE2_I:
                 ctx->avc_state->s_info.sps->nb_ei++;
                 break;
             case GF_AVC_TYPE_B:
             case GF_AVC_TYPE2_B:
                 ctx->avc_state->s_info.sps->nb_eb++;
                 break;
             }
         }
         break;
 	case GF_AVC_NALU_SLICE_AUX:
 		*is_slice = GF_TRUE;
 		break;
 
 	case GF_AVC_NALU_DV_RPU:
 		if (ctx->dv_mode==DVMODE_CLEAN) {
 			*skip_nal = GF_TRUE;
 		} else {
 			ctx->nb_dv_rpu ++;
 			if (ctx->nb_dv_rpu==1)
 				naludmx_set_dolby_vision(ctx);
 		}
 		break;
 	case GF_AVC_NALU_DV_EL:
 		if ((ctx->dv_mode==DVMODE_CLEAN) || (ctx->dv_mode==DVMODE_SINGLE)) {
 			*skip_nal = GF_TRUE;
 		} else {
 			ctx->nb_dv_el ++;
 			if (ctx->nb_dv_el==1)
 				naludmx_set_dolby_vision(ctx);
 		}
 		break;
 	}
 	return res;
 }
diff --git a/src/isomedia/avc_ext.c b/src/isomedia/avc_ext.c
index bfe6ee7c0..da6b06317 100644
--- a/src/isomedia/avc_ext.c
+++ b/src/isomedia/avc_ext.c
@@ -2733,126 +2733,127 @@ void avcc_box_del(GF_Box *s)
 GF_Err avcc_box_read(GF_Box *s, GF_BitStream *bs)
 {
 	u32 i, count;
 	GF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *)s;
 
 	if (ptr->config) gf_odf_avc_cfg_del(ptr->config);
 	ptr->config = gf_odf_avc_cfg_new();
 
 	ISOM_DECREASE_SIZE(ptr, 7) //7 includes the 2 counts of sps and pps
 
 	Bool is_avcc;
 	if ((ptr->type==GF_ISOM_BOX_TYPE_AVCC) || (ptr->type==GF_ISOM_BOX_TYPE_AVCE))
 		is_avcc = GF_TRUE;
 	else
 		is_avcc = GF_FALSE;
 
+	//we don't use gf_odf_avc_cfg_read to deal with missing rext profile signaling on many files
 	ptr->config->configurationVersion = gf_bs_read_u8(bs);
 	ptr->config->AVCProfileIndication = gf_bs_read_u8(bs);
 	ptr->config->profile_compatibility = gf_bs_read_u8(bs);
 	ptr->config->AVCLevelIndication = gf_bs_read_u8(bs);
 	if (is_avcc) {
 		gf_bs_read_int(bs, 6);
 	} else {
 		ptr->config->complete_representation = gf_bs_read_int(bs, 1);
 		gf_bs_read_int(bs, 5);
 	}
 	ptr->config->nal_unit_size = 1 + gf_bs_read_int(bs, 2);
 	gf_bs_read_int(bs, 3);
 	count = gf_bs_read_int(bs, 5);
 
 	for (i=0; i<count; i++) {
 		ISOM_DECREASE_SIZE(ptr, 2)
 		GF_NALUFFParam *sl = (GF_NALUFFParam *) gf_malloc(sizeof(GF_NALUFFParam));
 		sl->size = gf_bs_read_u16(bs);
 		if (!sl->size || (gf_bs_available(bs) < sl->size) || (ptr->size < sl->size) ) {
 			gf_free(sl);
 			GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, ("AVCC: Not enough bits to parse. Aborting.\n"));
 			return GF_ISOM_INVALID_FILE;
 		}
 		sl->data = (char *)gf_malloc(sizeof(char) * sl->size);
 		gf_bs_read_data(bs, sl->data, sl->size);
 		gf_list_add(ptr->config->sequenceParameterSets, sl);
 		ptr->size -= sl->size;
 	}
 
 	count = gf_bs_read_u8(bs);
 	for (i=0; i<count; i++) {
 		ISOM_DECREASE_SIZE(ptr, 2)
 		GF_NALUFFParam *sl = (GF_NALUFFParam *)gf_malloc(sizeof(GF_NALUFFParam));
 		sl->size = gf_bs_read_u16(bs);
 		if (!sl->size || (gf_bs_available(bs) < sl->size) || (ptr->size<sl->size)) {
 			gf_free(sl);
 			GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, ("AVCC: Not enough bits to parse. Aborting.\n"));
 			return GF_ISOM_INVALID_FILE;
 		}
 		sl->data = (char *)gf_malloc(sizeof(char) * sl->size);
 		gf_bs_read_data(bs, sl->data, sl->size);
 		gf_list_add(ptr->config->pictureParameterSets, sl);
 		ptr->size -= sl->size;
 	}
 
 	//not avcC (svcC; mvcC), no check for rext signaling
 	if (!is_avcc)
 		return GF_OK;
 
 	//not REXT profile, no check for rext signaling
 	if (!gf_avc_is_rext_profile(ptr->config->AVCProfileIndication))
 		return GF_OK;
 
 	//non-compliant file (rext signaling missing), try to fill in values from SPS
 	if (!ptr->size) {
 		/*set default values ...*/
 		ptr->config->chroma_format = 1;
 		ptr->config->luma_bit_depth = 8;
 		ptr->config->chroma_bit_depth = 8;
 
 #ifndef GPAC_DISABLE_AV_PARSERS
 		GF_NALUFFParam *sl = (GF_NALUFFParam*)gf_list_get(ptr->config->sequenceParameterSets, 0);
 		if (sl) {
 			AVCState avc;
 			s32 idx;
 			memset(&avc, 0, sizeof(AVCState));
 			idx = gf_avc_read_sps(sl->data, sl->size, &avc, 0, NULL);
 			if (idx>=0) {
 				ptr->config->chroma_format = avc.sps[idx].chroma_format;
 				ptr->config->luma_bit_depth = 8 + avc.sps[idx].luma_bit_depth_m8;
 				ptr->config->chroma_bit_depth = 8 + avc.sps[idx].chroma_bit_depth_m8;
 			}
 		}
 #endif
-		GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, ("AVCC: invalid syntax for REXT profile, patching.\n"));
+		GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, ("[isom/avcc] Missing REXT profile signaling, patching.\n"));
 		return GF_OK;
 	}
 	ISOM_DECREASE_SIZE(ptr, 4)
 	gf_bs_read_int(bs, 6);
 	ptr->config->chroma_format = gf_bs_read_int(bs, 2);
 	gf_bs_read_int(bs, 5);
 	ptr->config->luma_bit_depth = 8 + gf_bs_read_int(bs, 3);
 	gf_bs_read_int(bs, 5);
 	ptr->config->chroma_bit_depth = 8 + gf_bs_read_int(bs, 3);
 
 	count = gf_bs_read_int(bs, 8);
 	if (count*2 > ptr->size) {
 		//ffmpeg just ignores this part while allocating bytes (filled with garbage?)
 		GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, ("AVCC: invalid numOfSequenceParameterSetExt value. Skipping.\n"));
 		return GF_OK;
 	}
 	if (count) {
 		ptr->config->sequenceParameterSetExtensions = gf_list_new();
 		for (i=0; i<count; i++) {
 			ISOM_DECREASE_SIZE(ptr, 2)
 			GF_NALUFFParam *sl = (GF_NALUFFParam *)gf_malloc(sizeof(GF_NALUFFParam));
 			sl->size = gf_bs_read_u16(bs);
 			if ((gf_bs_available(bs) < sl->size) || (ptr->size<sl->size)) {
 				gf_free(sl);
 				GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, ("AVCC: Not enough bits to parse. Aborting.\n"));
 				return GF_ISOM_INVALID_FILE;
 			}
 			sl->data = (char *)gf_malloc(sizeof(char) * sl->size);
 			gf_bs_read_data(bs, sl->data, sl->size);
 			gf_list_add(ptr->config->sequenceParameterSetExtensions, sl);
 			ptr->size -= sl->size;
 		}
 	}
 	return GF_OK;
 }
diff --git a/src/media_tools/av_parsers.c b/src/media_tools/av_parsers.c
index e66b1a2e0..0daae2752 100644
--- a/src/media_tools/av_parsers.c
+++ b/src/media_tools/av_parsers.c
@@ -1907,42 +1907,47 @@ GF_Err gf_media_parse_ivf_frame_header(GF_BitStream *bs, u64 *frame_size, u64 *p
 GF_Err gf_vp9_parse_superframe(GF_BitStream *bs, u64 ivf_frame_size, u32 *num_frames_in_superframe, u32 frame_sizes[VP9_MAX_FRAMES_IN_SUPERFRAME], u32 *superframe_index_size)
 {
 	u32 byte, bytes_per_framesize;
 	u64 pos = gf_bs_get_position(bs), i = 0;
 	GF_Err e;
 
 	assert(bs && num_frames_in_superframe);
 
 	/*initialize like there is no superframe*/
 	memset(frame_sizes, 0, VP9_MAX_FRAMES_IN_SUPERFRAME * sizeof(frame_sizes[0]));
 	*num_frames_in_superframe = 1;
 	frame_sizes[0] = (u32)ivf_frame_size;
 	*superframe_index_size = 0;
 
 	e = gf_bs_seek(bs, pos + ivf_frame_size - 1);
 	if (e) return e;
 
+	gf_bs_mark_overflow(bs, GF_TRUE);
+
 	byte = gf_bs_read_u8(bs);
 	if ((byte & 0xe0) != 0xc0)
 		goto exit; /*no superframe*/
 
 	bytes_per_framesize = 1 + ((byte & 0x18) >> 3);
 	*num_frames_in_superframe = (u32)(1 + (byte & 0x7));
 
 	/*superframe_index()*/
 	*superframe_index_size = 2 + bytes_per_framesize * *num_frames_in_superframe;
 	gf_bs_seek(bs, pos + ivf_frame_size - *superframe_index_size);
 	byte = gf_bs_read_u8(bs);
 	if ((byte & 0xe0) != 0xc0) {
 		e = GF_NON_COMPLIANT_BITSTREAM;
 		goto exit; /*no superframe*/
 	}
 	frame_sizes[0] = 0;
 	for (i = 0; i < *num_frames_in_superframe; ++i) {
 		gf_bs_read_data(bs, (char*)(frame_sizes + i), bytes_per_framesize);
 	}
 
 exit:
 	gf_bs_seek(bs, pos);
+
+	if (gf_bs_is_overflow(bs)) e = GF_NON_COMPLIANT_BITSTREAM;
+
 	return e;
 }
 
@@ -2686,67 +2691,67 @@ Bool gf_media_aom_probe_annexb(GF_BitStream *bs)
 GF_Err aom_av1_parse_temporal_unit_from_annexb(GF_BitStream *bs, AV1State *state)
 {
 	GF_Err e;
 	u64 tupos;
 	u64 tusize, sz;
 	if (!bs || !state) return GF_BAD_PARAM;
 
-	state->bs_overread = GF_FALSE;
+	gf_bs_mark_overflow(bs, GF_TRUE);
 	tusize = sz = gf_av1_leb128_read(bs, NULL);
 	tupos = gf_bs_get_position(bs);
 	if (!sz) {
 		GF_LOG(GF_LOG_INFO, GF_LOG_CODING, ("[AV1] temporal unit size is 0, likely not annex B\n"));
 		return GF_NON_COMPLIANT_BITSTREAM;
 	}
 
 	GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, ("[AV1] Annex B temporal unit detected (size "LLU") ***** \n", sz));
 	while (sz > 0) {
 		u8 Leb128Bytes = 0;
 		u64 frame_unit_size = gf_av1_leb128_read(bs, &Leb128Bytes);
 
-		if (state->bs_overread) {
+		if (gf_bs_is_overflow(bs)) {
 			return GF_BUFFER_TOO_SMALL;
 		}
 		if (sz < Leb128Bytes + frame_unit_size) {
 			GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, ("[AV1] Annex B sz("LLU") < Leb128Bytes("LLU") + frame_unit_size("LLU")\n", sz, Leb128Bytes, frame_unit_size));
 			return GF_NON_COMPLIANT_BITSTREAM;
 		}
 		GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, ("[AV1] Annex B frame unit detected (size "LLU")\n", frame_unit_size));
 		sz -= Leb128Bytes + frame_unit_size;
 
 		while (frame_unit_size > 0) {
 			u64 pos, obu_size = gf_av1_leb128_read(bs, &Leb128Bytes);
 
-			if (state->bs_overread) {
+			if (gf_bs_is_overflow(bs)) {
 				return GF_BUFFER_TOO_SMALL;
 			}
 			if (frame_unit_size < Leb128Bytes + obu_size) {
 				GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, ("[AV1] Annex B frame_unit_size("LLU") < Leb128Bytes("LLU") + obu_length("LLU")\n", frame_unit_size, Leb128Bytes, obu_size));
 				return GF_NON_COMPLIANT_BITSTREAM;
 			}
 			GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, ("[AV1] Annex B OBU detected (size "LLU")\n", obu_size));
 			pos = gf_bs_get_position(bs);
 			frame_unit_size -= Leb128Bytes;
 
 			e = gf_av1_parse_obu(bs, &state->obu_type, &obu_size, NULL, state);
 			if (e) return e;
 
 			if (obu_size != gf_bs_get_position(bs) - pos) {
 				GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, ("[AV1] Annex B frame size "LLU" different from consumed bytes "LLU".\n", obu_size, gf_bs_get_position(bs) - pos));
 				return GF_NON_COMPLIANT_BITSTREAM;
 			}
 
 			av1_populate_state_from_obu(bs, pos, obu_size, state->obu_type, state);
 			if (frame_unit_size < obu_size) {
 				GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, ("[AV1] Annex B frame_unit_size("LLU") < OBU size ("LLU")\n", frame_unit_size, obu_size));
 				return GF_NON_COMPLIANT_BITSTREAM;
 			}
 			frame_unit_size -= obu_size;
 		}
 	}
 	assert(sz == 0);
 	if (tusize != gf_bs_get_position(bs) - tupos) {
 		GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, ("[AV1] Annex B TU size "LLU" different from consumed bytes "LLU".\n", tusize, gf_bs_get_position(bs) - tupos));
 		return GF_NON_COMPLIANT_BITSTREAM;
 	}
 	return GF_OK;
 }
@@ -4120,12 +4125,6 @@ static GF_Err av1_parse_frame(GF_BitStream *bs, AV1State *state, u64 obu_start,
 	return av1_parse_tile_group(bs, state, obu_start, obu_size);
 }
 
-static void on_aom_av1_eos(void *_state)
-{
-	AV1State *state = (AV1State *)_state;
-	state->bs_overread = GF_TRUE;
-}
-
 static void av1_parse_obu_metadata(AV1State *state, GF_BitStream *bs)
 {
 	u32 metadata_type = (u32)gf_av1_leb128_read(bs, NULL);
@@ -4150,117 +4149,118 @@ GF_EXPORT
 GF_Err gf_av1_parse_obu(GF_BitStream *bs, ObuType *obu_type, u64 *obu_size, u32 *obu_hdr_size, AV1State *state)
 {
 	GF_Err e = GF_OK;
 	u32 i, hdr_size;
 	u64 pos = gf_bs_get_position(bs);
 
 	if (!bs || !obu_type || !state)
 		return GF_BAD_PARAM;
 
-	state->bs_overread = GF_FALSE;
-	gf_bs_set_eos_callback(bs, on_aom_av1_eos, state);
+	gf_bs_mark_overflow(bs, GF_TRUE);
 
 	state->obu_extension_flag = state->obu_has_size_field = 0;
 	state->temporal_id = state->spatial_id = 0;
 	state->frame_state.uncompressed_header_bytes = 0;
 	e = gf_av1_parse_obu_header(bs, obu_type, &state->obu_extension_flag, &state->obu_has_size_field, &state->temporal_id, &state->spatial_id);
+	if (gf_bs_is_overflow(bs)) e = GF_NON_COMPLIANT_BITSTREAM;
 	if (e)
 		return e;
 
 	//at this point obu_size is either zero or the size of the containing buffer (likely the Temporal Unit)
 	if (state->obu_has_size_field) {
 		*obu_size = (u32)gf_av1_leb128_read(bs, NULL);
 	}
 	else {
 		if (*obu_size >= 1 + state->obu_extension_flag) {
 			*obu_size = *obu_size - 1 - state->obu_extension_flag;
 		}
 		else {
 			GF_LOG(state->config ? GF_LOG_WARNING : GF_LOG_DEBUG, GF_LOG_CODING, ("[AV1] computed OBU size "LLD" (input value = "LLU"). Skipping.\n", *obu_size - 1 - state->obu_extension_flag, *obu_size));
 			return GF_NON_COMPLIANT_BITSTREAM;
 		}
 	}
 	hdr_size = (u32)(gf_bs_get_position(bs) - pos);
-	if ((gf_bs_available(bs) < *obu_size) || state->bs_overread) {
+	if (gf_bs_is_overflow(bs) || (gf_bs_available(bs) < *obu_size) ) {
 		gf_bs_seek(bs, pos);
 		return GF_BUFFER_TOO_SMALL;
 	}
 	//gpac's internal obu_size includes the header + the payload
 	*obu_size += hdr_size;
 	if (obu_hdr_size) *obu_hdr_size = hdr_size;
 
 	if (*obu_type != OBU_SEQUENCE_HEADER && *obu_type != OBU_TEMPORAL_DELIMITER &&
 		state->OperatingPointIdc != 0 && state->obu_extension_flag == 1)
 	{
 		u32 inTemporalLayer = (state->OperatingPointIdc >> state->temporal_id) & 1;
 		u32 inSpatialLayer = (state->OperatingPointIdc >> (state->spatial_id + 8)) & 1;
 		if (!inTemporalLayer || !inSpatialLayer) {
 			*obu_type = -1;
 			gf_bs_seek(bs, pos + *obu_size);
 			return GF_OK;
 		}
 	}
 
 	e = GF_OK;
 
 	/* for AVIF a1lx */
 	for (i = state->spatial_id; i < 4; i++) {
 		state->layer_size[i] = (u32) (pos + *obu_size);
 	}
 
 	switch (*obu_type) {
 	case OBU_SEQUENCE_HEADER:
 		av1_parse_sequence_header_obu(bs, state);
-		if (gf_bs_get_position(bs) > pos + *obu_size) {
+		if (gf_bs_is_overflow(bs) || (gf_bs_get_position(bs) > pos + *obu_size)) {
 			GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, ("[AV1] Sequence header parsing consumed too many bytes !\n"));
 			e = GF_NON_COMPLIANT_BITSTREAM;
 		}
 		gf_bs_seek(bs, pos + *obu_size);
 		break;
 
 	case OBU_METADATA:
 		av1_parse_obu_metadata(state, bs);
 		gf_bs_seek(bs, pos + *obu_size);
+		if (gf_bs_is_overflow(bs)) e = GF_NON_COMPLIANT_BITSTREAM;
 		break;
 
 	case OBU_FRAME_HEADER:
 	case OBU_REDUNDANT_FRAME_HEADER:
 		if (state->config) {
 			av1_parse_frame_header(bs, state);
-			if (gf_bs_get_position(bs) > pos + *obu_size) {
+			if (gf_bs_is_overflow(bs) || (gf_bs_get_position(bs) > pos + *obu_size)) {
 				GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, ("[AV1] Frame header parsing consumed too many bytes !\n"));
 				e = GF_NON_COMPLIANT_BITSTREAM;
 			}
 		}
 		gf_bs_seek(bs, pos + *obu_size);
 		break;
 	case OBU_FRAME:
 		e = av1_parse_frame(bs, state, pos, *obu_size);
-		if (gf_bs_get_position(bs) != pos + *obu_size) {
+		if (gf_bs_is_overflow(bs) || (gf_bs_get_position(bs) != pos + *obu_size)) {
 			GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, ("[AV1] Frame parsing did not consume the right number of bytes !\n"));
 			e = GF_NON_COMPLIANT_BITSTREAM;
 		}
 		gf_bs_seek(bs, pos + *obu_size);
 		break;
 	case OBU_TILE_GROUP:
 		if (state->config) {
 			e = av1_parse_tile_group(bs, state, pos, *obu_size);
-			if (gf_bs_get_position(bs) != pos + *obu_size) {
+			if (gf_bs_is_overflow(bs) || (gf_bs_get_position(bs) != pos + *obu_size)) {
 				GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, ("[AV1] Tile group parsing did not consume the right number of bytes !\n"));
 				e = GF_NON_COMPLIANT_BITSTREAM;
 			}
 		}
 		gf_bs_seek(bs, pos + *obu_size);
 		break;
 	case OBU_TEMPORAL_DELIMITER:
 		state->frame_state.seen_frame_header = GF_FALSE;
 		state->clli_valid = state->mdcv_valid = 0;
 	case OBU_PADDING:
 		gf_bs_seek(bs, pos + *obu_size);
 		break;
 	default:
 		GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, ("[AV1] unknown OBU type %u (size "LLU"). Skipping.\n", *obu_type, *obu_size));
 		gf_bs_seek(bs, pos + *obu_size);
 		break;
 	}
 	return e;
 }
@@ -4722,43 +4722,46 @@ const char *gf_avc_hevc_get_chroma_format_name(u8 chroma_format)
 u32 gf_bs_read_ue_log_idx3(GF_BitStream *bs, const char *fname, s32 idx1, s32 idx2, s32 idx3)
 {
 	u32 val=0, code;
 	s32 nb_lead = -1;
 	u32 bits = 0;
 	for (code=0; !code; nb_lead++) {
 		if (nb_lead>=32) {
 			break;
 		}
 		code = gf_bs_read_int(bs, 1);
 		bits++;
 	}
 
 	if (nb_lead>=32) {
-		//gf_bs_read_int keeps returning 0 on EOS, so if no more bits available, rbsp was truncated otherwise code is broken in rbsp)
-		//we only test once nb_lead>=32 to avoid testing at each bit read
-		if (!gf_bs_available(bs)) {
-			GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, ("[Core] exp-golomb read failed, not enough bits in bitstream !\n"));
-		} else {
-			GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, ("[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\n", nb_lead));
+		if (gf_bs_is_overflow(bs)<2) {
+			//gf_bs_read_int keeps returning 0 on EOS, so if no more bits available, rbsp was truncated otherwise code is broken in rbsp)
+			//we only test once nb_lead>=32 to avoid testing at each bit read
+			if (!gf_bs_available(bs)) {
+				GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, ("[Core] exp-golomb read failed, not enough bits in bitstream !\n"));
+			} else {
+				GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, ("[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\n", nb_lead));
+			}
+			gf_bs_mark_overflow(bs, GF_FALSE);
 		}
 		return 0;
 	}
 
 	if (nb_lead) {
 		u32 leads=1;
 		val = gf_bs_read_int(bs, nb_lead);
 		leads <<= nb_lead;
 		leads -= 1;
 		val += leads;
 //		val += (1 << nb_lead) - 1;
 		bits += nb_lead;
 	}
 
 	if (fname) {
 		gf_bs_log_idx(bs, bits, fname, val, idx1, idx2, idx3);
 	}
 	return val;
 }
 
 #define gf_bs_read_ue_log_idx2(_bs, _fname, _idx1, _idx2) gf_bs_read_ue_log_idx3(_bs, _fname, (s32) _idx1, (s32) _idx2, -1)
 #define gf_bs_read_ue_log_idx(_bs, _fname, _idx) gf_bs_read_ue_log_idx3(_bs, _fname, (s32) _idx, -1, -1)
 #define gf_bs_read_ue_log(_bs, _fname) gf_bs_read_ue_log_idx3(_bs, _fname, -1, -1, -1)
@@ -6090,162 +6093,172 @@ GF_EXPORT
 s32 gf_avc_parse_nalu(GF_BitStream *bs, AVCState *avc)
 {
 	u8 idr_flag;
 	s32 slice, ret;
 	u32 nal_hdr;
 	AVCSliceInfo n_state;
 
 	gf_bs_enable_emulation_byte_removal(bs, GF_TRUE);
+	if (!gf_bs_available(bs)) return -1;
+	gf_bs_mark_overflow(bs, GF_TRUE);
 
 	nal_hdr = gf_bs_read_u8(bs);
 
 	slice = 0;
 	memcpy(&n_state, &avc->s_info, sizeof(AVCSliceInfo));
 	avc->last_nal_type_parsed = n_state.nal_unit_type = nal_hdr & 0x1F;
 	n_state.nal_ref_idc = (nal_hdr >> 5) & 0x3;
 
 	idr_flag = 0;
 
 	switch (n_state.nal_unit_type) {
 	case GF_AVC_NALU_ACCESS_UNIT:
 	case GF_AVC_NALU_END_OF_SEQ:
 	case GF_AVC_NALU_END_OF_STREAM:
 		ret = 1;
 		break;
 
 	case GF_AVC_NALU_SVC_SLICE:
 		SVC_ReadNal_header_extension(bs, &n_state.svc_nalhdr);
+		if (gf_bs_is_overflow(bs)) return -1;
+
 		// slice buffer - read the info and compare.
 		/*ret = */svc_parse_slice(bs, avc, &n_state);
 		if (avc->s_info.nal_ref_idc) {
 			n_state.poc_lsb_prev = avc->s_info.poc_lsb;
 			n_state.poc_msb_prev = avc->s_info.poc_msb;
 		}
 		avc_compute_poc(&n_state);
 
 		if (avc->s_info.poc != n_state.poc) {
 			memcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));
 			return 1;
 		}
 		memcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));
 		return 0;
 
 	case GF_AVC_NALU_SVC_PREFIX_NALU:
 		SVC_ReadNal_header_extension(bs, &avc->s_info.svc_nalhdr);
+		if (gf_bs_is_overflow(bs)) return -1;
 		return 0;
 
 	case GF_AVC_NALU_IDR_SLICE:
 	case GF_AVC_NALU_NON_IDR_SLICE:
 	case GF_AVC_NALU_DP_A_SLICE:
 	case GF_AVC_NALU_DP_B_SLICE:
 	case GF_AVC_NALU_DP_C_SLICE:
 		slice = 1;
 		/* slice buffer - read the info and compare.*/
 		ret = avc_parse_slice(bs, avc, idr_flag, &n_state);
+		if (gf_bs_is_overflow(bs)) ret = -1;
 		if (ret < 0) return ret;
 		ret = 0;
 		if (
 			((avc->s_info.nal_unit_type > GF_AVC_NALU_IDR_SLICE) || (avc->s_info.nal_unit_type < GF_AVC_NALU_NON_IDR_SLICE))
 			&& (avc->s_info.nal_unit_type != GF_AVC_NALU_SVC_SLICE)
 			) {
 			break;
 		}
 		if (avc->s_info.frame_num != n_state.frame_num) {
 			ret = 1;
 			break;
 		}
 
 		if (avc->s_info.field_pic_flag != n_state.field_pic_flag) {
 			ret = 1;
 			break;
 		}
 		if ((avc->s_info.nal_ref_idc != n_state.nal_ref_idc) &&
 			(!avc->s_info.nal_ref_idc || !n_state.nal_ref_idc)) {
 			ret = 1;
 			break;
 		}
 		if (!avc->s_info.sps)
 			return -1;
 
 		if (avc->s_info.sps->poc_type == n_state.sps->poc_type) {
 			if (!avc->s_info.sps->poc_type) {
 				if (!n_state.bottom_field_flag && (avc->s_info.poc_lsb != n_state.poc_lsb)) {
 					ret = 1;
 					break;
 				}
 				if (avc->s_info.delta_poc_bottom != n_state.delta_poc_bottom) {
 					ret = 1;
 					break;
 				}
 			}
 			else if (avc->s_info.sps->poc_type == 1) {
 				if (avc->s_info.delta_poc[0] != n_state.delta_poc[0]) {
 					ret = 1;
 					break;
 				}
 				if (avc->s_info.delta_poc[1] != n_state.delta_poc[1]) {
 					ret = 1;
 					break;
 				}
 			}
 		}
 
 		if (n_state.nal_unit_type == GF_AVC_NALU_IDR_SLICE) {
 			if (avc->s_info.nal_unit_type != GF_AVC_NALU_IDR_SLICE) { /*IdrPicFlag differs in value*/
 				ret = 1;
 				break;
 			}
 			else if (avc->s_info.idr_pic_id != n_state.idr_pic_id) { /*both IDR and idr_pic_id differs*/
 				ret = 1;
 				break;
 			}
 		}
 		break;
 	case GF_AVC_NALU_SEQ_PARAM:
 		avc->last_ps_idx = gf_avc_read_sps_bs_internal(bs, avc, 0, NULL, nal_hdr);
+		if (gf_bs_is_overflow(bs)) return -1;
 		if (avc->last_ps_idx < 0) return -1;
 		return 0;
 
 	case GF_AVC_NALU_PIC_PARAM:
 		avc->last_ps_idx = gf_avc_read_pps_bs_internal(bs, avc, nal_hdr);
+		if (gf_bs_is_overflow(bs)) return -1;
 		if (avc->last_ps_idx < 0) return -1;
 		return 0;
 	case GF_AVC_NALU_SVC_SUBSEQ_PARAM:
 		avc->last_ps_idx = gf_avc_read_sps_bs_internal(bs, avc, 1, NULL, nal_hdr);
+		if (gf_bs_is_overflow(bs)) return -1;
 		if (avc->last_ps_idx < 0) return -1;
 		return 0;
 	case GF_AVC_NALU_SEQ_PARAM_EXT:
 		avc->last_ps_idx = (s32) gf_bs_read_ue(bs);
+		if (gf_bs_is_overflow(bs)) return -1;
 		if (avc->last_ps_idx < 0) return -1;
 		return 0;
 
 	case GF_AVC_NALU_SEI:
 	case GF_AVC_NALU_FILLER_DATA:
 		return 0;
 
 	default:
 		if (avc->s_info.nal_unit_type <= GF_AVC_NALU_IDR_SLICE) ret = 1;
 		//To detect change of AU when multiple sps and pps in stream
 		else if ((nal_hdr & 0x1F) == GF_AVC_NALU_SEI && avc->s_info.nal_unit_type == GF_AVC_NALU_SVC_SLICE)
 			ret = 1;
 		else if ((nal_hdr & 0x1F) == GF_AVC_NALU_SEQ_PARAM && avc->s_info.nal_unit_type == GF_AVC_NALU_SVC_SLICE)
 			ret = 1;
 		else
 			ret = 0;
 		break;
 	}
 
 	/* save _prev values */
 	if (ret && avc->s_info.sps) {
 		n_state.frame_num_offset_prev = avc->s_info.frame_num_offset;
 		if ((avc->s_info.sps->poc_type != 2) || (avc->s_info.nal_ref_idc != 0))
 			n_state.frame_num_prev = avc->s_info.frame_num;
 		if (avc->s_info.nal_ref_idc) {
 			n_state.poc_lsb_prev = avc->s_info.poc_lsb;
 			n_state.poc_msb_prev = avc->s_info.poc_msb;
 		}
 	}
 	if (slice)
 		avc_compute_poc(&n_state);
 	memcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));
 	return ret;
 }
@@ -8558,89 +8571,95 @@ GF_EXPORT
 s32 gf_hevc_parse_nalu_bs(GF_BitStream *bs, HEVCState *hevc, u8 *nal_unit_type, u8 *temporal_id, u8 *layer_id)
 {
 	Bool is_slice = GF_FALSE;
 	s32 ret = -1;
 	HEVCSliceInfo n_state;
 
 	gf_bs_enable_emulation_byte_removal(bs, GF_TRUE);
+	if (gf_bs_available(bs)<2) return -1;
+
+	gf_bs_mark_overflow(bs, GF_TRUE);
 
 	memcpy(&n_state, &hevc->s_info, sizeof(HEVCSliceInfo));
 	if (!hevc_parse_nal_header(bs, nal_unit_type, temporal_id, layer_id)) return -1;
 
 	n_state.nal_unit_type = *nal_unit_type;
 
 	switch (n_state.nal_unit_type) {
 	case GF_HEVC_NALU_ACCESS_UNIT:
 	case GF_HEVC_NALU_END_OF_SEQ:
 	case GF_HEVC_NALU_END_OF_STREAM:
 		ret = 1;
 		break;
 
 		/*slice_segment_layer_rbsp*/
 	case GF_HEVC_NALU_SLICE_TRAIL_N:
 	case GF_HEVC_NALU_SLICE_TRAIL_R:
 	case GF_HEVC_NALU_SLICE_TSA_N:
 	case GF_HEVC_NALU_SLICE_TSA_R:
 	case GF_HEVC_NALU_SLICE_STSA_N:
 	case GF_HEVC_NALU_SLICE_STSA_R:
 	case GF_HEVC_NALU_SLICE_BLA_W_LP:
 	case GF_HEVC_NALU_SLICE_BLA_W_DLP:
 	case GF_HEVC_NALU_SLICE_BLA_N_LP:
 	case GF_HEVC_NALU_SLICE_IDR_W_DLP:
 	case GF_HEVC_NALU_SLICE_IDR_N_LP:
 	case GF_HEVC_NALU_SLICE_CRA:
 	case GF_HEVC_NALU_SLICE_RADL_N:
 	case GF_HEVC_NALU_SLICE_RADL_R:
 	case GF_HEVC_NALU_SLICE_RASL_N:
 	case GF_HEVC_NALU_SLICE_RASL_R:
 		is_slice = GF_TRUE;
 		/* slice - read the info and compare.*/
 		ret = hevc_parse_slice_segment(bs, hevc, &n_state);
 		if (ret < 0) return ret;
 
 		hevc_compute_poc(&n_state);
 
 		ret = 0;
 
 		if (hevc->s_info.poc != n_state.poc) {
 			ret = 1;
 			break;
 		}
 		if (n_state.first_slice_segment_in_pic_flag) {
 			if (!(*layer_id) || (n_state.prev_layer_id_plus1 && ((*layer_id) <= n_state.prev_layer_id_plus1 - 1))) {
 				ret = 1;
 				break;
 			}
 		}
 		break;
 	case GF_HEVC_NALU_SEQ_PARAM:
 		hevc->last_parsed_sps_id = gf_hevc_read_sps_bs_internal(bs, hevc, *layer_id, NULL);
 		ret = (hevc->last_parsed_sps_id>=0) ? 0 : -1;
 		break;
 	case GF_HEVC_NALU_PIC_PARAM:
 		hevc->last_parsed_pps_id = gf_hevc_read_pps_bs_internal(bs, hevc);
 		ret = (hevc->last_parsed_pps_id>=0) ? 0 : -1;
 		break;
 	case GF_HEVC_NALU_VID_PARAM:
 		hevc->last_parsed_vps_id = gf_hevc_read_vps_bs_internal(bs, hevc, GF_FALSE);
 		ret = (hevc->last_parsed_vps_id>=0) ? 0 : -1;
 		break;
 	default:
 		ret = 0;
 		break;
 	}
 
+	if (gf_bs_is_overflow(bs))
+		ret = -1;
+
 	/* save _prev values */
 	if ((ret>0) && hevc->s_info.sps) {
 		n_state.frame_num_offset_prev = hevc->s_info.frame_num_offset;
 		n_state.frame_num_prev = hevc->s_info.frame_num;
 
 		n_state.poc_lsb_prev = hevc->s_info.poc_lsb;
 		n_state.poc_msb_prev = hevc->s_info.poc_msb;
 		if (is_slice)
 			n_state.prev_layer_id_plus1 = *layer_id + 1;
 	}
 	if (is_slice) hevc_compute_poc(&n_state);
 	memcpy(&hevc->s_info, &n_state, sizeof(HEVCSliceInfo));
 
 	return ret;
 }
@@ -8649,26 +8668,28 @@ GF_EXPORT
 s32 gf_hevc_parse_nalu(u8 *data, u32 size, HEVCState *hevc, u8 *nal_unit_type, u8 *temporal_id, u8 *layer_id)
 {
 	GF_BitStream *bs = NULL;
 	s32 ret = -1;
 
+	if (size<2) return -1;
+
 	if (!hevc) {
 		if (nal_unit_type) (*nal_unit_type) = (data[0] & 0x7E) >> 1;
 		if (layer_id) {
 			u8 id = data[0] & 1;
 			id <<= 5;
 			id |= (data[1] >> 3) & 0x1F;
 			(*layer_id) = id;
 		}
 		if (temporal_id) (*temporal_id) = (data[1] & 0x7);
 		return -1;
 	}
 
 	bs = gf_bs_new(data, size, GF_BITSTREAM_READ);
 	if (!bs) return -1;
 	gf_bs_enable_emulation_byte_removal(bs, GF_TRUE);
 
 	ret = gf_hevc_parse_nalu_bs(bs, hevc, nal_unit_type, temporal_id, layer_id);
 
 	gf_bs_del(bs);
 	return ret;
 }
@@ -11231,109 +11252,112 @@ GF_EXPORT
 s32 gf_vvc_parse_nalu_bs(GF_BitStream *bs, VVCState *vvc, u8 *nal_unit_type, u8 *temporal_id, u8 *layer_id)
 {
 	Bool is_slice = GF_FALSE;
 	s32 ret = -1;
 	Bool poc_reset = GF_FALSE;
 	VVCSliceInfo n_state;
 
 	gf_bs_enable_emulation_byte_removal(bs, GF_TRUE);
+	if (gf_bs_available(bs)<2) return -1;
+	gf_bs_mark_overflow(bs, GF_TRUE);
 
 	memcpy(&n_state, &vvc->s_info, sizeof(VVCSliceInfo));
 	if (!vvc_parse_nal_header(bs, nal_unit_type, temporal_id, layer_id)) return -1;
 
 	n_state.nal_unit_type = *nal_unit_type;
 
 	switch (n_state.nal_unit_type) {
 	case GF_VVC_NALU_ACCESS_UNIT:
 	case GF_VVC_NALU_END_OF_SEQ:
 	case GF_VVC_NALU_END_OF_STREAM:
 		//don't restore slice info, we don't have any change and n_state.poc_lsb / n_state.poc_msb is not valid
 		vvc->s_info.nal_unit_type = n_state.nal_unit_type;
 		return 1;
 
 	case GF_VVC_NALU_SLICE_IDR_W_RADL:
 	case GF_VVC_NALU_SLICE_IDR_N_LP:
 		poc_reset = GF_TRUE;
 	case GF_VVC_NALU_SLICE_TRAIL:
 	case GF_VVC_NALU_SLICE_STSA:
 	case GF_VVC_NALU_SLICE_RADL:
 	case GF_VVC_NALU_SLICE_RASL:
 	case GF_VVC_NALU_SLICE_CRA:
 	case GF_VVC_NALU_SLICE_GDR:
 		/* slice - read the info and compare.*/
 		ret = vvc_parse_slice(bs, vvc, &n_state);
 		if (ret < 0) {
 			memcpy(&vvc->s_info, &n_state, sizeof(VVCSliceInfo));
 			return ret;
 		}
 		
 		ret = 0;
 		if (n_state.compute_poc_defer || n_state.picture_header_in_slice_header_flag) {
 			is_slice = GF_TRUE;
 			n_state.compute_poc_defer = 0;
 
 			vvc_compute_poc(&n_state, poc_reset);
 			if (vvc->s_info.poc != n_state.poc) {
 				ret = 1;
 				break;
 			}
 			if (!(*layer_id) || (n_state.prev_layer_id_plus1 && ((*layer_id) <= n_state.prev_layer_id_plus1 - 1))) {
 				ret = 1;
 				break;
 			}
 		}
 		break;
 
 	case GF_VVC_NALU_PIC_HEADER:
 		if (vvc_parse_picture_header(bs, vvc, &n_state)<0) {
 			ret = -1;
 			break;
 		}
 		is_slice = GF_TRUE;
 
 		//we cannot compute poc until we know the first picture unit type, since IDR will reset poc count
 		//and irap_or_gdr_pic=0 does not prevent IDR from following
 		n_state.compute_poc_defer = 1;
 
 		if (!(*layer_id) || (n_state.prev_layer_id_plus1 && ((*layer_id) <= n_state.prev_layer_id_plus1 - 1))) {
 			ret = 1;
 		}
 		break;
 	case GF_VVC_NALU_SEQ_PARAM:
 		vvc->last_parsed_sps_id = gf_vvc_read_sps_bs_internal(bs, vvc, *layer_id, NULL);
 		ret = (vvc->last_parsed_sps_id>=0) ? 0 : -1;
 		break;
 	case GF_VVC_NALU_PIC_PARAM:
 		vvc->last_parsed_pps_id = gf_vvc_read_pps_bs_internal(bs, vvc);
 		ret = (vvc->last_parsed_pps_id>=0) ? 0 : -1;
 		break;
 	case GF_VVC_NALU_VID_PARAM:
 		vvc->last_parsed_vps_id = gf_vvc_read_vps_bs_internal(bs, vvc, GF_FALSE);
 		ret = (vvc->last_parsed_vps_id>=0) ? 0 : -1;
 		break;
 	case GF_VVC_NALU_DEC_PARAM:
 		ret = 0;
 		break;
 	case GF_VVC_NALU_APS_PREFIX:
 		//we use the mix aps type + aps id (first 8 bits) as unique identifier
 		vvc->last_parsed_aps_id = gf_bs_read_int_log(bs, 8, "aps_id");
 		ret = 0;
 		break;
 	default:
 		ret = 0;
 		break;
 	}
+	if (gf_bs_is_overflow(bs)) ret = -1;
 
 	/* save current POC lsb/msb to prev values */
 	if ((ret>0) && vvc->s_info.sps) {
 		if (!n_state.compute_poc_defer) {
 			n_state.poc_lsb_prev = n_state.poc_lsb;
 			n_state.poc_msb_prev = n_state.poc_msb;
 		}
 		if (is_slice)
 			n_state.prev_layer_id_plus1 = *layer_id + 1;
 	}
 
 	memcpy(&vvc->s_info, &n_state, sizeof(VVCSliceInfo));
 
 	return ret;
 }
@@ -11342,19 +11366,21 @@ GF_EXPORT
 s32 gf_vvc_parse_nalu(u8 *data, u32 size, VVCState *vvc, u8 *nal_unit_type, u8 *temporal_id, u8 *layer_id)
 {
 	GF_BitStream *bs = NULL;
 	s32 ret;
 
+	if (size<2) return -1;
+
 	if (!vvc) {
 		if (nal_unit_type) (*nal_unit_type) = data[1] >> 3;
 		if (layer_id) (*layer_id) = data[0] & 0x3f;
 		if (temporal_id) (*temporal_id) = (data[1] & 0x7);
 		return -1;
 	}
 	bs = gf_bs_new(data, size, GF_BITSTREAM_READ);
 	if (!bs) return -1;
 	gf_bs_enable_emulation_byte_removal(bs, GF_TRUE);
 
 	ret = gf_vvc_parse_nalu_bs(bs, vvc, nal_unit_type, temporal_id, layer_id);
 	gf_bs_del(bs);
 	return ret;
 }
diff --git a/src/odf/descriptors.c b/src/odf/descriptors.c
index 8b4bf1817..0c2143c48 100644
--- a/src/odf/descriptors.c
+++ b/src/odf/descriptors.c
@@ -1,33 +1,33 @@
 /*
  *			GPAC - Multimedia Framework C SDK
  *
  *			Authors: Jean Le Feuvre
- *			Copyright (c) Telecom ParisTech 2000-2012
+ *			Copyright (c) Telecom ParisTech 2000-2022
  *					All rights reserved
  *
  *  This file is part of GPAC / MPEG-4 ObjectDescriptor sub-project
  *
  *  GPAC is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
  *  the Free Software Foundation; either version 2, or (at your option)
  *  any later version.
  *
  *  GPAC is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU Lesser General Public License for more details.
  *
  *  You should have received a copy of the GNU Lesser General Public
  *  License along with this library; see the file COPYING.  If not, write to
  *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
  *
  */
 
 #include <gpac/internal/odf_dev.h>
 #include <gpac/constants.h>
 
 #include <gpac/avparse.h>
 
 #ifndef GPAC_DISABLE_AV_PARSERS
 #include <gpac/internal/media_dev.h>
 #endif
@@ -590,53 +590,98 @@ GF_EXPORT
 GF_AVCConfig *gf_odf_avc_cfg_read(u8 *dsi, u32 dsi_size)
 {
 	u32 i, count;
 	GF_AVCConfig *avcc = gf_odf_avc_cfg_new();
 	GF_BitStream *bs = gf_bs_new(dsi, dsi_size, GF_BITSTREAM_READ);
 	avcc->configurationVersion = gf_bs_read_int(bs, 8);
 	avcc->AVCProfileIndication  = gf_bs_read_int(bs, 8);
 	avcc->profile_compatibility = gf_bs_read_int(bs, 8);
 	avcc->AVCLevelIndication  = gf_bs_read_int(bs, 8);
 	gf_bs_read_int(bs, 6);
 	avcc->nal_unit_size = 1 + gf_bs_read_int(bs, 2);
 	gf_bs_read_int(bs, 3);
 	count = gf_bs_read_int(bs, 5);
 	for (i=0; i<count; i++) {
-		GF_NALUFFParam *sl = (GF_NALUFFParam *)gf_malloc(sizeof(GF_NALUFFParam));
-		sl->size = gf_bs_read_int(bs, 16);
+		GF_NALUFFParam *sl;
+		u32 size = gf_bs_read_int(bs, 16);
+		if ((size>gf_bs_available(bs)) || (size<2)) {
+			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[AVC] Wrong param set size %d\n", size));
+			gf_odf_avc_cfg_del(avcc);
+			return NULL;
+		}
+		GF_SAFEALLOC(sl, GF_NALUFFParam );
+		if (!sl) {
+			gf_odf_avc_cfg_del(avcc);
+			return NULL;
+		}
+		sl->size = size;
 		sl->data = (char*)gf_malloc(sizeof(char)*sl->size);
+		if (!sl->data) {
+			gf_odf_avc_cfg_del(avcc);
+			return NULL;
+		}
 		gf_bs_read_data(bs, sl->data, sl->size);
 		gf_list_add(avcc->sequenceParameterSets, sl);
 	}
 	count = gf_bs_read_int(bs, 8);
 	for (i=0; i<count; i++) {
-		GF_NALUFFParam *sl = (GF_NALUFFParam *)gf_malloc(sizeof(GF_NALUFFParam));
-		sl->size = gf_bs_read_int(bs, 16);
+		GF_NALUFFParam *sl;
+		u32 size = gf_bs_read_int(bs, 16);
+		if ((size>gf_bs_available(bs)) || (size<2)) {
+			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[AVC] Wrong param set size %d\n", size));
+			gf_odf_avc_cfg_del(avcc);
+			return NULL;
+		}
+		GF_SAFEALLOC(sl, GF_NALUFFParam );
+		if (!sl) {
+			gf_odf_avc_cfg_del(avcc);
+			return NULL;
+		}
+		sl->size = size;
 		sl->data = (char*)gf_malloc(sizeof(char)*sl->size);
+		if (!sl->data) {
+			gf_odf_avc_cfg_del(avcc);
+			return NULL;
+		}
 		gf_bs_read_data(bs, sl->data, sl->size);
 		gf_list_add(avcc->pictureParameterSets, sl);
 	}
 	if (gf_avc_is_rext_profile(avcc->AVCProfileIndication)) {
 		gf_bs_read_int(bs, 6);
 		avcc->chroma_format = gf_bs_read_int(bs, 2);
 		gf_bs_read_int(bs, 5);
 		avcc->luma_bit_depth = 8 + gf_bs_read_int(bs, 3);
 		gf_bs_read_int(bs, 5);
 		avcc->chroma_bit_depth = 8 + gf_bs_read_int(bs, 3);
 
 		count = gf_bs_read_int(bs, 8);
 		if (count) {
 			avcc->sequenceParameterSetExtensions = gf_list_new();
 			for (i=0; i<count; i++) {
-				GF_NALUFFParam *sl = (GF_NALUFFParam *)gf_malloc(sizeof(GF_NALUFFParam));
-				sl->size = gf_bs_read_u16(bs);
-				sl->data = (char *)gf_malloc(sizeof(char) * sl->size);
+				GF_NALUFFParam *sl;
+				u32 size = gf_bs_read_int(bs, 16);
+				if ((size>gf_bs_available(bs)) || (size<2)) {
+					GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[AVC] Wrong param set size %d\n", size));
+					gf_odf_avc_cfg_del(avcc);
+					return NULL;
+				}
+				GF_SAFEALLOC(sl, GF_NALUFFParam );
+				if (!sl) {
+					gf_odf_avc_cfg_del(avcc);
+					return NULL;
+				}
+				sl->size = size;
+				sl->data = (char*)gf_malloc(sizeof(char)*sl->size);
+				if (!sl->data) {
+					gf_odf_avc_cfg_del(avcc);
+					return NULL;
+				}
 				gf_bs_read_data(bs, sl->data, sl->size);
 				gf_list_add(avcc->sequenceParameterSetExtensions, sl);
 			}
 		}
 	}
 
 
 	gf_bs_del(bs);
 	return avcc;
 }
@@ -985,87 +1030,87 @@ GF_EXPORT
 GF_HEVCConfig *gf_odf_hevc_cfg_read_bs(GF_BitStream *bs, Bool is_lhvc)
 {
 	u32 i, count;
 	GF_HEVCConfig *cfg = gf_odf_hevc_cfg_new();
 
 	cfg->is_lhvc = is_lhvc;
 
 	cfg->configurationVersion = gf_bs_read_int(bs, 8);
 
 	if (!is_lhvc) {
 		cfg->profile_space = gf_bs_read_int(bs, 2);
 		cfg->tier_flag = gf_bs_read_int(bs, 1);
 		cfg->profile_idc = gf_bs_read_int(bs, 5);
 		cfg->general_profile_compatibility_flags = gf_bs_read_int(bs, 32);
 
 		cfg->progressive_source_flag = gf_bs_read_int(bs, 1);
 		cfg->interlaced_source_flag = gf_bs_read_int(bs, 1);
 		cfg->non_packed_constraint_flag = gf_bs_read_int(bs, 1);
 		cfg->frame_only_constraint_flag = gf_bs_read_int(bs, 1);
 		/*only lowest 44 bits used*/
 		cfg->constraint_indicator_flags = gf_bs_read_long_int(bs, 44);
 		cfg->level_idc = gf_bs_read_int(bs, 8);
 	}
 
 	gf_bs_read_int(bs, 4); //reserved
 	cfg->min_spatial_segmentation_idc = gf_bs_read_int(bs, 12);
 
 	gf_bs_read_int(bs, 6);//reserved
 	cfg->parallelismType = gf_bs_read_int(bs, 2);
 
 	if (!is_lhvc) {
 		gf_bs_read_int(bs, 6);
 		cfg->chromaFormat = gf_bs_read_int(bs, 2);
 		gf_bs_read_int(bs, 5);
 		cfg->luma_bit_depth = gf_bs_read_int(bs, 3) + 8;
 		gf_bs_read_int(bs, 5);
 		cfg->chroma_bit_depth = gf_bs_read_int(bs, 3) + 8;
 		cfg->avgFrameRate = gf_bs_read_int(bs, 16);
 
 		cfg->constantFrameRate = gf_bs_read_int(bs, 2);
 	} else {
 		gf_bs_read_int(bs, 2); //reserved
 	}
 
 	cfg->numTemporalLayers = gf_bs_read_int(bs, 3);
 	cfg->temporalIdNested = gf_bs_read_int(bs, 1);
 
 	cfg->nal_unit_size = 1 + gf_bs_read_int(bs, 2);
 
 	count = gf_bs_read_int(bs, 8);
 	for (i=0; i<count; i++) {
 		u32 nalucount, j;
 		GF_NALUFFParamArray *ar;
 		GF_SAFEALLOC(ar, GF_NALUFFParamArray);
 		if (!ar) {
 			gf_odf_hevc_cfg_del(cfg);
 			return NULL;
 		}
 		ar->nalus = gf_list_new();
 		gf_list_add(cfg->param_array, ar);
 
 		ar->array_completeness = gf_bs_read_int(bs, 1);
 		gf_bs_read_int(bs, 1);
 		ar->type = gf_bs_read_int(bs, 6);
 		nalucount = gf_bs_read_int(bs, 16);
 		for (j=0; j<nalucount; j++) {
 			GF_NALUFFParam *sl;
 			u32 size = gf_bs_read_int(bs, 16);
-			if (size>gf_bs_available(bs)) {
+			if ((size>gf_bs_available(bs)) || (size<2)) {
 				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[HEVC] Wrong param set size %d\n", size));
 				gf_odf_hevc_cfg_del(cfg);
 				return NULL;
 			}
 			GF_SAFEALLOC(sl, GF_NALUFFParam );
 			if (!sl) {
 				gf_odf_hevc_cfg_del(cfg);
 				return NULL;
 			}
 
 			sl->size = size;
 			sl->data = (char *)gf_malloc(sizeof(char) * sl->size);
 			gf_bs_read_data(bs, sl->data, sl->size);
 			gf_list_add(ar->nalus, sl);
 		}
 	}
 	return cfg;
 }
@@ -1232,127 +1277,127 @@ GF_EXPORT
 GF_VVCConfig *gf_odf_vvc_cfg_read_bs(GF_BitStream *bs)
 {
 	u32 i, count;
 	GF_VVCConfig *cfg = gf_odf_vvc_cfg_new();
 
 	gf_bs_read_int(bs, 5);
 	cfg->nal_unit_size = 1 + gf_bs_read_int(bs, 2);
 	cfg->ptl_present = gf_bs_read_int(bs, 1);
 
 	if (cfg->ptl_present) {
 		s32 j;
 
 		cfg->ols_idx = gf_bs_read_int(bs, 9);
 		cfg->numTemporalLayers = gf_bs_read_int(bs, 3);
 		cfg->constantFrameRate = gf_bs_read_int(bs, 2);
 		cfg->chroma_format = gf_bs_read_int(bs, 2);
 		cfg->bit_depth = 8 + gf_bs_read_int(bs, 3);
 		gf_bs_read_int(bs, 5);
 
 		//parse PTL
 		gf_bs_read_int(bs, 2);
 		cfg->num_constraint_info = gf_bs_read_int(bs, 6);
 		cfg->general_profile_idc = gf_bs_read_int(bs, 7);
 		cfg->general_tier_flag = gf_bs_read_int(bs, 1);
 		cfg->general_level_idc = gf_bs_read_u8(bs);
 		cfg->ptl_frame_only_constraint = gf_bs_read_int(bs, 1);
 		cfg->ptl_multilayer_enabled = gf_bs_read_int(bs, 1);
 
 		if (cfg->num_constraint_info) {
 			cfg->general_constraint_info = gf_malloc(sizeof(u8)*cfg->num_constraint_info);
 			if (!cfg->general_constraint_info) {
 				gf_free(cfg);
 				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[VVC] alloc failed while parsing vvc config\n"));
 				return NULL;
 			}
 			gf_bs_read_data(bs, cfg->general_constraint_info, cfg->num_constraint_info - 1);
 			cfg->general_constraint_info[cfg->num_constraint_info-1] =  gf_bs_read_int(bs, 6);
 		} else {
 			//forbidden in spec!
 			gf_bs_read_int(bs, 6);
 		}
 
 		cfg->ptl_sublayer_present_mask = 0;
 		for (j=cfg->numTemporalLayers-2; j>=0; j--) {
 			u32 val = gf_bs_read_int(bs, 1);
 			cfg->ptl_sublayer_present_mask |= val << j;
 		}
 		for (j=cfg->numTemporalLayers; j<=8 && cfg->numTemporalLayers>1; j++) {
 			gf_bs_read_int(bs, 1);
 		}
 		for (j=cfg->numTemporalLayers-2; j>=0; j--) {
 			if (cfg->ptl_sublayer_present_mask & (1<<j)) {
 				cfg->sublayer_level_idc[j] = gf_bs_read_u8(bs);
 			}
 		}
 		cfg->num_sub_profiles = gf_bs_read_u8(bs);
 		if (cfg->num_sub_profiles) {
 			cfg->sub_profiles_idc = gf_malloc(sizeof(u32)*cfg->num_sub_profiles);
 			if (!cfg->sub_profiles_idc) {
 				gf_free(cfg->general_constraint_info);
 				gf_free(cfg);
 				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[VVC] alloc failed while parsing vvc config\n"));
 				return NULL;
 			}
 		}
 		for (i=0; i<cfg->num_sub_profiles; i++) {
 			cfg->sub_profiles_idc[i] = gf_bs_read_u32(bs);
 		}
 
 		//end PTL
 
 		cfg->maxPictureWidth = gf_bs_read_u16(bs);
 		cfg->maxPictureHeight = gf_bs_read_u16(bs);
 		cfg->avgFrameRate = gf_bs_read_u16(bs);
 	}
 
 	count = gf_bs_read_int(bs, 8);
 	for (i=0; i<count; i++) {
 		u32 nalucount, j;
 		GF_NALUFFParamArray *ar;
 		GF_SAFEALLOC(ar, GF_NALUFFParamArray);
 		if (!ar) {
 			gf_odf_vvc_cfg_del(cfg);
 			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[VVC] alloc failed while parsing vvc config\n"));
 			return NULL;
 		}
 		ar->nalus = gf_list_new();
 		gf_list_add(cfg->param_array, ar);
 
 		ar->array_completeness = gf_bs_read_int(bs, 1);
 		gf_bs_read_int(bs, 2);
 		ar->type = gf_bs_read_int(bs, 5);
 
 		if ((ar->type != GF_VVC_NALU_DEC_PARAM) && (ar->type != GF_VVC_NALU_OPI))
 			nalucount = gf_bs_read_int(bs, 16);
 		else
 			nalucount = 1;
 			
 		for (j=0; j<nalucount; j++) {
 			GF_NALUFFParam *sl;
 			u32 size = gf_bs_read_int(bs, 16);
-			if (size>gf_bs_available(bs)) {
+			if ((size>gf_bs_available(bs)) || (size<2)) {
 				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[VVC] Wrong param set size %d\n", size));
 				gf_odf_vvc_cfg_del(cfg);
 				return NULL;
 			}
 			GF_SAFEALLOC(sl, GF_NALUFFParam );
 			if (!sl) {
 				gf_odf_vvc_cfg_del(cfg);
 				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[VVC] alloc failed while parsing vvc config\n"));
 				return NULL;
 			}
 
 			sl->size = size;
 			sl->data = (char *)gf_malloc(sizeof(char) * sl->size);
 			if (!sl->data) {
 				gf_free(sl);
 				gf_odf_vvc_cfg_del(cfg);
 				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[VVC] alloc failed while parsing vvc config\n"));
 				return NULL;
 			}
 			gf_bs_read_data(bs, sl->data, sl->size);
 			gf_list_add(ar->nalus, sl);
 		}
 	}
 	return cfg;
 }
diff --git a/src/utils/bitstream.c b/src/utils/bitstream.c
index dd235db17..6ea644ca1 100644
--- a/src/utils/bitstream.c
+++ b/src/utils/bitstream.c
@@ -38,45 +38,46 @@ enum
 struct __tag_bitstream
 {
 	/*original stream data*/
 	FILE *stream;
 
 	/*or original data*/
 	char *original;
 	/*the size of our buffer in bytes*/
 	u64 size;
 	/*current position in BYTES*/
 	u64 position;
 	/*the byte readen/written*/
 	u32 current;
 	/*the number of bits in the current byte*/
 	u32 nbBits;
 	/*the bitstream mode*/
 	u32 bsmode;
 
 	void (*EndOfStream)(void *par);
 	void *par;
 
 
 	char *cache_write;
 	u32 cache_write_size, buffer_written;
 
 	Bool remove_emul_prevention_byte;
 	u32 nb_zeros;
 
 	GF_Err (*on_block_out)(void *cbk, u8 *data, u32 block_size);
 	void *usr_data;
 	u64 bytes_out;
 	u32 prevent_dispatch;
 
 	u64 cookie;
 
 	u8 *cache_read;
 	u32 cache_read_size, cache_read_pos, cache_read_alloc;
 
 	void (*on_log)(void *udta, const char *field_name, u32 nb_bits, u64 field_val, s32 idx1, s32 idx2, s32 idx3);
 	void *log_udta;
 
 	u32 total_bits_read;
+	u32 overflow_state;
 };
 
 GF_Err gf_bs_reassign_buffer(GF_BitStream *bs, const u8 *buffer, u64 BufferSize)
@@ -350,53 +351,54 @@ static GFINLINE u8 gf_bs_load_byte(GF_BitStream *bs, Bool *is_eos)
 /*fetch a new byte in the bitstream switch between packets*/
 static u8 BS_ReadByte(GF_BitStream *bs)
 {
 	Bool is_eos;
 	if (bs->bsmode == GF_BITSTREAM_READ) {
 		u8 res;
 		if (bs->position >= bs->size) {
 			if (bs->EndOfStream) bs->EndOfStream(bs->par);
+			if (!bs->overflow_state) bs->overflow_state = 1;
 			return 0;
 		}
 		res = bs->original[bs->position++];
 
 		if (bs->remove_emul_prevention_byte) {
 			if ((bs->nb_zeros==2) && (res==0x03) && (bs->position<bs->size) && (bs->original[bs->position]<0x04)) {
 				bs->nb_zeros = 0;
 				res = bs->original[bs->position++];
 			}
 			if (!res) bs->nb_zeros++;
 			else bs->nb_zeros = 0;
 		}
 		return res;
 	}
 	if (bs->cache_write)
 		bs_flush_write_cache(bs);
 
 	is_eos = gf_feof(bs->stream);
 
 	/*we are in FILE mode, test for end of file*/
 	if (!is_eos || bs->cache_read) {
 		u8 res;
 		Bool loc_eos=GF_FALSE;
 		assert(bs->position<=bs->size);
 		bs->position++;
 
 		res = gf_bs_load_byte(bs, &loc_eos);
 		if (loc_eos) goto bs_eof;
 
 		if (bs->remove_emul_prevention_byte) {
 			if ((bs->nb_zeros==2) && (res==0x03) && (bs->position<bs->size)) {
 				u8 next = gf_bs_load_byte(bs, &loc_eos);
 				if (next < 0x04) {
 					bs->nb_zeros = 0;
 					res = next;
 					bs->position++;
 				} else {
 					gf_bs_seek(bs, bs->position);
 				}
 			}
 			if (!res) bs->nb_zeros++;
 			else bs->nb_zeros = 0;
 		}
 		return res;
 	}
@@ -404,13 +406,14 @@ static u8 BS_ReadByte(GF_BitStream *bs)
 bs_eof:
 	if (bs->EndOfStream) {
 		bs->EndOfStream(bs->par);
+		if (!bs->overflow_state) bs->overflow_state = 1;
 	} else {
 		GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, ("[BS] Attempt to overread bitstream\n"));
 	}
 	assert(bs->position <= 1+bs->size);
 	return 0;
 }
 
 #define NO_OPTS
 
 #ifndef NO_OPTS
@@ -608,30 +611,31 @@ GF_EXPORT
 u64 gf_bs_read_long_int(GF_BitStream *bs, u32 nBits)
 {
 	u64 ret = 0;
 	if (nBits>64) {
 		u32 skip = nBits-64;
 		if (gf_bs_available(bs) * 8 < nBits-8) {
 			if (bs->EndOfStream) bs->EndOfStream(bs->par);
 			bs->position = bs->size;
+			if (!bs->overflow_state) bs->overflow_state = 1;
 			return 0;
 		}
 		GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, ("Reading %d bits but max should be 64, skipping %d most significants bits\n", nBits, nBits-64));
 		//avoid recursion
 		while (skip) {
 			if (skip>32) {
 				gf_bs_read_int(bs, 32);
 				skip-=32;
 			} else {
 				gf_bs_read_int(bs, skip);
 				skip=0;
 			}
 		}
 		ret = gf_bs_read_long_int(bs, 64);
 	} else {
 		while (nBits-- > 0) {
 			ret <<= 1;
 			ret |= gf_bs_read_bit(bs);
 		}
 	}
 	return ret;
 }
@@ -1324,28 +1328,29 @@ static GF_Err BS_SeekIntern(GF_BitStream *bs, u64 offset)
 GF_EXPORT
 GF_Err gf_bs_seek(GF_BitStream *bs, u64 offset)
 {
+	bs->overflow_state = 0;
 	if (bs->on_block_out) {
 		GF_Err e;
 		if (offset < bs->bytes_out) {
 			GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, ("[BS] Attempt to seek on byte range already forwarded\n"));
 			return GF_BAD_PARAM;
 		}
 		/*warning: we allow offset = bs->size for WRITE buffers*/
 		if (offset - bs->bytes_out > bs->size)
 			return GF_BAD_PARAM;
 		gf_bs_align(bs);
 		e = BS_SeekIntern(bs, offset - bs->bytes_out);
 		bs->position += bs->bytes_out;
 		return e;
 	}
 	if (bs->cache_write)
 		bs_flush_write_cache(bs);
 
 	/*warning: we allow offset = bs->size for WRITE buffers*/
 	if (offset > bs->size) return GF_BAD_PARAM;
 
 	gf_bs_align(bs);
 	return BS_SeekIntern(bs, offset);
 }
 
 /*peek bits (as int!!) from orig position (ON BYTE BOUNDARIES, from 0) - only for read ...*/
@@ -1706,3 +1711,11 @@ void gf_bs_log_idx(GF_BitStream *bs, u32 nBits, const char *fname, s64 val, s32
 #endif
 
 
+void gf_bs_mark_overflow(GF_BitStream *bs, Bool reset)
+{
+	bs->overflow_state = reset ? 0 : 2;
+}
+u32 gf_bs_is_overflow(GF_BitStream *bs)
+{
+	return bs->overflow_state;
+}
