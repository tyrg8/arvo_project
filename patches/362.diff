commit e9a154e70015e602d695d65a588ecb38f5bb38cc
Author: Werner Lemberg <wl@gnu.org>
Date:   Sat Dec 31 21:41:08 2016 +0100

    [truetype] Check axis count in HVAR table.
    
    Reported as
    
      https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=362
    
    * src/truetype/ttgxvar.c (ft_var_load_hvar): Check axis count.
    (ft_var_load_avar): Fix tracing message.

diff --git a/ChangeLog b/ChangeLog
index 23f574823..df3626970 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,2091 +1,2102 @@
-2016-09-08  Werner Lemberg  <wl@gnu.org>
+2016-12-31  Werner Lemberg  <wl@gnu.org>
+
+	[truetype] Check axis count in HVAR table.
+
+	Reported as
+
+	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=362
+
+	* src/truetype/ttgxvar.c (ft_var_load_hvar): Check axis count.
+	(ft_var_load_avar): Fix tracing message.
+
+2016-12-30  Werner Lemberg  <wl@gnu.org>
 
 	* Version 2.7.1 released.
 	=========================
 
 
 	Tag sources with `VER-2-7-1'.
 
 	* docs/VERSION.TXT: Add entry for version 2.7.1.
 
 	* README, Jamfile (RefDoc), builds/windows/vc2005/freetype.vcproj,
 	builds/windows/vc2005/index.html,
 	builds/windows/vc2008/freetype.vcproj,
 	builds/windows/vc2008/index.html,
 	builds/windows/vc2010/freetype.vcxproj,
 	builds/windows/vc2010/index.html,
 	builds/windows/visualc/freetype.dsp,
 	builds/windows/visualc/freetype.vcproj,
 	builds/windows/visualc/index.html,
 	builds/windows/visualce/freetype.dsp,
 	builds/windows/visualce/freetype.vcproj,
 	builds/windows/visualce/index.html,
 	builds/wince/vc2005-ce/freetype.vcproj,
 	builds/wince/vc2005-ce/index.html,
 	builds/wince/vc2008-ce/freetype.vcproj,
 	builds/wince/vc2008-ce/index.html: s/2.7/2.7.1/, s/27/271/.
 
 	* include/freetype/freetype.h (FREETYPE_PATCH): Set to 1.
 
 	* builds/unix/configure.raw (version_info): Set to 19:0:13.
 	* CMakeLists.txt (VERSION_PATCH): Set to 1.
 
 2016-12-30  Werner Lemberg  <wl@gnu.org>
 
 	[ftfuzzer] Replace `rand' with an xorshift algorithm.
 
 	* src/tools/ftfuzzer/ftfuzzer.cc: Don't include `stdlib.h'.
 	(Random): Implement and use a 32bit `xorshift' algorithm.
 
 2016-12-30  Werner Lemberg  <wl@gnu.org>
 
 	[ftfuzzer] Restrict number of tested bitmap strikes.
 
 	Malformed fonts often have large values for the number of bitmap
 	strikes, and FreeType doesn't check the validity of all bitmap
 	strikes in advance.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=353
 
 	* src/tools/ftfuzzer/ftfuzzer.cc: Include `stdlib.h' for `rand'.
 	(Random): Small class to provide n randomly selected numbers
 	(without repitition) out of the value set [1,N].
 	(LLVMFuzzerTestOneInput): Use it to test only up to 10 bitmap
 	strikes.
 
 2016-12-29  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Variation font API stability issues.
 
 	Make some functions work before a call to `TT_Set_MM_Blend'.
 
 	* src/truetype/ttgxvar.c (tt_hadvance_adjust): Exit immediately if
 	we don't blend.
 	(TT_Get_MM_Blend, TT_Get_Var_Design): Return default values if we
 	don't blend.
 
 2016-12-29  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttgxvar.c (TT_Get_MM_Var): Check axis data.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=348
 
 2016-12-29  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Tracing fixes.
 
 	* src/truetype/ttgxvar.c (tt_hadvance_adjust): Emit correct
 	information.
 	(TT_Set_Var_Design): Fix typo.
 	(TT_Get_Var_Design): Fix typos.
 
 2016-12-29  Werner Lemberg  <wl@gnu.org>
 
 	*/*: Use `0.5f' for tracing 16.16 numbers.
 
 2016-12-29  Werner Lemberg  <wl@gnu.org>
 
 	[pcf] Protect against gzip bombs.
 
 	Fix suggested by Kostya; reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=345
 
 	* src/pcf/pcfread.c (pcf_read_TOC): Limit number of TOC entries to
 	1024.
 
 2016-12-28  Werner Lemberg  <wl@gnu.org>
 
 	[psnames] Only declare, not define, data in `pstables.h' (#49949).
 
 	Pdfium includes `pstables.h' a second time; moving the definition
 	from `pstables.h' to `psmodule.c' saves more than 60kByte data
 	segment space for this case.
 
 	* src/tools/glnames.py (StringTable::dump,
 	StringTable::dump_sublist, dump_encoding, dump_array): Emit
 	additional code to only define tables if `DEFINE_PS_TABLES' is set.
 
 	* src/psnames/pstables.h: Regenerated.
 	* src/psnames/psmodule.c (DEFINE_PS_TABLES): Define.
 
 2016-12-28  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Catch `blend' op in non-variant fonts.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=334
 
 	* src/cff/cf2intrp.c (cf2_interpT2CharString) <cf2_cmdBLEND>: Don't
 	allow `blend' op for non-variant fonts.
 
 2016-12-28  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Better check of number of blends.
 
 	* src/cff/cf2intrp.c (cf2_interpT2CharString) <cf2_cmdBLEND>,
 	src/cff/cffparse.c (cff_parse_blend): Compare number of blends with
 	stack size.
 
 2016-12-27  Werner Lemberg  <wl@gnu.org>
 
 	Documentation updates.
 
 	* docs/CHANGES: Add missing information.
 
 	* docs/formats.txt: Rewritten and updated.
 
 2016-12-27  Werner Lemberg  <wl@gnu.org>
 
 	[truetype, type1] Implement `FT_Get_Var_Design_Coordinates'.
 
 	* src/truetype/ttgxvar.c (TT_Get_Var_Design): Implement.
 	(TT_Set_Var_Design): Fix tracing.
 
 	* src/type1/t1load.c (T1_Get_Var_Design): Implement.
 
 2016-12-24  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttpload.c (tt_face_load_hdmx): Ignore `version'.
 
 	Problem reported by 張俊芝 <418092625@qq.com>.
 
 2016-12-24  Werner Lemberg  <wl@gnu.org>
 
 	* src/sfnt/ttsbit.c (tt_face_load_sbit): Allow more version values.
 
 	Some fonts seem to have the `version' field in the wrong byte order.
 
 	Problem reported by 張俊芝 <418092625@qq.com>.
 
 2016-12-24  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttpload.c (tt_face_load_loca): Sanitize table length.
 
 	This trivial fix allows us to accept more fonts.
 
 	Problem reported by 張俊芝 <418092625@qq.com>.
 
 2016-12-24  Werner Lemberg  <wl@gnu.org>
 
 	* src/sfnt/sfobjs.c (sfnt_init_face): Fix tracing.
 
 2016-12-22  Werner Lemberg  <wl@gnu.org>
 
 	* CMakeLists.txt: Make it work with cmake 2.8.11.2 (#49909).
 
 2016-12-22  Werner Lemberg  <wl@gnu.org>
 
 	Ensure used preprocessor symbols are defined (#49790).
 
 	* builds/unix/ftconfig.in, builds/vms/ftconfig.h,
 	include/freetype/config/ftconfig.h: Check `__GNUC__', `__IBMC__',
 	and `__SUNPRO_C' correctly.
 
 2016-12-22  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftrfork.c (FT_Raccess_Get_DataOffsets): Check `count'.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=308
 
 2016-12-22  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Protect against invalid `vsindex' and `blend' values.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=305
 
 	* src/cff/cf2intrp.c (cf2_interpT2CharString) <cf2_cmdVSINDEX,
 	cf2_cmdBLEND>: Implement it.
 
 2016-12-22  Werner Lemberg  <wl@gnu.org>
 
 	[ftfuzzer] Always use Adobe CFF engine.
 
 	* src/tools/ftfuzzer/ftfuzzer.cc (FT_Global::FT_Global): Implement
 	it.
 
 2016-12-21  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttgxvar.c (TT_Vary_Apply_Glyph_Deltas): Thinko.
 
 	I should really stop coding late in the evening...
 
 	Thanks again to Ben for checking.
 
 2016-12-21  Werner Lemberg  <wl@gnu.org>
 
 	[autofit] Support variation fonts.
 
 	(This ChangeLog entry was added later on.)
 
 	* src/autofit/afglobal.c (af_face_globals_free): Remove useless
 	code.
 
 	* src/base/ftmm.c (FT_Set_MM_Design_Coordinates,
 	* FT_Set_Var_Design_Coordinates, FT_Set_MM_Blend_Coordinates,
 	FT_Set_Var_Blend_Coordinates): Finalize
 	auto-hinter data to enforce recomputation.  Note that this is a
 	brute-force method which should be improved.
 
 2016-12-21  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttgxvar.c (TT_Vary_Apply_Glyph_Deltas): Thinko.
 
 	Don't apply deltas twice for non-phantom points.
 
 	Spotted by Ben Wagner.
 
 2016-12-21  Werner Lemberg  <wl@gnu.org>
 
 	[cff, truetype] Another try for #49829.
 
 	* src/cff/cffdrivr.c: Don't include
 	`FT_SERVICE_METRICS_VARIATIONS_H'.
 	(cff_get_advances): Use `ttface->variation_support'.
 
 	* src/truetype/ttdriver.c (tt_get_advances): Use
 	`ttface->variation_support'.
 
 	* src/truetype/ttgload.c (TT_Process_Simple_Glyph,
 	load_truetype_glyph): Use `ttface->variation_support'.
 
 2016-12-21  Werner Lemberg  <wl@gnu.org>
 
 	[truetype, sfnt] Introduce font variation flags to `TT_Face'.
 
 	* include/freetype/internal/tttypes.h (TT_FACE_FLAG_VAR_XXX):
 	New macros describing available functionality of various OpenType
 	tables related to font variation.
 	(TT_Face): New fields `variation_support' and `mvar_support',
 	replacing and extending `use_fvar'.
 
 	* src/sfnt/sfobjs.c (sfnt_init_face, sfnt_load_face): Use
 	`variation_support'.
 
 	* src/truetype/ttgxvar.c (ft_var_load_hvar): Set `variation_support'
 	field.
 	(TT_Vary_Apply_Glyph_Deltas): Updated.
 
 2016-12-21  Werner Lemberg  <wl@gnu.org>
 
 	[base] Improve sanity check for Mac resources (#49888).
 
 	* src/base/ftobjs.c (Mac_Read_sfnt_Resource): Abort if `rlen' is not
 	positive.
 
 2016-12-20  Werner Lemberg  <wl@gnu.org>
 
 	[base] More sanity checks for Mac resources.
 
 	We use
 
 	  https://github.com/kreativekorp/ksfl/wiki/Macintosh-Resource-File-Format
 
 	and
 
 	  https://developer.apple.com/legacy/library/documentation/mac/pdf/MoreMacintoshToolbox.pdf#page=151
 
 	as references.
 
 	* include/freetype/internal/ftrfork.h (FT_RFork_Ref): Use FT_Short
 	for `res_id'.
 
 	* src/base/ftrfork.c (FT_Raccess_Get_HeaderInfo): Extract map length
 	and use it to improve sanity checks.
 	Follow the specification more closely;in particular, all data types
 	are signed, not unsigned.
 	(FT_Raccess_Get_DataOffsets): Follow the specification more closely;
 	in particular, all data types are signed, not unsigned.
 	Add some sanity checks.
 
 2016-12-20  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Improve logic for getting fast advance widths.
 
 	* src/cff/cffdrivr.c (cff_get_advances), src/truetype/ttdriver.c
 	(tt_get_advances): Use `is_default_instance' for test; this gets
 	recomputed after changing blend coordinates.
 
 2016-12-20  Ben Wagner  <bungeman@google.com>
 	    Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Fix linear metrics of GX variation fonts (#49829).
 
 	When asking for an unhinted non-default variations,
 	`linearVertAdvance' is currently the value from the `hmtx' table
 	instead of the actual value after applying the variation.  `HVAR'
 	support fixes this, but fonts will exist without that table and will
 	need sane fallback.
 
 	Problem also reported as
 
 	  https://bugs.chromium.org/p/skia/issues/detail?id=5917
 
 	* src/truetype/ttgload.c (TT_Process_Simple_Glyph,
 	load_truetype_glyph): Implement linear advance adjustments if `HVAR'
 	or `VVAR' tables are missing.
 
 2016-12-20  Werner Lemberg  <wl@gnu.org>
 
 	[cff, truetype] Fast advance width retrieval for fonts with HVAR.
 
 	Everything is guarded with TT_CONFIG_OPTION_GX_VAR_SUPPORT.
 
 	* src/base/ftadvanc.c (LOAD_ADVANCE_FAST_CHECK): Don't handle MM.
 
 	* src/cff/cffdrivr.c: Include FT_SERVICE_METRICS_VARIATIONS_H.
 	(cff_get_advances): Test for HVAR and VVAR.
 
 	* src/truetype/ttdriver.c (tt_get_advances): Test for HVAR and VVAR.
 
 2016-12-18  Werner Lemberg  <wl@gnu.org>
 
 	[base] Fix invalid mac font recursion.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=304
 
 	* src/base/ftobjs.c (FT_Open_Face): Code moved to...
 	(ft_open_face_internal): ... this function.
 	Add a parameter to control whether we try special Mac font handling
 	in case of failure.
 	(FT_Open_Face, FT_New_Face, FT_New_Memory_Face,
 	open_face_from_buffer): Use `ft_open_face_internal'.
 
 2016-12-18  Werner Lemberg  <wl@gnu.org>
 
 	* src/cff/cffobjs.c (cff_face_init): Make named instances work.
 
 2016-12-18  Werner Lemberg  <wl@gnu.org>
 
 	[truetype, cff] Extend `get_var_blend' function of MM service.
 
 	In particular, we need access to named instance data.
 
 	* include/freetype/internal/services/svmm.h (FT_Get_Var_Blend_Func):
 	Add argument for `FT_MM_Var'.
 
 	* src/cff/cffload.c (cff_get_var_blend): Updated.
 	* src/cff/cffload.h: Updated.
 
 	* src/cff/cf2ft.c (cf2_getNormalizedVector): Updated.
 
 	* src/truetype/ttgxvar.c (tt_get_var_blend): Updated.
 	Accept value `NULL' for arguments.
 	* src/truetype/ttgxvar.h: Updated.
 
 2016-12-18  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Handle `fvar' with zero axes as a non-MM font.
 
 	This is better behaviour than exiting with an error.
 
 	* include/freetype/internal/tttypes.h (TT_Face): Add `use_fvar'
 	field.
 
 	* src/sfnt/sfobjs.c (sfnt_init_face): Compute `use_fvar', also
 	updating the validation code.
 	Use `use_fvar' to compute FT_FACE_FLAG_MULTIPLE_MASTERS.
 
 	* src/truetype/ttgxvar.c (TT_Get_MM_Var): Remove `fvar' validation
 	code.
 
 2016-12-18  Werner Lemberg  <wl@gnu.org>
 
 	Minor GX code shuffling.
 
 	* include/freetype/internal/tttypes.h (TT_Face): Move
 	`is_default_instance' into TT_CONFIG_OPTION_GX_VAR_SUPPORT
 	block.
 
 	* src/sfnt/sfobjs.c (sfnt_init_face): Updated.
 	* src/truetype/ttgload.c (IS_DEFAULT_INSTANCE): New macro.
 	(TT_Load_Glyph): Use it.
 
 2016-12-18  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Better handling of non-CFF font formats.
 
 	* src/cff/cffload.c (cff_font_load): Pure CFFs don't have a
 	signature, so return `FT_Err_Unknown_File_Format' more often.
 
 2016-12-17  Werner Lemberg  <wl@gnu.org>
 
 	* src/cff/cffload.c (cff_build_blend_vector): Remove redundant code.
 
 2016-12-17  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttobjs.c (tt_face_init): Simplify conditional code.
 
 2016-12-17  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt, truetype] Various sanitizing fixes.
 
 	* src/sfnt/sfobjs.c (sfnt_init_face): If the axis count in `fvar' is
 	zero, set `num_instances' to zero.
 
 	* src/truetype/ttgxvar.c (TT_Get_MM_Var): Handle `fvar' table with
 	zero axes as invalid.
 
 	* src/truetype/ttobjs.c (tt_face_init): Improve logic of loading
 	`loca', `cvt', `fpgm', and `prep' table.
 
 2016-12-17  Werner Lemberg  <wl@gnu.org>
 
 	Improve tracing of `FT_Open_Face'.
 
 	* src/base/ftobjs.c (FT_Open_Face): Return info on number of
 	available faces and numbered instances, or the indices of the
 	requested face and numbered instance.
 
 	* src/sfnt/sfobjs. (sfnt_open_font): Trace number of subfonts.
 
 2016-12-17  Werner Lemberg  <wl@gnu.org>
 
 	* src/cff/cffload.c (cff_load_private_dict): Always init `blend'.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=295
 
 2016-12-16  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Fix `cvar' sanity test.
 
 	Reported by Dave Arnold.
 
 	* src/truetype/ttgxvar.c (tt_face_vary_cvt): Use tuple count mask.
 
 2016-12-16  Werner Lemberg  <wl@gnu.org>
 
 	[cff, truetype] Remove compiler warnings; fix `make multi'.
 
 	* src/cff/cf2font.h: Include `cffload.h'.
 
 	* src/cff/cffload.c: Include FT_MULTIPLE_MASTERS_H and
 	FT_SERVICE_MULTIPLE_MASTERS_H.
 	(cff_vstore_load): Eliminate `vsSize'.
 	(cff_load_private_dict): Tag as `FT_LOCAL_DEF'.
 
 	* src/cff/cffload.h: Include `cffobjs.h'.
 	Provide declaration for `cff_load_private_dict'.
 
 	* src/truetype/ttgxvar.c (ft_var_load_hvar): Eliminate
 	`minorVersion' and `map_offset'.
 
 2016-12-16  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Fix heap buffer overflow (#49858).
 
 	* src/cff/cffparse.c (cff_parser_run): Add one more stack size
 	check.
 
 2016-12-15  Werner Lemberg  <wl@gnu.org>
 
 	Fix clang warnings.
 
 	* src/cff/cffload.c (cff_blend_doBlend): Add cast.
 	(cff_subfont_load): Set `error' correctly.
 
 	* src/sfnt/ttmtx.c (tt_face_get_metrics): Typo.
 
 2016-12-15  Dave Arnold  <darnold@adobe.com>
 	    Werner Lemberg  <wl@gnu.org>
 
 	[cff] Implement CFF2 support (2/2).
 
 	The font variation code.  All parts dependent on the GX code in the
 	`truetype' module are guarded with TT_CONFIG_OPTION_GX_VAR_SUPPORT. 
 	In other words, you can still compile the `cff' module without
 	defining TT_CONFIG_OPTION_GX_VAR_SUPPORT (which brings you CFF2
 	support without font variation).
 
 	* src/cff/cf2font.c (cf2_font_setup): Add support for font
 	variation.
 	* src/cff/cf2font.h (CF2_Font): Add fields for variation data.
 
 	* src/cff/cf2ft.c (cf2_free_instance): Free blend data.
 	(cf2_getVStore, cf2_getNormalizedVector): New functions.
 	* src/cff/cf2ft.h: Updated.
 
 	* src/cff/cf2intrp.c: Include `cffload.h'.
 	(cf2_cmdRESERVED_15, cf2_cmdRESERVED_16): Replace with...
 	(cf2_cmdVSINDEX, cf2_cmdBLEND): ... this new enum values.
 	(cf2_doBlend): New function.
 	(cf2_interpT2CharString): Handle `vsindex' and `blend' opcodes.
 
 	* src/cff/cffload.c (FT_fdot14ToFixed): New macro.
 	(cff_vstore_done, cff_vstore_load): New functions.
 	(cff_blend_clear, cff_blend_doBlend, cff_blend_build_vector,
 	cff_blend_check_vector): New functions.
 	(cff_load_private_dict): Add arguments for blend vector.
 	Handle blend data.
 	(cff_subfont_load, cff_subfont_done): Updated.
 	(cff_font_load): Handle CFF2 variation store data.
 	(cff_font_done): Updated.
 	* src/cff/cffload.h: Include `cffparse.h'.
 	Updated.
 
 	* src/cff/cffobjs.c (cff_face_done): Updated.
 
 	* src/cff/cffparse.c: Include `cffload.h'.
 	(cff_parse_num): Handle internal value 255.
 	(cff_parse_vsindex, cff_parse_blend): New functions.
 	(CFF_FIELD_BLEND): New macro.
 	(cff_parser_run): Updated.
 	* src/cff/cffparse.h (cff_kind_blend): New enum value.
 
 	* src/cff/cfftoken.h: Handle `vstore', `vsindex', and `blend'
 	dictionary values.
 
 	* src/cff/cfftypes.h (CFF_VarData, CFF_AxisCoords, CFF_VarRegion,
 	CFF_VStore, CFF_Blend): New structures.
 	(CFF_FontRecDict): Add `vstore_offset' field.
 	(CFF_Private): Add `vsindex' field.
 	(CFF_SubFont): Add fields for blend data.
 	(CFF_Font): Add `vstore' field.
 
 	* src/truetype/ttgxvar.c (TT_Get_MM_Var): `CFF2' is equal to `gvar',
 	since glyph variation data is directly embedded.
 	(TT_Set_MM_Blend): Don't load `gvar' table for CFF2 fonts.
 
 2016-12-15  Dave Arnold  <darnold@adobe.com>
 	    Werner Lemberg  <wl@gnu.org>
 
 	[cff] Implement CFF2 support (1/2).
 
 	This commit does not contain the blend code for font variation
 	support, which follows in another commit.
 
 	You should ignore whitespace while inspecting this commit.
 
 	* include/freetype/internal/tttypes.h (TT_Face): Add `isCFF2'
 	member.
 
 	* src/cff/cf2font.h (CF2_Font): Add `isCFF2' member.
 
 	* src/cff/cf2ft.c (cf2_decoder_parse_charstrings): Handle `isCFF2'
 	flag.
 	(cf2_getMaxstack): New function.
 	* src/cff/cf2ft.h: Updated.
 
 	* src/cff/cf2intrp.c (cf2_escRESERVED_38): New enum.
 	(cf2_interpT2CharString): Handle CFF2 differences.
 	Add tracing message for errors.
 
 	* src/cff/cffdrivr.c (cff_get_glyph_name, cff_get_name_index):
 	Update for CFF2.
 
 	* src/cff/cffload.c (FT_FIXED_ONE): New macro.
 	(cff_index_init, cff_index_load_offsets, cff_index_access_element,
 	cff_index_get_name, cff_ft_select_get, cff_load_private_dict,
 	cff_subfont_load, cff_font_load): Handle CFF2.
 	* src/cff/cffload.h: Updated.
 
 	* src/cff/cffobjs.c (cff_face_init): Handle CFF2.
 
 	* src/cff/cffparse.c (cff_parse_maxstack): New function.
 	(CFFCODE_TOPDICT, CFFCODE_PRIVATE): Removed
 	* src/cff/cffparse.h (CFF2_MAX_STACK, CFF2_DEFAULT_STACK): New
 	macros.
 	(CFF2_CODE_TOPDICT, CFF2_CODE_FONTDICT, CFF2_CODE_PRIVATE): New
 	macros.
 
 	* src/cff/cfftoken.h: Add fields for CFF2 dictionaries (but no blend
 	stuff).
 
 	* src/cff/cfftypes.h (CFF_Index): Add `hdr_size' field.
 	(CFF_FontRecDict): Add `maxstack' field.
 	(CFF_Private): Add `subfont' field.
 	(CFF_Font): Add `top_dict_length' and `cff2' fields.
 
 	* src/sfnt/sfobjs.c (sfnt_load_face): Handle `CFF2' table.
 
 2016-12-15  Werner Lemberg  <wl@gnu.org>
 	    Dave Arnold  <darnold@adobe.com>
 
 	[truetype] Provide HVAR advance width variation as a service.
 
 	Everything is guarded with TT_CONFIG_OPTION_GX_VAR_SUPPORT.
 
 	* src/truetype/ttdriver.c (tt_service_metrics_variations): Updated.
 
 	* src/truetype/ttgxvar.c (TT_Vary_Apply_Glyph_Deltas): Prevent
 	double adjustment of advance width.
 
 	* src/sfnt/ttmtx.c: Include FT_SERVICE_METRICS_VARIATIONS_H.
 	(tt_face_get_metrics): Apply metrics variations.
 
 2016-12-15  Dave Arnold  <darnold@adobe.com>
 	    Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Provide function to apply `HVAR' advance width variation.
 
 	Everything is guarded with TT_CONFIG_OPTION_GX_VAR_SUPPORT.
 
 	* src/truetype/ttgxvar.c (tt_hadvance_adjust): New function.
 	* src/truetype/ttgxvar.h: Updated.
 
 2016-12-15  Dave Arnold  <darnold@adobe.com>
 	    Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Add `HVAR' table parsing.
 
 	Note that this is not complete yet; it only handles advance width
 	variation.
 
 	Activation of the code follows in another commit.
 
 	Everything is guarded with TT_CONFIG_OPTION_GX_VAR_SUPPORT.
 
 	* include/freetype/ftmm.h (FT_Var_Named_Style): Add `psid' member.
 
 	* src/truetype/ttgxvar.h (GX_HVarData, GX_AxisCoords, GX_HVarRegion,
 	GX_HVStore, GX_WidthMap): New auxiliary structures for...
 	(GX_HVarTable): ... HVAR main structure.
 	(GX_BlendRec): Add data for HVAR loading.
 
 	* src/truetype/ttgxvar.c (FT_FIXED_ONE, FT_fdot14ToFixed,
 	FT_intToFixed, FT_fixedToInt): New macros.
 	(ft_var_load_hvar): New function.
 	(TT_Get_MM_Var): Updated.
 	(tt_done_blend): Deallocate HVAR data.
 
 2016-12-15  Dave Arnold  <darnold@adobe.com>
 
 	[cff] Extend number parsing.
 
 	The forthcoming CFF2 support needs a dynamic parsing limit.
 
 	* src/cff/cffparse.c (cff_parse_num, do_fixed, cff_parse_fixed,
 	cff_parse_fixed_scaled, cff_parse_fixed_dynamic): Add argument for
 	parser.
 	(cff_parse_font_matrix, cff_parse_font_bbox, cff_parse_private_dict,
 	cff_parse_multiple_master, cff_parse_cid_ros, cff_parser_run): Updated.
 
 	* src/cff/cffparse.h (cff_parse_num): Export locally.
 
 2016-12-15  Dave Arnold  <darnold@adobe.com>
 
 	[cff] Implement dynamic stack size for Adobe engine.
 
 	This also adds `cf2_stack_setReal' and `cf2_stack_pop', needed for
 	the forthcoming CFF2 support.
 
 	* src/cff/cf2stack.c (cf2_stack_init): Add argument for stack size.
 	(cf2_stack_free): Deallocate stack.
 	(cf2_stack_count, cf2_stack_pushInt, cf2_stack_pushFixed,
 	cf2_stack_popInt, cf2_stack_popFixed, cf2_stack_getReal,
 	cf2_stack_clear): Updated.
 	(cf2_stack_setReal, cf2_stack_pop): New functions.
 
 	* src/cff/cf2stack.h (CF2_Stack): Add `stackSize' member.
 	Update function declarations.
 
 	* src/cff/cf2intrp.c (cf2_interpT2CharString): Updated.
 
 	* src/cff/cffparse.c (cff_parser_init): Add parameter for stack
 	size; return error code.
 	(cff_parser_done): New function.
 	(cff_parser_run): Updated.
 
 	* src/cff/cffparse.h (CFF_Parser): Add `stackSize' member and make
 	`stack' a pointer.
 	Update function declarations.
 
 	* src/cff/cffload.c (cff_load_private_dict, cff_subfont_load):
 	Updated.
 
 2016-12-15  Dave Arnold  <darnold@adobe.com>
 	    Werner Lemberg  <wl@gnu.org>
 
 	[cff] Code shuffling.
 
 	* src/cff/cfftypes.h (CFF_Font): Add `library' and `base_offset'
 	fields.
 
 	* src/cff/cffload.c (cff_subfont_load): Change last argument to
 	`CFF_Font'
 	Split off parsing of private dictionary into...
 	(cff_load_private_dict): ...this new function.
 	(cff_font_load): Updated.
 
 2016-12-14  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt, truetype] Add framework for Metrics Variations service.
 
 	No effect yet; service functions will be implemented later on.
 
 	Everything is guarded with TT_CONFIG_OPTION_GX_VAR_SUPPORT.
 
 	* include/freetype/internal/services/svmetric.h: New file.
 
 	* include/freetype/internal/ftserv.h
 	(FT_SERVICE_METRICS_VARIATIONS_H): New macro.
 
 	* include/freetype/internal/tttypes.h (TT_Face): New field `var'.
 
 	* src/sfnt/sfobjs.c: Include FT_SERVICE_METRICS_VARIATIONS_H.
 	(sfnt_init_face): Initialize `face->var'.
 
 	* src/truetype/ttdriver.c: Include FT_SERVICE_METRICS_VARIATIONS_H.
 	(tt_service_metrics_variations): New service.
 	(tt_services): Updated.
 
 	* src/truetype/ttpic.h: Updated.
 
 2016-12-14  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Add Multiple Masters service.
 
 	The code simply uses the MM functions from the `truetype' module.
 
 	Everything is guarded with TT_CONFIG_OPTION_GX_VAR_SUPPORT.
 
 	* include/freetype/internal/tttypes.h (TT_Face): New field `mm'.
 
 	* src/cff/cffdrivr.c: Include FT_SERVICE_MULTIPLE_MASTERS_H.
 	(cff_set_mm_blend, cff_get_mm_blend, cff_get_mm_var,
 	cff_set_var_design, cff_get_var_design): New functions.
 	(cff_service_multi_masters): New service.
 	(cff_services): Updated.
 
 	* src/cff/cffload.c (cff_get_var_blend, cff_done_blend): New
 	functions.
 	* src/cff/cffload.h: Updated.
 
 	* src/cff/cffpic.h (CFF_SERVICE_MULTI_MASTERS_GET): New macro.
 
 	* src/sfnt/sfobjs.c: Include FT_SERVICE_MULTIPLE_MASTERS_H.
 	(sfnt_init_face): Initialize `face->mm'.
 
 2016-12-14  Werner Lemberg  <wl@gnu.org>
 
 	Extend functionality of `ft_module_get_service'.
 
 	It can now differentiate between local and global searches.
 
 	* src/base/ftobjs.c (ft_module_get_service): Add `global' argument.
 	(FT_Get_TrueType_Engine_Type): Updated.
 
 	* src/cff/cffdrivr.c (cff_get_ps_name, cff_get_cmap_info): Updated.
 
 	* include/freetype/internal/ftobjs.h: Updated.
 	* include/freetype/internal/ftserv.h (FT_FACE_FIND_GLOBAL_SERVICE):
 	Updated.
 
 2016-12-14  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttgxvar.c (tt_get_var_blend): Fix compiler warning.
 
 2016-12-14  Dave Arnold  <darnold@adobe.com>
 	    Werner Lemberg  <wl@gnu.org>
 
 	[sfnt, cff] Minor preparations.
 
 	* include/freetype/tttags.h (TTAG_CFF2, TTAG_HVAR, TTAG_MVAR,
 	TTAG_VVAR): New SFNT table tags.
 
 	* src/cff/cf2fixed.h (CF2_FIXED_ONE, CF2_FIXED_EPSILON): Add cast.
 
 2016-12-10  Werner Lemberg  <wl@gnu.org>
 
 	[truetype, type1] Add `get_var_blend' to MM service.
 
 	For internal use; we want to share code between the forthcoming CFF2
 	support and TrueType.
 
 	* include/freetype/internal/services/svmm.h (FT_Get_Var_Blend_Func):
 	New typedef.
 	(MultiMasters): Add `get_var_blend'.
 	(FT_Service_MultiMasters): Updated.
 
 	* src/truetype/ttgxvar.c (tt_get_var_blend): New function.
 	* src/truetype/ttgxvar.h: Updated.
 
 	* src/truetype/ttdriver.c (tt_service_gx_multi_masters): Updated.
 	* src/type1/t1driver.c (t1_service_multi_masters): Updated.
 
 2016-12-10  Werner Lemberg  <wl@gnu.org>
 
 	[truetype, type1] Add `done_blend' to MM service.
 
 	For internal use; we want to share code between the forthcoming CFF2
 	support and TrueType.
 
 	* include/freetype/internal/services/svmm.h (FT_Done_Blend_Func):
 	New typedef.
 	(MultiMasters): Add `done_blend'.
 	(FT_Service_MultiMasters): Updated.
 
 	* src/truetype/ttgxvar.c (tt_done_blend): Use `TT_Face' as argument.
 	* src/truetype/ttgxvar.h: Updated.
 
 	* src/truetype/ttobjs.c (TT_Face_Done): Updated.
 
 	* src/truetype/ttdriver.c (tt_service_gx_multi_masters): Updated.
 	* src/type1/t1driver.c (t1_service_multi_masters): Updated.
 
 2016-12-09  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Revert change from 2016-12-08.
 
 	I missed the functionality of `ft_module_get_service', which makes
 	the change unnecessary.
 
 2016-12-08  Werner Lemberg  <wl@gnu.org>
 
 	Add framework to support services with 8 functions.
 
 	We will need this for CFF variation font support.
 
 	* include/freetype/internal/ftserv.h (FT_DEFINE_SERVICEDESCREC8):
 	New macro.
 
 2016-12-08  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Add `get_glyph_name' and `get_name_index' to SFNT interface.
 
 	CFF2 fonts will need access to those two functions.
 
 	* include/freetype/internal/sfnt.h: Include FT_SERVICE_GLYPH_DICT_H.
 	(SFNT_Interface): Add `get_glyph_name' and `get_name_index' members.
 	(FT_DEFINE_SFNT_INTERFACE): Updated.
 
 	* src/sfnt/sfdriver.c (sfnt_get_glyph_name, sfnt_get_name_index):
 	Fix signatures to exactly correspond to the glyph dict service
 	function typedefs.
 	(sfnt_interface): Updated.
 
 2016-12-06  Dave Arnold  <darnold@adobe.com>
 
 	Add `FT_Get_Var_Design_Coordinates' function.
 
 	Note that the low-level functions aren't implemented yet.
 
 	* include/freetype/ftmm.h: Declare.
 
 	* include/freetype/internal/services/svmm.h
 	(FT_Get_Var_Design_Func): New typedef.
 	(MultiMasters): New MM service function `get_var_design'.
 	(FT_DEFINE_SERVICE_MULTIMASTERSREC): Updated.
 	Update all callers.
 
 	* src/base/ftmm.c (FT_Get_Var_Design_Coordinates): Implement.
 
 	* src/truetype/ttdriver.c: Updated.
 
 	* src/truetype/ttgxvar.c (TT_Get_Var_Design): New dummy function to
 	handle `get_var_design' service.
 	* src/truetype/ttgxvar.h: Updated.
 
 	* src/type1/t1driver.c: Updated.
 
 	* src/type1/t1load.c (T1_Get_Var_Design): New dummp function to
 	handle `get_var_design' service.
 	* src/type1/t1load.h: Updated.
 
 2016-12-06  Werner Lemberg  <wl@gnu.org>
 
 	* src/type1/t1load.c (parse_subrs): Fix memory leak.
 
 	The `subrs' keyword might erroneously occur multiple times.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=231
 
 2016-12-01  Werner Lemberg  <wl@gnu.org>
 
 	[gzip] Improve building with external zlib (#49673).
 
 	Building FreeType with external zlib 1.2.8 makes msvc 14 stop with
 	the following error.
 
 	  ftgzip.c
 	  zlib-1.2.8\zlib.h(86): error C2061:
 	                         syntax error: identifier 'z_const'
 	  zlib-1.2.8\zlib.h(94): error C2054:
 	                         expected '(' to follow 'z_const'
 	  zlib-1.2.8\zlib.h(94): error C2085:
 	                         'msg': not in formal parameter list
 	  ...
 	  zlib-1.2.8\zlib.h(877): fatal error C1003:
 	                          error count exceeds 100; stopping compilation
 
 	The error happens because FreeType keeps an own copy of zlib-1.1.4
 	under `src/gzip'.  When building `src/gzip/ftgzip.c' with
 	FT_CONFIG_OPTION_SYSTEM_ZLIB defined, it uses
 
 	  #include <zlib.h>
 
 	which correctly finds an external `zlib.h', but `zlib.h' itself has
 	a line
 
 	  #include "zconf.h"
 
 	which makes Visual Studio 2015 find `src/gzip/zconf.h' while
 	compiling the files in `src/gzip'.
 
 	* src/gzip/zconf.h: Rename to...
 	* src/gzip/ftzconf.h: ... this.
 	* src/gzip/zlib.h, src/gzip/rules.mk (GZIP_DRV_SRCS): Updated.
 
 2016-12-01  Oleksandr Chekhovskyi  <oleksandr.chekhovskyi@gmail.com>
 
 	[autofit] Fix Emscripten crash (patch #9180).
 
 	Function calls through pointers must use a matching signature to
 	work on Emscripten, since such calls are dispatched through lookup
 	tables grouped by signature.
 
 	* src/autofit/aftypes.h (AF_WritingSystem_ApplyHintsFunc): Fix
 	typedef.
 
 2016-11-29  Werner Lemberg  <wl@gnu.org>
 
 	[smooth] Revert previous commit.  Already fixed with 6ca54c64.
 
 2016-11-29  Werner Lemberg  <wl@gnu.org>
 
 	[smooth] Avoid conditional jump on uninitialized value (#49711).
 
 	* src/smooth/ftgrays.c (gray_raster_render): Initialize `worker'.
 
 2016-11-27  Nikolaus Waxweiler  <madigens@gmail.com>
 
 	[autofit] Code shuffling.
 
 	Also improve some comments and remove unused code.
 
 	No functional change.
 
 	* src/autofit/afloader.c (af_loader_load_g): Merged with...
 	(af_loader_load_glyph): ...this function.
 	Split off emboldening code into...
 	(af_loader_embolden_glyph_in_slot): ... this function.
 
 2016-11-17  Werner Lemberg  <wl@gnu.org>
 
 	Better support of LLP64 systems with gcc (and clang).
 
 	* builds/unix/configure.raw: Call `AC_TYPE_LONG_LONG_INT'.
 
 	* builds/unix/ftconfig.in (FT_LONG64): Enable for LLP64 systems (and
 	suppress warnings) even without `FT_CONFIG_OPTION_FORCE_INT64'.
 
 2016-11-10  Werner Lemberg  <wl@gnu.org>
 
 	Fix `lcd_weights' array size.
 
 	* include/freetype/internal/ftobjs.h (FT_LibraryRec): Do it.
 
 	Reported by Nikolaus.
 
 2016-11-06  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftobjs.c (FT_Render_Glyph_Internal): Fix tracing.
 
 2016-11-06  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Improve FT_LOAD_BITMAP_METRICS_ONLY for `sbix' format.
 
 	It's unavoidable to call the PNG engine, but to get the metrics it
 	is sufficient to read the PNG image's header only.
 
 	* src/sfnt/pngshim.c (Load_SBit_Png): Add argument to control the
 	allocation of the glyph slot.
 	* src/sfnt/pngshim.h: Updated.
 	* src/sfnt/ttsbit.c (tt_sbit_decoder_load_png,
 	tt_face_load_sbix_image, tt_face_load_sbit_image): Updated.
 
 2016-11-06  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Speed up `sbix' lookup.
 
 	This also fixes a bug introduced in 2016-10-01 which prevents
 	display of embedded bitmap fonts that use the `sbix' format.
 
 	* src/sfnt/ttsbit.c (tt_face_load_sbit): Store `sbix' size and
 	offset also in `ebdt_size' and `ebdt_start', respectively.  This
 	makes the test for an embedded bitmap data table succeed for this
 	format.
 
 	(tt_face_load_strike_metrics) <TT_SBIT_TABLE_TYPE_SBIX>: Use
 	`ebdt_size' and `ebdt_start'
 	(tt_face_load_sbix_image): Ditto.
 
 2016-11-06  Seigo Nonaka  <nona@google.com>
 	    Werner Lemberg  <wl@gnu.org>
 
 	Introduce a way of quickly retrieving (embedded) bitmap metrics.
 
 	`FT_Load_Glyph' doesn't generate a bitmap for a non-bitmap glyph
 	until the user calls `FT_Render_Glyph'.  However, it always
 	allocates memory for bitmaps and copies or decodes the contents of a
 	bitmap glyph, which can be quite slow for PNG data.
 
 	* include/freetype/freetype.h (FT_LOAD_BITMAP_METRICS_ONLY): New
 	macro.
 
 	* src/base/ftobjs.c (FT_Load_Glyph): Unset FT_LOAD_RENDER if
 	FT_LOAD_BITMAP_METRICS_ONLY is used.
 
 	* src/sfnt/ttsbit.c (tt_sbit_decoder_alloc_bitmap,
 	tt_sbit_decoder_load_bitmap): Add argument to control allocation of
 	the glyph slot.
 	(tt_sbit_decoder_load_image, tt_sbit_decoder_load_compound,
 	tt_face_load_sbit_image): Updated.
 
 	* src/pcf/pcfdrivr.c (PCF_Glyph_Load): Quickly exit if
 	`FT_LOAD_BITMAP_METRICS_ONLY' is set.
 
 	* src/pfr/pfrsbit.c, src/pfr/pfrsbit.h (pfr_slot_load_bitmap): Add
 	argument to control allocation of the glyph slot.
 	* src/pfr/pfrobjs (pfr_slot_load): Updated.
 
 	* src/winfonts/winfnt.c (FNT_Load_Glyph): Ditto.
 
 	* docs/CHANGES: Updated.
 
 2016-11-06  Werner Lemberg  <wl@gnu.org>
 
 	Synchronize with gnulib (#49448).
 
 	* include/freetype/config/ftconfig.h, builds/unix/ftconfig.in,
 	builds/vms/ftconfig.h (FT_TYPEOF): Update code to use definition in
 	current version of `intprops.h'.
 	Other minor synchronization to reduce code differences between the
 	three files.
 
 2016-11-03  Behdad Esfahbod  <behdad@behdad.org>
 
 	[truetype] Clamp variation requests to valid range.
 
 	This is required by OpenType 1.8; it also avoids rounding surprises.
 
 	* src/truetype/ttgxvar.c (TT_Set_Var_Design): Clamp design coordinates
 	outside of the allowed range to always stay within the range instead
 	of producing an error.
 
 2016-10-29  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Remove clang warnings.
 
 	* src/truetype/ttinterp.h (TT_ExecContextRec): Using `FT_ULong' for
 	loop counter handling.
 
 	* src/truetype/ttinterp.c: Updated.
 	(Ins_SCANTYPE): Use signed constant.
 	(TT_RunIns): Ensure `num_twilight_points' is 16bit.
 
 2016-10-27  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Fix commit from 2014-11-24.
 
 	Problem reported by Hin-Tak Leung  <htl10@users.sourceforge.net>.
 
 	* src/truetype/ttpload.c (tt_face_load_hdmx): Fix file checking
 	logic.
 
 2016-10-26  Werner Lemberg  <wl@gnu.org>
 
 	Add `FT_Get_{MM,Var}_Blend_Coordinates' functions.
 
 	* include/freetype/ftmm.h: Declare.
 
 	* include/freetype/internal/services/svmm.h (FT_Get_MM_Blend_Func):
 	New typedef.
 	(MultiMasters): New MM service function `get_mm_blend'.
 	(FT_DEFINE_SERVICE_MULTIMASTERSREC): Updated.
 	Update all callers.
 
 	* src/base/ftmm.c (FT_Get_MM_Blend_Coordinates,
 	FT_Get_Var_Blend_Coordinates): Implement.
 
 	* src/truetype/ttdriver.c: Updated.
 
 	* src/truetype/ttgxvar.c (TT_Get_MM_Blend): New function to handle
 	`get_mm_blend' service.
 	* src/truetype/ttgxvar.h: Updated.
 
 	* src/type1/t1driver.c: Updated.
 
 	* src/type1/t1load.c (T1_Get_MM_Blend): New function to handle
 	`get_mm_blend' service.
 	* src/type1/t1load.h: Updated.
 
 	* docs/CHANGES: Document.
 
 2016-10-26  Werner Lemberg  <wl@gnu.org>
 
 	* src/type1/t1load.c (parse_subrs): Fix limit check.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=81
 
 2016-10-25  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[cff] Correct cmap format reporting (#24819).
 
 	* src/cff/cffdrivr.c (cff_get_cmap_info): Throw an error on synthetic
 	charmap instead of guessing its format and language.
 
 2016-10-22  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Fix SCANTYPE instruction (#49394).
 
 	* src/truetype/ttinterp.c (Ins_SCANTYPE): Only use lower 16bits.
 
 2016-10-22  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Improve handling of invalid post 2.5 tables [#49393].
 
 	* src/sfnt/ttpost.c (load_format_25): We need at least a single
 	table entry.
 
 2016-10-14  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Fix handling of `cvar' table data.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=53
 
 	* src/truetype/ttgxvar.c (tt_face_vary_cvt): Ignore invalid CVT
 	indices.
 
 2016-10-11  Werner Lemberg  <wl@gnu.org>
 
 	[psaux] Fix handling of invalid flex subrs.
 
 	Problem reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=52
 
 	* src/psaux/t1decode.c (t1_decoder_parse_charstrings)
 	<op_callothersubr>: Set `flex_state' after error checking.
 
 2016-10-11  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttgxvar.c (tt_done_blend): Fix deallocation.
 
 2016-10-08  Werner Lemberg  <wl@gnu.org>
 
 	* src/cid/cidload.c (cid_face_open): Properly propagate `error'.
 
 2016-10-08  Werner Lemberg  <wl@gnu.org>
 
 	[cid] Fix parsing of subr offsets.
 
 	Bug introduced 2016-05-16.
 
 	* src/cid/cidparse.c (cid_parser_new): Fix off-by-one error.
 
 2016-10-01  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Disable bitmap strikes if we don't have a bitmap data table.
 
 	* src/sfnt/ttsbit.c (tt_face_load_sbit): Check whether we have
 	a bitmap data table.
 
 2016-10-01  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Remove impossibility.
 
 	* src/smooth/ftgrays.c (TWorker): Rearrange fields.
 	(gray_convert_glyph): Remove impossible condition and clean up.
 
 2016-09-29  Werner Lemberg  <wl@gnu.org>
 
 	[pcf] Enrich family name with foundry name and glyph width info.
 
 	This is a very old patch from openSuSE (from 2006, submitted to
 	FreeType in 2011) that I forgot to apply.
 
 	  https://build.opensuse.org/package/view_file/openSUSE:Factory/freetype2/freetype2-bitmap-foundry.patch
 
 	Prepend the foundry name plus a space to the family name.  There are
 	many fonts just called `Fixed' which look completely different, and
 	which have nothing to do with each other.  When selecting `Fixed' in
 	KDE or Gnome one gets results that appear rather random, the style
 	changes often if one changes the size and one cannot select some
 	fonts at all.
 
 	We also check whether we have `wide' characters; all put together,
 	we get family names like `Sony Fixed' or `Misc Fixed Wide'.
 
 	* src/pcf/pcfread.c (pcf_load_font): Implement it.
 
 	* docs/CHANGES: Document it.
 
 2016-09-29  Werner Lemberg  <wl@gnu.org>
 
 	[ftfuzzer] Speed up.
 
 	* src/tools/ftfuzzer/ftfuzzer.cc (LLVMFuzzerTestOneInput): Don't
 	check for embedded bitmaps if we have a non-default instance.
 
 2016-09-29  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Disallow bitmap strokes for non-default instances.
 
 	Also speed up access of default instances if GX variations are
 	active.
 
 	* include/freetype/internal/tttypes.h (TT_FaceRec): Add
 	`is_default_instance' member.
 
 	* src/sfnt/sfobjs.c (sfnt_init_face): Initialize
 	`is_default_instance'.
 
 	* src/truetype/ttgload.c (TT_Process_Simple_Glyph,
 	load_truetype_glyph): Add test for default instance.
 	(TT_Load_Glyph): Load embedded bitmaps for default instance only.
 
 	* src/truetype/ttgxvar.c (TT_Set_MM_Blend): Compute
 	`is_default_instance'.
 
 2016-09-29  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Clean up `TT_Face' structure.
 
 	* include/freetype/internal/tttypes.h (TT_FaceRec): Remove unused
 	fields `horz_metrics' and `vert_metrics'.
 	Update documentation.
 
 	* src/sfnt/sfobjs.c (sfnt_done_face): Updated.
 
 2016-09-28  Werner Lemberg  <wl@gnu.org>
 
 	More FT_ZERO usage.
 
 	* src/gxvalid/gxvcommn.c (gxv_ClassTable_validate):
 	s/ft_memset/FT_MEM_ZERO/.
 
 	* src/psaux/t1decode.c (t1_decoder_parse_charstrings):
 	s/ft_memset/FT_ARRAY_ZERO/.
 
 	* src/raster/ftraster.c (FT_ZERO): Define.
 	(ft_black_new): Use it.
 	* src/raster/ftrend1.c (ft_raster1_get_cbox):
 	s/FT_MEM_ZERO/FT_ZERO/.
 
 	* src/smooth/ftgrays.c (FT_ZERO): Define.
 	(gray_raster_new): Use it.
 	* src/smooth/ftsmooth.c (ft_smooth_get_cbox):
 	s/FT_MEM_ZERO/FT_ZERO/.
 
 2016-09-28  Werner Lemberg  <wl@gnu.org>
 
 	*/*: s/FT_MEM_ZERO/FT_ZERO/ where appropriate.
 
 2016-09-27  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Trace number of executed opcodes.
 
 	* src/truetype/ttinterp.c (TT_RunIns): Implement it.
 
 2016-09-27  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Speed up `TT_Load_Glyph'.
 
 	This avoids additional calls to `tt_face_lookup_table' for the
 	`glyf' table, which can be expensive.
 
 	* include/freetype/internal/tttypes.h (TT_LoaderRec): Move
 	`glyf_offset' field to ...
 	(TT_FaceRec): ... this structure.
 	* src/truetype/ttgload.c (load_truetype_glyph): Updated.
 	(tt_loader_init): Move initialization of `glyf_offset' to ...
 	* src/truetype/ttpload.c (tt_face_load_loca): ... this function.
 
 2016-09-27  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Introduce dynamic limits for some bytecode opcodes.
 
 	This speeds up FreeType's handling of malformed fonts.
 
 	* src/truetype/ttinterp.c (TT_RunIns): Set up limits for the number
 	of twilight points, the total number of negative jumps, and the
 	total number of loops in LOOPCALL opcodes.  The values are based on
 	the number of points and entries in the CVT table.
 	(Ins_JMPR): Test negative jump counter.
 	(Ins_LOOPCALL): Test loopcall counter.
 
 	* src/truetype/ttinterp.h (TT_ExecContext): Updated.
 
 	* docs/CHANGES: Updated.
 
 2016-09-25  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Sanitize only last entry of `loca' table.
 
 	Without this patch, a loca sequence like `0 100000 0 100000 ...',
 	where value 100000 is larger than the `glyf' table size, makes
 	FreeType handle the whole `glyf' table as a single glyph again and
 	again, which is certainly invalid (and can be very slow, too).
 
 	* src/truetype/ttpload.c (tt_face_get_location): Implement.
 	Improve tracing messages.
 
 2016-09-25  Werner Lemberg  <wl@gnu.org>
 
 	* src/tools/ftfuzzer/ftfuzzer.cc (LLVMFuzzerTestOneInput): Fix typo.
 
 2016-09-24  Werner Lemberg  <wl@gnu.org>
 
 	[autofit] Tracing fixes.
 
 	* src/autofit/afmodule.c (af_autofitter_load_glyph): Call dumping
 	functions only if we actually do tracing.
 
 2016-09-22  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Reduce divisions in the line renderer.
 
 	We don't need some divisions if a line segments stays within a single
 	row or a single column of pixels.
 
 	* src/smooth/ftgrays.c (gray_render_line) [FT_LONG64]: Make divisions
 	conditional.
 
 2016-09-15  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/smooth/ftgrays.c (gray_sweep): Remove check for empty table.
 
 2016-09-14  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Another tiny speed-up.
 
 	* src/smooth/ftgrays.c (gray_find_cell): Merge into...
 	(gray_record_cell): ... this function.
 
 2016-09-11  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/smooth/ftgrays.c (gray_{find,set}_cell): Remove dubious code.
 
 2016-09-11  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Fix valgrind warning and reoptimize.
 
 	The algorithm calls `gray_set_cell' at the start of each new contour
 	or when the contours cross the cell boundaries. Double-checking for
 	that is wasteful.
 
 	* src/smooth/ftgrays.c (gray_set_cell): Remove check for a new cell.
 	(gray_convert_glyph): Remove initialization introduced by 44b172e88.
 
 2016-09-10  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Fix previous commit.
 
 	Problems reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40
 
 	We now map the strike index right before accessing the physical
 	data, not earlier.
 
 	* src/sfnt/sfobjs.c (sfnt_load_face): Set `face->sbit_strike_map'
 	after creating the map so that...
 
 	* src/sfnt/ttsbit.c (tt_face_load_strike_metrics): ... this function
 	can be used before and after setting up `sbit_strike_map'.
 	(tt_face_set_sbit_strike): Revert change.
 	(tt_sbit_decoder_init, tt_face_load_sbix_image): Map strike index.
 
 	* src/truetype/ttdriver.c (tt_size_select): Revert change.
 
 2016-09-09  Werner Lemberg  <wl@gnu.org>
 
 	[ftfuzzer] Minor improvements.
 
 	* src/tools/ftfuzzer/ftfuzzer.cc (LLVMFuzzerTestOneInput): Ignore
 	invalid strikes.
 	Use better values for call to `FT_Set_Char_Size'.
 
 2016-09-09  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Don't provide (completely) broken strike data.
 
 	FreeType tries to sanitize strike header data; we now reject
 	completely broken ones.
 
 	* include/freetype/internal/tttypes.h (TT_FaceRec): New
 	`sbit_strike_map' array pointer.
 
 	* src/base/ftobjs.c (FT_Match_Size): Reject matches where either
 	width or height would be zero.
 	Add tracing message in case of error.
 
 	* src/sfnt/sfobjs.c (sfnt_load_face): Populate `sbit_strike_map',
 	only using (more or less) valid strike header data for
 	FT_Face's `available_sizes' array.
 	(sfnt_done_face): Updated.
 
 	* src/sfnt/ttsbit.c (tt_face_set_sbit_strike): Use
 	`sbit_strike_map'.
 	(tt_face_load_strike_metrics): Improve tracing.
 
 	* src/truetype/ttdriver.c (tt_size_select): Use `sbit_strike_map'.
 
 2016-09-08  Werner Lemberg  <wl@gnu.org>
 
 	* Version 2.7 released.
 	=======================
 
 
 	Tag sources with `VER-2-7'.
 
 	* docs/VERSION.TXT: Add entry for version 2.7.
 
 	* README, Jamfile (RefDoc), builds/windows/vc2005/freetype.vcproj,
 	builds/windows/vc2005/index.html,
 	builds/windows/vc2008/freetype.vcproj,
 	builds/windows/vc2008/index.html,
 	builds/windows/vc2010/freetype.vcxproj,
 	builds/windows/vc2010/index.html,
 	builds/windows/visualc/freetype.dsp,
 	builds/windows/visualc/freetype.vcproj,
 	builds/windows/visualc/index.html,
 	builds/windows/visualce/freetype.dsp,
 	builds/windows/visualce/freetype.vcproj,
 	builds/windows/visualce/index.html,
 	builds/wince/vc2005-ce/freetype.vcproj,
 	builds/wince/vc2005-ce/index.html,
 	builds/wince/vc2008-ce/freetype.vcproj,
 	builds/wince/vc2008-ce/index.html: s/2.6.5/2.7/, s/265/27/.
 
 	* include/freetype/freetype.h (FREETYPE_MINOR): Set to 7.
 	(FREETYPE_PATCH): Set to 0.
 
 	* builds/unix/configure.raw (version_info): Set to 18:6:12.
 	* CMakeLists.txt (VERSION_MINOR): Set to 7.
 	(VERSION_PATCH): Set to 0.
 
 	* docs/CHANGES: Updated.
 
 2016-09-08  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttinterp.c: Include `ttgxvar.h'.
 
 	This fixes the `multi' build.
 
 2016-09-08  Werner Lemberg  <wl@gnu.org>
 
 	[autofit] Another improvement to Armenian support.
 
 	Suggested by Hrant H Papazian <hpapazian@gmail.com>.
 
 	* src/autofit/afscript.h: Use better suited characters to derive
 	default stem widths.
 
 2016-09-07  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/smooth/ftgrays.c (gray_hline): Microptimize.
 
 2016-09-06  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Operate in absolute bitmap coordinates.
 
 	Simpler bitmap addressing improves performance by 1.5%.
 
 	* src/smooth/ftgrays.c (gray_TWorker): Remove count fields.
 	(gray_dump_cells, gray_find_cell, gray_set_cell, gray_hline,
 	gray_sweep, gray_convert_glyph, gray_raster_render): Updated.
 
 2016-09-06  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Improve contour start (take 2).
 
 	* src/smooth/ftgrays.c (gray_move_to): Call `gray_set_cell' directly
 	instead of...
 	(gray_start_cell): ... this function, which is removed.
 	(gray_convert_glyph): Make initial y-coordinate invalid.
 
 2016-09-06  Werner Lemberg  <wl@gnu.org>
 
 	[type1] MM fonts support exactly zero named instances (#48748).
 
 	* src/type1/t1load.c (T1_Get_MM_Var): Set `num_namedstyles' to zero.
 
 2016-09-06  Jonathan Kew  <jfkthame@gmail.com>
 
 	[cff] Fix uninitialized memory.
 
 	Problem reported as
 
 	  https://bugzilla.mozilla.org/show_bug.cgi?id=1270288
 
 	* src/cff/cf2interp.c (cf2_interpT2CharString): Initialize `storage'
 	array to handle a `get' opcode without a previous `put'.
 
 2016-09-05  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/smooth/ftgrays.c (gray_move_to, gray_start_cell): Revert.
 
 2016-09-05  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Improve contour start.
 
 	* src/smooth/ftgrays.c (gray_move_to): Call `gray_set_cell' directly
 	instead of...
 	(gray_start_cell): ... this function, which is removed.
 
 2016-09-05  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Fix memory initialization.
 
 	* src/cff/cf2stack.c (cf2_stack_init): Use `FT_NEW'.  The `Q'
 	variants of FreeType's memory allocation macros don't do zeroing.
 
 2016-09-05  Werner Lemberg  <wl@gnu.org>
 
 	[ftrandom] Minor improvements.
 
 	* src/tools/ftrandom/ftrandom.c (_XOPEN_SOURCE): New macro, set to
 	500.
 
 	* src/tools/ftrandom/Makefile (CFLAGS): Split off include
 	directories to ...
 	(INCLUDES): ... this new variable.
 	(LDFLAGS): New variable.
 	(ftrandom.o, ftrandom): Updated.
 
 2016-09-05  Werner Lemberg  <wl@gnu.org>
 
 	[autofit] Improve Armenian support.
 
 	Thanks to Hrant H Papazian <hpapazian@gmail.com> for help.
 
 	* src/autofit/afblue.dat (AF_BLUE_STRING_ARMENIAN_*): Improve
 	selection of characters.
 
 	* src/autofit/afblue.c, src/autofit/afblue.h: Regenerated.
 
 2016-09-04  Werner Lemberg  <wl@gnu.org>
 
 	[ftrandom] Improve Makefile.
 
 	It now supports both a normal build (`./configure && make') and a
 	development build (`make devel').
 
 	* src/tools/ftrandom/Makefile (VPATH): Set it so that
 	`libfreetype.a' gets searched in both `objs' (for the development
 	build) and `objs/.libs' (for a normal build which uses libtool).
 	(LIBS): Add missing libraries.
 	(ftrandom.o): New rule.
 	(ftrandom): Use automatic variables.
 
 2016-09-03  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] More fixes for handling of GX deltas.
 
 	Problems reported by Bob Taylor <Bob.Taylor@monotype.com>.
 
 	* src/truetype/ttgxvar.c (TT_Vary_Apply_Glyph_Deltas): Fix rough
 	sanity test for glyph variation array header size.
 	Always set stream position before reading packed x and y deltas.
 	Fix thinko w.r.t. `localpoints' array.
 
 2016-09-03  Werner Lemberg  <wl@gnu.org>
 
 	[ftrandom] Various fixes.
 
 	* src/tools/ftrandom/ftrandom.c (GOOD_FONTS_DIR): Provide better
 	default.
 	(error_fraction): Make it of type `double' to work as advertized –
 	this was completely broken.
 	Update all related code.
 	(error_count, fcnt): Make it unsigned to fix compiler warnings.
 	Update all related code.
 	(fontlist): Change `len' member to `long' to fix compiler warnings.
 	(FT_MoveTo, FT_LineTo, FT_ConicTo, FT_CubicTo, abort_test): Tag
 	unused variables.
 	(TestFace, FindFonts, copyfont, do_test): Fix compiler warnings.
 	(ExecuteTest): Ditto.
 	Call `FT_Done_FreeType'.
 	(getErrorCnt): Replace `ceil' with an ordinary cast to `unsigned
 	int'.
 	(usage): Improve output.
 	(main): Fix compiler warnings.
 
 	* src/tools/ftrandom/README: Updated.
 
 2016-09-03  Werner Lemberg  <wl@gnu.org>
 
 	[base] Avoid negative bitmap stroke dimensions (#48985).
 
 	* src/base/ftobjs.c (FT_Open_Face): Check whether negation was
 	actually successful.  For example, this can fail for value
 	-32768 if the type is `signed short'.  If there are problems,
 	disable the stroke.
 
 2016-09-03  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Avoid null pointer passed to FT_MEM_COPY (#48984).
 
 	* src/cff/cffload.c (cff_index_get_name): Check `byte_len'.
 
 2016-09-02  Werner Lemberg  <wl@gnu.org>
 
 	[unix] Enable 64bit support in file system access (#48962).
 
 	* builds/unix/configure.raw: Call `AC_SYS_LARGEFILE'.
 
 2016-09-02  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Avoid left shift of negative value (#48980).
 
 	* src/sfnt/ttsbit.c (tt_sbit_decoder_load_bit_aligned): Use unsigned
 	constant.
 
 2016-09-02  Werner Lemberg  <wl@gnu.org>
 
 	* src/smooth/ftgrays.c (gray_hline): Fix clang compiler warnings.
 
 2016-09-02  Werner Lemberg  <wl@gnu.org>
 
 	Some preparations for the next release.
 
 	* include/freetype/config/ftoption.h
 	(TT_CONFIG_OPTION_SUBPIXEL_HINTING): Enable.
 
 	* docs/CHANGES: Updated.
 
 2016-09-01  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Simplify span rendering more.
 
 	It turns out that there is significant cost associated with `FT_Span'
 	creation and calls to `gray_render_span' because it happerns so
 	frequently. This removes these steps from our internal use but leaves
 	it alone for `FT_RASTER_FLAG_DIRECT" to preserve API. The speed gain
 	is about 5%.
 
 	* src/smooth/ftgrays.c (gray_render_span): Removed. The code is
 	migrated to...
 	(gray_hline): ... here.
 
 2016-08-30  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Streamline pixmap drawing a bit more.
 
 	Zero coverage is unlikely (1 out of 256) to warrant checking. This
 	gives 0.5% speed improvement in rendering simple glyphs.
 
 	* src/smooth/ftgrays.c (gray_hline, gray_render_span): Remove checks.
 
 2016-08-29  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Streamline pixmap drawing.
 
 	This gives 2% speed improvement in rendering simple glyphs.
 
 	* src/smooth/ftgrays.c (TPixmap): Reduced pixmap descriptor with a
 	pointer to its bottom-left and pitch to be used in...
 	(gray_TWorker): ... here.
 	(gray_render_span): Move pixmap flow check from here...
 	(gray_raster_render): .. to here.
 
 2016-08-27  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Reduce stack of band boundaries.
 
 	* src/smooth/ftgrays.c (gray_TBand): Removed.
 	(gray_convert_glyph): Updated to stack band boundaries concisely.
 
 2016-08-26  Werner Lemberg  <wl@gnu.org>
 
 	* src/cid/cidload.c (cid_face_open): Improve handling of `SDBytes'.
 
 2016-08-26  Werner Lemberg  <wl@gnu.org>
 
 	[cid] Fix commit from 2016-05-16.
 
 	* src/cid/cidparse.c (cid_parser_new): Fix off-by-one errors.
 
 2016-08-26  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Cache offset and size to bitmap data table.
 
 	This commit avoids `EBDT' and friends being looked up again and
 	again while loading a single embedded bitmap.
 
 	* include/freetype/internal/tttypes.h (TT_FaceRec)
 	[TT_CONFIG_OPTION_EMBEDDED_BITMAPS]: New fields `ebdt_start' and
 	`ebdt_size'.
 
 	* src/sfnt/ttsbit.c (tt_sbit_decoder_init): Move table lookup to ...
 	(tt_face_load_sbit): ... this function; also store the table size
 	and offset.
 
 2016-08-26  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/smooth/ftgrays.c (gray_raster_render): Minor tweaks.
 
 2016-08-26  Werner Lemberg  <wl@gnu.org>
 
 	[type1] Fix heap buffer overflow.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=36
 
 	* src/type1/t1load.c (parse_charstrings): Reject fonts that don't
 	contain glyph names.
 
 2016-08-25  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Fix previous commit (#48901).
 
 	* src/sfnt/ttcmap.c (tt_cmap4_char_map_binary): Thinkos.
 
 2016-08-25  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Speed up handling of invalid format 4 cmaps.
 
 	* src/sfnt/ttcmap.c (tt_cmap4_next, tt_cmap4_char_map_binary): Add
 	tests for `num_glyph' from `tt_cmap4_char_map_linear'.
 
 2016-08-25  Werner Lemberg  <wl@gnu.org>
 
 	* include/freetype/internal/ftdriver.h: Remove unused typedefs.
 
 2016-08-22  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Simplify span rendering.
 
 	This removes unnecessary complexity of span merging and buffering.
 	Instead, the spans are rendered as they come, speeding up the
 	rendering by about 5% as a result.
 
 	* src/smooth/ftgrays.c [FT_MAX_GRAY_SPANS]: Macro removed.
 	(gray_TWorker): Remove span buffer and related fields.
 	(gray_sweep, gray_hline): Updated.
 
 	* include/freetype/ftimage.h: Remove documentation note about
 	`FT_MAX_GRAY_SPANS', which was never in `ftoption.h' and is now gone.
 
 2016-08-16  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Fix `MPS' instruction.
 
 	According to Greg Hitchcock, MPS in DWrite really returns the point
 	size.
 
 	* src/truetype/ttobjs.h (TT_SizeRec): Add `point_size' member.
 
 	* src/truetype/ttdriver.c (tt_size_request): Set `point_size'.
 
 	* src/truetype/ttinterp.h (TT_ExecContextRec): Add `pointSize'
 	member.
 
 	* src/truetype/ttinterp.c (TT_Load_Context): Updated.
 	(Ins_MPS): Fix instruction.
 
 2016-08-16  Werner Lemberg  <wl@gnu.org>
 
 	[lzw] Optimize last commit.
 
 	* src/lzw/ftzopen.c (ft_lzwstate_get_code): Move check into
 	conditional clause.
 
 2016-08-16  Werner Lemberg  <wl@gnu.org>
 
 	[lzw] Avoid invalid left shift.
 
 	Reported as
 
 	  https://bugzilla.mozilla.org/show_bug.cgi?id=1295366
 
 	* src/lzw/ftzopen.c (ft_lzwstate_get_code): Limit `num_bits'.
 
 2016-08-16  Werner Lemberg  <wl@gnu.org>
 
 	[lzw] Avoid buffer overrun.
 
 	Reported as
 
 	  https://bugzilla.mozilla.org/show_bug.cgi?id=1273283
 
 	* src/lzw/ftzopen.c (ft_lzwstate_refill): Ensure `buf_size' doesn't
 	underflow.
 
 2016-08-16  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Fix compiler warning.
 
 	* src/truetype/ttgload.c (load_truetype_glyph): Add cast.
 
 2016-08-13  Werner Lemberg  <wl@gnu.org>
 
 	[winfonts] Avoid zero bitmap width and height.
 
 	Reported as
 
 	  https://bugzilla.mozilla.org/show_bug.cgi?id=1272173
 
 	* src/winfonts/winfnt.c (FNT_Face_Init): Check zero pixel height.
 	(FNT_Load_Glyph): Check for zero pitch.
 
 2016-08-11  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/truetype/ttinterp.c (Pop_Push_Count): Revert changes.
 
 2016-08-11  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/truetype/ttinterp.c (TT_RunIns): Minor and formatting.
 
 2016-08-11  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/truetype/ttinterp.c (Pop_Push_Count): Fix some entries.
 
 2016-08-10  Peter Klotz  <Peter.Klotz@ith-icoserve.com>
 
 	* src/smooth/ftgrays.c (gray_hline): Fix uninitialized access.
 
 2016-08-10  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Use correct type for `italicAngle' field (#48732).
 
 	* src/sfnt/ttload.c (tt_face_load_post): Fix types.
 
 2016-08-06  Jon Spencer  <jon@jonspencer.ca>
 
 	[sfnt] Fix `FT_Get_Advance' for bitmap strikes.
 
 	`FT_Get_Advance' returns 0 for bitmap fonts.  It first gets the
 	advance value from the font table and then scales it by the
 	`font->size->metrics->x_scale' field.  But `FT_Select_Size' doesn't
 	set that value for bitmap fonts and the advance gets scaled to zero.
 
 	Taken from
 
 	  https://github.com/behdad/harfbuzz/issues/252
 
 	* src/sfnt/ttsbit.c (tt_face_load_strike_metrics)
 	<TT_SBIT_TABLE_TYPE_EBLC>: Set scale values.
 
 2016-08-06  Behdad Esfahbod  <behdad@behdad.org>
 
 	[truetype] Fix GX variation handling of composites.
 
 	* src/truetype/ttgload.c (load_truetype_glyph)
 	[TT_CONFIG_OPTION_GX_VAR_SUPPORT]: Check `ARGS_ARE_XY_VALUES' flag.
 
 2016-08-05  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Minor refactoring.
 
 	* src/smooth/ftgrays.c (gray_render_scanline, gray_render_line):
 	Updated.
 
 2016-07-29  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt, truetype] Don't abort on invalid `maxComponentDepth'.
 
 	Since 2016-05-16 we detect infinite recursion directly.
 
 	* src/sfnt/ttload.c (tt_face_load_maxp): Don't adjust
 	`maxComponentDepth'.
 	* src/truetype/ttgload.c (load_truetype_glyph): Don't abort if
 	`maxComponentDepth' is not valid.  Instead, simply adjust its value
 	and emit a tracing message.
 
 2016-07-26  Werner Lemberg  <wl@gnu.org>
 
 	* src/autofit/aflatin.c (af_latin_metrics_scale_dim): Minor.
 
 	No functional change.
 
 2016-07-22  Hin-Tak Leung  <htl10@users.sourceforge.net>
 
 	[truetype] Record the end of IDEFs.
 
 	To match the logic in FDEF.  The value of the end is only used for
 	bound-checking in `Ins_JMPR', so it may not have been obvious that
 	it was not recorded.  Tested (as part of Font Validator 2.0) all the
 	fonts on Fedora and did not see any change.
 
 	* src/truetype/ttinterp.c (Ins_IDEF): Updated.
 
 2016-07-19  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Sanitizer fix, second try.
 
 	* src/truetype/ttgxvar.c (ft_var_readpackedpoints): Fix boundary
 	tests and use only one slot more.
 
 2016-07-19  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Sanitizer fix.
 
 	* src/truetype/ttgxvar.c (ft_var_readpackedpoints): Increase array
 	to fix nested loops.
 
 2016-07-18  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Make GETDATA work only for GX fonts.
 
 	* src/truetype/ttinterp.c (opcode_name): Updated.
 	(Ins_GETDATA): Only define for `TT_CONFIG_OPTION_GX_VAR_SUPPORT'.
 	(TT_RunIns): Updated.
 
 2016-07-17  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Add support for Apple's
 
 	  GETDATA[], opcode 0x92
 
 	bytecode instruction.  It always returns 17, and we have absolutely
 	no idea what it is good for...
 
 	* src/truetype/ttinterp.c (Pop_Push_Count, opcode_name): Updated.
 	(Ins_GETDATA): New function.
 	(TT_RunIns): Add it.
 
 2016-07-16  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Add bytecode support for GX variation fonts.
 
 	This commit implements undocumented (but confirmed) stuff from
 	Apple's old bytecode engine.
 
 	  GETVARIATION[], opcode 0x91
 	    This opcode pushes normalized variation coordinates for all axes
 	    onto the stack (in 2.14 format).  Coordinate of first axis gets
 	    pushed first.
 
 	  GETINFO[], selector bit 3
 	    If GX variation support is enabled, bit 10 of the result is set
 	    to 1.
 
 	* src/truetype/ttinterp.c: Include FT_MULTIPLE_MASTERS_H.
 	(opcode_name) [TT_CONFIG_OPTION_GX_VAR_SUPPORT]: Updated.
 	(Ins_GETINFO) [TT_CONFIG_OPTION_GX_VAR_SUPPORT]: Handle selector
 	bit 3, checking support for variation glyph hinting.
 	(Ins_GETVARIATION) [TT_CONFIG_OPTION_GX_VAR_SUPPORT]: New function
 	to implement opcode 0x91.
 	(TT_RunIns) [TT_CONFIG_OPTION_GX_VAR_SUPPORT]: Handle opcode 0x91.
 
 2016-07-16  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Fix GETINFO bytecode instruction.
 
 	* src/truetype/ttinterp.c (Ins_GETINFO): Fix return value for
 	stretching information.
 
 2016-07-16  Behdad Esfahbod  <behdad@behdad.org>
 
 	[truetype] Make all glyphs in `Zycon' GX font work.
 
 	* src/truetype/ttgxvar.c (ft_var_readpackedpoints): Fix boundary
 	tests.
 
 2016-07-16  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Fix GX delta tracing.
 
 	* src/truetype/ttgxvar.c (TT_Vary_Apply_Glyph_Deltas): Trace
 	relative point movements.
 
 2016-07-16  Behdad Esfahbod  <behdad@behdad.org>
 
 	[truetype] More fixes for GX.
 
 	This finally fixes the rendering of the cyclist and the lizard in
 	the `Zycon' font.
 
 	* src/truetype/ttgxvar.c (ft_var_readpackedpoints): `first' point
 	index is always cumulative.
 
 	(tt_handle_deltas): Rename to...
 	(tt_interpolate_deltas): ... This.
 	Add new parameter for output point array.
 	Update caller.
 
 	(TT_Vary_Apply_Glyph_Deltas): Add `points_out' array; it now holds
 	the intermediate results of `tt_interpolate_deltas' that are to be
 	added to `outline->points'.
 
 2016-07-15  Werner Lemberg  <wl@gnu.org>
 
 	* src/autofit/aflatin.c (af_latin_hints_compute_segments): Thinko.
 
 	`max_pos' is always larger than `min_pos' so `FT_ABS' is not needed.
 
 	Reported by Alexei.
 
 2016-07-16  Nikolaus Waxweiler  <madigens@gmail.com>
 
 	* src/truetype/ttinterp.c (Ins_MIRP): Fix copy-and-paste error.
 
 	Problem reported by Hin-Tak Leung.
 
 2016-07-15  Werner Lemberg  <wl@gnu.org>
 
 	[autofit] Update and improve segment and edge tracing.
 
 	* src/autofit/afhints.c (af_glyph_hints_dump_segments): Trace
 	`delta' also.
 	Don't show first point of segment as a replacement for `pos'; this
 	is (a) misleading, since the difference to `pos' can be almost
 	arbitrarily large in corner cases, and (b) it is better to have all
 	segment data in font units instead of a single value given in output
 	space coordinates.
 	Improve layout.
 	(af_glyph_hints_dump_edges): Show px->units and units->px conversion
 	values for convenience.
 	Improve layout.
 
 2016-07-15  Werner Lemberg  <wl@gnu.org>
 
 	[autofit] For edges, reject segments wider than 1px (#41334).
 
 	* src/autofit/afhints.h (AF_SegmentRec): New member `delta'.
 
 	* src/autofit/aflatin.c (af_latin_hints_compute_segments): Compute
 	`delta'.
 	(af_latin_hints_compute_edges): Reject segments with a delta larger
 	than 0.5px.
 
 2016-07-14  Werner Lemberg  <wl@gnu.org>
 
 	* include/freetype/freetype.h (FT_IS_NAMED_INSTANCE): New macro.
 
 2016-07-14  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Fix `face_index' value in `FT_Face' for named instances.
 
 	* src/sfnt/sfobjc.s (sfnt_init_face): Don't strip off higher 16bits.
 
 2016-07-14  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttgxvar.c (TT_Vary_Apply_Glyph_Deltas): Fix tracing.
 
 2016-07-14  Behdad Esfahbod  <behdad@behdad.org>
 
 	[truetype] Fix gxvar delta interpolation.
 
 	The coordinates of the base font should be used for interpolation
 	purposes, NOT the current points (i.e., the result of accumulation
 	of previous deltas).
 
 	* src/truetype/ttgxvar.c (TT_Vary_Apply_Glyph_Deltas): Initialize
 	`points_org' before looping over all tuples.
 
 
 ----------------------------------------------------------------------------
diff --git a/src/truetype/ttgxvar.c b/src/truetype/ttgxvar.c
index cf4f7b17a..768987027 100644
--- a/src/truetype/ttgxvar.c
+++ b/src/truetype/ttgxvar.c
@@ -1,2996 +1,3004 @@
 /***************************************************************************/
 /*                                                                         */
 /*  ttgxvar.c                                                              */
 /*                                                                         */
 /*    TrueType GX Font Variation loader                                    */
 /*                                                                         */
 /*  Copyright 2004-2016 by                                                 */
 /*  David Turner, Robert Wilhelm, Werner Lemberg, and George Williams.     */
 /*                                                                         */
 /*  This file is part of the FreeType project, and may only be used,       */
 /*  modified, and distributed under the terms of the FreeType project      */
 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
 /*  this file you indicate that you have read the license and              */
 /*  understand and accept it fully.                                        */
 /*                                                                         */
 /***************************************************************************/
 
 
   /*************************************************************************/
   /*                                                                       */
   /* Apple documents the `fvar', `gvar', `cvar', and `avar' tables at      */
   /*                                                                       */
   /*   https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6[fgca]var.html */
   /*                                                                       */
   /* The documentation for `fvar' is inconsistent.  At one point it says   */
   /* that `countSizePairs' should be 3, at another point 2.  It should     */
   /* be 2.                                                                 */
   /*                                                                       */
   /* The documentation for `gvar' is not intelligible; `cvar' refers you   */
   /* to `gvar' and is thus also incomprehensible.                          */
   /*                                                                       */
   /* The documentation for `avar' appears correct, but Apple has no fonts  */
   /* with an `avar' table, so it is hard to test.                          */
   /*                                                                       */
   /* Many thanks to John Jenkins (at Apple) in figuring this out.          */
   /*                                                                       */
   /*                                                                       */
   /* Apple's `kern' table has some references to tuple indices, but as     */
   /* there is no indication where these indices are defined, nor how to    */
   /* interpolate the kerning values (different tuples have different       */
   /* classes) this issue is ignored.                                       */
   /*                                                                       */
   /*************************************************************************/
 
 
 #include <ft2build.h>
 #include FT_INTERNAL_DEBUG_H
 #include FT_CONFIG_CONFIG_H
 #include FT_INTERNAL_STREAM_H
 #include FT_INTERNAL_SFNT_H
 #include FT_TRUETYPE_TAGS_H
 #include FT_MULTIPLE_MASTERS_H
 
 #include "ttpload.h"
 #include "ttgxvar.h"
 
 #include "tterrors.h"
 
 
 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
 
 
 #define FT_Stream_FTell( stream )                         \
           (FT_ULong)( (stream)->cursor - (stream)->base )
 #define FT_Stream_SeekSet( stream, off )                  \
           ( (stream)->cursor = (stream)->base + (off) )
 
 
   /*************************************************************************/
   /*                                                                       */
   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
   /* messages during execution.                                            */
   /*                                                                       */
 #undef  FT_COMPONENT
 #define FT_COMPONENT  trace_ttgxvar
 
 
   /*************************************************************************/
   /*************************************************************************/
   /*****                                                               *****/
   /*****                       Internal Routines                       *****/
   /*****                                                               *****/
   /*************************************************************************/
   /*************************************************************************/
 
 
   /*************************************************************************/
   /*                                                                       */
   /* The macro ALL_POINTS is used in `ft_var_readpackedpoints'.  It        */
   /* indicates that there is a delta for every point without needing to    */
   /* enumerate all of them.                                                */
   /*                                                                       */
 
   /* ensure that value `0' has the same width as a pointer */
 #define ALL_POINTS  (FT_UShort*)~(FT_PtrDist)0
 
 
 #define GX_PT_POINTS_ARE_WORDS      0x80U
 #define GX_PT_POINT_RUN_COUNT_MASK  0x7FU
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    ft_var_readpackedpoints                                            */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Read a set of points to which the following deltas will apply.     */
   /*    Points are packed with a run length encoding.                      */
   /*                                                                       */
   /* <Input>                                                               */
   /*    stream    :: The data stream.                                      */
   /*                                                                       */
   /*    size      :: The size of the table holding the data.               */
   /*                                                                       */
   /* <Output>                                                              */
   /*    point_cnt :: The number of points read.  A zero value means that   */
   /*                 all points in the glyph will be affected, without     */
   /*                 enumerating them individually.                        */
   /*                                                                       */
   /* <Return>                                                              */
   /*    An array of FT_UShort containing the affected points or the        */
   /*    special value ALL_POINTS.                                          */
   /*                                                                       */
   static FT_UShort*
   ft_var_readpackedpoints( FT_Stream  stream,
                            FT_ULong   size,
                            FT_UInt   *point_cnt )
   {
     FT_UShort *points = NULL;
     FT_UInt    n;
     FT_UInt    runcnt;
     FT_UInt    i, j;
     FT_UShort  first;
     FT_Memory  memory = stream->memory;
     FT_Error   error  = FT_Err_Ok;
 
     FT_UNUSED( error );
 
 
     *point_cnt = 0;
 
     n = FT_GET_BYTE();
     if ( n == 0 )
       return ALL_POINTS;
 
     if ( n & GX_PT_POINTS_ARE_WORDS )
     {
       n  &= GX_PT_POINT_RUN_COUNT_MASK;
       n <<= 8;
       n  |= FT_GET_BYTE();
     }
 
     if ( n > size )
     {
       FT_TRACE1(( "ft_var_readpackedpoints: number of points too large\n" ));
       return NULL;
     }
 
     /* in the nested loops below we increase `i' twice; */
     /* it is faster to simply allocate one more slot    */
     /* than to add another test within the loop         */
     if ( FT_NEW_ARRAY( points, n + 1 ) )
       return NULL;
 
     *point_cnt = n;
 
     first = 0;
     i     = 0;
     while ( i < n )
     {
       runcnt = FT_GET_BYTE();
       if ( runcnt & GX_PT_POINTS_ARE_WORDS )
       {
         runcnt     &= GX_PT_POINT_RUN_COUNT_MASK;
         first      += FT_GET_USHORT();
         points[i++] = first;
 
         /* first point not included in run count */
         for ( j = 0; j < runcnt; j++ )
         {
           first      += FT_GET_USHORT();
           points[i++] = first;
           if ( i >= n )
             break;
         }
       }
       else
       {
         first      += FT_GET_BYTE();
         points[i++] = first;
 
         for ( j = 0; j < runcnt; j++ )
         {
           first      += FT_GET_BYTE();
           points[i++] = first;
           if ( i >= n )
             break;
         }
       }
     }
 
     return points;
   }
 
 
 #define GX_DT_DELTAS_ARE_ZERO       0x80U
 #define GX_DT_DELTAS_ARE_WORDS      0x40U
 #define GX_DT_DELTA_RUN_COUNT_MASK  0x3FU
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    ft_var_readpackeddeltas                                            */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Read a set of deltas.  These are packed slightly differently than  */
   /*    points.  In particular there is no overall count.                  */
   /*                                                                       */
   /* <Input>                                                               */
   /*    stream    :: The data stream.                                      */
   /*                                                                       */
   /*    size      :: The size of the table holding the data.               */
   /*                                                                       */
   /*    delta_cnt :: The number of deltas to be read.                      */
   /*                                                                       */
   /* <Return>                                                              */
   /*    An array of FT_Short containing the deltas for the affected        */
   /*    points.  (This only gets the deltas for one dimension.  It will    */
   /*    generally be called twice, once for x, once for y.  When used in   */
   /*    cvt table, it will only be called once.)                           */
   /*                                                                       */
   static FT_Short*
   ft_var_readpackeddeltas( FT_Stream  stream,
                            FT_ULong   size,
                            FT_UInt    delta_cnt )
   {
     FT_Short  *deltas = NULL;
     FT_UInt    runcnt, cnt;
     FT_UInt    i, j;
     FT_Memory  memory = stream->memory;
     FT_Error   error  = FT_Err_Ok;
 
     FT_UNUSED( error );
 
 
     if ( delta_cnt > size )
     {
       FT_TRACE1(( "ft_var_readpackeddeltas: number of points too large\n" ));
       return NULL;
     }
 
     if ( FT_NEW_ARRAY( deltas, delta_cnt ) )
       return NULL;
 
     i = 0;
     while ( i < delta_cnt )
     {
       runcnt = FT_GET_BYTE();
       cnt    = runcnt & GX_DT_DELTA_RUN_COUNT_MASK;
 
       if ( runcnt & GX_DT_DELTAS_ARE_ZERO )
       {
         /* `runcnt' zeroes get added */
         for ( j = 0; j <= cnt && i < delta_cnt; j++ )
           deltas[i++] = 0;
       }
       else if ( runcnt & GX_DT_DELTAS_ARE_WORDS )
       {
         /* `runcnt' shorts from the stack */
         for ( j = 0; j <= cnt && i < delta_cnt; j++ )
           deltas[i++] = FT_GET_SHORT();
       }
       else
       {
         /* `runcnt' signed bytes from the stack */
         for ( j = 0; j <= cnt && i < delta_cnt; j++ )
           deltas[i++] = FT_GET_CHAR();
       }
 
       if ( j <= cnt )
       {
         /* bad format */
         FT_FREE( deltas );
         return NULL;
       }
     }
 
     return deltas;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    ft_var_load_avar                                                   */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Parse the `avar' table if present.  It need not be, so we return   */
   /*    nothing.                                                           */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    face :: The font face.                                             */
   /*                                                                       */
   static void
   ft_var_load_avar( TT_Face  face )
   {
     FT_Stream       stream = FT_FACE_STREAM( face );
     FT_Memory       memory = stream->memory;
     GX_Blend        blend  = face->blend;
     GX_AVarSegment  segment;
     FT_Error        error = FT_Err_Ok;
     FT_Long         version;
     FT_Long         axisCount;
     FT_Int          i, j;
     FT_ULong        table_len;
 
     FT_UNUSED( error );
 
 
     FT_TRACE2(( "AVAR " ));
 
     blend->avar_checked = TRUE;
     error = face->goto_table( face, TTAG_avar, stream, &table_len );
     if ( error )
     {
       FT_TRACE2(( "is missing\n" ));
       return;
     }
 
     if ( FT_FRAME_ENTER( table_len ) )
       return;
 
     version   = FT_GET_LONG();
     axisCount = FT_GET_LONG();
 
     if ( version != 0x00010000L )
     {
       FT_TRACE2(( "bad table version\n" ));
       goto Exit;
     }
 
     FT_TRACE2(( "loaded\n" ));
 
     if ( axisCount != (FT_Long)blend->mmvar->num_axis )
     {
-      FT_TRACE2(( "ft_var_load_avar: number of axes in `avar' and `cvar'\n"
+      FT_TRACE2(( "ft_var_load_avar: number of axes in `avar' and `fvar'\n"
                   "                  table are different\n" ));
       goto Exit;
     }
 
     if ( FT_NEW_ARRAY( blend->avar_segment, axisCount ) )
       goto Exit;
 
     segment = &blend->avar_segment[0];
     for ( i = 0; i < axisCount; i++, segment++ )
     {
       FT_TRACE5(( "  axis %d:\n", i ));
 
       segment->pairCount = FT_GET_USHORT();
       if ( (FT_ULong)segment->pairCount * 4 > table_len                ||
            FT_NEW_ARRAY( segment->correspondence, segment->pairCount ) )
       {
         /* Failure.  Free everything we have done so far.  We must do */
         /* it right now since loading the `avar' table is optional.   */
 
         for ( j = i - 1; j >= 0; j-- )
           FT_FREE( blend->avar_segment[j].correspondence );
 
         FT_FREE( blend->avar_segment );
         blend->avar_segment = NULL;
         goto Exit;
       }
 
       for ( j = 0; j < segment->pairCount; j++ )
       {
         /* convert to Fixed */
         segment->correspondence[j].fromCoord = FT_GET_SHORT() * 4;
         segment->correspondence[j].toCoord   = FT_GET_SHORT() * 4;
 
         FT_TRACE5(( "    mapping %.5f to %.5f\n",
                     segment->correspondence[j].fromCoord / 65536.0,
                     segment->correspondence[j].toCoord / 65536.0 ));
       }
 
       FT_TRACE5(( "\n" ));
     }
 
   Exit:
     FT_FRAME_EXIT();
   }
 
 
   /* some macros we need */
   #define FT_FIXED_ONE  ( (FT_Fixed)0x10000 )
 
   #define FT_fdot14ToFixed( x )                    \
           ( ( (FT_Fixed)( (FT_Int16)(x) ) ) << 2 )
   #define FT_intToFixed( i )                     \
           ( (FT_Fixed)( (FT_UInt32)(i) << 16 ) )
   #define FT_fixedToInt( x )                                   \
           ( (FT_Short)( ( (FT_UInt32)(x) + 0x8000U ) >> 16 ) )
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    ft_var_load_hvar                                                   */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Parse the `HVAR' table and set `blend->hvar_loaded' to TRUE.       */
   /*                                                                       */
   /*    On success, `blend->hvar_checked' is set to TRUE.                  */
   /*                                                                       */
   /*    Some memory may remain allocated on error; it is always freed in   */
   /*    `tt_done_blend', however.                                          */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    face :: The font face.                                             */
   /*                                                                       */
   /* <Return>                                                              */
   /*    FreeType error code.  0 means success.                             */
   /*                                                                       */
   static FT_Error
   ft_var_load_hvar( TT_Face  face )
   {
     FT_Stream  stream = FT_FACE_STREAM( face );
     FT_Memory  memory = stream->memory;
 
     GX_Blend  blend = face->blend;
 
     FT_Error   error;
     FT_UShort  majorVersion;
     FT_ULong   table_len;
     FT_ULong   table_offset;
     FT_ULong   store_offset;
 
     FT_ULong*  dataOffsetArray = NULL;
 
 
     blend->hvar_loaded = TRUE;
 
     FT_TRACE2(( "HVAR " ));
 
     error = face->goto_table( face, TTAG_HVAR, stream, &table_len );
     if ( error )
     {
       FT_TRACE2(( "is missing\n" ));
       goto Exit;
     }
 
     table_offset = FT_STREAM_POS();
 
     /* skip minor version */
     if ( FT_READ_USHORT( majorVersion ) ||
          FT_STREAM_SKIP( 2 )            )
       goto Exit;
     if ( majorVersion != 1 )
     {
       FT_TRACE2(( "bad table version %d\n", majorVersion ));
       error = FT_THROW( Invalid_Table );
       goto Exit;
     }
 
     /* skip map offset */
     if ( FT_READ_ULONG( store_offset ) ||
          FT_STREAM_SKIP( 4 )           )
       goto Exit;
 
     /* parse item variation store */
     {
       FT_UShort  format;
       FT_ULong   region_offset;
       FT_UInt    i, j, k;
       FT_UInt    shortDeltaCount;
 
       GX_HVStore    itemStore;
       GX_HVarTable  hvarTable;
       GX_HVarData   hvarData;
 
 
       if ( FT_STREAM_SEEK( table_offset + store_offset ) ||
            FT_READ_USHORT( format )                      )
         goto Exit;
       if ( format != 1 )
       {
         FT_TRACE2(( "bad store format %d\n", format ));
         error = FT_THROW( Invalid_Table );
         goto Exit;
       }
 
       if ( FT_NEW( blend->hvar_table ) )    /* allocate table at top level */
         goto Exit;
 
       hvarTable = blend->hvar_table;
       itemStore = &hvarTable->itemStore;
 
       /* read top level fields */
       if ( FT_READ_ULONG( region_offset )         ||
            FT_READ_USHORT( itemStore->dataCount ) )
         goto Exit;
 
       /* make temporary copy of item variation data offsets; */
       /* we will parse region list first, then come back     */
       if ( FT_NEW_ARRAY( dataOffsetArray, itemStore->dataCount ) )
         goto Exit;
 
       for ( i = 0; i < itemStore->dataCount; i++ )
       {
         if ( FT_READ_ULONG( dataOffsetArray[i] ) )
           goto Exit;
       }
 
       /* parse array of region records (region list) */
       if ( FT_STREAM_SEEK( table_offset + store_offset + region_offset ) )
         goto Exit;
 
       if ( FT_READ_USHORT( itemStore->axisCount )   ||
            FT_READ_USHORT( itemStore->regionCount ) )
         goto Exit;
 
+      if ( itemStore->axisCount != (FT_Long)blend->mmvar->num_axis )
+      {
+        FT_TRACE2(( "ft_var_load_hvar: number of axes in `hvar' and `fvar'\n"
+                    "                  table are different\n" ));
+        error = FT_THROW( Invalid_Table );
+        goto Exit;
+      }
+
       if ( FT_NEW_ARRAY( itemStore->varRegionList, itemStore->regionCount ) )
         goto Exit;
 
       for ( i = 0; i < itemStore->regionCount; i++ )
       {
         GX_AxisCoords  axisCoords;
 
 
         if ( FT_NEW_ARRAY( itemStore->varRegionList[i].axisList,
                            itemStore->axisCount ) )
           goto Exit;
 
         axisCoords = itemStore->varRegionList[i].axisList;
 
         for ( j = 0; j < itemStore->axisCount; j++ )
         {
           FT_Short  start, peak, end;
 
 
           if ( FT_READ_SHORT( start ) ||
                FT_READ_SHORT( peak )  ||
                FT_READ_SHORT( end )   )
             goto Exit;
 
           axisCoords[j].startCoord = FT_fdot14ToFixed( start );
           axisCoords[j].peakCoord  = FT_fdot14ToFixed( peak );
           axisCoords[j].endCoord   = FT_fdot14ToFixed( end );
         }
       }
 
       /* end of region list parse */
 
       /* use dataOffsetArray now to parse varData items */
       if ( FT_NEW_ARRAY( itemStore->varData, itemStore->dataCount ) )
         goto Exit;
 
       for ( i = 0; i < itemStore->dataCount; i++ )
       {
         hvarData = &itemStore->varData[i];
 
         if ( FT_STREAM_SEEK( table_offset       +
                              store_offset       +
                              dataOffsetArray[i] ) )
           goto Exit;
 
         if ( FT_READ_USHORT( hvarData->itemCount )      ||
              FT_READ_USHORT( shortDeltaCount )          ||
              FT_READ_USHORT( hvarData->regionIdxCount ) )
           goto Exit;
 
         /* check some data consistency */
         if ( shortDeltaCount > hvarData->regionIdxCount )
         {
           FT_TRACE2(( "bad short count %d or region count %d\n",
                       shortDeltaCount,
                       hvarData->regionIdxCount ));
           error = FT_THROW( Invalid_Table );
           goto Exit;
         }
 
         if ( hvarData->regionIdxCount > itemStore->regionCount )
         {
           FT_TRACE2(( "inconsistent regionCount %d in varData[%d]\n",
                       hvarData->regionIdxCount,
                       i ));
           error = FT_THROW( Invalid_Table );
           goto Exit;
         }
 
         /* parse region indices */
         if ( FT_NEW_ARRAY( hvarData->regionIndices,
                            hvarData->regionIdxCount ) )
           goto Exit;
 
         for ( j = 0; j < hvarData->regionIdxCount; j++ )
         {
           if ( FT_READ_USHORT( hvarData->regionIndices[j] ) )
             goto Exit;
 
           if ( hvarData->regionIndices[j] >= itemStore->regionCount )
           {
             FT_TRACE2(( "bad region index %d\n",
                         hvarData->regionIndices[j] ));
             error = FT_THROW( Invalid_Table );
             goto Exit;
           }
         }
 
         /* Parse delta set.                                                */
         /*                                                                 */
         /* On input, deltas are ( shortDeltaCount + regionIdxCount ) bytes */
         /* each; on output, deltas are expanded to `regionIdxCount' shorts */
         /* each.                                                           */
         if ( FT_NEW_ARRAY( hvarData->deltaSet,
                            hvarData->regionIdxCount * hvarData->itemCount ) )
           goto Exit;
 
         /* the delta set is stored as a 2-dimensional array of shorts; */
         /* sign-extend signed bytes to signed shorts                   */
         for ( j = 0; j < hvarData->itemCount * hvarData->regionIdxCount; )
         {
           for ( k = 0; k < shortDeltaCount; k++, j++ )
           {
             /* read the short deltas */
             FT_Short  delta;
 
 
             if ( FT_READ_SHORT( delta ) )
               goto Exit;
 
             hvarData->deltaSet[j] = delta;
           }
 
           for ( ; k < hvarData->regionIdxCount; k++, j++ )
           {
             /* read the (signed) byte deltas */
             FT_Char  delta;
 
 
             if ( FT_READ_CHAR( delta ) )
               goto Exit;
 
             hvarData->deltaSet[j] = delta;
           }
         }
       }
     }
 
     /* end parse item variation store */
 
     /* parse width map */
     {
       GX_WidthMap  widthMap;
 
       FT_UShort  format;
       FT_UInt    entrySize;
       FT_UInt    innerBitCount;
       FT_UInt    innerIndexMask;
       FT_UInt    i, j;
 
 
       widthMap = &blend->hvar_table->widthMap;
 
       if ( FT_READ_USHORT( format )             ||
            FT_READ_USHORT( widthMap->mapCount ) )
         goto Exit;
 
       if ( format & 0xFFC0 )
       {
         FT_TRACE2(( "bad map format %d\n", format ));
         error = FT_THROW( Invalid_Table );
         goto Exit;
       }
 
       /* bytes per entry: 1, 2, 3, or 4 */
       entrySize      = ( ( format & 0x0030 ) >> 4 ) + 1;
       innerBitCount  = ( format & 0x000F ) + 1;
       innerIndexMask = ( 1 << innerBitCount ) - 1;
 
       if ( FT_NEW_ARRAY( widthMap->innerIndex, widthMap->mapCount ) )
         goto Exit;
 
       if ( FT_NEW_ARRAY( widthMap->outerIndex, widthMap->mapCount ) )
         goto Exit;
 
       for ( i = 0; i < widthMap->mapCount; i++ )
       {
         FT_UInt  mapData = 0;
         FT_UInt  outerIndex, innerIndex;
 
 
         /* read map data one unsigned byte at a time, big endian */
         for ( j = 0; j < entrySize; j++ )
         {
           FT_Byte  data;
 
 
           if ( FT_READ_BYTE( data ) )
             goto Exit;
 
           mapData = ( mapData << 8 ) | data;
         }
 
         outerIndex = mapData >> innerBitCount;
 
         if ( outerIndex >= blend->hvar_table->itemStore.dataCount )
         {
           FT_TRACE2(( "outerIndex[%d] == %d out of range\n",
                       i,
                       outerIndex ));
           error = FT_THROW( Invalid_Table );
           goto Exit;
         }
 
         widthMap->outerIndex[i] = outerIndex;
 
         innerIndex = mapData & innerIndexMask;
 
         if ( innerIndex >=
                blend->hvar_table->itemStore.varData[outerIndex].itemCount )
         {
           FT_TRACE2(( "innerIndex[%d] == %d out of range\n",
                       i,
                       innerIndex ));
           error = FT_THROW( Invalid_Table );
             goto Exit;
         }
 
         widthMap->innerIndex[i] = innerIndex;
       }
     }
 
     /* end parse width map */
 
     FT_TRACE2(( "loaded\n" ));
     error = FT_Err_Ok;
 
   Exit:
     FT_FREE( dataOffsetArray );
 
     if ( !error )
     {
       blend->hvar_checked = TRUE;
 
       /* TODO: implement other HVAR stuff */
       face->variation_support |= TT_FACE_FLAG_VAR_HADVANCE;
     }
 
     return error;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    tt_hadvance_adjust                                                 */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Apply HVAR advance width adjustment of a given glyph.              */
   /*                                                                       */
   /* <Input>                                                               */
   /*    gindex :: The glyph index.                                         */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    face   :: The font face.                                           */
   /*                                                                       */
   /*    adelta :: Points to width value that gets modified.                */
   /*                                                                       */
   FT_LOCAL_DEF( FT_Error )
   tt_hadvance_adjust( TT_Face  face,
                       FT_UInt  gindex,
                       FT_Int  *avalue )
   {
     FT_Error  error = FT_Err_Ok;
 
     GX_HVarData  varData;
 
     FT_UInt    innerIndex, outerIndex;
     FT_UInt    master, j;
     FT_Fixed   netAdjustment = 0;     /* accumulated adjustment */
     FT_Fixed   scaledDelta;
     FT_Short*  deltaSet;
     FT_Fixed   delta;
 
 
     if ( !face->doblend || !face->blend )
       goto Exit;
 
     if ( !face->blend->hvar_loaded )
     {
       /* initialize hvar table */
       face->blend->hvar_error = ft_var_load_hvar( face );
     }
 
     if ( !face->blend->hvar_checked )
     {
       error = face->blend->hvar_error;
       goto Exit;
     }
 
     /* advance width adjustments are always present in an `HVAR' table, */
     /* so need to test for this capability                              */
 
     if ( gindex >= face->blend->hvar_table->widthMap.mapCount )
     {
       FT_TRACE2(( "gindex %d out of range\n", gindex ));
       error = FT_THROW( Invalid_Argument );
       goto Exit;
     }
 
     /* trust that HVAR parser has checked indices */
     outerIndex = face->blend->hvar_table->widthMap.outerIndex[gindex];
     innerIndex = face->blend->hvar_table->widthMap.innerIndex[gindex];
     varData    = &face->blend->hvar_table->itemStore.varData[outerIndex];
     deltaSet   = &varData->deltaSet[varData->regionIdxCount * innerIndex];
 
     /* See pseudo code from `Font Variations Overview' */
     /* in the OpenType specification.                  */
 
     /* outer loop steps through master designs to be blended */
     for ( master = 0; master < varData->regionIdxCount; master++ )
     {
       FT_Fixed  scalar      = FT_FIXED_ONE;
       FT_UInt   regionIndex = varData->regionIndices[master];
 
       GX_AxisCoords  axis = face->blend
                               ->hvar_table
                               ->itemStore.varRegionList[regionIndex]
                                          .axisList;
 
 
       /* inner loop steps through axes in this region */
       for ( j = 0;
             j < face->blend->hvar_table->itemStore.axisCount;
             j++, axis++ )
       {
         FT_Fixed  axisScalar;
 
 
         /* compute the scalar contribution of this axis; */
         /* ignore invalid ranges                         */
         if ( axis->startCoord > axis->peakCoord ||
              axis->peakCoord > axis->endCoord   )
           axisScalar = FT_FIXED_ONE;
 
         else if ( axis->startCoord < 0 &&
                   axis->endCoord > 0   &&
                   axis->peakCoord != 0 )
           axisScalar = FT_FIXED_ONE;
 
         /* peak of 0 means ignore this axis */
         else if ( axis->peakCoord == 0 )
           axisScalar = FT_FIXED_ONE;
 
         /* ignore this region if coords are out of range */
         else if ( face->blend->normalizedcoords[j] < axis->startCoord ||
                   face->blend->normalizedcoords[j] > axis->endCoord   )
           axisScalar = 0;
 
         /* calculate a proportional factor */
         else
         {
           if ( face->blend->normalizedcoords[j] == axis->peakCoord )
             axisScalar = FT_FIXED_ONE;
           else if ( face->blend->normalizedcoords[j] < axis->peakCoord )
             axisScalar =
               FT_DivFix( face->blend->normalizedcoords[j] - axis->startCoord,
                          axis->peakCoord - axis->startCoord );
           else
             axisScalar =
               FT_DivFix( axis->endCoord - face->blend->normalizedcoords[j],
                          axis->endCoord - axis->peakCoord );
         }
 
         /* take product of all the axis scalars */
         scalar = FT_MulFix( scalar, axisScalar );
 
       } /* per-axis loop */
 
       /* get the scaled delta for this region */
       delta       = FT_intToFixed( deltaSet[master] );
       scaledDelta = FT_MulFix( scalar, delta );
 
       /* accumulate the adjustments from each region */
       netAdjustment = netAdjustment + scaledDelta;
 
     } /* per-region loop */
 
     /* apply the accumulated adjustment to derive the interpolated value */
     FT_TRACE5(( "horizontal width %d adjusted by %d units (HVAR)\n",
                 *avalue,
                 FT_fixedToInt( netAdjustment ) ));
 
     *avalue += FT_fixedToInt( netAdjustment );
 
   Exit:
     return error;
   }
 
 
   typedef struct  GX_GVar_Head_
   {
     FT_Long    version;
     FT_UShort  axisCount;
     FT_UShort  globalCoordCount;
     FT_ULong   offsetToCoord;
     FT_UShort  glyphCount;
     FT_UShort  flags;
     FT_ULong   offsetToData;
 
   } GX_GVar_Head;
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    ft_var_load_gvar                                                   */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Parse the `gvar' table if present.  If `fvar' is there, `gvar' had */
   /*    better be there too.                                               */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    face :: The font face.                                             */
   /*                                                                       */
   /* <Return>                                                              */
   /*    FreeType error code.  0 means success.                             */
   /*                                                                       */
   static FT_Error
   ft_var_load_gvar( TT_Face  face )
   {
     FT_Stream     stream = FT_FACE_STREAM( face );
     FT_Memory     memory = stream->memory;
     GX_Blend      blend  = face->blend;
     FT_Error      error;
     FT_UInt       i, j;
     FT_ULong      table_len;
     FT_ULong      gvar_start;
     FT_ULong      offsetToData;
     GX_GVar_Head  gvar_head;
 
     static const FT_Frame_Field  gvar_fields[] =
     {
 
 #undef  FT_STRUCTURE
 #define FT_STRUCTURE  GX_GVar_Head
 
       FT_FRAME_START( 20 ),
         FT_FRAME_LONG  ( version ),
         FT_FRAME_USHORT( axisCount ),
         FT_FRAME_USHORT( globalCoordCount ),
         FT_FRAME_ULONG ( offsetToCoord ),
         FT_FRAME_USHORT( glyphCount ),
         FT_FRAME_USHORT( flags ),
         FT_FRAME_ULONG ( offsetToData ),
       FT_FRAME_END
     };
 
 
     FT_TRACE2(( "GVAR " ));
 
     if ( FT_SET_ERROR( face->goto_table( face,
                                          TTAG_gvar,
                                          stream,
                                          &table_len ) ) )
     {
       FT_TRACE2(( "is missing\n" ));
       goto Exit;
     }
 
     gvar_start = FT_STREAM_POS( );
     if ( FT_STREAM_READ_FIELDS( gvar_fields, &gvar_head ) )
       goto Exit;
 
     if ( gvar_head.version != 0x00010000L )
     {
       FT_TRACE1(( "bad table version\n" ));
       error = FT_THROW( Invalid_Table );
       goto Exit;
     }
 
     if ( gvar_head.axisCount != (FT_UShort)blend->mmvar->num_axis )
     {
       FT_TRACE1(( "ft_var_load_gvar: number of axes in `gvar' and `cvar'\n"
                   "                  table are different\n" ));
       error = FT_THROW( Invalid_Table );
       goto Exit;
     }
 
     /* rough sanity check, ignoring offsets */
     if ( (FT_ULong)gvar_head.globalCoordCount * gvar_head.axisCount >
            table_len / 2 )
     {
       FT_TRACE1(( "ft_var_load_gvar:"
                   " invalid number of global coordinates\n" ));
       error = FT_THROW( Invalid_Table );
       goto Exit;
     }
 
     /* rough sanity check: offsets can be either 2 or 4 bytes, */
     /* and a single variation needs at least 4 bytes per glyph */
     if ( (FT_ULong)gvar_head.glyphCount *
            ( ( gvar_head.flags & 1 ) ? 8 : 6 ) > table_len )
     {
       FT_TRACE1(( "ft_var_load_gvar: invalid number of glyphs\n" ));
       error = FT_THROW( Invalid_Table );
       goto Exit;
     }
 
     FT_TRACE2(( "loaded\n" ));
 
     blend->gvar_size   = table_len;
     blend->tuplecount  = gvar_head.globalCoordCount;
     blend->gv_glyphcnt = gvar_head.glyphCount;
     offsetToData       = gvar_start + gvar_head.offsetToData;
 
     FT_TRACE5(( "gvar: there are %d shared coordinates:\n",
                 blend->tuplecount ));
 
     if ( FT_NEW_ARRAY( blend->glyphoffsets, blend->gv_glyphcnt + 1 ) )
       goto Exit;
 
     if ( gvar_head.flags & 1 )
     {
       /* long offsets (one more offset than glyphs, to mark size of last) */
       if ( FT_FRAME_ENTER( ( blend->gv_glyphcnt + 1 ) * 4L ) )
         goto Exit;
 
       for ( i = 0; i <= blend->gv_glyphcnt; i++ )
         blend->glyphoffsets[i] = offsetToData + FT_GET_ULONG();
 
       FT_FRAME_EXIT();
     }
     else
     {
       /* short offsets (one more offset than glyphs, to mark size of last) */
       if ( FT_FRAME_ENTER( ( blend->gv_glyphcnt + 1 ) * 2L ) )
         goto Exit;
 
       for ( i = 0; i <= blend->gv_glyphcnt; i++ )
         blend->glyphoffsets[i] = offsetToData + FT_GET_USHORT() * 2;
                                                /* XXX: Undocumented: `*2'! */
 
       FT_FRAME_EXIT();
     }
 
     if ( blend->tuplecount != 0 )
     {
       if ( FT_NEW_ARRAY( blend->tuplecoords,
                          gvar_head.axisCount * blend->tuplecount ) )
         goto Exit;
 
       if ( FT_STREAM_SEEK( gvar_start + gvar_head.offsetToCoord )         ||
            FT_FRAME_ENTER( blend->tuplecount * gvar_head.axisCount * 2L ) )
         goto Exit;
 
       for ( i = 0; i < blend->tuplecount; i++ )
       {
         FT_TRACE5(( "  [ " ));
         for ( j = 0; j < (FT_UInt)gvar_head.axisCount; j++ )
         {
           blend->tuplecoords[i * gvar_head.axisCount + j] =
             FT_GET_SHORT() * 4;                 /* convert to FT_Fixed */
           FT_TRACE5(( "%.5f ",
             blend->tuplecoords[i * gvar_head.axisCount + j] / 65536.0 ));
         }
         FT_TRACE5(( "]\n" ));
       }
 
       FT_TRACE5(( "\n" ));
 
       FT_FRAME_EXIT();
     }
 
   Exit:
     return error;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    ft_var_apply_tuple                                                 */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Figure out whether a given tuple (design) applies to the current   */
   /*    blend, and if so, what is the scaling factor.                      */
   /*                                                                       */
   /* <Input>                                                               */
   /*    blend           :: The current blend of the font.                  */
   /*                                                                       */
   /*    tupleIndex      :: A flag saying whether this is an intermediate   */
   /*                       tuple or not.                                   */
   /*                                                                       */
   /*    tuple_coords    :: The coordinates of the tuple in normalized axis */
   /*                       units.                                          */
   /*                                                                       */
   /*    im_start_coords :: The initial coordinates where this tuple starts */
   /*                       to apply (for intermediate coordinates).        */
   /*                                                                       */
   /*    im_end_coords   :: The final coordinates after which this tuple no */
   /*                       longer applies (for intermediate coordinates).  */
   /*                                                                       */
   /* <Return>                                                              */
   /*    An FT_Fixed value containing the scaling factor.                   */
   /*                                                                       */
   static FT_Fixed
   ft_var_apply_tuple( GX_Blend   blend,
                       FT_UShort  tupleIndex,
                       FT_Fixed*  tuple_coords,
                       FT_Fixed*  im_start_coords,
                       FT_Fixed*  im_end_coords )
   {
     FT_UInt   i;
     FT_Fixed  apply = 0x10000L;
 
 
     for ( i = 0; i < blend->num_axis; i++ )
     {
       FT_TRACE6(( "    axis coordinate %d (%.5f):\n",
                   i, blend->normalizedcoords[i] / 65536.0 ));
       if ( !( tupleIndex & GX_TI_INTERMEDIATE_TUPLE ) )
         FT_TRACE6(( "      intermediate coordinates %d (%.5f, %.5f):\n",
                     i,
                     im_start_coords[i] / 65536.0,
                     im_end_coords[i] / 65536.0 ));
 
       /* It's not clear why (for intermediate tuples) we don't need     */
       /* to check against start/end -- the documentation says we don't. */
       /* Similarly, it's unclear why we don't need to scale along the   */
       /* axis.                                                          */
 
       if ( tuple_coords[i] == 0 )
       {
         FT_TRACE6(( "      tuple coordinate is zero, ignored\n", i ));
         continue;
       }
 
       if ( blend->normalizedcoords[i] == 0 )
       {
         FT_TRACE6(( "      axis coordinate is zero, stop\n" ));
         apply = 0;
         break;
       }
 
       if ( blend->normalizedcoords[i] == tuple_coords[i] )
       {
         FT_TRACE6(( "      tuple coordinate value %.5f fits perfectly\n",
                     tuple_coords[i] / 65536.0 ));
         /* `apply' does not change */
         continue;
       }
 
       if ( !( tupleIndex & GX_TI_INTERMEDIATE_TUPLE ) )
       {
         /* not an intermediate tuple */
 
         if ( blend->normalizedcoords[i] < FT_MIN( 0, tuple_coords[i] ) ||
              blend->normalizedcoords[i] > FT_MAX( 0, tuple_coords[i] ) )
         {
           FT_TRACE6(( "      tuple coordinate value %.5f is exceeded, stop\n",
                       tuple_coords[i] / 65536.0 ));
           apply = 0;
           break;
         }
 
         FT_TRACE6(( "      tuple coordinate value %.5f fits\n",
                     tuple_coords[i] / 65536.0 ));
         apply = FT_MulDiv( apply,
                            blend->normalizedcoords[i],
                            tuple_coords[i] );
       }
       else
       {
         /* intermediate tuple */
 
         if ( blend->normalizedcoords[i] < im_start_coords[i] ||
              blend->normalizedcoords[i] > im_end_coords[i]   )
         {
           FT_TRACE6(( "      intermediate tuple range [%.5f;%.5f] is exceeded,"
                       " stop\n",
                       im_start_coords[i] / 65536.0,
                       im_end_coords[i] / 65536.0 ));
           apply = 0;
           break;
         }
 
         else if ( blend->normalizedcoords[i] < tuple_coords[i] )
         {
           FT_TRACE6(( "      intermediate tuple range [%.5f;%.5f] fits\n",
                       im_start_coords[i] / 65536.0,
                       im_end_coords[i] / 65536.0 ));
           apply = FT_MulDiv( apply,
                              blend->normalizedcoords[i] - im_start_coords[i],
                              tuple_coords[i] - im_start_coords[i] );
         }
 
         else
         {
           FT_TRACE6(( "      intermediate tuple range [%.5f;%.5f] fits\n",
                       im_start_coords[i] / 65536.0,
                       im_end_coords[i] / 65536.0 ));
           apply = FT_MulDiv( apply,
                              im_end_coords[i] - blend->normalizedcoords[i],
                              im_end_coords[i] - tuple_coords[i] );
         }
       }
     }
 
     FT_TRACE6(( "    apply factor is %.5f\n", apply / 65536.0 ));
 
     return apply;
   }
 
 
   /*************************************************************************/
   /*************************************************************************/
   /*****                                                               *****/
   /*****               MULTIPLE MASTERS SERVICE FUNCTIONS              *****/
   /*****                                                               *****/
   /*************************************************************************/
   /*************************************************************************/
 
 
   typedef struct  GX_FVar_Head_
   {
     FT_Long    version;
     FT_UShort  offsetToData;
     FT_UShort  countSizePairs;
     FT_UShort  axisCount;
     FT_UShort  axisSize;
     FT_UShort  instanceCount;
     FT_UShort  instanceSize;
 
   } GX_FVar_Head;
 
 
   typedef struct  fvar_axis_
   {
     FT_ULong   axisTag;
     FT_Fixed   minValue;
     FT_Fixed   defaultValue;
     FT_Fixed   maxValue;
     FT_UShort  flags;
     FT_UShort  nameID;
 
   } GX_FVar_Axis;
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    TT_Get_MM_Var                                                      */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Check that the font's `fvar' table is valid, parse it, and return  */
   /*    those data.                                                        */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    face   :: The font face.                                           */
   /*              TT_Get_MM_Var initializes the blend structure.           */
   /*                                                                       */
   /* <Output>                                                              */
   /*    master :: The `fvar' data (must be freed by caller).  Can be NULL, */
   /*              which makes this function simply load MM support.        */
   /*                                                                       */
   /* <Return>                                                              */
   /*    FreeType error code.  0 means success.                             */
   /*                                                                       */
   FT_LOCAL_DEF( FT_Error )
   TT_Get_MM_Var( TT_Face      face,
                  FT_MM_Var*  *master )
   {
     FT_Stream            stream = face->root.stream;
     FT_Memory            memory = face->root.memory;
     FT_ULong             table_len;
     FT_Error             error  = FT_Err_Ok;
     FT_ULong             fvar_start;
     FT_Int               i, j;
     FT_MM_Var*           mmvar = NULL;
     FT_Fixed*            next_coords;
     FT_String*           next_name;
     FT_Var_Axis*         a;
     FT_Var_Named_Style*  ns;
     GX_FVar_Head         fvar_head;
     FT_Bool              usePsName;
 
     static const FT_Frame_Field  fvar_fields[] =
     {
 
 #undef  FT_STRUCTURE
 #define FT_STRUCTURE  GX_FVar_Head
 
       FT_FRAME_START( 16 ),
         FT_FRAME_LONG  ( version ),
         FT_FRAME_USHORT( offsetToData ),
         FT_FRAME_USHORT( countSizePairs ),
         FT_FRAME_USHORT( axisCount ),
         FT_FRAME_USHORT( axisSize ),
         FT_FRAME_USHORT( instanceCount ),
         FT_FRAME_USHORT( instanceSize ),
       FT_FRAME_END
     };
 
     static const FT_Frame_Field  fvaraxis_fields[] =
     {
 
 #undef  FT_STRUCTURE
 #define FT_STRUCTURE  GX_FVar_Axis
 
       FT_FRAME_START( 20 ),
         FT_FRAME_ULONG ( axisTag ),
         FT_FRAME_LONG  ( minValue ),
         FT_FRAME_LONG  ( defaultValue ),
         FT_FRAME_LONG  ( maxValue ),
         FT_FRAME_USHORT( flags ),
         FT_FRAME_USHORT( nameID ),
       FT_FRAME_END
     };
 
 
     /* read the font data and set up the internal representation */
     /* if not already done                                       */
 
     if ( !face->blend )
     {
       FT_TRACE2(( "FVAR " ));
 
       /* both `fvar' and `gvar' must be present */
       if ( FT_SET_ERROR( face->goto_table( face, TTAG_gvar,
                                            stream, &table_len ) ) )
       {
         /* CFF2 is an alternate to gvar here */
         if ( FT_SET_ERROR( face->goto_table( face, TTAG_CFF2,
                                              stream, &table_len ) ) )
         {
           FT_TRACE1(( "\n"
                       "TT_Get_MM_Var: `gvar' or `CFF2' table is missing\n" ));
           goto Exit;
         }
       }
 
       if ( FT_SET_ERROR( face->goto_table( face, TTAG_fvar,
                                            stream, &table_len ) ) )
       {
         FT_TRACE1(( "is missing\n" ));
         goto Exit;
       }
 
       fvar_start = FT_STREAM_POS( );
 
       /* the validity of the `fvar' header data was already checked */
       /* in function `sfnt_init_face'                               */
       if ( FT_STREAM_READ_FIELDS( fvar_fields, &fvar_head ) )
         goto Exit;
 
       usePsName = FT_BOOL( fvar_head.instanceSize ==
                            6 + 4 * fvar_head.axisCount );
 
       FT_TRACE2(( "loaded\n" ));
 
       FT_TRACE5(( "number of GX style axes: %d\n", fvar_head.axisCount ));
 
       if ( FT_NEW( face->blend ) )
         goto Exit;
 
       /* cannot overflow 32-bit arithmetic because of limits above */
       face->blend->mmvar_len =
         sizeof ( FT_MM_Var ) +
         fvar_head.axisCount * sizeof ( FT_Var_Axis ) +
         fvar_head.instanceCount * sizeof ( FT_Var_Named_Style ) +
         fvar_head.instanceCount * fvar_head.axisCount * sizeof ( FT_Fixed ) +
         5 * fvar_head.axisCount;
 
       if ( FT_ALLOC( mmvar, face->blend->mmvar_len ) )
         goto Exit;
       face->blend->mmvar = mmvar;
 
       /* set up pointers and offsets into the `mmvar' array; */
       /* the data gets filled in later on                    */
 
       mmvar->num_axis =
         fvar_head.axisCount;
       mmvar->num_designs =
         ~0U;                   /* meaningless in this context; each glyph */
                                /* may have a different number of designs  */
                                /* (or tuples, as called by Apple)         */
       mmvar->num_namedstyles =
         fvar_head.instanceCount;
       mmvar->axis =
         (FT_Var_Axis*)&( mmvar[1] );
       mmvar->namedstyle =
         (FT_Var_Named_Style*)&( mmvar->axis[fvar_head.axisCount] );
 
       next_coords =
         (FT_Fixed*)&( mmvar->namedstyle[fvar_head.instanceCount] );
       for ( i = 0; i < fvar_head.instanceCount; i++ )
       {
         mmvar->namedstyle[i].coords  = next_coords;
         next_coords                 += fvar_head.axisCount;
       }
 
       next_name = (FT_String*)next_coords;
       for ( i = 0; i < fvar_head.axisCount; i++ )
       {
         mmvar->axis[i].name  = next_name;
         next_name           += 5;
       }
 
       /* now fill in the data */
 
       if ( FT_STREAM_SEEK( fvar_start + fvar_head.offsetToData ) )
         goto Exit;
 
       a = mmvar->axis;
       for ( i = 0; i < fvar_head.axisCount; i++ )
       {
         GX_FVar_Axis  axis_rec;
 
 
         if ( FT_STREAM_READ_FIELDS( fvaraxis_fields, &axis_rec ) )
           goto Exit;
         a->tag     = axis_rec.axisTag;
         a->minimum = axis_rec.minValue;
         a->def     = axis_rec.defaultValue;
         a->maximum = axis_rec.maxValue;
         a->strid   = axis_rec.nameID;
 
         a->name[0] = (FT_String)(   a->tag >> 24 );
         a->name[1] = (FT_String)( ( a->tag >> 16 ) & 0xFF );
         a->name[2] = (FT_String)( ( a->tag >>  8 ) & 0xFF );
         a->name[3] = (FT_String)( ( a->tag       ) & 0xFF );
         a->name[4] = '\0';
 
         if ( a->minimum > a->def ||
              a->def > a->maximum )
         {
           FT_TRACE2(( "TT_Get_MM_Var:"
                       " invalid \"%s\" axis record; disabling\n",
                       a->name ));
 
           a->minimum = a->def;
           a->maximum = a->def;
         }
 
         FT_TRACE5(( "  \"%s\": minimum=%.5f, default=%.5f, maximum=%.5f\n",
                     a->name,
                     a->minimum / 65536.0,
                     a->def / 65536.0,
                     a->maximum / 65536.0 ));
 
         a++;
       }
 
       FT_TRACE5(( "\n" ));
 
       ns = mmvar->namedstyle;
       for ( i = 0; i < fvar_head.instanceCount; i++, ns++ )
       {
         /* PostScript names add 2 bytes to the instance record size */
         if ( FT_FRAME_ENTER( ( usePsName ? 6L : 4L ) +
                              4L * fvar_head.axisCount ) )
           goto Exit;
 
         ns->strid       =    FT_GET_USHORT();
         (void) /* flags = */ FT_GET_USHORT();
 
         for ( j = 0; j < fvar_head.axisCount; j++ )
           ns->coords[j] = FT_GET_LONG();
 
         if ( usePsName )
           ns->psid = FT_GET_USHORT();
 
         FT_FRAME_EXIT();
       }
     }
 
     /* fill the output array if requested */
 
     if ( master )
     {
       FT_UInt  n;
 
 
       if ( FT_ALLOC( mmvar, face->blend->mmvar_len ) )
         goto Exit;
       FT_MEM_COPY( mmvar, face->blend->mmvar, face->blend->mmvar_len );
 
       mmvar->axis =
         (FT_Var_Axis*)&( mmvar[1] );
       mmvar->namedstyle =
         (FT_Var_Named_Style*)&( mmvar->axis[mmvar->num_axis] );
       next_coords =
         (FT_Fixed*)&( mmvar->namedstyle[mmvar->num_namedstyles] );
 
       for ( n = 0; n < mmvar->num_namedstyles; n++ )
       {
         mmvar->namedstyle[n].coords  = next_coords;
         next_coords                 += mmvar->num_axis;
       }
 
       a         = mmvar->axis;
       next_name = (FT_String*)next_coords;
       for ( n = 0; n < mmvar->num_axis; n++ )
       {
         a->name = next_name;
 
         /* standard PostScript names for some standard apple tags */
         if ( a->tag == TTAG_wght )
           a->name = (char*)"Weight";
         else if ( a->tag == TTAG_wdth )
           a->name = (char*)"Width";
         else if ( a->tag == TTAG_opsz )
           a->name = (char*)"OpticalSize";
         else if ( a->tag == TTAG_slnt )
           a->name = (char*)"Slant";
 
         next_name += 5;
         a++;
       }
 
       *master = mmvar;
     }
 
   Exit:
     return error;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    TT_Set_MM_Blend                                                    */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Set the blend (normalized) coordinates for this instance of the    */
   /*    font.  Check that the `gvar' table is reasonable and does some     */
   /*    initial preparation.                                               */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    face       :: The font.                                            */
   /*                  Initialize the blend structure with `gvar' data.     */
   /*                                                                       */
   /* <Input>                                                               */
   /*    num_coords :: The number of available coordinates.  If it is       */
   /*                  larger than the number of axes, ignore the excess    */
   /*                  values.  If it is smaller than the number of axes,   */
   /*                  use the default value (0) for the remaining axes.    */
   /*                                                                       */
   /*    coords     :: An array of `num_coords', each between [-1,1].       */
   /*                                                                       */
   /* <Return>                                                              */
   /*    FreeType error code.  0 means success.                             */
   /*                                                                       */
   FT_LOCAL_DEF( FT_Error )
   TT_Set_MM_Blend( TT_Face    face,
                    FT_UInt    num_coords,
                    FT_Fixed*  coords )
   {
     FT_Error    error = FT_Err_Ok;
     GX_Blend    blend;
     FT_MM_Var*  mmvar;
     FT_UInt     i;
     FT_Bool     is_default_instance = 1;
     FT_Memory   memory = face->root.memory;
 
     enum
     {
       mcvt_retain,
       mcvt_modify,
       mcvt_load
 
     } manageCvt;
 
 
     face->doblend = FALSE;
 
     if ( !face->blend )
     {
       if ( FT_SET_ERROR( TT_Get_MM_Var( face, NULL ) ) )
         goto Exit;
     }
 
     blend = face->blend;
     mmvar = blend->mmvar;
 
     if ( num_coords > mmvar->num_axis )
     {
       FT_TRACE2(( "TT_Set_MM_Blend: only using first %d of %d coordinates\n",
                   mmvar->num_axis, num_coords ));
       num_coords = mmvar->num_axis;
     }
 
     FT_TRACE5(( "normalized design coordinates:\n" ));
 
     for ( i = 0; i < num_coords; i++ )
     {
       FT_TRACE5(( "  %.5f\n", coords[i] / 65536.0 ));
       if ( coords[i] < -0x00010000L || coords[i] > 0x00010000L )
       {
         FT_TRACE1(( "TT_Set_MM_Blend: normalized design coordinate %.5f\n"
                     "                 is out of range [-1;1]\n",
                     coords[i] / 65536.0 ));
         error = FT_THROW( Invalid_Argument );
         goto Exit;
       }
 
       if ( coords[i] != 0 )
         is_default_instance = 0;
     }
 
     FT_TRACE5(( "\n" ));
 
     if ( !face->isCFF2 && !blend->glyphoffsets )
       if ( FT_SET_ERROR( ft_var_load_gvar( face ) ) )
         goto Exit;
 
     if ( !blend->normalizedcoords )
     {
       if ( FT_NEW_ARRAY( blend->normalizedcoords, mmvar->num_axis ) )
         goto Exit;
 
       manageCvt = mcvt_modify;
 
       /* If we have not set the blend coordinates before this, then the  */
       /* cvt table will still be what we read from the `cvt ' table and  */
       /* we don't need to reload it.  We may need to change it though... */
     }
     else
     {
       manageCvt = mcvt_retain;
 
       for ( i = 0; i < num_coords; i++ )
       {
         if ( blend->normalizedcoords[i] != coords[i] )
         {
           manageCvt = mcvt_load;
           break;
         }
       }
 
       for ( ; i < mmvar->num_axis; i++ )
       {
         if ( blend->normalizedcoords[i] != 0 )
         {
           manageCvt = mcvt_load;
           break;
         }
       }
 
       /* If we don't change the blend coords then we don't need to do  */
       /* anything to the cvt table.  It will be correct.  Otherwise we */
       /* no longer have the original cvt (it was modified when we set  */
       /* the blend last time), so we must reload and then modify it.   */
     }
 
     blend->num_axis = mmvar->num_axis;
     FT_MEM_COPY( blend->normalizedcoords,
                  coords,
                  num_coords * sizeof ( FT_Fixed ) );
 
     face->doblend = TRUE;
 
     if ( face->cvt )
     {
       switch ( manageCvt )
       {
       case mcvt_load:
         /* The cvt table has been loaded already; every time we change the */
         /* blend we may need to reload and remodify the cvt table.         */
         FT_FREE( face->cvt );
         face->cvt = NULL;
 
         error = tt_face_load_cvt( face, face->root.stream );
         break;
 
       case mcvt_modify:
         /* The original cvt table is in memory.  All we need to do is */
         /* apply the `cvar' table (if any).                           */
         error = tt_face_vary_cvt( face, face->root.stream );
         break;
 
       case mcvt_retain:
         /* The cvt table is correct for this set of coordinates. */
         break;
       }
     }
 
     face->is_default_instance = is_default_instance;
 
   Exit:
     return error;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    TT_Get_MM_Blend                                                    */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Get the blend (normalized) coordinates for this instance of the    */
   /*    font.                                                              */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    face       :: The font.                                            */
   /*                  Initialize the blend structure with `gvar' data.     */
   /*                                                                       */
   /* <Input>                                                               */
   /*    num_coords :: The number of available coordinates.  If it is       */
   /*                  larger than the number of axes, set the excess       */
   /*                  values to 0.                                         */
   /*                                                                       */
   /*    coords     :: An array of `num_coords', each between [-1,1].       */
   /*                                                                       */
   /* <Return>                                                              */
   /*    FreeType error code.  0 means success.                             */
   /*                                                                       */
   FT_LOCAL_DEF( FT_Error )
   TT_Get_MM_Blend( TT_Face    face,
                    FT_UInt    num_coords,
                    FT_Fixed*  coords )
   {
     FT_Error  error = FT_Err_Ok;
     GX_Blend  blend;
     FT_UInt   i, nc;
 
 
     if ( !face->blend )
     {
       if ( FT_SET_ERROR( TT_Get_MM_Var( face, NULL ) ) )
         return error;
     }
 
     blend = face->blend;
 
     nc = num_coords;
     if ( num_coords > blend->num_axis )
     {
       FT_TRACE2(( "TT_Get_MM_Blend: only using first %d of %d coordinates\n",
                   blend->num_axis, num_coords ));
       nc = blend->num_axis;
     }
 
     if ( face->doblend )
     {
       for ( i = 0; i < nc; i++ )
         coords[i] = blend->normalizedcoords[i];
     }
     else
     {
       for ( i = 0; i < nc; i++ )
         coords[i] = 0;
     }
 
     for ( ; i < num_coords; i++ )
       coords[i] = 0;
 
     return FT_Err_Ok;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    TT_Set_Var_Design                                                  */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Set the coordinates for the instance, measured in the user         */
   /*    coordinate system.  Parse the `avar' table (if present) to convert */
   /*    from user to normalized coordinates.                               */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    face       :: The font face.                                       */
   /*                  Initialize the blend struct with `gvar' data.        */
   /*                                                                       */
   /* <Input>                                                               */
   /*    num_coords :: The number of available coordinates.  If it is       */
   /*                  larger than the number of axes, ignore the excess    */
   /*                  values.  If it is smaller than the number of axes,   */
   /*                  use the default values for the remaining axes.       */
   /*                                                                       */
   /*    coords     :: A coordinate array with `num_coords' elements.       */
   /*                                                                       */
   /* <Return>                                                              */
   /*    FreeType error code.  0 means success.                             */
   /*                                                                       */
   FT_LOCAL_DEF( FT_Error )
   TT_Set_Var_Design( TT_Face    face,
                      FT_UInt    num_coords,
                      FT_Fixed*  coords )
   {
     FT_Error        error      = FT_Err_Ok;
     FT_Fixed*       normalized = NULL;
     GX_Blend        blend;
     FT_MM_Var*      mmvar;
     FT_UInt         i, j;
     FT_Var_Axis*    a;
     GX_AVarSegment  av;
     FT_Memory       memory = face->root.memory;
 
 
     if ( !face->blend )
     {
       if ( FT_SET_ERROR( TT_Get_MM_Var( face, NULL ) ) )
         goto Exit;
     }
 
     blend = face->blend;
     mmvar = blend->mmvar;
 
     if ( num_coords > mmvar->num_axis )
     {
       FT_TRACE2(( "TT_Set_Var_Design:"
                   " only using first %d of %d coordinates\n",
                   mmvar->num_axis, num_coords ));
       num_coords = mmvar->num_axis;
     }
 
     /* Axis normalization is a two-stage process.  First we normalize */
     /* based on the [min,def,max] values for the axis to be [-1,0,1]. */
     /* Then, if there's an `avar' table, we renormalize this range.   */
 
     if ( FT_NEW_ARRAY( normalized, mmvar->num_axis ) )
       goto Exit;
 
     FT_TRACE5(( "design coordinates:\n" ));
 
     a = mmvar->axis;
     for ( i = 0; i < num_coords; i++, a++ )
     {
       FT_Fixed  coord = coords[i];
 
 
       FT_TRACE5(( "  %.5f\n", coord / 65536.0 ));
       if ( coord > a->maximum || coord < a->minimum )
       {
         FT_TRACE1((
           "TT_Set_Var_Design: design coordinate %.5f\n"
           "                   is out of range [%.5f;%.5f]; clamping\n",
           coord / 65536.0,
           a->minimum / 65536.0,
           a->maximum / 65536.0 ));
 
         if ( coord > a->maximum)
           coord = a->maximum;
         else
           coord = a->minimum;
       }
 
       if ( coord < a->def )
         normalized[i] = -FT_DivFix( coords[i] - a->def,
                                     a->minimum - a->def );
       else if ( coord > a->def )
         normalized[i] = FT_DivFix( coords[i] - a->def,
                                    a->maximum - a->def );
       else
         normalized[i] = 0;
     }
 
     FT_TRACE5(( "\n" ));
 
     for ( ; i < mmvar->num_axis; i++ )
       normalized[i] = 0;
 
     if ( !blend->avar_checked )
       ft_var_load_avar( face );
 
     if ( blend->avar_segment )
     {
       FT_TRACE5(( "normalized design coordinates"
                   " before applying `avar' data:\n" ));
 
       av = blend->avar_segment;
       for ( i = 0; i < mmvar->num_axis; i++, av++ )
       {
         for ( j = 1; j < (FT_UInt)av->pairCount; j++ )
         {
           if ( normalized[i] < av->correspondence[j].fromCoord )
           {
             FT_TRACE5(( "  %.5f\n", normalized[i] / 65536.0 ));
 
             normalized[i] =
               FT_MulDiv( normalized[i] - av->correspondence[j - 1].fromCoord,
                          av->correspondence[j].toCoord -
                            av->correspondence[j - 1].toCoord,
                          av->correspondence[j].fromCoord -
                            av->correspondence[j - 1].fromCoord ) +
               av->correspondence[j - 1].toCoord;
             break;
           }
         }
       }
     }
 
     error = TT_Set_MM_Blend( face, mmvar->num_axis, normalized );
 
   Exit:
     FT_FREE( normalized );
     return error;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    TT_Get_Var_Design                                                  */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Get the design coordinates of the currently selected interpolated  */
   /*    font.                                                              */
   /*                                                                       */
   /* <Input>                                                               */
   /*    face       :: A handle to the source face.                         */
   /*                                                                       */
   /*    num_coords :: The number of design coordinates to retrieve.  If it */
   /*                  is larger than the number of axes, set the excess    */
   /*                  values to~0.                                         */
   /*                                                                       */
   /* <Output>                                                              */
   /*    coords     :: The design coordinates array.                        */
   /*                                                                       */
   /* <Return>                                                              */
   /*    FreeType error code.  0~means success.                             */
   /*                                                                       */
   FT_LOCAL_DEF( FT_Error )
   TT_Get_Var_Design( TT_Face    face,
                      FT_UInt    num_coords,
                      FT_Fixed*  coords )
   {
     FT_Error  error = FT_Err_Ok;
 
     GX_Blend      blend;
     FT_MM_Var*    mmvar;
     FT_Var_Axis*  a;
 
     FT_UInt  i, j, nc;
 
 
     if ( !face->blend )
     {
       if ( FT_SET_ERROR( TT_Get_MM_Var( face, NULL ) ) )
         return error;
     }
 
     blend = face->blend;
 
     nc = num_coords;
     if ( num_coords > blend->num_axis )
     {
       FT_TRACE2(( "TT_Get_Var_Design: only using first %d of %d coordinates\n",
                   blend->num_axis, num_coords ));
       nc = blend->num_axis;
     }
 
     if ( face->doblend )
     {
       for ( i = 0; i < nc; i++ )
         coords[i] = blend->normalizedcoords[i];
     }
     else
     {
       for ( i = 0; i < nc; i++ )
         coords[i] = 0;
     }
 
     for ( ; i < num_coords; i++ )
       coords[i] = 0;
 
     if ( !blend->avar_checked )
       ft_var_load_avar( face );
 
     if ( blend->avar_segment )
     {
       GX_AVarSegment  av = blend->avar_segment;
 
 
       FT_TRACE5(( "design coordinates"
                   " after removing `avar' distortion:\n" ));
 
       for ( i = 0; i < nc; i++, av++ )
       {
         for ( j = 1; j < (FT_UInt)av->pairCount; j++ )
         {
           if ( coords[i] < av->correspondence[j].toCoord )
           {
             coords[i] =
               FT_MulDiv( coords[i] - av->correspondence[j - 1].toCoord,
                          av->correspondence[j].fromCoord -
                            av->correspondence[j - 1].fromCoord,
                          av->correspondence[j].toCoord -
                            av->correspondence[j - 1].toCoord ) +
               av->correspondence[j - 1].fromCoord;
 
             FT_TRACE5(( "  %.5f\n", coords[i] / 65536.0 ));
             break;
           }
         }
       }
     }
 
     mmvar = blend->mmvar;
     a     = mmvar->axis;
 
     for ( i = 0; i < nc; i++, a++ )
     {
       if ( coords[i] < 0 )
         coords[i] = a->def + FT_MulFix( coords[i],
                                         a->def - a->minimum );
       else if ( coords[i] > 0 )
         coords[i] = a->def + FT_MulFix( coords[i],
                                         a->maximum - a->def );
       else
         coords[i] = a->def;
     }
 
     return FT_Err_Ok;
   }
 
 
   /*************************************************************************/
   /*************************************************************************/
   /*****                                                               *****/
   /*****                     GX VAR PARSING ROUTINES                   *****/
   /*****                                                               *****/
   /*************************************************************************/
   /*************************************************************************/
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    tt_face_vary_cvt                                                   */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Modify the loaded cvt table according to the `cvar' table and the  */
   /*    font's blend.                                                      */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    face   :: A handle to the target face object.                      */
   /*                                                                       */
   /* <Input>                                                               */
   /*    stream :: A handle to the input stream.                            */
   /*                                                                       */
   /* <Return>                                                              */
   /*    FreeType error code.  0 means success.                             */
   /*                                                                       */
   /*    Most errors are ignored.  It is perfectly valid not to have a      */
   /*    `cvar' table even if there is a `gvar' and `fvar' table.           */
   /*                                                                       */
   FT_LOCAL_DEF( FT_Error )
   tt_face_vary_cvt( TT_Face    face,
                     FT_Stream  stream )
   {
     FT_Error    error;
     FT_Memory   memory = stream->memory;
     FT_ULong    table_start;
     FT_ULong    table_len;
     FT_UInt     tupleCount;
     FT_ULong    offsetToData;
     FT_ULong    here;
     FT_UInt     i, j;
     FT_Fixed*   tuple_coords    = NULL;
     FT_Fixed*   im_start_coords = NULL;
     FT_Fixed*   im_end_coords   = NULL;
     GX_Blend    blend           = face->blend;
     FT_UInt     point_count;
     FT_UShort*  localpoints;
     FT_Short*   deltas;
 
 
     FT_TRACE2(( "CVAR " ));
 
     if ( !blend )
     {
       FT_TRACE2(( "\n"
                   "tt_face_vary_cvt: no blend specified\n" ));
       error = FT_Err_Ok;
       goto Exit;
     }
 
     if ( !face->cvt )
     {
       FT_TRACE2(( "\n"
                   "tt_face_vary_cvt: no `cvt ' table\n" ));
       error = FT_Err_Ok;
       goto Exit;
     }
 
     error = face->goto_table( face, TTAG_cvar, stream, &table_len );
     if ( error )
     {
       FT_TRACE2(( "is missing\n" ));
 
       error = FT_Err_Ok;
       goto Exit;
     }
 
     if ( FT_FRAME_ENTER( table_len ) )
     {
       error = FT_Err_Ok;
       goto Exit;
     }
 
     table_start = FT_Stream_FTell( stream );
     if ( FT_GET_LONG() != 0x00010000L )
     {
       FT_TRACE2(( "bad table version\n" ));
 
       error = FT_Err_Ok;
       goto FExit;
     }
 
     FT_TRACE2(( "loaded\n" ));
 
     if ( FT_NEW_ARRAY( tuple_coords, blend->num_axis )    ||
          FT_NEW_ARRAY( im_start_coords, blend->num_axis ) ||
          FT_NEW_ARRAY( im_end_coords, blend->num_axis )   )
       goto FExit;
 
     tupleCount   = FT_GET_USHORT();
     offsetToData = FT_GET_USHORT();
 
     /* rough sanity test */
     if ( offsetToData + ( tupleCount & GX_TC_TUPLE_COUNT_MASK ) * 4 >
            table_len )
     {
       FT_TRACE2(( "tt_face_vary_cvt:"
                   " invalid CVT variation array header\n" ));
 
       error = FT_THROW( Invalid_Table );
       goto FExit;
     }
 
     offsetToData += table_start;
 
     /* The documentation implies there are flags packed into              */
     /* `tupleCount', but John Jenkins says that shared points don't apply */
     /* to `cvar', and no other flags are defined.                         */
 
     FT_TRACE5(( "cvar: there are %d tuples:\n", tupleCount & 0xFFF ));
 
     for ( i = 0; i < ( tupleCount & 0xFFF ); i++ )
     {
       FT_UInt   tupleDataSize;
       FT_UInt   tupleIndex;
       FT_Fixed  apply;
 
 
       FT_TRACE6(( "  tuple %d:\n", i ));
 
       tupleDataSize = FT_GET_USHORT();
       tupleIndex    = FT_GET_USHORT();
 
       /* There is no provision here for a global tuple coordinate section, */
       /* so John says.  There are no tuple indices, just embedded tuples.  */
 
       if ( tupleIndex & GX_TI_EMBEDDED_TUPLE_COORD )
       {
         for ( j = 0; j < blend->num_axis; j++ )
           tuple_coords[j] = FT_GET_SHORT() * 4;  /* convert from        */
                                                  /* short frac to fixed */
       }
       else
       {
         /* skip this tuple; it makes no sense */
 
         if ( tupleIndex & GX_TI_INTERMEDIATE_TUPLE )
           for ( j = 0; j < 2 * blend->num_axis; j++ )
             (void)FT_GET_SHORT();
 
         offsetToData += tupleDataSize;
         continue;
       }
 
       if ( tupleIndex & GX_TI_INTERMEDIATE_TUPLE )
       {
         for ( j = 0; j < blend->num_axis; j++ )
           im_start_coords[j] = FT_GET_SHORT() * 4;
         for ( j = 0; j < blend->num_axis; j++ )
           im_end_coords[j] = FT_GET_SHORT() * 4;
       }
 
       apply = ft_var_apply_tuple( blend,
                                   (FT_UShort)tupleIndex,
                                   tuple_coords,
                                   im_start_coords,
                                   im_end_coords );
       if ( /* tuple isn't active for our blend */
            apply == 0                                    ||
            /* global points not allowed,           */
            /* if they aren't local, makes no sense */
            !( tupleIndex & GX_TI_PRIVATE_POINT_NUMBERS ) )
       {
         offsetToData += tupleDataSize;
         continue;
       }
 
       here = FT_Stream_FTell( stream );
 
       FT_Stream_SeekSet( stream, offsetToData );
 
       localpoints = ft_var_readpackedpoints( stream,
                                              table_len,
                                              &point_count );
       deltas      = ft_var_readpackeddeltas( stream,
                                              table_len,
                                              point_count == 0 ? face->cvt_size
                                                               : point_count );
       if ( !localpoints || !deltas )
         ; /* failure, ignore it */
 
       else if ( localpoints == ALL_POINTS )
       {
 #ifdef FT_DEBUG_LEVEL_TRACE
         int  count = 0;
 #endif
 
 
         FT_TRACE7(( "    CVT deltas:\n" ));
 
         /* this means that there are deltas for every entry in cvt */
         for ( j = 0; j < face->cvt_size; j++ )
         {
           FT_Long  orig_cvt = face->cvt[j];
 
 
           face->cvt[j] = (FT_Short)( orig_cvt +
                                      FT_MulFix( deltas[j], apply ) );
 
 #ifdef FT_DEBUG_LEVEL_TRACE
           if ( orig_cvt != face->cvt[j] )
           {
             FT_TRACE7(( "      %d: %d -> %d\n",
                         j, orig_cvt, face->cvt[j] ));
             count++;
           }
 #endif
         }
 
 #ifdef FT_DEBUG_LEVEL_TRACE
         if ( !count )
           FT_TRACE7(( "      none\n" ));
 #endif
       }
 
       else
       {
 #ifdef FT_DEBUG_LEVEL_TRACE
         int  count = 0;
 #endif
 
 
         FT_TRACE7(( "    CVT deltas:\n" ));
 
         for ( j = 0; j < point_count; j++ )
         {
           int      pindex;
           FT_Long  orig_cvt;
 
 
           pindex = localpoints[j];
           if ( (FT_ULong)pindex >= face->cvt_size )
             continue;
 
           orig_cvt          = face->cvt[pindex];
           face->cvt[pindex] = (FT_Short)( orig_cvt +
                                           FT_MulFix( deltas[j], apply ) );
 
 #ifdef FT_DEBUG_LEVEL_TRACE
           if ( orig_cvt != face->cvt[pindex] )
           {
             FT_TRACE7(( "      %d: %d -> %d\n",
                         pindex, orig_cvt, face->cvt[pindex] ));
             count++;
           }
 #endif
         }
 
 #ifdef FT_DEBUG_LEVEL_TRACE
         if ( !count )
           FT_TRACE7(( "      none\n" ));
 #endif
       }
 
       if ( localpoints != ALL_POINTS )
         FT_FREE( localpoints );
       FT_FREE( deltas );
 
       offsetToData += tupleDataSize;
 
       FT_Stream_SeekSet( stream, here );
     }
 
     FT_TRACE5(( "\n" ));
 
   FExit:
     FT_FRAME_EXIT();
 
   Exit:
     FT_FREE( tuple_coords );
     FT_FREE( im_start_coords );
     FT_FREE( im_end_coords );
 
     return error;
   }
 
 
   /* Shift the original coordinates of all points between indices `p1' */
   /* and `p2', using the same difference as given by index `ref'.      */
 
   /* modeled after `af_iup_shift' */
 
   static void
   tt_delta_shift( int         p1,
                   int         p2,
                   int         ref,
                   FT_Vector*  in_points,
                   FT_Vector*  out_points )
   {
     int        p;
     FT_Vector  delta;
 
 
     delta.x = out_points[ref].x - in_points[ref].x;
     delta.y = out_points[ref].y - in_points[ref].y;
 
     if ( delta.x == 0 && delta.y == 0 )
       return;
 
     for ( p = p1; p < ref; p++ )
     {
       out_points[p].x += delta.x;
       out_points[p].y += delta.y;
     }
 
     for ( p = ref + 1; p <= p2; p++ )
     {
       out_points[p].x += delta.x;
       out_points[p].y += delta.y;
     }
   }
 
 
   /* Interpolate the original coordinates of all points with indices */
   /* between `p1' and `p2', using `ref1' and `ref2' as the reference */
   /* point indices.                                                  */
 
   /* modeled after `af_iup_interp', `_iup_worker_interpolate', and */
   /* `Ins_IUP'                                                     */
 
   static void
   tt_delta_interpolate( int         p1,
                         int         p2,
                         int         ref1,
                         int         ref2,
                         FT_Vector*  in_points,
                         FT_Vector*  out_points )
   {
     int  p, i;
 
     FT_Pos  out, in1, in2, out1, out2, d1, d2;
 
 
     if ( p1 > p2 )
       return;
 
     /* handle both horizontal and vertical coordinates */
     for ( i = 0; i <= 1; i++ )
     {
       /* shift array pointers so that we can access `foo.y' as `foo.x' */
       in_points  = (FT_Vector*)( (FT_Pos*)in_points + i );
       out_points = (FT_Vector*)( (FT_Pos*)out_points + i );
 
       if ( in_points[ref1].x > in_points[ref2].x )
       {
         p    = ref1;
         ref1 = ref2;
         ref2 = p;
       }
 
       in1  = in_points[ref1].x;
       in2  = in_points[ref2].x;
       out1 = out_points[ref1].x;
       out2 = out_points[ref2].x;
       d1   = out1 - in1;
       d2   = out2 - in2;
 
       if ( out1 == out2 || in1 == in2 )
       {
         for ( p = p1; p <= p2; p++ )
         {
           out = in_points[p].x;
 
           if ( out <= in1 )
             out += d1;
           else if ( out >= in2 )
             out += d2;
           else
             out = out1;
 
           out_points[p].x = out;
         }
       }
       else
       {
         FT_Fixed  scale = FT_DivFix( out2 - out1, in2 - in1 );
 
 
         for ( p = p1; p <= p2; p++ )
         {
           out = in_points[p].x;
 
           if ( out <= in1 )
             out += d1;
           else if ( out >= in2 )
             out += d2;
           else
             out = out1 + FT_MulFix( out - in1, scale );
 
           out_points[p].x = out;
         }
       }
     }
   }
 
 
   /* Interpolate points without delta values, similar to */
   /* the `IUP' hinting instruction.                      */
 
   /* modeled after `Ins_IUP */
 
   static void
   tt_interpolate_deltas( FT_Outline*  outline,
                          FT_Vector*   out_points,
                          FT_Vector*   in_points,
                          FT_Bool*     has_delta )
   {
     FT_Int  first_point;
     FT_Int  end_point;
 
     FT_Int  first_delta;
     FT_Int  cur_delta;
 
     FT_Int    point;
     FT_Short  contour;
 
 
     /* ignore empty outlines */
     if ( !outline->n_contours )
       return;
 
     contour = 0;
     point   = 0;
 
     do
     {
       end_point   = outline->contours[contour];
       first_point = point;
 
       /* search first point that has a delta */
       while ( point <= end_point && !has_delta[point] )
         point++;
 
       if ( point <= end_point )
       {
         first_delta = point;
         cur_delta   = point;
 
         point++;
 
         while ( point <= end_point )
         {
           /* search next point that has a delta  */
           /* and interpolate intermediate points */
           if ( has_delta[point] )
           {
             tt_delta_interpolate( cur_delta + 1,
                                   point - 1,
                                   cur_delta,
                                   point,
                                   in_points,
                                   out_points );
             cur_delta = point;
           }
 
           point++;
         }
 
         /* shift contour if we only have a single delta */
         if ( cur_delta == first_delta )
           tt_delta_shift( first_point,
                           end_point,
                           cur_delta,
                           in_points,
                           out_points );
         else
         {
           /* otherwise handle remaining points       */
           /* at the end and beginning of the contour */
           tt_delta_interpolate( cur_delta + 1,
                                 end_point,
                                 cur_delta,
                                 first_delta,
                                 in_points,
                                 out_points );
 
           if ( first_delta > 0 )
             tt_delta_interpolate( first_point,
                                   first_delta - 1,
                                   cur_delta,
                                   first_delta,
                                   in_points,
                                   out_points );
         }
       }
       contour++;
 
     } while ( contour < outline->n_contours );
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    TT_Vary_Apply_Glyph_Deltas                                         */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Apply the appropriate deltas to the current glyph.                 */
   /*                                                                       */
   /* <Input>                                                               */
   /*    face        :: A handle to the target face object.                 */
   /*                                                                       */
   /*    glyph_index :: The index of the glyph being modified.              */
   /*                                                                       */
   /*    n_points    :: The number of the points in the glyph, including    */
   /*                   phantom points.                                     */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    outline     :: The outline to change.                              */
   /*                                                                       */
   /* <Return>                                                              */
   /*    FreeType error code.  0 means success.                             */
   /*                                                                       */
   FT_LOCAL_DEF( FT_Error )
   TT_Vary_Apply_Glyph_Deltas( TT_Face      face,
                               FT_UInt      glyph_index,
                               FT_Outline*  outline,
                               FT_UInt      n_points )
   {
     FT_Stream   stream = face->root.stream;
     FT_Memory   memory = stream->memory;
     GX_Blend    blend  = face->blend;
 
     FT_Vector*  points_org = NULL;
     FT_Vector*  points_out = NULL;
     FT_Bool*    has_delta  = NULL;
 
     FT_Error    error;
     FT_ULong    glyph_start;
     FT_UInt     tupleCount;
     FT_ULong    offsetToData;
     FT_ULong    here;
     FT_UInt     i, j;
     FT_Fixed*   tuple_coords    = NULL;
     FT_Fixed*   im_start_coords = NULL;
     FT_Fixed*   im_end_coords   = NULL;
     FT_UInt     point_count, spoint_count = 0;
     FT_UShort*  sharedpoints = NULL;
     FT_UShort*  localpoints  = NULL;
     FT_UShort*  points;
     FT_Short    *deltas_x, *deltas_y;
 
 
     if ( !face->doblend || !blend )
       return FT_THROW( Invalid_Argument );
 
     if ( glyph_index >= blend->gv_glyphcnt      ||
          blend->glyphoffsets[glyph_index] ==
            blend->glyphoffsets[glyph_index + 1] )
     {
       FT_TRACE2(( "TT_Vary_Apply_Glyph_Deltas:"
                   " no variation data for this glyph\n" ));
       return FT_Err_Ok;
     }
 
     if ( FT_NEW_ARRAY( points_org, n_points ) ||
          FT_NEW_ARRAY( points_out, n_points ) ||
          FT_NEW_ARRAY( has_delta, n_points )  )
       goto Fail1;
 
     if ( FT_STREAM_SEEK( blend->glyphoffsets[glyph_index] )   ||
          FT_FRAME_ENTER( blend->glyphoffsets[glyph_index + 1] -
                            blend->glyphoffsets[glyph_index] ) )
       goto Fail1;
 
     glyph_start = FT_Stream_FTell( stream );
 
     /* each set of glyph variation data is formatted similarly to `cvar' */
     /* (except we get shared points and global tuples)                   */
 
     if ( FT_NEW_ARRAY( tuple_coords, blend->num_axis )    ||
          FT_NEW_ARRAY( im_start_coords, blend->num_axis ) ||
          FT_NEW_ARRAY( im_end_coords, blend->num_axis )   )
       goto Fail2;
 
     tupleCount   = FT_GET_USHORT();
     offsetToData = FT_GET_USHORT();
 
     /* rough sanity test */
     if ( offsetToData + ( tupleCount & GX_TC_TUPLE_COUNT_MASK ) * 4 >
            blend->gvar_size )
     {
       FT_TRACE2(( "TT_Vary_Apply_Glyph_Deltas:"
                   " invalid glyph variation array header\n" ));
 
       error = FT_THROW( Invalid_Table );
       goto Fail2;
     }
 
     offsetToData += glyph_start;
 
     if ( tupleCount & GX_TC_TUPLES_SHARE_POINT_NUMBERS )
     {
       here = FT_Stream_FTell( stream );
 
       FT_Stream_SeekSet( stream, offsetToData );
 
       sharedpoints = ft_var_readpackedpoints( stream,
                                               blend->gvar_size,
                                               &spoint_count );
       offsetToData = FT_Stream_FTell( stream );
 
       FT_Stream_SeekSet( stream, here );
     }
 
     FT_TRACE5(( "gvar: there are %d tuples:\n",
                 tupleCount & GX_TC_TUPLE_COUNT_MASK ));
 
     for ( j = 0; j < n_points; j++ )
       points_org[j] = outline->points[j];
 
     for ( i = 0; i < ( tupleCount & GX_TC_TUPLE_COUNT_MASK ); i++ )
     {
       FT_UInt   tupleDataSize;
       FT_UInt   tupleIndex;
       FT_Fixed  apply;
 
 
       FT_TRACE6(( "  tuple %d:\n", i ));
 
       tupleDataSize = FT_GET_USHORT();
       tupleIndex    = FT_GET_USHORT();
 
       if ( tupleIndex & GX_TI_EMBEDDED_TUPLE_COORD )
       {
         for ( j = 0; j < blend->num_axis; j++ )
           tuple_coords[j] = FT_GET_SHORT() * 4;   /* convert from        */
                                                   /* short frac to fixed */
       }
       else if ( ( tupleIndex & GX_TI_TUPLE_INDEX_MASK ) >= blend->tuplecount )
       {
         FT_TRACE2(( "TT_Vary_Apply_Glyph_Deltas:"
                     " invalid tuple index\n" ));
 
         error = FT_THROW( Invalid_Table );
         goto Fail2;
       }
       else
         FT_MEM_COPY(
           tuple_coords,
           &blend->tuplecoords[( tupleIndex & 0xFFF ) * blend->num_axis],
           blend->num_axis * sizeof ( FT_Fixed ) );
 
       if ( tupleIndex & GX_TI_INTERMEDIATE_TUPLE )
       {
         for ( j = 0; j < blend->num_axis; j++ )
           im_start_coords[j] = FT_GET_SHORT() * 4;
         for ( j = 0; j < blend->num_axis; j++ )
           im_end_coords[j] = FT_GET_SHORT() * 4;
       }
 
       apply = ft_var_apply_tuple( blend,
                                   (FT_UShort)tupleIndex,
                                   tuple_coords,
                                   im_start_coords,
                                   im_end_coords );
 
       if ( apply == 0 )              /* tuple isn't active for our blend */
       {
         offsetToData += tupleDataSize;
         continue;
       }
 
       here = FT_Stream_FTell( stream );
 
       FT_Stream_SeekSet( stream, offsetToData );
 
       if ( tupleIndex & GX_TI_PRIVATE_POINT_NUMBERS )
       {
         localpoints = ft_var_readpackedpoints( stream,
                                                blend->gvar_size,
                                                &point_count );
         points      = localpoints;
       }
       else
       {
         points      = sharedpoints;
         point_count = spoint_count;
       }
 
       deltas_x = ft_var_readpackeddeltas( stream,
                                           blend->gvar_size,
                                           point_count == 0 ? n_points
                                                            : point_count );
       deltas_y = ft_var_readpackeddeltas( stream,
                                           blend->gvar_size,
                                           point_count == 0 ? n_points
                                                            : point_count );
 
       if ( !points || !deltas_y || !deltas_x )
         ; /* failure, ignore it */
 
       else if ( points == ALL_POINTS )
       {
 #ifdef FT_DEBUG_LEVEL_TRACE
         int  count = 0;
 #endif
 
 
         FT_TRACE7(( "    point deltas:\n" ));
 
         /* this means that there are deltas for every point in the glyph */
         for ( j = 0; j < n_points; j++ )
         {
           FT_Pos  delta_x = FT_MulFix( deltas_x[j], apply );
           FT_Pos  delta_y = FT_MulFix( deltas_y[j], apply );
 
 
           if ( j < n_points - 3 )
           {
             outline->points[j].x += delta_x;
             outline->points[j].y += delta_y;
           }
           else
           {
             /* To avoid double adjustment of advance width or height, */
             /* adjust phantom points only if there is no HVAR or VVAR */
             /* support, respectively.                                 */
             if ( j == ( n_points - 3 )          &&
                  !( face->variation_support   &
                     TT_FACE_FLAG_VAR_HADVANCE ) )
               outline->points[j].x += delta_x;
 
             else if ( j == ( n_points - 2 )        &&
                       !( face->variation_support &
                          TT_FACE_FLAG_VAR_LSB    ) )
               outline->points[j].x += delta_x;
 
             else if ( j == ( n_points - 1 )          &&
                       !( face->variation_support   &
                          TT_FACE_FLAG_VAR_VADVANCE ) )
               outline->points[j].y += delta_y;
 
             else if ( j == ( n_points - 0 )        &&
                       !( face->variation_support &
                          TT_FACE_FLAG_VAR_TSB    ) )
               outline->points[j].y += delta_y;
           }
 
 #ifdef FT_DEBUG_LEVEL_TRACE
           if ( delta_x || delta_y )
           {
             FT_TRACE7(( "      %d: (%d, %d) -> (%d, %d)\n",
                         j,
                         outline->points[j].x - delta_x,
                         outline->points[j].y - delta_y,
                         outline->points[j].x,
                         outline->points[j].y ));
             count++;
           }
 #endif
         }
 
 #ifdef FT_DEBUG_LEVEL_TRACE
         if ( !count )
           FT_TRACE7(( "      none\n" ));
 #endif
       }
 
       else
       {
 #ifdef FT_DEBUG_LEVEL_TRACE
         int  count = 0;
 #endif
 
 
         /* we have to interpolate the missing deltas similar to the */
         /* IUP bytecode instruction                                 */
         for ( j = 0; j < n_points; j++ )
         {
           has_delta[j]  = FALSE;
           points_out[j] = points_org[j];
         }
 
         for ( j = 0; j < point_count; j++ )
         {
           FT_UShort  idx = points[j];
 
 
           if ( idx >= n_points )
             continue;
 
           has_delta[idx] = TRUE;
 
           points_out[idx].x += FT_MulFix( deltas_x[j], apply );
           points_out[idx].y += FT_MulFix( deltas_y[j], apply );
         }
 
         /* no need to handle phantom points here,      */
         /* since solitary points can't be interpolated */
         tt_interpolate_deltas( outline,
                                points_out,
                                points_org,
                                has_delta );
 
         FT_TRACE7(( "    point deltas:\n" ));
 
         for ( j = 0; j < n_points; j++ )
         {
           FT_Pos  delta_x = points_out[j].x - points_org[j].x;
           FT_Pos  delta_y = points_out[j].y - points_org[j].y;
 
 
           outline->points[j].x += delta_x;
           outline->points[j].y += delta_y;
 
 #ifdef FT_DEBUG_LEVEL_TRACE
           if ( delta_x || delta_y )
           {
             FT_TRACE7(( "      %d: (%d, %d) -> (%d, %d)\n",
                         j,
                         outline->points[j].x - delta_x,
                         outline->points[j].y - delta_y,
                         outline->points[j].x,
                         outline->points[j].y ));
             count++;
           }
 #endif
         }
 
 #ifdef FT_DEBUG_LEVEL_TRACE
         if ( !count )
           FT_TRACE7(( "      none\n" ));
 #endif
       }
 
       if ( localpoints != ALL_POINTS )
         FT_FREE( localpoints );
       FT_FREE( deltas_x );
       FT_FREE( deltas_y );
 
       offsetToData += tupleDataSize;
 
       FT_Stream_SeekSet( stream, here );
     }
 
     FT_TRACE5(( "\n" ));
 
   Fail2:
     if ( sharedpoints != ALL_POINTS )
       FT_FREE( sharedpoints );
     FT_FREE( tuple_coords );
     FT_FREE( im_start_coords );
     FT_FREE( im_end_coords );
 
     FT_FRAME_EXIT();
 
   Fail1:
     FT_FREE( points_org );
     FT_FREE( points_out );
     FT_FREE( has_delta );
 
     return error;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    tt_get_var_blend                                                   */
   /*                                                                       */
   /* <Description>                                                         */
   /*    An extended internal version of `TT_Get_MM_Blend' that returns     */
   /*    pointers instead of copying data, without any initialization of    */
   /*    the MM machinery in case it isn't loaded yet.                      */
   /*                                                                       */
   FT_LOCAL_DEF( FT_Error )
   tt_get_var_blend( TT_Face      face,
                     FT_UInt     *num_coords,
                     FT_Fixed*   *coords,
                     FT_MM_Var*  *mm_var )
   {
     if ( face->blend )
     {
       if ( num_coords )
         *num_coords = face->blend->num_axis;
       if ( coords )
         *coords     = face->blend->normalizedcoords;
       if ( mm_var )
         *mm_var     = face->blend->mmvar;
     }
     else
     {
       if ( num_coords )
         *num_coords = 0;
       if ( coords )
         *coords     = NULL;
       if ( mm_var )
         *mm_var     = NULL;
     }
 
     return FT_Err_Ok;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    tt_done_blend                                                      */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Free the blend internal data structure.                            */
   /*                                                                       */
   FT_LOCAL_DEF( void )
   tt_done_blend( TT_Face  face )
   {
     FT_Memory  memory = FT_FACE_MEMORY( face );
     GX_Blend   blend  = face->blend;
 
 
     if ( blend )
     {
       FT_UInt  i, num_axes;
 
 
       /* blend->num_axis might not be set up yet */
       num_axes = blend->mmvar->num_axis;
 
       FT_FREE( blend->normalizedcoords );
       FT_FREE( blend->mmvar );
 
       if ( blend->avar_segment )
       {
         for ( i = 0; i < num_axes; i++ )
           FT_FREE( blend->avar_segment[i].correspondence );
         FT_FREE( blend->avar_segment );
       }
 
       if ( blend->hvar_table )
       {
         if ( blend->hvar_table->itemStore.varData )
         {
           for ( i = 0; i < blend->hvar_table->itemStore.dataCount; i++ )
           {
             FT_FREE( blend->hvar_table->itemStore.varData[i].regionIndices );
             FT_FREE( blend->hvar_table->itemStore.varData[i].deltaSet );
           }
           FT_FREE( blend->hvar_table->itemStore.varData );
         }
 
         if ( blend->hvar_table->itemStore.varRegionList )
         {
           for ( i = 0; i < blend->hvar_table->itemStore.regionCount; i++ )
             FT_FREE( blend->hvar_table->itemStore.varRegionList[i].axisList );
           FT_FREE( blend->hvar_table->itemStore.varRegionList );
         }
 
         FT_FREE( blend->hvar_table->widthMap.innerIndex );
         FT_FREE( blend->hvar_table->widthMap.outerIndex );
         FT_FREE( blend->hvar_table );
       }
 
       FT_FREE( blend->tuplecoords );
       FT_FREE( blend->glyphoffsets );
       FT_FREE( blend );
     }
   }
 
 #endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
 
 
 /* END */
