commit 8739b7da75f305ab391eb36c613210c23243fe5b
Author: Mallikarjun Kamble <mallikarjun.kamble@ittiam.com>
Date:   Tue Feb 14 14:57:11 2023 +0530

    svcdec: Limit min dimensions supported to 32x32
    
    Also added macros for svc decoder max dimensions as well
    
    BUG=oss-fuzz:55874, 55876, 55877, 55888, 55905 and 55911
    Test: svc_dec_fuzzer

diff --git a/decoder/svc/isvcd_defs.h b/decoder/svc/isvcd_defs.h
index 77d6554..4162713 100644
--- a/decoder/svc/isvcd_defs.h
+++ b/decoder/svc/isvcd_defs.h
@@ -42,72 +42,79 @@
 typedef enum
 {
     ERROR_SVC_FIELD_PIC_UNSUPPORTED = 0xC1,
     ERROR_SVC_INV_SCAN_IDX = 0xC2,
     ERROR_SVC_INV_NAL_UNIT = 0xC3,
     ERROR_SVC_INV_SUBSET_SPS = 0xC4
 } isvcd_decoder_error_code_t;
 
 #define FLUSH 2
 
+#define SVCD_MAX_FRAME_WIDTH 4080
+#define SVCD_MAX_FRAME_HEIGHT 4080
+#define SVCD_MAX_FRAME_SIZE (4096 * 2048)
+
+#define SVCD_MIN_FRAME_WIDTH 32
+#define SVCD_MIN_FRAME_HEIGHT 32
+
 #define SCALABLE_BASELINE_PROFILE_IDC 83
 #define SCALABLE_HIGH_PROFILE_IDC 86
 #define SCALABLE_HIGH_INTRA_IDC 118
 
 #define SPS_EXTENSION_NAL 13
 #define PREFIX_UNIT_NAL 14
 #define SUBSET_SPS_NAL 15
 #define CODED_SLICE_EXTENSION_NAL 20
 
 #define EP_SLICE 5
 #define EB_SLICE 6
 #define EI_SLICE 7
 
 #define D_INTRA_IBL 16
 
 #define CAB_INFERRED 0xFF
 
 #define MAX_TOTAL_LYRS (MAX_QUALITY_ID + 1) * (MAX_DEPENDENCY_ID + 1) * 16
 
 #define MAX_QUALITY_LYRS 5 /* ReqRename */
 /*!< Maximum number of layers with same
      dependency id
  */
 #define MAX_DEPENDENCY_LYRS 6 /* ReqRename */
 /*!< Maximum number of layers with
      different dependency id
  */
 
 /** Maximum number of layers without spatial resolution change */
 #define MAX_NUM_LYRS_IN_RES 5
 
 /** Maximum number of dependency layers in a resolution */
 #define MAX_DEP_LYRS_IN_RES 3
 
 /* Maximum number of spatial resolution layers */
 #define MAX_NUM_RES_LYRS 3
 
 /* Maximum number of layers in an access unit */
 #define MAX_NUM_LAYERS MAX_NUM_LYRS_IN_RES *MAX_NUM_RES_LYRS
 
 #define MAX_NUM_PIC_BUFS (32 + 1)
 
 /*SVC Standard Specific Macros*/
 #define MAX_QUALITY_ID 0
 #define MAX_DEPENDENCY_ID 4
 #define MAX_TEMPORAL_ID 7
 #define MAX_PRIORITY_ID 63
 #define MAX_REF_DEP_ID ((MAX_DEPENDENCY_ID << 4) | MAX_QUALITY_ID)
 
 #define BASE_LAYER 0
 #define MEDIAL_ENHANCEMENT_LAYER 1
 #define TARGET_LAYER 2
 
 #define MB_INFER 250
 
 #define SVC_INTER_MB (1 << 0)       /*!< Intra MBs other than IPCM and I_BL */
 #define SVC_INTRA_MB (1 << 1)       /*!< P or B MBs decoded or inferred*/
 #define SVC_IPCM_MB (1 << 2)        /*!< IPCM_MB  decoder or inferred*/
 #define SVC_IBL_MB (1 << 3)         /*!< I_BL MB always inferred */
 #define SVC_INTRA_INTER_MB (1 << 4) /*!< Intra Inter MB */
 
 #endif                              /*_ISVCD_DEFS_H_*/
diff --git a/decoder/svc/isvcd_parse_headers.c b/decoder/svc/isvcd_parse_headers.c
index 7be48c7..6c3e9fb 100644
--- a/decoder/svc/isvcd_parse_headers.c
+++ b/decoder/svc/isvcd_parse_headers.c
@@ -118,777 +118,777 @@ dif
 *
 * \brief
 *    Decodes Sequence parameter set from the SVC bitstream
 *
 * \return
 *    0 on Success and Error code otherwise
 **************************************************************************
 */
 WORD32 isvcd_parse_subset_sps(svc_dec_lyr_struct_t *ps_svc_lyr_dec, dec_bit_stream_t *ps_bitstrm)
 {
     dec_struct_t *ps_dec = &ps_svc_lyr_dec->s_dec;
     UWORD8 i;
     dec_seq_params_t *ps_seq = NULL;
     dec_svc_seq_params_t *ps_subset_seq = NULL;
     dec_subset_seq_params_t *ps_seq_svc_ext;
     UWORD8 u1_profile_idc, u1_level_idc, u1_seq_parameter_set_id, u1_mb_aff_flag = 0;
     UWORD16 i2_max_frm_num;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
     UWORD8 u1_frm, uc_constraint_set0_flag, uc_constraint_set1_flag, uc_constraint_set2_flag;
     WORD32 i4_cropped_ht, i4_cropped_wd;
     UWORD32 u4_temp;
     UWORD64 u8_temp;
     UWORD32 u4_pic_height_in_map_units, u4_pic_width_in_mbs;
     UWORD32 u2_pic_wd = 0;
     UWORD32 u2_pic_ht = 0;
     UWORD32 u2_frm_wd_y = 0;
     UWORD32 u2_frm_ht_y = 0;
     UWORD32 u2_frm_wd_uv = 0;
     UWORD32 u2_frm_ht_uv = 0;
     UWORD32 u2_crop_offset_y = 0;
     UWORD32 u2_crop_offset_uv = 0;
     WORD32 ret;
     /* High profile related syntax element */
     WORD32 i4_i;
     /* G050 */
     UWORD8 u1_frame_cropping_flag,
         u1_frame_cropping_rect_left_ofst = 0, u1_frame_cropping_rect_right_ofst = 0,
         u1_frame_cropping_rect_top_ofst = 0, u1_frame_cropping_rect_bottom_ofst = 0;
     /* G050 */
     /*--------------------------------------------------------------------*/
     /* Decode seq_parameter_set_id and profile and level values           */
     /*--------------------------------------------------------------------*/
     SWITCHONTRACE;
     u1_profile_idc = ih264d_get_bits_h264(ps_bitstrm, 8);
     COPYTHECONTEXT("SPS: profile_idc", u1_profile_idc);
 
     /* G050 */
     uc_constraint_set0_flag = ih264d_get_bit_h264(ps_bitstrm);
     uc_constraint_set1_flag = ih264d_get_bit_h264(ps_bitstrm);
     uc_constraint_set2_flag = ih264d_get_bit_h264(ps_bitstrm);
     UNUSED(uc_constraint_set1_flag);
     UNUSED(uc_constraint_set2_flag);
 
     /*****************************************************/
     /* Read 5 bits for uc_constraint_set3_flag (1 bit)   */
     /* and reserved_zero_4bits (4 bits) - Sushant        */
     /*****************************************************/
     ih264d_get_bits_h264(ps_bitstrm, 5);
     /* G050 */
     u1_level_idc = (UWORD8) ih264d_get_bits_h264(ps_bitstrm, 8);
     COPYTHECONTEXT("SPS: u4_level_idc", u1_level_idc);
 
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u4_temp & MASK_ERR_SEQ_SET_ID) return ERROR_INV_SPS_PPS_T;
     u1_seq_parameter_set_id = u4_temp;
     COPYTHECONTEXT("SPS: seq_parameter_set_id", u1_seq_parameter_set_id);
 
     if(u1_seq_parameter_set_id >= MAX_NUM_SEQ_PARAMS) return ERROR_INV_SPS_PPS_T;
 
     /*--------------------------------------------------------------------*/
     /* Find an seq param entry in seqparam array of decStruct             */
     /*--------------------------------------------------------------------*/
     ps_subset_seq = ps_svc_lyr_dec->pv_scratch_subset_sps;
     memset(ps_subset_seq, 0, sizeof(dec_svc_seq_params_t));
     ps_seq = ps_dec->pv_scratch_sps_pps;
     memset(ps_seq, 0, sizeof(dec_seq_params_t));
 
     if(ps_dec->i4_header_decoded & 1)
     {
         if(NULL != ps_dec->ps_cur_sps)
             *ps_seq = *ps_dec->ps_cur_sps;
         else
             return ERROR_INV_SPS_PPS_T;
     }
 
     ps_seq->u1_profile_idc = u1_profile_idc;
     ps_seq->u1_level_idc = u1_level_idc;
     ps_seq->u1_seq_parameter_set_id = u1_seq_parameter_set_id;
 
     /* subset_seq_sps_will be stored from location 32 : MAX_NUM_SEQ_PARAMS*/
     u1_seq_parameter_set_id += MAX_NUM_SEQ_PARAMS;
     ps_subset_seq->ps_seq = &ps_dec->ps_sps[u1_seq_parameter_set_id];
 
     if((ps_dec->i4_header_decoded & 1) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
        (ps_dec->ps_sps[u1_seq_parameter_set_id].u1_profile_idc != u1_profile_idc))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
 
     if((ps_dec->i4_header_decoded & 1) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
        (ps_dec->ps_sps[u1_seq_parameter_set_id].u1_level_idc != u1_level_idc))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
     /*******************************************************************/
     /* Initializations for high profile - Sushant                      */
     /*******************************************************************/
     ps_seq->i4_chroma_format_idc = 1;
     ps_seq->i4_bit_depth_luma_minus8 = 0;
     ps_seq->i4_bit_depth_chroma_minus8 = 0;
     ps_seq->i4_qpprime_y_zero_transform_bypass_flag = 0;
     ps_seq->i4_seq_scaling_matrix_present_flag = 0;
     if(u1_profile_idc == HIGH_PROFILE_IDC || u1_profile_idc == SCALABLE_BASELINE_PROFILE_IDC ||
        u1_profile_idc == SCALABLE_HIGH_PROFILE_IDC)
     {
         /* reading chroma_format_idc   */
         ps_seq->i4_chroma_format_idc = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
         /* Monochrome is not supported */
         if(ps_seq->i4_chroma_format_idc != 1)
         {
             return ERROR_FEATURE_UNAVAIL;
         }
 
         /* reading bit_depth_luma_minus8   */
         ps_seq->i4_bit_depth_luma_minus8 = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
         if(ps_seq->i4_bit_depth_luma_minus8 != 0)
         {
             return ERROR_FEATURE_UNAVAIL;
         }
 
         /* reading bit_depth_chroma_minus8   */
         ps_seq->i4_bit_depth_chroma_minus8 = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
         if(ps_seq->i4_bit_depth_chroma_minus8 != 0)
         {
             return ERROR_FEATURE_UNAVAIL;
         }
 
         /* reading qpprime_y_zero_transform_bypass_flag   */
         ps_seq->i4_qpprime_y_zero_transform_bypass_flag = (WORD32) ih264d_get_bit_h264(ps_bitstrm);
 
         if(ps_seq->i4_qpprime_y_zero_transform_bypass_flag != 0)
         {
             return ERROR_INV_SPS_PPS_T;
         }
 
         /* reading seq_scaling_matrix_present_flag   */
         ps_seq->i4_seq_scaling_matrix_present_flag = (WORD32) ih264d_get_bit_h264(ps_bitstrm);
 
         if(ps_seq->i4_seq_scaling_matrix_present_flag)
         {
             for(i4_i = 0; i4_i < 8; i4_i++)
             {
                 ps_seq->u1_seq_scaling_list_present_flag[i4_i] = ih264d_get_bit_h264(ps_bitstrm);
 
                 /* initialize u1_use_default_scaling_matrix_flag[i4_i] to zero */
                 /* before calling scaling list                             */
                 ps_seq->u1_use_default_scaling_matrix_flag[i4_i] = 0;
 
                 if(ps_seq->u1_seq_scaling_list_present_flag[i4_i])
                 {
                     if(i4_i < 6)
                     {
                         ret = ih264d_scaling_list(ps_seq->i2_scalinglist4x4[i4_i], 16,
                                                   &ps_seq->u1_use_default_scaling_matrix_flag[i4_i],
                                                   ps_bitstrm);
                     }
                     else
                     {
                         ret = ih264d_scaling_list(ps_seq->i2_scalinglist8x8[i4_i - 6], 64,
                                                   &ps_seq->u1_use_default_scaling_matrix_flag[i4_i],
                                                   ps_bitstrm);
                     }
                     if(ret != OK)
                     {
                         return ret;
                     }
                 }
             }
         }
     }
     /*--------------------------------------------------------------------*/
     /* Decode MaxFrameNum                                                 */
     /*--------------------------------------------------------------------*/
     u8_temp = (UWORD64) 4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u8_temp > MAX_BITS_IN_FRAME_NUM)
     {
         return ERROR_INV_SPS_PPS_T;
     }
     ps_seq->u1_bits_in_frm_num = (UWORD8) u8_temp;
     COPYTHECONTEXT("SPS: log2_max_frame_num_minus4", (ps_seq->u1_bits_in_frm_num - 4));
 
     i2_max_frm_num = (1 << (ps_seq->u1_bits_in_frm_num));
     ps_seq->u2_u4_max_pic_num_minus1 = i2_max_frm_num - 1;
     /*--------------------------------------------------------------------*/
     /* Decode picture order count and related values                      */
     /*--------------------------------------------------------------------*/
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
     if(u4_temp > MAX_PIC_ORDER_CNT_TYPE)
     {
         return ERROR_INV_POC_TYPE_T;
     }
     ps_seq->u1_pic_order_cnt_type = u4_temp;
     COPYTHECONTEXT("SPS: pic_order_cnt_type", ps_seq->u1_pic_order_cnt_type);
 
     ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = 1;
     if(ps_seq->u1_pic_order_cnt_type == 0)
     {
         u8_temp = (UWORD64) 4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         if(u8_temp > MAX_BITS_IN_POC_LSB)
         {
             return ERROR_INV_SPS_PPS_T;
         }
         ps_seq->u1_log2_max_pic_order_cnt_lsb_minus = (UWORD8) u8_temp;
         ps_seq->i4_max_pic_order_cntLsb = (1 << u8_temp);
         COPYTHECONTEXT("SPS: log2_max_pic_order_cnt_lsb_minus4", (u8_temp - 4));
     }
     else if(ps_seq->u1_pic_order_cnt_type == 1)
     {
         ps_seq->u1_delta_pic_order_always_zero_flag = ih264d_get_bit_h264(ps_bitstrm);
         COPYTHECONTEXT("SPS: delta_pic_order_always_zero_flag",
                        ps_seq->u1_delta_pic_order_always_zero_flag);
 
         ps_seq->i4_ofst_for_non_ref_pic = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: offset_for_non_ref_pic", ps_seq->i4_ofst_for_non_ref_pic);
 
         ps_seq->i4_ofst_for_top_to_bottom_field = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: offset_for_top_to_bottom_field",
                        ps_seq->i4_ofst_for_top_to_bottom_field);
 
         u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         if(u4_temp > 255) return ERROR_INV_SPS_PPS_T;
         ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = u4_temp;
         COPYTHECONTEXT("SPS: num_ref_frames_in_pic_order_cnt_cycle",
                        ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle);
 
         for(i = 0; i < ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle; i++)
         {
             ps_seq->i4_ofst_for_ref_frame[i] = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
             COPYTHECONTEXT("SPS: offset_for_ref_frame", ps_seq->i4_ofst_for_ref_frame[i]);
         }
     }
 
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
     if((u4_temp > H264_MAX_REF_PICS))
     {
         return ERROR_NUM_REF;
     }
 
     /* Compare with older num_ref_frames is header is already once */
     if((ps_dec->i4_header_decoded & 1) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
        (ps_dec->ps_sps[u1_seq_parameter_set_id].u1_num_ref_frames != u4_temp))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
     ps_seq->u1_num_ref_frames = u4_temp;
     COPYTHECONTEXT("SPS: num_ref_frames", ps_seq->u1_num_ref_frames);
 
     ps_seq->u1_gaps_in_frame_num_value_allowed_flag = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("SPS: gaps_in_frame_num_value_allowed_flag",
                    ps_seq->u1_gaps_in_frame_num_value_allowed_flag);
     /* SVC_DEC_REVIEW */
     ps_seq->u1_gaps_in_frame_num_value_allowed_flag = 0;
 
     /*--------------------------------------------------------------------*/
     /* Decode FrameWidth and FrameHeight and related values               */
     /*--------------------------------------------------------------------*/
     u8_temp = (UWORD64) 1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     /* Check  for unsupported resolutions*/
     if(u8_temp > (H264_MAX_FRAME_WIDTH >> 4))
     {
         return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
     }
     u4_pic_width_in_mbs = (UWORD32) u8_temp;
     COPYTHECONTEXT("SPS: pic_width_in_mbs_minus1", u4_pic_width_in_mbs - 1);
 
     u8_temp = (UWORD64) 1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u8_temp > (H264_MAX_FRAME_HEIGHT >> 4))
     {
         return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
     }
     u4_pic_height_in_map_units = (UWORD32) u8_temp;
 
     ps_seq->u2_frm_wd_in_mbs = u4_pic_width_in_mbs;
     ps_seq->u2_frm_ht_in_mbs = u4_pic_height_in_map_units;
 
     u2_pic_wd = (u4_pic_width_in_mbs << 4);
     u2_pic_ht = (u4_pic_height_in_map_units << 4);
     /*--------------------------------------------------------------------*/
     /* Get the value of MaxMbAddress and Number of bits needed for it     */
     /*--------------------------------------------------------------------*/
     ps_seq->u2_max_mb_addr = (ps_seq->u2_frm_wd_in_mbs * ps_seq->u2_frm_ht_in_mbs) - 1;
 
     ps_seq->u2_total_num_of_mbs = ps_seq->u2_max_mb_addr + 1;
 
     ps_seq->u1_level_idc = ih264d_correct_level_idc(u1_level_idc, ps_seq->u2_total_num_of_mbs);
 
     u1_frm = ih264d_get_bit_h264(ps_bitstrm);
 
     if((ps_dec->i4_header_decoded & 1) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
        (ps_dec->ps_sps[u1_seq_parameter_set_id].u1_frame_mbs_only_flag != u1_frm))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
     ps_seq->u1_frame_mbs_only_flag = u1_frm;
 
     COPYTHECONTEXT("SPS: frame_mbs_only_flag", u1_frm);
 
     if(!u1_frm) u1_mb_aff_flag = ih264d_get_bit_h264(ps_bitstrm);
     if((ps_dec->i4_header_decoded & 1) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
        (ps_dec->ps_sps[u1_seq_parameter_set_id].u1_mb_aff_flag != u1_mb_aff_flag))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
     if(!u1_frm)
     {
         u2_pic_ht <<= 1;
         ps_seq->u1_mb_aff_flag = u1_mb_aff_flag;
         COPYTHECONTEXT("SPS: mb_adaptive_frame_field_flag", ps_seq->u1_mb_aff_flag);
     }
     else
         ps_seq->u1_mb_aff_flag = 0;
 
     ps_seq->u1_direct_8x8_inference_flag = ih264d_get_bit_h264(ps_bitstrm);
 
     COPYTHECONTEXT("SPS: direct_8x8_inference_flag", ps_seq->u1_direct_8x8_inference_flag);
 
     /* G050 */
     u1_frame_cropping_flag = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("SPS: frame_cropping_flag", u1_frame_cropping_flag);
 
     if(u1_frame_cropping_flag)
     {
         u1_frame_cropping_rect_left_ofst = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: frame_cropping_rect_left_offset", u1_frame_cropping_rect_left_ofst);
         u1_frame_cropping_rect_right_ofst = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: frame_cropping_rect_right_offset", u1_frame_cropping_rect_right_ofst);
         u1_frame_cropping_rect_top_ofst = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: frame_cropping_rect_top_offset", u1_frame_cropping_rect_top_ofst);
         u1_frame_cropping_rect_bottom_ofst = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: frame_cropping_rect_bottom_offset",
                        u1_frame_cropping_rect_bottom_ofst);
     }
     /* G050 */
     ps_seq->u1_vui_parameters_present_flag = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("SPS: vui_parameters_present_flag", ps_seq->u1_vui_parameters_present_flag);
 
     u2_frm_wd_y = u2_pic_wd + (UWORD8) (PAD_LEN_Y_H << 1);
     if(1 == ps_dec->u4_share_disp_buf)
     {
         if(ps_dec->u4_app_disp_width > u2_frm_wd_y) u2_frm_wd_y = ps_dec->u4_app_disp_width;
     }
 
     u2_frm_ht_y = u2_pic_ht + (UWORD8) (PAD_LEN_Y_V << 2);
     u2_frm_wd_uv = u2_pic_wd + (UWORD8) (PAD_LEN_UV_H << 2);
     u2_frm_wd_uv = MAX(u2_frm_wd_uv, u2_frm_wd_y);
 
     u2_frm_ht_uv = (u2_pic_ht >> 1) + (UWORD8) (PAD_LEN_UV_V << 2);
     u2_frm_ht_uv = MAX(u2_frm_ht_uv, (u2_frm_ht_y >> 1));
 
     /* Calculate display picture width, height and start u4_ofst from YUV420 */
     /* pictute buffers as per cropping information parsed above             */
     {
         UWORD16 u2_rgt_ofst = 0;
         UWORD16 u2_lft_ofst = 0;
         UWORD16 u2_top_ofst = 0;
         UWORD16 u2_btm_ofst = 0;
         UWORD8 u1_frm_mbs_flag;
         UWORD8 u1_vert_mult_factor;
 
         if(u1_frame_cropping_flag)
         {
             /* Calculate right and left u4_ofst for cropped picture           */
             u2_rgt_ofst = u1_frame_cropping_rect_right_ofst << 1;
             u2_lft_ofst = u1_frame_cropping_rect_left_ofst << 1;
 
             /* Know frame MBs only u4_flag                                      */
             u1_frm_mbs_flag = (1 == ps_seq->u1_frame_mbs_only_flag);
 
             /* Simplify the vertical u4_ofst calculation from field/frame     */
             u1_vert_mult_factor = (2 - u1_frm_mbs_flag);
 
             /* Calculate bottom and top u4_ofst for cropped  picture          */
             u2_btm_ofst = (u1_frame_cropping_rect_bottom_ofst << u1_vert_mult_factor);
             u2_top_ofst = (u1_frame_cropping_rect_top_ofst << u1_vert_mult_factor);
         }
 
         /* Calculate u4_ofst from start of YUV 420 picture buffer to start of*/
         /* cropped picture buffer                                           */
         u2_crop_offset_y = (u2_frm_wd_y * u2_top_ofst) + (u2_lft_ofst);
         u2_crop_offset_uv =
             (u2_frm_wd_uv * (u2_top_ofst >> 1)) + (u2_lft_ofst >> 1) * YUV420SP_FACTOR;
         /* Calculate the display picture width and height based on crop      */
         /* information                                                       */
         i4_cropped_ht = (WORD32) u2_pic_ht - (WORD32) (u2_btm_ofst + u2_top_ofst);
         i4_cropped_wd = (WORD32) u2_pic_wd - (WORD32) (u2_rgt_ofst + u2_lft_ofst);
 
         if((i4_cropped_ht < MB_SIZE) || (i4_cropped_wd < MB_SIZE))
         {
             return ERROR_INV_SPS_PPS_T;
         }
 
         if((ps_dec->i4_header_decoded & 1) &&
            (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
            (ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id].u2_pic_wd != u2_pic_wd))
         {
             ps_dec->u1_res_changed = 1;
             return IVD_RES_CHANGED;
         }
 
         if((ps_dec->i4_header_decoded & 1) &&
            (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
            (ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id].u2_disp_width != i4_cropped_wd))
         {
             ps_dec->u1_res_changed = 1;
             return IVD_RES_CHANGED;
         }
 
         if((ps_dec->i4_header_decoded & 1) &&
            (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
            (ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id].u2_pic_ht != u2_pic_ht))
         {
             ps_dec->u1_res_changed = 1;
             return IVD_RES_CHANGED;
         }
 
         if((ps_dec->i4_header_decoded & 1) &&
            (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
            (ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id].u2_disp_height != i4_cropped_ht))
         {
             ps_dec->u1_res_changed = 1;
             return IVD_RES_CHANGED;
         }
         /* Check again for unsupported resolutions with updated values*/
-        if((u2_pic_wd > H264_MAX_FRAME_WIDTH) || (u2_pic_ht > H264_MAX_FRAME_HEIGHT) ||
-           (u2_pic_wd < H264_MIN_FRAME_WIDTH) || (u2_pic_ht < H264_MIN_FRAME_HEIGHT) ||
-           (u2_pic_wd * (UWORD32) u2_pic_ht > H264_MAX_FRAME_SIZE))
+        if((u2_pic_wd > SVCD_MAX_FRAME_WIDTH) || (u2_pic_ht > SVCD_MAX_FRAME_HEIGHT) ||
+           (u2_pic_wd < SVCD_MIN_FRAME_WIDTH) || (u2_pic_ht < SVCD_MIN_FRAME_HEIGHT) ||
+           (u2_pic_wd * (UWORD32) u2_pic_ht > SVCD_MAX_FRAME_SIZE))
         {
             return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
         }
 
         /* If MBAff is enabled, decoder support is limited to streams with
          * width less than half of H264_MAX_FRAME_WIDTH.
          * In case of MBAff decoder processes two rows at a time
          */
         if((u2_pic_wd << ps_seq->u1_mb_aff_flag) > H264_MAX_FRAME_WIDTH)
         {
             return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
         }
     }
 
     if(1 == ps_seq->u1_vui_parameters_present_flag)
     {
         ret = ih264d_parse_vui_parametres(&ps_seq->s_vui, ps_bitstrm);
         if(ret != OK) return ret;
     }
     ps_seq_svc_ext = &ps_subset_seq->s_sps_svc_ext;
 
     isvcd_set_default_seq_svc_ext(ps_seq_svc_ext);
 
     if(SCALABLE_BASELINE_PROFILE_IDC == ps_seq->u1_profile_idc ||
        SCALABLE_HIGH_PROFILE_IDC == ps_seq->u1_profile_idc)
     {
         SWITCHONTRACE;
         ps_seq_svc_ext->u1_inter_layer_deblocking_filter_control_present_flag =
             ih264d_get_bit_h264(ps_bitstrm);
         COPYTHECONTEXT("SPS_EXt: u1_inter_layer_deblocking_filter_control_present_flag",
                        ps_seq_svc_ext->u1_inter_layer_deblocking_filter_control_present_flag);
 
         ps_seq_svc_ext->u1_extended_spatial_scalability_idc = ih264d_get_bits_h264(ps_bitstrm, 2);
         COPYTHECONTEXT("SPS_EXt: u1_extended_spatial_scalability_idc",
                        ps_seq_svc_ext->u1_extended_spatial_scalability_idc);
 
         if(ps_seq_svc_ext->u1_extended_spatial_scalability_idc >= 3)
         {
             return ERROR_SVC_INV_SUBSET_SPS;
         }
 
         /* ChromaArrayType = i4_chroma_format_idc  if  separate_colour_plane_flag =
          * 0 for all chroma format except 4:4:4 */
         if(1 == ps_seq->i4_chroma_format_idc || 2 == ps_seq->i4_chroma_format_idc)
         {
             ps_seq_svc_ext->u1_chroma_phase_x_plus1_flag = ih264d_get_bit_h264(ps_bitstrm);
             COPYTHECONTEXT("SPS_EXt: u1_chroma_phase_x_plus1_flag",
                            ps_seq_svc_ext->u1_chroma_phase_x_plus1_flag);
         }
 
         if(1 == ps_seq->i4_chroma_format_idc)
         {
             ps_seq_svc_ext->u1_chroma_phase_y_plus1 = ih264d_get_bits_h264(ps_bitstrm, 2);
             COPYTHECONTEXT("SPS_EXt: u1_chroma_phase_y_plus1",
                            ps_seq_svc_ext->u1_chroma_phase_y_plus1);
 
             if(ps_seq_svc_ext->u1_chroma_phase_y_plus1 >= 3)
             {
                 return ERROR_SVC_INV_SUBSET_SPS;
             }
         }
 
         /* inferred values not covered in isvcd_set_default_seq_svc_ext*/
         ps_seq_svc_ext->u1_seq_ref_layer_chroma_phase_x_plus1_flag =
             ps_seq_svc_ext->u1_chroma_phase_x_plus1_flag;
         ps_seq_svc_ext->u1_seq_ref_layer_chroma_phase_y_plus1 =
             ps_seq_svc_ext->u1_chroma_phase_y_plus1;
 
         if(1 == ps_seq_svc_ext->u1_extended_spatial_scalability_idc)
         {
             if(ps_seq->i4_chroma_format_idc > 0)
             {
                 ps_seq_svc_ext->u1_seq_ref_layer_chroma_phase_x_plus1_flag =
                     ih264d_get_bit_h264(ps_bitstrm);
                 COPYTHECONTEXT("SPS_EXt: u1_seq_ref_layer_chroma_phase_x_plus1_flag",
                                ps_seq_svc_ext->u1_seq_ref_layer_chroma_phase_x_plus1_flag);
 
                 ps_seq_svc_ext->u1_seq_ref_layer_chroma_phase_y_plus1 =
                     ih264d_get_bits_h264(ps_bitstrm, 2);
                 COPYTHECONTEXT("SPS_EXt: u1_seq_ref_layer_chroma_phase_y_plus1",
                                ps_seq_svc_ext->u1_seq_ref_layer_chroma_phase_y_plus1);
 
                 if(ps_seq_svc_ext->u1_seq_ref_layer_chroma_phase_y_plus1 >= 3)
                 {
                     return ERROR_SVC_INV_SUBSET_SPS;
                 }
             }
 
             ps_seq_svc_ext->i4_seq_scaled_ref_layer_left_offset =
                 ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
             COPYTHECONTEXT("SPS_EXt: i4_seq_scaled_ref_layer_left_offset",
                            ps_seq_svc_ext->i4_seq_scaled_ref_layer_left_offset);
 
             if(ps_seq_svc_ext->i4_seq_scaled_ref_layer_left_offset >= MAX_SCLD_REF_LAYER_OFFSET ||
                ps_seq_svc_ext->i4_seq_scaled_ref_layer_left_offset < MIN_SCLD_REF_LAYER_OFFSET)
             {
                 return ERROR_SVC_INV_SUBSET_SPS;
             }
 
             ps_seq_svc_ext->i4_seq_scaled_ref_layer_top_offset =
                 ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
             COPYTHECONTEXT("SPS_EXt: i4_seq_scaled_ref_layer_top_offset",
                            ps_seq_svc_ext->i4_seq_scaled_ref_layer_top_offset);
 
             if(ps_seq_svc_ext->i4_seq_scaled_ref_layer_top_offset >= MAX_SCLD_REF_LAYER_OFFSET ||
                ps_seq_svc_ext->i4_seq_scaled_ref_layer_top_offset < MIN_SCLD_REF_LAYER_OFFSET)
             {
                 return ERROR_SVC_INV_SUBSET_SPS;
             }
 
             ps_seq_svc_ext->i4_seq_scaled_ref_layer_right_offset =
                 ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
             COPYTHECONTEXT("SPS_EXt: i4_seq_scaled_ref_layer_right_offset",
                            ps_seq_svc_ext->i4_seq_scaled_ref_layer_right_offset);
 
             if(ps_seq_svc_ext->i4_seq_scaled_ref_layer_right_offset >= MAX_SCLD_REF_LAYER_OFFSET ||
                ps_seq_svc_ext->i4_seq_scaled_ref_layer_right_offset < MIN_SCLD_REF_LAYER_OFFSET)
             {
                 return ERROR_SVC_INV_SUBSET_SPS;
             }
 
             ps_seq_svc_ext->i4_seq_scaled_ref_layer_bottom_offset =
                 ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
             COPYTHECONTEXT("SPS_EXt: i4_seq_scaled_ref_layer_bottom_offset",
                            ps_seq_svc_ext->i4_seq_scaled_ref_layer_bottom_offset);
 
             if(ps_seq_svc_ext->i4_seq_scaled_ref_layer_bottom_offset >= MAX_SCLD_REF_LAYER_OFFSET ||
                ps_seq_svc_ext->i4_seq_scaled_ref_layer_bottom_offset < MIN_SCLD_REF_LAYER_OFFSET)
             {
                 return ERROR_INV_SLICE_HDR_T;
             }
         }
 
         ps_seq_svc_ext->u1_seq_tcoeff_level_prediction_flag = ih264d_get_bit_h264(ps_bitstrm);
         COPYTHECONTEXT("SPS_EXt: u1_seq_tcoeff_level_prediction_flag",
                        ps_seq_svc_ext->u1_seq_tcoeff_level_prediction_flag);
 
         if(1 == ps_seq_svc_ext->u1_seq_tcoeff_level_prediction_flag)
         {
             ps_seq_svc_ext->u1_adaptive_tcoeff_level_prediction_flag =
                 ih264d_get_bit_h264(ps_bitstrm);
             COPYTHECONTEXT("SPS_EXt: u1_adaptive_tcoeff_level_prediction_flag",
                            ps_seq_svc_ext->u1_adaptive_tcoeff_level_prediction_flag);
         }
 
         ps_seq_svc_ext->u1_slice_header_restriction_flag = ih264d_get_bit_h264(ps_bitstrm);
         COPYTHECONTEXT("SPS_EXt: u1_slice_header_restriction_flag",
                        ps_seq_svc_ext->u1_slice_header_restriction_flag);
 
         ps_seq_svc_ext->u1_svc_vui_parameters_present_flag = ih264d_get_bit_h264(ps_bitstrm);
         COPYTHECONTEXT("SPS_EXt: u1_svc_vui_parameters_present_flag",
                        ps_seq_svc_ext->u1_svc_vui_parameters_present_flag);
 
         if(1 == ps_seq_svc_ext->u1_svc_vui_parameters_present_flag)
         {
             if(NULL ==
                ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id].s_sps_svc_ext.ps_svc_vui_ext)
             {
                 void *pv_buf;
                 UWORD32 size;
                 /* Memory allocation only if VUI is enabled in a particular subset SPS*/
                 size = sizeof(svc_vui_ext_t);
                 pv_buf = ps_dec->pf_aligned_alloc(ps_dec->pv_mem_ctxt, 128, size);
                 RETURN_IF((NULL == pv_buf), IV_FAIL);
                 memset(pv_buf, 0, size);
                 ps_seq_svc_ext->ps_svc_vui_ext = pv_buf;
                 ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id]
                     .s_sps_svc_ext.ps_svc_vui_ext = pv_buf;
             }
             else
             {
                 ps_seq_svc_ext->ps_svc_vui_ext =
                     ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id]
                         .s_sps_svc_ext.ps_svc_vui_ext;
             }
             ret = isvcd_parse_vui_ext_parametres(ps_seq_svc_ext->ps_svc_vui_ext, ps_bitstrm);
             if(ret != OK) return ret;
         }
     }
     /* Add conditions for SCALABLE BASELINE PROFILE */
     if(SCALABLE_BASELINE_PROFILE_IDC == ps_seq->u1_profile_idc ||
        ((SCALABLE_HIGH_PROFILE_IDC == ps_seq->u1_profile_idc) && (1 == uc_constraint_set0_flag)))
     {
         if(ps_seq->i4_chroma_format_idc != 1)
         {
             return ERROR_FEATURE_UNAVAIL;
         }
 
         if(ps_seq->i4_bit_depth_luma_minus8 != 0)
         {
             return ERROR_FEATURE_UNAVAIL;
         }
 
         if(ps_seq->i4_bit_depth_chroma_minus8 != 0)
         {
             return ERROR_FEATURE_UNAVAIL;
         }
 
         if(ps_seq->i4_qpprime_y_zero_transform_bypass_flag != 0)
         {
             return ERROR_FEATURE_UNAVAIL;
         }
 
         if(ps_seq->u1_frame_mbs_only_flag != 1)
         {
             return ERROR_FEATURE_UNAVAIL;
         }
 
         if((0 != ps_seq_svc_ext->i4_seq_scaled_ref_layer_left_offset % 16) &&
            (0 != ps_seq_svc_ext->i4_seq_scaled_ref_layer_top_offset % 16))
         {
             return ERROR_FEATURE_UNAVAIL;
         }
     }
     /* Compare older num_reorder_frames with the new one if header is already
      * decoded */
     if((ps_dec->i4_header_decoded & 1) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_vui_parameters_present_flag) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].s_vui.u1_bitstream_restriction_flag))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
     /* In case bitstream read has exceeded the filled size, then return an error */
     if(EXCEED_OFFSET(ps_bitstrm))
     {
         return ERROR_INV_SPS_PPS_T;
     }
 
     /*--------------------------------------------------------------------*/
     /* All initializations to ps_dec are beyond this point                */
     /*--------------------------------------------------------------------*/
     {
         WORD32 reorder_depth = ih264d_get_dpb_size(ps_seq);
         if((1 == ps_seq->u1_vui_parameters_present_flag) &&
            (1 == ps_seq->s_vui.u1_bitstream_restriction_flag))
         {
             reorder_depth = ps_seq->s_vui.u4_num_reorder_frames + 1;
         }
 
         if(reorder_depth > H264_MAX_REF_PICS)
         {
             return ERROR_INV_SPS_PPS_T;
         }
 
         if(ps_seq->u1_frame_mbs_only_flag != 1) reorder_depth *= 2;
         ps_subset_seq->i4_reorder_depth = reorder_depth + DISPLAY_LATENCY;
     }
     ps_subset_seq->u2_disp_height = i4_cropped_ht;
     ps_subset_seq->u2_disp_width = i4_cropped_wd;
     ps_subset_seq->u2_pic_wd = u2_pic_wd;
     ps_subset_seq->u2_pic_ht = u2_pic_ht;
 
     /* Assuming 8k is the maximum resolution svc dec supports*/
     if(u2_frm_wd_y > H264_MAX_FRAME_WIDTH) return (NOT_OK);
     if(u2_frm_ht_y > H264_MAX_FRAME_HEIGHT) return (NOT_OK);
     if(u2_frm_wd_uv > H264_MAX_FRAME_WIDTH) return (NOT_OK);
     if(u2_frm_ht_uv > H264_MAX_FRAME_HEIGHT) return (NOT_OK);
 
     /* Determining the Width and Height of Frame from that of Picture */
     ps_subset_seq->u2_frm_wd_y = u2_frm_wd_y;
     ps_subset_seq->u2_frm_ht_y = u2_frm_ht_y;
     ps_subset_seq->u2_frm_wd_uv = u2_frm_wd_uv;
     ps_subset_seq->u2_frm_ht_uv = u2_frm_ht_uv;
 
     ps_subset_seq->u1_pad_len_y_v = (UWORD8) (PAD_LEN_Y_V << (1 - u1_frm));
     ps_subset_seq->u1_pad_len_cr_v = (UWORD8) (PAD_LEN_UV_V << (1 - u1_frm));
 
     ps_subset_seq->u2_crop_offset_y = u2_crop_offset_y;
     ps_subset_seq->u2_crop_offset_uv = u2_crop_offset_uv;
 
     if(((ps_dec->u2_pic_wd * ps_dec->u2_pic_ht) <
         (ps_subset_seq->u2_pic_wd * ps_subset_seq->u2_pic_ht)) ||
        (ps_dec->i4_reorder_depth < ps_subset_seq->i4_reorder_depth))
     {
         ps_dec->i4_reorder_depth = ps_subset_seq->i4_reorder_depth;
 
         ps_dec->u2_disp_height = ps_subset_seq->u2_disp_height;
         ps_dec->u2_disp_width = ps_subset_seq->u2_disp_width;
 
         ps_dec->u2_pic_wd = ps_subset_seq->u2_pic_wd;
         ps_dec->u2_pic_ht = ps_subset_seq->u2_pic_ht;
         ps_dec->u4_total_mbs = ps_seq->u2_total_num_of_mbs << (1 - ps_seq->u1_frame_mbs_only_flag);
 
         /* Determining the Width and Height of Frame from that of Picture */
         ps_dec->u2_frm_wd_y = ps_subset_seq->u2_frm_wd_y;
         ps_dec->u2_frm_ht_y = ps_subset_seq->u2_frm_ht_y;
         ps_dec->u2_frm_wd_uv = ps_subset_seq->u2_frm_wd_uv;
         ps_dec->u2_frm_ht_uv = ps_subset_seq->u2_frm_ht_uv;
 
         ps_dec->s_pad_mgr.u1_pad_len_y_v = ps_subset_seq->u1_pad_len_y_v;
         ps_dec->s_pad_mgr.u1_pad_len_cr_v = ps_subset_seq->u1_pad_len_cr_v;
 
         ps_dec->u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs;
         ps_dec->u2_frm_ht_in_mbs = ps_seq->u2_frm_ht_in_mbs;
 
         ps_dec->u2_crop_offset_y = ps_subset_seq->u2_crop_offset_y;
         ps_dec->u2_crop_offset_uv = ps_subset_seq->u2_crop_offset_uv;
     }
 
     ps_seq->u1_is_valid = TRUE;
     ps_dec->ps_sps[u1_seq_parameter_set_id] = *ps_seq;
     if(NULL != ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id].s_sps_svc_ext.ps_svc_vui_ext)
     {
         ps_seq_svc_ext->ps_svc_vui_ext =
             ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id].s_sps_svc_ext.ps_svc_vui_ext;
     }
     ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id] = *ps_subset_seq;
     ps_dec->ps_cur_sps = &ps_dec->ps_sps[u1_seq_parameter_set_id];
     ps_svc_lyr_dec->ps_cur_subset_sps = &ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id];
 
     return OK;
 }
 /*!
  **************************************************************************
  * \if Function name : isvcd_dec_ref_base_pic_marking \endif
  *
  * \brief
  *    Decodes reference base pic marking params
  *
  * \return
  *    0 on Success and error code otherwise
  **************************************************************************
  */
@@ -1085,593 +1085,593 @@ WORD32 isvcd_parse_nal_unit(svc_dec_lyr_struct_t *dec_svc_hdl, UWORD8 u1_nal_ref
 /*!
 **************************************************************************
 * \if Function name : isvcd_parse_sps \endif
 *
 * \brief
 *    Decodes Picture Parameter set
 *
 * \return
 *    0 on Success and Error code otherwise
 **************************************************************************
 */
 WORD32 isvcd_parse_sps(svc_dec_lyr_struct_t *ps_svc_lyr_dec, dec_bit_stream_t *ps_bitstrm)
 {
     dec_struct_t *ps_dec = &ps_svc_lyr_dec->s_dec;
     UWORD8 i;
     dec_seq_params_t *ps_seq = NULL;
     dec_svc_seq_params_t *ps_subset_seq = NULL;
     UWORD8 u1_profile_idc, u1_level_idc, u1_seq_parameter_set_id, u1_mb_aff_flag = 0;
     UWORD16 i2_max_frm_num;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
     UWORD8 u1_frm, uc_constraint_set0_flag, uc_constraint_set1_flag, uc_constraint_set2_flag;
     WORD32 i4_cropped_ht, i4_cropped_wd;
     UWORD32 u4_temp;
     UWORD64 u8_temp;
     UWORD32 u4_pic_height_in_map_units, u4_pic_width_in_mbs;
     UWORD32 u2_pic_wd = 0;
     UWORD32 u2_pic_ht = 0;
     UWORD32 u2_frm_wd_y = 0;
     UWORD32 u2_frm_ht_y = 0;
     UWORD32 u2_frm_wd_uv = 0;
     UWORD32 u2_frm_ht_uv = 0;
     UWORD32 u2_crop_offset_y = 0;
     UWORD32 u2_crop_offset_uv = 0;
     WORD32 ret;
     WORD32 num_reorder_frames;
     /* High profile related syntax element */
     WORD32 i4_i;
     /* G050 */
     UWORD8 u1_frame_cropping_flag,
         u1_frame_cropping_rect_left_ofst = 0, u1_frame_cropping_rect_right_ofst = 0,
         u1_frame_cropping_rect_top_ofst = 0, u1_frame_cropping_rect_bottom_ofst = 0;
     /* G050 */
     /*--------------------------------------------------------------------*/
     /* Decode seq_parameter_set_id and profile and level values           */
     /*--------------------------------------------------------------------*/
     SWITCHONTRACE;
     u1_profile_idc = ih264d_get_bits_h264(ps_bitstrm, 8);
     COPYTHECONTEXT("SPS: profile_idc", u1_profile_idc);
 
     /* G050 */
     uc_constraint_set0_flag = ih264d_get_bit_h264(ps_bitstrm);
     uc_constraint_set1_flag = ih264d_get_bit_h264(ps_bitstrm);
     uc_constraint_set2_flag = ih264d_get_bit_h264(ps_bitstrm);
     UNUSED(uc_constraint_set2_flag);
     /*****************************************************/
     /* Read 5 bits for uc_constraint_set3_flag (1 bit)   */
     /* and reserved_zero_4bits (4 bits) - Sushant        */
     /*****************************************************/
     ih264d_get_bits_h264(ps_bitstrm, 5);
     /* G050 */
     /* Check whether particular profile is suported or not */
     /* Check whether particular profile is suported or not */
     if((u1_profile_idc != MAIN_PROFILE_IDC) && (u1_profile_idc != BASE_PROFILE_IDC) &&
        (u1_profile_idc != HIGH_PROFILE_IDC))
     {
         /* Apart from Baseline, main and high profile,
          * only extended profile is supported provided
          * uc_constraint_set0_flag or uc_constraint_set1_flag are set to 1
          */
         if((u1_profile_idc != EXTENDED_PROFILE_IDC) ||
            ((uc_constraint_set1_flag != 1) && (uc_constraint_set0_flag != 1)))
         {
             return (ERROR_FEATURE_UNAVAIL);
         }
     }
 
     u1_level_idc = ih264d_get_bits_h264(ps_bitstrm, 8);
     COPYTHECONTEXT("SPS: u4_level_idc", u1_level_idc);
 
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u4_temp & MASK_ERR_SEQ_SET_ID) return ERROR_INV_SPS_PPS_T;
     u1_seq_parameter_set_id = u4_temp;
     COPYTHECONTEXT("SPS: seq_parameter_set_id", u1_seq_parameter_set_id);
 
     /*--------------------------------------------------------------------*/
     /* Find an seq param entry in seqparam array of decStruct             */
     /*--------------------------------------------------------------------*/
     ps_subset_seq = ps_svc_lyr_dec->pv_scratch_subset_sps;
     memset(ps_subset_seq, 0, sizeof(dec_svc_seq_params_t));
     ps_seq = ps_dec->pv_scratch_sps_pps;
     memset(ps_seq, 0, sizeof(dec_seq_params_t));
 
     if(ps_dec->i4_header_decoded & 1)
     {
         if(ps_dec->ps_cur_sps != NULL)
             *ps_seq = *ps_dec->ps_cur_sps;
         else
             return ERROR_INV_SPS_PPS_T;
     }
 
     if((ps_dec->i4_header_decoded & 1) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
        (ps_dec->ps_sps[u1_seq_parameter_set_id].u1_profile_idc != u1_profile_idc))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
 
     if((ps_dec->i4_header_decoded & 1) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
        (ps_dec->ps_sps[u1_seq_parameter_set_id].u1_level_idc != u1_level_idc))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
 
     ps_seq->u1_profile_idc = u1_profile_idc;
     ps_seq->u1_level_idc = u1_level_idc;
     ps_seq->u1_seq_parameter_set_id = u1_seq_parameter_set_id;
     ps_subset_seq->ps_seq = &ps_dec->ps_sps[u1_seq_parameter_set_id];
 
     /*******************************************************************/
     /* Initializations for high profile - Sushant                      */
     /*******************************************************************/
     ps_seq->i4_chroma_format_idc = 1;
     ps_seq->i4_bit_depth_luma_minus8 = 0;
     ps_seq->i4_bit_depth_chroma_minus8 = 0;
     ps_seq->i4_qpprime_y_zero_transform_bypass_flag = 0;
     ps_seq->i4_seq_scaling_matrix_present_flag = 0;
     if(u1_profile_idc == HIGH_PROFILE_IDC || u1_profile_idc == SCALABLE_BASELINE_PROFILE_IDC ||
        u1_profile_idc == SCALABLE_HIGH_PROFILE_IDC)
     {
         /* reading chroma_format_idc   */
         ps_seq->i4_chroma_format_idc = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
         /* Monochrome is not supported */
         if(ps_seq->i4_chroma_format_idc != 1)
         {
             return ERROR_FEATURE_UNAVAIL;
         }
 
         /* reading bit_depth_luma_minus8   */
         ps_seq->i4_bit_depth_luma_minus8 = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
         if(ps_seq->i4_bit_depth_luma_minus8 != 0)
         {
             return ERROR_FEATURE_UNAVAIL;
         }
 
         /* reading bit_depth_chroma_minus8   */
         ps_seq->i4_bit_depth_chroma_minus8 = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
         if(ps_seq->i4_bit_depth_chroma_minus8 != 0)
         {
             return ERROR_FEATURE_UNAVAIL;
         }
 
         /* reading qpprime_y_zero_transform_bypass_flag   */
         ps_seq->i4_qpprime_y_zero_transform_bypass_flag = (WORD32) ih264d_get_bit_h264(ps_bitstrm);
 
         if(ps_seq->i4_qpprime_y_zero_transform_bypass_flag != 0)
         {
             return ERROR_INV_SPS_PPS_T;
         }
 
         /* reading seq_scaling_matrix_present_flag   */
         ps_seq->i4_seq_scaling_matrix_present_flag = (WORD32) ih264d_get_bit_h264(ps_bitstrm);
 
         if(ps_seq->i4_seq_scaling_matrix_present_flag)
         {
             for(i4_i = 0; i4_i < 8; i4_i++)
             {
                 ps_seq->u1_seq_scaling_list_present_flag[i4_i] = ih264d_get_bit_h264(ps_bitstrm);
 
                 /* initialize u1_use_default_scaling_matrix_flag[i4_i] to zero */
                 /* before calling scaling list                             */
                 ps_seq->u1_use_default_scaling_matrix_flag[i4_i] = 0;
 
                 if(ps_seq->u1_seq_scaling_list_present_flag[i4_i])
                 {
                     if(i4_i < 6)
                     {
                         ret = ih264d_scaling_list(ps_seq->i2_scalinglist4x4[i4_i], 16,
                                                   &ps_seq->u1_use_default_scaling_matrix_flag[i4_i],
                                                   ps_bitstrm);
                     }
                     else
                     {
                         ret = ih264d_scaling_list(ps_seq->i2_scalinglist8x8[i4_i - 6], 64,
                                                   &ps_seq->u1_use_default_scaling_matrix_flag[i4_i],
                                                   ps_bitstrm);
                     }
                     if(ret != OK)
                     {
                         return ret;
                     }
                 }
             }
         }
     }
     /*--------------------------------------------------------------------*/
     /* Decode MaxFrameNum                                                 */
     /*--------------------------------------------------------------------*/
     u8_temp = (UWORD64) 4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u8_temp > MAX_BITS_IN_FRAME_NUM)
     {
         return ERROR_INV_SPS_PPS_T;
     }
     ps_seq->u1_bits_in_frm_num = (UWORD8) u8_temp;
     COPYTHECONTEXT("SPS: log2_max_frame_num_minus4", (ps_seq->u1_bits_in_frm_num - 4));
 
     i2_max_frm_num = (1 << (ps_seq->u1_bits_in_frm_num));
     ps_seq->u2_u4_max_pic_num_minus1 = i2_max_frm_num - 1;
     /*--------------------------------------------------------------------*/
     /* Decode picture order count and related values                      */
     /*--------------------------------------------------------------------*/
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u4_temp > MAX_PIC_ORDER_CNT_TYPE)
     {
         return ERROR_INV_POC_TYPE_T;
     }
     ps_seq->u1_pic_order_cnt_type = u4_temp;
     COPYTHECONTEXT("SPS: pic_order_cnt_type", ps_seq->u1_pic_order_cnt_type);
 
     ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = 1;
     if(ps_seq->u1_pic_order_cnt_type == 0)
     {
         u8_temp = (UWORD64) 4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         if(u8_temp > MAX_BITS_IN_POC_LSB)
         {
             return ERROR_INV_SPS_PPS_T;
         }
         ps_seq->u1_log2_max_pic_order_cnt_lsb_minus = (UWORD8) u8_temp;
         ps_seq->i4_max_pic_order_cntLsb = (1 << u8_temp);
         COPYTHECONTEXT("SPS: log2_max_pic_order_cnt_lsb_minus4", (u8_temp - 4));
     }
     else if(ps_seq->u1_pic_order_cnt_type == 1)
     {
         ps_seq->u1_delta_pic_order_always_zero_flag = ih264d_get_bit_h264(ps_bitstrm);
         COPYTHECONTEXT("SPS: delta_pic_order_always_zero_flag",
                        ps_seq->u1_delta_pic_order_always_zero_flag);
 
         ps_seq->i4_ofst_for_non_ref_pic = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: offset_for_non_ref_pic", ps_seq->i4_ofst_for_non_ref_pic);
 
         ps_seq->i4_ofst_for_top_to_bottom_field = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: offset_for_top_to_bottom_field",
                        ps_seq->i4_ofst_for_top_to_bottom_field);
 
         u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         if(u4_temp > 255) return ERROR_INV_SPS_PPS_T;
         ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = u4_temp;
         COPYTHECONTEXT("SPS: num_ref_frames_in_pic_order_cnt_cycle",
                        ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle);
 
         for(i = 0; i < ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle; i++)
         {
             ps_seq->i4_ofst_for_ref_frame[i] = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
             COPYTHECONTEXT("SPS: offset_for_ref_frame", ps_seq->i4_ofst_for_ref_frame[i]);
         }
     }
 
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
     if((u4_temp > H264_MAX_REF_PICS))
     {
         return ERROR_NUM_REF;
     }
 
     /* Compare with older num_ref_frames is header is already once */
     if((ps_dec->i4_header_decoded & 1) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
        (ps_dec->ps_sps[u1_seq_parameter_set_id].u1_num_ref_frames != u4_temp))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
 
     ps_seq->u1_num_ref_frames = u4_temp;
     COPYTHECONTEXT("SPS: num_ref_frames", ps_seq->u1_num_ref_frames);
 
     ps_seq->u1_gaps_in_frame_num_value_allowed_flag = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("SPS: gaps_in_frame_num_value_allowed_flag",
                    ps_seq->u1_gaps_in_frame_num_value_allowed_flag);
 
     ps_seq->u1_gaps_in_frame_num_value_allowed_flag = 0;
 
     /*--------------------------------------------------------------------*/
     /* Decode FrameWidth and FrameHeight and related values               */
     /*--------------------------------------------------------------------*/
     u8_temp = (UWORD64) 1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     /* Check  for unsupported resolutions*/
     if(u8_temp > (H264_MAX_FRAME_WIDTH >> 4))
     {
         return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
     }
     u4_pic_width_in_mbs = (UWORD32) u8_temp;
     COPYTHECONTEXT("SPS: pic_width_in_mbs_minus1", u4_pic_width_in_mbs - 1);
 
     u8_temp = (UWORD64) 1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u8_temp > (H264_MAX_FRAME_HEIGHT >> 4))
     {
         return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
     }
     u4_pic_height_in_map_units = (UWORD32) u8_temp;
 
     ps_seq->u2_frm_wd_in_mbs = u4_pic_width_in_mbs;
     ps_seq->u2_frm_ht_in_mbs = u4_pic_height_in_map_units;
     u2_pic_wd = (u4_pic_width_in_mbs << 4);
     u2_pic_ht = (u4_pic_height_in_map_units << 4);
     /*--------------------------------------------------------------------*/
     /* Get the value of MaxMbAddress and Number of bits needed for it     */
     /*--------------------------------------------------------------------*/
     ps_seq->u2_max_mb_addr = (ps_seq->u2_frm_wd_in_mbs * ps_seq->u2_frm_ht_in_mbs) - 1;
     ps_seq->u2_total_num_of_mbs = ps_seq->u2_max_mb_addr + 1;
     ps_seq->u1_level_idc = ih264d_correct_level_idc(u1_level_idc, ps_seq->u2_total_num_of_mbs);
 
     u1_frm = ih264d_get_bit_h264(ps_bitstrm);
     if((ps_dec->i4_header_decoded & 1) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
        (ps_dec->ps_sps[u1_seq_parameter_set_id].u1_frame_mbs_only_flag != u1_frm))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
     ps_seq->u1_frame_mbs_only_flag = u1_frm;
     COPYTHECONTEXT("SPS: frame_mbs_only_flag", u1_frm);
 
     if(!u1_frm) u1_mb_aff_flag = ih264d_get_bit_h264(ps_bitstrm);
 
     if((ps_dec->i4_header_decoded & 1) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
        (ps_dec->ps_sps[u1_seq_parameter_set_id].u1_mb_aff_flag != u1_mb_aff_flag))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
 
     if(!u1_frm)
     {
         u2_pic_ht <<= 1;
         ps_seq->u1_mb_aff_flag = u1_mb_aff_flag;
         COPYTHECONTEXT("SPS: mb_adaptive_frame_field_flag", ps_seq->u1_mb_aff_flag);
     }
     else
         ps_seq->u1_mb_aff_flag = 0;
 
     ps_seq->u1_direct_8x8_inference_flag = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("SPS: direct_8x8_inference_flag", ps_seq->u1_direct_8x8_inference_flag);
 
     /* G050 */
     u1_frame_cropping_flag = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("SPS: frame_cropping_flag", u1_frame_cropping_flag);
 
     if(u1_frame_cropping_flag)
     {
         u1_frame_cropping_rect_left_ofst = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: frame_cropping_rect_left_offset", u1_frame_cropping_rect_left_ofst);
         u1_frame_cropping_rect_right_ofst = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: frame_cropping_rect_right_offset", u1_frame_cropping_rect_right_ofst);
         u1_frame_cropping_rect_top_ofst = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: frame_cropping_rect_top_offset", u1_frame_cropping_rect_top_ofst);
         u1_frame_cropping_rect_bottom_ofst = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: frame_cropping_rect_bottom_offset",
                        u1_frame_cropping_rect_bottom_ofst);
     }
     /* G050 */
     ps_seq->u1_vui_parameters_present_flag = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("SPS: vui_parameters_present_flag", ps_seq->u1_vui_parameters_present_flag);
 
     u2_frm_wd_y = u2_pic_wd + (UWORD8) (PAD_LEN_Y_H << 1);
 
     if(1 == ps_dec->u4_share_disp_buf)
     {
         if(ps_dec->u4_app_disp_width > u2_frm_wd_y) u2_frm_wd_y = ps_dec->u4_app_disp_width;
     }
 
     u2_frm_ht_y = u2_pic_ht + (UWORD8) (PAD_LEN_Y_V << 2);
     u2_frm_wd_uv = u2_pic_wd + (UWORD8) (PAD_LEN_UV_H << 2);
     u2_frm_wd_uv = MAX(u2_frm_wd_uv, u2_frm_wd_y);
     u2_frm_ht_uv = (u2_pic_ht >> 1) + (UWORD8) (PAD_LEN_UV_V << 2);
     u2_frm_ht_uv = MAX(u2_frm_ht_uv, (u2_frm_ht_y >> 1));
 
     /* Calculate display picture width, height and start u4_ofst from YUV420 */
     /* pictute buffers as per cropping information parsed above             */
     {
         UWORD16 u2_rgt_ofst = 0;
         UWORD16 u2_lft_ofst = 0;
         UWORD16 u2_top_ofst = 0;
         UWORD16 u2_btm_ofst = 0;
         UWORD8 u1_frm_mbs_flag;
         UWORD8 u1_vert_mult_factor;
 
         if(u1_frame_cropping_flag)
         {
             /* Calculate right and left u4_ofst for cropped picture           */
             u2_rgt_ofst = u1_frame_cropping_rect_right_ofst << 1;
             u2_lft_ofst = u1_frame_cropping_rect_left_ofst << 1;
 
             /* Know frame MBs only u4_flag                                      */
             u1_frm_mbs_flag = (1 == ps_seq->u1_frame_mbs_only_flag);
 
             /* Simplify the vertical u4_ofst calculation from field/frame     */
             u1_vert_mult_factor = (2 - u1_frm_mbs_flag);
 
             /* Calculate bottom and top u4_ofst for cropped  picture          */
             u2_btm_ofst = (u1_frame_cropping_rect_bottom_ofst << u1_vert_mult_factor);
             u2_top_ofst = (u1_frame_cropping_rect_top_ofst << u1_vert_mult_factor);
         }
 
         /* Calculate u4_ofst from start of YUV 420 picture buffer to start of*/
         /* cropped picture buffer                                           */
         u2_crop_offset_y = (u2_frm_wd_y * u2_top_ofst) + (u2_lft_ofst);
         u2_crop_offset_uv =
             (u2_frm_wd_uv * (u2_top_ofst >> 1)) + (u2_lft_ofst >> 1) * YUV420SP_FACTOR;
         /* Calculate the display picture width and height based on crop      */
         /* information                                                       */
         i4_cropped_ht = (WORD32) u2_pic_ht - (WORD32) (u2_btm_ofst + u2_top_ofst);
         i4_cropped_wd = (WORD32) u2_pic_wd - (WORD32) (u2_rgt_ofst + u2_lft_ofst);
 
         if((i4_cropped_ht < MB_SIZE) || (i4_cropped_wd < MB_SIZE))
         {
             return ERROR_INV_SPS_PPS_T;
         }
 
         if((ps_dec->i4_header_decoded & 1) &&
            (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
            (ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id].u2_pic_wd != u2_pic_wd))
         {
             ps_dec->u1_res_changed = 1;
             return IVD_RES_CHANGED;
         }
 
         if((ps_dec->i4_header_decoded & 1) &&
            (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
            (ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id].u2_disp_width != i4_cropped_wd))
         {
             ps_dec->u1_res_changed = 1;
             return IVD_RES_CHANGED;
         }
 
         if((ps_dec->i4_header_decoded & 1) &&
            (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
            (ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id].u2_pic_ht != u2_pic_ht))
         {
             ps_dec->u1_res_changed = 1;
             return IVD_RES_CHANGED;
         }
 
         if((ps_dec->i4_header_decoded & 1) &&
            (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
            (ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id].u2_disp_height != i4_cropped_ht))
         {
             ps_dec->u1_res_changed = 1;
             return IVD_RES_CHANGED;
         }
         /* Check again for unsupported resolutions with updated values*/
-        if((u2_pic_wd > H264_MAX_FRAME_WIDTH) || (u2_pic_ht > H264_MAX_FRAME_HEIGHT) ||
-           (u2_pic_wd < H264_MIN_FRAME_WIDTH) || (u2_pic_ht < H264_MIN_FRAME_HEIGHT) ||
-           (u2_pic_wd * (UWORD32) u2_pic_ht > H264_MAX_FRAME_SIZE))
+        if((u2_pic_wd > SVCD_MAX_FRAME_WIDTH) || (u2_pic_ht > SVCD_MAX_FRAME_HEIGHT) ||
+           (u2_pic_wd < SVCD_MIN_FRAME_WIDTH) || (u2_pic_ht < SVCD_MIN_FRAME_HEIGHT) ||
+           (u2_pic_wd * (UWORD32) u2_pic_ht > SVCD_MAX_FRAME_SIZE))
         {
             return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
         }
 
         /* If MBAff is enabled, decoder support is limited to streams with
          * width less than half of H264_MAX_FRAME_WIDTH.
          * In case of MBAff decoder processes two rows at a time
          */
         if((u2_pic_wd << ps_seq->u1_mb_aff_flag) > H264_MAX_FRAME_WIDTH)
         {
             return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
         }
     }
 
     /* Backup num_reorder_frames if header is already decoded */
     if((ps_dec->i4_header_decoded & 1) && (1 == ps_seq->u1_vui_parameters_present_flag) &&
        (1 == ps_seq->s_vui.u1_bitstream_restriction_flag))
     {
         num_reorder_frames = (WORD32) ps_seq->s_vui.u4_num_reorder_frames;
     }
     else
     {
         num_reorder_frames = -1;
     }
     if(1 == ps_seq->u1_vui_parameters_present_flag)
     {
         ret = ih264d_parse_vui_parametres(&ps_seq->s_vui, ps_bitstrm);
         if(ret != OK) return ret;
     }
 
     /* Compare older num_reorder_frames with the new one if header is already
      * decoded */
     if((ps_dec->i4_header_decoded & 1) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) && (-1 != num_reorder_frames) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_vui_parameters_present_flag) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].s_vui.u1_bitstream_restriction_flag) &&
        ((WORD32) ps_dec->ps_sps[u1_seq_parameter_set_id].s_vui.u4_num_reorder_frames !=
         num_reorder_frames))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
 
     /* In case bitstream read has exceeded the filled size, then return an error */
     if(EXCEED_OFFSET(ps_bitstrm))
     {
         return ERROR_INV_SPS_PPS_T;
     }
 
     /*--------------------------------------------------------------------*/
     /* All initializations to ps_dec are beyond this point                */
     /*--------------------------------------------------------------------*/
     {
         WORD32 reorder_depth = ih264d_get_dpb_size(ps_seq);
         if((1 == ps_seq->u1_vui_parameters_present_flag) &&
            (1 == ps_seq->s_vui.u1_bitstream_restriction_flag))
         {
             reorder_depth = ps_seq->s_vui.u4_num_reorder_frames + 1;
         }
 
         if(reorder_depth > H264_MAX_REF_PICS)
         {
             return ERROR_INV_SPS_PPS_T;
         }
 
         if(ps_seq->u1_frame_mbs_only_flag != 1) reorder_depth *= 2;
         ps_subset_seq->i4_reorder_depth = reorder_depth + DISPLAY_LATENCY;
     }
     ps_subset_seq->u2_disp_height = i4_cropped_ht;
     ps_subset_seq->u2_disp_width = i4_cropped_wd;
     ps_subset_seq->u2_pic_wd = u2_pic_wd;
     ps_subset_seq->u2_pic_ht = u2_pic_ht;
 
     /* Determining the Width and Height of Frame from that of Picture */
     ps_subset_seq->u2_frm_wd_y = u2_frm_wd_y;
     ps_subset_seq->u2_frm_ht_y = u2_frm_ht_y;
     ps_subset_seq->u2_frm_wd_uv = u2_frm_wd_uv;
     ps_subset_seq->u2_frm_ht_uv = u2_frm_ht_uv;
 
     ps_subset_seq->u1_pad_len_y_v = (UWORD8) (PAD_LEN_Y_V << (1 - u1_frm));
     ps_subset_seq->u1_pad_len_cr_v = (UWORD8) (PAD_LEN_UV_V << (1 - u1_frm));
 
     ps_subset_seq->u2_crop_offset_y = u2_crop_offset_y;
     ps_subset_seq->u2_crop_offset_uv = u2_crop_offset_uv;
 
     if(((ps_dec->u2_pic_wd * ps_dec->u2_pic_ht) <
         (ps_subset_seq->u2_pic_wd * ps_subset_seq->u2_pic_ht)) ||
        (ps_dec->i4_reorder_depth < ps_subset_seq->i4_reorder_depth))
     {
         ps_dec->i4_reorder_depth = ps_subset_seq->i4_reorder_depth;
 
         ps_dec->u2_disp_height = ps_subset_seq->u2_disp_height;
         ps_dec->u2_disp_width = ps_subset_seq->u2_disp_width;
         ps_dec->u2_pic_wd = ps_subset_seq->u2_pic_wd;
         ps_dec->u2_pic_ht = ps_subset_seq->u2_pic_ht;
         ps_dec->u4_total_mbs = ps_seq->u2_total_num_of_mbs << (1 - ps_seq->u1_frame_mbs_only_flag);
 
         /* Determining the Width and Height of Frame from that of Picture */
         ps_dec->u2_frm_wd_y = ps_subset_seq->u2_frm_wd_y;
         ps_dec->u2_frm_ht_y = ps_subset_seq->u2_frm_ht_y;
         ps_dec->u2_frm_wd_uv = ps_subset_seq->u2_frm_wd_uv;
         ps_dec->u2_frm_ht_uv = ps_subset_seq->u2_frm_ht_uv;
 
         ps_dec->s_pad_mgr.u1_pad_len_y_v = ps_subset_seq->u1_pad_len_y_v;
         ps_dec->s_pad_mgr.u1_pad_len_cr_v = ps_subset_seq->u1_pad_len_cr_v;
 
         ps_dec->u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs;
         ps_dec->u2_frm_ht_in_mbs = ps_seq->u2_frm_ht_in_mbs;
         ps_dec->u2_crop_offset_y = ps_subset_seq->u2_crop_offset_y;
         ps_dec->u2_crop_offset_uv = ps_subset_seq->u2_crop_offset_uv;
     }
 
     ps_seq->u1_is_valid = TRUE;
     ps_dec->ps_sps[u1_seq_parameter_set_id] = *ps_seq;
     ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id] = *ps_subset_seq;
     ps_dec->ps_cur_sps = &ps_dec->ps_sps[u1_seq_parameter_set_id];
     ps_svc_lyr_dec->ps_cur_subset_sps = &ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id];
 
     return OK;
 }
 
 /*!
 **************************************************************************
 * \if Function name : isvcd_parse_pps \endif
 *
 * \brief
 *    Decodes Picture Parameter set
 *
 * \return
 *    0 on Success and Error code otherwise
 **************************************************************************
 */
