commit 555ab6f1feceb1118492e91970b14cb901f82229
Author: Greg Landrum <greg.landrum@gmail.com>
Date:   Wed Feb 9 14:20:49 2022 +0100

    Start adding move constructors and move-assignment operators (#4909)
    
    * some initial work...
    Still some real questions here about what should be done with dp_mol data members
    
    * add some tests for move semantics of Dict and Props
    remove extraneous clear()
    
    * more in-depth testing of the molecule results
    
    * test refactoring
    
    * improve the molecule move test
    
    * fix some leaks found by valgrind
    the new tests are now all clean in valgrind
    
    * additional classes
    QueryAtom, QueryBond, RingInfo, Conformer
    
    * get swig working again.
    Not sure why this is necessary, but SWIG is a mysterious beast
    
    * fixes in response to review
    
    * updates in response to review

diff --git a/Code/GraphMol/Atom.h b/Code/GraphMol/Atom.h
index 69f83b2dd..29443d64f 100644
--- a/Code/GraphMol/Atom.h
+++ b/Code/GraphMol/Atom.h
@@ -1,27 +1,27 @@
 //
-//  Copyright (C) 2001-2014 Greg Landrum and Rational Discovery LLC
+//  Copyright (C) 2001-2021 Greg Landrum and other RDKit contributors
 //
 //   @@ All Rights Reserved @@
 //  This file is part of the RDKit.
 //  The contents are covered by the terms of the BSD license
 //  which is included in the file license.txt, found at the root
 //  of the RDKit source tree.
 //
 /*! \file Atom.h
 
   \brief Defines the Atom class and associated typedefs
 
 */
 #include <RDGeneral/export.h>
 #ifndef _RD_ATOM_H
 #define _RD_ATOM_H
 
 // Std stuff
 #include <iostream>
 
 // ours
 #include <RDGeneral/Invariant.h>
 #include <Query/QueryObjects.h>
 #include <RDGeneral/types.h>
 #include <RDGeneral/RDProps.h>
 #include <GraphMol/details.h>
@@ -67,346 +67,351 @@ class AtomMonomerInfo;
 */
 class RDKIT_GRAPHMOL_EXPORT Atom : public RDProps {
   friend class MolPickler;  //!< the pickler needs access to our privates
   friend class ROMol;
   friend class RWMol;
 
  public:
   // FIX: grn...
   typedef Queries::Query<int, Atom const *, true> QUERYATOM_QUERY;
 
   //! store hybridization
   typedef enum {
     UNSPECIFIED = 0,  //!< hybridization that hasn't been specified
     S,
     SP,
     SP2,
     SP3,
     SP3D,
     SP3D2,
     OTHER  //!< unrecognized hybridization
   } HybridizationType;
 
   //! store type of chirality
   typedef enum {
     CHI_UNSPECIFIED = 0,  //!< chirality that hasn't been specified
     CHI_TETRAHEDRAL_CW,   //!< tetrahedral: clockwise rotation (SMILES \@\@)
     CHI_TETRAHEDRAL_CCW,  //!< tetrahedral: counter-clockwise rotation (SMILES
                           //\@)
     CHI_OTHER             //!< some unrecognized type of chirality
   } ChiralType;
 
   Atom();
   //! construct an Atom with a particular atomic number
   explicit Atom(unsigned int num);
   //! construct an Atom with a particular symbol (looked up in the
   /// PeriodicTable)
   explicit Atom(const std::string &what);
   Atom(const Atom &other);
   Atom &operator=(const Atom &other);
+  // NOTE: the move methods are somewhat fraught for atoms associated with
+  // molecules since the molecule will still be pointing to the original object
+  Atom(Atom &&other) = default;
+  Atom &operator=(Atom &&other) = default;
+
   virtual ~Atom();
 
   //! makes a copy of this Atom and returns a pointer to it.
   /*!
     <b>Note:</b> the caller is responsible for <tt>delete</tt>ing the result
   */
   virtual Atom *copy() const;
 
   //! returns our atomic number
   int getAtomicNum() const { return d_atomicNum; }
   //! sets our atomic number
   void setAtomicNum(int newNum) { d_atomicNum = newNum; }
 
   //! returns our symbol (determined by our atomic number)
   std::string getSymbol() const;
 
   //! returns whether or not this instance belongs to a molecule
   bool hasOwningMol() const { return dp_mol != nullptr; }
 
   //! returns a reference to the ROMol that owns this instance
   ROMol &getOwningMol() const {
     PRECONDITION(dp_mol, "no owner");
     return *dp_mol;
   }
 
   //! returns our index within the ROMol
   unsigned int getIdx() const { return d_index; }
   //! sets our index within the ROMol
   /*!
     <b>Notes:</b>
       - this makes no sense if we do not have an owning molecule
       - the index should be <tt>< this->getOwningMol()->getNumAtoms()</tt>
   */
   void setIdx(unsigned int index) { d_index = index; }
   //! overload
   template <class U>
   void setIdx(const U index) {
     setIdx(rdcast<unsigned int>(index));
   }
   //! returns the explicit degree of the Atom (number of bonded
   //!   neighbors in the graph)
   /*!
     <b>Notes:</b>
       - requires an owning molecule
   */
   unsigned int getDegree() const;
 
   //! returns the total degree of the Atom (number of bonded
   //!   neighbors + number of Hs)
   /*!
     <b>Notes:</b>
       - requires an owning molecule
   */
   unsigned int getTotalDegree() const;
 
   //! \brief returns the total number of Hs (implicit and explicit) that
   //! this Atom is bound to
   /*!
     <b>Notes:</b>
       - requires an owning molecule
   */
   unsigned int getTotalNumHs(bool includeNeighbors = false) const;
 
   //! \brief returns the total valence (implicit and explicit)
   //! for an atom
   /*!
     <b>Notes:</b>
       - requires an owning molecule
   */
   unsigned int getTotalValence() const;
 
   //! returns the number of implicit Hs this Atom is bound to
   /*!
     <b>Notes:</b>
       - requires an owning molecule
   */
   unsigned int getNumImplicitHs() const;
 
   //! returns the explicit valence (including Hs) of this atom
   int getExplicitValence() const;
 
   //! returns the implicit valence for this Atom
   /*!
     <b>Notes:</b>
       - requires an owning molecule
   */
   int getImplicitValence() const;
 
   //! returns the number of radical electrons for this Atom
   /*!
     <b>Notes:</b>
       - requires an owning molecule
   */
   unsigned int getNumRadicalElectrons() const { return d_numRadicalElectrons; }
   void setNumRadicalElectrons(unsigned int num) { d_numRadicalElectrons = num; }
 
   //! returns the formal charge of this atom
   int getFormalCharge() const { return d_formalCharge; }
   //! set's the formal charge of this atom
   void setFormalCharge(int what) { d_formalCharge = what; }
 
   //! \brief sets our \c noImplicit flag, indicating whether or not
   //!  we are allowed to have implicit Hs
   void setNoImplicit(bool what) { df_noImplicit = what; }
   //! returns the \c noImplicit flag
   bool getNoImplicit() const { return df_noImplicit; }
 
   //! sets our number of explicit Hs
   void setNumExplicitHs(unsigned int what) { d_numExplicitHs = what; }
   //! returns our number of explicit Hs
   unsigned int getNumExplicitHs() const { return d_numExplicitHs; }
 
   //! sets our \c isAromatic flag, indicating whether or not we are aromatic
   void setIsAromatic(bool what) { df_isAromatic = what; }
   //! returns our \c isAromatic flag
   bool getIsAromatic() const { return df_isAromatic; }
 
   //! returns our mass
   double getMass() const;
 
   //! sets our isotope number
   void setIsotope(unsigned int what);
   //! returns our isotope number
   unsigned int getIsotope() const { return d_isotope; }
 
   //! sets our \c chiralTag
   void setChiralTag(ChiralType what) { d_chiralTag = what; }
   //! inverts our \c chiralTag
   void invertChirality();
   //! returns our \c chiralTag
   ChiralType getChiralTag() const {
     return static_cast<ChiralType>(d_chiralTag);
   }
 
   //! sets our hybridization
   void setHybridization(HybridizationType what) { d_hybrid = what; }
   //! returns our hybridization
   HybridizationType getHybridization() const {
     return static_cast<HybridizationType>(d_hybrid);
   }
 
   // ------------------------------------
   // Some words of explanation before getting down into
   // the query stuff.
   // These query functions are really only here so that they
   //  can have real functionality in subclasses (like QueryAtoms).
   // Since pretty much it's gonna be a mistake to call any of these
   //  (ever), we're saddling them all with a precondition which
   //  is guaranteed to fail.  I'd like to have them be pure virtual,
   //  but that doesn't work since we need to be able to instantiate
   //  Atoms.
   // ------------------------------------
 
   // This method can be used to distinguish query atoms from standard atoms:
   virtual bool hasQuery() const { return false; }
 
   virtual std::string getQueryType() const {return "";}
 
   //! NOT CALLABLE
   virtual void setQuery(QUERYATOM_QUERY *what);
 
   //! NOT CALLABLE
   virtual QUERYATOM_QUERY *getQuery() const;
   //! NOT CALLABLE
   virtual void expandQuery(
       QUERYATOM_QUERY *what,
       Queries::CompositeQueryType how = Queries::COMPOSITE_AND,
       bool maintainOrder = true);
 
   //! returns whether or not we match the argument
   /*!
       <b>Notes:</b>
         The general rule is that if a property on this atom has a non-default
      value,
         the property on the other atom must have the same value.
         The exception to this is H counts, which are ignored. These turns out to
      be
           impossible to handle generally, so rather than having odd and
      hard-to-explain
           exceptions, we ignore them entirely.
 
         Here are the rules for atom-atom matching:
         | This    | Other   | Match | Reason
         | CCO     | CCO     | Yes   |
         | CCO     | CC[O-]  | Yes   |
         | CC[O-]  | CCO     | No    | Charge
         | CC[O-]  | CC[O-]  | Yes   |
         | CC[OH]  | CC[O-]  | Yes   |
         | CC[OH]  | CCOC    | Yes   |
         | CCO     | CCOC    | Yes   |
         | CCC     | CCC     | Yes   |
         | CCC     | CC[14C] | Yes   |
         | CC[14C] | CCC     | No    | Isotope
         | CC[14C] | CC[14C] | Yes   |
         | C       | OCO     | Yes   |
         | [CH]    | OCO     | Yes   |
         | [CH2]   | OCO     | Yes   |
         | [CH3]   | OCO     | No    | Radical
         | C       | O[CH2]O | Yes   |
         | [CH2]   | O[CH2]O | Yes   |
   */
   virtual bool Match(Atom const *what) const;
 
   //! returns the perturbation order for a list of integers
   /*!
 
     This value is associated with chirality.
 
     \param probe a list of bond indices.  This must be the same
       length as our number of incoming bonds (our degree).
 
     \return the number of swaps required to convert the ordering
       of the probe list to match the order of our incoming bonds:
       e.g. if our incoming bond order is: <tt>[0,1,2,3]</tt>
       \verbatim
       getPerturbationOrder([1,0,2,3]) = 1
       getPerturbationOrder([1,2,3,0]) = 3
       getPerturbationOrder([1,2,0,3]) = 2
       \endverbatim
 
     See the class documentation for a more detailed description
     of our representation of chirality.
 
     <b>Notes:</b>
       - requires an owning molecule
 
   */
   int getPerturbationOrder(const INT_LIST &probe) const;
 
   //! calculates any of our lazy \c properties
   /*!
     <b>Notes:</b>
       - requires an owning molecule
       - the current lazy \c properties are implicit and explicit valence
   */
   void updatePropertyCache(bool strict = true);
 
   bool needsUpdatePropertyCache() const;
 
   //! calculates and returns our explicit valence
   /*!
     <b>Notes:</b>
       - requires an owning molecule
   */
   int calcExplicitValence(bool strict = true);
 
   //! calculates and returns our implicit valence
   /*!
     <b>Notes:</b>
       - requires an owning molecule
   */
   int calcImplicitValence(bool strict = true);
 
   AtomMonomerInfo *getMonomerInfo() { return dp_monomerInfo; }
   const AtomMonomerInfo *getMonomerInfo() const { return dp_monomerInfo; }
   //! takes ownership of the pointer
   void setMonomerInfo(AtomMonomerInfo *info) { dp_monomerInfo = info; }
 
   //! Set the atom map Number of the atom
   void setAtomMapNum(int mapno, bool strict = true) {
     PRECONDITION(
         !strict || (mapno >= 0 && mapno < 1000),
         "atom map number out of range [0..1000], use strict=false to override");
     if (mapno) {
       setProp(common_properties::molAtomMapNumber, mapno);
     } else if (hasProp(common_properties::molAtomMapNumber)) {
       clearProp(common_properties::molAtomMapNumber);
     }
   }
   //! Gets the atom map Number of the atom, if no atom map exists, 0 is
   //! returned.
   int getAtomMapNum() const {
     int mapno = 0;
     getPropIfPresent(common_properties::molAtomMapNumber, mapno);
     return mapno;
   }
 
  protected:
   //! sets our owning molecule
   void setOwningMol(ROMol *other);
   //! sets our owning molecule
   void setOwningMol(ROMol &other) { setOwningMol(&other); }
 
   bool df_isAromatic;
   bool df_noImplicit;
   std::uint8_t d_numExplicitHs;
   std::int8_t d_formalCharge;
   std::uint8_t d_atomicNum;
   // NOTE that these cannot be signed, they are calculated using
   // a lazy scheme and are initialized to -1 to indicate that the
   // calculation has not yet been done.
   std::int8_t d_implicitValence, d_explicitValence;
   std::uint8_t d_numRadicalElectrons;
   std::uint8_t d_chiralTag;
   std::uint8_t d_hybrid;
 
   std::uint16_t d_isotope;
   atomindex_t d_index;
 
   ROMol *dp_mol;
   AtomMonomerInfo *dp_monomerInfo;
   void initAtom();
   void initFromOther(const Atom &other);
 };
 
 //! Set the atom's MDL integer RLabel
 ///  Setting to 0 clears the rlabel.  Rlabel must be in the range [0..99]
diff --git a/Code/GraphMol/Bond.h b/Code/GraphMol/Bond.h
index 02b661e06..97de162a8 100644
--- a/Code/GraphMol/Bond.h
+++ b/Code/GraphMol/Bond.h
@@ -45,302 +45,335 @@ class Atom;
 */
 class RDKIT_GRAPHMOL_EXPORT Bond : public RDProps {
   friend class RWMol;
   friend class ROMol;
 
  public:
   // FIX: grn...
   typedef Queries::Query<int, Bond const *, true> QUERYBOND_QUERY;
 
   //! the type of Bond
   typedef enum {
     UNSPECIFIED = 0,
     SINGLE,
     DOUBLE,
     TRIPLE,
     QUADRUPLE,
     QUINTUPLE,
     HEXTUPLE,
     ONEANDAHALF,
     TWOANDAHALF,
     THREEANDAHALF,
     FOURANDAHALF,
     FIVEANDAHALF,
     AROMATIC,
     IONIC,
     HYDROGEN,
     THREECENTER,
     DATIVEONE,  //!< one-electron dative (e.g. from a C in a Cp ring to a metal)
     DATIVE,     //!< standard two-electron dative
     DATIVEL,    //!< standard two-electron dative
     DATIVER,    //!< standard two-electron dative
     OTHER,
     ZERO  //!< Zero-order bond (from
     // http://pubs.acs.org/doi/abs/10.1021/ci200488k)
   } BondType;
 
   //! the bond's direction (for chirality)
   typedef enum {
     NONE = 0,    //!< no special style
     BEGINWEDGE,  //!< wedged: narrow at begin
     BEGINDASH,   //!< dashed: narrow at begin
     // FIX: this may not really be adequate
     ENDDOWNRIGHT,  //!< for cis/trans
     ENDUPRIGHT,    //!<  ditto
     EITHERDOUBLE,  //!< a "crossed" double bond
     UNKNOWN,       //!< intentionally unspecified stereochemistry
   } BondDir;
 
   //! the nature of the bond's stereochem (for cis/trans)
   typedef enum {     // stereochemistry of double bonds
     STEREONONE = 0,  // no special style
     STEREOANY,       // intentionally unspecified
     // -- Put any true specifications about this point so
     // that we can do comparisons like if(bond->getStereo()>Bond::STEREOANY)
     STEREOZ,     // Z double bond
     STEREOE,     // E double bond
     STEREOCIS,   // cis double bond
     STEREOTRANS  // trans double bond
   } BondStereo;
 
   Bond();
   //! construct with a particular BondType
   explicit Bond(BondType bT);
   Bond(const Bond &other);
   virtual ~Bond();
   Bond &operator=(const Bond &other);
 
+  Bond(Bond &&o) noexcept : RDProps(std::move(o)) {
+    df_isAromatic = o.df_isAromatic;
+    df_isConjugated = o.df_isConjugated;
+    d_bondType = o.d_bondType;
+    d_dirTag = o.d_dirTag;
+    d_stereo = o.d_stereo;
+    d_index = o.d_index;
+    d_beginAtomIdx = o.d_beginAtomIdx;
+    d_endAtomIdx = o.d_endAtomIdx;
+    // NOTE: this is somewhat fraught for bonds associated with molecules since
+    // the molecule will still be pointing to the original object
+    dp_mol = std::exchange(o.dp_mol, nullptr);
+    dp_stereoAtoms = std::exchange(o.dp_stereoAtoms, nullptr);
+  }
+  Bond &operator=(Bond &&o) noexcept {
+    if (this == &o) return *this;
+    RDProps::operator=(std::move(o));
+    df_isAromatic = o.df_isAromatic;
+    df_isConjugated = o.df_isConjugated;
+    d_bondType = o.d_bondType;
+    d_dirTag = o.d_dirTag;
+    d_stereo = o.d_stereo;
+    d_index = o.d_index;
+    d_beginAtomIdx = o.d_beginAtomIdx;
+    d_endAtomIdx = o.d_endAtomIdx;
+    // NOTE: this is somewhat fraught for bonds associated with molecules since
+    // the molecule will still be pointing to the original object
+    delete dp_stereoAtoms;
+    dp_mol = std::exchange(o.dp_mol, nullptr);
+    dp_stereoAtoms = std::exchange(o.dp_stereoAtoms, nullptr);
+    return *this;
+  }
+
   //! returns a copy
   /*!
     <b>Note:</b> the caller is responsible for <tt>delete</tt>ing
      the returned pointer.
   */
   virtual Bond *copy() const;
 
   //! returns our \c bondType
   BondType getBondType() const { return static_cast<BondType>(d_bondType); }
   //! sets our \c bondType
   void setBondType(BondType bT) { d_bondType = bT; }
   //! \brief returns our \c bondType as a double
   //!   (e.g. SINGLE->1.0, AROMATIC->1.5, etc.)
   double getBondTypeAsDouble() const;
 
   //! returns our contribution to the explicit valence of an Atom
   /*!
     <b>Notes:</b>
       - requires an owning molecule
   */
   virtual double getValenceContrib(const Atom *at) const;
 
   //! sets our \c isAromatic flag
   void setIsAromatic(bool what) { df_isAromatic = what; }
   //! returns the status of our \c isAromatic flag
   bool getIsAromatic() const { return df_isAromatic; }
 
   //! sets our \c isConjugated flag
   void setIsConjugated(bool what) { df_isConjugated = what; }
   //! returns the status of our \c isConjugated flag
   bool getIsConjugated() const { return df_isConjugated; }
 
   //! returns whether or not this instance belongs to a molecule
   bool hasOwningMol() const { return dp_mol != nullptr; }
 
   //! returns a reference to the ROMol that owns this instance
   ROMol &getOwningMol() const {
     PRECONDITION(dp_mol, "no owner");
     return *dp_mol;
   }
   //! sets our owning molecule
   void setOwningMol(ROMol *other);
   //! sets our owning molecule
   void setOwningMol(ROMol &other) { setOwningMol(&other); }
 
   //! returns our index within the ROMol
   /*!
     <b>Notes:</b>
       - this makes no sense if we do not have an owning molecule
 
   */
   unsigned int getIdx() const { return d_index; }
   //! sets our index within the ROMol
   /*!
     <b>Notes:</b>
       - this makes no sense if we do not have an owning molecule
       - the index should be <tt>< this->getOwningMol()->getNumBonds()</tt>
   */
   void setIdx(unsigned int index) { d_index = index; }
 
   //! returns the index of our begin Atom
   /*!
     <b>Notes:</b>
       - this makes no sense if we do not have an owning molecule
   */
   unsigned int getBeginAtomIdx() const { return d_beginAtomIdx; }
 
   //! returns the index of our end Atom
   /*!
     <b>Notes:</b>
       - this makes no sense if we do not have an owning molecule
   */
   unsigned int getEndAtomIdx() const { return d_endAtomIdx; }
 
   //! given the index of one Atom, returns the index of the other
   /*!
     <b>Notes:</b>
       - this makes no sense if we do not have an owning molecule
   */
   unsigned int getOtherAtomIdx(unsigned int thisIdx) const;
 
   //! sets the index of our begin Atom
   /*!
     <b>Notes:</b>
       - requires an owning molecule
   */
   void setBeginAtomIdx(unsigned int what);
   //! sets the index of our end Atom
   /*!
     <b>Notes:</b>
       - requires an owning molecule
   */
   void setEndAtomIdx(unsigned int what);
 
   //! sets our begin Atom
   /*!
     <b>Notes:</b>
       - requires an owning molecule
   */
   void setBeginAtom(Atom *at);
   //! sets our end Atom
   /*!
     <b>Notes:</b>
       - requires an owning molecule
   */
   void setEndAtom(Atom *at);
 
   //! returns a pointer to our begin Atom
   /*!
     <b>Notes:</b>
       - requires an owning molecule
   */
   Atom *getBeginAtom() const;
   //! returns a pointer to our end Atom
   /*!
     <b>Notes:</b>
       - requires an owning molecule
   */
   Atom *getEndAtom() const;
   //! returns a pointer to the other Atom
   /*!
     <b>Notes:</b>
       - requires an owning molecule
   */
   Atom *getOtherAtom(Atom const *what) const;
 
   // ------------------------------------
   // Please see the note in Atom.h for some explanation
   // of these methods
   // ------------------------------------
 
   // This method can be used to distinguish query bonds from standard bonds
   virtual bool hasQuery() const { return false; }
 
   // FIX: the const crap here is all mucked up.
   //! NOT CALLABLE
   virtual void setQuery(QUERYBOND_QUERY *what);
   //! NOT CALLABLE
   virtual QUERYBOND_QUERY *getQuery() const;
 
   //! NOT CALLABLE
   virtual void expandQuery(
       QUERYBOND_QUERY *what,
       Queries::CompositeQueryType how = Queries::COMPOSITE_AND,
       bool maintainOrder = true);
 
   //! returns whether or not we match the argument
   /*!
       <b>Notes:</b>
         - for Bond objects, "match" means that either one of the Bonds
           has \c bondType Bond::UNSPECIFIED or both Bonds have the
           same \c bondType.
   */
   virtual bool Match(Bond const *what) const;
 
   //! sets our direction
   void setBondDir(BondDir what) { d_dirTag = what; }
   //! returns our direction
   BondDir getBondDir() const { return static_cast<BondDir>(d_dirTag); }
 
   //! sets our stereo code
   /*!
       STEREONONE, STEREOANY, STEREOE and STEREOZ can be set without
       neighboring atoms specified in getStereoAtoms since they are
       defined by the topology of the molecular graph. In order to set
       STEREOCIS or STEREOTRANS the neighboring atoms must be set first
       (using setStereoBonds()) to know what atoms are being considered.
 
       <b>Notes:</b>
         - MolOps::findPotentialStereoBonds can be used to set
           getStereoAtoms before setting CIS/TRANS
   */
   void setStereo(BondStereo what) {
     PRECONDITION(what <= STEREOE || getStereoAtoms().size() == 2,
                  "Stereo atoms should be specified before specifying CIS/TRANS "
                  "bond stereochemistry")
     d_stereo = what;
   }
   //! returns our stereo code
   BondStereo getStereo() const { return static_cast<BondStereo>(d_stereo); }
 
   //! sets the atoms to be considered as reference points for bond stereo
   /*!
       These do not necessarily need to be the highest 'ranking' atoms
       like CIP stereo requires. They can be any arbitrary atoms
       neighboring the begin and end atoms of this bond
       respectively. STEREOCIS or STEREOTRANS is then set relative to
       only these atoms.
 
       If CIP rankings are desired, use
       MolOps::findPotentialStereoBonds, but this is a more costly
       function as it takes the whole molecule topology into account.
   */
   void setStereoAtoms(unsigned int bgnIdx, unsigned int endIdx);
 
   //! returns the indices of our stereo atoms
   const INT_VECT &getStereoAtoms() const {
     if (!dp_stereoAtoms) {
       const_cast<Bond *>(this)->dp_stereoAtoms = new INT_VECT();
     }
     return *dp_stereoAtoms;
   }
   //! \overload
   INT_VECT &getStereoAtoms() {
     if (!dp_stereoAtoms) dp_stereoAtoms = new INT_VECT();
     return *dp_stereoAtoms;
   }
 
   //! calculates any of our lazy \c properties
   /*!
     <b>Notes:</b>
       - requires an owning molecule
   */
   void updatePropertyCache(bool strict = true) { (void)strict; }
 
  protected:
   //! sets our owning molecule
   /// void setOwningMol(ROMol *other);
   //! sets our owning molecule
   /// void setOwningMol(ROMol &other) { setOwningMol(&other); }
   bool df_isAromatic;
   bool df_isConjugated;
   std::uint8_t d_bondType;
   std::uint8_t d_dirTag;
   std::uint8_t d_stereo;
   atomindex_t d_index;
   atomindex_t d_beginAtomIdx, d_endAtomIdx;
   ROMol *dp_mol;
   INT_VECT *dp_stereoAtoms;
 
   void initBond();
 };
 
 //! returns twice the \c bondType
 //! (e.g. SINGLE->2, AROMATIC->3, etc.)
diff --git a/Code/GraphMol/Conformer.h b/Code/GraphMol/Conformer.h
index 19d53f667..83ded52f1 100644
--- a/Code/GraphMol/Conformer.h
+++ b/Code/GraphMol/Conformer.h
@@ -39,110 +39,125 @@ class RDKIT_GRAPHMOL_EXPORT ConformerException : public std::exception {
 //! The class for representing 2D or 3D conformation of a molecule
 /*!
   This class contains
   - a pointer to the owing molecule
   - a vector of 3D points (positions of atoms)
 */
 class RDKIT_GRAPHMOL_EXPORT Conformer : public RDProps {
  public:
   friend class ROMol;
 
   //! Constructor
   Conformer() { d_positions.clear(); }
 
   //! Constructor with number of atoms specified ID specification
   Conformer(unsigned int numAtoms) {
     if (numAtoms) {
       d_positions.resize(numAtoms, RDGeom::Point3D(0.0, 0.0, 0.0));
     } else {
       d_positions.resize(0);
       d_positions.clear();
     }
   }
 
   //! Copy Constructor: initialize from a second conformation.
   Conformer(const Conformer &other);
   Conformer &operator=(const Conformer &other);
-
+  Conformer(Conformer &&o) noexcept
+      : RDProps(std::move(o)),
+        df_is3D(std::move(o.df_is3D)),
+        d_id(std::move(o.d_id)),
+        dp_mol(std::move(o.dp_mol)),
+        d_positions(std::move(o.d_positions)){};
+  Conformer &operator=(Conformer &&o) noexcept {
+    if (this == &o) {
+      return *this;
+    }
+    RDProps::operator=(std::move(o));
+    df_is3D = std::move(o.df_is3D);
+    d_id = std::move(o.d_id);
+    dp_mol = std::move(o.dp_mol);
+    d_positions = std::move(o.d_positions);
+  }
   //! Destructor
   ~Conformer() = default;
 
   //! Resize the conformer so that more atoms location can be added.
   //! Useful, for e.g., when adding hydrogens
   void resize(unsigned int size) { d_positions.resize(size); }
 
   //! Reserve more space for atom position
   void reserve(unsigned int size) { d_positions.reserve(size); }
 
   //! returns whether or not this instance belongs to a molecule
   bool hasOwningMol() const { return dp_mol != nullptr; }
 
   //! Get the molecule that owns this instance
   ROMol &getOwningMol() const {
     PRECONDITION(dp_mol, "no owner");
     return *dp_mol;
   }
 
   //! Get a const reference to the vector of atom positions
   const RDGeom::POINT3D_VECT &getPositions() const;
 
   //! Get a reference to the atom positions
   RDGeom::POINT3D_VECT &getPositions();
 
   //! Get the position of the specified atom
   const RDGeom::Point3D &getAtomPos(unsigned int atomId) const;
   //! overload
   template <class U>
   const RDGeom::Point3D &getAtomPos(U atomId) const {
     return getAtomPos(rdcast<unsigned int>(atomId));
   }
 
   //! Get the position of the specified atom
   RDGeom::Point3D &getAtomPos(unsigned int atomId);
   //! overload
   template <class U>
   RDGeom::Point3D &getAtomPos(U atomId) {
     return getAtomPos(rdcast<unsigned int>(atomId));
   }
 
   //! Set the position of the specified atom
   inline void setAtomPos(unsigned int atomId, const RDGeom::Point3D &position) {
     if (atomId == std::numeric_limits<unsigned int>::max()) {
       throw ValueErrorException("atom index overflow");
     }
     if (atomId >= d_positions.size()) {
       d_positions.resize(atomId + 1, RDGeom::Point3D(0.0, 0.0, 0.0));
     }
     d_positions[atomId] = position;
   }
   //! overload
   template <class U>
   void setAtomPos(U atomId, const RDGeom::Point3D &position) {
     return setAtomPos(rdcast<unsigned int>(atomId), position);
   }
   //! get the ID of this conformer
   inline unsigned int getId() const { return d_id; }
 
   //! set the ID of this conformer
   inline void setId(unsigned int id) { d_id = id; }
 
   //! Get the number of atoms
   inline unsigned int getNumAtoms() const {
     return rdcast<unsigned int>(d_positions.size());
   }
   inline bool is3D() const { return df_is3D; }
   inline void set3D(bool v) { df_is3D = v; }
 
  protected:
   //! Set owning molecule
   void setOwningMol(ROMol *mol);
 
   //! Set owning molecule
   void setOwningMol(ROMol &mol);
 
  private:
   bool df_is3D{true};                // is this a 3D conformation?
   unsigned int d_id{0};              // id is the conformation
   ROMol *dp_mol{nullptr};            // owning molecule
   RDGeom::POINT3D_VECT d_positions;  // positions of the atoms
   void initFromOther(const Conformer &conf);
 };
diff --git a/Code/GraphMol/QueryAtom.h b/Code/GraphMol/QueryAtom.h
index 83ac0acc6..b7d240a07 100644
--- a/Code/GraphMol/QueryAtom.h
+++ b/Code/GraphMol/QueryAtom.h
@@ -1,16 +1,16 @@
 //
-//  Copyright (C) 2001-2017 Greg Landrum and Rational Discovery LLC
+//  Copyright (C) 2001-2022 Greg Landrum and other RDKit contributors
 //
 //   @@ All Rights Reserved @@
 //  This file is part of the RDKit.
 //  The contents are covered by the terms of the BSD license
 //  which is included in the file license.txt, found at the root
 //  of the RDKit source tree.
 //
 #include <RDGeneral/export.h>
-#ifndef _RD_QUERYATOM_H_
-#define _RD_QUERYATOM_H_
+#ifndef RD_QUERYATOM_H
+#define RD_QUERYATOM_H
 
 #include "Atom.h"
 #include <Query/QueryObjects.h>
 #include <GraphMol/QueryOps.h>
@@ -26,93 +26,106 @@ namespace RDKit {
  */
 class RDKIT_GRAPHMOL_EXPORT QueryAtom : public Atom {
  public:
   typedef Queries::Query<int, Atom const *, true> QUERYATOM_QUERY;
 
   QueryAtom() : Atom() {}
   explicit QueryAtom(int num) : Atom(num), dp_query(makeAtomNumQuery(num)) {}
   explicit QueryAtom(const Atom &other)
       : Atom(other), dp_query(makeAtomNumQuery(other.getAtomicNum())) {
     if (other.getIsotope()) {
       this->expandQuery(makeAtomIsotopeQuery(other.getIsotope()),
                         Queries::CompositeQueryType::COMPOSITE_AND);
     }
     if (other.getFormalCharge()) {
       this->expandQuery(makeAtomFormalChargeQuery(other.getFormalCharge()),
                         Queries::CompositeQueryType::COMPOSITE_AND);
     }
     if (other.getNumRadicalElectrons()) {
       this->expandQuery(
           makeAtomNumRadicalElectronsQuery(other.getNumRadicalElectrons()),
           Queries::CompositeQueryType::COMPOSITE_AND);
     }
   }
   QueryAtom(const QueryAtom &other) : Atom(other) {
     if (other.dp_query) {
       dp_query = other.dp_query->copy();
     } else {
       dp_query = nullptr;
     }
   }
   QueryAtom &operator=(const QueryAtom &other) {
     if (this == &other) return *this;
     Atom::operator=(other);
     delete dp_query;
     if (other.dp_query) {
       dp_query = other.dp_query->copy();
     } else {
       dp_query = nullptr;
     }
     return *this;
   }
+
+  QueryAtom(QueryAtom &&other) noexcept : Atom(std::move(other)) {
+    dp_query = std::exchange(other.dp_query, nullptr);
+  }
+  QueryAtom &operator=(QueryAtom &&other) noexcept {
+    if (this == &other) {
+      return *this;
+    }
+    QueryAtom::operator=(std::move(other));
+    dp_query = std::exchange(other.dp_query, nullptr);
+    return *this;
+  }
+
   ~QueryAtom() override;
 
   //! returns a copy of this query, owned by the caller
   Atom *copy() const override;
 
   // This method can be used to distinguish query atoms from standard atoms:
   bool hasQuery() const override { return dp_query != nullptr; }
 
   //! replaces our current query with the value passed in
   std::string getQueryType() const override {
     return dp_query->getTypeLabel();
   }
 
   //! replaces our current query with the value passed in
   void setQuery(QUERYATOM_QUERY *what) override {
     delete dp_query;
     dp_query = what;
   }
   //! returns our current query
   QUERYATOM_QUERY *getQuery() const override { return dp_query; }
 
   //! expands our current query
   /*!
     \param what          the Queries::Query to be added. The ownership of
                          the query is passed to the current object, where it
                          might be deleted, so that the pointer should not be
                          used again in the calling code.
     \param how           the operator to be used in the expansion
     \param maintainOrder (optional) flags whether the relative order of
                          the queries needs to be maintained, if this is
                          false, the order is reversed
     <b>Notes:</b>
       - \c what should probably be constructed using one of the functions
          defined in QueryOps.h
       - the \c maintainOrder option can be useful because the combination
         operators short circuit when possible.
 
   */
   void expandQuery(QUERYATOM_QUERY *what,
                    Queries::CompositeQueryType how = Queries::COMPOSITE_AND,
                    bool maintainOrder = true) override;
 
   //! returns true if we match Atom \c what
   bool Match(Atom const *what) const override;
 
   //! returns true if our query details match those of QueryAtom \c what
   bool QueryMatch(QueryAtom const *what) const;
 
  private:
   QUERYATOM_QUERY *dp_query{nullptr};
 
 };  // end o' class
diff --git a/Code/GraphMol/QueryBond.h b/Code/GraphMol/QueryBond.h
index 8d3fadee6..1bfc52b7a 100644
--- a/Code/GraphMol/QueryBond.h
+++ b/Code/GraphMol/QueryBond.h
@@ -1,16 +1,16 @@
 //
-//  Copyright (C) 2001-2021 Greg Landrum and other RDKit contributors
+//  Copyright (C) 2001-2022 Greg Landrum and other RDKit contributors
 //
 //   @@ All Rights Reserved @@
 //  This file is part of the RDKit.
 //  The contents are covered by the terms of the BSD license
 //  which is included in the file license.txt, found at the root
 //  of the RDKit source tree.
 //
 #include <RDGeneral/export.h>
 #ifndef _RD_QUERYBOND_H
 #define _RD_QUERYBOND_H
 
 #include <Query/QueryObjects.h>
 #include "Bond.h"
 #include "QueryOps.h"
@@ -28,79 +28,91 @@ namespace RDKit {
 class RDKIT_GRAPHMOL_EXPORT QueryBond : public Bond {
  public:
   typedef Queries::Query<int, Bond const *, true> QUERYBOND_QUERY;
 
   QueryBond() : Bond() {}
   //! initialize with a particular bond order
   explicit QueryBond(BondType bT);
   //! initialize from a bond
   explicit QueryBond(const Bond &other)
       : Bond(other), dp_query(makeBondOrderEqualsQuery(other.getBondType())) {}
   QueryBond(const QueryBond &other) : Bond(other) {
     if (other.dp_query) {
       dp_query = other.dp_query->copy();
     } else {
       dp_query = nullptr;
     }
   }
+  QueryBond(QueryBond &&other) noexcept : Bond(std::move(other)) {
+    dp_query = std::move(other.dp_query);
+  }
+  QueryBond &operator=(QueryBond &&other) noexcept {
+    if (this == &other) {
+      return *this;
+    }
+    QueryBond::operator=(std::move(other));
+    dp_query = std::move(other.dp_query);
+    return *this;
+  }
+
   ~QueryBond() override;
 
   //! returns a copy of this query, owned by the caller
   Bond *copy() const override;
 
   QueryBond &operator=(const QueryBond &other);
 
   //! sets the BondType of this query:
   void setBondType(BondType bT);
   //! sets the BondDir of this query:
   void setBondDir(BondDir bD);
 
   //! returns true if we match Bond \c what
   bool Match(Bond const *what) const override;
 
   //! returns true if our query details match those of QueryBond \c what
   bool QueryMatch(QueryBond const *what) const;
 
   // This method can be used to distinguish query bonds from standard bonds
   bool hasQuery() const override { return dp_query != nullptr; }
 
   //! returns our current query
   QUERYBOND_QUERY *getQuery() const override { return dp_query; }
   //! replaces our current query with the value passed in
   void setQuery(QUERYBOND_QUERY *what) override {
     // free up any existing query (Issue255):
     delete dp_query;
     dp_query = what;
   }
 
   //! expands our current query
   /*!
     \param what          the Queries::Query to be added. The ownership of
                          the query is passed to the current object, where it
                          might be deleted, so that the pointer should not be
                          used again in the calling code.
     \param how           the operator to be used in the expansion
     \param maintainOrder (optional) flags whether the relative order of
                          the queries needs to be maintained, if this is
                          false, the order is reversed
 
     <b>Notes:</b>
       - \c what should probably be constructed using one of the functions
          defined in QueryOps.h
       - the \c maintainOrder option can be useful because the combination
         operators short circuit when possible.
 
   */
   void expandQuery(QUERYBOND_QUERY *what,
                    Queries::CompositeQueryType how = Queries::COMPOSITE_AND,
                    bool maintainOrder = true) override;
 
   //! returns our contribution to the explicit valence of an Atom
   /*!
     <b>Notes:</b>
       - requires an owning molecule
   */
   double getValenceContrib(const Atom *at) const override;
 
  protected:
   QUERYBOND_QUERY *dp_query{nullptr};
 };
diff --git a/Code/GraphMol/ROMol.h b/Code/GraphMol/ROMol.h
index 6d1c370e4..a2b465666 100644
--- a/Code/GraphMol/ROMol.h
+++ b/Code/GraphMol/ROMol.h
@@ -1,42 +1,43 @@
 //
 //  Copyright (C) 2003-2018 Greg Landrum and Rational Discovery LLC
 //
 //   @@ All Rights Reserved @@
 //  This file is part of the RDKit.
 //  The contents are covered by the terms of the BSD license
 //  which is included in the file license.txt, found at the root
 //  of the RDKit source tree.
 //
 /*! \file ROMol.h
 
   \brief Defines the primary molecule class \c ROMol as well as associated
   typedefs
 
 */
 
 #include <RDGeneral/export.h>
 #ifndef RD_ROMOL_H
 #define RD_ROMOL_H
 
 /// Std stuff
 #include <utility>
 #include <map>
 
 // boost stuff
 #include <RDGeneral/BoostStartInclude.h>
 #include <boost/graph/adjacency_list.hpp>
 #include <boost/smart_ptr.hpp>
 #include <boost/dynamic_bitset.hpp>
 #include <RDGeneral/BoostEndInclude.h>
 
 // our stuff
 #include <RDGeneral/types.h>
 #include <RDGeneral/RDProps.h>
 #include "Atom.h"
 #include "Bond.h"
 #include "Conformer.h"
 #include "SubstanceGroup.h"
 #include "StereoGroup.h"
+#include "RingInfo.h"
 
 namespace RDKit {
 class SubstanceGroup;
@@ -178,596 +179,655 @@ struct CXXBondIterator {
 class RDKIT_GRAPHMOL_EXPORT ROMol : public RDProps {
  public:
   friend class MolPickler;
   friend class RWMol;
 
   //! \cond TYPEDEFS
 
   //! \name typedefs
   //@{
   typedef MolGraph::vertex_descriptor vertex_descriptor;
   typedef MolGraph::edge_descriptor edge_descriptor;
 
   typedef MolGraph::edge_iterator EDGE_ITER;
   typedef MolGraph::out_edge_iterator OEDGE_ITER;
   typedef MolGraph::vertex_iterator VERTEX_ITER;
   typedef MolGraph::adjacency_iterator ADJ_ITER;
   typedef std::pair<EDGE_ITER, EDGE_ITER> BOND_ITER_PAIR;
   typedef std::pair<OEDGE_ITER, OEDGE_ITER> OBOND_ITER_PAIR;
   typedef std::pair<VERTEX_ITER, VERTEX_ITER> ATOM_ITER_PAIR;
   typedef std::pair<ADJ_ITER, ADJ_ITER> ADJ_ITER_PAIR;
 
   typedef std::vector<Atom *> ATOM_PTR_VECT;
   typedef ATOM_PTR_VECT::iterator ATOM_PTR_VECT_I;
   typedef ATOM_PTR_VECT::const_iterator ATOM_PTR_VECT_CI;
   typedef std::vector<Bond *> BOND_PTR_VECT;
   typedef BOND_PTR_VECT::iterator BOND_PTR_VECT_I;
   typedef BOND_PTR_VECT::const_iterator BOND_PTR_VECT_CI;
 
   typedef std::list<Atom *> ATOM_PTR_LIST;
   typedef ATOM_PTR_LIST::iterator ATOM_PTR_LIST_I;
   typedef ATOM_PTR_LIST::const_iterator ATOM_PTR_LIST_CI;
   typedef std::list<Bond *> BOND_PTR_LIST;
   typedef BOND_PTR_LIST::iterator BOND_PTR_LIST_I;
   typedef BOND_PTR_LIST::const_iterator BOND_PTR_LIST_CI;
 
   // list of conformations
   typedef std::list<CONFORMER_SPTR> CONF_SPTR_LIST;
   typedef CONF_SPTR_LIST::iterator CONF_SPTR_LIST_I;
   typedef CONF_SPTR_LIST::const_iterator CONF_SPTR_LIST_CI;
   typedef std::pair<CONF_SPTR_LIST_I, CONF_SPTR_LIST_I> CONFS_I_PAIR;
 
   // ROFIX: these will need to be readonly somehow?
   typedef std::map<int, ATOM_PTR_LIST> ATOM_BOOKMARK_MAP;
   typedef std::map<int, BOND_PTR_LIST> BOND_BOOKMARK_MAP;
 
   typedef class AtomIterator_<Atom, ROMol> AtomIterator;
   typedef class AtomIterator_<const Atom, const ROMol> ConstAtomIterator;
   typedef class BondIterator_ BondIterator;
   typedef class ConstBondIterator_ ConstBondIterator;
   typedef class AromaticAtomIterator_<Atom, ROMol> AromaticAtomIterator;
   typedef class AromaticAtomIterator_<const Atom, const ROMol>
       ConstAromaticAtomIterator;
   typedef class HeteroatomIterator_<Atom, ROMol> HeteroatomIterator;
   typedef class HeteroatomIterator_<const Atom, const ROMol>
       ConstHeteroatomIterator;
   typedef class QueryAtomIterator_<Atom, ROMol> QueryAtomIterator;
   typedef class QueryAtomIterator_<const Atom, const ROMol>
       ConstQueryAtomIterator;
   typedef class MatchingAtomIterator_<Atom, ROMol> MatchingAtomIterator;
   typedef class MatchingAtomIterator_<const Atom, const ROMol>
       ConstMatchingAtomIterator;
 
   typedef CONF_SPTR_LIST_I ConformerIterator;
   typedef CONF_SPTR_LIST_CI ConstConformerIterator;
 
   //@}
   //! \endcond
 
   //! C++11 Range iterator
   /*!
     <b>Usage</b>
     \code
       for(auto atom : mol.atoms()) {
          atom->getIdx();
       };
     \endcode
    */
 
   CXXAtomIterator<MolGraph, Atom *> atoms() { return {&d_graph}; }
 
   CXXAtomIterator<const MolGraph, Atom *const> atoms() const {
     return {&d_graph};
   }
 
   CXXAtomIterator<const MolGraph, Atom *const, MolGraph::adjacency_iterator>
   atomNeighbors(Atom const *at) const {
     auto pr = getAtomNeighbors(at);
     return {&d_graph, pr.first, pr.second};
   }
 
   CXXAtomIterator<MolGraph, Atom *, MolGraph::adjacency_iterator> atomNeighbors(
       Atom const *at) {
     auto pr = getAtomNeighbors(at);
     return {&d_graph, pr.first, pr.second};
   }
 
   CXXBondIterator<const MolGraph, Bond *const, MolGraph::out_edge_iterator>
   atomBonds(Atom const *at) const {
     auto pr = getAtomBonds(at);
     return {&d_graph, pr.first, pr.second};
   }
 
   CXXBondIterator<MolGraph, Bond *, MolGraph::out_edge_iterator> atomBonds(
       Atom const *at) {
     auto pr = getAtomBonds(at);
     return {&d_graph, pr.first, pr.second};
   }
 
   /*!
   <b>Usage</b>
   \code
     for(auto bond : mol.bonds()) {
        bond->getIdx();
     };
   \endcode
  */
 
   CXXBondIterator<MolGraph, Bond *> bonds() { return {&d_graph}; }
 
   CXXBondIterator<const MolGraph, Bond *const> bonds() const {
     return {&d_graph};
   }
 
   ROMol() : RDProps() { initMol(); }
 
   //! copy constructor with a twist
   /*!
     \param other     the molecule to be copied
     \param quickCopy (optional) if this is true, the resulting ROMol will not
          copy any of the properties or bookmarks and conformers from \c other.
     This can
          make the copy substantially faster (thus the name).
     \param confId (optional) if this is >=0, the resulting ROMol will contain
     only
          the specified conformer from \c other.
   */
   ROMol(const ROMol &other, bool quickCopy = false, int confId = -1)
       : RDProps() {
     dp_ringInfo = nullptr;
     initFromOther(other, quickCopy, confId);
     numBonds = rdcast<unsigned int>(boost::num_edges(d_graph));
   }
   //! construct a molecule from a pickle string
   ROMol(const std::string &binStr);
   //! construct a molecule from a pickle string
   ROMol(const std::string &binStr, unsigned int propertyFlags);
 
+  ROMol(ROMol &&o) noexcept
+      : RDProps(std::move(o)),
+        d_graph(std::move(o.d_graph)),
+        d_atomBookmarks(std::move(o.d_atomBookmarks)),
+        d_bondBookmarks(std::move(o.d_bondBookmarks)),
+        d_confs(std::move(o.d_confs)),
+        d_sgroups(std::move(o.d_sgroups)),
+        d_stereo_groups(std::move(o.d_stereo_groups)),
+        numBonds(o.numBonds) {
+    for (auto atom : atoms()) {
+      atom->setOwningMol(this);
+    }
+    for (auto bond : bonds()) {
+      bond->setOwningMol(this);
+    }
+    for (auto conf : d_confs) {
+      conf->setOwningMol(this);
+    }
+    o.d_graph.clear();
+    o.numBonds = 0;
+    dp_ringInfo = std::exchange(o.dp_ringInfo, nullptr);
+    dp_delAtoms = std::exchange(o.dp_delAtoms, nullptr);
+    dp_delBonds = std::exchange(o.dp_delBonds, nullptr);
+  }
+  ROMol &operator=(ROMol &&o) noexcept {
+    if (this == &o) {
+      return *this;
+    }
+    RDProps::operator=(std::move(o));
+    d_graph = std::move(o.d_graph);
+    d_atomBookmarks = std::move(o.d_atomBookmarks);
+    d_bondBookmarks = std::move(o.d_bondBookmarks);
+    if (dp_ringInfo) {
+      delete dp_ringInfo;
+    }
+    dp_ringInfo = std::exchange(o.dp_ringInfo, nullptr);
+
+    d_confs = std::move(o.d_confs);
+    d_sgroups = std::move(o.d_sgroups);
+    d_stereo_groups = std::move(o.d_stereo_groups);
+    dp_delAtoms = std::exchange(o.dp_delAtoms, nullptr);
+    dp_delBonds = std::exchange(o.dp_delBonds, nullptr);
+    numBonds = o.numBonds;
+    o.numBonds = 0;
+
+    for (auto atom : atoms()) {
+      atom->setOwningMol(this);
+    }
+    for (auto bond : bonds()) {
+      bond->setOwningMol(this);
+    }
+    for (auto conf : d_confs) {
+      conf->setOwningMol(this);
+    }
+
+    o.d_graph.clear();
+    return *this;
+  }
+
+  ROMol &operator=(const ROMol &) =
+      delete;  // disable assignment, RWMol's support assignment
+
   virtual ~ROMol() { destroy(); }
 
   //@}
   //! \name Atoms
   //@{
 
   //! returns our number of atoms
   inline unsigned int getNumAtoms() const {
     return rdcast<unsigned int>(boost::num_vertices(d_graph));
   }
   unsigned int getNumAtoms(bool onlyExplicit) const;
   //! returns our number of heavy atoms (atomic number > 1)
   unsigned int getNumHeavyAtoms() const;
   //! returns a pointer to a particular Atom
   Atom *getAtomWithIdx(unsigned int idx);
   //! \overload
   const Atom *getAtomWithIdx(unsigned int idx) const;
   //! \overload
   template <class U>
   Atom *getAtomWithIdx(const U idx) {
     return getAtomWithIdx(rdcast<unsigned int>(idx));
   }
   //! \overload
   template <class U>
   const Atom *getAtomWithIdx(const U idx) const {
     return getAtomWithIdx(rdcast<unsigned int>(idx));
   }
   //! returns the degree (number of neighbors) of an Atom in the graph
   unsigned int getAtomDegree(const Atom *at) const;
   //@}
 
   //! \name Bonds
   //@{
 
   //! returns our number of Bonds
   unsigned int getNumBonds(bool onlyHeavy = 1) const;
   //! returns a pointer to a particular Bond
   Bond *getBondWithIdx(unsigned int idx);
   //! \overload
   const Bond *getBondWithIdx(unsigned int idx) const;
   //! \overload
   template <class U>
   Bond *getBondWithIdx(const U idx) {
     return getBondWithIdx(rdcast<unsigned int>(idx));
   }
   //! \overload
   template <class U>
   const Bond *getBondWithIdx(const U idx) const {
     return getBondWithIdx(rdcast<unsigned int>(idx));
   }
   //! returns a pointer to the bond between two atoms, Null on failure
   Bond *getBondBetweenAtoms(unsigned int idx1, unsigned int idx2);
   //! \overload
   const Bond *getBondBetweenAtoms(unsigned int idx1, unsigned int idx2) const;
   //! \overload
   template <class U, class V>
   Bond *getBondBetweenAtoms(const U idx1, const V idx2) {
     return getBondBetweenAtoms(rdcast<unsigned int>(idx1),
                                rdcast<unsigned int>(idx2));
   }
   //! \overload
   template <class U, class V>
   const Bond *getBondBetweenAtoms(const U idx1, const V idx2) const {
     return getBondBetweenAtoms(rdcast<unsigned int>(idx1),
                                rdcast<unsigned int>(idx2));
   }
 
   //@}
 
   //! \name Bookmarks
   //@{
 
   //! associates an Atom pointer with a bookmark
   void setAtomBookmark(Atom *at, int mark) {
     d_atomBookmarks[mark].push_back(at);
   }
   //! associates an Atom pointer with a bookmark
   void replaceAtomBookmark(Atom *at, int mark) {
     d_atomBookmarks[mark].clear();
     d_atomBookmarks[mark].push_back(at);
   }
   //! returns the first Atom associated with the \c bookmark provided
   Atom *getAtomWithBookmark(int mark);
   //! returns the Atom associated with the \c bookmark provided
   //! a check is made to ensure it is the only atom with that bookmark
   Atom *getUniqueAtomWithBookmark(int mark);
   //! returns all Atoms associated with the \c bookmark provided
   ATOM_PTR_LIST &getAllAtomsWithBookmark(int mark);
   //! removes a \c bookmark from our collection
   void clearAtomBookmark(int mark);
   //! removes a particular Atom from the list associated with the \c bookmark
   void clearAtomBookmark(int mark, const Atom *atom);
 
   //! blows out all atomic \c bookmarks
   void clearAllAtomBookmarks() { d_atomBookmarks.clear(); }
   //! queries whether or not any atoms are associated with a \c bookmark
   bool hasAtomBookmark(int mark) const { return d_atomBookmarks.count(mark); }
   //! returns a pointer to all of our atom \c bookmarks
   ATOM_BOOKMARK_MAP *getAtomBookmarks() { return &d_atomBookmarks; }
 
   //! associates a Bond pointer with a bookmark
   void setBondBookmark(Bond *bond, int mark) {
     d_bondBookmarks[mark].push_back(bond);
   }
   //! returns the first Bond associated with the \c bookmark provided
   Bond *getBondWithBookmark(int mark);
   //! returns the Bond associated with the \c bookmark provided
   //! a check is made to ensure it is the only bond with that bookmark
   Bond *getUniqueBondWithBookmark(int mark);
   //! returns all bonds associated with the \c bookmark provided
   BOND_PTR_LIST &getAllBondsWithBookmark(int mark);
   //! removes a \c bookmark from our collection
   void clearBondBookmark(int mark);
   //! removes a particular Bond from the list associated with the \c bookmark
   void clearBondBookmark(int mark, const Bond *bond);
 
   //! blows out all bond \c bookmarks
   void clearAllBondBookmarks() { d_bondBookmarks.clear(); }
   //! queries whether or not any bonds are associated with a \c bookmark
   bool hasBondBookmark(int mark) const { return d_bondBookmarks.count(mark); }
   //! returns a pointer to all of our bond \c bookmarks
   BOND_BOOKMARK_MAP *getBondBookmarks() { return &d_bondBookmarks; }
 
   //@}
 
   //! \name Conformers
   //@{
 
   //! return the conformer with a specified ID
   //! if the ID is negative the first conformation will be returned
   const Conformer &getConformer(int id = -1) const;
 
   //! return the conformer with a specified ID
   //! if the ID is negative the first conformation will be returned
   Conformer &getConformer(int id = -1);
 
   //! Delete the conformation with the specified ID
   void removeConformer(unsigned int id);
 
   //! Clear all the conformations on the molecule
   void clearConformers() { d_confs.clear(); }
 
   //! Add a new conformation to the molecule
   /*!
     \param conf - conformation to be added to the molecule, this molecule takes
     ownership
                   of the conformer
     \param assignId - a unique ID will be assigned to the conformation if
     true
                       otherwise it is assumed that the conformation already has
     an (unique) ID set
   */
   unsigned int addConformer(Conformer *conf, bool assignId = false);
 
   inline unsigned int getNumConformers() const {
     return rdcast<unsigned int>(d_confs.size());
   }
 
   //! \name Topology
   //@{
 
   //! returns a pointer to our RingInfo structure
   //! <b>Note:</b> the client should not delete this.
   RingInfo *getRingInfo() const { return dp_ringInfo; }
 
   //! provides access to all neighbors around an Atom
   /*!
     \param at the atom whose neighbors we are looking for
 
     <b>Usage</b>
     \code
       ... mol is a const ROMol & ...
       ... atomPtr is a const Atom * ...
       ... requires #include <boost/range/iterator_range.hpp>
       for (const auto &nbri :
            boost::make_iterator_range(m.getAtomNeighbors(atomPtr))) {
         const auto &nbr = (*m)[nbri];
         // nbr is an atom pointer
       }
 
     \endcode
 
   */
   ADJ_ITER_PAIR getAtomNeighbors(Atom const *at) const;
 
   //! provides access to all Bond objects connected to an Atom
   /*!
     \param at the atom whose neighbors we are looking for
 
     <b>Usage</b>
     \code
       ... mol is a const ROMol & ...
       ... atomPtr is a const Atom * ...
       ... requires #include <boost/range/iterator_range.hpp>
       for (const auto &nbri :
            boost::make_iterator_range(m.getAtomBonds(atomPtr))) {
         const auto &nbr = (*m)[nbri];
         // nbr is a bond pointer
       }
     \endcode
     or, if you need a non-const Bond *:
     \code
       ... mol is a const ROMol & ...
       ... atomPtr is a const Atom * ...
       ... requires #include <boost/range/iterator_range.hpp>
       for (const auto &nbri :
            boost::make_iterator_range(m.getAtomBonds(atomPtr))) {
         auto nbr = (*m)[nbri];
         // nbr is a bond pointer
       }
     \endcode
 
 
   */
   OBOND_ITER_PAIR getAtomBonds(Atom const *at) const;
 
   //! returns an iterator pair for looping over all Atoms
   /*!
 
     <b>Usage</b>
     \code
 
       ROMol::VERTEX_ITER atBegin,atEnd;
       boost::tie(atBegin,atEnd) = mol.getVertices();
       while(atBegin!=atEnd){
         ATOM_SPTR at2=mol[*atBegin];
         ... do something with the Atom ...
         ++atBegin;
       }
     \endcode
   */
   ATOM_ITER_PAIR getVertices();
   //! returns an iterator pair for looping over all Bonds
   /*!
 
     <b>Usage</b>
     \code
 
       ROMol::EDGE_ITER firstB,lastB;
       boost::tie(firstB,lastB) = mol.getEdges();
       while(firstB!=lastB){
         BOND_SPTR bond = mol[*firstB];
         ... do something with the Bond ...
         ++firstB;
       }
     \endcode
   */
   BOND_ITER_PAIR getEdges();
   //! \overload
   ATOM_ITER_PAIR getVertices() const;
   //! \overload
   BOND_ITER_PAIR getEdges() const;
 
   //! brief returns a pointer to our underlying BGL object
   /*!
       This can be useful if you need to call other BGL algorithms:
 
       Here's an example:
       \code
          ... mol is a const ROMol ...
          ... mapping is an INT_VECT ...
          mapping.resize(mol.getNumAtoms());
          const MolGraph &G_p = mol.getTopology();
          int res = boost::connected_components(G_p,&mapping[0]);
       \endcode
    */
   MolGraph const &getTopology() const { return d_graph; }
   //@}
 
   //! \name Iterators
   //@{
 
   //! get an AtomIterator pointing at our first Atom
   AtomIterator beginAtoms();
   //! \overload
   ConstAtomIterator beginAtoms() const;
   //! get an AtomIterator pointing at the end of our Atoms
   AtomIterator endAtoms();
   //! \overload
   ConstAtomIterator endAtoms() const;
   //! get a BondIterator pointing at our first Bond
   BondIterator beginBonds();
   //! \overload
   ConstBondIterator beginBonds() const;
   //! get a BondIterator pointing at the end of our Bonds
   BondIterator endBonds();
   //! \overload
   ConstBondIterator endBonds() const;
 
   //! get an AtomIterator pointing at our first aromatic Atom
   AromaticAtomIterator beginAromaticAtoms();
   //! \overload
   ConstAromaticAtomIterator beginAromaticAtoms() const;
   //! get an AtomIterator pointing at the end of our Atoms
   AromaticAtomIterator endAromaticAtoms();
   //! \overload
   ConstAromaticAtomIterator endAromaticAtoms() const;
 
   //! get an AtomIterator pointing at our first hetero Atom
   HeteroatomIterator beginHeteros();
   //! \overload
   ConstHeteroatomIterator beginHeteros() const;
   //! get an AtomIterator pointing at the end of our Atoms
   HeteroatomIterator endHeteros();
   //! \overload
   ConstHeteroatomIterator endHeteros() const;
 
   //! get an AtomIterator pointing at our first Atom that matches \c query
   QueryAtomIterator beginQueryAtoms(QueryAtom const *query);
   //! \overload
   ConstQueryAtomIterator beginQueryAtoms(QueryAtom const *) const;
   //! get an AtomIterator pointing at the end of our Atoms
   QueryAtomIterator endQueryAtoms();
   //! \overload
   ConstQueryAtomIterator endQueryAtoms() const;
 
   //! get an AtomIterator pointing at our first Atom that matches \c query
   MatchingAtomIterator beginMatchingAtoms(bool (*query)(Atom *));
   //! \overload
   ConstMatchingAtomIterator beginMatchingAtoms(
       bool (*query)(const Atom *)) const;
   //! get an AtomIterator pointing at the end of our Atoms
   MatchingAtomIterator endMatchingAtoms();
   //! \overload
   ConstMatchingAtomIterator endMatchingAtoms() const;
 
   inline ConformerIterator beginConformers() { return d_confs.begin(); }
 
   inline ConformerIterator endConformers() { return d_confs.end(); }
 
   inline ConstConformerIterator beginConformers() const {
     return d_confs.begin();
   }
 
   inline ConstConformerIterator endConformers() const { return d_confs.end(); }
 
   //@}
 
   //! \name Properties
   //@{
 
   //! clears all of our \c computed \c properties
   void clearComputedProps(bool includeRings = true) const;
   //! calculates any of our lazy \c properties
   /*!
     <b>Notes:</b>
        - this calls \c updatePropertyCache() on each of our Atoms and Bonds
   */
   void updatePropertyCache(bool strict = true);
 
   bool needsUpdatePropertyCache() const;
 
   //@}
 
   //! \name Misc
   //@{
   //! sends some debugging info to a stream
   void debugMol(std::ostream &str) const;
   //@}
 
   Atom *operator[](const vertex_descriptor &v) { return d_graph[v]; }
   const Atom *operator[](const vertex_descriptor &v) const {
     return d_graph[v];
   }
 
   Bond *operator[](const edge_descriptor &e) { return d_graph[e]; }
   const Bond *operator[](const edge_descriptor &e) const { return d_graph[e]; }
 
   //! Gets a reference to the groups of atoms with relative stereochemistry
   /*!
     Stereo groups are also called enhanced stereochemistry in the SDF/Mol3000
     file format.
   */
   const std::vector<StereoGroup> &getStereoGroups() const {
     return d_stereo_groups;
   }
 
   //! Sets groups of atoms with relative stereochemistry
   /*!
     \param stereo_groups the new set of stereo groups. All will be replaced.
 
     Stereo groups are also called enhanced stereochemistry in the SDF/Mol3000
     file format. stereo_groups should be std::move()ed into this function.
   */
   void setStereoGroups(std::vector<StereoGroup> stereo_groups);
 
  private:
   MolGraph d_graph;
   ATOM_BOOKMARK_MAP d_atomBookmarks;
   BOND_BOOKMARK_MAP d_bondBookmarks;
   RingInfo *dp_ringInfo = nullptr;
   CONF_SPTR_LIST d_confs;
   std::vector<SubstanceGroup> d_sgroups;
   std::vector<StereoGroup> d_stereo_groups;
   std::unique_ptr<boost::dynamic_bitset<>> dp_delAtoms = nullptr;
   std::unique_ptr<boost::dynamic_bitset<>> dp_delBonds = nullptr;
 
   friend RDKIT_GRAPHMOL_EXPORT std::vector<SubstanceGroup> &getSubstanceGroups(
       ROMol &);
   friend RDKIT_GRAPHMOL_EXPORT const std::vector<SubstanceGroup>
       &getSubstanceGroups(const ROMol &);
   void clearSubstanceGroups() { d_sgroups.clear(); }
 
-  ROMol &operator=(
-      const ROMol &);  // disable assignment, RWMol's support assignment
-
  protected:
   unsigned int numBonds{0};
 #ifndef WIN32
  private:
 #endif
   void initMol();
   virtual void destroy();
   //! adds an Atom to our collection
   /*!
     \param atom          pointer to the Atom to add
     \param updateLabel   (optional) if this is true, the new Atom will be
                          our \c activeAtom
     \param takeOwnership (optional) if this is true, we take ownership of \c
     atom
                          instead of copying it.
 
     \return the new number of atoms
   */
   unsigned int addAtom(Atom *atom, bool updateLabel = true,
                        bool takeOwnership = false);
   //! adds a Bond to our collection
   /*!
     \param bond          pointer to the Bond to add
     \param takeOwnership (optional) if this is true, we take ownership of \c
     bond
                          instead of copying it.
 
     \return the new number of bonds
   */
   unsigned int addBond(Bond *bond, bool takeOwnership = false);
 
   //! adds a Bond to our collection
   /*!
     \param bond          pointer to the Bond to add
 
     \return the new number of bonds
 
     <b>Note:</b> since this is using a smart pointer, we don't need to worry
     about
     issues of ownership.
   */
   void initFromOther(const ROMol &other, bool quickCopy, int confId);
 };
diff --git a/Code/GraphMol/RWMol.h b/Code/GraphMol/RWMol.h
index 09a281321..ff2aa218d 100644
--- a/Code/GraphMol/RWMol.h
+++ b/Code/GraphMol/RWMol.h
@@ -31,179 +31,185 @@ namespace RDKit {
  */
 class RDKIT_GRAPHMOL_EXPORT RWMol : public ROMol {
  public:
   RWMol() : ROMol() {}
   //! copy constructor with a twist
   /*!
     \param other     the molecule to be copied
     \param quickCopy (optional) if this is true, the resulting ROMol will not
          copy any of the properties or bookmarks and conformers from \c other.
     This can
          make the copy substantially faster (thus the name).
     \param confId if this is >=0, the resulting ROMol will contain only
          the specified conformer from \c other.
   */
   RWMol(const ROMol &other, bool quickCopy = false, int confId = -1)
       : ROMol(other, quickCopy, confId) {}
   RWMol(const RWMol &other) : ROMol(other) {}
   RWMol &operator=(const RWMol &);
+  RWMol(RWMol &&other) noexcept : ROMol(std::move(other)) {}
+  RWMol &operator=(RWMol &&other) noexcept { 
+    ROMol::operator=(std::move(other)); 
+    return *this;
+  }
+
 
   //! insert the atoms and bonds from \c other into this molecule
   void insertMol(const ROMol &other);
 
   //! \name Atoms
   //@{
 
   //! adds an empty Atom to our collection
   /*!
     \param updateLabel   (optional) if this is true, the new Atom will be
                          our \c activeAtom
 
     \return the index of the added atom
 
   */
   unsigned int addAtom(bool updateLabel = true);
 
   //! adds an Atom to our collection
   /*!
     \param atom          pointer to the Atom to add
     \param updateLabel   (optional) if this is true, the new Atom will be
                          our \c activeAtom
     \param takeOwnership (optional) if this is true, we take ownership of \c
     atom
                          instead of copying it.
 
     \return the index of the added atom
   */
   unsigned int addAtom(Atom *atom, bool updateLabel = true,
                        bool takeOwnership = false) {
     return ROMol::addAtom(atom, updateLabel, takeOwnership);
   }
 
   //! adds an Atom to our collection
 
   //! replaces a particular Atom
   /*!
     \param idx          the index of the Atom to replace
     \param atom         the new atom, which will be copied.
     \param updateLabel   (optional) if this is true, the new Atom will be
                          our \c activeAtom
     \param preserveProps if true preserve the original atom property data
 
   */
   void replaceAtom(unsigned int idx, Atom *atom, bool updateLabel = false,
                    bool preserveProps = false);
   //! returns a pointer to the highest-numbered Atom
   Atom *getLastAtom() { return getAtomWithIdx(getNumAtoms() - 1); }
   //! returns a pointer to the "active" Atom
   /*!
      If we have an \c activeAtom, it will be returned,
      otherwise the results of getLastAtom() will be returned.
    */
   Atom *getActiveAtom();
   //! sets our \c activeAtom
   void setActiveAtom(Atom *atom);
   //! \overload
   void setActiveAtom(unsigned int idx);
   //! removes an Atom from the molecule
   void removeAtom(unsigned int idx);
   //! \overload
   void removeAtom(Atom *atom);
 
   //@}
 
   //! \name Bonds
   //@{
 
   //! adds a Bond between the indicated Atoms
   /*!
      \return the number of Bonds
   */
   unsigned int addBond(unsigned int beginAtomIdx, unsigned int endAtomIdx,
                        Bond::BondType order = Bond::UNSPECIFIED);
   //! \overload
   unsigned int addBond(Atom *beginAtom, Atom *endAtom,
                        Bond::BondType order = Bond::UNSPECIFIED);
 
   //! adds a Bond to our collection
   /*!
     \param bond          pointer to the Bond to add
     \param takeOwnership (optional) if this is true, we take ownership of \c
     bond
                          instead of copying it.
 
     \return the new number of bonds
   */
   unsigned int addBond(Bond *bond, bool takeOwnership = false) {
     return ROMol::addBond(bond, takeOwnership);
   }
 
   //! starts a Bond and sets its beginAtomIdx
   /*!
     \return a pointer to the new bond
 
     The caller should set a bookmark to the returned Bond in order
     to be able to later complete it:
 
     \verbatim
       Bond *pBond = mol->createPartialBond(1);
       mol->setBondBookmark(pBond,666);
       ... do some other stuff ...
       mol->finishPartialBond(2,666,Bond::SINGLE);
       mol->clearBondBookmark(666,pBond);
     \endverbatim
 
     or, if we want to set the \c BondType initially:
     \verbatim
       Bond *pBond = mol->createPartialBond(1,Bond::DOUBLE);
       mol->setBondBookmark(pBond,666);
       ... do some other stuff ...
       mol->finishPartialBond(2,666);
       mol->clearBondBookmark(666,pBond);
     \endverbatim
 
     the call to finishPartialBond() will take priority if you set the
     \c BondType in both calls.
 
   */
   Bond *createPartialBond(unsigned int beginAtomIdx,
                           Bond::BondType order = Bond::UNSPECIFIED);
   //! finishes a partially constructed bond
   /*!
     \return the final number of Bonds
 
     See the documentation for createPartialBond() for more details
   */
   unsigned int finishPartialBond(unsigned int endAtomIdx, int bondBookmark,
                                  Bond::BondType order = Bond::UNSPECIFIED);
 
   //! removes a bond from the molecule
   void removeBond(unsigned int beginAtomIdx, unsigned int endAtomIdx);
 
   //! replaces a particular Bond
   /*!
     \param idx          the index of the Bond to replace
     \param bond         the new bond, which will be copied.
     \param preserveProps if true preserve the original bond property data
     \param keepSGroups if true, keep Substance groups referencing the bond
 
   */
   void replaceBond(unsigned int idx, Bond *bond, bool preserveProps = false,
                    bool keepSGroups = true);
 
   //@}
 
     //! removes all atoms, bonds, properties, bookmarks, etc.
   void clear() {
     destroy();
     d_confs.clear();
     ROMol::initMol();  // make sure we have a "fresh" ready to go copy
     numBonds = 0;
   }
 
   void beginBatchEdit();
   void rollbackBatchEdit() {
     dp_delAtoms.reset();
     dp_delBonds.reset();
   }
   void commitBatchEdit();
 };
diff --git a/Code/GraphMol/RingInfo.h b/Code/GraphMol/RingInfo.h
index 4c4280c88..f036a4d35 100644
--- a/Code/GraphMol/RingInfo.h
+++ b/Code/GraphMol/RingInfo.h
@@ -1,22 +1,22 @@
 //
-//  Copyright (C) 2004-2019 Greg Landrum and Rational Discovery LLC
+//  Copyright (C) 2004-2022 Greg Landrum and other RDKit contributors
 //
 //   @@ All Rights Reserved @@
 //  This file is part of the RDKit.
 //  The contents are covered by the terms of the BSD license
 //  which is included in the file license.txt, found at the root
 //  of the RDKit source tree.
 //
 #include <RDGeneral/export.h>
-#ifndef _RD_RINGINFO_H
-#define _RD_RINGINFO_H
+#ifndef RD_RINGINFO_H
+#define RD_RINGINFO_H
 
 #include <map>
 #include <vector>
+#ifdef RDK_USE_URF
 #include <RDGeneral/BoostStartInclude.h>
 #include <boost/shared_ptr.hpp>
 #include <RDGeneral/BoostEndInclude.h>
-#ifdef RDK_USE_URF
 #include <RingDecomposerLib.h>
 #endif
 
@@ -27,259 +27,248 @@ namespace RDKit {
  */
 class RDKIT_GRAPHMOL_EXPORT RingInfo {
   friend class MolPickler;
 
  public:
   typedef std::vector<int> MemberType;
   typedef std::vector<MemberType> DataType;
   typedef std::vector<int> INT_VECT;
   typedef std::vector<INT_VECT> VECT_INT_VECT;
 
   RingInfo() {}
-  RingInfo(const RingInfo &other)
-      : df_init(other.df_init),
-        d_atomMembers(other.d_atomMembers),
-        d_bondMembers(other.d_bondMembers),
-        d_atomRings(other.d_atomRings),
-        d_bondRings(other.d_bondRings),
-        d_atomRingFamilies(other.d_atomRingFamilies),
-        d_bondRingFamilies(other.d_bondRingFamilies)
-#ifdef RDK_USE_URF
-        ,
-        dp_urfData(other.dp_urfData)
-#endif
-  {
-  }
-
+  RingInfo(const RingInfo &other) = default;
+  RingInfo &operator=(const RingInfo &other) = default;
+  RingInfo(RingInfo &&other) noexcept = default;
+  RingInfo &operator=(RingInfo &&other) noexcept = default;
   //! checks to see if we've been properly initialized
   bool isInitialized() const { return df_init; }
   //! does initialization
   void initialize();
 
   //! blows out all current data and de-initializes
   void reset();
 
   //! adds a ring to our data
   /*!
     \param atomIndices the integer indices of the atoms involved in the ring
     \param bondIndices the integer indices of the bonds involved in the ring,
       this must be the same size as \c atomIndices.
 
     \return the number of rings
 
     <b>Notes:</b>
       - the object must be initialized before calling this
 
   */
   unsigned int addRing(const INT_VECT &atomIndices,
                        const INT_VECT &bondIndices);
 
   //! \name Atom information
   //@{
 
   //! returns a vector with sizes of the rings that atom with index \c idx is
   //! in.
   /*!
     <b>Notes:</b>
       - the object must be initialized before calling this
   */
   INT_VECT atomRingSizes(unsigned int idx) const;
   //! returns whether or not the atom with index \c idx is in a \c size - ring.
   /*!
     <b>Notes:</b>
       - the object must be initialized before calling this
   */
   bool isAtomInRingOfSize(unsigned int idx, unsigned int size) const;
   //! returns the number of rings atom \c idx is involved in
   /*!
     <b>Notes:</b>
       - the object must be initialized before calling this
   */
   unsigned int numAtomRings(unsigned int idx) const;
   //! returns the size of the smallest ring atom \c idx is involved in
   /*!
     <b>Notes:</b>
       - the object must be initialized before calling this
   */
   unsigned int minAtomRingSize(unsigned int idx) const;
 
   //! returns our \c atom-rings vectors, i.e. a vector of int vectors
   //! reporting the atom indices which are part of each ring
   /*!
     <b>Notes:</b>
       - the object must be initialized before calling this
   */
   const VECT_INT_VECT &atomRings() const { return d_atomRings; }
 
   //! returns our \c atom-members vector for atom idx (i.e.,
   //! a vector of ints reporting the ring indices that
   //! atom idx is member of), or an empty vector if the atom is
   //! not in any ring.
   /*!
     <b>Notes:</b>
       - the object must be initialized before calling this
   */
   INT_VECT atomMembers(unsigned int idx) const;
 
   //! returns whether or not atoms with indices \c idx1 and \c idx2 belong to
   //! the same ring.
   /*!
     <b>Notes:</b>
       - the object must be initialized before calling this
   */
   bool areAtomsInSameRing(unsigned int idx1, unsigned int idx2) const {
     return areAtomsInSameRingOfSize(idx1, idx2, 0);
   }
 
   //! returns whether or not atoms with indices \c idx1 and \c idx2 belong to
   //! the same ring of size \c size.
   /*!
     <b>Notes:</b>
       - the object must be initialized before calling this
   */
   bool areAtomsInSameRingOfSize(unsigned int idx1, unsigned int idx2,
                                 unsigned int size) const;
 
   //@}
 
   //! \name Bond information
   //@{
 
   //! returns a vector with sizes of the rings that bond with index \c idx is
   //! in.
   /*!
     <b>Notes:</b>
       - the object must be initialized before calling this
   */
   INT_VECT bondRingSizes(unsigned int idx) const;
   //! returns whether or not the bond with index \c idx is in a \c size - ring.
   /*!
     <b>Notes:</b>
       - the object must be initialized before calling this
   */
   bool isBondInRingOfSize(unsigned int idx, unsigned int size) const;
   //! returns the number of rings bond \c idx is involved in
   /*!
     <b>Notes:</b>
       - the object must be initialized before calling this
   */
   unsigned int numBondRings(unsigned int idx) const;
   //! returns the size of the smallest ring bond \c idx is involved in
   /*!
     <b>Notes:</b>
       - the object must be initialized before calling this
   */
   unsigned int minBondRingSize(unsigned int idx) const;
 
   //! returns the total number of rings
   /*!
     <b>Notes:</b>
       - the object must be initialized before calling this
       - if the RDKit has been built with URF support, this returns the number
         of ring families.
   */
   unsigned int numRings() const;
 
   //! returns our \c bond-rings vectors, i.e. a vector of int vectors
   //! reporting the bond indices which are part of each ring
   /*!
     <b>Notes:</b>
       - the object must be initialized before calling this
   */
   const VECT_INT_VECT &bondRings() const { return d_bondRings; }
 
   //! returns our \c bond-members vector for bond idx (i.e.,
   //! a vector of ints reporting the ring indices that
   //! bond idx is member of), or an empty vector if the bond is
   //! not in any ring.
   /*!
     <b>Notes:</b>
       - the object must be initialized before calling this
   */
   INT_VECT bondMembers(unsigned int idx) const;
 
   //! returns whether or not bonds with indices \c idx1 and \c idx2 belong to
   //! the same ring.
   /*!
     <b>Notes:</b>
       - the object must be initialized before calling this
   */
   bool areBondsInSameRing(unsigned int idx1, unsigned int idx2) const {
     return areBondsInSameRingOfSize(idx1, idx2, 0);
   }
 
   //! returns whether or not bonds with indices \c idx1 and \c idx2 belong to
   //! the same ring of size \c size.
   /*!
     <b>Notes:</b>
       - the object must be initialized before calling this
   */
   bool areBondsInSameRingOfSize(unsigned int idx1, unsigned int idx2,
                                 unsigned int size) const;
 
 #ifdef RDK_USE_URF
   //! adds a ring family to our data
   /*!
     \param atomIndices the integer indices of the atoms involved in the
                        ring family
     \param bondIndices the integer indices of the bonds involved in the
                        ring family,
       this must be the same size as \c atomIndices.
 
     \return the number of ring families
 
     <b>Notes:</b>
       - the object must be initialized before calling this
 
   */
   unsigned int addRingFamily(const INT_VECT &atomIndices,
                              const INT_VECT &bondIndices);
   //! returns the total number of ring families
   /*!
     <b>Notes:</b>
       - the object must be initialized before calling this
   */
   unsigned int numRingFamilies() const;
 
   //! returns the total number of relevant cycles
   /*!
     <b>Notes:</b>
       - the object must be initialized before calling this
   */
   unsigned int numRelevantCycles() const;
 
   //! returns our atom ring family vectors
   /*!
     <b>Notes:</b>
       - the object must be initialized before calling this
   */
   const VECT_INT_VECT &atomRingFamilies() const { return d_atomRingFamilies; }
 
   //! returns our bond ring family vectors
   /*!
     <b>Notes:</b>
       - the object must be initialized before calling this
   */
   const VECT_INT_VECT &bondRingFamilies() const { return d_bondRingFamilies; }
 
   //! check if the ring families have been initialized
   bool areRingFamiliesInitialized() const { return dp_urfData != nullptr; }
 #endif
 
   //@}
 
  private:
   //! pre-allocates some memory to save time later
   void preallocate(unsigned int numAtoms, unsigned int numBonds);
   bool df_init{false};
   DataType d_atomMembers, d_bondMembers;
   VECT_INT_VECT d_atomRings, d_bondRings;
   VECT_INT_VECT d_atomRingFamilies, d_bondRingFamilies;
 
 #ifdef RDK_USE_URF
  public:
   boost::shared_ptr<RDL_data> dp_urfData;
 #endif
 };
 }  // namespace RDKit
 
 #endif
diff --git a/Code/GraphMol/StereoGroup.h b/Code/GraphMol/StereoGroup.h
index 6d5e2bc61..724f1c02f 100644
--- a/Code/GraphMol/StereoGroup.h
+++ b/Code/GraphMol/StereoGroup.h
@@ -1,21 +1,21 @@
 //
-//  Copyright (C) 2018 T5 Informatics GmbH
+//  Copyright (C) 2018-2021 Greg Landrum and other RDKit contributors
 //
 //   @@ All Rights Reserved @@
 //  This file is part of the RDKit.
 //  The contents are covered by the terms of the BSD license
 //  which is included in the file license.txt, found at the root
 //  of the RDKit source tree.
 //
 /*! \file StereoGroup.h
 
   \brief Defines the class StereoGroup which stores relationships between
   the absolute configurations of atoms within a structure.
 
 */
 
 #include <RDGeneral/export.h>
 #ifndef RD_StereoGroup_092018
 #define RD_StereoGroup_092018
 
 #include <vector>
@@ -40,22 +40,27 @@ enum class StereoGroupType {
  */
 class RDKIT_GRAPHMOL_EXPORT StereoGroup {
  private:
   StereoGroupType d_grouptype{StereoGroupType::STEREO_ABSOLUTE};
   std::vector<Atom*> d_atoms;
 
  public:
   StereoGroup() : d_atoms(0u) {}
   // Takes control of atoms if possible.
   StereoGroup(StereoGroupType grouptype, std::vector<Atom*>&& atoms);
   StereoGroup(StereoGroupType grouptype, const std::vector<Atom*>& atoms);
+  StereoGroup(const StereoGroup& other) = default;
+  StereoGroup& operator=(const StereoGroup& other) = default;
+  StereoGroup(StereoGroup&& other) = default;
+  StereoGroup& operator=(StereoGroup&& other) = default;
+
   StereoGroupType getGroupType() const;
   const std::vector<Atom*>& getAtoms() const;
   // Seems odd to have to define these, but otherwise the SWIG wrappers
   // won't build
   bool operator==(const StereoGroup& other) const {
     return (d_grouptype == other.d_grouptype) && (d_atoms == other.d_atoms);
   }
   bool operator!=(const StereoGroup& other) const {
     return (d_grouptype != other.d_grouptype) || (d_atoms != other.d_atoms);
   }
 };
diff --git a/Code/GraphMol/SubstanceGroup.h b/Code/GraphMol/SubstanceGroup.h
index 50c4091dc..b1b25c86d 100644
--- a/Code/GraphMol/SubstanceGroup.h
+++ b/Code/GraphMol/SubstanceGroup.h
@@ -53,162 +53,184 @@ class RDKIT_GRAPHMOL_EXPORT SubstanceGroupException
 class RDKIT_GRAPHMOL_EXPORT SubstanceGroup : public RDProps {
  public:
   //! Bond type (see V3000 spec)
   enum class BondType {
     XBOND,  // External/Crossing bond
     CBOND,  // Internal/Contained bond
   };
 
   typedef std::array<RDGeom::Point3D, 3> Bracket;
 
   //! Data structure for SAP lines (see V3000 spec)
   //! lvIdx may not be set; this signaled with value -1
   struct AttachPoint {
     unsigned int aIdx;
     int lvIdx;
     std::string id;
     bool operator==(const AttachPoint &other) const {
       return aIdx == other.aIdx && lvIdx == other.lvIdx && id == other.id;
     }
   };
 
   //! See specification for V3000 CSTATE
   //! vector may or not be considered, depending on TYPE
   struct CState {
     unsigned int bondIdx;
     RDGeom::Point3D vector;
     bool operator==(const CState &other) const {
       // note that we ignore coordinates for this
       return bondIdx == other.bondIdx;
     }
   };
 
 //! No default constructor
 #ifndef SWIG
   // Unfortunately, SWIG generated wrapper code uses temporary variables that
   // require a default ctor not be deleted.
   SubstanceGroup() = delete;
 #endif  // !SWIG
 
   //! Main Constructor. Ownership is only set on this side of the relationship:
   //! mol->addSubstanceGroup(sgroup) still needs to be called to get ownership
   //! on the other side.
   SubstanceGroup(ROMol *owning_mol, const std::string &type);
 
   SubstanceGroup(const SubstanceGroup &other) = default;
-  SubstanceGroup(SubstanceGroup &&other) = default;
-
   SubstanceGroup &operator=(const SubstanceGroup &other) = default;
-  SubstanceGroup &operator=(SubstanceGroup &&other) = default;
+
+  SubstanceGroup(SubstanceGroup &&other) noexcept : RDProps(std::move(other)) {
+    dp_mol = std::exchange(other.dp_mol, nullptr);
+    d_atoms = std::move(other.d_atoms);
+    d_patoms = std::move(other.d_patoms);
+    d_bonds = std::move(other.d_bonds);
+    d_brackets = std::move(other.d_brackets);
+    d_cstates = std::move(other.d_cstates);
+    d_saps = std::move(other.d_saps);
+  }
+
+  SubstanceGroup &operator=(SubstanceGroup &&other) noexcept {
+    if (this == &other) {
+      return *this;
+    }
+    RDProps::operator=(std::move(other));
+    dp_mol = std::exchange(other.dp_mol, nullptr);
+    d_atoms = std::move(other.d_atoms);
+    d_patoms = std::move(other.d_patoms);
+    d_bonds = std::move(other.d_bonds);
+    d_brackets = std::move(other.d_brackets);
+    d_cstates = std::move(other.d_cstates);
+    d_saps = std::move(other.d_saps);
+    return *this;
+  }
 
   //! Destructor
   ~SubstanceGroup() = default;
 
   //! returns whether or not this belongs to a molecule
   bool hasOwningMol() const { return dp_mol != nullptr; }
 
   //! Get the molecule that owns this instance
   ROMol &getOwningMol() const {
     PRECONDITION(dp_mol, "no owner");
     return *dp_mol;
   }
 
   //! returns whether or not this group is valid; invalid groups must be
   //! ignored.
   bool getIsValid() const { return d_isValid; }
 
   //! set whether or not this group is valid; invalid groups must be ignored.
   void setIsValid(bool isValid) { d_isValid = isValid; }
 
   //! get the index of this sgroup in dp_mol's sgroups vector
   //! (do not mistake this by the ID!)
   unsigned int getIndexInMol() const;
 
   /* Atom and Bond methods */
   void addAtomWithIdx(unsigned int idx);
   void addParentAtomWithIdx(unsigned int idx);
   void addBondWithIdx(unsigned int idx);
   void addAtomWithBookmark(int mark);
   void addParentAtomWithBookmark(int mark);
   void addBondWithBookmark(int mark);
 
   void addBracket(const Bracket &bracket);
   void addCState(unsigned int bondIdx, const RDGeom::Point3D &vector);
   void addAttachPoint(unsigned int aIdx, int lvIdx, const std::string &idStr);
 
   BondType getBondType(unsigned int bondIdx) const;
 
   const std::vector<unsigned int> &getAtoms() const { return d_atoms; }
   const std::vector<unsigned int> &getParentAtoms() const { return d_patoms; }
   const std::vector<unsigned int> &getBonds() const { return d_bonds; }
 
   void setAtoms(std::vector<unsigned int> atoms) { d_atoms = std::move(atoms); }
   void setParentAtoms(std::vector<unsigned int> patoms) {
     d_patoms = std::move(patoms);
   }
   void setBonds(std::vector<unsigned int> bonds) { d_bonds = std::move(bonds); }
 
   const std::vector<Bracket> &getBrackets() const { return d_brackets; }
   const std::vector<CState> &getCStates() const { return d_cstates; }
   const std::vector<AttachPoint> &getAttachPoints() const { return d_saps; }
 
   std::vector<Bracket> &getBrackets() { return d_brackets; }
   std::vector<CState> &getCStates() { return d_cstates; }
   std::vector<AttachPoint> &getAttachPoints() { return d_saps; }
 
   void clearBrackets() { d_brackets.clear(); }
   void clearCStates() { d_cstates.clear(); }
   void clearAttachPoints() { d_saps.clear(); }
 
   //! adjusts our atom IDs to reflect that an atom has been removed from the
   //! parent molecule
   //!   decrements all atom IDs that are higher than \c atomIdx
   //!   raises a \c SubstanceGroupException if \c atomIdx is actually part of
   //!   this substance group
   //! \returns whether or not anything was changed
   bool adjustToRemovedAtom(unsigned int atomIdx);
 
   //! \returns whether or not anything the specified atom is part of the
   //! definition of this substance group
   bool includesAtom(unsigned int atomIdx) const;
 
   //! adjusts our bond IDs to reflect that a bond has been removed from the
   //! parent molecule
   //!   decrements all bond IDs that are higher than \c bondIdx
   //!   raises a \c SubstanceGroupException if \c bondIdx is actually part of
   //!   this substance group
   //! \returns whether or not anything was changed
   bool adjustToRemovedBond(unsigned int bondIdx);
 
   //! \returns whether or not anything the specified bond is part of the
   //! definition of this substance group
   bool includesBond(unsigned int bondIdx) const;
 
   //! Set owning molecule
   //! This only updates atoms and bonds; parent sgroup has to be updated
   //! independently, since parent might not exist at the time this is
   //! called.
   void setOwningMol(ROMol *mol);
 
   bool operator==(const SubstanceGroup &other) const {
     // we ignore brackets and cstates, which involve coordinates
     return dp_mol == other.dp_mol && d_atoms == other.d_atoms &&
            d_patoms == other.d_patoms && d_bonds == other.d_bonds &&
            d_saps == other.d_saps;
   }
 
  private:
   ROMol *dp_mol = nullptr;  // owning molecule
 
   bool d_isValid = true;
 
   std::vector<unsigned int> d_atoms;
   std::vector<unsigned int> d_patoms;
   std::vector<unsigned int> d_bonds;
 
   std::vector<Bracket> d_brackets;
   std::vector<CState> d_cstates;
   std::vector<AttachPoint> d_saps;
-};
+};  // namespace RDKit
 
 namespace SubstanceGroupChecks {
 
diff --git a/Code/GraphMol/catch_graphmol.cpp b/Code/GraphMol/catch_graphmol.cpp
index 485e85940..ca3a2fdeb 100644
--- a/Code/GraphMol/catch_graphmol.cpp
+++ b/Code/GraphMol/catch_graphmol.cpp
@@ -2479,16 +2479,141 @@ TEST_CASE("isAromaticAtom") {
 TEST_CASE(
     "Github #4785: aromatic bonds no longer set aromatic flags on atoms") {
   SECTION("basics1") {
     auto m = "C1:C:C:C:1"_smiles;
     REQUIRE(m);
     CHECK(MolToSmiles(*m) == "C1=CC=C1");
   }
   SECTION("basics2") {
     auto m = "C1:C:C:C:C:C:1"_smiles;
     REQUIRE(m);
     CHECK(MolToSmiles(*m) == "c1ccccc1");
   }
   SECTION("can still get kekulization errors") {
     CHECK_THROWS_AS(SmilesToMol("C1:C:C:C:C:1"), KekulizeException);
   }
-}
\ No newline at end of file
+}
+
+namespace {
+void check_dest(RWMol *m1, const ROMol &m2) {
+  CHECK(m2.getNumAtoms() == 8);
+  CHECK(m2.getNumBonds() == 7);
+  for (const auto atom : m2.atoms()) {
+    CHECK(&atom->getOwningMol() == &m2);
+    CHECK(&atom->getOwningMol() != m1);
+  }
+  for (const auto bond : m2.bonds()) {
+    CHECK(&bond->getOwningMol() == &m2);
+    CHECK(&bond->getOwningMol() != m1);
+  }
+  CHECK(m2.getStereoGroups().size() == 2);
+  CHECK(m2.getStereoGroups()[0].getAtoms().size() == 2);
+  CHECK(m2.getStereoGroups()[0].getAtoms()[0]->getIdx() == 1);
+  CHECK(m2.getStereoGroups()[0].getAtoms()[1]->getIdx() == 5);
+  CHECK(m2.getStereoGroups()[1].getAtoms().size() == 1);
+  CHECK(m2.getStereoGroups()[1].getAtoms()[0]->getIdx() == 3);
+
+  const auto &sgs = getSubstanceGroups(m2);
+  CHECK(sgs.size() == 1);
+  CHECK(sgs[0].getAtoms().size() == 1);
+  CHECK(sgs[0].getAtoms()[0] == 4);
+
+  // check the state of m1:
+  CHECK(m1->getNumAtoms() == 0);
+  CHECK(m1->getNumBonds() == 0);
+  CHECK(m1->getPropList().empty());
+  CHECK(m1->getDict().getData().empty());
+  CHECK(m1->getStereoGroups().empty());
+  CHECK(getSubstanceGroups(*m1).empty());
+  CHECK(m1->getRingInfo() == nullptr);
+
+  // make sure we can still do something with m1:
+  *m1 = m2;
+  CHECK(!m1->getDict().getData().empty());
+  CHECK(m1->getNumAtoms() == 8);
+  CHECK(m1->getNumBonds() == 7);
+  CHECK(m1->getRingInfo() != nullptr);
+  CHECK(m1->getRingInfo()->isInitialized() ==
+        m2.getRingInfo()->isInitialized());
+}
+}  // namespace
+TEST_CASE("moves") {
+  auto m1 =
+      "C[C@H](O)C(F)[C@H](C)O |o2:1,5,&1:3,r,@:3,SgD:4:atom_data:foo::::|"_smiles;
+  REQUIRE(m1);
+  m1->setProp("foo", 1u);
+  SECTION("molecule move") {
+    ROMol m2 = std::move(*m1);
+    check_dest(m1.get(), m2);
+  }
+  SECTION("molecule move-assign") {
+    ROMol m2;
+    m2 = std::move(*m1);
+    check_dest(m1.get(), m2);
+  }
+}
+
+TEST_CASE("query moves") {
+  auto m1 =
+      "C[C@H](O)C(F)[C@H](C)O |o2:1,5,&1:3,r,@:3,SgD:4:atom_data:foo::::|"_smarts;
+  REQUIRE(m1);
+  m1->setProp("foo", 1u);
+  SECTION("molecule move") {
+    ROMol m2 = std::move(*m1);
+    check_dest(m1.get(), m2);
+  }
+  SECTION("molecule move-assign") {
+    ROMol m2;
+    m2 = std::move(*m1);
+    check_dest(m1.get(), m2);
+  }
+}
+
+TEST_CASE("moves with conformer") {
+  auto m1 = R"CTAB(
+  Mrv2108 01192209042D          
+
+  0  0  0     0  0            999 V3000
+M  V30 BEGIN CTAB
+M  V30 COUNTS 8 7 1 0 0
+M  V30 BEGIN ATOM
+M  V30 1 C 2.31 4.001 0 0
+M  V30 2 C 1.54 2.6674 0 0 CFG=2
+M  V30 3 O -0 2.6674 0 0
+M  V30 4 C 2.31 1.3337 0 0 CFG=1
+M  V30 5 F 3.85 1.3337 0 0
+M  V30 6 C 1.54 0 0 0 CFG=2
+M  V30 7 C 2.31 -1.3337 0 0
+M  V30 8 O 0 0 0 0
+M  V30 END ATOM
+M  V30 BEGIN BOND
+M  V30 1 1 2 1
+M  V30 2 1 2 3 CFG=1
+M  V30 3 1 4 2
+M  V30 4 1 4 5 CFG=1
+M  V30 5 1 4 6
+M  V30 6 1 6 7
+M  V30 7 1 6 8 CFG=3
+M  V30 END BOND
+M  V30 BEGIN SGROUP
+M  V30 1 DAT 0 ATOMS=(1 5) FIELDNAME=atom_data -
+M  V30 FIELDDISP="    4.6200    0.5637    DA    ALL  0       0" FIELDDATA=foo
+M  V30 END SGROUP
+M  V30 BEGIN COLLECTION
+M  V30 MDLV30/STEREL2 ATOMS=(2 2 6)
+M  V30 MDLV30/STERAC1 ATOMS=(1 4)
+M  V30 END COLLECTION
+M  V30 END CTAB
+M  END
+)CTAB"_ctab;
+  REQUIRE(m1);
+  m1->setProp("foo", 1u);
+  SECTION("molecule move") {
+    ROMol m2 = std::move(*m1);
+    check_dest(m1.get(), m2);
+  }
+  SECTION("molecule move-assign") {
+    ROMol m2;
+    m2 = std::move(*m1);
+    check_dest(m1.get(), m2);
+  }
+}
diff --git a/Code/RDGeneral/CMakeLists.txt b/Code/RDGeneral/CMakeLists.txt
index 054e82c8b..82ef14df5 100644
--- a/Code/RDGeneral/CMakeLists.txt
+++ b/Code/RDGeneral/CMakeLists.txt
@@ -79,3 +79,5 @@ if(RDK_BUILD_THREADSAFE_SSS)
 rdkit_test(testConcurrentQueue testConcurrentQueue.cpp LINK_LIBRARIES RDGeneral)
 endif(RDK_BUILD_THREADSAFE_SSS)
 
+rdkit_catch_test(dictTestsCatch catch_dict.cpp catch_main.cpp
+           LINK_LIBRARIES RDGeneral )
\ No newline at end of file
diff --git a/Code/RDGeneral/Dict.h b/Code/RDGeneral/Dict.h
index ed8d466fc..094d29baa 100644
--- a/Code/RDGeneral/Dict.h
+++ b/Code/RDGeneral/Dict.h
@@ -1,26 +1,26 @@
 //
-// Copyright (C) 2003-2020 Greg Landrum and Rational Discovery LLC
+// Copyright (C) 2003-2021 Greg Landrum and other RDKit contributors
 //
 //  @@ All Rights Reserved @@
 //  This file is part of the RDKit.
 //  The contents are covered by the terms of the BSD license
 //  which is included in the file license.txt, found at the root
 //  of the RDKit source tree.
 //
 /*! \file Dict.h
 
   \brief Defines the Dict class
 
 */
 #include <RDGeneral/export.h>
 #ifndef RD_DICT_H_012020
 #define RD_DICT_H_012020
 
 #include <map>
 #include <string>
 #include <vector>
 #include "RDValue.h"
 #include "Exceptions.h"
 #include <RDGeneral/BoostStartInclude.h>
 #include <boost/lexical_cast.hpp>
 #include <RDGeneral/BoostEndInclude.h>
@@ -31,287 +31,306 @@ typedef std::vector<std::string> STR_VECT;
 //! \brief The \c Dict class can be used to store objects of arbitrary
 //!        type keyed by \c strings.
 //!
 //!  The actual storage is done using \c RDValue objects.
 //!
 class RDKIT_RDGENERAL_EXPORT Dict {
  public:
   struct Pair {
     std::string key;
     RDValue val;
 
     Pair() : key(), val() {}
     explicit Pair(std::string s) : key(std::move(s)), val() {}
     Pair(std::string s, const RDValue &v) : key(std::move(s)), val(v) {}
   };
 
   typedef std::vector<Pair> DataType;
 
   Dict() {}
 
   Dict(const Dict &other) : _data(other._data) {
     _hasNonPodData = other._hasNonPodData;
     if (other._hasNonPodData) {  // other has non pod data, need to copy
       std::vector<Pair> data(other._data.size());
       _data.swap(data);
       for (size_t i = 0; i < _data.size(); ++i) {
         _data[i].key = other._data[i].key;
         copy_rdvalue(_data[i].val, other._data[i].val);
       }
     }
   }
 
+  Dict(Dict &&other) noexcept = default;
+
   ~Dict() {
     reset();  // to clear pointers if necessary
   }
 
   void update(const Dict &other, bool preserveExisting = false) {
     if (!preserveExisting) {
       *this = other;
     } else {
       if (other._hasNonPodData) _hasNonPodData = true;
       for (size_t i = 0; i < other._data.size(); ++i) {
         const Pair &pair = other._data[i];
         Pair *target = nullptr;
         for (size_t i = 0; i < _data.size(); ++i) {
           if (_data[i].key == pair.key) {
             target = &_data[i];
             break;
           }
         }
 
         if (!target) {
           // need to create blank entry and copy
           _data.push_back(Pair(pair.key));
           copy_rdvalue(_data.back().val, pair.val);
         } else {
           // just copy
           copy_rdvalue(target->val, pair.val);
         }
       }
     }
   }
 
   Dict &operator=(const Dict &other) {
-    if (this == &other) return *this;
-    if (_hasNonPodData) reset();
+    if (this == &other) {
+      return *this;
+    }
+    if (_hasNonPodData) {
+      reset();
+    }
 
     if (other._hasNonPodData) {
       std::vector<Pair> data(other._data.size());
       _data.swap(data);
       for (size_t i = 0; i < _data.size(); ++i) {
         _data[i].key = other._data[i].key;
         copy_rdvalue(_data[i].val, other._data[i].val);
       }
     } else {
       _data = other._data;
     }
     _hasNonPodData = other._hasNonPodData;
     return *this;
   }
 
+  Dict &operator=(Dict &&other) noexcept {
+    if (this == &other) {
+      return *this;
+    }
+    if (_hasNonPodData) {
+      reset();
+    }
+    _hasNonPodData = other._hasNonPodData;
+    other._hasNonPodData = false;
+    _data = std::move(other._data);
+    return *this;
+  }
+
   //----------------------------------------------------------
   //! \brief Access to the underlying non-POD containment flag
   //! This is meant to be used only in bulk updates of _data.
   bool &getNonPODStatus() { return _hasNonPodData; }
 
   //----------------------------------------------------------
   //! \brief Access to the underlying data.
   const DataType &getData() const { return _data; }
   DataType &getData() { return _data; }
 
   //----------------------------------------------------------
 
   //! \brief Returns whether or not the dictionary contains a particular
   //!        key.
   bool hasVal(const std::string &what) const {
     for (const auto &data : _data) {
       if (data.key == what) return true;
     }
     return false;
   }
 
   //----------------------------------------------------------
   //! Returns the set of keys in the dictionary
   /*!
      \return  a \c STR_VECT
   */
   STR_VECT keys() const {
     STR_VECT res;
     res.reserve(_data.size());
     for (const auto &item : _data) {
       res.push_back(item.key);
     }
     return res;
   }
 
   //----------------------------------------------------------
   //! \brief Gets the value associated with a particular key
   /*!
      \param what  the key to lookup
      \param res   a reference used to return the result
 
      <B>Notes:</b>
       - If \c res is a \c std::string, every effort will be made
         to convert the specified element to a string using the
         \c boost::lexical_cast machinery.
       - If the dictionary does not contain the key \c what,
         a KeyErrorException will be thrown.
   */
   template <typename T>
   void getVal(const std::string &what, T &res) const {
     res = getVal<T>(what);
   }
 
   //! \overload
   template <typename T>
   T getVal(const std::string &what) const {
     for (auto &data : _data) {
       if (data.key == what) {
         return from_rdvalue<T>(data.val);
       }
     }
     throw KeyErrorException(what);
   }
 
   //! \overload
   void getVal(const std::string &what, std::string &res) const {
     for (const auto &i : _data) {
       if (i.key == what) {
         rdvalue_tostring(i.val, res);
         return;
       }
     }
     throw KeyErrorException(what);
   }
 
   //----------------------------------------------------------
   //! \brief Potentially gets the value associated with a particular key
   //!        returns true on success/false on failure.
   /*!
      \param what  the key to lookup
      \param res   a reference used to return the result
 
      <B>Notes:</b>
       - If \c res is a \c std::string, every effort will be made
         to convert the specified element to a string using the
         \c boost::lexical_cast machinery.
       - If the dictionary does not contain the key \c what,
         a KeyErrorException will be thrown.
   */
   template <typename T>
   bool getValIfPresent(const std::string &what, T &res) const {
     for (const auto &data : _data) {
       if (data.key == what) {
         res = from_rdvalue<T>(data.val);
         return true;
       }
     }
     return false;
   }
 
   //! \overload
   bool getValIfPresent(const std::string &what, std::string &res) const {
     for (const auto &i : _data) {
       if (i.key == what) {
         rdvalue_tostring(i.val, res);
         return true;
       }
     }
     return false;
   }
 
   //----------------------------------------------------------
   //! \brief Sets the value associated with a key
   /*!
 
      \param what the key to set
      \param val  the value to store
 
      <b>Notes:</b>
         - If \c val is a <tt>const char *</tt>, it will be converted
            to a \c std::string for storage.
         - If the dictionary already contains the key \c what,
           the value will be replaced.
   */
   template <typename T>
   void setVal(const std::string &what, T &val) {
     _hasNonPodData = true;
     for (auto &&data : _data) {
       if (data.key == what) {
         RDValue::cleanup_rdvalue(data.val);
         data.val = val;
         return;
       }
     }
     _data.push_back(Pair(what, val));
   }
 
   template <typename T>
   void setPODVal(const std::string &what, T val) {
     // don't change the hasNonPodData status
     for (auto &&data : _data) {
       if (data.key == what) {
         RDValue::cleanup_rdvalue(data.val);
         data.val = val;
         return;
       }
     }
     _data.push_back(Pair(what, val));
   }
 
   void setVal(const std::string &what, bool val) { setPODVal(what, val); }
 
   void setVal(const std::string &what, double val) { setPODVal(what, val); }
 
   void setVal(const std::string &what, float val) { setPODVal(what, val); }
 
   void setVal(const std::string &what, int val) { setPODVal(what, val); }
 
   void setVal(const std::string &what, unsigned int val) {
     setPODVal(what, val);
   }
 
   //! \overload
   void setVal(const std::string &what, const char *val) {
     std::string h(val);
     setVal(what, h);
   }
 
   //----------------------------------------------------------
   //! \brief Clears the value associated with a particular key,
   //!     removing the key from the dictionary.
   /*!
 
      \param what the key to clear
 
   */
   void clearVal(const std::string &what) {
     for (DataType::iterator it = _data.begin(); it < _data.end(); ++it) {
       if (it->key == what) {
         if (_hasNonPodData) {
           RDValue::cleanup_rdvalue(it->val);
         }
         _data.erase(it);
         return;
       }
     }
   }
 
   //----------------------------------------------------------
   //! \brief Clears all keys (and values) from the dictionary.
   //!
   void reset() {
     if (_hasNonPodData) {
       for (auto &&data : _data) {
         RDValue::cleanup_rdvalue(data.val);
       }
     }
     DataType data;
     _data.swap(data);
   }
 
  private:
   DataType _data{};            //!< the actual dictionary
   bool _hasNonPodData{false};  // if true, need a deep copy
                                //  (copy_rdvalue)
 };
diff --git a/Code/RDGeneral/RDProps.h b/Code/RDGeneral/RDProps.h
index 0e6488718..a240e2525 100644
--- a/Code/RDGeneral/RDProps.h
+++ b/Code/RDGeneral/RDProps.h
@@ -14,154 +14,159 @@ namespace RDKit {
 class RDProps {
  protected:
   mutable Dict d_props;
   // It is a quirk of history that this is mutable
   //  as the RDKit allows properties to be set
   //  on const objects.
 
  public:
   RDProps() : d_props() {}
   RDProps(const RDProps &rhs) : d_props(rhs.d_props) {}
   RDProps &operator=(const RDProps &rhs) {
-    if (this == &rhs) return *this;
+    if (this == &rhs) {
+      return *this;
+    }
     d_props = rhs.d_props;
     return *this;
   }
+  RDProps(RDProps &&o) noexcept = default;
+  RDProps &operator=(RDProps &&rhs) noexcept = default;
+
   void clear() { d_props.reset(); }
   //! gets the underlying Dictionary
   const Dict &getDict() const { return d_props; }
   Dict &getDict() { return d_props; }
 
   // ------------------------------------
   //  Local Property Dict functionality
   //  all setProp functions are const because they
   //     are not meant to change the atom chemically
   // ------------------------------------
   //! returns a list with the names of our \c properties
   STR_VECT getPropList(bool includePrivate = true,
                        bool includeComputed = true) const {
     const STR_VECT &tmp = d_props.keys();
     STR_VECT res, computed;
     if (!includeComputed &&
         getPropIfPresent(RDKit::detail::computedPropName, computed)) {
       computed.push_back(RDKit::detail::computedPropName);
     }
 
     auto pos = tmp.begin();
     while (pos != tmp.end()) {
       if ((includePrivate || (*pos)[0] != '_') &&
           std::find(computed.begin(), computed.end(), *pos) == computed.end()) {
         res.push_back(*pos);
       }
       pos++;
     }
     return res;
   }
 
   //! sets a \c property value
   /*!
     \param key the name under which the \c property should be stored.
     If a \c property is already stored under this name, it will be
     replaced.
     \param val the value to be stored
     \param computed (optional) allows the \c property to be flagged
     \c computed.
   */
 
   //! \overload
   template <typename T>
   void setProp(const std::string &key, T val, bool computed = false) const {
     if (computed) {
       STR_VECT compLst;
       getPropIfPresent(RDKit::detail::computedPropName, compLst);
       if (std::find(compLst.begin(), compLst.end(), key) == compLst.end()) {
         compLst.push_back(key);
         d_props.setVal(RDKit::detail::computedPropName, compLst);
       }
     }
     d_props.setVal(key, val);
   }
 
   //! allows retrieval of a particular property value
   /*!
 
     \param key the name under which the \c property should be stored.
     If a \c property is already stored under this name, it will be
     replaced.
     \param res a reference to the storage location for the value.
 
     <b>Notes:</b>
     - if no \c property with name \c key exists, a KeyErrorException will be
     thrown.
     - the \c boost::lexical_cast machinery is used to attempt type
     conversions.
     If this fails, a \c boost::bad_lexical_cast exception will be thrown.
 
   */
   //! \overload
   template <typename T>
   void getProp(const std::string &key, T &res) const {
     d_props.getVal(key, res);
   }
 
   //! \overload
   template <typename T>
   T getProp(const std::string &key) const {
     return d_props.getVal<T>(key);
   }
 
   //! returns whether or not we have a \c property with name \c key
   //!  and assigns the value if we do
   //! \overload
   template <typename T>
   bool getPropIfPresent(const std::string &key, T &res) const {
     return d_props.getValIfPresent(key, res);
   }
 
   //! \overload
   bool hasProp(const std::string &key) const { return d_props.hasVal(key); }
 
   //! clears the value of a \c property
   /*!
     <b>Notes:</b>
     - if no \c property with name \c key exists, a KeyErrorException
     will be thrown.
     - if the \c property is marked as \c computed, it will also be removed
     from our list of \c computedProperties
   */
   //! \overload
   void clearProp(const std::string &key) const {
     STR_VECT compLst;
     if (getPropIfPresent(RDKit::detail::computedPropName, compLst)) {
       auto svi = std::find(compLst.begin(), compLst.end(), key);
       if (svi != compLst.end()) {
         compLst.erase(svi);
         d_props.setVal(RDKit::detail::computedPropName, compLst);
       }
     }
     d_props.clearVal(key);
   }
 
   //! clears all of our \c computed \c properties
   void clearComputedProps() const {
     STR_VECT compLst;
     if (getPropIfPresent(RDKit::detail::computedPropName, compLst)) {
       for (const auto &sv : compLst) {
         d_props.clearVal(sv);
       }
       compLst.clear();
       d_props.setVal(RDKit::detail::computedPropName, compLst);
     }
   }
 
   //! update the properties from another
   /*
     \param source    Source to update the properties from
-    \param preserve  Existing If true keep existing data, else override from the
-    source
+    \param preserve  Existing If true keep existing data, else override from
+    the source
   */
   void updateProps(const RDProps &source, bool preserveExisting = false) {
     d_props.update(source.getDict(), preserveExisting);
   }
 };
 }  // namespace RDKit
 #endif
diff --git a/Code/RDGeneral/catch_dict.cpp b/Code/RDGeneral/catch_dict.cpp
new file mode 100644
index 000000000..bcecc6fc5
--- /dev/null
+++ b/Code/RDGeneral/catch_dict.cpp
@@ -0,0 +1,72 @@
+//
+//  Copyright (C) 2021 Greg Landrum
+//
+//   @@ All Rights Reserved @@
+//  This file is part of the RDKit.
+//  The contents are covered by the terms of the BSD license
+//  which is included in the file license.txt, found at the root
+//  of the RDKit source tree.
+//
+#include <string>
+#include "catch.hpp"
+#include "Dict.h"
+#include "RDProps.h"
+using namespace std::string_literals;
+
+TEST_CASE("Dict move semantics") {
+  RDKit::Dict d1;
+  d1.setVal("foo"s, 1);
+  d1.setVal("bar"s, "yep");
+  SECTION("move constructor") {
+    CHECK(d1.hasVal("foo"s));
+    CHECK(d1.hasVal("bar"s));
+    CHECK(d1.getVal<std::string>("bar"s) == "yep"s);
+    auto d2 = std::move(d1);
+    CHECK(d2.hasVal("foo"s));
+    CHECK(d2.hasVal("bar"s));
+    CHECK(d2.getVal<std::string>("bar"s) == "yep"s);
+    CHECK(!d1.hasVal("foo"s));
+    CHECK(!d1.hasVal("bar"s));
+  }
+  SECTION("move assignment") {
+    CHECK(d1.hasVal("foo"s));
+    CHECK(d1.hasVal("bar"s));
+    CHECK(d1.getVal<std::string>("bar"s) == "yep"s);
+    RDKit::Dict d2;
+    d2 = std::move(d1);
+    CHECK(d2.hasVal("foo"s));
+    CHECK(d2.hasVal("bar"s));
+    CHECK(d2.getVal<std::string>("bar"s) == "yep"s);
+    CHECK(!d1.hasVal("foo"s));
+    CHECK(!d1.hasVal("bar"s));
+  }
+}
+
+TEST_CASE("RDProps move semantics") {
+  RDKit::RDProps d1;
+  d1.setProp("foo"s, 1);
+  d1.setProp("bar"s, "yep");
+  SECTION("move constructor") {
+    CHECK(d1.hasProp("foo"s));
+    CHECK(d1.hasProp("bar"s));
+    CHECK(d1.getProp<std::string>("bar"s) == "yep"s);
+    auto d2 = std::move(d1);
+    CHECK(d2.hasProp("foo"s));
+    CHECK(d2.hasProp("bar"s));
+    CHECK(d2.getProp<std::string>("bar"s) == "yep"s);
+    CHECK(!d1.hasProp("foo"s));
+    CHECK(!d1.hasProp("bar"s));
+  }
+  SECTION("move assignment") {
+    CHECK(d1.hasProp("foo"s));
+    CHECK(d1.hasProp("bar"s));
+    CHECK(d1.getProp<std::string>("bar"s) == "yep"s);
+    RDKit::RDProps d2;
+    d2 = std::move(d1);
+    CHECK(d2.hasProp("foo"s));
+    CHECK(d2.hasProp("bar"s));
+    CHECK(d2.getProp<std::string>("bar"s) == "yep"s);
+    CHECK(!d1.hasProp("foo"s));
+    CHECK(!d1.hasProp("bar"s));
+  }
+}
\ No newline at end of file
diff --git a/Code/RDGeneral/catch_main.cpp b/Code/RDGeneral/catch_main.cpp
new file mode 100644
index 000000000..e94b210fe
--- /dev/null
+++ b/Code/RDGeneral/catch_main.cpp
@@ -0,0 +1,20 @@
+//
+//  Copyright (C) 2021 Greg Landrum
+//   @@ All Rights Reserved @@
+//  This file is part of the RDKit.
+//  The contents are covered by the terms of the BSD license
+//  which is included in the file license.txt, found at the root
+//  of the RDKit source tree.
+//
+
+#define CATCH_CONFIG_RUNNER
+#include "catch.hpp"
+#include <RDGeneral/RDLog.h>
+
+int main(int argc, char* argv[]) {
+  RDLog::InitLogs();
+
+  int result = Catch::Session().run(argc, argv);
+
+  return result;
+}
\ No newline at end of file
