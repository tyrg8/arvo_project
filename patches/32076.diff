commit 48123a7d2e7409ecd0e74f64a326fa7f2af0627d
Author: Francesc Alted <faltet@gmail.com>
Date:   Tue Apr 13 14:52:27 2021 +0200

    Another sanity check for the number of chunks in frame

diff --git a/blosc/frame.c b/blosc/frame.c
index 5a395a5e..5c246771 100644
--- a/blosc/frame.c
+++ b/blosc/frame.c
@@ -958,83 +958,92 @@ int64_t frame_from_schunk(blosc2_schunk *schunk, blosc2_frame_s *frame) {
 
 
 // Get the compressed data offsets
-uint8_t* get_coffsets(blosc2_frame_s *frame, int32_t header_len, int64_t cbytes, int32_t *off_cbytes) {
+uint8_t* get_coffsets(blosc2_frame_s *frame, int32_t header_len, int64_t cbytes,
+                      int32_t nchunks, int32_t *off_cbytes) {
   int32_t chunk_cbytes;
   int rc;
 
   if (frame->coffsets != NULL) {
     if (off_cbytes != NULL) {
       rc = blosc2_cbuffer_sizes(frame->coffsets, NULL, &chunk_cbytes, NULL);
       if (rc < 0) {
         return NULL;
       }
       *off_cbytes = (int32_t)chunk_cbytes;
     }
     return frame->coffsets;
   }
   if (frame->cframe != NULL) {
     int64_t off_pos = header_len;
     if (cbytes < INT64_MAX - header_len) {
       off_pos += cbytes;
     }
     // Check that there is enough room to read Blosc header
     if (off_pos < 0 || off_pos > INT64_MAX - BLOSC_EXTENDED_HEADER_LENGTH ||
         off_pos + BLOSC_EXTENDED_HEADER_LENGTH > frame->len) {
       BLOSC_TRACE_ERROR("Cannot read the offsets outside of frame boundary.");
       return NULL;
     }
     // For in-memory frames, the coffset is just one pointer away
     uint8_t* off_start = frame->cframe + off_pos;
     if (off_cbytes != NULL) {
-      rc = blosc2_cbuffer_sizes(off_start, NULL, &chunk_cbytes, NULL);
+      int32_t chunk_nbytes;
+      int32_t chunk_blocksize;
+      rc = blosc2_cbuffer_sizes(off_start, &chunk_nbytes, &chunk_cbytes, &chunk_blocksize);
       if (rc < 0) {
         return NULL;
       }
       *off_cbytes = (int32_t)chunk_cbytes;
       if (*off_cbytes < 0 || off_pos + *off_cbytes > frame->len) {
         BLOSC_TRACE_ERROR("Cannot read the cbytes outside of frame boundary.");
         return NULL;
       }
+      if (chunk_nbytes != nchunks * sizeof(int64_t)) {
+        BLOSC_TRACE_ERROR("The number of chunks in offset idx "
+                          "does not match the ones in the header frame.");
+        return NULL;
+      }
+
     }
     return off_start;
   }
 
   int64_t trailer_offset = get_trailer_offset(frame, header_len, true);
 
   if (trailer_offset < BLOSC_EXTENDED_HEADER_LENGTH || trailer_offset + FRAME_TRAILER_MINLEN > frame->len) {
     BLOSC_TRACE_ERROR("Cannot read the trailer out of the frame.");
     return NULL;
   }
 
   int32_t coffsets_cbytes;
   if (frame->sframe) {
     coffsets_cbytes = (int32_t)(trailer_offset - (header_len + 0));
   }
   else {
     coffsets_cbytes = (int32_t)(trailer_offset - (header_len + cbytes));
   }
 
   if (off_cbytes != NULL) {
     *off_cbytes = coffsets_cbytes;
   }
 
   FILE* fp = NULL;
   uint8_t* coffsets = malloc((size_t)coffsets_cbytes);
   if (frame->sframe) {
     fp = sframe_open_index(frame->urlpath, "rb");
     fseek(fp, header_len + 0, SEEK_SET);
   }
   else {
     fp = fopen(frame->urlpath, "rb");
     fseek(fp, header_len + cbytes, SEEK_SET);
   }
   size_t rbytes = fread(coffsets, 1, (size_t)coffsets_cbytes, fp);
   fclose(fp);
   if (rbytes != (size_t)coffsets_cbytes) {
     BLOSC_TRACE_ERROR("Cannot read the offsets out of the frame.");
     free(coffsets);
     return NULL;
   }
   frame->coffsets = coffsets;
   return coffsets;
 }
@@ -1491,195 +1500,195 @@ blosc2_storage* get_new_storage(const blosc2_storage* storage, const blosc2_cpar
 /* Get a super-chunk out of a frame */
 blosc2_schunk* frame_to_schunk(blosc2_frame_s* frame, bool copy) {
   int32_t header_len;
   int64_t frame_len;
   int rc;
   blosc2_schunk* schunk = calloc(1, sizeof(blosc2_schunk));
   schunk->frame = (blosc2_frame*)frame;
   rc = get_header_info(frame, &header_len, &frame_len, &schunk->nbytes,
                        &schunk->cbytes, &schunk->blocksize,
                        &schunk->chunksize, &schunk->nchunks, &schunk->typesize,
                        &schunk->compcode, &schunk->clevel, schunk->filters,
                        schunk->filters_meta);
   if (rc < 0) {
     BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
     blosc2_schunk_free(schunk);
     return NULL;
   }
   int32_t nchunks = schunk->nchunks;
   int64_t nbytes = schunk->nbytes;
   (void) nbytes;
   int64_t cbytes = schunk->cbytes;
 
   // Compression and decompression contexts
   blosc2_cparams *cparams;
   blosc2_schunk_get_cparams(schunk, &cparams);
   schunk->cctx = blosc2_create_cctx(*cparams);
   blosc2_dparams *dparams;
   blosc2_schunk_get_dparams(schunk, &dparams);
   schunk->dctx = blosc2_create_dctx(*dparams);
   blosc2_storage storage = {.contiguous = copy ? false : true};
   schunk->storage = get_new_storage(&storage, cparams, dparams);
   free(cparams);
   free(dparams);
 
   if (!copy) {
     goto out;
   }
 
   // We are not attached to a frame anymore
   schunk->frame = NULL;
 
   if (nchunks == 0) {
     goto out;
   }
 
   // Get the compressed offsets
   int32_t coffsets_cbytes = 0;
-  uint8_t* coffsets = get_coffsets(frame, header_len, cbytes, &coffsets_cbytes);
+  uint8_t* coffsets = get_coffsets(frame, header_len, cbytes, nchunks, &coffsets_cbytes);
   if (coffsets == NULL) {
     blosc2_schunk_free(schunk);
     BLOSC_TRACE_ERROR("Cannot get the offsets for the frame.");
     return NULL;
   }
 
   // Decompress offsets
   blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_context *dctx = blosc2_create_dctx(off_dparams);
   int64_t* offsets = (int64_t *) malloc((size_t)nchunks * 8);
   int32_t off_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes,
                                              offsets, nchunks * sizeof(int64_t));
   blosc2_free_ctx(dctx);
   if (off_nbytes < 0) {
     free(offsets);
     blosc2_schunk_free(schunk);
     BLOSC_TRACE_ERROR("Cannot decompress the offsets chunk.");
     return NULL;
   }
 
   // We want the contiguous schunk, so create the actual data chunks (and, while doing this,
   // get a guess at the blocksize used in this frame)
   int64_t acc_nbytes = 0;
   int64_t acc_cbytes = 0;
   int32_t blocksize = 0;
   int32_t chunk_nbytes;
   int32_t chunk_cbytes;
   int32_t chunk_blocksize;
   size_t prev_alloc = BLOSC_EXTENDED_HEADER_LENGTH;
   uint8_t* data_chunk = NULL;
   FILE* fp = NULL;
   if (frame->cframe == NULL) {
     data_chunk = malloc((size_t)prev_alloc);
     if (!frame->sframe) {
       // If not the chunks won't be in the frame
       fp = fopen(frame->urlpath, "rb");
       if (fp == NULL) {
         free(data_chunk);
         free(offsets);
         blosc2_schunk_free(schunk);
         return NULL;
       }
     }
   }
   schunk->data = malloc(nchunks * sizeof(void*));
   for (int i = 0; i < nchunks; i++) {
     if (frame->cframe != NULL) {
       data_chunk = frame->cframe + header_len + offsets[i];
       rc = blosc2_cbuffer_sizes(data_chunk, NULL, &chunk_cbytes, NULL);
       if (rc < 0) {
         return NULL;
       }
     }
     else {
       size_t rbytes;
       bool needs_free = false;
       if (frame->sframe) {
         rbytes = frame_get_lazychunk(frame, offsets[i], &data_chunk, &needs_free);
       }
       else {
         fseek(fp, header_len + offsets[i], SEEK_SET);
         rbytes = fread(data_chunk, 1, BLOSC_EXTENDED_HEADER_LENGTH, fp);
         if (rbytes != BLOSC_EXTENDED_HEADER_LENGTH) {
           fclose(fp);
           return NULL;
         }
       }
       if (rbytes != BLOSC_EXTENDED_HEADER_LENGTH) {
         if (frame->sframe) {
           free(data_chunk);
         }
         else {
           fclose(fp);
         }
         free(offsets);
         blosc2_schunk_free(schunk);
         return NULL;
       }
       rc = blosc2_cbuffer_sizes(data_chunk, NULL, &chunk_cbytes, NULL);
       if (rc < 0) {
         return NULL;
       }
       if (chunk_cbytes > prev_alloc) {
         data_chunk = realloc(data_chunk, chunk_cbytes);
         prev_alloc = chunk_cbytes;
       }
       if (!frame->sframe) {
         fseek(fp, header_len + offsets[i], SEEK_SET);
         rbytes = fread(data_chunk, 1, chunk_cbytes, fp);
         if (rbytes != chunk_cbytes) {
           fclose(fp);
           free(offsets);
           blosc2_schunk_free(schunk);
           return NULL;
         }
       }
     }
     uint8_t* new_chunk = malloc(chunk_cbytes);
     memcpy(new_chunk, data_chunk, chunk_cbytes);
     schunk->data[i] = new_chunk;
     rc = blosc2_cbuffer_sizes(data_chunk, &chunk_nbytes, NULL, &chunk_blocksize);
     if (rc < 0) {
       blosc2_schunk_free(schunk);
       return NULL;
     }
     acc_nbytes += chunk_nbytes;
     acc_cbytes += chunk_cbytes;
     if (i == 0) {
       blocksize = chunk_blocksize;
     }
     else if (blocksize != chunk_blocksize) {
       // Blocksize varies
       blocksize = 0;
     }
   }
   schunk->blocksize = blocksize;
 
   if (frame->cframe == NULL) {
     free(data_chunk);
     if (!frame->sframe) {
       fclose(fp);
     }
   }
   free(offsets);
 
   if (acc_nbytes != nbytes || acc_cbytes != cbytes) {
     blosc2_schunk_free(schunk);
     return NULL;
   }
 
   out:
   rc = frame_get_metalayers(frame, schunk);
   if (rc < 0) {
     blosc2_schunk_free(schunk);
     BLOSC_TRACE_ERROR("Cannot access the metalayers.");
     return NULL;
   }
 
   rc = frame_get_vlmetalayers(frame, schunk);
   if (rc < 0) {
     blosc2_schunk_free(schunk);
     BLOSC_TRACE_ERROR("Cannot access the vlmetalayers.");
     return NULL;
   }
 
   return schunk;
 }
@@ -1698,26 +1707,27 @@ int sort_offset(const void* a, const void* b) {
 }
 
 
-int get_coffset(blosc2_frame_s* frame, int32_t header_len, int64_t cbytes, int32_t nchunk, int64_t *offset) {
+int get_coffset(blosc2_frame_s* frame, int32_t header_len, int64_t cbytes,
+                int32_t nchunk, int32_t nchunks, int64_t *offset) {
   int32_t off_cbytes;
   // Get the offset to nchunk
-  uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, &off_cbytes);
+  uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, nchunks, &off_cbytes);
   if (coffsets == NULL) {
     BLOSC_TRACE_ERROR("Cannot get the offset for chunk %d for the frame.", nchunk);
     return BLOSC2_ERROR_DATA;
   }
 
   // Get the 64-bit offset
   int rc = blosc2_getitem(coffsets, off_cbytes, nchunk, 1, offset, (int32_t)sizeof(int64_t));
   if (rc < 0) {
     BLOSC_TRACE_ERROR("Problems retrieving a chunk offset.");
   } else if (*offset > frame->len) {
     BLOSC_TRACE_ERROR("Cannot read chunk %d outside of frame boundary.", nchunk);
     rc = BLOSC2_ERROR_READ_BUFFER;
   }
 
   return rc;
 }
 
 
 // Detect and return a chunk with special values in offsets (only zeros, NaNs and non initialized)
@@ -1771,514 +1781,514 @@ int frame_special_chunk(int64_t special_value, int32_t nbytes, int32_t typesize,
 /* Return a compressed chunk that is part of a frame in the `chunk` parameter.
  * If the frame is disk-based, a buffer is allocated for the (compressed) chunk,
  * and hence a free is needed.  You can check if the chunk requires a free with the `needs_free`
  * parameter.
  * If the chunk does not need a free, it means that a pointer to the location in frame is returned
  * in the `chunk` parameter.
  *
  * The size of the (compressed) chunk is returned.  If some problem is detected, a negative code
  * is returned instead.
 */
 int frame_get_chunk(blosc2_frame_s *frame, int nchunk, uint8_t **chunk, bool *needs_free) {
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t blocksize;
   int32_t chunksize;
   int32_t nchunks;
   int32_t typesize;
   int64_t offset;
   int32_t chunk_cbytes;
   int rc;
 
   *chunk = NULL;
   *needs_free = false;
   rc = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes,
                        &blocksize, &chunksize, &nchunks,
                        &typesize, NULL, NULL, NULL, NULL);
   if (rc < 0) {
     BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
     return rc;
   }
 
   if (nchunk >= nchunks) {
     BLOSC_TRACE_ERROR("nchunk ('%d') exceeds the number of chunks "
                     "('%d') in frame.", nchunk, nchunks);
     return BLOSC2_ERROR_INVALID_PARAM;
   }
 
   // Get the offset to nchunk
-  rc = get_coffset(frame, header_len, cbytes, nchunk, &offset);
+  rc = get_coffset(frame, header_len, cbytes, nchunk, nchunks, &offset);
   if (rc < 0) {
     BLOSC_TRACE_ERROR("Unable to get offset to chunk %d.", nchunk);
     return rc;
   }
 
   if (offset < 0) {
     // Special value
     chunk_cbytes = BLOSC_EXTENDED_HEADER_LENGTH;
     rc = frame_special_chunk(offset, chunksize, typesize, blocksize, chunk, chunk_cbytes, needs_free);
     if (rc < 0) {
       return rc;
     }
     goto end;
   }
 
   if (frame->sframe) {
     // Sparse on-disk
     nchunk = offset;
     return sframe_get_chunk(frame, nchunk, chunk, needs_free);
   }
 
   if (frame->cframe == NULL) {
     uint8_t header[BLOSC_EXTENDED_HEADER_LENGTH];
     FILE* fp = fopen(frame->urlpath, "rb");
     fseek(fp, header_len + offset, SEEK_SET);
     size_t rbytes = fread(header, 1, sizeof(header), fp);
     if (rbytes != sizeof(header)) {
       BLOSC_TRACE_ERROR("Cannot read the cbytes for chunk in the frame.");
       fclose(fp);
       return BLOSC2_ERROR_FILE_READ;
     }
     rc = blosc2_cbuffer_sizes(header, NULL, &chunk_cbytes, NULL);
     if (rc < 0) {
       BLOSC_TRACE_ERROR("Cannot read the cbytes for chunk in the frame.");
       fclose(fp);
       return rc;
     }
     *chunk = malloc(chunk_cbytes);
     fseek(fp, header_len + offset, SEEK_SET);
     rbytes = fread(*chunk, 1, chunk_cbytes, fp);
     fclose(fp);
     if (rbytes != chunk_cbytes) {
       BLOSC_TRACE_ERROR("Cannot read the chunk out of the frame.");
       return BLOSC2_ERROR_FILE_READ;
     }
     *needs_free = true;
   } else {
     // The chunk is in memory and just one pointer away
     *chunk = frame->cframe + header_len + offset;
     rc = blosc2_cbuffer_sizes(*chunk, NULL, &chunk_cbytes, NULL);
     if (rc < 0) {
       return rc;
     }
   }
 
   end:
   return (int32_t)chunk_cbytes;
 }
 
 
 /* Return a compressed chunk that is part of a frame in the `chunk` parameter.
  * If the frame is disk-based, a buffer is allocated for the (lazy) chunk,
  * and hence a free is needed.  You can check if the chunk requires a free with the `needs_free`
  * parameter.
  * If the chunk does not need a free, it means that the frame is in memory and that just a
  * pointer to the location of the chunk in memory is returned.
  *
  * The size of the (compressed, potentially lazy) chunk is returned.  If some problem is detected,
  * a negative code is returned instead.
 */
 int frame_get_lazychunk(blosc2_frame_s *frame, int nchunk, uint8_t **chunk, bool *needs_free) {
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t blocksize;
   int32_t chunksize;
   int32_t nchunks;
   int32_t typesize;
   int32_t lazychunk_cbytes;
   int64_t offset;
   FILE* fp = NULL;
 
   *chunk = NULL;
   *needs_free = false;
   int rc = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes,
                            &blocksize, &chunksize, &nchunks,
                            &typesize, NULL, NULL, NULL, NULL);
   if (rc < 0) {
     BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
     return rc;
   }
 
   if (nchunk >= nchunks) {
     BLOSC_TRACE_ERROR("nchunk ('%d') exceeds the number of chunks "
                       "('%d') in frame.", nchunk, nchunks);
     return BLOSC2_ERROR_INVALID_PARAM;
   }
 
   // Get the offset to nchunk
-  rc = get_coffset(frame, header_len, cbytes, nchunk, &offset);
+  rc = get_coffset(frame, header_len, cbytes, nchunk, nchunks, &offset);
   if (rc < 0) {
     BLOSC_TRACE_ERROR("Unable to get offset to chunk %d.", nchunk);
     return rc;
   }
 
   if (offset < 0) {
     // Special value
     lazychunk_cbytes = BLOSC_EXTENDED_HEADER_LENGTH;
     rc = frame_special_chunk(offset, chunksize, typesize, blocksize, chunk,
                              (int32_t)lazychunk_cbytes, needs_free);
     goto end;
   }
 
   if (frame->cframe == NULL) {
     // TODO: make this portable across different endianness
     // Get info for building a lazy chunk
     int32_t chunk_nbytes;
     int32_t chunk_cbytes;
     int32_t chunk_blocksize;
     uint8_t header[BLOSC_EXTENDED_HEADER_LENGTH];
     if (frame->sframe) {
       // The chunk is not in the frame
       fp = sframe_open_chunk(frame->urlpath, offset, "rb");
     }
     else {
       fp = fopen(frame->urlpath, "rb");
       fseek(fp, header_len + offset, SEEK_SET);
     }
     size_t rbytes = fread(header, 1, BLOSC_EXTENDED_HEADER_LENGTH, fp);
     if (rbytes != BLOSC_EXTENDED_HEADER_LENGTH) {
       BLOSC_TRACE_ERROR("Cannot read the header for chunk in the frame.");
       rc = BLOSC2_ERROR_FILE_READ;
       goto end;
     }
     rc = blosc2_cbuffer_sizes(header, &chunk_nbytes, &chunk_cbytes, &chunk_blocksize);
     if (rc < 0) {
       goto end;
     }
     size_t nblocks = chunk_nbytes / chunk_blocksize;
     size_t leftover_block = chunk_nbytes % chunk_blocksize;
     nblocks = leftover_block ? nblocks + 1 : nblocks;
     // Allocate space for the lazy chunk
     size_t trailer_len;
     int32_t special_type = (header[BLOSC2_CHUNK_BLOSC2_FLAGS] >> 4) & BLOSC2_SPECIAL_MASK;
     size_t trailer_offset = BLOSC_EXTENDED_HEADER_LENGTH;
     if (special_type == 0) {
       // Regular values have offsets for blocks
       trailer_offset += nblocks * sizeof(int32_t);
       trailer_len = sizeof(int32_t) + sizeof(int64_t) + nblocks * sizeof(int32_t);
       lazychunk_cbytes = trailer_offset + trailer_len;
     }
     else if (special_type == BLOSC2_VALUE_RUNLEN) {
       trailer_offset += typesize;
       trailer_len = 0;
       lazychunk_cbytes = trailer_offset + trailer_len;
     }
     else {
       rc = BLOSC2_ERROR_INVALID_HEADER;
       goto end;
     }
     *chunk = malloc(lazychunk_cbytes);
     *needs_free = true;
 
     // Read just the full header and bstarts section too (lazy partial length)
     if (frame->sframe) {
       fseek(fp, 0, SEEK_SET);
     }
     else {
       fseek(fp, header_len + offset, SEEK_SET);
     }
 
     rbytes = fread(*chunk, 1, trailer_offset, fp);
     if (rbytes != trailer_offset) {
       BLOSC_TRACE_ERROR("Cannot read the (lazy) chunk out of the frame.");
       rc = BLOSC2_ERROR_FILE_READ;
       goto end;
     }
     if (special_type == BLOSC2_VALUE_RUNLEN) {
       // Value runlen is not returning a lazy chunk.  We are done.
       goto end;
     }
 
     // Mark chunk as lazy
     uint8_t* blosc2_flags = *chunk + BLOSC2_CHUNK_BLOSC2_FLAGS;
     *blosc2_flags |= 0x08U;
 
     // Add the trailer (currently, nchunk + offset + block_csizes)
     if (frame->sframe) {
       *(int32_t*)(*chunk + trailer_offset) = (int32_t)offset;   // offset is nchunk for sframes
       *(int64_t*)(*chunk + trailer_offset + sizeof(int32_t)) = offset;
     }
     else {
       *(int32_t*)(*chunk + trailer_offset) = nchunk;
       *(int64_t*)(*chunk + trailer_offset + sizeof(int32_t)) = header_len + offset;
     }
 
     int32_t* block_csizes = malloc(nblocks * sizeof(int32_t));
 
     int memcpyed = *(*chunk + BLOSC2_CHUNK_FLAGS) & (uint8_t)BLOSC_MEMCPYED;
     if (memcpyed) {
       // When memcpyed the blocksizes are trivial to compute
       for (int i = 0; i < (int)nblocks; i++) {
         block_csizes[i] = (int)chunk_blocksize;
       }
     }
     else {
       // In regular, compressed chunks, we need to sort the bstarts (they can be out
       // of order because of multi-threading), and get a reverse index too.
       memcpy(block_csizes, *chunk + BLOSC_EXTENDED_HEADER_LENGTH, nblocks * sizeof(int32_t));
       // Helper structure to keep track of original indexes
       struct csize_idx *csize_idx = malloc(nblocks * sizeof(struct csize_idx));
       for (int n = 0; n < (int)nblocks; n++) {
         csize_idx[n].val = block_csizes[n];
         csize_idx[n].idx = n;
       }
       qsort(csize_idx, nblocks, sizeof(struct csize_idx), &sort_offset);
       // Compute the actual csizes
       int idx;
       for (int n = 0; n < (int)nblocks - 1; n++) {
         idx = csize_idx[n].idx;
         block_csizes[idx] = csize_idx[n + 1].val - csize_idx[n].val;
       }
       idx = csize_idx[nblocks - 1].idx;
       block_csizes[idx] = (int)chunk_cbytes - csize_idx[nblocks - 1].val;
       free(csize_idx);
     }
     // Copy the csizes at the end of the trailer
     void *trailer_csizes = *chunk + lazychunk_cbytes - nblocks * sizeof(int32_t);
     memcpy(trailer_csizes, block_csizes, nblocks * sizeof(int32_t));
     free(block_csizes);
   } else {
     // The chunk is in memory and just one pointer away
     int64_t chunk_header_offset = header_len + offset;
     int64_t chunk_cbytes_offset = chunk_header_offset + BLOSC_MIN_HEADER_LENGTH;
 
     *chunk = frame->cframe + chunk_header_offset;
 
     if (chunk_cbytes_offset > frame->len) {
       BLOSC_TRACE_ERROR("Cannot read the header for chunk in the (contiguous) frame.");
       rc = BLOSC2_ERROR_READ_BUFFER;
     } else {
       rc = blosc2_cbuffer_sizes(*chunk, NULL, &lazychunk_cbytes, NULL);
       if (rc && chunk_cbytes_offset + lazychunk_cbytes > frame_len) {
         BLOSC_TRACE_ERROR("Compressed bytes exceed beyond frame length.");
         rc = BLOSC2_ERROR_READ_BUFFER;
       }
     }
   }
 
   end:
   if (fp != NULL) {
     fclose(fp);
   }
   if (rc < 0) {
     if (*needs_free) {
       free(*chunk);
       *chunk = NULL;
     }
     return rc;
   }
 
   return (int)lazychunk_cbytes;
 }
 
 
 /* Append an existing chunk into a frame. */
 void* frame_append_chunk(blosc2_frame_s* frame, void* chunk, blosc2_schunk* schunk) {
   int8_t* chunk_ = chunk;
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t blocksize;
   int32_t chunksize;
   int32_t nchunks;
   int rc = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &blocksize, &chunksize,
                            &nchunks, NULL, NULL, NULL, NULL, NULL);
   if (rc < 0) {
     BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
     return NULL;
   }
 
   /* The uncompressed and compressed sizes start at byte 4 and 12 */
   int32_t chunk_nbytes;
   int32_t chunk_cbytes;
   rc = blosc2_cbuffer_sizes(chunk, &chunk_nbytes, &chunk_cbytes, NULL);
   if (rc < 0) {
     return NULL;
   }
 
   if ((nchunks > 0) && (chunk_nbytes > (size_t)chunksize)) {
     BLOSC_TRACE_ERROR("Appending chunks with a larger chunksize than frame is "
                       "not allowed yet %d != %d.", chunk_nbytes, chunksize);
     return NULL;
   }
 
   // Check that we are not appending a small chunk after another small chunk
   int32_t chunk_nbytes_last;
   if (chunksize == 0 && (nchunks > 0) && (chunk_nbytes < (size_t)chunksize)) {
     uint8_t* last_chunk;
     bool needs_free;
     rc = frame_get_lazychunk(frame, nchunks - 1, &last_chunk, &needs_free);
     if (rc < 0) {
       BLOSC_TRACE_ERROR("Cannot get the last chunk (in position %d).", nchunks - 1);
     } else {
       rc = blosc2_cbuffer_sizes(last_chunk, &chunk_nbytes_last, NULL, NULL);
     }
     if (needs_free) {
       free(last_chunk);
     }
     if (rc < 0) {
       return NULL;
     }
     if ((chunk_nbytes_last < (size_t)chunksize) && (nbytes < (size_t)chunksize)) {
       BLOSC_TRACE_ERROR("Appending two consecutive chunks with a chunksize smaller "
                         "than the frame chunksize is not allowed yet: %d != %d.",
                         chunk_nbytes, chunksize);
       return NULL;
     }
   }
 
   // Get the current offsets and add one more
   int32_t off_nbytes = (nchunks + 1) * sizeof(int64_t);
   int64_t* offsets = (int64_t *) malloc((size_t)off_nbytes);
   if (nchunks > 0) {
     int32_t coffsets_cbytes;
-    uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, &coffsets_cbytes);
+    uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, nchunks, &coffsets_cbytes);
     if (coffsets == NULL) {
       BLOSC_TRACE_ERROR("Cannot get the offsets for the frame.");
       free(offsets);
       return NULL;
     }
     if (coffsets_cbytes == 0) {
       coffsets_cbytes = (int32_t)cbytes;
     }
 
     // Decompress offsets
     blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;
     blosc2_context *dctx = blosc2_create_dctx(off_dparams);
     int32_t prev_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes, offsets,
                                                 nchunks * sizeof(int64_t));
     blosc2_free_ctx(dctx);
     if (prev_nbytes < 0) {
       free(offsets);
       BLOSC_TRACE_ERROR("Cannot decompress the offsets chunk.");
       return NULL;
     }
   }
 
   // Add the new offset
   int special_value = (chunk_[BLOSC2_CHUNK_BLOSC2_FLAGS] >> 4) & BLOSC2_SPECIAL_MASK;
   uint64_t offset_value = ((uint64_t)1 << 63);
   switch (special_value) {
     case BLOSC2_ZERO_RUNLEN:
       // Zero chunk.  Code it in a special way.
       offset_value += (uint64_t) BLOSC2_ZERO_RUNLEN << (8 * 7);  // chunk of zeros
       to_little(offsets + nchunks, &offset_value, sizeof(uint64_t));
       chunk_cbytes = 0;   // we don't need to store the chunk
       break;
     case BLOSC2_UNINIT_VALUE:
       // Non initizalized values chunk.  Code it in a special way.
       offset_value += (uint64_t) BLOSC2_UNINIT_VALUE << (8 * 7);  // chunk of uninit values
       to_little(offsets + nchunks, &offset_value, sizeof(uint64_t));
       chunk_cbytes = 0;   // we don't need to store the chunk
       break;
     case BLOSC2_NAN_RUNLEN:
       // NaN chunk.  Code it in a special way.
       offset_value += (uint64_t)BLOSC2_NAN_RUNLEN << (8 * 7);  // chunk of NANs
       to_little(offsets + nchunks, &offset_value, sizeof(uint64_t));
       chunk_cbytes = 0;   // we don't need to store the chunk
       break;
     default:
       if (frame->sframe) {
         offsets[nchunks] = nchunks;
       }
       else {
         offsets[nchunks] = cbytes;
       }
   }
 
   // Re-compress the offsets again
   blosc2_context* cctx = blosc2_create_cctx(BLOSC2_CPARAMS_DEFAULTS);
   cctx->typesize = sizeof(int64_t);  // 64-bit offsets
   // The params below have been fine-tuned with the zero_runlen bench
   cctx->nthreads = 4;  // 4 threads seems a decent default for nowadays CPUs
   // cctx->compcode = BLOSC_LZ4;
   void* off_chunk = malloc((size_t)off_nbytes + BLOSC_MAX_OVERHEAD);
   int32_t new_off_cbytes = blosc2_compress_ctx(cctx, offsets, off_nbytes,
                                                off_chunk, off_nbytes + BLOSC_MAX_OVERHEAD);
   blosc2_free_ctx(cctx);
 
   free(offsets);
   if (new_off_cbytes < 0) {
     free(off_chunk);
     return NULL;
   }
 
   int64_t new_cbytes = cbytes + chunk_cbytes;
   int64_t new_frame_len;
   if (frame->sframe) {
     new_frame_len = header_len + 0 + new_off_cbytes + frame->trailer_len;
   }
   else {
     new_frame_len = header_len + new_cbytes + new_off_cbytes + frame->trailer_len;
   }
 
   FILE* fp = NULL;
   if (frame->cframe != NULL) {
     uint8_t* framep = frame->cframe;
     /* Make space for the new chunk and copy it */
     frame->cframe = framep = realloc(framep, (size_t)new_frame_len);
     if (framep == NULL) {
       BLOSC_TRACE_ERROR("Cannot realloc space for the frame.");
       return NULL;
     }
     /* Copy the chunk */
     memcpy(framep + header_len + cbytes, chunk, (size_t)chunk_cbytes);
     /* Copy the offsets */
     memcpy(framep + header_len + new_cbytes, off_chunk, (size_t)new_off_cbytes);
   }
   else {
     size_t wbytes;
     if (frame->sframe) {
       // Update the offsets chunk in the chunks frame
       if (chunk_cbytes != 0) {
         if (sframe_create_chunk(frame, chunk, nchunks, chunk_cbytes) == NULL) {
           BLOSC_TRACE_ERROR("Cannot write the full chunk.");
           return NULL;
         }
       }
       fp = sframe_open_index(frame->urlpath, "rb+");
       fseek(fp, header_len, SEEK_SET);
     }
     else {
       // Regular frame
       fp = fopen(frame->urlpath, "rb+");
       fseek(fp, header_len + cbytes, SEEK_SET);
       wbytes = fwrite(chunk, 1, (size_t)chunk_cbytes, fp);  // the new chunk
       if (wbytes != (size_t)chunk_cbytes) {
         BLOSC_TRACE_ERROR("Cannot write the full chunk to frame.");
         fclose(fp);
         return NULL;
       }
     }
     wbytes = fwrite(off_chunk, 1, (size_t)new_off_cbytes, fp);  // the new offsets
     fclose(fp);
     if (wbytes != (size_t)new_off_cbytes) {
       BLOSC_TRACE_ERROR("Cannot write the offsets to frame.");
       return NULL;
     }
   }
   // Invalidate the cache for chunk offsets
   if (frame->coffsets != NULL) {
     free(frame->coffsets);
     frame->coffsets = NULL;
   }
   free(chunk);  // chunk has always to be a copy when reaching here...
   free(off_chunk);
 
   frame->len = new_frame_len;
   rc = frame_update_header(frame, schunk, false);
   if (rc < 0) {
     return NULL;
   }
 
   rc = frame_update_trailer(frame, schunk);
   if (rc < 0) {
     return NULL;
   }
 
   return frame;
 }
@@ -2287,184 +2297,184 @@ void* frame_append_chunk(blosc2_frame_s* frame, void* chunk, blosc2_schunk* schu
 void* frame_insert_chunk(blosc2_frame_s* frame, int nchunk, void* chunk, blosc2_schunk* schunk) {
   uint8_t* chunk_ = chunk;
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t blocksize;
   int32_t chunksize;
   int32_t nchunks;
   int rc = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes,
                            &blocksize, &chunksize,  &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
   if (rc < 0) {
     BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
     return NULL;
   }
   int32_t chunk_cbytes;
   rc = blosc2_cbuffer_sizes(chunk_, NULL, &chunk_cbytes, NULL);
   if (rc < 0) {
     return NULL;
   }
 
   // Get the current offsets
   int32_t off_nbytes = (nchunks + 1) * 8;
   int64_t* offsets = (int64_t *) malloc((size_t)off_nbytes);
   if (nchunks > 0) {
     int32_t coffsets_cbytes = 0;
-    uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, &coffsets_cbytes);
+    uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, nchunks, &coffsets_cbytes);
     if (coffsets == NULL) {
       BLOSC_TRACE_ERROR("Cannot get the offsets for the frame.");
       return NULL;
     }
     if (coffsets_cbytes == 0) {
       coffsets_cbytes = (int32_t)cbytes;
     }
 
     // Decompress offsets
     blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;
     blosc2_context *dctx = blosc2_create_dctx(off_dparams);
     int32_t prev_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes, offsets, nchunks * 8);
     blosc2_free_ctx(dctx);
     if (prev_nbytes < 0) {
       free(offsets);
       BLOSC_TRACE_ERROR("Cannot decompress the offsets chunk.");
       return NULL;
     }
   }
 
   // TODO: Improvement: Check if new chunk is smaller than previous one
 
   // Add the new offset
   int special_value = (chunk_[BLOSC2_CHUNK_BLOSC2_FLAGS] >> 4) & BLOSC2_SPECIAL_MASK;
   uint64_t offset_value = ((uint64_t)1 << 63);
   switch (special_value) {
     case BLOSC2_ZERO_RUNLEN:
       // Zero chunk.  Code it in a special way.
       offset_value += (uint64_t)BLOSC2_ZERO_RUNLEN << (8 * 7);  // indicate a chunk of zeros
       for (int i = nchunks; i > nchunk; i--) {
         offsets[i] = offsets[i - 1];
       }
       to_little(offsets + nchunk, &offset_value, sizeof(uint64_t));
       chunk_cbytes = 0;   // we don't need to store the chunk
       break;
     case BLOSC2_UNINIT_VALUE:
       // Non initizalized values chunk.  Code it in a special way.
       offset_value += (uint64_t) BLOSC2_UNINIT_VALUE << (8 * 7);  // chunk of uninit values
       for (int i = nchunks; i > nchunk; i--) {
         offsets[i] = offsets[i - 1];
       }
       to_little(offsets + nchunk, &offset_value, sizeof(uint64_t));
       chunk_cbytes = 0;   // we don't need to store the chunk
       break;
     case BLOSC2_NAN_RUNLEN:
       // NaN chunk.  Code it in a special way.
       offset_value += (uint64_t)BLOSC2_NAN_RUNLEN << (8 * 7);  // indicate a chunk of NANs
       for (int i = nchunks; i > nchunk; i--) {
         offsets[i] = offsets[i - 1];
       }
       to_little(offsets + nchunk, &offset_value, sizeof(uint64_t));
       chunk_cbytes = 0;   // we don't need to store the chunk
       break;
     default:
       // Add the new offset
       for (int i = nchunks; i > nchunk; i--) {
         offsets[i] = offsets[i - 1];
       }
       if (frame->sframe) {
         offsets[nchunk] = nchunks;
       }
       else {
         offsets[nchunk] = cbytes;
       }
   }
 
   // Re-compress the offsets again
   blosc2_context* cctx = blosc2_create_cctx(BLOSC2_CPARAMS_DEFAULTS);
   cctx->typesize = 8;
   void* off_chunk = malloc((size_t)off_nbytes + BLOSC_MAX_OVERHEAD);
   int32_t new_off_cbytes = blosc2_compress_ctx(cctx, offsets, off_nbytes,
                                                off_chunk, off_nbytes + BLOSC_MAX_OVERHEAD);
   blosc2_free_ctx(cctx);
 
   free(offsets);
   if (new_off_cbytes < 0) {
     free(off_chunk);
     return NULL;
   }
 
   int64_t new_cbytes = cbytes + chunk_cbytes;
 
   int64_t new_frame_len;
   if (frame->sframe) {
     new_frame_len = header_len + 0 + new_off_cbytes + frame->trailer_len;
   }
   else {
     new_frame_len = header_len + new_cbytes + new_off_cbytes + frame->trailer_len;
   }
 
   // Add the chunk and update meta
   FILE* fp = NULL;
   if (frame->cframe != NULL) {
     uint8_t* framep = frame->cframe;
     /* Make space for the new chunk and copy it */
     frame->cframe = framep = realloc(framep, (size_t)new_frame_len);
     if (framep == NULL) {
       BLOSC_TRACE_ERROR("Cannot realloc space for the frame.");
       return NULL;
     }
     /* Copy the chunk */
     memcpy(framep + header_len + cbytes, chunk, (size_t)chunk_cbytes);
     /* Copy the offsets */
     memcpy(framep + header_len + new_cbytes, off_chunk, (size_t)new_off_cbytes);
   } else {
     size_t wbytes;
     if (frame->sframe) {
       if (chunk_cbytes != 0) {
         if (sframe_create_chunk(frame, chunk, nchunks, chunk_cbytes) == NULL) {
           BLOSC_TRACE_ERROR("Cannot write the full chunk.");
           return NULL;
         }
       }
       // Update the offsets chunk in the chunks frame
       fp = sframe_open_index(frame->urlpath, "rb+");
       fseek(fp, header_len + 0, SEEK_SET);
     }
     else {
       // Regular frame
       fp = fopen(frame->urlpath, "rb+");
       fseek(fp, header_len + cbytes, SEEK_SET);
       wbytes = fwrite(chunk, 1, (size_t)chunk_cbytes, fp);  // the new chunk
       if (wbytes != (size_t)chunk_cbytes) {
         BLOSC_TRACE_ERROR("Cannot write the full chunk to frame.");
         fclose(fp);
         return NULL;
       }
     }
     wbytes = fwrite(off_chunk, 1, (size_t)new_off_cbytes, fp);  // the new offsets
     fclose(fp);
     if (wbytes != (size_t)new_off_cbytes) {
       BLOSC_TRACE_ERROR("Cannot write the offsets to frame.");
       return NULL;
     }
     // Invalidate the cache for chunk offsets
     if (frame->coffsets != NULL) {
       free(frame->coffsets);
       frame->coffsets = NULL;
     }
   }
   free(chunk);  // chunk has always to be a copy when reaching here...
   free(off_chunk);
 
   frame->len = new_frame_len;
   rc = frame_update_header(frame, schunk, false);
   if (rc < 0) {
     return NULL;
   }
 
   rc = frame_update_trailer(frame, schunk);
   if (rc < 0) {
     return NULL;
   }
 
   return frame;
 }
@@ -2473,204 +2483,204 @@ void* frame_insert_chunk(blosc2_frame_s* frame, int nchunk, void* chunk, blosc2_
 void* frame_update_chunk(blosc2_frame_s* frame, int nchunk, void* chunk, blosc2_schunk* schunk) {
   uint8_t *chunk_ = (uint8_t *) chunk;
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t blocksize;
   int32_t chunksize;
   int32_t nchunks;
   int rc = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes,
                            &blocksize, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
   if (rc < 0) {
     BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
     return NULL;
   }
   if (nchunk >= nchunks) {
     BLOSC_TRACE_ERROR("The chunk must already exist.");
     return NULL;
   }
 
   int32_t chunk_cbytes;
   rc = blosc2_cbuffer_sizes(chunk, NULL, &chunk_cbytes, NULL);
   if (rc < 0) {
     return NULL;
   }
   // Get the current offsets
   int32_t off_nbytes = nchunks * 8;
   int64_t* offsets = (int64_t *) malloc((size_t)off_nbytes);
   if (nchunks > 0) {
     int32_t coffsets_cbytes = 0;
-    uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, &coffsets_cbytes);
+    uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, nchunks, &coffsets_cbytes);
     if (coffsets == NULL) {
       BLOSC_TRACE_ERROR("Cannot get the offsets for the frame.");
       return NULL;
     }
     if (coffsets_cbytes == 0) {
       coffsets_cbytes = (int32_t)cbytes;
     }
 
     // Decompress offsets
     blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;
     blosc2_context *dctx = blosc2_create_dctx(off_dparams);
     int32_t prev_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes, offsets, nchunks * 8);
     blosc2_free_ctx(dctx);
     if (prev_nbytes < 0) {
       free(offsets);
       BLOSC_TRACE_ERROR("Cannot decompress the offsets chunk.");
       return NULL;
     }
   }
   int32_t cbytes_old;
   int32_t old_offset;
   if (!frame->sframe) {
     // See how big would be the space
     old_offset = offsets[nchunk];
     bool needs_free;
     uint8_t *chunk_old;
     int err = blosc2_schunk_get_chunk(schunk, nchunk, &chunk_old, &needs_free);
     if (err < 0) {
       BLOSC_TRACE_ERROR("%d chunk can not be obtained from schunk.", nchunk);
       return NULL;
     }
 
     if (chunk_old == NULL) {
       cbytes_old = 0;
     }
     else {
       cbytes_old = sw32_(chunk_old + BLOSC2_CHUNK_CBYTES);
       if (cbytes_old == BLOSC_MAX_OVERHEAD) {
         cbytes_old = 0;
       }
     }
     if (needs_free) {
       free(chunk_old);
     }
   }
 
   // Add the new offset
   int special_value = (chunk_[BLOSC2_CHUNK_BLOSC2_FLAGS] >> 4) & BLOSC2_SPECIAL_MASK;
   uint64_t offset_value = ((uint64_t)1 << 63);
   switch (special_value) {
     case BLOSC2_ZERO_RUNLEN:
       // Zero chunk.  Code it in a special way.
       offset_value += (uint64_t)BLOSC2_ZERO_RUNLEN << (8 * 7);  // indicate a chunk of zeros
       to_little(offsets + nchunk, &offset_value, sizeof(uint64_t));
       chunk_cbytes = 0;   // we don't need to store the chunk
       break;
     case BLOSC2_UNINIT_VALUE:
       // Non initizalized values chunk.  Code it in a special way.
       offset_value += (uint64_t)BLOSC2_UNINIT_VALUE << (8 * 7);  // indicate a chunk of uninit values
       to_little(offsets + nchunk, &offset_value, sizeof(uint64_t));
       chunk_cbytes = 0;   // we don't need to store the chunk
       break;
     case BLOSC2_NAN_RUNLEN:
       // NaN chunk.  Code it in a special way.
       offset_value += (uint64_t)BLOSC2_NAN_RUNLEN << (8 * 7);  // indicate a chunk of NANs
       to_little(offsets + nchunk, &offset_value, sizeof(uint64_t));
       chunk_cbytes = 0;   // we don't need to store the chunk
       break;
     default:
       if (frame->sframe) {
         // In case there was a reorder
         offsets[nchunk] = nchunk;
       }
       else {
         // Add the new offset
         offsets[nchunk] = cbytes;
       }
   }
 
   if (!frame->sframe && chunk_cbytes != 0 && cbytes_old >= chunk_cbytes) {
     offsets[nchunk] = old_offset;
     cbytes = old_offset;
   }
   // Re-compress the offsets again
   blosc2_context* cctx = blosc2_create_cctx(BLOSC2_CPARAMS_DEFAULTS);
   cctx->typesize = 8;
   void* off_chunk = malloc((size_t)off_nbytes + BLOSC_MAX_OVERHEAD);
   int32_t new_off_cbytes = blosc2_compress_ctx(cctx, offsets, off_nbytes,
                                                off_chunk, off_nbytes + BLOSC_MAX_OVERHEAD);
   blosc2_free_ctx(cctx);
 
   free(offsets);
   if (new_off_cbytes < 0) {
     free(off_chunk);
     return NULL;
   }
 
   int64_t new_cbytes = schunk->cbytes;
   int64_t new_frame_len;
   if (frame->sframe) {
     // The chunk is not stored in the frame
     new_frame_len = header_len + 0 + new_off_cbytes + frame->trailer_len;
   }
   else {
     new_frame_len = header_len + new_cbytes + new_off_cbytes + frame->trailer_len;
   }
 
   FILE* fp = NULL;
   if (frame->cframe != NULL) {
     uint8_t* framep = frame->cframe;
     /* Make space for the new chunk and copy it */
     frame->cframe = framep = realloc(framep, (size_t)new_frame_len);
     if (framep == NULL) {
       BLOSC_TRACE_ERROR("Cannot realloc space for the frame.");
       return NULL;
     }
     /* Copy the chunk */
     memcpy(framep + header_len + cbytes, chunk, (size_t)chunk_cbytes);
     /* Copy the offsets */
     memcpy(framep + header_len + new_cbytes, off_chunk, (size_t)new_off_cbytes);
   } else {
     size_t wbytes;
     if (frame->sframe) {
       if (chunk_cbytes) {
         if (sframe_create_chunk(frame, chunk, nchunk, chunk_cbytes) == NULL) {
           BLOSC_TRACE_ERROR("Cannot write the full chunk.");
           return NULL;
         }
       }
       // Update the offsets chunk in the chunks frame
       fp = sframe_open_index(frame->urlpath, "rb+");
       fseek(fp, header_len + 0, SEEK_SET);
     }
     else {
       // Regular frame
       fp = fopen(frame->urlpath, "rb+");
       fseek(fp, header_len + cbytes, SEEK_SET);
       wbytes = fwrite(chunk, 1, (size_t)chunk_cbytes, fp);  // the new chunk
       if (wbytes != (size_t)chunk_cbytes) {
         BLOSC_TRACE_ERROR("Cannot write the full chunk to frame.");
         fclose(fp);
         return NULL;
       }
     }
     wbytes = fwrite(off_chunk, 1, (size_t)new_off_cbytes, fp);  // the new offsets
     fclose(fp);
     if (wbytes != (size_t)new_off_cbytes) {
       BLOSC_TRACE_ERROR("Cannot write the offsets to frame.");
       return NULL;
     }
     // Invalidate the cache for chunk offsets
     if (frame->coffsets != NULL) {
       free(frame->coffsets);
       frame->coffsets = NULL;
     }
   }
   free(chunk);  // chunk has always to be a copy when reaching here...
   free(off_chunk);
 
   frame->len = new_frame_len;
   rc = frame_update_header(frame, schunk, false);
   if (rc < 0) {
     return NULL;
   }
 
   rc = frame_update_trailer(frame, schunk);
   if (rc < 0) {
     return NULL;
   }
 
   return frame;
 }
@@ -2679,127 +2689,127 @@ void* frame_update_chunk(blosc2_frame_s* frame, int nchunk, void* chunk, blosc2_
 int frame_reorder_offsets(blosc2_frame_s* frame, const int* offsets_order, blosc2_schunk* schunk) {
   // Get header info
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t blocksize;
   int32_t chunksize;
   int32_t nchunks;
   int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes,
                             &blocksize, &chunksize,  &nchunks,
                             NULL, NULL, NULL, NULL, NULL);
   if (ret < 0) {
       BLOSC_TRACE_ERROR("Cannot get the header info for the frame.");
       return ret;
   }
 
   // Get the current offsets and add one more
   int32_t off_nbytes = nchunks * sizeof(int64_t);
   int64_t* offsets = (int64_t *) malloc((size_t)off_nbytes);
 
   int32_t coffsets_cbytes = 0;
-  uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, &coffsets_cbytes);
+  uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, nchunks, &coffsets_cbytes);
   if (coffsets == NULL) {
     BLOSC_TRACE_ERROR("Cannot get the offsets for the frame.");
     free(offsets);
     return BLOSC2_ERROR_DATA;
   }
 
   // Decompress offsets
   blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_context *dctx = blosc2_create_dctx(off_dparams);
   int32_t prev_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes,
                                               offsets, off_nbytes);
   blosc2_free_ctx(dctx);
   if (prev_nbytes < 0) {
     free(offsets);
     BLOSC_TRACE_ERROR("Cannot decompress the offsets chunk.");
     return prev_nbytes;
   }
 
   // Make a copy of the chunk offsets and reorder it
   int64_t *offsets_copy = malloc(prev_nbytes);
   memcpy(offsets_copy, offsets, prev_nbytes);
 
   for (int i = 0; i < nchunks; ++i) {
     offsets[i] = offsets_copy[offsets_order[i]];
   }
   free(offsets_copy);
 
   // Re-compress the offsets again
   blosc2_context* cctx = blosc2_create_cctx(BLOSC2_CPARAMS_DEFAULTS);
   cctx->typesize = sizeof(int64_t);
   void* off_chunk = malloc((size_t)off_nbytes + BLOSC_MAX_OVERHEAD);
   int32_t new_off_cbytes = blosc2_compress_ctx(cctx, offsets, off_nbytes,
                                                off_chunk, off_nbytes + BLOSC_MAX_OVERHEAD);
   blosc2_free_ctx(cctx);
 
   if (new_off_cbytes < 0) {
     free(offsets);
     free(off_chunk);
     return new_off_cbytes;
   }
   free(offsets);
   int64_t new_frame_len;
   if (frame->sframe) {
     // The chunks are not in the frame
     new_frame_len = header_len + 0 + new_off_cbytes + frame->trailer_len;
   }
   else {
     new_frame_len = header_len + cbytes + new_off_cbytes + frame->trailer_len;
   }
 
   if (frame->cframe != NULL) {
     uint8_t* framep = frame->cframe;
     /* Make space for the new chunk and copy it */
     frame->cframe = framep = realloc(framep, (size_t)new_frame_len);
     if (framep == NULL) {
       BLOSC_TRACE_ERROR("Cannot realloc space for the frame.");
       return BLOSC2_ERROR_MEMORY_ALLOC;
     }
     /* Copy the offsets */
     memcpy(framep + header_len + cbytes, off_chunk, (size_t)new_off_cbytes);
   }
   else {
     FILE* fp = NULL;
     if (frame->sframe) {
       // Update the offsets chunk in the chunks frame
       fp = sframe_open_index(frame->urlpath, "rb+");
       fseek(fp, header_len + 0, SEEK_SET);
     }
     else {
       // Regular frame
       fp = fopen(frame->urlpath, "rb+");
       fseek(fp, header_len + cbytes, SEEK_SET);
     }
     size_t wbytes = fwrite(off_chunk, 1, (size_t)new_off_cbytes, fp);  // the new offsets
     fclose(fp);
     if (wbytes != (size_t)new_off_cbytes) {
       BLOSC_TRACE_ERROR("Cannot write the offsets to frame.");
       return BLOSC2_ERROR_FILE_WRITE;
     }
   }
 
   // Invalidate the cache for chunk offsets
   if (frame->coffsets != NULL) {
     free(frame->coffsets);
     frame->coffsets = NULL;
   }
   free(off_chunk);
 
   frame->len = new_frame_len;
   int rc = frame_update_header(frame, schunk, false);
   if (rc < 0) {
     return rc;
   }
 
   rc = frame_update_trailer(frame, schunk);
   if (rc < 0) {
     return rc;
   }
 
   return 0;
 }
 
 
 /* Decompress and return a chunk that is part of a frame. */
