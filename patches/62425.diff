commit 6a42197331c23ed7e09d040f6deaa7c352c02cca
Author: Frank Tang <ftang@chromium.org>
Date:   Mon Sep 18 14:41:18 2023 -0700

    ICU-22510 Fix Calendar::set to check the field is valid.

diff --git a/icu4c/source/i18n/calendar.cpp b/icu4c/source/i18n/calendar.cpp
index 47f1d7fce87..deb878ed243 100644
--- a/icu4c/source/i18n/calendar.cpp
+++ b/icu4c/source/i18n/calendar.cpp
@@ -1192,11 +1192,18 @@ Calendar::setTimeInMillis( double millis, UErrorCode& status ) {
 int32_t
 Calendar::get(UCalendarDateFields field, UErrorCode& status) const
 {
+    if (U_FAILURE(status)) {
+        return 0;
+    }
+    if (field < 0 || field >= UCAL_FIELD_COUNT) {
+        status = U_ILLEGAL_ARGUMENT_ERROR;
+        return 0;
+    }
     // field values are only computed when actually requested; for more on when computation
     // of various things happens, see the "data flow in Calendar" description at the top
     // of this file
     if (U_SUCCESS(status)) ((Calendar*)this)->complete(status); // Cast away const
     return U_SUCCESS(status) ? fFields[field] : 0;
 }
 
 // -------------------------------------
@@ -1204,18 +1211,21 @@ Calendar::get(UCalendarDateFields field, UErrorCode& status) const
 void
 Calendar::set(UCalendarDateFields field, int32_t value)
 {
+    if (field < 0 || field >= UCAL_FIELD_COUNT) {
+        return;
+    }
     if (fAreFieldsVirtuallySet) {
         UErrorCode ec = U_ZERO_ERROR;
         computeFields(ec);
     }
     fFields[field]     = value;
     /* Ensure that the fNextStamp value doesn't go pass max value for int32_t */
     if (fNextStamp == STAMP_MAX) {
         recalculateStamp();
     }
     fStamp[field]     = fNextStamp++;
     fIsSet[field]     = true; // Remove later
     fIsTimeSet = fAreFieldsSet = fAreFieldsVirtuallySet = false;
 }
 
 // -------------------------------------
@@ -1285,23 +1295,26 @@ Calendar::clear()
 void
 Calendar::clear(UCalendarDateFields field)
 {
+    if (field < 0 || field >= UCAL_FIELD_COUNT) {
+        return;
+    }
     if (fAreFieldsVirtuallySet) {
         UErrorCode ec = U_ZERO_ERROR;
         computeFields(ec);
     }
     fFields[field]         = 0;
     fStamp[field]         = kUnset;
     if (field == UCAL_MONTH) {
         fFields[UCAL_ORDINAL_MONTH]         = 0;
         fStamp[UCAL_ORDINAL_MONTH]         = kUnset;
         fIsSet[UCAL_ORDINAL_MONTH]         = false; // Remove later
     }
     if (field == UCAL_ORDINAL_MONTH) {
         fFields[UCAL_MONTH]         = 0;
         fStamp[UCAL_MONTH]         = kUnset;
         fIsSet[UCAL_MONTH]         = false; // Remove later
     }
     fIsTimeSet = fAreFieldsSet = fAreAllFieldsSet = fAreFieldsVirtuallySet = false;
 }
 
 // -------------------------------------
@@ -1309,6 +1322,9 @@ Calendar::clear(UCalendarDateFields field)
 UBool
 Calendar::isSet(UCalendarDateFields field) const
 {
+    if (field < 0 || field >= UCAL_FIELD_COUNT) {
+        return false;
+    }
     return fAreFieldsVirtuallySet || (fStamp[field] != kUnset);
 }
 
@@ -1359,40 +1375,44 @@ Calendar::complete(UErrorCode& status)
 /**
 * Adjust the specified field so that it is within
 * the allowable range for the date to which this calendar is set.
 * For example, in a Gregorian calendar pinning the {@link #DAY_OF_MONTH DAY_OF_MONTH}
 * field for a calendar set to April 31 would cause it to be set
 * to April 30.
 * <p>
 * <b>Subclassing:</b>
 * <br>
 * This utility method is intended for use by subclasses that need to implement
 * their own overrides of {@link #roll roll} and {@link #add add}.
 * <p>
 * <b>Note:</b>
 * <code>pinField</code> is implemented in terms of
 * {@link #getActualMinimum getActualMinimum}
 * and {@link #getActualMaximum getActualMaximum}.  If either of those methods uses
 * a slow, iterative algorithm for a particular field, it would be
 * unwise to attempt to call <code>pinField</code> for that field.  If you
 * really do need to do so, you should override this method to do
 * something more efficient for that field.
 * <p>
 * @param field The calendar field whose value should be pinned.
 *
 * @see #getActualMinimum
 * @see #getActualMaximum
 * @stable ICU 2.0
 */
 void Calendar::pinField(UCalendarDateFields field, UErrorCode& status) {
     if (U_FAILURE(status)) {
        return;
     }
+    if (field < 0 || field >= UCAL_FIELD_COUNT) {
+       status = U_ILLEGAL_ARGUMENT_ERROR;
+       return;
+    }
     int32_t max = getActualMaximum(field, status);
     int32_t min = getActualMinimum(field, status);
 
     if (fFields[field] > max) {
         set(field, max);
     } else if (fFields[field] < min) {
         set(field, min);
     }
 }
@@ -1715,340 +1735,344 @@ void Calendar::roll(EDateFields field, int32_t amount, UErrorCode& status)
 void Calendar::roll(UCalendarDateFields field, int32_t amount, UErrorCode& status) UPRV_NO_SANITIZE_UNDEFINED {
     if (amount == 0) {
         return; // Nothing to do
     }
 
     complete(status);
 
     if(U_FAILURE(status)) {
         return;
     }
+    if (field < 0 || field >= UCAL_FIELD_COUNT) {
+       status = U_ILLEGAL_ARGUMENT_ERROR;
+       return;
+    }
     switch (field) {
     case UCAL_DAY_OF_MONTH:
     case UCAL_AM_PM:
     case UCAL_MINUTE:
     case UCAL_SECOND:
     case UCAL_MILLISECOND:
     case UCAL_MILLISECONDS_IN_DAY:
     case UCAL_ERA:
         // These are the standard roll instructions.  These work for all
         // simple cases, that is, cases in which the limits are fixed, such
         // as the hour, the day of the month, and the era.
         {
             int32_t min = getActualMinimum(field,status);
             int32_t max = getActualMaximum(field,status);
             int32_t gap = max - min + 1;
 
             int32_t value = internalGet(field) + amount;
             value = (value - min) % gap;
             if (value < 0) {
                 value += gap;
             }
             value += min;
 
             set(field, value);
             return;
         }
 
     case UCAL_HOUR:
     case UCAL_HOUR_OF_DAY:
         // Rolling the hour is difficult on the ONSET and CEASE days of
         // daylight savings.  For example, if the change occurs at
         // 2 AM, we have the following progression:
         // ONSET: 12 Std -> 1 Std -> 3 Dst -> 4 Dst
         // CEASE: 12 Dst -> 1 Dst -> 1 Std -> 2 Std
         // To get around this problem we don't use fields; we manipulate
         // the time in millis directly.
         {
             // Assume min == 0 in calculations below
             double start = getTimeInMillis(status);
             int32_t oldHour = internalGet(field);
             int32_t max = getMaximum(field);
             int32_t newHour = (oldHour + amount) % (max + 1);
             if (newHour < 0) {
                 newHour += max + 1;
             }
             setTimeInMillis(start + kOneHour * (newHour - oldHour),status);
             return;
         }
 
     case UCAL_MONTH:
     case UCAL_ORDINAL_MONTH:
         // Rolling the month involves both pinning the final value
         // and adjusting the DAY_OF_MONTH if necessary.  We only adjust the
         // DAY_OF_MONTH if, after updating the MONTH field, it is illegal.
         // E.g., <jan31>.roll(MONTH, 1) -> <feb28> or <feb29>.
         {
             int32_t max = getActualMaximum(UCAL_MONTH, status);
             int32_t mon = (internalGet(UCAL_MONTH) + amount) % (max+1);
 
             if (mon < 0) {
                 mon += (max + 1);
             }
             set(UCAL_MONTH, mon);
 
             // Keep the day of month in range.  We don't want to spill over
             // into the next month; e.g., we don't want jan31 + 1 mo -> feb31 ->
             // mar3.
             pinField(UCAL_DAY_OF_MONTH,status);
             return;
         }
 
     case UCAL_YEAR:
     case UCAL_YEAR_WOY:
         {
             // * If era==0 and years go backwards in time, change sign of amount.
             // * Until we have new API per #9393, we temporarily hardcode knowledge of
             //   which calendars have era 0 years that go backwards.
             UBool era0WithYearsThatGoBackwards = false;
             int32_t era = get(UCAL_ERA, status);
             if (era == 0) {
                 const char * calType = getType();
                 if ( uprv_strcmp(calType,"gregorian")==0 || uprv_strcmp(calType,"roc")==0 || uprv_strcmp(calType,"coptic")==0 ) {
                     amount = -amount;
                     era0WithYearsThatGoBackwards = true;
                 }
             }
             int32_t newYear = internalGet(field) + amount;
             if (era > 0 || newYear >= 1) {
                 int32_t maxYear = getActualMaximum(field, status);
                 if (maxYear < 32768) {
                     // this era has real bounds, roll should wrap years
                     if (newYear < 1) {
                         newYear = maxYear - ((-newYear) % maxYear);
                     } else if (newYear > maxYear) {
                         newYear = ((newYear - 1) % maxYear) + 1;
                     }
                 // else era is unbounded, just pin low year instead of wrapping
                 } else if (newYear < 1) {
                     newYear = 1;
                 }
             // else we are in era 0 with newYear < 1;
             // calendars with years that go backwards must pin the year value at 0,
             // other calendars can have years < 0 in era 0
             } else if (era0WithYearsThatGoBackwards) {
                 newYear = 1;
             }
             set(field, newYear);
             pinField(UCAL_MONTH,status);
             pinField(UCAL_DAY_OF_MONTH,status);
             return;
         }
 
     case UCAL_EXTENDED_YEAR:
         // Rolling the year can involve pinning the DAY_OF_MONTH.
         set(field, internalGet(field) + amount);
         pinField(UCAL_MONTH,status);
         pinField(UCAL_DAY_OF_MONTH,status);
         return;
 
     case UCAL_WEEK_OF_MONTH:
         {
             // This is tricky, because during the roll we may have to shift
             // to a different day of the week.  For example:
 
             //    s  m  t  w  r  f  s
             //          1  2  3  4  5
             //    6  7  8  9 10 11 12
 
             // When rolling from the 6th or 7th back one week, we go to the
             // 1st (assuming that the first partial week counts).  The same
             // thing happens at the end of the month.
 
             // The other tricky thing is that we have to figure out whether
             // the first partial week actually counts or not, based on the
             // minimal first days in the week.  And we have to use the
             // correct first day of the week to delineate the week
             // boundaries.
 
             // Here's our algorithm.  First, we find the real boundaries of
             // the month.  Then we discard the first partial week if it
             // doesn't count in this locale.  Then we fill in the ends with
             // phantom days, so that the first partial week and the last
             // partial week are full weeks.  We then have a nice square
             // block of weeks.  We do the usual rolling within this block,
             // as is done elsewhere in this method.  If we wind up on one of
             // the phantom days that we added, we recognize this and pin to
             // the first or the last day of the month.  Easy, eh?
 
             // Normalize the DAY_OF_WEEK so that 0 is the first day of the week
             // in this locale.  We have dow in 0..6.
             int32_t dow = internalGet(UCAL_DAY_OF_WEEK) - getFirstDayOfWeek();
             if (dow < 0) dow += 7;
 
             // Find the day of the week (normalized for locale) for the first
             // of the month.
             int32_t fdm = (dow - internalGet(UCAL_DAY_OF_MONTH) + 1) % 7;
             if (fdm < 0) fdm += 7;
 
             // Get the first day of the first full week of the month,
             // including phantom days, if any.  Figure out if the first week
             // counts or not; if it counts, then fill in phantom days.  If
             // not, advance to the first real full week (skip the partial week).
             int32_t start;
             if ((7 - fdm) < getMinimalDaysInFirstWeek())
                 start = 8 - fdm; // Skip the first partial week
             else
                 start = 1 - fdm; // This may be zero or negative
 
             // Get the day of the week (normalized for locale) for the last
             // day of the month.
             int32_t monthLen = getActualMaximum(UCAL_DAY_OF_MONTH, status);
             int32_t ldm = (monthLen - internalGet(UCAL_DAY_OF_MONTH) + dow) % 7;
             // We know monthLen >= DAY_OF_MONTH so we skip the += 7 step here.
 
             // Get the limit day for the blocked-off rectangular month; that
             // is, the day which is one past the last day of the month,
             // after the month has already been filled in with phantom days
             // to fill out the last week.  This day has a normalized DOW of 0.
             int32_t limit = monthLen + 7 - ldm;
 
             // Now roll between start and (limit - 1).
             int32_t gap = limit - start;
             int32_t day_of_month = (internalGet(UCAL_DAY_OF_MONTH) + amount*7 -
                 start) % gap;
             if (day_of_month < 0) day_of_month += gap;
             day_of_month += start;
 
             // Finally, pin to the real start and end of the month.
             if (day_of_month < 1) day_of_month = 1;
             if (day_of_month > monthLen) day_of_month = monthLen;
 
             // Set the DAY_OF_MONTH.  We rely on the fact that this field
             // takes precedence over everything else (since all other fields
             // are also set at this point).  If this fact changes (if the
             // disambiguation algorithm changes) then we will have to unset
             // the appropriate fields here so that DAY_OF_MONTH is attended
             // to.
             set(UCAL_DAY_OF_MONTH, day_of_month);
             return;
         }
     case UCAL_WEEK_OF_YEAR:
         {
             // This follows the outline of WEEK_OF_MONTH, except it applies
             // to the whole year.  Please see the comment for WEEK_OF_MONTH
             // for general notes.
 
             // Normalize the DAY_OF_WEEK so that 0 is the first day of the week
             // in this locale.  We have dow in 0..6.
             int32_t dow = internalGet(UCAL_DAY_OF_WEEK) - getFirstDayOfWeek();
             if (dow < 0) dow += 7;
 
             // Find the day of the week (normalized for locale) for the first
             // of the year.
             int32_t fdy = (dow - internalGet(UCAL_DAY_OF_YEAR) + 1) % 7;
             if (fdy < 0) fdy += 7;
 
             // Get the first day of the first full week of the year,
             // including phantom days, if any.  Figure out if the first week
             // counts or not; if it counts, then fill in phantom days.  If
             // not, advance to the first real full week (skip the partial week).
             int32_t start;
             if ((7 - fdy) < getMinimalDaysInFirstWeek())
                 start = 8 - fdy; // Skip the first partial week
             else
                 start = 1 - fdy; // This may be zero or negative
 
             // Get the day of the week (normalized for locale) for the last
             // day of the year.
             int32_t yearLen = getActualMaximum(UCAL_DAY_OF_YEAR,status);
             int32_t ldy = (yearLen - internalGet(UCAL_DAY_OF_YEAR) + dow) % 7;
             // We know yearLen >= DAY_OF_YEAR so we skip the += 7 step here.
 
             // Get the limit day for the blocked-off rectangular year; that
             // is, the day which is one past the last day of the year,
             // after the year has already been filled in with phantom days
             // to fill out the last week.  This day has a normalized DOW of 0.
             int32_t limit = yearLen + 7 - ldy;
 
             // Now roll between start and (limit - 1).
             int32_t gap = limit - start;
             int32_t day_of_year = (internalGet(UCAL_DAY_OF_YEAR) + amount*7 -
                 start) % gap;
             if (day_of_year < 0) day_of_year += gap;
             day_of_year += start;
 
             // Finally, pin to the real start and end of the month.
             if (day_of_year < 1) day_of_year = 1;
             if (day_of_year > yearLen) day_of_year = yearLen;
 
             // Make sure that the year and day of year are attended to by
             // clearing other fields which would normally take precedence.
             // If the disambiguation algorithm is changed, this section will
             // have to be updated as well.
             set(UCAL_DAY_OF_YEAR, day_of_year);
             clear(UCAL_MONTH);
             clear(UCAL_ORDINAL_MONTH);
             return;
         }
     case UCAL_DAY_OF_YEAR:
         {
             // Roll the day of year using millis.  Compute the millis for
             // the start of the year, and get the length of the year.
             double delta = amount * kOneDay; // Scale up from days to millis
             double min2 = internalGet(UCAL_DAY_OF_YEAR)-1;
             min2 *= kOneDay;
             min2 = internalGetTime() - min2;
 
             //      double min2 = internalGetTime() - (internalGet(UCAL_DAY_OF_YEAR) - 1.0) * kOneDay;
             double newtime;
 
             double yearLength = getActualMaximum(UCAL_DAY_OF_YEAR,status);
             double oneYear = yearLength;
             oneYear *= kOneDay;
             newtime = uprv_fmod((internalGetTime() + delta - min2), oneYear);
             if (newtime < 0) newtime += oneYear;
             setTimeInMillis(newtime + min2, status);
             return;
         }
     case UCAL_DAY_OF_WEEK:
     case UCAL_DOW_LOCAL:
         {
             // Roll the day of week using millis.  Compute the millis for
             // the start of the week, using the first day of week setting.
             // Restrict the millis to [start, start+7days).
             double delta = amount * kOneDay; // Scale up from days to millis
             // Compute the number of days before the current day in this
             // week.  This will be a value 0..6.
             int32_t leadDays = internalGet(field);
             leadDays -= (field == UCAL_DAY_OF_WEEK) ? getFirstDayOfWeek() : 1;
             if (leadDays < 0) leadDays += 7;
             double min2 = internalGetTime() - leadDays * kOneDay;
             double newtime = uprv_fmod((internalGetTime() + delta - min2), kOneWeek);
             if (newtime < 0) newtime += kOneWeek;
             setTimeInMillis(newtime + min2, status);
             return;
         }
     case UCAL_DAY_OF_WEEK_IN_MONTH:
         {
             // Roll the day of week in the month using millis.  Determine
             // the first day of the week in the month, and then the last,
             // and then roll within that range.
             double delta = amount * kOneWeek; // Scale up from weeks to millis
             // Find the number of same days of the week before this one
             // in this month.
             int32_t preWeeks = (internalGet(UCAL_DAY_OF_MONTH) - 1) / 7;
             // Find the number of same days of the week after this one
             // in this month.
             int32_t postWeeks = (getActualMaximum(UCAL_DAY_OF_MONTH,status) -
                 internalGet(UCAL_DAY_OF_MONTH)) / 7;
             // From these compute the min and gap millis for rolling.
             double min2 = internalGetTime() - preWeeks * kOneWeek;
             double gap2 = kOneWeek * (preWeeks + postWeeks + 1); // Must add 1!
             // Roll within this range
             double newtime = uprv_fmod((internalGetTime() + delta - min2), gap2);
             if (newtime < 0) newtime += gap2;
             setTimeInMillis(newtime + min2, status);
             return;
         }
     case UCAL_JULIAN_DAY:
         set(field, internalGet(field) + amount);
         return;
     default:
         // Other fields cannot be rolled by this method
 #if defined (U_DEBUG_CAL)
         fprintf(stderr, "%s:%d: ILLEGAL ARG because of roll on non-rollable field %s\n",
             __FILE__, __LINE__,fldName(field));
 #endif
         status = U_ILLEGAL_ARGUMENT_ERROR;
     }
 }
@@ -2061,187 +2085,191 @@ void Calendar::add(EDateFields field, int32_t amount, UErrorCode& status)
 // -------------------------------------
 void Calendar::add(UCalendarDateFields field, int32_t amount, UErrorCode& status)
 {
     if (U_FAILURE(status)) {
        return;
     }
+    if (field < 0 || field >= UCAL_FIELD_COUNT) {
+        status = U_ILLEGAL_ARGUMENT_ERROR;
+        return;
+    }
     if (amount == 0) {
         return;   // Do nothing!
     }
 
     // We handle most fields in the same way.  The algorithm is to add
     // a computed amount of millis to the current millis.  The only
     // wrinkle is with DST (and/or a change to the zone's UTC offset, which
     // we'll include with DST) -- for some fields, like the DAY_OF_MONTH,
     // we don't want the wall time to shift due to changes in DST.  If the
     // result of the add operation is to move from DST to Standard, or
     // vice versa, we need to adjust by an hour forward or back,
     // respectively.  For such fields we set keepWallTimeInvariant to true.
 
     // We only adjust the DST for fields larger than an hour.  For
     // fields smaller than an hour, we cannot adjust for DST without
     // causing problems.  for instance, if you add one hour to April 5,
     // 1998, 1:00 AM, in PST, the time becomes "2:00 AM PDT" (an
     // illegal value), but then the adjustment sees the change and
     // compensates by subtracting an hour.  As a result the time
     // doesn't advance at all.
 
     // For some fields larger than a day, such as a UCAL_MONTH, we pin the
     // UCAL_DAY_OF_MONTH.  This allows <March 31>.add(UCAL_MONTH, 1) to be
     // <April 30>, rather than <April 31> => <May 1>.
 
     double delta = amount; // delta in ms
     UBool keepWallTimeInvariant = true;
 
     switch (field) {
     case UCAL_ERA:
         set(field, get(field, status) + amount);
         pinField(UCAL_ERA, status);
         return;
 
     case UCAL_YEAR:
     case UCAL_YEAR_WOY:
       {
         // * If era=0 and years go backwards in time, change sign of amount.
         // * Until we have new API per #9393, we temporarily hardcode knowledge of
         //   which calendars have era 0 years that go backwards.
         // * Note that for UCAL_YEAR (but not UCAL_YEAR_WOY) we could instead handle
         //   this by applying the amount to the UCAL_EXTENDED_YEAR field; but since
         //   we would still need to handle UCAL_YEAR_WOY as below, might as well
         //   also handle UCAL_YEAR the same way.
         int32_t era = get(UCAL_ERA, status);
         if (era == 0) {
           const char * calType = getType();
           if ( uprv_strcmp(calType,"gregorian")==0 || uprv_strcmp(calType,"roc")==0 || uprv_strcmp(calType,"coptic")==0 ) {
             amount = -amount;
           }
         }
       }
       // Fall through into normal handling
       U_FALLTHROUGH;
     case UCAL_EXTENDED_YEAR:
     case UCAL_MONTH:
     case UCAL_ORDINAL_MONTH:
       {
         UBool oldLenient = isLenient();
         setLenient(true);
         set(field, get(field, status) + amount);
         pinField(UCAL_DAY_OF_MONTH, status);
         if(oldLenient==false) {
           complete(status); /* force recalculate */
           setLenient(oldLenient);
         }
       }
       return;
 
     case UCAL_WEEK_OF_YEAR:
     case UCAL_WEEK_OF_MONTH:
     case UCAL_DAY_OF_WEEK_IN_MONTH:
         delta *= kOneWeek;
         break;
 
     case UCAL_AM_PM:
         delta *= 12 * kOneHour;
         break;
 
     case UCAL_DAY_OF_MONTH:
     case UCAL_DAY_OF_YEAR:
     case UCAL_DAY_OF_WEEK:
     case UCAL_DOW_LOCAL:
     case UCAL_JULIAN_DAY:
         delta *= kOneDay;
         break;
 
     case UCAL_HOUR_OF_DAY:
     case UCAL_HOUR:
         delta *= kOneHour;
         keepWallTimeInvariant = false;
         break;
 
     case UCAL_MINUTE:
         delta *= kOneMinute;
         keepWallTimeInvariant = false;
         break;
 
     case UCAL_SECOND:
         delta *= kOneSecond;
         keepWallTimeInvariant = false;
         break;
 
     case UCAL_MILLISECOND:
     case UCAL_MILLISECONDS_IN_DAY:
         keepWallTimeInvariant = false;
         break;
 
     default:
 #if defined (U_DEBUG_CAL)
         fprintf(stderr, "%s:%d: ILLEGAL ARG because field %s not addable",
             __FILE__, __LINE__, fldName(field));
 #endif
         status = U_ILLEGAL_ARGUMENT_ERROR;
         return;
         //  throw new IllegalArgumentException("Calendar.add(" + fieldName(field) +
         //                                     ") not supported");
     }
 
     // In order to keep the wall time invariant (for fields where this is
     // appropriate), check the combined DST & ZONE offset before and
     // after the add() operation. If it changes, then adjust the millis
     // to compensate.
     int32_t prevOffset = 0;
     int32_t prevWallTime = 0;
     if (keepWallTimeInvariant) {
         prevOffset = get(UCAL_DST_OFFSET, status) + get(UCAL_ZONE_OFFSET, status);
         prevWallTime = get(UCAL_MILLISECONDS_IN_DAY, status);
     }
 
     setTimeInMillis(getTimeInMillis(status) + delta, status);
 
     if (keepWallTimeInvariant) {
         int32_t newWallTime = get(UCAL_MILLISECONDS_IN_DAY, status);
         if (newWallTime != prevWallTime) {
             // There is at least one zone transition between the base
             // time and the result time. As the result, wall time has
             // changed.
             UDate t = internalGetTime();
             int32_t newOffset = get(UCAL_DST_OFFSET, status) + get(UCAL_ZONE_OFFSET, status);
             if (newOffset != prevOffset) {
                 // When the difference of the previous UTC offset and
                 // the new UTC offset exceeds 1 full day, we do not want
                 // to roll over/back the date. For now, this only happens
                 // in Samoa (Pacific/Apia) on Dec 30, 2011. See ticket:9452.
                 int32_t adjAmount = prevOffset - newOffset;
                 adjAmount = adjAmount >= 0 ? adjAmount % (int32_t)kOneDay : -(-adjAmount % (int32_t)kOneDay);
                 if (adjAmount != 0) {
                     setTimeInMillis(t + adjAmount, status);
                     newWallTime = get(UCAL_MILLISECONDS_IN_DAY, status);
                 }
                 if (newWallTime != prevWallTime) {
                     // The result wall time or adjusted wall time was shifted because
                     // the target wall time does not exist on the result date.
                     switch (fSkippedWallTime) {
                     case UCAL_WALLTIME_FIRST:
                         if (adjAmount > 0) {
                             setTimeInMillis(t, status);
                         }
                         break;
                     case UCAL_WALLTIME_LAST:
                         if (adjAmount < 0) {
                             setTimeInMillis(t, status);
                         }
                         break;
                     case UCAL_WALLTIME_NEXT_VALID:
                         UDate tmpT = adjAmount > 0 ? internalGetTime() : t;
                         UDate immediatePrevTrans;
                         UBool hasTransition = getImmediatePreviousZoneTransition(tmpT, &immediatePrevTrans, status);
                         if (U_SUCCESS(status) && hasTransition) {
                             setTimeInMillis(immediatePrevTrans, status);
                         }
                         break;
                     }
                 }
             }
         }
     }
 }
 
 // -------------------------------------
@@ -2250,103 +2278,109 @@ int32_t Calendar::fieldDifference(UDate when, EDateFields field, UErrorCode& sta
 }
 
 int32_t Calendar::fieldDifference(UDate targetMs, UCalendarDateFields field, UErrorCode& ec) {
-    if (U_FAILURE(ec)) return 0;
+    if (U_FAILURE(ec)) {
+        return 0;
+    }
+    if (field < 0 || field >= UCAL_FIELD_COUNT) {
+        ec = U_ILLEGAL_ARGUMENT_ERROR;
+        return 0;
+    }
     int32_t min = 0;
     double startMs = getTimeInMillis(ec);
     // Always add from the start millis.  This accommodates
     // operations like adding years from February 29, 2000 up to
     // February 29, 2004.  If 1, 1, 1, 1 is added to the year
     // field, the DOM gets pinned to 28 and stays there, giving an
     // incorrect DOM difference of 1.  We have to add 1, reset, 2,
     // reset, 3, reset, 4.
     if (startMs < targetMs) {
         int32_t max = 1;
         // Find a value that is too large
         while (U_SUCCESS(ec)) {
             setTimeInMillis(startMs, ec);
             add(field, max, ec);
             double ms = getTimeInMillis(ec);
             if (ms == targetMs) {
                 return max;
             } else if (ms > targetMs) {
                 break;
             } else if (max < INT32_MAX) {
                 min = max;
                 max <<= 1;
                 if (max < 0) {
                     max = INT32_MAX;
                 }
             } else {
                 // Field difference too large to fit into int32_t
 #if defined (U_DEBUG_CAL)
                 fprintf(stderr, "%s:%d: ILLEGAL ARG because field %s's max too large for int32_t\n",
                     __FILE__, __LINE__, fldName(field));
 #endif
                 ec = U_ILLEGAL_ARGUMENT_ERROR;
             }
         }
         // Do a binary search
         while ((max - min) > 1 && U_SUCCESS(ec)) {
             int32_t t = min + (max - min)/2; // make sure intermediate values don't exceed INT32_MAX
             setTimeInMillis(startMs, ec);
             add(field, t, ec);
             double ms = getTimeInMillis(ec);
             if (ms == targetMs) {
                 return t;
             } else if (ms > targetMs) {
                 max = t;
             } else {
                 min = t;
             }
         }
     } else if (startMs > targetMs) {
         int32_t max = -1;
         // Find a value that is too small
         while (U_SUCCESS(ec)) {
             setTimeInMillis(startMs, ec);
             add(field, max, ec);
             double ms = getTimeInMillis(ec);
             if (ms == targetMs) {
                 return max;
             } else if (ms < targetMs) {
                 break;
             } else {
                 min = max;
                 max = (int32_t)((uint32_t)(max) << 1);
                 if (max == 0) {
                     // Field difference too large to fit into int32_t
 #if defined (U_DEBUG_CAL)
                     fprintf(stderr, "%s:%d: ILLEGAL ARG because field %s's max too large for int32_t\n",
                         __FILE__, __LINE__, fldName(field));
 #endif
                     ec = U_ILLEGAL_ARGUMENT_ERROR;
                 }
             }
         }
         // Do a binary search
         while ((min - max) > 1 && U_SUCCESS(ec)) {
             int32_t t = min + (max - min)/2; // make sure intermediate values don't exceed INT32_MAX
             setTimeInMillis(startMs, ec);
             add(field, t, ec);
             double ms = getTimeInMillis(ec);
             if (ms == targetMs) {
                 return t;
             } else if (ms < targetMs) {
                 max = t;
             } else {
                 min = t;
             }
         }
     }
     // Set calendar to end point
     setTimeInMillis(startMs, ec);
     add(field, min, ec);
 
     /* Test for buffer overflows */
     if(U_FAILURE(ec)) {
         return 0;
     }
     return min;
 }
 
 // -------------------------------------
@@ -2355,14 +2389,16 @@ void
 Calendar::adoptTimeZone(TimeZone* zone)
 {
     // Do nothing if passed-in zone is nullptr
-    if (zone == nullptr) return;
+    if (zone == nullptr) {
+        return;
+    }
 
     // fZone should always be non-null
     delete fZone;
     fZone = zone;
 
     // if the zone changes, we need to recompute the time fields
     fAreFieldsSet = false;
 }
 
 // -------------------------------------
@@ -2706,48 +2742,52 @@ int32_t
 Calendar::getActualMinimum(UCalendarDateFields field, UErrorCode& status) const
 {
     if (U_FAILURE(status)) {
        return 0;
     }
+    if (field < 0 || field >= UCAL_FIELD_COUNT) {
+        status = U_ILLEGAL_ARGUMENT_ERROR;
+        return 0;
+    }
     int32_t fieldValue = getGreatestMinimum(field);
     int32_t endValue = getMinimum(field);
 
     // if we know that the minimum value is always the same, just return it
     if (fieldValue == endValue) {
         return fieldValue;
     }
 
     // clone the calendar so we don't mess with the real one, and set it to
     // accept anything for the field values
     Calendar *work = this->clone();
     if (work == nullptr) {
         status = U_MEMORY_ALLOCATION_ERROR;
         return 0;
     }
     work->setLenient(true);
 
     // now try each value from getLeastMaximum() to getMaximum() one by one until
     // we get a value that normalizes to another value.  The last value that
     // normalizes to itself is the actual minimum for the current date
     int32_t result = fieldValue;
 
     do {
         work->set(field, fieldValue);
         if (work->get(field, status) != fieldValue) {
             break;
         }
         else {
             result = fieldValue;
             fieldValue--;
         }
     } while (fieldValue >= endValue);
 
     delete work;
 
     /* Test for buffer overflows */
     if(U_FAILURE(status)) {
         return 0;
     }
     return result;
 }
 
 // -------------------------------------
@@ -2783,8 +2823,10 @@ const char*
 Calendar::getTemporalMonthCode(UErrorCode& status) const
 {
     int32_t month = get(UCAL_MONTH, status);
-    if (U_FAILURE(status)) return nullptr;
+    if (U_FAILURE(status)) {
+        return nullptr;
+    }
     U_ASSERT(month < 12);
     U_ASSERT(internalGet(UCAL_IS_LEAP_MONTH) == 0);
     return gTemporalMonthCodes[month];
 }
@@ -2792,26 +2834,28 @@ Calendar::getTemporalMonthCode(UErrorCode& status) const
 void
 Calendar::setTemporalMonthCode(const char* code, UErrorCode& status )
 {
-    if (U_FAILURE(status)) return;
+    if (U_FAILURE(status)) {
+        return;
+    }
     int32_t len = static_cast<int32_t>(uprv_strlen(code));
     if (len == 3 && code[0] == 'M') {
         for (int m = 0; gTemporalMonthCodes[m] != nullptr; m++) {
             if (uprv_strcmp(code, gTemporalMonthCodes[m]) == 0) {
                 set(UCAL_MONTH, m);
                 set(UCAL_IS_LEAP_MONTH, 0);
                 return;
             }
         }
     }
     status = U_ILLEGAL_ARGUMENT_ERROR;
 }
 
 // -------------------------------------
 
 /**
 * Ensure that each field is within its valid range by calling {@link
 * #validateField(int)} on each field that has been set.  This method
 * should only be called if this calendar is not lenient.
 * @see #isLenient
 * @see #validateField(int)
 */
@@ -2829,62 +2873,70 @@ void Calendar::validateFields(UErrorCode &status) {
 /**
 * Validate a single field of this calendar.  Subclasses should
 * override this method to validate any calendar-specific fields.
 * Generic fields can be handled by
 * <code>Calendar.validateField()</code>.
 * @see #validateField(int, int, int)
 */
 void Calendar::validateField(UCalendarDateFields field, UErrorCode &status) {
     if (U_FAILURE(status)) {
        return;
     }
+    if (field < 0 || field >= UCAL_FIELD_COUNT) {
+        status = U_ILLEGAL_ARGUMENT_ERROR;
+        return;
+    }
     int32_t y;
     switch (field) {
     case UCAL_DAY_OF_MONTH:
         y = handleGetExtendedYear();
         validateField(field, 1, handleGetMonthLength(y, internalGetMonth()), status);
         break;
     case UCAL_DAY_OF_YEAR:
         y = handleGetExtendedYear();
         validateField(field, 1, handleGetYearLength(y), status);
         break;
     case UCAL_DAY_OF_WEEK_IN_MONTH:
         if (internalGet(field) == 0) {
 #if defined (U_DEBUG_CAL)
             fprintf(stderr, "%s:%d: ILLEGAL ARG because DOW in month cannot be 0\n",
                 __FILE__, __LINE__);
 #endif
             status = U_ILLEGAL_ARGUMENT_ERROR; // "DAY_OF_WEEK_IN_MONTH cannot be zero"
             return;
         }
         validateField(field, getMinimum(field), getMaximum(field), status);
         break;
     default:
         validateField(field, getMinimum(field), getMaximum(field), status);
         break;
     }
 }
 
 /**
 * Validate a single field of this calendar given its minimum and
 * maximum allowed value.  If the field is out of range, throw a
 * descriptive <code>IllegalArgumentException</code>.  Subclasses may
 * use this method in their implementation of {@link
 * #validateField(int)}.
 */
 void Calendar::validateField(UCalendarDateFields field, int32_t min, int32_t max, UErrorCode& status)
 {
     if (U_FAILURE(status)) {
        return;
     }
+    if (field < 0 || field >= UCAL_FIELD_COUNT) {
+        status = U_ILLEGAL_ARGUMENT_ERROR;
+        return;
+    }
     int32_t value = fFields[field];
     if (value < min || value > max) {
 #if defined (U_DEBUG_CAL)
         fprintf(stderr, "%s:%d: ILLEGAL ARG because of field %s out of range %d..%d  at %d\n",
             __FILE__, __LINE__,fldName(field),min,max,value);
 #endif
         status = U_ILLEGAL_ARGUMENT_ERROR;
         return;
     }
 }
 
 // -------------------------
@@ -3637,135 +3689,147 @@ int32_t
 Calendar::getActualMaximum(UCalendarDateFields field, UErrorCode& status) const
 {
     if (U_FAILURE(status)) {
        return 0;
     }
+    if (field < 0 || field >= UCAL_FIELD_COUNT) {
+        status = U_ILLEGAL_ARGUMENT_ERROR;
+        return 0;
+    }
     int32_t result;
     switch (field) {
     case UCAL_DATE:
         {
-            if(U_FAILURE(status)) return 0;
             Calendar *cal = clone();
-            if(!cal) { status = U_MEMORY_ALLOCATION_ERROR; return 0; }
+            if(!cal) {
+                status = U_MEMORY_ALLOCATION_ERROR;
+                return 0;
+            }
             cal->setLenient(true);
             cal->prepareGetActual(field,false,status);
             result = handleGetMonthLength(cal->get(UCAL_EXTENDED_YEAR, status), cal->get(UCAL_MONTH, status));
             delete cal;
         }
         break;
 
     case UCAL_DAY_OF_YEAR:
         {
-            if(U_FAILURE(status)) return 0;
             Calendar *cal = clone();
-            if(!cal) { status = U_MEMORY_ALLOCATION_ERROR; return 0; }
+            if(!cal) {
+                status = U_MEMORY_ALLOCATION_ERROR;
+                return 0;
+            }
             cal->setLenient(true);
             cal->prepareGetActual(field,false,status);
             result = handleGetYearLength(cal->get(UCAL_EXTENDED_YEAR, status));
             delete cal;
         }
         break;
 
     case UCAL_DAY_OF_WEEK:
     case UCAL_AM_PM:
     case UCAL_HOUR:
     case UCAL_HOUR_OF_DAY:
     case UCAL_MINUTE:
     case UCAL_SECOND:
     case UCAL_MILLISECOND:
     case UCAL_ZONE_OFFSET:
     case UCAL_DST_OFFSET:
     case UCAL_DOW_LOCAL:
     case UCAL_JULIAN_DAY:
     case UCAL_MILLISECONDS_IN_DAY:
         // These fields all have fixed minima/maxima
         result = getMaximum(field);
         break;
 
     case UCAL_ORDINAL_MONTH:
         result = inTemporalLeapYear(status) ? getMaximum(UCAL_ORDINAL_MONTH) : getLeastMaximum(UCAL_ORDINAL_MONTH);
         break;
 
     default:
         // For all other fields, do it the hard way....
         result = getActualHelper(field, getLeastMaximum(field), getMaximum(field),status);
         break;
     }
     return result;
 }
 
 
 /**
 * Prepare this calendar for computing the actual minimum or maximum.
 * This method modifies this calendar's fields; it is called on a
 * temporary calendar.
 *
 * <p>Rationale: The semantics of getActualXxx() is to return the
 * maximum or minimum value that the given field can take, taking into
 * account other relevant fields.  In general these other fields are
 * larger fields.  For example, when computing the actual maximum
 * DATE, the current value of DATE itself is ignored,
 * as is the value of any field smaller.
 *
 * <p>The time fields all have fixed minima and maxima, so we don't
 * need to worry about them.  This also lets us set the
 * MILLISECONDS_IN_DAY to zero to erase any effects the time fields
 * might have when computing date fields.
 *
 * <p>DAY_OF_WEEK is adjusted specially for the WEEK_OF_MONTH and
 * WEEK_OF_YEAR fields to ensure that they are computed correctly.
 * @internal
 */
 void Calendar::prepareGetActual(UCalendarDateFields field, UBool isMinimum, UErrorCode &status)
 {
     if (U_FAILURE(status)) {
        return;
     }
+    if (field < 0 || field >= UCAL_FIELD_COUNT) {
+        status = U_ILLEGAL_ARGUMENT_ERROR;
+        return;
+    }
     set(UCAL_MILLISECONDS_IN_DAY, 0);
 
     switch (field) {
     case UCAL_YEAR:
     case UCAL_EXTENDED_YEAR:
         set(UCAL_DAY_OF_YEAR, getGreatestMinimum(UCAL_DAY_OF_YEAR));
         break;
 
     case UCAL_YEAR_WOY:
         set(UCAL_WEEK_OF_YEAR, getGreatestMinimum(UCAL_WEEK_OF_YEAR));
         U_FALLTHROUGH;
     case UCAL_MONTH:
         set(UCAL_DATE, getGreatestMinimum(UCAL_DATE));
         break;
 
     case UCAL_DAY_OF_WEEK_IN_MONTH:
         // For dowim, the maximum occurs for the DOW of the first of the
         // month.
         set(UCAL_DATE, 1);
         set(UCAL_DAY_OF_WEEK, get(UCAL_DAY_OF_WEEK, status)); // Make this user set
         break;
 
     case UCAL_WEEK_OF_MONTH:
     case UCAL_WEEK_OF_YEAR:
         // If we're counting weeks, set the day of the week to either the
         // first or last localized DOW.  We know the last week of a month
         // or year will contain the first day of the week, and that the
         // first week will contain the last DOW.
         {
             int32_t dow = fFirstDayOfWeek;
             if (isMinimum) {
                 dow = (dow + 6) % 7; // set to last DOW
                 if (dow < UCAL_SUNDAY) {
                     dow += 7;
                 }
             }
 #if defined (U_DEBUG_CAL)
             fprintf(stderr, "prepareGetActualHelper(WOM/WOY) - dow=%d\n", dow);
 #endif
             set(UCAL_DAY_OF_WEEK, dow);
         }
         break;
     default:
         break;
     }
 
     // Do this last to give it the newest time stamp
     set(field, getGreatestMinimum(field));
 }
@@ -3773,68 +3837,77 @@ void Calendar::prepareGetActual(UCalendarDateFields field, UBool isMinimum, UErr
 int32_t Calendar::getActualHelper(UCalendarDateFields field, int32_t startValue, int32_t endValue, UErrorCode &status) const
 {
 #if defined (U_DEBUG_CAL)
     fprintf(stderr, "getActualHelper(%d,%d .. %d, %s)\n", field, startValue, endValue, u_errorName(status));
 #endif
     if (U_FAILURE(status)) {
        return 0;
     }
+    if (field < 0 || field >= UCAL_FIELD_COUNT) {
+        status = U_ILLEGAL_ARGUMENT_ERROR;
+        return 0;
+    }
     if (startValue == endValue) {
         // if we know that the maximum value is always the same, just return it
         return startValue;
     }
 
     int32_t delta = (endValue > startValue) ? 1 : -1;
 
     // clone the calendar so we don't mess with the real one, and set it to
     // accept anything for the field values
-    if(U_FAILURE(status)) return startValue;
+    if(U_FAILURE(status)) {
+        return startValue;
+    }
     Calendar *work = clone();
-    if(!work) { status = U_MEMORY_ALLOCATION_ERROR; return startValue; }
+    if(!work) {
+        status = U_MEMORY_ALLOCATION_ERROR;
+        return startValue;
+    }
 
     // need to resolve time here, otherwise, fields set for actual limit
     // may cause conflict with fields previously set (but not yet resolved).
     work->complete(status);
 
     work->setLenient(true);
     work->prepareGetActual(field, delta < 0, status);
 
     // now try each value from the start to the end one by one until
     // we get a value that normalizes to another value.  The last value that
     // normalizes to itself is the actual maximum for the current date
     work->set(field, startValue);
 
     // prepareGetActual sets the first day of week in the same week with
     // the first day of a month.  Unlike WEEK_OF_YEAR, week number for the
     // week which contains days from both previous and current month is
     // not unique.  For example, last several days in the previous month
     // is week 5, and the rest of week is week 1.
     int32_t result = startValue;
     if ((work->get(field, status) != startValue
          && field != UCAL_WEEK_OF_MONTH && delta > 0 ) || U_FAILURE(status)) {
 #if defined (U_DEBUG_CAL)
         fprintf(stderr, "getActualHelper(fld %d) - got  %d (not %d) - %s\n", field, work->get(field,status), startValue, u_errorName(status));
 #endif
     } else {
         do {
             startValue += delta;
             work->add(field, delta, status);
             if (work->get(field, status) != startValue || U_FAILURE(status)) {
 #if defined (U_DEBUG_CAL)
                 fprintf(stderr, "getActualHelper(fld %d) - got  %d (not %d), BREAK - %s\n", field, work->get(field,status), startValue, u_errorName(status));
 #endif
                 break;
             }
             result = startValue;
         } while (startValue != endValue);
     }
     delete work;
 #if defined (U_DEBUG_CAL)
     fprintf(stderr, "getActualHelper(%d) = %d\n", field, result);
 #endif
     return result;
 }
 
 
 
 
 // -------------------------------------
@@ -3843,134 +3916,136 @@ void
 Calendar::setWeekData(const Locale& desiredLocale, const char *type, UErrorCode& status)
 {
 
-    if (U_FAILURE(status)) return;
+    if (U_FAILURE(status)) {
+        return;
+    }
 
     fFirstDayOfWeek = UCAL_SUNDAY;
     fMinimalDaysInFirstWeek = 1;
     fWeekendOnset = UCAL_SATURDAY;
     fWeekendOnsetMillis = 0;
     fWeekendCease = UCAL_SUNDAY;
     fWeekendCeaseMillis = 86400000; // 24*60*60*1000
 
     // Since week and weekend data is territory based instead of language based,
     // we may need to tweak the locale that we are using to try to get the appropriate
     // values, using the following logic:
     // 1). If the locale has a language but no territory, use the territory as defined by
     //     the likely subtags.
     // 2). If the locale has a script designation then we ignore it,
     //     then remove it ( i.e. "en_Latn_US" becomes "en_US" )
 
     UErrorCode myStatus = U_ZERO_ERROR;
 
     Locale min(desiredLocale);
     min.minimizeSubtags(myStatus);
     Locale useLocale;
     if ( uprv_strlen(desiredLocale.getCountry()) == 0 ||
          (uprv_strlen(desiredLocale.getScript()) > 0 && uprv_strlen(min.getScript()) == 0) ) {
         myStatus = U_ZERO_ERROR;
         Locale max(desiredLocale);
         max.addLikelySubtags(myStatus);
         useLocale = Locale(max.getLanguage(),max.getCountry());
     } else {
         useLocale = desiredLocale;
     }
 
     /* The code here is somewhat of a hack, since week data and weekend data aren't really tied to
        a specific calendar, they aren't truly locale data.  But this is the only place where valid and
        actual locale can be set, so we take a shot at it here by loading a representative resource
        from the calendar data.  The code used to use the dateTimeElements resource to get first day
        of week data, but this was moved to supplemental data under ticket 7755. (JCE) */
 
     // Get the monthNames resource bundle for the calendar 'type'. Fallback to gregorian if the resource is not
     // found.
     LocalUResourceBundlePointer calData(ures_open(nullptr, useLocale.getBaseName(), &status));
     ures_getByKey(calData.getAlias(), gCalendar, calData.getAlias(), &status);
 
     LocalUResourceBundlePointer monthNames;
     if (type != nullptr && *type != '\0' && uprv_strcmp(type, gGregorian) != 0) {
         monthNames.adoptInstead(ures_getByKeyWithFallback(calData.getAlias(), type, nullptr, &status));
         ures_getByKeyWithFallback(monthNames.getAlias(), gMonthNames,
                                   monthNames.getAlias(), &status);
     }
 
     if (monthNames.isNull() || status == U_MISSING_RESOURCE_ERROR) {
         status = U_ZERO_ERROR;
         monthNames.adoptInstead(ures_getByKeyWithFallback(calData.getAlias(), gGregorian,
                                                           monthNames.orphan(), &status));
         ures_getByKeyWithFallback(monthNames.getAlias(), gMonthNames,
                                   monthNames.getAlias(), &status);
     }
 
     if (U_SUCCESS(status)) {
         U_LOCALE_BASED(locBased,*this);
         locBased.setLocaleIDs(ures_getLocaleByType(monthNames.getAlias(), ULOC_VALID_LOCALE, &status),
                               ures_getLocaleByType(monthNames.getAlias(), ULOC_ACTUAL_LOCALE, &status));
     } else {
         status = U_USING_FALLBACK_WARNING;
         return;
     }
 
     char region[ULOC_COUNTRY_CAPACITY];
     (void)ulocimp_getRegionForSupplementalData(desiredLocale.getName(), true, region, sizeof(region), &status);
 
     // Read week data values from supplementalData week data
     UResourceBundle *rb = ures_openDirect(nullptr, "supplementalData", &status);
     ures_getByKey(rb, "weekData", rb, &status);
     UResourceBundle *weekData = ures_getByKey(rb, region, nullptr, &status);
     if (status == U_MISSING_RESOURCE_ERROR && rb != nullptr) {
         status = U_ZERO_ERROR;
         weekData = ures_getByKey(rb, "001", nullptr, &status);
     }
 
     if (U_FAILURE(status)) {
         status = U_USING_FALLBACK_WARNING;
     } else {
         int32_t arrLen;
         const int32_t *weekDataArr = ures_getIntVector(weekData,&arrLen,&status);
         if( U_SUCCESS(status) && arrLen == 6
                 && 1 <= weekDataArr[0] && weekDataArr[0] <= 7
                 && 1 <= weekDataArr[1] && weekDataArr[1] <= 7
                 && 1 <= weekDataArr[2] && weekDataArr[2] <= 7
                 && 1 <= weekDataArr[4] && weekDataArr[4] <= 7) {
             fFirstDayOfWeek = (UCalendarDaysOfWeek)weekDataArr[0];
             fMinimalDaysInFirstWeek = (uint8_t)weekDataArr[1];
             fWeekendOnset = (UCalendarDaysOfWeek)weekDataArr[2];
             fWeekendOnsetMillis = weekDataArr[3];
             fWeekendCease = (UCalendarDaysOfWeek)weekDataArr[4];
             fWeekendCeaseMillis = weekDataArr[5];
         } else {
             status = U_INVALID_FORMAT_ERROR;
         }
 
         // Check if the locale has a "fw" u extension and we honor it if present.
         // And we don't change the overal status, as the presence / lack of "fw" is not an error.
         UErrorCode fwStatus = U_ZERO_ERROR;
         char fwExt[ULOC_FULLNAME_CAPACITY] = "";
         desiredLocale.getKeywordValue("fw", fwExt, ULOC_FULLNAME_CAPACITY, fwStatus);
         if (U_SUCCESS(fwStatus)) {
             if (uprv_strcmp(fwExt, "sun") == 0) {
                 fFirstDayOfWeek = UCAL_SUNDAY;
             } else if (uprv_strcmp(fwExt, "mon") == 0) {
                 fFirstDayOfWeek = UCAL_MONDAY;
             } else if (uprv_strcmp(fwExt, "tue") == 0) {
                 fFirstDayOfWeek = UCAL_TUESDAY;
             } else if (uprv_strcmp(fwExt, "wed") == 0) {
                 fFirstDayOfWeek = UCAL_WEDNESDAY;
             } else if (uprv_strcmp(fwExt, "thu") == 0) {
                 fFirstDayOfWeek = UCAL_THURSDAY;
             } else if (uprv_strcmp(fwExt, "fri") == 0) {
                 fFirstDayOfWeek = UCAL_FRIDAY;
             } else if (uprv_strcmp(fwExt, "sat") == 0) {
                 fFirstDayOfWeek = UCAL_SATURDAY;
             }
         }
     }
     ures_close(weekData);
     ures_close(rb);
 }
 
 /**
 * Recompute the time and update the status fields isTimeSet
 * and areFieldsSet.  Callers should check isTimeSet and only
 * call this method if isTimeSet is false.
 */
