commit c25a14c3fd5522aff0b1d2a77d7ee66b7c529779
Author: David Anderson <davea42@linuxmail.org>
Date:   Mon Mar 27 10:07:36 2023 -0700

    Unused local variables removed.
            modified:   src/lib/libdwarf/dwarf_gdbindex.c
    
    A free() was duplicated, Windows compiler noticed.
            modified:   src/lib/libdwarf/dwarf_line_table_reader_common.h

diff --git a/src/lib/libdwarf/dwarf_gdbindex.c b/src/lib/libdwarf/dwarf_gdbindex.c
index 4b4bd0d5..0ddf894e 100644
--- a/src/lib/libdwarf/dwarf_gdbindex.c
+++ b/src/lib/libdwarf/dwarf_gdbindex.c
@@ -171,203 +171,196 @@ int
 dwarf_gdbindex_header(Dwarf_Debug dbg,
     Dwarf_Gdbindex * gdbindexptr,
     Dwarf_Unsigned * version,
     Dwarf_Unsigned * cu_list_offset,
     Dwarf_Unsigned * types_cu_list_offset,
     Dwarf_Unsigned * address_area_offset,
     Dwarf_Unsigned * symbol_table_offset,
     Dwarf_Unsigned * constant_pool_offset,
     Dwarf_Unsigned * section_size,
     const char    ** section_name,
     Dwarf_Error    * error)
 {
     Dwarf_Gdbindex indexptr = 0;
     int res = DW_DLV_ERROR;
-    Dwarf_Unsigned localoff = 0;
     Dwarf_Small *data = 0;
     Dwarf_Small *startdata = 0;
     Dwarf_Unsigned version_in = 0;
     
 
     if (!dbg) {
         _dwarf_error_string(NULL, error,
             DW_DLE_GDB_INDEX_INDEX_ERROR,
             "DW_DLE_GDB_INDEX_INDEX_ERROR:"
             " passed in NULL Dwarf_Debut to"
             " dwarf_gdbindex_header");
         return DW_DLV_ERROR;
     }
     if (!dbg->de_debug_gdbindex.dss_size) {
         return DW_DLV_NO_ENTRY;
     }
     if (!dbg->de_debug_gdbindex.dss_data) {
         res = _dwarf_load_section(dbg, &dbg->de_debug_gdbindex,error);
         if (res != DW_DLV_OK) {
             return res;
         }
     }
     data = dbg->de_debug_gdbindex.dss_data;
     startdata = data;
 
     if (dbg->de_debug_gdbindex.dss_size < (DWARF_32BIT_SIZE*6)) {
         _dwarf_error(dbg, error, DW_DLE_ERRONEOUS_GDB_INDEX_SECTION);
         return DW_DLV_ERROR;
     }
     indexptr = (Dwarf_Gdbindex)_dwarf_get_alloc(dbg,
         DW_DLA_GDBINDEX,1);
     if (indexptr == NULL) {
         _dwarf_error_string(dbg, error, DW_DLE_ALLOC_FAIL,
             "DW_DLE_ALLOC_FAIL: allocating Dwarf_Gdbindex");
         return DW_DLV_ERROR;
     }
     READ_GDBINDEX(version_in,Dwarf_Unsigned,
         data, DWARF_32BIT_SIZE);
     indexptr->gi_version = version_in;
 
     indexptr->gi_dbg = dbg;
     indexptr->gi_section_data = startdata;
     indexptr->gi_section_length = dbg->de_debug_gdbindex.dss_size;
     /*   7 and lower are different format in some way */
     if (indexptr->gi_version != 8 &&
         indexptr->gi_version != 7) {
         emit_one_value_msg(dbg, DW_DLE_ERRONEOUS_GDB_INDEX_SECTION,
             "DW_DLE_ERRONEOUS_GDB_INDEX_SECTION: "
             " version number %u is not"
             " supported",
             indexptr->gi_version,error);
         dwarf_dealloc(dbg,indexptr,DW_DLA_GDBINDEX);
         return DW_DLV_ERROR;
     }
     data += DWARF_32BIT_SIZE;
-    localoff += DWARF_32BIT_SIZE;
     READ_GDBINDEX(indexptr->gi_cu_list_offset ,Dwarf_Unsigned,
         data, DWARF_32BIT_SIZE);
     if (indexptr->gi_cu_list_offset > indexptr->gi_section_length) {
         emit_one_value_msg(dbg, DW_DLE_ERRONEOUS_GDB_INDEX_SECTION,
             "DW_DLE_ERRONEOUS_GDB_INDEX_SECTION"
             " cu list offset of %u is too large for the section",
             indexptr->gi_cu_list_offset,error);
         dwarf_dealloc(dbg,indexptr,DW_DLA_GDBINDEX);
         return DW_DLV_ERROR;
     }
     data += DWARF_32BIT_SIZE;
-    localoff += DWARF_32BIT_SIZE;
     READ_GDBINDEX(indexptr->gi_types_cu_list_offset ,Dwarf_Unsigned,
         data, DWARF_32BIT_SIZE);
     if (indexptr->gi_types_cu_list_offset > 
         indexptr->gi_section_length) {
         emit_one_value_msg(dbg, DW_DLE_ERRONEOUS_GDB_INDEX_SECTION,
             "DW_DLE_ERRONEOUS_GDB_INDEX_SECTION"
             " types cu list offset of %u is too "
             "large for the section",
             indexptr->gi_cu_list_offset,error);
         dwarf_dealloc(dbg,indexptr,DW_DLA_GDBINDEX);
         return DW_DLV_ERROR;
     }
     data += DWARF_32BIT_SIZE;
-    localoff += DWARF_32BIT_SIZE;
     READ_GDBINDEX(indexptr->gi_address_area_offset ,Dwarf_Unsigned,
         data, DWARF_32BIT_SIZE);
     if (indexptr->gi_address_area_offset > 
         indexptr->gi_section_length) {
         emit_one_value_msg(dbg, DW_DLE_ERRONEOUS_GDB_INDEX_SECTION,
             "DW_DLE_ERRONEOUS_GDB_INDEX_SECTION"
             " address area offset of %u is too "
             "large for the section",
             indexptr->gi_address_area_offset ,error);
         dwarf_dealloc(dbg,indexptr,DW_DLA_GDBINDEX);
         return DW_DLV_ERROR;
     }
     data += DWARF_32BIT_SIZE;
-    localoff += DWARF_32BIT_SIZE;
     READ_GDBINDEX(indexptr->gi_symbol_table_offset ,Dwarf_Unsigned,
         data, DWARF_32BIT_SIZE);
     if (indexptr->gi_symbol_table_offset > 
         indexptr->gi_section_length) {
         emit_one_value_msg(dbg, DW_DLE_ERRONEOUS_GDB_INDEX_SECTION,
             "DW_DLE_ERRONEOUS_GDB_INDEX_SECTION"
             " symbol table offset of %u is too "
             "large for the section",
             indexptr->gi_symbol_table_offset,error);
         dwarf_dealloc(dbg,indexptr,DW_DLA_GDBINDEX);
         return DW_DLV_ERROR;
     }
     data += DWARF_32BIT_SIZE;
-    localoff += DWARF_32BIT_SIZE;
     READ_GDBINDEX(indexptr->gi_constant_pool_offset ,Dwarf_Unsigned,
         data, DWARF_32BIT_SIZE);
     if (indexptr->gi_constant_pool_offset > 
         indexptr->gi_section_length) {
         emit_one_value_msg(dbg, DW_DLE_ERRONEOUS_GDB_INDEX_SECTION,
             "DW_DLE_ERRONEOUS_GDB_INDEX_SECTION"
             " constant pool offset of %u is too "
             "large for the section",
             indexptr->gi_constant_pool_offset,error);
         dwarf_dealloc(dbg,indexptr,DW_DLA_GDBINDEX);
         return DW_DLV_ERROR;
     }
     data += DWARF_32BIT_SIZE;
-    localoff += DWARF_32BIT_SIZE;
     
     res = set_base(dbg,&indexptr->gi_culisthdr,
         startdata + indexptr->gi_cu_list_offset,
         startdata + indexptr->gi_types_cu_list_offset,
         2*sizeof(gdbindex_64),
         sizeof(gdbindex_64),
         git_std,error);
     if (res == DW_DLV_ERROR) {
         dwarf_dealloc(dbg,indexptr,DW_DLA_GDBINDEX);
         return res;
     }
     res = set_base(dbg,&indexptr->gi_typesculisthdr,
         startdata+ indexptr->gi_types_cu_list_offset,
         startdata+ indexptr->gi_address_area_offset,
         3*sizeof(gdbindex_64),
         sizeof(gdbindex_64),
         git_std,error);
     if (res == DW_DLV_ERROR) {
         dwarf_dealloc(dbg,indexptr,DW_DLA_GDBINDEX);
         return res;
     }
     res = set_base(dbg,&indexptr->gi_addressareahdr,
         startdata + indexptr->gi_address_area_offset,
         startdata + indexptr->gi_symbol_table_offset,
         3*sizeof(gdbindex_64),
         sizeof(gdbindex_64),
         git_address,error);
     if (res == DW_DLV_ERROR) {
         dwarf_dealloc(dbg,indexptr,DW_DLA_GDBINDEX);
         return res;
     }
     res = set_base(dbg,&indexptr->gi_symboltablehdr,
         startdata + indexptr->gi_symbol_table_offset,
         startdata + indexptr->gi_constant_pool_offset,
         2*DWARF_32BIT_SIZE,
         DWARF_32BIT_SIZE,
         git_std,error);
     if (res == DW_DLV_ERROR) {
         dwarf_dealloc(dbg,indexptr,DW_DLA_GDBINDEX);
         return res;
     }
     res = set_base(dbg,&indexptr->gi_cuvectorhdr,
         startdata + indexptr->gi_constant_pool_offset,
         /*  There is no real single vector size.
             but we'll use the entire rest as if there was. */
         startdata + indexptr->gi_section_length,
         DWARF_32BIT_SIZE,
         DWARF_32BIT_SIZE,
         git_cuvec,error);
     if (res == DW_DLV_ERROR) {
         dwarf_dealloc(dbg,indexptr,DW_DLA_GDBINDEX);
         return res;
     }
     *gdbindexptr          = indexptr;
     *version              = indexptr->gi_version;
     *cu_list_offset       = indexptr->gi_cu_list_offset;
     *types_cu_list_offset = indexptr->gi_types_cu_list_offset;
     *address_area_offset  = indexptr->gi_address_area_offset;
     *symbol_table_offset  = indexptr->gi_symbol_table_offset;
     *constant_pool_offset = indexptr->gi_constant_pool_offset;
     *section_size         = indexptr->gi_section_length;
     *section_name  =        dbg->de_debug_gdbindex.dss_name;
     return DW_DLV_OK;
 }
@@ -683,43 +676,40 @@ int
 dwarf_gdbindex_cuvector_length(Dwarf_Gdbindex gdbindexptr,
     Dwarf_Unsigned   cuvector_offset,
     Dwarf_Unsigned * innercount,
     Dwarf_Error    * error)
 {
     Dwarf_Small *base = 0;
     Dwarf_Small *endptr = 0;
     Dwarf_Unsigned fieldlen = 0;
     Dwarf_Unsigned val = 0;
-    Dwarf_Unsigned secoff = 0;
 
     if (!gdbindexptr || !gdbindexptr->gi_dbg) {
         _dwarf_error_string(NULL, error,
             DW_DLE_GDB_INDEX_INDEX_ERROR,
             "DW_DLE_GDB_INDEX_INDEX_ERROR:"
             " passed in NULL indexptr to"
             " dwarf_gdbindex_cuvector_length");
         return DW_DLV_ERROR;
     }
 
     base = gdbindexptr->gi_cuvectorhdr.dg_base;
-    secoff = (Dwarf_Unsigned)(base - gdbindexptr->gi_section_data); 
     endptr = gdbindexptr->gi_section_data +
         gdbindexptr->gi_section_length;
     fieldlen = gdbindexptr->gi_cuvectorhdr.dg_entry_length;
     base += cuvector_offset;
-    secoff += cuvector_offset;
     if (( base + fieldlen) >endptr) {
         Dwarf_Debug dbg = gdbindexptr->gi_dbg;
         emit_no_value_msg(dbg, DW_DLE_GDB_INDEX_INDEX_ERROR,
             "DW_DLE_GDB_INDEX_INDEX_ERROR:"
             " end offset of count of gdbindex cuvector "
             " is past the"
             " end of the section",
             error);
         return DW_DLV_ERROR;
     }
     READ_GDBINDEX(val,Dwarf_Unsigned,
         base,
         fieldlen);
     *innercount = val;
     return DW_DLV_OK;
 }
diff --git a/src/lib/libdwarf/dwarf_line_table_reader_common.h b/src/lib/libdwarf/dwarf_line_table_reader_common.h
index 5985bcdb..1a6b3e46 100644
--- a/src/lib/libdwarf/dwarf_line_table_reader_common.h
+++ b/src/lib/libdwarf/dwarf_line_table_reader_common.h
@@ -171,1032 +171,1031 @@ static int
 _dwarf_read_line_table_header(Dwarf_Debug dbg,
     Dwarf_CU_Context cu_context,
     Dwarf_Small * section_start,
     Dwarf_Small * data_start,
     Dwarf_Unsigned section_length,
     Dwarf_Small ** updated_data_start_out,
     Dwarf_Line_Context  line_context,
     Dwarf_Small ** bogus_bytes_ptr,
     Dwarf_Unsigned *bogus_bytes,
     Dwarf_Error * err,
     int *err_count_out)
 {
     Dwarf_Small *line_ptr = data_start;
     Dwarf_Small *starting_line_ptr = data_start;
     Dwarf_Unsigned total_length = 0;
     int local_length_size = 0;
     int local_extension_size = 0;
     Dwarf_Unsigned prologue_length = 0;
     Dwarf_Half version = 0;
     /*  Both of the next two should point *one past*
         the end of actual data of interest. */
     Dwarf_Small *section_end = section_start + section_length;
     Dwarf_Small *line_ptr_end = 0;
     Dwarf_Small *lp_begin = 0;
     int res = 0;
     Dwarf_Unsigned htmp = 0;
 
     if (bogus_bytes_ptr) *bogus_bytes_ptr = 0;
     if (bogus_bytes) *bogus_bytes= 0;
 
     line_context->lc_line_ptr_start = starting_line_ptr;
     /* READ_AREA_LENGTH updates line_ptr for consumed bytes */
     READ_AREA_LENGTH_CK(dbg, total_length, Dwarf_Unsigned,
         line_ptr, local_length_size, local_extension_size,
         err, section_length,section_end);
     line_ptr_end = line_ptr + total_length;
     line_context->lc_line_ptr_end = line_ptr_end;
     line_context->lc_length_field_length = local_length_size +
         local_extension_size;
     line_context->lc_section_offset = starting_line_ptr -
         dbg->de_debug_line.dss_data;
     /*  ASSERT: line_context->lc_length_field_length == line_ptr
         -line_context->lc_line_ptr_start; */
     if (line_ptr_end > section_end) {
         dwarfstring m;
  
         dwarfstring_constructor(&m);
         dwarfstring_append_printf_u(&m,"DW_DLE_DEBUG_LINE_LENGTH_BAD "
             " the total length of this line table is too large at"
             " %" DW_PR_DUu  " bytes",total_length);
         _dwarf_error_string(dbg, err, DW_DLE_DEBUG_LINE_LENGTH_BAD,
              dwarfstring_string(&m));
         dwarfstring_destructor(&m);
         return DW_DLV_ERROR;
     }
     line_context->lc_total_length = total_length;
 
     /* READ_UNALIGNED_CK(dbg, version, Dwarf_Half,
         line_ptr, DWARF_HALF_SIZE,
         err,line_ptr_end); */
     res = _dwarf_read_unaligned_ck_wrapper(dbg,
         &htmp,line_ptr,DWARF_HALF_SIZE,line_ptr_end,err);
     if (res == DW_DLV_ERROR) {
         return res;
     }
     version = htmp;
 
     line_context->lc_version_number = version;
     line_ptr += DWARF_HALF_SIZE;
     if (version != DW_LINE_VERSION2 &&
         version != DW_LINE_VERSION3 &&
         version != DW_LINE_VERSION4 &&
         version != DW_LINE_VERSION5 &&
         version != EXPERIMENTAL_LINE_TABLES_VERSION) {
         _dwarf_error(dbg, err, DW_DLE_VERSION_STAMP_ERROR);
         return DW_DLV_ERROR;
     }
     if (version == DW_LINE_VERSION5) {
         if (line_ptr >= line_ptr_end) {
             _dwarf_error(dbg, err, DW_DLE_DEBUG_LINE_LENGTH_BAD);
             return (DW_DLV_ERROR);
         }
         line_context->lc_address_size = *(unsigned char *) line_ptr;
         line_ptr = line_ptr + sizeof(Dwarf_Small);
         if (line_ptr >= line_ptr_end) {
             _dwarf_error(dbg, err, DW_DLE_DEBUG_LINE_LENGTH_BAD);
             return (DW_DLV_ERROR);
         }
         line_context->lc_segment_selector_size =
             *(unsigned char *) line_ptr;
         line_ptr = line_ptr + sizeof(Dwarf_Small);
     } else {
         line_context->lc_address_size = cu_context->cc_address_size;
         line_context->lc_segment_selector_size =
             cu_context->cc_segment_selector_size;
     }
 
     READ_UNALIGNED_CK(dbg, prologue_length, Dwarf_Unsigned,
         line_ptr, local_length_size,
         err,line_ptr_end);
     if (prologue_length > total_length) {
         dwarfstring m;
         dwarfstring_constructor(&m);
         dwarfstring_append_printf_u(&m,
             "DW_DLE_DEBUG_LINE_LENGTH_BAD "
             " the prologue length of "
             " this line table is too large at"
             " %" DW_PR_DUu  " bytes",prologue_length);
         _dwarf_error_string(dbg, err,
             DW_DLE_DEBUG_LINE_LENGTH_BAD,
             dwarfstring_string(&m));
         dwarfstring_destructor(&m);
         return DW_DLV_ERROR;
     }
     line_context->lc_prologue_length = prologue_length;
     line_ptr += local_length_size;
     line_context->lc_line_prologue_start = line_ptr;
     if (line_ptr >= line_ptr_end) {
         _dwarf_error(dbg, err, DW_DLE_DEBUG_LINE_LENGTH_BAD);
         return (DW_DLV_ERROR);
     }
     line_context->lc_minimum_instruction_length =
         *(unsigned char *) line_ptr;
     line_ptr = line_ptr + sizeof(Dwarf_Small);
 
     if (version == DW_LINE_VERSION4 ||
         version == DW_LINE_VERSION5 ||
         version == EXPERIMENTAL_LINE_TABLES_VERSION) {
         if (line_ptr >= line_ptr_end) {
             _dwarf_error(dbg, err, DW_DLE_DEBUG_LINE_LENGTH_BAD);
             return (DW_DLV_ERROR);
         }
         line_context->lc_maximum_ops_per_instruction =
             *(unsigned char *) line_ptr;
         line_ptr = line_ptr + sizeof(Dwarf_Small);
     }
     if (line_ptr >= line_ptr_end) {
         _dwarf_error(dbg, err, DW_DLE_DEBUG_LINE_LENGTH_BAD);
         return (DW_DLV_ERROR);
     }
     line_context->lc_default_is_stmt = *(unsigned char *) line_ptr;
     line_ptr = line_ptr + sizeof(Dwarf_Small);
 
     if (line_ptr >= line_ptr_end) {
         _dwarf_error(dbg, err, DW_DLE_DEBUG_LINE_LENGTH_BAD);
         return (DW_DLV_ERROR);
     }
     line_context->lc_line_base = *(signed char *) line_ptr;
     line_ptr = line_ptr + sizeof(Dwarf_Sbyte);
     if (line_ptr >= line_ptr_end) {
         _dwarf_error(dbg, err, DW_DLE_LINE_OFFSET_BAD);
         return DW_DLV_ERROR;
     }
     line_context->lc_line_range = *(unsigned char *) line_ptr;
     if (!line_context->lc_line_range) {
         _dwarf_error(dbg, err, DW_DLE_DEBUG_LINE_RANGE_ZERO);
         return DW_DLV_ERROR;
     }
     line_ptr = line_ptr + sizeof(Dwarf_Small);
     if (line_ptr >= line_ptr_end) {
         _dwarf_error(dbg, err, DW_DLE_LINE_OFFSET_BAD);
         return DW_DLV_ERROR;
     }
     line_context->lc_opcode_base = *(unsigned char *) line_ptr;
     line_ptr = line_ptr + sizeof(Dwarf_Small);
     /*  Set up the array of standard opcode lengths. */
     /*  We think this works ok even for cross-endian processing of
         objects.  It might be wrong, we might need to
         specially process the array of ubyte into host order.  */
     line_context->lc_opcode_length_table = line_ptr;
 
     /*  lc_opcode_base is one greater than the size of the array. */
     line_ptr += line_context->lc_opcode_base - 1;
     line_context->lc_std_op_count = line_context->lc_opcode_base -1;
     if (line_ptr >= line_ptr_end) {
         _dwarf_error(dbg, err, DW_DLE_LINE_OFFSET_BAD);
         return DW_DLV_ERROR;
     }
     {
         /*  Determine (as best we can) whether the
             lc_opcode_length_table holds 9 or 12 standard-conforming
             entries.  gcc4 upped to DWARF3's 12 without updating the
             version number.
             EXPERIMENTAL_LINE_TABLES_VERSION upped to 15.  */
         unsigned check_count = line_context->lc_std_op_count;
         unsigned tab_count =
             sizeof(dwarf_standard_opcode_operand_count);
 
         int operand_ck_fail = true;
         if (line_context->lc_std_op_count > tab_count) {
             _dwarf_print_header_issue(dbg,
                 "Too many standard operands in linetable header: ",
                 data_start,
                 line_context->lc_std_op_count,
                 0,0,0,
                 err_count_out);
             check_count = tab_count;
         }
         {
             unsigned entrynum = 0;
             unsigned tabv     = 0;
             unsigned linetabv     = 0;
 
             int mismatch = operandmismatch(
                 dwarf_standard_opcode_operand_count,
                 tab_count,
                 line_context->lc_opcode_length_table,
                 check_count,&entrynum,&tabv,&linetabv);
             if (mismatch) {
                 if (err_count_out) {
                     _dwarf_print_header_issue(dbg,
                         "standard-operands did not match, checked",
                         data_start,
                         check_count,
                         entrynum,tabv,linetabv,err_count_out);
                 }
                 if (check_count >
                     sizeof(dwarf_arm_standard_opcode_operand_count)) {
                     check_count =
                         sizeof(
                         dwarf_arm_standard_opcode_operand_count);
                 }
                 mismatch = operandmismatch(
                     dwarf_arm_standard_opcode_operand_count,
                     sizeof(dwarf_arm_standard_opcode_operand_count),
                     line_context->lc_opcode_length_table,
                     check_count,&entrynum,&tabv,&linetabv);
                 if (!mismatch && err_count_out) {
                     _dwarf_print_header_issue(dbg,
                         "arm (incorrect) operands in use: ",
                         data_start,
                         check_count,
                         entrynum,tabv,linetabv,err_count_out);
                 }
             }
             if (!mismatch) {
                 if (version == 2) {
                     if (line_context->lc_std_op_count ==
                         STANDARD_OPERAND_COUNT_DWARF3) {
                         _dwarf_print_header_issue(dbg,
                             "standard DWARF3 operands matched,"
                             " but is DWARF2 linetable: count",
                             data_start,
                             check_count,
                             0,0,0, err_count_out);
                     }
                 }
                 operand_ck_fail = false;
             }
         }
         if (operand_ck_fail) {
             /* Here we are not sure what the lc_std_op_count is. */
             _dwarf_error(dbg, err, DW_DLE_LINE_NUM_OPERANDS_BAD);
             return (DW_DLV_ERROR);
         }
     }
     /*  At this point we no longer need to check operand counts. */
     if (line_ptr >= line_ptr_end) {
         _dwarf_error(dbg, err, DW_DLE_LINE_OFFSET_BAD);
         return DW_DLV_ERROR;
     }
 
     if (version < DW_LINE_VERSION5){
         Dwarf_Unsigned directories_count = 0;
         Dwarf_Unsigned directories_malloc = 5;
         line_context->lc_include_directories =
             malloc(sizeof(Dwarf_Small *) * directories_malloc);
         if (line_context->lc_include_directories == NULL) {
             _dwarf_error(dbg, err, DW_DLE_ALLOC_FAIL);
             return (DW_DLV_ERROR);
         }
         memset(line_context->lc_include_directories, 0,
             sizeof(Dwarf_Small *) * directories_malloc);
 
         if (line_ptr >= line_ptr_end) {
             _dwarf_error(dbg, err, DW_DLE_LINE_NUMBER_HEADER_ERROR);
             return (DW_DLV_ERROR);
         }
         while ((*(char *) line_ptr) != '\0') {
             if (directories_count >= directories_malloc) {
                 Dwarf_Unsigned expand = 2 * directories_malloc;
                 Dwarf_Unsigned bytesalloc =
                     sizeof(Dwarf_Small *) * expand;
                 Dwarf_Small **newdirs =
                     realloc(line_context->lc_include_directories,
                         bytesalloc);
 
                 if (!newdirs) {
                     _dwarf_error(dbg, err, DW_DLE_ALLOC_FAIL);
                     return (DW_DLV_ERROR);
                 }
                 /* Doubled size, zero out second half. */
                 memset(newdirs + directories_malloc, 0,
                     sizeof(Dwarf_Small *) * directories_malloc);
                 directories_malloc = expand;
                 line_context->lc_include_directories = newdirs;
             }
             line_context->lc_include_directories[directories_count] =
                 line_ptr;
             res = _dwarf_check_string_valid(dbg,
                 data_start,line_ptr,line_ptr_end,
                 DW_DLE_LINE_STRING_BAD,err);
             if (res != DW_DLV_OK) {
                 return res;
             }
             line_ptr = line_ptr + strlen((char *) line_ptr) + 1;
             directories_count++;
             if (line_ptr >= line_ptr_end) {
                 _dwarf_error(dbg, err,
                     DW_DLE_LINE_NUMBER_HEADER_ERROR);
                 return (DW_DLV_ERROR);
             }
         }
         line_ptr++;
         line_context->lc_include_directories_count =
             directories_count;
     } else if (version == EXPERIMENTAL_LINE_TABLES_VERSION) {
         /* Empty old style dir entry list. */
         line_ptr++;
     } else if (version == DW_LINE_VERSION5) {
         /* handled below */
     } else {
         /* No old style directory entries. */
     }
     if (line_ptr > line_ptr_end) {
         _dwarf_error(dbg, err, DW_DLE_LINE_OFFSET_BAD);
         return DW_DLV_ERROR;
     }
     if (version < DW_LINE_VERSION5) {
         if (line_ptr >= line_ptr_end) {
             _dwarf_error(dbg, err, DW_DLE_LINE_NUMBER_HEADER_ERROR);
             return (DW_DLV_ERROR);
         }
         while (*(char *) line_ptr != '\0') {
             Dwarf_Unsigned utmp;
             Dwarf_Unsigned dir_index = 0;
             Dwarf_Unsigned lastmod = 0;
             Dwarf_Unsigned file_length = 0;
             int resl = 0;
             Dwarf_File_Entry currfile  = 0;
 
             currfile = (Dwarf_File_Entry)
                 malloc(sizeof(struct Dwarf_File_Entry_s));
             if (currfile == NULL) {
                 _dwarf_error(dbg, err, DW_DLE_ALLOC_FAIL);
                 return (DW_DLV_ERROR);
             }
             memset(currfile,0,sizeof(struct Dwarf_File_Entry_s));
             /*  Insert early so in case of error we can find
                 and free the record. */
             _dwarf_add_to_files_list(line_context,currfile);
 
             currfile->fi_file_name = line_ptr;
             resl = _dwarf_check_string_valid(dbg,
                 data_start,line_ptr,line_ptr_end,
                 DW_DLE_LINE_STRING_BAD,err);
             if (resl != DW_DLV_OK) {
                 return resl;
             }
             line_ptr = line_ptr + strlen((char *) line_ptr) + 1;
             /*  DECODE_LEB128_UWORD_CK(line_ptr, utmp,dbg,
                 err,line_ptr_end); */
             res =  read_uword_de(&line_ptr,&utmp,
                 dbg,err,line_ptr_end);
             if (res == DW_DLV_ERROR) {
                 return DW_DLV_ERROR;
             }
             dir_index = (Dwarf_Unsigned) utmp;
             if (dir_index >
                 line_context->lc_include_directories_count) {
                 _dwarf_error(dbg, err, DW_DLE_DIR_INDEX_BAD);
                 return (DW_DLV_ERROR);
             }
             currfile->fi_dir_index = dir_index;
             currfile->fi_dir_index_present = TRUE;
 
             /*DECODE_LEB128_UWORD_CK(line_ptr,lastmod,
                 dbg,err, line_ptr_end); */
             res =  read_uword_de( &line_ptr,&lastmod,
                 dbg,err,line_ptr_end);
             if (res == DW_DLV_ERROR) {
                 return DW_DLV_ERROR;
             }
 
             currfile->fi_time_last_mod = lastmod;
             currfile->fi_time_last_mod_present = TRUE;
 
             DECODE_LEB128_UWORD_CK(line_ptr,file_length,
                 dbg,err, line_ptr_end);
             currfile->fi_file_length = file_length;
             currfile->fi_file_length_present = TRUE;
             if (line_ptr >= line_ptr_end) {
                 _dwarf_error(dbg, err,
                     DW_DLE_LINE_NUMBER_HEADER_ERROR);
                 return (DW_DLV_ERROR);
             }
         }
         /* Skip trailing nul byte */
         ++line_ptr;
     } else if (version == EXPERIMENTAL_LINE_TABLES_VERSION) {
         if (line_ptr >= line_ptr_end) {
             _dwarf_error(dbg, err, DW_DLE_LINE_NUMBER_HEADER_ERROR);
             return (DW_DLV_ERROR);
         }
         if (*line_ptr != 0) {
             _dwarf_error(dbg, err, DW_DLE_LINE_NUMBER_HEADER_ERROR);
             return (DW_DLV_ERROR);
         }
         line_ptr++;
     } else if (version == 5) {
         /* handled below */
     } else {
         /* No old style filenames entries. */
     }
     if (line_ptr > line_ptr_end) {
         _dwarf_error(dbg, err, DW_DLE_LINE_OFFSET_BAD);
         return DW_DLV_ERROR;
     }
 
     if (version == EXPERIMENTAL_LINE_TABLES_VERSION) {
         static unsigned char expbytes[5] = {0,0xff,0xff,0x7f, 0x7f };
         Dwarf_Unsigned logicals_table_offset = 0;
         Dwarf_Unsigned actuals_table_offset = 0;
         unsigned i = 0;
 
         for ( ; i < 5; ++i) {
             if (line_ptr >= line_ptr_end) {
                 _dwarf_error(dbg, err,
                     DW_DLE_LINE_NUMBER_HEADER_ERROR);
                 return (DW_DLV_ERROR);
             }
             if (*line_ptr != expbytes[i]) {
                 _dwarf_error(dbg, err,
                     DW_DLE_LINE_NUMBER_HEADER_ERROR);
                 return (DW_DLV_ERROR);
             }
             line_ptr++;
         }
         READ_UNALIGNED_CK(dbg, logicals_table_offset, Dwarf_Unsigned,
             line_ptr, local_length_size,err,line_ptr_end);
         line_context->lc_logicals_table_offset =
             logicals_table_offset;
         line_ptr += local_length_size;
         READ_UNALIGNED_CK(dbg, actuals_table_offset, Dwarf_Unsigned,
             line_ptr, local_length_size,err,line_ptr_end);
         line_context->lc_actuals_table_offset = actuals_table_offset;
         line_ptr += local_length_size;
         if (line_ptr > line_ptr_end) {
             _dwarf_error(dbg, err, DW_DLE_LINE_OFFSET_BAD);
             return DW_DLV_ERROR;
         }
     }
 
     if (version == DW_LINE_VERSION5 ||
         version == EXPERIMENTAL_LINE_TABLES_VERSION) {
         /* DWARF 5.  directory names.*/
         Dwarf_Unsigned directory_format_count = 0;
         struct Dwarf_Unsigned_Pair_s * format_values = 0;
         Dwarf_Unsigned directories_count = 0;
         Dwarf_Unsigned i = 0;
         Dwarf_Unsigned j = 0;
         int dres = 0;
 
         if (line_ptr >= line_ptr_end) {
             _dwarf_error(dbg, err, DW_DLE_LINE_NUMBER_HEADER_ERROR);
             return (DW_DLV_ERROR);
         }
         directory_format_count = *(unsigned char *) line_ptr;
         line_context->lc_directory_entry_format_count =
             directory_format_count;
         line_ptr = line_ptr + sizeof(Dwarf_Small);
         if (directory_format_count > 0) {
             format_values = malloc(
                 sizeof(struct Dwarf_Unsigned_Pair_s) *
                 directory_format_count);
             if (format_values == NULL) {
                 _dwarf_error(dbg, err, DW_DLE_ALLOC_FAIL);
                 return (DW_DLV_ERROR);
             }
             for (i = 0; i < directory_format_count; i++) {
                 dres=read_uword_de(&line_ptr,
                     &format_values[i].up_first,
                     dbg,err,line_ptr_end);
                 if (dres != DW_DLV_OK) {
                     free(format_values);
                     format_values = 0;
                     return dres;
                 }
                 dres=read_uword_de(&line_ptr,
                     &format_values[i].up_second,
                     dbg,err,line_ptr_end);
                 if (dres != DW_DLV_OK) {
                     free(format_values);
                     format_values = 0;
                     return dres;
                 }
             }
         }
         dres = read_uword_de(&line_ptr,&directories_count,
             dbg,err,line_ptr_end);
         if (dres != DW_DLV_OK) {
             free(format_values);
             format_values = 0;
             return dres;
         }
         if (directories_count > total_length) {
             dwarfstring m;
  
             free(format_values);
             format_values = 0;
             dwarfstring_constructor(&m);
             dwarfstring_append_printf_u(&m,
                 "DW_DLE_DEBUG_LINE_LENGTH_BAD "
                 " the directories count of "
                 " this line table is too large at"
                 " %" DW_PR_DUu  ,directories_count);
             _dwarf_error_string(dbg, err, 
                 DW_DLE_DEBUG_LINE_LENGTH_BAD,
                 dwarfstring_string(&m));
             dwarfstring_destructor(&m);
             return DW_DLV_ERROR;
         }
         line_context->lc_include_directories =
             malloc(sizeof(Dwarf_Small *) * directories_count);
         if (line_context->lc_include_directories == NULL) {
             free(format_values);
             format_values = 0;
             _dwarf_error(dbg, err, DW_DLE_ALLOC_FAIL);
             return (DW_DLV_ERROR);
         }
         if (directory_format_count == 0 &&
             directories_count > 0) {
             free(format_values);
             format_values = 0;
             _dwarf_error_string(dbg, err,
                 DW_DLE_DIRECTORY_FORMAT_COUNT_VS_DIRECTORIES_MISMATCH,
                 "DW_DLE_DIRECTORY_FORMAT_COUNT_"
                 "VS_DIRECTORIES_MISMATCH"
                 ": format count is zero yet directories count > 0");
             return (DW_DLV_ERROR);
         }
         memset(line_context->lc_include_directories, 0,
             sizeof(Dwarf_Small *) * directories_count);
 
         for (i = 0; i < directories_count; i++) {
             for (j = 0; j < directory_format_count; j++) {
                 Dwarf_Unsigned lntype =
                     format_values[j].up_first;
                 Dwarf_Unsigned lnform =
                     format_values[j].up_second;
                 switch (lntype) {
                 case DW_LNCT_path: {
                     char *inc_dir_ptr = 0;
                     res = _dwarf_decode_line_string_form(dbg,
                         lntype,lnform,
                         local_length_size,
                         &line_ptr,
                         line_ptr_end,
                         &inc_dir_ptr,
                         err);
                     if (res != DW_DLV_OK) {
                         free(format_values);
                         format_values = 0;
                         return res;
                     }
                     line_context->lc_include_directories[i] =
                         (unsigned char *)inc_dir_ptr;
                     break;
                 }
                 default:
                     free(format_values);
                     format_values = 0;
                     _dwarf_error(dbg, err,
                         DW_DLE_LINE_NUMBER_HEADER_ERROR);
                     return (DW_DLV_ERROR);
                 }
             }
             if (line_ptr > line_ptr_end) {
                 free(format_values);
                 format_values = 0;
                 _dwarf_error(dbg, err,
                     DW_DLE_LINE_NUMBER_HEADER_ERROR);
                 return (DW_DLV_ERROR);
             }
         }
         line_context->lc_directory_format_values =
             format_values;
         format_values = 0;
         line_context->lc_include_directories_count =
             directories_count;
     }
     if (version == DW_LINE_VERSION5 ||
         version == EXPERIMENTAL_LINE_TABLES_VERSION) {
         /* DWARF 5.  file names.*/
         struct Dwarf_Unsigned_Pair_s *
             filename_entry_pairs = 0;
         Dwarf_Unsigned filename_format_count = 0;
         Dwarf_Unsigned files_count = 0;
         Dwarf_Unsigned i = 0;
         Dwarf_Unsigned j = 0;
         int dres = 0;
 
         if (line_ptr >= line_ptr_end) {
             _dwarf_error(dbg, err,
                 DW_DLE_LINE_NUMBER_HEADER_ERROR);
             return (DW_DLV_ERROR);
         }
         filename_format_count = *(unsigned char *) line_ptr;
         line_context->lc_file_name_format_count =
             filename_format_count;
         line_ptr = line_ptr + sizeof(Dwarf_Small);
         filename_entry_pairs = malloc(
             sizeof(struct Dwarf_Unsigned_Pair_s) *
             filename_format_count);
         if (!filename_entry_pairs) {
             _dwarf_error(dbg, err, DW_DLE_ALLOC_FAIL);
             return DW_DLV_ERROR;
         }
         for (i = 0; i < filename_format_count; i++) {
             dres=read_uword_de(&line_ptr,
                 &filename_entry_pairs[i].up_first,
                 dbg,err,line_ptr_end);
             if (dres != DW_DLV_OK) {
                 free(filename_entry_pairs);
                 return dres;
             }
             dres=read_uword_de(&line_ptr,
                 &filename_entry_pairs[i].
                 up_second, dbg,err,line_ptr_end);
             if (dres != DW_DLV_OK) {
                 free(filename_entry_pairs);
                 return dres;
             }
         }
         /* DECODE_LEB128_UWORD_CK(line_ptr, files_count,
             dbg,err,line_ptr_end); */
         dres=read_uword_de(&line_ptr,&files_count,
             dbg,err,line_ptr_end);
         if (dres != DW_DLV_OK) {
             free(filename_entry_pairs);
             return dres;
         }
         if (files_count > total_length) {
             dwarfstring m;
 
             dwarfstring_constructor(&m);
             dwarfstring_append_printf_u(&m,
                 "DW_DLE_DEBUG_LINE_LENGTH_BAD "
                 " the files count of "
                 " this line table is too large at"
                 " %" DW_PR_DUu  " files",files_count);
             _dwarf_error_string(dbg, err,
                 DW_DLE_DEBUG_LINE_LENGTH_BAD,
                 dwarfstring_string(&m));
             dwarfstring_destructor(&m);
             free(filename_entry_pairs);
             return DW_DLV_ERROR;
         }
 
         for (i = 0; i < files_count; i++) {
             Dwarf_File_Entry curline = 0;
             curline = (Dwarf_File_Entry)
                 malloc(sizeof(struct Dwarf_File_Entry_s));
             if (curline == NULL) {
                 free(filename_entry_pairs);
                 _dwarf_error(dbg, err, DW_DLE_ALLOC_FAIL);
                 return (DW_DLV_ERROR);
             }
             memset(curline,0,sizeof(*curline));
             _dwarf_add_to_files_list(line_context,curline);
             for (j = 0; j < filename_format_count; j++) {
                 Dwarf_Unsigned dirindex = 0;
                 Dwarf_Unsigned lntype =
                     filename_entry_pairs[j].up_first;
                 Dwarf_Unsigned lnform =
                     filename_entry_pairs[j].up_second;
                 switch (lntype) {
                 /* The LLVM LNCT is documented in
                     https://releases.llvm.org/9.0.0/docs
                     /AMDGPUUsage.html
                 */
 
                 /* Cannot find the GNU items documented.? */
                 case DW_LNCT_GNU_decl_file: /* FORM udata*/
                     res = _dwarf_decode_line_udata_form(dbg,
                         lntype,lnform,
                         &line_ptr,
                         &dirindex,
                         line_ptr_end,
                         err);
                     if (res != DW_DLV_OK) {
                         free(filename_entry_pairs);
                         return res;
                     }
                     curline->fi_gnu_decl_file = dirindex;
                     curline->fi_gnu_decl_file_present = TRUE;
                     break;
                 case DW_LNCT_GNU_decl_line: /* FORM udata */
                     res = _dwarf_decode_line_udata_form(dbg,
                         lntype,lnform,
                         &line_ptr,
                         &dirindex,
                         line_ptr_end,
                         err);
                     if (res != DW_DLV_OK) {
                         free(filename_entry_pairs);
                         return res;
                     }
                     curline->fi_gnu_decl_line = dirindex;
                     curline->fi_gnu_decl_line_present = TRUE;
                     break;
 
                 case DW_LNCT_path: {
                     res = _dwarf_decode_line_string_form(dbg,
                         lntype, lnform,
                         local_length_size,
                         &line_ptr,
                         line_ptr_end,
                         (char **)&curline->fi_file_name,
                         err);
                     if (res != DW_DLV_OK) {
                         free(filename_entry_pairs);
                         return res;
                     }
                     }
                     break;
                 case DW_LNCT_GNU_subprogram_name: {
                     res = _dwarf_decode_line_string_form(dbg,
                         lntype, lnform,
                         local_length_size,
                         &line_ptr,
                         line_ptr_end,
                         (char **)&curline->fi_gnu_subprogram_name,
                         err);
                     if (res != DW_DLV_OK) {
                         free(filename_entry_pairs);
                         return res;
                     }
                     }
                     break;
                 case DW_LNCT_LLVM_source: {
                     res = _dwarf_decode_line_string_form(dbg,
                         lntype, lnform,
                         local_length_size,
                         &line_ptr,
                         line_ptr_end,
                         (char **)&curline->fi_llvm_source,
                         err);
                     if (res != DW_DLV_OK) {
                         free(filename_entry_pairs);
                         return res;
                     }
                     }
                     break;
                 case DW_LNCT_directory_index:
                     res = _dwarf_decode_line_udata_form(dbg,
                         lntype,lnform,
                         &line_ptr,
                         &dirindex,
                         line_ptr_end,
                         err);
                     if (res != DW_DLV_OK) {
                         free(filename_entry_pairs);
                         return res;
                     }
                     curline->fi_dir_index = dirindex;
                     curline->fi_dir_index_present = TRUE;
                     break;
                 case DW_LNCT_timestamp:
                     res = _dwarf_decode_line_udata_form(dbg,
                         lntype, lnform,
                         &line_ptr,
                         &curline->fi_time_last_mod,
                         line_ptr_end,
                         err);
                     if (res != DW_DLV_OK) {
                         free(filename_entry_pairs);
                         return res;
                     }
                     curline->fi_time_last_mod_present = TRUE;
                     break;
                 case DW_LNCT_size:
                     res = _dwarf_decode_line_udata_form(dbg,
                         lntype, lnform,
                         &line_ptr,
                         &curline->fi_file_length,
                         line_ptr_end,
                         err);
                     if (res != DW_DLV_OK) {
                         free(filename_entry_pairs);
                         return res;
                     }
                     curline->fi_file_length_present = TRUE;
                     break;
                 case DW_LNCT_MD5: { /* form DW_FORM_data16 */
                     if (filename_entry_pairs[j].up_second !=
                         DW_FORM_data16) {
                         free(filename_entry_pairs);
                         _dwarf_error(dbg, err,
                             DW_DLE_LNCT_MD5_WRONG_FORM);
                         return  DW_DLV_ERROR;
                     }
                     res = _dwarf_extract_data16(dbg,
                         line_ptr,
                         line_ptr,
                         line_ptr_end,
                         &curline->fi_md5_value,
                         err);
                     if (res != DW_DLV_OK) {
                         free(filename_entry_pairs);
                         return res;
                     }
                     curline->fi_md5_present = TRUE;
                     line_ptr = line_ptr +
                         sizeof(curline->fi_md5_value);
                     }
                     break;
 
                 default:
-                    free(filename_entry_pairs);
                     _dwarf_report_bad_lnct(dbg,
                         lntype,
                         DW_DLE_LINE_NUMBER_HEADER_ERROR,
                         "DW_DLE_LINE_NUMBER_HEADER_ERROR",
                         err);
                     free(filename_entry_pairs);
                     return (DW_DLV_ERROR);
                 }
                 if (line_ptr > line_ptr_end) {
                     free(filename_entry_pairs);
                     _dwarf_error(dbg, err,
                         DW_DLE_LINE_NUMBER_HEADER_ERROR);
                     return (DW_DLV_ERROR);
                 }
             }
         }
         line_context->lc_file_format_values = filename_entry_pairs;
         filename_entry_pairs = 0;
     }
     /*  For two-level line tables, read the
         subprograms table. */
     if (version == EXPERIMENTAL_LINE_TABLES_VERSION) {
         Dwarf_Unsigned subprog_format_count = 0;
         Dwarf_Unsigned *subprog_entry_types = 0;
         Dwarf_Unsigned *subprog_entry_forms = 0;
         Dwarf_Unsigned subprogs_count = 0;
         Dwarf_Unsigned i = 0;
         Dwarf_Unsigned j = 0;
         int dres = 0;
 
         if (line_ptr > line_ptr_end) {
             _dwarf_error(dbg, err, DW_DLE_LINE_NUMBER_HEADER_ERROR);
             return (DW_DLV_ERROR);
         }
         subprog_format_count = *(unsigned char *) line_ptr;
         line_ptr = line_ptr + sizeof(Dwarf_Small);
         subprog_entry_types = malloc(sizeof(Dwarf_Unsigned) *
             subprog_format_count);
         if (subprog_entry_types == NULL) {
             _dwarf_error(dbg, err, DW_DLE_ALLOC_FAIL);
             return (DW_DLV_ERROR);
         }
         subprog_entry_forms = malloc(sizeof(Dwarf_Unsigned) *
             subprog_format_count);
         if (subprog_entry_forms == NULL) {
             free(subprog_entry_types);
             _dwarf_error(dbg, err, DW_DLE_ALLOC_FAIL);
             return (DW_DLV_ERROR);
         }
 
         for (i = 0; i < subprog_format_count; i++) {
 
             dres=read_uword_de(&line_ptr,subprog_entry_types+i,
                 dbg,err,line_ptr_end);
             if (dres != DW_DLV_OK) {
                 free(subprog_entry_types);
                 free(subprog_entry_forms);
                 return dres;
             }
             dres=read_uword_de(&line_ptr,subprog_entry_forms+i,
                 dbg,err,line_ptr_end);
             if (dres != DW_DLV_OK) {
                 free(subprog_entry_types);
                 free(subprog_entry_forms);
                 return dres;
             }
         }
         dres=read_uword_de(&line_ptr,&subprogs_count,
             dbg,err,line_ptr_end);
         if (dres != DW_DLV_OK) {
             free(subprog_entry_types);
             free(subprog_entry_forms);
             return dres;
         }
         line_context->lc_subprogs =
             malloc(sizeof(struct Dwarf_Subprog_Entry_s) *
                 subprogs_count);
         if (line_context->lc_subprogs == NULL) {
             free(subprog_entry_types);
             free(subprog_entry_forms);
             _dwarf_error(dbg, err, DW_DLE_ALLOC_FAIL);
             return (DW_DLV_ERROR);
         }
         memset(line_context->lc_subprogs, 0,
             sizeof(struct Dwarf_Subprog_Entry_s) * subprogs_count);
         for (i = 0; i < subprogs_count; i++) {
             struct Dwarf_Subprog_Entry_s *curline =
                 line_context->lc_subprogs + i;
             for (j = 0; j < subprog_format_count; j++) {
                 Dwarf_Unsigned lntype =
                     subprog_entry_types[j];
                 Dwarf_Unsigned lnform =
                     subprog_entry_forms[j];
                 switch (lntype) {
                 case DW_LNCT_GNU_subprogram_name:
                     res = _dwarf_decode_line_string_form(dbg,
                         lntype,lnform,
                         local_length_size,
                         &line_ptr,
                         line_ptr_end,
                         (char **)&curline->ds_subprog_name,
                         err);
                     if (res != DW_DLV_OK) {
                         free(subprog_entry_types);
                         free(subprog_entry_forms);
                         return res;
                     }
                     break;
                 case DW_LNCT_GNU_decl_file:
                     res = _dwarf_decode_line_udata_form(dbg,
                         lntype,lnform,
                         &line_ptr,
                         &curline->ds_decl_file,
                         line_ptr_end,
                         err);
                     if (res != DW_DLV_OK) {
                         free(subprog_entry_forms);
                         free(subprog_entry_types);
                         return res;
                     }
                     break;
                 case DW_LNCT_GNU_decl_line:
                     res = _dwarf_decode_line_udata_form(dbg,
                         lntype,lnform,
                         &line_ptr,
                         &curline->ds_decl_line,
                         line_ptr_end,
                         err);
                     if (res != DW_DLV_OK) {
                         free(subprog_entry_forms);
                         free(subprog_entry_types);
                         return res;
                     }
                     break;
                 default:
                     free(subprog_entry_forms);
                     free(subprog_entry_types);
                     _dwarf_report_bad_lnct(dbg,
                         lntype,
                         DW_DLE_LINE_NUMBER_HEADER_ERROR,
                         "DW_DLE_LINE_NUMBER_HEADER_ERROR",
                         err);
                     return (DW_DLV_ERROR);
                 }
                 if (line_ptr >= line_ptr_end) {
                     free(subprog_entry_types);
                     free(subprog_entry_forms);
                     _dwarf_error_string(dbg, err,
                         DW_DLE_LINE_NUMBER_HEADER_ERROR,
                         "DW_DLE_LINE_NUMBER_HEADER_ERROR:"
                         " Reading suprogram entry DW_LNCT* types "
                         " we run off the end of the table");
                     return (DW_DLV_ERROR);
                 }
             }
         }
 
         free(subprog_entry_types);
         free(subprog_entry_forms);
         line_context->lc_subprogs_count = subprogs_count;
     }
     if (version == EXPERIMENTAL_LINE_TABLES_VERSION) {
         lp_begin = line_context->lc_line_prologue_start +
             line_context->lc_logicals_table_offset;
     } else {
         lp_begin = line_context->lc_line_prologue_start +
             line_context->lc_prologue_length;
     }
     if (line_ptr > line_ptr_end) {
         _dwarf_error(dbg, err, DW_DLE_LINE_OFFSET_BAD);
         return DW_DLV_ERROR;
     }
     if (line_ptr != lp_begin) {
         if (line_ptr > lp_begin) {
             _dwarf_error(dbg, err, DW_DLE_LINE_PROLOG_LENGTH_BAD);
             return (DW_DLV_ERROR);
         } else {
             /*  Bug in compiler. These
                 bytes are really part of the instruction
                 stream.  The line_context->lc_prologue_length is
                 wrong (12 too high).  */
             if (bogus_bytes_ptr) {
                 *bogus_bytes_ptr = line_ptr;
             }
             if (bogus_bytes) {
                 /*  How far off things are. We expect the
                     value 12 ! Negative value seems impossible. */
                 /*  ptrdiff_t is generated but not named */
                 *bogus_bytes = (lp_begin - line_ptr);
             }
         }
         /*  Ignore the lp_begin calc. Assume line_ptr right.
             Making up for compiler bug. */
         lp_begin = line_ptr;
     }
     line_context->lc_line_ptr_start = lp_begin;
     if (line_context->lc_actuals_table_offset) {
         /* This means two tables. */
         line_context->lc_table_count = 2;
     } else {
         if (line_context->lc_line_ptr_end > lp_begin) {
             line_context->lc_table_count = 1;
         } else {
             line_context->lc_table_count = 0;
         }
     }
     *updated_data_start_out = lp_begin;
     return DW_DLV_OK;
 }
 
 /*  Read one line table program. For two-level line tables, this
     function is called once for each table. */
