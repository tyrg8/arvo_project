commit 8b79248eabe494179bd7c97a1e6478959d12595e
Merge: a525fa19f eddcf0c0e
Author: JacobBarthelmeh <jacob@wolfssl.com>
Date:   Tue Apr 18 15:43:42 2023 -0600

    Merge pull request #6307 from SparkiDev/decode_ecdsa_sig_inited
    
    ECC, ASN.1: DecodeECC_DSA_Sig didn't handle r and s being initialized

diff --git a/wolfcrypt/src/asn.c b/wolfcrypt/src/asn.c
index 7d60e5bb0..326898170 100644
--- a/wolfcrypt/src/asn.c
+++ b/wolfcrypt/src/asn.c
@@ -1096,536 +1096,539 @@ static int GetASN_BitString(const byte* input, word32 idx, int length)
 /* Get the ASN.1 items from the BER encoding.
  *
  * @param [in] asn         ASN.1 item expected.
  * @param [in] data        Data array to place found item into.
  * @param [in] input       BER encoded data.
  * @param [in] idx         Starting index of item data.
  * @param [in] len         Length of input buffer upto end of this item's data.
  * @param [in] zeroPadded  INTEGER was zero padded to make positive.
  * @return  0 on success.
  * @return  ASN_PARSE_E when BER encoded data is invalid.
  * @return  ASN_EXPECT_0_E when NULL tagged item has a non-zero length.
  * @return  MP_INIT_E when the unable to initialize an mp_int.
  * @return  ASN_GETINT_E when the unable to convert data to an mp_int.
  * @return  BAD_STATE_E when the data type is not supported.
  * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
  */
 static int GetASN_StoreData(const ASNItem* asn, ASNGetData* data,
                             const byte* input, word32 idx, int len,
                             int zeroPadded)
 {
     int i;
     int err;
 
     /* Parse data based on data type to extract. */
     switch (data->dataType) {
         /* Parse a data into a number of specified bits. */
         case ASN_DATA_TYPE_WORD8:
             /* Check data is small enough to fit. */
             if (len != 1) {
             #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                 WOLFSSL_MSG_VSNPRINTF("Expecting one byte: %d", len);
             #endif
                 return ASN_PARSE_E;
             }
             /* Fill number with all of data. */
             *data->data.u8 = input[idx];
             break;
         case ASN_DATA_TYPE_WORD16:
             /* Check data is small enough to fit. */
             if (len == 0 || len > 2) {
             #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                 WOLFSSL_MSG_VSNPRINTF("Expecting 1 or 2 bytes: %d", len);
             #endif
                 return ASN_PARSE_E;
             }
             /* Fill number with all of data. */
             *data->data.u16 = 0;
             for (i = 0; i < len; i++) {
                 *data->data.u16 <<= 8;
                 *data->data.u16 |= input[idx + (word32)i] ;
             }
             break;
         case ASN_DATA_TYPE_WORD32:
             /* Check data is small enough to fit. */
             if (len == 0 || len > 4) {
             #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                 WOLFSSL_MSG_VSNPRINTF("Expecting 1 to 4 bytes: %d", len);
             #endif
                 return ASN_PARSE_E;
             }
             /* Fill number with all of data. */
             *data->data.u32 = 0;
             for (i = 0; i < len; i++) {
                 *data->data.u32 <<= 8;
                 *data->data.u32 |= input[idx + (word32)i] ;
             }
             break;
 
         case ASN_DATA_TYPE_BUFFER:
             /* Check buffer is big enough to hold data. */
             if (len > (int)*data->data.buffer.length) {
             #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                 WOLFSSL_MSG_VSNPRINTF("Buffer too small for data: %d %d", len,
                         *data->data.buffer.length);
             #endif
                 return ASN_PARSE_E;
             }
             /* Copy in data and record actual length seen. */
             XMEMCPY(data->data.buffer.data, input + idx, (size_t)len);
             *data->data.buffer.length = (word32)len;
             break;
 
         case ASN_DATA_TYPE_EXP_BUFFER:
             /* Check data is same size expected. */
             if (len != (int)data->data.ref.length) {
             #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                 WOLFSSL_MSG_VSNPRINTF("Data not expected length: %d %d", len,
                         data->data.ref.length);
             #endif
                 return ASN_PARSE_E;
             }
             /* Check data is same as expected. */
             if (XMEMCMP(data->data.ref.data, input + idx, (size_t)len) != 0) {
             #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                 WOLFSSL_MSG("Data not as expected");
             #endif
                 return ASN_PARSE_E;
             }
             break;
 
         case ASN_DATA_TYPE_MP:
         case ASN_DATA_TYPE_MP_POS_NEG:
             /* Initialize mp_int and read in big-endian byte array. */
             if (mp_init(data->data.mp) != MP_OKAY) {
             #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                 WOLFSSL_MSG_VSNPRINTF("Failed to init mp: %p", data->data.mp);
             #endif
                 return MP_INIT_E;
             }
+            FALL_THROUGH;
+        case ASN_DATA_TYPE_MP_INITED:
             err = mp_read_unsigned_bin(data->data.mp, (byte*)input + idx,
                                        (word32)len);
             if (err != 0) {
             #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                 WOLFSSL_MSG_VSNPRINTF("Failed to read mp: %d", err);
             #endif
                 mp_clear(data->data.mp);
                 return ASN_GETINT_E;
             }
         #ifdef HAVE_WOLF_BIGINT
             err = wc_bigint_from_unsigned_bin(&data->data.mp->raw, input + idx,
                     len);
             if (err != 0) {
             #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                 WOLFSSL_MSG_VSNPRINTF("Failed to create bigint: %d", err);
             #endif
                 mp_clear(data->data.mp);
                 return ASN_GETINT_E;
             }
         #endif /* HAVE_WOLF_BIGINT */
 
         #ifdef WOLFSSL_SP_INT_NEGATIVE
             /* Don't always read as positive. */
             if ((data->dataType == ASN_DATA_TYPE_MP_POS_NEG) && (!zeroPadded) &&
                 (input[idx] & 0x80)) {
                 #ifdef MP_NEG
                     data->data.mp->sign = MP_NEG;
                 #else
                     #ifdef OPENSSL_EXTRA
                         /* public API wolfSSL_ASN1_INTEGER_get() depends
                          * indirectly on negative bignum handling here.
                          */
                         #error OPENSSL_EXTRA requires negative bignum support.
                     #endif
                     #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                     WOLFSSL_MSG_VSNPRINTF("ASN negative integer without bignum support.");
                     #endif
                     mp_clear(data->data.mp);
                     return ASN_GETINT_E;
                 #endif
             }
         #else
             (void)zeroPadded;
         #endif
             break;
 
         case ASN_DATA_TYPE_CHOICE:
             /* Check if tag matched any of the choices specified. */
             for (i = 0; data->data.choice[i] != 0; i++)
                 if (data->data.choice[i] == data->tag)
                     break;
             if (data->data.choice[i] == 0) {
             #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                 WOLFSSL_MSG("Tag didn't match a choice");
             #endif
                 return ASN_PARSE_E;
             }
 
             /* Store data pointer and length for caller. */
             data->data.ref.data = input + idx;
             data->data.ref.length = (word32)len;
             break;
 
         case ASN_DATA_TYPE_NONE:
             /* Default behaviour based on tag. */
             if (asn->tag == ASN_BOOLEAN) {
                 /* BOOLEAN has only one byte of data in BER. */
                 if (len != 1) {
                 #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                     WOLFSSL_MSG_VSNPRINTF("BOOLEAN length too long: %d", len);
                 #endif
                     return ASN_PARSE_E;
                 }
                 if (data->data.u8 == NULL)
                     return BAD_STATE_E;
                 /* Store C boolean value. */
                 *data->data.u8 = (input[idx] != 0);
                 break;
             }
             if (asn->tag == ASN_TAG_NULL) {
                 /* NULL has no data in BER. */
                 if (len != 0) {
                 #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                     WOLFSSL_MSG_VSNPRINTF("NULL length too long: %d", len);
                 #endif
                     return ASN_EXPECT_0_E;
                 }
                 data->data.ref.data = input + idx;
                 break;
             }
             if (asn->tag == ASN_OBJECT_ID) {
                 word32 oidIdx = 0;
                 /* Store OID data pointer and length */
                 data->data.oid.data = input + idx;
                 data->data.oid.length = (word32)len;
                 /* Get the OID sum. */
                 err = GetOID(input + idx, &oidIdx, &data->data.oid.sum,
                         data->data.oid.type, len);
                 if (err < 0) {
                 #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                     WOLFSSL_MSG_VSNPRINTF("OID check failed: %d", err);
                 #endif
                     return err;
                 }
                 break;
             }
 
             /* Otherwise store data pointer and length. */
             data->data.ref.data = input + idx;
             data->data.ref.length = (word32)len;
             break;
 
     #ifdef DEBUG_WOLFSSL
         default:
             /* Bad ASN data type. */
         #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
             WOLFSSL_MSG_VSNPRINTF("Bad data type: %d", data->dataType);
         #endif
             return BAD_STATE_E;
     #endif
     }
 
     return 0;
 }
 
 /* Get the ASN.1 items from the BER encoding.
  *
  * @param [in]      asn       ASN.1 items expected.
  * @param [in]      data      Data array to place found items into.
  * @param [in]      count     Count of items to parse.
  * @param [in]      complete  Whether the whole buffer is to be used up.
  * @param [in]      input     BER encoded data.
  * @param [in, out] inOutIdx  On in, starting index of data.
  *                            On out, end of parsed data.
  * @param [in]      length    Length of input buffer.
  * @return  0 on success.
  * @return  ASN_PARSE_E when BER encoded data does not match ASN.1 items or
  *          is invalid.
  * @return  BUFFER_E when data in buffer is too small.
  * @return  ASN_OBJECT_ID_E when the expected OBJECT_ID tag is not found.
  * @return  ASN_BITSTR_E when the expected BIT_STRING tag is not found.
  * @return  ASN_EXPECT_0_E when the INTEGER has the MSB set or NULL has a
  *          non-zero length.
  * @return  MP_INIT_E when the unable to initialize an mp_int.
  * @return  ASN_GETINT_E when the unable to convert data to an mp_int.
  * @return  BAD_STATE_E when the data type is not supported.
  * @return  ASN_UNKNOWN_OID_E when the OID cannot be verified.
  */
 int GetASN_Items(const ASNItem* asn, ASNGetData *data, int count, int complete,
                  const byte* input, word32* inOutIdx, word32 length)
 {
     int    i;
     int    j;
     int    err;
     int    len;
     /* Current index into buffer. */
     word32 idx = *inOutIdx;
     /* Initialize the end index at each depth to be the length. */
     word32 endIdx[GET_ASN_MAX_DEPTH] = { length, length, length, length, length,
                                          length, length };
     /* Set choices to -1 to indicate they haven't been seen or found. */
     signed char   choiceMet[GET_ASN_MAX_CHOICES] = { -1, -1 };
     /* Not matching a choice right now. */
     int    choice = 0;
     /* Current depth of ASN.1 item. */
     int    depth;
     /* Minimum depth value seen. */
     int    minDepth;
     /* Integer had a zero prepended. */
     int    zeroPadded;
 
 #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
     WOLFSSL_ENTER("GetASN_Items");
 #endif
 
     /* Start depth at first items depth. */
     minDepth = depth = asn[0].depth;
     /* Check every ASN.1 item. */
     for (i = 0; i < count; i++) {
         /* Store offset of ASN.1 item. */
         data[i].offset = idx;
         /* Length of data in ASN.1 item starts empty. */
         data[i].length = 0;
         /* Get current item depth. */
         depth = asn[i].depth;
     #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
         if (depth > GET_ASN_MAX_DEPTH) {
             WOLFSSL_MSG("Depth in template too large");
             return ASN_PARSE_E;
         }
     #endif
         /* Keep track of minimum depth. */
         if (depth < minDepth) {
             minDepth = depth;
         }
 
         /* Reset choice if different from previous. */
         if (choice > 0 && asn[i].optional != choice) {
             choice = 0;
         }
         /* Check if first of numbered choice. */
         if (choice == 0 && asn[i].optional > 1) {
             choice = asn[i].optional;
             if (choiceMet[choice - 2] == -1) {
                 /* Choice seen but not found a match yet. */
                 choiceMet[choice - 2] = 0;
             }
         }
 
         /* Check for end of data or not a choice and tag not matching. */
         if (idx == endIdx[depth] || (data[i].dataType != ASN_DATA_TYPE_CHOICE &&
                               (input[idx] & ~ASN_CONSTRUCTED) != asn[i].tag)) {
             if (asn[i].optional) {
                 /* Skip over ASN.1 items underneath this optional item. */
                 for (j = i + 1; j < count; j++) {
                     if (asn[i].depth >= asn[j].depth)
                         break;
                     data[j].offset = idx;
                     data[j].length = 0;
                 }
                 i = j - 1;
                 continue;
             }
 
             /* Check for end of data. */
             if (idx == length) {
         #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                 WOLFSSL_MSG_VSNPRINTF(
                     "%2d: %4d %4d %c %*s %-16s%*s  (index past end)",
                     i, data[i].offset, data[i].length,
                     asn[i].constructed ? '+' : ' ', asn[i].depth, "",
                     TagString(asn[i].tag), 6 - asn[i].depth, "");
                 WOLFSSL_MSG_VSNPRINTF("Index past end of data: %d %d", idx,
                         length);
         #endif
                 return BUFFER_E;
             }
         #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
             /* Show expected versus found. */
             WOLFSSL_MSG_VSNPRINTF(
                 "%2d: %4d %4d %c %*s %-16s%*s  Tag=0x%02x (%s)",
                 i, data[i].offset, data[i].length,
                 asn[i].constructed ? '+' : ' ', asn[i].depth, "",
                 TagString(asn[i].tag), 6 - asn[i].depth, "",
                 input[idx], TagString(input[idx]));
         #endif
             /* Check for end of data at this depth. */
             if (idx == endIdx[depth]) {
             #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                 WOLFSSL_MSG_VSNPRINTF("Index past outer item: %d %d", idx,
                         endIdx[depth]);
             #endif
                 return ASN_PARSE_E;
             }
 
             /* Expecting an OBJECT_ID */
             if (asn[i].tag == ASN_OBJECT_ID) {
             #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                 WOLFSSL_MSG("Expecting OBJECT ID");
             #endif
                 return ASN_OBJECT_ID_E;
             }
             /* Expecting a BIT_STRING */
             if (asn[i].tag == ASN_BIT_STRING) {
             #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                 WOLFSSL_MSG("Expecting BIT STRING");
             #endif
                 return ASN_BITSTR_E;
             }
             /* Not the expected tag. */
         #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
             WOLFSSL_MSG("Bad tag");
         #endif
             return ASN_PARSE_E;
         }
 
         /* Store found tag in data. */
         data[i].tag = input[idx];
         if (data[i].dataType != ASN_DATA_TYPE_CHOICE) {
             int constructed = (input[idx] & ASN_CONSTRUCTED) == ASN_CONSTRUCTED;
             /* Check constructed match expected for non-choice ASN.1 item. */
             if (asn[i].constructed != constructed) {
             #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                 WOLFSSL_MSG_VSNPRINTF(
                         "%2d: %4d %4d %c %*s %-16s%*s  Tag=0x%02x (%s)",
                         i, data[i].offset, data[i].length,
                         asn[i].constructed ? '+' : ' ', asn[i].depth, "",
                         TagString(asn[i].tag), 6 - asn[i].depth, "",
                         input[idx], TagString(input[idx]));
                 if (!constructed) {
                     WOLFSSL_MSG("Not constructed");
                 }
                 else {
                     WOLFSSL_MSG("Not expected to be constructed");
                 }
             #endif
                 return ASN_PARSE_E;
             }
         }
         /* Move index to start of length. */
         idx++;
         /* Get the encoded length. */
         if (GetASN_Length(input, &idx, &len, endIdx[depth], 1) < 0) {
         #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
             WOLFSSL_MSG_VSNPRINTF("%2d: idx=%d len=%d end=%d", i, idx, len,
                     endIdx[depth]);
         #endif
             return ASN_PARSE_E;
         }
         /* Store length of data. */
         data[i].length = (word32)len;
         /* Note the max length of items under this one. */
         endIdx[depth + 1] = idx + (word32)len;
         if (choice > 1) {
             /* Note we found a number choice. */
             choiceMet[choice - 2] = 1;
         }
 
     #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
         WOLFSSL_MSG_VSNPRINTF("%2d: %4d %4d %c %*s %-16s", i,
                 data[i].offset, data[i].length, asn[i].constructed ? '+' : ' ',
                 asn[i].depth, "", TagString(data[i].tag));
     #endif
 
         /* Assume no zero padding on INTEGER. */
         zeroPadded = 0;
         /* Check data types that prepended a byte. */
         if (asn[i].tag == ASN_INTEGER) {
             /* Check validity of first byte. */
             err = GetASN_Integer(input, idx, len,
-                    data[i].dataType == ASN_DATA_TYPE_MP);
+                    data[i].dataType == ASN_DATA_TYPE_MP ||
+                    data[i].dataType == ASN_DATA_TYPE_MP_INITED);
             if (err != 0)
                 return err;
             if (len > 1 && input[idx] == 0) {
                 zeroPadded = 1;
                 /* Move over prepended byte. */
                 idx++;
                 len--;
             }
         }
         else if (asn[i].tag == ASN_BIT_STRING) {
             /* Check prepended byte is correct. */
             err = GetASN_BitString(input, idx, len);
             if (err != 0)
                 return err;
             /* Move over prepended byte. */
             idx++;
             len--;
         }
         else if ((asn[i].tag == ASN_OBJECT_ID) && (len < 3)) {
         #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
             WOLFSSL_MSG_VSNPRINTF("OID length must be 3 or more: %d", len);
         #endif
             return ASN_PARSE_E;
         }
 
         /* Don't parse data if only header required. */
         if (asn[i].headerOnly) {
             /* Store reference to data and length. */
             data[i].data.ref.data = input + idx;
             data[i].data.ref.length = (word32)len;
             continue;
         }
 
         /* Store the data at idx in the ASN data item. */
         err = GetASN_StoreData(&asn[i], &data[i], input, idx, len, zeroPadded);
         if (err != 0) {
             return err;
         }
 
         /* Move index to next item. */
         idx += (word32)len;
 
         /* When matched numbered choice ... */
         if (asn[i].optional > 1) {
             /* Skip over other ASN.1 items of the same number. */
             for (j = i + 1; j < count; j++) {
                 if (asn[j].depth <= asn[i].depth &&
                                            asn[j].optional != asn[i].optional) {
                    break;
                 }
             }
             i = j - 1;
         }
     }
 
     if (complete) {
         /* When expecting ASN.1 items to completely use data, check we did. */
         for (j = depth; j > minDepth; j--) {
             if (idx < endIdx[j]) {
             #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
                 WOLFSSL_MSG_VSNPRINTF(
                     "More data in constructed item at depth: %d", j - 1);
             #endif
                 return ASN_PARSE_E;
             }
         }
     }
 
     /* Check all choices where met - found an item for them. */
     for (j = 0; j < GET_ASN_MAX_CHOICES; j++) {
         if (choiceMet[j] == 0) {
         #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
             WOLFSSL_MSG_VSNPRINTF("No choice seen: %d", j + 2);
         #endif
             return ASN_PARSE_E;
         }
     }
 
     /* Return index after ASN.1 data has been parsed. */
     *inOutIdx = idx;
 
     return 0;
 }
 
 #ifdef WOLFSSL_DEBUG_ASN_TEMPLATE
 /* Calculate the size of the DER encoding.
  *
  * Call SetASN_Items() to write encoding to a buffer.
  *
  * @param [in]      asn    ASN.1 items to encode.
  * @param [in, out] data   Data to place in each item. Lengths set were not
  *                         known.
  * @param [in]      count  Count of items to encode.
  * @param [out]     len    Length of the DER encoding.
  * @return  Size of the DER encoding in bytes.
  */
@@ -1856,16 +1859,27 @@ void GetASN_ExpBuffer(ASNGetData *dataASN, const byte* data, word32 length)
 /* Setup ASN data item to get a number into an mp_int.
  *
  * @param [in] dataASN  Dynamic ASN data item.
  * @param [in] num      Multi-precision number object.
  */
 void GetASN_MP(ASNGetData *dataASN, mp_int* num)
 {
     dataASN->dataType = ASN_DATA_TYPE_MP;
     dataASN->data.mp  = num;
 }
 
+/* Setup ASN data item to get a number into an mp_int that is initialized.
+ *
+ * @param [in] dataASN  Dynamic ASN data item.
+ * @param [in] num      Multi-precision number object.
+ */
+void GetASN_MP_Inited(ASNGetData *dataASN, mp_int* num)
+{
+    dataASN->dataType = ASN_DATA_TYPE_MP_INITED;
+    dataASN->data.mp  = num;
+}
+
 /* Setup ASN data item to get a positive or negative number into an mp_int.
  *
  * @param [in] dataASN  Dynamic ASN data item.
  * @param [in] num      Multi-precision number object.
  */
@@ -3239,39 +3253,41 @@ int GetInt(mp_int* mpi, const byte* input, word32* inOutIdx, word32 maxIdx)
 
 #if (defined(HAVE_ECC) || !defined(NO_DSA)) && !defined(WOLFSSL_ASN_TEMPLATE)
 static int GetIntPositive(mp_int* mpi, const byte* input, word32* inOutIdx,
-    word32 maxIdx)
+    word32 maxIdx, int initNum)
 {
     word32 idx = *inOutIdx;
     int    ret;
     int    length;
 
     ret = GetASNInt(input, &idx, &length, maxIdx);
     if (ret != 0)
         return ret;
 
     if (((input[idx] & 0x80) == 0x80) && (input[idx - 1] != 0x00))
         return MP_INIT_E;
 
-    if (mp_init(mpi) != MP_OKAY)
-        return MP_INIT_E;
+    if (initNum) {
+        if (mp_init(mpi) != MP_OKAY)
+            return MP_INIT_E;
+    }
 
     if (mp_read_unsigned_bin(mpi, input + idx, (word32)length) != 0) {
         mp_clear(mpi);
         return ASN_GETINT_E;
     }
 
 #ifdef HAVE_WOLF_BIGINT
     if (wc_bigint_from_unsigned_bin(&mpi->raw, input + idx, length) != 0) {
         mp_clear(mpi);
         return ASN_GETINT_E;
     }
 #endif /* HAVE_WOLF_BIGINT */
 
     *inOutIdx = idx + (word32)length;
 
     return 0;
 }
 #endif /* (ECC || !NO_DSA) && !WOLFSSL_ASN_TEMPLATE */
 
 #ifndef WOLFSSL_ASN_TEMPLATE
 #if (!defined(NO_RSA) && !defined(HAVE_USER_RSA)) || !defined(NO_DSA)
@@ -31206,85 +31222,97 @@ int DecodeECC_DSA_Sig_Bin(const byte* sig, word32 sigLen, byte* r, word32* rLen,
 }
 
 int DecodeECC_DSA_Sig(const byte* sig, word32 sigLen, mp_int* r, mp_int* s)
+{
+    return DecodeECC_DSA_Sig_Ex(sig, sigLen, r, s, 1);
+}
+
+int DecodeECC_DSA_Sig_Ex(const byte* sig, word32 sigLen, mp_int* r, mp_int* s,
+    int init)
 {
 #ifndef WOLFSSL_ASN_TEMPLATE
     word32 idx = 0;
     int    len = 0;
 
     if (GetSequence(sig, &idx, &len, sigLen) < 0) {
         return ASN_ECC_KEY_E;
     }
 
 #ifndef NO_STRICT_ECDSA_LEN
     /* enable strict length checking for signature */
     if (sigLen != idx + (word32)len) {
         return ASN_ECC_KEY_E;
     }
 #else
     /* allow extra signature bytes at end */
     if ((word32)len > (sigLen - idx)) {
         return ASN_ECC_KEY_E;
     }
 #endif
 
-    if (GetIntPositive(r, sig, &idx, sigLen) < 0) {
+    if (GetIntPositive(r, sig, &idx, sigLen, init) < 0) {
         return ASN_ECC_KEY_E;
     }
 
-    if (GetIntPositive(s, sig, &idx, sigLen) < 0) {
+    if (GetIntPositive(s, sig, &idx, sigLen, init) < 0) {
         mp_clear(r);
         return ASN_ECC_KEY_E;
     }
 
 #ifndef NO_STRICT_ECDSA_LEN
     /* sanity check that the index has been advanced all the way to the end of
      * the buffer */
     if (idx != sigLen) {
         mp_clear(r);
         mp_clear(s);
         return ASN_ECC_KEY_E;
     }
 #endif
 
     return 0;
 #else
     ASNGetData dataASN[dsaSigASN_Length];
     word32 idx = 0;
     int ret;
 
     /* Clear dynamic data and set mp_ints to put r and s into. */
     XMEMSET(dataASN, 0, sizeof(dataASN));
-    GetASN_MP(&dataASN[DSASIGASN_IDX_R], r);
-    GetASN_MP(&dataASN[DSASIGASN_IDX_S], s);
+    if (init) {
+        GetASN_MP(&dataASN[DSASIGASN_IDX_R], r);
+        GetASN_MP(&dataASN[DSASIGASN_IDX_S], s);
+    }
+    else {
+        GetASN_MP_Inited(&dataASN[DSASIGASN_IDX_R], r);
+        GetASN_MP_Inited(&dataASN[DSASIGASN_IDX_S], s);
+    }
 
     /* Decode the DSA signature. */
     ret = GetASN_Items(dsaSigASN, dataASN, dsaSigASN_Length, 0, sig, &idx,
                        sigLen);
 #ifndef NO_STRICT_ECDSA_LEN
     /* sanity check that the index has been advanced all the way to the end of
      * the buffer */
     if ((ret == 0) && (idx != sigLen)) {
         ret = ASN_ECC_KEY_E;
     }
 #endif
     if (ret != 0) {
         mp_clear(r);
         mp_clear(s);
     }
 
     return ret;
 #endif /* WOLFSSL_ASN_TEMPLATE */
 }
 #endif
 
 
 #ifdef WOLFSSL_ASN_TEMPLATE
 #ifdef WOLFSSL_CUSTOM_CURVES
 /* Convert data to hex string.
  *
  * Big-endian byte array is converted to big-endian hexadecimal string.
  *
  * @param [in]  input  Buffer containing data.
  * @param [in]  inSz   Size of data in buffer.
  * @param [out] out    Buffer to hold hex string.
  */
diff --git a/wolfcrypt/src/ecc.c b/wolfcrypt/src/ecc.c
index 3445c4023..3e5341f0a 100644
--- a/wolfcrypt/src/ecc.c
+++ b/wolfcrypt/src/ecc.c
@@ -7943,159 +7943,164 @@ WOLFSSL_ABI
 int wc_ecc_verify_hash(const byte* sig, word32 siglen, const byte* hash,
                        word32 hashlen, int* res, ecc_key* key)
 {
     int err;
 
 #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)
     mp_int *r = NULL, *s = NULL;
 #else
     DECL_MP_INT_SIZE_DYN(r, ECC_KEY_MAX_BITS(key), MAX_ECC_BITS_USE);
     DECL_MP_INT_SIZE_DYN(s, ECC_KEY_MAX_BITS(key), MAX_ECC_BITS_USE);
 #endif
 #ifdef WOLFSSL_ASYNC_CRYPT
     int isPrivateKeyOnly = 0;
 #endif
 
     if (sig == NULL || hash == NULL || res == NULL || key == NULL) {
         return ECC_BAD_ARG_E;
     }
 
 #ifdef WOLF_CRYPTO_CB
     if (key->devId != INVALID_DEVID) {
         err = wc_CryptoCb_EccVerify(sig, siglen, hash, hashlen, res, key);
     #ifndef WOLF_CRYPTO_CB_ONLY_ECC
         if (err != CRYPTOCB_UNAVAILABLE)
             return err;
         /* fall-through when unavailable */
     #endif
     }
     #ifdef WOLF_CRYPTO_CB_ONLY_ECC
     else {
         err = NO_VALID_DEVID;
     }
     #endif
 #endif
 
 #ifndef WOLF_CRYPTO_CB_ONLY_ECC
 
 #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)
     err = wc_ecc_alloc_async(key);
     if (err != 0)
         return err;
     r = key->r;
     s = key->s;
 #else
     NEW_MP_INT_SIZE(r, ECC_KEY_MAX_BITS(key), key->heap, DYNAMIC_TYPE_ECC);
 #ifdef MP_INT_SIZE_CHECK_NULL
     if (r == NULL)
         return MEMORY_E;
 #endif
     NEW_MP_INT_SIZE(s, ECC_KEY_MAX_BITS(key), key->heap, DYNAMIC_TYPE_ECC);
 #ifdef MP_INT_SIZE_CHECK_NULL
     if (s == NULL) {
         FREE_MP_INT_SIZE(r, key->heap, DYNAMIC_TYPE_ECC);
         return MEMORY_E;
     }
 #endif
     err = INIT_MP_INT_SIZE(r, ECC_KEY_MAX_BITS(key));
     if (err != 0) {
         FREE_MP_INT_SIZE(s, key->heap, DYNAMIC_TYPE_ECC);
         FREE_MP_INT_SIZE(r, key->heap, DYNAMIC_TYPE_ECC);
         return err;
     }
     err = INIT_MP_INT_SIZE(s, ECC_KEY_MAX_BITS(key));
     if (err != 0) {
         FREE_MP_INT_SIZE(s, key->heap, DYNAMIC_TYPE_ECC);
         FREE_MP_INT_SIZE(r, key->heap, DYNAMIC_TYPE_ECC);
         return err;
     }
 #endif /* WOLFSSL_ASYNC_CRYPT */
 
     switch (key->state) {
         case ECC_STATE_NONE:
         case ECC_STATE_VERIFY_DECODE:
             key->state = ECC_STATE_VERIFY_DECODE;
 
             /* default to invalid signature */
             *res = 0;
 
+            /* Decode ASN.1 ECDSA signature. */
+        #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)
             /* Note, DecodeECC_DSA_Sig() calls mp_init() on r and s.
              * If either of those don't allocate correctly, none of
              * the rest of this function will execute, and everything
              * gets cleaned up at the end. */
-            /* decode DSA header */
             err = DecodeECC_DSA_Sig(sig, siglen, r, s);
+        #else
+            /* r and s are initialized. */
+            err = DecodeECC_DSA_Sig_Ex(sig, siglen, r, s, 0);
+        #endif
             if (err < 0) {
                 break;
             }
             FALL_THROUGH;
 
         case ECC_STATE_VERIFY_DO:
             key->state = ECC_STATE_VERIFY_DO;
         #ifdef WOLFSSL_ASYNC_CRYPT
             if (key->type == ECC_PRIVATEKEY_ONLY) {
                 isPrivateKeyOnly = 1;
             }
         #endif
             err = wc_ecc_verify_hash_ex(r, s, hash, hashlen, res, key);
 
         #ifndef WOLFSSL_ASYNC_CRYPT
             /* done with R/S */
             mp_clear(r);
             mp_clear(s);
             FREE_MP_INT_SIZE(s, key->heap, DYNAMIC_TYPE_ECC);
             FREE_MP_INT_SIZE(r, key->heap, DYNAMIC_TYPE_ECC);
         #ifdef MP_INT_SIZE_CHECK_NULL
             r = NULL;
             s = NULL;
         #endif
         #endif
 
             if (err < 0) {
                 break;
             }
             FALL_THROUGH;
 
         case ECC_STATE_VERIFY_RES:
             key->state = ECC_STATE_VERIFY_RES;
             err = 0;
             break;
 
         default:
             err = BAD_STATE_E;
     }
 
 #ifdef WOLFSSL_ASYNC_CRYPT
     /* if async pending then return and skip done cleanup below */
     if (err == WC_PENDING_E) {
         if (!isPrivateKeyOnly) /* do not advance state if doing make pub key */
             key->state++;
         return err;
     }
 #endif
 
     /* cleanup */
 #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_ECC)
     wc_ecc_free_async(key);
 #else
     FREE_MP_INT_SIZE(s, key->heap, DYNAMIC_TYPE_ECC);
     FREE_MP_INT_SIZE(r, key->heap, DYNAMIC_TYPE_ECC);
 #endif
 
     /* make sure required variables are reset */
     wc_ecc_reset(key);
 #else
     (void)siglen;
     (void)hashlen;
     (void)s;
     (void)r;
     (void)err;
 #endif /* WOLF_CRYPTO_CB_ONLY_ECC */
 
     return err;
 }
 #endif /* !NO_ASN */
 
 #ifndef WOLF_CRYPTO_CB_ONLY_ECC
 
 #if !defined(WOLFSSL_STM32_PKA) && !defined(WOLFSSL_PSOC6_CRYPTO) && \
     !defined(WOLF_CRYPTO_CB_ONLY_ECC)
diff --git a/wolfssl/wolfcrypt/asn.h b/wolfssl/wolfcrypt/asn.h
index 136318430..39a95096b 100644
--- a/wolfssl/wolfcrypt/asn.h
+++ b/wolfssl/wolfcrypt/asn.h
@@ -169,26 +169,28 @@ enum ASN_Tags {
 #ifdef WOLFSSL_ASN_TEMPLATE
 /* Different data types that can be stored in ASNGetData/ASNSetData. */
 enum ASNItem_DataType {
     /* Default for tag type. */
     ASN_DATA_TYPE_NONE           = 0,
     /* 8-bit integer value. */
     ASN_DATA_TYPE_WORD8          = 1,
     /* 16-bit integer value. */
     ASN_DATA_TYPE_WORD16         = 2,
     /* 32-bit integer value. */
     ASN_DATA_TYPE_WORD32         = 4,
     /* Buffer with data and length. */
     ASN_DATA_TYPE_BUFFER         = 5,
     /* An expected/required buffer with data and length. */
     ASN_DATA_TYPE_EXP_BUFFER     = 6,
     /* Replace the item with buffer (data and length). */
     ASN_DATA_TYPE_REPLACE_BUFFER = 7,
     /* Big number as an mp_int. */
     ASN_DATA_TYPE_MP             = 8,
+    /* Big number as an mp_int that has already been initialized. */
+    ASN_DATA_TYPE_MP_INITED      = 9,
     /* Big number as a positive or negative mp_int. */
-    ASN_DATA_TYPE_MP_POS_NEG     = 9,
+    ASN_DATA_TYPE_MP_POS_NEG     = 10,
     /* ASN.1 CHOICE. A 0 terminated list of tags that are valid. */
-    ASN_DATA_TYPE_CHOICE         = 10
+    ASN_DATA_TYPE_CHOICE         = 11
 };
 
 /* A template entry describing an ASN.1 item. */
@@ -311,6 +313,7 @@ WOLFSSL_LOCAL void GetASN_Buffer(ASNGetData *dataASN, byte* data,
 WOLFSSL_LOCAL void GetASN_ExpBuffer(ASNGetData *dataASN, const byte* data,
     word32 length);
 WOLFSSL_LOCAL void GetASN_MP(ASNGetData *dataASN, mp_int* num);
+WOLFSSL_LOCAL void GetASN_MP_Inited(ASNGetData *dataASN, mp_int* num);
 WOLFSSL_LOCAL void GetASN_MP_PosNeg(ASNGetData *dataASN, mp_int* num);
 WOLFSSL_LOCAL void GetASN_Choice(ASNGetData *dataASN, const byte* options);
 WOLFSSL_LOCAL void GetASN_Boolean(ASNGetData *dataASN, byte* num);
@@ -332,330 +335,341 @@ WOLFSSL_LOCAL void SetASN_MP(ASNSetData *dataASN, mp_int* num);
 WOLFSSL_LOCAL void SetASN_OID(ASNSetData *dataASN, int oid, int oidType);
 #else
 /* Setup ASN data item to get an 8-bit number.
  *
  * @param [in] dataASN  Dynamic ASN data item.
  * @param [in] num      Pointer to an 8-bit variable.
  */
 #define GetASN_Int8Bit(dataASN, num)                                   \
     do {                                                               \
         (dataASN)->dataType = ASN_DATA_TYPE_WORD8;                     \
         (dataASN)->data.u8  = num;                                     \
     } while (0)
 
 /* Setup ASN data item to get a 16-bit number.
  *
  * @param [in] dataASN  Dynamic ASN data item.
  * @param [in] num      Pointer to a 16-bit variable.
  */
 #define GetASN_Int16Bit(dataASN, num)                                  \
     do {                                                               \
         (dataASN)->dataType = ASN_DATA_TYPE_WORD16;                    \
         (dataASN)->data.u16 = num;                                     \
     } while (0)
 
 /* Setup ASN data item to get a 32-bit number.
  *
  * @param [in] dataASN  Dynamic ASN data item.
  * @param [in] num      Pointer to a 32-bit variable.
  */
 #define GetASN_Int32Bit(dataASN, num)                                  \
     do {                                                               \
         (dataASN)->dataType = ASN_DATA_TYPE_WORD32;                    \
         (dataASN)->data.u32 = num;                                     \
     } while (0)
 
 /* Setup ASN data item to get data into a buffer of a specific length.
  *
  * @param [in] dataASN  Dynamic ASN data item.
  * @param [in] d        Buffer to hold data.
  * @param [in] l        Length of buffer in bytes.
  */
 #define GetASN_Buffer(dataASN, d, l)                                   \
     do {                                                               \
         (dataASN)->dataType           = ASN_DATA_TYPE_BUFFER;          \
         (dataASN)->data.buffer.data   = d;                             \
         (dataASN)->data.buffer.length = l;                             \
     } while (0)
 
 /* Setup ASN data item to check parsed data against expected buffer.
  *
  * @param [in] dataASN  Dynamic ASN data item.
  * @param [in] d        Buffer containing expected data.
  * @param [in] l        Length of buffer in bytes.
  */
 #define GetASN_ExpBuffer(dataASN, d, l)                                \
     do {                                                               \
         (dataASN)->dataType        = ASN_DATA_TYPE_EXP_BUFFER;         \
         (dataASN)->data.ref.data   = d;                                \
         (dataASN)->data.ref.length = l;                                \
     } while (0)
 
 /* Setup ASN data item to get a number into an mp_int.
  *
  * @param [in] dataASN  Dynamic ASN data item.
  * @param [in] num      Multi-precision number object.
  */
 #define GetASN_MP(dataASN, num)                                        \
     do {                                                               \
         (dataASN)->dataType = ASN_DATA_TYPE_MP;                        \
         (dataASN)->data.mp  = num;                                     \
     } while (0)
 
+/* Setup ASN data item to get a number into an mp_int that is initialized.
+ *
+ * @param [in] dataASN  Dynamic ASN data item.
+ * @param [in] num      Multi-precision number object.
+ */
+#define GetASN_MP_Inited(dataASN, num)                                 \
+    do {                                                               \
+        (dataASN)->dataType = ASN_DATA_TYPE_MP_INITED;                 \
+        (dataASN)->data.mp  = num;                                     \
+    } while (0)
+
 /* Setup ASN data item to get a positive or negative number into an mp_int.
  *
  * @param [in] dataASN  Dynamic ASN data item.
  * @param [in] num      Multi-precision number object.
  */
 #define GetASN_MP_PosNeg(dataASN, num)                                 \
     do {                                                               \
         (dataASN)->dataType = ASN_DATA_TYPE_MP_POS_NEG;                \
         (dataASN)->data.mp  = num;                                     \
     } while (0)
 
 /* Setup ASN data item to be a choice of tags.
  *
  * @param [in] dataASN  Dynamic ASN data item.
  * @param [in] choice   0 terminated list of tags that are valid.
  */
 #define GetASN_Choice(dataASN, options)                                \
     do {                                                               \
         (dataASN)->dataType    = ASN_DATA_TYPE_CHOICE;                 \
         (dataASN)->data.choice = options;                              \
     } while (0)
 
 /* Setup ASN data item to get a boolean value.
  *
  * @param [in] dataASN  Dynamic ASN data item.
  * @param [in] num      Pointer to an 8-bit variable.
  */
 #define GetASN_Boolean(dataASN, num)                                   \
     do {                                                               \
         (dataASN)->dataType = ASN_DATA_TYPE_NONE;                      \
         (dataASN)->data.u8  = num;                                     \
     } while (0)
 
 /* Setup ASN data item to be a an OID of a specific type.
  *
  * @param [in] dataASN  Dynamic ASN data item.
  * @param [in] oidType  Type of OID to expect.
  */
 #define GetASN_OID(dataASN, oidType)                                   \
     (dataASN)->data.oid.type = oidType
 
 /* Get the data and length from an ASN data item.
  *
  * @param [in]  dataASN  Dynamic ASN data item.
  * @param [out] d        Pointer to data of item.
  * @param [out] l        Length of buffer in bytes.
  */
 #define GetASN_GetConstRef(dataASN, d, l)                              \
     do {                                                               \
         *(d) = (dataASN)->data.ref.data;                               \
         *(l) = (dataASN)->data.ref.length;                             \
     } while (0)
 
 /* Get the data and length from an ASN data item.
  *
  * @param [in]  dataASN  Dynamic ASN data item.
  * @param [out] d        Pointer to data of item.
  * @param [out] l        Length of buffer in bytes.
  */
 #define GetASN_GetRef(dataASN, d, l)                                   \
     do {                                                               \
         *(d) = (byte*)(dataASN)->data.ref.data;                        \
         *(l) =        (dataASN)->data.ref.length;                      \
     } while (0)
 
 /* Get the data and length from an ASN data item that is an OID.
  *
  * @param [in]  dataASN  Dynamic ASN data item.
  * @param [out] d        Pointer to .
  * @param [out] l        Length of buffer in bytes.
  */
 #define GetASN_OIDData(dataASN, d, l)                                  \
     do {                                                               \
         *(d) = (byte*)(dataASN)->data.oid.data;                        \
         *(l) =        (dataASN)->data.oid.length;                      \
     } while (0)
 
 /* Setup an ASN data item to set a boolean.
  *
  * @param [in] dataASN  Dynamic ASN data item.
  * @param [in] val      Boolean value.
  */
 #define SetASN_Boolean(dataASN, val)                                   \
     do {                                                               \
         (dataASN)->dataType = ASN_DATA_TYPE_NONE;                      \
         (dataASN)->data.u8  = val;                                     \
     } while (0)
 
 /* Setup an ASN data item to set an 8-bit number.
  *
  * @param [in] dataASN  Dynamic ASN data item.
  * @param [in] num      8-bit number to set.
  */
 #define SetASN_Int8Bit(dataASN, num)                                   \
     do {                                                               \
         (dataASN)->dataType = ASN_DATA_TYPE_WORD8;                     \
         (dataASN)->data.u8  = num;                                     \
     } while (0)
 
 /* Setup an ASN data item to set a 16-bit number.
  *
  * @param [in] dataASN  Dynamic ASN data item.
  * @param [in] num      16-bit number to set.
  */
 #define SetASN_Int16Bit(dataASN, num)                                  \
     do {                                                               \
         (dataASN)->dataType = ASN_DATA_TYPE_WORD16;                    \
         (dataASN)->data.u16 = num;                                     \
     } while (0)
 
 /* Setup an ASN data item to set the data in a buffer.
  *
  * @param [in] dataASN  Dynamic ASN data item.
  * @param [in] d        Buffer containing data to set.
  * @param [in] l        Length of data in buffer in bytes.
  */
 #define SetASN_Buffer(dataASN, d, l)                                   \
     do {                                                               \
         (dataASN)->data.buffer.data   = d;                             \
         (dataASN)->data.buffer.length = l;                             \
     } while (0)
 
 /* Setup an ASN data item to set the DER encode data in a buffer.
  *
  * @param [in] dataASN  Dynamic ASN data item.
  * @param [in] d        Buffer containing BER encoded data to set.
  * @param [in] l        Length of data in buffer in bytes.
  */
 #define SetASN_ReplaceBuffer(dataASN, d, l)                            \
     do {                                                               \
         (dataASN)->dataType           = ASN_DATA_TYPE_REPLACE_BUFFER;  \
         (dataASN)->data.buffer.data   = d;                             \
         (dataASN)->data.buffer.length = l;                             \
     } while (0)
 
 /* Setup an ASN data item to set an muli-precision number.
  *
  * @param [in] dataASN  Dynamic ASN data item.
  * @param [in] num      Multi-precision number.
  */
 #define SetASN_MP(dataASN, num)                                        \
     do {                                                               \
         (dataASN)->dataType = ASN_DATA_TYPE_MP;                        \
         (dataASN)->data.mp  = num;                                     \
     } while (0)
 
 /* Setup an ASN data item to set an OID based on id and type.
  *
  * oid and oidType pair are unique.
  *
  * @param [in] dataASN  Dynamic ASN data item.
  * @param [in] oid      OID identifier.
  * @param [in] oidType  Type of OID.
  */
 #define SetASN_OID(dataASN, oid, oidType)                              \
     (dataASN)->data.buffer.data = OidFromId(oid, oidType,              \
                                        &(dataASN)->data.buffer.length)
 #endif /* WOLFSSL_ASN_TEMPLATE_TYPE_CHECK */
 
 
 /* Get address at the start of the BER item.
  *
  * @param [in] dataASN  Dynamic ASN data item.
  * @param [in] in       Input buffer.
  * @return  Address at start of BER item.
  */
 #define GetASNItem_Addr(dataASN, in)                                   \
     ((in) + (dataASN).offset)
 
 /* Get length of a BER item - including tag and length.
  *
  * @param [in] dataASN  Dynamic ASN data item.
  * @param [in] in       Input buffer.
  * @return  Length of a BER item.
  */
 #define GetASNItem_Length(dataASN, in)                                 \
     ((dataASN).length + (word32)((dataASN).data.buffer.data - (in)) -  \
                                                      (dataASN).offset)
 
 /* Get the index of a BER item's data.
  *
  * @param [in] dataASN  Dynamic ASN data item.
  * @param [in] in       Input buffer.
  * @return  Index of a BER item's data.
  */
 #define GetASNItem_DataIdx(dataASN, in)                                \
     (word32)((dataASN).data.ref.data - (in))
 
 /* Get the end index of a BER item - index of the start of the next item.
  *
  * @param [in] dataASN  Dynamic ASN data item.
  * @param [in] in       Input buffer.
  * @return  End index of a BER item.
  */
 #define GetASNItem_EndIdx(dataASN, in)                                 \
     ((word32)((dataASN).data.ref.data - (in)) +                        \
                                             (dataASN).data.ref.length)
 
 /* For a BIT_STRING, get the unused bits byte.
  *
  * @param [in] dataASN  Dynamic ASN data item.
  * @return  Unused bits byte in BIT_STRING.
  */
 #define GetASNItem_UnusedBits(dataASN)                                 \
     (*((dataASN).data.ref.data - 1))
 
 /* Set the data items at indices start to end inclusive to not be encoded.
  *
  * @param [in] dataASN  Dynamic ASN data item.
  * @param [in] start    First item not to be encoded.
  * @param [in] end      Last item not to be encoded.
  */
 #define SetASNItem_NoOut(dataASN, start, end)                          \
     do {                                                               \
         int ii;                                                        \
         for (ii = (start); ii <= (end); ii++) {                        \
             (dataASN)[ii].noOut = 1;                                   \
         }                                                              \
     }                                                                  \
     while (0)
 
 /* Set the data items below node to not be encoded.
  *
  * @param [in] dataASN  Dynamic ASN data item.
  * @param [in] node     Node who's children should not be encoded.
  * @param [in] dataASNLen Number of items in dataASN.
  */
 #define SetASNItem_NoOutBelow(dataASN, asn, node, dataASNLen)          \
     do {                                                               \
         int ii;                                                        \
         for (ii = (node) + 1; ii < (int)(dataASNLen); ii++) {          \
             if ((asn)[ii].depth <= (asn)[node].depth)                  \
                 break;                                                 \
             (dataASN)[ii].noOut = 1;                                   \
         }                                                              \
     }                                                                  \
     while (0)
 
 /* Set the node and all nodes below to not be encoded.
  *
  * @param [in] dataASN  Dynamic ASN data item.
  * @param [in] node     Node which should not be encoded. Child nodes will
  *                      also not be encoded.
  * @param [in] dataASNLen Number of items in dataASN.
  */
 #define SetASNItem_NoOutNode(dataASN, asn, node, dataASNLen)           \
     do {                                                               \
         int ii;                                                        \
         (dataASN)[node].noOut = 1;                                     \
         for (ii = (node) + 1; ii < (int)(dataASNLen); ii++) {          \
             if ((asn)[ii].depth <= (asn)[node].depth)                  \
                 break;                                                 \
             (dataASN)[ii].noOut = 1;                                   \
         }                                                              \
     }                                                                  \
     while (0)
 
 #endif /* WOLFSSL_ASN_TEMPLATE */
@@ -2190,17 +2204,19 @@ WOLFSSL_LOCAL int wc_EncodeName(EncodedName* name, const char* nameStr,
         char nameType, byte type);
 WOLFSSL_LOCAL int wc_EncodeNameCanonical(EncodedName* name, const char* nameStr,
                                 char nameType, byte type);
 
 #if defined(HAVE_ECC) || !defined(NO_DSA)
     /* ASN sig helpers */
     WOLFSSL_LOCAL int StoreECC_DSA_Sig(byte* out, word32* outLen, mp_int* r,
                                       mp_int* s);
     WOLFSSL_LOCAL int StoreECC_DSA_Sig_Bin(byte* out, word32* outLen,
         const byte* r, word32 rLen, const byte* s, word32 sLen);
     WOLFSSL_LOCAL int DecodeECC_DSA_Sig_Bin(const byte* sig, word32 sigLen,
         byte* r, word32* rLen, byte* s, word32* sLen);
     WOLFSSL_LOCAL int DecodeECC_DSA_Sig(const byte* sig, word32 sigLen,
                                        mp_int* r, mp_int* s);
+    WOLFSSL_LOCAL int DecodeECC_DSA_Sig_Ex(const byte* sig, word32 sigLen,
+                                       mp_int* r, mp_int* s, int init);
 #endif
 #ifndef NO_DSA
 WOLFSSL_LOCAL int StoreDSAParams(byte*, word32*, const mp_int*, const mp_int*,
