commit 5fabd43f6af6c5f432c543b8a84e690dfa31a3b2
Author: chamarthi.kishore <chamarthi.kishore@ittiam.com>
Date:   Fri Feb 24 23:10:35 2023 +0530

    svcdec: Bug fix in header parsing w.r.t u1_extended_spatial_scalability_idc
    
    BUG=oss-fuzz: 56176
    Test: svc_dec_fuzzer

diff --git a/decoder/svc/isvcd_mode_mv_resamp.c b/decoder/svc/isvcd_mode_mv_resamp.c
index 49adebc..322dbec 100644
--- a/decoder/svc/isvcd_mode_mv_resamp.c
+++ b/decoder/svc/isvcd_mode_mv_resamp.c
@@ -2937,139 +2937,139 @@ WORD32 isvcd_interlyr_motion_mode_pred_dyadic(void *pv_comp_mode_mv_ctxt, void *
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : isvcd_compute_scaled_offsets                              */
 /*                                                                           */
 /*  Description   : this module does the projection of the current layer     */
 /*                   points (x,0) and (0,y) on to the reference layer and    */
 /*                   gets the 1/16 sample of the reference location          */
 /*                   x ranges from 0 - frame width                           */
 /*                   y ranges from 0 - frame height                          */
 /*                   this projection is done for LUMA only                   */
 /*  Inputs        :  ps_curr_lyr_slice_prms: pointer to current layer slice  */
 /*                                           parameters                      */
 /*                   ps_ref_lyr_slice_prms: pointer to ref layer slice prms  */
 /*                   pi2_offset_x         : pointer to store x projected     */
 /*                   pi2_offset_y         : pointer to store y projected     */
 /*  Globals       :  none                                                    */
 /*  Processing    :  it store the projected values for those points in the   */
 /*                   crop window                                             */
 /*  Outputs       :  projected locations                                     */
 /*  Returns       :  none                                                    */
 /*                                                                           */
 /*  Issues        : assumes that outside crop window no projection           */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         06 09 2021   vijayakumar          creation                        */
 /*                                                                           */
 /*****************************************************************************/
 WORD32 isvcd_compute_scaled_offsets(res_prms_t *ps_curr_res_prms, res_prms_t *ps_ref_res_prms,
                                     WORD16 *pi2_offset_x, WORD16 *pi2_offset_y, UWORD8 u1_level_idc)
 {
     WORD32 i4_offset_x, i4_offset_y;
     UWORD32 i4_scaled_ref_lyr_width;
     UWORD32 i4_scaled_ref_lyr_height;
     UWORD32 i4_ref_lyr_width;
     UWORD32 i4_ref_lyr_height;
     UWORD32 i4_shift_x, i4_shift_y;
     UWORD32 i4_scale_x, i4_scale_y;
     WORD32 i4_cntr;
     WORD32 i4_scale_add_x, i4_scale_add_y;
     WORD32 i4_curr_lyr_width, i4_curr_lyr_height;
 
     if((NULL == ps_curr_res_prms) || (NULL == ps_ref_res_prms) || (NULL == pi2_offset_x) ||
        (NULL == pi2_offset_y))
     {
         return NOT_OK;
     }
     /* initial calculation */
     i4_offset_x = ps_curr_res_prms->s_ref_lyr_scaled_offset.i2_left;
     i4_offset_y = ps_curr_res_prms->s_ref_lyr_scaled_offset.i2_top;
 
     /* get the width and height */
     i4_scaled_ref_lyr_width = ps_curr_res_prms->u2_scaled_ref_width;
     i4_scaled_ref_lyr_height = ps_curr_res_prms->u2_scaled_ref_height;
     i4_ref_lyr_width = ps_ref_res_prms->i4_res_width;
     i4_ref_lyr_height = ps_ref_res_prms->i4_res_height;
     i4_curr_lyr_width = ps_curr_res_prms->i4_res_width;
     i4_curr_lyr_height = ps_curr_res_prms->i4_res_height;
 
     /* derive shift x and y based on level idd */
     if(u1_level_idc <= 30)
     {
         i4_shift_x = 16;
         i4_shift_y = 16;
     }
     else
     {
         i4_shift_x = 31 - isvcd_get_ceil_log2(i4_ref_lyr_width);
         i4_shift_y = 31 - isvcd_get_ceil_log2(i4_ref_lyr_height);
     }
 
     /* assert on max ranges of width and shift values */
     if((i4_ref_lyr_width > H264_MAX_FRAME_WIDTH) ||
        (i4_scaled_ref_lyr_width > H264_MAX_FRAME_WIDTH) ||
        (i4_ref_lyr_height > H264_MAX_FRAME_HEIGHT) ||
        (i4_scaled_ref_lyr_height > H264_MAX_FRAME_HEIGHT) ||
        (i4_curr_lyr_width > H264_MAX_FRAME_WIDTH) || (i4_curr_lyr_height > H264_MAX_FRAME_HEIGHT))
     {
         return NOT_OK;
     }
 
     /* calculate scale factor x and y */
     i4_scale_x = (((UWORD32) i4_ref_lyr_width << i4_shift_x) + (i4_scaled_ref_lyr_width >> 1)) /
                  i4_scaled_ref_lyr_width;
 
     i4_scale_y = (((UWORD32) i4_ref_lyr_height << i4_shift_y) + (i4_scaled_ref_lyr_height >> 1)) /
                  i4_scaled_ref_lyr_height;
 
     /* calcualte the values to be added based on left and top offset */
-    i4_scale_add_x = (1 << (i4_shift_x - 1)) - i4_offset_x * i4_scale_x;
-    i4_scale_add_y = (1 << (i4_shift_y - 1)) - i4_offset_y * i4_scale_y;
+    i4_scale_add_x = (1 << (i4_shift_x - 1)) - (i4_offset_x * (WORD32) i4_scale_x);
+    i4_scale_add_y = (1 << (i4_shift_y - 1)) - (i4_offset_y * (WORD32) i4_scale_y);
 
     /* derive the projected locations in the reference layer */
     for(i4_cntr = 0; i4_cntr < i4_curr_lyr_width; i4_cntr++)
     {
         WORD32 i4_ref_x;
         i4_ref_x = (i4_cntr * i4_scale_x + i4_scale_add_x) >> i4_shift_x;
         *pi2_offset_x++ = (WORD16) i4_ref_x;
     }
 
     /* derive the projected locations in the reference layer */
     for(i4_cntr = 0; i4_cntr < i4_curr_lyr_height; i4_cntr++)
     {
         WORD32 i4_ref_y;
         i4_ref_y = (i4_cntr * i4_scale_y + i4_scale_add_y) >> i4_shift_y;
         *pi2_offset_y++ = (WORD16) i4_ref_y;
     }
     return OK;
 }
 
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : isvcd_comp_mode_mv_res_init                               */
 /*                                                                           */
 /*  Description   : this function calculates the scale factors and initialise*/
 /*                  the context structure                                    */
 /*                                                                           */
 /*  Inputs        : pv_comp_mode_mv_ctxt: handle to private structure        */
 /*                  ps_curr_lyr_res_prms: pointer to current resolution      */
 /*                                               params                      */
 /*                  pi2_ref_loc_x             : pointer to buffer having the */
 /*                                              projected locations horz     */
 /*                  pi2_ref_loc_y             : pointer to buffer having the */
 /*                                              projected location vertical  */
 /*  Globals       : none                                                     */
 /*  Processing    : it calculates the scale factors and stores it            */
 /*                                                                           */
 /*  Outputs       : none                                                     */
 /*  Returns       : none                                                     */
 /*                                                                           */
 /*  Issues        : none                                                     */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         06 09 2021   vijayakumar          creation                        */
 /*                                                                           */
 /*****************************************************************************/
diff --git a/decoder/svc/isvcd_nal_parse_structs.h b/decoder/svc/isvcd_nal_parse_structs.h
index fb1cb61..890ff29 100644
--- a/decoder/svc/isvcd_nal_parse_structs.h
+++ b/decoder/svc/isvcd_nal_parse_structs.h
@@ -84,27 +84,30 @@ static __inline UWORD32 GET_NAL_BUF_INC(WORD32 i4_derived_nal_type)
 static __inline void UPDATE_NAL_BUF_PTR(UWORD8 **ppu1_buf, WORD32 i4_derived_nal_type,
                                         UWORD32 *pu4_bytes_left)
 {
     UWORD8 *pu1_buf_ptr;
     UWORD64 u4_inc;
 
     /* Align the start of the structure */
 
     pu1_buf_ptr = *ppu1_buf;
 
     /* Account for the vcl or non-vcl header */
     u4_inc = GET_NAL_BUF_INC(i4_derived_nal_type);
     u4_inc = UP_ALIGN_8(u4_inc);
     pu1_buf_ptr += u4_inc;
 
     /* Update the pointers */
+    if(*pu4_bytes_left >= u4_inc)
+    {
     *pu4_bytes_left -= u4_inc;
+    }
     *ppu1_buf = pu1_buf_ptr;
 }
 
 /*****************************************************************************/
 /* Typedefs                                                                  */
 /*****************************************************************************/
 
 /*****************************************************************************/
 /* Enums                                                                     */
 /*****************************************************************************/
diff --git a/decoder/svc/isvcd_parse_headers.c b/decoder/svc/isvcd_parse_headers.c
index 6c3e9fb..b549f4c 100644
--- a/decoder/svc/isvcd_parse_headers.c
+++ b/decoder/svc/isvcd_parse_headers.c
@@ -118,777 +118,778 @@ dif
 *
 * \brief
 *    Decodes Sequence parameter set from the SVC bitstream
 *
 * \return
 *    0 on Success and Error code otherwise
 **************************************************************************
 */
 WORD32 isvcd_parse_subset_sps(svc_dec_lyr_struct_t *ps_svc_lyr_dec, dec_bit_stream_t *ps_bitstrm)
 {
     dec_struct_t *ps_dec = &ps_svc_lyr_dec->s_dec;
     UWORD8 i;
     dec_seq_params_t *ps_seq = NULL;
     dec_svc_seq_params_t *ps_subset_seq = NULL;
     dec_subset_seq_params_t *ps_seq_svc_ext;
     UWORD8 u1_profile_idc, u1_level_idc, u1_seq_parameter_set_id, u1_mb_aff_flag = 0;
     UWORD16 i2_max_frm_num;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
     UWORD8 u1_frm, uc_constraint_set0_flag, uc_constraint_set1_flag, uc_constraint_set2_flag;
     WORD32 i4_cropped_ht, i4_cropped_wd;
     UWORD32 u4_temp;
     UWORD64 u8_temp;
     UWORD32 u4_pic_height_in_map_units, u4_pic_width_in_mbs;
     UWORD32 u2_pic_wd = 0;
     UWORD32 u2_pic_ht = 0;
     UWORD32 u2_frm_wd_y = 0;
     UWORD32 u2_frm_ht_y = 0;
     UWORD32 u2_frm_wd_uv = 0;
     UWORD32 u2_frm_ht_uv = 0;
     UWORD32 u2_crop_offset_y = 0;
     UWORD32 u2_crop_offset_uv = 0;
     WORD32 ret;
     /* High profile related syntax element */
     WORD32 i4_i;
     /* G050 */
     UWORD8 u1_frame_cropping_flag,
         u1_frame_cropping_rect_left_ofst = 0, u1_frame_cropping_rect_right_ofst = 0,
         u1_frame_cropping_rect_top_ofst = 0, u1_frame_cropping_rect_bottom_ofst = 0;
     /* G050 */
     /*--------------------------------------------------------------------*/
     /* Decode seq_parameter_set_id and profile and level values           */
     /*--------------------------------------------------------------------*/
     SWITCHONTRACE;
     u1_profile_idc = ih264d_get_bits_h264(ps_bitstrm, 8);
     COPYTHECONTEXT("SPS: profile_idc", u1_profile_idc);
 
     /* G050 */
     uc_constraint_set0_flag = ih264d_get_bit_h264(ps_bitstrm);
     uc_constraint_set1_flag = ih264d_get_bit_h264(ps_bitstrm);
     uc_constraint_set2_flag = ih264d_get_bit_h264(ps_bitstrm);
     UNUSED(uc_constraint_set1_flag);
     UNUSED(uc_constraint_set2_flag);
 
     /*****************************************************/
     /* Read 5 bits for uc_constraint_set3_flag (1 bit)   */
     /* and reserved_zero_4bits (4 bits) - Sushant        */
     /*****************************************************/
     ih264d_get_bits_h264(ps_bitstrm, 5);
     /* G050 */
     u1_level_idc = (UWORD8) ih264d_get_bits_h264(ps_bitstrm, 8);
     COPYTHECONTEXT("SPS: u4_level_idc", u1_level_idc);
 
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u4_temp & MASK_ERR_SEQ_SET_ID) return ERROR_INV_SPS_PPS_T;
     u1_seq_parameter_set_id = u4_temp;
     COPYTHECONTEXT("SPS: seq_parameter_set_id", u1_seq_parameter_set_id);
 
     if(u1_seq_parameter_set_id >= MAX_NUM_SEQ_PARAMS) return ERROR_INV_SPS_PPS_T;
 
     /*--------------------------------------------------------------------*/
     /* Find an seq param entry in seqparam array of decStruct             */
     /*--------------------------------------------------------------------*/
     ps_subset_seq = ps_svc_lyr_dec->pv_scratch_subset_sps;
     memset(ps_subset_seq, 0, sizeof(dec_svc_seq_params_t));
     ps_seq = ps_dec->pv_scratch_sps_pps;
     memset(ps_seq, 0, sizeof(dec_seq_params_t));
 
     if(ps_dec->i4_header_decoded & 1)
     {
         if(NULL != ps_dec->ps_cur_sps)
             *ps_seq = *ps_dec->ps_cur_sps;
         else
             return ERROR_INV_SPS_PPS_T;
     }
 
     ps_seq->u1_profile_idc = u1_profile_idc;
     ps_seq->u1_level_idc = u1_level_idc;
     ps_seq->u1_seq_parameter_set_id = u1_seq_parameter_set_id;
 
     /* subset_seq_sps_will be stored from location 32 : MAX_NUM_SEQ_PARAMS*/
     u1_seq_parameter_set_id += MAX_NUM_SEQ_PARAMS;
     ps_subset_seq->ps_seq = &ps_dec->ps_sps[u1_seq_parameter_set_id];
 
     if((ps_dec->i4_header_decoded & 1) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
        (ps_dec->ps_sps[u1_seq_parameter_set_id].u1_profile_idc != u1_profile_idc))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
 
     if((ps_dec->i4_header_decoded & 1) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
        (ps_dec->ps_sps[u1_seq_parameter_set_id].u1_level_idc != u1_level_idc))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
     /*******************************************************************/
     /* Initializations for high profile - Sushant                      */
     /*******************************************************************/
     ps_seq->i4_chroma_format_idc = 1;
     ps_seq->i4_bit_depth_luma_minus8 = 0;
     ps_seq->i4_bit_depth_chroma_minus8 = 0;
     ps_seq->i4_qpprime_y_zero_transform_bypass_flag = 0;
     ps_seq->i4_seq_scaling_matrix_present_flag = 0;
     if(u1_profile_idc == HIGH_PROFILE_IDC || u1_profile_idc == SCALABLE_BASELINE_PROFILE_IDC ||
        u1_profile_idc == SCALABLE_HIGH_PROFILE_IDC)
     {
         /* reading chroma_format_idc   */
         ps_seq->i4_chroma_format_idc = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
         /* Monochrome is not supported */
         if(ps_seq->i4_chroma_format_idc != 1)
         {
             return ERROR_FEATURE_UNAVAIL;
         }
 
         /* reading bit_depth_luma_minus8   */
         ps_seq->i4_bit_depth_luma_minus8 = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
         if(ps_seq->i4_bit_depth_luma_minus8 != 0)
         {
             return ERROR_FEATURE_UNAVAIL;
         }
 
         /* reading bit_depth_chroma_minus8   */
         ps_seq->i4_bit_depth_chroma_minus8 = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
         if(ps_seq->i4_bit_depth_chroma_minus8 != 0)
         {
             return ERROR_FEATURE_UNAVAIL;
         }
 
         /* reading qpprime_y_zero_transform_bypass_flag   */
         ps_seq->i4_qpprime_y_zero_transform_bypass_flag = (WORD32) ih264d_get_bit_h264(ps_bitstrm);
 
         if(ps_seq->i4_qpprime_y_zero_transform_bypass_flag != 0)
         {
             return ERROR_INV_SPS_PPS_T;
         }
 
         /* reading seq_scaling_matrix_present_flag   */
         ps_seq->i4_seq_scaling_matrix_present_flag = (WORD32) ih264d_get_bit_h264(ps_bitstrm);
 
         if(ps_seq->i4_seq_scaling_matrix_present_flag)
         {
             for(i4_i = 0; i4_i < 8; i4_i++)
             {
                 ps_seq->u1_seq_scaling_list_present_flag[i4_i] = ih264d_get_bit_h264(ps_bitstrm);
 
                 /* initialize u1_use_default_scaling_matrix_flag[i4_i] to zero */
                 /* before calling scaling list                             */
                 ps_seq->u1_use_default_scaling_matrix_flag[i4_i] = 0;
 
                 if(ps_seq->u1_seq_scaling_list_present_flag[i4_i])
                 {
                     if(i4_i < 6)
                     {
                         ret = ih264d_scaling_list(ps_seq->i2_scalinglist4x4[i4_i], 16,
                                                   &ps_seq->u1_use_default_scaling_matrix_flag[i4_i],
                                                   ps_bitstrm);
                     }
                     else
                     {
                         ret = ih264d_scaling_list(ps_seq->i2_scalinglist8x8[i4_i - 6], 64,
                                                   &ps_seq->u1_use_default_scaling_matrix_flag[i4_i],
                                                   ps_bitstrm);
                     }
                     if(ret != OK)
                     {
                         return ret;
                     }
                 }
             }
         }
     }
     /*--------------------------------------------------------------------*/
     /* Decode MaxFrameNum                                                 */
     /*--------------------------------------------------------------------*/
     u8_temp = (UWORD64) 4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u8_temp > MAX_BITS_IN_FRAME_NUM)
     {
         return ERROR_INV_SPS_PPS_T;
     }
     ps_seq->u1_bits_in_frm_num = (UWORD8) u8_temp;
     COPYTHECONTEXT("SPS: log2_max_frame_num_minus4", (ps_seq->u1_bits_in_frm_num - 4));
 
     i2_max_frm_num = (1 << (ps_seq->u1_bits_in_frm_num));
     ps_seq->u2_u4_max_pic_num_minus1 = i2_max_frm_num - 1;
     /*--------------------------------------------------------------------*/
     /* Decode picture order count and related values                      */
     /*--------------------------------------------------------------------*/
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
     if(u4_temp > MAX_PIC_ORDER_CNT_TYPE)
     {
         return ERROR_INV_POC_TYPE_T;
     }
     ps_seq->u1_pic_order_cnt_type = u4_temp;
     COPYTHECONTEXT("SPS: pic_order_cnt_type", ps_seq->u1_pic_order_cnt_type);
 
     ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = 1;
     if(ps_seq->u1_pic_order_cnt_type == 0)
     {
         u8_temp = (UWORD64) 4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         if(u8_temp > MAX_BITS_IN_POC_LSB)
         {
             return ERROR_INV_SPS_PPS_T;
         }
         ps_seq->u1_log2_max_pic_order_cnt_lsb_minus = (UWORD8) u8_temp;
         ps_seq->i4_max_pic_order_cntLsb = (1 << u8_temp);
         COPYTHECONTEXT("SPS: log2_max_pic_order_cnt_lsb_minus4", (u8_temp - 4));
     }
     else if(ps_seq->u1_pic_order_cnt_type == 1)
     {
         ps_seq->u1_delta_pic_order_always_zero_flag = ih264d_get_bit_h264(ps_bitstrm);
         COPYTHECONTEXT("SPS: delta_pic_order_always_zero_flag",
                        ps_seq->u1_delta_pic_order_always_zero_flag);
 
         ps_seq->i4_ofst_for_non_ref_pic = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: offset_for_non_ref_pic", ps_seq->i4_ofst_for_non_ref_pic);
 
         ps_seq->i4_ofst_for_top_to_bottom_field = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: offset_for_top_to_bottom_field",
                        ps_seq->i4_ofst_for_top_to_bottom_field);
 
         u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         if(u4_temp > 255) return ERROR_INV_SPS_PPS_T;
         ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = u4_temp;
         COPYTHECONTEXT("SPS: num_ref_frames_in_pic_order_cnt_cycle",
                        ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle);
 
         for(i = 0; i < ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle; i++)
         {
             ps_seq->i4_ofst_for_ref_frame[i] = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
             COPYTHECONTEXT("SPS: offset_for_ref_frame", ps_seq->i4_ofst_for_ref_frame[i]);
         }
     }
 
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
     if((u4_temp > H264_MAX_REF_PICS))
     {
         return ERROR_NUM_REF;
     }
 
     /* Compare with older num_ref_frames is header is already once */
     if((ps_dec->i4_header_decoded & 1) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
        (ps_dec->ps_sps[u1_seq_parameter_set_id].u1_num_ref_frames != u4_temp))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
     ps_seq->u1_num_ref_frames = u4_temp;
     COPYTHECONTEXT("SPS: num_ref_frames", ps_seq->u1_num_ref_frames);
 
     ps_seq->u1_gaps_in_frame_num_value_allowed_flag = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("SPS: gaps_in_frame_num_value_allowed_flag",
                    ps_seq->u1_gaps_in_frame_num_value_allowed_flag);
     /* SVC_DEC_REVIEW */
     ps_seq->u1_gaps_in_frame_num_value_allowed_flag = 0;
 
     /*--------------------------------------------------------------------*/
     /* Decode FrameWidth and FrameHeight and related values               */
     /*--------------------------------------------------------------------*/
     u8_temp = (UWORD64) 1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     /* Check  for unsupported resolutions*/
     if(u8_temp > (H264_MAX_FRAME_WIDTH >> 4))
     {
         return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
     }
     u4_pic_width_in_mbs = (UWORD32) u8_temp;
     COPYTHECONTEXT("SPS: pic_width_in_mbs_minus1", u4_pic_width_in_mbs - 1);
 
     u8_temp = (UWORD64) 1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u8_temp > (H264_MAX_FRAME_HEIGHT >> 4))
     {
         return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
     }
     u4_pic_height_in_map_units = (UWORD32) u8_temp;
 
     ps_seq->u2_frm_wd_in_mbs = u4_pic_width_in_mbs;
     ps_seq->u2_frm_ht_in_mbs = u4_pic_height_in_map_units;
 
     u2_pic_wd = (u4_pic_width_in_mbs << 4);
     u2_pic_ht = (u4_pic_height_in_map_units << 4);
     /*--------------------------------------------------------------------*/
     /* Get the value of MaxMbAddress and Number of bits needed for it     */
     /*--------------------------------------------------------------------*/
     ps_seq->u2_max_mb_addr = (ps_seq->u2_frm_wd_in_mbs * ps_seq->u2_frm_ht_in_mbs) - 1;
 
     ps_seq->u2_total_num_of_mbs = ps_seq->u2_max_mb_addr + 1;
 
     ps_seq->u1_level_idc = ih264d_correct_level_idc(u1_level_idc, ps_seq->u2_total_num_of_mbs);
 
     u1_frm = ih264d_get_bit_h264(ps_bitstrm);
 
     if((ps_dec->i4_header_decoded & 1) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
        (ps_dec->ps_sps[u1_seq_parameter_set_id].u1_frame_mbs_only_flag != u1_frm))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
     ps_seq->u1_frame_mbs_only_flag = u1_frm;
 
     COPYTHECONTEXT("SPS: frame_mbs_only_flag", u1_frm);
 
     if(!u1_frm) u1_mb_aff_flag = ih264d_get_bit_h264(ps_bitstrm);
     if((ps_dec->i4_header_decoded & 1) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
        (ps_dec->ps_sps[u1_seq_parameter_set_id].u1_mb_aff_flag != u1_mb_aff_flag))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
     if(!u1_frm)
     {
         u2_pic_ht <<= 1;
         ps_seq->u1_mb_aff_flag = u1_mb_aff_flag;
         COPYTHECONTEXT("SPS: mb_adaptive_frame_field_flag", ps_seq->u1_mb_aff_flag);
     }
     else
         ps_seq->u1_mb_aff_flag = 0;
 
     ps_seq->u1_direct_8x8_inference_flag = ih264d_get_bit_h264(ps_bitstrm);
 
     COPYTHECONTEXT("SPS: direct_8x8_inference_flag", ps_seq->u1_direct_8x8_inference_flag);
 
     /* G050 */
     u1_frame_cropping_flag = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("SPS: frame_cropping_flag", u1_frame_cropping_flag);
 
     if(u1_frame_cropping_flag)
     {
         u1_frame_cropping_rect_left_ofst = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: frame_cropping_rect_left_offset", u1_frame_cropping_rect_left_ofst);
         u1_frame_cropping_rect_right_ofst = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: frame_cropping_rect_right_offset", u1_frame_cropping_rect_right_ofst);
         u1_frame_cropping_rect_top_ofst = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: frame_cropping_rect_top_offset", u1_frame_cropping_rect_top_ofst);
         u1_frame_cropping_rect_bottom_ofst = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SPS: frame_cropping_rect_bottom_offset",
                        u1_frame_cropping_rect_bottom_ofst);
     }
     /* G050 */
     ps_seq->u1_vui_parameters_present_flag = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("SPS: vui_parameters_present_flag", ps_seq->u1_vui_parameters_present_flag);
 
     u2_frm_wd_y = u2_pic_wd + (UWORD8) (PAD_LEN_Y_H << 1);
     if(1 == ps_dec->u4_share_disp_buf)
     {
         if(ps_dec->u4_app_disp_width > u2_frm_wd_y) u2_frm_wd_y = ps_dec->u4_app_disp_width;
     }
 
     u2_frm_ht_y = u2_pic_ht + (UWORD8) (PAD_LEN_Y_V << 2);
     u2_frm_wd_uv = u2_pic_wd + (UWORD8) (PAD_LEN_UV_H << 2);
     u2_frm_wd_uv = MAX(u2_frm_wd_uv, u2_frm_wd_y);
 
     u2_frm_ht_uv = (u2_pic_ht >> 1) + (UWORD8) (PAD_LEN_UV_V << 2);
     u2_frm_ht_uv = MAX(u2_frm_ht_uv, (u2_frm_ht_y >> 1));
 
     /* Calculate display picture width, height and start u4_ofst from YUV420 */
     /* pictute buffers as per cropping information parsed above             */
     {
         UWORD16 u2_rgt_ofst = 0;
         UWORD16 u2_lft_ofst = 0;
         UWORD16 u2_top_ofst = 0;
         UWORD16 u2_btm_ofst = 0;
         UWORD8 u1_frm_mbs_flag;
         UWORD8 u1_vert_mult_factor;
 
         if(u1_frame_cropping_flag)
         {
             /* Calculate right and left u4_ofst for cropped picture           */
             u2_rgt_ofst = u1_frame_cropping_rect_right_ofst << 1;
             u2_lft_ofst = u1_frame_cropping_rect_left_ofst << 1;
 
             /* Know frame MBs only u4_flag                                      */
             u1_frm_mbs_flag = (1 == ps_seq->u1_frame_mbs_only_flag);
 
             /* Simplify the vertical u4_ofst calculation from field/frame     */
             u1_vert_mult_factor = (2 - u1_frm_mbs_flag);
 
             /* Calculate bottom and top u4_ofst for cropped  picture          */
             u2_btm_ofst = (u1_frame_cropping_rect_bottom_ofst << u1_vert_mult_factor);
             u2_top_ofst = (u1_frame_cropping_rect_top_ofst << u1_vert_mult_factor);
         }
 
         /* Calculate u4_ofst from start of YUV 420 picture buffer to start of*/
         /* cropped picture buffer                                           */
         u2_crop_offset_y = (u2_frm_wd_y * u2_top_ofst) + (u2_lft_ofst);
         u2_crop_offset_uv =
             (u2_frm_wd_uv * (u2_top_ofst >> 1)) + (u2_lft_ofst >> 1) * YUV420SP_FACTOR;
         /* Calculate the display picture width and height based on crop      */
         /* information                                                       */
         i4_cropped_ht = (WORD32) u2_pic_ht - (WORD32) (u2_btm_ofst + u2_top_ofst);
         i4_cropped_wd = (WORD32) u2_pic_wd - (WORD32) (u2_rgt_ofst + u2_lft_ofst);
 
         if((i4_cropped_ht < MB_SIZE) || (i4_cropped_wd < MB_SIZE))
         {
             return ERROR_INV_SPS_PPS_T;
         }
 
         if((ps_dec->i4_header_decoded & 1) &&
            (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
            (ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id].u2_pic_wd != u2_pic_wd))
         {
             ps_dec->u1_res_changed = 1;
             return IVD_RES_CHANGED;
         }
 
         if((ps_dec->i4_header_decoded & 1) &&
            (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
            (ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id].u2_disp_width != i4_cropped_wd))
         {
             ps_dec->u1_res_changed = 1;
             return IVD_RES_CHANGED;
         }
 
         if((ps_dec->i4_header_decoded & 1) &&
            (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
            (ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id].u2_pic_ht != u2_pic_ht))
         {
             ps_dec->u1_res_changed = 1;
             return IVD_RES_CHANGED;
         }
 
         if((ps_dec->i4_header_decoded & 1) &&
            (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
            (ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id].u2_disp_height != i4_cropped_ht))
         {
             ps_dec->u1_res_changed = 1;
             return IVD_RES_CHANGED;
         }
         /* Check again for unsupported resolutions with updated values*/
         if((u2_pic_wd > SVCD_MAX_FRAME_WIDTH) || (u2_pic_ht > SVCD_MAX_FRAME_HEIGHT) ||
            (u2_pic_wd < SVCD_MIN_FRAME_WIDTH) || (u2_pic_ht < SVCD_MIN_FRAME_HEIGHT) ||
            (u2_pic_wd * (UWORD32) u2_pic_ht > SVCD_MAX_FRAME_SIZE))
         {
             return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
         }
 
         /* If MBAff is enabled, decoder support is limited to streams with
          * width less than half of H264_MAX_FRAME_WIDTH.
          * In case of MBAff decoder processes two rows at a time
          */
         if((u2_pic_wd << ps_seq->u1_mb_aff_flag) > H264_MAX_FRAME_WIDTH)
         {
             return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
         }
     }
 
     if(1 == ps_seq->u1_vui_parameters_present_flag)
     {
         ret = ih264d_parse_vui_parametres(&ps_seq->s_vui, ps_bitstrm);
         if(ret != OK) return ret;
     }
     ps_seq_svc_ext = &ps_subset_seq->s_sps_svc_ext;
 
     isvcd_set_default_seq_svc_ext(ps_seq_svc_ext);
 
     if(SCALABLE_BASELINE_PROFILE_IDC == ps_seq->u1_profile_idc ||
        SCALABLE_HIGH_PROFILE_IDC == ps_seq->u1_profile_idc)
     {
         SWITCHONTRACE;
         ps_seq_svc_ext->u1_inter_layer_deblocking_filter_control_present_flag =
             ih264d_get_bit_h264(ps_bitstrm);
         COPYTHECONTEXT("SPS_EXt: u1_inter_layer_deblocking_filter_control_present_flag",
                        ps_seq_svc_ext->u1_inter_layer_deblocking_filter_control_present_flag);
 
         ps_seq_svc_ext->u1_extended_spatial_scalability_idc = ih264d_get_bits_h264(ps_bitstrm, 2);
         COPYTHECONTEXT("SPS_EXt: u1_extended_spatial_scalability_idc",
                        ps_seq_svc_ext->u1_extended_spatial_scalability_idc);
 
-        if(ps_seq_svc_ext->u1_extended_spatial_scalability_idc >= 3)
+        /* u1_extended_spatial_scalability_idc value 0 is supported*/
+        if(ps_seq_svc_ext->u1_extended_spatial_scalability_idc != 0)
         {
             return ERROR_SVC_INV_SUBSET_SPS;
         }
 
         /* ChromaArrayType = i4_chroma_format_idc  if  separate_colour_plane_flag =
          * 0 for all chroma format except 4:4:4 */
         if(1 == ps_seq->i4_chroma_format_idc || 2 == ps_seq->i4_chroma_format_idc)
         {
             ps_seq_svc_ext->u1_chroma_phase_x_plus1_flag = ih264d_get_bit_h264(ps_bitstrm);
             COPYTHECONTEXT("SPS_EXt: u1_chroma_phase_x_plus1_flag",
                            ps_seq_svc_ext->u1_chroma_phase_x_plus1_flag);
         }
 
         if(1 == ps_seq->i4_chroma_format_idc)
         {
             ps_seq_svc_ext->u1_chroma_phase_y_plus1 = ih264d_get_bits_h264(ps_bitstrm, 2);
             COPYTHECONTEXT("SPS_EXt: u1_chroma_phase_y_plus1",
                            ps_seq_svc_ext->u1_chroma_phase_y_plus1);
 
             if(ps_seq_svc_ext->u1_chroma_phase_y_plus1 >= 3)
             {
                 return ERROR_SVC_INV_SUBSET_SPS;
             }
         }
 
         /* inferred values not covered in isvcd_set_default_seq_svc_ext*/
         ps_seq_svc_ext->u1_seq_ref_layer_chroma_phase_x_plus1_flag =
             ps_seq_svc_ext->u1_chroma_phase_x_plus1_flag;
         ps_seq_svc_ext->u1_seq_ref_layer_chroma_phase_y_plus1 =
             ps_seq_svc_ext->u1_chroma_phase_y_plus1;
 
         if(1 == ps_seq_svc_ext->u1_extended_spatial_scalability_idc)
         {
             if(ps_seq->i4_chroma_format_idc > 0)
             {
                 ps_seq_svc_ext->u1_seq_ref_layer_chroma_phase_x_plus1_flag =
                     ih264d_get_bit_h264(ps_bitstrm);
                 COPYTHECONTEXT("SPS_EXt: u1_seq_ref_layer_chroma_phase_x_plus1_flag",
                                ps_seq_svc_ext->u1_seq_ref_layer_chroma_phase_x_plus1_flag);
 
                 ps_seq_svc_ext->u1_seq_ref_layer_chroma_phase_y_plus1 =
                     ih264d_get_bits_h264(ps_bitstrm, 2);
                 COPYTHECONTEXT("SPS_EXt: u1_seq_ref_layer_chroma_phase_y_plus1",
                                ps_seq_svc_ext->u1_seq_ref_layer_chroma_phase_y_plus1);
 
                 if(ps_seq_svc_ext->u1_seq_ref_layer_chroma_phase_y_plus1 >= 3)
                 {
                     return ERROR_SVC_INV_SUBSET_SPS;
                 }
             }
 
             ps_seq_svc_ext->i4_seq_scaled_ref_layer_left_offset =
                 ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
             COPYTHECONTEXT("SPS_EXt: i4_seq_scaled_ref_layer_left_offset",
                            ps_seq_svc_ext->i4_seq_scaled_ref_layer_left_offset);
 
             if(ps_seq_svc_ext->i4_seq_scaled_ref_layer_left_offset >= MAX_SCLD_REF_LAYER_OFFSET ||
                ps_seq_svc_ext->i4_seq_scaled_ref_layer_left_offset < MIN_SCLD_REF_LAYER_OFFSET)
             {
                 return ERROR_SVC_INV_SUBSET_SPS;
             }
 
             ps_seq_svc_ext->i4_seq_scaled_ref_layer_top_offset =
                 ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
             COPYTHECONTEXT("SPS_EXt: i4_seq_scaled_ref_layer_top_offset",
                            ps_seq_svc_ext->i4_seq_scaled_ref_layer_top_offset);
 
             if(ps_seq_svc_ext->i4_seq_scaled_ref_layer_top_offset >= MAX_SCLD_REF_LAYER_OFFSET ||
                ps_seq_svc_ext->i4_seq_scaled_ref_layer_top_offset < MIN_SCLD_REF_LAYER_OFFSET)
             {
                 return ERROR_SVC_INV_SUBSET_SPS;
             }
 
             ps_seq_svc_ext->i4_seq_scaled_ref_layer_right_offset =
                 ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
             COPYTHECONTEXT("SPS_EXt: i4_seq_scaled_ref_layer_right_offset",
                            ps_seq_svc_ext->i4_seq_scaled_ref_layer_right_offset);
 
             if(ps_seq_svc_ext->i4_seq_scaled_ref_layer_right_offset >= MAX_SCLD_REF_LAYER_OFFSET ||
                ps_seq_svc_ext->i4_seq_scaled_ref_layer_right_offset < MIN_SCLD_REF_LAYER_OFFSET)
             {
                 return ERROR_SVC_INV_SUBSET_SPS;
             }
 
             ps_seq_svc_ext->i4_seq_scaled_ref_layer_bottom_offset =
                 ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
             COPYTHECONTEXT("SPS_EXt: i4_seq_scaled_ref_layer_bottom_offset",
                            ps_seq_svc_ext->i4_seq_scaled_ref_layer_bottom_offset);
 
             if(ps_seq_svc_ext->i4_seq_scaled_ref_layer_bottom_offset >= MAX_SCLD_REF_LAYER_OFFSET ||
                ps_seq_svc_ext->i4_seq_scaled_ref_layer_bottom_offset < MIN_SCLD_REF_LAYER_OFFSET)
             {
                 return ERROR_INV_SLICE_HDR_T;
             }
         }
 
         ps_seq_svc_ext->u1_seq_tcoeff_level_prediction_flag = ih264d_get_bit_h264(ps_bitstrm);
         COPYTHECONTEXT("SPS_EXt: u1_seq_tcoeff_level_prediction_flag",
                        ps_seq_svc_ext->u1_seq_tcoeff_level_prediction_flag);
 
         if(1 == ps_seq_svc_ext->u1_seq_tcoeff_level_prediction_flag)
         {
             ps_seq_svc_ext->u1_adaptive_tcoeff_level_prediction_flag =
                 ih264d_get_bit_h264(ps_bitstrm);
             COPYTHECONTEXT("SPS_EXt: u1_adaptive_tcoeff_level_prediction_flag",
                            ps_seq_svc_ext->u1_adaptive_tcoeff_level_prediction_flag);
         }
 
         ps_seq_svc_ext->u1_slice_header_restriction_flag = ih264d_get_bit_h264(ps_bitstrm);
         COPYTHECONTEXT("SPS_EXt: u1_slice_header_restriction_flag",
                        ps_seq_svc_ext->u1_slice_header_restriction_flag);
 
         ps_seq_svc_ext->u1_svc_vui_parameters_present_flag = ih264d_get_bit_h264(ps_bitstrm);
         COPYTHECONTEXT("SPS_EXt: u1_svc_vui_parameters_present_flag",
                        ps_seq_svc_ext->u1_svc_vui_parameters_present_flag);
 
         if(1 == ps_seq_svc_ext->u1_svc_vui_parameters_present_flag)
         {
             if(NULL ==
                ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id].s_sps_svc_ext.ps_svc_vui_ext)
             {
                 void *pv_buf;
                 UWORD32 size;
                 /* Memory allocation only if VUI is enabled in a particular subset SPS*/
                 size = sizeof(svc_vui_ext_t);
                 pv_buf = ps_dec->pf_aligned_alloc(ps_dec->pv_mem_ctxt, 128, size);
                 RETURN_IF((NULL == pv_buf), IV_FAIL);
                 memset(pv_buf, 0, size);
                 ps_seq_svc_ext->ps_svc_vui_ext = pv_buf;
                 ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id]
                     .s_sps_svc_ext.ps_svc_vui_ext = pv_buf;
             }
             else
             {
                 ps_seq_svc_ext->ps_svc_vui_ext =
                     ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id]
                         .s_sps_svc_ext.ps_svc_vui_ext;
             }
             ret = isvcd_parse_vui_ext_parametres(ps_seq_svc_ext->ps_svc_vui_ext, ps_bitstrm);
             if(ret != OK) return ret;
         }
     }
     /* Add conditions for SCALABLE BASELINE PROFILE */
     if(SCALABLE_BASELINE_PROFILE_IDC == ps_seq->u1_profile_idc ||
        ((SCALABLE_HIGH_PROFILE_IDC == ps_seq->u1_profile_idc) && (1 == uc_constraint_set0_flag)))
     {
         if(ps_seq->i4_chroma_format_idc != 1)
         {
             return ERROR_FEATURE_UNAVAIL;
         }
 
         if(ps_seq->i4_bit_depth_luma_minus8 != 0)
         {
             return ERROR_FEATURE_UNAVAIL;
         }
 
         if(ps_seq->i4_bit_depth_chroma_minus8 != 0)
         {
             return ERROR_FEATURE_UNAVAIL;
         }
 
         if(ps_seq->i4_qpprime_y_zero_transform_bypass_flag != 0)
         {
             return ERROR_FEATURE_UNAVAIL;
         }
 
         if(ps_seq->u1_frame_mbs_only_flag != 1)
         {
             return ERROR_FEATURE_UNAVAIL;
         }
 
         if((0 != ps_seq_svc_ext->i4_seq_scaled_ref_layer_left_offset % 16) &&
            (0 != ps_seq_svc_ext->i4_seq_scaled_ref_layer_top_offset % 16))
         {
             return ERROR_FEATURE_UNAVAIL;
         }
     }
     /* Compare older num_reorder_frames with the new one if header is already
      * decoded */
     if((ps_dec->i4_header_decoded & 1) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_is_valid) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].u1_vui_parameters_present_flag) &&
        (1 == ps_dec->ps_sps[u1_seq_parameter_set_id].s_vui.u1_bitstream_restriction_flag))
     {
         ps_dec->u1_res_changed = 1;
         return IVD_RES_CHANGED;
     }
     /* In case bitstream read has exceeded the filled size, then return an error */
     if(EXCEED_OFFSET(ps_bitstrm))
     {
         return ERROR_INV_SPS_PPS_T;
     }
 
     /*--------------------------------------------------------------------*/
     /* All initializations to ps_dec are beyond this point                */
     /*--------------------------------------------------------------------*/
     {
         WORD32 reorder_depth = ih264d_get_dpb_size(ps_seq);
         if((1 == ps_seq->u1_vui_parameters_present_flag) &&
            (1 == ps_seq->s_vui.u1_bitstream_restriction_flag))
         {
             reorder_depth = ps_seq->s_vui.u4_num_reorder_frames + 1;
         }
 
         if(reorder_depth > H264_MAX_REF_PICS)
         {
             return ERROR_INV_SPS_PPS_T;
         }
 
         if(ps_seq->u1_frame_mbs_only_flag != 1) reorder_depth *= 2;
         ps_subset_seq->i4_reorder_depth = reorder_depth + DISPLAY_LATENCY;
     }
     ps_subset_seq->u2_disp_height = i4_cropped_ht;
     ps_subset_seq->u2_disp_width = i4_cropped_wd;
     ps_subset_seq->u2_pic_wd = u2_pic_wd;
     ps_subset_seq->u2_pic_ht = u2_pic_ht;
 
     /* Assuming 8k is the maximum resolution svc dec supports*/
     if(u2_frm_wd_y > H264_MAX_FRAME_WIDTH) return (NOT_OK);
     if(u2_frm_ht_y > H264_MAX_FRAME_HEIGHT) return (NOT_OK);
     if(u2_frm_wd_uv > H264_MAX_FRAME_WIDTH) return (NOT_OK);
     if(u2_frm_ht_uv > H264_MAX_FRAME_HEIGHT) return (NOT_OK);
 
     /* Determining the Width and Height of Frame from that of Picture */
     ps_subset_seq->u2_frm_wd_y = u2_frm_wd_y;
     ps_subset_seq->u2_frm_ht_y = u2_frm_ht_y;
     ps_subset_seq->u2_frm_wd_uv = u2_frm_wd_uv;
     ps_subset_seq->u2_frm_ht_uv = u2_frm_ht_uv;
 
     ps_subset_seq->u1_pad_len_y_v = (UWORD8) (PAD_LEN_Y_V << (1 - u1_frm));
     ps_subset_seq->u1_pad_len_cr_v = (UWORD8) (PAD_LEN_UV_V << (1 - u1_frm));
 
     ps_subset_seq->u2_crop_offset_y = u2_crop_offset_y;
     ps_subset_seq->u2_crop_offset_uv = u2_crop_offset_uv;
 
     if(((ps_dec->u2_pic_wd * ps_dec->u2_pic_ht) <
         (ps_subset_seq->u2_pic_wd * ps_subset_seq->u2_pic_ht)) ||
        (ps_dec->i4_reorder_depth < ps_subset_seq->i4_reorder_depth))
     {
         ps_dec->i4_reorder_depth = ps_subset_seq->i4_reorder_depth;
 
         ps_dec->u2_disp_height = ps_subset_seq->u2_disp_height;
         ps_dec->u2_disp_width = ps_subset_seq->u2_disp_width;
 
         ps_dec->u2_pic_wd = ps_subset_seq->u2_pic_wd;
         ps_dec->u2_pic_ht = ps_subset_seq->u2_pic_ht;
         ps_dec->u4_total_mbs = ps_seq->u2_total_num_of_mbs << (1 - ps_seq->u1_frame_mbs_only_flag);
 
         /* Determining the Width and Height of Frame from that of Picture */
         ps_dec->u2_frm_wd_y = ps_subset_seq->u2_frm_wd_y;
         ps_dec->u2_frm_ht_y = ps_subset_seq->u2_frm_ht_y;
         ps_dec->u2_frm_wd_uv = ps_subset_seq->u2_frm_wd_uv;
         ps_dec->u2_frm_ht_uv = ps_subset_seq->u2_frm_ht_uv;
 
         ps_dec->s_pad_mgr.u1_pad_len_y_v = ps_subset_seq->u1_pad_len_y_v;
         ps_dec->s_pad_mgr.u1_pad_len_cr_v = ps_subset_seq->u1_pad_len_cr_v;
 
         ps_dec->u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs;
         ps_dec->u2_frm_ht_in_mbs = ps_seq->u2_frm_ht_in_mbs;
 
         ps_dec->u2_crop_offset_y = ps_subset_seq->u2_crop_offset_y;
         ps_dec->u2_crop_offset_uv = ps_subset_seq->u2_crop_offset_uv;
     }
 
     ps_seq->u1_is_valid = TRUE;
     ps_dec->ps_sps[u1_seq_parameter_set_id] = *ps_seq;
     if(NULL != ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id].s_sps_svc_ext.ps_svc_vui_ext)
     {
         ps_seq_svc_ext->ps_svc_vui_ext =
             ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id].s_sps_svc_ext.ps_svc_vui_ext;
     }
     ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id] = *ps_subset_seq;
     ps_dec->ps_cur_sps = &ps_dec->ps_sps[u1_seq_parameter_set_id];
     ps_svc_lyr_dec->ps_cur_subset_sps = &ps_svc_lyr_dec->ps_subset_sps[u1_seq_parameter_set_id];
 
     return OK;
 }
 /*!
  **************************************************************************
  * \if Function name : isvcd_dec_ref_base_pic_marking \endif
  *
  * \brief
  *    Decodes reference base pic marking params
  *
  * \return
  *    0 on Success and error code otherwise
  **************************************************************************
  */
