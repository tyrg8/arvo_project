commit 04dd327493676ef6855df841d7595874d60c3b65
Merge: 25c264245b 214cd1565b
Author: Dmitry Stogov <dmitry@zend.com>
Date:   Tue Sep 28 14:27:29 2021 +0300

    Merge branch 'PHP-8.1'
    
    * PHP-8.1:
      JIT: Fixed result when assigning to typed reference

diff --git a/ext/opcache/jit/zend_jit_arm64.dasc b/ext/opcache/jit/zend_jit_arm64.dasc
index f47d96a651..f1f0502759 100644
--- a/ext/opcache/jit/zend_jit_arm64.dasc
+++ b/ext/opcache/jit/zend_jit_arm64.dasc
@@ -5555,40 +5555,47 @@ static int zend_jit_simple_assign(dasm_State    **Dst,
 static int zend_jit_assign_to_typed_ref(dasm_State         **Dst,
                                        const zend_op        *opline,
                                        zend_uchar            val_type,
                                        zend_jit_addr         val_addr,
+                                       zend_jit_addr         res_addr,
                                        bool                  check_exception)
 {
 	|	// if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(variable_ptr)))) {
 	|	ldr TMP1, [FCARG1x, #offsetof(zend_reference, sources.ptr)]
 	|	cbnz TMP1, >2
 	|.cold_code
 	|2:
 	if (Z_MODE(val_addr) != IS_MEM_ZVAL || Z_REG(val_addr) != ZREG_FCARG2 || Z_OFFSET(val_addr) != 0) {
 		|	LOAD_ZVAL_ADDR FCARG2x, val_addr
 	}
 	if (opline) {
 		|	SET_EX_OPLINE opline, REG0
 	}
 	if (val_type == IS_CONST) {
 		|	EXT_CALL zend_jit_assign_const_to_typed_ref, REG0
 	} else if (val_type == IS_TMP_VAR) {
 		|	EXT_CALL zend_jit_assign_tmp_to_typed_ref, REG0
 	} else if (val_type == IS_VAR) {
 		|	EXT_CALL zend_jit_assign_var_to_typed_ref, REG0
 	} else if (val_type == IS_CV) {
 		|	EXT_CALL zend_jit_assign_cv_to_typed_ref, REG0
 	} else {
 		ZEND_UNREACHABLE();
 	}
+	if (res_addr) {
+		zend_jit_addr ret_addr = ZEND_ADDR_MEM_ZVAL(ZREG_X0, 0); // RETVAL
+
+		|	ZVAL_COPY_VALUE res_addr, -1, ret_addr, -1, ZREG_REG1, ZREG_REG2, ZREG_TMP1, ZREG_TMP2, ZREG_FPR0
+		|	TRY_ADDREF -1, REG1w, REG2, TMP1w
+	}
 	if (check_exception) {
 		|	// if (UNEXPECTED(EG(exception) != NULL)) {
 		|	MEM_LOAD_64_ZTS ldr, REG0, executor_globals, exception, TMP1
 		|	cbz REG0, >8  // END OF zend_jit_assign_to_variable()
 		|	b ->exception_handler_undef
 	} else {
 		|	b >8
 	}
 	|.code
 
 	return 1;
 }
@@ -5679,152 +5686,152 @@ static int zend_jit_assign_to_variable_call(dasm_State    **Dst,
 static int zend_jit_assign_to_variable(dasm_State    **Dst,
                                        const zend_op  *opline,
                                        zend_jit_addr   var_use_addr,
                                        zend_jit_addr   var_addr,
                                        uint32_t        var_info,
                                        uint32_t        var_def_info,
                                        zend_uchar      val_type,
                                        zend_jit_addr   val_addr,
                                        uint32_t        val_info,
                                        zend_jit_addr   res_addr,
                                        bool            check_exception)
 /* Labels: 1,2,3,4,5,8 */
 {
 	int done = 0;
 	zend_reg ref_reg, tmp_reg;
 
 	if (Z_MODE(var_addr) == IS_REG || Z_REG(var_use_addr) != ZREG_REG0) {
 		ref_reg = ZREG_FCARG1;
 		tmp_reg = ZREG_REG0;
 	} else {
 		/* ASSIGN_DIM */
 		ref_reg = ZREG_REG0;
 		tmp_reg = ZREG_FCARG1;
 	}
 
 	if (var_info & MAY_BE_REF) {
 		if (Z_MODE(var_use_addr) != IS_MEM_ZVAL || Z_REG(var_use_addr) != ref_reg || Z_OFFSET(var_use_addr) != 0) {
 			|	LOAD_ZVAL_ADDR Rx(ref_reg), var_use_addr
 			var_addr = var_use_addr = ZEND_ADDR_MEM_ZVAL(ref_reg, 0);
 		}
 		|	// if (Z_ISREF_P(variable_ptr)) {
 		|	IF_NOT_Z_TYPE Rx(ref_reg), IS_REFERENCE, >1, TMP1w
 		|	// if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(variable_ptr)))) {
 		|	GET_Z_PTR FCARG1x, Rx(ref_reg)
-		if (!zend_jit_assign_to_typed_ref(Dst, opline, val_type, val_addr, check_exception)) {
+		if (!zend_jit_assign_to_typed_ref(Dst, opline, val_type, val_addr, res_addr, check_exception)) {
 			return 0;
 		}
 		|	add Rx(ref_reg), FCARG1x, #offsetof(zend_reference, val)
 		|1:
 	}
 	if (var_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE)) {
 		if (RC_MAY_BE_1(var_info)) {
 			int in_cold = 0;
 
 			if (var_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
 				|	IF_ZVAL_REFCOUNTED var_use_addr, >1, ZREG_TMP1, ZREG_TMP2
 				|.cold_code
 				|1:
 				in_cold = 1;
 			}
 			if (Z_REG(var_use_addr) == ZREG_FCARG1 || Z_REG(var_use_addr) == ZREG_REG0) {
 				bool keep_gc = 0;
 
 				|	GET_ZVAL_PTR Rx(tmp_reg), var_use_addr, TMP1
 #if 0
 				// TODO: This optiization doesn't work on ARM
 				if (tmp_reg == ZREG_FCARG1) {
 					if (Z_MODE(val_addr) == IS_REG) {
 						keep_gc = 1;
 					} else if ((val_info & ((MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_GUARD)-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE))) == 0) {
 						keep_gc = 1;
 					} else if (Z_MODE(val_addr) == IS_CONST_ZVAL) {
 						zval *zv = Z_ZV(val_addr);
 						if (Z_TYPE_P(zv) == IS_DOUBLE) {
 							if (Z_DVAL_P(zv) == 0) {
 								keep_gc = 1;
 							}
 						} else if (IS_SIGNED_32BIT(Z_LVAL_P(zv))) {
 							keep_gc = 1;
 						}
 					} else if (Z_MODE(val_addr) == IS_MEM_ZVAL) {
 						if ((val_info & (MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_GUARD)) == MAY_BE_DOUBLE) {
 							keep_gc = 1;
 						}
 					}
 				}
 #endif
 				if (!keep_gc) {
 					|	str Rx(tmp_reg), T1 // save
 				}
 				if (!zend_jit_simple_assign(Dst, opline, var_addr, var_info, var_def_info, val_type, val_addr, val_info, res_addr, in_cold, 0)) {
 					return 0;
 				}
 				if (!keep_gc) {
 					|	ldr FCARG1x, T1     // restore
 				}
 			} else {
 				|	GET_ZVAL_PTR FCARG1x, var_use_addr, TMP1
 				if (!zend_jit_simple_assign(Dst, opline, var_addr, var_info, var_def_info, val_type, val_addr, val_info, res_addr, in_cold, 1)) {
 					return 0;
 				}
 			}
 			|	GC_DELREF FCARG1x, TMP1w
 			if (RC_MAY_BE_N(var_info) && (var_info & (MAY_BE_ARRAY|MAY_BE_OBJECT)) != 0) {
 				|	bne >4
 			} else {
 				|	bne >8
 			}
 			|	ZVAL_DTOR_FUNC var_info, opline, TMP1
 			if (in_cold || (RC_MAY_BE_N(var_info) && (var_info & (MAY_BE_ARRAY|MAY_BE_OBJECT)) != 0)) {
 				if (check_exception) {
 					|	MEM_LOAD_64_ZTS ldr, REG0, executor_globals, exception, TMP1
 					|	cbz REG0, >8
 					|	b ->exception_handler
 				} else {
 					|	b >8
 				}
 			}
 			if (RC_MAY_BE_N(var_info) && (var_info & (MAY_BE_ARRAY|MAY_BE_OBJECT)) != 0) {
 				|4:
 				|	IF_GC_MAY_NOT_LEAK FCARG1x, >8, TMP1w, TMP2w
 				|	EXT_CALL gc_possible_root, REG0
 				if (in_cold) {
 					|	b >8
 				}
 			}
 			if (in_cold) {
 				|.code
 			} else {
 				done = 1;
 			}
 		} else /* if (RC_MAY_BE_N(var_info)) */ {
 			if (var_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
 				|	IF_NOT_ZVAL_REFCOUNTED var_use_addr, >5, ZREG_TMP1, ZREG_TMP2
 			}
 			if (var_info & (MAY_BE_ARRAY|MAY_BE_OBJECT)) {
 				if (Z_REG(var_use_addr) != ZREG_FP) {
 					|	str Rx(Z_REG(var_use_addr)), T1 // save
 				}
 				|	GET_ZVAL_PTR FCARG1x, var_use_addr, TMP1
 				|	GC_DELREF FCARG1x, TMP1w
 				|	IF_GC_MAY_NOT_LEAK FCARG1x, >5, TMP1w, TMP2w
 				|	EXT_CALL gc_possible_root, TMP1
 				if (Z_REG(var_use_addr) != ZREG_FP) {
 					|	ldr Rx(Z_REG(var_use_addr)), T1 // restore
 				}
 			} else {
 				|	GET_ZVAL_PTR Rx(tmp_reg), var_use_addr, TMP1
 				|	GC_DELREF Rx(tmp_reg), TMP1w
 			}
 			|5:
 	    }
 	}
 
 	if (!done && !zend_jit_simple_assign(Dst, opline, var_addr, var_info, var_def_info, val_type, val_addr, val_info, res_addr, 0, 0)) {
 		return 0;
 	}
 
 	|8:
 
 	return 1;
 }
diff --git a/ext/opcache/jit/zend_jit_helpers.c b/ext/opcache/jit/zend_jit_helpers.c
index ecb29fa217..d378a8ce9e 100644
--- a/ext/opcache/jit/zend_jit_helpers.c
+++ b/ext/opcache/jit/zend_jit_helpers.c
@@ -1752,44 +1752,44 @@ static void ZEND_FASTCALL zend_jit_vm_stack_free_args_helper(zend_execute_data *
 	zend_vm_stack_free_args(call);
 }
 
-static zend_always_inline void zend_jit_assign_to_typed_ref_helper(zend_reference *ref, zval *value, zend_uchar value_type)
+static zend_always_inline zval* zend_jit_assign_to_typed_ref_helper(zend_reference *ref, zval *value, zend_uchar value_type)
 {
 	zval variable;
 
 	ZVAL_REF(&variable, ref);
-	zend_assign_to_variable(&variable, value, value_type, ZEND_CALL_USES_STRICT_TYPES(EG(current_execute_data)));
+	return zend_assign_to_variable(&variable, value, value_type, ZEND_CALL_USES_STRICT_TYPES(EG(current_execute_data)));
 }
 
-static void ZEND_FASTCALL zend_jit_assign_const_to_typed_ref(zend_reference *ref, zval *value)
+static zval* ZEND_FASTCALL zend_jit_assign_const_to_typed_ref(zend_reference *ref, zval *value)
 {
-	zend_jit_assign_to_typed_ref_helper(ref, value, IS_CONST);
+	return zend_jit_assign_to_typed_ref_helper(ref, value, IS_CONST);
 }
 
-static void ZEND_FASTCALL zend_jit_assign_tmp_to_typed_ref(zend_reference *ref, zval *value)
+static zval* ZEND_FASTCALL zend_jit_assign_tmp_to_typed_ref(zend_reference *ref, zval *value)
 {
-	zend_jit_assign_to_typed_ref_helper(ref, value, IS_TMP_VAR);
+	return zend_jit_assign_to_typed_ref_helper(ref, value, IS_TMP_VAR);
 }
 
-static void ZEND_FASTCALL zend_jit_assign_var_to_typed_ref(zend_reference *ref, zval *value)
+static zval* ZEND_FASTCALL zend_jit_assign_var_to_typed_ref(zend_reference *ref, zval *value)
 {
-	zend_jit_assign_to_typed_ref_helper(ref, value, IS_VAR);
+	return zend_jit_assign_to_typed_ref_helper(ref, value, IS_VAR);
 }
 
-static void ZEND_FASTCALL zend_jit_assign_cv_to_typed_ref(zend_reference *ref, zval *value)
+static zval* ZEND_FASTCALL zend_jit_assign_cv_to_typed_ref(zend_reference *ref, zval *value)
 {
 	if (UNEXPECTED(Z_TYPE_P(value) == IS_UNDEF)) {
 		const zend_op *opline = EG(current_execute_data)->opline;
 		uint32_t var;
 		if (opline->opcode == ZEND_ASSIGN) {
 			var = opline->op2.var;
 		} else {
 			ZEND_ASSERT((opline + 1)->opcode == ZEND_OP_DATA);
 			var = (opline + 1)->op1.var;
 		}
 		zend_jit_undefined_op_helper(var);
 		value = &EG(uninitialized_zval);
 	}
-	zend_jit_assign_to_typed_ref_helper(ref, value, IS_CV);
+	return zend_jit_assign_to_typed_ref_helper(ref, value, IS_CV);
 }
 
 
diff --git a/ext/opcache/jit/zend_jit_trace.c b/ext/opcache/jit/zend_jit_trace.c
index 675176837c..ebe1af530f 100644
--- a/ext/opcache/jit/zend_jit_trace.c
+++ b/ext/opcache/jit/zend_jit_trace.c
@@ -3797,2907 +3797,2912 @@ static bool zend_jit_trace_next_is_send_result(const zend_op              *oplin
 static const void *zend_jit_trace(zend_jit_trace_rec *trace_buffer, uint32_t parent_trace, uint32_t exit_num)
 {
 	const void *handler = NULL;
 	dasm_State* dasm_state = NULL;
 	zend_script *script = NULL;
 	zend_lifetime_interval **ra = NULL;
 	zend_string *name = NULL;
 	void *checkpoint;
 	const zend_op_array *op_array;
 	zend_ssa *ssa, *op_array_ssa;
 	const zend_op **ssa_opcodes;
 	zend_jit_trace_rec *p;
 	zend_jit_op_array_trace_extension *jit_extension;
 	int num_op_arrays = 0;
 	zend_jit_trace_info *t;
 	const zend_op_array *op_arrays[ZEND_JIT_TRACE_MAX_FUNCS];
 	zend_uchar smart_branch_opcode;
 	const void *exit_addr;
 	uint32_t op1_info, op1_def_info, op2_info, res_info, res_use_info, op1_data_info;
 	bool send_result = 0;
 	bool skip_comparison;
 	zend_jit_addr op1_addr, op1_def_addr, op2_addr, op2_def_addr, res_addr;
 	zend_class_entry *ce;
 	bool ce_is_instanceof;
 	bool on_this = 0;
 	bool delayed_fetch_this = 0;
 	bool avoid_refcounting = 0;
 	bool polymorphic_side_trace =
 		parent_trace &&
 		(zend_jit_traces[parent_trace].exit_info[exit_num].flags & ZEND_JIT_EXIT_METHOD_CALL);
 	uint32_t i;
 	zend_jit_trace_stack_frame *frame, *top, *call;
 	zend_jit_trace_stack *stack;
 	zend_uchar res_type = IS_UNKNOWN;
 	const zend_op *opline, *orig_opline;
 	const zend_ssa_op *ssa_op, *orig_ssa_op;
 	int checked_stack;
 	int peek_checked_stack;
 	uint32_t frame_flags = 0;
 
 	JIT_G(current_trace) = trace_buffer;
 
 	checkpoint = zend_arena_checkpoint(CG(arena));
 
 	ssa = zend_jit_trace_build_tssa(trace_buffer, parent_trace, exit_num, script, op_arrays, &num_op_arrays);
 
 	if (!ssa) {
 		goto jit_cleanup;
 	}
 
 	ssa_opcodes = ((zend_tssa*)ssa)->tssa_opcodes;
 
 	/* Register allocation */
 	if ((JIT_G(opt_flags) & (ZEND_JIT_REG_ALLOC_LOCAL|ZEND_JIT_REG_ALLOC_GLOBAL))
 	 && JIT_G(opt_level) >= ZEND_JIT_LEVEL_INLINE) {
 		ra = zend_jit_trace_allocate_registers(trace_buffer, ssa, parent_trace, exit_num);
 	}
 
 	p = trace_buffer;
 	ZEND_ASSERT(p->op == ZEND_JIT_TRACE_START);
 	op_array = p->op_array;
 	frame = JIT_G(current_frame);
 	top = zend_jit_trace_call_frame(frame, op_array);
 	TRACE_FRAME_INIT(frame, op_array, TRACE_FRAME_MASK_UNKNOWN_RETURN, -1);
 	frame->used_stack = checked_stack = peek_checked_stack = 0;
 	stack = frame->stack;
 	for (i = 0; i < op_array->last_var + op_array->T; i++) {
 		SET_STACK_TYPE(stack, i, IS_UNKNOWN, 1);
 	}
 
 	opline = p[1].opline;
 	name = zend_jit_trace_name(op_array, opline->lineno);
 	p += ZEND_JIT_TRACE_START_REC_SIZE;
 
 	dasm_init(&dasm_state, DASM_MAXSECTION);
 	dasm_setupglobal(&dasm_state, dasm_labels, zend_lb_MAX);
 	dasm_setup(&dasm_state, dasm_actions);
 
 	jit_extension =
 		(zend_jit_op_array_trace_extension*)ZEND_FUNC_INFO(op_array);
 	op_array_ssa = &jit_extension->func_info.ssa;
 
 	dasm_growpc(&dasm_state, 2); /* =>0: loop header */
 	                             /* =>1: end of code */
 
 	zend_jit_align_func(&dasm_state);
 	if (!parent_trace) {
 		zend_jit_prologue(&dasm_state);
 	}
 	zend_jit_trace_begin(&dasm_state, ZEND_JIT_TRACE_NUM,
 		parent_trace ? &zend_jit_traces[parent_trace] : NULL, exit_num);
 
 	if (!parent_trace) {
 		zend_jit_set_last_valid_opline(opline);
 		zend_jit_track_last_valid_opline();
 	} else {
 		if (zend_jit_traces[parent_trace].exit_info[exit_num].opline == NULL) {
 			zend_jit_trace_opline_guard(&dasm_state, opline);
 		} else {
 			zend_jit_reset_last_valid_opline();
 		}
 	}
 
 	if (JIT_G(opt_level) >= ZEND_JIT_LEVEL_INLINE) {
 		int last_var;
 		int parent_vars_count = 0;
 		zend_jit_trace_stack *parent_stack = NULL;
 		int used_stack = ((zend_tssa*)ssa)->used_stack;
 
 		if (used_stack > 0) {
 			peek_checked_stack = used_stack;
 			if (!zend_jit_stack_check(&dasm_state, opline, used_stack)) {
 				goto jit_failure;
 			}
 		}
 
 		if (parent_trace) {
 			parent_vars_count = MIN(zend_jit_traces[parent_trace].exit_info[exit_num].stack_size,
 				op_array->last_var + op_array->T);
 			if (parent_vars_count) {
 				parent_stack =
 					zend_jit_traces[parent_trace].stack_map +
 					zend_jit_traces[parent_trace].exit_info[exit_num].stack_offset;
 			}
 		}
 
 		last_var = op_array->last_var;
 		if (trace_buffer->start != ZEND_JIT_TRACE_START_ENTER) {
 			last_var += op_array->T;
 		}
 
 		for (i = 0; i < last_var; i++) {
 			uint32_t info = ssa->var_info[i].type;
 
 			if (!(info & MAY_BE_GUARD) && has_concrete_type(info)) {
 				uint8_t type, mem_type;
 
 				type = concrete_type(info);
 				if (i < parent_vars_count
 				 && STACK_TYPE(parent_stack, i) == type) {
 					mem_type = STACK_MEM_TYPE(parent_stack, i);
 					if (mem_type != IS_UNKNOWN) {
 						SET_STACK_TYPE(stack, i, mem_type, 1);
 					}
 					SET_STACK_TYPE(stack, i, type, 0);
 				} else {
 					SET_STACK_TYPE(stack, i, type, 1);
 				}
 			} else if (ssa->vars[i].alias != NO_ALIAS) {
 				SET_STACK_TYPE(stack, i, IS_UNKNOWN, 1);
 			} else if (i < parent_vars_count
 			 && STACK_TYPE(parent_stack, i) != IS_UNKNOWN) {
 				/* This must be already handled by trace type inference */
 				ZEND_UNREACHABLE();
 				// SET_STACK_TYPE(stack, i, STACK_TYPE(parent_stack, i));
 			} else if ((info & MAY_BE_GUARD) != 0
 			 && (trace_buffer->stop == ZEND_JIT_TRACE_STOP_LOOP
 			  || trace_buffer->stop == ZEND_JIT_TRACE_STOP_RECURSIVE_CALL
 			  || (trace_buffer->stop == ZEND_JIT_TRACE_STOP_RECURSIVE_RET
 			   && (opline-1)->result_type == IS_VAR
 			   && EX_VAR_TO_NUM((opline-1)->result.var) == i))
 			 && (ssa->vars[i].use_chain != -1
 			  || (ssa->vars[i].phi_use_chain
 			   && !(ssa->var_info[ssa->vars[i].phi_use_chain->ssa_var].type & MAY_BE_GUARD)))) {
 				/* Check loop-invariant variable type */
 				if (!zend_jit_type_guard(&dasm_state, opline, EX_NUM_TO_VAR(i), concrete_type(info))) {
 					goto jit_failure;
 				}
 				info &= ~MAY_BE_GUARD;
 				ssa->var_info[i].type = info;
 				SET_STACK_TYPE(stack, i, concrete_type(info), 1);
 			} else if (trace_buffer->start == ZEND_JIT_TRACE_START_ENTER
 			 && op_array->function_name
 			 && i >= op_array->num_args) {
 				/* This must be already handled by trace type inference */
 				ZEND_UNREACHABLE();
 				// SET_STACK_TYPE(stack, i, IS_UNDEF, 1);
 			}
 
 			if ((info & MAY_BE_PACKED_GUARD) != 0
 			 && (trace_buffer->stop == ZEND_JIT_TRACE_STOP_LOOP
 			  || trace_buffer->stop == ZEND_JIT_TRACE_STOP_RECURSIVE_CALL
 			  || trace_buffer->stop == ZEND_JIT_TRACE_STOP_RECURSIVE_RET)
 			 && (ssa->vars[i].use_chain != -1
 			  || (ssa->vars[i].phi_use_chain
 			   && !(ssa->var_info[ssa->vars[i].phi_use_chain->ssa_var].type & MAY_BE_PACKED_GUARD)))) {
 				if (!zend_jit_packed_guard(&dasm_state, opline, EX_NUM_TO_VAR(i), info)) {
 					goto jit_failure;
 				}
 				info &= ~MAY_BE_PACKED_GUARD;
 				ssa->var_info[i].type = info;
 			}
 		}
 
 		if (parent_trace) {
 			/* Deoptimization */
 			if (!zend_jit_trace_deoptimization(&dasm_state,
 					zend_jit_traces[parent_trace].exit_info[exit_num].flags,
 					zend_jit_traces[parent_trace].exit_info[exit_num].opline,
 					parent_stack, parent_vars_count, ssa, stack, ra,
 					polymorphic_side_trace)) {
 				goto jit_failure;
 			}
 		}
 
 		if (ra
 		 && trace_buffer->stop != ZEND_JIT_TRACE_STOP_RECURSIVE_CALL
 		 && trace_buffer->stop != ZEND_JIT_TRACE_STOP_RECURSIVE_RET) {
 			for (i = 0; i < last_var; i++) {
 				if (ra[i]
 				 && (ra[i]->flags & ZREG_LOAD) != 0
 				 && ra[i]->reg != stack[i].reg) {
 
 					if ((ssa->var_info[i].type & MAY_BE_GUARD) != 0) {
 						uint8_t op_type;
 
 						ssa->var_info[i].type &= ~MAY_BE_GUARD;
 						op_type = concrete_type(ssa->var_info[i].type);
 						if (!zend_jit_type_guard(&dasm_state, opline, i, op_type)) {
 							goto jit_failure;
 						}
 						SET_STACK_TYPE(stack, i, op_type, 1);
 					}
 
 					SET_STACK_REG_EX(stack, i, ra[i]->reg, ZREG_LOAD);
 					if (!zend_jit_load_var(&dasm_state, ssa->var_info[i].type, i, ra[i]->reg)) {
 						goto jit_failure;
 					}
 				}
 			}
 		}
 	}
 
 	if (trace_buffer->stop == ZEND_JIT_TRACE_STOP_LOOP
 	 || trace_buffer->stop == ZEND_JIT_TRACE_STOP_RECURSIVE_CALL
 	 || trace_buffer->stop == ZEND_JIT_TRACE_STOP_RECURSIVE_RET) {
 
 		zend_jit_label(&dasm_state, 0); /* start of of trace loop */
 
 		if (ra) {
 			zend_ssa_phi *phi = ssa->blocks[1].phis;
 
 			while (phi) {
 				zend_lifetime_interval *ival = ra[phi->ssa_var];
 
 				if (ival) {
 					if (ival->flags & ZREG_LOAD) {
 						uint32_t info = ssa->var_info[phi->ssa_var].type;
 						ZEND_ASSERT(ival->reg != ZREG_NONE);
 
 						if (info & MAY_BE_GUARD) {
 							if (!zend_jit_type_guard(&dasm_state, opline, phi->var, concrete_type(info))) {
 								goto jit_failure;
 							}
 							info &= ~MAY_BE_GUARD;
 							ssa->var_info[phi->ssa_var].type = info;
 							SET_STACK_TYPE(stack, i, concrete_type(info), 1);
 						}
 						SET_STACK_REG_EX(stack, phi->var, ival->reg, ZREG_LOAD);
 						if (!zend_jit_load_var(&dasm_state, ssa->var_info[phi->ssa_var].type, ssa->vars[phi->ssa_var].var, ival->reg)) {
 							goto jit_failure;
 						}
 					} else if (ival->flags & ZREG_STORE) {
 						ZEND_ASSERT(ival->reg != ZREG_NONE);
 
 						SET_STACK_REG_EX(stack, phi->var, ival->reg, ZREG_STORE);
 						if (!zend_jit_store_var(&dasm_state, ssa->var_info[phi->ssa_var].type, ssa->vars[phi->ssa_var].var, ival->reg,
 								STACK_MEM_TYPE(stack, phi->var) != ssa->var_info[phi->ssa_var].type)) {
 							goto jit_failure;
 						}
 					} else {
 						/* Register has to be written back on side exit */
 						SET_STACK_REG(stack, phi->var, ival->reg);
 					}
 				}
 				phi = phi->next;
 			}
 		}
 
 //		if (trace_buffer->stop != ZEND_JIT_TRACE_STOP_RECURSIVE_RET) {
 //			if (ra && zend_jit_trace_stack_needs_deoptimization(stack, op_array->last_var + op_array->T)) {
 //				uint32_t exit_point = zend_jit_trace_get_exit_point(opline, ZEND_JIT_EXIT_TO_VM);
 //
 //				timeout_exit_addr = zend_jit_trace_get_exit_addr(exit_point);
 //				if (!timeout_exit_addr) {
 //					goto jit_failure;
 //				}
 //			}
 //		}
 
 		if (ra && trace_buffer->stop != ZEND_JIT_TRACE_STOP_LOOP) {
 			int last_var = op_array->last_var;
 
 			if (trace_buffer->start != ZEND_JIT_TRACE_START_ENTER) {
 				last_var += op_array->T;
 			}
 			for (i = 0; i < last_var; i++) {
 				if (ra && ra[i] && (ra[i]->flags & ZREG_LOAD) != 0) {
 					SET_STACK_REG_EX(stack, i, ra[i]->reg, ZREG_LOAD);
 					if (!zend_jit_load_var(&dasm_state, ssa->var_info[i].type, i, ra[i]->reg)) {
 						goto jit_failure;
 					}
 				}
 			}
 		}
 	}
 
 	ssa_op = (JIT_G(opt_level) >= ZEND_JIT_LEVEL_INLINE) ? ssa->ops : NULL;
 	for (;;p++) {
 		if (p->op == ZEND_JIT_TRACE_VM) {
 			uint8_t op1_type = p->op1_type;
 			uint8_t op2_type = p->op2_type;
 			uint8_t op3_type = p->op3_type;
 			uint8_t orig_op1_type = op1_type;
 			uint8_t orig_op2_type = op2_type;
 			uint8_t val_type = IS_UNKNOWN;
 			bool op1_indirect;
 			zend_class_entry *op1_ce = NULL;
 			zend_class_entry *op2_ce = NULL;
 
 			opline = p->opline;
 			if (op1_type & (IS_TRACE_REFERENCE|IS_TRACE_INDIRECT)) {
 				op1_type = IS_UNKNOWN;
 			}
 			if (op1_type != IS_UNKNOWN) {
 				op1_type &= ~IS_TRACE_PACKED;
 			}
 			if (op2_type & (IS_TRACE_REFERENCE|IS_TRACE_INDIRECT)) {
 				op2_type = IS_UNKNOWN;
 			}
 			if (op3_type & (IS_TRACE_REFERENCE|IS_TRACE_INDIRECT)) {
 				op3_type = IS_UNKNOWN;
 			}
 
 			if ((p+1)->op == ZEND_JIT_TRACE_OP1_TYPE) {
 				op1_ce = (zend_class_entry*)(p+1)->ce;
 				p++;
 			}
 			if ((p+1)->op == ZEND_JIT_TRACE_OP2_TYPE) {
 				op2_ce = (zend_class_entry*)(p+1)->ce;
 				p++;
 			}
 			if ((p+1)->op == ZEND_JIT_TRACE_VAL_INFO) {
 				val_type = (p+1)->op1_type;
 				p++;
 			}
 
 			frame_flags = 0;
 
 			switch (opline->opcode) {
 				case ZEND_INIT_FCALL:
 				case ZEND_INIT_FCALL_BY_NAME:
 				case ZEND_INIT_NS_FCALL_BY_NAME:
 				case ZEND_INIT_METHOD_CALL:
 				case ZEND_INIT_DYNAMIC_CALL:
 				case ZEND_INIT_STATIC_METHOD_CALL:
 				case ZEND_INIT_USER_CALL:
 				case ZEND_NEW:
 					frame->call_level++;
 			}
 
 			if (JIT_G(opt_level) >= ZEND_JIT_LEVEL_INLINE) {
 				switch (opline->opcode) {
 					case ZEND_PRE_INC:
 					case ZEND_PRE_DEC:
 					case ZEND_POST_INC:
 					case ZEND_POST_DEC:
 						if (opline->op1_type != IS_CV) {
 							break;
 						}
 						op1_info = OP1_INFO();
 						CHECK_OP1_TRACE_TYPE();
 						if (!(op1_info & MAY_BE_LONG)) {
 							break;
 						}
 						if (opline->result_type != IS_UNUSED) {
 							res_use_info = zend_jit_trace_type_to_info(
 								STACK_MEM_TYPE(stack, EX_VAR_TO_NUM(opline->result.var)))
 									& (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG|MAY_BE_DOUBLE);
 							res_info = RES_INFO();
 							res_addr = RES_REG_ADDR();
 						} else {
 							res_use_info = -1;
 							res_info = -1;
 							res_addr = 0;
 						}
 						op1_def_info = OP1_DEF_INFO();
 						if (op1_def_info & MAY_BE_GUARD
 						 && !has_concrete_type(op1_def_info)) {
 							op1_def_info &= ~MAY_BE_GUARD;
 						}
 						if (!zend_jit_inc_dec(&dasm_state, opline,
 								op1_info, OP1_REG_ADDR(),
 								op1_def_info, OP1_DEF_REG_ADDR(),
 								res_use_info, res_info,
 								res_addr,
 								(op1_def_info & (MAY_BE_DOUBLE|MAY_BE_GUARD)) && zend_may_overflow(opline, ssa_op, op_array, ssa),
 								zend_may_throw(opline, ssa_op, op_array, ssa))) {
 							goto jit_failure;
 						}
 						if ((op1_def_info & (MAY_BE_ANY|MAY_BE_GUARD)) == (MAY_BE_LONG|MAY_BE_GUARD)) {
 							ssa->var_info[ssa_op->op1_def].type &= ~MAY_BE_GUARD;
 							if (opline->result_type != IS_UNUSED) {
 								ssa->var_info[ssa_op->result_def].type &= ~MAY_BE_GUARD;
 							}
 						}
 						if (opline->result_type != IS_UNUSED
 						 && (res_info & (MAY_BE_ANY|MAY_BE_GUARD)) == (MAY_BE_LONG|MAY_BE_GUARD)) {
 							ssa->var_info[ssa_op->result_def].type &= ~MAY_BE_GUARD;
 						}
 						goto done;
 					case ZEND_BW_OR:
 					case ZEND_BW_AND:
 					case ZEND_BW_XOR:
 					case ZEND_SL:
 					case ZEND_SR:
 					case ZEND_MOD:
 						op1_info = OP1_INFO();
 						CHECK_OP1_TRACE_TYPE();
 						op2_info = OP2_INFO();
 						CHECK_OP2_TRACE_TYPE();
 						if ((op1_info & MAY_BE_UNDEF) || (op2_info & MAY_BE_UNDEF)) {
 							break;
 						}
 						if (!(op1_info & MAY_BE_LONG)
 						 || !(op2_info & MAY_BE_LONG)) {
 							break;
 						}
 						res_addr = RES_REG_ADDR();
 						if (Z_MODE(res_addr) != IS_REG
 						 && zend_jit_trace_next_is_send_result(opline, p, frame)) {
 							send_result = 1;
 							res_use_info = -1;
 							res_addr = ZEND_ADDR_MEM_ZVAL(ZREG_RX, (opline+1)->result.var);
 							if (!zend_jit_reuse_ip(&dasm_state)) {
 								goto jit_failure;
 							}
 						} else {
 							res_use_info = zend_jit_trace_type_to_info(
 								STACK_MEM_TYPE(stack, EX_VAR_TO_NUM(opline->result.var)))
 									& (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG|MAY_BE_DOUBLE);
 						}
 						res_info = RES_INFO();
 						if (!zend_jit_long_math(&dasm_state, opline,
 								op1_info, OP1_RANGE(), OP1_REG_ADDR(),
 								op2_info, OP2_RANGE(), OP2_REG_ADDR(),
 								res_use_info, res_info, res_addr,
 								zend_may_throw(opline, ssa_op, op_array, ssa))) {
 							goto jit_failure;
 						}
 						goto done;
 					case ZEND_ADD:
 					case ZEND_SUB:
 					case ZEND_MUL:
 //					case ZEND_DIV: // TODO: check for division by zero ???
 						op1_info = OP1_INFO();
 						op1_addr = OP1_REG_ADDR();
 						op2_info = OP2_INFO();
 						op2_addr = OP2_REG_ADDR();
 						if (orig_op1_type != IS_UNKNOWN
 						 && (orig_op1_type & IS_TRACE_REFERENCE)
 						 && opline->op1_type == IS_CV
 						 && (Z_MODE(op2_addr) != IS_REG || Z_REG(op2_addr) != ZREG_FCARG1)
 						 && (orig_op2_type == IS_UNKNOWN || !(orig_op2_type & IS_TRACE_REFERENCE))) {
 							if (!zend_jit_fetch_reference(&dasm_state, opline, orig_op1_type, &op1_info, &op1_addr,
 									!ssa->var_info[ssa_op->op1_use].guarded_reference, 1)) {
 								goto jit_failure;
 							}
 							if (ssa->vars[ssa_op->op1_use].alias == NO_ALIAS) {
 								ssa->var_info[ssa_op->op1_use].guarded_reference = 1;
 							}
 						} else {
 							CHECK_OP1_TRACE_TYPE();
 						}
 						if (orig_op2_type != IS_UNKNOWN
 						 && (orig_op2_type & IS_TRACE_REFERENCE)
 						 && opline->op2_type == IS_CV
 						 && (Z_MODE(op1_addr) != IS_REG || Z_REG(op1_addr) != ZREG_FCARG1)
 						 && (orig_op1_type == IS_UNKNOWN || !(orig_op1_type & IS_TRACE_REFERENCE))) {
 							if (!zend_jit_fetch_reference(&dasm_state, opline, orig_op2_type, &op2_info, &op2_addr,
 									!ssa->var_info[ssa_op->op2_use].guarded_reference, 1)) {
 								goto jit_failure;
 							}
 							if (ssa->vars[ssa_op->op2_use].alias == NO_ALIAS) {
 								ssa->var_info[ssa_op->op2_use].guarded_reference = 1;
 							}
 						} else {
 							CHECK_OP2_TRACE_TYPE();
 						}
 						if ((op1_info & MAY_BE_UNDEF) || (op2_info & MAY_BE_UNDEF)) {
 							break;
 						}
 						if (opline->opcode == ZEND_ADD &&
 						    (op1_info & (MAY_BE_ANY|MAY_BE_UNDEF)) == MAY_BE_ARRAY &&
 						    (op2_info & (MAY_BE_ANY|MAY_BE_UNDEF)) == MAY_BE_ARRAY) {
 							/* pass */
 						} else if (!(op1_info & (MAY_BE_LONG|MAY_BE_DOUBLE)) ||
 						    !(op2_info & (MAY_BE_LONG|MAY_BE_DOUBLE))) {
 							break;
 						}
 						res_addr = RES_REG_ADDR();
 						if (Z_MODE(res_addr) != IS_REG
 						 && zend_jit_trace_next_is_send_result(opline, p, frame)) {
 							send_result = 1;
 							res_use_info = -1;
 							res_addr = ZEND_ADDR_MEM_ZVAL(ZREG_RX, (opline+1)->result.var);
 							if (!zend_jit_reuse_ip(&dasm_state)) {
 								goto jit_failure;
 							}
 						} else {
 							res_use_info = zend_jit_trace_type_to_info(
 								STACK_MEM_TYPE(stack, EX_VAR_TO_NUM(opline->result.var)))
 									& (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG|MAY_BE_DOUBLE);
 						}
 						res_info = RES_INFO();
 						if (opline->opcode == ZEND_ADD &&
 						    (op1_info & (MAY_BE_ANY|MAY_BE_UNDEF)) == MAY_BE_ARRAY &&
 						    (op2_info & (MAY_BE_ANY|MAY_BE_UNDEF)) == MAY_BE_ARRAY) {
 							if (!zend_jit_add_arrays(&dasm_state, opline, op1_info, op1_addr, op2_info, op2_addr, res_addr)) {
 								goto jit_failure;
 							}
 						} else {
 							if (!zend_jit_math(&dasm_state, opline,
 									op1_info, op1_addr,
 									op2_info, op2_addr,
 									res_use_info, res_info, res_addr,
 									(op1_info & MAY_BE_LONG) && (op2_info & MAY_BE_LONG) && (res_info & (MAY_BE_DOUBLE|MAY_BE_GUARD)) && zend_may_overflow(opline, ssa_op, op_array, ssa),
 									zend_may_throw(opline, ssa_op, op_array, ssa))) {
 								goto jit_failure;
 							}
 							if ((res_info & (MAY_BE_ANY|MAY_BE_GUARD)) == (MAY_BE_LONG|MAY_BE_GUARD)
 							 || (res_info & (MAY_BE_ANY|MAY_BE_GUARD)) == (MAY_BE_DOUBLE|MAY_BE_GUARD)) {
 								ssa->var_info[ssa_op->result_def].type &= ~MAY_BE_GUARD;
 							}
 						}
 						goto done;
 					case ZEND_CONCAT:
 					case ZEND_FAST_CONCAT:
 						op1_info = OP1_INFO();
 						CHECK_OP1_TRACE_TYPE();
 						op2_info = OP2_INFO();
 						CHECK_OP2_TRACE_TYPE();
 						if ((op1_info & MAY_BE_UNDEF) || (op2_info & MAY_BE_UNDEF)) {
 							break;
 						}
 						if (!(op1_info & MAY_BE_STRING) ||
 						    !(op2_info & MAY_BE_STRING)) {
 							break;
 						}
 						res_addr = RES_REG_ADDR();
 						if (zend_jit_trace_next_is_send_result(opline, p, frame)) {
 							send_result = 1;
 							res_addr = ZEND_ADDR_MEM_ZVAL(ZREG_RX, (opline+1)->result.var);
 							if (!zend_jit_reuse_ip(&dasm_state)) {
 								goto jit_failure;
 							}
 						}
 						if (!zend_jit_concat(&dasm_state, opline,
 								op1_info, op2_info, res_addr,
 								zend_may_throw(opline, ssa_op, op_array, ssa))) {
 							goto jit_failure;
 						}
 						goto done;
 					case ZEND_ASSIGN_OP:
 						if (opline->op1_type != IS_CV || opline->result_type != IS_UNUSED) {
 							break;
 						}
 						op1_info = OP1_INFO();
 						CHECK_OP1_TRACE_TYPE();
 						op2_info = OP2_INFO();
 						CHECK_OP2_TRACE_TYPE();
 						if (!zend_jit_supported_binary_op(
 								opline->extended_value, op1_info, op2_info)) {
 							break;
 						}
 						op1_def_info = OP1_DEF_INFO();
 						if (op1_def_info & MAY_BE_GUARD
 						 && !has_concrete_type(op1_def_info)) {
 							op1_def_info &= ~MAY_BE_GUARD;
 						}
 						if (!zend_jit_assign_op(&dasm_state, opline,
 								op1_info, op1_def_info, OP1_RANGE(),
 								op2_info, OP2_RANGE(),
 								(op1_info & MAY_BE_LONG) && (op2_info & MAY_BE_LONG) && (op1_def_info & (MAY_BE_DOUBLE|MAY_BE_GUARD)) && zend_may_overflow(opline, ssa_op, op_array, ssa),
 								zend_may_throw(opline, ssa_op, op_array, ssa))) {
 							goto jit_failure;
 						}
 						if ((op1_def_info & (MAY_BE_ANY|MAY_BE_GUARD)) == (MAY_BE_LONG|MAY_BE_GUARD)) {
 							ssa->var_info[ssa_op->op1_def].type &= ~MAY_BE_GUARD;
 							if (opline->result_type != IS_UNUSED) {
 								ssa->var_info[ssa_op->result_def].type &= ~MAY_BE_GUARD;
 							}
 						}
 						goto done;
 					case ZEND_ASSIGN_DIM_OP:
 						if (opline->result_type != IS_UNUSED) {
 							break;
 						}
 						if (!zend_jit_supported_binary_op(
 								opline->extended_value, MAY_BE_ANY, OP1_DATA_INFO())) {
 							break;
 						}
 						op1_info = OP1_INFO();
 						op1_addr = OP1_REG_ADDR();
 						if (opline->op1_type == IS_VAR) {
 							if (orig_op1_type != IS_UNKNOWN
 							 && (orig_op1_type & IS_TRACE_INDIRECT)) {
 								if (!zend_jit_fetch_indirect_var(&dasm_state, opline, orig_op1_type,
 										&op1_info, &op1_addr, !ssa->var_info[ssa_op->op1_use].indirect_reference)) {
 									goto jit_failure;
 								}
 							} else {
 								break;
 							}
 						}
 						if (orig_op1_type != IS_UNKNOWN
 						 && (orig_op1_type & IS_TRACE_REFERENCE)) {
 							if (!zend_jit_fetch_reference(&dasm_state, opline, orig_op1_type, &op1_info, &op1_addr,
 									!ssa->var_info[ssa_op->op1_use].guarded_reference, 1)) {
 								goto jit_failure;
 							}
 							if (opline->op1_type == IS_CV
 							 && ssa->vars[ssa_op->op1_def].alias == NO_ALIAS) {
 								ssa->var_info[ssa_op->op1_def].guarded_reference = 1;
 							}
 						} else {
 							CHECK_OP1_TRACE_TYPE();
 						}
 						op2_info = OP2_INFO();
 						CHECK_OP2_TRACE_TYPE();
 						op1_data_info = OP1_DATA_INFO();
 						CHECK_OP1_DATA_TRACE_TYPE();
 						op1_def_info = OP1_DEF_INFO();
 						if (!zend_jit_assign_dim_op(&dasm_state, opline,
 								op1_info, op1_def_info, op1_addr, op2_info,
 								op1_data_info, OP1_DATA_RANGE(), val_type,
 								zend_may_throw_ex(opline, ssa_op, op_array, ssa, op1_info, op2_info))) {
 							goto jit_failure;
 						}
 						goto done;
 					case ZEND_PRE_INC_OBJ:
 					case ZEND_PRE_DEC_OBJ:
 					case ZEND_POST_INC_OBJ:
 					case ZEND_POST_DEC_OBJ:
 						if (opline->op2_type != IS_CONST
 						 || Z_TYPE_P(RT_CONSTANT(opline, opline->op2)) != IS_STRING
 						 || Z_STRVAL_P(RT_CONSTANT(opline, opline->op2))[0] == '\0') {
 							break;
 						}
 						ce = NULL;
 						ce_is_instanceof = 0;
 						on_this = delayed_fetch_this = 0;
 						op1_indirect = 0;
 						if (opline->op1_type == IS_UNUSED) {
 							op1_info = MAY_BE_OBJECT|MAY_BE_RC1|MAY_BE_RCN;
 							ce = op_array->scope;
 							ce_is_instanceof = (ce->ce_flags & ZEND_ACC_FINAL) != 0;
 							op1_addr = 0;
 							on_this = 1;
 						} else {
 							if (ssa_op->op1_use >= 0) {
 								delayed_fetch_this = ssa->var_info[ssa_op->op1_use].delayed_fetch_this;
 							}
 							op1_info = OP1_INFO();
 							if (!(op1_info & MAY_BE_OBJECT)) {
 								break;
 							}
 							op1_addr = OP1_REG_ADDR();
 							if (opline->op1_type == IS_VAR) {
 								if (orig_op1_type != IS_UNKNOWN
 								 && (orig_op1_type & IS_TRACE_INDIRECT)) {
 									op1_indirect = 1;
 									if (!zend_jit_fetch_indirect_var(&dasm_state, opline, orig_op1_type,
 											&op1_info, &op1_addr, !ssa->var_info[ssa_op->op1_use].indirect_reference)) {
 										goto jit_failure;
 									}
 								}
 							}
 							if (orig_op1_type != IS_UNKNOWN
 							 && (orig_op1_type & IS_TRACE_REFERENCE)) {
 								if (!zend_jit_fetch_reference(&dasm_state, opline, orig_op1_type, &op1_info, &op1_addr,
 										!ssa->var_info[ssa_op->op1_use].guarded_reference, 1)) {
 									goto jit_failure;
 								}
 								if (opline->op1_type == IS_CV
 								 && ssa->vars[ssa_op->op1_def].alias == NO_ALIAS) {
 									ssa->var_info[ssa_op->op1_def].guarded_reference = 1;
 								}
 							} else {
 								CHECK_OP1_TRACE_TYPE();
 							}
 							if (!(op1_info & MAY_BE_OBJECT)) {
 								break;
 							}
 							if (ssa->var_info && ssa->ops) {
 								if (ssa_op->op1_use >= 0) {
 									zend_ssa_var_info *op1_ssa = ssa->var_info + ssa_op->op1_use;
 									if (op1_ssa->ce && !op1_ssa->ce->create_object) {
 										ce = op1_ssa->ce;
 										ce_is_instanceof = op1_ssa->is_instanceof;
 									}
 								}
 							}
 							if (delayed_fetch_this) {
 								on_this = 1;
 							} else if (ssa_op->op1_use >= 0 && ssa->vars[ssa_op->op1_use].definition >= 0) {
 								on_this = ssa_opcodes[ssa->vars[ssa_op->op1_use].definition]->opcode == ZEND_FETCH_THIS;
 							} else if (op_array_ssa->ops
 							        && op_array_ssa->vars
 									&& op_array_ssa->ops[opline-op_array->opcodes].op1_use >= 0
 									&& op_array_ssa->vars[op_array_ssa->ops[opline-op_array->opcodes].op1_use].definition >= 0) {
 								on_this = op_array->opcodes[op_array_ssa->vars[op_array_ssa->ops[opline-op_array->opcodes].op1_use].definition].opcode == ZEND_FETCH_THIS;
 							}
 						}
 						if (!zend_jit_incdec_obj(&dasm_state, opline, op_array, ssa, ssa_op,
 								op1_info, op1_addr,
 								op1_indirect, ce, ce_is_instanceof, on_this, delayed_fetch_this, op1_ce,
 								val_type)) {
 							goto jit_failure;
 						}
 						goto done;
 					case ZEND_ASSIGN_OBJ_OP:
 						if (opline->result_type != IS_UNUSED) {
 							break;
 						}
 						if (opline->op2_type != IS_CONST
 						 || Z_TYPE_P(RT_CONSTANT(opline, opline->op2)) != IS_STRING
 						 || Z_STRVAL_P(RT_CONSTANT(opline, opline->op2))[0] == '\0') {
 							break;
 						}
 						if (!zend_jit_supported_binary_op(
 								opline->extended_value, MAY_BE_ANY, OP1_DATA_INFO())) {
 							break;
 						}
 						ce = NULL;
 						ce_is_instanceof = 0;
 						on_this = delayed_fetch_this = 0;
 						op1_indirect = 0;
 						if (opline->op1_type == IS_UNUSED) {
 							op1_info = MAY_BE_OBJECT|MAY_BE_RC1|MAY_BE_RCN;
 							ce = op_array->scope;
 							ce_is_instanceof = (ce->ce_flags & ZEND_ACC_FINAL) != 0;
 							op1_addr = 0;
 							on_this = 1;
 						} else {
 							if (ssa_op->op1_use >= 0) {
 								delayed_fetch_this = ssa->var_info[ssa_op->op1_use].delayed_fetch_this;
 							}
 							op1_info = OP1_INFO();
 							if (!(op1_info & MAY_BE_OBJECT)) {
 								break;
 							}
 							op1_addr = OP1_REG_ADDR();
 							if (opline->op1_type == IS_VAR) {
 								if (orig_op1_type != IS_UNKNOWN
 								 && (orig_op1_type & IS_TRACE_INDIRECT)) {
 									op1_indirect = 1;
 									if (!zend_jit_fetch_indirect_var(&dasm_state, opline, orig_op1_type,
 											&op1_info, &op1_addr, !ssa->var_info[ssa_op->op1_use].indirect_reference)) {
 										goto jit_failure;
 									}
 								}
 							}
 							if (orig_op1_type != IS_UNKNOWN
 							 && (orig_op1_type & IS_TRACE_REFERENCE)) {
 								if (!zend_jit_fetch_reference(&dasm_state, opline, orig_op1_type, &op1_info, &op1_addr,
 										!ssa->var_info[ssa_op->op1_use].guarded_reference, 1)) {
 									goto jit_failure;
 								}
 								if (opline->op1_type == IS_CV
 								 && ssa->vars[ssa_op->op1_def].alias == NO_ALIAS) {
 									ssa->var_info[ssa_op->op1_def].guarded_reference = 1;
 								}
 							} else {
 								CHECK_OP1_TRACE_TYPE();
 							}
 							if (!(op1_info & MAY_BE_OBJECT)) {
 								break;
 							}
 							if (ssa->var_info && ssa->ops) {
 								if (ssa_op->op1_use >= 0) {
 									zend_ssa_var_info *op1_ssa = ssa->var_info + ssa_op->op1_use;
 									if (op1_ssa->ce && !op1_ssa->ce->create_object) {
 										ce = op1_ssa->ce;
 										ce_is_instanceof = op1_ssa->is_instanceof;
 									}
 								}
 							}
 							if (delayed_fetch_this) {
 								on_this = 1;
 							} else if (ssa_op->op1_use >= 0 && ssa->vars[ssa_op->op1_use].definition >= 0) {
 								on_this = ssa_opcodes[ssa->vars[ssa_op->op1_use].definition]->opcode == ZEND_FETCH_THIS;
 							} else if (op_array_ssa->ops
 							        && op_array_ssa->vars
 									&& op_array_ssa->ops[opline-op_array->opcodes].op1_use >= 0
 									&& op_array_ssa->vars[op_array_ssa->ops[opline-op_array->opcodes].op1_use].definition >= 0) {
 								on_this = op_array->opcodes[op_array_ssa->vars[op_array_ssa->ops[opline-op_array->opcodes].op1_use].definition].opcode == ZEND_FETCH_THIS;
 							}
 						}
 						op1_data_info = OP1_DATA_INFO();
 						CHECK_OP1_DATA_TRACE_TYPE();
 						if (!zend_jit_assign_obj_op(&dasm_state, opline, op_array, ssa, ssa_op,
 								op1_info, op1_addr, op1_data_info, OP1_DATA_RANGE(),
 								op1_indirect, ce, ce_is_instanceof, on_this, delayed_fetch_this, op1_ce,
 								val_type)) {
 							goto jit_failure;
 						}
 						goto done;
 					case ZEND_ASSIGN_OBJ:
 						if (opline->op2_type != IS_CONST
 						 || Z_TYPE_P(RT_CONSTANT(opline, opline->op2)) != IS_STRING
 						 || Z_STRVAL_P(RT_CONSTANT(opline, opline->op2))[0] == '\0') {
 							break;
 						}
 						ce = NULL;
 						ce_is_instanceof = 0;
 						on_this = delayed_fetch_this = 0;
 						op1_indirect = 0;
 						if (opline->op1_type == IS_UNUSED) {
 							op1_info = MAY_BE_OBJECT|MAY_BE_RC1|MAY_BE_RCN;
 							ce = op_array->scope;
 							ce_is_instanceof = (ce->ce_flags & ZEND_ACC_FINAL) != 0;
 							op1_addr = 0;
 							on_this = 1;
 						} else {
 							if (ssa_op->op1_use >= 0) {
 								delayed_fetch_this = ssa->var_info[ssa_op->op1_use].delayed_fetch_this;
 							}
 							op1_info = OP1_INFO();
 							if (!(op1_info & MAY_BE_OBJECT)) {
 								break;
 							}
 							op1_addr = OP1_REG_ADDR();
 							if (opline->op1_type == IS_VAR) {
 								if (orig_op1_type != IS_UNKNOWN
 								 && (orig_op1_type & IS_TRACE_INDIRECT)) {
 									op1_indirect = 1;
 									if (!zend_jit_fetch_indirect_var(&dasm_state, opline, orig_op1_type,
 											&op1_info, &op1_addr, !ssa->var_info[ssa_op->op1_use].indirect_reference)) {
 										goto jit_failure;
 									}
 								}
 							}
 							if (orig_op1_type != IS_UNKNOWN
 							 && (orig_op1_type & IS_TRACE_REFERENCE)) {
 								if (!zend_jit_fetch_reference(&dasm_state, opline, orig_op1_type, &op1_info, &op1_addr,
 										!ssa->var_info[ssa_op->op1_use].guarded_reference, 1)) {
 									goto jit_failure;
 								}
 								if (opline->op1_type == IS_CV
 								 && ssa->vars[ssa_op->op1_def].alias == NO_ALIAS) {
 									ssa->var_info[ssa_op->op1_def].guarded_reference = 1;
 								}
 							} else {
 								CHECK_OP1_TRACE_TYPE();
 							}
 							if (!(op1_info & MAY_BE_OBJECT)) {
 								break;
 							}
 							if (ssa->var_info && ssa->ops) {
 								if (ssa_op->op1_use >= 0) {
 									zend_ssa_var_info *op1_ssa = ssa->var_info + ssa_op->op1_use;
 									if (op1_ssa->ce && !op1_ssa->ce->create_object) {
 										ce = op1_ssa->ce;
 										ce_is_instanceof = op1_ssa->is_instanceof;
 									}
 								}
 							}
 							if (delayed_fetch_this) {
 								on_this = 1;
 							} else if (ssa_op->op1_use >= 0 && ssa->vars[ssa_op->op1_use].definition >= 0) {
 								on_this = ssa_opcodes[ssa->vars[ssa_op->op1_use].definition]->opcode == ZEND_FETCH_THIS;
 							} else if (op_array_ssa->ops
 							        && op_array_ssa->vars
 									&& op_array_ssa->ops[opline-op_array->opcodes].op1_use >= 0
 									&& op_array_ssa->vars[op_array_ssa->ops[opline-op_array->opcodes].op1_use].definition >= 0) {
 								on_this = op_array->opcodes[op_array_ssa->vars[op_array_ssa->ops[opline-op_array->opcodes].op1_use].definition].opcode == ZEND_FETCH_THIS;
 							}
 						}
 						op1_data_info = OP1_DATA_INFO();
 						CHECK_OP1_DATA_TRACE_TYPE();
 						if (!zend_jit_assign_obj(&dasm_state, opline, op_array, ssa, ssa_op,
 								op1_info, op1_addr, op1_data_info,
 								op1_indirect, ce, ce_is_instanceof, on_this, delayed_fetch_this, op1_ce,
 								val_type,
 								zend_may_throw(opline, ssa_op, op_array, ssa))) {
 							goto jit_failure;
 						}
 						if ((opline+1)->op1_type == IS_CV
 						 && (ssa_op+1)->op1_def >= 0
 						 && ssa->vars[(ssa_op+1)->op1_def].alias == NO_ALIAS) {
 							ssa->var_info[(ssa_op+1)->op1_def].guarded_reference = ssa->var_info[(ssa_op+1)->op1_use].guarded_reference;
 						}
 						goto done;
 					case ZEND_ASSIGN_DIM:
 						op1_info = OP1_INFO();
 						op1_addr = OP1_REG_ADDR();
 						if (opline->op1_type == IS_VAR) {
 							if (orig_op1_type != IS_UNKNOWN
 							 && (orig_op1_type & IS_TRACE_INDIRECT)
 							 && opline->result_type == IS_UNUSED) {
 								if (!zend_jit_fetch_indirect_var(&dasm_state, opline, orig_op1_type,
 										&op1_info, &op1_addr, !ssa->var_info[ssa_op->op1_use].indirect_reference)) {
 									goto jit_failure;
 								}
 							} else {
 								break;
 							}
 						}
 						if (orig_op1_type != IS_UNKNOWN
 						 && (orig_op1_type & IS_TRACE_REFERENCE)) {
 							if (!zend_jit_fetch_reference(&dasm_state, opline, orig_op1_type, &op1_info, &op1_addr,
 									!ssa->var_info[ssa_op->op1_use].guarded_reference, 1)) {
 								goto jit_failure;
 							}
 							if (opline->op1_type == IS_CV
 							 && ssa->vars[ssa_op->op1_def].alias == NO_ALIAS) {
 								ssa->var_info[ssa_op->op1_def].guarded_reference = 1;
 							}
 						} else {
 							CHECK_OP1_TRACE_TYPE();
 						}
 						op2_info = OP2_INFO();
 						CHECK_OP2_TRACE_TYPE();
 						op1_data_info = OP1_DATA_INFO();
 						CHECK_OP1_DATA_TRACE_TYPE();
 						if (!zend_jit_assign_dim(&dasm_state, opline,
 								op1_info, op1_addr, op2_info, op1_data_info, val_type,
 								zend_may_throw_ex(opline, ssa_op, op_array, ssa, op1_info, op2_info))) {
 							goto jit_failure;
 						}
 						if ((opline+1)->op1_type == IS_CV
 						 && (ssa_op+1)->op1_def >= 0
 						 && ssa->vars[(ssa_op+1)->op1_def].alias == NO_ALIAS) {
 							ssa->var_info[(ssa_op+1)->op1_def].guarded_reference = ssa->var_info[(ssa_op+1)->op1_use].guarded_reference;
 						}
 						goto done;
 					case ZEND_ASSIGN:
 						if (opline->op1_type != IS_CV) {
 							break;
 						}
 						op2_addr = OP2_REG_ADDR();
 						if (ra
 						 && ssa_op->op2_def >= 0
 						 && !ssa->vars[ssa_op->op2_def].no_val) {
 							op2_def_addr = OP2_DEF_REG_ADDR();
 						} else {
 							op2_def_addr = op2_addr;
 						}
 						op2_info = OP2_INFO();
 						CHECK_OP2_TRACE_TYPE();
 						op1_info = OP1_INFO();
 						CHECK_OP1_TRACE_TYPE();
 						op1_def_info = OP1_DEF_INFO();
 						op1_addr = OP1_REG_ADDR();
 						op1_def_addr = OP1_DEF_REG_ADDR();
 						if (orig_op1_type != IS_UNKNOWN) {
 							if (orig_op1_type & IS_TRACE_REFERENCE) {
 								if (!zend_jit_fetch_reference(&dasm_state, opline, orig_op1_type, &op1_info, &op1_addr,
 										!ssa->var_info[ssa_op->op1_use].guarded_reference, 0)) {
 									goto jit_failure;
 								}
 								if (opline->op1_type == IS_CV
 								 && ssa->vars[ssa_op->op1_def].alias == NO_ALIAS) {
 									ssa->var_info[ssa_op->op1_def].guarded_reference = 1;
 								}
-								if (!zend_jit_assign_to_typed_ref(&dasm_state, opline, opline->op2_type, op2_addr, 1)) {
+								if (opline->result_type == IS_UNUSED) {
+									res_addr = 0;
+								} else {
+									res_addr = RES_REG_ADDR();
+								}
+								if (!zend_jit_assign_to_typed_ref(&dasm_state, opline, opline->op2_type, op2_addr, res_addr, 1)) {
 									goto jit_failure;
 								}
 								op1_def_addr = op1_addr;
 								op1_def_info &= ~MAY_BE_REF;
 							} else if (op1_info & MAY_BE_REF) {
 								if (!zend_jit_noref_guard(&dasm_state, opline, op1_addr)) {
 									goto jit_failure;
 								}
 								op1_info &= ~MAY_BE_REF;
 								op1_def_info &= ~MAY_BE_REF;
 							}
 						}
 						if (opline->result_type == IS_UNUSED) {
 							res_addr = 0;
 							res_info = -1;
 						} else {
 							res_addr = RES_REG_ADDR();
 							res_info = RES_INFO();
 							if (Z_MODE(res_addr) != IS_REG
 							 && zend_jit_trace_next_is_send_result(opline, p, frame)) {
 								send_result = 1;
 								res_addr = ZEND_ADDR_MEM_ZVAL(ZREG_RX, (opline+1)->result.var);
 								if (!zend_jit_reuse_ip(&dasm_state)) {
 									goto jit_failure;
 								}
 							}
 						}
 						if (!zend_jit_assign(&dasm_state, opline,
 								op1_info, op1_addr,
 								op1_def_info, op1_def_addr,
 								op2_info, op2_addr, op2_def_addr,
 								res_info, res_addr,
 								zend_may_throw_ex(opline, ssa_op, op_array, ssa, op1_info, op2_info))) {
 							goto jit_failure;
 						}
 						if (opline->op2_type == IS_CV
 						 && ssa_op->op2_def >= 0
 						 && ssa->vars[ssa_op->op2_def].alias == NO_ALIAS) {
 							ssa->var_info[ssa_op->op2_def].guarded_reference = ssa->var_info[ssa_op->op2_use].guarded_reference;
 						}
 						goto done;
 					case ZEND_CAST:
 						if (opline->extended_value != op1_type) {
 							break;
 						}
 						ZEND_FALLTHROUGH;
 					case ZEND_QM_ASSIGN:
 						op1_addr = OP1_REG_ADDR();
 						if (ra
 						 && ssa_op->op1_def >= 0
 						 && !ssa->vars[ssa_op->op1_def].no_val) {
 							op1_def_addr = OP1_DEF_REG_ADDR();
 						} else {
 							op1_def_addr = op1_addr;
 						}
 						op1_info = OP1_INFO();
 						CHECK_OP1_TRACE_TYPE();
 						res_info = RES_INFO();
 						res_use_info = zend_jit_trace_type_to_info(
 							STACK_MEM_TYPE(stack, EX_VAR_TO_NUM(opline->result.var)))
 								& (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG|MAY_BE_DOUBLE);
 						if (!zend_jit_qm_assign(&dasm_state, opline,
 								op1_info, op1_addr, op1_def_addr,
 								res_use_info, res_info, RES_REG_ADDR())) {
 							goto jit_failure;
 						}
 						if (opline->op1_type == IS_CV
 						 && ssa_op->op1_def >= 0
 						 && ssa->vars[ssa_op->op1_def].alias == NO_ALIAS) {
 							ssa->var_info[ssa_op->op1_def].guarded_reference = ssa->var_info[ssa_op->op1_use].guarded_reference;
 						}
 						goto done;
 					case ZEND_INIT_FCALL:
 					case ZEND_INIT_FCALL_BY_NAME:
 					case ZEND_INIT_NS_FCALL_BY_NAME:
 						frame_flags = TRACE_FRAME_MASK_NESTED;
 						if (!zend_jit_init_fcall(&dasm_state, opline, op_array_ssa->cfg.map ? op_array_ssa->cfg.map[opline - op_array->opcodes] : -1, op_array, ssa, ssa_op, frame->call_level, p + 1, peek_checked_stack - checked_stack)) {
 							goto jit_failure;
 						}
 						goto done;
 					case ZEND_SEND_VAL:
 					case ZEND_SEND_VAL_EX:
 						if (opline->op2_type == IS_CONST) {
 							/* Named parameters not supported in JIT */
 							break;
 						}
 						if (opline->opcode == ZEND_SEND_VAL_EX
 						 && opline->op2.num > MAX_ARG_FLAG_NUM) {
 							break;
 						}
 						op1_info = OP1_INFO();
 						CHECK_OP1_TRACE_TYPE();
 						if (!zend_jit_send_val(&dasm_state, opline,
 								op1_info, OP1_REG_ADDR())) {
 							goto jit_failure;
 						}
 						if (frame->call && frame->call->func) {
 							if (opline->op1_type == IS_CONST) {
 								zend_jit_trace_send_type(opline, frame->call, Z_TYPE_P(RT_CONSTANT(opline, opline->op1)));
 							} else if (op1_type != IS_UNKNOWN) {
 								if (op1_type == IS_UNDEF) {
 									op1_type = IS_NULL;
 								}
 								zend_jit_trace_send_type(opline, frame->call, op1_type);
 							}
 						}
 						goto done;
 					case ZEND_SEND_REF:
 						if (opline->op2_type == IS_CONST) {
 							/* Named parameters not supported in JIT */
 							break;
 						}
 						op1_info = OP1_INFO();
 						if (!zend_jit_send_ref(&dasm_state, opline, op_array,
 								op1_info, 0)) {
 							goto jit_failure;
 						}
 						if (opline->op1_type == IS_CV
 						 && ssa->vars[ssa_op->op1_def].alias == NO_ALIAS) {
 							ssa->var_info[ssa_op->op1_def].guarded_reference = 1;
 						}
 						goto done;
 					case ZEND_SEND_VAR:
 					case ZEND_SEND_VAR_EX:
 					case ZEND_SEND_VAR_NO_REF:
 					case ZEND_SEND_VAR_NO_REF_EX:
 					case ZEND_SEND_FUNC_ARG:
 						if (opline->op2_type == IS_CONST) {
 							/* Named parameters not supported in JIT */
 							break;
 						}
 						if ((opline->opcode == ZEND_SEND_VAR_EX
 						  || opline->opcode == ZEND_SEND_VAR_NO_REF_EX)
 						 && opline->op2.num > MAX_ARG_FLAG_NUM) {
 							break;
 						}
 						op1_addr = OP1_REG_ADDR();
 						if (ra
 						 && ssa_op->op1_def >= 0
 						 && !ssa->vars[ssa_op->op1_def].no_val) {
 							op1_def_addr = OP1_DEF_REG_ADDR();
 						} else {
 							op1_def_addr = op1_addr;
 						}
 						op1_info = OP1_INFO();
 						CHECK_OP1_TRACE_TYPE();
 						if (!zend_jit_send_var(&dasm_state, opline, op_array,
 								op1_info, op1_addr, op1_def_addr)) {
 							goto jit_failure;
 						}
 						if (opline->op1_type == IS_CV
 						 && ssa_op->op1_def >= 0
 						 && ssa->vars[ssa_op->op1_def].alias == NO_ALIAS) {
 							ssa->var_info[ssa_op->op1_def].guarded_reference = ssa->var_info[ssa_op->op1_use].guarded_reference;
 						}
 						if (frame->call && frame->call->func) {
 							if ((opline->opcode == ZEND_SEND_VAR_EX
 							  || opline->opcode == ZEND_SEND_FUNC_ARG)
 							 && ARG_SHOULD_BE_SENT_BY_REF(frame->call->func, opline->op2.num)) {
 								goto done;
 							}
 							if (op1_type != IS_UNKNOWN) {
 								if (op1_type == IS_UNDEF) {
 									op1_type = IS_NULL;
 								}
 								zend_jit_trace_send_type(opline, frame->call, op1_type);
 							}
 						}
 						goto done;
 					case ZEND_CHECK_FUNC_ARG:
 						if (!JIT_G(current_frame)
 						 || !JIT_G(current_frame)->call
 						 || !JIT_G(current_frame)->call->func) {
 							break;
 						}
 						if (opline->op2_type == IS_CONST
 						 || opline->op2.num > MAX_ARG_FLAG_NUM) {
 							/* Named parameters not supported in JIT */
 							TRACE_FRAME_SET_LAST_SEND_UNKNOWN(JIT_G(current_frame)->call);
 							break;
 						}
 						if (!zend_jit_check_func_arg(&dasm_state, opline)) {
 							goto jit_failure;
 						}
 						goto done;
 					case ZEND_CHECK_UNDEF_ARGS:
 						if (!zend_jit_check_undef_args(&dasm_state, opline)) {
 							goto jit_failure;
 						}
 						goto done;
 					case ZEND_DO_UCALL:
 					case ZEND_DO_ICALL:
 					case ZEND_DO_FCALL_BY_NAME:
 					case ZEND_DO_FCALL:
 						if (!zend_jit_do_fcall(&dasm_state, opline, op_array, op_array_ssa, frame->call_level, -1, p + 1)) {
 							goto jit_failure;
 						}
 						goto done;
 					case ZEND_IS_EQUAL:
 					case ZEND_IS_NOT_EQUAL:
 					case ZEND_IS_SMALLER:
 					case ZEND_IS_SMALLER_OR_EQUAL:
 					case ZEND_CASE:
 						op1_info = OP1_INFO();
 						op2_info = OP2_INFO();
 						skip_comparison =
 							ssa_op != ssa->ops &&
 							(op1_info & (MAY_BE_ANY|MAY_BE_UNDEF)) == MAY_BE_LONG &&
 							(op2_info & (MAY_BE_ANY|MAY_BE_UNDEF)) == MAY_BE_LONG &&
 							zend_jit_may_skip_comparison(opline, ssa_op, ssa, ssa_opcodes);
 						CHECK_OP1_TRACE_TYPE();
 						CHECK_OP2_TRACE_TYPE();
 						if ((opline->result_type & (IS_SMART_BRANCH_JMPZ|IS_SMART_BRANCH_JMPNZ)) != 0) {
 							bool exit_if_true = 0;
 							const zend_op *exit_opline = zend_jit_trace_get_exit_opline(p + 1, opline + 1, &exit_if_true);
 							uint32_t exit_point;
 
 							if (ra) {
 								zend_jit_trace_clenup_stack(stack, opline, ssa_op, ssa, ra);
 							}
 							exit_point = zend_jit_trace_get_exit_point(exit_opline, 0);
 							exit_addr = zend_jit_trace_get_exit_addr(exit_point);
 							if (!exit_addr) {
 								goto jit_failure;
 							}
 							smart_branch_opcode = exit_if_true ? ZEND_JMPNZ : ZEND_JMPZ;
 							if (!zend_jit_cmp(&dasm_state, opline,
 									op1_info, OP1_RANGE(), OP1_REG_ADDR(),
 									op2_info, OP2_RANGE(), OP2_REG_ADDR(),
 									RES_REG_ADDR(),
 									zend_may_throw(opline, ssa_op, op_array, ssa),
 									smart_branch_opcode, -1, -1, exit_addr, skip_comparison)) {
 								goto jit_failure;
 							}
 							zend_jit_trace_update_condition_ranges(opline, ssa_op, op_array, ssa, exit_if_true);
 						} else {
 							smart_branch_opcode = 0;
 							exit_addr = NULL;
 							if (!zend_jit_cmp(&dasm_state, opline,
 									op1_info, OP1_RANGE(), OP1_REG_ADDR(),
 									op2_info, OP2_RANGE(), OP2_REG_ADDR(),
 									RES_REG_ADDR(),
 									zend_may_throw(opline, ssa_op, op_array, ssa),
 									smart_branch_opcode, -1, -1, exit_addr, skip_comparison)) {
 								goto jit_failure;
 							}
 						}
 						goto done;
 					case ZEND_IS_IDENTICAL:
 					case ZEND_IS_NOT_IDENTICAL:
 					case ZEND_CASE_STRICT:
 						op1_info = OP1_INFO();
 						op2_info = OP2_INFO();
 						skip_comparison =
 							ssa_op != ssa->ops &&
 							(op1_info & (MAY_BE_ANY|MAY_BE_UNDEF)) == MAY_BE_LONG &&
 							(op2_info & (MAY_BE_ANY|MAY_BE_UNDEF)) == MAY_BE_LONG &&
 							zend_jit_may_skip_comparison(opline, ssa_op, ssa, ssa_opcodes);
 						CHECK_OP1_TRACE_TYPE();
 						CHECK_OP2_TRACE_TYPE();
 						if ((opline->result_type & (IS_SMART_BRANCH_JMPZ|IS_SMART_BRANCH_JMPNZ)) != 0) {
 							bool exit_if_true = 0;
 							const zend_op *exit_opline = zend_jit_trace_get_exit_opline(p + 1, opline + 1, &exit_if_true);
 							uint32_t exit_point;
 
 							if (ra) {
 								zend_jit_trace_clenup_stack(stack, opline, ssa_op, ssa, ra);
 							}
 							exit_point = zend_jit_trace_get_exit_point(exit_opline, 0);
 							exit_addr = zend_jit_trace_get_exit_addr(exit_point);
 							if (!exit_addr) {
 								goto jit_failure;
 							}
 							if (opline->opcode == ZEND_IS_NOT_IDENTICAL) {
 								exit_if_true = !exit_if_true;
 							}
 							smart_branch_opcode = exit_if_true ? ZEND_JMPNZ : ZEND_JMPZ;
 							if (!zend_jit_identical(&dasm_state, opline,
 									op1_info, OP1_RANGE(), OP1_REG_ADDR(),
 									op2_info, OP2_RANGE(), OP2_REG_ADDR(),
 									RES_REG_ADDR(),
 									zend_may_throw(opline, ssa_op, op_array, ssa),
 									smart_branch_opcode, -1, -1, exit_addr, skip_comparison)) {
 								goto jit_failure;
 							}
 							zend_jit_trace_update_condition_ranges(opline, ssa_op, op_array, ssa, exit_if_true);
 						} else {
 							smart_branch_opcode = 0;
 							exit_addr = NULL;
 							if (!zend_jit_identical(&dasm_state, opline,
 									op1_info, OP1_RANGE(), OP1_REG_ADDR(),
 									op2_info, OP2_RANGE(), OP2_REG_ADDR(),
 									RES_REG_ADDR(),
 									zend_may_throw(opline, ssa_op, op_array, ssa),
 									smart_branch_opcode, -1, -1, exit_addr, skip_comparison)) {
 								goto jit_failure;
 							}
 						}
 						goto done;
 					case ZEND_DEFINED:
 						if ((opline->result_type & (IS_SMART_BRANCH_JMPZ|IS_SMART_BRANCH_JMPNZ)) != 0) {
 							bool exit_if_true = 0;
 							const zend_op *exit_opline = zend_jit_trace_get_exit_opline(p + 1, opline + 1, &exit_if_true);
 							uint32_t exit_point = zend_jit_trace_get_exit_point(exit_opline, 0);
 
 							exit_addr = zend_jit_trace_get_exit_addr(exit_point);
 							if (!exit_addr) {
 								goto jit_failure;
 							}
 							smart_branch_opcode = exit_if_true ? ZEND_JMPNZ : ZEND_JMPZ;
 						} else {
 							smart_branch_opcode = 0;
 							exit_addr = NULL;
 						}
 						if (!zend_jit_defined(&dasm_state, opline, smart_branch_opcode, -1, -1, exit_addr)) {
 							goto jit_failure;
 						}
 						goto done;
 					case ZEND_TYPE_CHECK:
 						if (opline->extended_value == MAY_BE_RESOURCE) {
 							// TODO: support for is_resource() ???
 							break;
 						}
 						op1_info = OP1_INFO();
 						CHECK_OP1_TRACE_TYPE();
 						if ((opline->result_type & (IS_SMART_BRANCH_JMPZ|IS_SMART_BRANCH_JMPNZ)) != 0) {
 							bool exit_if_true = 0;
 							const zend_op *exit_opline = zend_jit_trace_get_exit_opline(p + 1, opline + 1, &exit_if_true);
 							uint32_t exit_point;
 
 							if (ra) {
 								zend_jit_trace_clenup_stack(stack, opline, ssa_op, ssa, ra);
 							}
 							exit_point = zend_jit_trace_get_exit_point(exit_opline, 0);
 							exit_addr = zend_jit_trace_get_exit_addr(exit_point);
 							if (!exit_addr) {
 								goto jit_failure;
 							}
 							smart_branch_opcode = exit_if_true ? ZEND_JMPNZ : ZEND_JMPZ;
 						} else {
 							smart_branch_opcode = 0;
 							exit_addr = NULL;
 						}
 						if (!zend_jit_type_check(&dasm_state, opline, op1_info, smart_branch_opcode, -1, -1, exit_addr)) {
 							goto jit_failure;
 						}
 						goto done;
 					case ZEND_RETURN:
 						op1_info = OP1_INFO();
 						CHECK_OP1_TRACE_TYPE();
 						if (opline->op1_type == IS_CONST) {
 							res_type = Z_TYPE_P(RT_CONSTANT(opline, opline->op1));
 						} else if (op1_type != IS_UNKNOWN) {
 							res_type = op1_type;
 						}
 						if (op_array->type == ZEND_EVAL_CODE
 						 // TODO: support for top-level code
 						 || !op_array->function_name
 						 // TODO: support for IS_UNDEF ???
 						 || (op1_info & MAY_BE_UNDEF)) {
 							if (!zend_jit_trace_handler(&dasm_state, op_array, opline, zend_may_throw(opline, ssa_op, op_array, ssa), p + 1)) {
 								goto jit_failure;
 							}
 						} else {
 							int j;
 							int may_throw = 0;
 							bool left_frame = 0;
 
 							if (!zend_jit_return(&dasm_state, opline, op_array,
 									op1_info, OP1_REG_ADDR())) {
 								goto jit_failure;
 							}
 							if (op_array->last_var > 100) {
 								/* To many CVs to unroll */
 								if (!zend_jit_free_cvs(&dasm_state)) {
 									goto jit_failure;
 								}
 								left_frame = 1;
 							}
 							if (!left_frame) {
 								for (j = 0 ; j < op_array->last_var; j++) {
 									uint32_t info;
 									zend_uchar type;
 
 									info = zend_ssa_cv_info(op_array, op_array_ssa, j);
 									type = STACK_TYPE(stack, j);
 									info = zend_jit_trace_type_to_info_ex(type, info);
 									if (opline->op1_type == IS_CV
 									 && EX_VAR_TO_NUM(opline->op1.var) == j
 									 && !(op1_info & (MAY_BE_REF|MAY_BE_OBJECT))) {
 										if (JIT_G(current_frame)
 										 && TRACE_FRAME_IS_RETURN_VALUE_USED(JIT_G(current_frame))) {
 											continue;
 										} else {
 											info |= MAY_BE_NULL;
 										}
 									}
 									if (info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_REF)) {
 										if (!left_frame) {
 											left_frame = 1;
 										    if (!zend_jit_leave_frame(&dasm_state)) {
 												goto jit_failure;
 										    }
 										}
 										if (!zend_jit_free_cv(&dasm_state, info, j)) {
 											goto jit_failure;
 										}
 										if (info & (MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_ARRAY_OF_OBJECT|MAY_BE_ARRAY_OF_ARRAY|MAY_BE_ARRAY_OF_RESOURCE)) {
 											if (info & MAY_BE_RC1) {
 												may_throw = 1;
 											}
 										}
 									}
 								}
 							}
 							if (!zend_jit_leave_func(&dasm_state, op_array, opline, op1_info, left_frame,
 									p + 1, &zend_jit_traces[ZEND_JIT_TRACE_NUM],
 									(op_array_ssa->cfg.flags & ZEND_FUNC_INDIRECT_VAR_ACCESS) != 0, may_throw)) {
 								goto jit_failure;
 							}
 						}
 						goto done;
 					case ZEND_BOOL:
 					case ZEND_BOOL_NOT:
 						op1_info = OP1_INFO();
 						CHECK_OP1_TRACE_TYPE();
 						if (!zend_jit_bool_jmpznz(&dasm_state, opline,
 								op1_info, OP1_REG_ADDR(), RES_REG_ADDR(),
 								-1, -1,
 								zend_may_throw(opline, ssa_op, op_array, ssa),
 								opline->opcode, NULL)) {
 							goto jit_failure;
 						}
 						goto done;
 					case ZEND_JMPZ:
 					case ZEND_JMPNZ:
 						if (/*opline > op_array->opcodes + ssa->cfg.blocks[b].start && ??? */
 						    opline->op1_type == IS_TMP_VAR &&
 						    ((opline-1)->result_type & (IS_SMART_BRANCH_JMPZ|IS_SMART_BRANCH_JMPNZ)) != 0) {
 							/* smart branch */
 							break;
 						}
 						ZEND_FALLTHROUGH;
 					case ZEND_JMPZNZ:
 					case ZEND_JMPZ_EX:
 					case ZEND_JMPNZ_EX:
 						if ((p+1)->op == ZEND_JIT_TRACE_VM || (p+1)->op == ZEND_JIT_TRACE_END) {
 							const zend_op *exit_opline = NULL;
 							uint32_t exit_point;
 
 							if ((p+1)->opline == OP_JMP_ADDR(opline, opline->op2)) {
 								/* taken branch */
 								if (opline->opcode == ZEND_JMPNZ_EX) {
 									smart_branch_opcode = ZEND_JMPZ_EX;
 								} else if (opline->opcode == ZEND_JMPZ_EX) {
 									smart_branch_opcode = ZEND_JMPNZ_EX;
 								} else if (opline->opcode == ZEND_JMPNZ) {
 									smart_branch_opcode = ZEND_JMPZ;
 								} else {
 									smart_branch_opcode = ZEND_JMPNZ;
 								}
 								exit_opline = (opline->opcode == ZEND_JMPZNZ) ?
 									ZEND_OFFSET_TO_OPLINE(opline, opline->extended_value) :
 									opline + 1;
 							} else if (opline->opcode == ZEND_JMPZNZ) {
 								ZEND_ASSERT((p+1)->opline == ZEND_OFFSET_TO_OPLINE(opline, opline->extended_value));
 								smart_branch_opcode = ZEND_JMPZ;
 								exit_opline = OP_JMP_ADDR(opline, opline->op2);
 							} else if ((p+1)->opline == opline + 1) {
 								/* not taken branch */
 								smart_branch_opcode = opline->opcode;
 								exit_opline = OP_JMP_ADDR(opline, opline->op2);
 							} else {
 								ZEND_UNREACHABLE();
 							}
 							if (ra) {
 								zend_jit_trace_clenup_stack(stack, opline, ssa_op, ssa, ra);
 							}
 							if (opline->result_type == IS_TMP_VAR) {
 								zend_jit_trace_stack *stack = JIT_G(current_frame)->stack;
 								uint32_t old_info = STACK_INFO(stack, EX_VAR_TO_NUM(opline->result.var));
 
 								SET_STACK_TYPE(stack, EX_VAR_TO_NUM(opline->result.var), IS_UNKNOWN, 1);
 								exit_point = zend_jit_trace_get_exit_point(exit_opline, 0);
 								SET_STACK_INFO(stack, EX_VAR_TO_NUM(opline->result.var), old_info);
 							} else {
 								exit_point = zend_jit_trace_get_exit_point(exit_opline, 0);
 							}
 							exit_addr = zend_jit_trace_get_exit_addr(exit_point);
 							if (!exit_addr) {
 								goto jit_failure;
 							}
 						} else  {
 							ZEND_UNREACHABLE();
 						}
 						if (opline->result_type == IS_UNDEF) {
 							res_addr = 0;
 						} else {
 							res_addr = RES_REG_ADDR();
 						}
 						op1_info = OP1_INFO();
 						CHECK_OP1_TRACE_TYPE();
 						if (!zend_jit_bool_jmpznz(&dasm_state, opline,
 								op1_info, OP1_REG_ADDR(), res_addr,
 								-1, -1,
 								zend_may_throw(opline, ssa_op, op_array, ssa),
 								smart_branch_opcode, exit_addr)) {
 							goto jit_failure;
 						}
 						goto done;
 					case ZEND_ISSET_ISEMPTY_CV:
 						if ((opline->extended_value & ZEND_ISEMPTY)) {
 							// TODO: support for empty() ???
 							break;
 						}
 						op1_info = OP1_INFO();
 						op1_addr = OP1_REG_ADDR();
 						if (orig_op1_type != IS_UNKNOWN
 						 && (orig_op1_type & IS_TRACE_REFERENCE)) {
 							if (!zend_jit_fetch_reference(&dasm_state, opline, orig_op1_type, &op1_info, &op1_addr,
 									!ssa->var_info[ssa_op->op1_use].guarded_reference, 1)) {
 								goto jit_failure;
 							}
 							if (opline->op1_type == IS_CV
 							 && ssa->vars[ssa_op->op1_use].alias == NO_ALIAS) {
 								ssa->var_info[ssa_op->op1_use].guarded_reference = 1;
 							}
 						} else {
 							CHECK_OP1_TRACE_TYPE();
 						}
 						if ((opline->result_type & (IS_SMART_BRANCH_JMPZ|IS_SMART_BRANCH_JMPNZ)) != 0) {
 							bool exit_if_true = 0;
 							const zend_op *exit_opline = zend_jit_trace_get_exit_opline(p + 1, opline + 1, &exit_if_true);
 							uint32_t exit_point = zend_jit_trace_get_exit_point(exit_opline, 0);
 
 							exit_addr = zend_jit_trace_get_exit_addr(exit_point);
 							if (!exit_addr) {
 								goto jit_failure;
 							}
 							smart_branch_opcode = exit_if_true ? ZEND_JMPNZ : ZEND_JMPZ;
 						} else {
 							smart_branch_opcode = 0;
 							exit_addr = NULL;
 						}
 						if (!zend_jit_isset_isempty_cv(&dasm_state, opline,
 								op1_info, op1_addr,
 								smart_branch_opcode, -1, -1, exit_addr)) {
 							goto jit_failure;
 						}
 						goto done;
 					case ZEND_IN_ARRAY:
 						if (opline->op1_type == IS_VAR || opline->op1_type == IS_TMP_VAR) {
 							break;
 						}
 						op1_info = OP1_INFO();
 						op1_addr = OP1_REG_ADDR();
 						CHECK_OP1_TRACE_TYPE();
 						if ((op1_info & (MAY_BE_ANY|MAY_BE_UNDEF|MAY_BE_REF)) != MAY_BE_STRING) {
 							break;
 						}
 						if ((opline->result_type & (IS_SMART_BRANCH_JMPZ|IS_SMART_BRANCH_JMPNZ)) != 0) {
 							bool exit_if_true = 0;
 							const zend_op *exit_opline = zend_jit_trace_get_exit_opline(p + 1, opline + 1, &exit_if_true);
 							uint32_t exit_point = zend_jit_trace_get_exit_point(exit_opline, 0);
 
 							exit_addr = zend_jit_trace_get_exit_addr(exit_point);
 							if (!exit_addr) {
 								goto jit_failure;
 							}
 							smart_branch_opcode = exit_if_true ? ZEND_JMPNZ : ZEND_JMPZ;
 						} else {
 							smart_branch_opcode = 0;
 							exit_addr = NULL;
 						}
 						if (!zend_jit_in_array(&dasm_state, opline,
 								op1_info, op1_addr,
 								smart_branch_opcode, -1, -1, exit_addr)) {
 							goto jit_failure;
 						}
 						goto done;
 					case ZEND_FETCH_DIM_FUNC_ARG:
 						if (!JIT_G(current_frame)
 						 || !JIT_G(current_frame)->call
 						 || !JIT_G(current_frame)->call->func
 						 || !TRACE_FRAME_IS_LAST_SEND_BY_VAL(JIT_G(current_frame)->call)) {
 							break;
 						}
 						ZEND_FALLTHROUGH;
 					case ZEND_FETCH_DIM_R:
 					case ZEND_FETCH_DIM_IS:
 					case ZEND_FETCH_LIST_R:
 						op1_info = OP1_INFO();
 						op1_addr = OP1_REG_ADDR();
 						if (orig_op1_type != IS_UNKNOWN
 						 && (orig_op1_type & IS_TRACE_REFERENCE)) {
 							if (!zend_jit_fetch_reference(&dasm_state, opline, orig_op1_type, &op1_info, &op1_addr,
 									!ssa->var_info[ssa_op->op1_use].guarded_reference, 1)) {
 								goto jit_failure;
 							}
 							if (opline->op1_type == IS_CV
 							 && ssa->vars[ssa_op->op1_use].alias == NO_ALIAS) {
 								ssa->var_info[ssa_op->op1_use].guarded_reference = 1;
 							}
 						} else {
 							CHECK_OP1_TRACE_TYPE();
 						}
 						op2_info = OP2_INFO();
 						CHECK_OP2_TRACE_TYPE();
 						res_info = RES_INFO();
 						avoid_refcounting =
 							ssa_op->op1_use >= 0 &&
 							ssa->var_info[ssa_op->op1_use].avoid_refcounting;
 						if (op1_info & MAY_BE_PACKED_GUARD) {
 							ssa->var_info[ssa_op->op1_use].type &= ~MAY_BE_PACKED_GUARD;
 						} else if ((op2_info & (MAY_BE_ANY|MAY_BE_UNDEF)) == MAY_BE_LONG
 								&& (op1_info & (MAY_BE_ANY|MAY_BE_UNDEF)) == MAY_BE_ARRAY
 								&& MAY_BE_PACKED(op1_info)
 								&& MAY_BE_HASH(op1_info)
 								&& orig_op1_type != IS_UNKNOWN) {
 							op1_info |= MAY_BE_PACKED_GUARD;
 							if (orig_op1_type & IS_TRACE_PACKED) {
 								op1_info &= ~(MAY_BE_ARRAY_NUMERIC_HASH|MAY_BE_ARRAY_STRING_HASH);
 							} else {
 								op1_info &= ~MAY_BE_ARRAY_PACKED;
 							}
 						}
 						if (!zend_jit_fetch_dim_read(&dasm_state, opline, ssa, ssa_op,
 								op1_info, op1_addr, avoid_refcounting,
 								op2_info, res_info, RES_REG_ADDR(), val_type,
 								(
 									(op1_info & MAY_BE_ANY) != MAY_BE_ARRAY ||
 									(op2_info & (MAY_BE_ANY - (MAY_BE_LONG|MAY_BE_STRING))) != 0 ||
 									((op1_info & MAY_BE_UNDEF) != 0 &&
 										opline->opcode != ZEND_FETCH_DIM_IS) ||
 									(opline->opcode != ZEND_FETCH_LIST_R &&
 										(opline->op1_type & (IS_TMP_VAR|IS_VAR)) != 0 &&
 										(op1_info & MAY_BE_RC1) &&
 										(op1_info & (MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_ARRAY_OF_OBJECT|MAY_BE_ARRAY_OF_RESOURCE|MAY_BE_ARRAY_OF_ARRAY)) != 0) ||
 									(op2_info & MAY_BE_UNDEF) != 0 ||
 									((opline->op2_type & (IS_TMP_VAR|IS_VAR)) != 0 &&
 										(op2_info & MAY_BE_RC1) &&
 										(op2_info & (MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_ARRAY_OF_OBJECT|MAY_BE_ARRAY_OF_RESOURCE|MAY_BE_ARRAY_OF_ARRAY)) != 0)))) {
 							goto jit_failure;
 						}
 						goto done;
 					case ZEND_FETCH_DIM_W:
 					case ZEND_FETCH_DIM_RW:
 //					case ZEND_FETCH_DIM_UNSET:
 					case ZEND_FETCH_LIST_W:
 						if (opline->op1_type != IS_CV
 						 && (orig_op1_type == IS_UNKNOWN
 						  || !(orig_op1_type & IS_TRACE_INDIRECT))) {
 							break;
 						}
 						op1_info = OP1_INFO();
 						op1_addr = OP1_REG_ADDR();
 						if (opline->op1_type == IS_VAR) {
 							if (orig_op1_type != IS_UNKNOWN
 							 && (orig_op1_type & IS_TRACE_INDIRECT)) {
 								if (!zend_jit_fetch_indirect_var(&dasm_state, opline, orig_op1_type,
 										&op1_info, &op1_addr, !ssa->var_info[ssa_op->op1_use].indirect_reference)) {
 									goto jit_failure;
 								}
 							} else {
 								break;
 							}
 						}
 						if (orig_op1_type != IS_UNKNOWN
 						 && (orig_op1_type & IS_TRACE_REFERENCE)) {
 							if (!zend_jit_fetch_reference(&dasm_state, opline, orig_op1_type, &op1_info, &op1_addr,
 									!ssa->var_info[ssa_op->op1_use].guarded_reference, 1)) {
 								goto jit_failure;
 							}
 							if (opline->op1_type == IS_CV
 							 && ssa->vars[ssa_op->op1_def].alias == NO_ALIAS) {
 								ssa->var_info[ssa_op->op1_def].guarded_reference = 1;
 							}
 						} else {
 							CHECK_OP1_TRACE_TYPE();
 						}
 						op2_info = OP2_INFO();
 						CHECK_OP2_TRACE_TYPE();
 						op1_def_info = OP1_DEF_INFO();
 						if (!zend_jit_fetch_dim(&dasm_state, opline,
 								op1_info, op1_addr, op2_info, RES_REG_ADDR(), val_type,
 								(opline->opcode == ZEND_FETCH_DIM_RW
 								 || opline->op2_type == IS_UNUSED
 								 || (op1_info & (MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG|MAY_BE_DOUBLE|MAY_BE_STRING|MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_REF))
 								 || (op2_info & (MAY_BE_UNDEF|MAY_BE_RESOURCE|MAY_BE_ARRAY|MAY_BE_OBJECT))
 								 || (opline->op1_type == IS_VAR
 								  && (op1_info & MAY_BE_UNDEF)
 								  && !ssa->var_info[ssa_op->op1_use].indirect_reference)))) {
 							goto jit_failure;
 						}
 						if (ssa_op->result_def > 0
 						 && (opline->opcode == ZEND_FETCH_DIM_W || opline->opcode == ZEND_FETCH_LIST_W)
 						 && !(op1_info & (MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG|MAY_BE_DOUBLE|MAY_BE_STRING|MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_REF))
 						 && !(op2_info & (MAY_BE_UNDEF|MAY_BE_RESOURCE|MAY_BE_ARRAY|MAY_BE_OBJECT))) {
 							ssa->var_info[ssa_op->result_def].indirect_reference = 1;
 						}
 						goto done;
 					case ZEND_ISSET_ISEMPTY_DIM_OBJ:
 						if ((opline->extended_value & ZEND_ISEMPTY)) {
 							// TODO: support for empty() ???
 							break;
 						}
 						op1_info = OP1_INFO();
 						op1_addr = OP1_REG_ADDR();
 						if (orig_op1_type != IS_UNKNOWN
 						 && (orig_op1_type & IS_TRACE_REFERENCE)) {
 							if (!zend_jit_fetch_reference(&dasm_state, opline, orig_op1_type, &op1_info, &op1_addr,
 									!ssa->var_info[ssa_op->op1_use].guarded_reference, 1)) {
 								goto jit_failure;
 							}
 							if (opline->op1_type == IS_CV
 							 && ssa->vars[ssa_op->op1_use].alias == NO_ALIAS) {
 								ssa->var_info[ssa_op->op1_use].guarded_reference = 1;
 							}
 						} else {
 							CHECK_OP1_TRACE_TYPE();
 						}
 						op2_info = OP2_INFO();
 						CHECK_OP2_TRACE_TYPE();
 						if ((opline->result_type & (IS_SMART_BRANCH_JMPZ|IS_SMART_BRANCH_JMPNZ)) != 0) {
 							bool exit_if_true = 0;
 							const zend_op *exit_opline = zend_jit_trace_get_exit_opline(p + 1, opline + 1, &exit_if_true);
 							uint32_t exit_point;
 
 							if (ra) {
 								zend_jit_trace_clenup_stack(stack, opline, ssa_op, ssa, ra);
 							}
 							if (ssa_op->op1_use >= 0
 							 && ssa->var_info[ssa_op->op1_use].avoid_refcounting) {
 								/* Temporary reset ZREG_ZVAL_TRY_ADDREF */
 								zend_jit_trace_stack *stack = JIT_G(current_frame)->stack;
 								uint32_t old_info = STACK_INFO(stack, EX_VAR_TO_NUM(opline->op1.var));
 
 								SET_STACK_REG(stack, EX_VAR_TO_NUM(opline->op1.var), ZREG_NONE);
 								exit_point = zend_jit_trace_get_exit_point(exit_opline, 0);
 								SET_STACK_INFO(stack, EX_VAR_TO_NUM(opline->op1.var), old_info);
 							} else {
 								exit_point = zend_jit_trace_get_exit_point(exit_opline, 0);
 							}
 							exit_addr = zend_jit_trace_get_exit_addr(exit_point);
 							if (!exit_addr) {
 								goto jit_failure;
 							}
 							smart_branch_opcode = exit_if_true ? ZEND_JMPNZ : ZEND_JMPZ;
 						} else {
 							smart_branch_opcode = 0;
 							exit_addr = NULL;
 						}
 						avoid_refcounting =
 							ssa_op->op1_use >= 0 &&
 							ssa->var_info[ssa_op->op1_use].avoid_refcounting;
 						if (op1_info & MAY_BE_PACKED_GUARD) {
 							ssa->var_info[ssa_op->op1_use].type &= ~MAY_BE_PACKED_GUARD;
 						} else if ((op2_info & (MAY_BE_ANY|MAY_BE_UNDEF)) == MAY_BE_LONG
 								&& (op1_info & (MAY_BE_ANY|MAY_BE_UNDEF)) == MAY_BE_ARRAY
 								&& MAY_BE_PACKED(op1_info)
 								&& MAY_BE_HASH(op1_info)
 								&& orig_op1_type != IS_UNKNOWN) {
 							op1_info |= MAY_BE_PACKED_GUARD;
 							if (orig_op1_type & IS_TRACE_PACKED) {
 								op1_info &= ~(MAY_BE_ARRAY_NUMERIC_HASH|MAY_BE_ARRAY_STRING_HASH);
 							} else {
 								op1_info &= ~MAY_BE_ARRAY_PACKED;
 							}
 						}
 						if (!zend_jit_isset_isempty_dim(&dasm_state, opline,
 								op1_info, op1_addr, avoid_refcounting,
 								op2_info, val_type,
 								zend_may_throw_ex(opline, ssa_op, op_array, ssa, op1_info, op2_info),
 								smart_branch_opcode, -1, -1,
 								exit_addr)) {
 							goto jit_failure;
 						}
 						goto done;
 					case ZEND_FETCH_OBJ_FUNC_ARG:
 						if (!JIT_G(current_frame)
 						 || !JIT_G(current_frame)->call
 						 || !JIT_G(current_frame)->call->func
 						 || !TRACE_FRAME_IS_LAST_SEND_BY_VAL(JIT_G(current_frame)->call)) {
 							break;
 						}
 						ZEND_FALLTHROUGH;
 					case ZEND_FETCH_OBJ_R:
 					case ZEND_FETCH_OBJ_IS:
 					case ZEND_FETCH_OBJ_W:
 						on_this = delayed_fetch_this = 0;
 						avoid_refcounting = 0;
 						if (opline->op2_type != IS_CONST
 						 || Z_TYPE_P(RT_CONSTANT(opline, opline->op2)) != IS_STRING
 						 || Z_STRVAL_P(RT_CONSTANT(opline, opline->op2))[0] == '\0') {
 							break;
 						}
 						ce = NULL;
 						ce_is_instanceof = 0;
 						op1_indirect = 0;
 						if (opline->op1_type == IS_UNUSED) {
 							op1_info = MAY_BE_OBJECT|MAY_BE_RC1|MAY_BE_RCN;
 							ce = op_array->scope;
 							ce_is_instanceof = (ce->ce_flags & ZEND_ACC_FINAL) != 0;
 							op1_addr = 0;
 							on_this = 1;
 						} else {
 							op1_info = OP1_INFO();
 							if (!(op1_info & MAY_BE_OBJECT)) {
 								break;
 							}
 							op1_addr = OP1_REG_ADDR();
 							if (opline->op1_type == IS_VAR
 							 && opline->opcode == ZEND_FETCH_OBJ_W) {
 								if (orig_op1_type != IS_UNKNOWN
 								 && (orig_op1_type & IS_TRACE_INDIRECT)) {
 									op1_indirect = 1;
 									if (!zend_jit_fetch_indirect_var(&dasm_state, opline, orig_op1_type,
 											&op1_info, &op1_addr, !ssa->var_info[ssa_op->op1_use].indirect_reference)) {
 										goto jit_failure;
 									}
 								}
 							}
 							if (orig_op1_type != IS_UNKNOWN
 							 && (orig_op1_type & IS_TRACE_REFERENCE)) {
 								if (!zend_jit_fetch_reference(&dasm_state, opline, orig_op1_type, &op1_info, &op1_addr,
 										!ssa->var_info[ssa_op->op1_use].guarded_reference, 1)) {
 									goto jit_failure;
 								}
 								if (opline->op1_type == IS_CV
 								 && ssa->vars[ssa_op->op1_use].alias == NO_ALIAS) {
 									ssa->var_info[ssa_op->op1_def >= 0 ? ssa_op->op1_def : ssa_op->op1_use].guarded_reference = 1;
 								}
 							} else {
 								CHECK_OP1_TRACE_TYPE();
 							}
 							if (!(op1_info & MAY_BE_OBJECT)) {
 								break;
 							}
 							if (ssa->var_info && ssa->ops) {
 								if (ssa_op->op1_use >= 0) {
 									zend_ssa_var_info *op1_ssa = ssa->var_info + ssa_op->op1_use;
 									if (op1_ssa->ce && !op1_ssa->ce->create_object) {
 										ce = op1_ssa->ce;
 										ce_is_instanceof = op1_ssa->is_instanceof;
 									}
 								}
 							}
 							if (ssa_op->op1_use >= 0) {
 								delayed_fetch_this = ssa->var_info[ssa_op->op1_use].delayed_fetch_this;
 								avoid_refcounting = ssa->var_info[ssa_op->op1_use].avoid_refcounting;
 							}
 							if (delayed_fetch_this) {
 								on_this = 1;
 							} else if (ssa_op->op1_use >= 0 && ssa->vars[ssa_op->op1_use].definition >= 0) {
 								on_this = ssa_opcodes[ssa->vars[ssa_op->op1_use].definition]->opcode == ZEND_FETCH_THIS;
 							} else if (op_array_ssa->ops
 							        && op_array_ssa->vars
 									&& op_array_ssa->ops[opline-op_array->opcodes].op1_use >= 0
 									&& op_array_ssa->vars[op_array_ssa->ops[opline-op_array->opcodes].op1_use].definition >= 0) {
 								on_this = op_array->opcodes[op_array_ssa->vars[op_array_ssa->ops[opline-op_array->opcodes].op1_use].definition].opcode == ZEND_FETCH_THIS;
 							}
 						}
 						if (!zend_jit_fetch_obj(&dasm_state, opline, op_array, ssa, ssa_op,
 								op1_info, op1_addr, op1_indirect, ce, ce_is_instanceof,
 								on_this, delayed_fetch_this, avoid_refcounting, op1_ce, val_type,
 								zend_may_throw_ex(opline, ssa_op, op_array, ssa, op1_info, MAY_BE_STRING))) {
 							goto jit_failure;
 						}
 						goto done;
 					case ZEND_BIND_GLOBAL:
 						orig_opline = opline;
 						orig_ssa_op = ssa_op;
 						while (1) {
 							if (!ssa->ops || !ssa->var_info) {
 								op1_info = MAY_BE_ANY|MAY_BE_REF;
 							} else {
 								op1_info = OP1_INFO();
 							}
 							if (ssa->vars[ssa_op->op1_def].alias == NO_ALIAS) {
 								ssa->var_info[ssa_op->op1_def].guarded_reference = 1;
 							}
 							if (!zend_jit_bind_global(&dasm_state, opline, op1_info)) {
 								goto jit_failure;
 							}
 							if ((opline+1)->opcode == ZEND_BIND_GLOBAL) {
 								opline++;
 								ssa_op++;
 							} else {
 								break;
 							}
 						}
 						opline = orig_opline;
 						ssa_op = orig_ssa_op;
 						goto done;
 					case ZEND_RECV:
 						if (!zend_jit_recv(&dasm_state, opline, op_array)) {
 							goto jit_failure;
 						}
 						goto done;
 					case ZEND_RECV_INIT:
 						orig_opline = opline;
 						orig_ssa_op = ssa_op;
 						while (1) {
 							if (!zend_jit_recv_init(&dasm_state, opline, op_array,
 									(opline + 1)->opcode != ZEND_RECV_INIT,
 									zend_may_throw(opline, ssa_op, op_array, ssa))) {
 								goto jit_failure;
 							}
 							if ((opline+1)->opcode == ZEND_RECV_INIT) {
 								opline++;
 								ssa_op++;
 							} else {
 								break;
 							}
 						}
 						opline = orig_opline;
 						ssa_op = orig_ssa_op;
 						goto done;
 					case ZEND_FREE:
 					case ZEND_FE_FREE:
 						op1_info = OP1_INFO();
 						if (!zend_jit_free(&dasm_state, opline, op1_info,
 								zend_may_throw(opline, ssa_op, op_array, ssa))) {
 							goto jit_failure;
 						}
 						goto done;
 					case ZEND_ECHO:
 						op1_info = OP1_INFO();
 						CHECK_OP1_TRACE_TYPE();
 						if ((op1_info & (MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF)) != MAY_BE_STRING) {
 							break;
 						}
 						if (!zend_jit_echo(&dasm_state, opline, op1_info)) {
 							goto jit_failure;
 						}
 						goto done;
 					case ZEND_STRLEN:
 						op1_info = OP1_INFO();
 						op1_addr = OP1_REG_ADDR();
 						if (orig_op1_type == (IS_TRACE_REFERENCE|IS_STRING)) {
 							if (!zend_jit_fetch_reference(&dasm_state, opline, orig_op1_type, &op1_info, &op1_addr,
 									!ssa->var_info[ssa_op->op1_use].guarded_reference, 1)) {
 								goto jit_failure;
 							}
 							if (opline->op1_type == IS_CV
 							 && ssa->vars[ssa_op->op1_use].alias == NO_ALIAS) {
 								ssa->var_info[ssa_op->op1_use].guarded_reference = 1;
 							}
 						} else {
 							CHECK_OP1_TRACE_TYPE();
 							if ((op1_info & (MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF)) != MAY_BE_STRING) {
 								break;
 							}
 						}
 						if (!zend_jit_strlen(&dasm_state, opline, op1_info, op1_addr)) {
 							goto jit_failure;
 						}
 						goto done;
 					case ZEND_COUNT:
 						op1_info = OP1_INFO();
 						op1_addr = OP1_REG_ADDR();
 						if (orig_op1_type == (IS_TRACE_REFERENCE|IS_ARRAY)) {
 							if (!zend_jit_fetch_reference(&dasm_state, opline, orig_op1_type, &op1_info, &op1_addr,
 									!ssa->var_info[ssa_op->op1_use].guarded_reference, 1)) {
 								goto jit_failure;
 							}
 							if (opline->op1_type == IS_CV
 							 && ssa->vars[ssa_op->op1_use].alias == NO_ALIAS) {
 								ssa->var_info[ssa_op->op1_use].guarded_reference = 1;
 							}
 						} else {
 							CHECK_OP1_TRACE_TYPE();
 							if ((op1_info & (MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF)) != MAY_BE_ARRAY) {
 								break;
 							}
 						}
 						if (!zend_jit_count(&dasm_state, opline, op1_info, op1_addr, zend_may_throw(opline, ssa_op, op_array, ssa))) {
 							goto jit_failure;
 						}
 						goto done;
 					case ZEND_FETCH_THIS:
 						delayed_fetch_this = 0;
 						if (ssa_op->result_def >= 0 && opline->result_type != IS_CV) {
 							if (zend_jit_may_delay_fetch_this(ssa, ssa_opcodes, ssa_op->result_def)) {
 								ssa->var_info[ssa_op->result_def].delayed_fetch_this = 1;
 								delayed_fetch_this = 1;
 							}
 						}
 						if (!zend_jit_fetch_this(&dasm_state, opline, op_array, delayed_fetch_this)) {
 							goto jit_failure;
 						}
 						goto done;
 					case ZEND_SWITCH_LONG:
 					case ZEND_SWITCH_STRING:
 					case ZEND_MATCH:
 						if (!zend_jit_switch(&dasm_state, opline, op_array, op_array_ssa, p+1, &zend_jit_traces[ZEND_JIT_TRACE_NUM])) {
 							goto jit_failure;
 						}
 						goto done;
 					case ZEND_VERIFY_RETURN_TYPE:
 						if (opline->op1_type == IS_UNUSED) {
 							/* Always throws */
 							break;
 						}
 						if (opline->op1_type == IS_CONST) {
 							/* TODO Different instruction format, has return value */
 							break;
 						}
 						if (op_array->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
 							/* Not worth bothering with */
 							break;
 						}
 						op1_info = OP1_INFO();
 						CHECK_OP1_TRACE_TYPE();
 						if (op1_info & MAY_BE_REF) {
 							/* TODO May need reference unwrapping. */
 							break;
 						}
 						if (!zend_jit_verify_return_type(&dasm_state, opline, op_array, op1_info)) {
 							goto jit_failure;
 						}
 						goto done;
 					case ZEND_FE_RESET_R:
 						op1_info = OP1_INFO();
 						CHECK_OP1_TRACE_TYPE();
 						if ((op1_info & (MAY_BE_ANY|MAY_BE_REF|MAY_BE_UNDEF)) != MAY_BE_ARRAY) {
 							break;
 						}
 						if (!zend_jit_fe_reset(&dasm_state, opline, op1_info)) {
 							goto jit_failure;
 						}
 						goto done;
 					case ZEND_FE_FETCH_R:
 						op1_info = OP1_INFO();
 						CHECK_OP1_TRACE_TYPE();
 						if ((op1_info & MAY_BE_ANY) != MAY_BE_ARRAY) {
 							break;
 						}
 						if ((p+1)->op == ZEND_JIT_TRACE_VM || (p+1)->op == ZEND_JIT_TRACE_END) {
 							const zend_op *exit_opline = ZEND_OFFSET_TO_OPLINE(opline, opline->extended_value);
 							uint32_t exit_point;
 
 							if ((p+1)->opline == exit_opline) {
 								/* taken branch (exit from loop) */
 								exit_opline = opline;
 								smart_branch_opcode = ZEND_NOP;
 							} else if ((p+1)->opline == opline + 1) {
 								/* not taken branch (loop) */
 								smart_branch_opcode = ZEND_JMP;
 							} else {
 								ZEND_UNREACHABLE();
 							}
 							exit_point = zend_jit_trace_get_exit_point(exit_opline, 0);
 							exit_addr = zend_jit_trace_get_exit_addr(exit_point);
 							if (!exit_addr) {
 								goto jit_failure;
 							}
 						} else  {
 							ZEND_UNREACHABLE();
 						}
 						if (!zend_jit_fe_fetch(&dasm_state, opline, op1_info, OP2_INFO(),
 								-1, smart_branch_opcode, exit_addr)) {
 							goto jit_failure;
 						}
 						goto done;
 					case ZEND_FETCH_CONSTANT:
 						if (!zend_jit_fetch_constant(&dasm_state, opline, op_array, ssa, ssa_op, RES_REG_ADDR())) {
 							goto jit_failure;
 						}
 						goto done;
 					case ZEND_INIT_METHOD_CALL:
 						if (opline->op2_type != IS_CONST
 						 || Z_TYPE_P(RT_CONSTANT(opline, opline->op2)) != IS_STRING) {
 							goto generic_dynamic_call;
 						}
 						on_this = delayed_fetch_this = 0;
 						ce = NULL;
 						ce_is_instanceof = 0;
 						if (opline->op1_type == IS_UNUSED) {
 							op1_info = MAY_BE_OBJECT|MAY_BE_RC1|MAY_BE_RCN;
 							ce = op_array->scope;
 							ce_is_instanceof = (ce->ce_flags & ZEND_ACC_FINAL) != 0;
 							op1_addr = 0;
 							on_this = 1;
 						} else {
 							op1_info = OP1_INFO();
 							op1_addr = OP1_REG_ADDR();
 							if (polymorphic_side_trace) {
 								op1_info = MAY_BE_OBJECT;
 								op1_addr = 0;
 							} else if (orig_op1_type != IS_UNKNOWN
 							 && (orig_op1_type & IS_TRACE_REFERENCE)) {
 								if (!zend_jit_fetch_reference(&dasm_state, opline, orig_op1_type, &op1_info, &op1_addr,
 										!ssa->var_info[ssa_op->op1_use].guarded_reference, 1)) {
 									goto jit_failure;
 								}
 								if (opline->op1_type == IS_CV
 								 && ssa->vars[ssa_op->op1_use].alias == NO_ALIAS) {
 									ssa->var_info[ssa_op->op1_use].guarded_reference = 1;
 								}
 							} else {
 								CHECK_OP1_TRACE_TYPE();
 							}
 							if (ssa->var_info && ssa->ops) {
 								if (ssa_op->op1_use >= 0) {
 									zend_ssa_var_info *op1_ssa = ssa->var_info + ssa_op->op1_use;
 									if (op1_ssa->ce && !op1_ssa->ce->create_object) {
 										ce = op1_ssa->ce;
 										ce_is_instanceof = op1_ssa->is_instanceof;
 									}
 								}
 							}
 							if (ssa_op->op1_use >= 0) {
 								delayed_fetch_this = ssa->var_info[ssa_op->op1_use].delayed_fetch_this;
 							}
 							if (delayed_fetch_this) {
 								on_this = 1;
 							} else if (ssa_op->op1_use >= 0 && ssa->vars[ssa_op->op1_use].definition >= 0) {
 								on_this = ssa_opcodes[ssa->vars[ssa_op->op1_use].definition]->opcode == ZEND_FETCH_THIS;
 							} else if (op_array_ssa->ops
 							        && op_array_ssa->vars
 									&& op_array_ssa->ops[opline-op_array->opcodes].op1_use >= 0
 									&& op_array_ssa->vars[op_array_ssa->ops[opline-op_array->opcodes].op1_use].definition >= 0) {
 								on_this = op_array->opcodes[op_array_ssa->vars[op_array_ssa->ops[opline-op_array->opcodes].op1_use].definition].opcode == ZEND_FETCH_THIS;
 							}
 						}
 						frame_flags = TRACE_FRAME_MASK_NESTED;
 						if (!zend_jit_init_method_call(&dasm_state, opline,
 								op_array_ssa->cfg.map ? op_array_ssa->cfg.map[opline - op_array->opcodes] : -1,
 								op_array, ssa, ssa_op, frame->call_level,
 								op1_info, op1_addr, ce, ce_is_instanceof, on_this, delayed_fetch_this, op1_ce,
 								p + 1, peek_checked_stack - checked_stack, polymorphic_side_trace)) {
 							goto jit_failure;
 						}
 						goto done;
 					case ZEND_INIT_DYNAMIC_CALL:
 						if (orig_op2_type != IS_OBJECT || op2_ce != zend_ce_closure) {
 							goto generic_dynamic_call;
 						}
 						op2_info = OP2_INFO();
 						CHECK_OP2_TRACE_TYPE();
 						frame_flags = TRACE_FRAME_MASK_NESTED;
 						if (!zend_jit_init_closure_call(&dasm_state, opline, op_array_ssa->cfg.map ? op_array_ssa->cfg.map[opline - op_array->opcodes] : -1, op_array, ssa, ssa_op, frame->call_level, p + 1, peek_checked_stack - checked_stack)) {
 							goto jit_failure;
 						}
 						goto done;
 					case ZEND_INIT_STATIC_METHOD_CALL:
 generic_dynamic_call:
 						if (!zend_jit_trace_handler(&dasm_state, op_array, opline, zend_may_throw(opline, ssa_op, op_array, ssa), p + 1)) {
 							goto jit_failure;
 						}
 						if ((opline->opcode != ZEND_INIT_STATIC_METHOD_CALL
 						  || opline->op1_type != IS_CONST
 						  || opline->op2_type != IS_CONST)
 						 && (p+1)->op == ZEND_JIT_TRACE_INIT_CALL && (p+1)->func) {
 							if (!zend_jit_init_fcall_guard(&dasm_state, 0, (p+1)->func, opline+1)) {
 								goto jit_failure;
 							}
 						}
 						goto done;
 					case ZEND_INIT_USER_CALL:
 						if (!zend_jit_trace_handler(&dasm_state, op_array, opline, zend_may_throw(opline, ssa_op, op_array, ssa), p + 1)) {
 							goto jit_failure;
 						}
 						if (opline->op2_type != IS_CONST
 						 && (p+1)->op == ZEND_JIT_TRACE_INIT_CALL && (p+1)->func) {
 							if (!zend_jit_init_fcall_guard(&dasm_state, 0, (p+1)->func, opline+1)) {
 								goto jit_failure;
 							}
 						}
 						goto done;
 					case ZEND_NEW:
 						if (!zend_jit_trace_handler(&dasm_state, op_array, opline, zend_may_throw(opline, ssa_op, op_array, ssa), p + 1)) {
 							goto jit_failure;
 						}
 						if (opline->op1_type != IS_CONST
 						 && (p+1)->op == ZEND_JIT_TRACE_INIT_CALL && (p+1)->func) {
 							SET_STACK_TYPE(stack, EX_VAR_TO_NUM(opline->result.var), IS_OBJECT, 1);
 							if (!zend_jit_init_fcall_guard(&dasm_state, 0, (p+1)->func, opline+1)) {
 								goto jit_failure;
 							}
 						}
 						goto done;
 					case ZEND_SEND_ARRAY:
 					case ZEND_SEND_UNPACK:
 						if (JIT_G(current_frame)
 						 && JIT_G(current_frame)->call) {
 							TRACE_FRAME_SET_UNKNOWN_NUM_ARGS(JIT_G(current_frame)->call);
 						}
 						break;
 					case ZEND_ROPE_INIT:
 					case ZEND_ROPE_ADD:
 					case ZEND_ROPE_END:
 						op2_info = OP2_INFO();
 						CHECK_OP2_TRACE_TYPE();
 						if ((op2_info & (MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF)) != MAY_BE_STRING) {
 							break;
 						}
 						if (!zend_jit_rope(&dasm_state, opline, op2_info)) {
 							goto jit_failure;
 						}
 						goto done;
 					default:
 						break;
 				}
 			}
 
 			if (opline->opcode != ZEND_NOP && opline->opcode != ZEND_JMP) {
 				if (!zend_jit_trace_handler(&dasm_state, op_array, opline, zend_may_throw(opline, ssa_op, op_array, ssa), p + 1)) {
 					goto jit_failure;
 				}
 			}
 
 done:
 			polymorphic_side_trace = 0;
 			switch (opline->opcode) {
 				case ZEND_DO_FCALL:
 				case ZEND_DO_ICALL:
 				case ZEND_DO_UCALL:
 				case ZEND_DO_FCALL_BY_NAME:
 					frame->call_level--;
 			}
 
 			if (ra) {
 				zend_jit_trace_clenup_stack(stack, opline, ssa_op, ssa, ra);
 			}
 
 			if ((opline->op1_type & (IS_VAR|IS_TMP_VAR))
 			 && STACK_REG(stack, EX_VAR_TO_NUM(opline->op1.var)) > ZREG_NUM) {
 				SET_STACK_REG(stack, EX_VAR_TO_NUM(opline->op1.var), ZREG_NONE);
 			}
 
 			if (ssa_op) {
 				zend_ssa_range tmp;
 
 				/* Keep information about known types on abstract stack */
 				if (ssa_op->result_def >= 0) {
 					zend_uchar type = IS_UNKNOWN;
 
 					if ((opline->result_type & (IS_SMART_BRANCH_JMPZ|IS_SMART_BRANCH_JMPNZ)) != 0
 					 || send_result) {
 						/* we didn't set result variable */
 						type = IS_UNKNOWN;
 					} else if (!(ssa->var_info[ssa_op->result_def].type & MAY_BE_GUARD)
 					 && has_concrete_type(ssa->var_info[ssa_op->result_def].type)) {
 						type = concrete_type(ssa->var_info[ssa_op->result_def].type);
 					} else if (opline->opcode == ZEND_QM_ASSIGN) {
 						if (opline->op1_type != IS_CONST) {
 							/* copy */
 							type = STACK_TYPE(stack, EX_VAR_TO_NUM(opline->op1.var));
 						}
 					} else if (opline->opcode == ZEND_ASSIGN) {
 						if (opline->op2_type != IS_CONST
 						 && ssa_op->op1_use >= 0
 						 /* assignment to typed reference may cause conversion */
 						 && (ssa->var_info[ssa_op->op1_use].type & MAY_BE_REF) == 0) {
 							/* copy */
 							type = STACK_TYPE(stack, EX_VAR_TO_NUM(opline->op2.var));
 						}
 					} else if (opline->opcode == ZEND_POST_INC
 			         || opline->opcode == ZEND_POST_DEC) {
 						/* copy */
 						type = STACK_TYPE(stack, EX_VAR_TO_NUM(opline->op1.var));
 					}
 					if (opline->opcode == ZEND_JMP_SET
 					  || opline->opcode == ZEND_COALESCE
 					  || opline->opcode == ZEND_JMP_NULL) {
 						if ((p+1)->op != ZEND_JIT_TRACE_VM) {
 							SET_STACK_TYPE(stack, EX_VAR_TO_NUM(opline->result.var), IS_UNKNOWN, 1);
 						} else if ((p+1)->opline != (opline + 1)) {
 							SET_STACK_TYPE(stack, EX_VAR_TO_NUM(opline->result.var), type, 1);
 						}
 					} else {
 						SET_STACK_TYPE(stack, EX_VAR_TO_NUM(opline->result.var), type,
 							(type == IS_UNKNOWN || !ra || !ra[ssa_op->result_def]));
 						if (type != IS_UNKNOWN) {
 							ssa->var_info[ssa_op->result_def].type &= ~MAY_BE_GUARD;
 							if (opline->opcode == ZEND_FETCH_THIS
 							 && delayed_fetch_this) {
 								SET_STACK_REG(stack, EX_VAR_TO_NUM(opline->result.var), ZREG_THIS);
 							} else if (ssa->var_info[ssa_op->result_def].avoid_refcounting) {
 								SET_STACK_REG(stack, EX_VAR_TO_NUM(opline->result.var), ZREG_ZVAL_TRY_ADDREF);
 							} else if (ra && ra[ssa_op->result_def]) {
 								SET_STACK_REG_EX(stack, EX_VAR_TO_NUM(opline->result.var), ra[ssa_op->result_def]->reg,
 									ra[ssa_op->result_def]->flags & ZREG_STORE);
 							}
 						}
 					}
 
 					if (type == IS_LONG
 					 && zend_inference_propagate_range(op_array, ssa, (zend_op*)opline, (zend_ssa_op*)ssa_op, ssa_op->result_def, &tmp)) {
 						ssa->var_info[ssa_op->result_def].range.min = tmp.min;
 						ssa->var_info[ssa_op->result_def].range.max = tmp.max;
 						ssa->var_info[ssa_op->result_def].range.underflow = 0;
 						ssa->var_info[ssa_op->result_def].range.overflow = 0;
 						ssa->var_info[ssa_op->result_def].has_range = 1;
 					}
 				}
 				if (ssa_op->op1_def >= 0) {
 					zend_uchar type = IS_UNKNOWN;
 
 					if (!(ssa->var_info[ssa_op->op1_def].type & MAY_BE_GUARD)
 					 && has_concrete_type(ssa->var_info[ssa_op->op1_def].type)) {
 						type = concrete_type(ssa->var_info[ssa_op->op1_def].type);
 					} else if (opline->opcode == ZEND_ASSIGN) {
 						if (!(OP1_INFO() & MAY_BE_REF)
 						 || STACK_TYPE(stack, EX_VAR_TO_NUM(opline->op1.var)) != IS_UNKNOWN) {
 							if (opline->op2_type != IS_CONST) {
 								/* copy */
 								type = STACK_TYPE(stack, EX_VAR_TO_NUM(opline->op2.var));
 							}
 						}
 					} else if (opline->opcode == ZEND_SEND_VAR
 					 || opline->opcode == ZEND_CAST
 					 || opline->opcode == ZEND_QM_ASSIGN
 					 || opline->opcode == ZEND_JMP_SET
 					 || opline->opcode == ZEND_COALESCE
 					 || opline->opcode == ZEND_JMP_NULL
 					 || opline->opcode == ZEND_FE_RESET_R) {
 						/* keep old value */
 						type = STACK_TYPE(stack, EX_VAR_TO_NUM(opline->op1.var));
 					}
 					SET_STACK_TYPE(stack, EX_VAR_TO_NUM(opline->op1.var), type,
 						(type == IS_UNKNOWN || !ra || !ra[ssa_op->op1_def]));
 					if (type != IS_UNKNOWN) {
 						ssa->var_info[ssa_op->op1_def].type &= ~MAY_BE_GUARD;
 						if (ra && ra[ssa_op->op1_def]) {
 							uint8_t flags = ra[ssa_op->op1_def]->flags & ZREG_STORE;
 
 							if (ssa_op->op1_use >= 0) {
 								if (opline->opcode == ZEND_SEND_VAR
 								 || opline->opcode == ZEND_CAST
 								 || opline->opcode == ZEND_QM_ASSIGN
 								 || opline->opcode == ZEND_JMP_SET
 								 || opline->opcode == ZEND_COALESCE
 								 || opline->opcode == ZEND_JMP_NULL
 								 || opline->opcode == ZEND_FE_RESET_R) {
 									if (!ra[ssa_op->op1_use]
 									 || ra[ssa_op->op1_use]->reg != ra[ssa_op->op1_def]->reg) {
 										flags |= ZREG_LOAD;
 									}
 								}
 							}
 							SET_STACK_REG_EX(stack, EX_VAR_TO_NUM(opline->op1.var), ra[ssa_op->op1_def]->reg, flags);
 						}
 					}
 					if (type == IS_LONG
 					 && zend_inference_propagate_range(op_array, ssa, (zend_op*)opline, (zend_ssa_op*)ssa_op, ssa_op->op1_def, &tmp)) {
 						ssa->var_info[ssa_op->op1_def].range.min = tmp.min;
 						ssa->var_info[ssa_op->op1_def].range.max = tmp.max;
 						ssa->var_info[ssa_op->op1_def].range.underflow = 0;
 						ssa->var_info[ssa_op->op1_def].range.overflow = 0;
 						ssa->var_info[ssa_op->op1_def].has_range = 1;
 					}
 				}
 				if (ssa_op->op2_def >= 0) {
 					zend_uchar type = IS_UNKNOWN;
 
 					if (!(ssa->var_info[ssa_op->op2_def].type & MAY_BE_GUARD)
 					 && has_concrete_type(ssa->var_info[ssa_op->op2_def].type)) {
 						type = concrete_type(ssa->var_info[ssa_op->op2_def].type);
 					} else if (opline->opcode == ZEND_ASSIGN) {
 						/* keep old value */
 						type = STACK_TYPE(stack, EX_VAR_TO_NUM(opline->op2.var));
 					}
 					SET_STACK_TYPE(stack, EX_VAR_TO_NUM(opline->op2.var), type,
 						(type == IS_UNKNOWN || !ra || !ra[ssa_op->op2_def]));
 					if (type != IS_UNKNOWN) {
 						ssa->var_info[ssa_op->op2_def].type &= ~MAY_BE_GUARD;
 						if (ra && ra[ssa_op->op2_def]) {
 							uint8_t flags = ra[ssa_op->op2_def]->flags & ZREG_STORE;
 
 							if (ssa_op->op2_use >= 0) {
 								if (opline->opcode == ZEND_ASSIGN) {
 									if (!ra[ssa_op->op2_use]
 									 || ra[ssa_op->op2_use]->reg != ra[ssa_op->op2_def]->reg) {
 										flags |= ZREG_LOAD;
 									}
 								}
 							}
 							SET_STACK_REG_EX(stack, EX_VAR_TO_NUM(opline->op2.var), ra[ssa_op->op2_def]->reg, flags);
 						}
 					}
 					if (type == IS_LONG
 					 && zend_inference_propagate_range(op_array, ssa, (zend_op*)opline, (zend_ssa_op*)ssa_op, ssa_op->op2_def, &tmp)) {
 						ssa->var_info[ssa_op->op2_def].range.min = tmp.min;
 						ssa->var_info[ssa_op->op2_def].range.max = tmp.max;
 						ssa->var_info[ssa_op->op2_def].range.underflow = 0;
 						ssa->var_info[ssa_op->op2_def].range.overflow = 0;
 						ssa->var_info[ssa_op->op2_def].has_range = 1;
 					}
 				}
 
 				switch (opline->opcode) {
 					case ZEND_ASSIGN_DIM:
 					case ZEND_ASSIGN_OBJ:
 					case ZEND_ASSIGN_STATIC_PROP:
 					case ZEND_ASSIGN_DIM_OP:
 					case ZEND_ASSIGN_OBJ_OP:
 					case ZEND_ASSIGN_STATIC_PROP_OP:
 					case ZEND_ASSIGN_OBJ_REF:
 					case ZEND_ASSIGN_STATIC_PROP_REF:
 						/* OP_DATA */
 						ssa_op++;
 						opline++;
 						if (ssa_op->op1_def >= 0) {
 							zend_uchar type = IS_UNKNOWN;
 
 							if (!(ssa->var_info[ssa_op->op1_def].type & MAY_BE_GUARD)
 							 && has_concrete_type(ssa->var_info[ssa_op->op1_def].type)) {
 								type = concrete_type(ssa->var_info[ssa_op->op1_def].type);
 							} else if ((opline-1)->opcode == ZEND_ASSIGN_DIM
 							 || (opline-1)->opcode == ZEND_ASSIGN_OBJ
 							 || (opline-1)->opcode == ZEND_ASSIGN_STATIC_PROP) {
 								/* keep old value */
 								type = STACK_TYPE(stack, EX_VAR_TO_NUM(opline->op1.var));
 							}
 							SET_STACK_TYPE(stack, EX_VAR_TO_NUM(opline->op1.var), type,
 								(type == IS_UNKNOWN || !ra || !ra[ssa_op->op1_def]));
 							if (type != IS_UNKNOWN) {
 								ssa->var_info[ssa_op->op1_def].type &= ~MAY_BE_GUARD;
 								if (ra && ra[ssa_op->op1_def]) {
 									SET_STACK_REG_EX(stack, EX_VAR_TO_NUM(opline->op1.var), ra[ssa_op->op1_def]->reg,
 										ra[ssa_op->op1_def]->reg & ZREG_STORE);
 								}
 							}
 							if (type == IS_LONG
 							 && zend_inference_propagate_range(op_array, ssa, (zend_op*)opline, (zend_ssa_op*)ssa_op, ssa_op->op1_def, &tmp)) {
 								ssa->var_info[ssa_op->op1_def].range.min = tmp.min;
 								ssa->var_info[ssa_op->op1_def].range.max = tmp.max;
 								ssa->var_info[ssa_op->op1_def].range.underflow = 0;
 								ssa->var_info[ssa_op->op1_def].range.overflow = 0;
 								ssa->var_info[ssa_op->op1_def].has_range = 1;
 							}
 						}
 						ssa_op++;
 						break;
 					case ZEND_RECV_INIT:
 					    ssa_op++;
 						opline++;
 						while (opline->opcode == ZEND_RECV_INIT) {
 							if (ssa_op->result_def >= 0) {
 								zend_uchar type = IS_UNKNOWN;
 
 								if (!(ssa->var_info[ssa_op->result_def].type & MAY_BE_GUARD)
 								 && has_concrete_type(ssa->var_info[ssa_op->result_def].type)) {
 									type = concrete_type(ssa->var_info[ssa_op->result_def].type);
 								}
 								SET_STACK_TYPE(stack, EX_VAR_TO_NUM(opline->result.var), type,
 									(!ra || !ra[ssa_op->result_def]));
 								if (ra && ra[ssa_op->result_def]) {
 									SET_STACK_REG_EX(stack, EX_VAR_TO_NUM(opline->result.var), ra[ssa_op->result_def]->reg,
 										ra[ssa_op->result_def]->flags & ZREG_STORE);
 								}
 							}
 							ssa_op++;
 							opline++;
 						}
 						break;
 					case ZEND_BIND_GLOBAL:
 						ssa_op++;
 						opline++;
 						while (opline->opcode == ZEND_BIND_GLOBAL) {
 							if (ssa_op->op1_def >= 0) {
 								zend_uchar type = IS_UNKNOWN;
 
 								if (!(ssa->var_info[ssa_op->op1_def].type & MAY_BE_GUARD)
 								 && has_concrete_type(ssa->var_info[ssa_op->op1_def].type)) {
 									type = concrete_type(ssa->var_info[ssa_op->op1_def].type);
 								}
 								SET_STACK_TYPE(stack, EX_VAR_TO_NUM(opline->op1.var), type,
 									(!ra || !ra[ssa_op->op1_def]));
 								if (ra && ra[ssa_op->op1_def]) {
 									SET_STACK_REG_EX(stack, EX_VAR_TO_NUM(opline->op1.var), ra[ssa_op->op1_def]->reg,
 										ra[ssa_op->op1_def]->flags & ZREG_STORE);
 								}
 							}
 							ssa_op++;
 							opline++;
 						}
 						break;
 					default:
 						ssa_op += zend_jit_trace_op_len(opline);
 						break;
 				}
 
 				if (send_result) {
 					ssa_op++;
 					p++;
 					if ((p+1)->op == ZEND_JIT_TRACE_OP1_TYPE) {
 						p++;
 					}
 					send_result = 0;
 				}
 			}
 		} else if (p->op == ZEND_JIT_TRACE_ENTER) {
 			call = frame->call;
 			assert(call && &call->func->op_array == p->op_array);
 
 			if (opline->opcode == ZEND_DO_UCALL
 			 || opline->opcode == ZEND_DO_FCALL_BY_NAME
 			 || opline->opcode == ZEND_DO_FCALL) {
 
 				frame->call_opline = opline;
 
 				/* Check if SEND_UNPACK/SEND_ARRAY may cause enter at different opline */
 				if (opline > op_array->opcodes) {
 					const zend_op *prev_opline = opline - 1;
 
 					while (prev_opline->opcode == ZEND_EXT_FCALL_BEGIN || prev_opline->opcode == ZEND_TICKS) {
 						prev_opline--;
 					}
 					JIT_G(current_frame) = call;
 					if ((prev_opline->opcode == ZEND_SEND_ARRAY
 					  || prev_opline->opcode == ZEND_SEND_UNPACK
 					  || prev_opline->opcode == ZEND_CHECK_UNDEF_ARGS)
 					 && p->op_array->num_args
 					 && (p->op_array->fn_flags & ZEND_ACC_HAS_TYPE_HINTS) == 0
 					 && ((p+1)->op == ZEND_JIT_TRACE_VM
 					  || (p+1)->op == ZEND_JIT_TRACE_END)
 					 && (TRACE_FRAME_NUM_ARGS(call) < 0
 					  || TRACE_FRAME_NUM_ARGS(call) < p->op_array->num_args)
 					 && !zend_jit_trace_opline_guard(&dasm_state, (p+1)->opline)) {
 						goto jit_failure;
 					}
 					JIT_G(current_frame) = frame;
 				}
 			}
 
 			if ((p+1)->op == ZEND_JIT_TRACE_END) {
 				p++;
 				break;
 			}
 			if (op_array->fn_flags & ZEND_ACC_CLOSURE) {
 				if (TRACE_FRAME_IS_THIS_CHECKED(frame)) {
 					TRACE_FRAME_SET_THIS_CHECKED(call);
 				}
 			} else if (op_array->scope && !(op_array->fn_flags & ZEND_ACC_STATIC)) {
 				TRACE_FRAME_SET_THIS_CHECKED(call);
 			}
 			op_array = (zend_op_array*)p->op_array;
 			jit_extension =
 				(zend_jit_op_array_trace_extension*)ZEND_FUNC_INFO(op_array);
 			op_array_ssa = &jit_extension->func_info.ssa;
 			frame->call = call->prev;
 			call->prev = frame;
 			if (p->info & ZEND_JIT_TRACE_RETURN_VALUE_USED) {
 				TRACE_FRAME_SET_RETURN_VALUE_USED(call);
 			} else {
 				TRACE_FRAME_SET_RETURN_VALUE_UNUSED(call);
 			}
 			JIT_G(current_frame) = frame = call;
 			stack = frame->stack;
 			if (ra) {
 				int j = ZEND_JIT_TRACE_GET_FIRST_SSA_VAR(p->info);
 
 				for (i = 0; i < op_array->last_var; i++,j++) {
 					if (ra[j] && (ra[j]->flags & ZREG_LOAD) != 0) {
 						SET_STACK_REG_EX(stack, i, ra[j]->reg, ZREG_LOAD);
 						if (!zend_jit_load_var(&dasm_state, ssa->var_info[j].type, i, ra[j]->reg)) {
 							goto jit_failure;
 						}
 					}
 				}
 			}
 		} else if (p->op == ZEND_JIT_TRACE_BACK) {
 			op_array = (zend_op_array*)p->op_array;
 			jit_extension =
 				(zend_jit_op_array_trace_extension*)ZEND_FUNC_INFO(op_array);
 			op_array_ssa = &jit_extension->func_info.ssa;
 			top = frame;
 			if (frame->prev) {
 				checked_stack -= frame->used_stack;
 				frame = frame->prev;
 				stack = frame->stack;
 				ZEND_ASSERT(&frame->func->op_array == op_array);
 			} else {
 				frame = zend_jit_trace_ret_frame(frame, op_array);
 				TRACE_FRAME_INIT(frame, op_array, TRACE_FRAME_MASK_UNKNOWN_RETURN, -1);
 				frame->used_stack = checked_stack = peek_checked_stack = 0;
 				stack = frame->stack;
 				if (JIT_G(opt_level) >= ZEND_JIT_LEVEL_INLINE) {
 					uint32_t j = ZEND_JIT_TRACE_GET_FIRST_SSA_VAR(p->info);
 
 					for (i = 0; i < op_array->last_var + op_array->T; i++, j++) {
 						/* Initialize abstract stack using SSA */
 						if (!(ssa->var_info[j].type & MAY_BE_GUARD)
 						 && has_concrete_type(ssa->var_info[j].type)) {
 							SET_STACK_TYPE(stack, i, concrete_type(ssa->var_info[j].type), 1);
 						} else {
 							SET_STACK_TYPE(stack, i, IS_UNKNOWN, 1);
 						}
 					}
 					if (ra) {
 						j = ZEND_JIT_TRACE_GET_FIRST_SSA_VAR(p->info);
 						for (i = 0; i < op_array->last_var + op_array->T; i++, j++) {
 							if (ra[j] && (ra[j]->flags & ZREG_LOAD) != 0) {
 								SET_STACK_REG_EX(stack, i, ra[j]->reg, ZREG_LOAD);
 								if (!zend_jit_load_var(&dasm_state, ssa->var_info[j].type, i, ra[j]->reg)) {
 									goto jit_failure;
 								}
 							}
 						}
 					}
 				} else {
 					for (i = 0; i < op_array->last_var + op_array->T; i++) {
 						SET_STACK_TYPE(stack, i, IS_UNKNOWN, 1);
 					}
 				}
 				opline = NULL;
 			}
 			JIT_G(current_frame) = frame;
 			if (res_type != IS_UNKNOWN
 			 && (p+1)->op == ZEND_JIT_TRACE_VM) {
 				const zend_op *opline = (p+1)->opline - 1;
 				if (opline->result_type != IS_UNUSED) {
 				    SET_STACK_TYPE(stack, EX_VAR_TO_NUM(opline->result.var), res_type, 1);
 				}
 			}
 			res_type = IS_UNKNOWN;
 		} else if (p->op == ZEND_JIT_TRACE_END) {
 			break;
 		} else if (p->op == ZEND_JIT_TRACE_INIT_CALL) {
 			const zend_op *init_opline = zend_jit_trace_find_init_fcall_op(p, op_array);
 			int num_args = -1;
 
 			if (init_opline
 			 && init_opline->extended_value <= TRACE_FRAME_MAX_NUM_ARGS) {
 				num_args = init_opline->extended_value;
 			}
 
 			call = top;
 			TRACE_FRAME_INIT(call, p->func, frame_flags, num_args);
 			call->prev = frame->call;
 			if (!(p->info & ZEND_JIT_TRACE_FAKE_INIT_CALL)) {
 				TRACE_FRAME_SET_LAST_SEND_BY_VAL(call);
 			}
 			if (init_opline
 			 && init_opline->opcode != ZEND_NEW
 			 && (init_opline->opcode != ZEND_INIT_METHOD_CALL
 			  || init_opline->op1_type == IS_UNDEF)
 			 && (init_opline->opcode != ZEND_INIT_USER_CALL
 			  || (p->func && (!p->func->common.scope || (p->func->common.fn_flags & ZEND_ACC_STATIC))))
 			 && (init_opline->opcode != ZEND_INIT_DYNAMIC_CALL
 			  || (p->func && (!p->func->common.scope || (p->func->common.fn_flags & ZEND_ACC_STATIC))))
 			) {
 				TRACE_FRAME_SET_NO_NEED_RELEASE_THIS(call);
 			}
 			frame->call = call;
 			top = zend_jit_trace_call_frame(top, p->op_array);
 			if (p->func) {
 				if (p->func->type == ZEND_USER_FUNCTION) {
 					if (JIT_G(opt_level) >= ZEND_JIT_LEVEL_INLINE) {
 						zend_jit_op_array_trace_extension *jit_extension =
 							(zend_jit_op_array_trace_extension*)ZEND_FUNC_INFO(p->op_array);
 
 						i = 0;
 						while (i < p->op_array->num_args) {
 							/* Types of arguments are going to be stored in abstract stack when processing SEV instruction */
 							SET_STACK_TYPE(call->stack, i, IS_UNKNOWN, 1);
 							i++;
 						}
 						while (i < p->op_array->last_var) {
 							if (jit_extension
 							 && zend_jit_var_may_alias(p->op_array, &jit_extension->func_info.ssa, i) != NO_ALIAS) {
 								SET_STACK_TYPE(call->stack, i, IS_UNKNOWN, 1);
 							} else {
 								SET_STACK_TYPE(call->stack, i, IS_UNDEF, 1);
 							}
 							i++;
 						}
 						while (i < p->op_array->last_var + p->op_array->T) {
 							SET_STACK_TYPE(call->stack, i, IS_UNKNOWN, 1);
 							i++;
 						}
 					} else {
 						for (i = 0; i < p->op_array->last_var + p->op_array->T; i++) {
 							SET_STACK_TYPE(call->stack, i, IS_UNKNOWN, 1);
 						}
 					}
 				} else {
 					ZEND_ASSERT(p->func->type == ZEND_INTERNAL_FUNCTION);
 					for (i = 0; i < p->op_array->num_args; i++) {
 						SET_STACK_TYPE(call->stack, i, IS_UNKNOWN, 1);
 					}
 				}
 				if (p->info & ZEND_JIT_TRACE_FAKE_INIT_CALL) {
 					int skip_guard = 0;
 
 					if (init_opline) {
 						zend_call_info *call_info = jit_extension->func_info.callee_info;
 
 						while (call_info) {
 							if (call_info->caller_init_opline == init_opline
 									&& !call_info->is_prototype) {
 								if (op_array->fn_flags & ZEND_ACC_TRAIT_CLONE) {
 									if (init_opline->opcode == ZEND_INIT_STATIC_METHOD_CALL
 									 && init_opline->op1_type != IS_CONST) {
 										break;
 									} else if (init_opline->opcode == ZEND_INIT_METHOD_CALL) {
 										break;
 									}
 								}
 								skip_guard = 1;
 								break;
 							}
 							call_info = call_info->next_callee;
 						}
 						if (!skip_guard
 						 && !zend_jit_may_be_polymorphic_call(init_opline)) {
 							// TODO: recompilation may change target ???
 							skip_guard = 1;
 						}
 					}
 
 					if (!skip_guard) {
 						if (!opline) {
 							zend_jit_trace_rec *q = p + 1;
 							while (q->op != ZEND_JIT_TRACE_VM && q->op != ZEND_JIT_TRACE_END) {
 								q++;
 							}
 							opline = q->opline;
 							ZEND_ASSERT(opline != NULL);
 						}
 						if (!zend_jit_init_fcall_guard(&dasm_state,
 								ZEND_JIT_TRACE_FAKE_LEVEL(p->info), p->func, opline)) {
 							goto jit_failure;
 						}
 					}
 				}
 			}
 			if (p->info & ZEND_JIT_TRACE_FAKE_INIT_CALL) {
 				frame->call_level++;
 				call->used_stack = 0;
 			} else {
 				if (p->func) {
 					call->used_stack = zend_vm_calc_used_stack(init_opline->extended_value, (zend_function*)p->func);
 				} else {
 					call->used_stack = (ZEND_CALL_FRAME_SLOT + init_opline->extended_value) * sizeof(zval);
 				}
 				checked_stack += call->used_stack;
 				if (checked_stack > peek_checked_stack) {
 					peek_checked_stack = checked_stack;
 				}
 			}
 		} else if (p->op == ZEND_JIT_TRACE_DO_ICALL) {
 			call = frame->call;
 			if (call) {
 				checked_stack -= call->used_stack;
 				top = call;
 				frame->call = call->prev;
 			}
 		} else {
 			ZEND_UNREACHABLE();
 		}
 	}
 
 	ZEND_ASSERT(p->op == ZEND_JIT_TRACE_END);
 
 	t = &zend_jit_traces[ZEND_JIT_TRACE_NUM];
 
 	if (!parent_trace && zend_jit_trace_uses_initial_ip()) {
 		t->flags |= ZEND_JIT_TRACE_USES_INITIAL_IP;
 	}
 
 	if (p->stop == ZEND_JIT_TRACE_STOP_LOOP
 	 || p->stop == ZEND_JIT_TRACE_STOP_RECURSIVE_CALL
 	 || p->stop == ZEND_JIT_TRACE_STOP_RECURSIVE_RET) {
 		if (p->stop != ZEND_JIT_TRACE_STOP_RECURSIVE_RET) {
 			if ((t->flags & ZEND_JIT_TRACE_USES_INITIAL_IP)
 			 && !zend_jit_set_ip(&dasm_state, p->opline)) {
 				goto jit_failure;
 			}
 		}
 		t->link = ZEND_JIT_TRACE_NUM;
 		if (p->stop != ZEND_JIT_TRACE_STOP_RECURSIVE_RET) {
 			t->flags |= ZEND_JIT_TRACE_CHECK_INTERRUPT;
 		}
 		if (!(t->flags & ZEND_JIT_TRACE_LOOP)) {
 			const void *timeout_exit_addr = NULL;
 
 			t->flags |= ZEND_JIT_TRACE_LOOP;
 
 			if (trace_buffer->stop != ZEND_JIT_TRACE_STOP_RECURSIVE_RET) {
 				if (!(t->flags & ZEND_JIT_TRACE_USES_INITIAL_IP)
 				 || (ra
 				  && zend_jit_trace_stack_needs_deoptimization(stack, op_array->last_var + op_array->T))) {
 					uint32_t exit_point = zend_jit_trace_get_exit_point(opline, ZEND_JIT_EXIT_TO_VM);
 
 					timeout_exit_addr = zend_jit_trace_get_exit_addr(exit_point);
 					if (!timeout_exit_addr) {
 						goto jit_failure;
 					}
 				} else {
 					timeout_exit_addr = dasm_labels[zend_lbinterrupt_handler];
 				}
 			}
 
 			zend_jit_trace_end_loop(&dasm_state, 0, timeout_exit_addr); /* jump back to start of the trace loop */
 		}
 	} else if (p->stop == ZEND_JIT_TRACE_STOP_LINK
 	        || p->stop == ZEND_JIT_TRACE_STOP_INTERPRETER) {
 		if (!zend_jit_trace_deoptimization(&dasm_state, 0, NULL,
 				stack, op_array->last_var + op_array->T, NULL, NULL, NULL, 0)) {
 			goto jit_failure;
 		}
 		if (p->stop == ZEND_JIT_TRACE_STOP_LINK) {
 			const void *timeout_exit_addr = NULL;
 
 			t->link = zend_jit_find_trace(p->opline->handler);
 			if ((zend_jit_traces[t->link].flags & ZEND_JIT_TRACE_USES_INITIAL_IP)
 			 && !zend_jit_set_ip(&dasm_state, p->opline)) {
 				goto jit_failure;
 			}
 			if (!parent_trace && zend_jit_trace_uses_initial_ip()) {
 				t->flags |= ZEND_JIT_TRACE_USES_INITIAL_IP;
 			}
 			if (parent_trace
 			 && (zend_jit_traces[t->link].flags & ZEND_JIT_TRACE_CHECK_INTERRUPT)
 			 && zend_jit_traces[parent_trace].root == t->link) {
 				if (!(zend_jit_traces[t->link].flags & ZEND_JIT_TRACE_USES_INITIAL_IP)) {
 					uint32_t exit_point;
 
 					for (i = 0; i < op_array->last_var + op_array->T; i++) {
 						SET_STACK_TYPE(stack, i, IS_UNKNOWN, 1);
 					}
 					exit_point = zend_jit_trace_get_exit_point(opline, ZEND_JIT_EXIT_TO_VM);
 					timeout_exit_addr = zend_jit_trace_get_exit_addr(exit_point);
 					if (!timeout_exit_addr) {
 						goto jit_failure;
 					}
 				} else {
 					timeout_exit_addr = dasm_labels[zend_lbinterrupt_handler];
 				}
 			}
 			zend_jit_trace_link_to_root(&dasm_state, &zend_jit_traces[t->link], timeout_exit_addr);
 		} else {
 			zend_jit_trace_return(&dasm_state, 0);
 		}
 	} else if (p->stop == ZEND_JIT_TRACE_STOP_RETURN) {
 		zend_jit_trace_return(&dasm_state, 0);
 	} else {
 		// TODO: not implemented ???
 		ZEND_ASSERT(0 && p->stop);
 	}
 
 	if (ZEND_JIT_EXIT_COUNTERS + t->exit_count >= JIT_G(max_exit_counters)) {
 		goto jit_failure;
 	}
 
 	if (!zend_jit_trace_end(&dasm_state, t)) {
 		goto jit_failure;
 	}
 
 	handler = dasm_link_and_encode(&dasm_state, NULL, NULL, NULL, NULL, ZSTR_VAL(name), ZEND_JIT_TRACE_NUM,
 		parent_trace ? SP_ADJ_JIT : ((zend_jit_vm_kind == ZEND_VM_KIND_HYBRID) ? SP_ADJ_VM : SP_ADJ_RET),
 		parent_trace ? SP_ADJ_NONE : SP_ADJ_JIT);
 
 	if (handler) {
 		if (p->stop == ZEND_JIT_TRACE_STOP_RECURSIVE_CALL) {
 			const zend_op_array *rec_op_array;
 
 			rec_op_array = op_array = trace_buffer->op_array;
 			jit_extension =
 				(zend_jit_op_array_trace_extension*)ZEND_FUNC_INFO(op_array);
 			p = trace_buffer + ZEND_JIT_TRACE_START_REC_SIZE;
 			for (;;p++) {
 				if (p->op == ZEND_JIT_TRACE_VM) {
 					opline = p->opline;
 				} else if (p->op == ZEND_JIT_TRACE_ENTER) {
 					if (p->op_array == rec_op_array) {
 						zend_jit_trace_setup_ret_counter(opline, jit_extension->offset);
 					}
 					op_array = p->op_array;
 					jit_extension =
 						(zend_jit_op_array_trace_extension*)ZEND_FUNC_INFO(op_array);
 				} else if (p->op == ZEND_JIT_TRACE_BACK) {
 					op_array = p->op_array;
 					jit_extension =
 						(zend_jit_op_array_trace_extension*)ZEND_FUNC_INFO(op_array);
 				} else if (p->op == ZEND_JIT_TRACE_END) {
 					break;
 				}
 			}
 		} else if (p->stop == ZEND_JIT_TRACE_STOP_LINK
 		        || p->stop == ZEND_JIT_TRACE_STOP_INTERPRETER) {
 			if (opline
 			 && (opline->opcode == ZEND_DO_UCALL
 			  || opline->opcode == ZEND_DO_FCALL
 			  || opline->opcode == ZEND_DO_FCALL_BY_NAME
 			  || opline->opcode == ZEND_YIELD
 			  || opline->opcode == ZEND_YIELD_FROM
 			  || opline->opcode == ZEND_INCLUDE_OR_EVAL)) {
 				zend_jit_trace_setup_ret_counter(opline, jit_extension->offset);
 			}
 			if (JIT_G(current_frame)
 			 && JIT_G(current_frame)->prev) {
 				frame = JIT_G(current_frame)->prev;
 				do {
 					if (frame->call_opline) {
 						op_array = &frame->func->op_array;
 						jit_extension =
 							(zend_jit_op_array_trace_extension*)ZEND_FUNC_INFO(op_array);
 						zend_jit_trace_setup_ret_counter(frame->call_opline, jit_extension->offset);
 					}
 					frame = frame->prev;
 				} while (frame);
 			}
 		}
 	}
 
 jit_failure:
 	dasm_free(&dasm_state);
 
 	if (name) {
 		zend_string_release(name);
 	}
 
 jit_cleanup:
 	/* Clean up used op_arrays */
 	while (num_op_arrays > 0) {
 		op_array = op_arrays[--num_op_arrays];
 		jit_extension =
 			(zend_jit_op_array_trace_extension*)ZEND_FUNC_INFO(op_array);
 
 	    jit_extension->func_info.num = 0;
 		jit_extension->func_info.flags &= ZEND_FUNC_JIT_ON_FIRST_EXEC
 			| ZEND_FUNC_JIT_ON_PROF_REQUEST
 			| ZEND_FUNC_JIT_ON_HOT_COUNTERS
 			| ZEND_FUNC_JIT_ON_HOT_TRACE;
 		memset(&jit_extension->func_info.ssa, 0, sizeof(zend_func_info) - offsetof(zend_func_info, ssa));
 	}
 
 	zend_arena_release(&CG(arena), checkpoint);
 
 	JIT_G(current_frame) = NULL;
 	JIT_G(current_trace) = NULL;
 
 	return handler;
 }
diff --git a/ext/opcache/jit/zend_jit_x86.dasc b/ext/opcache/jit/zend_jit_x86.dasc
index a4794a3df2..bbb70a0ca5 100644
--- a/ext/opcache/jit/zend_jit_x86.dasc
+++ b/ext/opcache/jit/zend_jit_x86.dasc
@@ -6042,40 +6042,47 @@ static int zend_jit_simple_assign(dasm_State    **Dst,
 static int zend_jit_assign_to_typed_ref(dasm_State         **Dst,
                                        const zend_op        *opline,
                                        zend_uchar            val_type,
                                        zend_jit_addr         val_addr,
-                                       bool             check_exception)
+                                       zend_jit_addr         res_addr,
+                                       bool                  check_exception)
 {
 	|	// if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(variable_ptr)))) {
 	|	cmp aword [FCARG1a + offsetof(zend_reference, sources.ptr)], 0
 	|	jnz >2
 	|.cold_code
 	|2:
 	if (Z_MODE(val_addr) != IS_MEM_ZVAL || Z_REG(val_addr) != ZREG_FCARG2 || Z_OFFSET(val_addr) != 0) {
 		|	LOAD_ZVAL_ADDR FCARG2a, val_addr
 	}
 	if (opline) {
 		|	SET_EX_OPLINE opline, r0
 	}
 	if (val_type == IS_CONST) {
 		|	EXT_CALL zend_jit_assign_const_to_typed_ref, r0
 	} else if (val_type == IS_TMP_VAR) {
 		|	EXT_CALL zend_jit_assign_tmp_to_typed_ref, r0
 	} else if (val_type == IS_VAR) {
 		|	EXT_CALL zend_jit_assign_var_to_typed_ref, r0
 	} else if (val_type == IS_CV) {
 		|	EXT_CALL zend_jit_assign_cv_to_typed_ref, r0
 	} else {
 		ZEND_UNREACHABLE();
 	}
+	if (res_addr) {
+		zend_jit_addr ret_addr = ZEND_ADDR_MEM_ZVAL(ZREG_R0, 0);
+
+		|	ZVAL_COPY_VALUE res_addr, -1, ret_addr, -1, ZREG_R1, ZREG_R2
+		|	TRY_ADDREF -1, ch, r2
+	}
 	if (check_exception) {
 		|	// if (UNEXPECTED(EG(exception) != NULL)) {
 		|	MEM_CMP_ZTS aword, executor_globals, exception, 0, r0
 		|	je >8  // END OF zend_jit_assign_to_variable()
 		|	jmp ->exception_handler_undef
 	} else {
 		|	jmp >8
 	}
 	|.code
 
 	return 1;
 }
@@ -6165,154 +6172,154 @@ static int zend_jit_assign_to_variable_call(dasm_State    **Dst,
 static int zend_jit_assign_to_variable(dasm_State    **Dst,
                                        const zend_op  *opline,
                                        zend_jit_addr   var_use_addr,
                                        zend_jit_addr   var_addr,
                                        uint32_t        var_info,
                                        uint32_t        var_def_info,
                                        zend_uchar      val_type,
                                        zend_jit_addr   val_addr,
                                        uint32_t        val_info,
                                        zend_jit_addr   res_addr,
                                        bool       check_exception)
 /* Labels: 1,2,3,4,5,8 */
 {
 	int done = 0;
 	zend_reg ref_reg, tmp_reg;
 
 	if (Z_MODE(var_addr) == IS_REG || Z_REG(var_use_addr) != ZREG_R0) {
 		ref_reg = ZREG_FCARG1;
 		tmp_reg = ZREG_R0;
 	} else {
 		/* ASSIGN_DIM */
 		ref_reg = ZREG_R0;
 		tmp_reg = ZREG_FCARG1;
 	}
 
 	if (var_info & MAY_BE_REF) {
 		if (Z_MODE(var_use_addr) != IS_MEM_ZVAL || Z_REG(var_use_addr) != ref_reg || Z_OFFSET(var_use_addr) != 0) {
 			|	LOAD_ZVAL_ADDR Ra(ref_reg), var_use_addr
 			var_addr = var_use_addr = ZEND_ADDR_MEM_ZVAL(ref_reg, 0);
 		}
 		|	// if (Z_ISREF_P(variable_ptr)) {
 		|	IF_NOT_Z_TYPE, Ra(ref_reg), IS_REFERENCE, >1
 		|	// if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(variable_ptr)))) {
 		|	GET_Z_PTR FCARG1a, Ra(ref_reg)
-		if (!zend_jit_assign_to_typed_ref(Dst, opline, val_type, val_addr, check_exception)) {
+		if (!zend_jit_assign_to_typed_ref(Dst, opline, val_type, val_addr, res_addr, check_exception)) {
 			return 0;
 		}
 		|	lea Ra(ref_reg), [FCARG1a + offsetof(zend_reference, val)]
 		|1:
 	}
 	if (var_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE)) {
 		if (RC_MAY_BE_1(var_info)) {
 			int in_cold = 0;
 
 			if (var_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
 				|	IF_ZVAL_REFCOUNTED var_use_addr, >1
 				|.cold_code
 				|1:
 				in_cold = 1;
 			}
 			if (Z_REG(var_use_addr) == ZREG_FCARG1 || Z_REG(var_use_addr) == ZREG_R0) {
 				bool keep_gc = 0;
 
 				|	GET_ZVAL_PTR Ra(tmp_reg), var_use_addr
 				if (tmp_reg == ZREG_FCARG1) {
 					if (Z_MODE(val_addr) == IS_REG) {
 						keep_gc = 1;
 					} else if ((val_info & ((MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_GUARD)-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE))) == 0) {
 						keep_gc = 1;
 					} else if (Z_MODE(val_addr) == IS_CONST_ZVAL) {
 						if (sizeof(void*) == 4) {
 							keep_gc = 1;
 						} else {
 							zval *zv = Z_ZV(val_addr);
 
 							if (Z_TYPE_P(zv) == IS_DOUBLE) {
 								if (Z_DVAL_P(zv) == 0 || IS_SIGNED_32BIT(zv)) {
 									keep_gc = 1;
 								}
 							} else if (IS_SIGNED_32BIT(Z_LVAL_P(zv))) {
 								keep_gc = 1;
 							}
 						}
 					} else if (Z_MODE(val_addr) == IS_MEM_ZVAL) {
 						if ((val_info & (MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_GUARD)) == MAY_BE_DOUBLE) {
 							keep_gc = 1;
 						}
 					}
 				}
 				if (!keep_gc) {
 					|	mov aword T1, Ra(tmp_reg) // save
 				}
 				if (!zend_jit_simple_assign(Dst, opline, var_addr, var_info, var_def_info, val_type, val_addr, val_info, res_addr, in_cold, 0)) {
 					return 0;
 				}
 				if (!keep_gc) {
 					|	mov FCARG1a, aword T1 // restore
 				}
 			} else {
 				|	GET_ZVAL_PTR FCARG1a, var_use_addr
 				if (!zend_jit_simple_assign(Dst, opline, var_addr, var_info, var_def_info, val_type, val_addr, val_info, res_addr, in_cold, 1)) {
 					return 0;
 				}
 			}
 			|	GC_DELREF FCARG1a
 			if (RC_MAY_BE_N(var_info) && (var_info & (MAY_BE_ARRAY|MAY_BE_OBJECT)) != 0) {
 				|	jnz >4
 			} else {
 				|	jnz >8
 			}
 			|	ZVAL_DTOR_FUNC var_info, opline
 			if (in_cold || (RC_MAY_BE_N(var_info) && (var_info & (MAY_BE_ARRAY|MAY_BE_OBJECT)) != 0)) {
 				if (check_exception) {
 					|	MEM_CMP_ZTS aword, executor_globals, exception, 0, r0
 					|	je >8
 					|	jmp ->exception_handler
 				} else {
 					|	jmp >8
 				}
 			}
 			if (RC_MAY_BE_N(var_info) && (var_info & (MAY_BE_ARRAY|MAY_BE_OBJECT)) != 0) {
 				|4:
 				|	IF_GC_MAY_NOT_LEAK FCARG1a, >8
 				|	EXT_CALL gc_possible_root, r0
 				if (in_cold) {
 					|	jmp >8
 				}
 			}
 			if (in_cold) {
 				|.code
 			} else {
 				done = 1;
 			}
 		} else /* if (RC_MAY_BE_N(var_info)) */ {
 			if (var_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
 				|	IF_NOT_ZVAL_REFCOUNTED var_use_addr, >5
 			}
 			if (var_info & (MAY_BE_ARRAY|MAY_BE_OBJECT)) {
 				if (Z_REG(var_use_addr) != ZREG_FP) {
 					|	mov T1, Ra(Z_REG(var_use_addr)) // save
 				}
 				|	GET_ZVAL_PTR FCARG1a, var_use_addr
 				|	GC_DELREF FCARG1a
 				|	IF_GC_MAY_NOT_LEAK FCARG1a, >5
 				|	EXT_CALL gc_possible_root, r0
 				if (Z_REG(var_use_addr) != ZREG_FP) {
 					|	mov Ra(Z_REG(var_use_addr)), T1 // restore
 				}
 			} else {
 				|	GET_ZVAL_PTR Ra(tmp_reg), var_use_addr
 				|	GC_DELREF Ra(tmp_reg)
 			}
 			|5:
 	    }
 	}
 
 	if (!done && !zend_jit_simple_assign(Dst, opline, var_addr, var_info, var_def_info, val_type, val_addr, val_info, res_addr, 0, 0)) {
 		return 0;
 	}
 
 	|8:
 
 	return 1;
 }
diff --git a/ext/opcache/tests/jit/assign_041.phpt b/ext/opcache/tests/jit/assign_041.phpt
new file mode 100644
index 0000000000..c9b74ffa2b
--- /dev/null
+++ b/ext/opcache/tests/jit/assign_041.phpt
@@ -0,0 +1,22 @@
+--TEST--
+JIT ASSIGN: Assign to typed reference should return modified value
+--INI--
+opcache.enable=1
+opcache.enable_cli=1
+opcache.file_update_protection=0
+opcache.jit_buffer_size=1M
+opcache.protect_memory=1
+--FILE--
+<?php
+class Test {
+    public ?string $prop;
+}
+function test($val) {
+    $obj = new Test;
+    $ref =& $obj->prop;
+    var_dump($ref = $val);
+}
+test(0);
+?>
+--EXPECT--
+string(1) "0"
\ No newline at end of file
