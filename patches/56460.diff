commit 0343c63bd04d387924974e6da60d8471fdf945a9
Author: David Anderson <davea42@linuxmail.org>
Date:   Sun Mar 12 14:27:36 2023 -0700

    This is a significant revision of dwarf_str_offsets.[ch]
    with consequences in several places.
    
    The old code was hard to follow. This
    is much easier to understand.
    
    Still has debugging-related #if 0 in it, those will be removed in
    the next commit.
            modified:   src/lib/libdwarf/dwarf_die_deliv.c
            modified:   src/lib/libdwarf/dwarf_fission_to_cu.c
            modified:   src/lib/libdwarf/dwarf_form.c
            modified:   src/lib/libdwarf/dwarf_macro5.c
            modified:   src/lib/libdwarf/dwarf_opaque.h
            modified:   src/lib/libdwarf/dwarf_query.c
            modified:   src/lib/libdwarf/dwarf_str_offsets.c
            modified:   src/lib/libdwarf/dwarf_str_offsets.h

diff --git a/src/lib/libdwarf/dwarf_die_deliv.c b/src/lib/libdwarf/dwarf_die_deliv.c
index 4988f9c7..5edba5ff 100644
--- a/src/lib/libdwarf/dwarf_die_deliv.c
+++ b/src/lib/libdwarf/dwarf_die_deliv.c
@@ -1043,306 +1043,306 @@ static int
 find_cu_die_base_fields(Dwarf_Debug dbg,
     Dwarf_CU_Context cucon,
     Dwarf_Die cudie,
     Dwarf_Error*    error)
 {
     Dwarf_CU_Context  cu_context = 0;
     Dwarf_Attribute * alist = 0;
     Dwarf_Signed      atcount = 0;
     unsigned          version_stamp = 2;
     int               alres = 0;
     Dwarf_Signed      i = 0;
     Dwarf_Signed low_pc_attrnum = -1;
     Dwarf_Signed entry_pc_attrnum = -1;
     Dwarf_Signed at_addr_base_attrnum = -1;
 
     cu_context = cudie->di_cu_context;
     version_stamp = cu_context->cc_version_stamp;
 
     alres = dwarf_attrlist(cudie, &alist,
         &atcount,error);
     if (alres != DW_DLV_OK) {
         /* Something is badly wrong. No attrlist! */
         return alres;
     }
     /*  DW_AT_dwo_id and/or DW_AT_GNU_dwo_id
         are only found  in some
         experimental DWARF4.
         Even DWARF3,4 use DW_AT_low_pc as base address
         DWARF5 changed CU header contents
         to make this attribute unnecessary.
         DW_AT_GNU_odr_signature is the same format,
         but is in a different namespace so not
         appropriate here..
     */
     for (i = 0;  i < atcount; ++i) {
         Dwarf_Half attrnum = 0;
         Dwarf_Half form = 0;
         int ares = 0;
         int ares2 = 0;
         Dwarf_Attribute attr = alist[i];
 
         ares = dwarf_whatattr(attr,&attrnum,error);
         if (ares == DW_DLV_ERROR && error) {
             dwarf_dealloc_error(dbg,*error);
             *error = 0;
         }
         ares2 = dwarf_whatform(attr,&form,error);
         if (ares2 == DW_DLV_ERROR && error) {
             dwarf_dealloc_error(dbg,*error);
             *error = 0;
         }
         /*  We are not returning on DW_DLV_NO_ENTRY
             or DW_DLV_ERROR here. Such will be
             caught later. Lets finish a CU die
             scan and finish the cu_context  */
         if (ares == DW_DLV_OK && ares2 == DW_DLV_OK) {
             switch(form) {
             case DW_FORM_strx:
             case DW_FORM_strx1:
             case DW_FORM_strx2:
             case DW_FORM_strx3:
             case DW_FORM_strx4:
                 cucon->cc_at_strx_present = TRUE;
             default:
                 break;
             }
             switch(attrnum) {
             case DW_AT_dwo_id:
             case DW_AT_GNU_dwo_id: {
                 Dwarf_Sig8 signature;
                 /*  This is for DWARF4 with an early
                     non-standard version
                     of split dwarf. Not DWARF5. */
                 int sres = 0;
                 if (version_stamp != DW_CU_VERSION4 ) {
                     /* Not supposed to happen. */
                     local_attrlist_dealloc(dbg,atcount,alist);
                     _dwarf_error(dbg,error,
                         DW_DLE_IMPROPER_DWO_ID);
                     return DW_DLV_ERROR;
                 }
                 signature = dwarfsig8zero;
                 sres = dwarf_formsig8_const(attr,
                     &signature,error);
                 if (sres == DW_DLV_OK) {
                     if (!cucon->cc_signature_present) {
                         cucon->cc_signature = signature;
                         cucon->cc_signature_present = TRUE;
                     } else {
                         /*  Something wrong. Two styles of sig?
                             Can happen with DWARF4
                             debug-fission extension DWO_id.
                         */
                         if (memcmp(&signature,&cucon->cc_signature,
                             sizeof(signature))) {
                             /*  The two sigs do not match! */
                             const char *m="DW_DLE_SIGNATURE_MISMATCH"
                                 "DWARF4 extension fission signature"
                                 " and DW_AT_GNU_dwo_id do not match"
                                 " ignoring DW_AT[_GNU]_dwo_id";
                             dwarf_insert_harmless_error(dbg,
                                 (char*)m);
                         }
                     }
                 } else {
                     /* Something is badly wrong. */
                     local_attrlist_dealloc(dbg,atcount,alist);
                     return sres;
                 }
                     /* Something is badly wrong. */
                 break;
             }
             /*  If, in .debug_rnglists for a CU the
                 applicable range has no base address
                 this attribute provides a base address.
                 If this is indexed doing this now would
                 lead to an infinite recursion.
                 So wait till all the other fields seen.
             */
             case DW_AT_low_pc: {
                 low_pc_attrnum = i;
                 break;
             }
             /*  DW_AT_producer 4.2.1 (Based on Apple Inc. build 5658)
                 (LLVM build 2336.1.00) uses DW_AT_entry_pc as the
                 base address (DW_AT_entry_pc
                 first appears in DWARF3).
                 So we allow that as an extension,
                 as a 'low_pc' if there is DW_AT_entry_pc with
                 no DW_AT_low_pc. 19 May 2022.
             */
             case DW_AT_entry_pc: {
                 entry_pc_attrnum = i;
                 break;
             }
 
             /*  The offset is of the first offset in
                 .debug_str_offsets that is the string table
                 for this CU. */
             case DW_AT_str_offsets_base:{
                 int udres = 0;
 
                 udres = dwarf_global_formref(attr,
-                    &cucon->cc_str_offsets_base,
+                    &cucon->cc_str_offsets_header_offset,
                     error);
                 if (udres == DW_DLV_OK) {
-                    cucon->cc_str_offsets_base_present = TRUE;
+                    cucon->cc_str_offsets_tab_present = TRUE;
                 } else {
                     local_attrlist_dealloc(dbg,atcount,alist);
                     /* Something is badly wrong. */
                     return udres;
                 }
                 break;
             }
             /*  offset in .debug_loclists  of the offsets table
                 applicable to this CU. */
             case DW_AT_loclists_base: {
                 int udres = 0;
 
                 udres = dwarf_global_formref(attr,
                     &cucon->cc_loclists_base,
                     error);
                 if (udres == DW_DLV_OK) {
                     cucon->cc_loclists_base_present = TRUE;
                 } else {
                     local_attrlist_dealloc(dbg,atcount,alist);
                     /* Something is badly wrong. */
                     return udres;
                 }
                 break;
                 }
             /*  Base offset  in .debug_addr of the addr table
                 for this CU. DWARF5 (and possibly GNU DWARF4) */
             case DW_AT_addr_base:
             case DW_AT_GNU_addr_base: {
                 int udres = 0;
 
                 at_addr_base_attrnum = i;
                 udres = dwarf_global_formref(attr,
                     &cucon->cc_addr_base,
                     error);
                 if (udres == DW_DLV_OK) {
                     cucon->cc_addr_base_present = TRUE;
                 } else {
                     local_attrlist_dealloc(dbg,atcount,alist);
                     /* Something is badly wrong. */
                     return udres;
                 }
                 break;
             }
             case DW_AT_GNU_ranges_base: {
             /*  The DW4 ranges base was never used in GNU
                 but did get emitted in skeletons.
                 http://llvm.1065342.n5.nabble.com/
                 DebugInfo-DW-AT-GNU-ranges-base-in-
                 non-fission-td64194.html
                 But we accept it anyway. */
             /*  offset in .debug_rnglists  of the offsets table
                 applicable to this CU.
                 Note that this base applies when
                 referencing from the dwp, but NOT
                 when referencing from the a.out */
                 int udres = 0;
 
                 udres = dwarf_global_formref(attr,
                     &cucon->cc_ranges_base,
                     error);
                 if (udres == DW_DLV_OK) {
                     cucon->cc_ranges_base_present = TRUE;
                 } else {
                     local_attrlist_dealloc(dbg,atcount,alist);
                     /* Something is badly wrong. */
                     return udres;
                 }
                 break;
                 }
             case  DW_AT_rnglists_base: {
                 int udres = 0;
 
                 udres = dwarf_global_formref(attr,
                     &cucon->cc_rnglists_base,
                     error);
                 if (udres == DW_DLV_OK) {
                     cucon->cc_rnglists_base_present = TRUE;
                 } else {
                     local_attrlist_dealloc(dbg,atcount,alist);
                     /* Something is badly wrong. */
                     return udres;
                 }
                 break;
                 }
             /*  A signature, found in a DWARF5 skeleton
                 compilation unit. */
             case DW_AT_GNU_dwo_name:
             case DW_AT_dwo_name: {
                 int dnres = 0;
 
                 dnres = dwarf_formstring(attr,
                     &cucon->cc_dwo_name,error);
                 if (dnres != DW_DLV_OK) {
                     local_attrlist_dealloc(dbg,atcount,alist);
                     return dnres;
                 }
                 cucon->cc_dwo_name_present = TRUE;
                 break;
                 }
             default: /* do nothing, not an attribute
                 we need to deal with here. */
                 break;
             }
         }
     }
     if (low_pc_attrnum >= 0 ){
         int battr = 0;
 
         /* Prefer DW_AT_low_pc */
         Dwarf_Attribute attr = alist[low_pc_attrnum];
         battr = _dwarf_setup_base_address(dbg,"DW_AT_low_pc",
             attr,at_addr_base_attrnum, cucon,error);
         if (battr != DW_DLV_OK) {
             local_attrlist_dealloc(dbg,atcount,alist);
             /* Something is badly wrong */
             return battr;
         }
     } else if (entry_pc_attrnum >= 0) {
         int battr = 0;
 
         /*  Pretending that DW_AT_entry_pc with no
             DW_AT_low_pc is a valid base address for
             loccation lists.
             DW_AT_producer 4.2.1 (Based on Apple Inc. build 5658)
             (LLVM build 2336.1.00) uses DW_AT_entry_pc as the
             base address (DW_AT_entry_pc first appears in DWARF3).
             So we allow that as an extension,
             as a 'low_pc' if there is DW_AT_entry_pc with
             no DW_AT_low_pc. 19 May 2022. */
         Dwarf_Attribute attr = alist[entry_pc_attrnum];
         battr = _dwarf_setup_base_address(dbg,"DW_AT_entry_pc",
             attr,at_addr_base_attrnum, cucon,error);
         if (battr != DW_DLV_OK) {
             local_attrlist_dealloc(dbg,atcount,alist);
             /* Something is badly wrong */
             return battr;
         }
     }
     local_attrlist_dealloc(dbg,atcount,alist);
     alist = 0;
     atcount = 0;
     {
         int chres = 0;
         Dwarf_Half flag = 0;
 
         /*  always winds up with cc_cu_die_has_children
             set intentionally...to something. */
         cucon->cc_cu_die_has_children = TRUE;
         chres = dwarf_die_abbrev_children_flag(cudie,&flag);
         /*  If chres is not DW_DLV_OK the assumption
             of children remains true. */
         if (chres == DW_DLV_OK) {
             cucon->cc_cu_die_has_children = flag;
         }
     }
     return DW_DLV_OK;
 }
 
 /*  Called only for DWARF4 */
diff --git a/src/lib/libdwarf/dwarf_fission_to_cu.c b/src/lib/libdwarf/dwarf_fission_to_cu.c
index a17c7ce0..d1b6e390 100644
--- a/src/lib/libdwarf/dwarf_fission_to_cu.c
+++ b/src/lib/libdwarf/dwarf_fission_to_cu.c
@@ -111,66 +111,71 @@ static int
 load_xu_str_offsets_into_cucontext(Dwarf_Debug dbg,
     Dwarf_CU_Context cu_context,
     struct Dwarf_Debug_Fission_Per_CU_s*fsd,
     int fsd_index,
     Dwarf_Error *error )
 {
     Dwarf_Small *soff_secptr = 0;
-    Dwarf_Small *soff_hdrptr = 0;
     Dwarf_Unsigned soff_hdroffset = 0;
     Dwarf_Unsigned soff_size = 0;
     Dwarf_Small *soff_eptr = 0;
+    Dwarf_Small *soff_hdrptr;
     int res = 0;
 
     res = _dwarf_load_section(dbg, &dbg->de_debug_str_offsets,
         error);
     if (res != DW_DLV_OK) {
         return res;
     }
     soff_hdroffset = fsd->pcu_offset[fsd_index];
     soff_secptr = dbg->de_debug_str_offsets.dss_data;
     soff_size = dbg->de_debug_str_offsets.dss_size;
-    soff_eptr = soff_secptr + soff_size;
     soff_hdrptr = soff_secptr + soff_hdroffset;
     if (soff_hdroffset >= soff_size) {
         /*  Something is badly wrong. Ignore it here. */
         return DW_DLV_NO_ENTRY;
     }
 
     {
         Dwarf_Unsigned length = 0;
         Dwarf_Half     offset_size = 0;
         Dwarf_Half     extension_size = 0;
         Dwarf_Half     version = 0;
         Dwarf_Half     padding = 0;
-        Dwarf_Unsigned header_length = 0;
+        Dwarf_Unsigned local_offset_to_array=0;
+        Dwarf_Unsigned total_table_length   =0;
+        struct Dwarf_Str_Offsets_Table_s  sotstr;
 
-        res =  _dwarf_read_str_offsets_header(dbg,
+        memset(&sotstr,0,sizeof(sotstr));
+        sotstr.so_dbg = dbg;
+        sotstr.so_section_start_ptr = soff_secptr;
+        sotstr.so_section_end_ptr = soff_eptr;
+        sotstr.so_section_size = soff_size;
+        sotstr.so_next_table_offset = soff_hdroffset;
+        res =  _dwarf_read_str_offsets_header(&sotstr,
             soff_hdrptr,
-            soff_size - soff_hdroffset,
-            soff_eptr,
             cu_context,
             &length,&offset_size,
             &extension_size,&version,&padding,
-            &header_length,
+            &local_offset_to_array,
+            &total_table_length,
             error);
         if (res != DW_DLV_OK) {
             if (res == DW_DLV_ERROR && error) {
                 dwarf_dealloc_error(dbg,*error);
                 *error = 0;
             }
-            res = DW_DLV_NO_ENTRY;
-            return res;
+            return DW_DLV_NO_ENTRY;
         }
-        cu_context->cc_str_offsets_base_present = TRUE;
-        cu_context->cc_str_offsets_header_length_present = TRUE;
+        /*  See dwarf_opaque.h for comments. */
+        cu_context->cc_str_offsets_tab_present = TRUE;
         cu_context->cc_str_offsets_header_offset = soff_hdroffset;
-        cu_context->cc_str_offsets_base = soff_hdroffset +
-            header_length;
-        cu_context->cc_str_offsets_header_length = header_length;
+        cu_context->cc_str_offsets_tab_to_array_present = TRUE;
+        cu_context->cc_str_offsets_tab_to_array = local_offset_to_array;
         cu_context->cc_str_offsets_offset_size = offset_size;
+        cu_context->cc_str_offsets_version = version;
     }
     return DW_DLV_OK;
 }
 
 /*  ASSERT: dbg,cu_context, and fsd are non-NULL
     as the caller ensured that. */
diff --git a/src/lib/libdwarf/dwarf_form.c b/src/lib/libdwarf/dwarf_form.c
index 19a06f75..610e6644 100644
--- a/src/lib/libdwarf/dwarf_form.c
+++ b/src/lib/libdwarf/dwarf_form.c
@@ -1,57 +1,58 @@
 /*
   Copyright (C) 2000,2002,2004,2005 Silicon Graphics, Inc. All Rights Reserved.
   Portions Copyright 2007-2010 Sun Microsystems, Inc. All rights reserved.
   Portions Copyright 2008-2021 David Anderson. All rights reserved.
   Portions Copyright 2010-2012 SN Systems Ltd. All rights reserved.
 
   This program is free software; you can redistribute it
   and/or modify it under the terms of version 2.1 of the
   GNU Lesser General Public License as published by the Free
   Software Foundation.
 
   This program is distributed in the hope that it would be
   useful, but WITHOUT ANY WARRANTY; without even the implied
   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
   PURPOSE.
 
   Further, this software is distributed without any warranty
   that it is free of the rightful claim of any third person
   regarding infringement or the like.  Any license provided
   herein, whether implied or otherwise, applies only to this
   software file.  Patent licenses, if any, provided herein
   do not apply to combinations of this program with other
   software, or any other product whatsoever.
 
   You should have received a copy of the GNU Lesser General
   Public License along with this program; if not, write the
   Free Software Foundation, Inc., 51 Franklin Street - Fifth
   Floor, Boston MA 02110-1301, USA.
 
 */
 
 #include <config.h>
 
 #include <string.h>  /* memcpy() memset() */
+#include <stdio.h>  /* printf() */
 
 #if defined(_WIN32) && defined(HAVE_STDAFX_H)
 #include "stdafx.h"
 #endif /* HAVE_STDAFX_H */
 
 #include "dwarf.h"
 #include "libdwarf.h"
 #include "libdwarf_private.h"
 #include "dwarf_base_types.h"
 #include "dwarf_opaque.h"
 #include "dwarf_alloc.h"
 #include "dwarf_string.h"
 #include "dwarf_error.h"
 #include "dwarf_util.h"
 #include "dwarf_die_deliv.h"
 #include "dwarf_str_offsets.h"
 #include "dwarf_string.h"
 
 /*  It is necessary at times to cause errors of this sort
     in determining what we really have.  So best to avoid
     too much malloc and free, hence the static constructor
     dwarfstring will use malloc if we guess too-small
     for the size of mbuf. */
@@ -1649,116 +1650,158 @@ int
 _dwarf_extract_string_offset_via_str_offsets(Dwarf_Debug dbg,
     Dwarf_Small *data_ptr,
     Dwarf_Small *end_data_ptr,
     Dwarf_Half   attrform,
     Dwarf_CU_Context cu_context,
     Dwarf_Unsigned *str_sect_offset_out,
     Dwarf_Error *error)
 {
     Dwarf_Unsigned index_to_offset_entry = 0;
     Dwarf_Unsigned offsetintable = 0;
     Dwarf_Unsigned end_offsetintable = 0;
     Dwarf_Unsigned indexoffset = 0;
     Dwarf_Unsigned baseoffset = 0;
+    Dwarf_Unsigned table_offset_to_array = 0;
+    Dwarf_Unsigned table_size = 0;
     int res = 0;
     int idxres = 0;
-    Dwarf_Small *sof_start = 0;
+    Dwarf_Small *sectionptr = 0;
+    Dwarf_Unsigned sectionlen = 0;
     Dwarf_Unsigned sof_len = 0;
+    Dwarf_Small   *sof_start = 0;
     Dwarf_Small   *sof_end = 0;
+    Dwarf_Unsigned str_sect_offset = 0;
+    Dwarf_Unsigned table_end_offset = 0;
+    Dwarf_Unsigned length_size  = 0;
 
     res = _dwarf_load_section(dbg, &dbg->de_debug_str_offsets,error);
     if (res != DW_DLV_OK) {
         return res;
     }
+    sectionptr = dbg->de_debug_str_offsets.dss_data;
+    sectionlen = dbg->de_debug_str_offsets.dss_size;
+    length_size = cu_context->cc_length_size;  
     /*  If this is a dwp we look there, but I suppose
         we could also look for the section in the tied
-        file it is not here. */
-    sof_start = dbg->de_debug_str_offsets.dss_data;
-    sof_len = dbg->de_debug_str_offsets.dss_size;
-    sof_end = sof_start+sof_len;
+        executable object file it is not here. FIXME */
     idxres = dw_read_str_index_val_itself(dbg,
         attrform,data_ptr,end_data_ptr,&index_to_offset_entry,error);
     if ( idxres != DW_DLV_OK) {
         return idxres;
     }
 
-    if (cu_context->cc_str_offsets_base_present) {
-        baseoffset = cu_context->cc_str_offsets_base;
+#if 0
+printf("dadebug str_offsets_base_present %u line %d\n",cu_context->cc_str_offsets_tab_present,__LINE__);
+#endif
+    if (cu_context->cc_str_offsets_tab_present) {
+        baseoffset = cu_context->cc_str_offsets_header_offset;
+#if 0
+printf("dadebug str_offsets_base 0x%llx line %d\n",baseoffset,__LINE__);
+#endif
+    }
+    if (cu_context->cc_str_offsets_tab_to_array_present) {
+        table_offset_to_array = cu_context->cc_str_offsets_tab_to_array;
     }
-    indexoffset = index_to_offset_entry*
-        cu_context->cc_length_size;
-    baseoffset = cu_context->cc_str_offsets_base;
-    if (!baseoffset) {
+    table_size = cu_context->cc_str_offsets_table_size;
+
+/*    if (cu_context->cc_str_offsets_table_size) */
+#if 0
+printf("dadebug indexoffset 0x%llx line %d\n",indexoffset,__LINE__);
+printf("dadebug str_offsets_base 0x%llx line %d\n",baseoffset,__LINE__);
+printf("dadebug str_offsets tab %u line %d\n",cu_context->cc_str_offsets_tab_present,__LINE__);
+printf("dadebug str_offsets tab_to_arry %u line %d\n",cu_context->
+cc_str_offsets_tab_to_array_present,__LINE__);
+fflush(stdout);
+#endif
+    if (!cu_context->cc_str_offsets_tab_present ||
+        !cu_context->cc_str_offsets_tab_to_array_present) {
+#if 0
+printf("dadebug ERROR: missing tab data! line %d\n",__LINE__);
+fflush(stdout);
+#endif
+        /*  missing any connection to a specific
+            str_offsets table this guesses at table zero.
+            When the compiler/linker have
+            combined str offsets into a
+            single table this works. */
         if (cu_context->cc_version_stamp ==  DW_CU_VERSION5 ) {
-            /*  A base offset of 0 isnormally never correct for
+            /*  A base offset of 0 is ok for either 
                 DWARF5. but some early GNU compilers emitted
                 DWARF4 .debug_str_offsets, so lets check
                 the first table.  */
-            Dwarf_Small * ststart =
-                dbg->de_debug_str_offsets.dss_data;
-            Dwarf_Small * stend = 0;
-            Dwarf_Unsigned  stsize =
+            Dwarf_Unsigned stsize =
                 dbg->de_debug_str_offsets.dss_size;
-            Dwarf_Unsigned length            = 0;
-            Dwarf_Half local_offset_size = 0;
+            Dwarf_Unsigned length           = 0;
+            Dwarf_Unsigned table_length     = 0;
+            Dwarf_Half local_offset_size    = 0;
             Dwarf_Half local_extension_size = 0;
-            Dwarf_Half version               = 0;
-            Dwarf_Half padding               = 0;
+            Dwarf_Half version              = 0;
+            Dwarf_Half padding              = 0;
+            /*  starting at head of section! This is surely wrong. */
+            Dwarf_Unsigned global_array_off  = 0;
+
 
-            stend = ststart + stsize;
             res = _dwarf_trial_read_dwarf_five_hdr(dbg,
-                ststart,stsize,stend,
+                baseoffset,stsize,
+                &table_offset_to_array,
+                &table_length,
                 &length, &local_offset_size,
                 &local_extension_size,
                 &version,
                 &padding,
                 error);
             if (res == DW_DLV_OK) {
-                baseoffset = local_extension_size +
-                    local_offset_size +
-                    2*DWARF_HALF_SIZE;
+                /* baseoffset unchanged */
             } else {
                 if (res == DW_DLV_ERROR && error) {
                     dwarf_dealloc_error(dbg,*error);
                     *error = 0;
                 } else {}
             }
         }
     }
-    offsetintable = baseoffset +indexoffset;
-    end_offsetintable = offsetintable +
-        cu_context->cc_str_offsets_offset_size;
+    indexoffset = index_to_offset_entry* length_size;
+    offsetintable = indexoffset+ baseoffset 
+         + table_offset_to_array;
+    end_offsetintable = offsetintable + length_size;
+    table_end_offset = baseoffset + table_size;
+#if 0
+printf("dadebug offsetintable 0x%llx line %d\n",offsetintable,__LINE__);
+printf("dadebug table end offset 0x%llx line %d\n",
+table_end_offset,__LINE__);
+#endif
     /*  The offsets table is a series of offset-size entries.
         The == case in the test applies when we are at the last table
         entry, so == is not an error, hence only test >
     */
-    if (end_offsetintable > dbg->de_debug_str_offsets.dss_size ) {
+    if (end_offsetintable  > sectionlen) {
         dwarfstring m;
 
         dwarfstring_constructor(&m);
         dwarfstring_append_printf_u(&m,
             "DW_DLE_ATTR_FORM_SIZE_BAD: The end offset of "
             "a .debug_str_offsets table is 0x%x ",
             end_offsetintable);
         dwarfstring_append_printf_u(&m,
             "but the object section is just 0x%x "
             "bytes long",
-            dbg->de_debug_str_offsets.dss_size);
+            sectionlen);
         _dwarf_error_string(dbg, error,
             DW_DLE_ATTR_FORM_SIZE_BAD,
             dwarfstring_string(&m));
         dwarfstring_destructor(&m);
         return DW_DLV_ERROR;
     }
 
-    {
-        Dwarf_Unsigned offsettostr = baseoffset+offsetintable;
-
-        /* Now read the string offset from the offset table. */
-        READ_UNALIGNED_CK(dbg,offsettostr,Dwarf_Unsigned,
-            sof_start+ offsetintable,
-            cu_context->cc_length_size,error,sof_end);
-        *str_sect_offset_out = offsettostr;
-    }
+    sof_start = sectionptr+ offsetintable;
+    sof_end = sectionptr + end_offsetintable; 
+#if 0
+printf("dadebug offsettostr 0x%llx line %d\n",offsetintable,__LINE__);
+#endif
+    /* Now read the string offset from the offset table. */
+    READ_UNALIGNED_CK(dbg,str_sect_offset,Dwarf_Unsigned,
+        sof_start,
+        length_size,error,sof_end);
+    *str_sect_offset_out = str_sect_offset;
     return DW_DLV_OK;
 }
 
diff --git a/src/lib/libdwarf/dwarf_macro5.c b/src/lib/libdwarf/dwarf_macro5.c
index 17d35329..5fb035cd 100644
--- a/src/lib/libdwarf/dwarf_macro5.c
+++ b/src/lib/libdwarf/dwarf_macro5.c
@@ -1,52 +1,53 @@
 /*
   Copyright (C) 2015-2022 David Anderson. All Rights Reserved.
 
   This program is free software; you can redistribute it
   and/or modify it under the terms of version 2.1 of the
   GNU Lesser General Public License as published by the Free
   Software Foundation.
 
   This program is distributed in the hope that it would be
   useful, but WITHOUT ANY WARRANTY; without even the implied
   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
   PURPOSE.
 
   Further, this software is distributed without any warranty
   that it is free of the rightful claim of any third person
   regarding infringement or the like.  Any license provided
   herein, whether implied or otherwise, applies only to this
   software file.  Patent licenses, if any, provided herein
   do not apply to combinations of this program with other
   software, or any other product whatsoever.
 
   You should have received a copy of the GNU Lesser General
   Public License along with this program; if not, write the
   Free Software Foundation, Inc., 51 Franklin Street - Fifth
   Floor, Boston MA 02110-1301, USA.
 
 */
 
 #include <config.h>
 
 #include <stdlib.h> /* calloc() free() malloc() */
 #include <string.h> /* memset() strcat() strlen() */
 
 #if defined(_WIN32) && defined(HAVE_STDAFX_H)
 #include "stdafx.h"
 #endif /* HAVE_STDAFX_H */
 
 #include "dwarf.h"
 #include "libdwarf.h"
 #include "libdwarf_private.h"
 #include "dwarf_base_types.h"
 #include "dwarf_safe_strcpy.h"
 #include "dwarf_opaque.h"
 #include "dwarf_alloc.h"
 #include "dwarf_error.h"
 #include "dwarf_util.h"
 #include "dwarf_macro5.h"
 #include "dwarf_string.h"
+#include "dwarf_str_offsets.h"
 
 #define MC_SENTINEL  0xada
 
 #define CHECKNULLCONTEXT(m,d,e)             \
diff --git a/src/lib/libdwarf/dwarf_opaque.h b/src/lib/libdwarf/dwarf_opaque.h
index a4e7a33a..c3a66826 100644
--- a/src/lib/libdwarf/dwarf_opaque.h
+++ b/src/lib/libdwarf/dwarf_opaque.h
@@ -137,196 +137,198 @@ struct Dwarf_Attribute_s {
     **Updated by dwarf_next_cu_header in dwarf_die_deliv.c
 */
 struct Dwarf_CU_Context_s {
     Dwarf_Debug cc_dbg;
     /*  The sum of cc_length, cc_length_size, and cc_extension_size
         is the total length of the CU including its header.
         cc_length is the length of the compilation unit excluding
         cc_length_size and cc_extension_size.  */
     Dwarf_Unsigned cc_length;
 
     /*  cc_length_size is the size in bytes of an offset.
         Should probably be renamed cc_offset_size.
         4 for 32bit dwarf, 8 for 64bit dwarf (whether MIPS/IRIX
         64bit dwarf or standard 64bit dwarf using the extension
         mechanism). */
     Dwarf_Small cc_length_size;
 
     /*  cc_extension_size is zero unless this is standard
         DWARF3 and later 64bit dwarf using the extension mechanism.
         64bit DWARF3 and later: cc_extension_size is 4.
         64bit DWARF2 MIPS/IRIX: cc_extension_size is zero.
         32bit DWARF:            cc_extension_size is zero.  */
     Dwarf_Small cc_extension_size;
 
     /*  cc_version_stamp is the DWARF version number applicable
         to the  DWARF in this compilation unit. 2,3,4,... */
     Dwarf_Half cc_version_stamp;
     /*  cc_abbrev_offset is the section-global offset
         of the .debug_abbrev section this CU uses.
         Data from CU header. Includes DWP adjustment made
         as soon as we create a cu_context. */
     Dwarf_Unsigned cc_abbrev_offset;
 
     /*  cc_address_size is the size of an address in this
         compilation unit. */
     Dwarf_Small cc_address_size;
     Dwarf_Small cc_segment_selector_size;
 
     /*  cc_debug_offset is the global offset in the section
         of the area length field of the CU.
         The CU header of the CU is at offset
         cc_debug_offset+cc_length_size+cc_extension_size;
         This is a section global offset.
         May be debug_info or debug_types.
         Even in DWP this is set to true global offset
         right away when cu_context created.
         See cc_is_info flag. */
     Dwarf_Unsigned cc_debug_offset;
 
     /* === START DEBUG FISSION (Split Dwarf) data
         cc_signature is in the TU header
         of a type unit of a TU DIE (or for DW5 in the
         skeleton or split_compile header is a dwo_id).
         Ignore this field if cc_signature_present is zero.
         (TU CUs signature is not the same namespace
         as DW_AT_dwo_id signatures. The two must be
         kept separate (for DWARF5))
 
         If cc_unit_type == DW_UT_compile or DW_UT_partial
             the signature is a CU signature (dwo_id).
         Some early DW5 drafts encouraged DWARF4 output
             of some compilers to include dwo_id, but
             in a messier way(lacking DW_UT_*).
         If cc_unit_type ==  DW_UT_split_type
             the signature is a type signature. */
     Dwarf_Half  cc_cu_die_tag;
 
     Dwarf_Sig8  cc_signature;
 
     /*  cc_type_signature_offset contains the
         section-local DIE offset of the type
         the signature applies to if the cc_unit_type
         is DW_UT_type or DW_UT_split_type. */
     Dwarf_Unsigned cc_signature_offset;
 
     /*  For each CU and each TU
         in a dwp package file there is
         is a hash and
         a set of offsets indexed by DW_SECT_* id.
         Only one such set per CU or TU.
         The data on all that is in cc_dwp_offsets
 
         If it is a TU the signature in cc_dwp_offsets
         must match the signature in cc_signature.
         */
     struct Dwarf_Debug_Fission_Per_CU_s  cc_dwp_offsets;
 
     Dwarf_Bool cc_signature_present; /* Meaning type signature
         in TU header or, for CU header, signature in CU DIE. */
     Dwarf_Bool cc_low_pc_present;
     Dwarf_Bool cc_addr_base_present;   /* Not TRUE in .dwo */
 
     Dwarf_Bool cc_cu_die_has_children;
     Dwarf_Bool cc_dwo_name_present;
     Dwarf_Bool cc_at_strx_present;
 
     /*  Non zero if this context is a dwo section. Either
         dwo or dwp file. */
     Dwarf_Bool cc_is_dwo;
 
     /*  cc_cu_die_offset_present is non-zero if
         cc_cu_die_global_sec_offset is meaningful.  */
     Dwarf_Bool     cc_cu_die_offset_present;
 
     /*  If present, is base address of CU.  In DWARF2
         nothing says what attribute is the base address.
         DW_AT_producer 4.2.1 (Based on Apple Inc. build 5658)
         (LLVM build 2336.1.00) uses DW_AT_entry_pc as the
         base address.  DW_AT_entry_pc first appears
         in DWARF3.
         We allow  DW_AT_entry_pc as an extension,
         as a 'low_pc' if there is DW_AT_entry_pc with
         no DW_AT_low_pc. 19 May 2022.
         In DWARF3, DWARF4 DW_AT_low_pc is specifically
         mentioned as the base address.  */
     Dwarf_Unsigned cc_low_pc;
     /*  from DW_AT_addr_base in CU DIE, offset to .debug_addr table */
     Dwarf_Unsigned cc_addr_base;  /* Zero in .dwo */
 
     /*  DW_SECT_LINE */
     Dwarf_Bool     cc_line_base_present;     /*DW5 */
     Dwarf_Unsigned cc_line_base;             /*DW5 */
     Dwarf_Unsigned cc_line_base_contr_size;  /*DW5 */
 
     /*  From DW_AT_loclists_base or DW_SECT_LOCLISTS */
     Dwarf_Unsigned cc_loclists_base;
     Dwarf_Unsigned cc_loclists_base_contr_size;
     Dwarf_Bool     cc_loclists_base_present;
     Dwarf_Bool     cc_loclists_header_length_present;
 
     /*  .debug_str_offsets DW_SECT_STR_OFFSETS DW4 DW5 vs
-        DW_AT_str_offsets_base (table array off) */
-    Dwarf_Bool     cc_str_offsets_base_present;
-    Dwarf_Bool     cc_str_offsets_header_length_present;
-    Dwarf_Unsigned cc_str_offsets_header_offset; /* from cu/tu*/
-    Dwarf_Unsigned cc_str_offsets_contr_size;
-    Dwarf_Unsigned cc_str_offsets_base;
+        DW_AT_str_offsets_base (table array offset) .
+        Here cc_str_offsets_tab_present 
+        paired with cc_str_offsets_header_offset
+        which is what the offset means */
+    Dwarf_Bool     cc_str_offsets_tab_present;
+    /*  Without tab_to_array present we cannot do much. */
+    Dwarf_Bool     cc_str_offsets_tab_to_array_present;
+
+    /*  header_offset is global offset in str_offsets section. */
+    Dwarf_Unsigned cc_str_offsets_header_offset; /* cu/tu etc*/
+    Dwarf_Unsigned cc_str_offsets_table_size; 
+
     /*  to get from the start of a str_offsets table to the
-        offsets array entries.
-        See cc_str_offsets_header_length_present,
-        though not normally needed. If header_length
-        is zero all CUs in this DWP
-        use a DWARF4 extension simple offset array,
-        not a DWARF5 set of tables. */
-    Dwarf_Unsigned cc_str_offsets_header_length;
+        offsets array entries. */
+    Dwarf_Unsigned cc_str_offsets_tab_to_array;
     Dwarf_Unsigned cc_str_offsets_offset_size;
+    Dwarf_Half     cc_str_offsets_version;
 
     /*  DW_SECT_MACRO */
     Dwarf_Unsigned cc_macro_base;    /*DW5 */
     Dwarf_Unsigned cc_macro_base_contr_size;    /*DW5 */
     Dwarf_Bool     cc_macro_base_present;
     Dwarf_Bool     cc_macro_header_length_present;
 
     /*  DW_SECT_RNGLISTS  */
     Dwarf_Unsigned cc_rnglists_base;    /*DW5 */
     Dwarf_Unsigned cc_rnglists_base_contr_size;    /*DW5 */
     /*  DW_AT_GNU_ranges_base was a GNU extension that appeared
         but was unused. See dwarf_die_deliv.c for details. */
     Dwarf_Unsigned cc_ranges_base;
     /*  DW_AT_GNU_ranges_base is a GNU extension, DW4  */
     Dwarf_Bool     cc_ranges_base_present;
     /* .debug_rnglists */
     Dwarf_Bool     cc_rnglists_base_present; /* DW5 */
     Dwarf_Bool     cc_rnglists_header_length_present;
 
     char *         cc_dwo_name;
     /* === END DEBUG FISSION (Split Dwarf) data */
 
     /*  Global section offset to the bytes of the CU die for this CU.
         Set when the CU die is accessed by dwarf_siblingof_b(). */
     Dwarf_Unsigned cc_cu_die_global_sec_offset;
 
     Dwarf_Byte_Ptr   cc_last_abbrev_ptr;
     Dwarf_Byte_Ptr   cc_last_abbrev_endptr;
     Dwarf_Hash_Table cc_abbrev_hash_table;
     Dwarf_Unsigned   cc_highest_known_code;
     Dwarf_CU_Context cc_next;
 
     Dwarf_Bool cc_is_info;    /* TRUE means context is
         in debug_info, FALSE means is in debug_types.
         FALSE only possible for DWARF4 .debug_types
         section CUs.
         For DWARF5 all DIEs are in .debug_info[.dwo] */
 
     Dwarf_Half cc_unit_type; /* DWARF5
         Set from header as a DW_UT_ value.
         For DWARF 2,3,4 this is filled in initially
         from the CU header and refined by inspecting
         the CU DIE to detect the correct setting. */
 
 };
 
 /*  Consolidates section-specific data in one place.
     Section is an Elf specific term, intended as a general
     term (for non-Elf objects some code must synthesize the
     values somehow).  */
@@ -825,29 +827,6 @@ int _dwarf_get_string_base_attr_value(Dwarf_Debug dbg,
     Dwarf_Unsigned *sbase_out,
     Dwarf_Error *error);
 
-int
-_dwarf_read_str_offsets_header(Dwarf_Debug dbg,
-    Dwarf_Small*     table_start_ptr,
-    Dwarf_Unsigned   secsize,
-    Dwarf_Small*     secendptr,
-    Dwarf_CU_Context cucontext,
-    /* Followed by return values/error */
-    Dwarf_Unsigned *length,
-    Dwarf_Half    *offset_size_out,
-    Dwarf_Half    *extension_size_out,
-    Dwarf_Half    *version_out,
-    Dwarf_Half    *padding_out,
-    Dwarf_Unsigned * header_length_out,
-    Dwarf_Error *error);
-
-int _dwarf_extract_string_offset_via_str_offsets(Dwarf_Debug dbg,
-    Dwarf_Small *data_ptr,
-    Dwarf_Small *end_data_ptr,
-    Dwarf_Half   attrform,
-    Dwarf_CU_Context cu_context,
-    Dwarf_Unsigned *str_sect_offset_out,
-    Dwarf_Error *error);
-
 int _dwarf_look_in_local_and_tied_by_index(
     Dwarf_Debug dbg,
     Dwarf_CU_Context context,
diff --git a/src/lib/libdwarf/dwarf_query.c b/src/lib/libdwarf/dwarf_query.c
index 91b00ee3..520a5c1b 100644
--- a/src/lib/libdwarf/dwarf_query.c
+++ b/src/lib/libdwarf/dwarf_query.c
@@ -1187,71 +1187,83 @@ int
 _dwarf_merge_all_base_attrs_of_cu_die(Dwarf_Debug dbg,
     Dwarf_CU_Context context,
     Dwarf_Debug tieddbg,
     Dwarf_CU_Context *tiedcontext_out,
     Dwarf_Error *error)
 {
     Dwarf_CU_Context tiedcontext = 0;
     int res = 0;
 
     if (!tieddbg) {
         return DW_DLV_NO_ENTRY;
     }
     if (!context->cc_signature_present) {
         return DW_DLV_NO_ENTRY;
     }
     res = _dwarf_search_for_signature(tieddbg,
         context->cc_signature,
         &tiedcontext,
         error);
     if ( res == DW_DLV_ERROR) {
         /* Associate the error with dbg, not tieddbg */
         _dwarf_error_mv_s_to_t(tieddbg,error,dbg,error);
         return res;
     }
     if ( res == DW_DLV_NO_ENTRY) {
         return res;
     }
     if (!context->cc_low_pc_present) {
         context->cc_low_pc_present =
             tiedcontext->cc_low_pc_present;
         context->        cc_low_pc=
             tiedcontext->cc_low_pc;
     }
     if (!context->cc_addr_base_present) {
         context->        cc_addr_base_present =
             tiedcontext->cc_addr_base_present;
         context->        cc_addr_base=
             tiedcontext->cc_addr_base;
     }
     if (!context->cc_rnglists_base_present) {
         context->        cc_rnglists_base_present =
             tiedcontext->cc_rnglists_base_present;
         context->        cc_rnglists_base=
             tiedcontext->cc_rnglists_base;
     }
     if (!context->cc_loclists_base_present) {
         context->        cc_loclists_base_present =
             tiedcontext->cc_loclists_base_present;
         context->        cc_loclists_base=
             tiedcontext->cc_loclists_base;
     }
-    if (!context->cc_str_offsets_base_present) {
-        context->        cc_str_offsets_base_present =
-            tiedcontext->cc_str_offsets_base_present;
-        context->        cc_str_offsets_base=
-            tiedcontext->cc_str_offsets_base;
+    if (!context->cc_str_offsets_tab_present) {
+        context->        cc_str_offsets_tab_present =
+            tiedcontext->cc_str_offsets_tab_present;
+        context->        cc_str_offsets_header_offset=
+            tiedcontext->cc_str_offsets_header_offset;
+    }
+    if (!context->cc_str_offsets_tab_to_array_present) {
+        context->        cc_str_offsets_tab_to_array_present =
+            tiedcontext->cc_str_offsets_tab_to_array_present;
+        context->        cc_str_offsets_tab_to_array=
+            tiedcontext->cc_str_offsets_tab_to_array;
+        context->        cc_str_offsets_table_size=
+            tiedcontext->cc_str_offsets_table_size;
+        context->        cc_str_offsets_version=
+            tiedcontext->cc_str_offsets_version;
+        context->        cc_str_offsets_offset_size=
+            tiedcontext->cc_str_offsets_offset_size;
     }
 
     /* GNU DW4 extension. */
     if (!context->        cc_ranges_base_present) {
         context->        cc_ranges_base_present =
             tiedcontext->cc_ranges_base_present;
         context->        cc_ranges_base =
             tiedcontext->cc_ranges_base;
     }
 
     if (tiedcontext_out) {
         *tiedcontext_out = tiedcontext;
     }
     return DW_DLV_OK;
 }
@@ -1260,28 +1272,28 @@ int
 _dwarf_get_string_base_attr_value(Dwarf_Debug dbg,
     Dwarf_CU_Context context,
     Dwarf_Unsigned *sbase_out,
     Dwarf_Error *error)
 {
     (void)dbg;
     (void)error;
-    if (context->cc_str_offsets_base_present) {
-        *sbase_out = context->cc_str_offsets_base;
+    if (context->cc_str_offsets_tab_present) {
+        *sbase_out = context->cc_str_offsets_header_offset;
         return DW_DLV_OK;
     }
     *sbase_out = 0;
     return DW_DLV_OK;
 }
 /*  Goes to the CU die and finds the DW_AT_GNU_addr_base
     (or DW_AT_addr_base ) and gets the value from that CU die
     and returns it through abase_out. If we cannot find the value
     it is a serious error in the DWARF.
     */
 
 /*  This works for all versions of DWARF.
     The consumer has to check the return_form or
     return_class to decide if the value returned
     through return_value is an address or an address-offset.
 
     See  DWARF4 section 2.17.2,
     "Contiguous Address Range".
     */
diff --git a/src/lib/libdwarf/dwarf_str_offsets.c b/src/lib/libdwarf/dwarf_str_offsets.c
index 30c11241..d65eb171 100644
--- a/src/lib/libdwarf/dwarf_str_offsets.c
+++ b/src/lib/libdwarf/dwarf_str_offsets.c
@@ -1,67 +1,68 @@
 /*
     Copyright (C) 2018-2020 David Anderson. All Rights Reserved.
 
     This program is free software; you can redistribute it
     and/or modify it under the terms of version 2.1 of the
     GNU Lesser General Public License as published by the
     Free Software Foundation.
 
     This program is distributed in the hope that it would
     be useful, but WITHOUT ANY WARRANTY; without even the
     implied warranty of MERCHANTABILITY or FITNESS FOR A
     PARTICULAR PURPOSE.
 
     Further, this software is distributed without any warranty
     that it is free of the rightful claim of any third person
     regarding infringement or the like.  Any license provided
     herein, whether implied or otherwise, applies only to
     this software file.  Patent licenses, if any, provided
     herein do not apply to combinations of this program with
     other software, or any other product whatsoever.
 
     You should have received a copy of the GNU Lesser General
     Public License along with this program; if not, write
     the Free Software Foundation, Inc., 51 Franklin Street -
     Fifth Floor, Boston MA 02110-1301, USA.
 */
 
 #include <config.h>
 
 #include <stddef.h> /* NULL size_t */
 #ifdef HAVE_STDINT_H
 #include <stdint.h> /* uintptr_t */
 #endif /* HAVE_STDINT_H */
 
 #if defined(_WIN32) && defined(HAVE_STDAFX_H)
 #include "stdafx.h"
 #endif /* HAVE_STDAFX_H */
+#include <stdio.h> /* printf */
 
 #include "dwarf.h"
 #include "libdwarf.h"
 #include "libdwarf_private.h"
 #include "dwarf_base_types.h"
 #include "dwarf_opaque.h"
 #include "dwarf_alloc.h"
 #include "dwarf_error.h"
 #include "dwarf_util.h"
 #include "dwarf_string.h"
 #include "dwarf_str_offsets.h"
 
 #define STR_OFFSETS_MAGIC 0x2feed2
 
 #define VALIDATE_SOT(xsot)                                \
     if (!(xsot)) {                                          \
         _dwarf_error(NULL,error,DW_DLE_STR_OFFSETS_NULLARGUMENT);\
         return DW_DLV_ERROR;                              \
     }                                                     \
     if (!(xsot)->so_dbg) {                                \
         _dwarf_error(NULL,error,DW_DLE_STR_OFFSETS_NULL_DBG);\
         return DW_DLV_ERROR;                              \
     }                                                     \
     if ((xsot)->so_magic_value !=  STR_OFFSETS_MAGIC) {   \
         _dwarf_error((xsot)->so_dbg,error,                \
         DW_DLE_STR_OFFSETS_NO_MAGIC);                     \
         return DW_DLV_ERROR;                              \
     }
 
 #if 0
@@ -69,12 +70,12 @@ static void
 dump_bytes(char * msg,Dwarf_Small * start, long len)
 {
     Dwarf_Small *end = start + len;
     Dwarf_Small *cur = start;
 
-    printf("%s ",msg);
+    printf("%s starting at %p \n",msg,(void*)start);
     for (; cur < end; cur++) {
         printf("%02x ", *cur);
     }
     printf("\n");
 }
 #endif /*0*/
@@ -146,38 +147,66 @@ int
 dwarf_str_offsets_value_by_index(Dwarf_Str_Offsets_Table sot,
     Dwarf_Unsigned index,
     Dwarf_Unsigned *stroffset,
     Dwarf_Error *error)
 {
     Dwarf_Small *entryptr = 0;
     Dwarf_Unsigned val = 0;
+    Dwarf_Unsigned entryoffset = 0;
+    Dwarf_Unsigned secsize = 0;
+    Dwarf_Debug dbg = 0;
+    Dwarf_Small *end_ptr = 0;
+/* so_section_size */
 
     VALIDATE_SOT(sot)
+    dbg = sot->so_dbg;
+    secsize = dbg->de_debug_str_offsets.dss_size;
     if (index >= sot->so_array_entry_count) {
-        _dwarf_error(sot->so_dbg,error,
-            DW_DLE_STR_OFFSETS_ARRAY_INDEX_WRONG);
+        return DW_DLV_NO_ENTRY;
+    }
+    entryoffset = sot->so_table_start_offset +
+      sot->so_lcl_offset_to_array;
+    entryoffset += index*sot->so_array_entry_size;
+    entryptr = sot->so_section_start_ptr + entryoffset;
+#if 0
+if (index < 3) {
+    dump_bytes("dadebug bytes to read ",(Dwarf_Small*)entryptr,16);
+}
+printf("dadebug array entry count %llu line %d\n",sot->so_array_entry_count,__LINE__);
+printf("dadebug index %llu line %d\n",index,__LINE__);
+printf("dadebug section_size %llu \n",sot->so_section_size);
+printf("dadebug read at entryoffset 0x%llx line %d\n",entryoffset,__LINE__);
+printf("dadebug rd size  %d line %d\n",sot->so_array_entry_size ,__LINE__);
+fflush(stdout);
+#endif
+    if (entryoffset > secsize ||
+        (entryoffset+sot->so_array_entry_size) > secsize) {
+        _dwarf_error_string(dbg,error,
+            DW_DLE_STR_OFFSETS_ARRAY_INDEX_WRONG,
+            "DW_DLE_STR_OFFSETS_ARRAY_INDEX_WRONG: "
+            "A libdwarf internal bug. Report to the maintainers");
         return DW_DLV_ERROR;
     }
-    entryptr = sot->so_array_ptr + (index * sot->so_array_entry_size);
-    READ_UNALIGNED_CK(sot->so_dbg, val, Dwarf_Unsigned,
-        entryptr, sot->so_array_entry_size,error,sot->so_end_cu_ptr);
+    end_ptr = entryptr+sot->so_array_entry_size;
+    READ_UNALIGNED_CK(dbg, val, Dwarf_Unsigned,
+        entryptr, sot->so_array_entry_size,error,end_ptr);
     *stroffset = val;
     return DW_DLV_OK;
 }
 
 /* The minimum possible area .debug_str_offsets header . */
 #define MIN_HEADER_LENGTH  8
 
 /*  New April 2018.
     Beginning at starting_offset zero,
     returns data about the first table found.
     The value *next_table_offset is the value
     of the next table (if any), one byte past
     the end of the table whose data is returned..
     Returns DW_DLV_NO_ENTRY if the starting offset
     is past the end of valid data.
 
     There is no guarantee that there are no non-0 nonsense
     bytes in the section outside of useful tables,
     so this can fail and return nonsense or
     DW_DLV_ERROR  if such garbage exists.
 */
@@ -201,222 +230,287 @@ is_all_zeroes(Dwarf_Small*start,
     return TRUE;
 }
 
+static void
+emit_invalid_dw5tab(Dwarf_Debug dbg,
+    Dwarf_Unsigned headerlen,
+    Dwarf_Error *error)
+{
+    dwarfstring m;
+
+    dwarfstring_constructor(&m);
+    dwarfstring_append_printf_u(&m,
+        "DW_DLE_SECTION_SIZE_ERROR: "
+        "header length 0x%x is too small "
+        "to be a real .debug_str_offsets "
+        "DWARF5 section",
+        headerlen);
+    _dwarf_error_string(dbg,error,
+        DW_DLE_SECTION_SIZE_ERROR,
+        dwarfstring_string(&m));
+    dwarfstring_destructor(&m);
+}
+static void
+emit_offsets_array_msg(Dwarf_Debug dbg,
+    Dwarf_Unsigned tab_length,
+    Dwarf_Unsigned secsize,
+    Dwarf_Error *error)
+{
+    dwarfstring m;
+
+    dwarfstring_constructor(&m);
+    dwarfstring_append_printf_u(&m,
+        "DW_DLE_STR_OFFSETS_ARRAY_SIZE: "
+        " total length 0x%x  with table offset larger than ",
+        tab_length);
+    dwarfstring_append_printf_u(&m, 
+        ".debug_str_offsets section size of 0x%x."
+        " Perhaps the section is a GNU DWARF4"
+        " extension with a different format.",
+        secsize);
+    _dwarf_error_string(dbg,error,
+        DW_DLE_STR_OFFSETS_ARRAY_SIZE,
+        dwarfstring_string(&m));
+    dwarfstring_destructor(&m);
+}
+
+static void
+emit_wrong_version(Dwarf_Debug dbg,
+    Dwarf_Half version,
+    Dwarf_Error *error)
+{
+    dwarfstring m;
+
+    dwarfstring_constructor(&m);
+    dwarfstring_append_printf_u(&m,
+        "DW_DLE_STR_OFFSETS_VERSION_WRONG: "
+        "%u. Only version 5 is supported "
+        "when reading .debug_str_offsets."
+        " Perhaps the section is a GNU DWARF4"
+        " extension with a different format.",
+        version);
+    _dwarf_error_string(dbg,error,
+        DW_DLE_STR_OFFSETS_VERSION_WRONG,
+        dwarfstring_string(&m));
+    dwarfstring_destructor(&m);
+}
+
 int
 _dwarf_trial_read_dwarf_five_hdr(Dwarf_Debug dbg,
-    Dwarf_Small *table_start_ptr,
-    Dwarf_Unsigned secsize,
-    Dwarf_Small * secendptr,
+    Dwarf_Unsigned  new_table_offset,
+    Dwarf_Unsigned  secsize,
+    Dwarf_Unsigned *table_local_offset_of_array, 
+    Dwarf_Unsigned *total_table_length, 
     Dwarf_Unsigned *length_out,
-    Dwarf_Half *local_offset_size_out,
-    Dwarf_Half *local_extension_size_out,
-    Dwarf_Half *version_out,
-    Dwarf_Half *padding_out,
-    Dwarf_Error *error)
+    Dwarf_Half     *local_offset_size_out,
+    Dwarf_Half     *local_extension_size_out,
+    Dwarf_Half     *version_out,
+    Dwarf_Half     *padding_out,
+    Dwarf_Error    *error)
 {
     Dwarf_Unsigned length = 0; /* length following the
         local_offset_size + local_extension_size */
     Dwarf_Unsigned local_offset_size = 0;
     Dwarf_Unsigned local_extension_size = 0;
-    Dwarf_Half version = 0;
-    Dwarf_Half padding = 0;
+    Dwarf_Unsigned tab_length = 0;
+    Dwarf_Unsigned array_local_offset = 0;;
+    Dwarf_Half     version = 0;
+    Dwarf_Half     padding = 0;
+    Dwarf_Unsigned globloff = 0;
+    Dwarf_Unsigned net_new_len = 0;
+    Dwarf_Unsigned net_end_offset = 0;
+    Dwarf_Unsigned globl_array_off = 0;
+    Dwarf_Small   *secstart = dbg->de_debug_str_offsets.dss_data;
+    Dwarf_Unsigned secize = dbg->de_debug_str_offsets.dss_size;
+    Dwarf_Small   *table_start_ptr = secstart + new_table_offset; 
+    Dwarf_Small   *secendptr = secstart+secsize;
 
     READ_AREA_LENGTH_CK(dbg,length,Dwarf_Unsigned,
         table_start_ptr,local_offset_size,
         local_extension_size,error,
         secsize,secendptr);
     /*  The 'length' part of any header is
         local_extension_size + local_offset_size.
         The length of an offset in the section is just
         local_offset_size.
         Standard DWARF2 sums to 4.
         Standard DWARF3,4,5 sums to 4 or 12.
         Nonstandard SGI IRIX 64bit dwarf sums to 8 (SGI IRIX
         was all DWARF2 and could not have a .debug_str_offsets
         section).
         The header includes 2 bytes of version and two bytes
         of padding. */
     if (length < 4) {
         /*  Usually DW4-style .debug_str_offsets
             starts off with a zero value to ref the
-            base string in .debug_str.
+            base string in .debug_str. Should not apply here.
             Any tiny value is guaranteed not to be a legal
             DWARF5 .debug_str_offsets section. */
-        dwarfstring m;
-
-        dwarfstring_constructor(&m);
-        dwarfstring_append_printf_u(&m,
-            "DW_DLE_SECTION_SIZE_ERROR: "
-            "header length 0x%x is too small "
-            "to be a real .debug_str_offsets "
-            "DWARF5 section",
-            length);
-        _dwarf_error_string(dbg,error,
-            DW_DLE_SECTION_SIZE_ERROR,
-            dwarfstring_string(&m));
-        dwarfstring_destructor(&m);
+        emit_invalid_dw5tab(dbg,length,error);
         return DW_DLV_ERROR;
-
     }
-    if (length > secsize  ||
-        (length+local_extension_size +local_offset_size) >
-        secsize) {
-        dwarfstring m;
+    globloff = new_table_offset;
+    array_local_offset = local_extension_size +local_offset_size
+        +4; /* 4 for the two Dwarf_Half in the table header */
+    tab_length = local_extension_size +local_offset_size +
+        length;
+    
+    net_end_offset = tab_length+globloff;
 
-        dwarfstring_constructor(&m);
-        dwarfstring_append_printf_u(&m,
-            "DW_DLE_STR_OFFSETS_ARRAY_SIZE: "
-            " header length 0x%x is bigger than ",
-            length);
-        dwarfstring_append_printf_u(&m,
-            ".debug_str_offsets section size of 0x%x."
-            " Perhaps the section is a GNU DWARF4"
-            " extension with a different format.",
-            secsize);
-        _dwarf_error_string(dbg,error,
-            DW_DLE_STR_OFFSETS_ARRAY_SIZE,
-            dwarfstring_string(&m));
-        dwarfstring_destructor(&m);
+    if (length > secsize  ||
+        array_local_offset > secsize ||
+        tab_length > secsize ||  
+        net_end_offset > secsize) {
+        emit_offsets_array_msg(dbg,tab_length,
+           secsize,error);
         return DW_DLV_ERROR;
     }
-    /*  table_start_ptr was incremented past
-        the length data. */
+    /*  table_start_ptr is incremented past
+        the length data by read-area-length-ck. */
     READ_UNALIGNED_CK(dbg, version, Dwarf_Half,
         table_start_ptr, DWARF_HALF_SIZE,
         error,secendptr);
     table_start_ptr += DWARF_HALF_SIZE;
     if (version != DW_STR_OFFSETS_VERSION5) {
-        dwarfstring m;
-
-        dwarfstring_constructor(&m);
-        dwarfstring_append_printf_u(&m,
-            "DW_DLE_STR_OFFSETS_VERSION_WRONG: "
-            "%u. Only version 5 is supported "
-            "when reading .debug_str_offsets."
-            " Perhaps the section is a GNU DWARF4"
-            " extension with a different format.",
-            version);
-        _dwarf_error_string(dbg,error,
-            DW_DLE_STR_OFFSETS_VERSION_WRONG,
-            dwarfstring_string(&m));
-        dwarfstring_destructor(&m);
+        emit_wrong_version(dbg,version,error);
         return DW_DLV_ERROR;
     }
     READ_UNALIGNED_CK(dbg, padding, Dwarf_Half,
         table_start_ptr, DWARF_HALF_SIZE,
         error,secendptr);
+
     /*  padding should be zero, but we are
         not checking it here at present. */
+    *table_local_offset_of_array = array_local_offset;
+    *total_table_length = tab_length;
     *length_out = length;
     *local_offset_size_out = local_offset_size;
     *local_extension_size_out = local_extension_size;
     *version_out = version;
     *padding_out = padding;
     return DW_DLV_OK;
 }
 
 /*  Used by code reading attributes/forms and
     also by code reading the raw .debug_str_offsets
     section, hence the code allows for
     output arguments to be zero.
     If cucontext is null it means the call part
     of trying to print the section without
     accessing any context. dwarfdump option
     --print-str-offsets.
     New 30 August 2020. */
 int
-_dwarf_read_str_offsets_header(Dwarf_Debug dbg,
+_dwarf_read_str_offsets_header(Dwarf_Str_Offsets_Table sot,
     Dwarf_Small*    table_start_ptr,
-    Dwarf_Unsigned secsize,
-    Dwarf_Small*    secendptr,
-    Dwarf_CU_Context  cucontext,
+    Dwarf_CU_Context cucontext,
     /* Followed by return values/error */
     Dwarf_Unsigned *length_out,
     Dwarf_Half     *offset_size_out,
     Dwarf_Half     *extension_size_out,
     Dwarf_Half     *version_out,
     Dwarf_Half     *padding_out,
-    Dwarf_Unsigned *header_length_out,
+    Dwarf_Unsigned *local_offset_to_array_out,
+    Dwarf_Unsigned *total_table_length_out,
     Dwarf_Error *error)
 {
     Dwarf_Unsigned length            = 0;
     Dwarf_Half local_offset_size = 0;
     Dwarf_Half local_extension_size = 0;
     Dwarf_Half version               = 0;
     Dwarf_Half padding               = 0;
     Dwarf_Unsigned headerlength      = 0;
-    int res = 0;
-    Dwarf_Bool is_dwarf_five = TRUE;
+    int            res = 0;
+    Dwarf_Bool     is_dwarf_five = TRUE;
+    Dwarf_Debug    dbg = sot->so_dbg;
+    Dwarf_Unsigned secsize  = sot->so_section_size;
+    Dwarf_Small   *secendptr =   sot->so_section_end_ptr;
+    Dwarf_Unsigned global_array_off = 0;
+    Dwarf_Unsigned table_local_offset_of_array = 0;
+    Dwarf_Unsigned total_table_length = 0;
+    Dwarf_Unsigned globaltaboff = 0;
+
 
+#if 0
+printf("dadebug read_str_offsets_header cucontext? %s line %d\n",cucontext?"yes":"no",__LINE__);
+#endif
+    globaltaboff = sot->so_next_table_offset;
     if (cucontext) {
-        if (cucontext->cc_str_offsets_header_length_present) {
+        if (cucontext->cc_str_offsets_tab_to_array_present) {
             /*  cu_context has what it needs already and we do
                 not need the rest of what the interface
                 provides */
             return DW_DLV_OK;
         }
     }
-    {
-        res = _dwarf_trial_read_dwarf_five_hdr(dbg,
-            table_start_ptr,secsize, secendptr,
-            &length,
-            &local_offset_size,
-            &local_extension_size,
-            &version,
-            &padding,
-            error);
-        if (res != DW_DLV_OK) {
-            if (res == DW_DLV_ERROR && error) {
-                dwarf_dealloc_error(dbg,*error);
-                *error = 0;
-            }
-            /*  If it's really DWARF5 but with a serious
-                problem  this will think...NOT 5! */
-            is_dwarf_five = FALSE;
+    res = _dwarf_trial_read_dwarf_five_hdr(dbg,
+        globaltaboff,
+        secsize,
+        &table_local_offset_of_array,
+        &total_table_length,
+        /* Length is the length field from the table involved */
+        &length,
+        &local_offset_size,
+        &local_extension_size,
+        &version,
+        &padding,
+        error);
+    if (res != DW_DLV_OK) {
+        if (res == DW_DLV_ERROR && error) {
+            dwarf_dealloc_error(dbg,*error);
+            *error = 0;
         }
+        /*  If it's really DWARF5 but with a serious
+            problem  this will think...NOT 5! */
+        is_dwarf_five = FALSE;
     }
     if ( !is_dwarf_five) {
         length = secsize;
-        /*  This is likely
-            GNU Dwarf4 extension .debug_str_offsets,
-            and offset size is not going to be 8
-            de_length_size is most likely a guess
-            and not set properly at this point */
+        /*  This is possibly
+            GNU Dwarf4 extension .debug_str_offsets.
+            It could also just be corrupted data.
+            offset size is not going to be 8.
+            de_length_size is a guess and not set at this point .
+            We assume the data starts with the array of string offsets,
+            and all in one table. */
+        table_local_offset_of_array = 0;
+        total_table_length = secsize; 
+        length = secsize;
         local_offset_size = 4;
         local_extension_size = 0;
         version = DW_STR_OFFSETS_VERSION4;
         padding = 0;
     }
 
     if (length_out) {
         *length_out = length;
     }
     if (offset_size_out) {
         *offset_size_out = local_offset_size;
     }
     if (extension_size_out) {
         *extension_size_out = local_extension_size;
     }
     if (version_out) {
         *version_out = version;
     }
     if (padding_out) {
         *padding_out = padding;
     }
-    if (is_dwarf_five) {
-        headerlength =  local_offset_size +
-            local_extension_size +
-            2*DWARF_HALF_SIZE;
-    } else { /* DWARF4 */
-        headerlength = 0;
+    if (cucontext) {
+        cucontext->cc_str_offsets_header_offset         = globaltaboff;
+        cucontext->cc_str_offsets_tab_present = TRUE;
+        cucontext->cc_str_offsets_tab_to_array = 
+            table_local_offset_of_array;
+        cucontext->cc_str_offsets_tab_to_array_present = TRUE;
+        cucontext->cc_str_offsets_offset_size  = local_offset_size;
+        cucontext->cc_str_offsets_table_size   = total_table_length;
+        cucontext->cc_str_offsets_version   = version;
     }
-    if (header_length_out) {
-        *header_length_out  = headerlength;
+    if (local_offset_to_array_out) {
+        *local_offset_to_array_out = table_local_offset_of_array;
     }
-
-    if (cucontext) {
-        cucontext->cc_str_offsets_header_length_present = TRUE;
-        cucontext->cc_str_offsets_header_length = headerlength;
-        cucontext->cc_str_offsets_offset_size = local_offset_size;
+    if (total_table_length_out) {
+        *total_table_length_out = total_table_length;
     }
     return DW_DLV_OK;
 }
@@ -425,173 +519,211 @@ int
 dwarf_next_str_offsets_table(Dwarf_Str_Offsets_Table sot,
     Dwarf_Unsigned *unit_length_out,
     Dwarf_Unsigned *unit_length_offset_out,
     Dwarf_Unsigned *table_start_offset_out,
     Dwarf_Half     *entry_size_out,
     Dwarf_Half     *version_out,
     Dwarf_Half     *padding_out,
     Dwarf_Unsigned *table_value_count_out,
     Dwarf_Error    * error)
 {
 
     Dwarf_Small *table_header_ptr = 0;
     Dwarf_Small *array_start_ptr = 0;
     Dwarf_Small *table_end_ptr   = 0;
     Dwarf_Unsigned table_header_offset  = 0;
     Dwarf_Unsigned table_end_offset   = 0;
     Dwarf_Unsigned array_start_offset = 0;
     Dwarf_Unsigned length        = 0;
     Dwarf_Half local_length_size = 0;
     Dwarf_Half local_extension_size = 0;
     Dwarf_Half version           = 0;
     Dwarf_Half padding           = 0;
+    Dwarf_Unsigned local_offset_to_array= 0;
+    Dwarf_Unsigned  total_table_length = 0;
     Dwarf_Unsigned header_length = 0;
+    Dwarf_Debug dbg = sot->so_dbg;
     int res = 0;
 
     VALIDATE_SOT(sot)
 
     table_header_offset = sot->so_next_table_offset;
     if (table_header_offset >= sot->so_section_size) {
         return DW_DLV_NO_ENTRY;
     }
     table_header_ptr = sot->so_section_start_ptr +
         table_header_offset;
-    sot->so_header_ptr = table_header_ptr;
-    if (table_header_ptr >= sot->so_section_end_ptr) {
+    if (table_header_offset >= sot->so_section_size) {
         if (table_header_ptr == sot->so_section_end_ptr) {
             /* At end of section. Done. */
             return DW_DLV_NO_ENTRY;
         } else {
             /* bogus table offset. */
             Dwarf_Unsigned len = 0;
             dwarfstring m;
 
             len = (sot->so_section_end_ptr >= table_header_ptr)?
                 (Dwarf_Unsigned)(uintptr_t)sot->so_section_end_ptr -
                 (Dwarf_Unsigned)(uintptr_t)table_header_ptr:
                 (Dwarf_Unsigned)0xffffffff;
             dwarfstring_constructor(&m);
             dwarfstring_append_printf_i(&m,
                 "DW_DLE_STR_OFFSETS_EXTRA_BYTES: "
                 "Table Offset is %"   DW_PR_DSd
                 " bytes past end of section",len);
             _dwarf_error_string(sot->so_dbg,error,
                 DW_DLE_STR_OFFSETS_EXTRA_BYTES,
                 dwarfstring_string(&m));
             dwarfstring_destructor(&m);
         }
     }
 
     if ((table_header_ptr + MIN_HEADER_LENGTH) >
         sot->so_section_end_ptr) {
 
         /*  We have a too-short section it appears.
             Should we generate error? Or ignore?
             As of March 10 2020 we check for garbage
             bytes in-section. */
         dwarfstring m;
         Dwarf_Small *hend = 0;
         Dwarf_Unsigned len = 0;
 
         if (is_all_zeroes(table_header_ptr,sot->so_section_end_ptr)){
             return DW_DLV_NO_ENTRY;
         }
         hend = table_header_ptr + MIN_HEADER_LENGTH;
         len = (hend >= sot->so_section_end_ptr)?
             (Dwarf_Unsigned)(uintptr_t)sot->so_section_end_ptr -
             (Dwarf_Unsigned)(uintptr_t)table_header_ptr:
             (Dwarf_Unsigned)0xffffffff;
         dwarfstring_constructor(&m);
         dwarfstring_append_printf_i(&m,
             "DW_DLE_STR_OFFSETS_EXTRA_BYTES: "
             "Table Offset plus a minimal header is %"
             DW_PR_DSd
             " bytes past end of section"
             " and some bytes in-section are non-zero",len);
         _dwarf_error_string(sot->so_dbg,error,
             DW_DLE_STR_OFFSETS_EXTRA_BYTES,
             dwarfstring_string(&m));
         dwarfstring_destructor(&m);
         return DW_DLV_ERROR;
     }
-    res = _dwarf_read_str_offsets_header(sot->so_dbg,
-        table_header_ptr,sot->so_section_size,
-        sot->so_section_end_ptr,
+
+    res = _dwarf_read_str_offsets_header(sot,
+        table_header_ptr,
         0,
         &length,
         &local_length_size,
         &local_extension_size,
         &version,
         &padding,
-        &header_length, error);
+        &local_offset_to_array,
+        &total_table_length, error);
     if (res != DW_DLV_OK) {
         return res;
     }
     if (version == DW_STR_OFFSETS_VERSION5) {
-        array_start_ptr = table_header_ptr + header_length;
-        array_start_offset = table_header_offset +header_length;
-        table_end_ptr = table_header_ptr +
-            local_length_size +local_extension_size +
-            length;
-        table_end_offset = table_header_offset +
-            local_length_size +local_extension_size +
-            +length;
+        /*  header_length includes length field plus 4 for
+            the rest of the header. Don't double count!
+            length includes space for 4 bytes of the header!  */
+        array_start_ptr = table_header_ptr + local_offset_to_array;;
+        array_start_offset = table_header_offset +local_offset_to_array;
+        table_end_ptr = array_start_ptr + total_table_length;
+        table_end_offset = array_start_offset + total_table_length;
+#if 0
+printf("dadebug DWARF5 %u line %d\n",version,__LINE__);
+printf("dadebug header_length %llu line %d\n",header_length,__LINE__);
+printf("dadebug array start offset 0x%llx line %d\n",array_start_offset,__LINE__);
+printf("dadebug table end offset offset 0x%llx line %d\n",table_end_offset,__LINE__);
+printf("dadebug array start ptr %p line %d\n",(void*)array_start_ptr,__LINE__);
+printf("dadebug table end   ptr %p line %d\n",(void*)table_end_ptr,__LINE__);
+fflush(stdout);
+#endif
     } else {
-        array_start_ptr = table_header_ptr;
+        Dwarf_Unsigned space_left = 0;
+
+        /* leave table header offset as-is */
+        space_left = sot->so_section_size - table_header_offset;
+        array_start_ptr =    table_header_ptr;
         array_start_offset = table_header_offset;
-        table_end_ptr = table_header_ptr +
-            sot->so_section_size;
-        table_end_offset = table_header_offset +
-            sot->so_section_size;
+        table_end_ptr =    array_start_ptr + space_left;
+        table_end_offset = table_header_offset + space_left;
+#if 0
+printf("dadebug DWARF4 %u line %d\n",version,__LINE__);
+printf("dadebug array start offset 0x%llx line %d\n",array_start_offset,__LINE__);
+printf("dadebug table end offset offset 0x%llx line %d\n",table_end_offset,__LINE__);
+printf("dadebug array start ptr %p line %d\n",(void*)array_start_ptr,__LINE__);
+printf("dadebug table end   ptr %p line %d\n",(void*)table_end_ptr,__LINE__);
+fflush(stdout);
+#endif
     }
     /*  So now table_start_ptr points to a table of local_length_size
         entries.
         Each entry in this table is local_length_size bytes
         long: 4 or 8. */
     {
         Dwarf_Unsigned entrycount = 0;
         Dwarf_Unsigned entrybytes = 0;
 
         entrybytes = table_end_offset - array_start_offset;
+#if 0
+printf("dadebug entrybytes %llu line %d\n",entrybytes,__LINE__);
+fflush(stdout);
+#endif
         if (entrybytes % local_length_size) {
-            _dwarf_error(sot->so_dbg,error,
-                DW_DLE_STR_OFFSETS_ARRAY_SIZE);
+            _dwarf_error_string(sot->so_dbg,error,
+                DW_DLE_STR_OFFSETS_ARRAY_SIZE,
+                "DW_DLE_STR_OFFSETS_ARRAY_SIZE "
+                " array size not a multiple of the size of "
+                "a single entry");
             return DW_DLV_ERROR;
         }
         entrycount = entrybytes/local_length_size;
+
+        /* On the next table loop this will be the new table offset */
         sot->so_next_table_offset = table_end_offset;
 
-        sot->so_end_cu_ptr =  table_end_ptr;
+        sot->so_table_end_offset = table_end_offset; 
         sot->so_table_start_offset = table_header_offset;
-        sot->so_array_ptr  = array_start_ptr;
-        sot->so_array_start_offset = array_start_offset;
+        sot->so_table_end_offset = table_header_offset+
+            total_table_length;
         sot->so_array_entry_count = entrycount;
         sot->so_array_entry_size = local_length_size;
+#if 0
+printf("dadebug entrycount %llu line %d\n",entrycount,__LINE__);
+printf("dadebug array entry size %d line %d\n",local_length_size,__LINE__);
+printf("dadebug table_end_offset %llu line %d\n",table_end_offset,__LINE__);
+fflush(stdout);
+#endif
+
         sot->so_table_count += 1;
 
         /*  The data length  in bytes following the unit_length field
-            of the header. */
+            of the header. includes any other header bytes
+            and the table space */
         *unit_length_out = length;
 
         /*  Where the unit_length field starts in the section. */
         *unit_length_offset_out = sot->so_table_start_offset;
 
         /*  Where the table of offsets starts in the section. */
-        *table_start_offset_out = sot->so_array_start_offset;
+        *table_start_offset_out = sot->so_table_start_offset;
 
         /*   Entrysize: 4 or 8 */
         *entry_size_out  = local_length_size;
 
         /*   Version is 5. */
         *version_out  = version;
 
         /*   This is supposed to be zero. */
         *padding_out  = padding;
 
         /*  How many entry_size entries are in the array. */
         *table_value_count_out = entrycount;
         return DW_DLV_OK;
     }
 }
 
 /*  Meant to be called after all tables accessed using
     dwarf_next_str_offsets_table(). */
diff --git a/src/lib/libdwarf/dwarf_str_offsets.h b/src/lib/libdwarf/dwarf_str_offsets.h
index 0ee2ea28..774f99cf 100644
--- a/src/lib/libdwarf/dwarf_str_offsets.h
+++ b/src/lib/libdwarf/dwarf_str_offsets.h
@@ -1,30 +1,29 @@
 #ifndef DWARF_STR_OFFSETS_H
 #define DWARF_STR_OFFSETS_H
 /*
-    Copyright (C) 2018-2018 David Anderson. All Rights Reserved.
 
     This program is free software; you can redistribute it
     and/or modify it under the terms of version 2.1 of
     the GNU Lesser General Public License
     as published by the Free Software Foundation.
 
     This program is distributed in the hope that it would be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 
     Further, this software is distributed without any warranty
     that it is free of the rightful claim of any third person
     regarding infringement or the like.
     Any license provided herein, whether implied or
     otherwise, applies only to this software file.
     Patent licenses, if any, provided herein do not
     apply to combinations of this program with
     other software, or any other product whatsoever.
 
     You should have received a copy of the GNU Lesser General Public
     License along with this program; if not, write the Free Software
     Foundation, Inc., 51 Franklin Street - Fifth Floor,
     Boston MA 02110-1301,
     USA.
 
 */
@@ -32,44 +31,71 @@
 struct  Dwarf_Str_Offsets_Table_s {
     /*  pointers are to dwarf-memory valid till Dwarf_Debug
         is closed..  None are to be deallocated. */
     Dwarf_Unsigned so_magic_value;
     Dwarf_Debug  so_dbg;
 
     /* Section data. */
     Dwarf_Small   *so_section_start_ptr;
     Dwarf_Small   *so_section_end_ptr;
     Dwarf_Unsigned so_section_size;
     /* Overall data about wasted space in the section. */
     Dwarf_Unsigned so_wasted_section_bytes;
     /* The number of tables processed in the section. */
     Dwarf_Unsigned so_table_count;
 
     /*  Used to iterate through the section getting
         to each table */
     Dwarf_Unsigned so_next_table_offset;
 
     /*  Per table (ie, a table is a
-        header and array of offsets) inside the section.  */
-    Dwarf_Small *so_header_ptr;
-    Dwarf_Small *so_end_cu_ptr;
-    Dwarf_Small *so_array_ptr;
+        header and array of offsets) inside the section.  
+        Offset to first byte of a table
+        Offset one past last byte of a table.
+        Offset from first byte of table to its array.
+        Count of entries in the array
+        Size of each enntry in the array. */
     Dwarf_Unsigned so_table_start_offset;
-    Dwarf_Unsigned so_array_start_offset;
+    Dwarf_Unsigned so_table_end_offset;
+    Dwarf_Unsigned so_lcl_offset_to_array;
     Dwarf_Unsigned so_array_entry_count;
     Dwarf_Half     so_array_entry_size;
 
 };
+int _dwarf_extract_string_offset_via_str_offsets(Dwarf_Debug dbg,
+    Dwarf_Small *data_ptr,
+    Dwarf_Small *end_data_ptr,
+    Dwarf_Half   attrform,
+    Dwarf_CU_Context cu_context,
+    Dwarf_Unsigned *str_sect_offset_out,
+    Dwarf_Error *error);
+
+int
+_dwarf_read_str_offsets_header(Dwarf_Str_Offsets_Table sot,
+    Dwarf_Small*     table_start_ptr,
+    Dwarf_CU_Context cucontext,
+    /* Followed by return values/error */
+    Dwarf_Unsigned *length,
+    Dwarf_Half    *offset_size_out,
+    Dwarf_Half    *extension_size_out,
+    Dwarf_Half    *version_out,
+    Dwarf_Half    *padding_out,
+    Dwarf_Unsigned *local_offset_to_array_out,
+    Dwarf_Unsigned *total_table_length_out,
+    Dwarf_Error *error);
 
 int _dwarf_trial_read_dwarf_five_hdr(Dwarf_Debug dbg,
-    Dwarf_Small *table_start_ptr,
-    Dwarf_Unsigned secsize,
-    Dwarf_Small * secendptr,
+    Dwarf_Unsigned  table_start_offset,
+    Dwarf_Unsigned  secsize,
+    Dwarf_Unsigned *table_local_offset_of_array, 
+    Dwarf_Unsigned *total_table_length,
+    /*  length_out is the initial DWARF length value
+        from the table header. */
     Dwarf_Unsigned *length_out,
-    Dwarf_Half *local_offset_size_out,
-    Dwarf_Half *local_extension_size_out,
-    Dwarf_Half *version_out,
-    Dwarf_Half *padding_out,
-    Dwarf_Error *error);
+    Dwarf_Half     *local_offset_size_out,
+    Dwarf_Half     *local_extension_size_out,
+    Dwarf_Half     *version_out,
+    Dwarf_Half     *padding_out,
+    Dwarf_Error    *error);
 int
 _dwarf_find_all_offsets_via_fission(Dwarf_Debug dbg,
     Dwarf_CU_Context cu_context,
