commit bb99fe7ddb2bc6601bcb0ee30ced6a8cc8cb0564
Author: David Anderson <davea42@linuxmail.org>
Date:   Tue Mar 7 16:30:53 2023 -0800

    Related to oss fuzz 56536, some placew where
    READ_AREA_LENGTH values where not fully checked.
    This will require a revisit in a few of these cases
            modified:   src/lib/libdwarf/dwarf_arange.c
            modified:   src/lib/libdwarf/dwarf_debugnames.c
            modified:   src/lib/libdwarf/dwarf_die_deliv.c
            modified:   src/lib/libdwarf/dwarf_frame2.c
            modified:   src/lib/libdwarf/dwarf_global.c
            modified:   src/lib/libdwarf/dwarf_loclists.c
            modified:   src/lib/libdwarf/dwarf_rnglists.c
            modified:   src/lib/libdwarf/dwarf_str_offsets.c

diff --git a/src/lib/libdwarf/dwarf_arange.c b/src/lib/libdwarf/dwarf_arange.c
index 39914310..5e49ba56 100644
--- a/src/lib/libdwarf/dwarf_arange.c
+++ b/src/lib/libdwarf/dwarf_arange.c
@@ -81,318 +81,320 @@ static int
 _dwarf_get_aranges_list(Dwarf_Debug dbg,
     Dwarf_Chain  * chain_out,
     Dwarf_Signed * chain_count_out,
     Dwarf_Error  * error)
 {
     /* Sweeps through the arange. */
     Dwarf_Small *arange_ptr = 0;
     Dwarf_Small *arange_ptr_start = 0;
 
     /*  Start of arange header.
         Used for rounding offset of arange_ptr
         to twice the tuple size.  Libdwarf requirement. */
     Dwarf_Small *header_ptr = 0;
 
     /*  Version of .debug_aranges header. */
     Dwarf_Unsigned version = 0;
 
     /*  Offset of current set of aranges into .debug_info. */
     Dwarf_Off info_offset = 0;
     /*  Size in bytes of addresses in target. */
     Dwarf_Small address_size = 0;
     /*  Size in bytes of segment offsets in target. */
     Dwarf_Small segment_sel_size = 0;
     /*  Count of total number of aranges. */
     Dwarf_Signed arange_count = 0;
     Dwarf_Arange arange = 0;
     Dwarf_Unsigned section_size = 0;
     Dwarf_Byte_Ptr arange_end_section = 0;
     /*  Used to chain Dwarf_Aranges structs. */
     Dwarf_Chain curr_chain = NULL;
     Dwarf_Chain head_chain = NULL;
     Dwarf_Chain *plast = &head_chain;
 
     if (!dbg->de_debug_aranges.dss_size) {
         return DW_DLV_NO_ENTRY;
     }
     arange_ptr = dbg->de_debug_aranges.dss_data;
     arange_ptr_start = arange_ptr;
     section_size = dbg->de_debug_aranges.dss_size;
     arange_end_section = arange_ptr + section_size;
 
     do {
         /*  Length of current set of aranges.
             This is local length, which begins just
             after the length field itself. */
         Dwarf_Unsigned area_length = 0;
         Dwarf_Unsigned remainder = 0;
         Dwarf_Unsigned range_entry_size = 0;
         int local_length_size;
         int local_extension_size = 0;
         Dwarf_Small *end_this_arange = 0;
         int res = 0;
 
         header_ptr = arange_ptr;
         if (header_ptr >= arange_end_section) {
             free_aranges_chain(dbg,head_chain);
             _dwarf_error(dbg, error,DW_DLE_ARANGES_HEADER_ERROR);
             return DW_DLV_ERROR;
         }
         res = _dwarf_read_area_length_ck_wrapper(dbg,&area_length,
             &arange_ptr,&local_length_size,&local_extension_size,
             section_size,arange_end_section,error);
         if (res != DW_DLV_OK) {
             free_aranges_chain(dbg,head_chain);
             return res;
         }
         /*  arange_ptr has been incremented appropriately past
             the length field by READ_AREA_LENGTH. */
 
-        if (area_length >  dbg->de_debug_aranges.dss_size) {
+        if (area_length >  dbg->de_debug_aranges.dss_size ||
+            (area_length +local_length_size+local_extension_size)
+            > dbg->de_debug_aranges.dss_size ) {
             free_aranges_chain(dbg,head_chain);
             _dwarf_error(dbg, error,DW_DLE_ARANGES_HEADER_ERROR);
             return DW_DLV_ERROR;
         }
         if ((area_length + local_length_size + local_extension_size) >
             dbg->de_debug_aranges.dss_size) {
             free_aranges_chain(dbg,head_chain);
             _dwarf_error(dbg, error, DW_DLE_ARANGES_HEADER_ERROR);
             return DW_DLV_ERROR;
         }
 
         end_this_arange = arange_ptr + area_length;
         if (end_this_arange > arange_end_section) {
             free_aranges_chain(dbg,head_chain);
             _dwarf_error(dbg, error,DW_DLE_ARANGES_HEADER_ERROR);
             return DW_DLV_ERROR;
         }
         if (!area_length) {
             /*  We read 4 bytes of zero, so area-length zero.
                 Keep scanning. First seen Nov 27, 2018
                 in GNU-cc in windows dll. */
             continue;
         }
 
         res = _dwarf_read_unaligned_ck_wrapper(dbg,&version,
             arange_ptr,DWARF_HALF_SIZE,end_this_arange,error);
         if (res != DW_DLV_OK) {
             free_aranges_chain(dbg,head_chain);
             return res;
         }
         arange_ptr += DWARF_HALF_SIZE;
         if (arange_ptr >= end_this_arange) {
             free_aranges_chain(dbg,head_chain);
             _dwarf_error(dbg, error, DW_DLE_ARANGES_HEADER_ERROR);
             return DW_DLV_ERROR;
         }
         if (version != DW_ARANGES_VERSION2) {
             free_aranges_chain(dbg,head_chain);
             _dwarf_error(dbg, error, DW_DLE_VERSION_STAMP_ERROR);
             return DW_DLV_ERROR;
         }
         res = _dwarf_read_unaligned_ck_wrapper(dbg,&info_offset,
             arange_ptr,local_length_size,end_this_arange,error);
         if (res != DW_DLV_OK) {
             free_aranges_chain(dbg,head_chain);
             return res;
         }
 
         arange_ptr += local_length_size;
         if (arange_ptr >= end_this_arange) {
             free_aranges_chain(dbg,head_chain);
             _dwarf_error(dbg, error, DW_DLE_ARANGES_HEADER_ERROR);
             return DW_DLV_ERROR;
         }
         /* This applies to debug_info only, not to debug_types. */
         if (info_offset >= dbg->de_debug_info.dss_size) {
             FIX_UP_OFFSET_IRIX_BUG(dbg, info_offset,
                 "arange info offset.a");
             if (info_offset >= dbg->de_debug_info.dss_size) {
                 free_aranges_chain(dbg,head_chain);
                 _dwarf_error(dbg, error, DW_DLE_ARANGE_OFFSET_BAD);
                 return DW_DLV_ERROR;
             }
         }
 
         address_size = *(Dwarf_Small *) arange_ptr;
         if (address_size  > sizeof(Dwarf_Addr)) {
             free_aranges_chain(dbg,head_chain);
             _dwarf_error(dbg, error, DW_DLE_ADDRESS_SIZE_ERROR);
             return DW_DLV_ERROR;
         }
         if (address_size  ==  0) {
             free_aranges_chain(dbg,head_chain);
             _dwarf_error(dbg, error, DW_DLE_ADDRESS_SIZE_ZERO);
             return DW_DLV_ERROR;
         }
         /*  It is not an error if the sizes differ.
             Unusual, but not an error. */
         arange_ptr = arange_ptr + sizeof(Dwarf_Small);
 
         /*  The following deref means we better
             check the pointer for off-end. */
         if (arange_ptr >= end_this_arange) {
             free_aranges_chain(dbg,head_chain);
             _dwarf_error(dbg, error, DW_DLE_ARANGE_OFFSET_BAD);
             return DW_DLV_ERROR;
         }
 
         /*  Even DWARF2 had a segment_sel_size field here,
             meaning
             size in bytes of a segment selector/descriptor
             on the target system.
             In reality it is unlikely any non-zero
             value will work sensibly for the user.  */
         segment_sel_size = *(Dwarf_Small *) arange_ptr;
         if (segment_sel_size > 0) {
             free_aranges_chain(dbg,head_chain);
             _dwarf_error_string(dbg, error,
                 DW_DLE_SEGMENT_SIZE_BAD,
                 "DW_DLE_SEGMENT_SIZE_BAD: "
                 "segment selector size > 0 is not supported");
             return DW_DLV_ERROR;
         }
         arange_ptr = arange_ptr + sizeof(Dwarf_Small);
         /*  Code below will check for == end_this_arange
             as appropriate. */
         if (arange_ptr > end_this_arange) {
             free_aranges_chain(dbg,head_chain);
             _dwarf_error(dbg, error, DW_DLE_ARANGE_OFFSET_BAD);
             return DW_DLV_ERROR;
         }
         range_entry_size = 2*address_size + segment_sel_size;
         /*  Round arange_ptr offset to next multiple of
             address_size. */
         remainder = (Dwarf_Unsigned) ((arange_ptr - header_ptr) %
             (range_entry_size));
         if (remainder != 0) {
             arange_ptr = arange_ptr + (2 * address_size) - remainder;
         }
 
         do {
             Dwarf_Addr range_address = 0;
             Dwarf_Unsigned segment_selector = 0;
             Dwarf_Unsigned range_length = 0;
             /*  For segmented address spaces, the first field to
                 read is a segment selector (new in DWARF4).
                 The version number DID NOT CHANGE from 2, which
                 is quite surprising.
                 Also surprising since the segment_sel_size
                 was always there
                 in the table header! */
             /*  We want to test cu_version here
                 and segment_sel_size, but
                 currently with no way segment_sel_size
                 can be other than zero.
                 We just hope no one using
                 segment_selectors, really. FIXME */
             res = _dwarf_read_unaligned_ck_wrapper(dbg,&range_address,
                 arange_ptr,address_size,end_this_arange,error);
             if (res != DW_DLV_OK) {
                 free_aranges_chain(dbg,head_chain);
                 return res;
             }
             arange_ptr += address_size;
 
             res = _dwarf_read_unaligned_ck_wrapper(dbg,&range_length,
                 arange_ptr,address_size,end_this_arange,error);
             if (res != DW_DLV_OK) {
                 free_aranges_chain(dbg,head_chain);
                 return res;
             }
 
             arange_ptr += address_size;
 
             {
                 /*  We used to suppress all-zero entries, but
                     now we return all aranges entries so we show
                     the entire content.  March 31, 2010. */
 
                 arange = (Dwarf_Arange)
                     _dwarf_get_alloc(dbg, DW_DLA_ARANGE, 1);
                 if (arange == NULL) {
                     free_aranges_chain(dbg,head_chain);
                     _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);
                     return DW_DLV_ERROR;
                 }
 
                 arange->ar_segment_selector = segment_selector;
                 arange->ar_segment_selector_size =
                     segment_sel_size;
                 arange->ar_address = range_address;
                 arange->ar_length = range_length;
                 arange->ar_info_offset = info_offset;
                 arange->ar_dbg = dbg;
                 arange_count++;
 
                 curr_chain = (Dwarf_Chain)
                     _dwarf_get_alloc(dbg, DW_DLA_CHAIN, 1);
                 if (curr_chain == NULL) {
                     dwarf_dealloc(dbg,arange,DW_DLA_ARANGE);
                     free_aranges_chain(dbg,head_chain);
                     _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);
                     return DW_DLV_ERROR;
                 }
 
                 curr_chain->ch_item = arange;
                 curr_chain->ch_itemtype = DW_DLA_ARANGE;
                 (*plast) = curr_chain;
                 plast = &(curr_chain->ch_next);
             }
             /*  The current set of ranges is terminated by
                 range_address 0 and range_length 0, but that
                 does not necessarily terminate the ranges for this CU!
                 There can be multiple sets in that DWARF
                 does not explicitly forbid multiple sets.
                 DWARF2,3,4 section 7.20
                 We stop short to avoid overrun of the
                 end of the CU.  */
         } while (end_this_arange >= (arange_ptr + range_entry_size));
 
         /*  A compiler could emit some padding bytes here. dwarf2/3
             (dwarf4 sec 7.20) does not clearly make extra padding
             bytes illegal. */
         if (end_this_arange < arange_ptr) {
             Dwarf_Unsigned pad_count = arange_ptr - end_this_arange;
             Dwarf_Unsigned offset = arange_ptr - arange_ptr_start;
             dwarfstring aramsg;
 
             dwarfstring_constructor(&aramsg);
             /* Safe. Length strictly limited. */
             dwarfstring_append_printf_u(&aramsg,
                 "DW_DLE_ARANGE_LENGTH_BAD."
                 " 0x%" DW_PR_XZEROS DW_PR_DUx,
                 pad_count);
             dwarfstring_append_printf_u(&aramsg,
                 " pad bytes at offset 0x%" DW_PR_XZEROS DW_PR_DUx
                 " in .debug_aranges",
                 offset);
             dwarf_insert_harmless_error(dbg,
                 dwarfstring_string(&aramsg));
             dwarfstring_destructor(&aramsg);
         }
         /*  For most compilers, arange_ptr == end_this_arange at
             this point. But not if there were padding bytes */
         arange_ptr = end_this_arange;
     } while (arange_ptr < arange_end_section);
 
     if (arange_ptr != arange_end_section) {
         free_aranges_chain(dbg,head_chain);
         _dwarf_error(dbg, error, DW_DLE_ARANGE_DECODE_ERROR);
         return DW_DLV_ERROR;
     }
     *chain_out = head_chain;
     *chain_count_out = arange_count;
     return DW_DLV_OK;
 }
 
 /*
     This function returns the count of the number of
     aranges in the .debug_aranges section.  It sets
     aranges to point to a block of Dwarf_Arange's
     describing the arange's.  It returns DW_DLV_ERROR
     on error.
 
     Must be identical in most aspects to
         dwarf_get_aranges_addr_offsets!
 
 */
diff --git a/src/lib/libdwarf/dwarf_debugnames.c b/src/lib/libdwarf/dwarf_debugnames.c
index 6e217558..b401e3b5 100644
--- a/src/lib/libdwarf/dwarf_debugnames.c
+++ b/src/lib/libdwarf/dwarf_debugnames.c
@@ -353,410 +353,412 @@ static int
 read_a_name_table_header(Dwarf_Dnames_Head dn,
     Dwarf_Unsigned  starting_offset,
     Dwarf_Unsigned  remaining_space,
     Dwarf_Small    *curptr_in,
     Dwarf_Unsigned *usedspace_out,
     Dwarf_Unsigned *next_offset,
     Dwarf_Small    *end_section,
     Dwarf_Error    *error)
 {
     Dwarf_Unsigned area_length = 0;
     Dwarf_Unsigned area_max_offset = 0;
     unsigned initial_length = 0; /*offset_size+local_ext */
     int offset_size = 0;
     int local_extension_size = 0;
     Dwarf_Small *end_dnames = 0; /* 1 past local table */
     Dwarf_Half version = 0;
     Dwarf_Half padding = 0;
     Dwarf_Unsigned comp_unit_count = 0;
     Dwarf_Unsigned local_type_unit_count = 0;
     Dwarf_Unsigned foreign_type_unit_count = 0;
     Dwarf_Unsigned bucket_count = 0;
     Dwarf_Unsigned name_count = 0;
     Dwarf_Unsigned abbrev_table_size = 0; /* bytes */
     Dwarf_Unsigned entry_pool_size = 0; /* bytes */
     Dwarf_Unsigned augmentation_string_size = 0; /* bytes */
     Dwarf_Unsigned usedspace = 0;
     Dwarf_Unsigned totaloffset = 0;
     int res = 0;
     const char *str_utf8 = 0; /* Augmentation string */
     Dwarf_Small *curptr = 0;
     Dwarf_Debug dbg = dn->dn_dbg;
 
     curptr = curptr_in;
     usedspace = 0;
     totaloffset = starting_offset;
     /* 1 */
     READ_AREA_LENGTH_CK(dbg, area_length, Dwarf_Unsigned,
         curptr, offset_size,
         local_extension_size,error,
         remaining_space,end_section);
     initial_length =  offset_size+local_extension_size;
 
     /* curptr now points past the length field */
     area_max_offset = area_length + initial_length;
     usedspace = initial_length;
     totaloffset += initial_length;
     dn->dn_offset_size = (Dwarf_Half)offset_size;
     /* Two stage length test so overflow is caught. */
-    if (area_length > remaining_space) {
+    if (area_length > remaining_space ||
+       (area_length +offset_size +local_extension_size) > 
+       remaining_space) {
         _dwarf_error_string(dbg, error,
             DW_DLE_DEBUG_NAMES_HEADER_ERROR,
             "DW_DLE_DEBUG_NAMES_HEADER_ERROR: "
             "The index table runs off the end of the .debug_names "
             "section. Corrupt data.");
         return DW_DLV_ERROR;
     }
     if (area_max_offset > remaining_space) {
         _dwarf_error_string(dbg, error,
             DW_DLE_DEBUG_NAMES_HEADER_ERROR,
             "DW_DLE_DEBUG_NAMES_HEADER_ERROR: "
             "The index table runs off the end of the .debug_names "
             "section... Corrupt data.");
         return DW_DLV_ERROR;
     }
     end_dnames = curptr + area_length;
     dn->dn_unit_length = area_length + local_extension_size;
     dn->dn_indextable_data_end = end_dnames;
     dn->dn_next_set_offset = area_length
         + initial_length +
         + starting_offset;
 
     /* 2 */
     READ_UNALIGNED_CK(dbg, version, Dwarf_Half,
         curptr, DWARF_HALF_SIZE,
         error,end_dnames);
     curptr += DWARF_HALF_SIZE;
     usedspace += DWARF_HALF_SIZE;
     totaloffset += DWARF_HALF_SIZE;
     if (curptr >= end_dnames) {
         _dwarf_error(dbg, error,DW_DLE_DEBUG_NAMES_HEADER_ERROR);
         return DW_DLV_ERROR;
     }
     if (version != DWARF_DNAMES_VERSION5) {
         _dwarf_error(dbg, error, DW_DLE_VERSION_STAMP_ERROR);
         return DW_DLV_ERROR;
     }
     /* 3 */
     READ_UNALIGNED_CK(dbg, padding, Dwarf_Half,
         curptr, DWARF_HALF_SIZE,
         error,end_dnames);
     curptr += DWARF_HALF_SIZE;
     usedspace += DWARF_HALF_SIZE;
     totaloffset += DWARF_HALF_SIZE;
     if (curptr >= end_dnames) {
         _dwarf_error(dbg, error,DW_DLE_DEBUG_NAMES_HEADER_ERROR);
         return DW_DLV_ERROR;
     }
     if (padding) {
         _dwarf_error(dbg, error,DW_DLE_DEBUG_NAMES_HEADER_ERROR);
         return DW_DLV_ERROR;
     }
     /* 4 */
     res = read_uword_val(dbg, &curptr,
         end_dnames, DW_DLE_DEBUG_NAMES_HEADER_ERROR,
         &comp_unit_count,area_max_offset,error);
     if (res != DW_DLV_OK) {
         return res;
     }
     if (comp_unit_count > dn->dn_section_size) {
         _dwarf_error_string(dbg,error,
             DW_DLE_DEBUG_NAMES_ERROR,
             "DW_DLE_DEBUG_NAMES_ERROR comp_unit_count too large");
         return DW_DLV_ERROR;
     }
     dn->dn_comp_unit_count = comp_unit_count;
     usedspace += SIZEOFT32;
     totaloffset +=  SIZEOFT32;
     /* 5 */
     res = read_uword_val(dbg, &curptr,
         end_dnames, DW_DLE_DEBUG_NAMES_HEADER_ERROR,
         &local_type_unit_count,area_max_offset,error);
     if (res != DW_DLV_OK) {
         return res;
     }
     if (local_type_unit_count >  dn->dn_section_size) {
         _dwarf_error_string(dbg,error,
             DW_DLE_DEBUG_NAMES_ERROR,
             "DW_DLE_DEBUG_NAMES_ERROR local_type_unit_count large");
         return DW_DLV_ERROR;
     }
     dn->dn_local_type_unit_count = local_type_unit_count;
     usedspace += SIZEOFT32;
     totaloffset +=  SIZEOFT32;
 
     /* 6 */
     res = read_uword_val(dbg, &curptr,
         end_dnames, DW_DLE_DEBUG_NAMES_HEADER_ERROR,
         &foreign_type_unit_count,area_max_offset,error);
     if (res != DW_DLV_OK) {
         return res;
     }
     if (foreign_type_unit_count >  dn->dn_section_size) {
         _dwarf_error_string(dbg,error,
             DW_DLE_DEBUG_NAMES_ERROR,
             "DW_DLE_DEBUG_NAMES_ERROR: "
             "foreign_type_unit_count large");
         return DW_DLV_ERROR;
     }
     dn->dn_foreign_type_unit_count = foreign_type_unit_count;
     usedspace += SIZEOFT32;
     totaloffset += SIZEOFT32;
     /* 7 */
     res = read_uword_val(dbg, &curptr,
         end_dnames, DW_DLE_DEBUG_NAMES_HEADER_ERROR,
         &bucket_count,area_max_offset,error);
     if (res != DW_DLV_OK) {
         return res;
     }
     if (bucket_count > dn->dn_section_size) {
         _dwarf_error_string(dbg,error,
             DW_DLE_DEBUG_NAMES_ERROR,
             "DW_DLE_DEBUG_NAMES_ERROR bucketcount too large");
         return DW_DLV_ERROR;
     }
     dn->dn_bucket_count = bucket_count;
     usedspace += SIZEOFT32;
     totaloffset += SIZEOFT32;
     /*  name_count gives the size of
         the string-offsets and entry-offsets arrays,
         and if hashes present, the size of the hashes
         array. */
     /* 8 */
     res = read_uword_val(dbg, &curptr,
         end_dnames, DW_DLE_DEBUG_NAMES_HEADER_ERROR,
         &name_count,area_max_offset,error);
     if (res != DW_DLV_OK) {
         return res;
     }
     dn->dn_name_count = name_count;
     if (name_count > dn->dn_section_size) {
         _dwarf_error_string(dbg,error,
             DW_DLE_DEBUG_NAMES_ERROR,
             "DW_DLE_DEBUG_NAMES_ERROR name_count too large");
         return DW_DLV_ERROR;
     }
     usedspace += SIZEOFT32;
     totaloffset += SIZEOFT32;
 
     /*  abbrev_table */
     /* 9 */
     res = read_uword_val(dbg, &curptr,
         end_dnames, DW_DLE_DEBUG_NAMES_HEADER_ERROR,
         &abbrev_table_size,area_max_offset,error);
     if (res != DW_DLV_OK) {
         return res;
     }
     if (abbrev_table_size > dn->dn_section_size) {
         _dwarf_error_string(dbg,error,
             DW_DLE_DEBUG_NAMES_ERROR,
             "DW_DLE_DEBUG_NAMES_ERROR abbrev_table_size too large");
         return DW_DLV_ERROR;
     }
     dn->dn_abbrev_table_size = abbrev_table_size;
     usedspace += SIZEOFT32;
     totaloffset += SIZEOFT32;
 
     /* 10 */
     res = read_uword_val(dbg, &curptr,
         end_dnames, DW_DLE_DEBUG_NAMES_HEADER_ERROR,
         &augmentation_string_size,area_max_offset,error);
     if (res != DW_DLV_OK) {
         return res;
     }
     if (augmentation_string_size > dn->dn_section_size) {
         _dwarf_error_string(dbg,error,
             DW_DLE_DEBUG_NAMES_ERROR,
             "DW_DLE_DEBUG_NAMES_ERROR augmentation string too long");
         return DW_DLV_ERROR;
     }
     usedspace += SIZEOFT32;
     totaloffset += SIZEOFT32;
 
     str_utf8 = (const char *) curptr;
     totaloffset += augmentation_string_size;
     usedspace += augmentation_string_size;
     curptr += augmentation_string_size;
     dn->dn_augmentation_string_size = augmentation_string_size;
     if (curptr >= end_dnames) {
         _dwarf_error(dbg, error,DW_DLE_DEBUG_NAMES_HEADER_ERROR);
         return DW_DLV_ERROR;
     }
 
     dn->dn_version = version;
     dn->dn_abbrev_table_size = abbrev_table_size;
     if (augmentation_string_size) {
         /*  11. len: The string size includes zero or
             more NUL bytes to be a multiple of
             four bytes long. */
         Dwarf_Unsigned len = augmentation_string_size;
         const char *cp = 0;
         const char *cpend = 0;
         Dwarf_Unsigned finallen = 0;
 
         dn->dn_augmentation_string = calloc(1,
             augmentation_string_size + 1);
         /* Ensures a final NUL byte */
         _dwarf_safe_strcpy(dn->dn_augmentation_string,
             len +1,str_utf8, len);
         /* This validates a zero length string too. */
         /* in LLVM0700 there is no NUL terminator there:
             See DWARF5 page 144 and also ISSUE
             200505.4 */
         cp = dn->dn_augmentation_string;
         cpend = cp + len;
         /* It's null terminated now, so find the true length */
         for ( ; cp<cpend; ++cp) {
             if (!*cp) {
                 break;
             }
             ++finallen;
         }
         if (len%4) {
             dwarfstring m;
 
             dwarfstring_constructor(&m);
             dwarfstring_append_printf_u(&m,
                 "DW_DLE_DEBUG_NAMES_PAD_NON_ZERO: "
                 "The augmentation_string_size "
                 " is %u, not a multiple of four",len);
             _dwarf_error_string(dbg, error,
                 DW_DLE_DEBUG_NAMES_PAD_NON_ZERO,
                 dwarfstring_string(&m));
             dwarfstring_destructor(&m);
             return DW_DLV_ERROR;
         }
         if (finallen != len) {
             cp = str_utf8 + finallen;
             cpend = str_utf8+len;
             /*  Ensure that there is no corruption in
                 the padding. */
             for ( ; cp < cpend; ++cp) {
                 if (*cp) {
                     _dwarf_error_string(dbg, error,
                         DW_DLE_DEBUG_NAMES_PAD_NON_ZERO,
                         "DW_DLE_DEBUG_NAMES_PAD_NON_ZERO: "
                         "padding in augmentation string not zeros");
                     return DW_DLV_ERROR;
                 }
             }
         }
     }
 
     /*  Now we deal with the arrays following the header. */
     dn->dn_cu_list = curptr;
     dn->dn_cu_list_offset = usedspace;
     curptr +=  dn->dn_offset_size * comp_unit_count;
     usedspace += dn->dn_offset_size * comp_unit_count ;
     totaloffset += dn->dn_offset_size * comp_unit_count ;
     VALIDATEOFFSET(dn,totaloffset,"comp_unit array error");
 
     dn->dn_local_tu_list = curptr;
     dn->dn_local_tu_list_offset = usedspace;
     curptr +=  dn->dn_offset_size *local_type_unit_count;
     usedspace += dn->dn_offset_size* local_type_unit_count;
     totaloffset += dn->dn_offset_size* local_type_unit_count;
     VALIDATEOFFSET(dn,totaloffset,"local_type__unit array error");
 
     dn->dn_foreign_tu_list = curptr;
     dn->dn_foreign_tu_list_offset = usedspace;
     curptr += sizeof(Dwarf_Sig8)     * foreign_type_unit_count;
     usedspace += sizeof(Dwarf_Sig8)  * foreign_type_unit_count;
     totaloffset += sizeof(Dwarf_Sig8)* foreign_type_unit_count;
     VALIDATEOFFSET(dn,totaloffset,"foreign_type__unit array error");
 
     dn->dn_buckets_offset = usedspace;
     dn->dn_buckets = curptr;
     curptr +=  SIZEOFT32 * bucket_count ;
     usedspace += SIZEOFT32 * bucket_count;
     totaloffset += SIZEOFT32 * bucket_count;
     VALIDATEOFFSET(dn,totaloffset," bucket array error");
 
     if (comp_unit_count == 1) {
         Dwarf_Small *ptrx     = dn->dn_cu_list;
         Dwarf_Small *endptr   = dn->dn_foreign_tu_list;
         Dwarf_Unsigned unit_entry_size = dn->dn_offset_size;
         Dwarf_Unsigned offsetval = 0;
 
         READ_UNALIGNED_CK(dbg, offsetval, Dwarf_Unsigned,
             ptrx,(unsigned long) unit_entry_size,
             error,endptr);
         dn->dn_single_cu = TRUE;
         dn->dn_single_cu_offset = offsetval;
     }
     dn->dn_hash_table = curptr;
     dn->dn_hash_table_offset = usedspace;
     if (bucket_count) {
         curptr +=  SIZEOFT32 * name_count;
         usedspace += SIZEOFT32 * name_count;
         totaloffset += SIZEOFT32 * name_count;
     }
     VALIDATEOFFSET(dn,totaloffset,"hashes array error");
 
     dn->dn_string_offsets = curptr;
     dn->dn_string_offsets_offset = usedspace;
     curptr +=  dn->dn_offset_size * name_count;
     usedspace += dn->dn_offset_size * name_count;
     totaloffset += dn->dn_offset_size * name_count;
     VALIDATEOFFSET(dn,totaloffset,"string offsets array error");
 
     dn->dn_entry_offsets = curptr;
     dn->dn_entry_offsets_offset = usedspace;
     curptr +=  dn->dn_offset_size * name_count;
     usedspace += dn->dn_offset_size * name_count;
     totaloffset += dn->dn_offset_size * name_count;
     VALIDATEOFFSET(dn,totaloffset,"entry offsets array error");
 
     dn->dn_abbrevs = curptr;
     dn->dn_abbrevs_offset = totaloffset;
     VALIDATEOFFSET(dn,totaloffset,"abbrev table error");
     curptr +=  dn->dn_abbrev_table_size;
     usedspace +=  dn->dn_abbrev_table_size;
     totaloffset +=  dn->dn_abbrev_table_size;
     VALIDATEOFFSET(dn,totaloffset,"abbrev table error");
 
     dn->dn_entry_pool = curptr;
     dn->dn_entry_pool_offset = totaloffset;
     if (dn->dn_next_set_offset < totaloffset) {
         _dwarf_error_string(dbg, error,
             DW_DLE_DEBUG_NAMES_HEADER_ERROR,
             "DW_DLE_DEBUG_NAMES_HEADER_ERROR: "
             "Abbrev total wrong, exceeds "
             "the room available.");
         return DW_DLV_ERROR;
     }
 
     entry_pool_size = dn->dn_next_set_offset - totaloffset;
     dn->dn_entry_pool_size = entry_pool_size;
     curptr +=   entry_pool_size;
     usedspace += entry_pool_size;
     totaloffset += entry_pool_size;
 
     if (totaloffset != dn->dn_next_set_offset)   {
         _dwarf_error_string(dbg, error,
             DW_DLE_DEBUG_NAMES_HEADER_ERROR,
             "DW_DLE_DEBUG_NAMES_HEADER_ERROR: "
             "Final total offset does not match base "
             "calculation. Logic error.");
         return DW_DLV_ERROR;
     }
 
     *usedspace_out = usedspace;
     *next_offset = dn->dn_next_set_offset;
     res = fill_in_abbrevs_table(dn,error);
     if (res != DW_DLV_OK) {
         free(dn->dn_augmentation_string);
         dn->dn_augmentation_string = 0;
         return res;
     }
     return DW_DLV_OK;
 }
 
 #define FAKE_LAST_USED 0xffffffff
 
 /*  There may be one debug index for an entire object file,
     for multiple CUs or there can be individual indexes
     for some CUs.
     see DWARF5 6.1.1.3 Per_CU versus Per-Module Indexes.
     The initial of these tables starts at offset 0.
     If the starting-offset is too high for the section
     return DW_DLV_NO_ENTRY */
diff --git a/src/lib/libdwarf/dwarf_die_deliv.c b/src/lib/libdwarf/dwarf_die_deliv.c
index 7d1465e3..4988f9c7 100644
--- a/src/lib/libdwarf/dwarf_die_deliv.c
+++ b/src/lib/libdwarf/dwarf_die_deliv.c
@@ -411,61 +411,63 @@ static int
 read_info_area_length_and_check(Dwarf_Debug dbg,
     Dwarf_CU_Context cu_context,
     Dwarf_Unsigned offset,
     Dwarf_Byte_Ptr *cu_ptr_io,
     Dwarf_Unsigned section_size,
     Dwarf_Byte_Ptr section_end_ptr,
     Dwarf_Unsigned *max_cu_global_offset_out,
     Dwarf_Error *error)
 {
     Dwarf_Byte_Ptr cu_ptr = 0;
     /*  The following two will be either 0,4, or 8. */
     Dwarf_Unsigned local_length_size = 0;
     Dwarf_Unsigned local_extension_size = 0;
 
     Dwarf_Unsigned max_cu_global_offset = 0;
     Dwarf_Unsigned length = 0;
 
     cu_ptr = *cu_ptr_io;
     /* READ_AREA_LENGTH updates cu_ptr for consumed bytes */
     READ_AREA_LENGTH_CK(dbg, length, Dwarf_Unsigned,
         cu_ptr, local_length_size, local_extension_size,
         error,section_size,section_end_ptr);
     if (!length) {
         return DW_DLV_NO_ENTRY;
     }
 
     /* ASSERT: The following is either  4 or 8. */
     cu_context->cc_length_size =    (Dwarf_Small)local_length_size;
     /* ASSERT: The following is either  0 or 4. */
     cu_context->cc_extension_size = (Dwarf_Small)local_extension_size;
     cu_context->cc_length = length;
 
     /*  This is a bare minimum, not the real max offset.
         A preliminary sanity check. */
     max_cu_global_offset =  offset + length +
         local_extension_size + local_length_size;
-    if (length > section_size) {
+    if (length > section_size ||
+        (length+local_length_size + local_extension_size)>
+        section_size) {
         _dwarf_error(dbg, error, DW_DLE_CU_LENGTH_ERROR);
         return DW_DLV_ERROR;
     }
     if (max_cu_global_offset > section_size) {
         _dwarf_error(dbg, error, DW_DLE_CU_LENGTH_ERROR);
         return DW_DLV_ERROR;
     }
     *cu_ptr_io = cu_ptr;
     *max_cu_global_offset_out = max_cu_global_offset;
     return DW_DLV_OK;
 }
 
 /*  In DWARF4  GNU dwp there is a problem.
     We cannot read the CU die  and it's
     DW_AT_GNU_dwo_id until we know the
     section offsets from the index files.
     Hence we do not know how to search the
     index files by key. So search by offset.
 
     There is no such problem in DWARF5.
 
     We have not yet corrected the unit_type so, for DWARF4,
     we check for simpler unit types.
 */
diff --git a/src/lib/libdwarf/dwarf_frame2.c b/src/lib/libdwarf/dwarf_frame2.c
index 30b92070..6d42e62d 100644
--- a/src/lib/libdwarf/dwarf_frame2.c
+++ b/src/lib/libdwarf/dwarf_frame2.c
@@ -1277,90 +1277,95 @@ int
 _dwarf_read_cie_fde_prefix(Dwarf_Debug dbg,
     Dwarf_Small * frame_ptr_in,
     Dwarf_Small * section_ptr_in,
     Dwarf_Unsigned section_index_in,
     Dwarf_Unsigned section_length_in,
     struct cie_fde_prefix_s *data_out,
     Dwarf_Error * error)
 {
     Dwarf_Unsigned length = 0;
     int local_length_size = 0;
     int local_extension_size = 0;
     Dwarf_Small *frame_ptr = frame_ptr_in;
     Dwarf_Small *cie_ptr_addr = 0;
     Dwarf_Unsigned cie_id = 0;
     Dwarf_Small *section_end = section_ptr_in + section_length_in;
 
     if (section_end < (frame_ptr +4)) {
         dwarfstring m;
         Dwarf_Unsigned u =
             (Dwarf_Unsigned)(uintptr_t)(frame_ptr+4) -
             (Dwarf_Unsigned)(uintptr_t)section_end;
 
         dwarfstring_constructor(&m);
         dwarfstring_append_printf_u(&m,
             "DW_DLE_DEBUG_FRAME_LENGTH_BAD: "
             "Reading the cie/fde prefix would "
             "put us %u bytes past the end of the "
             "frame section.  Corrupt Dwarf.",u);
         _dwarf_error_string(dbg,error,DW_DLE_DEBUG_FRAME_LENGTH_BAD,
             dwarfstring_string(&m));
         dwarfstring_destructor(&m);
         return DW_DLV_ERROR;
     }
     /* READ_AREA_LENGTH updates frame_ptr for consumed bytes */
     READ_AREA_LENGTH_CK(dbg, length, Dwarf_Unsigned,
         frame_ptr, local_length_size,
         local_extension_size,error,
         section_length_in,section_end);
-
     if (length == 0) {
         /*  nul bytes at end of section, seen at end of egcs eh_frame
             sections (in a.out). Take this as meaning no more CIE/FDE
             data. We should be very close to end of section. */
         return DW_DLV_NO_ENTRY;
     }
+    if (length > section_length_in ||
+        (length +local_length_size + local_extension_size) >
+        section_length_in) {
+        _dwarf_error(dbg,error,DW_DLE_DEBUG_FRAME_LENGTH_BAD);
+        return DW_DLV_ERROR;
+    }
     if ((frame_ptr + local_length_size) >= section_end) {
         _dwarf_error(dbg,error,DW_DLE_DEBUG_FRAME_LENGTH_BAD);
         return DW_DLV_ERROR;
     }
 
     cie_ptr_addr = frame_ptr;
     READ_UNALIGNED_CK(dbg, cie_id, Dwarf_Unsigned,
         frame_ptr, local_length_size,error,section_end);
     SIGN_EXTEND(cie_id, local_length_size);
     frame_ptr += local_length_size;
 
     data_out->cf_start_addr = frame_ptr_in;
     data_out->cf_addr_after_prefix = frame_ptr;
 
     data_out->cf_length = length;
     if (length > section_length_in) {
         _dwarf_error(dbg,error,DW_DLE_DEBUG_FRAME_LENGTH_BAD);
         return DW_DLV_ERROR;
     }
     if (cie_ptr_addr+length > section_end) {
         _dwarf_error(dbg,error,DW_DLE_DEBUG_FRAME_LENGTH_BAD);
         return DW_DLV_ERROR;
     }
     data_out->cf_local_length_size = local_length_size;
     data_out->cf_local_extension_size = local_extension_size;
 
     /*  We do not know if it is a CIE or FDE id yet.
         How we check and what it means
         depends whether it is .debug_frame
         or .eh_frame. */
     data_out->cf_cie_id = cie_id;
 
     /*  The address of the CIE_id  or FDE_id value in memory.  */
     data_out->cf_cie_id_addr = cie_ptr_addr;
 
     data_out->cf_section_ptr = section_ptr_in;
     data_out->cf_section_index = section_index_in;
     data_out->cf_section_length = section_length_in;
     return DW_DLV_OK;
 }
 
 /*  On various errors previously-allocated CIEs and FDEs
     must be cleaned up.
     This helps avoid leaks in case of errors.
 */
diff --git a/src/lib/libdwarf/dwarf_global.c b/src/lib/libdwarf/dwarf_global.c
index 91273cab..1c1c66f2 100644
--- a/src/lib/libdwarf/dwarf_global.c
+++ b/src/lib/libdwarf/dwarf_global.c
@@ -613,476 +613,475 @@ static int
 _dwarf_internal_get_pubnames_like(Dwarf_Debug dbg,
     int         category, /* DW_GL_GLOBAL or ... */
     const char *secname,
     Dwarf_Small * section_data_ptr,
     Dwarf_Unsigned section_length,
     Dwarf_Chain  *  out_phead_chain,
     Dwarf_Chain  **  out_pplast_chain,
     Dwarf_Signed * return_count,
     Dwarf_Error * error,
     int length_err_num,
     int version_err_num)
 {
     Dwarf_Small   *pubnames_like_ptr = 0;
     /*  Section offset to the above pointer. */
     Dwarf_Unsigned pubnames_like_offset = 0;
 
     Dwarf_Small *section_end_ptr = section_data_ptr +section_length;
 
     /*  Points to the context for the current set of global names,
         and contains information to identify the compilation-unit
         that the set refers to. */
     Dwarf_Global_Context pubnames_context = 0;
     Dwarf_Bool           pubnames_context_on_list = FALSE;
     Dwarf_Unsigned       context_DLA_code = DW_DLA_GLOBAL_CONTEXT;
     Dwarf_Unsigned       global_DLA_code = DW_DLA_GLOBAL;
 
     Dwarf_Unsigned version = 0;
 
     /*  Offset from the start of compilation-unit for the current
         global. */
     Dwarf_Off die_offset_in_cu = 0;
     Dwarf_Signed global_count = 0;
 
     /*  The count is just to improve the error message
         a few lines above. */
     Dwarf_Unsigned context_count = 0;
 
     if (!dbg || dbg->de_magic != DBG_IS_VALID) {
         _dwarf_error_string(NULL, error, DW_DLE_DBG_NULL,
             "DW_DLE_DBG_NULL: "
             "calling for pubnames-like data Dwarf_Debug "
             "either null or it contains"
             "a stale Dwarf_Debug pointer");
         return DW_DLV_ERROR;
     }
     /* We will eventually need the .debug_info data. Load it now. */
     if (!dbg->de_debug_info.dss_data) {
         int res = _dwarf_load_debug_info(dbg, error);
 
         if (res != DW_DLV_OK) {
             return res;
         }
     }
     if (section_data_ptr == NULL) {
         return DW_DLV_NO_ENTRY;
     }
     pubnames_like_ptr = section_data_ptr;
     pubnames_like_offset = 0;
     do {
         int mres = 0;
         Dwarf_Unsigned length = 0;
         int local_extension_size = 0;
         int local_length_size = 0;
         Dwarf_Off pubnames_section_cu_offset =
             pubnames_like_offset;
 
         /*  Some compilers emit padding at the end of each cu's area.
             pubnames_ptr_past_end_cu records the true area end for the
             pubnames(like) content of a cu.
             Essentially the length in the header and the 0
             terminator of the data are redundant information. The
             dwarf2/3 spec does not mention what to do if the length is
             past the 0 terminator. So we take any bytes left
             after the 0 as padding and ignore them. */
         Dwarf_Small *pubnames_ptr_past_end_cu = 0;
 
         pubnames_context_on_list = FALSE;
         pubnames_context = (Dwarf_Global_Context)
             _dwarf_get_alloc(dbg,
                 (Dwarf_Small)context_DLA_code, 1);
         if (!pubnames_context) {
             dealloc_globals_chain(dbg,*out_phead_chain);
             *out_phead_chain = 0;
             _dwarf_error_string(dbg, error, DW_DLE_ALLOC_FAIL,
                 "DW_DLE_ALLOC_FAIL: Allocating a"
                 " Dwarf_Global_Context for a pubnames entry.");
             return DW_DLV_ERROR;
         }
         /*  ========pubnames_context not recorded anywhere yet. */
         /*  READ_AREA_LENGTH updates pubnames_like_ptr for consumed
             bytes. */
         if ((pubnames_like_ptr + DWARF_32BIT_SIZE +
             DWARF_HALF_SIZE + DWARF_32BIT_SIZE) >
             /* A minimum size needed */
             section_end_ptr) {
             pubnames_error_length(dbg,error,
                 DWARF_32BIT_SIZE + DWARF_HALF_SIZE + DWARF_32BIT_SIZE,
                 secname,
                 "header-record");
             dealloc_globals_chain(dbg,*out_phead_chain);
             *out_phead_chain = 0;
             if (!pubnames_context_on_list) {
                 dwarf_dealloc(dbg,pubnames_context,
                     context_DLA_code);
             }
             return DW_DLV_ERROR;
         }
         mres = _dwarf_read_area_length_ck_wrapper(dbg,
             &length,&pubnames_like_ptr,&local_length_size,
             &local_extension_size,section_length,section_end_ptr,
             error);
         if (mres != DW_DLV_OK) {
             dealloc_globals_chain(dbg,*out_phead_chain);
             *out_phead_chain = 0;
             if (!pubnames_context_on_list) {
                 dwarf_dealloc(dbg,pubnames_context,context_DLA_code);
             }
             return mres;
         }
         {
             Dwarf_Small * localend =pubnames_like_ptr + length;
-
             if ((length > section_length) ||
                 (localend > section_end_ptr)){
                 _dwarf_global_cu_len_error_msg(dbg,
                     length_err_num,
                     secname, section_length,
                     context_count,
                     (Dwarf_Unsigned)pubnames_like_offset,
                     (Dwarf_Unsigned)length,
                     error);
                 dealloc_globals_chain(dbg,*out_phead_chain);
                 *out_phead_chain = 0;
                 if (!pubnames_context_on_list) {
                     dwarf_dealloc(dbg,pubnames_context,
                         context_DLA_code);
                 }
                 return DW_DLV_ERROR;
             }
         }
         pubnames_like_offset += local_length_size +
             local_extension_size;
         /*  The count is just to improve the error message
             a few lines above. */
         ++context_count;
         /*  Dwarf_Global_Context initialization. */
         pubnames_context->pu_global_category  = category;
         pubnames_context->pu_alloc_type =
             (unsigned)context_DLA_code;
         pubnames_context->pu_length_size =
             (unsigned char)local_length_size;
         pubnames_context->pu_length = (unsigned char)length;
         pubnames_context->pu_extension_size =
             (unsigned char)local_extension_size;
         pubnames_context->pu_dbg = dbg;
         pubnames_context->pu_pub_offset = pubnames_section_cu_offset;
         pubnames_ptr_past_end_cu = pubnames_like_ptr + length;
         pubnames_context->pu_pub_entries_end_ptr =
             pubnames_ptr_past_end_cu;
         if ((pubnames_like_ptr + (DWARF_HALF_SIZE) ) >=
             /* A minimum size needed */
             section_end_ptr) {
             pubnames_error_length(dbg,error,
                 DWARF_HALF_SIZE,
                 secname,"version-number");
             dealloc_globals_chain(dbg,*out_phead_chain);
             *out_phead_chain = 0;
             if (!pubnames_context_on_list) {
                 dwarf_dealloc(dbg,pubnames_context,context_DLA_code);
             }
             return DW_DLV_ERROR;
         }
         mres = _dwarf_read_unaligned_ck_wrapper(dbg,
             &version,pubnames_like_ptr,DWARF_HALF_SIZE,
             section_end_ptr,error);
         if (mres != DW_DLV_OK) {
             dealloc_globals_chain(dbg,*out_phead_chain);
             *out_phead_chain = 0;
             if (!pubnames_context_on_list) {
                 dwarf_dealloc(dbg,pubnames_context,context_DLA_code);
             }
             return mres;
         }
         pubnames_context->pu_version = (Dwarf_Half)version;
         pubnames_like_ptr += DWARF_HALF_SIZE;
         pubnames_like_offset += DWARF_HALF_SIZE;
         /* ASSERT: DW_PUBNAMES_VERSION2 == DW_PUBTYPES_VERSION2 */
         if (version != DW_PUBNAMES_VERSION2) {
             dealloc_globals_chain(dbg,*out_phead_chain);
             *out_phead_chain = 0;
             if (!pubnames_context_on_list) {
                 dwarf_dealloc(dbg,pubnames_context,context_DLA_code);
             }
             _dwarf_error(dbg, error, version_err_num);
             return DW_DLV_ERROR;
         }
 
         /* Offset of CU header in debug section. */
         if ((pubnames_like_ptr + 3*pubnames_context->pu_length_size)>
             section_end_ptr) {
             pubnames_error_length(dbg,error,
                 3*pubnames_context->pu_length_size,
                 secname,
                 "header/DIE offsets");
             dealloc_globals_chain(dbg,*out_phead_chain);
             *out_phead_chain = 0;
             if (!pubnames_context_on_list) {
                 dwarf_dealloc(dbg,pubnames_context,context_DLA_code);
             }
             return DW_DLV_ERROR;
         }
         mres = _dwarf_read_unaligned_ck_wrapper(dbg,
             &pubnames_context->pu_offset_of_cu_header,
             pubnames_like_ptr,
             pubnames_context->pu_length_size,
             section_end_ptr,error);
         if (mres != DW_DLV_OK) {
             dealloc_globals_chain(dbg,*out_phead_chain);
             *out_phead_chain = 0;
             if (!pubnames_context_on_list) {
                 dwarf_dealloc(dbg,pubnames_context,context_DLA_code);
             }
             return mres;
         }
 
         pubnames_like_ptr += pubnames_context->pu_length_size;
         pubnames_like_offset += pubnames_context->pu_length_size;
 
         FIX_UP_OFFSET_IRIX_BUG(dbg,
             pubnames_context->pu_offset_of_cu_header,
             "pubnames cu header offset");
         mres = _dwarf_read_unaligned_ck_wrapper(dbg,
             &pubnames_context->pu_info_length,
             pubnames_like_ptr,
             pubnames_context->pu_length_size,
             section_end_ptr,error);
         if (mres != DW_DLV_OK) {
             dealloc_globals_chain(dbg,*out_phead_chain);
             *out_phead_chain = 0;
             if (!pubnames_context_on_list) {
                 dwarf_dealloc(dbg,pubnames_context,context_DLA_code);
             }
             return mres;
         }
         pubnames_like_ptr += pubnames_context->pu_length_size;
         pubnames_like_offset += pubnames_context->pu_length_size;
 
         if (pubnames_like_ptr > (section_data_ptr + section_length)) {
             dealloc_globals_chain(dbg,*out_phead_chain);
             *out_phead_chain = 0;
             if (!pubnames_context_on_list) {
                 dwarf_dealloc(dbg,pubnames_context,context_DLA_code);
             }
             _dwarf_error(dbg, error, length_err_num);
             return DW_DLV_ERROR;
         }
 
         /*  Read initial offset (of DIE within CU) of a pubname, final
             entry is not a pair, just a zero offset. */
         mres = _dwarf_read_unaligned_ck_wrapper(dbg,
             &die_offset_in_cu,
             pubnames_like_ptr,
             pubnames_context->pu_length_size,
             pubnames_context->pu_pub_entries_end_ptr,error);
         if (mres != DW_DLV_OK) {
             dealloc_globals_chain(dbg,*out_phead_chain);
             *out_phead_chain = 0;
             if (!pubnames_context_on_list) {
                 dwarf_dealloc(dbg,pubnames_context,context_DLA_code);
             }
             return mres;
         }
         pubnames_like_ptr += pubnames_context->pu_length_size;
         pubnames_like_offset += pubnames_context->pu_length_size;
         FIX_UP_OFFSET_IRIX_BUG(dbg,
             die_offset_in_cu, "offset of die in cu");
         if (pubnames_like_ptr > (section_data_ptr + section_length)) {
             dealloc_globals_chain(dbg,*out_phead_chain);
             *out_phead_chain = 0;
             if (!pubnames_context_on_list) {
                 dwarf_dealloc(dbg,pubnames_context,context_DLA_code);
             }
             _dwarf_error(dbg, error, length_err_num);
             return DW_DLV_ERROR;
         }
 
         /*  Check if empty section */
         if (!die_offset_in_cu) {
             if (dbg->de_return_empty_pubnames) {
                 int res = 0;
 
                 /*  Here we have a pubnames CU with no actual
                     entries so we fake up an entry to hold the
                     header data.  There are no 'pairs' here,
                     just the end of list zero value.  We do this
                     only if de_return_empty_pubnames is set
                     so that we by default return exactly the same
                     data this always returned, yet dwarfdump can
                     request the empty-cu records get created
                     to test that feature.
                     see dwarf_get_globals_header()  */
                 res = _dwarf_make_global_add_to_chain(dbg,
                     pubnames_context,
                     die_offset_in_cu,
                     /*  It is a fake global, so empty name */
                     (unsigned char *)"",
                     &global_count,
                     &pubnames_context_on_list,
                     global_DLA_code,
                     out_pplast_chain,
                     0,
                     error);
                 if (res != DW_DLV_OK) {
                     dealloc_globals_chain(dbg,*out_phead_chain);
                     *out_phead_chain = 0;
                     if (!pubnames_context_on_list) {
                         dwarf_dealloc(dbg,pubnames_context,
                             context_DLA_code);
                     }
                     return res;
                 }
                 /*  ========pubnames_context recorded in chain. */
             } else {
                 /*  The section is empty.
                     Nowhere to record pubnames_context); */
                 dwarf_dealloc(dbg,pubnames_context,context_DLA_code);
                 pubnames_context = 0;
                 continue;
             }
         }
         /* Loop thru pairs. DIE off with CU followed by string. */
         /*  Now read pairs of entries */
         while (die_offset_in_cu) {
             int res = 0;
             unsigned char *glname = 0;
             Dwarf_Unsigned nstrlen = 0;
 
             /*  non-zero die_offset_in_cu already read, so
                 pubnames_like_ptr points to a string.  */
             res = _dwarf_check_string_valid(dbg,section_data_ptr,
                 pubnames_like_ptr,
                 pubnames_context->pu_pub_entries_end_ptr,
                 DW_DLE_STRING_OFF_END_PUBNAMES_LIKE,error);
             if (res != DW_DLV_OK) {
                 dealloc_globals_chain(dbg,*out_phead_chain);
                 *out_phead_chain = 0;
                 if (!pubnames_context_on_list) {
                     dwarf_dealloc(dbg,pubnames_context,
                         context_DLA_code);
                 }
                 return res;
             }
             glname = (unsigned char *)pubnames_like_ptr;
             nstrlen = strlen((char *)pubnames_like_ptr);
             pubnames_like_ptr += nstrlen + 1;
             pubnames_like_offset += nstrlen + 1;
             /*  Already read offset and verified string, glname
                 now points to the string. */
             res = _dwarf_make_global_add_to_chain(dbg,
                 pubnames_context,
                 die_offset_in_cu,
                 glname,
                 &global_count,
                 &pubnames_context_on_list,
                 global_DLA_code,
                 out_pplast_chain,
                 0,
                 error);
             if (res != DW_DLV_OK) {
                 dealloc_globals_chain(dbg,*out_phead_chain);
                 *out_phead_chain = 0;
                 if (!pubnames_context_on_list) {
                     dwarf_dealloc(dbg,pubnames_context,
                         context_DLA_code);
                 }
                 return res;
             }
             /*  ========pubnames_context recorded in chain. */
             /*  Ensure room for a next entry  to exist. */
             if ((pubnames_like_ptr +
                 pubnames_context->pu_length_size ) >
                 section_end_ptr) {
                 pubnames_error_length(dbg,error,
                     2*pubnames_context->pu_length_size,
                     secname,
                     "global record offset");
                 dealloc_globals_chain(dbg,*out_phead_chain);
                 *out_phead_chain = 0;
                 if (!pubnames_context_on_list) {
                     dwarf_dealloc(dbg,pubnames_context,
                         context_DLA_code);
                 }
                 return DW_DLV_ERROR;
             }
             /* Read die offset for the *next* entry */
             mres = _dwarf_read_unaligned_ck_wrapper(dbg,
                 &die_offset_in_cu,
                 pubnames_like_ptr,
                 pubnames_context->pu_length_size,
                 pubnames_context->pu_pub_entries_end_ptr,
                 error);
             if (mres != DW_DLV_OK) {
                 if (!pubnames_context_on_list) {
                     dwarf_dealloc(dbg,pubnames_context,
                         context_DLA_code);
                 }
                 dealloc_globals_chain(dbg,*out_phead_chain);
                 *out_phead_chain = 0;
                 return mres;
             }
             /*  die_offset_in_cu may now be zero, meaing
                 end of the pairs list */
             pubnames_like_ptr += pubnames_context->pu_length_size;
             pubnames_like_offset += pubnames_context->pu_length_size;
             FIX_UP_OFFSET_IRIX_BUG(dbg,
                 die_offset_in_cu, "offset of next die in cu");
             if (pubnames_like_ptr >
                 (section_data_ptr + section_length)) {
                 if (!pubnames_context_on_list) {
                     dwarf_dealloc(dbg,pubnames_context,
                         context_DLA_code);
                 }
                 dealloc_globals_chain(dbg,*out_phead_chain);
                 *out_phead_chain = 0;
                 _dwarf_error(dbg, error, length_err_num);
                 return DW_DLV_ERROR;
             }
         }
         /* ASSERT: die_offset_in_cu == 0 */
         if (pubnames_like_ptr > pubnames_ptr_past_end_cu) {
             /* This is some kind of error. This simply cannot happen.
             The encoding is wrong or the length in the header for
             this cu's contribution is wrong. */
             _dwarf_error(dbg, error, length_err_num);
             if (!pubnames_context_on_list) {
                 dwarf_dealloc(dbg,pubnames_context,context_DLA_code);
             }
             dealloc_globals_chain(dbg,*out_phead_chain);
             *out_phead_chain = 0;
             return DW_DLV_ERROR;
         }
 #if 1
         /*  If there is some kind of padding at the end of
             the section, following a pairs terminator,
             as emitted by some compilers, skip over that padding and
             simply ignore the bytes thus passed-over. */
         {
             Dwarf_Unsigned finaloffset =
                 pubnames_section_cu_offset+
                 pubnames_context->pu_length_size +
                 pubnames_context->pu_length +
                 pubnames_context->pu_extension_size;
             if (finaloffset > pubnames_like_offset) {
                 pubnames_like_offset = finaloffset;
             }
         }
 #endif
         pubnames_like_ptr = pubnames_ptr_past_end_cu;
     } while (pubnames_like_ptr < section_end_ptr);
     *return_count = global_count;
     return DW_DLV_OK;
 #if 0
     if (!globals) {
         return DW_DLV_OK;
     }
     {
         int cbres = 0;
         /*  Cannot return DW_DLV_NO_ENTRY */
         cbres = _dwarf_chain_to_array(dbg,*out_phead_chain,
             global_count, globals, error);
         /* head_chain no longer points to anything */
         *out_phead_chain = 0;
         return cbres;
     }
 #endif
 }
diff --git a/src/lib/libdwarf/dwarf_loclists.c b/src/lib/libdwarf/dwarf_loclists.c
index 64022906..a0849870 100644
--- a/src/lib/libdwarf/dwarf_loclists.c
+++ b/src/lib/libdwarf/dwarf_loclists.c
@@ -294,113 +294,114 @@ int
 _dwarf_internal_read_loclists_header(Dwarf_Debug dbg,
     Dwarf_Unsigned contextnum,
     Dwarf_Unsigned sectionlength,
     Dwarf_Small *data,
     Dwarf_Small *end_data,
     Dwarf_Unsigned offset,
     Dwarf_Loclists_Context  buildhere,
     Dwarf_Unsigned *next_offset,
     Dwarf_Error *error)
 {
     Dwarf_Small *startdata = data;
     Dwarf_Unsigned arealen = 0;
     int offset_size = 0;
     int exten_size = 0;
     Dwarf_Unsigned version = 0;
     unsigned address_size = 0;
     unsigned segment_selector_size=  0;
     Dwarf_Unsigned offset_entry_count = 0;
     Dwarf_Unsigned localoff = 0;
     Dwarf_Unsigned lists_len = 0;
 
     READ_AREA_LENGTH_CK(dbg,arealen,Dwarf_Unsigned,
         data,offset_size,exten_size,
         error,
         sectionlength,end_data);
-    if (arealen > sectionlength) {
+    if (arealen > sectionlength ||
+        (arealen+offset_size+exten_size) > sectionlength) {
         dwarfstring m;
         dwarfstring_constructor(&m);
         dwarfstring_append_printf_u(&m,
             "DW_DLE_SECTION_SIZE_ERROR: A .debug_loclists "
             "area size of 0x%x ",arealen);
         dwarfstring_append_printf_u(&m,
             "at offset 0x%x ",offset);
         dwarfstring_append_printf_u(&m,
             "is larger than the entire section size of "
             "0x%x. Corrupt DWARF.",sectionlength);
         _dwarf_error_string(dbg,error,DW_DLE_SECTION_SIZE_ERROR,
             dwarfstring_string(&m));
         dwarfstring_destructor(&m);
         return DW_DLV_ERROR;
     }
 
     buildhere->lc_length = arealen +offset_size+exten_size;
     buildhere->lc_dbg = dbg;
     buildhere->lc_index = contextnum;
     buildhere->lc_header_offset = offset;
     buildhere->lc_offset_size = offset_size;
     buildhere->lc_extension_size = exten_size;
     READ_UNALIGNED_CK(dbg,version,Dwarf_Unsigned,data,
         SIZEOFT16,error,end_data);
     if (version != DW_CU_VERSION5) {
         dwarfstring m;
         dwarfstring_constructor(&m);
         dwarfstring_append_printf_u(&m,
             "DW_DLE_VERSION_STAMP_ERROR: The version should be 5 "
             "but we find %u instead.",version);
         _dwarf_error_string(dbg,error,DW_DLE_VERSION_STAMP_ERROR,
             dwarfstring_string(&m));
         dwarfstring_destructor(&m);
         return DW_DLV_ERROR;
     }
     buildhere->lc_version = version;
     data += SIZEOFT16;
 
     READ_UNALIGNED_CK(dbg,address_size,unsigned,data,
         SIZEOFT8,error,end_data);
     if (address_size != 4 && address_size != 8 &&
         address_size != 2) {
         dwarfstring m;
         dwarfstring_constructor(&m);
         dwarfstring_append_printf_u(&m,
             " DW_DLE_ADDRESS_SIZE_ERROR: The address size "
             "of %u is not supported.",address_size);
         _dwarf_error_string(dbg,error,DW_DLE_ADDRESS_SIZE_ERROR,
             dwarfstring_string(&m));
         dwarfstring_destructor(&m);
         return DW_DLV_ERROR;
     }
     buildhere->lc_address_size = address_size;
     data++;
 
     READ_UNALIGNED_CK(dbg,segment_selector_size,unsigned,data,
         SIZEOFT8,error,end_data);
     buildhere->lc_segment_selector_size = segment_selector_size;
     data++;
 
     READ_UNALIGNED_CK(dbg,offset_entry_count,Dwarf_Unsigned,data,
         SIZEOFT32,error,end_data);
     buildhere->lc_offset_entry_count = offset_entry_count;
     data += SIZEOFT32;
     if (offset_entry_count ){
         buildhere->lc_offsets_array = data;
     }
     localoff = data - startdata;
     lists_len = offset_size *offset_entry_count;
 
     data += lists_len;
 
     buildhere->lc_offsets_off_in_sect = offset+localoff;
     buildhere->lc_first_loclist_offset = offset+localoff+
         lists_len;
     buildhere->lc_loclists_header = startdata;
     buildhere->lc_endaddr = startdata +buildhere->lc_length;
     buildhere->lc_past_last_loclist_offset =
         buildhere->lc_header_offset +buildhere->lc_length;
     *next_offset =  buildhere->lc_past_last_loclist_offset;
     return DW_DLV_OK;
 }
 
 /*  We return a pointer to an array of contexts
     (not context pointers through *cxt if
     we succeed and are returning DW_DLV_OK.
     We never return DW_DLV_NO_ENTRY here. */
diff --git a/src/lib/libdwarf/dwarf_rnglists.c b/src/lib/libdwarf/dwarf_rnglists.c
index 81bbdbe4..778f94d4 100644
--- a/src/lib/libdwarf/dwarf_rnglists.c
+++ b/src/lib/libdwarf/dwarf_rnglists.c
@@ -191,114 +191,115 @@ int
 _dwarf_internal_read_rnglists_header(Dwarf_Debug dbg,
     Dwarf_Unsigned contextnum,
     Dwarf_Unsigned sectionlength,
     Dwarf_Small *data,
     Dwarf_Small *end_data,
     Dwarf_Unsigned offset,
     Dwarf_Rnglists_Context  buildhere,
     Dwarf_Unsigned *next_offset,
     Dwarf_Error *error)
 {
     Dwarf_Small *startdata = data;
     Dwarf_Unsigned arealen = 0;
     int offset_size = 0;
     int exten_size = 0;
     Dwarf_Unsigned version = 0;
     unsigned address_size = 0;
     unsigned segment_selector_size=  0;
     Dwarf_Unsigned offset_entry_count = 0;
     Dwarf_Unsigned localoff = 0;
     Dwarf_Unsigned lists_len = 0;
 
     READ_AREA_LENGTH_CK(dbg,arealen,Dwarf_Unsigned,
         data,offset_size,exten_size,
         error,
         sectionlength,end_data);
-    if (arealen > sectionlength) {
+    if (arealen > sectionlength ||
+        (arealen+offset_size+exten_size) > sectionlength) {
         dwarfstring m;
         dwarfstring_constructor(&m);
         dwarfstring_append_printf_u(&m,
             "DW_DLE_SECTION_SIZE_ERROR: A .debug_rnglists "
             "area size of 0x%x ",arealen);
         dwarfstring_append_printf_u(&m,
             "at offset 0x%x ",offset);
         dwarfstring_append_printf_u(&m,
             "is larger than the entire section size of "
             "0x%x. Corrupt DWARF.",sectionlength);
         _dwarf_error_string(dbg,error,DW_DLE_SECTION_SIZE_ERROR,
             dwarfstring_string(&m));
         dwarfstring_destructor(&m);
         return DW_DLV_ERROR;
     }
 
     buildhere->rc_length = arealen +offset_size+exten_size;
     buildhere->rc_dbg = dbg;
     buildhere->rc_index = contextnum;
     buildhere->rc_header_offset = offset;
     buildhere->rc_offset_size = offset_size;
     buildhere->rc_extension_size = exten_size;
     buildhere->rc_magic = RNGLISTS_MAGIC;
     READ_UNALIGNED_CK(dbg,version,Dwarf_Unsigned,data,
         SIZEOFT16,error,end_data);
     if (version != DW_CU_VERSION5) {
         dwarfstring m;
         dwarfstring_constructor(&m);
         dwarfstring_append_printf_u(&m,
             "DW_DLE_VERSION_STAMP_ERROR: The version should be 5 "
             "but we find %u instead.",version);
         _dwarf_error_string(dbg,error,DW_DLE_VERSION_STAMP_ERROR,
             dwarfstring_string(&m));
         dwarfstring_destructor(&m);
         return DW_DLV_ERROR;
     }
     buildhere->rc_version = version;
     data += SIZEOFT16;
 
     READ_UNALIGNED_CK(dbg,address_size,unsigned,data,
         SIZEOFT8,error,end_data);
     if (address_size != 4 && address_size != 8 &&
         address_size != 2) {
         dwarfstring m;
         dwarfstring_constructor(&m);
         dwarfstring_append_printf_u(&m,
             " DW_DLE_ADDRESS_SIZE_ERROR: The address size "
             "of %u is not supported.",address_size);
         _dwarf_error_string(dbg,error,DW_DLE_ADDRESS_SIZE_ERROR,
             dwarfstring_string(&m));
         dwarfstring_destructor(&m);
         return DW_DLV_ERROR;
     }
     buildhere->rc_address_size = address_size;
     data++;
 
     READ_UNALIGNED_CK(dbg,segment_selector_size,unsigned,data,
         SIZEOFT8,error,end_data);
     buildhere->rc_segment_selector_size = segment_selector_size;
     data++;
 
     READ_UNALIGNED_CK(dbg,offset_entry_count,Dwarf_Unsigned,data,
         SIZEOFT32,error,end_data);
     buildhere->rc_offset_entry_count = offset_entry_count;
     data += SIZEOFT32;
     if (offset_entry_count ){
         buildhere->rc_offsets_array = data;
     }
     localoff = data - startdata;
     lists_len = offset_size *offset_entry_count;
 
     data += lists_len;
 
     buildhere->rc_offsets_off_in_sect = offset+localoff;
     buildhere->rc_first_rnglist_offset = offset+localoff+
         lists_len;
     buildhere->rc_rnglists_header = startdata;
     buildhere->rc_endaddr = startdata +buildhere->rc_length;
     buildhere->rc_past_last_rnglist_offset =
         buildhere->rc_header_offset +buildhere->rc_length;
     *next_offset =  buildhere->rc_past_last_rnglist_offset;
     return DW_DLV_OK;
 }
 
 /*  We return a pointer to an array of contexts
     (not context pointers) through *cxt if
     we succeed and are returning DW_DLV_OK.
     We never return DW_DLV_NO_ENTRY here. */
diff --git a/src/lib/libdwarf/dwarf_str_offsets.c b/src/lib/libdwarf/dwarf_str_offsets.c
index 68977ba9..30c11241 100644
--- a/src/lib/libdwarf/dwarf_str_offsets.c
+++ b/src/lib/libdwarf/dwarf_str_offsets.c
@@ -205,122 +205,121 @@ int
 _dwarf_trial_read_dwarf_five_hdr(Dwarf_Debug dbg,
     Dwarf_Small *table_start_ptr,
     Dwarf_Unsigned secsize,
     Dwarf_Small * secendptr,
     Dwarf_Unsigned *length_out,
     Dwarf_Half *local_offset_size_out,
     Dwarf_Half *local_extension_size_out,
     Dwarf_Half *version_out,
     Dwarf_Half *padding_out,
     Dwarf_Error *error)
 {
     Dwarf_Unsigned length = 0; /* length following the
         local_offset_size + local_extension_size */
     Dwarf_Unsigned local_offset_size = 0;
     Dwarf_Unsigned local_extension_size = 0;
     Dwarf_Half version = 0;
     Dwarf_Half padding = 0;
 
     READ_AREA_LENGTH_CK(dbg,length,Dwarf_Unsigned,
         table_start_ptr,local_offset_size,
         local_extension_size,error,
         secsize,secendptr);
     /*  The 'length' part of any header is
         local_extension_size + local_offset_size.
         The length of an offset in the section is just
         local_offset_size.
         Standard DWARF2 sums to 4.
         Standard DWARF3,4,5 sums to 4 or 12.
         Nonstandard SGI IRIX 64bit dwarf sums to 8 (SGI IRIX
         was all DWARF2 and could not have a .debug_str_offsets
         section).
         The header includes 2 bytes of version and two bytes
         of padding. */
     if (length < 4) {
         /*  Usually DW4-style .debug_str_offsets
             starts off with a zero value to ref the
             base string in .debug_str.
             Any tiny value is guaranteed not to be a legal
             DWARF5 .debug_str_offsets section. */
         dwarfstring m;
 
         dwarfstring_constructor(&m);
         dwarfstring_append_printf_u(&m,
             "DW_DLE_SECTION_SIZE_ERROR: "
             "header length 0x%x is too small "
             "to be a real .debug_str_offsets "
             "DWARF5 section",
             length);
         _dwarf_error_string(dbg,error,
             DW_DLE_SECTION_SIZE_ERROR,
             dwarfstring_string(&m));
         dwarfstring_destructor(&m);
         return DW_DLV_ERROR;
 
     }
     if (length > secsize  ||
-        secsize <
-        /* 4 is for the version and padding bytes. */
-        (length+local_extension_size +local_offset_size)) {
+        (length+local_extension_size +local_offset_size) >
+        secsize) {
         dwarfstring m;
 
         dwarfstring_constructor(&m);
         dwarfstring_append_printf_u(&m,
             "DW_DLE_STR_OFFSETS_ARRAY_SIZE: "
             " header length 0x%x is bigger than ",
             length);
         dwarfstring_append_printf_u(&m,
             ".debug_str_offsets section size of 0x%x."
             " Perhaps the section is a GNU DWARF4"
             " extension with a different format.",
             secsize);
         _dwarf_error_string(dbg,error,
             DW_DLE_STR_OFFSETS_ARRAY_SIZE,
             dwarfstring_string(&m));
         dwarfstring_destructor(&m);
         return DW_DLV_ERROR;
     }
     /*  table_start_ptr was incremented past
         the length data. */
     READ_UNALIGNED_CK(dbg, version, Dwarf_Half,
         table_start_ptr, DWARF_HALF_SIZE,
         error,secendptr);
     table_start_ptr += DWARF_HALF_SIZE;
     if (version != DW_STR_OFFSETS_VERSION5) {
         dwarfstring m;
 
         dwarfstring_constructor(&m);
         dwarfstring_append_printf_u(&m,
             "DW_DLE_STR_OFFSETS_VERSION_WRONG: "
             "%u. Only version 5 is supported "
             "when reading .debug_str_offsets."
             " Perhaps the section is a GNU DWARF4"
             " extension with a different format.",
             version);
         _dwarf_error_string(dbg,error,
             DW_DLE_STR_OFFSETS_VERSION_WRONG,
             dwarfstring_string(&m));
         dwarfstring_destructor(&m);
         return DW_DLV_ERROR;
     }
     READ_UNALIGNED_CK(dbg, padding, Dwarf_Half,
         table_start_ptr, DWARF_HALF_SIZE,
         error,secendptr);
     /*  padding should be zero, but we are
         not checking it here at present. */
     *length_out = length;
     *local_offset_size_out = local_offset_size;
     *local_extension_size_out = local_extension_size;
     *version_out = version;
     *padding_out = padding;
     return DW_DLV_OK;
 }
 
 /*  Used by code reading attributes/forms and
     also by code reading the raw .debug_str_offsets
     section, hence the code allows for
     output arguments to be zero.
     If cucontext is null it means the call part
     of trying to print the section without
     accessing any context. dwarfdump option
     --print-str-offsets.
     New 30 August 2020. */
