commit 78fae97f6c480b942ef06d537c0a784c076bf7ad
Author: Philip.Hazel <Philip.Hazel@gmail.com>
Date:   Tue Sep 10 13:22:08 2019 +0000

    Mend bug introduced in previous patch. Fixes crash detected by ClusterFuzz
    17101.

diff --git a/src/pcre2_compile.c b/src/pcre2_compile.c
index 8ab10b5..7e44fc8 100644
--- a/src/pcre2_compile.c
+++ b/src/pcre2_compile.c
@@ -5359,2591 +5359,2599 @@ req_caseopt = ((options & PCRE2_CASELESS) != 0)? REQ_CASELESS:0;
 for (;; pptr++)
   {
 #ifdef SUPPORT_WIDE_CHARS
   BOOL xclass_has_prop;
 #endif
   BOOL negate_class;
   BOOL should_flip_negation;
   BOOL match_all_or_no_wide_chars;
   BOOL possessive_quantifier;
   BOOL note_group_empty;
   int class_has_8bitchar;
   int i;
   uint32_t mclength;
   uint32_t skipunits;
   uint32_t subreqcu, subfirstcu;
   uint32_t groupnumber;
   uint32_t verbarglen, verbculen;
   int32_t subreqcuflags, subfirstcuflags;  /* Must be signed */
   open_capitem *oc;
   PCRE2_UCHAR mcbuffer[8];
 
   /* Get next META item in the pattern and its potential argument. */
 
   meta = META_CODE(*pptr);
   meta_arg = META_DATA(*pptr);
 
   /* If we are in the pre-compile phase, accumulate the length used for the
   previous cycle of this loop, unless the next item is a quantifier. */
 
   if (lengthptr != NULL)
     {
     if (code > cb->start_workspace + cb->workspace_size -
         WORK_SIZE_SAFETY_MARGIN)                       /* Check for overrun */
       {
       *errorcodeptr = (code >= cb->start_workspace + cb->workspace_size)?
         ERR52 : ERR86;
       return 0;
       }
 
     /* There is at least one situation where code goes backwards: this is the
     case of a zero quantifier after a class (e.g. [ab]{0}). When the quantifier
     is processed, the whole class is eliminated. However, it is created first,
     so we have to allow memory for it. Therefore, don't ever reduce the length
     at this point. */
 
     if (code < last_code) code = last_code;
 
     /* If the next thing is not a quantifier, we add the length of the previous
     item into the total, and reset the code pointer to the start of the
     workspace. Otherwise leave the previous item available to be quantified. */
 
     if (meta < META_ASTERISK || meta > META_MINMAX_QUERY)
       {
       if (OFLOW_MAX - *lengthptr < (PCRE2_SIZE)(code - orig_code))
         {
         *errorcodeptr = ERR20;   /* Integer overflow */
         return 0;
         }
       *lengthptr += (PCRE2_SIZE)(code - orig_code);
       if (*lengthptr > MAX_PATTERN_SIZE)
         {
         *errorcodeptr = ERR20;   /* Pattern is too large */
         return 0;
         }
       code = orig_code;
       }
 
     /* Remember where this code item starts so we can catch the "backwards"
     case above next time round. */
 
     last_code = code;
     }
 
   /* Process the next parsed pattern item. If it is not a quantifier, remember
   where it starts so that it can be quantified when a quantifier follows.
   Checking for the legality of quantifiers happens in parse_regex(), except for
   a quantifier after an assertion that is a condition. */
 
   if (meta < META_ASTERISK || meta > META_MINMAX_QUERY)
     {
     previous = code;
     if (matched_char && !had_accept) okreturn = 1;
     }
 
   previous_matched_char = matched_char;
   matched_char = FALSE;
   note_group_empty = FALSE;
   skipunits = 0;         /* Default value for most subgroups */
 
   switch(meta)
     {
     /* ===================================================================*/
     /* The branch terminates at pattern end or | or ) */
 
     case META_END:
     case META_ALT:
     case META_KET:
     *firstcuptr = firstcu;
     *firstcuflagsptr = firstcuflags;
     *reqcuptr = reqcu;
     *reqcuflagsptr = reqcuflags;
     *codeptr = code;
     *pptrptr = pptr;
     return okreturn;
 
 
     /* ===================================================================*/
     /* Handle single-character metacharacters. In multiline mode, ^ disables
     the setting of any following char as a first character. */
 
     case META_CIRCUMFLEX:
     if ((options & PCRE2_MULTILINE) != 0)
       {
       if (firstcuflags == REQ_UNSET)
         zerofirstcuflags = firstcuflags = REQ_NONE;
       *code++ = OP_CIRCM;
       }
     else *code++ = OP_CIRC;
     break;
 
     case META_DOLLAR:
     *code++ = ((options & PCRE2_MULTILINE) != 0)? OP_DOLLM : OP_DOLL;
     break;
 
     /* There can never be a first char if '.' is first, whatever happens about
     repeats. The value of reqcu doesn't change either. */
 
     case META_DOT:
     matched_char = TRUE;
     if (firstcuflags == REQ_UNSET) firstcuflags = REQ_NONE;
     zerofirstcu = firstcu;
     zerofirstcuflags = firstcuflags;
     zeroreqcu = reqcu;
     zeroreqcuflags = reqcuflags;
     *code++ = ((options & PCRE2_DOTALL) != 0)? OP_ALLANY: OP_ANY;
     break;
 
 
     /* ===================================================================*/
     /* Empty character classes are allowed if PCRE2_ALLOW_EMPTY_CLASS is set.
     Otherwise, an initial ']' is taken as a data character. When empty classes
     are allowed, [] must always fail, so generate OP_FAIL, whereas [^] must
     match any character, so generate OP_ALLANY. */
 
     case META_CLASS_EMPTY:
     case META_CLASS_EMPTY_NOT:
     matched_char = TRUE;
     *code++ = (meta == META_CLASS_EMPTY_NOT)? OP_ALLANY : OP_FAIL;
     if (firstcuflags == REQ_UNSET) firstcuflags = REQ_NONE;
     zerofirstcu = firstcu;
     zerofirstcuflags = firstcuflags;
     break;
 
 
     /* ===================================================================*/
     /* Non-empty character class. If the included characters are all < 256, we
     build a 32-byte bitmap of the permitted characters, except in the special
     case where there is only one such character. For negated classes, we build
     the map as usual, then invert it at the end. However, we use a different
     opcode so that data characters > 255 can be handled correctly.
 
     If the class contains characters outside the 0-255 range, a different
     opcode is compiled. It may optionally have a bit map for characters < 256,
     but those above are are explicitly listed afterwards. A flag code unit
     tells whether the bitmap is present, and whether this is a negated class or
     not. */
 
     case META_CLASS_NOT:
     case META_CLASS:
     matched_char = TRUE;
     negate_class = meta == META_CLASS_NOT;
 
     /* We can optimize the case of a single character in a class by generating
     OP_CHAR or OP_CHARI if it's positive, or OP_NOT or OP_NOTI if it's
     negative. In the negative case there can be no first char if this item is
     first, whatever repeat count may follow. In the case of reqcu, save the
     previous value for reinstating. */
 
     /* NOTE: at present this optimization is not effective if the only
     character in a class in 32-bit, non-UCP mode has its top bit set. */
 
     if (pptr[1] < META_END && pptr[2] == META_CLASS_END)
       {
 #ifdef SUPPORT_UNICODE
       uint32_t d;
 #endif
       uint32_t c = pptr[1];
 
       pptr += 2;                 /* Move on to class end */
       if (meta == META_CLASS)    /* A positive one-char class can be */
         {                        /* handled as a normal literal character. */
         meta = c;                /* Set up the character */
         goto NORMAL_CHAR_SET;
         }
 
       /* Handle a negative one-character class */
 
       zeroreqcu = reqcu;
       zeroreqcuflags = reqcuflags;
       if (firstcuflags == REQ_UNSET) firstcuflags = REQ_NONE;
       zerofirstcu = firstcu;
       zerofirstcuflags = firstcuflags;
 
       /* For caseless UTF mode, check whether this character has more than
       one other case. If so, generate a special OP_NOTPROP item instead of
       OP_NOTI. */
 
 #ifdef SUPPORT_UNICODE
       if (utf && (options & PCRE2_CASELESS) != 0 &&
           (d = UCD_CASESET(c)) != 0)
         {
         *code++ = OP_NOTPROP;
         *code++ = PT_CLIST;
         *code++ = d;
         break;   /* We are finished with this class */
         }
 #endif
       /* Char has only one other case, or UCP not available */
 
       *code++ = ((options & PCRE2_CASELESS) != 0)? OP_NOTI: OP_NOT;
       code += PUTCHAR(c, code);
       break;   /* We are finished with this class */
       }        /* End of 1-char optimization */
 
     /* Handle character classes that contain more than just one literal
     character. If there are exactly two characters in a positive class, see if
     they are case partners. This can be optimized to generate a caseless single
     character match (which also sets first/required code units if relevant). */
 
-    if (meta == META_CLASS && pptr[1] < META_END && pptr[2] < META_END && 
+    if (meta == META_CLASS && pptr[1] < META_END && pptr[2] < META_END &&
         pptr[3] == META_CLASS_END)
       {
       uint32_t c = pptr[1];
 
 #ifdef SUPPORT_UNICODE
       if (UCD_CASESET(c) == 0)
 #endif
         {
-        uint32_t d = TABLE_GET(c, cb->fcc, c);
+        uint32_t d;
+        
 #ifdef SUPPORT_UNICODE
-        if (utf && c > 127) d = UCD_OTHERCASE(c);
+        if (utf && c > 127) d = UCD_OTHERCASE(c); else
 #endif
+          {
+#if PCRE2_CODE_UNIT_WIDTH != 8
+          if (c > 255) d = c; else
+#endif 
+          d = TABLE_GET(c, cb->fcc, c);
+          }  
+
         if (c != d && pptr[2] == d)
           {
           pptr += 3;                 /* Move on to class end */
           meta = c;
           if ((options & PCRE2_CASELESS) == 0)
             {
             reset_caseful = TRUE;
             options |= PCRE2_CASELESS;
             req_caseopt = REQ_CASELESS;
-            } 
+            }
           goto CLASS_CASELESS_CHAR;
           }
         }
       }
 
     /* If a non-extended class contains a negative special such as \S, we need
     to flip the negation flag at the end, so that support for characters > 255
     works correctly (they are all included in the class). An extended class may
     need to insert specific matching or non-matching code for wide characters.
     */
 
     should_flip_negation = match_all_or_no_wide_chars = FALSE;
 
     /* Extended class (xclass) will be used when characters > 255
     might match. */
 
 #ifdef SUPPORT_WIDE_CHARS
     xclass = FALSE;
     class_uchardata = code + LINK_SIZE + 2;   /* For XCLASS items */
     class_uchardata_base = class_uchardata;   /* Save the start */
 #endif
 
     /* For optimization purposes, we track some properties of the class:
     class_has_8bitchar will be non-zero if the class contains at least one
     character with a code point less than 256; xclass_has_prop will be TRUE if
     Unicode property checks are present in the class. */
 
     class_has_8bitchar = 0;
 #ifdef SUPPORT_WIDE_CHARS
     xclass_has_prop = FALSE;
 #endif
 
     /* Initialize the 256-bit (32-byte) bit map to all zeros. We build the map
     in a temporary bit of memory, in case the class contains fewer than two
     8-bit characters because in that case the compiled code doesn't use the bit
     map. */
 
     memset(classbits, 0, 32 * sizeof(uint8_t));
 
     /* Process items until META_CLASS_END is reached. */
 
     while ((meta = *(++pptr)) != META_CLASS_END)
       {
       /* Handle POSIX classes such as [:alpha:] etc. */
 
       if (meta == META_POSIX || meta == META_POSIX_NEG)
         {
         BOOL local_negate = (meta == META_POSIX_NEG);
         int posix_class = *(++pptr);
         int taboffset, tabopt;
         uint8_t pbits[32];
 
         should_flip_negation = local_negate;  /* Note negative special */
 
         /* If matching is caseless, upper and lower are converted to alpha.
         This relies on the fact that the class table starts with alpha,
         lower, upper as the first 3 entries. */
 
         if ((options & PCRE2_CASELESS) != 0 && posix_class <= 2)
           posix_class = 0;
 
         /* When PCRE2_UCP is set, some of the POSIX classes are converted to
         different escape sequences that use Unicode properties \p or \P.
         Others that are not available via \p or \P have to generate
         XCL_PROP/XCL_NOTPROP directly, which is done here. */
 
 #ifdef SUPPORT_UNICODE
         if ((options & PCRE2_UCP) != 0) switch(posix_class)
           {
           case PC_GRAPH:
           case PC_PRINT:
           case PC_PUNCT:
           *class_uchardata++ = local_negate? XCL_NOTPROP : XCL_PROP;
           *class_uchardata++ = (PCRE2_UCHAR)
             ((posix_class == PC_GRAPH)? PT_PXGRAPH :
              (posix_class == PC_PRINT)? PT_PXPRINT : PT_PXPUNCT);
           *class_uchardata++ = 0;
           xclass_has_prop = TRUE;
           goto CONTINUE_CLASS;
 
           /* For the other POSIX classes (ascii, xdigit) we are going to
           fall through to the non-UCP case and build a bit map for
           characters with code points less than 256. However, if we are in
           a negated POSIX class, characters with code points greater than
           255 must either all match or all not match, depending on whether
           the whole class is not or is negated. For example, for
           [[:^ascii:]... they must all match, whereas for [^[:^xdigit:]...
           they must not.
 
           In the special case where there are no xclass items, this is
           automatically handled by the use of OP_CLASS or OP_NCLASS, but an
           explicit range is needed for OP_XCLASS. Setting a flag here
           causes the range to be generated later when it is known that
           OP_XCLASS is required. In the 8-bit library this is relevant only in
           utf mode, since no wide characters can exist otherwise. */
 
           default:
 #if PCRE2_CODE_UNIT_WIDTH == 8
           if (utf)
 #endif
           match_all_or_no_wide_chars |= local_negate;
           break;
           }
 #endif  /* SUPPORT_UNICODE */
 
         /* In the non-UCP case, or when UCP makes no difference, we build the
         bit map for the POSIX class in a chunk of local store because we may
         be adding and subtracting from it, and we don't want to subtract bits
         that may be in the main map already. At the end we or the result into
         the bit map that is being built. */
 
         posix_class *= 3;
 
         /* Copy in the first table (always present) */
 
         memcpy(pbits, cbits + posix_class_maps[posix_class],
           32 * sizeof(uint8_t));
 
         /* If there is a second table, add or remove it as required. */
 
         taboffset = posix_class_maps[posix_class + 1];
         tabopt = posix_class_maps[posix_class + 2];
 
         if (taboffset >= 0)
           {
           if (tabopt >= 0)
             for (i = 0; i < 32; i++) pbits[i] |= cbits[(int)i + taboffset];
           else
             for (i = 0; i < 32; i++) pbits[i] &= ~cbits[(int)i + taboffset];
           }
 
         /* Now see if we need to remove any special characters. An option
         value of 1 removes vertical space and 2 removes underscore. */
 
         if (tabopt < 0) tabopt = -tabopt;
         if (tabopt == 1) pbits[1] &= ~0x3c;
           else if (tabopt == 2) pbits[11] &= 0x7f;
 
         /* Add the POSIX table or its complement into the main table that is
         being built and we are done. */
 
         if (local_negate)
           for (i = 0; i < 32; i++) classbits[i] |= ~pbits[i];
         else
           for (i = 0; i < 32; i++) classbits[i] |= pbits[i];
 
         /* Every class contains at least one < 256 character. */
 
         class_has_8bitchar = 1;
         goto CONTINUE_CLASS;    /* End of POSIX handling */
         }
 
       /* Other than POSIX classes, the only items we should encounter are
       \d-type escapes and literal characters (possibly as ranges). */
 
       if (meta == META_BIGVALUE)
         {
         meta = *(++pptr);
         goto CLASS_LITERAL;
         }
 
       /* Any other non-literal must be an escape */
 
       if (meta >= META_END)
         {
         if (META_CODE(meta) != META_ESCAPE)
           {
 #ifdef DEBUG_SHOW_PARSED
           fprintf(stderr, "** Unrecognized parsed pattern item 0x%.8x "
                           "in character class\n", meta);
 #endif
           *errorcodeptr = ERR89;  /* Internal error - unrecognized. */
           return 0;
           }
         escape = META_DATA(meta);
 
         /* Every class contains at least one < 256 character. */
 
         class_has_8bitchar++;
 
         switch(escape)
           {
           case ESC_d:
           for (i = 0; i < 32; i++) classbits[i] |= cbits[i+cbit_digit];
           break;
 
           case ESC_D:
           should_flip_negation = TRUE;
           for (i = 0; i < 32; i++) classbits[i] |= ~cbits[i+cbit_digit];
           break;
 
           case ESC_w:
           for (i = 0; i < 32; i++) classbits[i] |= cbits[i+cbit_word];
           break;
 
           case ESC_W:
           should_flip_negation = TRUE;
           for (i = 0; i < 32; i++) classbits[i] |= ~cbits[i+cbit_word];
           break;
 
           /* Perl 5.004 onwards omitted VT from \s, but restored it at Perl
           5.18. Before PCRE 8.34, we had to preserve the VT bit if it was
           previously set by something earlier in the character class.
           Luckily, the value of CHAR_VT is 0x0b in both ASCII and EBCDIC, so
           we could just adjust the appropriate bit. From PCRE 8.34 we no
           longer treat \s and \S specially. */
 
           case ESC_s:
           for (i = 0; i < 32; i++) classbits[i] |= cbits[i+cbit_space];
           break;
 
           case ESC_S:
           should_flip_negation = TRUE;
           for (i = 0; i < 32; i++) classbits[i] |= ~cbits[i+cbit_space];
           break;
 
           /* When adding the horizontal or vertical space lists to a class, or
           their complements, disable PCRE2_CASELESS, because it justs wastes
           time, and in the "not-x" UTF cases can create unwanted duplicates in
           the XCLASS list (provoked by characters that have more than one other
           case and by both cases being in the same "not-x" sublist). */
 
           case ESC_h:
           (void)add_list_to_class(classbits, &class_uchardata,
             options & ~PCRE2_CASELESS, cb, PRIV(hspace_list), NOTACHAR);
           break;
 
           case ESC_H:
           (void)add_not_list_to_class(classbits, &class_uchardata,
             options & ~PCRE2_CASELESS, cb, PRIV(hspace_list));
           break;
 
           case ESC_v:
           (void)add_list_to_class(classbits, &class_uchardata,
             options & ~PCRE2_CASELESS, cb, PRIV(vspace_list), NOTACHAR);
           break;
 
           case ESC_V:
           (void)add_not_list_to_class(classbits, &class_uchardata,
             options & ~PCRE2_CASELESS, cb, PRIV(vspace_list));
           break;
 
           /* If Unicode is not supported, \P and \p are not allowed and are
           faulted at parse time, so will never appear here. */
 
 #ifdef SUPPORT_UNICODE
           case ESC_p:
           case ESC_P:
             {
             uint32_t ptype = *(++pptr) >> 16;
             uint32_t pdata = *pptr & 0xffff;
             *class_uchardata++ = (escape == ESC_p)? XCL_PROP : XCL_NOTPROP;
             *class_uchardata++ = ptype;
             *class_uchardata++ = pdata;
             xclass_has_prop = TRUE;
             class_has_8bitchar--;                /* Undo! */
             }
           break;
 #endif
           }
 
         goto CONTINUE_CLASS;
         }  /* End handling \d-type escapes */
 
       /* A literal character may be followed by a range meta. At parse time
       there are checks for out-of-order characters, for ranges where the two
       characters are equal, and for hyphens that cannot indicate a range. At
       this point, therefore, no checking is needed. */
 
       else
         {
         uint32_t c, d;
 
         CLASS_LITERAL:
         c = d = meta;
 
         /* Remember if \r or \n were explicitly used */
 
         if (c == CHAR_CR || c == CHAR_NL) cb->external_flags |= PCRE2_HASCRORLF;
 
         /* Process a character range */
 
         if (pptr[1] == META_RANGE_LITERAL || pptr[1] == META_RANGE_ESCAPED)
           {
 #ifdef EBCDIC
           BOOL range_is_literal = (pptr[1] == META_RANGE_LITERAL);
 #endif
           pptr += 2;
           d = *pptr;
           if (d == META_BIGVALUE) d = *(++pptr);
 
           /* Remember an explicit \r or \n, and add the range to the class. */
 
           if (d == CHAR_CR || d == CHAR_NL) cb->external_flags |= PCRE2_HASCRORLF;
 
           /* In an EBCDIC environment, Perl treats alphabetic ranges specially
           because there are holes in the encoding, and simply using the range
           A-Z (for example) would include the characters in the holes. This
           applies only to literal ranges; [\xC1-\xE9] is different to [A-Z]. */
 
 #ifdef EBCDIC
           if (range_is_literal &&
                (cb->ctypes[c] & ctype_letter) != 0 &&
                (cb->ctypes[d] & ctype_letter) != 0 &&
                (c <= CHAR_z) == (d <= CHAR_z))
             {
             uint32_t uc = (d <= CHAR_z)? 0 : 64;
             uint32_t C = c - uc;
             uint32_t D = d - uc;
 
             if (C <= CHAR_i)
               {
               class_has_8bitchar +=
                 add_to_class(classbits, &class_uchardata, options, cb, C + uc,
                   ((D < CHAR_i)? D : CHAR_i) + uc);
               C = CHAR_j;
               }
 
             if (C <= D && C <= CHAR_r)
               {
               class_has_8bitchar +=
                 add_to_class(classbits, &class_uchardata, options, cb, C + uc,
                   ((D < CHAR_r)? D : CHAR_r) + uc);
               C = CHAR_s;
               }
 
             if (C <= D)
               {
               class_has_8bitchar +=
                 add_to_class(classbits, &class_uchardata, options, cb, C + uc,
                   D + uc);
               }
             }
           else
 #endif
           /* Not an EBCDIC special range */
 
           class_has_8bitchar +=
             add_to_class(classbits, &class_uchardata, options, cb, c, d);
           goto CONTINUE_CLASS;   /* Go get the next char in the class */
           }  /* End of range handling */
 
 
         /* Handle a single character. */
 
         class_has_8bitchar +=
           add_to_class(classbits, &class_uchardata, options, cb, meta, meta);
         }
 
       /* Continue to the next item in the class. */
 
       CONTINUE_CLASS:
 
 #ifdef SUPPORT_WIDE_CHARS
       /* If any wide characters or Unicode properties have been encountered,
       set xclass = TRUE. Then, in the pre-compile phase, accumulate the length
       of the extra data and reset the pointer. This is so that very large
       classes that contain a zillion wide characters or Unicode property tests
       do not overwrite the workspace (which is on the stack). */
 
       if (class_uchardata > class_uchardata_base)
         {
         xclass = TRUE;
         if (lengthptr != NULL)
           {
           *lengthptr += class_uchardata - class_uchardata_base;
           class_uchardata = class_uchardata_base;
           }
         }
 #endif
 
       continue;  /* Needed to avoid error when not supporting wide chars */
       }   /* End of main class-processing loop */
 
     /* If this class is the first thing in the branch, there can be no first
     char setting, whatever the repeat count. Any reqcu setting must remain
     unchanged after any kind of repeat. */
 
     if (firstcuflags == REQ_UNSET) firstcuflags = REQ_NONE;
     zerofirstcu = firstcu;
     zerofirstcuflags = firstcuflags;
     zeroreqcu = reqcu;
     zeroreqcuflags = reqcuflags;
 
     /* If there are characters with values > 255, or Unicode property settings
     (\p or \P), we have to compile an extended class, with its own opcode,
     unless there were no property settings and there was a negated special such
     as \S in the class, and PCRE2_UCP is not set, because in that case all
     characters > 255 are in or not in the class, so any that were explicitly
     given as well can be ignored.
 
     In the UCP case, if certain negated POSIX classes ([:^ascii:] or
     [^:xdigit:]) were present in a class, we either have to match or not match
     all wide characters (depending on whether the whole class is or is not
     negated). This requirement is indicated by match_all_or_no_wide_chars being
     true. We do this by including an explicit range, which works in both cases.
     This applies only in UTF and 16-bit and 32-bit non-UTF modes, since there
     cannot be any wide characters in 8-bit non-UTF mode.
 
     When there *are* properties in a positive UTF-8 or any 16-bit or 32_bit
     class where \S etc is present without PCRE2_UCP, causing an extended class
     to be compiled, we make sure that all characters > 255 are included by
     forcing match_all_or_no_wide_chars to be true.
 
     If, when generating an xclass, there are no characters < 256, we can omit
     the bitmap in the actual compiled code. */
 
 #ifdef SUPPORT_WIDE_CHARS  /* Defined for 16/32 bits, or 8-bit with Unicode */
     if (xclass && (
 #ifdef SUPPORT_UNICODE
         (options & PCRE2_UCP) != 0 ||
 #endif
         xclass_has_prop || !should_flip_negation))
       {
       if (match_all_or_no_wide_chars || (
 #if PCRE2_CODE_UNIT_WIDTH == 8
            utf &&
 #endif
            should_flip_negation && !negate_class && (options & PCRE2_UCP) == 0))
         {
         *class_uchardata++ = XCL_RANGE;
         if (utf)   /* Will always be utf in the 8-bit library */
           {
           class_uchardata += PRIV(ord2utf)(0x100, class_uchardata);
           class_uchardata += PRIV(ord2utf)(MAX_UTF_CODE_POINT, class_uchardata);
           }
         else       /* Can only happen for the 16-bit & 32-bit libraries */
           {
 #if PCRE2_CODE_UNIT_WIDTH == 16
           *class_uchardata++ = 0x100;
           *class_uchardata++ = 0xffffu;
 #elif PCRE2_CODE_UNIT_WIDTH == 32
           *class_uchardata++ = 0x100;
           *class_uchardata++ = 0xffffffffu;
 #endif
           }
         }
       *class_uchardata++ = XCL_END;    /* Marks the end of extra data */
       *code++ = OP_XCLASS;
       code += LINK_SIZE;
       *code = negate_class? XCL_NOT:0;
       if (xclass_has_prop) *code |= XCL_HASPROP;
 
       /* If the map is required, move up the extra data to make room for it;
       otherwise just move the code pointer to the end of the extra data. */
 
       if (class_has_8bitchar > 0)
         {
         *code++ |= XCL_MAP;
         (void)memmove(code + (32 / sizeof(PCRE2_UCHAR)), code,
           CU2BYTES(class_uchardata - code));
         if (negate_class && !xclass_has_prop)
           {
           /* Using 255 ^ instead of ~ avoids clang sanitize warning. */
           for (i = 0; i < 32; i++) classbits[i] = 255 ^ classbits[i];
           }
         memcpy(code, classbits, 32);
         code = class_uchardata + (32 / sizeof(PCRE2_UCHAR));
         }
       else code = class_uchardata;
 
       /* Now fill in the complete length of the item */
 
       PUT(previous, 1, (int)(code - previous));
       break;   /* End of class handling */
       }
 #endif  /* SUPPORT_WIDE_CHARS */
 
     /* If there are no characters > 255, or they are all to be included or
     excluded, set the opcode to OP_CLASS or OP_NCLASS, depending on whether the
     whole class was negated and whether there were negative specials such as \S
     (non-UCP) in the class. Then copy the 32-byte map into the code vector,
     negating it if necessary. */
 
     *code++ = (negate_class == should_flip_negation) ? OP_CLASS : OP_NCLASS;
     if (lengthptr == NULL)    /* Save time in the pre-compile phase */
       {
       if (negate_class)
         {
        /* Using 255 ^ instead of ~ avoids clang sanitize warning. */
        for (i = 0; i < 32; i++) classbits[i] = 255 ^ classbits[i];
        }
       memcpy(code, classbits, 32);
       }
     code += 32 / sizeof(PCRE2_UCHAR);
     break;  /* End of class processing */
 
 
     /* ===================================================================*/
     /* Deal with (*VERB)s. */
 
     /* Check for open captures before ACCEPT and close those that are within
     the same assertion level, also converting ACCEPT to ASSERT_ACCEPT in an
     assertion. In the first pass, just accumulate the length required;
     otherwise hitting (*ACCEPT) inside many nested parentheses can cause
     workspace overflow. Do not set firstcu after *ACCEPT. */
 
     case META_ACCEPT:
     cb->had_accept = had_accept = TRUE;
     for (oc = cb->open_caps;
          oc != NULL && oc->assert_depth >= cb->assert_depth;
          oc = oc->next)
       {
       if (lengthptr != NULL)
         {
         *lengthptr += CU2BYTES(1) + IMM2_SIZE;
         }
       else
         {
         *code++ = OP_CLOSE;
         PUT2INC(code, 0, oc->number);
         }
       }
     *code++ = (cb->assert_depth > 0)? OP_ASSERT_ACCEPT : OP_ACCEPT;
     if (firstcuflags == REQ_UNSET) firstcuflags = REQ_NONE;
     break;
 
     case META_PRUNE:
     case META_SKIP:
     cb->had_pruneorskip = TRUE;
     /* Fall through */
     case META_COMMIT:
     case META_FAIL:
     *code++ = verbops[(meta - META_MARK) >> 16];
     break;
 
     case META_THEN:
     cb->external_flags |= PCRE2_HASTHEN;
     *code++ = OP_THEN;
     break;
 
     /* Handle verbs with arguments. Arguments can be very long, especially in
     16- and 32-bit modes, and can overflow the workspace in the first pass.
     However, the argument length is constrained to be small enough to fit in
     one code unit. This check happens in parse_regex(). In the first pass,
     instead of putting the argument into memory, we just update the length
     counter and set up an empty argument. */
 
     case META_THEN_ARG:
     cb->external_flags |= PCRE2_HASTHEN;
     goto VERB_ARG;
 
     case META_PRUNE_ARG:
     case META_SKIP_ARG:
     cb->had_pruneorskip = TRUE;
     /* Fall through */
     case META_MARK:
     case META_COMMIT_ARG:
     VERB_ARG:
     *code++ = verbops[(meta - META_MARK) >> 16];
     /* The length is in characters. */
     verbarglen = *(++pptr);
     verbculen = 0;
     tempcode = code++;
     for (i = 0; i < (int)verbarglen; i++)
       {
       meta = *(++pptr);
 #ifdef SUPPORT_UNICODE
       if (utf) mclength = PRIV(ord2utf)(meta, mcbuffer); else
 #endif
         {
         mclength = 1;
         mcbuffer[0] = meta;
         }
       if (lengthptr != NULL) *lengthptr += mclength; else
         {
         memcpy(code, mcbuffer, CU2BYTES(mclength));
         code += mclength;
         verbculen += mclength;
         }
       }
 
     *tempcode = verbculen;   /* Fill in the code unit length */
     *code++ = 0;             /* Terminating zero */
     break;
 
 
     /* ===================================================================*/
     /* Handle options change. The new setting must be passed back for use in
     subsequent branches. Reset the greedy defaults and the case value for
     firstcu and reqcu. */
 
     case META_OPTIONS:
     *optionsptr = options = *(++pptr);
     greedy_default = ((options & PCRE2_UNGREEDY) != 0);
     greedy_non_default = greedy_default ^ 1;
     req_caseopt = ((options & PCRE2_CASELESS) != 0)? REQ_CASELESS : 0;
     break;
 
 
     /* ===================================================================*/
     /* Handle conditional subpatterns. The case of (?(Rdigits) is ambiguous
     because it could be a numerical check on recursion, or a name check on a
     group's being set. The pre-pass sets up META_COND_RNUMBER as a name so that
     we can handle it either way. We first try for a name; if not found, process
     the number. */
 
     case META_COND_RNUMBER:   /* (?(Rdigits) */
     case META_COND_NAME:      /* (?(name) or (?'name') or ?(<name>) */
     case META_COND_RNAME:     /* (?(R&name) - test for recursion */
     bravalue = OP_COND;
       {
       int count, index;
       PCRE2_SPTR name;
       named_group *ng = cb->named_groups;
       uint32_t length = *(++pptr);
 
       GETPLUSOFFSET(offset, pptr);
       name = cb->start_pattern + offset;
 
       /* In the first pass, the names generated in the pre-pass are available,
       but the main name table has not yet been created. Scan the list of names
       generated in the pre-pass in order to get a number and whether or not
       this name is duplicated. If it is not duplicated, we can handle it as a
       numerical group. */
 
       for (i = 0; i < cb->names_found; i++, ng++)
         {
         if (length == ng->length &&
             PRIV(strncmp)(name, ng->name, length) == 0)
           {
           if (!ng->isdup)
             {
             code[1+LINK_SIZE] = (meta == META_COND_RNAME)? OP_RREF : OP_CREF;
             PUT2(code, 2+LINK_SIZE, ng->number);
             if (ng->number > cb->top_backref) cb->top_backref = ng->number;
             skipunits = 1+IMM2_SIZE;
             goto GROUP_PROCESS_NOTE_EMPTY;
             }
           break;  /* Found a duplicated name */
           }
         }
 
       /* If the name was not found we have a bad reference, unless we are
       dealing with R<digits>, which is treated as a recursion test by number.
       */
 
       if (i >= cb->names_found)
         {
         groupnumber = 0;
         if (meta == META_COND_RNUMBER)
           {
           for (i = 1; i < (int)length; i++)
             {
             groupnumber = groupnumber * 10 + name[i] - CHAR_0;
             if (groupnumber > MAX_GROUP_NUMBER)
               {
               *errorcodeptr = ERR61;
               cb->erroroffset = offset + i;
               return 0;
               }
             }
           }
 
         if (meta != META_COND_RNUMBER || groupnumber > cb->bracount)
           {
           *errorcodeptr = ERR15;
           cb->erroroffset = offset;
           return 0;
           }
 
         /* (?Rdigits) treated as a recursion reference by number. A value of
         zero (which is the result of both (?R) and (?R0)) means "any", and is
         translated into RREF_ANY (which is 0xffff). */
 
         if (groupnumber == 0) groupnumber = RREF_ANY;
         code[1+LINK_SIZE] = OP_RREF;
         PUT2(code, 2+LINK_SIZE, groupnumber);
         skipunits = 1+IMM2_SIZE;
         goto GROUP_PROCESS_NOTE_EMPTY;
         }
 
       /* A duplicated name was found. Note that if an R<digits> name is found
       (META_COND_RNUMBER), it is a reference test, not a recursion test. */
 
       code[1+LINK_SIZE] = (meta == META_COND_RNAME)? OP_RREF : OP_CREF;
 
       /* We have a duplicated name. In the compile pass we have to search the
       main table in order to get the index and count values. */
 
       count = 0;  /* Values for first pass (avoids compiler warning) */
       index = 0;
       if (lengthptr == NULL && !find_dupname_details(name, length, &index,
             &count, errorcodeptr, cb)) return 0;
 
       /* Add one to the opcode to change CREF/RREF into DNCREF/DNRREF and
       insert appropriate data values. */
 
       code[1+LINK_SIZE]++;
       skipunits = 1+2*IMM2_SIZE;
       PUT2(code, 2+LINK_SIZE, index);
       PUT2(code, 2+LINK_SIZE+IMM2_SIZE, count);
       }
     goto GROUP_PROCESS_NOTE_EMPTY;
 
     /* The DEFINE condition is always false. Its internal groups may never
     be called, so matched_char must remain false, hence the jump to
     GROUP_PROCESS rather than GROUP_PROCESS_NOTE_EMPTY. */
 
     case META_COND_DEFINE:
     bravalue = OP_COND;
     GETPLUSOFFSET(offset, pptr);
     code[1+LINK_SIZE] = OP_DEFINE;
     skipunits = 1;
     goto GROUP_PROCESS;
 
     /* Conditional test of a group's being set. */
 
     case META_COND_NUMBER:
     bravalue = OP_COND;
     GETPLUSOFFSET(offset, pptr);
     groupnumber = *(++pptr);
     if (groupnumber > cb->bracount)
       {
       *errorcodeptr = ERR15;
       cb->erroroffset = offset;
       return 0;
       }
     if (groupnumber > cb->top_backref) cb->top_backref = groupnumber;
     offset -= 2;   /* Point at initial ( for too many branches error */
     code[1+LINK_SIZE] = OP_CREF;
     skipunits = 1+IMM2_SIZE;
     PUT2(code, 2+LINK_SIZE, groupnumber);
     goto GROUP_PROCESS_NOTE_EMPTY;
 
     /* Test for the PCRE2 version. */
 
     case META_COND_VERSION:
     bravalue = OP_COND;
     if (pptr[1] > 0)
       code[1+LINK_SIZE] = ((PCRE2_MAJOR > pptr[2]) ||
         (PCRE2_MAJOR == pptr[2] && PCRE2_MINOR >= pptr[3]))?
           OP_TRUE : OP_FALSE;
     else
       code[1+LINK_SIZE] = (PCRE2_MAJOR == pptr[2] && PCRE2_MINOR == pptr[3])?
         OP_TRUE : OP_FALSE;
     skipunits = 1;
     pptr += 3;
     goto GROUP_PROCESS_NOTE_EMPTY;
 
     /* The condition is an assertion, possibly preceded by a callout. */
 
     case META_COND_ASSERT:
     bravalue = OP_COND;
     goto GROUP_PROCESS_NOTE_EMPTY;
 
 
     /* ===================================================================*/
     /* Handle all kinds of nested bracketed groups. The non-capturing,
     non-conditional cases are here; others come to GROUP_PROCESS via goto. */
 
     case META_LOOKAHEAD:
     bravalue = OP_ASSERT;
     cb->assert_depth += 1;
     goto GROUP_PROCESS;
 
     case META_LOOKAHEAD_NA:
     bravalue = OP_ASSERT_NA;
     cb->assert_depth += 1;
     goto GROUP_PROCESS;
 
     /* Optimize (?!) to (*FAIL) unless it is quantified - which is a weird
     thing to do, but Perl allows all assertions to be quantified, and when
     they contain capturing parentheses there may be a potential use for
     this feature. Not that that applies to a quantified (?!) but we allow
     it for uniformity. */
 
     case META_LOOKAHEADNOT:
     if (pptr[1] == META_KET &&
          (pptr[2] < META_ASTERISK || pptr[2] > META_MINMAX_QUERY))
       {
       *code++ = OP_FAIL;
       pptr++;
       }
     else
       {
       bravalue = OP_ASSERT_NOT;
       cb->assert_depth += 1;
       goto GROUP_PROCESS;
       }
     break;
 
     case META_LOOKBEHIND:
     bravalue = OP_ASSERTBACK;
     cb->assert_depth += 1;
     goto GROUP_PROCESS;
 
     case META_LOOKBEHINDNOT:
     bravalue = OP_ASSERTBACK_NOT;
     cb->assert_depth += 1;
     goto GROUP_PROCESS;
 
     case META_LOOKBEHIND_NA:
     bravalue = OP_ASSERTBACK_NA;
     cb->assert_depth += 1;
     goto GROUP_PROCESS;
 
     case META_ATOMIC:
     bravalue = OP_ONCE;
     goto GROUP_PROCESS_NOTE_EMPTY;
 
     case META_SCRIPT_RUN:
     bravalue = OP_SCRIPT_RUN;
     goto GROUP_PROCESS_NOTE_EMPTY;
 
     case META_NOCAPTURE:
     bravalue = OP_BRA;
     /* Fall through */
 
     /* Process nested bracketed regex. The nesting depth is maintained for the
     benefit of the stackguard function. The test for too deep nesting is now
     done in parse_regex(). Assertion and DEFINE groups come to GROUP_PROCESS;
     others come to GROUP_PROCESS_NOTE_EMPTY, to indicate that we need to take
     note of whether or not they may match an empty string. */
 
     GROUP_PROCESS_NOTE_EMPTY:
     note_group_empty = TRUE;
 
     GROUP_PROCESS:
     cb->parens_depth += 1;
     *code = bravalue;
     pptr++;
     tempcode = code;
     tempreqvary = cb->req_varyopt;        /* Save value before group */
     length_prevgroup = 0;                 /* Initialize for pre-compile phase */
 
     if ((group_return =
          compile_regex(
          options,                         /* The option state */
          &tempcode,                       /* Where to put code (updated) */
          &pptr,                           /* Input pointer (updated) */
          errorcodeptr,                    /* Where to put an error message */
          skipunits,                       /* Skip over bracket number */
          &subfirstcu,                     /* For possible first char */
          &subfirstcuflags,
          &subreqcu,                       /* For possible last char */
          &subreqcuflags,
          bcptr,                           /* Current branch chain */
          cb,                              /* Compile data block */
          (lengthptr == NULL)? NULL :      /* Actual compile phase */
            &length_prevgroup              /* Pre-compile phase */
          )) == 0)
       return 0;  /* Error */
 
     cb->parens_depth -= 1;
 
     /* If that was a non-conditional significant group (not an assertion, not a
     DEFINE) that matches at least one character, then the current item matches
     a character. Conditionals are handled below. */
 
     if (note_group_empty && bravalue != OP_COND && group_return > 0)
       matched_char = TRUE;
 
     /* If we've just compiled an assertion, pop the assert depth. */
 
     if (bravalue >= OP_ASSERT && bravalue <= OP_ASSERTBACK_NA)
       cb->assert_depth -= 1;
 
     /* At the end of compiling, code is still pointing to the start of the
     group, while tempcode has been updated to point past the end of the group.
     The parsed pattern pointer (pptr) is on the closing META_KET.
 
     If this is a conditional bracket, check that there are no more than
     two branches in the group, or just one if it's a DEFINE group. We do this
     in the real compile phase, not in the pre-pass, where the whole group may
     not be available. */
 
     if (bravalue == OP_COND && lengthptr == NULL)
       {
       PCRE2_UCHAR *tc = code;
       int condcount = 0;
 
       do {
          condcount++;
          tc += GET(tc,1);
          }
       while (*tc != OP_KET);
 
       /* A DEFINE group is never obeyed inline (the "condition" is always
       false). It must have only one branch. Having checked this, change the
       opcode to OP_FALSE. */
 
       if (code[LINK_SIZE+1] == OP_DEFINE)
         {
         if (condcount > 1)
           {
           cb->erroroffset = offset;
           *errorcodeptr = ERR54;
           return 0;
           }
         code[LINK_SIZE+1] = OP_FALSE;
         bravalue = OP_DEFINE;   /* A flag to suppress char handling below */
         }
 
       /* A "normal" conditional group. If there is just one branch, we must not
       make use of its firstcu or reqcu, because this is equivalent to an
       empty second branch. Also, it may match an empty string. If there are two
       branches, this item must match a character if the group must. */
 
       else
         {
         if (condcount > 2)
           {
           cb->erroroffset = offset;
           *errorcodeptr = ERR27;
           return 0;
           }
         if (condcount == 1) subfirstcuflags = subreqcuflags = REQ_NONE;
           else if (group_return > 0) matched_char = TRUE;
         }
       }
 
     /* In the pre-compile phase, update the length by the length of the group,
     less the brackets at either end. Then reduce the compiled code to just a
     set of non-capturing brackets so that it doesn't use much memory if it is
     duplicated by a quantifier.*/
 
     if (lengthptr != NULL)
       {
       if (OFLOW_MAX - *lengthptr < length_prevgroup - 2 - 2*LINK_SIZE)
         {
         *errorcodeptr = ERR20;
         return 0;
         }
       *lengthptr += length_prevgroup - 2 - 2*LINK_SIZE;
       code++;   /* This already contains bravalue */
       PUTINC(code, 0, 1 + LINK_SIZE);
       *code++ = OP_KET;
       PUTINC(code, 0, 1 + LINK_SIZE);
       break;    /* No need to waste time with special character handling */
       }
 
     /* Otherwise update the main code pointer to the end of the group. */
 
     code = tempcode;
 
     /* For a DEFINE group, required and first character settings are not
     relevant. */
 
     if (bravalue == OP_DEFINE) break;
 
     /* Handle updating of the required and first code units for other types of
     group. Update for normal brackets of all kinds, and conditions with two
     branches (see code above). If the bracket is followed by a quantifier with
     zero repeat, we have to back off. Hence the definition of zeroreqcu and
     zerofirstcu outside the main loop so that they can be accessed for the back
     off. */
 
     zeroreqcu = reqcu;
     zeroreqcuflags = reqcuflags;
     zerofirstcu = firstcu;
     zerofirstcuflags = firstcuflags;
     groupsetfirstcu = FALSE;
 
     if (bravalue >= OP_ONCE)  /* Not an assertion */
       {
       /* If we have not yet set a firstcu in this branch, take it from the
       subpattern, remembering that it was set here so that a repeat of more
       than one can replicate it as reqcu if necessary. If the subpattern has
       no firstcu, set "none" for the whole branch. In both cases, a zero
       repeat forces firstcu to "none". */
 
       if (firstcuflags == REQ_UNSET && subfirstcuflags != REQ_UNSET)
         {
         if (subfirstcuflags >= 0)
           {
           firstcu = subfirstcu;
           firstcuflags = subfirstcuflags;
           groupsetfirstcu = TRUE;
           }
         else firstcuflags = REQ_NONE;
         zerofirstcuflags = REQ_NONE;
         }
 
       /* If firstcu was previously set, convert the subpattern's firstcu
       into reqcu if there wasn't one, using the vary flag that was in
       existence beforehand. */
 
       else if (subfirstcuflags >= 0 && subreqcuflags < 0)
         {
         subreqcu = subfirstcu;
         subreqcuflags = subfirstcuflags | tempreqvary;
         }
 
       /* If the subpattern set a required code unit (or set a first code unit
       that isn't really the first code unit - see above), set it. */
 
       if (subreqcuflags >= 0)
         {
         reqcu = subreqcu;
         reqcuflags = subreqcuflags;
         }
       }
 
     /* For a forward assertion, we take the reqcu, if set, provided that the
     group has also set a firstcu. This can be helpful if the pattern that
     follows the assertion doesn't set a different char. For example, it's
     useful for /(?=abcde).+/. We can't set firstcu for an assertion, however
     because it leads to incorrect effect for patterns such as /(?=a)a.+/ when
     the "real" "a" would then become a reqcu instead of a firstcu. This is
     overcome by a scan at the end if there's no firstcu, looking for an
     asserted first char. A similar effect for patterns like /(?=.*X)X$/ means
     we must only take the reqcu when the group also set a firstcu. Otherwise,
     in that example, 'X' ends up set for both. */
 
     else if ((bravalue == OP_ASSERT || bravalue == OP_ASSERT_NA) &&
              subreqcuflags >= 0 && subfirstcuflags >= 0)
       {
       reqcu = subreqcu;
       reqcuflags = subreqcuflags;
       }
 
     break;  /* End of nested group handling */
 
 
     /* ===================================================================*/
     /* Handle named backreferences and recursions. */
 
     case META_BACKREF_BYNAME:
     case META_RECURSE_BYNAME:
       {
       int count, index;
       PCRE2_SPTR name;
       BOOL is_dupname = FALSE;
       named_group *ng = cb->named_groups;
       uint32_t length = *(++pptr);
 
       GETPLUSOFFSET(offset, pptr);
       name = cb->start_pattern + offset;
 
       /* In the first pass, the names generated in the pre-pass are available,
       but the main name table has not yet been created. Scan the list of names
       generated in the pre-pass in order to get a number and whether or not
       this name is duplicated. */
 
       groupnumber = 0;
       for (i = 0; i < cb->names_found; i++, ng++)
         {
         if (length == ng->length &&
             PRIV(strncmp)(name, ng->name, length) == 0)
           {
           is_dupname = ng->isdup;
           groupnumber = ng->number;
 
           /* For a recursion, that's all that is needed. We can now go to
           the code that handles numerical recursion, applying it to the first
           group with the given name. */
 
           if (meta == META_RECURSE_BYNAME)
             {
             meta_arg = groupnumber;
             goto HANDLE_NUMERICAL_RECURSION;
             }
 
           /* For a back reference, update the back reference map and the
           maximum back reference. Then, for each group, we must check to
           see if it is recursive, that is, it is inside the group that it
           references. A flag is set so that the group can be made atomic.
           */
 
           cb->backref_map |= (groupnumber < 32)? (1u << groupnumber) : 1;
           if (groupnumber > cb->top_backref)
             cb->top_backref = groupnumber;
 
           for (oc = cb->open_caps; oc != NULL; oc = oc->next)
             {
             if (oc->number == groupnumber)
               {
               oc->flag = TRUE;
               break;
               }
             }
           }
         }
 
       /* If the name was not found we have a bad reference. */
 
       if (groupnumber == 0)
         {
         *errorcodeptr = ERR15;
         cb->erroroffset = offset;
         return 0;
         }
 
       /* If a back reference name is not duplicated, we can handle it as
       a numerical reference. */
 
       if (!is_dupname)
         {
         meta_arg = groupnumber;
         goto HANDLE_SINGLE_REFERENCE;
         }
 
       /* If a back reference name is duplicated, we generate a different
       opcode to a numerical back reference. In the second pass we must
       search for the index and count in the final name table. */
 
       count = 0;  /* Values for first pass (avoids compiler warning) */
       index = 0;
       if (lengthptr == NULL && !find_dupname_details(name, length, &index,
             &count, errorcodeptr, cb)) return 0;
 
       if (firstcuflags == REQ_UNSET) firstcuflags = REQ_NONE;
       *code++ = ((options & PCRE2_CASELESS) != 0)? OP_DNREFI : OP_DNREF;
       PUT2INC(code, 0, index);
       PUT2INC(code, 0, count);
       }
     break;
 
 
     /* ===================================================================*/
     /* Handle a numerical callout. */
 
     case META_CALLOUT_NUMBER:
     code[0] = OP_CALLOUT;
     PUT(code, 1, pptr[1]);               /* Offset to next pattern item */
     PUT(code, 1 + LINK_SIZE, pptr[2]);   /* Length of next pattern item */
     code[1 + 2*LINK_SIZE] = pptr[3];
     pptr += 3;
     code += PRIV(OP_lengths)[OP_CALLOUT];
     break;
 
 
     /* ===================================================================*/
     /* Handle a callout with a string argument. In the pre-pass we just compute
     the length without generating anything. The length in pptr[3] includes both
     delimiters; in the actual compile only the first one is copied, but a
     terminating zero is added. Any doubled delimiters within the string make
     this an overestimate, but it is not worth bothering about. */
 
     case META_CALLOUT_STRING:
     if (lengthptr != NULL)
       {
       *lengthptr += pptr[3] + (1 + 4*LINK_SIZE);
       pptr += 3;
       SKIPOFFSET(pptr);
       }
 
     /* In the real compile we can copy the string. The starting delimiter is
      included so that the client can discover it if they want. We also pass the
      start offset to help a script language give better error messages. */
 
     else
       {
       PCRE2_SPTR pp;
       uint32_t delimiter;
       uint32_t length = pptr[3];
       PCRE2_UCHAR *callout_string = code + (1 + 4*LINK_SIZE);
 
       code[0] = OP_CALLOUT_STR;
       PUT(code, 1, pptr[1]);               /* Offset to next pattern item */
       PUT(code, 1 + LINK_SIZE, pptr[2]);   /* Length of next pattern item */
 
       pptr += 3;
       GETPLUSOFFSET(offset, pptr);         /* Offset to string in pattern */
       pp = cb->start_pattern + offset;
       delimiter = *callout_string++ = *pp++;
       if (delimiter == CHAR_LEFT_CURLY_BRACKET)
         delimiter = CHAR_RIGHT_CURLY_BRACKET;
       PUT(code, 1 + 3*LINK_SIZE, (int)(offset + 1));  /* One after delimiter */
 
       /* The syntax of the pattern was checked in the parsing scan. The length
       includes both delimiters, but we have passed the opening one just above,
       so we reduce length before testing it. The test is for > 1 because we do
       not want to copy the final delimiter. This also ensures that pp[1] is
       accessible. */
 
       while (--length > 1)
         {
         if (*pp == delimiter && pp[1] == delimiter)
           {
           *callout_string++ = delimiter;
           pp += 2;
           length--;
           }
         else *callout_string++ = *pp++;
         }
       *callout_string++ = CHAR_NUL;
 
       /* Set the length of the entire item, the advance to its end. */
 
       PUT(code, 1 + 2*LINK_SIZE, (int)(callout_string - code));
       code = callout_string;
       }
     break;
 
 
     /* ===================================================================*/
     /* Handle repetition. The different types are all sorted out in the parsing
     pass. */
 
     case META_MINMAX_PLUS:
     case META_MINMAX_QUERY:
     case META_MINMAX:
     repeat_min = *(++pptr);
     repeat_max = *(++pptr);
     goto REPEAT;
 
     case META_ASTERISK:
     case META_ASTERISK_PLUS:
     case META_ASTERISK_QUERY:
     repeat_min = 0;
     repeat_max = REPEAT_UNLIMITED;
     goto REPEAT;
 
     case META_PLUS:
     case META_PLUS_PLUS:
     case META_PLUS_QUERY:
     repeat_min = 1;
     repeat_max = REPEAT_UNLIMITED;
     goto REPEAT;
 
     case META_QUERY:
     case META_QUERY_PLUS:
     case META_QUERY_QUERY:
     repeat_min = 0;
     repeat_max = 1;
 
     REPEAT:
     if (previous_matched_char && repeat_min > 0) matched_char = TRUE;
 
     /* Remember whether this is a variable length repeat, and default to
     single-char opcodes. */
 
     reqvary = (repeat_min == repeat_max)? 0 : REQ_VARY;
     op_type = 0;
 
     /* Adjust first and required code units for a zero repeat. */
 
     if (repeat_min == 0)
       {
       firstcu = zerofirstcu;
       firstcuflags = zerofirstcuflags;
       reqcu = zeroreqcu;
       reqcuflags = zeroreqcuflags;
       }
 
     /* Note the greediness and possessiveness. */
 
     switch (meta)
       {
       case META_MINMAX_PLUS:
       case META_ASTERISK_PLUS:
       case META_PLUS_PLUS:
       case META_QUERY_PLUS:
       repeat_type = 0;                  /* Force greedy */
       possessive_quantifier = TRUE;
       break;
 
       case META_MINMAX_QUERY:
       case META_ASTERISK_QUERY:
       case META_PLUS_QUERY:
       case META_QUERY_QUERY:
       repeat_type = greedy_non_default;
       possessive_quantifier = FALSE;
       break;
 
       default:
       repeat_type = greedy_default;
       possessive_quantifier = FALSE;
       break;
       }
 
     /* Save start of previous item, in case we have to move it up in order to
     insert something before it, and remember what it was. */
 
     tempcode = previous;
     op_previous = *previous;
 
     /* Now handle repetition for the different types of item. If the repeat
     minimum and the repeat maximum are both 1, we can ignore the quantifier for
     non-parenthesized items, as they have only one alternative. For anything in
     parentheses, we must not ignore if {1} is possessive. */
 
     switch (op_previous)
       {
       /* If previous was a character or negated character match, abolish the
       item and generate a repeat item instead. If a char item has a minimum of
       more than one, ensure that it is set in reqcu - it might not be if a
       sequence such as x{3} is the first thing in a branch because the x will
       have gone into firstcu instead.  */
 
       case OP_CHAR:
       case OP_CHARI:
       case OP_NOT:
       case OP_NOTI:
       if (repeat_max == 1 && repeat_min == 1) goto END_REPEAT;
       op_type = chartypeoffset[op_previous - OP_CHAR];
 
       /* Deal with UTF characters that take up more than one code unit. */
 
 #ifdef MAYBE_UTF_MULTI
       if (utf && NOT_FIRSTCU(code[-1]))
         {
         PCRE2_UCHAR *lastchar = code - 1;
         BACKCHAR(lastchar);
         mclength = (uint32_t)(code - lastchar);   /* Length of UTF character */
         memcpy(mcbuffer, lastchar, CU2BYTES(mclength));  /* Save the char */
         }
       else
 #endif  /* MAYBE_UTF_MULTI */
 
       /* Handle the case of a single code unit - either with no UTF support, or
       with UTF disabled, or for a single-code-unit UTF character. */
         {
         mcbuffer[0] = code[-1];
         mclength = 1;
         if (op_previous <= OP_CHARI && repeat_min > 1)
           {
           reqcu = mcbuffer[0];
           reqcuflags = req_caseopt | cb->req_varyopt;
           }
         }
       goto OUTPUT_SINGLE_REPEAT;  /* Code shared with single character types */
 
       /* If previous was a character class or a back reference, we put the
       repeat stuff after it, but just skip the item if the repeat was {0,0}. */
 
 #ifdef SUPPORT_WIDE_CHARS
       case OP_XCLASS:
 #endif
       case OP_CLASS:
       case OP_NCLASS:
       case OP_REF:
       case OP_REFI:
       case OP_DNREF:
       case OP_DNREFI:
 
       if (repeat_max == 0)
         {
         code = previous;
         goto END_REPEAT;
         }
       if (repeat_max == 1 && repeat_min == 1) goto END_REPEAT;
 
       if (repeat_min == 0 && repeat_max == REPEAT_UNLIMITED)
         *code++ = OP_CRSTAR + repeat_type;
       else if (repeat_min == 1 && repeat_max == REPEAT_UNLIMITED)
         *code++ = OP_CRPLUS + repeat_type;
       else if (repeat_min == 0 && repeat_max == 1)
         *code++ = OP_CRQUERY + repeat_type;
       else
         {
         *code++ = OP_CRRANGE + repeat_type;
         PUT2INC(code, 0, repeat_min);
         if (repeat_max == REPEAT_UNLIMITED) repeat_max = 0;  /* 2-byte encoding for max */
         PUT2INC(code, 0, repeat_max);
         }
       break;
 
       /* If previous is OP_FAIL, it was generated by an empty class []
       (PCRE2_ALLOW_EMPTY_CLASS is set). The other ways in which OP_FAIL can be
       generated, that is by (*FAIL) or (?!), disallow a quantifier at parse
       time. We can just ignore this repeat. */
 
       case OP_FAIL:
       goto END_REPEAT;
 
       /* Prior to 10.30, repeated recursions were wrapped in OP_ONCE brackets
       because pcre2_match() could not handle backtracking into recursively
       called groups. Now that this backtracking is available, we no longer need
       to do this. However, we still need to replicate recursions as we do for
       groups so as to have independent backtracking points. We can replicate
       for the minimum number of repeats directly. For optional repeats we now
       wrap the recursion in OP_BRA brackets and make use of the bracket
       repetition. */
 
       case OP_RECURSE:
       if (repeat_max == 1 && repeat_min == 1 && !possessive_quantifier)
         goto END_REPEAT;
 
       /* Generate unwrapped repeats for a non-zero minimum, except when the
       minimum is 1 and the maximum unlimited, because that can be handled with
       OP_BRA terminated by OP_KETRMAX/MIN. When the maximum is equal to the
       minimum, we just need to generate the appropriate additional copies.
       Otherwise we need to generate one more, to simulate the situation when
       the minimum is zero. */
 
       if (repeat_min > 0 && (repeat_min != 1 || repeat_max != REPEAT_UNLIMITED))
         {
         int replicate = repeat_min;
         if (repeat_min == repeat_max) replicate--;
 
         /* In the pre-compile phase, we don't actually do the replication. We
         just adjust the length as if we had. Do some paranoid checks for
         potential integer overflow. The INT64_OR_DOUBLE type is a 64-bit
         integer type when available, otherwise double. */
 
         if (lengthptr != NULL)
           {
           PCRE2_SIZE delta = replicate*(1 + LINK_SIZE);
           if ((INT64_OR_DOUBLE)replicate*
                 (INT64_OR_DOUBLE)(1 + LINK_SIZE) >
                   (INT64_OR_DOUBLE)INT_MAX ||
               OFLOW_MAX - *lengthptr < delta)
             {
             *errorcodeptr = ERR20;
             return 0;
             }
           *lengthptr += delta;
           }
 
         else for (i = 0; i < replicate; i++)
           {
           memcpy(code, previous, CU2BYTES(1 + LINK_SIZE));
           previous = code;
           code += 1 + LINK_SIZE;
           }
 
         /* If the number of repeats is fixed, we are done. Otherwise, adjust
         the counts and fall through. */
 
         if (repeat_min == repeat_max) break;
         if (repeat_max != REPEAT_UNLIMITED) repeat_max -= repeat_min;
         repeat_min = 0;
         }
 
       /* Wrap the recursion call in OP_BRA brackets. */
 
       (void)memmove(previous + 1 + LINK_SIZE, previous, CU2BYTES(1 + LINK_SIZE));
       op_previous = *previous = OP_BRA;
       PUT(previous, 1, 2 + 2*LINK_SIZE);
       previous[2 + 2*LINK_SIZE] = OP_KET;
       PUT(previous, 3 + 2*LINK_SIZE, 2 + 2*LINK_SIZE);
       code += 2 + 2 * LINK_SIZE;
       length_prevgroup = 3 + 3*LINK_SIZE;
       group_return = -1;  /* Set "may match empty string" */
 
       /* Now treat as a repeated OP_BRA. */
       /* Fall through */
 
       /* If previous was a bracket group, we may have to replicate it in
       certain cases. Note that at this point we can encounter only the "basic"
       bracket opcodes such as BRA and CBRA, as this is the place where they get
       converted into the more special varieties such as BRAPOS and SBRA.
       Originally, PCRE did not allow repetition of assertions, but now it does,
       for Perl compatibility. */
 
       case OP_ASSERT:
       case OP_ASSERT_NOT:
       case OP_ASSERT_NA:
       case OP_ASSERTBACK:
       case OP_ASSERTBACK_NOT:
       case OP_ASSERTBACK_NA:
       case OP_ONCE:
       case OP_SCRIPT_RUN:
       case OP_BRA:
       case OP_CBRA:
       case OP_COND:
         {
         int len = (int)(code - previous);
         PCRE2_UCHAR *bralink = NULL;
         PCRE2_UCHAR *brazeroptr = NULL;
 
         if (repeat_max == 1 && repeat_min == 1 && !possessive_quantifier)
           goto END_REPEAT;
 
         /* Repeating a DEFINE group (or any group where the condition is always
         FALSE and there is only one branch) is pointless, but Perl allows the
         syntax, so we just ignore the repeat. */
 
         if (op_previous == OP_COND && previous[LINK_SIZE+1] == OP_FALSE &&
             previous[GET(previous, 1)] != OP_ALT)
           goto END_REPEAT;
 
         /* There is no sense in actually repeating assertions. The only
         potential use of repetition is in cases when the assertion is optional.
         Therefore, if the minimum is greater than zero, just ignore the repeat.
         If the maximum is not zero or one, set it to 1. */
 
         if (op_previous < OP_ONCE)    /* Assertion */
           {
           if (repeat_min > 0) goto END_REPEAT;
           if (repeat_max > 1) repeat_max = 1;
           }
 
         /* The case of a zero minimum is special because of the need to stick
         OP_BRAZERO in front of it, and because the group appears once in the
         data, whereas in other cases it appears the minimum number of times. For
         this reason, it is simplest to treat this case separately, as otherwise
         the code gets far too messy. There are several special subcases when the
         minimum is zero. */
 
         if (repeat_min == 0)
           {
           /* If the maximum is also zero, we used to just omit the group from
           the output altogether, like this:
 
           ** if (repeat_max == 0)
           **   {
           **   code = previous;
           **   goto END_REPEAT;
           **   }
 
           However, that fails when a group or a subgroup within it is
           referenced as a subroutine from elsewhere in the pattern, so now we
           stick in OP_SKIPZERO in front of it so that it is skipped on
           execution. As we don't have a list of which groups are referenced, we
           cannot do this selectively.
 
           If the maximum is 1 or unlimited, we just have to stick in the
           BRAZERO and do no more at this point. */
 
           if (repeat_max <= 1 || repeat_max == REPEAT_UNLIMITED)
             {
             (void)memmove(previous + 1, previous, CU2BYTES(len));
             code++;
             if (repeat_max == 0)
               {
               *previous++ = OP_SKIPZERO;
               goto END_REPEAT;
               }
             brazeroptr = previous;    /* Save for possessive optimizing */
             *previous++ = OP_BRAZERO + repeat_type;
             }
 
           /* If the maximum is greater than 1 and limited, we have to replicate
           in a nested fashion, sticking OP_BRAZERO before each set of brackets.
           The first one has to be handled carefully because it's the original
           copy, which has to be moved up. The remainder can be handled by code
           that is common with the non-zero minimum case below. We have to
           adjust the value or repeat_max, since one less copy is required. */
 
           else
             {
             int linkoffset;
             (void)memmove(previous + 2 + LINK_SIZE, previous, CU2BYTES(len));
             code += 2 + LINK_SIZE;
             *previous++ = OP_BRAZERO + repeat_type;
             *previous++ = OP_BRA;
 
             /* We chain together the bracket link offset fields that have to be
             filled in later when the ends of the brackets are reached. */
 
             linkoffset = (bralink == NULL)? 0 : (int)(previous - bralink);
             bralink = previous;
             PUTINC(previous, 0, linkoffset);
             }
 
           if (repeat_max != REPEAT_UNLIMITED) repeat_max--;
           }
 
         /* If the minimum is greater than zero, replicate the group as many
         times as necessary, and adjust the maximum to the number of subsequent
         copies that we need. */
 
         else
           {
           if (repeat_min > 1)
             {
             /* In the pre-compile phase, we don't actually do the replication.
             We just adjust the length as if we had. Do some paranoid checks for
             potential integer overflow. The INT64_OR_DOUBLE type is a 64-bit
             integer type when available, otherwise double. */
 
             if (lengthptr != NULL)
               {
               PCRE2_SIZE delta = (repeat_min - 1)*length_prevgroup;
               if ((INT64_OR_DOUBLE)(repeat_min - 1)*
                     (INT64_OR_DOUBLE)length_prevgroup >
                       (INT64_OR_DOUBLE)INT_MAX ||
                   OFLOW_MAX - *lengthptr < delta)
                 {
                 *errorcodeptr = ERR20;
                 return 0;
                 }
               *lengthptr += delta;
               }
 
             /* This is compiling for real. If there is a set first code unit
             for the group, and we have not yet set a "required code unit", set
             it. */
 
             else
               {
               if (groupsetfirstcu && reqcuflags < 0)
                 {
                 reqcu = firstcu;
                 reqcuflags = firstcuflags;
                 }
               for (i = 1; (uint32_t)i < repeat_min; i++)
                 {
                 memcpy(code, previous, CU2BYTES(len));
                 code += len;
                 }
               }
             }
 
           if (repeat_max != REPEAT_UNLIMITED) repeat_max -= repeat_min;
           }
 
         /* This code is common to both the zero and non-zero minimum cases. If
         the maximum is limited, it replicates the group in a nested fashion,
         remembering the bracket starts on a stack. In the case of a zero
         minimum, the first one was set up above. In all cases the repeat_max
         now specifies the number of additional copies needed. Again, we must
         remember to replicate entries on the forward reference list. */
 
         if (repeat_max != REPEAT_UNLIMITED)
           {
           /* In the pre-compile phase, we don't actually do the replication. We
           just adjust the length as if we had. For each repetition we must add
           1 to the length for BRAZERO and for all but the last repetition we
           must add 2 + 2*LINKSIZE to allow for the nesting that occurs. Do some
           paranoid checks to avoid integer overflow. The INT64_OR_DOUBLE type
           is a 64-bit integer type when available, otherwise double. */
 
           if (lengthptr != NULL && repeat_max > 0)
             {
             PCRE2_SIZE delta = repeat_max*(length_prevgroup + 1 + 2 + 2*LINK_SIZE) -
                         2 - 2*LINK_SIZE;   /* Last one doesn't nest */
             if ((INT64_OR_DOUBLE)repeat_max *
                   (INT64_OR_DOUBLE)(length_prevgroup + 1 + 2 + 2*LINK_SIZE)
                     > (INT64_OR_DOUBLE)INT_MAX ||
                 OFLOW_MAX - *lengthptr < delta)
               {
               *errorcodeptr = ERR20;
               return 0;
               }
             *lengthptr += delta;
             }
 
           /* This is compiling for real */
 
           else for (i = repeat_max - 1; i >= 0; i--)
             {
             *code++ = OP_BRAZERO + repeat_type;
 
             /* All but the final copy start a new nesting, maintaining the
             chain of brackets outstanding. */
 
             if (i != 0)
               {
               int linkoffset;
               *code++ = OP_BRA;
               linkoffset = (bralink == NULL)? 0 : (int)(code - bralink);
               bralink = code;
               PUTINC(code, 0, linkoffset);
               }
 
             memcpy(code, previous, CU2BYTES(len));
             code += len;
             }
 
           /* Now chain through the pending brackets, and fill in their length
           fields (which are holding the chain links pro tem). */
 
           while (bralink != NULL)
             {
             int oldlinkoffset;
             int linkoffset = (int)(code - bralink + 1);
             PCRE2_UCHAR *bra = code - linkoffset;
             oldlinkoffset = GET(bra, 1);
             bralink = (oldlinkoffset == 0)? NULL : bralink - oldlinkoffset;
             *code++ = OP_KET;
             PUTINC(code, 0, linkoffset);
             PUT(bra, 1, linkoffset);
             }
           }
 
         /* If the maximum is unlimited, set a repeater in the final copy. For
         SCRIPT_RUN and ONCE brackets, that's all we need to do. However,
         possessively repeated ONCE brackets can be converted into non-capturing
         brackets, as the behaviour of (?:xx)++ is the same as (?>xx)++ and this
         saves having to deal with possessive ONCEs specially.
 
         Otherwise, when we are doing the actual compile phase, check to see
         whether this group is one that could match an empty string. If so,
         convert the initial operator to the S form (e.g. OP_BRA -> OP_SBRA) so
         that runtime checking can be done. [This check is also applied to ONCE
         and SCRIPT_RUN groups at runtime, but in a different way.]
 
         Then, if the quantifier was possessive and the bracket is not a
         conditional, we convert the BRA code to the POS form, and the KET code
         to KETRPOS. (It turns out to be convenient at runtime to detect this
         kind of subpattern at both the start and at the end.) The use of
         special opcodes makes it possible to reduce greatly the stack usage in
         pcre2_match(). If the group is preceded by OP_BRAZERO, convert this to
         OP_BRAPOSZERO.
 
         Then, if the minimum number of matches is 1 or 0, cancel the possessive
         flag so that the default action below, of wrapping everything inside
         atomic brackets, does not happen. When the minimum is greater than 1,
         there will be earlier copies of the group, and so we still have to wrap
         the whole thing. */
 
         else
           {
           PCRE2_UCHAR *ketcode = code - 1 - LINK_SIZE;
           PCRE2_UCHAR *bracode = ketcode - GET(ketcode, 1);
 
           /* Convert possessive ONCE brackets to non-capturing */
 
           if (*bracode == OP_ONCE && possessive_quantifier) *bracode = OP_BRA;
 
           /* For non-possessive ONCE and for SCRIPT_RUN brackets, all we need
           to do is to set the KET. */
 
           if (*bracode == OP_ONCE || *bracode == OP_SCRIPT_RUN)
             *ketcode = OP_KETRMAX + repeat_type;
 
           /* Handle non-SCRIPT_RUN and non-ONCE brackets and possessive ONCEs
           (which have been converted to non-capturing above). */
 
           else
             {
             /* In the compile phase, adjust the opcode if the group can match
             an empty string. For a conditional group with only one branch, the
             value of group_return will not show "could be empty", so we must
             check that separately. */
 
             if (lengthptr == NULL)
               {
               if (group_return < 0) *bracode += OP_SBRA - OP_BRA;
               if (*bracode == OP_COND && bracode[GET(bracode,1)] != OP_ALT)
                 *bracode = OP_SCOND;
               }
 
             /* Handle possessive quantifiers. */
 
             if (possessive_quantifier)
               {
               /* For COND brackets, we wrap the whole thing in a possessively
               repeated non-capturing bracket, because we have not invented POS
               versions of the COND opcodes. */
 
               if (*bracode == OP_COND || *bracode == OP_SCOND)
                 {
                 int nlen = (int)(code - bracode);
                 (void)memmove(bracode + 1 + LINK_SIZE, bracode, CU2BYTES(nlen));
                 code += 1 + LINK_SIZE;
                 nlen += 1 + LINK_SIZE;
                 *bracode = (*bracode == OP_COND)? OP_BRAPOS : OP_SBRAPOS;
                 *code++ = OP_KETRPOS;
                 PUTINC(code, 0, nlen);
                 PUT(bracode, 1, nlen);
                 }
 
               /* For non-COND brackets, we modify the BRA code and use KETRPOS. */
 
               else
                 {
                 *bracode += 1;              /* Switch to xxxPOS opcodes */
                 *ketcode = OP_KETRPOS;
                 }
 
               /* If the minimum is zero, mark it as possessive, then unset the
               possessive flag when the minimum is 0 or 1. */
 
               if (brazeroptr != NULL) *brazeroptr = OP_BRAPOSZERO;
               if (repeat_min < 2) possessive_quantifier = FALSE;
               }
 
             /* Non-possessive quantifier */
 
             else *ketcode = OP_KETRMAX + repeat_type;
             }
           }
         }
       break;
 
       /* If previous was a character type match (\d or similar), abolish it and
       create a suitable repeat item. The code is shared with single-character
       repeats by setting op_type to add a suitable offset into repeat_type.
       Note the the Unicode property types will be present only when
       SUPPORT_UNICODE is defined, but we don't wrap the little bits of code
       here because it just makes it horribly messy. */
 
       default:
       if (op_previous >= OP_EODN)   /* Not a character type - internal error */
         {
         *errorcodeptr = ERR10;
         return 0;
         }
       else
         {
         int prop_type, prop_value;
         PCRE2_UCHAR *oldcode;
 
         if (repeat_max == 1 && repeat_min == 1) goto END_REPEAT;
 
         op_type = OP_TYPESTAR - OP_STAR;      /* Use type opcodes */
         mclength = 0;                         /* Not a character */
 
         if (op_previous == OP_PROP || op_previous == OP_NOTPROP)
           {
           prop_type = previous[1];
           prop_value = previous[2];
           }
         else
           {
           /* Come here from just above with a character in mcbuffer/mclength. */
           OUTPUT_SINGLE_REPEAT:
           prop_type = prop_value = -1;
           }
 
         /* At this point, if prop_type == prop_value == -1 we either have a
         character in mcbuffer when mclength is greater than zero, or we have
         mclength zero, in which case there is a non-property character type in
         op_previous. If prop_type/value are not negative, we have a property
         character type in op_previous. */
 
         oldcode = code;                   /* Save where we were */
         code = previous;                  /* Usually overwrite previous item */
 
         /* If the maximum is zero then the minimum must also be zero; Perl allows
         this case, so we do too - by simply omitting the item altogether. */
 
         if (repeat_max == 0) goto END_REPEAT;
 
         /* Combine the op_type with the repeat_type */
 
         repeat_type += op_type;
 
         /* A minimum of zero is handled either as the special case * or ?, or as
         an UPTO, with the maximum given. */
 
         if (repeat_min == 0)
           {
           if (repeat_max == REPEAT_UNLIMITED) *code++ = OP_STAR + repeat_type;
             else if (repeat_max == 1) *code++ = OP_QUERY + repeat_type;
           else
             {
             *code++ = OP_UPTO + repeat_type;
             PUT2INC(code, 0, repeat_max);
             }
           }
 
         /* A repeat minimum of 1 is optimized into some special cases. If the
         maximum is unlimited, we use OP_PLUS. Otherwise, the original item is
         left in place and, if the maximum is greater than 1, we use OP_UPTO with
         one less than the maximum. */
 
         else if (repeat_min == 1)
           {
           if (repeat_max == REPEAT_UNLIMITED)
             *code++ = OP_PLUS + repeat_type;
           else
             {
             code = oldcode;  /* Leave previous item in place */
             if (repeat_max == 1) goto END_REPEAT;
             *code++ = OP_UPTO + repeat_type;
             PUT2INC(code, 0, repeat_max - 1);
             }
           }
 
         /* The case {n,n} is just an EXACT, while the general case {n,m} is
         handled as an EXACT followed by an UPTO or STAR or QUERY. */
 
         else
           {
           *code++ = OP_EXACT + op_type;  /* NB EXACT doesn't have repeat_type */
           PUT2INC(code, 0, repeat_min);
 
           /* Unless repeat_max equals repeat_min, fill in the data for EXACT,
           and then generate the second opcode. For a repeated Unicode property
           match, there are two extra values that define the required property,
           and mclength is set zero to indicate this. */
 
           if (repeat_max != repeat_min)
             {
             if (mclength > 0)
               {
               memcpy(code, mcbuffer, CU2BYTES(mclength));
               code += mclength;
               }
             else
               {
               *code++ = op_previous;
               if (prop_type >= 0)
                 {
                 *code++ = prop_type;
                 *code++ = prop_value;
                 }
               }
 
             /* Now set up the following opcode */
 
             if (repeat_max == REPEAT_UNLIMITED)
               *code++ = OP_STAR + repeat_type;
             else
               {
               repeat_max -= repeat_min;
               if (repeat_max == 1)
                 {
                 *code++ = OP_QUERY + repeat_type;
                 }
               else
                 {
                 *code++ = OP_UPTO + repeat_type;
                 PUT2INC(code, 0, repeat_max);
                 }
               }
             }
           }
 
         /* Fill in the character or character type for the final opcode. */
 
         if (mclength > 0)
           {
           memcpy(code, mcbuffer, CU2BYTES(mclength));
           code += mclength;
           }
         else
           {
           *code++ = op_previous;
           if (prop_type >= 0)
             {
             *code++ = prop_type;
             *code++ = prop_value;
             }
           }
         }
       break;
       }  /* End of switch on different op_previous values */
 
 
     /* If the character following a repeat is '+', possessive_quantifier is
     TRUE. For some opcodes, there are special alternative opcodes for this
     case. For anything else, we wrap the entire repeated item inside OP_ONCE
     brackets. Logically, the '+' notation is just syntactic sugar, taken from
     Sun's Java package, but the special opcodes can optimize it.
 
     Some (but not all) possessively repeated subpatterns have already been
     completely handled in the code just above. For them, possessive_quantifier
     is always FALSE at this stage. Note that the repeated item starts at
     tempcode, not at previous, which might be the first part of a string whose
     (former) last char we repeated. */
 
     if (possessive_quantifier)
       {
       int len;
 
       /* Possessifying an EXACT quantifier has no effect, so we can ignore it.
       However, QUERY, STAR, or UPTO may follow (for quantifiers such as {5,6},
       {5,}, or {5,10}). We skip over an EXACT item; if the length of what
       remains is greater than zero, there's a further opcode that can be
       handled. If not, do nothing, leaving the EXACT alone. */
 
       switch(*tempcode)
         {
         case OP_TYPEEXACT:
         tempcode += PRIV(OP_lengths)[*tempcode] +
           ((tempcode[1 + IMM2_SIZE] == OP_PROP
           || tempcode[1 + IMM2_SIZE] == OP_NOTPROP)? 2 : 0);
         break;
 
         /* CHAR opcodes are used for exacts whose count is 1. */
 
         case OP_CHAR:
         case OP_CHARI:
         case OP_NOT:
         case OP_NOTI:
         case OP_EXACT:
         case OP_EXACTI:
         case OP_NOTEXACT:
         case OP_NOTEXACTI:
         tempcode += PRIV(OP_lengths)[*tempcode];
 #ifdef SUPPORT_UNICODE
         if (utf && HAS_EXTRALEN(tempcode[-1]))
           tempcode += GET_EXTRALEN(tempcode[-1]);
 #endif
         break;
 
         /* For the class opcodes, the repeat operator appears at the end;
         adjust tempcode to point to it. */
 
         case OP_CLASS:
         case OP_NCLASS:
         tempcode += 1 + 32/sizeof(PCRE2_UCHAR);
         break;
 
 #ifdef SUPPORT_WIDE_CHARS
         case OP_XCLASS:
         tempcode += GET(tempcode, 1);
         break;
 #endif
         }
 
       /* If tempcode is equal to code (which points to the end of the repeated
       item), it means we have skipped an EXACT item but there is no following
       QUERY, STAR, or UPTO; the value of len will be 0, and we do nothing. In
       all other cases, tempcode will be pointing to the repeat opcode, and will
       be less than code, so the value of len will be greater than 0. */
 
       len = (int)(code - tempcode);
       if (len > 0)
         {
         unsigned int repcode = *tempcode;
 
         /* There is a table for possessifying opcodes, all of which are less
         than OP_CALLOUT. A zero entry means there is no possessified version.
         */
 
         if (repcode < OP_CALLOUT && opcode_possessify[repcode] > 0)
           *tempcode = opcode_possessify[repcode];
 
         /* For opcode without a special possessified version, wrap the item in
         ONCE brackets. */
 
         else
           {
           (void)memmove(tempcode + 1 + LINK_SIZE, tempcode, CU2BYTES(len));
           code += 1 + LINK_SIZE;
           len += 1 + LINK_SIZE;
           tempcode[0] = OP_ONCE;
           *code++ = OP_KET;
           PUTINC(code, 0, len);
           PUT(tempcode, 1, len);
           }
         }
       }
 
     /* We set the "follows varying string" flag for subsequently encountered
     reqcus if it isn't already set and we have just passed a varying length
     item. */
 
     END_REPEAT:
     cb->req_varyopt |= reqvary;
     break;
 
 
     /* ===================================================================*/
     /* Handle a 32-bit data character with a value greater than META_END. */
 
     case META_BIGVALUE:
     pptr++;
     goto NORMAL_CHAR;
 
 
     /* ===============================================================*/
     /* Handle a back reference by number, which is the meta argument. The
     pattern offsets for back references to group numbers less than 10 are held
     in a special vector, to avoid using more than two parsed pattern elements
     in 64-bit environments. We only need the offset to the first occurrence,
     because if that doesn't fail, subsequent ones will also be OK. */
 
     case META_BACKREF:
     if (meta_arg < 10) offset = cb->small_ref_offset[meta_arg];
       else GETPLUSOFFSET(offset, pptr);
 
     if (meta_arg > cb->bracount)
       {
       cb->erroroffset = offset;
       *errorcodeptr = ERR15;  /* Non-existent subpattern */
       return 0;
       }
 
     /* Come here from named backref handling when the reference is to a
     single group (that is, not to a duplicated name). The back reference
     data will have already been updated. We must disable firstcu if not
     set, to cope with cases like (?=(\w+))\1: which would otherwise set ':'
     later. */
 
     HANDLE_SINGLE_REFERENCE:
     if (firstcuflags == REQ_UNSET) zerofirstcuflags = firstcuflags = REQ_NONE;
     *code++ = ((options & PCRE2_CASELESS) != 0)? OP_REFI : OP_REF;
     PUT2INC(code, 0, meta_arg);
 
     /* Update the map of back references, and keep the highest one. We
     could do this in parse_regex() for numerical back references, but not
     for named back references, because we don't know the numbers to which
     named back references refer. So we do it all in this function. */
 
     cb->backref_map |= (meta_arg < 32)? (1u << meta_arg) : 1;
     if (meta_arg > cb->top_backref) cb->top_backref = meta_arg;
 
     /* Check to see if this back reference is recursive, that it, it
     is inside the group that it references. A flag is set so that the
     group can be made atomic. */
 
     for (oc = cb->open_caps; oc != NULL; oc = oc->next)
       {
       if (oc->number == meta_arg)
         {
         oc->flag = TRUE;
         break;
         }
       }
     break;
 
 
     /* ===============================================================*/
     /* Handle recursion by inserting the number of the called group (which is
     the meta argument) after OP_RECURSE. At the end of compiling the pattern is
     scanned and these numbers are replaced by offsets within the pattern. It is
     done like this to avoid problems with forward references and adjusting
     offsets when groups are duplicated and moved (as discovered in previous
     implementations). Note that a recursion does not have a set first
     character. */
 
     case META_RECURSE:
     GETPLUSOFFSET(offset, pptr);
     if (meta_arg > cb->bracount)
       {
       cb->erroroffset = offset;
       *errorcodeptr = ERR15;  /* Non-existent subpattern */
       return 0;
       }
     HANDLE_NUMERICAL_RECURSION:
     *code = OP_RECURSE;
     PUT(code, 1, meta_arg);
     code += 1 + LINK_SIZE;
     groupsetfirstcu = FALSE;
     cb->had_recurse = TRUE;
     if (firstcuflags == REQ_UNSET) firstcuflags = REQ_NONE;
     zerofirstcu = firstcu;
     zerofirstcuflags = firstcuflags;
     break;
 
 
     /* ===============================================================*/
     /* Handle capturing parentheses; the number is the meta argument. */
 
     case META_CAPTURE:
     bravalue = OP_CBRA;
     skipunits = IMM2_SIZE;
     PUT2(code, 1+LINK_SIZE, meta_arg);
     cb->lastcapture = meta_arg;
     goto GROUP_PROCESS_NOTE_EMPTY;
 
 
     /* ===============================================================*/
     /* Handle escape sequence items. For ones like \d, the ESC_values are
     arranged to be the same as the corresponding OP_values in the default case
     when PCRE2_UCP is not set (which is the only case in which they will appear
     here).
 
     Note: \Q and \E are never seen here, as they were dealt with in
     parse_pattern(). Neither are numerical back references or recursions, which
     were turned into META_BACKREF or META_RECURSE items, respectively. \k and
     \g, when followed by names, are turned into META_BACKREF_BYNAME or
     META_RECURSE_BYNAME. */
 
     case META_ESCAPE:
 
     /* We can test for escape sequences that consume a character because their
     values lie between ESC_b and ESC_Z; this may have to change if any new ones
     are ever created. For these sequences, we disable the setting of a first
     character if it hasn't already been set. */
 
     if (meta_arg > ESC_b && meta_arg < ESC_Z)
       {
       matched_char = TRUE;
       if (firstcuflags == REQ_UNSET) firstcuflags = REQ_NONE;
       }
 
     /* Set values to reset to if this is followed by a zero repeat. */
 
     zerofirstcu = firstcu;
     zerofirstcuflags = firstcuflags;
     zeroreqcu = reqcu;
     zeroreqcuflags = reqcuflags;
 
     /* If Unicode is not supported, \P and \p are not allowed and are
     faulted at parse time, so will never appear here. */
 
 #ifdef SUPPORT_UNICODE
     if (meta_arg == ESC_P || meta_arg == ESC_p)
       {
       uint32_t ptype = *(++pptr) >> 16;
       uint32_t pdata = *pptr & 0xffff;
 
       /* The special case of \p{Any} is compiled to OP_ALLANY so as to benefit
       from the auto-anchoring code. */
 
       if (meta_arg == ESC_p && ptype == PT_ANY)
         {
         *code++ = OP_ALLANY;
         }
       else
         {
         *code++ = (meta_arg == ESC_p)? OP_PROP : OP_NOTPROP;
         *code++ = ptype;
         *code++ = pdata;
         }
       break;  /* End META_ESCAPE */
       }
 #endif
 
     /* For the rest (including \X when Unicode is supported - if not it's
     faulted at parse time), the OP value is the escape value when PCRE2_UCP is
     not set; if it is set, these escapes do not show up here because they are
     converted into Unicode property tests in parse_regex(). Note that \b and \B
     do a one-character lookbehind, and \A also behaves as if it does. */
 
     if (meta_arg == ESC_C) cb->external_flags |= PCRE2_HASBKC; /* Record */
     if ((meta_arg == ESC_b || meta_arg == ESC_B || meta_arg == ESC_A) &&
          cb->max_lookbehind == 0)
       cb->max_lookbehind = 1;
 
     /* In non-UTF mode, and for both 32-bit modes, we turn \C into OP_ALLANY
     instead of OP_ANYBYTE so that it works in DFA mode and in lookbehinds. */
 
 #if PCRE2_CODE_UNIT_WIDTH == 32
     *code++ = (meta_arg == ESC_C)? OP_ALLANY : meta_arg;
 #else
     *code++ = (!utf && meta_arg == ESC_C)? OP_ALLANY : meta_arg;
 #endif
     break;  /* End META_ESCAPE */
 
 
     /* ===================================================================*/
     /* Handle an unrecognized meta value. A parsed pattern value less than
     META_END is a literal. Otherwise we have a problem. */
 
     default:
     if (meta >= META_END)
       {
 #ifdef DEBUG_SHOW_PARSED
       fprintf(stderr, "** Unrecognized parsed pattern item 0x%.8x\n", *pptr);
 #endif
       *errorcodeptr = ERR89;  /* Internal error - unrecognized. */
       return 0;
       }
 
     /* Handle a literal character. We come here by goto in the case of a
     32-bit, non-UTF character whose value is greater than META_END. */
 
     NORMAL_CHAR:
     meta = *pptr;     /* Get the full 32 bits */
     NORMAL_CHAR_SET:  /* Character is already in meta */
     matched_char = TRUE;
 
     /* For caseless UTF mode, check whether this character has more than one
     other case. If so, generate a special OP_PROP item instead of OP_CHARI. */
 
 #ifdef SUPPORT_UNICODE
     if (utf && (options & PCRE2_CASELESS) != 0)
       {
       uint32_t caseset = UCD_CASESET(meta);
       if (caseset != 0)
         {
         *code++ = OP_PROP;
         *code++ = PT_CLIST;
         *code++ = caseset;
         if (firstcuflags == REQ_UNSET)
           firstcuflags = zerofirstcuflags = REQ_NONE;
         break;  /* End handling this meta item */
         }
       }
 #endif
 
     /* Caseful matches, or caseless and not one of the multicase characters. We
     come here by goto in the case of a positive class that contains only
     case-partners of a character with just two cases; matched_char has already
     been set TRUE and options fudged if necessary. */
 
     CLASS_CASELESS_CHAR:
 
     /* Get the character's code units into mcbuffer, with the length in
     mclength. When not in UTF mode, the length is always 1. */
 
 #ifdef SUPPORT_UNICODE
     if (utf) mclength = PRIV(ord2utf)(meta, mcbuffer); else
 #endif
       {
       mclength = 1;
       mcbuffer[0] = meta;
       }
 
     /* Generate the appropriate code */
 
     *code++ = ((options & PCRE2_CASELESS) != 0)? OP_CHARI : OP_CHAR;
     memcpy(code, mcbuffer, CU2BYTES(mclength));
     code += mclength;
 
     /* Remember if \r or \n were seen */
 
     if (mcbuffer[0] == CHAR_CR || mcbuffer[0] == CHAR_NL)
       cb->external_flags |= PCRE2_HASCRORLF;
 
     /* Set the first and required code units appropriately. If no previous
     first code unit, set it from this character, but revert to none on a zero
     repeat. Otherwise, leave the firstcu value alone, and don't change it on
     a zero repeat. */
 
     if (firstcuflags == REQ_UNSET)
       {
       zerofirstcuflags = REQ_NONE;
       zeroreqcu = reqcu;
       zeroreqcuflags = reqcuflags;
 
       /* If the character is more than one code unit long, we can set a single
-      firstcu only if it is not to be matched caselessly. Multiple possible 
+      firstcu only if it is not to be matched caselessly. Multiple possible
       starting code units may be picked up later in the studying code. */
 
       if (mclength == 1 || req_caseopt == 0)
         {
         firstcu = mcbuffer[0];
         firstcuflags = req_caseopt;
         if (mclength != 1)
           {
           reqcu = code[-1];
           reqcuflags = cb->req_varyopt;
           }
         }
       else firstcuflags = reqcuflags = REQ_NONE;
       }
 
     /* firstcu was previously set; we can set reqcu only if the length is
     1 or the matching is caseful. */
 
     else
       {
       zerofirstcu = firstcu;
       zerofirstcuflags = firstcuflags;
       zeroreqcu = reqcu;
       zeroreqcuflags = reqcuflags;
       if (mclength == 1 || req_caseopt == 0)
         {
         reqcu = code[-1];
         reqcuflags = req_caseopt | cb->req_varyopt;
         }
       }
 
     /* If caselessness was temporarily instated, reset it. */
 
     if (reset_caseful)
       {
       options &= ~PCRE2_CASELESS;
       req_caseopt = 0;
       reset_caseful = FALSE;
       }
 
     break;    /* End literal character handling */
     }         /* End of big switch */
   }           /* End of big loop */
 
 /* Control never reaches here. */
 }
 
 
 
 /*************************************************
 *   Compile regex: a sequence of alternatives    *
 *************************************************/
 
 /* On entry, pptr is pointing past the bracket meta, but on return it points to
diff --git a/src/pcre2_intmodedep.h b/src/pcre2_intmodedep.h
index b03d5c2..15ade47 100644
--- a/src/pcre2_intmodedep.h
+++ b/src/pcre2_intmodedep.h
@@ -205,31 +205,30 @@ whether its argument, which is assumed to be one code unit, is less than 256.
 The CHMAX_255 macro does not assume one code unit. The maximum length of a MARK
 name must fit in one code unit; currently it is set to 255 or 65535. The
 TABLE_GET macro is used to access elements of tables containing exactly 256
-items. When code points can be greater than 255, a check is needed before
-accessing these tables. */
+items. Its argument is a code unit. When code points can be greater than 255, a
+check is needed before accessing these tables. */
 
 #if PCRE2_CODE_UNIT_WIDTH == 8
 #define MAX_255(c) TRUE
 #define MAX_MARK ((1u << 8) - 1)
+#define TABLE_GET(c, table, default) ((table)[c])
 #ifdef SUPPORT_UNICODE
 #define SUPPORT_WIDE_CHARS
 #define CHMAX_255(c) ((c) <= 255u)
 #else
 #define CHMAX_255(c) TRUE
 #endif  /* SUPPORT_UNICODE */
-#define TABLE_GET(c, table, default) ((table)[c])
 
 #else  /* Code units are 16 or 32 bits */
 #define CHMAX_255(c) ((c) <= 255u)
 #define MAX_255(c) ((c) <= 255u)
 #define MAX_MARK ((1u << 16) - 1)
 #define SUPPORT_WIDE_CHARS
 #define TABLE_GET(c, table, default) (MAX_255(c)? ((table)[c]):(default))
 #endif
 
 
-
 /* ----------------- Character-handling macros ----------------- */
 
 /* There is a proposed future special "UTF-21" mode, in which only the lowest
 21 bits of a 32-bit character are interpreted as UTF, with the remaining 11
