commit 8a6348e6d2ef095358cfc7d29d2a50d684cc719e
Author: Herb Derby <herb@google.com>
Date:   Thu Jul 12 15:30:35 2018 -0400

    Introduce text blob processing but don't wire it up
    
    Have all the old code paths start using lists in preparation
    for introducing text blobs.
    
    Change-Id: I65cc02ee3da63bc3c9492db78a08b0eee3b1f931
    Reviewed-on: https://skia-review.googlesource.com/141081
    Commit-Queue: Herb Derby <herb@google.com>
    Reviewed-by: Herb Derby <herb@google.com>
    Reviewed-by: Mike Klein <mtklein@google.com>

diff --git a/include/core/SkTextBlob.h b/include/core/SkTextBlob.h
index 672cc20c5c..c68ad4147b 100644
--- a/include/core/SkTextBlob.h
+++ b/include/core/SkTextBlob.h
@@ -14,6 +14,7 @@
 #include "SkString.h"
 #include "SkRefCnt.h"
 
+class SkGlyphRunList;
 class SkReadBuffer;
 class SkWriteBuffer;
 
@@ -88,42 +89,43 @@ public:
 private:
     friend class SkNVRefCnt<SkTextBlob>;
     class RunRecord;
 
     explicit SkTextBlob(const SkRect& bounds);
 
     ~SkTextBlob();
 
     // Memory for objects of this class is created with sk_malloc rather than operator new and must
     // be freed with sk_free.
     void operator delete(void* p);
     void* operator new(size_t);
     void* operator new(size_t, void* p);
 
     static unsigned ScalarsPerGlyph(GlyphPositioning pos);
 
     // Call when this blob is part of the key to a cache entry. This allows the cache
     // to know automatically those entries can be purged when this SkTextBlob is deleted.
     void notifyAddedToCache(uint32_t cacheID) const {
         fCacheID.store(cacheID);
     }
 
+    friend class SkGlyphRunList;
     friend class GrTextBlobCache;
     friend class SkTextBlobBuilder;
     friend class SkTextBlobRunIterator;
 
     const SkRect               fBounds;
     const uint32_t             fUniqueID;
     mutable SkAtomic<uint32_t> fCacheID;
 
     SkDEBUGCODE(size_t fStorageSize;)
 
     // The actual payload resides in externally-managed storage, following the object.
     // (see the .cpp for more details)
 
     typedef SkRefCnt INHERITED;
 };
 
 /** \class SkTextBlobBuilder
 
     Helper class for constructing SkTextBlobs.
  */
diff --git a/src/core/SkCanvas.cpp b/src/core/SkCanvas.cpp
index 367105ddda..3c5ec347c7 100644
--- a/src/core/SkCanvas.cpp
+++ b/src/core/SkCanvas.cpp
@@ -2426,14 +2426,14 @@ void SkCanvas::onDrawBitmapLattice(const SkBitmap& bitmap, const Lattice& lattic
 void SkCanvas::onDrawText(const void* text, size_t byteLength, SkScalar x, SkScalar y,
                           const SkPaint& paint) {
 
     LOOPER_BEGIN(paint, nullptr)
 
     while (iter.next()) {
         fScratchGlyphRunBuilder->drawText(
                 looper.paint(), text, byteLength, SkPoint::Make(x, y));
-        auto glyphRun = fScratchGlyphRunBuilder->useGlyphRun();
-        iter.fDevice->drawGlyphRun(looper.paint(), glyphRun);
+        auto glyphRunList = fScratchGlyphRunBuilder->useGlyphRunList();
+        iter.fDevice->drawGlyphRunList(looper.paint(), glyphRunList);
     }
 
     LOOPER_END
 }
@@ -2441,13 +2441,13 @@ void SkCanvas::onDrawText(const void* text, size_t byteLength, SkScalar x, SkSca
 void SkCanvas::onDrawPosText(const void* text, size_t byteLength, const SkPoint pos[],
                              const SkPaint& paint) {
 
     LOOPER_BEGIN(paint, nullptr)
 
     while (iter.next()) {
         fScratchGlyphRunBuilder->drawPosText(looper.paint(), text, byteLength, pos);
-        auto glyphRun = fScratchGlyphRunBuilder->useGlyphRun();
-        iter.fDevice->drawGlyphRun(looper.paint(), glyphRun);
+        auto glyphRunList = fScratchGlyphRunBuilder->useGlyphRunList();
+        iter.fDevice->drawGlyphRunList(looper.paint(), glyphRunList);
     }
 
     LOOPER_END
 }
@@ -2455,14 +2455,14 @@ void SkCanvas::onDrawPosText(const void* text, size_t byteLength, const SkPoint
 void SkCanvas::onDrawPosTextH(const void* text, size_t byteLength, const SkScalar xpos[],
                               SkScalar constY, const SkPaint& paint) {
 
     LOOPER_BEGIN(paint, nullptr)
 
     while (iter.next()) {
         fScratchGlyphRunBuilder->drawPosTextH(
                 looper.paint(), text, byteLength, xpos, constY);
-        const auto& glyphRun = fScratchGlyphRunBuilder->useGlyphRun();
-        iter.fDevice->drawGlyphRun(looper.paint(), glyphRun);
+        auto glyphRunList = fScratchGlyphRunBuilder->useGlyphRunList();
+        iter.fDevice->drawGlyphRunList(looper.paint(), glyphRunList);
     }
 
     LOOPER_END
 }
diff --git a/src/core/SkDevice.cpp b/src/core/SkDevice.cpp
index 5ca8f5ec5e..a4482a19ec 100644
--- a/src/core/SkDevice.cpp
+++ b/src/core/SkDevice.cpp
@@ -142,35 +142,35 @@ void SkBaseDevice::drawPatch(const SkPoint cubics[12], const SkColor colors[4],
 void SkBaseDevice::drawTextBlob(const SkTextBlob* blob, SkScalar x, SkScalar y,
                                 const SkPaint &paint) {
 
     SkPaint runPaint = paint;
 
     SkTextBlobRunIterator it(blob);
     for (;!it.done(); it.next()) {
         size_t textLen = it.glyphCount() * sizeof(uint16_t);
         const SkPoint& offset = it.offset();
         // applyFontToPaint() always overwrites the exact same attributes,
         // so it is safe to not re-seed the paint for this reason.
         it.applyFontToPaint(&runPaint);
 
         switch (it.positioning()) {
         case SkTextBlob::kDefault_Positioning: {
             auto origin = SkPoint::Make(x + offset.x(), y + offset.y());
             SkGlyphRunBuilder builder;
             builder.drawText(runPaint, (const char*) it.glyphs(), textLen, origin);
-            auto glyphRun = builder.useGlyphRun();
-            glyphRun->temporaryShuntToDrawPosText(this);
+            auto glyphRunList = builder.useGlyphRunList();
+            glyphRunList->temporaryShuntToDrawPosText(this);
         }
         break;
         case SkTextBlob::kHorizontal_Positioning:
             this->drawPosText(it.glyphs(), textLen, it.pos(), 1,
                               SkPoint::Make(x, y + offset.y()), runPaint);
             break;
         case SkTextBlob::kFull_Positioning:
             this->drawPosText(it.glyphs(), textLen, it.pos(), 2,
                               SkPoint::Make(x, y), runPaint);
             break;
         default:
             SK_ABORT("unhandled positioning mode");
         }
     }
 }
@@ -239,11 +239,8 @@ void SkBaseDevice::drawImageLattice(const SkImage* image,
     }
 }
 
-void SkBaseDevice::drawGlyphRun(const SkPaint& paint, SkGlyphRun* glyphRun) {
-    SkPaint glyphPaint(paint);
-    glyphPaint.setTextEncoding(SkPaint::kGlyphID_TextEncoding);
-
-    glyphRun->temporaryShuntToDrawPosText(this);
+void SkBaseDevice::drawGlyphRunList(const SkPaint& paint, SkGlyphRunList* glyphRunList) {
+    glyphRunList->temporaryShuntToDrawPosText(this);
 }
 
 void SkBaseDevice::drawBitmapLattice(const SkBitmap& bitmap,
diff --git a/src/core/SkDevice.h b/src/core/SkDevice.h
index 2173d91023..2a33822b1e 100644
--- a/src/core/SkDevice.h
+++ b/src/core/SkDevice.h
@@ -16,7 +16,7 @@
 
 class SkBitmap;
 struct SkDrawShadowRec;
-class SkGlyphRun;
+class SkGlyphRunList;
 class SkGlyphRunBuilder;
 class SkImageFilterCache;
 struct SkIRect;
@@ -129,207 +129,207 @@ public:
 protected:
     enum TileUsage {
         kPossible_TileUsage,    //!< the created device may be drawn tiled
         kNever_TileUsage,       //!< the created device will never be drawn tiled
     };
 
     struct TextFlags {
         uint32_t    fFlags;     // SkPaint::getFlags()
     };
 
     virtual void onSave() {}
     virtual void onRestore() {}
     virtual void onClipRect(const SkRect& rect, SkClipOp, bool aa) {}
     virtual void onClipRRect(const SkRRect& rrect, SkClipOp, bool aa) {}
     virtual void onClipPath(const SkPath& path, SkClipOp, bool aa) {}
     virtual void onClipRegion(const SkRegion& deviceRgn, SkClipOp) {}
     virtual void onSetDeviceClipRestriction(SkIRect* mutableClipRestriction) {}
     virtual bool onClipIsAA() const = 0;
     virtual void onAsRgnClip(SkRegion*) const = 0;
     enum ClipType {
         kEmpty_ClipType,
         kRect_ClipType,
         kComplex_ClipType
     };
     virtual ClipType onGetClipType() const = 0;
 
     /** These are called inside the per-device-layer loop for each draw call.
      When these are called, we have already applied any saveLayer operations,
      and are handling any looping from the paint.
      */
     virtual void drawPaint(const SkPaint& paint) = 0;
     virtual void drawPoints(SkCanvas::PointMode mode, size_t count,
                             const SkPoint[], const SkPaint& paint) = 0;
     virtual void drawRect(const SkRect& r,
                           const SkPaint& paint) = 0;
     virtual void drawRegion(const SkRegion& r,
                             const SkPaint& paint);
     virtual void drawOval(const SkRect& oval,
                           const SkPaint& paint) = 0;
     /** By the time this is called we know that abs(sweepAngle) is in the range [0, 360). */
     virtual void drawArc(const SkRect& oval, SkScalar startAngle,
                          SkScalar sweepAngle, bool useCenter, const SkPaint& paint);
     virtual void drawRRect(const SkRRect& rr,
                            const SkPaint& paint) = 0;
 
     // Default impl calls drawPath()
     virtual void drawDRRect(const SkRRect& outer,
                             const SkRRect& inner, const SkPaint&);
 
     /**
      *  If pathIsMutable, then the implementation is allowed to cast path to a
      *  non-const pointer and modify it in place (as an optimization). Canvas
      *  may do this to implement helpers such as drawOval, by placing a temp
      *  path on the stack to hold the representation of the oval.
      *
      *  If prePathMatrix is not null, it should logically be applied before any
      *  stroking or other effects. If there are no effects on the paint that
      *  affect the geometry/rasterization, then the pre matrix can just be
      *  pre-concated with the current matrix.
      */
     virtual void drawPath(const SkPath& path,
                           const SkPaint& paint,
                           const SkMatrix* prePathMatrix = nullptr,
                           bool pathIsMutable = false) = 0;
     virtual void drawBitmap(const SkBitmap& bitmap,
                             SkScalar x,
                             SkScalar y,
                             const SkPaint& paint) = 0;
     virtual void drawSprite(const SkBitmap& bitmap,
                             int x, int y, const SkPaint& paint) = 0;
 
     /**
      *  The default impl. will create a bitmap-shader from the bitmap,
      *  and call drawRect with it.
      */
     virtual void drawBitmapRect(const SkBitmap&,
                                 const SkRect* srcOrNull, const SkRect& dst,
                                 const SkPaint& paint,
                                 SkCanvas::SrcRectConstraint) = 0;
     virtual void drawBitmapNine(const SkBitmap&, const SkIRect& center,
                                 const SkRect& dst, const SkPaint&);
     virtual void drawBitmapLattice(const SkBitmap&, const SkCanvas::Lattice&,
                                    const SkRect& dst, const SkPaint&);
 
     virtual void drawImage(const SkImage*, SkScalar x, SkScalar y, const SkPaint&);
     virtual void drawImageRect(const SkImage*, const SkRect* src, const SkRect& dst,
                                const SkPaint&, SkCanvas::SrcRectConstraint);
     virtual void drawImageNine(const SkImage*, const SkIRect& center,
                                const SkRect& dst, const SkPaint&);
     virtual void drawImageLattice(const SkImage*, const SkCanvas::Lattice&,
                                   const SkRect& dst, const SkPaint&);
 
     /**
      *  Does not handle text decoration.
      *  Decorations (underline and stike-thru) will be handled by SkCanvas.
      */
-    virtual void drawGlyphRun(const SkPaint& paint, SkGlyphRun* glyphRun);
+    virtual void drawGlyphRunList(const SkPaint& paint, SkGlyphRunList* glyphRunList);
     virtual void drawVertices(const SkVertices*, const SkMatrix* bones, int boneCount, SkBlendMode,
                               const SkPaint&) = 0;
     virtual void drawShadow(const SkPath&, const SkDrawShadowRec&);
 
     // default implementation unrolls the blob runs.
     virtual void drawTextBlob(const SkTextBlob*, SkScalar x, SkScalar y, const SkPaint& paint);
     // default implementation calls drawVertices
     virtual void drawPatch(const SkPoint cubics[12], const SkColor colors[4],
                            const SkPoint texCoords[4], SkBlendMode, const SkPaint& paint);
 
     // default implementation calls drawPath
     virtual void drawAtlas(const SkImage* atlas, const SkRSXform[], const SkRect[],
                            const SkColor[], int count, SkBlendMode, const SkPaint&);
 
     virtual void drawAnnotation(const SkRect&, const char[], SkData*) {}
 
     /** The SkDevice passed will be an SkDevice which was returned by a call to
         onCreateDevice on this device with kNeverTile_TileExpectation.
      */
     virtual void drawDevice(SkBaseDevice*, int x, int y,
                             const SkPaint&) = 0;
 
     virtual void drawTextOnPath(const void* text, size_t len, const SkPath&,
                                 const SkMatrix*, const SkPaint&);
     virtual void drawTextRSXform(const void* text, size_t len, const SkRSXform[],
                                  const SkPaint&);
 
     virtual void drawSpecial(SkSpecialImage*, int x, int y, const SkPaint&,
                              SkImage* clipImage, const SkMatrix& clipMatrix);
     virtual sk_sp<SkSpecialImage> makeSpecial(const SkBitmap&);
     virtual sk_sp<SkSpecialImage> makeSpecial(const SkImage*);
     virtual sk_sp<SkSpecialImage> snapSpecial();
 
     bool readPixels(const SkPixmap&, int x, int y);
 
     ///////////////////////////////////////////////////////////////////////////
 
     virtual GrContext* context() const { return nullptr; }
 
     virtual sk_sp<SkSurface> makeSurface(const SkImageInfo&, const SkSurfaceProps&);
     virtual bool onPeekPixels(SkPixmap*) { return false; }
 
     /**
      *  The caller is responsible for "pre-clipping" the dst. The impl can assume that the dst
      *  image at the specified x,y offset will fit within the device's bounds.
      *
      *  This is explicitly asserted in readPixels(), the public way to call this.
      */
     virtual bool onReadPixels(const SkPixmap&, int x, int y);
 
     /**
      *  The caller is responsible for "pre-clipping" the src. The impl can assume that the src
      *  image at the specified x,y offset will fit within the device's bounds.
      *
      *  This is explicitly asserted in writePixelsDirect(), the public way to call this.
      */
     virtual bool onWritePixels(const SkPixmap&, int x, int y);
 
     virtual bool onAccessPixels(SkPixmap*) { return false; }
 
     struct CreateInfo {
         static SkPixelGeometry AdjustGeometry(const SkImageInfo&, TileUsage, SkPixelGeometry,
                                               bool preserveLCDText);
 
         // The constructor may change the pixel geometry based on other parameters.
         CreateInfo(const SkImageInfo& info,
                    TileUsage tileUsage,
                    SkPixelGeometry geo)
             : fInfo(info)
             , fTileUsage(tileUsage)
             , fPixelGeometry(AdjustGeometry(info, tileUsage, geo, false))
         {}
 
         CreateInfo(const SkImageInfo& info,
                    TileUsage tileUsage,
                    SkPixelGeometry geo,
                    bool preserveLCDText,
                    bool trackCoverage,
                    SkRasterHandleAllocator* allocator)
             : fInfo(info)
             , fTileUsage(tileUsage)
             , fPixelGeometry(AdjustGeometry(info, tileUsage, geo, preserveLCDText))
             , fTrackCoverage(trackCoverage)
             , fAllocator(allocator)
         {}
 
         const SkImageInfo       fInfo;
         const TileUsage         fTileUsage;
         const SkPixelGeometry   fPixelGeometry;
         const bool              fTrackCoverage = false;
         SkRasterHandleAllocator* fAllocator = nullptr;
     };
 
     /**
      *  Create a new device based on CreateInfo. If the paint is not null, then it represents a
      *  preview of how the new device will be composed with its creator device (this).
      *
      *  The subclass may be handed this device in drawDevice(), so it must always return
      *  a device that it knows how to draw, and that it knows how to identify if it is not of the
      *  same subclass (since drawDevice is passed a SkBaseDevice*). If the subclass cannot fulfill
      *  that contract (e.g. PDF cannot support some settings on the paint) it should return NULL,
      *  and the caller may then decide to explicitly create a bitmapdevice, knowing that later
      *  it could not call drawDevice with it (but it could call drawSprite or drawBitmap).
      */
     virtual SkBaseDevice* onCreateDevice(const CreateInfo&, const SkPaint*) {
         return nullptr;
     }
 
     // A helper function used by derived classes to log the scale factor of a bitmap or image draw.
     static void LogDrawScaleFactor(const SkMatrix&, SkFilterQuality);
diff --git a/src/core/SkGlyphRun.cpp b/src/core/SkGlyphRun.cpp
index 781263c103..6cb458544f 100644
--- a/src/core/SkGlyphRun.cpp
+++ b/src/core/SkGlyphRun.cpp
@@ -66,15 +66,45 @@ void SkGlyphRun::temporaryShuntToDrawPosText(SkBaseDevice* device) {
 void SkGlyphRun::temporaryShuntToCallback(TemporaryShuntCallback callback) {
     auto bytes = (const char *)fTemporaryShuntGlyphIDs.data();
     auto pos = (const SkScalar*) this->positions().data();
     callback(fTemporaryShuntGlyphIDs.size(), bytes, pos);
 }
 
+// -- SkGlyphRunList -------------------------------------------------------------------------------
+SkGlyphRunList::SkGlyphRunList(
+        const SkPaint& paint,
+        const SkTextBlob* blob,
+        SkPoint origin,
+        SkSpan<SkGlyphRun> glyphRunList)
+        : fOriginalPaint{&paint}
+        , fOriginalTextBlob{blob}
+        , fOrigin{origin}
+        , fGlyphRuns{glyphRunList} { }
+
+uint64_t SkGlyphRunList::uniqueID() const {
+    return fOriginalTextBlob != nullptr ? fOriginalTextBlob->uniqueID()
+                                        : SK_InvalidUniqueID;
+}
+
+bool SkGlyphRunList::anyRunsLCD() const {
+    for (const auto& r : fGlyphRuns) {
+        if (r.paint().isLCDRenderText()) {
+            return true;
+        }
+    }
+    return false;
+}
+
+void SkGlyphRunList::temporaryShuntBlobNotifyAddedToCache(uint32_t cacheID) const {
+    SkASSERT(fOriginalTextBlob != nullptr);
+    fOriginalTextBlob->notifyAddedToCache(cacheID);
+}
+
 // -- SkGlyphIDSet ---------------------------------------------------------------------------------
 // A faster set implementation that does not need any initialization, and reading the set items
 // is order the number of items, and not the size of the universe.
 // This implementation is based on the paper by Briggs and Torczon, "An Efficient Representation
 // for Sparse Sets"
 //
 // This implementation assumes that the unique glyphs added are appended to a vector that may
 // already have unique glyph from a previous computation. This allows the packing of multiple
 // UniqueID sequences in a single vector.
@@ -134,51 +164,119 @@ SkSpan<const SkGlyphID> SkGlyphIDSet::uniquifyGlyphIDs(
 // -- SkGlyphRunBuilder ----------------------------------------------------------------------------
 void SkGlyphRunBuilder::drawText(
         const SkPaint& paint, const void* bytes, size_t byteLength, SkPoint origin) {
     auto glyphIDs = textToGlyphIDs(paint, bytes, byteLength);
     if (!glyphIDs.empty()) {
         this->initialize(glyphIDs.size());
         this->simplifyDrawText(
                 paint, glyphIDs, origin, fUniqueGlyphIDIndices, fUniqueGlyphIDs, fPositions);
     }
+
+    this->makeGlyphRunList(paint, nullptr, SkPoint::Make(0, 0));
 }
 
 void SkGlyphRunBuilder::drawPosTextH(const SkPaint& paint, const void* bytes,
                                      size_t byteLength, const SkScalar* xpos,
                                      SkScalar constY) {
     auto glyphIDs = textToGlyphIDs(paint, bytes, byteLength);
     if (!glyphIDs.empty()) {
         this->initialize(glyphIDs.size());
         this->simplifyDrawPosTextH(
                 paint, glyphIDs, xpos, constY, fUniqueGlyphIDIndices, fUniqueGlyphIDs, fPositions);
     }
+
+    this->makeGlyphRunList(paint, nullptr, SkPoint::Make(0, 0));
 }
 
 void SkGlyphRunBuilder::drawPosText(const SkPaint& paint, const void* bytes,
                                     size_t byteLength, const SkPoint* pos) {
     auto glyphIDs = textToGlyphIDs(paint, bytes, byteLength);
     if (!glyphIDs.empty()) {
         this->initialize(glyphIDs.size());
-        this->simplifyDrawPosText(
-                paint, glyphIDs, pos, fUniqueGlyphIDIndices, fUniqueGlyphIDs);
+        this->simplifyDrawPosText(paint, glyphIDs, pos, fUniqueGlyphIDIndices, fUniqueGlyphIDs);
     }
+
+    this->makeGlyphRunList(paint, nullptr, SkPoint::Make(0, 0));
 }
 
-SkGlyphRun* SkGlyphRunBuilder::useGlyphRun() {
-    return &fScratchGlyphRun;
+void SkGlyphRunBuilder::drawTextBlob(const SkPaint& paint, const SkTextBlob& blob, SkPoint origin) {
+    SkPaint runPaint = paint;
+
+    // Figure out all the storage needed to pre-size everything below.
+    size_t totalGlyphs = 0;
+    for (SkTextBlobRunIterator it(&blob); !it.done(); it.next()) {
+        totalGlyphs += it.glyphCount();
+    }
+
+    // Pre-size all the buffers so they don't move during processing.
+    this->initialize(totalGlyphs);
+
+    uint16_t* currentDenseIndices = fUniqueGlyphIDIndices;
+    SkPoint* currentPositions = fPositions;
+    SkGlyphID* currentUniqueGlyphIDs = fUniqueGlyphIDs;
+
+    for (SkTextBlobRunIterator it(&blob); !it.done(); it.next()) {
+        // applyFontToPaint() always overwrites the exact same attributes,
+        // so it is safe to not re-seed the paint for this reason.
+        it.applyFontToPaint(&runPaint);
+        size_t runSize = it.glyphCount();
+
+        // These better be glyphs
+        SkASSERT(runPaint.getTextEncoding() == SkPaint::kGlyphID_TextEncoding);
+
+        auto text = SkSpan<const char>(it.text(), it.textSize());
+        auto clusters = SkSpan<const uint32_t>(it.clusters(), runSize);
+        const SkPoint& offset = it.offset();
+        auto glyphIDs = SkSpan<const SkGlyphID>{it.glyphs(), runSize};
+
+        size_t uniqueGlyphIDsSize = 0;
+        switch (it.positioning()) {
+            case SkTextBlob::kDefault_Positioning: {
+                uniqueGlyphIDsSize = this->simplifyDrawText(
+                        runPaint, glyphIDs, offset,
+                        currentDenseIndices, currentUniqueGlyphIDs, currentPositions,
+                        text, clusters);
+            }
+                break;
+            case SkTextBlob::kHorizontal_Positioning: {
+                auto constY = offset.y();
+                uniqueGlyphIDsSize = this->simplifyDrawPosTextH(
+                        runPaint, glyphIDs, it.pos(), constY,
+                        currentDenseIndices, currentUniqueGlyphIDs, currentPositions,
+                        text, clusters);
+            }
+                break;
+            case SkTextBlob::kFull_Positioning:
+                uniqueGlyphIDsSize = this->simplifyDrawPosText(
+                        runPaint, glyphIDs, (const SkPoint*)it.pos(),
+                        currentDenseIndices, currentUniqueGlyphIDs,
+                        text, clusters);
+                break;
+            default:
+                SK_ABORT("unhandled positioning mode");
+        }
+
+        currentDenseIndices += runSize;
+        currentPositions += runSize;
+        currentUniqueGlyphIDs += uniqueGlyphIDsSize;
+    }
+
+    this->makeGlyphRunList(paint, &blob, origin);
+}
+
+SkGlyphRunList* SkGlyphRunBuilder::useGlyphRunList() {
+    return &fGlyphRunList;
 }
 
 void SkGlyphRunBuilder::initialize(size_t totalRunSize) {
-    fUniqueID = 0;
 
     if (totalRunSize > fMaxTotalRunSize) {
         fMaxTotalRunSize = totalRunSize;
         fUniqueGlyphIDIndices.reset(fMaxTotalRunSize);
         fPositions.reset(fMaxTotalRunSize);
         fUniqueGlyphIDs.reset(fMaxTotalRunSize);
     }
 
-    // Be sure to clean up the last run before we reuse it.
-    fScratchGlyphRun.~SkGlyphRun();
+    fGlyphRunListStorage.clear();
 }
 
 SkSpan<const SkGlyphID> SkGlyphRunBuilder::textToGlyphIDs(
@@ -224,118 +322,127 @@ SkSpan<const SkGlyphID> SkGlyphRunBuilder::addDenseAndUnique(
 void SkGlyphRunBuilder::makeGlyphRun(
         const SkPaint& runPaint,
         SkSpan<const SkGlyphID> glyphIDs,
         SkSpan<const SkPoint> positions,
         SkSpan<const uint16_t> uniqueGlyphIDIndices,
         SkSpan<const SkGlyphID> uniqueGlyphIDs,
         SkSpan<const char> text,
         SkSpan<const uint32_t> clusters) {
 
     // Ignore empty runs.
     if (!glyphIDs.empty()) {
         SkPaint glyphRunPaint{runPaint};
         glyphRunPaint.setTextEncoding(SkPaint::kGlyphID_TextEncoding);
         glyphRunPaint.setTextAlign(SkPaint::kLeft_Align);
 
-        new ((void*)&fScratchGlyphRun) SkGlyphRun{
+        fGlyphRunListStorage.emplace_back(
                 std::move(glyphRunPaint),
                 uniqueGlyphIDIndices,
                 positions,
                 glyphIDs,
                 uniqueGlyphIDs,
                 text,
-                clusters
-        };
+                clusters);
     }
 }
 
-void SkGlyphRunBuilder::simplifyDrawText(
+void SkGlyphRunBuilder::makeGlyphRunList(
+        const SkPaint& paint, const SkTextBlob* blob, SkPoint origin) {
+
+    fGlyphRunList.~SkGlyphRunList();
+    new (&fGlyphRunList) SkGlyphRunList{
+        paint, blob, origin, SkSpan<SkGlyphRun>{fGlyphRunListStorage}};
+}
+
+size_t SkGlyphRunBuilder::simplifyDrawText(
         const SkPaint& paint, SkSpan<const SkGlyphID> glyphIDs, SkPoint origin,
         uint16_t* uniqueGlyphIDIndicesBuffer, SkGlyphID* uniqueGlyphIDsBuffer, SkPoint* positions,
         SkSpan<const char> text, SkSpan<const uint32_t> clusters) {
     SkASSERT(!glyphIDs.empty());
 
-
     auto runSize = glyphIDs.size();
 
     auto unqiueGlyphIDs = this->addDenseAndUnique(
             paint, glyphIDs, uniqueGlyphIDIndicesBuffer, uniqueGlyphIDsBuffer);
 
     if (!unqiueGlyphIDs.empty()) {
         fScratchAdvances.resize(runSize);
         {
             auto cache = SkStrikeCache::FindOrCreateStrikeExclusive(paint);
             cache->getAdvances(unqiueGlyphIDs, fScratchAdvances.data());
         }
 
         SkPoint endOfLastGlyph = origin;
 
         for (size_t i = 0; i < runSize; i++) {
             positions[i] = endOfLastGlyph;
-            endOfLastGlyph += fScratchAdvances[fUniqueGlyphIDIndices[i]];
+            endOfLastGlyph += fScratchAdvances[uniqueGlyphIDIndicesBuffer[i]];
         }
 
         if (paint.getTextAlign() != SkPaint::kLeft_Align) {
             SkVector len = endOfLastGlyph - origin;
             if (paint.getTextAlign() == SkPaint::kCenter_Align) {
                 len.scale(SK_ScalarHalf);
             }
             for (auto& pt : SkSpan<SkPoint>{positions, runSize}) {
                 pt -= len;
             }
 
         }
 
         this->makeGlyphRun(
                 paint,
                 glyphIDs,
                 SkSpan<const SkPoint>{positions, runSize},
-                SkSpan<const uint16_t>{fUniqueGlyphIDIndices, runSize},
+                SkSpan<const uint16_t>{uniqueGlyphIDIndicesBuffer, runSize},
                 unqiueGlyphIDs,
                 text,
                 clusters);
     }
+
+    return unqiueGlyphIDs.size();
 }
 
-void SkGlyphRunBuilder::simplifyDrawPosTextH(
+size_t SkGlyphRunBuilder::simplifyDrawPosTextH(
         const SkPaint& paint, SkSpan<const SkGlyphID> glyphIDs,
         const SkScalar* xpos, SkScalar constY,
         uint16_t* uniqueGlyphIDIndicesBuffer, SkGlyphID* uniqueGlyphIDsBuffer, SkPoint* positions,
         SkSpan<const char> text, SkSpan<const uint32_t> clusters) {
 
     auto posCursor = positions;
     for (auto x : SkSpan<const SkScalar>{xpos, glyphIDs.size()}) {
         *posCursor++ = SkPoint::Make(x, constY);
     }
 
-    this->simplifyDrawPosText(
+    return this->simplifyDrawPosText(
             paint, glyphIDs, positions,
             uniqueGlyphIDIndicesBuffer, uniqueGlyphIDsBuffer,
             text, clusters);
 }
 
-void SkGlyphRunBuilder::simplifyDrawPosText(
+size_t SkGlyphRunBuilder::simplifyDrawPosText(
         const SkPaint& paint, SkSpan<const SkGlyphID> glyphIDs, const SkPoint* pos,
         uint16_t* uniqueGlyphIDIndicesBuffer, SkGlyphID* uniqueGlyphIDsBuffer,
         SkSpan<const char> text, SkSpan<const uint32_t> clusters) {
     auto runSize = glyphIDs.size();
 
     // The dense indices are not used by the rest of the stack yet.
     SkSpan<const SkGlyphID> uniqueGlyphIDs;
     #ifdef SK_DEBUG
         uniqueGlyphIDs = this->addDenseAndUnique(
                 paint, glyphIDs, uniqueGlyphIDIndicesBuffer, uniqueGlyphIDsBuffer);
     #endif
 
     // TODO: when using the unique glyph system have a guard that there are actually glyphs like
     // drawText above.
     this->makeGlyphRun(
             paint,
             glyphIDs,
             SkSpan<const SkPoint>{pos, runSize},
             SkSpan<const SkGlyphID>{uniqueGlyphIDIndicesBuffer, runSize},
             uniqueGlyphIDs,
             text,
             clusters);
+    return 0;
 }
 
 
diff --git a/src/core/SkGlyphRun.h b/src/core/SkGlyphRun.h
index a1124fd58e..4b392fda0f 100644
--- a/src/core/SkGlyphRun.h
+++ b/src/core/SkGlyphRun.h
@@ -47,24 +47,22 @@ class SkGlyphRun {
 public:
     SkGlyphRun() = default;
     SkGlyphRun(SkPaint&& runPaint,
                SkSpan<const uint16_t> denseIndices,
                SkSpan<const SkPoint> positions,
                SkSpan<const SkGlyphID> glyphIDs,
                SkSpan<const SkGlyphID> uniqueGlyphIDs,
                SkSpan<const char> text,
                SkSpan<const uint32_t> clusters);
 
     // The temporaryShunt calls are to allow inter-operating with existing code while glyph runs
     // are developed.
     void temporaryShuntToDrawPosText(SkBaseDevice* device);
     using TemporaryShuntCallback = std::function<void(size_t, const char*, const SkScalar*)>;
     void temporaryShuntToCallback(TemporaryShuntCallback callback);
 
     size_t runSize() const { return fUniqueGlyphIDIndices.size(); }
-    uint16_t uniqueSize() const { return fUniqueGlyphIDs.size(); }
     SkSpan<const SkPoint> positions() const { return fPositions; }
-    SkSpan<const SkGlyphID> uniqueGlyphIDs() const { return fUniqueGlyphIDs; }
-    SkSpan<const SkGlyphID> shuntGlyphsIDs() const { return fTemporaryShuntGlyphIDs; }
+    const SkPaint& paint() const { return fRunPaint; }
 
 private:
     //
@@ -83,6 +81,53 @@ private:
     const SkPaint fRunPaint;
 };
 
+class SkGlyphRunList {
+    const SkPaint* fOriginalPaint{nullptr};
+    // The text blob is needed to hookup the call back that the SkTextBlob destructor calls. It
+    // should be used for nothing else
+    const SkTextBlob*  fOriginalTextBlob{nullptr};
+    SkPoint fOrigin = {0, 0};
+    SkSpan<SkGlyphRun> fGlyphRuns;
+
+public:
+    SkGlyphRunList() = default;
+    // Blob maybe null.
+    SkGlyphRunList(
+            const SkPaint& paint,
+            const SkTextBlob* blob,
+            SkPoint origin,
+            SkSpan<SkGlyphRun> glyphRunList);
+
+    uint64_t uniqueID() const;
+    bool anyRunsLCD() const;
+    void temporaryShuntBlobNotifyAddedToCache(uint32_t cacheID) const;
+
+    bool canCache() const { return fOriginalTextBlob != nullptr; }
+    size_t runCount() const { return fGlyphRuns.size(); }
+    size_t totalGlyphCount() const {
+        size_t glyphCount = 0;
+        for(const auto& run : fGlyphRuns) {
+            glyphCount += run.runSize();
+        }
+        return glyphCount;
+    }
+
+    SkPoint origin() const { return fOrigin; }
+    const SkPaint& paint() const { return *fOriginalPaint; }
+
+    auto begin() -> decltype(fGlyphRuns.begin())               { return fGlyphRuns.begin(); }
+    auto end()   -> decltype(fGlyphRuns.end())                 { return fGlyphRuns.end();   }
+    auto size()  -> decltype(fGlyphRuns.size())                { return fGlyphRuns.size();  }
+    auto empty() -> decltype(fGlyphRuns.empty())               { return fGlyphRuns.empty(); }
+    auto operator [] (size_t i) -> decltype(fGlyphRuns[i])     { return fGlyphRuns[i];      }
+    void temporaryShuntToDrawPosText(SkBaseDevice* device) {
+        for (auto& run : fGlyphRuns) {
+            run.temporaryShuntToDrawPosText(device);
+        }
+    }
+
+};
+
 class SkGlyphIDSet {
 public:
     SkSpan<const SkGlyphID> uniquifyGlyphIDs(
@@ -96,75 +141,76 @@ private:
 class SkGlyphRunBuilder {
 public:
     void drawText(
-            const SkPaint& paint, const void* bytes, size_t byteLength,
-            SkPoint origin);
+            const SkPaint& paint, const void* bytes, size_t byteLength, SkPoint origin);
     void drawPosTextH(
             const SkPaint& paint, const void* bytes, size_t byteLength,
             const SkScalar* xpos, SkScalar constY);
     void drawPosText(
-            const SkPaint& paint, const void* bytes, size_t byteLength,
-            const SkPoint* pos);
+            const SkPaint& paint, const void* bytes, size_t byteLength, const SkPoint* pos);
+    void drawTextBlob(const SkPaint& paint, const SkTextBlob& blob, SkPoint origin);
 
     SkGlyphRun* useGlyphRun();
+    SkGlyphRunList* useGlyphRunList();
 
 private:
     void initialize(size_t totalRunSize);
     SkSpan<const SkGlyphID> textToGlyphIDs(
             const SkPaint& paint, const void* bytes, size_t byteLength);
 
     // Returns the span of unique glyph IDs.
     SkSpan<const SkGlyphID> addDenseAndUnique(
             const SkPaint& paint,
             SkSpan<const SkGlyphID> glyphIDs,
             uint16_t* uniqueGlyphIDIndices,
             SkGlyphID* uniqueGlyphIDs);
 
     void makeGlyphRun(
             const SkPaint& runPaint,
             SkSpan<const SkGlyphID> glyphIDs,
             SkSpan<const SkPoint> positions,
             SkSpan<const uint16_t> uniqueGlyphIDIndices,
             SkSpan<const SkGlyphID> uniqueGlyphIDs,
             SkSpan<const char> text,
             SkSpan<const uint32_t> clusters);
 
-    void simplifyDrawText(
+    void makeGlyphRunList(const SkPaint& paint, const SkTextBlob* blob, SkPoint origin);
+
+    size_t simplifyDrawText(
             const SkPaint& paint, SkSpan<const SkGlyphID> glyphIDs, SkPoint origin,
             uint16_t* uniqueGlyphIDIndices, SkGlyphID* uniqueGlyphIDs, SkPoint* positions,
             SkSpan<const char> text = SkSpan<const char>{},
             SkSpan<const uint32_t> clusters = SkSpan<const uint32_t>{});
-    void simplifyDrawPosTextH(
+    size_t simplifyDrawPosTextH(
             const SkPaint& paint, SkSpan<const SkGlyphID> glyphIDs,
             const SkScalar* xpos, SkScalar constY,
             uint16_t* uniqueGlyphIDIndices, SkGlyphID* uniqueGlyphIDs, SkPoint* positions,
             SkSpan<const char> text = SkSpan<const char>{},
             SkSpan<const uint32_t> clusters = SkSpan<const uint32_t>{});
-    void simplifyDrawPosText(
+    size_t simplifyDrawPosText(
             const SkPaint& paint, SkSpan<const SkGlyphID> glyphIDs, const SkPoint* pos,
             uint16_t* uniqueGlyphIDIndices, SkGlyphID* uniqueGlyphIDs,
             SkSpan<const char> text = SkSpan<const char>{},
             SkSpan<const uint32_t> clusters = SkSpan<const uint32_t>{});
 
-    uint64_t fUniqueID{0};
 
     size_t fMaxTotalRunSize{0};
     SkAutoTMalloc<uint16_t> fUniqueGlyphIDIndices;
     SkAutoTMalloc<SkPoint> fPositions;
     SkAutoTMalloc<SkGlyphID> fUniqueGlyphIDs;
 
+    std::vector<SkGlyphRun> fGlyphRunListStorage;
+    SkGlyphRunList fGlyphRunList;
+
+
     // Used as a temporary for preparing using utfN text. This implies that only one run of
     // glyph ids will ever be needed because blobs are already glyph based.
     std::vector<SkGlyphID> fScratchGlyphIDs;
 
     // Used as temporary storage for calculating positions for drawText.
     std::vector<SkPoint> fScratchAdvances;
 
-
-    // Used as temporary glyph run for the rest of the Text stack.
-    SkGlyphRun fScratchGlyphRun;
-
     // Used for collecting the set of unique glyphs.
     SkGlyphIDSet fGlyphIDSet;
 };
 
 #endif  // SkGlyphRunInfo_DEFINED
diff --git a/src/gpu/text/GrTextContext.cpp b/src/gpu/text/GrTextContext.cpp
index 04d92aef39..a2ef40f16d 100644
--- a/src/gpu/text/GrTextContext.cpp
+++ b/src/gpu/text/GrTextContext.cpp
@@ -185,92 +185,97 @@ void GrTextContext::drawTextBlob(GrContext* context, GrTextUtils::Target* target
 void GrTextContext::regenerateTextBlob(GrTextBlob* cacheBlob,
                                        GrGlyphCache* glyphCache,
                                        const GrShaderCaps& shaderCaps,
                                        const GrTextUtils::Paint& paint,
                                        SkScalerContextFlags scalerContextFlags,
                                        const SkMatrix& viewMatrix,
                                        const SkSurfaceProps& props, const SkTextBlob* blob,
                                        SkScalar x, SkScalar y) const {
     cacheBlob->initReusableBlob(paint.luminanceColor(), viewMatrix, x, y);
 
     // Regenerate textblob
     SkTextBlobRunIterator it(blob);
     GrTextUtils::RunPaint runPaint(&paint);
     for (int run = 0; !it.done(); it.next(), run++) {
         int glyphCount = it.glyphCount();
         size_t textLen = glyphCount * sizeof(uint16_t);
         const SkPoint& offset = it.offset();
         cacheBlob->push_back_run(run);
         if (!runPaint.modifyForRun([it](SkPaint* p) { it.applyFontToPaint(p); })) {
             continue;
         }
         cacheBlob->setRunPaintFlags(run, runPaint.skPaint().getFlags());
 
         if (CanDrawAsDistanceFields(runPaint, viewMatrix, props,
                                     shaderCaps.supportsDistanceFieldText(), fOptions)) {
             switch (it.positioning()) {
                 case SkTextBlob::kDefault_Positioning: {
                     auto origin = SkPoint::Make(x + offset.x(), y + offset.y());
                     SkGlyphRunBuilder builder;
                     builder.drawText(runPaint.skPaint(),
                                      (const char*) it.glyphs(), textLen, origin);
 
-                    auto glyphRun = builder.useGlyphRun();
-
-                    glyphRun->temporaryShuntToCallback(
+                    auto glyphRunList = builder.useGlyphRunList();
+                    if (!glyphRunList->empty()) {
+                        auto glyphRun = (*glyphRunList)[0];
+                        glyphRun.temporaryShuntToCallback(
                             [&](size_t runSize, const char* glyphIDs, const SkScalar* pos) {
                                 this->drawDFPosText(
-                                    cacheBlob, run, glyphCache, props, runPaint, scalerContextFlags,
-                                    viewMatrix, glyphIDs, 2 * runSize, pos, 2,
-                                    SkPoint::Make(0,0));
+                                    cacheBlob, run, glyphCache, props, runPaint,
+                                    scalerContextFlags, viewMatrix, glyphIDs, 2 * runSize,
+                                    pos, 2, SkPoint::Make(0, 0));
                             });
+                    }
                     break;
                 }
 
                 case SkTextBlob::kHorizontal_Positioning: {
                     SkPoint dfOffset = SkPoint::Make(x, y + offset.y());
                     this->drawDFPosText(cacheBlob, run, glyphCache, props, runPaint,
                                         scalerContextFlags, viewMatrix, (const char*)it.glyphs(),
                                         textLen, it.pos(), 1, dfOffset);
                     break;
                 }
                 case SkTextBlob::kFull_Positioning: {
                     SkPoint dfOffset = SkPoint::Make(x, y);
                     this->drawDFPosText(cacheBlob, run, glyphCache, props, runPaint,
                                         scalerContextFlags, viewMatrix, (const char*)it.glyphs(),
                                         textLen, it.pos(), 2, dfOffset);
                     break;
                 }
             }
         } else {
             switch (it.positioning()) {
                 case SkTextBlob::kDefault_Positioning: {
                     auto origin = SkPoint::Make(x + offset.x(), y + offset.y());
                     SkGlyphRunBuilder builder;
                     builder.drawText(runPaint.skPaint(),
                                      (const char*) it.glyphs(), textLen, origin);
 
-                    auto glyphRun = builder.useGlyphRun();
+                    auto glyphRunList = builder.useGlyphRunList();
+                    if (!glyphRunList->empty()) {
+                        auto glyphRun = (*glyphRunList)[0];
 
-                    glyphRun->temporaryShuntToCallback(
+                        glyphRun.temporaryShuntToCallback(
                             [&](size_t runSize, const char* glyphIDs, const SkScalar* pos) {
                                 this->DrawBmpPosText(
-                                    cacheBlob, run, glyphCache, props, runPaint, scalerContextFlags,
-                                    viewMatrix, glyphIDs, 2 * runSize,
+                                    cacheBlob, run, glyphCache, props, runPaint,
+                                    scalerContextFlags, viewMatrix, glyphIDs, 2 * runSize,
                                     pos, 2, SkPoint::Make(0, 0));
                             });
+                    }
                     break;
                 }
                 case SkTextBlob::kHorizontal_Positioning:
                     DrawBmpPosText(cacheBlob, run, glyphCache, props, runPaint, scalerContextFlags,
                                    viewMatrix, (const char*)it.glyphs(), textLen, it.pos(), 1,
                                    SkPoint::Make(x, y + offset.y()));
                     break;
                 case SkTextBlob::kFull_Positioning:
                     DrawBmpPosText(cacheBlob, run, glyphCache, props, runPaint, scalerContextFlags,
                                    viewMatrix, (const char*)it.glyphs(), textLen, it.pos(), 2,
                                    SkPoint::Make(x, y));
                     break;
             }
         }
     }
 }
@@ -762,38 +767,42 @@ void GrTextContext::FallbackTextHelper::initializeForDraw(SkPaint* paint, SkScal
 std::unique_ptr<GrDrawOp> GrTextContext::createOp_TestingOnly(GrContext* context,
                                                               GrTextContext* textContext,
                                                               GrRenderTargetContext* rtc,
                                                               const SkPaint& skPaint,
                                                               const SkMatrix& viewMatrix,
                                                               const char* text,
                                                               int x,
                                                               int y) {
     auto glyphCache = context->contextPriv().getGlyphCache();
 
     static SkSurfaceProps surfaceProps(SkSurfaceProps::kLegacyFontHost_InitType);
 
     size_t textLen = (int)strlen(text);
 
     GrTextUtils::Paint utilsPaint(&skPaint, &rtc->colorSpaceInfo());
 
     // right now we don't handle textblobs, nor do we handle drawPosText. Since we only intend to
     // test the text op with this unit test, that is okay.
 
     auto origin = SkPoint::Make(x, y);
     SkGlyphRunBuilder builder;
     builder.drawText(skPaint, text, textLen, origin);
     sk_sp<GrTextBlob> blob;
 
-    auto glyphRun = builder.useGlyphRun();
-    // Use the text and textLen below, because we don't want to mess with the paint.
-    glyphRun->temporaryShuntToCallback(
+    auto glyphRunList = builder.useGlyphRunList();
+    if (!glyphRunList->empty()) {
+        auto glyphRun = (*glyphRunList)[0];
+        // Use the text and textLen below, because we don't want to mess with the paint.
+        glyphRun.temporaryShuntToCallback(
             [&](size_t runSize, const char* glyphIDs, const SkScalar* pos) {
                 blob = textContext->makeDrawPosTextBlob(
                     context->contextPriv().getTextBlobCache(), glyphCache,
                     *context->contextPriv().caps()->shaderCaps(), utilsPaint,
-                    GrTextContext::kTextBlobOpScalerContextFlags, viewMatrix, surfaceProps, text,
+                    GrTextContext::kTextBlobOpScalerContextFlags, viewMatrix, surfaceProps,
+                    text,
                     textLen, pos, 2, origin);
             });
+    }
 
     return blob->test_makeOp(textLen, 0, 0, viewMatrix, x, y, utilsPaint, surfaceProps,
                              textContext->dfAdjustTable(), rtc->textTarget());
 }
diff --git a/tests/GlyphRunTest.cpp b/tests/GlyphRunTest.cpp
index b87edc7731..49d7340aca 100644
--- a/tests/GlyphRunTest.cpp
+++ b/tests/GlyphRunTest.cpp
@@ -49,3 +49,57 @@ DEF_TEST(GlyphRunBasic, reporter) {
     SkGlyphRunBuilder builder;
     builder.drawText(paint, glyphs, count, SkPoint::Make(0, 0));
 }
+
+DEF_TEST(GlyphRunBlob, reporter) {
+    constexpr uint16_t count = 5;
+    constexpr int runCount = 2;
+
+    auto tf = SkTypeface::MakeFromName("monospace", SkFontStyle());
+
+    SkPaint font;
+    font.setTypeface(tf);
+    font.setTextEncoding(SkPaint::kGlyphID_TextEncoding);
+    font.setTextAlign(SkPaint::kLeft_Align);
+    font.setStyle(SkPaint::kFill_Style);
+    font.setHinting(SkPaint::kNormal_Hinting);
+    font.setTextSize(1u);
+
+    SkTextBlobBuilder blobBuilder;
+    for (int runNum = 0; runNum < runCount; runNum++) {
+        const auto& runBuffer = blobBuilder.allocRunPosH(font, count, runNum);
+        SkASSERT(runBuffer.utf8text == nullptr);
+        SkASSERT(runBuffer.clusters == nullptr);
+
+        for (int i = 0; i < count; i++) {
+            runBuffer.glyphs[i] = static_cast<SkGlyphID>(i + runNum * count);
+            runBuffer.pos[i] = SkIntToScalar(i + runNum * count);
+        }
+    }
+
+    auto blob = blobBuilder.make();
+
+    SkPaint paint;
+    paint.setTextEncoding(SkPaint::kGlyphID_TextEncoding);
+
+    SkGlyphRunBuilder runBuilder;
+    runBuilder.drawTextBlob(font, *blob, SkPoint::Make(0, 0));
+
+    auto runList = runBuilder.useGlyphRunList();
+
+    REPORTER_ASSERT(reporter, runList->size() == runCount);
+    int runIndex = 0;
+    for (auto& run : *runList) {
+        REPORTER_ASSERT(reporter, run.runSize() == count);
+
+        int index = 0;
+        for (auto p : run.positions()) {
+            if (p.x() != runIndex * count + index) {
+                ERRORF(reporter, "x: %g != k: %d", p.x(), runIndex * count + index);
+                break;
+            }
+            index += 1;
+        }
+
+        runIndex += 1;
+    }
+}
