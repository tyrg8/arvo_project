commit d0f24df648f46e4c9a385e12a057fbade21427db
Author: Paul B Mahol <onemda@gmail.com>
Date:   Wed Apr 10 12:10:09 2019 +0200

    avcodec: add ADPCM AGM decoder

diff --git a/libavcodec/Makefile b/libavcodec/Makefile
index de873c1643..02849f91ec 100644
--- a/libavcodec/Makefile
+++ b/libavcodec/Makefile
@@ -808,6 +808,7 @@ OBJS-$(CONFIG_ADPCM_4XM_DECODER)          += adpcm.o adpcm_data.o
 OBJS-$(CONFIG_ADPCM_ADX_DECODER)          += adxdec.o adx.o
 OBJS-$(CONFIG_ADPCM_ADX_ENCODER)          += adxenc.o adx.o
 OBJS-$(CONFIG_ADPCM_AFC_DECODER)          += adpcm.o adpcm_data.o
+OBJS-$(CONFIG_ADPCM_AGM_DECODER)          += adpcm.o adpcm_data.o
 OBJS-$(CONFIG_ADPCM_AICA_DECODER)         += adpcm.o adpcm_data.o
 OBJS-$(CONFIG_ADPCM_CT_DECODER)           += adpcm.o adpcm_data.o
 OBJS-$(CONFIG_ADPCM_DTK_DECODER)          += adpcm.o adpcm_data.o
diff --git a/libavcodec/adpcm.c b/libavcodec/adpcm.c
index aa9c7c5c4f..ede0130bf1 100644
--- a/libavcodec/adpcm.c
+++ b/libavcodec/adpcm.c
@@ -177,6 +177,50 @@ static av_cold int adpcm_decode_init(AVCodecContext * avctx)
     return 0;
 }
 
+static inline int16_t adpcm_agm_expand_nibble(ADPCMChannelStatus *c, int8_t nibble)
+{
+    int delta, pred, step, add;
+
+    pred = c->predictor;
+    delta = nibble & 7;
+    step = c->step;
+    add = (delta * 2 + 1) * step;
+    if (add < 0)
+        add = add + 7;
+
+    if ((nibble & 8) == 0)
+        pred = av_clip(pred + (add >> 3), -32767, 32767);
+    else
+        pred = av_clip(pred - (add >> 3), -32767, 32767);
+
+    switch (delta) {
+    case 7:
+        step *= 0x99;
+        break;
+    case 6:
+        c->step = av_clip(c->step * 2, 127, 24576);
+        c->predictor = pred;
+        return pred;
+    case 5:
+        step *= 0x66;
+        break;
+    case 4:
+        step *= 0x4d;
+        break;
+    default:
+        step *= 0x39;
+        break;
+    }
+
+    if (step < 0)
+        step += 0x3f;
+
+    c->step = step >> 6;
+    c->step = av_clip(c->step, 127, 24576);
+    c->predictor = pred;
+    return pred;
+}
+
 static inline int16_t adpcm_ima_expand_nibble(ADPCMChannelStatus *c, int8_t nibble, int shift)
 {
     int step_index;
@@ -496,211 +540,212 @@ static void adpcm_swf_decode(AVCodecContext *avctx, const uint8_t *buf, int buf_
 /**
  * Get the number of samples that will be decoded from the packet.
  * In one case, this is actually the maximum number of samples possible to
  * decode with the given buf_size.
  *
  * @param[out] coded_samples set to the number of samples as coded in the
  *                           packet, or 0 if the codec does not encode the
  *                           number of samples in each frame.
  * @param[out] approx_nb_samples set to non-zero if the number of samples
  *                               returned is an approximation.
  */
 static int get_nb_samples(AVCodecContext *avctx, GetByteContext *gb,
                           int buf_size, int *coded_samples, int *approx_nb_samples)
 {
     ADPCMDecodeContext *s = avctx->priv_data;
     int nb_samples        = 0;
     int ch                = avctx->channels;
     int has_coded_samples = 0;
     int header_size;
 
     *coded_samples = 0;
     *approx_nb_samples = 0;
 
     if(ch <= 0)
         return 0;
 
     switch (avctx->codec->id) {
     /* constant, only check buf_size */
     case AV_CODEC_ID_ADPCM_EA_XAS:
         if (buf_size < 76 * ch)
             return 0;
         nb_samples = 128;
         break;
     case AV_CODEC_ID_ADPCM_IMA_QT:
         if (buf_size < 34 * ch)
             return 0;
         nb_samples = 64;
         break;
     /* simple 4-bit adpcm */
     case AV_CODEC_ID_ADPCM_CT:
     case AV_CODEC_ID_ADPCM_IMA_APC:
     case AV_CODEC_ID_ADPCM_IMA_EA_SEAD:
     case AV_CODEC_ID_ADPCM_IMA_OKI:
     case AV_CODEC_ID_ADPCM_IMA_WS:
     case AV_CODEC_ID_ADPCM_YAMAHA:
     case AV_CODEC_ID_ADPCM_AICA:
         nb_samples = buf_size * 2 / ch;
         break;
     }
     if (nb_samples)
         return nb_samples;
 
     /* simple 4-bit adpcm, with header */
     header_size = 0;
     switch (avctx->codec->id) {
         case AV_CODEC_ID_ADPCM_4XM:
+        case AV_CODEC_ID_ADPCM_AGM:
         case AV_CODEC_ID_ADPCM_IMA_DAT4:
         case AV_CODEC_ID_ADPCM_IMA_ISS:     header_size = 4 * ch;      break;
         case AV_CODEC_ID_ADPCM_IMA_AMV:     header_size = 8;           break;
         case AV_CODEC_ID_ADPCM_IMA_SMJPEG:  header_size = 4 * ch;      break;
     }
     if (header_size > 0)
         return (buf_size - header_size) * 2 / ch;
 
     /* more complex formats */
     switch (avctx->codec->id) {
     case AV_CODEC_ID_ADPCM_EA:
         has_coded_samples = 1;
         *coded_samples  = bytestream2_get_le32(gb);
         *coded_samples -= *coded_samples % 28;
         nb_samples      = (buf_size - 12) / 30 * 28;
         break;
     case AV_CODEC_ID_ADPCM_IMA_EA_EACS:
         has_coded_samples = 1;
         *coded_samples = bytestream2_get_le32(gb);
         nb_samples     = (buf_size - (4 + 8 * ch)) * 2 / ch;
         break;
     case AV_CODEC_ID_ADPCM_EA_MAXIS_XA:
         nb_samples = (buf_size - ch) / ch * 2;
         break;
     case AV_CODEC_ID_ADPCM_EA_R1:
     case AV_CODEC_ID_ADPCM_EA_R2:
     case AV_CODEC_ID_ADPCM_EA_R3:
         /* maximum number of samples */
         /* has internal offsets and a per-frame switch to signal raw 16-bit */
         has_coded_samples = 1;
         switch (avctx->codec->id) {
         case AV_CODEC_ID_ADPCM_EA_R1:
             header_size    = 4 + 9 * ch;
             *coded_samples = bytestream2_get_le32(gb);
             break;
         case AV_CODEC_ID_ADPCM_EA_R2:
             header_size    = 4 + 5 * ch;
             *coded_samples = bytestream2_get_le32(gb);
             break;
         case AV_CODEC_ID_ADPCM_EA_R3:
             header_size    = 4 + 5 * ch;
             *coded_samples = bytestream2_get_be32(gb);
             break;
         }
         *coded_samples -= *coded_samples % 28;
         nb_samples      = (buf_size - header_size) * 2 / ch;
         nb_samples     -= nb_samples % 28;
         *approx_nb_samples = 1;
         break;
     case AV_CODEC_ID_ADPCM_IMA_DK3:
         if (avctx->block_align > 0)
             buf_size = FFMIN(buf_size, avctx->block_align);
         nb_samples = ((buf_size - 16) * 2 / 3 * 4) / ch;
         break;
     case AV_CODEC_ID_ADPCM_IMA_DK4:
         if (avctx->block_align > 0)
             buf_size = FFMIN(buf_size, avctx->block_align);
         if (buf_size < 4 * ch)
             return AVERROR_INVALIDDATA;
         nb_samples = 1 + (buf_size - 4 * ch) * 2 / ch;
         break;
     case AV_CODEC_ID_ADPCM_IMA_RAD:
         if (avctx->block_align > 0)
             buf_size = FFMIN(buf_size, avctx->block_align);
         nb_samples = (buf_size - 4 * ch) * 2 / ch;
         break;
     case AV_CODEC_ID_ADPCM_IMA_WAV:
     {
         int bsize = ff_adpcm_ima_block_sizes[avctx->bits_per_coded_sample - 2];
         int bsamples = ff_adpcm_ima_block_samples[avctx->bits_per_coded_sample - 2];
         if (avctx->block_align > 0)
             buf_size = FFMIN(buf_size, avctx->block_align);
         if (buf_size < 4 * ch)
             return AVERROR_INVALIDDATA;
         nb_samples = 1 + (buf_size - 4 * ch) / (bsize * ch) * bsamples;
         break;
     }
     case AV_CODEC_ID_ADPCM_MS:
         if (avctx->block_align > 0)
             buf_size = FFMIN(buf_size, avctx->block_align);
         nb_samples = (buf_size - 6 * ch) * 2 / ch;
         break;
     case AV_CODEC_ID_ADPCM_MTAF:
         if (avctx->block_align > 0)
             buf_size = FFMIN(buf_size, avctx->block_align);
         nb_samples = (buf_size - 16 * (ch / 2)) * 2 / ch;
         break;
     case AV_CODEC_ID_ADPCM_SBPRO_2:
     case AV_CODEC_ID_ADPCM_SBPRO_3:
     case AV_CODEC_ID_ADPCM_SBPRO_4:
     {
         int samples_per_byte;
         switch (avctx->codec->id) {
         case AV_CODEC_ID_ADPCM_SBPRO_2: samples_per_byte = 4; break;
         case AV_CODEC_ID_ADPCM_SBPRO_3: samples_per_byte = 3; break;
         case AV_CODEC_ID_ADPCM_SBPRO_4: samples_per_byte = 2; break;
         }
         if (!s->status[0].step_index) {
             if (buf_size < ch)
                 return AVERROR_INVALIDDATA;
             nb_samples++;
             buf_size -= ch;
         }
         nb_samples += buf_size * samples_per_byte / ch;
         break;
     }
     case AV_CODEC_ID_ADPCM_SWF:
     {
         int buf_bits       = buf_size * 8 - 2;
         int nbits          = (bytestream2_get_byte(gb) >> 6) + 2;
         int block_hdr_size = 22 * ch;
         int block_size     = block_hdr_size + nbits * ch * 4095;
         int nblocks        = buf_bits / block_size;
         int bits_left      = buf_bits - nblocks * block_size;
         nb_samples         = nblocks * 4096;
         if (bits_left >= block_hdr_size)
             nb_samples += 1 + (bits_left - block_hdr_size) / (nbits * ch);
         break;
     }
     case AV_CODEC_ID_ADPCM_THP:
     case AV_CODEC_ID_ADPCM_THP_LE:
         if (avctx->extradata) {
             nb_samples = buf_size * 14 / (8 * ch);
             break;
         }
         has_coded_samples = 1;
         bytestream2_skip(gb, 4); // channel size
         *coded_samples  = (avctx->codec->id == AV_CODEC_ID_ADPCM_THP_LE) ?
                           bytestream2_get_le32(gb) :
                           bytestream2_get_be32(gb);
         buf_size       -= 8 + 36 * ch;
         buf_size       /= ch;
         nb_samples      = buf_size / 8 * 14;
         if (buf_size % 8 > 1)
             nb_samples     += (buf_size % 8 - 1) * 2;
         *approx_nb_samples = 1;
         break;
     case AV_CODEC_ID_ADPCM_AFC:
         nb_samples = buf_size / (9 * ch) * 16;
         break;
     case AV_CODEC_ID_ADPCM_XA:
         nb_samples = (buf_size / 128) * 224 / ch;
         break;
     case AV_CODEC_ID_ADPCM_DTK:
     case AV_CODEC_ID_ADPCM_PSX:
         nb_samples = buf_size / (16 * ch) * 28;
         break;
     }
 
     /* validate coded sample count */
     if (has_coded_samples && (*coded_samples <= 0 || *coded_samples > nb_samples))
         return AVERROR_INVALIDDATA;
 
     return nb_samples;
 }
@@ -708,991 +753,1003 @@ static int get_nb_samples(AVCodecContext *avctx, GetByteContext *gb,
 static int adpcm_decode_frame(AVCodecContext *avctx, void *data,
                               int *got_frame_ptr, AVPacket *avpkt)
 {
     AVFrame *frame     = data;
     const uint8_t *buf = avpkt->data;
     int buf_size = avpkt->size;
     ADPCMDecodeContext *c = avctx->priv_data;
     ADPCMChannelStatus *cs;
     int n, m, channel, i;
     int16_t *samples;
     int16_t **samples_p;
     int st; /* stereo */
     int count1, count2;
     int nb_samples, coded_samples, approx_nb_samples, ret;
     GetByteContext gb;
 
     bytestream2_init(&gb, buf, buf_size);
     nb_samples = get_nb_samples(avctx, &gb, buf_size, &coded_samples, &approx_nb_samples);
     if (nb_samples <= 0) {
         av_log(avctx, AV_LOG_ERROR, "invalid number of samples in packet\n");
         return AVERROR_INVALIDDATA;
     }
 
     /* get output buffer */
     frame->nb_samples = nb_samples;
     if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)
         return ret;
     samples = (int16_t *)frame->data[0];
     samples_p = (int16_t **)frame->extended_data;
 
     /* use coded_samples when applicable */
     /* it is always <= nb_samples, so the output buffer will be large enough */
     if (coded_samples) {
         if (!approx_nb_samples && coded_samples != nb_samples)
             av_log(avctx, AV_LOG_WARNING, "mismatch in coded sample count\n");
         frame->nb_samples = nb_samples = coded_samples;
     }
 
     st = avctx->channels == 2 ? 1 : 0;
 
     switch(avctx->codec->id) {
     case AV_CODEC_ID_ADPCM_IMA_QT:
         /* In QuickTime, IMA is encoded by chunks of 34 bytes (=64 samples).
            Channel data is interleaved per-chunk. */
         for (channel = 0; channel < avctx->channels; channel++) {
             int predictor;
             int step_index;
             cs = &(c->status[channel]);
             /* (pppppp) (piiiiiii) */
 
             /* Bits 15-7 are the _top_ 9 bits of the 16-bit initial predictor value */
             predictor = sign_extend(bytestream2_get_be16u(&gb), 16);
             step_index = predictor & 0x7F;
             predictor &= ~0x7F;
 
             if (cs->step_index == step_index) {
                 int diff = predictor - cs->predictor;
                 if (diff < 0)
                     diff = - diff;
                 if (diff > 0x7f)
                     goto update;
             } else {
             update:
                 cs->step_index = step_index;
                 cs->predictor = predictor;
             }
 
             if (cs->step_index > 88u){
                 av_log(avctx, AV_LOG_ERROR, "ERROR: step_index[%d] = %i\n",
                        channel, cs->step_index);
                 return AVERROR_INVALIDDATA;
             }
 
             samples = samples_p[channel];
 
             for (m = 0; m < 64; m += 2) {
                 int byte = bytestream2_get_byteu(&gb);
                 samples[m    ] = adpcm_ima_qt_expand_nibble(cs, byte & 0x0F, 3);
                 samples[m + 1] = adpcm_ima_qt_expand_nibble(cs, byte >> 4  , 3);
             }
         }
         break;
     case AV_CODEC_ID_ADPCM_IMA_WAV:
         for(i=0; i<avctx->channels; i++){
             cs = &(c->status[i]);
             cs->predictor = samples_p[i][0] = sign_extend(bytestream2_get_le16u(&gb), 16);
 
             cs->step_index = sign_extend(bytestream2_get_le16u(&gb), 16);
             if (cs->step_index > 88u){
                 av_log(avctx, AV_LOG_ERROR, "ERROR: step_index[%d] = %i\n",
                        i, cs->step_index);
                 return AVERROR_INVALIDDATA;
             }
         }
 
         if (avctx->bits_per_coded_sample != 4) {
             int samples_per_block = ff_adpcm_ima_block_samples[avctx->bits_per_coded_sample - 2];
             int block_size = ff_adpcm_ima_block_sizes[avctx->bits_per_coded_sample - 2];
             uint8_t temp[20 + AV_INPUT_BUFFER_PADDING_SIZE] = { 0 };
             GetBitContext g;
 
             for (n = 0; n < (nb_samples - 1) / samples_per_block; n++) {
                 for (i = 0; i < avctx->channels; i++) {
                     int j;
 
                     cs = &c->status[i];
                     samples = &samples_p[i][1 + n * samples_per_block];
                     for (j = 0; j < block_size; j++) {
                         temp[j] = buf[4 * avctx->channels + block_size * n * avctx->channels +
                                         (j % 4) + (j / 4) * (avctx->channels * 4) + i * 4];
                     }
                     ret = init_get_bits8(&g, (const uint8_t *)&temp, block_size);
                     if (ret < 0)
                         return ret;
                     for (m = 0; m < samples_per_block; m++) {
                         samples[m] = adpcm_ima_wav_expand_nibble(cs, &g,
                                           avctx->bits_per_coded_sample);
                     }
                 }
             }
             bytestream2_skip(&gb, avctx->block_align - avctx->channels * 4);
         } else {
         for (n = 0; n < (nb_samples - 1) / 8; n++) {
             for (i = 0; i < avctx->channels; i++) {
                 cs = &c->status[i];
                 samples = &samples_p[i][1 + n * 8];
                 for (m = 0; m < 8; m += 2) {
                     int v = bytestream2_get_byteu(&gb);
                     samples[m    ] = adpcm_ima_expand_nibble(cs, v & 0x0F, 3);
                     samples[m + 1] = adpcm_ima_expand_nibble(cs, v >> 4  , 3);
                 }
             }
         }
         }
         break;
     case AV_CODEC_ID_ADPCM_4XM:
         for (i = 0; i < avctx->channels; i++)
             c->status[i].predictor = sign_extend(bytestream2_get_le16u(&gb), 16);
 
         for (i = 0; i < avctx->channels; i++) {
             c->status[i].step_index = sign_extend(bytestream2_get_le16u(&gb), 16);
             if (c->status[i].step_index > 88u) {
                 av_log(avctx, AV_LOG_ERROR, "ERROR: step_index[%d] = %i\n",
                        i, c->status[i].step_index);
                 return AVERROR_INVALIDDATA;
             }
         }
 
         for (i = 0; i < avctx->channels; i++) {
             samples = (int16_t *)frame->data[i];
             cs = &c->status[i];
             for (n = nb_samples >> 1; n > 0; n--) {
                 int v = bytestream2_get_byteu(&gb);
                 *samples++ = adpcm_ima_expand_nibble(cs, v & 0x0F, 4);
                 *samples++ = adpcm_ima_expand_nibble(cs, v >> 4  , 4);
             }
         }
         break;
+    case AV_CODEC_ID_ADPCM_AGM:
+        for (i = 0; i < avctx->channels; i++)
+            c->status[i].predictor = sign_extend(bytestream2_get_le16u(&gb), 16);
+        for (i = 0; i < avctx->channels; i++)
+            c->status[i].step = sign_extend(bytestream2_get_le16u(&gb), 16);
+
+        for (n = 0; n < nb_samples >> (1 - st); n++) {
+            int v = bytestream2_get_byteu(&gb);
+            *samples++ = adpcm_agm_expand_nibble(&c->status[0], v & 0xF);
+            *samples++ = adpcm_agm_expand_nibble(&c->status[st], v >> 4 );
+        }
+        break;
     case AV_CODEC_ID_ADPCM_MS:
     {
         int block_predictor;
 
         block_predictor = bytestream2_get_byteu(&gb);
         if (block_predictor > 6) {
             av_log(avctx, AV_LOG_ERROR, "ERROR: block_predictor[0] = %d\n",
                    block_predictor);
             return AVERROR_INVALIDDATA;
         }
         c->status[0].coeff1 = ff_adpcm_AdaptCoeff1[block_predictor];
         c->status[0].coeff2 = ff_adpcm_AdaptCoeff2[block_predictor];
         if (st) {
             block_predictor = bytestream2_get_byteu(&gb);
             if (block_predictor > 6) {
                 av_log(avctx, AV_LOG_ERROR, "ERROR: block_predictor[1] = %d\n",
                        block_predictor);
                 return AVERROR_INVALIDDATA;
             }
             c->status[1].coeff1 = ff_adpcm_AdaptCoeff1[block_predictor];
             c->status[1].coeff2 = ff_adpcm_AdaptCoeff2[block_predictor];
         }
         c->status[0].idelta = sign_extend(bytestream2_get_le16u(&gb), 16);
         if (st){
             c->status[1].idelta = sign_extend(bytestream2_get_le16u(&gb), 16);
         }
 
         c->status[0].sample1 = sign_extend(bytestream2_get_le16u(&gb), 16);
         if (st) c->status[1].sample1 = sign_extend(bytestream2_get_le16u(&gb), 16);
         c->status[0].sample2 = sign_extend(bytestream2_get_le16u(&gb), 16);
         if (st) c->status[1].sample2 = sign_extend(bytestream2_get_le16u(&gb), 16);
 
         *samples++ = c->status[0].sample2;
         if (st) *samples++ = c->status[1].sample2;
         *samples++ = c->status[0].sample1;
         if (st) *samples++ = c->status[1].sample1;
         for(n = (nb_samples - 2) >> (1 - st); n > 0; n--) {
             int byte = bytestream2_get_byteu(&gb);
             *samples++ = adpcm_ms_expand_nibble(&c->status[0 ], byte >> 4  );
             *samples++ = adpcm_ms_expand_nibble(&c->status[st], byte & 0x0F);
         }
         break;
     }
     case AV_CODEC_ID_ADPCM_MTAF:
         for (channel = 0; channel < avctx->channels; channel+=2) {
             bytestream2_skipu(&gb, 4);
             c->status[channel    ].step      = bytestream2_get_le16u(&gb) & 0x1f;
             c->status[channel + 1].step      = bytestream2_get_le16u(&gb) & 0x1f;
             c->status[channel    ].predictor = sign_extend(bytestream2_get_le16u(&gb), 16);
             bytestream2_skipu(&gb, 2);
             c->status[channel + 1].predictor = sign_extend(bytestream2_get_le16u(&gb), 16);
             bytestream2_skipu(&gb, 2);
             for (n = 0; n < nb_samples; n+=2) {
                 int v = bytestream2_get_byteu(&gb);
                 samples_p[channel][n    ] = adpcm_mtaf_expand_nibble(&c->status[channel], v & 0x0F);
                 samples_p[channel][n + 1] = adpcm_mtaf_expand_nibble(&c->status[channel], v >> 4  );
             }
             for (n = 0; n < nb_samples; n+=2) {
                 int v = bytestream2_get_byteu(&gb);
                 samples_p[channel + 1][n    ] = adpcm_mtaf_expand_nibble(&c->status[channel + 1], v & 0x0F);
                 samples_p[channel + 1][n + 1] = adpcm_mtaf_expand_nibble(&c->status[channel + 1], v >> 4  );
             }
         }
         break;
     case AV_CODEC_ID_ADPCM_IMA_DK4:
         for (channel = 0; channel < avctx->channels; channel++) {
             cs = &c->status[channel];
             cs->predictor  = *samples++ = sign_extend(bytestream2_get_le16u(&gb), 16);
             cs->step_index = sign_extend(bytestream2_get_le16u(&gb), 16);
             if (cs->step_index > 88u){
                 av_log(avctx, AV_LOG_ERROR, "ERROR: step_index[%d] = %i\n",
                        channel, cs->step_index);
                 return AVERROR_INVALIDDATA;
             }
         }
         for (n = (nb_samples - 1) >> (1 - st); n > 0; n--) {
             int v = bytestream2_get_byteu(&gb);
             *samples++ = adpcm_ima_expand_nibble(&c->status[0 ], v >> 4  , 3);
             *samples++ = adpcm_ima_expand_nibble(&c->status[st], v & 0x0F, 3);
         }
         break;
     case AV_CODEC_ID_ADPCM_IMA_DK3:
     {
         int last_byte = 0;
         int nibble;
         int decode_top_nibble_next = 0;
         int diff_channel;
         const int16_t *samples_end = samples + avctx->channels * nb_samples;
 
         bytestream2_skipu(&gb, 10);
         c->status[0].predictor  = sign_extend(bytestream2_get_le16u(&gb), 16);
         c->status[1].predictor  = sign_extend(bytestream2_get_le16u(&gb), 16);
         c->status[0].step_index = bytestream2_get_byteu(&gb);
         c->status[1].step_index = bytestream2_get_byteu(&gb);
         if (c->status[0].step_index > 88u || c->status[1].step_index > 88u){
             av_log(avctx, AV_LOG_ERROR, "ERROR: step_index = %i/%i\n",
                    c->status[0].step_index, c->status[1].step_index);
             return AVERROR_INVALIDDATA;
         }
         /* sign extend the predictors */
         diff_channel = c->status[1].predictor;
 
         /* DK3 ADPCM support macro */
 #define DK3_GET_NEXT_NIBBLE() \
     if (decode_top_nibble_next) { \
         nibble = last_byte >> 4; \
         decode_top_nibble_next = 0; \
     } else { \
         last_byte = bytestream2_get_byteu(&gb); \
         nibble = last_byte & 0x0F; \
         decode_top_nibble_next = 1; \
     }
 
         while (samples < samples_end) {
 
             /* for this algorithm, c->status[0] is the sum channel and
              * c->status[1] is the diff channel */
 
             /* process the first predictor of the sum channel */
             DK3_GET_NEXT_NIBBLE();
             adpcm_ima_expand_nibble(&c->status[0], nibble, 3);
 
             /* process the diff channel predictor */
             DK3_GET_NEXT_NIBBLE();
             adpcm_ima_expand_nibble(&c->status[1], nibble, 3);
 
             /* process the first pair of stereo PCM samples */
             diff_channel = (diff_channel + c->status[1].predictor) / 2;
             *samples++ = c->status[0].predictor + c->status[1].predictor;
             *samples++ = c->status[0].predictor - c->status[1].predictor;
 
             /* process the second predictor of the sum channel */
             DK3_GET_NEXT_NIBBLE();
             adpcm_ima_expand_nibble(&c->status[0], nibble, 3);
 
             /* process the second pair of stereo PCM samples */
             diff_channel = (diff_channel + c->status[1].predictor) / 2;
             *samples++ = c->status[0].predictor + c->status[1].predictor;
             *samples++ = c->status[0].predictor - c->status[1].predictor;
         }
 
         if ((bytestream2_tell(&gb) & 1))
             bytestream2_skip(&gb, 1);
         break;
     }
     case AV_CODEC_ID_ADPCM_IMA_ISS:
         for (channel = 0; channel < avctx->channels; channel++) {
             cs = &c->status[channel];
             cs->predictor  = sign_extend(bytestream2_get_le16u(&gb), 16);
             cs->step_index = sign_extend(bytestream2_get_le16u(&gb), 16);
             if (cs->step_index > 88u){
                 av_log(avctx, AV_LOG_ERROR, "ERROR: step_index[%d] = %i\n",
                        channel, cs->step_index);
                 return AVERROR_INVALIDDATA;
             }
         }
 
         for (n = nb_samples >> (1 - st); n > 0; n--) {
             int v1, v2;
             int v = bytestream2_get_byteu(&gb);
             /* nibbles are swapped for mono */
             if (st) {
                 v1 = v >> 4;
                 v2 = v & 0x0F;
             } else {
                 v2 = v >> 4;
                 v1 = v & 0x0F;
             }
             *samples++ = adpcm_ima_expand_nibble(&c->status[0 ], v1, 3);
             *samples++ = adpcm_ima_expand_nibble(&c->status[st], v2, 3);
         }
         break;
     case AV_CODEC_ID_ADPCM_IMA_DAT4:
         for (channel = 0; channel < avctx->channels; channel++) {
             cs = &c->status[channel];
             samples = samples_p[channel];
             bytestream2_skip(&gb, 4);
             for (n = 0; n < nb_samples; n += 2) {
                 int v = bytestream2_get_byteu(&gb);
                 *samples++ = adpcm_ima_expand_nibble(cs, v >> 4  , 3);
                 *samples++ = adpcm_ima_expand_nibble(cs, v & 0x0F, 3);
             }
         }
         break;
     case AV_CODEC_ID_ADPCM_IMA_APC:
         while (bytestream2_get_bytes_left(&gb) > 0) {
             int v = bytestream2_get_byteu(&gb);
             *samples++ = adpcm_ima_expand_nibble(&c->status[0],  v >> 4  , 3);
             *samples++ = adpcm_ima_expand_nibble(&c->status[st], v & 0x0F, 3);
         }
         break;
     case AV_CODEC_ID_ADPCM_IMA_OKI:
         while (bytestream2_get_bytes_left(&gb) > 0) {
             int v = bytestream2_get_byteu(&gb);
             *samples++ = adpcm_ima_oki_expand_nibble(&c->status[0],  v >> 4  );
             *samples++ = adpcm_ima_oki_expand_nibble(&c->status[st], v & 0x0F);
         }
         break;
     case AV_CODEC_ID_ADPCM_IMA_RAD:
         for (channel = 0; channel < avctx->channels; channel++) {
             cs = &c->status[channel];
             cs->step_index = sign_extend(bytestream2_get_le16u(&gb), 16);
             cs->predictor  = sign_extend(bytestream2_get_le16u(&gb), 16);
             if (cs->step_index > 88u){
                 av_log(avctx, AV_LOG_ERROR, "ERROR: step_index[%d] = %i\n",
                        channel, cs->step_index);
                 return AVERROR_INVALIDDATA;
             }
         }
         for (n = 0; n < nb_samples / 2; n++) {
             int byte[2];
 
             byte[0] = bytestream2_get_byteu(&gb);
             if (st)
                 byte[1] = bytestream2_get_byteu(&gb);
             for(channel = 0; channel < avctx->channels; channel++) {
                 *samples++ = adpcm_ima_expand_nibble(&c->status[channel], byte[channel] & 0x0F, 3);
             }
             for(channel = 0; channel < avctx->channels; channel++) {
                 *samples++ = adpcm_ima_expand_nibble(&c->status[channel], byte[channel] >> 4  , 3);
             }
         }
         break;
     case AV_CODEC_ID_ADPCM_IMA_WS:
         if (c->vqa_version == 3) {
             for (channel = 0; channel < avctx->channels; channel++) {
                 int16_t *smp = samples_p[channel];
 
                 for (n = nb_samples / 2; n > 0; n--) {
                     int v = bytestream2_get_byteu(&gb);
                     *smp++ = adpcm_ima_expand_nibble(&c->status[channel], v >> 4  , 3);
                     *smp++ = adpcm_ima_expand_nibble(&c->status[channel], v & 0x0F, 3);
                 }
             }
         } else {
             for (n = nb_samples / 2; n > 0; n--) {
                 for (channel = 0; channel < avctx->channels; channel++) {
                     int v = bytestream2_get_byteu(&gb);
                     *samples++  = adpcm_ima_expand_nibble(&c->status[channel], v >> 4  , 3);
                     samples[st] = adpcm_ima_expand_nibble(&c->status[channel], v & 0x0F, 3);
                 }
                 samples += avctx->channels;
             }
         }
         bytestream2_seek(&gb, 0, SEEK_END);
         break;
     case AV_CODEC_ID_ADPCM_XA:
     {
         int16_t *out0 = samples_p[0];
         int16_t *out1 = samples_p[1];
         int samples_per_block = 28 * (3 - avctx->channels) * 4;
         int sample_offset = 0;
         int bytes_remaining;
         while (bytestream2_get_bytes_left(&gb) >= 128) {
             if ((ret = xa_decode(avctx, out0, out1, buf + bytestream2_tell(&gb),
                                  &c->status[0], &c->status[1],
                                  avctx->channels, sample_offset)) < 0)
                 return ret;
             bytestream2_skipu(&gb, 128);
             sample_offset += samples_per_block;
         }
         /* Less than a full block of data left, e.g. when reading from
          * 2324 byte per sector XA; the remainder is padding */
         bytes_remaining = bytestream2_get_bytes_left(&gb);
         if (bytes_remaining > 0) {
             bytestream2_skip(&gb, bytes_remaining);
         }
         break;
     }
     case AV_CODEC_ID_ADPCM_IMA_EA_EACS:
         for (i=0; i<=st; i++) {
             c->status[i].step_index = bytestream2_get_le32u(&gb);
             if (c->status[i].step_index > 88u) {
                 av_log(avctx, AV_LOG_ERROR, "ERROR: step_index[%d] = %i\n",
                        i, c->status[i].step_index);
                 return AVERROR_INVALIDDATA;
             }
         }
         for (i=0; i<=st; i++)
             c->status[i].predictor  = bytestream2_get_le32u(&gb);
 
         for (n = nb_samples >> (1 - st); n > 0; n--) {
             int byte   = bytestream2_get_byteu(&gb);
             *samples++ = adpcm_ima_expand_nibble(&c->status[0],  byte >> 4,   3);
             *samples++ = adpcm_ima_expand_nibble(&c->status[st], byte & 0x0F, 3);
         }
         break;
     case AV_CODEC_ID_ADPCM_IMA_EA_SEAD:
         for (n = nb_samples >> (1 - st); n > 0; n--) {
             int byte = bytestream2_get_byteu(&gb);
             *samples++ = adpcm_ima_expand_nibble(&c->status[0],  byte >> 4,   6);
             *samples++ = adpcm_ima_expand_nibble(&c->status[st], byte & 0x0F, 6);
         }
         break;
     case AV_CODEC_ID_ADPCM_EA:
     {
         int previous_left_sample, previous_right_sample;
         int current_left_sample, current_right_sample;
         int next_left_sample, next_right_sample;
         int coeff1l, coeff2l, coeff1r, coeff2r;
         int shift_left, shift_right;
 
         /* Each EA ADPCM frame has a 12-byte header followed by 30-byte pieces,
            each coding 28 stereo samples. */
 
         if(avctx->channels != 2)
             return AVERROR_INVALIDDATA;
 
         current_left_sample   = sign_extend(bytestream2_get_le16u(&gb), 16);
         previous_left_sample  = sign_extend(bytestream2_get_le16u(&gb), 16);
         current_right_sample  = sign_extend(bytestream2_get_le16u(&gb), 16);
         previous_right_sample = sign_extend(bytestream2_get_le16u(&gb), 16);
 
         for (count1 = 0; count1 < nb_samples / 28; count1++) {
             int byte = bytestream2_get_byteu(&gb);
             coeff1l = ea_adpcm_table[ byte >> 4       ];
             coeff2l = ea_adpcm_table[(byte >> 4  ) + 4];
             coeff1r = ea_adpcm_table[ byte & 0x0F];
             coeff2r = ea_adpcm_table[(byte & 0x0F) + 4];
 
             byte = bytestream2_get_byteu(&gb);
             shift_left  = 20 - (byte >> 4);
             shift_right = 20 - (byte & 0x0F);
 
             for (count2 = 0; count2 < 28; count2++) {
                 byte = bytestream2_get_byteu(&gb);
                 next_left_sample  = sign_extend(byte >> 4, 4) << shift_left;
                 next_right_sample = sign_extend(byte,      4) << shift_right;
 
                 next_left_sample = (next_left_sample +
                     (current_left_sample * coeff1l) +
                     (previous_left_sample * coeff2l) + 0x80) >> 8;
                 next_right_sample = (next_right_sample +
                     (current_right_sample * coeff1r) +
                     (previous_right_sample * coeff2r) + 0x80) >> 8;
 
                 previous_left_sample = current_left_sample;
                 current_left_sample = av_clip_int16(next_left_sample);
                 previous_right_sample = current_right_sample;
                 current_right_sample = av_clip_int16(next_right_sample);
                 *samples++ = current_left_sample;
                 *samples++ = current_right_sample;
             }
         }
 
         bytestream2_skip(&gb, 2); // Skip terminating 0x0000
 
         break;
     }
     case AV_CODEC_ID_ADPCM_EA_MAXIS_XA:
     {
         int coeff[2][2], shift[2];
 
         for(channel = 0; channel < avctx->channels; channel++) {
             int byte = bytestream2_get_byteu(&gb);
             for (i=0; i<2; i++)
                 coeff[channel][i] = ea_adpcm_table[(byte >> 4) + 4*i];
             shift[channel] = 20 - (byte & 0x0F);
         }
         for (count1 = 0; count1 < nb_samples / 2; count1++) {
             int byte[2];
 
             byte[0] = bytestream2_get_byteu(&gb);
             if (st) byte[1] = bytestream2_get_byteu(&gb);
             for(i = 4; i >= 0; i-=4) { /* Pairwise samples LL RR (st) or LL LL (mono) */
                 for(channel = 0; channel < avctx->channels; channel++) {
                     int sample = sign_extend(byte[channel] >> i, 4) << shift[channel];
                     sample = (sample +
                              c->status[channel].sample1 * coeff[channel][0] +
                              c->status[channel].sample2 * coeff[channel][1] + 0x80) >> 8;
                     c->status[channel].sample2 = c->status[channel].sample1;
                     c->status[channel].sample1 = av_clip_int16(sample);
                     *samples++ = c->status[channel].sample1;
                 }
             }
         }
         bytestream2_seek(&gb, 0, SEEK_END);
         break;
     }
     case AV_CODEC_ID_ADPCM_EA_R1:
     case AV_CODEC_ID_ADPCM_EA_R2:
     case AV_CODEC_ID_ADPCM_EA_R3: {
         /* channel numbering
            2chan: 0=fl, 1=fr
            4chan: 0=fl, 1=rl, 2=fr, 3=rr
            6chan: 0=fl, 1=c,  2=fr, 3=rl,  4=rr, 5=sub */
         const int big_endian = avctx->codec->id == AV_CODEC_ID_ADPCM_EA_R3;
         int previous_sample, current_sample, next_sample;
         int coeff1, coeff2;
         int shift;
         unsigned int channel;
         uint16_t *samplesC;
         int count = 0;
         int offsets[6];
 
         for (channel=0; channel<avctx->channels; channel++)
             offsets[channel] = (big_endian ? bytestream2_get_be32(&gb) :
                                              bytestream2_get_le32(&gb)) +
                                (avctx->channels + 1) * 4;
 
         for (channel=0; channel<avctx->channels; channel++) {
             bytestream2_seek(&gb, offsets[channel], SEEK_SET);
             samplesC = samples_p[channel];
 
             if (avctx->codec->id == AV_CODEC_ID_ADPCM_EA_R1) {
                 current_sample  = sign_extend(bytestream2_get_le16(&gb), 16);
                 previous_sample = sign_extend(bytestream2_get_le16(&gb), 16);
             } else {
                 current_sample  = c->status[channel].predictor;
                 previous_sample = c->status[channel].prev_sample;
             }
 
             for (count1 = 0; count1 < nb_samples / 28; count1++) {
                 int byte = bytestream2_get_byte(&gb);
                 if (byte == 0xEE) {  /* only seen in R2 and R3 */
                     current_sample  = sign_extend(bytestream2_get_be16(&gb), 16);
                     previous_sample = sign_extend(bytestream2_get_be16(&gb), 16);
 
                     for (count2=0; count2<28; count2++)
                         *samplesC++ = sign_extend(bytestream2_get_be16(&gb), 16);
                 } else {
                     coeff1 = ea_adpcm_table[ byte >> 4     ];
                     coeff2 = ea_adpcm_table[(byte >> 4) + 4];
                     shift = 20 - (byte & 0x0F);
 
                     for (count2=0; count2<28; count2++) {
                         if (count2 & 1)
                             next_sample = sign_extend(byte,    4) << shift;
                         else {
                             byte = bytestream2_get_byte(&gb);
                             next_sample = sign_extend(byte >> 4, 4) << shift;
                         }
 
                         next_sample += (current_sample  * coeff1) +
                                        (previous_sample * coeff2);
                         next_sample = av_clip_int16(next_sample >> 8);
 
                         previous_sample = current_sample;
                         current_sample  = next_sample;
                         *samplesC++ = current_sample;
                     }
                 }
             }
             if (!count) {
                 count = count1;
             } else if (count != count1) {
                 av_log(avctx, AV_LOG_WARNING, "per-channel sample count mismatch\n");
                 count = FFMAX(count, count1);
             }
 
             if (avctx->codec->id != AV_CODEC_ID_ADPCM_EA_R1) {
                 c->status[channel].predictor   = current_sample;
                 c->status[channel].prev_sample = previous_sample;
             }
         }
 
         frame->nb_samples = count * 28;
         bytestream2_seek(&gb, 0, SEEK_END);
         break;
     }
     case AV_CODEC_ID_ADPCM_EA_XAS:
         for (channel=0; channel<avctx->channels; channel++) {
             int coeff[2][4], shift[4];
             int16_t *s = samples_p[channel];
             for (n = 0; n < 4; n++, s += 32) {
                 int val = sign_extend(bytestream2_get_le16u(&gb), 16);
                 for (i=0; i<2; i++)
                     coeff[i][n] = ea_adpcm_table[(val&0x0F)+4*i];
                 s[0] = val & ~0x0F;
 
                 val = sign_extend(bytestream2_get_le16u(&gb), 16);
                 shift[n] = 20 - (val & 0x0F);
                 s[1] = val & ~0x0F;
             }
 
             for (m=2; m<32; m+=2) {
                 s = &samples_p[channel][m];
                 for (n = 0; n < 4; n++, s += 32) {
                     int level, pred;
                     int byte = bytestream2_get_byteu(&gb);
 
                     level = sign_extend(byte >> 4, 4) << shift[n];
                     pred  = s[-1] * coeff[0][n] + s[-2] * coeff[1][n];
                     s[0]  = av_clip_int16((level + pred + 0x80) >> 8);
 
                     level = sign_extend(byte, 4) << shift[n];
                     pred  = s[0] * coeff[0][n] + s[-1] * coeff[1][n];
                     s[1]  = av_clip_int16((level + pred + 0x80) >> 8);
                 }
             }
         }
         break;
     case AV_CODEC_ID_ADPCM_IMA_AMV:
         c->status[0].predictor = sign_extend(bytestream2_get_le16u(&gb), 16);
         c->status[0].step_index = bytestream2_get_byteu(&gb);
         bytestream2_skipu(&gb, 5);
         if (c->status[0].step_index > 88u) {
             av_log(avctx, AV_LOG_ERROR, "ERROR: step_index = %i\n",
                    c->status[0].step_index);
             return AVERROR_INVALIDDATA;
         }
 
         for (n = nb_samples >> (1 - st); n > 0; n--) {
             int v = bytestream2_get_byteu(&gb);
 
             *samples++ = adpcm_ima_expand_nibble(&c->status[0], v >> 4, 3);
             *samples++ = adpcm_ima_expand_nibble(&c->status[0], v & 0xf, 3);
         }
         break;
     case AV_CODEC_ID_ADPCM_IMA_SMJPEG:
         for (i = 0; i < avctx->channels; i++) {
             c->status[i].predictor = sign_extend(bytestream2_get_be16u(&gb), 16);
             c->status[i].step_index = bytestream2_get_byteu(&gb);
             bytestream2_skipu(&gb, 1);
             if (c->status[i].step_index > 88u) {
                 av_log(avctx, AV_LOG_ERROR, "ERROR: step_index = %i\n",
                        c->status[i].step_index);
                 return AVERROR_INVALIDDATA;
             }
         }
 
         for (n = nb_samples >> (1 - st); n > 0; n--) {
             int v = bytestream2_get_byteu(&gb);
 
             *samples++ = adpcm_ima_qt_expand_nibble(&c->status[0 ], v >> 4, 3);
             *samples++ = adpcm_ima_qt_expand_nibble(&c->status[st], v & 0xf, 3);
         }
         break;
     case AV_CODEC_ID_ADPCM_CT:
         for (n = nb_samples >> (1 - st); n > 0; n--) {
             int v = bytestream2_get_byteu(&gb);
             *samples++ = adpcm_ct_expand_nibble(&c->status[0 ], v >> 4  );
             *samples++ = adpcm_ct_expand_nibble(&c->status[st], v & 0x0F);
         }
         break;
     case AV_CODEC_ID_ADPCM_SBPRO_4:
     case AV_CODEC_ID_ADPCM_SBPRO_3:
     case AV_CODEC_ID_ADPCM_SBPRO_2:
         if (!c->status[0].step_index) {
             /* the first byte is a raw sample */
             *samples++ = 128 * (bytestream2_get_byteu(&gb) - 0x80);
             if (st)
                 *samples++ = 128 * (bytestream2_get_byteu(&gb) - 0x80);
             c->status[0].step_index = 1;
             nb_samples--;
         }
         if (avctx->codec->id == AV_CODEC_ID_ADPCM_SBPRO_4) {
             for (n = nb_samples >> (1 - st); n > 0; n--) {
                 int byte = bytestream2_get_byteu(&gb);
                 *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],
                                                        byte >> 4,   4, 0);
                 *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],
                                                        byte & 0x0F, 4, 0);
             }
         } else if (avctx->codec->id == AV_CODEC_ID_ADPCM_SBPRO_3) {
             for (n = (nb_samples<<st) / 3; n > 0; n--) {
                 int byte = bytestream2_get_byteu(&gb);
                 *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],
                                                         byte >> 5        , 3, 0);
                 *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],
                                                        (byte >> 2) & 0x07, 3, 0);
                 *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],
                                                         byte & 0x03,       2, 0);
             }
         } else {
             for (n = nb_samples >> (2 - st); n > 0; n--) {
                 int byte = bytestream2_get_byteu(&gb);
                 *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],
                                                         byte >> 6        , 2, 2);
                 *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],
                                                        (byte >> 4) & 0x03, 2, 2);
                 *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],
                                                        (byte >> 2) & 0x03, 2, 2);
                 *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],
                                                         byte & 0x03,       2, 2);
             }
         }
         break;
     case AV_CODEC_ID_ADPCM_SWF:
         adpcm_swf_decode(avctx, buf, buf_size, samples);
         bytestream2_seek(&gb, 0, SEEK_END);
         break;
     case AV_CODEC_ID_ADPCM_YAMAHA:
         for (n = nb_samples >> (1 - st); n > 0; n--) {
             int v = bytestream2_get_byteu(&gb);
             *samples++ = adpcm_yamaha_expand_nibble(&c->status[0 ], v & 0x0F);
             *samples++ = adpcm_yamaha_expand_nibble(&c->status[st], v >> 4  );
         }
         break;
     case AV_CODEC_ID_ADPCM_AICA:
         if (!c->has_status) {
             for (channel = 0; channel < avctx->channels; channel++)
                 c->status[channel].step = 0;
             c->has_status = 1;
         }
         for (channel = 0; channel < avctx->channels; channel++) {
             samples = samples_p[channel];
             for (n = nb_samples >> 1; n > 0; n--) {
                 int v = bytestream2_get_byteu(&gb);
                 *samples++ = adpcm_yamaha_expand_nibble(&c->status[channel], v & 0x0F);
                 *samples++ = adpcm_yamaha_expand_nibble(&c->status[channel], v >> 4  );
             }
         }
         break;
     case AV_CODEC_ID_ADPCM_AFC:
     {
         int samples_per_block;
         int blocks;
 
         if (avctx->extradata && avctx->extradata_size == 1 && avctx->extradata[0]) {
             samples_per_block = avctx->extradata[0] / 16;
             blocks = nb_samples / avctx->extradata[0];
         } else {
             samples_per_block = nb_samples / 16;
             blocks = 1;
         }
 
         for (m = 0; m < blocks; m++) {
         for (channel = 0; channel < avctx->channels; channel++) {
             int prev1 = c->status[channel].sample1;
             int prev2 = c->status[channel].sample2;
 
             samples = samples_p[channel] + m * 16;
             /* Read in every sample for this channel.  */
             for (i = 0; i < samples_per_block; i++) {
                 int byte = bytestream2_get_byteu(&gb);
                 int scale = 1 << (byte >> 4);
                 int index = byte & 0xf;
                 int factor1 = ff_adpcm_afc_coeffs[0][index];
                 int factor2 = ff_adpcm_afc_coeffs[1][index];
 
                 /* Decode 16 samples.  */
                 for (n = 0; n < 16; n++) {
                     int32_t sampledat;
 
                     if (n & 1) {
                         sampledat = sign_extend(byte, 4);
                     } else {
                         byte = bytestream2_get_byteu(&gb);
                         sampledat = sign_extend(byte >> 4, 4);
                     }
 
                     sampledat = ((prev1 * factor1 + prev2 * factor2) +
                                  ((sampledat * scale) << 11)) >> 11;
                     *samples = av_clip_int16(sampledat);
                     prev2 = prev1;
                     prev1 = *samples++;
                 }
             }
 
             c->status[channel].sample1 = prev1;
             c->status[channel].sample2 = prev2;
         }
         }
         bytestream2_seek(&gb, 0, SEEK_END);
         break;
     }
     case AV_CODEC_ID_ADPCM_THP:
     case AV_CODEC_ID_ADPCM_THP_LE:
     {
         int table[14][16];
         int ch;
 
 #define THP_GET16(g) \
     sign_extend( \
         avctx->codec->id == AV_CODEC_ID_ADPCM_THP_LE ? \
         bytestream2_get_le16u(&(g)) : \
         bytestream2_get_be16u(&(g)), 16)
 
         if (avctx->extradata) {
             GetByteContext tb;
             if (avctx->extradata_size < 32 * avctx->channels) {
                 av_log(avctx, AV_LOG_ERROR, "Missing coeff table\n");
                 return AVERROR_INVALIDDATA;
             }
 
             bytestream2_init(&tb, avctx->extradata, avctx->extradata_size);
             for (i = 0; i < avctx->channels; i++)
                 for (n = 0; n < 16; n++)
                     table[i][n] = THP_GET16(tb);
         } else {
             for (i = 0; i < avctx->channels; i++)
                 for (n = 0; n < 16; n++)
                     table[i][n] = THP_GET16(gb);
 
             if (!c->has_status) {
                 /* Initialize the previous sample.  */
                 for (i = 0; i < avctx->channels; i++) {
                     c->status[i].sample1 = THP_GET16(gb);
                     c->status[i].sample2 = THP_GET16(gb);
                 }
                 c->has_status = 1;
             } else {
                 bytestream2_skip(&gb, avctx->channels * 4);
             }
         }
 
         for (ch = 0; ch < avctx->channels; ch++) {
             samples = samples_p[ch];
 
             /* Read in every sample for this channel.  */
             for (i = 0; i < (nb_samples + 13) / 14; i++) {
                 int byte = bytestream2_get_byteu(&gb);
                 int index = (byte >> 4) & 7;
                 unsigned int exp = byte & 0x0F;
                 int factor1 = table[ch][index * 2];
                 int factor2 = table[ch][index * 2 + 1];
 
                 /* Decode 14 samples.  */
                 for (n = 0; n < 14 && (i * 14 + n < nb_samples); n++) {
                     int32_t sampledat;
 
                     if (n & 1) {
                         sampledat = sign_extend(byte, 4);
                     } else {
                         byte = bytestream2_get_byteu(&gb);
                         sampledat = sign_extend(byte >> 4, 4);
                     }
 
                     sampledat = ((c->status[ch].sample1 * factor1
                                 + c->status[ch].sample2 * factor2) >> 11) + (sampledat << exp);
                     *samples = av_clip_int16(sampledat);
                     c->status[ch].sample2 = c->status[ch].sample1;
                     c->status[ch].sample1 = *samples++;
                 }
             }
         }
         break;
     }
     case AV_CODEC_ID_ADPCM_DTK:
         for (channel = 0; channel < avctx->channels; channel++) {
             samples = samples_p[channel];
 
             /* Read in every sample for this channel.  */
             for (i = 0; i < nb_samples / 28; i++) {
                 int byte, header;
                 if (channel)
                     bytestream2_skipu(&gb, 1);
                 header = bytestream2_get_byteu(&gb);
                 bytestream2_skipu(&gb, 3 - channel);
 
                 /* Decode 28 samples.  */
                 for (n = 0; n < 28; n++) {
                     int32_t sampledat, prev;
 
                     switch (header >> 4) {
                     case 1:
                         prev = (c->status[channel].sample1 * 0x3c);
                         break;
                     case 2:
                         prev = (c->status[channel].sample1 * 0x73) - (c->status[channel].sample2 * 0x34);
                         break;
                     case 3:
                         prev = (c->status[channel].sample1 * 0x62) - (c->status[channel].sample2 * 0x37);
                         break;
                     default:
                         prev = 0;
                     }
 
                     prev = av_clip_intp2((prev + 0x20) >> 6, 21);
 
                     byte = bytestream2_get_byteu(&gb);
                     if (!channel)
                         sampledat = sign_extend(byte, 4);
                     else
                         sampledat = sign_extend(byte >> 4, 4);
 
                     sampledat = (((sampledat << 12) >> (header & 0xf)) << 6) + prev;
                     *samples++ = av_clip_int16(sampledat >> 6);
                     c->status[channel].sample2 = c->status[channel].sample1;
                     c->status[channel].sample1 = sampledat;
                 }
             }
             if (!channel)
                 bytestream2_seek(&gb, 0, SEEK_SET);
         }
         break;
     case AV_CODEC_ID_ADPCM_PSX:
         for (channel = 0; channel < avctx->channels; channel++) {
             samples = samples_p[channel];
 
             /* Read in every sample for this channel.  */
             for (i = 0; i < nb_samples / 28; i++) {
                 int filter, shift, flag, byte;
 
                 filter = bytestream2_get_byteu(&gb);
                 shift  = filter & 0xf;
                 filter = filter >> 4;
                 if (filter >= FF_ARRAY_ELEMS(xa_adpcm_table))
                     return AVERROR_INVALIDDATA;
                 flag   = bytestream2_get_byteu(&gb);
 
                 /* Decode 28 samples.  */
                 for (n = 0; n < 28; n++) {
                     int sample = 0, scale;
 
                     if (flag < 0x07) {
                         if (n & 1) {
                             scale = sign_extend(byte >> 4, 4);
                         } else {
                             byte  = bytestream2_get_byteu(&gb);
                             scale = sign_extend(byte, 4);
                         }
 
                         scale  = scale << 12;
                         sample = (int)((scale >> shift) + (c->status[channel].sample1 * xa_adpcm_table[filter][0] + c->status[channel].sample2 * xa_adpcm_table[filter][1]) / 64);
                     }
                     *samples++ = av_clip_int16(sample);
                     c->status[channel].sample2 = c->status[channel].sample1;
                     c->status[channel].sample1 = sample;
                 }
             }
         }
         break;
 
     default:
         av_assert0(0); // unsupported codec_id should not happen
     }
 
     if (avpkt->size && bytestream2_tell(&gb) == 0) {
         av_log(avctx, AV_LOG_ERROR, "Nothing consumed\n");
         return AVERROR_INVALIDDATA;
     }
 
     *got_frame_ptr = 1;
 
     if (avpkt->size < bytestream2_tell(&gb)) {
         av_log(avctx, AV_LOG_ERROR, "Overread of %d < %d\n", avpkt->size, bytestream2_tell(&gb));
         return avpkt->size;
     }
 
     return bytestream2_tell(&gb);
 }
@@ -1729,6 +1786,7 @@ AVCodec ff_ ## name_ ## _decoder = {                        \
 /* Note: Do not forget to add new entries to the Makefile as well. */
 ADPCM_DECODER(AV_CODEC_ID_ADPCM_4XM,         sample_fmts_s16p, adpcm_4xm,         "ADPCM 4X Movie");
 ADPCM_DECODER(AV_CODEC_ID_ADPCM_AFC,         sample_fmts_s16p, adpcm_afc,         "ADPCM Nintendo Gamecube AFC");
+ADPCM_DECODER(AV_CODEC_ID_ADPCM_AGM,         sample_fmts_s16,  adpcm_agm,         "ADPCM AmuseGraphics Movie");
 ADPCM_DECODER(AV_CODEC_ID_ADPCM_AICA,        sample_fmts_s16p, adpcm_aica,        "ADPCM Yamaha AICA");
 ADPCM_DECODER(AV_CODEC_ID_ADPCM_CT,          sample_fmts_s16,  adpcm_ct,          "ADPCM Creative Technology");
 ADPCM_DECODER(AV_CODEC_ID_ADPCM_DTK,         sample_fmts_s16p, adpcm_dtk,         "ADPCM Nintendo Gamecube DTK");
diff --git a/libavcodec/allcodecs.c b/libavcodec/allcodecs.c
index 71fd74a07e..9ae8a779b3 100644
--- a/libavcodec/allcodecs.c
+++ b/libavcodec/allcodecs.c
@@ -574,6 +574,7 @@ extern AVCodec ff_adpcm_4xm_decoder;
 extern AVCodec ff_adpcm_adx_encoder;
 extern AVCodec ff_adpcm_adx_decoder;
 extern AVCodec ff_adpcm_afc_decoder;
+extern AVCodec ff_adpcm_agm_decoder;
 extern AVCodec ff_adpcm_aica_decoder;
 extern AVCodec ff_adpcm_ct_decoder;
 extern AVCodec ff_adpcm_dtk_decoder;
diff --git a/libavcodec/avcodec.h b/libavcodec/avcodec.h
index cafc65fce5..4218cff6c4 100644
--- a/libavcodec/avcodec.h
+++ b/libavcodec/avcodec.h
@@ -200,513 +200,514 @@
 /**
  * Identify the syntax and semantics of the bitstream.
  * The principle is roughly:
  * Two decoders with the same ID can decode the same streams.
  * Two encoders with the same ID can encode compatible streams.
  * There may be slight deviations from the principle due to implementation
  * details.
  *
  * If you add a codec ID to this list, add it so that
  * 1. no value of an existing codec ID changes (that would break ABI),
  * 2. it is as close as possible to similar codecs
  *
  * After adding new codec IDs, do not forget to add an entry to the codec
  * descriptor list and bump libavcodec minor version.
  */
 enum AVCodecID {
     AV_CODEC_ID_NONE,
 
     /* video codecs */
     AV_CODEC_ID_MPEG1VIDEO,
     AV_CODEC_ID_MPEG2VIDEO, ///< preferred ID for MPEG-1/2 video decoding
     AV_CODEC_ID_H261,
     AV_CODEC_ID_H263,
     AV_CODEC_ID_RV10,
     AV_CODEC_ID_RV20,
     AV_CODEC_ID_MJPEG,
     AV_CODEC_ID_MJPEGB,
     AV_CODEC_ID_LJPEG,
     AV_CODEC_ID_SP5X,
     AV_CODEC_ID_JPEGLS,
     AV_CODEC_ID_MPEG4,
     AV_CODEC_ID_RAWVIDEO,
     AV_CODEC_ID_MSMPEG4V1,
     AV_CODEC_ID_MSMPEG4V2,
     AV_CODEC_ID_MSMPEG4V3,
     AV_CODEC_ID_WMV1,
     AV_CODEC_ID_WMV2,
     AV_CODEC_ID_H263P,
     AV_CODEC_ID_H263I,
     AV_CODEC_ID_FLV1,
     AV_CODEC_ID_SVQ1,
     AV_CODEC_ID_SVQ3,
     AV_CODEC_ID_DVVIDEO,
     AV_CODEC_ID_HUFFYUV,
     AV_CODEC_ID_CYUV,
     AV_CODEC_ID_H264,
     AV_CODEC_ID_INDEO3,
     AV_CODEC_ID_VP3,
     AV_CODEC_ID_THEORA,
     AV_CODEC_ID_ASV1,
     AV_CODEC_ID_ASV2,
     AV_CODEC_ID_FFV1,
     AV_CODEC_ID_4XM,
     AV_CODEC_ID_VCR1,
     AV_CODEC_ID_CLJR,
     AV_CODEC_ID_MDEC,
     AV_CODEC_ID_ROQ,
     AV_CODEC_ID_INTERPLAY_VIDEO,
     AV_CODEC_ID_XAN_WC3,
     AV_CODEC_ID_XAN_WC4,
     AV_CODEC_ID_RPZA,
     AV_CODEC_ID_CINEPAK,
     AV_CODEC_ID_WS_VQA,
     AV_CODEC_ID_MSRLE,
     AV_CODEC_ID_MSVIDEO1,
     AV_CODEC_ID_IDCIN,
     AV_CODEC_ID_8BPS,
     AV_CODEC_ID_SMC,
     AV_CODEC_ID_FLIC,
     AV_CODEC_ID_TRUEMOTION1,
     AV_CODEC_ID_VMDVIDEO,
     AV_CODEC_ID_MSZH,
     AV_CODEC_ID_ZLIB,
     AV_CODEC_ID_QTRLE,
     AV_CODEC_ID_TSCC,
     AV_CODEC_ID_ULTI,
     AV_CODEC_ID_QDRAW,
     AV_CODEC_ID_VIXL,
     AV_CODEC_ID_QPEG,
     AV_CODEC_ID_PNG,
     AV_CODEC_ID_PPM,
     AV_CODEC_ID_PBM,
     AV_CODEC_ID_PGM,
     AV_CODEC_ID_PGMYUV,
     AV_CODEC_ID_PAM,
     AV_CODEC_ID_FFVHUFF,
     AV_CODEC_ID_RV30,
     AV_CODEC_ID_RV40,
     AV_CODEC_ID_VC1,
     AV_CODEC_ID_WMV3,
     AV_CODEC_ID_LOCO,
     AV_CODEC_ID_WNV1,
     AV_CODEC_ID_AASC,
     AV_CODEC_ID_INDEO2,
     AV_CODEC_ID_FRAPS,
     AV_CODEC_ID_TRUEMOTION2,
     AV_CODEC_ID_BMP,
     AV_CODEC_ID_CSCD,
     AV_CODEC_ID_MMVIDEO,
     AV_CODEC_ID_ZMBV,
     AV_CODEC_ID_AVS,
     AV_CODEC_ID_SMACKVIDEO,
     AV_CODEC_ID_NUV,
     AV_CODEC_ID_KMVC,
     AV_CODEC_ID_FLASHSV,
     AV_CODEC_ID_CAVS,
     AV_CODEC_ID_JPEG2000,
     AV_CODEC_ID_VMNC,
     AV_CODEC_ID_VP5,
     AV_CODEC_ID_VP6,
     AV_CODEC_ID_VP6F,
     AV_CODEC_ID_TARGA,
     AV_CODEC_ID_DSICINVIDEO,
     AV_CODEC_ID_TIERTEXSEQVIDEO,
     AV_CODEC_ID_TIFF,
     AV_CODEC_ID_GIF,
     AV_CODEC_ID_DXA,
     AV_CODEC_ID_DNXHD,
     AV_CODEC_ID_THP,
     AV_CODEC_ID_SGI,
     AV_CODEC_ID_C93,
     AV_CODEC_ID_BETHSOFTVID,
     AV_CODEC_ID_PTX,
     AV_CODEC_ID_TXD,
     AV_CODEC_ID_VP6A,
     AV_CODEC_ID_AMV,
     AV_CODEC_ID_VB,
     AV_CODEC_ID_PCX,
     AV_CODEC_ID_SUNRAST,
     AV_CODEC_ID_INDEO4,
     AV_CODEC_ID_INDEO5,
     AV_CODEC_ID_MIMIC,
     AV_CODEC_ID_RL2,
     AV_CODEC_ID_ESCAPE124,
     AV_CODEC_ID_DIRAC,
     AV_CODEC_ID_BFI,
     AV_CODEC_ID_CMV,
     AV_CODEC_ID_MOTIONPIXELS,
     AV_CODEC_ID_TGV,
     AV_CODEC_ID_TGQ,
     AV_CODEC_ID_TQI,
     AV_CODEC_ID_AURA,
     AV_CODEC_ID_AURA2,
     AV_CODEC_ID_V210X,
     AV_CODEC_ID_TMV,
     AV_CODEC_ID_V210,
     AV_CODEC_ID_DPX,
     AV_CODEC_ID_MAD,
     AV_CODEC_ID_FRWU,
     AV_CODEC_ID_FLASHSV2,
     AV_CODEC_ID_CDGRAPHICS,
     AV_CODEC_ID_R210,
     AV_CODEC_ID_ANM,
     AV_CODEC_ID_BINKVIDEO,
     AV_CODEC_ID_IFF_ILBM,
 #define AV_CODEC_ID_IFF_BYTERUN1 AV_CODEC_ID_IFF_ILBM
     AV_CODEC_ID_KGV1,
     AV_CODEC_ID_YOP,
     AV_CODEC_ID_VP8,
     AV_CODEC_ID_PICTOR,
     AV_CODEC_ID_ANSI,
     AV_CODEC_ID_A64_MULTI,
     AV_CODEC_ID_A64_MULTI5,
     AV_CODEC_ID_R10K,
     AV_CODEC_ID_MXPEG,
     AV_CODEC_ID_LAGARITH,
     AV_CODEC_ID_PRORES,
     AV_CODEC_ID_JV,
     AV_CODEC_ID_DFA,
     AV_CODEC_ID_WMV3IMAGE,
     AV_CODEC_ID_VC1IMAGE,
     AV_CODEC_ID_UTVIDEO,
     AV_CODEC_ID_BMV_VIDEO,
     AV_CODEC_ID_VBLE,
     AV_CODEC_ID_DXTORY,
     AV_CODEC_ID_V410,
     AV_CODEC_ID_XWD,
     AV_CODEC_ID_CDXL,
     AV_CODEC_ID_XBM,
     AV_CODEC_ID_ZEROCODEC,
     AV_CODEC_ID_MSS1,
     AV_CODEC_ID_MSA1,
     AV_CODEC_ID_TSCC2,
     AV_CODEC_ID_MTS2,
     AV_CODEC_ID_CLLC,
     AV_CODEC_ID_MSS2,
     AV_CODEC_ID_VP9,
     AV_CODEC_ID_AIC,
     AV_CODEC_ID_ESCAPE130,
     AV_CODEC_ID_G2M,
     AV_CODEC_ID_WEBP,
     AV_CODEC_ID_HNM4_VIDEO,
     AV_CODEC_ID_HEVC,
 #define AV_CODEC_ID_H265 AV_CODEC_ID_HEVC
     AV_CODEC_ID_FIC,
     AV_CODEC_ID_ALIAS_PIX,
     AV_CODEC_ID_BRENDER_PIX,
     AV_CODEC_ID_PAF_VIDEO,
     AV_CODEC_ID_EXR,
     AV_CODEC_ID_VP7,
     AV_CODEC_ID_SANM,
     AV_CODEC_ID_SGIRLE,
     AV_CODEC_ID_MVC1,
     AV_CODEC_ID_MVC2,
     AV_CODEC_ID_HQX,
     AV_CODEC_ID_TDSC,
     AV_CODEC_ID_HQ_HQA,
     AV_CODEC_ID_HAP,
     AV_CODEC_ID_DDS,
     AV_CODEC_ID_DXV,
     AV_CODEC_ID_SCREENPRESSO,
     AV_CODEC_ID_RSCC,
     AV_CODEC_ID_AVS2,
 
     AV_CODEC_ID_Y41P = 0x8000,
     AV_CODEC_ID_AVRP,
     AV_CODEC_ID_012V,
     AV_CODEC_ID_AVUI,
     AV_CODEC_ID_AYUV,
     AV_CODEC_ID_TARGA_Y216,
     AV_CODEC_ID_V308,
     AV_CODEC_ID_V408,
     AV_CODEC_ID_YUV4,
     AV_CODEC_ID_AVRN,
     AV_CODEC_ID_CPIA,
     AV_CODEC_ID_XFACE,
     AV_CODEC_ID_SNOW,
     AV_CODEC_ID_SMVJPEG,
     AV_CODEC_ID_APNG,
     AV_CODEC_ID_DAALA,
     AV_CODEC_ID_CFHD,
     AV_CODEC_ID_TRUEMOTION2RT,
     AV_CODEC_ID_M101,
     AV_CODEC_ID_MAGICYUV,
     AV_CODEC_ID_SHEERVIDEO,
     AV_CODEC_ID_YLC,
     AV_CODEC_ID_PSD,
     AV_CODEC_ID_PIXLET,
     AV_CODEC_ID_SPEEDHQ,
     AV_CODEC_ID_FMVC,
     AV_CODEC_ID_SCPR,
     AV_CODEC_ID_CLEARVIDEO,
     AV_CODEC_ID_XPM,
     AV_CODEC_ID_AV1,
     AV_CODEC_ID_BITPACKED,
     AV_CODEC_ID_MSCC,
     AV_CODEC_ID_SRGC,
     AV_CODEC_ID_SVG,
     AV_CODEC_ID_GDV,
     AV_CODEC_ID_FITS,
     AV_CODEC_ID_IMM4,
     AV_CODEC_ID_PROSUMER,
     AV_CODEC_ID_MWSC,
     AV_CODEC_ID_WCMV,
     AV_CODEC_ID_RASC,
     AV_CODEC_ID_HYMT,
     AV_CODEC_ID_ARBC,
     AV_CODEC_ID_AGM,
 
     /* various PCM "codecs" */
     AV_CODEC_ID_FIRST_AUDIO = 0x10000,     ///< A dummy id pointing at the start of audio codecs
     AV_CODEC_ID_PCM_S16LE = 0x10000,
     AV_CODEC_ID_PCM_S16BE,
     AV_CODEC_ID_PCM_U16LE,
     AV_CODEC_ID_PCM_U16BE,
     AV_CODEC_ID_PCM_S8,
     AV_CODEC_ID_PCM_U8,
     AV_CODEC_ID_PCM_MULAW,
     AV_CODEC_ID_PCM_ALAW,
     AV_CODEC_ID_PCM_S32LE,
     AV_CODEC_ID_PCM_S32BE,
     AV_CODEC_ID_PCM_U32LE,
     AV_CODEC_ID_PCM_U32BE,
     AV_CODEC_ID_PCM_S24LE,
     AV_CODEC_ID_PCM_S24BE,
     AV_CODEC_ID_PCM_U24LE,
     AV_CODEC_ID_PCM_U24BE,
     AV_CODEC_ID_PCM_S24DAUD,
     AV_CODEC_ID_PCM_ZORK,
     AV_CODEC_ID_PCM_S16LE_PLANAR,
     AV_CODEC_ID_PCM_DVD,
     AV_CODEC_ID_PCM_F32BE,
     AV_CODEC_ID_PCM_F32LE,
     AV_CODEC_ID_PCM_F64BE,
     AV_CODEC_ID_PCM_F64LE,
     AV_CODEC_ID_PCM_BLURAY,
     AV_CODEC_ID_PCM_LXF,
     AV_CODEC_ID_S302M,
     AV_CODEC_ID_PCM_S8_PLANAR,
     AV_CODEC_ID_PCM_S24LE_PLANAR,
     AV_CODEC_ID_PCM_S32LE_PLANAR,
     AV_CODEC_ID_PCM_S16BE_PLANAR,
 
     AV_CODEC_ID_PCM_S64LE = 0x10800,
     AV_CODEC_ID_PCM_S64BE,
     AV_CODEC_ID_PCM_F16LE,
     AV_CODEC_ID_PCM_F24LE,
     AV_CODEC_ID_PCM_VIDC,
 
     /* various ADPCM codecs */
     AV_CODEC_ID_ADPCM_IMA_QT = 0x11000,
     AV_CODEC_ID_ADPCM_IMA_WAV,
     AV_CODEC_ID_ADPCM_IMA_DK3,
     AV_CODEC_ID_ADPCM_IMA_DK4,
     AV_CODEC_ID_ADPCM_IMA_WS,
     AV_CODEC_ID_ADPCM_IMA_SMJPEG,
     AV_CODEC_ID_ADPCM_MS,
     AV_CODEC_ID_ADPCM_4XM,
     AV_CODEC_ID_ADPCM_XA,
     AV_CODEC_ID_ADPCM_ADX,
     AV_CODEC_ID_ADPCM_EA,
     AV_CODEC_ID_ADPCM_G726,
     AV_CODEC_ID_ADPCM_CT,
     AV_CODEC_ID_ADPCM_SWF,
     AV_CODEC_ID_ADPCM_YAMAHA,
     AV_CODEC_ID_ADPCM_SBPRO_4,
     AV_CODEC_ID_ADPCM_SBPRO_3,
     AV_CODEC_ID_ADPCM_SBPRO_2,
     AV_CODEC_ID_ADPCM_THP,
     AV_CODEC_ID_ADPCM_IMA_AMV,
     AV_CODEC_ID_ADPCM_EA_R1,
     AV_CODEC_ID_ADPCM_EA_R3,
     AV_CODEC_ID_ADPCM_EA_R2,
     AV_CODEC_ID_ADPCM_IMA_EA_SEAD,
     AV_CODEC_ID_ADPCM_IMA_EA_EACS,
     AV_CODEC_ID_ADPCM_EA_XAS,
     AV_CODEC_ID_ADPCM_EA_MAXIS_XA,
     AV_CODEC_ID_ADPCM_IMA_ISS,
     AV_CODEC_ID_ADPCM_G722,
     AV_CODEC_ID_ADPCM_IMA_APC,
     AV_CODEC_ID_ADPCM_VIMA,
 
     AV_CODEC_ID_ADPCM_AFC = 0x11800,
     AV_CODEC_ID_ADPCM_IMA_OKI,
     AV_CODEC_ID_ADPCM_DTK,
     AV_CODEC_ID_ADPCM_IMA_RAD,
     AV_CODEC_ID_ADPCM_G726LE,
     AV_CODEC_ID_ADPCM_THP_LE,
     AV_CODEC_ID_ADPCM_PSX,
     AV_CODEC_ID_ADPCM_AICA,
     AV_CODEC_ID_ADPCM_IMA_DAT4,
     AV_CODEC_ID_ADPCM_MTAF,
+    AV_CODEC_ID_ADPCM_AGM,
 
     /* AMR */
     AV_CODEC_ID_AMR_NB = 0x12000,
     AV_CODEC_ID_AMR_WB,
 
     /* RealAudio codecs*/
     AV_CODEC_ID_RA_144 = 0x13000,
     AV_CODEC_ID_RA_288,
 
     /* various DPCM codecs */
     AV_CODEC_ID_ROQ_DPCM = 0x14000,
     AV_CODEC_ID_INTERPLAY_DPCM,
     AV_CODEC_ID_XAN_DPCM,
     AV_CODEC_ID_SOL_DPCM,
 
     AV_CODEC_ID_SDX2_DPCM = 0x14800,
     AV_CODEC_ID_GREMLIN_DPCM,
 
     /* audio codecs */
     AV_CODEC_ID_MP2 = 0x15000,
     AV_CODEC_ID_MP3, ///< preferred ID for decoding MPEG audio layer 1, 2 or 3
     AV_CODEC_ID_AAC,
     AV_CODEC_ID_AC3,
     AV_CODEC_ID_DTS,
     AV_CODEC_ID_VORBIS,
     AV_CODEC_ID_DVAUDIO,
     AV_CODEC_ID_WMAV1,
     AV_CODEC_ID_WMAV2,
     AV_CODEC_ID_MACE3,
     AV_CODEC_ID_MACE6,
     AV_CODEC_ID_VMDAUDIO,
     AV_CODEC_ID_FLAC,
     AV_CODEC_ID_MP3ADU,
     AV_CODEC_ID_MP3ON4,
     AV_CODEC_ID_SHORTEN,
     AV_CODEC_ID_ALAC,
     AV_CODEC_ID_WESTWOOD_SND1,
     AV_CODEC_ID_GSM, ///< as in Berlin toast format
     AV_CODEC_ID_QDM2,
     AV_CODEC_ID_COOK,
     AV_CODEC_ID_TRUESPEECH,
     AV_CODEC_ID_TTA,
     AV_CODEC_ID_SMACKAUDIO,
     AV_CODEC_ID_QCELP,
     AV_CODEC_ID_WAVPACK,
     AV_CODEC_ID_DSICINAUDIO,
     AV_CODEC_ID_IMC,
     AV_CODEC_ID_MUSEPACK7,
     AV_CODEC_ID_MLP,
     AV_CODEC_ID_GSM_MS, /* as found in WAV */
     AV_CODEC_ID_ATRAC3,
     AV_CODEC_ID_APE,
     AV_CODEC_ID_NELLYMOSER,
     AV_CODEC_ID_MUSEPACK8,
     AV_CODEC_ID_SPEEX,
     AV_CODEC_ID_WMAVOICE,
     AV_CODEC_ID_WMAPRO,
     AV_CODEC_ID_WMALOSSLESS,
     AV_CODEC_ID_ATRAC3P,
     AV_CODEC_ID_EAC3,
     AV_CODEC_ID_SIPR,
     AV_CODEC_ID_MP1,
     AV_CODEC_ID_TWINVQ,
     AV_CODEC_ID_TRUEHD,
     AV_CODEC_ID_MP4ALS,
     AV_CODEC_ID_ATRAC1,
     AV_CODEC_ID_BINKAUDIO_RDFT,
     AV_CODEC_ID_BINKAUDIO_DCT,
     AV_CODEC_ID_AAC_LATM,
     AV_CODEC_ID_QDMC,
     AV_CODEC_ID_CELT,
     AV_CODEC_ID_G723_1,
     AV_CODEC_ID_G729,
     AV_CODEC_ID_8SVX_EXP,
     AV_CODEC_ID_8SVX_FIB,
     AV_CODEC_ID_BMV_AUDIO,
     AV_CODEC_ID_RALF,
     AV_CODEC_ID_IAC,
     AV_CODEC_ID_ILBC,
     AV_CODEC_ID_OPUS,
     AV_CODEC_ID_COMFORT_NOISE,
     AV_CODEC_ID_TAK,
     AV_CODEC_ID_METASOUND,
     AV_CODEC_ID_PAF_AUDIO,
     AV_CODEC_ID_ON2AVC,
     AV_CODEC_ID_DSS_SP,
     AV_CODEC_ID_CODEC2,
 
     AV_CODEC_ID_FFWAVESYNTH = 0x15800,
     AV_CODEC_ID_SONIC,
     AV_CODEC_ID_SONIC_LS,
     AV_CODEC_ID_EVRC,
     AV_CODEC_ID_SMV,
     AV_CODEC_ID_DSD_LSBF,
     AV_CODEC_ID_DSD_MSBF,
     AV_CODEC_ID_DSD_LSBF_PLANAR,
     AV_CODEC_ID_DSD_MSBF_PLANAR,
     AV_CODEC_ID_4GV,
     AV_CODEC_ID_INTERPLAY_ACM,
     AV_CODEC_ID_XMA1,
     AV_CODEC_ID_XMA2,
     AV_CODEC_ID_DST,
     AV_CODEC_ID_ATRAC3AL,
     AV_CODEC_ID_ATRAC3PAL,
     AV_CODEC_ID_DOLBY_E,
     AV_CODEC_ID_APTX,
     AV_CODEC_ID_APTX_HD,
     AV_CODEC_ID_SBC,
     AV_CODEC_ID_ATRAC9,
     AV_CODEC_ID_HCOM,
 
     /* subtitle codecs */
     AV_CODEC_ID_FIRST_SUBTITLE = 0x17000,          ///< A dummy ID pointing at the start of subtitle codecs.
     AV_CODEC_ID_DVD_SUBTITLE = 0x17000,
     AV_CODEC_ID_DVB_SUBTITLE,
     AV_CODEC_ID_TEXT,  ///< raw UTF-8 text
     AV_CODEC_ID_XSUB,
     AV_CODEC_ID_SSA,
     AV_CODEC_ID_MOV_TEXT,
     AV_CODEC_ID_HDMV_PGS_SUBTITLE,
     AV_CODEC_ID_DVB_TELETEXT,
     AV_CODEC_ID_SRT,
 
     AV_CODEC_ID_MICRODVD   = 0x17800,
     AV_CODEC_ID_EIA_608,
     AV_CODEC_ID_JACOSUB,
     AV_CODEC_ID_SAMI,
     AV_CODEC_ID_REALTEXT,
     AV_CODEC_ID_STL,
     AV_CODEC_ID_SUBVIEWER1,
     AV_CODEC_ID_SUBVIEWER,
     AV_CODEC_ID_SUBRIP,
     AV_CODEC_ID_WEBVTT,
     AV_CODEC_ID_MPL2,
     AV_CODEC_ID_VPLAYER,
     AV_CODEC_ID_PJS,
     AV_CODEC_ID_ASS,
     AV_CODEC_ID_HDMV_TEXT_SUBTITLE,
     AV_CODEC_ID_TTML,
     AV_CODEC_ID_ARIB_CAPTION,
 
     /* other specific kind of codecs (generally used for attachments) */
     AV_CODEC_ID_FIRST_UNKNOWN = 0x18000,           ///< A dummy ID pointing at the start of various fake codecs.
     AV_CODEC_ID_TTF = 0x18000,
 
     AV_CODEC_ID_SCTE_35, ///< Contain timestamp estimated through PCR of program stream.
     AV_CODEC_ID_BINTEXT    = 0x18800,
     AV_CODEC_ID_XBIN,
     AV_CODEC_ID_IDF,
     AV_CODEC_ID_OTF,
     AV_CODEC_ID_SMPTE_KLV,
     AV_CODEC_ID_DVD_NAV,
     AV_CODEC_ID_TIMED_ID3,
     AV_CODEC_ID_BIN_DATA,
 
 
     AV_CODEC_ID_PROBE = 0x19000, ///< codec_id is not known (like AV_CODEC_ID_NONE) but lavf should attempt to identify it
 
     AV_CODEC_ID_MPEG2TS = 0x20000, /**< _FAKE_ codec to indicate a raw MPEG-2 TS
                                 * stream (only used by libavformat) */
     AV_CODEC_ID_MPEG4SYSTEMS = 0x20001, /**< _FAKE_ codec to indicate a MPEG-4 Systems
                                 * stream (only used by libavformat) */
     AV_CODEC_ID_FFMETADATA = 0x21000,   ///< Dummy codec for streams containing only metadata information.
     AV_CODEC_ID_WRAPPED_AVFRAME = 0x21001, ///< Passthrough codec, AVFrames wrapped in AVPacket
 };
 
 /**
  * This struct describes the properties of a single codec described by an
  * AVCodecID.
  * @see avcodec_descriptor_get()
  */
diff --git a/libavcodec/codec_desc.c b/libavcodec/codec_desc.c
index 80c21a8c6c..8295221d15 100644
--- a/libavcodec/codec_desc.c
+++ b/libavcodec/codec_desc.c
@@ -32,3195 +32,3202 @@
 static const AVCodecDescriptor codec_descriptors[] = {
     /* video codecs */
     {
         .id        = AV_CODEC_ID_MPEG1VIDEO,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "mpeg1video",
         .long_name = NULL_IF_CONFIG_SMALL("MPEG-1 video"),
         .props     = AV_CODEC_PROP_LOSSY | AV_CODEC_PROP_REORDER,
     },
     {
         .id        = AV_CODEC_ID_MPEG2VIDEO,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "mpeg2video",
         .long_name = NULL_IF_CONFIG_SMALL("MPEG-2 video"),
         .props     = AV_CODEC_PROP_LOSSY | AV_CODEC_PROP_REORDER,
         .profiles  = NULL_IF_CONFIG_SMALL(ff_mpeg2_video_profiles),
     },
     {
         .id        = AV_CODEC_ID_H261,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "h261",
         .long_name = NULL_IF_CONFIG_SMALL("H.261"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_H263,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "h263",
         .long_name = NULL_IF_CONFIG_SMALL("H.263 / H.263-1996, H.263+ / H.263-1998 / H.263 version 2"),
         .props     = AV_CODEC_PROP_LOSSY | AV_CODEC_PROP_REORDER,
     },
     {
         .id        = AV_CODEC_ID_RV10,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "rv10",
         .long_name = NULL_IF_CONFIG_SMALL("RealVideo 1.0"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_RV20,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "rv20",
         .long_name = NULL_IF_CONFIG_SMALL("RealVideo 2.0"),
         .props     = AV_CODEC_PROP_LOSSY | AV_CODEC_PROP_REORDER,
     },
     {
         .id        = AV_CODEC_ID_MJPEG,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "mjpeg",
         .long_name = NULL_IF_CONFIG_SMALL("Motion JPEG"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
         .mime_types= MT("image/jpeg"),
         .profiles  = NULL_IF_CONFIG_SMALL(ff_mjpeg_profiles),
     },
     {
         .id        = AV_CODEC_ID_MJPEGB,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "mjpegb",
         .long_name = NULL_IF_CONFIG_SMALL("Apple MJPEG-B"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_LJPEG,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "ljpeg",
         .long_name = NULL_IF_CONFIG_SMALL("Lossless JPEG"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_SP5X,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "sp5x",
         .long_name = NULL_IF_CONFIG_SMALL("Sunplus JPEG (SP5X)"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_JPEGLS,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "jpegls",
         .long_name = NULL_IF_CONFIG_SMALL("JPEG-LS"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY |
                      AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_MPEG4,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "mpeg4",
         .long_name = NULL_IF_CONFIG_SMALL("MPEG-4 part 2"),
         .props     = AV_CODEC_PROP_LOSSY | AV_CODEC_PROP_REORDER,
         .profiles  = NULL_IF_CONFIG_SMALL(ff_mpeg4_video_profiles),
     },
     {
         .id        = AV_CODEC_ID_RAWVIDEO,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "rawvideo",
         .long_name = NULL_IF_CONFIG_SMALL("raw video"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_MSMPEG4V1,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "msmpeg4v1",
         .long_name = NULL_IF_CONFIG_SMALL("MPEG-4 part 2 Microsoft variant version 1"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_MSMPEG4V2,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "msmpeg4v2",
         .long_name = NULL_IF_CONFIG_SMALL("MPEG-4 part 2 Microsoft variant version 2"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_MSMPEG4V3,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "msmpeg4v3",
         .long_name = NULL_IF_CONFIG_SMALL("MPEG-4 part 2 Microsoft variant version 3"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_WMV1,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "wmv1",
         .long_name = NULL_IF_CONFIG_SMALL("Windows Media Video 7"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_WMV2,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "wmv2",
         .long_name = NULL_IF_CONFIG_SMALL("Windows Media Video 8"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_H263P,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "h263p",
         .long_name = NULL_IF_CONFIG_SMALL("H.263+ / H.263-1998 / H.263 version 2"),
         .props     = AV_CODEC_PROP_LOSSY | AV_CODEC_PROP_REORDER,
     },
     {
         .id        = AV_CODEC_ID_H263I,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "h263i",
         .long_name = NULL_IF_CONFIG_SMALL("Intel H.263"),
         .props     = AV_CODEC_PROP_LOSSY | AV_CODEC_PROP_REORDER,
     },
     {
         .id        = AV_CODEC_ID_FLV1,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "flv1",
         .long_name = NULL_IF_CONFIG_SMALL("FLV / Sorenson Spark / Sorenson H.263 (Flash Video)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_SVQ1,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "svq1",
         .long_name = NULL_IF_CONFIG_SMALL("Sorenson Vector Quantizer 1 / Sorenson Video 1 / SVQ1"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_SVQ3,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "svq3",
         .long_name = NULL_IF_CONFIG_SMALL("Sorenson Vector Quantizer 3 / Sorenson Video 3 / SVQ3"),
         .props     = AV_CODEC_PROP_LOSSY | AV_CODEC_PROP_REORDER,
     },
     {
         .id        = AV_CODEC_ID_DVVIDEO,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "dvvideo",
         .long_name = NULL_IF_CONFIG_SMALL("DV (Digital Video)"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_HUFFYUV,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "huffyuv",
         .long_name = NULL_IF_CONFIG_SMALL("HuffYUV"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_CYUV,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "cyuv",
         .long_name = NULL_IF_CONFIG_SMALL("Creative YUV (CYUV)"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_H264,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "h264",
         .long_name = NULL_IF_CONFIG_SMALL("H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10"),
         .props     = AV_CODEC_PROP_LOSSY | AV_CODEC_PROP_LOSSLESS | AV_CODEC_PROP_REORDER,
         .profiles  = NULL_IF_CONFIG_SMALL(ff_h264_profiles),
     },
     {
         .id        = AV_CODEC_ID_INDEO3,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "indeo3",
         .long_name = NULL_IF_CONFIG_SMALL("Intel Indeo 3"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_VP3,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "vp3",
         .long_name = NULL_IF_CONFIG_SMALL("On2 VP3"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_THEORA,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "theora",
         .long_name = NULL_IF_CONFIG_SMALL("Theora"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ASV1,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "asv1",
         .long_name = NULL_IF_CONFIG_SMALL("ASUS V1"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ASV2,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "asv2",
         .long_name = NULL_IF_CONFIG_SMALL("ASUS V2"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_FFV1,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "ffv1",
         .long_name = NULL_IF_CONFIG_SMALL("FFmpeg video codec #1"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_4XM,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "4xm",
         .long_name = NULL_IF_CONFIG_SMALL("4X Movie"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_VCR1,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "vcr1",
         .long_name = NULL_IF_CONFIG_SMALL("ATI VCR1"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_CLJR,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "cljr",
         .long_name = NULL_IF_CONFIG_SMALL("Cirrus Logic AccuPak"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_MDEC,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "mdec",
         .long_name = NULL_IF_CONFIG_SMALL("Sony PlayStation MDEC (Motion DECoder)"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ROQ,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "roq",
         .long_name = NULL_IF_CONFIG_SMALL("id RoQ video"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_INTERPLAY_VIDEO,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "interplayvideo",
         .long_name = NULL_IF_CONFIG_SMALL("Interplay MVE video"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_XAN_WC3,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "xan_wc3",
         .long_name = NULL_IF_CONFIG_SMALL("Wing Commander III / Xan"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_XAN_WC4,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "xan_wc4",
         .long_name = NULL_IF_CONFIG_SMALL("Wing Commander IV / Xxan"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_RPZA,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "rpza",
         .long_name = NULL_IF_CONFIG_SMALL("QuickTime video (RPZA)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_CINEPAK,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "cinepak",
         .long_name = NULL_IF_CONFIG_SMALL("Cinepak"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_WS_VQA,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "ws_vqa",
         .long_name = NULL_IF_CONFIG_SMALL("Westwood Studios VQA (Vector Quantized Animation) video"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_MSRLE,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "msrle",
         .long_name = NULL_IF_CONFIG_SMALL("Microsoft RLE"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_MSVIDEO1,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "msvideo1",
         .long_name = NULL_IF_CONFIG_SMALL("Microsoft Video 1"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_IDCIN,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "idcin",
         .long_name = NULL_IF_CONFIG_SMALL("id Quake II CIN video"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_8BPS,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "8bps",
         .long_name = NULL_IF_CONFIG_SMALL("QuickTime 8BPS video"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_SMC,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "smc",
         .long_name = NULL_IF_CONFIG_SMALL("QuickTime Graphics (SMC)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_FLIC,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "flic",
         .long_name = NULL_IF_CONFIG_SMALL("Autodesk Animator Flic video"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_TRUEMOTION1,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "truemotion1",
         .long_name = NULL_IF_CONFIG_SMALL("Duck TrueMotion 1.0"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_VMDVIDEO,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "vmdvideo",
         .long_name = NULL_IF_CONFIG_SMALL("Sierra VMD video"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_MSZH,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "mszh",
         .long_name = NULL_IF_CONFIG_SMALL("LCL (LossLess Codec Library) MSZH"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_ZLIB,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "zlib",
         .long_name = NULL_IF_CONFIG_SMALL("LCL (LossLess Codec Library) ZLIB"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_QTRLE,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "qtrle",
         .long_name = NULL_IF_CONFIG_SMALL("QuickTime Animation (RLE) video"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_TSCC,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "tscc",
         .long_name = NULL_IF_CONFIG_SMALL("TechSmith Screen Capture Codec"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_ULTI,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "ulti",
         .long_name = NULL_IF_CONFIG_SMALL("IBM UltiMotion"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_QDRAW,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "qdraw",
         .long_name = NULL_IF_CONFIG_SMALL("Apple QuickDraw"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_VIXL,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "vixl",
         .long_name = NULL_IF_CONFIG_SMALL("Miro VideoXL"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_QPEG,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "qpeg",
         .long_name = NULL_IF_CONFIG_SMALL("Q-team QPEG"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_PNG,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "png",
         .long_name = NULL_IF_CONFIG_SMALL("PNG (Portable Network Graphics) image"),
         .props     = AV_CODEC_PROP_LOSSLESS,
         .mime_types= MT("image/png"),
     },
     {
         .id        = AV_CODEC_ID_PPM,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "ppm",
         .long_name = NULL_IF_CONFIG_SMALL("PPM (Portable PixelMap) image"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PBM,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "pbm",
         .long_name = NULL_IF_CONFIG_SMALL("PBM (Portable BitMap) image"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PGM,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "pgm",
         .long_name = NULL_IF_CONFIG_SMALL("PGM (Portable GrayMap) image"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PGMYUV,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "pgmyuv",
         .long_name = NULL_IF_CONFIG_SMALL("PGMYUV (Portable GrayMap YUV) image"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PAM,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "pam",
         .long_name = NULL_IF_CONFIG_SMALL("PAM (Portable AnyMap) image"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
         .mime_types= MT("image/x-portable-pixmap"),
     },
     {
         .id        = AV_CODEC_ID_FFVHUFF,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "ffvhuff",
         .long_name = NULL_IF_CONFIG_SMALL("Huffyuv FFmpeg variant"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_RV30,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "rv30",
         .long_name = NULL_IF_CONFIG_SMALL("RealVideo 3.0"),
         .props     = AV_CODEC_PROP_LOSSY | AV_CODEC_PROP_REORDER,
     },
     {
         .id        = AV_CODEC_ID_RV40,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "rv40",
         .long_name = NULL_IF_CONFIG_SMALL("RealVideo 4.0"),
         .props     = AV_CODEC_PROP_LOSSY | AV_CODEC_PROP_REORDER,
     },
     {
         .id        = AV_CODEC_ID_VC1,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "vc1",
         .long_name = NULL_IF_CONFIG_SMALL("SMPTE VC-1"),
         .props     = AV_CODEC_PROP_LOSSY | AV_CODEC_PROP_REORDER,
         .profiles  = NULL_IF_CONFIG_SMALL(ff_vc1_profiles),
     },
     {
         .id        = AV_CODEC_ID_WMV3,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "wmv3",
         .long_name = NULL_IF_CONFIG_SMALL("Windows Media Video 9"),
         .props     = AV_CODEC_PROP_LOSSY | AV_CODEC_PROP_REORDER,
         .profiles  = NULL_IF_CONFIG_SMALL(ff_vc1_profiles),
     },
     {
         .id        = AV_CODEC_ID_LOCO,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "loco",
         .long_name = NULL_IF_CONFIG_SMALL("LOCO"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_WNV1,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "wnv1",
         .long_name = NULL_IF_CONFIG_SMALL("Winnov WNV1"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_AASC,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "aasc",
         .long_name = NULL_IF_CONFIG_SMALL("Autodesk RLE"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_INDEO2,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "indeo2",
         .long_name = NULL_IF_CONFIG_SMALL("Intel Indeo 2"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_FRAPS,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "fraps",
         .long_name = NULL_IF_CONFIG_SMALL("Fraps"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_TRUEMOTION2,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "truemotion2",
         .long_name = NULL_IF_CONFIG_SMALL("Duck TrueMotion 2.0"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_BMP,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "bmp",
         .long_name = NULL_IF_CONFIG_SMALL("BMP (Windows and OS/2 bitmap)"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
         .mime_types= MT("image/x-ms-bmp"),
     },
     {
         .id        = AV_CODEC_ID_CSCD,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "cscd",
         .long_name = NULL_IF_CONFIG_SMALL("CamStudio"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_MMVIDEO,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "mmvideo",
         .long_name = NULL_IF_CONFIG_SMALL("American Laser Games MM Video"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ZMBV,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "zmbv",
         .long_name = NULL_IF_CONFIG_SMALL("Zip Motion Blocks Video"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_AVS,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "avs",
         .long_name = NULL_IF_CONFIG_SMALL("AVS (Audio Video Standard) video"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_SMACKVIDEO,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "smackvideo",
         .long_name = NULL_IF_CONFIG_SMALL("Smacker video"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_NUV,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "nuv",
         .long_name = NULL_IF_CONFIG_SMALL("NuppelVideo/RTJPEG"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_KMVC,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "kmvc",
         .long_name = NULL_IF_CONFIG_SMALL("Karl Morton's video codec"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_FLASHSV,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "flashsv",
         .long_name = NULL_IF_CONFIG_SMALL("Flash Screen Video v1"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_CAVS,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "cavs",
         .long_name = NULL_IF_CONFIG_SMALL("Chinese AVS (Audio Video Standard) (AVS1-P2, JiZhun profile)"),
         .props     = AV_CODEC_PROP_LOSSY | AV_CODEC_PROP_REORDER,
     },
     {
         .id        = AV_CODEC_ID_JPEG2000,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "jpeg2000",
         .long_name = NULL_IF_CONFIG_SMALL("JPEG 2000"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY |
                      AV_CODEC_PROP_LOSSLESS,
         .mime_types= MT("image/jp2"),
         .profiles  = NULL_IF_CONFIG_SMALL(ff_jpeg2000_profiles),
     },
     {
         .id        = AV_CODEC_ID_VMNC,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "vmnc",
         .long_name = NULL_IF_CONFIG_SMALL("VMware Screen Codec / VMware Video"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_VP5,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "vp5",
         .long_name = NULL_IF_CONFIG_SMALL("On2 VP5"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_VP6,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "vp6",
         .long_name = NULL_IF_CONFIG_SMALL("On2 VP6"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_VP6F,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "vp6f",
         .long_name = NULL_IF_CONFIG_SMALL("On2 VP6 (Flash version)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_TARGA,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "targa",
         .long_name = NULL_IF_CONFIG_SMALL("Truevision Targa image"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
         .mime_types= MT("image/x-targa", "image/x-tga"),
     },
     {
         .id        = AV_CODEC_ID_DSICINVIDEO,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "dsicinvideo",
         .long_name = NULL_IF_CONFIG_SMALL("Delphine Software International CIN video"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_TIERTEXSEQVIDEO,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "tiertexseqvideo",
         .long_name = NULL_IF_CONFIG_SMALL("Tiertex Limited SEQ video"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_TIFF,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "tiff",
         .long_name = NULL_IF_CONFIG_SMALL("TIFF image"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
         .mime_types= MT("image/tiff"),
     },
     {
         .id        = AV_CODEC_ID_GIF,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "gif",
         .long_name = NULL_IF_CONFIG_SMALL("CompuServe GIF (Graphics Interchange Format)"),
         .props     = AV_CODEC_PROP_LOSSLESS,
         .mime_types= MT("image/gif"),
     },
     {
         .id        = AV_CODEC_ID_DXA,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "dxa",
         .long_name = NULL_IF_CONFIG_SMALL("Feeble Files/ScummVM DXA"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_DNXHD,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "dnxhd",
         .long_name = NULL_IF_CONFIG_SMALL("VC3/DNxHD"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
         .profiles  = NULL_IF_CONFIG_SMALL(ff_dnxhd_profiles),
     },
     {
         .id        = AV_CODEC_ID_THP,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "thp",
         .long_name = NULL_IF_CONFIG_SMALL("Nintendo Gamecube THP video"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_SGI,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "sgi",
         .long_name = NULL_IF_CONFIG_SMALL("SGI image"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_C93,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "c93",
         .long_name = NULL_IF_CONFIG_SMALL("Interplay C93"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_BETHSOFTVID,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "bethsoftvid",
         .long_name = NULL_IF_CONFIG_SMALL("Bethesda VID video"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_PTX,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "ptx",
         .long_name = NULL_IF_CONFIG_SMALL("V.Flash PTX image"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_TXD,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "txd",
         .long_name = NULL_IF_CONFIG_SMALL("Renderware TXD (TeXture Dictionary) image"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_VP6A,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "vp6a",
         .long_name = NULL_IF_CONFIG_SMALL("On2 VP6 (Flash version, with alpha channel)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_AMV,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "amv",
         .long_name = NULL_IF_CONFIG_SMALL("AMV Video"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_VB,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "vb",
         .long_name = NULL_IF_CONFIG_SMALL("Beam Software VB"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_PCX,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "pcx",
         .long_name = NULL_IF_CONFIG_SMALL("PC Paintbrush PCX image"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
         .mime_types= MT("image/x-pcx"),
     },
     {
         .id        = AV_CODEC_ID_SUNRAST,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "sunrast",
         .long_name = NULL_IF_CONFIG_SMALL("Sun Rasterfile image"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_INDEO4,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "indeo4",
         .long_name = NULL_IF_CONFIG_SMALL("Intel Indeo Video Interactive 4"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_INDEO5,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "indeo5",
         .long_name = NULL_IF_CONFIG_SMALL("Intel Indeo Video Interactive 5"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_MIMIC,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "mimic",
         .long_name = NULL_IF_CONFIG_SMALL("Mimic"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_RL2,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "rl2",
         .long_name = NULL_IF_CONFIG_SMALL("RL2 video"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ESCAPE124,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "escape124",
         .long_name = NULL_IF_CONFIG_SMALL("Escape 124"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_DIRAC,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "dirac",
         .long_name = NULL_IF_CONFIG_SMALL("Dirac"),
         .props     = AV_CODEC_PROP_LOSSY | AV_CODEC_PROP_LOSSLESS | AV_CODEC_PROP_REORDER,
     },
     {
         .id        = AV_CODEC_ID_BFI,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "bfi",
         .long_name = NULL_IF_CONFIG_SMALL("Brute Force & Ignorance"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_CMV,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "cmv",
         .long_name = NULL_IF_CONFIG_SMALL("Electronic Arts CMV video"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_MOTIONPIXELS,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "motionpixels",
         .long_name = NULL_IF_CONFIG_SMALL("Motion Pixels video"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_TGV,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "tgv",
         .long_name = NULL_IF_CONFIG_SMALL("Electronic Arts TGV video"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_TGQ,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "tgq",
         .long_name = NULL_IF_CONFIG_SMALL("Electronic Arts TGQ video"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_TQI,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "tqi",
         .long_name = NULL_IF_CONFIG_SMALL("Electronic Arts TQI video"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_AURA,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "aura",
         .long_name = NULL_IF_CONFIG_SMALL("Auravision AURA"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_AURA2,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "aura2",
         .long_name = NULL_IF_CONFIG_SMALL("Auravision Aura 2"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_V210X,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "v210x",
         .long_name = NULL_IF_CONFIG_SMALL("Uncompressed 4:2:2 10-bit"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_TMV,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "tmv",
         .long_name = NULL_IF_CONFIG_SMALL("8088flex TMV"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_V210,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "v210",
         .long_name = NULL_IF_CONFIG_SMALL("Uncompressed 4:2:2 10-bit"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_DPX,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "dpx",
         .long_name = NULL_IF_CONFIG_SMALL("DPX (Digital Picture Exchange) image"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_MAD,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "mad",
         .long_name = NULL_IF_CONFIG_SMALL("Electronic Arts Madcow Video"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_FRWU,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "frwu",
         .long_name = NULL_IF_CONFIG_SMALL("Forward Uncompressed"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_FLASHSV2,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "flashsv2",
         .long_name = NULL_IF_CONFIG_SMALL("Flash Screen Video v2"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_CDGRAPHICS,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "cdgraphics",
         .long_name = NULL_IF_CONFIG_SMALL("CD Graphics video"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_R210,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "r210",
         .long_name = NULL_IF_CONFIG_SMALL("Uncompressed RGB 10-bit"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_ANM,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "anm",
         .long_name = NULL_IF_CONFIG_SMALL("Deluxe Paint Animation"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_BINKVIDEO,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "binkvideo",
         .long_name = NULL_IF_CONFIG_SMALL("Bink video"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_IFF_ILBM,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "iff_ilbm",
         .long_name = NULL_IF_CONFIG_SMALL("IFF ACBM/ANIM/DEEP/ILBM/PBM/RGB8/RGBN"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_KGV1,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "kgv1",
         .long_name = NULL_IF_CONFIG_SMALL("Kega Game Video"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_YOP,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "yop",
         .long_name = NULL_IF_CONFIG_SMALL("Psygnosis YOP Video"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_VP8,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "vp8",
         .long_name = NULL_IF_CONFIG_SMALL("On2 VP8"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_PICTOR,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "pictor",
         .long_name = NULL_IF_CONFIG_SMALL("Pictor/PC Paint"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ANSI,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "ansi",
         .long_name = NULL_IF_CONFIG_SMALL("ASCII/ANSI art"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_A64_MULTI,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "a64_multi",
         .long_name = NULL_IF_CONFIG_SMALL("Multicolor charset for Commodore 64"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_A64_MULTI5,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "a64_multi5",
         .long_name = NULL_IF_CONFIG_SMALL("Multicolor charset for Commodore 64, extended with 5th color (colram)"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_R10K,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "r10k",
         .long_name = NULL_IF_CONFIG_SMALL("AJA Kona 10-bit RGB Codec"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_MXPEG,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "mxpeg",
         .long_name = NULL_IF_CONFIG_SMALL("Mobotix MxPEG video"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_LAGARITH,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "lagarith",
         .long_name = NULL_IF_CONFIG_SMALL("Lagarith lossless"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PRORES,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "prores",
         .long_name = NULL_IF_CONFIG_SMALL("Apple ProRes (iCodec Pro)"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
         .profiles  = NULL_IF_CONFIG_SMALL(ff_prores_profiles),
     },
     {
         .id        = AV_CODEC_ID_JV,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "jv",
         .long_name = NULL_IF_CONFIG_SMALL("Bitmap Brothers JV video"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_DFA,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "dfa",
         .long_name = NULL_IF_CONFIG_SMALL("Chronomaster DFA"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_WMV3IMAGE,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "wmv3image",
         .long_name = NULL_IF_CONFIG_SMALL("Windows Media Video 9 Image"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_VC1IMAGE,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "vc1image",
         .long_name = NULL_IF_CONFIG_SMALL("Windows Media Video 9 Image v2"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_UTVIDEO,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "utvideo",
         .long_name = NULL_IF_CONFIG_SMALL("Ut Video"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_BMV_VIDEO,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "bmv_video",
         .long_name = NULL_IF_CONFIG_SMALL("Discworld II BMV video"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_VBLE,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "vble",
         .long_name = NULL_IF_CONFIG_SMALL("VBLE Lossless Codec"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_DXTORY,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "dxtory",
         .long_name = NULL_IF_CONFIG_SMALL("Dxtory"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_V410,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "v410",
         .long_name = NULL_IF_CONFIG_SMALL("Uncompressed 4:4:4 10-bit"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_XWD,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "xwd",
         .long_name = NULL_IF_CONFIG_SMALL("XWD (X Window Dump) image"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
         .mime_types= MT("image/x-xwindowdump"),
     },
     {
         .id        = AV_CODEC_ID_CDXL,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "cdxl",
         .long_name = NULL_IF_CONFIG_SMALL("Commodore CDXL video"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_XBM,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "xbm",
         .long_name = NULL_IF_CONFIG_SMALL("XBM (X BitMap) image"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
         .mime_types= MT("image/x-xbitmap"),
     },
     {
         .id        = AV_CODEC_ID_ZEROCODEC,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "zerocodec",
         .long_name = NULL_IF_CONFIG_SMALL("ZeroCodec Lossless Video"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_MSS1,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "mss1",
         .long_name = NULL_IF_CONFIG_SMALL("MS Screen 1"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_MSA1,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "msa1",
         .long_name = NULL_IF_CONFIG_SMALL("MS ATC Screen"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_TSCC2,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "tscc2",
         .long_name = NULL_IF_CONFIG_SMALL("TechSmith Screen Codec 2"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_MTS2,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "mts2",
         .long_name = NULL_IF_CONFIG_SMALL("MS Expression Encoder Screen"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_CLLC,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "cllc",
         .long_name = NULL_IF_CONFIG_SMALL("Canopus Lossless Codec"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_MSS2,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "mss2",
         .long_name = NULL_IF_CONFIG_SMALL("MS Windows Media Video V9 Screen"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_VP9,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "vp9",
         .long_name = NULL_IF_CONFIG_SMALL("Google VP9"),
         .props     = AV_CODEC_PROP_LOSSY,
         .profiles  = NULL_IF_CONFIG_SMALL(ff_vp9_profiles),
     },
     {
         .id        = AV_CODEC_ID_AIC,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "aic",
         .long_name = NULL_IF_CONFIG_SMALL("Apple Intermediate Codec"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ESCAPE130,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "escape130",
         .long_name = NULL_IF_CONFIG_SMALL("Escape 130"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_G2M,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "g2m",
         .long_name = NULL_IF_CONFIG_SMALL("Go2Meeting"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_WEBP,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "webp",
         .long_name = NULL_IF_CONFIG_SMALL("WebP"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY |
                      AV_CODEC_PROP_LOSSLESS,
         .mime_types= MT("image/webp"),
     },
     {
         .id        = AV_CODEC_ID_HNM4_VIDEO,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "hnm4video",
         .long_name = NULL_IF_CONFIG_SMALL("HNM 4 video"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_HEVC,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "hevc",
         .long_name = NULL_IF_CONFIG_SMALL("H.265 / HEVC (High Efficiency Video Coding)"),
         .props     = AV_CODEC_PROP_LOSSY | AV_CODEC_PROP_REORDER,
         .profiles  = NULL_IF_CONFIG_SMALL(ff_hevc_profiles),
     },
     {
         .id        = AV_CODEC_ID_FIC,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "fic",
         .long_name = NULL_IF_CONFIG_SMALL("Mirillis FIC"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ALIAS_PIX,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "alias_pix",
         .long_name = NULL_IF_CONFIG_SMALL("Alias/Wavefront PIX image"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_BRENDER_PIX,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "brender_pix",
         .long_name = NULL_IF_CONFIG_SMALL("BRender PIX image"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PAF_VIDEO,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "paf_video",
         .long_name = NULL_IF_CONFIG_SMALL("Amazing Studio Packed Animation File Video"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_EXR,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "exr",
         .long_name = NULL_IF_CONFIG_SMALL("OpenEXR image"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY |
                      AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_VP7,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "vp7",
         .long_name = NULL_IF_CONFIG_SMALL("On2 VP7"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_SANM,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "sanm",
         .long_name = NULL_IF_CONFIG_SMALL("LucasArts SANM/SMUSH video"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_SGIRLE,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "sgirle",
         .long_name = NULL_IF_CONFIG_SMALL("SGI RLE 8-bit"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_MVC1,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "mvc1",
         .long_name = NULL_IF_CONFIG_SMALL("Silicon Graphics Motion Video Compressor 1"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_MVC2,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "mvc2",
         .long_name = NULL_IF_CONFIG_SMALL("Silicon Graphics Motion Video Compressor 2"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_HQX,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "hqx",
         .long_name = NULL_IF_CONFIG_SMALL("Canopus HQX"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_TDSC,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "tdsc",
         .long_name = NULL_IF_CONFIG_SMALL("TDSC"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_HQ_HQA,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "hq_hqa",
         .long_name = NULL_IF_CONFIG_SMALL("Canopus HQ/HQA"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_HAP,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "hap",
         .long_name = NULL_IF_CONFIG_SMALL("Vidvox Hap"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_DDS,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "dds",
         .long_name = NULL_IF_CONFIG_SMALL("DirectDraw Surface image decoder"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY |
                      AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_DXV,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "dxv",
         .long_name = NULL_IF_CONFIG_SMALL("Resolume DXV"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_SCREENPRESSO,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "screenpresso",
         .long_name = NULL_IF_CONFIG_SMALL("Screenpresso"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_RSCC,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "rscc",
         .long_name = NULL_IF_CONFIG_SMALL("innoHeim/Rsupport Screen Capture Codec"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_AVS2,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "avs2",
         .long_name = NULL_IF_CONFIG_SMALL("AVS2-P2/IEEE1857.4"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_Y41P,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "y41p",
         .long_name = NULL_IF_CONFIG_SMALL("Uncompressed YUV 4:1:1 12-bit"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_AVRP,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "avrp",
         .long_name = NULL_IF_CONFIG_SMALL("Avid 1:1 10-bit RGB Packer"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_012V,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "012v",
         .long_name = NULL_IF_CONFIG_SMALL("Uncompressed 4:2:2 10-bit"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_AVUI,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "avui",
         .long_name = NULL_IF_CONFIG_SMALL("Avid Meridien Uncompressed"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_AYUV,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "ayuv",
         .long_name = NULL_IF_CONFIG_SMALL("Uncompressed packed MS 4:4:4:4"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_TARGA_Y216,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "targa_y216",
         .long_name = NULL_IF_CONFIG_SMALL("Pinnacle TARGA CineWave YUV16"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_V308,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "v308",
         .long_name = NULL_IF_CONFIG_SMALL("Uncompressed packed 4:4:4"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_V408,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "v408",
         .long_name = NULL_IF_CONFIG_SMALL("Uncompressed packed QT 4:4:4:4"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_YUV4,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "yuv4",
         .long_name = NULL_IF_CONFIG_SMALL("Uncompressed packed 4:2:0"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_AVRN,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "avrn",
         .long_name = NULL_IF_CONFIG_SMALL("Avid AVI Codec"),
     },
     {
         .id        = AV_CODEC_ID_CPIA,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "cpia",
         .long_name = NULL_IF_CONFIG_SMALL("CPiA video format"),
     },
     {
         .id        = AV_CODEC_ID_XFACE,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "xface",
         .long_name = NULL_IF_CONFIG_SMALL("X-face image"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_SNOW,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "snow",
         .long_name = NULL_IF_CONFIG_SMALL("Snow"),
         .props     = AV_CODEC_PROP_LOSSY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_SMVJPEG,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "smvjpeg",
         .long_name = NULL_IF_CONFIG_SMALL("Sigmatel Motion Video"),
     },
     {
         .id        = AV_CODEC_ID_APNG,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "apng",
         .long_name = NULL_IF_CONFIG_SMALL("APNG (Animated Portable Network Graphics) image"),
         .props     = AV_CODEC_PROP_LOSSLESS,
         .mime_types= MT("image/png"),
     },
     {
         .id        = AV_CODEC_ID_DAALA,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "daala",
         .long_name = NULL_IF_CONFIG_SMALL("Daala"),
         .props     = AV_CODEC_PROP_LOSSY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_CFHD,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "cfhd",
         .long_name = NULL_IF_CONFIG_SMALL("Cineform HD"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_TRUEMOTION2RT,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "truemotion2rt",
         .long_name = NULL_IF_CONFIG_SMALL("Duck TrueMotion 2.0 Real Time"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_M101,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "m101",
         .long_name = NULL_IF_CONFIG_SMALL("Matrox Uncompressed SD"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_MAGICYUV,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "magicyuv",
         .long_name = NULL_IF_CONFIG_SMALL("MagicYUV video"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_SHEERVIDEO,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "sheervideo",
         .long_name = NULL_IF_CONFIG_SMALL("BitJazz SheerVideo"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_YLC,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "ylc",
         .long_name = NULL_IF_CONFIG_SMALL("YUY2 Lossless Codec"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PSD,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "psd",
         .long_name = NULL_IF_CONFIG_SMALL("Photoshop PSD file"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PIXLET,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "pixlet",
         .long_name = NULL_IF_CONFIG_SMALL("Apple Pixlet"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_SPEEDHQ,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "speedhq",
         .long_name = NULL_IF_CONFIG_SMALL("NewTek SpeedHQ"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_FMVC,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "fmvc",
         .long_name = NULL_IF_CONFIG_SMALL("FM Screen Capture Codec"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_SCPR,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "scpr",
         .long_name = NULL_IF_CONFIG_SMALL("ScreenPressor"),
         .props     = AV_CODEC_PROP_LOSSLESS | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_CLEARVIDEO,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "clearvideo",
         .long_name = NULL_IF_CONFIG_SMALL("Iterated Systems ClearVideo"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_XPM,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "xpm",
         .long_name = NULL_IF_CONFIG_SMALL("XPM (X PixMap) image"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
         .mime_types= MT("image/x-xpixmap"),
     },
     {
         .id        = AV_CODEC_ID_AV1,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "av1",
         .long_name = NULL_IF_CONFIG_SMALL("Alliance for Open Media AV1"),
         .props     = AV_CODEC_PROP_LOSSY,
         .profiles  = NULL_IF_CONFIG_SMALL(ff_av1_profiles),
     },
     {
         .id        = AV_CODEC_ID_BITPACKED,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "bitpacked",
         .long_name = NULL_IF_CONFIG_SMALL("Bitpacked"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_MSCC,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "mscc",
         .long_name = NULL_IF_CONFIG_SMALL("Mandsoft Screen Capture Codec"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_SRGC,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "srgc",
         .long_name = NULL_IF_CONFIG_SMALL("Screen Recorder Gold Codec"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_SVG,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "svg",
         .long_name = NULL_IF_CONFIG_SMALL("Scalable Vector Graphics"),
         .props     = AV_CODEC_PROP_LOSSLESS,
         .mime_types= MT("image/svg+xml"),
     },
     {
         .id        = AV_CODEC_ID_GDV,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "gdv",
         .long_name = NULL_IF_CONFIG_SMALL("Gremlin Digital Video"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_FITS,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "fits",
         .long_name = NULL_IF_CONFIG_SMALL("FITS (Flexible Image Transport System)"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_IMM4,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "imm4",
         .long_name = NULL_IF_CONFIG_SMALL("Infinity IMM4"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_PROSUMER,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "prosumer",
         .long_name = NULL_IF_CONFIG_SMALL("Brooktree ProSumer Video"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_MWSC,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "mwsc",
         .long_name = NULL_IF_CONFIG_SMALL("MatchWare Screen Capture Codec"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_WCMV,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "wcmv",
         .long_name = NULL_IF_CONFIG_SMALL("WinCAM Motion Video"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_RASC,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "rasc",
         .long_name = NULL_IF_CONFIG_SMALL("RemotelyAnywhere Screen Capture"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_HYMT,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "hymt",
         .long_name = NULL_IF_CONFIG_SMALL("HuffYUV MT"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_ARBC,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "arbc",
         .long_name = NULL_IF_CONFIG_SMALL("Gryphon's Anim Compressor"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_AGM,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "agm",
         .long_name = NULL_IF_CONFIG_SMALL("Amuse Graphics Movie"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
 
     /* various PCM "codecs" */
     {
         .id        = AV_CODEC_ID_PCM_S16LE,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_s16le",
         .long_name = NULL_IF_CONFIG_SMALL("PCM signed 16-bit little-endian"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PCM_S16BE,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_s16be",
         .long_name = NULL_IF_CONFIG_SMALL("PCM signed 16-bit big-endian"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PCM_U16LE,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_u16le",
         .long_name = NULL_IF_CONFIG_SMALL("PCM unsigned 16-bit little-endian"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PCM_U16BE,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_u16be",
         .long_name = NULL_IF_CONFIG_SMALL("PCM unsigned 16-bit big-endian"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PCM_S8,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_s8",
         .long_name = NULL_IF_CONFIG_SMALL("PCM signed 8-bit"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PCM_U8,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_u8",
         .long_name = NULL_IF_CONFIG_SMALL("PCM unsigned 8-bit"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PCM_MULAW,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_mulaw",
         .long_name = NULL_IF_CONFIG_SMALL("PCM mu-law / G.711 mu-law"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_PCM_ALAW,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_alaw",
         .long_name = NULL_IF_CONFIG_SMALL("PCM A-law / G.711 A-law"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_PCM_S32LE,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_s32le",
         .long_name = NULL_IF_CONFIG_SMALL("PCM signed 32-bit little-endian"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PCM_S32BE,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_s32be",
         .long_name = NULL_IF_CONFIG_SMALL("PCM signed 32-bit big-endian"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PCM_U32LE,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_u32le",
         .long_name = NULL_IF_CONFIG_SMALL("PCM unsigned 32-bit little-endian"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PCM_U32BE,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_u32be",
         .long_name = NULL_IF_CONFIG_SMALL("PCM unsigned 32-bit big-endian"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PCM_S24LE,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_s24le",
         .long_name = NULL_IF_CONFIG_SMALL("PCM signed 24-bit little-endian"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PCM_S24BE,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_s24be",
         .long_name = NULL_IF_CONFIG_SMALL("PCM signed 24-bit big-endian"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PCM_U24LE,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_u24le",
         .long_name = NULL_IF_CONFIG_SMALL("PCM unsigned 24-bit little-endian"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PCM_U24BE,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_u24be",
         .long_name = NULL_IF_CONFIG_SMALL("PCM unsigned 24-bit big-endian"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PCM_S24DAUD,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_s24daud",
         .long_name = NULL_IF_CONFIG_SMALL("PCM D-Cinema audio signed 24-bit"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PCM_ZORK,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_zork",
         .long_name = NULL_IF_CONFIG_SMALL("PCM Zork"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_PCM_S16LE_PLANAR,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_s16le_planar",
         .long_name = NULL_IF_CONFIG_SMALL("PCM signed 16-bit little-endian planar"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PCM_DVD,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_dvd",
         .long_name = NULL_IF_CONFIG_SMALL("PCM signed 20|24-bit big-endian"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PCM_F32BE,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_f32be",
         .long_name = NULL_IF_CONFIG_SMALL("PCM 32-bit floating point big-endian"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PCM_F32LE,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_f32le",
         .long_name = NULL_IF_CONFIG_SMALL("PCM 32-bit floating point little-endian"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PCM_F64BE,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_f64be",
         .long_name = NULL_IF_CONFIG_SMALL("PCM 64-bit floating point big-endian"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PCM_F64LE,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_f64le",
         .long_name = NULL_IF_CONFIG_SMALL("PCM 64-bit floating point little-endian"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PCM_BLURAY,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_bluray",
         .long_name = NULL_IF_CONFIG_SMALL("PCM signed 16|20|24-bit big-endian for Blu-ray media"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PCM_LXF,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_lxf",
         .long_name = NULL_IF_CONFIG_SMALL("PCM signed 20-bit little-endian planar"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_S302M,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "s302m",
         .long_name = NULL_IF_CONFIG_SMALL("SMPTE 302M"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PCM_S8_PLANAR,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_s8_planar",
         .long_name = NULL_IF_CONFIG_SMALL("PCM signed 8-bit planar"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PCM_S24LE_PLANAR,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_s24le_planar",
         .long_name = NULL_IF_CONFIG_SMALL("PCM signed 24-bit little-endian planar"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PCM_S32LE_PLANAR,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_s32le_planar",
         .long_name = NULL_IF_CONFIG_SMALL("PCM signed 32-bit little-endian planar"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PCM_S16BE_PLANAR,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_s16be_planar",
         .long_name = NULL_IF_CONFIG_SMALL("PCM signed 16-bit big-endian planar"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PCM_S64LE,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_s64le",
         .long_name = NULL_IF_CONFIG_SMALL("PCM signed 64-bit little-endian"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PCM_S64BE,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_s64be",
         .long_name = NULL_IF_CONFIG_SMALL("PCM signed 64-bit big-endian"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PCM_F16LE,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_f16le",
         .long_name = NULL_IF_CONFIG_SMALL("PCM 16.8 floating point little-endian"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PCM_F24LE,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_f24le",
         .long_name = NULL_IF_CONFIG_SMALL("PCM 24.0 floating point little-endian"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_PCM_VIDC,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "pcm_vidc",
         .long_name = NULL_IF_CONFIG_SMALL("PCM Archimedes VIDC"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
 
     /* various ADPCM codecs */
     {
         .id        = AV_CODEC_ID_ADPCM_IMA_QT,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_ima_qt",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM IMA QuickTime"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_IMA_WAV,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_ima_wav",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM IMA WAV"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_IMA_DK3,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_ima_dk3",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM IMA Duck DK3"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_IMA_DK4,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_ima_dk4",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM IMA Duck DK4"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_IMA_WS,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_ima_ws",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM IMA Westwood"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_IMA_SMJPEG,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_ima_smjpeg",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM IMA Loki SDL MJPEG"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_MS,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_ms",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM Microsoft"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_4XM,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_4xm",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM 4X Movie"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_XA,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_xa",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM CDROM XA"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_ADX,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_adx",
         .long_name = NULL_IF_CONFIG_SMALL("SEGA CRI ADX ADPCM"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_EA,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_ea",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM Electronic Arts"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_G726,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_g726",
         .long_name = NULL_IF_CONFIG_SMALL("G.726 ADPCM"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_CT,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_ct",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM Creative Technology"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_SWF,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_swf",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM Shockwave Flash"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_YAMAHA,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_yamaha",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM Yamaha"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_SBPRO_4,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_sbpro_4",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM Sound Blaster Pro 4-bit"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_SBPRO_3,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_sbpro_3",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM Sound Blaster Pro 2.6-bit"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_SBPRO_2,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_sbpro_2",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM Sound Blaster Pro 2-bit"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_THP,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_thp",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM Nintendo THP"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_IMA_AMV,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_ima_amv",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM IMA AMV"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_EA_R1,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_ea_r1",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM Electronic Arts R1"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_EA_R3,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_ea_r3",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM Electronic Arts R3"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_EA_R2,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_ea_r2",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM Electronic Arts R2"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_IMA_EA_SEAD,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_ima_ea_sead",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM IMA Electronic Arts SEAD"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_IMA_EA_EACS,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_ima_ea_eacs",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM IMA Electronic Arts EACS"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_EA_XAS,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_ea_xas",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM Electronic Arts XAS"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_EA_MAXIS_XA,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_ea_maxis_xa",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM Electronic Arts Maxis CDROM XA"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_IMA_ISS,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_ima_iss",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM IMA Funcom ISS"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_G722,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_g722",
         .long_name = NULL_IF_CONFIG_SMALL("G.722 ADPCM"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_IMA_APC,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_ima_apc",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM IMA CRYO APC"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_VIMA,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_vima",
         .long_name = NULL_IF_CONFIG_SMALL("LucasArts VIMA audio"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_AFC,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_afc",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM Nintendo Gamecube AFC"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_IMA_OKI,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_ima_oki",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM IMA Dialogic OKI"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_DTK,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_dtk",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM Nintendo Gamecube DTK"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_IMA_RAD,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_ima_rad",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM IMA Radical"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_G726LE,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_g726le",
         .long_name = NULL_IF_CONFIG_SMALL("G.726 ADPCM little-endian"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_THP_LE,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_thp_le",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM Nintendo THP (Little-Endian)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_PSX,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_psx",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM Playstation"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_AICA,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_aica",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM Yamaha AICA"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_IMA_DAT4,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_ima_dat4",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM IMA Eurocom DAT4"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ADPCM_MTAF,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "adpcm_mtaf",
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM MTAF"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
+    {
+        .id        = AV_CODEC_ID_ADPCM_AGM,
+        .type      = AVMEDIA_TYPE_AUDIO,
+        .name      = "adpcm_agm",
+        .long_name = NULL_IF_CONFIG_SMALL("ADPCM AmuseGraphics Movie AGM"),
+        .props     = AV_CODEC_PROP_LOSSY,
+    },
 
     /* AMR */
     {
         .id        = AV_CODEC_ID_AMR_NB,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "amr_nb",
         .long_name = NULL_IF_CONFIG_SMALL("AMR-NB (Adaptive Multi-Rate NarrowBand)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_AMR_WB,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "amr_wb",
         .long_name = NULL_IF_CONFIG_SMALL("AMR-WB (Adaptive Multi-Rate WideBand)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
 
     /* RealAudio codecs*/
     {
         .id        = AV_CODEC_ID_RA_144,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "ra_144",
         .long_name = NULL_IF_CONFIG_SMALL("RealAudio 1.0 (14.4K)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_RA_288,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "ra_288",
         .long_name = NULL_IF_CONFIG_SMALL("RealAudio 2.0 (28.8K)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
 
     /* various DPCM codecs */
     {
         .id        = AV_CODEC_ID_ROQ_DPCM,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "roq_dpcm",
         .long_name = NULL_IF_CONFIG_SMALL("DPCM id RoQ"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_INTERPLAY_DPCM,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "interplay_dpcm",
         .long_name = NULL_IF_CONFIG_SMALL("DPCM Interplay"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_XAN_DPCM,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "xan_dpcm",
         .long_name = NULL_IF_CONFIG_SMALL("DPCM Xan"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_SOL_DPCM,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "sol_dpcm",
         .long_name = NULL_IF_CONFIG_SMALL("DPCM Sol"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_SDX2_DPCM,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "sdx2_dpcm",
         .long_name = NULL_IF_CONFIG_SMALL("DPCM Squareroot-Delta-Exact"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_GREMLIN_DPCM,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "gremlin_dpcm",
         .long_name = NULL_IF_CONFIG_SMALL("DPCM Gremlin"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
 
     /* audio codecs */
     {
         .id        = AV_CODEC_ID_MP2,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "mp2",
         .long_name = NULL_IF_CONFIG_SMALL("MP2 (MPEG audio layer 2)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_MP3,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "mp3",
         .long_name = NULL_IF_CONFIG_SMALL("MP3 (MPEG audio layer 3)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_AAC,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "aac",
         .long_name = NULL_IF_CONFIG_SMALL("AAC (Advanced Audio Coding)"),
         .props     = AV_CODEC_PROP_LOSSY,
         .profiles  = NULL_IF_CONFIG_SMALL(ff_aac_profiles),
     },
     {
         .id        = AV_CODEC_ID_AC3,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "ac3",
         .long_name = NULL_IF_CONFIG_SMALL("ATSC A/52A (AC-3)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_DTS,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "dts",
         .long_name = NULL_IF_CONFIG_SMALL("DCA (DTS Coherent Acoustics)"),
         .props     = AV_CODEC_PROP_LOSSY | AV_CODEC_PROP_LOSSLESS,
         .profiles  = NULL_IF_CONFIG_SMALL(ff_dca_profiles),
     },
     {
         .id        = AV_CODEC_ID_VORBIS,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "vorbis",
         .long_name = NULL_IF_CONFIG_SMALL("Vorbis"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_DVAUDIO,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "dvaudio",
         .long_name = NULL_IF_CONFIG_SMALL("DV audio"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_WMAV1,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "wmav1",
         .long_name = NULL_IF_CONFIG_SMALL("Windows Media Audio 1"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_WMAV2,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "wmav2",
         .long_name = NULL_IF_CONFIG_SMALL("Windows Media Audio 2"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_MACE3,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "mace3",
         .long_name = NULL_IF_CONFIG_SMALL("MACE (Macintosh Audio Compression/Expansion) 3:1"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_MACE6,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "mace6",
         .long_name = NULL_IF_CONFIG_SMALL("MACE (Macintosh Audio Compression/Expansion) 6:1"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_VMDAUDIO,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "vmdaudio",
         .long_name = NULL_IF_CONFIG_SMALL("Sierra VMD audio"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_FLAC,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "flac",
         .long_name = NULL_IF_CONFIG_SMALL("FLAC (Free Lossless Audio Codec)"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_MP3ADU,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "mp3adu",
         .long_name = NULL_IF_CONFIG_SMALL("ADU (Application Data Unit) MP3 (MPEG audio layer 3)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_MP3ON4,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "mp3on4",
         .long_name = NULL_IF_CONFIG_SMALL("MP3onMP4"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_SHORTEN,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "shorten",
         .long_name = NULL_IF_CONFIG_SMALL("Shorten"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_ALAC,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "alac",
         .long_name = NULL_IF_CONFIG_SMALL("ALAC (Apple Lossless Audio Codec)"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_WESTWOOD_SND1,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "westwood_snd1",
         .long_name = NULL_IF_CONFIG_SMALL("Westwood Audio (SND1)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_GSM,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "gsm",
         .long_name = NULL_IF_CONFIG_SMALL("GSM"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_QDM2,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "qdm2",
         .long_name = NULL_IF_CONFIG_SMALL("QDesign Music Codec 2"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_COOK,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "cook",
         .long_name = NULL_IF_CONFIG_SMALL("Cook / Cooker / Gecko (RealAudio G2)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_TRUESPEECH,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "truespeech",
         .long_name = NULL_IF_CONFIG_SMALL("DSP Group TrueSpeech"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_TTA,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "tta",
         .long_name = NULL_IF_CONFIG_SMALL("TTA (True Audio)"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_SMACKAUDIO,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "smackaudio",
         .long_name = NULL_IF_CONFIG_SMALL("Smacker audio"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_QCELP,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "qcelp",
         .long_name = NULL_IF_CONFIG_SMALL("QCELP / PureVoice"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_WAVPACK,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "wavpack",
         .long_name = NULL_IF_CONFIG_SMALL("WavPack"),
         .props     = AV_CODEC_PROP_INTRA_ONLY |
                      AV_CODEC_PROP_LOSSY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_DSICINAUDIO,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "dsicinaudio",
         .long_name = NULL_IF_CONFIG_SMALL("Delphine Software International CIN audio"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_IMC,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "imc",
         .long_name = NULL_IF_CONFIG_SMALL("IMC (Intel Music Coder)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_MUSEPACK7,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "musepack7",
         .long_name = NULL_IF_CONFIG_SMALL("Musepack SV7"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_MLP,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "mlp",
         .long_name = NULL_IF_CONFIG_SMALL("MLP (Meridian Lossless Packing)"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_GSM_MS,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "gsm_ms",
         .long_name = NULL_IF_CONFIG_SMALL("GSM Microsoft variant"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ATRAC3,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "atrac3",
         .long_name = NULL_IF_CONFIG_SMALL("ATRAC3 (Adaptive TRansform Acoustic Coding 3)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_APE,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "ape",
         .long_name = NULL_IF_CONFIG_SMALL("Monkey's Audio"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_NELLYMOSER,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "nellymoser",
         .long_name = NULL_IF_CONFIG_SMALL("Nellymoser Asao"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_MUSEPACK8,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "musepack8",
         .long_name = NULL_IF_CONFIG_SMALL("Musepack SV8"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_SPEEX,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "speex",
         .long_name = NULL_IF_CONFIG_SMALL("Speex"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_WMAVOICE,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "wmavoice",
         .long_name = NULL_IF_CONFIG_SMALL("Windows Media Audio Voice"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_WMAPRO,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "wmapro",
         .long_name = NULL_IF_CONFIG_SMALL("Windows Media Audio 9 Professional"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_WMALOSSLESS,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "wmalossless",
         .long_name = NULL_IF_CONFIG_SMALL("Windows Media Audio Lossless"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_ATRAC3P,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "atrac3p",
         .long_name = NULL_IF_CONFIG_SMALL("ATRAC3+ (Adaptive TRansform Acoustic Coding 3+)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_EAC3,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "eac3",
         .long_name = NULL_IF_CONFIG_SMALL("ATSC A/52B (AC-3, E-AC-3)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_SIPR,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "sipr",
         .long_name = NULL_IF_CONFIG_SMALL("RealAudio SIPR / ACELP.NET"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_MP1,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "mp1",
         .long_name = NULL_IF_CONFIG_SMALL("MP1 (MPEG audio layer 1)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_TWINVQ,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "twinvq",
         .long_name = NULL_IF_CONFIG_SMALL("VQF TwinVQ"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_TRUEHD,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "truehd",
         .long_name = NULL_IF_CONFIG_SMALL("TrueHD"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_MP4ALS,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "mp4als",
         .long_name = NULL_IF_CONFIG_SMALL("MPEG-4 Audio Lossless Coding (ALS)"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_ATRAC1,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "atrac1",
         .long_name = NULL_IF_CONFIG_SMALL("ATRAC1 (Adaptive TRansform Acoustic Coding)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_BINKAUDIO_RDFT,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "binkaudio_rdft",
         .long_name = NULL_IF_CONFIG_SMALL("Bink Audio (RDFT)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_BINKAUDIO_DCT,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "binkaudio_dct",
         .long_name = NULL_IF_CONFIG_SMALL("Bink Audio (DCT)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_AAC_LATM,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "aac_latm",
         .long_name = NULL_IF_CONFIG_SMALL("AAC LATM (Advanced Audio Coding LATM syntax)"),
         .props     = AV_CODEC_PROP_LOSSY,
         .profiles  = NULL_IF_CONFIG_SMALL(ff_aac_profiles),
     },
     {
         .id        = AV_CODEC_ID_QDMC,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "qdmc",
         .long_name = NULL_IF_CONFIG_SMALL("QDesign Music"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_CELT,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "celt",
         .long_name = NULL_IF_CONFIG_SMALL("Constrained Energy Lapped Transform (CELT)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_G723_1,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "g723_1",
         .long_name = NULL_IF_CONFIG_SMALL("G.723.1"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_G729,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "g729",
         .long_name = NULL_IF_CONFIG_SMALL("G.729"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_8SVX_EXP,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "8svx_exp",
         .long_name = NULL_IF_CONFIG_SMALL("8SVX exponential"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_8SVX_FIB,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "8svx_fib",
         .long_name = NULL_IF_CONFIG_SMALL("8SVX fibonacci"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_BMV_AUDIO,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "bmv_audio",
         .long_name = NULL_IF_CONFIG_SMALL("Discworld II BMV audio"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_RALF,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "ralf",
         .long_name = NULL_IF_CONFIG_SMALL("RealAudio Lossless"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_IAC,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "iac",
         .long_name = NULL_IF_CONFIG_SMALL("IAC (Indeo Audio Coder)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ILBC,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "ilbc",
         .long_name = NULL_IF_CONFIG_SMALL("iLBC (Internet Low Bitrate Codec)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_OPUS,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "opus",
         .long_name = NULL_IF_CONFIG_SMALL("Opus (Opus Interactive Audio Codec)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_COMFORT_NOISE,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "comfortnoise",
         .long_name = NULL_IF_CONFIG_SMALL("RFC 3389 Comfort Noise"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_TAK,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "tak",
         .long_name = NULL_IF_CONFIG_SMALL("TAK (Tom's lossless Audio Kompressor)"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_METASOUND,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "metasound",
         .long_name = NULL_IF_CONFIG_SMALL("Voxware MetaSound"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_PAF_AUDIO,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "paf_audio",
         .long_name = NULL_IF_CONFIG_SMALL("Amazing Studio Packed Animation File Audio"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ON2AVC,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "avc",
         .long_name = NULL_IF_CONFIG_SMALL("On2 Audio for Video Codec"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_DSS_SP,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "dss_sp",
         .long_name = NULL_IF_CONFIG_SMALL("Digital Speech Standard - Standard Play mode (DSS SP)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_CODEC2,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "codec2",
         .long_name = NULL_IF_CONFIG_SMALL("codec2 (very low bitrate speech codec)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_FFWAVESYNTH,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "wavesynth",
         .long_name = NULL_IF_CONFIG_SMALL("Wave synthesis pseudo-codec"),
     },
     {
         .id        = AV_CODEC_ID_SONIC,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "sonic",
         .long_name = NULL_IF_CONFIG_SMALL("Sonic"),
     },
     {
         .id        = AV_CODEC_ID_SONIC_LS,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "sonicls",
         .long_name = NULL_IF_CONFIG_SMALL("Sonic lossless"),
     },
     {
         .id        = AV_CODEC_ID_EVRC,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "evrc",
         .long_name = NULL_IF_CONFIG_SMALL("EVRC (Enhanced Variable Rate Codec)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_SMV,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "smv",
         .long_name = NULL_IF_CONFIG_SMALL("SMV (Selectable Mode Vocoder)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_DSD_LSBF,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "dsd_lsbf",
         .long_name = NULL_IF_CONFIG_SMALL("DSD (Direct Stream Digital), least significant bit first"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_DSD_MSBF,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "dsd_msbf",
         .long_name = NULL_IF_CONFIG_SMALL("DSD (Direct Stream Digital), most significant bit first"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_DSD_LSBF_PLANAR,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "dsd_lsbf_planar",
         .long_name = NULL_IF_CONFIG_SMALL("DSD (Direct Stream Digital), least significant bit first, planar"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_DSD_MSBF_PLANAR,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "dsd_msbf_planar",
         .long_name = NULL_IF_CONFIG_SMALL("DSD (Direct Stream Digital), most significant bit first, planar"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_4GV,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "4gv",
         .long_name = NULL_IF_CONFIG_SMALL("4GV (Fourth Generation Vocoder)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_INTERPLAY_ACM,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "interplayacm",
         .long_name = NULL_IF_CONFIG_SMALL("Interplay ACM"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_XMA1,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "xma1",
         .long_name = NULL_IF_CONFIG_SMALL("Xbox Media Audio 1"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_XMA2,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "xma2",
         .long_name = NULL_IF_CONFIG_SMALL("Xbox Media Audio 2"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_DST,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "dst",
         .long_name = NULL_IF_CONFIG_SMALL("DST (Direct Stream Transfer)"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_ATRAC3AL,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "atrac3al",
         .long_name = NULL_IF_CONFIG_SMALL("ATRAC3 AL (Adaptive TRansform Acoustic Coding 3 Advanced Lossless)"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_ATRAC3PAL,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "atrac3pal",
         .long_name = NULL_IF_CONFIG_SMALL("ATRAC3+ AL (Adaptive TRansform Acoustic Coding 3+ Advanced Lossless)"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_DOLBY_E,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "dolby_e",
         .long_name = NULL_IF_CONFIG_SMALL("Dolby E"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_APTX,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "aptx",
         .long_name = NULL_IF_CONFIG_SMALL("aptX (Audio Processing Technology for Bluetooth)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_APTX_HD,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "aptx_hd",
         .long_name = NULL_IF_CONFIG_SMALL("aptX HD (Audio Processing Technology for Bluetooth)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_SBC,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "sbc",
         .long_name = NULL_IF_CONFIG_SMALL("SBC (low-complexity subband codec)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_ATRAC9,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "atrac9",
         .long_name = NULL_IF_CONFIG_SMALL("ATRAC9 (Adaptive TRansform Acoustic Coding 9)"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
     {
         .id        = AV_CODEC_ID_HCOM,
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "hcom",
         .long_name = NULL_IF_CONFIG_SMALL("HCOM Audio"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
 
     /* subtitle codecs */
     {
         .id        = AV_CODEC_ID_DVD_SUBTITLE,
         .type      = AVMEDIA_TYPE_SUBTITLE,
         .name      = "dvd_subtitle",
         .long_name = NULL_IF_CONFIG_SMALL("DVD subtitles"),
         .props     = AV_CODEC_PROP_BITMAP_SUB,
     },
     {
         .id        = AV_CODEC_ID_DVB_SUBTITLE,
         .type      = AVMEDIA_TYPE_SUBTITLE,
         .name      = "dvb_subtitle",
         .long_name = NULL_IF_CONFIG_SMALL("DVB subtitles"),
         .props     = AV_CODEC_PROP_BITMAP_SUB,
     },
     {
         .id        = AV_CODEC_ID_TEXT,
         .type      = AVMEDIA_TYPE_SUBTITLE,
         .name      = "text",
         .long_name = NULL_IF_CONFIG_SMALL("raw UTF-8 text"),
         .props     = AV_CODEC_PROP_TEXT_SUB,
     },
     {
         .id        = AV_CODEC_ID_XSUB,
         .type      = AVMEDIA_TYPE_SUBTITLE,
         .name      = "xsub",
         .long_name = NULL_IF_CONFIG_SMALL("XSUB"),
         .props     = AV_CODEC_PROP_BITMAP_SUB,
     },
     {
         .id        = AV_CODEC_ID_SSA,
         .type      = AVMEDIA_TYPE_SUBTITLE,
         .name      = "ssa",
         .long_name = NULL_IF_CONFIG_SMALL("SSA (SubStation Alpha) subtitle"),
         .props     = AV_CODEC_PROP_TEXT_SUB,
     },
     {
         .id        = AV_CODEC_ID_MOV_TEXT,
         .type      = AVMEDIA_TYPE_SUBTITLE,
         .name      = "mov_text",
         .long_name = NULL_IF_CONFIG_SMALL("MOV text"),
         .props     = AV_CODEC_PROP_TEXT_SUB,
     },
     {
         .id        = AV_CODEC_ID_HDMV_PGS_SUBTITLE,
         .type      = AVMEDIA_TYPE_SUBTITLE,
         .name      = "hdmv_pgs_subtitle",
         .long_name = NULL_IF_CONFIG_SMALL("HDMV Presentation Graphic Stream subtitles"),
         .props     = AV_CODEC_PROP_BITMAP_SUB,
     },
     {
         .id        = AV_CODEC_ID_DVB_TELETEXT,
         .type      = AVMEDIA_TYPE_SUBTITLE,
         .name      = "dvb_teletext",
         .long_name = NULL_IF_CONFIG_SMALL("DVB teletext"),
     },
     {
         .id        = AV_CODEC_ID_SRT,
         .type      = AVMEDIA_TYPE_SUBTITLE,
         .name      = "srt",
         .long_name = NULL_IF_CONFIG_SMALL("SubRip subtitle with embedded timing"),
         .props     = AV_CODEC_PROP_TEXT_SUB,
     },
     {
         .id        = AV_CODEC_ID_MICRODVD,
         .type      = AVMEDIA_TYPE_SUBTITLE,
         .name      = "microdvd",
         .long_name = NULL_IF_CONFIG_SMALL("MicroDVD subtitle"),
         .props     = AV_CODEC_PROP_TEXT_SUB,
     },
     {
         .id        = AV_CODEC_ID_EIA_608,
         .type      = AVMEDIA_TYPE_SUBTITLE,
         .name      = "eia_608",
         .long_name = NULL_IF_CONFIG_SMALL("EIA-608 closed captions"),
         .props     = AV_CODEC_PROP_TEXT_SUB,
     },
     {
         .id        = AV_CODEC_ID_JACOSUB,
         .type      = AVMEDIA_TYPE_SUBTITLE,
         .name      = "jacosub",
         .long_name = NULL_IF_CONFIG_SMALL("JACOsub subtitle"),
         .props     = AV_CODEC_PROP_TEXT_SUB,
     },
     {
         .id        = AV_CODEC_ID_SAMI,
         .type      = AVMEDIA_TYPE_SUBTITLE,
         .name      = "sami",
         .long_name = NULL_IF_CONFIG_SMALL("SAMI subtitle"),
         .props     = AV_CODEC_PROP_TEXT_SUB,
     },
     {
         .id        = AV_CODEC_ID_REALTEXT,
         .type      = AVMEDIA_TYPE_SUBTITLE,
         .name      = "realtext",
         .long_name = NULL_IF_CONFIG_SMALL("RealText subtitle"),
         .props     = AV_CODEC_PROP_TEXT_SUB,
     },
     {
         .id        = AV_CODEC_ID_STL,
         .type      = AVMEDIA_TYPE_SUBTITLE,
         .name      = "stl",
         .long_name = NULL_IF_CONFIG_SMALL("Spruce subtitle format"),
         .props     = AV_CODEC_PROP_TEXT_SUB,
     },
     {
         .id        = AV_CODEC_ID_SUBVIEWER1,
         .type      = AVMEDIA_TYPE_SUBTITLE,
         .name      = "subviewer1",
         .long_name = NULL_IF_CONFIG_SMALL("SubViewer v1 subtitle"),
         .props     = AV_CODEC_PROP_TEXT_SUB,
     },
     {
         .id        = AV_CODEC_ID_SUBVIEWER,
         .type      = AVMEDIA_TYPE_SUBTITLE,
         .name      = "subviewer",
         .long_name = NULL_IF_CONFIG_SMALL("SubViewer subtitle"),
         .props     = AV_CODEC_PROP_TEXT_SUB,
     },
     {
         .id        = AV_CODEC_ID_SUBRIP,
         .type      = AVMEDIA_TYPE_SUBTITLE,
         .name      = "subrip",
         .long_name = NULL_IF_CONFIG_SMALL("SubRip subtitle"),
         .props     = AV_CODEC_PROP_TEXT_SUB,
     },
     {
         .id        = AV_CODEC_ID_WEBVTT,
         .type      = AVMEDIA_TYPE_SUBTITLE,
         .name      = "webvtt",
         .long_name = NULL_IF_CONFIG_SMALL("WebVTT subtitle"),
         .props     = AV_CODEC_PROP_TEXT_SUB,
     },
     {
         .id        = AV_CODEC_ID_MPL2,
         .type      = AVMEDIA_TYPE_SUBTITLE,
         .name      = "mpl2",
         .long_name = NULL_IF_CONFIG_SMALL("MPL2 subtitle"),
         .props     = AV_CODEC_PROP_TEXT_SUB,
     },
     {
         .id        = AV_CODEC_ID_VPLAYER,
         .type      = AVMEDIA_TYPE_SUBTITLE,
         .name      = "vplayer",
         .long_name = NULL_IF_CONFIG_SMALL("VPlayer subtitle"),
         .props     = AV_CODEC_PROP_TEXT_SUB,
     },
     {
         .id        = AV_CODEC_ID_PJS,
         .type      = AVMEDIA_TYPE_SUBTITLE,
         .name      = "pjs",
         .long_name = NULL_IF_CONFIG_SMALL("PJS (Phoenix Japanimation Society) subtitle"),
         .props     = AV_CODEC_PROP_TEXT_SUB,
     },
     {
         .id        = AV_CODEC_ID_ASS,
         .type      = AVMEDIA_TYPE_SUBTITLE,
         .name      = "ass",
         .long_name = NULL_IF_CONFIG_SMALL("ASS (Advanced SSA) subtitle"),
         .props     = AV_CODEC_PROP_TEXT_SUB,
     },
     {
         .id        = AV_CODEC_ID_HDMV_TEXT_SUBTITLE,
         .type      = AVMEDIA_TYPE_SUBTITLE,
         .name      = "hdmv_text_subtitle",
         .long_name = NULL_IF_CONFIG_SMALL("HDMV Text subtitle"),
         .props     = AV_CODEC_PROP_TEXT_SUB,
     },
     {
         .id        = AV_CODEC_ID_TTML,
         .type      = AVMEDIA_TYPE_SUBTITLE,
         .name      = "ttml",
         .long_name = NULL_IF_CONFIG_SMALL("Timed Text Markup Language"),
         .props     = AV_CODEC_PROP_TEXT_SUB,
     },
     {
         .id        = AV_CODEC_ID_ARIB_CAPTION,
         .type      = AVMEDIA_TYPE_SUBTITLE,
         .name      = "arib_caption",
         .long_name = NULL_IF_CONFIG_SMALL("ARIB STD-B24 caption"),
         .props     = AV_CODEC_PROP_TEXT_SUB,
         .profiles  = NULL_IF_CONFIG_SMALL(ff_arib_caption_profiles),
     },
 
     /* other kind of codecs and pseudo-codecs */
     {
         .id        = AV_CODEC_ID_TTF,
         .type      = AVMEDIA_TYPE_DATA,
         .name      = "ttf",
         .long_name = NULL_IF_CONFIG_SMALL("TrueType font"),
         .mime_types= MT("application/x-truetype-font", "application/x-font"),
     },
     {
         .id        = AV_CODEC_ID_SCTE_35,
         .type      = AVMEDIA_TYPE_DATA,
         .name      = "scte_35",
         .long_name = NULL_IF_CONFIG_SMALL("SCTE 35 Message Queue"),
     },
     {
         .id        = AV_CODEC_ID_BINTEXT,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "bintext",
         .long_name = NULL_IF_CONFIG_SMALL("Binary text"),
         .props     = AV_CODEC_PROP_INTRA_ONLY,
     },
     {
         .id        = AV_CODEC_ID_XBIN,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "xbin",
         .long_name = NULL_IF_CONFIG_SMALL("eXtended BINary text"),
         .props     = AV_CODEC_PROP_INTRA_ONLY,
     },
     {
         .id        = AV_CODEC_ID_IDF,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "idf",
         .long_name = NULL_IF_CONFIG_SMALL("iCEDraw text"),
         .props     = AV_CODEC_PROP_INTRA_ONLY,
     },
     {
         .id        = AV_CODEC_ID_OTF,
         .type      = AVMEDIA_TYPE_DATA,
         .name      = "otf",
         .long_name = NULL_IF_CONFIG_SMALL("OpenType font"),
         .mime_types= MT("application/vnd.ms-opentype"),
     },
     {
         .id        = AV_CODEC_ID_SMPTE_KLV,
         .type      = AVMEDIA_TYPE_DATA,
         .name      = "klv",
         .long_name = NULL_IF_CONFIG_SMALL("SMPTE 336M Key-Length-Value (KLV) metadata"),
     },
     {
         .id        = AV_CODEC_ID_DVD_NAV,
         .type      = AVMEDIA_TYPE_DATA,
         .name      = "dvd_nav_packet",
         .long_name = NULL_IF_CONFIG_SMALL("DVD Nav packet"),
     },
     {
         .id        = AV_CODEC_ID_TIMED_ID3,
         .type      = AVMEDIA_TYPE_DATA,
         .name      = "timed_id3",
         .long_name = NULL_IF_CONFIG_SMALL("timed ID3 metadata"),
     },
     {
         .id        = AV_CODEC_ID_BIN_DATA,
         .type      = AVMEDIA_TYPE_DATA,
         .name      = "bin_data",
         .long_name = NULL_IF_CONFIG_SMALL("binary data"),
         .mime_types= MT("application/octet-stream"),
     },
     {
         .id        = AV_CODEC_ID_WRAPPED_AVFRAME,
         .type      = AVMEDIA_TYPE_VIDEO,
         .name      = "wrapped_avframe",
         .long_name = NULL_IF_CONFIG_SMALL("AVFrame to AVPacket passthrough"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
 };
diff --git a/libavcodec/version.h b/libavcodec/version.h
index 02cb5c3ec1..be4408cda2 100644
--- a/libavcodec/version.h
+++ b/libavcodec/version.h
@@ -1,140 +1,140 @@
 /*
  * This file is part of FFmpeg.
  *
  * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
  * version 2.1 of the License, or (at your option) any later version.
  *
  * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
  * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
 #ifndef AVCODEC_VERSION_H
 #define AVCODEC_VERSION_H
 
 /**
  * @file
  * @ingroup libavc
  * Libavcodec version macros.
  */
 
 #include "libavutil/version.h"
 
 #define LIBAVCODEC_VERSION_MAJOR  58
-#define LIBAVCODEC_VERSION_MINOR  48
-#define LIBAVCODEC_VERSION_MICRO 101
+#define LIBAVCODEC_VERSION_MINOR  49
+#define LIBAVCODEC_VERSION_MICRO 100
 
 #define LIBAVCODEC_VERSION_INT  AV_VERSION_INT(LIBAVCODEC_VERSION_MAJOR, \
                                                LIBAVCODEC_VERSION_MINOR, \
                                                LIBAVCODEC_VERSION_MICRO)
 #define LIBAVCODEC_VERSION      AV_VERSION(LIBAVCODEC_VERSION_MAJOR,    \
                                            LIBAVCODEC_VERSION_MINOR,    \
                                            LIBAVCODEC_VERSION_MICRO)
 #define LIBAVCODEC_BUILD        LIBAVCODEC_VERSION_INT
 
 #define LIBAVCODEC_IDENT        "Lavc" AV_STRINGIFY(LIBAVCODEC_VERSION)
 
 /**
  * FF_API_* defines may be placed below to indicate public API that will be
  * dropped at a future version bump. The defines themselves are not part of
  * the public API and may change, break or disappear at any time.
  *
  * @note, when bumping the major version it is recommended to manually
  * disable each FF_API_* in its own commit instead of disabling them all
  * at once through the bump. This improves the git bisect-ability of the change.
  */
 
 #ifndef FF_API_LOWRES
 #define FF_API_LOWRES            (LIBAVCODEC_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_DEBUG_MV
 #define FF_API_DEBUG_MV          (LIBAVCODEC_VERSION_MAJOR < 58)
 #endif
 #ifndef FF_API_AVCTX_TIMEBASE
 #define FF_API_AVCTX_TIMEBASE    (LIBAVCODEC_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_CODED_FRAME
 #define FF_API_CODED_FRAME       (LIBAVCODEC_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_SIDEDATA_ONLY_PKT
 #define FF_API_SIDEDATA_ONLY_PKT (LIBAVCODEC_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_VDPAU_PROFILE
 #define FF_API_VDPAU_PROFILE     (LIBAVCODEC_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_CONVERGENCE_DURATION
 #define FF_API_CONVERGENCE_DURATION (LIBAVCODEC_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_AVPICTURE
 #define FF_API_AVPICTURE         (LIBAVCODEC_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_AVPACKET_OLD_API
 #define FF_API_AVPACKET_OLD_API (LIBAVCODEC_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_RTP_CALLBACK
 #define FF_API_RTP_CALLBACK      (LIBAVCODEC_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_VBV_DELAY
 #define FF_API_VBV_DELAY         (LIBAVCODEC_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_CODER_TYPE
 #define FF_API_CODER_TYPE        (LIBAVCODEC_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_STAT_BITS
 #define FF_API_STAT_BITS         (LIBAVCODEC_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_PRIVATE_OPT
 #define FF_API_PRIVATE_OPT      (LIBAVCODEC_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_ASS_TIMING
 #define FF_API_ASS_TIMING       (LIBAVCODEC_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_OLD_BSF
 #define FF_API_OLD_BSF          (LIBAVCODEC_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_COPY_CONTEXT
 #define FF_API_COPY_CONTEXT     (LIBAVCODEC_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_GET_CONTEXT_DEFAULTS
 #define FF_API_GET_CONTEXT_DEFAULTS (LIBAVCODEC_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_NVENC_OLD_NAME
 #define FF_API_NVENC_OLD_NAME    (LIBAVCODEC_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_STRUCT_VAAPI_CONTEXT
 #define FF_API_STRUCT_VAAPI_CONTEXT (LIBAVCODEC_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_MERGE_SD_API
 #define FF_API_MERGE_SD_API      (LIBAVCODEC_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_TAG_STRING
 #define FF_API_TAG_STRING        (LIBAVCODEC_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_GETCHROMA
 #define FF_API_GETCHROMA         (LIBAVCODEC_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_CODEC_GET_SET
 #define FF_API_CODEC_GET_SET     (LIBAVCODEC_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_USER_VISIBLE_AVHWACCEL
 #define FF_API_USER_VISIBLE_AVHWACCEL (LIBAVCODEC_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_LOCKMGR
 #define FF_API_LOCKMGR (LIBAVCODEC_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_NEXT
 #define FF_API_NEXT              (LIBAVCODEC_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_UNSANITIZED_BITRATES
 #define FF_API_UNSANITIZED_BITRATES (LIBAVCODEC_VERSION_MAJOR < 59)
 #endif
 
 
 #endif /* AVCODEC_VERSION_H */
diff --git a/libavformat/riff.c b/libavformat/riff.c
index 394481becd..741a6515df 100644
--- a/libavformat/riff.c
+++ b/libavformat/riff.c
@@ -602,8 +602,9 @@ const struct AVCodecTag *avformat_get_riff_audio_tags(void)
 const AVCodecGuid ff_codec_wav_guids[] = {
     { AV_CODEC_ID_AC3,      { 0x2C, 0x80, 0x6D, 0xE0, 0x46, 0xDB, 0xCF, 0x11, 0xB4, 0xD1, 0x00, 0x80, 0x5F, 0x6C, 0xBB, 0xEA } },
     { AV_CODEC_ID_ATRAC3P,  { 0xBF, 0xAA, 0x23, 0xE9, 0x58, 0xCB, 0x71, 0x44, 0xA1, 0x19, 0xFF, 0xFA, 0x01, 0xE4, 0xCE, 0x62 } },
     { AV_CODEC_ID_ATRAC9,   { 0xD2, 0x42, 0xE1, 0x47, 0xBA, 0x36, 0x8D, 0x4D, 0x88, 0xFC, 0x61, 0x65, 0x4F, 0x8C, 0x83, 0x6C } },
     { AV_CODEC_ID_EAC3,     { 0xAF, 0x87, 0xFB, 0xA7, 0x02, 0x2D, 0xFB, 0x42, 0xA4, 0xD4, 0x05, 0xCD, 0x93, 0x84, 0x3B, 0xDD } },
     { AV_CODEC_ID_MP2,      { 0x2B, 0x80, 0x6D, 0xE0, 0x46, 0xDB, 0xCF, 0x11, 0xB4, 0xD1, 0x00, 0x80, 0x5F, 0x6C, 0xBB, 0xEA } },
+    { AV_CODEC_ID_ADPCM_AGM,{ 0x82, 0xEC, 0x1F, 0x6A, 0xCA, 0xDB, 0x19, 0x45, 0xBD, 0xE7, 0x56, 0xD3, 0xB3, 0xEF, 0x98, 0x1D } },
     { AV_CODEC_ID_NONE }
 };
diff --git a/libavformat/version.h b/libavformat/version.h
index 495a6ee8e1..b611d4d75f 100644
--- a/libavformat/version.h
+++ b/libavformat/version.h
@@ -1,114 +1,114 @@
 /*
  * Version macros.
  *
  * This file is part of FFmpeg.
  *
  * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
  * version 2.1 of the License, or (at your option) any later version.
  *
  * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
  * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
 #ifndef AVFORMAT_VERSION_H
 #define AVFORMAT_VERSION_H
 
 /**
  * @file
  * @ingroup libavf
  * Libavformat version macros
  */
 
 #include "libavutil/version.h"
 
 // Major bumping may affect Ticket5467, 5421, 5451(compatibility with Chromium)
 // Also please add any ticket numbers that you believe might be affected here
 #define LIBAVFORMAT_VERSION_MAJOR  58
 #define LIBAVFORMAT_VERSION_MINOR  27
-#define LIBAVFORMAT_VERSION_MICRO 100
+#define LIBAVFORMAT_VERSION_MICRO 101
 
 #define LIBAVFORMAT_VERSION_INT AV_VERSION_INT(LIBAVFORMAT_VERSION_MAJOR, \
                                                LIBAVFORMAT_VERSION_MINOR, \
                                                LIBAVFORMAT_VERSION_MICRO)
 #define LIBAVFORMAT_VERSION     AV_VERSION(LIBAVFORMAT_VERSION_MAJOR,   \
                                            LIBAVFORMAT_VERSION_MINOR,   \
                                            LIBAVFORMAT_VERSION_MICRO)
 #define LIBAVFORMAT_BUILD       LIBAVFORMAT_VERSION_INT
 
 #define LIBAVFORMAT_IDENT       "Lavf" AV_STRINGIFY(LIBAVFORMAT_VERSION)
 
 /**
  * FF_API_* defines may be placed below to indicate public API that will be
  * dropped at a future version bump. The defines themselves are not part of
  * the public API and may change, break or disappear at any time.
  *
  * @note, when bumping the major version it is recommended to manually
  * disable each FF_API_* in its own commit instead of disabling them all
  * at once through the bump. This improves the git bisect-ability of the change.
  *
  */
 #ifndef FF_API_COMPUTE_PKT_FIELDS2
 #define FF_API_COMPUTE_PKT_FIELDS2      (LIBAVFORMAT_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_OLD_OPEN_CALLBACKS
 #define FF_API_OLD_OPEN_CALLBACKS       (LIBAVFORMAT_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_LAVF_AVCTX
 #define FF_API_LAVF_AVCTX               (LIBAVFORMAT_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_HTTP_USER_AGENT
 #define FF_API_HTTP_USER_AGENT          (LIBAVFORMAT_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_HLS_WRAP
 #define FF_API_HLS_WRAP                 (LIBAVFORMAT_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_HLS_USE_LOCALTIME
 #define FF_API_HLS_USE_LOCALTIME        (LIBAVFORMAT_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_LAVF_KEEPSIDE_FLAG
 #define FF_API_LAVF_KEEPSIDE_FLAG       (LIBAVFORMAT_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_OLD_ROTATE_API
 #define FF_API_OLD_ROTATE_API           (LIBAVFORMAT_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_FORMAT_GET_SET
 #define FF_API_FORMAT_GET_SET           (LIBAVFORMAT_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_OLD_AVIO_EOF_0
 #define FF_API_OLD_AVIO_EOF_0           (LIBAVFORMAT_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_LAVF_FFSERVER
 #define FF_API_LAVF_FFSERVER            (LIBAVFORMAT_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_FORMAT_FILENAME
 #define FF_API_FORMAT_FILENAME          (LIBAVFORMAT_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_OLD_RTSP_OPTIONS
 #define FF_API_OLD_RTSP_OPTIONS         (LIBAVFORMAT_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_NEXT
 #define FF_API_NEXT                     (LIBAVFORMAT_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_DASH_MIN_SEG_DURATION
 #define FF_API_DASH_MIN_SEG_DURATION    (LIBAVFORMAT_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_LAVF_MP4A_LATM
 #define FF_API_LAVF_MP4A_LATM           (LIBAVFORMAT_VERSION_MAJOR < 59)
 #endif
 #ifndef FF_API_AVIOFORMAT
 #define FF_API_AVIOFORMAT               (LIBAVFORMAT_VERSION_MAJOR < 59)
 #endif
 
 
 #ifndef FF_API_R_FRAME_RATE
 #define FF_API_R_FRAME_RATE            1
 #endif
 #endif /* AVFORMAT_VERSION_H */
