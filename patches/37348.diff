commit 829b0f33531b3c14b2e08331b8cc5b31fed73129
Merge: 280366ba6 915550ab1
Author: Behdad Esfahbod <behdad@behdad.org>
Date:   Fri Aug 20 01:28:15 2021 -0600

    Merge pull request #3154 from harfbuzz/set-invert
    
    Resurrect hb_set_invert()

diff --git a/docs/harfbuzz-sections.txt b/docs/harfbuzz-sections.txt
index ac28b3422..543f5d6c7 100644
--- a/docs/harfbuzz-sections.txt
+++ b/docs/harfbuzz-sections.txt
@@ -195,7 +195,6 @@ HB_OT_VAR_NO_AXIS_INDEX
 hb_ot_var_axis_t
 hb_ot_var_find_axis
 hb_ot_var_get_axes
-hb_set_invert
 hb_unicode_eastasian_width_func_t
 hb_unicode_eastasian_width
 hb_unicode_funcs_set_eastasian_width_func
@@ -614,6 +613,7 @@ hb_set_get_population
 hb_set_get_user_data
 hb_set_has
 hb_set_intersect
+hb_set_invert
 hb_set_is_empty
 hb_set_is_equal
 hb_set_is_subset
diff --git a/src/Makefile.sources b/src/Makefile.sources
index f5717a67a..28fbf2c52 100644
--- a/src/Makefile.sources
+++ b/src/Makefile.sources
@@ -3,172 +3,175 @@
 HB_BASE_sources = \
 	hb-aat-layout-ankr-table.hh \
 	hb-aat-layout-bsln-table.hh \
 	hb-aat-layout-common.hh \
 	hb-aat-layout-feat-table.hh \
 	hb-aat-layout-just-table.hh \
 	hb-aat-layout-kerx-table.hh \
 	hb-aat-layout-morx-table.hh \
 	hb-aat-layout-opbd-table.hh \
 	hb-aat-layout-trak-table.hh \
 	hb-aat-layout.cc \
 	hb-aat-layout.hh \
 	hb-aat-ltag-table.hh \
 	hb-aat-map.cc \
 	hb-aat-map.hh \
 	hb-algs.hh \
 	hb-array.hh \
 	hb-atomic.hh \
 	hb-bimap.hh \
+	hb-bit-page.hh \
+	hb-bit-set.hh \
+	hb-bit-set-invertible.hh \
 	hb-blob.cc \
 	hb-blob.hh \
 	hb-buffer-serialize.cc \
 	hb-buffer.cc \
 	hb-buffer.hh \
 	hb-cache.hh \
 	hb-cff-interp-common.hh \
 	hb-cff-interp-cs-common.hh \
 	hb-cff-interp-dict-common.hh \
 	hb-cff1-interp-cs.hh \
 	hb-cff2-interp-cs.hh \
 	hb-common.cc \
 	hb-config.hh \
 	hb-debug.hh \
 	hb-dispatch.hh \
 	hb-draw.cc \
 	hb-draw.hh \
 	hb-face.cc \
 	hb-face.hh \
 	hb-fallback-shape.cc \
 	hb-font.cc \
 	hb-font.hh \
 	hb-iter.hh \
 	hb-kern.hh \
 	hb-machinery.hh \
 	hb-map.cc \
 	hb-map.hh \
 	hb-meta.hh \
 	hb-ms-feature-ranges.cc \
 	hb-ms-feature-ranges.hh \
 	hb-mutex.hh \
 	hb-null.hh \
 	hb-number.cc \
 	hb-number.hh \
 	hb-object.hh \
 	hb-open-file.hh \
 	hb-open-type.hh \
 	hb-ot-cff-common.hh \
 	hb-ot-cff1-std-str.hh \
 	hb-ot-cff1-table.cc \
 	hb-ot-cff1-table.hh \
 	hb-ot-cff2-table.cc \
 	hb-ot-cff2-table.hh \
 	hb-ot-cmap-table.hh \
 	hb-ot-color-cbdt-table.hh \
 	hb-ot-color-colr-table.hh \
 	hb-ot-color-cpal-table.hh \
 	hb-ot-color-sbix-table.hh \
 	hb-ot-color-svg-table.hh \
 	hb-ot-color.cc \
 	hb-ot-face-table-list.hh \
 	hb-ot-face.cc \
 	hb-ot-face.hh \
 	hb-ot-font.cc \
 	hb-ot-gasp-table.hh \
 	hb-ot-glyf-table.hh \
 	hb-ot-hdmx-table.hh \
 	hb-ot-head-table.hh \
 	hb-ot-hhea-table.hh \
 	hb-ot-hmtx-table.hh \
 	hb-ot-kern-table.hh \
 	hb-ot-layout-base-table.hh \
 	hb-ot-layout-common.hh \
 	hb-ot-layout-gdef-table.hh \
 	hb-ot-layout-gpos-table.hh \
 	hb-ot-layout-gsub-table.hh \
 	hb-ot-layout-gsubgpos.hh \
 	hb-ot-layout-jstf-table.hh \
 	hb-ot-layout.cc \
 	hb-ot-layout.hh \
 	hb-ot-map.cc \
 	hb-ot-map.hh \
 	hb-ot-math-table.hh \
 	hb-ot-math.cc \
 	hb-ot-maxp-table.hh \
 	hb-ot-meta-table.hh \
 	hb-ot-meta.cc \
 	hb-ot-metrics.cc \
 	hb-ot-metrics.hh \
 	hb-ot-name-language-static.hh \
 	hb-ot-name-language.hh \
 	hb-ot-name-table.hh \
 	hb-ot-name.cc \
 	hb-ot-os2-table.hh \
 	hb-ot-os2-unicode-ranges.hh \
 	hb-ot-post-macroman.hh \
 	hb-ot-post-table.hh \
 	hb-ot-shape-complex-arabic-fallback.hh \
 	hb-ot-shape-complex-arabic-joining-list.hh \
 	hb-ot-shape-complex-arabic-table.hh \
 	hb-ot-shape-complex-arabic-win1256.hh \
 	hb-ot-shape-complex-arabic.cc \
 	hb-ot-shape-complex-arabic.hh \
 	hb-ot-shape-complex-default.cc \
 	hb-ot-shape-complex-hangul.cc \
 	hb-ot-shape-complex-hebrew.cc \
 	hb-ot-shape-complex-indic-table.cc \
 	hb-ot-shape-complex-indic.cc \
 	hb-ot-shape-complex-indic.hh \
 	hb-ot-shape-complex-khmer.cc \
 	hb-ot-shape-complex-khmer.hh \
 	hb-ot-shape-complex-myanmar.cc \
 	hb-ot-shape-complex-myanmar.hh \
 	hb-ot-shape-complex-syllabic.cc \
 	hb-ot-shape-complex-syllabic.hh \
 	hb-ot-shape-complex-thai.cc \
 	hb-ot-shape-complex-use-table.hh \
 	hb-ot-shape-complex-use.cc \
 	hb-ot-shape-complex-vowel-constraints.cc \
 	hb-ot-shape-complex-vowel-constraints.hh \
 	hb-ot-shape-complex.hh \
 	hb-ot-shape-fallback.cc \
 	hb-ot-shape-fallback.hh \
 	hb-ot-shape-normalize.cc \
 	hb-ot-shape-normalize.hh \
 	hb-ot-shape.cc \
 	hb-ot-shape.hh \
 	hb-ot-stat-table.hh \
 	hb-ot-tag-table.hh \
 	hb-ot-tag.cc \
 	hb-ot-var-avar-table.hh \
 	hb-ot-var-fvar-table.hh \
 	hb-ot-var-gvar-table.hh \
 	hb-ot-var-hvar-table.hh \
 	hb-ot-var-mvar-table.hh \
 	hb-ot-var.cc \
 	hb-ot-vorg-table.hh \
 	hb-pool.hh \
 	hb-sanitize.hh \
 	hb-serialize.hh \
 	hb-set-digest.hh \
 	hb-set.cc \
 	hb-set.hh \
 	hb-shape-plan.cc \
 	hb-shape-plan.hh \
 	hb-shape.cc \
 	hb-shaper-impl.hh \
 	hb-shaper-list.hh \
 	hb-shaper.cc \
 	hb-shaper.hh \
 	hb-static.cc \
 	hb-string-array.hh \
 	hb-style.cc \
 	hb-ucd-table.hh \
 	hb-ucd.cc \
 	hb-unicode-emoji-table.hh \
 	hb-unicode.cc \
 	hb-unicode.hh \
 	hb-utf.hh \
 	hb-vector.hh \
 	hb-priority-queue.hh \
 	hb.hh \
 	$(NULL)
diff --git a/src/hb-algs.hh b/src/hb-algs.hh
index 57b87b05c..bbe097fe0 100644
--- a/src/hb-algs.hh
+++ b/src/hb-algs.hh
@@ -1159,30 +1159,48 @@ hb_codepoint_parse (const char *s, unsigned int len, int base, hb_codepoint_t *o
 
 /* Operators. */
 
-struct hb_bitwise_and
+struct
 { HB_PARTIALIZE(2);
   template <typename T> constexpr auto
   operator () (const T &a, const T &b) const HB_AUTO_RETURN (a & b)
 }
 HB_FUNCOBJ (hb_bitwise_and);
-struct hb_bitwise_or
+struct
 { HB_PARTIALIZE(2);
   template <typename T> constexpr auto
   operator () (const T &a, const T &b) const HB_AUTO_RETURN (a | b)
 }
 HB_FUNCOBJ (hb_bitwise_or);
-struct hb_bitwise_xor
+struct
 { HB_PARTIALIZE(2);
   template <typename T> constexpr auto
   operator () (const T &a, const T &b) const HB_AUTO_RETURN (a ^ b)
 }
 HB_FUNCOBJ (hb_bitwise_xor);
-struct hb_bitwise_sub
+struct
+{ HB_PARTIALIZE(2);
+  template <typename T> constexpr auto
+  operator () (const T &a, const T &b) const HB_AUTO_RETURN (~a & b)
+}
+HB_FUNCOBJ (hb_bitwise_lt);
+struct
 { HB_PARTIALIZE(2);
   template <typename T> constexpr auto
   operator () (const T &a, const T &b) const HB_AUTO_RETURN (a & ~b)
 }
-HB_FUNCOBJ (hb_bitwise_sub);
+HB_FUNCOBJ (hb_bitwise_gt); // aka sub
+struct
+{ HB_PARTIALIZE(2);
+  template <typename T> constexpr auto
+  operator () (const T &a, const T &b) const HB_AUTO_RETURN (~a | b)
+}
+HB_FUNCOBJ (hb_bitwise_le);
+struct
+{ HB_PARTIALIZE(2);
+  template <typename T> constexpr auto
+  operator () (const T &a, const T &b) const HB_AUTO_RETURN (a | ~b)
+}
+HB_FUNCOBJ (hb_bitwise_ge);
 struct
 {
   template <typename T> constexpr auto
@@ -1203,7 +1221,13 @@ struct
 }
 HB_FUNCOBJ (hb_sub);
 struct
+{ HB_PARTIALIZE(2);
+  template <typename T, typename T2> constexpr auto
+  operator () (const T &a, const T2 &b) const HB_AUTO_RETURN (b - a)
+}
+HB_FUNCOBJ (hb_rsub);
+struct
 { HB_PARTIALIZE(2);
   template <typename T, typename T2> constexpr auto
   operator () (const T &a, const T2 &b) const HB_AUTO_RETURN (a * b)
 }
diff --git a/src/hb-bit-page.hh b/src/hb-bit-page.hh
new file mode 100644
index 000000000..263be3d04
--- /dev/null
+++ b/src/hb-bit-page.hh
@@ -0,0 +1,203 @@
+/*
+ * Copyright © 2012,2017  Google, Inc.
+ * Copyright © 2021 Behdad Esfahbod
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_BIT_PAGE_HH
+#define HB_BIT_PAGE_HH
+
+#include "hb.hh"
+
+struct hb_bit_page_t
+{
+  void init0 () { v.clear (); }
+  void init1 () { v.clear (0xFF); }
+
+  constexpr unsigned len () const
+  { return ARRAY_LENGTH_CONST (v); }
+
+  bool is_empty () const
+  {
+    for (unsigned int i = 0; i < len (); i++)
+      if (v[i])
+	return false;
+    return true;
+  }
+
+  void add (hb_codepoint_t g) { elt (g) |= mask (g); }
+  void del (hb_codepoint_t g) { elt (g) &= ~mask (g); }
+  void set (hb_codepoint_t g, bool v) { if (v) add (g); else del (g); }
+  bool get (hb_codepoint_t g) const { return elt (g) & mask (g); }
+
+  void add_range (hb_codepoint_t a, hb_codepoint_t b)
+  {
+    elt_t *la = &elt (a);
+    elt_t *lb = &elt (b);
+    if (la == lb)
+      *la |= (mask (b) << 1) - mask(a);
+    else
+    {
+      *la |= ~(mask (a) - 1);
+      la++;
+
+      memset (la, 0xff, (char *) lb - (char *) la);
+
+      *lb |= ((mask (b) << 1) - 1);
+    }
+  }
+  void del_range (hb_codepoint_t a, hb_codepoint_t b)
+  {
+    elt_t *la = &elt (a);
+    elt_t *lb = &elt (b);
+    if (la == lb)
+      *la &= ~((mask (b) << 1) - mask(a));
+    else
+    {
+      *la &= mask (a) - 1;
+      la++;
+
+      memset (la, 0, (char *) lb - (char *) la);
+
+      *lb &= ~((mask (b) << 1) - 1);
+    }
+  }
+  void set_range (hb_codepoint_t a, hb_codepoint_t b, bool v)
+  { if (v) add_range (a, b); else del_range (a, b); }
+
+  bool is_equal (const hb_bit_page_t &other) const
+  {
+    return 0 == hb_memcmp (&v, &other.v, sizeof (v));
+  }
+  bool is_subset (const hb_bit_page_t &larger_page) const
+  {
+    for (unsigned i = 0; i < len (); i++)
+      if (~larger_page.v[i] & v[i])
+	return false;
+    return true;
+  }
+
+  unsigned int get_population () const
+  {
+    unsigned int pop = 0;
+    for (unsigned int i = 0; i < len (); i++)
+      pop += hb_popcount (v[i]);
+    return pop;
+  }
+
+  bool next (hb_codepoint_t *codepoint) const
+  {
+    unsigned int m = (*codepoint + 1) & MASK;
+    if (!m)
+    {
+      *codepoint = INVALID;
+      return false;
+    }
+    unsigned int i = m / ELT_BITS;
+    unsigned int j = m & ELT_MASK;
+
+    const elt_t vv = v[i] & ~((elt_t (1) << j) - 1);
+    for (const elt_t *p = &vv; i < len (); p = &v[++i])
+      if (*p)
+      {
+	*codepoint = i * ELT_BITS + elt_get_min (*p);
+	return true;
+      }
+
+    *codepoint = INVALID;
+    return false;
+  }
+  bool previous (hb_codepoint_t *codepoint) const
+  {
+    unsigned int m = (*codepoint - 1) & MASK;
+    if (m == MASK)
+    {
+      *codepoint = INVALID;
+      return false;
+    }
+    unsigned int i = m / ELT_BITS;
+    unsigned int j = m & ELT_MASK;
+
+    /* Fancy mask to avoid shifting by elt_t bitsize, which is undefined. */
+    const elt_t mask = j < 8 * sizeof (elt_t) - 1 ?
+		       ((elt_t (1) << (j + 1)) - 1) :
+		       (elt_t) -1;
+    const elt_t vv = v[i] & mask;
+    const elt_t *p = &vv;
+    while (true)
+    {
+      if (*p)
+      {
+	*codepoint = i * ELT_BITS + elt_get_max (*p);
+	return true;
+      }
+      if ((int) i <= 0) break;
+      p = &v[--i];
+    }
+
+    *codepoint = INVALID;
+    return false;
+  }
+  hb_codepoint_t get_min () const
+  {
+    for (unsigned int i = 0; i < len (); i++)
+      if (v[i])
+	return i * ELT_BITS + elt_get_min (v[i]);
+    return INVALID;
+  }
+  hb_codepoint_t get_max () const
+  {
+    for (int i = len () - 1; i >= 0; i--)
+      if (v[i])
+	return i * ELT_BITS + elt_get_max (v[i]);
+    return 0;
+  }
+
+  static constexpr hb_codepoint_t INVALID = HB_SET_VALUE_INVALID;
+
+  typedef unsigned long long elt_t;
+  static constexpr unsigned PAGE_BITS = 512;
+  static_assert ((PAGE_BITS & ((PAGE_BITS) - 1)) == 0, "");
+
+  static unsigned int elt_get_min (const elt_t &elt) { return hb_ctz (elt); }
+  static unsigned int elt_get_max (const elt_t &elt) { return hb_bit_storage (elt) - 1; }
+
+  typedef hb_vector_size_t<elt_t, PAGE_BITS / 8> vector_t;
+
+  static constexpr unsigned ELT_BITS = sizeof (elt_t) * 8;
+  static constexpr unsigned ELT_MASK = ELT_BITS - 1;
+  static constexpr unsigned BITS = sizeof (vector_t) * 8;
+  static constexpr unsigned MASK = BITS - 1;
+  static_assert ((unsigned) PAGE_BITS == (unsigned) BITS, "");
+
+  elt_t &elt (hb_codepoint_t g) { return v[(g & MASK) / ELT_BITS]; }
+  const elt_t& elt (hb_codepoint_t g) const { return v[(g & MASK) / ELT_BITS]; }
+  static constexpr elt_t mask (hb_codepoint_t g) { return elt_t (1) << (g & ELT_MASK); }
+
+  vector_t v;
+};
+static_assert (hb_bit_page_t::PAGE_BITS == sizeof (hb_bit_page_t) * 8, "");
+
+
+#endif /* HB_BIT_PAGE_HH */
diff --git a/src/hb-bit-set-invertible.hh b/src/hb-bit-set-invertible.hh
new file mode 100644
index 000000000..ab48239bb
--- /dev/null
+++ b/src/hb-bit-set-invertible.hh
@@ -0,0 +1,332 @@
+/*
+ * Copyright © 2012,2017  Google, Inc.
+ * Copyright © 2021 Behdad Esfahbod
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_BIT_SET_INVERTIBLE_HH
+#define HB_BIT_SET_INVERTIBLE_HH
+
+#include "hb.hh"
+#include "hb-bit-set.hh"
+
+
+struct hb_bit_set_invertible_t
+{
+  hb_bit_set_t s;
+  bool inverted;
+
+  hb_bit_set_invertible_t () { init (); }
+  ~hb_bit_set_invertible_t () { fini (); }
+
+  void init () { s.init (); inverted = false; }
+  void fini () { s.fini (); }
+  void err () { s.err (); }
+  bool in_error () const { return s.in_error (); }
+  explicit operator bool () const { return !is_empty (); }
+
+  void reset () { s.reset (); inverted = false; }
+  void clear () { s.clear (); inverted = false; }
+  void invert () { inverted = !inverted; }
+
+  bool is_empty () const
+  {
+    hb_codepoint_t v = INVALID;
+    next (&v);
+    return v == INVALID;
+  }
+  hb_codepoint_t get_min () const
+  {
+    hb_codepoint_t v = INVALID;
+    next (&v);
+    return v;
+  }
+  hb_codepoint_t get_max () const
+  {
+    hb_codepoint_t v = INVALID;
+    previous (&v);
+    return v;
+  }
+  unsigned int get_population () const
+  { return inverted ? INVALID - s.get_population () : s.get_population (); }
+
+
+  void add (hb_codepoint_t g) { unlikely (inverted) ? s.del (g) : s.add (g); }
+  bool add_range (hb_codepoint_t a, hb_codepoint_t b)
+  { return unlikely (inverted) ? (s.del_range (a, b), true) : s.add_range (a, b); }
+
+  template <typename T>
+  void add_array (const T *array, unsigned int count, unsigned int stride=sizeof(T))
+  { inverted ? s.del_array (array, count, stride) : s.add_array (array, count, stride); }
+  template <typename T>
+  void add_array (const hb_array_t<const T>& arr) { add_array (&arr, arr.len ()); }
+
+  /* Might return false if array looks unsorted.
+   * Used for faster rejection of corrupt data. */
+  template <typename T>
+  bool add_sorted_array (const T *array, unsigned int count, unsigned int stride=sizeof(T))
+  { return inverted ? s.del_sorted_array (array, count, stride) : s.add_sorted_array (array, count, stride); }
+  template <typename T>
+  bool add_sorted_array (const hb_sorted_array_t<const T>& arr) { return add_sorted_array (&arr, arr.len ()); }
+
+  void del (hb_codepoint_t g) { unlikely (inverted) ? s.add (g) : s.del (g); }
+  void del_range (hb_codepoint_t a, hb_codepoint_t b)
+  { unlikely (inverted) ? (void) s.add_range (a, b) : s.del_range (a, b); }
+
+  bool get (hb_codepoint_t g) const { return s.get (g) ^ inverted; }
+
+  /* Has interface. */
+  static constexpr bool SENTINEL = false;
+  typedef bool value_t;
+  value_t operator [] (hb_codepoint_t k) const { return get (k); }
+  bool has (hb_codepoint_t k) const { return (*this)[k] != SENTINEL; }
+  /* Predicate. */
+  bool operator () (hb_codepoint_t k) const { return has (k); }
+
+  /* Sink interface. */
+  hb_bit_set_invertible_t& operator << (hb_codepoint_t v)
+  { add (v); return *this; }
+  hb_bit_set_invertible_t& operator << (const hb_pair_t<hb_codepoint_t, hb_codepoint_t>& range)
+  { add_range (range.first, range.second); return *this; }
+
+  bool intersects (hb_codepoint_t first, hb_codepoint_t last) const
+  {
+    hb_codepoint_t c = first - 1;
+    return next (&c) && c <= last;
+  }
+
+  void set (const hb_bit_set_invertible_t &other) { s.set (other.s); inverted = other.inverted; }
+
+  bool is_equal (const hb_bit_set_invertible_t &other) const
+  {
+    if (likely (inverted == other.inverted))
+      return s.is_equal (other.s);
+    else
+    {
+      /* TODO Add iter_ranges() and use here. */
+      auto it1 = iter ();
+      auto it2 = other.iter ();
+      return hb_all (+ hb_zip (it1, it2)
+		     | hb_map ([](hb_pair_t<hb_codepoint_t, hb_codepoint_t> _) { return _.first == _.second; }));
+    }
+  }
+
+  bool is_subset (const hb_bit_set_invertible_t &larger_set) const
+  {
+    if (unlikely (inverted != larger_set.inverted))
+      return hb_all (hb_iter (s) | hb_map (larger_set.s));
+    else
+      return unlikely (inverted) ? larger_set.s.is_subset (s) : s.is_subset (larger_set.s);
+  }
+
+  protected:
+  template <typename Op>
+  void process (const Op& op, const hb_bit_set_invertible_t &other)
+  { s.process (op, other.s); }
+  public:
+  void union_ (const hb_bit_set_invertible_t &other)
+  {
+    if (likely (inverted == other.inverted))
+    {
+      if (unlikely (inverted))
+	process (hb_bitwise_and, other);
+      else
+	process (hb_bitwise_or, other); /* Main branch. */
+    }
+    else
+    {
+      if (unlikely (inverted))
+	process (hb_bitwise_gt, other);
+      else
+	process (hb_bitwise_lt, other);
+    }
+    inverted = inverted || other.inverted;
+  }
+  void intersect (const hb_bit_set_invertible_t &other)
+  {
+    if (likely (inverted == other.inverted))
+    {
+      if (unlikely (inverted))
+	process (hb_bitwise_or, other);
+      else
+	process (hb_bitwise_and, other); /* Main branch. */
+    }
+    else
+    {
+      if (unlikely (inverted))
+	process (hb_bitwise_lt, other);
+      else
+	process (hb_bitwise_gt, other);
+    }
+    inverted = inverted && other.inverted;
+  }
+  void subtract (const hb_bit_set_invertible_t &other)
+  {
+    if (likely (inverted == other.inverted))
+    {
+      if (unlikely (inverted))
+	process (hb_bitwise_lt, other);
+      else
+	process (hb_bitwise_gt, other); /* Main branch. */
+    }
+    else
+    {
+      if (unlikely (inverted))
+	process (hb_bitwise_or, other);
+      else
+	process (hb_bitwise_and, other);
+    }
+    inverted = inverted && !other.inverted;
+  }
+  void symmetric_difference (const hb_bit_set_invertible_t &other)
+  {
+    process (hb_bitwise_xor, other);
+    inverted = inverted ^ other.inverted;
+  }
+
+  bool next (hb_codepoint_t *codepoint) const
+  {
+    if (likely (!inverted))
+      return s.next (codepoint);
+
+    auto old = *codepoint;
+    if (unlikely (old + 1 == INVALID))
+    {
+      *codepoint = INVALID;
+      return false;
+    }
+
+    auto v = old;
+    s.next (&v);
+    if (old + 1 < v)
+    {
+      *codepoint = old + 1;
+      return true;
+    }
+
+    v = old;
+    s.next_range (&old, &v);
+
+    *codepoint = v + 1;
+    return *codepoint != INVALID;
+  }
+  bool previous (hb_codepoint_t *codepoint) const
+  {
+    if (likely (!inverted))
+      return s.previous (codepoint);
+
+    auto old = *codepoint;
+    if (unlikely (old - 1 == INVALID))
+    {
+      *codepoint = INVALID;
+      return false;
+    }
+
+    auto v = old;
+    s.previous (&v);
+
+    if (old - 1 > v || v == INVALID)
+    {
+      *codepoint = old - 1;
+      return true;
+    }
+
+    v = old;
+    s.previous_range (&v, &old);
+
+    *codepoint = v - 1;
+    return *codepoint != INVALID;
+  }
+  bool next_range (hb_codepoint_t *first, hb_codepoint_t *last) const
+  {
+    if (likely (!inverted))
+      return s.next_range (first, last);
+
+    if (!next (last))
+    {
+      *last = *first = INVALID;
+      return false;
+    }
+
+    *first = *last;
+    s.next (last);
+    --*last;
+    return true;
+  }
+  bool previous_range (hb_codepoint_t *first, hb_codepoint_t *last) const
+  {
+    if (likely (!inverted))
+      return s.previous_range (first, last);
+
+    if (!previous (first))
+    {
+      *last = *first = INVALID;
+      return false;
+    }
+
+    *last = *first;
+    s.previous (first);
+    ++*first;
+    return true;
+  }
+
+  static constexpr hb_codepoint_t INVALID = hb_bit_set_t::INVALID;
+
+  /*
+   * Iterator implementation.
+   */
+  struct iter_t : hb_iter_with_fallback_t<iter_t, hb_codepoint_t>
+  {
+    static constexpr bool is_sorted_iterator = true;
+    iter_t (const hb_bit_set_invertible_t &s_ = Null (hb_bit_set_invertible_t),
+	    bool init = true) : s (&s_), v (INVALID), l(0)
+    {
+      if (init)
+      {
+	l = s->get_population () + 1;
+	__next__ ();
+      }
+    }
+
+    typedef hb_codepoint_t __item_t__;
+    hb_codepoint_t __item__ () const { return v; }
+    bool __more__ () const { return v != INVALID; }
+    void __next__ () { s->next (&v); if (l) l--; }
+    void __prev__ () { s->previous (&v); }
+    unsigned __len__ () const { return l; }
+    iter_t end () const { return iter_t (*s, false); }
+    bool operator != (const iter_t& o) const
+    { return s != o.s || v != o.v; }
+
+    protected:
+    const hb_bit_set_invertible_t *s;
+    hb_codepoint_t v;
+    unsigned l;
+  };
+  iter_t iter () const { return iter_t (*this); }
+  operator iter_t () const { return iter (); }
+};
+
+
+#endif /* HB_BIT_SET_INVERTIBLE_HH */
diff --git a/src/hb-bit-set.hh b/src/hb-bit-set.hh
new file mode 100644
index 000000000..6a305ff22
--- /dev/null
+++ b/src/hb-bit-set.hh
@@ -0,0 +1,810 @@
+/*
+ * Copyright © 2012,2017  Google, Inc.
+ * Copyright © 2021 Behdad Esfahbod
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_BIT_SET_HH
+#define HB_BIT_SET_HH
+
+#include "hb.hh"
+#include "hb-bit-page.hh"
+#include "hb-machinery.hh"
+
+
+struct hb_bit_set_t
+{
+  hb_bit_set_t () { init (); }
+  ~hb_bit_set_t () { fini (); }
+
+  void init ()
+  {
+    successful = true;
+    population = 0;
+    last_page_lookup = 0;
+    page_map.init ();
+    pages.init ();
+  }
+  void fini ()
+  {
+    page_map.fini ();
+    pages.fini ();
+  }
+
+  hb_bit_set_t (const hb_bit_set_t& other) : hb_bit_set_t () { set (other); }
+  void operator= (const hb_bit_set_t& other) { set (other); }
+  // TODO Add move construtor/assign
+  // TODO Add constructor for Iterator; with specialization for (sorted) vector / array?
+
+  using page_t = hb_bit_page_t;
+  struct page_map_t
+  {
+    int cmp (const page_map_t &o) const { return cmp (o.major); }
+    int cmp (uint32_t o_major) const { return (int) o_major - (int) major; }
+
+    uint32_t major;
+    uint32_t index;
+  };
+
+  bool successful; /* Allocations successful */
+  mutable unsigned int population;
+  mutable unsigned int last_page_lookup;
+  hb_sorted_vector_t<page_map_t> page_map;
+  hb_vector_t<page_t> pages;
+
+  void err () { if (successful) successful = false; } /* TODO Remove */
+  bool in_error () const { return !successful; }
+
+  bool resize (unsigned int count)
+  {
+    if (unlikely (count > pages.length && !successful)) return false;
+    if (!pages.resize (count) || !page_map.resize (count))
+    {
+      pages.resize (page_map.length);
+      successful = false;
+      return false;
+    }
+    return true;
+  }
+
+  void reset ()
+  {
+    successful = true;
+    clear ();
+  }
+
+  void clear ()
+  {
+    if (resize (0))
+      population = 0;
+  }
+  bool is_empty () const
+  {
+    unsigned int count = pages.length;
+    for (unsigned int i = 0; i < count; i++)
+      if (!pages[i].is_empty ())
+	return false;
+    return true;
+  }
+  explicit operator bool () const { return !is_empty (); }
+
+  private:
+  void dirty () { population = UINT_MAX; }
+  public:
+
+  void add (hb_codepoint_t g)
+  {
+    if (unlikely (!successful)) return;
+    if (unlikely (g == INVALID)) return;
+    dirty ();
+    page_t *page = page_for (g, true); if (unlikely (!page)) return;
+    page->add (g);
+  }
+  bool add_range (hb_codepoint_t a, hb_codepoint_t b)
+  {
+    if (unlikely (!successful)) return true; /* https://github.com/harfbuzz/harfbuzz/issues/657 */
+    if (unlikely (a > b || a == INVALID || b == INVALID)) return false;
+    dirty ();
+    unsigned int ma = get_major (a);
+    unsigned int mb = get_major (b);
+    if (ma == mb)
+    {
+      page_t *page = page_for (a, true); if (unlikely (!page)) return false;
+      page->add_range (a, b);
+    }
+    else
+    {
+      page_t *page = page_for (a, true); if (unlikely (!page)) return false;
+      page->add_range (a, major_start (ma + 1) - 1);
+
+      for (unsigned int m = ma + 1; m < mb; m++)
+      {
+	page = page_for (major_start (m), true); if (unlikely (!page)) return false;
+	page->init1 ();
+      }
+
+      page = page_for (b, true); if (unlikely (!page)) return false;
+      page->add_range (major_start (mb), b);
+    }
+    return true;
+  }
+
+  template <typename T>
+  void set_array (bool v, const T *array, unsigned int count, unsigned int stride=sizeof(T))
+  {
+    if (unlikely (!successful)) return;
+    if (!count) return;
+    dirty ();
+    hb_codepoint_t g = *array;
+    while (count)
+    {
+      unsigned int m = get_major (g);
+      page_t *page = page_for (g, v); if (unlikely (v && !page)) return;
+      unsigned int start = major_start (m);
+      unsigned int end = major_start (m + 1);
+      do
+      {
+        if (v || page) /* The v check is to optimize out the page check if v is true. */
+	  page->set (g, v);
+
+	array = &StructAtOffsetUnaligned<T> (array, stride);
+	count--;
+      }
+      while (count && (g = *array, start <= g && g < end));
+    }
+  }
+
+  template <typename T>
+  void add_array (const T *array, unsigned int count, unsigned int stride=sizeof(T))
+  { set_array (true, array, count, stride); }
+  template <typename T>
+  void add_array (const hb_array_t<const T>& arr) { add_array (&arr, arr.len ()); }
+
+  template <typename T>
+  void del_array (const T *array, unsigned int count, unsigned int stride=sizeof(T))
+  { set_array (false, array, count, stride); }
+  template <typename T>
+  void del_array (const hb_array_t<const T>& arr) { del_array (&arr, arr.len ()); }
+
+  /* Might return false if array looks unsorted.
+   * Used for faster rejection of corrupt data. */
+  template <typename T>
+  bool set_sorted_array (bool v, const T *array, unsigned int count, unsigned int stride=sizeof(T))
+  {
+    if (unlikely (!successful)) return true; /* https://github.com/harfbuzz/harfbuzz/issues/657 */
+    if (!count) return true;
+    dirty ();
+    hb_codepoint_t g = *array;
+    hb_codepoint_t last_g = g;
+    while (count)
+    {
+      unsigned int m = get_major (g);
+      page_t *page = page_for (g, v); if (unlikely (v && !page)) return false;
+      unsigned int end = major_start (m + 1);
+      do
+      {
+	/* If we try harder we can change the following comparison to <=;
+	 * Not sure if it's worth it. */
+	if (g < last_g) return false;
+	last_g = g;
+
+        if (v || page) /* The v check is to optimize out the page check if v is true. */
+	  page->add (g);
+
+	array = (const T *) ((const char *) array + stride);
+	count--;
+      }
+      while (count && (g = *array, g < end));
+    }
+    return true;
+  }
+
+  template <typename T>
+  bool add_sorted_array (const T *array, unsigned int count, unsigned int stride=sizeof(T))
+  { return set_sorted_array (true, array, count, stride); }
+  template <typename T>
+  bool add_sorted_array (const hb_sorted_array_t<const T>& arr) { return add_sorted_array (&arr, arr.len ()); }
+
+  template <typename T>
+  bool del_sorted_array (const T *array, unsigned int count, unsigned int stride=sizeof(T))
+  { return set_sorted_array (false, array, count, stride); }
+  template <typename T>
+  bool del_sorted_array (const hb_sorted_array_t<const T>& arr) { return del_sorted_array (&arr, arr.len ()); }
+
+  void del (hb_codepoint_t g)
+  {
+    if (unlikely (!successful)) return;
+    page_t *page = page_for (g);
+    if (!page)
+      return;
+    dirty ();
+    page->del (g);
+  }
+
+  private:
+  void del_pages (int ds, int de)
+  {
+    if (ds <= de)
+    {
+      // Pre-allocate the workspace that compact() will need so we can bail on allocation failure
+      // before attempting to rewrite the page map.
+      hb_vector_t<unsigned> compact_workspace;
+      if (unlikely (!allocate_compact_workspace (compact_workspace))) return;
+
+      unsigned int write_index = 0;
+      for (unsigned int i = 0; i < page_map.length; i++)
+      {
+	int m = (int) page_map[i].major;
+	if (m < ds || de < m)
+	  page_map[write_index++] = page_map[i];
+      }
+      compact (compact_workspace, write_index);
+      resize (write_index);
+    }
+  }
+
+
+  public:
+  void del_range (hb_codepoint_t a, hb_codepoint_t b)
+  {
+    if (unlikely (!successful)) return;
+    if (unlikely (a > b || a == INVALID)) return;
+    dirty ();
+    unsigned int ma = get_major (a);
+    unsigned int mb = get_major (b);
+    /* Delete pages from ds through de if ds <= de. */
+    int ds = (a == major_start (ma))? (int) ma: (int) (ma + 1);
+    int de = (b + 1 == major_start (mb + 1))? (int) mb: ((int) mb - 1);
+    if (ds > de || (int) ma < ds)
+    {
+      page_t *page = page_for (a);
+      if (page)
+      {
+	if (ma == mb)
+	  page->del_range (a, b);
+	else
+	  page->del_range (a, major_start (ma + 1) - 1);
+      }
+    }
+    if (de < (int) mb && ma != mb)
+    {
+      page_t *page = page_for (b);
+      if (page)
+	page->del_range (major_start (mb), b);
+    }
+    del_pages (ds, de);
+  }
+
+  bool get (hb_codepoint_t g) const
+  {
+    const page_t *page = page_for (g);
+    if (!page)
+      return false;
+    return page->get (g);
+  }
+
+  /* Has interface. */
+  static constexpr bool SENTINEL = false;
+  typedef bool value_t;
+  value_t operator [] (hb_codepoint_t k) const { return get (k); }
+  bool has (hb_codepoint_t k) const { return (*this)[k] != SENTINEL; }
+  /* Predicate. */
+  bool operator () (hb_codepoint_t k) const { return has (k); }
+
+  /* Sink interface. */
+  hb_bit_set_t& operator << (hb_codepoint_t v)
+  { add (v); return *this; }
+  hb_bit_set_t& operator << (const hb_pair_t<hb_codepoint_t, hb_codepoint_t>& range)
+  { add_range (range.first, range.second); return *this; }
+
+  bool intersects (hb_codepoint_t first, hb_codepoint_t last) const
+  {
+    hb_codepoint_t c = first - 1;
+    return next (&c) && c <= last;
+  }
+  void set (const hb_bit_set_t &other)
+  {
+    if (unlikely (!successful)) return;
+    unsigned int count = other.pages.length;
+    if (!resize (count))
+      return;
+    population = other.population;
+
+    hb_memcpy ((void *) pages, (const void *) other.pages, count * pages.item_size);
+    hb_memcpy ((void *) page_map, (const void *) other.page_map, count * page_map.item_size);
+  }
+
+  bool is_equal (const hb_bit_set_t &other) const
+  {
+    if (has_population () && other.has_population () &&
+	get_population () != other.get_population ())
+      return false;
+
+    unsigned int na = pages.length;
+    unsigned int nb = other.pages.length;
+
+    unsigned int a = 0, b = 0;
+    for (; a < na && b < nb; )
+    {
+      if (page_at (a).is_empty ()) { a++; continue; }
+      if (other.page_at (b).is_empty ()) { b++; continue; }
+      if (page_map[a].major != other.page_map[b].major ||
+	  !page_at (a).is_equal (other.page_at (b)))
+	return false;
+      a++;
+      b++;
+    }
+    for (; a < na; a++)
+      if (!page_at (a).is_empty ()) { return false; }
+    for (; b < nb; b++)
+      if (!other.page_at (b).is_empty ()) { return false; }
+
+    return true;
+  }
+
+  bool is_subset (const hb_bit_set_t &larger_set) const
+  {
+    if (has_population () && larger_set.has_population () &&
+	get_population () != larger_set.get_population ())
+      return false;
+
+    uint32_t spi = 0;
+    for (uint32_t lpi = 0; spi < page_map.length && lpi < larger_set.page_map.length; lpi++)
+    {
+      uint32_t spm = page_map[spi].major;
+      uint32_t lpm = larger_set.page_map[lpi].major;
+      auto sp = page_at (spi);
+      auto lp = larger_set.page_at (lpi);
+
+      if (spm < lpm && !sp.is_empty ())
+        return false;
+
+      if (lpm < spm)
+        continue;
+
+      if (!sp.is_subset (lp))
+        return false;
+
+      spi++;
+    }
+
+    while (spi < page_map.length)
+      if (!page_at (spi++).is_empty ())
+        return false;
+
+    return true;
+  }
+
+  private:
+  bool allocate_compact_workspace (hb_vector_t<unsigned>& workspace)
+  {
+    if (unlikely (!workspace.resize (pages.length)))
+    {
+      successful = false;
+      return false;
+    }
+
+    return true;
+  }
+
+  /*
+   * workspace should be a pre-sized vector allocated to hold at exactly pages.length
+   * elements.
+   */
+  void compact (hb_vector_t<unsigned>& workspace,
+                unsigned int length)
+  {
+    assert(workspace.length == pages.length);
+    hb_vector_t<unsigned>& old_index_to_page_map_index = workspace;
+
+    hb_fill (old_index_to_page_map_index.writer(), 0xFFFFFFFF);
+    for (unsigned i = 0; i < length; i++)
+      old_index_to_page_map_index[page_map[i].index] =  i;
+
+    compact_pages (old_index_to_page_map_index);
+  }
+  void compact_pages (const hb_vector_t<unsigned>& old_index_to_page_map_index)
+  {
+    unsigned int write_index = 0;
+    for (unsigned int i = 0; i < pages.length; i++)
+    {
+      if (old_index_to_page_map_index[i] == 0xFFFFFFFF) continue;
+
+      if (write_index < i)
+	pages[write_index] = pages[i];
+
+      page_map[old_index_to_page_map_index[i]].index = write_index;
+      write_index++;
+    }
+  }
+  public:
+
+  template <typename Op>
+  void process (const Op& op, const hb_bit_set_t &other)
+  {
+    const bool passthru_left = op (1, 0);
+    const bool passthru_right = op (0, 1);
+
+    if (unlikely (!successful)) return;
+
+    dirty ();
+
+    unsigned int na = pages.length;
+    unsigned int nb = other.pages.length;
+    unsigned int next_page = na;
+
+    unsigned int count = 0, newCount = 0;
+    unsigned int a = 0, b = 0;
+    unsigned int write_index = 0;
+
+    // Pre-allocate the workspace that compact() will need so we can bail on allocation failure
+    // before attempting to rewrite the page map.
+    hb_vector_t<unsigned> compact_workspace;
+    if (!passthru_left && unlikely (!allocate_compact_workspace (compact_workspace))) return;
+
+    for (; a < na && b < nb; )
+    {
+      if (page_map[a].major == other.page_map[b].major)
+      {
+	if (!passthru_left)
+	{
+	  // Move page_map entries that we're keeping from the left side set
+	  // to the front of the page_map vector. This isn't necessary if
+	  // passthru_left is set since no left side pages will be removed
+	  // in that case.
+	  if (write_index < a)
+	    page_map[write_index] = page_map[a];
+	  write_index++;
+	}
+
+	count++;
+	a++;
+	b++;
+      }
+      else if (page_map[a].major < other.page_map[b].major)
+      {
+	if (passthru_left)
+	  count++;
+	a++;
+      }
+      else
+      {
+	if (passthru_right)
+	  count++;
+	b++;
+      }
+    }
+    if (passthru_left)
+      count += na - a;
+    if (passthru_right)
+      count += nb - b;
+
+    if (!passthru_left)
+    {
+      na  = write_index;
+      next_page = write_index;
+      compact (compact_workspace, write_index);
+    }
+
+    if (!resize (count))
+      return;
+
+    newCount = count;
+
+    /* Process in-place backward. */
+    a = na;
+    b = nb;
+    for (; a && b; )
+    {
+      if (page_map[a - 1].major == other.page_map[b - 1].major)
+      {
+	a--;
+	b--;
+	count--;
+	page_map[count] = page_map[a];
+	page_at (count).v = op (page_at (a).v, other.page_at (b).v);
+      }
+      else if (page_map[a - 1].major > other.page_map[b - 1].major)
+      {
+	a--;
+	if (passthru_left)
+	{
+	  count--;
+	  page_map[count] = page_map[a];
+	}
+      }
+      else
+      {
+	b--;
+	if (passthru_right)
+	{
+	  count--;
+	  page_map[count].major = other.page_map[b].major;
+	  page_map[count].index = next_page++;
+	  page_at (count).v = other.page_at (b).v;
+	}
+      }
+    }
+    if (passthru_left)
+      while (a)
+      {
+	a--;
+	count--;
+	page_map[count] = page_map [a];
+      }
+    if (passthru_right)
+      while (b)
+      {
+	b--;
+	count--;
+	page_map[count].major = other.page_map[b].major;
+	page_map[count].index = next_page++;
+	page_at (count).v = other.page_at (b).v;
+      }
+    assert (!count);
+    if (pages.length > newCount)
+      // This resize() doesn't need to be checked because we can't get here
+      // if the set is currently in_error() and this only resizes downwards
+      // which will always succeed if the set is not in_error().
+      resize (newCount);
+  }
+
+  void union_ (const hb_bit_set_t &other) { process (hb_bitwise_or, other); }
+  void intersect (const hb_bit_set_t &other) { process (hb_bitwise_and, other); }
+  void subtract (const hb_bit_set_t &other) { process (hb_bitwise_gt, other); }
+  void symmetric_difference (const hb_bit_set_t &other) { process (hb_bitwise_xor, other); }
+
+  bool next (hb_codepoint_t *codepoint) const
+  {
+    // TODO: this should be merged with prev() as both implementations
+    //       are very similar.
+    if (unlikely (*codepoint == INVALID)) {
+      *codepoint = get_min ();
+      return *codepoint != INVALID;
+    }
+
+    const auto* page_map_array = page_map.arrayZ;
+    unsigned int major = get_major (*codepoint);
+    unsigned int i = last_page_lookup;
+
+    if (unlikely (i >= page_map.length || page_map_array[i].major != major))
+    {
+      page_map.bfind (major, &i, HB_NOT_FOUND_STORE_CLOSEST);
+      if (i >= page_map.length) {
+        *codepoint = INVALID;
+        return false;
+      }
+    }
+
+    const auto* pages_array = pages.arrayZ;
+    const page_map_t &current = page_map_array[i];
+    if (likely (current.major == major))
+    {
+      if (pages_array[current.index].next (codepoint))
+      {
+        *codepoint += current.major * page_t::PAGE_BITS;
+        last_page_lookup = i;
+        return true;
+      }
+      i++;
+    }
+
+    for (; i < page_map.length; i++)
+    {
+      const page_map_t &current = page_map.arrayZ[i];
+      hb_codepoint_t m = pages_array[current.index].get_min ();
+      if (m != INVALID)
+      {
+	*codepoint = current.major * page_t::PAGE_BITS + m;
+        last_page_lookup = i;
+	return true;
+      }
+    }
+    last_page_lookup = 0;
+    *codepoint = INVALID;
+    return false;
+  }
+  bool previous (hb_codepoint_t *codepoint) const
+  {
+    if (unlikely (*codepoint == INVALID)) {
+      *codepoint = get_max ();
+      return *codepoint != INVALID;
+    }
+
+    page_map_t map = {get_major (*codepoint), 0};
+    unsigned int i;
+    page_map.bfind (map, &i, HB_NOT_FOUND_STORE_CLOSEST);
+    if (i < page_map.length && page_map[i].major == map.major)
+    {
+      if (pages[page_map[i].index].previous (codepoint))
+      {
+	*codepoint += page_map[i].major * page_t::PAGE_BITS;
+	return true;
+      }
+    }
+    i--;
+    for (; (int) i >= 0; i--)
+    {
+      hb_codepoint_t m = pages[page_map[i].index].get_max ();
+      if (m != INVALID)
+      {
+	*codepoint = page_map[i].major * page_t::PAGE_BITS + m;
+	return true;
+      }
+    }
+    *codepoint = INVALID;
+    return false;
+  }
+  bool next_range (hb_codepoint_t *first, hb_codepoint_t *last) const
+  {
+    hb_codepoint_t i;
+
+    i = *last;
+    if (!next (&i))
+    {
+      *last = *first = INVALID;
+      return false;
+    }
+
+    /* TODO Speed up. */
+    *last = *first = i;
+    while (next (&i) && i == *last + 1)
+      (*last)++;
+
+    return true;
+  }
+  bool previous_range (hb_codepoint_t *first, hb_codepoint_t *last) const
+  {
+    hb_codepoint_t i;
+
+    i = *first;
+    if (!previous (&i))
+    {
+      *last = *first = INVALID;
+      return false;
+    }
+
+    /* TODO Speed up. */
+    *last = *first = i;
+    while (previous (&i) && i == *first - 1)
+      (*first)--;
+
+    return true;
+  }
+
+  bool has_population () const { return population != UINT_MAX; }
+  unsigned int get_population () const
+  {
+    if (has_population ())
+      return population;
+
+    unsigned int pop = 0;
+    unsigned int count = pages.length;
+    for (unsigned int i = 0; i < count; i++)
+      pop += pages[i].get_population ();
+
+    population = pop;
+    return pop;
+  }
+  hb_codepoint_t get_min () const
+  {
+    unsigned count = pages.length;
+    for (unsigned i = 0; i < count; i++)
+    {
+      const auto& map = page_map[i];
+      const auto& page = pages[map.index];
+
+      if (!page.is_empty ())
+	return map.major * page_t::PAGE_BITS + page.get_min ();
+    }
+    return INVALID;
+  }
+  hb_codepoint_t get_max () const
+  {
+    unsigned count = pages.length;
+    for (signed i = count - 1; i >= 0; i--)
+    {
+      const auto& map = page_map[(unsigned) i];
+      const auto& page = pages[map.index];
+
+      if (!page.is_empty ())
+	return map.major * page_t::PAGE_BITS + page.get_max ();
+    }
+    return INVALID;
+  }
+
+  static constexpr hb_codepoint_t INVALID = page_t::INVALID;
+
+  /*
+   * Iterator implementation.
+   */
+  struct iter_t : hb_iter_with_fallback_t<iter_t, hb_codepoint_t>
+  {
+    static constexpr bool is_sorted_iterator = true;
+    iter_t (const hb_bit_set_t &s_ = Null (hb_bit_set_t),
+	    bool init = true) : s (&s_), v (INVALID), l(0)
+    {
+      if (init)
+      {
+	l = s->get_population () + 1;
+	__next__ ();
+      }
+    }
+
+    typedef hb_codepoint_t __item_t__;
+    hb_codepoint_t __item__ () const { return v; }
+    bool __more__ () const { return v != INVALID; }
+    void __next__ () { s->next (&v); if (l) l--; }
+    void __prev__ () { s->previous (&v); }
+    unsigned __len__ () const { return l; }
+    iter_t end () const { return iter_t (*s, false); }
+    bool operator != (const iter_t& o) const
+    { return s != o.s || v != o.v; }
+
+    protected:
+    const hb_bit_set_t *s;
+    hb_codepoint_t v;
+    unsigned l;
+  };
+  iter_t iter () const { return iter_t (*this); }
+  operator iter_t () const { return iter (); }
+
+  protected:
+
+  page_t *page_for (hb_codepoint_t g, bool insert = false)
+  {
+    page_map_t map = {get_major (g), pages.length};
+    unsigned int i;
+    if (!page_map.bfind (map, &i, HB_NOT_FOUND_STORE_CLOSEST))
+    {
+      if (!insert)
+        return nullptr;
+
+      if (!resize (pages.length + 1))
+	return nullptr;
+
+      pages[map.index].init0 ();
+      memmove (page_map + i + 1,
+	       page_map + i,
+	       (page_map.length - 1 - i) * page_map.item_size);
+      page_map[i] = map;
+    }
+    return &pages[page_map[i].index];
+  }
+  const page_t *page_for (hb_codepoint_t g) const
+  {
+    page_map_t key = {get_major (g)};
+    const page_map_t *found = page_map.bsearch (key);
+    if (found)
+      return &pages[found->index];
+    return nullptr;
+  }
+  page_t &page_at (unsigned int i) { return pages[page_map[i].index]; }
+  const page_t &page_at (unsigned int i) const { return pages[page_map[i].index]; }
+  unsigned int get_major (hb_codepoint_t g) const { return g / page_t::PAGE_BITS; }
+  hb_codepoint_t major_start (unsigned int major) const { return major * page_t::PAGE_BITS; }
+};
+
+
+#endif /* HB_BIT_SET_HH */
diff --git a/src/hb-deprecated.h b/src/hb-deprecated.h
index 5f1912578..a130d77f7 100644
--- a/src/hb-deprecated.h
+++ b/src/hb-deprecated.h
@@ -107,16 +107,13 @@ hb_font_funcs_set_glyph_func (hb_font_funcs_t *ffuncs,
 			      hb_font_get_glyph_func_t func,
 			      void *user_data, hb_destroy_func_t destroy);
 
-HB_EXTERN HB_DEPRECATED void
-hb_set_invert (hb_set_t *set);
-
 /**
  * hb_unicode_eastasian_width_func_t:
  * @ufuncs: A Unicode-functions structure
  * @unicode: The code point to query
  * @user_data: User data pointer passed by the caller
  *
  * A virtual method for the #hb_unicode_funcs_t structure.
  *
  * Deprecated: 2.0.0
  */
diff --git a/src/hb-map.cc b/src/hb-map.cc
index 6757535b7..388e67886 100644
--- a/src/hb-map.cc
+++ b/src/hb-map.cc
@@ -187,16 +187,17 @@ void
 hb_map_set (hb_map_t       *map,
 	    hb_codepoint_t  key,
 	    hb_codepoint_t  value)
 {
+  /* Immutable-safe. */
   map->set (key, value);
 }
 
 /**
  * hb_map_get:
  * @map: A map
  * @key: The key to query
  *
  * Fetches the value stored for @key in @map.
  *
  * Since: 1.7.7
  **/
@@ -220,17 +221,18 @@ void
 hb_map_del (hb_map_t       *map,
 	    hb_codepoint_t  key)
 {
+  /* Immutable-safe. */
   map->del (key);
 }
 
 /**
  * hb_map_has:
  * @map: A map
  * @key: The key to query
  *
  * Tests whether @key is an element of @map.
  *
  * Return value: %true if @key is found in @map, %false otherwise
  *
  * Since: 1.7.7
  **/
diff --git a/src/hb-object.hh b/src/hb-object.hh
index 64abb0ce1..0e15cb12c 100644
--- a/src/hb-object.hh
+++ b/src/hb-object.hh
@@ -46,102 +46,100 @@ template <typename item_t, typename lock_t>
 struct hb_lockable_set_t
 {
   hb_vector_t<item_t> items;
 
   void init () { items.init (); }
 
   template <typename T>
   item_t *replace_or_insert (T v, lock_t &l, bool replace)
   {
     l.lock ();
     item_t *item = items.find (v);
     if (item) {
       if (replace) {
 	item_t old = *item;
 	*item = v;
 	l.unlock ();
 	old.fini ();
       }
       else {
 	item = nullptr;
 	l.unlock ();
       }
     } else {
       item = items.push (v);
       l.unlock ();
     }
     return item;
   }
 
   template <typename T>
   void remove (T v, lock_t &l)
   {
     l.lock ();
     item_t *item = items.find (v);
     if (item)
     {
       item_t old = *item;
       *item = items[items.length - 1];
       items.pop ();
       l.unlock ();
       old.fini ();
     } else {
       l.unlock ();
     }
   }
 
   template <typename T>
   bool find (T v, item_t *i, lock_t &l)
   {
     l.lock ();
     item_t *item = items.find (v);
     if (item)
       *i = *item;
     l.unlock ();
     return !!item;
   }
 
   template <typename T>
   item_t *find_or_insert (T v, lock_t &l)
   {
     l.lock ();
     item_t *item = items.find (v);
     if (!item) {
       item = items.push (v);
     }
     l.unlock ();
     return item;
   }
 
   void fini (lock_t &l)
   {
     if (!items.length)
     {
       /* No need to lock. */
       items.fini ();
       return;
     }
     l.lock ();
     while (items.length)
     {
       item_t old = items[items.length - 1];
       items.pop ();
       l.unlock ();
       old.fini ();
       l.lock ();
     }
     items.fini ();
     l.unlock ();
   }
 
 };
 
 
 /*
  * Reference-count.
  */
 
-#define HB_REFERENCE_COUNT_INIT {0}
-
 struct hb_reference_count_t
 {
   mutable hb_atomic_int_t ref_count;
@@ -195,12 +193,14 @@ struct hb_user_data_array_t
 struct hb_object_header_t
 {
   hb_reference_count_t ref_count;
   mutable hb_atomic_int_t writable = 0;
   hb_atomic_ptr_t<hb_user_data_array_t> user_data;
+
+  bool is_inert () const { return !ref_count.get_relaxed (); }
 };
 #define HB_OBJECT_HEADER_STATIC {}
 
 
 /*
  * Object
  */
@@ -234,11 +234,6 @@ static inline void hb_object_init (Type *obj)
   obj->header.user_data.init ();
 }
 template <typename Type>
-static inline bool hb_object_is_inert (const Type *obj)
-{
-  return unlikely (obj->header.ref_count.is_inert ());
-}
-template <typename Type>
 static inline bool hb_object_is_valid (const Type *obj)
 {
   return likely (obj->header.ref_count.is_valid ());
@@ -257,9 +252,9 @@ template <typename Type>
 static inline Type *hb_object_reference (Type *obj)
 {
   hb_object_trace (obj, HB_FUNC);
-  if (unlikely (!obj || hb_object_is_inert (obj)))
+  if (unlikely (!obj || obj->header.is_inert ()))
     return obj;
   assert (hb_object_is_valid (obj));
   obj->header.ref_count.inc ();
   return obj;
 }
@@ -267,12 +262,12 @@ template <typename Type>
 static inline bool hb_object_destroy (Type *obj)
 {
   hb_object_trace (obj, HB_FUNC);
-  if (unlikely (!obj || hb_object_is_inert (obj)))
+  if (unlikely (!obj || obj->header.is_inert ()))
     return false;
   assert (hb_object_is_valid (obj));
   if (obj->header.ref_count.dec () != 1)
     return false;
 
   hb_object_fini (obj);
   return true;
 }
@@ -292,10 +287,10 @@ template <typename Type>
 static inline bool hb_object_set_user_data (Type               *obj,
 					    hb_user_data_key_t *key,
 					    void *              data,
 					    hb_destroy_func_t   destroy,
 					    hb_bool_t           replace)
 {
-  if (unlikely (!obj || hb_object_is_inert (obj)))
+  if (unlikely (!obj || obj->header.is_inert ()))
     return false;
   assert (hb_object_is_valid (obj));
 
@@ -322,14 +317,14 @@ template <typename Type>
 static inline void *hb_object_get_user_data (Type               *obj,
 					     hb_user_data_key_t *key)
 {
-  if (unlikely (!obj || hb_object_is_inert (obj)))
+  if (unlikely (!obj || obj->header.is_inert ()))
     return nullptr;
   assert (hb_object_is_valid (obj));
   hb_user_data_array_t *user_data = obj->header.user_data.get ();
   if (!user_data)
     return nullptr;
   return user_data->get (key);
 }
 
 
 #endif /* HB_OBJECT_HH */
diff --git a/src/hb-ot-layout-gsubgpos.hh b/src/hb-ot-layout-gsubgpos.hh
index f1c111a4a..a68abb533 100644
--- a/src/hb-ot-layout-gsubgpos.hh
+++ b/src/hb-ot-layout-gsubgpos.hh
@@ -3517,320 +3517,321 @@ struct hb_ot_layout_lookup_accelerator_t
 struct GSUBGPOS
 {
   bool has_data () const { return version.to_int (); }
   unsigned int get_script_count () const
   { return (this+scriptList).len; }
   const Tag& get_script_tag (unsigned int i) const
   { return (this+scriptList).get_tag (i); }
   unsigned int get_script_tags (unsigned int start_offset,
 				unsigned int *script_count /* IN/OUT */,
 				hb_tag_t     *script_tags /* OUT */) const
   { return (this+scriptList).get_tags (start_offset, script_count, script_tags); }
   const Script& get_script (unsigned int i) const
   { return (this+scriptList)[i]; }
   bool find_script_index (hb_tag_t tag, unsigned int *index) const
   { return (this+scriptList).find_index (tag, index); }
 
   unsigned int get_feature_count () const
   { return (this+featureList).len; }
   hb_tag_t get_feature_tag (unsigned int i) const
   { return i == Index::NOT_FOUND_INDEX ? HB_TAG_NONE : (this+featureList).get_tag (i); }
   unsigned int get_feature_tags (unsigned int start_offset,
 				 unsigned int *feature_count /* IN/OUT */,
 				 hb_tag_t     *feature_tags /* OUT */) const
   { return (this+featureList).get_tags (start_offset, feature_count, feature_tags); }
   const Feature& get_feature (unsigned int i) const
   { return (this+featureList)[i]; }
   bool find_feature_index (hb_tag_t tag, unsigned int *index) const
   { return (this+featureList).find_index (tag, index); }
 
   unsigned int get_lookup_count () const
   { return (this+lookupList).len; }
   const Lookup& get_lookup (unsigned int i) const
   { return (this+lookupList)[i]; }
 
   bool find_variations_index (const int *coords, unsigned int num_coords,
 			      unsigned int *index) const
   {
 #ifdef HB_NO_VAR
     *index = FeatureVariations::NOT_FOUND_INDEX;
     return false;
 #endif
     return (version.to_int () >= 0x00010001u ? this+featureVars : Null (FeatureVariations))
 	    .find_index (coords, num_coords, index);
   }
   const Feature& get_feature_variation (unsigned int feature_index,
 					unsigned int variations_index) const
   {
 #ifndef HB_NO_VAR
     if (FeatureVariations::NOT_FOUND_INDEX != variations_index &&
 	version.to_int () >= 0x00010001u)
     {
       const Feature *feature = (this+featureVars).find_substitute (variations_index,
 								   feature_index);
       if (feature)
 	return *feature;
     }
 #endif
     return get_feature (feature_index);
   }
 
   void feature_variation_collect_lookups (const hb_set_t *feature_indexes,
 					  hb_set_t       *lookup_indexes /* OUT */) const
   {
 #ifndef HB_NO_VAR
     if (version.to_int () >= 0x00010001u)
       (this+featureVars).collect_lookups (feature_indexes, lookup_indexes);
 #endif
   }
 
   template <typename TLookup>
   void closure_lookups (hb_face_t      *face,
 			const hb_set_t *glyphs,
 			hb_set_t       *lookup_indexes /* IN/OUT */) const
   {
     hb_set_t visited_lookups, inactive_lookups;
     OT::hb_closure_lookups_context_t c (face, glyphs, &visited_lookups, &inactive_lookups);
 
     for (unsigned lookup_index : + hb_iter (lookup_indexes))
       reinterpret_cast<const TLookup &> (get_lookup (lookup_index)).closure_lookups (&c, lookup_index);
 
     hb_set_union (lookup_indexes, &visited_lookups);
     hb_set_subtract (lookup_indexes, &inactive_lookups);
   }
 
   void prune_langsys (const hb_map_t *duplicate_feature_map,
                       hb_hashmap_t<unsigned, hb_set_t *, (unsigned)-1, nullptr> *script_langsys_map,
                       hb_set_t       *new_feature_indexes /* OUT */) const
   {
     hb_prune_langsys_context_t c (this, script_langsys_map, duplicate_feature_map, new_feature_indexes);
 
     unsigned count = get_script_count ();
     for (unsigned script_index = 0; script_index < count; script_index++)
     {
       const Script& s = get_script (script_index);
       s.prune_langsys (&c, script_index);
     }
   }
 
   template <typename TLookup>
   bool subset (hb_subset_layout_context_t *c) const
   {
     TRACE_SUBSET (this);
     auto *out = c->subset_context->serializer->embed (*this);
     if (unlikely (!out)) return_trace (false);
 
     typedef LookupOffsetList<TLookup> TLookupList;
     reinterpret_cast<Offset16To<TLookupList> &> (out->lookupList)
 	.serialize_subset (c->subset_context,
 			   reinterpret_cast<const Offset16To<TLookupList> &> (lookupList),
 			   this,
 			   c);
 
     reinterpret_cast<Offset16To<RecordListOfFeature> &> (out->featureList)
 	.serialize_subset (c->subset_context,
 			   reinterpret_cast<const Offset16To<RecordListOfFeature> &> (featureList),
 			   this,
 			   c);
 
     out->scriptList.serialize_subset (c->subset_context,
 				      scriptList,
 				      this,
 				      c);
 
 #ifndef HB_NO_VAR
     if (version.to_int () >= 0x00010001u)
     {
       bool ret = out->featureVars.serialize_subset (c->subset_context, featureVars, this, c);
       if (!ret)
       {
 	out->version.major = 1;
 	out->version.minor = 0;
       }
     }
 #endif
 
     return_trace (true);
   }
 
   void find_duplicate_features (const hb_map_t *lookup_indices,
                                 const hb_set_t *feature_indices,
                                 hb_map_t *duplicate_feature_map /* OUT */) const
   {
     //find out duplicate features after subset
     unsigned prev = 0xFFFFu;
     for (unsigned i : feature_indices->iter ())
     {
       if (prev == 0xFFFFu)
       {
         duplicate_feature_map->set (i, i);
         prev = i;
         continue;
       }
 
       hb_tag_t t = get_feature_tag (i);
       hb_tag_t prev_t = get_feature_tag (prev);
       if (t != prev_t)
       {
         duplicate_feature_map->set (i, i);
         prev = i;
         continue;
       }
 
       const Feature& f = get_feature (i);
       const Feature& prev_f = get_feature (prev);
 
       auto f_iter =
       + hb_iter (f.lookupIndex)
       | hb_filter (lookup_indices)
       ;
 
       auto prev_iter =
       + hb_iter (prev_f.lookupIndex)
       | hb_filter (lookup_indices)
       ;
 
       if (f_iter.len () != prev_iter.len ())
       {
         duplicate_feature_map->set (i, i);
         prev = i;
         continue;
       }
 
       bool is_equal = true;
       for (auto _ : + hb_zip (f_iter, prev_iter))
         if (_.first != _.second) { is_equal = false; break; }
 
       if (is_equal == true) duplicate_feature_map->set (i, prev);
       else
       {
         duplicate_feature_map->set (i, i);
         prev = i;
       }
     }
   }
 
   void prune_features (const hb_map_t *lookup_indices, /* IN */
 		       hb_set_t       *feature_indices /* IN/OUT */) const
   {
 #ifndef HB_NO_VAR
     // This is the set of feature indices which have alternate versions defined
     // if the FeatureVariation's table and the alternate version(s) intersect the
     // set of lookup indices.
     hb_set_t alternate_feature_indices;
     if (version.to_int () >= 0x00010001u)
       (this+featureVars).closure_features (lookup_indices, &alternate_feature_indices);
-    if (unlikely (alternate_feature_indices.in_error())) {
-      feature_indices->successful = false;
+    if (unlikely (alternate_feature_indices.in_error()))
+    {
+      feature_indices->err ();
       return;
     }
 #endif
 
     for (unsigned i : feature_indices->iter())
     {
       const Feature& f = get_feature (i);
       hb_tag_t tag =  get_feature_tag (i);
       if (tag == HB_TAG ('p', 'r', 'e', 'f'))
         // Note: Never ever drop feature 'pref', even if it's empty.
         // HarfBuzz chooses shaper for Khmer based on presence of this
         // feature.	See thread at:
 	// http://lists.freedesktop.org/archives/harfbuzz/2012-November/002660.html
         continue;
 
       if (f.featureParams.is_null ()
 	  && !f.intersects_lookup_indexes (lookup_indices)
 #ifndef HB_NO_VAR
           && !alternate_feature_indices.has (i)
 #endif
 	  )
 	feature_indices->del (i);
     }
   }
 
   unsigned int get_size () const
   {
     return min_size +
 	   (version.to_int () >= 0x00010001u ? featureVars.static_size : 0);
   }
 
   template <typename TLookup>
   bool sanitize (hb_sanitize_context_t *c) const
   {
     TRACE_SANITIZE (this);
     typedef List16OfOffset16To<TLookup> TLookupList;
     if (unlikely (!(version.sanitize (c) &&
 		    likely (version.major == 1) &&
 		    scriptList.sanitize (c, this) &&
 		    featureList.sanitize (c, this) &&
 		    reinterpret_cast<const Offset16To<TLookupList> &> (lookupList).sanitize (c, this))))
       return_trace (false);
 
 #ifndef HB_NO_VAR
     if (unlikely (!(version.to_int () < 0x00010001u || featureVars.sanitize (c, this))))
       return_trace (false);
 #endif
 
     return_trace (true);
   }
 
   template <typename T>
   struct accelerator_t
   {
     void init (hb_face_t *face)
     {
       this->table = hb_sanitize_context_t ().reference_table<T> (face);
       if (unlikely (this->table->is_blocklisted (this->table.get_blob (), face)))
       {
 	hb_blob_destroy (this->table.get_blob ());
 	this->table = hb_blob_get_empty ();
       }
 
       this->lookup_count = table->get_lookup_count ();
 
       this->accels = (hb_ot_layout_lookup_accelerator_t *) hb_calloc (this->lookup_count, sizeof (hb_ot_layout_lookup_accelerator_t));
       if (unlikely (!this->accels))
       {
 	this->lookup_count = 0;
 	this->table.destroy ();
 	this->table = hb_blob_get_empty ();
       }
 
       for (unsigned int i = 0; i < this->lookup_count; i++)
 	this->accels[i].init (table->get_lookup (i));
     }
 
     void fini ()
     {
       for (unsigned int i = 0; i < this->lookup_count; i++)
 	this->accels[i].fini ();
       hb_free (this->accels);
       this->table.destroy ();
     }
 
     hb_blob_ptr_t<T> table;
     unsigned int lookup_count;
     hb_ot_layout_lookup_accelerator_t *accels;
   };
 
   protected:
   FixedVersion<>version;	/* Version of the GSUB/GPOS table--initially set
 				 * to 0x00010000u */
   Offset16To<ScriptList>
 		scriptList;	/* ScriptList table */
   Offset16To<FeatureList>
 		featureList;	/* FeatureList table */
   Offset16To<LookupList>
 		lookupList;	/* LookupList table */
   Offset32To<FeatureVariations>
 		featureVars;	/* Offset to Feature Variations
 				   table--from beginning of table
 				 * (may be NULL).  Introduced
 				 * in version 0x00010001. */
   public:
   DEFINE_SIZE_MIN (10);
 };
 
 
 } /* namespace OT */
 
 
 #endif /* HB_OT_LAYOUT_GSUBGPOS_HH */
diff --git a/src/hb-set.cc b/src/hb-set.cc
index 25f29c67b..f9bc85869 100644
--- a/src/hb-set.cc
+++ b/src/hb-set.cc
@@ -169,16 +169,16 @@ hb_set_get_user_data (hb_set_t           *set,
 hb_bool_t
 hb_set_allocation_successful (const hb_set_t  *set)
 {
-  return set->successful;
+  return !set->in_error ();
 }
 
 /**
  * hb_set_copy:
  * @set: A set
  *
  * Allocate a copy of @set.
  *
  * Return value: Newly-allocated set.
  *
  * Since: 2.8.2
  **/
@@ -254,17 +254,18 @@ void
 hb_set_add (hb_set_t       *set,
 	    hb_codepoint_t  codepoint)
 {
+  /* Immutible-safe. */
   set->add (codepoint);
 }
 
 /**
  * hb_set_add_range:
  * @set: A set
  * @first: The first element to add to @set
  * @last: The final element to add to @set
  *
  * Adds all of the elements from @first to @last
  * (inclusive) to @set.
  *
  * Since: 0.9.7
  **/
@@ -272,16 +273,17 @@ void
 hb_set_add_range (hb_set_t       *set,
 		  hb_codepoint_t  first,
 		  hb_codepoint_t  last)
 {
+  /* Immutible-safe. */
   set->add_range (first, last);
 }
 
 /**
  * hb_set_del:
  * @set: A set
  * @codepoint: Removes @codepoint from @set
  *
  * Removes @codepoint from @set.
  *
  * Since: 0.9.2
  **/
@@ -289,20 +291,21 @@ void
 hb_set_del (hb_set_t       *set,
 	    hb_codepoint_t  codepoint)
 {
+  /* Immutible-safe. */
   set->del (codepoint);
 }
 
 /**
  * hb_set_del_range:
  * @set: A set
  * @first: The first element to remove from @set
  * @last: The final element to remove from @set
  *
  * Removes all of the elements from @first to @last
  * (inclusive) from @set.
  *
  * If @last is #HB_SET_VALUE_INVALID, then all values
  * greater than or equal to @first are removed.
  *
  * Since: 0.9.7
  **/
@@ -310,19 +313,20 @@ void
 hb_set_del_range (hb_set_t       *set,
 		  hb_codepoint_t  first,
 		  hb_codepoint_t  last)
 {
+  /* Immutible-safe. */
   set->del_range (first, last);
 }
 
 /**
  * hb_set_is_equal:
  * @set: A set
  * @other: Another set
  *
  * Tests whether @set and @other are equal (contain the same
  * elements).
  *
  * Return value: %true if the two sets are equal, %false otherwise.
  *
  * Since: 0.9.7
  **/
@@ -364,15 +368,18 @@ void
 hb_set_set (hb_set_t       *set,
 	    const hb_set_t *other)
 {
+  if (unlikely (hb_object_is_immutable (set)))
+    return;
+
   set->set (*other);
 }
 
 /**
  * hb_set_union:
  * @set: A set
  * @other: Another set
  *
  * Makes @set the union of @set and @other.
  *
  * Since: 0.9.2
  **/
@@ -380,15 +387,18 @@ void
 hb_set_union (hb_set_t       *set,
 	      const hb_set_t *other)
 {
+  if (unlikely (hb_object_is_immutable (set)))
+    return;
+
   set->union_ (*other);
 }
 
 /**
  * hb_set_intersect:
  * @set: A set
  * @other: Another set
  *
  * Makes @set the intersection of @set and @other.
  *
  * Since: 0.9.2
  **/
@@ -396,15 +406,18 @@ void
 hb_set_intersect (hb_set_t       *set,
 		  const hb_set_t *other)
 {
+  if (unlikely (hb_object_is_immutable (set)))
+    return;
+
   set->intersect (*other);
 }
 
 /**
  * hb_set_subtract:
  * @set: A set
  * @other: Another set
  *
  * Subtracts the contents of @other from @set.
  *
  * Since: 0.9.2
  **/
@@ -412,16 +425,19 @@ void
 hb_set_subtract (hb_set_t       *set,
 		 const hb_set_t *other)
 {
+  if (unlikely (hb_object_is_immutable (set)))
+    return;
+
   set->subtract (*other);
 }
 
 /**
  * hb_set_symmetric_difference:
  * @set: A set
  * @other: Another set
  *
  * Makes @set the symmetric difference of @set
  * and @other.
  *
  * Since: 0.9.2
  **/
@@ -429,33 +445,36 @@ void
 hb_set_symmetric_difference (hb_set_t       *set,
 			     const hb_set_t *other)
 {
+  if (unlikely (hb_object_is_immutable (set)))
+    return;
+
   set->symmetric_difference (*other);
 }
 
-#ifndef HB_DISABLE_DEPRECATED
 /**
  * hb_set_invert:
  * @set: A set
  *
  * Inverts the contents of @set.
  *
- * Since: 0.9.10
- *
- * Deprecated: 1.6.1
+ * Since: 3.0.0
  **/
 void
-hb_set_invert (hb_set_t *set HB_UNUSED)
+hb_set_invert (hb_set_t *set)
 {
+  if (unlikely (hb_object_is_immutable (set)))
+    return;
+
+  set->invert ();
 }
-#endif
 
 /**
  * hb_set_get_population:
  * @set: A set
  *
  * Returns the number of elements in the set.
  *
  * Return value: The population of @set
  *
  * Since: 0.9.7
  **/
diff --git a/src/hb-set.h b/src/hb-set.h
index 7f2112e69..423225bf9 100644
--- a/src/hb-set.h
+++ b/src/hb-set.h
@@ -94,6 +94,9 @@ hb_set_clear (hb_set_t *set);
 HB_EXTERN hb_bool_t
 hb_set_is_empty (const hb_set_t *set);
 
+HB_EXTERN void
+hb_set_invert (hb_set_t *set);
+
 HB_EXTERN hb_bool_t
 hb_set_has (const hb_set_t *set,
 	    hb_codepoint_t  codepoint);
diff --git a/src/hb-set.hh b/src/hb-set.hh
index 8bb7f9f0b..95132200a 100644
--- a/src/hb-set.hh
+++ b/src/hb-set.hh
@@ -1,973 +1,143 @@
 /*
  * Copyright © 2012,2017  Google, Inc.
+ * Copyright © 2021 Behdad Esfahbod
  *
  *  This is part of HarfBuzz, a text shaping library.
  *
  * Permission is hereby granted, without written agreement and without
  * license or royalty fees, to use, copy, modify, and distribute this
  * software and its documentation for any purpose, provided that the
  * above copyright notice and the following two paragraphs appear in
  * all copies of this software.
  *
  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  * DAMAGE.
  *
  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  *
  * Google Author(s): Behdad Esfahbod
  */
 
 #ifndef HB_SET_HH
 #define HB_SET_HH
 
 #include "hb.hh"
-#include "hb-machinery.hh"
+#include "hb-bit-set-invertible.hh"
 
 
-/*
- * hb_set_t
- */
-
-/* TODO Keep a freelist so we can release pages that are completely zeroed.  At that
- * point maybe also use a sentinel value for "all-1" pages? */
-
-struct hb_set_t
+template <typename impl_t>
+struct hb_sparseset_t
 {
-  hb_set_t ()  { init (); }
-  ~hb_set_t () { fini (); }
-
-  hb_set_t (const hb_set_t& other) : hb_set_t () { set (other); }
-  void operator= (const hb_set_t& other) { set (other); }
-  // TODO Add move construtor/assign
-  // TODO Add constructor for Iterator; with specialization for (sorted) vector / array?
-
-  struct page_map_t
-  {
-    int cmp (const page_map_t &o) const { return (int) o.major - (int) major; }
-    int cmp (uint32_t o_major) const { return (int) o_major - (int) major; }
-
-    uint32_t major;
-    uint32_t index;
-  };
-
-  struct page_t
-  {
-    void init0 () { v.clear (); }
-    void init1 () { v.clear (0xFF); }
-
-    constexpr unsigned len () const
-    { return ARRAY_LENGTH_CONST (v); }
-
-    bool is_empty () const
-    {
-      for (unsigned int i = 0; i < len (); i++)
-	if (v[i])
-	  return false;
-      return true;
-    }
-
-    void add (hb_codepoint_t g) { elt (g) |= mask (g); }
-    void del (hb_codepoint_t g) { elt (g) &= ~mask (g); }
-    bool get (hb_codepoint_t g) const { return elt (g) & mask (g); }
-
-    void add_range (hb_codepoint_t a, hb_codepoint_t b)
-    {
-      elt_t *la = &elt (a);
-      elt_t *lb = &elt (b);
-      if (la == lb)
-	*la |= (mask (b) << 1) - mask(a);
-      else
-      {
-	*la |= ~(mask (a) - 1);
-	la++;
-
-	memset (la, 0xff, (char *) lb - (char *) la);
-
-	*lb |= ((mask (b) << 1) - 1);
-      }
-    }
-
-    void del_range (hb_codepoint_t a, hb_codepoint_t b)
-    {
-      elt_t *la = &elt (a);
-      elt_t *lb = &elt (b);
-      if (la == lb)
-	*la &= ~((mask (b) << 1) - mask(a));
-      else
-      {
-	*la &= mask (a) - 1;
-	la++;
-
-	memset (la, 0, (char *) lb - (char *) la);
-
-	*lb &= ~((mask (b) << 1) - 1);
-      }
-    }
-
-    bool is_equal (const page_t &other) const
-    {
-      return 0 == hb_memcmp (&v, &other.v, sizeof (v));
-    }
-    bool is_subset (const page_t &larger_page) const
-    {
-      for (unsigned i = 0; i < len (); i++)
-        if (~larger_page.v[i] & v[i])
-	  return false;
-      return true;
-    }
-
-    unsigned int get_population () const
-    {
-      unsigned int pop = 0;
-      for (unsigned int i = 0; i < len (); i++)
-	pop += hb_popcount (v[i]);
-      return pop;
-    }
-
-    bool next (hb_codepoint_t *codepoint) const
-    {
-      unsigned int m = (*codepoint + 1) & MASK;
-      if (!m)
-      {
-	*codepoint = INVALID;
-	return false;
-      }
-      unsigned int i = m / ELT_BITS;
-      unsigned int j = m & ELT_MASK;
-
-      const elt_t vv = v[i] & ~((elt_t (1) << j) - 1);
-      for (const elt_t *p = &vv; i < len (); p = &v[++i])
-	if (*p)
-	{
-	  *codepoint = i * ELT_BITS + elt_get_min (*p);
-	  return true;
-	}
-
-      *codepoint = INVALID;
-      return false;
-    }
-    bool previous (hb_codepoint_t *codepoint) const
-    {
-      unsigned int m = (*codepoint - 1) & MASK;
-      if (m == MASK)
-      {
-	*codepoint = INVALID;
-	return false;
-      }
-      unsigned int i = m / ELT_BITS;
-      unsigned int j = m & ELT_MASK;
-
-      /* Fancy mask to avoid shifting by elt_t bitsize, which is undefined. */
-      const elt_t mask = j < 8 * sizeof (elt_t) - 1 ?
-			 ((elt_t (1) << (j + 1)) - 1) :
-			 (elt_t) -1;
-      const elt_t vv = v[i] & mask;
-      const elt_t *p = &vv;
-      while (true)
-      {
-	if (*p)
-	{
-	  *codepoint = i * ELT_BITS + elt_get_max (*p);
-	  return true;
-	}
-	if ((int) i <= 0) break;
-	p = &v[--i];
-      }
-
-      *codepoint = INVALID;
-      return false;
-    }
-    hb_codepoint_t get_min () const
-    {
-      for (unsigned int i = 0; i < len (); i++)
-	if (v[i])
-	  return i * ELT_BITS + elt_get_min (v[i]);
-      return INVALID;
-    }
-    hb_codepoint_t get_max () const
-    {
-      for (int i = len () - 1; i >= 0; i--)
-	if (v[i])
-	  return i * ELT_BITS + elt_get_max (v[i]);
-      return 0;
-    }
-
-    typedef unsigned long long elt_t;
-    static constexpr unsigned PAGE_BITS = 512;
-    static_assert ((PAGE_BITS & ((PAGE_BITS) - 1)) == 0, "");
-
-    static unsigned int elt_get_min (const elt_t &elt) { return hb_ctz (elt); }
-    static unsigned int elt_get_max (const elt_t &elt) { return hb_bit_storage (elt) - 1; }
-
-    typedef hb_vector_size_t<elt_t, PAGE_BITS / 8> vector_t;
-
-    static constexpr unsigned ELT_BITS = sizeof (elt_t) * 8;
-    static constexpr unsigned ELT_MASK = ELT_BITS - 1;
-    static constexpr unsigned BITS = sizeof (vector_t) * 8;
-    static constexpr unsigned MASK = BITS - 1;
-    static_assert ((unsigned) PAGE_BITS == (unsigned) BITS, "");
-
-    elt_t &elt (hb_codepoint_t g) { return v[(g & MASK) / ELT_BITS]; }
-    const elt_t& elt (hb_codepoint_t g) const { return v[(g & MASK) / ELT_BITS]; }
-    static constexpr elt_t mask (hb_codepoint_t g) { return elt_t (1) << (g & ELT_MASK); }
-
-    vector_t v;
-  };
-  static_assert (page_t::PAGE_BITS == sizeof (page_t) * 8, "");
-
   hb_object_header_t header;
-  bool successful; /* Allocations successful */
-  mutable unsigned int population;
-  mutable unsigned int last_page_lookup;
-  hb_sorted_vector_t<page_map_t> page_map;
-  hb_vector_t<page_t> pages;
+  impl_t s;
 
-  void init_shallow ()
-  {
-    successful = true;
-    population = 0;
-    last_page_lookup = 0;
-    page_map.init ();
-    pages.init ();
-  }
+  hb_sparseset_t () { init (); }
+  ~hb_sparseset_t () { fini (); }
+
+  void init_shallow () { s.init (); }
   void init ()
   {
     hb_object_init (this);
     init_shallow ();
   }
-  void fini_shallow ()
-  {
-    population = 0;
-    last_page_lookup = 0;
-    page_map.fini ();
-    pages.fini ();
-  }
+  void fini_shallow () { s.fini (); }
   void fini ()
   {
     hb_object_fini (this);
     fini_shallow ();
   }
 
-  bool in_error () const { return !successful; }
-
-  bool resize (unsigned int count)
-  {
-    if (unlikely (count > pages.length && !successful)) return false;
-    if (!pages.resize (count) || !page_map.resize (count))
-    {
-      pages.resize (page_map.length);
-      successful = false;
-      return false;
-    }
-    return true;
-  }
-
-  void reset ()
-  {
-    successful = true;
-    clear ();
-  }
-
-  void clear ()
-  {
-    if (resize (0))
-      population = 0;
-  }
-  bool is_empty () const
-  {
-    unsigned int count = pages.length;
-    for (unsigned int i = 0; i < count; i++)
-      if (!pages[i].is_empty ())
-	return false;
-    return true;
-  }
   explicit operator bool () const { return !is_empty (); }
 
-  void dirty () { population = UINT_MAX; }
+  void err () { s.err (); }
+  bool in_error () const { return s.in_error (); }
 
-  void add (hb_codepoint_t g)
-  {
-    if (unlikely (!successful)) return;
-    if (unlikely (g == INVALID)) return;
-    dirty ();
-    page_t *page = page_for_insert (g); if (unlikely (!page)) return;
-    page->add (g);
-  }
-  bool add_range (hb_codepoint_t a, hb_codepoint_t b)
-  {
-    if (unlikely (!successful)) return true; /* https://github.com/harfbuzz/harfbuzz/issues/657 */
-    if (unlikely (a > b || a == INVALID || b == INVALID)) return false;
-    dirty ();
-    unsigned int ma = get_major (a);
-    unsigned int mb = get_major (b);
-    if (ma == mb)
-    {
-      page_t *page = page_for_insert (a); if (unlikely (!page)) return false;
-      page->add_range (a, b);
-    }
-    else
-    {
-      page_t *page = page_for_insert (a); if (unlikely (!page)) return false;
-      page->add_range (a, major_start (ma + 1) - 1);
+  void reset () { s.reset (); }
+  void clear () { s.clear (); }
+  void invert () { s.invert (); }
+  bool is_empty () const { return s.is_empty (); }
 
-      for (unsigned int m = ma + 1; m < mb; m++)
-      {
-	page = page_for_insert (major_start (m)); if (unlikely (!page)) return false;
-	page->init1 ();
-      }
-
-      page = page_for_insert (b); if (unlikely (!page)) return false;
-      page->add_range (major_start (mb), b);
-    }
-    return true;
-  }
+  void add (hb_codepoint_t g) { s.add (g); }
+  bool add_range (hb_codepoint_t a, hb_codepoint_t b) { return s.add_range (a, b); }
 
   template <typename T>
   void add_array (const T *array, unsigned int count, unsigned int stride=sizeof(T))
-  {
-    if (unlikely (!successful)) return;
-    if (!count) return;
-    dirty ();
-    hb_codepoint_t g = *array;
-    while (count)
-    {
-      unsigned int m = get_major (g);
-      page_t *page = page_for_insert (g); if (unlikely (!page)) return;
-      unsigned int start = major_start (m);
-      unsigned int end = major_start (m + 1);
-      do
-      {
-	page->add (g);
-
-	array = &StructAtOffsetUnaligned<T> (array, stride);
-	count--;
-      }
-      while (count && (g = *array, start <= g && g < end));
-    }
-  }
+  { s.add_array (array, count, stride); }
   template <typename T>
   void add_array (const hb_array_t<const T>& arr) { add_array (&arr, arr.len ()); }
 
   /* Might return false if array looks unsorted.
    * Used for faster rejection of corrupt data. */
   template <typename T>
   bool add_sorted_array (const T *array, unsigned int count, unsigned int stride=sizeof(T))
-  {
-    if (unlikely (!successful)) return true; /* https://github.com/harfbuzz/harfbuzz/issues/657 */
-    if (!count) return true;
-    dirty ();
-    hb_codepoint_t g = *array;
-    hb_codepoint_t last_g = g;
-    while (count)
-    {
-      unsigned int m = get_major (g);
-      page_t *page = page_for_insert (g); if (unlikely (!page)) return false;
-      unsigned int end = major_start (m + 1);
-      do
-      {
-	/* If we try harder we can change the following comparison to <=;
-	 * Not sure if it's worth it. */
-	if (g < last_g) return false;
-	last_g = g;
-	page->add (g);
-
-	array = (const T *) ((const char *) array + stride);
-	count--;
-      }
-      while (count && (g = *array, g < end));
-    }
-    return true;
-  }
+  { return s.add_sorted_array (array, count, stride); }
   template <typename T>
   bool add_sorted_array (const hb_sorted_array_t<const T>& arr) { return add_sorted_array (&arr, arr.len ()); }
 
-  void del (hb_codepoint_t g)
-  {
-    /* TODO perform op even if !successful. */
-    if (unlikely (!successful)) return;
-    page_t *page = page_for (g);
-    if (!page)
-      return;
-    dirty ();
-    page->del (g);
-  }
-
-  private:
-  void del_pages (int ds, int de)
-  {
-    if (ds <= de)
-    {
-      // Pre-allocate the workspace that compact() will need so we can bail on allocation failure
-      // before attempting to rewrite the page map.
-      hb_vector_t<unsigned> compact_workspace;
-      if (unlikely (!allocate_compact_workspace (compact_workspace))) return;
-
-      unsigned int write_index = 0;
-      for (unsigned int i = 0; i < page_map.length; i++)
-      {
-	int m = (int) page_map[i].major;
-	if (m < ds || de < m)
-	  page_map[write_index++] = page_map[i];
-      }
-      compact (compact_workspace, write_index);
-      resize (write_index);
-    }
-  }
+  void del (hb_codepoint_t g) { s.del (g); }
+  void del_range (hb_codepoint_t a, hb_codepoint_t b) { s.del_range (a, b); }
 
-
-  public:
-  void del_range (hb_codepoint_t a, hb_codepoint_t b)
-  {
-    /* TODO perform op even if !successful. */
-    if (unlikely (!successful)) return;
-    if (unlikely (a > b || a == INVALID)) return;
-    dirty ();
-    unsigned int ma = get_major (a);
-    unsigned int mb = get_major (b);
-    /* Delete pages from ds through de if ds <= de. */
-    int ds = (a == major_start (ma))? (int) ma: (int) (ma + 1);
-    int de = (b + 1 == major_start (mb + 1))? (int) mb: ((int) mb - 1);
-    if (ds > de || (int) ma < ds)
-    {
-      page_t *page = page_for (a);
-      if (page)
-      {
-	if (ma == mb)
-	  page->del_range (a, b);
-	else
-	  page->del_range (a, major_start (ma + 1) - 1);
-      }
-    }
-    if (de < (int) mb && ma != mb)
-    {
-      page_t *page = page_for (b);
-      if (page)
-	page->del_range (major_start (mb), b);
-    }
-    del_pages (ds, de);
-  }
-
-  bool get (hb_codepoint_t g) const
-  {
-    const page_t *page = page_for (g);
-    if (!page)
-      return false;
-    return page->get (g);
-  }
+  bool get (hb_codepoint_t g) const { return s.get (g); }
 
   /* Has interface. */
   static constexpr bool SENTINEL = false;
   typedef bool value_t;
   value_t operator [] (hb_codepoint_t k) const { return get (k); }
   bool has (hb_codepoint_t k) const { return (*this)[k] != SENTINEL; }
   /* Predicate. */
   bool operator () (hb_codepoint_t k) const { return has (k); }
 
   /* Sink interface. */
-  hb_set_t& operator << (hb_codepoint_t v)
+  hb_sparseset_t& operator << (hb_codepoint_t v)
   { add (v); return *this; }
-  hb_set_t& operator << (const hb_pair_t<hb_codepoint_t, hb_codepoint_t>& range)
+  hb_sparseset_t& operator << (const hb_pair_t<hb_codepoint_t, hb_codepoint_t>& range)
   { add_range (range.first, range.second); return *this; }
 
   bool intersects (hb_codepoint_t first, hb_codepoint_t last) const
-  {
-    hb_codepoint_t c = first - 1;
-    return next (&c) && c <= last;
-  }
-  void set (const hb_set_t &other)
-  {
-    if (unlikely (!successful)) return;
-    unsigned int count = other.pages.length;
-    if (!resize (count))
-      return;
-    population = other.population;
-
-    hb_memcpy ((void *) pages, (const void *) other.pages, count * pages.item_size);
-    hb_memcpy ((void *) page_map, (const void *) other.page_map, count * page_map.item_size);
-  }
-
-  bool is_equal (const hb_set_t &other) const
-  {
-    if (get_population () != other.get_population ())
-      return false;
+  { return s.intersects (first, last); }
 
-    unsigned int na = pages.length;
-    unsigned int nb = other.pages.length;
-
-    unsigned int a = 0, b = 0;
-    for (; a < na && b < nb; )
-    {
-      if (page_at (a).is_empty ()) { a++; continue; }
-      if (other.page_at (b).is_empty ()) { b++; continue; }
-      if (page_map[a].major != other.page_map[b].major ||
-	  !page_at (a).is_equal (other.page_at (b)))
-	return false;
-      a++;
-      b++;
-    }
-    for (; a < na; a++)
-      if (!page_at (a).is_empty ()) { return false; }
-    for (; b < nb; b++)
-      if (!other.page_at (b).is_empty ()) { return false; }
-
-    return true;
-  }
-
-  bool is_subset (const hb_set_t &larger_set) const
-  {
-    /* TODO: Merge this and is_equal() into something like process(). */
-    if (unlikely(larger_set.is_empty ()))
-      return is_empty ();
+  void set (const hb_sparseset_t &other) { s.set (other.s); }
 
-    uint32_t spi = 0;
-    for (uint32_t lpi = 0; spi < page_map.length && lpi < larger_set.page_map.length; lpi++)
-    {
-      uint32_t spm = page_map[spi].major;
-      uint32_t lpm = larger_set.page_map[lpi].major;
-      auto sp = page_at (spi);
-      auto lp = larger_set.page_at (lpi);
+  bool is_equal (const hb_sparseset_t &other) const { return s.is_equal (other.s); }
 
-      if (spm < lpm && !sp.is_empty ())
-        return false;
+  bool is_subset (const hb_sparseset_t &larger_set) const { return s.is_subset (larger_set.s); }
 
-      if (lpm < spm)
-        continue;
+  void union_ (const hb_sparseset_t &other) { s.union_ (other.s); }
+  void intersect (const hb_sparseset_t &other) { s.intersect (other.s); }
+  void subtract (const hb_sparseset_t &other) { s.subtract (other.s); }
+  void symmetric_difference (const hb_sparseset_t &other) { s.symmetric_difference (other.s); }
 
-      if (!sp.is_subset (lp))
-        return false;
-
-      spi++;
-    }
-
-    while (spi < page_map.length)
-      if (!page_at (spi++).is_empty ())
-        return false;
-
-    return true;
-  }
-
-  bool allocate_compact_workspace(hb_vector_t<unsigned>& workspace)
-  {
-    if (unlikely(!workspace.resize (pages.length)))
-    {
-      successful = false;
-      return false;
-    }
-
-    return true;
-  }
-
-
-  /*
-   * workspace should be a pre-sized vector allocated to hold at exactly pages.length
-   * elements.
-   */
-  void compact (hb_vector_t<unsigned>& workspace,
-                unsigned int length)
-  {
-    assert(workspace.length == pages.length);
-    hb_vector_t<unsigned>& old_index_to_page_map_index = workspace;
-
-    hb_fill (old_index_to_page_map_index.writer(), 0xFFFFFFFF);
-    /* TODO(iter) Rewrite as dagger? */
-    for (unsigned i = 0; i < length; i++)
-      old_index_to_page_map_index[page_map[i].index] =  i;
-
-    compact_pages (old_index_to_page_map_index);
-  }
-
-  void compact_pages (const hb_vector_t<unsigned>& old_index_to_page_map_index)
-  {
-    unsigned int write_index = 0;
-    for (unsigned int i = 0; i < pages.length; i++)
-    {
-      if (old_index_to_page_map_index[i] == 0xFFFFFFFF) continue;
-
-      if (write_index < i)
-	pages[write_index] = pages[i];
-
-      page_map[old_index_to_page_map_index[i]].index = write_index;
-      write_index++;
-    }
-  }
-
-  template <typename Op>
-  void process (const Op& op, const hb_set_t &other)
-  {
-    const bool passthru_left = op (1, 0);
-    const bool passthru_right = op (0, 1);
-
-    if (unlikely (!successful)) return;
-
-    dirty ();
-
-    unsigned int na = pages.length;
-    unsigned int nb = other.pages.length;
-    unsigned int next_page = na;
-
-    unsigned int count = 0, newCount = 0;
-    unsigned int a = 0, b = 0;
-    unsigned int write_index = 0;
-
-    // Pre-allocate the workspace that compact() will need so we can bail on allocation failure
-    // before attempting to rewrite the page map.
-    hb_vector_t<unsigned> compact_workspace;
-    if (!passthru_left && unlikely (!allocate_compact_workspace (compact_workspace))) return;
-
-    for (; a < na && b < nb; )
-    {
-      if (page_map[a].major == other.page_map[b].major)
-      {
-	if (!passthru_left)
-	{
-	  // Move page_map entries that we're keeping from the left side set
-	  // to the front of the page_map vector. This isn't necessary if
-	  // passthru_left is set since no left side pages will be removed
-	  // in that case.
-	  if (write_index < a)
-	    page_map[write_index] = page_map[a];
-	  write_index++;
-	}
-
-	count++;
-	a++;
-	b++;
-      }
-      else if (page_map[a].major < other.page_map[b].major)
-      {
-	if (passthru_left)
-	  count++;
-	a++;
-      }
-      else
-      {
-	if (passthru_right)
-	  count++;
-	b++;
-      }
-    }
-    if (passthru_left)
-      count += na - a;
-    if (passthru_right)
-      count += nb - b;
-
-    if (!passthru_left)
-    {
-      na  = write_index;
-      next_page = write_index;
-      compact (compact_workspace, write_index);
-    }
-
-    if (!resize (count))
-      return;
-
-    newCount = count;
-
-    /* Process in-place backward. */
-    a = na;
-    b = nb;
-    for (; a && b; )
-    {
-      if (page_map[a - 1].major == other.page_map[b - 1].major)
-      {
-	a--;
-	b--;
-	count--;
-	page_map[count] = page_map[a];
-	page_at (count).v = op (page_at (a).v, other.page_at (b).v);
-      }
-      else if (page_map[a - 1].major > other.page_map[b - 1].major)
-      {
-	a--;
-	if (passthru_left)
-	{
-	  count--;
-	  page_map[count] = page_map[a];
-	}
-      }
-      else
-      {
-	b--;
-	if (passthru_right)
-	{
-	  count--;
-	  page_map[count].major = other.page_map[b].major;
-	  page_map[count].index = next_page++;
-	  page_at (count).v = other.page_at (b).v;
-	}
-      }
-    }
-    if (passthru_left)
-      while (a)
-      {
-	a--;
-	count--;
-	page_map[count] = page_map [a];
-      }
-    if (passthru_right)
-      while (b)
-      {
-	b--;
-	count--;
-	page_map[count].major = other.page_map[b].major;
-	page_map[count].index = next_page++;
-	page_at (count).v = other.page_at (b).v;
-      }
-    assert (!count);
-    if (pages.length > newCount)
-      // This resize() doesn't need to be checked because we can't get here
-      // if the set is currently in_error() and this only resizes downwards
-      // which will always succeed if the set is not in_error().
-      resize (newCount);
-  }
-
-  void union_ (const hb_set_t &other)
-  {
-    process (hb_bitwise_or, other);
-  }
-  void intersect (const hb_set_t &other)
-  {
-    process (hb_bitwise_and, other);
-  }
-  void subtract (const hb_set_t &other)
-  {
-    process (hb_bitwise_sub, other);
-  }
-  void symmetric_difference (const hb_set_t &other)
-  {
-    process (hb_bitwise_xor, other);
-  }
-  bool next (hb_codepoint_t *codepoint) const
-  {
-    // TODO: this should be merged with prev() as both implementations
-    //       are very similar.
-    if (unlikely (*codepoint == INVALID)) {
-      *codepoint = get_min ();
-      return *codepoint != INVALID;
-    }
-
-    const auto* page_map_array = page_map.arrayZ;
-    unsigned int major = get_major (*codepoint);
-    unsigned int i = last_page_lookup;
-
-    if (unlikely (i >= page_map.length || page_map_array[i].major != major))
-    {
-      page_map.bfind (major, &i, HB_NOT_FOUND_STORE_CLOSEST);
-      if (i >= page_map.length) {
-        *codepoint = INVALID;
-        return false;
-      }
-    }
-
-    const auto* pages_array = pages.arrayZ;
-    const page_map_t &current = page_map_array[i];
-    if (likely (current.major == major))
-    {
-      if (pages_array[current.index].next (codepoint))
-      {
-        *codepoint += current.major * page_t::PAGE_BITS;
-        last_page_lookup = i;
-        return true;
-      }
-      i++;
-    }
-
-    for (; i < page_map.length; i++)
-    {
-      const page_map_t &current = page_map.arrayZ[i];
-      hb_codepoint_t m = pages_array[current.index].get_min ();
-      if (m != INVALID)
-      {
-	*codepoint = current.major * page_t::PAGE_BITS + m;
-        last_page_lookup = i;
-	return true;
-      }
-    }
-    last_page_lookup = 0;
-    *codepoint = INVALID;
-    return false;
-  }
-  bool previous (hb_codepoint_t *codepoint) const
-  {
-    if (unlikely (*codepoint == INVALID)) {
-      *codepoint = get_max ();
-      return *codepoint != INVALID;
-    }
-
-    page_map_t map = {get_major (*codepoint), 0};
-    unsigned int i;
-    page_map.bfind (map, &i, HB_NOT_FOUND_STORE_CLOSEST);
-    if (i < page_map.length && page_map[i].major == map.major)
-    {
-      if (pages[page_map[i].index].previous (codepoint))
-      {
-	*codepoint += page_map[i].major * page_t::PAGE_BITS;
-	return true;
-      }
-    }
-    i--;
-    for (; (int) i >= 0; i--)
-    {
-      hb_codepoint_t m = pages[page_map[i].index].get_max ();
-      if (m != INVALID)
-      {
-	*codepoint = page_map[i].major * page_t::PAGE_BITS + m;
-	return true;
-      }
-    }
-    *codepoint = INVALID;
-    return false;
-  }
+  bool next (hb_codepoint_t *codepoint) const { return s.next (codepoint); }
+  bool previous (hb_codepoint_t *codepoint) const { return s.previous (codepoint); }
   bool next_range (hb_codepoint_t *first, hb_codepoint_t *last) const
-  {
-    hb_codepoint_t i;
-
-    i = *last;
-    if (!next (&i))
-    {
-      *last = *first = INVALID;
-      return false;
-    }
-
-    /* TODO Speed up. */
-    *last = *first = i;
-    while (next (&i) && i == *last + 1)
-      (*last)++;
-
-    return true;
-  }
+  { return s.next_range (first, last); }
   bool previous_range (hb_codepoint_t *first, hb_codepoint_t *last) const
-  {
-    hb_codepoint_t i;
-
-    i = *first;
-    if (!previous (&i))
-    {
-      *last = *first = INVALID;
-      return false;
-    }
+  { return s.previous_range (first, last); }
 
-    /* TODO Speed up. */
-    *last = *first = i;
-    while (previous (&i) && i == *first - 1)
-      (*first)--;
+  unsigned int get_population () const { return s.get_population (); }
+  hb_codepoint_t get_min () const { return s.get_min (); }
+  hb_codepoint_t get_max () const { return s.get_max (); }
 
-    return true;
-  }
-
-  unsigned int get_population () const
-  {
-    if (population != UINT_MAX)
-      return population;
-
-    unsigned int pop = 0;
-    unsigned int count = pages.length;
-    for (unsigned int i = 0; i < count; i++)
-      pop += pages[i].get_population ();
-
-    population = pop;
-    return pop;
-  }
-  hb_codepoint_t get_min () const
-  {
-    unsigned int count = pages.length;
-    for (unsigned int i = 0; i < count; i++)
-      if (!page_at (i).is_empty ())
-	return page_map[i].major * page_t::PAGE_BITS + page_at (i).get_min ();
-    return INVALID;
-  }
-  hb_codepoint_t get_max () const
-  {
-    unsigned int count = pages.length;
-    for (int i = count - 1; i >= 0; i--)
-      if (!page_at (i).is_empty ())
-	return page_map[(unsigned) i].major * page_t::PAGE_BITS + page_at (i).get_max ();
-    return INVALID;
-  }
-
-  static constexpr hb_codepoint_t INVALID = HB_SET_VALUE_INVALID;
+  static constexpr hb_codepoint_t INVALID = impl_t::INVALID;
 
   /*
    * Iterator implementation.
    */
-  struct iter_t : hb_iter_with_fallback_t<iter_t, hb_codepoint_t>
-  {
-    static constexpr bool is_sorted_iterator = true;
-    iter_t (const hb_set_t &s_ = Null (hb_set_t),
-	    bool init = true) : s (&s_), v (INVALID), l(0)
-    {
-      if (init)
-      {
-	l = s->get_population () + 1;
-	__next__ ();
-      }
-    }
-
-    typedef hb_codepoint_t __item_t__;
-    hb_codepoint_t __item__ () const { return v; }
-    bool __more__ () const { return v != INVALID; }
-    void __next__ () { s->next (&v); if (l) l--; }
-    void __prev__ () { s->previous (&v); }
-    unsigned __len__ () const { return l; }
-    iter_t end () const { return iter_t (*s, false); }
-    bool operator != (const iter_t& o) const
-    { return s != o.s || v != o.v; }
-
-    protected:
-    const hb_set_t *s;
-    hb_codepoint_t v;
-    unsigned l;
-  };
-  iter_t iter () const { return iter_t (*this); }
+  using iter_t = typename impl_t::iter_t;
+  iter_t iter () const { return iter_t (this->s); }
   operator iter_t () const { return iter (); }
+};
 
-  protected:
+struct hb_set_t : hb_sparseset_t<hb_bit_set_invertible_t> {};
 
-  page_t *page_for_insert (hb_codepoint_t g)
-  {
-    page_map_t map = {get_major (g), pages.length};
-    unsigned int i;
-    if (!page_map.bfind (map, &i, HB_NOT_FOUND_STORE_CLOSEST))
-    {
-      if (!resize (pages.length + 1))
-	return nullptr;
-
-      pages[map.index].init0 ();
-      memmove (page_map + i + 1,
-	       page_map + i,
-	       (page_map.length - 1 - i) * page_map.item_size);
-      page_map[i] = map;
-    }
-    return &pages[page_map[i].index];
-  }
-  page_t *page_for (hb_codepoint_t g)
-  {
-    page_map_t key = {get_major (g)};
-    const page_map_t *found = page_map.bsearch (key);
-    if (found)
-      return &pages[found->index];
-    return nullptr;
-  }
-  const page_t *page_for (hb_codepoint_t g) const
-  {
-    page_map_t key = {get_major (g)};
-    const page_map_t *found = page_map.bsearch (key);
-    if (found)
-      return &pages[found->index];
-    return nullptr;
-  }
-  page_t &page_at (unsigned int i) { return pages[page_map[i].index]; }
-  const page_t &page_at (unsigned int i) const { return pages[page_map[i].index]; }
-  unsigned int get_major (hb_codepoint_t g) const { return g / page_t::PAGE_BITS; }
-  hb_codepoint_t major_start (unsigned int major) const { return major * page_t::PAGE_BITS; }
-};
+static_assert (hb_set_t::INVALID == HB_SET_VALUE_INVALID, "");
 
 
 #endif /* HB_SET_HH */
diff --git a/src/hb-shape-plan.cc b/src/hb-shape-plan.cc
index aa7da2db3..66332165c 100644
--- a/src/hb-shape-plan.cc
+++ b/src/hb-shape-plan.cc
@@ -388,58 +388,58 @@ static bool
 _hb_shape_plan_execute_internal (hb_shape_plan_t    *shape_plan,
 				 hb_font_t          *font,
 				 hb_buffer_t        *buffer,
 				 const hb_feature_t *features,
 				 unsigned int        num_features)
 {
   DEBUG_MSG_FUNC (SHAPE_PLAN, shape_plan,
 		  "num_features=%d shaper_func=%p, shaper_name=%s",
 		  num_features,
 		  shape_plan->key.shaper_func,
 		  shape_plan->key.shaper_name);
 
   if (unlikely (!buffer->len))
     return true;
 
   assert (!hb_object_is_immutable (buffer));
 
   buffer->assert_unicode ();
 
-  if (unlikely (hb_object_is_inert (shape_plan)))
+  if (unlikely (!hb_object_is_valid (shape_plan)))
     return false;
 
   assert (shape_plan->face_unsafe == font->face);
   assert (hb_segment_properties_equal (&shape_plan->key.props, &buffer->props));
 
 #define HB_SHAPER_EXECUTE(shaper) \
 	HB_STMT_START { \
 	  return font->data.shaper && \
 		 _hb_##shaper##_shape (shape_plan, font, buffer, features, num_features); \
 	} HB_STMT_END
 
   if (false)
     ;
 #define HB_SHAPER_IMPLEMENT(shaper) \
   else if (shape_plan->key.shaper_func == _hb_##shaper##_shape) \
     HB_SHAPER_EXECUTE (shaper);
 #include "hb-shaper-list.hh"
 #undef HB_SHAPER_IMPLEMENT
 
 #undef HB_SHAPER_EXECUTE
 
   return false;
 }
 /**
  * hb_shape_plan_execute:
  * @shape_plan: A shaping plan
  * @font: The #hb_font_t to use
  * @buffer: The #hb_buffer_t to work upon
  * @features: (array length=num_features): Features to enable
  * @num_features: The number of features to enable
  *
  * Executes the given shaping plan on the specified buffer, using
  * the given @font and @features.
  *
  * Return value: %true if success, %false otherwise.
  *
  * Since: 0.9.7
  **/
@@ -529,51 +529,51 @@ hb_shape_plan_create_cached2 (hb_face_t                     *face,
 retry:
   hb_face_t::plan_node_t *cached_plan_nodes = face->shape_plans;
 
-  bool dont_cache = hb_object_is_inert (face);
+  bool dont_cache = !hb_object_is_valid (face);
 
   if (likely (!dont_cache))
   {
     hb_shape_plan_key_t key;
     if (!key.init (false,
 		   face,
 		   props,
 		   user_features,
 		   num_user_features,
 		   coords,
 		   num_coords,
 		   shaper_list))
       return hb_shape_plan_get_empty ();
 
     for (hb_face_t::plan_node_t *node = cached_plan_nodes; node; node = node->next)
       if (node->shape_plan->key.equal (&key))
       {
 	DEBUG_MSG_FUNC (SHAPE_PLAN, node->shape_plan, "fulfilled from cache");
 	return hb_shape_plan_reference (node->shape_plan);
       }
   }
 
   hb_shape_plan_t *shape_plan = hb_shape_plan_create2 (face, props,
 						       user_features, num_user_features,
 						       coords, num_coords,
 						       shaper_list);
 
   if (unlikely (dont_cache))
     return shape_plan;
 
   hb_face_t::plan_node_t *node = (hb_face_t::plan_node_t *) hb_calloc (1, sizeof (hb_face_t::plan_node_t));
   if (unlikely (!node))
     return shape_plan;
 
   node->shape_plan = shape_plan;
   node->next = cached_plan_nodes;
 
   if (unlikely (!face->shape_plans.cmpexch (cached_plan_nodes, node)))
   {
     hb_shape_plan_destroy (shape_plan);
     hb_free (node);
     goto retry;
   }
   DEBUG_MSG_FUNC (SHAPE_PLAN, shape_plan, "inserted into cache");
 
   return hb_shape_plan_reference (shape_plan);
 }
diff --git a/src/meson.build b/src/meson.build
index e7093cb29..cbe57e9eb 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -8,172 +8,173 @@ hb_version_h = configure_file(
 # Base and default-included sources and headers
 hb_base_sources = files(
   'hb-aat-layout-ankr-table.hh',
   'hb-aat-layout-bsln-table.hh',
   'hb-aat-layout-common.hh',
   'hb-aat-layout-feat-table.hh',
   'hb-aat-layout-just-table.hh',
   'hb-aat-layout-kerx-table.hh',
   'hb-aat-layout-morx-table.hh',
   'hb-aat-layout-opbd-table.hh',
   'hb-aat-layout-trak-table.hh',
   'hb-aat-layout.cc',
   'hb-aat-layout.hh',
   'hb-aat-ltag-table.hh',
   'hb-aat-map.cc',
   'hb-aat-map.hh',
   'hb-algs.hh',
   'hb-array.hh',
   'hb-atomic.hh',
   'hb-bimap.hh',
+  'hb-bit-page.hh',
   'hb-blob.cc',
   'hb-blob.hh',
   'hb-buffer-serialize.cc',
   'hb-buffer.cc',
   'hb-buffer.hh',
   'hb-cache.hh',
   'hb-cff-interp-common.hh',
   'hb-cff-interp-cs-common.hh',
   'hb-cff-interp-dict-common.hh',
   'hb-cff1-interp-cs.hh',
   'hb-cff2-interp-cs.hh',
   'hb-common.cc',
   'hb-config.hh',
   'hb-debug.hh',
   'hb-dispatch.hh',
   'hb-draw.cc',
   'hb-draw.hh',
   'hb-face.cc',
   'hb-face.hh',
   'hb-fallback-shape.cc',
   'hb-font.cc',
   'hb-font.hh',
   'hb-iter.hh',
   'hb-kern.hh',
   'hb-machinery.hh',
   'hb-map.cc',
   'hb-map.hh',
   'hb-meta.hh',
   'hb-ms-feature-ranges.cc',
   'hb-ms-feature-ranges.hh',
   'hb-mutex.hh',
   'hb-null.hh',
   'hb-number.cc',
   'hb-number.hh',
   'hb-object.hh',
   'hb-open-file.hh',
   'hb-open-type.hh',
   'hb-ot-cff-common.hh',
   'hb-ot-cff1-std-str.hh',
   'hb-ot-cff1-table.cc',
   'hb-ot-cff1-table.hh',
   'hb-ot-cff2-table.cc',
   'hb-ot-cff2-table.hh',
   'hb-ot-cmap-table.hh',
   'hb-ot-color-cbdt-table.hh',
   'hb-ot-color-colr-table.hh',
   'hb-ot-color-cpal-table.hh',
   'hb-ot-color-sbix-table.hh',
   'hb-ot-color-svg-table.hh',
   'hb-ot-color.cc',
   'hb-ot-face-table-list.hh',
   'hb-ot-face.cc',
   'hb-ot-face.hh',
   'hb-ot-font.cc',
   'hb-ot-gasp-table.hh',
   'hb-ot-glyf-table.hh',
   'hb-ot-hdmx-table.hh',
   'hb-ot-head-table.hh',
   'hb-ot-hhea-table.hh',
   'hb-ot-hmtx-table.hh',
   'hb-ot-kern-table.hh',
   'hb-ot-layout-base-table.hh',
   'hb-ot-layout-common.hh',
   'hb-ot-layout-gdef-table.hh',
   'hb-ot-layout-gpos-table.hh',
   'hb-ot-layout-gsub-table.hh',
   'hb-ot-layout-gsubgpos.hh',
   'hb-ot-layout-jstf-table.hh',
   'hb-ot-layout.cc',
   'hb-ot-layout.hh',
   'hb-ot-map.cc',
   'hb-ot-map.hh',
   'hb-ot-math-table.hh',
   'hb-ot-math.cc',
   'hb-ot-maxp-table.hh',
   'hb-ot-meta-table.hh',
   'hb-ot-meta.cc',
   'hb-ot-metrics.cc',
   'hb-ot-metrics.hh',
   'hb-ot-name-language-static.hh',
   'hb-ot-name-language.hh',
   'hb-ot-name-table.hh',
   'hb-ot-name.cc',
   'hb-ot-os2-table.hh',
   'hb-ot-os2-unicode-ranges.hh',
   'hb-ot-post-macroman.hh',
   'hb-ot-post-table.hh',
   'hb-ot-shape-complex-arabic-fallback.hh',
   'hb-ot-shape-complex-arabic-joining-list.hh',
   'hb-ot-shape-complex-arabic-table.hh',
   'hb-ot-shape-complex-arabic-win1256.hh',
   'hb-ot-shape-complex-arabic.cc',
   'hb-ot-shape-complex-arabic.hh',
   'hb-ot-shape-complex-default.cc',
   'hb-ot-shape-complex-hangul.cc',
   'hb-ot-shape-complex-hebrew.cc',
   'hb-ot-shape-complex-indic-table.cc',
   'hb-ot-shape-complex-indic.cc',
   'hb-ot-shape-complex-indic.hh',
   'hb-ot-shape-complex-khmer.cc',
   'hb-ot-shape-complex-khmer.hh',
   'hb-ot-shape-complex-myanmar.cc',
   'hb-ot-shape-complex-myanmar.hh',
   'hb-ot-shape-complex-syllabic.cc',
   'hb-ot-shape-complex-syllabic.hh',
   'hb-ot-shape-complex-thai.cc',
   'hb-ot-shape-complex-use-table.hh',
   'hb-ot-shape-complex-use.cc',
   'hb-ot-shape-complex-vowel-constraints.cc',
   'hb-ot-shape-complex-vowel-constraints.hh',
   'hb-ot-shape-complex.hh',
   'hb-ot-shape-fallback.cc',
   'hb-ot-shape-fallback.hh',
   'hb-ot-shape-normalize.cc',
   'hb-ot-shape-normalize.hh',
   'hb-ot-shape.cc',
   'hb-ot-shape.hh',
   'hb-ot-stat-table.hh',
   'hb-ot-tag-table.hh',
   'hb-ot-tag.cc',
   'hb-ot-var-avar-table.hh',
   'hb-ot-var-fvar-table.hh',
   'hb-ot-var-gvar-table.hh',
   'hb-ot-var-hvar-table.hh',
   'hb-ot-var-mvar-table.hh',
   'hb-ot-var.cc',
   'hb-ot-vorg-table.hh',
   'hb-pool.hh',
   'hb-sanitize.hh',
   'hb-serialize.hh',
   'hb-set-digest.hh',
   'hb-set.cc',
   'hb-set.hh',
   'hb-shape-plan.cc',
   'hb-shape-plan.hh',
   'hb-shape.cc',
   'hb-shaper-impl.hh',
   'hb-shaper-list.hh',
   'hb-shaper.cc',
   'hb-shaper.hh',
   'hb-static.cc',
   'hb-string-array.hh',
   'hb-style.cc',
   'hb-ucd-table.hh',
   'hb-ucd.cc',
   'hb-unicode-emoji-table.hh',
   'hb-unicode.cc',
   'hb-unicode.hh',
   'hb-utf.hh',
   'hb-vector.hh',
   'hb.hh',
 )
diff --git a/test/api/test-set.c b/test/api/test-set.c
index 21a48ffa6..eb32472b5 100644
--- a/test/api/test-set.c
+++ b/test/api/test-set.c
@@ -574,21 +574,508 @@ test_set_delrange (void)
   hb_set_destroy (s);
 }
 
+static const unsigned max_set_elements = -1;
+
+static void
+test_set_inverted_basics (void)
+{
+  // Tests:
+  // add, del, has, get_population, is_empty, get_min, get_max
+  // for inverted sets.
+  hb_set_t *s = hb_set_create ();
+  hb_set_invert (s);
+
+  g_assert_cmpint (hb_set_get_population (s), ==, max_set_elements);
+  g_assert (hb_set_has (s, 0));
+  g_assert (hb_set_has (s, 13));
+  g_assert (hb_set_has (s, max_set_elements - 1));
+  g_assert (!hb_set_is_empty (s));
+  g_assert_cmpint (hb_set_get_min (s), ==, 0);
+  g_assert_cmpint (hb_set_get_max (s), ==, max_set_elements - 1);
+
+  hb_set_del (s, 13);
+  g_assert (!hb_set_has (s, 13));
+  g_assert_cmpint (hb_set_get_population (s), ==, max_set_elements - 1);
+  g_assert_cmpint (hb_set_get_min (s), ==, 0);
+  g_assert_cmpint (hb_set_get_max (s), ==, max_set_elements - 1);
+
+  hb_set_add (s, 13);
+  g_assert (hb_set_has (s, 13));
+  g_assert_cmpint (hb_set_get_population (s), ==, max_set_elements);
+
+  hb_set_del (s, 0);
+  hb_set_del (s, max_set_elements - 1);
+  g_assert (!hb_set_has (s, 0));
+  g_assert (hb_set_has (s, 13));
+  g_assert (!hb_set_has (s, max_set_elements - 1));
+  g_assert (!hb_set_is_empty (s));
+  g_assert_cmpint (hb_set_get_population (s), ==, max_set_elements - 2);
+  g_assert_cmpint (hb_set_get_min (s), ==, 1);
+  g_assert_cmpint (hb_set_get_max (s), ==, max_set_elements - 2);
+
+  hb_set_destroy (s);
+}
+
+static void
+test_set_inverted_ranges (void)
+{
+  // Tests:
+  // add_range, del_range, has, get_population, is_empty, get_min, get_max
+  // for inverted sets.
+  hb_set_t *s = hb_set_create ();
+  hb_set_invert (s);
+
+  hb_set_del_range (s, 41, 4000);
+  hb_set_add_range (s, 78, 601);
+
+  g_assert (hb_set_has (s, 40));
+  g_assert (!hb_set_has (s, 41));
+  g_assert (!hb_set_has (s, 64));
+  g_assert (!hb_set_has (s, 77));
+  g_assert (hb_set_has (s, 78));
+  g_assert (hb_set_has (s, 300));
+  g_assert (hb_set_has (s, 601));
+  g_assert (!hb_set_has (s, 602));
+  g_assert (!hb_set_has (s, 3000));
+  g_assert (!hb_set_has (s, 4000));
+  g_assert (hb_set_has (s, 4001));
+
+  g_assert (!hb_set_is_empty (s));
+  g_assert_cmpint (hb_set_get_population (s), ==, max_set_elements - 3436);
+  g_assert_cmpint (hb_set_get_min (s), ==, 0);
+  g_assert_cmpint (hb_set_get_max (s), ==, max_set_elements - 1);
+
+  hb_set_del_range (s, 0, 37);
+  g_assert (!hb_set_has (s, 0));
+  g_assert (!hb_set_has (s, 37));
+  g_assert (hb_set_has (s, 38));
+  g_assert (!hb_set_is_empty (s));
+  g_assert_cmpint (hb_set_get_population (s), ==,
+                   max_set_elements - 3436 - 38);
+  g_assert_cmpint (hb_set_get_min (s), ==, 38);
+  g_assert_cmpint (hb_set_get_max (s), ==, max_set_elements - 1);
+
+  hb_set_del_range (s, max_set_elements - 13, max_set_elements - 1);
+  g_assert (!hb_set_has (s, max_set_elements - 1));
+  g_assert (!hb_set_has (s, max_set_elements - 13));
+  g_assert (hb_set_has (s, max_set_elements - 14));
+
+  g_assert (!hb_set_is_empty (s));
+  g_assert_cmpint (hb_set_get_population (s), ==,
+                   max_set_elements - 3436 - 38 - 13);
+  g_assert_cmpint (hb_set_get_min (s), ==, 38);
+  g_assert_cmpint (hb_set_get_max (s), ==, max_set_elements - 14);
+
+  hb_set_destroy (s);
+}
+
+static void
+test_set_inverted_iteration_next (void)
+{
+  // Tests:
+  // next, next_range
+  hb_set_t *s = hb_set_create ();
+  hb_set_invert (s);
+
+  hb_set_del_range (s, 41, 4000);
+  hb_set_add_range (s, 78, 601);
+
+  hb_codepoint_t cp = HB_SET_VALUE_INVALID;
+  hb_codepoint_t start = 0;
+  hb_codepoint_t end = 0;
+  g_assert (hb_set_next (s, &cp));
+  g_assert_cmpint (cp, ==, 0);
+  g_assert (hb_set_next (s, &cp));
+  g_assert_cmpint (cp, ==, 1);
+
+  g_assert (hb_set_next_range (s, &start, &end));
+  g_assert_cmpint (start, ==, 1);
+  g_assert_cmpint (end, ==, 40);
+
+  start = 40;
+  end = 40;
+  g_assert (hb_set_next_range (s, &start, &end));
+  g_assert_cmpint (start, ==, 78);
+  g_assert_cmpint (end, ==, 601);
+
+  start = 40;
+  end = 57;
+  g_assert (hb_set_next_range (s, &start, &end));
+  g_assert_cmpint (start, ==, 78);
+  g_assert_cmpint (end, ==, 601);
+
+  cp = 39;
+  g_assert (hb_set_next (s, &cp));
+  g_assert_cmpint (cp, ==, 40);
+
+  g_assert (hb_set_next (s, &cp));
+  g_assert_cmpint (cp, ==, 78);
+
+  cp = 56;
+  g_assert (hb_set_next (s, &cp));
+  g_assert_cmpint (cp, ==, 78);
+
+  cp = 78;
+  g_assert (hb_set_next (s, &cp));
+  g_assert_cmpint (cp, ==, 79);
+
+  cp = 601;
+  g_assert (hb_set_next (s, &cp));
+  g_assert_cmpint (cp, ==, 4001);
+
+  cp = HB_SET_VALUE_INVALID;
+  hb_set_del (s, 0);
+  g_assert (hb_set_next (s, &cp));
+  g_assert_cmpint (cp, ==, 1);
+
+  start = 0;
+  end = 0;
+  g_assert (hb_set_next_range (s, &start, &end));
+  g_assert_cmpint (start, ==, 1);
+  g_assert_cmpint (end, ==, 40);
+
+  cp = max_set_elements - 1;
+  g_assert (!hb_set_next (s, &cp));
+  g_assert_cmpint (cp, ==, HB_SET_VALUE_INVALID);
+
+  start = 4000;
+  end = 4000;
+  g_assert (hb_set_next_range (s, &start, &end));
+  g_assert_cmpint (start, ==, 4001);
+  g_assert_cmpint (end, ==, max_set_elements - 1);
+
+  start = max_set_elements - 1;
+  end = max_set_elements - 1;
+  g_assert (!hb_set_next_range (s, &start, &end));
+  g_assert_cmpint (start, ==, HB_SET_VALUE_INVALID);
+  g_assert_cmpint (end, ==, HB_SET_VALUE_INVALID);
+
+  cp = max_set_elements - 3;
+  hb_set_del (s, max_set_elements - 1);
+  g_assert (hb_set_next (s, &cp));
+  g_assert_cmpint (cp, ==, max_set_elements - 2);
+  g_assert (!hb_set_next (s, &cp));
+  g_assert_cmpint (cp, ==, HB_SET_VALUE_INVALID);
+
+
+  start = max_set_elements - 2;
+  end = max_set_elements - 2;
+  g_assert (!hb_set_next_range (s, &start, &end));
+  g_assert_cmpint (start, ==, HB_SET_VALUE_INVALID);
+  g_assert_cmpint (end, ==, HB_SET_VALUE_INVALID);
+
+  start = max_set_elements - 3;
+  end = max_set_elements - 3;
+  g_assert (hb_set_next_range (s, &start, &end));
+  g_assert_cmpint (start, ==, max_set_elements - 2);
+  g_assert_cmpint (end, ==, max_set_elements - 2);
+
+  hb_set_destroy (s);
+}
+
+static void
+test_set_inverted_iteration_prev (void)
+{
+  // Tests:
+  // previous, previous_range
+  hb_set_t *s = hb_set_create ();
+  hb_set_invert (s);
+
+  hb_set_del_range (s, 41, 4000);
+  hb_set_add_range (s, 78, 601);
+
+  hb_codepoint_t cp = HB_SET_VALUE_INVALID;
+  hb_codepoint_t start = max_set_elements - 1;
+  hb_codepoint_t end = max_set_elements - 1;
+  g_assert (hb_set_previous (s, &cp));
+  g_assert_cmpint (cp, ==, max_set_elements - 1);
+  g_assert (hb_set_previous (s, &cp));
+  g_assert_cmpint (cp, ==, max_set_elements - 2);
+
+  g_assert (hb_set_previous_range (s, &start, &end));
+  g_assert_cmpint (start, ==, 4001);
+  g_assert_cmpint (end, ==, max_set_elements - 2);
+
+  start = 4001;
+  end = 4001;
+  g_assert (hb_set_previous_range (s, &start, &end));
+  g_assert_cmpint (start, ==, 78);
+  g_assert_cmpint (end, ==, 601);
+
+  start = 2500;
+  end = 3000;
+  g_assert (hb_set_previous_range (s, &start, &end));
+  g_assert_cmpint (start, ==, 78);
+  g_assert_cmpint (end, ==, 601);
+
+  cp = 4002;
+  g_assert (hb_set_previous (s, &cp));
+  g_assert_cmpint (cp, ==, 4001);
+
+  g_assert (hb_set_previous (s, &cp));
+  g_assert_cmpint (cp, ==, 601);
+
+  cp = 3500;
+  g_assert (hb_set_previous (s, &cp));
+  g_assert_cmpint (cp, ==, 601);
+
+  cp = 601;
+  g_assert (hb_set_previous (s, &cp));
+  g_assert_cmpint (cp, ==, 600);
+
+  cp = 78;
+  g_assert (hb_set_previous (s, &cp));
+  g_assert_cmpint (cp, ==, 40);
+
+  cp = HB_SET_VALUE_INVALID;
+  hb_set_del (s, max_set_elements - 1);
+  g_assert (hb_set_previous (s, &cp));
+  g_assert_cmpint (cp, ==, max_set_elements - 2);
+
+  start = max_set_elements - 1;
+  end = max_set_elements - 1;
+  g_assert (hb_set_previous_range (s, &start, &end));
+  g_assert_cmpint (start, ==, 4001);
+  g_assert_cmpint (end, ==, max_set_elements - 2);
+
+  cp = 0;
+  g_assert (!hb_set_previous (s, &cp));
+  g_assert_cmpint (cp, ==, HB_SET_VALUE_INVALID);
+
+  cp = 40;
+  g_assert (hb_set_previous (s, &cp));
+  g_assert_cmpint (cp, ==, 39);
+
+  start = 40;
+  end = 40;
+  g_assert (hb_set_previous_range (s, &start, &end));
+  g_assert_cmpint (start, ==, 0);
+  g_assert_cmpint (end, ==, 39);
+
+  start = 0;
+  end = 0;
+  g_assert (!hb_set_previous_range (s, &start, &end));
+  g_assert_cmpint (start, ==, HB_SET_VALUE_INVALID);
+  g_assert_cmpint (end, ==, HB_SET_VALUE_INVALID);
+
+
+  cp = 2;
+  hb_set_del (s, 0);
+  g_assert (hb_set_previous (s, &cp));
+  g_assert_cmpint (cp, ==, 1);
+  g_assert (!hb_set_previous (s, &cp));
+  g_assert_cmpint (cp, ==, HB_SET_VALUE_INVALID);
+
+  start = 1;
+  end = 1;
+  g_assert (!hb_set_previous_range (s, &start, &end));
+  g_assert_cmpint (start, ==, HB_SET_VALUE_INVALID);
+  g_assert_cmpint (end, ==, HB_SET_VALUE_INVALID);
+
+  start = 2;
+  end = 2;
+  g_assert (hb_set_previous_range (s, &start, &end));
+  g_assert_cmpint (start, ==, 1);
+  g_assert_cmpint (end, ==, 1);
+
+  hb_set_destroy (s);
+}
+
+
+static void
+test_set_inverted_equality (void)
+{
+  hb_set_t *a = hb_set_create ();
+  hb_set_t *b = hb_set_create ();
+  hb_set_invert (a);
+  hb_set_invert (b);
+
+  g_assert (hb_set_is_equal (a, b));
+  g_assert (hb_set_is_equal (b, a));
+
+  hb_set_add (a, 10);
+  g_assert (hb_set_is_equal (a, b));
+  g_assert (hb_set_is_equal (b, a));
+
+  hb_set_del (a, 42);
+  g_assert (!hb_set_is_equal (a, b));
+  g_assert (!hb_set_is_equal (b, a));
+
+  hb_set_del (b, 42);
+  g_assert (hb_set_is_equal (a, b));
+  g_assert (hb_set_is_equal (b, a));
+
+  hb_set_del_range (a, 43, 50);
+  hb_set_del_range (a, 51, 76);
+  hb_set_del_range (b, 43, 76);
+  g_assert (hb_set_is_equal (a, b));
+  g_assert (hb_set_is_equal (b, a));
+
+  hb_set_del (a, 0);
+  g_assert (!hb_set_is_equal (a, b));
+  g_assert (!hb_set_is_equal (b, a));
+
+  hb_set_del (b, 0);
+  g_assert (hb_set_is_equal (a, b));
+  g_assert (hb_set_is_equal (b, a));
+
+  hb_set_del (a, max_set_elements - 1);
+  g_assert (!hb_set_is_equal (a, b));
+  g_assert (!hb_set_is_equal (b, a));
+
+  hb_set_del (b, max_set_elements - 1);
+  g_assert (hb_set_is_equal (a, b));
+  g_assert (hb_set_is_equal (b, a));
+
+  hb_set_invert (a);
+  g_assert (!hb_set_is_equal (a, b));
+  g_assert (!hb_set_is_equal (b, a));
+
+  hb_set_invert (b);
+  g_assert (hb_set_is_equal (a, b));
+  g_assert (hb_set_is_equal (b, a));
+
+  hb_set_destroy (a);
+  hb_set_destroy (b);
+}
+
+typedef enum {
+  UNION = 0,
+  INTERSECT,
+  SUBTRACT,
+  SYM_DIFF,
+  LAST,
+} set_operation;
+
+static hb_set_t* prepare_set(hb_bool_t has_x,
+                             hb_bool_t inverted,
+                             hb_bool_t has_page)
+{
+  static const hb_codepoint_t x = 13;
+  hb_set_t* s = hb_set_create ();
+  if (inverted) hb_set_invert (s);
+  if (has_page)
+  {
+    // Ensure a page exists for x.
+    inverted ? hb_set_del (s, x) : hb_set_add (s, x);
+  }
+  if (has_x)
+    hb_set_add (s, x);
+  else
+    hb_set_del (s, x);
+
+  return s;
+}
+
+static hb_bool_t
+check_set_operations(hb_bool_t a_has_x,
+                     hb_bool_t a_inverted,
+                     hb_bool_t a_has_page,
+                     hb_bool_t b_has_x,
+                     hb_bool_t b_inverted,
+                     hb_bool_t b_has_page,
+                     set_operation op)
+{
+  hb_codepoint_t x = 13;
+  hb_set_t* a = prepare_set (a_has_x, a_inverted, a_has_page);
+  hb_set_t* b = prepare_set (b_has_x, b_inverted, b_has_page);
+
+  char* op_name;
+  hb_bool_t has_expected;
+  hb_bool_t should_have_x;
+  switch (op) {
+  case UNION:
+  default:
+    op_name = "union";
+    should_have_x = (a_has_x || b_has_x);
+    hb_set_union (a, b);
+    has_expected = (hb_set_has (a, x) == should_have_x);
+    break;
+  case INTERSECT:
+    op_name = "intersect";
+    should_have_x = (a_has_x && b_has_x);
+    hb_set_intersect (a, b);
+    has_expected = (hb_set_has (a, x) == should_have_x);
+    break;
+  case SUBTRACT:
+    op_name = "subtract";
+    should_have_x = (a_has_x && !b_has_x);
+    hb_set_subtract (a, b);
+    has_expected = (hb_set_has (a, x) == should_have_x);
+    break;
+  case SYM_DIFF:
+    op_name = "sym_diff";
+    should_have_x = (a_has_x ^ b_has_x);
+    hb_set_symmetric_difference (a, b);
+    has_expected = (hb_set_has (a, x) == should_have_x);
+    break;
+  }
+
+  printf ("%s%s%s %-9s %s%s%s == %s  [%s]\n",
+          a_inverted ? "i" : " ",
+          a_has_page ? "p" : " ",
+          a_has_x ? "{13}" : "{}  ",
+          op_name,
+          b_inverted ? "i" : " ",
+          b_has_page ? "p" : " ",
+          b_has_x ? "{13}" : "{}  ",
+          should_have_x ? "{13}" : "{}  ",
+          has_expected ? "succeeded" : "failed");
+
+  hb_set_destroy (a);
+  hb_set_destroy (b);
+
+  return has_expected;
+}
+
+static void
+test_set_inverted_operations (void)
+{
+  hb_bool_t all_succeeded = 1;
+  for (hb_bool_t a_has_x = 0; a_has_x <= 1; a_has_x++) {
+    for (hb_bool_t a_inverted = 0; a_inverted <= 1; a_inverted++) {
+      for (hb_bool_t b_has_x = 0; b_has_x <= 1; b_has_x++) {
+        for (hb_bool_t b_inverted = 0; b_inverted <= 1; b_inverted++) {
+          for (hb_bool_t a_has_page = 0; a_has_page <= !(a_has_x ^ a_inverted); a_has_page++) {
+            for (hb_bool_t b_has_page = 0; b_has_page <= !(b_has_x ^ b_inverted); b_has_page++) {
+              for (set_operation op = UNION; op < LAST; op++) {
+                all_succeeded = check_set_operations (a_has_x, a_inverted, a_has_page,
+                                                      b_has_x, b_inverted, b_has_page,
+                                                      op)
+                                && all_succeeded;
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+
+  g_assert (all_succeeded);
+}
+
 int
 main (int argc, char **argv)
 {
   hb_test_init (&argc, &argv);
 
   hb_test_add (test_set_basic);
   hb_test_add (test_set_subsets);
   hb_test_add (test_set_algebra);
   hb_test_add (test_set_iter);
   hb_test_add (test_set_empty);
   hb_test_add (test_set_delrange);
 
   hb_test_add (test_set_intersect_empty);
   hb_test_add (test_set_intersect_page_reduction);
   hb_test_add (test_set_union);
 
+  hb_test_add (test_set_inverted_basics);
+  hb_test_add (test_set_inverted_ranges);
+  hb_test_add (test_set_inverted_iteration_next);
+  hb_test_add (test_set_inverted_iteration_prev);
+  hb_test_add (test_set_inverted_equality);
+  hb_test_add (test_set_inverted_operations);
+
   return hb_test_run();
 }
diff --git a/util/hb-subset.cc b/util/hb-subset.cc
index b30614179..be135d1ba 100644
--- a/util/hb-subset.cc
+++ b/util/hb-subset.cc
@@ -39,115 +39,121 @@
 struct subset_main_t : option_parser_t, face_options_t, output_options_t<false>
 {
   subset_main_t ()
   : input (hb_subset_input_create_or_fail ())
   {}
   ~subset_main_t ()
   {
     hb_subset_input_destroy (input);
   }
 
   void parse_face (int argc, const char * const *argv)
   {
     option_parser_t parser;
     face_options_t face_opts;
 
     face_opts.add_options (&parser);
 
     GOptionEntry entries[] =
     {
       {G_OPTION_REMAINING,	0, G_OPTION_FLAG_IN_MAIN,
 				G_OPTION_ARG_CALLBACK,	(gpointer) &collect_face,	nullptr,	"[FONT-FILE] [TEXT]"},
       {nullptr}
     };
     parser.add_main_group (entries, &face_opts);
 
     g_option_context_set_ignore_unknown_options (parser.context, true);
     g_option_context_set_help_enabled (parser.context, false);
 
-    char **args = (char **) g_memdup (argv, argc * sizeof (*argv));
+    char **args = (char **)
+#if GLIB_CHECK_VERSION (2, 68, 0)
+      g_memdup2
+#else
+      g_memdup
+#endif
+      (argv, argc * sizeof (*argv));
     parser.parse (&argc, &args, true);
     g_free (args);
 
     set_face (face_opts.face);
   }
 
   void parse (int argc, char **argv)
   {
     /* Do a preliminary parse to load font-face, such that we can use it
      * during main option parsing. */
     parse_face (argc, argv);
 
     add_options ();
     option_parser_t::parse (&argc, &argv);
   }
 
   int operator () (int argc, char **argv)
   {
     parse (argc, argv);
 
     hb_face_t *new_face = nullptr;
     for (unsigned i = 0; i < num_iterations; i++)
     {
       hb_face_destroy (new_face);
       new_face = hb_subset_or_fail (face, input);
     }
 
     bool success = new_face;
     if (success)
     {
       hb_blob_t *result = hb_face_reference_blob (new_face);
       write_file (output_file, result);
       hb_blob_destroy (result);
     }
 
     hb_face_destroy (new_face);
 
     return success ? 0 : 1;
   }
 
   bool
   write_file (const char *output_file, hb_blob_t *blob)
   {
     assert (out_fp);
 
     unsigned int size;
     const char* data = hb_blob_get_data (blob, &size);
 
     while (size)
     {
       size_t ret = fwrite (data, 1, size, out_fp);
       size -= ret;
       data += ret;
       if (size && ferror (out_fp))
         fail (false, "Failed to write output: %s", strerror (errno));
     }
 
     return true;
   }
 
   void
   add_all_unicodes ()
   {
     hb_set_t *codepoints = hb_subset_input_unicode_set (input);
     hb_face_collect_unicodes (face, codepoints);
   }
 
   void add_options ();
 
   protected:
   static gboolean
   collect_face (const char *name,
 		const char *arg,
 		gpointer    data,
 		GError    **error);
   static gboolean
   collect_rest (const char *name,
 		const char *arg,
 		gpointer    data,
 		GError    **error);
 
   public:
 
   unsigned num_iterations = 1;
   hb_subset_input_t *input = nullptr;
 };
