commit ab05e50ec44506dc81220a21fb8f5e8d048772e0
Author: Keith Winstein <keithw@cs.stanford.edu>
Date:   Wed Sep 6 15:54:12 2023 -0700

    Share reading/validation code between elem exprs & other const exprs (#2288)
    
    This continues the work from #1783 and reduces special handling of elem
    exprs, by treating them the same as other const expressions (init
    expressions).

diff --git a/include/wabt/binary-reader-logging.h b/include/wabt/binary-reader-logging.h
index 9ce32aca..65c5ac66 100644
--- a/include/wabt/binary-reader-logging.h
+++ b/include/wabt/binary-reader-logging.h
@@ -26,399 +26,398 @@ class Stream;
 class BinaryReaderLogging : public BinaryReaderDelegate {
  public:
   BinaryReaderLogging(Stream*, BinaryReaderDelegate* forward);
 
   bool OnError(const Error&) override;
   void OnSetState(const State* s) override;
 
   Result BeginModule(uint32_t version) override;
   Result EndModule() override;
 
   Result BeginSection(Index section_index,
                       BinarySection section_type,
                       Offset size) override;
 
   Result BeginCustomSection(Index section_index,
                             Offset size,
                             std::string_view section_name) override;
   Result EndCustomSection() override;
 
   Result BeginTypeSection(Offset size) override;
   Result OnTypeCount(Index count) override;
   Result OnFuncType(Index index,
                     Index param_count,
                     Type* param_types,
                     Index result_count,
                     Type* result_types) override;
   Result OnStructType(Index index, Index field_count, TypeMut* fields) override;
   Result OnArrayType(Index index, TypeMut field) override;
   Result EndTypeSection() override;
 
   Result BeginImportSection(Offset size) override;
   Result OnImportCount(Index count) override;
   Result OnImport(Index index,
                   ExternalKind kind,
                   std::string_view module_name,
                   std::string_view field_name) override;
   Result OnImportFunc(Index import_index,
                       std::string_view module_name,
                       std::string_view field_name,
                       Index func_index,
                       Index sig_index) override;
   Result OnImportTable(Index import_index,
                        std::string_view module_name,
                        std::string_view field_name,
                        Index table_index,
                        Type elem_type,
                        const Limits* elem_limits) override;
   Result OnImportMemory(Index import_index,
                         std::string_view module_name,
                         std::string_view field_name,
                         Index memory_index,
                         const Limits* page_limits) override;
   Result OnImportGlobal(Index import_index,
                         std::string_view module_name,
                         std::string_view field_name,
                         Index global_index,
                         Type type,
                         bool mutable_) override;
   Result OnImportTag(Index import_index,
                      std::string_view module_name,
                      std::string_view field_name,
                      Index tag_index,
                      Index sig_index) override;
   Result EndImportSection() override;
 
   Result BeginFunctionSection(Offset size) override;
   Result OnFunctionCount(Index count) override;
   Result OnFunction(Index index, Index sig_index) override;
   Result EndFunctionSection() override;
 
   Result BeginTableSection(Offset size) override;
   Result OnTableCount(Index count) override;
   Result OnTable(Index index,
                  Type elem_type,
                  const Limits* elem_limits) override;
   Result EndTableSection() override;
 
   Result BeginMemorySection(Offset size) override;
   Result OnMemoryCount(Index count) override;
   Result OnMemory(Index index, const Limits* limits) override;
   Result EndMemorySection() override;
 
   Result BeginGlobalSection(Offset size) override;
   Result OnGlobalCount(Index count) override;
   Result BeginGlobal(Index index, Type type, bool mutable_) override;
   Result BeginGlobalInitExpr(Index index) override;
   Result EndGlobalInitExpr(Index index) override;
   Result EndGlobal(Index index) override;
   Result EndGlobalSection() override;
 
   Result BeginExportSection(Offset size) override;
   Result OnExportCount(Index count) override;
   Result OnExport(Index index,
                   ExternalKind kind,
                   Index item_index,
                   std::string_view name) override;
   Result EndExportSection() override;
 
   Result BeginStartSection(Offset size) override;
   Result OnStartFunction(Index func_index) override;
   Result EndStartSection() override;
 
   Result BeginCodeSection(Offset size) override;
   Result OnFunctionBodyCount(Index count) override;
   Result BeginFunctionBody(Index index, Offset size) override;
   Result OnLocalDeclCount(Index count) override;
   Result OnLocalDecl(Index decl_index, Index count, Type type) override;
 
   Result OnOpcode(Opcode opcode) override;
   Result OnOpcodeBare() override;
   Result OnOpcodeIndex(Index value) override;
   Result OnOpcodeIndexIndex(Index value, Index value2) override;
   Result OnOpcodeUint32(uint32_t value) override;
   Result OnOpcodeUint32Uint32(uint32_t value, uint32_t value2) override;
   Result OnOpcodeUint32Uint32Uint32(uint32_t value,
                                     uint32_t value2,
                                     uint32_t value3) override;
   Result OnOpcodeUint32Uint32Uint32Uint32(uint32_t value,
                                           uint32_t value2,
                                           uint32_t value3,
                                           uint32_t value4) override;
   Result OnOpcodeUint64(uint64_t value) override;
   Result OnOpcodeF32(uint32_t value) override;
   Result OnOpcodeF64(uint64_t value) override;
   Result OnOpcodeV128(v128 value) override;
   Result OnOpcodeBlockSig(Type sig_type) override;
   Result OnOpcodeType(Type type) override;
   Result OnAtomicLoadExpr(Opcode opcode,
                           Index memidx,
                           Address alignment_log2,
                           Address offset) override;
   Result OnAtomicStoreExpr(Opcode opcode,
                            Index memidx,
                            Address alignment_log2,
                            Address offset) override;
   Result OnAtomicRmwExpr(Opcode opcode,
                          Index memidx,
                          Address alignment_log2,
                          Address offset) override;
   Result OnAtomicRmwCmpxchgExpr(Opcode opcode,
                                 Index memidx,
                                 Address alignment_log2,
                                 Address offset) override;
   Result OnBinaryExpr(Opcode opcode) override;
   Result OnBlockExpr(Type sig_type) override;
   Result OnBrExpr(Index depth) override;
   Result OnBrIfExpr(Index depth) override;
   Result OnBrTableExpr(Index num_targets,
                        Index* target_depths,
                        Index default_target_depth) override;
   Result OnCallExpr(Index func_index) override;
   Result OnCatchExpr(Index tag_index) override;
   Result OnCatchAllExpr() override;
   Result OnCallIndirectExpr(Index sig_index, Index table_index) override;
   Result OnCallRefExpr() override;
   Result OnCompareExpr(Opcode opcode) override;
   Result OnConvertExpr(Opcode opcode) override;
   Result OnDelegateExpr(Index depth) override;
   Result OnDropExpr() override;
   Result OnElseExpr() override;
   Result OnEndExpr() override;
   Result OnF32ConstExpr(uint32_t value_bits) override;
   Result OnF64ConstExpr(uint64_t value_bits) override;
   Result OnV128ConstExpr(v128 value_bits) override;
   Result OnGlobalGetExpr(Index global_index) override;
   Result OnGlobalSetExpr(Index global_index) override;
   Result OnI32ConstExpr(uint32_t value) override;
   Result OnI64ConstExpr(uint64_t value) override;
   Result OnIfExpr(Type sig_type) override;
   Result OnLoadExpr(Opcode opcode,
                     Index memidx,
                     Address alignment_log2,
                     Address offset) override;
   Result OnLocalGetExpr(Index local_index) override;
   Result OnLocalSetExpr(Index local_index) override;
   Result OnLocalTeeExpr(Index local_index) override;
   Result OnLoopExpr(Type sig_type) override;
   Result OnMemoryCopyExpr(Index srcmemidx, Index destmemidx) override;
   Result OnDataDropExpr(Index segment_index) override;
   Result OnMemoryFillExpr(Index memidx) override;
   Result OnMemoryGrowExpr(Index memidx) override;
   Result OnMemoryInitExpr(Index segment_index, Index memidx) override;
   Result OnMemorySizeExpr(Index memidx) override;
   Result OnTableCopyExpr(Index dst_index, Index src_index) override;
   Result OnElemDropExpr(Index segment_index) override;
   Result OnTableInitExpr(Index segment_index, Index table_index) override;
   Result OnTableGetExpr(Index table) override;
   Result OnTableSetExpr(Index table) override;
   Result OnTableGrowExpr(Index table) override;
   Result OnTableSizeExpr(Index table) override;
   Result OnTableFillExpr(Index table) override;
   Result OnRefFuncExpr(Index index) override;
   Result OnRefNullExpr(Type type) override;
   Result OnRefIsNullExpr() override;
   Result OnNopExpr() override;
   Result OnRethrowExpr(Index depth) override;
   Result OnReturnCallExpr(Index func_index) override;
   Result OnReturnCallIndirectExpr(Index sig_index, Index table_index) override;
   Result OnReturnExpr() override;
   Result OnSelectExpr(Index result_count, Type* result_types) override;
   Result OnStoreExpr(Opcode opcode,
                      Index memidx,
                      Address alignment_log2,
                      Address offset) override;
   Result OnThrowExpr(Index tag_index) override;
   Result OnTryExpr(Type sig_type) override;
   Result OnUnaryExpr(Opcode opcode) override;
   Result OnTernaryExpr(Opcode opcode) override;
   Result OnUnreachableExpr() override;
   Result OnAtomicWaitExpr(Opcode opcode,
                           Index memidx,
                           Address alignment_log2,
                           Address offset) override;
   Result OnAtomicFenceExpr(uint32_t consistency_model) override;
   Result OnAtomicNotifyExpr(Opcode opcode,
                             Index memidx,
                             Address alignment_log2,
                             Address offset) override;
   Result EndFunctionBody(Index index) override;
   Result EndCodeSection() override;
   Result OnSimdLaneOpExpr(Opcode opcode, uint64_t value) override;
   Result OnSimdLoadLaneExpr(Opcode opcode,
                             Index memidx,
                             Address alignment_log2,
                             Address offset,
                             uint64_t value) override;
   Result OnSimdStoreLaneExpr(Opcode opcode,
                              Index memidx,
                              Address alignment_log2,
                              Address offset,
                              uint64_t value) override;
   Result OnSimdShuffleOpExpr(Opcode opcode, v128 value) override;
   Result OnLoadSplatExpr(Opcode opcode,
                          Index memidx,
                          Address alignment_log2,
                          Address offset) override;
   Result OnLoadZeroExpr(Opcode opcode,
                         Index memidx,
                         Address alignment_log2,
                         Address offset) override;
 
   Result BeginElemSection(Offset size) override;
   Result OnElemSegmentCount(Index count) override;
   Result BeginElemSegment(Index index,
                           Index table_index,
                           uint8_t flags) override;
   Result BeginElemSegmentInitExpr(Index index) override;
   Result EndElemSegmentInitExpr(Index index) override;
   Result OnElemSegmentElemType(Index index, Type elem_type) override;
   Result OnElemSegmentElemExprCount(Index index, Index count) override;
-  Result OnElemSegmentElemExpr_RefNull(Index segment_index, Type type) override;
-  Result OnElemSegmentElemExpr_RefFunc(Index segment_index,
-                                       Index func_index) override;
+  Result BeginElemExpr(Index elem_index, Index expr_index) override;
+  Result EndElemExpr(Index elem_index, Index expr_index) override;
   Result EndElemSegment(Index index) override;
   Result EndElemSection() override;
 
   Result BeginDataSection(Offset size) override;
   Result OnDataSegmentCount(Index count) override;
   Result BeginDataSegment(Index index,
                           Index memory_index,
                           uint8_t flags) override;
   Result BeginDataSegmentInitExpr(Index index) override;
   Result EndDataSegmentInitExpr(Index index) override;
   Result OnDataSegmentData(Index index,
                            const void* data,
                            Address size) override;
   Result EndDataSegment(Index index) override;
   Result EndDataSection() override;
 
   Result BeginDataCountSection(Offset size) override;
   Result OnDataCount(Index count) override;
   Result EndDataCountSection() override;
 
   Result BeginNamesSection(Offset size) override;
   Result OnModuleNameSubsection(Index index,
                                 uint32_t name_type,
                                 Offset subsection_size) override;
   Result OnModuleName(std::string_view name) override;
   Result OnFunctionNameSubsection(Index index,
                                   uint32_t name_type,
                                   Offset subsection_size) override;
   Result OnFunctionNamesCount(Index num_functions) override;
   Result OnFunctionName(Index function_index,
                         std::string_view function_name) override;
   Result OnLocalNameSubsection(Index index,
                                uint32_t name_type,
                                Offset subsection_size) override;
   Result OnLocalNameFunctionCount(Index num_functions) override;
   Result OnLocalNameLocalCount(Index function_index, Index num_locals) override;
   Result OnLocalName(Index function_index,
                      Index local_index,
                      std::string_view local_name) override;
   Result OnNameSubsection(Index index,
                           NameSectionSubsection subsection_type,
                           Offset subsection_size) override;
   Result OnNameEntry(NameSectionSubsection type,
                      Index index,
                      std::string_view name) override;
   Result OnNameCount(Index num_names) override;
   Result EndNamesSection() override;
 
   Result BeginRelocSection(Offset size) override;
   Result OnRelocCount(Index count, Index section_index) override;
   Result OnReloc(RelocType type,
                  Offset offset,
                  Index index,
                  uint32_t addend) override;
   Result EndRelocSection() override;
 
   Result BeginDylinkSection(Offset size) override;
   Result OnDylinkInfo(uint32_t mem_size,
                       uint32_t mem_align,
                       uint32_t table_size,
                       uint32_t table_align) override;
   Result OnDylinkNeededCount(Index count) override;
   Result OnDylinkNeeded(std::string_view needed) override;
   Result OnDylinkImportCount(Index count) override;
   Result OnDylinkExportCount(Index count) override;
   Result OnDylinkImport(std::string_view module,
                         std::string_view name,
                         uint32_t flags) override;
   Result OnDylinkExport(std::string_view name, uint32_t flags) override;
   Result EndDylinkSection() override;
 
   Result BeginTargetFeaturesSection(Offset size) override;
   Result OnFeatureCount(Index count) override;
   Result OnFeature(uint8_t prefix, std::string_view name) override;
   Result EndTargetFeaturesSection() override;
 
   Result BeginLinkingSection(Offset size) override;
   Result OnSymbolCount(Index count) override;
   Result OnDataSymbol(Index index,
                       uint32_t flags,
                       std::string_view name,
                       Index segment,
                       uint32_t offset,
                       uint32_t size) override;
   Result OnFunctionSymbol(Index index,
                           uint32_t flags,
                           std::string_view name,
                           Index func_index) override;
   Result OnGlobalSymbol(Index index,
                         uint32_t flags,
                         std::string_view name,
                         Index global_index) override;
   Result OnSectionSymbol(Index index,
                          uint32_t flags,
                          Index section_index) override;
   Result OnTagSymbol(Index index,
                      uint32_t flags,
                      std::string_view name,
                      Index tag_index) override;
   Result OnTableSymbol(Index index,
                        uint32_t flags,
                        std::string_view name,
                        Index tag_index) override;
   Result OnSegmentInfoCount(Index count) override;
   Result OnSegmentInfo(Index index,
                        std::string_view name,
                        Address alignment,
                        uint32_t flags) override;
   Result OnInitFunctionCount(Index count) override;
   Result OnInitFunction(uint32_t priority, Index symbol_index) override;
   Result OnComdatCount(Index count) override;
   Result OnComdatBegin(std::string_view name,
                        uint32_t flags,
                        Index count) override;
   Result OnComdatEntry(ComdatType kind, Index index) override;
   Result EndLinkingSection() override;
 
   Result BeginTagSection(Offset size) override;
   Result OnTagCount(Index count) override;
   Result OnTagType(Index index, Index sig_index) override;
   Result EndTagSection() override;
 
   /* Code Metadata sections */
   Result BeginCodeMetadataSection(std::string_view name, Offset size) override;
   Result OnCodeMetadataFuncCount(Index count) override;
   Result OnCodeMetadataCount(Index function_index, Index count) override;
   Result OnCodeMetadata(Offset offset, const void* data, Address size) override;
   Result EndCodeMetadataSection() override;
 
  private:
   void Indent();
   void Dedent();
   void WriteIndent();
   void LogType(Type type);
   void LogTypes(Index type_count, Type* types);
   void LogTypes(TypeVector& types);
   void LogField(TypeMut field);
 
   Stream* stream_;
   BinaryReaderDelegate* reader_;
   int indent_;
 };
 
 }  // namespace wabt
 
 #endif  // WABT_BINARY_READER_LOGGING_H_
diff --git a/include/wabt/binary-reader-nop.h b/include/wabt/binary-reader-nop.h
index 0c9ebc64..9d4a9a39 100644
--- a/include/wabt/binary-reader-nop.h
+++ b/include/wabt/binary-reader-nop.h
@@ -24,566 +24,564 @@ namespace wabt {
 class BinaryReaderNop : public BinaryReaderDelegate {
  public:
   bool OnError(const Error&) override { return false; }
 
   /* Module */
   Result BeginModule(uint32_t version) override { return Result::Ok; }
   Result EndModule() override { return Result::Ok; }
 
   Result BeginSection(Index section_index,
                       BinarySection section_type,
                       Offset size) override {
     return Result::Ok;
   }
 
   /* Custom section */
   Result BeginCustomSection(Index section_index,
                             Offset size,
                             std::string_view section_name) override {
     return Result::Ok;
   }
   Result EndCustomSection() override { return Result::Ok; }
 
   /* Type section */
   Result BeginTypeSection(Offset size) override { return Result::Ok; }
   Result OnTypeCount(Index count) override { return Result::Ok; }
   Result OnFuncType(Index index,
                     Index param_count,
                     Type* param_types,
                     Index result_count,
                     Type* result_types) override {
     return Result::Ok;
   }
   Result OnStructType(Index index,
                       Index field_count,
                       TypeMut* fields) override {
     return Result::Ok;
   }
   Result OnArrayType(Index index, TypeMut field) override { return Result::Ok; }
   Result EndTypeSection() override { return Result::Ok; }
 
   /* Import section */
   Result BeginImportSection(Offset size) override { return Result::Ok; }
   Result OnImportCount(Index count) override { return Result::Ok; }
   Result OnImport(Index index,
                   ExternalKind kind,
                   std::string_view module_name,
                   std::string_view field_name) override {
     return Result::Ok;
   }
   Result OnImportFunc(Index import_index,
                       std::string_view module_name,
                       std::string_view field_name,
                       Index func_index,
                       Index sig_index) override {
     return Result::Ok;
   }
   Result OnImportTable(Index import_index,
                        std::string_view module_name,
                        std::string_view field_name,
                        Index table_index,
                        Type elem_type,
                        const Limits* elem_limits) override {
     return Result::Ok;
   }
   Result OnImportMemory(Index import_index,
                         std::string_view module_name,
                         std::string_view field_name,
                         Index memory_index,
                         const Limits* page_limits) override {
     return Result::Ok;
   }
   Result OnImportGlobal(Index import_index,
                         std::string_view module_name,
                         std::string_view field_name,
                         Index global_index,
                         Type type,
                         bool mutable_) override {
     return Result::Ok;
   }
   Result OnImportTag(Index import_index,
                      std::string_view module_name,
                      std::string_view field_name,
                      Index tag_index,
                      Index sig_index) override {
     return Result::Ok;
   }
   Result EndImportSection() override { return Result::Ok; }
 
   /* Function section */
   Result BeginFunctionSection(Offset size) override { return Result::Ok; }
   Result OnFunctionCount(Index count) override { return Result::Ok; }
   Result OnFunction(Index index, Index sig_index) override {
     return Result::Ok;
   }
   Result EndFunctionSection() override { return Result::Ok; }
 
   /* Table section */
   Result BeginTableSection(Offset size) override { return Result::Ok; }
   Result OnTableCount(Index count) override { return Result::Ok; }
   Result OnTable(Index index,
                  Type elem_type,
                  const Limits* elem_limits) override {
     return Result::Ok;
   }
   Result EndTableSection() override { return Result::Ok; }
 
   /* Memory section */
   Result BeginMemorySection(Offset size) override { return Result::Ok; }
   Result OnMemoryCount(Index count) override { return Result::Ok; }
   Result OnMemory(Index index, const Limits* limits) override {
     return Result::Ok;
   }
   Result EndMemorySection() override { return Result::Ok; }
 
   /* Global section */
   Result BeginGlobalSection(Offset size) override { return Result::Ok; }
   Result OnGlobalCount(Index count) override { return Result::Ok; }
   Result BeginGlobal(Index index, Type type, bool mutable_) override {
     return Result::Ok;
   }
   Result BeginGlobalInitExpr(Index index) override { return Result::Ok; }
   Result EndGlobalInitExpr(Index index) override { return Result::Ok; }
   Result EndGlobal(Index index) override { return Result::Ok; }
   Result EndGlobalSection() override { return Result::Ok; }
 
   /* Exports section */
   Result BeginExportSection(Offset size) override { return Result::Ok; }
   Result OnExportCount(Index count) override { return Result::Ok; }
   Result OnExport(Index index,
                   ExternalKind kind,
                   Index item_index,
                   std::string_view name) override {
     return Result::Ok;
   }
   Result EndExportSection() override { return Result::Ok; }
 
   /* Start section */
   Result BeginStartSection(Offset size) override { return Result::Ok; }
   Result OnStartFunction(Index func_index) override { return Result::Ok; }
   Result EndStartSection() override { return Result::Ok; }
 
   /* Code section */
   Result BeginCodeSection(Offset size) override { return Result::Ok; }
   Result OnFunctionBodyCount(Index count) override { return Result::Ok; }
   Result BeginFunctionBody(Index index, Offset size) override {
     return Result::Ok;
   }
   Result OnLocalDeclCount(Index count) override { return Result::Ok; }
   Result OnLocalDecl(Index decl_index, Index count, Type type) override {
     return Result::Ok;
   }
 
   /* Function expressions; called between BeginFunctionBody and
    EndFunctionBody */
   Result OnOpcode(Opcode Opcode) override { return Result::Ok; }
   Result OnOpcodeBare() override { return Result::Ok; }
   Result OnOpcodeIndex(Index value) override { return Result::Ok; }
   Result OnOpcodeIndexIndex(Index value, Index value2) override {
     return Result::Ok;
   }
   Result OnOpcodeUint32(uint32_t value) override { return Result::Ok; }
   Result OnOpcodeUint32Uint32(uint32_t value, uint32_t value2) override {
     return Result::Ok;
   }
   Result OnOpcodeUint32Uint32Uint32(uint32_t value,
                                     uint32_t value2,
                                     uint32_t value3) override {
     return Result::Ok;
   }
   Result OnOpcodeUint32Uint32Uint32Uint32(uint32_t value,
                                           uint32_t value2,
                                           uint32_t value3,
                                           uint32_t value4) override {
     return Result::Ok;
   }
   Result OnOpcodeUint64(uint64_t value) override { return Result::Ok; }
   Result OnOpcodeF32(uint32_t value) override { return Result::Ok; }
   Result OnOpcodeF64(uint64_t value) override { return Result::Ok; }
   Result OnOpcodeV128(v128 value) override { return Result::Ok; }
   Result OnOpcodeBlockSig(Type sig_type) override { return Result::Ok; }
   Result OnOpcodeType(Type type) override { return Result::Ok; }
   Result OnAtomicLoadExpr(Opcode opcode,
                           Index memidx,
                           Address alignment_log2,
                           Address offset) override {
     return Result::Ok;
   }
   Result OnAtomicStoreExpr(Opcode opcode,
                            Index memidx,
                            Address alignment_log2,
                            Address offset) override {
     return Result::Ok;
   }
   Result OnAtomicRmwExpr(Opcode opcode,
                          Index memidx,
                          Address alignment_log2,
                          Address offset) override {
     return Result::Ok;
   }
   Result OnAtomicRmwCmpxchgExpr(Opcode opcode,
                                 Index memidx,
                                 Address alignment_log2,
                                 Address offset) override {
     return Result::Ok;
   }
   Result OnAtomicWaitExpr(Opcode, Index, Address, Address) override {
     return Result::Ok;
   }
   Result OnAtomicFenceExpr(uint32_t) override { return Result::Ok; }
   Result OnAtomicNotifyExpr(Opcode, Index, Address, Address) override {
     return Result::Ok;
   }
   Result OnBinaryExpr(Opcode opcode) override { return Result::Ok; }
   Result OnBlockExpr(Type sig_type) override { return Result::Ok; }
   Result OnBrExpr(Index depth) override { return Result::Ok; }
   Result OnBrIfExpr(Index depth) override { return Result::Ok; }
   Result OnBrTableExpr(Index num_targets,
                        Index* target_depths,
                        Index default_target_depth) override {
     return Result::Ok;
   }
   Result OnCallExpr(Index func_index) override { return Result::Ok; }
   Result OnCallIndirectExpr(Index sig_index, Index table_index) override {
     return Result::Ok;
   }
   Result OnCallRefExpr() override { return Result::Ok; }
   Result OnCatchExpr(Index tag_index) override { return Result::Ok; }
   Result OnCatchAllExpr() override { return Result::Ok; }
   Result OnCompareExpr(Opcode opcode) override { return Result::Ok; }
   Result OnConvertExpr(Opcode opcode) override { return Result::Ok; }
   Result OnDelegateExpr(Index depth) override { return Result::Ok; }
   Result OnDropExpr() override { return Result::Ok; }
   Result OnElseExpr() override { return Result::Ok; }
   Result OnEndExpr() override { return Result::Ok; }
   Result OnF32ConstExpr(uint32_t value_bits) override { return Result::Ok; }
   Result OnF64ConstExpr(uint64_t value_bits) override { return Result::Ok; }
   Result OnV128ConstExpr(v128 value_bits) override { return Result::Ok; }
   Result OnGlobalGetExpr(Index global_index) override { return Result::Ok; }
   Result OnGlobalSetExpr(Index global_index) override { return Result::Ok; }
   Result OnI32ConstExpr(uint32_t value) override { return Result::Ok; }
   Result OnI64ConstExpr(uint64_t value) override { return Result::Ok; }
   Result OnIfExpr(Type sig_type) override { return Result::Ok; }
   Result OnLoadExpr(Opcode opcode,
                     Index memidx,
                     Address alignment_log2,
                     Address offset) override {
     return Result::Ok;
   }
   Result OnLocalGetExpr(Index local_index) override { return Result::Ok; }
   Result OnLocalSetExpr(Index local_index) override { return Result::Ok; }
   Result OnLocalTeeExpr(Index local_index) override { return Result::Ok; }
   Result OnLoopExpr(Type sig_type) override { return Result::Ok; }
   Result OnMemoryCopyExpr(Index srcmemidx, Index destmemidx) override {
     return Result::Ok;
   }
   Result OnDataDropExpr(Index segment_index) override { return Result::Ok; }
   Result OnMemoryFillExpr(Index memidx) override { return Result::Ok; }
   Result OnMemoryGrowExpr(Index memidx) override { return Result::Ok; }
   Result OnMemoryInitExpr(Index segment_index, Index memidx) override {
     return Result::Ok;
   }
   Result OnMemorySizeExpr(Index memidx) override { return Result::Ok; }
   Result OnTableCopyExpr(Index dst_index, Index src_index) override {
     return Result::Ok;
   }
   Result OnElemDropExpr(Index segment_index) override { return Result::Ok; }
   Result OnTableInitExpr(Index segment_index, Index table_index) override {
     return Result::Ok;
   }
   Result OnTableGetExpr(Index table_index) override { return Result::Ok; }
   Result OnTableSetExpr(Index table_index) override { return Result::Ok; }
   Result OnTableGrowExpr(Index table_index) override { return Result::Ok; }
   Result OnTableSizeExpr(Index table_index) override { return Result::Ok; }
   Result OnTableFillExpr(Index table_index) override { return Result::Ok; }
   Result OnRefFuncExpr(Index func_index) override { return Result::Ok; }
   Result OnRefNullExpr(Type type) override { return Result::Ok; }
   Result OnRefIsNullExpr() override { return Result::Ok; }
   Result OnNopExpr() override { return Result::Ok; }
   Result OnRethrowExpr(Index depth) override { return Result::Ok; }
   Result OnReturnCallExpr(Index sig_index) override { return Result::Ok; }
   Result OnReturnCallIndirectExpr(Index sig_index, Index table_index) override {
     return Result::Ok;
   }
   Result OnReturnExpr() override { return Result::Ok; }
   Result OnSelectExpr(Index result_count, Type* result_types) override {
     return Result::Ok;
   }
   Result OnStoreExpr(Opcode opcode,
                      Index memidx,
                      Address alignment_log2,
                      Address offset) override {
     return Result::Ok;
   }
   Result OnThrowExpr(Index depth) override { return Result::Ok; }
   Result OnTryExpr(Type sig_type) override { return Result::Ok; }
   Result OnUnaryExpr(Opcode opcode) override { return Result::Ok; }
   Result OnTernaryExpr(Opcode opcode) override { return Result::Ok; }
   Result OnUnreachableExpr() override { return Result::Ok; }
   Result EndFunctionBody(Index index) override { return Result::Ok; }
   Result EndCodeSection() override { return Result::Ok; }
   Result OnSimdLaneOpExpr(Opcode opcode, uint64_t value) override {
     return Result::Ok;
   }
   Result OnSimdLoadLaneExpr(Opcode opcode,
                             Index memidx,
                             Address alignment_log2,
                             Address offset,
                             uint64_t value) override {
     return Result::Ok;
   }
   Result OnSimdStoreLaneExpr(Opcode opcode,
                              Index memidx,
                              Address alignment_log2,
                              Address offset,
                              uint64_t value) override {
     return Result::Ok;
   }
   Result OnSimdShuffleOpExpr(Opcode opcode, v128 value) override {
     return Result::Ok;
   }
   Result OnLoadSplatExpr(Opcode opcode,
                          Index memidx,
                          Address alignment_log2,
                          Address offset) override {
     return Result::Ok;
   }
   Result OnLoadZeroExpr(Opcode opcode,
                         Index memidx,
                         Address alignment_log2,
                         Address offset) override {
     return Result::Ok;
   }
 
   /* Elem section */
   Result BeginElemSection(Offset size) override { return Result::Ok; }
   Result OnElemSegmentCount(Index count) override { return Result::Ok; }
   Result BeginElemSegment(Index index,
                           Index table_index,
                           uint8_t flags) override {
     return Result::Ok;
   }
   Result BeginElemSegmentInitExpr(Index index) override { return Result::Ok; }
   Result EndElemSegmentInitExpr(Index index) override { return Result::Ok; }
   Result OnElemSegmentElemType(Index index, Type elem_type) override {
     return Result::Ok;
   }
   Result OnElemSegmentElemExprCount(Index index, Index count) override {
     return Result::Ok;
   }
-  Result OnElemSegmentElemExpr_RefNull(Index segment_index,
-                                       Type type) override {
+  Result BeginElemExpr(Index elem_index, Index expr_index) override {
     return Result::Ok;
   }
-  Result OnElemSegmentElemExpr_RefFunc(Index segment_index,
-                                       Index func_index) override {
+  Result EndElemExpr(Index elem_index, Index expr_index) override {
     return Result::Ok;
   }
   Result EndElemSegment(Index index) override { return Result::Ok; }
   Result EndElemSection() override { return Result::Ok; }
 
   /* Data section */
   Result BeginDataSection(Offset size) override { return Result::Ok; }
   Result OnDataSegmentCount(Index count) override { return Result::Ok; }
   Result BeginDataSegment(Index index,
                           Index memory_index,
                           uint8_t flags) override {
     return Result::Ok;
   }
   Result BeginDataSegmentInitExpr(Index index) override { return Result::Ok; }
   Result EndDataSegmentInitExpr(Index index) override { return Result::Ok; }
   Result OnDataSegmentData(Index index,
                            const void* data,
                            Address size) override {
     return Result::Ok;
   }
   Result EndDataSegment(Index index) override { return Result::Ok; }
   Result EndDataSection() override { return Result::Ok; }
 
   /* DataCount section */
   Result BeginDataCountSection(Offset size) override { return Result::Ok; }
   Result OnDataCount(Index count) override { return Result::Ok; }
   Result EndDataCountSection() override { return Result::Ok; }
 
   /* Names section */
   Result BeginNamesSection(Offset size) override { return Result::Ok; }
   Result OnModuleNameSubsection(Index index,
                                 uint32_t name_type,
                                 Offset subsection_size) override {
     return Result::Ok;
   }
   Result OnModuleName(std::string_view name) override { return Result::Ok; }
   Result OnFunctionNameSubsection(Index index,
                                   uint32_t name_type,
                                   Offset subsection_size) override {
     return Result::Ok;
   }
   Result OnFunctionNamesCount(Index num_functions) override {
     return Result::Ok;
   }
   Result OnFunctionName(Index function_index,
                         std::string_view function_name) override {
     return Result::Ok;
   }
   Result OnLocalNameSubsection(Index index,
                                uint32_t name_type,
                                Offset subsection_size) override {
     return Result::Ok;
   }
   Result OnLocalNameFunctionCount(Index num_functions) override {
     return Result::Ok;
   }
   Result OnLocalNameLocalCount(Index function_index,
                                Index num_locals) override {
     return Result::Ok;
   }
   Result OnLocalName(Index function_index,
                      Index local_index,
                      std::string_view local_name) override {
     return Result::Ok;
   }
   Result EndNamesSection() override { return Result::Ok; }
 
   Result OnNameSubsection(Index index,
                           NameSectionSubsection subsection_type,
                           Offset subsection_size) override {
     return Result::Ok;
   }
   Result OnNameCount(Index num_names) override { return Result::Ok; }
   Result OnNameEntry(NameSectionSubsection type,
                      Index index,
                      std::string_view name) override {
     return Result::Ok;
   }
 
   /* Reloc section */
   Result BeginRelocSection(Offset size) override { return Result::Ok; }
   Result OnRelocCount(Index count, Index section_code) override {
     return Result::Ok;
   }
   Result OnReloc(RelocType type,
                  Offset offset,
                  Index index,
                  uint32_t addend) override {
     return Result::Ok;
   }
   Result EndRelocSection() override { return Result::Ok; }
 
   /* Tag section */
   Result BeginTagSection(Offset size) override { return Result::Ok; }
   Result OnTagCount(Index count) override { return Result::Ok; }
   Result OnTagType(Index index, Index sig_index) override { return Result::Ok; }
   Result EndTagSection() override { return Result::Ok; }
 
   /* Code Metadata sections */
   Result BeginCodeMetadataSection(std::string_view name, Offset size) override {
     return Result::Ok;
   }
   Result OnCodeMetadataFuncCount(Index count) override { return Result::Ok; }
   Result OnCodeMetadataCount(Index function_index, Index count) override {
     return Result::Ok;
   }
   Result OnCodeMetadata(Offset offset,
                         const void* data,
                         Address size) override {
     return Result::Ok;
   }
   Result EndCodeMetadataSection() override { return Result::Ok; }
 
   /* Dylink section */
   Result BeginDylinkSection(Offset size) override { return Result::Ok; }
   Result OnDylinkInfo(uint32_t mem_size,
                       uint32_t mem_align,
                       uint32_t table_size,
                       uint32_t table_align) override {
     return Result::Ok;
   }
   Result OnDylinkNeededCount(Index count) override { return Result::Ok; }
   Result OnDylinkNeeded(std::string_view so_name) override {
     return Result::Ok;
   }
   Result OnDylinkImportCount(Index count) override { return Result::Ok; }
   Result OnDylinkExportCount(Index count) override { return Result::Ok; }
   Result OnDylinkImport(std::string_view module,
                         std::string_view name,
                         uint32_t flags) override {
     return Result::Ok;
   }
   Result OnDylinkExport(std::string_view name, uint32_t flags) override {
     return Result::Ok;
   }
   Result EndDylinkSection() override { return Result::Ok; }
 
   /* target_features section */
   Result BeginTargetFeaturesSection(Offset size) override { return Result::Ok; }
   Result OnFeatureCount(Index count) override { return Result::Ok; }
   Result OnFeature(uint8_t prefix, std::string_view name) override {
     return Result::Ok;
   }
   Result EndTargetFeaturesSection() override { return Result::Ok; }
 
   /* Linking section */
   Result BeginLinkingSection(Offset size) override { return Result::Ok; }
   Result OnSymbolCount(Index count) override { return Result::Ok; }
   Result OnDataSymbol(Index index,
                       uint32_t flags,
                       std::string_view name,
                       Index segment,
                       uint32_t offset,
                       uint32_t size) override {
     return Result::Ok;
   }
   Result OnFunctionSymbol(Index index,
                           uint32_t flags,
                           std::string_view name,
                           Index func_index) override {
     return Result::Ok;
   }
   Result OnGlobalSymbol(Index index,
                         uint32_t flags,
                         std::string_view name,
                         Index global_index) override {
     return Result::Ok;
   }
   Result OnSectionSymbol(Index index,
                          uint32_t flags,
                          Index section_index) override {
     return Result::Ok;
   }
   Result OnTagSymbol(Index index,
                      uint32_t flags,
                      std::string_view name,
                      Index tag_index) override {
     return Result::Ok;
   }
   Result OnTableSymbol(Index index,
                        uint32_t flags,
                        std::string_view name,
                        Index table_index) override {
     return Result::Ok;
   }
   Result OnSegmentInfoCount(Index count) override { return Result::Ok; }
   Result OnSegmentInfo(Index index,
                        std::string_view name,
                        Address alignment,
                        uint32_t flags) override {
     return Result::Ok;
   }
   Result OnInitFunctionCount(Index count) override { return Result::Ok; }
   Result OnInitFunction(uint32_t priority, Index symbol_index) override {
     return Result::Ok;
   }
   Result OnComdatCount(Index count) override { return Result::Ok; }
   Result OnComdatBegin(std::string_view name,
                        uint32_t flags,
                        Index count) override {
     return Result::Ok;
   }
   Result OnComdatEntry(ComdatType kind, Index index) override {
     return Result::Ok;
   }
   Result EndLinkingSection() override { return Result::Ok; }
 };
 
 }  // namespace wabt
 
 #endif /* WABT_BINARY_READER_H_ */
diff --git a/include/wabt/binary-reader.h b/include/wabt/binary-reader.h
index 825d562c..ac0be7b4 100644
--- a/include/wabt/binary-reader.h
+++ b/include/wabt/binary-reader.h
@@ -62,427 +62,425 @@ using TypeMutVector = std::vector<TypeMut>;
 class BinaryReaderDelegate {
  public:
   struct State {
     State(const uint8_t* data, Offset size)
         : data(data), size(size), offset(0) {}
 
     const uint8_t* data;
     Offset size;
     Offset offset;
   };
 
   virtual ~BinaryReaderDelegate() {}
 
   virtual bool OnError(const Error&) = 0;
   virtual void OnSetState(const State* s) { state = s; }
 
   /* Module */
   virtual Result BeginModule(uint32_t version) = 0;
   virtual Result EndModule() = 0;
 
   virtual Result BeginSection(Index section_index,
                               BinarySection section_type,
                               Offset size) = 0;
 
   /* Custom section */
   virtual Result BeginCustomSection(Index section_index,
                                     Offset size,
                                     std::string_view section_name) = 0;
   virtual Result EndCustomSection() = 0;
 
   /* Type section */
   virtual Result BeginTypeSection(Offset size) = 0;
   virtual Result OnTypeCount(Index count) = 0;
   virtual Result OnFuncType(Index index,
                             Index param_count,
                             Type* param_types,
                             Index result_count,
                             Type* result_types) = 0;
   virtual Result OnStructType(Index index,
                               Index field_count,
                               TypeMut* fields) = 0;
   virtual Result OnArrayType(Index index, TypeMut field) = 0;
   virtual Result EndTypeSection() = 0;
 
   /* Import section */
   virtual Result BeginImportSection(Offset size) = 0;
   virtual Result OnImportCount(Index count) = 0;
   virtual Result OnImport(Index index,
                           ExternalKind kind,
                           std::string_view module_name,
                           std::string_view field_name) = 0;
   virtual Result OnImportFunc(Index import_index,
                               std::string_view module_name,
                               std::string_view field_name,
                               Index func_index,
                               Index sig_index) = 0;
   virtual Result OnImportTable(Index import_index,
                                std::string_view module_name,
                                std::string_view field_name,
                                Index table_index,
                                Type elem_type,
                                const Limits* elem_limits) = 0;
   virtual Result OnImportMemory(Index import_index,
                                 std::string_view module_name,
                                 std::string_view field_name,
                                 Index memory_index,
                                 const Limits* page_limits) = 0;
   virtual Result OnImportGlobal(Index import_index,
                                 std::string_view module_name,
                                 std::string_view field_name,
                                 Index global_index,
                                 Type type,
                                 bool mutable_) = 0;
   virtual Result OnImportTag(Index import_index,
                              std::string_view module_name,
                              std::string_view field_name,
                              Index tag_index,
                              Index sig_index) = 0;
   virtual Result EndImportSection() = 0;
 
   /* Function section */
   virtual Result BeginFunctionSection(Offset size) = 0;
   virtual Result OnFunctionCount(Index count) = 0;
   virtual Result OnFunction(Index index, Index sig_index) = 0;
   virtual Result EndFunctionSection() = 0;
 
   /* Table section */
   virtual Result BeginTableSection(Offset size) = 0;
   virtual Result OnTableCount(Index count) = 0;
   virtual Result OnTable(Index index,
                          Type elem_type,
                          const Limits* elem_limits) = 0;
   virtual Result EndTableSection() = 0;
 
   /* Memory section */
   virtual Result BeginMemorySection(Offset size) = 0;
   virtual Result OnMemoryCount(Index count) = 0;
   virtual Result OnMemory(Index index, const Limits* limits) = 0;
   virtual Result EndMemorySection() = 0;
 
   /* Global section */
   virtual Result BeginGlobalSection(Offset size) = 0;
   virtual Result OnGlobalCount(Index count) = 0;
   virtual Result BeginGlobal(Index index, Type type, bool mutable_) = 0;
   virtual Result BeginGlobalInitExpr(Index index) = 0;
   virtual Result EndGlobalInitExpr(Index index) = 0;
   virtual Result EndGlobal(Index index) = 0;
   virtual Result EndGlobalSection() = 0;
 
   /* Exports section */
   virtual Result BeginExportSection(Offset size) = 0;
   virtual Result OnExportCount(Index count) = 0;
   virtual Result OnExport(Index index,
                           ExternalKind kind,
                           Index item_index,
                           std::string_view name) = 0;
   virtual Result EndExportSection() = 0;
 
   /* Start section */
   virtual Result BeginStartSection(Offset size) = 0;
   virtual Result OnStartFunction(Index func_index) = 0;
   virtual Result EndStartSection() = 0;
 
   /* Code section */
   virtual Result BeginCodeSection(Offset size) = 0;
   virtual Result OnFunctionBodyCount(Index count) = 0;
   virtual Result BeginFunctionBody(Index index, Offset size) = 0;
   virtual Result OnLocalDeclCount(Index count) = 0;
   virtual Result OnLocalDecl(Index decl_index, Index count, Type type) = 0;
 
   /* Function expressions; called between BeginFunctionBody and
    EndFunctionBody */
   virtual Result OnOpcode(Opcode Opcode) = 0;
   virtual Result OnOpcodeBare() = 0;
   virtual Result OnOpcodeUint32(uint32_t value) = 0;
   virtual Result OnOpcodeIndex(Index value) = 0;
   virtual Result OnOpcodeIndexIndex(Index value, Index value2) = 0;
   virtual Result OnOpcodeUint32Uint32(uint32_t value, uint32_t value2) = 0;
   virtual Result OnOpcodeUint32Uint32Uint32(uint32_t value,
                                             uint32_t value2,
                                             uint32_t value3) = 0;
   virtual Result OnOpcodeUint32Uint32Uint32Uint32(uint32_t value,
                                                   uint32_t value2,
                                                   uint32_t value3,
                                                   uint32_t value4) = 0;
   virtual Result OnOpcodeUint64(uint64_t value) = 0;
   virtual Result OnOpcodeF32(uint32_t value) = 0;
   virtual Result OnOpcodeF64(uint64_t value) = 0;
   virtual Result OnOpcodeV128(v128 value) = 0;
   virtual Result OnOpcodeBlockSig(Type sig_type) = 0;
   virtual Result OnOpcodeType(Type type) = 0;
   virtual Result OnAtomicLoadExpr(Opcode opcode,
                                   Index memidx,
                                   Address alignment_log2,
                                   Address offset) = 0;
   virtual Result OnAtomicStoreExpr(Opcode opcode,
                                    Index memidx,
                                    Address alignment_log2,
                                    Address offset) = 0;
   virtual Result OnAtomicRmwExpr(Opcode opcode,
                                  Index memidx,
                                  Address alignment_log2,
                                  Address offset) = 0;
   virtual Result OnAtomicRmwCmpxchgExpr(Opcode opcode,
                                         Index memidx,
                                         Address alignment_log2,
                                         Address offset) = 0;
   virtual Result OnAtomicWaitExpr(Opcode opcode,
                                   Index memidx,
                                   Address alignment_log2,
                                   Address offset) = 0;
   virtual Result OnAtomicFenceExpr(uint32_t consistency_model) = 0;
   virtual Result OnAtomicNotifyExpr(Opcode opcode,
                                     Index memidx,
                                     Address alignment_log2,
                                     Address offset) = 0;
   virtual Result OnBinaryExpr(Opcode opcode) = 0;
   virtual Result OnBlockExpr(Type sig_type) = 0;
   virtual Result OnBrExpr(Index depth) = 0;
   virtual Result OnBrIfExpr(Index depth) = 0;
   virtual Result OnBrTableExpr(Index num_targets,
                                Index* target_depths,
                                Index default_target_depth) = 0;
   virtual Result OnCallExpr(Index func_index) = 0;
   virtual Result OnCallIndirectExpr(Index sig_index, Index table_index) = 0;
   virtual Result OnCallRefExpr() = 0;
   virtual Result OnCatchExpr(Index tag_index) = 0;
   virtual Result OnCatchAllExpr() = 0;
   virtual Result OnCompareExpr(Opcode opcode) = 0;
   virtual Result OnConvertExpr(Opcode opcode) = 0;
   virtual Result OnDelegateExpr(Index depth) = 0;
   virtual Result OnDropExpr() = 0;
   virtual Result OnElseExpr() = 0;
   virtual Result OnEndExpr() = 0;
   virtual Result OnF32ConstExpr(uint32_t value_bits) = 0;
   virtual Result OnF64ConstExpr(uint64_t value_bits) = 0;
   virtual Result OnV128ConstExpr(v128 value_bits) = 0;
   virtual Result OnGlobalGetExpr(Index global_index) = 0;
   virtual Result OnGlobalSetExpr(Index global_index) = 0;
   virtual Result OnI32ConstExpr(uint32_t value) = 0;
   virtual Result OnI64ConstExpr(uint64_t value) = 0;
   virtual Result OnIfExpr(Type sig_type) = 0;
   virtual Result OnLoadExpr(Opcode opcode,
                             Index memidx,
                             Address alignment_log2,
                             Address offset) = 0;
   virtual Result OnLocalGetExpr(Index local_index) = 0;
   virtual Result OnLocalSetExpr(Index local_index) = 0;
   virtual Result OnLocalTeeExpr(Index local_index) = 0;
   virtual Result OnLoopExpr(Type sig_type) = 0;
   virtual Result OnMemoryCopyExpr(Index srcmemidx, Index destmemidx) = 0;
   virtual Result OnDataDropExpr(Index segment_index) = 0;
   virtual Result OnMemoryFillExpr(Index memidx) = 0;
   virtual Result OnMemoryGrowExpr(Index memidx) = 0;
   virtual Result OnMemoryInitExpr(Index segment_index, Index memidx) = 0;
   virtual Result OnMemorySizeExpr(Index memidx) = 0;
   virtual Result OnTableCopyExpr(Index dst_index, Index src_index) = 0;
   virtual Result OnElemDropExpr(Index segment_index) = 0;
   virtual Result OnTableInitExpr(Index segment_index, Index table_index) = 0;
   virtual Result OnTableGetExpr(Index table_index) = 0;
   virtual Result OnTableSetExpr(Index table_index) = 0;
   virtual Result OnTableGrowExpr(Index table_index) = 0;
   virtual Result OnTableSizeExpr(Index table_index) = 0;
   virtual Result OnTableFillExpr(Index table_index) = 0;
   virtual Result OnRefFuncExpr(Index func_index) = 0;
   virtual Result OnRefNullExpr(Type type) = 0;
   virtual Result OnRefIsNullExpr() = 0;
   virtual Result OnNopExpr() = 0;
   virtual Result OnRethrowExpr(Index depth) = 0;
   virtual Result OnReturnExpr() = 0;
   virtual Result OnReturnCallExpr(Index func_index) = 0;
   virtual Result OnReturnCallIndirectExpr(Index sig_index,
                                           Index table_index) = 0;
   virtual Result OnSelectExpr(Index result_count, Type* result_types) = 0;
   virtual Result OnStoreExpr(Opcode opcode,
                              Index memidx,
                              Address alignment_log2,
                              Address offset) = 0;
   virtual Result OnThrowExpr(Index tag_index) = 0;
   virtual Result OnTryExpr(Type sig_type) = 0;
 
   virtual Result OnUnaryExpr(Opcode opcode) = 0;
   virtual Result OnTernaryExpr(Opcode opcode) = 0;
   virtual Result OnUnreachableExpr() = 0;
   virtual Result EndFunctionBody(Index index) = 0;
   virtual Result EndCodeSection() = 0;
 
   /* Simd instructions with Lane Imm operand*/
   virtual Result OnSimdLaneOpExpr(Opcode opcode, uint64_t value) = 0;
   virtual Result OnSimdShuffleOpExpr(Opcode opcode, v128 value) = 0;
   virtual Result OnSimdLoadLaneExpr(Opcode opcode,
                                     Index memidx,
                                     Address alignment_log2,
                                     Address offset,
                                     uint64_t value) = 0;
   virtual Result OnSimdStoreLaneExpr(Opcode opcode,
                                      Index memidx,
                                      Address alignment_log2,
                                      Address offset,
                                      uint64_t value) = 0;
 
   virtual Result OnLoadSplatExpr(Opcode opcode,
                                  Index memidx,
                                  Address alignment_log2,
                                  Address offset) = 0;
   virtual Result OnLoadZeroExpr(Opcode opcode,
                                 Index memidx,
                                 Address alignment_log2,
                                 Address offset) = 0;
 
   /* Elem section */
   virtual Result BeginElemSection(Offset size) = 0;
   virtual Result OnElemSegmentCount(Index count) = 0;
   virtual Result BeginElemSegment(Index index,
                                   Index table_index,
                                   uint8_t flags) = 0;
   virtual Result BeginElemSegmentInitExpr(Index index) = 0;
   virtual Result EndElemSegmentInitExpr(Index index) = 0;
   virtual Result OnElemSegmentElemType(Index index, Type elem_type) = 0;
   virtual Result OnElemSegmentElemExprCount(Index index, Index count) = 0;
-  virtual Result OnElemSegmentElemExpr_RefNull(Index segment_index,
-                                               Type type) = 0;
-  virtual Result OnElemSegmentElemExpr_RefFunc(Index segment_index,
-                                               Index func_index) = 0;
+  virtual Result BeginElemExpr(Index elem_index, Index expr_index) = 0;
+  virtual Result EndElemExpr(Index elem_index, Index expr_index) = 0;
   virtual Result EndElemSegment(Index index) = 0;
   virtual Result EndElemSection() = 0;
 
   /* Data section */
   virtual Result BeginDataSection(Offset size) = 0;
   virtual Result OnDataSegmentCount(Index count) = 0;
   virtual Result BeginDataSegment(Index index,
                                   Index memory_index,
                                   uint8_t flags) = 0;
   virtual Result BeginDataSegmentInitExpr(Index index) = 0;
   virtual Result EndDataSegmentInitExpr(Index index) = 0;
   virtual Result OnDataSegmentData(Index index,
                                    const void* data,
                                    Address size) = 0;
   virtual Result EndDataSegment(Index index) = 0;
   virtual Result EndDataSection() = 0;
 
   /* DataCount section */
   virtual Result BeginDataCountSection(Offset size) = 0;
   virtual Result OnDataCount(Index count) = 0;
   virtual Result EndDataCountSection() = 0;
 
   /* Names section */
   virtual Result BeginNamesSection(Offset size) = 0;
   virtual Result OnModuleNameSubsection(Index index,
                                         uint32_t name_type,
                                         Offset subsection_size) = 0;
   virtual Result OnModuleName(std::string_view name) = 0;
   virtual Result OnFunctionNameSubsection(Index index,
                                           uint32_t name_type,
                                           Offset subsection_size) = 0;
   virtual Result OnFunctionNamesCount(Index num_functions) = 0;
   virtual Result OnFunctionName(Index function_index,
                                 std::string_view function_name) = 0;
   virtual Result OnLocalNameSubsection(Index index,
                                        uint32_t name_type,
                                        Offset subsection_size) = 0;
   virtual Result OnLocalNameFunctionCount(Index num_functions) = 0;
   virtual Result OnLocalNameLocalCount(Index function_index,
                                        Index num_locals) = 0;
   virtual Result OnLocalName(Index function_index,
                              Index local_index,
                              std::string_view local_name) = 0;
   virtual Result OnNameSubsection(Index index,
                                   NameSectionSubsection subsection_type,
                                   Offset subsection_size) = 0;
   virtual Result OnNameCount(Index num_names) = 0;
   virtual Result OnNameEntry(NameSectionSubsection type,
                              Index index,
                              std::string_view name) = 0;
   virtual Result EndNamesSection() = 0;
 
   /* Reloc section */
   virtual Result BeginRelocSection(Offset size) = 0;
   virtual Result OnRelocCount(Index count, Index section_index) = 0;
   virtual Result OnReloc(RelocType type,
                          Offset offset,
                          Index index,
                          uint32_t addend) = 0;
   virtual Result EndRelocSection() = 0;
 
   /* Dylink section */
   virtual Result BeginDylinkSection(Offset size) = 0;
   virtual Result OnDylinkInfo(uint32_t mem_size,
                               uint32_t mem_align_log2,
                               uint32_t table_size,
                               uint32_t table_align_log2) = 0;
   virtual Result OnDylinkImportCount(Index count) = 0;
   virtual Result OnDylinkExportCount(Index count) = 0;
   virtual Result OnDylinkImport(std::string_view module,
                                 std::string_view name,
                                 uint32_t flags) = 0;
   virtual Result OnDylinkExport(std::string_view name, uint32_t flags) = 0;
   virtual Result OnDylinkNeededCount(Index count) = 0;
   virtual Result OnDylinkNeeded(std::string_view so_name) = 0;
   virtual Result EndDylinkSection() = 0;
 
   /* target_features section */
   virtual Result BeginTargetFeaturesSection(Offset size) = 0;
   virtual Result OnFeatureCount(Index count) = 0;
   virtual Result OnFeature(uint8_t prefix, std::string_view name) = 0;
   virtual Result EndTargetFeaturesSection() = 0;
 
   /* Linking section */
   virtual Result BeginLinkingSection(Offset size) = 0;
   virtual Result OnSymbolCount(Index count) = 0;
   virtual Result OnDataSymbol(Index index,
                               uint32_t flags,
                               std::string_view name,
                               Index segment,
                               uint32_t offset,
                               uint32_t size) = 0;
   virtual Result OnFunctionSymbol(Index index,
                                   uint32_t flags,
                                   std::string_view name,
                                   Index function_index) = 0;
   virtual Result OnGlobalSymbol(Index index,
                                 uint32_t flags,
                                 std::string_view name,
                                 Index global_index) = 0;
   virtual Result OnSectionSymbol(Index index,
                                  uint32_t flags,
                                  Index section_index) = 0;
   virtual Result OnTagSymbol(Index index,
                              uint32_t flags,
                              std::string_view name,
                              Index tag_index) = 0;
   virtual Result OnTableSymbol(Index index,
                                uint32_t flags,
                                std::string_view name,
                                Index table_index) = 0;
   virtual Result OnSegmentInfoCount(Index count) = 0;
   virtual Result OnSegmentInfo(Index index,
                                std::string_view name,
                                Address alignment_log2,
                                uint32_t flags) = 0;
   virtual Result OnInitFunctionCount(Index count) = 0;
   virtual Result OnInitFunction(uint32_t priority, Index symbol_index) = 0;
   virtual Result OnComdatCount(Index count) = 0;
   virtual Result OnComdatBegin(std::string_view name,
                                uint32_t flags,
                                Index count) = 0;
   virtual Result OnComdatEntry(ComdatType kind, Index index) = 0;
   virtual Result EndLinkingSection() = 0;
 
   /* Tag section */
   virtual Result BeginTagSection(Offset size) = 0;
   virtual Result OnTagCount(Index count) = 0;
   virtual Result OnTagType(Index index, Index sig_index) = 0;
   virtual Result EndTagSection() = 0;
 
   /* Code Metadata sections */
   virtual Result BeginCodeMetadataSection(std::string_view name,
                                           Offset size) = 0;
   virtual Result OnCodeMetadataFuncCount(Index count) = 0;
   virtual Result OnCodeMetadataCount(Index function_index, Index count) = 0;
   virtual Result OnCodeMetadata(Offset offset,
                                 const void* data,
                                 Address size) = 0;
   virtual Result EndCodeMetadataSection() = 0;
 
   const State* state = nullptr;
 };
diff --git a/include/wabt/interp/interp.h b/include/wabt/interp/interp.h
index 6af605ac..3dda44ef 100644
--- a/include/wabt/interp/interp.h
+++ b/include/wabt/interp/interp.h
@@ -77,7 +77,6 @@ using ExternKind = ExternalKind;
 enum class Mutability { Const, Var };
 enum class TagAttr { Exception };
 using SegmentMode = SegmentKind;
-enum class ElemKind { RefNull, RefFunc };
 
 enum class ObjectKind {
   Null,
@@ -359,15 +358,10 @@ struct DataDesc {
   FuncDesc init_func;
 };
 
-struct ElemExpr {
-  ElemKind kind;
-  Index index;
-};
-
 struct ElemDesc {
-  std::vector<ElemExpr> elements;
+  std::vector<FuncDesc> elements;
   ValueType type;
   SegmentMode mode;
   Index table_index;
   FuncDesc init_func;
 };
@@ -972,19 +966,19 @@ class Tag : public Extern {
 
 class ElemSegment {
  public:
-  explicit ElemSegment(const ElemDesc*, RefPtr<Instance>&);
+  explicit ElemSegment(Store& store, const ElemDesc*, RefPtr<Instance>&);
 
   bool IsValidRange(u32 offset, u32 size) const;
   void Drop();
 
   const ElemDesc& desc() const;
   const RefVec& elements() const;
   u32 size() const;
 
  private:
   friend Instance;
   void Mark(Store&);
 
   const ElemDesc* desc_;  // Borrowed from the Module.
   RefVec elements_;
 };
diff --git a/include/wabt/shared-validator.h b/include/wabt/shared-validator.h
index 37927802..f2e2bf91 100644
--- a/include/wabt/shared-validator.h
+++ b/include/wabt/shared-validator.h
@@ -43,327 +43,324 @@ struct ValidateOptions {
 class SharedValidator {
  public:
   WABT_DISALLOW_COPY_AND_ASSIGN(SharedValidator);
   SharedValidator(Errors*, const ValidateOptions& options);
 
   // TODO: Move into SharedValidator?
   using Label = TypeChecker::Label;
   size_t type_stack_size() const { return typechecker_.type_stack_size(); }
   Result GetLabel(Index depth, Label** out_label) {
     return typechecker_.GetLabel(depth, out_label);
   }
   Result GetCatchCount(Index depth, Index* out_count) {
     return typechecker_.GetCatchCount(depth, out_count);
   }
 
   Result WABT_PRINTF_FORMAT(3, 4)
       PrintError(const Location& loc, const char* fmt, ...);
 
   void OnTypecheckerError(const char* msg);
 
   Index GetLocalCount() const;
 
   Result EndModule();
 
   Result OnFuncType(const Location&,
                     Index param_count,
                     const Type* param_types,
                     Index result_count,
                     const Type* result_types,
                     Index type_index);
   Result OnStructType(const Location&, Index field_count, TypeMut* fields);
   Result OnArrayType(const Location&, TypeMut field);
 
   Result OnFunction(const Location&, Var sig_var);
   Result OnTable(const Location&, Type elem_type, const Limits&);
   Result OnMemory(const Location&, const Limits&);
   Result OnGlobalImport(const Location&, Type type, bool mutable_);
   Result OnGlobal(const Location&, Type type, bool mutable_);
   Result OnTag(const Location&, Var sig_var);
 
   Result OnExport(const Location&,
                   ExternalKind,
                   Var item_var,
                   std::string_view name);
 
   Result OnStart(const Location&, Var func_var);
 
   Result OnElemSegment(const Location&, Var table_var, SegmentKind);
   Result OnElemSegmentElemType(const Location&, Type elem_type);
-  Result OnElemSegmentElemExpr_RefNull(const Location&, Type type);
-  Result OnElemSegmentElemExpr_RefFunc(const Location&, Var func_var);
-  Result OnElemSegmentElemExpr_Other(const Location&);
 
   void OnDataCount(Index count);
   Result OnDataSegment(const Location&, Var memory_var, SegmentKind);
 
   Result BeginInitExpr(const Location&, Type type);
   Result EndInitExpr();
 
   Result BeginFunctionBody(const Location&, Index func_index);
   Result EndFunctionBody(const Location&);
   Result OnLocalDecl(const Location&, Index count, Type type);
 
   Result OnAtomicFence(const Location&, uint32_t consistency_model);
   Result OnAtomicLoad(const Location&,
                       Opcode,
                       Var memidx,
                       Address align,
                       Address offset);
   Result OnAtomicNotify(const Location&,
                         Opcode,
                         Var memidx,
                         Address align,
                         Address offset);
   Result OnAtomicRmwCmpxchg(const Location&,
                             Opcode,
                             Var memidx,
                             Address align,
                             Address offset);
   Result OnAtomicRmw(const Location&,
                      Opcode,
                      Var memidx,
                      Address align,
                      Address offset);
   Result OnAtomicStore(const Location&,
                        Opcode,
                        Var memidx,
                        Address align,
                        Address offset);
   Result OnAtomicWait(const Location&,
                       Opcode,
                       Var memidx,
                       Address align,
                       Address offset);
   Result OnBinary(const Location&, Opcode);
   Result OnBlock(const Location&, Type sig_type);
   Result OnBr(const Location&, Var depth);
   Result OnBrIf(const Location&, Var depth);
   Result BeginBrTable(const Location&);
   Result OnBrTableTarget(const Location&, Var depth);
   Result EndBrTable(const Location&);
   Result OnCall(const Location&, Var func_var);
   Result OnCallIndirect(const Location&, Var sig_var, Var table_var);
   Result OnCallRef(const Location&, Index* function_type_index);
   Result OnCatch(const Location&, Var tag_var, bool is_catch_all);
   Result OnCompare(const Location&, Opcode);
   Result OnConst(const Location&, Type);
   Result OnConvert(const Location&, Opcode);
   Result OnDataDrop(const Location&, Var segment_var);
   Result OnDelegate(const Location&, Var depth);
   Result OnDrop(const Location&);
   Result OnElemDrop(const Location&, Var segment_var);
   Result OnElse(const Location&);
   Result OnEnd(const Location&);
   Result OnGlobalGet(const Location&, Var);
   Result OnGlobalSet(const Location&, Var);
   Result OnIf(const Location&, Type sig_type);
   Result OnLoad(const Location&, Opcode, Var memidx, Address align, Address offset);
   Result OnLoadSplat(const Location&,
                      Opcode,
                      Var memidx,
                      Address align,
                      Address offset);
   Result OnLoadZero(const Location&,
                     Opcode,
                     Var memidx,
                     Address align,
                     Address offset);
   Result OnLocalGet(const Location&, Var);
   Result OnLocalSet(const Location&, Var);
   Result OnLocalTee(const Location&, Var);
   Result OnLoop(const Location&, Type sig_type);
   Result OnMemoryCopy(const Location&, Var srcmemidx, Var destmemidx);
   Result OnMemoryFill(const Location&, Var memidx);
   Result OnMemoryGrow(const Location&, Var memidx);
   Result OnMemoryInit(const Location&, Var segment_var, Var memidx);
   Result OnMemorySize(const Location&, Var memidx);
   Result OnNop(const Location&);
   Result OnRefFunc(const Location&, Var func_var);
   Result OnRefIsNull(const Location&);
   Result OnRefNull(const Location&, Type type);
   Result OnRethrow(const Location&, Var depth);
   Result OnReturnCall(const Location&, Var func_var);
   Result OnReturnCallIndirect(const Location&, Var sig_var, Var table_var);
   Result OnReturn(const Location&);
   Result OnSelect(const Location&, Index result_count, Type* result_types);
   Result OnSimdLaneOp(const Location&, Opcode, uint64_t lane_idx);
   Result OnSimdLoadLane(const Location&,
                         Opcode,
                         Var memidx,
                         Address align,
                         Address offset,
                         uint64_t lane_idx);
   Result OnSimdStoreLane(const Location&,
                          Opcode,
                          Var memidx,
                          Address align,
                          Address offset,
                          uint64_t lane_idx);
   Result OnSimdShuffleOp(const Location&, Opcode, v128 lane_idx);
   Result OnStore(const Location&,
                  Opcode,
                  Var memidx,
                  Address align,
                  Address offset);
   Result OnTableCopy(const Location&, Var dst_var, Var src_var);
   Result OnTableFill(const Location&, Var table_var);
   Result OnTableGet(const Location&, Var table_var);
   Result OnTableGrow(const Location&, Var table_var);
   Result OnTableInit(const Location&, Var segment_var, Var table_var);
   Result OnTableSet(const Location&, Var table_var);
   Result OnTableSize(const Location&, Var table_var);
   Result OnTernary(const Location&, Opcode);
   Result OnThrow(const Location&, Var tag_var);
   Result OnTry(const Location&, Type sig_type);
   Result OnUnary(const Location&, Opcode);
   Result OnUnreachable(const Location&);
 
  private:
   struct FuncType {
     FuncType() = default;
     FuncType(const TypeVector& params,
              const TypeVector& results,
              Index type_index)
         : params(params), results(results), type_index(type_index) {}
 
     TypeVector params;
     TypeVector results;
     Index type_index;
   };
 
   struct StructType {
     StructType() = default;
     StructType(const TypeMutVector& fields) : fields(fields) {}
 
     TypeMutVector fields;
   };
 
   struct ArrayType {
     ArrayType() = default;
     ArrayType(TypeMut field) : field(field) {}
 
     TypeMut field;
   };
 
   struct TableType {
     TableType() = default;
     TableType(Type element, Limits limits) : element(element), limits(limits) {}
 
     Type element = Type::Any;
     Limits limits;
   };
 
   struct MemoryType {
     MemoryType() = default;
     MemoryType(Limits limits) : limits(limits) {}
 
     Limits limits;
   };
 
   struct GlobalType {
     GlobalType() = default;
     GlobalType(Type type, bool mutable_) : type(type), mutable_(mutable_) {}
 
     Type type = Type::Any;
     bool mutable_ = true;
   };
 
   struct TagType {
     TypeVector params;
   };
 
   struct ElemType {
     ElemType() = default;
     ElemType(Type element, bool is_active, Type table_type)
         : element(element), is_active(is_active), table_type(table_type) {}
 
     Type element;
     bool is_active;
     Type table_type;
   };
 
   struct LocalDecl {
     Type type;
     Index end;
   };
 
   bool ValidInitOpcode(Opcode opcode) const;
   Result CheckInstr(Opcode opcode, const Location& loc);
   Result CheckType(const Location&,
                    Type actual,
                    Type expected,
                    const char* desc);
   Result CheckLimits(const Location&,
                      const Limits&,
                      uint64_t absolute_max,
                      const char* desc);
 
   Result CheckLocalIndex(Var local_var, Type* out_type);
 
   Result CheckDeclaredFunc(Var func_var);
 
   Result CheckIndex(Var var, Index max_index, const char* desc);
   template <typename T>
   Result CheckIndexWithValue(Var var,
                              const std::vector<T>& values,
                              T* out,
                              const char* desc);
   Result CheckFuncTypeIndex(Var sig_var, FuncType* out = nullptr);
   Result CheckFuncIndex(Var func_var, FuncType* out = nullptr);
   Result CheckTableIndex(Var table_var, TableType* out = nullptr);
   Result CheckMemoryIndex(Var memory_var, MemoryType* out = nullptr);
   Result CheckGlobalIndex(Var global_var, GlobalType* out = nullptr);
   Result CheckTagIndex(Var tag_var, TagType* out = nullptr);
   Result CheckElemSegmentIndex(Var elem_segment_var, ElemType* out = nullptr);
   Result CheckDataSegmentIndex(Var data_segment_var);
 
   Result CheckAlign(const Location&, Address align, Address natural_align);
   Result CheckOffset(const Location&, Address offset, const Limits& limits);
   Result CheckAtomicAlign(const Location&,
                           Address align,
                           Address natural_align);
 
   Result CheckBlockSignature(const Location&,
                              Opcode,
                              Type sig_type,
                              TypeVector* out_param_types,
                              TypeVector* out_result_types);
 
   Index GetFunctionTypeIndex(Index func_index) const;
 
   TypeVector ToTypeVector(Index count, const Type* types);
 
   ValidateOptions options_;
   Errors* errors_;
   TypeChecker typechecker_;  // TODO: Move into SharedValidator.
   // Cached for access by OnTypecheckerError.
   Location expr_loc_ = Location(kInvalidOffset);
   bool in_init_expr_ = false;
 
   Index num_types_ = 0;
   std::map<Index, FuncType> func_types_;
   std::map<Index, StructType> struct_types_;
   std::map<Index, ArrayType> array_types_;
 
   std::vector<FuncType> funcs_;       // Includes imported and defined.
   std::vector<TableType> tables_;     // Includes imported and defined.
   std::vector<MemoryType> memories_;  // Includes imported and defined.
   std::vector<GlobalType> globals_;   // Includes imported and defined.
   std::vector<TagType> tags_;         // Includes imported and defined.
   std::vector<ElemType> elems_;
   Index starts_ = 0;
   Index num_imported_globals_ = 0;
   Index data_segments_ = 0;
 
   // Includes parameters, since this is only used for validating
   // local.{get,set,tee} instructions.
   std::vector<LocalDecl> locals_;
 
   std::set<std::string> export_names_;  // Used to check for duplicates.
   std::set<Index> declared_funcs_;      // TODO: optimize?
   std::vector<Var> check_declared_funcs_;
 };
 
 }  // namespace wabt
 
 #endif  // WABT_SHARED_VALIDATOR_H_
diff --git a/include/wabt/type-checker.h b/include/wabt/type-checker.h
index 2b0ec092..7807e89e 100644
--- a/include/wabt/type-checker.h
+++ b/include/wabt/type-checker.h
@@ -29,179 +29,179 @@ namespace wabt {
 class TypeChecker {
  public:
   using ErrorCallback = std::function<void(const char* msg)>;
 
   struct Label {
     Label(LabelType,
           const TypeVector& param_types,
           const TypeVector& result_types,
           size_t limit);
 
     TypeVector& br_types() {
       return label_type == LabelType::Loop ? param_types : result_types;
     }
 
     LabelType label_type;
     TypeVector param_types;
     TypeVector result_types;
     size_t type_stack_limit;
     bool unreachable;
   };
 
   explicit TypeChecker(const Features& features) : features_(features) {}
 
   void set_error_callback(const ErrorCallback& error_callback) {
     error_callback_ = error_callback;
   }
 
   size_t type_stack_size() const { return type_stack_.size(); }
 
   bool IsUnreachable();
   Result GetLabel(Index depth, Label** out_label);
   Result GetRethrowLabel(Index depth, Label** out_label);
   Result GetCatchCount(Index depth, Index* out_depth);
 
   Result BeginFunction(const TypeVector& sig);
   Result OnAtomicFence(uint32_t consistency_model);
   Result OnAtomicLoad(Opcode, const Limits& limits);
   Result OnAtomicNotify(Opcode, const Limits& limits);
   Result OnAtomicStore(Opcode, const Limits& limits);
   Result OnAtomicRmw(Opcode, const Limits& limits);
   Result OnAtomicRmwCmpxchg(Opcode, const Limits& limits);
   Result OnAtomicWait(Opcode, const Limits& limits);
   Result OnBinary(Opcode);
   Result OnBlock(const TypeVector& param_types, const TypeVector& result_types);
   Result OnBr(Index depth);
   Result OnBrIf(Index depth);
   Result BeginBrTable();
   Result OnBrTableTarget(Index depth);
   Result EndBrTable();
   Result OnCall(const TypeVector& param_types, const TypeVector& result_types);
   Result OnCallIndirect(const TypeVector& param_types,
                         const TypeVector& result_types);
   Result OnIndexedFuncRef(Index* out_index);
   Result OnReturnCall(const TypeVector& param_types,
                       const TypeVector& result_types);
   Result OnReturnCallIndirect(const TypeVector& param_types,
                               const TypeVector& result_types);
   Result OnCatch(const TypeVector& sig);
   Result OnCompare(Opcode);
   Result OnConst(Type);
   Result OnConvert(Opcode);
   Result OnDelegate(Index depth);
   Result OnDrop();
   Result OnElse();
   Result OnEnd();
   Result OnGlobalGet(Type);
   Result OnGlobalSet(Type);
   Result OnIf(const TypeVector& param_types, const TypeVector& result_types);
   Result OnLoad(Opcode, const Limits& limits);
   Result OnLocalGet(Type);
   Result OnLocalSet(Type);
   Result OnLocalTee(Type);
   Result OnLoop(const TypeVector& param_types, const TypeVector& result_types);
   Result OnMemoryCopy(const Limits& srclimits, const Limits& dstlimits);
   Result OnDataDrop(Index);
   Result OnMemoryFill(const Limits& limits);
   Result OnMemoryGrow(const Limits& limits);
   Result OnMemoryInit(Index, const Limits& limits);
   Result OnMemorySize(const Limits& limits);
   Result OnTableCopy();
   Result OnElemDrop(Index);
   Result OnTableInit(Index, Index);
   Result OnTableGet(Type elem_type);
   Result OnTableSet(Type elem_type);
   Result OnTableGrow(Type elem_type);
   Result OnTableSize();
   Result OnTableFill(Type elem_type);
-  Result OnRefFuncExpr(Index func_type);
+  Result OnRefFuncExpr(Index func_type, bool force_generic_funcref);
   Result OnRefNullExpr(Type type);
   Result OnRefIsNullExpr();
   Result OnRethrow(Index depth);
   Result OnReturn();
   Result OnSelect(const TypeVector& result_types);
   Result OnSimdLaneOp(Opcode, uint64_t);
   Result OnSimdLoadLane(Opcode, const Limits& limits, uint64_t);
   Result OnSimdStoreLane(Opcode, const Limits& limits, uint64_t);
   Result OnSimdShuffleOp(Opcode, v128);
   Result OnStore(Opcode, const Limits& limits);
   Result OnTernary(Opcode);
   Result OnThrow(const TypeVector& sig);
   Result OnTry(const TypeVector& param_types, const TypeVector& result_types);
   Result OnUnary(Opcode);
   Result OnUnreachable();
   Result EndFunction();
 
   Result BeginInitExpr(Type type);
   Result EndInitExpr();
 
   static Result CheckType(Type actual, Type expected);
 
  private:
   void WABT_PRINTF_FORMAT(2, 3) PrintError(const char* fmt, ...);
   Result TopLabel(Label** out_label);
   void ResetTypeStackToLabel(Label* label);
   Result SetUnreachable();
   void PushLabel(LabelType label_type,
                  const TypeVector& param_types,
                  const TypeVector& result_types);
   Result PopLabel();
   Result CheckLabelType(Label* label, LabelType label_type);
   Result Check2LabelTypes(Label* label,
                           LabelType label_type1,
                           LabelType label_type2);
   Result GetThisFunctionLabel(Label** label);
   Result PeekType(Index depth, Type* out_type);
   Result PeekAndCheckType(Index depth, Type expected);
   Result DropTypes(size_t drop_count);
   void PushType(Type type);
   void PushTypes(const TypeVector& types);
   Result CheckTypeStackEnd(const char* desc);
   Result CheckTypes(const TypeVector& actual, const TypeVector& expected);
   Result CheckSignature(const TypeVector& sig, const char* desc);
   Result CheckReturnSignature(const TypeVector& sig,
                               const TypeVector& expected,
                               const char* desc);
   Result PopAndCheckSignature(const TypeVector& sig, const char* desc);
   Result PopAndCheckCall(const TypeVector& param_types,
                          const TypeVector& result_types,
                          const char* desc);
   Result PopAndCheck1Type(Type expected, const char* desc);
   Result PopAndCheck2Types(Type expected1, Type expected2, const char* desc);
   Result PopAndCheck3Types(Type expected1,
                            Type expected2,
                            Type expected3,
                            const char* desc);
   Result CheckOpcode1(Opcode opcode, const Limits* limits = nullptr);
   Result CheckOpcode2(Opcode opcode, const Limits* limits = nullptr);
   Result CheckOpcode3(Opcode opcode,
                       const Limits* limits1 = nullptr,
                       const Limits* limits2 = nullptr,
                       const Limits* limits3 = nullptr);
   Result OnEnd(Label* label, const char* sig_desc, const char* end_desc);
 
   template <typename... Args>
   void PrintStackIfFailed(Result result, const char* desc, Args... args) {
     // Minor optimization, check result before constructing the vector to pass
     // to the other overload of PrintStackIfFailed.
     if (Failed(result)) {
       PrintStackIfFailedV(result, desc, {args...}, /*is_end=*/false);
     }
   }
 
   void PrintStackIfFailedV(Result,
                            const char* desc,
                            const TypeVector&,
                            bool is_end);
 
   ErrorCallback error_callback_;
   TypeVector type_stack_;
   std::vector<Label> label_stack_;
   // Cache the expected br_table signature. It will be initialized to `nullptr`
   // to represent "any".
   TypeVector* br_table_sig_ = nullptr;
   Features features_;
 };
 
 }  // namespace wabt
 
 #endif /* WABT_TYPE_CHECKER_H_ */
diff --git a/src/binary-reader-ir.cc b/src/binary-reader-ir.cc
index 2eb2342b..69ff72aa 100644
--- a/src/binary-reader-ir.cc
+++ b/src/binary-reader-ir.cc
@@ -93,300 +93,299 @@ class CodeMetadataExprQueue {
 class BinaryReaderIR : public BinaryReaderNop {
   static constexpr size_t kMaxNestingDepth = 16384;  // max depth of label stack
   static constexpr size_t kMaxFunctionLocals = 50000;  // matches V8
   static constexpr size_t kMaxFunctionParams = 1000;   // matches V8
   static constexpr size_t kMaxFunctionResults = 1000;  // matches V8
 
  public:
   BinaryReaderIR(Module* out_module, const char* filename, Errors* errors);
 
   bool OnError(const Error&) override;
 
   Result OnTypeCount(Index count) override;
   Result OnFuncType(Index index,
                     Index param_count,
                     Type* param_types,
                     Index result_count,
                     Type* result_types) override;
   Result OnStructType(Index index, Index field_count, TypeMut* fields) override;
   Result OnArrayType(Index index, TypeMut field) override;
 
   Result OnImportCount(Index count) override;
   Result OnImportFunc(Index import_index,
                       std::string_view module_name,
                       std::string_view field_name,
                       Index func_index,
                       Index sig_index) override;
   Result OnImportTable(Index import_index,
                        std::string_view module_name,
                        std::string_view field_name,
                        Index table_index,
                        Type elem_type,
                        const Limits* elem_limits) override;
   Result OnImportMemory(Index import_index,
                         std::string_view module_name,
                         std::string_view field_name,
                         Index memory_index,
                         const Limits* page_limits) override;
   Result OnImportGlobal(Index import_index,
                         std::string_view module_name,
                         std::string_view field_name,
                         Index global_index,
                         Type type,
                         bool mutable_) override;
   Result OnImportTag(Index import_index,
                      std::string_view module_name,
                      std::string_view field_name,
                      Index tag_index,
                      Index sig_index) override;
 
   Result OnFunctionCount(Index count) override;
   Result OnFunction(Index index, Index sig_index) override;
 
   Result OnTableCount(Index count) override;
   Result OnTable(Index index,
                  Type elem_type,
                  const Limits* elem_limits) override;
 
   Result OnMemoryCount(Index count) override;
   Result OnMemory(Index index, const Limits* limits) override;
 
   Result OnGlobalCount(Index count) override;
   Result BeginGlobal(Index index, Type type, bool mutable_) override;
   Result BeginGlobalInitExpr(Index index) override;
   Result EndGlobalInitExpr(Index index) override;
 
   Result OnExportCount(Index count) override;
   Result OnExport(Index index,
                   ExternalKind kind,
                   Index item_index,
                   std::string_view name) override;
 
   Result OnStartFunction(Index func_index) override;
 
   Result OnFunctionBodyCount(Index count) override;
   Result BeginFunctionBody(Index index, Offset size) override;
   Result OnLocalDecl(Index decl_index, Index count, Type type) override;
 
   Result OnOpcode(Opcode opcode) override;
   Result OnAtomicLoadExpr(Opcode opcode,
                           Index memidx,
                           Address alignment_log2,
                           Address offset) override;
   Result OnAtomicStoreExpr(Opcode opcode,
                            Index memidx,
                            Address alignment_log2,
                            Address offset) override;
   Result OnAtomicRmwExpr(Opcode opcode,
                          Index memidx,
                          Address alignment_log2,
                          Address offset) override;
   Result OnAtomicRmwCmpxchgExpr(Opcode opcode,
                                 Index memidx,
                                 Address alignment_log2,
                                 Address offset) override;
   Result OnAtomicWaitExpr(Opcode opcode,
                           Index memidx,
                           Address alignment_log2,
                           Address offset) override;
   Result OnAtomicFenceExpr(uint32_t consistency_model) override;
   Result OnAtomicNotifyExpr(Opcode opcode,
                             Index memidx,
                             Address alignment_log2,
                             Address offset) override;
   Result OnBinaryExpr(Opcode opcode) override;
   Result OnBlockExpr(Type sig_type) override;
   Result OnBrExpr(Index depth) override;
   Result OnBrIfExpr(Index depth) override;
   Result OnBrTableExpr(Index num_targets,
                        Index* target_depths,
                        Index default_target_depth) override;
   Result OnCallExpr(Index func_index) override;
   Result OnCatchExpr(Index tag_index) override;
   Result OnCatchAllExpr() override;
   Result OnCallIndirectExpr(Index sig_index, Index table_index) override;
   Result OnCallRefExpr() override;
   Result OnReturnCallExpr(Index func_index) override;
   Result OnReturnCallIndirectExpr(Index sig_index, Index table_index) override;
   Result OnCompareExpr(Opcode opcode) override;
   Result OnConvertExpr(Opcode opcode) override;
   Result OnDelegateExpr(Index depth) override;
   Result OnDropExpr() override;
   Result OnElseExpr() override;
   Result OnEndExpr() override;
   Result OnF32ConstExpr(uint32_t value_bits) override;
   Result OnF64ConstExpr(uint64_t value_bits) override;
   Result OnV128ConstExpr(v128 value_bits) override;
   Result OnGlobalGetExpr(Index global_index) override;
   Result OnGlobalSetExpr(Index global_index) override;
   Result OnI32ConstExpr(uint32_t value) override;
   Result OnI64ConstExpr(uint64_t value) override;
   Result OnIfExpr(Type sig_type) override;
   Result OnLoadExpr(Opcode opcode,
                     Index memidx,
                     Address alignment_log2,
                     Address offset) override;
   Result OnLocalGetExpr(Index local_index) override;
   Result OnLocalSetExpr(Index local_index) override;
   Result OnLocalTeeExpr(Index local_index) override;
   Result OnLoopExpr(Type sig_type) override;
   Result OnMemoryCopyExpr(Index srcmemidx, Index destmemidx) override;
   Result OnDataDropExpr(Index segment_index) override;
   Result OnMemoryFillExpr(Index memidx) override;
   Result OnMemoryGrowExpr(Index memidx) override;
   Result OnMemoryInitExpr(Index segment_index, Index memidx) override;
   Result OnMemorySizeExpr(Index memidx) override;
   Result OnTableCopyExpr(Index dst_index, Index src_index) override;
   Result OnElemDropExpr(Index segment_index) override;
   Result OnTableInitExpr(Index segment_index, Index table_index) override;
   Result OnTableGetExpr(Index table_index) override;
   Result OnTableSetExpr(Index table_index) override;
   Result OnTableGrowExpr(Index table_index) override;
   Result OnTableSizeExpr(Index table_index) override;
   Result OnTableFillExpr(Index table_index) override;
   Result OnRefFuncExpr(Index func_index) override;
   Result OnRefNullExpr(Type type) override;
   Result OnRefIsNullExpr() override;
   Result OnNopExpr() override;
   Result OnRethrowExpr(Index depth) override;
   Result OnReturnExpr() override;
   Result OnSelectExpr(Index result_count, Type* result_types) override;
   Result OnStoreExpr(Opcode opcode,
                      Index memidx,
                      Address alignment_log2,
                      Address offset) override;
   Result OnThrowExpr(Index tag_index) override;
   Result OnTryExpr(Type sig_type) override;
   Result OnUnaryExpr(Opcode opcode) override;
   Result OnTernaryExpr(Opcode opcode) override;
   Result OnUnreachableExpr() override;
   Result EndFunctionBody(Index index) override;
   Result OnSimdLaneOpExpr(Opcode opcode, uint64_t value) override;
   Result OnSimdLoadLaneExpr(Opcode opcode,
                             Index memidx,
                             Address alignment_log2,
                             Address offset,
                             uint64_t value) override;
   Result OnSimdStoreLaneExpr(Opcode opcode,
                              Index memidx,
                              Address alignment_log2,
                              Address offset,
                              uint64_t value) override;
   Result OnSimdShuffleOpExpr(Opcode opcode, v128 value) override;
   Result OnLoadSplatExpr(Opcode opcode,
                          Index memidx,
                          Address alignment_log2,
                          Address offset) override;
   Result OnLoadZeroExpr(Opcode opcode,
                         Index memidx,
                         Address alignment_log2,
                         Address offset) override;
 
   Result OnElemSegmentCount(Index count) override;
   Result BeginElemSegment(Index index,
                           Index table_index,
                           uint8_t flags) override;
   Result BeginElemSegmentInitExpr(Index index) override;
   Result EndElemSegmentInitExpr(Index index) override;
   Result OnElemSegmentElemType(Index index, Type elem_type) override;
   Result OnElemSegmentElemExprCount(Index index, Index count) override;
-  Result OnElemSegmentElemExpr_RefNull(Index segment_index, Type type) override;
-  Result OnElemSegmentElemExpr_RefFunc(Index segment_index,
-                                       Index func_index) override;
+  Result BeginElemExpr(Index elem_index, Index expr_index) override;
+  Result EndElemExpr(Index elem_index, Index expr_index) override;
 
   Result OnDataSegmentCount(Index count) override;
   Result BeginDataSegment(Index index,
                           Index memory_index,
                           uint8_t flags) override;
   Result BeginDataSegmentInitExpr(Index index) override;
   Result EndDataSegmentInitExpr(Index index) override;
   Result OnDataSegmentData(Index index,
                            const void* data,
                            Address size) override;
 
   Result OnModuleName(std::string_view module_name) override;
   Result OnFunctionNamesCount(Index num_functions) override;
   Result OnFunctionName(Index function_index,
                         std::string_view function_name) override;
   Result OnLocalNameLocalCount(Index function_index, Index num_locals) override;
   Result OnLocalName(Index function_index,
                      Index local_index,
                      std::string_view local_name) override;
   Result OnNameEntry(NameSectionSubsection type,
                      Index index,
                      std::string_view name) override;
 
   Result BeginTagSection(Offset size) override { return Result::Ok; }
   Result OnTagCount(Index count) override { return Result::Ok; }
   Result OnTagType(Index index, Index sig_index) override;
   Result EndTagSection() override { return Result::Ok; }
 
   Result OnDataSymbol(Index index,
                       uint32_t flags,
                       std::string_view name,
                       Index segment,
                       uint32_t offset,
                       uint32_t size) override;
   Result OnFunctionSymbol(Index index,
                           uint32_t flags,
                           std::string_view name,
                           Index func_index) override;
   Result OnGlobalSymbol(Index index,
                         uint32_t flags,
                         std::string_view name,
                         Index global_index) override;
   Result OnSectionSymbol(Index index,
                          uint32_t flags,
                          Index section_index) override;
   /* Code Metadata sections */
   Result BeginCodeMetadataSection(std::string_view name, Offset size) override;
   Result OnCodeMetadataFuncCount(Index count) override;
   Result OnCodeMetadataCount(Index function_index, Index count) override;
   Result OnCodeMetadata(Offset offset, const void* data, Address size) override;
 
   Result OnTagSymbol(Index index,
                      uint32_t flags,
                      std::string_view name,
                      Index tag_index) override;
   Result OnTableSymbol(Index index,
                        uint32_t flags,
                        std::string_view name,
                        Index table_index) override;
 
  private:
   Location GetLocation() const;
   void PrintError(const char* format, ...);
   Result PushLabel(LabelType label_type,
                    ExprList* first,
                    Expr* context = nullptr);
   Result BeginInitExpr(ExprList* init_expr);
   Result EndInitExpr();
   Result PopLabel();
   Result GetLabelAt(LabelNode** label, Index depth);
   Result TopLabel(LabelNode** label);
   Result TopLabelExpr(LabelNode** label, Expr** expr);
   Result AppendExpr(std::unique_ptr<Expr> expr);
   Result AppendCatch(Catch&& catch_);
   void SetFuncDeclaration(FuncDeclaration* decl, Var var);
   void SetBlockDeclaration(BlockDeclaration* decl, Type sig_type);
   Result SetMemoryName(Index index, std::string_view name);
   Result SetTableName(Index index, std::string_view name);
   Result SetFunctionName(Index index, std::string_view name);
   Result SetTypeName(Index index, std::string_view name);
   Result SetGlobalName(Index index, std::string_view name);
   Result SetDataSegmentName(Index index, std::string_view name);
   Result SetElemSegmentName(Index index, std::string_view name);
   Result SetTagName(Index index, std::string_view name);
 
   std::string GetUniqueName(BindingHash* bindings,
                             const std::string& original_name);
 
   Errors* errors_ = nullptr;
   Module* module_ = nullptr;
 
   Func* current_func_ = nullptr;
   std::vector<LabelNode> label_stack_;
   const char* filename_;
 
   CodeMetadataExprQueue code_metadata_queue_;
   std::string_view current_metadata_name_;
 };
@@ -1350,26 +1349,16 @@ Result BinaryReaderIR::OnElemSegmentElemExprCount(Index index, Index count) {
   return Result::Ok;
 }
 
-Result BinaryReaderIR::OnElemSegmentElemExpr_RefNull(Index segment_index,
-                                                     Type type) {
-  assert(segment_index == module_->elem_segments.size() - 1);
-  ElemSegment* segment = module_->elem_segments[segment_index];
-  Location loc = GetLocation();
-  ExprList init_expr;
-  init_expr.push_back(std::make_unique<RefNullExpr>(type, loc));
-  segment->elem_exprs.push_back(std::move(init_expr));
-  return Result::Ok;
+Result BinaryReaderIR::BeginElemExpr(Index elem_index, Index expr_index) {
+  assert(elem_index == module_->elem_segments.size() - 1);
+  ElemSegment* segment = module_->elem_segments[elem_index];
+  assert(expr_index == segment->elem_exprs.size());
+  segment->elem_exprs.emplace_back();
+  return BeginInitExpr(&segment->elem_exprs.back());
 }
 
-Result BinaryReaderIR::OnElemSegmentElemExpr_RefFunc(Index segment_index,
-                                                     Index func_index) {
-  assert(segment_index == module_->elem_segments.size() - 1);
-  ElemSegment* segment = module_->elem_segments[segment_index];
-  Location loc = GetLocation();
-  ExprList init_expr;
-  init_expr.push_back(std::make_unique<RefFuncExpr>(Var(func_index, loc), loc));
-  segment->elem_exprs.push_back(std::move(init_expr));
-  return Result::Ok;
+Result BinaryReaderIR::EndElemExpr(Index elem_index, Index expr_index) {
+  return EndInitExpr();
 }
 
 Result BinaryReaderIR::OnDataSegmentCount(Index count) {
diff --git a/src/binary-reader-logging.cc b/src/binary-reader-logging.cc
index 83a14e9f..bc2e58c9 100644
--- a/src/binary-reader-logging.cc
+++ b/src/binary-reader-logging.cc
@@ -850,8 +850,8 @@ DEFINE_INDEX(OnElemSegmentCount)
 DEFINE_INDEX(BeginElemSegmentInitExpr)
 DEFINE_INDEX(EndElemSegmentInitExpr)
 DEFINE_INDEX_INDEX(OnElemSegmentElemExprCount, "index", "count")
-DEFINE_INDEX_TYPE(OnElemSegmentElemExpr_RefNull)
-DEFINE_INDEX_INDEX(OnElemSegmentElemExpr_RefFunc, "index", "func_index")
+DEFINE_INDEX_INDEX(BeginElemExpr, "elem_index", "expr_index")
+DEFINE_INDEX_INDEX(EndElemExpr, "elem_index", "expr_index")
 DEFINE_INDEX(EndElemSegment)
 DEFINE_END(EndElemSection)
 
diff --git a/src/binary-reader-objdump.cc b/src/binary-reader-objdump.cc
index d7643f31..bca6a2b9 100644
--- a/src/binary-reader-objdump.cc
+++ b/src/binary-reader-objdump.cc
@@ -978,14 +978,15 @@ Result BinaryReaderObjdumpDisassemble::OnOpcodeBlockSig(Type sig_type) {
 }
 
 enum class InitExprType {
+  Invalid,
   I32,
   F32,
   I64,
   F64,
   V128,
   Global,
   FuncRef,
   // TODO: There isn't a nullref anymore, this just represents ref.null of some
   // type T.
   NullRef,
 };
@@ -1011,236 +1012,250 @@ struct InitExpr {
 class BinaryReaderObjdump : public BinaryReaderObjdumpBase {
  public:
   BinaryReaderObjdump(const uint8_t* data,
                       size_t size,
                       ObjdumpOptions* options,
                       ObjdumpState* state);
 
   Result EndModule() override;
   Result BeginSection(Index section_index,
                       BinarySection section_type,
                       Offset size) override;
   Result BeginCustomSection(Index section_index,
                             Offset size,
                             std::string_view section_name) override;
 
   Result OnTypeCount(Index count) override;
   Result OnFuncType(Index index,
                     Index param_count,
                     Type* param_types,
                     Index result_count,
                     Type* result_types) override;
   Result OnStructType(Index index, Index field_count, TypeMut* fields) override;
   Result OnArrayType(Index index, TypeMut field) override;
 
   Result OnImportCount(Index count) override;
   Result OnImportFunc(Index import_index,
                       std::string_view module_name,
                       std::string_view field_name,
                       Index func_index,
                       Index sig_index) override;
   Result OnImportTable(Index import_index,
                        std::string_view module_name,
                        std::string_view field_name,
                        Index table_index,
                        Type elem_type,
                        const Limits* elem_limits) override;
   Result OnImportMemory(Index import_index,
                         std::string_view module_name,
                         std::string_view field_name,
                         Index memory_index,
                         const Limits* page_limits) override;
   Result OnImportGlobal(Index import_index,
                         std::string_view module_name,
                         std::string_view field_name,
                         Index global_index,
                         Type type,
                         bool mutable_) override;
   Result OnImportTag(Index import_index,
                      std::string_view module_name,
                      std::string_view field_name,
                      Index tag_index,
                      Index sig_index) override;
 
   Result OnFunctionCount(Index count) override;
   Result OnFunction(Index index, Index sig_index) override;
 
   Result OnTableCount(Index count) override;
   Result OnTable(Index index,
                  Type elem_type,
                  const Limits* elem_limits) override;
 
   Result OnMemoryCount(Index count) override;
   Result OnMemory(Index index, const Limits* limits) override;
 
   Result OnGlobalCount(Index count) override;
   Result BeginGlobal(Index index, Type type, bool mutable_) override;
 
   Result OnExportCount(Index count) override;
   Result OnExport(Index index,
                   ExternalKind kind,
                   Index item_index,
                   std::string_view name) override;
 
   Result OnStartFunction(Index func_index) override;
   Result OnDataCount(Index count) override;
 
   Result OnFunctionBodyCount(Index count) override;
   Result BeginFunctionBody(Index index, Offset size) override;
 
   Result OnElemSegmentCount(Index count) override;
   Result BeginElemSegment(Index index,
                           Index table_index,
                           uint8_t flags) override;
   Result OnElemSegmentElemType(Index index, Type elem_type) override;
   Result OnElemSegmentElemExprCount(Index index, Index count) override;
-  Result OnElemSegmentElemExpr_RefNull(Index segment_index, Type type) override;
-  Result OnElemSegmentElemExpr_RefFunc(Index segment_index,
-                                       Index func_index) override;
 
   void BeginInitExpr() { current_init_expr_.insts.clear(); }
 
   Result BeginElemSegmentInitExpr(Index index) override {
     reading_elem_init_expr_ = true;
     BeginInitExpr();
     return Result::Ok;
   }
 
   Result EndElemSegmentInitExpr(Index index) override { return EndInitExpr(); }
 
   Result BeginDataSegmentInitExpr(Index index) override {
     reading_data_init_expr_ = true;
     BeginInitExpr();
     return Result::Ok;
   }
 
   Result EndDataSegmentInitExpr(Index index) override { return EndInitExpr(); }
 
   Result BeginGlobalInitExpr(Index index) override {
     reading_global_init_expr_ = true;
     BeginInitExpr();
     return Result::Ok;
   }
 
   Result EndGlobalInitExpr(Index index) override { return EndInitExpr(); }
 
+  Result BeginElemExpr(Index elem_index, Index expr_index) override {
+    reading_elem_expr_ = true;
+    elem_index_ = expr_index;
+    BeginInitExpr();
+    return Result::Ok;
+  }
+
+  Result EndElemExpr(Index elem_index, Index expr_index) override {
+    assert(expr_index == elem_index_);
+    return EndInitExpr();
+  }
+
   Result OnDataSegmentCount(Index count) override;
   Result BeginDataSegment(Index index,
                           Index memory_index,
                           uint8_t flags) override;
   Result OnDataSegmentData(Index index,
                            const void* data,
                            Address size) override;
 
   Result OnModuleName(std::string_view name) override;
   Result OnFunctionName(Index function_index,
                         std::string_view function_name) override;
   Result OnLocalName(Index function_index,
                      Index local_index,
                      std::string_view local_name) override;
   Result OnNameEntry(NameSectionSubsection type,
                      Index index,
                      std::string_view name) override;
 
   Result OnDylinkInfo(uint32_t mem_size,
                       uint32_t mem_align_log2,
                       uint32_t table_size,
                       uint32_t table_align_log2) override;
   Result OnDylinkNeededCount(Index count) override;
   Result OnDylinkNeeded(std::string_view so_name) override;
   Result OnDylinkImportCount(Index count) override;
   Result OnDylinkExportCount(Index count) override;
   Result OnDylinkImport(std::string_view module,
                         std::string_view name,
                         uint32_t flags) override;
   Result OnDylinkExport(std::string_view name, uint32_t flags) override;
 
   Result OnRelocCount(Index count, Index section_index) override;
   Result OnReloc(RelocType type,
                  Offset offset,
                  Index index,
                  uint32_t addend) override;
 
   Result OnFeature(uint8_t prefix, std::string_view name) override;
 
   Result OnSymbolCount(Index count) override;
   Result OnDataSymbol(Index index,
                       uint32_t flags,
                       std::string_view name,
                       Index segment,
                       uint32_t offset,
                       uint32_t size) override;
   Result OnFunctionSymbol(Index index,
                           uint32_t flags,
                           std::string_view name,
                           Index func_index) override;
   Result OnGlobalSymbol(Index index,
                         uint32_t flags,
                         std::string_view name,
                         Index global_index) override;
   Result OnSectionSymbol(Index index,
                          uint32_t flags,
                          Index section_index) override;
   Result OnTagSymbol(Index index,
                      uint32_t flags,
                      std::string_view name,
                      Index tag_index) override;
   Result OnTableSymbol(Index index,
                        uint32_t flags,
                        std::string_view name,
                        Index table_index) override;
   Result OnSegmentInfoCount(Index count) override;
   Result OnSegmentInfo(Index index,
                        std::string_view name,
                        Address alignment_log2,
                        uint32_t flags) override;
   Result OnInitFunctionCount(Index count) override;
   Result OnInitFunction(uint32_t priority, Index symbol_index) override;
   Result OnComdatCount(Index count) override;
   Result OnComdatBegin(std::string_view name,
                        uint32_t flags,
                        Index count) override;
   Result OnComdatEntry(ComdatType kind, Index index) override;
 
   Result OnTagCount(Index count) override;
   Result OnTagType(Index index, Index sig_index) override;
 
   Result OnOpcode(Opcode Opcode) override;
   Result OnI32ConstExpr(uint32_t value) override;
   Result OnI64ConstExpr(uint64_t value) override;
   Result OnF32ConstExpr(uint32_t value) override;
   Result OnF64ConstExpr(uint64_t value) override;
+  Result OnRefFuncExpr(Index func_index) override;
+  Result OnRefNullExpr(Type type) override;
   Result OnGlobalGetExpr(Index global_index) override;
   Result OnCodeMetadataCount(Index function_index, Index count) override;
   Result OnCodeMetadata(Offset code_offset,
                         const void* data,
                         Address size) override;
 
  private:
   Result EndInitExpr();
   bool ShouldPrintDetails();
   void PrintDetails(const char* fmt, ...);
   Result PrintSymbolFlags(uint32_t flags);
   Result PrintSegmentFlags(uint32_t flags);
-  void PrintInitExpr(const InitExpr& expr, bool as_unsigned = false);
+  void PrintInitExpr(const InitExpr& expr,
+                     bool as_unsigned = false,
+                     bool with_prefix = true);
   Result OnCount(Index count);
 
   std::unique_ptr<FileStream> out_stream_;
   Index elem_index_ = 0;
   Index table_index_ = 0;
   Index next_data_reloc_ = 0;
   bool reading_elem_init_expr_ = false;
   bool reading_data_init_expr_ = false;
   bool reading_global_init_expr_ = false;
-  InitExpr current_init_expr_;
+  bool reading_elem_expr_ = false;
+  InitExpr current_init_expr_{};
   uint8_t data_flags_ = 0;
   uint8_t elem_flags_ = 0;
   Index data_mem_index_ = 0;
   uint64_t data_offset_ = 0;
   uint64_t elem_offset_ = 0;
 
   bool ReadingInitExpr() {
     return reading_elem_init_expr_ || reading_data_init_expr_ ||
-           reading_global_init_expr_;
+           reading_global_init_expr_ || reading_elem_expr_;
   }
 };
 
@@ -1644,27 +1659,6 @@ Result BinaryReaderObjdump::OnExport(Index index,
   return Result::Ok;
 }
 
-Result BinaryReaderObjdump::OnElemSegmentElemExpr_RefNull(Index segment_index,
-                                                          Type type) {
-  PrintDetails("  - elem[%" PRIu64 "] = ref.null %s\n",
-               elem_offset_ + elem_index_, type.GetName().c_str());
-  elem_index_++;
-  return Result::Ok;
-}
-
-Result BinaryReaderObjdump::OnElemSegmentElemExpr_RefFunc(Index segment_index,
-                                                          Index func_index) {
-  PrintDetails("  - elem[%" PRIu64 "] = func[%" PRIindex "]",
-               elem_offset_ + elem_index_, func_index);
-  auto name = GetFunctionName(func_index);
-  if (!name.empty()) {
-    PrintDetails(" <" PRIstringview ">", WABT_PRINTF_STRING_VIEW_ARG(name));
-  }
-  PrintDetails("\n");
-  elem_index_++;
-  return Result::Ok;
-}
-
 Result BinaryReaderObjdump::OnElemSegmentCount(Index count) {
   return OnCount(count);
 }
@@ -1711,112 +1705,122 @@ Result BinaryReaderObjdump::BeginGlobal(Index index, Type type, bool mutable_) {
 }
 
 void BinaryReaderObjdump::PrintInitExpr(const InitExpr& expr,
-                                        bool as_unsigned) {
-  assert(expr.insts.size() > 0);
+                                        bool as_unsigned,
+                                        bool with_prefix) {
+  if (with_prefix) {
+    PrintDetails(" - init ");
+  }
+
+  if (expr.insts.empty()) {
+    PrintDetails("<EMPTY>\n");
+    return;
+  }
 
   // We have two different way to print init expressions.  One for
   // extended expressions involving more than one instruction, and
   // a short form for the more traditional single instruction form.
   if (expr.insts.size() > 1) {
-    PrintDetails(" - init (");
+    PrintDetails("(");
     bool first = true;
     for (auto& inst : expr.insts) {
       if (!first) {
         PrintDetails(", ");
       }
       first = false;
       PrintDetails("%s", inst.opcode.GetName());
       switch (inst.opcode) {
         case Opcode::I32Const:
           PrintDetails(" %d", inst.imm.i32);
           break;
         case Opcode::I64Const:
           PrintDetails(" %" PRId64, inst.imm.i64);
           break;
         case Opcode::F32Const: {
           char buffer[WABT_MAX_FLOAT_HEX];
           WriteFloatHex(buffer, sizeof(buffer), inst.imm.f32);
           PrintDetails(" %s\n", buffer);
           break;
         }
         case Opcode::F64Const: {
           char buffer[WABT_MAX_DOUBLE_HEX];
           WriteDoubleHex(buffer, sizeof(buffer), inst.imm.f64);
           PrintDetails(" %s\n", buffer);
           break;
         }
         case Opcode::GlobalGet: {
           PrintDetails(" %" PRIindex, inst.imm.index);
           std::string_view name = GetGlobalName(inst.imm.index);
           if (!name.empty()) {
             PrintDetails(" <" PRIstringview ">",
                          WABT_PRINTF_STRING_VIEW_ARG(name));
           }
           break;
         }
         default:
           break;
       }
     }
     PrintDetails(")\n");
     return;
   }
 
   switch (expr.type) {
     case InitExprType::I32:
       if (as_unsigned) {
-        PrintDetails(" - init i32=%u\n", expr.insts[0].imm.i32);
+        PrintDetails("i32=%u\n", expr.insts[0].imm.i32);
       } else {
-        PrintDetails(" - init i32=%d\n", expr.insts[0].imm.i32);
+        PrintDetails("i32=%d\n", expr.insts[0].imm.i32);
       }
       break;
     case InitExprType::I64:
       if (as_unsigned) {
-        PrintDetails(" - init i64=%" PRIu64 "\n", expr.insts[0].imm.i64);
+        PrintDetails("i64=%" PRIu64 "\n", expr.insts[0].imm.i64);
       } else {
-        PrintDetails(" - init i64=%" PRId64 "\n", expr.insts[0].imm.i64);
+        PrintDetails("i64=%" PRId64 "\n", expr.insts[0].imm.i64);
       }
       break;
     case InitExprType::F64: {
       char buffer[WABT_MAX_DOUBLE_HEX];
       WriteDoubleHex(buffer, sizeof(buffer), expr.insts[0].imm.f64);
-      PrintDetails(" - init f64=%s\n", buffer);
+      PrintDetails("f64=%s\n", buffer);
       break;
     }
     case InitExprType::F32: {
       char buffer[WABT_MAX_FLOAT_HEX];
       WriteFloatHex(buffer, sizeof(buffer), expr.insts[0].imm.f32);
-      PrintDetails(" - init f32=%s\n", buffer);
+      PrintDetails("f32=%s\n", buffer);
       break;
     }
     case InitExprType::V128: {
       PrintDetails(
-          " - init v128=0x%08x 0x%08x 0x%08x 0x%08x \n",
+          "v128=0x%08x 0x%08x 0x%08x 0x%08x \n",
           expr.insts[0].imm.v128_v.u32(0), expr.insts[0].imm.v128_v.u32(1),
           expr.insts[0].imm.v128_v.u32(2), expr.insts[0].imm.v128_v.u32(3));
       break;
     }
     case InitExprType::Global: {
-      PrintDetails(" - init global=%" PRIindex, expr.insts[0].imm.index);
+      PrintDetails("global=%" PRIindex, expr.insts[0].imm.index);
       std::string_view name = GetGlobalName(expr.insts[0].imm.index);
       if (!name.empty()) {
         PrintDetails(" <" PRIstringview ">", WABT_PRINTF_STRING_VIEW_ARG(name));
       }
       PrintDetails("\n");
       break;
     }
     case InitExprType::FuncRef: {
-      PrintDetails(" - init ref.func:%" PRIindex, expr.insts[0].imm.index);
+      PrintDetails("ref.func:%" PRIindex, expr.insts[0].imm.index);
       std::string_view name = GetFunctionName(expr.insts[0].imm.index);
       if (!name.empty()) {
         PrintDetails(" <" PRIstringview ">", WABT_PRINTF_STRING_VIEW_ARG(name));
       }
       PrintDetails("\n");
       break;
     }
     case InitExprType::NullRef:
-      PrintDetails(" - init null\n");
+      PrintDetails("ref.null %s\n", expr.insts[0].imm.type.GetName().c_str());
       break;
+    case InitExprType::Invalid:
+      PrintDetails("<INVALID>\n");
       break;
   }
 }
@@ -1839,15 +1843,20 @@ static void InitExprToConstOffset(const InitExpr& expr, uint64_t* out_offset) {
 Result BinaryReaderObjdump::EndInitExpr() {
   if (reading_data_init_expr_) {
     reading_data_init_expr_ = false;
     InitExprToConstOffset(current_init_expr_, &data_offset_);
   } else if (reading_elem_init_expr_) {
     reading_elem_init_expr_ = false;
     InitExprToConstOffset(current_init_expr_, &elem_offset_);
   } else if (reading_global_init_expr_) {
     reading_global_init_expr_ = false;
     PrintInitExpr(current_init_expr_);
+  } else if (reading_elem_expr_) {
+    reading_elem_expr_ = false;
+    PrintDetails("  - elem[%" PRIu64 "] = ", elem_offset_ + elem_index_);
+    PrintInitExpr(current_init_expr_, /*as_unsigned=*/false,
+                  /*with_prefix=*/false);
   } else {
     WABT_UNREACHABLE;
   }
   return Result::Ok;
 }
@@ -1884,6 +1893,22 @@ Result BinaryReaderObjdump::OnF64ConstExpr(uint64_t value) {
   return Result::Ok;
 }
 
+Result BinaryReaderObjdump::OnRefFuncExpr(Index func_index) {
+  if (ReadingInitExpr()) {
+    current_init_expr_.type = InitExprType::FuncRef;
+    current_init_expr_.insts.back().imm.index = func_index;
+  }
+  return Result::Ok;
+}
+
+Result BinaryReaderObjdump::OnRefNullExpr(Type type) {
+  if (ReadingInitExpr()) {
+    current_init_expr_.type = InitExprType::NullRef;
+    current_init_expr_.insts.back().imm.type = type;
+  }
+  return Result::Ok;
+}
+
 Result BinaryReaderObjdump::OnOpcode(Opcode opcode) {
   BinaryReaderObjdumpBase::OnOpcode(opcode);
   if (ReadingInitExpr() && opcode != Opcode::End) {
diff --git a/src/binary-reader.cc b/src/binary-reader.cc
index 01e1c2cd..1bdab2dd 100644
--- a/src/binary-reader.cc
+++ b/src/binary-reader.cc
@@ -2670,73 +2670,62 @@ Result BinaryReader::ReadStartSection(Offset section_size) {
 Result BinaryReader::ReadElemSection(Offset section_size) {
   CALLBACK(BeginElemSection, section_size);
   Index num_elem_segments;
   CHECK_RESULT(ReadCount(&num_elem_segments, "elem segment count"));
   CALLBACK(OnElemSegmentCount, num_elem_segments);
   for (Index i = 0; i < num_elem_segments; ++i) {
     uint32_t flags;
     CHECK_RESULT(ReadU32Leb128(&flags, "elem segment flags"));
     ERROR_IF(flags > SegFlagMax, "invalid elem segment flags: %#x", flags);
     Index table_index(0);
     if ((flags & (SegPassive | SegExplicitIndex)) == SegExplicitIndex) {
       CHECK_RESULT(ReadIndex(&table_index, "elem segment table index"));
     }
     Type elem_type = Type::FuncRef;
 
     CALLBACK(BeginElemSegment, i, table_index, flags);
 
     if (!(flags & SegPassive)) {
       CALLBACK(BeginElemSegmentInitExpr, i);
       CHECK_RESULT(ReadInitExpr(i));
       CALLBACK(EndElemSegmentInitExpr, i);
     }
 
     // For backwards compat we support not declaring the element kind.
     if (flags & (SegPassive | SegExplicitIndex)) {
       if (flags & SegUseElemExprs) {
         CHECK_RESULT(ReadRefType(&elem_type, "table elem type"));
       } else {
         ExternalKind kind;
         CHECK_RESULT(ReadExternalKind(&kind, "export kind"));
         ERROR_UNLESS(kind == ExternalKind::Func,
                      "segment elem type must be func (%s)",
                      elem_type.GetName().c_str());
         elem_type = Type::FuncRef;
       }
     }
 
     CALLBACK(OnElemSegmentElemType, i, elem_type);
 
     Index num_elem_exprs;
     CHECK_RESULT(ReadCount(&num_elem_exprs, "elem count"));
 
     CALLBACK(OnElemSegmentElemExprCount, i, num_elem_exprs);
     for (Index j = 0; j < num_elem_exprs; ++j) {
+      CALLBACK(BeginElemExpr, i, j);
       if (flags & SegUseElemExprs) {
-        Opcode opcode;
-        CHECK_RESULT(ReadOpcode(&opcode, "elem expr opcode"));
-        if (opcode == Opcode::RefNull) {
-          Type type;
-          CHECK_RESULT(ReadRefType(&type, "elem expr ref.null type"));
-          CALLBACK(OnElemSegmentElemExpr_RefNull, i, type);
-        } else if (opcode == Opcode::RefFunc) {
-          Index func_index;
-          CHECK_RESULT(ReadIndex(&func_index, "elem expr func index"));
-          CALLBACK(OnElemSegmentElemExpr_RefFunc, i, func_index);
-        } else {
-          PrintError(
-              "expected ref.null or ref.func in passive element segment");
-        }
-        CHECK_RESULT(ReadOpcode(&opcode, "opcode"));
-        ERROR_UNLESS(opcode == Opcode::End,
-                     "expected END opcode after element expression");
+        CHECK_RESULT(ReadInitExpr(j));
       } else {
         Index func_index;
         CHECK_RESULT(ReadIndex(&func_index, "elem expr func index"));
-        CALLBACK(OnElemSegmentElemExpr_RefFunc, i, func_index);
+        CALLBACK(OnOpcode, Opcode::RefFunc);
+        CALLBACK(OnRefFuncExpr, func_index);
+        CALLBACK(OnOpcodeUint32, func_index);
+        CALLBACK0(OnEndExpr);
       }
+      CALLBACK(EndElemExpr, i, j);
     }
     CALLBACK(EndElemSegment, i);
   }
   CALLBACK0(EndElemSection);
   return Result::Ok;
 }
diff --git a/src/c-writer.cc b/src/c-writer.cc
index 7076fdb5..770fbfe0 100644
--- a/src/c-writer.cc
+++ b/src/c-writer.cc
@@ -2105,92 +2105,101 @@ void CWriter::WriteElemInitializerDecls() {
 void CWriter::WriteElemInitializers() {
   if (module_->tables.empty()) {
     return;
   }
 
   for (const ElemSegment* elem_segment : module_->elem_segments) {
     if (elem_segment->elem_exprs.empty()) {
       continue;
     }
 
     if (elem_segment->elem_type == Type::ExternRef) {
       // no need to store externref elem initializers because only
       // ref.null is possible
       continue;
     }
 
     Write(Newline(), InternalSymbolScope(),
           "const wasm_elem_segment_expr_t elem_segment_exprs_",
           GlobalName(ModuleFieldType::ElemSegment, elem_segment->name),
           "[] = ", OpenBrace());
 
     for (const ExprList& elem_expr : elem_segment->elem_exprs) {
       assert(elem_expr.size() == 1);
       const Expr& expr = elem_expr.front();
       switch (expr.type()) {
         case ExprType::RefFunc: {
           const Func* func = module_->GetFunc(cast<RefFuncExpr>(&expr)->var);
           const FuncType* func_type = module_->GetFuncType(func->decl.type_var);
-          Write("{", FuncTypeExpr(func_type), ", (wasm_rt_function_ptr_t)",
+          Write("{RefFunc, ", FuncTypeExpr(func_type),
+                ", (wasm_rt_function_ptr_t)",
                 ExternalRef(ModuleFieldType::Func, func->name), ", ");
           if (IsImport(func->name)) {
             Write("offsetof(", ModuleInstanceTypeName(), ", ",
                   GlobalName(ModuleFieldType::Import,
                              import_module_sym_map_[func->name]),
                   ")");
           } else {
             Write("0");
           }
           Write("},", Newline());
         } break;
         case ExprType::RefNull:
-          Write("{NULL, NULL, 0},", Newline());
+          Write("{RefNull, NULL, NULL, 0},", Newline());
           break;
+        case ExprType::GlobalGet: {
+          const Global* global =
+              module_->GetGlobal(cast<GlobalGetExpr>(&expr)->var);
+          assert(IsImport(global->name));
+          Write("{GlobalGet, NULL, NULL, offsetof(", ModuleInstanceTypeName(),
+                ", ", GlobalName(ModuleFieldType::Global, global->name), ")},",
+                Newline());
+        } break;
         default:
           WABT_UNREACHABLE;
       }
     }
     Write(CloseBrace(), ";", Newline());
   }
 
   Write(Newline(), "static void init_tables(", ModuleInstanceTypeName(),
         "* instance) ", OpenBrace());
 
   if (module_->tables.size() > module_->num_table_imports) {
     Index table_idx = module_->num_table_imports;
     for (Index i = table_idx; i < module_->tables.size(); i++) {
       const Table* table = module_->tables[i];
       uint32_t max =
           table->elem_limits.has_max ? table->elem_limits.max : UINT32_MAX;
       Write("wasm_rt_allocate_", GetReferenceTypeName(table->elem_type),
             "_table(", ExternalInstancePtr(ModuleFieldType::Table, table->name),
             ", ", table->elem_limits.initial, ", ", max, ");", Newline());
     }
   }
 
   for (const ElemSegment* elem_segment : module_->elem_segments) {
     if (elem_segment->kind != SegmentKind::Active) {
       continue;
     }
 
     const Table* table = module_->GetTable(elem_segment->table_var);
 
     WriteElemTableInit(true, elem_segment, table);
   }
 
   Write(CloseBrace(), Newline());
 
   if (!module_->elem_segments.empty()) {
     Write(Newline(), "static void init_elem_instances(",
           ModuleInstanceTypeName(), " *instance) ", OpenBrace());
 
     for (const ElemSegment* elem_segment : module_->elem_segments) {
       if (is_droppable(elem_segment)) {
         Write("instance->elem_segment_dropped_",
               GlobalName(ModuleFieldType::ElemSegment, elem_segment->name),
               " = false;", Newline());
       }
     }
 
     Write(CloseBrace(), Newline());
   }
 }
diff --git a/src/interp/binary-reader-interp.cc b/src/interp/binary-reader-interp.cc
index d8426d30..600bf516 100644
--- a/src/interp/binary-reader-interp.cc
+++ b/src/interp/binary-reader-interp.cc
@@ -74,272 +74,271 @@ struct FixupMap {
 class BinaryReaderInterp : public BinaryReaderNop {
  public:
   BinaryReaderInterp(ModuleDesc* module,
                      std::string_view filename,
                      Errors* errors,
                      const Features& features);
 
   // Implement BinaryReader.
   bool OnError(const Error&) override;
 
   Result EndModule() override;
 
   Result OnTypeCount(Index count) override;
   Result OnFuncType(Index index,
                     Index param_count,
                     Type* param_types,
                     Index result_count,
                     Type* result_types) override;
 
   Result OnImportFunc(Index import_index,
                       std::string_view module_name,
                       std::string_view field_name,
                       Index func_index,
                       Index sig_index) override;
   Result OnImportTable(Index import_index,
                        std::string_view module_name,
                        std::string_view field_name,
                        Index table_index,
                        Type elem_type,
                        const Limits* elem_limits) override;
   Result OnImportMemory(Index import_index,
                         std::string_view module_name,
                         std::string_view field_name,
                         Index memory_index,
                         const Limits* page_limits) override;
   Result OnImportGlobal(Index import_index,
                         std::string_view module_name,
                         std::string_view field_name,
                         Index global_index,
                         Type type,
                         bool mutable_) override;
   Result OnImportTag(Index import_index,
                      std::string_view module_name,
                      std::string_view field_name,
                      Index tag_index,
                      Index sig_index) override;
 
   Result OnFunctionCount(Index count) override;
   Result OnFunction(Index index, Index sig_index) override;
 
   Result OnTableCount(Index count) override;
   Result OnTable(Index index,
                  Type elem_type,
                  const Limits* elem_limits) override;
 
   Result OnMemoryCount(Index count) override;
   Result OnMemory(Index index, const Limits* limits) override;
 
   Result OnGlobalCount(Index count) override;
   Result BeginGlobal(Index index, Type type, bool mutable_) override;
   Result BeginGlobalInitExpr(Index index) override;
   Result EndGlobalInitExpr(Index index) override;
 
   Result OnTagCount(Index count) override;
   Result OnTagType(Index index, Index sig_index) override;
 
   Result OnExport(Index index,
                   ExternalKind kind,
                   Index item_index,
                   std::string_view name) override;
 
   Result OnStartFunction(Index func_index) override;
 
   Result BeginFunctionBody(Index index, Offset size) override;
   Result OnLocalDeclCount(Index count) override;
   Result OnLocalDecl(Index decl_index, Index count, Type type) override;
 
   Result OnOpcode(Opcode Opcode) override;
   Result OnAtomicLoadExpr(Opcode opcode,
                           Index memidx,
                           Address alignment_log2,
                           Address offset) override;
   Result OnAtomicStoreExpr(Opcode opcode,
                            Index memidx,
                            Address alignment_log2,
                            Address offset) override;
   Result OnAtomicRmwExpr(Opcode opcode,
                          Index memidx,
                          Address alignment_log2,
                          Address offset) override;
   Result OnAtomicRmwCmpxchgExpr(Opcode opcode,
                                 Index memidx,
                                 Address alignment_log2,
                                 Address offset) override;
   Result OnAtomicWaitExpr(Opcode opcode,
                           Index memidx,
                           Address alignment_log2,
                           Address offset) override;
   Result OnAtomicFenceExpr(uint32_t consistency_model) override;
   Result OnAtomicNotifyExpr(Opcode opcode,
                             Index memidx,
                             Address alignment_log2,
                             Address offset) override;
   Result OnBinaryExpr(Opcode opcode) override;
   Result OnBlockExpr(Type sig_type) override;
   Result OnBrExpr(Index depth) override;
   Result OnBrIfExpr(Index depth) override;
   Result OnBrTableExpr(Index num_targets,
                        Index* target_depths,
                        Index default_target_depth) override;
   Result OnCallExpr(Index func_index) override;
   Result OnCallIndirectExpr(Index sig_index, Index table_index) override;
   Result OnCatchExpr(Index tag_index) override;
   Result OnCatchAllExpr() override;
   Result OnDelegateExpr(Index depth) override;
   Result OnReturnCallExpr(Index func_index) override;
   Result OnReturnCallIndirectExpr(Index sig_index, Index table_index) override;
   Result OnCompareExpr(Opcode opcode) override;
   Result OnConvertExpr(Opcode opcode) override;
   Result OnDropExpr() override;
   Result OnElseExpr() override;
   Result OnEndExpr() override;
   Result OnF32ConstExpr(uint32_t value_bits) override;
   Result OnF64ConstExpr(uint64_t value_bits) override;
   Result OnV128ConstExpr(v128 value_bits) override;
   Result OnGlobalGetExpr(Index global_index) override;
   Result OnGlobalSetExpr(Index global_index) override;
   Result OnI32ConstExpr(uint32_t value) override;
   Result OnI64ConstExpr(uint64_t value) override;
   Result OnIfExpr(Type sig_type) override;
   Result OnLoadExpr(Opcode opcode,
                     Index memidx,
                     Address alignment_log2,
                     Address offset) override;
   Result OnLocalGetExpr(Index local_index) override;
   Result OnLocalSetExpr(Index local_index) override;
   Result OnLocalTeeExpr(Index local_index) override;
   Result OnLoopExpr(Type sig_type) override;
   Result OnMemoryCopyExpr(Index srcmemidx, Index destmemidx) override;
   Result OnDataDropExpr(Index segment_index) override;
   Result OnMemoryGrowExpr(Index memidx) override;
   Result OnMemoryFillExpr(Index memidx) override;
   Result OnMemoryInitExpr(Index segment_index, Index memidx) override;
   Result OnMemorySizeExpr(Index memidx) override;
   Result OnRefFuncExpr(Index func_index) override;
   Result OnRefNullExpr(Type type) override;
   Result OnRefIsNullExpr() override;
   Result OnNopExpr() override;
   Result OnRethrowExpr(Index depth) override;
   Result OnReturnExpr() override;
   Result OnSelectExpr(Index result_count, Type* result_types) override;
   Result OnStoreExpr(Opcode opcode,
                      Index memidx,
                      Address alignment_log2,
                      Address offset) override;
   Result OnUnaryExpr(Opcode opcode) override;
   Result OnTableCopyExpr(Index dst_index, Index src_index) override;
   Result OnTableGetExpr(Index table_index) override;
   Result OnTableSetExpr(Index table_index) override;
   Result OnTableGrowExpr(Index table_index) override;
   Result OnTableSizeExpr(Index table_index) override;
   Result OnTableFillExpr(Index table_index) override;
   Result OnElemDropExpr(Index segment_index) override;
   Result OnTableInitExpr(Index segment_index, Index table_index) override;
   Result OnTernaryExpr(Opcode opcode) override;
   Result OnThrowExpr(Index tag_index) override;
   Result OnTryExpr(Type sig_type) override;
   Result OnUnreachableExpr() override;
   Result EndFunctionBody(Index index) override;
   Result OnSimdLaneOpExpr(Opcode opcode, uint64_t value) override;
   Result OnSimdLoadLaneExpr(Opcode opcode,
                             Index memidx,
                             Address alignment_log2,
                             Address offset,
                             uint64_t value) override;
   Result OnSimdStoreLaneExpr(Opcode opcode,
                              Index memidx,
                              Address alignment_log2,
                              Address offset,
                              uint64_t value) override;
   Result OnSimdShuffleOpExpr(Opcode opcode, v128 value) override;
   Result OnLoadSplatExpr(Opcode opcode,
                          Index memidx,
                          Address alignment_log2,
                          Address offset) override;
   Result OnLoadZeroExpr(Opcode opcode,
                         Index memidx,
                         Address alignment_log2,
                         Address offset) override;
 
   Result OnElemSegmentCount(Index count) override;
   Result BeginElemSegment(Index index,
                           Index table_index,
                           uint8_t flags) override;
   Result BeginElemSegmentInitExpr(Index index) override;
   Result EndElemSegmentInitExpr(Index index) override;
   Result OnElemSegmentElemType(Index index, Type elem_type) override;
   Result OnElemSegmentElemExprCount(Index index, Index count) override;
-  Result OnElemSegmentElemExpr_RefNull(Index segment_index, Type type) override;
-  Result OnElemSegmentElemExpr_RefFunc(Index segment_index,
-                                       Index func_index) override;
+  Result BeginElemExpr(Index elem_index, Index expr_index) override;
+  Result EndElemExpr(Index elem_index, Index expr_index) override;
 
   Result OnDataCount(Index count) override;
   Result BeginDataSegmentInitExpr(Index index) override;
   Result EndDataSegmentInitExpr(Index index) override;
   Result BeginDataSegment(Index index,
                           Index memory_index,
                           uint8_t flags) override;
   Result OnDataSegmentData(Index index,
                            const void* data,
                            Address size) override;
 
  private:
   Location GetLocation() const;
   Label* GetLabel(Index depth);
   Label* GetNearestTryLabel(Index depth);
   Label* TopLabel();
   void PushLabel(LabelKind label = LabelKind::Block,
                  Istream::Offset offset = Istream::kInvalidOffset,
                  Istream::Offset fixup_offset = Istream::kInvalidOffset,
                  u32 handler_desc_index = kInvalidIndex);
   void PopLabel();
 
   void PrintError(const char* format, ...);
 
   Result GetDropCount(Index keep_count,
                       size_t type_stack_limit,
                       Index* out_drop_count);
   Result GetBrDropKeepCount(Index depth,
                             Index* out_drop_count,
                             Index* out_keep_count);
   Result GetReturnDropKeepCount(Index* out_drop_count, Index* out_keep_count);
   Result GetReturnCallDropKeepCount(const FuncType&,
                                     Index keep_extra,
                                     Index* out_drop_count,
                                     Index* out_keep_count);
   Result BeginInitExpr(Type type, FuncDesc* init_func);
   Result EndInitExpr();
 
   void EmitBr(Index depth,
               Index drop_count,
               Index keep_count,
               Index catch_drop_count);
   void FixupTopLabel();
   u32 GetFuncOffset(Index func_index);
 
   Index TranslateLocalIndex(Index local_index);
 
   Index num_func_imports() const;
 
   Errors* errors_ = nullptr;
   ModuleDesc& module_;
   Istream& istream_;
 
   SharedValidator validator_;
 
   FuncDesc* func_;
   std::vector<Label> label_stack_;
   FixupMap depth_fixups_;
   FixupMap func_fixups_;
 
   u32 local_decl_count_;
   u32 local_count_;
 
   std::vector<FuncType> func_types_;      // Includes imported and defined.
   std::vector<TableType> table_types_;    // Includes imported and defined.
   std::vector<MemoryType> memory_types_;  // Includes imported and defined.
   std::vector<GlobalType> global_types_;  // Includes imported and defined.
   std::vector<TagType> tag_types_;        // Includes imported and defined.
 
   std::string_view filename_;
 };
@@ -739,21 +738,17 @@ Result BinaryReaderInterp::OnElemSegmentElemExprCount(Index index,
   return Result::Ok;
 }
 
-Result BinaryReaderInterp::OnElemSegmentElemExpr_RefNull(Index segment_index,
-                                                         Type type) {
-  CHECK_RESULT(validator_.OnElemSegmentElemExpr_RefNull(GetLocation(), type));
+Result BinaryReaderInterp::BeginElemExpr(Index elem_index, Index expr_index) {
+  assert(elem_index == module_.elems.size() - 1);
   ElemDesc& elem = module_.elems.back();
-  elem.elements.push_back(ElemExpr{ElemKind::RefNull, 0});
-  return Result::Ok;
+  elem.elements.push_back(
+      {FuncType{{}, {elem.type}}, {}, Istream::kInvalidOffset, {}});
+  assert(expr_index == elem.elements.size() - 1);
+  return BeginInitExpr(elem.type, &elem.elements.back());
 }
 
-Result BinaryReaderInterp::OnElemSegmentElemExpr_RefFunc(Index segment_index,
-                                                         Index func_index) {
-  CHECK_RESULT(validator_.OnElemSegmentElemExpr_RefFunc(
-      GetLocation(), Var(func_index, GetLocation())));
-  ElemDesc& elem = module_.elems.back();
-  elem.elements.push_back(ElemExpr{ElemKind::RefFunc, func_index});
-  return Result::Ok;
+Result BinaryReaderInterp::EndElemExpr(Index elem_index, Index expr_index) {
+  return EndInitExpr();
 }
 
 Result BinaryReaderInterp::OnDataCount(Index count) {
diff --git a/src/interp/interp.cc b/src/interp/interp.cc
index ff0883c1..ae1e7bb9 100644
--- a/src/interp/interp.cc
+++ b/src/interp/interp.cc
@@ -705,19 +705,19 @@ Result Tag::Match(Store& store,
 }
 
 //// ElemSegment ////
-ElemSegment::ElemSegment(const ElemDesc* desc, Instance::Ptr& inst)
+ElemSegment::ElemSegment(Store& store,
+                         const ElemDesc* desc,
+                         Instance::Ptr& inst)
     : desc_(desc) {
+  Trap::Ptr out_trap;
   elements_.reserve(desc->elements.size());
   for (auto&& elem_expr : desc->elements) {
-    switch (elem_expr.kind) {
-      case ElemKind::RefNull:
-        elements_.emplace_back(Ref::Null);
-        break;
-
-      case ElemKind::RefFunc:
-        elements_.emplace_back(inst->funcs_[elem_expr.index]);
-        break;
+    Value value;
+    Ref func_ref = DefinedFunc::New(store, inst.ref(), elem_expr).ref();
+    if (Failed(inst->CallInitFunc(store, func_ref, &value, &out_trap))) {
+      WABT_UNREACHABLE;  // valid const expression cannot trap
     }
+    elements_.push_back(value.Get<Ref>());
   }
 }
 
@@ -762,189 +762,189 @@ Instance::Instance(Store& store, Ref module) : Object(skind), module_(module) {
 // static
 Instance::Ptr Instance::Instantiate(Store& store,
                                     Ref module,
                                     const RefVec& imports,
                                     Trap::Ptr* out_trap) {
   Module::Ptr mod{store, module};
   Instance::Ptr inst = store.Alloc<Instance>(store, module);
 
   size_t import_desc_count = mod->desc().imports.size();
   if (imports.size() < import_desc_count) {
     *out_trap = Trap::New(store, "not enough imports!");
     return {};
   }
 
   // Imports.
   for (size_t i = 0; i < import_desc_count; ++i) {
     auto&& import_desc = mod->desc().imports[i];
     Ref extern_ref = imports[i];
     if (extern_ref == Ref::Null) {
       *out_trap = Trap::New(store, StringPrintf("invalid import \"%s.%s\"",
                                                 import_desc.type.module.c_str(),
                                                 import_desc.type.name.c_str()));
       return {};
     }
 
     Extern::Ptr extern_{store, extern_ref};
     if (Failed(extern_->Match(store, import_desc.type, out_trap))) {
       return {};
     }
 
     inst->imports_.push_back(extern_ref);
 
     switch (import_desc.type.type->kind) {
       case ExternKind::Func:   inst->funcs_.push_back(extern_ref); break;
       case ExternKind::Table:  inst->tables_.push_back(extern_ref); break;
       case ExternKind::Memory: inst->memories_.push_back(extern_ref); break;
       case ExternKind::Global: inst->globals_.push_back(extern_ref); break;
       case ExternKind::Tag:    inst->tags_.push_back(extern_ref); break;
     }
   }
 
   // Funcs.
   for (auto&& desc : mod->desc().funcs) {
     inst->funcs_.push_back(DefinedFunc::New(store, inst.ref(), desc).ref());
   }
 
   // Tables.
   for (auto&& desc : mod->desc().tables) {
     inst->tables_.push_back(Table::New(store, desc.type).ref());
   }
 
   // Memories.
   for (auto&& desc : mod->desc().memories) {
     inst->memories_.push_back(Memory::New(store, desc.type).ref());
   }
 
   // Globals.
   for (auto&& desc : mod->desc().globals) {
     Value value;
     Ref func_ref = DefinedFunc::New(store, inst.ref(), desc.init_func).ref();
     if (Failed(inst->CallInitFunc(store, func_ref, &value, out_trap))) {
       return {};
     }
     inst->globals_.push_back(Global::New(store, desc.type, value).ref());
   }
 
   // Tags.
   for (auto&& desc : mod->desc().tags) {
     inst->tags_.push_back(Tag::New(store, desc.type).ref());
   }
 
   // Exports.
   for (auto&& desc : mod->desc().exports) {
     Ref ref;
     switch (desc.type.type->kind) {
       case ExternKind::Func:   ref = inst->funcs_[desc.index]; break;
       case ExternKind::Table:  ref = inst->tables_[desc.index]; break;
       case ExternKind::Memory: ref = inst->memories_[desc.index]; break;
       case ExternKind::Global: ref = inst->globals_[desc.index]; break;
       case ExternKind::Tag:    ref = inst->tags_[desc.index]; break;
     }
     inst->exports_.push_back(ref);
   }
 
   // Elems.
   for (auto&& desc : mod->desc().elems) {
-    inst->elems_.emplace_back(&desc, inst);
+    inst->elems_.emplace_back(store, &desc, inst);
   }
 
   // Datas.
   for (auto&& desc : mod->desc().datas) {
     inst->datas_.emplace_back(&desc);
   }
 
   // Initialization.
   // The MVP requires that all segments are bounds-checked before being copied
   // into the table or memory. The bulk memory proposal changes this behavior;
   // instead, each segment is copied in order. If any segment fails, then no
   // further segments are copied. Any data that was written persists.
   enum Pass { Check, Init };
   int pass = store.features().bulk_memory_enabled() ? Init : Check;
   for (; pass <= Init; ++pass) {
     // Elems.
     for (auto&& segment : inst->elems_) {
       auto&& desc = segment.desc();
       if (desc.mode == SegmentMode::Active) {
         Result result;
         Table::Ptr table{store, inst->tables_[desc.table_index]};
         Value value;
         Ref func_ref =
             DefinedFunc::New(store, inst.ref(), desc.init_func).ref();
         if (Failed(inst->CallInitFunc(store, func_ref, &value, out_trap))) {
           return {};
         }
         u32 offset = value.Get<u32>();
         if (pass == Check) {
           result = table->IsValidRange(offset, segment.size()) ? Result::Ok
                                                                : Result::Error;
         } else {
           result = table->Init(store, offset, segment, 0, segment.size());
           if (Succeeded(result)) {
             segment.Drop();
           }
         }
 
         if (Failed(result)) {
           *out_trap = Trap::New(
               store, StringPrintf(
                          "out of bounds table access: elem segment is "
                          "out of bounds: [%u, %" PRIu64 ") >= max value %u",
                          offset, u64{offset} + segment.size(), table->size()));
           return {};
         }
       } else if (desc.mode == SegmentMode::Declared) {
         segment.Drop();
       }
     }
 
     // Data.
     for (auto&& segment : inst->datas_) {
       auto&& desc = segment.desc();
       if (desc.mode == SegmentMode::Active) {
         Result result;
         Memory::Ptr memory{store, inst->memories_[desc.memory_index]};
         Value offset_op;
         Ref func_ref =
             DefinedFunc::New(store, inst.ref(), desc.init_func).ref();
         if (Failed(inst->CallInitFunc(store, func_ref, &offset_op, out_trap))) {
           return {};
         }
         u64 offset = memory->type().limits.is_64 ? offset_op.Get<u64>()
                                                  : offset_op.Get<u32>();
         if (pass == Check) {
           result = memory->IsValidAccess(offset, 0, segment.size())
                        ? Result::Ok
                        : Result::Error;
         } else {
           result = memory->Init(offset, segment, 0, segment.size());
           if (Succeeded(result)) {
             segment.Drop();
           }
         }
 
         if (Failed(result)) {
           *out_trap = Trap::New(
               store, StringPrintf(
                          "out of bounds memory access: data segment is "
                          "out of bounds: [%" PRIu64 ", %" PRIu64
                          ") >= max value %" PRIu64,
                          offset, offset + segment.size(), memory->ByteSize()));
           return {};
         }
       } else if (desc.mode == SegmentMode::Declared) {
         segment.Drop();
       }
     }
   }
 
   // Start.
   for (auto&& start : mod->desc().starts) {
     Func::Ptr func{store, inst->funcs_[start.func_index]};
     Values results;
     if (Failed(func->Call(store, {}, results, out_trap))) {
       return {};
     }
   }
 
   return inst;
 }
diff --git a/src/prebuilt/wasm2c_source_declarations.cc b/src/prebuilt/wasm2c_source_declarations.cc
index 5970f9a3..23b24b4e 100644
--- a/src/prebuilt/wasm2c_source_declarations.cc
+++ b/src/prebuilt/wasm2c_source_declarations.cc
@@ -936,6 +936,8 @@ R"w2c_template(}
 R"w2c_template(
 typedef struct {
 )w2c_template"
+R"w2c_template(  enum { RefFunc, RefNull, GlobalGet } expr_type;
+)w2c_template"
 R"w2c_template(  wasm_rt_func_type_t type;
 )w2c_template"
 R"w2c_template(  wasm_rt_function_ptr_t func;
@@ -969,20 +971,44 @@ R"w2c_template(    TRAP(OOB);
 )w2c_template"
 R"w2c_template(  for (u32 i = 0; i < n; i++) {
 )w2c_template"
-R"w2c_template(    const wasm_elem_segment_expr_t* src_expr = &src[src_addr + i];
+R"w2c_template(    const wasm_elem_segment_expr_t* const src_expr = &src[src_addr + i];
+)w2c_template"
+R"w2c_template(    wasm_rt_funcref_t* const dest_val = &(dest->data[dest_addr + i]);
+)w2c_template"
+R"w2c_template(    switch (src_expr->expr_type) {
+)w2c_template"
+R"w2c_template(      case RefFunc:
+)w2c_template"
+R"w2c_template(        *dest_val = (wasm_rt_funcref_t){
+)w2c_template"
+R"w2c_template(            src_expr->type, src_expr->func,
+)w2c_template"
+R"w2c_template(            (char*)module_instance + src_expr->module_offset};
+)w2c_template"
+R"w2c_template(        break;
+)w2c_template"
+R"w2c_template(      case RefNull:
+)w2c_template"
+R"w2c_template(        *dest_val = wasm_rt_funcref_null_value;
+)w2c_template"
+R"w2c_template(        break;
+)w2c_template"
+R"w2c_template(      case GlobalGet:
+)w2c_template"
+R"w2c_template(        *dest_val = **(wasm_rt_funcref_t**)((char*)module_instance +
 )w2c_template"
-R"w2c_template(    dest->data[dest_addr + i] =
+R"w2c_template(                                            src_expr->module_offset);
 )w2c_template"
-R"w2c_template(        (wasm_rt_funcref_t){src_expr->type, src_expr->func,
+R"w2c_template(        break;
 )w2c_template"
-R"w2c_template(                            (char*)module_instance + src_expr->module_offset};
+R"w2c_template(    }
 )w2c_template"
 R"w2c_template(  }
 )w2c_template"
 R"w2c_template(}
 )w2c_template"
 R"w2c_template(
-// Currently Wasm only supports initializing externref tables with ref.null.
+// Currently wasm2c only supports initializing externref tables with ref.null.
 )w2c_template"
 R"w2c_template(static inline void externref_table_init(wasm_rt_externref_table_t* dest,
 )w2c_template"
diff --git a/src/shared-validator.cc b/src/shared-validator.cc
index a36af478..9ac82181 100644
--- a/src/shared-validator.cc
+++ b/src/shared-validator.cc
@@ -276,27 +276,6 @@ Result SharedValidator::OnElemSegmentElemType(const Location& loc,
   return result;
 }
 
-Result SharedValidator::OnElemSegmentElemExpr_RefNull(const Location& loc,
-                                                      Type type) {
-  return CheckType(loc, type, elems_.back().element, "elem expression");
-}
-
-Result SharedValidator::OnElemSegmentElemExpr_RefFunc(const Location& loc,
-                                                      Var func_var) {
-  Result result = Result::Ok;
-  result |=
-      CheckType(loc, Type::FuncRef, elems_.back().element, "elem expression");
-  result |= CheckFuncIndex(func_var);
-  declared_funcs_.insert(func_var.index());
-  return result;
-}
-
-Result SharedValidator::OnElemSegmentElemExpr_Other(const Location& loc) {
-  return PrintError(loc,
-                    "invalid elem expression expression; must be either "
-                    "ref.null or ref.func.");
-}
-
 void SharedValidator::OnDataCount(Index count) {
   data_segments_ = count;
 }
@@ -1003,16 +982,16 @@ Result SharedValidator::OnNop(const Location& loc) {
 Result SharedValidator::OnRefFunc(const Location& loc, Var func_var) {
   Result result = CheckInstr(Opcode::RefFunc, loc);
   result |= CheckFuncIndex(func_var);
   if (Succeeded(result)) {
     // References in initializer expressions are considered declarations, as
     // opposed to references in function bodies that are considered usages.
     if (in_init_expr_) {
       declared_funcs_.insert(func_var.index());
     } else {
       check_declared_funcs_.push_back(func_var);
     }
     Index func_type = GetFunctionTypeIndex(func_var.index());
-    result |= typechecker_.OnRefFuncExpr(func_type);
+    result |= typechecker_.OnRefFuncExpr(func_type, in_init_expr_);
   }
   return result;
 }
diff --git a/src/template/wasm2c.declarations.c b/src/template/wasm2c.declarations.c
index 8ea080ca..cc9b2445 100644
--- a/src/template/wasm2c.declarations.c
+++ b/src/template/wasm2c.declarations.c
@@ -500,7 +500,8 @@ static inline void memory_init(wasm_rt_memory_t* dest,
 }
 
 typedef struct {
+  enum { RefFunc, RefNull, GlobalGet } expr_type;
   wasm_rt_func_type_t type;
   wasm_rt_function_ptr_t func;
   size_t module_offset;
 } wasm_elem_segment_expr_t;
@@ -508,23 +509,35 @@ typedef struct {
 static inline void funcref_table_init(wasm_rt_funcref_table_t* dest,
                                       const wasm_elem_segment_expr_t* src,
                                       u32 src_size,
                                       u32 dest_addr,
                                       u32 src_addr,
                                       u32 n,
                                       void* module_instance) {
   if (UNLIKELY(src_addr + (uint64_t)n > src_size))
     TRAP(OOB);
   if (UNLIKELY(dest_addr + (uint64_t)n > dest->size))
     TRAP(OOB);
   for (u32 i = 0; i < n; i++) {
-    const wasm_elem_segment_expr_t* src_expr = &src[src_addr + i];
-    dest->data[dest_addr + i] =
-        (wasm_rt_funcref_t){src_expr->type, src_expr->func,
-                            (char*)module_instance + src_expr->module_offset};
+    const wasm_elem_segment_expr_t* const src_expr = &src[src_addr + i];
+    wasm_rt_funcref_t* const dest_val = &(dest->data[dest_addr + i]);
+    switch (src_expr->expr_type) {
+      case RefFunc:
+        *dest_val = (wasm_rt_funcref_t){
+            src_expr->type, src_expr->func,
+            (char*)module_instance + src_expr->module_offset};
+        break;
+      case RefNull:
+        *dest_val = wasm_rt_funcref_null_value;
+        break;
+      case GlobalGet:
+        *dest_val = **(wasm_rt_funcref_t**)((char*)module_instance +
+                                            src_expr->module_offset);
+        break;
+    }
   }
 }
 
-// Currently Wasm only supports initializing externref tables with ref.null.
+// Currently wasm2c only supports initializing externref tables with ref.null.
 static inline void externref_table_init(wasm_rt_externref_table_t* dest,
                                         u32 src_size,
                                         u32 dest_addr,
diff --git a/src/type-checker.cc b/src/type-checker.cc
index 79b4f604..ff58968c 100644
--- a/src/type-checker.cc
+++ b/src/type-checker.cc
@@ -777,11 +777,17 @@ Result TypeChecker::OnTableFill(Type elem_type) {
   return PopAndCheck3Types(Type::I32, elem_type, Type::I32, "table.fill");
 }
 
-Result TypeChecker::OnRefFuncExpr(Index func_type) {
-  if (features_.function_references_enabled()) {
+Result TypeChecker::OnRefFuncExpr(Index func_type, bool force_generic_funcref) {
+  /*
+   * In a const expression, treat ref.func as producing a generic funcref.
+   * This avoids having to implement funcref subtyping (for now) and matches
+   * the previous behavior where SharedValidator::OnElemSegmentElemExpr_RefFunc
+   * examined only the validity of the function index.
+   */
+  if (features_.function_references_enabled() && !force_generic_funcref) {
     PushType(Type(Type::Reference, func_type));
   } else {
     PushType(Type::FuncRef);
   }
   return Result::Ok;
 }
diff --git a/src/validator.cc b/src/validator.cc
index d52efb97..a759ad24 100644
--- a/src/validator.cc
+++ b/src/validator.cc
@@ -675,237 +675,224 @@ Validator::Validator(Errors* errors,
 Result Validator::CheckModule() {
   const Module* module = current_module_;
 
   // Type section.
   for (const ModuleField& field : module->fields) {
     if (auto* f = dyn_cast<TypeModuleField>(&field)) {
       switch (f->type->kind()) {
         case TypeEntryKind::Func: {
           FuncType* func_type = cast<FuncType>(f->type.get());
           result_ |= validator_.OnFuncType(
               field.loc, func_type->sig.param_types.size(),
               func_type->sig.param_types.data(),
               func_type->sig.result_types.size(),
               func_type->sig.result_types.data(),
               module->GetFuncTypeIndex(func_type->sig));
           break;
         }
 
         case TypeEntryKind::Struct: {
           StructType* struct_type = cast<StructType>(f->type.get());
           TypeMutVector type_muts;
           for (auto&& field : struct_type->fields) {
             type_muts.push_back(TypeMut{field.type, field.mutable_});
           }
           result_ |= validator_.OnStructType(field.loc, type_muts.size(),
                                              type_muts.data());
           break;
         }
 
         case TypeEntryKind::Array: {
           ArrayType* array_type = cast<ArrayType>(f->type.get());
           result_ |= validator_.OnArrayType(
               field.loc,
               TypeMut{array_type->field.type, array_type->field.mutable_});
           break;
         }
       }
     }
   }
 
   // Import section.
   for (const ModuleField& field : module->fields) {
     if (auto* f = dyn_cast<ImportModuleField>(&field)) {
       switch (f->import->kind()) {
         case ExternalKind::Func: {
           auto&& func = cast<FuncImport>(f->import.get())->func;
           result_ |= validator_.OnFunction(
               field.loc, GetFuncTypeIndex(field.loc, func.decl));
           break;
         }
 
         case ExternalKind::Table: {
           auto&& table = cast<TableImport>(f->import.get())->table;
           result_ |=
               validator_.OnTable(field.loc, table.elem_type, table.elem_limits);
           break;
         }
 
         case ExternalKind::Memory: {
           auto&& memory = cast<MemoryImport>(f->import.get())->memory;
           result_ |= validator_.OnMemory(field.loc, memory.page_limits);
           break;
         }
 
         case ExternalKind::Global: {
           auto&& global = cast<GlobalImport>(f->import.get())->global;
           result_ |= validator_.OnGlobalImport(field.loc, global.type,
                                                global.mutable_);
           break;
         }
 
         case ExternalKind::Tag: {
           auto&& tag = cast<TagImport>(f->import.get())->tag;
           result_ |= validator_.OnTag(field.loc,
                                       GetFuncTypeIndex(field.loc, tag.decl));
           break;
         }
       }
     }
   }
 
   // Func section.
   for (const ModuleField& field : module->fields) {
     if (auto* f = dyn_cast<FuncModuleField>(&field)) {
       result_ |= validator_.OnFunction(
           field.loc, GetFuncTypeIndex(field.loc, f->func.decl));
     }
   }
 
   // Table section.
   for (const ModuleField& field : module->fields) {
     if (auto* f = dyn_cast<TableModuleField>(&field)) {
       result_ |= validator_.OnTable(field.loc, f->table.elem_type,
                                     f->table.elem_limits);
     }
   }
 
   // Memory section.
   for (const ModuleField& field : module->fields) {
     if (auto* f = dyn_cast<MemoryModuleField>(&field)) {
       result_ |= validator_.OnMemory(field.loc, f->memory.page_limits);
     }
   }
 
   // Global section.
   for (const ModuleField& field : module->fields) {
     if (auto* f = dyn_cast<GlobalModuleField>(&field)) {
       result_ |=
           validator_.OnGlobal(field.loc, f->global.type, f->global.mutable_);
 
       // Init expr.
       result_ |= validator_.BeginInitExpr(field.loc, f->global.type);
       ExprVisitor visitor(this);
       result_ |=
           visitor.VisitExprList(const_cast<ExprList&>(f->global.init_expr));
       result_ |= validator_.EndInitExpr();
     }
   }
 
   // Tag section.
   for (const ModuleField& field : module->fields) {
     if (auto* f = dyn_cast<TagModuleField>(&field)) {
       result_ |=
           validator_.OnTag(field.loc, GetFuncTypeIndex(field.loc, f->tag.decl));
     }
   }
 
   // Export section.
   for (const ModuleField& field : module->fields) {
     if (auto* f = dyn_cast<ExportModuleField>(&field)) {
       result_ |= validator_.OnExport(field.loc, f->export_.kind, f->export_.var,
                                      f->export_.name);
     }
   }
 
   // Start section.
   for (const ModuleField& field : module->fields) {
     if (auto* f = dyn_cast<StartModuleField>(&field)) {
       result_ |= validator_.OnStart(field.loc, f->start);
     }
   }
 
   // Elem segment section.
   for (const ModuleField& field : module->fields) {
     if (auto* f = dyn_cast<ElemSegmentModuleField>(&field)) {
       result_ |= validator_.OnElemSegment(field.loc, f->elem_segment.table_var,
                                           f->elem_segment.kind);
 
       result_ |= validator_.OnElemSegmentElemType(field.loc,
                                                   f->elem_segment.elem_type);
 
       // Init expr.
       if (f->elem_segment.kind == SegmentKind::Active) {
         result_ |= validator_.BeginInitExpr(field.loc, Type::I32);
         ExprVisitor visitor(this);
         result_ |= visitor.VisitExprList(
             const_cast<ExprList&>(f->elem_segment.offset));
         result_ |= validator_.EndInitExpr();
       }
 
       // Element expr.
       for (auto&& elem_expr : f->elem_segment.elem_exprs) {
-        if (elem_expr.size() == 1) {
-          const Expr* expr = &elem_expr.front();
-          switch (expr->type()) {
-            case ExprType::RefNull:
-              result_ |= validator_.OnElemSegmentElemExpr_RefNull(
-                  expr->loc, cast<RefNullExpr>(expr)->type);
-              break;
-            case ExprType::RefFunc:
-              result_ |= validator_.OnElemSegmentElemExpr_RefFunc(
-                  expr->loc, cast<RefFuncExpr>(expr)->var);
-              break;
-            default:
-              result_ |= validator_.OnElemSegmentElemExpr_Other(expr->loc);
-              break;
-          }
-        } else if (elem_expr.size() > 1) {
-          result_ |= validator_.OnElemSegmentElemExpr_Other(field.loc);
-        }
+        result_ |= validator_.BeginInitExpr(elem_expr.front().loc,
+                                            f->elem_segment.elem_type);
+        ExprVisitor visitor(this);
+        result_ |= visitor.VisitExprList(const_cast<ExprList&>(elem_expr));
+        result_ |= validator_.EndInitExpr();
       }
     }
   }
 
   // DataCount section.
   validator_.OnDataCount(module->data_segments.size());
 
   // Code section.
   Index func_index = module->num_func_imports;
   for (const ModuleField& field : module->fields) {
     if (auto* f = dyn_cast<FuncModuleField>(&field)) {
       const Location& body_start = f->func.loc;
       const Location& body_end =
           f->func.exprs.empty() ? body_start : f->func.exprs.back().loc;
       result_ |= validator_.BeginFunctionBody(body_start, func_index++);
 
       for (auto&& decl : f->func.local_types.decls()) {
         result_ |= validator_.OnLocalDecl(body_start, decl.second, decl.first);
       }
 
       ExprVisitor visitor(this);
       result_ |= visitor.VisitExprList(const_cast<ExprList&>(f->func.exprs));
       result_ |= validator_.EndFunctionBody(body_end);
     }
   }
 
   // Data segment section.
   for (const ModuleField& field : module->fields) {
     if (auto* f = dyn_cast<DataSegmentModuleField>(&field)) {
       result_ |= validator_.OnDataSegment(field.loc, f->data_segment.memory_var,
                                           f->data_segment.kind);
 
       // Init expr.
       if (f->data_segment.kind == SegmentKind::Active) {
         Type offset_type = Type::I32;
         Index memory_index = module->GetMemoryIndex(f->data_segment.memory_var);
         if (memory_index < module->memories.size() &&
             module->memories[memory_index]->page_limits.is_64) {
           offset_type = Type::I64;
         }
         result_ |= validator_.BeginInitExpr(field.loc, offset_type);
         ExprVisitor visitor(this);
         result_ |= visitor.VisitExprList(
             const_cast<ExprList&>(f->data_segment.offset));
         result_ |= validator_.EndInitExpr();
       }
     }
   }
 
   result_ |= validator_.EndModule();
 
   return result_;
 }
 
 // Returns the result type of the invoked function, checked by the caller;
 // returning nullptr means that another error occured first, so the result type
 // should be ignored.
diff --git a/test/dump/extended-const.txt b/test/dump/extended-const.txt
index cafd2dd5..90fc4430 100644
--- a/test/dump/extended-const.txt
+++ b/test/dump/extended-const.txt
@@ -178,8 +178,8 @@ Global[2]:
  - global[1] i32 mutable=1 - init (i32.const 44, i32.const 3, i32.sub)
  - global[2] i32 mutable=0 - init i32=45
 Elem[1]:
  - segment[0] flags=0 table=0 count=1 - init (i32.const 4, global.get 0 <g_import>, i32.mul)
-  - elem[0] = func[0]
+  - elem[0] = ref.func:0
 Code[1]:
  - func[0] size=2
 Data[1]:
diff --git a/test/dump/extended-names.txt b/test/dump/extended-names.txt
index c3c78f62..b90a3308 100644
--- a/test/dump/extended-names.txt
+++ b/test/dump/extended-names.txt
@@ -378,8 +378,8 @@ Global[2]:
  - global[0] i32 mutable=1 <g1> - init i32=1
  - global[1] i32 mutable=0 <g2> - init i32=2
 Elem[1]:
  - segment[0] flags=1 table=0 count=1
-  - elem[0] = func[0]
+  - elem[0] = ref.func:0
 DataCount:
  - data count: 1
 Code[4]:
diff --git a/test/dump/invalid-init-exprs.txt b/test/dump/invalid-init-exprs.txt
new file mode 100644
index 00000000..7cc126d3
--- /dev/null
+++ b/test/dump/invalid-init-exprs.txt
@@ -0,0 +1,25 @@
+;;; TOOL: run-objdump-gen-wasm
+;;; ARGS1: -x
+;; TODO: wasm-objdump should handle the "<INVALID>" case more gracefully
+magic
+version
+section(ELEM) {
+  count[1]
+  flags[4]
+  offset[nop end]
+  elemcount[1]
+  end
+}
+(;; STDOUT ;;;
+
+invalid-init-exprs.wasm:	file format wasm 0x1
+
+Section Details:
+
+Elem[1]:
+ - segment[0] flags=4 table=0 count=1 - init <INVALID>
+  - elem[0] = <EMPTY>
+
+Code Disassembly:
+
+;;; STDOUT ;;)
diff --git a/test/dump/reference-types.txt b/test/dump/reference-types.txt
index 2fd082cc..9d29b10a 100644
--- a/test/dump/reference-types.txt
+++ b/test/dump/reference-types.txt
@@ -81,9 +81,9 @@ Table[3]:
  - table[0] type=externref initial=1
  - table[1] type=externref initial=1
  - table[2] type=funcref initial=1
 Elem[2]:
  - segment[0] flags=2 table=2 count=1 - init i32=0
-  - elem[0] = func[0]
+  - elem[0] = ref.func:0
  - segment[1] flags=5 table=0 count=1
   - elem[0] = ref.null funcref
 Code[10]:
diff --git a/test/dump/relocations-all-features.txt b/test/dump/relocations-all-features.txt
index d85c6215..0b22b641 100644
--- a/test/dump/relocations-all-features.txt
+++ b/test/dump/relocations-all-features.txt
@@ -51,7 +51,7 @@ Export[1]:
  - func[2] <f> -> "f"
 Elem[1]:
  - segment[0] flags=0 table=0 count=1 - init i32=0
-  - elem[0] = func[1] <__extern.bar>
+  - elem[0] = ref.func:1 <__extern.bar>
 Code[1]:
  - func[2] size=36 <f>
 Custom:
diff --git a/test/dump/relocations.txt b/test/dump/relocations.txt
index cb3570b6..9114e356 100644
--- a/test/dump/relocations.txt
+++ b/test/dump/relocations.txt
@@ -51,7 +51,7 @@ Export[1]:
  - func[2] <f> -> "f"
 Elem[1]:
  - segment[0] flags=0 table=0 count=1 - init i32=0
-  - elem[0] = func[1] <__extern.bar>
+  - elem[0] = ref.func:1 <__extern.bar>
 Code[1]:
  - func[2] size=36 <f>
 Custom:
diff --git a/test/dump/table-multi.txt b/test/dump/table-multi.txt
index fc4555e0..d5bfd3c8 100644
--- a/test/dump/table-multi.txt
+++ b/test/dump/table-multi.txt
@@ -85,10 +85,10 @@ Table[2]:
  - table[0] type=funcref initial=1 max=1
  - table[1] type=funcref initial=1 max=1
 Elem[2]:
  - segment[0] flags=0 table=0 count=1 - init i32=0
-  - elem[0] = func[0]
+  - elem[0] = ref.func:0
  - segment[1] flags=2 table=1 count=1 - init i32=0
-  - elem[0] = func[0]
+  - elem[0] = ref.func:0
 Code[1]:
  - func[0] size=2
 
diff --git a/test/dump/table.txt b/test/dump/table.txt
index 10aadb5e..b0184bfb 100644
--- a/test/dump/table.txt
+++ b/test/dump/table.txt
@@ -116,13 +116,13 @@ Table[1]:
  - table[0] type=funcref initial=6 max=6
 Elem[2]:
  - segment[0] flags=0 table=0 count=2 - init i32=0
-  - elem[0] = func[1]
-  - elem[1] = func[1]
+  - elem[0] = ref.func:1
+  - elem[1] = ref.func:1
  - segment[1] flags=0 table=0 count=4 - init i32=2
-  - elem[2] = func[0]
-  - elem[3] = func[0]
-  - elem[4] = func[1]
-  - elem[5] = func[2]
+  - elem[2] = ref.func:0
+  - elem[3] = ref.func:0
+  - elem[4] = ref.func:1
+  - elem[5] = ref.func:2
 Code[3]:
  - func[0] size=2
  - func[1] size=2
diff --git a/test/parse/module/bad-table-invalid-function.txt b/test/parse/module/bad-table-invalid-function.txt
index 07383518..d05f093e 100644
--- a/test/parse/module/bad-table-invalid-function.txt
+++ b/test/parse/module/bad-table-invalid-function.txt
@@ -1,11 +1,12 @@
 ;;; TOOL: wat2wasm
 ;;; ERROR: 1
 (module
   (table 1 funcref)
   (func $f)
   (elem (i32.const 0) $f 1))
 (;; STDERR ;;;
 out/test/parse/module/bad-table-invalid-function.txt:6:26: error: function variable out of range: 1 (max 1)
   (elem (i32.const 0) $f 1))
                          ^
+0:0: error: type mismatch in initializer expression, expected [funcref] but got []
 ;;; STDERR ;;)
diff --git a/test/spec/binary.txt b/test/spec/binary.txt
index 084fe516..b0bd5346 100644
--- a/test/spec/binary.txt
+++ b/test/spec/binary.txt
@@ -212,8 +212,7 @@ out/test/spec/binary.wast:1205: assert_malformed passed:
 out/test/spec/binary.wast:1227: assert_malformed passed:
   000001e: error: data.drop requires data count section
 out/test/spec/binary.wast:1246: assert_malformed passed:
-  0000024: error: expected ref.null or ref.func in passive element segment
-  0000025: error: expected END opcode after element expression
+  0000024: error: unexpected opcode: 0xf3
 out/test/spec/binary.wast:1272: assert_malformed passed:
   0000022: error: table elem type must be a reference type
 out/test/spec/binary.wast:1353: assert_malformed passed:
diff --git a/test/spec/call_indirect.txt b/test/spec/call_indirect.txt
index 3728e4ad..a950b15e 100644
--- a/test/spec/call_indirect.txt
+++ b/test/spec/call_indirect.txt
@@ -148,7 +148,7 @@ out/test/spec/call_indirect.wast:1004: assert_invalid passed:
   out/test/spec/call_indirect/call_indirect.33.wasm:0000026: error: function type variable out of range: 1012321300 (max 1)
   0000026: error: OnCallIndirectExpr callback failed
 out/test/spec/call_indirect.wast:1015: assert_invalid passed:
   out/test/spec/call_indirect/call_indirect.34.wasm:0000018: error: function variable out of range: 0 (max 0)
-  0000018: error: OnElemSegmentElemExpr_RefFunc callback failed
+  0000018: error: OnRefFuncExpr callback failed
 170/170 tests passed.
 ;;; STDOUT ;;)
diff --git a/test/spec/elem.txt b/test/spec/elem.txt
index 34f10d7f..f588e3a5 100644
--- a/test/spec/elem.txt
+++ b/test/spec/elem.txt
@@ -55,22 +55,23 @@ out/test/spec/elem.wast:484: assert_invalid passed:
   out/test/spec/elem/elem.50.wasm:000002e: error: initializer expression cannot reference a mutable global
   000002e: error: OnGlobalGetExpr callback failed
 out/test/spec/elem.wast:495: assert_invalid passed:
-  out/test/spec/elem/elem.51.wasm:0000018: error: type mismatch at elem expression. got externref, expected funcref
-  0000018: error: OnElemSegmentElemExpr_RefNull callback failed
+  out/test/spec/elem/elem.51.wasm:0000018: error: type mismatch in initializer expression, expected [funcref] but got [externref]
+  0000019: error: EndElemExpr callback failed
 out/test/spec/elem.wast:503: assert_invalid passed:
-  0000019: error: expected END opcode after element expression
+  out/test/spec/elem/elem.52.wasm:000001a: error: type mismatch at end of initializer expression, expected [] but got [funcref]
+  000001b: error: EndElemExpr callback failed
 out/test/spec/elem.wast:511: assert_invalid passed:
-  0000017: error: expected ref.null or ref.func in passive element segment
-  0000018: error: expected END opcode after element expression
+  out/test/spec/elem/elem.53.wasm:0000018: error: type mismatch in initializer expression, expected [funcref] but got [i32]
+  0000019: error: EndElemExpr callback failed
 out/test/spec/elem.wast:519: assert_invalid passed:
-  0000017: error: expected ref.null or ref.func in passive element segment
-  0000018: error: expected END opcode after element expression
+  out/test/spec/elem/elem.54.wasm:0000018: error: type mismatch in initializer expression, expected [funcref] but got [i32]
+  0000019: error: EndElemExpr callback failed
 out/test/spec/elem.wast:527: assert_invalid passed:
-  0000022: error: expected ref.null or ref.func in passive element segment
-  0000023: error: expected END opcode after element expression
+  out/test/spec/elem/elem.55.wasm:0000023: error: invalid initializer: instruction not valid in initializer expression: call
+  0000023: error: OnCallExpr callback failed
 out/test/spec/elem.wast:536: assert_invalid passed:
-  0000017: error: expected ref.null or ref.func in passive element segment
-  0000018: error: expected END opcode after element expression
+  out/test/spec/elem/elem.56.wasm:000001b: error: invalid initializer: instruction not valid in initializer expression: i32.add
+  000001b: error: OnBinaryExpr callback failed
 out/test/spec/elem.wast:593: assert_trap passed: uninitialized table element
 out/test/spec/elem.wast:626: assert_invalid passed:
   out/test/spec/elem/elem.62.wasm:000001f: error: type mismatch at elem segment. got externref, expected funcref
diff --git a/test/spec/exception-handling/binary.txt b/test/spec/exception-handling/binary.txt
index 240ee602..561c7918 100644
--- a/test/spec/exception-handling/binary.txt
+++ b/test/spec/exception-handling/binary.txt
@@ -213,8 +213,7 @@ out/test/spec/exception-handling/binary.wast:1205: assert_malformed passed:
 out/test/spec/exception-handling/binary.wast:1227: assert_malformed passed:
   000001e: error: data.drop requires data count section
 out/test/spec/exception-handling/binary.wast:1246: assert_malformed passed:
-  0000024: error: expected ref.null or ref.func in passive element segment
-  0000025: error: expected END opcode after element expression
+  0000024: error: unexpected opcode: 0xf3
 out/test/spec/exception-handling/binary.wast:1272: assert_malformed passed:
   0000022: error: table elem type must be a reference type
 out/test/spec/exception-handling/binary.wast:1353: assert_malformed passed:
diff --git a/test/spec/extended-const/elem.txt b/test/spec/extended-const/elem.txt
index d27b224f..75837f59 100644
--- a/test/spec/extended-const/elem.txt
+++ b/test/spec/extended-const/elem.txt
@@ -56,22 +56,23 @@ out/test/spec/extended-const/elem.wast:484: assert_invalid passed:
   out/test/spec/extended-const/elem/elem.50.wasm:000002e: error: initializer expression cannot reference a mutable global
   000002e: error: OnGlobalGetExpr callback failed
 out/test/spec/extended-const/elem.wast:495: assert_invalid passed:
-  out/test/spec/extended-const/elem/elem.51.wasm:0000018: error: type mismatch at elem expression. got externref, expected funcref
-  0000018: error: OnElemSegmentElemExpr_RefNull callback failed
+  out/test/spec/extended-const/elem/elem.51.wasm:0000018: error: type mismatch in initializer expression, expected [funcref] but got [externref]
+  0000019: error: EndElemExpr callback failed
 out/test/spec/extended-const/elem.wast:503: assert_invalid passed:
-  0000019: error: expected END opcode after element expression
+  out/test/spec/extended-const/elem/elem.52.wasm:000001a: error: type mismatch at end of initializer expression, expected [] but got [funcref]
+  000001b: error: EndElemExpr callback failed
 out/test/spec/extended-const/elem.wast:511: assert_invalid passed:
-  0000017: error: expected ref.null or ref.func in passive element segment
-  0000018: error: expected END opcode after element expression
+  out/test/spec/extended-const/elem/elem.53.wasm:0000018: error: type mismatch in initializer expression, expected [funcref] but got [i32]
+  0000019: error: EndElemExpr callback failed
 out/test/spec/extended-const/elem.wast:519: assert_invalid passed:
-  0000017: error: expected ref.null or ref.func in passive element segment
-  0000018: error: expected END opcode after element expression
+  out/test/spec/extended-const/elem/elem.54.wasm:0000018: error: type mismatch in initializer expression, expected [funcref] but got [i32]
+  0000019: error: EndElemExpr callback failed
 out/test/spec/extended-const/elem.wast:527: assert_invalid passed:
-  0000022: error: expected ref.null or ref.func in passive element segment
-  0000023: error: expected END opcode after element expression
+  out/test/spec/extended-const/elem/elem.55.wasm:0000023: error: invalid initializer: instruction not valid in initializer expression: call
+  0000023: error: OnCallExpr callback failed
 out/test/spec/extended-const/elem.wast:536: assert_invalid passed:
-  0000022: error: expected ref.null or ref.func in passive element segment
-  0000023: error: expected END opcode after element expression
+  out/test/spec/extended-const/elem/elem.56.wasm:0000023: error: invalid initializer: instruction not valid in initializer expression: call
+  0000023: error: OnCallExpr callback failed
 out/test/spec/extended-const/elem.wast:594: assert_trap passed: uninitialized table element
 out/test/spec/extended-const/elem.wast:627: assert_invalid passed:
   out/test/spec/extended-const/elem/elem.62.wasm:000001f: error: type mismatch at elem segment. got externref, expected funcref
diff --git a/test/spec/multi-memory/binary.txt b/test/spec/multi-memory/binary.txt
index e7ae9959..6210d4dc 100644
--- a/test/spec/multi-memory/binary.txt
+++ b/test/spec/multi-memory/binary.txt
@@ -193,8 +193,7 @@ out/test/spec/multi-memory/binary.wast:1014: assert_malformed passed:
 out/test/spec/multi-memory/binary.wast:1036: assert_malformed passed:
   000001e: error: data.drop requires data count section
 out/test/spec/multi-memory/binary.wast:1055: assert_malformed passed:
-  0000024: error: expected ref.null or ref.func in passive element segment
-  0000025: error: expected END opcode after element expression
+  0000024: error: unexpected opcode: 0xf3
 out/test/spec/multi-memory/binary.wast:1081: assert_malformed passed:
   0000022: error: table elem type must be a reference type
 out/test/spec/multi-memory/binary.wast:1162: assert_malformed passed:
diff --git a/test/spec/tail-call/return_call_indirect.txt b/test/spec/tail-call/return_call_indirect.txt
index 1c3354c2..ee1bcf55 100644
--- a/test/spec/tail-call/return_call_indirect.txt
+++ b/test/spec/tail-call/return_call_indirect.txt
@@ -114,7 +114,7 @@ out/test/spec/tail-call/return_call_indirect.wast:523: assert_invalid passed:
   out/test/spec/tail-call/return_call_indirect/return_call_indirect.26.wasm:0000026: error: function type variable out of range: 1012321300 (max 1)
   0000026: error: OnReturnCallIndirectExpr callback failed
 out/test/spec/tail-call/return_call_indirect.wast:534: assert_invalid passed:
   out/test/spec/tail-call/return_call_indirect/return_call_indirect.27.wasm:0000018: error: function variable out of range: 0 (max 0)
-  0000018: error: OnElemSegmentElemExpr_RefFunc callback failed
+  0000018: error: OnRefFuncExpr callback failed
 75/75 tests passed.
 ;;; STDOUT ;;)
diff --git a/test/strip/remove_section.txt b/test/strip/remove_section.txt
index 5a157f3a..31a2fc38 100644
--- a/test/strip/remove_section.txt
+++ b/test/strip/remove_section.txt
@@ -25,12 +25,13 @@ section("five") { "Ut enim ad minim veniam," }
 remove_section_stripped.wasm:	file format wasm 0x1
 
 Sections:
+
    Custom start=0x0000000a end=0x0000002a (size=0x00000020) "two"
    Custom start=0x0000002c end=0x00000052 (size=0x00000026) "three"
    Custom start=0x00000054 end=0x0000007a (size=0x00000026) "four"
      Type start=0x0000007c end=0x00000081 (size=0x00000005) count: 1
  Function start=0x00000083 end=0x00000085 (size=0x00000002) count: 1
    Export start=0x00000087 end=0x0000008f (size=0x00000008) count: 1
      Code start=0x00000091 end=0x00000099 (size=0x00000008) count: 1
    Custom start=0x0000009b end=0x000000b8 (size=0x0000001d) "five"
 ;;; STDOUT ;;)
diff --git a/test/wasm2c/add.txt b/test/wasm2c/add.txt
index 783f443c..1d25c416 100644
--- a/test/wasm2c/add.txt
+++ b/test/wasm2c/add.txt
@@ -567,7 +567,8 @@ static inline void memory_init(wasm_rt_memory_t* dest,
 }
 
 typedef struct {
+  enum { RefFunc, RefNull, GlobalGet } expr_type;
   wasm_rt_func_type_t type;
   wasm_rt_function_ptr_t func;
   size_t module_offset;
 } wasm_elem_segment_expr_t;
@@ -575,23 +576,35 @@ typedef struct {
 static inline void funcref_table_init(wasm_rt_funcref_table_t* dest,
                                       const wasm_elem_segment_expr_t* src,
                                       u32 src_size,
                                       u32 dest_addr,
                                       u32 src_addr,
                                       u32 n,
                                       void* module_instance) {
   if (UNLIKELY(src_addr + (uint64_t)n > src_size))
     TRAP(OOB);
   if (UNLIKELY(dest_addr + (uint64_t)n > dest->size))
     TRAP(OOB);
   for (u32 i = 0; i < n; i++) {
-    const wasm_elem_segment_expr_t* src_expr = &src[src_addr + i];
-    dest->data[dest_addr + i] =
-        (wasm_rt_funcref_t){src_expr->type, src_expr->func,
-                            (char*)module_instance + src_expr->module_offset};
+    const wasm_elem_segment_expr_t* const src_expr = &src[src_addr + i];
+    wasm_rt_funcref_t* const dest_val = &(dest->data[dest_addr + i]);
+    switch (src_expr->expr_type) {
+      case RefFunc:
+        *dest_val = (wasm_rt_funcref_t){
+            src_expr->type, src_expr->func,
+            (char*)module_instance + src_expr->module_offset};
+        break;
+      case RefNull:
+        *dest_val = wasm_rt_funcref_null_value;
+        break;
+      case GlobalGet:
+        *dest_val = **(wasm_rt_funcref_t**)((char*)module_instance +
+                                            src_expr->module_offset);
+        break;
+    }
   }
 }
 
-// Currently Wasm only supports initializing externref tables with ref.null.
+// Currently wasm2c only supports initializing externref tables with ref.null.
 static inline void externref_table_init(wasm_rt_externref_table_t* dest,
                                         u32 src_size,
                                         u32 dest_addr,
diff --git a/test/wasm2c/check-imports.txt b/test/wasm2c/check-imports.txt
index bae7f486..1401f7ce 100644
--- a/test/wasm2c/check-imports.txt
+++ b/test/wasm2c/check-imports.txt
@@ -590,7 +590,8 @@ static inline void memory_init(wasm_rt_memory_t* dest,
 }
 
 typedef struct {
+  enum { RefFunc, RefNull, GlobalGet } expr_type;
   wasm_rt_func_type_t type;
   wasm_rt_function_ptr_t func;
   size_t module_offset;
 } wasm_elem_segment_expr_t;
@@ -598,23 +599,35 @@ typedef struct {
 static inline void funcref_table_init(wasm_rt_funcref_table_t* dest,
                                       const wasm_elem_segment_expr_t* src,
                                       u32 src_size,
                                       u32 dest_addr,
                                       u32 src_addr,
                                       u32 n,
                                       void* module_instance) {
   if (UNLIKELY(src_addr + (uint64_t)n > src_size))
     TRAP(OOB);
   if (UNLIKELY(dest_addr + (uint64_t)n > dest->size))
     TRAP(OOB);
   for (u32 i = 0; i < n; i++) {
-    const wasm_elem_segment_expr_t* src_expr = &src[src_addr + i];
-    dest->data[dest_addr + i] =
-        (wasm_rt_funcref_t){src_expr->type, src_expr->func,
-                            (char*)module_instance + src_expr->module_offset};
+    const wasm_elem_segment_expr_t* const src_expr = &src[src_addr + i];
+    wasm_rt_funcref_t* const dest_val = &(dest->data[dest_addr + i]);
+    switch (src_expr->expr_type) {
+      case RefFunc:
+        *dest_val = (wasm_rt_funcref_t){
+            src_expr->type, src_expr->func,
+            (char*)module_instance + src_expr->module_offset};
+        break;
+      case RefNull:
+        *dest_val = wasm_rt_funcref_null_value;
+        break;
+      case GlobalGet:
+        *dest_val = **(wasm_rt_funcref_t**)((char*)module_instance +
+                                            src_expr->module_offset);
+        break;
+    }
   }
 }
 
-// Currently Wasm only supports initializing externref tables with ref.null.
+// Currently wasm2c only supports initializing externref tables with ref.null.
 static inline void externref_table_init(wasm_rt_externref_table_t* dest,
                                         u32 src_size,
                                         u32 dest_addr,
@@ -703,7 +716,7 @@ static void init_memories(w2c_test* instance) {
 }
 
 static const wasm_elem_segment_expr_t elem_segment_exprs_w2c_test_e0[] = {
-  {w2c_test_t1, (wasm_rt_function_ptr_t)w2c_test_f1, 0},
+  {RefFunc, w2c_test_t1, (wasm_rt_function_ptr_t)w2c_test_f1, 0},
 };
 
 static void init_tables(w2c_test* instance) {
diff --git a/test/wasm2c/export-names.txt b/test/wasm2c/export-names.txt
index 596db402..3d0395a1 100644
--- a/test/wasm2c/export-names.txt
+++ b/test/wasm2c/export-names.txt
@@ -590,7 +590,8 @@ static inline void memory_init(wasm_rt_memory_t* dest,
 }
 
 typedef struct {
+  enum { RefFunc, RefNull, GlobalGet } expr_type;
   wasm_rt_func_type_t type;
   wasm_rt_function_ptr_t func;
   size_t module_offset;
 } wasm_elem_segment_expr_t;
@@ -598,23 +599,35 @@ typedef struct {
 static inline void funcref_table_init(wasm_rt_funcref_table_t* dest,
                                       const wasm_elem_segment_expr_t* src,
                                       u32 src_size,
                                       u32 dest_addr,
                                       u32 src_addr,
                                       u32 n,
                                       void* module_instance) {
   if (UNLIKELY(src_addr + (uint64_t)n > src_size))
     TRAP(OOB);
   if (UNLIKELY(dest_addr + (uint64_t)n > dest->size))
     TRAP(OOB);
   for (u32 i = 0; i < n; i++) {
-    const wasm_elem_segment_expr_t* src_expr = &src[src_addr + i];
-    dest->data[dest_addr + i] =
-        (wasm_rt_funcref_t){src_expr->type, src_expr->func,
-                            (char*)module_instance + src_expr->module_offset};
+    const wasm_elem_segment_expr_t* const src_expr = &src[src_addr + i];
+    wasm_rt_funcref_t* const dest_val = &(dest->data[dest_addr + i]);
+    switch (src_expr->expr_type) {
+      case RefFunc:
+        *dest_val = (wasm_rt_funcref_t){
+            src_expr->type, src_expr->func,
+            (char*)module_instance + src_expr->module_offset};
+        break;
+      case RefNull:
+        *dest_val = wasm_rt_funcref_null_value;
+        break;
+      case GlobalGet:
+        *dest_val = **(wasm_rt_funcref_t**)((char*)module_instance +
+                                            src_expr->module_offset);
+        break;
+    }
   }
 }
 
-// Currently Wasm only supports initializing externref tables with ref.null.
+// Currently wasm2c only supports initializing externref tables with ref.null.
 static inline void externref_table_init(wasm_rt_externref_table_t* dest,
                                         u32 src_size,
                                         u32 dest_addr,
diff --git a/test/wasm2c/hello.txt b/test/wasm2c/hello.txt
index 752725e8..a4b9a0e3 100644
--- a/test/wasm2c/hello.txt
+++ b/test/wasm2c/hello.txt
@@ -598,7 +598,8 @@ static inline void memory_init(wasm_rt_memory_t* dest,
 }
 
 typedef struct {
+  enum { RefFunc, RefNull, GlobalGet } expr_type;
   wasm_rt_func_type_t type;
   wasm_rt_function_ptr_t func;
   size_t module_offset;
 } wasm_elem_segment_expr_t;
@@ -606,23 +607,35 @@ typedef struct {
 static inline void funcref_table_init(wasm_rt_funcref_table_t* dest,
                                       const wasm_elem_segment_expr_t* src,
                                       u32 src_size,
                                       u32 dest_addr,
                                       u32 src_addr,
                                       u32 n,
                                       void* module_instance) {
   if (UNLIKELY(src_addr + (uint64_t)n > src_size))
     TRAP(OOB);
   if (UNLIKELY(dest_addr + (uint64_t)n > dest->size))
     TRAP(OOB);
   for (u32 i = 0; i < n; i++) {
-    const wasm_elem_segment_expr_t* src_expr = &src[src_addr + i];
-    dest->data[dest_addr + i] =
-        (wasm_rt_funcref_t){src_expr->type, src_expr->func,
-                            (char*)module_instance + src_expr->module_offset};
+    const wasm_elem_segment_expr_t* const src_expr = &src[src_addr + i];
+    wasm_rt_funcref_t* const dest_val = &(dest->data[dest_addr + i]);
+    switch (src_expr->expr_type) {
+      case RefFunc:
+        *dest_val = (wasm_rt_funcref_t){
+            src_expr->type, src_expr->func,
+            (char*)module_instance + src_expr->module_offset};
+        break;
+      case RefNull:
+        *dest_val = wasm_rt_funcref_null_value;
+        break;
+      case GlobalGet:
+        *dest_val = **(wasm_rt_funcref_t**)((char*)module_instance +
+                                            src_expr->module_offset);
+        break;
+    }
   }
 }
 
-// Currently Wasm only supports initializing externref tables with ref.null.
+// Currently wasm2c only supports initializing externref tables with ref.null.
 static inline void externref_table_init(wasm_rt_externref_table_t* dest,
                                         u32 src_size,
                                         u32 dest_addr,
@@ -719,7 +732,7 @@ static void init_data_instances(w2c_test *instance) {
 }
 
 static const wasm_elem_segment_expr_t elem_segment_exprs_w2c_test_e0[] = {
-  {w2c_test_t0, (wasm_rt_function_ptr_t)w2c_wasi__snapshot__preview1_fd_write, offsetof(w2c_test, w2c_wasi__snapshot__preview1_instance)},
+  {RefFunc, w2c_test_t0, (wasm_rt_function_ptr_t)w2c_wasi__snapshot__preview1_fd_write, offsetof(w2c_test, w2c_wasi__snapshot__preview1_instance)},
 };
 
 static void init_tables(w2c_test* instance) {
diff --git a/test/wasm2c/minimal.txt b/test/wasm2c/minimal.txt
index 08c72401..81012a90 100644
--- a/test/wasm2c/minimal.txt
+++ b/test/wasm2c/minimal.txt
@@ -561,7 +561,8 @@ static inline void memory_init(wasm_rt_memory_t* dest,
 }
 
 typedef struct {
+  enum { RefFunc, RefNull, GlobalGet } expr_type;
   wasm_rt_func_type_t type;
   wasm_rt_function_ptr_t func;
   size_t module_offset;
 } wasm_elem_segment_expr_t;
@@ -569,23 +570,35 @@ typedef struct {
 static inline void funcref_table_init(wasm_rt_funcref_table_t* dest,
                                       const wasm_elem_segment_expr_t* src,
                                       u32 src_size,
                                       u32 dest_addr,
                                       u32 src_addr,
                                       u32 n,
                                       void* module_instance) {
   if (UNLIKELY(src_addr + (uint64_t)n > src_size))
     TRAP(OOB);
   if (UNLIKELY(dest_addr + (uint64_t)n > dest->size))
     TRAP(OOB);
   for (u32 i = 0; i < n; i++) {
-    const wasm_elem_segment_expr_t* src_expr = &src[src_addr + i];
-    dest->data[dest_addr + i] =
-        (wasm_rt_funcref_t){src_expr->type, src_expr->func,
-                            (char*)module_instance + src_expr->module_offset};
-  }
-}
-
-// Currently Wasm only supports initializing externref tables with ref.null.
+    const wasm_elem_segment_expr_t* const src_expr = &src[src_addr + i];
+    wasm_rt_funcref_t* const dest_val = &(dest->data[dest_addr + i]);
+    switch (src_expr->expr_type) {
+      case RefFunc:
+        *dest_val = (wasm_rt_funcref_t){
+            src_expr->type, src_expr->func,
+            (char*)module_instance + src_expr->module_offset};
+        break;
+      case RefNull:
+        *dest_val = wasm_rt_funcref_null_value;
+        break;
+      case GlobalGet:
+        *dest_val = **(wasm_rt_funcref_t**)((char*)module_instance +
+                                            src_expr->module_offset);
+        break;
+    }
+  }
+}
+
+// Currently wasm2c only supports initializing externref tables with ref.null.
 static inline void externref_table_init(wasm_rt_externref_table_t* dest,
                                         u32 src_size,
                                         u32 dest_addr,
diff --git a/wasm2c/examples/fac/fac.c b/wasm2c/examples/fac/fac.c
index 31bceb94..153ab1fb 100644
--- a/wasm2c/examples/fac/fac.c
+++ b/wasm2c/examples/fac/fac.c
@@ -519,7 +519,8 @@ static inline void memory_init(wasm_rt_memory_t* dest,
 }
 
 typedef struct {
+  enum { RefFunc, RefNull, GlobalGet } expr_type;
   wasm_rt_func_type_t type;
   wasm_rt_function_ptr_t func;
   size_t module_offset;
 } wasm_elem_segment_expr_t;
@@ -527,23 +528,35 @@ typedef struct {
 static inline void funcref_table_init(wasm_rt_funcref_table_t* dest,
                                       const wasm_elem_segment_expr_t* src,
                                       u32 src_size,
                                       u32 dest_addr,
                                       u32 src_addr,
                                       u32 n,
                                       void* module_instance) {
   if (UNLIKELY(src_addr + (uint64_t)n > src_size))
     TRAP(OOB);
   if (UNLIKELY(dest_addr + (uint64_t)n > dest->size))
     TRAP(OOB);
   for (u32 i = 0; i < n; i++) {
-    const wasm_elem_segment_expr_t* src_expr = &src[src_addr + i];
-    dest->data[dest_addr + i] =
-        (wasm_rt_funcref_t){src_expr->type, src_expr->func,
-                            (char*)module_instance + src_expr->module_offset};
+    const wasm_elem_segment_expr_t* const src_expr = &src[src_addr + i];
+    wasm_rt_funcref_t* const dest_val = &(dest->data[dest_addr + i]);
+    switch (src_expr->expr_type) {
+      case RefFunc:
+        *dest_val = (wasm_rt_funcref_t){
+            src_expr->type, src_expr->func,
+            (char*)module_instance + src_expr->module_offset};
+        break;
+      case RefNull:
+        *dest_val = wasm_rt_funcref_null_value;
+        break;
+      case GlobalGet:
+        *dest_val = **(wasm_rt_funcref_t**)((char*)module_instance +
+                                            src_expr->module_offset);
+        break;
+    }
   }
 }
 
-// Currently Wasm only supports initializing externref tables with ref.null.
+// Currently wasm2c only supports initializing externref tables with ref.null.
 static inline void externref_table_init(wasm_rt_externref_table_t* dest,
                                         u32 src_size,
                                         u32 dest_addr,
