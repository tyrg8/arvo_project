commit 3ecb9dd575db7da4542b659a8e9d7f9948d4be76
Author: Marta Iborra <martaiborra24@gmail.com>
Date:   Tue Oct 3 11:08:17 2023 +0200

    Check ctx has been created correctly

diff --git a/blosc/blosc2.c b/blosc/blosc2.c
index 8b54c755..336f3ab9 100644
--- a/blosc/blosc2.c
+++ b/blosc/blosc2.c
@@ -2676,195 +2676,199 @@ void build_filters(const int doshuffle, const int delta,
 /* The public secure routine for compression. */
 int blosc2_compress(int clevel, int doshuffle, int32_t typesize,
                     const void* src, int32_t srcsize, void* dest, int32_t destsize) {
   int error;
   int result;
   char* envvar;
 
   /* Check whether the library should be initialized */
   if (!g_initlib) blosc2_init();
 
   /* Check for a BLOSC_CLEVEL environment variable */
   envvar = getenv("BLOSC_CLEVEL");
   if (envvar != NULL) {
     long value;
     value = strtol(envvar, NULL, 10);
     if ((value != EINVAL) && (value >= 0)) {
       clevel = (int)value;
     }
     else {
       BLOSC_TRACE_WARNING("BLOSC_CLEVEL environment variable '%s' not recognized\n", envvar);
     }
   }
 
   /* Check for a BLOSC_SHUFFLE environment variable */
   envvar = getenv("BLOSC_SHUFFLE");
   if (envvar != NULL) {
     if (strcmp(envvar, "NOSHUFFLE") == 0) {
       doshuffle = BLOSC_NOSHUFFLE;
     }
     else if (strcmp(envvar, "SHUFFLE") == 0) {
       doshuffle = BLOSC_SHUFFLE;
     }
     else if (strcmp(envvar, "BITSHUFFLE") == 0) {
       doshuffle = BLOSC_BITSHUFFLE;
     }
     else {
       BLOSC_TRACE_WARNING("BLOSC_SHUFFLE environment variable '%s' not recognized\n", envvar);
     }
   }
 
   /* Check for a BLOSC_DELTA environment variable */
   envvar = getenv("BLOSC_DELTA");
   if (envvar != NULL) {
     if (strcmp(envvar, "1") == 0) {
       blosc2_set_delta(1);
     } else if (strcmp(envvar, "0") == 0) {
       blosc2_set_delta(0);
     }
     else {
       BLOSC_TRACE_WARNING("BLOSC_DELTA environment variable '%s' not recognized\n", envvar);
     }
   }
 
   /* Check for a BLOSC_TYPESIZE environment variable */
   envvar = getenv("BLOSC_TYPESIZE");
   if (envvar != NULL) {
     long value;
     value = strtol(envvar, NULL, 10);
     if ((value != EINVAL) && (value > 0)) {
       typesize = (int32_t)value;
     }
     else {
       BLOSC_TRACE_WARNING("BLOSC_TYPESIZE environment variable '%s' not recognized\n", envvar);
     }
   }
 
   /* Check for a BLOSC_COMPRESSOR environment variable */
   envvar = getenv("BLOSC_COMPRESSOR");
   if (envvar != NULL) {
     result = blosc1_set_compressor(envvar);
     if (result < 0) {
       BLOSC_TRACE_WARNING("BLOSC_COMPRESSOR environment variable '%s' not recognized\n", envvar);
     }
   }
 
   /* Check for a BLOSC_BLOCKSIZE environment variable */
   envvar = getenv("BLOSC_BLOCKSIZE");
   if (envvar != NULL) {
     long blocksize;
     blocksize = strtol(envvar, NULL, 10);
     if ((blocksize != EINVAL) && (blocksize > 0)) {
       blosc1_set_blocksize((size_t) blocksize);
     }
     else {
       BLOSC_TRACE_WARNING("BLOSC_BLOCKSIZE environment variable '%s' not recognized\n", envvar);
     }
   }
 
   /* Check for a BLOSC_NTHREADS environment variable */
   envvar = getenv("BLOSC_NTHREADS");
   if (envvar != NULL) {
     long nthreads;
     nthreads = strtol(envvar, NULL, 10);
     if ((nthreads != EINVAL) && (nthreads > 0)) {
       result = blosc2_set_nthreads((int16_t) nthreads);
       if (result < 0) {
         BLOSC_TRACE_WARNING("BLOSC_NTHREADS environment variable '%s' not recognized\n", envvar);
       }
     }
   }
 
   /* Check for a BLOSC_SPLITMODE environment variable */
   envvar = getenv("BLOSC_SPLITMODE");
   if (envvar != NULL) {
     int32_t splitmode = -1;
     if (strcmp(envvar, "ALWAYS") == 0) {
       splitmode = BLOSC_ALWAYS_SPLIT;
     }
     else if (strcmp(envvar, "NEVER") == 0) {
       splitmode = BLOSC_NEVER_SPLIT;
     }
     else if (strcmp(envvar, "AUTO") == 0) {
       splitmode = BLOSC_AUTO_SPLIT;
     }
     else if (strcmp(envvar, "FORWARD_COMPAT") == 0) {
       splitmode = BLOSC_FORWARD_COMPAT_SPLIT;
     }
     else {
       BLOSC_TRACE_WARNING("BLOSC_SPLITMODE environment variable '%s' not recognized\n", envvar);
     }
 
     if (splitmode >= 0) {
       blosc1_set_splitmode(splitmode);
     }
   }
 
   /* Check for a BLOSC_NOLOCK environment variable.  It is important
      that this should be the last env var so that it can take the
      previous ones into account */
   envvar = getenv("BLOSC_NOLOCK");
   if (envvar != NULL) {
     // TODO: here is the only place that returns an extended header from
     //  a blosc1_compress() call.  This should probably be fixed.
     const char *compname;
     blosc2_context *cctx;
     blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
 
     blosc2_compcode_to_compname(g_compressor, &compname);
     /* Create a context for compression */
     build_filters(doshuffle, g_delta, typesize, cparams.filters);
     // TODO: cparams can be shared in a multithreaded environment.  do a copy!
     cparams.typesize = (uint8_t)typesize;
     cparams.compcode = (uint8_t)g_compressor;
     cparams.clevel = (uint8_t)clevel;
     cparams.nthreads = g_nthreads;
     cparams.splitmode = g_splitmode;
     cctx = blosc2_create_cctx(cparams);
+    if (cctx == NULL) {
+      BLOSC_TRACE_ERROR("Error while creating the compression context");
+      return BLOSC2_ERROR_NULL_POINTER;
+    }
     /* Do the actual compression */
     result = blosc2_compress_ctx(cctx, src, srcsize, dest, destsize);
     /* Release context resources */
     blosc2_free_ctx(cctx);
     return result;
   }
 
   pthread_mutex_lock(&global_comp_mutex);
 
   /* Initialize a context compression */
   uint8_t* filters = calloc(1, BLOSC2_MAX_FILTERS);
   BLOSC_ERROR_NULL(filters, BLOSC2_ERROR_MEMORY_ALLOC);
   uint8_t* filters_meta = calloc(1, BLOSC2_MAX_FILTERS);
   BLOSC_ERROR_NULL(filters_meta, BLOSC2_ERROR_MEMORY_ALLOC);
   build_filters(doshuffle, g_delta, typesize, filters);
   error = initialize_context_compression(
           g_global_context, src, srcsize, dest, destsize, clevel, filters,
           filters_meta, (int32_t)typesize, g_compressor, g_force_blocksize, g_nthreads, g_nthreads,
           g_splitmode, g_tuner, NULL, g_schunk);
   free(filters);
   free(filters_meta);
   if (error <= 0) {
     pthread_mutex_unlock(&global_comp_mutex);
     return error;
   }
 
   envvar = getenv("BLOSC_BLOSC1_COMPAT");
   if (envvar != NULL) {
     /* Write chunk header without extended header (Blosc1 compatibility mode) */
     error = write_compression_header(g_global_context, false);
   }
   else {
     error = write_compression_header(g_global_context, true);
   }
   if (error < 0) {
     pthread_mutex_unlock(&global_comp_mutex);
     return error;
   }
 
   result = blosc_compress_context(g_global_context);
 
   pthread_mutex_unlock(&global_comp_mutex);
 
   return result;
 }
 
 
 /* The public routine for compression. */
@@ -2933,47 +2937,51 @@ int blosc2_decompress_ctx(blosc2_context* context, const void* src, int32_t srcs
 /* The public secure routine for decompression. */
 int blosc2_decompress(const void* src, int32_t srcsize, void* dest, int32_t destsize) {
   int result;
   char* envvar;
   long nthreads;
   blosc2_context *dctx;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
 
   /* Check whether the library should be initialized */
   if (!g_initlib) blosc2_init();
 
   /* Check for a BLOSC_NTHREADS environment variable */
   envvar = getenv("BLOSC_NTHREADS");
   if (envvar != NULL) {
     nthreads = strtol(envvar, NULL, 10);
     if ((nthreads != EINVAL) && (nthreads > 0)) {
       result = blosc2_set_nthreads((int16_t) nthreads);
       if (result < 0) {
         return result;
       }
     }
   }
 
   /* Check for a BLOSC_NOLOCK environment variable.  It is important
      that this should be the last env var so that it can take the
      previous ones into account */
   envvar = getenv("BLOSC_NOLOCK");
   if (envvar != NULL) {
     dparams.nthreads = g_nthreads;
     dctx = blosc2_create_dctx(dparams);
+    if (dctx == NULL) {
+      BLOSC_TRACE_ERROR("Error while creating the decompression context");
+      return BLOSC2_ERROR_NULL_POINTER;
+    }
     result = blosc2_decompress_ctx(dctx, src, srcsize, dest, destsize);
     blosc2_free_ctx(dctx);
     return result;
   }
 
   pthread_mutex_lock(&global_comp_mutex);
 
   result = blosc_run_decompression_with_context(
           g_global_context, src, srcsize, dest, destsize);
 
   pthread_mutex_unlock(&global_comp_mutex);
 
   return result;
 }
 
 
 /* The public routine for decompression. */
@@ -4235,175 +4243,191 @@ int blosc2_set_maskout(blosc2_context *ctx, bool *maskout, int nblocks) {
 /* Create a chunk made of zeros */
 int blosc2_chunk_zeros(blosc2_cparams cparams, const int32_t nbytes, void* dest, int32_t destsize) {
   if (destsize < BLOSC_EXTENDED_HEADER_LENGTH) {
     BLOSC_TRACE_ERROR("dest buffer is not long enough");
     return BLOSC2_ERROR_DATA;
   }
 
   if (nbytes % cparams.typesize) {
     BLOSC_TRACE_ERROR("nbytes must be a multiple of typesize");
     return BLOSC2_ERROR_DATA;
   }
 
   blosc_header header;
   blosc2_context* context = blosc2_create_cctx(cparams);
+  if (context == NULL) {
+    BLOSC_TRACE_ERROR("Error while creating the compression context");
+    return BLOSC2_ERROR_NULL_POINTER;
+  }
 
   int error = initialize_context_compression(
           context, NULL, nbytes, dest, destsize,
           context->clevel, context->filters, context->filters_meta,
           context->typesize, context->compcode, context->blocksize,
           context->new_nthreads, context->nthreads, context->splitmode,
           context->tuner_id, context->tuner_params, context->schunk);
   if (error <= 0) {
     blosc2_free_ctx(context);
     return error;
   }
 
   memset(&header, 0, sizeof(header));
   header.version = BLOSC2_VERSION_FORMAT;
   header.versionlz = BLOSC_BLOSCLZ_VERSION_FORMAT;
   header.flags = BLOSC_DOSHUFFLE | BLOSC_DOBITSHUFFLE;  // extended header
   header.typesize = context->typesize;
   header.nbytes = (int32_t)nbytes;
   header.blocksize = context->blocksize;
   header.cbytes = BLOSC_EXTENDED_HEADER_LENGTH;
   header.blosc2_flags = BLOSC2_SPECIAL_ZERO << 4;  // mark chunk as all zeros
   memcpy((uint8_t *)dest, &header, sizeof(header));
 
   blosc2_free_ctx(context);
 
   return BLOSC_EXTENDED_HEADER_LENGTH;
 }
 
 
 /* Create a chunk made of uninitialized values */
 int blosc2_chunk_uninit(blosc2_cparams cparams, const int32_t nbytes, void* dest, int32_t destsize) {
   if (destsize < BLOSC_EXTENDED_HEADER_LENGTH) {
     BLOSC_TRACE_ERROR("dest buffer is not long enough");
     return BLOSC2_ERROR_DATA;
   }
 
   if (nbytes % cparams.typesize) {
     BLOSC_TRACE_ERROR("nbytes must be a multiple of typesize");
     return BLOSC2_ERROR_DATA;
   }
 
   blosc_header header;
   blosc2_context* context = blosc2_create_cctx(cparams);
+  if (context == NULL) {
+    BLOSC_TRACE_ERROR("Error while creating the compression context");
+    return BLOSC2_ERROR_NULL_POINTER;
+  }
   int error = initialize_context_compression(
           context, NULL, nbytes, dest, destsize,
           context->clevel, context->filters, context->filters_meta,
           context->typesize, context->compcode, context->blocksize,
           context->new_nthreads, context->nthreads, context->splitmode,
           context->tuner_id, context->tuner_params, context->schunk);
   if (error <= 0) {
     blosc2_free_ctx(context);
     return error;
   }
 
   memset(&header, 0, sizeof(header));
   header.version = BLOSC2_VERSION_FORMAT;
   header.versionlz = BLOSC_BLOSCLZ_VERSION_FORMAT;
   header.flags = BLOSC_DOSHUFFLE | BLOSC_DOBITSHUFFLE;  // extended header
   header.typesize = context->typesize;
   header.nbytes = (int32_t)nbytes;
   header.blocksize = context->blocksize;
   header.cbytes = BLOSC_EXTENDED_HEADER_LENGTH;
   header.blosc2_flags = BLOSC2_SPECIAL_UNINIT << 4;  // mark chunk as uninitialized
   memcpy((uint8_t *)dest, &header, sizeof(header));
 
   blosc2_free_ctx(context);
 
   return BLOSC_EXTENDED_HEADER_LENGTH;
 }
 
 
 /* Create a chunk made of nans */
 int blosc2_chunk_nans(blosc2_cparams cparams, const int32_t nbytes, void* dest, int32_t destsize) {
   if (destsize < BLOSC_EXTENDED_HEADER_LENGTH) {
     BLOSC_TRACE_ERROR("dest buffer is not long enough");
     return BLOSC2_ERROR_DATA;
   }
 
   if (nbytes % cparams.typesize) {
     BLOSC_TRACE_ERROR("nbytes must be a multiple of typesize");
     return BLOSC2_ERROR_DATA;
   }
 
   blosc_header header;
   blosc2_context* context = blosc2_create_cctx(cparams);
+  if (context == NULL) {
+    BLOSC_TRACE_ERROR("Error while creating the compression context");
+    return BLOSC2_ERROR_NULL_POINTER;
+  }
 
   int error = initialize_context_compression(
           context, NULL, nbytes, dest, destsize,
           context->clevel, context->filters, context->filters_meta,
           context->typesize, context->compcode, context->blocksize,
           context->new_nthreads, context->nthreads, context->splitmode,
           context->tuner_id, context->tuner_params, context->schunk);
   if (error <= 0) {
     blosc2_free_ctx(context);
     return error;
   }
 
   memset(&header, 0, sizeof(header));
   header.version = BLOSC2_VERSION_FORMAT;
   header.versionlz = BLOSC_BLOSCLZ_VERSION_FORMAT;
   header.flags = BLOSC_DOSHUFFLE | BLOSC_DOBITSHUFFLE;  // extended header
   header.typesize = context->typesize;
   header.nbytes = (int32_t)nbytes;
   header.blocksize = context->blocksize;
   header.cbytes = BLOSC_EXTENDED_HEADER_LENGTH;
   header.blosc2_flags = BLOSC2_SPECIAL_NAN << 4;  // mark chunk as all NaNs
   memcpy((uint8_t *)dest, &header, sizeof(header));
 
   blosc2_free_ctx(context);
 
   return BLOSC_EXTENDED_HEADER_LENGTH;
 }
 
 
 /* Create a chunk made of repeated values */
 int blosc2_chunk_repeatval(blosc2_cparams cparams, const int32_t nbytes,
                            void* dest, int32_t destsize, const void* repeatval) {
   uint8_t typesize = cparams.typesize;
   if (destsize < BLOSC_EXTENDED_HEADER_LENGTH + typesize) {
     BLOSC_TRACE_ERROR("dest buffer is not long enough");
     return BLOSC2_ERROR_DATA;
   }
 
   if (nbytes % cparams.typesize) {
     BLOSC_TRACE_ERROR("nbytes must be a multiple of typesize");
     return BLOSC2_ERROR_DATA;
   }
 
   blosc_header header;
   blosc2_context* context = blosc2_create_cctx(cparams);
+  if (context == NULL) {
+    BLOSC_TRACE_ERROR("Error while creating the compression context");
+    return BLOSC2_ERROR_NULL_POINTER;
+  }
 
   int error = initialize_context_compression(
           context, NULL, nbytes, dest, destsize,
           context->clevel, context->filters, context->filters_meta,
           context->typesize, context->compcode, context->blocksize,
           context->new_nthreads, context->nthreads, context->splitmode,
           context->tuner_id, context->tuner_params, context->schunk);
   if (error <= 0) {
     blosc2_free_ctx(context);
     return error;
   }
 
   memset(&header, 0, sizeof(header));
   header.version = BLOSC2_VERSION_FORMAT;
   header.versionlz = BLOSC_BLOSCLZ_VERSION_FORMAT;
   header.flags = BLOSC_DOSHUFFLE | BLOSC_DOBITSHUFFLE;  // extended header
   header.typesize = (uint8_t)typesize;
   header.nbytes = (int32_t)nbytes;
   header.blocksize = context->blocksize;
   header.cbytes = BLOSC_EXTENDED_HEADER_LENGTH + (int32_t)typesize;
   header.blosc2_flags = BLOSC2_SPECIAL_VALUE << 4;  // mark chunk as all repeated value
   memcpy((uint8_t *)dest, &header, sizeof(header));
   memcpy((uint8_t *)dest + sizeof(header), repeatval, typesize);
 
   blosc2_free_ctx(context);
 
   return BLOSC_EXTENDED_HEADER_LENGTH + (uint8_t)typesize;
 }
 
 
 /* Register filters */
diff --git a/blosc/frame.c b/blosc/frame.c
index e4530bf5..4808a6cc 100644
--- a/blosc/frame.c
+++ b/blosc/frame.c
@@ -911,144 +911,148 @@ blosc2_frame_s* frame_from_cframe(uint8_t *cframe, int64_t len, bool copy) {
 /* Create a frame out of a super-chunk. */
 int64_t frame_from_schunk(blosc2_schunk *schunk, blosc2_frame_s *frame) {
   frame->file_offset = 0;
   int64_t nchunks = schunk->nchunks;
   int64_t cbytes = schunk->cbytes;
   int32_t chunk_cbytes;
   int32_t chunk_nbytes;
   void* fp = NULL;
   int rc;
 
   uint8_t* h2 = new_header_frame(schunk, frame);
   if (h2 == NULL) {
     return BLOSC2_ERROR_DATA;
   }
   uint32_t h2len;
   from_big(&h2len, h2 + FRAME_HEADER_LEN, sizeof(h2len));
   // Build the offsets chunk
   int32_t chunksize = -1;
   int32_t off_cbytes = 0;
   uint64_t coffset = 0;
   int32_t off_nbytes = (int32_t) (nchunks * sizeof(int64_t));
   uint64_t* data_tmp = malloc(off_nbytes);
   bool needs_free = false;
   for (int i = 0; i < nchunks; i++) {
     uint8_t* data_chunk;
     data_chunk = schunk->data[i];
     rc = blosc2_cbuffer_sizes(data_chunk, &chunk_nbytes, &chunk_cbytes, NULL);
     if (rc < 0) {
       return rc;
     }
     data_tmp[i] = coffset;
     coffset += chunk_cbytes;
     int32_t chunksize_ = chunk_nbytes;
     if (i == 0) {
       chunksize = chunksize_;
     }
     else if (chunksize != chunksize_) {
       // Variable size  // TODO: update flags for this (or do not use them at all)
       chunksize = 0;
     }
     if (needs_free) {
       free(data_chunk);
     }
   }
   if ((int64_t)coffset != cbytes) {
     free(data_tmp);
     return BLOSC2_ERROR_DATA;
   }
   uint8_t *off_chunk = NULL;
   if (nchunks > 0) {
     // Compress the chunk of offsets
     off_chunk = malloc(off_nbytes + BLOSC2_MAX_OVERHEAD);
     blosc2_context *cctx = blosc2_create_cctx(BLOSC2_CPARAMS_DEFAULTS);
+    if (cctx == NULL) {
+      BLOSC_TRACE_ERROR("Error while creating the compression context");
+      return BLOSC2_ERROR_NULL_POINTER;
+    }
     cctx->typesize = sizeof(int64_t);
     off_cbytes = blosc2_compress_ctx(cctx, data_tmp, off_nbytes, off_chunk,
                                      off_nbytes + BLOSC2_MAX_OVERHEAD);
     blosc2_free_ctx(cctx);
     if (off_cbytes < 0) {
       free(off_chunk);
       free(h2);
       return off_cbytes;
     }
   }
   else {
     off_cbytes = 0;
   }
   free(data_tmp);
 
   // Now that we know them, fill the chunksize and frame length in header
   to_big(h2 + FRAME_CHUNKSIZE, &chunksize, sizeof(chunksize));
   frame->len = h2len + cbytes + off_cbytes + FRAME_TRAILER_MINLEN;
   if (frame->sframe) {
     frame->len = h2len + off_cbytes + FRAME_TRAILER_MINLEN;
   }
   int64_t tbytes = frame->len;
   to_big(h2 + FRAME_LEN, &tbytes, sizeof(tbytes));
 
   blosc2_io_cb *io_cb = blosc2_get_io_cb(frame->schunk->storage->io->id);
   if (io_cb == NULL) {
     BLOSC_TRACE_ERROR("Error getting the input/output API");
     return BLOSC2_ERROR_PLUGIN_IO;
   }
 
   // Create the frame and put the header at the beginning
   if (frame->urlpath == NULL) {
     frame->cframe = malloc((size_t)frame->len);
     memcpy(frame->cframe, h2, h2len);
   }
   else {
     if (frame->sframe) {
       fp = sframe_open_index(frame->urlpath, "wb",
                              frame->schunk->storage->io);
     }
     else {
       fp = io_cb->open(frame->urlpath, "wb", frame->schunk->storage->io->params);
     }
     if (fp == NULL) {
       BLOSC_TRACE_ERROR("Error creating file in: %s", frame->urlpath);
       return BLOSC2_ERROR_FILE_OPEN;
     }
     io_cb->write(h2, h2len, 1, fp);
   }
   free(h2);
 
   // Fill the frame with the actual data chunks
   if (!frame->sframe) {
     coffset = 0;
     for (int i = 0; i < nchunks; i++) {
       uint8_t* data_chunk = schunk->data[i];
       rc = blosc2_cbuffer_sizes(data_chunk, NULL, &chunk_cbytes, NULL);
       if (rc < 0) {
         return rc;
       }
       if (frame->urlpath == NULL) {
         memcpy(frame->cframe + h2len + coffset, data_chunk, (size_t)chunk_cbytes);
       } else {
         io_cb->write(data_chunk, chunk_cbytes, 1, fp);
       }
       coffset += chunk_cbytes;
     }
     if ((int64_t)coffset != cbytes) {
       return BLOSC2_ERROR_FAILURE;
     }
   }
 
   // Copy the offsets chunk at the end of the frame
   if (frame->urlpath == NULL) {
     memcpy(frame->cframe + h2len + cbytes, off_chunk, off_cbytes);
   }
   else {
     io_cb->write(off_chunk, off_cbytes, 1, fp);
     io_cb->close(fp);
   }
   free(off_chunk);
   rc = frame_update_trailer(frame, schunk);
   if (rc < 0) {
     return rc;
   }
 
   return frame->len;
 }
 
 
 // Get the compressed data offsets
@@ -1161,43 +1165,47 @@ uint8_t* get_coffsets(blosc2_frame_s *frame, int32_t header_len, int64_t cbytes,
 // Get the data offsets from a frame
 int64_t* blosc2_frame_get_offsets(blosc2_schunk *schunk) {
   if (schunk->frame == NULL) {
     BLOSC_TRACE_ERROR("This function needs a frame.");
     return NULL;
   }
   blosc2_frame_s* frame = (blosc2_frame_s*)schunk->frame;
 
   // Get header info
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t blocksize;
   int32_t chunksize;
   int64_t nchunks;
   int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes,
                             &blocksize, &chunksize, &nchunks,
                             NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                             frame->schunk->storage->io);
   if (ret < 0) {
     BLOSC_TRACE_ERROR("Cannot get the header info for the frame.");
     return NULL;
   }
 
   int32_t off_nbytes = (int32_t) (nchunks * sizeof(int64_t));
   int64_t* offsets = (int64_t *) malloc((size_t)off_nbytes);
 
   int32_t coffsets_cbytes = 0;
   uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, nchunks, &coffsets_cbytes);
   // Decompress offsets
   blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_context *dctx = blosc2_create_dctx(off_dparams);
+  if (dctx == NULL) {
+    BLOSC_TRACE_ERROR("Error while creating the decompression context");
+    return NULL;
+  }
   int32_t prev_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes,
                                               offsets, off_nbytes);
   blosc2_free_ctx(dctx);
   if (prev_nbytes < 0) {
     free(offsets);
     BLOSC_TRACE_ERROR("Cannot decompress the offsets chunk.");
     return NULL;
   }
   return offsets;
 }
@@ -1721,222 +1729,234 @@ blosc2_storage* get_new_storage(const blosc2_storage* storage,
 /* Get a super-chunk out of a frame */
 blosc2_schunk* frame_to_schunk(blosc2_frame_s* frame, bool copy, const blosc2_io *udio) {
   int32_t header_len;
   int64_t frame_len;
   int rc;
   blosc2_schunk* schunk = calloc(1, sizeof(blosc2_schunk));
   schunk->frame = (blosc2_frame*)frame;
   frame->schunk = schunk;
 
   rc = get_header_info(frame, &header_len, &frame_len, &schunk->nbytes,
                        &schunk->cbytes, &schunk->blocksize,
                        &schunk->chunksize, &schunk->nchunks, &schunk->typesize,
                        &schunk->compcode, &schunk->compcode_meta, &schunk->clevel, schunk->filters,
                        schunk->filters_meta, &schunk->splitmode, udio);
   if (rc < 0) {
     BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
     blosc2_schunk_free(schunk);
     return NULL;
   }
   int64_t nchunks = schunk->nchunks;
   int64_t nbytes = schunk->nbytes;
   (void) nbytes;
   int64_t cbytes = schunk->cbytes;
 
   // Compression and decompression contexts
   blosc2_cparams *cparams;
   blosc2_schunk_get_cparams(schunk, &cparams);
   schunk->cctx = blosc2_create_cctx(*cparams);
+  if (schunk->cctx == NULL) {
+    BLOSC_TRACE_ERROR("Error while creating the compression context");
+    return NULL;
+  }
   blosc2_dparams *dparams;
   blosc2_schunk_get_dparams(schunk, &dparams);
   schunk->dctx = blosc2_create_dctx(*dparams);
+  if (schunk->dctx == NULL) {
+    BLOSC_TRACE_ERROR("Error while creating the decompression context");
+    return NULL;
+  }
   blosc2_storage storage = {.contiguous = copy ? false : true};
   schunk->storage = get_new_storage(&storage, cparams, dparams, udio);
   free(cparams);
   free(dparams);
   if (!copy) {
     goto out;
   }
 
   // We are not attached to a frame anymore
   schunk->frame = NULL;
 
   if (nchunks == 0) {
     frame->schunk = NULL;
     goto out;
   }
 
   // Get the compressed offsets
   int32_t coffsets_cbytes = 0;
   uint8_t* coffsets = get_coffsets(frame, header_len, cbytes, nchunks, &coffsets_cbytes);
   if (coffsets == NULL) {
     blosc2_schunk_free(schunk);
     BLOSC_TRACE_ERROR("Cannot get the offsets for the frame.");
     return NULL;
   }
 
   // Decompress offsets
   blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_context *dctx = blosc2_create_dctx(off_dparams);
+  if (dctx == NULL) {
+    BLOSC_TRACE_ERROR("Error while creating the decompression context");
+    return NULL;
+  }
   int64_t* offsets = (int64_t *) malloc((size_t)nchunks * sizeof(int64_t));
   int32_t off_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes,
                                              offsets, (int32_t)(nchunks * sizeof(int64_t)));
   blosc2_free_ctx(dctx);
   if (off_nbytes < 0) {
     free(offsets);
     blosc2_schunk_free(schunk);
     BLOSC_TRACE_ERROR("Cannot decompress the offsets chunk.");
     return NULL;
   }
 
   // We want the contiguous schunk, so create the actual data chunks (and, while doing this,
   // get a guess at the blocksize used in this frame)
   int64_t acc_nbytes = 0;
   int64_t acc_cbytes = 0;
   int32_t blocksize = 0;
   int32_t chunk_nbytes;
   int32_t chunk_cbytes;
   int32_t chunk_blocksize;
   size_t prev_alloc = BLOSC_EXTENDED_HEADER_LENGTH;
   uint8_t* data_chunk = NULL;
   bool needs_free = false;
   const blosc2_io_cb *io_cb = blosc2_get_io_cb(udio->id);
   if (io_cb == NULL) {
     blosc2_schunk_free(schunk);
     BLOSC_TRACE_ERROR("Error getting the input/output API");
     return NULL;
   }
 
   void* fp = NULL;
   if (frame->cframe == NULL) {
     data_chunk = malloc((size_t)prev_alloc);
     needs_free = true;
     if (!frame->sframe) {
       // If not the chunks won't be in the frame
       fp = io_cb->open(frame->urlpath, "rb", udio->params);
       if (fp == NULL) {
         BLOSC_TRACE_ERROR("Error opening file in: %s", frame->urlpath);
         rc = BLOSC2_ERROR_FILE_OPEN;
         goto end;
       }
     }
   }
   schunk->data = malloc(nchunks * sizeof(void*));
   for (int i = 0; i < nchunks; i++) {
     if (frame->cframe != NULL) {
       if (needs_free) {
         free(data_chunk);
       }
       if (offsets[i] < 0) {
         int64_t rbytes = frame_get_chunk(frame, i, &data_chunk, &needs_free);
         if (rbytes < 0) {
           break;
         }
       }
       else {
        data_chunk = frame->cframe + header_len + offsets[i];
       }
       rc = blosc2_cbuffer_sizes(data_chunk, NULL, &chunk_cbytes, NULL);
       if (rc < 0) {
         break;
       }
     }
     else {
       int64_t rbytes;
       if (frame->sframe) {
         if (needs_free) {
           free(data_chunk);
         }
         rbytes = frame_get_chunk(frame, i, &data_chunk, &needs_free);
         if (rbytes < 0) {
           break;
         }
       }
       else {
         io_cb->seek(fp, frame->file_offset + header_len + offsets[i], SEEK_SET);
         rbytes = io_cb->read(data_chunk, 1, BLOSC_EXTENDED_HEADER_LENGTH, fp);
       }
       if (rbytes != BLOSC_EXTENDED_HEADER_LENGTH) {
         rc = BLOSC2_ERROR_READ_BUFFER;
         break;
       }
       rc = blosc2_cbuffer_sizes(data_chunk, NULL, &chunk_cbytes, NULL);
       if (rc < 0) {
         break;
       }
       if (chunk_cbytes > (int32_t)prev_alloc) {
         data_chunk = realloc(data_chunk, chunk_cbytes);
         prev_alloc = chunk_cbytes;
       }
       if (!frame->sframe) {
         io_cb->seek(fp, frame->file_offset + header_len + offsets[i], SEEK_SET);
         rbytes = io_cb->read(data_chunk, 1, chunk_cbytes, fp);
         if (rbytes != chunk_cbytes) {
           rc = BLOSC2_ERROR_READ_BUFFER;
           break;
         }
       }
     }
     uint8_t* new_chunk = malloc(chunk_cbytes);
     memcpy(new_chunk, data_chunk, chunk_cbytes);
     schunk->data[i] = new_chunk;
     rc = blosc2_cbuffer_sizes(data_chunk, &chunk_nbytes, NULL, &chunk_blocksize);
     if (rc < 0) {
       break;
     }
     acc_nbytes += chunk_nbytes;
     acc_cbytes += chunk_cbytes;
     if (i == 0) {
       blocksize = chunk_blocksize;
     }
     else if (blocksize != chunk_blocksize) {
       // Blocksize varies
       blocksize = 0;
     }
   }
 
   // We are not attached to a schunk anymore
   frame->schunk = NULL;
 
   end:
   if (needs_free) {
     free(data_chunk);
   }
   if (frame->cframe == NULL) {
     if (!frame->sframe) {
       io_cb->close(fp);
     }
   }
   free(offsets);
 
   // cframes and sframes have different ways to store chunks with special values:
   // 1) cframes represent special chunks as negative offsets
   // 2) sframes does not have the concept of offsets, but rather of data pointers (.data)
   //    so they always have a pointer to a special chunk
   // This is why cframes and sframes have different cbytes and hence, we cannot enforce acc_bytes == schunk->cbytes
   // In the future, maybe we could provide special meanings for .data[i] > 0x7FFFFFFF, but not there yet
   // if (rc < 0 || acc_nbytes != nbytes || acc_cbytes != cbytes) {
   if (rc < 0 || acc_nbytes != nbytes) {
     blosc2_schunk_free(schunk);
     return NULL;
   }
   // Update counters
   schunk->cbytes = acc_cbytes;
   schunk->blocksize = blocksize;
 
   out:
   rc = frame_get_metalayers(frame, schunk);
   if (rc < 0) {
     blosc2_schunk_free(schunk);
     BLOSC_TRACE_ERROR("Cannot access the metalayers.");
     return NULL;
   }
 
   rc = frame_get_vlmetalayers(frame, schunk);
   if (rc < 0) {
     blosc2_schunk_free(schunk);
     BLOSC_TRACE_ERROR("Cannot access the vlmetalayers.");
     return NULL;
   }
 
   return schunk;
 }
@@ -2552,237 +2572,245 @@ int64_t frame_fill_special(blosc2_frame_s* frame, int64_t nitems, int special_va
 /* Append an existing chunk into a frame. */
 void* frame_append_chunk(blosc2_frame_s* frame, void* chunk, blosc2_schunk* schunk) {
   int8_t* chunk_ = chunk;
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t blocksize;
   int32_t chunksize;
   int64_t nchunks;
   int rc = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &blocksize, &chunksize,
                            &nchunks, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                            frame->schunk->storage->io);
   if (rc < 0) {
     BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
     return NULL;
   }
 
   /* The uncompressed and compressed sizes start at byte 4 and 12 */
   int32_t chunk_nbytes;
   int32_t chunk_cbytes;
   rc = blosc2_cbuffer_sizes(chunk, &chunk_nbytes, &chunk_cbytes, NULL);
   if (rc < 0) {
     return NULL;
   }
 
   if ((nchunks > 0) && (chunk_nbytes > chunksize)) {
     BLOSC_TRACE_ERROR("Appending chunks with a larger chunksize than frame is "
                       "not allowed yet %d != %d.", chunk_nbytes, chunksize);
     return NULL;
   }
 
   // Check that we are not appending a small chunk after another small chunk
   int32_t chunk_nbytes_last;
   if (chunksize == 0 && (nchunks > 0) && (chunk_nbytes < chunksize)) {
     uint8_t* last_chunk;
     bool needs_free;
     rc = frame_get_lazychunk(frame, nchunks - 1, &last_chunk, &needs_free);
     if (rc < 0) {
       BLOSC_TRACE_ERROR("Cannot get the last chunk (in position %" PRId64 ").", nchunks - 1);
     } else {
       rc = blosc2_cbuffer_sizes(last_chunk, &chunk_nbytes_last, NULL, NULL);
     }
     if (needs_free) {
       free(last_chunk);
     }
     if (rc < 0) {
       return NULL;
     }
     if ((chunk_nbytes_last < chunksize) && (nbytes < chunksize)) {
       BLOSC_TRACE_ERROR("Appending two consecutive chunks with a chunksize smaller "
                         "than the frame chunksize is not allowed yet: %d != %d.",
                         chunk_nbytes, chunksize);
       return NULL;
     }
   }
 
   // Get the current offsets and add one more
   int32_t off_nbytes = (int32_t) ((nchunks + 1) * sizeof(int64_t));
   int64_t* offsets = (int64_t *) malloc((size_t)off_nbytes);
   if (nchunks > 0) {
     int32_t coffsets_cbytes;
     uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, nchunks, &coffsets_cbytes);
     if (coffsets == NULL) {
       BLOSC_TRACE_ERROR("Cannot get the offsets for the frame.");
       free(offsets);
       return NULL;
     }
     if (coffsets_cbytes == 0) {
       coffsets_cbytes = (int32_t)cbytes;
     }
 
     // Decompress offsets
     blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;
     blosc2_context *dctx = blosc2_create_dctx(off_dparams);
+    if (dctx == NULL) {
+      BLOSC_TRACE_ERROR("Error while creating the decompression context");
+      return NULL;
+    }
     int32_t prev_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes, offsets,
                                                 off_nbytes);
     blosc2_free_ctx(dctx);
     if (prev_nbytes < 0) {
       free(offsets);
       BLOSC_TRACE_ERROR("Cannot decompress the offsets chunk.");
       return NULL;
     }
   }
 
   // Add the new offset
   int64_t sframe_chunk_id = -1;
   int special_value = (chunk_[BLOSC2_CHUNK_BLOSC2_FLAGS] >> 4) & BLOSC2_SPECIAL_MASK;
   uint64_t offset_value = ((uint64_t)1 << 63);
   switch (special_value) {
     case BLOSC2_SPECIAL_ZERO:
       // Zero chunk.  Code it in a special way.
       offset_value += (uint64_t) BLOSC2_SPECIAL_ZERO << (8 * 7);  // chunk of zeros
       to_little(offsets + nchunks, &offset_value, sizeof(uint64_t));
       chunk_cbytes = 0;   // we don't need to store the chunk
       break;
     case BLOSC2_SPECIAL_UNINIT:
       // Non initizalized values chunk.  Code it in a special way.
       offset_value += (uint64_t) BLOSC2_SPECIAL_UNINIT << (8 * 7);  // chunk of uninit values
       to_little(offsets + nchunks, &offset_value, sizeof(uint64_t));
       chunk_cbytes = 0;   // we don't need to store the chunk
       break;
     case BLOSC2_SPECIAL_NAN:
       // NaN chunk.  Code it in a special way.
       offset_value += (uint64_t)BLOSC2_SPECIAL_NAN << (8 * 7);  // chunk of NANs
       to_little(offsets + nchunks, &offset_value, sizeof(uint64_t));
       chunk_cbytes = 0;   // we don't need to store the chunk
       break;
     default:
       if (frame->sframe) {
         // Compute the sframe_chunk_id value
         for (int i = 0; i < nchunks; ++i) {
           if (offsets[i] > sframe_chunk_id) {
             sframe_chunk_id = offsets[i];
           }
         }
         offsets[nchunks] = ++sframe_chunk_id;
       }
       else {
         offsets[nchunks] = cbytes;
       }
   }
 
   // Re-compress the offsets again
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   cparams.splitmode = BLOSC_NEVER_SPLIT;
   cparams.typesize = sizeof(int64_t);
   cparams.blocksize = 16 * 1024;  // based on experiments with create_frame.c bench
   cparams.nthreads = 4;  // 4 threads seems a decent default for nowadays CPUs
   cparams.compcode = BLOSC_BLOSCLZ;
   blosc2_context* cctx = blosc2_create_cctx(cparams);
+  if (cctx == NULL) {
+    BLOSC_TRACE_ERROR("Error while creating the compression context");
+    return NULL;
+  }
   cctx->typesize = sizeof(int64_t);  // override a possible BLOSC_TYPESIZE env variable (or chaos may appear)
   void* off_chunk = malloc((size_t)off_nbytes + BLOSC2_MAX_OVERHEAD);
   int32_t new_off_cbytes = blosc2_compress_ctx(cctx, offsets, off_nbytes,
                                                off_chunk, off_nbytes + BLOSC2_MAX_OVERHEAD);
   blosc2_free_ctx(cctx);
   free(offsets);
   if (new_off_cbytes < 0) {
     free(off_chunk);
     return NULL;
   }
   // printf("%f\n", (double) off_nbytes / new_off_cbytes);
 
   int64_t new_cbytes = cbytes + chunk_cbytes;
   int64_t new_frame_len;
   if (frame->sframe) {
     new_frame_len = header_len + 0 + new_off_cbytes + frame->trailer_len;
   }
   else {
     new_frame_len = header_len + new_cbytes + new_off_cbytes + frame->trailer_len;
   }
 
   void* fp = NULL;
   if (frame->cframe != NULL) {
     uint8_t* framep = frame->cframe;
     /* Make space for the new chunk and copy it */
     frame->cframe = framep = realloc(framep, (size_t)new_frame_len);
     if (framep == NULL) {
       BLOSC_TRACE_ERROR("Cannot realloc space for the frame.");
       return NULL;
     }
     /* Copy the chunk */
     memcpy(framep + header_len + cbytes, chunk, (size_t)chunk_cbytes);
     /* Copy the offsets */
     memcpy(framep + header_len + new_cbytes, off_chunk, (size_t)new_off_cbytes);
   }
   else {
     int64_t wbytes;
     blosc2_io_cb *io_cb = blosc2_get_io_cb(frame->schunk->storage->io->id);
     if (io_cb == NULL) {
       BLOSC_TRACE_ERROR("Error getting the input/output API");
       return NULL;
     }
 
     if (frame->sframe) {
       // Update the offsets chunk in the chunks frame
       if (chunk_cbytes != 0) {
         if (sframe_chunk_id < 0) {
           BLOSC_TRACE_ERROR("The chunk id (%" PRId64 ") is not correct", sframe_chunk_id);
           return NULL;
         }
         if (sframe_create_chunk(frame, chunk, sframe_chunk_id, chunk_cbytes) == NULL) {
           BLOSC_TRACE_ERROR("Cannot write the full chunk.");
           return NULL;
         }
       }
       fp = sframe_open_index(frame->urlpath, "rb+",
                              frame->schunk->storage->io);
       if (fp == NULL) {
         BLOSC_TRACE_ERROR("Error opening file in: %s", frame->urlpath);
         return NULL;
       }
       io_cb->seek(fp, frame->file_offset + header_len, SEEK_SET);
     }
     else {
       // Regular frame
       fp = io_cb->open(frame->urlpath, "rb+", frame->schunk->storage->io->params);
       if (fp == NULL) {
         BLOSC_TRACE_ERROR("Error opening file in: %s", frame->urlpath);
         return NULL;
       }
       io_cb->seek(fp, frame->file_offset + header_len + cbytes, SEEK_SET);
       wbytes = io_cb->write(chunk, 1, chunk_cbytes, fp);  // the new chunk
       if (wbytes != chunk_cbytes) {
         BLOSC_TRACE_ERROR("Cannot write the full chunk to frame.");
         io_cb->close(fp);
         return NULL;
       }
     }
     wbytes = io_cb->write(off_chunk, 1, new_off_cbytes, fp);  // the new offsets
     io_cb->close(fp);
     if (wbytes != new_off_cbytes) {
       BLOSC_TRACE_ERROR("Cannot write the offsets to frame.");
       return NULL;
     }
   }
   // Invalidate the cache for chunk offsets
   if (frame->coffsets != NULL) {
     free(frame->coffsets);
     frame->coffsets = NULL;
   }
   free(chunk);  // chunk has always to be a copy when reaching here...
   free(off_chunk);
 
   frame->len = new_frame_len;
   rc = frame_update_header(frame, schunk, false);
   if (rc < 0) {
     return NULL;
   }
 
   rc = frame_update_trailer(frame, schunk);
   if (rc < 0) {
     return NULL;
   }
 
   return frame;
 }
@@ -2791,208 +2819,216 @@ void* frame_append_chunk(blosc2_frame_s* frame, void* chunk, blosc2_schunk* schu
 void* frame_insert_chunk(blosc2_frame_s* frame, int64_t nchunk, void* chunk, blosc2_schunk* schunk) {
   uint8_t* chunk_ = chunk;
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t blocksize;
   int32_t chunksize;
   int64_t nchunks;
   int rc = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes,
                            &blocksize, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                            frame->schunk->storage->io);
   if (rc < 0) {
     BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
     return NULL;
   }
   int32_t chunk_cbytes;
   rc = blosc2_cbuffer_sizes(chunk_, NULL, &chunk_cbytes, NULL);
   if (rc < 0) {
     return NULL;
   }
 
   // Get the current offsets
   int32_t off_nbytes = (int32_t) ((nchunks + 1) * sizeof(int64_t));
   int64_t* offsets = (int64_t *) malloc((size_t)off_nbytes);
   if (nchunks > 0) {
     int32_t coffsets_cbytes = 0;
     uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, nchunks, &coffsets_cbytes);
     if (coffsets == NULL) {
       BLOSC_TRACE_ERROR("Cannot get the offsets for the frame.");
       return NULL;
     }
     if (coffsets_cbytes == 0) {
       coffsets_cbytes = (int32_t)cbytes;
     }
 
     // Decompress offsets
     blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;
     blosc2_context *dctx = blosc2_create_dctx(off_dparams);
+    if (dctx == NULL) {
+      BLOSC_TRACE_ERROR("Error while creating the decompression context");
+      return NULL;
+    }
     int32_t prev_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes, offsets, off_nbytes);
     blosc2_free_ctx(dctx);
     if (prev_nbytes < 0) {
       free(offsets);
       BLOSC_TRACE_ERROR("Cannot decompress the offsets chunk.");
       return NULL;
     }
   }
 
   // TODO: Improvement: Check if new chunk is smaller than previous one
 
   // Move offsets
   for (int64_t i = nchunks; i > nchunk; i--) {
     offsets[i] = offsets[i - 1];
   }
   // Add the new offset
   int64_t sframe_chunk_id = -1;
   int special_value = (chunk_[BLOSC2_CHUNK_BLOSC2_FLAGS] >> 4) & BLOSC2_SPECIAL_MASK;
   uint64_t offset_value = ((uint64_t)1 << 63);
   switch (special_value) {
     case BLOSC2_SPECIAL_ZERO:
       // Zero chunk.  Code it in a special way.
       offset_value += (uint64_t)BLOSC2_SPECIAL_ZERO << (8 * 7);  // indicate a chunk of zeros
       to_little(offsets + nchunk, &offset_value, sizeof(uint64_t));
       chunk_cbytes = 0;   // we don't need to store the chunk
       break;
     case BLOSC2_SPECIAL_UNINIT:
       // Non initizalized values chunk.  Code it in a special way.
       offset_value += (uint64_t) BLOSC2_SPECIAL_UNINIT << (8 * 7);  // chunk of uninit values
       to_little(offsets + nchunk, &offset_value, sizeof(uint64_t));
       chunk_cbytes = 0;   // we don't need to store the chunk
       break;
     case BLOSC2_SPECIAL_NAN:
       // NaN chunk.  Code it in a special way.
       offset_value += (uint64_t)BLOSC2_SPECIAL_NAN << (8 * 7);  // indicate a chunk of NANs
       to_little(offsets + nchunk, &offset_value, sizeof(uint64_t));
       chunk_cbytes = 0;   // we don't need to store the chunk
       break;
     default:
       if (frame->sframe) {
         for (int i = 0; i <= nchunks; ++i) {
           // offsets[nchunk] is still uninitialized here
           if (i != nchunk && offsets[i] > sframe_chunk_id) {
             sframe_chunk_id = offsets[i];
           }
         }
         offsets[nchunk] = ++sframe_chunk_id;
       }
       else {
         offsets[nchunk] = cbytes;
       }
   }
 
   // Re-compress the offsets again
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   cparams.splitmode = BLOSC_NEVER_SPLIT;
   cparams.typesize = sizeof(int64_t);
   cparams.blocksize = 16 * 1024;  // based on experiments with create_frame.c bench
   cparams.nthreads = 4;  // 4 threads seems a decent default for nowadays CPUs
   cparams.compcode = BLOSC_BLOSCLZ;
   blosc2_context* cctx = blosc2_create_cctx(cparams);
+  if (cctx == NULL) {
+    BLOSC_TRACE_ERROR("Error while creating the compression context");
+    return NULL;
+  }
   void* off_chunk = malloc((size_t)off_nbytes + BLOSC2_MAX_OVERHEAD);
   int32_t new_off_cbytes = blosc2_compress_ctx(cctx, offsets, off_nbytes,
                                                off_chunk, off_nbytes + BLOSC2_MAX_OVERHEAD);
   blosc2_free_ctx(cctx);
 
   free(offsets);
   if (new_off_cbytes < 0) {
     free(off_chunk);
     return NULL;
   }
 
   int64_t new_cbytes = cbytes + chunk_cbytes;
 
   int64_t new_frame_len;
   if (frame->sframe) {
     new_frame_len = header_len + 0 + new_off_cbytes + frame->trailer_len;
   }
   else {
     new_frame_len = header_len + new_cbytes + new_off_cbytes + frame->trailer_len;
   }
 
   // Add the chunk and update meta
   void* fp = NULL;
   if (frame->cframe != NULL) {
     uint8_t* framep = frame->cframe;
     /* Make space for the new chunk and copy it */
     frame->cframe = framep = realloc(framep, (size_t)new_frame_len);
     if (framep == NULL) {
       BLOSC_TRACE_ERROR("Cannot realloc space for the frame.");
       return NULL;
     }
     /* Copy the chunk */
     memcpy(framep + header_len + cbytes, chunk, (size_t)chunk_cbytes);
     /* Copy the offsets */
     memcpy(framep + header_len + new_cbytes, off_chunk, (size_t)new_off_cbytes);
   } else {
     int64_t wbytes;
 
     blosc2_io_cb *io_cb = blosc2_get_io_cb(frame->schunk->storage->io->id);
     if (io_cb == NULL) {
       BLOSC_TRACE_ERROR("Error getting the input/output API");
       return NULL;
     }
 
     if (frame->sframe) {
       if (chunk_cbytes != 0) {
         if (sframe_chunk_id < 0) {
           BLOSC_TRACE_ERROR("The chunk id (%" PRId64 ") is not correct", sframe_chunk_id);
           return NULL;
         }
         if (sframe_create_chunk(frame, chunk, sframe_chunk_id, chunk_cbytes) == NULL) {
           BLOSC_TRACE_ERROR("Cannot write the full chunk.");
           return NULL;
         }
       }
       // Update the offsets chunk in the chunks frame
       fp = sframe_open_index(frame->urlpath, "rb+",
                              frame->schunk->storage->io);
       if (fp == NULL) {
         BLOSC_TRACE_ERROR("Error opening file in: %s", frame->urlpath);
         return NULL;
       }
       io_cb->seek(fp, frame->file_offset + header_len + 0, SEEK_SET);
     }
     else {
       // Regular frame
       fp = io_cb->open(frame->urlpath, "rb+", frame->schunk->storage->io->params);
       if (fp == NULL) {
         BLOSC_TRACE_ERROR("Error opening file in: %s", frame->urlpath);
         return NULL;
       }
       io_cb->seek(fp, frame->file_offset + header_len + cbytes, SEEK_SET);
       wbytes = io_cb->write(chunk, 1, chunk_cbytes, fp);  // the new chunk
       if (wbytes != chunk_cbytes) {
         BLOSC_TRACE_ERROR("Cannot write the full chunk to frame.");
         io_cb->close(fp);
         return NULL;
       }
     }
     wbytes = io_cb->write(off_chunk, 1, new_off_cbytes, fp);  // the new offsets
     io_cb->close(fp);
     if (wbytes != new_off_cbytes) {
       BLOSC_TRACE_ERROR("Cannot write the offsets to frame.");
       return NULL;
     }
     // Invalidate the cache for chunk offsets
     if (frame->coffsets != NULL) {
       free(frame->coffsets);
       frame->coffsets = NULL;
     }
   }
   free(chunk);  // chunk has always to be a copy when reaching here...
   free(off_chunk);
 
   frame->len = new_frame_len;
   rc = frame_update_header(frame, schunk, false);
   if (rc < 0) {
     return NULL;
   }
 
   rc = frame_update_trailer(frame, schunk);
   if (rc < 0) {
     return NULL;
   }
 
   return frame;
 }
@@ -3001,245 +3037,253 @@ void* frame_insert_chunk(blosc2_frame_s* frame, int64_t nchunk, void* chunk, blo
 void* frame_update_chunk(blosc2_frame_s* frame, int64_t nchunk, void* chunk, blosc2_schunk* schunk) {
   uint8_t *chunk_ = (uint8_t *) chunk;
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t blocksize;
   int32_t chunksize;
   int64_t nchunks;
   int rc = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes,
                            &blocksize, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                            frame->schunk->storage->io);
   if (rc < 0) {
     BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
     return NULL;
   }
   if (nchunk >= nchunks) {
     BLOSC_TRACE_ERROR("The chunk must already exist.");
     return NULL;
   }
 
   int32_t chunk_cbytes;
   rc = blosc2_cbuffer_sizes(chunk, NULL, &chunk_cbytes, NULL);
   if (rc < 0) {
     return NULL;
   }
 
   // Get the current offsets
   int32_t off_nbytes = (int32_t) (nchunks * sizeof(int64_t));
   int64_t* offsets = (int64_t *) malloc((size_t)off_nbytes);
   if (nchunks > 0) {
     int32_t coffsets_cbytes = 0;
     uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, nchunks, &coffsets_cbytes);
     if (coffsets == NULL) {
       BLOSC_TRACE_ERROR("Cannot get the offsets for the frame.");
       return NULL;
     }
     if (coffsets_cbytes == 0) {
       coffsets_cbytes = (int32_t)cbytes;
     }
 
     // Decompress offsets
     blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;
     blosc2_context *dctx = blosc2_create_dctx(off_dparams);
+    if (dctx == NULL) {
+      BLOSC_TRACE_ERROR("Error while creating the decompression context");
+      return NULL;
+    }
     int32_t prev_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes, offsets, off_nbytes);
     blosc2_free_ctx(dctx);
     if (prev_nbytes < 0) {
       free(offsets);
       BLOSC_TRACE_ERROR("Cannot decompress the offsets chunk.");
       return NULL;
     }
   }
   int32_t cbytes_old;
   int64_t old_offset;
   if (!frame->sframe) {
     // See how big would be the space
     old_offset = offsets[nchunk];
     bool needs_free;
     uint8_t *chunk_old;
     int err = blosc2_schunk_get_chunk(schunk, nchunk, &chunk_old, &needs_free);
     if (err < 0) {
       BLOSC_TRACE_ERROR("%" PRId64 " chunk can not be obtained from schunk.", nchunk);
       return NULL;
     }
 
     if (chunk_old == NULL) {
       cbytes_old = 0;
     }
     else {
       cbytes_old = sw32_(chunk_old + BLOSC2_CHUNK_CBYTES);
       if (cbytes_old == BLOSC2_MAX_OVERHEAD) {
         cbytes_old = 0;
       }
     }
     if (needs_free) {
       free(chunk_old);
     }
   }
 
   // Add the new offset
   int64_t sframe_chunk_id;
   if (frame->sframe) {
     if (offsets[nchunk] < 0) {
       sframe_chunk_id = -1;
     }
     else {
       // In case there was a reorder in a sframe
       sframe_chunk_id = offsets[nchunk];
     }
   }
   int special_value = (chunk_[BLOSC2_CHUNK_BLOSC2_FLAGS] >> 4) & BLOSC2_SPECIAL_MASK;
   uint64_t offset_value = ((uint64_t)1 << 63);
   switch (special_value) {
     case BLOSC2_SPECIAL_ZERO:
       // Zero chunk.  Code it in a special way.
       offset_value += (uint64_t)BLOSC2_SPECIAL_ZERO << (8 * 7);  // indicate a chunk of zeros
       to_little(offsets + nchunk, &offset_value, sizeof(uint64_t));
       chunk_cbytes = 0;   // we don't need to store the chunk
       break;
     case BLOSC2_SPECIAL_UNINIT:
       // Non initizalized values chunk.  Code it in a special way.
       offset_value += (uint64_t)BLOSC2_SPECIAL_UNINIT << (8 * 7);  // indicate a chunk of uninit values
       to_little(offsets + nchunk, &offset_value, sizeof(uint64_t));
       chunk_cbytes = 0;   // we don't need to store the chunk
       break;
     case BLOSC2_SPECIAL_NAN:
       // NaN chunk.  Code it in a special way.
       offset_value += (uint64_t)BLOSC2_SPECIAL_NAN << (8 * 7);  // indicate a chunk of NANs
       to_little(offsets + nchunk, &offset_value, sizeof(uint64_t));
       chunk_cbytes = 0;   // we don't need to store the chunk
       break;
     default:
       if (frame->sframe) {
         if (sframe_chunk_id < 0) {
           for (int i = 0; i < nchunks; ++i) {
             if (offsets[i] > sframe_chunk_id) {
               sframe_chunk_id = offsets[i];
             }
           }
           offsets[nchunk] = ++sframe_chunk_id;
         }
       }
       else {
         // Add the new offset
         offsets[nchunk] = cbytes;
       }
   }
 
   if (!frame->sframe && chunk_cbytes != 0 && cbytes_old >= chunk_cbytes) {
     offsets[nchunk] = old_offset;
     cbytes = old_offset;
   }
   // Re-compress the offsets again
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   cparams.splitmode = BLOSC_NEVER_SPLIT;
   cparams.typesize = sizeof(int64_t);
   cparams.blocksize = 16 * 1024;  // based on experiments with create_frame.c bench
   cparams.nthreads = 4;  // 4 threads seems a decent default for nowadays CPUs
   cparams.compcode = BLOSC_BLOSCLZ;
   blosc2_context* cctx = blosc2_create_cctx(cparams);
+  if (cctx == NULL) {
+    BLOSC_TRACE_ERROR("Error while creating the compression context");
+    return NULL;
+  }
   void* off_chunk = malloc((size_t)off_nbytes + BLOSC2_MAX_OVERHEAD);
   int32_t new_off_cbytes = blosc2_compress_ctx(cctx, offsets, off_nbytes,
                                                off_chunk, off_nbytes + BLOSC2_MAX_OVERHEAD);
   blosc2_free_ctx(cctx);
 
   free(offsets);
   if (new_off_cbytes < 0) {
     free(off_chunk);
     return NULL;
   }
 
   int64_t new_cbytes = schunk->cbytes;
   int64_t new_frame_len;
   if (frame->sframe) {
     // The chunk is not stored in the frame
     new_frame_len = header_len + 0 + new_off_cbytes + frame->trailer_len;
   }
   else {
     new_frame_len = header_len + new_cbytes + new_off_cbytes + frame->trailer_len;
   }
 
   void* fp = NULL;
   if (frame->cframe != NULL) {
     uint8_t* framep = frame->cframe;
     /* Make space for the new chunk and copy it */
     frame->cframe = framep = realloc(framep, (size_t)new_frame_len);
     if (framep == NULL) {
       BLOSC_TRACE_ERROR("Cannot realloc space for the frame.");
       return NULL;
     }
     /* Copy the chunk */
     memcpy(framep + header_len + cbytes, chunk, (size_t)chunk_cbytes);
     /* Copy the offsets */
     memcpy(framep + header_len + new_cbytes, off_chunk, (size_t)new_off_cbytes);
   } else {
     int64_t wbytes;
 
     blosc2_io_cb *io_cb = blosc2_get_io_cb(frame->schunk->storage->io->id);
     if (io_cb == NULL) {
       BLOSC_TRACE_ERROR("Error getting the input/output API");
       return NULL;
     }
 
     if (frame->sframe) {
       // Create the chunks file, if it's a special value this will delete its old content
       if (sframe_chunk_id >= 0) {
         if (sframe_create_chunk(frame, chunk, sframe_chunk_id, chunk_cbytes) == NULL) {
           BLOSC_TRACE_ERROR("Cannot write the full chunk.");
           return NULL;
         }
       }
       // Update the offsets chunk in the chunks frame
       fp = sframe_open_index(frame->urlpath, "rb+",
                              frame->schunk->storage->io);
       if (fp == NULL) {
         BLOSC_TRACE_ERROR("Error opening file in: %s", frame->urlpath);
         return NULL;
       }
       io_cb->seek(fp, frame->file_offset + header_len + 0, SEEK_SET);
     }
     else {
       // Regular frame
       fp = io_cb->open(frame->urlpath, "rb+", frame->schunk->storage->io->params);
       if (fp == NULL) {
         BLOSC_TRACE_ERROR("Error opening file in: %s", frame->urlpath);
         return NULL;
       }
       io_cb->seek(fp, frame->file_offset + header_len + cbytes, SEEK_SET);
       wbytes = io_cb->write(chunk, 1, chunk_cbytes, fp);  // the new chunk
       if (wbytes != chunk_cbytes) {
         BLOSC_TRACE_ERROR("Cannot write the full chunk to frame.");
         io_cb->close(fp);
         return NULL;
       }
       io_cb->seek(fp, frame->file_offset + header_len + new_cbytes, SEEK_SET);
     }
     wbytes = io_cb->write(off_chunk, 1, new_off_cbytes, fp);  // the new offsets
     io_cb->close(fp);
     if (wbytes != new_off_cbytes) {
       BLOSC_TRACE_ERROR("Cannot write the offsets to frame.");
       return NULL;
     }
     // Invalidate the cache for chunk offsets
     if (frame->coffsets != NULL) {
       free(frame->coffsets);
       frame->coffsets = NULL;
     }
   }
   free(chunk);  // chunk has always to be a copy when reaching here...
   free(off_chunk);
 
   frame->len = new_frame_len;
   rc = frame_update_header(frame, schunk, false);
   if (rc < 0) {
     return NULL;
   }
 
   rc = frame_update_trailer(frame, schunk);
   if (rc < 0) {
     return NULL;
   }
 
   return frame;
 }
@@ -3248,156 +3292,164 @@ void* frame_update_chunk(blosc2_frame_s* frame, int64_t nchunk, void* chunk, blo
 void* frame_delete_chunk(blosc2_frame_s* frame, int64_t nchunk, blosc2_schunk* schunk) {
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t blocksize;
   int32_t chunksize;
   int64_t nchunks;
   int rc = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes,
                            &blocksize, &chunksize,  &nchunks,
                            NULL, NULL, NULL, NULL, NULL, NULL, NULL, frame->schunk->storage->io);
   if (rc < 0) {
     BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
     return NULL;
   }
 
   // Get the current offsets
   int32_t off_nbytes = (int32_t) (nchunks * sizeof(int64_t));
   int64_t* offsets = (int64_t *) malloc((size_t)off_nbytes);
   if (nchunks > 0) {
     int32_t coffsets_cbytes = 0;
     uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, nchunks, &coffsets_cbytes);
     if (coffsets == NULL) {
       BLOSC_TRACE_ERROR("Cannot get the offsets for the frame.");
       return NULL;
     }
     if (coffsets_cbytes == 0) {
       coffsets_cbytes = (int32_t)cbytes;
     }
 
     // Decompress offsets
     blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;
     blosc2_context *dctx = blosc2_create_dctx(off_dparams);
+    if (dctx == NULL) {
+      BLOSC_TRACE_ERROR("Error while creating the decompression context");
+      return NULL;
+    }
     int32_t prev_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes, offsets, off_nbytes);
     blosc2_free_ctx(dctx);
     if (prev_nbytes < 0) {
       free(offsets);
       BLOSC_TRACE_ERROR("Cannot decompress the offsets chunk.");
       return NULL;
     }
   }
 
   // Delete the new offset
   for (int64_t i = nchunk; i < nchunks - 1; i++) {
     offsets[i] = offsets[i + 1];
   }
   offsets[nchunks - 1] = 0;
 
   // Re-compress the offsets again
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   cparams.splitmode = BLOSC_NEVER_SPLIT;
   cparams.typesize = sizeof(int64_t);
   cparams.blocksize = 16 * 1024;  // based on experiments with create_frame.c bench
   cparams.nthreads = 4;  // 4 threads seems a decent default for nowadays CPUs
   cparams.compcode = BLOSC_BLOSCLZ;
   blosc2_context* cctx = blosc2_create_cctx(cparams);
+  if (cctx == NULL) {
+    BLOSC_TRACE_ERROR("Error while creating the compression context");
+    return NULL;
+  }
   void* off_chunk = malloc((size_t)off_nbytes + BLOSC2_MAX_OVERHEAD);
   int32_t new_off_cbytes = blosc2_compress_ctx(cctx, offsets, off_nbytes - (int32_t)sizeof(int64_t),
                                                off_chunk, off_nbytes + BLOSC2_MAX_OVERHEAD);
   blosc2_free_ctx(cctx);
 
   free(offsets);
   if (new_off_cbytes < 0) {
     free(off_chunk);
     return NULL;
   }
 
   int64_t new_cbytes = cbytes;
 
   int64_t new_frame_len;
   if (frame->sframe) {
     new_frame_len = header_len + 0 + new_off_cbytes + frame->trailer_len;
   }
   else {
     new_frame_len = header_len + new_cbytes + new_off_cbytes + frame->trailer_len;
   }
 
   // Add the chunk and update meta
   FILE* fp = NULL;
   if (frame->cframe != NULL) {
     uint8_t* framep = frame->cframe;
     /* Make space for the new chunk and copy it */
     frame->cframe = framep = realloc(framep, (size_t)new_frame_len);
     if (framep == NULL) {
       BLOSC_TRACE_ERROR("Cannot realloc space for the frame.");
       return NULL;
     }
     /* Copy the offsets */
     memcpy(framep + header_len + new_cbytes, off_chunk, (size_t)new_off_cbytes);
   } else {
     blosc2_io_cb *io_cb = blosc2_get_io_cb(frame->schunk->storage->io->id);
     if (io_cb == NULL) {
       BLOSC_TRACE_ERROR("Error getting the input/output API");
       return NULL;
     }
 
     size_t wbytes;
     if (frame->sframe) {
       int64_t offset;
       rc = get_coffset(frame, header_len, cbytes, nchunk, nchunks, &offset);
       if (rc < 0) {
         BLOSC_TRACE_ERROR("Unable to get offset to chunk %" PRId64 ".", nchunk);
         return NULL;
       }
       if (offset >= 0){
         // Remove the chunk file only if it is not a special value chunk
         int err = sframe_delete_chunk(frame->urlpath, offset);
         if (err != 0) {
           BLOSC_TRACE_ERROR("Unable to delete chunk!");
           return NULL;
         }
       }
       // Update the offsets chunk in the chunks frame
       fp = sframe_open_index(frame->urlpath, "rb+", frame->schunk->storage->io);
       if (fp == NULL) {
         BLOSC_TRACE_ERROR("Error opening file in: %s", frame->urlpath);
         return NULL;
       }
       io_cb->seek(fp, frame->file_offset + header_len + 0, SEEK_SET);
     }
     else {
       // Regular frame
       fp = io_cb->open(frame->urlpath, "rb+", frame->schunk->storage->io);
       if (fp == NULL) {
         BLOSC_TRACE_ERROR("Error opening file in: %s", frame->urlpath);
         return NULL;
       }
       io_cb->seek(fp, frame->file_offset + header_len + cbytes, SEEK_SET);
     }
     wbytes = io_cb->write(off_chunk, 1, new_off_cbytes, fp);  // the new offsets
     io_cb->close(fp);
     if (wbytes != (size_t)new_off_cbytes) {
       BLOSC_TRACE_ERROR("Cannot write the offsets to frame.");
       return NULL;
     }
     // Invalidate the cache for chunk offsets
     if (frame->coffsets != NULL) {
       free(frame->coffsets);
       frame->coffsets = NULL;
     }
   }
   free(off_chunk);
 
   frame->len = new_frame_len;
   rc = frame_update_header(frame, schunk, false);
   if (rc < 0) {
     return NULL;
   }
 
   rc = frame_update_trailer(frame, schunk);
   if (rc < 0) {
     return NULL;
   }
 
   return frame;
 }
@@ -3406,149 +3458,157 @@ void* frame_delete_chunk(blosc2_frame_s* frame, int64_t nchunk, blosc2_schunk* s
 int frame_reorder_offsets(blosc2_frame_s* frame, const int64_t* offsets_order, blosc2_schunk* schunk) {
   // Get header info
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t blocksize;
   int32_t chunksize;
   int64_t nchunks;
   int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes,
                             &blocksize, &chunksize, &nchunks,
                             NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                             frame->schunk->storage->io);
   if (ret < 0) {
       BLOSC_TRACE_ERROR("Cannot get the header info for the frame.");
       return ret;
   }
 
   // Get the current offsets and add one more
   int32_t off_nbytes = (int32_t) (nchunks * sizeof(int64_t));
   int64_t* offsets = (int64_t *) malloc((size_t)off_nbytes);
 
   int32_t coffsets_cbytes = 0;
   uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, nchunks, &coffsets_cbytes);
   if (coffsets == NULL) {
     BLOSC_TRACE_ERROR("Cannot get the offsets for the frame.");
     free(offsets);
     return BLOSC2_ERROR_DATA;
   }
 
   // Decompress offsets
   blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_context *dctx = blosc2_create_dctx(off_dparams);
+  if (dctx == NULL) {
+    BLOSC_TRACE_ERROR("Error while creating the decompression context");
+    return BLOSC2_ERROR_NULL_POINTER;
+  }
   int32_t prev_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes,
                                               offsets, off_nbytes);
   blosc2_free_ctx(dctx);
   if (prev_nbytes < 0) {
     free(offsets);
     BLOSC_TRACE_ERROR("Cannot decompress the offsets chunk.");
     return prev_nbytes;
   }
 
   // Make a copy of the chunk offsets and reorder it
   int64_t *offsets_copy = malloc(prev_nbytes);
   memcpy(offsets_copy, offsets, prev_nbytes);
 
   for (int i = 0; i < nchunks; ++i) {
     offsets[i] = offsets_copy[offsets_order[i]];
   }
   free(offsets_copy);
 
   // Re-compress the offsets again
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   cparams.splitmode = BLOSC_NEVER_SPLIT;
   cparams.typesize = sizeof(int64_t);
   cparams.blocksize = 16 * 1024;  // based on experiments with create_frame.c bench
   cparams.nthreads = 4;  // 4 threads seems a decent default for nowadays CPUs
   cparams.compcode = BLOSC_BLOSCLZ;
   blosc2_context* cctx = blosc2_create_cctx(cparams);
+  if (cctx == NULL) {
+    BLOSC_TRACE_ERROR("Error while creating the compression context");
+    return BLOSC2_ERROR_NULL_POINTER;
+  }
   void* off_chunk = malloc((size_t)off_nbytes + BLOSC2_MAX_OVERHEAD);
   int32_t new_off_cbytes = blosc2_compress_ctx(cctx, offsets, off_nbytes,
                                                off_chunk, off_nbytes + BLOSC2_MAX_OVERHEAD);
   blosc2_free_ctx(cctx);
 
   if (new_off_cbytes < 0) {
     free(offsets);
     free(off_chunk);
     return new_off_cbytes;
   }
   free(offsets);
   int64_t new_frame_len;
   if (frame->sframe) {
     // The chunks are not in the frame
     new_frame_len = header_len + 0 + new_off_cbytes + frame->trailer_len;
   }
   else {
     new_frame_len = header_len + cbytes + new_off_cbytes + frame->trailer_len;
   }
 
   if (frame->cframe != NULL) {
     uint8_t* framep = frame->cframe;
     /* Make space for the new chunk and copy it */
     frame->cframe = framep = realloc(framep, (size_t)new_frame_len);
     if (framep == NULL) {
       BLOSC_TRACE_ERROR("Cannot realloc space for the frame.");
       return BLOSC2_ERROR_MEMORY_ALLOC;
     }
     /* Copy the offsets */
     memcpy(framep + header_len + cbytes, off_chunk, (size_t)new_off_cbytes);
   }
   else {
     void* fp = NULL;
 
     blosc2_io_cb *io_cb = blosc2_get_io_cb(frame->schunk->storage->io->id);
     if (io_cb == NULL) {
       BLOSC_TRACE_ERROR("Error getting the input/output API");
       return BLOSC2_ERROR_PLUGIN_IO;
     }
 
     if (frame->sframe) {
       // Update the offsets chunk in the chunks frame
       fp = sframe_open_index(frame->urlpath, "rb+",
                              frame->schunk->storage->io);
       if (fp == NULL) {
         BLOSC_TRACE_ERROR("Error opening file in: %s", frame->urlpath);
         return BLOSC2_ERROR_FILE_OPEN;
       }
       io_cb->seek(fp, frame->file_offset + header_len + 0, SEEK_SET);
     }
     else {
       // Regular frame
       fp = io_cb->open(frame->urlpath, "rb+", frame->schunk->storage->io->params);
       if (fp == NULL) {
         BLOSC_TRACE_ERROR("Error opening file in: %s", frame->urlpath);
         return BLOSC2_ERROR_FILE_OPEN;
       }
       io_cb->seek(fp, frame->file_offset + header_len + cbytes, SEEK_SET);
     }
     int64_t wbytes = io_cb->write(off_chunk, 1, new_off_cbytes, fp);  // the new offsets
     io_cb->close(fp);
     if (wbytes != new_off_cbytes) {
       BLOSC_TRACE_ERROR("Cannot write the offsets to frame.");
       return BLOSC2_ERROR_FILE_WRITE;
     }
   }
 
   // Invalidate the cache for chunk offsets
   if (frame->coffsets != NULL) {
     free(frame->coffsets);
     frame->coffsets = NULL;
   }
   free(off_chunk);
 
   frame->len = new_frame_len;
   int rc = frame_update_header(frame, schunk, false);
   if (rc < 0) {
     return rc;
   }
 
   rc = frame_update_trailer(frame, schunk);
   if (rc < 0) {
     return rc;
   }
 
   return 0;
 }
 
 
 /* Decompress and return a chunk that is part of a frame. */
diff --git a/blosc/schunk.c b/blosc/schunk.c
index 2a5256a8..20f0bf33 100644
--- a/blosc/schunk.c
+++ b/blosc/schunk.c
@@ -73,39 +73,49 @@ int blosc2_schunk_get_dparams(blosc2_schunk *schunk, blosc2_dparams **dparams) {
 }
 
 
-void update_schunk_properties(struct blosc2_schunk* schunk) {
+int update_schunk_properties(struct blosc2_schunk* schunk) {
   blosc2_cparams* cparams = schunk->storage->cparams;
   blosc2_dparams* dparams = schunk->storage->dparams;
 
   for (int i = 0; i < BLOSC2_MAX_FILTERS; i++) {
     schunk->filters[i] = cparams->filters[i];
     schunk->filters_meta[i] = cparams->filters_meta[i];
   }
   schunk->compcode = cparams->compcode;
   schunk->compcode_meta = cparams->compcode_meta;
   schunk->clevel = cparams->clevel;
   schunk->splitmode = cparams->splitmode;
   schunk->typesize = cparams->typesize;
   schunk->blocksize = cparams->blocksize;
   schunk->chunksize = -1;
   schunk->tuner_params = cparams->tuner_params;
   schunk->tuner_id = cparams->tuner_id;
   if (cparams->tuner_id == BLOSC_BTUNE) {
     cparams->use_dict = 0;
   }
   /* The compression context */
   if (schunk->cctx != NULL) {
     blosc2_free_ctx(schunk->cctx);
   }
   cparams->schunk = schunk;
   schunk->cctx = blosc2_create_cctx(*cparams);
+  if (schunk->cctx == NULL) {
+    BLOSC_TRACE_ERROR("Could not create compression ctx");
+    return BLOSC2_ERROR_NULL_POINTER;
+  }
 
   /* The decompression context */
   if (schunk->dctx != NULL) {
     blosc2_free_ctx(schunk->dctx);
   }
   dparams->schunk = schunk;
   schunk->dctx = blosc2_create_dctx(*dparams);
+  if (schunk->dctx == NULL) {
+    BLOSC_TRACE_ERROR("Could not create decompression ctx");
+    return BLOSC2_ERROR_NULL_POINTER;
+  }
+
+  return BLOSC2_ERROR_SUCCESS;
 }
 
 
@@ -118,70 +128,73 @@ static bool file_exists (char *filename) {
 /* Create a new super-chunk */
 blosc2_schunk* blosc2_schunk_new(blosc2_storage *storage) {
   blosc2_schunk* schunk = calloc(1, sizeof(blosc2_schunk));
   schunk->version = 0;     /* pre-first version */
 
   // Get the storage with proper defaults
   schunk->storage = get_new_storage(storage, &BLOSC2_CPARAMS_DEFAULTS, &BLOSC2_DPARAMS_DEFAULTS, &BLOSC2_IO_DEFAULTS);
   // Update the (local variable) storage
   storage = schunk->storage;
 
   char* tradeoff = getenv("BTUNE_TRADEOFF");
   if (tradeoff != NULL) {
     // If BTUNE_TRADEOFF passed, automatically use btune
     storage->cparams->tuner_id = BLOSC_BTUNE;
   }
 
   // ...and update internal properties
-  update_schunk_properties(schunk);
+  if (update_schunk_properties(schunk) < 0) {
+    BLOSC_TRACE_ERROR("Error when updating schunk properties");
+    return NULL;
+  }
 
   if (!storage->contiguous && storage->urlpath != NULL){
     char* urlpath;
     char last_char = storage->urlpath[strlen(storage->urlpath) - 1];
     urlpath = malloc(strlen(storage->urlpath) + 1);
     strcpy(urlpath, storage->urlpath);
     if (last_char == '\\' || last_char == '/') {
       urlpath[strlen(storage->urlpath) - 1] = '\0';
     }
     // Create directory
     if (mkdir(urlpath, 0777) == -1) {
       BLOSC_TRACE_ERROR("Error during the creation of the directory, maybe it already exists.");
       return NULL;
     }
     // We want a sparse (directory) frame as storage
     blosc2_frame_s* frame = frame_new(urlpath);
     free(urlpath);
     frame->sframe = true;
     // Initialize frame (basically, encode the header)
     frame->schunk = schunk;
     int64_t frame_len = frame_from_schunk(schunk, frame);
     if (frame_len < 0) {
       BLOSC_TRACE_ERROR("Error during the conversion of schunk to frame.");
       return NULL;
     }
     schunk->frame = (blosc2_frame*)frame;
   }
   if (storage->contiguous){
     // We want a contiguous frame as storage
     if (storage->urlpath != NULL) {
       if (file_exists(storage->urlpath)) {
         BLOSC_TRACE_ERROR("You are trying to overwrite an existing frame.  Remove it first!");
         return NULL;
       }
     }
     blosc2_frame_s* frame = frame_new(storage->urlpath);
     frame->sframe = false;
     // Initialize frame (basically, encode the header)
     frame->schunk = schunk;
     int64_t frame_len = frame_from_schunk(schunk, frame);
     if (frame_len < 0) {
       BLOSC_TRACE_ERROR("Error during the conversion of schunk to frame.");
       return NULL;
     }
     schunk->frame = (blosc2_frame*)frame;
   }
 
   return schunk;
 }
 
 
 /* Create a copy of a super-chunk */
@@ -1560,45 +1573,49 @@ int vlmetalayer_flush(blosc2_schunk* schunk) {
 /* Add content into a new variable-length metalayer.
  *
  * If successful, return the index of the new variable-length metalayer.  Else, return a negative value.
  */
 int blosc2_vlmeta_add(blosc2_schunk *schunk, const char *name, uint8_t *content, int32_t content_len,
                       blosc2_cparams *cparams) {
   int nvlmetalayer = blosc2_vlmeta_exists(schunk, name);
   if (nvlmetalayer >= 0) {
     BLOSC_TRACE_ERROR("Variable-length metalayer \"%s\" already exists.", name);
     return BLOSC2_ERROR_INVALID_PARAM;
   }
 
   // Add the vlmetalayer
   blosc2_metalayer *vlmetalayer = malloc(sizeof(blosc2_metalayer));
   vlmetalayer->name = strdup(name);
   uint8_t* content_buf = malloc((size_t) content_len + BLOSC2_MAX_OVERHEAD);
 
   blosc2_context *cctx;
   if (cparams != NULL) {
     cctx = blosc2_create_cctx(*cparams);
   } else {
     cctx = blosc2_create_cctx(BLOSC2_CPARAMS_DEFAULTS);
   }
+  if (cctx == NULL) {
+    BLOSC_TRACE_ERROR("Error while creating the compression context");
+    return BLOSC2_ERROR_NULL_POINTER;
+  }
 
   int csize = blosc2_compress_ctx(cctx, content, content_len, content_buf, content_len + BLOSC2_MAX_OVERHEAD);
   if (csize < 0) {
     BLOSC_TRACE_ERROR("Can not compress the `%s` variable-length metalayer.", name);
     return csize;
   }
   blosc2_free_ctx(cctx);
 
   vlmetalayer->content = realloc(content_buf, csize);
   vlmetalayer->content_len = csize;
   schunk->vlmetalayers[schunk->nvlmetalayers] = vlmetalayer;
   schunk->nvlmetalayers += 1;
 
   // Propagate to frames
   int rc = vlmetalayer_flush(schunk);
   if (rc < 0) {
     BLOSC_TRACE_ERROR("Can not propagate de `%s` variable-length metalayer to a frame.", name);
     return rc;
   }
 
   return schunk->nvlmetalayers - 1;
 }
@@ -1607,25 +1624,29 @@ int blosc2_vlmeta_add(blosc2_schunk *schunk, const char *name, uint8_t *content,
 int blosc2_vlmeta_get(blosc2_schunk *schunk, const char *name, uint8_t **content,
                       int32_t *content_len) {
   int nvlmetalayer = blosc2_vlmeta_exists(schunk, name);
   if (nvlmetalayer < 0) {
     BLOSC_TRACE_ERROR("User metalayer \"%s\" not found.", name);
     return nvlmetalayer;
   }
   blosc2_metalayer *meta = schunk->vlmetalayers[nvlmetalayer];
   int32_t nbytes, cbytes;
   blosc2_cbuffer_sizes(meta->content, &nbytes, &cbytes, NULL);
   if (cbytes != meta->content_len) {
     BLOSC_TRACE_ERROR("User metalayer \"%s\" is corrupted.", meta->name);
     return BLOSC2_ERROR_DATA;
   }
   *content_len = nbytes;
   *content = malloc((size_t) nbytes);
   blosc2_context *dctx = blosc2_create_dctx(*schunk->storage->dparams);
+  if (dctx == NULL) {
+    BLOSC_TRACE_ERROR("Error while creating the decompression context");
+    return BLOSC2_ERROR_NULL_POINTER;
+  }
   int nbytes_ = blosc2_decompress_ctx(dctx, meta->content, meta->content_len, *content, nbytes);
   blosc2_free_ctx(dctx);
   if (nbytes_ != nbytes) {
     BLOSC_TRACE_ERROR("User metalayer \"%s\" is corrupted.", meta->name);
     return BLOSC2_ERROR_READ_BUFFER;
   }
   return nvlmetalayer;
 }
@@ -1633,38 +1654,42 @@ int blosc2_vlmeta_get(blosc2_schunk *schunk, const char *name, uint8_t **content
 int blosc2_vlmeta_update(blosc2_schunk *schunk, const char *name, uint8_t *content, int32_t content_len,
                          blosc2_cparams *cparams) {
   int nvlmetalayer = blosc2_vlmeta_exists(schunk, name);
   if (nvlmetalayer < 0) {
     BLOSC_TRACE_ERROR("User vlmetalayer \"%s\" not found.", name);
     return nvlmetalayer;
   }
 
   blosc2_metalayer *vlmetalayer = schunk->vlmetalayers[nvlmetalayer];
   free(vlmetalayer->content);
   uint8_t* content_buf = malloc((size_t) content_len + BLOSC2_MAX_OVERHEAD);
 
   blosc2_context *cctx;
   if (cparams != NULL) {
     cctx = blosc2_create_cctx(*cparams);
   } else {
     cctx = blosc2_create_cctx(BLOSC2_CPARAMS_DEFAULTS);
   }
+  if (cctx == NULL) {
+    BLOSC_TRACE_ERROR("Error while creating the compression context");
+    return BLOSC2_ERROR_NULL_POINTER;
+  }
 
   int csize = blosc2_compress_ctx(cctx, content, content_len, content_buf, content_len + BLOSC2_MAX_OVERHEAD);
   if (csize < 0) {
     BLOSC_TRACE_ERROR("Can not compress the `%s` variable-length metalayer.", name);
     return csize;
   }
   blosc2_free_ctx(cctx);
 
   vlmetalayer->content = realloc(content_buf, csize);
   vlmetalayer->content_len = csize;
 
   // Propagate to frames
   int rc = vlmetalayer_flush(schunk);
   if (rc < 0) {
     BLOSC_TRACE_ERROR("Can not propagate de `%s` variable-length metalayer to a frame.", name);
     return rc;
   }
 
   return nvlmetalayer;
 }
