commit 589d1f0899343b18c3181f35451550dc1b904bef
Author: Werner Lemberg <wl@gnu.org>
Date:   Mon Jun 25 18:38:04 2018 +0200

    * src/truetype/ttgxvar.c (tt_face_vary_cvt): Add initializers.
    
    Reported as
    
      https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=9070

diff --git a/ChangeLog b/ChangeLog
index f1d7eab05..49325f0f8 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3196 +1,3204 @@
+2018-06-25  Werner Lemberg  <wl@gnu.org>
+
+	* src/truetype/ttgxvar.c (tt_face_vary_cvt): Add initializers.
+
+	Reported as
+
+	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=9070
+
 2018-06-24  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Increase precision while applying VF deltas.
 
 	It turned out that we incorrectly round CVT and glyph point deltas
 	before accumulation, leading to severe positioning errors if there
 	are many delta values to sum up.
 
 	Problem reported by Akiem Helmling <akiem@underware.nl> and analyzed
 	by Behdad.
 
 	* src/truetype/ttgxvar.c (ft_var_readpackeddelta): Return deltas in
 	16.16 format.
 	(tt_face_var_cvt): Collect deltas in `cvt_deltas', which is a 16.16
 	format array, and add the accumulated values to the CVT at the end
 	of the function.
 	(TT_Vary_Apply_Glyph_Deltas): Store data in `points_org' and
 	`points_out' in 16.16 format.
 	Collect deltas in `point_deltas_x' and `point_deltas_y', which are
 	16.16 format arrays, and add the accumulated values to the glyph
 	coordinates at the end of the function.
 
 2018-06-24  Werner Lemberg  <wl@gnu.org>
 
 	New base function `FT_Matrix_Check' (#54019).
 
 	* src/base/ftcalc.c (FT_Matrix_Check): New base function to properly
 	reject degenerate font matrices.
 
 	* include/freetype/internal/ftcalc.h: Updated.
 
 	* src/cff/cffparse.c (cff_parse_font_matrix), src/cid/cidload.c
 	(cid_parse_font_matrix), src/type1/t1load.c (t1_parse_font_matrix),
 	src/type42/t42parse.c (t42_parse_font_matrix): Use
 	`FT_Matrix_Check'.
 
 2018-06-23  Werner Lemberg  <wl@gnu.org>
 
 	Fix typo.
 
 	Reported by Behdad.
 
 	* src/base/ftcolor.c (FT_Palette_Data_Get)
 	[!TT_CONFIG_OPTION_COLOR_LAYERS]: s/apalette/apalette_data/.
 
 2018-06-21  Werner Lemberg  <wl@gnu.org>
 
 	s/FT_PALETTE_USABLE_WITH_/FT_PALETTE_FOR_/.
 
 	* include/freetype/ftcolor.h, include/freetype/internal/sfnt.h,
 	src/sfnt/ttcolr.c: Do it.
 
 2018-06-19  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Fix CPAL heap buffer overflow.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=8968
 
 	* src/sfnt/ttcpal.c (tt_face_load_cpal): Guard CPAL version 1
 	offsets.
 
 2018-06-19  Werner Lemberg  <wl@gnu.org>
 
 	Doh.  Don't use CPAL or COLR data if tables are missing.
 
 	Reported by Alexei.
 
 	* src/sfnt/ttcolr.c (tt_face_get_colr_layer): Return immediately if
 	`colr' is NULL.
 
 	* src/sfnt/ttcpal.c (tt_face_palette_set): Return immediately, if
 	`cpal' is NULL.
 
 2018-06-17  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[base] Introduce `FT_New_Glyph'.
 
 	This function facilitates access to full capabilities of FreeType
 	rendering engine for custom glyphs. This can be quite useful for
 	consistent rendering of mathematical and chemical formulas, e.g.
 
 	  https://bugs.chromium.org/p/chromium/issues/detail?id=757078
 
 	* include/freetype/ftglyph.h, src/base/ftglyph.c (FT_New_Glyph): New
 	function.
 
 2018-06-17  Armin Hasitzka  <prince.cherusker@gmail.com>
 
 	[bdf] Fix underflow of an unsigned value.
 
 	bdflib.c:1562 could be reached with `font->glyphs_used == 0'.  That
 	caused an underflow of the unsigned value which results in undefined
 	behaviour.
 
 	* src/bdf/bdflib.c (_bdf_parse_glyphs): Bail out earlier than before
 	if the `ENCODING' keyword cannot be found.
 
 2018-06-17  Werner Lemberg  <wl@gnu.org>
 
 	[base] Add tracing for `FT_Bitmap_Blend'.
 
 	* include/freetype/internal/fttrace.h (trace_bitmap): New
 	enumeration.
 
 	* src/base/ftbitmap.c (FT_COMPONENT): Define.
 	(FT_Bitmap_Blend): Add `FT_TRACE5' calls.
 
 2018-06-17  Werner Lemberg  <wl@gnu.org>
 
 	s/trace_bitmap/trace_checksum/.
 
 	* include/freetype/internal/fttrace.h: s/bitmap/checksum/.
 
 	* src/base/ftobjs.c (FT_COMPONENT): s/trace_bitmap/trace_checksum/.
 	Adjust code.
 
 2018-06-16  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Fix color glyph layer loading.
 
 	* src/sfnt/ttcolr.c (Colr): Add `table_size' field.
 	(tt_face_load_colr): Set it.
 	(tt_face_get_colr_layer): Check pointer limit for layer entries.
 
 2018-06-16  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Fix color palette loading.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=8933
 
 	* src/sfnt/ttcpal.c (Cpal): Add `table_size' field.
 	(tt_face_load_cpal): Set it.
 	(tt_face_palette_set): Check pointer limit for color entries.
 
 2018-06-16  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftbitmap.c (FT_Bitmap_Blend): Avoid integer overflow.
 
 2018-06-16  Werner Lemberg  <wl@gnu.org>
 
 	Add `FT_Bitmap_Blend' API.
 
 	Still missing: Support for negative bitmap pitch and subpixel offset
 	of source bitmap.
 
 	* include/freetype/ftbitmap.h, src/base/ftbitmap.c
 	(FT_Bitmap_Blend): New function.
 
 2018-06-14  Werner Lemberg  <wl@gnu.org>
 
 	Replace `FT_Get_GlyphLayers' with `FT_Get_Color_Glyph_Layer'.
 
 	This avoids any additional allocation of COLR related structures in
 	a glyph slot.
 
 	* include/freetype/freetype.h (FT_Glyph_Layer, FT_Glyph_LayerRec,
 	FT_Get_GlyphLayers): Removed.
 
 	* include/freetype/internal/ftobjs.h (FT_Colr_InternalRec): Removed.
 	(FT_Slot_InternalRec): Remove `color_layers'.
 
 	* include/freetype/internal/sfnt.h (TT_Load_Colr_Layer_Func):
 	Removed.
 	(SFNT_Interface, FT_DEFINE_SFNT_INTERFACE): Remove
 	`load_colr_layer'.
 
 	* src/base/ftobjs.c (ft_glyph_slot_done): Updated.
 	(FT_Render_Glyph_Internal): Use `FT_Get_Color_Glyph_Layer'.
 	(FT_Get_GlyphLayers): Removed.
 
 	* src/sfnt/sfdriver.c (sfnt_interface): Updated.
 
 	* src/sfnt/ttcolr.c (tt_face_load_colr_layers): Removed.
 	* src/sfnt/ttcolr.h: Updated.
 
 	* src/truetype/ttgload.c (TT_Load_Glyph): Updated.
 
 2018-06-14  Werner Lemberg  <wl@gnu.org>
 
 	Provide iterative API to access `COLR' data.
 
 	This solution doesn't store any data in an `FT_GlyphSlot' object.
 
 	* include/freetype/freetype.h (FT_LayerIterator): New structure.
 	(FT_Get_Color_Glyph_Layer): New function.
 
 	* include/freetype/internal/sfnt.h (TT_Get_Colr_Layer_Func): New
 	function type.
 	(SFNT_Interface, FT_DEFINE_SFNT_INTERFACE): Add it.
 
 	* src/base/ftobjs.c (FT_Get_Color_Glyph_Layer): Implement it.
 
 	* src/sfnt/ttcolr.c (tt_face_get_colr_layer): New function.
 	* src/sfnt/ttcolr.h: Updated.
 
 	* src/sfnt/sfdriver.c (sfnt_interface): Updated.
 
 2018-06-14  Werner Lemberg  <wl@gnu.org>
 
 	Add glyph index and glyph load flags to glyph slot.
 
 	* include/freetype/freetype.h (FT_GlyphSlotRec): Rename unused
 	`reserved' field to `glyph_index'.
 
 	* include/freetype/internal/ftobjs.h (FT_Slot_InternalRec): Add
 	`load_flags' field.
 
 	* src/base/ftobjs.c (FT_Load_Glyph): Set new fields.
 
 2018-06-14  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Move `CPAL' stuff into separate files.
 
 	* src/sfnt/sfdriver.c: Include `ttcpal.h'.
 	* src/sfnt/sfnt.c: Include `ttcpal.c'.
 
 	* src/sfnt/ttcolr.c, src/sfnt/ttcolr.h: Move CPAL stuff to ...
 	* src/sfnt/ttcpal.c, src/sfnt/ttcpal.c: ... these new files.
 
 	* src/sfnt/Jamfile (_sources), src/sfnt/rules.mk (SFNT_DRV_SRC):
 	Updated.
 
 	* include/freetype/internal/fttrace.h: Add support for `colr' and
 	`cpal'.
 	Sort entries.
 
 2018-06-13  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Separate `CPAL' and `COLR' table handling.
 
 	Later on we want to support the `SVG' table also, which needs `CPAL'
 	(but not `COLR').
 
 	* include/freetype/internal/sfnt.h (SFNT_Interface): Add `load_cpal'
 	and `free_cpal' fields.
 	(FT_DEFINE_SFNT_INTERFACE): Updated.
 
 	* include/freetype/internal/tttypes.h (TT_FaceRec): Replace
 	`colr_and_cpal' fields with `cpal' and `colr'.
 
 	* src/sfnt/sfdriver.c (sfnt_interface): Updated.
 
 	* src/sfnt/sfobjs.c (sfnt_load_face, sfnt_done_face): Updated.
 
 	* src/sfnt/ttcolr.c (Colr, Cpal): Add `table' field.
 	(ColrCpal): Removed.
 	(tt_face_load_colr): Split off CPAL handling into...
 	(tt_face_load_cpal): ... this new function.
 	(tt_face_free_colr): Split off CPAL handling into...
 	(tt_face_free_cpal): ... this new function.
 	(tt_face_load_colr_layers, tt_face_palette_set): Updated.
 
 	* src/sfnt/ttcolr.h: Updated.
 
 	* src/truetype/ttgload.c (TT_Load_Glyph): Updated.
 
 2018-06-12  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Fix `sizeof' thinko.
 
 	* src/sfnt/ttcolr.c (tt_face_load_colr, tt_face_palette_set): Don't
 	use `sizeof' for computing array limit.
 
 2018-06-12  Werner Lemberg  <wl@gnu.org>
 
 	Finish CPAL/COLR support (4/4).
 
 	* src/sfnt/ttcolr.c (tt_face_find_color): Removed.
 	(tt_face_colr_blend_layer): Use `face->palette' instead of calling
 	`tt_face_find_color'.
 	Use and set text foreground color.
 
 2018-06-12  Werner Lemberg  <wl@gnu.org>
 
 	Finish CPAL/COLR support (3/4).
 
 	* src/base/ftcolor.c: Include FT_INTERNAL_SFNT_H.
 	(FT_Palette_Select, FT_Palette_Set_Foreground_Color): Implement
 	functions.
 
 2018-06-12  Werner Lemberg  <wl@gnu.org>
 
 	Finish CPAL/COLR support (2/4).
 
 	* src/sfnt/ttcolr.c (tt_face_palette_set): New function.
 	(tt_face_load_colr): Allocate `face->palette' and call
 	`tt_face_palette_set'.
 	Adjust return error code in case of error.
 
 	* src/sfnt/ttcolr.h: Updated.
 
 	* include/freetype/internal/sfnt.h (TT_Set_Palette_Func): New
 	function type.
 	(SFNT_Interface, FT_DEFINE_SFNT_INTERFACE): Add it.
 
 	* src/sfnt/sfdriver.c (sfnt_interface), src/sfnt/sfobjs.c
 	(sfnt_done_face): Updated.
 
 2018-06-12  Werner Lemberg  <wl@gnu.org>
 
 	Finish CPAL/COLR support (1/4).
 
 	* include/freetype/internal/tttypes.h (TT_FaceRec): New fields
 	`palette_index', `palette', `have_foreground_color' and
 	`foreground_color'.
 
 2018-06-12  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Minor.
 
 	* src/sfnt/ttcolr.c (tt_face_load_colr_layers):
 	s/palette_index/palette_entry_index/ for consistency.
 	Adjust return error code in case of error.
 
 2018-06-11  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[raster] Clean up.
 
 	* src/raster/ftraster.c (black_TWorker, SCALED, Set_High_Precision):
 	Clean up after 5-level gray removal (8dc8635874).
 	(Vertical_Sweep_Span): Be brief.
 
 2018-06-10  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Fix compiler warnings.
 
 	* src/sfnt/ttcolr.c (tt_face_load_colr, tt_face_load_colr_layers,
 	tt_face_colr_blend_layer): Add `NULL' initializers.
 
 2018-06-10  Werner Lemberg  <wl@gnu.org>
 
 	s/FT_Palette/FT_Palette_Data/, s/palette/palette_data/.
 
 	* include/freetype/ftcolor.h, include/freetype/internal/tttypes.h,
 	src/base/ftcolor.c, src/sfnt/sfobjs.c, src/sfnt/ttcolr.c: Updated.
 
 2018-06-10  Nikolaus Waxweiler  <madigens@gmail.com>
 
 	CMakeLists: also accept IOS_PLATFORM=SIMULATOR64
 
 	This might be needed to build FreeType for the iOS simulator. See
 	https://savannah.nongnu.org/bugs/index.php?54048. Patch contributed
 	by Steve Robinson.
 
 	* CMakeLists.txt: Accept IOS_PLATFORM=SIMULATOR64
 
 2018-06-10  Werner Lemberg  <wl@gnu.org>
 
 	Implement `FT_Palette_Get'.
 
 	* src/base/ftcolor.c: New file.
 
 	* src/base/Jamefile (_sources), src/base/rules.mk (BASE_SRC),
 	src/base/ftbase.c: Add `ftcolor.c'.
 
 2018-06-10  Werner Lemberg  <wl@gnu.org>
 
 	* src/sfnt/ttcolr.c (tt_face_load_colr): Improve overflow checks.
 
 2018-06-09  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[raster] Deal with pitch sign earlier.
 
 	* src/raster/ftraster.c (black_TWorker): Remove unused `traceG',
 	s/bTarget/bOrigin/.
 	(Render_Glyph): Set `ras.bOrigin' at the bottom-left corner.
 	(Vertical_Sweep_Init, {Vertical,Horizontal}_Sweep_{Span,Drop}):
 	Updated accordingly.
 
 2018-06-09  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Read `CPAL' version 1 tables.
 
 	* include/freetype/internal.tttypes.h: Include FT_COLOR_H.
 	(TT_FaceRec): Add `palette' field.
 
 	* src/sfnt/ttcolr.c: Include FT_COLOR_H.
 	(Cpal): Remove all data covered by the new `palette' field in
 	`TT_FaceRec'.
 	(tt_face_load_colr): Updated.
 	Read `CPAL' version 1 data.
 	(tt_face_load_colr_layers, tt_face_find_color): Updated.
 
 	* src/sfnt/sfobjs.c (sfnt_done_face): Free glyph color palette data.
 
 2018-06-07  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[base] API for Harmony LCD rendering.
 
 	This introduces `FT_Library_SetLcdGeometry' for setting up arbitrary
 	LCD subpixel geometry including non-striped patterns.
 
 	* src/base/ftlcdfil.c (FT_Library_SetLcdGeometry): New function.
 	* include/freetype/ftlcdfil.h: Document it.
 	* include/freetype/freetype.h: Minor.
 	* include/freetype/ftchapters.h: Minor.
 
 2018-06-06  Werner Lemberg  <wl@gnu.org>
 
 	ftcolor.h: Redesign API.
 
 	While going to implement it I noticed that I need access to most of
 	the `CPAL' elements; I thus plan to add a `cpal' field to
 	`TT_FaceRec', which makes most of the previously suggested API
 	functions obsolete because the fields will be directly accessible.
 
 2018-06-06  Parth Wazurkar  <parthwazurkar@gmail.com>
 
 	[bdf, pcf] Remove deprecated FT_FACE_FLAG_FAST_GLYPHS flag.
 
 	* src/bdf/bdfdrivr.c (BDF_Face_Init): Remove deprecated
 	FT_FACE_FLAG_FAST_GLYPHS flag.
 
 	* src/pcf/pcfread.c (pcf_load_font): Remove deprecated
 	FT_FACE_FLAG_FAST_GLYPHS flag.
 
 2018-06-06  Werner Lemberg  <wl@gnu.org>
 
 	[smooth, raster] Limit bitmap size (#54019).
 
 	* src/raster/ftraster.c [STANDALONE] (FT_Outline_Get_CBox): Add
 	function.
 	[!STANDALONE]: Include FT_OUTLINE_H.
 	(ft_black_render): Compute CBox and reject glyphs larger than
 	0xFFFF x 0xFFFF.
 
 	* src/smooth/ftgrays.c (gray_raster_render): Reject glyphs larger
 	than 0xFFFF x 0xFFFF.
 
 2018-06-03  Armin Hasitzka  <prince.cherusker@gmail.com>
 
 	* src/smooth/ftgrays.c (gray_convert_glyph): Remove unused variables.
 
 2018-06-03  Werner Lemberg  <wl@gnu.org>
 
 	* src/tools/glnames.py (main): Emit header in `light' comment style.
 
 2018-06-02  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Attempt to mitigate bug #54019.
 
 	The robust rendering of estra large glyphs came with unbearable cost.
 	The old way of bisecting should fail but fail faster.
 
 	* src/smooth/ftgrays.c (gray_convert_glyph): Switch back to bisecting
 	in y-direction.
 
 2018-06-02  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttinterp.c (Ins_MIRP): Use SUB_LONG; avoid FT_ABS.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=8706
 
 2018-06-02  Werner Lemberg  <wl@gnu.org>
 
 	* src/autofit/afwarp.h: Use AF_CONFIG_OPTION_USE_WARPER (#54033).
 
 2018-05-31  Werner Lemberg  <wl@gnu.org>
 
 	* src/raster/ftraster.c (black_TWorker_): Remove `gTarget' field.
 
 	This is no longer used.
 
 2018-05-31  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Get colors from `CPAL' table in right order (#54015).
 
 	* src/sfnt/ttcolr.c (tt_face_find_color): Fix it.
 
 2018-05-30  Werner Lemberg  <wl@gnu.org>
 
 	ftcolor.h: Improve API design, fix typos (#54011, #54014).
 
 	* include/freetype/ftcolor.h (FT_Palette_Get_Names): Replace with...
 	(FT_Palette_Get_Name_IDs): ... this function.
 	(FT_Palette_Get_Entry_Names): Replace with...
 	(FT_Palette_Get_Entry_Name_IDs): ... this function
 	s/FT_Palette_Set_Foreground_COlor/FT_Palette_Set_Foreground_Color/.
 
 2018-05-30  Armin Hasitzka  <prince.cherusker@gmail.com>
 
 	Beautify a3cfed5e87232c933bdc64f43e8ebebcfd18b41b.
 
 	* src/autofit/afloader.c (af_loader_load_glyph): Move the
 	initialisationand declaration of variables into the if-block.
 
 2018-05-30  Armin Hasitzka  <prince.cherusker@gmail.com>
 
 	Fix pointer underflow.
 
 	The declaration of `edge2' can be reached with `edge1 == NULL' and
 	`axis->edges == 0' which results in undefined behaviour.
 
 	* src/autofit/afloader.c (af_loader_load_glyph): Initialise `edge2'
 	after checking `axis->num_edges > 1'.  `edge1 != NULL' can be assumed.
 
 2018-05-30  Werner Lemberg  <wl@gnu.org>
 
 	Various minor color fixes.
 
 	* include/freetype/config/ftheader.h (FT_COLOR_H): New macro.
 
 	* include/freetype/internal/ftobjs.h (FT_Colr_Internal): Change
 	type of `load_flags' to `FT_Int32'.
 
 	* include/freetype/internal/sfnt.h (TT_Load_Colr_Layer_Func): Change
 	type of `idx' to `FT_UInt'.
 	(TT_Blend_Colr_Func): Change type of `color_index' to `FT_UInt'.
 
 	* src/base/ftobjs.c (FT_Render_Glyph_Internal): Change type of
 	`load_flags' to `FT_Int32'.
 
 	* src/sfnt/ttcolr.c (find_base_glyph_record,
 	tt_face_load_colr_layers): Change type of `glyph_id' to `FT_UInt'.
 	(tt_face_find_color, tt_face_colr_blend_layer): Change type of
 	`color_index' to `FT_UInt'.
 	Fix signedness and type issues.
 
 	* src/sfnt/ttcolr.h: Updated.
 
 2018-05-25  Nikhil Ramakrishnan  <ramakrishnan.nikhil@gmail.com>
 
 	[docmaker] Fix missing `Defined in (...)' under Windows/Cygwin.
 
 	This platform uses backslashes for paths, which docmaker didn't
 	understand correctly.
 
 	* src/tools/docmaker/tohtml.py (HtmlFormatter::blockEnter): Use
 	`os.path.normpath' to normalize the path for the platform being
 	used.
 
 2018-05-24  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Formalize Harmony LCD rendering.
 
 	This generalizes magic outline shifts that make Harmony LCD
 	rendering work in terms of precise two-dimensional RGB subpixel
 	positions. These coordinates are now set in time of the `smooth'
 	module initialization and later used to shift a glyph outline for
 	rendering. FT_RENDER_MODE_LCD and FT_RENDER_MODE_LCD_V use the same
 	coordinates. The letter, however, rotates them before using.
 	The LCD bitmap padding is also calculated using these coordinates.
 
 	* include/freetype/internal/ftobjs.h (FT_LibraryRec): New array field
 	`lcd_geometry'.
 	* src/base/ftlcdfil.c (ft_lcd_padding): Reworked.
 	* src/base/ftobjs.c (ft_glyphslot_preset_bitmap): Updated accordingly.
 
 	* src/smooth/ftsmooth.c [!FT_CONFIG_OPTION_SUBPIXEL_RENDERING]
 	(ft_smooth_init): Initialize `lcd_geometry'.
 	(ft_smooth_render_generic): Formalize outline shifts.
 
 2018-05-22  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Reject elements of composites with invalid glyph indices.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=8413
 
 	* src/truetype/ttgload.c (TT_Load_Composite_Glyph): Implement it.
 
 2018-05-22  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttgload.c (TT_Load_Simple_Glyph): Trace # of points.
 
 2018-05-20  Werner Lemberg  <wl@gnu.org>
 
 	* include/freetype/ftcolor.h: New file.
 
 	This is an interface to the `CPAL' OpenType table.  No
 	implementation yet.
 
 2018-05-18  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* include/freetype/internal/ftcalc.h (FT_MSB): Verified `_MSC_VER'.
 
 	Actually `_BitScanReverse' is available since VS2005.
 
 2018-05-18  Werner Lemberg  <wl@gnu.org>
 
 	* include/freetype/internal/ftcalc.h (FT_MSB): Use `_MSC_VER' value.
 
 	Older VC versions don't provide `_BitScanReverse'.  We test for VC
 	2013.
 
 	Reported by John Emmas <john@creativepost.co.uk>.
 
 2018-05-17  Werner Lemberg  <wl@gnu.org>
 
 	s/inline/__inline/ for MSVC.
 
 	Reported by John Emmas <john@creativepost.co.uk>.
 
 	* include/freetype/internal/ftcalc.h (FT_MSB) [_MSC_VER]: Do it.
 
 2018-05-16  Werner Lemberg  <wl@gnu.org>
 
 	Add function `FT_Get_GlyphLayers' to access `COLR' table data.
 
 	* include/freetype/internal/ftobjs.h (FT_Glyph_LayerRec): Move this
 	structure to...
 	* include/freetype/freetype.h (FT_Glyph_LayerRec): ... this
 	header file.
 	(FT_Glyph_Layer): New typedef.
 	Update code to use it where appropriate.
 
 	* src/base/ftobjs.c (FT_Get_GlyphLayers): New function.
 
 2018-05-15  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[base] Fix mono bitmap presetting (#53896).
 
 	It is rather fundamental to set monochrome bitmap based on rounded
 	CBox because the b/w rasterizer turns on pixels when their centers are
 	inside the glyph outline. The dropout control is unpredictable and can
 	distort narrow glyphs if the bitmap is too wide.
 
 	Reported by Chris Liddell.
 
 	* src/base/ftobjs.c (ft_glyphslot_preset_bitmap): If BBox boundaries
 	are too close, adjust them before rounding.
 
 2018-05-15  Werner Lemberg  <wl@gnu.org>
 
 	[psaux] Fix compiler warning (#53915).
 
 	* src/psaux/psft.c (cf2_freeT1SeacComponent): Do it.
 
 2018-05-15  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Fix memory leak in handling `COLR' data.
 
 	* src/truetype/ttgload.c (TT_Load_Glyph): Free old `layers' array
 	before reassigning allocated memory.
 	Only allocate `color_layers' if we don't have one already.
 
 2018-05-15  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] If `COLR' is present, don't assume that all glyphs use it.
 
 	* src/sfnt/ttcolr.c (tt_face_load_colr_layers): Return FT_Err_Ok if
 	current glyph is not a `COLR' base glyph.
 
 	* src/truetype/ttgload.c (TT_Load_Glyph): Don't allocate
 	`color_layers' if there are no color layers.
 
 2018-05-14  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftobjs.c (FT_Load_Glyph): Fix signature of `pixel_modes'.
 
 2018-05-14  Werner Lemberg  <wl@gnu.org>
 
 	Provide dummy functions if `TT_CONFIG_OPTION_SFNT_NAMES' is not set.
 
 	* src/base/ftsnames.c [!TT_CONFIG_OPTION_SFNT_NAMES]: Implement it.
 
 2018-05-13  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftobjs.c (FT_Load_Glyph): Improve tracing.
 
 2018-05-13  Shao Yu Zhang  <shaozhang@fb.com>
 	    Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Preliminary support of coloured layer outlines (#44689).
 
 	This commit enables OpenType's COLR/CPAL table handling; a typical
 	application are color emojis that can be scaled to any size.
 
 	If the color palette does not exist or is invalid, the rendering
 	step rasterizes the outline instead.  The current implementation
 	assumes that the foreground is black.
 
 	Enable this by defining option TT_CONFIG_OPTION_COLOR_LAYERS.
 
 	There are still some issues with metrics; additionally, an API to
 	fetch color layers is missing.
 
 	* devel/ftoption.h, include/freetype/config/ftoption.h
 	(TT_CONFIG_OPTION_COLOR_LAYERS): New macro.
 
 	* include/freetype/internal/ftobjs.h (FT_Glyph_LayerRec,
 	FT_Colr_InternalRec): New structures.
 	(FT_Slot_InternalRec): Add `color_layers' field.
 
 	* include/freetype/internal/sfnt.h (TT_Load_Colr_Layer_Func,
 	TT_Blend_Colr_Func): New function types.
 	(SFNT_Interface): Add `load_colr', `free_colr', `load_colr_layer',
 	and `colr_blend' fields.
 
 	* include/freetype/internal/tttypes.h (TT_FaceRec): Add
 	`colr_and_cpal' field.
 
 	* include/freetype/internal/tttags. (TTAG_COLR, TTAG_CPAL): New
 	macros.
 
 	* src/sfnt/ttcolr.c, src/sfnt/ttcolr.h: New files.
 
 	* src/base/ftobjs.c (ft_glyphslot_done, FT_Render_Glyph_Internal):
 	Handle glyph color layers.
 
 	* src/sfnt/Jamfile (_sources), src/sfnt/rules.mk (SFNT_DRV_SRC): Add
 	`ttcolr.c'.
 
 	* src/sfnt/sfdriver.c: Include `ttcolr.h'.
 	(PUT_COLOR_LAYERS): New macro.
 	Update call to `FT_DEFINE_SFNT_INTERFACE'.
 
 	* src/sfnt/sfnt.c: Include `ttcolr.c'.
 
 	* src/sfnt/sfobjs.c (sfnt_load_face): Load `COLR' and `CPAL' tables.
 	(sfnt_done_face): Updated.
 
 	* src/truetype/ttgload.c (TT_Load_Glyph): Handle color layers.
 
 2018-05-12  Arkady Shapkin  <arkady.shapkin@gmail.com>
 
 	Use MS VC++'s _BitScanReverse to calculate MSB (patch #9636).
 
 	* include/freetype/internal/ftcalc.h (FT_MSB) [_MSC_VER]: Implement
 	it.
 
 2018-05-10  Alan Coopersmith  <alan.coopersmith@oracle.com>
 
 	Fix DLL compilation on Solaris.
 
 	AC_COMPILE_IFELSE only tries to compile a `*.c' to a `*.o'.  The
 	Solaris Studio 12.1 through 12.5 compilers see the
 	`-fvisibility=hidden' flag, but ignore it with a warning of:
 
 	  cc: Warning: Option -fvisibility=hidden passed to ld,
 	               if ld is invoked, ignored otherwise
 
 	AC_LINK_IFELSE does the compile and then tries to link the result,
 	at which point the Solaris linker will issue an error:
 
 	  ld: fatal: option '-fvisibility=hidden' is incompatible with
 	      building a dynamic executable
 
 	If we don't use AC_LINK_IFELSE to catch the error, then configure
 	will fail further tests which attempt to link, such as those testing
 	dependencies like `libbz2'.
 
 	Also, don't try adding `-fvisibility' if we have already added
 	`-xldscope', just use one of them, since Sun Studio 12 and earlier
 	compilers only issue a warning, and don't try passing through to the
 	linker to generate an error, so AC_LINK_IFELSE doesn't catch them.
 
 	Tested on Solaris 11.4 beta with compiler versions:
 
 	  Sun Studio 8 (Sun C 5.5)
 	  Sun Studio 10 (Sun C 5.7)
 	  Sun Studio 11 (Sun C 5.8)
 	  Sun Studio 12 (Sun C 5.9)
 	  Sun Studio 12.1 (Sun C 5.10)
 	  Oracle Solaris Studio 12.2 (Sun C 5.11)
 	  Oracle Solaris Studio 12.3 (Sun C 5.12)
 	  Oracle Solaris Studio 12.4 (Sun C 5.13)
 	  Oracle Developer Studio 12.5 (Sun C 5.14)
 	  Oracle Developer Studio 12.6 (Sun C 5.15)
 	  gcc 5.5.0
 	  gcc 7.3.0
 
 	and verified the libfreetype.so.6 generated by each of those
 	compilers exported the same set of symbols.
 
 	* builds/unix/configure.raw: Implement it.
 
 2018-05-08  Werner Lemberg  <wl@gnu.org>
 
 	[autofit] Avoid potential SEGV if running out of memory.
 
 	Problem reported by Shailesh Mistry <shailesh.mistry@hotmail.co.uk>.
 
 	* src/autofit/afshaper.c (af_shaper_buf_create,
 	af_shaper_buf_destroy) [!FT_CONFIG_OPTION_USE_HARFBUZZ]: Don't
 	allocate and free a four-byte buffer.  Instead, make those functions
 	no-ops; the calling functions will provide a pointer to a buffer
 	instead.
 
 	* src/autofit/afcjk.c (af_cjk_metrics_init_widths,
 	af_cjk_metrics_init_blues, af_cjk_metrics_check_digits),
 	src/autofit/aflatin.c (af_latin_metrics_init_widths,
 	af_latin_metrics_init_blues, af_latin_metrics_check_digits)
 	[!FT_CONFIG_OPTION_USE_HARFBUZZ]: Use pointer to local variable for
 	`shaper_buf'.
 
 2018-05-07  Nikolaus Waxweiler  <madigens@gmail.com>
 
 	[cmake] Allow using project as subfolder in other project.
 
 	* CMakeLists.txt: Test for CMake build directory being different
 	from source directory.  Provide other parts of the build system
 	access the full include directory.
 
 2018-05-07  Werner Lemberg  <wl@gnu.org>
 
 	[build] Suppress configure's `nothing to be done' message.
 
 	This is due to calling the configure script via `make' (within the
 	top-level `configure' wrapper script).  The same can happen for all
 	other secondary make targets that are used to only modify the
 	primary one, e.g., `make setup devel'.
 
 	* builds/dos/detect.mk (emx, turboc, watcom, borlandc, borlandc16),
 	builds/os2/detect (visualage, watcom, borlandc, devel),
 	builds/unix/detect.mk (devel, lcc, unix), builds/windows/detect.mk
 	(visualc, watcom, visualage, lcc, mingw32, bcc32, devel-bcc,
 	devel-gcc): Use no-op recipe.
 
 2018-05-04  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Support symbol visibility features of Sun / Oracle C compilers.
 
 	Reported by Kiyoshi Kanazawa:
 	https://lists.gnu.org/archive/html/freetype-devel/2018-05/msg00008.html
 	Thanks to the suggestions by Alexei and Alan Coopersmith.
 
 	* builds/unix/configure.raw: Check if "-xldscope=hidden" is
 	accepted, and if so, it is added to CFLAGS.  This is the option
 	making Sun / Oracle C compilers hide the symbols from global
 	scope.
 	* include/freetype/config/ftconfig.h: Use "__global" prefix
 	for FT_EXPORT() macro, if SunPro C is newer than Sun ONE
 	Studio 8 (2003).
 	* builds/unix/ftconfig.in: Ditto.
 	* builds/vms/ftconfig.h: Ditto.
 
 2018-05-02  Nikolaus Waxweiler  <madigens@gmail.com>
 
 	Unbreak CMake Windows installation
 
 	* CMakeLists.txt: Generate ftconfig.h on non-UNIX.
 
 2018-05-02  Werner Lemberg  <wl@gnu.org>
 
 	Remove FT_CONFIG_OPTION_PIC and related code.
 
 	*/* [FT_CONFIG_OPTION_PIC]: Remove all code guarded by this
 	preprocessor symbol.
 
 	*/*: Replace `XXX_GET' macros (which could be either a function in
 	PIC mode or an array in non-PIC mode) with `xxx' arrays.
 
 	* include/freetype/internal/ftpic.h, src/autofit/afpic.c,
 	src/autofit/afpic.h, src/base/basepic.c, src/base/basepic.h,
 	src/base/ftpic.c, src/cff/cffpic.c, src/cff/cffpic.h,
 	src/pshinter/pshpic.c, src/pshinter/pshpic.h, src/psnames/pspic.c,
 	src/psnames/pspic.h, src/raster/rastpic.c, src/raster/rastpic.h,
 	src/sfnt/sfntpic.c, src/sfnt/sfntpic.h, src/smooth/ftspic.c,
 	src/smooth/ftspic.h, src/truetype/ttpic.c, src/truetype/ttpic.h:
 	Removed.
 
 2018-05-01  Werner Lemberg  <wl@gnu.org>
 
 	* Version 2.9.1 released.
 	=========================
 
 
 	Tag sources with `VER-2-9-1'.
 
 	* docs/VERSION.TXT: Add entry for version 2.9.1.
 	* docs/CHANGES: Updated.
 
 	* README, Jamfile (RefDoc), builds/windows/vc2005/freetype.vcproj,
 	src/base/ftver.rc, builds/windows/vc2005/index.html,
 	builds/windows/vc2008/freetype.vcproj,
 	builds/windows/vc2008/index.html,
 	builds/windows/vc2010/freetype.vcxproj,
 	builds/windows/vc2010/index.html,
 	builds/windows/visualc/freetype.dsp,
 	builds/windows/visualc/freetype.vcproj,
 	builds/windows/visualc/index.html,
 	builds/windows/visualce/freetype.dsp,
 	builds/windows/visualce/freetype.vcproj,
 	builds/windows/visualce/index.html,
 	builds/wince/vc2005-ce/freetype.vcproj,
 	builds/wince/vc2005-ce/index.html,
 	builds/wince/vc2008-ce/freetype.vcproj,
 	builds/wince/vc2008-ce/index.html: s/2.9/2.9.1/, s/29/291/.
 
 	* include/freetype/freetype.h (FREETYPE_PATCH): Set to 1.
 
 	* builds/unix/configure.raw (version_info): Set to 22:1:16.
 	* CMakeLists.txt (VERSION_PATCH): Set to 1.
 
 	* include/freetype/ftgasp.h: Use FT_BEGIN_HEADER and FT_END_HEADER.
 
 2018-04-26  Werner Lemberg  <wl@gnu.org>
 
 	Another fix for handling invalid format 2 cmaps.
 
 	Sigh.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=8003
 
 	* src/sfnt/ttcmap.c (tt_cmap2_char_next): Adjust condition to avoid
 	an endless loop.
 
 2018-04-24  Ben Wagner  <bungeman@google.com>
 
 	[base] Avoid undefined behaviour in lcd filtering code (#53727).
 
 	* src/base/ftlcdfil.c (ft_lcd_filter_fir, _ft_lcd_filter_legacy):
 	Ensure `height > 0'.
 
 2018-04-22  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftoutln.c (FT_Outline_Decompose): Improve error tracing.
 
 2018-04-22  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[base] Fix bitmap emboldening.
 
 	Bug introduced after release 2.8.
 
 	* src/base/ftbitmap.c (ft_bitmap_assure_buffer): We use
 	`FT_QALLOC_MULT', which doesn't zero out the buffer.  Adjust the
 	bitmap copying code to take care of this fact.
 
 2018-04-22  Werner Lemberg  <wl@gnu.org>
 
 	Another fix for handling invalid format 2 cmaps.
 
 	The previous commit was incomplete.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=7928
 
 	* src/sfnt/ttcmap.c (tt_cmap2_char_next): Adjust condition to avoid
 	an endless loop.
 
 2018-04-19  Werner Lemberg  <wl@gnu.org
 
 	[autofit] Add support for Georgian Mtavruli characters.
 
 	This will be part of the forthcoming Unicode 11.0.
 
 	* src/autofit/afblue.dat: Add blue zone data for Mtavruli.
 	* src/autofit/afblue.c, src/autofit/afblue.h: Regenerated.
 
 	* src/autofit/afscript.h: Add Mtavruli standard character.
 
 2018-04-18  Werner Lemberg  <wl@gnu.org>
 
 	Fix handling of invalid format 2 cmaps.
 
 	The problem was introduced after the last release.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=7828
 
 	* src/sfnt/ttcmap.c (tt_cmap2_char_next): Avoid endless loop.
 
 2018-04-17  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Integer overflow issues.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=7739
 
 	* src/truetype/ttinterp.c (Ins_CEILING): Use FT_PIX_CEIL_LONG.
 
 2018-04-16  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Integer overflow issues.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=7718
 
 	* src/truetype/ttinterp.c (Ins_MIRP): Use ADD_LONG.
 
 2018-04-15  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[build] Use `info' function of make 3.81.
 
 	* configure, docs/INSTALL, docs/INSTALL.CROSS, docs/INSTALL.GNU,
 	docs/INSTALL.UNIX, docs/MAKEPP: Bump make version requirements.
 
 	* builds/detect.mk (std_setup): Replace `echo' with `info'.
 	(dos_setup): Removed.
 	* builds/unix/install.mk, builds/modules.mk, builds/dos/detect.mk,
 	builds/windows/detect.mk, builds/os2/detect.mk: Updated.
 	* builds/newline: No longer needed.
 
 2018-04-15  Werner Lemberg  <wl@gnu.org>
 
 	[truetype]: Limit `SLOOP' bytecode argument to 16 bits.
 
 	This fixes
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=7707
 
 	* src/truetype/ttinterp.c (Ins_SLOOP): Do it.
 
 2018-04-14  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Integer overflow issues.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=7652
 
 	* src/truetype/ttinterp.c (Ins_MDAP): Use SUB_LONG.
 
 2018-04-14  Werner Lemberg  <wl@gnu.org>
 
 	[autofit] Update to Unicode 11.0.0.
 
 	But no support new scripts (volunteers welcomed).
 
 	* src/autofit/afranges.c (af_arab_nonbase_uniranges,
 	af_beng_nonbase_uniranges, af_cakm_nonbase_uniranges,
 	af_deva_nonbase_uniranges, af_geor_uniranges,
 	af_gujr_nonbase_uniranges, af_mlym_nonbase_uniranges,
 	af_nkoo_nonbase_uniranges, af_telu_nonbase_uniranges,
 	af_hani_uniranges): Add new data.
 
 2018-04-10  Nikolaus Waxweiler  <madigens@gmail.com>
 
 	* CMakeLists.txt, builds/cmake/FindHarfBuzz.cmake: Extensive
 	modernization measures.
 
 	This brings up the minimum required CMake version to 2.8.12.
 
 	The installation paths follow the GNU defaults now, e.g. installing on a
 	64 bit host will place binaries into the lib64/ folder on e.g. Fedora.
 
 	Symbols are hidden by default (e.g. `-fvisibility=hidden' on GCC).
 
 	CMake will no longer look for a C++ compiler.
 
 	Library and .so version now match the Autotools build.
 
 	Comments in the build file and informational messages now use platform
 	agnostic example commands.
 
 	ftoption.h and ftconfig.h are written directly without a redundant `-new'
 	copy.
 
 	External dependencies are expressed as option()s and will turn up as such
 	in cmake-gui.
 
 	Internal: Properties such as dependencies and include directories are now
 	privately set on the freetype library instead of globally.
 
 	The CPack definitions have been cleaned up, the `make dist' has been
 	removed. Source packages generated with CPack don't contain Autotools
 	files and aren't used by the maintainers anyway.
 
 	On Windows, src/base/ftver.rc is compiled to decorate the library with
 	version and copyright information.
 
 	A pkg-config file is now generated and installed.
 
 2018-04-09  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Integer overflow issues.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=7453
 
 	* src/truetype/ttinterp.c (Round_Super, Round_Super_45): Use
 	ADD_LONG and SUB_LONG.
 
 2018-04-06  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[windows, wince] Clean up legacy project files.
 
 	* builds/wince/vc2005-ce/freetype.vcproj,
 	builds/wince/vc2008-ce/freetype.vcproj,
 	builds/windows/vc2005/freetype.vcproj,
 	builds/windows/vc2008/freetype.vcproj,
 	builds/windows/visualce/freetype.vcproj,
 	builds/windows/visualce/freetype.dsp,
 	builds/windows/visualc/freetype.vcproj,
 	builds/windows/visualc/freetype.dsp: Remove per-file compile flags.
 
 2018-04-04  Werner Lemberg  <wl@gnu.org>
 
 	[cff, type1] Sanitize `BlueFuzz' and `BlueShift'.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=7371
 
 	* src/cff/cffload.c (cff_load_private_dict): Sanitize
 	`priv->blue_shift' and `priv->blue_fuzz' to avoid overflows later
 	on.
 
 	* src/type1/t1load.c (T1_Open_Face): Ditto.
 
 2018-04-04  Ben Wagner  <bungeman@google.com>
 
 	* src/truetype/ttobjs.c (trick_names): Add 3 tricky fonts (#53554),
 	`DFHei-Md-HK-BF', `DFKaiShu-Md-HK-BF' and `DFMing-Bd-HK-BF'.
 	(tt_check_trickyness_sfnt_ids): Add checksums for 3 tricky fonts
 	in above.
 
 2018-04-01  Werner Lemberg  <wl@gnu.org>
 
 	* builds/toplevel.mk (work): Use $(SEP).
 
 	This fixes the `make refdoc' using Cygwin: $(CAT) is `type' on this
 	platform, and this program only understands backslashes in paths.
 
 	Reported by Nikhil Ramakrishnan <ramakrishnan.nikhil@gmail.com>.
 
 2018-03-30  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Fix memory leak (only if tracing is on).
 
 	* src/truetype/ttgxvar.c (TT_Get_MM_Var) [FT_DEBUG_LEVEL_TRACE}: Fix
 	it.
 
 2018-03-23  Ben Wagner  <bungeman@google.com>
 
 	[sfnt] Correctly handle missing bitmaps in sbix format (#53404).
 
 	* src/sfnt/ttfsbit.c (tt_face_load_sbix_image): Fix return value.
 
 2018-03-23  Ben Wagner  <bungeman@google.com>
 
 	[truetype] Fix advance of empty glyphs in bitmap fonts (#53393).
 
 	* src/truetype/ttgload.c (TT_Load_Glyph): Apply scaling to metrics
 	for empty bitmaps.
 
 2018-03-22  Werner Lemberg  <wl@gnu.org>
 
 	Remove `ftlcdfil.c' and `ftfntfmt.c' from build files (#53415).
 
 	builds/amiga/makefile, builds/amiga/makefile.os4,
 	builds/amiga/smakefile, builds/mac/FreeType.m68k_cfm.make.txt,
 	builds/mac/FreeType.m68k_far.make.txt,
 	builds/mac/FreeType.ppc_carbon.make.txt,
 	builds/mac/FreeType.ppc_classic.make.txt,
 	builds/symbian/freetype.mmp, builds/wince/vc2005-ce/freetype.vcproj,
 	builds/wince/vc2008-ce/freetype.vcproj,
 	builds/windows/vc2005/freetype.vcproj,
 	builds/windows/vc2008/freetype.vcproj,
 	builds/windows/vc2010/freetype.vcxproj,
 	builds/windows/vc2010/freetype.vcxproj.filters,
 	builds/windows/visualc/freetype.dsp,
 	builds/windows/visualc/freetype.vcproj,
 	builds/windows/visualce/freetype.dsp,
 	builds/windows/visualce/freetype.vcproj, vms_make.com: Do it.
 
 2018-03-13  Werner Lemberg  <wl@gnu.org>
 
 	* src/sfnt/ttcmap.c (tt_cmap2_validate): Fix potential numeric
 	overflow.
 
 2018-03-13  Werner Lemberg  <wl@gnu.org>
 
 	Fix cmap format 2 handling (#53320).
 
 	The patch introduced for #52646 was not correct.
 
 	* src/sfnt/ttcmap.c (tt_cmap2_char_next): Adjust condition.
 
 2018-03-10  Nikolaus Waxweiler  <madigens@gmail.com>
 
 	* CMakeLists.txt (BASE_SRCS): Update to changes from 2018-03-05.
 
 2018-03-09  Chun-wei Fan  <fanc999@yahoo.com.tw>
 
 	* CMakeLists.txt [win32]: Allow MSVC DLL builds (#53287).
 
 	Do not limit DLL builds to MinGW, since we already have
 	`__declspec(dllexport)' directives in `ftconfig.h'.
 	Also suppress more warnings for POSIX functions.
 
 2018-03-08  Hugh McMaster  <hugh.mcmaster@outlook.com>
 
 	Make installation of `freetype-config' optional (#53093).
 
 	* builds/unix/configure.raw: Add option `--enable-freetype-config'
 	and set `INSTALL_FT2_CONFIG'.
 	* builds/unix/unix-def.in (INSTALL_FT2_CONFIG): Define.
 	* builds/unix/install.mk (install): Handle it.
 
 2018-03-05  Werner Lemberg  <wl@gnu.org>
 
 	Make `ftlcdfil.c' part of the `base' module.
 
 	`ftobjs.c' needs `ft_lcd_padding'.
 
 	Problem reported by duhuanpeng <548708880@qq.com>.
 
 	* modules.cfg (BASE_EXTENSIONS): Don't include `ftlcdfil.c'.
 
 	* src/base/ftbase.c: Include `ftlcdfil.c'.
 	* src/base/rules.mk (BASE_SRC): Add `ftlcdfil.c'.
 	* src/base/Jamfile (_sources): Adjusted.
 
 	* docs/INSTALL.ANY: Updated.
 
 2018-03-05  Werner Lemberg  <wl@gnu.org>
 
 	Make `ftfntfmt.c' part of the `base' module.
 
 	`ftobjs.c' needs `FT_Get_Font_Format'.
 
 	Problem reported by duhuanpeng <548708880@qq.com>.
 
 	* modules.cfg (BASE_EXTENSIONS): Don't include `ftfntfmt.c'.
 
 	* src/base/ftbase.c: Include `ftfntfmt.c'.
 	* src/base/rules.mk (BASE_SRC): Add `ftfntfmt.c'.
 	* src/base/Jamfile (_sources): Adjusted.
 
 	* docs/INSTALL.ANY: Updated.
 
 2018-03-01  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttinterp.c (TT_RunIns): Fix tracing arguments.
 
 2018-02-23  Werner Lemberg  <wl@gnu.org>
 
 	* builds/unix/configure.raw: Need HarfBuzz 1.3.0 or newer.
 
 	Problem reported by Alan Coopersmith <alan.coopersmith@oracle.com>.
 
 2018-02-17  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Prefer `CBDT'/`CBLC' over `glyf' table (#53154).
 
 2018-02-06  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Integer overflow issues.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=6027
 
 	* src/truetype/ttinterp.c (Ins_MSIRP, Ins_MIAP, Ins_MIRP): Use
 	SUB_LONG; avoid FT_ABS.
 
 2018-02-04  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[unix] Use -fvisibility=hidden.
 
 	It is now widely recommended that ELF shared libraries hide symbols
 	except those with explicit __attribute__((visibility("default"))).
 	This is supported by all major compilers and should rather be an
 	option in libtool.
 
 	* builds/unix/configure.raw: Add -fvisibility=hidden to CFLAGS.
 	* builds/unix/ftconfig.in, builds/vms/ftconfig.h,
 	include/freetype/config/ftconfig.h (FT_EXPORT): Use visibility
 	attribute.
 
 2018-01-27  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Better protection against invalid VF data.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=5739
 
 	Bug introduced in commit 08cd62deedefe217f2ea50e392923ce8b5bc7ac7.
 
 	* src/truetype/ttgxvar.c (TT_Set_Var_Design): Always initialize
 	`normalizedcoords'.
 
 2018-01-27  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttinterp.c (Ins_GETVARIATION): Avoid NULL reference.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=5736
 
 2018-01-27  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttgxvar.c (tt_set_mm_blend): Minor.
 
 2018-01-27  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Better trace VF instances.
 
 	* src/truetype/ttgxvar.c (ft_var_to_normalized): Don't emit number
 	of coordinates.
 	(TT_Get_MM_Var): Trace instance indices names.
 	(TT_Set_Var_Design): Updated.
 
 2018-01-27  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Beautify tracing of VF axis records.
 
 	* src/truetype/ttgxvar.c (TT_Get_MM_Var): Show axis records in a
 	table-like manner.
 
 2018-01-26  Ben Wagner  <bungeman@google.com>
 
 	[truetype] Fix multiple calls of `FT_Get_MM_Var' (#52955).
 
 	* src/truetype/ttgxvar.c (TT_Get_MM_Var): Set
 	`face->blend->num_axis' in case we have to initialize the
 	`face->blend'.
 
 2018-01-23  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[apinames] Anonymous version map for GNU linker.
 
 	* src/tools/apinames.c (PROGRAM_VERSION): Set to 0.3.
 	(OutputFormat): Add `OUTPUT_GNU_VERMAP'.
 	(names_dump): Handle it.
 	(usage): Updated.
 	(main): Handle new command line flag `-wL'.
 
 2018-01-21  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[unix] Call libtool to clean up.
 
 	* builds/unix/install.mk (clean_project_unix, distclean_project_unix):
 	Use libtool.
 	* builds/freetype.mk: Minor.
 
 2018-01-18  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/base/ftver.rc: Fix mingw-w64 compilation.
 
 2018-01-18  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[build] Enable VERSIONINFO resource for Cygwin/MinGW.
 
 	* builds/unix/configure.raw: Check for resource compiler.
 	* builds/unix/unix-cc.in: Conditionally set up resource compiler.
 	* builds/freetype.mk: Add conditional rule for `ftver.rc'.
 	* src/base/ftver.rc: Copyright notice and year update.
 
 2018-01-18  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[build] Move VERSIONINFO resource.
 
 	* builds/windows/vc2010/freetype.vcxproj: Updated.
 	* builds/windows/ftver.rc: Move file from here...
 	* src/base/ftver.rc: ... to here.
 
 2018-01-12  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[build] Expand dllexport/dllimport to Cygwin/MinGW.
 
 	* include/freetype/config/ftconfig.h: Respect DLL_EXPORT,
 	s/_MSC_VER/_WIN32/.
 	* builds/unix/ftconfig.in: Replicate here.
 	* builds/vms/ftconfig.h: Replicate here.
 
 2018-01-12  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[build] Improve and document MSVC build.
 
 	* include/freetype/config/ftconfig.h: Guard dllexport/dllimport
 	attributes with _DLL and FT2_DLLIMPORT.
 	* builds/windows/vc2010/index.html: Update documentation.
 
 2018-01-10  Steve Robinson  <ssrobins@gmail.com>
 
 	* CMakeLists.txt [win32]: Suppress warnings for POSIX functions.
 
 2018-01-10  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux] Correctly handle Flex features (#52846).
 
 	* src/psaux/psintrp.c (cf2_interpT2CharString) <cf2_cmdVMOVETO,
 	cf2_cmdHMOVETO>: Do not move if doing Flex.
 
 2018-01-09  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* builds/windows/vc2010/freetype.sln: Synchronize with the project.
 
 2018-01-08  Werner Lemberg  <wl@gnu.org>
 
 	* Version 2.9 released.
 	=======================
 
 
 	Tag sources with `VER-2-9'.
 
 	* docs/VERSION.TXT: Add entry for version 2.9.
 
 	* README, Jamfile (RefDoc), builds/windows/vc2005/freetype.vcproj,
 	builds/windows/vc2005/index.html,
 	builds/windows/vc2008/freetype.vcproj,
 	builds/windows/vc2008/index.html,
 	builds/windows/vc2010/freetype.vcxproj,
 	builds/windows/vc2010/index.html,
 	builds/windows/visualc/freetype.dsp,
 	builds/windows/visualc/freetype.vcproj,
 	builds/windows/visualc/index.html,
 	builds/windows/visualce/freetype.dsp,
 	builds/windows/visualce/freetype.vcproj,
 	builds/windows/visualce/index.html,
 	builds/windows/ftver.rc,
 	builds/wince/vc2005-ce/freetype.vcproj,
 	builds/wince/vc2005-ce/index.html,
 	builds/wince/vc2008-ce/freetype.vcproj,
 	builds/wince/vc2008-ce/index.html: s/2.8.1/2.9/, s/281/29/.
 
 	* include/freetype/freetype.h (FREETYPE_MINOR): Set to 9.
 	(FREETYPE_PATCH): Set to 0.
 
 	* builds/unix/configure.raw (version_info): Set to 22:0:16.
 	* CMakeLists.txt (VERSION_PATCH): Set to 0.
 
 2018-01-07  Werner Lemberg  <wl@gnu.org>
 
 	Add check for librt, needed for `ftbench' (#52824).
 
 	* builds/unix/configure.raw (LIB_CLOCK_GETTIME): Define; this will
 	hold `-lrt' if necessary.
 
 	* builds/unix/unix-cc.in (LIB_CLOCK_GETTIME): New variable.
 
 2018-01-07  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux] Fix Type 1 glyphs with too many stem hints.
 
 	According to the CFF specification, charstrings can have up to 96 stem
 	hints. Due to hint replacement routines in Type 1 charstrings, some
 	glyphs are rejected by the Adobe engine, which implements the above
 	limit. This fix turns off hinting for such glyphs.
 
 	* src/psaux/pshints.c (cf2_hintmap_build): Reset the error from calling
 	`cf2_hintmask_setAll' on a problematic Type 1 charstring and turn off
 	hinting.
 
 2018-01-06  Werner Lemberg  <wl@gnu.org>
 
 	Add `FT_Done_MM_Var'.
 
 	This is necessary in case the application's memory routines differ
 	from FreeType.  A typical example is a Python application on Windows
 	that calls FreeType compiled as a DLL via the `ctypes' interface.
 
 	* include/freetype/ftmm.h, src/base/ftmm.c (FT_Done_MM_Var): Declare
 	and define.
 
 	* docs/CHANGES: Updated.
 
 2018-01-03  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Round offsets of glyph components only if hinting is on.
 
 	* src/truetype/ttgload.c (TT_Process_Composite_Component): Implement
 	it.
 
 2018-01-03  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttgxvar.c (ft_var_to_design): Remove dead code.
 
 	This is a better fix than the previous commit, which is now
 	reverted.
 
 2018-01-03  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	Move internal LCD-related declarations.
 
 	* include/freetype/ftlcdfil.h (ft_lcd_padding, ft_lcd_filter_fir):
 	Move from here...
 	* include/freetype/internal/ftobjs.h: ... to here.
 
 2018-01-03  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* include/freetype/config/ftconfig.h (FT_EXPORT, FT_EXPORT_DEF)
 	[_MSC_VER]: Limit Visual C++ attributes.
 
 2018-01-03  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Make blend/design coordinate round-tripping work.
 
 	Behdad reported that setting blend coordinates, then getting design
 	coordinates did incorrectly return the default instance's
 	coordinates.
 
 	* src/truetype/ttgxvar.c (tt_set_mm_blend): Fix it.
 
 2017-12-31  Werner Lemberg  <wl@gnu.org>
 
 	* src/sfnt/ttcmap.c (tt_cmap2_char_next): Fix endless loop.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=4838
 
 2017-12-31  Werner Lemberg  <wl@gnu.org>
 
 	Synchronize other Windows project files.
 
 	* builds/windows/*: Add missing files.
 
 2017-12-31  Werner Lemberg  <wl@gnu.org>
 
 	Update Visual C 2010 project files.
 
 	Problem reported by Hin-Tak.
 
 	* builds/windows/vc2010/freetype.vcxproj: Add files `ftbdf.c' and
 	`ftcid.c'.
 	Sort entries.
 	* builds/windows/vc2010/freetype.vcxproj.filter: Ditto.
 	Fix members of `FT_MODULE' group.
 
 2017-12-30  Werner Lemberg  <wl@gnu.org>
 
 	* builds/vms/ftconfig.h: Synchronize with unix `ftconfig.in' file.
 
 2017-12-28  Werner Lemberg  <wl@gnu.org>
 
 	* builds/unix/ftconfig.in: Synchronize with main `ftconfig.h' file.
 
 	Reported by Nikolaus.
 
 2017-12-27  Werner Lemberg  <wl@gnu.org>
 
 	Fix compiler warnings.
 
 	* src/base/ftbitmap.c (ft_bitmap_assure_buffer): Make `pitch' and
 	`new_pitch' unsigned.
 
 	* src/base/ftpsprop.c: Include FT_INTERNAL_POSTSCRIPT_PROPS_H.
 
 2017-12-27  Werner Lemberg  <wl@gnu.org>
 
 	Fixes for `make multi'.
 
 	* include/freetype/internal/ftpsprop.h: Use `FT_BASE_CALLBACK'.
 	(ps_property_get): Harmonize declaration with corresponding
 	function typedef.
 
 	* include/freety[e/internal/fttrace.h: Add `trace_psprops'.
 
 	* src/base/ftpsprop.c: Include necessary header files.
 	(FT_COMPONENT): Define.
 	(ps_property_set): Tag with `FT_BASE_CALLBACK_DEF'.
 	(ps_property_get): Tag with `FT_BASE_CALLBACK_DEF'.
 	Harmonize declaration with corresponding function typedef.
 
 2017-12-27  Werner Lemberg  <wl@gnu.org>
 
 	Provide support for intra-module callback functions.
 
 	This is needed especially for `make multi' with C++.
 
 	* include/freetype/config/ftconfig.h (FT_BASE_CALLBACK,
 	FT_BASE_CALLBACK_DEF): New macros.
 
 2017-12-25  Ewald Hew  <ewaldhew@gmail.com>
 
 	Move PostScript drivers' property handlers to `base'.
 
 	This reduces the amount of duplicated code across PostScript
 	drivers.
 
 	* src/cff/cffdrivr.c, src/cid/cidriver.c, src/type1/t1driver.c
 	({cff,cid,t1}_property_{get,set}): Moved to...
 	* include/freetype/internal/ftpsprop.h: ...this new file.
 	(ps_property_{get,set}): New functions to replace moved ones.
 
 	* src/base/ftpsprop.c: New file that implements above functions.
 
 	* include/freetype/internal/internal.h
 	(FT_INTERNAL_POSTSCRIPT_PROPS_H): New macro.
 
 	* src/cff/cffdrivr.c, src/cid/cidriver.c, src/type1/t1driver.c:
 	Updated.
 
 	* src/base/Jamfile, src/base/rules.mk (BASE_SRC), src/base/ftbase.c:
 	Updated.
 
 2017-12-20  Werner Lemberg  <wl@gnu.org>
 
 	Speed up FT_Set_Var_{Design,Blend}_Coordinates if curr == new.
 
 	We exit early if the current design or blend coordinates are
 	identical to the new ones.
 
 	* src/truetype/ttgxvar.c (tt_set_mm_blend, TT_Set_Var_Design):
 	Implement it, returning internal error code -1 if there will be no
 	variation change.
 
 	* src/type1/t1load.c (t1_set_mm_blend): Ditto.
 
 	* src/base/ftmm.c (FT_Set_Var_Design_Coordinates,
 	FT_Set_MM_Blend_Coordinates, FT_Set_Var_Blend_Coordinates): Updated.
 
 2017-12-18  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Fix charmap type 2 iterator (#52646).
 
 	The subsetted demo font of the report that exhibits the bug has a
 	very unusual type 2 cmap for Unicode(!): It contains only two
 	sub-headers, one for one-byte characters (covering the range 0x20 to
 	0xFA), and a second one for higher byte 0x01 (just for character
 	code U+0131).
 
 	Before this commit, the iterator wasn't able to correctly handle a
 	sub-header for higher byte 0x01.
 
 	* src/sfnt/ttcmap.c (tt_cmap2_char_next): Fix character increment
 	for outer loop.
 
 2017-12-18  Matthias Clasen  <matthias.clasen@gmail.com>
 
 	[truetype] Fix clamping, minor tracing code beautification.
 
 	* src/truetype/ttgxvar.c (ft_var_to_normalized): Trace number of
 	design coordinates.
 	Use clamped value.
 
 2017-12-18  Werner Lemberg  <wl@gnu.org>
 
 	* src/*/*: Only use `ft_' and `FT_' variants of stdc library stuff.
 
 2017-12-18  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttgxvar.c (tt_face_vary_cvt): Add size guard (#52688).
 
 2017-12-18  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Fix previous commit.
 
 	* src/truetype/ttgload.c (TT_Process_Simple_Glyph): Correctly handle
 	unhinted phantom points, which must be properly scaled.
 
 2017-12-18  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Don't apply HVAR and VVAR deltas twice (#52683).
 
 	* src/truetype/ttgload.c (TT_Process_Simple_Glyph): Always adjust
 	`pp1' to `pp4', except if we have an HVAR and/or VVAR table.
 
 	* src/truetype/ttgxvar.c (TT_Vary_Apply_Glyph_Deltas): Handle
 	alternative code branch identically w.r.t. presence of an HVAR
 	and/or VVAR table.
 
 2017-12-17  Jonathan Kew  <jfkthame@gmail.com>
 
 	[truetype] Correctly handle variation font phantom points (#52683).
 
 	* src/truetype/ttgxvar.c (TT_Vary_Apply_Glyph_Deltas): Fix phantom
 	point indices.
 
 2017-12-17  Jonathan Kew  <jfkthame@gmail.com>
 
 	Fix incorrect advance width scaling (#52683).
 
 	* src/base/ftadvance.c (FT_Get_Advances): Always respect the
 	FT_LOAD_NO_SCALE flag if present.
 
 2017-12-16  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* builds/windows/vc2010/freetype.vcxproj: AfterBuild copy.
 	* objs/.gitignore: Ignore almost everything.
 
 2017-12-11  Werner Lemberg  <wl@gnu.org>
 
 	Fix compiler warning (#52640).
 
 	* src/base/ftbitmap.c (ft_bitmap_assure_buffer): Remove unused
 	variable.
 
 2017-12-08  Azzuro  <azzuro@team-mediaportal.com>
 
 	* builds/windows/vc2010/freetype.vcxproj: Adjust output directory.
 
 	This allows builds with different configurations in parallel.
 
 2017-12-08  Werner Lemberg  <wl@gnu.org>
 
 	Fix `make setup dos', second try (#52622).
 
 	* builds/detect.mk (dos_setup): Don't use literal `>' character at
 	all.  Mixing the different escaping rules from make, dos, and
 	windows is too fragile.
 
 2017-12-08  Werner Lemberg  <wl@gnu.org>
 
 	[docmaker] Fix code section parsing.
 
 	Stuff like
 
 	  {
 	    <bla>
 	  }
 
 	confused the parser, which incorrectly treated `<bla>' as a markup
 	tag.
 
 	* src/tools/docmaker/content.py (ContentProcessor::process_content):
 	Apply `re_markup_tags' only outside of code sections.
 
 2017-12-08  Werner Lemberg  <wl@gnu.org>
 
 	New `ftdriver.h' file, covering all driver modules.
 
 	This reduces redundancy and increases synergy; it also reduces the
 	number of header files.
 
 	* include/freetype/config/ftheader.h (FT_DRIVER_H): New macro.
 	(FT_AUTOHINTER_H, FT_CFF_DRIVER_H, FT_TRUETYPE_DRIVER_H,
 	FT_PCF_DRIVER_H, FT_TYPE1_DRIVER_H): Make them aliases to
 	FT_DRIVER_H.
 
 	* include/freetype/ftautoh.h, include/freetype/ftcffdrv.h,
 	include/freetype/ftpcfdrv.h, include/freetype/ftt1drv.h,
 	include/freetype/ftttdrv.h: Replaced with...
 	* include/freetype/ftdriver.h: ...this new file.
 	(FT_CFF_HINTING_ADOBE, FT_T1_HINTING_ADOBE): Renamed to...
 	(FT_HINTING_ADOBE): ... this new macro.
 	(FT_CFF_HINTING_FREETYPE, FT_T1_HINTING_FREETYPE): Renamed to...
 	(FT_HINTING_FREETYPE): ... this new macro.
 
 	* src/*/*: Updated accordingly.
 
 2017-12-08  Werner Lemberg  <wl@gnu.org>
 
 	Move `ftdriver.h' to `ftdrv.h'.
 
 	* include/freetype/internal/ftdriver.h: Renamed to...
 	* include/freetype/internal/ftdrv.h: ... this name.
 
 	* include/freetype/internal/internal.h (FT_INTERNAL_DRIVER_H):
 	Updated.
 
 2017-12-08  Werner Lemberg  <wl@gnu.org>
 
 	Fix access to uninitalized memory (#52613).
 
 	Also reported as
 
 	  https://bugs.chromium.org/p/chromium/issues/detail?id=791317
 
 	* src/base/ftbitmap.c (ft_bitmap_assure_buffer): If increasing the
 	bitmap size needs a larger bitmap buffer, assure that the new memory
 	areas are initialized also.
 
 2017-12-08  Werner Lemberg  <wl@gnu.org>
 
 	Fix `make setup dos' (#52622).
 
 	* builds/detect.mk (dos_setup): Properly escape literal `>'
 	character.
 
 2017-12-07  Werner Lemberg  <wl@gnu.org>
 
 	Fix C++ compilation.
 
 	* src/psaux/psauxmod.h: Use FT_CALLBACK_TABLE macro where necessary.
 
 	* src/smooth/ftsmooth.c (ft_smooth_render_generic): Fix warning.
 
 2017-12-07  Werner Lemberg  <wl@gnu.org>
 
 	Fix `make multi'.
 
 	* include/freetype/internal/fttrace.h: Remove unused tracing macros.
 	s/pshalgo2/pshalgo/.
 	Add `trace_cffdecode'.
 	* src/pshinter/pshalgo.c (FT_COMPONENT): Updated.
 
 	* src/cff/cffload.c: Include FT_INTERNAL_POSTSCRIPT_AUX_H.
 	* src/cff/cffobjs.c: Include FT_SERVICE_METRICS_VARIATIONS_H and
 	FT_SERVICE_CFF_TABLE_LOAD_H.
 
 	* src/cid/cidriver.c: Include FT_INTERNAL_POSTSCRIPT_AUX_H.
 
 	* src/psaux/cffdecode.c: Include FT_FREETYPE_H and
 	FT_INTERNAL_DEBUG_H.
 	(FT_COMPONENT): Define.
 	* src/psaux/cffdecode.h: Include FT_INTERNAL_POSTSCRIPT_AUX_H.
 	* src/psaux/psauxmod.h: Include FT_INTERNAL_POSTSCRIPT_AUX_H.
 	Declare `cff_builder_funcs' and `ps_builder_funcs'.
 	* src/psaux/psft.c: Include `psobjs.h' and `cffdecode.h'.
 	* src/psaux/psobjs.c : Include `psauxmod.h'.
 
 2017-12-07  Werner Lemberg  <wl@gnu.org>
 
 	* include/freetype/config/ftheader.h: Some clean-up.
 
 	This commit removes documentation of deprecated macros and does some
 	minor streamlining.
 
 2017-12-06  Werner Lemberg  <wl@gnu.org>
 
 	* builds/symbian/bld.inf: Updated.
 
 2017-12-06  Werner Lemberg  <wl@gnu.org>
 
 	New header file `ftparams.h' that collects all parameter tags.
 
 	* include/freetype/config/ftheader.h (FT_PARAMETER_TAGS_H): New
 	macro.
 	(FT_TRUETYPE_UNPATENTED_H, FT_UNPATENTED_HINTING_H): Define it to
 	`ftparams.h'.
 
 	* include/freetype/ftautoh.h, include/freetype/ftcffdrv.h,
 	include/freetype/ftincrem.h, include/freetype/ftlcdfil.h,
 	include/freetype/ftsnames.h, include/freetype/ftt1drv.h: Include
 	FT_PARAMETER_TAGS_H.
 	Move FT_PARAM_TAG_XXX definitions to...
 	* include/freetype/ftparams.h: ...this new file.
 
 	* include/freetype/ttunpat.h: Remove.  No longer needed.
 
 2017-12-05  Werner Lemberg  <wl@gnu.org>
 
 	Improve tracing messages by using singular and plural forms.
 
 	* src/*/*.c: Implement it.
 
 2017-12-04  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Allow shared points in `cvar' table (#52532).
 
 	* src/truetype/ttgxvar.c (tt_face_vary_cvt): Implement it by copying
 	and adjusting the corresponding code from
 	`TT_Vary_Apply_Glyph_Deltas'.
 
 2017-11-28  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Improving tracing of composite glyphs.
 
 	* src/truetype/ttgload.c (TT_Load_Composite_Glyph)
 	[FT_DEBUG_LEVEL_TRACE]: Show composite glyph information.
 
 2017-11-27  Werner Lemberg  <wl@gnu.org>
 
 	[type1] Allow (again) `/Encoding' with >256 elements (#52464).
 
 	In version 2.6.1, this has been disallowed to better reject
 	malformed fonts; however, this restriction was too strong.  This
 	time, we only take the first 256 elements into account, since
 	encoding arrays are always accessed with a 8bit integer, according
 	to the PostScript Language Reference.
 
 	* src/type1/t1load.c (parse_encoding): Implement it.
 
 2017-11-27  Jan Alexander Steffens (heftig)  <jan.steffens@gmail.com>
 
 	Fix last commit (#52522).
 
 	* builds/freetype.mk: Set `FT_OPTION_H' and `FTOPTION_FLAG'
 	properly if we have `ftoption.h' in `BUILD_DIR'.
 
 2017-11-24  Werner Lemberg  <wl@gnu.org>
 
 	[unix] Install a massaged `ftoption.h' file (#51780).
 
 	* builds/unix/configure.raw (ftoption_set, ftoption_unset): New
 	auxiliary functions to construct...
 	(FTOPTION_H_SED): ... this new variable.
 	Apply it as a sed argument while copying `ftoption.h' to the
 	`builds/unix' directory (using `AC_CONFIG_FILES').
 	Simplify code of test that checks cpp's computation of bit length
 	(the test previously created an empty `ftoption.h' file and deleted
 	it immediately afterwards); without this change, it can happen on my
 	GNU/Linux box that `configure's execution of `config.status' doesn't
 	create `ftoption.h' (no idea why this happens).
 
 	* builds/unix/install.mk (install): Install
 	`builds/unix/ftoption.h'.
 
 	* builds/unix/unix-def.in (DISTCLEAN): Updated.
 
 	* builds/unix/.gitignore: Updated.
 
 2017-11-23  Tor Andersson  <tor.andersson@artifex.com>
 
 	Silence unused function warnings (#52465).
 
 	Some static function declarations cause unused function warnings if
 	certain config options are turned off via `ftoption.h'.
 
 	* src/base/ftbase.h, src/base/ftrfork.c, src/sfnt/ttbdf.h,
 	src/truetype/ttgxvar.h: Add #ifdef guards around these sections.
 
 2017-11-22  Ewald Hew  <ewaldhew@gmail.com>
 
 	* src/psaux/psft.c (cf2_setGlyphWidth): Check format before setting.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=4377
 
 2017-11-22  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux] Fix CFF advance widths. (#52466)
 
 	Glyph advance widths were being written to the new `PS_Decoder' but not
 	saved to the underlying format specific decoder. This caused pure CFF
 	fonts to have bad advance width.
 
 	* include/freetype/internal/psaux.h (PS_Decoder): Change `glyph_width'
 	field to pointer.
 	Remove unused fields.
 	* src/psaux/psobjs.c (ps_decoder_init): Change `glyph_width' from copy
 	to reference.
 	Remove unused.
 	* src/psaux/psft.c (cf2_setGlyphWidth): Update code.
 
 2017-11-15  Vlad Tsyrklevich  <vtsyrklevich@google.com>
 
 	* include/freetype/ftrender.h: Fix `FT_Renderer_RenderFunc' type.
 
 2017-11-14  Nikolaus Waxweiler  <madigens@gmail.com>
 
 	Use Adobe hinting engine for `light' hinting of both CFF and Type 1.
 
 	Since Ewald Hew factored the Adobe hinting engine out of the CFF
 	driver code, we can now use it on Type 1 (and CID) font formats, as
 	both have the same hinting philosophy.
 
 	This change activates the Adobe hinter when in LIGHT mode, and
 	therefore always unless explicitly asking for the auto-hinter.  This
 	makes LIGHT behavior consistent with CFF fonts.  As of this commit,
 	the hinting engine table looks as follows.
 
 	             LIGHT  NORMAL
 	  -------------------------
 	   TrueType  Auto   v40
 	   CFF       Adobe  Adobe
 	   Type 1    Adobe  Adobe
 
 2017-11-10  Yuri Levchenko  <yuri_levchenko@boolat.com>
 
 	* CMakeLists.txt: Add `DISABLE_FORCE_DEBUG_PREFIX' option.
 
 2017-11-06  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/base/ftobjs.c (FT_Load_Glyph): Relocate condition.
 
 2017-11-06  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/smooth/ftgrays.c (gray_set_cell): Fix uninitialized variables.
 
 2017-11-03  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux] Fix PostScript interpreter rewinding in Type 1 mode. (#52251)
 
 	The interpreter in Type 1 mode rewinds the charstring after collecting
 	all hints for building the initial hintmap (commit d52dd7f). However,
 	some charstrings use `endchar' in a final subroutine call, rewinding to
 	the start of that subroutine, and only a small section of the actual
 	glyph is drawn.
 
 	* src/psaux/psintrp.c (cf2_interpT2CharString) <cf2_cmdENDCHAR>:
 	Ensure we are on the top level charstring before rewinding.
 
 2017-11-03  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	[truetype] Add more tricky fonts.
 
 	See the report by Yang Yinsen.
 	https://lists.gnu.org/archive/html/freetype-devel/2017-11/msg00000.html
 
 	* src/truetype/ttobjs.c (trick_names): Add `DFGothic-EB',
 	`DFGyoSho-Lt', `DFHSGothic-W5', `DFHSMincho-W3' and `DFHSMincho-W7'.
 	(tt_check_trickyness_sfnt_ids): Add checksums for DFGothic-EB,
 	DFGyoSho-Lt, DFHSGothic-W5, DFHSMincho-W3 and DFHSMincho-W7.  Also
 	add checksums for DLCLiShu and DLCHayBold which their family names
 	were already listed but their checksums were previously unknown.
 
 2017-11-01  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Fix complex rendering at high ppem.
 
 	We used to split large glyphs into horizontal bands and continue
 	bisecting them still horizontally if that was not enough.  This is
 	guaranteed to fail when a single scanline cannot fit into the
 	rendering memory pool.  Now we bisect the bands vertically so that
 	the smallest unit is a column of the band height, which is guranteed
 	to fit into memory.
 
 	* src/smooth/ftgrays.c (gray_convert_glyph): Implement it.
 
 2017-10-20  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Improve complex rendering at high ppem.
 
 	At large sizes almost but not exactly horizontal segments can quickly
 	drain the rendering pool. This patch at least avoids filling the pool
 	with trivial cells. Beyond this, we can only increase the pool size.
 
 	Reported, analyzed, and tested by Colin Fahey.
 
 	* src/smooth/ftgrays.c (gray_set_cell): Do not record trivial cells.
 
 2017-10-20  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[base] Improve tracing in FT_Load_Glyph, FT_*_Size.
 
 	* src/base/ftobjs.c (FT_Load_Glyph): Tag tracing messages with
 	function name, glyph index, and load flags.
 	(FT_Select_Metrics, FT_Request_Metrics): Remove all tracing.
 	(FT_Select_Size, FT_Request_Size): Improve tracing.
 
 2017-10-18  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[base] Improve tracing in FT_Render_Glyph.
 
 	* src/base/ftobjs.c (FT_Render_Glyph_Internal): Add total coverage
 	calculations and downgrade Netpbm dump to bitmap:7.
 
 2017-10-15  Ewald Hew  <ewaldhew@gmail.com>
 
 	[cff] Fix segfault on missing `psaux' (#52218)
 
 	* src/cff/cffload.c (cff_done_blend): Add a check for possible nullptr.
 
 	* modules.cfg: Update dependency list.
 
 2017-10-15  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[base, cff] Fix MSVC warnings.
 
 	* src/base/ftobjs.c (FT_New_Library): C4702: unreachable code.
 	(ft_glyphslot_preset_bitmap): C4244: possible loss of data.
 	* src/cff/cffload.c (cff_blend_doBlend): C4244: possible loss of data.
 	Turn `sum' into unsigned.
 
 2017-10-14  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[base] Netpbm image tracing.
 
 	* src/base/ftobjs.c (FT_Load_Glyph): Trace bitmap size.
 	(FT_Render_Glyph_Internal): Trace bitmap in Netpbm format.
 
 	* src/smooth/ftgrays.c (gray_sweep): Sweep remnants of span tracing.
 
 2017-10-14  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* builds/windows/ftdebug.c (FT_Message): Print to stderr.
 	* builds/wince/ftdebug.c (FT_Message): Ditto.
 
 2017-10-14  Behdad Esfahbod  <behdad@behdad.org>
 
 	[afshaper] Delay creating `hb_set' objects until needed.
 
 	In runs on Noto Naskh Arabic, this results in 89 sets created
 	instead of 340 before.  Makes auto-hinter setup with HarfBuzz
 	enabled 20% to 30% faster.
 
 	* src/autofit/afshaper.c (af_shaper_get_coverage): Implement it.
 
 2017-10-12  Ewald Hew  <ewaldhew@gmail.com>
 
 	[type1, cid] Add hinting engine switch.
 
 	Implement property service in `type1' and `cid' drivers to allow
 	switching between FreeType or Adobe hinting engine when both are
 	available.
 
 	* src/cid/cidriver.c (cid_property_{set,get}, cid_services),
 	src/type1/t1driver.c (t1_property_{set,get}, t1_services): Add
 	Properties service.
 
 	* src/cid/cidobjs.c (cid_driver_init), src/type1/t1objs.c
 	(T1_Driver_Init): Add default property values.
 
 2017-10-12  Ewald Hew  <ewaldhew@gmail.com>
 
 	Add T1_CONFIG_OPTION_OLD_ENGINE configuration option.
 
 	This controls whether the old Type 1 engine gets compiled into FreeType.
 	It is disabled by default.
 
 	* devel/ftoption.h, include/freetype/config/ftoption.h
 	(T1_CONFIG_OPTION_OLD_ENGINE): New macro.
 
 	* include/freetype/internal/psaux.h (PS_Decoder): Remove unused field.
 	* include/freetype/internal/psaux.h, src/cid/cidgload.c
 	(cid_load_glyph), src/psaux/psauxmod.c, src/psaux/psobjs.c
 	(ps_builder_add_point), src/psaux/t1decode.c
 	(t1_lookup_glyph_by_stdcharcode, t1_decoder_parse_glyph,
 	t1operator_seac, t1_decoder_parse_charstrings), src/psaux/t1decode.h,
 	src/type1/t1gload.c (T1_Parse_Glyph_And_Get_Char_String): Surround
 	relevant code with macro.
 	Minor code changes.
 
 2017-10-12  Ewald Hew  <ewaldhew@gmail.com>
 
 	Extract width parsing from Type 1 parser.
 
 	Duplicate the fast advance width calculations from the old parser.
 	This is to facilitate adding options for compiling out the old parser.
 
 	* src/psaux/t1decode.{c,h} (t1_decoder_parse_metrics): New function.
 	* include/freetype/internal/psaux.h (T1_Decoder_Funcs): New entry
 	`parse_metrics'.
 	* src/psaux/psauxmod.c: Set the new entry.
 
 	* src/type1/t1gload.c (T1_Parse_Glyph_And_Get_Char_String),
 	src/cid/cidgload.c (cid_load_glyph): Separate
 	conditional for selecting engine.
 
 2017-10-09  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftoutln.c (FT_Outline_Translate): Fix integer overflow.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/chromium/issues/detail?id=772775
 
 2017-10-08  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftobjs.c (ft_glyphslot_preset_bitmap): Integer overflows.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=3579
 
 2017-10-07  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Adjust behaviour of PS font names for variation fonts.
 
 	* src/sfnt/sfdriver.c (sfnt_get_var_ps_name): Use a named instance's
 	PS name only if no variation is applied.
 
 2017-10-07  Werner Lemberg  <wl@gnu.org>
 
 	[cff, truetype] Adjust behaviour of named instances.
 
 	This commit completely separates the interaction between named
 	instances and variation functions.  In particular, resetting the
 	variation returns to the current named instance (if set) and not to
 	the base font.
 
 	As a side effect, variation functions no longer change the named
 	instance index.
 
 	* src/cff/cffobjs.c (cff_face_init): Use MM service's `set_instance'
 	function.
 	Also apply `MVAR' table to named instances.
 
 	* src/truetype/ttgxvar.c (TT_Get_MM_Var): Add cast.
 	(tt_set_mm_blend): No longer check whether requested variation
 	coincides with a named instance.
 	(TT_Set_Var_Design): Use current named instance for default
 	coordinates.
 	* src/truetype/ttobjs.c (tt_face_init): Use `TT_Set_Named_Instance'.
 
 2017-10-07  Werner Lemberg  <wl@gnu.org>
 
 	Make `FT_Set_Named_Instance' work.
 
 	* src/cff/cffdrivr.c (cff_set_instance): New function.
 	(cff_service_multi_masters): Register it.
 
 	* src/truetype/ttgxvar.c (TT_Set_Named_Instance): New function.
 	* src/truetype/ttgxvar.h: Updated.
 	* src/truetype/ttdriver.c (tt_service_gx_multi_masters): Register
 	it.
 
 	* src/type1/t1load.c (T1_Reset_MM_Blend): New function.
 	* src/type1/t1load.h: Updated.
 	* src/type1/t1driver.c (t1_service_multi_masters): Register it.
 
 2017-10-07  Werner Lemberg  <wl@gnu.org>
 
 	Make `FT_FACE_FLAG_VARIATION' work.
 
 	* include/freetype/internal/tttypes.h (TT_Face): Remove
 	`is_default_instance'; this can be replaced with a combination of
 	`FT_IS_VARIATION' and `FT_IS_INSTANCE'.
 
 	* src/cff/cffdrivr.c (cff_get_advances): Updated.
 
 	* src/sfnt/sfdriver.c (sfnt_get_ps_name), src/sfnt/sfobjs.c
 	(sfnt_init_face): Updated.
 
 	* src/truetype/ttdriver.c (tt_get_advances), src/truetype/ttgload.c
 	(TT_Process_Simple_Glyph, load_truetype_glyph, IS_DEFAULT_INSTANCE),
 	src/truetype/ttgxvar.c (tt_set_mm_blend): Updated.
 	* src/truetype/ttgxvar.c (TT_Set_MM_Blend, TT_Set_Var_Design):
 	Handle `FT_FACE_FLAG_VARIATION'.
 
 	* src/type1/t1load.c (T1_Set_MM_Blend, T1_Set_MM_Design): Handle
 	`FT_FACE_FLAG_VARIATION'.
 
 2017-10-07  Werner Lemberg  <wl@gnu.org>
 
 	New function `FT_Set_Named_Instance'.
 
 	No effect yet.
 
 	* src/base/ftmm.c (FT_Set_Named_Instance): New function.
 
 	* include/freetype/ftmm.h: Updated.
 
 2017-10-07  Werner Lemberg  <wl@gnu.org>
 
 	Add macros for checking whether a font variation is active.
 
 	* include/freetype/freetype.h (FT_FACE_FLAG_VARIATION,
 	FT_IS_VARIATION): New macros.
 	No effect yet.
 
 2017-10-07  Werner Lemberg  <wl@gnu.org>
 
 	Add framework for setting named instance in MM service.
 
 	* include/freetype/internal/services/svmm.h (FT_Set_Instance_Func):
 	New function typedef.
 	(MultiMasters): Add `set_instance' member.
 	(FT_DEFINE_SERVICE_MULTIMASTERSREC): Updated.
 
 	* src/cff/cffdrivr.c (cff_service_multi_masters),
 	src/truetype/ttdriver (tt_service_gx_multi_masters),
 	src/type1/t1driver.c (t1_service_multi_masters): Updated.
 
 2017-10-07  Werner Lemberg  <wl@gnu.org>
 
 	[type1] Minor code shuffling.
 
 	* src/type1/t1load.c (T1_Set_MM_Blend): Make it a wrapper of...
 	(t1_set_mm_blend): ...this new function.
 	(T1_Set_MM_Design): Use `t1_set_mm_blend'.
 
 2017-10-05  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftobjs.c (ft_glyphslot_preset_bitmap): Fix integer
 	overflow.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=3539
 
 2017-10-05  Werner Lemberg  <wl@gnu.org>
 
 	Fix compiler warnings.
 
 	* src/cff/cffdrivr.c (cff_ps_get_font_extra): Avoid code that relies
 	on numeric overflow.
 	Add cast.
 
 	* src/smooth/ftsmooth.c (ft_smooth_render_generic): Fix variable
 	types, add cast.
 
 2017-10-04  John Tytgat  <John.Tytgat@esko.com>
 
 	[cff] Add support for `FSType'.
 
 	* include/freetype/internal/cfftypes.h (CFF_FontRec): Add
 	`font_extra' entry.
 
 	* src/cff/cffdrivr.c (cff_ps_get_font_extra): New function to
 	retrieve FSType info from the embedded PostScript data.
 	(cff_service_ps_info): Register function.
 
 	* src/cff/cffload.c (cff_font_done): Free `font_extra'.
 
 2017-09-30  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	Signedness fixes in bitmap presetting.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=3514.
 
 	* src/raster/ftrend1.c (ft_raster1_render): Explicitly signed height.
 	* src/smooth/ftsmooth.c (ft_smooth_render_generic): Ditto.
 	* src/base/ftobjs.c (ft_glyphslot_preset_bitmap): Explicitly unsigned
 	subtraction.
 
 2017-09-29  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	Bitmap metrics presetting [2/2].
 
 	* src/base/ftobjs.c (FT_Load_Glyph): Preset the bitmap metrics when
 	appropriate but `FT_Render_Glyph' is not called.
 	* include/freetype/freetype.h (FT_GlyphSlotRec): Document the change.
 
 2017-09-28  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth, raster] Miscellaneous cleanups.
 
 	* src/raster/ftrend1.c (ft_raster1_render): Clean up the exit.
 	* src/smooth/ftsmooth.c (ft_smooth_render_generic): Reduce
 	translations and clean up the exit.
 	(ft_smooth_render_lcd, ft_smooth_render_lcd): Remove unused `error'.
 
 2017-09-28  Ben Wagner  <bungeman@google.com>
 
 	[truetype] Really, really fix #52082.
 
 	* src/truetype/ttinterp.c (Ins_MDRP): Correct conditional.
 
 2017-09-28  Werner Lemberg  <wl@gnu.org>
 
 	* src/psaux/psintrp.c (cf2_doStems): Fix integer overflow.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=3510
 
 2017-09-28  Ewald Hew  <ewaldhew@gmail.com>
 
 	* src/cid/cidgload.c (cid_slot_load_glyph): Fix memory leak.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=3489
 
 2017-09-28  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	Bitmap metrics presetting [1/2].
 
 	This mainly just extracts the code for presetting the bitmap metrics
 	from the monochrome, grayscale, and LCD renderers into a separate
 	function.
 
 	* src/base/ftobjs.c (ft_glyphslot_preset_bitmap): New function that
 	calculates prospective bitmap metrics for the given rendering mode.
 	* include/freetype/internal/ftobjs.h (ft_glyphslot_preset_bitmap):
 	Declare it.
 
 	* src/base/ftlcdfil.c (ft_lcd_padding): New helper function that adds
 	padding to CBox taking into account pecularities of LCD rendering.
 	* include/freetype/ftlcdfil.h (ft_lcd_padding): Declare it.
 
 	* src/raster/ftrend1.c (ft_raster1_render): Reworked to use
 	`ft_glyphslot_preset_bitmap'.
 	* src/smooth/ftsmooth.c (ft_smooth_render_generic): Ditto.
 	(ft_smooth_render_lcd, ft_smooth_render_lcd): The pixel_mode setting
 	is moved to `ft_glyphslot_preset_bitmap'.
 
 2017-09-28  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux] Fix compiler warning.
 
 	* src/psaux/pshints.c (cf2_hintmap_dump): Add switch for tracing
 	code.
 
 2017-09-27  Werner Lemberg  <wl@gnu.org>
 
 	* src/sfnt/ttload.c (tt_face_load_font_dir): Fix compiler warning.
 
 2017-09-25  Werner Lemberg  <wl@gnu.org>
 
 	[psaux] Fix compiler warnings.
 
 	* src/psaux/psft.c (cf2_initLocalRegionBuffer): Remove redundant
 	test.
 
 	* src/psaux/psintrp.c (cf2_interpT2CharString)
 	<cf2_escCALLOTHERSUBR>: Add casts.
 
 	* src/psaux/psobjs.c (ps_decoder_init): Add cast.
 
 2017-09-25  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux] Minor fixes.
 
 	* include/freetype/internal/psaux.h, src/psaux/psobjs.{c,h}:
 	Rearrange `ps_builder_init' arguments to conventional order.
 
 	* src/psaux/psft.c (cf2_decoder_parse_charstrings): Add a check and
 	notice for `SubFont' in Type 1 mode.
 
 2017-09-25  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux] Move `psdecode' into `psobjs'.
 
 	As the former only contains a single procedure, move it into
 	`psobjs' for simplicity.  Also change the parameter order to the
 	conventional one.
 
 	* src/psaux/psdecode.c (ps_decoder_init): Moved to...
 	* src/psaux/psobjs.c: ...Here.
 	* src/psaux/psdecode.h, src/psaux/psobjs.h: Ditto.
 
 	* include/freetype/internal/psaux.h (PSAux_ServiceRec): Update
 	`ps_decoder_init' function signature.
 
 	* src/cff/cffgload.c, src/cid/cidgload.c, src/type1/t1gload.c:
 	Update calls.
 
 	* src/psaux/psaux.c, src/psaux/psauxmod.c: Update includes.
 
 	* src/psaux/Jamfile (_sources), src/psaux/rules.mk (PSAUX_DRV_SRC):
 	Update file references.
 
 2017-09-25  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux] Fix Type 1 hinting.
 
 	Type 1 hinting breaks sometimes when mid-charstring hints should
 	have been in the initial hintmap.  This fix adds a preprocessing
 	pass that reads all hints and builds the correct initial hintmap
 	first, before proceeding to build the glyph outline.
 
 	* src/psaux/psintrp.c (cf2_interpT2CharString): New
 	`initial_map_ready' boolean flag.
 	Ignore outline commands and hint changes on first pass.
 	<cf2_cmdENDCHAR>: Add section to build hintmap and rewind.
 
 2017-09-25  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux] Add tracing for hints.
 
 	* src/psaux/pshints.c (cf2_hintmap_dump): New function.
 	(cf2_hintmap_insertHint): Trace incoming and inserted hints.
 	(cf2_hintmap_build): Dump hintmap before and after hint adjustment.
 
 2017-09-25  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux] Minor fixes.
 
 	* src/psaux/psintrp.c (cf2_interpT2CharString): Fix check for pop
 	results.
 	s/font->decoder/decoder/ where necessary.
 	<cf2_cmdHSTEM, cf2_cmdVSTEM, cf2_escHSTEM3, cf2_escVSTEM3>: Use
 	offset parameter in `cf2_doStems' instead of doing correction for
 	left-sidebearing.
 
 2017-09-25  Ewald Hew  <ewaldhew@gmail.com>
 
 	[cid] Use the new engine.
 
 	* src/cid/cidgload.c: Update includes.
 	(cid_load_glyph, cid_slot_load_glyph): Implement changes to glyph
 	loading code as with `type1' module.
 
 2017-09-25  Ewald Hew  <ewaldhew@gmail.com>
 
 	[cid] Add Adobe engine configuration.
 
 	This is similar to what was done in the `type1' module.
 
 	* src/cid/cidriver.c (t1cid_driver_class): Update declaration.
 	* src/cid/cidobjs.c: Include FT_TYPE1_DRIVER_H.
 	(cid_driver_init): Update code.
 
 2017-09-25  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux] Change subfont synthesis for CID fonts.
 
 	Change `t1_make_subfont' to take in the Private dict record as an
 	argument.  This is because Type 1 and CID font records in FreeType
 	have this in different places.
 
 	* src/psaux/psobjs.c (t1_make_subfont): Change `T1_Face' to
 	`FT_Face' so that CID is also accepted.
 	Take `PS_Private' as an argument and let caller figure out where the
 	Private dict actually is.
 	Update references.
 
 	* include/freetype/internal/psaux.h, src/psaux/psobjs.h: Update
 	declaration.
 
 	* src/type1/t1gload.c (T1_Parse_Glyph_And_Get_Char_String): Update
 	call.
 
 2017-09-25  Ewald Hew  <ewaldhew@gmail.com>
 
 	[type1] Switch to Adobe engine.
 
 	* src/type1/t1objs.c (T1_Driver_Init): Set default to Adobe engine.
 
 2017-09-25  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux] Extend Adobe interpreter (seac).
 
 	This concludes the changes needed to add Type 1 support.
 
 	* src/psaux/psintrp.c: Update includes.
 	(cf2_interpT2CharString) <cf2_escSEAC>: Implement this similarly to
 	implied seac for CFF.
 
 	* src/psaux/t1decode.c (t1_lookup_glyph_by_stdcharcode_ps): New
 	function to look up the glyph index.
 
 	* src/psaux/psft.c (cf2_getT1SeacComponent,
 	cf2_freeT1SeacComponent): New functions to get the charstrings for
 	seac components.
 
 	* src/psaux/t1decode.h, src/psaux/psft.h: Update declarations.
 
 2017-09-25  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux] Extend Adobe interpreter (flex in callothersubr).
 
 	* src/psaux/psintrp.c (cf2_interpT2CharString)
 	<cf2_escCALLOTHERSUBR>: Fix Flex feature handling (OtherSubrs 0, 1,
 	2).
 	<cf2_cmdRMOVETO>: Do not actually move the `glyphPath' while doing
 	flex.  This is to avoid closing the current contour.
 
 2017-09-25  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux] Extend Adobe interpreter (callothersubr).
 
 	* src/psaux/psintrp.c (cf2_interpT2CharString)
 	<cf2_escCALLOTHERSUBR>: Copy code from
 	`t1_decoder_parse_charstrings' (in `t1decode.c').
 	OtherSubr 3 (change hints) should reset the hintmask, so that the
 	new hints are applied.
 	Fix function calls and stack access.
 
 2017-09-25  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux] Extend Adobe interpreter (pop).
 
 	* src/psaux/psintrp.c (cf2_interpT2CharString): Change how unhandled
 	OtherSubr results are stored.  Implement the PostScript stack using
 	an array.
 	<cf2_escPOP>: Ensure that the stack is not cleared after getting
 	`OtherSubr' results.
 	Fix stack access.
 
 2017-09-25  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux] Extend Adobe interpreter (callsubr).
 
 	* src/psaux/psintrp.c (cf2_interpT2CharString) <cf2_cmdCALLSUBR>:
 	Type 1 mode.
 
 	* src/psaux/psft.c (cf2_initLocalRegionBuffer): Add Type 1 mode.
 
 2017-09-25  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux] Extend Adobe interpreter (div, four-byte numbers).
 
 	* src/psaux/psintrp.c (cf2_interpT2CharString) <cf2_escDIV>: Add
 	Type 1 mode.  Type 1 requires large integers to be followed by
 	`div'; cf. `Adobe Type 1 Font Format', section 6.2.
 	<op == 255>: Push Type 1 four-byte numbers as `Int' always.  This is
 	to ensure `div' and `callsubr' get values they can use.
 
 2017-09-25  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux] Extend Adobe interpreter (hints).
 
 	* src/psaux/psintrp.c (cf2_interpT2CharString) <cf2_cmdHSTEM,
 	cf2_cmdVSTEM>: Add correction for left sidebearing in Type 1 mode.
 	Allow adding hints mid-charstring.
 	<cf2_escVSTEM3, cf2_escHSTEM3>: Translate into equivalent commands
 	for three normal stem hints.  This requires some recalculation of
 	stem positions.
 	Correction for left sidebearing.
 
 2017-09-25  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux] Extend Adobe interpreter (hsbw, sbw).
 
 	* src/psaux/psintrp.c (cf2_doStems): `hsbw' or `sbw' must be the
 	first operation in a Type 1 charstring.
 	(cf2_interpT2CharString): Remove unused variables.
 	<cf2_cmdHMOVETO, cf2_cmdVMOVETO, cf2_cmdRMOVETO>: `hsbw' or `sbw'
 	must be the first operation in a Type 1 charstring.
 	<cf2_cmdHSBW, cf2_escSBW>: Fix data access and add correction for
 	left sidebearing.
 
 2017-09-25  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux] Extend Adobe interpreter (setcurrentpoint).
 
 	* src/psaux/psintrp.c (cf2_interpT2CharString)
 	<cf2_escSETCURRENTPT>: Fix stack access.
 
 2017-09-25  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux] Extend Adobe interpreter (closepath).
 
 	* src/psaux/psintrp.c (cf2_interpT2CharString) <c2f_cmdCLOSEPATH>:
 	Use the right builder function.  We can use the `haveWidth' boolean
 	already present, instead of implementing `parse_state'.
 
 2017-09-25  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux] Add Type 1 operations to Adobe CFF interpreter.
 
 	The following Type 1 specific ops have been added (copied from
 	`t1decode'):
 
 	  closepath
 	  vstem3
 	  hstem3
 	  seac
 	  sbw
 	  callothersubr
 	  pop
 	  setcurrentpoint
 	  hsbw
 
 	The following require a Type 1 mode, because of differences in
 	specification:
 
 	  hstem
 	  vstem
 	  vmoveto
 	  callsubr
 	  div
 	  rmoveto
 	  hmoveto
 	  Numbers
 
 	The subsequent commits will implement these changes and adapt
 	accesses of data and objects to the new interpreter.
 
 	NOTE: Will not compile in the meantime!
 
 	* src/psaux/psintrp.c: Add opcodes to enum.
 	(cf2_interpT2CharString): Copy relevant code over from
 	`t1_decoder_parse_charstrings' (in `t1decode.c').
 
 2017-09-25  Ewald Hew  <ewaldhew@gmail.com>
 
 	[type1] Fixes for rendering.
 
 	The Type 1 advance width calculation passes null for glyph slot,
 	etc, which can cause null pointer access in the new interpreter.
 	Fall back to the old one for now.
 
 	Fix the large glyph retry code and ensure hinting and scaling flags
 	are set properly.
 
 	* src/type1/t1gload.c (T1_Parse_Glyph_And_Get_Char_String): Add a
 	check for metrics_only.
 	Set the `force_scaling' flag.
 	(T1_Parse_Glyph): Updated.
 	(T1_Load_Glyph): Add `hinting' and `scaled' flags.
 
 2017-09-25  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux] Add missing objects (2/2).
 
 	Synthesize a `SubFont' object for Type 1 fonts.  This is used in the
 	interpreter to access Private dict data, which are stored in
 	different places for Type 1 and CFF.  This allows the same data to
 	be used in either mode.
 
 	* src/psaux/psobjs.c (t1_make_subfont): New procedure to copy
 	required values to a dummy `CFF_SubFont' object.  This is similar to
 	`cff_make_private_dict'.
 	* src/psaux/psobjs.h: Add the new declaration.
 
 	* include/freetype/internal/psaux.h, src/psaux/psauxmod.c: Ditto.
 	Add this to the PSAux Service for future use with CID fonts.
 
 	* src/type1/t1gload.c: Include FT_INTERNAL_CFF_TYPES_H.
 	(T1_Parse_Glyph_And_Get_Char_String): Add the call.
 
 2017-09-25  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux] Add missing objects for Type 1 (1/2).
 
 	Move `CF2_Font' instance to `PS_Decoder'.  This is the context for
 	the interpreter and since it is currently stored in `CFF_Font', is
 	unavailable in Type 1 mode.
 
 	* include/freetype/internal/psaux.h (T1_Decoder, PS_Decoder): New
 	`cf2_instance' field.
 
 	* src/psaux/psdecode.c (ps_decoder_init): Copy `cf2_instance' to
 	`PS_Decoder'.
 
 	* src/psaux/t1decode.c (t1_decoder_done): Add finalization code.
 
 	* src/psaux/psft.c (cf2_decoder_parse_charstrings): Update accesses.
 
 2017-09-25  Ewald Hew  <ewaldhew@gmail.com>
 
 	Allow `type1' module to use the Adobe engine.
 
 	Add the callback and some conditionals to switch between the two
 	engines.
 
 	* include/freetype/internal/psaux.h (T1_Decoder_FuncsRec): Change
 	function declarations.
 	* src/psaux/psauxmod.c (T1_Decoder_FuncsRec): Register the
 	callbacks.
 
 	* src/psaux/psobjs.c (ps_builder_add_point): Add conditionals for
 	number conversion.
 
 	* src/type1/t1gload.c (T1_Parse_Glyph_And_Get_Char_String): Add code
 	to choose which renderer to use.
 
 	* src/cid/cidgload.c (cid_load_glyph): Update call.
 	* src/base/ftobjs.c, src/psaux/psobjs.c, src/type1/t1gload.c: Update
 	includes.
 
 2017-09-25  Ewald Hew  <ewaldhew@gmail.com>
 
 	[type1] Add Adobe engine configuration.
 
 	Use the previously changed PS_Driver in type1 module to store
 	hinting engine configuration.
 
 	* include/freetype/ftt1drv.h: New file.
 	Duplicate and rename config options from CFF.
 	* include/freetype/config/ftheader.h (FT_TYPE1_DRIVER_H): New macro.
 
 	* src/type1/t1driver.c (t1_driver_class): Update declaration.
 	* src/type1/t1objs.c: Include FT_TYPE1_DRIVER_H.
 	(T1_Driver_Init): Update code.
 
 2017-09-25  Ewald Hew  <ewaldhew@gmail.com>
 
 	[cff] Move and rename `CFF_Driver'.
 
 	This is so that we can use the same hinting engine parameters for
 	Type 1.
 
 	* include/freetype/internal/cffotypes.h (CFF_Driver): Rename and
 	move to...
 	* include/freetype/internal/psaux.h (PS_Driver): ...here.
 
 	* src/cff/cffdrivr.c, src/cff/cffgload.c, src/cff/cffload.c,
 	src/cff/cffobjs.c, src/cff/cffobjs.h, src/psaux/psft.c,
 	src/psaux/psobjs.c: Update references.
 
 2017-09-25  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux, type1] Reorganize object fields.
 
 	Make some fields more generic, so that we can access them the same
 	way regardless of Type 1 or CFF.
 
 	* include/freetype/internal/psaux.h (PS_Builder): Change `TT_Face'
 	to `FT_Face'.
 	Remove unused fields.
 
 	* src/psaux/psft.c: Update all accesses of `PS_Builder.face'.
 	Add some asserts to guard against casting `T1_Face' as `TT_Face'.
 
 	* src/type1/t1objs.h (T1_GlyphSlot): Reorder fields to follow
 	`CFF_GlyphSlot', so that we can pretend they are the same in the
 	interpreter.
 
 	* src/psaux/psobjs.c (ps_builder_init, ps_builder_add_point):
 	Updated with above changes.
 
 2017-09-25  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux] Prepare for Type 1 mode.
 
 	Add some checks for Type 1 data passing through.
 
 	* src/psaux/psfont.h (CF2_Font): Add `isT1' flag.
 	* src/psaux/psfont.c (cf2_font_setup): Skip the variations and blend
 	code which is not applicable for Type 1.
 
 	* src/psaux/psft.c (cf2_decoder_parse_charstrings): Avoid accessing
 	`decoder->cff' in Type 1 mode.
 	Copy `is_t1' flag to `CF2_Font'.
 
 2017-09-25  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux, cff] Use the new objects.
 
 	* include/freetype/internal/psaux.h, src/psaux/psauxmod.c: Fix
 	switching between new and old engines.
 
 	* src/cff/cffgload.c, src/cff/cffparse.c: Update calls.
 
 	* src/psaux/psblues.c, src/psaux/psfont.c, src/psaux/psfont.h,
 	src/psaux/psft.c, src/psaux/psft.h, src/psaux/psintrp.c: Update all
 	to use new objects.
 
 2017-09-24  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux] Objects for new interpreter (part 2).
 
 	Make the new objects copy over values.  They are essentially wrapper
 	types for the different decoders/builders.
 
 	* include/freetype/internal/psaux.h: Update declarations.
 	(PS_Builder): Add `is_t1' flag.
 	(PS_Decoder_{Get,Free}_Glyph_Callback): Renamed to...
 	(CFF_Decoder_{Get,Free}_Glyph_Callback: ... this.
 	(PS_Decoder): Updated.
 	Add `t1_parse_callback' member.
 	(PSAux_ServiceRec): Add `ps_decoder_init' member.
 
 	* src/psaux/psdecode.h, src/psaux/psobjs.h: Update declarations.
 
 	* src/psaux/psdecode.c, src/psaux/psobjs.c: Implement copy with two
 	modes.
 
 	* src/psaux/psauxmod.c: Add builder and decoder functions to `PSAux'
 	service.
 
 2017-09-24  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux] Add objects for new interpreter.
 
 	Introduce `PS_Decoder' and `PS_Builder' which include all fields
 	from either Type 1 or CFF decoders/builders.
 
 	* include/freetype/internal/psaux.h (PS_Builder, PS_Decoder): New
 	structs.
 
 	* src/psaux/psobjs.c, src/psaux/psobjs.h: Add `PS_Builder'
 	functions.
 
 	* src/psaux/psdecode.c, src/psaux/psdecode.h: New files to hold
 	`PS_Decoder' initialization functions.
 
 	* src/psaux/psaux.c, src/psaux/Jamfile (_sources),
 	src/psaux/rules.mk (PSAUX_DRV_SRC): Updated.
 
 2017-09-24  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux] Rename files.
 
 	Replace the `cf2' file name prefix with `ps' as the Adobe engine
 	will be used for both PostScript Types 1 and 2 (CFF) instead of just
 	CFF.
 
 	s/cf2/ps/ for all following.
 
 	* src/psaux/cf2*: Rename files.
 	* src/psaux/*: Update includes.
 
 	* src/psaux/Jamfile (_sources), src/psaux/rules.mk (PSAUX_DRC_SRC,
 	PSAUX_DRV_H): Update file references.
 
 2017-09-24  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux] Minor fix.
 
 	Use `MultiMasters' service in `psaux' instead of a call to `cff'.
 	The project builds if CFF_CONFIG_OPTION_OLD_ENGINE is not defined.
 
 	* src/psaux/cf2ft.c: Update includes.
 	(cf2_getNormalizedVector): Use `mm->get_var_blend' instead of
 	`cff_get_var_blend'.
 
 2017-09-24  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux, cff] Move `cff_random' into `psaux' service.
 
 	NOTE: Does not compile!
 
 	Minor fix to allow both `cff' and `psaux' to use `cff_random'.
 
 	* src/cff/cffload.c (cff_random): Move to...
 	* src/psaux/psobjs.c: Here.
 	* src/cff/cffload.h: Move corresponding declaration to
 	`src/psaux/psobjs.h'.
 
 	* include/freetype/internal/psaux.h (PSAux_ServiceRec): Register the
 	function here...
 	* src/psaux/psauxmod.c: And here.
 
 	* src/cff/cffload.c, src/psaux/cf2intrp.c: Update code.
 
 2017-09-24  Ewald Hew  <ewaldhew@gmail.com>
 
 	[cff] Move struct declarations to `freetype/internal'.
 
 	NOTE: Does not compile!
 
 	This is so that the CFF functions moved to `psaux' can access the
 	same structs that they need.
 
 	* src/cff/cfftypes.h: Moved to...
 	* include/freetype/internal/cfftypes.h: ...Here.
 
 	* src/cff/cffobjs.h: Moved the struct declarations to...
 	* include/freetype/internal/cffotypes.h: ... this new file.
 
 	* include/freetype/internal/internal.h (FT_INTERNAL_CFF_TYPES_H,
 	FT_INTERNAL_CFF_OBJECT_TYPES_H): New macros.
 
 	* src/cff/cffcmap.h, src/cff/cffdrivr.c, src/cff/cffgload.c,
 	src/cff/cffgload.h, src/cff/cffload.h, src/cff/cffobjs.c,
 	src/cff/cffobjs.h, src/cff/cffparse.h, src/psaux/psobjs.h,
 	include/freetype/internal/psaux.h,
 	include/freetype/internal/services/svcfftl.h: Update includes.
 
 	* src/cff/rules.mk (CFF_DRV_H): Updated.
 
 2017-09-24  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux, cff] Add new service for inter-module calls.
 
 	NOTE: Does not compile!
 
 	This is to allow CFF functions moved to `psaux' to call functions
 	declared in `src/cff/cffload.h'.
 
 	* include/freetype/internal/services/svcfftl.h: New file, setting up
 	a `CFFLoad' service.
 
 	* include/freetype/internal/ftserv.h (FT_DEFINE_SERVICEDESCREC10,
 	FT_DEFINE_SERVICEDESCREC): New macros.
 	(FT_SERVICE_CFF_TABLE_LOAD_H): New macro.
 
 	* src/cff/cffdrivr.c, src/cff/cffpic.h: Register the new service.
 
 	* src/cff/cfftypes.h (CFF_FontRec), src/psaux/cf2font.h
 	(CF2_FontRec): Add service interface.
 
 	* src/cff/cffobjs.c, src/psaux/cf2font.c, src/psaux/cf2ft.c,
 	src/psaux/cf2intrp.c, src/psaux/cffdecode.c: Use the new service.
 
 2017-09-24  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux, cff] Add callbacks for inter-module calls.
 
 	NOTE: Does not compile!
 
 	* include/freetype/internal/psaux.h: Add function pointer
 	declarations.
 
 	* src/psaux/cffdecode.c (cff_decoder_init): Update to take in
 	callbacks.
 	* src/psaux/cffdecode.h: Ditto.
 
 	* src/cff/cffgload.c (cff_compute_max_advance, cff_slot_load):
 	Update calls to pass in callbacks.
 	* src/psaux/cf2ft.c, src/psaux/cffdecode.c: Use them.
 
 2017-09-24  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux, cff] Create new `PSAux' service interface entries.
 
 	NOTE: Does not compile!
 
 	* include/freetype/internal/psaux.h: Include
 	FT_INTERNAL_TRUETYPE_TYPES_H.
 	(CFF_Builder_FuncsRec, CFF_Decocer_FuncsRec): New function tables.
 	(CFF_Builder): Updated.
 	Fix for forward declaration.
 	(PSAux_ServiceRec): New field `cff_decoder_funcs'.
 
 	* src/psaux/psauxmod.c (cff_builder_funcs, cff_decoder_funcs): New
 	function tables.
 	(PSAux_Interface): Updated.
 
 	* include/freetype/internal/tttypes.h (TT_FaceRec): Add `psaux'
 	service interface.
 
 	* src/cff/cffgload.c, src/cff/cffobjs.c, src/cff/cffparse.c: Update
 	function calls to use psaux service.
 
 2017-09-24  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux, cff] Move CFF builder components into `psaux' module.
 
 	NOTE: Does not compile!
 
 	* src/cff/cffgload.c
 	(cff_builder_{init,done,add_point,add_point1,add_contour,start_point,close_contour},
 	cff_check_points): Move to...
 	* src/psaux/psobjs.c: Here.
 
 	* src/cff/cffgload.h: Move corresponding declarations to
 	`src/psaux/psobjs.h'.
 
 	* src/cff/cffgload.h (CFF_Builder): Move struct declaration to...
 	* include/freetype/internal/psaux.h: Here.
 
 2017-09-24  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux, cff] Move CFF decoder components into `psaux' module.
 
 	NOTE: Does not compile!
 
 	* src/cff/cffgload.c (CFF_Operator,
 	CFF_COUNT_{CHECK_WIDTH,EXACT,CLEAR_STACK}, cff_argument_counts,
 	cff_operator_seac, cff_compute_bias,
 	cff_lookup_glyph_by_stdcharcode,
 	cff_decoder_{parse_charstrings,init,prepare}): Move to...
 	* src/psaux/cffdecode.c: This new file.
 
 	* src/cff/cffgload.h: Move corresponding declarations to...
 	* src/psaux/cffdecode.h: This new file.
 
 	* src/cff/cffgload.h (CFF_MAX_{OPERANDS,SUBRS_CALLS,TRANS_ELEMENTS},
 	CFF_Decoder_Zone, CFF_Decoder): Move declarations to...
 	* include/freetype/internal/psaux.h: Here.
 
 	* src/psaux/cf2ft.h: Update include.
 
 	* src/psaux/psaux.c, src/psaux/rules.mk (PSAUX_DRV_SRC): Update with
 	the new file.
 
 2017-09-24  Ewald Hew  <ewaldhew@gmail.com>
 
 	[psaux, cff] Move Adobe's engine components into `psaux' module.
 
 	This is the first patch of a sequence to move the Type 2 charstring
 	processing capability from the `cff' module to the `psaux' module.
 
 	NOTE: Does not compile!
 
 	* src/cff/cf2*: Move these files to...
 	* src/psaux/cf2*: Here.
 
 	* src/cff/Jamfile (_sources), src/cff/rules.mk (CFF_DRV_SRC,
 	CFF_DRV_H), src/cff/cff.c, src/cff/cffgload.c: Remove file
 	references.
 
 	* src/psaux/Jamfile (_sources), src/psaux/rules.mk, src/psaux/psaux.c
 	(PSAUX_DRV_SRC, PSAUX_DRV_H): Add file references.
 
 2017-09-24  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	Tweak per-face LCD filtering controls.
 
 	Thing are simpler with a NULL-function pointer.
 
 	* include/freetype/internal/ftobjs.h (FT_Face_InternalRec): New
 	pointer to the filter function.
 	(FT_LibraryRec): Remove unused `lcd_filter'.
 	(FT_Bitmap_LcdFilterFunc, ft_lcd_filter_fir):  Move from here...
 	* include/freetype/ftlcdfil.h (FT_Bitmap_LcdFilterFunc,
 	ft_lcd_filter_fir): ... to here.
 
 	* src/base/ftobjs.c (ft_open_face_internal): NULL-initialize the
 	per-face filter.
 	(FT_Face_Properties): Set it.
 	* src/smooth/ftsmooth.c (ft_smooth_render_generic): Simplify.
 
 	* src/base/ftlcdfil.c (ft_lcd_filter_fir, FT_Libary_SetLcdFilter):
 	Minor.
 
 2017-09-24  Jonathan Kew  <jfkthame@gmail.com>
 
 	[sfnt] Fix `premultiply_data' (#52092).
 
 	* src/sfnt/pngshim.c (premultiply_data): Don't use vector extension
 	if we have less than 16 bytes of data.
 
 2017-09-24  Werner Lemberg  <wl@gnu.org>
 
 	[otvalid] Fix handling of ValueRecords.
 
 	For GPOS pair positioning format 1 the description of ValueRecords
 	in the OpenType specification (1.8.2, from today) is wrong – the
 	offset has to be taken from the parent structure; in this case the
 	`PairSet' table.
 
 	* src/otvalid/otvgpos.c (otv_PairSet_validate): Set `extra3'.
 	(otv_PairPos_validate): Adjust.
 
 2017-09-23  Werner Lemberg  <wl@gnu.org>
 
 	[otvalid] Handle `GSUB' and `GPOS' v1.1 tables.
 
 	* src/otvalid/otvgsub.c (otv_GSUB_validate), src/otvalid/otvgpos.c
 	(otv_GPOS_validate): Implement it.
 
 2017-09-23  Werner Lemberg  <wl@gnu.org>
 
 	[otvalid] Update common table handling to OpenType 1.8.2.
 
 	* src/otvalid/otvcommn.c (otv_Device_validate): Handle
 	VariationIndex subtable.
 	(otv_Lookup_validate): Handle MarkFilteringSet.
 
 2017-09-23  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[build] Windows-style DLL versioning.
 
 	* build/windows/ftver.rc: New VERSIONINFO resource.
 	* build/windows/vc2010/freetype.vcxproj: Further improvements.
 
 2017-09-23  Ben Wagner  <bungeman@google.com>
 
 	[truetype] Really fix #52082.
 
 	* src/truetype/ttinterp.c (Ins_MDRP): Correct conditional.
 
 2017-09-23  Werner Lemberg  <wl@gnu.org>
 
 	[otvalid] Handle `GDEF' v1.2 and v1.3 tables.
 
 	No validation of variation stuff yet.
 
 	* src/otvalid/otvgdef.c (otv_MarkGlyphSets_validate): New function.
 	(otv_GDEF_validate): Implement it.
 
 2017-09-22  Werner Lemberg  <wl@gnu.org>
 
 	[otvalid] Handle `BASE' v1.1 table.
 
 	No validation of variation stuff yet.
 
 	* src/otvalid/otvbase.c (otv_BASE_validate): Implement it.
 
 2017-09-22  Werner Lemberg  <wl@gnu.org>
 
 	[otvalid] Macros for 32bit offset support.
 
 	* src/otvalid/otvcommn.h (OTV_OPTIONAL_TABLE32,
 	OTV_OPTIONAL_OFFSET32, OTV_SIZE_CHECK32): New macros.
 
 2017-09-21  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[build] Simplify Visual C++ 2010 project.
 
 	* build/windows/vc2010/freetype.vcxproj: Remove fake singlethreaded
 	configurations and tweak.
 
 2017-09-21  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Integer overflow (#52082).
 
 	* src/truetype/ttinterp.c (Ins_MDRP): Avoid FT_ABS.
 
 2017-09-21  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Fix postscript name for default instance of variation fonts.
 
 	Problem reported by Behdad.
 
 	* src/sfnt/sfdriver.c (sfnt_get_ps_name): Test
 	`is_default_instance'.
 
 2017-09-21  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Fix `mmvar' array pointers, part 2.
 
 	The previous commit was incomplete.
 
 	* src/truetype/ttgxvar.c: Properly initialize sub-array offsets for
 	`master' also.
 
 2017-09-21  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Fix `mmvar' array pointers.
 
 	Without this change, clang's AddressSanitizer reports many runtime
 	errors due to misaligned addresses.
 
 	* src/truetype/ttgxvar.c (TT_Get_MM_Var): Use multiples of pointer
 	size for sub-array offsets into `mmvar'.
 
 2017-09-20  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Integer overflows.
 
 	Changes triggered by
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=3429
 
 	* src/truetype/ttinterp.c (Ins_SHPIX, Ins_DELTAP): Use NEG_LONG.
 	(Ins_MIAP): Use SUB_LONG.
 
 2017-09-19  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[build] Fix DLL builds in Visual C++ project.
 
 	* build/windows/vc2010/freetype.vcxproj: Use DynamicLibrary in Debug
 	and Release configurations.
 	* include/freetype/config/ftconfig.h (FT_EXPORT, FT_EXPORT_DEF)
 	[_DLL]: Use Visual C++ extensions.
 
 2017-09-19  John Tytgat  <John.Tytgat@esko.com>
 
 	[cff] Fix family name logic of pure CFF fontdata (#52056).
 
 	1. If `FamilyName' is present in the CFF font, use this for
 	   FT_Face's `family_name'.
 	2. Otherwise, use the face name and chop off any subset prefix.
 	3. If at this point FT_Face's `family_name' is set, use this
 	   together with the full name to determine the style.
 	4. Otherwise, use `CIDFontName' as FT_Face's `family_name'.
 	5. If we don't have a valid style, use "Regular".
 
 	Previously, FT_Face's `family_name' entry for pure CFF fontdata
 	nearly always was the fontname itself, instead of the `FamilyName'
 	entry in the CFF font (assuming there is one).
 
 	* src/cff/cffobjs.c (cff_face_init) [pure_cff]: Implement it.
 
 2017-09-18  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[build] Declutter Visual C++ 2010-2017 project.
 
 	* build/windows/vc2010/freetype.vcxproj: Use MaxSpeed (/02)
 	optimization for Release configuration throughout the project.
 
 
 ----------------------------------------------------------------------------
diff --git a/src/truetype/ttgxvar.c b/src/truetype/ttgxvar.c
index c9f0ba434..97462a6e9 100644
--- a/src/truetype/ttgxvar.c
+++ b/src/truetype/ttgxvar.c
@@ -1,4171 +1,4179 @@
 /****************************************************************************
  *
  * ttgxvar.c
  *
  *   TrueType GX Font Variation loader
  *
  * Copyright 2004-2018 by
  * David Turner, Robert Wilhelm, Werner Lemberg, and George Williams.
  *
  * This file is part of the FreeType project, and may only be used,
  * modified, and distributed under the terms of the FreeType project
  * license, LICENSE.TXT.  By continuing to use, modify, or distribute
  * this file you indicate that you have read the license and
  * understand and accept it fully.
  *
  */
 
 
   /**************************************************************************
    *
    * Apple documents the `fvar', `gvar', `cvar', and `avar' tables at
    *
    *   https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6[fgca]var.html
    *
    * The documentation for `gvar' is not intelligible; `cvar' refers you
    * to `gvar' and is thus also incomprehensible.
    *
    * The documentation for `avar' appears correct, but Apple has no fonts
    * with an `avar' table, so it is hard to test.
    *
    * Many thanks to John Jenkins (at Apple) in figuring this out.
    *
    *
    * Apple's `kern' table has some references to tuple indices, but as
    * there is no indication where these indices are defined, nor how to
    * interpolate the kerning values (different tuples have different
    * classes) this issue is ignored.
    *
    */
 
 
 #include <ft2build.h>
 #include FT_INTERNAL_DEBUG_H
 #include FT_CONFIG_CONFIG_H
 #include FT_INTERNAL_STREAM_H
 #include FT_INTERNAL_SFNT_H
 #include FT_TRUETYPE_TAGS_H
 #include FT_TRUETYPE_IDS_H
 #include FT_MULTIPLE_MASTERS_H
 #include FT_LIST_H
 
 #include "ttpload.h"
 #include "ttgxvar.h"
 
 #include "tterrors.h"
 
 
 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
 
 
 #define FT_Stream_FTell( stream )                         \
           (FT_ULong)( (stream)->cursor - (stream)->base )
 #define FT_Stream_SeekSet( stream, off )                               \
           (stream)->cursor =                                           \
             ( (off) < (FT_ULong)( (stream)->limit - (stream)->base ) ) \
                         ? (stream)->base + (off)                       \
                         : (stream)->limit
 
 
   /* some macros we need */
 #define FT_FIXED_ONE  ( (FT_Fixed)0x10000 )
 
 #define FT_fdot14ToFixed( x )                \
         ( (FT_Fixed)( (FT_ULong)(x) << 2 ) )
 #define FT_intToFixed( i )                    \
         ( (FT_Fixed)( (FT_ULong)(i) << 16 ) )
 #define FT_fixedToInt( x )                                   \
         ( (FT_Short)( ( (FT_UInt32)(x) + 0x8000U ) >> 16 ) )
 
 
   /**************************************************************************
    *
    * The macro FT_COMPONENT is used in trace mode.  It is an implicit
    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log
    * messages during execution.
    */
 #undef  FT_COMPONENT
 #define FT_COMPONENT  trace_ttgxvar
 
 
   /*************************************************************************/
   /*************************************************************************/
   /*****                                                               *****/
   /*****                       Internal Routines                       *****/
   /*****                                                               *****/
   /*************************************************************************/
   /*************************************************************************/
 
 
   /**************************************************************************
    *
    * The macro ALL_POINTS is used in `ft_var_readpackedpoints'.  It
    * indicates that there is a delta for every point without needing to
    * enumerate all of them.
    */
 
   /* ensure that value `0' has the same width as a pointer */
 #define ALL_POINTS  (FT_UShort*)~(FT_PtrDist)0
 
 
 #define GX_PT_POINTS_ARE_WORDS      0x80U
 #define GX_PT_POINT_RUN_COUNT_MASK  0x7FU
 
 
   /**************************************************************************
    *
    * @Function:
    *   ft_var_readpackedpoints
    *
    * @Description:
    *   Read a set of points to which the following deltas will apply.
    *   Points are packed with a run length encoding.
    *
    * @Input:
    *   stream ::
    *     The data stream.
    *
    *   size ::
    *     The size of the table holding the data.
    *
    * @Output:
    *   point_cnt ::
    *     The number of points read.  A zero value means that
    *     all points in the glyph will be affected, without
    *     enumerating them individually.
    *
    * @Return:
    *   An array of FT_UShort containing the affected points or the
    *   special value ALL_POINTS.
    */
   static FT_UShort*
   ft_var_readpackedpoints( FT_Stream  stream,
                            FT_ULong   size,
                            FT_UInt   *point_cnt )
   {
     FT_UShort *points = NULL;
     FT_UInt    n;
     FT_UInt    runcnt;
     FT_UInt    i, j;
     FT_UShort  first;
     FT_Memory  memory = stream->memory;
     FT_Error   error  = FT_Err_Ok;
 
     FT_UNUSED( error );
 
 
     *point_cnt = 0;
 
     n = FT_GET_BYTE();
     if ( n == 0 )
       return ALL_POINTS;
 
     if ( n & GX_PT_POINTS_ARE_WORDS )
     {
       n  &= GX_PT_POINT_RUN_COUNT_MASK;
       n <<= 8;
       n  |= FT_GET_BYTE();
     }
 
     if ( n > size )
     {
       FT_TRACE1(( "ft_var_readpackedpoints: number of points too large\n" ));
       return NULL;
     }
 
     /* in the nested loops below we increase `i' twice; */
     /* it is faster to simply allocate one more slot    */
     /* than to add another test within the loop         */
     if ( FT_NEW_ARRAY( points, n + 1 ) )
       return NULL;
 
     *point_cnt = n;
 
     first = 0;
     i     = 0;
     while ( i < n )
     {
       runcnt = FT_GET_BYTE();
       if ( runcnt & GX_PT_POINTS_ARE_WORDS )
       {
         runcnt     &= GX_PT_POINT_RUN_COUNT_MASK;
         first      += FT_GET_USHORT();
         points[i++] = first;
 
         /* first point not included in run count */
         for ( j = 0; j < runcnt; j++ )
         {
           first      += FT_GET_USHORT();
           points[i++] = first;
           if ( i >= n )
             break;
         }
       }
       else
       {
         first      += FT_GET_BYTE();
         points[i++] = first;
 
         for ( j = 0; j < runcnt; j++ )
         {
           first      += FT_GET_BYTE();
           points[i++] = first;
           if ( i >= n )
             break;
         }
       }
     }
 
     return points;
   }
 
 
 #define GX_DT_DELTAS_ARE_ZERO       0x80U
 #define GX_DT_DELTAS_ARE_WORDS      0x40U
 #define GX_DT_DELTA_RUN_COUNT_MASK  0x3FU
 
 
   /**************************************************************************
    *
    * @Function:
    *   ft_var_readpackeddeltas
    *
    * @Description:
    *   Read a set of deltas.  These are packed slightly differently than
    *   points.  In particular there is no overall count.
    *
    * @Input:
    *   stream ::
    *     The data stream.
    *
    *   size ::
    *     The size of the table holding the data.
    *
    *   delta_cnt ::
    *     The number of deltas to be read.
    *
    * @Return:
    *   An array of FT_Fixed containing the deltas for the affected
    *   points.  (This only gets the deltas for one dimension.  It will
    *   generally be called twice, once for x, once for y.  When used in
    *   cvt table, it will only be called once.)
    *
    *   We use FT_Fixed to avoid accumulation errors while summing up all
    *   deltas (the rounding to integer values happens as the very last
    *   step).
    */
   static FT_Fixed*
   ft_var_readpackeddeltas( FT_Stream  stream,
                            FT_ULong   size,
                            FT_UInt    delta_cnt )
   {
     FT_Fixed  *deltas = NULL;
     FT_UInt    runcnt, cnt;
     FT_UInt    i, j;
     FT_Memory  memory = stream->memory;
     FT_Error   error  = FT_Err_Ok;
 
     FT_UNUSED( error );
 
 
     if ( delta_cnt > size )
     {
       FT_TRACE1(( "ft_var_readpackeddeltas: number of points too large\n" ));
       return NULL;
     }
 
     if ( FT_NEW_ARRAY( deltas, delta_cnt ) )
       return NULL;
 
     i = 0;
     while ( i < delta_cnt )
     {
       runcnt = FT_GET_BYTE();
       cnt    = runcnt & GX_DT_DELTA_RUN_COUNT_MASK;
 
       if ( runcnt & GX_DT_DELTAS_ARE_ZERO )
       {
         /* `runcnt' zeroes get added */
         for ( j = 0; j <= cnt && i < delta_cnt; j++ )
           deltas[i++] = 0;
       }
       else if ( runcnt & GX_DT_DELTAS_ARE_WORDS )
       {
         /* `runcnt' shorts from the stack */
         for ( j = 0; j <= cnt && i < delta_cnt; j++ )
           deltas[i++] = FT_intToFixed( FT_GET_SHORT() );
       }
       else
       {
         /* `runcnt' signed bytes from the stack */
         for ( j = 0; j <= cnt && i < delta_cnt; j++ )
           deltas[i++] = FT_intToFixed( FT_GET_CHAR() );
       }
 
       if ( j <= cnt )
       {
         /* bad format */
         FT_FREE( deltas );
         return NULL;
       }
     }
 
     return deltas;
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   ft_var_load_avar
    *
    * @Description:
    *   Parse the `avar' table if present.  It need not be, so we return
    *   nothing.
    *
    * @InOut:
    *   face ::
    *     The font face.
    */
   static void
   ft_var_load_avar( TT_Face  face )
   {
     FT_Stream       stream = FT_FACE_STREAM( face );
     FT_Memory       memory = stream->memory;
     GX_Blend        blend  = face->blend;
     GX_AVarSegment  segment;
     FT_Error        error = FT_Err_Ok;
     FT_Long         version;
     FT_Long         axisCount;
     FT_Int          i, j;
     FT_ULong        table_len;
 
     FT_UNUSED( error );
 
 
     FT_TRACE2(( "AVAR " ));
 
     blend->avar_loaded = TRUE;
     error = face->goto_table( face, TTAG_avar, stream, &table_len );
     if ( error )
     {
       FT_TRACE2(( "is missing\n" ));
       return;
     }
 
     if ( FT_FRAME_ENTER( table_len ) )
       return;
 
     version   = FT_GET_LONG();
     axisCount = FT_GET_LONG();
 
     if ( version != 0x00010000L )
     {
       FT_TRACE2(( "bad table version\n" ));
       goto Exit;
     }
 
     FT_TRACE2(( "loaded\n" ));
 
     if ( axisCount != (FT_Long)blend->mmvar->num_axis )
     {
       FT_TRACE2(( "ft_var_load_avar: number of axes in `avar' and `fvar'\n"
                   "                  table are different\n" ));
       goto Exit;
     }
 
     if ( FT_NEW_ARRAY( blend->avar_segment, axisCount ) )
       goto Exit;
 
     segment = &blend->avar_segment[0];
     for ( i = 0; i < axisCount; i++, segment++ )
     {
       FT_TRACE5(( "  axis %d:\n", i ));
 
       segment->pairCount = FT_GET_USHORT();
       if ( (FT_ULong)segment->pairCount * 4 > table_len                ||
            FT_NEW_ARRAY( segment->correspondence, segment->pairCount ) )
       {
         /* Failure.  Free everything we have done so far.  We must do */
         /* it right now since loading the `avar' table is optional.   */
 
         for ( j = i - 1; j >= 0; j-- )
           FT_FREE( blend->avar_segment[j].correspondence );
 
         FT_FREE( blend->avar_segment );
         blend->avar_segment = NULL;
         goto Exit;
       }
 
       for ( j = 0; j < segment->pairCount; j++ )
       {
         /* convert to Fixed */
         segment->correspondence[j].fromCoord = FT_GET_SHORT() * 4;
         segment->correspondence[j].toCoord   = FT_GET_SHORT() * 4;
 
         FT_TRACE5(( "    mapping %.5f to %.5f\n",
                     segment->correspondence[j].fromCoord / 65536.0,
                     segment->correspondence[j].toCoord / 65536.0 ));
       }
 
       FT_TRACE5(( "\n" ));
     }
 
   Exit:
     FT_FRAME_EXIT();
   }
 
 
   static FT_Error
   ft_var_load_item_variation_store( TT_Face          face,
                                     FT_ULong         offset,
                                     GX_ItemVarStore  itemStore )
   {
     FT_Stream  stream = FT_FACE_STREAM( face );
     FT_Memory  memory = stream->memory;
 
     FT_Error   error;
     FT_UShort  format;
     FT_ULong   region_offset;
     FT_UInt    i, j, k;
     FT_UInt    shortDeltaCount;
 
     GX_Blend        blend = face->blend;
     GX_ItemVarData  varData;
 
     FT_ULong*  dataOffsetArray = NULL;
 
 
     if ( FT_STREAM_SEEK( offset ) ||
          FT_READ_USHORT( format ) )
       goto Exit;
 
     if ( format != 1 )
     {
       FT_TRACE2(( "ft_var_load_item_variation_store: bad store format %d\n",
                   format ));
       error = FT_THROW( Invalid_Table );
       goto Exit;
     }
 
     /* read top level fields */
     if ( FT_READ_ULONG( region_offset )         ||
          FT_READ_USHORT( itemStore->dataCount ) )
       goto Exit;
 
     /* we need at least one entry in `itemStore->varData' */
     if ( !itemStore->dataCount )
     {
       FT_TRACE2(( "ft_var_load_item_variation_store: missing varData\n" ));
       error = FT_THROW( Invalid_Table );
       goto Exit;
     }
 
     /* make temporary copy of item variation data offsets; */
     /* we will parse region list first, then come back     */
     if ( FT_NEW_ARRAY( dataOffsetArray, itemStore->dataCount ) )
       goto Exit;
 
     for ( i = 0; i < itemStore->dataCount; i++ )
     {
       if ( FT_READ_ULONG( dataOffsetArray[i] ) )
         goto Exit;
     }
 
     /* parse array of region records (region list) */
     if ( FT_STREAM_SEEK( offset + region_offset ) )
       goto Exit;
 
     if ( FT_READ_USHORT( itemStore->axisCount )   ||
          FT_READ_USHORT( itemStore->regionCount ) )
       goto Exit;
 
     if ( itemStore->axisCount != (FT_Long)blend->mmvar->num_axis )
     {
       FT_TRACE2(( "ft_var_load_item_variation_store:"
                   " number of axes in item variation store\n"
                   "                                 "
                   " and `fvar' table are different\n" ));
       error = FT_THROW( Invalid_Table );
       goto Exit;
     }
 
     if ( FT_NEW_ARRAY( itemStore->varRegionList, itemStore->regionCount ) )
       goto Exit;
 
     for ( i = 0; i < itemStore->regionCount; i++ )
     {
       GX_AxisCoords  axisCoords;
 
 
       if ( FT_NEW_ARRAY( itemStore->varRegionList[i].axisList,
                          itemStore->axisCount ) )
         goto Exit;
 
       axisCoords = itemStore->varRegionList[i].axisList;
 
       for ( j = 0; j < itemStore->axisCount; j++ )
       {
         FT_Short  start, peak, end;
 
 
         if ( FT_READ_SHORT( start ) ||
              FT_READ_SHORT( peak )  ||
              FT_READ_SHORT( end )   )
           goto Exit;
 
         axisCoords[j].startCoord = FT_fdot14ToFixed( start );
         axisCoords[j].peakCoord  = FT_fdot14ToFixed( peak );
         axisCoords[j].endCoord   = FT_fdot14ToFixed( end );
       }
     }
 
     /* end of region list parse */
 
     /* use dataOffsetArray now to parse varData items */
     if ( FT_NEW_ARRAY( itemStore->varData, itemStore->dataCount ) )
       goto Exit;
 
     for ( i = 0; i < itemStore->dataCount; i++ )
     {
       varData = &itemStore->varData[i];
 
       if ( FT_STREAM_SEEK( offset + dataOffsetArray[i] ) )
         goto Exit;
 
       if ( FT_READ_USHORT( varData->itemCount )      ||
            FT_READ_USHORT( shortDeltaCount )         ||
            FT_READ_USHORT( varData->regionIdxCount ) )
         goto Exit;
 
       /* check some data consistency */
       if ( shortDeltaCount > varData->regionIdxCount )
       {
         FT_TRACE2(( "bad short count %d or region count %d\n",
                     shortDeltaCount,
                     varData->regionIdxCount ));
         error = FT_THROW( Invalid_Table );
         goto Exit;
       }
 
       if ( varData->regionIdxCount > itemStore->regionCount )
       {
         FT_TRACE2(( "inconsistent regionCount %d in varData[%d]\n",
                     varData->regionIdxCount,
                     i ));
         error = FT_THROW( Invalid_Table );
         goto Exit;
       }
 
       /* parse region indices */
       if ( FT_NEW_ARRAY( varData->regionIndices,
                          varData->regionIdxCount ) )
         goto Exit;
 
       for ( j = 0; j < varData->regionIdxCount; j++ )
       {
         if ( FT_READ_USHORT( varData->regionIndices[j] ) )
           goto Exit;
 
         if ( varData->regionIndices[j] >= itemStore->regionCount )
         {
           FT_TRACE2(( "bad region index %d\n",
                       varData->regionIndices[j] ));
           error = FT_THROW( Invalid_Table );
           goto Exit;
         }
       }
 
       /* Parse delta set.                                                */
       /*                                                                 */
       /* On input, deltas are (shortDeltaCount + regionIdxCount) bytes   */
       /* each; on output, deltas are expanded to `regionIdxCount' shorts */
       /* each.                                                           */
       if ( FT_NEW_ARRAY( varData->deltaSet,
                          varData->regionIdxCount * varData->itemCount ) )
         goto Exit;
 
       /* the delta set is stored as a 2-dimensional array of shorts; */
       /* sign-extend signed bytes to signed shorts                   */
       for ( j = 0; j < varData->itemCount * varData->regionIdxCount; )
       {
         for ( k = 0; k < shortDeltaCount; k++, j++ )
         {
           /* read the short deltas */
           FT_Short  delta;
 
 
           if ( FT_READ_SHORT( delta ) )
             goto Exit;
 
           varData->deltaSet[j] = delta;
         }
 
         for ( ; k < varData->regionIdxCount; k++, j++ )
         {
           /* read the (signed) byte deltas */
           FT_Char  delta;
 
 
           if ( FT_READ_CHAR( delta ) )
             goto Exit;
 
           varData->deltaSet[j] = delta;
         }
       }
     }
 
   Exit:
     FT_FREE( dataOffsetArray );
 
     return error;
   }
 
 
   static FT_Error
   ft_var_load_delta_set_index_mapping( TT_Face            face,
                                        FT_ULong           offset,
                                        GX_DeltaSetIdxMap  map,
                                        GX_ItemVarStore    itemStore )
   {
     FT_Stream  stream = FT_FACE_STREAM( face );
     FT_Memory  memory = stream->memory;
 
     FT_Error   error;
 
     FT_UShort  format;
     FT_UInt    entrySize;
     FT_UInt    innerBitCount;
     FT_UInt    innerIndexMask;
     FT_UInt    i, j;
 
 
     if ( FT_STREAM_SEEK( offset )        ||
          FT_READ_USHORT( format )        ||
          FT_READ_USHORT( map->mapCount ) )
       goto Exit;
 
     if ( format & 0xFFC0 )
     {
       FT_TRACE2(( "bad map format %d\n", format ));
       error = FT_THROW( Invalid_Table );
       goto Exit;
     }
 
     /* bytes per entry: 1, 2, 3, or 4 */
     entrySize      = ( ( format & 0x0030 ) >> 4 ) + 1;
     innerBitCount  = ( format & 0x000F ) + 1;
     innerIndexMask = ( 1 << innerBitCount ) - 1;
 
     if ( FT_NEW_ARRAY( map->innerIndex, map->mapCount ) )
       goto Exit;
 
     if ( FT_NEW_ARRAY( map->outerIndex, map->mapCount ) )
       goto Exit;
 
     for ( i = 0; i < map->mapCount; i++ )
     {
       FT_UInt  mapData = 0;
       FT_UInt  outerIndex, innerIndex;
 
 
       /* read map data one unsigned byte at a time, big endian */
       for ( j = 0; j < entrySize; j++ )
       {
         FT_Byte  data;
 
 
         if ( FT_READ_BYTE( data ) )
           goto Exit;
 
         mapData = ( mapData << 8 ) | data;
       }
 
       outerIndex = mapData >> innerBitCount;
 
       if ( outerIndex >= itemStore->dataCount )
       {
         FT_TRACE2(( "outerIndex[%d] == %d out of range\n",
                     i,
                     outerIndex ));
         error = FT_THROW( Invalid_Table );
         goto Exit;
       }
 
       map->outerIndex[i] = outerIndex;
 
       innerIndex = mapData & innerIndexMask;
 
       if ( innerIndex >= itemStore->varData[outerIndex].itemCount )
       {
         FT_TRACE2(( "innerIndex[%d] == %d out of range\n",
                     i,
                     innerIndex ));
         error = FT_THROW( Invalid_Table );
           goto Exit;
       }
 
       map->innerIndex[i] = innerIndex;
     }
 
   Exit:
     return error;
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   ft_var_load_hvvar
    *
    * @Description:
    *   If `vertical' is zero, parse the `HVAR' table and set
    *   `blend->hvar_loaded' to TRUE.  On success, `blend->hvar_checked'
    *   is set to TRUE.
    *
    *   If `vertical' is not zero, parse the `VVAR' table and set
    *   `blend->vvar_loaded' to TRUE.  On success, `blend->vvar_checked'
    *   is set to TRUE.
    *
    *   Some memory may remain allocated on error; it is always freed in
    *   `tt_done_blend', however.
    *
    * @InOut:
    *   face ::
    *     The font face.
    *
    * @Return:
    *   FreeType error code.  0 means success.
    */
   static FT_Error
   ft_var_load_hvvar( TT_Face  face,
                      FT_Bool  vertical )
   {
     FT_Stream  stream = FT_FACE_STREAM( face );
     FT_Memory  memory = stream->memory;
 
     GX_Blend  blend = face->blend;
 
     GX_HVVarTable  table;
 
     FT_Error   error;
     FT_UShort  majorVersion;
     FT_ULong   table_len;
     FT_ULong   table_offset;
     FT_ULong   store_offset;
     FT_ULong   widthMap_offset;
 
 
     if ( vertical )
     {
       blend->vvar_loaded = TRUE;
 
       FT_TRACE2(( "VVAR " ));
 
       error = face->goto_table( face, TTAG_VVAR, stream, &table_len );
     }
     else
     {
       blend->hvar_loaded = TRUE;
 
       FT_TRACE2(( "HVAR " ));
 
       error = face->goto_table( face, TTAG_HVAR, stream, &table_len );
     }
 
     if ( error )
     {
       FT_TRACE2(( "is missing\n" ));
       goto Exit;
     }
 
     table_offset = FT_STREAM_POS();
 
     /* skip minor version */
     if ( FT_READ_USHORT( majorVersion ) ||
          FT_STREAM_SKIP( 2 )            )
       goto Exit;
 
     if ( majorVersion != 1 )
     {
       FT_TRACE2(( "bad table version %d\n", majorVersion ));
       error = FT_THROW( Invalid_Table );
       goto Exit;
     }
 
     if ( FT_READ_ULONG( store_offset )    ||
          FT_READ_ULONG( widthMap_offset ) )
       goto Exit;
 
     if ( vertical )
     {
       if ( FT_NEW( blend->vvar_table ) )
         goto Exit;
       table = blend->vvar_table;
     }
     else
     {
       if ( FT_NEW( blend->hvar_table ) )
         goto Exit;
       table = blend->hvar_table;
     }
 
     error = ft_var_load_item_variation_store(
               face,
               table_offset + store_offset,
               &table->itemStore );
     if ( error )
       goto Exit;
 
     if ( widthMap_offset )
     {
       error = ft_var_load_delta_set_index_mapping(
                 face,
                 table_offset + widthMap_offset,
                 &table->widthMap,
                 &table->itemStore );
       if ( error )
         goto Exit;
     }
 
     FT_TRACE2(( "loaded\n" ));
     error = FT_Err_Ok;
 
   Exit:
     if ( !error )
     {
       if ( vertical )
       {
         blend->vvar_checked = TRUE;
 
         /* FreeType doesn't provide functions to quickly retrieve    */
         /* TSB, BSB, or VORG values; we thus don't have to implement */
         /* support for those three item variation stores.            */
 
         face->variation_support |= TT_FACE_FLAG_VAR_VADVANCE;
       }
       else
       {
         blend->hvar_checked = TRUE;
 
         /* FreeType doesn't provide functions to quickly retrieve */
         /* LSB or RSB values; we thus don't have to implement     */
         /* support for those two item variation stores.           */
 
         face->variation_support |= TT_FACE_FLAG_VAR_HADVANCE;
       }
     }
 
     return error;
   }
 
 
   static FT_Int
   ft_var_get_item_delta( TT_Face          face,
                          GX_ItemVarStore  itemStore,
                          FT_UInt          outerIndex,
                          FT_UInt          innerIndex )
   {
     GX_ItemVarData  varData;
     FT_Short*       deltaSet;
 
     FT_UInt   master, j;
     FT_Fixed  netAdjustment = 0;     /* accumulated adjustment */
     FT_Fixed  scaledDelta;
     FT_Fixed  delta;
 
 
     /* See pseudo code from `Font Variations Overview' */
     /* in the OpenType specification.                  */
 
     varData  = &itemStore->varData[outerIndex];
     deltaSet = &varData->deltaSet[varData->regionIdxCount * innerIndex];
 
     /* outer loop steps through master designs to be blended */
     for ( master = 0; master < varData->regionIdxCount; master++ )
     {
       FT_Fixed  scalar      = FT_FIXED_ONE;
       FT_UInt   regionIndex = varData->regionIndices[master];
 
       GX_AxisCoords  axis = itemStore->varRegionList[regionIndex].axisList;
 
 
       /* inner loop steps through axes in this region */
       for ( j = 0; j < itemStore->axisCount; j++, axis++ )
       {
         FT_Fixed  axisScalar;
 
 
         /* compute the scalar contribution of this axis; */
         /* ignore invalid ranges                         */
         if ( axis->startCoord > axis->peakCoord ||
              axis->peakCoord > axis->endCoord   )
           axisScalar = FT_FIXED_ONE;
 
         else if ( axis->startCoord < 0 &&
                   axis->endCoord > 0   &&
                   axis->peakCoord != 0 )
           axisScalar = FT_FIXED_ONE;
 
         /* peak of 0 means ignore this axis */
         else if ( axis->peakCoord == 0 )
           axisScalar = FT_FIXED_ONE;
 
         /* ignore this region if coords are out of range */
         else if ( face->blend->normalizedcoords[j] < axis->startCoord ||
                   face->blend->normalizedcoords[j] > axis->endCoord   )
           axisScalar = 0;
 
         /* calculate a proportional factor */
         else
         {
           if ( face->blend->normalizedcoords[j] == axis->peakCoord )
             axisScalar = FT_FIXED_ONE;
           else if ( face->blend->normalizedcoords[j] < axis->peakCoord )
             axisScalar =
               FT_DivFix( face->blend->normalizedcoords[j] - axis->startCoord,
                          axis->peakCoord - axis->startCoord );
           else
             axisScalar =
               FT_DivFix( axis->endCoord - face->blend->normalizedcoords[j],
                          axis->endCoord - axis->peakCoord );
         }
 
         /* take product of all the axis scalars */
         scalar = FT_MulFix( scalar, axisScalar );
 
       } /* per-axis loop */
 
       /* get the scaled delta for this region */
       delta       = FT_intToFixed( deltaSet[master] );
       scaledDelta = FT_MulFix( scalar, delta );
 
       /* accumulate the adjustments from each region */
       netAdjustment = netAdjustment + scaledDelta;
 
     } /* per-region loop */
 
     return FT_fixedToInt( netAdjustment );
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   tt_hvadvance_adjust
    *
    * @Description:
    *   Apply `HVAR' advance width or `VVAR' advance height adjustment of
    *   a given glyph.
    *
    * @Input:
    *   gindex ::
    *     The glyph index.
    *
    *   vertical ::
    *     If set, handle `VVAR' table.
    *
    * @InOut:
    *   face ::
    *     The font face.
    *
    *   adelta ::
    *     Points to width or height value that gets modified.
    */
   static FT_Error
   tt_hvadvance_adjust( TT_Face  face,
                        FT_UInt  gindex,
                        FT_Int  *avalue,
                        FT_Bool  vertical )
   {
     FT_Error  error = FT_Err_Ok;
     FT_UInt   innerIndex, outerIndex;
     FT_Int    delta;
 
     GX_HVVarTable  table;
 
 
     if ( !face->doblend || !face->blend )
       goto Exit;
 
     if ( vertical )
     {
       if ( !face->blend->vvar_loaded )
       {
         /* initialize vvar table */
         face->blend->vvar_error = ft_var_load_hvvar( face, 1 );
       }
 
       if ( !face->blend->vvar_checked )
       {
         error = face->blend->vvar_error;
         goto Exit;
       }
 
       table = face->blend->vvar_table;
     }
     else
     {
       if ( !face->blend->hvar_loaded )
       {
         /* initialize hvar table */
         face->blend->hvar_error = ft_var_load_hvvar( face, 0 );
       }
 
       if ( !face->blend->hvar_checked )
       {
         error = face->blend->hvar_error;
         goto Exit;
       }
 
       table = face->blend->hvar_table;
     }
 
     /* advance width or height adjustments are always present in an */
     /* `HVAR' or `VVAR' table; no need to test for this capability  */
 
     if ( table->widthMap.innerIndex )
     {
       FT_UInt  idx = gindex;
 
 
       if ( idx >= table->widthMap.mapCount )
         idx = table->widthMap.mapCount - 1;
 
       /* trust that HVAR parser has checked indices */
       outerIndex = table->widthMap.outerIndex[idx];
       innerIndex = table->widthMap.innerIndex[idx];
     }
     else
     {
       GX_ItemVarData  varData;
 
 
       /* no widthMap data */
       outerIndex = 0;
       innerIndex = gindex;
 
       varData = &table->itemStore.varData[outerIndex];
       if ( gindex >= varData->itemCount )
       {
         FT_TRACE2(( "gindex %d out of range\n", gindex ));
         error = FT_THROW( Invalid_Argument );
         goto Exit;
       }
     }
 
     delta = ft_var_get_item_delta( face,
                                    &table->itemStore,
                                    outerIndex,
                                    innerIndex );
 
     FT_TRACE5(( "%s value %d adjusted by %d unit%s (%s)\n",
                 vertical ? "vertical height" : "horizontal width",
                 *avalue,
                 delta,
                 delta == 1 ? "" : "s",
                 vertical ? "VVAR" : "HVAR" ));
 
     *avalue += delta;
 
   Exit:
     return error;
   }
 
 
   FT_LOCAL_DEF( FT_Error )
   tt_hadvance_adjust( TT_Face  face,
                       FT_UInt  gindex,
                       FT_Int  *avalue )
   {
     return tt_hvadvance_adjust( face, gindex, avalue, 0 );
   }
 
 
   FT_LOCAL_DEF( FT_Error )
   tt_vadvance_adjust( TT_Face  face,
                       FT_UInt  gindex,
                       FT_Int  *avalue )
   {
     return tt_hvadvance_adjust( face, gindex, avalue, 1 );
   }
 
 
 #define GX_VALUE_SIZE  8
 
   /* all values are FT_Short or FT_UShort entities; */
   /* we treat them consistently as FT_Short         */
 #define GX_VALUE_CASE( tag, dflt )      \
           case MVAR_TAG_ ## tag :       \
             p = (FT_Short*)&face->dflt; \
             break
 
 #define GX_GASP_CASE( idx )                                       \
           case MVAR_TAG_GASP_ ## idx :                            \
             if ( idx < face->gasp.numRanges - 1 )                 \
               p = (FT_Short*)&face->gasp.gaspRanges[idx].maxPPEM; \
             else                                                  \
               p = NULL;                                           \
             break
 
 
   static FT_Short*
   ft_var_get_value_pointer( TT_Face   face,
                             FT_ULong  mvar_tag )
   {
     FT_Short*  p;
 
 
     switch ( mvar_tag )
     {
       GX_GASP_CASE( 0 );
       GX_GASP_CASE( 1 );
       GX_GASP_CASE( 2 );
       GX_GASP_CASE( 3 );
       GX_GASP_CASE( 4 );
       GX_GASP_CASE( 5 );
       GX_GASP_CASE( 6 );
       GX_GASP_CASE( 7 );
       GX_GASP_CASE( 8 );
       GX_GASP_CASE( 9 );
 
       GX_VALUE_CASE( CPHT, os2.sCapHeight );
       GX_VALUE_CASE( HASC, os2.sTypoAscender );
       GX_VALUE_CASE( HCLA, os2.usWinAscent );
       GX_VALUE_CASE( HCLD, os2.usWinDescent );
       GX_VALUE_CASE( HCOF, horizontal.caret_Offset );
       GX_VALUE_CASE( HCRN, horizontal.caret_Slope_Run );
       GX_VALUE_CASE( HCRS, horizontal.caret_Slope_Rise );
       GX_VALUE_CASE( HDSC, os2.sTypoDescender );
       GX_VALUE_CASE( HLGP, os2.sTypoLineGap );
       GX_VALUE_CASE( SBXO, os2.ySubscriptXOffset);
       GX_VALUE_CASE( SBXS, os2.ySubscriptXSize );
       GX_VALUE_CASE( SBYO, os2.ySubscriptYOffset );
       GX_VALUE_CASE( SBYS, os2.ySubscriptYSize );
       GX_VALUE_CASE( SPXO, os2.ySuperscriptXOffset );
       GX_VALUE_CASE( SPXS, os2.ySuperscriptXSize );
       GX_VALUE_CASE( SPYO, os2.ySuperscriptYOffset );
       GX_VALUE_CASE( SPYS, os2.ySuperscriptYSize );
       GX_VALUE_CASE( STRO, os2.yStrikeoutPosition );
       GX_VALUE_CASE( STRS, os2.yStrikeoutSize );
       GX_VALUE_CASE( UNDO, postscript.underlinePosition );
       GX_VALUE_CASE( UNDS, postscript.underlineThickness );
       GX_VALUE_CASE( VASC, vertical.Ascender );
       GX_VALUE_CASE( VCOF, vertical.caret_Offset );
       GX_VALUE_CASE( VCRN, vertical.caret_Slope_Run );
       GX_VALUE_CASE( VCRS, vertical.caret_Slope_Rise );
       GX_VALUE_CASE( VDSC, vertical.Descender );
       GX_VALUE_CASE( VLGP, vertical.Line_Gap );
       GX_VALUE_CASE( XHGT, os2.sxHeight );
 
     default:
       /* ignore unknown tag */
       p = NULL;
     }
 
     return p;
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   ft_var_load_mvar
    *
    * @Description:
    *   Parse the `MVAR' table.
    *
    *   Some memory may remain allocated on error; it is always freed in
    *   `tt_done_blend', however.
    *
    * @InOut:
    *   face ::
    *     The font face.
    */
   static void
   ft_var_load_mvar( TT_Face  face )
   {
     FT_Stream  stream = FT_FACE_STREAM( face );
     FT_Memory  memory = stream->memory;
 
     GX_Blend         blend = face->blend;
     GX_ItemVarStore  itemStore;
     GX_Value         value, limit;
 
     FT_Error   error;
     FT_UShort  majorVersion;
     FT_ULong   table_len;
     FT_ULong   table_offset;
     FT_UShort  store_offset;
     FT_ULong   records_offset;
 
 
     FT_TRACE2(( "MVAR " ));
 
     error = face->goto_table( face, TTAG_MVAR, stream, &table_len );
     if ( error )
     {
       FT_TRACE2(( "is missing\n" ));
       return;
     }
 
     table_offset = FT_STREAM_POS();
 
     /* skip minor version */
     if ( FT_READ_USHORT( majorVersion ) ||
          FT_STREAM_SKIP( 2 )            )
       return;
 
     if ( majorVersion != 1 )
     {
       FT_TRACE2(( "bad table version %d\n", majorVersion ));
       return;
     }
 
     if ( FT_NEW( blend->mvar_table ) )
       return;
 
     /* skip reserved entry and value record size */
     if ( FT_STREAM_SKIP( 4 )                             ||
          FT_READ_USHORT( blend->mvar_table->valueCount ) ||
          FT_READ_USHORT( store_offset )                  )
       return;
 
     records_offset = FT_STREAM_POS();
 
     error = ft_var_load_item_variation_store(
               face,
               table_offset + store_offset,
               &blend->mvar_table->itemStore );
     if ( error )
       return;
 
     if ( FT_NEW_ARRAY( blend->mvar_table->values,
                        blend->mvar_table->valueCount ) )
       return;
 
     if ( FT_STREAM_SEEK( records_offset )                                ||
          FT_FRAME_ENTER( blend->mvar_table->valueCount * GX_VALUE_SIZE ) )
       return;
 
     value     = blend->mvar_table->values;
     limit     = value + blend->mvar_table->valueCount;
     itemStore = &blend->mvar_table->itemStore;
 
     for ( ; value < limit; value++ )
     {
       value->tag        = FT_GET_ULONG();
       value->outerIndex = FT_GET_USHORT();
       value->innerIndex = FT_GET_USHORT();
 
       if ( value->outerIndex >= itemStore->dataCount                  ||
            value->innerIndex >= itemStore->varData[value->outerIndex]
                                                   .itemCount          )
       {
         error = FT_THROW( Invalid_Table );
         break;
       }
     }
 
     FT_FRAME_EXIT();
 
     if ( error )
       return;
 
     FT_TRACE2(( "loaded\n" ));
 
     value = blend->mvar_table->values;
     limit = value + blend->mvar_table->valueCount;
 
     /* save original values of the data MVAR is going to modify */
     for ( ; value < limit; value++ )
     {
       FT_Short*  p = ft_var_get_value_pointer( face, value->tag );
 
 
       if ( p )
         value->unmodified = *p;
 #ifdef FT_DEBUG_LEVEL_TRACE
       else
         FT_TRACE1(( "ft_var_load_mvar: Ignoring unknown tag `%c%c%c%c'\n",
                     (FT_Char)( value->tag >> 24 ),
                     (FT_Char)( value->tag >> 16 ),
                     (FT_Char)( value->tag >> 8 ),
                     (FT_Char)( value->tag ) ));
 #endif
     }
 
     face->variation_support |= TT_FACE_FLAG_VAR_MVAR;
   }
 
 
   static FT_Error
   tt_size_reset_iterator( FT_ListNode  node,
                           void*        user )
   {
     TT_Size  size = (TT_Size)node->data;
 
     FT_UNUSED( user );
 
 
     tt_size_reset( size, 1 );
 
     return FT_Err_Ok;
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   tt_apply_mvar
    *
    * @Description:
    *   Apply `MVAR' table adjustments.
    *
    * @InOut:
    *   face ::
    *     The font face.
    */
   FT_LOCAL_DEF( void )
   tt_apply_mvar( TT_Face  face )
   {
     GX_Blend  blend = face->blend;
     GX_Value  value, limit;
 
 
     if ( !( face->variation_support & TT_FACE_FLAG_VAR_MVAR ) )
       return;
 
     value = blend->mvar_table->values;
     limit = value + blend->mvar_table->valueCount;
 
     for ( ; value < limit; value++ )
     {
       FT_Short*  p = ft_var_get_value_pointer( face, value->tag );
       FT_Int     delta;
 
 
       delta = ft_var_get_item_delta( face,
                                      &blend->mvar_table->itemStore,
                                      value->outerIndex,
                                      value->innerIndex );
 
       if ( p )
       {
         FT_TRACE5(( "value %c%c%c%c (%d unit%s) adjusted by %d unit%s (MVAR)\n",
                     (FT_Char)( value->tag >> 24 ),
                     (FT_Char)( value->tag >> 16 ),
                     (FT_Char)( value->tag >> 8 ),
                     (FT_Char)( value->tag ),
                     value->unmodified,
                     value->unmodified == 1 ? "" : "s",
                     delta,
                     delta == 1 ? "" : "s" ));
 
         /* since we handle both signed and unsigned values as FT_Short, */
         /* ensure proper overflow arithmetic                            */
         *p = (FT_Short)( value->unmodified + (FT_Short)delta );
       }
     }
 
     /* adjust all derived values */
     {
       FT_Face  root = &face->root;
 
 
       if ( face->os2.version != 0xFFFFU )
       {
         if ( face->os2.sTypoAscender || face->os2.sTypoDescender )
         {
           root->ascender  = face->os2.sTypoAscender;
           root->descender = face->os2.sTypoDescender;
 
           root->height = root->ascender - root->descender +
                          face->os2.sTypoLineGap;
         }
         else
         {
           root->ascender  =  (FT_Short)face->os2.usWinAscent;
           root->descender = -(FT_Short)face->os2.usWinDescent;
 
           root->height = root->ascender - root->descender;
         }
       }
 
       root->underline_position  = face->postscript.underlinePosition -
                                   face->postscript.underlineThickness / 2;
       root->underline_thickness = face->postscript.underlineThickness;
 
       /* iterate over all FT_Size objects and call `tt_size_reset' */
       /* to propagate the metrics changes                          */
       FT_List_Iterate( &root->sizes_list,
                        tt_size_reset_iterator,
                        NULL );
     }
   }
 
 
   typedef struct  GX_GVar_Head_
   {
     FT_Long    version;
     FT_UShort  axisCount;
     FT_UShort  globalCoordCount;
     FT_ULong   offsetToCoord;
     FT_UShort  glyphCount;
     FT_UShort  flags;
     FT_ULong   offsetToData;
 
   } GX_GVar_Head;
 
 
   /**************************************************************************
    *
    * @Function:
    *   ft_var_load_gvar
    *
    * @Description:
    *   Parse the `gvar' table if present.  If `fvar' is there, `gvar' had
    *   better be there too.
    *
    * @InOut:
    *   face ::
    *     The font face.
    *
    * @Return:
    *   FreeType error code.  0 means success.
    */
   static FT_Error
   ft_var_load_gvar( TT_Face  face )
   {
     FT_Stream     stream = FT_FACE_STREAM( face );
     FT_Memory     memory = stream->memory;
     GX_Blend      blend  = face->blend;
     FT_Error      error;
     FT_UInt       i, j;
     FT_ULong      table_len;
     FT_ULong      gvar_start;
     FT_ULong      offsetToData;
     GX_GVar_Head  gvar_head;
 
     static const FT_Frame_Field  gvar_fields[] =
     {
 
 #undef  FT_STRUCTURE
 #define FT_STRUCTURE  GX_GVar_Head
 
       FT_FRAME_START( 20 ),
         FT_FRAME_LONG  ( version ),
         FT_FRAME_USHORT( axisCount ),
         FT_FRAME_USHORT( globalCoordCount ),
         FT_FRAME_ULONG ( offsetToCoord ),
         FT_FRAME_USHORT( glyphCount ),
         FT_FRAME_USHORT( flags ),
         FT_FRAME_ULONG ( offsetToData ),
       FT_FRAME_END
     };
 
 
     FT_TRACE2(( "GVAR " ));
 
     if ( FT_SET_ERROR( face->goto_table( face,
                                          TTAG_gvar,
                                          stream,
                                          &table_len ) ) )
     {
       FT_TRACE2(( "is missing\n" ));
       goto Exit;
     }
 
     gvar_start = FT_STREAM_POS( );
     if ( FT_STREAM_READ_FIELDS( gvar_fields, &gvar_head ) )
       goto Exit;
 
     if ( gvar_head.version != 0x00010000L )
     {
       FT_TRACE1(( "bad table version\n" ));
       error = FT_THROW( Invalid_Table );
       goto Exit;
     }
 
     if ( gvar_head.axisCount != (FT_UShort)blend->mmvar->num_axis )
     {
       FT_TRACE1(( "ft_var_load_gvar: number of axes in `gvar' and `cvar'\n"
                   "                  table are different\n" ));
       error = FT_THROW( Invalid_Table );
       goto Exit;
     }
 
     /* rough sanity check, ignoring offsets */
     if ( (FT_ULong)gvar_head.globalCoordCount * gvar_head.axisCount >
            table_len / 2 )
     {
       FT_TRACE1(( "ft_var_load_gvar:"
                   " invalid number of global coordinates\n" ));
       error = FT_THROW( Invalid_Table );
       goto Exit;
     }
 
     /* rough sanity check: offsets can be either 2 or 4 bytes */
     if ( (FT_ULong)gvar_head.glyphCount *
            ( ( gvar_head.flags & 1 ) ? 4 : 2 ) > table_len )
     {
       FT_TRACE1(( "ft_var_load_gvar: invalid number of glyphs\n" ));
       error = FT_THROW( Invalid_Table );
       goto Exit;
     }
 
     FT_TRACE2(( "loaded\n" ));
 
     blend->gvar_size   = table_len;
     blend->tuplecount  = gvar_head.globalCoordCount;
     blend->gv_glyphcnt = gvar_head.glyphCount;
     offsetToData       = gvar_start + gvar_head.offsetToData;
 
     FT_TRACE5(( "gvar: there %s %d shared coordinate%s:\n",
                 blend->tuplecount == 1 ? "is" : "are",
                 blend->tuplecount,
                 blend->tuplecount == 1 ? "" : "s" ));
 
     if ( FT_NEW_ARRAY( blend->glyphoffsets, blend->gv_glyphcnt + 1 ) )
       goto Exit;
 
     if ( gvar_head.flags & 1 )
     {
       /* long offsets (one more offset than glyphs, to mark size of last) */
       if ( FT_FRAME_ENTER( ( blend->gv_glyphcnt + 1 ) * 4L ) )
         goto Exit;
 
       for ( i = 0; i <= blend->gv_glyphcnt; i++ )
         blend->glyphoffsets[i] = offsetToData + FT_GET_ULONG();
 
       FT_FRAME_EXIT();
     }
     else
     {
       /* short offsets (one more offset than glyphs, to mark size of last) */
       if ( FT_FRAME_ENTER( ( blend->gv_glyphcnt + 1 ) * 2L ) )
         goto Exit;
 
       for ( i = 0; i <= blend->gv_glyphcnt; i++ )
         blend->glyphoffsets[i] = offsetToData + FT_GET_USHORT() * 2;
                                                /* XXX: Undocumented: `*2'! */
 
       FT_FRAME_EXIT();
     }
 
     if ( blend->tuplecount != 0 )
     {
       if ( FT_NEW_ARRAY( blend->tuplecoords,
                          gvar_head.axisCount * blend->tuplecount ) )
         goto Exit;
 
       if ( FT_STREAM_SEEK( gvar_start + gvar_head.offsetToCoord )         ||
            FT_FRAME_ENTER( blend->tuplecount * gvar_head.axisCount * 2L ) )
         goto Exit;
 
       for ( i = 0; i < blend->tuplecount; i++ )
       {
         FT_TRACE5(( "  [ " ));
         for ( j = 0; j < (FT_UInt)gvar_head.axisCount; j++ )
         {
           blend->tuplecoords[i * gvar_head.axisCount + j] =
             FT_GET_SHORT() * 4;                 /* convert to FT_Fixed */
           FT_TRACE5(( "%.5f ",
             blend->tuplecoords[i * gvar_head.axisCount + j] / 65536.0 ));
         }
         FT_TRACE5(( "]\n" ));
       }
 
       FT_TRACE5(( "\n" ));
 
       FT_FRAME_EXIT();
     }
 
   Exit:
     return error;
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   ft_var_apply_tuple
    *
    * @Description:
    *   Figure out whether a given tuple (design) applies to the current
    *   blend, and if so, what is the scaling factor.
    *
    * @Input:
    *   blend ::
    *     The current blend of the font.
    *
    *   tupleIndex ::
    *     A flag saying whether this is an intermediate
    *     tuple or not.
    *
    *   tuple_coords ::
    *     The coordinates of the tuple in normalized axis
    *     units.
    *
    *   im_start_coords ::
    *     The initial coordinates where this tuple starts
    *     to apply (for intermediate coordinates).
    *
    *   im_end_coords ::
    *     The final coordinates after which this tuple no
    *     longer applies (for intermediate coordinates).
    *
    * @Return:
    *   An FT_Fixed value containing the scaling factor.
    */
   static FT_Fixed
   ft_var_apply_tuple( GX_Blend   blend,
                       FT_UShort  tupleIndex,
                       FT_Fixed*  tuple_coords,
                       FT_Fixed*  im_start_coords,
                       FT_Fixed*  im_end_coords )
   {
     FT_UInt   i;
     FT_Fixed  apply = 0x10000L;
 
 
     for ( i = 0; i < blend->num_axis; i++ )
     {
       FT_TRACE6(( "    axis coordinate %d (%.5f):\n",
                   i, blend->normalizedcoords[i] / 65536.0 ));
       if ( !( tupleIndex & GX_TI_INTERMEDIATE_TUPLE ) )
         FT_TRACE6(( "      intermediate coordinates %d (%.5f, %.5f):\n",
                     i,
                     im_start_coords[i] / 65536.0,
                     im_end_coords[i] / 65536.0 ));
 
       /* It's not clear why (for intermediate tuples) we don't need     */
       /* to check against start/end -- the documentation says we don't. */
       /* Similarly, it's unclear why we don't need to scale along the   */
       /* axis.                                                          */
 
       if ( tuple_coords[i] == 0 )
       {
         FT_TRACE6(( "      tuple coordinate is zero, ignored\n", i ));
         continue;
       }
 
       if ( blend->normalizedcoords[i] == 0 )
       {
         FT_TRACE6(( "      axis coordinate is zero, stop\n" ));
         apply = 0;
         break;
       }
 
       if ( blend->normalizedcoords[i] == tuple_coords[i] )
       {
         FT_TRACE6(( "      tuple coordinate value %.5f fits perfectly\n",
                     tuple_coords[i] / 65536.0 ));
         /* `apply' does not change */
         continue;
       }
 
       if ( !( tupleIndex & GX_TI_INTERMEDIATE_TUPLE ) )
       {
         /* not an intermediate tuple */
 
         if ( blend->normalizedcoords[i] < FT_MIN( 0, tuple_coords[i] ) ||
              blend->normalizedcoords[i] > FT_MAX( 0, tuple_coords[i] ) )
         {
           FT_TRACE6(( "      tuple coordinate value %.5f is exceeded, stop\n",
                       tuple_coords[i] / 65536.0 ));
           apply = 0;
           break;
         }
 
         FT_TRACE6(( "      tuple coordinate value %.5f fits\n",
                     tuple_coords[i] / 65536.0 ));
         apply = FT_MulDiv( apply,
                            blend->normalizedcoords[i],
                            tuple_coords[i] );
       }
       else
       {
         /* intermediate tuple */
 
         if ( blend->normalizedcoords[i] < im_start_coords[i] ||
              blend->normalizedcoords[i] > im_end_coords[i]   )
         {
           FT_TRACE6(( "      intermediate tuple range [%.5f;%.5f] is exceeded,"
                       " stop\n",
                       im_start_coords[i] / 65536.0,
                       im_end_coords[i] / 65536.0 ));
           apply = 0;
           break;
         }
 
         else if ( blend->normalizedcoords[i] < tuple_coords[i] )
         {
           FT_TRACE6(( "      intermediate tuple range [%.5f;%.5f] fits\n",
                       im_start_coords[i] / 65536.0,
                       im_end_coords[i] / 65536.0 ));
           apply = FT_MulDiv( apply,
                              blend->normalizedcoords[i] - im_start_coords[i],
                              tuple_coords[i] - im_start_coords[i] );
         }
 
         else
         {
           FT_TRACE6(( "      intermediate tuple range [%.5f;%.5f] fits\n",
                       im_start_coords[i] / 65536.0,
                       im_end_coords[i] / 65536.0 ));
           apply = FT_MulDiv( apply,
                              im_end_coords[i] - blend->normalizedcoords[i],
                              im_end_coords[i] - tuple_coords[i] );
         }
       }
     }
 
     FT_TRACE6(( "    apply factor is %.5f\n", apply / 65536.0 ));
 
     return apply;
   }
 
 
   /* convert from design coordinates to normalized coordinates */
 
   static void
   ft_var_to_normalized( TT_Face    face,
                         FT_UInt    num_coords,
                         FT_Fixed*  coords,
                         FT_Fixed*  normalized )
   {
     GX_Blend        blend;
     FT_MM_Var*      mmvar;
     FT_UInt         i, j;
     FT_Var_Axis*    a;
     GX_AVarSegment  av;
 
 
     blend = face->blend;
     mmvar = blend->mmvar;
 
     if ( num_coords > mmvar->num_axis )
     {
       FT_TRACE2(( "ft_var_to_normalized:"
                   " only using first %d of %d coordinates\n",
                   mmvar->num_axis, num_coords ));
       num_coords = mmvar->num_axis;
     }
 
     /* Axis normalization is a two-stage process.  First we normalize */
     /* based on the [min,def,max] values for the axis to be [-1,0,1]. */
     /* Then, if there's an `avar' table, we renormalize this range.   */
 
     a = mmvar->axis;
     for ( i = 0; i < num_coords; i++, a++ )
     {
       FT_Fixed  coord = coords[i];
 
 
       FT_TRACE5(( "    %d: %.5f\n", i, coord / 65536.0 ));
       if ( coord > a->maximum || coord < a->minimum )
       {
         FT_TRACE1((
           "ft_var_to_normalized: design coordinate %.5f\n"
           "                      is out of range [%.5f;%.5f]; clamping\n",
           coord / 65536.0,
           a->minimum / 65536.0,
           a->maximum / 65536.0 ));
 
         if ( coord > a->maximum )
           coord = a->maximum;
         else
           coord = a->minimum;
       }
 
       if ( coord < a->def )
         normalized[i] = -FT_DivFix( coord - a->def,
                                     a->minimum - a->def );
       else if ( coord > a->def )
         normalized[i] = FT_DivFix( coord - a->def,
                                    a->maximum - a->def );
       else
         normalized[i] = 0;
     }
 
     FT_TRACE5(( "\n" ));
 
     for ( ; i < mmvar->num_axis; i++ )
       normalized[i] = 0;
 
     if ( blend->avar_segment )
     {
       FT_TRACE5(( "normalized design coordinates"
                   " before applying `avar' data:\n" ));
 
       av = blend->avar_segment;
       for ( i = 0; i < mmvar->num_axis; i++, av++ )
       {
         for ( j = 1; j < (FT_UInt)av->pairCount; j++ )
         {
           if ( normalized[i] < av->correspondence[j].fromCoord )
           {
             FT_TRACE5(( "  %.5f\n", normalized[i] / 65536.0 ));
 
             normalized[i] =
               FT_MulDiv( normalized[i] - av->correspondence[j - 1].fromCoord,
                          av->correspondence[j].toCoord -
                            av->correspondence[j - 1].toCoord,
                          av->correspondence[j].fromCoord -
                            av->correspondence[j - 1].fromCoord ) +
               av->correspondence[j - 1].toCoord;
             break;
           }
         }
       }
     }
   }
 
 
   /* convert from normalized coordinates to design coordinates */
 
   static void
   ft_var_to_design( TT_Face    face,
                     FT_UInt    num_coords,
                     FT_Fixed*  coords,
                     FT_Fixed*  design )
   {
     GX_Blend      blend;
     FT_MM_Var*    mmvar;
     FT_Var_Axis*  a;
 
     FT_UInt  i, j, nc;
 
 
     blend = face->blend;
 
     nc = num_coords;
     if ( num_coords > blend->num_axis )
     {
       FT_TRACE2(( "ft_var_to_design:"
                   " only using first %d of %d coordinates\n",
                   blend->num_axis, num_coords ));
       nc = blend->num_axis;
     }
 
     for ( i = 0; i < nc; i++ )
       design[i] = coords[i];
 
     for ( ; i < num_coords; i++ )
       design[i] = 0;
 
     if ( blend->avar_segment )
     {
       GX_AVarSegment  av = blend->avar_segment;
 
 
       FT_TRACE5(( "design coordinates"
                   " after removing `avar' distortion:\n" ));
 
       for ( i = 0; i < nc; i++, av++ )
       {
         for ( j = 1; j < (FT_UInt)av->pairCount; j++ )
         {
           if ( design[i] < av->correspondence[j].toCoord )
           {
             design[i] =
               FT_MulDiv( design[i] - av->correspondence[j - 1].toCoord,
                          av->correspondence[j].fromCoord -
                            av->correspondence[j - 1].fromCoord,
                          av->correspondence[j].toCoord -
                            av->correspondence[j - 1].toCoord ) +
               av->correspondence[j - 1].fromCoord;
 
             FT_TRACE5(( "  %.5f\n", design[i] / 65536.0 ));
             break;
           }
         }
       }
     }
 
     mmvar = blend->mmvar;
     a     = mmvar->axis;
 
     for ( i = 0; i < nc; i++, a++ )
     {
       if ( design[i] < 0 )
         design[i] = a->def + FT_MulFix( design[i],
                                         a->def - a->minimum );
       else if ( design[i] > 0 )
         design[i] = a->def + FT_MulFix( design[i],
                                         a->maximum - a->def );
       else
         design[i] = a->def;
     }
   }
 
 
   /*************************************************************************/
   /*************************************************************************/
   /*****                                                               *****/
   /*****               MULTIPLE MASTERS SERVICE FUNCTIONS              *****/
   /*****                                                               *****/
   /*************************************************************************/
   /*************************************************************************/
 
 
   typedef struct  GX_FVar_Head_
   {
     FT_Long    version;
     FT_UShort  offsetToData;
     FT_UShort  axisCount;
     FT_UShort  axisSize;
     FT_UShort  instanceCount;
     FT_UShort  instanceSize;
 
   } GX_FVar_Head;
 
 
   typedef struct  fvar_axis_
   {
     FT_ULong   axisTag;
     FT_Fixed   minValue;
     FT_Fixed   defaultValue;
     FT_Fixed   maxValue;
     FT_UShort  flags;
     FT_UShort  nameID;
 
   } GX_FVar_Axis;
 
 
   /**************************************************************************
    *
    * @Function:
    *   TT_Get_MM_Var
    *
    * @Description:
    *   Check that the font's `fvar' table is valid, parse it, and return
    *   those data.  It also loads (and parses) the `MVAR' table, if
    *   possible.
    *
    * @InOut:
    *   face ::
    *     The font face.
    *     TT_Get_MM_Var initializes the blend structure.
    *
    * @Output:
    *   master ::
    *     The `fvar' data (must be freed by caller).  Can be NULL,
    *     which makes this function simply load MM support.
    *
    * @Return:
    *   FreeType error code.  0 means success.
    */
   FT_LOCAL_DEF( FT_Error )
   TT_Get_MM_Var( TT_Face      face,
                  FT_MM_Var*  *master )
   {
     FT_Stream            stream     = face->root.stream;
     FT_Memory            memory     = face->root.memory;
     FT_ULong             table_len;
     FT_Error             error      = FT_Err_Ok;
     FT_ULong             fvar_start = 0;
     FT_UInt              i, j;
     FT_MM_Var*           mmvar = NULL;
     FT_Fixed*            next_coords;
     FT_Fixed*            nsc;
     FT_String*           next_name;
     FT_Var_Axis*         a;
     FT_Fixed*            c;
     FT_Var_Named_Style*  ns;
     GX_FVar_Head         fvar_head;
     FT_Bool              usePsName  = 0;
     FT_UInt              num_instances;
     FT_UInt              num_axes;
     FT_UShort*           axis_flags;
 
     FT_Offset  mmvar_size;
     FT_Offset  axis_flags_size;
     FT_Offset  axis_size;
     FT_Offset  namedstyle_size;
     FT_Offset  next_coords_size;
     FT_Offset  next_name_size;
 
     FT_Bool  need_init;
 
     static const FT_Frame_Field  fvar_fields[] =
     {
 
 #undef  FT_STRUCTURE
 #define FT_STRUCTURE  GX_FVar_Head
 
       FT_FRAME_START( 16 ),
         FT_FRAME_LONG      ( version ),
         FT_FRAME_USHORT    ( offsetToData ),
         FT_FRAME_SKIP_SHORT,
         FT_FRAME_USHORT    ( axisCount ),
         FT_FRAME_USHORT    ( axisSize ),
         FT_FRAME_USHORT    ( instanceCount ),
         FT_FRAME_USHORT    ( instanceSize ),
       FT_FRAME_END
     };
 
     static const FT_Frame_Field  fvaraxis_fields[] =
     {
 
 #undef  FT_STRUCTURE
 #define FT_STRUCTURE  GX_FVar_Axis
 
       FT_FRAME_START( 20 ),
         FT_FRAME_ULONG ( axisTag ),
         FT_FRAME_LONG  ( minValue ),
         FT_FRAME_LONG  ( defaultValue ),
         FT_FRAME_LONG  ( maxValue ),
         FT_FRAME_USHORT( flags ),
         FT_FRAME_USHORT( nameID ),
       FT_FRAME_END
     };
 
 
     /* read the font data and set up the internal representation */
     /* if not already done                                       */
 
     need_init = !face->blend;
 
     if ( need_init )
     {
       FT_TRACE2(( "FVAR " ));
 
       /* both `fvar' and `gvar' must be present */
       if ( FT_SET_ERROR( face->goto_table( face, TTAG_gvar,
                                            stream, &table_len ) ) )
       {
         /* CFF2 is an alternate to gvar here */
         if ( FT_SET_ERROR( face->goto_table( face, TTAG_CFF2,
                                              stream, &table_len ) ) )
         {
           FT_TRACE1(( "\n"
                       "TT_Get_MM_Var: `gvar' or `CFF2' table is missing\n" ));
           goto Exit;
         }
       }
 
       if ( FT_SET_ERROR( face->goto_table( face, TTAG_fvar,
                                            stream, &table_len ) ) )
       {
         FT_TRACE1(( "is missing\n" ));
         goto Exit;
       }
 
       fvar_start = FT_STREAM_POS( );
 
       /* the validity of the `fvar' header data was already checked */
       /* in function `sfnt_init_face'                               */
       if ( FT_STREAM_READ_FIELDS( fvar_fields, &fvar_head ) )
         goto Exit;
 
       usePsName = FT_BOOL( fvar_head.instanceSize ==
                            6 + 4 * fvar_head.axisCount );
 
       FT_TRACE2(( "loaded\n" ));
 
       FT_TRACE5(( "%d variation ax%s\n",
                   fvar_head.axisCount,
                   fvar_head.axisCount == 1 ? "is" : "es" ));
 
       if ( FT_NEW( face->blend ) )
         goto Exit;
 
       num_axes              = fvar_head.axisCount;
       face->blend->num_axis = num_axes;
     }
     else
       num_axes = face->blend->num_axis;
 
     /* `num_instances' holds the number of all named instances, */
     /* including the default instance which might be missing    */
     /* in fvar's table of named instances                       */
     num_instances = (FT_UInt)face->root.style_flags >> 16;
 
     /* prepare storage area for MM data; this cannot overflow   */
     /* 32-bit arithmetic because of the size limits used in the */
     /* `fvar' table validity check in `sfnt_init_face'          */
 
     /* the various `*_size' variables, which we also use as     */
     /* offsets into the `mmlen' array, must be multiples of the */
     /* pointer size (except the last one); without such an      */
     /* alignment there might be runtime errors due to           */
     /* misaligned addresses                                     */
 #undef  ALIGN_SIZE
 #define ALIGN_SIZE( n ) \
           ( ( (n) + sizeof (void*) - 1 ) & ~( sizeof (void*) - 1 ) )
 
     mmvar_size       = ALIGN_SIZE( sizeof ( FT_MM_Var ) );
     axis_flags_size  = ALIGN_SIZE( num_axes *
                                    sizeof ( FT_UShort ) );
     axis_size        = ALIGN_SIZE( num_axes *
                                    sizeof ( FT_Var_Axis ) );
     namedstyle_size  = ALIGN_SIZE( num_instances *
                                    sizeof ( FT_Var_Named_Style ) );
     next_coords_size = ALIGN_SIZE( num_instances *
                                    num_axes *
                                    sizeof ( FT_Fixed ) );
     next_name_size   = num_axes * 5;
 
     if ( need_init )
     {
       face->blend->mmvar_len = mmvar_size       +
                                axis_flags_size  +
                                axis_size        +
                                namedstyle_size  +
                                next_coords_size +
                                next_name_size;
 
       if ( FT_ALLOC( mmvar, face->blend->mmvar_len ) )
         goto Exit;
       face->blend->mmvar = mmvar;
 
       /* set up pointers and offsets into the `mmvar' array; */
       /* the data gets filled in later on                    */
 
       mmvar->num_axis =
         num_axes;
       mmvar->num_designs =
         ~0U;                   /* meaningless in this context; each glyph */
                                /* may have a different number of designs  */
                                /* (or tuples, as called by Apple)         */
       mmvar->num_namedstyles =
         num_instances;
 
       /* alas, no public field in `FT_Var_Axis' for axis flags */
       axis_flags =
         (FT_UShort*)( (char*)mmvar + mmvar_size );
       mmvar->axis =
         (FT_Var_Axis*)( (char*)axis_flags + axis_flags_size );
       mmvar->namedstyle =
         (FT_Var_Named_Style*)( (char*)mmvar->axis + axis_size );
 
       next_coords = (FT_Fixed*)( (char*)mmvar->namedstyle +
                                  namedstyle_size );
       for ( i = 0; i < num_instances; i++ )
       {
         mmvar->namedstyle[i].coords  = next_coords;
         next_coords                 += num_axes;
       }
 
       next_name = (FT_String*)( (char*)mmvar->namedstyle +
                                 namedstyle_size + next_coords_size );
       for ( i = 0; i < num_axes; i++ )
       {
         mmvar->axis[i].name  = next_name;
         next_name           += 5;
       }
 
       /* now fill in the data */
 
       if ( FT_STREAM_SEEK( fvar_start + fvar_head.offsetToData ) )
         goto Exit;
 
       a = mmvar->axis;
       for ( i = 0; i < num_axes; i++ )
       {
         GX_FVar_Axis  axis_rec;
 
 #ifdef FT_DEBUG_LEVEL_TRACE
         int  invalid = 0;
 #endif
 
 
         if ( FT_STREAM_READ_FIELDS( fvaraxis_fields, &axis_rec ) )
           goto Exit;
         a->tag     = axis_rec.axisTag;
         a->minimum = axis_rec.minValue;
         a->def     = axis_rec.defaultValue;
         a->maximum = axis_rec.maxValue;
         a->strid   = axis_rec.nameID;
 
         a->name[0] = (FT_String)(   a->tag >> 24 );
         a->name[1] = (FT_String)( ( a->tag >> 16 ) & 0xFF );
         a->name[2] = (FT_String)( ( a->tag >>  8 ) & 0xFF );
         a->name[3] = (FT_String)( ( a->tag       ) & 0xFF );
         a->name[4] = '\0';
 
         *axis_flags = axis_rec.flags;
 
         if ( a->minimum > a->def ||
              a->def > a->maximum )
         {
           a->minimum = a->def;
           a->maximum = a->def;
 
 #ifdef FT_DEBUG_LEVEL_TRACE
           invalid = 1;
 #endif
         }
 
 #ifdef FT_DEBUG_LEVEL_TRACE
         if ( i == 0 )
           FT_TRACE5(( "  idx   tag  "
                    /* "  XXX  `XXXX'" */
                       "    minimum     default     maximum   flags\n" ));
                    /* "  XXXX.XXXXX  XXXX.XXXXX  XXXX.XXXXX  0xXXXX" */
 
         FT_TRACE5(( "  %3d  `%s'"
                     "  %10.5f  %10.5f  %10.5f  0x%04X%s\n",
                     i,
                     a->name,
                     a->minimum / 65536.0,
                     a->def / 65536.0,
                     a->maximum / 65536.0,
                     *axis_flags,
                     invalid ? " (invalid, disabled)" : "" ));
 #endif
 
         a++;
         axis_flags++;
       }
 
       FT_TRACE5(( "\n" ));
 
       /* named instance coordinates are stored as design coordinates; */
       /* we have to convert them to normalized coordinates also       */
       if ( FT_NEW_ARRAY( face->blend->normalized_stylecoords,
                          num_axes * num_instances ) )
         goto Exit;
 
       if ( fvar_head.instanceCount && !face->blend->avar_loaded )
       {
         FT_ULong  offset = FT_STREAM_POS();
 
 
         ft_var_load_avar( face );
 
         if ( FT_STREAM_SEEK( offset ) )
           goto Exit;
       }
 
       FT_TRACE5(( "%d instance%s\n",
                   fvar_head.instanceCount,
                   fvar_head.instanceCount == 1 ? "" : "s" ));
 
       ns  = mmvar->namedstyle;
       nsc = face->blend->normalized_stylecoords;
       for ( i = 0; i < fvar_head.instanceCount; i++, ns++ )
       {
         /* PostScript names add 2 bytes to the instance record size */
         if ( FT_FRAME_ENTER( ( usePsName ? 6L : 4L ) +
                              4L * num_axes ) )
           goto Exit;
 
         ns->strid       =    FT_GET_USHORT();
         (void) /* flags = */ FT_GET_USHORT();
 
         c = ns->coords;
         for ( j = 0; j < num_axes; j++, c++ )
           *c = FT_GET_LONG();
 
         /* valid psid values are 6, [256;32767], and 0xFFFF */
         if ( usePsName )
           ns->psid = FT_GET_USHORT();
         else
           ns->psid = 0xFFFF;
 
 #ifdef FT_DEBUG_LEVEL_TRACE
         {
           SFNT_Service  sfnt = (SFNT_Service)face->sfnt;
 
           FT_String*  strname = NULL;
           FT_String*  psname  = NULL;
 
           FT_ULong  pos;
 
 
           pos = FT_STREAM_POS();
 
           if ( ns->strid != 0xFFFF )
           {
             (void)sfnt->get_name( face,
                                   (FT_UShort)ns->strid,
                                   &strname );
             if ( strname && !ft_strcmp( strname, ".notdef" ) )
               strname = NULL;
           }
 
           if ( ns->psid != 0xFFFF )
           {
             (void)sfnt->get_name( face,
                                   (FT_UShort)ns->psid,
                                   &psname );
             if ( psname && !ft_strcmp( psname, ".notdef" ) )
               psname = NULL;
           }
 
           (void)FT_STREAM_SEEK( pos );
 
           FT_TRACE5(( "  instance %d (%s%s%s, %s%s%s)\n",
                       i,
                       strname ? "name: `" : "",
                       strname ? strname : "unnamed",
                       strname ? "'" : "",
                       psname ? "PS name: `" : "",
                       psname ? psname : "no PS name",
                       psname ? "'" : "" ));
 
           FT_FREE( strname );
           FT_FREE( psname );
         }
 #endif /* FT_DEBUG_LEVEL_TRACE */
 
         ft_var_to_normalized( face, num_axes, ns->coords, nsc );
         nsc += num_axes;
 
         FT_FRAME_EXIT();
       }
 
       if ( num_instances != fvar_head.instanceCount )
       {
         SFNT_Service  sfnt = (SFNT_Service)face->sfnt;
 
         FT_Int   found, dummy1, dummy2;
         FT_UInt  strid = ~0U;
 
 
         /* the default instance is missing in array the   */
         /* of named instances; try to synthesize an entry */
         found = sfnt->get_name_id( face,
                                    TT_NAME_ID_TYPOGRAPHIC_SUBFAMILY,
                                    &dummy1,
                                    &dummy2 );
         if ( found )
           strid = TT_NAME_ID_TYPOGRAPHIC_SUBFAMILY;
         else
         {
           found = sfnt->get_name_id( face,
                                      TT_NAME_ID_FONT_SUBFAMILY,
                                      &dummy1,
                                      &dummy2 );
           if ( found )
             strid = TT_NAME_ID_FONT_SUBFAMILY;
         }
 
         if ( found )
         {
           found = sfnt->get_name_id( face,
                                      TT_NAME_ID_PS_NAME,
                                      &dummy1,
                                      &dummy2 );
           if ( found )
           {
             FT_TRACE5(( "TT_Get_MM_Var:"
                         " Adding default instance to named instances\n" ));
 
             ns = &mmvar->namedstyle[fvar_head.instanceCount];
 
             ns->strid = strid;
             ns->psid  = TT_NAME_ID_PS_NAME;
 
             a = mmvar->axis;
             c = ns->coords;
             for ( j = 0; j < num_axes; j++, a++, c++ )
               *c = a->def;
           }
         }
       }
 
       ft_var_load_mvar( face );
     }
 
     /* fill the output array if requested */
 
     if ( master )
     {
       FT_UInt  n;
 
 
       if ( FT_ALLOC( mmvar, face->blend->mmvar_len ) )
         goto Exit;
       FT_MEM_COPY( mmvar, face->blend->mmvar, face->blend->mmvar_len );
 
       axis_flags =
         (FT_UShort*)( (char*)mmvar + mmvar_size );
       mmvar->axis =
         (FT_Var_Axis*)( (char*)axis_flags + axis_flags_size );
       mmvar->namedstyle =
         (FT_Var_Named_Style*)( (char*)mmvar->axis+ axis_size );
 
       next_coords = (FT_Fixed*)( (char*)mmvar->namedstyle +
                                  namedstyle_size );
       for ( n = 0; n < mmvar->num_namedstyles; n++ )
       {
         mmvar->namedstyle[n].coords  = next_coords;
         next_coords                 += num_axes;
       }
 
       a         = mmvar->axis;
       next_name = (FT_String*)( (char*)mmvar->namedstyle +
                                 namedstyle_size + next_coords_size );
       for ( n = 0; n < num_axes; n++ )
       {
         a->name = next_name;
 
         /* standard PostScript names for some standard apple tags */
         if ( a->tag == TTAG_wght )
           a->name = (char*)"Weight";
         else if ( a->tag == TTAG_wdth )
           a->name = (char*)"Width";
         else if ( a->tag == TTAG_opsz )
           a->name = (char*)"OpticalSize";
         else if ( a->tag == TTAG_slnt )
           a->name = (char*)"Slant";
 
         next_name += 5;
         a++;
       }
 
       *master = mmvar;
     }
 
   Exit:
     return error;
   }
 
 
   static FT_Error
   tt_set_mm_blend( TT_Face    face,
                    FT_UInt    num_coords,
                    FT_Fixed*  coords,
                    FT_Bool    set_design_coords )
   {
     FT_Error    error = FT_Err_Ok;
     GX_Blend    blend;
     FT_MM_Var*  mmvar;
     FT_UInt     i;
 
     FT_Bool     all_design_coords = FALSE;
 
     FT_Memory   memory = face->root.memory;
 
     enum
     {
       mcvt_retain,
       mcvt_modify,
       mcvt_load
 
     } manageCvt;
 
 
     face->doblend = FALSE;
 
     if ( !face->blend )
     {
       if ( FT_SET_ERROR( TT_Get_MM_Var( face, NULL ) ) )
         goto Exit;
     }
 
     blend = face->blend;
     mmvar = blend->mmvar;
 
     if ( num_coords > mmvar->num_axis )
     {
       FT_TRACE2(( "TT_Set_MM_Blend:"
                   " only using first %d of %d coordinates\n",
                   mmvar->num_axis, num_coords ));
       num_coords = mmvar->num_axis;
     }
 
     FT_TRACE5(( "TT_Set_MM_Blend:\n"
                 "  normalized design coordinates:\n" ));
 
     for ( i = 0; i < num_coords; i++ )
     {
       FT_TRACE5(( "    %.5f\n", coords[i] / 65536.0 ));
       if ( coords[i] < -0x00010000L || coords[i] > 0x00010000L )
       {
         FT_TRACE1(( "TT_Set_MM_Blend: normalized design coordinate %.5f\n"
                     "                 is out of range [-1;1]\n",
                     coords[i] / 65536.0 ));
         error = FT_THROW( Invalid_Argument );
         goto Exit;
       }
     }
 
     FT_TRACE5(( "\n" ));
 
     if ( !face->is_cff2 && !blend->glyphoffsets )
       if ( FT_SET_ERROR( ft_var_load_gvar( face ) ) )
         goto Exit;
 
     if ( !blend->coords )
     {
       if ( FT_NEW_ARRAY( blend->coords, mmvar->num_axis ) )
         goto Exit;
 
       /* the first time we have to compute all design coordinates */
       all_design_coords = TRUE;
     }
 
     if ( !blend->normalizedcoords )
     {
       if ( FT_NEW_ARRAY( blend->normalizedcoords, mmvar->num_axis ) )
         goto Exit;
 
       manageCvt = mcvt_modify;
 
       /* If we have not set the blend coordinates before this, then the  */
       /* cvt table will still be what we read from the `cvt ' table and  */
       /* we don't need to reload it.  We may need to change it though... */
     }
     else
     {
       FT_Bool    have_diff = 0;
       FT_UInt    j;
       FT_Fixed*  c;
       FT_Fixed*  n;
 
 
       manageCvt = mcvt_retain;
 
       for ( i = 0; i < num_coords; i++ )
       {
         if ( blend->normalizedcoords[i] != coords[i] )
         {
           manageCvt = mcvt_load;
           have_diff = 1;
           break;
         }
       }
 
       if ( FT_IS_NAMED_INSTANCE( FT_FACE( face ) ) )
       {
         FT_UInt  idx = (FT_UInt)face->root.face_index >> 16;
 
 
         c = blend->normalizedcoords + i;
         n = blend->normalized_stylecoords + idx * mmvar->num_axis + i;
         for ( j = i; j < mmvar->num_axis; j++, n++, c++ )
           if ( *c != *n )
             have_diff = 1;
       }
       else
       {
         c = blend->normalizedcoords + i;
         for ( j = i; j < mmvar->num_axis; j++, c++ )
           if ( *c != 0 )
             have_diff = 1;
       }
 
       /* return value -1 indicates `no change' */
       if ( !have_diff )
         return -1;
 
       for ( ; i < mmvar->num_axis; i++ )
       {
         if ( blend->normalizedcoords[i] != 0 )
         {
           manageCvt = mcvt_load;
           break;
         }
       }
 
       /* If we don't change the blend coords then we don't need to do  */
       /* anything to the cvt table.  It will be correct.  Otherwise we */
       /* no longer have the original cvt (it was modified when we set  */
       /* the blend last time), so we must reload and then modify it.   */
     }
 
     blend->num_axis = mmvar->num_axis;
     FT_MEM_COPY( blend->normalizedcoords,
                  coords,
                  num_coords * sizeof ( FT_Fixed ) );
 
     if ( set_design_coords )
       ft_var_to_design( face,
                         all_design_coords ? blend->num_axis : num_coords,
                         blend->normalizedcoords,
                         blend->coords );
 
     face->doblend = TRUE;
 
     if ( face->cvt )
     {
       switch ( manageCvt )
       {
       case mcvt_load:
         /* The cvt table has been loaded already; every time we change the */
         /* blend we may need to reload and remodify the cvt table.         */
         FT_FREE( face->cvt );
         face->cvt = NULL;
 
         error = tt_face_load_cvt( face, face->root.stream );
         break;
 
       case mcvt_modify:
         /* The original cvt table is in memory.  All we need to do is */
         /* apply the `cvar' table (if any).                           */
         error = tt_face_vary_cvt( face, face->root.stream );
         break;
 
       case mcvt_retain:
         /* The cvt table is correct for this set of coordinates. */
         break;
       }
     }
 
     /* enforce recomputation of the PostScript name; */
     FT_FREE( face->postscript_name );
     face->postscript_name = NULL;
 
   Exit:
     return error;
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   TT_Set_MM_Blend
    *
    * @Description:
    *   Set the blend (normalized) coordinates for this instance of the
    *   font.  Check that the `gvar' table is reasonable and does some
    *   initial preparation.
    *
    * @InOut:
    *   face ::
    *     The font.
    *     Initialize the blend structure with `gvar' data.
    *
    * @Input:
    *   num_coords ::
    *     The number of available coordinates.  If it is
    *     larger than the number of axes, ignore the excess
    *     values.  If it is smaller than the number of axes,
    *     use the default value (0) for the remaining axes.
    *
    *   coords ::
    *     An array of `num_coords', each between [-1,1].
    *
    * @Return:
    *   FreeType error code.  0 means success.
    */
   FT_LOCAL_DEF( FT_Error )
   TT_Set_MM_Blend( TT_Face    face,
                    FT_UInt    num_coords,
                    FT_Fixed*  coords )
   {
     FT_Error  error;
 
 
     error = tt_set_mm_blend( face, num_coords, coords, 1 );
     if ( error )
       return error;
 
     if ( num_coords )
       face->root.face_flags |= FT_FACE_FLAG_VARIATION;
     else
       face->root.face_flags &= ~FT_FACE_FLAG_VARIATION;
 
     return FT_Err_Ok;
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   TT_Get_MM_Blend
    *
    * @Description:
    *   Get the blend (normalized) coordinates for this instance of the
    *   font.
    *
    * @InOut:
    *   face ::
    *     The font.
    *     Initialize the blend structure with `gvar' data.
    *
    * @Input:
    *   num_coords ::
    *     The number of available coordinates.  If it is
    *     larger than the number of axes, set the excess
    *     values to 0.
    *
    *   coords ::
    *     An array of `num_coords', each between [-1,1].
    *
    * @Return:
    *   FreeType error code.  0 means success.
    */
   FT_LOCAL_DEF( FT_Error )
   TT_Get_MM_Blend( TT_Face    face,
                    FT_UInt    num_coords,
                    FT_Fixed*  coords )
   {
     FT_Error  error = FT_Err_Ok;
     GX_Blend  blend;
     FT_UInt   i, nc;
 
 
     if ( !face->blend )
     {
       if ( FT_SET_ERROR( TT_Get_MM_Var( face, NULL ) ) )
         return error;
     }
 
     blend = face->blend;
 
     if ( !blend->coords )
     {
       /* select default instance coordinates */
       /* if no instance is selected yet      */
       if ( FT_SET_ERROR( tt_set_mm_blend( face, 0, NULL, 1 ) ) )
         return error;
     }
 
     nc = num_coords;
     if ( num_coords > blend->num_axis )
     {
       FT_TRACE2(( "TT_Get_MM_Blend:"
                   " only using first %d of %d coordinates\n",
                   blend->num_axis, num_coords ));
       nc = blend->num_axis;
     }
 
     if ( face->doblend )
     {
       for ( i = 0; i < nc; i++ )
         coords[i] = blend->normalizedcoords[i];
     }
     else
     {
       for ( i = 0; i < nc; i++ )
         coords[i] = 0;
     }
 
     for ( ; i < num_coords; i++ )
       coords[i] = 0;
 
     return FT_Err_Ok;
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   TT_Set_Var_Design
    *
    * @Description:
    *   Set the coordinates for the instance, measured in the user
    *   coordinate system.  Parse the `avar' table (if present) to convert
    *   from user to normalized coordinates.
    *
    * @InOut:
    *   face ::
    *     The font face.
    *     Initialize the blend struct with `gvar' data.
    *
    * @Input:
    *   num_coords ::
    *     The number of available coordinates.  If it is
    *     larger than the number of axes, ignore the excess
    *     values.  If it is smaller than the number of axes,
    *     use the default values for the remaining axes.
    *
    *   coords ::
    *     A coordinate array with `num_coords' elements.
    *
    * @Return:
    *   FreeType error code.  0 means success.
    */
   FT_LOCAL_DEF( FT_Error )
   TT_Set_Var_Design( TT_Face    face,
                      FT_UInt    num_coords,
                      FT_Fixed*  coords )
   {
     FT_Error    error  = FT_Err_Ok;
     GX_Blend    blend;
     FT_MM_Var*  mmvar;
     FT_UInt     i;
     FT_Memory   memory = face->root.memory;
 
     FT_Fixed*  c;
     FT_Fixed*  n;
     FT_Fixed*  normalized = NULL;
 
     FT_Bool  have_diff = 0;
 
 
     if ( !face->blend )
     {
       if ( FT_SET_ERROR( TT_Get_MM_Var( face, NULL ) ) )
         goto Exit;
     }
 
     blend = face->blend;
     mmvar = blend->mmvar;
 
     if ( num_coords > mmvar->num_axis )
     {
       FT_TRACE2(( "TT_Set_Var_Design:"
                   " only using first %d of %d coordinates\n",
                   mmvar->num_axis, num_coords ));
       num_coords = mmvar->num_axis;
     }
 
     if ( !blend->coords )
     {
       if ( FT_NEW_ARRAY( blend->coords, mmvar->num_axis ) )
         goto Exit;
     }
 
     c = blend->coords;
     n = coords;
     for ( i = 0; i < num_coords; i++, n++, c++ )
     {
       if ( *c != *n )
       {
         *c        = *n;
         have_diff = 1;
       }
     }
 
     if ( FT_IS_NAMED_INSTANCE( FT_FACE( face ) ) )
     {
       FT_UInt              instance_index;
       FT_Var_Named_Style*  named_style;
 
 
       instance_index = (FT_UInt)face->root.face_index >> 16;
       named_style    = mmvar->namedstyle + instance_index - 1;
 
       n = named_style->coords + num_coords;
       for ( ; i < mmvar->num_axis; i++, n++, c++ )
       {
         if ( *c != *n )
         {
           *c        = *n;
           have_diff = 1;
         }
       }
     }
     else
     {
       FT_Var_Axis*  a;
 
 
       a = mmvar->axis + num_coords;
       for ( ; i < mmvar->num_axis; i++, a++, c++ )
       {
         if ( *c != a->def )
         {
           *c        = a->def;
           have_diff = 1;
         }
       }
     }
 
     /* return value -1 indicates `no change';                      */
     /* we can exit early if `normalizedcoords' is already computed */
     if ( blend->normalizedcoords && !have_diff )
       return -1;
 
     if ( FT_NEW_ARRAY( normalized, mmvar->num_axis ) )
       goto Exit;
 
     if ( !face->blend->avar_loaded )
       ft_var_load_avar( face );
 
     FT_TRACE5(( "TT_Set_Var_Design:\n"
                 "  normalized design coordinates:\n" ));
     ft_var_to_normalized( face, num_coords, blend->coords, normalized );
 
     error = tt_set_mm_blend( face, mmvar->num_axis, normalized, 0 );
     if ( error )
       goto Exit;
 
     if ( num_coords )
       face->root.face_flags |= FT_FACE_FLAG_VARIATION;
     else
       face->root.face_flags &= ~FT_FACE_FLAG_VARIATION;
 
   Exit:
     FT_FREE( normalized );
     return error;
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   TT_Get_Var_Design
    *
    * @Description:
    *   Get the design coordinates of the currently selected interpolated
    *   font.
    *
    * @Input:
    *   face ::
    *     A handle to the source face.
    *
    *   num_coords ::
    *     The number of design coordinates to retrieve.  If it
    *     is larger than the number of axes, set the excess
    *     values to~0.
    *
    * @Output:
    *   coords ::
    *     The design coordinates array.
    *
    * @Return:
    *   FreeType error code.  0~means success.
    */
   FT_LOCAL_DEF( FT_Error )
   TT_Get_Var_Design( TT_Face    face,
                      FT_UInt    num_coords,
                      FT_Fixed*  coords )
   {
     FT_Error  error = FT_Err_Ok;
     GX_Blend  blend;
     FT_UInt   i, nc;
 
 
     if ( !face->blend )
     {
       if ( FT_SET_ERROR( TT_Get_MM_Var( face, NULL ) ) )
         return error;
     }
 
     blend = face->blend;
 
     if ( !blend->coords )
     {
       /* select default instance coordinates */
       /* if no instance is selected yet      */
       if ( FT_SET_ERROR( tt_set_mm_blend( face, 0, NULL, 1 ) ) )
         return error;
     }
 
     nc = num_coords;
     if ( num_coords > blend->num_axis )
     {
       FT_TRACE2(( "TT_Get_Var_Design:"
                   " only using first %d of %d coordinates\n",
                   blend->num_axis, num_coords ));
       nc = blend->num_axis;
     }
 
     if ( face->doblend )
     {
       for ( i = 0; i < nc; i++ )
         coords[i] = blend->coords[i];
     }
     else
     {
       for ( i = 0; i < nc; i++ )
         coords[i] = 0;
     }
 
     for ( ; i < num_coords; i++ )
       coords[i] = 0;
 
     return FT_Err_Ok;
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   TT_Set_Named_Instance
    *
    * @Description:
    *   Set the given named instance, also resetting any further
    *   variation.
    *
    * @Input:
    *   face ::
    *     A handle to the source face.
    *
    *   instance_index ::
    *     The instance index, starting with value 1.
    *     Value 0 indicates to not use an instance.
    *
    * @Return:
    *   FreeType error code.  0~means success.
    */
   FT_LOCAL_DEF( FT_Error )
   TT_Set_Named_Instance( TT_Face  face,
                          FT_UInt  instance_index )
   {
     FT_Error    error = FT_ERR( Invalid_Argument );
     GX_Blend    blend;
     FT_MM_Var*  mmvar;
 
     FT_UInt  num_instances;
 
 
     if ( !face->blend )
     {
       if ( FT_SET_ERROR( TT_Get_MM_Var( face, NULL ) ) )
         goto Exit;
     }
 
     blend = face->blend;
     mmvar = blend->mmvar;
 
     num_instances = (FT_UInt)face->root.style_flags >> 16;
 
     /* `instance_index' starts with value 1, thus `>' */
     if ( instance_index > num_instances )
       goto Exit;
 
     if ( instance_index > 0 && mmvar->namedstyle )
     {
       FT_Memory     memory = face->root.memory;
       SFNT_Service  sfnt   = (SFNT_Service)face->sfnt;
 
       FT_Var_Named_Style*  named_style;
       FT_String*           style_name;
 
 
       named_style = mmvar->namedstyle + instance_index - 1;
 
       error = sfnt->get_name( face,
                               (FT_UShort)named_style->strid,
                               &style_name );
       if ( error )
         goto Exit;
 
       /* set (or replace) style name */
       FT_FREE( face->root.style_name );
       face->root.style_name = style_name;
 
       /* finally, select the named instance */
       error = TT_Set_Var_Design( face,
                                  mmvar->num_axis,
                                  named_style->coords );
       if ( error )
         goto Exit;
     }
     else
       error = TT_Set_Var_Design( face, 0, NULL );
 
     face->root.face_index  = ( instance_index << 16 )             |
                              ( face->root.face_index & 0xFFFFL );
     face->root.face_flags &= ~FT_FACE_FLAG_VARIATION;
 
   Exit:
     return error;
   }
 
 
   /*************************************************************************/
   /*************************************************************************/
   /*****                                                               *****/
   /*****                     GX VAR PARSING ROUTINES                   *****/
   /*****                                                               *****/
   /*************************************************************************/
   /*************************************************************************/
 
 
   /**************************************************************************
    *
    * @Function:
    *   tt_face_vary_cvt
    *
    * @Description:
    *   Modify the loaded cvt table according to the `cvar' table and the
    *   font's blend.
    *
    * @InOut:
    *   face ::
    *     A handle to the target face object.
    *
    * @Input:
    *   stream ::
    *     A handle to the input stream.
    *
    * @Return:
    *   FreeType error code.  0 means success.
    *
    *   Most errors are ignored.  It is perfectly valid not to have a
    *   `cvar' table even if there is a `gvar' and `fvar' table.
    */
   FT_LOCAL_DEF( FT_Error )
   tt_face_vary_cvt( TT_Face    face,
                     FT_Stream  stream )
   {
-    FT_Error    error;
-    FT_Memory   memory = stream->memory;
-    FT_ULong    table_start;
-    FT_ULong    table_len;
-    FT_UInt     tupleCount;
-    FT_ULong    offsetToData;
-    FT_ULong    here;
-    FT_UInt     i, j;
-    FT_Fixed*   tuple_coords    = NULL;
-    FT_Fixed*   im_start_coords = NULL;
-    FT_Fixed*   im_end_coords   = NULL;
-    GX_Blend    blend           = face->blend;
-    FT_UInt     point_count, spoint_count = 0;
+    FT_Error   error;
+    FT_Memory  memory = stream->memory;
+
+    FT_ULong  table_start;
+    FT_ULong  table_len;
+
+    FT_UInt   tupleCount;
+    FT_ULong  offsetToData;
+
+    FT_ULong  here;
+    FT_UInt   i, j;
+
+    FT_Fixed*  tuple_coords    = NULL;
+    FT_Fixed*  im_start_coords = NULL;
+    FT_Fixed*  im_end_coords   = NULL;
+
+    GX_Blend  blend = face->blend;
+
+    FT_UInt  point_count;
+    FT_UInt  spoint_count = 0;
+
     FT_UShort*  sharedpoints = NULL;
     FT_UShort*  localpoints  = NULL;
     FT_UShort*  points;
 
-    FT_Fixed*  deltas;
-    FT_Fixed*  cvt_deltas;
+    FT_Fixed*  deltas     = NULL;
+    FT_Fixed*  cvt_deltas = NULL;
 
 
     FT_TRACE2(( "CVAR " ));
 
     if ( !blend )
     {
       FT_TRACE2(( "\n"
                   "tt_face_vary_cvt: no blend specified\n" ));
       error = FT_Err_Ok;
       goto Exit;
     }
 
     if ( !face->cvt )
     {
       FT_TRACE2(( "\n"
                   "tt_face_vary_cvt: no `cvt ' table\n" ));
       error = FT_Err_Ok;
       goto Exit;
     }
 
     error = face->goto_table( face, TTAG_cvar, stream, &table_len );
     if ( error )
     {
       FT_TRACE2(( "is missing\n" ));
 
       error = FT_Err_Ok;
       goto Exit;
     }
 
     if ( FT_FRAME_ENTER( table_len ) )
     {
       error = FT_Err_Ok;
       goto Exit;
     }
 
     table_start = FT_Stream_FTell( stream );
     if ( FT_GET_LONG() != 0x00010000L )
     {
       FT_TRACE2(( "bad table version\n" ));
 
       error = FT_Err_Ok;
       goto FExit;
     }
 
     FT_TRACE2(( "loaded\n" ));
 
     if ( FT_NEW_ARRAY( tuple_coords, blend->num_axis )    ||
          FT_NEW_ARRAY( im_start_coords, blend->num_axis ) ||
          FT_NEW_ARRAY( im_end_coords, blend->num_axis )   )
       goto FExit;
 
     tupleCount   = FT_GET_USHORT();
     offsetToData = FT_GET_USHORT();
 
     /* rough sanity test */
     if ( offsetToData + ( tupleCount & GX_TC_TUPLE_COUNT_MASK ) * 4 >
            table_len )
     {
       FT_TRACE2(( "tt_face_vary_cvt:"
                   " invalid CVT variation array header\n" ));
 
       error = FT_THROW( Invalid_Table );
       goto FExit;
     }
 
     offsetToData += table_start;
 
     if ( tupleCount & GX_TC_TUPLES_SHARE_POINT_NUMBERS )
     {
       here = FT_Stream_FTell( stream );
 
       FT_Stream_SeekSet( stream, offsetToData );
 
       sharedpoints = ft_var_readpackedpoints( stream,
                                               table_len,
                                               &spoint_count );
       offsetToData = FT_Stream_FTell( stream );
 
       FT_Stream_SeekSet( stream, here );
     }
 
     FT_TRACE5(( "cvar: there %s %d tuple%s:\n",
                 ( tupleCount & 0xFFF ) == 1 ? "is" : "are",
                 tupleCount & 0xFFF,
                 ( tupleCount & 0xFFF ) == 1 ? "" : "s" ));
 
     if ( FT_NEW_ARRAY( cvt_deltas, face->cvt_size ) )
       goto FExit;
 
     for ( i = 0; i < ( tupleCount & 0xFFF ); i++ )
     {
       FT_UInt   tupleDataSize;
       FT_UInt   tupleIndex;
       FT_Fixed  apply;
 
 
       FT_TRACE6(( "  tuple %d:\n", i ));
 
       tupleDataSize = FT_GET_USHORT();
       tupleIndex    = FT_GET_USHORT();
 
       if ( tupleIndex & GX_TI_EMBEDDED_TUPLE_COORD )
       {
         for ( j = 0; j < blend->num_axis; j++ )
           tuple_coords[j] = FT_GET_SHORT() * 4;  /* convert from        */
                                                  /* short frac to fixed */
       }
       else if ( ( tupleIndex & GX_TI_TUPLE_INDEX_MASK ) >= blend->tuplecount )
       {
         FT_TRACE2(( "tt_face_vary_cvt:"
                     " invalid tuple index\n" ));
 
         error = FT_THROW( Invalid_Table );
         goto Exit;
       }
       else
         FT_MEM_COPY(
           tuple_coords,
           &blend->tuplecoords[( tupleIndex & 0xFFF ) * blend->num_axis],
           blend->num_axis * sizeof ( FT_Fixed ) );
 
       if ( tupleIndex & GX_TI_INTERMEDIATE_TUPLE )
       {
         for ( j = 0; j < blend->num_axis; j++ )
           im_start_coords[j] = FT_GET_SHORT() * 4;
         for ( j = 0; j < blend->num_axis; j++ )
           im_end_coords[j] = FT_GET_SHORT() * 4;
       }
 
       apply = ft_var_apply_tuple( blend,
                                   (FT_UShort)tupleIndex,
                                   tuple_coords,
                                   im_start_coords,
                                   im_end_coords );
 
       if ( apply == 0 )              /* tuple isn't active for our blend */
       {
         offsetToData += tupleDataSize;
         continue;
       }
 
       here = FT_Stream_FTell( stream );
 
       FT_Stream_SeekSet( stream, offsetToData );
 
       if ( tupleIndex & GX_TI_PRIVATE_POINT_NUMBERS )
       {
         localpoints = ft_var_readpackedpoints( stream,
                                                table_len,
                                                &point_count );
         points      = localpoints;
       }
       else
       {
         points      = sharedpoints;
         point_count = spoint_count;
       }
 
       deltas = ft_var_readpackeddeltas( stream,
                                         table_len,
                                         point_count == 0 ? face->cvt_size
                                                          : point_count );
 
       if ( !points                                                        ||
            !deltas                                                        ||
            ( localpoints == ALL_POINTS && point_count != face->cvt_size ) )
         ; /* failure, ignore it */
 
       else if ( localpoints == ALL_POINTS )
       {
 #ifdef FT_DEBUG_LEVEL_TRACE
         int  count = 0;
 #endif
 
 
         FT_TRACE7(( "    CVT deltas:\n" ));
 
         /* this means that there are deltas for every entry in cvt */
         for ( j = 0; j < face->cvt_size; j++ )
         {
           FT_Fixed  old_cvt_delta;
 
 
           old_cvt_delta = cvt_deltas[j];
           cvt_deltas[j] = old_cvt_delta + FT_MulFix( deltas[j], apply );
 
 #ifdef FT_DEBUG_LEVEL_TRACE
           if ( old_cvt_delta != cvt_deltas[j] )
           {
             FT_TRACE7(( "      %d: %f -> %f\n",
                         j,
                         ( FT_intToFixed( face->cvt[j] ) +
                           old_cvt_delta ) / 65536.0,
                         ( FT_intToFixed( face->cvt[j] ) +
                           cvt_deltas[j] ) / 65536.0 ));
             count++;
           }
 #endif
         }
 
 #ifdef FT_DEBUG_LEVEL_TRACE
         if ( !count )
           FT_TRACE7(( "      none\n" ));
 #endif
       }
 
       else
       {
 #ifdef FT_DEBUG_LEVEL_TRACE
         int  count = 0;
 #endif
 
 
         FT_TRACE7(( "    CVT deltas:\n" ));
 
         for ( j = 0; j < point_count; j++ )
         {
           int       pindex;
           FT_Fixed  old_cvt_delta;
 
 
           pindex = points[j];
           if ( (FT_ULong)pindex >= face->cvt_size )
             continue;
 
           old_cvt_delta      = cvt_deltas[pindex];
           cvt_deltas[pindex] = old_cvt_delta + FT_MulFix( deltas[j], apply );
 
 #ifdef FT_DEBUG_LEVEL_TRACE
           if ( old_cvt_delta != cvt_deltas[pindex] )
           {
             FT_TRACE7(( "      %d: %f -> %f\n",
                         pindex,
                         ( FT_intToFixed( face->cvt[pindex] ) +
                           old_cvt_delta ) / 65536.0,
                         ( FT_intToFixed( face->cvt[pindex] ) +
                           cvt_deltas[pindex] ) / 65536.0 ));
             count++;
           }
 #endif
         }
 
 #ifdef FT_DEBUG_LEVEL_TRACE
         if ( !count )
           FT_TRACE7(( "      none\n" ));
 #endif
       }
 
       if ( localpoints != ALL_POINTS )
         FT_FREE( localpoints );
       FT_FREE( deltas );
 
       offsetToData += tupleDataSize;
 
       FT_Stream_SeekSet( stream, here );
     }
 
     FT_TRACE5(( "\n" ));
 
     for ( i = 0; i < face->cvt_size; i++ )
       face->cvt[i] += FT_fixedToInt( cvt_deltas[i] );
 
   FExit:
     FT_FRAME_EXIT();
 
   Exit:
     if ( sharedpoints != ALL_POINTS )
       FT_FREE( sharedpoints );
     FT_FREE( tuple_coords );
     FT_FREE( im_start_coords );
     FT_FREE( im_end_coords );
     FT_FREE( cvt_deltas );
 
     return error;
   }
 
 
   /* Shift the original coordinates of all points between indices `p1' */
   /* and `p2', using the same difference as given by index `ref'.      */
 
   /* modeled after `af_iup_shift' */
 
   static void
   tt_delta_shift( int         p1,
                   int         p2,
                   int         ref,
                   FT_Vector*  in_points,
                   FT_Vector*  out_points )
   {
     int        p;
     FT_Vector  delta;
 
 
     delta.x = out_points[ref].x - in_points[ref].x;
     delta.y = out_points[ref].y - in_points[ref].y;
 
     if ( delta.x == 0 && delta.y == 0 )
       return;
 
     for ( p = p1; p < ref; p++ )
     {
       out_points[p].x += delta.x;
       out_points[p].y += delta.y;
     }
 
     for ( p = ref + 1; p <= p2; p++ )
     {
       out_points[p].x += delta.x;
       out_points[p].y += delta.y;
     }
   }
 
 
   /* Interpolate the original coordinates of all points with indices */
   /* between `p1' and `p2', using `ref1' and `ref2' as the reference */
   /* point indices.                                                  */
 
   /* modeled after `af_iup_interp', `_iup_worker_interpolate', and */
   /* `Ins_IUP'                                                     */
 
   static void
   tt_delta_interpolate( int         p1,
                         int         p2,
                         int         ref1,
                         int         ref2,
                         FT_Vector*  in_points,
                         FT_Vector*  out_points )
   {
     int  p, i;
 
     FT_Pos  out, in1, in2, out1, out2, d1, d2;
 
 
     if ( p1 > p2 )
       return;
 
     /* handle both horizontal and vertical coordinates */
     for ( i = 0; i <= 1; i++ )
     {
       /* shift array pointers so that we can access `foo.y' as `foo.x' */
       in_points  = (FT_Vector*)( (FT_Pos*)in_points + i );
       out_points = (FT_Vector*)( (FT_Pos*)out_points + i );
 
       if ( in_points[ref1].x > in_points[ref2].x )
       {
         p    = ref1;
         ref1 = ref2;
         ref2 = p;
       }
 
       in1  = in_points[ref1].x;
       in2  = in_points[ref2].x;
       out1 = out_points[ref1].x;
       out2 = out_points[ref2].x;
       d1   = out1 - in1;
       d2   = out2 - in2;
 
       /* If the reference points have the same coordinate but different */
       /* delta, inferred delta is zero.  Otherwise interpolate.         */
       if ( in1 != in2 || out1 == out2 )
       {
         FT_Fixed  scale = in1 != in2 ? FT_DivFix( out2 - out1, in2 - in1 )
                                      : 0;
 
 
         for ( p = p1; p <= p2; p++ )
         {
           out = in_points[p].x;
 
           if ( out <= in1 )
             out += d1;
           else if ( out >= in2 )
             out += d2;
           else
             out = out1 + FT_MulFix( out - in1, scale );
 
           out_points[p].x = out;
         }
       }
     }
   }
 
 
   /* Interpolate points without delta values, similar to */
   /* the `IUP' hinting instruction.                      */
 
   /* modeled after `Ins_IUP */
 
   static void
   tt_interpolate_deltas( FT_Outline*  outline,
                          FT_Vector*   out_points,
                          FT_Vector*   in_points,
                          FT_Bool*     has_delta )
   {
     FT_Int  first_point;
     FT_Int  end_point;
 
     FT_Int  first_delta;
     FT_Int  cur_delta;
 
     FT_Int    point;
     FT_Short  contour;
 
 
     /* ignore empty outlines */
     if ( !outline->n_contours )
       return;
 
     contour = 0;
     point   = 0;
 
     do
     {
       end_point   = outline->contours[contour];
       first_point = point;
 
       /* search first point that has a delta */
       while ( point <= end_point && !has_delta[point] )
         point++;
 
       if ( point <= end_point )
       {
         first_delta = point;
         cur_delta   = point;
 
         point++;
 
         while ( point <= end_point )
         {
           /* search next point that has a delta  */
           /* and interpolate intermediate points */
           if ( has_delta[point] )
           {
             tt_delta_interpolate( cur_delta + 1,
                                   point - 1,
                                   cur_delta,
                                   point,
                                   in_points,
                                   out_points );
             cur_delta = point;
           }
 
           point++;
         }
 
         /* shift contour if we only have a single delta */
         if ( cur_delta == first_delta )
           tt_delta_shift( first_point,
                           end_point,
                           cur_delta,
                           in_points,
                           out_points );
         else
         {
           /* otherwise handle remaining points       */
           /* at the end and beginning of the contour */
           tt_delta_interpolate( cur_delta + 1,
                                 end_point,
                                 cur_delta,
                                 first_delta,
                                 in_points,
                                 out_points );
 
           if ( first_delta > 0 )
             tt_delta_interpolate( first_point,
                                   first_delta - 1,
                                   cur_delta,
                                   first_delta,
                                   in_points,
                                   out_points );
         }
       }
       contour++;
 
     } while ( contour < outline->n_contours );
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   TT_Vary_Apply_Glyph_Deltas
    *
    * @Description:
    *   Apply the appropriate deltas to the current glyph.
    *
    * @Input:
    *   face ::
    *     A handle to the target face object.
    *
    *   glyph_index ::
    *     The index of the glyph being modified.
    *
    *   n_points ::
    *     The number of the points in the glyph, including
    *     phantom points.
    *
    * @InOut:
    *   outline ::
    *     The outline to change.
    *
    * @Return:
    *   FreeType error code.  0 means success.
    */
   FT_LOCAL_DEF( FT_Error )
   TT_Vary_Apply_Glyph_Deltas( TT_Face      face,
                               FT_UInt      glyph_index,
                               FT_Outline*  outline,
                               FT_UInt      n_points )
   {
     FT_Stream   stream = face->root.stream;
     FT_Memory   memory = stream->memory;
     GX_Blend    blend  = face->blend;
 
     FT_Vector*  points_org = NULL;  /* coordinates in 16.16 format */
     FT_Vector*  points_out = NULL;  /* coordinates in 16.16 format */
     FT_Bool*    has_delta  = NULL;
 
     FT_Error    error;
     FT_ULong    glyph_start;
     FT_UInt     tupleCount;
     FT_ULong    offsetToData;
     FT_ULong    here;
     FT_UInt     i, j;
     FT_Fixed*   tuple_coords    = NULL;
     FT_Fixed*   im_start_coords = NULL;
     FT_Fixed*   im_end_coords   = NULL;
     FT_UInt     point_count, spoint_count = 0;
     FT_UShort*  sharedpoints = NULL;
     FT_UShort*  localpoints  = NULL;
     FT_UShort*  points;
 
     FT_Fixed*  deltas_x;
     FT_Fixed*  deltas_y;
     FT_Fixed*  point_deltas_x;
     FT_Fixed*  point_deltas_y;
 
 
     if ( !face->doblend || !blend )
       return FT_THROW( Invalid_Argument );
 
     if ( glyph_index >= blend->gv_glyphcnt      ||
          blend->glyphoffsets[glyph_index] ==
            blend->glyphoffsets[glyph_index + 1] )
     {
       FT_TRACE2(( "TT_Vary_Apply_Glyph_Deltas:"
                   " no variation data for this glyph\n" ));
       return FT_Err_Ok;
     }
 
     if ( FT_NEW_ARRAY( points_org, n_points ) ||
          FT_NEW_ARRAY( points_out, n_points ) ||
          FT_NEW_ARRAY( has_delta, n_points )  )
       goto Fail1;
 
     if ( FT_STREAM_SEEK( blend->glyphoffsets[glyph_index] )   ||
          FT_FRAME_ENTER( blend->glyphoffsets[glyph_index + 1] -
                            blend->glyphoffsets[glyph_index] ) )
       goto Fail1;
 
     glyph_start = FT_Stream_FTell( stream );
 
     /* each set of glyph variation data is formatted similarly to `cvar' */
 
     if ( FT_NEW_ARRAY( tuple_coords, blend->num_axis )    ||
          FT_NEW_ARRAY( im_start_coords, blend->num_axis ) ||
          FT_NEW_ARRAY( im_end_coords, blend->num_axis )   )
       goto Fail2;
 
     tupleCount   = FT_GET_USHORT();
     offsetToData = FT_GET_USHORT();
 
     /* rough sanity test */
     if ( offsetToData + ( tupleCount & GX_TC_TUPLE_COUNT_MASK ) * 4 >
            blend->gvar_size )
     {
       FT_TRACE2(( "TT_Vary_Apply_Glyph_Deltas:"
                   " invalid glyph variation array header\n" ));
 
       error = FT_THROW( Invalid_Table );
       goto Fail2;
     }
 
     offsetToData += glyph_start;
 
     if ( tupleCount & GX_TC_TUPLES_SHARE_POINT_NUMBERS )
     {
       here = FT_Stream_FTell( stream );
 
       FT_Stream_SeekSet( stream, offsetToData );
 
       sharedpoints = ft_var_readpackedpoints( stream,
                                               blend->gvar_size,
                                               &spoint_count );
       offsetToData = FT_Stream_FTell( stream );
 
       FT_Stream_SeekSet( stream, here );
     }
 
     FT_TRACE5(( "gvar: there %s %d tuple%s:\n",
                 ( tupleCount & GX_TC_TUPLE_COUNT_MASK ) == 1 ? "is" : "are",
                 tupleCount & GX_TC_TUPLE_COUNT_MASK,
                 ( tupleCount & GX_TC_TUPLE_COUNT_MASK ) == 1 ? "" : "s" ));
 
     if ( FT_NEW_ARRAY( point_deltas_x, n_points ) ||
          FT_NEW_ARRAY( point_deltas_y, n_points ) )
       goto Fail3;
 
     for ( j = 0; j < n_points; j++ )
     {
       points_org[j].x = FT_intToFixed( outline->points[j].x );
       points_org[j].y = FT_intToFixed( outline->points[j].y );
     }
 
     for ( i = 0; i < ( tupleCount & GX_TC_TUPLE_COUNT_MASK ); i++ )
     {
       FT_UInt   tupleDataSize;
       FT_UInt   tupleIndex;
       FT_Fixed  apply;
 
 
       FT_TRACE6(( "  tuple %d:\n", i ));
 
       tupleDataSize = FT_GET_USHORT();
       tupleIndex    = FT_GET_USHORT();
 
       if ( tupleIndex & GX_TI_EMBEDDED_TUPLE_COORD )
       {
         for ( j = 0; j < blend->num_axis; j++ )
           tuple_coords[j] = FT_GET_SHORT() * 4;   /* convert from        */
                                                   /* short frac to fixed */
       }
       else if ( ( tupleIndex & GX_TI_TUPLE_INDEX_MASK ) >= blend->tuplecount )
       {
         FT_TRACE2(( "TT_Vary_Apply_Glyph_Deltas:"
                     " invalid tuple index\n" ));
 
         error = FT_THROW( Invalid_Table );
         goto Fail2;
       }
       else
         FT_MEM_COPY(
           tuple_coords,
           &blend->tuplecoords[( tupleIndex & 0xFFF ) * blend->num_axis],
           blend->num_axis * sizeof ( FT_Fixed ) );
 
       if ( tupleIndex & GX_TI_INTERMEDIATE_TUPLE )
       {
         for ( j = 0; j < blend->num_axis; j++ )
           im_start_coords[j] = FT_GET_SHORT() * 4;
         for ( j = 0; j < blend->num_axis; j++ )
           im_end_coords[j] = FT_GET_SHORT() * 4;
       }
 
       apply = ft_var_apply_tuple( blend,
                                   (FT_UShort)tupleIndex,
                                   tuple_coords,
                                   im_start_coords,
                                   im_end_coords );
 
       if ( apply == 0 )              /* tuple isn't active for our blend */
       {
         offsetToData += tupleDataSize;
         continue;
       }
 
       here = FT_Stream_FTell( stream );
 
       FT_Stream_SeekSet( stream, offsetToData );
 
       if ( tupleIndex & GX_TI_PRIVATE_POINT_NUMBERS )
       {
         localpoints = ft_var_readpackedpoints( stream,
                                                blend->gvar_size,
                                                &point_count );
         points      = localpoints;
       }
       else
       {
         points      = sharedpoints;
         point_count = spoint_count;
       }
 
       deltas_x = ft_var_readpackeddeltas( stream,
                                           blend->gvar_size,
                                           point_count == 0 ? n_points
                                                            : point_count );
       deltas_y = ft_var_readpackeddeltas( stream,
                                           blend->gvar_size,
                                           point_count == 0 ? n_points
                                                            : point_count );
 
       if ( !points || !deltas_y || !deltas_x )
         ; /* failure, ignore it */
 
       else if ( points == ALL_POINTS )
       {
 #ifdef FT_DEBUG_LEVEL_TRACE
         int  count = 0;
 #endif
 
 
         FT_TRACE7(( "    point deltas:\n" ));
 
         /* this means that there are deltas for every point in the glyph */
         for ( j = 0; j < n_points; j++ )
         {
           FT_Fixed  old_point_delta_x = point_deltas_x[j];
           FT_Fixed  old_point_delta_y = point_deltas_y[j];
 
           FT_Fixed  point_delta_x = FT_MulFix( deltas_x[j], apply );
           FT_Fixed  point_delta_y = FT_MulFix( deltas_y[j], apply );
 
 
           if ( j < n_points - 4 )
           {
             point_deltas_x[j] = old_point_delta_x + point_delta_x;
             point_deltas_y[j] = old_point_delta_y + point_delta_y;
           }
           else
           {
             /* To avoid double adjustment of advance width or height, */
             /* adjust phantom points only if there is no HVAR or VVAR */
             /* support, respectively.                                 */
             if ( j == ( n_points - 4 )        &&
                  !( face->variation_support &
                     TT_FACE_FLAG_VAR_LSB    ) )
               point_deltas_x[j] = old_point_delta_x + point_delta_x;
 
             else if ( j == ( n_points - 3 )          &&
                       !( face->variation_support   &
                          TT_FACE_FLAG_VAR_HADVANCE ) )
               point_deltas_x[j] = old_point_delta_x + point_delta_x;
 
             else if ( j == ( n_points - 2 )        &&
                       !( face->variation_support &
                          TT_FACE_FLAG_VAR_TSB    ) )
               point_deltas_y[j] = old_point_delta_y + point_delta_y;
 
             else if ( j == ( n_points - 1 )          &&
                       !( face->variation_support   &
                          TT_FACE_FLAG_VAR_VADVANCE ) )
               point_deltas_y[j] = old_point_delta_y + point_delta_y;
           }
 
 #ifdef FT_DEBUG_LEVEL_TRACE
           if ( point_delta_x || point_delta_y )
           {
             FT_TRACE7(( "      %d: (%f, %f) -> (%f, %f)\n",
                         j,
                         ( FT_intToFixed( outline->points[j].x ) +
                           old_point_delta_x ) / 65536.0,
                         ( FT_intToFixed( outline->points[j].y ) +
                           old_point_delta_y ) / 65536.0,
                         ( FT_intToFixed( outline->points[j].x ) +
                           point_deltas_x[j] ) / 65536.0,
                         ( FT_intToFixed( outline->points[j].y ) +
                           point_deltas_y[j] ) / 65536.0 ));
             count++;
           }
 #endif
         }
 
 #ifdef FT_DEBUG_LEVEL_TRACE
         if ( !count )
           FT_TRACE7(( "      none\n" ));
 #endif
       }
 
       else
       {
 #ifdef FT_DEBUG_LEVEL_TRACE
         int  count = 0;
 #endif
 
 
         /* we have to interpolate the missing deltas similar to the */
         /* IUP bytecode instruction                                 */
         for ( j = 0; j < n_points; j++ )
         {
           has_delta[j]  = FALSE;
           points_out[j] = points_org[j];
         }
 
         for ( j = 0; j < point_count; j++ )
         {
           FT_UShort  idx = points[j];
 
 
           if ( idx >= n_points )
             continue;
 
           has_delta[idx] = TRUE;
 
           points_out[idx].x += FT_MulFix( deltas_x[j], apply );
           points_out[idx].y += FT_MulFix( deltas_y[j], apply );
         }
 
         /* no need to handle phantom points here,      */
         /* since solitary points can't be interpolated */
         tt_interpolate_deltas( outline,
                                points_out,
                                points_org,
                                has_delta );
 
         FT_TRACE7(( "    point deltas:\n" ));
 
         for ( j = 0; j < n_points; j++ )
         {
           FT_Fixed  old_point_delta_x = point_deltas_x[j];
           FT_Fixed  old_point_delta_y = point_deltas_y[j];
 
           FT_Pos  point_delta_x = points_out[j].x - points_org[j].x;
           FT_Pos  point_delta_y = points_out[j].y - points_org[j].y;
 
 
           if ( j < n_points - 4 )
           {
             point_deltas_x[j] = old_point_delta_x + point_delta_x;
             point_deltas_y[j] = old_point_delta_y + point_delta_y;
           }
           else
           {
             /* To avoid double adjustment of advance width or height, */
             /* adjust phantom points only if there is no HVAR or VVAR */
             /* support, respectively.                                 */
             if ( j == ( n_points - 4 )        &&
                  !( face->variation_support &
                     TT_FACE_FLAG_VAR_LSB    ) )
               point_deltas_x[j] = old_point_delta_x + point_delta_x;
 
             else if ( j == ( n_points - 3 )          &&
                       !( face->variation_support   &
                          TT_FACE_FLAG_VAR_HADVANCE ) )
               point_deltas_x[j] = old_point_delta_x + point_delta_x;
 
             else if ( j == ( n_points - 2 )        &&
                       !( face->variation_support &
                          TT_FACE_FLAG_VAR_TSB    ) )
               point_deltas_y[j] = old_point_delta_y + point_delta_y;
 
             else if ( j == ( n_points - 1 )          &&
                       !( face->variation_support   &
                          TT_FACE_FLAG_VAR_VADVANCE ) )
               point_deltas_y[j] = old_point_delta_y + point_delta_y;
           }
 
 #ifdef FT_DEBUG_LEVEL_TRACE
           if ( point_delta_x || point_delta_y )
           {
             FT_TRACE7(( "      %d: (%f, %f) -> (%f, %f)\n",
                         j,
                         ( FT_intToFixed( outline->points[j].x ) +
                           old_point_delta_x ) / 65536.0,
                         ( FT_intToFixed( outline->points[j].y ) +
                           old_point_delta_y ) / 65536.0,
                         ( FT_intToFixed( outline->points[j].x ) +
                           point_deltas_x[j] ) / 65536.0,
                         ( FT_intToFixed( outline->points[j].y ) +
                           point_deltas_y[j] ) / 65536.0 ));
             count++;
           }
 #endif
         }
 
 #ifdef FT_DEBUG_LEVEL_TRACE
         if ( !count )
           FT_TRACE7(( "      none\n" ));
 #endif
       }
 
       if ( localpoints != ALL_POINTS )
         FT_FREE( localpoints );
       FT_FREE( deltas_x );
       FT_FREE( deltas_y );
 
       offsetToData += tupleDataSize;
 
       FT_Stream_SeekSet( stream, here );
     }
 
     FT_TRACE5(( "\n" ));
 
     for ( i = 0; i < n_points; i++ )
     {
       outline->points[i].x += FT_fixedToInt( point_deltas_x[i] );
       outline->points[i].y += FT_fixedToInt( point_deltas_y[i] );
     }
 
   Fail3:
     FT_FREE( point_deltas_x );
     FT_FREE( point_deltas_y );
 
   Fail2:
     if ( sharedpoints != ALL_POINTS )
       FT_FREE( sharedpoints );
     FT_FREE( tuple_coords );
     FT_FREE( im_start_coords );
     FT_FREE( im_end_coords );
 
     FT_FRAME_EXIT();
 
   Fail1:
     FT_FREE( points_org );
     FT_FREE( points_out );
     FT_FREE( has_delta );
 
     return error;
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   tt_get_var_blend
    *
    * @Description:
    *   An extended internal version of `TT_Get_MM_Blend' that returns
    *   pointers instead of copying data, without any initialization of
    *   the MM machinery in case it isn't loaded yet.
    */
   FT_LOCAL_DEF( FT_Error )
   tt_get_var_blend( TT_Face      face,
                     FT_UInt     *num_coords,
                     FT_Fixed*   *coords,
                     FT_Fixed*   *normalizedcoords,
                     FT_MM_Var*  *mm_var )
   {
     if ( face->blend )
     {
       if ( num_coords )
         *num_coords       = face->blend->num_axis;
       if ( coords )
         *coords           = face->blend->coords;
       if ( normalizedcoords )
         *normalizedcoords = face->blend->normalizedcoords;
       if ( mm_var )
         *mm_var           = face->blend->mmvar;
     }
     else
     {
       if ( num_coords )
         *num_coords = 0;
       if ( coords )
         *coords     = NULL;
       if ( mm_var )
         *mm_var     = NULL;
     }
 
     return FT_Err_Ok;
   }
 
 
   static void
   ft_var_done_item_variation_store( TT_Face          face,
                                     GX_ItemVarStore  itemStore )
   {
     FT_Memory  memory = FT_FACE_MEMORY( face );
     FT_UInt    i;
 
 
     if ( itemStore->varData )
     {
       for ( i = 0; i < itemStore->dataCount; i++ )
       {
         FT_FREE( itemStore->varData[i].regionIndices );
         FT_FREE( itemStore->varData[i].deltaSet );
       }
 
       FT_FREE( itemStore->varData );
     }
 
     if ( itemStore->varRegionList )
     {
       for ( i = 0; i < itemStore->regionCount; i++ )
         FT_FREE( itemStore->varRegionList[i].axisList );
 
       FT_FREE( itemStore->varRegionList );
     }
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   tt_done_blend
    *
    * @Description:
    *   Free the blend internal data structure.
    */
   FT_LOCAL_DEF( void )
   tt_done_blend( TT_Face  face )
   {
     FT_Memory  memory = FT_FACE_MEMORY( face );
     GX_Blend   blend  = face->blend;
 
 
     if ( blend )
     {
       FT_UInt  i, num_axes;
 
 
       /* blend->num_axis might not be set up yet */
       num_axes = blend->mmvar->num_axis;
 
       FT_FREE( blend->coords );
       FT_FREE( blend->normalizedcoords );
       FT_FREE( blend->normalized_stylecoords );
       FT_FREE( blend->mmvar );
 
       if ( blend->avar_segment )
       {
         for ( i = 0; i < num_axes; i++ )
           FT_FREE( blend->avar_segment[i].correspondence );
         FT_FREE( blend->avar_segment );
       }
 
       if ( blend->hvar_table )
       {
         ft_var_done_item_variation_store( face,
                                           &blend->hvar_table->itemStore );
 
         FT_FREE( blend->hvar_table->widthMap.innerIndex );
         FT_FREE( blend->hvar_table->widthMap.outerIndex );
         FT_FREE( blend->hvar_table );
       }
 
       if ( blend->vvar_table )
       {
         ft_var_done_item_variation_store( face,
                                           &blend->vvar_table->itemStore );
 
         FT_FREE( blend->vvar_table->widthMap.innerIndex );
         FT_FREE( blend->vvar_table->widthMap.outerIndex );
         FT_FREE( blend->vvar_table );
       }
 
       if ( blend->mvar_table )
       {
         ft_var_done_item_variation_store( face,
                                           &blend->mvar_table->itemStore );
 
         FT_FREE( blend->mvar_table->values );
         FT_FREE( blend->mvar_table );
       }
 
       FT_FREE( blend->tuplecoords );
       FT_FREE( blend->glyphoffsets );
       FT_FREE( blend );
     }
   }
 
 #else /* !TT_CONFIG_OPTION_GX_VAR_SUPPORT */
 
   /* ANSI C doesn't like empty source files */
   typedef int  _tt_gxvar_dummy;
 
 #endif /* !TT_CONFIG_OPTION_GX_VAR_SUPPORT */
 
 
 /* END */
