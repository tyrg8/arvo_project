commit f3f90ae7301595761d3445097ce111ffd5220e2d
Author: Jan <31709392+cuellius@users.noreply.github.com>
Date:   Fri Oct 7 17:34:20 2022 +0300

    Code modernization
    
    (cherry picked from commit 46b3ad0a710f3210b6a1d7de15ca51182e4ccd13)

diff --git a/src/hunspell/affentry.cxx b/src/hunspell/affentry.cxx
index bfd6cf5..46e8b58 100644
--- a/src/hunspell/affentry.cxx
+++ b/src/hunspell/affentry.cxx
@@ -1,77 +1,77 @@
 /* ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
  * Copyright (C) 2002-2022 Németh László
  *
  * The contents of this file are subject to the Mozilla Public License Version
  * 1.1 (the "License"); you may not use this file except in compliance with
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * Hunspell is based on MySpell which is Copyright (C) 2002 Kevin Hendricks.
  *
  * Contributor(s): David Einstein, Davide Prina, Giuseppe Modugno,
  * Gianluca Turconi, Simon Brouwer, Noll János, Bíró Árpád,
  * Goldman Eleonóra, Sarlós Tamás, Bencsáth Boldizsár, Halácsy Péter,
  * Dvornik László, Gefferth András, Nagy Viktor, Varga Dániel, Chris Halls,
  * Rene Engelhard, Bram Moolenaar, Dafydd Jones, Harri Pitkänen
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 /*
  * Copyright 2002 Kevin B. Hendricks, Stratford, Ontario, Canada
  * And Contributors.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  *
  * 3. All modifications to the source code must be clearly marked as
  *    such.  Binary redistributions based on modified source code
  *    must be clearly marked as modified versions in the documentation
  *    and/or other materials provided with the distribution.
  *
  * THIS SOFTWARE IS PROVIDED BY KEVIN B. HENDRICKS AND CONTRIBUTORS
  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
  * KEVIN B. HENDRICKS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
 
-#include <stdlib.h>
-#include <string.h>
-#include <stdio.h>
-#include <ctype.h>
+#include <cstdlib>
+#include <cstring>
+#include <cstdio>
+#include <cctype>
 
 #include "affentry.hxx"
 #include "csutil.hxx"
@@ -97,13 +97,13 @@ PfxEntry::PfxEntry(AffixMgr* pmgr)
 // add prefix to this word assuming conditions hold
 std::string PfxEntry::add(const char* word, size_t len) {
   std::string result;
   if ((len > strip.size() || (len == 0 && pmyMgr->get_fullstrip())) &&
       (len >= numconds) && test_condition(word) &&
-      (!strip.size() ||
+      (strip.empty() ||
       (len >= strip.size() && strncmp(word, strip.c_str(), strip.size()) == 0))) {
     /* we have a match so add prefix */
     result.assign(appnd);
     result.append(word + strip.size());
   }
   return result;
 }
@@ -466,14 +466,14 @@ SfxEntry::SfxEntry(AffixMgr* pmgr)
 // add suffix to this word assuming conditions hold
 std::string SfxEntry::add(const char* word, size_t len) {
   std::string result;
   /* make sure all conditions match */
   if ((len > strip.size() || (len == 0 && pmyMgr->get_fullstrip())) &&
       (len >= numconds) && test_condition(word + len, word) &&
-      (!strip.size() ||
+      (strip.empty() ||
        (len >= strip.size() && strcmp(word + len - strip.size(), strip.c_str()) == 0))) {
     result.assign(word, len);
     /* we have a match so add suffix */
     result.replace(len - strip.size(), std::string::npos, appnd);
   }
   return result;
 }
@@ -618,83 +618,83 @@ inline int SfxEntry::test_condition(const char* st, const char* beg) {
 // see if this suffix is present in the word
 struct hentry* SfxEntry::checkword(const std::string& word,
                                    int start,
                                    int len,
                                    int optflags,
                                    PfxEntry* ppfx,
                                    const FLAG cclass,
                                    const FLAG needflag,
                                    const FLAG badflag) {
   struct hentry* he;  // hash entry pointer
   PfxEntry* ep = ppfx;
 
   // if this suffix is being cross checked with a prefix
   // but it does not support cross products skip it
 
   if (((optflags & aeXPRODUCT) != 0) && ((opts & aeXPRODUCT) == 0))
     return NULL;
 
   // upon entry suffix is 0 length or already matches the end of the word.
   // So if the remaining root word has positive length
   // and if there are enough chars in root word and added back strip chars
   // to meet the number of characters conditions, then test it
 
   int tmpl = len - appnd.size(); // length of tmpword
   // the second condition is not enough for UTF-8 strings
   // it checked in test_condition()
 
   if ((tmpl > 0 || (tmpl == 0 && pmyMgr->get_fullstrip())) &&
       (tmpl + strip.size() >= numconds)) {
     // generate new root word by removing suffix and adding
     // back any characters that would have been stripped or
     // or null terminating the shorter string
 
     std::string tmpstring(word, start, tmpl);
-    if (strip.size()) {
+    if (!strip.empty()) {
       tmpstring.append(strip);
     }
 
     const char* tmpword = tmpstring.c_str();
     const char* endword = tmpword + tmpstring.size();
 
     // now make sure all of the conditions on characters
     // are met.  Please see the appendix at the end of
     // this file for more info on exactly what is being
     // tested
 
     // if all conditions are met then check if resulting
     // root word in the dictionary
 
     if (test_condition(endword, tmpword)) {
 #ifdef SZOSZABLYA_POSSIBLE_ROOTS
       fprintf(stdout, "%s %s %c\n", word.c_str() + start, tmpword, aflag);
 #endif
       if ((he = pmyMgr->lookup(tmpstring.c_str(), tmpstring.size())) != NULL) {
         do {
           // check conditional suffix (enabled by prefix)
           if ((TESTAFF(he->astr, aflag, he->alen) ||
                (ep && ep->getCont() &&
                 TESTAFF(ep->getCont(), aflag, ep->getContLen()))) &&
               (((optflags & aeXPRODUCT) == 0) ||
                (ep && TESTAFF(he->astr, ep->getFlag(), he->alen)) ||
                // enabled by prefix
                ((contclass) &&
                 (ep && TESTAFF(contclass, ep->getFlag(), contclasslen)))) &&
               // handle cont. class
               ((!cclass) ||
                ((contclass) && TESTAFF(contclass, cclass, contclasslen))) &&
               // check only in compound homonyms (bad flags)
               (!badflag || !TESTAFF(he->astr, badflag, he->alen)) &&
               // handle required flag
               ((!needflag) ||
                (TESTAFF(he->astr, needflag, he->alen) ||
                 ((contclass) && TESTAFF(contclass, needflag, contclasslen)))))
             return he;
           he = he->next_homonym;  // check homonyms
         } while (he);
       }
     }
   }
   return NULL;
 }
 
 // see if two-level suffix is present in the word
diff --git a/src/hunspell/affentry.hxx b/src/hunspell/affentry.hxx
index 8d35a83..01002f8 100644
--- a/src/hunspell/affentry.hxx
+++ b/src/hunspell/affentry.hxx
@@ -78,69 +78,67 @@
 /* A Prefix Entry  */
 
 class PfxEntry : public AffEntry {
- private:
-  PfxEntry(const PfxEntry&);
-  PfxEntry& operator=(const PfxEntry&);
-
  private:
   AffixMgr* pmyMgr;
 
   PfxEntry* next;
   PfxEntry* nexteq;
   PfxEntry* nextne;
   PfxEntry* flgnxt;
 
  public:
   explicit PfxEntry(AffixMgr* pmgr);
+  PfxEntry(const PfxEntry&) = delete;
+  PfxEntry& operator=(const PfxEntry&) = delete;
 
   bool allowCross() const { return ((opts & aeXPRODUCT) != 0); }
   struct hentry* checkword(const std::string& word,
                            int start,
                            int len,
                            char in_compound,
                            const FLAG needflag = FLAG_NULL);
 
   struct hentry* check_twosfx(const std::string& word,
                               int start,
                               int len,
                               char in_compound,
                               const FLAG needflag = FLAG_NULL);
 
   std::string check_morph(const std::string& word,
                           int start,
                           int len,
                           char in_compound,
                           const FLAG needflag = FLAG_NULL);
 
   std::string check_twosfx_morph(const std::string& word,
                                  int start,
                                  int len,
                                  char in_compound,
                                  const FLAG needflag = FLAG_NULL);
 
   FLAG getFlag() { return aflag; }
   const char* getKey() { return appnd.c_str(); }
   std::string add(const char* word, size_t len);
 
   inline int getKeyLen() { return appnd.size(); }
 
   inline const char* getMorph() { return morphcode; }
 
   inline const unsigned short* getCont() { return contclass; }
   inline unsigned short getContLen() { return contclasslen; }
 
   inline PfxEntry* getNext() { return next; }
   inline PfxEntry* getNextNE() { return nextne; }
   inline PfxEntry* getNextEQ() { return nexteq; }
   inline PfxEntry* getFlgNxt() { return flgnxt; }
 
   inline void setNext(PfxEntry* ptr) { next = ptr; }
   inline void setNextNE(PfxEntry* ptr) { nextne = ptr; }
   inline void setNextEQ(PfxEntry* ptr) { nexteq = ptr; }
   inline void setFlgNxt(PfxEntry* ptr) { flgnxt = ptr; }
 
   inline char* nextchar(char* p);
   inline int test_condition(const std::string& st);
 };
 
 /* A Suffix Entry */
diff --git a/src/hunspell/affixmgr.cxx b/src/hunspell/affixmgr.cxx
index e6576d6..3be0997 100644
--- a/src/hunspell/affixmgr.cxx
+++ b/src/hunspell/affixmgr.cxx
@@ -1,87 +1,87 @@
 /* ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
  * Copyright (C) 2002-2022 Németh László
  *
  * The contents of this file are subject to the Mozilla Public License Version
  * 1.1 (the "License"); you may not use this file except in compliance with
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * Hunspell is based on MySpell which is Copyright (C) 2002 Kevin Hendricks.
  *
  * Contributor(s): David Einstein, Davide Prina, Giuseppe Modugno,
  * Gianluca Turconi, Simon Brouwer, Noll János, Bíró Árpád,
  * Goldman Eleonóra, Sarlós Tamás, Bencsáth Boldizsár, Halácsy Péter,
  * Dvornik László, Gefferth András, Nagy Viktor, Varga Dániel, Chris Halls,
  * Rene Engelhard, Bram Moolenaar, Dafydd Jones, Harri Pitkänen
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 /*
  * Copyright 2002 Kevin B. Hendricks, Stratford, Ontario, Canada
  * And Contributors.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  *
  * 3. All modifications to the source code must be clearly marked as
  *    such.  Binary redistributions based on modified source code
  *    must be clearly marked as modified versions in the documentation
  *    and/or other materials provided with the distribution.
  *
  * THIS SOFTWARE IS PROVIDED BY KEVIN B. HENDRICKS AND CONTRIBUTORS
  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
  * KEVIN B. HENDRICKS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
 
-#include <stdlib.h>
-#include <string.h>
-#include <stdio.h>
-#include <ctype.h>
-#include <time.h>
+#include <cstdlib>
+#include <cstring>
+#include <cstdio>
+#include <cctype>
+#include <ctime>
 
 #include <algorithm>
 #include <memory>
 #include <limits>
 #include <string>
 #include <vector>
 
 #include "affixmgr.hxx"
 #include "affentry.hxx"
 #include "langnum.hxx"
 
 #include "csutil.hxx"
@@ -89,116 +89,114 @@
 AffixMgr::AffixMgr(const char* affpath,
                    const std::vector<HashMgr*>& ptr,
                    const char* key)
   : alldic(ptr)
   , pHMgr(ptr[0]) {
 
   // register hash manager and load affix data from aff file
   csconv = NULL;
   utf8 = 0;
   complexprefixes = 0;
   parsedmaptable = false;
   parsedbreaktable = false;
   iconvtable = NULL;
   oconvtable = NULL;
   // allow simplified compound forms (see 3rd field of CHECKCOMPOUNDPATTERN)
   simplifiedcpd = 0;
   parsedcheckcpd = false;
   parseddefcpd = false;
   phone = NULL;
   compoundflag = FLAG_NULL;        // permits word in compound forms
   compoundbegin = FLAG_NULL;       // may be first word in compound forms
   compoundmiddle = FLAG_NULL;      // may be middle word in compound forms
   compoundend = FLAG_NULL;         // may be last word in compound forms
   compoundroot = FLAG_NULL;        // compound word signing flag
   compoundpermitflag = FLAG_NULL;  // compound permitting flag for suffixed word
   compoundforbidflag = FLAG_NULL;  // compound fordidden flag for suffixed word
   compoundmoresuffixes = 0;        // allow more suffixes within compound words
   checkcompounddup = 0;            // forbid double words in compounds
   checkcompoundrep = 0;  // forbid bad compounds (may be non-compound word with
                          // a REP substitution)
   checkcompoundcase =
       0;  // forbid upper and lowercase combinations at word bounds
   checkcompoundtriple = 0;  // forbid compounds with triple letters
   simplifiedtriple = 0;     // allow simplified triple letters in compounds
                             // (Schiff+fahrt -> Schiffahrt)
   forbiddenword = FORBIDDENWORD;  // forbidden word signing flag
   nosuggest = FLAG_NULL;  // don't suggest words signed with NOSUGGEST flag
   nongramsuggest = FLAG_NULL;
   langnum = 0;  // language code (see http://l10n.openoffice.org/languages.html)
   needaffix = FLAG_NULL;  // forbidden root, allowed only with suffixes
   cpdwordmax = -1;        // default: unlimited wordcount in compound words
   cpdmin = -1;            // undefined
   cpdmaxsyllable = 0;     // default: unlimited syllablecount in compound words
   pfxappnd = NULL;  // previous prefix for counting syllables of the prefix BUG
   sfxappnd = NULL;  // previous suffix for counting syllables of the suffix BUG
   sfxextra = 0;     // modifier for syllable count of sfxappnd BUG
   checknum = 0;               // checking numbers, and word with numbers
   havecontclass = 0;  // flags of possible continuing classes (double affix)
   // LEMMA_PRESENT: not put root into the morphological output. Lemma presents
   // in morhological description in dictionary file. It's often combined with
   // PSEUDOROOT.
   lemma_present = FLAG_NULL;
   circumfix = FLAG_NULL;
   onlyincompound = FLAG_NULL;
   maxngramsugs = -1;  // undefined
   maxdiff = -1;       // undefined
   onlymaxdiff = 0;
   maxcpdsugs = -1;  // undefined
   nosplitsugs = 0;
   sugswithdots = 0;
   keepcase = 0;
   forceucase = 0;
   warn = 0;
   forbidwarn = 0;
   checksharps = 0;
   substandard = FLAG_NULL;
   fullstrip = 0;
 
   sfx = NULL;
   pfx = NULL;
 
   for (int i = 0; i < SETSIZE; i++) {
     pStart[i] = NULL;
     sStart[i] = NULL;
     pFlag[i] = NULL;
     sFlag[i] = NULL;
   }
 
-  for (int j = 0; j < CONTSIZE; j++) {
-    contclasses[j] = 0;
-  }
+  memset(contclasses, 0, CONTSIZE * sizeof(char));
 
   if (parse_file(affpath, key)) {
     HUNSPELL_WARNING(stderr, "Failure loading aff file %s\n", affpath);
   }
 
   /* get encoding for CHECKCOMPOUNDCASE */
   if (!utf8) {
     csconv = get_current_cs(get_encoding());
     for (int i = 0; i <= 255; i++) {
       if ((csconv[i].cupper != csconv[i].clower) &&
           (wordchars.find((char)i) == std::string::npos)) {
         wordchars.push_back((char)i);
       }
     }
   }
 
   // default BREAK definition
   if (!parsedbreaktable) {
-    breaktable.push_back("-");
-    breaktable.push_back("^-");
-    breaktable.push_back("-$");
+    breaktable.emplace_back("-");
+    breaktable.emplace_back("^-");
+    breaktable.emplace_back("-$");
     parsedbreaktable = true;
   }
 
 #if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
   // not entirely sure this is invalid, so only for fuzzing for now
   if (iconvtable && !iconvtable->check_against_breaktable(breaktable)) {
       delete iconvtable;
       iconvtable = nullptr;
   }
 #endif
 
   if (cpdmin == -1)
     cpdmin = MINCPDLEN;
 }
@@ -760,125 +758,125 @@ int AffixMgr::parse_file(const char* affpath, const char* key) {
 int AffixMgr::build_pfxtree(PfxEntry* pfxptr) {
   PfxEntry* ptr;
   PfxEntry* pptr;
   PfxEntry* ep = pfxptr;
 
   // get the right starting points
   const char* key = ep->getKey();
-  const unsigned char flg = (unsigned char)(ep->getFlag() & 0x00FF);
+  const auto flg = (unsigned char)(ep->getFlag() & 0x00FF);
 
   // first index by flag which must exist
   ptr = pFlag[flg];
   ep->setFlgNxt(ptr);
   pFlag[flg] = ep;
 
   // handle the special case of null affix string
   if (strlen(key) == 0) {
     // always inset them at head of list at element 0
     ptr = pStart[0];
     ep->setNext(ptr);
     pStart[0] = ep;
     return 0;
   }
 
   // now handle the normal case
   ep->setNextEQ(NULL);
   ep->setNextNE(NULL);
 
   unsigned char sp = *((const unsigned char*)key);
   ptr = pStart[sp];
 
   // handle the first insert
   if (!ptr) {
     pStart[sp] = ep;
     return 0;
   }
 
   // otherwise use binary tree insertion so that a sorted
   // list can easily be generated later
   pptr = NULL;
   for (;;) {
     pptr = ptr;
     if (strcmp(ep->getKey(), ptr->getKey()) <= 0) {
       ptr = ptr->getNextEQ();
       if (!ptr) {
         pptr->setNextEQ(ep);
         break;
       }
     } else {
       ptr = ptr->getNextNE();
       if (!ptr) {
         pptr->setNextNE(ep);
         break;
       }
     }
   }
   return 0;
 }
 
 // we want to be able to quickly access suffix information
 // both by suffix flag, and sorted by the reverse of the
 // suffix string itself; so we need to set up two indexes
 int AffixMgr::build_sfxtree(SfxEntry* sfxptr) {
 
   sfxptr->initReverseWord();
 
   SfxEntry* ptr;
   SfxEntry* pptr;
   SfxEntry* ep = sfxptr;
 
   /* get the right starting point */
   const char* key = ep->getKey();
-  const unsigned char flg = (unsigned char)(ep->getFlag() & 0x00FF);
+  const auto flg = (unsigned char)(ep->getFlag() & 0x00FF);
 
   // first index by flag which must exist
   ptr = sFlag[flg];
   ep->setFlgNxt(ptr);
   sFlag[flg] = ep;
 
   // next index by affix string
 
   // handle the special case of null affix string
   if (strlen(key) == 0) {
     // always inset them at head of list at element 0
     ptr = sStart[0];
     ep->setNext(ptr);
     sStart[0] = ep;
     return 0;
   }
 
   // now handle the normal case
   ep->setNextEQ(NULL);
   ep->setNextNE(NULL);
 
   unsigned char sp = *((const unsigned char*)key);
   ptr = sStart[sp];
 
   // handle the first insert
   if (!ptr) {
     sStart[sp] = ep;
     return 0;
   }
 
   // otherwise use binary tree insertion so that a sorted
   // list can easily be generated later
   pptr = NULL;
   for (;;) {
     pptr = ptr;
     if (strcmp(ep->getKey(), ptr->getKey()) <= 0) {
       ptr = ptr->getNextEQ();
       if (!ptr) {
         pptr->setNextEQ(ep);
         break;
       }
     } else {
       ptr = ptr->getNextNE();
       if (!ptr) {
         pptr->setNextNE(ep);
         break;
       }
     }
   }
   return 0;
 }
 
 // convert from binary tree to sorted list
@@ -1027,18 +1025,17 @@ std::string& AffixMgr::debugflag(std::string& result, unsigned short flag) {
 // calculate the character length of the condition
 int AffixMgr::condlen(const std::string& s) {
   int l = 0;
   bool group = false;
-  std::string::const_iterator st = s.begin();
-  std::string::const_iterator end = s.end();
+  auto st = s.begin(), end = s.end();
   while (st != end) {
     if (*st == '[') {
       group = true;
       l++;
     } else if (*st == ']')
       group = false;
     else if (!group && (!utf8 || (!(*st & 0x80) || ((*st & 0xc0) == 0x80))))
       l++;
     ++st;
   }
   return l;
 }
@@ -1278,29 +1275,29 @@ std::string AffixMgr::prefix_check_twosfx_morph(const std::string& word,
 // Is word a non-compound with a REP substitution (see checkcompoundrep)?
 int AffixMgr::cpdrep_check(const std::string& in_word, int wl) {
 
   if ((wl < 2) || get_reptable().empty())
     return 0;
 
   std::string word(in_word, 0, wl);
 
-  for (size_t i = 0; i < get_reptable().size(); ++i) {
+  for (const auto& i : get_reptable()) {
     // use only available mid patterns
-    if (!get_reptable()[i].outstrings[0].empty()) {
+    if (!i.outstrings[0].empty()) {
       size_t r = 0;
-      const size_t lenp = get_reptable()[i].pattern.size();
+      const size_t lenp = i.pattern.size();
       // search every occurence of the pattern in the word
-      while (word.find(get_reptable()[i].pattern, r) != std::string::npos) {
+      while (word.find(i.pattern, r) != std::string::npos) {
         std::string candidate(word);
-        candidate.replace(r, lenp, get_reptable()[i].outstrings[0]);
+        candidate.replace(r, lenp, i.outstrings[0]);
         if (candidate_check(candidate))
           return 1;
         ++r;  // search for the next letter
       }
     }
   }
 
  return 0;
 }
 
 // forbid compound words, if they are in the dictionary as a
 // word pair separated by space
@@ -1324,51 +1321,50 @@ int AffixMgr::cpdwordpair_check(const std::string& word, int wl) {
 // forbid compoundings when there are special patterns at word bound
 int AffixMgr::cpdpat_check(const char* word,
                            int pos,
                            hentry* r1,
                            hentry* r2,
                            const char /*affixed*/) {
-  for (size_t i = 0; i < checkcpdtable.size(); ++i) {
+  for (auto& i : checkcpdtable) {
     size_t len;
-    if (isSubset(checkcpdtable[i].pattern2.c_str(), word + pos) &&
-        (!r1 || !checkcpdtable[i].cond ||
-         (r1->astr && TESTAFF(r1->astr, checkcpdtable[i].cond, r1->alen))) &&
-        (!r2 || !checkcpdtable[i].cond2 ||
-         (r2->astr && TESTAFF(r2->astr, checkcpdtable[i].cond2, r2->alen))) &&
+    if (isSubset(i.pattern2.c_str(), word + pos) &&
+        (!r1 || !i.cond ||
+         (r1->astr && TESTAFF(r1->astr, i.cond, r1->alen))) &&
+        (!r2 || !i.cond2 ||
+         (r2->astr && TESTAFF(r2->astr, i.cond2, r2->alen))) &&
         // zero length pattern => only TESTAFF
         // zero pattern (0/flag) => unmodified stem (zero affixes allowed)
-        (checkcpdtable[i].pattern.empty() ||
-         ((checkcpdtable[i].pattern[0] == '0' && r1->blen <= pos &&
+        (i.pattern.empty() ||
+         ((i.pattern[0] == '0' && r1->blen <= pos &&
            strncmp(word + pos - r1->blen, r1->word, r1->blen) == 0) ||
-          (checkcpdtable[i].pattern[0] != '0' &&
-           ((len = checkcpdtable[i].pattern.size()) != 0) && len <= pos &&
-           strncmp(word + pos - len, checkcpdtable[i].pattern.c_str(), len) == 0)))) {
+          (i.pattern[0] != '0' &&
+           ((len = i.pattern.size()) != 0) && len <= pos &&
+           strncmp(word + pos - len, i.pattern.c_str(), len) == 0)))) {
       return 1;
     }
   }
   return 0;
 }
 
 // forbid compounding with neighbouring upper and lower case characters at word
 // bounds
 int AffixMgr::cpdcase_check(const char* word, int pos) {
   if (utf8) {
     const char* p;
     for (p = word + pos - 1; p > word && (*p & 0xc0) == 0x80; p--)
       ;
     std::string pair(p);
     std::vector<w_char> pair_u;
     u8_u16(pair_u, pair);
-    unsigned short a = pair_u.size() > 1 ? (unsigned short)pair_u[1] : 0;
-    unsigned short b = !pair_u.empty() ? (unsigned short)pair_u[0] : 0;
+    unsigned short a = pair_u.size() > 1 ? (unsigned short)pair_u[1] : 0,
+                   b = !pair_u.empty() ? (unsigned short)pair_u[0] : 0;
     if (((unicodetoupper(a, langnum) == a) ||
          (unicodetoupper(b, langnum) == b)) &&
         (a != '-') && (b != '-'))
       return 1;
   } else {
-    unsigned char a = *(word + pos - 1);
-    unsigned char b = *(word + pos);
+    const unsigned char a = *(word + pos - 1), b = *(word + pos);
     if ((csconv[a].ccase || csconv[b].ccase) && (a != '-') && (b != '-'))
       return 1;
   }
   return 0;
 }
@@ -1382,132 +1378,131 @@ struct metachar_data {
 // check compound patterns
 int AffixMgr::defcpd_check(hentry*** words,
                            short wnum,
                            hentry* rv,
                            hentry** def,
                            char all) {
   int w = 0;
 
   if (!*words) {
     w = 1;
     *words = def;
   }
 
   if (!*words) {
     return 0;
   }
 
   std::vector<metachar_data> btinfo(1);
 
   short bt = 0;
 
   (*words)[wnum] = rv;
 
   // has the last word COMPOUNDRULE flag?
   if (rv->alen == 0) {
     (*words)[wnum] = NULL;
     if (w)
       *words = NULL;
     return 0;
   }
   int ok = 0;
-  for (size_t i = 0; i < defcpdtable.size(); ++i) {
-    for (size_t j = 0; j < defcpdtable[i].size(); ++j) {
-      if (defcpdtable[i][j] != '*' && defcpdtable[i][j] != '?' &&
-          TESTAFF(rv->astr, defcpdtable[i][j], rv->alen)) {
+  for (auto& i : defcpdtable) {
+    for (auto& j : i) {
+      if (j != '*' && j != '?' &&
+          TESTAFF(rv->astr, j, rv->alen)) {
         ok = 1;
         break;
       }
     }
   }
   if (ok == 0) {
     (*words)[wnum] = NULL;
     if (w)
       *words = NULL;
     return 0;
   }
 
-  for (size_t i = 0; i < defcpdtable.size(); ++i) {
+  for (auto& i : defcpdtable) {
     size_t pp = 0;  // pattern position
     signed short wp = 0;  // "words" position
-    int ok2;
+    int ok2 = 1;
     ok = 1;
-    ok2 = 1;
     do {
-      while ((pp < defcpdtable[i].size()) && (wp <= wnum)) {
-        if (((pp + 1) < defcpdtable[i].size()) &&
-            ((defcpdtable[i][pp + 1] == '*') ||
-             (defcpdtable[i][pp + 1] == '?'))) {
-          int wend = (defcpdtable[i][pp + 1] == '?') ? wp : wnum;
+      while ((pp < i.size()) && (wp <= wnum)) {
+        if (((pp + 1) < i.size()) &&
+            ((i[pp + 1] == '*') ||
+             (i[pp + 1] == '?'))) {
+          int wend = (i[pp + 1] == '?') ? wp : wnum;
           ok2 = 1;
           pp += 2;
           btinfo[bt].btpp = pp;
           btinfo[bt].btwp = wp;
           while (wp <= wend) {
             if (!(*words)[wp] ||
                 !(*words)[wp]->alen ||
-                !TESTAFF((*words)[wp]->astr, defcpdtable[i][pp - 2],
+                !TESTAFF((*words)[wp]->astr, i[pp - 2],
                          (*words)[wp]->alen)) {
               ok2 = 0;
               break;
             }
             wp++;
           }
           if (wp <= wnum)
             ok2 = 0;
           btinfo[bt].btnum = wp - btinfo[bt].btwp;
           if (btinfo[bt].btnum > 0) {
             ++bt;
             btinfo.resize(bt+1);
           }
           if (ok2)
             break;
         } else {
           ok2 = 1;
           if (!(*words)[wp] || !(*words)[wp]->alen ||
-              !TESTAFF((*words)[wp]->astr, defcpdtable[i][pp],
+              !TESTAFF((*words)[wp]->astr, i[pp],
                        (*words)[wp]->alen)) {
             ok = 0;
             break;
           }
           pp++;
           wp++;
-          if ((defcpdtable[i].size() == pp) && !(wp > wnum))
+          if ((i.size() == pp) && !(wp > wnum))
             ok = 0;
         }
       }
       if (ok && ok2) {
         size_t r = pp;
-        while ((defcpdtable[i].size() > r) && ((r + 1) < defcpdtable[i].size()) &&
-               ((defcpdtable[i][r + 1] == '*') ||
-                (defcpdtable[i][r + 1] == '?')))
+        while ((i.size() > r) && ((r + 1) < i.size()) &&
+               ((i[r + 1] == '*') ||
+                (i[r + 1] == '?')))
           r += 2;
-        if (defcpdtable[i].size() <= r)
+        if (i.size() <= r)
           return 1;
       }
       // backtrack
       if (bt)
         do {
           ok = 1;
           btinfo[bt - 1].btnum--;
           pp = btinfo[bt - 1].btpp;
           wp = btinfo[bt - 1].btwp + (signed short)btinfo[bt - 1].btnum;
         } while ((btinfo[bt - 1].btnum < 0) && --bt);
     } while (bt);
 
-    if (ok && ok2 && (!all || (defcpdtable[i].size() <= pp)))
+    if (ok && ok2 && (!all || (i.size() <= pp)))
       return 1;
 
     // check zero ending
-    while (ok && ok2 && (defcpdtable[i].size() > pp) &&
-           ((pp + 1) < defcpdtable[i].size()) &&
-           ((defcpdtable[i][pp + 1] == '*') ||
-            (defcpdtable[i][pp + 1] == '?')))
+    while (ok && ok2 && (i.size() > pp) &&
+           ((pp + 1) < i.size()) &&
+           ((i[pp + 1] == '*') ||
+            (i[pp + 1] == '?')))
       pp += 2;
-    if (ok && ok2 && (defcpdtable[i].size() <= pp))
+    if (ok && ok2 && (i.size() <= pp))
       return 1;
   }
   (*words)[wnum] = NULL;
   if (w)
     *words = NULL;
   return 0;
 }
@@ -1530,28 +1525,23 @@ inline int AffixMgr::candidate_check(const std::string& word) {
 // calculate number of syllable for compound-checking
 short AffixMgr::get_syllable(const std::string& word) {
   if (cpdmaxsyllable == 0)
     return 0;
 
   short num = 0;
 
   if (!utf8) {
-    for (size_t i = 0; i < word.size(); ++i) {
-      if (std::binary_search(cpdvowels.begin(), cpdvowels.end(),
-                             word[i])) {
-        ++num;
-      }
-    }
+    num = (short)std::count_if(word.begin(), word.end(), 
+          [&](char c) {
+            return std::binary_search(cpdvowels.begin(), cpdvowels.end(), c);
+          });
   } else if (!cpdvowels_utf16.empty()) {
     std::vector<w_char> w;
     u8_u16(w, word);
-    for (size_t i = 0; i < w.size(); ++i) {
-      if (std::binary_search(cpdvowels_utf16.begin(),
-                             cpdvowels_utf16.end(),
-                             w[i])) {
-        ++num;
-      }
-    }
+    num = (short)std::count_if(w.begin(), w.end(),
+          [&](w_char wc) {
+            return std::binary_search(cpdvowels_utf16.begin(), cpdvowels_utf16.end(), wc);
+          });
   }
 
   return num;
 }
@@ -1576,1149 +1566,1129 @@ void AffixMgr::setcminmax(int* cmin, int* cmax, const char* word, int len) {
 // check if compound word is correctly spelled
 // hu_mov_rule = spec. Hungarian rule (XXX)
 struct hentry* AffixMgr::compound_check(const std::string& word,
                                         short wordnum,
                                         short numsyllable,
                                         short maxwordnum,
                                         short wnum,
                                         hentry** words = NULL,
                                         hentry** rwords = NULL,
                                         char hu_mov_rule = 0,
                                         char is_sug = 0,
                                         int* info = NULL) {
   short oldnumsyllable, oldnumsyllable2, oldwordnum, oldwordnum2;
-  struct hentry* rv = NULL;
-  struct hentry* rv_first;
+  hentry *rv = NULL, *rv_first;
   std::string st;
-  char ch = '\0';
-  int cmin;
-  int cmax;
-  int striple = 0;
-  size_t scpd = 0;
-  int soldi = 0;
-  int oldcmin = 0;
-  int oldcmax = 0;
-  int oldlen = 0;
-  int checkedstriple = 0;
-  char affixed = 0;
+  char ch = '\0', affixed;
+  int cmin, cmax, striple = 0, soldi = 0, oldcmin = 0, oldcmax = 0, oldlen = 0, checkedstriple = 0;
   hentry** oldwords = words;
-  size_t len = word.size();
+  size_t scpd, len = word.size();
 
   int checked_prefix;
 
   // add a time limit to handle possible
   // combinatorical explosion of the overlapping words
 
   HUNSPELL_THREAD_LOCAL clock_t timelimit;
 
   if (wordnum == 0) {
       // get the start time, seeing as we're reusing this set to 0
       // to flag timeout, use clock() + 1 to avoid start clock()
       // of 0 as being a timeout
       timelimit = clock() + 1;
   }
   else if (timelimit != 0 && (clock() > timelimit + TIMELIMIT)) {
       timelimit = 0;
   }
 
   setcminmax(&cmin, &cmax, word.c_str(), len);
 
   st.assign(word);
 
   for (int i = cmin; i < cmax; ++i) {
     // go to end of the UTF-8 character
     if (utf8) {
       for (; (st[i] & 0xc0) == 0x80; i++)
         ;
       if (i >= cmax)
         return NULL;
     }
 
     words = oldwords;
     int onlycpdrule = (words) ? 1 : 0;
 
     do {  // onlycpdrule loop
 
       oldnumsyllable = numsyllable;
       oldwordnum = wordnum;
       checked_prefix = 0;
 
       do {  // simplified checkcompoundpattern loop
 
         if (timelimit == 0)
           return 0;
 
         if (scpd > 0) {
           for (; scpd <= checkcpdtable.size() &&
                  (checkcpdtable[scpd - 1].pattern3.empty() ||
                   i > word.size() ||
                   word.compare(i, checkcpdtable[scpd - 1].pattern3.size(), checkcpdtable[scpd - 1].pattern3) != 0);
                scpd++)
             ;
 
           if (scpd > checkcpdtable.size())
             break;  // break simplified checkcompoundpattern loop
           st.replace(i, std::string::npos, checkcpdtable[scpd - 1].pattern);
           soldi = i;
           i += checkcpdtable[scpd - 1].pattern.size();
           st.replace(i, std::string::npos, checkcpdtable[scpd - 1].pattern2);
           st.replace(i + checkcpdtable[scpd - 1].pattern2.size(), std::string::npos,
                  word.substr(soldi + checkcpdtable[scpd - 1].pattern3.size()));
 
           oldlen = len;
           len += checkcpdtable[scpd - 1].pattern.size() +
                  checkcpdtable[scpd - 1].pattern2.size() -
                  checkcpdtable[scpd - 1].pattern3.size();
           oldcmin = cmin;
           oldcmax = cmax;
           setcminmax(&cmin, &cmax, st.c_str(), len);
 
           cmax = len - cpdmin + 1;
         }
 
 	if (i > st.size())
 	    return NULL;
 
         ch = st[i];
         st[i] = '\0';
 
         sfx = NULL;
         pfx = NULL;
 
         // FIRST WORD
 
         affixed = 1;
         rv = lookup(st.c_str(), i);  // perhaps without prefix
 
         // forbid dictionary stems with COMPOUNDFORBIDFLAG in
         // compound words, overriding the effect of COMPOUNDPERMITFLAG
         if ((rv) && compoundforbidflag &&
                 TESTAFF(rv->astr, compoundforbidflag, rv->alen) && !hu_mov_rule)
             continue;
 
         // search homonym with compound flag
         while ((rv) && !hu_mov_rule &&
                ((needaffix && TESTAFF(rv->astr, needaffix, rv->alen)) ||
                 !((compoundflag && !words && !onlycpdrule &&
                    TESTAFF(rv->astr, compoundflag, rv->alen)) ||
                   (compoundbegin && !wordnum && !onlycpdrule &&
                    TESTAFF(rv->astr, compoundbegin, rv->alen)) ||
                   (compoundmiddle && wordnum && !words && !onlycpdrule &&
                    TESTAFF(rv->astr, compoundmiddle, rv->alen)) ||
                   (!defcpdtable.empty() && onlycpdrule &&
                    ((!words && !wordnum &&
                      defcpd_check(&words, wnum, rv, rwords, 0)) ||
                     (words &&
                      defcpd_check(&words, wnum, rv, rwords, 0))))) ||
                 (scpd != 0 && checkcpdtable[scpd - 1].cond != FLAG_NULL &&
                  !TESTAFF(rv->astr, checkcpdtable[scpd - 1].cond, rv->alen)))) {
           rv = rv->next_homonym;
         }
 
         if (rv)
           affixed = 0;
 
         if (!rv) {
           if (onlycpdrule)
             break;
           if (compoundflag &&
               !(rv = prefix_check(st, 0, i,
                                   hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN,
                                   compoundflag))) {
             if (((rv = suffix_check(
                       st, 0, i, 0, NULL, FLAG_NULL, compoundflag,
                       hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN)) ||
                  (compoundmoresuffixes &&
                   (rv = suffix_check_twosfx(st, 0, i, 0, NULL, compoundflag)))) &&
                 !hu_mov_rule && sfx->getCont() &&
                 ((compoundforbidflag &&
                   TESTAFF(sfx->getCont(), compoundforbidflag,
                           sfx->getContLen())) ||
                  (compoundend &&
                   TESTAFF(sfx->getCont(), compoundend, sfx->getContLen())))) {
               rv = NULL;
             }
           }
 
           if (rv ||
               (((wordnum == 0) && compoundbegin &&
                 ((rv = suffix_check(
                       st, 0, i, 0, NULL, FLAG_NULL, compoundbegin,
                       hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN)) ||
                  (compoundmoresuffixes &&
                   (rv = suffix_check_twosfx(
                        st, 0, i, 0, NULL,
                        compoundbegin))) ||  // twofold suffixes + compound
                  (rv = prefix_check(st, 0, i,
                                     hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN,
                                     compoundbegin)))) ||
                ((wordnum > 0) && compoundmiddle &&
                 ((rv = suffix_check(
                       st, 0, i, 0, NULL, FLAG_NULL, compoundmiddle,
                       hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN)) ||
                  (compoundmoresuffixes &&
                   (rv = suffix_check_twosfx(
                        st, 0, i, 0, NULL,
                        compoundmiddle))) ||  // twofold suffixes + compound
                  (rv = prefix_check(st, 0, i,
                                     hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN,
                                     compoundmiddle))))))
             checked_prefix = 1;
           // else check forbiddenwords and needaffix
         } else if (rv->astr && (TESTAFF(rv->astr, forbiddenword, rv->alen) ||
                                 TESTAFF(rv->astr, needaffix, rv->alen) ||
                                 TESTAFF(rv->astr, ONLYUPCASEFLAG, rv->alen) ||
                                 (is_sug && nosuggest &&
                                  TESTAFF(rv->astr, nosuggest, rv->alen)))) {
           st[i] = ch;
           // continue;
           break;
         }
 
         // check non_compound flag in suffix and prefix
         if ((rv) && !hu_mov_rule &&
             ((pfx && pfx->getCont() &&
               TESTAFF(pfx->getCont(), compoundforbidflag, pfx->getContLen())) ||
              (sfx && sfx->getCont() &&
               TESTAFF(sfx->getCont(), compoundforbidflag,
                       sfx->getContLen())))) {
           rv = NULL;
         }
 
         // check compoundend flag in suffix and prefix
         if ((rv) && !checked_prefix && compoundend && !hu_mov_rule &&
             ((pfx && pfx->getCont() &&
               TESTAFF(pfx->getCont(), compoundend, pfx->getContLen())) ||
              (sfx && sfx->getCont() &&
               TESTAFF(sfx->getCont(), compoundend, sfx->getContLen())))) {
           rv = NULL;
         }
 
         // check compoundmiddle flag in suffix and prefix
         if ((rv) && !checked_prefix && (wordnum == 0) && compoundmiddle &&
             !hu_mov_rule &&
             ((pfx && pfx->getCont() &&
               TESTAFF(pfx->getCont(), compoundmiddle, pfx->getContLen())) ||
              (sfx && sfx->getCont() &&
               TESTAFF(sfx->getCont(), compoundmiddle, sfx->getContLen())))) {
           rv = NULL;
         }
 
         // check forbiddenwords
         if ((rv) && (rv->astr) &&
             (TESTAFF(rv->astr, forbiddenword, rv->alen) ||
              TESTAFF(rv->astr, ONLYUPCASEFLAG, rv->alen) ||
              (is_sug && nosuggest && TESTAFF(rv->astr, nosuggest, rv->alen)))) {
           return NULL;
         }
 
         // increment word number, if the second root has a compoundroot flag
         if ((rv) && compoundroot &&
             (TESTAFF(rv->astr, compoundroot, rv->alen))) {
           wordnum++;
         }
 
         // first word is acceptable in compound words?
         if (((rv) &&
              (checked_prefix || (words && words[wnum]) ||
               (compoundflag && TESTAFF(rv->astr, compoundflag, rv->alen)) ||
               ((oldwordnum == 0) && compoundbegin &&
                TESTAFF(rv->astr, compoundbegin, rv->alen)) ||
               ((oldwordnum > 0) && compoundmiddle &&
                TESTAFF(rv->astr, compoundmiddle, rv->alen))
 
               // LANG_hu section: spec. Hungarian rule
               || ((langnum == LANG_hu) && hu_mov_rule &&
                   (TESTAFF(
                        rv->astr, 'F',
                        rv->alen) ||  // XXX hardwired Hungarian dictionary codes
                    TESTAFF(rv->astr, 'G', rv->alen) ||
                    TESTAFF(rv->astr, 'H', rv->alen)))
               // END of LANG_hu section
               ) &&
              (
                  // test CHECKCOMPOUNDPATTERN conditions
                  scpd == 0 || checkcpdtable[scpd - 1].cond == FLAG_NULL ||
                  TESTAFF(rv->astr, checkcpdtable[scpd - 1].cond, rv->alen)) &&
              !((checkcompoundtriple && scpd == 0 &&
                 !words &&  // test triple letters
                 (word[i - 1] == word[i]) &&
                 (((i > 1) && (word[i - 1] == word[i - 2])) ||
                  ((word[i - 1] == word[i + 1]))  // may be word[i+1] == '\0'
                  )) ||
                (checkcompoundcase && scpd == 0 && !words &&
                 cpdcase_check(word.c_str(), i))))
             // LANG_hu section: spec. Hungarian rule
             || ((!rv) && (langnum == LANG_hu) && hu_mov_rule &&
                 (rv = affix_check(st, 0, i)) &&
                 (sfx && sfx->getCont() &&
                  (  // XXX hardwired Hungarian dic. codes
                      TESTAFF(sfx->getCont(), (unsigned short)'x',
                              sfx->getContLen()) ||
                      TESTAFF(
                          sfx->getCont(), (unsigned short)'%',
                          sfx->getContLen()))))) {  // first word is ok condition
 
           // LANG_hu section: spec. Hungarian rule
           if (langnum == LANG_hu) {
             // calculate syllable number of the word
             numsyllable += get_syllable(st.substr(0, i));
             // + 1 word, if syllable number of the prefix > 1 (hungarian
             // convention)
             if (pfx && (get_syllable(pfx->getKey()) > 1))
               wordnum++;
           }
           // END of LANG_hu section
 
           // NEXT WORD(S)
           rv_first = rv;
           st[i] = ch;
 
           do {  // striple loop
 
             // check simplifiedtriple
             if (simplifiedtriple) {
               if (striple) {
                 checkedstriple = 1;
                 i--;  // check "fahrt" instead of "ahrt" in "Schiffahrt"
               } else if (i > 2 && i <= word.size() && word[i - 1] == word[i - 2])
                 striple = 1;
             }
 
             rv = lookup(st.c_str() + i, st.size() - i);  // perhaps without prefix
 
             // search homonym with compound flag
             while ((rv) &&
                    ((needaffix && TESTAFF(rv->astr, needaffix, rv->alen)) ||
                     !((compoundflag && !words &&
                        TESTAFF(rv->astr, compoundflag, rv->alen)) ||
                       (compoundend && !words &&
                        TESTAFF(rv->astr, compoundend, rv->alen)) ||
                       (!defcpdtable.empty() && words &&
                        defcpd_check(&words, wnum + 1, rv, NULL, 1))) ||
                     (scpd != 0 && checkcpdtable[scpd - 1].cond2 != FLAG_NULL &&
                      !TESTAFF(rv->astr, checkcpdtable[scpd - 1].cond2,
                               rv->alen)))) {
               rv = rv->next_homonym;
             }
 
             // check FORCEUCASE
             if (rv && forceucase &&
                 (TESTAFF(rv->astr, forceucase, rv->alen)) &&
                 !(info && *info & SPELL_ORIGCAP))
               rv = NULL;
 
             if (rv && words && words[wnum + 1])
               return rv_first;
 
             oldnumsyllable2 = numsyllable;
             oldwordnum2 = wordnum;
 
             // LANG_hu section: spec. Hungarian rule, XXX hardwired dictionary
             // code
             if ((rv) && (langnum == LANG_hu) &&
                 (TESTAFF(rv->astr, 'I', rv->alen)) &&
                 !(TESTAFF(rv->astr, 'J', rv->alen))) {
               numsyllable--;
             }
             // END of LANG_hu section
 
             // increment word number, if the second root has a compoundroot flag
             if ((rv) && (compoundroot) &&
                 (TESTAFF(rv->astr, compoundroot, rv->alen))) {
               wordnum++;
             }
 
             // check forbiddenwords
             if ((rv) && (rv->astr) &&
                 (TESTAFF(rv->astr, forbiddenword, rv->alen) ||
                  TESTAFF(rv->astr, ONLYUPCASEFLAG, rv->alen) ||
                  (is_sug && nosuggest &&
                   TESTAFF(rv->astr, nosuggest, rv->alen))))
               return NULL;
 
             // second word is acceptable, as a root?
             // hungarian conventions: compounding is acceptable,
             // when compound forms consist of 2 words, or if more,
             // then the syllable number of root words must be 6, or lesser.
 
             if ((rv) &&
                 ((compoundflag && TESTAFF(rv->astr, compoundflag, rv->alen)) ||
                  (compoundend && TESTAFF(rv->astr, compoundend, rv->alen))) &&
                 (((cpdwordmax == -1) || (wordnum + 1 < cpdwordmax)) ||
                  ((cpdmaxsyllable != 0) &&
                   (numsyllable + get_syllable(std::string(HENTRY_WORD(rv), rv->blen)) <=
                    cpdmaxsyllable))) &&
                 (
                     // test CHECKCOMPOUNDPATTERN
                     checkcpdtable.empty() || scpd != 0 ||
                     !cpdpat_check(word.c_str(), i, rv_first, rv, 0)) &&
                 ((!checkcompounddup || (rv != rv_first)))
                 // test CHECKCOMPOUNDPATTERN conditions
                 &&
                 (scpd == 0 || checkcpdtable[scpd - 1].cond2 == FLAG_NULL ||
                  TESTAFF(rv->astr, checkcpdtable[scpd - 1].cond2, rv->alen))) {
               // forbid compound word, if it is a non-compound word with typical
               // fault
               if ((checkcompoundrep && cpdrep_check(word, len)) ||
                       cpdwordpair_check(word, len))
                 return NULL;
               return rv_first;
             }
 
             numsyllable = oldnumsyllable2;
             wordnum = oldwordnum2;
 
             // perhaps second word has prefix or/and suffix
             sfx = NULL;
             sfxflag = FLAG_NULL;
             rv = (compoundflag && !onlycpdrule && i < word.size())
                      ? affix_check(word, i, word.size() - i, compoundflag,
                                    IN_CPD_END)
                      : NULL;
             if (!rv && compoundend && !onlycpdrule) {
               sfx = NULL;
               pfx = NULL;
               if (i < word.size())
                 rv = affix_check(word, i, word.size() - i, compoundend, IN_CPD_END);
             }
 
             if (!rv && !defcpdtable.empty() && words) {
               if (i < word.size())
                 rv = affix_check(word, i, word.size() - i, 0, IN_CPD_END);
               if (rv && defcpd_check(&words, wnum + 1, rv, NULL, 1))
                 return rv_first;
               rv = NULL;
             }
 
             // test CHECKCOMPOUNDPATTERN conditions (allowed forms)
             if (rv &&
                 !(scpd == 0 || checkcpdtable[scpd - 1].cond2 == FLAG_NULL ||
                   TESTAFF(rv->astr, checkcpdtable[scpd - 1].cond2, rv->alen)))
               rv = NULL;
 
             // test CHECKCOMPOUNDPATTERN conditions (forbidden compounds)
             if (rv && !checkcpdtable.empty() && scpd == 0 &&
                 cpdpat_check(word.c_str(), i, rv_first, rv, affixed))
               rv = NULL;
 
             // check non_compound flag in suffix and prefix
             if ((rv) && ((pfx && pfx->getCont() &&
                           TESTAFF(pfx->getCont(), compoundforbidflag,
                                   pfx->getContLen())) ||
                          (sfx && sfx->getCont() &&
                           TESTAFF(sfx->getCont(), compoundforbidflag,
                                   sfx->getContLen())))) {
               rv = NULL;
             }
 
             // check FORCEUCASE
             if (rv && forceucase &&
                 (TESTAFF(rv->astr, forceucase, rv->alen)) &&
                 !(info && *info & SPELL_ORIGCAP))
               rv = NULL;
 
             // check forbiddenwords
             if ((rv) && (rv->astr) &&
                 (TESTAFF(rv->astr, forbiddenword, rv->alen) ||
                  TESTAFF(rv->astr, ONLYUPCASEFLAG, rv->alen) ||
                  (is_sug && nosuggest &&
                   TESTAFF(rv->astr, nosuggest, rv->alen))))
               return NULL;
 
             // pfxappnd = prefix of word+i, or NULL
             // calculate syllable number of prefix.
             // hungarian convention: when syllable number of prefix is more,
             // than 1, the prefix+word counts as two words.
 
             if (langnum == LANG_hu) {
               if (i < word.size()) {
                 // calculate syllable number of the word
                 numsyllable += get_syllable(word.substr(i));
               }
 
               // - affix syllable num.
               // XXX only second suffix (inflections, not derivations)
               if (sfxappnd) {
                 std::string tmp(sfxappnd);
                 reverseword(tmp);
                 numsyllable -= short(get_syllable(tmp) + sfxextra);
               } else {
                 numsyllable -= short(sfxextra);
               }
 
               // + 1 word, if syllable number of the prefix > 1 (hungarian
               // convention)
               if (pfx && (get_syllable(pfx->getKey()) > 1))
                 wordnum++;
 
               // increment syllable num, if last word has a SYLLABLENUM flag
               // and the suffix is beginning `s'
 
               if (!cpdsyllablenum.empty()) {
                 switch (sfxflag) {
                   case 'c': {
                     numsyllable += 2;
                     break;
                   }
                   case 'J': {
                     numsyllable += 1;
                     break;
                   }
                   case 'I': {
                     if (rv && TESTAFF(rv->astr, 'J', rv->alen))
                       numsyllable += 1;
                     break;
                   }
                 }
               }
             }
 
             // increment word number, if the second word has a compoundroot flag
             if ((rv) && (compoundroot) &&
                 (TESTAFF(rv->astr, compoundroot, rv->alen))) {
               wordnum++;
             }
             // second word is acceptable, as a word with prefix or/and suffix?
             // hungarian conventions: compounding is acceptable,
             // when compound forms consist 2 word, otherwise
             // the syllable number of root words is 6, or lesser.
             if ((rv) &&
                 (((cpdwordmax == -1) || (wordnum + 1 < cpdwordmax)) ||
                  ((cpdmaxsyllable != 0) && (numsyllable <= cpdmaxsyllable))) &&
                 ((!checkcompounddup || (rv != rv_first)))) {
               // forbid compound word, if it is a non-compound word with typical
               // fault
               if ((checkcompoundrep && cpdrep_check(word, len)) ||
                       cpdwordpair_check(word, len))
                 return NULL;
               return rv_first;
             }
 
             numsyllable = oldnumsyllable2;
             wordnum = oldwordnum2;
 
             // perhaps second word is a compound word (recursive call)
             if (wordnum + 2 < maxwordnum) {
               rv = compound_check(st.substr(i), wordnum + 1,
                                   numsyllable, maxwordnum, wnum + 1, words, rwords, 0,
                                   is_sug, info);
 
               if (rv && !checkcpdtable.empty() &&
                   ((scpd == 0 &&
                     cpdpat_check(word.c_str(), i, rv_first, rv, affixed)) ||
                    (scpd != 0 &&
                     !cpdpat_check(word.c_str(), i, rv_first, rv, affixed))))
                 rv = NULL;
             } else {
               rv = NULL;
             }
             if (rv) {
               // forbid compound word, if it is a non-compound word with typical
               // fault, or a dictionary word pair
 
               if (cpdwordpair_check(word, len))
                   return NULL;
 
               if (checkcompoundrep || forbiddenword) {
 
                 if (checkcompoundrep && cpdrep_check(word, len))
                   return NULL;
 
                 // check first part
                 if (word.compare(i, rv->blen, rv->word, rv->blen) == 0) {
                   char r = st[i + rv->blen];
                   st[i + rv->blen] = '\0';
 
                   if ((checkcompoundrep && cpdrep_check(st, i + rv->blen)) ||
                       cpdwordpair_check(st, i + rv->blen)) {
                     st[ + i + rv->blen] = r;
                     continue;
                   }
 
                   if (forbiddenword) {
                     struct hentry* rv2 = lookup(word.c_str(), word.size());
                     if (!rv2)
                       rv2 = affix_check(word, 0, len);
                     if (rv2 && rv2->astr &&
                         TESTAFF(rv2->astr, forbiddenword, rv2->alen) &&
                         (strncmp(rv2->word, st.c_str(), i + rv->blen) == 0)) {
                       return NULL;
                     }
                   }
                   st[i + rv->blen] = r;
                 }
               }
               return rv_first;
             }
           } while (striple && !checkedstriple);  // end of striple loop
 
           if (checkedstriple) {
             i++;
             checkedstriple = 0;
             striple = 0;
           }
 
         }  // first word is ok condition
 
         if (soldi != 0) {
           i = soldi;
           soldi = 0;
           len = oldlen;
           cmin = oldcmin;
           cmax = oldcmax;
         }
         scpd++;
 
       } while (!onlycpdrule && simplifiedcpd &&
                scpd <= checkcpdtable.size());  // end of simplifiedcpd loop
 
       scpd = 0;
       wordnum = oldwordnum;
       numsyllable = oldnumsyllable;
 
       if (soldi != 0) {
         i = soldi;
         st.assign(word);  // XXX add more optim.
         soldi = 0;
       } else
         st[i] = ch;
 
     } while (!defcpdtable.empty() && oldwordnum == 0 &&
              onlycpdrule++ < 1);  // end of onlycpd loop
   }
 
   return NULL;
 }
 
 // check if compound word is correctly spelled
 // hu_mov_rule = spec. Hungarian rule (XXX)
 int AffixMgr::compound_check_morph(const std::string& word,
                                    short wordnum,
                                    short numsyllable,
                                    short maxwordnum,
                                    short wnum,
                                    hentry** words,
                                    hentry** rwords,
                                    char hu_mov_rule,
                                    std::string& result,
                                    const std::string* partresult) {
   short oldnumsyllable, oldnumsyllable2, oldwordnum, oldwordnum2;
-  int ok = 0;
-
-  struct hentry* rv = NULL;
-  struct hentry* rv_first;
-  std::string st;
-  char ch;
-
-  int checked_prefix;
-  std::string presult;
-
-  int cmin;
-  int cmax;
-
-  char affixed = 0;
+  hentry* rv = NULL, *rv_first;
+  std::string st, presult;
+  char ch, affixed = 0;
+  int checked_prefix, cmin, cmax, ok = 0;
   hentry** oldwords = words;
   size_t len = word.size();
 
   // add a time limit to handle possible
   // combinatorical explosion of the overlapping words
 
   HUNSPELL_THREAD_LOCAL clock_t timelimit;
 
   if (wordnum == 0) {
       // get the start time, seeing as we're reusing this set to 0
       // to flag timeout, use clock() + 1 to avoid start clock()
       // of 0 as being a timeout
       timelimit = clock() + 1;
   }
   else if (timelimit != 0 && (clock() > timelimit + TIMELIMIT)) {
       timelimit = 0;
   }
 
   setcminmax(&cmin, &cmax, word.c_str(), len);
 
   st.assign(word);
 
   for (int i = cmin; i < cmax; ++i) {
     // go to end of the UTF-8 character
     if (utf8) {
       for (; (st[i] & 0xc0) == 0x80; i++)
         ;
       if (i >= cmax)
         return 0;
     }
 
     words = oldwords;
     int onlycpdrule = (words) ? 1 : 0;
 
     do {  // onlycpdrule loop
 
       if (timelimit == 0)
         return 0;
 
       oldnumsyllable = numsyllable;
       oldwordnum = wordnum;
       checked_prefix = 0;
 
       ch = st[i];
       st[i] = '\0';
       sfx = NULL;
 
       // FIRST WORD
 
       affixed = 1;
 
       presult.clear();
       if (partresult)
         presult.append(*partresult);
 
       rv = lookup(st.c_str(), i);  // perhaps without prefix
 
       // forbid dictionary stems with COMPOUNDFORBIDFLAG in
       // compound words, overriding the effect of COMPOUNDPERMITFLAG
       if ((rv) && compoundforbidflag &&
               TESTAFF(rv->astr, compoundforbidflag, rv->alen) && !hu_mov_rule)
           continue;
 
       // search homonym with compound flag
       while ((rv) && !hu_mov_rule &&
              ((needaffix && TESTAFF(rv->astr, needaffix, rv->alen)) ||
               !((compoundflag && !words && !onlycpdrule &&
                  TESTAFF(rv->astr, compoundflag, rv->alen)) ||
                 (compoundbegin && !wordnum && !onlycpdrule &&
                  TESTAFF(rv->astr, compoundbegin, rv->alen)) ||
                 (compoundmiddle && wordnum && !words && !onlycpdrule &&
                  TESTAFF(rv->astr, compoundmiddle, rv->alen)) ||
                 (!defcpdtable.empty() && onlycpdrule &&
                  ((!words && !wordnum &&
                    defcpd_check(&words, wnum, rv, rwords, 0)) ||
                   (words &&
                    defcpd_check(&words, wnum, rv, rwords, 0))))))) {
         rv = rv->next_homonym;
       }
 
       if (timelimit == 0)
         return 0;
 
       if (rv)
         affixed = 0;
 
       if (rv) {
         presult.push_back(MSEP_FLD);
         presult.append(MORPH_PART);
         presult.append(st, 0, i);
         if (!HENTRY_FIND(rv, MORPH_STEM)) {
           presult.push_back(MSEP_FLD);
           presult.append(MORPH_STEM);
           presult.append(st, 0, i);
         }
         if (HENTRY_DATA(rv)) {
           presult.push_back(MSEP_FLD);
           presult.append(HENTRY_DATA2(rv));
         }
       }
 
       if (!rv) {
         if (compoundflag &&
             !(rv =
                   prefix_check(st, 0, i, hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN,
                                compoundflag))) {
           if (((rv = suffix_check(st, 0, i, 0, NULL, FLAG_NULL,
                                   compoundflag,
                                   hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN)) ||
                (compoundmoresuffixes &&
                 (rv = suffix_check_twosfx(st, 0, i, 0, NULL, compoundflag)))) &&
               !hu_mov_rule && sfx->getCont() &&
               ((compoundforbidflag &&
                 TESTAFF(sfx->getCont(), compoundforbidflag,
                         sfx->getContLen())) ||
                (compoundend &&
                 TESTAFF(sfx->getCont(), compoundend, sfx->getContLen())))) {
             rv = NULL;
           }
         }
 
         if (rv ||
             (((wordnum == 0) && compoundbegin &&
               ((rv = suffix_check(st, 0, i, 0, NULL, FLAG_NULL,
                                   compoundbegin,
                                   hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN)) ||
                (compoundmoresuffixes &&
                 (rv = suffix_check_twosfx(
                      st, 0, i, 0, NULL,
                      compoundbegin))) ||  // twofold suffix+compound
                (rv = prefix_check(st, 0, i,
                                   hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN,
                                   compoundbegin)))) ||
              ((wordnum > 0) && compoundmiddle &&
               ((rv = suffix_check(st, 0, i, 0, NULL, FLAG_NULL,
                                   compoundmiddle,
                                   hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN)) ||
                (compoundmoresuffixes &&
                 (rv = suffix_check_twosfx(
                      st, 0, i, 0, NULL,
                      compoundmiddle))) ||  // twofold suffix+compound
                (rv = prefix_check(st, 0, i,
                                   hu_mov_rule ? IN_CPD_OTHER : IN_CPD_BEGIN,
                                   compoundmiddle)))))) {
           std::string p;
           if (compoundflag)
             p = affix_check_morph(st, 0, i, compoundflag);
           if (p.empty()) {
             if ((wordnum == 0) && compoundbegin) {
               p = affix_check_morph(st, 0, i, compoundbegin);
             } else if ((wordnum > 0) && compoundmiddle) {
               p = affix_check_morph(st, 0, i, compoundmiddle);
             }
           }
           if (!p.empty()) {
             presult.push_back(MSEP_FLD);
             presult.append(MORPH_PART);
             presult.append(st, 0, i);
             line_uniq_app(p, MSEP_REC);
             presult.append(p);
           }
           checked_prefix = 1;
         }
         // else check forbiddenwords
       } else if (rv->astr && (TESTAFF(rv->astr, forbiddenword, rv->alen) ||
                               TESTAFF(rv->astr, ONLYUPCASEFLAG, rv->alen) ||
                               TESTAFF(rv->astr, needaffix, rv->alen))) {
         st[i] = ch;
         continue;
       }
 
       // check non_compound flag in suffix and prefix
       if ((rv) && !hu_mov_rule &&
           ((pfx && pfx->getCont() &&
             TESTAFF(pfx->getCont(), compoundforbidflag, pfx->getContLen())) ||
            (sfx && sfx->getCont() &&
             TESTAFF(sfx->getCont(), compoundforbidflag, sfx->getContLen())))) {
         continue;
       }
 
       // check compoundend flag in suffix and prefix
       if ((rv) && !checked_prefix && compoundend && !hu_mov_rule &&
           ((pfx && pfx->getCont() &&
             TESTAFF(pfx->getCont(), compoundend, pfx->getContLen())) ||
            (sfx && sfx->getCont() &&
             TESTAFF(sfx->getCont(), compoundend, sfx->getContLen())))) {
         continue;
       }
 
       // check compoundmiddle flag in suffix and prefix
       if ((rv) && !checked_prefix && (wordnum == 0) && compoundmiddle &&
           !hu_mov_rule &&
           ((pfx && pfx->getCont() &&
             TESTAFF(pfx->getCont(), compoundmiddle, pfx->getContLen())) ||
            (sfx && sfx->getCont() &&
             TESTAFF(sfx->getCont(), compoundmiddle, sfx->getContLen())))) {
         rv = NULL;
       }
 
       // check forbiddenwords
       if ((rv) && (rv->astr) && (TESTAFF(rv->astr, forbiddenword, rv->alen) ||
                                  TESTAFF(rv->astr, ONLYUPCASEFLAG, rv->alen)))
         continue;
 
       // increment word number, if the second root has a compoundroot flag
       if ((rv) && (compoundroot) &&
           (TESTAFF(rv->astr, compoundroot, rv->alen))) {
         wordnum++;
       }
 
       // first word is acceptable in compound words?
       if (((rv) &&
            (checked_prefix || (words && words[wnum]) ||
             (compoundflag && TESTAFF(rv->astr, compoundflag, rv->alen)) ||
             ((oldwordnum == 0) && compoundbegin &&
              TESTAFF(rv->astr, compoundbegin, rv->alen)) ||
             ((oldwordnum > 0) && compoundmiddle &&
              TESTAFF(rv->astr, compoundmiddle, rv->alen))
             // LANG_hu section: spec. Hungarian rule
             || ((langnum == LANG_hu) &&  // hu_mov_rule
                 hu_mov_rule && (TESTAFF(rv->astr, 'F', rv->alen) ||
                                 TESTAFF(rv->astr, 'G', rv->alen) ||
                                 TESTAFF(rv->astr, 'H', rv->alen)))
             // END of LANG_hu section
             ) &&
            !((checkcompoundtriple && !words &&  // test triple letters
               (word[i - 1] == word[i]) &&
               (((i > 1) && (word[i - 1] == word[i - 2])) ||
                ((word[i - 1] == word[i + 1]))  // may be word[i+1] == '\0'
                )) ||
              (
                  // test CHECKCOMPOUNDPATTERN
                  !checkcpdtable.empty() && !words &&
                  cpdpat_check(word.c_str(), i, rv, NULL, affixed)) ||
              (checkcompoundcase && !words && cpdcase_check(word.c_str(), i))))
           // LANG_hu section: spec. Hungarian rule
           ||
           ((!rv) && (langnum == LANG_hu) && hu_mov_rule &&
            (rv = affix_check(st, 0, i)) &&
            (sfx && sfx->getCont() &&
             (TESTAFF(sfx->getCont(), (unsigned short)'x', sfx->getContLen()) ||
              TESTAFF(sfx->getCont(), (unsigned short)'%', sfx->getContLen()))))
           // END of LANG_hu section
           ) {
         // LANG_hu section: spec. Hungarian rule
         if (langnum == LANG_hu) {
           // calculate syllable number of the word
           numsyllable += get_syllable(st.substr(0, i));
 
           // + 1 word, if syllable number of the prefix > 1 (hungarian
           // convention)
           if (pfx && (get_syllable(pfx->getKey()) > 1))
             wordnum++;
         }
         // END of LANG_hu section
 
         // NEXT WORD(S)
         rv_first = rv;
         rv = lookup(word.c_str() + i, word.size() - i);  // perhaps without prefix
 
         // search homonym with compound flag
         while ((rv) && ((needaffix && TESTAFF(rv->astr, needaffix, rv->alen)) ||
                         !((compoundflag && !words &&
                            TESTAFF(rv->astr, compoundflag, rv->alen)) ||
                           (compoundend && !words &&
                            TESTAFF(rv->astr, compoundend, rv->alen)) ||
                           (!defcpdtable.empty() && words &&
                            defcpd_check(&words, wnum + 1, rv, NULL, 1))))) {
           rv = rv->next_homonym;
         }
 
         if (rv && words && words[wnum + 1]) {
           result.append(presult);
           result.push_back(MSEP_FLD);
           result.append(MORPH_PART);
           result.append(word, i);
           if (complexprefixes && HENTRY_DATA(rv))
             result.append(HENTRY_DATA2(rv));
           if (!HENTRY_FIND(rv, MORPH_STEM)) {
             result.push_back(MSEP_FLD);
             result.append(MORPH_STEM);
             result.append(HENTRY_WORD(rv));
           }
           // store the pointer of the hash entry
           if (!complexprefixes && HENTRY_DATA(rv)) {
             result.push_back(MSEP_FLD);
             result.append(HENTRY_DATA2(rv));
           }
           result.push_back(MSEP_REC);
           return 0;
         }
 
         oldnumsyllable2 = numsyllable;
         oldwordnum2 = wordnum;
 
         // LANG_hu section: spec. Hungarian rule
         if ((rv) && (langnum == LANG_hu) &&
             (TESTAFF(rv->astr, 'I', rv->alen)) &&
             !(TESTAFF(rv->astr, 'J', rv->alen))) {
           numsyllable--;
         }
         // END of LANG_hu section
         // increment word number, if the second root has a compoundroot flag
         if ((rv) && (compoundroot) &&
             (TESTAFF(rv->astr, compoundroot, rv->alen))) {
           wordnum++;
         }
 
         // check forbiddenwords
         if ((rv) && (rv->astr) &&
             (TESTAFF(rv->astr, forbiddenword, rv->alen) ||
              TESTAFF(rv->astr, ONLYUPCASEFLAG, rv->alen))) {
           st[i] = ch;
           continue;
         }
 
         // second word is acceptable, as a root?
         // hungarian conventions: compounding is acceptable,
         // when compound forms consist of 2 words, or if more,
         // then the syllable number of root words must be 6, or lesser.
         if ((rv) &&
             ((compoundflag && TESTAFF(rv->astr, compoundflag, rv->alen)) ||
              (compoundend && TESTAFF(rv->astr, compoundend, rv->alen))) &&
             (((cpdwordmax == -1) || (wordnum + 1 < cpdwordmax)) ||
              ((cpdmaxsyllable != 0) &&
               (numsyllable + get_syllable(std::string(HENTRY_WORD(rv), rv->blen)) <=
                cpdmaxsyllable))) &&
             ((!checkcompounddup || (rv != rv_first)))) {
           // bad compound word
           result.append(presult);
           result.push_back(MSEP_FLD);
           result.append(MORPH_PART);
           result.append(word, i);
 
           if (HENTRY_DATA(rv)) {
             if (complexprefixes)
               result.append(HENTRY_DATA2(rv));
             if (!HENTRY_FIND(rv, MORPH_STEM)) {
               result.push_back(MSEP_FLD);
               result.append(MORPH_STEM);
               result.append(HENTRY_WORD(rv));
             }
             // store the pointer of the hash entry
             if (!complexprefixes) {
               result.push_back(MSEP_FLD);
               result.append(HENTRY_DATA2(rv));
             }
           }
           result.push_back(MSEP_REC);
           ok = 1;
         }
 
         numsyllable = oldnumsyllable2;
         wordnum = oldwordnum2;
 
         // perhaps second word has prefix or/and suffix
         sfx = NULL;
         sfxflag = FLAG_NULL;
 
         if (compoundflag && !onlycpdrule)
           rv = affix_check(word, i, word.size() - i, compoundflag);
         else
           rv = NULL;
 
         if (!rv && compoundend && !onlycpdrule) {
           sfx = NULL;
           pfx = NULL;
           rv = affix_check(word, i, word.size() - i, compoundend);
         }
 
         if (!rv && !defcpdtable.empty() && words) {
           rv = affix_check(word, i, word.size() - i, 0, IN_CPD_END);
           if (rv && words && defcpd_check(&words, wnum + 1, rv, NULL, 1)) {
             std::string m;
             if (compoundflag)
               m = affix_check_morph(word, i, word.size() - i, compoundflag);
             if (m.empty() && compoundend) {
               m = affix_check_morph(word, i, word.size() - i, compoundend);
             }
             result.append(presult);
             if (!m.empty()) {
               result.push_back(MSEP_FLD);
               result.append(MORPH_PART);
               result.append(word, i);
               line_uniq_app(m, MSEP_REC);
               result.append(m);
             }
             result.push_back(MSEP_REC);
             ok = 1;
           }
         }
 
         // check non_compound flag in suffix and prefix
         if ((rv) &&
             ((pfx && pfx->getCont() &&
               TESTAFF(pfx->getCont(), compoundforbidflag, pfx->getContLen())) ||
              (sfx && sfx->getCont() &&
               TESTAFF(sfx->getCont(), compoundforbidflag,
                       sfx->getContLen())))) {
           rv = NULL;
         }
 
         // check forbiddenwords
         if ((rv) && (rv->astr) &&
             (TESTAFF(rv->astr, forbiddenword, rv->alen) ||
              TESTAFF(rv->astr, ONLYUPCASEFLAG, rv->alen)) &&
             (!TESTAFF(rv->astr, needaffix, rv->alen))) {
           st[i] = ch;
           continue;
         }
 
         if (langnum == LANG_hu) {
           // calculate syllable number of the word
           numsyllable += get_syllable(word.c_str() + i);
 
           // - affix syllable num.
           // XXX only second suffix (inflections, not derivations)
           if (sfxappnd) {
             std::string tmp(sfxappnd);
             reverseword(tmp);
             numsyllable -= short(get_syllable(tmp) + sfxextra);
           } else {
             numsyllable -= short(sfxextra);
           }
 
           // + 1 word, if syllable number of the prefix > 1 (hungarian
           // convention)
           if (pfx && (get_syllable(pfx->getKey()) > 1))
             wordnum++;
 
           // increment syllable num, if last word has a SYLLABLENUM flag
           // and the suffix is beginning `s'
 
           if (!cpdsyllablenum.empty()) {
             switch (sfxflag) {
               case 'c': {
                 numsyllable += 2;
                 break;
               }
               case 'J': {
                 numsyllable += 1;
                 break;
               }
               case 'I': {
                 if (rv && TESTAFF(rv->astr, 'J', rv->alen))
                   numsyllable += 1;
                 break;
               }
             }
           }
         }
 
         // increment word number, if the second word has a compoundroot flag
         if ((rv) && (compoundroot) &&
             (TESTAFF(rv->astr, compoundroot, rv->alen))) {
           wordnum++;
         }
         // second word is acceptable, as a word with prefix or/and suffix?
         // hungarian conventions: compounding is acceptable,
         // when compound forms consist 2 word, otherwise
         // the syllable number of root words is 6, or lesser.
         if ((rv) &&
             (((cpdwordmax == -1) || (wordnum + 1 < cpdwordmax)) ||
              ((cpdmaxsyllable != 0) && (numsyllable <= cpdmaxsyllable))) &&
             ((!checkcompounddup || (rv != rv_first)))) {
           std::string m;
           if (compoundflag)
             m = affix_check_morph(word, i, word.size() - i, compoundflag);
           if (m.empty() && compoundend) {
             m = affix_check_morph(word, i, word.size() - i, compoundend);
           }
           result.append(presult);
           if (!m.empty()) {
             result.push_back(MSEP_FLD);
             result.append(MORPH_PART);
             result.append(word, i);
             line_uniq_app(m, MSEP_REC);
             result.push_back(MSEP_FLD);
             result.append(m);
           }
           result.push_back(MSEP_REC);
           ok = 1;
         }
 
         numsyllable = oldnumsyllable2;
         wordnum = oldwordnum2;
 
         // perhaps second word is a compound word (recursive call)
         if ((wordnum + 2 < maxwordnum) && (ok == 0)) {
           compound_check_morph(word.substr(i), wordnum + 1,
                                numsyllable, maxwordnum, wnum + 1, words, rwords, 0,
                                result, &presult);
         } else {
           rv = NULL;
         }
       }
       st[i] = ch;
       wordnum = oldwordnum;
       numsyllable = oldnumsyllable;
 
     } while (!defcpdtable.empty() && oldwordnum == 0 &&
              onlycpdrule++ < 1);  // end of onlycpd loop
   }
   return 0;
 }
@@ -2906,72 +2876,72 @@ struct hentry* AffixMgr::suffix_check_twosfx(const std::string& word,
 // check word for two-level suffixes and morph
 std::string AffixMgr::suffix_check_twosfx_morph(const std::string& word,
                                                 int start,
                                                 int len,
                                                 int sfxopts,
                                                 PfxEntry* ppfx,
                                                 const FLAG needflag) {
   std::string result;
   std::string result2;
   std::string result3;
 
   // first handle the special case of 0 length suffixes
   SfxEntry* se = sStart[0];
   while (se) {
     if (contclasses[se->getFlag()]) {
       std::string st = se->check_twosfx_morph(word, start, len, sfxopts, ppfx, needflag);
       if (!st.empty()) {
         if (ppfx) {
           if (ppfx->getMorph()) {
             result.append(ppfx->getMorph());
             result.push_back(MSEP_FLD);
           } else
             debugflag(result, ppfx->getFlag());
         }
         result.append(st);
         if (se->getMorph()) {
           result.push_back(MSEP_FLD);
           result.append(se->getMorph());
         } else
           debugflag(result, se->getFlag());
         result.push_back(MSEP_REC);
       }
     }
     se = se->getNext();
   }
 
   // now handle the general case
   if (len == 0)
-    return std::string();  // FULLSTRIP
+    return { };  // FULLSTRIP
   unsigned char sp = word[start + len - 1];
   SfxEntry* sptr = sStart[sp];
 
   while (sptr) {
     if (isRevSubset(sptr->getKey(), word.c_str() + start + len - 1, len)) {
       if (contclasses[sptr->getFlag()]) {
         std::string st = sptr->check_twosfx_morph(word, start, len, sfxopts, ppfx, needflag);
         if (!st.empty()) {
           sfxflag = sptr->getFlag();  // BUG: sfxflag not stateless
           if (!sptr->getCont())
             sfxappnd = sptr->getKey();  // BUG: sfxappnd not stateless
           result2.assign(st);
 
           result3.clear();
 
           if (sptr->getMorph()) {
             result3.push_back(MSEP_FLD);
             result3.append(sptr->getMorph());
           } else
             debugflag(result3, sptr->getFlag());
           strlinecat(result2, result3);
           result2.push_back(MSEP_REC);
           result.append(result2);
         }
       }
       sptr = sptr->getNextEQ();
     } else {
       sptr = sptr->getNextNE();
     }
   }
 
   return result;
 }
@@ -2979,153 +2949,153 @@ std::string AffixMgr::suffix_check_twosfx_morph(const std::string& word,
 std::string AffixMgr::suffix_check_morph(const std::string& word,
                                          int start,
                                          int len,
                                          int sfxopts,
                                          PfxEntry* ppfx,
                                          const FLAG cclass,
                                          const FLAG needflag,
                                          char in_compound) {
   std::string result;
 
   struct hentry* rv = NULL;
 
   PfxEntry* ep = ppfx;
 
   // first handle the special case of 0 length suffixes
   SfxEntry* se = sStart[0];
   while (se) {
     if (!cclass || se->getCont()) {
       // suffixes are not allowed in beginning of compounds
       if (((((in_compound != IN_CPD_BEGIN)) ||  // && !cclass
             // except when signed with compoundpermitflag flag
             (se->getCont() && compoundpermitflag &&
              TESTAFF(se->getCont(), compoundpermitflag, se->getContLen()))) &&
            (!circumfix ||
             // no circumfix flag in prefix and suffix
             ((!ppfx || !(ep->getCont()) ||
               !TESTAFF(ep->getCont(), circumfix, ep->getContLen())) &&
              (!se->getCont() ||
               !(TESTAFF(se->getCont(), circumfix, se->getContLen())))) ||
             // circumfix flag in prefix AND suffix
             ((ppfx && (ep->getCont()) &&
               TESTAFF(ep->getCont(), circumfix, ep->getContLen())) &&
              (se->getCont() &&
               (TESTAFF(se->getCont(), circumfix, se->getContLen()))))) &&
            // fogemorpheme
            (in_compound ||
             !((se->getCont() &&
                (TESTAFF(se->getCont(), onlyincompound, se->getContLen()))))) &&
            // needaffix on prefix or first suffix
            (cclass ||
             !(se->getCont() &&
               TESTAFF(se->getCont(), needaffix, se->getContLen())) ||
             (ppfx &&
              !((ep->getCont()) &&
                TESTAFF(ep->getCont(), needaffix, ep->getContLen()))))))
         rv = se->checkword(word, start, len, sfxopts, ppfx, cclass,
                            needflag, FLAG_NULL);
       while (rv) {
         if (ppfx) {
           if (ppfx->getMorph()) {
             result.append(ppfx->getMorph());
             result.push_back(MSEP_FLD);
           } else
             debugflag(result, ppfx->getFlag());
         }
         if (complexprefixes && HENTRY_DATA(rv))
           result.append(HENTRY_DATA2(rv));
         if (!HENTRY_FIND(rv, MORPH_STEM)) {
           result.push_back(MSEP_FLD);
           result.append(MORPH_STEM);
           result.append(HENTRY_WORD(rv));
         }
 
         if (!complexprefixes && HENTRY_DATA(rv)) {
           result.push_back(MSEP_FLD);
           result.append(HENTRY_DATA2(rv));
         }
         if (se->getMorph()) {
           result.push_back(MSEP_FLD);
           result.append(se->getMorph());
         } else
           debugflag(result, se->getFlag());
         result.push_back(MSEP_REC);
         rv = se->get_next_homonym(rv, sfxopts, ppfx, cclass, needflag);
       }
     }
     se = se->getNext();
   }
 
   // now handle the general case
   if (len == 0)
-    return std::string();  // FULLSTRIP
+    return { };  // FULLSTRIP
   unsigned char sp = word[start + len - 1];
   SfxEntry* sptr = sStart[sp];
 
   while (sptr) {
     if (isRevSubset(sptr->getKey(), word.c_str() + start + len - 1, len)) {
       // suffixes are not allowed in beginning of compounds
       if (((((in_compound != IN_CPD_BEGIN)) ||  // && !cclass
             // except when signed with compoundpermitflag flag
             (sptr->getCont() && compoundpermitflag &&
              TESTAFF(sptr->getCont(), compoundpermitflag,
                      sptr->getContLen()))) &&
            (!circumfix ||
             // no circumfix flag in prefix and suffix
             ((!ppfx || !(ep->getCont()) ||
               !TESTAFF(ep->getCont(), circumfix, ep->getContLen())) &&
              (!sptr->getCont() ||
               !(TESTAFF(sptr->getCont(), circumfix, sptr->getContLen())))) ||
             // circumfix flag in prefix AND suffix
             ((ppfx && (ep->getCont()) &&
               TESTAFF(ep->getCont(), circumfix, ep->getContLen())) &&
              (sptr->getCont() &&
               (TESTAFF(sptr->getCont(), circumfix, sptr->getContLen()))))) &&
            // fogemorpheme
            (in_compound ||
             !((sptr->getCont() && (TESTAFF(sptr->getCont(), onlyincompound,
                                            sptr->getContLen()))))) &&
            // needaffix on first suffix
            (cclass ||
             !(sptr->getCont() &&
               TESTAFF(sptr->getCont(), needaffix, sptr->getContLen())))))
         rv = sptr->checkword(word, start, len, sfxopts, ppfx, cclass,
                              needflag, FLAG_NULL);
       while (rv) {
         if (ppfx) {
           if (ppfx->getMorph()) {
             result.append(ppfx->getMorph());
             result.push_back(MSEP_FLD);
           } else
             debugflag(result, ppfx->getFlag());
         }
         if (complexprefixes && HENTRY_DATA(rv))
           result.append(HENTRY_DATA2(rv));
         if (!HENTRY_FIND(rv, MORPH_STEM)) {
           result.push_back(MSEP_FLD);
           result.append(MORPH_STEM);
           result.append(HENTRY_WORD(rv));
         }
 
         if (!complexprefixes && HENTRY_DATA(rv)) {
           result.push_back(MSEP_FLD);
           result.append(HENTRY_DATA2(rv));
         }
 
         if (sptr->getMorph()) {
           result.push_back(MSEP_FLD);
           result.append(sptr->getMorph());
         } else
           debugflag(result, sptr->getFlag());
         result.push_back(MSEP_REC);
         rv = sptr->get_next_homonym(rv, sfxopts, ppfx, cclass, needflag);
       }
       sptr = sptr->getNextEQ();
     } else {
       sptr = sptr->getNextNE();
     }
   }
 
   return result;
 }
 
 // check if word with affixes is correctly spelled
@@ -3203,82 +3173,81 @@ std::string AffixMgr::affix_check_morph(const std::string& word,
 // morphcmp(): compare MORPH_DERI_SFX, MORPH_INFL_SFX and MORPH_TERM_SFX fields
 // in the first line of the inputs
 // return 0, if inputs equal
 // return 1, if inputs may equal with a secondary suffix
 // otherwise return -1
 static int morphcmp(const char* s, const char* t) {
-  int se = 0;
-  int te = 0;
+  int se = 0, te = 0;
   const char* sl;
   const char* tl;
   const char* olds;
   const char* oldt;
   if (!s || !t)
     return 1;
   olds = s;
   sl = strchr(s, '\n');
   s = strstr(s, MORPH_DERI_SFX);
   if (!s || (sl && sl < s))
     s = strstr(olds, MORPH_INFL_SFX);
   if (!s || (sl && sl < s)) {
     s = strstr(olds, MORPH_TERM_SFX);
     olds = NULL;
   }
   oldt = t;
   tl = strchr(t, '\n');
   t = strstr(t, MORPH_DERI_SFX);
   if (!t || (tl && tl < t))
     t = strstr(oldt, MORPH_INFL_SFX);
   if (!t || (tl && tl < t)) {
     t = strstr(oldt, MORPH_TERM_SFX);
     oldt = NULL;
   }
   while (s && t && (!sl || sl > s) && (!tl || tl > t)) {
     s += MORPH_TAG_LEN;
     t += MORPH_TAG_LEN;
     se = 0;
     te = 0;
     while ((*s == *t) && !se && !te) {
       s++;
       t++;
       switch (*s) {
         case ' ':
         case '\n':
         case '\t':
         case '\0':
           se = 1;
       }
       switch (*t) {
         case ' ':
         case '\n':
         case '\t':
         case '\0':
           te = 1;
       }
     }
     if (!se || !te) {
       // not terminal suffix difference
       if (olds)
         return -1;
       return 1;
     }
     olds = s;
     s = strstr(s, MORPH_DERI_SFX);
     if (!s || (sl && sl < s))
       s = strstr(olds, MORPH_INFL_SFX);
     if (!s || (sl && sl < s)) {
       s = strstr(olds, MORPH_TERM_SFX);
       olds = NULL;
     }
     oldt = t;
     t = strstr(t, MORPH_DERI_SFX);
     if (!t || (tl && tl < t))
       t = strstr(oldt, MORPH_INFL_SFX);
     if (!t || (tl && tl < t)) {
       t = strstr(oldt, MORPH_TERM_SFX);
       oldt = NULL;
     }
   }
   if (!s && !t && se && te)
     return 0;
   return 1;
 }
@@ -3286,82 +3255,82 @@ static int morphcmp(const char* s, const char* t) {
 std::string AffixMgr::morphgen(const char* ts,
                                int wl,
                                const unsigned short* ap,
                                unsigned short al,
                                const char* morph,
                                const char* targetmorph,
                          int level) {
   // handle suffixes
   if (!morph)
-    return std::string();
+    return {};
 
   // check substandard flag
   if (TESTAFF(ap, substandard, al))
-    return std::string();
+    return {};
 
   if (morphcmp(morph, targetmorph) == 0)
     return ts;
 
   size_t stemmorphcatpos;
   std::string mymorph;
 
   // use input suffix fields, if exist
   if (strstr(morph, MORPH_INFL_SFX) || strstr(morph, MORPH_DERI_SFX)) {
     mymorph.assign(morph);
     mymorph.push_back(MSEP_FLD);
     stemmorphcatpos = mymorph.size();
   } else {
     stemmorphcatpos = std::string::npos;
   }
 
   for (int i = 0; i < al; i++) {
-    const unsigned char c = (unsigned char)(ap[i] & 0x00FF);
+    const auto c = (unsigned char)(ap[i] & 0x00FF);
     SfxEntry* sptr = sFlag[c];
     while (sptr) {
       if (sptr->getFlag() == ap[i] && sptr->getMorph() &&
           ((sptr->getContLen() == 0) ||
            // don't generate forms with substandard affixes
            !TESTAFF(sptr->getCont(), substandard, sptr->getContLen()))) {
         const char* stemmorph;
         if (stemmorphcatpos != std::string::npos) {
           mymorph.replace(stemmorphcatpos, std::string::npos, sptr->getMorph());
           stemmorph = mymorph.c_str();
         } else {
           stemmorph = sptr->getMorph();
         }
 
         int cmp = morphcmp(stemmorph, targetmorph);
 
         if (cmp == 0) {
           std::string newword = sptr->add(ts, wl);
           if (!newword.empty()) {
             hentry* check = pHMgr->lookup(newword.c_str(), newword.size());  // XXX extra dic
             if (!check || !check->astr ||
                 !(TESTAFF(check->astr, forbiddenword, check->alen) ||
                   TESTAFF(check->astr, ONLYUPCASEFLAG, check->alen))) {
               return newword;
             }
           }
         }
 
         // recursive call for secondary suffixes
         if ((level == 0) && (cmp == 1) && (sptr->getContLen() > 0) &&
             !TESTAFF(sptr->getCont(), substandard, sptr->getContLen())) {
           std::string newword = sptr->add(ts, wl);
           if (!newword.empty()) {
             std::string newword2 =
                 morphgen(newword.c_str(), newword.size(), sptr->getCont(),
                          sptr->getContLen(), stemmorph, targetmorph, 1);
 
             if (!newword2.empty()) {
               return newword2;
             }
           }
         }
       }
       sptr = sptr->getFlgNxt();
     }
   }
-  return std::string();
+  return { };
 }
 
 namespace {
@@ -3380,133 +3349,133 @@ namespace {
 int AffixMgr::expand_rootword(struct guessword* wlst,
                               int maxn,
                               const char* ts,
                               int wl,
                               const unsigned short* ap,
                               unsigned short al,
                               const char* bad,
                               int badl,
                               const char* phon) {
   int nh = 0;
   // first add root word to list
   if ((nh < maxn) &&
       !(al && ((needaffix && TESTAFF(ap, needaffix, al)) ||
                (onlyincompound && TESTAFF(ap, onlyincompound, al))))) {
     wlst[nh].word = mystrdup(ts);
     wlst[nh].allow = false;
     wlst[nh].orig = NULL;
     nh++;
     // add special phonetic version
     if (phon && (nh < maxn)) {
       wlst[nh].word = mystrdup(phon);
       wlst[nh].allow = false;
       wlst[nh].orig = mystrdup(ts);
       nh++;
     }
   }
 
   // handle suffixes
   for (int i = 0; i < al; i++) {
-    const unsigned char c = (unsigned char)(ap[i] & 0x00FF);
+    const auto c = (unsigned char)(ap[i] & 0x00FF);
     SfxEntry* sptr = sFlag[c];
     while (sptr) {
       if ((sptr->getFlag() == ap[i]) &&
           (!sptr->getKeyLen() ||
            ((badl > sptr->getKeyLen()) &&
             (strcmp(sptr->getAffix(), bad + badl - sptr->getKeyLen()) == 0))) &&
           // check needaffix flag
           !(sptr->getCont() &&
             ((needaffix &&
               TESTAFF(sptr->getCont(), needaffix, sptr->getContLen())) ||
              (circumfix &&
               TESTAFF(sptr->getCont(), circumfix, sptr->getContLen())) ||
              (onlyincompound &&
               TESTAFF(sptr->getCont(), onlyincompound, sptr->getContLen()))))) {
         std::string newword = sptr->add(ts, wl);
         if (!newword.empty()) {
           if (nh < maxn) {
             wlst[nh].word = mystrdup(newword.c_str());
             wlst[nh].allow = sptr->allowCross();
             wlst[nh].orig = NULL;
             nh++;
             // add special phonetic version
             if (phon && (nh < maxn)) {
               std::string prefix(phon);
               std::string key(sptr->getKey());
               reverseword(key);
               prefix.append(key);
               wlst[nh].word = mystrdup(prefix.c_str());
               wlst[nh].allow = false;
               wlst[nh].orig = mystrdup(newword.c_str());
               nh++;
             }
           }
         }
       }
       sptr = sptr->getFlgNxt();
     }
   }
 
   int n = nh;
 
   // handle cross products of prefixes and suffixes
   for (int j = 1; j < n; j++)
     if (wlst[j].allow) {
       for (int k = 0; k < al; k++) {
-        const unsigned char c = (unsigned char)(ap[k] & 0x00FF);
+        const auto c = (unsigned char)(ap[k] & 0x00FF);
         PfxEntry* cptr = pFlag[c];
         while (cptr) {
           if ((cptr->getFlag() == ap[k]) && cptr->allowCross() &&
               (!cptr->getKeyLen() ||
                ((badl > cptr->getKeyLen()) &&
                 (strncmp(cptr->getKey(), bad, cptr->getKeyLen()) == 0)))) {
             int l1 = strlen(wlst[j].word);
             std::string newword = cptr->add(wlst[j].word, l1);
             if (!newword.empty()) {
               if (nh < maxn) {
                 wlst[nh].word = mystrdup(newword.c_str());
                 wlst[nh].allow = cptr->allowCross();
                 wlst[nh].orig = NULL;
                 nh++;
               }
             }
           }
           cptr = cptr->getFlgNxt();
         }
       }
     }
 
   // now handle pure prefixes
   for (int m = 0; m < al; m++) {
-    const unsigned char c = (unsigned char)(ap[m] & 0x00FF);
+    const auto c = (unsigned char)(ap[m] & 0x00FF);
     PfxEntry* ptr = pFlag[c];
     while (ptr) {
       if ((ptr->getFlag() == ap[m]) &&
           (!ptr->getKeyLen() ||
            ((badl > ptr->getKeyLen()) &&
             (strncmp(ptr->getKey(), bad, ptr->getKeyLen()) == 0))) &&
           // check needaffix flag
           !(ptr->getCont() &&
             ((needaffix &&
               TESTAFF(ptr->getCont(), needaffix, ptr->getContLen())) ||
              (circumfix &&
               TESTAFF(ptr->getCont(), circumfix, ptr->getContLen())) ||
              (onlyincompound &&
               TESTAFF(ptr->getCont(), onlyincompound, ptr->getContLen()))))) {
         std::string newword = ptr->add(ts, wl);
         if (!newword.empty()) {
           if (nh < maxn) {
             wlst[nh].word = mystrdup(newword.c_str());
             wlst[nh].allow = ptr->allowCross();
             wlst[nh].orig = NULL;
             nh++;
           }
         }
       }
       ptr = ptr->getFlgNxt();
     }
   }
 
   return nh;
 }
 
 // return replacing table
@@ -3749,45 +3718,44 @@ bool AffixMgr::parse_num(const std::string& line, int* out, FileMgr* af) {
 /* parse in the max syllablecount of compound words and  */
 bool AffixMgr::parse_cpdsyllable(const std::string& line, FileMgr* af) {
   int i = 0;
   int np = 0;
-  std::string::const_iterator iter = line.begin();
-  std::string::const_iterator start_piece = mystrsep(line, iter);
+  auto iter = line.begin(), start_piece = mystrsep(line, iter);
   while (start_piece != line.end()) {
     switch (i) {
       case 0: {
         np++;
         break;
       }
       case 1: {
         cpdmaxsyllable = atoi(std::string(start_piece, iter).c_str());
         np++;
         break;
       }
       case 2: {
         if (!utf8) {
           cpdvowels.assign(start_piece, iter);
           std::sort(cpdvowels.begin(), cpdvowels.end());
         } else {
           std::string piece(start_piece, iter);
           u8_u16(cpdvowels_utf16, piece);
           std::sort(cpdvowels_utf16.begin(), cpdvowels_utf16.end());
         }
         np++;
         break;
       }
       default:
         break;
     }
     ++i;
     start_piece = mystrsep(line, iter);
   }
   if (np < 2) {
     HUNSPELL_WARNING(stderr,
                      "error: line %d: missing compoundsyllable information\n",
                      af->getlinenum());
     return false;
   }
   if (np == 2)
     cpdvowels = "AEIOUaeiou";
   return true;
 }
@@ -3795,579 +3763,571 @@ bool AffixMgr::parse_cpdsyllable(const std::string& line, FileMgr* af) {
 bool AffixMgr::parse_convtable(const std::string& line,
                               FileMgr* af,
                               RepList** rl,
                               const std::string& keyword) {
   if (*rl) {
     HUNSPELL_WARNING(stderr, "error: line %d: multiple table definitions\n",
                      af->getlinenum());
     return false;
   }
   int i = 0;
   int np = 0;
   int numrl = 0;
-  std::string::const_iterator iter = line.begin();
-  std::string::const_iterator start_piece = mystrsep(line, iter);
+  auto iter = line.begin(), start_piece = mystrsep(line, iter);
   while (start_piece != line.end()) {
     switch (i) {
       case 0: {
         np++;
         break;
       }
       case 1: {
         numrl = atoi(std::string(start_piece, iter).c_str());
         if (numrl < 1) {
           HUNSPELL_WARNING(stderr, "error: line %d: incorrect entry number\n",
                            af->getlinenum());
           return false;
         }
         *rl = new RepList(numrl);
         if (!*rl)
           return false;
         np++;
         break;
       }
       default:
         break;
     }
     ++i;
     start_piece = mystrsep(line, iter);
   }
   if (np != 2) {
     HUNSPELL_WARNING(stderr, "error: line %d: missing data\n",
                      af->getlinenum());
     return false;
   }
 
   /* now parse the num lines to read in the remainder of the table */
   for (int j = 0; j < numrl; j++) {
     std::string nl;
     if (!af->getline(nl))
       return false;
     mychomp(nl);
     i = 0;
     std::string pattern;
     std::string pattern2;
     iter = nl.begin();
     start_piece = mystrsep(nl, iter);
     while (start_piece != nl.end()) {
       {
         switch (i) {
           case 0: {
             if (nl.compare(start_piece - nl.begin(), keyword.size(), keyword, 0, keyword.size()) != 0) {
               HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n",
                                af->getlinenum());
               delete *rl;
               *rl = NULL;
               return false;
             }
             break;
           }
           case 1: {
             pattern.assign(start_piece, iter);
             break;
           }
           case 2: {
             pattern2.assign(start_piece, iter);
             break;
           }
           default:
             break;
         }
         ++i;
       }
       start_piece = mystrsep(nl, iter);
     }
     if (pattern.empty() || pattern2.empty()) {
       HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n",
                        af->getlinenum());
       return false;
     }
 
     (*rl)->add(pattern, pattern2);
   }
   return true;
 }
 
 /* parse in the typical fault correcting table */
 bool AffixMgr::parse_phonetable(const std::string& line, FileMgr* af) {
   if (phone) {
     HUNSPELL_WARNING(stderr, "error: line %d: multiple table definitions\n",
                      af->getlinenum());
     return false;
   }
   std::unique_ptr<phonetable> new_phone;
   int num = -1;
   int i = 0;
   int np = 0;
-  std::string::const_iterator iter = line.begin();
-  std::string::const_iterator start_piece = mystrsep(line, iter);
+  auto iter = line.begin(), start_piece = mystrsep(line, iter);
   while (start_piece != line.end()) {
     switch (i) {
       case 0: {
         np++;
         break;
       }
       case 1: {
         num = atoi(std::string(start_piece, iter).c_str());
         if (num < 1) {
           HUNSPELL_WARNING(stderr, "error: line %d: bad entry number\n",
                            af->getlinenum());
           return false;
         }
         new_phone.reset(new phonetable);
         new_phone->utf8 = (char)utf8;
         np++;
         break;
       }
       default:
         break;
     }
     ++i;
     start_piece = mystrsep(line, iter);
   }
   if (np != 2) {
     HUNSPELL_WARNING(stderr, "error: line %d: missing data\n",
                      af->getlinenum());
     return false;
   }
 
   /* now parse the phone->num lines to read in the remainder of the table */
   for (int j = 0; j < num; ++j) {
     std::string nl;
     if (!af->getline(nl))
       return false;
     mychomp(nl);
     i = 0;
     const size_t old_size = new_phone->rules.size();
     iter = nl.begin();
     start_piece = mystrsep(nl, iter);
     while (start_piece != nl.end()) {
       {
         switch (i) {
           case 0: {
             if (nl.compare(start_piece - nl.begin(), 5, "PHONE", 5) != 0) {
               HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n",
                                af->getlinenum());
               return false;
             }
             break;
           }
           case 1: {
-            new_phone->rules.push_back(std::string(start_piece, iter));
+            new_phone->rules.emplace_back(start_piece, iter);
             break;
           }
           case 2: {
-            new_phone->rules.push_back(std::string(start_piece, iter));
+            new_phone->rules.emplace_back(start_piece, iter);
             mystrrep(new_phone->rules.back(), "_", "");
             break;
           }
           default:
             break;
         }
         ++i;
       }
       start_piece = mystrsep(nl, iter);
     }
     if (new_phone->rules.size() != old_size + 2) {
       HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n",
                        af->getlinenum());
       return false;
     }
   }
-  new_phone->rules.push_back("");
-  new_phone->rules.push_back("");
+  new_phone->rules.emplace_back("");
+  new_phone->rules.emplace_back("");
   init_phonet_hash(*new_phone);
   phone = new_phone.release();
   return true;
 }
 
 /* parse in the checkcompoundpattern table */
 bool AffixMgr::parse_checkcpdtable(const std::string& line, FileMgr* af) {
   if (parsedcheckcpd) {
     HUNSPELL_WARNING(stderr, "error: line %d: multiple table definitions\n",
                      af->getlinenum());
     return false;
   }
   parsedcheckcpd = true;
   int numcheckcpd = -1;
   int i = 0;
   int np = 0;
-  std::string::const_iterator iter = line.begin();
-  std::string::const_iterator start_piece = mystrsep(line, iter);
+  auto iter = line.begin(), start_piece = mystrsep(line, iter);
   while (start_piece != line.end()) {
     switch (i) {
       case 0: {
         np++;
         break;
       }
       case 1: {
         numcheckcpd = atoi(std::string(start_piece, iter).c_str());
         if (numcheckcpd < 1) {
           HUNSPELL_WARNING(stderr, "error: line %d: bad entry number\n",
                            af->getlinenum());
           return false;
         }
         checkcpdtable.reserve(std::min(numcheckcpd, 16384));
         np++;
         break;
       }
       default:
         break;
     }
     ++i;
     start_piece = mystrsep(line, iter);
   }
   if (np != 2) {
     HUNSPELL_WARNING(stderr, "error: line %d: missing data\n",
                      af->getlinenum());
     return false;
   }
 
   /* now parse the numcheckcpd lines to read in the remainder of the table */
   for (int j = 0; j < numcheckcpd; ++j) {
     std::string nl;
     if (!af->getline(nl))
       return false;
     mychomp(nl);
     i = 0;
-    checkcpdtable.push_back(patentry());
+    checkcpdtable.emplace_back();
     iter = nl.begin();
     start_piece = mystrsep(nl, iter);
     while (start_piece != nl.end()) {
       switch (i) {
         case 0: {
           if (nl.compare(start_piece - nl.begin(), 20, "CHECKCOMPOUNDPATTERN", 20) != 0) {
             HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n",
                              af->getlinenum());
             return false;
           }
           break;
         }
         case 1: {
           checkcpdtable.back().pattern.assign(start_piece, iter);
           size_t slash_pos = checkcpdtable.back().pattern.find('/');
           if (slash_pos != std::string::npos) {
             std::string chunk(checkcpdtable.back().pattern, slash_pos + 1);
             checkcpdtable.back().pattern.resize(slash_pos);
             checkcpdtable.back().cond = pHMgr->decode_flag(chunk);
           }
           break;
         }
         case 2: {
           checkcpdtable.back().pattern2.assign(start_piece, iter);
           size_t slash_pos = checkcpdtable.back().pattern2.find('/');
           if (slash_pos != std::string::npos) {
             std::string chunk(checkcpdtable.back().pattern2, slash_pos + 1);
             checkcpdtable.back().pattern2.resize(slash_pos);
             checkcpdtable.back().cond2 = pHMgr->decode_flag(chunk);
           }
           break;
         }
         case 3: {
           checkcpdtable.back().pattern3.assign(start_piece, iter);
           simplifiedcpd = 1;
           break;
         }
         default:
           break;
       }
       i++;
       start_piece = mystrsep(nl, iter);
     }
   }
   return true;
 }
 
 /* parse in the compound rule table */
 bool AffixMgr::parse_defcpdtable(const std::string& line, FileMgr* af) {
   if (parseddefcpd) {
     HUNSPELL_WARNING(stderr, "error: line %d: multiple table definitions\n",
                      af->getlinenum());
     return false;
   }
   parseddefcpd = true;
   int numdefcpd = -1;
   int i = 0;
   int np = 0;
-  std::string::const_iterator iter = line.begin();
-  std::string::const_iterator start_piece = mystrsep(line, iter);
+  auto iter = line.begin(), start_piece = mystrsep(line, iter);
   while (start_piece != line.end()) {
     switch (i) {
       case 0: {
         np++;
         break;
       }
       case 1: {
         numdefcpd = atoi(std::string(start_piece, iter).c_str());
         if (numdefcpd < 1) {
           HUNSPELL_WARNING(stderr, "error: line %d: bad entry number\n",
                            af->getlinenum());
           return false;
         }
         defcpdtable.reserve(std::min(numdefcpd, 16384));
         np++;
         break;
       }
       default:
         break;
     }
     ++i;
     start_piece = mystrsep(line, iter);
   }
   if (np != 2) {
     HUNSPELL_WARNING(stderr, "error: line %d: missing data\n",
                      af->getlinenum());
     return false;
   }
 
   /* now parse the numdefcpd lines to read in the remainder of the table */
   for (int j = 0; j < numdefcpd; ++j) {
     std::string nl;
     if (!af->getline(nl))
       return false;
     mychomp(nl);
     i = 0;
-    defcpdtable.push_back(flagentry());
+    defcpdtable.emplace_back();
     iter = nl.begin();
     start_piece = mystrsep(nl, iter);
     while (start_piece != nl.end()) {
       switch (i) {
         case 0: {
           if (nl.compare(start_piece - nl.begin(), 12, "COMPOUNDRULE", 12) != 0) {
             HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n",
                              af->getlinenum());
             numdefcpd = 0;
             return false;
           }
           break;
         }
         case 1: {  // handle parenthesized flags
           if (std::find(start_piece, iter, '(') != iter) {
-            for (std::string::const_iterator k = start_piece; k != iter; ++k) {
-              std::string::const_iterator chb = k;
-              std::string::const_iterator che = k + 1;
+            for (auto k = start_piece; k != iter; ++k) {
+              auto chb = k, che = k + 1;
               if (*k == '(') {
-                std::string::const_iterator parpos = std::find(k, iter, ')');
+	            auto parpos = std::find(k, iter, ')');
                 if (parpos != iter) {
                   chb = k + 1;
                   che = parpos;
                   k = parpos;
                 }
               }
 
               if (*chb == '*' || *chb == '?') {
                 defcpdtable.back().push_back((FLAG)*chb);
               } else {
                 pHMgr->decode_flags(defcpdtable.back(), std::string(chb, che), af);
               }
             }
           } else {
             pHMgr->decode_flags(defcpdtable.back(), std::string(start_piece, iter), af);
           }
           break;
         }
         default:
           break;
       }
       ++i;
       start_piece = mystrsep(nl, iter);
     }
     if (defcpdtable.back().empty()) {
       HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n",
                        af->getlinenum());
       return false;
     }
   }
   return true;
 }
 
 /* parse in the character map table */
 bool AffixMgr::parse_maptable(const std::string& line, FileMgr* af) {
   if (parsedmaptable) {
     HUNSPELL_WARNING(stderr, "error: line %d: multiple table definitions\n",
                      af->getlinenum());
     return false;
   }
   parsedmaptable = true;
   int nummap = -1;
   int i = 0;
   int np = 0;
-  std::string::const_iterator iter = line.begin();
-  std::string::const_iterator start_piece = mystrsep(line, iter);
+  auto iter = line.begin(), start_piece = mystrsep(line, iter);
   while (start_piece != line.end()) {
     switch (i) {
       case 0: {
         np++;
         break;
       }
       case 1: {
         nummap = atoi(std::string(start_piece, iter).c_str());
         if (nummap < 1) {
           HUNSPELL_WARNING(stderr, "error: line %d: bad entry number\n",
                            af->getlinenum());
           return false;
         }
         maptable.reserve(std::min(nummap, 16384));
         np++;
         break;
       }
       default:
         break;
     }
     ++i;
     start_piece = mystrsep(line, iter);
   }
   if (np != 2) {
     HUNSPELL_WARNING(stderr, "error: line %d: missing data\n",
                      af->getlinenum());
     return false;
   }
 
   /* now parse the nummap lines to read in the remainder of the table */
   for (int j = 0; j < nummap; ++j) {
     std::string nl;
     if (!af->getline(nl))
       return false;
     mychomp(nl);
     i = 0;
-    maptable.push_back(mapentry());
+    maptable.emplace_back();
     iter = nl.begin();
     start_piece = mystrsep(nl, iter);
     while (start_piece != nl.end()) {
       switch (i) {
         case 0: {
           if (nl.compare(start_piece - nl.begin(), 3, "MAP", 3) != 0) {
             HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n",
                              af->getlinenum());
             nummap = 0;
             return false;
           }
           break;
         }
         case 1: {
-          for (std::string::const_iterator k = start_piece; k != iter; ++k) {
-            std::string::const_iterator chb = k;
-            std::string::const_iterator che = k + 1;
+          for (auto k = start_piece; k != iter; ++k) {
+            auto chb = k, che = k + 1;
             if (*k == '(') {
-              std::string::const_iterator parpos = std::find(k, iter, ')');
+              auto parpos = std::find(k, iter, ')');
               if (parpos != iter) {
                 chb = k + 1;
                 che = parpos;
                 k = parpos;
               }
             } else {
               if (utf8 && (*k & 0xc0) == 0xc0) {
                 ++k;
                 while (k != iter && (*k & 0xc0) == 0x80)
                     ++k;
                 che = k;
                 --k;
               }
             }
             if (chb == che) {
               HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n",
                               af->getlinenum());
             }
 
-            maptable.back().push_back(std::string(chb, che));
+            maptable.back().emplace_back(chb, che);
           }
           break;
         }
         default:
           break;
       }
       ++i;
       start_piece = mystrsep(nl, iter);
     }
     if (maptable.back().empty()) {
       HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n",
                        af->getlinenum());
       return false;
     }
   }
   return true;
 }
 
 /* parse in the word breakpoint table */
 bool AffixMgr::parse_breaktable(const std::string& line, FileMgr* af) {
   if (parsedbreaktable) {
     HUNSPELL_WARNING(stderr, "error: line %d: multiple table definitions\n",
                      af->getlinenum());
     return false;
   }
   parsedbreaktable = true;
   int numbreak = -1;
   int i = 0;
   int np = 0;
-  std::string::const_iterator iter = line.begin();
-  std::string::const_iterator start_piece = mystrsep(line, iter);
+  auto iter = line.begin(), start_piece = mystrsep(line, iter);
   while (start_piece != line.end()) {
     switch (i) {
       case 0: {
         np++;
         break;
       }
       case 1: {
         numbreak = atoi(std::string(start_piece, iter).c_str());
         if (numbreak < 0) {
           HUNSPELL_WARNING(stderr, "error: line %d: bad entry number\n",
                            af->getlinenum());
           return false;
         }
         if (numbreak == 0)
           return true;
         breaktable.reserve(std::min(numbreak, 16384));
         np++;
         break;
       }
       default:
         break;
     }
     ++i;
     start_piece = mystrsep(line, iter);
   }
   if (np != 2) {
     HUNSPELL_WARNING(stderr, "error: line %d: missing data\n",
                      af->getlinenum());
     return false;
   }
 
   /* now parse the numbreak lines to read in the remainder of the table */
   for (int j = 0; j < numbreak; ++j) {
     std::string nl;
     if (!af->getline(nl))
       return false;
     mychomp(nl);
     i = 0;
     iter = nl.begin();
     start_piece = mystrsep(nl, iter);
     while (start_piece != nl.end()) {
       switch (i) {
         case 0: {
           if (nl.compare(start_piece - nl.begin(), 5, "BREAK", 5) != 0) {
             HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n",
                              af->getlinenum());
             numbreak = 0;
             return false;
           }
           break;
         }
         case 1: {
-          breaktable.push_back(std::string(start_piece, iter));
+          breaktable.emplace_back(start_piece, iter);
           break;
         }
         default:
           break;
       }
       ++i;
       start_piece = mystrsep(nl, iter);
     }
   }
 
   if (breaktable.size() != static_cast<size_t>(numbreak)) {
     HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n",
                      af->getlinenum());
     return false;
   }
 
   return true;
 }
@@ -4375,35 +4335,35 @@ bool AffixMgr::parse_breaktable(const std::string& line, FileMgr* af) {
 void AffixMgr::reverse_condition(std::string& piece) {
   if (piece.empty())
       return;
 
   int neg = 0;
-  for (std::string::reverse_iterator k = piece.rbegin(); k != piece.rend(); ++k) {
+  for (auto k = piece.rbegin(); k != piece.rend(); ++k) {
     switch (*k) {
       case '[': {
         if (neg)
           *(k - 1) = '[';
         else
           *k = ']';
         break;
       }
       case ']': {
         *k = '[';
         if (neg)
           *(k - 1) = '^';
         neg = 0;
         break;
       }
       case '^': {
         if (*(k - 1) == ']')
           neg = 1;
         else if (neg)
           *(k - 1) = *k;
         break;
       }
       default: {
         if (neg)
           *(k - 1) = *k;
       }
     }
   }
 }
@@ -4412,49 +4372,49 @@ class entries_container {
   std::vector<AffEntry*> entries;
   AffixMgr* m_mgr;
   char m_at;
 public:
   entries_container(char at, AffixMgr* mgr)
     : m_mgr(mgr)
     , m_at(at) {
   }
   void release() {
     entries.clear();
   }
   void initialize(int numents,
                   char opts, unsigned short aflag) {
     entries.reserve(std::min(numents, 16384));
 
     if (m_at == 'P') {
       entries.push_back(new PfxEntry(m_mgr));
     } else {
       entries.push_back(new SfxEntry(m_mgr));
     }
 
     entries.back()->opts = opts;
     entries.back()->aflag = aflag;
   }
 
   AffEntry* add_entry(char opts) {
     if (m_at == 'P') {
       entries.push_back(new PfxEntry(m_mgr));
     } else {
       entries.push_back(new SfxEntry(m_mgr));
     }
     AffEntry* ret = entries.back();
     ret->opts = entries[0]->opts & opts;
     return ret;
   }
 
   AffEntry* first_entry() {
     return entries.empty() ? NULL : entries[0];
   }
 
   ~entries_container() {
-    for (size_t i = 0; i < entries.size(); ++i) {
-        delete entries[i];
+    for (auto& entry : entries) {
+      delete entry;
     }
   }
 
   std::vector<AffEntry*>::iterator begin() { return entries.begin(); }
   std::vector<AffEntry*>::iterator end() { return entries.end(); }
 };
@@ -4462,309 +4422,307 @@ public:
 bool AffixMgr::parse_affix(const std::string& line,
                           const char at,
                           FileMgr* af,
                           char* dupflags) {
   int numents = 0;  // number of AffEntry structures to parse
 
   unsigned short aflag = 0;  // affix char identifier
 
   char ff = 0;
   entries_container affentries(at, this);
 
   int i = 0;
 
 // checking lines with bad syntax
 #ifdef DEBUG
   int basefieldnum = 0;
 #endif
 
   // split affix header line into pieces
 
   int np = 0;
-  std::string::const_iterator iter = line.begin();
-  std::string::const_iterator start_piece = mystrsep(line, iter);
+  auto iter = line.begin(), start_piece = mystrsep(line, iter);
   while (start_piece != line.end()) {
     switch (i) {
       // piece 1 - is type of affix
       case 0: {
         np++;
         break;
       }
 
       // piece 2 - is affix char
       case 1: {
         np++;
         aflag = pHMgr->decode_flag(std::string(start_piece, iter));
         if (((at == 'S') && (dupflags[aflag] & dupSFX)) ||
             ((at == 'P') && (dupflags[aflag] & dupPFX))) {
           HUNSPELL_WARNING(
               stderr,
               "error: line %d: multiple definitions of an affix flag\n",
               af->getlinenum());
         }
         dupflags[aflag] += (char)((at == 'S') ? dupSFX : dupPFX);
         break;
       }
       // piece 3 - is cross product indicator
       case 2: {
         np++;
         if (*start_piece == 'Y')
           ff = aeXPRODUCT;
         break;
       }
 
       // piece 4 - is number of affentries
       case 3: {
         np++;
         numents = atoi(std::string(start_piece, iter).c_str());
         if ((numents <= 0) || ((std::numeric_limits<size_t>::max() /
                                 sizeof(AffEntry)) < static_cast<size_t>(numents))) {
           std::string err = pHMgr->encode_flag(aflag);
           HUNSPELL_WARNING(stderr, "error: line %d: bad entry number\n",
                            af->getlinenum());
           return false;
         }
 
         char opts = ff;
         if (utf8)
           opts |= aeUTF8;
         if (pHMgr->is_aliasf())
           opts |= aeALIASF;
         if (pHMgr->is_aliasm())
           opts |= aeALIASM;
         affentries.initialize(numents, opts, aflag);
       }
 
       default:
         break;
     }
     ++i;
     start_piece = mystrsep(line, iter);
   }
   // check to make sure we parsed enough pieces
   if (np != 4) {
     std::string err = pHMgr->encode_flag(aflag);
     HUNSPELL_WARNING(stderr, "error: line %d: missing data\n",
                      af->getlinenum());
     return false;
   }
 
   // now parse numents affentries for this affix
   AffEntry* entry = affentries.first_entry();
   for (int ent = 0; ent < numents; ++ent) {
     std::string nl;
     if (!af->getline(nl))
       return false;
     mychomp(nl);
 
     iter = nl.begin();
     i = 0;
     np = 0;
 
     // split line into pieces
     start_piece = mystrsep(nl, iter);
     while (start_piece != nl.end()) {
       switch (i) {
         // piece 1 - is type
         case 0: {
           np++;
           if (ent != 0)
             entry = affentries.add_entry((char)(aeXPRODUCT + aeUTF8 + aeALIASF + aeALIASM));
           break;
         }
 
         // piece 2 - is affix char
         case 1: {
           np++;
           std::string chunk(start_piece, iter);
           if (pHMgr->decode_flag(chunk) != aflag) {
             std::string err = pHMgr->encode_flag(aflag);
             HUNSPELL_WARNING(stderr,
                              "error: line %d: affix %s is corrupt\n",
                              af->getlinenum(), err.c_str());
             return false;
           }
 
           if (ent != 0) {
             AffEntry* start_entry = affentries.first_entry();
             entry->aflag = start_entry->aflag;
           }
           break;
         }
 
         // piece 3 - is string to strip or 0 for null
         case 2: {
           np++;
           entry->strip = std::string(start_piece, iter);
           if (complexprefixes) {
             if (utf8)
               reverseword_utf(entry->strip);
             else
               reverseword(entry->strip);
           }
           if (entry->strip.compare("0") == 0) {
             entry->strip.clear();
           }
           break;
         }
 
         // piece 4 - is affix string or 0 for null
         case 3: {
           entry->morphcode = NULL;
           entry->contclass = NULL;
           entry->contclasslen = 0;
           np++;
           std::string::const_iterator dash = std::find(start_piece, iter, '/');
           if (dash != iter) {
             entry->appnd = std::string(start_piece, dash);
             std::string dash_str(dash + 1, iter);
 
             if (!ignorechars.empty() && !has_no_ignored_chars(entry->appnd, ignorechars)) {
               if (utf8) {
                 remove_ignored_chars_utf(entry->appnd, ignorechars_utf16);
               } else {
                 remove_ignored_chars(entry->appnd, ignorechars);
               }
             }
 
             if (complexprefixes) {
               if (utf8)
                 reverseword_utf(entry->appnd);
               else
                 reverseword(entry->appnd);
             }
 
             if (pHMgr->is_aliasf()) {
               int index = atoi(dash_str.c_str());
               entry->contclasslen = (unsigned short)pHMgr->get_aliasf(
                   index, &(entry->contclass), af);
               if (!entry->contclasslen)
                 HUNSPELL_WARNING(stderr,
                                  "error: bad affix flag alias: \"%s\"\n",
                                  dash_str.c_str());
             } else {
               entry->contclasslen = (unsigned short)pHMgr->decode_flags(
                   &(entry->contclass), dash_str, af);
               std::sort(entry->contclass, entry->contclass + entry->contclasslen);
             }
 
             havecontclass = 1;
             for (unsigned short _i = 0; _i < entry->contclasslen; _i++) {
               contclasses[(entry->contclass)[_i]] = 1;
             }
           } else {
             entry->appnd = std::string(start_piece, iter);
 
             if (!ignorechars.empty() && !has_no_ignored_chars(entry->appnd, ignorechars)) {
               if (utf8) {
                 remove_ignored_chars_utf(entry->appnd, ignorechars_utf16);
               } else {
                 remove_ignored_chars(entry->appnd, ignorechars);
               }
             }
 
             if (complexprefixes) {
               if (utf8)
                 reverseword_utf(entry->appnd);
               else
                 reverseword(entry->appnd);
             }
           }
 
           if (entry->appnd.compare("0") == 0) {
             entry->appnd.clear();
           }
           break;
         }
 
         // piece 5 - is the conditions descriptions
         case 4: {
           std::string chunk(start_piece, iter);
           np++;
           if (complexprefixes) {
             if (utf8)
               reverseword_utf(chunk);
             else
               reverseword(chunk);
             reverse_condition(chunk);
           }
           if (!entry->strip.empty() && chunk != "." &&
               redundant_condition(at, entry->strip, chunk,
                                   af->getlinenum()))
             chunk = ".";
           if (at == 'S') {
             reverseword(chunk);
             reverse_condition(chunk);
           }
           if (encodeit(*entry, chunk))
             return false;
           break;
         }
 
         case 5: {
           std::string chunk(start_piece, iter);
           np++;
           if (pHMgr->is_aliasm()) {
             int index = atoi(chunk.c_str());
             entry->morphcode = pHMgr->get_aliasm(index);
           } else {
             if (complexprefixes) {  // XXX - fix me for morph. gen.
               if (utf8)
                 reverseword_utf(chunk);
               else
                 reverseword(chunk);
             }
             // add the remaining of the line
             std::string::const_iterator end = nl.end();
             if (iter != end) {
               chunk.append(iter, end);
             }
             entry->morphcode = mystrdup(chunk.c_str());
           }
           break;
         }
         default:
           break;
       }
       i++;
       start_piece = mystrsep(nl, iter);
     }
     // check to make sure we parsed enough pieces
     if (np < 4) {
       std::string err = pHMgr->encode_flag(aflag);
       HUNSPELL_WARNING(stderr, "error: line %d: affix %s is corrupt\n",
                        af->getlinenum(), err.c_str());
       return false;
     }
 
 #ifdef DEBUG
     // detect unnecessary fields, excepting comments
     if (basefieldnum) {
       int fieldnum =
           !(entry->morphcode) ? 5 : ((*(entry->morphcode) == '#') ? 5 : 6);
       if (fieldnum != basefieldnum)
         HUNSPELL_WARNING(stderr, "warning: line %d: bad field number\n",
                          af->getlinenum());
     } else {
       basefieldnum =
           !(entry->morphcode) ? 5 : ((*(entry->morphcode) == '#') ? 5 : 6);
     }
 #endif
   }
 
   // now create SfxEntry or PfxEntry objects and use links to
   // build an ordered (sorted by affix string) list
-  std::vector<AffEntry*>::iterator start = affentries.begin();
-  std::vector<AffEntry*>::iterator end = affentries.end();
-  for (std::vector<AffEntry*>::iterator affentry = start; affentry != end; ++affentry) {
+  auto start = affentries.begin(), end = affentries.end();
+  for (auto affentry = start; affentry != end; ++affentry) {
     if (at == 'P') {
-      build_pfxtree(static_cast<PfxEntry*>(*affentry));
+      build_pfxtree(dynamic_cast<PfxEntry*>(*affentry));
     } else {
-      build_sfxtree(static_cast<SfxEntry*>(*affentry));
+      build_sfxtree(dynamic_cast<SfxEntry*>(*affentry));
     }
   }
 
   //contents belong to AffixMgr now
   affentries.release();
 
   return true;
 }
@@ -4772,91 +4730,88 @@ bool AffixMgr::parse_affix(const std::string& line,
 int AffixMgr::redundant_condition(char ft,
                                   const std::string& strip,
                                   const std::string& cond,
                                   int linenum) {
-  int stripl = strip.size(), condl = cond.size();
-  int i, j;
-  int neg;
-  int in;
+  int stripl = strip.size(), condl = cond.size(), i, j, neg, in;
   if (ft == 'P') {  // prefix
     if (strip.compare(0, condl, cond) == 0)
       return 1;
     if (utf8) {
     } else {
       for (i = 0, j = 0; (i < stripl) && (j < condl); i++, j++) {
         if (cond[j] != '[') {
           if (cond[j] != strip[i]) {
             HUNSPELL_WARNING(stderr,
                              "warning: line %d: incompatible stripping "
                              "characters and condition\n",
                              linenum);
             return 0;
           }
         } else {
           neg = (cond[j + 1] == '^') ? 1 : 0;
           in = 0;
           do {
             j++;
             if (strip[i] == cond[j])
               in = 1;
           } while ((j < (condl - 1)) && (cond[j] != ']'));
           if (j == (condl - 1) && (cond[j] != ']')) {
             HUNSPELL_WARNING(stderr,
                              "error: line %d: missing ] in condition:\n%s\n",
                              linenum, cond.c_str());
             return 0;
           }
           if ((!neg && !in) || (neg && in)) {
             HUNSPELL_WARNING(stderr,
                              "warning: line %d: incompatible stripping "
                              "characters and condition\n",
                              linenum);
             return 0;
           }
         }
       }
       if (j >= condl)
         return 1;
     }
   } else {  // suffix
     if ((stripl >= condl) && strip.compare(stripl - condl, std::string::npos, cond) == 0)
       return 1;
     if (utf8) {
     } else {
       for (i = stripl - 1, j = condl - 1; (i >= 0) && (j >= 0); i--, j--) {
         if (cond[j] != ']') {
           if (cond[j] != strip[i]) {
             HUNSPELL_WARNING(stderr,
                              "warning: line %d: incompatible stripping "
                              "characters and condition\n",
                              linenum);
             return 0;
           }
         } else if (j > 0) {
           in = 0;
           do {
             j--;
             if (strip[i] == cond[j])
               in = 1;
           } while ((j > 0) && (cond[j] != '['));
           if ((j == 0) && (cond[j] != '[')) {
             HUNSPELL_WARNING(stderr,
                              "error: line: %d: missing ] in condition:\n%s\n",
                              linenum, cond.c_str());
             return 0;
           }
           neg = (cond[j + 1] == '^') ? 1 : 0;
           if ((!neg && !in) || (neg && in)) {
             HUNSPELL_WARNING(stderr,
                              "warning: line %d: incompatible stripping "
                              "characters and condition\n",
                              linenum);
             return 0;
           }
         }
       }
       if (j < 0)
         return 1;
     }
   }
   return 0;
 }
@@ -4864,25 +4819,24 @@ int AffixMgr::redundant_condition(char ft,
 std::vector<std::string> AffixMgr::get_suffix_words(short unsigned* suff,
                                int len,
                                const std::string& root_word) {
   std::vector<std::string> slst;
   short unsigned* start_ptr = suff;
-  for (int j = 0; j < SETSIZE; j++) {
-    SfxEntry* ptr = sStart[j];
+  for (auto ptr : sStart) {
     while (ptr) {
       suff = start_ptr;
       for (int i = 0; i < len; i++) {
         if ((*suff) == ptr->getFlag()) {
           std::string nw(root_word);
           nw.append(ptr->getAffix());
           hentry* ht = ptr->checkword(nw, 0, nw.size(), 0, NULL, 0, 0, 0);
           if (ht) {
             slst.push_back(nw);
           }
         }
         suff++;
       }
       ptr = ptr->getNext();
     }
   }
   return slst;
 }
diff --git a/src/hunspell/affixmgr.hxx b/src/hunspell/affixmgr.hxx
index a0ba103..174ce33 100644
--- a/src/hunspell/affixmgr.hxx
+++ b/src/hunspell/affixmgr.hxx
@@ -1,87 +1,87 @@
 /* ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
  * Copyright (C) 2002-2022 Németh László
  *
  * The contents of this file are subject to the Mozilla Public License Version
  * 1.1 (the "License"); you may not use this file except in compliance with
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * Hunspell is based on MySpell which is Copyright (C) 2002 Kevin Hendricks.
  *
  * Contributor(s): David Einstein, Davide Prina, Giuseppe Modugno,
  * Gianluca Turconi, Simon Brouwer, Noll János, Bíró Árpád,
  * Goldman Eleonóra, Sarlós Tamás, Bencsáth Boldizsár, Halácsy Péter,
  * Dvornik László, Gefferth András, Nagy Viktor, Varga Dániel, Chris Halls,
  * Rene Engelhard, Bram Moolenaar, Dafydd Jones, Harri Pitkänen
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 /*
  * Copyright 2002 Kevin B. Hendricks, Stratford, Ontario, Canada
  * And Contributors.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  *
  * 3. All modifications to the source code must be clearly marked as
  *    such.  Binary redistributions based on modified source code
  *    must be clearly marked as modified versions in the documentation
  *    and/or other materials provided with the distribution.
  *
  * THIS SOFTWARE IS PROVIDED BY KEVIN B. HENDRICKS AND CONTRIBUTORS
  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
  * KEVIN B. HENDRICKS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
 
 #ifndef AFFIXMGR_HXX_
 #define AFFIXMGR_HXX_
 
-#include <stdio.h>
+#include <cstdio>
 
 #include <string>
 #include <vector>
 
 #include "atypes.hxx"
 #include "baseaffix.hxx"
 #include "hashmgr.hxx"
 #include "phonet.hxx"
 #include "replist.hxx"
 
 // check flag duplication
 #define dupSFX (1 << 0)
 #define dupPFX (1 << 1)
diff --git a/src/hunspell/baseaffix.hxx b/src/hunspell/baseaffix.hxx
index bd2f3f2..b1f2404 100644
--- a/src/hunspell/baseaffix.hxx
+++ b/src/hunspell/baseaffix.hxx
@@ -41,34 +41,32 @@
 #include <string>
 
 class AffEntry {
- private:
-  AffEntry(const AffEntry&);
-  AffEntry& operator=(const AffEntry&);
-
  public:
   AffEntry()
       : numconds(0),
         opts(0),
         aflag(0),
         morphcode(0),
         contclass(NULL),
         contclasslen(0) {}
+  AffEntry(const AffEntry&) = delete;
+  AffEntry& operator=(const AffEntry&) = delete;
   virtual ~AffEntry();
   std::string appnd;
   std::string strip;
   unsigned char numconds;
   char opts;
   unsigned short aflag;
   union {
     char conds[MAXCONDLEN];
     struct {
       char conds1[MAXCONDLEN_1];
       char* conds2;
     } l;
   } c;
   char* morphcode;
   unsigned short* contclass;
   unsigned short contclasslen;
 };
 
 #endif
diff --git a/src/hunspell/csutil.cxx b/src/hunspell/csutil.cxx
index f3a9d61..4589e77 100644
--- a/src/hunspell/csutil.cxx
+++ b/src/hunspell/csutil.cxx
@@ -1,102 +1,102 @@
 /* ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
  * Copyright (C) 2002-2022 Németh László
  *
  * The contents of this file are subject to the Mozilla Public License Version
  * 1.1 (the "License"); you may not use this file except in compliance with
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * Hunspell is based on MySpell which is Copyright (C) 2002 Kevin Hendricks.
  *
  * Contributor(s): David Einstein, Davide Prina, Giuseppe Modugno,
  * Gianluca Turconi, Simon Brouwer, Noll János, Bíró Árpád,
  * Goldman Eleonóra, Sarlós Tamás, Bencsáth Boldizsár, Halácsy Péter,
  * Dvornik László, Gefferth András, Nagy Viktor, Varga Dániel, Chris Halls,
  * Rene Engelhard, Bram Moolenaar, Dafydd Jones, Harri Pitkänen
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 /*
  * Copyright 2002 Kevin B. Hendricks, Stratford, Ontario, Canada
  * And Contributors.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  *
  * 3. All modifications to the source code must be clearly marked as
  *    such.  Binary redistributions based on modified source code
  *    must be clearly marked as modified versions in the documentation
  *    and/or other materials provided with the distribution.
  *
  * THIS SOFTWARE IS PROVIDED BY KEVIN B. HENDRICKS AND CONTRIBUTORS
  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
  * KEVIN B. HENDRICKS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
 
 #include <algorithm>
 #include <assert.h>
-#include <stdlib.h>
-#include <string.h>
-#include <stdio.h>
-#include <ctype.h>
+#include <cstdlib>
+#include <cstring>
+#include <cstdio>
+#include <cctype>
 #include <sstream>
 #if __cplusplus >= 202002L
 #include <bit>
 #endif
 
 #include "csutil.hxx"
 #include "atypes.hxx"
 #include "langnum.hxx"
 
 #ifdef _WIN32
 #include <windows.h>
 #include <wchar.h>
 #endif
 
 #ifdef OPENOFFICEORG
 #include <unicode/uchar.h>
 #else
 #ifndef MOZILLA_CLIENT
 #include "utf_info.hxx"
 #endif
 #endif
 
 #ifdef MOZILLA_CLIENT
 #include "nsCOMPtr.h"
 #include "nsUnicharUtils.h"
 #include "mozilla/Encoding.h"
@@ -127,37 +127,36 @@ void myopen(std::ifstream& stream, const char* path, std::ios_base::openmode mod
 std::string& u16_u8(std::string& dest, const std::vector<w_char>& src) {
   dest.clear();
   dest.reserve(src.size());
-  std::vector<w_char>::const_iterator u2 = src.begin();
-  std::vector<w_char>::const_iterator u2_max = src.end();
+  auto u2 = src.begin(), u2_max = src.end();
   while (u2 < u2_max) {
     signed char u8;
     if (u2->h) {  // > 0xFF
       // XXX 4-byte haven't implemented yet.
       if (u2->h >= 0x08) {  // >= 0x800 (3-byte UTF-8 character)
         u8 = 0xe0 + (u2->h >> 4);
         dest.push_back(u8);
         u8 = 0x80 + ((u2->h & 0xf) << 2) + (u2->l >> 6);
         dest.push_back(u8);
         u8 = 0x80 + (u2->l & 0x3f);
         dest.push_back(u8);
       } else {  // < 0x800 (2-byte UTF-8 character)
         u8 = 0xc0 + (u2->h << 2) + (u2->l >> 6);
         dest.push_back(u8);
         u8 = 0x80 + (u2->l & 0x3f);
         dest.push_back(u8);
       }
     } else {               // <= 0xFF
       if (u2->l & 0x80) {  // >0x80 (2-byte UTF-8 character)
         u8 = 0xc0 + (u2->l >> 6);
         dest.push_back(u8);
         u8 = 0x80 + (u2->l & 0x3f);
         dest.push_back(u8);
       } else {  // < 0x80 (1-byte UTF-8 character)
         u8 = u2->l;
         dest.push_back(u8);
       }
     }
     ++u2;
   }
   return dest;
 }
@@ -165,102 +164,101 @@ std::string& u16_u8(std::string& dest, const std::vector<w_char>& src) {
 int u8_u16(std::vector<w_char>& dest, const std::string& src, bool only_convert_first_letter) {
   // faster to oversize initially, assign to elements and resize to what's used
   // than to reserve and push_back
   dest.resize(only_convert_first_letter ? 1 : src.size());
-  std::vector<w_char>::iterator u16 = dest.begin();
-  std::string::const_iterator u8 = src.begin();
-  std::string::const_iterator u8_max = src.end();
+  auto u16 = dest.begin();
+  auto u8 = src.begin(), u8_max = src.end();
 
   while (u8 < u8_max) {
     w_char u2;
     switch ((*u8) & 0xf0) {
       case 0x00:
       case 0x10:
       case 0x20:
       case 0x30:
       case 0x40:
       case 0x50:
       case 0x60:
       case 0x70: {
         u2.h = 0;
         u2.l = *u8;
         break;
       }
       case 0x80:
       case 0x90:
       case 0xa0:
       case 0xb0: {
         HUNSPELL_WARNING(stderr,
                          "UTF-8 encoding error. Unexpected continuation bytes "
                          "in %ld. character position\n%s\n",
                          static_cast<long>(std::distance(src.begin(), u8)),
                          src.c_str());
         u2.h = 0xff;
         u2.l = 0xfd;
         break;
       }
       case 0xc0:
       case 0xd0: {  // 2-byte UTF-8 codes
         if ((*(u8 + 1) & 0xc0) == 0x80) {
           u2.h = (*u8 & 0x1f) >> 2;
           u2.l = (static_cast<unsigned char>(*u8) << 6) + (*(u8 + 1) & 0x3f);
           ++u8;
         } else {
           HUNSPELL_WARNING(stderr,
                            "UTF-8 encoding error. Missing continuation byte in "
                            "%ld. character position:\n%s\n",
                            static_cast<long>(std::distance(src.begin(), u8)),
                            src.c_str());
           u2.h = 0xff;
           u2.l = 0xfd;
         }
         break;
       }
       case 0xe0: {  // 3-byte UTF-8 codes
         if ((*(u8 + 1) & 0xc0) == 0x80) {
           u2.h = ((*u8 & 0x0f) << 4) + ((*(u8 + 1) & 0x3f) >> 2);
           ++u8;
           if ((*(u8 + 1) & 0xc0) == 0x80) {
             u2.l = (static_cast<unsigned char>(*u8) << 6) + (*(u8 + 1) & 0x3f);
             ++u8;
           } else {
             HUNSPELL_WARNING(stderr,
                              "UTF-8 encoding error. Missing continuation byte "
                              "in %ld. character position:\n%s\n",
                              static_cast<long>(std::distance(src.begin(), u8)),
                              src.c_str());
             u2.h = 0xff;
             u2.l = 0xfd;
           }
         } else {
           HUNSPELL_WARNING(stderr,
                            "UTF-8 encoding error. Missing continuation byte in "
                            "%ld. character position:\n%s\n",
                            static_cast<long>(std::distance(src.begin(), u8)),
                            src.c_str());
           u2.h = 0xff;
           u2.l = 0xfd;
         }
         break;
       }
       default: {  // 4 or more byte UTF-8 codes
         assert(((*u8) & 0xf0) == 0xf0 && "can only be 0xf0");
         HUNSPELL_WARNING(stderr,
                          "This UTF-8 encoding can't convert to UTF-16:\n%s\n",
                          src.c_str());
         u2.h = 0xff;
         u2.l = 0xfd;
         *u16++ = u2;
         dest.resize(u16 - dest.begin());
         return -1;
       }
     }
     *u16++ = u2;
     if (only_convert_first_letter)
         break;
     ++u8;
   }
 
   int size = u16 - dest.begin();
   dest.resize(size);
   return size;
 }
@@ -269,31 +267,31 @@ namespace {
 class is_any_of {
  public:
   explicit is_any_of(const std::string& in) : chars(in) {}
 
-  bool operator()(char c) { return chars.find(c) != std::string::npos; }
+  bool operator()(char c) const { return chars.find(c) != std::string::npos; }
 
  private:
   std::string chars;
 };
 }
 
 std::string::const_iterator mystrsep(const std::string &str,
                                      std::string::const_iterator& start) {
-  std::string::const_iterator end = str.end();
+  auto end = str.end();
 
   is_any_of op(" \t");
   // don't use isspace() here, the string can be in some random charset
   // that's way different than the locale's
-  std::string::const_iterator sp = start;
+  auto sp = start;
   while (sp != end && op(*sp))
       ++sp;
 
-  std::string::const_iterator dp = sp;
+  auto dp = sp;
   while (dp != end && !op(*dp))
       ++dp;
 
   start = dp;
   return sp;
 }
 
 // remove cross-platform text line end characters
@@ -353,41 +351,41 @@ void line_uniq(std::string& text, char breakchar)
 // uniq and boundary for compound analysis: "1\n\2\n\1" -> " ( \1 | \2 ) "
 void line_uniq_app(std::string& text, char breakchar) {
   if (text.find(breakchar) == std::string::npos) {
     return;
   }
 
   std::vector<std::string> lines = line_tok(text, breakchar);
   text.clear();
   if (lines.empty()) {
     return;
   }
   text = lines[0];
   for (size_t i = 1; i < lines.size(); ++i) {
     bool dup = false;
     for (size_t j = 0; j < i; ++j) {
       if (lines[i] == lines[j]) {
         dup = true;
         break;
       }
     }
     if (!dup) {
       if (!text.empty())
         text.push_back(breakchar);
       text.append(lines[i]);
     }
   }
 
   if (lines.size() == 1) {
     text = lines[0];
     return;
   }
 
   text.assign(" ( ");
-  for (size_t i = 0; i < lines.size(); ++i) {
-      text.append(lines[i]);
-      text.append(" | ");
+  for (auto& line : lines) {
+    text.append(line);
+    text.append(" | ");
   }
   text[text.size() - 2] = ')';  // " ) "
 }
 
 // append s to ends of every lines in text
@@ -413,20 +411,19 @@ int fieldlen(const char* r) {
 bool copy_field(std::string& dest,
                 const std::string& morph,
                 const std::string& var) {
   if (morph.empty())
     return false;
   size_t pos = morph.find(var);
   if (pos == std::string::npos)
     return false;
   dest.clear();
   std::string beg(morph.substr(pos + MORPH_TAG_LEN, std::string::npos));
 
-  for (size_t i = 0; i < beg.size(); ++i) {
-    const char c(beg[i]);
-    if (c == ' ' || c == '\t' || c == '\n')
+  for (const char c : beg) {
+	if (c == ' ' || c == '\t' || c == '\n')
       break;
     dest.push_back(c);
   }
 
   return true;
 }
@@ -614,30 +611,30 @@ w_char lower_utf(w_char u, int langnum) {
 
 // convert std::string to all caps
 std::string& mkallcap(std::string& s, const struct cs_info* csconv) {
-  for (std::string::iterator aI = s.begin(), aEnd = s.end(); aI != aEnd; ++aI) {
-    *aI = cupper(csconv, static_cast<unsigned char>(*aI));
+  for (char& aI : s) {
+    aI = cupper(csconv, static_cast<unsigned char>(aI));
   }
   return s;
 }
 
 // convert std::string to all little
 std::string& mkallsmall(std::string& s, const struct cs_info* csconv) {
-  for (std::string::iterator aI = s.begin(), aEnd = s.end(); aI != aEnd; ++aI) {
-    *aI = clower(csconv, static_cast<unsigned char>(*aI));
+  for (char& aI : s) {
+    aI = clower(csconv, static_cast<unsigned char>(aI));
   }
   return s;
 }
 
 std::vector<w_char>& mkallsmall_utf(std::vector<w_char>& u, int langnum) {
-  for (size_t i = 0; i < u.size(); ++i) {
-	u[i] = lower_utf(u[i], langnum);
+  for (auto& i : u) {
+    i = lower_utf(i, langnum);
   }
   return u;
 }
 
 std::vector<w_char>& mkallcap_utf(std::vector<w_char>& u, int langnum) {
-  for (size_t i = 0; i < u.size(); i++) {
-	u[i] = upper_utf(u[i], langnum);
+  for (auto& i : u) {
+    i = upper_utf(i, langnum);
   }
   return u;
 }
@@ -2329,28 +2326,27 @@ static void toAsciiLowerAndRemoveNonAlphanumeric(const char* pName,
 struct cs_info* get_current_cs(const std::string& es) {
   char* normalized_encoding = new char[es.size() + 1];
   toAsciiLowerAndRemoveNonAlphanumeric(es.c_str(), normalized_encoding);
 
   struct cs_info* ccs = NULL;
-  int n = sizeof(encds) / sizeof(encds[0]);
-  for (int i = 0; i < n; i++) {
-    if (strcmp(normalized_encoding, encds[i].enc_name) == 0) {
-      ccs = encds[i].cs_table;
+  for (const auto& encd : encds) {
+    if (strcmp(normalized_encoding, encd.enc_name) == 0) {
+      ccs = encd.cs_table;
       break;
     }
   }
 
   delete[] normalized_encoding;
 
   if (!ccs) {
     HUNSPELL_WARNING(stderr,
                      "error: unknown encoding %s: using %s as fallback\n", es.c_str(),
                      encds[0].enc_name);
     ccs = encds[0].cs_table;
   }
 
   return ccs;
 }
 #else
 // XXX This function was rewritten for mozilla. Instead of storing the
 // conversion tables static in this file, create them when needed
 // with help the mozilla backend.
@@ -2480,11 +2476,10 @@ static struct lang_map lang2enc[] =
      {"ru", LANG_ru},    {"uk", LANG_uk}};
 
 int get_lang_num(const std::string& lang) {
-  int n = sizeof(lang2enc) / sizeof(lang2enc[0]);
-  for (int i = 0; i < n; i++) {
-    if (strcmp(lang.c_str(), lang2enc[i].lang) == 0) {
-      return lang2enc[i].num;
+  for (const auto& i : lang2enc) {
+    if (strcmp(lang.c_str(), i.lang) == 0) {
+      return i.num;
     }
   }
   return LANG_xx;
 }
@@ -2534,32 +2529,32 @@ int unicodeisalpha(unsigned short c) {
 /* get type of capitalization */
 int get_captype(const std::string& word, cs_info* csconv) {
   // now determine the capitalization type of the first nl letters
   size_t ncap = 0;
   size_t nneutral = 0;
   size_t firstcap = 0;
   if (csconv == NULL)
     return NOCAP;
-  for (std::string::const_iterator q = word.begin(); q != word.end(); ++q) {
-    unsigned char nIndex = static_cast<unsigned char>(*q);
+  for (auto q = word.begin(); q != word.end(); ++q) {
+    const auto nIndex = static_cast<unsigned char>(*q);
     if (ccase(csconv, nIndex))
       ncap++;
     if (cupper(csconv, nIndex) == clower(csconv, nIndex))
       nneutral++;
   }
   if (ncap) {
-    unsigned char nIndex = static_cast<unsigned char>(word[0]);
+    const auto nIndex = static_cast<unsigned char>(word[0]);
     firstcap = csconv[nIndex].ccase;
   }
 
   // now finally set the captype
   if (ncap == 0) {
     return NOCAP;
   } else if ((ncap == 1) && firstcap) {
     return INITCAP;
   } else if ((ncap == word.size()) || ((ncap + nneutral) == word.size())) {
     return ALLCAP;
   } else if ((ncap > 1) && firstcap) {
     return HUHINITCAP;
   }
   return HUHCAP;
 }
@@ -2567,55 +2562,51 @@ int get_captype(const std::string& word, cs_info* csconv) {
 int get_captype_utf8(const std::vector<w_char>& word, int langnum) {
   // now determine the capitalization type of the first nl letters
   size_t ncap = 0;
   size_t nneutral = 0;
   size_t firstcap = 0;
 
-  std::vector<w_char>::const_iterator it = word.begin();
-  std::vector<w_char>::const_iterator it_end = word.end();
+  auto it = word.begin(), it_end = word.end();
   while (it != it_end) {
-    unsigned short idx = (unsigned short)(*it);
-    unsigned short lwridx = unicodetolower(idx, langnum);
+    const auto idx = (unsigned short)*it;
+    const auto lwridx = unicodetolower(idx, langnum);
     if (idx != lwridx)
       ncap++;
     if (unicodetoupper(idx, langnum) == lwridx)
       nneutral++;
     ++it;
   }
   if (ncap) {
-    unsigned short idx = (unsigned short)(word[0]);
+    const auto idx = (unsigned short)word[0];
     firstcap = (idx != unicodetolower(idx, langnum));
   }
 
   // now finally set the captype
   if (ncap == 0) {
     return NOCAP;
   } else if ((ncap == 1) && firstcap) {
     return INITCAP;
   } else if ((ncap == word.size()) || ((ncap + nneutral) == word.size())) {
     return ALLCAP;
   } else if ((ncap > 1) && firstcap) {
     return HUHINITCAP;
   }
   return HUHCAP;
 }
 
 // strip all ignored characters in the string
 size_t remove_ignored_chars_utf(std::string& word,
                                 const std::vector<w_char>& ignored_chars) {
   std::vector<w_char> w;
   std::vector<w_char> w2;
   u8_u16(w, word);
 
-  for (size_t i = 0; i < w.size(); ++i) {
-    if (!std::binary_search(ignored_chars.begin(),
-                            ignored_chars.end(),
-                            w[i])) {
-      w2.push_back(w[i]);
-    }
-  }
+  std::copy_if(w.begin(), w.end(), std::back_inserter(w2), 
+  [&ignored_chars](w_char wc) {
+    return !std::binary_search(ignored_chars.begin(), ignored_chars.end(), wc);
+  });
 
   u16_u8(word, w2);
   return w2.size();
 }
 
 // strip all ignored characters in the string
@@ -2630,32 +2621,31 @@ size_t remove_ignored_chars(std::string& word,
 bool parse_string(const std::string& line, std::string& out, int ln) {
   if (!out.empty()) {
     HUNSPELL_WARNING(stderr, "error: line %d: multiple definitions\n", ln);
     return false;
   }
   int i = 0;
   int np = 0;
-  std::string::const_iterator iter = line.begin();
-  std::string::const_iterator start_piece = mystrsep(line, iter);
+  auto iter = line.begin(), start_piece = mystrsep(line, iter);
   while (start_piece != line.end()) {
     switch (i) {
       case 0: {
         np++;
         break;
       }
       case 1: {
         out.assign(start_piece, iter);
         np++;
         break;
       }
       default:
         break;
     }
     ++i;
      start_piece = mystrsep(line, iter);
   }
   if (np != 2) {
     HUNSPELL_WARNING(stderr, "error: line %d: missing data\n", ln);
     return false;
   }
   return true;
 }
diff --git a/src/hunspell/csutil.hxx b/src/hunspell/csutil.hxx
index 1635543..808087d 100644
--- a/src/hunspell/csutil.hxx
+++ b/src/hunspell/csutil.hxx
@@ -1,129 +1,130 @@
 /* ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
  * Copyright (C) 2002-2022 Németh László
  *
  * The contents of this file are subject to the Mozilla Public License Version
  * 1.1 (the "License"); you may not use this file except in compliance with
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * Hunspell is based on MySpell which is Copyright (C) 2002 Kevin Hendricks.
  *
  * Contributor(s): David Einstein, Davide Prina, Giuseppe Modugno,
  * Gianluca Turconi, Simon Brouwer, Noll János, Bíró Árpád,
  * Goldman Eleonóra, Sarlós Tamás, Bencsáth Boldizsár, Halácsy Péter,
  * Dvornik László, Gefferth András, Nagy Viktor, Varga Dániel, Chris Halls,
  * Rene Engelhard, Bram Moolenaar, Dafydd Jones, Harri Pitkänen
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 /*
  * Copyright 2002 Kevin B. Hendricks, Stratford, Ontario, Canada
  * And Contributors.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  *
  * 3. All modifications to the source code must be clearly marked as
  *    such.  Binary redistributions based on modified source code
  *    must be clearly marked as modified versions in the documentation
  *    and/or other materials provided with the distribution.
  *
  * THIS SOFTWARE IS PROVIDED BY KEVIN B. HENDRICKS AND CONTRIBUTORS
  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
  * KEVIN B. HENDRICKS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
 
 #ifndef CSUTIL_HXX_
 #define CSUTIL_HXX_
 
 #include "hunvisapi.h"
 
 // First some base level utility routines
 
 #include <fstream>
 #include <string>
 #include <vector>
-#include <assert.h>
-#include <string.h>
+#include <cassert>
+#include <cstring>
+#include <algorithm>
 #include "w_char.hxx"
 #include "htypes.hxx"
 
 #ifdef MOZILLA_CLIENT
 #include "nscore.h"  // for mozalloc headers
 #endif
 
 // casing
 #define NOCAP 0
 #define INITCAP 1
 #define ALLCAP 2
 #define HUHCAP 3
 #define HUHINITCAP 4
 
 // default encoding and keystring
 #define SPELL_ENCODING "ISO8859-1"
 #define SPELL_KEYSTRING "qwertyuiop|asdfghjkl|zxcvbnm"
 
 // default morphological fields
 #define MORPH_STEM "st:"
 #define MORPH_ALLOMORPH "al:"
 #define MORPH_POS "po:"
 #define MORPH_DERI_PFX "dp:"
 #define MORPH_INFL_PFX "ip:"
 #define MORPH_TERM_PFX "tp:"
 #define MORPH_DERI_SFX "ds:"
 #define MORPH_INFL_SFX "is:"
 #define MORPH_TERM_SFX "ts:"
 #define MORPH_SURF_PFX "sp:"
 #define MORPH_FREQ "fr:"
 #define MORPH_PHON "ph:"
 #define MORPH_HYPH "hy:"
 #define MORPH_PART "pa:"
 #define MORPH_FLAG "fl:"
 #define MORPH_HENTRY "_H:"
 #define MORPH_TAG_LEN strlen(MORPH_STEM)
 
 #define MSEP_FLD ' '
 #define MSEP_REC '\n'
 #define MSEP_ALT '\v'
 
 // default flags
 #define DEFAULTFLAGS 65510
 #define FORBIDDENWORD 65510
 #define ONLYUPCASEFLAG 65511
 
 // fix long pathname problem of WIN32 by using w_char std::fstream::open override
@@ -270,13 +271,11 @@ LIBHUNSPELL_DLL_EXPORTED char* get_stored_pointer(const char* s);
 // to avoid unnecessary string copies and Unicode conversions
 // we simply check the ignored_chars characters in the word
 // (in the case of UTF-8 encoded strings, "false" means
 // "likely false", if ignored_chars characters are not ASCII)
 inline bool has_no_ignored_chars(const std::string& word,
                             const std::string& ignored_chars) {
-  for (std::string::const_iterator it = ignored_chars.begin(), end = ignored_chars.end(); it != end; ++it)
-    if (word.find(*it) != std::string::npos)
-      return false;
-  return true;
+  return std::all_of(ignored_chars.begin(), ignored_chars.end(), 
+    [&word](char ic) { return word.find(ic) == std::string::npos; });
 }
 
 // hash entry macros
@@ -316,10 +315,9 @@ inline const char* HENTRY_DATA2(
   return ret;
 }
 
-inline char* HENTRY_FIND(struct hentry* h,
-                                                  const char* p) {
+inline char* HENTRY_FIND(struct hentry* h, const char* p) {
   char* data = HENTRY_DATA(h);
   return data ? strstr(data, p) : NULL;
 }
 
 #endif
diff --git a/src/hunspell/filemgr.cxx b/src/hunspell/filemgr.cxx
index 4a754e5..10729ea 100644
--- a/src/hunspell/filemgr.cxx
+++ b/src/hunspell/filemgr.cxx
@@ -1,76 +1,76 @@
 /* ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
  * Copyright (C) 2002-2022 Németh László
  *
  * The contents of this file are subject to the Mozilla Public License Version
  * 1.1 (the "License"); you may not use this file except in compliance with
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * Hunspell is based on MySpell which is Copyright (C) 2002 Kevin Hendricks.
  *
  * Contributor(s): David Einstein, Davide Prina, Giuseppe Modugno,
  * Gianluca Turconi, Simon Brouwer, Noll János, Bíró Árpád,
  * Goldman Eleonóra, Sarlós Tamás, Bencsáth Boldizsár, Halácsy Péter,
  * Dvornik László, Gefferth András, Nagy Viktor, Varga Dániel, Chris Halls,
  * Rene Engelhard, Bram Moolenaar, Dafydd Jones, Harri Pitkänen
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 /*
  * Copyright 2002 Kevin B. Hendricks, Stratford, Ontario, Canada
  * And Contributors.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  *
  * 3. All modifications to the source code must be clearly marked as
  *    such.  Binary redistributions based on modified source code
  *    must be clearly marked as modified versions in the documentation
  *    and/or other materials provided with the distribution.
  *
  * THIS SOFTWARE IS PROVIDED BY KEVIN B. HENDRICKS AND CONTRIBUTORS
  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
  * KEVIN B. HENDRICKS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
 
-#include <stdlib.h>
-#include <string.h>
-#include <stdio.h>
+#include <cstdlib>
+#include <cstring>
+#include <cstdio>
 
 #include "filemgr.hxx"
 #include "csutil.hxx"
diff --git a/src/hunspell/filemgr.hxx b/src/hunspell/filemgr.hxx
index 88fe883..b933f95 100644
--- a/src/hunspell/filemgr.hxx
+++ b/src/hunspell/filemgr.hxx
@@ -1,98 +1,96 @@
 /* ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
  * Copyright (C) 2002-2022 Németh László
  *
  * The contents of this file are subject to the Mozilla Public License Version
  * 1.1 (the "License"); you may not use this file except in compliance with
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * Hunspell is based on MySpell which is Copyright (C) 2002 Kevin Hendricks.
  *
  * Contributor(s): David Einstein, Davide Prina, Giuseppe Modugno,
  * Gianluca Turconi, Simon Brouwer, Noll János, Bíró Árpád,
  * Goldman Eleonóra, Sarlós Tamás, Bencsáth Boldizsár, Halácsy Péter,
  * Dvornik László, Gefferth András, Nagy Viktor, Varga Dániel, Chris Halls,
  * Rene Engelhard, Bram Moolenaar, Dafydd Jones, Harri Pitkänen
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 /*
  * Copyright 2002 Kevin B. Hendricks, Stratford, Ontario, Canada
  * And Contributors.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  *
  * 3. All modifications to the source code must be clearly marked as
  *    such.  Binary redistributions based on modified source code
  *    must be clearly marked as modified versions in the documentation
  *    and/or other materials provided with the distribution.
  *
  * THIS SOFTWARE IS PROVIDED BY KEVIN B. HENDRICKS AND CONTRIBUTORS
  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
  * KEVIN B. HENDRICKS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
 
 /* file manager class - read lines of files [filename] OR [filename.hz] */
 #ifndef FILEMGR_HXX_
 #define FILEMGR_HXX_
 
 #include "hunzip.hxx"
-#include <stdio.h>
+#include <cstdio>
 #include <string>
 #include <fstream>
 
 class FileMgr {
- private:
-  FileMgr(const FileMgr&);
-  FileMgr& operator=(const FileMgr&);
-
  protected:
   std::ifstream fin;
   Hunzip* hin;
   char in[BUFSIZE + 50];  // input buffer
   int fail(const char* err, const char* par);
   int linenum;
 
  public:
   FileMgr(const char* filename, const char* key = NULL);
+  FileMgr(const FileMgr&) = delete;
+  FileMgr& operator=(const FileMgr&) = delete;
   ~FileMgr();
   bool getline(std::string&);
   int getlinenum();
 };
 #endif
diff --git a/src/hunspell/hashmgr.cxx b/src/hunspell/hashmgr.cxx
index f9ddcb5..cde8952 100644
--- a/src/hunspell/hashmgr.cxx
+++ b/src/hunspell/hashmgr.cxx
@@ -1,83 +1,86 @@
 /* ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
  * Copyright (C) 2002-2022 Németh László
  *
  * The contents of this file are subject to the Mozilla Public License Version
  * 1.1 (the "License"); you may not use this file except in compliance with
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * Hunspell is based on MySpell which is Copyright (C) 2002 Kevin Hendricks.
  *
  * Contributor(s): David Einstein, Davide Prina, Giuseppe Modugno,
  * Gianluca Turconi, Simon Brouwer, Noll János, Bíró Árpád,
  * Goldman Eleonóra, Sarlós Tamás, Bencsáth Boldizsár, Halácsy Péter,
  * Dvornik László, Gefferth András, Nagy Viktor, Varga Dániel, Chris Halls,
  * Rene Engelhard, Bram Moolenaar, Dafydd Jones, Harri Pitkänen
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 /*
  * Copyright 2002 Kevin B. Hendricks, Stratford, Ontario, Canada
  * And Contributors.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  *
  * 3. All modifications to the source code must be clearly marked as
  *    such.  Binary redistributions based on modified source code
  *    must be clearly marked as modified versions in the documentation
  *    and/or other materials provided with the distribution.
  *
  * THIS SOFTWARE IS PROVIDED BY KEVIN B. HENDRICKS AND CONTRIBUTORS
  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
  * KEVIN B. HENDRICKS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
 
-#include <stdlib.h>
-#include <string.h>
-#include <stdio.h>
-#include <ctype.h>
+#include <cstdlib>
+#include <cstring>
+#include <cstdio>
+#include <cctype>
 #include <limits>
 #include <sstream>
+#if __cplusplus >= 202002L
+#include <bit>
+#endif
 
 #include "hashmgr.hxx"
 #include "csutil.hxx"
 #include "atypes.hxx"
 #include "langnum.hxx"
 
 // build a hash table from a munched word list
@@ -111,15 +114,14 @@ void HashMgr::free_flag(unsigned short* astr, short alen) {
 void HashMgr::free_table() {
   // now pass through hash table freeing up everything
   // go through column by column of the table
-  for (size_t i = 0; i < tableptr.size(); ++i) {
-    struct hentry* pt = tableptr[i];
-    struct hentry* nt = NULL;
-    while (pt) {
-      nt = pt->next;
-      free_flag(pt->astr, pt->alen);
-      free(pt);
-      pt = nt;
+  for (auto ptr : tableptr) {
+    hentry* nt = NULL;
+    while (ptr) {
+      nt = ptr->next;
+      free_flag(ptr->astr, ptr->alen);
+      free(ptr);
+      ptr = nt;
     }
   }
   tableptr.clear();
 }
@@ -127,17 +129,17 @@ void HashMgr::free_table() {
 HashMgr::~HashMgr() {
   free_table();
 
-  for (size_t j = 0, numaliasf = aliasf.size(); j < numaliasf; ++j)
-    delete[] aliasf[j];
+  for (auto& j : aliasf)
+    delete[] j;
   aliasf.clear();
 
-  for (size_t j = 0, numaliasm = aliasm.size(); j < numaliasm; ++j)
-    delete[] aliasm[j];
+  for (auto& j : aliasm)
+    delete[] j;
   aliasm.clear();
 
 #ifdef MOZILLA_CLIENT
   delete[] csconv;
 #endif
 }
 
 // lookup a root word in the hashtable
@@ -156,259 +158,258 @@ struct hentry* HashMgr::lookup(const char* word, size_t len) const {
 // add a word to the hash table (private)
 int HashMgr::add_word(const std::string& in_word,
                       int wcl,
                       unsigned short* aff,
                       int al,
                       const std::string* in_desc,
                       bool onlyupcase,
                       int captype) {
 
   if (al > std::numeric_limits<short>::max()) {
     HUNSPELL_WARNING(stderr, "error: affix len %d is over max limit\n", al);
     free_flag(aff, al);
     return 1;
   }
 
   const std::string* word = &in_word;
   const std::string* desc = in_desc;
 
   std::string *word_copy = NULL;
   std::string *desc_copy = NULL;
   if ((!ignorechars.empty() && !has_no_ignored_chars(in_word, ignorechars)) || complexprefixes) {
     word_copy = new std::string(in_word);
 
     if (!ignorechars.empty()) {
       if (utf8) {
         wcl = remove_ignored_chars_utf(*word_copy, ignorechars_utf16);
       } else {
         remove_ignored_chars(*word_copy, ignorechars);
       }
     }
 
     if (complexprefixes) {
       if (utf8)
         wcl = reverseword_utf(*word_copy);
       else
         reverseword(*word_copy);
 
       if (in_desc && aliasm.empty()) {
         desc_copy = new std::string(*in_desc);
 
         if (complexprefixes) {
           if (utf8)
             reverseword_utf(*desc_copy);
           else
             reverseword(*desc_copy);
         }
         desc = desc_copy;
       }
     }
 
     word = word_copy;
   }
 
   // limit of hp->blen
   if (word->size() > std::numeric_limits<unsigned char>::max()) {
     HUNSPELL_WARNING(stderr, "error: word len %ld is over max limit\n", word->size());
     delete desc_copy;
     delete word_copy;
     free_flag(aff, al);
     return 1;
   }
 
   bool upcasehomonym = false;
   int descl = desc ? (!aliasm.empty() ? sizeof(char*) : desc->size() + 1) : 0;
   // variable-length hash record with word and optional fields
-  struct hentry* hp =
+  auto hp =
       (struct hentry*)malloc(sizeof(struct hentry) + word->size() + descl);
   if (!hp) {
     delete desc_copy;
     delete word_copy;
     free_flag(aff, al);
     return 1;
   }
 
   char* hpw = hp->word;
   memcpy(hpw, word->data(), word->size());
   hpw[word->size()] = 0;
 
   int i = hash(hpw, word->size());
 
   hp->blen = (unsigned char)word->size();
   hp->clen = (unsigned char)wcl;
   hp->alen = (short)al;
   hp->astr = aff;
   hp->next = NULL;
   hp->next_homonym = NULL;
   hp->var = (captype == INITCAP) ? H_OPT_INITCAP : 0;
 
   // store the description string or its pointer
   if (desc) {
     hp->var |= H_OPT;
     if (!aliasm.empty()) {
       hp->var |= H_OPT_ALIASM;
       store_pointer(hpw + word->size() + 1, get_aliasm(atoi(desc->c_str())));
     } else {
       strcpy(hpw + word->size() + 1, desc->c_str());
     }
     if (HENTRY_FIND(hp, MORPH_PHON)) {
       hp->var |= H_OPT_PHON;
       // store ph: fields (pronounciation, misspellings, old orthography etc.)
       // of a morphological description in reptable to use in REP replacements.
       size_t predicted = tableptr.size() / MORPH_PHON_RATIO;
       if (reptable.capacity() < predicted)
           reptable.reserve(predicted);
       std::string fields = HENTRY_DATA(hp);
-      std::string::const_iterator iter = fields.begin();
-      std::string::const_iterator start_piece = mystrsep(fields, iter);
+      std::string::const_iterator iter = fields.begin(), start_piece = mystrsep(fields, iter);
       while (start_piece != fields.end()) {
         if (std::string(start_piece, iter).find(MORPH_PHON) == 0) {
           std::string ph = std::string(start_piece, iter).substr(sizeof MORPH_PHON - 1);
-          if (ph.size() > 0) {
+          if (!ph.empty()) {
             std::vector<w_char> w;
             size_t strippatt;
             std::string wordpart;
             // dictionary based REP replacement, separated by "->"
             // for example "pretty ph:prity ph:priti->pretti" to handle
             // both prity -> pretty and pritier -> prettiest suggestions.
             if (((strippatt = ph.find("->")) != std::string::npos) &&
                     (strippatt > 0) && (strippatt < ph.size() - 2)) {
                 wordpart = ph.substr(strippatt + 2);
                 ph.erase(ph.begin() + strippatt, ph.end());
             } else
                 wordpart = in_word;
             // when the ph: field ends with the character *,
             // strip last character of the pattern and the replacement
             // to match in REP suggestions also at character changes,
             // for example, "pretty ph:prity*" results "prit->prett"
             // REP replacement instead of "prity->pretty", to get
             // prity->pretty and pritiest->prettiest suggestions.
             if (ph.at(ph.size()-1) == '*') {
               strippatt = 1;
               size_t stripword = 0;
               if (utf8) {
                 while ((strippatt < ph.size()) &&
                   ((ph.at(ph.size()-strippatt-1) & 0xc0) == 0x80))
                      ++strippatt;
                 while ((stripword < wordpart.size()) &&
                   ((wordpart.at(wordpart.size()-stripword-1) & 0xc0) == 0x80))
                      ++stripword;
               }
               ++strippatt;
               ++stripword;
               if ((ph.size() > strippatt) && (wordpart.size() > stripword)) {
                 ph.erase(ph.size()-strippatt, strippatt);
                 wordpart.erase(wordpart.size()-stripword, stripword);
               }
             }
             // capitalize lowercase pattern for capitalized words to support
             // good suggestions also for capitalized misspellings, eg.
             // Wednesday ph:wendsay
             // results wendsay -> Wednesday and Wendsay -> Wednesday, too.
-            if (captype==INITCAP) {
+            if (captype == INITCAP) {
               std::string ph_capitalized;
               if (utf8) {
                 u8_u16(w, ph);
                 if (get_captype_utf8(w, langnum) == NOCAP) {
                   mkinitcap_utf(w, langnum);
                   u16_u8(ph_capitalized, w);
                 }
               } else if (get_captype(ph, csconv) == NOCAP)
                   mkinitcap(ph_capitalized, csconv);
 
-              if (ph_capitalized.size() > 0) {
+              if (!ph_capitalized.empty()) {
                 // add also lowercase word in the case of German or
                 // Hungarian to support lowercase suggestions lowercased by
                 // compound word generation or derivational suffixes
                 // (for example by adjectival suffix "-i" of geographical
                 // names in Hungarian:
                 // Massachusetts ph:messzecsuzec
                 // messzecsuzeci -> massachusettsi (adjective)
                 // For lowercasing by conditional PFX rules, see
                 // tests/germancompounding test example or the
                 // Hungarian dictionary.)
                 if (langnum == LANG_de || langnum == LANG_hu) {
                   std::string wordpart_lower(wordpart);
                   if (utf8) {
                     u8_u16(w, wordpart_lower);
                     mkallsmall_utf(w, langnum);
                     u16_u8(wordpart_lower, w);
                   } else {
                     mkallsmall(wordpart_lower, csconv);
                   }
-                  reptable.push_back(replentry());
+                  reptable.emplace_back();
                   reptable.back().pattern.assign(ph);
                   reptable.back().outstrings[0].assign(wordpart_lower);
                 }
-                reptable.push_back(replentry());
+                reptable.emplace_back();
                 reptable.back().pattern.assign(ph_capitalized);
                 reptable.back().outstrings[0].assign(wordpart);
               }
             }
-            reptable.push_back(replentry());
+            reptable.emplace_back();
             reptable.back().pattern.assign(ph);
             reptable.back().outstrings[0].assign(wordpart);
           }
         }
         start_piece = mystrsep(fields, iter);
       }
     }
   }
 
   struct hentry* dp = tableptr[i];
   if (!dp) {
     tableptr[i] = hp;
     delete desc_copy;
     delete word_copy;
     return 0;
   }
   while (dp->next != NULL) {
     if ((!dp->next_homonym) && (strcmp(hp->word, dp->word) == 0)) {
       // remove hidden onlyupcase homonym
       if (!onlyupcase) {
         if ((dp->astr) && TESTAFF(dp->astr, ONLYUPCASEFLAG, dp->alen)) {
           delete[] dp->astr;
           dp->astr = hp->astr;
           dp->alen = hp->alen;
           free(hp);
           delete desc_copy;
           delete word_copy;
           return 0;
         } else {
           dp->next_homonym = hp;
         }
       } else {
         upcasehomonym = true;
       }
     }
     dp = dp->next;
   }
   if (strcmp(hp->word, dp->word) == 0) {
     // remove hidden onlyupcase homonym
     if (!onlyupcase) {
       if ((dp->astr) && TESTAFF(dp->astr, ONLYUPCASEFLAG, dp->alen)) {
         delete[] dp->astr;
         dp->astr = hp->astr;
         dp->alen = hp->alen;
         free(hp);
         delete desc_copy;
         delete word_copy;
         return 0;
       } else {
         dp->next_homonym = hp;
       }
     } else {
       upcasehomonym = true;
     }
   }
   if (!upcasehomonym) {
     dp->next = hp;
   } else {
     // remove hidden onlyupcase homonym
     delete[] hp->astr;
     free(hp);
   }
 
   delete desc_copy;
   delete word_copy;
   return 0;
 }
@@ -474,20 +475,20 @@ int HashMgr::get_clen_and_captype(const std::string& word, int* captype) {
 // remove word (personal dictionary function for standalone applications)
 int HashMgr::remove(const std::string& word) {
   struct hentry* dp = lookup(word.c_str(), word.size());
   while (dp) {
     if (dp->alen == 0 || !TESTAFF(dp->astr, forbiddenword, dp->alen)) {
-      unsigned short* flags = new unsigned short[dp->alen + 1];
+      auto flags = new unsigned short[dp->alen + 1];
       for (int i = 0; i < dp->alen; i++)
         flags[i] = dp->astr[i];
       flags[dp->alen] = forbiddenword;
       delete[] dp->astr;
       dp->astr = flags;
       dp->alen++;
       std::sort(flags, flags + dp->alen);
     }
     dp = dp->next_homonym;
   }
   return 0;
 }
 
 /* remove forbidden flag to add a personal word to the hash */
@@ -506,13 +507,12 @@ int HashMgr::remove_forbidden_flag(const std::string& word) {
 // add a custom dic. word to the hash table (public)
 int HashMgr::add(const std::string& word) {
   if (remove_forbidden_flag(word)) {
-    int captype;
-    int al = 0;
+    int captype, al = 0;
     unsigned short* flags = NULL;
     int wcl = get_clen_and_captype(word, &captype);
     add_word(word, wcl, flags, al, NULL, false, captype);
     return add_hidden_capitalized_word(word, wcl, flags, al, NULL,
                                        captype);
   }
   return 0;
 }
@@ -520,23 +520,22 @@ int HashMgr::add(const std::string& word) {
 int HashMgr::add_with_affix(const std::string& word, const std::string& example) {
   // detect captype and modify word length for UTF-8 encoding
   struct hentry* dp = lookup(example.c_str(), example.size());
   remove_forbidden_flag(word);
   if (dp && dp->astr) {
     int captype;
     int wcl = get_clen_and_captype(word, &captype);
     if (!aliasf.empty()) {
       add_word(word, wcl, dp->astr, dp->alen, NULL, false, captype);
     } else {
-      unsigned short* flags = new unsigned short[dp->alen];
-      memcpy((void*)flags, (void*)dp->astr,
-             dp->alen * sizeof(unsigned short));
+      auto flags = new unsigned short[dp->alen];
+      memcpy(flags, dp->astr, dp->alen * sizeof(unsigned short));
       add_word(word, wcl, flags, dp->alen, NULL, false, captype);
     }
     return add_hidden_capitalized_word(word, wcl, dp->astr,
                                        dp->alen, NULL, captype);
   }
   return 1;
 }
 
 // walk the hash table entry by entry - null at end
 // initialize: col=-1; hp = NULL; hp = walk_hashtable(&col, hp);
@@ -555,136 +554,136 @@ struct hentry* HashMgr::walk_hashtable(int& col, struct hentry* hp) const {
 // load a munched word list and build a hash table on the fly
 int HashMgr::load_tables(const char* tpath, const char* key) {
   // open dictionary file
   FileMgr* dict = new FileMgr(tpath, key);
   if (dict == NULL)
     return 1;
 
   // first read the first line of file to get hash table size
   std::string ts;
   if (!dict->getline(ts)) {
     HUNSPELL_WARNING(stderr, "error: empty dic file %s\n", tpath);
     delete dict;
     return 2;
   }
   mychomp(ts);
 
   /* remove byte order mark */
   if (ts.compare(0, 3, "\xEF\xBB\xBF", 3) == 0) {
     ts.erase(0, 3);
   }
 
   int tablesize = atoi(ts.c_str());
 
   const int nExtra = 5 + USERWORD;
 #if !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
   const int max_allowed = (std::numeric_limits<int>::max() - 1 - nExtra) / int(sizeof(struct hentry*));
 #else
   const int max_allowed = (268435456 - 1 - nExtra) / int(sizeof(struct hentry*));
 #endif
 
   if (tablesize <= 0 || tablesize >= max_allowed) {
     HUNSPELL_WARNING(
         stderr, "error: line 1: missing or bad word count in the dic file\n");
     delete dict;
     return 4;
   }
   tablesize += nExtra;
   if ((tablesize & 1) == 0)
     tablesize++;
 
   // allocate the hash table
   tableptr.resize(tablesize, nullptr);
 
   // loop through all words on much list and add to hash
   // table and create word and affix strings
 
   std::vector<w_char> workbuf;
 
   while (dict->getline(ts)) {
     mychomp(ts);
     // split each line into word and morphological description
     size_t dp_pos = 0;
     while ((dp_pos = ts.find(':', dp_pos)) != std::string::npos) {
       if ((dp_pos > 3) && (ts[dp_pos - 3] == ' ' || ts[dp_pos - 3] == '\t')) {
         for (dp_pos -= 3; dp_pos > 0 && (ts[dp_pos-1] == ' ' || ts[dp_pos-1] == '\t'); --dp_pos)
           ;
         if (dp_pos == 0) {  // missing word
           dp_pos = std::string::npos;
         } else {
           ++dp_pos;
         }
         break;
       }
       ++dp_pos;
     }
 
     // tabulator is the old morphological field separator
     size_t dp2_pos = ts.find('\t');
     if (dp2_pos != std::string::npos && (dp_pos == std::string::npos || dp2_pos < dp_pos)) {
       dp_pos = dp2_pos + 1;
     }
 
     std::string dp;
     if (dp_pos != std::string::npos) {
       dp.assign(ts.substr(dp_pos));
       ts.resize(dp_pos - 1);
     }
 
     // split each line into word and affix char strings
     // "\/" signs slash in words (not affix separator)
     // "/" at beginning of the line is word character (not affix separator)
     size_t ap_pos = ts.find('/');
     while (ap_pos != std::string::npos) {
       if (ap_pos == 0) {
         ++ap_pos;
         continue;
       } else if (ts[ap_pos - 1] != '\\')
         break;
       // replace "\/" with "/"
       ts.erase(ap_pos - 1, 1);
       ap_pos = ts.find('/', ap_pos);
     }
 
     unsigned short* flags;
     int al;
     if (ap_pos != std::string::npos && ap_pos != ts.size()) {
       std::string ap(ts.substr(ap_pos + 1));
       ts.resize(ap_pos);
       if (!aliasf.empty()) {
         int index = atoi(ap.c_str());
         al = get_aliasf(index, &flags, dict);
         if (!al) {
           HUNSPELL_WARNING(stderr, "error: line %d: bad flag vector alias\n",
                            dict->getlinenum());
         }
       } else {
-        al = decode_flags(&flags, ap.c_str(), dict);
+        al = decode_flags(&flags, ap, dict);
         if (al == -1) {
           HUNSPELL_WARNING(stderr, "Can't allocate memory.\n");
           delete dict;
           return 6;
         }
         std::sort(flags, flags + al);
       }
     } else {
       al = 0;
       flags = NULL;
     }
 
     int captype;
     int wcl = get_clen_and_captype(ts, &captype, workbuf);
     const std::string *dp_str = dp.empty() ? NULL : &dp;
     // add the word and its index plus its capitalized form optionally
     if (add_word(ts, wcl, flags, al, dp_str, false, captype) ||
         add_hidden_capitalized_word(ts, wcl, flags, al, dp_str, captype)) {
       delete dict;
       return 5;
     }
   }
 
   delete dict;
   return 0;
 }
 
 // the hash function is a simple load and rotate
 // algorithm borrowed
@@ -703,91 +702,85 @@ int HashMgr::hash(const char* word, size_t len) const {
 int HashMgr::decode_flags(unsigned short** result, const std::string& flags, FileMgr* af) const {
   int len;
   if (flags.empty()) {
     *result = NULL;
     return 0;
   }
   switch (flag_mode) {
     case FLAG_LONG: {  // two-character flags (1x2yZz -> 1x 2y Zz)
       len = flags.size();
       if ((len & 1) == 1)
         HUNSPELL_WARNING(stderr, "error: line %d: bad flagvector\n",
                          af->getlinenum());
       len >>= 1;
       *result = new unsigned short[len];
       for (int i = 0; i < len; i++) {
         unsigned short flag = ((unsigned short)((unsigned char)flags[i << 1]) << 8) |
                               ((unsigned short)((unsigned char)flags[(i << 1) | 1]));
 
         if (flag >= DEFAULTFLAGS) {
           HUNSPELL_WARNING(stderr,
                            "error: line %d: flag id %d is too large (max: %d)\n",
                            af->getlinenum(), flag, DEFAULTFLAGS - 1);
           flag = 0;
         }
 
         (*result)[i] = flag;
       }
       break;
     }
     case FLAG_NUM: {  // decimal numbers separated by comma (4521,23,233 -> 4521
                       // 23 233)
-      len = 1;
-      unsigned short* dest;
-      for (size_t i = 0; i < flags.size(); ++i) {
-        if (flags[i] == ',')
-          len++;
-      }
+      len = int(1 + std::count_if(flags.begin(), flags.end(), [](char c) { return c == ','; }));
       *result = new unsigned short[len];
-      dest = *result;
+      unsigned short* dest = *result;
       const char* src = flags.c_str();
       for (size_t p = 0; p < flags.size(); ++p) {
         if (flags[p] == ',') {
           int i = atoi(src);
           if (i >= DEFAULTFLAGS) {
             HUNSPELL_WARNING(
                 stderr, "error: line %d: flag id %d is too large (max: %d)\n",
                 af->getlinenum(), i, DEFAULTFLAGS - 1);
              i = 0;
 	  }
           *dest = (unsigned short)i;
           if (*dest == 0)
             HUNSPELL_WARNING(stderr, "error: line %d: 0 is wrong flag id\n",
                              af->getlinenum());
           src = flags.c_str() + p + 1;
           dest++;
         }
       }
       int i = atoi(src);
       if (i >= DEFAULTFLAGS) {
         HUNSPELL_WARNING(stderr,
                          "error: line %d: flag id %d is too large (max: %d)\n",
                          af->getlinenum(), i, DEFAULTFLAGS - 1);
         i = 0;
       }
       *dest = (unsigned short)i;
       if (*dest == 0)
         HUNSPELL_WARNING(stderr, "error: line %d: 0 is wrong flag id\n",
                          af->getlinenum());
       break;
     }
     case FLAG_UNI: {  // UTF-8 characters
       std::vector<w_char> w;
       u8_u16(w, flags);
       len = w.size();
       *result = new unsigned short[len];
       memcpy(*result, w.data(), len * sizeof(short));
       break;
     }
     default: {  // Ispell's one-character flags (erfg -> e r f g)
-      unsigned short* dest;
-      len = flags.size();
+	  len = flags.size();
       *result = new unsigned short[len];
-      dest = *result;
-      for (size_t i = 0; i < flags.size(); ++i) {
-        *dest = (unsigned char)flags[i];
+      unsigned short* dest = *result;
+      for (const char flag : flags) {
+        *dest = (unsigned char)flag;
         dest++;
       }
     }
   }
   return len;
 }
@@ -795,68 +788,67 @@ int HashMgr::decode_flags(unsigned short** result, const std::string& flags, Fil
 bool HashMgr::decode_flags(std::vector<unsigned short>& result, const std::string& flags, FileMgr* af) const {
   if (flags.empty()) {
     return false;
   }
   switch (flag_mode) {
     case FLAG_LONG: {  // two-character flags (1x2yZz -> 1x 2y Zz)
       size_t len = flags.size();
       if ((len & 1) == 1)
         HUNSPELL_WARNING(stderr, "error: line %d: bad flagvector\n",
                          af->getlinenum());
       len >>= 1;
       result.reserve(result.size() + len);
       for (size_t i = 0; i < len; ++i) {
         result.push_back(((unsigned short)((unsigned char)flags[i << 1]) << 8) |
 		                 ((unsigned short)((unsigned char)flags[(i << 1) | 1])));
       }
       break;
     }
     case FLAG_NUM: {  // decimal numbers separated by comma (4521,23,233 -> 4521
                       // 23 233)
       const char* src = flags.c_str();
       for (const char* p = src; *p; p++) {
         if (*p == ',') {
           int i = atoi(src);
           if (i >= DEFAULTFLAGS) {
             HUNSPELL_WARNING(
                 stderr, "error: line %d: flag id %d is too large (max: %d)\n",
                 af->getlinenum(), i, DEFAULTFLAGS - 1);
             i = 0;
 	  }
           result.push_back((unsigned short)i);
           if (result.back() == 0)
             HUNSPELL_WARNING(stderr, "error: line %d: 0 is wrong flag id\n",
                              af->getlinenum());
           src = p + 1;
         }
       }
       int i = atoi(src);
       if (i >= DEFAULTFLAGS) {
         HUNSPELL_WARNING(stderr,
                          "error: line %d: flag id %d is too large (max: %d)\n",
                          af->getlinenum(), i, DEFAULTFLAGS - 1);
         i = 0;
       }
       result.push_back((unsigned short)i);
       if (result.back() == 0)
         HUNSPELL_WARNING(stderr, "error: line %d: 0 is wrong flag id\n",
                          af->getlinenum());
       break;
     }
     case FLAG_UNI: {  // UTF-8 characters
       std::vector<w_char> w;
       u8_u16(w, flags);
-      size_t len = w.size();
-      size_t origsize = result.size();
+      size_t len = w.size(), origsize = result.size();
       result.resize(origsize + len);
       memcpy(result.data() + origsize, w.data(), len * sizeof(short));
       break;
     }
     default: {  // Ispell's one-character flags (erfg -> e r f g)
       result.reserve(flags.size());
-      for (size_t i = 0; i < flags.size(); ++i) {
-        result.push_back((unsigned char)flags[i]);
+      for (const char flag : flags) {
+        result.push_back((unsigned char)flag);
       }
     }
   }
   return true;
 }
@@ -895,22 +887,37 @@ unsigned short HashMgr::decode_flag(const std::string& f) const {
 std::string HashMgr::encode_flag(unsigned short f) const {
   if (f == 0)
     return "(NULL)";
   std::string ch;
   if (flag_mode == FLAG_LONG) {
     ch.push_back((unsigned char)(f >> 8));
     ch.push_back((unsigned char)(f - ((f >> 8) << 8)));
   } else if (flag_mode == FLAG_NUM) {
     std::ostringstream stream;
     stream << f;
     ch = stream.str();
   } else if (flag_mode == FLAG_UNI) {
-    const w_char* w_c = (const w_char*)&f;
-    std::vector<w_char> w(w_c, w_c + 1);
+
+#if defined(__i386__) || defined(_M_IX86) || defined(_M_X64)
+
+#if __cplusplus >= 202002L
+    auto wc = std::bit_cast<w_char>(f);
+#else
+    w_char wc;
+    memcpy(&wc, &f, sizeof(unsigned short));
+#endif
+
+#else
+    w_char wc;
+    wc.h = (unsigned char)(f >> 8);
+    wc.l = (unsigned char)(f & 0xff);
+#endif
+    //const w_char* w_c = (const w_char*)&f; <- this will not work properly on big endian architecture 
+    const std::vector<w_char> w = { wc };
     u16_u8(ch, w);
   } else {
     ch.push_back((unsigned char)(f));
   }
   return ch;
 }
 
 // read in aff file and set flag mode
@@ -1040,96 +1047,93 @@ int HashMgr::load_config(const char* affpath, const char* key) {
 /* parse in the ALIAS table */
 bool HashMgr::parse_aliasf(const std::string& line, FileMgr* af) {
   if (!aliasf.empty()) {
     HUNSPELL_WARNING(stderr, "error: line %d: multiple table definitions\n",
                      af->getlinenum());
     return false;
   }
-  int i = 0;
-  int np = 0;
-  int numaliasf = 0;
-  std::string::const_iterator iter = line.begin();
-  std::string::const_iterator start_piece = mystrsep(line, iter);
+  int i = 0, np = 0, numaliasf = 0;
+  auto iter = line.begin(), start_piece = mystrsep(line, iter);
   while (start_piece != line.end()) {
     switch (i) {
       case 0: {
         np++;
         break;
       }
       case 1: {
         numaliasf = atoi(std::string(start_piece, iter).c_str());
         if (numaliasf < 1) {
           aliasf.clear();
           aliasflen.clear();
           HUNSPELL_WARNING(stderr, "error: line %d: bad entry number\n",
                            af->getlinenum());
           return false;
         }
         aliasf.reserve(std::min(numaliasf, 16384));
         aliasflen.reserve(std::min(numaliasf, 16384));
         np++;
         break;
       }
       default:
         break;
     }
     ++i;
     start_piece = mystrsep(line, iter);
   }
   if (np != 2) {
     aliasf.clear();
     aliasflen.clear();
     HUNSPELL_WARNING(stderr, "error: line %d: missing data\n",
                      af->getlinenum());
     return false;
   }
 
   /* now parse the numaliasf lines to read in the remainder of the table */
   for (int j = 0; j < numaliasf; ++j) {
     std::string nl;
     unsigned short* alias = NULL;
     unsigned aliaslen = 0;
     i = 0;
     if (af->getline(nl)) {
       mychomp(nl);
       iter = nl.begin();
       start_piece = mystrsep(nl, iter);
       bool errored = false;
       while (!errored && start_piece != nl.end()) {
         switch (i) {
           case 0: {
             if (nl.compare(start_piece - nl.begin(), 2, "AF", 2) != 0) {
               errored = true;
               break;
             }
             break;
           }
           case 1: {
             std::string piece(start_piece, iter);
             aliaslen =
                 (unsigned short)decode_flags(&alias, piece, af);
             std::sort(alias, alias + aliaslen);
             break;
           }
           default:
             break;
         }
         ++i;
         start_piece = mystrsep(nl, iter);
       }
     }
     if (!alias) {
       for (int k = 0; k < j; ++k) {
         delete[] aliasf[k];
       }
       aliasf.clear();
       aliasflen.clear();
       HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n",
                        af->getlinenum());
       return false;
     }
 
     aliasf.push_back(alias);
     aliasflen.push_back(aliaslen);
   }
   return true;
 }
@@ -1152,96 +1156,93 @@ int HashMgr::get_aliasf(int index, unsigned short** fvec, FileMgr* af) const {
 /* parse morph alias definitions */
 bool HashMgr::parse_aliasm(const std::string& line, FileMgr* af) {
   if (!aliasm.empty()) {
     HUNSPELL_WARNING(stderr, "error: line %d: multiple table definitions\n",
                      af->getlinenum());
     return false;
   }
-  int i = 0;
-  int np = 0;
-  int numaliasm = 0;
-  std::string::const_iterator iter = line.begin();
-  std::string::const_iterator start_piece = mystrsep(line, iter);
+  int i = 0, np = 0, numaliasm = 0;
+  auto iter = line.begin(), start_piece = mystrsep(line, iter);
   while (start_piece != line.end()) {
     switch (i) {
       case 0: {
         np++;
         break;
       }
       case 1: {
         numaliasm = atoi(std::string(start_piece, iter).c_str());
         if (numaliasm < 1) {
           HUNSPELL_WARNING(stderr, "error: line %d: bad entry number\n",
                            af->getlinenum());
           return false;
         }
         aliasm.reserve(std::min(numaliasm, 16384));
         np++;
         break;
       }
       default:
         break;
     }
     ++i;
     start_piece = mystrsep(line, iter);
   }
   if (np != 2) {
     aliasm.clear();
     HUNSPELL_WARNING(stderr, "error: line %d: missing data\n",
                      af->getlinenum());
     return false;
   }
 
   /* now parse the numaliasm lines to read in the remainder of the table */
   for (int j = 0; j < numaliasm; ++j) {
     std::string nl;
     char* alias = NULL;
     if (af->getline(nl)) {
       mychomp(nl);
       iter = nl.begin();
       i = 0;
       start_piece = mystrsep(nl, iter);
       bool errored = false;
       while (!errored && start_piece != nl.end()) {
         switch (i) {
           case 0: {
             if (nl.compare(start_piece - nl.begin(), 2, "AM", 2) != 0) {
               errored = true;
               break;
             }
             break;
           }
           case 1: {
             // add the remaining of the line
             std::string::const_iterator end = nl.end();
             std::string chunk(start_piece, end);
             if (complexprefixes) {
               if (utf8)
                 reverseword_utf(chunk);
               else
                 reverseword(chunk);
             }
             size_t sl = chunk.size() + 1;
             alias = new char[sl];
             memcpy(alias, chunk.c_str(), sl);
             break;
           }
           default:
             break;
         }
         ++i;
         start_piece = mystrsep(nl, iter);
       }
     }
     if (!alias) {
       for (int k = 0; k < j; ++k) {
         delete[] aliasm[k];
       }
       aliasm.clear();
       HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n",
                        af->getlinenum());
       return false;
     }
     aliasm.push_back(alias);
   }
   return true;
 }
@@ -1260,95 +1261,92 @@ char* HashMgr::get_aliasm(int index) const {
 /* parse in the typical fault correcting table */
 bool HashMgr::parse_reptable(const std::string& line, FileMgr* af) {
   if (!reptable.empty()) {
     HUNSPELL_WARNING(stderr, "error: line %d: multiple table definitions\n",
                      af->getlinenum());
     return false;
   }
-  int numrep = -1;
-  int i = 0;
-  int np = 0;
-  std::string::const_iterator iter = line.begin();
-  std::string::const_iterator start_piece = mystrsep(line, iter);
+  int numrep = -1, i = 0, np = 0;
+  auto iter = line.begin(), start_piece = mystrsep(line, iter);
   while (start_piece != line.end()) {
     switch (i) {
       case 0: {
         np++;
         break;
       }
       case 1: {
         numrep = atoi(std::string(start_piece, iter).c_str());
         if (numrep < 1) {
           HUNSPELL_WARNING(stderr, "error: line %d: incorrect entry number\n",
                            af->getlinenum());
           return false;
         }
         reptable.reserve(std::min(numrep, 16384));
         np++;
         break;
       }
       default:
         break;
     }
     ++i;
     start_piece = mystrsep(line, iter);
   }
   if (np != 2) {
     HUNSPELL_WARNING(stderr, "error: line %d: missing data\n",
                      af->getlinenum());
     return false;
   }
 
   /* now parse the numrep lines to read in the remainder of the table */
   for (int j = 0; j < numrep; ++j) {
     std::string nl;
-    reptable.push_back(replentry());
+    reptable.emplace_back();
     int type = 0;
     if (af->getline(nl)) {
       mychomp(nl);
       iter = nl.begin();
       i = 0;
       start_piece = mystrsep(nl, iter);
       bool errored = false;
       while (!errored && start_piece != nl.end()) {
         switch (i) {
           case 0: {
             if (nl.compare(start_piece - nl.begin(), 3, "REP", 3) != 0) {
               errored = true;
               break;
             }
             break;
           }
           case 1: {
             if (*start_piece == '^')
               type = 1;
             reptable.back().pattern.assign(start_piece + type, iter);
             mystrrep(reptable.back().pattern, "_", " ");
             if (!reptable.back().pattern.empty() && reptable.back().pattern[reptable.back().pattern.size() - 1] == '$') {
               type += 2;
               reptable.back().pattern.resize(reptable.back().pattern.size() - 1);
             }
             break;
           }
           case 2: {
             reptable.back().outstrings[type].assign(start_piece, iter);
             mystrrep(reptable.back().outstrings[type], "_", " ");
             break;
           }
           default:
             break;
         }
         ++i;
         start_piece = mystrsep(nl, iter);
       }
     }
     if (reptable.back().pattern.empty() || reptable.back().outstrings[type].empty()) {
       HUNSPELL_WARNING(stderr, "error: line %d: table is corrupt\n",
                        af->getlinenum());
       reptable.clear();
       return false;
     }
   }
   return true;
 }
 
 // return replacing table
diff --git a/src/hunspell/hashmgr.hxx b/src/hunspell/hashmgr.hxx
index a21b784..3c82e4c 100644
--- a/src/hunspell/hashmgr.hxx
+++ b/src/hunspell/hashmgr.hxx
@@ -1,80 +1,80 @@
 /* ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
  * Copyright (C) 2002-2022 Németh László
  *
  * The contents of this file are subject to the Mozilla Public License Version
  * 1.1 (the "License"); you may not use this file except in compliance with
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * Hunspell is based on MySpell which is Copyright (C) 2002 Kevin Hendricks.
  *
  * Contributor(s): David Einstein, Davide Prina, Giuseppe Modugno,
  * Gianluca Turconi, Simon Brouwer, Noll János, Bíró Árpád,
  * Goldman Eleonóra, Sarlós Tamás, Bencsáth Boldizsár, Halácsy Péter,
  * Dvornik László, Gefferth András, Nagy Viktor, Varga Dániel, Chris Halls,
  * Rene Engelhard, Bram Moolenaar, Dafydd Jones, Harri Pitkänen
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 /*
  * Copyright 2002 Kevin B. Hendricks, Stratford, Ontario, Canada
  * And Contributors.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  *
  * 3. All modifications to the source code must be clearly marked as
  *    such.  Binary redistributions based on modified source code
  *    must be clearly marked as modified versions in the documentation
  *    and/or other materials provided with the distribution.
  *
  * THIS SOFTWARE IS PROVIDED BY KEVIN B. HENDRICKS AND CONTRIBUTORS
  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
  * KEVIN B. HENDRICKS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
 
 #ifndef HASHMGR_HXX_
 #define HASHMGR_HXX_
 
-#include <stdio.h>
+#include <cstdio>
 #include <string>
 #include <vector>
 
 #include "htypes.hxx"
 #include "filemgr.hxx"
 #include "w_char.hxx"
diff --git a/src/hunspell/hunspell.cxx b/src/hunspell/hunspell.cxx
index cddcb4c..d2ad847 100644
--- a/src/hunspell/hunspell.cxx
+++ b/src/hunspell/hunspell.cxx
@@ -1,85 +1,85 @@
 /* ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
  * Copyright (C) 2002-2022 Németh László
  *
  * The contents of this file are subject to the Mozilla Public License Version
  * 1.1 (the "License"); you may not use this file except in compliance with
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * Hunspell is based on MySpell which is Copyright (C) 2002 Kevin Hendricks.
  *
  * Contributor(s): David Einstein, Davide Prina, Giuseppe Modugno,
  * Gianluca Turconi, Simon Brouwer, Noll János, Bíró Árpád,
  * Goldman Eleonóra, Sarlós Tamás, Bencsáth Boldizsár, Halácsy Péter,
  * Dvornik László, Gefferth András, Nagy Viktor, Varga Dániel, Chris Halls,
  * Rene Engelhard, Bram Moolenaar, Dafydd Jones, Harri Pitkänen
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 /*
  * Copyright 2002 Kevin B. Hendricks, Stratford, Ontario, Canada
  * And Contributors.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  *
  * 3. All modifications to the source code must be clearly marked as
  *    such.  Binary redistributions based on modified source code
  *    must be clearly marked as modified versions in the documentation
  *    and/or other materials provided with the distribution.
  *
  * THIS SOFTWARE IS PROVIDED BY KEVIN B. HENDRICKS AND CONTRIBUTORS
  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
  * KEVIN B. HENDRICKS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
 
-#include <stdlib.h>
-#include <string.h>
-#include <stdio.h>
-#include <time.h>
+#include <cstdlib>
+#include <cstring>
+#include <cstdio>
+#include <ctime>
 
 #include "affixmgr.hxx"
 #include "hunspell.hxx"
 #include "suggestmgr.hxx"
 #include "hunspell.h"
 #include "csutil.hxx"
 
 #include <limits>
 #include <string>
 
 #define MAXWORDUTF8LEN (MAXWORDLEN * 3)
@@ -88,39 +88,41 @@ class HunspellImpl
 {
 public:
   HunspellImpl(const char* affpath, const char* dpath, const char* key = NULL);
+  HunspellImpl(const HunspellImpl&) = delete;
+  HunspellImpl& operator=(const HunspellImpl&) = delete;
   ~HunspellImpl();
   int add_dic(const char* dpath, const char* key = NULL);
   std::vector<std::string> suffix_suggest(const std::string& root_word);
   std::vector<std::string> generate(const std::string& word, const std::vector<std::string>& pl);
   std::vector<std::string> generate(const std::string& word, const std::string& pattern);
   std::vector<std::string> stem(const std::string& word);
   std::vector<std::string> stem(const std::vector<std::string>& morph);
   std::vector<std::string> analyze(const std::string& word);
   int get_langnum() const;
   bool input_conv(const std::string& word, std::string& dest);
   bool spell(const std::string& word, std::vector<std::string>& candidate_stack,
              int* info = NULL, std::string* root = NULL);
   std::vector<std::string> suggest(const std::string& word);
   std::vector<std::string> suggest(const std::string& word, std::vector<std::string>& suggest_candidate_stack);
   const std::string& get_wordchars_cpp() const;
   const std::vector<w_char>& get_wordchars_utf16() const;
   const std::string& get_dict_encoding() const;
   int add(const std::string& word);
   int add_with_affix(const std::string& word, const std::string& example);
   int remove(const std::string& word);
   const std::string& get_version_cpp() const;
   struct cs_info* get_csconv();
 
   int spell(const char* word, int* info = NULL, char** root = NULL);
   int suggest(char*** slst, const char* word);
   int suffix_suggest(char*** slst, const char* root_word);
   void free_list(char*** slst, int n);
   char* get_dic_encoding();
   int analyze(char*** slst, const char* word);
   int stem(char*** slst, const char* word);
   int stem(char*** slst, char** morph, int n);
   int generate(char*** slst, const char* word, const char* word2);
   int generate(char*** slst, const char* word, char** desc, int n);
   const char* get_wordchars() const;
   const char* get_version() const;
   int input_conv(const char* word, char* dest, size_t destsize);
@@ -141,37 +143,34 @@ private:
   std::vector<std::string> analyze_internal(const std::string& word);
   bool spell_internal(const std::string& word, std::vector<std::string>& candidate_stack,
                       int* info = NULL, std::string* root = NULL);
   std::vector<std::string> suggest_internal(const std::string& word,
                                             std::vector<std::string>& spell_candidate_stack,
                                             std::vector<std::string>& suggest_candidate_stack,
                                             bool& capitalized, size_t& abbreviated, int& captype);
   void cleanword(std::string& dest, const std::string&, int* pcaptype, int* pabbrev);
   size_t cleanword2(std::string& dest,
                     std::vector<w_char>& dest_u,
                     const std::string& src,
                     int* pcaptype,
                     size_t* pabbrev);
   void clean_ignore(std::string& dest, const std::string& src);
   void mkinitcap(std::string& u8);
   int mkinitcap2(std::string& u8, std::vector<w_char>& u16);
   int mkinitsmall2(std::string& u8, std::vector<w_char>& u16);
   void mkallcap(std::string& u8);
   int mkallsmall2(std::string& u8, std::vector<w_char>& u16);
   struct hentry* checkword(const std::string& source, int* info, std::string* root);
   std::string sharps_u8_l1(const std::string& source);
   hentry*
   spellsharps(std::string& base, size_t start_pos, int, int, int* info, std::string* root);
   int is_keepcase(const hentry* rv);
   void insert_sug(std::vector<std::string>& slst, const std::string& word);
   void cat_result(std::string& result, const std::string& st);
   std::vector<std::string> spellml(const std::string& word);
   std::string get_xml_par(const std::string& par, std::string::size_type pos);
   std::string::size_type get_xml_pos(const std::string& s, std::string::size_type pos, const char* attr);
   std::vector<std::string> get_xml_list(const std::string& list, std::string::size_type pos, const char* tag);
   int check_xml_par(const std::string& q, std::string::size_type pos, const char* attr, const char* value);
-private:
-  HunspellImpl(const HunspellImpl&);
-  HunspellImpl& operator=(const HunspellImpl&);
 };
 
 HunspellImpl::HunspellImpl(const char* affpath, const char* dpath, const char* key)
@@ -205,14 +204,14 @@ HunspellImpl::HunspellImpl(const char* affpath, const char* dpath, const char* k
 HunspellImpl::~HunspellImpl() {
   delete pSMgr;
   delete pAMgr;
-  for (size_t i = 0; i < m_HMgrs.size(); ++i)
-    delete m_HMgrs[i];
+  for (auto& m_HMgr : m_HMgrs)
+    delete m_HMgr;
   pSMgr = NULL;
   pAMgr = NULL;
 #ifdef MOZILLA_CLIENT
   delete[] csconv;
 #endif
   csconv = NULL;
 }
 
 // load extra dictionaries
@@ -297,76 +296,76 @@ size_t HunspellImpl::cleanword2(std::string& dest,
 void HunspellImpl::cleanword(std::string& dest,
                         const std::string& src,
                         int* pcaptype,
                         int* pabbrev) {
   dest.clear();
   const unsigned char* q = (const unsigned char*)src.c_str();
   int firstcap = 0, nl = (int)src.size();
 
   // first skip over any leading blanks
   while (*q == ' ') {
     ++q;
     nl--;
   }
   
   // now strip off any trailing periods (recording their presence)
   *pabbrev = 0;
   
   while ((nl > 0) && (*(q + nl - 1) == '.')) {
     nl--;
     (*pabbrev)++;
   }
 
   // if no characters are left it can't be capitalized
   if (nl <= 0) {
     *pcaptype = NOCAP;
     return;
   }
 
   // now determine the capitalization type of the first nl letters
   int ncap = 0;
   int nneutral = 0;
   int nc = 0;
 
   if (!utf8) {
     while (nl > 0) {
       nc++;
       if (csconv[(*q)].ccase)
         ncap++;
       if (csconv[(*q)].cupper == csconv[(*q)].clower)
         nneutral++;
       dest.push_back(*q++);
       nl--;
     }
     // remember to terminate the destination string
     firstcap = csconv[static_cast<unsigned char>(dest[0])].ccase;
   } else {
     std::vector<w_char> t;
     u8_u16(t, src);
-    for (size_t i = 0; i < t.size(); ++i) {
-      unsigned short idx = (unsigned short)t[i];
-      unsigned short low = unicodetolower(idx, langnum);
+    for (auto& wc : t) {
+      const auto idx = (unsigned short)wc;
+      const auto low = unicodetolower(idx, langnum);
       if (idx != low)
         ncap++;
       if (unicodetoupper(idx, langnum) == low)
         nneutral++;
     }
     u16_u8(dest, t);
     if (ncap) {
-      unsigned short idx = (unsigned short)t[0];
+      const auto idx = (unsigned short)t[0];
       firstcap = (idx != unicodetolower(idx, langnum));
     }
   }
 
   // now finally set the captype
   if (ncap == 0) {
     *pcaptype = NOCAP;
   } else if ((ncap == 1) && firstcap) {
     *pcaptype = INITCAP;
   } else if ((ncap == nc) || ((ncap + nneutral) == nc)) {
     *pcaptype = ALLCAP;
   } else if ((ncap > 1) && firstcap) {
     *pcaptype = HUHINITCAP;
   } else {
     *pcaptype = HUHCAP;
   }
 }
@@ -463,321 +462,319 @@ bool HunspellImpl::spell(const std::string& word, std::vector<std::string>& cand
 bool HunspellImpl::spell_internal(const std::string& word, std::vector<std::string>& candidate_stack,
                                   int* info, std::string* root) {
   struct hentry* rv = NULL;
 
   int info2 = 0;
   if (!info)
     info = &info2;
   else
     *info = 0;
 
   // Hunspell supports XML input of the simplified API (see manual)
   if (word == SPELL_XML)
     return true;
   if (utf8) {
     if (word.size() >= MAXWORDUTF8LEN)
       return false;
   } else {
     if (word.size() >= MAXWORDLEN)
       return false;
   }
   int captype = NOCAP;
   size_t abbv = 0;
   size_t wl = 0;
 
   std::string scw;
   std::vector<w_char> sunicw;
 
   // input conversion
   RepList* rl = pAMgr ? pAMgr->get_iconvtable() : NULL;
   {
     std::string wspace;
 
     bool convstatus = rl ? rl->conv(word, wspace) : false;
     if (convstatus)
       wl = cleanword2(scw, sunicw, wspace, &captype, &abbv);
     else
       wl = cleanword2(scw, sunicw, word, &captype, &abbv);
   }
 
 #ifdef MOZILLA_CLIENT
   // accept the abbreviated words without dots
   // workaround for the incomplete tokenization of Mozilla
   abbv = 1;
 #endif
 
   if (wl == 0 || m_HMgrs.empty())
     return true;
   if (root)
     root->clear();
 
   // allow numbers with dots, dashes and commas (but forbid double separators:
   // "..", "--" etc.)
   enum { NBEGIN, NNUM, NSEP };
   int nstate = NBEGIN;
   size_t i;
 
   for (i = 0; (i < wl); i++) {
     if ((scw[i] <= '9') && (scw[i] >= '0')) {
       nstate = NNUM;
     } else if ((scw[i] == ',') || (scw[i] == '.') || (scw[i] == '-')) {
       if ((nstate == NSEP) || (i == 0))
         break;
       nstate = NSEP;
     } else
       break;
   }
   if ((i == wl) && (nstate == NNUM))
     return true;
 
   switch (captype) {
     case HUHCAP:
     /* FALLTHROUGH */
     case HUHINITCAP:
       *info |= SPELL_ORIGCAP;
     /* FALLTHROUGH */
     case NOCAP:
       rv = checkword(scw, info, root);
       if ((abbv) && !(rv)) {
         std::string u8buffer(scw);
         u8buffer.push_back('.');
         rv = checkword(u8buffer, info, root);
       }
       break;
     case ALLCAP: {
       *info |= SPELL_ORIGCAP;
       rv = checkword(scw, info, root);
       if (rv)
         break;
       if (abbv) {
         std::string u8buffer(scw);
         u8buffer.push_back('.');
         rv = checkword(u8buffer, info, root);
         if (rv)
           break;
       }
       // Spec. prefix handling for Catalan, French, Italian:
       // prefixes separated by apostrophe (SANT'ELIA -> Sant'+Elia).
       size_t apos = pAMgr ? scw.find('\'') : std::string::npos;
       if (apos != std::string::npos) {
         mkallsmall2(scw, sunicw);
         //conversion may result in string with different len to pre-mkallsmall2
         //so re-scan
         if (apos != std::string::npos && apos < scw.size() - 1) {
-          std::string part1 = scw.substr(0, apos+1);
-          std::string part2 = scw.substr(apos+1);
+          std::string part1 = scw.substr(0, apos + 1), part2 = scw.substr(apos + 1);
           if (utf8) {
             std::vector<w_char> part1u, part2u;
             u8_u16(part1u, part1);
             u8_u16(part2u, part2);
             mkinitcap2(part2, part2u);
             scw = part1 + part2;
             sunicw = part1u;
             sunicw.insert(sunicw.end(), part2u.begin(), part2u.end());
             rv = checkword(scw, info, root);
             if (rv)
               break;
           } else {
             mkinitcap2(part2, sunicw);
             scw = part1 + part2;
             rv = checkword(scw, info, root);
             if (rv)
               break;
           }
           mkinitcap2(scw, sunicw);
           rv = checkword(scw, info, root);
           if (rv)
             break;
         }
       }
       if (pAMgr && pAMgr->get_checksharps() && scw.find("SS") != std::string::npos) {
 
         mkallsmall2(scw, sunicw);
         std::string u8buffer(scw);
         rv = spellsharps(u8buffer, 0, 0, 0, info, root);
         if (!rv) {
           mkinitcap2(scw, sunicw);
           rv = spellsharps(scw, 0, 0, 0, info, root);
         }
         if ((abbv) && !(rv)) {
           u8buffer.push_back('.');
           rv = spellsharps(u8buffer, 0, 0, 0, info, root);
           if (!rv) {
             u8buffer = std::string(scw);
             u8buffer.push_back('.');
             rv = spellsharps(u8buffer, 0, 0, 0, info, root);
           }
         }
         if (rv)
           break;
       }
     }
       /* FALLTHROUGH */
     case INITCAP: {
       // handle special capitalization of dotted I
       bool Idot = (utf8 && (unsigned char) scw[0] == 0xc4 && (unsigned char) scw[1] == 0xb0);
       *info |= SPELL_ORIGCAP;
       if (captype == ALLCAP) {
           mkallsmall2(scw, sunicw);
           mkinitcap2(scw, sunicw);
           if (Idot)
              scw.replace(0, 1, "\xc4\xb0");
       }
       if (captype == INITCAP)
         *info |= SPELL_INITCAP;
       rv = checkword(scw, info, root);
       if (captype == INITCAP)
         *info &= ~SPELL_INITCAP;
       // forbid bad capitalization
       // (for example, ijs -> Ijs instead of IJs in Dutch)
       // use explicit forms in dic: Ijs/F (F = FORBIDDENWORD flag)
       if (*info & SPELL_FORBIDDEN) {
         rv = NULL;
         break;
       }
       if (rv && is_keepcase(rv) && (captype == ALLCAP))
         rv = NULL;
       if (rv || (Idot && langnum != LANG_az && langnum != LANG_tr && langnum != LANG_crh))
         break;
 
       mkallsmall2(scw, sunicw);
       std::string u8buffer(scw);
       mkinitcap2(scw, sunicw);
 
       rv = checkword(u8buffer, info, root);
       if (abbv && !rv) {
         u8buffer.push_back('.');
         rv = checkword(u8buffer, info, root);
         if (!rv) {
           u8buffer = scw;
           u8buffer.push_back('.');
           if (captype == INITCAP)
             *info |= SPELL_INITCAP;
           rv = checkword(u8buffer, info, root);
           if (captype == INITCAP)
             *info &= ~SPELL_INITCAP;
           if (rv && is_keepcase(rv) && (captype == ALLCAP))
             rv = NULL;
           break;
         }
       }
       if (rv && is_keepcase(rv) &&
           ((captype == ALLCAP) ||
            // if CHECKSHARPS: KEEPCASE words with \xDF  are allowed
            // in INITCAP form, too.
            !(pAMgr->get_checksharps() &&
              ((utf8 && u8buffer.find("\xC3\x9F") != std::string::npos) ||
               (!utf8 && u8buffer.find('\xDF') != std::string::npos)))))
         rv = NULL;
       break;
     }
   }
 
   if (rv) {
     if (pAMgr && pAMgr->get_warn() && rv->astr &&
         TESTAFF(rv->astr, pAMgr->get_warn(), rv->alen)) {
       *info |= SPELL_WARN;
       if (pAMgr->get_forbidwarn())
         return false;
       return true;
     }
     return true;
   }
 
   // recursive breaking at break points
   if (!wordbreak.empty() && !(*info & SPELL_FORBIDDEN)) {
 
     int nbr = 0;
     wl = scw.size();
 
     // calculate break points for recursion limit
-    for (size_t j = 0; j < wordbreak.size(); ++j) {
+    for (auto& j : wordbreak) {
       size_t pos = 0;
-      while ((pos = scw.find(wordbreak[j], pos)) != std::string::npos) {
+      while ((pos = scw.find(j, pos)) != std::string::npos) {
         ++nbr;
-        pos += wordbreak[j].size();
+        pos += j.size();
       }
     }
     if (nbr >= 10)
       return false;
 
     // check boundary patterns (^begin and end$)
-    for (size_t j = 0; j < wordbreak.size(); ++j) {
-      size_t plen = wordbreak[j].size();
+    for (auto& j : wordbreak) {
+      size_t plen = j.size();
       if (plen == 1 || plen > wl)
         continue;
 
-      if (wordbreak[j][0] == '^' &&
-          scw.compare(0, plen - 1, wordbreak[j], 1, plen -1) == 0 && spell(scw.substr(plen - 1), candidate_stack))
+      if (j[0] == '^' &&
+          scw.compare(0, plen - 1, j, 1, plen -1) == 0 && spell(scw.substr(plen - 1), candidate_stack))
         return true;
 
-      if (wordbreak[j][plen - 1] == '$' &&
-          scw.compare(wl - plen + 1, plen - 1, wordbreak[j], 0, plen - 1) == 0) {
+      if (j[plen - 1] == '$' &&
+          scw.compare(wl - plen + 1, plen - 1, j, 0, plen - 1) == 0) {
         std::string suffix(scw.substr(wl - plen + 1));
         scw.resize(wl - plen + 1);
         if (spell(scw, candidate_stack))
           return true;
         scw.append(suffix);
       }
     }
 
     // other patterns
-    for (size_t j = 0; j < wordbreak.size(); ++j) {
-      size_t plen = wordbreak[j].size();
-      size_t found = scw.find(wordbreak[j]);
+    for (auto& j : wordbreak) {
+      size_t plen = j.size();
+      size_t found = scw.find(j);
       if ((found > 0) && (found < wl - plen)) {
-        size_t found2 = scw.find(wordbreak[j], found + 1);
+        size_t found2 = scw.find(j, found + 1);
         // try to break at the second occurance
         // to recognize dictionary words with wordbreak
         if (found2 > 0 && (found2 < wl - plen))
             found = found2;
         std::string substring(scw.substr(found + plen));
         if (!spell(substring, candidate_stack))
           continue;
         std::string suffix(scw.substr(found));
         scw.resize(found);
         // examine 2 sides of the break point
         if (spell(scw, candidate_stack))
           return true;
         scw.append(suffix);
 
         // LANG_hu: spec. dash rule
-        if (langnum == LANG_hu && wordbreak[j] == "-") {
+        if (langnum == LANG_hu && j == "-") {
           suffix = scw.substr(found + 1);
           scw.resize(found + 1);
           if (spell(scw, candidate_stack))
             return true;  // check the first part with dash
           scw.append(suffix);
         }
         // end of LANG specific region
       }
     }
 
     // other patterns (break at first break point)
-    for (size_t j = 0; j < wordbreak.size(); ++j) {
-      size_t plen = wordbreak[j].size();
-      size_t found = scw.find(wordbreak[j]);
+    for (auto& j : wordbreak) {
+      size_t plen = j.size(), found = scw.find(j);
       if ((found > 0) && (found < wl - plen)) {
         if (!spell(scw.substr(found + plen), candidate_stack))
           continue;
         std::string suffix(scw.substr(found));
         scw.resize(found);
         // examine 2 sides of the break point
         if (spell(scw, candidate_stack))
           return true;
         scw.append(suffix);
 
         // LANG_hu: spec. dash rule
-        if (langnum == LANG_hu && wordbreak[j] == "-") {
+        if (langnum == LANG_hu && j == "-") {
           suffix = scw.substr(found + 1);
           scw.resize(found + 1);
           if (spell(scw, candidate_stack))
             return true;  // check the first part with dash
           scw.append(suffix);
         }
         // end of LANG specific region
       }
     }
   }
 
   return false;
 }
@@ -895,101 +892,101 @@ struct hentry* HunspellImpl::checkword(const std::string& w, int* info, std::str
 std::vector<std::string> HunspellImpl::suggest(const std::string& word, std::vector<std::string>& suggest_candidate_stack) {
 
   if (suggest_candidate_stack.size() > 2048 || // apply a fairly arbitrary depth limit
       // something very broken if suggest ends up calling itself with the same word
       std::find(suggest_candidate_stack.begin(), suggest_candidate_stack.end(), word) != suggest_candidate_stack.end()) {
-    return std::vector<std::string>();
+    return { };
   }
 
   bool capwords;
   size_t abbv;
   int captype;
   std::vector<std::string> spell_candidate_stack;
   suggest_candidate_stack.push_back(word);
   std::vector<std::string> slst = suggest_internal(word, spell_candidate_stack, suggest_candidate_stack,
 		                                   capwords, abbv, captype);
   suggest_candidate_stack.pop_back();
   // word reversing wrapper for complex prefixes
   if (complexprefixes) {
-    for (size_t j = 0; j < slst.size(); ++j) {
+    for (auto& j : slst) {
       if (utf8)
-        reverseword_utf(slst[j]);
+        reverseword_utf(j);
       else
-        reverseword(slst[j]);
+        reverseword(j);
     }
   }
 
   // capitalize
   if (capwords)
-    for (size_t j = 0; j < slst.size(); ++j) {
-      mkinitcap(slst[j]);
+    for (auto& j : slst) {
+      mkinitcap(j);
     }
 
   // expand suggestions with dot(s)
   if (abbv && pAMgr && pAMgr->get_sugswithdots()) {
-    for (size_t j = 0; j < slst.size(); ++j) {
-      slst[j].append(word.substr(word.size() - abbv));
+    for (auto& j : slst) {
+	    j.append(word.substr(word.size() - abbv));
     }
   }
 
   // remove bad capitalized and forbidden forms
   if (pAMgr && (pAMgr->get_keepcase() || pAMgr->get_forbiddenword())) {
     switch (captype) {
       case INITCAP:
       case ALLCAP: {
         size_t l = 0;
         for (size_t j = 0; j < slst.size(); ++j) {
           if (slst[j].find(' ') == std::string::npos && !spell(slst[j], spell_candidate_stack)) {
             std::string s;
             std::vector<w_char> w;
             if (utf8) {
               u8_u16(w, slst[j]);
             } else {
               s = slst[j];
             }
             mkallsmall2(s, w);
             if (spell(s, spell_candidate_stack)) {
               slst[l] = s;
               ++l;
             } else {
               mkinitcap2(s, w);
               if (spell(s, spell_candidate_stack)) {
                 slst[l] = s;
                 ++l;
               }
             }
           } else {
             slst[l] = slst[j];
             ++l;
           }
         }
         slst.resize(l);
       }
     }
   }
 
   // remove duplications
   size_t l = 0;
   for (size_t j = 0; j < slst.size(); ++j) {
     slst[l] = slst[j];
     for (size_t k = 0; k < l; ++k) {
       if (slst[k] == slst[j]) {
         --l;
         break;
       }
     }
     ++l;
   }
   slst.resize(l);
 
   // output conversion
   RepList* rl = (pAMgr) ? pAMgr->get_oconvtable() : NULL;
   if (rl) {
     for (size_t i = 0; rl && i < slst.size(); ++i) {
       std::string wspace;
       if (rl->conv(slst[i], wspace)) {
         slst[i] = wspace;
       }
     }
   }
   return slst;
 }
@@ -1002,306 +999,306 @@ std::vector<std::string> HunspellImpl::suggest(const std::string& word) {
 std::vector<std::string> HunspellImpl::suggest_internal(const std::string& word,
         std::vector<std::string>& spell_candidate_stack,
         std::vector<std::string>& suggest_candidate_stack,
         bool& capwords, size_t& abbv, int& captype) {
   captype = NOCAP;
   abbv = 0;
   capwords = false;
 
   std::vector<std::string> slst;
 
   int onlycmpdsug = 0;
   if (!pSMgr || m_HMgrs.empty())
     return slst;
 
   // process XML input of the simplified API (see manual)
   if (word.compare(0, sizeof(SPELL_XML) - 3, SPELL_XML, sizeof(SPELL_XML) - 3) == 0) {
     return spellml(word);
   }
   if (utf8) {
     if (word.size() >= MAXWORDUTF8LEN)
       return slst;
   } else {
     if (word.size() >= MAXWORDLEN)
       return slst;
   }
   size_t wl = 0;
 
   std::string scw;
   std::vector<w_char> sunicw;
 
   // input conversion
   RepList* rl = (pAMgr) ? pAMgr->get_iconvtable() : NULL;
   {
     std::string wspace;
 
     bool convstatus = rl ? rl->conv(word, wspace) : false;
     if (convstatus)
       wl = cleanword2(scw, sunicw, wspace, &captype, &abbv);
     else
       wl = cleanword2(scw, sunicw, word, &captype, &abbv);
 
     if (wl == 0)
       return slst;
 
 #if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
     if (wl > 32768)
       return slst;
 #endif
   }
 
   bool good = false;
 
   clock_t timelimit;
   // initialize in every suggestion call
   timelimit = clock();
 
   // check capitalized form for FORCEUCASE
   if (pAMgr && captype == NOCAP && pAMgr->get_forceucase()) {
     int info = SPELL_ORIGCAP;
     if (checkword(scw, &info, NULL)) {
       std::string form(scw);
       mkinitcap(form);
       slst.push_back(form);
       return slst;
     }
   }
 
   switch (captype) {
     case NOCAP: {
-      good |= pSMgr->suggest(slst, scw.c_str(), &onlycmpdsug);
+      good |= pSMgr->suggest(slst, scw, &onlycmpdsug);
       if (clock() > timelimit + TIMELIMIT_GLOBAL)
           return slst;
       if (abbv) {
         std::string wspace(scw);
         wspace.push_back('.');
-        good |= pSMgr->suggest(slst, wspace.c_str(), &onlycmpdsug);
+        good |= pSMgr->suggest(slst, wspace, &onlycmpdsug);
         if (clock() > timelimit + TIMELIMIT_GLOBAL)
             return slst;
       }
       break;
     }
 
     case INITCAP: {
       capwords = true;
-      good |= pSMgr->suggest(slst, scw.c_str(), &onlycmpdsug);
+      good |= pSMgr->suggest(slst, scw, &onlycmpdsug);
       if (clock() > timelimit + TIMELIMIT_GLOBAL)
           return slst;
       std::string wspace(scw);
       mkallsmall2(wspace, sunicw);
-      good |= pSMgr->suggest(slst, wspace.c_str(), &onlycmpdsug);
+      good |= pSMgr->suggest(slst, wspace, &onlycmpdsug);
       if (clock() > timelimit + TIMELIMIT_GLOBAL)
           return slst;
       break;
     }
     case HUHINITCAP:
       capwords = true;
       /* FALLTHROUGH */
     case HUHCAP: {
-      good |= pSMgr->suggest(slst, scw.c_str(), &onlycmpdsug);
+      good |= pSMgr->suggest(slst, scw, &onlycmpdsug);
       if (clock() > timelimit + TIMELIMIT_GLOBAL)
           return slst;
       // something.The -> something. The
       size_t dot_pos = scw.find('.');
       if (dot_pos != std::string::npos) {
         std::string postdot = scw.substr(dot_pos + 1);
         int captype_;
         if (utf8) {
           std::vector<w_char> postdotu;
           u8_u16(postdotu, postdot);
           captype_ = get_captype_utf8(postdotu, langnum);
         } else {
           captype_ = get_captype(postdot, csconv);
         }
         if (captype_ == INITCAP) {
           std::string str(scw);
           str.insert(dot_pos + 1, 1, ' ');
           insert_sug(slst, str);
         }
       }
 
       std::string wspace;
 
       if (captype == HUHINITCAP) {
         // TheOpenOffice.org -> The OpenOffice.org
         wspace = scw;
         mkinitsmall2(wspace, sunicw);
-        good |= pSMgr->suggest(slst, wspace.c_str(), &onlycmpdsug);
+        good |= pSMgr->suggest(slst, wspace, &onlycmpdsug);
         if (clock() > timelimit + TIMELIMIT_GLOBAL)
             return slst;
       }
       wspace = scw;
       mkallsmall2(wspace, sunicw);
-      if (spell(wspace.c_str(), spell_candidate_stack))
+      if (spell(wspace, spell_candidate_stack))
         insert_sug(slst, wspace);
       size_t prevns = slst.size();
-      good |= pSMgr->suggest(slst, wspace.c_str(), &onlycmpdsug);
+      good |= pSMgr->suggest(slst, wspace, &onlycmpdsug);
       if (clock() > timelimit + TIMELIMIT_GLOBAL)
           return slst;
       if (captype == HUHINITCAP) {
         mkinitcap2(wspace, sunicw);
-        if (spell(wspace.c_str(), spell_candidate_stack))
+        if (spell(wspace, spell_candidate_stack))
           insert_sug(slst, wspace);
-        good |= pSMgr->suggest(slst, wspace.c_str(), &onlycmpdsug);
+        good |= pSMgr->suggest(slst, wspace, &onlycmpdsug);
         if (clock() > timelimit + TIMELIMIT_GLOBAL)
             return slst;
       }
       // aNew -> "a New" (instead of "a new")
       for (size_t j = prevns; j < slst.size(); ++j) {
         const char* space = strchr(slst[j].c_str(), ' ');
         if (space) {
           size_t slen = strlen(space + 1);
           // different case after space (need capitalisation)
           if ((slen < wl) && strcmp(scw.c_str() + wl - slen, space + 1)) {
             std::string first(slst[j].c_str(), space + 1);
             std::string second(space + 1);
             std::vector<w_char> w;
             if (utf8)
               u8_u16(w, second);
             mkinitcap2(second, w);
             // set as first suggestion
             slst.erase(slst.begin() + j);
             slst.insert(slst.begin(), first + second);
           }
         }
       }
       break;
     }
 
     case ALLCAP: {
       std::string wspace(scw);
       mkallsmall2(wspace, sunicw);
-      good |= pSMgr->suggest(slst, wspace.c_str(), &onlycmpdsug);
+      good |= pSMgr->suggest(slst, wspace, &onlycmpdsug);
       if (clock() > timelimit + TIMELIMIT_GLOBAL)
           return slst;
-      if (pAMgr && pAMgr->get_keepcase() && spell(wspace.c_str(), spell_candidate_stack))
+      if (pAMgr && pAMgr->get_keepcase() && spell(wspace, spell_candidate_stack))
         insert_sug(slst, wspace);
       mkinitcap2(wspace, sunicw);
-      good |= pSMgr->suggest(slst, wspace.c_str(), &onlycmpdsug);
+      good |= pSMgr->suggest(slst, wspace, &onlycmpdsug);
       if (clock() > timelimit + TIMELIMIT_GLOBAL)
           return slst;
-      for (size_t j = 0; j < slst.size(); ++j) {
-        mkallcap(slst[j]);
+      for (auto& j : slst) {
+        mkallcap(j);
         if (pAMgr && pAMgr->get_checksharps()) {
           if (utf8) {
-            mystrrep(slst[j], "\xC3\x9F", "SS");
+            mystrrep(j, "\xC3\x9F", "SS");
           } else {
-            mystrrep(slst[j], "\xDF", "SS");
+            mystrrep(j, "\xDF", "SS");
           }
         }
       }
       break;
     }
   }
 
   // LANG_hu section: replace '-' with ' ' in Hungarian
   if (langnum == LANG_hu) {
-    for (size_t j = 0; j < slst.size(); ++j) {
-      size_t pos = slst[j].find('-');
+    for (auto& j : slst) {
+      size_t pos = j.find('-');
       if (pos != std::string::npos) {
         int info;
-        std::string w(slst[j].substr(0, pos));
-        w.append(slst[j].substr(pos + 1));
+        std::string w(j.substr(0, pos));
+        w.append(j.substr(pos + 1));
         (void)spell(w, spell_candidate_stack, &info, NULL);
         if ((info & SPELL_COMPOUND) && (info & SPELL_FORBIDDEN)) {
-          slst[j][pos] = ' ';
+	        j[pos] = ' ';
         } else
-          slst[j][pos] = '-';
+	        j[pos] = '-';
       }
     }
   }
   // END OF LANG_hu section
   // try ngram approach since found nothing good suggestion
   if (!good && pAMgr && (slst.empty() || onlycmpdsug) && (pAMgr->get_maxngramsugs() != 0)) {
     switch (captype) {
       case NOCAP: {
         pSMgr->ngsuggest(slst, scw.c_str(), m_HMgrs, NOCAP);
         if (clock() > timelimit + TIMELIMIT_GLOBAL)
             return slst;
         break;
       }
       /* FALLTHROUGH */
       case HUHINITCAP:
         capwords = true;
       /* FALLTHROUGH */
       case HUHCAP: {
         std::string wspace(scw);
         mkallsmall2(wspace, sunicw);
         pSMgr->ngsuggest(slst, wspace.c_str(), m_HMgrs, HUHCAP);
         if (clock() > timelimit + TIMELIMIT_GLOBAL)
             return slst;
         break;
       }
       case INITCAP: {
         capwords = true;
         std::string wspace(scw);
         mkallsmall2(wspace, sunicw);
         pSMgr->ngsuggest(slst, wspace.c_str(), m_HMgrs, INITCAP);
         if (clock() > timelimit + TIMELIMIT_GLOBAL)
             return slst;
         break;
       }
       case ALLCAP: {
         std::string wspace(scw);
         mkallsmall2(wspace, sunicw);
         size_t oldns = slst.size();
         pSMgr->ngsuggest(slst, wspace.c_str(), m_HMgrs, ALLCAP);
         if (clock() > timelimit + TIMELIMIT_GLOBAL)
             return slst;
         for (size_t j = oldns; j < slst.size(); ++j) {
           mkallcap(slst[j]);
         }
         break;
       }
     }
   }
 
   // try dash suggestion (Afo-American -> Afro-American)
   // Note: LibreOffice was modified to treat dashes as word
   // characters to check "scot-free" etc. word forms, but
   // we need to handle suggestions for "Afo-American", etc.,
   // while "Afro-American" is missing from the dictionary.
   // TODO avoid possible overgeneration
   size_t dash_pos = scw.find('-');
   if (dash_pos != std::string::npos) {
     int nodashsug = 1;
     for (size_t j = 0; j < slst.size() && nodashsug == 1; ++j) {
       if (slst[j].find('-') != std::string::npos)
         nodashsug = 0;
     }
 
     size_t prev_pos = 0;
     bool last = false;
 
     while (!good && nodashsug && !last) {
       if (dash_pos == scw.size())
         last = 1;
       std::string chunk = scw.substr(prev_pos, dash_pos - prev_pos);
       if (chunk != word && !spell(chunk, spell_candidate_stack)) {
         std::vector<std::string> nlst = suggest(chunk, suggest_candidate_stack);
         if (clock() > timelimit + TIMELIMIT_GLOBAL)
             return slst;
-        for (std::vector<std::string>::reverse_iterator j = nlst.rbegin(); j != nlst.rend(); ++j) {
+        for (auto j = nlst.rbegin(); j != nlst.rend(); ++j) {
           std::string wspace = scw.substr(0, prev_pos);
           wspace.append(*j);
           if (!last) {
             wspace.append("-");
             wspace.append(scw.substr(dash_pos + 1));
           }
           int info = 0;
           if (pAMgr && pAMgr->get_forbiddenword())
             checkword(wspace, &info, NULL);
           if (!(info & SPELL_FORBIDDEN))
             insert_sug(slst, wspace);
         }
         nodashsug = 0;
       }
       if (!last) {
         prev_pos = dash_pos + 1;
         dash_pos = scw.find('-', prev_pos);
       }
       if (dash_pos == std::string::npos)
         dash_pos = scw.size();
     }
   }
   return slst;
 }
@@ -1313,67 +1310,66 @@ const std::string& HunspellImpl::get_dict_encoding() const {
 std::vector<std::string> HunspellImpl::stem(const std::vector<std::string>& desc) {
   std::vector<std::string> slst;
 
   std::string result2;
   if (desc.empty())
     return slst;
-  for (size_t i = 0; i < desc.size(); ++i) {
-
+  for (const auto& i : desc) {
     std::string result;
 
     // add compound word parts (except the last one)
-    const char* s = desc[i].c_str();
+    const char* s = i.c_str();
     const char* part = strstr(s, MORPH_PART);
     if (part) {
       const char* nextpart = strstr(part + 1, MORPH_PART);
       while (nextpart) {
         std::string field;
         copy_field(field, part, MORPH_PART);
         result.append(field);
         part = nextpart;
         nextpart = strstr(part + 1, MORPH_PART);
       }
       s = part;
     }
 
     std::string tok(s);
     size_t alt = 0;
     while ((alt = tok.find(" | ", alt)) != std::string::npos) {
       tok[alt + 1] = MSEP_ALT;
     }
     std::vector<std::string> pl = line_tok(tok, MSEP_ALT);
-    for (size_t k = 0; k < pl.size(); ++k) {
+    for (auto& k : pl) {
       // add derivational suffixes
-      if (pl[k].find(MORPH_DERI_SFX) != std::string::npos) {
+      if (k.find(MORPH_DERI_SFX) != std::string::npos) {
         // remove inflectional suffixes
-        const size_t is = pl[k].find(MORPH_INFL_SFX);
+        const size_t is = k.find(MORPH_INFL_SFX);
         if (is != std::string::npos)
-          pl[k].resize(is);
+	        k.resize(is);
         std::vector<std::string> singlepl;
-        singlepl.push_back(pl[k]);
-        std::string sg = pSMgr->suggest_gen(singlepl, pl[k]);
+        singlepl.push_back(k);
+        std::string sg = pSMgr->suggest_gen(singlepl, k);
         if (!sg.empty()) {
           std::vector<std::string> gen = line_tok(sg, MSEP_REC);
-          for (size_t j = 0; j < gen.size(); ++j) {
+          for (auto& j : gen) {
             result2.push_back(MSEP_REC);
             result2.append(result);
-            result2.append(gen[j]);
+            result2.append(j);
           }
         }
       } else {
         result2.push_back(MSEP_REC);
         result2.append(result);
-        if (pl[k].find(MORPH_SURF_PFX) != std::string::npos) {
+        if (k.find(MORPH_SURF_PFX) != std::string::npos) {
           std::string field;
-          copy_field(field, pl[k], MORPH_SURF_PFX);
+          copy_field(field, k, MORPH_SURF_PFX);
           result2.append(field);
         }
         std::string field;
-        copy_field(field, pl[k], MORPH_STEM);
+        copy_field(field, k, MORPH_STEM);
         result2.append(field);
       }
     }
   }
   slst = line_tok(result2, MSEP_REC);
   uniqlist(slst);
   return slst;
 }
@@ -1471,235 +1467,233 @@ std::vector<std::string> HunspellImpl::analyze(const std::string& word) {
 }
 
 std::vector<std::string> HunspellImpl::analyze_internal(const std::string& word) {
-  std::vector<std::string> candidate_stack;
-  std::vector<std::string> slst;
+  std::vector<std::string> candidate_stack, slst;
   if (!pSMgr || m_HMgrs.empty())
     return slst;
   if (utf8) {
     if (word.size() >= MAXWORDUTF8LEN)
       return slst;
   } else {
     if (word.size() >= MAXWORDLEN)
       return slst;
   }
   int captype = NOCAP;
   size_t abbv = 0;
   size_t wl = 0;
 
   std::string scw;
   std::vector<w_char> sunicw;
 
   // input conversion
   RepList* rl = (pAMgr) ? pAMgr->get_iconvtable() : NULL;
   {
     std::string wspace;
 
     bool convstatus = rl ? rl->conv(word, wspace) : false;
     if (convstatus)
       wl = cleanword2(scw, sunicw, wspace, &captype, &abbv);
     else
       wl = cleanword2(scw, sunicw, word, &captype, &abbv);
   }
 
   if (wl == 0) {
     if (abbv) {
       scw.clear();
       for (wl = 0; wl < abbv; wl++)
         scw.push_back('.');
       abbv = 0;
     } else
       return slst;
   }
 
   std::string result;
 
   size_t n = 0;
   // test numbers
   // LANG_hu section: set dash information for suggestions
   if (langnum == LANG_hu) {
     size_t n2 = 0;
     size_t n3 = 0;
 
     while ((n < wl) && (((scw[n] <= '9') && (scw[n] >= '0')) ||
                         (((scw[n] == '.') || (scw[n] == ',')) && (n > 0)))) {
       n++;
       if ((scw[n] == '.') || (scw[n] == ',')) {
         if (((n2 == 0) && (n > 3)) ||
             ((n2 > 0) && ((scw[n - 1] == '.') || (scw[n - 1] == ','))))
           break;
         n2++;
         n3 = n;
       }
     }
 
     if ((n == wl) && (n3 > 0) && (n - n3 > 3))
       return slst;
     if ((n == wl) || ((n > 0) && ((scw[n] == '%') || (scw[n] == '\xB0')) &&
                       checkword(scw.substr(n), NULL, NULL))) {
       result.append(scw);
       result.resize(n - 1);
       if (n == wl)
         cat_result(result, pSMgr->suggest_morph(scw.substr(n - 1)));
       else {
         std::string chunk = scw.substr(n - 1, 1);
         cat_result(result, pSMgr->suggest_morph(chunk));
         result.push_back('+');  // XXX SPEC. MORPHCODE
         cat_result(result, pSMgr->suggest_morph(scw.substr(n)));
       }
       return line_tok(result, MSEP_REC);
     }
   }
   // END OF LANG_hu section
 
   switch (captype) {
     case HUHCAP:
     case HUHINITCAP:
     case NOCAP: {
       cat_result(result, pSMgr->suggest_morph(scw));
       if (abbv) {
         std::string u8buffer(scw);
         u8buffer.push_back('.');
         cat_result(result, pSMgr->suggest_morph(u8buffer));
       }
       break;
     }
     case INITCAP: {
       mkallsmall2(scw, sunicw);
       std::string u8buffer(scw);
       mkinitcap2(scw, sunicw);
       cat_result(result, pSMgr->suggest_morph(u8buffer));
       cat_result(result, pSMgr->suggest_morph(scw));
       if (abbv) {
         u8buffer.push_back('.');
         cat_result(result, pSMgr->suggest_morph(u8buffer));
 
         u8buffer = scw;
         u8buffer.push_back('.');
 
         cat_result(result, pSMgr->suggest_morph(u8buffer));
       }
       break;
     }
     case ALLCAP: {
       cat_result(result, pSMgr->suggest_morph(scw));
       if (abbv) {
         std::string u8buffer(scw);
         u8buffer.push_back('.');
         cat_result(result, pSMgr->suggest_morph(u8buffer));
       }
       mkallsmall2(scw, sunicw);
       std::string u8buffer(scw);
       mkinitcap2(scw, sunicw);
 
       cat_result(result, pSMgr->suggest_morph(u8buffer));
       cat_result(result, pSMgr->suggest_morph(scw));
       if (abbv) {
         u8buffer.push_back('.');
         cat_result(result, pSMgr->suggest_morph(u8buffer));
 
         u8buffer = scw;
         u8buffer.push_back('.');
 
         cat_result(result, pSMgr->suggest_morph(u8buffer));
       }
       break;
     }
   }
 
   if (!result.empty()) {
     // word reversing wrapper for complex prefixes
     if (complexprefixes) {
       if (utf8)
         reverseword_utf(result);
       else
         reverseword(result);
     }
     return line_tok(result, MSEP_REC);
   }
 
   // compound word with dash (HU) I18n
   // LANG_hu section: set dash information for suggestions
 
   size_t dash_pos = langnum == LANG_hu ? scw.find('-') : std::string::npos;
   if (dash_pos != std::string::npos) {
     int nresult = 0;
 
-    std::string part1 = scw.substr(0, dash_pos);
-    std::string part2 = scw.substr(dash_pos+1);
+    std::string part1 = scw.substr(0, dash_pos), part2 = scw.substr(dash_pos + 1);
 
     // examine 2 sides of the dash
     if (part2.empty()) {  // base word ending with dash
       if (spell(part1, candidate_stack)) {
         std::string p = pSMgr->suggest_morph(part1);
         if (!p.empty()) {
           slst = line_tok(p, MSEP_REC);
           return slst;
         }
       }
     } else if (part2.size() == 1 && part2[0] == 'e') {  // XXX (HU) -e hat.
       if (spell(part1, candidate_stack) && (spell("-e", candidate_stack))) {
         std::string st = pSMgr->suggest_morph(part1);
         if (!st.empty()) {
           result.append(st);
         }
         result.push_back('+');  // XXX spec. separator in MORPHCODE
         st = pSMgr->suggest_morph("-e");
         if (!st.empty()) {
           result.append(st);
         }
         return line_tok(result, MSEP_REC);
       }
     } else {
       // first word ending with dash: word- XXX ???
       part1.push_back(' ');
       nresult = spell(part1, candidate_stack);
       part1.erase(part1.size() - 1);
       if (nresult && spell(part2, candidate_stack) &&
           ((part2.size() > 1) || ((part2[0] > '0') && (part2[0] < '9')))) {
         std::string st = pSMgr->suggest_morph(part1);
         if (!st.empty()) {
           result.append(st);
           result.push_back('+');  // XXX spec. separator in MORPHCODE
         }
         st = pSMgr->suggest_morph(part2);
         if (!st.empty()) {
           result.append(st);
         }
         return line_tok(result, MSEP_REC);
       }
     }
     // affixed number in correct word
     if (nresult && (dash_pos > 0) &&
         (((scw[dash_pos - 1] <= '9') && (scw[dash_pos - 1] >= '0')) ||
          (scw[dash_pos - 1] == '.'))) {
       n = 1;
       if (scw[dash_pos - n] == '.')
         n++;
       // search first not a number character to left from dash
       while ((dash_pos >= n) && ((scw[dash_pos - n] == '0') || (n < 3)) &&
              (n < 6)) {
         n++;
       }
       if (dash_pos < n)
         n--;
       // numbers: valami1000000-hoz
       // examine 100000-hoz, 10000-hoz 1000-hoz, 10-hoz,
       // 56-hoz, 6-hoz
       for (; n >= 1; n--) {
         if (scw[dash_pos - n] < '0' || scw[dash_pos - n] > '9') {
             continue;
         }
         std::string chunk = scw.substr(dash_pos - n);
         if (checkword(chunk, NULL, NULL)) {
           result.append(chunk);
           std::string st = pSMgr->suggest_morph(chunk);
           if (!st.empty()) {
             result.append(st);
           }
           return line_tok(result, MSEP_REC);
         }
       }
     }
   }
   return slst;
 }
@@ -1707,44 +1701,43 @@ std::vector<std::string> HunspellImpl::analyze_internal(const std::string& word)
 std::vector<std::string> HunspellImpl::generate(const std::string& word, const std::vector<std::string>& pl) {
   std::vector<std::string> slst;
   if (!pSMgr || pl.empty())
     return slst;
   std::vector<std::string> pl2 = analyze(word);
-  int captype = NOCAP;
-  int abbv = 0;
+  int captype = NOCAP, abbv = 0;
   std::string cw;
   cleanword(cw, word, &captype, &abbv);
   std::string result;
 
-  for (size_t i = 0; i < pl.size(); ++i) {
-    cat_result(result, pSMgr->suggest_gen(pl2, pl[i]));
+  for (const auto& i : pl) {
+    cat_result(result, pSMgr->suggest_gen(pl2, i));
   }
 
   if (!result.empty()) {
     // allcap
     if (captype == ALLCAP)
       mkallcap(result);
 
     // line split
     slst = line_tok(result, MSEP_REC);
 
     // capitalize
     if (captype == INITCAP || captype == HUHINITCAP) {
-      for (size_t j = 0; j < slst.size(); ++j) {
-        mkinitcap(slst[j]);
+      for (auto& str : slst) {
+        mkinitcap(str);
       }
     }
 
     // temporary filtering of prefix related errors (eg.
     // generate("undrinkable", "eats") --> "undrinkables" and "*undrinks")
-    std::vector<std::string>::iterator it = slst.begin();
+    auto it = slst.begin();
     while (it != slst.end()) {
       std::vector<std::string> candidate_stack;
       if (!spell(*it, candidate_stack)) {
         it = slst.erase(it);
       } else  {
         ++it;
       }
     }
   }
   return slst;
 }
@@ -1810,10 +1803,8 @@ std::string::size_type HunspellImpl::get_xml_pos(const std::string& s, std::stri
 int HunspellImpl::check_xml_par(const std::string& q, std::string::size_type pos,
                                 const char* attr,
                                 const char* value) {
-  std::string cw = get_xml_par(q, get_xml_pos(q, pos, attr));
-  if (cw == value)
-    return 1;
-  return 0;
+  const std::string cw = get_xml_par(q, get_xml_pos(q, pos, attr));
+  return cw == value ? 1 : 0;
 }
 
 std::vector<std::string> HunspellImpl::get_xml_list(const std::string& list, std::string::size_type pos, const char* tag) {
@@ -1837,82 +1828,81 @@ std::vector<std::string> HunspellImpl::get_xml_list(const std::string& list, std
 std::vector<std::string> HunspellImpl::spellml(const std::string& in_word) {
   std::vector<std::string> slst;
 
   std::string::size_type qpos = in_word.find("<query");
   if (qpos == std::string::npos)
     return slst;  // bad XML input
 
   std::string::size_type q2pos = in_word.find('>', qpos);
   if (q2pos == std::string::npos)
     return slst;  // bad XML input
 
   q2pos = in_word.find("<word", q2pos);
   if (q2pos == std::string::npos)
     return slst;  // bad XML input
 
   if (check_xml_par(in_word, qpos, "type=", "analyze")) {
     std::string cw = get_xml_par(in_word, in_word.find('>', q2pos));
     if (!cw.empty())
       slst = analyze(cw);
     if (slst.empty())
       return slst;
     // convert the result to <code><a>ana1</a><a>ana2</a></code> format
     std::string r;
     r.append("<code>");
-    for (size_t i = 0; i < slst.size(); ++i) {
+    for (auto entry : slst) {
       r.append("<a>");
 
-      std::string entry(slst[i]);
       mystrrep(entry, "\t", " ");
       mystrrep(entry, "&", "&amp;");
       mystrrep(entry, "<", "&lt;");
       r.append(entry);
 
       r.append("</a>");
     }
     r.append("</code>");
     slst.clear();
     slst.push_back(r);
     return slst;
   } else if (check_xml_par(in_word, qpos, "type=", "stem")) {
     std::string cw = get_xml_par(in_word, in_word.find('>', q2pos));
     if (!cw.empty())
       return stem(cw);
   } else if (check_xml_par(in_word, qpos, "type=", "generate")) {
     std::string cw = get_xml_par(in_word, in_word.find('>', q2pos));
     if (cw.empty())
       return slst;
     std::string::size_type q3pos = in_word.find("<word", q2pos + 1);
     if (q3pos != std::string::npos) {
       std::string cw2 = get_xml_par(in_word, in_word.find('>', q3pos));
       if (!cw2.empty()) {
         return generate(cw, cw2);
       }
     } else {
       q2pos = in_word.find("<code", q2pos + 1);
       if (q2pos != std::string::npos) {
         std::vector<std::string> slst2 = get_xml_list(in_word, in_word.find('>', q2pos), "<a>");
         if (!slst2.empty()) {
           slst = generate(cw, slst2);
           uniqlist(slst);
           return slst;
         }
       }
     }
   } else if (check_xml_par(in_word, qpos, "type=", "add")) {
     std::string cw = get_xml_par(in_word, in_word.find('>', q2pos));
     if (cw.empty())
       return slst;
     std::string::size_type q3pos = in_word.find("<word", q2pos + 1);
     if (q3pos != std::string::npos) {
       std::string cw2 = get_xml_par(in_word, in_word.find('>', q3pos));
       if (!cw2.empty()) {
         add_with_affix(cw, cw2);
       } else {
         add(cw);
       }
     } else {
         add(cw);
     }
   }
   return slst;
 }
@@ -2026,9 +2016,8 @@ int HunspellImpl::stem(char*** slst, const char* word) {
 int HunspellImpl::stem(char*** slst, char** desc, int n) {
   std::vector<std::string> morph;
   morph.reserve(n);
-  for (int i = 0; i < n; ++i)
-    morph.push_back(desc[i]);
+  for (int i = 0; i < n; ++i) morph.emplace_back(desc[i]);
 
   std::vector<std::string> stems = stem(morph);
   return munge_vector(slst, stems);
 }
@@ -2041,9 +2030,8 @@ int HunspellImpl::generate(char*** slst, const char* word, const char* pattern)
 int HunspellImpl::generate(char*** slst, const char* word, char** pl, int pln) {
   std::vector<std::string> morph;
   morph.reserve(pln);
-  for (int i = 0; i < pln; ++i)
-    morph.push_back(pl[i]);
+  for (int i = 0; i < pln; ++i) morph.emplace_back(pl[i]);
 
   std::vector<std::string> stems = generate(word, morph);
   return munge_vector(slst, stems);
 }
diff --git a/src/hunspell/hunspell.hxx b/src/hunspell/hunspell.hxx
index 8640a35..13d42d3 100644
--- a/src/hunspell/hunspell.hxx
+++ b/src/hunspell/hunspell.hxx
@@ -99,134 +99,132 @@
 class HunspellImpl;
 
 class LIBHUNSPELL_DLL_EXPORTED Hunspell {
- private:
-  Hunspell(const Hunspell&);
-  Hunspell& operator=(const Hunspell&);
-
  private:
   HunspellImpl* m_Impl;
 
  public:
   /* Hunspell(aff, dic) - constructor of Hunspell class
    * input: path of affix file and dictionary file
    *
    * In WIN32 environment, use UTF-8 encoded paths started with the long path
    * prefix \\\\?\\ to handle system-independent character encoding and very
    * long path names (without the long path prefix Hunspell will use fopen()
    * with system-dependent character encoding instead of _wfopen()).
    */
   Hunspell(const char* affpath, const char* dpath, const char* key = NULL);
+  Hunspell(const Hunspell&) = delete;
+  Hunspell& operator=(const Hunspell&) = delete;
   ~Hunspell();
 
   /* load extra dictionaries (only dic files) */
   int add_dic(const char* dpath, const char* key = NULL);
 
   /* spell(word) - spellcheck word
    * output: false = bad word, true = good word
    *
    * plus output:
    *   info: information bit array, fields:
    *     SPELL_COMPOUND  = a compound word
    *     SPELL_FORBIDDEN = an explicit forbidden word
    *   root: root (stem), when input is a word with affix(es)
    */
   bool spell(const std::string& word, int* info = NULL, std::string* root = NULL);
   H_DEPRECATED int spell(const char* word, int* info = NULL, char** root = NULL);
 
   /* suggest(suggestions, word) - search suggestions
    * input: pointer to an array of strings pointer and the (bad) word
    *   array of strings pointer (here *slst) may not be initialized
    * output: number of suggestions in string array, and suggestions in
    *   a newly allocated array of strings (*slts will be NULL when number
    *   of suggestion equals 0.)
    */
   std::vector<std::string> suggest(const std::string& word);
   H_DEPRECATED int suggest(char*** slst, const char* word);
 
   /* Suggest words from suffix rules
    * suffix_suggest(suggestions, root_word)
    * input: pointer to an array of strings pointer and the  word
    *   array of strings pointer (here *slst) may not be initialized
    * output: number of suggestions in string array, and suggestions in
    *   a newly allocated array of strings (*slts will be NULL when number
    *   of suggestion equals 0.)
    */
   std::vector<std::string> suffix_suggest(const std::string& root_word);
   H_DEPRECATED int suffix_suggest(char*** slst, const char* root_word);
 
   /* deallocate suggestion lists */
   H_DEPRECATED void free_list(char*** slst, int n);
 
   const std::string& get_dict_encoding() const;
   char* get_dic_encoding();
 
   /* morphological functions */
 
   /* analyze(result, word) - morphological analysis of the word */
   std::vector<std::string> analyze(const std::string& word);
   H_DEPRECATED int analyze(char*** slst, const char* word);
 
   /* stem(word) - stemmer function */
   std::vector<std::string> stem(const std::string& word);
   H_DEPRECATED int stem(char*** slst, const char* word);
 
   /* stem(analysis, n) - get stems from a morph. analysis
    * example:
    * char ** result, result2;
    * int n1 = analyze(&result, "words");
    * int n2 = stem(&result2, result, n1);
    */
   std::vector<std::string> stem(const std::vector<std::string>& morph);
   H_DEPRECATED int stem(char*** slst, char** morph, int n);
 
   /* generate(result, word, word2) - morphological generation by example(s) */
   std::vector<std::string> generate(const std::string& word, const std::string& word2);
   H_DEPRECATED int generate(char*** slst, const char* word, const char* word2);
 
   /* generate(result, word, desc, n) - generation by morph. description(s)
    * example:
    * char ** result;
    * char * affix = "is:plural"; // description depends from dictionaries, too
    * int n = generate(&result, "word", &affix, 1);
    * for (int i = 0; i < n; i++) printf("%s\n", result[i]);
    */
   std::vector<std::string> generate(const std::string& word, const std::vector<std::string>& pl);
   H_DEPRECATED int generate(char*** slst, const char* word, char** desc, int n);
 
   /* functions for run-time modification of the dictionary */
 
   /* add word to the run-time dictionary */
 
   int add(const std::string& word);
 
   /* add word to the run-time dictionary with affix flags of
    * the example (a dictionary word): Hunspell will recognize
    * affixed forms of the new word, too.
    */
 
   int add_with_affix(const std::string& word, const std::string& example);
 
   /* remove word from the run-time dictionary */
 
   int remove(const std::string& word);
 
   /* other */
 
   /* get extra word characters definied in affix file for tokenization */
   const char* get_wordchars() const;
   const std::string& get_wordchars_cpp() const;
   const std::vector<w_char>& get_wordchars_utf16() const;
 
   struct cs_info* get_csconv();
   
   const char* get_version() const;
   const std::string& get_version_cpp() const;
 
   int get_langnum() const;
 
   /* need for putdic */
   bool input_conv(const std::string& word, std::string& dest);
   H_DEPRECATED int input_conv(const char* word, char* dest, size_t destsize);
 };
 
 #endif
diff --git a/src/hunspell/hunzip.cxx b/src/hunspell/hunzip.cxx
index edbbad4..41c8b98 100644
--- a/src/hunspell/hunzip.cxx
+++ b/src/hunspell/hunzip.cxx
@@ -1,51 +1,51 @@
 /* ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
  * Copyright (C) 2002-2022 Németh László
  *
  * The contents of this file are subject to the Mozilla Public License Version
  * 1.1 (the "License"); you may not use this file except in compliance with
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * Hunspell is based on MySpell which is Copyright (C) 2002 Kevin Hendricks.
  *
  * Contributor(s): David Einstein, Davide Prina, Giuseppe Modugno,
  * Gianluca Turconi, Simon Brouwer, Noll János, Bíró Árpád,
  * Goldman Eleonóra, Sarlós Tamás, Bencsáth Boldizsár, Halácsy Péter,
  * Dvornik László, Gefferth András, Nagy Viktor, Varga Dániel, Chris Halls,
  * Rene Engelhard, Bram Moolenaar, Dafydd Jones, Harri Pitkänen
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
-#include <stdlib.h>
-#include <string.h>
-#include <stdio.h>
+#include <cstdlib>
+#include <cstring>
+#include <cstdio>
 
 #include "hunzip.hxx"
 #include "csutil.hxx"
 
 #define CODELEN 65536
 #define BASEBITREC 5000
 
 #define UNCOMPRESSED '\002'
 #define MAGIC "hz0"
 #define MAGIC_ENCRYPT "hz1"
 #define MAGICLEN (sizeof(MAGIC) - 1)
@@ -67,102 +67,101 @@ Hunzip::Hunzip(const char* file, const char* key)
 
 int Hunzip::getcode(const char* key) {
   unsigned char c[2];
-  int i, j, n;
-  int allocatedbit = BASEBITREC;
+  int i, j, n, allocatedbit = BASEBITREC;
   const char* enc = key;
 
   if (filename.empty())
     return -1;
 
   myopen(fin, filename.c_str(), std::ios_base::in | std::ios_base::binary);
   if (!fin.is_open())
     return -1;
 
   // read magic number
   if (!fin.read(in, 3) ||
       !(strncmp(MAGIC, in, MAGICLEN) == 0 ||
         strncmp(MAGIC_ENCRYPT, in, MAGICLEN) == 0)) {
     return fail(MSG_FORMAT, filename);
   }
 
   // check encryption
   if (strncmp(MAGIC_ENCRYPT, in, MAGICLEN) == 0) {
     unsigned char cs;
     if (!key)
       return fail(MSG_KEY, filename);
     if (!fin.read(reinterpret_cast<char*>(c), 1))
       return fail(MSG_FORMAT, filename);
     for (cs = 0; *enc; enc++)
       cs ^= *enc;
     if (cs != c[0])
       return fail(MSG_KEY, filename);
     enc = key;
   } else
     key = NULL;
 
   // read record count
   if (!fin.read(reinterpret_cast<char*>(c), 2))
     return fail(MSG_FORMAT, filename);
 
   if (key) {
     c[0] ^= *enc;
     if (*(++enc) == '\0')
       enc = key;
     c[1] ^= *enc;
   }
 
   n = ((int)c[0] << 8) + c[1];
   dec.resize(BASEBITREC);
   dec[0].v[0] = 0;
   dec[0].v[1] = 0;
 
   // read codes
   for (i = 0; i < n; i++) {
     unsigned char l;
     if (!fin.read(reinterpret_cast<char*>(c), 2))
       return fail(MSG_FORMAT, filename);
     if (key) {
       if (*(++enc) == '\0')
         enc = key;
       c[0] ^= *enc;
       if (*(++enc) == '\0')
         enc = key;
       c[1] ^= *enc;
     }
     if (!fin.read(reinterpret_cast<char*>(&l), 1))
       return fail(MSG_FORMAT, filename);
     if (key) {
       if (*(++enc) == '\0')
         enc = key;
       l ^= *enc;
     }
     if (!fin.read(in, (l >> 3) + 1))
       return fail(MSG_FORMAT, filename);
     if (key)
       for (j = 0; j <= (l >> 3); j++) {
         if (*(++enc) == '\0')
           enc = key;
         in[j] ^= *enc;
       }
     int p = 0;
     for (j = 0; j < l; j++) {
       int b = (in[(j >> 3)] & (1 << (7 - (j & 7)))) ? 1 : 0;
       int oldp = p;
       p = dec[p].v[b];
       if (p == 0) {
         lastbit++;
         if (lastbit == allocatedbit) {
           allocatedbit += BASEBITREC;
           dec.resize(allocatedbit);
         }
         dec[lastbit].v[0] = 0;
         dec[lastbit].v[1] = 0;
         dec[oldp].v[b] = lastbit;
         p = lastbit;
       }
     }
     dec[p].c[0] = c[0];
     dec[p].c[1] = c[1];
   }
   return 0;
 }
diff --git a/src/hunspell/hunzip.hxx b/src/hunspell/hunzip.hxx
index 05c72a0..5cd74b3 100644
--- a/src/hunspell/hunzip.hxx
+++ b/src/hunspell/hunzip.hxx
@@ -1,56 +1,56 @@
 /* ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
  * Copyright (C) 2002-2022 Németh László
  *
  * The contents of this file are subject to the Mozilla Public License Version
  * 1.1 (the "License"); you may not use this file except in compliance with
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * Hunspell is based on MySpell which is Copyright (C) 2002 Kevin Hendricks.
  *
  * Contributor(s): David Einstein, Davide Prina, Giuseppe Modugno,
  * Gianluca Turconi, Simon Brouwer, Noll János, Bíró Árpád,
  * Goldman Eleonóra, Sarlós Tamás, Bencsáth Boldizsár, Halácsy Péter,
  * Dvornik László, Gefferth András, Nagy Viktor, Varga Dániel, Chris Halls,
  * Rene Engelhard, Bram Moolenaar, Dafydd Jones, Harri Pitkänen
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 /* hunzip: file decompression for sorted dictionaries with optional encryption,
  * algorithm: prefix-suffix encoding and 16-bit Huffman encoding */
 
 #ifndef HUNZIP_HXX_
 #define HUNZIP_HXX_
 
 #include "hunvisapi.h"
 
-#include <stdio.h>
+#include <cstdio>
 #include <fstream>
 #include <vector>
 
 #define BUFSIZE 65536
 #define HZIP_EXTENSION ".hz"
 
 #define MSG_OPEN "error: %s: cannot open\n"
 #define MSG_FORMAT "error: %s: not in hzip format\n"
 #define MSG_MEMORY "error: %s: missing memory\n"
 #define MSG_KEY "error: %s: missing or bad password\n"
@@ -61,27 +61,25 @@ struct bit {
 };
 
 class LIBHUNSPELL_DLL_EXPORTED Hunzip {
- private:
-  Hunzip(const Hunzip&);
-  Hunzip& operator=(const Hunzip&);
-
  protected:
   std::string filename;
   std::ifstream fin;
   int bufsiz, lastbit, inc, inbits, outc;
   std::vector<bit> dec;     // code table
   char in[BUFSIZE];         // input buffer
   char out[BUFSIZE + 1];    // Huffman-decoded buffer
   char line[BUFSIZE + 50];  // decoded line
   int getcode(const char* key);
   int getbuf();
   int fail(const char* err, const std::string& par);
 
  public:
   Hunzip(const char* filename, const char* key = NULL);
+  Hunzip(const Hunzip&) = delete;
+  Hunzip& operator=(const Hunzip&) = delete;
   ~Hunzip();
   bool is_open() { return fin.is_open(); }
   bool getline(std::string& dest);
 };
 
 #endif
diff --git a/src/hunspell/phonet.cxx b/src/hunspell/phonet.cxx
index fd4b6b6..4f71e91 100644
--- a/src/hunspell/phonet.cxx
+++ b/src/hunspell/phonet.cxx
@@ -1,54 +1,52 @@
 /*  phonetic.c - generic replacement aglogithms for phonetic transformation
     Copyright (C) 2000 Bjoern Jacke
 
     This library is free software; you can redistribute it and/or
     modify it under the terms of the GNU Lesser General Public
     License version 2.1 as published by the Free Software Foundation;
 
     This library is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     Lesser General Public License for more details.
 
     You should have received a copy of the GNU Lesser General Public
     License along with this library; If not, see
     <http://www.gnu.org/licenses/>.
 
     Changelog:
 
     2000-01-05  Bjoern Jacke <bjoern at j3e.de>
                 Initial Release insprired by the article about phonetic
                 transformations out of c't 25/1999
 
     2007-07-26  Bjoern Jacke <bjoern at j3e.de>
                 Released under MPL/GPL/LGPL tri-license for Hunspell
 
     2007-08-23  Laszlo Nemeth <nemeth at OOo>
                 Porting from Aspell to Hunspell using C-like structs
 */
 
-#include <stdlib.h>
-#include <string.h>
-#include <stdio.h>
-#include <ctype.h>
+#include <cstdlib>
+#include <cstring>
+#include <cstdio>
+#include <cctype>
 
 #include "csutil.hxx"
 #include "phonet.hxx"
 
 void init_phonet_hash(phonetable& parms) {
-  for (int i = 0; i < HASHSIZE; i++) {
-    parms.hash[i] = -1;
-  }
+  memset(parms.hash, 0xff, HASHSIZE * sizeof(int));
 
   for (int i = 0; parms.rules[i][0] != '\0'; i += 2) {
     /**  set hash value  **/
     int k = (unsigned char)parms.rules[i][0];
 
     if (parms.hash[k] < 0) {
       parms.hash[k] = i;
     }
   }
 }
 
 // like strcpy but safe if the strings overlap
 //   but only if dest < src
@@ -67,205 +65,204 @@ static int myisalpha(char ch) {
 /*  Do phonetic transformation.                        */
 /*  phonetic transcription algorithm                   */
 /*  see: http://aspell.net/man-html/Phonetic-Code.html */
 /*  convert string to uppercase before this call       */
 std::string phonet(const std::string& inword, phonetable& parms) {
 
-  int i, k = 0, p, z;
-  int k0, n0, p0 = -333;
+  int i, k = 0, p, z, k0, n0, p0 = -333;
   char c;
   typedef unsigned char uchar;
 
   size_t len = inword.size();
   if (len > MAXPHONETUTF8LEN)
-    return std::string();
+    return {};
   char word[MAXPHONETUTF8LEN + 1];
   strncpy(word, inword.c_str(), MAXPHONETUTF8LEN);
   word[MAXPHONETUTF8LEN] = '\0';
 
   std::string target;
   /**  check word  **/
   i = z = 0;
   while ((c = word[i]) != '\0') {
     int n = parms.hash[(uchar)c];
     int z0 = 0;
 
     if (n >= 0 && !parms.rules[n].empty()) {
       /**  check all rules for the same letter  **/
       while (parms.rules[n][0] == c) {
         /**  check whole string  **/
         k = 1; /** number of found letters  **/
         p = 5; /** default priority  **/
         const char*s = parms.rules[n].c_str();
         s++; /**  important for (see below)  "*(s-1)"  **/
 
         while (*s != '\0' && word[i + k] == *s && !isdigit((unsigned char)*s) &&
                strchr("(-<^$", *s) == NULL) {
           k++;
           s++;
         }
         if (*s == '(') {
           /**  check letters in "(..)"  **/
           if (myisalpha(word[i + k])  // ...could be implied?
               && strchr(s + 1, word[i + k]) != NULL) {
             k++;
             while (*s && *s != ')')
               s++;
             if (*s == ')')
               s++;
           }
         }
         p0 = (int)*s;
         k0 = k;
         while (*s == '-' && k > 1) {
           k--;
           s++;
         }
         if (*s == '<')
           s++;
         if (isdigit((unsigned char)*s)) {
           /**  determine priority  **/
           p = *s - '0';
           s++;
         }
         if (*s == '^' && *(s + 1) == '^')
           s++;
 
         if (*s == '\0' || (*s == '^' && (i == 0 || !myisalpha(word[i - 1])) &&
                            (*(s + 1) != '$' || (!myisalpha(word[i + k0])))) ||
             (*s == '$' && i > 0 && myisalpha(word[i - 1]) &&
              (!myisalpha(word[i + k0])))) {
           /**  search for followup rules, if:     **/
           /**  parms.followup and k > 1  and  NO '-' in searchstring **/
           char c0 = word[i + k - 1];
           n0 = parms.hash[(uchar)c0];
 
           //            if (parms.followup  &&  k > 1  &&  n0 >= 0
           if (k > 1 && n0 >= 0 && p0 != (int)'-' && word[i + k] != '\0' && !parms.rules[n0].empty()) {
             /**  test follow-up rule for "word[i+k]"  **/
             while (parms.rules[n0][0] == c0) {
               /**  check whole string  **/
               k0 = k;
               p0 = 5;
               s = parms.rules[n0].c_str();
               s++;
               while (*s != '\0' && word[i + k0] == *s &&
                      !isdigit((unsigned char)*s) &&
                      strchr("(-<^$", *s) == NULL) {
                 k0++;
                 s++;
               }
               if (*s == '(') {
                 /**  check letters  **/
                 if (myisalpha(word[i + k0]) &&
                     strchr(s + 1, word[i + k0]) != NULL) {
                   k0++;
                   while (*s != ')' && *s != '\0')
                     s++;
                   if (*s == ')')
                     s++;
                 }
               }
               while (*s == '-') {
                 /**  "k0" gets NOT reduced   **/
                 /**  because "if (k0 == k)"  **/
                 s++;
               }
               if (*s == '<')
                 s++;
               if (isdigit((unsigned char)*s)) {
                 p0 = *s - '0';
                 s++;
               }
 
               if (*s == '\0'
                   /**  *s == '^' cuts  **/
                   || (*s == '$' && !myisalpha(word[i + k0]))) {
                 if (k0 == k) {
                   /**  this is just a piece of the string  **/
                   n0 += 2;
                   continue;
                 }
 
                 if (p0 < p) {
                   /**  priority too low  **/
                   n0 += 2;
                   continue;
                 }
                 /**  rule fits; stop search  **/
                 break;
               }
               n0 += 2;
             } /**  End of "while (parms.rules[n0][0] == c0)"  **/
 
             if (p0 >= p && parms.rules[n0][0] == c0) {
               n += 2;
               continue;
             }
           } /** end of follow-up stuff **/
 
           /**  replace string  **/
           s = parms.rules[n + 1].c_str();
           p0 = (!parms.rules[n].empty() &&
                 strchr(parms.rules[n].c_str() + 1, '<') != NULL)
                    ? 1
                    : 0;
           if (p0 == 1 && z == 0) {
             /**  rule with '<' is used  **/
             if (!target.empty() && *s != '\0' &&
                 (target[target.size()-1] == c || target[target.size()-1] == *s)) {
               target.erase(target.size() - 1);
             }
             z0 = 1;
             z = 1;
             k0 = 0;
             while (*s != '\0' && word[i + k0] != '\0') {
               word[i + k0] = *s;
               k0++;
               s++;
             }
             if (k > k0)
               strmove(&word[0] + i + k0, &word[0] + i + k);
 
             /**  new "actual letter"  **/
             c = word[i];
           } else { /** no '<' rule used **/
             i += k - 1;
             z = 0;
             while (*s != '\0' && *(s + 1) != '\0' && target.size() < len) {
               if (target.empty() || target[target.size()-1] != *s) {
                 target.push_back(*s);
               }
               s++;
             }
             /**  new "actual letter"  **/
             c = *s;
             if (!parms.rules[n].empty() &&
                 strstr(parms.rules[n].c_str() + 1, "^^") != NULL) {
               if (c != '\0') {
                 target.push_back(c);
               }
               strmove(&word[0], &word[0] + i + 1);
               i = 0;
               z0 = 1;
             }
           }
           break;
         } /** end of follow-up stuff **/
         n += 2;
       } /**  end of while (parms.rules[n][0] == c)  **/
     }   /**  end of if (n >= 0)  **/
     if (z0 == 0) {
       if (k && !p0 && target.size() < len && c != '\0') {
         /**  condense only double letters  **/
         target.push_back(c);
         /// printf("\n setting \n");
       }
 
       i++;
       z = 0;
       k = 0;
     }
   } /**  end of   while ((c = word[i]) != '\0')  **/
 
   return target;
 } /**  end of function "phonet"  **/
diff --git a/src/hunspell/replist.cxx b/src/hunspell/replist.cxx
index bbdaa0b..f3cde4d 100644
--- a/src/hunspell/replist.cxx
+++ b/src/hunspell/replist.cxx
@@ -81,8 +81,8 @@ RepList::RepList(int n) {
 }
 
 RepList::~RepList() {
-  for (size_t i = 0, pos = dat.size(); i < pos; ++i) {
-    delete dat[i];
+  for (auto& i : dat) {
+    delete i;
   }
 }
 
@@ -163,45 +163,45 @@ int RepList::add(const std::string& in_pat1, const std::string& pat2) {
 bool RepList::conv(const std::string& in_word, std::string& dest) {
   dest.clear();
 
-  size_t wordlen = in_word.size();
+  const size_t wordlen = in_word.size();
   const char* word = in_word.c_str();
 
   bool change = false;
   for (size_t i = 0; i < wordlen; ++i) {
     int n = find(word + i);
 
     bool empty = n < 0;
     if (empty) {
       dest.push_back(word[i]);
       continue;
     }
 
     std::string l = replace(wordlen - i, n, i == 0);
     if (l.empty()) {
       dest.push_back(word[i]);
       continue;
     }
 
     dest.append(l);
     if (!dat[n]->pattern.empty()) {
       i += dat[n]->pattern.size() - 1;
     }
     change = true;
   }
 
   return change;
 }
 
 bool RepList::check_against_breaktable(const std::vector<std::string>& breaktable) const {
-  for (size_t i = 0, pos = dat.size(); i < pos; ++i) {
-    for (int j = 0; j < 4; ++j) {
-      for (size_t k = 0; k < breaktable.size(); ++k) {
-        if (dat[i]->outstrings[j].find(breaktable[k]) != std::string::npos) {
+  for (const auto i : dat) {
+    for (auto& outstring : i->outstrings) {
+      for (const auto& str : breaktable) {
+        if (outstring.find(str) != std::string::npos) {
           return false;
         }
       }
     }
   }
 
   return true;
 }
diff --git a/src/hunspell/replist.hxx b/src/hunspell/replist.hxx
index e82940e..e3462b9 100644
--- a/src/hunspell/replist.hxx
+++ b/src/hunspell/replist.hxx
@@ -79,20 +79,18 @@
 
 class RepList {
  private:
-  RepList(const RepList&);
-  RepList& operator=(const RepList&);
-
   std::vector<replentry*> dat;
-
  public:
   explicit RepList(int n);
+  RepList(const RepList&) = delete;
+  RepList& operator=(const RepList&) = delete;
   ~RepList();
 
   bool check_against_breaktable(const std::vector<std::string>& breaktable) const;
 
   int add(const std::string& pat1, const std::string& pat2);
   int find(const char* word);
   std::string replace(const size_t wordlen, int n, bool atstart);
   bool conv(const std::string& word, std::string& dest);
 };
 #endif
diff --git a/src/hunspell/suggestmgr.cxx b/src/hunspell/suggestmgr.cxx
index a977330..b1d1568 100644
--- a/src/hunspell/suggestmgr.cxx
+++ b/src/hunspell/suggestmgr.cxx
@@ -1,79 +1,79 @@
 /* ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
  * Copyright (C) 2002-2022 Németh László
  *
  * The contents of this file are subject to the Mozilla Public License Version
  * 1.1 (the "License"); you may not use this file except in compliance with
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * Hunspell is based on MySpell which is Copyright (C) 2002 Kevin Hendricks.
  *
  * Contributor(s): David Einstein, Davide Prina, Giuseppe Modugno,
  * Gianluca Turconi, Simon Brouwer, Noll János, Bíró Árpád,
  * Goldman Eleonóra, Sarlós Tamás, Bencsáth Boldizsár, Halácsy Péter,
  * Dvornik László, Gefferth András, Nagy Viktor, Varga Dániel, Chris Halls,
  * Rene Engelhard, Bram Moolenaar, Dafydd Jones, Harri Pitkänen
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 /*
  * Copyright 2002 Kevin B. Hendricks, Stratford, Ontario, Canada
  * And Contributors.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  *
  * 3. All modifications to the source code must be clearly marked as
  *    such.  Binary redistributions based on modified source code
  *    must be clearly marked as modified versions in the documentation
  *    and/or other materials provided with the distribution.
  *
  * THIS SOFTWARE IS PROVIDED BY KEVIN B. HENDRICKS AND CONTRIBUTORS
  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
  * KEVIN B. HENDRICKS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
 
-#include <stdlib.h>
-#include <string.h>
-#include <stdio.h>
-#include <ctype.h>
-#include <time.h>
+#include <cstdlib>
+#include <cstring>
+#include <cstdio>
+#include <cctype>
+#include <ctime>
 
 #include "suggestmgr.hxx"
 #include "htypes.hxx"
 #include "csutil.hxx"
@@ -159,196 +159,190 @@ SuggestMgr::~SuggestMgr() {
 void SuggestMgr::testsug(std::vector<std::string>& wlst,
                         const std::string& candidate,
                         int cpdsuggest,
                         int* timer,
                         clock_t* timelimit) {
-  int cwrd = 1;
   if (wlst.size() == maxSug)
     return;
-  for (size_t k = 0; k < wlst.size(); ++k) {
-    if (wlst[k] == candidate) {
-      cwrd = 0;
-      break;
-    }
-  }
+
+  const int cwrd = std::find(wlst.begin(), wlst.end(), candidate) != wlst.end() ? 0 : 1;
+  
   if ((cwrd) && checkword(candidate, cpdsuggest, timer, timelimit)) {
     wlst.push_back(candidate);
   }
 }
 
 /* generate suggestions for a misspelled word
  *    pass in address of array of char * pointers
  * onlycompoundsug: probably bad suggestions (need for ngram sugs, too)
  * return value: true, if there is a good suggestion
  * (REP, ph: or a dictionary word pair)
  */
 bool SuggestMgr::suggest(std::vector<std::string>& slst,
                         const std::string& w,
                         int* onlycompoundsug) {
   int nocompoundtwowords = 0;
   std::vector<w_char> word_utf;
-  size_t nsugorig = slst.size();
+  size_t nsugorig = slst.size(), oldSug = 0;
   std::string w2;
-  size_t oldSug = 0;
   bool good_suggestion = false;
 
   // word reversing wrapper for complex prefixes
   if (complexprefixes) {
     w2.assign(w);
     if (utf8)
       reverseword_utf(w2);
     else
       reverseword(w2);
   }
 
   const std::string& word = complexprefixes ? w2 : w;
 
   if (utf8) {
     int wl = u8_u16(word_utf, word);
     if (wl == -1) {
       return false;
     }
   }
 
   for (int cpdsuggest = 0; (cpdsuggest < 2) && (nocompoundtwowords == 0) && !good_suggestion;
        cpdsuggest++) {
 
-    clock_t timelimit;
     // initialize both in non-compound and compound cycles
-    timelimit = clock();
+    clock_t timelimit = clock();
 
     // limit compound suggestion
     if (cpdsuggest > 0)
       oldSug = slst.size();
 
     // suggestions for an uppercase word (html -> HTML)
     if (slst.size() < maxSug) {
       size_t i = slst.size();
       if (utf8)
         capchars_utf(slst, word_utf, cpdsuggest);
       else
         capchars(slst, word, cpdsuggest);
       if (slst.size() > i)
         good_suggestion = true;
     }
 
     // perhaps we made a typical fault of spelling
     if ((slst.size() < maxSug) && (!cpdsuggest || (slst.size() < oldSug + maxcpdsugs))) {
       size_t i = slst.size();
       replchars(slst, word, cpdsuggest);
       if (slst.size() > i)
         good_suggestion = true;
     }
     if (clock() > timelimit + TIMELIMIT_SUGGESTION)
       return good_suggestion;
 
     // perhaps we made chose the wrong char from a related set
     if ((slst.size() < maxSug) &&
         (!cpdsuggest || (slst.size() < oldSug + maxcpdsugs))) {
       mapchars(slst, word, cpdsuggest);
     }
     if (clock() > timelimit + TIMELIMIT_SUGGESTION)
       return good_suggestion;
 
     // only suggest compound words when no other suggestion
     if ((cpdsuggest == 0) && (slst.size() > nsugorig))
       nocompoundtwowords = 1;
 
     // did we swap the order of chars by mistake
     if ((slst.size() < maxSug) && (!cpdsuggest || (slst.size() < oldSug + maxcpdsugs))) {
       if (utf8)
         swapchar_utf(slst, word_utf, cpdsuggest);
       else
         swapchar(slst, word, cpdsuggest);
     }
     if (clock() > timelimit + TIMELIMIT_SUGGESTION)
       return good_suggestion;
 
     // did we swap the order of non adjacent chars by mistake
     if ((slst.size() < maxSug) && (!cpdsuggest || (slst.size() < oldSug + maxcpdsugs))) {
       if (utf8)
         longswapchar_utf(slst, word_utf, cpdsuggest);
       else
         longswapchar(slst, word, cpdsuggest);
     }
     if (clock() > timelimit + TIMELIMIT_SUGGESTION)
       return good_suggestion;
 
     // did we just hit the wrong key in place of a good char (case and keyboard)
     if ((slst.size() < maxSug) && (!cpdsuggest || (slst.size() < oldSug + maxcpdsugs))) {
       if (utf8)
         badcharkey_utf(slst, word_utf, cpdsuggest);
       else
         badcharkey(slst, word, cpdsuggest);
     }
     if (clock() > timelimit + TIMELIMIT_SUGGESTION)
       return good_suggestion;
 
     // did we add a char that should not be there
     if ((slst.size() < maxSug) && (!cpdsuggest || (slst.size() < oldSug + maxcpdsugs))) {
       if (utf8)
         extrachar_utf(slst, word_utf, cpdsuggest);
       else
         extrachar(slst, word, cpdsuggest);
     }
     if (clock() > timelimit + TIMELIMIT_SUGGESTION)
       return good_suggestion;
 
     // did we forgot a char
     if ((slst.size() < maxSug) && (!cpdsuggest || (slst.size() < oldSug + maxcpdsugs))) {
       if (utf8)
         forgotchar_utf(slst, word_utf, cpdsuggest);
       else
         forgotchar(slst, word, cpdsuggest);
     }
     if (clock() > timelimit + TIMELIMIT_SUGGESTION)
       return good_suggestion;
 
     // did we move a char
     if ((slst.size() < maxSug) && (!cpdsuggest || (slst.size() < oldSug + maxcpdsugs))) {
       if (utf8)
         movechar_utf(slst, word_utf, cpdsuggest);
       else
         movechar(slst, word, cpdsuggest);
     }
     if (clock() > timelimit + TIMELIMIT_SUGGESTION)
       return good_suggestion;
 
     // did we just hit the wrong key in place of a good char
     if ((slst.size() < maxSug) && (!cpdsuggest || (slst.size() < oldSug + maxcpdsugs))) {
       if (utf8)
         badchar_utf(slst, word_utf, cpdsuggest);
       else
         badchar(slst, word, cpdsuggest);
     }
     if (clock() > timelimit + TIMELIMIT_SUGGESTION)
       return good_suggestion;
 
     // did we double two characters
     if ((slst.size() < maxSug) && (!cpdsuggest || (slst.size() < oldSug + maxcpdsugs))) {
       if (utf8)
         doubletwochars_utf(slst, word_utf, cpdsuggest);
       else
         doubletwochars(slst, word, cpdsuggest);
     }
     if (clock() > timelimit + TIMELIMIT_SUGGESTION)
       return good_suggestion;
 
     // perhaps we forgot to hit space and two words ran together
     // (dictionary word pairs have top priority here, so
     // we always suggest them, in despite of nosplitsugs, and
     // drop compound word and other suggestions)
     if (!cpdsuggest || (!nosplitsugs && slst.size() < oldSug + maxcpdsugs)) {
       good_suggestion = twowords(slst, word, cpdsuggest, good_suggestion);
     }
     if (clock() > timelimit + TIMELIMIT_SUGGESTION)
       return good_suggestion;
 
   }  // repeating ``for'' statement compounding support
 
   if (!nocompoundtwowords && (!slst.empty()) && onlycompoundsug)
     *onlycompoundsug = 1;
 
   return good_suggestion;
 }
 
 // suggestions for an uppercase word (html -> HTML)
@@ -395,112 +389,106 @@ int SuggestMgr::mapchars(std::vector<std::string>& wlst,
 int SuggestMgr::map_related(const std::string& word,
                             std::string& candidate,
                             size_t wn,
                             std::vector<std::string>& wlst,
                             int cpdsuggest,
                             const std::vector<mapentry>& maptable,
                             int* timer,
                             clock_t* timelimit,
                             int depth) {
   if (word.size() == wn) {
-    int cwrd = 1;
-    for (size_t m = 0; m < wlst.size(); ++m) {
-      if (wlst[m] == candidate) {
-        cwrd = 0;
-        break;
-      }
-    }
+    const int cwrd = std::find(wlst.begin(), wlst.end(), candidate) != wlst.end() ? 0 : 1;
     if ((cwrd) && checkword(candidate, cpdsuggest, timer, timelimit)) {
       if (wlst.size() < maxSug) {
         wlst.push_back(candidate);
       }
     }
     return wlst.size();
   }
 
   if (depth > 16384) {
     *timer = 0;
     return wlst.size();
   }
 
   int in_map = 0;
   for (size_t j = 0; j < maptable.size(); ++j) {
     for (size_t k = 0; k < maptable[j].size(); ++k) {
       size_t len = maptable[j][k].size();
       if (len && word.compare(wn, len, maptable[j][k]) == 0) {
         in_map = 1;
         size_t cn = candidate.size();
         for (size_t l = 0; l < maptable[j].size(); ++l) {
           candidate.resize(cn);
           candidate.append(maptable[j][l]);
           map_related(word, candidate, wn + len, wlst,
                            cpdsuggest, maptable, timer, timelimit, depth + 1);
           if (!(*timer))
             return wlst.size();
         }
       }
     }
   }
   if (!in_map) {
     candidate.push_back(word[wn]);
     map_related(word, candidate, wn + 1, wlst, cpdsuggest,
                 maptable, timer, timelimit, depth + 1);
   }
   return wlst.size();
 }
 
 // suggestions for a typical fault of spelling, that
 // differs with more, than 1 letter from the right form.
 int SuggestMgr::replchars(std::vector<std::string>& wlst,
                           const std::string& word,
                           int cpdsuggest) {
   std::string candidate;
   int wl = word.size();
   if (wl < 2 || !pAMgr)
     return wlst.size();
   const std::vector<replentry>& reptable = pAMgr->get_reptable();
-  for (size_t i = 0; i < reptable.size(); ++i) {
+  for (const auto& entry : reptable) {
     size_t r = 0;
     // search every occurence of the pattern in the word
-    while ((r = word.find(reptable[i].pattern, r)) != std::string::npos) {
+    while ((r = word.find(entry.pattern, r)) != std::string::npos) {
       int type = (r == 0) ? 1 : 0;
-      if (r + reptable[i].pattern.size() == word.size())
+      if (r + entry.pattern.size() == word.size())
         type += 2;
-      while (type && reptable[i].outstrings[type].empty())
+      while (type && entry.outstrings[type].empty())
         type = (type == 2 && r != 0) ? 0 : type - 1;
-      const std::string&out = reptable[i].outstrings[type];
+      const std::string&out = entry.outstrings[type];
       if (out.empty()) {
         ++r;
         continue;
       }
       candidate.assign(word, 0, r);
-      candidate.append(reptable[i].outstrings[type]);
-      candidate.append(word, r + reptable[i].pattern.size(), std::string::npos);
+      candidate.append(entry.outstrings[type]);
+      candidate.append(word, r + entry.pattern.size(), std::string::npos);
       testsug(wlst, candidate, cpdsuggest, NULL, NULL);
       // check REP suggestions with space
       size_t sp = candidate.find(' ');
       if (sp != std::string::npos) {
         size_t prev = 0;
         while (sp != std::string::npos) {
           std::string prev_chunk = candidate.substr(prev, sp - prev);
           if (checkword(prev_chunk, 0, NULL, NULL)) {
             size_t oldns = wlst.size();
             std::string post_chunk = candidate.substr(sp + 1);
             testsug(wlst, post_chunk, cpdsuggest, NULL, NULL);
             if (oldns < wlst.size()) {
               wlst[wlst.size() - 1] = candidate;
             }
           }
           prev = sp + 1;
           sp = candidate.find(' ', prev);
         }
       }
       r++;  // search for the next letter
     }
   }
   return wlst.size();
 }
 
 // perhaps we doubled two characters
 // (for example vacation -> vacacation)
 // The recognized pattern with regex back-references:
 // "(.)(.)\1\2\1" or "..(.)(.)\1\2"
@@ -783,119 +771,109 @@ int SuggestMgr::forgotchar_utf(std::vector<std::string>& wlst,
 /* error is should have been two words
  * return value is true, if there is a dictionary word pair,
  * or there was already a good suggestion before calling
  * this function.
  */
 bool SuggestMgr::twowords(std::vector<std::string>& wlst,
                          const std::string& word,
                          int cpdsuggest,
                          bool good) {
-  int c2;
-  int forbidden = 0;
-  int cwrd;
-
-  int wl = word.size();
+  int c2, forbidden = 0, cwrd, wl = word.size();
   if (wl < 3)
     return false;
 
   if (langnum == LANG_hu)
     forbidden = check_forbidden(word);
 
   char* candidate = new char[wl + 2];
   memcpy(candidate + 1, word.data(), wl);
   candidate[wl + 1] = 0;
 
   // split the string into two pieces after every char
   // if both pieces are good words make them a suggestion
   for (char* p = candidate + 1; p[1] != '\0'; p++) {
     p[-1] = *p;
     // go to end of the UTF-8 character
     while (utf8 && ((p[1] & 0xc0) == 0x80)) {
       *p = p[1];
       p++;
     }
     if (utf8 && p[1] == '\0')
       break;  // last UTF-8 character
 
     // Suggest only word pairs, if they are listed in the dictionary.
     // For example, adding "a lot" to the English dic file will
     // result only "alot" -> "a lot" suggestion instead of
     // "alto, slot, alt, lot, allot, aloft, aloe, clot, plot, blot, a lot".
     // Note: using "ph:alot" keeps the other suggestions:
     // a lot ph:alot
     // alot -> a lot, alto, slot...
     *p = ' ';
     if (!cpdsuggest && checkword(candidate, cpdsuggest, NULL, NULL)) {
       // remove not word pair suggestions
       if (!good) {
         good = true;
         wlst.clear();
       }
       wlst.insert(wlst.begin(), candidate);
     }
 
     // word pairs with dash?
     if (lang_with_dash_usage) {
       *p = '-';
 
       if (!cpdsuggest && checkword(candidate, cpdsuggest, NULL, NULL)) {
         // remove not word pair suggestions
         if (!good) {
           good = true;
           wlst.clear();
         }
         wlst.insert(wlst.begin(), candidate);
       }
     }
 
     if (wlst.size() < maxSug && !nosplitsugs && !good) {
       *p = '\0';
       int c1 = checkword(candidate, cpdsuggest, NULL, NULL);
       if (c1) {
         c2 = checkword((p + 1), cpdsuggest, NULL, NULL);
         if (c2) {
           // spec. Hungarian code (TODO need a better compound word support)
           if ((langnum == LANG_hu) && !forbidden &&
               // if 3 repeating letter, use - instead of space
               (((p[-1] == p[1]) &&
               (((p > candidate + 1) && (p[-1] == p[-2])) || (p[-1] == p[2]))) ||
               // or multiple compounding, with more, than 6 syllables
               ((c1 == 3) && (c2 >= 2))))
             *p = '-';
           else
             *p = ' ';
 
-          cwrd = 1;
-          for (size_t k = 0; k < wlst.size(); ++k) {
-            if (wlst[k] == candidate) {
-              cwrd = 0;
-              break;
-            }
-          }
+          cwrd = std::find(wlst.begin(), wlst.end(), candidate) != wlst.end() ? 0 : 1;
 
           if (cwrd && (wlst.size() < maxSug))
-              wlst.push_back(candidate);
+              wlst.emplace_back(candidate);
 
           // add two word suggestion with dash, depending on the language
           // Note that cwrd doesn't modified for REP twoword sugg.
           if ( !nosplitsugs && lang_with_dash_usage &&
               mystrlen(p + 1) > 1 && mystrlen(candidate) - mystrlen(p) > 1) {
             *p = '-';
-            for (size_t k = 0; k < wlst.size(); ++k) {
-              if (wlst[k] == candidate) {
+            for (auto& k : wlst) {
+              if (k == candidate) {
                 cwrd = 0;
                 break;
               }
             }
 
             if ((wlst.size() < maxSug) && cwrd)
-              wlst.push_back(candidate);
+              wlst.emplace_back(candidate);
           }
         }
       }
     }
   }
   delete[] candidate;
   return good;
 }
 
 // error is adjacent letter were swapped
@@ -976,655 +954,652 @@ int SuggestMgr::swapchar_utf(std::vector<std::string>& wlst,
 // error is not adjacent letter were swapped
 int SuggestMgr::longswapchar(std::vector<std::string>& wlst,
                              const std::string& word,
                              int cpdsuggest) {
   std::string candidate(word);
   // try swapping not adjacent chars one by one
-  for (std::string::iterator p = candidate.begin(); p < candidate.end(); ++p) {
-    for (std::string::iterator q = candidate.begin(); q < candidate.end(); ++q) {
-      size_t distance = std::abs(std::distance(q, p));
+  for (auto p = candidate.begin(); p < candidate.end(); ++p) {
+    for (auto q = candidate.begin(); q < candidate.end(); ++q) {
+      const auto distance = std::abs(std::distance(q, p));
       if (distance > 1 && distance <= MAX_CHAR_DISTANCE) {
         std::swap(*p, *q);
         testsug(wlst, candidate, cpdsuggest, NULL, NULL);
         std::swap(*p, *q);
       }
     }
   }
   return wlst.size();
 }
 
 // error is adjacent letter were swapped
 int SuggestMgr::longswapchar_utf(std::vector<std::string>& wlst,
                                  const std::vector<w_char>& word,
                                  int cpdsuggest) {
   std::vector<w_char> candidate_utf(word);
   // try swapping not adjacent chars
-  for (std::vector<w_char>::iterator p = candidate_utf.begin(); p < candidate_utf.end(); ++p) {
-    for (std::vector<w_char>::iterator q = candidate_utf.begin(); q < candidate_utf.end(); ++q) {
-      size_t distance = std::abs(std::distance(q, p));
+  for (auto p = candidate_utf.begin(); p < candidate_utf.end(); ++p) {
+    for (auto q = candidate_utf.begin(); q < candidate_utf.end(); ++q) {
+      const auto distance = std::abs(std::distance(q, p));
       if (distance > 1 && distance <= MAX_CHAR_DISTANCE) {
         std::swap(*p, *q);
         std::string candidate;
         u16_u8(candidate, candidate_utf);
         testsug(wlst, candidate, cpdsuggest, NULL, NULL);
         std::swap(*p, *q);
       }
     }
   }
   return wlst.size();
 }
 
 // error is a letter was moved
 int SuggestMgr::movechar(std::vector<std::string>& wlst,
                          const std::string& word,
                          int cpdsuggest) {
   if (word.size() < 2)
     return wlst.size();
 
   std::string candidate(word);
 
   // try moving a char
-  for (std::string::iterator p = candidate.begin(); p < candidate.end(); ++p) {
-    for (std::string::iterator q = p + 1; q < candidate.end() && std::distance(p, q) <= MAX_CHAR_DISTANCE; ++q) {
+  for (auto p = candidate.begin(); p < candidate.end(); ++p) {
+    for (auto q = p + 1; q < candidate.end() && std::distance(p, q) <= MAX_CHAR_DISTANCE; ++q) {
       std::swap(*q, *(q - 1));
       if (std::distance(p, q) < 2)
         continue;  // omit swap char
       testsug(wlst, candidate, cpdsuggest, NULL, NULL);
     }
-    auto word_iter = word.begin();
-    std::copy(word_iter, word_iter + candidate.size(), candidate.begin());
+    const auto word_iter = word.begin();
+    std::copy_n(word_iter, candidate.size(), candidate.begin());
   }
 
-  for (std::string::reverse_iterator p = candidate.rbegin(), pEnd = candidate.rend() - 1; p != pEnd; ++p) {
-    for (std::string::reverse_iterator q = p + 1, qEnd = candidate.rend(); q != qEnd && std::distance(p, q) <= MAX_CHAR_DISTANCE; ++q) {
+  for (auto p = candidate.rbegin(), pEnd = candidate.rend() - 1; p != pEnd; ++p) {
+    for (auto q = p + 1, qEnd = candidate.rend(); q != qEnd && std::distance(p, q) <= MAX_CHAR_DISTANCE; ++q) {
       std::swap(*q, *(q - 1));
       if (std::distance(p, q) < 2)
         continue;  // omit swap char
       testsug(wlst, candidate, cpdsuggest, NULL, NULL);
     }
-    auto word_iter = word.begin();
-    std::copy(word_iter, word_iter + candidate.size(), candidate.begin());
+    const auto word_iter = word.begin();
+    std::copy_n(word_iter, candidate.size(), candidate.begin());
   }
 
   return wlst.size();
 }
 
 // error is a letter was moved
 int SuggestMgr::movechar_utf(std::vector<std::string>& wlst,
                              const std::vector<w_char>& word,
                              int cpdsuggest) {
   if (word.size() < 2)
     return wlst.size();
 
   std::vector<w_char> candidate_utf(word);
 
   // try moving a char
-  for (std::vector<w_char>::iterator p = candidate_utf.begin(); p < candidate_utf.end(); ++p) {
-    for (std::vector<w_char>::iterator q = p + 1; q < candidate_utf.end() && std::distance(p, q) <= MAX_CHAR_DISTANCE; ++q) {
+  for (auto p = candidate_utf.begin(); p < candidate_utf.end(); ++p) {
+    for (auto q = p + 1; q < candidate_utf.end() && std::distance(p, q) <= MAX_CHAR_DISTANCE; ++q) {
       std::swap(*q, *(q - 1));
       if (std::distance(p, q) < 2)
         continue;  // omit swap char
       std::string candidate;
       u16_u8(candidate, candidate_utf);
       testsug(wlst, candidate, cpdsuggest, NULL, NULL);
     }
-    auto word_iter = word.begin();
-    std::copy(word_iter, word_iter + candidate_utf.size(), candidate_utf.begin());
+    const auto word_iter = word.begin();
+    std::copy_n(word_iter, candidate_utf.size(), candidate_utf.begin());
   }
 
-  for (std::vector<w_char>::reverse_iterator p = candidate_utf.rbegin(); p < candidate_utf.rend(); ++p) {
-    for (std::vector<w_char>::reverse_iterator q = p + 1; q < candidate_utf.rend() && std::distance(p, q) <= MAX_CHAR_DISTANCE; ++q) {
+  for (auto p = candidate_utf.rbegin(); p < candidate_utf.rend(); ++p) {
+    for (auto q = p + 1; q < candidate_utf.rend() && std::distance(p, q) <= MAX_CHAR_DISTANCE; ++q) {
       std::swap(*q, *(q - 1));
       if (std::distance(p, q) < 2)
         continue;  // omit swap char
       std::string candidate;
       u16_u8(candidate, candidate_utf);
       testsug(wlst, candidate, cpdsuggest, NULL, NULL);
     }
-    auto word_iter = word.begin();
-    std::copy(word_iter, word_iter + candidate_utf.size(), candidate_utf.begin());
+    const auto word_iter = word.begin();
+    std::copy_n(word_iter, candidate_utf.size(), candidate_utf.begin());
   }
 
   return wlst.size();
 }
 
 // generate a set of suggestions for very poorly spelled words
 void SuggestMgr::ngsuggest(std::vector<std::string>& wlst,
                           const char* w,
                           const std::vector<HashMgr*>& rHMgr,
                           int captype) {
-  int lval;
-  int sc;
-  int lp, lpphon;
-  int nonbmp = 0;
+  int lval, sc, lp, lpphon, nonbmp = 0;
 
   // exhaustively search through all root words
   // keeping track of the MAX_ROOTS most similar root words
   struct hentry* roots[MAX_ROOTS];
   char* rootsphon[MAX_ROOTS];
   int scores[MAX_ROOTS];
   int scoresphon[MAX_ROOTS];
   for (int i = 0; i < MAX_ROOTS; i++) {
     roots[i] = NULL;
     scores[i] = -100 * i;
     rootsphon[i] = NULL;
     scoresphon[i] = -100 * i;
   }
   lp = MAX_ROOTS - 1;
   lpphon = MAX_ROOTS - 1;
   int low = NGRAM_LOWERING;
 
   std::string w2;
   const char* word = w;
 
   // word reversing wrapper for complex prefixes
   if (complexprefixes) {
     w2.assign(w);
     if (utf8)
       reverseword_utf(w2);
     else
       reverseword(w2);
     word = w2.c_str();
   }
 
   std::vector<w_char> u8;
   int nc = strlen(word);
   int n = (utf8) ? u8_u16(u8, word) : nc;
 
   // set character based ngram suggestion for words with non-BMP Unicode
   // characters
   struct cs_info* origconv = csconv;
   if (n == -1) {
     utf8 = 0;  // XXX not state-free
     if (!csconv)
       csconv = get_current_cs("iso88591"); // XXX not state-free
     n = nc;
     nonbmp = 1;
     low = 0;
   }
 
   struct hentry* hp = NULL;
   int col = -1;
   phonetable* ph = (pAMgr) ? pAMgr->get_phonetable() : NULL;
   std::string target;
   std::string candidate;
   std::vector<w_char> w_candidate;
   if (ph) {
     if (utf8) {
       u8_u16(w_candidate, word);
       mkallcap_utf(w_candidate, langnum);
       u16_u8(candidate, w_candidate);
     } else {
       candidate.assign(word);
       if (!nonbmp)
         mkallcap(candidate, csconv);
     }
     target = phonet(candidate, *ph);  // XXX phonet() is 8-bit (nc, not n)
   }
 
   FLAG forbiddenword = pAMgr ? pAMgr->get_forbiddenword() : FLAG_NULL;
   FLAG nosuggest = pAMgr ? pAMgr->get_nosuggest() : FLAG_NULL;
   FLAG nongramsuggest = pAMgr ? pAMgr->get_nongramsuggest() : FLAG_NULL;
   FLAG onlyincompound = pAMgr ? pAMgr->get_onlyincompound() : FLAG_NULL;
 
   std::vector<w_char> w_word, w_target;
   if (utf8) {
     u8_u16(w_word, word);
     u8_u16(w_target, target);
   }
 
   std::string f;
   std::vector<w_char> w_f;
 
   for (size_t i = 0; i < rHMgr.size(); ++i) {
     while (0 != (hp = rHMgr[i]->walk_hashtable(col, hp))) {
       // skip exceptions
       if (
            // skip it, if the word length different by 5 or
            // more characters (to avoid strange suggestions)
            // (except Unicode characters over BMP)
            (((abs(n - hp->clen) > 4) && !nonbmp)) ||
            // don't suggest capitalized dictionary words for
            // lower case misspellings in ngram suggestions, except
            // - PHONE usage, or
            // - in the case of German, where not only proper
            //   nouns are capitalized, or
            // - the capitalized word has special pronunciation
            ((captype == NOCAP) && (hp->var & H_OPT_INITCAP) &&
               !ph && (langnum != LANG_de) && !(hp->var & H_OPT_PHON)) ||
            // or it has one of the following special flags
            ((hp->astr) && (pAMgr) &&
              (TESTAFF(hp->astr, forbiddenword, hp->alen) ||
              TESTAFF(hp->astr, ONLYUPCASEFLAG, hp->alen) ||
              TESTAFF(hp->astr, nosuggest, hp->alen) ||
              TESTAFF(hp->astr, nongramsuggest, hp->alen) ||
              TESTAFF(hp->astr, onlyincompound, hp->alen)))
          )
         continue;
 
       if (utf8) {
         u8_u16(w_f, HENTRY_WORD(hp));
 
         int leftcommon = leftcommonsubstring(w_word, w_f);
         if (low) {
           // lowering dictionary word
           mkallsmall_utf(w_f, langnum);
         }
         sc = ngram(3, w_word, w_f, NGRAM_LONGER_WORSE) + leftcommon;
       } else {
         f.assign(HENTRY_WORD(hp));
 
         int leftcommon = leftcommonsubstring(word, f.c_str());
         if (low) {
           // lowering dictionary word
           mkallsmall(f, csconv);
         }
         sc = ngram(3, word, f, NGRAM_LONGER_WORSE) + leftcommon;
       }
 
       // check special pronunciation
       f.clear();
       if ((hp->var & H_OPT_PHON) &&
           copy_field(f, HENTRY_DATA(hp), MORPH_PHON)) {
         int sc2;
         if (utf8) {
           u8_u16(w_f, f);
 
           int leftcommon = leftcommonsubstring(w_word, w_f);
           if (low) {
             // lowering dictionary word
             mkallsmall_utf(w_f, langnum);
           }
           sc2 = ngram(3, w_word, w_f, NGRAM_LONGER_WORSE) + leftcommon;
         } else {
           int leftcommon = leftcommonsubstring(word, f.c_str());
           if (low) {
             // lowering dictionary word
             mkallsmall(f, csconv);
           }
           sc2 = ngram(3, word, f, NGRAM_LONGER_WORSE) + leftcommon;
         }
         if (sc2 > sc)
           sc = sc2;
       }
 
       int scphon = -20000;
       if (ph && (sc > 2) && (abs(n - (int)hp->clen) <= 3)) {
         if (utf8) {
           u8_u16(w_candidate, HENTRY_WORD(hp));
           mkallcap_utf(w_candidate, langnum);
           u16_u8(candidate, w_candidate);
         } else {
           candidate = HENTRY_WORD(hp);
           mkallcap(candidate, csconv);
         }
         f = phonet(candidate, *ph);
         if (utf8) {
           u8_u16(w_f, f);
           scphon = 2 * ngram(3, w_target, w_f,
                              NGRAM_LONGER_WORSE);
         } else {
           scphon = 2 * ngram(3, target, f,
                              NGRAM_LONGER_WORSE);
         }
       }
 
       if (sc > scores[lp]) {
         scores[lp] = sc;
         roots[lp] = hp;
         lval = sc;
         for (int j = 0; j < MAX_ROOTS; j++)
           if (scores[j] < lval) {
             lp = j;
             lval = scores[j];
           }
       }
 
       if (scphon > scoresphon[lpphon]) {
         scoresphon[lpphon] = scphon;
         rootsphon[lpphon] = HENTRY_WORD(hp);
         lval = scphon;
         for (int j = 0; j < MAX_ROOTS; j++)
           if (scoresphon[j] < lval) {
             lpphon = j;
             lval = scoresphon[j];
           }
       }
     }
   }
 
   // find minimum threshold for a passable suggestion
   // mangle original word three differnt ways
   // and score them to generate a minimum acceptable score
   std::vector<w_char> w_mw;
   int thresh = 0;
   for (int sp = 1; sp < 4; sp++) {
     if (utf8) {
       w_mw = w_word;
       for (int k = sp; k < n; k += 4) {
         w_mw[k].l = '*';
         w_mw[k].h = 0;
       }
 
       if (low) {
         // lowering dictionary word
         mkallsmall_utf(w_mw, langnum);
       }
 
       thresh += ngram(n, w_word, w_mw, NGRAM_ANY_MISMATCH);
     } else {
       std::string mw = word;
       for (int k = sp; k < n; k += 4)
         mw[k] = '*';
 
       if (low) {
         // lowering dictionary word
         mkallsmall(mw, csconv);
       }
 
       thresh += ngram(n, word, mw, NGRAM_ANY_MISMATCH);
     }
   }
   thresh = thresh / 3;
   thresh--;
 
   // now expand affixes on each of these root words and
   // and use length adjusted ngram scores to select
   // possible suggestions
   char* guess[MAX_GUESS];
   char* guessorig[MAX_GUESS];
   int gscore[MAX_GUESS];
   for (int i = 0; i < MAX_GUESS; i++) {
     guess[i] = NULL;
     guessorig[i] = NULL;
     gscore[i] = -100 * i;
   }
 
   lp = MAX_GUESS - 1;
 
   std::vector<guessword> glst(MAX_WORDS);
 
-  for (int i = 0; i < MAX_ROOTS; i++) {
-    if (roots[i]) {
-      struct hentry* rp = roots[i];
+  for (auto& root : roots) {
+    if (root) {
+      struct hentry* rp = root;
 
       f.clear();
       const char *field = NULL;
       if ((rp->var & H_OPT_PHON) && copy_field(f, HENTRY_DATA(rp), MORPH_PHON))
           field = f.c_str();
       int nw = pAMgr->expand_rootword(
           glst.data(), MAX_WORDS, HENTRY_WORD(rp), rp->blen, rp->astr, rp->alen, word,
           nc, field);
 
       for (int k = 0; k < nw; k++) {
         if (utf8) {
           u8_u16(w_f, glst[k].word);
 
           int leftcommon = leftcommonsubstring(w_word, w_f);
           if (low) {
             // lowering dictionary word
             mkallsmall_utf(w_f, langnum);
           }
 
           sc = ngram(n, w_word, w_f, NGRAM_ANY_MISMATCH) + leftcommon;
         } else {
           f = glst[k].word;
 
           int leftcommon = leftcommonsubstring(word, f.c_str());
           if (low) {
             // lowering dictionary word
             mkallsmall(f, csconv);
           }
 
           sc = ngram(n, word, f, NGRAM_ANY_MISMATCH) + leftcommon;
         }
 
         if (sc > thresh) {
           if (sc > gscore[lp]) {
             if (guess[lp]) {
               delete[] guess[lp];
               if (guessorig[lp]) {
                 delete[] guessorig[lp];
                 guessorig[lp] = NULL;
               }
             }
             gscore[lp] = sc;
             guess[lp] = glst[k].word;
             guessorig[lp] = glst[k].orig;
             lval = sc;
             for (int j = 0; j < MAX_GUESS; j++)
               if (gscore[j] < lval) {
                 lp = j;
                 lval = gscore[j];
               }
           } else {
             delete[] glst[k].word;
             delete[] glst[k].orig;
           }
         } else {
           delete[] glst[k].word;
           delete[] glst[k].orig;
         }
       }
     }
   }
   glst.clear();
 
   // now we are done generating guesses
   // sort in order of decreasing score
 
   bubblesort(&guess[0], &guessorig[0], &gscore[0], MAX_GUESS);
   if (ph)
     bubblesort(&rootsphon[0], NULL, &scoresphon[0], MAX_ROOTS);
 
   // weight suggestions with a similarity index, based on
   // the longest common subsequent algorithm and resort
 
   int is_swap = 0;
   int re = 0;
   double fact = 1.0;
   if (pAMgr) {
     int maxd = pAMgr->get_maxdiff();
     if (maxd >= 0)
       fact = (10.0 - maxd) / 5.0;
   }
 
   std::vector<w_char> w_gl;
   for (int i = 0; i < MAX_GUESS; i++) {
     if (guess[i]) {
       // lowering guess[i]
       std::string gl;
       int len;
       if (utf8) {
         len = u8_u16(w_gl, guess[i]);
         mkallsmall_utf(w_gl, langnum);
         u16_u8(gl, w_gl);
       } else {
         gl.assign(guess[i]);
         if (!nonbmp)
           mkallsmall(gl, csconv);
         len = strlen(guess[i]);
       }
 
       int _lcs = lcslen(word, gl.c_str());
 
       // same characters with different casing
       if ((n == len) && (n == _lcs)) {
         gscore[i] += 2000;
         break;
       }
       // using 2-gram instead of 3, and other weightening
 
       if (utf8) {
         u8_u16(w_gl, gl);
         //w_gl is lowercase already at this point
         re = ngram(2, w_word, w_gl, NGRAM_ANY_MISMATCH | NGRAM_WEIGHTED);
         if (low) {
           w_f = w_word;
           // lowering dictionary word
           mkallsmall_utf(w_f, langnum);
           re += ngram(2, w_gl, w_f, NGRAM_ANY_MISMATCH | NGRAM_WEIGHTED);
         } else {
           re += ngram(2, w_gl, w_word, NGRAM_ANY_MISMATCH | NGRAM_WEIGHTED);
         }
       } else {
         //gl is lowercase already at this point
         re = ngram(2, word, gl, NGRAM_ANY_MISMATCH | NGRAM_WEIGHTED);
         if (low) {
           f = word;
           // lowering dictionary word
           mkallsmall(f, csconv);
           re += ngram(2, gl, f, NGRAM_ANY_MISMATCH | NGRAM_WEIGHTED);
         } else {
           re += ngram(2, gl, word, NGRAM_ANY_MISMATCH | NGRAM_WEIGHTED);
         }
       }
 
       int ngram_score, leftcommon_score;
       if (utf8) {
         //w_gl is lowercase already at this point
         ngram_score = ngram(4, w_word, w_gl, NGRAM_ANY_MISMATCH);
         leftcommon_score = leftcommonsubstring(w_word, w_gl);
       } else {
         //gl is lowercase already at this point
         ngram_score = ngram(4, word, gl, NGRAM_ANY_MISMATCH);
         leftcommon_score = leftcommonsubstring(word, gl.c_str());
       }
       gscore[i] =
           // length of longest common subsequent minus length difference
           2 * _lcs - abs((int)(n - len)) +
           // weight length of the left common substring
           leftcommon_score +
           // weight equal character positions
           (!nonbmp && commoncharacterpositions(word, gl.c_str(), &is_swap)
                ? 1
                : 0) +
           // swap character (not neighboring)
           ((is_swap) ? 10 : 0) +
           // ngram
           ngram_score +
           // weighted ngrams
           re +
           // different limit for dictionaries with PHONE rules
           (ph ? (re < len * fact ? -1000 : 0)
               : (re < (n + len) * fact ? -1000 : 0));
     }
   }
 
   bubblesort(&guess[0], &guessorig[0], &gscore[0], MAX_GUESS);
 
   // phonetic version
   if (ph)
     for (int i = 0; i < MAX_ROOTS; i++) {
       if (rootsphon[i]) {
         // lowering rootphon[i]
         std::string gl;
         int len;
         if (utf8) {
           len = u8_u16(w_gl, rootsphon[i]);
           mkallsmall_utf(w_gl, langnum);
           u16_u8(gl, w_gl);
         } else {
           gl.assign(rootsphon[i]);
           if (!nonbmp)
             mkallsmall(gl, csconv);
           len = strlen(rootsphon[i]);
         }
 
         // weight length of the left common substring
         int leftcommon_score;
         if (utf8)
           leftcommon_score = leftcommonsubstring(w_word, w_gl);
         else
           leftcommon_score = leftcommonsubstring(word, gl.c_str());
         // heuristic weigthing of ngram scores
         scoresphon[i] += 2 * lcslen(word, gl) - abs((int)(n - len)) +
                          leftcommon_score;
       }
     }
 
   if (ph)
     bubblesort(&rootsphon[0], NULL, &scoresphon[0], MAX_ROOTS);
 
   // copy over
   size_t oldns = wlst.size();
 
   int same = 0;
   for (int i = 0; i < MAX_GUESS; i++) {
     if (guess[i]) {
       if ((wlst.size() < oldns + maxngramsugs) && (wlst.size() < maxSug) &&
           (!same || (gscore[i] > 1000))) {
         int unique = 1;
         // leave only excellent suggestions, if exists
         if (gscore[i] > 1000)
           same = 1;
         else if (gscore[i] < -100) {
           same = 1;
           // keep the best ngram suggestions, unless in ONLYMAXDIFF mode
           if (wlst.size() > oldns || (pAMgr && pAMgr->get_onlymaxdiff())) {
             delete[] guess[i];
             delete[] guessorig[i];
             continue;
           }
         }
-        for (size_t j = 0; j < wlst.size(); ++j) {
+        for (auto& j : wlst) {
           // don't suggest previous suggestions or a previous suggestion with
           // prefixes or affixes
-          if ((!guessorig[i] && strstr(guess[i], wlst[j].c_str())) ||
-              (guessorig[i] && strstr(guessorig[i], wlst[j].c_str())) ||
+          if ((!guessorig[i] && strstr(guess[i], j.c_str())) ||
+              (guessorig[i] && strstr(guessorig[i], j.c_str())) ||
               // check forbidden words
               !checkword(guess[i], 0, NULL, NULL)) {
             unique = 0;
             break;
           }
         }
         if (unique) {
           if (guessorig[i]) {
-            wlst.push_back(guessorig[i]);
+            wlst.emplace_back(guessorig[i]);
           } else {
-            wlst.push_back(guess[i]);
+            wlst.emplace_back(guess[i]);
           }
         }
         delete[] guess[i];
         delete[] guessorig[i];
       } else {
         delete[] guess[i];
         delete[] guessorig[i];
       }
     }
   }
 
   oldns = wlst.size();
   if (ph)
-    for (int i = 0; i < MAX_ROOTS; i++) {
-      if (rootsphon[i]) {
+    for (auto& i : rootsphon) {
+      if (i) {
         if ((wlst.size() < oldns + MAXPHONSUGS) && (wlst.size() < maxSug)) {
           int unique = 1;
-          for (size_t j = 0; j < wlst.size(); ++j) {
+          for (auto& j : wlst) {
             // don't suggest previous suggestions or a previous suggestion with
             // prefixes or affixes
-            if (strstr(rootsphon[i], wlst[j].c_str()) ||
+            if (strstr(i, j.c_str()) ||
                 // check forbidden words
-                !checkword(rootsphon[i], 0, NULL, NULL)) {
+                !checkword(i, 0, NULL, NULL)) {
               unique = 0;
               break;
             }
           }
           if (unique) {
-            wlst.push_back(rootsphon[i]);
+            wlst.emplace_back(i);
           }
         }
       }
     }
 
   if (nonbmp) {
     csconv = origconv;
     utf8 = 1;
   }
 }
 
 // see if a candidate suggestion is spelled correctly
 // needs to check both root words and words with affixes
 
 // obsolote MySpell-HU modifications:
 // return value 2 and 3 marks compounding with hyphen (-)
 // `3' marks roots without suffix
@@ -1735,53 +1710,53 @@ int SuggestMgr::check_forbidden(const std::string& word) {
 std::string SuggestMgr::suggest_morph(const std::string& in_w) {
   std::string result;
 
   struct hentry* rv = NULL;
 
   if (!pAMgr)
-    return std::string();
+    return {};
 
   std::string w(in_w);
 
   // word reversing wrapper for complex prefixes
   if (complexprefixes) {
     if (utf8)
       reverseword_utf(w);
     else
       reverseword(w);
   }
 
   rv = pAMgr->lookup(w.c_str(), w.size());
 
   while (rv) {
     if ((!rv->astr) ||
         !(TESTAFF(rv->astr, pAMgr->get_forbiddenword(), rv->alen) ||
           TESTAFF(rv->astr, pAMgr->get_needaffix(), rv->alen) ||
           TESTAFF(rv->astr, pAMgr->get_onlyincompound(), rv->alen))) {
       if (!HENTRY_FIND(rv, MORPH_STEM)) {
         result.push_back(MSEP_FLD);
         result.append(MORPH_STEM);
         result.append(w);
       }
       if (HENTRY_DATA(rv)) {
         result.push_back(MSEP_FLD);
         result.append(HENTRY_DATA2(rv));
       }
       result.push_back(MSEP_REC);
     }
     rv = rv->next_homonym;
   }
 
   std::string st = pAMgr->affix_check_morph(w, 0, w.size());
   if (!st.empty()) {
     result.append(st);
   }
 
   if (pAMgr->get_compound() && result.empty()) {
     struct hentry* rwords[100];  // buffer for COMPOUND pattern checking
     pAMgr->compound_check_morph(w, 0, 0, 100, 0, NULL, (hentry**)&rwords, 0, result, NULL);
   }
 
   line_uniq(result, MSEP_REC);
 
   return result;
 }
@@ -1859,224 +1834,211 @@ std::string SuggestMgr::suggest_hentry_gen(hentry* rv, const char* pattern) {
 
 std::string SuggestMgr::suggest_gen(const std::vector<std::string>& desc, const std::string& in_pattern) {
   if (desc.empty() || !pAMgr)
-    return std::string();
+    return {};
 
   const char* pattern = in_pattern.c_str();
   std::string result2;
   std::string newpattern;
   struct hentry* rv = NULL;
 
   // search affixed forms with and without derivational suffixes
   while (1) {
     for (size_t k = 0; k < desc.size(); ++k) {
       std::string result;
 
       // add compound word parts (except the last one)
       const char* s = desc[k].c_str();
       const char* part = strstr(s, MORPH_PART);
       if (part) {
         const char* nextpart = strstr(part + 1, MORPH_PART);
         while (nextpart) {
           std::string field;
           copy_field(field, part, MORPH_PART);
           result.append(field);
           part = nextpart;
           nextpart = strstr(part + 1, MORPH_PART);
         }
         s = part;
       }
 
       std::string tok(s);
       size_t pos = tok.find(" | ");
       while (pos != std::string::npos) {
         tok[pos + 1] = MSEP_ALT;
         pos = tok.find(" | ", pos);
       }
       std::vector<std::string> pl = line_tok(tok, MSEP_ALT);
-      for (size_t i = 0; i < pl.size(); ++i) {
+      for (auto& i : pl) {
         // remove inflectional and terminal suffixes
-        size_t is = pl[i].find(MORPH_INFL_SFX);
+        size_t is = i.find(MORPH_INFL_SFX);
         if (is != std::string::npos)
-          pl[i].resize(is);
-        size_t ts = pl[i].find(MORPH_TERM_SFX);
+	        i.resize(is);
+        size_t ts = i.find(MORPH_TERM_SFX);
         while (ts != std::string::npos) {
-          pl[i][ts] = '_';
-          ts = pl[i].find(MORPH_TERM_SFX);
+	        i[ts] = '_';
+          ts = i.find(MORPH_TERM_SFX);
         }
         const char* st = strstr(s, MORPH_STEM);
         if (st) {
           copy_field(tok, st, MORPH_STEM);
           rv = pAMgr->lookup(tok.c_str(), tok.size());
           while (rv) {
-            std::string newpat(pl[i]);
+            std::string newpat(i);
             newpat.append(pattern);
             std::string sg = suggest_hentry_gen(rv, newpat.c_str());
             if (sg.empty())
               sg = suggest_hentry_gen(rv, pattern);
             if (!sg.empty()) {
               std::vector<std::string> gen = line_tok(sg, MSEP_REC);
-              for (size_t j = 0; j < gen.size(); ++j) {
+              for (auto& j : gen) {
                 result2.push_back(MSEP_REC);
                 result2.append(result);
-                if (pl[i].find(MORPH_SURF_PFX) != std::string::npos) {
+                if (i.find(MORPH_SURF_PFX) != std::string::npos) {
                   std::string field;
-                  copy_field(field, pl[i], MORPH_SURF_PFX);
+                  copy_field(field, i, MORPH_SURF_PFX);
                   result2.append(field);
                 }
-                result2.append(gen[j]);
+                result2.append(j);
               }
             }
             rv = rv->next_homonym;
           }
         }
       }
     }
 
     if (!result2.empty() || !strstr(pattern, MORPH_DERI_SFX))
       break;
 
     newpattern.assign(pattern);
     mystrrep(newpattern, MORPH_DERI_SFX, MORPH_TERM_SFX);
     pattern = newpattern.c_str();
   }
   return result2;
 }
 
 // generate an n-gram score comparing s1 and s2, UTF16 version
 int SuggestMgr::ngram(int n,
                       const std::vector<w_char>& su1,
                       const std::vector<w_char>& su2,
                       int opt) {
-  int nscore = 0;
-  int ns;
-  int l1;
-  int l2;
-  int test = 0;
-
-  l1 = su1.size();
-  l2 = su2.size();
+  int nscore = 0, ns, test = 0, l1 = su1.size(), l2 = su2.size();
+
   if (l2 == 0)
     return 0;
   for (int j = 1; j <= n; j++) {
     ns = 0;
     for (int i = 0; i <= (l1 - j); i++) {
       int k = 0;
       for (int l = 0; l <= (l2 - j); l++) {
         for (k = 0; k < j; k++) {
           if (su1[i + k] != su2[l + k])
             break;
         }
         if (k == j) {
           ns++;
           break;
         }
       }
       if (k != j && opt & NGRAM_WEIGHTED) {
         ns--;
         test++;
         if (i == 0 || i == l1 - j)
           ns--;  // side weight
       }
     }
     nscore = nscore + ns;
     if (ns < 2 && !(opt & NGRAM_WEIGHTED))
       break;
   }
 
   ns = 0;
   if (opt & NGRAM_LONGER_WORSE)
     ns = (l2 - l1) - 2;
   if (opt & NGRAM_ANY_MISMATCH)
     ns = abs(l2 - l1) - 2;
   ns = (nscore - ((ns > 0) ? ns : 0));
   return ns;
 }
 
 // generate an n-gram score comparing s1 and s2, non-UTF16 version
 int SuggestMgr::ngram(int n,
                       const std::string& s1,
                       const std::string& s2,
                       int opt) {
-  int nscore = 0;
-  int ns;
-  int l1;
-  int l2;
-  int test = 0;
-
-  l2 = s2.size();
+  int nscore = 0, ns, l1, l2 = s2.size(), test = 0;
+  
   if (l2 == 0)
     return 0;
   l1 = s1.size();
   for (int j = 1; j <= n; j++) {
     ns = 0;
     for (int i = 0; i <= (l1 - j); i++) {
       //s2 is haystack, s1[i..i+j) is needle
       if (s2.find(s1.c_str()+i, 0, j) != std::string::npos) {
         ns++;
       } else if (opt & NGRAM_WEIGHTED) {
         ns--;
         test++;
         if (i == 0 || i == l1 - j)
           ns--;  // side weight
       }
     }
     nscore = nscore + ns;
     if (ns < 2 && !(opt & NGRAM_WEIGHTED))
       break;
   }
 
   ns = 0;
   if (opt & NGRAM_LONGER_WORSE)
     ns = (l2 - l1) - 2;
   if (opt & NGRAM_ANY_MISMATCH)
     ns = abs(l2 - l1) - 2;
   ns = (nscore - ((ns > 0) ? ns : 0));
   return ns;
 }
 
 // length of the left common substring of s1 and (decapitalised) s2, UTF version
 int SuggestMgr::leftcommonsubstring(
     const std::vector<w_char>& su1,
     const std::vector<w_char>& su2) {
-  int l1 = su1.size();
-  int l2 = su2.size();
+  int l1 = su1.size(), l2 = su2.size();
   // decapitalize dictionary word
   if (complexprefixes) {
     if (l1 && l2 && su1[l1 - 1] == su2[l2 - 1])
       return 1;
   } else {
-    unsigned short idx = su2.empty() ? 0 : (unsigned short)(su2[0]);
-    unsigned short otheridx = su1.empty() ? 0 : (unsigned short)(su1[0]);
+    unsigned short idx = su2.empty() ? 0 : (unsigned short)(su2[0]),
+  	               otheridx = su1.empty() ? 0 : (unsigned short)(su1[0]);
     if (otheridx != idx && (otheridx != unicodetolower(idx, langnum)))
       return 0;
     int i;
     for (i = 1; (i < l1) && (i < l2) && (su1[i] == su2[i]);
          i++)
       ;
     return i;
   }
   return 0;
 }
 
 // length of the left common substring of s1 and (decapitalised) s2, non-UTF
 int SuggestMgr::leftcommonsubstring(
     const char* s1,
     const char* s2) {
   if (complexprefixes) {
-    int l1 = strlen(s1);
-    int l2 = strlen(s2);
+    int l1 = strlen(s1), l2 = strlen(s2);
     if (l1 && l1 <= l2 && s2[l1 - 1] == s2[l2 - 1])
       return 1;
   } else if (csconv) {
     const char* olds = s1;
     // decapitalise dictionary word
     if ((*s1 != *s2) && (*s1 != csconv[((unsigned char)*s2)].clower))
       return 0;
     do {
       s1++;
       s2++;
     } while ((*s1 == *s2) && (*s1 != '\0'));
     return (int)(s1 - olds);
   }
   return 0;
 }
@@ -2084,61 +2046,58 @@ int SuggestMgr::leftcommonsubstring(
 int SuggestMgr::commoncharacterpositions(const char* s1,
                                          const char* s2,
                                          int* is_swap) {
-  int num = 0;
-  int diff = 0;
-  int diffpos[2];
+  int num = 0, diff = 0, diffpos[2];
   *is_swap = 0;
   if (utf8) {
     std::vector<w_char> su1;
     std::vector<w_char> su2;
-    int l1 = u8_u16(su1, s1);
-    int l2 = u8_u16(su2, s2);
+    int l1 = u8_u16(su1, s1), l2 = u8_u16(su2, s2);
 
     if (l1 <= 0 || l2 <= 0)
       return 0;
 
     // decapitalize dictionary word
     if (complexprefixes) {
       su2[l2 - 1] = lower_utf(su2[l2 - 1], langnum);
     } else {
       su2[0] = lower_utf(su2[0], langnum);
     }
     for (int i = 0; (i < l1) && (i < l2); i++) {
       if (su1[i] == su2[i]) {
         num++;
       } else {
         if (diff < 2)
           diffpos[diff] = i;
         diff++;
       }
     }
     if ((diff == 2) && (l1 == l2) &&
         (su1[diffpos[0]] == su2[diffpos[1]]) &&
         (su1[diffpos[1]] == su2[diffpos[0]]))
       *is_swap = 1;
   } else {
     size_t i;
     std::string t(s2);
     // decapitalize dictionary word
     if (complexprefixes) {
       size_t l2 = t.size();
       t[l2 - 1] = csconv[(unsigned char)t[l2 - 1]].clower;
     } else {
       mkallsmall(t, csconv);
     }
     for (i = 0; i < t.size() && (*(s1 + i) != 0); ++i) {
       if (*(s1 + i) == t[i]) {
         num++;
       } else {
         if (diff < 2)
           diffpos[diff] = i;
         diff++;
       }
     }
     if ((diff == 2) && (*(s1 + i) == 0) && i == t.size() &&
         (*(s1 + diffpos[0]) == t[diffpos[1]]) &&
         (*(s1 + diffpos[1]) == t[diffpos[0]]))
       *is_swap = 1;
   }
   return num;
 }
@@ -2154,93 +2113,85 @@ int SuggestMgr::mystrlen(const char* word) {
 // sort in decreasing order of score
 void SuggestMgr::bubblesort(char** rword, char** rword2, int* rsc, int n) {
   int m = 1;
   while (m < n) {
     int j = m;
     while (j > 0) {
       if (rsc[j - 1] < rsc[j]) {
         int sctmp = rsc[j - 1];
         char* wdtmp = rword[j - 1];
         rsc[j - 1] = rsc[j];
         rword[j - 1] = rword[j];
         rsc[j] = sctmp;
         rword[j] = wdtmp;
         if (rword2) {
           wdtmp = rword2[j - 1];
           rword2[j - 1] = rword2[j];
           rword2[j] = wdtmp;
         }
         j--;
       } else
         break;
     }
     m++;
   }
-  return;
 }
 
 // longest common subsequence
 char* SuggestMgr::lcs(const char* s,
                       const char* s2,
                       int* l1,
                       int* l2) {
-  int n, m;
+  int n, m, i, j;
   std::vector<w_char> su;
   std::vector<w_char> su2;
-  int i;
-  int j;
   if (utf8) {
     m = u8_u16(su, s);
     n = u8_u16(su2, s2);
   } else {
     m = strlen(s);
     n = strlen(s2);
   }
   char* c = new char[(m + 1) * (n + 1)];
   char* b = new char[(m + 1) * (n + 1)];
   for (i = 1; i <= m; i++)
     c[i * (n + 1)] = 0;
   for (j = 0; j <= n; j++)
     c[j] = 0;
   for (i = 1; i <= m; i++) {
     for (j = 1; j <= n; j++) {
       if (((utf8) && (su[i - 1] == su2[j - 1])) ||
           ((!utf8) && (s[i - 1] == s2[j - 1]))) {
         c[i * (n + 1) + j] = c[(i - 1) * (n + 1) + j - 1] + 1;
         b[i * (n + 1) + j] = LCS_UPLEFT;
       } else if (c[(i - 1) * (n + 1) + j] >= c[i * (n + 1) + j - 1]) {
         c[i * (n + 1) + j] = c[(i - 1) * (n + 1) + j];
         b[i * (n + 1) + j] = LCS_UP;
       } else {
         c[i * (n + 1) + j] = c[i * (n + 1) + j - 1];
         b[i * (n + 1) + j] = LCS_LEFT;
       }
     }
   }
   delete[] c;
   *l1 = m;
   *l2 = n;
   return b;
 }
 
 int SuggestMgr::lcslen(const char* s, const char* s2) {
-  int m;
-  int n;
-  int i;
-  int j;
-  int len = 0;
+  int m, n, len = 0;
   char* result = lcs(s, s2, &m, &n);
-  i = m;
-  j = n;
+  int i = m, j = n;
   while ((i != 0) && (j != 0)) {
     if (result[i * (n + 1) + j] == LCS_UPLEFT) {
       len++;
       i--;
       j--;
     } else if (result[i * (n + 1) + j] == LCS_UP) {
       i--;
     } else
       j--;
   }
   delete[] result;
   return len;
 }
diff --git a/src/hunspell/suggestmgr.hxx b/src/hunspell/suggestmgr.hxx
index cde1db4..8838a0f 100644
--- a/src/hunspell/suggestmgr.hxx
+++ b/src/hunspell/suggestmgr.hxx
@@ -91,94 +91,92 @@
 enum { LCS_UP, LCS_LEFT, LCS_UPLEFT };
 
 class SuggestMgr {
- private:
-  SuggestMgr(const SuggestMgr&);
-  SuggestMgr& operator=(const SuggestMgr&);
-
  private:
   std::string ckey;
   size_t ckeyl;
   std::vector<w_char> ckey_utf;
 
   std::string ctry;
   size_t ctryl;
   std::vector<w_char> ctry_utf;
   bool lang_with_dash_usage;
 
   AffixMgr* pAMgr;
   unsigned int maxSug;
   struct cs_info* csconv;
   int utf8;
   int langnum;
   int nosplitsugs;
   int maxngramsugs;
   int maxcpdsugs;
   int complexprefixes;
 
  public:
   SuggestMgr(const std::string& tryme, unsigned int maxn, AffixMgr* aptr);
+  SuggestMgr(const SuggestMgr&) = delete;
+  SuggestMgr& operator=(const SuggestMgr&) = delete;
   ~SuggestMgr();
 
   bool suggest(std::vector<std::string>& slst, const std::string& word, int* onlycmpdsug);
   void ngsuggest(std::vector<std::string>& slst, const char* word, const std::vector<HashMgr*>& rHMgr, int captype);
 
   std::string suggest_morph(const std::string& word);
   std::string suggest_gen(const std::vector<std::string>& pl, const std::string& pattern);
 
  private:
   void testsug(std::vector<std::string>& wlst,
                const std::string& candidate,
                int cpdsuggest,
                int* timer,
                clock_t* timelimit);
   int checkword(const std::string& word, int, int*, clock_t*);
   int check_forbidden(const std::string&);
 
   void capchars(std::vector<std::string>&, const std::string&, int);
   int replchars(std::vector<std::string>&, const std::string&, int);
   int doubletwochars(std::vector<std::string>&, const std::string&, int);
   int forgotchar(std::vector<std::string>&, const std::string&, int);
   int swapchar(std::vector<std::string>&, const std::string&, int);
   int longswapchar(std::vector<std::string>&, const std::string&, int);
   int movechar(std::vector<std::string>&, const std::string&, int);
   int extrachar(std::vector<std::string>&, const std::string&, int);
   int badcharkey(std::vector<std::string>&, const std::string&, int);
   int badchar(std::vector<std::string>&, const std::string&, int);
   bool twowords(std::vector<std::string>&, const std::string&, int, bool);
 
   void capchars_utf(std::vector<std::string>&, const std::vector<w_char>&, int);
   int doubletwochars_utf(std::vector<std::string>&, const std::vector<w_char>&, int);
   int forgotchar_utf(std::vector<std::string>&, const std::vector<w_char>&, int);
   int extrachar_utf(std::vector<std::string>&, const std::vector<w_char>&, int);
   int badcharkey_utf(std::vector<std::string>&, const std::vector<w_char>&, int);
   int badchar_utf(std::vector<std::string>&, const std::vector<w_char>&, int);
   int swapchar_utf(std::vector<std::string>&, const std::vector<w_char>&, int);
   int longswapchar_utf(std::vector<std::string>&, const std::vector<w_char>&, int);
   int movechar_utf(std::vector<std::string>&, const std::vector<w_char>&, int);
 
   int mapchars(std::vector<std::string>&, const std::string&, int);
   int map_related(const std::string&,
                   std::string&,
                   size_t,
                   std::vector<std::string>& wlst,
                   int,
                   const std::vector<mapentry>&,
                   int*,
                   clock_t*,
                   int depth);
   int ngram(int n, const std::vector<w_char>& su1,
             const std::vector<w_char>& su2, int opt);
   int ngram(int n, const std::string& s1, const std::string& s2, int opt);
   int mystrlen(const char* word);
   int leftcommonsubstring(const std::vector<w_char>& su1,
                           const std::vector<w_char>& su2);
   int leftcommonsubstring(const char* s1, const char* s2);
   int commoncharacterpositions(const char* s1, const char* s2, int* is_swap);
   void bubblesort(char** rwd, char** rwd2, int* rsc, int n);
   char* lcs(const char* s, const char* s2, int* l1, int* l2);
   int lcslen(const char* s, const char* s2);
   int lcslen(const std::string& s, const std::string& s2);
   std::string suggest_hentry_gen(hentry* rv, const char* pattern);
 };
 
 #endif
