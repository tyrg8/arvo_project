commit 5496abe1c5c31aa6648e8fdb15e4122025bcabfe
Author: Alan Modra <amodra@gmail.com>
Date:   Sun Jan 12 20:16:22 2020 +1030

    tic4x: sign extension using shifts
    
    Don't do that.  Especially don't use shift counts that assume the type
    being shifted is 32 bits when the type is long/unsigned long.  Also
    reverts part of a change I made on 2019-12-11 to tic4x_print_register
    that on closer inspection turns out to be unnecessary.
    
    include/
            * opcode/tic4x.h (EXTR): Delete.
            (EXTRU, EXTRS, INSERTU, INSERTS): Rewrite without zero/sign
            extension using shifts.  Do trim INSERTU value to specified bitfield.
    opcodes/
            * tic4x-dis.c (tic4x_print_register): Remove dead code.
    gas/
            * config/tc-tic4x.c (tic4x_operands_match): Correct tic3x trap
            insertion.

diff --git a/gas/ChangeLog b/gas/ChangeLog
index 245bd743634..4186fbd05e3 100644
--- a/gas/ChangeLog
+++ b/gas/ChangeLog
@@ -1,171 +1,176 @@
+2020-01-13  Alan Modra  <amodra@gmail.com>
+
+	* config/tc-tic4x.c (tic4x_operands_match): Correct tic3x trap
+	insertion.
+
 2020-01-10  Alan Modra  <amodra@gmail.com>
 
 	* testsuite/gas/elf/pr14891.s: Don't start directives in first column.
 	* testsuite/gas/elf/pr21661.d: Don't run on hpux.
 
 2020-01-03  Sergey Belyashov  <sergey.belyashov@gmail.com>
 
 	PR 25224
 	* config/tc-z80.c (emit_ld_m_rr): Use integer types when checking
 	opcode byte values.
 	(emit_ld_r_r): Likewise.
 	(emit_ld_rr_m): Likewise.
 	(emit_ld_rr_nn): Likewise.
 
 2020-01-09  Jan Beulich  <jbeulich@suse.com>
 
 	* config/tc-i386.c (optimize_encoding): Add
 	is_any_vex_encoding() invocations. Drop respective
 	i.tm.extension_opcode == None checks.
 
 2020-01-09  Jan Beulich  <jbeulich@suse.com>
 
 	* config/tc-i386.c (md_assemble): Check RegRex is clear during
 	REX transformations. Correct comment indentation.
 
 2020-01-09  Jan Beulich  <jbeulich@suse.com>
 
 	* config/tc-i386.c (optimize_encoding): Generalize register
 	transformation for TEST optimization.
 
 2020-01-09  Jan Beulich  <jbeulich@suse.com>
 
 	* testsuite/gas/i386/x86-64-sysenter-amd.s,
 	testsuite/gas/i386/x86-64-sysenter-amd.d,
 	testsuite/gas/i386/x86-64-sysenter-amd.l,
 	testsuite/gas/i386/x86-64-sysenter-intel.d,
 	testsuite/gas/i386/x86-64-sysenter-mixed.d: New.
 	* testsuite/gas/i386/i386.exp: Run new tests.
 
 2020-01-08  Nick Clifton  <nickc@redhat.com>
 
 	PR 25284
 	* doc/as.texi (Align): Document the fact that all arguments can be
 	omitted.
 	(Balign): Likewise.
 	(P2align): Likewise.
 
 2020-01-08  Nick Clifton  <nickc@redhat.com>
 
 	PR 14891
 	* config/obj-elf.c (obj_elf_section): Fail if the section name is
 	already defined as a different symbol type.
 	* testsuite/gas/elf/pr14891.s: New test source file.
 	* testsuite/gas/elf/pr14891.d: New test driver.
 	* testsuite/gas/elf/pr14891.s: New test expected error output.
 	* testsuite/gas/elf/elf.exp: Run the new test.
 
 2020-01-08  Alan Modra  <amodra@gmail.com>
 
 	* config/tc-z8k.c (md_begin): Make idx unsigned.
 	(get_specific): Likewise for this_index.
 
 2020-01-07  Claudiu Zissulescu  <claziss@synopsys.com>
 
 	* onfig/tc-arc.c (parse_reloc_symbol): New function.
 	(tokenize_arguments): Clean up, use parse_reloc_symbol function.
 	(md_operand): Set X_md to absent.
 	(arc_parse_name): Check for X_md.
 
 2020-01-03  Sergey Belyashov  <sergey.belyashov@gmail.com>
 
 	PR 25311
 	* as.h (TC_STRING_ESCAPES): Provide a default definition.
 	* app.c (do_scrub_chars): Use TC_STRING_ESCAPES instead of
 	NO_STRING_ESCAPES.
 	* read.c (next_char_of_string): Likewise.
 	* config/tc-ppc.h (TC_STRING_ESCAPES): Define.
 	* config/tc-z80.h (TC_STRING_ESCAPES): Define.
 
 2020-01-03  Nick Clifton  <nickc@redhat.com>
 
 	* po/sv.po: Updated Swedish translation.
 
 2020-01-03  Jan Beulich  <jbeulich@suse.com>
 
 	* testsuite/gas/aarch64/f64mm.s: Scale index of LD1RO{H,W,D}.
 	* testsuite/gas/aarch64/f64mm.d: Adjust expectations.
 
 2020-01-03  Jan Beulich  <jbeulich@suse.com>
 
 	* testsuite/gas/aarch64/i8mm.s: Add 128-bit form tests for
 	by-element usdot. Add 64-bit form tests for by-element sudot.
 	* testsuite/gas/aarch64/i8mm.d: Adjust expectations.
 
 2020-01-03  Jan Beulich  <jbeulich@suse.com>
 
 	* testsuite/gas/aarch64/f64mm.s: Drop 'i' from uzip<n>.
 	* testsuite/gas/aarch64/f64mm.d: Adjust expectations.
 
 2020-01-03  Jan Beulich  <jbeulich@suse.com>
 
 	* testsuite/gas/aarch64/f64mm.d,
 	testsuite/gas/aarch64/sve-movprfx-mm.d: Adjust expectations.
 
 2020-01-02  Sergey Belyashov  <sergey.belyashov@gmail.com>
 
 	* config/tc-z80.c: Add new architectures: Z180 and eZ80. Add
 	support for assembler code generated by SDCC. Add new relocation
 	types. Add z80-elf target support.
 	* config/tc-z80.h: Add z80-elf target support. Enable dollar local
 	labels. Local labels starts from ".L".
 	* NEWS: Mention the new support.
 	* testsuite/gas/all/fwdexp.d: Fix failure due to symbol conflict.
 	* testsuite/gas/all/fwdexp.s: Likewise.
 	* testsuite/gas/all/cond.l: Likewise.
 	* testsuite/gas/all/cond.s: Likewise.
 	* testsuite/gas/all/fwdexp.d: Likewise.
 	* testsuite/gas/all/fwdexp.s: Likewise.
 	* testsuite/gas/elf/section2.e-mips: Likewise.
 	* testsuite/gas/elf/section2.l: Likewise.
 	* testsuite/gas/elf/section2.s: Likewise.
 	* testsuite/gas/macros/app1.d: Likewise.
 	* testsuite/gas/macros/app1.s: Likewise.
 	* testsuite/gas/macros/app2.d: Likewise.
 	* testsuite/gas/macros/app2.s: Likewise.
 	* testsuite/gas/macros/app3.d: Likewise.
 	* testsuite/gas/macros/app3.s: Likewise.
 	* testsuite/gas/macros/app4.d: Likewise.
 	* testsuite/gas/macros/app4.s: Likewise.
 	* testsuite/gas/macros/app4b.s: Likewise.
 	* testsuite/gas/z80/suffix.d: Fix failure on ELF target.
 	* testsuite/gas/z80/z80.exp: Add new tests
 	* testsuite/gas/z80/dollar.d: New file.
 	* testsuite/gas/z80/dollar.s: New file.
 	* testsuite/gas/z80/ez80_adl_all.d: New file.
 	* testsuite/gas/z80/ez80_adl_all.s: New file.
 	* testsuite/gas/z80/ez80_adl_suf.d: New file.
 	* testsuite/gas/z80/ez80_isuf.s: New file.
 	* testsuite/gas/z80/ez80_z80_all.d: New file.
 	* testsuite/gas/z80/ez80_z80_all.s: New file.
 	* testsuite/gas/z80/ez80_z80_suf.d: New file.
 	* testsuite/gas/z80/r800_extra.d: New file.
 	* testsuite/gas/z80/r800_extra.s: New file.
 	* testsuite/gas/z80/r800_ii8.d: New file.
 	* testsuite/gas/z80/r800_z80_doc.d: New file.
 	* testsuite/gas/z80/z180.d: New file.
 	* testsuite/gas/z80/z180.s: New file.
 	* testsuite/gas/z80/z180_z80_doc.d: New file.
 	* testsuite/gas/z80/z80_doc.d: New file.
 	* testsuite/gas/z80/z80_doc.s: New file.
 	* testsuite/gas/z80/z80_ii8.d: New file.
 	* testsuite/gas/z80/z80_ii8.s: New file.
 	* testsuite/gas/z80/z80_in_f_c.d: New file.
 	* testsuite/gas/z80/z80_in_f_c.s: New file.
 	* testsuite/gas/z80/z80_op_ii_ld.d: New file.
 	* testsuite/gas/z80/z80_op_ii_ld.s: New file.
 	* testsuite/gas/z80/z80_out_c_0.d: New file.
 	* testsuite/gas/z80/z80_out_c_0.s: New file.
 	* testsuite/gas/z80/z80_reloc.d: New file.
 	* testsuite/gas/z80/z80_reloc.s: New file.
 	* testsuite/gas/z80/z80_sli.d: New file.
 	* testsuite/gas/z80/z80_sli.s: New file.
 
 2020-01-02  Szabolcs Nagy  <szabolcs.nagy@arm.com>
 
 	* config/tc-arm.c (parse_reg_list): Use REG_TYPE_RN instead of
 	REGLIST_RN.
 
 2020-01-01  Alan Modra  <amodra@gmail.com>
 
 	Update year range in copyright notice of all files.
diff --git a/gas/config/tc-tic4x.c b/gas/config/tc-tic4x.c
index 913120d9aba..cc477b62bbc 100644
--- a/gas/config/tc-tic4x.c
+++ b/gas/config/tc-tic4x.c
@@ -1656,669 +1656,669 @@ static int
 tic4x_operands_match (tic4x_inst_t *inst, tic4x_insn_t *tinsn, int check)
 {
   const char *args = inst->args;
   unsigned long opcode = inst->opcode;
   int num_operands = tinsn->num_operands;
   tic4x_operand_t *operand = tinsn->operands;
   expressionS *exp = &operand->expr;
   int ret = 1;
   int reg;
 
   /* Build the opcode, checking as we go to make sure that the
      operands match.
 
      If an operand matches, we modify insn or opcode appropriately,
      and do a "continue".  If an operand fails to match, we "break".  */
 
   tinsn->nchars = 4;		/* Instructions always 4 bytes.  */
   tinsn->reloc = NO_RELOC;
   tinsn->pcrel = 0;
 
   if (*args == '\0')
     {
       tinsn->opcode = opcode;
       return num_operands == 0;
     }
 
   for (;; ++args)
     {
       switch (*args)
 	{
 
 	case '\0':		/* End of args.  */
 	  if (num_operands == 1)
 	    {
 	      tinsn->opcode = opcode;
 	      return ret;
 	    }
 	  break;		/* Too many operands.  */
 
 	case '#':		/* This is only used for ldp.  */
 	  if (operand->mode != M_DIRECT && operand->mode != M_IMMED)
 	    break;
 	  /* While this looks like a direct addressing mode, we actually
 	     use an immediate mode form of ldiu or ldpk instruction.  */
 	  if (exp->X_op == O_constant)
 	    {
               if( ( IS_CPU_TIC4X (tic4x_cpu) && exp->X_add_number <= 65535 )
                   || ( IS_CPU_TIC3X (tic4x_cpu) && exp->X_add_number <= 255 ) )
                 {
                   INSERTS (opcode, exp->X_add_number, 15, 0);
                   continue;
                 }
               else
                 {
 		  if (!check)
                     as_bad (_("Immediate value of %ld is too large for ldf"),
                             (long) exp->X_add_number);
 		  ret = -1;
 		  continue;
                 }
 	    }
 	  else if (exp->X_op == O_symbol)
 	    {
 	      tinsn->reloc = BFD_RELOC_HI16;
 	      tinsn->exp = *exp;
 	      continue;
 	    }
 	  break;		/* Not direct (dp) addressing.  */
 
 	case '@':		/* direct.  */
 	  if (operand->mode != M_DIRECT)
 	    break;
 	  if (exp->X_op == O_constant)
             {
               /* Store only the 16 LSBs of the number.  */
               INSERTS (opcode, exp->X_add_number, 15, 0);
               continue;
 	    }
 	  else if (exp->X_op == O_symbol)
 	    {
 	      tinsn->reloc = BFD_RELOC_LO16;
 	      tinsn->exp = *exp;
 	      continue;
 	    }
 	  break;		/* Not direct addressing.  */
 
 	case 'A':
 	  if (operand->mode != M_REGISTER)
 	    break;
 	  reg = exp->X_add_number;
 	  if (reg >= REG_AR0 && reg <= REG_AR7)
 	    INSERTU (opcode, reg - REG_AR0, 24, 22);
 	  else
 	    {
               if (!check)
                 as_bad (_("Destination register must be ARn"));
 	      ret = -1;
 	    }
 	  continue;
 
 	case 'B':		/* Unsigned integer immediate.  */
 	  /* Allow br label or br @label.  */
 	  if (operand->mode != M_IMMED && operand->mode != M_DIRECT)
 	    break;
 	  if (exp->X_op == O_constant)
 	    {
 	      if (exp->X_add_number < (1 << 24))
 		{
 		  INSERTU (opcode, exp->X_add_number, 23, 0);
 		  continue;
 		}
 	      else
 		{
 		  if (!check)
                     as_bad (_("Immediate value of %ld is too large"),
                             (long) exp->X_add_number);
 		  ret = -1;
 		  continue;
 		}
 	    }
 	  if (IS_CPU_TIC4X (tic4x_cpu))
 	    {
 	      tinsn->reloc = BFD_RELOC_24_PCREL;
 	      tinsn->pcrel = 1;
 	    }
 	  else
 	    {
 	      tinsn->reloc = BFD_RELOC_24;
 	      tinsn->pcrel = 0;
 	    }
 	  tinsn->exp = *exp;
 	  continue;
 
 	case 'C':
 	  if (!IS_CPU_TIC4X (tic4x_cpu))
 	    break;
 	  if (operand->mode != M_INDIRECT)
 	    break;
 	  /* Require either *+ARn(disp) or *ARn.  */
 	  if (operand->expr.X_add_number != 0
 	      && operand->expr.X_add_number != 0x18)
 	    {
               if (!check)
                 as_bad (_("Invalid indirect addressing mode"));
               ret = -1;
 	      continue;
 	    }
 	  INSERTU (opcode, operand->aregno - REG_AR0, 2, 0);
 	  INSERTU (opcode, operand->disp, 7, 3);
 	  continue;
 
 	case 'E':
 	  if (!(operand->mode == M_REGISTER))
 	    break;
 	  INSERTU (opcode, exp->X_add_number, 7, 0);
 	  continue;
 
         case 'e':
           if (!(operand->mode == M_REGISTER))
             break;
 	  reg = exp->X_add_number;
 	  if ( (reg >= REG_R0 && reg <= REG_R7)
                || (IS_CPU_TIC4X (tic4x_cpu) && reg >= REG_R8 && reg <= REG_R11) )
 	    INSERTU (opcode, reg, 7, 0);
 	  else
 	    {
               if (!check)
                 as_bad (_("Register must be Rn"));
 	      ret = -1;
 	    }
           continue;
 
 	case 'F':
 	  if (operand->mode != M_IMMED_F
 	      && !(operand->mode == M_IMMED && exp->X_op == O_constant))
 	    break;
 
 	  if (operand->mode != M_IMMED_F)
 	    {
 	      /* OK, we 've got something like cmpf 0, r0
 	         Why can't they stick in a bloody decimal point ?!  */
 	      char string[16];
 
 	      /* Create floating point number string.  */
 	      sprintf (string, "%d.0", (int) exp->X_add_number);
 	      tic4x_atof (string, 's', operand->fwords);
 	    }
 
 	  INSERTU (opcode, operand->fwords[0], 15, 0);
 	  continue;
 
 	case 'G':
 	  if (operand->mode != M_REGISTER)
 	    break;
 	  INSERTU (opcode, exp->X_add_number, 15, 8);
 	  continue;
 
         case 'g':
 	  if (operand->mode != M_REGISTER)
 	    break;
 	  reg = exp->X_add_number;
 	  if ( (reg >= REG_R0 && reg <= REG_R7)
                || (IS_CPU_TIC4X (tic4x_cpu) && reg >= REG_R8 && reg <= REG_R11) )
 	    INSERTU (opcode, reg, 15, 8);
 	  else
 	    {
               if (!check)
                 as_bad (_("Register must be Rn"));
 	      ret = -1;
 	    }
           continue;
 
 	case 'H':
 	  if (operand->mode != M_REGISTER)
 	    break;
 	  reg = exp->X_add_number;
 	  if (reg >= REG_R0 && reg <= REG_R7)
 	    INSERTU (opcode, reg - REG_R0, 18, 16);
 	  else
 	    {
               if (!check)
                 as_bad (_("Register must be R0--R7"));
 	      ret = -1;
 	    }
 	  continue;
 
         case 'i':
           if ( operand->mode == M_REGISTER
                && tic4x_oplevel & OP_ENH )
             {
               reg = exp->X_add_number;
               INSERTU (opcode, reg, 4, 0);
               INSERTU (opcode, 7, 7, 5);
               continue;
             }
           /* Fallthrough */
 
 	case 'I':
 	  if (operand->mode != M_INDIRECT)
 	    break;
 	  if (operand->disp != 0 && operand->disp != 1)
 	    {
 	      if (IS_CPU_TIC4X (tic4x_cpu))
 		break;
               if (!check)
                 as_bad (_("Invalid indirect addressing mode displacement %d"),
                         operand->disp);
 	      ret = -1;
 	      continue;
 	    }
 	  INSERTU (opcode, operand->aregno - REG_AR0, 2, 0);
 	  INSERTU (opcode, operand->expr.X_add_number, 7, 3);
 	  continue;
 
         case 'j':
           if ( operand->mode == M_REGISTER
                && tic4x_oplevel & OP_ENH )
             {
               reg = exp->X_add_number;
               INSERTU (opcode, reg, 12, 8);
               INSERTU (opcode, 7, 15, 13);
               continue;
             }
           /* Fallthrough */
 
 	case 'J':
 	  if (operand->mode != M_INDIRECT)
 	    break;
 	  if (operand->disp != 0 && operand->disp != 1)
 	    {
 	      if (IS_CPU_TIC4X (tic4x_cpu))
 		break;
               if (!check)
                 as_bad (_("Invalid indirect addressing mode displacement %d"),
                         operand->disp);
 	      ret = -1;
 	      continue;
 	    }
 	  INSERTU (opcode, operand->aregno - REG_AR0, 10, 8);
 	  INSERTU (opcode, operand->expr.X_add_number, 15, 11);
 	  continue;
 
 	case 'K':
 	  if (operand->mode != M_REGISTER)
 	    break;
 	  reg = exp->X_add_number;
 	  if (reg >= REG_R0 && reg <= REG_R7)
 	    INSERTU (opcode, reg - REG_R0, 21, 19);
 	  else
 	    {
               if (!check)
                 as_bad (_("Register must be R0--R7"));
 	      ret = -1;
 	    }
 	  continue;
 
 	case 'L':
 	  if (operand->mode != M_REGISTER)
 	    break;
 	  reg = exp->X_add_number;
 	  if (reg >= REG_R0 && reg <= REG_R7)
 	    INSERTU (opcode, reg - REG_R0, 24, 22);
 	  else
 	    {
               if (!check)
                 as_bad (_("Register must be R0--R7"));
 	      ret = -1;
 	    }
 	  continue;
 
 	case 'M':
 	  if (operand->mode != M_REGISTER)
 	    break;
 	  reg = exp->X_add_number;
 	  if (reg == REG_R2 || reg == REG_R3)
 	    INSERTU (opcode, reg - REG_R2, 22, 22);
 	  else
 	    {
               if (!check)
                 as_bad (_("Destination register must be R2 or R3"));
 	      ret = -1;
 	    }
 	  continue;
 
 	case 'N':
 	  if (operand->mode != M_REGISTER)
 	    break;
 	  reg = exp->X_add_number;
 	  if (reg == REG_R0 || reg == REG_R1)
 	    INSERTU (opcode, reg - REG_R0, 23, 23);
 	  else
 	    {
               if (!check)
                 as_bad (_("Destination register must be R0 or R1"));
 	      ret = -1;
 	    }
 	  continue;
 
 	case 'O':
 	  if (!IS_CPU_TIC4X (tic4x_cpu))
 	    break;
 	  if (operand->mode != M_INDIRECT)
 	    break;
 	  /* Require either *+ARn(disp) or *ARn.  */
 	  if (operand->expr.X_add_number != 0
 	      && operand->expr.X_add_number != 0x18)
 	    {
               if (!check)
                 as_bad (_("Invalid indirect addressing mode"));
 	      ret = -1;
 	      continue;
 	    }
 	  INSERTU (opcode, operand->aregno - REG_AR0, 10, 8);
 	  INSERTU (opcode, operand->disp, 15, 11);
 	  continue;
 
 	case 'P':		/* PC relative displacement.  */
 	  /* Allow br label or br @label.  */
 	  if (operand->mode != M_IMMED && operand->mode != M_DIRECT)
 	    break;
 	  if (exp->X_op == O_constant)
 	    {
 	      if (exp->X_add_number >= -32768 && exp->X_add_number <= 32767)
 		{
 		  INSERTS (opcode, exp->X_add_number, 15, 0);
 		  continue;
 		}
 	      else
 		{
                   if (!check)
                     as_bad (_("Displacement value of %ld is too large"),
                             (long) exp->X_add_number);
 		  ret = -1;
 		  continue;
 		}
 	    }
 	  tinsn->reloc = BFD_RELOC_16_PCREL;
 	  tinsn->pcrel = 1;
 	  tinsn->exp = *exp;
 	  continue;
 
 	case 'Q':
 	  if (operand->mode != M_REGISTER)
 	    break;
 	  reg = exp->X_add_number;
 	  INSERTU (opcode, reg, 15, 0);
 	  continue;
 
         case 'q':
 	  if (operand->mode != M_REGISTER)
 	    break;
 	  reg = exp->X_add_number;
 	  if ( (reg >= REG_R0 && reg <= REG_R7)
                || (IS_CPU_TIC4X (tic4x_cpu) && reg >= REG_R8 && reg <= REG_R11) )
 	    INSERTU (opcode, reg, 15, 0);
 	  else
 	    {
               if (!check)
                 as_bad (_("Register must be Rn"));
 	      ret = -1;
 	    }
           continue;
 
 	case 'R':
 	  if (operand->mode != M_REGISTER)
 	    break;
 	  reg = exp->X_add_number;
 	  INSERTU (opcode, reg, 20, 16);
 	  continue;
 
         case 'r':
 	  if (operand->mode != M_REGISTER)
 	    break;
 	  reg = exp->X_add_number;
 	  if ( (reg >= REG_R0 && reg <= REG_R7)
                || (IS_CPU_TIC4X (tic4x_cpu) && reg >= REG_R8 && reg <= REG_R11) )
 	    INSERTU (opcode, reg, 20, 16);
 	  else
 	    {
               if (!check)
                 as_bad (_("Register must be Rn"));
 	      ret = -1;
 	    }
           continue;
 
 	case 'S':		/* Short immediate int.  */
 	  if (operand->mode != M_IMMED && operand->mode != M_HI)
 	    break;
 	  if (exp->X_op == O_big)
 	    {
               if (!check)
                 as_bad (_("Floating point number not valid in expression"));
 	      ret = -1;
 	      continue;
 	    }
 	  if (exp->X_op == O_constant)
 	    {
 	      if (exp->X_add_number >= -32768 && exp->X_add_number <= 65535)
 		{
 		  INSERTS (opcode, exp->X_add_number, 15, 0);
 		  continue;
 		}
 	      else
 		{
 		  if (!check)
                     as_bad (_("Signed immediate value %ld too large"),
                             (long) exp->X_add_number);
 		  ret = -1;
 		  continue;
 		}
 	    }
 	  else if (exp->X_op == O_symbol)
 	    {
 	      if (operand->mode == M_HI)
 		{
 		  tinsn->reloc = BFD_RELOC_HI16;
 		}
 	      else
 		{
 		  tinsn->reloc = BFD_RELOC_LO16;
 		}
 	      tinsn->exp = *exp;
 	      continue;
 	    }
 	  /* Handle cases like ldi foo - $, ar0  where foo
 	     is a forward reference.  Perhaps we should check
 	     for X_op == O_symbol and disallow things like
 	     ldi foo, ar0.  */
 	  tinsn->reloc = BFD_RELOC_16;
 	  tinsn->exp = *exp;
 	  continue;
 
 	case 'T':		/* 5-bit immediate value for tic4x stik.  */
 	  if (!IS_CPU_TIC4X (tic4x_cpu))
 	    break;
 	  if (operand->mode != M_IMMED)
 	    break;
 	  if (exp->X_op == O_constant)
 	    {
 	      if (exp->X_add_number < 16 && exp->X_add_number >= -16)
 		{
 		  INSERTS (opcode, exp->X_add_number, 20, 16);
 		  continue;
 		}
 	      else
 		{
                   if (!check)
                     as_bad (_("Immediate value of %ld is too large"),
                             (long) exp->X_add_number);
 		  ret = -1;
 		  continue;
 		}
 	    }
 	  break;		/* No relocations allowed.  */
 
 	case 'U':		/* Unsigned integer immediate.  */
 	  if (operand->mode != M_IMMED && operand->mode != M_HI)
 	    break;
 	  if (exp->X_op == O_constant)
 	    {
 	      if (exp->X_add_number < (1 << 16) && exp->X_add_number >= 0)
 		{
 		  INSERTU (opcode, exp->X_add_number, 15, 0);
 		  continue;
 		}
 	      else
 		{
                   if (!check)
                     as_bad (_("Unsigned immediate value %ld too large"),
                             (long) exp->X_add_number);
 		  ret = -1;
 		  continue;
 		}
 	    }
 	  else if (exp->X_op == O_symbol)
 	    {
 	      if (operand->mode == M_HI)
 		tinsn->reloc = BFD_RELOC_HI16;
 	      else
 		tinsn->reloc = BFD_RELOC_LO16;
 
 	      tinsn->exp = *exp;
 	      continue;
 	    }
 	  tinsn->reloc = BFD_RELOC_16;
 	  tinsn->exp = *exp;
 	  continue;
 
 	case 'V':		/* Trap numbers (immediate field).  */
 	  if (operand->mode != M_IMMED)
 	    break;
 	  if (exp->X_op == O_constant)
 	    {
 	      if (exp->X_add_number < 512 && IS_CPU_TIC4X (tic4x_cpu))
 		{
 		  INSERTU (opcode, exp->X_add_number, 8, 0);
 		  continue;
 		}
 	      else if (exp->X_add_number < 32 && IS_CPU_TIC3X (tic4x_cpu))
 		{
-		  INSERTU (opcode, exp->X_add_number | 0x20, 4, 0);
+		  INSERTU (opcode, exp->X_add_number | 0x20, 5, 0);
 		  continue;
 		}
 	      else
 		{
                   if (!check)
                     as_bad (_("Immediate value of %ld is too large"),
                             (long) exp->X_add_number);
 		  ret = -1;
 		  continue;
 		}
 	    }
 	  break;		/* No relocations allowed.  */
 
 	case 'W':		/* Short immediate int (0--7).  */
 	  if (!IS_CPU_TIC4X (tic4x_cpu))
 	    break;
 	  if (operand->mode != M_IMMED)
 	    break;
 	  if (exp->X_op == O_big)
 	    {
               if (!check)
                 as_bad (_("Floating point number not valid in expression"));
 	      ret = -1;
 	      continue;
 	    }
 	  if (exp->X_op == O_constant)
 	    {
 	      if (exp->X_add_number >= -256 && exp->X_add_number <= 127)
 		{
 		  INSERTS (opcode, exp->X_add_number, 7, 0);
 		  continue;
 		}
 	      else
 		{
                   if (!check)
                     as_bad (_("Immediate value %ld too large"),
                             (long) exp->X_add_number);
 		  ret = -1;
 		  continue;
 		}
 	    }
 	  tinsn->reloc = BFD_RELOC_16;
 	  tinsn->exp = *exp;
 	  continue;
 
 	case 'X':		/* Expansion register for tic4x.  */
 	  if (operand->mode != M_REGISTER)
 	    break;
 	  reg = exp->X_add_number;
 	  if (reg >= REG_IVTP && reg <= REG_TVTP)
 	    INSERTU (opcode, reg - REG_IVTP, 4, 0);
 	  else
 	    {
               if (!check)
                 as_bad (_("Register must be ivtp or tvtp"));
 	      ret = -1;
 	    }
 	  continue;
 
 	case 'Y':		/* Address register for tic4x lda.  */
 	  if (operand->mode != M_REGISTER)
 	    break;
 	  reg = exp->X_add_number;
 	  if (reg >= REG_AR0 && reg <= REG_SP)
 	    INSERTU (opcode, reg, 20, 16);
 	  else
 	    {
               if (!check)
                 as_bad (_("Register must be address register"));
 	      ret = -1;
 	    }
 	  continue;
 
 	case 'Z':		/* Expansion register for tic4x.  */
 	  if (operand->mode != M_REGISTER)
 	    break;
 	  reg = exp->X_add_number;
 	  if (reg >= REG_IVTP && reg <= REG_TVTP)
 	    INSERTU (opcode, reg - REG_IVTP, 20, 16);
 	  else
 	    {
               if (!check)
                 as_bad (_("Register must be ivtp or tvtp"));
 	      ret = -1;
 	    }
 	  continue;
 
 	case '*':
 	  if (operand->mode != M_INDIRECT)
 	    break;
 	  INSERTS (opcode, operand->disp, 7, 0);
 	  INSERTU (opcode, operand->aregno - REG_AR0, 10, 8);
 	  INSERTU (opcode, operand->expr.X_add_number, 15, 11);
 	  continue;
 
 	case '|':		/* treat as `,' if have ldi_ldi form.  */
 	  if (tinsn->parallel)
 	    {
 	      if (--num_operands < 0)
 		break;		/* Too few operands.  */
 	      operand++;
 	      if (operand->mode != M_PARALLEL)
 		break;
 	    }
 	  /* Fall through.  */
 
 	case ',':		/* Another operand.  */
 	  if (--num_operands < 0)
 	    break;		/* Too few operands.  */
 	  operand++;
 	  exp = &operand->expr;
 	  continue;
 
 	case ';':		/* Another optional operand.  */
 	  if (num_operands == 1 || operand[1].mode == M_PARALLEL)
 	    continue;
 	  if (--num_operands < 0)
 	    break;		/* Too few operands.  */
 	  operand++;
 	  exp = &operand->expr;
 	  continue;
 
 	default:
 	  BAD_CASE (*args);
 	}
       return 0;
     }
 }
diff --git a/include/ChangeLog b/include/ChangeLog
index 91765c5be61..3e2cdcaeb48 100644
--- a/include/ChangeLog
+++ b/include/ChangeLog
@@ -1,24 +1,30 @@
+2020-01-13  Alan Modra  <amodra@gmail.com>
+
+	* opcode/tic4x.h (EXTR): Delete.
+	(EXTRU, EXTRS, INSERTU, INSERTS): Rewrite without zero/sign
+	extension using shifts.  Do trim INSERTU value to specified bitfield.
+
 2020-01-10  Alan Modra  <amodra@gmail.com>
 
 	* opcode/spu.h: Formatting.
 	(UNSIGNED_EXTRACT): Use 1u.
 	(SIGNED_EXTRACT): Don't sign extend with shifts.
 	(DECODE_INSN_I9a, DECODE_INSN_I9b): Avoid left shift of signed value.
 	Keep result signed.
 	(DECODE_INSN_U9a, DECODE_INSN_U9b): Delete.
 
 2020-01-07  Shahab Vahedi  <shahab@synopsys.com>
 
 	* opcode/arc.h (insn_class_t): Add 'LLOCK' and 'SCOND'.
 
 2020-01-02  Sergey Belyashov  <sergey.belyashov@gmail.com>
 
 	* coff/internal.h: Add defintions of Z80 reloc names.
 
 2020-01-02  Christian Biesinger  <cbiesinger@google.com>
 
 	* opcode/s12z.h: Undef REG_Y.
 
 2020-01-01  Alan Modra  <amodra@gmail.com>
 
 	Update year range in copyright notice of all files.
diff --git a/include/opcode/tic4x.h b/include/opcode/tic4x.h
index 66b4ebfd082..04e3f0853d2 100644
--- a/include/opcode/tic4x.h
+++ b/include/opcode/tic4x.h
@@ -1,33 +1,35 @@
 /* Table of opcodes for the Texas Instruments TMS320C[34]X family.
 
    Copyright (C) 2002-2020 Free Software Foundation, Inc.
   
    Contributed by Michael P. Hayes (m.hayes@elec.canterbury.ac.nz)
    
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
    MA 02110-1301, USA.  */
 
 #define IS_CPU_TIC3X(v) ((v) == 30 || (v) == 31 || (v) == 32 || (v) == 33)
 #define IS_CPU_TIC4X(v) ((v) ==  0 || (v) == 40 || (v) == 44)
 
 /* Define some bitfield extraction/insertion macros.  */
-#define EXTR(inst, m, l)          ((inst) << (31 - (m)) >> (31 - ((m) - (l)))) 
-#define EXTRU(inst, m, l)         EXTR ((unsigned long)(inst), (m), (l))
-#define EXTRS(inst, m, l)         EXTR ((long)(inst), (m), (l))
-#define INSERTU(inst, val, m, l)  (inst |= ((val) << (l))) 
-#define INSERTS(inst, val, m, l)  INSERTU (inst, ((val) & ((1 << ((m) - (l) + 1)) - 1)), m, l)
+#define EXTRU(inst, m, l) \
+  (((inst) >> (l)) & ((2u << ((m) - (l))) - 1))
+#define EXTRS(inst, m, l) \
+  ((int) ((EXTRU (inst, m, l) ^ (1u << ((m) - (l)))) - (1u << ((m) - (l)))))
+#define INSERTU(inst, val, m, l) \
+  ((inst) |= ((val) & ((2u << ((m) - (l))) - 1)) << (l))
+#define INSERTS INSERTU
 
 /* Define register numbers.  */
 typedef enum
diff --git a/opcodes/ChangeLog b/opcodes/ChangeLog
index feeb7c55357..26d1e6c4a2c 100644
--- a/opcodes/ChangeLog
+++ b/opcodes/ChangeLog
@@ -1,121 +1,125 @@
+2020-01-13  Alan Modra  <amodra@gmail.com>
+
+	* tic4x-dis.c (tic4x_print_register): Remove dead code.
+
 2020-01-13  Alan Modra  <amodra@gmail.com>
 
 	* fr30-ibld.c: Regenerate.
 
 2020-01-13  Alan Modra  <amodra@gmail.com>
 
 	* xgate-dis.c (print_insn): Don't left shift signed value.
 	(ripBits): Formatting, use 1u.
 
 2020-01-10  Alan Modra  <amodra@gmail.com>
 
 	* tilepro-opc.c (parse_insn_tilepro): Make opval unsigned.
 	* tilegx-opc.c (parse_insn_tilegx): Likewise.  Delete raw_opval.
 
 2020-01-10  Alan Modra  <amodra@gmail.com>
 
 	* m10300-dis.c (disassemble): Move extraction of DREG, AREG, RREG,
 	and XRREG value earlier to avoid a shift with negative exponent.
 	* m10200-dis.c (disassemble): Similarly.
 
 2020-01-09  Nick Clifton  <nickc@redhat.com>
 
 	PR 25224
 	* z80-dis.c (ld_ii_ii): Use correct cast.
 
 2020-01-03  Sergey Belyashov  <sergey.belyashov@gmail.com>
 
 	PR 25224
 	* z80-dis.c (ld_ii_ii): Use character constant when checking
 	opcode byte value.
 
 2020-01-09  Jan Beulich  <jbeulich@suse.com>
 
 	* i386-dis.c (SEP_Fixup): New.
 	(SEP): Define.
 	(dis386_twobyte): Use it for sysenter/sysexit.
 	(enum x86_64_isa): Change amd64 enumerator to value 1.
 	(OP_J): Compare isa64 against intel64 instead of amd64.
 	* i386-opc.tbl (sysenter, sysexit): Split into AMD64 and Intel64
 	forms.
 	* i386-tbl.h: Re-generate.
 
 2020-01-08  Alan Modra  <amodra@gmail.com>
 
 	* z8k-dis.c: Include libiberty.h
 	(instr_data_s): Make max_fetched unsigned.
 	(z8k_lookup_instr): Make nibl_index and tabl_index unsigned.
 	Don't exceed byte_info bounds.
 	(output_instr): Make num_bytes unsigned.
 	(unpack_instr): Likewise for nibl_count and loop.
 	* z8kgen.c (gas <opcode_entry_type>): Make noperands, length and
 	idx unsigned.
 	* z8k-opc.h: Regenerate.
 
 2020-01-07  Shahab Vahedi  <shahab@synopsys.com>
 
 	* arc-tbl.h (llock): Use 'LLOCK' as class.
 	(llockd): Likewise.
 	(scond): Use 'SCOND' as class.
 	(scondd): Likewise.
 	(llockd): Set data_size_mode to 'C_ZZ_D' which is 64-bit.
 	(scondd): Likewise.
 
 2020-01-06  Alan Modra  <amodra@gmail.com>
 
 	* m32c-ibld.c: Regenerate.
 
 2020-01-06  Alan Modra  <amodra@gmail.com>
 
 	PR 25344
 	* z80-dis.c (suffix): Don't use a local struct buffer copy.
 	Peek at next byte to prevent recursion on repeated prefix bytes.
 	Ensure uninitialised "mybuf" is not accessed.
 	(print_insn_z80): Don't zero n_fetch and n_used here,..
 	(print_insn_z80_buf): ..do it here instead.
 
 2020-01-04  Alan Modra  <amodra@gmail.com>
 
 	* m32r-ibld.c: Regenerate.
 
 2020-01-04  Alan Modra  <amodra@gmail.com>
 
 	* cr16-dis.c (cr16_match_opcode): Avoid shift left of signed value.
 
 2020-01-04  Alan Modra  <amodra@gmail.com>
 
 	* crx-dis.c (match_opcode): Avoid shift left of signed value.
 
 2020-01-04  Alan Modra  <amodra@gmail.com>
 
 	* d30v-dis.c (print_insn): Avoid signed overflow in left shift.
 
 2020-01-03  Jan Beulich  <jbeulich@suse.com>
 
 	* aarch64-tbl.h (aarch64_opcode_table): Use
 	SVE_ADDR_RX_LSL{1,2,3} for LD1RO{H,W,D}.
 
 2020-01-03  Jan Beulich  <jbeulich@suse.com>
 
 	* aarch64-tbl.h (aarch64_opcode_table): Correct SIMD
 	forms of SUDOT and USDOT.
 
 2020-01-03  Jan Beulich  <jbeulich@suse.com>
 
 	* aarch64-tbl.h (aarch64_opcode_table): Drop 'i' from
 	uzip{1,2}.
 	* opcodes/aarch64-dis-2.c: Re-generate.
 
 2020-01-03  Jan Beulich  <jbeulich@suse.com>
 
 	* aarch64-tbl.h (aarch64_opcode_table): Correct 64-bit
 	FMMLA encoding.
 	* opcodes/aarch64-dis-2.c: Re-generate.
 
 2020-01-02  Sergey Belyashov  <sergey.belyashov@gmail.com>
 
 	* z80-dis.c: Add support for eZ80 and Z80 instructions.
 
 2020-01-01  Alan Modra  <amodra@gmail.com>
 
 	Update year range in copyright notice of all files.
diff --git a/opcodes/tic4x-dis.c b/opcodes/tic4x-dis.c
index 1d7946918b7..34e270b7138 100644
--- a/opcodes/tic4x-dis.c
+++ b/opcodes/tic4x-dis.c
@@ -131,27 +131,26 @@ static int
 tic4x_print_register (struct disassemble_info *info, unsigned long regno)
 {
   static tic4x_register_t ** registertable = NULL;
   unsigned int i;
 
   if (registertable == NULL)
     {
       registertable = xmalloc (sizeof (tic4x_register_t *) * REG_TABLE_SIZE);
       for (i = 0; i < tic3x_num_registers; i++)
 	registertable[tic3x_registers[i].regno]
 	  = (tic4x_register_t *) (tic3x_registers + i);
       if (IS_CPU_TIC4X (tic4x_version))
 	{
 	  /* Add C4x additional registers, overwriting
 	     any C3x registers if necessary.  */
 	  for (i = 0; i < tic4x_num_registers; i++)
 	    registertable[tic4x_registers[i].regno]
 	      = (tic4x_register_t *)(tic4x_registers + i);
 	}
     }
-  if (regno > (IS_CPU_TIC4X (tic4x_version) ? TIC4X_REG_MAX : TIC3X_REG_MAX)
-      || registertable[regno] == NULL)
+  if (regno > (IS_CPU_TIC4X (tic4x_version) ? TIC4X_REG_MAX : TIC3X_REG_MAX))
     return 0;
   if (info != NULL)
     (*info->fprintf_func) (info->stream, "%s", registertable[regno]->name);
   return 1;
 }
